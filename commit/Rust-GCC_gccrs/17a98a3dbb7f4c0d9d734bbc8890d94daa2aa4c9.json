{"sha": "17a98a3dbb7f4c0d9d734bbc8890d94daa2aa4c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTdhOThhM2RiYjdmNGMwZDlkNzM0YmJjODg5MGQ5NGRhYTJhYTRjOQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2019-12-16T10:34:17Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-12-16T10:34:17Z"}, "message": "[Ada] Fix couple of oversights in the implementation of AI12-0128\n\n2019-12-16  Eric Botcazou  <ebotcazou@adacore.com>\n\ngcc/ada/\n\n\t* sem_prag.adb (Atomic_Components): Remove local variable and\n\tfix consistency issues.  Call Component_Type on the Etype of E.\n\t(Independent_Components): Remove local variable.\n\t* sem_util.adb (Is_Subcomponent_Of_Atomic_Object): Properly deal\n\twith prefixes that are access values.\n\t* gcc-interface/trans.c (atomic_acces_t): New enumeral type.\n\t(node_is_atomic) <N_Indexed_Component>: Test the prefix.\n\t(node_has_volatile_full_access): Rename into...\n\t(node_is_volatile_full_access): ...this.\n\t(node_is_component): New predicare.\n\t(gnat_strip_type_conversion): Delete.\n\t(outer_atomic_access_required_p): Likewise.\n\t(atomic_access_required_p): Rename into...\n\t(get_atomic_access): ...this.  Implement the 3 different semantics\n\tof Atomic and Volatile_Full_Access.\n\t(simple_atomic_access_required_p): New predicate.\n\t(Call_to_gnu): Remove outer_atomic_access parameter and change the\n\ttype of atomic_access parameter to atomic_acces_t.  Replace call to\n\tatomic_access_required_p with simple_atomic_access_required_p for\n\tthe in direction and call get_atomic_access for the out direction\n\tinstead of [outer_]atomic_access_required_p.\n\t(lhs_or_actual_p): Constify local variables.\n\t(present_in_lhs_or_actual_p): Likewise.\n\t(gnat_to_gnu) <N_Identifier>: Replace call to atomic_access_required_p\n\twith simple_atomic_access_required_p.\n\t<N_Explicit_Dereference>: Likewise.\n\t<N_Indexed_Component>: Likewise.\n\t<N_Selected_Component>: Likewise.\n\t<N_Assignment_Statement>: Call get_atomic_access for the name instead\n\tof [outer_]atomic_access_required_p.  Adjust call to Call_to_gnu.\n\t<N_Function_Call>: Adjust call to Call_to_gnu.\n\t(get_controlling_type): Fix typo in comment.\n\nFrom-SVN: r279427", "tree": {"sha": "b0c6f91cdca1d6cdc90c3958f09b1c792abaf3b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0c6f91cdca1d6cdc90c3958f09b1c792abaf3b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/17a98a3dbb7f4c0d9d734bbc8890d94daa2aa4c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17a98a3dbb7f4c0d9d734bbc8890d94daa2aa4c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17a98a3dbb7f4c0d9d734bbc8890d94daa2aa4c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17a98a3dbb7f4c0d9d734bbc8890d94daa2aa4c9/comments", "author": null, "committer": null, "parents": [{"sha": "2f31b36248da8d0a895f2535d9c5e251b5e4595e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f31b36248da8d0a895f2535d9c5e251b5e4595e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f31b36248da8d0a895f2535d9c5e251b5e4595e"}], "stats": {"total": 346, "additions": 203, "deletions": 143}, "files": [{"sha": "d1af558033eebb864b5a36dc548a9cbf6aa7d427", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17a98a3dbb7f4c0d9d734bbc8890d94daa2aa4c9/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17a98a3dbb7f4c0d9d734bbc8890d94daa2aa4c9/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=17a98a3dbb7f4c0d9d734bbc8890d94daa2aa4c9", "patch": "@@ -1,3 +1,38 @@\n+2019-12-16  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* sem_prag.adb (Atomic_Components): Remove local variable and\n+\tfix consistency issues.  Call Component_Type on the Etype of E.\n+\t(Independent_Components): Remove local variable.\n+\t* sem_util.adb (Is_Subcomponent_Of_Atomic_Object): Properly deal\n+\twith prefixes that are access values.\n+\t* gcc-interface/trans.c (atomic_acces_t): New enumeral type.\n+\t(node_is_atomic) <N_Indexed_Component>: Test the prefix.\n+\t(node_has_volatile_full_access): Rename into...\n+\t(node_is_volatile_full_access): ...this.\n+\t(node_is_component): New predicare.\n+\t(gnat_strip_type_conversion): Delete.\n+\t(outer_atomic_access_required_p): Likewise.\n+\t(atomic_access_required_p): Rename into...\n+\t(get_atomic_access): ...this.  Implement the 3 different semantics\n+\tof Atomic and Volatile_Full_Access.\n+\t(simple_atomic_access_required_p): New predicate.\n+\t(Call_to_gnu): Remove outer_atomic_access parameter and change the\n+\ttype of atomic_access parameter to atomic_acces_t.  Replace call to\n+\tatomic_access_required_p with simple_atomic_access_required_p for\n+\tthe in direction and call get_atomic_access for the out direction\n+\tinstead of [outer_]atomic_access_required_p.\n+\t(lhs_or_actual_p): Constify local variables.\n+\t(present_in_lhs_or_actual_p): Likewise.\n+\t(gnat_to_gnu) <N_Identifier>: Replace call to atomic_access_required_p\n+\twith simple_atomic_access_required_p.\n+\t<N_Explicit_Dereference>: Likewise.\n+\t<N_Indexed_Component>: Likewise.\n+\t<N_Selected_Component>: Likewise.\n+\t<N_Assignment_Statement>: Call get_atomic_access for the name instead\n+\tof [outer_]atomic_access_required_p.  Adjust call to Call_to_gnu.\n+\t<N_Function_Call>: Adjust call to Call_to_gnu.\n+\t(get_controlling_type): Fix typo in comment.\n+\n 2019-12-16  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* fe.h (Ada_Version_Type): New typedef."}, {"sha": "762ca465c9484c1f36a55bc4f944de64d14418f3", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 145, "deletions": 130, "changes": 275, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17a98a3dbb7f4c0d9d734bbc8890d94daa2aa4c9/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17a98a3dbb7f4c0d9d734bbc8890d94daa2aa4c9/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=17a98a3dbb7f4c0d9d734bbc8890d94daa2aa4c9", "patch": "@@ -3976,7 +3976,7 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n   return gnu_result;\n }\n \f\n-/* This page implements a form of Named Return Value optimization modelled\n+/* This page implements a form of Named Return Value optimization modeled\n    on the C++ optimization of the same name.  The main difference is that\n    we disregard any semantical considerations when applying it here, the\n    counterpart being that we don't try to apply it to semantically loaded\n@@ -4792,7 +4792,13 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n     rest_of_subprog_body_compilation (gnu_subprog_decl);\n }\n \f\n-/* Return true if GNAT_NODE references an Atomic entity.  */\n+/* The type of an atomic access.  */\n+\n+typedef enum { NOT_ATOMIC, SIMPLE_ATOMIC, OUTER_ATOMIC } atomic_acces_t;\n+\n+/* Return true if GNAT_NODE references an Atomic entity.  This is modeled on\n+   the Is_Atomic_Object predicate of the front-end, but additionally handles\n+   explicit dereferences.  */\n \n static bool\n node_is_atomic (Node_Id gnat_node)\n@@ -4809,17 +4815,14 @@ node_is_atomic (Node_Id gnat_node)\n       return Is_Atomic (gnat_entity) || Is_Atomic (Etype (gnat_entity));\n \n     case N_Selected_Component:\n-      gnat_entity = Entity (Selector_Name (gnat_node));\n-      return Is_Atomic (gnat_entity) || Is_Atomic (Etype (gnat_entity));\n+      return Is_Atomic (Etype (gnat_node))\n+\t     || Is_Atomic (Entity (Selector_Name (gnat_node)));\n \n     case N_Indexed_Component:\n-      if (Has_Atomic_Components (Etype (Prefix (gnat_node))))\n-\treturn true;\n-      if (Is_Entity_Name (Prefix (gnat_node))\n-\t  && Has_Atomic_Components (Entity (Prefix (gnat_node))))\n-\treturn true;\n-\n-      /* ... fall through ... */\n+      return Is_Atomic (Etype (gnat_node))\n+\t     || Has_Atomic_Components (Etype (Prefix (gnat_node)))\n+\t     || (Is_Entity_Name (Prefix (gnat_node))\n+\t\t && Has_Atomic_Components (Entity (Prefix (gnat_node))));\n \n     case N_Explicit_Dereference:\n       return Is_Atomic (Etype (gnat_node));\n@@ -4831,10 +4834,12 @@ node_is_atomic (Node_Id gnat_node)\n   return false;\n }\n \n-/* Return true if GNAT_NODE references a Volatile_Full_Access entity.  */\n+/* Return true if GNAT_NODE references a Volatile_Full_Access entity.  This is\n+   modeled on the Is_VFA_Object predicate of the front-end, but additionally\n+   handles explicit dereferences.  */\n \n static bool\n-node_has_volatile_full_access (Node_Id gnat_node)\n+node_is_volatile_full_access (Node_Id gnat_node)\n {\n   Entity_Id gnat_entity;\n \n@@ -4849,9 +4854,8 @@ node_has_volatile_full_access (Node_Id gnat_node)\n \t     || Is_Volatile_Full_Access (Etype (gnat_entity));\n \n     case N_Selected_Component:\n-      gnat_entity = Entity (Selector_Name (gnat_node));\n-      return Is_Volatile_Full_Access (gnat_entity)\n-\t     || Is_Volatile_Full_Access (Etype (gnat_entity));\n+      return Is_Volatile_Full_Access (Etype (gnat_node))\n+\t     || Is_Volatile_Full_Access (Entity (Selector_Name (gnat_node)));\n \n     case N_Indexed_Component:\n     case N_Explicit_Dereference:\n@@ -4864,73 +4868,42 @@ node_has_volatile_full_access (Node_Id gnat_node)\n   return false;\n }\n \n-/* Strip any type conversion on GNAT_NODE and return the result.  */\n+/* Return true if GNAT_NODE references a component of a larger object.  */\n \n-static Node_Id\n-gnat_strip_type_conversion (Node_Id gnat_node)\n+static inline bool\n+node_is_component (Node_Id gnat_node)\n {\n-  Node_Kind kind = Nkind (gnat_node);\n-\n-  if (kind == N_Type_Conversion || kind == N_Unchecked_Type_Conversion)\n-    gnat_node = Expression (gnat_node);\n-\n-  return gnat_node;\n+  const Node_Kind k = Nkind (gnat_node);\n+  return\n+    (k == N_Indexed_Component || k == N_Selected_Component || k == N_Slice);\n }\n \n-/* Return true if GNAT_NODE requires outer atomic access, i.e. atomic access\n-   of an object of which GNAT_NODE is a component.  */\n-\n-static bool\n-outer_atomic_access_required_p (Node_Id gnat_node)\n-{\n-  gnat_node = gnat_strip_type_conversion (gnat_node);\n-\n-  while (true)\n-    {\n-      switch (Nkind (gnat_node))\n-\t{\n-\tcase N_Identifier:\n-\tcase N_Expanded_Name:\n-\t  if (No (Renamed_Object (Entity (gnat_node))))\n-\t    return false;\n-\t  gnat_node\n-\t    = gnat_strip_type_conversion (Renamed_Object (Entity (gnat_node)));\n-\t  break;\n+/* Compute whether GNAT_NODE requires atomic access and set TYPE to the type\n+   of access and SYNC according to the associated synchronization setting.\n \n-\tcase N_Indexed_Component:\n-\tcase N_Selected_Component:\n-\tcase N_Slice:\n-\t  gnat_node = gnat_strip_type_conversion (Prefix (gnat_node));\n-\t  if (node_has_volatile_full_access (gnat_node))\n-\t    return true;\n-\t  break;\n+   We implement 3 different semantics of atomicity in this function:\n \n-\tdefault:\n-\t  return false;\n-\t}\n-    }\n-\n-  gcc_unreachable ();\n-}\n+     1. the Ada 95/2005/2012 semantics of the Atomic aspect/pragma,\n+     2. the Ada 2020 semantics of the Atomic aspect/pragma,\n+     3. the semantics of the Volatile_Full_Access GNAT aspect/pragma.\n \n-/* Return true if GNAT_NODE requires atomic access and set SYNC according to\n-   the associated synchronization setting.  */\n+  They are mutually exclusive and the FE should have rejected conflicts.  */\n \n-static bool\n-atomic_access_required_p (Node_Id gnat_node, bool *sync)\n+static void\n+get_atomic_access (Node_Id gnat_node, atomic_acces_t *type, bool *sync)\n {\n-  const Node_Id gnat_parent = Parent (gnat_node);\n+  Node_Id gnat_parent, gnat_temp;\n   unsigned char attr_id;\n-  bool as_a_whole = true;\n \n-  /* First, scan the parent to find out cases where the flag is irrelevant.  */\n+  /* First, scan the parent to filter out irrelevant cases.  */\n+  gnat_parent = Parent (gnat_node);\n   switch (Nkind (gnat_parent))\n     {\n     case N_Attribute_Reference:\n       attr_id = Get_Attribute_Id (Attribute_Name (gnat_parent));\n       /* Do not mess up machine code insertions.  */\n       if (attr_id == Attr_Asm_Input || attr_id == Attr_Asm_Output)\n-\treturn false;\n+\tgoto not_atomic;\n \n       /* Nothing to do if we are the prefix of an attribute, since we do not\n \t want an atomic access for things like 'Size.  */\n@@ -4940,45 +4913,86 @@ atomic_access_required_p (Node_Id gnat_node, bool *sync)\n     case N_Reference:\n       /* The N_Reference node is like an attribute.  */\n       if (Prefix (gnat_parent) == gnat_node)\n-\treturn false;\n-      break;\n-\n-    case N_Indexed_Component:\n-    case N_Selected_Component:\n-    case N_Slice:\n-      /* If we are the prefix, then the access is only partial.  */\n-      if (Prefix (gnat_parent) == gnat_node)\n-\tas_a_whole = false;\n+\tgoto not_atomic;\n       break;\n \n     case N_Object_Renaming_Declaration:\n       /* Nothing to do for the identifier in an object renaming declaration,\n          the renaming itself does not need atomic access.  */\n-      return false;\n+      goto not_atomic;\n \n     default:\n       break;\n     }\n \n-  /* Then, scan the node to find the atomic object.  */\n-  gnat_node = gnat_strip_type_conversion (gnat_node);\n+  /* Now strip any type conversion from GNAT_NODE.  */\n+  if (Nkind (gnat_node) == N_Type_Conversion\n+      || Nkind (gnat_node) == N_Unchecked_Type_Conversion)\n+    gnat_node = Expression (gnat_node);\n \n-  /* For Atomic itself, only reads and updates of the object as a whole require\n-     atomic access (RM C.6 (15)).  But for Volatile_Full_Access, all reads and\n-     updates require atomic access.  */\n-  if (!(as_a_whole && node_is_atomic (gnat_node))\n-      && !node_has_volatile_full_access (gnat_node))\n-    return false;\n+  /* Up to Ada 2012, for Atomic itself, only reads and updates of the object as\n+     a whole require atomic access (RM C.6(15)).  But, starting with Ada 2020,\n+     reads of or writes to a nonatomic subcomponent of the object also require\n+     atomic access (RM C.6(19)).  */\n+  if (node_is_atomic (gnat_node))\n+    {\n+      bool as_a_whole = true;\n \n-  /* If an outer atomic access will also be required, it cancels this one.  */\n-  if (outer_atomic_access_required_p (gnat_node))\n-    return false;\n+      /* If we are the prefix of the parent, then the access is partial.  */\n+      for (gnat_temp = gnat_node, gnat_parent = Parent (gnat_temp);\n+\t   node_is_component (gnat_parent) && Prefix (gnat_parent) == gnat_temp;\n+\t   gnat_temp = gnat_parent, gnat_parent = Parent (gnat_temp))\n+\tif (Ada_Version < Ada_2020 || node_is_atomic (gnat_parent))\n+\t  goto not_atomic;\n+\telse\n+\t  as_a_whole = false;\n \n-  *sync = Atomic_Sync_Required (gnat_node);\n+      /* We consider that partial accesses are not sequential actions and,\n+\t therefore, do not require synchronization.  */\n+      *type = SIMPLE_ATOMIC;\n+      *sync = as_a_whole ? Atomic_Sync_Required (gnat_node) : false;\n+      return;\n+    }\n \n-  return true;\n+  /* Look for an outer atomic access of a nonatomic subcomponent.  Note that,\n+     for VFA, we do this before looking at the node itself because we need to\n+     access the outermost VFA object atomically, unlike for Atomic where it is\n+     the innermost atomic object (RM C.6(19)).  */\n+  for (gnat_temp = gnat_node;\n+       node_is_component (gnat_temp);\n+       gnat_temp = Prefix (gnat_temp))\n+    if ((Ada_Version >= Ada_2020 && node_is_atomic (Prefix (gnat_temp)))\n+\t|| node_is_volatile_full_access (Prefix (gnat_temp)))\n+      {\n+\t*type = OUTER_ATOMIC;\n+\t*sync = false;\n+\treturn;\n+      }\n+\n+  /* Unlike Atomic, accessing a VFA object always requires atomic access.  */\n+  if (node_is_volatile_full_access (gnat_node))\n+    {\n+      *type = SIMPLE_ATOMIC;\n+      *sync = false;\n+      return;\n+    }\n+\n+not_atomic:\n+  *type = NOT_ATOMIC;\n+  *sync = false;\n }\n \f\n+\f/* Return true if GNAT_NODE requires simple atomic access and, if so, set SYNC\n+   according to the associated synchronization setting.  */\n+\n+static inline bool\n+simple_atomic_access_required_p (Node_Id gnat_node, bool *sync)\n+{\n+  atomic_acces_t type;\n+  get_atomic_access (gnat_node, &type, sync);\n+  return type == SIMPLE_ATOMIC;\n+}\n+\n /* Create a temporary variable with PREFIX and TYPE, and return it.  */\n \n static tree\n@@ -5013,14 +5027,13 @@ create_init_temporary (const char *prefix, tree gnu_init, tree *gnu_init_stmt,\n    GNU_RESULT_TYPE_P is a pointer to where we should place the result type.\n    If GNU_TARGET is non-null, this must be a function call on the RHS of a\n    N_Assignment_Statement and the result is to be placed into that object.\n-   If OUTER_ATOMIC_ACCESS is true, then the assignment to GNU_TARGET must be a\n-   load-modify-store sequence.  Otherwise, if ATOMIC_ACCESS is true, then the\n-   assignment to GNU_TARGET must be atomic.  If, in addition, ATOMIC_SYNC is\n-   true, then the assignment to GNU_TARGET requires atomic synchronization.  */\n+   ATOMIC_ACCESS is the type of atomic access to be used for the assignment\n+   to GNU_TARGET.  If, in addition, ATOMIC_SYNC is true, then the assignment\n+   to GNU_TARGET requires atomic synchronization.  */\n \n static tree\n Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n-\t     bool outer_atomic_access, bool atomic_access, bool atomic_sync)\n+\t     atomic_acces_t atomic_access, bool atomic_sync)\n {\n   const bool function_call = (Nkind (gnat_node) == N_Function_Call);\n   const bool returning_value = (function_call && !gnu_target);\n@@ -5047,7 +5060,8 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n   bool pushed_binding_level = false;\n   Entity_Id gnat_formal;\n   Node_Id gnat_actual;\n-  bool sync;\n+  atomic_acces_t aa_type;\n+  bool aa_sync;\n \n   gcc_assert (FUNC_OR_METHOD_TYPE_P (gnu_subprog_type));\n \n@@ -5346,8 +5360,8 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n       if (is_true_formal_parm\n \t  && !is_by_ref_formal_parm\n \t  && Ekind (gnat_formal) != E_Out_Parameter\n-\t  && atomic_access_required_p (gnat_actual, &sync))\n-\tgnu_actual = build_atomic_load (gnu_actual, sync);\n+\t  && simple_atomic_access_required_p (gnat_actual, &aa_sync))\n+\tgnu_actual = build_atomic_load (gnu_actual, aa_sync);\n \n       /* If this was a procedure call, we may not have removed any padding.\n \t So do it here for the part we will use as an input, if any.  */\n@@ -5647,16 +5661,19 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t\t  gnu_result = convert (TREE_TYPE (gnu_actual), gnu_result);\n \t      }\n \n+\t    get_atomic_access (gnat_actual, &aa_type, &aa_sync);\n+\n \t    /* If an outer atomic access is required for an actual parameter,\n \t       build the load-modify-store sequence.  */\n-\t    if (outer_atomic_access_required_p (gnat_actual))\n+\t    if (aa_type == OUTER_ATOMIC)\n \t      gnu_result\n \t\t= build_load_modify_store (gnu_actual, gnu_result, gnat_node);\n \n-\t    /* Or else, if simple atomic access is required, build the atomic\n+\t    /* Or else, if a simple atomic access is required, build the atomic\n \t       store.  */\n-\t    else if (atomic_access_required_p (gnat_actual, &sync))\n-\t      gnu_result = build_atomic_store (gnu_actual, gnu_result, sync);\n+\t    else if (aa_type == SIMPLE_ATOMIC)\n+\t      gnu_result\n+\t\t= build_atomic_store (gnu_actual, gnu_result, aa_sync);\n \n \t    /* Otherwise build a regular assignment.  */\n \t    else\n@@ -5708,10 +5725,10 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t    op_code = MODIFY_EXPR;\n \n \t  /* Use the required method to move the result to the target.  */\n-\t  if (outer_atomic_access)\n+\t  if (atomic_access == OUTER_ATOMIC)\n \t    gnu_call\n \t      = build_load_modify_store (gnu_target, gnu_call, gnat_node);\n-\t  else if (atomic_access)\n+\t  else if (atomic_access == SIMPLE_ATOMIC)\n \t    gnu_call = build_atomic_store (gnu_target, gnu_call, atomic_sync);\n \t  else\n \t    gnu_call\n@@ -6631,8 +6648,8 @@ Raise_Error_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n static bool\n lhs_or_actual_p (Node_Id gnat_node)\n {\n-  Node_Id gnat_parent = Parent (gnat_node);\n-  Node_Kind kind = Nkind (gnat_parent);\n+  const Node_Id gnat_parent = Parent (gnat_node);\n+  const Node_Kind kind = Nkind (gnat_parent);\n \n   if (kind == N_Assignment_Statement && Name (gnat_parent) == gnat_node)\n     return true;\n@@ -6653,12 +6670,10 @@ lhs_or_actual_p (Node_Id gnat_node)\n static bool\n present_in_lhs_or_actual_p (Node_Id gnat_node)\n {\n-  Node_Kind kind;\n-\n   if (lhs_or_actual_p (gnat_node))\n     return true;\n \n-  kind = Nkind (Parent (gnat_node));\n+  const Node_Kind kind = Nkind (Parent (gnat_node));\n \n   if ((kind == N_Type_Conversion || kind == N_Unchecked_Type_Conversion)\n       && lhs_or_actual_p (Parent (gnat_node)))\n@@ -6747,7 +6762,8 @@ gnat_to_gnu (Node_Id gnat_node)\n   tree gnu_result_type = void_type_node;\n   tree gnu_expr, gnu_lhs, gnu_rhs;\n   Node_Id gnat_temp;\n-  bool sync = false;\n+  atomic_acces_t aa_type;\n+  bool aa_sync;\n \n   /* Save node number for error message and set location information.  */\n   Current_Error_Node = gnat_node;\n@@ -6819,9 +6835,9 @@ gnat_to_gnu (Node_Id gnat_node)\n       gnu_result = Identifier_to_gnu (gnat_node, &gnu_result_type);\n \n       /* If atomic access is required on the RHS, build the atomic load.  */\n-      if (atomic_access_required_p (gnat_node, &sync)\n+      if (simple_atomic_access_required_p (gnat_node, &aa_sync)\n \t  && !present_in_lhs_or_actual_p (gnat_node))\n-\tgnu_result = build_atomic_load (gnu_result, sync);\n+\tgnu_result = build_atomic_load (gnu_result, aa_sync);\n       break;\n \n     case N_Integer_Literal:\n@@ -7153,9 +7169,9 @@ gnat_to_gnu (Node_Id gnat_node)\n       gnu_result = build_unary_op (INDIRECT_REF, NULL_TREE, gnu_result);\n \n       /* If atomic access is required on the RHS, build the atomic load.  */\n-      if (atomic_access_required_p (gnat_node, &sync)\n+      if (simple_atomic_access_required_p (gnat_node, &aa_sync)\n \t  && !present_in_lhs_or_actual_p (gnat_node))\n-\tgnu_result = build_atomic_load (gnu_result, sync);\n+\tgnu_result = build_atomic_load (gnu_result, aa_sync);\n       break;\n \n     case N_Indexed_Component:\n@@ -7230,9 +7246,9 @@ gnat_to_gnu (Node_Id gnat_node)\n \tgnu_result_type = get_unpadded_type (Etype (gnat_node));\n \n \t/* If atomic access is required on the RHS, build the atomic load.  */\n-\tif (atomic_access_required_p (gnat_node, &sync)\n+\tif (simple_atomic_access_required_p (gnat_node, &aa_sync)\n \t    && !present_in_lhs_or_actual_p (gnat_node))\n-\t  gnu_result = build_atomic_load (gnu_result, sync);\n+\t  gnu_result = build_atomic_load (gnu_result, aa_sync);\n       }\n       break;\n \n@@ -7308,9 +7324,9 @@ gnat_to_gnu (Node_Id gnat_node)\n \tgnu_result_type = get_unpadded_type (Etype (gnat_node));\n \n \t/* If atomic access is required on the RHS, build the atomic load.  */\n-\tif (atomic_access_required_p (gnat_node, &sync)\n+\tif (simple_atomic_access_required_p (gnat_node, &aa_sync)\n \t    && !present_in_lhs_or_actual_p (gnat_node))\n-\t  gnu_result = build_atomic_load (gnu_result, sync);\n+\t  gnu_result = build_atomic_load (gnu_result, aa_sync);\n       }\n       break;\n \n@@ -7811,14 +7827,10 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t\t\t       N_Raise_Storage_Error);\n       else if (Nkind (Expression (gnat_node)) == N_Function_Call)\n \t{\n-\t  bool outer_atomic_access\n-\t    = outer_atomic_access_required_p (Name (gnat_node));\n-\t  bool atomic_access\n-\t    = !outer_atomic_access\n-\t      && atomic_access_required_p (Name (gnat_node), &sync);\n+\t  get_atomic_access (Name (gnat_node), &aa_type, &aa_sync);\n \t  gnu_result\n \t    = Call_to_gnu (Expression (gnat_node), &gnu_result_type, gnu_lhs,\n-\t\t\t   outer_atomic_access, atomic_access, sync);\n+\t\t\t   aa_type, aa_sync);\n \t}\n       else\n \t{\n@@ -7848,14 +7860,17 @@ gnat_to_gnu (Node_Id gnat_node)\n \n \t  gigi_checking_assert (!Do_Range_Check (gnat_expr));\n \n+\t  get_atomic_access (Name (gnat_node), &aa_type, &aa_sync);\n+\n \t  /* If an outer atomic access is required on the LHS, build the load-\n \t     modify-store sequence.  */\n-\t  if (outer_atomic_access_required_p (Name (gnat_node)))\n+\t  if (aa_type == OUTER_ATOMIC)\n \t    gnu_result = build_load_modify_store (gnu_lhs, gnu_rhs, gnat_node);\n \n-\t  /* Or else, if atomic access is required, build the atomic store.  */\n-\t  else if (atomic_access_required_p (Name (gnat_node), &sync))\n-\t    gnu_result = build_atomic_store (gnu_lhs, gnu_rhs, sync);\n+\t  /* Or else, if a simple atomic access is required, build the atomic\n+\t     store.  */\n+\t  else if (aa_type == SIMPLE_ATOMIC)\n+\t    gnu_result = build_atomic_store (gnu_lhs, gnu_rhs, aa_sync);\n \n \t  /* Or else, use memset when the conditions are met.  This has already\n \t     been validated by Aggr_Assignment_OK_For_Backend in the front-end\n@@ -8176,7 +8191,7 @@ gnat_to_gnu (Node_Id gnat_node)\n     case N_Function_Call:\n     case N_Procedure_Call_Statement:\n       gnu_result = Call_to_gnu (gnat_node, &gnu_result_type, NULL_TREE,\n-\t\t\t\tfalse, false, false);\n+\t\t\t\tNOT_ATOMIC, false);\n       break;\n \n     /************************/\n@@ -8476,7 +8491,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t  /* If the operand is going to end up in memory,\n \t\t     mark it addressable.  Note that we don't test\n \t\t     allows_mem like in the input case below; this\n-\t\t     is modelled on the C front-end.  */\n+\t\t     is modeled on the C front-end.  */\n \t\t  if (!allows_reg)\n \t\t    {\n \t\t      output = remove_conversions (output, false);\n@@ -11123,7 +11138,7 @@ get_elaboration_procedure (void)\n static Entity_Id\n get_controlling_type (Entity_Id subprog)\n {\n-  /* This is modelled on Expand_Interface_Thunk.  */\n+  /* This is modeled on Expand_Interface_Thunk.  */\n   Entity_Id controlling_type = Etype (First_Formal (subprog));\n   if (Is_Access_Type (controlling_type))\n     controlling_type = Directly_Designated_Type (controlling_type);"}, {"sha": "b2177102781e3f6b1060b3c6d97c0125e0a78b45", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17a98a3dbb7f4c0d9d734bbc8890d94daa2aa4c9/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17a98a3dbb7f4c0d9d734bbc8890d94daa2aa4c9/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=17a98a3dbb7f4c0d9d734bbc8890d94daa2aa4c9", "patch": "@@ -14039,7 +14039,6 @@ package body Sem_Prag is\n             D    : Node_Id;\n             E    : Entity_Id;\n             E_Id : Node_Id;\n-            K    : Node_Kind;\n \n          begin\n             Check_Ada_83_Warning;\n@@ -14068,26 +14067,28 @@ package body Sem_Prag is\n             end if;\n \n             D := Declaration_Node (E);\n-            K := Nkind (D);\n \n-            if (K = N_Full_Type_Declaration and then Is_Array_Type (E))\n+            if (Nkind (D) = N_Full_Type_Declaration and then Is_Array_Type (E))\n               or else\n-                ((Ekind (E) = E_Constant or else Ekind (E) = E_Variable)\n-                   and then Nkind (D) = N_Object_Declaration\n+                (Nkind (D) = N_Object_Declaration\n+                   and then (Ekind (E) = E_Constant\n+                              or else\n+                             Ekind (E) = E_Variable)\n                    and then Nkind (Object_Definition (D)) =\n                                        N_Constrained_Array_Definition)\n             then\n-               --  The flag is set on the object, or on the base type\n+               --  The flag is set on the base type, or on the object\n \n-               if Nkind (D) /= N_Object_Declaration then\n+               if Nkind (D) = N_Full_Type_Declaration then\n                   E := Base_Type (E);\n                end if;\n \n                --  Atomic implies both Independent and Volatile\n \n                if Prag_Id = Pragma_Atomic_Components then\n                   if Ada_Version >= Ada_2020 then\n-                     Check_Atomic_VFA (Component_Type (E), VFA => False);\n+                     Check_Atomic_VFA\n+                       (Component_Type (Etype (E)), VFA => False);\n                   end if;\n                   Set_Has_Atomic_Components (E);\n                   Set_Has_Independent_Components (E);\n@@ -17963,7 +17964,6 @@ package body Sem_Prag is\n             D    : Node_Id;\n             E_Id : Node_Id;\n             E    : Entity_Id;\n-            K    : Node_Kind;\n \n          begin\n             Check_Ada_83_Warning;\n@@ -18030,11 +18030,10 @@ package body Sem_Prag is\n             end if;\n \n             D := Declaration_Node (E);\n-            K := Nkind (D);\n \n             --  The flag is set on the base type, or on the object\n \n-            if K = N_Full_Type_Declaration\n+            if Nkind (D) = N_Full_Type_Declaration\n               and then (Is_Array_Type (E) or else Is_Record_Type (E))\n             then\n                Set_Has_Independent_Components (Base_Type (E));"}, {"sha": "72126372f30bef5cbae23dd91d375848327ec143", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17a98a3dbb7f4c0d9d734bbc8890d94daa2aa4c9/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17a98a3dbb7f4c0d9d734bbc8890d94daa2aa4c9/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=17a98a3dbb7f4c0d9d734bbc8890d94daa2aa4c9", "patch": "@@ -17890,11 +17890,22 @@ package body Sem_Util is\n \n    begin\n       R := Get_Referenced_Object (N);\n+\n       while Nkind_In (R, N_Indexed_Component, N_Selected_Component, N_Slice)\n       loop\n          R := Get_Referenced_Object (Prefix (R));\n-         if Is_Atomic_Object (R) then\n-            return True;\n+\n+         --  If the prefix is an access value, only the designated type matters\n+\n+         if Is_Access_Type (Etype (R)) then\n+            if Is_Atomic (Designated_Type (Etype (R))) then\n+               return True;\n+            end if;\n+\n+         else\n+            if Is_Atomic (Etype (R)) or else Is_Atomic_Object (R) then\n+               return True;\n+            end if;\n          end if;\n       end loop;\n "}]}