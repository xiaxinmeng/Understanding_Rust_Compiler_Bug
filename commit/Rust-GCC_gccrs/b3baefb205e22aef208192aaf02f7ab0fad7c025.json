{"sha": "b3baefb205e22aef208192aaf02f7ab0fad7c025", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjNiYWVmYjIwNWUyMmFlZjIwODE5MmFhZjAyZjdhYjBmYWQ3YzAyNQ==", "commit": {"author": {"name": "Bernd Edlinger", "email": "bernd.edlinger@hotmail.de", "date": "2019-09-09T19:44:15Z"}, "committer": {"name": "Bernd Edlinger", "email": "edlinger@gcc.gnu.org", "date": "2019-09-09T19:44:15Z"}, "message": "expmed.c (extract_bit_field): Update function comment regarding alt_rtl.\n\n2019-09-09  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n\n        * expmed.c (extract_bit_field): Update function comment\n        regarding alt_rtl.\n        * expr.c (expand_expr_real): Update function comment\n        regarding alt_rtl.\n        (expand_misaligned_mem_ref): New helper function.\n        (expand_expr_real_2): Use expand_misaligned_mem_ref.\n        Remove duplicate assignment to \"base\" at case MEM_REF.\n        Remove a shadowed variable \"unsignedp\" at case VCE.\n\nFrom-SVN: r275541", "tree": {"sha": "8d09b733f3a6232a13ae5823b3155f274331bc14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d09b733f3a6232a13ae5823b3155f274331bc14"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3baefb205e22aef208192aaf02f7ab0fad7c025", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3baefb205e22aef208192aaf02f7ab0fad7c025", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3baefb205e22aef208192aaf02f7ab0fad7c025", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3baefb205e22aef208192aaf02f7ab0fad7c025/comments", "author": {"login": "bernd-edlinger", "id": 17638929, "node_id": "MDQ6VXNlcjE3NjM4OTI5", "avatar_url": "https://avatars.githubusercontent.com/u/17638929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bernd-edlinger", "html_url": "https://github.com/bernd-edlinger", "followers_url": "https://api.github.com/users/bernd-edlinger/followers", "following_url": "https://api.github.com/users/bernd-edlinger/following{/other_user}", "gists_url": "https://api.github.com/users/bernd-edlinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/bernd-edlinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bernd-edlinger/subscriptions", "organizations_url": "https://api.github.com/users/bernd-edlinger/orgs", "repos_url": "https://api.github.com/users/bernd-edlinger/repos", "events_url": "https://api.github.com/users/bernd-edlinger/events{/privacy}", "received_events_url": "https://api.github.com/users/bernd-edlinger/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b7f55c8e35981c5f2cb7c65d7d69f58e02ab0bcd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7f55c8e35981c5f2cb7c65d7d69f58e02ab0bcd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7f55c8e35981c5f2cb7c65d7d69f58e02ab0bcd"}], "stats": {"total": 129, "additions": 60, "deletions": 69}, "files": [{"sha": "fcf052a7643ed797c3c8782c746923f7052f4f3b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3baefb205e22aef208192aaf02f7ab0fad7c025/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3baefb205e22aef208192aaf02f7ab0fad7c025/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b3baefb205e22aef208192aaf02f7ab0fad7c025", "patch": "@@ -1,3 +1,14 @@\n+2019-09-09  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n+\n+\t* expmed.c (extract_bit_field): Update function comment\n+\tregarding alt_rtl.\n+\t* expr.c (expand_expr_real): Update function comment\n+\tregarding alt_rtl.\n+\t(expand_misaligned_mem_ref): New helper function.\n+\t(expand_expr_real_2): Use expand_misaligned_mem_ref.\n+\tRemove duplicate assignment to \"base\" at case MEM_REF.\n+\tRemove a shadowed variable \"unsignedp\" at case VCE. \n+\n 2019-09-09  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* regset.h (regs_invalidated_by_call_regset): Delete."}, {"sha": "f1975fe33fe6ace731be3ef424928d6c1cf5fe33", "filename": "gcc/expmed.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3baefb205e22aef208192aaf02f7ab0fad7c025/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3baefb205e22aef208192aaf02f7ab0fad7c025/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=b3baefb205e22aef208192aaf02f7ab0fad7c025", "patch": "@@ -2046,7 +2046,10 @@ extract_integral_bit_field (rtx op0, opt_scalar_int_mode op0_mode,\n    If a TARGET is specified and we can store in it at no extra cost,\n    we do so, and return TARGET.\n    Otherwise, we return a REG of mode TMODE or MODE, with TMODE preferred\n-   if they are equally easy.  */\n+   if they are equally easy.\n+\n+   If the result can be stored at TARGET, and ALT_RTL is non-NULL,\n+   then *ALT_RTL is set to TARGET (before legitimziation).  */\n \n rtx\n extract_bit_field (rtx str_rtx, poly_uint64 bitsize, poly_uint64 bitnum,"}, {"sha": "2f2b53f8b6905013b4214eea137d67c666b0c795", "filename": "gcc/expr.c", "status": "modified", "additions": 45, "deletions": 68, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3baefb205e22aef208192aaf02f7ab0fad7c025/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3baefb205e22aef208192aaf02f7ab0fad7c025/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=b3baefb205e22aef208192aaf02f7ab0fad7c025", "patch": "@@ -8261,6 +8261,8 @@ expand_constructor (tree exp, rtx target, enum expand_modifier modifier,\n    DECL_RTL of the VAR_DECL.  *ALT_RTL is also set if EXP is a\n    COMPOUND_EXPR whose second argument is such a VAR_DECL, and so on\n    recursively.\n+   If the result can be stored at TARGET, and ALT_RTL is non-NULL,\n+   then *ALT_RTL is set to TARGET (before legitimziation).\n \n    If INNER_REFERENCE_P is true, we are expanding an inner reference.\n    In this case, we don't adjust a returned MEM rtx that wouldn't be\n@@ -8398,6 +8400,40 @@ expand_cond_expr_using_cmove (tree treeop0 ATTRIBUTE_UNUSED,\n   return NULL_RTX;\n }\n \n+/* A helper function for expand_expr_real_2 to be used with a\n+   misaligned mem_ref TEMP.  Assume an unsigned type if UNSIGNEDP\n+   is nonzero, with alignment ALIGN in bits.\n+   Store the value at TARGET if possible (if TARGET is nonzero).\n+   Regardless of TARGET, we return the rtx for where the value is placed.\n+   If the result can be stored at TARGET, and ALT_RTL is non-NULL,\n+   then *ALT_RTL is set to TARGET (before legitimziation).  */\n+\n+static rtx\n+expand_misaligned_mem_ref (rtx temp, machine_mode mode, int unsignedp,\n+\t\t\t   unsigned int align, rtx target, rtx *alt_rtl)\n+{\n+  enum insn_code icode;\n+\n+  if ((icode = optab_handler (movmisalign_optab, mode))\n+      != CODE_FOR_nothing)\n+    {\n+      class expand_operand ops[2];\n+\n+      /* We've already validated the memory, and we're creating a\n+\t new pseudo destination.  The predicates really can't fail,\n+\t nor can the generator.  */\n+      create_output_operand (&ops[0], NULL_RTX, mode);\n+      create_fixed_operand (&ops[1], temp);\n+      expand_insn (icode, 2, ops);\n+      temp = ops[0].value;\n+    }\n+  else if (targetm.slow_unaligned_access (mode, align))\n+    temp = extract_bit_field (temp, GET_MODE_BITSIZE (mode),\n+\t\t\t      0, unsignedp, target,\n+\t\t\t      mode, mode, false, alt_rtl);\n+  return temp;\n+}\n+\n rtx\n expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n \t\t    enum expand_modifier modifier)\n@@ -10077,27 +10113,8 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t      && !inner_reference_p\n \t      && mode != BLKmode\n \t      && MEM_ALIGN (temp) < GET_MODE_ALIGNMENT (mode))\n-\t    {\n-\t      enum insn_code icode;\n-\n-\t      if ((icode = optab_handler (movmisalign_optab, mode))\n-\t\t  != CODE_FOR_nothing)\n-\t\t{\n-\t\t  class expand_operand ops[2];\n-\n-\t\t  /* We've already validated the memory, and we're creating a\n-\t\t     new pseudo destination.  The predicates really can't fail,\n-\t\t     nor can the generator.  */\n-\t\t  create_output_operand (&ops[0], NULL_RTX, mode);\n-\t\t  create_fixed_operand (&ops[1], temp);\n-\t\t  expand_insn (icode, 2, ops);\n-\t\t  temp = ops[0].value;\n-\t\t}\n-\t      else if (targetm.slow_unaligned_access (mode, MEM_ALIGN (temp)))\n-\t\ttemp = extract_bit_field (temp, GET_MODE_BITSIZE (mode),\n-\t\t\t\t\t  0, unsignedp, NULL_RTX,\n-\t\t\t\t\t  mode, mode, false, NULL);\n-\t    }\n+\t    temp = expand_misaligned_mem_ref (temp, mode, unsignedp,\n+\t\t\t\t\t      MEM_ALIGN (temp), NULL_RTX, NULL);\n \n \t  return temp;\n \t}\n@@ -10325,27 +10342,8 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t    && modifier != EXPAND_MEMORY\n \t    && mode != BLKmode\n \t    && align < GET_MODE_ALIGNMENT (mode))\n-\t  {\n-\t    enum insn_code icode;\n-\n-\t    if ((icode = optab_handler (movmisalign_optab, mode))\n-\t\t!= CODE_FOR_nothing)\n-\t      {\n-\t\tclass expand_operand ops[2];\n-\n-\t\t/* We've already validated the memory, and we're creating a\n-\t\t   new pseudo destination.  The predicates really can't fail,\n-\t\t   nor can the generator.  */\n-\t\tcreate_output_operand (&ops[0], NULL_RTX, mode);\n-\t\tcreate_fixed_operand (&ops[1], temp);\n-\t\texpand_insn (icode, 2, ops);\n-\t\ttemp = ops[0].value;\n-\t      }\n-\t    else if (targetm.slow_unaligned_access (mode, align))\n-\t      temp = extract_bit_field (temp, GET_MODE_BITSIZE (mode),\n-\t\t\t\t\t0, unsignedp, NULL_RTX,\n-\t\t\t\t\tmode, mode, false, NULL);\n-\t  }\n+\t  temp = expand_misaligned_mem_ref (temp, mode, unsignedp,\n+\t\t\t\t\t    align, NULL_RTX, NULL);\n \treturn temp;\n       }\n \n@@ -10357,7 +10355,6 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \tmachine_mode address_mode;\n \ttree base = TREE_OPERAND (exp, 0);\n \tgimple *def_stmt;\n-\tenum insn_code icode;\n \tunsigned align;\n \t/* Handle expansion of non-aliased memory with non-BLKmode.  That\n \t   might end up in a register.  */\n@@ -10387,7 +10384,6 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t    return expand_expr (exp, target, tmode, modifier);\n \t  }\n \taddress_mode = targetm.addr_space.address_mode (as);\n-\tbase = TREE_OPERAND (exp, 0);\n \tif ((def_stmt = get_def_for_expr (base, BIT_AND_EXPR)))\n \t  {\n \t    tree mask = gimple_assign_rhs2 (def_stmt);\n@@ -10414,27 +10410,9 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t    && !inner_reference_p\n \t    && mode != BLKmode\n \t    && align < GET_MODE_ALIGNMENT (mode))\n-\t  {\n-\t    if ((icode = optab_handler (movmisalign_optab, mode))\n-\t\t!= CODE_FOR_nothing)\n-\t      {\n-\t\tclass expand_operand ops[2];\n-\n-\t\t/* We've already validated the memory, and we're creating a\n-\t\t   new pseudo destination.  The predicates really can't fail,\n-\t\t   nor can the generator.  */\n-\t\tcreate_output_operand (&ops[0], NULL_RTX, mode);\n-\t\tcreate_fixed_operand (&ops[1], temp);\n-\t\texpand_insn (icode, 2, ops);\n-\t\ttemp = ops[0].value;\n-\t      }\n-\t    else if (targetm.slow_unaligned_access (mode, align))\n-\t      temp = extract_bit_field (temp, GET_MODE_BITSIZE (mode),\n-\t\t\t\t\t0, TYPE_UNSIGNED (TREE_TYPE (exp)),\n-\t\t\t\t\t(modifier == EXPAND_STACK_PARM\n-\t\t\t\t\t ? NULL_RTX : target),\n-\t\t\t\t\tmode, mode, false, alt_rtl);\n-\t  }\n+\t  temp = expand_misaligned_mem_ref (temp, mode, unsignedp, align,\n+\t\t\t\t\t    modifier == EXPAND_STACK_PARM\n+\t\t\t\t\t    ? NULL_RTX : target, alt_rtl);\n \tif (reverse\n \t    && modifier != EXPAND_MEMORY\n \t    && modifier != EXPAND_WRITE)\n@@ -11109,11 +11087,10 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \tmachine_mode mode1;\n \tpoly_int64 bitsize, bitpos, bytepos;\n \ttree offset;\n-\tint unsignedp, reversep, volatilep = 0;\n+\tint reversep, volatilep = 0;\n \ttree tem\n \t  = get_inner_reference (treeop0, &bitsize, &bitpos, &offset, &mode1,\n \t\t\t\t &unsignedp, &reversep, &volatilep);\n-\trtx orig_op0;\n \n \t/* ??? We should work harder and deal with non-zero offsets.  */\n \tif (!offset\n@@ -11123,7 +11100,7 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t    && known_eq (wi::to_poly_offset (TYPE_SIZE (type)), bitsize))\n \t  {\n \t    /* See the normal_inner_ref case for the rationale.  */\n-\t    orig_op0\n+\t    rtx orig_op0\n \t      = expand_expr_real (tem,\n \t\t\t\t  (TREE_CODE (TREE_TYPE (tem)) == UNION_TYPE\n \t\t\t\t   && (TREE_CODE (TYPE_SIZE (TREE_TYPE (tem)))"}]}