{"sha": "138cac6426259ed3ed98371f0aa0989df32c0724", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTM4Y2FjNjQyNjI1OWVkM2VkOTgzNzFmMGFhMDk4OWRmMzJjMDcyNA==", "commit": {"author": {"name": "Torvald Riegel", "email": "triegel@redhat.com", "date": "2015-05-26T10:45:56Z"}, "committer": {"name": "Torvald Riegel", "email": "torvald@gcc.gnu.org", "date": "2015-05-26T10:45:56Z"}, "message": "Fix memory order description in atomic ops built-ins docs.\n\nFrom-SVN: r223683", "tree": {"sha": "0c7e21ea224153c64524106b42959e006036fc3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c7e21ea224153c64524106b42959e006036fc3e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/138cac6426259ed3ed98371f0aa0989df32c0724", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/138cac6426259ed3ed98371f0aa0989df32c0724", "html_url": "https://github.com/Rust-GCC/gccrs/commit/138cac6426259ed3ed98371f0aa0989df32c0724", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/138cac6426259ed3ed98371f0aa0989df32c0724/comments", "author": {"login": "triegelrh", "id": 62400967, "node_id": "MDQ6VXNlcjYyNDAwOTY3", "avatar_url": "https://avatars.githubusercontent.com/u/62400967?v=4", "gravatar_id": "", "url": "https://api.github.com/users/triegelrh", "html_url": "https://github.com/triegelrh", "followers_url": "https://api.github.com/users/triegelrh/followers", "following_url": "https://api.github.com/users/triegelrh/following{/other_user}", "gists_url": "https://api.github.com/users/triegelrh/gists{/gist_id}", "starred_url": "https://api.github.com/users/triegelrh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/triegelrh/subscriptions", "organizations_url": "https://api.github.com/users/triegelrh/orgs", "repos_url": "https://api.github.com/users/triegelrh/repos", "events_url": "https://api.github.com/users/triegelrh/events{/privacy}", "received_events_url": "https://api.github.com/users/triegelrh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b68cf874f69d47c08479f4b0e7bcd1d55d65d06b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b68cf874f69d47c08479f4b0e7bcd1d55d65d06b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b68cf874f69d47c08479f4b0e7bcd1d55d65d06b"}], "stats": {"total": 181, "additions": 95, "deletions": 86}, "files": [{"sha": "b8305aa0ed8d679f6c0524abd078c006ec4d726e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/138cac6426259ed3ed98371f0aa0989df32c0724/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/138cac6426259ed3ed98371f0aa0989df32c0724/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=138cac6426259ed3ed98371f0aa0989df32c0724", "patch": "@@ -1,3 +1,9 @@\n+2015-05-26  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* doc/extend.texi (__atomic Builtins): Use 'memory order' instead of\n+\t'memory\tmodel' to align with C++11; fix description of memory orders;\n+\tfix a few typos.\n+\n 2015-05-26  Richard Biener  <rguenther@suse.de>\n \n \t* tree-vect-loop.c (vect_update_vf_for_slp): Split out from ..."}, {"sha": "d9adc65cd4d5cfc850a87739d1e240923afd8dc2", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 89, "deletions": 86, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/138cac6426259ed3ed98371f0aa0989df32c0724/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/138cac6426259ed3ed98371f0aa0989df32c0724/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=138cac6426259ed3ed98371f0aa0989df32c0724", "patch": "@@ -8907,19 +8907,19 @@ are not prevented from being speculated to before the barrier.\n @section Built-in Functions for Memory Model Aware Atomic Operations\n \n The following built-in functions approximately match the requirements\n-for C++11 concurrency and memory models.  They are all\n+for the C++11 memory model.  They are all\n identified by being prefixed with @samp{__atomic} and most are\n overloaded so that they work with multiple types.\n \n These functions are intended to replace the legacy @samp{__sync}\n-builtins.  The main difference is that the memory model to be used is a\n-parameter to the functions.  New code should always use the\n+builtins.  The main difference is that the memory order that is requested\n+is a parameter to the functions.  New code should always use the\n @samp{__atomic} builtins rather than the @samp{__sync} builtins.\n \n Note that the @samp{__atomic} builtins assume that programs will\n-conform to the C++11 model for concurrency.  In particular, they assume\n+conform to the C++11 memory model.  In particular, they assume\n that programs are free of data races.  See the C++11 standard for\n-detailed definitions.\n+detailed requirements.\n \n The @samp{__atomic} builtins can be used with any integral scalar or\n pointer type that is 1, 2, 4, or 8 bytes in length.  16-byte integral\n@@ -8928,137 +8928,140 @@ supported by the architecture.\n \n The four non-arithmetic functions (load, store, exchange, and \n compare_exchange) all have a generic version as well.  This generic\n-version works on any data type.  If the data type size maps to one\n-of the integral sizes that may have lock free support, the generic\n-version uses the lock free built-in function.  Otherwise an\n+version works on any data type.  It uses the lock-free built-in function\n+if the specific data type size makes that possible; otherwise, an\n external call is left to be resolved at run time.  This external call is\n the same format with the addition of a @samp{size_t} parameter inserted\n as the first parameter indicating the size of the object being pointed to.\n All objects must be the same size.\n \n-There are 6 different memory models that can be specified.  These map\n-to the C++11 memory models with the same names, see the C++11 standard\n+There are 6 different memory orders that can be specified.  These map\n+to the C++11 memory orders with the same names, see the C++11 standard\n or the @uref{http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync,GCC wiki\n on atomic synchronization} for detailed definitions.  Individual\n-targets may also support additional memory models for use on specific\n+targets may also support additional memory orders for use on specific\n architectures.  Refer to the target documentation for details of\n these.\n \n-The memory models integrate both barriers to code motion as well as\n-synchronization requirements with other threads.  They are listed here\n-in approximately ascending order of strength.\n+An atomic operation can both constrain code motion and\n+be mapped to hardware instructions for synchronization between threads\n+(e.g., a fence).  To which extent this happens is controlled by the\n+memory orders, which are listed here in approximately ascending order of\n+strength.  The description of each memory order is only meant to roughly\n+illustrate the effects and is not a specification; see the C++11\n+memory model for precise semantics.\n \n @table  @code\n @item __ATOMIC_RELAXED\n-No barriers or synchronization.\n+Implies no inter-thread ordering constraints.\n @item __ATOMIC_CONSUME\n-Data dependency only for both barrier and synchronization with another\n-thread.\n+This is currently implemented using the stronger @code{__ATOMIC_ACQUIRE}\n+memory order because of a deficiency in C++11's semantics for\n+@code{memory_order_consume}.\n @item __ATOMIC_ACQUIRE\n-Barrier to hoisting of code and synchronizes with release (or stronger)\n-semantic stores from another thread.\n+Creates an inter-thread happens-before constraint from the release (or\n+stronger) semantic store to this acquire load.  Can prevent hoisting\n+of code to before the operation.\n @item __ATOMIC_RELEASE\n-Barrier to sinking of code and synchronizes with acquire (or stronger)\n-semantic loads from another thread.\n+Creates an inter-thread happens-before constraint to acquire (or stronger)\n+semantic loads that read from this release store.  Can prevent sinking\n+of code to after the operation.\n @item __ATOMIC_ACQ_REL\n-Barrier in both directions and synchronizes with acquire loads and\n-release stores in another thread.\n+Combines the effects of both @code{__ATOMIC_ACQUIRE} and\n+@code{__ATOMIC_RELEASE}.\n @item __ATOMIC_SEQ_CST\n-Barrier in both directions and synchronizes with acquire loads and\n-release stores in all threads.\n+Enforces total ordering with all other @code{__ATOMIC_SEQ_CST} operations.\n @end table\n \n-Note that the scope of a C++11 memory model depends on whether or not\n-the function being called is a @emph{fence} (such as\n-@samp{__atomic_thread_fence}).  In a fence, all memory accesses are\n-subject to the restrictions of the memory model.  When the function is\n-an operation on a location, the restrictions apply only to those\n-memory accesses that could affect or that could depend on the\n-location.\n+Note that in the C++11 memory model, @emph{fences} (e.g.,\n+@samp{__atomic_thread_fence}) take effect in combination with other\n+atomic operations on specific memory locations (e.g., atomic loads);\n+operations on specific memory locations do not necessarily affect other\n+operations in the same way.\n \n Target architectures are encouraged to provide their own patterns for\n-each of these built-in functions.  If no target is provided, the original\n+each of the atomic built-in functions.  If no target is provided, the original\n non-memory model set of @samp{__sync} atomic built-in functions are\n used, along with any required synchronization fences surrounding it in\n order to achieve the proper behavior.  Execution in this case is subject\n to the same restrictions as those built-in functions.\n \n-If there is no pattern or mechanism to provide a lock free instruction\n+If there is no pattern or mechanism to provide a lock-free instruction\n sequence, a call is made to an external routine with the same parameters\n to be resolved at run time.\n \n-When implementing patterns for these built-in functions, the memory model\n+When implementing patterns for these built-in functions, the memory order\n parameter can be ignored as long as the pattern implements the most\n-restrictive @code{__ATOMIC_SEQ_CST} model.  Any of the other memory models\n-execute correctly with this memory model but they may not execute as\n+restrictive @code{__ATOMIC_SEQ_CST} memory order.  Any of the other memory\n+orders execute correctly with this memory order but they may not execute as\n efficiently as they could with a more appropriate implementation of the\n relaxed requirements.\n \n-Note that the C++11 standard allows for the memory model parameter to be\n+Note that the C++11 standard allows for the memory order parameter to be\n determined at run time rather than at compile time.  These built-in\n functions map any run-time value to @code{__ATOMIC_SEQ_CST} rather\n than invoke a runtime library call or inline a switch statement.  This is\n standard compliant, safe, and the simplest approach for now.\n \n-The memory model parameter is a signed int, but only the lower 16 bits are\n-reserved for the memory model.  The remainder of the signed int is reserved\n+The memory order parameter is a signed int, but only the lower 16 bits are\n+reserved for the memory order.  The remainder of the signed int is reserved\n for target use and should be 0.  Use of the predefined atomic values\n ensures proper usage.\n \n-@deftypefn {Built-in Function} @var{type} __atomic_load_n (@var{type} *ptr, int memmodel)\n+@deftypefn {Built-in Function} @var{type} __atomic_load_n (@var{type} *ptr, int memorder)\n This built-in function implements an atomic load operation.  It returns the\n contents of @code{*@var{ptr}}.\n \n-The valid memory model variants are\n+The valid memory order variants are\n @code{__ATOMIC_RELAXED}, @code{__ATOMIC_SEQ_CST}, @code{__ATOMIC_ACQUIRE},\n and @code{__ATOMIC_CONSUME}.\n \n @end deftypefn\n \n-@deftypefn {Built-in Function} void __atomic_load (@var{type} *ptr, @var{type} *ret, int memmodel)\n+@deftypefn {Built-in Function} void __atomic_load (@var{type} *ptr, @var{type} *ret, int memorder)\n This is the generic version of an atomic load.  It returns the\n contents of @code{*@var{ptr}} in @code{*@var{ret}}.\n \n @end deftypefn\n \n-@deftypefn {Built-in Function} void __atomic_store_n (@var{type} *ptr, @var{type} val, int memmodel)\n+@deftypefn {Built-in Function} void __atomic_store_n (@var{type} *ptr, @var{type} val, int memorder)\n This built-in function implements an atomic store operation.  It writes \n @code{@var{val}} into @code{*@var{ptr}}.  \n \n-The valid memory model variants are\n+The valid memory order variants are\n @code{__ATOMIC_RELAXED}, @code{__ATOMIC_SEQ_CST}, and @code{__ATOMIC_RELEASE}.\n \n @end deftypefn\n \n-@deftypefn {Built-in Function} void __atomic_store (@var{type} *ptr, @var{type} *val, int memmodel)\n+@deftypefn {Built-in Function} void __atomic_store (@var{type} *ptr, @var{type} *val, int memorder)\n This is the generic version of an atomic store.  It stores the value\n of @code{*@var{val}} into @code{*@var{ptr}}.\n \n @end deftypefn\n \n-@deftypefn {Built-in Function} @var{type} __atomic_exchange_n (@var{type} *ptr, @var{type} val, int memmodel)\n+@deftypefn {Built-in Function} @var{type} __atomic_exchange_n (@var{type} *ptr, @var{type} val, int memorder)\n This built-in function implements an atomic exchange operation.  It writes\n @var{val} into @code{*@var{ptr}}, and returns the previous contents of\n @code{*@var{ptr}}.\n \n-The valid memory model variants are\n+The valid memory order variants are\n @code{__ATOMIC_RELAXED}, @code{__ATOMIC_SEQ_CST}, @code{__ATOMIC_ACQUIRE},\n @code{__ATOMIC_RELEASE}, and @code{__ATOMIC_ACQ_REL}.\n \n @end deftypefn\n \n-@deftypefn {Built-in Function} void __atomic_exchange (@var{type} *ptr, @var{type} *val, @var{type} *ret, int memmodel)\n+@deftypefn {Built-in Function} void __atomic_exchange (@var{type} *ptr, @var{type} *val, @var{type} *ret, int memorder)\n This is the generic version of an atomic exchange.  It stores the\n contents of @code{*@var{val}} into @code{*@var{ptr}}. The original value\n of @code{*@var{ptr}} is copied into @code{*@var{ret}}.\n \n @end deftypefn\n \n-@deftypefn {Built-in Function} bool __atomic_compare_exchange_n (@var{type} *ptr, @var{type} *expected, @var{type} desired, bool weak, int success_memmodel, int failure_memmodel)\n+@deftypefn {Built-in Function} bool __atomic_compare_exchange_n (@var{type} *ptr, @var{type} *expected, @var{type} desired, bool weak, int success_memorder, int failure_memorder)\n This built-in function implements an atomic compare and exchange operation.\n This compares the contents of @code{*@var{ptr}} with the contents of\n @code{*@var{expected}}. If equal, the operation is a @emph{read-modify-write}\n-which writes @var{desired} into @code{*@var{ptr}}.  If they are not\n+operation that writes @var{desired} into @code{*@var{ptr}}.  If they are not\n equal, the operation is a @emph{read} and the current contents of\n @code{*@var{ptr}} is written into @code{*@var{expected}}.  @var{weak} is true\n for weak compare_exchange, and false for the strong variation.  Many targets \n@@ -9067,59 +9070,59 @@ the strong variation.\n \n True is returned if @var{desired} is written into\n @code{*@var{ptr}} and the operation is considered to conform to the\n-memory model specified by @var{success_memmodel}.  There are no\n-restrictions on what memory model can be used here.\n+memory order specified by @var{success_memorder}.  There are no\n+restrictions on what memory order can be used here.\n \n False is returned otherwise, and the operation is considered to conform\n-to @var{failure_memmodel}. This memory model cannot be\n+to @var{failure_memorder}. This memory order cannot be\n @code{__ATOMIC_RELEASE} nor @code{__ATOMIC_ACQ_REL}.  It also cannot be a\n-stronger model than that specified by @var{success_memmodel}.\n+stronger order than that specified by @var{success_memorder}.\n \n @end deftypefn\n \n-@deftypefn {Built-in Function} bool __atomic_compare_exchange (@var{type} *ptr, @var{type} *expected, @var{type} *desired, bool weak, int success_memmodel, int failure_memmodel)\n+@deftypefn {Built-in Function} bool __atomic_compare_exchange (@var{type} *ptr, @var{type} *expected, @var{type} *desired, bool weak, int success_memorder, int failure_memorder)\n This built-in function implements the generic version of\n @code{__atomic_compare_exchange}.  The function is virtually identical to\n @code{__atomic_compare_exchange_n}, except the desired value is also a\n pointer.\n \n @end deftypefn\n \n-@deftypefn {Built-in Function} @var{type} __atomic_add_fetch (@var{type} *ptr, @var{type} val, int memmodel)\n-@deftypefnx {Built-in Function} @var{type} __atomic_sub_fetch (@var{type} *ptr, @var{type} val, int memmodel)\n-@deftypefnx {Built-in Function} @var{type} __atomic_and_fetch (@var{type} *ptr, @var{type} val, int memmodel)\n-@deftypefnx {Built-in Function} @var{type} __atomic_xor_fetch (@var{type} *ptr, @var{type} val, int memmodel)\n-@deftypefnx {Built-in Function} @var{type} __atomic_or_fetch (@var{type} *ptr, @var{type} val, int memmodel)\n-@deftypefnx {Built-in Function} @var{type} __atomic_nand_fetch (@var{type} *ptr, @var{type} val, int memmodel)\n+@deftypefn {Built-in Function} @var{type} __atomic_add_fetch (@var{type} *ptr, @var{type} val, int memorder)\n+@deftypefnx {Built-in Function} @var{type} __atomic_sub_fetch (@var{type} *ptr, @var{type} val, int memorder)\n+@deftypefnx {Built-in Function} @var{type} __atomic_and_fetch (@var{type} *ptr, @var{type} val, int memorder)\n+@deftypefnx {Built-in Function} @var{type} __atomic_xor_fetch (@var{type} *ptr, @var{type} val, int memorder)\n+@deftypefnx {Built-in Function} @var{type} __atomic_or_fetch (@var{type} *ptr, @var{type} val, int memorder)\n+@deftypefnx {Built-in Function} @var{type} __atomic_nand_fetch (@var{type} *ptr, @var{type} val, int memorder)\n These built-in functions perform the operation suggested by the name, and\n return the result of the operation. That is,\n \n @smallexample\n @{ *ptr @var{op}= val; return *ptr; @}\n @end smallexample\n \n-All memory models are valid.\n+All memory orders are valid.\n \n @end deftypefn\n \n-@deftypefn {Built-in Function} @var{type} __atomic_fetch_add (@var{type} *ptr, @var{type} val, int memmodel)\n-@deftypefnx {Built-in Function} @var{type} __atomic_fetch_sub (@var{type} *ptr, @var{type} val, int memmodel)\n-@deftypefnx {Built-in Function} @var{type} __atomic_fetch_and (@var{type} *ptr, @var{type} val, int memmodel)\n-@deftypefnx {Built-in Function} @var{type} __atomic_fetch_xor (@var{type} *ptr, @var{type} val, int memmodel)\n-@deftypefnx {Built-in Function} @var{type} __atomic_fetch_or (@var{type} *ptr, @var{type} val, int memmodel)\n-@deftypefnx {Built-in Function} @var{type} __atomic_fetch_nand (@var{type} *ptr, @var{type} val, int memmodel)\n+@deftypefn {Built-in Function} @var{type} __atomic_fetch_add (@var{type} *ptr, @var{type} val, int memorder)\n+@deftypefnx {Built-in Function} @var{type} __atomic_fetch_sub (@var{type} *ptr, @var{type} val, int memorder)\n+@deftypefnx {Built-in Function} @var{type} __atomic_fetch_and (@var{type} *ptr, @var{type} val, int memorder)\n+@deftypefnx {Built-in Function} @var{type} __atomic_fetch_xor (@var{type} *ptr, @var{type} val, int memorder)\n+@deftypefnx {Built-in Function} @var{type} __atomic_fetch_or (@var{type} *ptr, @var{type} val, int memorder)\n+@deftypefnx {Built-in Function} @var{type} __atomic_fetch_nand (@var{type} *ptr, @var{type} val, int memorder)\n These built-in functions perform the operation suggested by the name, and\n return the value that had previously been in @code{*@var{ptr}}.  That is,\n \n @smallexample\n @{ tmp = *ptr; *ptr @var{op}= val; return tmp; @}\n @end smallexample\n \n-All memory models are valid.\n+All memory orders are valid.\n \n @end deftypefn\n \n-@deftypefn {Built-in Function} bool __atomic_test_and_set (void *ptr, int memmodel)\n+@deftypefn {Built-in Function} bool __atomic_test_and_set (void *ptr, int memorder)\n \n This built-in function performs an atomic test-and-set operation on\n the byte at @code{*@var{ptr}}.  The byte is set to some implementation\n@@ -9128,11 +9131,11 @@ if the previous contents were ``set''.\n It should be only used for operands of type @code{bool} or @code{char}. For \n other types only part of the value may be set.\n \n-All memory models are valid.\n+All memory orders are valid.\n \n @end deftypefn\n \n-@deftypefn {Built-in Function} void __atomic_clear (bool *ptr, int memmodel)\n+@deftypefn {Built-in Function} void __atomic_clear (bool *ptr, int memorder)\n \n This built-in function performs an atomic clear operation on\n @code{*@var{ptr}}.  After the operation, @code{*@var{ptr}} contains 0.\n@@ -9141,22 +9144,22 @@ in conjunction with @code{__atomic_test_and_set}.\n For other types it may only clear partially. If the type is not @code{bool}\n prefer using @code{__atomic_store}.\n \n-The valid memory model variants are\n+The valid memory order variants are\n @code{__ATOMIC_RELAXED}, @code{__ATOMIC_SEQ_CST}, and\n @code{__ATOMIC_RELEASE}.\n \n @end deftypefn\n \n-@deftypefn {Built-in Function} void __atomic_thread_fence (int memmodel)\n+@deftypefn {Built-in Function} void __atomic_thread_fence (int memorder)\n \n This built-in function acts as a synchronization fence between threads\n-based on the specified memory model.\n+based on the specified memory order.\n \n All memory orders are valid.\n \n @end deftypefn\n \n-@deftypefn {Built-in Function} void __atomic_signal_fence (int memmodel)\n+@deftypefn {Built-in Function} void __atomic_signal_fence (int memorder)\n \n This built-in function acts as a synchronization fence between a thread\n and signal handlers based in the same thread.\n@@ -9168,7 +9171,7 @@ All memory orders are valid.\n @deftypefn {Built-in Function} bool __atomic_always_lock_free (size_t size,  void *ptr)\n \n This built-in function returns true if objects of @var{size} bytes always\n-generate lock free atomic instructions for the target architecture.  \n+generate lock-free atomic instructions for the target architecture.\n @var{size} must resolve to a compile-time constant and the result also\n resolves to a compile-time constant.\n \n@@ -9185,9 +9188,9 @@ if (_atomic_always_lock_free (sizeof (long long), 0))\n @deftypefn {Built-in Function} bool __atomic_is_lock_free (size_t size, void *ptr)\n \n This built-in function returns true if objects of @var{size} bytes always\n-generate lock free atomic instructions for the target architecture.  If\n-it is not known to be lock free a call is made to a runtime routine named\n-@code{__atomic_is_lock_free}.\n+generate lock-free atomic instructions for the target architecture.  If\n+the built-in function is not known to be lock-free, a call is made to a\n+runtime routine named @code{__atomic_is_lock_free}.\n \n @var{ptr} is an optional pointer to the object that may be used to determine\n alignment.  A value of 0 indicates typical alignment should be used.  The \n@@ -9258,20 +9261,20 @@ functions above, except they perform multiplication, instead of addition.\n \n The x86 architecture supports additional memory ordering flags\n to mark lock critical sections for hardware lock elision. \n-These must be specified in addition to an existing memory model to \n+These must be specified in addition to an existing memory order to\n atomic intrinsics.\n \n @table @code\n @item __ATOMIC_HLE_ACQUIRE\n Start lock elision on a lock variable.\n-Memory model must be @code{__ATOMIC_ACQUIRE} or stronger.\n+Memory order must be @code{__ATOMIC_ACQUIRE} or stronger.\n @item __ATOMIC_HLE_RELEASE\n End lock elision on a lock variable.\n-Memory model must be @code{__ATOMIC_RELEASE} or stronger.\n+Memory order must be @code{__ATOMIC_RELEASE} or stronger.\n @end table\n \n-When a lock acquire fails it is required for good performance to abort\n-the transaction quickly. This can be done with a @code{_mm_pause}\n+When a lock acquire fails, it is required for good performance to abort\n+the transaction quickly. This can be done with a @code{_mm_pause}.\n \n @smallexample\n #include <immintrin.h> // For _mm_pause"}]}