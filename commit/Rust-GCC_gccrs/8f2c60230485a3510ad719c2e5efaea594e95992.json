{"sha": "8f2c60230485a3510ad719c2e5efaea594e95992", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGYyYzYwMjMwNDg1YTM1MTBhZDcxOWMyZTVlZmFlYTU5NGU5NTk5Mg==", "commit": {"author": {"name": "Aaron Sawdey", "email": "acsawdey@linux.vnet.ibm.com", "date": "2018-01-08T15:07:06Z"}, "committer": {"name": "Aaron Sawdey", "email": "acsawdey@gcc.gnu.org", "date": "2018-01-08T15:07:06Z"}, "message": "rs6000.md (cceq_ior_compare): Remove * so I can use it to generate rtl.\n\n2018-01-08  Aaron Sawdey  <acsawdey@linux.vnet.ibm.com>\n\n\t* config/rs6000/rs6000.md (cceq_ior_compare): Remove * so I can use it\n\tto generate rtl.\n\t(cceq_ior_compare_complement): Give it a name so I can use it, and\n\tchange boolean_or_operator predicate to boolean_operator so it can\n\tbe used to generate a crand.\n\t(eqne): New code iterator.\n\t(bd/bd_neg): New code_attrs.\n\t(<bd>_<mode>): New name for ctr<mode>_internal[12] now combined into\n\ta single define_insn.\n\t(<bd>tf_<mode>): A new insn pattern for the conditional form branch\n\tdecrement (bdnzt/bdnzf/bdzt/bdzf).\n\t* config/rs6000/rs6000.c (rs6000_legitimate_combined_insn): Updated\n\twith the new names of the branch decrement patterns, and added the\n\tnames of the branch decrement conditional patterns.\n\nFrom-SVN: r256344", "tree": {"sha": "8134cf66ee2422604ebf19ded7af726ddc3689f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8134cf66ee2422604ebf19ded7af726ddc3689f0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8f2c60230485a3510ad719c2e5efaea594e95992", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f2c60230485a3510ad719c2e5efaea594e95992", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f2c60230485a3510ad719c2e5efaea594e95992", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f2c60230485a3510ad719c2e5efaea594e95992/comments", "author": null, "committer": null, "parents": [{"sha": "b33086c0a74ecc4ca0abb4011bb30564198f034e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b33086c0a74ecc4ca0abb4011bb30564198f034e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b33086c0a74ecc4ca0abb4011bb30564198f034e"}], "stats": {"total": 206, "additions": 141, "deletions": 65}, "files": [{"sha": "b5aeb0ec51965a16738f8f95a98ba464c043c664", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f2c60230485a3510ad719c2e5efaea594e95992/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f2c60230485a3510ad719c2e5efaea594e95992/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8f2c60230485a3510ad719c2e5efaea594e95992", "patch": "@@ -1,3 +1,20 @@\n+2018-01-08  Aaron Sawdey  <acsawdey@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/rs6000.md (cceq_ior_compare): Remove * so I can use it\n+\tto generate rtl.\n+\t(cceq_ior_compare_complement): Give it a name so I can use it, and\n+\tchange boolean_or_operator predicate to boolean_operator so it can\n+\tbe used to generate a crand.\n+\t(eqne): New code iterator.\n+\t(bd/bd_neg): New code_attrs.\n+\t(<bd>_<mode>): New name for ctr<mode>_internal[12] now combined into\n+\ta single define_insn.\n+\t(<bd>tf_<mode>): A new insn pattern for the conditional form branch\n+\tdecrement (bdnzt/bdnzf/bdzt/bdzf).\n+\t* config/rs6000/rs6000.c (rs6000_legitimate_combined_insn): Updated\n+\twith the new names of the branch decrement patterns, and added the\n+\tnames of the branch decrement conditional patterns.\n+\n 2018-01-08  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/83563"}, {"sha": "3d3ead4ec4906e3e6c61db2329b52a33dc756028", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 124, "deletions": 65, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f2c60230485a3510ad719c2e5efaea594e95992/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f2c60230485a3510ad719c2e5efaea594e95992/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=8f2c60230485a3510ad719c2e5efaea594e95992", "patch": "@@ -12797,7 +12797,7 @@\n ; which are generated by the branch logic.\n ; Prefer destructive operations where BT = BB (for crXX BT,BA,BB)\n \n-(define_insn \"*cceq_ior_compare\"\n+(define_insn \"cceq_ior_compare\"\n   [(set (match_operand:CCEQ 0 \"cc_reg_operand\" \"=y,?y\")\n         (compare:CCEQ (match_operator:SI 1 \"boolean_operator\"\n \t                [(match_operator:SI 2\n@@ -12817,9 +12817,9 @@\n \n ; Why is the constant -1 here, but 1 in the previous pattern?\n ; Because ~1 has all but the low bit set.\n-(define_insn \"\"\n+(define_insn \"cceq_ior_compare_complement\"\n   [(set (match_operand:CCEQ 0 \"cc_reg_operand\" \"=y,?y\")\n-        (compare:CCEQ (match_operator:SI 1 \"boolean_or_operator\"\n+        (compare:CCEQ (match_operator:SI 1 \"boolean_operator\"\n \t                [(not:SI (match_operator:SI 2\n \t\t\t\t      \"branch_positive_comparison_operator\"\n \t\t\t\t      [(match_operand 3\n@@ -13036,34 +13036,13 @@\n ;; rs6000_legitimate_combined_insn prevents combine creating any of\n ;; the ctr<mode> insns.\n \n-(define_insn \"ctr<mode>_internal1\"\n-  [(set (pc)\n-\t(if_then_else (ne (match_operand:P 1 \"register_operand\" \"c,*b,*b,*b\")\n-\t\t\t  (const_int 1))\n-\t\t      (label_ref (match_operand 0))\n-\t\t      (pc)))\n-   (set (match_operand:P 2 \"nonimmediate_operand\" \"=1,*r,m,*d*wi*c*l\")\n-\t(plus:P (match_dup 1)\n-\t\t(const_int -1)))\n-   (clobber (match_scratch:CC 3 \"=X,&x,&x,&x\"))\n-   (clobber (match_scratch:P 4 \"=X,X,&r,r\"))]\n-  \"\"\n-{\n-  if (which_alternative != 0)\n-    return \"#\";\n-  else if (get_attr_length (insn) == 4)\n-    return \"bdnz %l0\";\n-  else\n-    return \"bdz $+8\\;b %l0\";\n-}\n-  [(set_attr \"type\" \"branch\")\n-   (set_attr \"length\" \"*,16,20,20\")])\n-\n-;; Similar but use EQ\n+(define_code_iterator eqne [eq ne])\n+(define_code_attr bd [(eq \"bdz\") (ne \"bdnz\")])\n+(define_code_attr bd_neg [(eq \"bdnz\") (ne \"bdz\")])\n \n-(define_insn \"ctr<mode>_internal2\"\n+(define_insn \"<bd>_<mode>\"\n   [(set (pc)\n-\t(if_then_else (eq (match_operand:P 1 \"register_operand\" \"c,*b,*b,*b\")\n+\t(if_then_else (eqne (match_operand:P 1 \"register_operand\" \"c,*b,*b,*b\")\n \t\t\t  (const_int 1))\n \t\t      (label_ref (match_operand 0))\n \t\t      (pc)))\n@@ -13077,72 +13056,152 @@\n   if (which_alternative != 0)\n     return \"#\";\n   else if (get_attr_length (insn) == 4)\n-    return \"bdz %l0\";\n+    return \"<bd> %l0\";\n   else\n-    return \"bdnz $+8\\;b %l0\";\n+    return \"<bd_neg> $+8\\;b %l0\";\n }\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"*,16,20,20\")])\n \n-;; Now the splitters if we could not allocate the CTR register\n-\n+;; Now the splitter if we could not allocate the CTR register\n (define_split\n   [(set (pc)\n \t(if_then_else (match_operator 2 \"comparison_operator\"\n \t\t\t\t      [(match_operand:P 1 \"gpc_reg_operand\")\n \t\t\t\t       (const_int 1)])\n \t\t      (match_operand 5)\n \t\t      (match_operand 6)))\n-   (set (match_operand:P 0 \"int_reg_operand\")\n+   (set (match_operand:P 0 \"nonimmediate_operand\")\n \t(plus:P (match_dup 1)\n \t\t(const_int -1)))\n    (clobber (match_scratch:CC 3))\n    (clobber (match_scratch:P 4))]\n   \"reload_completed\"\n-  [(set (match_dup 3)\n-\t(compare:CC (match_dup 1)\n-\t\t    (const_int 1)))\n-   (set (match_dup 0)\n-\t(plus:P (match_dup 1)\n-\t\t(const_int -1)))\n-   (set (pc)\n+  [(set (pc)\n \t(if_then_else (match_dup 7)\n \t\t      (match_dup 5)\n \t\t      (match_dup 6)))]\n {\n   operands[7] = gen_rtx_fmt_ee (GET_CODE (operands[2]), VOIDmode, operands[3],\n \t\t\t\tconst0_rtx);\n+  emit_insn (gen_rtx_SET (operands[3],\n+\t\t\t  gen_rtx_COMPARE (CCmode, operands[1], const1_rtx)));\n+  if (gpc_reg_operand (operands[0], <MODE>mode))\n+    emit_insn (gen_add<mode>3 (operands[0], operands[1], constm1_rtx));\n+  else\n+    {\n+      emit_insn (gen_add<mode>3 (operands[4], operands[1], constm1_rtx));\n+      emit_move_insn (operands[0], operands[4]);\n+    } \n+    /* No DONE so branch comes from the pattern.  */\n })\n \n-(define_split\n+;; patterns for bdnzt/bdnzf/bdzt/bdzf\n+;; Note that in the case of long branches we have to decompose this into\n+;; bdnz+bc. This is because bdnzt has an implied AND between the ctr condition\n+;; and the CR bit, which means there is no way to conveniently invert the\n+;; comparison as is done with plain bdnz/bdz.\n+\n+(define_insn \"<bd>tf_<mode>\"\n   [(set (pc)\n-\t(if_then_else (match_operator 2 \"comparison_operator\"\n-\t\t\t\t      [(match_operand:P 1 \"gpc_reg_operand\")\n-\t\t\t\t       (const_int 1)])\n-\t\t      (match_operand 5)\n-\t\t      (match_operand 6)))\n-   (set (match_operand:P 0 \"nonimmediate_operand\")\n-\t(plus:P (match_dup 1)\n-\t\t(const_int -1)))\n-   (clobber (match_scratch:CC 3))\n-   (clobber (match_scratch:P 4))]\n-  \"reload_completed && !gpc_reg_operand (operands[0], SImode)\"\n-  [(set (match_dup 3)\n-\t(compare:CC (match_dup 1)\n-\t\t    (const_int 1)))\n-   (set (match_dup 4)\n+\t(if_then_else\n+\t  (and\n+\t     (eqne (match_operand:P 1 \"register_operand\" \"c,*b,*b,*b\")\n+\t\t   (const_int 1))\n+\t     (match_operator 3 \"branch_comparison_operator\"\n+\t\t      [(match_operand 4 \"cc_reg_operand\" \"y,y,y,y\")\n+\t\t       (const_int 0)]))\n+\t  (label_ref (match_operand 0))\n+\t  (pc)))\n+   (set (match_operand:P 2 \"nonimmediate_operand\" \"=1,*r,m,*d*wi*c*l\")\n \t(plus:P (match_dup 1)\n \t\t(const_int -1)))\n-   (set (match_dup 0)\n-\t(match_dup 4))\n-   (set (pc)\n-\t(if_then_else (match_dup 7)\n-\t\t      (match_dup 5)\n-\t\t      (match_dup 6)))]\n+   (clobber (match_scratch:P 5 \"=X,X,&r,r\"))\n+   (clobber (match_scratch:CC 6 \"=X,&y,&y,&y\"))\n+   (clobber (match_scratch:CCEQ 7 \"=X,&y,&y,&y\"))]\n+  \"\"\n {\n-  operands[7] = gen_rtx_fmt_ee (GET_CODE (operands[2]), VOIDmode, operands[3],\n-\t\t\t\tconst0_rtx);\n+  if (which_alternative != 0)\n+    return \"#\";\n+  else if (get_attr_length (insn) == 4)\n+    {\n+      if (branch_positive_comparison_operator (operands[3],\n+\t\t\t\t\t       GET_MODE (operands[3])))\n+\treturn \"<bd>t %j3,%l0\";\n+      else\n+\treturn \"<bd>f %j3,%l0\";\n+    }\n+  else\n+    {\n+      static char seq[96];\n+      char *bcs = output_cbranch (operands[3], \"$+8\", 1, insn);\n+      sprintf(seq, \"<bd_neg> $+12\\;%s;b %%l0\", bcs);\n+      return seq;\n+    }\n+}\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"length\" \"*,16,20,20\")])\n+\n+;; Now the splitter if we could not allocate the CTR register\n+(define_split\n+  [(set (pc)\n+\t(if_then_else\n+\t  (and\n+\t     (match_operator 1 \"comparison_operator\"\n+\t\t\t     [(match_operand:P 0 \"gpc_reg_operand\")\n+\t\t\t      (const_int 1)])\n+\t     (match_operator 3 \"branch_comparison_operator\"\n+\t\t      [(match_operand 2 \"cc_reg_operand\")\n+\t\t       (const_int 0)]))\n+\t  (match_operand 4)\n+\t  (match_operand 5)))\n+   (set (match_operand:P 6 \"int_reg_operand\")\n+\t(plus:P (match_dup 0)\n+\t\t(const_int -1)))\n+   (clobber (match_scratch:P 7))\n+   (clobber (match_scratch:CC 8))\n+   (clobber (match_scratch:CCEQ 9))]\n+  \"reload_completed\"\n+[(pc)]\n+{\n+  rtx ctr = operands[0];\n+  rtx ctrcmp = operands[1];\n+  rtx ccin = operands[2];\n+  rtx cccmp = operands[3];\n+  rtx dst1 = operands[4];\n+  rtx dst2 = operands[5];\n+  rtx ctrout = operands[6];\n+  rtx ctrtmp = operands[7];\n+  enum rtx_code cmpcode = GET_CODE (ctrcmp);\n+  bool ispos = branch_positive_comparison_operator (ctrcmp, GET_MODE (ctrcmp));\n+  if (!ispos)\n+    cmpcode = reverse_condition (cmpcode);\n+  /* Generate crand/crandc here.  */\n+  emit_insn (gen_rtx_SET (operands[8],\n+\t\t\t  gen_rtx_COMPARE (CCmode, ctr, const1_rtx)));\n+  rtx ctrcmpcc = gen_rtx_fmt_ee (cmpcode, SImode, operands[8], const0_rtx);\n+\n+  rtx andexpr = gen_rtx_AND (SImode, ctrcmpcc, cccmp);\n+  if (ispos)\n+     emit_insn (gen_cceq_ior_compare (operands[9], andexpr, ctrcmpcc,\n+\t\t\t\t      operands[8], cccmp, ccin));\n+  else\n+     emit_insn (gen_cceq_ior_compare_complement (operands[9], andexpr, ctrcmpcc,\n+\t\t\t\t\t\t operands[8], cccmp, ccin));\n+  if (gpc_reg_operand (operands[0], <MODE>mode))\n+     emit_insn (gen_add<mode>3 (ctrout, ctr, constm1_rtx));\n+  else\n+    {\n+      emit_insn (gen_add<mode>3 (ctrtmp, ctr, constm1_rtx));\n+      emit_move_insn (ctrout, ctrtmp);\n+    }\n+  rtx cmp = gen_rtx_EQ (CCEQmode, operands[9], const0_rtx);\n+  emit_jump_insn (gen_rtx_SET (pc_rtx,\n+\t\t\t       gen_rtx_IF_THEN_ELSE (VOIDmode, cmp,\n+\t\t\t\t\t\t     dst1, dst2)));\n+  DONE;\n })\n+\n \f\n (define_insn \"trap\"\n   [(trap_if (const_int 1) (const_int 0))]"}]}