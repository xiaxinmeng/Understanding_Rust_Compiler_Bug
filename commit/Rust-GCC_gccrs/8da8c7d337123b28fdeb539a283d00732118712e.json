{"sha": "8da8c7d337123b28fdeb539a283d00732118712e", "node_id": "C_kwDOANBUbNoAKDhkYThjN2QzMzcxMjNiMjhmZGViNTM5YTI4M2QwMDczMjExODcxMmU", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2023-03-05T00:47:19Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2023-03-16T16:29:57Z"}, "message": "d: Merge upstream dmd, druntime 4ca4140e58, phobos 454dff14d.\n\nD front-end changes:\n\n\t- Import dmd v2.103.0-beta.1.\n\t- Using `alias this' for classes has been deprecated.\n\t- The feature `-fpreview=dip25` is now enabled by default.\n\t- The compile-time traits `isVirtualFunction' and\n\t  `getVirtualFunctions' have been deprecated.\n\nD runtime changes:\n\n\t- Import druntime v2.103.0-beta.1.\n\nPhobos changes:\n\n\t- Import phobos v2.103.0-beta.1.\n\t- Updated unicode grapheme walking updated to conform to Unicode\n\t  version 15.\n\t- Improved friendliness of error messages when instantiating\n\t  `std.algorithm.iteration.joiner' and\n\t  `std.algorithm.sorting.sort' with wrong inputs.\n\ngcc/d/ChangeLog:\n\n\t* dmd/MERGE: Merge upstream dmd 4ca4140e58.\n\t* dmd/VERSION: Bump version to v2.103.0-beta.1.\n\t* Make-lang.in (D_FRONTEND_OBJS): Add d/errorsink.o.\n\t* d-ctfloat.cc (CTFloat::sprint): Update signature for new front-end\n\tinterface.\n\t* d-frontend.cc (getTypeInfoType): Likewise.\n\t* d-lang.cc (d_handle_option): Remove handling of -fpreview=dip25 and\n\t-frevert=dip25.\n\t(d_post_options): Remove enabling of sealed references language\n\tfeature when scoped pointers is enabled.\n\t* d-tree.h (create_typeinfo): Update signature.\n\t* decl.cc (DeclVisitor::finish_vtable): Update for new front-end\n\tinterface.\n\t(DeclVisitor::visit (VarDeclaration *)): Likewise.\n\t(DeclVisitor::visit (FuncDeclaration *)): Check skipCodegen to see if\n\tfront-end explicitly requested not to generate code.\n\t* expr.cc (ExprVisitor::visit (NewExp *)): Update for new front-end\n\tinterface.\n\t* lang.opt (fpreview=dip25): Remove.\n\t(frevert=dip25): Remove.\n\t* modules.cc (layout_moduleinfo_fields): Update for new front-end\n\tinterface.\n\t(layout_moduleinfo): Likewise.\n\t* runtime.def (NEWCLASS): Remove.\n\t* toir.cc (IRVisitor::visit (IfStatement *)): Don't generate IR for if\n\tstatement list when condition is `__ctfe'.\n\t* typeinfo.cc (create_typeinfo): Add generate parameter.\n\t* types.cc (layout_aggregate_members): Update for new front-end\n\tinterface.\n\nlibphobos/ChangeLog:\n\n\t* libdruntime/MERGE: Merge upstream druntime 4ca4140e58.\n\t* libdruntime/Makefile.am (DRUNTIME_DSOURCES): Add core/factory.d.\n\t* libdruntime/Makefile.in: Regenerate.\n\t* src/MERGE: Merge upstream phobos 454dff14d.\n\t* testsuite/libphobos.hash/test_hash.d: Update test.\n\t* testsuite/libphobos.shared/finalize.d: Update test.\n\t* libdruntime/core/factory.d: New file.\n\ngcc/testsuite/ChangeLog:\n\n\t* gdc.dg/torture/simd23084.d: New test.\n\t* gdc.dg/torture/simd23085.d: New test.\n\t* gdc.dg/torture/simd23218.d: New test.", "tree": {"sha": "74096a23b9e2f64a7e25ec1e8d4d3b1d8934842e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74096a23b9e2f64a7e25ec1e8d4d3b1d8934842e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8da8c7d337123b28fdeb539a283d00732118712e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8da8c7d337123b28fdeb539a283d00732118712e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8da8c7d337123b28fdeb539a283d00732118712e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8da8c7d337123b28fdeb539a283d00732118712e/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5e2c3dd6afcf9b152df72b30e205b0180c0afd5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5e2c3dd6afcf9b152df72b30e205b0180c0afd5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5e2c3dd6afcf9b152df72b30e205b0180c0afd5"}], "stats": {"total": 9351, "additions": 6467, "deletions": 2884}, "files": [{"sha": "1679fb81097985639199262abab81ab59d9d2bb8", "filename": "gcc/d/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2FMake-lang.in?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -124,6 +124,7 @@ D_FRONTEND_OBJS = \\\n \td/dversion.o \\\n \td/entity.o \\\n \td/errors.o \\\n+\td/errorsink.o \\\n \td/escape.o \\\n \td/expression.o \\\n \td/expressionsem.o \\"}, {"sha": "15d02b6de7603695fd66bd084b659962d7acb951", "filename": "gcc/d/d-ctfloat.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fd-ctfloat.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fd-ctfloat.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-ctfloat.cc?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -96,16 +96,16 @@ CTFloat::parse (const char *buffer, bool &overflow)\n   return r;\n }\n \n-/* Format the real_t value R to string BUFFER as a decimal or hexadecimal,\n-   converting the result to uppercase if FMT requests it.  */\n+/* Format the real_t value R to string BUFFER, bounded by BUF_SIZE, as a decimal\n+   or hexadecimal, converting the result to uppercase if FMT requests it.  */\n \n int\n-CTFloat::sprint (char *buffer, char fmt, real_t r)\n+CTFloat::sprint (char *buffer, d_size_t buf_size, char fmt, real_t r)\n {\n   if (fmt == 'a' || fmt == 'A')\n     {\n       /* Converting to a hexadecimal string.  */\n-      real_to_hexadecimal (buffer, &r.rv (), 32, 0, 1);\n+      real_to_hexadecimal (buffer, &r.rv (), buf_size, 0, 1);\n       int buflen;\n \n       switch (fmt)"}, {"sha": "cf200959cf9dfc0793bb8dd1f16d01198fe0cfe2", "filename": "gcc/d/d-frontend.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fd-frontend.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fd-frontend.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-frontend.cc?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -79,11 +79,11 @@ eval_builtin (const Loc &loc, FuncDeclaration *fd, Expressions *arguments)\n /* Build and return typeinfo type for TYPE.  */\n \n Type *\n-getTypeInfoType (const Loc &loc, Type *type, Scope *sc)\n+getTypeInfoType (const Loc &loc, Type *type, Scope *sc, bool genObjCode)\n {\n   gcc_assert (type->ty != TY::Terror);\n   check_typeinfo_type (loc, sc);\n-  create_typeinfo (type, sc ? sc->_module->importedFrom : NULL);\n+  create_typeinfo (type, sc ? sc->_module->importedFrom : NULL, genObjCode);\n   return type->vtinfo->type;\n }\n "}, {"sha": "235e22a4b41e32a23741fe87ddd4981a3fdf5903", "filename": "gcc/d/d-lang.cc", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fd-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fd-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-lang.cc?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -558,7 +558,6 @@ d_handle_option (size_t scode, const char *arg, HOST_WIDE_INT value,\n \n     case OPT_fpreview_all:\n       global.params.ehnogc = value;\n-      global.params.useDIP25 = FeatureState::enabled;\n       global.params.useDIP1000 = FeatureState::enabled;\n       global.params.useDIP1021 = value;\n       global.params.bitfields = value;\n@@ -590,10 +589,6 @@ d_handle_option (size_t scode, const char *arg, HOST_WIDE_INT value,\n       global.params.useDIP1021 = value;\n       break;\n \n-    case OPT_fpreview_dip25:\n-      global.params.useDIP25 = FeatureState::enabled;\n-      break;\n-\n     case OPT_fpreview_dtorfields:\n       global.params.dtorFields = FeatureState::enabled;\n       break;\n@@ -636,7 +631,6 @@ d_handle_option (size_t scode, const char *arg, HOST_WIDE_INT value,\n \n     case OPT_frevert_all:\n       global.params.useDIP1000 = FeatureState::disabled;\n-      global.params.useDIP25 = FeatureState::disabled;\n       global.params.dtorFields = FeatureState::disabled;\n       global.params.fix16997 = !value;\n       break;\n@@ -645,10 +639,6 @@ d_handle_option (size_t scode, const char *arg, HOST_WIDE_INT value,\n       global.params.useDIP1000 = FeatureState::disabled;\n       break;\n \n-    case OPT_frevert_dip25:\n-      global.params.useDIP25 = FeatureState::disabled;\n-      break;\n-\n     case OPT_frevert_dtorfields:\n       global.params.dtorFields = FeatureState::disabled;\n       break;\n@@ -911,10 +901,6 @@ d_post_options (const char ** fn)\n   if (global.params.useDIP1021)\n     global.params.useDIP1000 = FeatureState::enabled;\n \n-  /* Enabling DIP1000 implies DIP25.  */\n-  if (global.params.useDIP1000 == FeatureState::enabled)\n-    global.params.useDIP25 = FeatureState::enabled;\n-\n   /* Keep in sync with existing -fbounds-check flag.  */\n   flag_bounds_check = (global.params.useArrayBounds == CHECKENABLEon);\n "}, {"sha": "b64a6fb46f9c15da6e8f2a9b23b81d5d0af27df4", "filename": "gcc/d/d-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fd-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fd-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-tree.h?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -689,7 +689,7 @@ extern tree get_classinfo_decl (ClassDeclaration *);\n extern void check_typeinfo_type (const Loc &, Scope *, Expression * = NULL);\n extern tree build_typeinfo (const Loc &, Type *, Expression * = NULL);\n extern tree build_typeinfo (Expression *, Type *);\n-extern void create_typeinfo (Type *, Module *);\n+extern void create_typeinfo (Type *, Module *, bool = true);\n extern void create_tinfo_types (Module *);\n extern void layout_cpp_typeinfo (ClassDeclaration *);\n extern tree get_cpp_typeinfo_decl (ClassDeclaration *);"}, {"sha": "78c4ab554dc8a7a04eb9aaab16237ce5107860df", "filename": "gcc/d/decl.cc", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdecl.cc?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -563,8 +563,8 @@ class DeclVisitor : public Visitor\n \t    if (fd2->isFuture ())\n \t      continue;\n \n-\t    if (fd->leastAsSpecialized (fd2) != MATCH::nomatch\n-\t\t|| fd2->leastAsSpecialized (fd) != MATCH::nomatch)\n+\t    if (fd->leastAsSpecialized (fd2, NULL) != MATCH::nomatch\n+\t\t|| fd2->leastAsSpecialized (fd, NULL) != MATCH::nomatch)\n \t      {\n \t\terror_at (make_location_t (fd->loc), \"use of %qs\",\n \t\t\t  fd->toPrettyChars ());\n@@ -772,7 +772,7 @@ class DeclVisitor : public Visitor\n \treturn;\n       }\n \n-    if (d->aliassym)\n+    if (d->aliasTuple)\n       {\n \tthis->build_dsymbol (d->toAlias ());\n \treturn;\n@@ -821,7 +821,7 @@ class DeclVisitor : public Visitor\n \t\tDECL_INITIAL (decl) = build_expr (e, true);\n \t      }\n \t  }\n-\telse\n+\telse if (!d->type->isZeroInit ())\n \t  {\n \t    /* Use default initializer for the type.  */\n \t    if (TypeStruct *ts = d->type->isTypeStruct ())\n@@ -903,6 +903,10 @@ class DeclVisitor : public Visitor\n     if (gcc_attribute_p (d))\n       return;\n \n+    /* Front-end decided this function doesn't require code generation.  */\n+    if (d->skipCodegen ())\n+      return;\n+\n     /* Not emitting unittest functions.  */\n     if (!global.params.useUnitTests && d->isUnitTestDeclaration ())\n       return;"}, {"sha": "269eebfc483ffc2d35cff980269cfcf3bcefe443", "filename": "gcc/d/dmd/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FMERGE?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1,4 +1,4 @@\n-09faa4eacd4fb147107e94eeebf56b3a73fdcc05\n+4ca4140e584c055a8a9bc727e56a97ebcecd61e0\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/dmd repository."}, {"sha": "cecd008e608b519e765df8bf614930aa1aeb2b43", "filename": "gcc/d/dmd/README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2FREADME.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2FREADME.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FREADME.md?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -38,7 +38,8 @@ Note that these groups have no strict meaning, the category assignments are a bi\n | [dinifile.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/dinifile.d)   | Parse settings from .ini file (`sc.ini` / `dmd.conf`)                 |\n | [vsoptions.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/vsoptions.d) | Detect the Microsoft Visual Studio toolchain for linking              |\n | [frontend.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/frontend.d)   | An interface for using DMD as a library                               |\n-| [errors.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/errors.d)       | Error reporting functionality                                         |\n+| [errors.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/errors.d)       | Error reporting implementation                                        |\n+| [errorsink.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/errorsink.d) | Error reporting interface                                             |\n | [target.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/target.d)       | Manage target-specific parameters for cross-compiling (for LDC/GDC)   |\n | [compiler.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/compiler.d)   | Describe a back-end compiler and implements compiler-specific actions |\n "}, {"sha": "8b24f92dab7872fb50c21c92e219d87e162e37c2", "filename": "gcc/d/dmd/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FVERSION?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1 +1 @@\n-v2.102.0-beta.1\n+v2.103.0-beta.1"}, {"sha": "04e5eb2f0d9b1acf399ccf33808816dab4571a33", "filename": "gcc/d/dmd/aggregate.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Faggregate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Faggregate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Faggregate.h?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -304,7 +304,6 @@ class ClassDeclaration : public AggregateDeclaration\n     virtual int vtblOffset() const;\n     const char *kind() const override;\n \n-    void addLocalClass(ClassDeclarations *) override final;\n     void addObjcSymbols(ClassDeclarations *classes, ClassDeclarations *categories) override final;\n \n     // Back end"}, {"sha": "59ba9f5ecd65fb815c8bde7b5d2f0bc401d8b720", "filename": "gcc/d/dmd/apply.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fapply.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fapply.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fapply.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -75,7 +75,7 @@ private extern (C++) final class PostorderExpressionVisitor : StoppableVisitor\n public:\n     StoppableVisitor v;\n \n-    extern (D) this(StoppableVisitor v)\n+    extern (D) this(StoppableVisitor v) scope\n     {\n         this.v = v;\n     }"}, {"sha": "908855e271c644796658208cb66d9bc3a4d04463", "filename": "gcc/d/dmd/arrayop.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Farrayop.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Farrayop.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Farrayop.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -149,7 +149,7 @@ Expression arrayOp(BinExp e, Scope* sc)\n             ObjectNotFound(idArrayOp);   // fatal error\n     }\n \n-    auto fd = resolveFuncCall(e.loc, sc, arrayOp, tiargs, null, args, FuncResolveFlag.standard);\n+    auto fd = resolveFuncCall(e.loc, sc, arrayOp, tiargs, null, ArgumentList(args), FuncResolveFlag.standard);\n     if (!fd || fd.errors)\n         return ErrorExp.get();\n     return new CallExp(e.loc, new VarExp(e.loc, fd, false), args).expressionSemantic(sc);\n@@ -194,7 +194,7 @@ private Expressions* buildArrayOp(Scope* sc, Expression e, Objects* tiargs)\n         Expressions* args;\n \n     public:\n-        extern (D) this(Scope* sc, Objects* tiargs)\n+        extern (D) this(Scope* sc, Objects* tiargs) scope\n         {\n             this.sc = sc;\n             this.tiargs = tiargs;"}, {"sha": "dbe78ef74bc595bb61c3d5448dbbb2b859bbcdee", "filename": "gcc/d/dmd/attrib.d", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fattrib.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fattrib.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fattrib.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -197,17 +197,12 @@ extern (C++) abstract class AttribDeclaration : Dsymbol\n \n     /****************************************\n      */\n-    override final void addLocalClass(ClassDeclarations* aclasses)\n-    {\n-        include(null).foreachDsymbol( s => s.addLocalClass(aclasses) );\n-    }\n-\n     override final void addObjcSymbols(ClassDeclarations* classes, ClassDeclarations* categories)\n     {\n         objc.addSymbols(this, classes, categories);\n     }\n \n-    override final inout(AttribDeclaration) isAttribDeclaration() inout pure @safe\n+    override inout(AttribDeclaration) isAttribDeclaration() inout pure @safe\n     {\n         return this;\n     }\n@@ -1080,6 +1075,11 @@ extern (C++) final class StaticIfDeclaration : ConditionalDeclaration\n         return \"static if\";\n     }\n \n+    override inout(StaticIfDeclaration) isStaticIfDeclaration() inout pure @safe\n+    {\n+        return this;\n+    }\n+\n     override void accept(Visitor v)\n     {\n         v.visit(this);"}, {"sha": "44ceb12e0d06b892cf49c007e0315d10d38a3e3d", "filename": "gcc/d/dmd/attrib.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fattrib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fattrib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fattrib.h?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -36,8 +36,7 @@ class AttribDeclaration : public Dsymbol\n     bool hasPointers() override final;\n     bool hasStaticCtorOrDtor() override final;\n     void checkCtorConstInit() override final;\n-    void addLocalClass(ClassDeclarations *) override final;\n-    AttribDeclaration *isAttribDeclaration() override final { return this; }\n+    AttribDeclaration *isAttribDeclaration() override { return this; }\n \n     void accept(Visitor *v) override { v->visit(this); }\n };\n@@ -184,6 +183,7 @@ class StaticIfDeclaration final : public ConditionalDeclaration\n     void addMember(Scope *sc, ScopeDsymbol *sds) override;\n     void setScope(Scope *sc) override;\n     void importAll(Scope *sc) override;\n+    StaticIfDeclaration *isStaticIfDeclaration() override { return this; }\n     const char *kind() const override;\n     void accept(Visitor *v) override { v->visit(this); }\n };"}, {"sha": "bd5b78e92dc557817f647589e56a60c8b4fd53a3", "filename": "gcc/d/dmd/blockexit.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fblockexit.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fblockexit.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fblockexit.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -71,7 +71,7 @@ int blockExit(Statement s, FuncDeclaration func, bool mustNotThrow)\n         bool mustNotThrow;\n         int result;\n \n-        extern (D) this(FuncDeclaration func, bool mustNotThrow)\n+        extern (D) this(FuncDeclaration func, bool mustNotThrow) scope\n         {\n             this.func = func;\n             this.mustNotThrow = mustNotThrow;"}, {"sha": "0c237e6da567015bc5ac14b68a8337daafbac2fb", "filename": "gcc/d/dmd/canthrow.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fcanthrow.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fcanthrow.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcanthrow.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -63,7 +63,7 @@ extern (C++) /* CT */ BE canThrow(Expression e, FuncDeclaration func, bool mustN\n         CT result;\n \n     public:\n-        extern (D) this(FuncDeclaration func, bool mustNotThrow)\n+        extern (D) this(FuncDeclaration func, bool mustNotThrow) scope\n         {\n             this.func = func;\n             this.mustNotThrow = mustNotThrow;"}, {"sha": "19bf83e4ec353144df64fc98b580e39950a4f102", "filename": "gcc/d/dmd/clone.d", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fclone.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fclone.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fclone.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -113,11 +113,11 @@ FuncDeclaration hasIdentityOpAssign(AggregateDeclaration ad, Scope* sc)\n         sc.minst = null;\n \n         a[0] = er;\n-        auto f = resolveFuncCall(ad.loc, sc, assign, null, ad.type, &a, FuncResolveFlag.quiet);\n+        auto f = resolveFuncCall(ad.loc, sc, assign, null, ad.type, ArgumentList(&a), FuncResolveFlag.quiet);\n         if (!f)\n         {\n             a[0] = el;\n-            f = resolveFuncCall(ad.loc, sc, assign, null, ad.type, &a, FuncResolveFlag.quiet);\n+            f = resolveFuncCall(ad.loc, sc, assign, null, ad.type, ArgumentList(&a), FuncResolveFlag.quiet);\n         }\n \n         sc = sc.pop();\n@@ -478,7 +478,7 @@ private FuncDeclaration hasIdentityOpEquals(AggregateDeclaration ad, Scope* sc)\n             {\n                 a[0] = e;\n                 a[0].type = tthis;\n-                return resolveFuncCall(ad.loc, sc, eq, null, tthis, &a, FuncResolveFlag.quiet);\n+                return resolveFuncCall(ad.loc, sc, eq, null, tthis, ArgumentList(&a), FuncResolveFlag.quiet);\n             }\n \n             f = rfc(er);\n@@ -1065,7 +1065,7 @@ private DtorDeclaration buildWindowsCppDtor(AggregateDeclaration ad, DtorDeclara\n {\n     auto cldec = ad.isClassDeclaration();\n     if (!cldec || cldec.cppDtorVtblIndex == -1) // scalar deleting dtor not built for non-virtual dtors\n-        return dtor;\n+        return dtor;    // perhaps also do this if STC.scope_ is set\n \n     // generate deleting C++ destructor corresponding to:\n     // void* C::~C(int del)\n@@ -1077,8 +1077,9 @@ private DtorDeclaration buildWindowsCppDtor(AggregateDeclaration ad, DtorDeclara\n     Parameter delparam = new Parameter(STC.undefined_, Type.tuns32, Identifier.idPool(\"del\"), new IntegerExp(dtor.loc, 0, Type.tuns32), null);\n     Parameters* params = new Parameters;\n     params.push(delparam);\n-    auto ftype = new TypeFunction(ParameterList(params), Type.tvoidptr, LINK.cpp, dtor.storage_class);\n-    auto func = new DtorDeclaration(dtor.loc, dtor.loc, dtor.storage_class, Id.cppdtor);\n+    const stc = dtor.storage_class & ~STC.scope_; // because we add the `return this;` later\n+    auto ftype = new TypeFunction(ParameterList(params), Type.tvoidptr, LINK.cpp, stc);\n+    auto func = new DtorDeclaration(dtor.loc, dtor.loc, stc, Id.cppdtor);\n     func.type = ftype;\n \n     // Always generate the function with body, because it is not exported from DLLs."}, {"sha": "007d301359c78a9c2c5283f43689497488241d33", "filename": "gcc/d/dmd/common/outbuffer.d", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fcommon%2Foutbuffer.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fcommon%2Foutbuffer.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcommon%2Foutbuffer.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -338,9 +338,12 @@ struct OutBuffer\n         offset += len;\n     }\n \n-    /// write newline\n+    /// strip trailing tabs or spaces, write newline\n     extern (C++) void writenl() pure nothrow @safe\n     {\n+        while (offset > 0 && (data[offset - 1] == ' ' || data[offset - 1] == '\\t'))\n+            offset--;\n+\n         version (Windows)\n         {\n             writeword(0x0A0D); // newline is CR,LF on Microsoft OS's\n@@ -919,3 +922,18 @@ unittest\n     buf.setsize(4);\n     assert(buf.length == 4);\n }\n+\n+unittest\n+{\n+    OutBuffer buf;\n+\n+    buf.writenl();\n+    buf.writestring(\"abc \\t \");\n+    buf.writenl(); // strips trailing whitespace\n+    buf.writenl(); // doesn't strip previous newline\n+\n+    version(Windows)\n+        assert(buf[] == \"\\r\\nabc\\r\\n\\r\\n\");\n+    else\n+        assert(buf[] == \"\\nabc\\n\\n\");\n+}"}, {"sha": "e4be63cda3e5261122c2f24644e72174eefd9061", "filename": "gcc/d/dmd/constfold.d", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fconstfold.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fconstfold.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fconstfold.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -845,20 +845,8 @@ UnionExp Identity(EXP op, const ref Loc loc, Type type, Expression e1, Expressio\n     }\n     else\n     {\n-        if (e1.type.isreal())\n-        {\n-            cmp = CTFloat.isIdentical(e1.toReal(), e2.toReal());\n-        }\n-        else if (e1.type.isimaginary())\n-        {\n-            cmp = RealIdentical(e1.toImaginary(), e2.toImaginary());\n-        }\n-        else if (e1.type.iscomplex())\n-        {\n-            complex_t v1 = e1.toComplex();\n-            complex_t v2 = e2.toComplex();\n-            cmp = RealIdentical(creall(v1), creall(v2)) && RealIdentical(cimagl(v1), cimagl(v1));\n-        }\n+        if (e1.type.isfloating())\n+            cmp = e1.isIdentical(e2);\n         else\n         {\n             ue = Equal((op == EXP.identity) ? EXP.equal : EXP.notEqual, loc, type, e1, e2);"}, {"sha": "a18f810372df477fb0ecc2d89d6e116b9f9446f0", "filename": "gcc/d/dmd/cparse.d", "status": "modified", "additions": 76, "deletions": 33, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fcparse.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fcparse.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcparse.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -16,6 +16,7 @@ module dmd.cparse;\n import core.stdc.stdio;\n import core.stdc.string;\n import dmd.astenums;\n+import dmd.errorsink;\n import dmd.globals;\n import dmd.id;\n import dmd.identifier;\n@@ -69,9 +70,10 @@ final class CParser(AST) : Parser!AST\n     OutBuffer* defines;\n \n     extern (D) this(TARGET)(AST.Module _module, const(char)[] input, bool doDocComment,\n-                            const ref TARGET target, OutBuffer* defines)\n+                            ErrorSink errorSink,\n+                            const ref TARGET target, OutBuffer* defines) scope\n     {\n-        super(_module, input, doDocComment);\n+        super(_module, input, doDocComment, errorSink);\n \n         //printf(\"CParser.this()\\n\");\n         mod = _module;\n@@ -268,11 +270,12 @@ final class CParser(AST) : Parser!AST\n         case TOK.minusMinus:\n         case TOK.sizeof_:\n         case TOK._Generic:\n+        case TOK._assert:\n         Lexp:\n             auto exp = cparseExpression();\n             if (token.value == TOK.identifier && exp.op == EXP.identifier)\n             {\n-                error(\"found `%s` when expecting `;` or `=`, did you mean `%s %s = %s`?\", peek(&token).toChars(), exp.toChars(), token.toChars(), peek(peek(&token)).toChars());\n+                error(token.loc, \"found `%s` when expecting `;` or `=`, did you mean `%s %s = %s`?\", peek(&token).toChars(), exp.toChars(), token.toChars(), peek(peek(&token)).toChars());\n                 nextToken();\n             }\n             else\n@@ -286,6 +289,7 @@ final class CParser(AST) : Parser!AST\n         case TOK.int16:\n         case TOK.int32:\n         case TOK.int64:\n+        case TOK.__int128:\n         case TOK.float32:\n         case TOK.float64:\n         case TOK.signed:\n@@ -752,7 +756,7 @@ final class CParser(AST) : Parser!AST\n                     if (token.postfix)\n                     {\n                         if (token.postfix != postfix)\n-                            error(\"mismatched string literal postfixes `'%c'` and `'%c'`\", postfix, token.postfix);\n+                            error(token.loc, \"mismatched string literal postfixes `'%c'` and `'%c'`\", postfix, token.postfix);\n                         postfix = token.postfix;\n                     }\n \n@@ -781,6 +785,14 @@ final class CParser(AST) : Parser!AST\n             e = cparseGenericSelection();\n             break;\n \n+        case TOK._assert:  // __check(assign-exp) extension\n+            nextToken();\n+            check(TOK.leftParenthesis, \"`__check`\");\n+            e = parseAssignExp();\n+            check(TOK.rightParenthesis);\n+            e = new AST.AssertExp(loc, e, null);\n+            break;\n+\n         default:\n             error(\"expression expected, not `%s`\", token.toChars());\n             // Anything for e, as long as it's not NULL\n@@ -1640,6 +1652,23 @@ final class CParser(AST) : Parser!AST\n         specifier.packalign = this.packalign;\n         auto tspec = cparseDeclarationSpecifiers(level, specifier);\n \n+        AST.Dsymbol declareTag(AST.TypeTag tt, ref Specifier specifier)\n+        {\n+            /* `struct tag;` and `struct tag { ... };`\n+             * always result in a declaration in the current scope\n+             */\n+            auto stag = (tt.tok == TOK.struct_) ? new AST.StructDeclaration(tt.loc, tt.id, false) :\n+                        (tt.tok == TOK.union_)  ? new AST.UnionDeclaration(tt.loc, tt.id) :\n+                                                  new AST.EnumDeclaration(tt.loc, tt.id, tt.base);\n+            stag.members = tt.members;\n+            tt.members = null;\n+            if (!symbols)\n+                symbols = new AST.Dsymbols();\n+            auto stags = applySpecifier(stag, specifier);\n+            symbols.push(stags);\n+            return stags;\n+        }\n+\n         /* If a declarator does not follow, it is unnamed\n          */\n         if (token.value == TOK.semicolon)\n@@ -1664,22 +1693,12 @@ final class CParser(AST) : Parser!AST\n                 !tt.id && (tt.tok == TOK.struct_ || tt.tok == TOK.union_))\n                 return; // legal but meaningless empty declaration, ignore it\n \n-            /* `struct tag;` and `struct tag { ... };`\n-             * always result in a declaration in the current scope\n-             */\n-            auto stag = (tt.tok == TOK.struct_) ? new AST.StructDeclaration(tt.loc, tt.id, false) :\n-                        (tt.tok == TOK.union_)  ? new AST.UnionDeclaration(tt.loc, tt.id) :\n-                                                  new AST.EnumDeclaration(tt.loc, tt.id, tt.base);\n-            stag.members = tt.members;\n-            if (!symbols)\n-                symbols = new AST.Dsymbols();\n-            auto stags = applySpecifier(stag, specifier);\n-            symbols.push(stags);\n+            auto stags = declareTag(tt, specifier);\n \n             if (0 && tt.tok == TOK.enum_)    // C11 proscribes enums with no members, but we allow it\n             {\n                 if (!tt.members)\n-                    error(tt.loc, \"`enum %s` has no members\", stag.toChars());\n+                    error(tt.loc, \"`enum %s` has no members\", stags.toChars());\n             }\n             return;\n         }\n@@ -1823,17 +1842,10 @@ final class CParser(AST) : Parser!AST\n                 {\n                     if (tt.id || tt.tok == TOK.enum_)\n                     {\n-                        /* `struct tag;` and `struct tag { ... };`\n-                         * always result in a declaration in the current scope\n-                         */\n-                        auto stag = (tt.tok == TOK.struct_) ? new AST.StructDeclaration(tt.loc, tt.id, false) :\n-                                    (tt.tok == TOK.union_)  ? new AST.UnionDeclaration(tt.loc, tt.id) :\n-                                                              new AST.EnumDeclaration(tt.loc, tt.id, tt.base);\n-                        stag.members = tt.members;\n-                        tt.members = null;\n-                        if (!symbols)\n-                            symbols = new AST.Dsymbols();\n-                        symbols.push(stag);\n+                        if (!tt.id && id)\n+                            tt.id = id;\n+                        Specifier spec;\n+                        auto stag = declareTag(tt, spec);\n                         if (tt.tok == TOK.enum_)\n                         {\n                             isalias = false;\n@@ -1847,6 +1859,15 @@ final class CParser(AST) : Parser!AST\n             }\n             else if (id)\n             {\n+                if (auto tt = dt.isTypeTag())\n+                {\n+                    if (tt.members && (tt.id || tt.tok == TOK.enum_))\n+                    {\n+                        Specifier spec;\n+                        declareTag(tt, spec);\n+                    }\n+                }\n+\n                 if (level == LVL.prototype)\n                     break;      // declared later as Parameter, not VarDeclaration\n \n@@ -1929,7 +1950,7 @@ final class CParser(AST) : Parser!AST\n                 case TOK.identifier:\n                     if (s)\n                     {\n-                        error(\"missing comma or semicolon after declaration of `%s`, found `%s` instead\", s.toChars(), token.toChars());\n+                        error(token.loc, \"missing comma or semicolon after declaration of `%s`, found `%s` instead\", s.toChars(), token.toChars());\n                         goto Lend;\n                     }\n                     goto default;\n@@ -1995,7 +2016,7 @@ final class CParser(AST) : Parser!AST\n             importBuiltins = true;                              // will need __va_list_tag\n             auto plLength = pl.length;\n             if (symbols.length != plLength)\n-                error(\"%d identifiers does not match %d declarations\", cast(int)plLength, cast(int)symbols.length);\n+                error(token.loc, \"%d identifiers does not match %d declarations\", cast(int)plLength, cast(int)symbols.length);\n \n             /* Transfer the types and storage classes from symbols[] to pl[]\n              */\n@@ -2183,6 +2204,7 @@ final class CParser(AST) : Parser!AST\n             ximaginary = 0x8000,\n             xcomplex   = 0x10000,\n             x_Atomic   = 0x20000,\n+            xint128    = 0x40000,\n         }\n \n         AST.Type t;\n@@ -2227,6 +2249,7 @@ final class CParser(AST) : Parser!AST\n                 case TOK.int16:      tkwx = TKW.xshort;     break;\n                 case TOK.int32:      tkwx = TKW.xint;       break;\n                 case TOK.int64:      tkwx = TKW.xlong;      break;\n+                case TOK.__int128:   tkwx = TKW.xint128;    break;\n                 case TOK.float32:    tkwx = TKW.xfloat;     break;\n                 case TOK.float64:    tkwx = TKW.xdouble;    break;\n                 case TOK.void_:      tkwx = TKW.xvoid;      break;\n@@ -2505,6 +2528,11 @@ final class CParser(AST) : Parser!AST\n             case TKW.xunsigned | TKW.xllong | TKW.xint:\n             case TKW.xunsigned | TKW.xllong:     t = unsignedTypeForSize(long_longsize); break;\n \n+            case TKW.xint128:\n+            case TKW.xsigned | TKW.xint128:     t = integerTypeForSize(16); break;\n+\n+            case TKW.xunsigned | TKW.xint128:   t = unsignedTypeForSize(16); break;\n+\n             case TKW.xvoid:                     t = AST.Type.tvoid; break;\n             case TKW.xbool:                     t = boolsize == 1 ? AST.Type.tbool : integerTypeForSize(boolsize); break;\n \n@@ -2991,11 +3019,11 @@ final class CParser(AST) : Parser!AST\n             auto param = new AST.Parameter(specifiersToSTC(LVL.parameter, specifier),\n                                            t, id, null, null);\n             parameters.push(param);\n-            if (token.value == TOK.rightParenthesis)\n+            if (token.value == TOK.rightParenthesis || token.value == TOK.endOfFile)\n                 break;\n             check(TOK.comma);\n         }\n-        nextToken();\n+        check(TOK.rightParenthesis);\n         return finish();\n     }\n \n@@ -3270,6 +3298,7 @@ final class CParser(AST) : Parser!AST\n             case TOK._Complex:\n             case TOK._Thread_local:\n             case TOK.int32:\n+            case TOK.__int128:\n             case TOK.char_:\n             case TOK.float32:\n             case TOK.float64:\n@@ -3940,6 +3969,7 @@ final class CParser(AST) : Parser!AST\n                 case TOK.int16:\n                 case TOK.int32:\n                 case TOK.int64:\n+                case TOK.__int128:\n                 case TOK.float32:\n                 case TOK.float64:\n                 case TOK.signed:\n@@ -4304,6 +4334,7 @@ final class CParser(AST) : Parser!AST\n                 case TOK.int16:\n                 case TOK.int32:\n                 case TOK.int64:\n+                case TOK.__int128:\n                 case TOK.float32:\n                 case TOK.float64:\n                 case TOK.void_:\n@@ -4702,6 +4733,11 @@ final class CParser(AST) : Parser!AST\n             return AST.Type.tint32;\n         if (size <= 8)\n             return AST.Type.tint64;\n+        if (size == 16)\n+        {\n+            error(\"__int128 not supported\");\n+            return AST.Type.terror;\n+        }\n         error(\"unsupported integer type\");\n         return AST.Type.terror;\n     }\n@@ -4723,6 +4759,11 @@ final class CParser(AST) : Parser!AST\n             return AST.Type.tuns32;\n         if (size <= 8)\n             return AST.Type.tuns64;\n+        if (size == 16)\n+        {\n+            error(\"unsigned __int128 not supported\");\n+            return AST.Type.terror;\n+        }\n         error(\"unsupported integer type\");\n         return AST.Type.terror;\n     }\n@@ -5115,9 +5156,9 @@ final class CParser(AST) : Parser!AST\n         if (n.value == TOK.identifier && n.ident == Id.show)\n         {\n             if (packalign.isDefault())\n-                warning(startloc, \"current pack attribute is default\");\n+                eSink.warning(startloc, \"current pack attribute is default\");\n             else\n-                warning(startloc, \"current pack attribute is %d\", packalign.get());\n+                eSink.warning(startloc, \"current pack attribute is %d\", packalign.get());\n             scan(&n);\n             return closingParen();\n         }\n@@ -5278,6 +5319,8 @@ final class CParser(AST) : Parser!AST\n \n         void addVar(AST.VarDeclaration v)\n         {\n+            //printf(\"addVar() %s\\n\", v.toChars());\n+            v.isCmacro(true);           // mark it as coming from a C #define\n             /* If it's already defined, replace the earlier\n              * definition\n              */"}, {"sha": "b015a642b909159f753e93311574c1f9d7b87a92", "filename": "gcc/d/dmd/cppmangle.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fcppmangle.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fcppmangle.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcppmangle.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -173,7 +173,7 @@ private final class CppMangleVisitor : Visitor\n      *   buf = `OutBuffer` to write the mangling to\n      *   loc = `Loc` of the symbol being mangled\n      */\n-    this(OutBuffer* buf, Loc loc)\n+    this(OutBuffer* buf, Loc loc) scope\n     {\n         this.buf = buf;\n         this.loc = loc;"}, {"sha": "8109e12d43d34daab0506e6422329a73f1a0e674", "filename": "gcc/d/dmd/ctfeexpr.d", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fctfeexpr.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fctfeexpr.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fctfeexpr.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1281,12 +1281,12 @@ private int ctfeRawCmp(const ref Loc loc, Expression e1, Expression e2, bool ide\n     {\n         return e1.toInteger() != e2.toInteger();\n     }\n+    if (identity && e1.type.isfloating())\n+        return !e1.isIdentical(e2);\n     if (e1.type.isreal() || e1.type.isimaginary())\n     {\n         real_t r1 = e1.type.isreal() ? e1.toReal() : e1.toImaginary();\n         real_t r2 = e1.type.isreal() ? e2.toReal() : e2.toImaginary();\n-        if (identity)\n-            return !CTFloat.isIdentical(r1, r2);\n         if (CTFloat.isNaN(r1) || CTFloat.isNaN(r2)) // if unordered\n         {\n             return 1;   // they are not equal\n@@ -1298,13 +1298,7 @@ private int ctfeRawCmp(const ref Loc loc, Expression e1, Expression e2, bool ide\n     }\n     else if (e1.type.iscomplex())\n     {\n-        auto c1 = e1.toComplex();\n-        auto c2 = e2.toComplex();\n-        if (identity)\n-        {\n-            return !RealIdentical(c1.re, c2.re) && !RealIdentical(c1.im, c2.im);\n-        }\n-        return c1 != c2;\n+        return e1.toComplex() != e2.toComplex();\n     }\n     if (e1.op == EXP.structLiteral && e2.op == EXP.structLiteral)\n     {\n@@ -1415,16 +1409,8 @@ bool ctfeIdentity(const ref Loc loc, EXP op, Expression e1, Expression e2)\n         SymOffExp es2 = e2.isSymOffExp();\n         cmp = (es1.var == es2.var && es1.offset == es2.offset);\n     }\n-    else if (e1.type.isreal())\n-        cmp = CTFloat.isIdentical(e1.toReal(), e2.toReal());\n-    else if (e1.type.isimaginary())\n-        cmp = RealIdentical(e1.toImaginary(), e2.toImaginary());\n-    else if (e1.type.iscomplex())\n-    {\n-        complex_t v1 = e1.toComplex();\n-        complex_t v2 = e2.toComplex();\n-        cmp = RealIdentical(creall(v1), creall(v2)) && RealIdentical(cimagl(v1), cimagl(v1));\n-    }\n+    else if (e1.type.isfloating())\n+        cmp = e1.isIdentical(e2);\n     else\n     {\n         cmp = !ctfeRawCmp(loc, e1, e2, true);"}, {"sha": "2830b25d651210af1cb5cd09eb3f0fb3ed8d21a9", "filename": "gcc/d/dmd/dcast.d", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fdcast.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fdcast.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdcast.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1520,6 +1520,8 @@ Type toStaticArrayType(SliceExp e)\n  */\n Expression castTo(Expression e, Scope* sc, Type t, Type att = null)\n {\n+    //printf(\"castTo(e: %s from: %s to: %s\\n\", e.toChars(), e.type.toChars(), t.toChars());\n+\n     Expression visit(Expression e)\n     {\n         //printf(\"Expression::castTo(this=%s, t=%s)\\n\", e.toChars(), t.toChars());"}, {"sha": "e4585934089f3255f52ec2d6c9839bbd499e6bb5", "filename": "gcc/d/dmd/dclass.d", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fdclass.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fdclass.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdclass.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -963,12 +963,6 @@ extern (C++) class ClassDeclaration : AggregateDeclaration\n \n     /****************************************\n      */\n-    override final void addLocalClass(ClassDeclarations* aclasses)\n-    {\n-        if (classKind != ClassKind.objc)\n-            aclasses.push(this);\n-    }\n-\n     override final void addObjcSymbols(ClassDeclarations* classes, ClassDeclarations* categories)\n     {\n         .objc.addSymbols(this, classes, categories);"}, {"sha": "7cd8df19bdcb0fab5dcd39c06a6efe611f4fa077", "filename": "gcc/d/dmd/declaration.d", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fdeclaration.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fdeclaration.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdeclaration.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1111,7 +1111,7 @@ extern (C++) class VarDeclaration : Declaration\n {\n     Initializer _init;\n     FuncDeclarations nestedrefs;    // referenced by these lexically nested functions\n-    Dsymbol aliassym;               // if redone as alias to another symbol\n+    TupleDeclaration aliasTuple;    // when `this` is really a tuple of declarations\n     VarDeclaration lastVar;         // Linked list of variables for goto-skips-init detection\n     Expression edtor;               // if !=null, does the destruction of the variable\n     IntRange* range;                // if !=null, the variable is known to be within the range\n@@ -1148,6 +1148,12 @@ extern (C++) class VarDeclaration : Declaration\n         bool doNotInferReturn;  /// do not infer 'return' for this variable\n \n         bool isArgDtorVar;      /// temporary created to handle scope destruction of a function argument\n+        bool isCmacro;          /// it is a C macro turned into a C declaration\n+        version (MARS)\n+        {\n+            bool inClosure;         /// is inserted into a GC allocated closure\n+            bool inAlignSection;    /// is inserted into an aligned section on stack\n+        }\n     }\n \n     import dmd.common.bitfields : generateBitFields;\n@@ -1199,12 +1205,10 @@ extern (C++) class VarDeclaration : Declaration\n     {\n         //printf(\"VarDeclaration::setFieldOffset(ad = %s) %s\\n\", ad.toChars(), toChars());\n \n-        if (aliassym)\n+        if (aliasTuple)\n         {\n             // If this variable was really a tuple, set the offsets for the tuple fields\n-            TupleDeclaration v2 = aliassym.isTupleDeclaration();\n-            assert(v2);\n-            v2.foreachVar((s) { s.setFieldOffset(ad, fieldState, isunion); });\n+            aliasTuple.foreachVar((s) { s.setFieldOffset(ad, fieldState, isunion); });\n             return;\n         }\n \n@@ -1315,9 +1319,17 @@ extern (C++) class VarDeclaration : Declaration\n \n     override final bool isImportedSymbol() const\n     {\n-        if (visibility.kind == Visibility.Kind.export_ && !_init && (storage_class & STC.static_ || parent.isModule()))\n-            return true;\n-        return false;\n+        /* If global variable has `export` and `extern` then it is imported\n+         *   export int sym1;            // definition:  exported\n+         *   export extern int sym2;     // declaration: imported\n+         *   export extern int sym3 = 0; // error, extern cannot have initializer\n+         */\n+        bool result =\n+            visibility.kind == Visibility.Kind.export_ &&\n+            storage_class & STC.extern_ &&\n+            (storage_class & STC.static_ || parent.isModule());\n+        //printf(\"isImportedSymbol() %s %d\\n\", toChars(), result);\n+        return result;\n     }\n \n     final bool isCtorinit() const pure nothrow @nogc @safe\n@@ -1659,8 +1671,7 @@ extern (C++) class VarDeclaration : Declaration\n         // Add this VarDeclaration to fdv.closureVars[] if not already there\n         if (!sc.intypeof && !(sc.flags & SCOPE.compile) &&\n             // https://issues.dlang.org/show_bug.cgi?id=17605\n-            (fdv.isCompileTimeOnly || !fdthis.isCompileTimeOnly)\n-           )\n+            (fdv.skipCodegen || !fdthis.skipCodegen))\n         {\n             if (!fdv.closureVars.contains(this))\n                 fdv.closureVars.push(this);\n@@ -1697,8 +1708,8 @@ extern (C++) class VarDeclaration : Declaration\n         if ((!type || !type.deco) && _scope)\n             dsymbolSemantic(this, _scope);\n \n-        assert(this != aliassym);\n-        Dsymbol s = aliassym ? aliassym.toAlias() : this;\n+        assert(this != aliasTuple);\n+        Dsymbol s = aliasTuple ? aliasTuple.toAlias() : this;\n         return s;\n     }\n "}, {"sha": "cd4155d0fbb0d659d49dc53c4bcf9a4e6c40d4cd", "filename": "gcc/d/dmd/declaration.h", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fdeclaration.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fdeclaration.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdeclaration.h?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -229,7 +229,7 @@ class VarDeclaration : public Declaration\n public:\n     Initializer *_init;\n     FuncDeclarations nestedrefs; // referenced by these lexically nested functions\n-    Dsymbol *aliassym;          // if redone as alias to another symbol\n+    TupleDeclaration *aliasTuple;  // if `this` is really a tuple of declarations\n     VarDeclaration *lastVar;    // Linked list of variables for goto-skips-init detection\n     Expression *edtor;          // if !=NULL, does the destruction of the variable\n     IntRange *range;            // if !NULL, the variable is known to be within the range\n@@ -270,6 +270,14 @@ class VarDeclaration : public Declaration\n     bool doNotInferReturn(bool v);\n     bool isArgDtorVar() const; // temporary created to handle scope destruction of a function argument\n     bool isArgDtorVar(bool v);\n+    bool isCmacro() const; // if a C macro turned into a C variable\n+    bool isCmacro(bool v);\n+#if MARS\n+    bool inClosure() const; // is inserted into a GC allocated closure\n+    bool inClosure(bool v);\n+    bool inAlignSection() const; // is inserted into aligned section on stack\n+    bool inAlignSection(bool v);\n+#endif\n     static VarDeclaration *create(const Loc &loc, Type *t, Identifier *id, Initializer *init, StorageClass storage_class = STCundefined);\n     VarDeclaration *syntaxCopy(Dsymbol *) override;\n     void setFieldOffset(AggregateDeclaration *ad, FieldState& fieldState, bool isunion) override final;\n@@ -634,8 +642,8 @@ class FuncDeclaration : public Declaration\n     bool inferScope(bool v);\n     bool hasCatches() const;\n     bool hasCatches(bool v);\n-    bool isCompileTimeOnly() const;\n-    bool isCompileTimeOnly(bool v);\n+    bool skipCodegen() const;\n+    bool skipCodegen(bool v);\n     bool printf() const;\n     bool printf(bool v);\n     bool scanf() const;\n@@ -680,7 +688,7 @@ class FuncDeclaration : public Declaration\n     BaseClass *overrideInterface();\n     bool overloadInsert(Dsymbol *s) override;\n     bool inUnittest();\n-    MATCH leastAsSpecialized(FuncDeclaration *g);\n+    MATCH leastAsSpecialized(FuncDeclaration *g, Identifiers *names);\n     LabelDsymbol *searchLabel(Identifier *ident, const Loc &loc);\n     int getLevel(FuncDeclaration *fd, int intypeof); // lexical nesting level difference\n     int getLevelAndCheck(const Loc &loc, Scope *sc, FuncDeclaration *fd);"}, {"sha": "fd9569105b59c56ce18cc418e22958e9a5b86aaf", "filename": "gcc/d/dmd/delegatize.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fdelegatize.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fdelegatize.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdelegatize.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -109,7 +109,7 @@ private void lambdaSetParent(Expression e, FuncDeclaration fd)\n         }\n \n     public:\n-        extern (D) this(FuncDeclaration fd)\n+        extern (D) this(FuncDeclaration fd) scope\n         {\n             this.fd = fd;\n         }\n@@ -205,7 +205,7 @@ bool lambdaCheckForNestedRef(Expression e, Scope* sc)\n         Scope* sc;\n         bool result;\n \n-        extern (D) this(Scope* sc)\n+        extern (D) this(Scope* sc) scope\n         {\n             this.sc = sc;\n         }"}, {"sha": "9073b0db2f843e35f39edee4647652ed268670e3", "filename": "gcc/d/dmd/dinterpret.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fdinterpret.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fdinterpret.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdinterpret.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -747,7 +747,7 @@ public:\n     Expression result;\n     UnionExp* pue;              // storage for `result`\n \n-    extern (D) this(UnionExp* pue, InterState* istate, CTFEGoal goal)\n+    extern (D) this(UnionExp* pue, InterState* istate, CTFEGoal goal) scope\n     {\n         this.pue = pue;\n         this.istate = istate;"}, {"sha": "72a447657878f7d71b79292c7e8c2b92fc7edbfe", "filename": "gcc/d/dmd/dmangle.d", "status": "modified", "additions": 310, "deletions": 260, "changes": 570, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fdmangle.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fdmangle.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdmangle.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -14,17 +14,18 @@\n \n module dmd.dmangle;\n \n-import dmd.astenums;\n \n /******************************************************************************\n  * Returns exact mangled name of function.\n  */\n extern (C++) const(char)* mangleExact(FuncDeclaration fd)\n {\n+    //printf(\"mangleExact()\\n\");\n     if (!fd.mangleString)\n     {\n         OutBuffer buf;\n-        scope Mangler v = new Mangler(&buf);\n+        auto backref = Backref(null);\n+        scope Mangler v = new Mangler(&buf, &backref);\n         v.mangleExact(fd);\n         fd.mangleString = buf.extractChars();\n     }\n@@ -33,30 +34,38 @@ extern (C++) const(char)* mangleExact(FuncDeclaration fd)\n \n extern (C++) void mangleToBuffer(Type t, OutBuffer* buf)\n {\n+    //printf(\"mangleToBuffer t()\\n\");\n     if (t.deco)\n         buf.writestring(t.deco);\n     else\n     {\n-        scope Mangler v = new Mangler(buf, t);\n-        v.visitWithMask(t, 0);\n+        auto backref = Backref(t);\n+        mangleType(t, 0, buf, backref);\n+        //printf(\"%s\\n\", buf.peekChars());\n     }\n }\n \n extern (C++) void mangleToBuffer(Expression e, OutBuffer* buf)\n {\n-    scope Mangler v = new Mangler(buf);\n+    //printf(\"mangleToBuffer e()\\n\");\n+    auto backref = Backref(null);\n+    scope Mangler v = new Mangler(buf, &backref);\n     e.accept(v);\n }\n \n extern (C++) void mangleToBuffer(Dsymbol s, OutBuffer* buf)\n {\n-    scope Mangler v = new Mangler(buf);\n+    //printf(\"mangleToBuffer s(%s)\\n\", s.toChars());\n+    auto backref = Backref(null);\n+    scope Mangler v = new Mangler(buf, &backref);\n     s.accept(v);\n }\n \n extern (C++) void mangleToBuffer(TemplateInstance ti, OutBuffer* buf)\n {\n-    scope Mangler v = new Mangler(buf);\n+    //printf(\"mangleToBuffer ti()\\n\");\n+    auto backref = Backref(null);\n+    scope Mangler v = new Mangler(buf, &backref);\n     v.mangleTemplateInstance(ti);\n }\n \n@@ -127,6 +136,7 @@ import core.stdc.string;\n \n import dmd.aggregate;\n import dmd.arraytypes;\n+import dmd.astenums;\n import dmd.dclass;\n import dmd.declaration;\n import dmd.dmodule;\n@@ -231,233 +241,344 @@ unittest\n     }\n }\n \n-private extern (C++) final class Mangler : Visitor\n+/************************************************\n+ * Append the mangling of type `t` to `buf`.\n+ * Params:\n+ *      t = type to mangle\n+ *      modMask = mod bits currently applying to t\n+ *      buf = buffer to append mangling to\n+ *      backref = state of back references (updated)\n+ */\n+void mangleType(Type t, ubyte modMask, OutBuffer* buf, ref Backref backref)\n {\n-    alias visit = Visitor.visit;\n-public:\n-    static assert(Key.sizeof == size_t.sizeof);\n-\n-    OutBuffer* buf;\n-    Backref backref;\n-\n-    extern (D) this(OutBuffer* buf, Type rootType = null)\n-    {\n-        this.buf = buf;\n-        this.backref = Backref(rootType);\n-    }\n-\n-    void mangleSymbol(Dsymbol s)\n-    {\n-        s.accept(this);\n-    }\n-\n-    void mangleType(Type t)\n+    void visitWithMask(Type t, ubyte modMask)\n     {\n-        if (!backref.addRefToType(buf, t))\n-            t.accept(this);\n-    }\n+        void mangleSymbol(Dsymbol s)\n+        {\n+            scope Mangler v = new Mangler(buf, &backref);\n+            v.mangleSymbol(s);\n+        }\n \n-    void mangleIdentifier(Identifier id, Dsymbol s)\n-    {\n-        if (!backref.addRefToIdentifier(buf, id))\n-            toBuffer(buf, id.toString(), s);\n-    }\n+        void visitType(Type t)\n+        {\n+            tyToDecoBuffer(buf, t.ty);\n+        }\n \n-    ////////////////////////////////////////////////////////////////////////////\n-    /**************************************************\n-     * Type mangling\n-     */\n-    void visitWithMask(Type t, ubyte modMask)\n-    {\n-        if (modMask != t.mod)\n+        void visitTypeNext(TypeNext t)\n         {\n-            MODtoDecoBuffer(buf, t.mod);\n+            visitType(t);\n+            visitWithMask(t.next, t.mod);\n         }\n-        mangleType(t);\n-    }\n \n-    override void visit(Type t)\n-    {\n-        tyToDecoBuffer(buf, t.ty);\n-    }\n+        void visitTypeVector(TypeVector t)\n+        {\n+            buf.writestring(\"Nh\");\n+            visitWithMask(t.basetype, t.mod);\n+        }\n \n-    override void visit(TypeNext t)\n-    {\n-        visit(cast(Type)t);\n-        visitWithMask(t.next, t.mod);\n-    }\n+        void visitTypeSArray(TypeSArray t)\n+        {\n+            visitType(t);\n+            if (t.dim)\n+                buf.print(t.dim.toInteger());\n+            if (t.next)\n+                visitWithMask(t.next, t.mod);\n+        }\n \n-    override void visit(TypeVector t)\n-    {\n-        buf.writestring(\"Nh\");\n-        visitWithMask(t.basetype, t.mod);\n-    }\n+        void visitTypeDArray(TypeDArray t)\n+        {\n+            visitType(t);\n+            if (t.next)\n+                visitWithMask(t.next, t.mod);\n+        }\n \n-    override void visit(TypeSArray t)\n-    {\n-        visit(cast(Type)t);\n-        if (t.dim)\n-            buf.print(t.dim.toInteger());\n-        if (t.next)\n+        void visitTypeAArray(TypeAArray t)\n+        {\n+            visitType(t);\n+            visitWithMask(t.index, 0);\n             visitWithMask(t.next, t.mod);\n-    }\n+        }\n \n-    override void visit(TypeDArray t)\n-    {\n-        visit(cast(Type)t);\n-        if (t.next)\n-            visitWithMask(t.next, t.mod);\n-    }\n+        void visitTypeFunction(TypeFunction t)\n+        {\n+            //printf(\"TypeFunction.toDecoBuffer() t = %p %s\\n\", t, t.toChars());\n+            //static int nest; if (++nest == 50) *(char*)0=0;\n+            mangleFuncType(t, t, t.mod, t.next, buf, backref);\n+        }\n \n-    override void visit(TypeAArray t)\n-    {\n-        visit(cast(Type)t);\n-        visitWithMask(t.index, 0);\n-        visitWithMask(t.next, t.mod);\n-    }\n+        void visitTypeIdentifier(TypeIdentifier t)\n+        {\n+            visitType(t);\n+            auto name = t.ident.toString();\n+            buf.print(cast(int)name.length);\n+            buf.writestring(name);\n+        }\n \n-    override void visit(TypeFunction t)\n-    {\n-        //printf(\"TypeFunction.toDecoBuffer() t = %p %s\\n\", t, t.toChars());\n-        //static int nest; if (++nest == 50) *(char*)0=0;\n-        mangleFuncType(t, t, t.mod, t.next);\n-    }\n+        void visitTypeEnum(TypeEnum t)\n+        {\n+            visitType(t);\n+            mangleSymbol(t.sym);\n+        }\n \n-    void mangleFuncType(TypeFunction t, TypeFunction ta, ubyte modMask, Type tret)\n-    {\n-        //printf(\"mangleFuncType() %s\\n\", t.toChars());\n-        if (t.inuse && tret)\n+        void visitTypeStruct(TypeStruct t)\n         {\n-            // printf(\"TypeFunction.mangleFuncType() t = %s inuse\\n\", t.toChars());\n-            t.inuse = 2; // flag error to caller\n-            return;\n+            //printf(\"TypeStruct.toDecoBuffer('%s') = '%s'\\n\", t.toChars(), name);\n+            visitType(t);\n+            mangleSymbol(t.sym);\n         }\n-        t.inuse++;\n-        if (modMask != t.mod)\n-            MODtoDecoBuffer(buf, t.mod);\n \n-        char mc;\n-        final switch (t.linkage)\n+        void visitTypeClass(TypeClass t)\n         {\n-        case LINK.default_:\n-        case LINK.d:\n-            mc = 'F';\n-            break;\n-        case LINK.c:\n-            mc = 'U';\n-            break;\n-        case LINK.windows:\n-            mc = 'W';\n-            break;\n-        case LINK.cpp:\n-            mc = 'R';\n-            break;\n-        case LINK.objc:\n-            mc = 'Y';\n-            break;\n-        case LINK.system:\n-            assert(0);\n+            //printf(\"TypeClass.toDecoBuffer('%s' mod=%x) = '%s'\\n\", t.toChars(), mod, name);\n+            visitType(t);\n+            mangleSymbol(t.sym);\n         }\n-        buf.writeByte(mc);\n-\n-        if (ta.purity)\n-            buf.writestring(\"Na\");\n-        if (ta.isnothrow)\n-            buf.writestring(\"Nb\");\n-        if (ta.isref)\n-            buf.writestring(\"Nc\");\n-        if (ta.isproperty)\n-            buf.writestring(\"Nd\");\n-        if (ta.isnogc)\n-            buf.writestring(\"Ni\");\n-\n-        // `return scope` must be in that order\n-        if (ta.isreturnscope && !ta.isreturninferred)\n+\n+        void visitTypeTuple(TypeTuple t)\n         {\n-            buf.writestring(\"NjNl\");\n+            //printf(\"TypeTuple.toDecoBuffer() t = %p, %s\\n\", t, t.toChars());\n+            visitType(t);\n+            Parameter._foreach(t.arguments, (idx, param) {\n+                    mangleParameter(param, buf, backref);\n+                    return 0;\n+            });\n+            buf.writeByte('Z');\n         }\n-        else\n+\n+        void visitTypeNull(TypeNull t)\n         {\n-            // when return ref, the order is `scope return`\n-            if (ta.isScopeQual && !ta.isscopeinferred)\n-                buf.writestring(\"Nl\");\n+            visitType(t);\n+        }\n \n-            if (ta.isreturn && !ta.isreturninferred)\n-                buf.writestring(\"Nj\");\n+        void visitTypeNoreturn(TypeNoreturn t)\n+        {\n+            buf.writestring(\"Nn\");\n         }\n \n-        if (ta.islive)\n-            buf.writestring(\"Nm\");\n+        if (modMask != t.mod)\n+        {\n+            MODtoDecoBuffer(buf, t.mod);\n+        }\n+        if (backref.addRefToType(buf, t))\n+            return;\n \n-        switch (ta.trust)\n+        switch (t.ty)\n         {\n-            case TRUST.trusted:\n-                buf.writestring(\"Ne\");\n-                break;\n-            case TRUST.safe:\n-                buf.writestring(\"Nf\");\n-                break;\n-            default:\n-                break;\n+            case Tpointer:\n+            case Treference:\n+            case Tdelegate:\n+            case Tslice:     visitTypeNext      (cast(TypeNext)t);      break;\n+\n+            case Tarray:     visitTypeDArray    (t.isTypeDArray());     break;\n+            case Tsarray:    visitTypeSArray    (t.isTypeSArray());     break;\n+            case Taarray:    visitTypeAArray    (t.isTypeAArray());     break;\n+            case Tfunction:  visitTypeFunction  (t.isTypeFunction());   break;\n+            case Tident:     visitTypeIdentifier(t.isTypeIdentifier()); break;\n+            case Tclass:     visitTypeClass     (t.isTypeClass());      break;\n+            case Tstruct:    visitTypeStruct    (t.isTypeStruct());     break;\n+            case Tenum:      visitTypeEnum      (t.isTypeEnum());       break;\n+            case Ttuple:     visitTypeTuple     (t.isTypeTuple());      break;\n+            case Tnull:      visitTypeNull      (t.isTypeNull());       break;\n+            case Tvector:    visitTypeVector    (t.isTypeVector());     break;\n+            case Tnoreturn:  visitTypeNoreturn  (t.isTypeNoreturn);     break;\n+\n+            case Terror:\n+                break;      // ignore errors\n+\n+            default:         visitType(t); break;\n         }\n+    }\n \n-        // Write argument types\n-        foreach (idx, param; t.parameterList)\n-            mangleParameter(param);\n-        //if (buf.data[buf.length - 1] == '@') assert(0);\n-        buf.writeByte('Z' - t.parameterList.varargs); // mark end of arg list\n-        if (tret !is null)\n-            visitWithMask(tret, 0);\n-        t.inuse--;\n+    visitWithMask(t, modMask);\n+}\n+\n+\n+/*************************************************************\n+ */\n+void mangleFuncType(TypeFunction t, TypeFunction ta, ubyte modMask, Type tret, OutBuffer* buf, ref Backref backref)\n+{\n+    //printf(\"mangleFuncType() %s\\n\", t.toChars());\n+    if (t.inuse && tret)\n+    {\n+        // printf(\"TypeFunction.mangleFuncType() t = %s inuse\\n\", t.toChars());\n+        t.inuse = 2; // flag error to caller\n+        return;\n     }\n+    t.inuse++;\n+    if (modMask != t.mod)\n+        MODtoDecoBuffer(buf, t.mod);\n \n-    override void visit(TypeIdentifier t)\n+    char mc;\n+    final switch (t.linkage)\n+    {\n+    case LINK.default_:\n+    case LINK.d:\n+        mc = 'F';\n+        break;\n+    case LINK.c:\n+        mc = 'U';\n+        break;\n+    case LINK.windows:\n+        mc = 'W';\n+        break;\n+    case LINK.cpp:\n+        mc = 'R';\n+        break;\n+    case LINK.objc:\n+        mc = 'Y';\n+        break;\n+    case LINK.system:\n+        assert(0);\n+    }\n+    buf.writeByte(mc);\n+\n+    if (ta.purity)\n+        buf.writestring(\"Na\");\n+    if (ta.isnothrow)\n+        buf.writestring(\"Nb\");\n+    if (ta.isref)\n+        buf.writestring(\"Nc\");\n+    if (ta.isproperty)\n+        buf.writestring(\"Nd\");\n+    if (ta.isnogc)\n+        buf.writestring(\"Ni\");\n+\n+    // `return scope` must be in that order\n+    if (ta.isreturnscope && !ta.isreturninferred)\n+    {\n+        buf.writestring(\"NjNl\");\n+    }\n+    else\n     {\n-        visit(cast(Type)t);\n-        auto name = t.ident.toString();\n-        buf.print(cast(int)name.length);\n-        buf.writestring(name);\n+        // when return ref, the order is `scope return`\n+        if (ta.isScopeQual && !ta.isscopeinferred)\n+            buf.writestring(\"Nl\");\n+\n+        if (ta.isreturn && !ta.isreturninferred)\n+            buf.writestring(\"Nj\");\n     }\n \n-    override void visit(TypeEnum t)\n+    if (ta.islive)\n+        buf.writestring(\"Nm\");\n+\n+    switch (ta.trust)\n     {\n-        visit(cast(Type)t);\n-        mangleSymbol(t.sym);\n+        case TRUST.trusted:\n+            buf.writestring(\"Ne\");\n+            break;\n+        case TRUST.safe:\n+            buf.writestring(\"Nf\");\n+            break;\n+        default:\n+            break;\n     }\n \n-    override void visit(TypeStruct t)\n+    // Write argument types\n+    foreach (idx, param; t.parameterList)\n+        mangleParameter(param, buf, backref);\n+    //if (buf.data[buf.length - 1] == '@') assert(0);\n+    buf.writeByte('Z' - t.parameterList.varargs); // mark end of arg list\n+    if (tret !is null)\n+        mangleType(tret, 0, buf, backref);\n+    t.inuse--;\n+}\n+\n+/*************************************************************\n+ */\n+void mangleParameter(Parameter p, OutBuffer* buf, ref Backref backref)\n+{\n+    // https://dlang.org/spec/abi.html#Parameter\n+\n+    auto stc = p.storageClass;\n+\n+    // Inferred storage classes don't get mangled in\n+    if (stc & STC.scopeinferred)\n+        stc &= ~(STC.scope_ | STC.scopeinferred);\n+    if (stc & STC.returninferred)\n+        stc &= ~(STC.return_ | STC.returninferred);\n+\n+    // much like hdrgen.stcToBuffer()\n+    string rrs;\n+    const isout = (stc & STC.out_) != 0;\n+    final switch (buildScopeRef(stc))\n     {\n-        //printf(\"TypeStruct.toDecoBuffer('%s') = '%s'\\n\", t.toChars(), name);\n-        visit(cast(Type)t);\n-        mangleSymbol(t.sym);\n+        case ScopeRef.None:\n+        case ScopeRef.Scope:\n+        case ScopeRef.Ref:\n+        case ScopeRef.Return:\n+        case ScopeRef.RefScope:\n+            break;\n+\n+        case ScopeRef.ReturnScope:     rrs = \"NkM\";                  goto L1;  // return scope\n+        case ScopeRef.ReturnRef:       rrs = isout ? \"NkJ\"  : \"NkK\"; goto L1;  // return ref\n+        case ScopeRef.ReturnRef_Scope: rrs = isout ? \"MNkJ\" : \"MNkK\"; goto L1; // scope return ref\n+        case ScopeRef.Ref_ReturnScope: rrs = isout ? \"NkMJ\" : \"NkMK\"; goto L1; // return scope ref\n+        L1:\n+            buf.writestring(rrs);\n+            stc &= ~(STC.out_ | STC.scope_ | STC.ref_ | STC.return_);\n+            break;\n     }\n \n-    override void visit(TypeClass t)\n+    if (stc & STC.scope_)\n+        buf.writeByte('M');  // scope\n+\n+    if (stc & STC.return_)\n+        buf.writestring(\"Nk\"); // return\n+\n+    switch (stc & (STC.IOR | STC.lazy_))\n     {\n-        //printf(\"TypeClass.toDecoBuffer('%s' mod=%x) = '%s'\\n\", t.toChars(), mod, name);\n-        visit(cast(Type)t);\n-        mangleSymbol(t.sym);\n+    case 0:\n+        break;\n+    case STC.in_:\n+        buf.writeByte('I');\n+        break;\n+    case STC.in_ | STC.ref_:\n+        buf.writestring(\"IK\");\n+        break;\n+    case STC.out_:\n+        buf.writeByte('J');\n+        break;\n+    case STC.ref_:\n+        buf.writeByte('K');\n+        break;\n+    case STC.lazy_:\n+        buf.writeByte('L');\n+        break;\n+    default:\n+        debug\n+        {\n+            printf(\"storageClass = x%llx\\n\", stc & (STC.IOR | STC.lazy_));\n+        }\n+        assert(0);\n     }\n+    mangleType(p.type, (stc & STC.in_) ? MODFlags.const_ : 0, buf, backref);\n+}\n+\n+\n+private extern (C++) final class Mangler : Visitor\n+{\n+    alias visit = Visitor.visit;\n+public:\n+    static assert(Key.sizeof == size_t.sizeof);\n \n-    override void visit(TypeTuple t)\n+    OutBuffer* buf;\n+    Backref* backref;\n+\n+    extern (D) this(OutBuffer* buf, Backref* backref)\n     {\n-        //printf(\"TypeTuple.toDecoBuffer() t = %p, %s\\n\", t, t.toChars());\n-        visit(cast(Type)t);\n-        Parameter._foreach(t.arguments, (idx, param) {\n-                mangleParameter(param);\n-                return 0;\n-        });\n-        buf.writeByte('Z');\n+        this.buf = buf;\n+        this.backref = backref;\n     }\n \n-    override void visit(TypeNull t)\n+    void mangleSymbol(Dsymbol s)\n     {\n-        visit(cast(Type)t);\n+        s.accept(this);\n     }\n \n-    override void visit(TypeNoreturn t)\n+    void mangleIdentifier(Identifier id, Dsymbol s)\n     {\n-        buf.writestring(\"Nn\");\n+        if (!backref.addRefToIdentifier(buf, id))\n+            toBuffer(buf, id.toString(), s);\n     }\n \n     ////////////////////////////////////////////////////////////////////////////\n@@ -472,7 +593,7 @@ public:\n         }\n         else if (sthis.type)\n         {\n-            visitWithMask(sthis.type, 0);\n+            mangleType(sthis.type, 0, buf, *backref);\n         }\n         else\n             assert(0);\n@@ -530,11 +651,11 @@ public:\n         {\n             TypeFunction tf = fd.type.isTypeFunction();\n             TypeFunction tfo = fd.originalType.isTypeFunction();\n-            mangleFuncType(tf, tfo, 0, null);\n+            mangleFuncType(tf, tfo, 0, null, buf, *backref);\n         }\n         else\n         {\n-            visitWithMask(fd.type, 0);\n+            mangleType(fd.type, 0, buf, *backref);\n         }\n     }\n \n@@ -735,7 +856,7 @@ public:\n             if (ta)\n             {\n                 buf.writeByte('T');\n-                visitWithMask(ta, 0);\n+                mangleType(ta, 0, buf, *backref);\n             }\n             else if (ea)\n             {\n@@ -778,7 +899,7 @@ public:\n \n                 /* Use type mangling that matches what it would be for a function parameter\n                 */\n-                visitWithMask(ea.type, 0);\n+                mangleType(ea.type, 0, buf, *backref);\n                 ea.accept(this);\n             }\n             else if (sa)\n@@ -1004,77 +1125,6 @@ public:\n         else\n             mangleSymbol(e.fd);\n     }\n-\n-    ////////////////////////////////////////////////////////////////////////////\n-\n-    void mangleParameter(Parameter p)\n-    {\n-        // https://dlang.org/spec/abi.html#Parameter\n-\n-        auto stc = p.storageClass;\n-\n-        // Inferred storage classes don't get mangled in\n-        if (stc & STC.scopeinferred)\n-            stc &= ~(STC.scope_ | STC.scopeinferred);\n-        if (stc & STC.returninferred)\n-            stc &= ~(STC.return_ | STC.returninferred);\n-\n-        // much like hdrgen.stcToBuffer()\n-        string rrs;\n-        const isout = (stc & STC.out_) != 0;\n-        final switch (buildScopeRef(stc))\n-        {\n-            case ScopeRef.None:\n-            case ScopeRef.Scope:\n-            case ScopeRef.Ref:\n-            case ScopeRef.Return:\n-            case ScopeRef.RefScope:\n-                break;\n-\n-            case ScopeRef.ReturnScope:     rrs = \"NkM\";                  goto L1;  // return scope\n-            case ScopeRef.ReturnRef:       rrs = isout ? \"NkJ\"  : \"NkK\"; goto L1;  // return ref\n-            case ScopeRef.ReturnRef_Scope: rrs = isout ? \"MNkJ\" : \"MNkK\"; goto L1; // scope return ref\n-            case ScopeRef.Ref_ReturnScope: rrs = isout ? \"NkMJ\" : \"NkMK\"; goto L1; // return scope ref\n-            L1:\n-                buf.writestring(rrs);\n-                stc &= ~(STC.out_ | STC.scope_ | STC.ref_ | STC.return_);\n-                break;\n-        }\n-\n-        if (stc & STC.scope_)\n-            buf.writeByte('M');  // scope\n-\n-        if (stc & STC.return_)\n-            buf.writestring(\"Nk\"); // return\n-\n-        switch (stc & (STC.IOR | STC.lazy_))\n-        {\n-        case 0:\n-            break;\n-        case STC.in_:\n-            buf.writeByte('I');\n-            break;\n-        case STC.in_ | STC.ref_:\n-            buf.writestring(\"IK\");\n-            break;\n-        case STC.out_:\n-            buf.writeByte('J');\n-            break;\n-        case STC.ref_:\n-            buf.writeByte('K');\n-            break;\n-        case STC.lazy_:\n-            buf.writeByte('L');\n-            break;\n-        default:\n-            debug\n-            {\n-                printf(\"storageClass = x%llx\\n\", stc & (STC.IOR | STC.lazy_));\n-            }\n-            assert(0);\n-        }\n-        visitWithMask(p.type, (stc & STC.in_) ? MODFlags.const_ : 0);\n-    }\n }\n \n /***************************************\n@@ -1322,7 +1372,7 @@ void realToMangleBuffer(OutBuffer* buf, real_t value)\n \n     char[36] buffer = void;\n     // 'A' format yields [-]0xh.hhhhp+-d\n-    const n = CTFloat.sprint(buffer.ptr, 'A', value);\n+    const n = CTFloat.sprint(buffer.ptr, buffer.length, 'A', value);\n     assert(n < buffer.length);\n     foreach (const c; buffer[2 .. n])\n     {"}, {"sha": "a5f7cd321da53c521e712c13788e91d806e28a58", "filename": "gcc/d/dmd/dmodule.d", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fdmodule.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fdmodule.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdmodule.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -29,6 +29,7 @@ import dmd.dscope;\n import dmd.dsymbol;\n import dmd.dsymbolsem;\n import dmd.errors;\n+import dmd.errorsink;\n import dmd.expression;\n import dmd.expressionsem;\n import dmd.file_manager;\n@@ -766,7 +767,7 @@ extern (C++) final class Module : Package\n         {\n             filetype = FileType.c;\n \n-            scope p = new CParser!AST(this, buf, cast(bool) docfile, target.c, &defines);\n+            scope p = new CParser!AST(this, buf, cast(bool) docfile, global.errorSink, target.c, &defines);\n             p.nextToken();\n             checkCompiledImport();\n             members = p.parseModule();\n@@ -775,7 +776,7 @@ extern (C++) final class Module : Package\n         }\n         else\n         {\n-            scope p = new Parser!AST(this, buf, cast(bool) docfile);\n+            scope p = new Parser!AST(this, buf, cast(bool) docfile, global.errorSink);\n             p.nextToken();\n             p.parseModuleDeclaration();\n             md = p.md;\n@@ -1377,6 +1378,37 @@ extern (C++) struct ModuleDeclaration\n     }\n }\n \n+/****************************************\n+ * Create array of the local classes in the Module, suitable\n+ * for inclusion in ModuleInfo\n+ * Params:\n+ *      mod = the Module\n+ *      aclasses = array to fill in\n+ * Returns: array of local classes\n+ */\n+extern (C++) void getLocalClasses(Module mod, ref ClassDeclarations aclasses)\n+{\n+    //printf(\"members.length = %d\\n\", mod.members.length);\n+    int pushAddClassDg(size_t n, Dsymbol sm)\n+    {\n+        if (!sm)\n+            return 0;\n+\n+        if (auto cd = sm.isClassDeclaration())\n+        {\n+            // compatibility with previous algorithm\n+            if (cd.parent && cd.parent.isTemplateMixin())\n+                return 0;\n+\n+            if (cd.classKind != ClassKind.objc)\n+                aclasses.push(cd);\n+        }\n+        return 0;\n+    }\n+\n+    ScopeDsymbol._foreach(null, mod.members, &pushAddClassDg);\n+}\n+\n /**\n  * Process the content of a source file\n  *"}, {"sha": "88e8996ae3aafda278e3a2bf2692da70c8d99f7a", "filename": "gcc/d/dmd/doc.d", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fdoc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fdoc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdoc.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -951,7 +951,7 @@ private void emitComment(Dsymbol s, ref OutBuffer buf, Scope* sc)\n         OutBuffer* buf;\n         Scope* sc;\n \n-        extern (D) this(ref OutBuffer buf, Scope* sc)\n+        extern (D) this(ref OutBuffer buf, Scope* sc) scope\n         {\n             this.buf = &buf;\n             this.sc = sc;\n@@ -1235,7 +1235,7 @@ private void toDocBuffer(Dsymbol s, ref OutBuffer buf, Scope* sc)\n         OutBuffer* buf;\n         Scope* sc;\n \n-        extern (D) this(ref OutBuffer buf, Scope* sc)\n+        extern (D) this(ref OutBuffer buf, Scope* sc) scope\n         {\n             this.buf = &buf;\n             this.sc = sc;\n@@ -5183,6 +5183,7 @@ private void highlightCode2(Scope* sc, Dsymbols* a, ref OutBuffer buf, size_t of\n     uint errorsave = global.startGagging();\n \n     scope Lexer lex = new Lexer(null, cast(char*)buf[].ptr, 0, buf.length - 1, 0, 1,\n+        global.errorSink,\n         global.vendor, global.versionNumber());\n     OutBuffer res;\n     const(char)* lastp = cast(char*)buf[].ptr;"}, {"sha": "ab422fd0cf6024d71c02b58ba92478459139075a", "filename": "gcc/d/dmd/dscope.d", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fdscope.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fdscope.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdscope.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -64,13 +64,14 @@ enum SCOPE\n     free          = 0x8000,   /// is on free list\n \n     fullinst      = 0x10000,  /// fully instantiate templates\n+    ctfeBlock     = 0x20000,  /// inside a `if (__ctfe)` block\n }\n \n /// Flags that are carried along with a scope push()\n private enum PersistentFlags =\n     SCOPE.contract | SCOPE.debug_ | SCOPE.ctfe | SCOPE.compile | SCOPE.constraint |\n     SCOPE.noaccesscheck | SCOPE.ignoresymbolvisibility |\n-    SCOPE.Cfile;\n+    SCOPE.Cfile | SCOPE.ctfeBlock;\n \n extern (C++) struct Scope\n {\n@@ -272,6 +273,10 @@ extern (C++) struct Scope\n              *   // To call x.toString in runtime, compiler should unspeculative S!int.\n              *   assert(x.toString() == \"instantiated\");\n              * }\n+             *\n+             * This results in an undefined reference to `RTInfoImpl`:\n+             *  class C {  int a,b,c;   int* p,q; }\n+             *  void test() {    C c = new C(); }\n              */\n             // If a template is instantiated from CT evaluated expression,\n             // compiler can elide its code generation."}, {"sha": "3268d5667de88675c4df6f5dd9eddadc6c5b358a", "filename": "gcc/d/dmd/dstruct.d", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fdstruct.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fdstruct.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdstruct.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -75,7 +75,7 @@ extern (C++) void semanticTypeInfo(Scope* sc, Type t)\n     {\n         if (sc.intypeof)\n             return;\n-        if (sc.flags & (SCOPE.ctfe | SCOPE.compile))\n+        if (sc.flags & (SCOPE.ctfe | SCOPE.compile | SCOPE.ctfeBlock))\n             return;\n     }\n \n@@ -480,6 +480,16 @@ extern (C++) class StructDeclaration : AggregateDeclaration\n         return (ispod == ThreeState.yes);\n     }\n \n+    /***************************************\n+     * Determine if struct has copy construction (copy constructor or postblit)\n+     * Returns:\n+     *     true if struct has copy construction\n+     */\n+    final bool hasCopyConstruction()\n+    {\n+        return postblit || hasCopyCtor;\n+    }\n+\n     override final inout(StructDeclaration) isStructDeclaration() inout @nogc nothrow pure @safe\n     {\n         return this;"}, {"sha": "aa478f2fea22564bd5ea1062971d3cf50cfddb42", "filename": "gcc/d/dmd/dsymbol.d", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fdsymbol.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fdsymbol.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbol.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -999,10 +999,7 @@ extern (C++) class Dsymbol : ASTNode\n                 sm = sm.toAlias();\n                 TemplateDeclaration td = sm.isTemplateDeclaration();\n                 if (!td)\n-                {\n-                    .error(loc, \"`%s.%s` is not a template, it is a %s\", s.toPrettyChars(), ti.name.toChars(), sm.kind());\n-                    return null;\n-                }\n+                    return null; // error but handled later\n                 ti.tempdecl = td;\n                 if (!ti.semanticRun)\n                     ti.dsymbolSemantic(sc);\n@@ -1242,10 +1239,6 @@ extern (C++) class Dsymbol : ASTNode\n         return false;\n     }\n \n-    void addLocalClass(ClassDeclarations*)\n-    {\n-    }\n-\n     void addObjcSymbols(ClassDeclarations* classes, ClassDeclarations* categories)\n     {\n     }\n@@ -1416,6 +1409,7 @@ extern (C++) class Dsymbol : ASTNode\n     inout(OverloadSet)                 isOverloadSet()                 inout { return null; }\n     inout(CompileDeclaration)          isCompileDeclaration()          inout { return null; }\n     inout(StaticAssert)                isStaticAssert()                inout { return null; }\n+    inout(StaticIfDeclaration)         isStaticIfDeclaration()         inout { return null; }\n }\n \n /***********************************************************\n@@ -2620,6 +2614,12 @@ Dsymbol handleSymbolRedeclarations(ref Scope sc, Dsymbol s, Dsymbol s2, ScopeDsy\n \n     auto vd = s.isVarDeclaration(); // new declaration\n     auto vd2 = s2.isVarDeclaration(); // existing declaration\n+\n+    if (vd && vd.isCmacro())\n+        return vd2;\n+\n+    assert(!(vd2 && vd2.isCmacro()));\n+\n     if (vd && vd2)\n     {\n         /* if one is `static` and the other isn't, the result is undefined"}, {"sha": "1cee456aa10b6cdd653003774c1d5509cafa3a43", "filename": "gcc/d/dmd/dsymbol.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fdsymbol.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fdsymbol.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbol.h?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -72,6 +72,7 @@ class ExpressionDsymbol;\n class AliasAssign;\n class OverloadSet;\n class StaticAssert;\n+class StaticIfDeclaration;\n struct AA;\n #ifdef IN_GCC\n typedef union tree_node Symbol;\n@@ -257,7 +258,6 @@ class Dsymbol : public ASTNode\n     virtual void setFieldOffset(AggregateDeclaration *ad, FieldState& fieldState, bool isunion);\n     virtual bool hasPointers();\n     virtual bool hasStaticCtorOrDtor();\n-    virtual void addLocalClass(ClassDeclarations *) { }\n     virtual void addObjcSymbols(ClassDeclarations *, ClassDeclarations *) { }\n     virtual void checkCtorConstInit() { }\n \n@@ -323,6 +323,7 @@ class Dsymbol : public ASTNode\n     virtual OverloadSet *isOverloadSet() { return NULL; }\n     virtual CompileDeclaration *isCompileDeclaration() { return NULL; }\n     virtual StaticAssert *isStaticAssert() { return NULL; }\n+    virtual StaticIfDeclaration *isStaticIfDeclaration() { return NULL; }\n     void accept(Visitor *v) override { v->visit(this); }\n };\n "}, {"sha": "6697ad6d4d66506da429df95ab2cc0ee61313704", "filename": "gcc/d/dmd/dsymbolsem.d", "status": "modified", "additions": 147, "deletions": 65, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fdsymbolsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fdsymbolsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbolsem.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -230,12 +230,48 @@ package bool allowsContractWithoutBody(FuncDeclaration funcdecl)\n     return true;\n }\n \n+/*\n+Tests whether the `ctor` that is part of `ti` is an rvalue constructor\n+(i.e. a constructor that receives a single parameter of the same type as\n+`Unqual!typeof(this)`). If that is the case and `sd` contains a copy\n+constructor, than an error is issued.\n+\n+Params:\n+    sd = struct declaration that may contin both an rvalue and copy constructor\n+    ctor = constructor that will be checked if it is an evalue constructor\n+    ti = template instance the ctor is part of\n+\n+Return:\n+    `false` if ctor is not an rvalue constructor or if `sd` does not contain a\n+    copy constructor. `true` otherwise\n+*/\n+bool checkHasBothRvalueAndCpCtor(StructDeclaration sd, CtorDeclaration ctor, TemplateInstance ti)\n+{\n+    auto loc = ctor.loc;\n+    auto tf = cast(TypeFunction)ctor.type;\n+    auto dim = tf.parameterList.length;\n+    if (sd && sd.hasCopyCtor && (dim == 1 || (dim > 1 && tf.parameterList[1].defaultArg)))\n+    {\n+        auto param = tf.parameterList[0];\n+        if (!(param.storageClass & STC.ref_) && param.type.mutableOf().unSharedOf() == sd.type.mutableOf().unSharedOf())\n+        {\n+            .error(loc, \"cannot define both an rvalue constructor and a copy constructor for `struct %s`\", sd.toChars());\n+            .errorSupplemental(ti.loc, \"Template instance `%s` creates an rvalue constructor for `struct %s`\",\n+                    ti.toPrettyChars(), sd.toChars());\n+\n+            return true;\n+        }\n+    }\n+\n+    return false;\n+}\n+\n private extern(C++) final class DsymbolSemanticVisitor : Visitor\n {\n     alias visit = Visitor.visit;\n \n     Scope* sc;\n-    this(Scope* sc)\n+    this(Scope* sc) scope\n     {\n         this.sc = sc;\n     }\n@@ -281,6 +317,11 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             return;\n         }\n \n+        // @@@DEPRECATED_2.121@@@\n+        // Deprecated in 2.101 - Can be removed in 2.121\n+        if (ad.isClassDeclaration() || ad.isInterfaceDeclaration())\n+            deprecation(dsym.loc, \"alias this for classes/interfaces is deprecated\");\n+\n         assert(ad.members);\n         Dsymbol s = ad.search(dsym.loc, dsym.ident);\n         if (!s)\n@@ -338,6 +379,11 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             return;\n         assert(dsym.semanticRun <= PASS.semantic);\n \n+        if (!sc)\n+            return;\n+\n+        dsym.semanticRun = PASS.semantic;\n+\n         dsym.storage_class |= sc.stc & STC.deprecated_;\n         dsym.visibility = sc.visibility;\n         dsym.userAttribDecl = sc.userAttribDecl;\n@@ -509,10 +555,10 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n         {\n             if (inferred)\n             {\n-                dsym.error(\"type `%s` is inferred from initializer `%s`, and variables cannot be of type `void`\", dsym.type.toChars(), dsym._init.toChars());\n+                dsym.error(\"- type `%s` is inferred from initializer `%s`, and variables cannot be of type `void`\", dsym.type.toChars(), dsym._init.toChars());\n             }\n             else\n-                dsym.error(\"variables cannot be of type `void`\");\n+                dsym.error(\"- variables cannot be of type `void`\");\n             dsym.type = Type.terror;\n             tb = dsym.type;\n         }\n@@ -528,7 +574,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             // or when the variable is defined externally\n             if (!ts.sym.members && !(dsym.storage_class & (STC.ref_ | STC.extern_)))\n             {\n-                dsym.error(\"no definition of struct `%s`\", ts.toChars());\n+                dsym.error(\"- no definition of struct `%s`\", ts.toChars());\n \n                 // Explain why the definition is required when it's part of another type\n                 if (!dsym.type.isTypeStruct())\n@@ -544,7 +590,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             }\n         }\n         if ((dsym.storage_class & STC.auto_) && !inferred)\n-            dsym.error(\"storage class `auto` has no effect if type is not inferred, did you mean `scope`?\");\n+            dsym.error(\"- storage class `auto` has no effect if type is not inferred, did you mean `scope`?\");\n \n         if (auto tt = tb.isTypeTuple())\n         {\n@@ -689,7 +735,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             auto v2 = new TupleDeclaration(dsym.loc, dsym.ident, exps);\n             v2.parent = dsym.parent;\n             v2.isexp = true;\n-            dsym.aliassym = v2;\n+            dsym.aliasTuple = v2;\n             dsym.semanticRun = PASS.semanticdone;\n             return;\n         }\n@@ -742,7 +788,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             }\n             else if (dsym.isMember())\n             {\n-                dsym.error(\"field cannot be `scope`\");\n+                error(dsym.loc, \"field `%s` cannot be `scope`\", dsym.toChars());\n             }\n             else if (!dsym.type.hasPointers())\n             {\n@@ -780,11 +826,11 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             InterfaceDeclaration id = parent.isInterfaceDeclaration();\n             if (id)\n             {\n-                dsym.error(\"field not allowed in interface\");\n+                error(dsym.loc, \"field `%s` not allowed in interface\", dsym.toChars());\n             }\n             else if (aad && aad.sizeok == Sizeok.done)\n             {\n-                dsym.error(\"cannot be further field because it will change the determined %s size\", aad.toChars());\n+                error(dsym.loc, \"cannot declare field `%s` because it will change the determined size of `%s`\", dsym.toChars(), aad.toChars());\n             }\n \n             /* Templates cannot add fields to aggregates\n@@ -804,21 +850,37 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                 AggregateDeclaration ad2 = ti.tempdecl.isMember();\n                 if (ad2 && dsym.storage_class != STC.undefined_)\n                 {\n-                    dsym.error(\"cannot use template to add field to aggregate `%s`\", ad2.toChars());\n+                    dsym.error(\"- cannot use template to add field to aggregate `%s`\", ad2.toChars());\n                 }\n             }\n         }\n \n+        /* If the alignment of a stack local is greater than the stack alignment,\n+         * note it in the enclosing function's alignSectionVars\n+         */\n+        version (MARS)\n+        {\n+            if (!dsym.alignment.isDefault() && sc.func &&\n+                dsym.alignment.get() > target.stackAlign() &&\n+                sc.func && !dsym.isDataseg() && !dsym.isParameter() && !dsym.isField())\n+            {\n+                auto fd = sc.func;\n+                if (!fd.alignSectionVars)\n+                    fd.alignSectionVars = new VarDeclarations();\n+                fd.alignSectionVars.push(dsym);\n+            }\n+        }\n+\n         if ((dsym.storage_class & (STC.ref_ | STC.parameter | STC.foreach_ | STC.temp | STC.result)) == STC.ref_ && dsym.ident != Id.This)\n         {\n-            dsym.error(\"only parameters or `foreach` declarations can be `ref`\");\n+            dsym.error(\"- only parameters, functions and `foreach` declarations can be `ref`\");\n         }\n \n         if (dsym.type.hasWild())\n         {\n             if (dsym.storage_class & (STC.static_ | STC.extern_ | STC.gshared | STC.manifest | STC.field) || dsym.isDataseg())\n             {\n-                dsym.error(\"only parameters or stack based variables can be `inout`\");\n+                dsym.error(\"- only parameters or stack-based variables can be `inout`\");\n             }\n             FuncDeclaration func = sc.func;\n             if (func)\n@@ -836,7 +898,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                 }\n                 if (!isWild)\n                 {\n-                    dsym.error(\"`inout` variables can only be declared inside `inout` functions\");\n+                    dsym.error(\"- `inout` variables can only be declared inside `inout` functions\");\n                 }\n             }\n         }\n@@ -856,7 +918,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                 {\n                 }\n                 else\n-                    dsym.error(\"default construction is disabled for type `%s`\", dsym.type.toChars());\n+                    dsym.error(\"- default construction is disabled for type `%s`\", dsym.type.toChars());\n             }\n         }\n \n@@ -911,7 +973,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n         if (dsym._init)\n         { } // remember we had an explicit initializer\n         else if (dsym.storage_class & STC.manifest)\n-            dsym.error(\"manifest constants must have initializers\");\n+            dsym.error(\"- manifest constants must have initializers\");\n \n         // Don't allow non-extern, non-__gshared variables to be interfaced with C++\n         if (dsym._linkage == LINK.cpp && !(dsym.storage_class & (STC.ctfe | STC.extern_ | STC.gshared)) && dsym.isDataseg())\n@@ -939,7 +1001,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n \n             //printf(\"Providing default initializer for '%s'\\n\", dsym.toChars());\n             if (sz == SIZE_INVALID && dsym.type.ty != Terror)\n-                dsym.error(\"size of type `%s` is invalid\", dsym.type.toChars());\n+                dsym.error(\"- size of type `%s` is invalid\", dsym.type.toChars());\n \n             Type tv = dsym.type;\n             while (tv.ty == Tsarray)    // Don't skip Tenum\n@@ -974,7 +1036,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             }\n             if (dsym.type.baseElemOf().ty == Tvoid)\n             {\n-                dsym.error(\"`%s` does not have a default initializer\", dsym.type.toChars());\n+                dsym.error(\"of type `%s` does not have a default initializer\", dsym.type.toChars());\n             }\n             else if (auto e = dsym.type.defaultInit(dsym.loc))\n             {\n@@ -995,7 +1057,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                 dsym._init.isVoidInitializer() &&\n                 !(dsym.storage_class & STC.field))\n             {\n-                dsym.error(\"incomplete array type must have initializer\");\n+                dsym.error(\"- incomplete array type must have initializer\");\n             }\n \n             ExpInitializer ei = dsym._init.isExpInitializer();\n@@ -1049,9 +1111,26 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                             ex = (cast(AssignExp)ex).e2;\n                         if (auto ne = ex.isNewExp())\n                         {\n-                            // See if initializer is a NewExp that can be allocated on the stack\n+                            /* See if initializer is a NewExp that can be allocated on the stack.\n+                             */\n                             if (dsym.type.toBasetype().ty == Tclass)\n                             {\n+                                /* Unsafe to allocate on stack if constructor is not `scope` because the `this` can leak.\n+                                 * https://issues.dlang.org/show_bug.cgi?id=23145\n+                                 */\n+                                if (ne.member && !(ne.member.storage_class & STC.scope_))\n+                                {\n+                                    if (sc.func.isSafe())\n+                                    {\n+                                        // @@@DEPRECATED_2.112@@@\n+                                        deprecation(dsym.loc,\n+                                            \"`scope` allocation of `%s` requires that constructor be annotated with `scope`\",\n+                                            dsym.toChars());\n+                                        deprecationSupplemental(ne.member.loc, \"is the location of the constructor\");\n+                                     }\n+                                     else\n+                                         sc.func.setUnsafe();\n+                                }\n                                 ne.onstack = 1;\n                                 dsym.onstack = true;\n                             }\n@@ -1244,7 +1323,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n \n         if (!dsym.parent.isStructDeclaration() && !dsym.parent.isClassDeclaration())\n         {\n-            dsym.error(\"bit-field must be member of struct, union, or class\");\n+            dsym.error(\"- bit-field must be member of struct, union, or class\");\n         }\n \n         sc = sc.startCTFE();\n@@ -1534,12 +1613,12 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             e = se;\n             if (!se.len)\n             {\n-                pd.error(\"zero-length string not allowed for mangled name\");\n+                pd.error(\"- zero-length string not allowed for mangled name\");\n                 return null;\n             }\n             if (se.sz != 1)\n             {\n-                pd.error(\"mangled name characters can only be of type `char`\");\n+                pd.error(\"- mangled name characters can only be of type `char`\");\n                 return null;\n             }\n             version (all)\n@@ -1742,7 +1821,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                 pd.args = new Expressions();\n             if (pd.args.length == 0 || pd.args.length > 2)\n             {\n-                pd.error(pd.args.length == 0 ? \"string expected for mangled name\"\n+                pd.error(pd.args.length == 0 ? \"- string expected for mangled name\"\n                                           : \"expected 1 or 2 arguments\");\n                 pd.args.setDim(1);\n                 (*pd.args)[0] = ErrorExp.get(); // error recovery\n@@ -1854,7 +1933,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n         const len = buf.length;\n         buf.writeByte(0);\n         const str = buf.extractSlice()[0 .. len];\n-        scope p = new Parser!ASTCodegen(cd.loc, sc._module, str, false);\n+        scope p = new Parser!ASTCodegen(cd.loc, sc._module, str, false, global.errorSink);\n         p.nextToken();\n \n         auto d = p.parseDeclDefs(0);\n@@ -2656,7 +2735,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n \n     override void visit(TemplateInstance ti)\n     {\n-        templateInstanceSemantic(ti, sc, null);\n+        templateInstanceSemantic(ti, sc, ArgumentList());\n     }\n \n     override void visit(TemplateMixin tm)\n@@ -2694,7 +2773,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n         /* Run semantic on each argument, place results in tiargs[],\n          * then find best match template with tiargs\n          */\n-        if (!tm.findTempDecl(sc) || !tm.semanticTiargs(sc) || !tm.findBestMatch(sc, null))\n+        if (!tm.findTempDecl(sc) || !tm.semanticTiargs(sc) || !tm.findBestMatch(sc, ArgumentList()))\n         {\n             if (tm.semanticRun == PASS.initial) // forward reference had occurred\n             {\n@@ -3054,7 +3133,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n         //printf(\"function storage_class = x%llx, sc.stc = x%llx, %x\\n\", storage_class, sc.stc, Declaration.isFinal());\n \n         if (sc.flags & SCOPE.compile)\n-            funcdecl.isCompileTimeOnly = true; // don't emit code for this function\n+            funcdecl.skipCodegen = true;\n \n         funcdecl._linkage = sc.linkage;\n         if (auto fld = funcdecl.isFuncLiteralDeclaration())\n@@ -3844,11 +3923,25 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n \n                         if (fd.ident == funcdecl.ident)\n                             hgs.fullQual = true;\n-                        functionToBufferFull(cast(TypeFunction)(fd.type), &buf1,\n-                            new Identifier(fd.toPrettyChars()), &hgs, null);\n \n-                        error(funcdecl.loc, \"function `%s` does not override any function, did you mean to override `%s`?\",\n-                            funcdeclToChars, buf1.peekChars());\n+                        // https://issues.dlang.org/show_bug.cgi?id=23745\n+                        // If the potentially overriden function contains errors,\n+                        // inform the user to fix that one first\n+                        if (fd.errors)\n+                        {\n+                            error(funcdecl.loc, \"function `%s` does not override any function, did you mean to override `%s`?\",\n+                                funcdecl.toChars(), fd.toPrettyChars());\n+                            errorSupplemental(fd.loc, \"Function `%s` contains errors in its declaration, therefore it cannot be correctly overriden\",\n+                                fd.toPrettyChars());\n+                        }\n+                        else\n+                        {\n+                            functionToBufferFull(cast(TypeFunction)(fd.type), &buf1,\n+                                new Identifier(fd.toPrettyChars()), &hgs, null);\n+\n+                            error(funcdecl.loc, \"function `%s` does not override any function, did you mean to override `%s`?\",\n+                                funcdeclToChars, buf1.peekChars());\n+                       }\n                     }\n                     else\n                     {\n@@ -4088,9 +4181,8 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             else if (dim == 0 && tf.parameterList.varargs != VarArg.none) // allow varargs only ctor\n             {\n             }\n-            else if (dim && tf.parameterList[0].defaultArg)\n+            else if (dim && !tf.parameterList.hasArgsWithoutDefault)\n             {\n-                // if the first parameter has a default argument, then the rest does as well\n                 if (ctd.storage_class & STC.disable)\n                 {\n                     ctd.error(\"is marked `@disable`, so it cannot have default \"~\n@@ -4115,20 +4207,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n         // https://issues.dlang.org/show_bug.cgi?id=22593\n         else if (auto ti = ctd.parent.isTemplateInstance())\n         {\n-            if (!sd || !sd.hasCopyCtor || !(dim == 1 || (dim > 1 && tf.parameterList[1].defaultArg)))\n-                return;\n-\n-            auto param = tf.parameterList[0];\n-\n-            // if the template instance introduces an rvalue constructor\n-            // between the members of a struct declaration, we should check if a\n-            // copy constructor exists and issue an error in that case.\n-            if (!(param.storageClass & STC.ref_) && param.type.mutableOf().unSharedOf() == sd.type.mutableOf().unSharedOf())\n-            {\n-                .error(ctd.loc, \"cannot define both an rvalue constructor and a copy constructor for `struct %s`\", sd.toChars);\n-                .errorSupplemental(ti.loc, \"Template instance `%s` creates a rvalue constructor for `struct %s`\",\n-                        ti.toChars(), sd.toChars());\n-            }\n+            checkHasBothRvalueAndCpCtor(sd, ctd, ti);\n         }\n     }\n \n@@ -4171,8 +4250,8 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n \n     override void visit(DtorDeclaration dd)\n     {\n-        //printf(\"DtorDeclaration::semantic() %s\\n\", toChars());\n-        //printf(\"ident: %s, %s, %p, %p\\n\", ident.toChars(), Id.dtor.toChars(), ident, Id.dtor);\n+        //printf(\"DtorDeclaration::semantic() %s\\n\", dd.toChars());\n+        //printf(\"ident: %s, %s, %p, %p\\n\", dd.ident.toChars(), Id.dtor.toChars(), dd.ident, Id.dtor);\n         if (dd.semanticRun >= PASS.semanticdone)\n             return;\n         if (dd._scope)\n@@ -4534,7 +4613,8 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n \n     override void visit(StructDeclaration sd)\n     {\n-        //printf(\"StructDeclaration::semantic(this=%p, '%s', sizeok = %d)\\n\", sd, sd.toPrettyChars(), sd.sizeok);\n+        enum log = false;\n+        if (log) printf(\"+StructDeclaration::semantic(this=%p, '%s', sizeok = %d)\\n\", sd, sd.toPrettyChars(), sd.sizeok);\n \n         //static int count; if (++count == 20) assert(0);\n \n@@ -4604,6 +4684,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n \n         if (!sd.members) // if opaque declaration\n         {\n+            if (log) printf(\"\\topaque declaration %s\\n\", sd.toChars());\n             sd.semanticRun = PASS.semanticdone;\n             return;\n         }\n@@ -4655,7 +4736,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n \n             sc2.pop();\n \n-            //printf(\"\\tdeferring %s\\n\", toChars());\n+            if (log) printf(\"\\tdeferring %s\\n\", sd.toChars());\n             return deferDsymbolSemantic(sd, scx);\n         }\n \n@@ -4685,7 +4766,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n         sd.inv = buildInv(sd, sc2);\n \n         sd.semanticRun = PASS.semanticdone;\n-        //printf(\"-StructDeclaration::semantic(this=%p, '%s')\\n\", sd, sd.toChars());\n+        if (log) printf(\"-StructDeclaration::semantic(this=%p, '%s', sizeok = %d)\\n\", sd, sd.toPrettyChars(), sd.sizeok);\n \n         sc2.pop();\n \n@@ -4698,7 +4779,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                 sc = sc.push();\n                 sc.tinst = null;\n                 sc.minst = null;\n-                auto fcall = resolveFuncCall(sd.loc, sc, scall, null, null, null, FuncResolveFlag.quiet);\n+                auto fcall = resolveFuncCall(sd.loc, sc, scall, null, null, ArgumentList(), FuncResolveFlag.quiet);\n                 sc = sc.pop();\n                 global.endGagging(xerrors);\n \n@@ -4752,6 +4833,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n         // Make an error in 2.110\n         if (sd.storage_class & STC.scope_)\n             deprecation(sd.loc, \"`scope` as a type constraint is deprecated.  Use `scope` at the usage site.\");\n+        //printf(\"-StructDeclaration::semantic(this=%p, '%s', sizeok = %d)\\n\", sd, sd.toPrettyChars(), sd.sizeok);\n     }\n \n     void interfaceSemantic(ClassDeclaration cd)\n@@ -5297,9 +5379,9 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n         //    this() { }\n         if (!cldec.ctor && cldec.baseClass && cldec.baseClass.ctor)\n         {\n-            auto fd = resolveFuncCall(cldec.loc, sc2, cldec.baseClass.ctor, null, cldec.type, null, FuncResolveFlag.quiet);\n+            auto fd = resolveFuncCall(cldec.loc, sc2, cldec.baseClass.ctor, null, cldec.type, ArgumentList(), FuncResolveFlag.quiet);\n             if (!fd) // try shared base ctor instead\n-                fd = resolveFuncCall(cldec.loc, sc2, cldec.baseClass.ctor, null, cldec.type.sharedOf, null, FuncResolveFlag.quiet);\n+                fd = resolveFuncCall(cldec.loc, sc2, cldec.baseClass.ctor, null, cldec.type.sharedOf, ArgumentList(), FuncResolveFlag.quiet);\n             if (fd && !fd.errors)\n             {\n                 //printf(\"Creating default this(){} for class %s\\n\", toChars());\n@@ -5311,7 +5393,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                 // is less strict (e.g. `preview=dtorfields` might introduce a call to a less qualified dtor)\n \n                 auto ctor = new CtorDeclaration(cldec.loc, Loc.initial, 0, tf);\n-                ctor.storage_class |= STC.inference;\n+                ctor.storage_class |= STC.inference | (fd.storage_class & STC.scope_);\n                 ctor.isGenerated = true;\n                 ctor.fbody = new CompoundStatement(Loc.initial, new Statements());\n \n@@ -5776,7 +5858,7 @@ void addEnumMembers(EnumDeclaration ed, Scope* sc, ScopeDsymbol sds)\n     });\n }\n \n-void templateInstanceSemantic(TemplateInstance tempinst, Scope* sc, Expressions* fargs)\n+void templateInstanceSemantic(TemplateInstance tempinst, Scope* sc, ArgumentList argumentList)\n {\n     //printf(\"[%s] TemplateInstance.dsymbolSemantic('%s', this=%p, gag = %d, sc = %p)\\n\", tempinst.loc.toChars(), tempinst.toChars(), tempinst, global.gag, sc);\n     version (none)\n@@ -5848,7 +5930,7 @@ void templateInstanceSemantic(TemplateInstance tempinst, Scope* sc, Expressions*\n      * then run semantic on each argument (place results in tiargs[]),\n      * last find most specialized template from overload list/set.\n      */\n-    if (!tempinst.findTempDecl(sc, null) || !tempinst.semanticTiargs(sc) || !tempinst.findBestMatch(sc, fargs))\n+    if (!tempinst.findTempDecl(sc, null) || !tempinst.semanticTiargs(sc) || !tempinst.findBestMatch(sc, argumentList))\n     {\n     Lerror:\n         if (tempinst.gagged)\n@@ -5901,6 +5983,8 @@ void templateInstanceSemantic(TemplateInstance tempinst, Scope* sc, Expressions*\n         return aliasInstanceSemantic(tempinst, sc, tempdecl);\n     }\n \n+    Expressions* fargs = argumentList.arguments; // TODO: resolve named args\n+\n     /* See if there is an existing TemplateInstantiation that already\n      * implements the typeargs. If so, just refer to that one instead.\n      */\n@@ -5986,7 +6070,7 @@ void templateInstanceSemantic(TemplateInstance tempinst, Scope* sc, Expressions*\n                 alias visit = Visitor.visit;\n                 TemplateInstance inst;\n \n-                extern (D) this(TemplateInstance inst)\n+                extern (D) this(TemplateInstance inst) scope\n                 {\n                     this.inst = inst;\n                 }\n@@ -6142,7 +6226,7 @@ void templateInstanceSemantic(TemplateInstance tempinst, Scope* sc, Expressions*\n         Dsymbol s;\n         if (Dsymbol.oneMembers(tempinst.members, &s, tempdecl.ident) && s)\n         {\n-            //printf(\"tempdecl.ident = %s, s = '%s'\\n\", tempdecl.ident.toChars(), s.kind(), s.toPrettyChars());\n+            //printf(\"tempdecl.ident = %s, s = `%s %s`\\n\", tempdecl.ident.toChars(), s.kind(), s.toPrettyChars());\n             //printf(\"setting aliasdecl\\n\");\n             tempinst.aliasdecl = s;\n         }\n@@ -6189,7 +6273,7 @@ void templateInstanceSemantic(TemplateInstance tempinst, Scope* sc, Expressions*\n         {\n             if (!tempinst.aliasdecl || tempinst.aliasdecl != s)\n             {\n-                //printf(\"tempdecl.ident = %s, s = '%s'\\n\", tempdecl.ident.toChars(), s.kind(), s.toPrettyChars());\n+                //printf(\"tempdecl.ident = %s, s = `%s %s`\\n\", tempdecl.ident.toChars(), s.kind(), s.toPrettyChars());\n                 //printf(\"setting aliasdecl 2\\n\");\n                 tempinst.aliasdecl = s;\n             }\n@@ -7022,12 +7106,10 @@ bool determineFields(AggregateDeclaration ad)\n         if (ad.sizeok != Sizeok.none)\n             return 1;\n \n-        if (v.aliassym)\n+        if (v.aliasTuple)\n         {\n             // If this variable was really a tuple, process each element.\n-            if (auto tup = v.aliassym.isTupleDeclaration())\n-                return tup.foreachVar(tv => tv.apply(&func, ad));\n-            return 0;\n+            return v.aliasTuple.foreachVar(tv => tv.apply(&func, ad));\n         }\n \n         if (v.storage_class & (STC.static_ | STC.extern_ | STC.tls | STC.gshared | STC.manifest | STC.ctfe | STC.templateparameter))"}, {"sha": "ad3a6d4dd54f9e9af4904691d87ad341e5f438a7", "filename": "gcc/d/dmd/dtemplate.d", "status": "modified", "additions": 173, "deletions": 74, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fdtemplate.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fdtemplate.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdtemplate.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -45,6 +45,7 @@ import dmd.aliasthis;\n import dmd.arraytypes;\n import dmd.astenums;\n import dmd.ast_node;\n+import dmd.attrib;\n import dmd.dcast;\n import dmd.dclass;\n import dmd.declaration;\n@@ -1050,7 +1051,7 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n      *      dedtypes        deduced arguments\n      * Return match level.\n      */\n-    extern (D) MATCH matchWithInstance(Scope* sc, TemplateInstance ti, Objects* dedtypes, Expressions* fargs, int flag)\n+    extern (D) MATCH matchWithInstance(Scope* sc, TemplateInstance ti, Objects* dedtypes, ArgumentList argumentList, int flag)\n     {\n         enum LOGM = 0;\n         static if (LOGM)\n@@ -1168,6 +1169,12 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n             if (fd)\n             {\n                 TypeFunction tf = fd.type.isTypeFunction().syntaxCopy();\n+                if (argumentList.hasNames)\n+                    return nomatch();\n+                Expressions* fargs = argumentList.arguments;\n+                // TODO: Expressions* fargs = tf.resolveNamedArgs(argumentList, null);\n+                // if (!fargs)\n+                //     return nomatch();\n \n                 fd = new FuncDeclaration(fd.loc, fd.endloc, fd.ident, fd.storage_class, tf);\n                 fd.parent = ti;\n@@ -1226,7 +1233,7 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n         paramscope.pop();\n         static if (LOGM)\n         {\n-            printf(\"-TemplateDeclaration.matchWithInstance(this = %p, ti = %p) = %d\\n\", this, ti, m);\n+            printf(\"-TemplateDeclaration.matchWithInstance(this = %s, ti = %s) = %d\\n\", toChars(), ti.toChars(), m);\n         }\n         return m;\n     }\n@@ -1237,7 +1244,7 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n      *      match   this is at least as specialized as td2\n      *      0       td2 is more specialized than this\n      */\n-    MATCH leastAsSpecialized(Scope* sc, TemplateDeclaration td2, Expressions* fargs)\n+    MATCH leastAsSpecialized(Scope* sc, TemplateDeclaration td2, ArgumentList argumentList)\n     {\n         enum LOG_LEASTAS = 0;\n         static if (LOG_LEASTAS)\n@@ -1272,7 +1279,7 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n         Objects dedtypes = Objects(td2.parameters.length);\n \n         // Attempt a type deduction\n-        MATCH m = td2.matchWithInstance(sc, ti, &dedtypes, fargs, 1);\n+        MATCH m = td2.matchWithInstance(sc, ti, &dedtypes, argumentList, 1);\n         if (m > MATCH.nomatch)\n         {\n             /* A non-variadic template is more specialized than a\n@@ -1303,14 +1310,14 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n      *      sc              instantiation scope\n      *      fd\n      *      tthis           'this' argument if !NULL\n-     *      fargs           arguments to function\n+     *      argumentList    arguments to function\n      * Output:\n      *      fd              Partially instantiated function declaration\n      *      ti.tdtypes     Expression/Type deduced template arguments\n      * Returns:\n      *      match pair of initial and inferred template arguments\n      */\n-    extern (D) MATCHpair deduceFunctionTemplateMatch(TemplateInstance ti, Scope* sc, ref FuncDeclaration fd, Type tthis, Expressions* fargs)\n+    extern (D) MATCHpair deduceFunctionTemplateMatch(TemplateInstance ti, Scope* sc, ref FuncDeclaration fd, Type tthis, ArgumentList argumentList)\n     {\n         size_t nfparams;\n         size_t nfargs;\n@@ -1334,7 +1341,7 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n             for (size_t i = 0; i < (fargs ? fargs.length : 0); i++)\n             {\n                 Expression e = (*fargs)[i];\n-                printf(\"\\tfarg[%d] is %s, type is %s\\n\", i, e.toChars(), e.type.toChars());\n+                printf(\"\\tfarg[%d] is %s, type is %s\\n\", cast(int) i, e.toChars(), e.type.toChars());\n             }\n             printf(\"fd = %s\\n\", fd.toChars());\n             printf(\"fd.type = %s\\n\", fd.type.toChars());\n@@ -1458,7 +1465,10 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n \n         fparameters = fd.getParameterList();\n         nfparams = fparameters.length; // number of function parameters\n-        nfargs = fargs ? fargs.length : 0; // number of function arguments\n+        nfargs = argumentList.length; // number of function arguments\n+        if (argumentList.hasNames)\n+            return matcherror(); // TODO: resolve named args\n+        Expressions* fargs = argumentList.arguments; // TODO: resolve named args\n \n         /* Check for match of function arguments with variadic template\n          * parameter, such as:\n@@ -2593,13 +2603,12 @@ extern (C++) final class TypeDeduced : Type\n  *      sc          = instantiation scope\n  *      tiargs      = initial list of template arguments\n  *      tthis       = if !NULL, the 'this' pointer argument\n- *      fargs       = arguments to function\n+ *      argumentList= arguments to function\n  *      pMessage    = address to store error message, or null\n  */\n void functionResolve(ref MatchAccumulator m, Dsymbol dstart, Loc loc, Scope* sc, Objects* tiargs,\n-    Type tthis, Expressions* fargs, const(char)** pMessage = null)\n+    Type tthis, ArgumentList argumentList, const(char)** pMessage = null)\n {\n-    Expression[] fargs_ = fargs.peekSlice();\n     version (none)\n     {\n         printf(\"functionResolve() dstart = %s\\n\", dstart.toChars());\n@@ -2704,7 +2713,7 @@ void functionResolve(ref MatchAccumulator m, Dsymbol dstart, Loc loc, Scope* sc,\n             else if (shared_this && !shared_dtor && tthis_fd !is null)\n                 tf.mod = tthis_fd.mod;\n         }\n-        MATCH mfa = tf.callMatch(tthis_fd, fargs_, 0, pMessage, sc);\n+        MATCH mfa = tf.callMatch(tthis_fd, argumentList, 0, pMessage, sc);\n         //printf(\"test1: mfa = %d\\n\", mfa);\n         if (mfa == MATCH.nomatch)\n             return 0;\n@@ -2737,8 +2746,8 @@ void functionResolve(ref MatchAccumulator m, Dsymbol dstart, Loc loc, Scope* sc,\n          * This is because f() is \"more specialized.\"\n          */\n         {\n-            MATCH c1 = fd.leastAsSpecialized(m.lastf);\n-            MATCH c2 = m.lastf.leastAsSpecialized(fd);\n+            MATCH c1 = fd.leastAsSpecialized(m.lastf, argumentList.names);\n+            MATCH c2 = m.lastf.leastAsSpecialized(fd, argumentList.names);\n             //printf(\"c1 = %d, c2 = %d\\n\", c1, c2);\n             if (c1 > c2) return firstIsBetter();\n             if (c1 < c2) return 0;\n@@ -2806,7 +2815,7 @@ void functionResolve(ref MatchAccumulator m, Dsymbol dstart, Loc loc, Scope* sc,\n \n     int applyTemplate(TemplateDeclaration td)\n     {\n-        //printf(\"applyTemplate()\\n\");\n+        //printf(\"applyTemplate(): td = %s\\n\", td.toChars());\n         if (td == td_best)   // skip duplicates\n             return 0;\n \n@@ -2830,6 +2839,11 @@ void functionResolve(ref MatchAccumulator m, Dsymbol dstart, Loc loc, Scope* sc,\n         }\n         //printf(\"td = %s\\n\", td.toChars());\n \n+        if (argumentList.hasNames)\n+        {\n+            .error(loc, \"named arguments with Implicit Function Template Instantiation are not supported yet\");\n+            goto Lerror;\n+        }\n         auto f = td.onemember ? td.onemember.isFuncDeclaration() : null;\n         if (!f)\n         {\n@@ -2838,12 +2852,12 @@ void functionResolve(ref MatchAccumulator m, Dsymbol dstart, Loc loc, Scope* sc,\n             auto ti = new TemplateInstance(loc, td, tiargs);\n             Objects dedtypes = Objects(td.parameters.length);\n             assert(td.semanticRun != PASS.initial);\n-            MATCH mta = td.matchWithInstance(sc, ti, &dedtypes, fargs, 0);\n+            MATCH mta = td.matchWithInstance(sc, ti, &dedtypes, argumentList, 0);\n             //printf(\"matchWithInstance = %d\\n\", mta);\n             if (mta == MATCH.nomatch || mta < ta_last)   // no match or less match\n                 return 0;\n \n-            ti.templateInstanceSemantic(sc, fargs);\n+            ti.templateInstanceSemantic(sc, argumentList);\n             if (!ti.inst)               // if template failed to expand\n                 return 0;\n \n@@ -2882,13 +2896,13 @@ void functionResolve(ref MatchAccumulator m, Dsymbol dstart, Loc loc, Scope* sc,\n                 pr.dedargs = &dedtypesX;\n                 tdx.previous = &pr;             // add this to threaded list\n \n-                fd = resolveFuncCall(loc, sc, s, null, tthis, fargs, FuncResolveFlag.quiet);\n+                fd = resolveFuncCall(loc, sc, s, null, tthis, argumentList, FuncResolveFlag.quiet);\n \n                 tdx.previous = pr.prev;         // unlink from threaded list\n             }\n             else if (s.isFuncDeclaration())\n             {\n-                fd = resolveFuncCall(loc, sc, s, null, tthis, fargs, FuncResolveFlag.quiet);\n+                fd = resolveFuncCall(loc, sc, s, null, tthis, argumentList, FuncResolveFlag.quiet);\n             }\n             else\n                 goto Lerror;\n@@ -2907,7 +2921,7 @@ void functionResolve(ref MatchAccumulator m, Dsymbol dstart, Loc loc, Scope* sc,\n             Type tthis_fd = fd.needThis() && !fd.isCtorDeclaration() ? tthis : null;\n \n             auto tf = cast(TypeFunction)fd.type;\n-            MATCH mfa = tf.callMatch(tthis_fd, fargs_, 0, null, sc);\n+            MATCH mfa = tf.callMatch(tthis_fd, argumentList, 0, null, sc);\n             if (mfa < m.last)\n                 return 0;\n \n@@ -2954,7 +2968,7 @@ void functionResolve(ref MatchAccumulator m, Dsymbol dstart, Loc loc, Scope* sc,\n             ti.parent = td.parent;  // Maybe calculating valid 'enclosing' is unnecessary.\n \n             auto fd = f;\n-            MATCHpair x = td.deduceFunctionTemplateMatch(ti, sc, fd, tthis, fargs);\n+            MATCHpair x = td.deduceFunctionTemplateMatch(ti, sc, fd, tthis, argumentList);\n             MATCH mta = x.mta;\n             MATCH mfa = x.mfa;\n             //printf(\"match:t/f = %d/%d\\n\", mta, mfa);\n@@ -2967,7 +2981,6 @@ void functionResolve(ref MatchAccumulator m, Dsymbol dstart, Loc loc, Scope* sc,\n             if (isCtorCall)\n             {\n                 // Constructor call requires additional check.\n-\n                 auto tf = cast(TypeFunction)fd.type;\n                 assert(tf.next);\n                 if (MODimplicitConv(tf.mod, tthis_fd.mod) ||\n@@ -2978,6 +2991,16 @@ void functionResolve(ref MatchAccumulator m, Dsymbol dstart, Loc loc, Scope* sc,\n                 }\n                 else\n                     continue;   // MATCH.nomatch\n+\n+                // need to check here whether the constructor is the member of a struct\n+                // declaration that defines a copy constructor. This is already checked\n+                // in the semantic of CtorDeclaration, however, when matching functions,\n+                // the template instance is not expanded.\n+                // https://issues.dlang.org/show_bug.cgi?id=21613\n+                auto ad = fd.isThis();\n+                auto sd = ad.isStructDeclaration();\n+                if (checkHasBothRvalueAndCpCtor(sd, fd.isCtorDeclaration(), ti))\n+                    continue;\n             }\n \n             if (mta < ta_last) goto Ltd_best;\n@@ -2989,8 +3012,8 @@ void functionResolve(ref MatchAccumulator m, Dsymbol dstart, Loc loc, Scope* sc,\n             if (td_best)\n             {\n                 // Disambiguate by picking the most specialized TemplateDeclaration\n-                MATCH c1 = td.leastAsSpecialized(sc, td_best, fargs);\n-                MATCH c2 = td_best.leastAsSpecialized(sc, td, fargs);\n+                MATCH c1 = td.leastAsSpecialized(sc, td_best, argumentList);\n+                MATCH c2 = td_best.leastAsSpecialized(sc, td, argumentList);\n                 //printf(\"1: c1 = %d, c2 = %d\\n\", c1, c2);\n                 if (c1 > c2) goto Ltd;\n                 if (c1 < c2) goto Ltd_best;\n@@ -3000,16 +3023,16 @@ void functionResolve(ref MatchAccumulator m, Dsymbol dstart, Loc loc, Scope* sc,\n                 // Disambiguate by tf.callMatch\n                 auto tf1 = fd.type.isTypeFunction();\n                 auto tf2 = m.lastf.type.isTypeFunction();\n-                MATCH c1 = tf1.callMatch(tthis_fd, fargs_, 0, null, sc);\n-                MATCH c2 = tf2.callMatch(tthis_best, fargs_, 0, null, sc);\n+                MATCH c1 = tf1.callMatch(tthis_fd, argumentList, 0, null, sc);\n+                MATCH c2 = tf2.callMatch(tthis_best, argumentList, 0, null, sc);\n                 //printf(\"2: c1 = %d, c2 = %d\\n\", c1, c2);\n                 if (c1 > c2) goto Ltd;\n                 if (c1 < c2) goto Ltd_best;\n             }\n             {\n                 // Disambiguate by picking the most specialized FunctionDeclaration\n-                MATCH c1 = fd.leastAsSpecialized(m.lastf);\n-                MATCH c2 = m.lastf.leastAsSpecialized(fd);\n+                MATCH c1 = fd.leastAsSpecialized(m.lastf, argumentList.names);\n+                MATCH c2 = m.lastf.leastAsSpecialized(fd, argumentList.names);\n                 //printf(\"3: c1 = %d, c2 = %d\\n\", c1, c2);\n                 if (c1 > c2) goto Ltd;\n                 if (c1 < c2) goto Ltd_best;\n@@ -3076,7 +3099,7 @@ void functionResolve(ref MatchAccumulator m, Dsymbol dstart, Loc loc, Scope* sc,\n             sc = td_best._scope; // workaround for Type.aliasthisOf\n \n         auto ti = new TemplateInstance(loc, td_best, ti_best.tiargs);\n-        ti.templateInstanceSemantic(sc, fargs);\n+        ti.templateInstanceSemantic(sc, argumentList);\n \n         m.lastf = ti.toAlias().isFuncDeclaration();\n         if (!m.lastf)\n@@ -3104,7 +3127,7 @@ void functionResolve(ref MatchAccumulator m, Dsymbol dstart, Loc loc, Scope* sc,\n         if (m.lastf.type.ty == Terror)\n             goto Lerror;\n         auto tf = m.lastf.type.isTypeFunction();\n-        if (!tf.callMatch(tthis_best, fargs_, 0, null, sc))\n+        if (!tf.callMatch(tthis_best, argumentList, 0, null, sc))\n             goto Lnomatch;\n \n         /* As https://issues.dlang.org/show_bug.cgi?id=3682 shows,\n@@ -5887,7 +5910,7 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n         }\n     }\n \n-    extern (D) this(const ref Loc loc, Identifier ident, Objects* tiargs)\n+    extern (D) this(const ref Loc loc, Identifier ident, Objects* tiargs) scope\n     {\n         super(loc, null);\n         static if (LOG)\n@@ -5902,7 +5925,7 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n      * This constructor is only called when we figured out which function\n      * template to instantiate.\n      */\n-    extern (D) this(const ref Loc loc, TemplateDeclaration td, Objects* tiargs)\n+    extern (D) this(const ref Loc loc, TemplateDeclaration td, Objects* tiargs) scope\n     {\n         super(loc, null);\n         static if (LOG)\n@@ -6010,7 +6033,10 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n             return;\n \n         // Print full trace for verbose mode, otherwise only short traces\n-        const(uint) max_shown = !global.params.verbose ? 6 : uint.max;\n+        const(uint) max_shown = !global.params.verbose ?\n+                                    (global.params.errorSupplementLimit ? global.params.errorSupplementLimit : uint.max)\n+                                    : uint.max;\n+\n         const(char)* format = \"instantiated from here: `%s`\";\n \n         // This returns a function pointer\n@@ -6247,41 +6273,55 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n      */\n     final bool needsCodegen()\n     {\n+        //printf(\"needsCodegen() %s\\n\", toChars());\n+\n         // minst is finalized after the 1st invocation.\n-        // tnext and tinst are only needed for the 1st invocation and\n+        // tnext is only needed for the 1st invocation and\n         // cleared for further invocations.\n         TemplateInstance tnext = this.tnext;\n         TemplateInstance tinst = this.tinst;\n         this.tnext = null;\n-        this.tinst = null;\n \n-        if (errors || (inst && inst.isDiscardable()))\n+        // Don't do codegen if the instance has errors,\n+        // is a dummy instance (see evaluateConstraint),\n+        // or is determined to be discardable.\n+        if (errors || inst is null || inst.isDiscardable())\n         {\n             minst = null; // mark as speculative\n             return false;\n         }\n \n+        // This should only be called on the primary instantiation.\n+        assert(this is inst);\n+\n         if (global.params.allInst)\n         {\n             // Do codegen if there is an instantiation from a root module, to maximize link-ability.\n-\n-            // Do codegen if `this` is instantiated from a root module.\n-            if (minst && minst.isRoot())\n-                return true;\n-\n-            // Do codegen if the ancestor needs it.\n-            if (tinst && tinst.needsCodegen())\n+            static ThreeState needsCodegenAllInst(TemplateInstance tithis, TemplateInstance tinst)\n             {\n-                minst = tinst.minst; // cache result\n-                assert(minst);\n-                assert(minst.isRoot());\n-                return true;\n+                // Do codegen if `this` is instantiated from a root module.\n+                if (tithis.minst && tithis.minst.isRoot())\n+                    return ThreeState.yes;\n+\n+                // Do codegen if the ancestor needs it.\n+                if (tinst && tinst.inst && tinst.inst.needsCodegen())\n+                {\n+                    tithis.minst = tinst.inst.minst; // cache result\n+                    assert(tithis.minst);\n+                    assert(tithis.minst.isRoot());\n+                    return ThreeState.yes;\n+                }\n+                return ThreeState.none;\n             }\n \n+            if (const needsCodegen = needsCodegenAllInst(this, tinst))\n+                return needsCodegen == ThreeState.yes ? true : false;\n+\n             // Do codegen if a sibling needs it.\n-            if (tnext)\n+            for (; tnext; tnext = tnext.tnext)\n             {\n-                if (tnext.needsCodegen())\n+                const needsCodegen = needsCodegenAllInst(tnext, tnext.tinst);\n+                if (needsCodegen == ThreeState.yes)\n                 {\n                     minst = tnext.minst; // cache result\n                     assert(minst);\n@@ -6291,8 +6331,10 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n                 else if (!minst && tnext.minst)\n                 {\n                     minst = tnext.minst; // cache result from non-speculative sibling\n-                    return false;\n+                    // continue searching\n                 }\n+                else if (needsCodegen != ThreeState.none)\n+                    break;\n             }\n \n             // Elide codegen because there's no instantiation from any root modules.\n@@ -6317,31 +6359,39 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n              * => Elide codegen if there is at least one instantiation from a non-root module\n              *    which doesn't import any root modules.\n              */\n-\n-            // If the ancestor isn't speculative,\n-            // 1. do codegen if the ancestor needs it\n-            // 2. elide codegen if the ancestor doesn't need it (non-root instantiation of ancestor incl. subtree)\n-            if (tinst)\n+            static ThreeState needsCodegenRootOnly(TemplateInstance tithis, TemplateInstance tinst)\n             {\n-                const needsCodegen = tinst.needsCodegen(); // sets tinst.minst\n-                if (tinst.minst) // not speculative\n+                // If the ancestor isn't speculative,\n+                // 1. do codegen if the ancestor needs it\n+                // 2. elide codegen if the ancestor doesn't need it (non-root instantiation of ancestor incl. subtree)\n+                if (tinst && tinst.inst)\n                 {\n-                    minst = tinst.minst; // cache result\n-                    return needsCodegen;\n+                    tinst = tinst.inst;\n+                    const needsCodegen = tinst.needsCodegen(); // sets tinst.minst\n+                    if (tinst.minst) // not speculative\n+                    {\n+                        tithis.minst = tinst.minst; // cache result\n+                        return needsCodegen ? ThreeState.yes : ThreeState.no;\n+                    }\n                 }\n+\n+                // Elide codegen if `this` doesn't need it.\n+                if (tithis.minst && !tithis.minst.isRoot() && !tithis.minst.rootImports())\n+                    return ThreeState.no;\n+\n+                return ThreeState.none;\n             }\n \n-            // Elide codegen if `this` doesn't need it.\n-            if (minst && !minst.isRoot() && !minst.rootImports())\n-                return false;\n+            if (const needsCodegen = needsCodegenRootOnly(this, tinst))\n+                return needsCodegen == ThreeState.yes ? true : false;\n \n             // Elide codegen if a (non-speculative) sibling doesn't need it.\n-            if (tnext)\n+            for (; tnext; tnext = tnext.tnext)\n             {\n-                const needsCodegen = tnext.needsCodegen(); // sets tnext.minst\n+                const needsCodegen = needsCodegenRootOnly(tnext, tnext.tinst); // sets tnext.minst\n                 if (tnext.minst) // not speculative\n                 {\n-                    if (!needsCodegen)\n+                    if (needsCodegen == ThreeState.no)\n                     {\n                         minst = tnext.minst; // cache result\n                         assert(!minst.isRoot() && !minst.rootImports());\n@@ -6350,8 +6400,10 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n                     else if (!minst)\n                     {\n                         minst = tnext.minst; // cache result from non-speculative sibling\n-                        return true;\n+                        // continue searching\n                     }\n+                    else if (needsCodegen != ThreeState.none)\n+                        break;\n                 }\n             }\n \n@@ -6564,7 +6616,17 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n         }\n \n         TemplateInstance ti = s.parent ? s.parent.isTemplateInstance() : null;\n-        if (ti && (ti.name == s.ident || ti.toAlias().ident == s.ident) && ti.tempdecl)\n+\n+        /* This avoids the VarDeclaration.toAlias() which runs semantic() too soon\n+         */\n+        static bool matchId(TemplateInstance ti, Identifier id)\n+        {\n+            if (ti.aliasdecl && ti.aliasdecl.isVarDeclaration())\n+                return ti.aliasdecl.isVarDeclaration().ident == id;\n+            return ti.toAlias().ident == id;\n+        }\n+\n+        if (ti && (ti.name == s.ident || matchId(ti, s.ident)) && ti.tempdecl)\n         {\n             /* This is so that one can refer to the enclosing\n              * template, even if it has the same name as a member\n@@ -6883,12 +6945,12 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n      *\n      * Params:\n      *   sc    = the scope this TemplateInstance resides in\n-     *   fargs = function arguments in case of a template function, null otherwise\n+     *   argumentList = function arguments in case of a template function\n      *\n      * Returns:\n      *   `true` if a match was found, `false` otherwise\n      */\n-    extern (D) final bool findBestMatch(Scope* sc, Expressions* fargs)\n+    extern (D) final bool findBestMatch(Scope* sc, ArgumentList argumentList)\n     {\n         if (havetempdecl)\n         {\n@@ -6897,7 +6959,7 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n             assert(tempdecl._scope);\n             // Deduce tdtypes\n             tdtypes.setDim(tempdecl.parameters.length);\n-            if (!tempdecl.matchWithInstance(sc, this, &tdtypes, fargs, 2))\n+            if (!tempdecl.matchWithInstance(sc, this, &tdtypes, argumentList, 2))\n             {\n                 error(\"incompatible arguments for template instantiation\");\n                 return false;\n@@ -6947,7 +7009,7 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n                 dedtypes.zero();\n                 assert(td.semanticRun != PASS.initial);\n \n-                MATCH m = td.matchWithInstance(sc, this, &dedtypes, fargs, 0);\n+                MATCH m = td.matchWithInstance(sc, this, &dedtypes, argumentList, 0);\n                 //printf(\"matchWithInstance = %d\\n\", m);\n                 if (m == MATCH.nomatch) // no match at all\n                     return 0;\n@@ -6956,8 +7018,8 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n \n                 // Disambiguate by picking the most specialized TemplateDeclaration\n                 {\n-                MATCH c1 = td.leastAsSpecialized(sc, td_best, fargs);\n-                MATCH c2 = td_best.leastAsSpecialized(sc, td, fargs);\n+                MATCH c1 = td.leastAsSpecialized(sc, td_best, argumentList);\n+                MATCH c2 = td_best.leastAsSpecialized(sc, td, argumentList);\n                 //printf(\"c1 = %d, c2 = %d\\n\", c1, c2);\n                 if (c1 > c2) goto Ltd;\n                 if (c1 < c2) goto Ltd_best;\n@@ -7223,7 +7285,7 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n                             return 1;\n                         }\n                     }\n-                    MATCH m = td.matchWithInstance(sc, this, &dedtypes, null, 0);\n+                    MATCH m = td.matchWithInstance(sc, this, &dedtypes, ArgumentList(), 0);\n                     if (m == MATCH.nomatch)\n                         return 0;\n                 }\n@@ -7480,6 +7542,43 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n \n         members.foreachDsymbol( (s) { s.importAll(sc2); } );\n \n+        if (!aliasdecl)\n+        {\n+            /* static if's are crucial to evaluating aliasdecl correctly. But\n+             * evaluating the if/else bodies may require aliasdecl.\n+             * So, evaluate the condition for static if's, but not their if/else bodies.\n+             * Then try to set aliasdecl.\n+             * Later do the if/else bodies.\n+             * https://issues.dlang.org/show_bug.cgi?id=23598\n+             * It might be better to do this by attaching a lambda to the StaticIfDeclaration\n+             * to do the oneMembers call after the sid.include(sc2) is run as part of dsymbolSemantic().\n+             */\n+            bool done;\n+            void staticIfDg(Dsymbol s)\n+            {\n+                if (done || aliasdecl)\n+                    return;\n+                //printf(\"\\t staticIfDg on '%s %s' in '%s'\\n\",  s.kind(), s.toChars(), this.toChars());\n+                if (!s.isStaticIfDeclaration())\n+                {\n+                    //s.dsymbolSemantic(sc2);\n+                    done = true;\n+                    return;\n+                }\n+                auto sid = s.isStaticIfDeclaration();\n+                sid.include(sc2);\n+                if (members.length)\n+                {\n+                    Dsymbol sa;\n+                    if (Dsymbol.oneMembers(members, &sa, tempdecl.ident) && sa)\n+                        aliasdecl = sa;\n+                }\n+                done = true;\n+            }\n+\n+            members.foreachDsymbol(&staticIfDg);\n+        }\n+\n         void symbolDg(Dsymbol s)\n         {\n             //printf(\"\\t semantic on '%s' %p kind %s in '%s'\\n\",  s.toChars(), s, s.kind(), this.toChars());"}, {"sha": "7c3ff4bccc2ca87842ac8164f82e3d26f6cd207f", "filename": "gcc/d/dmd/dtoh.d", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fdtoh.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fdtoh.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdtoh.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -291,9 +291,23 @@ public:\n \n     /// Informations about the current context in the AST\n     Context context;\n-    alias context this;\n \n-    this(OutBuffer* fwdbuf, OutBuffer* donebuf, OutBuffer* buf)\n+    // Generates getter-setter methods to replace the use of alias this\n+    // This should be replaced by a `static foreach` once the gdc tester\n+    // gets upgraded to version 10 (to support `static foreach`).\n+    private extern(D) static string generateMembers()\n+    {\n+        string result = \"\";\n+        foreach(member; __traits(allMembers, Context))\n+        {\n+            result ~= \"ref auto \" ~ member ~ \"() { return context.\" ~ member ~ \"; }\\n\";\n+        }\n+        return result;\n+    }\n+\n+    mixin(generateMembers());\n+\n+    this(OutBuffer* fwdbuf, OutBuffer* donebuf, OutBuffer* buf) scope\n     {\n         this.fwdbuf = fwdbuf;\n         this.donebuf = donebuf;\n@@ -875,7 +889,7 @@ public:\n         // (we'll visit them later)\n         if (vd.type && vd.type.isTypeTuple())\n         {\n-            assert(vd.aliassym);\n+            assert(vd.aliasTuple);\n             vd.toAlias().accept(this);\n             return;\n         }"}, {"sha": "f107f7b09b3a24f197ef7a546f2e2d373b1da0db", "filename": "gcc/d/dmd/errors.d", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Ferrors.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Ferrors.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ferrors.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -12,11 +12,63 @@\n module dmd.errors;\n \n import core.stdc.stdarg;\n+import dmd.errorsink;\n import dmd.globals;\n import dmd.location;\n \n nothrow:\n \n+/***************************\n+ * Error message sink for D compiler.\n+ */\n+class ErrorSinkCompiler : ErrorSink\n+{\n+  nothrow:\n+  extern (C++):\n+  override:\n+\n+    void error(const ref Loc loc, const(char)* format, ...)\n+    {\n+        va_list ap;\n+        va_start(ap, format);\n+        verror(loc, format, ap);\n+        va_end(ap);\n+    }\n+\n+    void errorSupplemental(const ref Loc loc, const(char)* format, ...)\n+    {\n+        va_list ap;\n+        va_start(ap, format);\n+        verrorSupplemental(loc, format, ap);\n+        va_end(ap);\n+    }\n+\n+    void warning(const ref Loc loc, const(char)* format, ...)\n+    {\n+        va_list ap;\n+        va_start(ap, format);\n+        vwarning(loc, format, ap);\n+        va_end(ap);\n+    }\n+\n+    void deprecation(const ref Loc loc, const(char)* format, ...)\n+    {\n+        va_list ap;\n+        va_start(ap, format);\n+        vdeprecation(loc, format, ap);\n+        va_end(ap);\n+    }\n+\n+    void deprecationSupplemental(const ref Loc loc, const(char)* format, ...)\n+    {\n+        va_list ap;\n+        va_start(ap, format);\n+        vdeprecationSupplemental(loc, format, ap);\n+        va_end(ap);\n+    }\n+}\n+\n+\n /**\n  * Color highlighting to classify messages\n  */"}, {"sha": "b519db7e9bc08bbc2a4ad227b6dc970694fae678", "filename": "gcc/d/dmd/errorsink.d", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Ferrorsink.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Ferrorsink.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ferrorsink.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,121 @@\n+/**\n+ * Provides an abstraction for what to do with error messages.\n+ *\n+ * Copyright:   Copyright (C) 2023 by The D Language Foundation, All Rights Reserved\n+ * Authors:     $(LINK2 https://www.digitalmars.com, Walter Bright)\n+ * License:     $(LINK2 https://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n+ * Source:      $(LINK2 https://github.com/dlang/dmd/blob/master/src/dmd/errorsink.d, _errorsink.d)\n+ * Documentation:  https://dlang.org/phobos/dmd_errorsink.html\n+ * Coverage:    https://codecov.io/gh/dlang/dmd/src/master/src/dmd/errorsink.d\n+ */\n+\n+module dmd.errorsink;\n+\n+import dmd.location;\n+\n+/***************************************\n+ * Where error/warning/deprecation messages go.\n+ */\n+abstract class ErrorSink\n+{\n+  nothrow:\n+  extern (C++):\n+\n+    void error(const ref Loc loc, const(char)* format, ...);\n+\n+    void errorSupplemental(const ref Loc loc, const(char)* format, ...);\n+\n+    void warning(const ref Loc loc, const(char)* format, ...);\n+\n+    void deprecation(const ref Loc loc, const(char)* format, ...);\n+\n+    void deprecationSupplemental(const ref Loc loc, const(char)* format, ...);\n+}\n+\n+/*****************************************\n+ * Just ignores the messages.\n+ */\n+class ErrorSinkNull : ErrorSink\n+{\n+  nothrow:\n+  extern (C++):\n+  override:\n+\n+    void error(const ref Loc loc, const(char)* format, ...) { }\n+\n+    void errorSupplemental(const ref Loc loc, const(char)* format, ...) { }\n+\n+    void warning(const ref Loc loc, const(char)* format, ...) { }\n+\n+    void deprecation(const ref Loc loc, const(char)* format, ...) { }\n+\n+    void deprecationSupplemental(const ref Loc loc, const(char)* format, ...) { }\n+}\n+\n+/*****************************************\n+ * Simplest implementation, just sends messages to stderr.\n+ */\n+class ErrorSinkStderr : ErrorSink\n+{\n+    import core.stdc.stdio;\n+    import core.stdc.stdarg;\n+\n+  nothrow:\n+  extern (C++):\n+  override:\n+\n+    void error(const ref Loc loc, const(char)* format, ...)\n+    {\n+        fputs(\"Error: \", stderr);\n+        const p = loc.toChars();\n+        if (*p)\n+        {\n+            fprintf(stderr, \"%s: \", p);\n+            //mem.xfree(cast(void*)p); // loc should provide the free()\n+        }\n+\n+        va_list ap;\n+        va_start(ap, format);\n+        vfprintf(stderr, format, ap);\n+        fputc('\\n', stderr);\n+        va_end(ap);\n+    }\n+\n+    void errorSupplemental(const ref Loc loc, const(char)* format, ...) { }\n+\n+    void warning(const ref Loc loc, const(char)* format, ...)\n+    {\n+        fputs(\"Warning: \", stderr);\n+        const p = loc.toChars();\n+        if (*p)\n+        {\n+            fprintf(stderr, \"%s: \", p);\n+            //mem.xfree(cast(void*)p); // loc should provide the free()\n+        }\n+\n+        va_list ap;\n+        va_start(ap, format);\n+        vfprintf(stderr, format, ap);\n+        fputc('\\n', stderr);\n+        va_end(ap);\n+    }\n+\n+    void deprecation(const ref Loc loc, const(char)* format, ...)\n+    {\n+        fputs(\"Deprecation: \", stderr);\n+        const p = loc.toChars();\n+        if (*p)\n+        {\n+            fprintf(stderr, \"%s: \", p);\n+            //mem.xfree(cast(void*)p); // loc should provide the free()\n+        }\n+\n+        va_list ap;\n+        va_start(ap, format);\n+        vfprintf(stderr, format, ap);\n+        fputc('\\n', stderr);\n+        va_end(ap);\n+    }\n+\n+    void deprecationSupplemental(const ref Loc loc, const(char)* format, ...) { }\n+}"}, {"sha": "420fa7f80bbb816dc87c0efed8cd46c1158d513d", "filename": "gcc/d/dmd/escape.d", "status": "modified", "additions": 115, "deletions": 77, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fescape.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fescape.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fescape.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -181,7 +181,7 @@ bool checkMutableArguments(Scope* sc, FuncDeclaration fd, TypeFunction tf,\n         if (!(eb.isMutable || eb2.isMutable))\n             return;\n \n-        if (!(global.params.useDIP1000 == FeatureState.enabled && sc.setUnsafe()))\n+        if (!tf.islive && !(global.params.useDIP1000 == FeatureState.enabled && sc.func.setUnsafe()))\n             return;\n \n         if (!gag)\n@@ -558,6 +558,46 @@ bool checkConstructorEscape(Scope* sc, CallExp ce, bool gag)\n     return false;\n }\n \n+/// How a `return` parameter escapes its pointer value\n+enum ReturnParamDest\n+{\n+    returnVal, /// through return statement: `return x`\n+    this_,     /// assigned to a struct instance: `this.x = x`\n+    firstArg,  /// assigned to first argument: `firstArg = x`\n+}\n+\n+/****************************************\n+ * Find out if instead of returning a `return` parameter via a return statement,\n+ * it is returned via assignment to either `this` or the first parameter.\n+ *\n+ * This works the same as returning the value via a return statement.\n+ * Although the first argument must be `ref`, it is not regarded as returning by `ref`.\n+ *\n+ * See_Also: https://dlang.org.spec/function.html#return-ref-parameters\n+ *\n+ * Params:\n+ *   tf = function type\n+ *   tthis = type of `this` parameter, or `null` if none\n+ * Returns: What a `return` parameter should transfer the lifetime of the argument to\n+ */\n+ReturnParamDest returnParamDest(TypeFunction tf, Type tthis)\n+{\n+    assert(tf);\n+    if (tf.isctor)\n+        return ReturnParamDest.this_;\n+\n+    if (!tf.nextOf() || (tf.nextOf().ty != Tvoid))\n+        return ReturnParamDest.returnVal;\n+\n+    if (tthis && tthis.toBasetype().ty == Tstruct) // class `this` is passed by value\n+        return ReturnParamDest.this_;\n+\n+    if (tf.parameterList.length > 0 && tf.parameterList[0].isReference)\n+        return ReturnParamDest.firstArg;\n+\n+    return ReturnParamDest.returnVal;\n+}\n+\n /****************************************\n  * Given an `AssignExp`, determine if the lvalue will cause\n  * the contents of the rvalue to escape.\n@@ -608,6 +648,7 @@ bool checkAssignEscape(Scope* sc, Expression e, bool gag, bool byRef)\n     if (e1.isStructLiteralExp())\n         return false;\n \n+    VarDeclaration va = expToVariable(e1);\n     EscapeByResults er;\n \n     if (byRef)\n@@ -618,7 +659,6 @@ bool checkAssignEscape(Scope* sc, Expression e, bool gag, bool byRef)\n     if (!er.byref.length && !er.byvalue.length && !er.byfunc.length && !er.byexp.length)\n         return false;\n \n-    VarDeclaration va = expToVariable(e1);\n \n     if (va && e.op == EXP.concatenateElemAssign)\n     {\n@@ -653,30 +693,23 @@ bool checkAssignEscape(Scope* sc, Expression e, bool gag, bool byRef)\n     const bool vaIsRef = va && va.isParameter() && va.isReference();\n     if (log && vaIsRef) printf(\"va is ref `%s`\\n\", va.toChars());\n \n-    /* Determine if va is the first parameter, through which other 'return' parameters\n-     * can be assigned.\n-     * This works the same as returning the value via a return statement.\n-     * Although va is marked as `ref`, it is not regarded as returning by `ref`.\n-     * https://dlang.org.spec/function.html#return-ref-parameters\n-     */\n-    bool isFirstRef()\n+    // Determine if va is the first parameter, through which other 'return' parameters\n+    // can be assigned.\n+    bool vaIsFirstRef = false;\n+    if (fd && fd.type)\n     {\n-        if (!vaIsRef)\n-            return false;\n-        Dsymbol p = va.toParent2();\n-        if (p == fd && fd.type && fd.type.isTypeFunction())\n+        final switch (returnParamDest(fd.type.isTypeFunction(), fd.vthis ? fd.vthis.type : null))\n         {\n-            TypeFunction tf = fd.type.isTypeFunction();\n-            if (!tf.nextOf() || (tf.nextOf().ty != Tvoid && !fd.isCtorDeclaration()))\n-                return false;\n-            if (va == fd.vthis) // `this` of a non-static member function is considered to be the first parameter\n-                return true;\n-            if (!fd.vthis && fd.parameters && fd.parameters.length && (*fd.parameters)[0] == va) // va is first parameter\n-                return true;\n+            case ReturnParamDest.this_:\n+                vaIsFirstRef = va == fd.vthis;\n+                break;\n+            case ReturnParamDest.firstArg:\n+                vaIsFirstRef = (*fd.parameters)[0] == va;\n+                break;\n+            case ReturnParamDest.returnVal:\n+                break;\n         }\n-        return false;\n     }\n-    const bool vaIsFirstRef = isFirstRef();\n     if (log && vaIsFirstRef) printf(\"va is first ref `%s`\\n\", va.toChars());\n \n     bool result = false;\n@@ -1745,7 +1778,25 @@ void escapeByValue(Expression e, EscapeByResults* er, bool live = false, bool re\n                     const stc = tf.parameterStorageClass(null, p);\n                     ScopeRef psr = buildScopeRef(stc);\n                     if (psr == ScopeRef.ReturnScope || psr == ScopeRef.Ref_ReturnScope)\n-                        escapeByValue(arg, er, live, retRefTransition);\n+                    {\n+                        if (tf.isref)\n+                        {\n+                            /* ignore `ref` on struct constructor return because\n+                             *   struct S { this(return scope int* q) { this.p = q; } int* p; }\n+                             * is different from:\n+                             *   ref char* front(return scope char** q) { return *q; }\n+                             * https://github.com/dlang/dmd/pull/14869\n+                             */\n+                            if (auto dve = e.e1.isDotVarExp())\n+                                if (auto fd = dve.var.isFuncDeclaration())\n+                                    if (fd.isCtorDeclaration() && tf.next.toBasetype().isTypeStruct())\n+                                    {\n+                                        escapeByValue(arg, er, live, retRefTransition);\n+                                    }\n+                        }\n+                        else\n+                            escapeByValue(arg, er, live, retRefTransition);\n+                    }\n                     else if (psr == ScopeRef.ReturnRef || psr == ScopeRef.ReturnRef_Scope)\n                     {\n                         if (tf.isref)\n@@ -1768,68 +1819,55 @@ void escapeByValue(Expression e, EscapeByResults* er, bool live = false, bool re\n         {\n             DotVarExp dve = e.e1.isDotVarExp();\n             FuncDeclaration fd = dve.var.isFuncDeclaration();\n-            if (1)\n+            if (fd && fd.isThis())\n             {\n-                if (fd && fd.isThis())\n+                /* Calling a non-static member function dve.var, which is returning `this`, and with dve.e1 representing `this`\n+                 */\n+\n+                /*****************************\n+                 * Concoct storage class for member function's implicit `this` parameter.\n+                 * Params:\n+                 *      fd = member function\n+                 * Returns:\n+                 *      storage class for fd's `this`\n+                 */\n+                StorageClass getThisStorageClass(FuncDeclaration fd)\n                 {\n-                    /* Calling a non-static member function dve.var, which is returning `this`, and with dve.e1 representing `this`\n-                     */\n-\n-                    /*****************************\n-                     * Concoct storage class for member function's implicit `this` parameter.\n-                     * Params:\n-                     *      fd = member function\n-                     * Returns:\n-                     *      storage class for fd's `this`\n-                     */\n-                    StorageClass getThisStorageClass(FuncDeclaration fd)\n-                    {\n-                        StorageClass stc;\n-                        auto tf = fd.type.toBasetype().isTypeFunction();\n-                        if (tf.isreturn)\n-                            stc |= STC.return_;\n-                        if (tf.isreturnscope)\n-                            stc |= STC.returnScope | STC.scope_;\n-                        auto ad = fd.isThis();\n-                        if (ad.isClassDeclaration() || tf.isScopeQual)\n-                            stc |= STC.scope_;\n-                        if (ad.isStructDeclaration())\n-                            stc |= STC.ref_;        // `this` for a struct member function is passed by `ref`\n-                        return stc;\n-                    }\n+                    StorageClass stc;\n+                    auto tf = fd.type.toBasetype().isTypeFunction();\n+                    if (tf.isreturn)\n+                        stc |= STC.return_;\n+                    if (tf.isreturnscope)\n+                        stc |= STC.returnScope | STC.scope_;\n+                    auto ad = fd.isThis();\n+                    if (ad.isClassDeclaration() || tf.isScopeQual)\n+                        stc |= STC.scope_;\n+                    if (ad.isStructDeclaration())\n+                        stc |= STC.ref_;        // `this` for a struct member function is passed by `ref`\n+                    return stc;\n+                }\n \n-                    const psr = buildScopeRef(getThisStorageClass(fd));\n-                    if (psr == ScopeRef.ReturnScope || psr == ScopeRef.Ref_ReturnScope)\n+                const psr = buildScopeRef(getThisStorageClass(fd));\n+                if (psr == ScopeRef.ReturnScope || psr == ScopeRef.Ref_ReturnScope)\n+                {\n+                    if (!tf.isref || tf.isctor)\n                         escapeByValue(dve.e1, er, live, retRefTransition);\n-                    else if (psr == ScopeRef.ReturnRef || psr == ScopeRef.ReturnRef_Scope)\n+                }\n+                else if (psr == ScopeRef.ReturnRef || psr == ScopeRef.ReturnRef_Scope)\n+                {\n+                    if (tf.isref)\n                     {\n-                        if (tf.isref)\n-                        {\n-                            /* Treat calling:\n-                             *   struct S { ref S foo() return; }\n-                             * as:\n-                             *   this;\n-                             */\n-                            escapeByValue(dve.e1, er, live, retRefTransition);\n-                        }\n-                        else\n-                            escapeByRef(dve.e1, er, live, psr == ScopeRef.ReturnRef_Scope);\n+                        /* Treat calling:\n+                         *   struct S { ref S foo() return; }\n+                         * as:\n+                         *   this;\n+                         */\n+                        escapeByValue(dve.e1, er, live, retRefTransition);\n                     }\n+                    else\n+                        escapeByRef(dve.e1, er, live, psr == ScopeRef.ReturnRef_Scope);\n                 }\n             }\n-            else\n-            {\n-                // Calling member function before dip1000\n-                StorageClass stc = dve.var.storage_class & (STC.return_ | STC.scope_ | STC.ref_);\n-                if (tf.isreturn)\n-                    stc |= STC.return_;\n-\n-                const psr = buildScopeRef(stc);\n-                if (psr == ScopeRef.ReturnScope || psr == ScopeRef.Ref_ReturnScope)\n-                    escapeByValue(dve.e1, er, live, retRefTransition);\n-                else if (psr == ScopeRef.ReturnRef || psr == ScopeRef.ReturnRef_Scope)\n-                    escapeByRef(dve.e1, er, live, retRefTransition);\n-            }\n \n             // If it's also a nested function that is 'return scope'\n             if (fd && fd.isNested())"}, {"sha": "df5e9ddc98ef33810312e0d2c2c796aa22e76001", "filename": "gcc/d/dmd/expression.d", "status": "modified", "additions": 136, "deletions": 27, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fexpression.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fexpression.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpression.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -249,18 +249,55 @@ bool isDotOpDispatch(Expression e)\n }\n \n /****************************************\n- * Expand tuples.\n- * Input:\n- *      exps    aray of Expressions\n- * Output:\n- *      exps    rewritten in place\n+ * Expand tuples in-place.\n+ *\n+ * Example:\n+ *     When there's a call `f(10, pair: AliasSeq!(20, 30), single: 40)`, the input is:\n+ *         `exps =  [10, (20, 30), 40]`\n+ *         `names = [null, \"pair\", \"single\"]`\n+ *     The arrays will be modified to:\n+ *         `exps =  [10, 20, 30, 40]`\n+ *         `names = [null, \"pair\", null, \"single\"]`\n+ *\n+ * Params:\n+ *     exps  = array of Expressions\n+ *     names = optional array of names corresponding to Expressions\n  */\n-extern (C++) void expandTuples(Expressions* exps)\n+extern (C++) void expandTuples(Expressions* exps, Identifiers* names = null)\n {\n     //printf(\"expandTuples()\\n\");\n     if (exps is null)\n         return;\n \n+    if (names)\n+    {\n+        if (exps.length != names.length)\n+        {\n+            printf(\"exps.length = %d, names.length = %d\\n\", cast(int) exps.length, cast(int) names.length);\n+            printf(\"exps = %s, names = %s\\n\", exps.toChars(), names.toChars());\n+            if (exps.length > 0)\n+                printf(\"%s\\n\", (*exps)[0].loc.toChars());\n+            assert(0);\n+        }\n+    }\n+\n+    // At `index`, a tuple of length `length` is expanded. Insert corresponding nulls in `names`.\n+    void expandNames(size_t index, size_t length)\n+    {\n+        if (names)\n+        {\n+            if (length == 0)\n+            {\n+                names.remove(index);\n+                return;\n+            }\n+            foreach (i; 1 .. length)\n+            {\n+                names.insert(index + i, cast(Identifier) null);\n+            }\n+        }\n+    }\n+\n     for (size_t i = 0; i < exps.length; i++)\n     {\n         Expression arg = (*exps)[i];\n@@ -275,6 +312,7 @@ extern (C++) void expandTuples(Expressions* exps)\n                 if (!tt.arguments || tt.arguments.length == 0)\n                 {\n                     exps.remove(i);\n+                    expandNames(i, 0);\n                     if (i == exps.length)\n                         return;\n                 }\n@@ -285,6 +323,7 @@ extern (C++) void expandTuples(Expressions* exps)\n                     foreach (j, a; *tt.arguments)\n                         (*texps)[j] = new TypeExp(e.loc, a.type);\n                     exps.insert(i, texps);\n+                    expandNames(i, texps.length);\n                 }\n                 i--;\n                 continue;\n@@ -297,6 +336,7 @@ extern (C++) void expandTuples(Expressions* exps)\n             TupleExp te = cast(TupleExp)arg;\n             exps.remove(i); // remove arg\n             exps.insert(i, te.exps); // replace with tuple contents\n+            expandNames(i, te.exps.length);\n             if (i == exps.length)\n                 return; // empty tuple, no more arguments\n             (*exps)[i] = Expression.combine(te.e0, (*exps)[i]);\n@@ -682,11 +722,11 @@ extern (C++) abstract class Expression : ASTNode\n {\n     const EXP op;   // to minimize use of dynamic_cast\n     ubyte size;     // # of bytes in Expression so we can copy() it\n-    ubyte parens;   // if this is a parenthesized expression\n+    bool parens;    // if this is a parenthesized expression\n     Type type;      // !=null means that semantic() has been run\n     Loc loc;        // file location\n \n-    extern (D) this(const ref Loc loc, EXP op, int size)\n+    extern (D) this(const ref Loc loc, EXP op, int size) scope\n     {\n         //printf(\"Expression::Expression(op = %d) this = %p\\n\", op, this);\n         this.loc = loc;\n@@ -1393,7 +1433,7 @@ extern (C++) abstract class Expression : ASTNode\n     */\n     private static bool checkImpure(Scope* sc)\n     {\n-        return sc.func && (sc.flags & SCOPE.compile\n+        return sc.func && (isRootTraitsCompilesScope(sc)\n                 ? sc.func.isPureBypassingInference() >= PURE.weak\n                 : sc.func.setImpure());\n     }\n@@ -1435,7 +1475,7 @@ extern (C++) abstract class Expression : ASTNode\n \n         if (!f.isSafe() && !f.isTrusted())\n         {\n-            if (sc.flags & SCOPE.compile ? sc.func.isSafeBypassingInference() : sc.func.setUnsafeCall(f))\n+            if (isRootTraitsCompilesScope(sc) ? sc.func.isSafeBypassingInference() : sc.func.setUnsafeCall(f))\n             {\n                 if (!loc.isValid()) // e.g. implicitly generated dtor\n                     loc = sc.func.loc;\n@@ -1488,15 +1528,16 @@ extern (C++) abstract class Expression : ASTNode\n \n         if (!f.isNogc())\n         {\n-            if (sc.flags & SCOPE.compile ? sc.func.isNogcBypassingInference() : sc.func.setGC())\n+            if (isRootTraitsCompilesScope(sc) ? sc.func.isNogcBypassingInference() : sc.func.setGC())\n             {\n                 if (loc.linnum == 0) // e.g. implicitly generated dtor\n                     loc = sc.func.loc;\n \n                 // Lowered non-@nogc'd hooks will print their own error message inside of nogc.d (NOGCVisitor.visit(CallExp e)),\n                 // so don't print anything to avoid double error messages.\n                 if (!(f.ident == Id._d_HookTraceImpl || f.ident == Id._d_arraysetlengthT\n-                    || f.ident == Id._d_arrayappendT || f.ident == Id._d_arrayappendcTX))\n+                    || f.ident == Id._d_arrayappendT || f.ident == Id._d_arrayappendcTX\n+                    || f.ident == Id._d_newclassT))\n                     error(\"`@nogc` %s `%s` cannot call non-@nogc %s `%s`\",\n                         sc.func.kind(), sc.func.toPrettyChars(), f.kind(), f.toPrettyChars());\n \n@@ -1647,6 +1688,15 @@ extern (C++) abstract class Expression : ASTNode\n         return .isConst(this);\n     }\n \n+    /******\n+     * Identical, not just equal. I.e. NaNs with different bit patterns are not identical\n+     */\n+    bool isIdentical(const Expression e) const\n+    {\n+        return equals(e);\n+    }\n+\n+\n     /// Statically evaluate this expression to a `bool` if possible\n     /// Returns: an optional thath either contains the value or is empty\n     Optional!bool toBool()\n@@ -2137,6 +2187,13 @@ extern (C++) final class RealExp : Expression\n         return false;\n     }\n \n+    override bool isIdentical(const Expression e) const\n+    {\n+        if (!equals(e))\n+            return false;\n+        return CTFloat.isIdentical(value, e.isRealExp().value);\n+    }\n+\n     override dinteger_t toInteger()\n     {\n         return cast(sinteger_t)toReal();\n@@ -2213,6 +2270,16 @@ extern (C++) final class ComplexExp : Expression\n         return false;\n     }\n \n+    override bool isIdentical(const Expression e) const\n+    {\n+        if (!equals(e))\n+            return false;\n+        // equals() regards different NaN values as 'equals'\n+        auto c = e.isComplexExp();\n+        return CTFloat.isIdentical(creall(value), creall(c.value)) &&\n+               CTFloat.isIdentical(cimagl(value), cimagl(c.value));\n+    }\n+\n     override dinteger_t toInteger()\n     {\n         return cast(sinteger_t)toReal();\n@@ -2261,7 +2328,7 @@ extern (C++) class IdentifierExp : Expression\n {\n     Identifier ident;\n \n-    extern (D) this(const ref Loc loc, Identifier ident)\n+    extern (D) this(const ref Loc loc, Identifier ident) scope\n     {\n         super(loc, EXP.identifier, __traits(classInstanceSize, IdentifierExp));\n         this.ident = ident;\n@@ -2416,7 +2483,7 @@ extern (C++) final class SuperExp : ThisExp\n  */\n extern (C++) final class NullExp : Expression\n {\n-    extern (D) this(const ref Loc loc, Type type = null)\n+    extern (D) this(const ref Loc loc, Type type = null) scope\n     {\n         super(loc, EXP.null_, __traits(classInstanceSize, NullExp));\n         this.type = type;\n@@ -2475,15 +2542,15 @@ extern (C++) final class StringExp : Expression\n     char postfix = NoPostfix;   // 'c', 'w', 'd'\n     OwnedBy ownedByCtfe = OwnedBy.code;\n \n-    extern (D) this(const ref Loc loc, const(void)[] string)\n+    extern (D) this(const ref Loc loc, const(void)[] string) scope\n     {\n         super(loc, EXP.string_, __traits(classInstanceSize, StringExp));\n         this.string = cast(char*)string.ptr; // note that this.string should be const\n         this.len = string.length;\n         this.sz = 1;                    // work around LDC bug #1286\n     }\n \n-    extern (D) this(const ref Loc loc, const(void)[] string, size_t len, ubyte sz, char postfix = NoPostfix)\n+    extern (D) this(const ref Loc loc, const(void)[] string, size_t len, ubyte sz, char postfix = NoPostfix) scope\n     {\n         super(loc, EXP.string_, __traits(classInstanceSize, StringExp));\n         this.string = cast(char*)string.ptr; // note that this.string should be const\n@@ -3570,18 +3637,26 @@ extern (C++) final class NewExp : Expression\n     Expression thisexp;         // if !=null, 'this' for class being allocated\n     Type newtype;\n     Expressions* arguments;     // Array of Expression's\n+    Identifiers* names;         // Array of names corresponding to expressions\n \n     Expression argprefix;       // expression to be evaluated just before arguments[]\n     CtorDeclaration member;     // constructor function\n     bool onstack;               // allocate on stack\n     bool thrownew;              // this NewExp is the expression of a ThrowStatement\n \n-    extern (D) this(const ref Loc loc, Expression thisexp, Type newtype, Expressions* arguments)\n+    Expression lowering;        // lowered druntime hook: `_d_newclass`\n+\n+    /// Puts the `arguments` and `names` into an `ArgumentList` for easily passing them around.\n+    /// The fields are still separate for backwards compatibility\n+    extern (D) ArgumentList argumentList() { return ArgumentList(arguments, names); }\n+\n+    extern (D) this(const ref Loc loc, Expression thisexp, Type newtype, Expressions* arguments, Identifiers* names = null)\n     {\n         super(loc, EXP.new_, __traits(classInstanceSize, NewExp));\n         this.thisexp = thisexp;\n         this.newtype = newtype;\n         this.arguments = arguments;\n+        this.names = names;\n     }\n \n     static NewExp create(const ref Loc loc, Expression thisexp, Type newtype, Expressions* arguments)\n@@ -3594,7 +3669,8 @@ extern (C++) final class NewExp : Expression\n         return new NewExp(loc,\n             thisexp ? thisexp.syntaxCopy() : null,\n             newtype.syntaxCopy(),\n-            arraySyntaxCopy(arguments));\n+            arraySyntaxCopy(arguments),\n+            names ? names.copy() : null);\n     }\n \n     override void accept(Visitor v)\n@@ -3969,6 +4045,7 @@ extern (C++) final class FuncExp : Expression\n                 Type t = pto.type;\n                 if (t.ty == Terror)\n                     return cannotInfer(this, to, flag);\n+                tf.parameterList[u].storageClass = tof.parameterList[u].storageClass;\n                 tiargs.push(t);\n             }\n \n@@ -4217,7 +4294,7 @@ extern (C++) final class IsExp : Expression\n     TOK tok;            // ':' or '=='\n     TOK tok2;           // 'struct', 'union', etc.\n \n-    extern (D) this(const ref Loc loc, Type targ, Identifier id, TOK tok, Type tspec, TOK tok2, TemplateParameters* parameters)\n+    extern (D) this(const ref Loc loc, Type targ, Identifier id, TOK tok, Type tspec, TOK tok2, TemplateParameters* parameters) scope\n     {\n         super(loc, EXP.is_, __traits(classInstanceSize, IsExp));\n         this.targ = targ;\n@@ -4257,7 +4334,7 @@ extern (C++) abstract class UnaExp : Expression\n     Expression e1;\n     Type att1;      // Save alias this type to detect recursion\n \n-    extern (D) this(const ref Loc loc, EXP op, int size, Expression e1)\n+    extern (D) this(const ref Loc loc, EXP op, int size, Expression e1) scope\n     {\n         super(loc, op, size);\n         this.e1 = e1;\n@@ -4330,7 +4407,7 @@ extern (C++) abstract class BinExp : Expression\n     Type att1;      // Save alias this type to detect recursion\n     Type att2;      // Save alias this type to detect recursion\n \n-    extern (D) this(const ref Loc loc, EXP op, int size, Expression e1, Expression e2)\n+    extern (D) this(const ref Loc loc, EXP op, int size, Expression e1, Expression e2) scope\n     {\n         super(loc, op, size);\n         this.e1 = e1;\n@@ -4621,7 +4698,7 @@ extern (C++) abstract class BinExp : Expression\n  */\n extern (C++) class BinAssignExp : BinExp\n {\n-    extern (D) this(const ref Loc loc, EXP op, int size, Expression e1, Expression e2)\n+    extern (D) this(const ref Loc loc, EXP op, int size, Expression e1, Expression e2) scope\n     {\n         super(loc, op, size, e1, e2);\n     }\n@@ -5048,21 +5125,53 @@ extern (C++) final class DotTypeExp : UnaExp\n     }\n }\n \n+/**\n+ * The arguments of a function call\n+ *\n+ * Contains a list of expressions. If it is a named argument, the `names`\n+ * list has a non-null entry at the same index.\n+ */\n+struct ArgumentList\n+{\n+    Expressions* arguments; // function arguments\n+    Identifiers* names;     // named argument identifiers\n+\n+    size_t length() const @nogc nothrow pure @safe { return arguments ? arguments.length : 0; }\n+\n+    /// Returns: whether this argument list contains any named arguments\n+    bool hasNames() const @nogc nothrow pure @safe\n+    {\n+        if (names is null)\n+            return false;\n+        foreach (name; *names)\n+            if (name !is null)\n+                return true;\n+\n+        return false;\n+    }\n+}\n+\n /***********************************************************\n  */\n extern (C++) final class CallExp : UnaExp\n {\n     Expressions* arguments; // function arguments\n+    Identifiers* names;     // named argument identifiers\n     FuncDeclaration f;      // symbol to call\n     bool directcall;        // true if a virtual call is devirtualized\n     bool inDebugStatement;  /// true if this was in a debug statement\n     bool ignoreAttributes;  /// don't enforce attributes (e.g. call @gc function in @nogc code)\n     VarDeclaration vthis2;  // container for multi-context\n \n-    extern (D) this(const ref Loc loc, Expression e, Expressions* exps)\n+    /// Puts the `arguments` and `names` into an `ArgumentList` for easily passing them around.\n+    /// The fields are still separate for backwards compatibility\n+    extern (D) ArgumentList argumentList() { return ArgumentList(arguments, names); }\n+\n+    extern (D) this(const ref Loc loc, Expression e, Expressions* exps, Identifiers* names = null)\n     {\n         super(loc, EXP.call, __traits(classInstanceSize, CallExp), e);\n         this.arguments = exps;\n+        this.names = names;\n     }\n \n     extern (D) this(const ref Loc loc, Expression e)\n@@ -5129,7 +5238,7 @@ extern (C++) final class CallExp : UnaExp\n \n     override CallExp syntaxCopy()\n     {\n-        return new CallExp(loc, e1.syntaxCopy(), arraySyntaxCopy(arguments));\n+        return new CallExp(loc, e1.syntaxCopy(), arraySyntaxCopy(arguments), names ? names.copy() : null);\n     }\n \n     override bool isLvalue()\n@@ -5325,7 +5434,7 @@ extern (C++) final class NegExp : UnaExp\n  */\n extern (C++) final class UAddExp : UnaExp\n {\n-    extern (D) this(const ref Loc loc, Expression e)\n+    extern (D) this(const ref Loc loc, Expression e) scope\n     {\n         super(loc, EXP.uadd, __traits(classInstanceSize, UAddExp), e);\n     }\n@@ -6387,7 +6496,7 @@ extern (C++) final class MinExp : BinExp\n  */\n extern (C++) final class CatExp : BinExp\n {\n-    extern (D) this(const ref Loc loc, Expression e1, Expression e2)\n+    extern (D) this(const ref Loc loc, Expression e1, Expression e2) scope\n     {\n         super(loc, EXP.concatenate, __traits(classInstanceSize, CatExp), e1, e2);\n     }\n@@ -6717,7 +6826,7 @@ extern (C++) final class CondExp : BinExp\n {\n     Expression econd;\n \n-    extern (D) this(const ref Loc loc, Expression econd, Expression e1, Expression e2)\n+    extern (D) this(const ref Loc loc, Expression econd, Expression e1, Expression e2) scope\n     {\n         super(loc, EXP.question, __traits(classInstanceSize, CondExp), e1, e2);\n         this.econd = econd;"}, {"sha": "e4716c8dfcf51008bfbdbd97e6a28910c54a8711", "filename": "gcc/d/dmd/expression.h", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fexpression.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fexpression.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpression.h?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -45,7 +45,7 @@ typedef union tree_node Symbol;\n struct Symbol;          // back end symbol\n #endif\n \n-void expandTuples(Expressions *exps);\n+void expandTuples(Expressions *exps, Identifiers *names = nullptr);\n bool isTrivialExp(Expression *e);\n bool hasSideEffect(Expression *e, bool assumeImpureCalls = false);\n \n@@ -81,7 +81,7 @@ class Expression : public ASTNode\n public:\n     EXP op;                     // to minimize use of dynamic_cast\n     unsigned char size;         // # of bytes in Expression so we can copy() it\n-    unsigned char parens;       // if this is a parenthesized expression\n+    bool parens;                // if this is a parenthesized expression\n     Type *type;                 // !=NULL means that semantic() has been run\n     Loc loc;                    // file location\n \n@@ -123,6 +123,7 @@ class Expression : public ASTNode\n     // A compile-time result is required. Give an error if not possible\n     Expression *ctfeInterpret();\n     int isConst();\n+    virtual bool isIdentical(const Expression *e) const;\n     virtual Optional<bool> toBool();\n     virtual bool hasCode()\n     {\n@@ -281,6 +282,7 @@ class RealExp final : public Expression\n     static RealExp *create(const Loc &loc, real_t value, Type *type);\n     static void emplace(UnionExp *pue, const Loc &loc, real_t value, Type *type);\n     bool equals(const RootObject * const o) const override;\n+    bool isIdentical(const Expression *e) const override;\n     dinteger_t toInteger() override;\n     uinteger_t toUInteger() override;\n     real_t toReal() override;\n@@ -298,6 +300,7 @@ class ComplexExp final : public Expression\n     static ComplexExp *create(const Loc &loc, complex_t value, Type *type);\n     static void emplace(UnionExp *pue, const Loc &loc, complex_t value, Type *type);\n     bool equals(const RootObject * const o) const override;\n+    bool isIdentical(const Expression *e) const override;\n     dinteger_t toInteger() override;\n     uinteger_t toUInteger() override;\n     real_t toReal() override;\n@@ -529,13 +532,16 @@ class NewExp final : public Expression\n     Expression *thisexp;        // if !NULL, 'this' for class being allocated\n     Type *newtype;\n     Expressions *arguments;     // Array of Expression's\n+    Identifiers *names;         // Array of names corresponding to expressions\n \n     Expression *argprefix;      // expression to be evaluated just before arguments[]\n \n     CtorDeclaration *member;    // constructor function\n     bool onstack;               // allocate on stack\n     bool thrownew;              // this NewExp is the expression of a ThrowStatement\n \n+    Expression *lowering;       // lowered druntime hook: `_d_newclass`\n+\n     static NewExp *create(const Loc &loc, Expression *thisexp, Type *newtype, Expressions *arguments);\n     NewExp *syntaxCopy() override;\n \n@@ -823,6 +829,7 @@ class CallExp final : public UnaExp\n {\n public:\n     Expressions *arguments;     // function arguments\n+    Identifiers *names;\n     FuncDeclaration *f;         // symbol to call\n     bool directcall;            // true if a virtual call is devirtualized\n     bool inDebugStatement;      // true if this was in a debug statement"}, {"sha": "d186abc05524d5fb4767c11b998ef1342052dcce", "filename": "gcc/d/dmd/expressionsem.d", "status": "modified", "additions": 206, "deletions": 114, "changes": 320, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fexpressionsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fexpressionsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpressionsem.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -105,6 +105,8 @@ bool expressionsToString(ref OutBuffer buf, Scope* sc, Expressions* exps)\n         if (!ex)\n             continue;\n         auto sc2 = sc.startCTFE();\n+        sc2.tinst = null;\n+        sc2.minst = null;       // prevents emission of any instantiated templates to object file\n         auto e2 = ex.expressionSemantic(sc2);\n         auto e3 = resolveProperties(sc2, e2);\n         sc2.endCTFE();\n@@ -260,7 +262,7 @@ Expression resolveOpDollar(Scope* sc, ArrayExp ae, Expression* pe0)\n \n             uint xerrors = global.startGagging();\n             sc = sc.push();\n-            FuncDeclaration fslice = resolveFuncCall(ae.loc, sc, slice, tiargs, ae.e1.type, fargs, FuncResolveFlag.quiet);\n+            FuncDeclaration fslice = resolveFuncCall(ae.loc, sc, slice, tiargs, ae.e1.type, ArgumentList(fargs), FuncResolveFlag.quiet);\n             sc = sc.pop();\n             global.endGagging(xerrors);\n             if (!fslice)\n@@ -649,6 +651,9 @@ private Expression resolveUFCS(Scope* sc, CallExp ce)\n     if (!ce.arguments)\n         ce.arguments = new Expressions();\n     ce.arguments.shift(eleft);\n+    if (!ce.names)\n+        ce.names = new Identifiers();\n+    ce.names.shift(null);\n \n     return null;\n }\n@@ -1192,7 +1197,7 @@ private Expression resolvePropertiesX(Scope* sc, Expression e1, Expression e2 =\n \n             for (size_t i = 0; i < os.a.length; i++)\n             {\n-                if (FuncDeclaration f = resolveFuncCall(loc, sc, os.a[i], tiargs, tthis, &a, FuncResolveFlag.quiet))\n+                if (FuncDeclaration f = resolveFuncCall(loc, sc, os.a[i], tiargs, tthis, ArgumentList(&a), FuncResolveFlag.quiet))\n                 {\n                     if (f.errors)\n                         return ErrorExp.get();\n@@ -1209,7 +1214,7 @@ private Expression resolvePropertiesX(Scope* sc, Expression e1, Expression e2 =\n         {\n             for (size_t i = 0; i < os.a.length; i++)\n             {\n-                if (FuncDeclaration f = resolveFuncCall(loc, sc, os.a[i], tiargs, tthis, null, FuncResolveFlag.quiet))\n+                if (FuncDeclaration f = resolveFuncCall(loc, sc, os.a[i], tiargs, tthis, ArgumentList(), FuncResolveFlag.quiet))\n                 {\n                     if (f.errors)\n                         return ErrorExp.get();\n@@ -1307,7 +1312,7 @@ private Expression resolvePropertiesX(Scope* sc, Expression e1, Expression e2 =\n             Expressions a;\n             a.push(e2);\n \n-            FuncDeclaration fd = resolveFuncCall(loc, sc, s, tiargs, tthis, &a, FuncResolveFlag.quiet);\n+            FuncDeclaration fd = resolveFuncCall(loc, sc, s, tiargs, tthis, ArgumentList(&a), FuncResolveFlag.quiet);\n             if (fd && fd.type)\n             {\n                 if (fd.errors)\n@@ -1327,7 +1332,7 @@ private Expression resolvePropertiesX(Scope* sc, Expression e1, Expression e2 =\n             }\n         }\n         {\n-            FuncDeclaration fd = resolveFuncCall(loc, sc, s, tiargs, tthis, null, FuncResolveFlag.quiet);\n+            FuncDeclaration fd = resolveFuncCall(loc, sc, s, tiargs, tthis, ArgumentList(), FuncResolveFlag.quiet);\n             if (fd && fd.type)\n             {\n                 if (fd.errors)\n@@ -1586,29 +1591,22 @@ private Expression opAssignToOp(const ref Loc loc, EXP op, Expression e1, Expres\n /*********************\n  * Rewrite:\n  *    array.length op= e2\n- * as:\n- *    array.length = array.length op e2\n- * or:\n- *    auto tmp = &array;\n- *    (*tmp).length = (*tmp).length op e2\n  */\n private Expression rewriteOpAssign(BinExp exp)\n {\n     ArrayLengthExp ale = exp.e1.isArrayLengthExp();\n     if (ale.e1.isVarExp())\n     {\n+        // array.length = array.length op e2\n         Expression e = opAssignToOp(exp.loc, exp.op, ale, exp.e2);\n         e = new AssignExp(exp.loc, ale.syntaxCopy(), e);\n         return e;\n     }\n     else\n     {\n-        /*    auto tmp = &array;\n-         *    (*tmp).length = (*tmp).length op e2\n-         */\n-        auto tmp = copyToTemp(0, \"__arraylength\", new AddrExp(ale.loc, ale.e1));\n-\n-        Expression e1 = new ArrayLengthExp(ale.loc, new PtrExp(ale.loc, new VarExp(ale.loc, tmp)));\n+        // (ref tmp = array;), tmp.length = tmp.length op e2\n+        auto tmp = copyToTemp(STC.ref_, \"__arraylength\", ale.e1);\n+        Expression e1 = new ArrayLengthExp(ale.loc, new VarExp(ale.loc, tmp));\n         Expression elvalue = e1.syntaxCopy();\n         Expression e = opAssignToOp(exp.loc, exp.op, e1, exp.e2);\n         e = new AssignExp(exp.loc, elvalue, e);\n@@ -1619,20 +1617,24 @@ private Expression rewriteOpAssign(BinExp exp)\n \n /****************************************\n  * Preprocess arguments to function.\n- * Input:\n- *      reportErrors    whether or not to report errors here.  Some callers are not\n+ *\n+ * Tuples in argumentList get expanded, properties resolved, rewritten in place\n+ *\n+ * Params:\n+ *     sc           =  scope\n+ *     argumentList =  arguments to function\n+ *     reportErrors =  whether or not to report errors here. Some callers are not\n  *                      checking actual function params, so they'll do their own error reporting\n- * Output:\n- *      exps[]  tuples expanded, properties resolved, rewritten in place\n  * Returns:\n- *      true    a semantic error occurred\n+ *     `true` when a semantic error occurred\n  */\n-private bool preFunctionParameters(Scope* sc, Expressions* exps, const bool reportErrors = true)\n+private bool preFunctionParameters(Scope* sc, ArgumentList argumentList, const bool reportErrors = true)\n {\n+    Expressions* exps = argumentList.arguments;\n     bool err = false;\n     if (exps)\n     {\n-        expandTuples(exps);\n+        expandTuples(exps, argumentList.names);\n \n         for (size_t i = 0; i < exps.length; i++)\n         {\n@@ -1708,28 +1710,46 @@ private bool checkDefCtor(Loc loc, Type t)\n  *      tf        = type of the function\n  *      ethis     = `this` argument, `null` if none or not known\n  *      tthis     = type of `this` argument, `null` if no `this` argument\n- *      arguments = array of actual arguments to function call\n+ *      argumentsList = array of actual arguments to function call\n  *      fd        = the function being called, `null` if called indirectly\n  *      prettype  = set to return type of function\n  *      peprefix  = set to expression to execute before `arguments[]` are evaluated, `null` if none\n  * Returns:\n  *      true    errors happened\n  */\n private bool functionParameters(const ref Loc loc, Scope* sc,\n-    TypeFunction tf, Expression ethis, Type tthis, Expressions* arguments, FuncDeclaration fd,\n+    TypeFunction tf, Expression ethis, Type tthis, ArgumentList argumentList, FuncDeclaration fd,\n     Type* prettype, Expression* peprefix)\n {\n+    Expressions* arguments = argumentList.arguments;\n     //printf(\"functionParameters() %s\\n\", fd ? fd.toChars() : \"\");\n     assert(arguments);\n     assert(fd || tf.next);\n-    size_t nargs = arguments ? arguments.length : 0;\n     const size_t nparams = tf.parameterList.length;\n     const olderrors = global.errors;\n     bool err = false;\n-    *prettype = Type.terror;\n     Expression eprefix = null;\n     *peprefix = null;\n \n+    if (argumentList.names)\n+    {\n+        const(char)* msg = null;\n+        auto resolvedArgs = tf.resolveNamedArgs(argumentList, &msg);\n+        if (!resolvedArgs)\n+        {\n+            // while errors are usually already caught by `tf.callMatch`,\n+            // this can happen when calling `typeof(freefunc)`\n+            if (msg)\n+                error(loc, \"%s\", msg);\n+            return true;\n+        }\n+        // note: the argument list should be mutated with named arguments / default arguments,\n+        // so we can't simply change the pointer like `arguments = resolvedArgs;`\n+        arguments.setDim(0);\n+        arguments.pushSlice((*resolvedArgs)[]);\n+    }\n+    size_t nargs = arguments ? arguments.length : 0;\n+\n     if (nargs > nparams && tf.parameterList.varargs == VarArg.none)\n     {\n         error(loc, \"expected %llu arguments, not %llu for non-variadic function type `%s`\", cast(ulong)nparams, cast(ulong)nargs, tf.toChars());\n@@ -1796,11 +1816,18 @@ private bool functionParameters(const ref Loc loc, Scope* sc,\n                     return errorArgs();\n                 }\n                 arg = p.defaultArg;\n+                if (!arg.type)\n+                    arg = arg.expressionSemantic(sc);\n                 arg = inlineCopy(arg, sc);\n                 // __FILE__, __LINE__, __MODULE__, __FUNCTION__, and __PRETTY_FUNCTION__\n                 arg = arg.resolveLoc(loc, sc);\n-                arguments.push(arg);\n-                nargs++;\n+                if (i >= nargs)\n+                {\n+                    arguments.push(arg);\n+                    nargs++;\n+                }\n+                else\n+                    (*arguments)[i] = arg;\n             }\n             else\n             {\n@@ -1978,11 +2005,18 @@ private bool functionParameters(const ref Loc loc, Scope* sc,\n             return errorInout(wildmatch);\n     }\n \n-    Expression firstArg = ((tf.next && tf.next.ty == Tvoid || isCtorCall) &&\n-                           tthis &&\n-                           tthis.isMutable() && tthis.toBasetype().ty == Tstruct &&\n-                           tthis.hasPointers())\n-                          ? ethis : null;\n+    Expression firstArg = null;\n+    final switch (returnParamDest(tf, tthis))\n+    {\n+        case ReturnParamDest.returnVal:\n+            break;\n+        case ReturnParamDest.firstArg:\n+            firstArg = nargs > 0 ? (*arguments)[0] : null;\n+            break;\n+        case ReturnParamDest.this_:\n+            firstArg = ethis;\n+            break;\n+    }\n \n     assert(nargs >= nparams);\n     foreach (const i, arg; (*arguments)[0 .. nargs])\n@@ -2145,19 +2179,6 @@ private bool functionParameters(const ref Loc loc, Scope* sc,\n                 err |= arg.checkSharedAccess(sc);\n \n             arg = arg.optimize(WANTvalue, p.isReference());\n-\n-            /* Determine if this parameter is the \"first reference\" parameter through which\n-             * later \"return\" arguments can be stored.\n-             */\n-            if (i == 0 && !tthis && p.isReference() && p.type &&\n-                (tf.next && tf.next.ty == Tvoid || isCtorCall))\n-            {\n-                Type tb = p.type.baseElemOf();\n-                if (tb.isMutable() && tb.hasPointers())\n-                {\n-                    firstArg = arg;\n-                }\n-            }\n         }\n         else\n         {\n@@ -2443,10 +2464,10 @@ private bool functionParameters(const ref Loc loc, Scope* sc,\n     }\n     //if (eprefix) printf(\"eprefix: %s\\n\", eprefix.toChars());\n \n-    /* Test compliance with DIP1021\n+    /* Test compliance with DIP1021 Argument Ownership and Function Calls\n      */\n-    if (global.params.useDIP1021 &&\n-        tf.trust != TRUST.system && tf.trust != TRUST.trusted)\n+    if (global.params.useDIP1021 && (tf.trust == TRUST.safe || tf.trust == TRUST.default_) ||\n+        tf.islive)\n         err |= checkMutableArguments(sc, fd, tf, ethis, arguments, false);\n \n     // If D linkage and variadic, add _arguments[] as first argument\n@@ -2545,7 +2566,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n     Scope* sc;\n     Expression result;\n \n-    this(Scope* sc)\n+    this(Scope* sc) scope\n     {\n         this.sc = sc;\n     }\n@@ -3547,7 +3568,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         {\n             return setError();\n         }\n-        if (preFunctionParameters(sc, exp.arguments))\n+        if (preFunctionParameters(sc, exp.argumentList))\n         {\n             return setError();\n         }\n@@ -3706,7 +3727,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n \n             if (cd.ctor)\n             {\n-                FuncDeclaration f = resolveFuncCall(exp.loc, sc, cd.ctor, null, tb, exp.arguments, FuncResolveFlag.standard);\n+                FuncDeclaration f = resolveFuncCall(exp.loc, sc, cd.ctor, null, tb, exp.argumentList, FuncResolveFlag.standard);\n                 if (!f || f.errors)\n                     return setError();\n \n@@ -3716,7 +3737,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                 TypeFunction tf = f.type.isTypeFunction();\n                 if (!exp.arguments)\n                     exp.arguments = new Expressions();\n-                if (functionParameters(exp.loc, sc, tf, null, exp.type, exp.arguments, f, &exp.type, &exp.argprefix))\n+                if (functionParameters(exp.loc, sc, tf, null, exp.type, exp.argumentList, f, &exp.type, &exp.argprefix))\n                     return setError();\n \n                 exp.member = f.isCtorDeclaration();\n@@ -3776,6 +3797,32 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                 result = id.expressionSemantic(sc);\n                 return;\n             }\n+            else if (!exp.onstack && !exp.type.isscope())\n+            {\n+                auto hook = global.params.tracegc ? Id._d_newclassTTrace : Id._d_newclassT;\n+                if (!verifyHookExist(exp.loc, *sc, hook, \"new class\"))\n+                    return setError();\n+\n+                Expression id = new IdentifierExp(exp.loc, Id.empty);\n+                id = new DotIdExp(exp.loc, id, Id.object);\n+\n+                auto tiargs = new Objects();\n+                auto t = exp.newtype.unqualify(MODFlags.wild);  // remove `inout`\n+                tiargs.push(t);\n+                id = new DotTemplateInstanceExp(exp.loc, id, hook, tiargs);\n+                auto arguments = new Expressions();\n+                if (global.params.tracegc)\n+                {\n+                    auto funcname = (sc.callsc && sc.callsc.func) ?\n+                        sc.callsc.func.toPrettyChars() : sc.func.toPrettyChars();\n+                    arguments.push(new StringExp(exp.loc, exp.loc.filename.toDString()));\n+                    arguments.push(new IntegerExp(exp.loc, exp.loc.linnum, Type.tint32));\n+                    arguments.push(new StringExp(exp.loc, funcname.toDString()));\n+                }\n+                id = new CallExp(exp.loc, id, arguments);\n+\n+                exp.lowering = id.expressionSemantic(sc);\n+            }\n         }\n         else if (auto ts = tb.isTypeStruct())\n         {\n@@ -3805,7 +3852,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             // is the same type as the struct\n             if (nargs && (sd.hasRegularCtor() || (sd.ctor && (*exp.arguments)[0].type.mutableOf() == sd.type.mutableOf())))\n             {\n-                FuncDeclaration f = resolveFuncCall(exp.loc, sc, sd.ctor, null, tb, exp.arguments, FuncResolveFlag.standard);\n+                FuncDeclaration f = resolveFuncCall(exp.loc, sc, sd.ctor, null, tb, exp.argumentList, FuncResolveFlag.standard);\n                 if (!f || f.errors)\n                     return setError();\n \n@@ -3815,7 +3862,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                 TypeFunction tf = f.type.isTypeFunction();\n                 if (!exp.arguments)\n                     exp.arguments = new Expressions();\n-                if (functionParameters(exp.loc, sc, tf, null, exp.type, exp.arguments, f, &exp.type, &exp.argprefix))\n+                if (functionParameters(exp.loc, sc, tf, null, exp.type, exp.argumentList, f, &exp.type, &exp.argprefix))\n                     return setError();\n \n                 exp.member = f.isCtorDeclaration();\n@@ -3826,8 +3873,20 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             }\n             else\n             {\n-                if (!exp.arguments)\n+                if (exp.names)\n+                {\n+                    exp.arguments = resolveStructLiteralNamedArgs(sd, exp.type, sc, exp.loc,\n+                        exp.names ? (*exp.names)[] : null,\n+                        (size_t i, Type t) => (*exp.arguments)[i],\n+                        i => (*exp.arguments)[i].loc\n+                    );\n+                    if (!exp.arguments)\n+                        return setError();\n+                }\n+                else if (!exp.arguments)\n+                {\n                     exp.arguments = new Expressions();\n+                }\n \n                 if (!sd.fit(exp.loc, sc, exp.arguments, tb))\n                     return setError();\n@@ -3876,6 +3935,12 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                 }\n \n                 Expression arg = (*exp.arguments)[i];\n+                if (exp.names && (*exp.names)[i])\n+                {\n+                    exp.error(\"no named argument `%s` allowed for array dimension\", (*exp.names)[i].toChars());\n+                    return setError();\n+                }\n+\n                 arg = resolveProperties(sc, arg);\n                 arg = arg.implicitCastTo(sc, Type.tsize_t);\n                 if (arg.op == EXP.error)\n@@ -3897,6 +3962,11 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             }\n             else if (nargs == 1)\n             {\n+                if (exp.names && (*exp.names)[0])\n+                {\n+                    exp.error(\"no named argument `%s` allowed for scalar\", (*exp.names)[0].toChars());\n+                    return setError();\n+                }\n                 Expression e = (*exp.arguments)[0];\n                 e = e.implicitCastTo(sc, tb);\n                 (*exp.arguments)[0] = e;\n@@ -4285,7 +4355,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         if (FuncExp fe = exp.e1.isFuncExp())\n         {\n             if (arrayExpressionSemantic(exp.arguments.peekSlice(), sc) ||\n-                preFunctionParameters(sc, exp.arguments))\n+                preFunctionParameters(sc, exp.argumentList))\n                 return setError();\n \n             // Run e1 semantic even if arguments have any errors\n@@ -4524,7 +4594,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             return;\n         }\n         if (arrayExpressionSemantic(exp.arguments.peekSlice(), sc) ||\n-            preFunctionParameters(sc, exp.arguments))\n+            preFunctionParameters(sc, exp.argumentList))\n             return setError();\n \n         // Check for call operator overload\n@@ -4622,7 +4692,22 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                 /* It's a struct literal\n                  */\n             Lx:\n-                Expression e = new StructLiteralExp(exp.loc, sd, exp.arguments, exp.e1.type);\n+                Expressions* resolvedArgs = exp.arguments;\n+                if (exp.names)\n+                {\n+                    resolvedArgs = resolveStructLiteralNamedArgs(sd, exp.e1.type, sc, exp.loc,\n+                        (*exp.names)[],\n+                        (size_t i, Type t) => (*exp.arguments)[i],\n+                        i => (*exp.arguments)[i].loc\n+                    );\n+                    if (!resolvedArgs)\n+                    {\n+                        result = ErrorExp.get();\n+                        return;\n+                    }\n+                }\n+\n+                Expression e = new StructLiteralExp(exp.loc, sd, resolvedArgs, exp.e1.type);\n                 e = e.expressionSemantic(sc);\n                 result = e;\n                 return;\n@@ -4632,7 +4717,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             L1:\n                 // Rewrite as e1.call(arguments)\n                 Expression e = new DotIdExp(exp.loc, exp.e1, Id.call);\n-                e = new CallExp(exp.loc, e, exp.arguments);\n+                e = new CallExp(exp.loc, e, exp.arguments, exp.names);\n                 e = e.expressionSemantic(sc);\n                 result = e;\n                 return;\n@@ -4671,14 +4756,14 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         }\n \n         FuncDeclaration resolveOverloadSet(Loc loc, Scope* sc,\n-            OverloadSet os, Objects* tiargs, Type tthis, Expressions* arguments)\n+            OverloadSet os, Objects* tiargs, Type tthis, ArgumentList argumentList)\n         {\n             FuncDeclaration f = null;\n             foreach (s; os.a)\n             {\n                 if (tiargs && s.isFuncDeclaration())\n                     continue;\n-                if (auto f2 = resolveFuncCall(loc, sc, s, tiargs, tthis, arguments, FuncResolveFlag.quiet))\n+                if (auto f2 = resolveFuncCall(loc, sc, s, tiargs, tthis, argumentList, FuncResolveFlag.quiet))\n                 {\n                     if (f2.errors)\n                         return null;\n@@ -4738,7 +4823,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             }\n \n             // Do overload resolution\n-            exp.f = resolveFuncCall(exp.loc, sc, s, tiargs, ue.e1.type, exp.arguments, FuncResolveFlag.standard);\n+            exp.f = resolveFuncCall(exp.loc, sc, s, tiargs, ue.e1.type, exp.argumentList, FuncResolveFlag.standard);\n             if (!exp.f || exp.f.errors || exp.f.type.ty == Terror)\n                 return setError();\n \n@@ -4901,9 +4986,9 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             tthis = ad.type.addMod(sc.func.type.mod);\n             auto ctor = isSuper ? cd.baseClass.ctor : ad.ctor;\n             if (auto os = ctor.isOverloadSet())\n-                exp.f = resolveOverloadSet(exp.loc, sc, os, null, tthis, exp.arguments);\n+                exp.f = resolveOverloadSet(exp.loc, sc, os, null, tthis, exp.argumentList);\n             else\n-                exp.f = resolveFuncCall(exp.loc, sc, ctor, null, tthis, exp.arguments, FuncResolveFlag.standard);\n+                exp.f = resolveFuncCall(exp.loc, sc, ctor, null, tthis, exp.argumentList, FuncResolveFlag.standard);\n \n             if (!exp.f || exp.f.errors)\n                 return setError();\n@@ -4928,7 +5013,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         }\n         else if (auto oe = exp.e1.isOverExp())\n         {\n-            exp.f = resolveOverloadSet(exp.loc, sc, oe.vars, tiargs, tthis, exp.arguments);\n+            exp.f = resolveOverloadSet(exp.loc, sc, oe.vars, tiargs, tthis, exp.argumentList);\n             if (!exp.f)\n                 return setError();\n             if (ethis)\n@@ -4975,7 +5060,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             else if (exp.e1.op == EXP.dotVariable && (cast(DotVarExp)exp.e1).var.isOverDeclaration())\n             {\n                 DotVarExp dve = cast(DotVarExp)exp.e1;\n-                exp.f = resolveFuncCall(exp.loc, sc, dve.var, tiargs, dve.e1.type, exp.arguments, FuncResolveFlag.overloadOnly);\n+                exp.f = resolveFuncCall(exp.loc, sc, dve.var, tiargs, dve.e1.type, exp.argumentList, FuncResolveFlag.overloadOnly);\n                 if (!exp.f)\n                     return setError();\n                 if (exp.f.needThis())\n@@ -4999,7 +5084,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             {\n                 s = (cast(TemplateExp)exp.e1).td;\n             L2:\n-                exp.f = resolveFuncCall(exp.loc, sc, s, tiargs, null, exp.arguments, FuncResolveFlag.standard);\n+                exp.f = resolveFuncCall(exp.loc, sc, s, tiargs, null, exp.argumentList, FuncResolveFlag.standard);\n                 if (!exp.f || exp.f.errors)\n                     return setError();\n                 if (exp.f.needThis())\n@@ -5027,8 +5112,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             }\n \n             const(char)* failMessage;\n-            Expression[] fargs = exp.arguments ? (*exp.arguments)[] : null;\n-            if (!tf.callMatch(null, fargs, 0, &failMessage, sc))\n+            if (!tf.callMatch(null, exp.argumentList, 0, &failMessage, sc))\n             {\n                 OutBuffer buf;\n                 buf.writeByte('(');\n@@ -5095,14 +5179,13 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             tiargs = null;\n \n             if (exp.f.overnext)\n-                exp.f = resolveFuncCall(exp.loc, sc, exp.f, tiargs, null, exp.arguments, FuncResolveFlag.overloadOnly);\n+                exp.f = resolveFuncCall(exp.loc, sc, exp.f, tiargs, null, exp.argumentList, FuncResolveFlag.overloadOnly);\n             else\n             {\n                 exp.f = exp.f.toAliasFunc();\n                 TypeFunction tf = cast(TypeFunction)exp.f.type;\n                 const(char)* failMessage;\n-                Expression[] fargs = exp.arguments ? (*exp.arguments)[] : null;\n-                if (!tf.callMatch(null, fargs, 0, &failMessage, sc))\n+                if (!tf.callMatch(null, exp.argumentList, 0, &failMessage, sc))\n                 {\n                     OutBuffer buf;\n                     buf.writeByte('(');\n@@ -5144,7 +5227,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                     //\n                     // https://issues.dlang.org/show_bug.cgi?id=22157\n                     if (exp.f.overnext)\n-                        exp.f = resolveFuncCall(exp.loc, sc, exp.f, tiargs, null, exp.arguments, FuncResolveFlag.standard);\n+                        exp.f = resolveFuncCall(exp.loc, sc, exp.f, tiargs, null, exp.argumentList, FuncResolveFlag.standard);\n \n                     if (!exp.f || exp.f.errors)\n                         return setError();\n@@ -5176,7 +5259,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         Expression argprefix;\n         if (!exp.arguments)\n             exp.arguments = new Expressions();\n-        if (functionParameters(exp.loc, sc, cast(TypeFunction)t1, ethis, tthis, exp.arguments, exp.f, &exp.type, &argprefix))\n+        if (functionParameters(exp.loc, sc, cast(TypeFunction)t1, ethis, tthis, exp.argumentList, exp.f, &exp.type, &argprefix))\n             return setError();\n \n         if (!exp.type)\n@@ -5499,8 +5582,18 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         {\n             // Handle this in the glue layer\n             e = new TypeidExp(exp.loc, ta);\n-            e.type = getTypeInfoType(exp.loc, ta, sc);\n \n+            bool genObjCode = true;\n+\n+            // https://issues.dlang.org/show_bug.cgi?id=23650\n+            // We generate object code for typeinfo, required\n+            // by typeid, only if in non-speculative context\n+            if (sc.flags & SCOPE.compile)\n+            {\n+                genObjCode = false;\n+            }\n+\n+            e.type = getTypeInfoType(exp.loc, ta, sc, genObjCode);\n             semanticTypeInfo(sc, ta);\n \n             if (ea)\n@@ -6009,7 +6102,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         uint errors = global.errors;\n         const len = buf.length;\n         const str = buf.extractChars()[0 .. len];\n-        scope p = new Parser!ASTCodegen(exp.loc, sc._module, str, false);\n+        scope p = new Parser!ASTCodegen(exp.loc, sc._module, str, false, global.errorSink);\n         p.nextToken();\n         //printf(\"p.loc.linnum = %d\\n\", p.loc.linnum);\n \n@@ -8342,13 +8435,12 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n \n         Type t1b = exp.e1.type.toBasetype();\n \n-        if (t1b.ty == Tvector)\n+        if (TypeVector tv1 = t1b.isTypeVector())\n         {\n             // Convert e1 to corresponding static array\n-            TypeVector tv1 = cast(TypeVector)t1b;\n             t1b = tv1.basetype;\n             t1b = t1b.castMod(tv1.mod);\n-            exp.e1.type = t1b;\n+            exp.e1 = exp.e1.castTo(sc, t1b);\n         }\n         if (t1b.ty == Tsarray || t1b.ty == Tarray)\n         {\n@@ -12043,6 +12135,15 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             __equals = new DotIdExp(exp.loc, __equals, Id.object);\n             __equals = new DotIdExp(exp.loc, __equals, id);\n \n+            /* https://issues.dlang.org/show_bug.cgi?id=23674\n+             *\n+             * Optimize before creating the call expression to the\n+             * druntime hook as the optimizer may output errors\n+             * that will get swallowed otherwise.\n+             */\n+            exp.e1 = exp.e1.optimize(WANTvalue);\n+            exp.e2 = exp.e2.optimize(WANTvalue);\n+\n             auto arguments = new Expressions(2);\n             (*arguments)[0] = exp.e1;\n             (*arguments)[1] = exp.e2;\n@@ -13149,11 +13250,6 @@ bool checkSharedAccess(Expression e, Scope* sc, bool returnRef = false)\n \n     //printf(\"checkSharedAccess() `%s` returnRef: %d\\n\", e.toChars(), returnRef);\n \n-    /* In case we don't know which expression triggered it,\n-     * e.g. for `visit(Type)` overload\n-     */\n-    Expression original = e;\n-\n     bool check(Expression e, bool allowRef)\n     {\n         bool sharedError(Expression e)\n@@ -13166,7 +13262,9 @@ bool checkSharedAccess(Expression e, Scope* sc, bool returnRef = false)\n         // Error by default\n         bool visit(Expression e)\n         {\n-            if (e.type.isShared())\n+            // https://issues.dlang.org/show_bug.cgi?id=23639\n+            // Should be able to cast(shared)\n+            if (!e.isCastExp() && e.type.isShared())\n                 return sharedError(e);\n             return false;\n         }\n@@ -13175,10 +13273,6 @@ bool checkSharedAccess(Expression e, Scope* sc, bool returnRef = false)\n         {\n             if (e.thisexp)\n                 check(e.thisexp, false);\n-            // Note: This handles things like `new shared(Throwable).msg`,\n-            // where accessing `msg` would violate `shared`.\n-            if (e.newtype.isShared())\n-                return sharedError(original);\n             return false;\n         }\n \n@@ -13216,33 +13310,32 @@ bool checkSharedAccess(Expression e, Scope* sc, bool returnRef = false)\n             return check(e.e1, false);\n         }\n \n-        bool visitThis(ThisExp e)\n+        bool visitDotVar(DotVarExp e)\n         {\n-            if (sc.func && sc.func.isSynchronized())\n-                return false;\n+            //printf(\"dotvarexp = %s\\n\", e.toChars());\n+            if (e.type.isShared())\n+            {\n+                // / https://issues.dlang.org/show_bug.cgi?id=22626\n+                if (e.e1.isThisExp() && sc.func && sc.func.isSynchronized())\n+                    return false;\n \n-            if (!allowRef && e.type.isShared())\n-                return sharedError(e);\n+                auto fd = e.var.isFuncDeclaration();\n+                const sharedFunc = fd && fd.type.isShared;\n+                if (!allowRef && !sharedFunc)\n+                    return sharedError(e);\n \n-            return false;\n-        }\n+                // Allow using `DotVarExp` within value types\n+                if (e.e1.type.isTypeSArray() || e.e1.type.isTypeStruct())\n+                    return check(e.e1, allowRef);\n \n-        bool visitDotVar(DotVarExp e)\n-        {\n-            //printf(\"dotvarexp = %s\\n\", e.toChars());\n-            auto fd = e.var.isFuncDeclaration();\n-            const sharedFunc = fd && fd.type.isShared;\n-            // Allow using `DotVarExp` within value types\n-            if (!allowRef && e.type.isShared() && !sharedFunc && !(sc.func && sc.func.isSynchronized()))\n-                return sharedError(e);\n-            if (e.e1.type.isTypeSArray() || e.e1.type.isTypeStruct())\n-                return check(e.e1, allowRef);\n+                // If we end up with a single `VarExp`, it might be a `ref` param\n+                // `shared ref T` param == `shared(T)*`.\n+                if (auto ve = e.e1.isVarExp())\n+                {\n+                    return check(e.e1, allowRef && (ve.var.storage_class & STC.ref_));\n+                }\n \n-            // If we end up with a single `VarExp`, it might be a `ref` param\n-            // `shared ref T` param == `shared(T)*`.\n-            if (auto ve = e.e1.isVarExp())\n-            {\n-                return check(e.e1, allowRef && (ve.var.storage_class & STC.ref_));\n+                return sharedError(e);\n             }\n \n             return check(e.e1, false);\n@@ -13283,7 +13376,6 @@ bool checkSharedAccess(Expression e, Scope* sc, bool returnRef = false)\n             case EXP.star:        return visitPtr(e.isPtrExp());\n             case EXP.dotVariable: return visitDotVar(e.isDotVarExp());\n             case EXP.index:       return visitIndex(e.isIndexExp());\n-            case EXP.this_:       return visitThis(e.isThisExp());\n         }\n     }\n "}, {"sha": "ba2825a3098dfa80d71eb560c4529bde32bae965", "filename": "gcc/d/dmd/foreachvar.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fforeachvar.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fforeachvar.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fforeachvar.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -56,7 +56,7 @@ void foreachVar(Expression e, void delegate(VarDeclaration) dgVar)\n         alias visit = typeof(super).visit;\n         extern (D) void delegate(VarDeclaration) dgVar;\n \n-        extern (D) this(void delegate(VarDeclaration) dgVar)\n+        extern (D) this(void delegate(VarDeclaration) dgVar) scope\n         {\n             this.dgVar = dgVar;\n         }"}, {"sha": "4b6b5b58233942cff73b4866afb87a46136dfbb6", "filename": "gcc/d/dmd/func.d", "status": "modified", "additions": 62, "deletions": 17, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Ffunc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Ffunc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ffunc.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -202,7 +202,7 @@ private struct FUNCFLAG\n     bool inlineScanned;      /// function has been scanned for inline possibilities\n     bool inferScope;         /// infer 'scope' for parameters\n     bool hasCatches;         /// function has try-catch statements\n-    bool isCompileTimeOnly;  /// is a compile time only function; no code will be generated for it\n+    bool skipCodegen;        /// do not generate code for this function.\n     bool printf;             /// is a printf-like function\n     bool scanf;              /// is a scanf-like function\n     bool noreturn;           /// the function does not return\n@@ -217,6 +217,8 @@ private struct FUNCFLAG\n     bool hasAlwaysInlines;   /// Contains references to functions that must be inlined\n     bool isCrtCtor;          /// Has attribute pragma(crt_constructor)\n     bool isCrtDtor;          /// Has attribute pragma(crt_destructor)\n+    bool hasEscapingSiblings;/// Has sibling functions that escape\n+    bool computedEscapingSiblings; /// `hasEscapingSiblings` has been computed\n }\n \n /***********************************************************\n@@ -322,6 +324,12 @@ extern (C++) class FuncDeclaration : Declaration\n \n     GotoStatements* gotos;              /// Gotos with forward references\n \n+    version (MARS)\n+    {\n+        VarDeclarations* alignSectionVars;  /// local variables with alignment needs larger than stackAlign\n+        Symbol* salignSection;              /// pointer to aligned section, if any\n+    }\n+\n     /// set if this is a known, builtin function we can evaluate at compile time\n     BUILTIN builtin = BUILTIN.unknown;\n \n@@ -1039,12 +1047,13 @@ extern (C++) class FuncDeclaration : Declaration\n      *      match   'this' is at least as specialized as g\n      *      0       g is more specialized than 'this'\n      */\n-    final MATCH leastAsSpecialized(FuncDeclaration g)\n+    final MATCH leastAsSpecialized(FuncDeclaration g, Identifiers* names)\n     {\n         enum LOG_LEASTAS = 0;\n         static if (LOG_LEASTAS)\n         {\n-            printf(\"%s.leastAsSpecialized(%s)\\n\", toChars(), g.toChars());\n+            import core.stdc.stdio : printf;\n+            printf(\"%s.leastAsSpecialized(%s, %s)\\n\", toChars(), g.toChars(), names ? names.toChars() : \"null\");\n             printf(\"%s, %s\\n\", type.toChars(), g.type.toChars());\n         }\n \n@@ -1089,7 +1098,7 @@ extern (C++) class FuncDeclaration : Declaration\n             args.push(e);\n         }\n \n-        MATCH m = tg.callMatch(null, args[], 1);\n+        MATCH m = tg.callMatch(null, ArgumentList(&args, names), 1);\n         if (m > MATCH.nomatch)\n         {\n             /* A variadic parameter list is less specialized than a\n@@ -1979,6 +1988,7 @@ extern (C++) class FuncDeclaration : Declaration\n                         if (!sc.intypeof && !(sc.flags & SCOPE.compile))\n                         {\n                             siblingCallers.push(fdthis);\n+                            computedEscapingSiblings = false;\n                         }\n                     }\n                 }\n@@ -2028,8 +2038,7 @@ extern (C++) class FuncDeclaration : Declaration\n          * is already set to `true` upon entering this function when the\n          * struct/class refers to a local variable and a closure is needed.\n          */\n-\n-        //printf(\"FuncDeclaration::needsClosure() %s\\n\", toChars());\n+        //printf(\"FuncDeclaration::needsClosure() %s\\n\", toPrettyChars());\n \n         if (requiresClosure)\n             goto Lyes;\n@@ -2106,7 +2115,7 @@ extern (C++) class FuncDeclaration : Declaration\n      */\n     extern (C++) final bool checkClosure()\n     {\n-        //printf(\"checkClosure() %s\\n\", toChars());\n+        //printf(\"checkClosure() %s\\n\", toPrettyChars());\n         if (!needsClosure())\n             return false;\n \n@@ -2320,6 +2329,7 @@ extern (C++) class FuncDeclaration : Declaration\n          *    base.in();\n          *    assert(false, \"Logic error: \" ~ thr.msg);\n          *  }\n+         * }\n          */\n \n         foreach (fdv; foverrides)\n@@ -2827,6 +2837,12 @@ extern (C++) class FuncDeclaration : Declaration\n                         return false;\n                     if (v.nestedrefs.length && needsClosure())\n                         return false;\n+                    // don't know if the return storage is aligned\n+                    version (MARS)\n+                    {\n+                        if (alignSectionVars && (*alignSectionVars).contains(v))\n+                            return false;\n+                    }\n                     // The variable type needs to be equivalent to the return type.\n                     if (!v.type.equivalent(tf.next))\n                         return false;\n@@ -3127,14 +3143,15 @@ enum FuncResolveFlag : ubyte\n  *      s =             instantiation symbol\n  *      tiargs =        initial list of template arguments\n  *      tthis =         if !NULL, the `this` argument type\n- *      fargs =         arguments to function\n+ *      argumentList =  arguments to function\n  *      flags =         see $(LREF FuncResolveFlag).\n  * Returns:\n  *      if match is found, then function symbol, else null\n  */\n FuncDeclaration resolveFuncCall(const ref Loc loc, Scope* sc, Dsymbol s,\n-    Objects* tiargs, Type tthis, Expressions* fargs, FuncResolveFlag flags)\n+    Objects* tiargs, Type tthis, ArgumentList argumentList, FuncResolveFlag flags)\n {\n+    auto fargs = argumentList.arguments;\n     if (!s)\n         return null; // no match\n \n@@ -3152,6 +3169,7 @@ FuncDeclaration resolveFuncCall(const ref Loc loc, Scope* sc, Dsymbol s,\n                 printf(\"\\t%s: %s\\n\", arg.toChars(), arg.type.toChars());\n             }\n         }\n+        printf(\"\\tfnames: %s\\n\", fnames ? fnames.toChars() : \"null\");\n     }\n \n     if (tiargs && arrayObjectIsError(tiargs))\n@@ -3162,7 +3180,7 @@ FuncDeclaration resolveFuncCall(const ref Loc loc, Scope* sc, Dsymbol s,\n                 return null;\n \n     MatchAccumulator m;\n-    functionResolve(m, s, loc, sc, tiargs, tthis, fargs, null);\n+    functionResolve(m, s, loc, sc, tiargs, tthis, argumentList);\n     auto orig_s = s;\n \n     if (m.last > MATCH.nomatch && m.lastf)\n@@ -3285,7 +3303,7 @@ FuncDeclaration resolveFuncCall(const ref Loc loc, Scope* sc, Dsymbol s,\n         }\n \n         const(char)* failMessage;\n-        functionResolve(m, orig_s, loc, sc, tiargs, tthis, fargs, &failMessage);\n+        functionResolve(m, orig_s, loc, sc, tiargs, tthis, argumentList, &failMessage);\n         if (failMessage)\n         {\n             .error(loc, \"%s `%s%s%s` is not callable using argument types `%s`\",\n@@ -3331,7 +3349,7 @@ FuncDeclaration resolveFuncCall(const ref Loc loc, Scope* sc, Dsymbol s,\n                     if (auto baseFunction = baseClass.search(baseClass.loc, fd.ident))\n                     {\n                         MatchAccumulator mErr;\n-                        functionResolve(mErr, baseFunction, loc, sc, tiargs, baseClass.type, fargs, null);\n+                        functionResolve(mErr, baseFunction, loc, sc, tiargs, baseClass.type, argumentList);\n                         if (mErr.last > MATCH.nomatch && mErr.lastf)\n                         {\n                             errorSupplemental(loc, \"%s `%s` hides base class function `%s`\",\n@@ -3345,7 +3363,7 @@ FuncDeclaration resolveFuncCall(const ref Loc loc, Scope* sc, Dsymbol s,\n             }\n         }\n         const(char)* failMessage;\n-        functionResolve(m, orig_s, loc, sc, tiargs, tthis, fargs, &failMessage);\n+        functionResolve(m, orig_s, loc, sc, tiargs, tthis, argumentList, &failMessage);\n         if (failMessage)\n             errorSupplemental(loc, failMessage);\n     }\n@@ -3362,8 +3380,10 @@ FuncDeclaration resolveFuncCall(const ref Loc loc, Scope* sc, Dsymbol s,\n private void printCandidates(Decl)(const ref Loc loc, Decl declaration, bool showDeprecated)\n if (is(Decl == TemplateDeclaration) || is(Decl == FuncDeclaration))\n {\n-    // max num of overloads to print (-v overrides this).\n-    enum int DisplayLimit = 5;\n+    // max num of overloads to print (-v or -verror-supplements overrides this).\n+    const int DisplayLimit = !global.params.verbose ?\n+                                (global.params.errorSupplementLimit ? global.params.errorSupplementLimit : int.max)\n+                                : int.max;\n     const(char)* constraintsTip;\n     // determine if the first candidate was printed\n     int printed;\n@@ -3619,6 +3639,9 @@ private bool checkEscapingSiblings(FuncDeclaration f, FuncDeclaration outerFunc,\n         FuncDeclaration f;\n     }\n \n+    if (f.computedEscapingSiblings)\n+        return f.hasEscapingSiblings;\n+\n     PrevSibling ps;\n     ps.p = cast(PrevSibling*)p;\n     ps.f = f;\n@@ -3660,6 +3683,8 @@ private bool checkEscapingSiblings(FuncDeclaration f, FuncDeclaration outerFunc,\n             prev = prev.p;\n         }\n     }\n+    f.hasEscapingSiblings = bAnyClosures;\n+    f.computedEscapingSiblings = true;\n     //printf(\"\\t%d\\n\", bAnyClosures);\n     return bAnyClosures;\n }\n@@ -3859,7 +3884,7 @@ extern (C++) final class CtorDeclaration : FuncDeclaration\n     {\n         super(loc, endloc, Id.ctor, stc, type);\n         this.isCpCtor = isCpCtor;\n-        //printf(\"CtorDeclaration(loc = %s) %s\\n\", loc.toChars(), toChars());\n+        //printf(\"CtorDeclaration(loc = %s) %s %p\\n\", loc.toChars(), toChars(), this);\n     }\n \n     override CtorDeclaration syntaxCopy(Dsymbol s)\n@@ -4350,6 +4375,26 @@ extern (C++) final class NewDeclaration : FuncDeclaration\n     }\n }\n \n+/**************************************\n+ * When a traits(compiles) is used on a function literal call\n+ * we need to take into account if the body of the function\n+ * violates any attributes, however, we must not affect the\n+ * attribute inference on the outer function. The attributes\n+ * of the function literal still need to be inferred, therefore\n+ * we need a way to check for the scope that the traits compiles\n+ * introduces.\n+ *\n+ * Params:\n+ *   sc = scope to be checked for\n+ *\n+ * Returns: `true` if the provided scope is the root\n+ * of the traits compiles list of scopes.\n+ */\n+bool isRootTraitsCompilesScope(Scope* sc)\n+{\n+    return (sc.flags & SCOPE.compile) && !(sc.func.flags & SCOPE.compile);\n+}\n+\n /**************************************\n  * A statement / expression in this scope is not `@safe`,\n  * so mark the enclosing function as `@system`\n@@ -4392,7 +4437,7 @@ bool setUnsafe(Scope* sc,\n     }\n \n \n-    if (sc.flags & SCOPE.compile) // __traits(compiles, x)\n+    if (isRootTraitsCompilesScope(sc)) // __traits(compiles, x)\n     {\n         if (sc.func.isSafeBypassingInference())\n         {"}, {"sha": "1919d9ae0ce1e0a53907a77443d1384100c1ed6d", "filename": "gcc/d/dmd/globals.d", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fglobals.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fglobals.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fglobals.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -15,6 +15,8 @@ import core.stdc.stdint;\n import dmd.root.array;\n import dmd.root.filename;\n import dmd.common.outbuffer;\n+import dmd.errorsink;\n+import dmd.errors;\n import dmd.file_manager;\n import dmd.identifier;\n import dmd.location;\n@@ -143,7 +145,7 @@ extern (C++) struct Param\n     bool logo;              // print compiler logo\n \n     // Options for `-preview=/-revert=`\n-    FeatureState useDIP25;       // implement https://wiki.dlang.org/DIP25\n+    FeatureState useDIP25 = FeatureState.enabled; // implement https://wiki.dlang.org/DIP25\n     FeatureState useDIP1000;     // implement https://dlang.org/spec/memory-safe-d.html#scope-return-params\n     bool ehnogc;                 // use @nogc exception handling\n     bool useDIP1021;             // implement https://github.com/dlang/DIPs/blob/master/DIPs/accepted/DIP1021.md\n@@ -176,6 +178,7 @@ extern (C++) struct Param\n     CHECKACTION checkAction = CHECKACTION.D; // action to take when bounds, asserts or switch defaults are violated\n \n     uint errorLimit = 20;\n+    uint errorSupplementLimit = 6;      // Limit the number of supplemental messages for each error (0 means unlimited)\n \n     const(char)[] argv0;                // program name\n     Array!(const(char)*) modFileAliasStrings; // array of char*'s of -I module filename alias strings\n@@ -291,6 +294,8 @@ extern (C++) struct Global\n \n     enum recursionLimit = 500; /// number of recursive template expansions before abort\n \n+    ErrorSink errorSink;       /// where the error messages go\n+\n     extern (C++) FileName function(FileName, ref const Loc, out bool, OutBuffer*) preprocess;\n \n   nothrow:\n@@ -345,6 +350,8 @@ extern (C++) struct Global\n \n     extern (C++) void _init()\n     {\n+        global.errorSink = new ErrorSinkCompiler;\n+\n         this.fileManager = new FileManager();\n         version (MARS)\n         {"}, {"sha": "ec8fc32ed0f52871737bb85afdc8f2ed2bbbe97c", "filename": "gcc/d/dmd/globals.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fglobals.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fglobals.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fglobals.h?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -19,6 +19,7 @@\n // Can't include arraytypes.h here, need to declare these directly.\n template <typename TYPE> struct Array;\n \n+class ErrorSink;\n class FileManager;\n struct Loc;\n \n@@ -179,6 +180,7 @@ struct Param\n     CHECKACTION checkAction;       // action to take when bounds, asserts or switch defaults are violated\n \n     unsigned errorLimit;\n+    unsigned errorSupplementLimit; // Limit the number of supplemental messages for each error (0 means unlimited)\n \n     DString  argv0;    // program name\n     Array<const char *> modFileAliasStrings; // array of char*'s of -I module filename alias strings\n@@ -277,6 +279,7 @@ struct Global\n     unsigned varSequenceNumber;\n \n     FileManager* fileManager;\n+    ErrorSink* errorSink;       // where the error messages go\n \n     FileName (*preprocess)(FileName, const Loc&, bool&, OutBuffer&);\n "}, {"sha": "c7e5690bc0a7e9d9486e48ee83776ad1d72ce90f", "filename": "gcc/d/dmd/hdrgen.d", "status": "modified", "additions": 57, "deletions": 16, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fhdrgen.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fhdrgen.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fhdrgen.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -65,6 +65,7 @@ struct HdrGenState\n     int autoMember;\n     int forStmtInit;\n     int insideFuncBody;\n+    int insideAggregate;\n \n     bool declstring; // set while declaring alias for string,wstring or dstring\n     EnumDeclaration inEnumDecl;\n@@ -144,7 +145,7 @@ public:\n     OutBuffer* buf;\n     HdrGenState* hgs;\n \n-    extern (D) this(OutBuffer* buf, HdrGenState* hgs)\n+    extern (D) this(OutBuffer* buf, HdrGenState* hgs) scope\n     {\n         this.buf = buf;\n         this.hgs = hgs;\n@@ -805,7 +806,7 @@ public:\n     OutBuffer* buf;\n     HdrGenState* hgs;\n \n-    extern (D) this(OutBuffer* buf, HdrGenState* hgs)\n+    extern (D) this(OutBuffer* buf, HdrGenState* hgs) scope\n     {\n         this.buf = buf;\n         this.hgs = hgs;\n@@ -1406,8 +1407,10 @@ public:\n         buf.writeByte('{');\n         buf.writenl();\n         buf.level++;\n+        hgs.insideAggregate++;\n         foreach (s; *d.members)\n             s.accept(this);\n+        hgs.insideAggregate--;\n         buf.level--;\n         buf.writeByte('}');\n         buf.writenl();\n@@ -1428,8 +1431,10 @@ public:\n             buf.writeByte('{');\n             buf.writenl();\n             buf.level++;\n+            hgs.insideAggregate++;\n             foreach (s; *d.members)\n                 s.accept(this);\n+            hgs.insideAggregate--;\n             buf.level--;\n             buf.writeByte('}');\n         }\n@@ -1521,28 +1526,52 @@ public:\n \n     void visitVarDecl(VarDeclaration v, bool anywritten)\n     {\n+        const bool isextern = hgs.hdrgen &&\n+            !hgs.insideFuncBody &&\n+            !hgs.tpltMember &&\n+            !hgs.insideAggregate &&\n+            !(v.storage_class & STC.manifest);\n+\n+        void vinit(VarDeclaration v)\n+        {\n+            auto ie = v._init.isExpInitializer();\n+            if (ie && (ie.exp.op == EXP.construct || ie.exp.op == EXP.blit))\n+                (cast(AssignExp)ie.exp).e2.expressionToBuffer(buf, hgs);\n+            else\n+                v._init.initializerToBuffer(buf, hgs);\n+        }\n+\n         if (anywritten)\n         {\n             buf.writestring(\", \");\n             buf.writestring(v.ident.toString());\n         }\n         else\n         {\n-            if (stcToBuffer(buf, v.storage_class))\n+            const bool useTypeof = isextern && v._init && !v.type;\n+            auto stc = v.storage_class;\n+            if (isextern)\n+                stc |= STC.extern_;\n+            if (useTypeof)\n+                stc &= ~STC.auto_;\n+            if (stcToBuffer(buf, stc))\n                 buf.writeByte(' ');\n             if (v.type)\n                 typeToBuffer(v.type, v.ident, buf, hgs);\n+            else if (useTypeof)\n+            {\n+                buf.writestring(\"typeof(\");\n+                vinit(v);\n+                buf.writestring(\") \");\n+                buf.writestring(v.ident.toString());\n+            }\n             else\n                 buf.writestring(v.ident.toString());\n         }\n-        if (v._init)\n+        if (v._init && !isextern)\n         {\n             buf.writestring(\" = \");\n-            auto ie = v._init.isExpInitializer();\n-            if (ie && (ie.exp.op == EXP.construct || ie.exp.op == EXP.blit))\n-                (cast(AssignExp)ie.exp).e2.expressionToBuffer(buf, hgs);\n-            else\n-                v._init.initializerToBuffer(buf, hgs);\n+            vinit(v);\n         }\n     }\n \n@@ -2136,7 +2165,7 @@ private void expressionPrettyPrint(Expression e, OutBuffer* buf, HdrGenState* hg\n         if (e.arguments && e.arguments.length)\n         {\n             buf.writeByte('(');\n-            argsToBuffer(e.arguments, buf, hgs);\n+            argsToBuffer(e.arguments, buf, hgs, null, e.names);\n             buf.writeByte(')');\n         }\n     }\n@@ -2440,7 +2469,7 @@ private void expressionPrettyPrint(Expression e, OutBuffer* buf, HdrGenState* hg\n         else\n             expToBuffer(e.e1, precedence[e.op], buf, hgs);\n         buf.writeByte('(');\n-        argsToBuffer(e.arguments, buf, hgs);\n+        argsToBuffer(e.arguments, buf, hgs, null, e.names);\n         buf.writeByte(')');\n     }\n \n@@ -2683,15 +2712,15 @@ void floatToBuffer(Type type, const real_t value, OutBuffer* buf, const bool all\n         Plus one for rounding. */\n     const(size_t) BUFFER_LEN = value.sizeof * 3 + 8 + 1 + 1;\n     char[BUFFER_LEN] buffer = void;\n-    CTFloat.sprint(buffer.ptr, 'g', value);\n+    CTFloat.sprint(buffer.ptr, BUFFER_LEN, 'g', value);\n     assert(strlen(buffer.ptr) < BUFFER_LEN);\n     if (allowHex)\n     {\n         bool isOutOfRange;\n         real_t r = CTFloat.parse(buffer.ptr, isOutOfRange);\n         //assert(!isOutOfRange); // test/compilable/test22725.c asserts here\n         if (r != value) // if exact duplication\n-            CTFloat.sprint(buffer.ptr, 'a', value);\n+            CTFloat.sprint(buffer.ptr, BUFFER_LEN, 'a', value);\n     }\n     buf.writestring(buffer.ptr);\n     if (buffer.ptr[strlen(buffer.ptr) - 1] == '.')\n@@ -2733,7 +2762,7 @@ public:\n     OutBuffer* buf;\n     HdrGenState* hgs;\n \n-    extern (D) this(OutBuffer* buf, HdrGenState* hgs)\n+    extern (D) this(OutBuffer* buf, HdrGenState* hgs) scope\n     {\n         this.buf = buf;\n         this.hgs = hgs;\n@@ -2814,7 +2843,7 @@ public:\n     OutBuffer* buf;\n     HdrGenState* hgs;\n \n-    extern (D) this(OutBuffer* buf, HdrGenState* hgs)\n+    extern (D) this(OutBuffer* buf, HdrGenState* hgs) scope\n     {\n         this.buf = buf;\n         this.hgs = hgs;\n@@ -3281,8 +3310,14 @@ private void parameterToBuffer(Parameter p, OutBuffer* buf, HdrGenState* hgs)\n \n /**************************************************\n  * Write out argument list to buf.\n+ * Params:\n+ *     expressions = argument list\n+ *     buf = buffer to write to\n+ *     hgs = context\n+ *     basis = replace `null`s in argument list with this expression (for sparse array literals)\n+ *     names = if non-null, use these as the names for the arguments\n  */\n-private void argsToBuffer(Expressions* expressions, OutBuffer* buf, HdrGenState* hgs, Expression basis = null)\n+private void argsToBuffer(Expressions* expressions, OutBuffer* buf, HdrGenState* hgs, Expression basis = null, Identifiers* names = null)\n {\n     if (!expressions || !expressions.length)\n         return;\n@@ -3292,6 +3327,12 @@ private void argsToBuffer(Expressions* expressions, OutBuffer* buf, HdrGenState*\n         {\n             if (i)\n                 buf.writestring(\", \");\n+\n+            if (names && i < names.length && (*names)[i])\n+            {\n+                buf.writestring((*names)[i].toString());\n+                buf.writestring(\": \");\n+            }\n             if (!el)\n                 el = basis;\n             if (el)"}, {"sha": "f8c88ab536e9cccd5cfa2d2829244f07bdc4d652", "filename": "gcc/d/dmd/iasmgcc.d", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fiasmgcc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fiasmgcc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fiasmgcc.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -17,6 +17,7 @@ import dmd.arraytypes;\n import dmd.astcodegen;\n import dmd.dscope;\n import dmd.errors;\n+import dmd.errorsink;\n import dmd.expression;\n import dmd.expressionsem;\n import dmd.identifier;\n@@ -72,7 +73,7 @@ int parseExtAsmOperands(Parser)(Parser p, GccAsmStatement s)\n                 }\n                 else\n                 {\n-                    p.error(s.loc, \"expected identifier after `[`\");\n+                    p.eSink.error(s.loc, \"expected identifier after `[`\");\n                     goto Lerror;\n                 }\n                 // Look for closing `]`\n@@ -116,7 +117,7 @@ int parseExtAsmOperands(Parser)(Parser p, GccAsmStatement s)\n                 break;\n \n             default:\n-                p.error(\"expected constant string constraint for operand, not `%s`\",\n+                p.eSink.error(p.token.loc, \"expected constant string constraint for operand, not `%s`\",\n                         p.token.toChars());\n                 goto Lerror;\n         }\n@@ -167,7 +168,7 @@ Expressions *parseExtAsmClobbers(Parser)(Parser p)\n                 break;\n \n             default:\n-                p.error(\"expected constant string constraint for clobber name, not `%s`\",\n+                p.eSink.error(p.token.loc, \"expected constant string constraint for clobber name, not `%s`\",\n                         p.token.toChars());\n                 goto Lerror;\n         }\n@@ -214,7 +215,7 @@ Identifiers *parseExtAsmGotoLabels(Parser)(Parser p)\n                 break;\n \n             default:\n-                p.error(\"expected identifier for goto label name, not `%s`\",\n+                p.eSink.error(p.token.loc, \"expected identifier for goto label name, not `%s`\",\n                         p.token.toChars());\n                 goto Lerror;\n         }\n@@ -301,7 +302,7 @@ Ldone:\n extern (C++) public Statement gccAsmSemantic(GccAsmStatement s, Scope *sc)\n {\n     //printf(\"GccAsmStatement.semantic()\\n\");\n-    scope p = new Parser!ASTCodegen(sc._module, \";\", false);\n+    scope p = new Parser!ASTCodegen(sc._module, \";\", false, global.errorSink);\n \n     // Make a safe copy of the token list before parsing.\n     Token *toklist = null;\n@@ -384,6 +385,9 @@ unittest\n {\n     import dmd.mtype : TypeBasic;\n \n+    if (!global.errorSink)\n+        global.errorSink = new ErrorSinkCompiler;\n+\n     uint errors = global.startGagging();\n     scope(exit) global.endGagging(errors);\n \n@@ -406,7 +410,7 @@ unittest\n     {\n         const errors = global.errors;\n         scope gas = new GccAsmStatement(Loc.initial, tokens);\n-        scope p = new Parser!ASTCodegen(null, \";\", false);\n+        scope p = new Parser!ASTCodegen(null, \";\", false, global.errorSink);\n         p.token = *tokens;\n         p.parseGccAsm(gas);\n         return global.errors - errors;\n@@ -416,7 +420,7 @@ unittest\n     static void parseAsm(string input, bool expectError)\n     {\n         // Generate tokens from input test.\n-        scope p = new Parser!ASTCodegen(null, input, false);\n+        scope p = new Parser!ASTCodegen(null, input, false, global.errorSink);\n         p.nextToken();\n \n         Token* toklist = null;"}, {"sha": "ec5cb25ef28abf5ee25ff96481bb186f580fc8e8", "filename": "gcc/d/dmd/id.d", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fid.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fid.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fid.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -313,6 +313,8 @@ immutable Msgtable[] msgtable =\n     { \"__ArrayDtor\" },\n     { \"_d_delThrowable\" },\n     { \"_d_newThrowable\" },\n+    { \"_d_newclassT\" },\n+    { \"_d_newclassTTrace\" },\n     { \"_d_assert_fail\" },\n     { \"dup\" },\n     { \"_aaApply\" },\n@@ -455,6 +457,7 @@ immutable Msgtable[] msgtable =\n     { \"isLazy\" },\n     { \"hasMember\" },\n     { \"identifier\" },\n+    { \"fullyQualifiedName\" },\n     { \"getProtection\" },\n     { \"getVisibility\" },\n     { \"parent\" },"}, {"sha": "18b10b41a2d3e19acacca01bd7ccc080acaef681", "filename": "gcc/d/dmd/initsem.d", "status": "modified", "additions": 149, "deletions": 103, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Finitsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Finitsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Finitsem.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -135,111 +135,19 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n             sd.size(i.loc);\n             if (sd.sizeok != Sizeok.done)\n                 return err();\n-            const nfields = sd.nonHiddenFields();\n-            //expandTuples for non-identity arguments?\n-            auto elements = new Expressions(nfields);\n-            auto elems = (*elements)[];\n-            foreach (ref elem; elems)\n-                elem = null;\n-\n-            // Run semantic for explicitly given initializers\n-            // TODO: this part is slightly different from StructLiteralExp::semantic.\n-            bool errors = false;\n-            size_t fieldi = 0;\n-            foreach (j, id; i.field[])\n-            {\n-                if (id)\n-                {\n-                    /* Determine `fieldi` that `id` matches\n-                     */\n-                    Dsymbol s = sd.search(i.loc, id);\n-                    if (!s)\n-                    {\n-                        s = sd.search_correct(id);\n-                        const initLoc = i.value[j].loc;\n-                        if (s)\n-                            error(initLoc, \"`%s` is not a member of `%s`, did you mean %s `%s`?\", id.toChars(), sd.toChars(), s.kind(), s.toChars());\n-                        else\n-                            error(initLoc, \"`%s` is not a member of `%s`\", id.toChars(), sd.toChars());\n-                        return err();\n-                    }\n-                    s.checkDeprecated(i.loc, sc);\n-                    s = s.toAlias();\n-\n-                    // Find out which field index `s` is\n-                    for (fieldi = 0; 1; fieldi++)\n-                    {\n-                        if (fieldi >= nfields)\n-                        {\n-                            error(i.loc, \"`%s.%s` is not a per-instance initializable field\", sd.toChars(), s.toChars());\n-                            return err();\n-                        }\n-                        if (s == sd.fields[fieldi])\n-                            break;\n-                    }\n-                }\n-                if (j >= nfields)\n-                {\n-                    error(i.value[j].loc, \"too many initializers for `%s`\", sd.toChars());\n-                    return err();\n-                }\n-\n-                VarDeclaration vd = sd.fields[fieldi];\n-                if (elems[fieldi])\n-                {\n-                    error(i.value[j].loc, \"duplicate initializer for field `%s`\", vd.toChars());\n-                    errors = true;\n-                    elems[fieldi] = ErrorExp.get(); // for better diagnostics on multiple errors\n-                    ++fieldi;\n-                    continue;\n-                }\n-\n-                // Check for @safe violations\n-                if (vd.type.hasPointers)\n-                {\n-                    if ((!t.alignment.isDefault() && t.alignment.get() < target.ptrsize ||\n-                         (vd.offset & (target.ptrsize - 1))))\n-                    {\n-                        if (sc.setUnsafe(false, i.value[j].loc,\n-                            \"field `%s.%s` cannot assign to misaligned pointers in `@safe` code\", sd, vd))\n-                        {\n-                            errors = true;\n-                            elems[fieldi] = ErrorExp.get(); // for better diagnostics on multiple errors\n-                            ++fieldi;\n-                            continue;\n-                        }\n-                    }\n-                }\n-\n-                // Check for overlapping initializations (can happen with unions)\n-                foreach (k, v2; sd.fields[0 .. nfields])\n-                {\n-                    if (vd.isOverlappedWith(v2) && elems[k])\n-                    {\n-                        error(elems[k].loc, \"overlapping initialization for field `%s` and `%s`\", v2.toChars(), vd.toChars());\n-                        errors = true;\n-                        continue;\n-                    }\n-                }\n-\n-                // Convert initializer to Expression `ex`\n-                assert(sc);\n-                auto tm = vd.type.addMod(t.mod);\n-                auto iz = i.value[j].initializerSemantic(sc, tm, needInterpret);\n-                auto ex = iz.initializerToExpression(null, (sc.flags & SCOPE.Cfile) != 0);\n-                if (ex.op == EXP.error)\n-                {\n-                    errors = true;\n-                    elems[fieldi] = ErrorExp.get(); // for better diagnostics on multiple errors\n-                    ++fieldi;\n-                    continue;\n-                }\n \n+        Expression getExp(size_t j, Type fieldType)\n+        {\n+            // Convert initializer to Expression `ex`\n+            auto tm = fieldType.addMod(t.mod);\n+            auto iz = i.value[j].initializerSemantic(sc, tm, needInterpret);\n+            auto ex = iz.initializerToExpression(null, (sc.flags & SCOPE.Cfile) != 0);\n+            if (ex.op != EXP.error)\n                 i.value[j] = iz;\n-                elems[fieldi] = doCopyOrMove(sc, ex);\n-                ++fieldi;\n-            }\n-            if (errors)\n+            return ex;\n+        }\n+            auto elements = resolveStructLiteralNamedArgs(sd, t, sc, i.loc, i.field[], &getExp, (size_t j) => i.value[j].loc);\n+            if (!elements)\n                 return err();\n \n             // Make a StructLiteralExp out of elements[]\n@@ -1514,3 +1422,141 @@ private bool hasNonConstPointers(Expression e)\n     }\n     return false;\n }\n+\n+/**\n+Given the names and values of a `StructInitializer` or `CallExp`,\n+resolve it to a list of expressions to construct a `StructLiteralExp`.\n+\n+Params:\n+    sd = struct\n+    t = type of struct (potentially including qualifiers such as `const` or `immutable`)\n+    sc = scope of the expression initializing the struct\n+    iloc = location of expression initializing the struct\n+    names = identifiers passed in argument list, `null` entries for positional arguments\n+    getExp = function that, given an index into `names` and destination type, returns the initializing expression\n+    getLoc = function that, given an index into `names`, returns a location for error messages\n+\n+Returns: list of expressions ordered to the struct's fields, or `null` on error\n+*/\n+Expressions* resolveStructLiteralNamedArgs(StructDeclaration sd, Type t, Scope* sc,\n+    Loc iloc, Identifier[] names, scope Expression delegate(size_t i, Type fieldType) getExp,\n+    scope Loc delegate(size_t i) getLoc\n+)\n+{\n+    //expandTuples for non-identity arguments?\n+    const nfields = sd.nonHiddenFields();\n+    auto elements = new Expressions(nfields);\n+    auto elems = (*elements)[];\n+    foreach (ref elem; elems)\n+        elem = null;\n+\n+    // Run semantic for explicitly given initializers\n+    // TODO: this part is slightly different from StructLiteralExp::semantic.\n+    bool errors = false;\n+    size_t fieldi = 0;\n+    foreach (j, id; names)\n+    {\n+        const argLoc = getLoc(j);\n+        if (id)\n+        {\n+            // Determine `fieldi` that `id` matches\n+            Dsymbol s = sd.search(iloc, id);\n+            if (!s)\n+            {\n+                s = sd.search_correct(id);\n+                if (s)\n+                    error(argLoc, \"`%s` is not a member of `%s`, did you mean %s `%s`?\", id.toChars(), sd.toChars(), s.kind(), s.toChars());\n+                else\n+                    error(argLoc, \"`%s` is not a member of `%s`\", id.toChars(), sd.toChars());\n+                return null;\n+            }\n+            s.checkDeprecated(iloc, sc);\n+            s = s.toAlias();\n+\n+            // Find out which field index `s` is\n+            for (fieldi = 0; 1; fieldi++)\n+            {\n+                if (fieldi >= nfields)\n+                {\n+                    error(iloc, \"`%s.%s` is not a per-instance initializable field\", sd.toChars(), s.toChars());\n+                    return null;\n+                }\n+                if (s == sd.fields[fieldi])\n+                    break;\n+            }\n+        }\n+        if (nfields == 0)\n+        {\n+            error(argLoc, \"initializer provided for struct `%s` with no fields\", sd.toChars());\n+            return null;\n+        }\n+        if (j >= nfields)\n+        {\n+            error(argLoc, \"too many initializers for `%s` with %d field%s\", sd.toChars(),\n+                cast(int) nfields, nfields != 1 ? \"s\".ptr : \"\".ptr);\n+            return null;\n+        }\n+\n+        VarDeclaration vd = sd.fields[fieldi];\n+        if (elems[fieldi])\n+        {\n+            error(argLoc, \"duplicate initializer for field `%s`\", vd.toChars());\n+            errors = true;\n+            elems[fieldi] = ErrorExp.get(); // for better diagnostics on multiple errors\n+            ++fieldi;\n+            continue;\n+        }\n+\n+        // Check for @safe violations\n+        if (vd.type.hasPointers)\n+        {\n+            if ((!t.alignment.isDefault() && t.alignment.get() < target.ptrsize ||\n+                    (vd.offset & (target.ptrsize - 1))))\n+            {\n+                if (sc.setUnsafe(false, argLoc,\n+                    \"field `%s.%s` cannot assign to misaligned pointers in `@safe` code\", sd, vd))\n+                {\n+                    errors = true;\n+                    elems[fieldi] = ErrorExp.get(); // for better diagnostics on multiple errors\n+                    ++fieldi;\n+                    continue;\n+                }\n+            }\n+        }\n+\n+        // Check for overlapping initializations (can happen with unions)\n+        foreach (k, v2; sd.fields[0 .. nfields])\n+        {\n+            if (vd.isOverlappedWith(v2) && elems[k])\n+            {\n+                error(elems[k].loc, \"overlapping initialization for field `%s` and `%s`\", v2.toChars(), vd.toChars());\n+                enum errorMsg = \"`struct` initializers that contain anonymous unions\" ~\n+                    \" must initialize only the first member of a `union`. All subsequent\" ~\n+                    \" non-overlapping fields are default initialized\";\n+                if (!sd.isUnionDeclaration())\n+                    .errorSupplemental(elems[k].loc, errorMsg);\n+                errors = true;\n+                continue;\n+            }\n+        }\n+\n+        assert(sc);\n+\n+        auto ex = getExp(j, vd.type);\n+\n+        if (ex.op == EXP.error)\n+        {\n+            errors = true;\n+            elems[fieldi] = ErrorExp.get(); // for better diagnostics on multiple errors\n+            ++fieldi;\n+            continue;\n+        }\n+\n+        elems[fieldi] = doCopyOrMove(sc, ex);\n+        ++fieldi;\n+    }\n+    if (errors)\n+        return null;\n+\n+    return elements;\n+}"}, {"sha": "2af7faec354d6c74eedb6896a887cc174ff3548f", "filename": "gcc/d/dmd/json.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fjson.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fjson.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fjson.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -54,7 +54,7 @@ public:\n     int indentLevel;\n     const(char)[] filename;\n \n-    extern (D) this(OutBuffer* buf)\n+    extern (D) this(OutBuffer* buf) scope\n     {\n         this.buf = buf;\n     }"}, {"sha": "885a27af9059588647bed7a88b7c8b9a119a2ca4", "filename": "gcc/d/dmd/lambdacomp.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Flambdacomp.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Flambdacomp.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Flambdacomp.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -120,7 +120,7 @@ public:\n     OutBuffer buf;\n     alias visit = SemanticTimeTransitiveVisitor.visit;\n \n-    this(Scope* sc)\n+    this(Scope* sc) scope\n     {\n         this.sc = sc;\n     }"}, {"sha": "c9ed35ffa6d5015876e8248496f866a8122b4a80", "filename": "gcc/d/dmd/lexer.d", "status": "modified", "additions": 79, "deletions": 74, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Flexer.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Flexer.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Flexer.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -22,8 +22,7 @@ import core.stdc.string;\n import core.stdc.time;\n \n import dmd.entity;\n-import dmd.errors;\n-import dmd.globals;\n+import dmd.errorsink;\n import dmd.id;\n import dmd.identifier;\n import dmd.location;\n@@ -69,6 +68,8 @@ class Lexer\n     ubyte long_doublesize;      /// size of C long double, 8 or D real.sizeof\n     ubyte wchar_tsize;          /// size of C wchar_t, 2 or 4\n \n+    ErrorSink eSink;            /// send error messages through this interface\n+\n     private\n     {\n         const(char)* base;      // pointer to start of buffer\n@@ -103,12 +104,14 @@ class Lexer\n      *  endoffset = the last offset to read into base[]\n      *  doDocComment = handle documentation comments\n      *  commentToken = comments become TOK.comment's\n+     *  errorSink = where error messages go, must not be null\n      *  vendor = name of the vendor\n      *  versionNumber = version of the caller\n      */\n     this(const(char)* filename, const(char)* base, size_t begoffset,\n         size_t endoffset, bool doDocComment, bool commentToken,\n-        const(char)[] vendor = \"DLF\", uint versionNumber = 1) pure\n+        ErrorSink errorSink,\n+        const(char)[] vendor = \"DLF\", uint versionNumber = 1) pure scope\n     {\n         scanloc = Loc(filename, 1, 1);\n         // debug printf(\"Lexer::Lexer(%p)\\n\", base);\n@@ -123,6 +126,8 @@ class Lexer\n         this.tokenizeNewlines = false;\n         this.inTokenStringConstant = 0;\n         this.lastDocLine = 0;\n+        this.eSink = errorSink;\n+        assert(errorSink);\n         this.versionNumber = versionNumber;\n         this.vendor = vendor;\n         //initKeywords();\n@@ -163,16 +168,18 @@ class Lexer\n      * Alternative entry point for DMDLIB, adds `whitespaceToken`\n      */\n     this(const(char)* filename, const(char)* base, size_t begoffset, size_t endoffset,\n-        bool doDocComment, bool commentToken, bool whitespaceToken)\n+        bool doDocComment, bool commentToken, bool whitespaceToken,\n+        ErrorSink errorSink\n+        )\n     {\n-        this(filename, base, begoffset, endoffset, doDocComment, commentToken);\n+        this(filename, base, begoffset, endoffset, doDocComment, commentToken, errorSink);\n         this.whitespaceToken = whitespaceToken;\n     }\n \n     /******************\n      * Used for unittests for a mock Lexer\n      */\n-    this() { }\n+    this(ErrorSink errorSink) scope { assert(errorSink); this.eSink = errorSink; }\n \n     /**************************************\n      * Reset lexer to lex #define's\n@@ -565,7 +572,7 @@ class Lexer\n                     else if (*t.ptr == '_') // if special identifier token\n                     {\n                         // Lazy initialization\n-                        TimeStampInfo.initialize(t.loc);\n+                        TimeStampInfo.initialize(t.loc, eSink);\n \n                         if (id == Id.DATE)\n                         {\n@@ -1616,7 +1623,7 @@ class Lexer\n         else if (isspace(delimright))\n             error(\"delimited string must end in `\\\"`\");\n         else\n-            error(\"delimited string must end in `%c\\\"`\", delimright);\n+            error(token.loc, \"delimited string must end in `%c\\\"`\", delimright);\n         result.setString(stringbuffer);\n         stringPostfix(result);\n     }\n@@ -1909,10 +1916,10 @@ class Lexer\n                 if (idx < n && !msg)\n                     msg = utf_decodeChar(str, idx, d2);\n                 if (msg)\n-                    error(loc, \"%s\", msg);\n+                    error(loc, \"%.*s\", cast(int)msg.length, msg.ptr);\n                 else if (idx < n)\n                     error(loc, \"max number of chars in 16 bit character literal is 2, had %d\",\n-                        (n + 1) >> 1);\n+                        cast(int)((n + 1) >> 1));\n                 else if (d1 > 0x1_0000)\n                     error(loc, \"%d does not fit in 16 bits\", d1);\n                 else if (d2 > 0x1_0000)\n@@ -1927,10 +1934,10 @@ class Lexer\n                 size_t idx;\n                 auto msg = utf_decodeChar(str, idx, d);\n                 if (msg)\n-                    error(loc, \"%s\", msg);\n+                    error(loc, \"%.*s\", cast(int)msg.length, msg.ptr);\n                 else if (idx < n)\n                     error(loc, \"max number of chars in 32 bit character literal is 1, had %d\",\n-                        (n + 3) >> 2);\n+                        cast(int)((n + 3) >> 2));\n                 u = d;\n                 break;\n \n@@ -2137,7 +2144,7 @@ class Lexer\n     Ldone:\n         if (errorDigit)\n         {\n-            error(\"%s digit expected, not `%c`\", base == 2 ? \"binary\".ptr :\n+            error(token.loc, \"%s digit expected, not `%c`\", base == 2 ? \"binary\".ptr :\n                                                  base == 8 ? \"octal\".ptr :\n                                                  \"decimal\".ptr, errorDigit);\n             err = true;\n@@ -2149,7 +2156,7 @@ class Lexer\n         }\n         if ((base == 2 && !anyBinaryDigitsNoSingleUS) ||\n             (base == 16 && !anyHexDigitsNoSingleUS))\n-            error(\"`%.*s` isn't a valid integer literal, use `%.*s0` instead\", cast(int)(p - start), start, 2, start);\n+            error(token.loc, \"`%.*s` isn't a valid integer literal, use `%.*s0` instead\", cast(int)(p - start), start, 2, start);\n \n         t.unsvalue = n;\n \n@@ -2202,7 +2209,7 @@ class Lexer\n                 // can't translate invalid octal value, just show a generic message\n                 error(\"octal literals larger than 7 are no longer supported\");\n             else\n-                error(\"octal literals `0%llo%.*s` are no longer supported, use `std.conv.octal!\\\"%llo%.*s\\\"` instead\",\n+                error(token.loc, \"octal literals `0%llo%.*s` are no longer supported, use `std.conv.octal!\\\"%llo%.*s\\\"` instead\",\n                     n, cast(int)(p - psuffix), psuffix, n, cast(int)(p - psuffix), psuffix);\n         }\n         TOK result;\n@@ -2619,7 +2626,7 @@ class Lexer\n                                 TOK.float80Literal: \"`real` for the current target\".ptr][result];\n             error(scanloc, \"number `%s%s` is not representable as a %s\", sbufptr, suffix, type);\n             const char* extra = result == TOK.float64Literal ? \"`real` literals can be written using the `L` suffix. \" : \"\";\n-            errorSupplemental(scanloc, \"%shttps://dlang.org/spec/lex.html#floatliteral\", extra);\n+            eSink.errorSupplemental(scanloc, \"%shttps://dlang.org/spec/lex.html#floatliteral\", extra);\n         }\n         debug\n         {\n@@ -2647,28 +2654,24 @@ class Lexer\n         return scanloc;\n     }\n \n-    final void error(const(char)* format, ...)\n+    void error(T...)(const(char)* format, T args)\n+    {\n+        eSink.error(token.loc, format, args);\n+    }\n+\n+    void error(T...)(const ref Loc loc, const(char)* format, T args)\n     {\n-        va_list args;\n-        va_start(args, format);\n-        .verror(token.loc, format, args);\n-        va_end(args);\n+        eSink.error(loc, format, args);\n     }\n \n-    final void error(const ref Loc loc, const(char)* format, ...)\n+    final void deprecation(const(char)* format)\n     {\n-        va_list args;\n-        va_start(args, format);\n-        .verror(loc, format, args);\n-        va_end(args);\n+        eSink.deprecation(token.loc, format);\n     }\n \n-    final void deprecation(const(char)* format, ...)\n+    final void deprecationSupplemental(const(char)* format)\n     {\n-        va_list args;\n-        va_start(args, format);\n-        .vdeprecation(token.loc, format, args);\n-        va_end(args);\n+        eSink.deprecationSupplemental(token.loc, format);\n     }\n \n     /***************************************\n@@ -2692,7 +2695,7 @@ class Lexer\n             else\n             {\n                 const locx = loc();\n-                warning(locx, \"C preprocessor directive `#%s` is not supported\", n.ident.toChars());\n+                eSink.warning(locx, \"C preprocessor directive `#%s` is not supported\", n.ident.toChars());\n             }\n         }\n         else if (n.value == TOK.if_)\n@@ -2853,7 +2856,7 @@ class Lexer\n         auto result = decodeUTFpure(msg);\n \n         if (msg)\n-            error(\"%.*s\", cast(int)msg.length, msg.ptr);\n+            error(token.loc, \"%.*s\", cast(int)msg.length, msg.ptr);\n         return result;\n     }\n \n@@ -3077,7 +3080,7 @@ private struct TimeStampInfo\n     __gshared char[8 + 1] time;\n     __gshared char[24 + 1] timestamp;\n \n-    public static void initialize(const ref Loc loc) nothrow\n+    public static void initialize(const ref Loc loc, ErrorSink eSink) nothrow\n     {\n         if (initdone)\n             return;\n@@ -3088,15 +3091,15 @@ private struct TimeStampInfo\n         if (auto p = getenv(\"SOURCE_DATE_EPOCH\"))\n         {\n             if (!ct.parseDigits(p.toDString()))\n-                error(loc, \"value of environment variable `SOURCE_DATE_EPOCH` should be a valid UNIX timestamp, not: `%s`\", p);\n+                eSink.error(loc, \"value of environment variable `SOURCE_DATE_EPOCH` should be a valid UNIX timestamp, not: `%s`\", p);\n         }\n         else\n             .time(&ct);\n         const p = ctime(&ct);\n         assert(p);\n-        sprintf(&date[0], \"%.6s %.4s\", p + 4, p + 20);\n-        sprintf(&time[0], \"%.8s\", p + 11);\n-        sprintf(&timestamp[0], \"%.24s\", p);\n+        snprintf(&date[0], date.length, \"%.6s %.4s\", p + 4, p + 20);\n+        snprintf(&time[0], time.length, \"%.8s\", p + 11);\n+        snprintf(&timestamp[0], timestamp.length, \"%.24s\", p);\n     }\n }\n \n@@ -3217,19 +3220,15 @@ private bool c_isalnum(const int c) pure @nogc @safe\n \n unittest\n {\n-    import dmd.console;\n-    nothrow bool assertDiagnosticHandler(const ref Loc loc, Color headerColor, const(char)* header,\n-                                   const(char)* format, va_list ap, const(char)* p1, const(char)* p2)\n-    {\n-        assert(0);\n-    }\n-    diagnosticHandler = &assertDiagnosticHandler;\n+    fprintf(stderr, \"Lexer.unittest %d\\n\", __LINE__);\n+\n+    ErrorSink errorSink = new ErrorSinkStderr;\n \n-    static void test(T)(string sequence, T expected, bool Ccompile = false)\n+    void test(T)(string sequence, T expected, bool Ccompile = false)\n     {\n         auto p = cast(const(char)*)sequence.ptr;\n         dchar c2;\n-        Lexer lexer = new Lexer();\n+        Lexer lexer = new Lexer(errorSink);\n         assert(expected == lexer.escapeSequence(Loc.initial, p, Ccompile, c2));\n         assert(p == sequence.ptr + sequence.length);\n     }\n@@ -3266,45 +3265,51 @@ unittest\n     test(`&quot;`, '\"');\n     test(`&lt;`, '<');\n     test(`&gt;`, '>');\n-\n-    diagnosticHandler = null;\n }\n \n unittest\n {\n-    import dmd.console;\n-    string expected;\n-    bool gotError;\n+    fprintf(stderr, \"Lexer.unittest %d\\n\", __LINE__);\n \n-    nothrow bool expectDiagnosticHandler(const ref Loc loc, Color headerColor, const(char)* header,\n-                                         const(char)* format, va_list ap, const(char)* p1, const(char)* p2)\n+    static class ErrorSinkTest : ErrorSinkNull\n     {\n-        assert(cast(Classification)headerColor == Classification.error);\n+      nothrow:\n+      extern (C++):\n+      override:\n+\n+        import core.stdc.stdio;\n+        import core.stdc.stdarg;\n \n-        gotError = true;\n-        char[100] buffer = void;\n-        auto actual = buffer[0 .. vsprintf(buffer.ptr, format, ap)];\n-        assert(expected == actual);\n-        return true;\n+        string expected;\n+        bool gotError;\n+\n+        void error(const ref Loc loc, const(char)* format, ...)\n+        {\n+            gotError = true;\n+            char[100] buffer = void;\n+            va_list ap;\n+            va_start(ap, format);\n+            auto actual = buffer[0 .. vsnprintf(buffer.ptr, buffer.length, format, ap)];\n+            va_end(ap);\n+            assert(expected == actual);\n+        }\n     }\n \n-    diagnosticHandler = &expectDiagnosticHandler;\n+    ErrorSinkTest errorSink = new ErrorSinkTest;\n \n     void test(string sequence, string expectedError, dchar expectedReturnValue, uint expectedScanLength, bool Ccompile = false)\n     {\n-        uint errors = global.errors;\n-        gotError = false;\n-        expected = expectedError;\n+        errorSink.expected = expectedError;\n+        errorSink.gotError = false;\n         auto p = cast(const(char)*)sequence.ptr;\n-        Lexer lexer = new Lexer();\n+        Lexer lexer = new Lexer(errorSink);\n         dchar c2;\n         auto actualReturnValue = lexer.escapeSequence(Loc.initial, p, Ccompile, c2);\n-        assert(gotError);\n+        assert(errorSink.gotError);\n         assert(expectedReturnValue == actualReturnValue);\n \n         auto actualScanLength = p - sequence.ptr;\n         assert(expectedScanLength == actualScanLength);\n-        global.errors = errors;\n     }\n \n     test(\"c\", `undefined escape sequence \\c`, 'c', 1);\n@@ -3338,17 +3343,16 @@ unittest\n     test(\"&quot\", `unterminated named entity &quot;`, '?', 5);\n \n     test(\"400\", `escape octal sequence \\400 is larger than \\377`, 0x100, 3);\n-\n-    diagnosticHandler = null;\n }\n \n unittest\n {\n-    //printf(\"lexer.unittest\\n\");\n+    fprintf(stderr, \"Lexer.unittest %d\\n\", __LINE__);\n     /* Not much here, just trying things out.\n      */\n     string text = \"int\"; // We rely on the implicit null-terminator\n-    scope Lexer lex1 = new Lexer(null, text.ptr, 0, text.length, 0, 0);\n+    ErrorSink errorSink = new ErrorSinkStderr;\n+    scope Lexer lex1 = new Lexer(null, text.ptr, 0, text.length, false, false, errorSink);\n     TOK tok;\n     tok = lex1.nextToken();\n     //printf(\"tok == %s, %d, %d\\n\", Token::toChars(tok), tok, TOK.int32);\n@@ -3363,9 +3367,10 @@ unittest\n \n unittest\n {\n+    fprintf(stderr, \"Lexer.unittest %d\\n\", __LINE__);\n+\n     // We don't want to see Lexer error output during these tests.\n-    uint errors = global.startGagging();\n-    scope(exit) global.endGagging(errors);\n+    ErrorSink errorSink = new ErrorSinkNull;\n \n     // Test malformed input: even malformed input should end in a TOK.endOfFile.\n     static immutable char[][] testcases =\n@@ -3383,7 +3388,7 @@ unittest\n \n     foreach (testcase; testcases)\n     {\n-        scope Lexer lex2 = new Lexer(null, testcase.ptr, 0, testcase.length-1, 0, 0);\n+        scope Lexer lex2 = new Lexer(null, testcase.ptr, 0, testcase.length-1, false, false, errorSink);\n         TOK tok = lex2.nextToken();\n         size_t iterations = 1;\n         while ((tok != TOK.endOfFile) && (iterations++ < testcase.length))"}, {"sha": "002bb1a875b8d2f4e8e85d4059f03d4ddbea1408", "filename": "gcc/d/dmd/module.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fmodule.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fmodule.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmodule.h?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -170,3 +170,5 @@ struct ModuleDeclaration\n \n     const char *toChars() const;\n };\n+\n+extern void getLocalClasses(Module* mod, Array<ClassDeclaration* >& aclasses);"}, {"sha": "5939db5ba854e4c9d60e8dcac189b894e3a31674", "filename": "gcc/d/dmd/mtype.d", "status": "modified", "additions": 169, "deletions": 23, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fmtype.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fmtype.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -456,7 +456,7 @@ extern (C++) abstract class Type : ASTNode\n             return sizeTy;\n         }();\n \n-    final extern (D) this(TY ty)\n+    final extern (D) this(TY ty) scope\n     {\n         this.ty = ty;\n     }\n@@ -2046,7 +2046,7 @@ extern (C++) abstract class Type : ASTNode\n         }\n         if (auto fd = s.isFuncDeclaration())\n         {\n-            fd = resolveFuncCall(Loc.initial, null, fd, null, this, null, FuncResolveFlag.quiet);\n+            fd = resolveFuncCall(Loc.initial, null, fd, null, this, ArgumentList(), FuncResolveFlag.quiet);\n             if (!fd || fd.errors || !fd.functionSemantic())\n                 return Type.terror;\n \n@@ -2068,7 +2068,7 @@ extern (C++) abstract class Type : ASTNode\n         if (auto td = s.isTemplateDeclaration())\n         {\n             assert(td._scope);\n-            auto fd = resolveFuncCall(Loc.initial, null, td, null, this, null, FuncResolveFlag.quiet);\n+            auto fd = resolveFuncCall(Loc.initial, null, td, null, this, ArgumentList(), FuncResolveFlag.quiet);\n             if (!fd || fd.errors || !fd.functionSemantic())\n                 return Type.terror;\n \n@@ -2447,7 +2447,7 @@ extern (C++) abstract class Type : ASTNode\n         const namelen = 19 + size_t.sizeof * 3 + slice.length + 1;\n         auto name = namelen <= namebuf.length ? namebuf.ptr : cast(char*)Mem.check(malloc(namelen));\n \n-        const length = sprintf(name, \"_D%lluTypeInfo_%.*s6__initZ\",\n+        const length = snprintf(name, namelen, \"_D%lluTypeInfo_%.*s6__initZ\",\n                 cast(ulong)(9 + slice.length), cast(int)slice.length, slice.ptr);\n         //printf(\"%p %s, deco = %s, name = %s\\n\", this, toChars(), deco, name);\n         assert(0 < length && length < namelen); // don't overflow the buffer\n@@ -3120,7 +3120,7 @@ extern (C++) final class TypeBasic : Type\n     const(char)* dstring;\n     uint flags;\n \n-    extern (D) this(TY ty)\n+    extern (D) this(TY ty) scope\n     {\n         super(ty);\n         const(char)* d;\n@@ -4626,14 +4626,14 @@ extern (C++) final class TypeFunction : TypeNext\n      * Determine match level.\n      * Params:\n      *      tthis = type of `this` pointer, null if not member function\n-     *      args = array of function arguments\n+     *      argumentList = arguments to function call\n      *      flag = 1: performing a partial ordering match\n      *      pMessage = address to store error message, or null\n      *      sc = context\n      * Returns:\n      *      MATCHxxxx\n      */\n-    extern (D) MATCH callMatch(Type tthis, Expression[] args, int flag = 0, const(char)** pMessage = null, Scope* sc = null)\n+    extern (D) MATCH callMatch(Type tthis, ArgumentList argumentList, int flag = 0, const(char)** pMessage = null, Scope* sc = null)\n     {\n         //printf(\"TypeFunction::callMatch() %s\\n\", toChars());\n         MATCH match = MATCH.exact; // assume exact match\n@@ -4669,8 +4669,7 @@ extern (C++) final class TypeFunction : TypeNext\n         }\n \n         const nparams = parameterList.length;\n-        const nargs = args.length;\n-        if (nargs > nparams)\n+        if (argumentList.length > nparams)\n         {\n             if (parameterList.varargs == VarArg.none)\n             {\n@@ -4684,22 +4683,39 @@ extern (C++) final class TypeFunction : TypeNext\n         }\n \n         // https://issues.dlang.org/show_bug.cgi?id=22997\n-        if (parameterList.varargs == VarArg.none && nparams > nargs && !parameterList[nargs].defaultArg)\n+        if (parameterList.varargs == VarArg.none && nparams > argumentList.length && !parameterList.hasDefaultArgs)\n         {\n             OutBuffer buf;\n-            buf.printf(\"too few arguments, expected %d, got %d\", cast(int)nparams, cast(int)nargs);\n+            buf.printf(\"too few arguments, expected %d, got %d\", cast(int)nparams, cast(int)argumentList.length);\n             if (pMessage)\n                 *pMessage = buf.extractChars();\n             return MATCH.nomatch;\n         }\n+        auto resolvedArgs = resolveNamedArgs(argumentList, pMessage);\n+        Expression[] args;\n+        if (!resolvedArgs)\n+        {\n+            if (!pMessage || *pMessage)\n+                return MATCH.nomatch;\n+\n+            // if no message was provided, it was because of overflow which will be diagnosed below\n+            match = MATCH.nomatch;\n+            args = argumentList.arguments ? (*argumentList.arguments)[] : null;\n+        }\n+        else\n+        {\n+            args = (*resolvedArgs)[];\n+        }\n \n         foreach (u, p; parameterList)\n         {\n-            if (u == nargs)\n+            if (u >= args.length)\n                 break;\n \n             Expression arg = args[u];\n-            assert(arg);\n+            if (!arg)\n+                continue; // default argument\n+\n             Type tprm = p.type;\n             Type targ = arg.type;\n \n@@ -4733,10 +4749,11 @@ extern (C++) final class TypeFunction : TypeNext\n             assert(p);\n \n             // One or more arguments remain\n-            if (u < nargs)\n+            if (u < args.length)\n             {\n                 Expression arg = args[u];\n-                assert(arg);\n+                if (!arg)\n+                    continue; // default argument\n                 m = argumentMatchParameter(this, p, arg, wildmatch, flag, sc, pMessage);\n             }\n             else if (p.defaultArg)\n@@ -4745,7 +4762,7 @@ extern (C++) final class TypeFunction : TypeNext\n             /* prefer matching the element type rather than the array\n              * type when more arguments are present with T[]...\n              */\n-            if (parameterList.varargs == VarArg.typesafe && u + 1 == nparams && nargs > nparams)\n+            if (parameterList.varargs == VarArg.typesafe && u + 1 == nparams && args.length > nparams)\n                 goto L1;\n \n             //printf(\"\\tm = %d\\n\", m);\n@@ -4760,7 +4777,7 @@ extern (C++) final class TypeFunction : TypeNext\n                     // Error message was already generated in `matchTypeSafeVarArgs`\n                     return MATCH.nomatch;\n                 }\n-                if (pMessage && u >= nargs)\n+                if (pMessage && u >= args.length)\n                     *pMessage = getMatchError(\"missing argument for parameter #%d: `%s`\",\n                         u + 1, parameterToChars(p, this, false));\n                 // If an error happened previously, `pMessage` was already filled\n@@ -4773,16 +4790,97 @@ extern (C++) final class TypeFunction : TypeNext\n                 match = m; // pick worst match\n         }\n \n-        if (pMessage && !parameterList.varargs && nargs > nparams)\n+        if (pMessage && !parameterList.varargs && args.length > nparams)\n         {\n             // all parameters had a match, but there are surplus args\n-            *pMessage = getMatchError(\"expected %d argument(s), not %d\", nparams, nargs);\n+            *pMessage = getMatchError(\"expected %d argument(s), not %d\", nparams, args.length);\n             return MATCH.nomatch;\n         }\n         //printf(\"match = %d\\n\", match);\n         return match;\n     }\n \n+    /********************************\n+     * Convert an `argumentList`, which may contain named arguments, into\n+     * a list of arguments in the order of the parameter list.\n+     *\n+     * Params:\n+     *      argumentList = array of function arguments\n+     *      pMessage = address to store error message, or `null`\n+     * Returns: re-ordered argument list, or `null` on error\n+     */\n+    extern(D) Expressions* resolveNamedArgs(ArgumentList argumentList, const(char)** pMessage)\n+    {\n+        Expression[] args = argumentList.arguments ? (*argumentList.arguments)[] : null;\n+        Identifier[] names = argumentList.names ? (*argumentList.names)[] : null;\n+        auto newArgs = new Expressions(parameterList.length);\n+        newArgs.zero();\n+        size_t ci = 0;\n+        bool hasNamedArgs = false;\n+        foreach (i, arg; args)\n+        {\n+            if (!arg)\n+            {\n+                ci++;\n+                continue;\n+            }\n+            auto name = i < names.length ? names[i] : null;\n+            if (name)\n+            {\n+                hasNamedArgs = true;\n+                const pi = findParameterIndex(name);\n+                if (pi == -1)\n+                {\n+                    if (pMessage)\n+                        *pMessage = getMatchError(\"no parameter named `%s`\", name.toChars());\n+                    return null;\n+                }\n+                ci = pi;\n+            }\n+            if (ci >= newArgs.length)\n+            {\n+                if (!parameterList.varargs)\n+                {\n+                    // Without named args, let the caller diagnose argument overflow\n+                    if (hasNamedArgs && pMessage)\n+                        *pMessage = getMatchError(\"argument `%s` goes past end of parameter list\", arg.toChars());\n+                    return null;\n+                }\n+                while (ci >= newArgs.length)\n+                    newArgs.push(null);\n+            }\n+\n+            if ((*newArgs)[ci])\n+            {\n+                if (pMessage)\n+                    *pMessage = getMatchError(\"parameter `%s` assigned twice\", parameterList[ci].toChars());\n+                return null;\n+            }\n+            (*newArgs)[ci++] = arg;\n+        }\n+        foreach (i, arg; (*newArgs)[])\n+        {\n+            if (arg || parameterList[i].defaultArg)\n+                continue;\n+\n+            if (parameterList.varargs != VarArg.none && i + 1 == newArgs.length)\n+                continue;\n+\n+            if (pMessage)\n+                *pMessage = getMatchError(\"missing argument for parameter #%d: `%s`\",\n+                    i + 1, parameterToChars(parameterList[i], this, false));\n+            return null;\n+        }\n+        // strip trailing nulls from default arguments\n+        size_t e = newArgs.length;\n+        while (e > 0 && (*newArgs)[e - 1] is null)\n+        {\n+            --e;\n+        }\n+        newArgs.setDim(e);\n+        return newArgs;\n+    }\n+\n     /+\n      + Checks whether this function type is convertible to ` to`\n      + when used in a function pointer / delegate.\n@@ -4871,9 +4969,18 @@ extern (C++) final class TypeFunction : TypeNext\n     }\n \n     /// Returns: whether `this` function type has the same attributes (`@safe`,...) as `other`\n-    bool attributesEqual(const scope TypeFunction other) const pure nothrow @safe @nogc\n-    {\n-        return this.trust == other.trust &&\n+    extern (D) bool attributesEqual(const scope TypeFunction other, bool trustSystemEqualsDefault = true) const pure nothrow @safe @nogc\n+    {\n+        // @@@DEPRECATED_2.112@@@\n+        // See semantic2.d Semantic2Visitor.visit(FuncDeclaration):\n+        // Two overloads that are identical except for one having an explicit `@system`\n+        // attribute is currently in deprecation, and will become an error in 2.104 for\n+        // `extern(C)`, and 2.112 for `extern(D)` code respectively. Once the deprecation\n+        // period has passed, the trustSystemEqualsDefault=true behaviour should be made\n+        // the default, then we can remove the `cannot overload extern(...) function`\n+        // errors as they will become dead code as a result.\n+        return (this.trust == other.trust ||\n+                (trustSystemEqualsDefault && this.trust <= TRUST.system && other.trust <= TRUST.system)) &&\n                 this.purity == other.purity &&\n                 this.isnothrow == other.isnothrow &&\n                 this.isnogc == other.isnogc &&\n@@ -4884,6 +4991,23 @@ extern (C++) final class TypeFunction : TypeNext\n     {\n         v.visit(this);\n     }\n+\n+    /**\n+     * Look for the index of parameter `ident` in the parameter list\n+     *\n+     * Params:\n+     *   ident = identifier of parameter to search for\n+     * Returns: index of parameter with name `ident` or -1 if not found\n+     */\n+    private extern(D) ptrdiff_t findParameterIndex(Identifier ident)\n+    {\n+        foreach (i, p; this.parameterList)\n+        {\n+            if (p.ident == ident)\n+                return i;\n+        }\n+        return -1;\n+    }\n }\n \n /***********************************************************\n@@ -6507,6 +6631,28 @@ extern (C++) struct ParameterList\n         // Ensure no remaining parameters in `other`\n         return !diff && other[idx] is null;\n     }\n+\n+    /// Returns: `true` if any parameter has a default argument\n+    extern(D) bool hasDefaultArgs()\n+    {\n+        foreach (oidx, oparam, eidx, eparam; this)\n+        {\n+            if (eparam.defaultArg)\n+                return true;\n+        }\n+        return false;\n+    }\n+\n+    // Returns: `true` if any parameter doesn't have a default argument\n+    extern(D) bool hasArgsWithoutDefault()\n+    {\n+        foreach (oidx, oparam, eidx, eparam; this)\n+        {\n+            if (!eparam.defaultArg)\n+                return true;\n+        }\n+        return false;\n+    }\n }\n \n \n@@ -6975,7 +7121,7 @@ bool isCopyable(Type t)\n             el.type = cast() ts;\n             Expressions args;\n             args.push(el);\n-            FuncDeclaration f = resolveFuncCall(Loc.initial, null, ctor, null, cast()ts, &args, FuncResolveFlag.quiet);\n+            FuncDeclaration f = resolveFuncCall(Loc.initial, null, ctor, null, cast()ts, ArgumentList(&args), FuncResolveFlag.quiet);\n             if (!f || f.storage_class & STC.disable)\n                 return false;\n         }"}, {"sha": "201f168527cb71c92c9a2686e91c9a7c934abc97", "filename": "gcc/d/dmd/nogc.d", "status": "modified", "additions": 64, "deletions": 51, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fnogc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fnogc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fnogc.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -13,11 +13,14 @@\n \n module dmd.nogc;\n \n+import core.stdc.stdio;\n+\n import dmd.aggregate;\n import dmd.apply;\n import dmd.astenums;\n import dmd.declaration;\n import dmd.dscope;\n+import dmd.errors;\n import dmd.expression;\n import dmd.func;\n import dmd.globals;\n@@ -34,9 +37,10 @@ extern (C++) final class NOGCVisitor : StoppableVisitor\n     alias visit = typeof(super).visit;\n public:\n     FuncDeclaration f;\n+    bool checkOnly;     // don't print errors\n     bool err;\n \n-    extern (D) this(FuncDeclaration f)\n+    extern (D) this(FuncDeclaration f) scope\n     {\n         this.f = f;\n     }\n@@ -64,6 +68,30 @@ public:\n         }\n     }\n \n+    /**\n+     * Register that expression `e` requires the GC\n+     * Params:\n+     *   e = expression that uses GC\n+     *   format = error message when `e` is used in a `@nogc` function.\n+     *            Must contain format strings \"`@nogc` %s `%s`\" referring to the function.\n+     * Returns: `true` if `err` was set, `false` if it's not in a `@nogc` and not checkonly (-betterC)\n+     */\n+    private bool setGC(Expression e, const(char)* format)\n+    {\n+        if (checkOnly)\n+        {\n+            err = true;\n+            return true;\n+        }\n+        if (f.setGC())\n+        {\n+            e.error(format, f.kind(), f.toPrettyChars());\n+            err = true;\n+            return true;\n+        }\n+        return false;\n+    }\n+\n     override void visit(CallExp e)\n     {\n         import dmd.id : Id;\n@@ -75,24 +103,14 @@ public:\n         auto fd = stripHookTraceImpl(e.f);\n         if (fd.ident == Id._d_arraysetlengthT)\n         {\n-            if (f.setGC())\n-            {\n-                e.error(\"setting `length` in `@nogc` %s `%s` may cause a GC allocation\",\n-                    f.kind(), f.toPrettyChars());\n-                err = true;\n+            if (setGC(e, \"setting `length` in `@nogc` %s `%s` may cause a GC allocation\"))\n                 return;\n-            }\n             f.printGCUsage(e.loc, \"setting `length` may cause a GC allocation\");\n         }\n         else if (fd.ident == Id._d_arrayappendT || fd.ident == Id._d_arrayappendcTX)\n         {\n-            if (f.setGC())\n-            {\n-                e.error(\"cannot use operator `~=` in `@nogc` %s `%s`\",\n-                    f.kind(), f.toPrettyChars());\n-                err = true;\n+            if (setGC(e, \"cannot use operator `~=` in `@nogc` %s `%s`\"))\n                 return;\n-            }\n             f.printGCUsage(e.loc, \"operator `~=` may cause a GC allocation\");\n         }\n     }\n@@ -101,27 +119,17 @@ public:\n     {\n         if (e.type.ty != Tarray || !e.elements || !e.elements.length || e.onstack)\n             return;\n-        if (f.setGC())\n-        {\n-            e.error(\"array literal in `@nogc` %s `%s` may cause a GC allocation\",\n-                f.kind(), f.toPrettyChars());\n-            err = true;\n+        if (setGC(e, \"array literal in `@nogc` %s `%s` may cause a GC allocation\"))\n             return;\n-        }\n         f.printGCUsage(e.loc, \"array literal may cause a GC allocation\");\n     }\n \n     override void visit(AssocArrayLiteralExp e)\n     {\n         if (!e.keys.length)\n             return;\n-        if (f.setGC())\n-        {\n-            e.error(\"associative array literal in `@nogc` %s `%s` may cause a GC allocation\",\n-                f.kind(), f.toPrettyChars());\n-            err = true;\n+        if (setGC(e, \"associative array literal in `@nogc` %s `%s` may cause a GC allocation\"))\n             return;\n-        }\n         f.printGCUsage(e.loc, \"associative array literal may cause a GC allocation\");\n     }\n \n@@ -136,13 +144,9 @@ public:\n             return;\n         if (global.params.ehnogc && e.thrownew)\n             return;                     // separate allocator is called for this, not the GC\n-        if (f.setGC())\n-        {\n-            e.error(\"cannot use `new` in `@nogc` %s `%s`\",\n-                f.kind(), f.toPrettyChars());\n-            err = true;\n+\n+        if (setGC(e, \"cannot use `new` in `@nogc` %s `%s`\"))\n             return;\n-        }\n         f.printGCUsage(e.loc, \"`new` causes a GC allocation\");\n     }\n \n@@ -164,13 +168,8 @@ public:\n         Type t1b = e.e1.type.toBasetype();\n         if (e.modifiable && t1b.ty == Taarray)\n         {\n-            if (f.setGC())\n-            {\n-                e.error(\"assigning an associative array element in `@nogc` %s `%s` may cause a GC allocation\",\n-                    f.kind(), f.toPrettyChars());\n-                err = true;\n+            if (setGC(e, \"assigning an associative array element in `@nogc` %s `%s` may cause a GC allocation\"))\n                 return;\n-            }\n             f.printGCUsage(e.loc, \"assigning an associative array element may cause a GC allocation\");\n         }\n     }\n@@ -179,13 +178,8 @@ public:\n     {\n         if (e.e1.op == EXP.arrayLength)\n         {\n-            if (f.setGC())\n-            {\n-                e.error(\"setting `length` in `@nogc` %s `%s` may cause a GC allocation\",\n-                    f.kind(), f.toPrettyChars());\n-                err = true;\n+            if (setGC(e, \"setting `length` in `@nogc` %s `%s` may cause a GC allocation\"))\n                 return;\n-            }\n             f.printGCUsage(e.loc, \"setting `length` may cause a GC allocation\");\n         }\n     }\n@@ -196,6 +190,11 @@ public:\n          * The other branch will be `_d_arrayappendcTX(e1, 1), e1[$-1]=e2` which will generate the warning about\n          * GC usage. See visit(CallExp).\n          */\n+        if (checkOnly)\n+        {\n+            err = true;\n+            return;\n+        }\n         if (f.setGC())\n         {\n             err = true;\n@@ -205,29 +204,43 @@ public:\n \n     override void visit(CatExp e)\n     {\n-        if (f.setGC())\n-        {\n-            e.error(\"cannot use operator `~` in `@nogc` %s `%s`\",\n-                f.kind(), f.toPrettyChars());\n-            err = true;\n+        if (setGC(e, \"cannot use operator `~` in `@nogc` %s `%s`\"))\n             return;\n-        }\n         f.printGCUsage(e.loc, \"operator `~` may cause a GC allocation\");\n     }\n }\n \n Expression checkGC(Scope* sc, Expression e)\n {\n+    if (sc.flags & SCOPE.ctfeBlock)     // ignore GC in ctfe blocks\n+        return e;\n+\n+    /* If betterC, allow GC to happen in non-CTFE code.\n+     * Just don't generate code for it.\n+     * Detect non-CTFE use of the GC in betterC code.\n+     */\n+    const betterC = global.params.betterC;\n     FuncDeclaration f = sc.func;\n-    if (e && e.op != EXP.error && f && sc.intypeof != 1 && !(sc.flags & SCOPE.ctfe) &&\n+    if (e && e.op != EXP.error && f && sc.intypeof != 1 &&\n+           (!(sc.flags & SCOPE.ctfe) || betterC) &&\n            (f.type.ty == Tfunction &&\n             (cast(TypeFunction)f.type).isnogc || f.nogcInprocess || global.params.vgc) &&\n            !(sc.flags & SCOPE.debug_))\n     {\n         scope NOGCVisitor gcv = new NOGCVisitor(f);\n+        gcv.checkOnly = betterC;\n         walkPostorder(e, gcv);\n         if (gcv.err)\n-            return ErrorExp.get();\n+        {\n+            if (betterC)\n+            {\n+                /* Allow ctfe to use the gc code, but don't let it into the runtime\n+                 */\n+                f.skipCodegen = true;\n+            }\n+            else\n+                return ErrorExp.get();\n+        }\n     }\n     return e;\n }"}, {"sha": "9cff76b84aa2fe8930af04ebd20cf165b4dff7a9", "filename": "gcc/d/dmd/ob.d", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fob.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fob.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fob.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -115,7 +115,7 @@ struct ObNode\n     PtrVarState[] input;  /// variable states on entry to exp\n     PtrVarState[] output; /// variable states on exit to exp\n \n-    this(ObNode* tryBlock)\n+    this(ObNode* tryBlock) scope\n     {\n         this.tryBlock = tryBlock;\n     }\n@@ -1353,7 +1353,7 @@ void genKill(ref ObState obstate, ObNode* ob)\n \n             extern (D) this(void delegate(ObNode*, VarDeclaration, Expression, bool) dgWriteVar,\n                             void delegate(const ref Loc loc, ObNode* ob, VarDeclaration v, bool mutable) dgReadVar,\n-                            ObNode* ob, ref ObState obstate)\n+                            ObNode* ob, ref ObState obstate) scope\n             {\n                 this.dgWriteVar = dgWriteVar;\n                 this.dgReadVar  = dgReadVar;\n@@ -2058,7 +2058,7 @@ void checkObErrors(ref ObState obstate)\n \n             extern (D) this(void delegate(const ref Loc loc, ObNode* ob, VarDeclaration v, bool mutable, PtrVarState[]) dgReadVar,\n                             void delegate(ObNode*, PtrVarState[], VarDeclaration, Expression) dgWriteVar,\n-                            PtrVarState[] cpvs, ObNode* ob, ref ObState obstate)\n+                            PtrVarState[] cpvs, ObNode* ob, ref ObState obstate) scope\n             {\n                 this.dgReadVar  = dgReadVar;\n                 this.dgWriteVar = dgWriteVar;\n@@ -2569,7 +2569,7 @@ void checkObErrors(ref ObState obstate)\n                 {\n                     auto v = obstate.vars[i];\n                     if (v.type.hasPointers())\n-                        v.error(v.loc, \"is left dangling at return\");\n+                        v.error(v.loc, \"is not disposed of before return\");\n                 }\n             }\n         }"}, {"sha": "3c80e5e1d0e749375d6f7333b23e289a36cd7b60", "filename": "gcc/d/dmd/opover.d", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fopover.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fopover.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fopover.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -711,7 +711,7 @@ Expression op_overload(Expression e, Scope* sc, EXP* pop = null)\n                 MatchAccumulator m;\n                 if (s)\n                 {\n-                    functionResolve(m, s, e.loc, sc, tiargs, e.e1.type, &args2);\n+                    functionResolve(m, s, e.loc, sc, tiargs, e.e1.type, ArgumentList(&args2));\n                     if (m.lastf && (m.lastf.errors || m.lastf.hasSemantic3Errors()))\n                     {\n                         return ErrorExp.get();\n@@ -720,7 +720,7 @@ Expression op_overload(Expression e, Scope* sc, EXP* pop = null)\n                 FuncDeclaration lastf = m.lastf;\n                 if (s_r)\n                 {\n-                    functionResolve(m, s_r, e.loc, sc, tiargs, e.e2.type, &args1);\n+                    functionResolve(m, s_r, e.loc, sc, tiargs, e.e2.type, ArgumentList(&args1));\n                     if (m.lastf && (m.lastf.errors || m.lastf.hasSemantic3Errors()))\n                     {\n                         return ErrorExp.get();\n@@ -793,7 +793,7 @@ Expression op_overload(Expression e, Scope* sc, EXP* pop = null)\n                         MatchAccumulator m;\n                         if (s_r)\n                         {\n-                            functionResolve(m, s_r, e.loc, sc, tiargs, e.e1.type, &args2);\n+                            functionResolve(m, s_r, e.loc, sc, tiargs, e.e1.type, ArgumentList(&args2));\n                             if (m.lastf && (m.lastf.errors || m.lastf.hasSemantic3Errors()))\n                             {\n                                 return ErrorExp.get();\n@@ -802,7 +802,7 @@ Expression op_overload(Expression e, Scope* sc, EXP* pop = null)\n                         FuncDeclaration lastf = m.lastf;\n                         if (s)\n                         {\n-                            functionResolve(m, s, e.loc, sc, tiargs, e.e2.type, &args1);\n+                            functionResolve(m, s, e.loc, sc, tiargs, e.e2.type, ArgumentList(&args1));\n                             if (m.lastf && (m.lastf.errors || m.lastf.hasSemantic3Errors()))\n                             {\n                                 return ErrorExp.get();\n@@ -1254,7 +1254,7 @@ Expression op_overload(Expression e, Scope* sc, EXP* pop = null)\n                 args2[0] = e.e2;\n                 expandTuples(&args2);\n                 MatchAccumulator m;\n-                functionResolve(m, s, e.loc, sc, tiargs, e.e1.type, &args2);\n+                functionResolve(m, s, e.loc, sc, tiargs, e.e1.type, ArgumentList(&args2));\n                 if (m.lastf && (m.lastf.errors || m.lastf.hasSemantic3Errors()))\n                 {\n                     return ErrorExp.get();\n@@ -1347,15 +1347,15 @@ private Expression compare_overload(BinExp e, Scope* sc, Identifier id, EXP* pop\n         }\n         if (s)\n         {\n-            functionResolve(m, s, e.loc, sc, tiargs, e.e1.type, &args2);\n+            functionResolve(m, s, e.loc, sc, tiargs, e.e1.type, ArgumentList(&args2));\n             if (m.lastf && (m.lastf.errors || m.lastf.hasSemantic3Errors()))\n                 return ErrorExp.get();\n         }\n         FuncDeclaration lastf = m.lastf;\n         int count = m.count;\n         if (s_r)\n         {\n-            functionResolve(m, s_r, e.loc, sc, tiargs, e.e2.type, &args1);\n+            functionResolve(m, s_r, e.loc, sc, tiargs, e.e2.type, ArgumentList(&args1));\n             if (m.lastf && (m.lastf.errors || m.lastf.hasSemantic3Errors()))\n                 return ErrorExp.get();\n         }\n@@ -1746,7 +1746,10 @@ private FuncDeclaration findBestOpApplyMatch(Expression ethis, FuncDeclaration f\n \n             // Found another overload with different attributes?\n             // e.g. @system vs. @safe opApply\n-            bool ambig = tf.attributesEqual(bestTf);\n+            // @@@DEPRECATED_2.112@@@\n+            // See semantic2.d Semantic2Visitor.visit(FuncDeclaration):\n+            // Remove `false` after deprecation period is over.\n+            bool ambig = tf.attributesEqual(bestTf, false);\n \n             // opApplies with identical attributes could still accept\n             // different function bodies as delegate"}, {"sha": "36a76f50da20590abc9560533b1901b1258ad00b", "filename": "gcc/d/dmd/parse.d", "status": "modified", "additions": 105, "deletions": 114, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fparse.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fparse.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fparse.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -16,6 +16,7 @@ module dmd.parse;\n import core.stdc.stdio;\n import core.stdc.string;\n import dmd.astenums;\n+import dmd.errorsink;\n import dmd.globals;\n import dmd.id;\n import dmd.identifier;\n@@ -51,9 +52,11 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n      * Input:\n      *      loc     location in source file of mixin\n      */\n-    extern (D) this(const ref Loc loc, AST.Module _module, const(char)[] input, bool doDocComment)\n+    extern (D) this(const ref Loc loc, AST.Module _module, const(char)[] input, bool doDocComment,\n+        ErrorSink errorSink) scope\n     {\n         super(_module ? _module.srcfile.toChars() : null, input.ptr, 0, input.length, doDocComment, false,\n+                errorSink,\n                 global.vendor, global.versionNumber());\n \n         //printf(\"Parser::Parser()\\n\");\n@@ -64,8 +67,9 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n             /* Create a pseudo-filename for the mixin string, as it may not even exist\n              * in the source file.\n              */\n-            char* filename = cast(char*)mem.xmalloc(strlen(loc.filename) + 7 + (loc.linnum).sizeof * 3 + 1);\n-            sprintf(filename, \"%s-mixin-%d\", loc.filename, cast(int)loc.linnum);\n+            auto len = strlen(loc.filename) + 7 + (loc.linnum).sizeof * 3 + 1;\n+            char* filename = cast(char*)mem.xmalloc(len);\n+            snprintf(filename, len, \"%s-mixin-%d\", loc.filename, cast(int)loc.linnum);\n             scanloc.filename = filename;\n         }\n \n@@ -74,9 +78,10 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n         //nextToken();              // start up the scanner\n     }\n \n-    extern (D) this(AST.Module _module, const(char)[] input, bool doDocComment)\n+    extern (D) this(AST.Module _module, const(char)[] input, bool doDocComment, ErrorSink errorSink) scope\n     {\n         super(_module ? _module.srcfile.toChars() : null, input.ptr, 0, input.length, doDocComment, false,\n+              errorSink,\n               global.vendor, global.versionNumber());\n \n         //printf(\"Parser::Parser()\\n\");\n@@ -167,13 +172,13 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n \n         if (token.value == TOK.rightCurly)\n         {\n-            error(token.loc, \"unmatched closing brace\");\n+            error(\"unmatched closing brace\");\n             return errorReturn();\n         }\n \n         if (token.value != TOK.endOfFile)\n         {\n-            error(token.loc, \"unrecognized declaration\");\n+            error(\"unrecognized declaration\");\n             return errorReturn();\n         }\n         return decldefs;\n@@ -286,7 +291,7 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n         check(TOK.rightParenthesis);\n         if (msg)\n         {\n-            error(\"conflicting storage class `deprecated(%s)` and `deprecated(%s)`\", msg.toChars(), e.toChars());\n+            error(token.loc, \"conflicting storage class `deprecated(%s)` and `deprecated(%s)`\", msg.toChars(), e.toChars());\n         }\n         msg = e;\n         return true;\n@@ -799,7 +804,7 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n                     {\n                         if (pAttrs.link != res.link)\n                         {\n-                            error(\"conflicting linkage `extern (%s)` and `extern (%s)`\", AST.linkageToChars(pAttrs.link), AST.linkageToChars(res.link));\n+                            error(token.loc, \"conflicting linkage `extern (%s)` and `extern (%s)`\", AST.linkageToChars(pAttrs.link), AST.linkageToChars(res.link));\n                         }\n                         else if (res.idents || res.identExps || res.cppmangle != CPPMANGLE.def)\n                         {\n@@ -887,7 +892,7 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n                     if (pAttrs.visibility.kind != AST.Visibility.Kind.undefined)\n                     {\n                         if (pAttrs.visibility.kind != prot)\n-                            error(\"conflicting visibility attribute `%s` and `%s`\", AST.visibilityToChars(pAttrs.visibility.kind), AST.visibilityToChars(prot));\n+                            error(token.loc, \"conflicting visibility attribute `%s` and `%s`\", AST.visibilityToChars(pAttrs.visibility.kind), AST.visibilityToChars(prot));\n                         else\n                             error(\"redundant visibility attribute `%s`\", AST.visibilityToChars(prot));\n                     }\n@@ -1240,7 +1245,7 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n             {\n                 // Windows `printf` does not support `%1$s`\n                 const(char*) stc_str = (orig & STC.scope_) ? \"scope\".ptr : \"ref\".ptr;\n-                error(\"attribute `in` cannot be added after `%s`: remove `%s`\",\n+                error(token.loc, \"attribute `in` cannot be added after `%s`: remove `%s`\",\n                       stc_str, stc_str);\n             }\n             else\n@@ -1285,7 +1290,10 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n             if (token.value == TOK.leftParenthesis)\n             {\n                 const loc = token.loc;\n-                exp = new AST.CallExp(loc, exp, parseArguments());\n+                AST.Expressions* args = new AST.Expressions();\n+                AST.Identifiers* names = new AST.Identifiers();\n+                parseNamedArguments(args, names);\n+                exp = new AST.CallExp(loc, exp, args, names);\n             }\n \n             if (udas is null)\n@@ -2170,7 +2178,7 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n             nextToken();\n             if (token.value != TOK.identifier)\n             {\n-                error(\"`%s` expected as dot-separated identifiers, got `%s`\", entity, token.toChars());\n+                error(token.loc, \"`%s` expected as dot-separated identifiers, got `%s`\", entity, token.toChars());\n                 return qualified;\n             }\n \n@@ -2420,7 +2428,7 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n         tf = tf.addSTC(stc);\n \n         auto f = new AST.CtorDeclaration(loc, Loc.initial, stc, tf);\n-        AST.Dsymbol s = parseContracts(f);\n+        AST.Dsymbol s = parseContracts(f, !!tpl);\n         if (udas)\n         {\n             auto a = new AST.Dsymbols();\n@@ -2879,43 +2887,6 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n                     storageClass = appendStorageClass(storageClass, stc);\n                     continue;\n \n-                    version (none)\n-                    {\n-                    case TOK.static_:\n-                        stc = STC.static_;\n-                        goto L2;\n-\n-                    case TOK.auto_:\n-                        storageClass = STC.auto_;\n-                        goto L4;\n-\n-                    case TOK.alias_:\n-                        storageClass = STC.alias_;\n-                        goto L4;\n-                    L4:\n-                        nextToken();\n-                        ai = null;\n-                        if (token.value == TOK.identifier)\n-                        {\n-                            ai = token.ident;\n-                            nextToken();\n-                        }\n-\n-                        at = null; // no type\n-                        ae = null; // no default argument\n-                        if (token.value == TOK.assign) // = defaultArg\n-                        {\n-                            nextToken();\n-                            ae = parseDefaultInitExp();\n-                            hasdefault = 1;\n-                        }\n-                        else\n-                        {\n-                            if (hasdefault)\n-                                error(\"default argument expected for `alias %s`\", ai ? ai.toChars() : \"\");\n-                        }\n-                        goto L3;\n-                    }\n                 default:\n                     {\n                         stc = storageClass & (STC.IOR | STC.lazy_);\n@@ -3270,7 +3241,7 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n             if (token.value != TOK.rightCurly)\n             {\n                 /* { */\n-                error(\"`}` expected following members in `%s` declaration at %s\",\n+                error(token.loc, \"`}` expected following members in `%s` declaration at %s\",\n                     Token.toChars(tok), loc.toChars());\n             }\n             nextToken();\n@@ -3283,7 +3254,7 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n         }\n         else\n         {\n-            error(\"{ } expected following `%s` declaration\", Token.toChars(tok));\n+            error(token.loc, \"{ } expected following `%s` declaration\", Token.toChars(tok));\n         }\n \n         AST.AggregateDeclaration a;\n@@ -3670,7 +3641,7 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n             loc = token.loc;\n             nextToken();\n             if (token.value != TOK.leftParenthesis)\n-                error(\"found `%s` when expecting `%s` following `mixin`\", token.toChars(), Token.toChars(TOK.leftParenthesis));\n+                error(token.loc, \"found `%s` when expecting `%s` following `mixin`\", token.toChars(), Token.toChars(TOK.leftParenthesis));\n             auto exps = parseArguments();\n             t = new AST.TypeMixin(loc, exps);\n             break;\n@@ -3734,7 +3705,7 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n         default:\n             error(\"basic type expected, not `%s`\", token.toChars());\n             if (token.value == TOK.else_)\n-                errorSupplemental(token.loc, \"There's no `static else`, use `else` instead.\");\n+                eSink.errorSupplemental(token.loc, \"There's no `static else`, use `else` instead.\");\n             t = AST.Type.terror;\n             break;\n         }\n@@ -4482,7 +4453,7 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n             if (!tfirst)\n                 tfirst = t;\n             else if (t != tfirst)\n-                error(\"multiple declarations must have the same type, not `%s` and `%s`\", tfirst.toChars(), t.toChars());\n+                error(token.loc, \"multiple declarations must have the same type, not `%s` and `%s`\", tfirst.toChars(), t.toChars());\n \n             if (token.value == TOK.colon && !ident && t.ty != Tfunction)\n             {\n@@ -4519,7 +4490,7 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n                 if (_init)\n                 {\n                     if (isThis)\n-                        error(\"cannot use syntax `alias this = %s`, use `alias %s this` instead\", _init.toChars(), _init.toChars());\n+                        error(token.loc, \"cannot use syntax `alias this = %s`, use `alias %s this` instead\", _init.toChars(), _init.toChars());\n                     else\n                         error(\"alias cannot have initializer\");\n                 }\n@@ -4558,7 +4529,7 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n                     continue;\n \n                 default:\n-                    error(\"semicolon expected to close `alias` declaration\");\n+                    error(\"semicolon expected to close `alias` declaration, not `%s`\", token.toChars());\n                     break;\n                 }\n             }\n@@ -4571,7 +4542,7 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n                     pAttrs.storageClass = STC.undefined_;\n                 if (tpl)\n                     constraint = parseConstraint();\n-                AST.Dsymbol s = parseContracts(f);\n+                AST.Dsymbol s = parseContracts(f, !!tpl);\n                 auto tplIdent = s.ident;\n \n                 if (link != linkage)\n@@ -4697,12 +4668,12 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n                 default:\n                     if (loc.linnum != token.loc.linnum)\n                     {\n-                        error(\"semicolon needed to end declaration of `%s`, instead of `%s`\", s.toChars(), token.toChars());\n-                        errorSupplemental(loc, \"`%s` declared here\", s.toChars());\n+                        error(token.loc, \"semicolon needed to end declaration of `%s`, instead of `%s`\", s.toChars(), token.toChars());\n+                        eSink.errorSupplemental(loc, \"`%s` declared here\", s.toChars());\n                     }\n                     else\n                     {\n-                        error(\"semicolon needed to end declaration of `%s` instead of `%s`\", s.toChars(), token.toChars());\n+                        error(token.loc, \"semicolon needed to end declaration of `%s` instead of `%s`\", s.toChars(), token.toChars());\n                     }\n                     break;\n                 }\n@@ -4720,7 +4691,7 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n         // A common mistake is to use a reserved keyword as an identifier, e.g. `in` or `out`\n         if (token.isKeyword)\n         {\n-            errorSupplemental(token.loc, \"`%s` is a keyword, perhaps append `_` to make it an identifier\", token.toChars());\n+            eSink.errorSupplemental(token.loc, \"`%s` is a keyword, perhaps append `_` to make it an identifier\", token.toChars());\n             nextToken();\n         }\n     }\n@@ -4940,7 +4911,7 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n                             AST.stcToBuffer(&buf, remStc);\n                             // @@@DEPRECATED_2.103@@@\n                             // Deprecated in 2020-07, can be made an error in 2.103\n-                            deprecation(\"storage class `%s` has no effect in type aliases\", buf.peekChars());\n+                            eSink.deprecation(token.loc, \"storage class `%s` has no effect in type aliases\", buf.peekChars());\n                         }\n                     }\n \n@@ -4990,7 +4961,7 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n                     continue;\n \n                 default:\n-                    error(\"semicolon expected to close `alias` declaration\");\n+                    error(\"semicolon expected to close `alias` declaration, not `%s`\", token.toChars());\n                     break;\n                 }\n                 break;\n@@ -5132,7 +5103,7 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n             if (token.value == TOK.leftCurly)\n             {\n                 deprecation(\"using `(args) => { ... }` to create a delegate that returns a delegate is error-prone.\");\n-                deprecationSupplemental(token.loc, \"Use `(args) { ... }` for a multi-statement function literal or use `(args) => () { }` if you intended for the lambda to return a delegate.\");\n+                deprecationSupplemental(\"Use `(args) { ... }` for a multi-statement function literal or use `(args) => () { }` if you intended for the lambda to return a delegate.\");\n             }\n             const returnloc = token.loc;\n             AST.Expression ae = parseAssignExp();\n@@ -5157,7 +5128,7 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n     /*****************************************\n      * Parse contracts following function declaration.\n      */\n-    private AST.FuncDeclaration parseContracts(AST.FuncDeclaration f)\n+    private AST.FuncDeclaration parseContracts(AST.FuncDeclaration f, bool isTemplateFunction = false)\n     {\n         LINK linksave = linkage;\n \n@@ -5329,7 +5300,12 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n                 else if (t == TOK.at)\n                     error(\"attributes cannot be placed after a template constraint\");\n                 else if (t == TOK.if_)\n-                    error(\"cannot use function constraints for non-template functions. Use `static if` instead\");\n+                {\n+                    if (isTemplateFunction)\n+                        error(\"template constraint must follow parameter lists and attributes\");\n+                    else\n+                        error(\"cannot use function constraints for non-template functions. Use `static if` instead\");\n+                }\n                 else\n                     error(\"semicolon expected following function declaration\");\n             }\n@@ -5352,7 +5328,7 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n     {\n         if (token.value != TOK.else_ && token.value != TOK.catch_ && token.value != TOK.finally_ && lookingForElse.linnum != 0)\n         {\n-            warning(elseloc, \"else is dangling, add { } after condition at %s\", lookingForElse.toChars());\n+            eSink.warning(elseloc, \"else is dangling, add { } after condition at %s\", lookingForElse.toChars());\n         }\n     }\n \n@@ -5395,7 +5371,7 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n             nextToken();\n         }\n         if (format)\n-            error(format.ptr, start.ptr, param ? \"declaration\".ptr : condition.toChars());\n+            error(token.loc, format.ptr, start.ptr, param ? \"declaration\".ptr : condition.toChars());\n     }\n \n     /*****************************************\n@@ -5450,6 +5426,11 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n                     stc = STC.out_;\n                     goto Lagain;\n \n+                case TOK.auto_:\n+                    error(\"cannot declare `auto` loop variable, omit `auto` to still get type inference\");\n+                    stc = STC.auto_;\n+                    goto Lagain;\n+\n                 case TOK.enum_:\n                     stc = STC.manifest;\n                     goto Lagain;\n@@ -5525,7 +5506,7 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n             nextToken();\n             if (lastai && parameters.length >= 2)\n             {\n-                errorSupplemental(loc, \"perhaps the `;` goes before `%s`\", lastai.toChars());\n+                eSink.errorSupplemental(loc, \"perhaps the `;` goes before `%s`\", lastai.toChars());\n             }\n             return null;\n         }\n@@ -5798,7 +5779,7 @@ LagainStc:\n                  */\n                 if (token.value == TOK.identifier && exp.op == EXP.identifier)\n                 {\n-                    error(\"found `%s` when expecting `;` or `=`, did you mean `%s %s = %s`?\", peek(&token).toChars(), exp.toChars(), token.toChars(), peek(peek(&token)).toChars());\n+                    error(token.loc, \"found `%s` when expecting `;` or `=`, did you mean `%s %s = %s`?\", peek(&token).toChars(), exp.toChars(), token.toChars(), peek(peek(&token)).toChars());\n                     nextToken();\n                 }\n                 else\n@@ -6501,7 +6482,7 @@ LagainStc:\n                     if (token.value != TOK.leftParenthesis)\n                     {\n                         deprecation(\"`catch` statement without an exception specification is deprecated\");\n-                        deprecationSupplemental(token.loc, \"use `catch(Throwable)` for old behavior\");\n+                        deprecationSupplemental(\"use `catch(Throwable)` for old behavior\");\n                         t = null;\n                         id = null;\n                     }\n@@ -7060,7 +7041,7 @@ LagainStc:\n     void check(TOK value, const(char)* string)\n     {\n         if (token.value != value)\n-            error(\"found `%s` when expecting `%s` following %s\", token.toChars(), Token.toChars(value), string);\n+            error(token.loc, \"found `%s` when expecting `%s` following %s\", token.toChars(), Token.toChars(value), string);\n         nextToken();\n     }\n \n@@ -7330,7 +7311,7 @@ LagainStc:\n     {\n         // This code parallels parseDeclarator()\n         Token* t = *pt;\n-        int parens;\n+        bool parens;\n \n         //printf(\"Parser::isDeclarator() %s\\n\", t.toChars());\n         if (t.value == TOK.assign)\n@@ -7625,24 +7606,6 @@ LagainStc:\n                 }\n                 goto L1;\n \n-                version (none)\n-                {\n-                case TOK.static_:\n-                    continue;\n-                case TOK.auto_:\n-                case TOK.alias_:\n-                    t = peek(t);\n-                    if (t.value == TOK.identifier)\n-                        t = peek(t);\n-                    if (t.value == TOK.assign)\n-                    {\n-                        t = peek(t);\n-                        if (!isExpression(&t))\n-                            return false;\n-                    }\n-                    goto L3;\n-                }\n-\n             default:\n                 {\n                     if (!isBasicType(&t))\n@@ -8144,12 +8107,12 @@ LagainStc:\n                         if (token.postfix)\n                         {\n                             if (token.postfix != postfix)\n-                                error(\"mismatched string literal postfixes `'%c'` and `'%c'`\", postfix, token.postfix);\n+                                error(token.loc, \"mismatched string literal postfixes `'%c'` and `'%c'`\", postfix, token.postfix);\n                             postfix = token.postfix;\n                         }\n \n                         error(\"implicit string concatenation is error-prone and disallowed in D\");\n-                        errorSupplemental(token.loc, \"Use the explicit syntax instead \" ~\n+                        eSink.errorSupplemental(token.loc, \"Use the explicit syntax instead \" ~\n                              \"(concatenating literals is `@nogc`): %s ~ %s\",\n                              prev.toChars(), token.toChars());\n \n@@ -8280,7 +8243,7 @@ LagainStc:\n             check(TOK.dot);\n             if (token.value != TOK.identifier)\n             {\n-                error(\"found `%s` when expecting identifier following `%s`.\", token.toChars(), t.toChars());\n+                error(token.loc, \"found `%s` when expecting identifier following `%s`.\", token.toChars(), t.toChars());\n                 goto Lerr;\n             }\n             e = new AST.DotIdExp(loc, new AST.TypeExp(loc, t), token.ident);\n@@ -8425,7 +8388,7 @@ LagainStc:\n                 // https://dlang.org/spec/expression.html#mixin_expressions\n                 nextToken();\n                 if (token.value != TOK.leftParenthesis)\n-                    error(\"found `%s` when expecting `%s` following `mixin`\", token.toChars(), Token.toChars(TOK.leftParenthesis));\n+                    error(token.loc, \"found `%s` when expecting `%s` following `mixin`\", token.toChars(), Token.toChars(TOK.leftParenthesis));\n                 auto exps = parseArguments();\n                 e = new AST.MixinExp(loc, exps);\n                 break;\n@@ -8488,7 +8451,7 @@ LagainStc:\n                 // ( expression )\n                 nextToken();\n                 e = parseExpression();\n-                e.parens = 1;\n+                e.parens = true;\n                 check(loc, TOK.rightParenthesis);\n                 break;\n             }\n@@ -8758,14 +8721,6 @@ LagainStc:\n                         case TOK.wcharLiteral:\n                         case TOK.dcharLiteral:\n                         case TOK.string_:\n-                            version (none)\n-                            {\n-                            case TOK.tilde:\n-                            case TOK.and:\n-                            case TOK.mul:\n-                            case TOK.min:\n-                            case TOK.add:\n-                            }\n                         case TOK.function_:\n                         case TOK.delegate_:\n                         case TOK.typeof_:\n@@ -8907,7 +8862,10 @@ LagainStc:\n                 break;\n \n             case TOK.leftParenthesis:\n-                e = new AST.CallExp(loc, e, parseArguments());\n+                AST.Expressions* args = new AST.Expressions();\n+                AST.Identifiers* names = new AST.Identifiers();\n+                parseNamedArguments(args, names);\n+                e = new AST.CallExp(loc, e, args, names);\n                 continue;\n \n             case TOK.leftBracket:\n@@ -9342,26 +9300,52 @@ LagainStc:\n     private AST.Expressions* parseArguments()\n     {\n         // function call\n-        AST.Expressions* arguments;\n+        AST.Expressions* arguments = new AST.Expressions();\n+        parseNamedArguments(arguments, null);\n+        return arguments;\n+    }\n+\n+    /*************************\n+     * Collect argument list.\n+     * Assume current token is ',', '$(LPAREN)' or '['.\n+     */\n+    private void parseNamedArguments(AST.Expressions* arguments, AST.Identifiers* names)\n+    {\n+        assert(arguments);\n \n-        arguments = new AST.Expressions();\n         const endtok = token.value == TOK.leftBracket ? TOK.rightBracket : TOK.rightParenthesis;\n \n         nextToken();\n \n         while (token.value != endtok && token.value != TOK.endOfFile)\n         {\n+            if (peekNext() == TOK.colon)\n+            {\n+                // Named argument `name: exp`\n+                auto loc = token.loc;\n+                auto ident = token.ident;\n+                check(TOK.identifier);\n+                check(TOK.colon);\n+                if (names)\n+                    names.push(ident);\n+                else\n+                    error(loc, \"named arguments not allowed here\");\n+            }\n+            else\n+            {\n+                if (names)\n+                    names.push(null);\n+            }\n+\n             auto arg = parseAssignExp();\n             arguments.push(arg);\n+\n             if (token.value != TOK.comma)\n                 break;\n \n             nextToken(); //comma\n         }\n-\n         check(endtok);\n-\n-        return arguments;\n     }\n \n     /*******************************************\n@@ -9372,13 +9356,18 @@ LagainStc:\n \n         nextToken();\n         AST.Expressions* arguments = null;\n+        AST.Identifiers* names = null;\n \n         // An anonymous nested class starts with \"class\"\n         if (token.value == TOK.class_)\n         {\n             nextToken();\n             if (token.value == TOK.leftParenthesis)\n-                arguments = parseArguments();\n+            {\n+                arguments = new AST.Expressions();\n+                names = new AST.Identifiers();\n+                parseNamedArguments(arguments, names);\n+            }\n \n             AST.BaseClasses* baseclasses = null;\n             if (token.value != TOK.leftCurly)\n@@ -9420,10 +9409,12 @@ LagainStc:\n         }\n         else if (token.value == TOK.leftParenthesis && t.ty != Tsarray)\n         {\n-            arguments = parseArguments();\n+            arguments = new AST.Expressions();\n+            names = new AST.Identifiers();\n+            parseNamedArguments(arguments, names);\n         }\n \n-        auto e = new AST.NewExp(loc, thisexp, t, arguments);\n+        auto e = new AST.NewExp(loc, thisexp, t, arguments, names);\n         return e;\n     }\n "}, {"sha": "d85105d6f202a155e2039a72dcfb1d53f4f58a2d", "filename": "gcc/d/dmd/printast.d", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fprintast.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fprintast.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fprintast.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -14,6 +14,7 @@ module dmd.printast;\n import core.stdc.stdio;\n \n import dmd.expression;\n+import dmd.ctfeexpr;\n import dmd.tokens;\n import dmd.visitor;\n import dmd.hdrgen;\n@@ -38,7 +39,7 @@ extern (C++) final class PrintASTVisitor : Visitor\n \n     int indent;\n \n-    extern (D) this(int indent)\n+    extern (D) this(int indent) scope\n     {\n         this.indent = indent;\n     }\n@@ -210,6 +211,14 @@ extern (C++) final class PrintASTVisitor : Visitor\n         printf(\".init: %s\\n\", e.initializer ? e.initializer.toChars() : \"\");\n     }\n \n+    override void visit(ClassReferenceExp e)\n+    {\n+        visit(cast(Expression)e);\n+        printIndent(indent + 2);\n+        printf(\".value: %s\\n\", e.value ? e.value.toChars() : \"\");\n+        printAST(e.value, indent + 2);\n+    }\n+\n     static void printIndent(int indent)\n     {\n         foreach (i; 0 .. indent)"}, {"sha": "1d450505a4dad694ac3f8a0a3f47923fb60a092a", "filename": "gcc/d/dmd/root/aav.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Froot%2Faav.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Froot%2Faav.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Faav.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -149,7 +149,7 @@ private struct AARange(K,V)\n     size_t bIndex;\n     aaA* current;\n \n-    this(AA* aa) pure nothrow @nogc\n+    this(AA* aa) pure nothrow @nogc scope\n     {\n         if (aa)\n         {"}, {"sha": "541a12d9e1db3fa5c8394395b1b6db30cf2a2171", "filename": "gcc/d/dmd/root/array.d", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Froot%2Farray.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Froot%2Farray.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Farray.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -41,7 +41,7 @@ public:\n      * Params:\n      *  dim = initial length of array\n      */\n-    this(size_t dim) pure nothrow\n+    this(size_t dim) pure nothrow scope\n     {\n         reserve(dim);\n         this.length = dim;\n@@ -69,7 +69,18 @@ public:\n             {\n                 foreach (u; 0 .. a.length)\n                 {\n-                    buf[u] = toStringFunc(a.data[u]);\n+                    static if (is(typeof(a.data[u] is null)))\n+                    {\n+                        if (a.data[u] is null)\n+                            buf[u] = \"null\";\n+                        else\n+                            buf[u] = toStringFunc(a.data[u]);\n+                    }\n+                    else\n+                    {\n+                        buf[u] = toStringFunc(a.data[u]);\n+                    }\n+\n                     len += buf[u].length + seplen;\n                 }\n             }\n@@ -381,6 +392,19 @@ unittest\n     assert(str == `[\"hello\",\"world\"]`);\n     // Test presence of null terminator.\n     assert(str.ptr[str.length] == '\\0');\n+\n+    // Test printing an array of classes, which can be null\n+    static class C\n+    {\n+        override string toString() const\n+        {\n+            return \"x\";\n+        }\n+    }\n+    auto nullarray = Array!C(2);\n+    nullarray[0] = new C();\n+    nullarray[1] = null;\n+    assert(nullarray.toString() == `[x,null]`);\n }\n \n unittest"}, {"sha": "aae56fac02b24260b71744f6967d7d05f8097ca4", "filename": "gcc/d/dmd/root/ctfloat.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Froot%2Fctfloat.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Froot%2Fctfloat.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Fctfloat.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -50,7 +50,7 @@ extern (C++) struct CTFloat\n     static real_t parse(const(char)* literal, out bool isOutOfRange);\n \n     @system\n-    static int sprint(char* str, char fmt, real_t x);\n+    static int sprint(char* str, size_t size, char fmt, real_t x);\n \n     // Constant real values 0, 1, -1 and 0.5.\n     __gshared real_t zero;"}, {"sha": "d2f795bf9e912c442ec4e6c571081e20525fc229", "filename": "gcc/d/dmd/root/ctfloat.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Froot%2Fctfloat.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Froot%2Fctfloat.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Fctfloat.h?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -9,6 +9,7 @@\n \n #pragma once\n \n+#include \"dcompat.h\"\n #include \"longdouble.h\"\n \n // Type used by the front-end for compile-time reals\n@@ -51,7 +52,7 @@ struct CTFloat\n     static bool isInfinity(real_t r);\n \n     static real_t parse(const char *literal, bool& isOutOfRange);\n-    static int sprint(char *str, char fmt, real_t x);\n+    static int sprint(char *str, d_size_t size, char fmt, real_t x);\n \n     static size_t hash(real_t a);\n "}, {"sha": "387361568e07576bb57510ef7caa8cb6e6cfe88c", "filename": "gcc/d/dmd/root/filename.d", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Froot%2Ffilename.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Froot%2Ffilename.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Ffilename.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -85,6 +85,12 @@ nothrow:\n         this.str = str.xarraydup;\n     }\n \n+    ///\n+    extern (C++) static FileName create(const(char)* name) pure\n+    {\n+        return FileName(name.toDString);\n+    }\n+\n     /// Compare two name according to the platform's rules (case sensitive or not)\n     extern (C++) static bool equals(const(char)* name1, const(char)* name2) pure @nogc\n     {"}, {"sha": "62142331013a04755228762c901c6c730772562d", "filename": "gcc/d/dmd/root/filename.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Froot%2Ffilename.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Froot%2Ffilename.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Ffilename.h?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -19,6 +19,7 @@ struct FileName\n private:\n     DString str;\n public:\n+    static FileName create(const char *name);\n     static bool equals(const char *name1, const char *name2);\n     static bool absolute(const char *name);\n     static const char *toAbsolute(const char *name, const char *base = NULL);"}, {"sha": "7138841caa02ae3d95a2fb97521649573d60f306", "filename": "gcc/d/dmd/root/rootobject.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Froot%2Frootobject.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Froot%2Frootobject.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Frootobject.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -38,7 +38,7 @@ enum DYNCAST : int\n \n extern (C++) class RootObject\n {\n-    this() nothrow pure @nogc @safe\n+    this() nothrow pure @nogc @safe scope\n     {\n     }\n "}, {"sha": "ef0151656b1dd68ebea3071adbe0fdd3abe66dd8", "filename": "gcc/d/dmd/sapply.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fsapply.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fsapply.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fsapply.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -37,7 +37,7 @@ private extern (C++) final class PostorderStatementVisitor : StoppableVisitor\n public:\n     StoppableVisitor v;\n \n-    extern (D) this(StoppableVisitor v)\n+    extern (D) this(StoppableVisitor v) scope\n     {\n         this.v = v;\n     }"}, {"sha": "440e4cbc8e7a2d2a915e6c3c38f70bfe2121b010", "filename": "gcc/d/dmd/semantic2.d", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fsemantic2.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fsemantic2.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fsemantic2.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -83,7 +83,7 @@ private extern(C++) final class Semantic2Visitor : Visitor\n {\n     alias visit = Visitor.visit;\n     Scope* sc;\n-    this(Scope* sc)\n+    this(Scope* sc) scope\n     {\n         this.sc = sc;\n     }\n@@ -248,9 +248,9 @@ private extern(C++) final class Semantic2Visitor : Visitor\n         sc.varDecl = vd;\n         scope(exit) sc.varDecl = null;\n \n-        if (vd.aliassym)        // if it's a tuple\n+        if (vd.aliasTuple)        // if it's a tuple\n         {\n-            vd.aliassym.accept(this);\n+            vd.aliasTuple.accept(this);\n             vd.semanticRun = PASS.semantic2done;\n             return;\n         }\n@@ -439,7 +439,11 @@ private extern(C++) final class Semantic2Visitor : Visitor\n                 if (tf1.mod != tf2.mod || ((f1.storage_class ^ f2.storage_class) & STC.static_))\n                     return 0;\n \n-                const sameAttr = tf1.attributesEqual(tf2);\n+                // @@@DEPRECATED_2.112@@@\n+                // This test doesn't catch identical functions that differ only\n+                // in explicit/implicit `@system` - a deprecation has now been\n+                // added below, remove `false` after deprecation period is over.\n+                const sameAttr = tf1.attributesEqual(tf2, false);\n                 const sameParams = tf1.parameterList == tf2.parameterList;\n \n                 // Allow the hack to declare overloads with different parameters/STC's\n@@ -462,7 +466,19 @@ private extern(C++) final class Semantic2Visitor : Visitor\n \n                 // Different attributes don't conflict in extern(D)\n                 if (!sameAttr && linkage1 == LINK.d)\n+                {\n+                    // @@@DEPRECATED_2.112@@@\n+                    // Same as 2.104 deprecation, but also catching explicit/implicit `@system`\n+                    // At the end of deprecation period, fix Type.attributesEqual and remove\n+                    // this condition, as well as the error for extern(C) functions above.\n+                    if (sameAttr != tf1.attributesEqual(tf2))\n+                    {\n+                        f2.deprecation(\"cannot overload `extern(%s)` function at %s\",\n+                                linkageToChars(f1._linkage),\n+                                f1.loc.toChars());\n+                    }\n                     return 0;\n+                }\n \n                 error(f2.loc, \"%s `%s%s` conflicts with previous declaration at %s\",\n                         f2.kind(),"}, {"sha": "33a43187fa8af1eba32976cc97f20630f37eb635", "filename": "gcc/d/dmd/semantic3.d", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fsemantic3.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fsemantic3.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fsemantic3.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -88,7 +88,7 @@ private extern(C++) final class Semantic3Visitor : Visitor\n     alias visit = Visitor.visit;\n \n     Scope* sc;\n-    this(Scope* sc)\n+    this(Scope* sc) scope\n     {\n         this.sc = sc;\n     }\n@@ -342,7 +342,6 @@ private extern(C++) final class Semantic3Visitor : Visitor\n             sc2.aligndecl = null;\n             if (funcdecl.ident != Id.require && funcdecl.ident != Id.ensure)\n                 sc2.flags = sc.flags & ~SCOPE.contract;\n-            sc2.flags &= ~SCOPE.compile;\n             sc2.tf = null;\n             sc2.os = null;\n             sc2.inLoop = false;\n@@ -712,7 +711,7 @@ private extern(C++) final class Semantic3Visitor : Visitor\n \n                         // Insert implicit super() at start of fbody\n                         Type tthis = ad2.type.addMod(funcdecl.vthis.type.mod);\n-                        FuncDeclaration fd = resolveFuncCall(Loc.initial, sc2, cd.baseClass.ctor, null, tthis, null, FuncResolveFlag.quiet);\n+                        FuncDeclaration fd = resolveFuncCall(Loc.initial, sc2, cd.baseClass.ctor, null, tthis, ArgumentList(), FuncResolveFlag.quiet);\n                         if (!fd)\n                         {\n                             funcdecl.error(\"no match for implicit `super()` call in constructor\");\n@@ -1600,7 +1599,7 @@ private struct FuncDeclSem3\n \n     // Scope of analysis\n     Scope* sc;\n-    this(FuncDeclaration fd,Scope* s)\n+    this(FuncDeclaration fd,Scope* s) scope\n     {\n         funcdecl = fd;\n         sc = s;"}, {"sha": "60a74cc2812b7ae9e5b0c07b2f89d7da415f6ee5", "filename": "gcc/d/dmd/sideeffect.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fsideeffect.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fsideeffect.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fsideeffect.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -37,7 +37,7 @@ extern (C++) bool isTrivialExp(Expression e)\n     {\n         alias visit = typeof(super).visit;\n     public:\n-        extern (D) this()\n+        extern (D) this() scope\n         {\n         }\n \n@@ -75,7 +75,7 @@ extern (C++) bool hasSideEffect(Expression e, bool assumeImpureCalls = false)\n     {\n         alias visit = typeof(super).visit;\n     public:\n-        extern (D) this()\n+        extern (D) this() scope\n         {\n         }\n "}, {"sha": "90728fb6fec5a4695e4ec7fc76d57ee19a4c0c54", "filename": "gcc/d/dmd/statement.d", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fstatement.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fstatement.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatement.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1061,6 +1061,16 @@ extern (C++) final class IfStatement : Statement\n     {\n         v.visit(this);\n     }\n+\n+    /******\n+     * Returns: true if `if (__ctfe)`\n+     */\n+    bool isIfCtfeBlock()\n+    {\n+        if (auto cv = condition.isVarExp())\n+            return cv.var.ident == Id.ctfe;\n+        return false;\n+    }\n }\n \n /***********************************************************\n@@ -1762,6 +1772,7 @@ extern (C++) final class GotoStatement : Statement\n     TryFinallyStatement tf;\n     ScopeGuardStatement os;\n     VarDeclaration lastVar;\n+    bool inCtfeBlock;               /// set if goto is inside an `if (__ctfe)` block\n \n     extern (D) this(const ref Loc loc, Identifier ident)\n     {\n@@ -1804,6 +1815,12 @@ extern (C++) final class GotoStatement : Statement\n             return true;\n         }\n \n+        if (label.statement.inCtfeBlock && !inCtfeBlock)\n+        {\n+            error(\"cannot `goto` into `if (__ctfe)` block\");\n+            return true;\n+        }\n+\n         Statement stbnext;\n         for (auto stb = tryBody; stb != label.statement.tryBody; stb = stbnext)\n         {\n@@ -1870,6 +1887,7 @@ extern (C++) final class LabelStatement : Statement\n     Statement gotoTarget;       // interpret\n     void* extra;                // used by Statement_toIR()\n     bool breaks;                // someone did a 'break ident'\n+    bool inCtfeBlock;           // inside a block dominated by `if (__ctfe)`\n \n     extern (D) this(const ref Loc loc, Identifier ident, Statement statement)\n     {"}, {"sha": "46cc4dadf6461751e36a6a42bcbd870d87f304ad", "filename": "gcc/d/dmd/statement.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fstatement.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fstatement.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatement.h?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -381,6 +381,7 @@ class IfStatement final : public Statement\n     IfStatement *syntaxCopy() override;\n \n     void accept(Visitor *v) override { v->visit(this); }\n+    bool isIfCtfeBlock();\n };\n \n class ConditionalStatement final : public Statement\n@@ -667,7 +668,7 @@ class GotoStatement final : public Statement\n     TryFinallyStatement *tf;\n     ScopeGuardStatement *os;\n     VarDeclaration *lastVar;\n-\n+    bool inCtfeBlock;\n     GotoStatement *syntaxCopy() override;\n \n     void accept(Visitor *v) override { v->visit(this); }\n@@ -685,7 +686,7 @@ class LabelStatement final : public Statement\n     Statement *gotoTarget;      // interpret\n     void* extra;                // used by Statement_toIR()\n     bool breaks;                // someone did a 'break ident'\n-\n+    bool inCtfeBlock;\n     LabelStatement *syntaxCopy() override;\n \n     void accept(Visitor *v) override { v->visit(this); }"}, {"sha": "bbaee8e61523862036ac4a0f21cba67a82180b93", "filename": "gcc/d/dmd/statementsem.d", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fstatementsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fstatementsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatementsem.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -39,6 +39,7 @@ import dmd.dsymbol;\n import dmd.dsymbolsem;\n import dmd.dtemplate;\n import dmd.errors;\n+import dmd.errorsink;\n import dmd.escape;\n import dmd.expression;\n import dmd.expressionsem;\n@@ -160,7 +161,7 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n     Statement result;\n     Scope* sc;\n \n-    this(Scope* sc)\n+    this(Scope* sc) scope\n     {\n         this.sc = sc;\n     }\n@@ -1276,7 +1277,7 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n                 else if (auto td = sfront.isTemplateDeclaration())\n                 {\n                     Expressions a;\n-                    if (auto f = resolveFuncCall(loc, sc, td, null, tab, &a, FuncResolveFlag.quiet))\n+                    if (auto f = resolveFuncCall(loc, sc, td, null, tab, ArgumentList(&a), FuncResolveFlag.quiet))\n                         tfront = f.type;\n                 }\n                 else if (auto d = sfront.toAlias().isDeclaration())\n@@ -1491,7 +1492,7 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n                 assert(0);\n         }\n         const(char)* r = (fs.op == TOK.foreach_reverse_) ? \"R\" : \"\";\n-        int j = sprintf(fdname.ptr, \"_aApply%s%.*s%llu\", r, 2, fntab[flag].ptr, cast(ulong)dim);\n+        int j = snprintf(fdname.ptr, BUFFER_LEN,  \"_aApply%s%.*s%llu\", r, 2, fntab[flag].ptr, cast(ulong)dim);\n         assert(j < BUFFER_LEN);\n \n         FuncDeclaration fdapply;\n@@ -1955,7 +1956,17 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n         // Save 'root' of two branches (then and else) at the point where it forks\n         CtorFlow ctorflow_root = scd.ctorflow.clone();\n \n-        ifs.ifbody = ifs.ifbody.semanticNoScope(scd);\n+        /* Detect `if (__ctfe)`\n+         */\n+        if (ifs.isIfCtfeBlock())\n+        {\n+            Scope* scd2 = scd.push();\n+            scd2.flags |= SCOPE.ctfeBlock;\n+            ifs.ifbody = ifs.ifbody.semanticNoScope(scd2);\n+            scd2.pop();\n+        }\n+        else\n+            ifs.ifbody = ifs.ifbody.semanticNoScope(scd);\n         scd.pop();\n \n         CtorFlow ctorflow_then = sc.ctorflow;   // move flow results\n@@ -2222,7 +2233,9 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n             if (ed && ss.cases.length < ed.members.length)\n             {\n                 int missingMembers = 0;\n-                const maxShown = !global.params.verbose ? 6 : int.max;\n+                const maxShown = !global.params.verbose ?\n+                                    (global.params.errorSupplementLimit ? global.params.errorSupplementLimit : int.max)\n+                                    : int.max;\n             Lmembers:\n                 foreach (es; *ed.members)\n                 {\n@@ -2256,7 +2269,7 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n         }\n \n         if (!sc.sw.sdefault &&\n-            (!ss.isFinal || needswitcherror || global.params.useAssert == CHECKENABLE.on))\n+            (!ss.isFinal || needswitcherror || global.params.useAssert == CHECKENABLE.on || sc.func.isSafe))\n         {\n             ss.hasNoDefault = 1;\n \n@@ -2485,7 +2498,7 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n                 cs.exp = se;\n             else if (!cs.exp.isIntegerExp() && !cs.exp.isErrorExp())\n             {\n-                cs.error(\"`case` must be a `string` or an integral constant, not `%s`\", cs.exp.toChars());\n+                cs.error(\"`case` expression must be a compile-time `string` or an integral constant, not `%s`\", cs.exp.toChars());\n                 errors = true;\n             }\n \n@@ -3798,6 +3811,7 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n         gs.tf = sc.tf;\n         gs.os = sc.os;\n         gs.lastVar = sc.lastVar;\n+        gs.inCtfeBlock = (sc.flags & SCOPE.ctfeBlock) != 0;\n \n         if (!gs.label.statement && sc.fes)\n         {\n@@ -3837,6 +3851,7 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n         ls.tf = sc.tf;\n         ls.os = sc.os;\n         ls.lastVar = sc.lastVar;\n+        ls.inCtfeBlock = (sc.flags & SCOPE.ctfeBlock) != 0;\n \n         LabelDsymbol ls2 = fd.searchLabel(ls.ident, ls.loc);\n         if (ls2.statement)\n@@ -4730,7 +4745,7 @@ private Statements* flatten(Statement statement, Scope* sc)\n             const len = buf.length;\n             buf.writeByte(0);\n             const str = buf.extractSlice()[0 .. len];\n-            scope p = new Parser!ASTCodegen(cs.loc, sc._module, str, false);\n+            scope p = new Parser!ASTCodegen(cs.loc, sc._module, str, false, global.errorSink);\n             p.nextToken();\n \n             auto a = new Statements();"}, {"sha": "12b21207b8e660ed4f65ddcd840cfb1881ab78a6", "filename": "gcc/d/dmd/template.h", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Ftemplate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Ftemplate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftemplate.h?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -46,6 +46,21 @@ struct TemplatePrevious\n     Objects *dedargs;\n };\n \n+struct ArgumentList final\n+{\n+    Expressions* arguments;\n+    Identifiers* names;\n+    ArgumentList() :\n+        arguments(),\n+        names()\n+    {\n+    }\n+    ArgumentList(Expressions* arguments, Identifiers* names = nullptr) :\n+        arguments(arguments),\n+        names(names)\n+        {}\n+};\n+\n class TemplateDeclaration final : public ScopeDsymbol\n {\n public:\n@@ -81,7 +96,7 @@ class TemplateDeclaration final : public ScopeDsymbol\n \n     Visibility visible() override;\n \n-    MATCH leastAsSpecialized(Scope *sc, TemplateDeclaration *td2, Expressions *fargs);\n+    MATCH leastAsSpecialized(Scope* sc, TemplateDeclaration* td2, ArgumentList argumentList);\n     RootObject *declareParameter(Scope *sc, TemplateParameter *tp, RootObject *o);\n \n     TemplateDeclaration *isTemplateDeclaration() override { return this; }"}, {"sha": "1a9d2520c84ec597e8bba9c8cb0c0828ab04b3ee", "filename": "gcc/d/dmd/templateparamsem.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Ftemplateparamsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Ftemplateparamsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftemplateparamsem.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -50,7 +50,7 @@ private extern (C++) final class TemplateParameterSemanticVisitor : Visitor\n     TemplateParameters* parameters;\n     bool result;\n \n-    this(Scope* sc, TemplateParameters* parameters)\n+    this(Scope* sc, TemplateParameters* parameters) scope\n     {\n         this.sc = sc;\n         this.parameters = parameters;"}, {"sha": "aec3a77dee8cdf0a6c6952742aa733d15a872277", "filename": "gcc/d/dmd/tokens.d", "status": "modified", "additions": 27, "deletions": 18, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Ftokens.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Ftokens.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftokens.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -269,11 +269,13 @@ enum TOK : ubyte\n     _Thread_local,\n \n     // C only extended keywords\n+    _assert,\n     _import,\n     __cdecl,\n     __declspec,\n     __stdcall,\n     __pragma,\n+    __int128,\n     __attribute__,\n }\n \n@@ -579,11 +581,13 @@ private immutable TOK[] keywords =\n     TOK._Thread_local,\n \n     // C only extended keywords\n+    TOK._assert,\n     TOK._import,\n     TOK.__cdecl,\n     TOK.__declspec,\n     TOK.__stdcall,\n     TOK.__pragma,\n+    TOK.__int128,\n     TOK.__attribute__,\n ];\n \n@@ -612,7 +616,9 @@ static immutable TOK[TOK.max + 1] Ckeywords =\n                        restrict, return_, int16, signed, sizeof_, static_, struct_, switch_, typedef_,\n                        union_, unsigned, void_, volatile, while_, asm_, typeof_,\n                        _Alignas, _Alignof, _Atomic, _Bool, _Complex, _Generic, _Imaginary, _Noreturn,\n-                       _Static_assert, _Thread_local, _import, __cdecl, __declspec, __stdcall, __pragma, __attribute__ ];\n+                       _Static_assert, _Thread_local,\n+                       _import, __cdecl, __declspec, __stdcall, __pragma, __int128, __attribute__,\n+                       _assert ];\n \n         foreach (kw; Ckwds)\n             tab[kw] = cast(TOK) kw;\n@@ -878,11 +884,13 @@ extern (C++) struct Token\n         TOK._Thread_local  : \"_Thread_local\",\n \n         // C only extended keywords\n+        TOK._assert       : \"__check\",\n         TOK._import       : \"__import\",\n         TOK.__cdecl        : \"__cdecl\",\n         TOK.__declspec     : \"__declspec\",\n         TOK.__stdcall      : \"__stdcall\",\n         TOK.__pragma       : \"__pragma\",\n+        TOK.__int128       : \"__int128\",\n         TOK.__attribute__  : \"__attribute__\",\n     ];\n \n@@ -942,16 +950,17 @@ nothrow:\n \n     extern (C++) const(char)* toChars() const\n     {\n-        __gshared char[3 + 3 * floatvalue.sizeof + 1] buffer;\n+        const bufflen = 3 + 3 * floatvalue.sizeof + 1;\n+        __gshared char[bufflen] buffer;\n         const(char)* p = &buffer[0];\n         switch (value)\n         {\n         case TOK.int32Literal:\n-            sprintf(&buffer[0], \"%d\", cast(int)intvalue);\n+            snprintf(&buffer[0], bufflen, \"%d\", cast(int)intvalue);\n             break;\n         case TOK.uns32Literal:\n         case TOK.wchar_tLiteral:\n-            sprintf(&buffer[0], \"%uU\", cast(uint)unsvalue);\n+            snprintf(&buffer[0], bufflen, \"%uU\", cast(uint)unsvalue);\n             break;\n         case TOK.wcharLiteral:\n         case TOK.dcharLiteral:\n@@ -960,36 +969,36 @@ nothrow:\n                 OutBuffer buf;\n                 buf.writeSingleCharLiteral(cast(dchar) intvalue);\n                 buf.writeByte('\\0');\n-                p = buf.extractSlice().ptr;\n+                p = buf.extractChars();\n             }\n             break;\n         case TOK.int64Literal:\n-            sprintf(&buffer[0], \"%lldL\", cast(long)intvalue);\n+            snprintf(&buffer[0], bufflen, \"%lldL\", cast(long)intvalue);\n             break;\n         case TOK.uns64Literal:\n-            sprintf(&buffer[0], \"%lluUL\", cast(ulong)unsvalue);\n+            snprintf(&buffer[0], bufflen, \"%lluUL\", cast(ulong)unsvalue);\n             break;\n         case TOK.float32Literal:\n-            CTFloat.sprint(&buffer[0], 'g', floatvalue);\n+            CTFloat.sprint(&buffer[0], bufflen, 'g', floatvalue);\n             strcat(&buffer[0], \"f\");\n             break;\n         case TOK.float64Literal:\n-            CTFloat.sprint(&buffer[0], 'g', floatvalue);\n+            CTFloat.sprint(&buffer[0], bufflen, 'g', floatvalue);\n             break;\n         case TOK.float80Literal:\n-            CTFloat.sprint(&buffer[0], 'g', floatvalue);\n+            CTFloat.sprint(&buffer[0], bufflen, 'g', floatvalue);\n             strcat(&buffer[0], \"L\");\n             break;\n         case TOK.imaginary32Literal:\n-            CTFloat.sprint(&buffer[0], 'g', floatvalue);\n+            CTFloat.sprint(&buffer[0], bufflen, 'g', floatvalue);\n             strcat(&buffer[0], \"fi\");\n             break;\n         case TOK.imaginary64Literal:\n-            CTFloat.sprint(&buffer[0], 'g', floatvalue);\n+            CTFloat.sprint(&buffer[0], bufflen, 'g', floatvalue);\n             strcat(&buffer[0], \"i\");\n             break;\n         case TOK.imaginary80Literal:\n-            CTFloat.sprint(&buffer[0], 'g', floatvalue);\n+            CTFloat.sprint(&buffer[0], bufflen, 'g', floatvalue);\n             strcat(&buffer[0], \"Li\");\n             break;\n         case TOK.string_:\n@@ -1006,7 +1015,7 @@ nothrow:\n                 if (postfix)\n                     buf.writeByte(postfix);\n                 buf.writeByte(0);\n-                p = buf.extractSlice().ptr;\n+                p = buf.extractChars();\n             }\n             break;\n         case TOK.identifier:\n@@ -1116,7 +1125,7 @@ unittest\n     {\n         writeCharLiteral(buf, d);\n     }\n-    assert(buf.extractSlice() == `a\\n\\r\\t\\b\\f\\0\\x11\\u7233\\U00017233`);\n+    assert(buf[] == `a\\n\\r\\t\\b\\f\\0\\x11\\u7233\\U00017233`);\n }\n \n /**\n@@ -1147,11 +1156,11 @@ unittest\n {\n     OutBuffer buf;\n     writeSingleCharLiteral(buf, '\\'');\n-    assert(buf.extractSlice() == `'\\''`);\n+    assert(buf[] == `'\\''`);\n     buf.reset();\n     writeSingleCharLiteral(buf, '\"');\n-    assert(buf.extractSlice() == `'\"'`);\n+    assert(buf[] == `'\"'`);\n     buf.reset();\n     writeSingleCharLiteral(buf, '\\n');\n-    assert(buf.extractSlice() == `'\\n'`);\n+    assert(buf[] == `'\\n'`);\n }"}, {"sha": "87361f327a4f87cac2a7bedd1cc26c4d9f8f4e09", "filename": "gcc/d/dmd/tokens.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Ftokens.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Ftokens.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftokens.h?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -278,11 +278,13 @@ enum class TOK : unsigned char\n     _Thread_local_,\n \n     // C only extended keywords\n+    _assert,\n     _import,\n     cdecl_,\n     declspec,\n     stdcall,\n     pragma,\n+    int128_,\n     attribute__,\n \n     MAX,"}, {"sha": "de0129b5b332adba5f3882bfb8bb41fccb84e3b5", "filename": "gcc/d/dmd/traits.d", "status": "modified", "additions": 51, "deletions": 3, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Ftraits.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Ftraits.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftraits.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -122,7 +122,7 @@ ulong getTypePointerBitmap(Loc loc, Type t, Array!(ulong)* data)\n     {\n         alias visit = Visitor.visit;\n     public:\n-        extern (D) this(Array!(ulong)* _data, ulong _sz_size_t)\n+        extern (D) this(Array!(ulong)* _data, ulong _sz_size_t) scope\n         {\n             this.data = _data;\n             this.sz_size_t = _sz_size_t;\n@@ -634,6 +634,10 @@ Expression semanticTraits(TraitsExp e, Scope* sc)\n     }\n     if (e.ident == Id.isVirtualFunction)\n     {\n+        // @@@DEPRECATED2.121@@@\n+        // Deprecated in 2.101 - Can be removed from 2.121\n+        e.deprecation(\"`traits(isVirtualFunction)` is deprecated. Use `traits(isVirtualMethod)` instead\");\n+\n         if (dim != 1)\n             return dimError(1);\n \n@@ -739,6 +743,42 @@ Expression semanticTraits(TraitsExp e, Scope* sc)\n         auto se = new StringExp(e.loc, id.toString());\n         return se.expressionSemantic(sc);\n     }\n+    if (e.ident == Id.fullyQualifiedName) // https://dlang.org/spec/traits.html#fullyQualifiedName\n+    {\n+        if (dim != 1)\n+            return dimError(1);\n+\n+        Scope* sc2 = sc.push();\n+        sc2.flags = sc.flags | SCOPE.noaccesscheck | SCOPE.ignoresymbolvisibility;\n+        bool ok = TemplateInstance.semanticTiargs(e.loc, sc2, e.args, 1);\n+        sc2.pop();\n+        if (!ok)\n+            return ErrorExp.get();\n+\n+        const(char)[] fqn;\n+        auto o = (*e.args)[0];\n+        if (auto s = getDsymbolWithoutExpCtx(o))\n+        {\n+            if (s.semanticRun == PASS.initial)\n+                s.dsymbolSemantic(null);\n+\n+            fqn = s.toPrettyChars().toDString();\n+        }\n+        else if (auto t = getType(o))\n+        {\n+            fqn = t.toPrettyChars(true).toDString();\n+        }\n+        else\n+        {\n+            if (!isError(o))\n+                e.error(\"argument `%s` has no identifier\", o.toChars());\n+            return ErrorExp.get();\n+        }\n+        assert(fqn);\n+        auto se = new StringExp(e.loc, fqn);\n+        return se.expressionSemantic(sc);\n+\n+    }\n     if (e.ident == Id.getProtection || e.ident == Id.getVisibility)\n     {\n         if (dim != 1)\n@@ -995,6 +1035,13 @@ Expression semanticTraits(TraitsExp e, Scope* sc)\n             if (errors < global.errors)\n                 e.error(\"`%s` cannot be resolved\", eorig.toChars());\n \n+            if (e.ident == Id.getVirtualFunctions)\n+            {\n+                // @@@DEPRECATED2.121@@@\n+                // Deprecated in 2.101 - Can be removed from 2.121\n+                e.deprecation(\"`traits(getVirtualFunctions)` is deprecated. Use `traits(getVirtualMethods)` instead\");\n+            }\n+\n             /* Create tuple of functions of ex\n              */\n             auto exps = new Expressions();\n@@ -1676,7 +1723,7 @@ Expression semanticTraits(TraitsExp e, Scope* sc)\n             uint errors = global.startGagging();\n             Scope* sc2 = sc.push();\n             sc2.tinst = null;\n-            sc2.minst = null;\n+            sc2.minst = null;   // this is why code for these are not emitted to object file\n             sc2.flags = (sc.flags & ~(SCOPE.ctfe | SCOPE.condition)) | SCOPE.compile | SCOPE.fullinst;\n \n             bool err = false;\n@@ -2197,7 +2244,7 @@ private void traitNotFound(TraitsExp e)\n         initialized = true;     // lazy initialization\n \n         // All possible traits\n-        __gshared Identifier*[58] idents =\n+        __gshared Identifier*[59] idents =\n         [\n             &Id.isAbstractClass,\n             &Id.isArithmetic,\n@@ -2227,6 +2274,7 @@ private void traitNotFound(TraitsExp e)\n             &Id.isReturnOnStack,\n             &Id.hasMember,\n             &Id.identifier,\n+            &Id.fullyQualifiedName,\n             &Id.getProtection,\n             &Id.getVisibility,\n             &Id.parent,"}, {"sha": "84561ac467aa4d14aecebd5ace0bca6fbaca6620", "filename": "gcc/d/dmd/typesem.d", "status": "modified", "additions": 16, "deletions": 71, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Ftypesem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Ftypesem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftypesem.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -35,6 +35,7 @@ import dmd.dsymbol;\n import dmd.dsymbolsem;\n import dmd.dtemplate;\n import dmd.errors;\n+import dmd.errorsink;\n import dmd.expression;\n import dmd.expressionsem;\n import dmd.func;\n@@ -285,54 +286,10 @@ private void resolveHelper(TypeQualified mt, const ref Loc loc, Scope* sc, Dsymb\n                     return helper3();\n             }\n         }\n+\n         if (!sm)\n-        {\n-            if (!t)\n-            {\n-                if (s.isDeclaration()) // var, func, or tuple declaration?\n-                {\n-                    t = s.isDeclaration().type;\n-                    if (!t && s.isTupleDeclaration()) // expression tuple?\n-                        return helper3();\n-                }\n-                else if (s.isTemplateInstance() ||\n-                         s.isImport() || s.isPackage() || s.isModule())\n-                {\n-                    return helper3();\n-                }\n-            }\n-            if (t)\n-            {\n-                sm = t.toDsymbol(sc);\n-                if (sm && id.dyncast() == DYNCAST.identifier)\n-                {\n-                    sm = sm.search(loc, cast(Identifier)id, IgnorePrivateImports);\n-                    if (!sm)\n-                        return helper3();\n-                }\n-                else\n-                    return helper3();\n-            }\n-            else\n-            {\n-                if (id.dyncast() == DYNCAST.dsymbol)\n-                {\n-                    // searchX already handles errors for template instances\n-                    assert(global.errors);\n-                }\n-                else\n-                {\n-                    assert(id.dyncast() == DYNCAST.identifier);\n-                    sm = s.search_correct(cast(Identifier)id);\n-                    if (sm)\n-                        error(loc, \"identifier `%s` of `%s` is not defined, did you mean %s `%s`?\", id.toChars(), mt.toChars(), sm.kind(), sm.toChars());\n-                    else\n-                        error(loc, \"identifier `%s` of `%s` is not defined\", id.toChars(), mt.toChars());\n-                }\n-                pe = ErrorExp.get();\n-                return;\n-            }\n-        }\n+            return helper3();\n+\n         s = sm.toAlias();\n     }\n \n@@ -580,6 +537,7 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n         {\n             auto errors = global.errors;\n             mtype.dim = semanticLength(sc, tbn, mtype.dim);\n+            mtype.dim = mtype.dim.implicitCastTo(sc, Type.tsize_t);\n             if (errors != global.errors)\n                 return error();\n \n@@ -636,7 +594,7 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n                  * run on them for the size, since they may be forward referenced.\n                  */\n                 bool overflow = false;\n-                if (mulu(tbn.size(loc), d2, overflow) >= target.maxStaticDataSize || overflow)\n+                if (mulu(tbn.size(loc), d2, overflow) > target.maxStaticDataSize || overflow)\n                     return overflowError();\n             }\n         }\n@@ -1285,20 +1243,7 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n \n                 if (fparam.storageClass & STC.return_)\n                 {\n-                    if (fparam.isReference())\n-                    {\n-                        // Disabled for the moment awaiting improvement to allow return by ref\n-                        // to be transformed into return by scope.\n-                        if (0 && !tf.isref)\n-                        {\n-                            auto stc = fparam.storageClass & (STC.ref_ | STC.out_);\n-                            .error(loc, \"parameter `%s` is `return %s` but function does not return by `ref`\",\n-                                fparam.ident ? fparam.ident.toChars() : \"\",\n-                                stcToString(stc).ptr);\n-                            errors = true;\n-                        }\n-                    }\n-                    else\n+                    if (!fparam.isReference())\n                     {\n                         if (!(fparam.storageClass & STC.scope_))\n                             fparam.storageClass |= STC.scope_ | STC.scopeinferred; // 'return' implies 'scope'\n@@ -1389,7 +1334,6 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n             // extended index), as we need to run semantic when `oidx` changes.\n             size_t tupleOrigIdx = size_t.max;\n             size_t tupleExtIdx = size_t.max;\n-            bool hasDefault;\n             foreach (oidx, oparam, eidx, eparam; tf.parameterList)\n             {\n                 // oparam (original param) will always have the default arg\n@@ -1398,7 +1342,6 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n                 // position to get the offset in it later on.\n                 if (oparam.defaultArg)\n                 {\n-                    hasDefault = true;\n                     // Get the obvious case out of the way\n                     if (oparam is eparam)\n                         errors |= !defaultArgSemantic(eparam, argsc);\n@@ -1425,11 +1368,6 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n                             eparam.defaultArg = (*te.exps)[eidx - tupleExtIdx];\n                     }\n                 }\n-                else if (hasDefault)\n-                {\n-                    .error(loc, \"default argument expected for `%s`\", oparam.toChars());\n-                    errors = true;\n-                }\n \n                 // We need to know the default argument to resolve `auto ref`,\n                 // hence why this has to take place as the very last step.\n@@ -3912,8 +3850,15 @@ Expression dotExp(Type mt, Scope* sc, Expression e, Identifier ident, int flag)\n             {\n                 /* Rewrite as:\n                  *  this.d\n+                 *\n+                 * only if the scope in which we are\n+                 * has a `this` that matches the type\n+                 * of the lhs of the dot expression.\n+                 *\n+                 * https://issues.dlang.org/show_bug.cgi?id=23617\n                  */\n-                if (hasThis(sc))\n+                auto fd = hasThis(sc);\n+                if (fd && fd.isThis() == mt.sym)\n                 {\n                     e = new DotVarExp(e.loc, new ThisExp(e.loc), d);\n                     return e.expressionSemantic(sc);\n@@ -4973,7 +4918,7 @@ RootObject compileTypeMixin(TypeMixin tm, Loc loc, Scope* sc)\n     const len = buf.length;\n     buf.writeByte(0);\n     const str = buf.extractSlice()[0 .. len];\n-    scope p = new Parser!ASTCodegen(loc, sc._module, str, false);\n+    scope p = new Parser!ASTCodegen(loc, sc._module, str, false, global.errorSink);\n     p.nextToken();\n     //printf(\"p.loc.linnum = %d\\n\", p.loc.linnum);\n "}, {"sha": "2ca71437d14a9a4383e6c63d7214b833d6bdc77e", "filename": "gcc/d/dmd/typinf.d", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Ftypinf.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Ftypinf.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftypinf.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -105,10 +105,11 @@ extern (C++) void genTypeInfo(Expression e, const ref Loc loc, Type torig, Scope\n  *      loc = the location for reporting line nunbers in errors\n  *      t   = the type to get the type of the `TypeInfo` object for\n  *      sc  = the scope\n+ *      genObjCode = if true, object code will be generated for the obtained TypeInfo\n  * Returns:\n  *      The type of the `TypeInfo` object associated with `t`\n  */\n-extern (C++) Type getTypeInfoType(const ref Loc loc, Type t, Scope* sc);\n+extern (C++) Type getTypeInfoType(const ref Loc loc, Type t, Scope* sc, bool genObjCode = true);\n \n private TypeInfoDeclaration getTypeInfoDeclaration(Type t)\n {"}, {"sha": "8990ce49a2a9dd7aedae0bdc280221709d165645", "filename": "gcc/d/dmd/visitor.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fvisitor.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fdmd%2Fvisitor.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fvisitor.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -248,7 +248,7 @@ extern (C++) class StoppableVisitor : Visitor\n public:\n     bool stop;\n \n-    final extern (D) this()\n+    final extern (D) this() scope\n     {\n     }\n }"}, {"sha": "c6245ff5fc19f4b89eeb8ce4bae4862c3526f6ef", "filename": "gcc/d/expr.cc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fexpr.cc?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -2277,8 +2277,7 @@ class ExprVisitor : public Visitor\n \telse\n \t  {\n \t    /* Generate: _d_newclass()  */\n-\t    tree arg = build_address (get_classinfo_decl (cd));\n-\t    new_call = build_libcall (LIBCALL_NEWCLASS, tb, 1, arg);\n+\t    new_call = build_expr (e->lowering);\n \t  }\n \n \t/* Set the context pointer for nested classes.  */"}, {"sha": "bb0a3dcc911bb2e24f9250853d275095415334ef", "filename": "gcc/d/lang.opt", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Flang.opt?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -360,10 +360,6 @@ fpreview=dip1021\n D RejectNegative\n Implement DIP1021: Mutable function arguments.\n \n-fpreview=dip25\n-D RejectNegative\n-Implement DIP25: Sealed references.\n-\n fpreview=dtorfields\n D RejectNegative\n Destruct fields of partially constructed objects.\n@@ -412,10 +408,6 @@ frevert=dip1000\n D RejectNegative\n Revert DIP1000: Scoped pointers.\n \n-frevert=dip25\n-D RejectNegative\n-Revert DIP25: Sealed references.\n-\n frevert=dtorfields\n D RejectNegative\n Don't destruct fields of partially constructed objects."}, {"sha": "f2180d30546ea5b0c975aa06815c3705a831b612", "filename": "gcc/d/modules.cc", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fmodules.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fmodules.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fmodules.cc?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -530,11 +530,7 @@ layout_moduleinfo_fields (Module *decl, tree type)\n \n   /* Array of local ClassInfo decls are laid out in the same way.  */\n   ClassDeclarations aclasses;\n-  for (size_t i = 0; i < decl->members->length; i++)\n-    {\n-      Dsymbol *member = (*decl->members)[i];\n-      member->addLocalClass (&aclasses);\n-    }\n+  getLocalClasses (decl, aclasses);\n \n   if (aclasses.length)\n     {\n@@ -564,11 +560,7 @@ layout_moduleinfo (Module *decl)\n   ClassDeclarations aclasses;\n   FuncDeclaration *sgetmembers;\n \n-  for (size_t i = 0; i < decl->members->length; i++)\n-    {\n-      Dsymbol *member = (*decl->members)[i];\n-      member->addLocalClass (&aclasses);\n-    }\n+  getLocalClasses (decl, aclasses);\n \n   size_t aimports_dim = decl->aimports.length;\n   for (size_t i = 0; i < decl->aimports.length; i++)"}, {"sha": "23f8b64324efb4546c07eac4fbfbfe444eaf4de8", "filename": "gcc/d/runtime.def", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fruntime.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Fruntime.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fruntime.def?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -59,9 +59,6 @@ DEF_D_RUNTIME (ARRAYBOUNDS_SLICEP, \"_d_arraybounds_slicep\", RT(VOID),\n DEF_D_RUNTIME (ARRAYBOUNDS_INDEXP, \"_d_arraybounds_indexp\", RT(VOID),\n \t       P4(IMMUTABLE_CHARPTR, UINT, SIZE_T, SIZE_T), ECF_NORETURN)\n \n-/* Used when calling new on a class.  */\n-DEF_D_RUNTIME (NEWCLASS, \"_d_newclass\", RT(OBJECT), P1(CONST_CLASSINFO), 0)\n-\n /* Used when calling delete on a stack-allocated class or interface.  */\n DEF_D_RUNTIME (CALLFINALIZER, \"_d_callfinalizer\", RT(VOID), P1(VOIDPTR), 0)\n DEF_D_RUNTIME (CALLINTERFACEFINALIZER, \"_d_callinterfacefinalizer\", RT(VOID),"}, {"sha": "8bd6eb63d51e343d8aa5b78c8b8d94aa0f700270", "filename": "gcc/d/toir.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Ftoir.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Ftoir.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Ftoir.cc?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -582,8 +582,9 @@ class IRVisitor : public Visitor\n     tree ifbody = void_node;\n     tree elsebody = void_node;\n \n-    /* Build the `then' branch.  */\n-    if (s->ifbody)\n+    /* Build the `then' branch, don't do code generation when the condition\n+       is `if (__ctfe)', as that is always false at run-time.  */\n+    if (s->ifbody && !s->isIfCtfeBlock ())\n       {\n \tpush_stmt_list ();\n \tthis->build_stmt (s->ifbody);"}, {"sha": "1c5e50c03c0962ca36225bb928c21478615a25f5", "filename": "gcc/d/typeinfo.cc", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Ftypeinfo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Ftypeinfo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Ftypeinfo.cc?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1524,10 +1524,12 @@ get_cpp_typeinfo_decl (ClassDeclaration *decl)\n   return decl->cpp_type_info_ptr_sym;\n }\n \n-/* Get the exact TypeInfo for TYPE, if it doesn't exist, create it.  */\n+/* Get the exact TypeInfo for TYPE, if it doesn't exist, create it.\n+   When GENERATE is true, push the TypeInfo as a member of MOD so that it will\n+   get code generation. */\n \n void\n-create_typeinfo (Type *type, Module *mod)\n+create_typeinfo (Type *type, Module *mod, bool generate)\n {\n   if (!Type::dtypeinfo)\n     create_frontend_tinfo_types ();\n@@ -1685,7 +1687,7 @@ create_typeinfo (Type *type, Module *mod)\n \n       /* If this has a custom implementation in rt/typeinfo, then\n \t do not generate a COMDAT for it.  */\n-      if (!builtin_typeinfo_p (t))\n+      if (generate && !builtin_typeinfo_p (t))\n \t{\n \t  /* Find module that will go all the way to an object file.  */\n \t  if (mod)"}, {"sha": "beaf2a61af999d833be0f67a01e87b6873122ebd", "filename": "gcc/d/types.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Fd%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Ftypes.cc?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -381,9 +381,9 @@ layout_aggregate_members (Dsymbols *members, tree context, bool inherited_p)\n \t    continue;\n \n \t  /* If this variable was really a tuple, add all tuple fields.  */\n-\t  if (var->aliassym)\n+\t  if (var->aliasTuple)\n \t    {\n-\t      TupleDeclaration *td = var->aliassym->isTupleDeclaration ();\n+\t      TupleDeclaration *td = var->aliasTuple;\n \t      Dsymbols tmembers;\n \t      /* No other way to coerce the underlying type out of the tuple.\n \t\t Frontend should have already validated this.  */"}, {"sha": "ad18813a562c341a84551ae87d0a7f60403c3880", "filename": "gcc/testsuite/gdc.dg/torture/simd23084.d", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.dg%2Ftorture%2Fsimd23084.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.dg%2Ftorture%2Fsimd23084.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Ftorture%2Fsimd23084.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,16 @@\n+// https://issues.dlang.org/show_bug.cgi?id=23084\n+// { dg-additional-options \"-mavx\" { target avx_runtime } }\n+// { dg-do compile { target { avx_runtime || vect_sizes_16B_8B } } }\n+// { dg-skip-if \"needs gcc/config.d\" { ! d_runtime } }\n+\n+__vector(int[4]) test23084a(__vector(int[4]) a)\n+{\n+    __vector(short[8]) r = cast(short)(a.array[0]);\n+    return cast(__vector(int[4]))r;\n+}\n+\n+__vector(int[4]) test23084b(__vector(int[4]) a)\n+{\n+    __vector(byte[16]) r = cast(byte)(a.array[0]);\n+    return cast(__vector(int[4]))r;\n+}"}, {"sha": "66444addc0d7b1dee49ae07811af37e014fdce42", "filename": "gcc/testsuite/gdc.dg/torture/simd23085.d", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.dg%2Ftorture%2Fsimd23085.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.dg%2Ftorture%2Fsimd23085.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Ftorture%2Fsimd23085.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,11 @@\n+// https://issues.dlang.org/show_bug.cgi?id=23085\n+// { dg-additional-options \"-mavx\" { target avx_runtime } }\n+// { dg-do compile }\n+// { dg-skip-if \"needs gcc/config.d\" { ! d_runtime } }\n+\n+float test23085(float x)\n+{\n+    byte i = *cast(byte*)&x;\n+    ++i;\n+    return *cast(float*)&i; // this cast is not allowed in @safe code\n+}"}, {"sha": "865fc825f9dd17ddb275e74b8e6d5e6f2e98a599", "filename": "gcc/testsuite/gdc.dg/torture/simd23218.d", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.dg%2Ftorture%2Fsimd23218.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.dg%2Ftorture%2Fsimd23218.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Ftorture%2Fsimd23218.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,15 @@\n+// https://issues.dlang.org/show_bug.cgi?id=23218\n+// { dg-additional-options \"-mavx\" { target avx_runtime } }\n+// { dg-do run { target { avx_runtime || vect_sizes_16B_8B } } }\n+// { dg-skip-if \"needs gcc/config.d\" { ! d_runtime } }\n+\n+__vector(int[4]) convtest(int[4] a)\n+{\n+    return cast(__vector(int[4]))a;\n+}\n+\n+void main()\n+{\n+    static assert(convtest([1,2,3,4])[0] == 1);\n+    assert(convtest([1,2,3,4])[0] == 1);\n+}"}, {"sha": "1eb1dcde542682caa37bffa01e2de1c406a07b6e", "filename": "gcc/testsuite/gdc.test/compilable/b23620.d", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fb23620.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fb23620.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fb23620.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,10 @@\n+// https://issues.dlang.org/show_bug.cgi?id=23620\n+struct Index\n+{\n+    uint value;\n+    alias value this;\n+}\n+\n+enum i = Index();\n+int[i] a;\n+static assert(a.length == 0);"}, {"sha": "a0fb8333d1b37004f5fb69f35549e32e7ad4ca54", "filename": "gcc/testsuite/gdc.test/compilable/extra-files/header18365.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fextra-files%2Fheader18365.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fextra-files%2Fheader18365.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fextra-files%2Fheader18365.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1,5 +1,5 @@\n module foo.bar.ba;\n-nothrow pure @nogc @safe package(foo) \n+nothrow pure @nogc @safe package(foo)\n {\n \tvoid foo();\n \tnothrow pure @nogc @safe package(foo.bar) void foo2();"}, {"sha": "74f035e40d3de15e195e35f43a3ffaf9fc80d753", "filename": "gcc/testsuite/gdc.test/compilable/extra-files/imp9057.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fextra-files%2Fimp9057.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fextra-files%2Fimp9057.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fextra-files%2Fimp9057.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1,5 +1,5 @@\n struct BugInt\n {\n-    uint[] data = ZEROX;  \n+    uint[] data = ZEROX;\n }\n enum uint [] ZEROX = [0];"}, {"sha": "a1345929e14de5f211f6b134b80956ed8c55f4a4", "filename": "gcc/testsuite/gdc.test/compilable/extra-files/test23626a.d", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fextra-files%2Ftest23626a.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fextra-files%2Ftest23626a.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fextra-files%2Ftest23626a.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,49 @@\n+template fullyQualifiedName(T...)\n+{\n+    enum fullyQualifiedName = !T[0];\n+}\n+\n+void __trace_maybeDumpTupleToFile(Args...)(auto ref const Args args) nothrow @nogc { }\n+\n+int getStructInfoEx(T)() {\n+   enum Ctx = fullyQualifiedName!T;\n+   return 0;\n+}\n+\n+auto as(Func)(Func) {}\n+\n+@nogc void foo() { }\n+\n+void assertOp(string OPERATION, LHS, RHS)(LHS lhs, RHS) {\n+  as({\n+    try {\n+      try as(lhs);\n+      catch(Throwable) foo();\n+    } catch(Throwable) assert(false);\n+  });\n+}\n+\n+struct FixedArray(T, size_t capacity_) {\n+  int a = getStructInfoEx!FixedArray;\n+\n+  T* some_function() {\n+    assertOp !\"\"(1, 1);\n+    return null;\n+  }\n+  alias some_function this;\n+}\n+\n+struct ReclamationBatch {\n+\n+  FixedArray !(uint,1) dummy;\n+\n+  @nogc nothrow void some_inout_func() inout { }\n+\n+  void func_2(Dlg)(Dlg dlg) {\n+    __trace_maybeDumpTupleToFile(dlg);\n+  }\n+\n+  void _reclaimBatch() {\n+    func_2({ some_inout_func; });\n+  }\n+}"}, {"sha": "8bb2af5276a59bb580dadac77c10d10ea15c1968", "filename": "gcc/testsuite/gdc.test/compilable/extra-files/test23626b.d", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fextra-files%2Ftest23626b.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fextra-files%2Ftest23626b.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fextra-files%2Ftest23626b.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,14 @@\n+interface Timeline {\n+}\n+\n+struct Policy {\n+  alias OldTagCallback = void delegate() @nogc nothrow;\n+  Timeline timeline;\n+  OldTagCallback oldTagCB;\n+}\n+\n+import test23626;\n+\n+struct Tiering {\n+    StaticHashTable!(Policy) policies;\n+}"}, {"sha": "a4540d1eac87d5bd1be2898117eedbdc491949a1", "filename": "gcc/testsuite/gdc.test/compilable/ice13920.d", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fice13920.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fice13920.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fice13920.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -14,11 +14,6 @@ class Foo\n         {\n             auto dg = &f;\n         }\n-\n-        foreach (f; __traits(getVirtualFunctions, typeof(this), \"bar\"))\n-        {\n-            auto dg = &f;\n-        }\n     }\n \n     uint bar() { return 0; }"}, {"sha": "1556bc9e3d986fef0ee3cdec2ea3027247df713e", "filename": "gcc/testsuite/gdc.test/compilable/imports/imp23662.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fimp23662.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fimp23662.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fimp23662.c?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,6 @@\n+// https://issues.dlang.org/show_bug.cgi?id=23662\n+typedef enum {A} E;\n+\n+E func(E v) {\n+    return v;\n+}"}, {"sha": "50140e73d2b16fc3de31fdba5d57a64894be0bed", "filename": "gcc/testsuite/gdc.test/compilable/infer_stc.d", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Finfer_stc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Finfer_stc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Finfer_stc.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,51 @@\n+/// Test storage class inference on delegate parameters\n+\n+alias FPT = void function (in string, ref string, out string, scope string);\n+alias DGT = void delegate (in string, ref string, out string, scope string);\n+\n+void f1 (FPT func)\n+{\n+    string ro = \"Hello World\";\n+    string ref_ = ro, out_ = ro;\n+    func(ro, ref_, out_, ro);\n+}\n+\n+void f2 (DGT func)\n+{\n+    string ro = \"Hello World\";\n+    string ref_ = ro, out_ = ro;\n+    func(ro, ref_, out_, ro);\n+}\n+\n+void test ()\n+{\n+    f1((in_, ref_, out_, scope_) {\n+            assert(in_ == \"Hello World\");\n+            assert(in_ == scope_);\n+            assert(in_ == ref_);\n+            assert(out_ is null);\n+        });\n+\n+    f2((in_, ref_, out_, scope_) {\n+            assert(in_ == \"Hello World\");\n+            assert(in_ == scope_);\n+            assert(in_ == ref_);\n+            assert(out_ is null);\n+        });\n+}\n+\n+// https://issues.dlang.org/show_bug.cgi?id=11316\n+void issue11316() {\n+    void delegate(const int x) F0;\n+    F0 = (const int x) {}; // OK\n+    F0 = (x) {};           // OK\n+    void delegate(in int x) F1;\n+    F1 = (in int x) {};    // OK\n+    F1 = (x) {};           // OK\n+    void delegate(ref int x) F2;\n+    F2 = (ref int x) {};   // OK\n+    F2 = (x) {};           // Error\n+    void delegate(out int x) F3;\n+    F3 = (out int x) {};   // OK\n+    F3 = (x) {};           // Error\n+}"}, {"sha": "0c60509dda8d73b12b2a9c381133768478208d16", "filename": "gcc/testsuite/gdc.test/compilable/named_argumens_struct.d", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fnamed_argumens_struct.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fnamed_argumens_struct.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fnamed_argumens_struct.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,24 @@\n+\n+struct S\n+{\n+    string name;\n+    int x;\n+    int y;\n+}\n+\n+\n+immutable S s = S(x: 2, 3, name: \"boo\");\n+\n+static assert(s.x == 2);\n+static assert(s.y == 3);\n+static assert(s.name == \"boo\");\n+\n+union U\n+{\n+    float f;\n+    int i;\n+}\n+\n+immutable U u = U(i: 2);\n+\n+static assert(u.i == 2);"}, {"sha": "f287ccdea959782035dbd88fd0736489af188316", "filename": "gcc/testsuite/gdc.test/compilable/named_arguments.d", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fnamed_arguments.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fnamed_arguments.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fnamed_arguments.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,74 @@\n+\n+string fun(string x, string y, string z = \"Z\", string w = \"W\")\n+{\n+\treturn x ~ y ~ z ~ w;\n+}\n+\n+static assert(fun(   \"x\",    \"y\") == \"xyZW\");\n+static assert(fun(   \"x\",    \"y\", \"z\", \"w\") == \"xyzw\");\n+static assert(fun(x: \"x\", y: \"y\", z: \"z\", w: \"w\") == \"xyzw\");\n+static assert(fun(w: \"w\", z: \"z\", y: \"y\", x: \"x\") == \"xyzw\");\n+static assert(fun(y: \"y\",    \"z\", x: \"x\") == \"xyzW\");\n+static assert(fun(   \"x\",    \"y\", w: \"w\") == \"xyZw\");\n+static assert(fun(x: \"x\",    \"y\", z: \"z\") == \"xyzW\");\n+\n+// Default arguments need not all be at the end anymore\n+string fun2(string x = \"x\", string y, string z = \"z\")\n+{\n+\treturn x ~ y ~ z;\n+}\n+\n+static assert(fun2(y: \"y\") == \"xyz\");\n+\n+// The assumption that first parameter having a default implies all parameters have a default is no longer valid,\n+// so this struct constructor shouldn't be mistaken for a default constructor.\n+struct SD { this(int x = 1, int y) { } }\n+\n+// UFCS\n+static assert(\"x\".fun(\"y\", w: \"w\") == \"xyZw\");\n+\n+// tuples\n+alias AliasSeq(T...) = T;\n+\n+static assert(\"x\".fun(x: AliasSeq!(), \"y\", w: \"w\") == \"xyZw\");\n+static assert(AliasSeq!(\"x\", \"y\").fun(w: \"w\", z: AliasSeq!()) == \"xyZw\");\n+static assert(fun(y: AliasSeq!(\"y\", \"z\", \"w\"), x: \"x\") == \"xyzw\");\n+\n+// `new` expressions\n+class C\n+{\n+\tint x, y;\n+\n+\tthis(int x, int y)\n+\t{\n+\t\tthis.x = x;\n+\t\tthis.y = y;\n+\t}\n+\n+\tstatic C opCall(int x, int y) { return new C(x, y); }\n+}\n+\n+struct S\n+{\n+\tint x, y;\n+}\n+\n+static assert(new C(y: 3, x: 2).x == 2);\n+static assert(    C(y: 3, x: 2).x == 2);\n+static assert(new S(y: 3, x: 2).x == 2);\n+static assert(    S(y: 3, x: 2).x == 2);\n+\n+// opCall\n+struct Div\n+{\n+    static int opCall(int numer, int denom) { return numer / denom; }\n+}\n+static assert(Div(denom: 3, numer: 6) == 2);\n+\n+struct Concat\n+{\n+\tstring s = \"s\";\n+    string opCall(string st0, string st1) { return s ~ st0 ~ st1; }\n+}\n+\n+static assert(Concat.init(\"t0\", \"t1\") == \"st0t1\");"}, {"sha": "44f54f7468ab394a511120e846051fb1a4eb54d6", "filename": "gcc/testsuite/gdc.test/compilable/scope.d", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fscope.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fscope.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fscope.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -253,3 +253,12 @@ void main21209()\n     testForeach(cs);\n     testForeach(fs);\n }\n+\n+struct S23669\n+{\n+    string[] a;\n+    @safe void reserve() scope\n+    {\n+        a.length += 1;\n+    }\n+}"}, {"sha": "695083a5476e90a515e2735cc706a3dcee718a28", "filename": "gcc/testsuite/gdc.test/compilable/shared.d", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fshared.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fshared.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fshared.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -123,3 +123,10 @@ struct Parent\n         ch = shared Child(i);\n     }\n }\n+\n+// https://issues.dlang.org/show_bug.cgi?id=23732\n+class Class {}\n+void main()\n+{\n+    auto b = new shared Class();\n+}"}, {"sha": "70f11be49b89a7ae401f95dac0d3bc6ad2bdfa2c", "filename": "gcc/testsuite/gdc.test/compilable/test16495.d", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest16495.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest16495.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest16495.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,117 @@\n+// https://issues.dlang.org/show_bug.cgi?id=16495\n+\n+void types()\n+{\n+    static assert(__traits(fullyQualifiedName, string) == \"string\");\n+    static assert(__traits(fullyQualifiedName, wstring) == \"wstring\");\n+    static assert(__traits(fullyQualifiedName, dstring) == \"dstring\");\n+    static assert(__traits(fullyQualifiedName, typeof(null)) == \"typeof(null)\");\n+    static assert(__traits(fullyQualifiedName, void) == \"void\");\n+    static assert(__traits(fullyQualifiedName, const(void)) == \"const(void)\");\n+    static assert(__traits(fullyQualifiedName, shared(void)) == \"shared(void)\");\n+    static assert(__traits(fullyQualifiedName, shared const(void)) == \"shared(const(void))\");\n+    static assert(__traits(fullyQualifiedName, shared inout(void)) == \"shared(inout(void))\");\n+    static assert(__traits(fullyQualifiedName, shared inout const(void)) == \"shared(inout(const(void)))\");\n+    static assert(__traits(fullyQualifiedName, inout(void)) == \"inout(void)\");\n+    static assert(__traits(fullyQualifiedName, inout const(void)) == \"inout(const(void))\");\n+    static assert(__traits(fullyQualifiedName, immutable(void)) == \"immutable(void)\");\n+}\n+\n+struct QualifiedNameTests\n+{\n+    struct Inner\n+    {\n+        bool value;\n+    }\n+\n+    ref const(Inner[string]) func( ref Inner var1, lazy scope string var2 );\n+    ref const(Inner[string]) retfunc( return ref Inner var1 );\n+    Inner inoutFunc(inout Inner) inout;\n+    shared(const(Inner[string])[]) data;\n+    const Inner delegate(double, string) @safe nothrow deleg;\n+    inout(int) delegate(inout int) inout inoutDeleg;\n+    Inner function(out double, string) funcPtr;\n+    extern(C) Inner function(double, string) cFuncPtr;\n+\n+    extern(C) void cVarArg(int, ...);\n+    void dVarArg(...);\n+    void dVarArg2(int, ...);\n+    void typesafeVarArg(int[] ...);\n+\n+    Inner[] array;\n+    Inner[16] sarray;\n+    Inner[Inner] aarray;\n+    const(Inner[const(Inner)]) qualAarray;\n+\n+    shared(immutable(Inner) delegate(ref double, scope string) const shared @trusted nothrow) attrDeleg;\n+\n+    struct Data(T) { int x; }\n+    void tfunc(T...)(T args) {}\n+\n+    template Inst(alias A) { int x; }\n+\n+    class Test12309(T, int x, string s) {}\n+}\n+\n+void symbols()\n+{\n+    alias qnTests = QualifiedNameTests;\n+    enum prefix = \"test16495.QualifiedNameTests.\";\n+    static assert(__traits(fullyQualifiedName, qnTests.Inner)           == prefix ~ \"Inner\");\n+    static assert(__traits(fullyQualifiedName, qnTests.func)            == prefix ~ \"func\");\n+\n+    static assert(__traits(fullyQualifiedName, qnTests.Data!int)        == prefix ~ \"Data!int.Data\");\n+    static assert(__traits(fullyQualifiedName, qnTests.Data!int.x)      == prefix ~ \"Data!int.Data.x\");\n+    static assert(__traits(fullyQualifiedName, qnTests.tfunc!(int[]))   == prefix ~ \"tfunc!(int[]).tfunc\");\n+    static assert(__traits(fullyQualifiedName, qnTests.Inst!(Object))   == prefix ~ \"Inst!(Object)\");\n+    static assert(__traits(fullyQualifiedName, qnTests.Inst!(Object).x) == prefix ~ \"Inst!(Object).x\");\n+    static assert(__traits(fullyQualifiedName, qnTests.Test12309!(int, 10, \"str\"))\n+                                                == prefix ~ \"Test12309!(int, 10, \\\"str\\\").Test12309\");\n+}\n+\n+void names()\n+{\n+    enum prefix = \"test16495.QualifiedNameTests\";\n+    enum xx = prefix ~ \".Inner\";\n+    with (QualifiedNameTests)\n+    {\n+        // Basic qualified name\n+        static assert(__traits(fullyQualifiedName, Inner) == xx);\n+\n+        // Array types\n+        static assert(__traits(fullyQualifiedName, typeof(array)) == xx ~ \"[]\");\n+        static assert(__traits(fullyQualifiedName, typeof(sarray)) == xx ~ \"[16]\");\n+        static assert(__traits(fullyQualifiedName, typeof(aarray)) == xx ~ \"[\" ~ xx ~ \"]\");\n+\n+        // qualified key for AA\n+        static assert(__traits(fullyQualifiedName, typeof(qualAarray)) == \"const(\" ~ xx ~ \"[const(\" ~ xx ~ \")])\");\n+\n+        // Qualified composed data types\n+        static assert(__traits(fullyQualifiedName, typeof(data)) == \"shared(const(\" ~ xx ~ \"[string])[])\");\n+\n+        // Function types + function attributes\n+        static assert(__traits(fullyQualifiedName, typeof(func)) == \"ref const(\" ~ xx ~ \"[string])(ref \" ~ xx ~ \", lazy scope string)\");\n+        static assert(__traits(fullyQualifiedName, typeof(retfunc)) == \"ref const(\" ~ xx ~ \"[string])(return ref \" ~ xx ~ \")\");\n+        static assert(__traits(fullyQualifiedName, typeof(inoutFunc)) == \"inout \"~xx~\"(inout(\"~xx~\"))\");\n+        static assert(__traits(fullyQualifiedName, typeof(deleg)) == \"const(\" ~ xx ~ \" delegate(double, string) nothrow @safe)\");\n+        static assert(__traits(fullyQualifiedName, typeof(inoutDeleg)) == \"inout(int) delegate(inout(int)) inout\");\n+        static assert(__traits(fullyQualifiedName, typeof(funcPtr)) == \"\" ~ xx ~ \" function(out double, string)\");\n+        static assert(__traits(fullyQualifiedName, typeof(cFuncPtr)) == \"extern (C) \" ~ xx ~ \" function(double, string)\");\n+\n+        // Delegate type with qualified function type\n+        static assert(__traits(fullyQualifiedName, typeof(attrDeleg)) == \"shared(immutable(\" ~ xx ~ \") \"~\n+            \"delegate(ref double, scope string) shared const nothrow @trusted)\");\n+\n+        // Variable argument function types\n+        static assert(__traits(fullyQualifiedName, typeof(cVarArg)) == \"extern (C) void(int, ...)\");\n+        static assert(__traits(fullyQualifiedName, typeof(dVarArg)) == \"void(...)\");\n+        static assert(__traits(fullyQualifiedName, typeof(dVarArg2)) == \"void(int, ...)\");\n+        static assert(__traits(fullyQualifiedName, typeof(typesafeVarArg)) == \"void(int[]...)\");\n+\n+        // SIMD vector\n+        static if (is(__vector(float[4])))\n+        {\n+            static assert(__traits(fullyQualifiedName, __vector(float[4])) == \"__vector(float[4])\");\n+        }\n+    }\n+}"}, {"sha": "97d83b4b409d95edee52c7305b4b97424cde321d", "filename": "gcc/testsuite/gdc.test/compilable/test18026.d", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest18026.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest18026.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest18026.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,12 @@\n+// https://issues.dlang.org/show_bug.cgi?id=18026\n+bool f(T)(T x)\n+{\n+    return false;\n+}\n+\n+static foreach(i; 0..60000)\n+{\n+    static if(f(i))\n+    {\n+    }\n+}"}, {"sha": "ff224033c72d0c03cdda86a06debdf4ac2e60d78", "filename": "gcc/testsuite/gdc.test/compilable/test19268.d", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest19268.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest19268.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest19268.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,6 @@\n+/* REQUIRED_ARGS: -betterC\n+ */\n+\n+// https://issues.dlang.org/show_bug.cgi?id=19268\n+\n+mixin(`void foo(){}`.idup);"}, {"sha": "b0419d6a34568f7d04dc2b432eebbcf5cab84308", "filename": "gcc/testsuite/gdc.test/compilable/test20201.d", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest20201.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest20201.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest20201.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,16 @@\n+/* REQUIRED_ARGS: -betterC\n+ */\n+\n+// https://issues.dlang.org/show_bug.cgi?id=20101\n+\n+public string ctfeHelper()(string a)\n+{\n+    return \"int \" ~ a ~ \" = 42;\";\n+}\n+\n+extern(C) int main()\n+{\n+    int b = __traits(compiles, ctfeHelper(\"a\"));\n+    mixin(ctfeHelper(\"a\"));\n+    return !(a + b);\n+}"}, {"sha": "47d788128b3b760c7f52367b84189b0ca19b4855", "filename": "gcc/testsuite/gdc.test/compilable/test21073.d", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e2c3dd6afcf9b152df72b30e205b0180c0afd5/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21073.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e2c3dd6afcf9b152df72b30e205b0180c0afd5/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21073.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21073.d?ref=c5e2c3dd6afcf9b152df72b30e205b0180c0afd5", "patch": "@@ -1,16 +0,0 @@\n-// https://issues.dlang.org/show_bug.cgi?id=21073\n-\n-class C\n-{\n-    auto internal() const\n-    {\n-        return 5;\n-    }\n-    alias internal this;\n-}\n-\n-void main() pure\n-{\n-    const c = new C;\n-    auto r = cast(C)c;\n-}"}, {"sha": "4914264aaf9b43c43bcfe74e0f22413d7444a00a", "filename": "gcc/testsuite/gdc.test/compilable/test21543.d", "status": "removed", "additions": 0, "deletions": 116, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e2c3dd6afcf9b152df72b30e205b0180c0afd5/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21543.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e2c3dd6afcf9b152df72b30e205b0180c0afd5/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21543.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21543.d?ref=c5e2c3dd6afcf9b152df72b30e205b0180c0afd5", "patch": "@@ -1,116 +0,0 @@\n-// https://issues.dlang.org/show_bug.cgi?id=21543\n-\n-class B\n-{\n-    Nullable!B data;\n-    alias data this;\n-}\n-\n-void test1()\n-{\n-    B b;\n-    Nullable!B n;\n-}\n-\n-struct Nullable(T)\n-{\n-    T payload;\n-\n-    void opAssign()(T)\n-    {\n-        move(payload);\n-    }\n-\n-    inout(T) get_() inout\n-    {\n-        return payload;\n-    }\n-\n-    alias get_ this;\n-}\n-\n-// another version with chain of 3 alias this\n-\n-struct C\n-{\n-    Nullable2 data;\n-    alias data this;\n-}\n-\n-void test2()\n-{\n-    C c;\n-    Nullable2 n2 = &c;\n-    Nullable3 n3 = &c;\n-\n-    // these are to check a sane -vcg-ast output\n-    fn1(c);\n-    fn1(n2);\n-    fn1(n3);\n-    fn2(c);\n-    fn2(n2);\n-    fn2(n3);\n-    fn3(c);\n-    fn3(n2);\n-    fn3(n3);\n-}\n-\n-void fn1(C x) {}\n-\n-void fn2(Nullable2 x) {}\n-\n-void fn3(Nullable3 x) {}\n-\n-struct Nullable2\n-{\n-    Nullable3 payload;\n-\n-    this(C* c)\n-    {\n-        payload = Nullable3(c);\n-    }\n-\n-    void opAssign()(Nullable3)\n-    {\n-        move(payload);\n-    }\n-\n-    inout(Nullable3) get_() inout\n-    {\n-        return payload;\n-    }\n-\n-    alias get_ this;\n-}\n-\n-struct Nullable3\n-{\n-    C* payload;\n-\n-    this(C* c)\n-    {\n-        payload = c;\n-    }\n-\n-    void opAssign()(C)\n-    {\n-        move(payload);\n-    }\n-\n-    inout(C) get_() inout\n-    {\n-        return *payload;\n-    }\n-\n-    alias get_ this;\n-}\n-\n-T move(T)(ref T source)\n-{\n-    return source;\n-}\n-\n-T move(T)(T source)\n-{\n-    return source;\n-}"}, {"sha": "9f779fd07dae7438a0da9674f36ad498b62c3e65", "filename": "gcc/testsuite/gdc.test/compilable/test22916.d", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22916.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22916.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22916.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,42 @@\n+// REQUIRED_ARGS: -preview=dip1000\n+\n+// https://issues.dlang.org/show_bug.cgi?id=22916\n+// Issue 22916 - [dip1000] copy of ref return still treated as scope variable (edit)\n+\n+@safe:\n+struct Arr\n+{\n+    int** ptr;\n+    ref int* index() return scope { return *ptr; }\n+    void assign(int* p) scope { *ptr = p; }\n+}\n+\n+void main0()\n+{\n+    scope Arr a;\n+    a.assign(a.index());\n+}\n+\n+// https://issues.dlang.org/show_bug.cgi?id=23682\n+ref char* front_p(ref return scope char** p) { return *p; }\n+ref char* front_r(    return scope char** p) { return *p; }\n+\n+char* g;\n+\n+void test23862()\n+{\n+    scope char** _errors;\n+    g = front_p(_errors);   // should pass\n+    g = front_r(_errors);   // should pass\n+}\n+\n+// Test case reduced from druntime\n+ref int* monitor(return scope Object h) pure nothrow @nogc @trusted\n+{\n+    return *cast(int**)&h.__monitor;\n+}\n+\n+int* getMonitor(Object h) pure @nogc\n+{\n+    return monitor(h); // should pass\n+}"}, {"sha": "45235dc5284113fdaada2f3ad55b6e7e2cc47ef9", "filename": "gcc/testsuite/gdc.test/compilable/test23145.d", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23145.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23145.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23145.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,39 @@\n+/* TEST_OUTPUT:\n+---\n+compilable/test23145.d(117): Deprecation: `scope` allocation of `c` requires that constructor be annotated with `scope`\n+compilable/test23145.d(111):        is the location of the constructor\n+compilable/test23145.d(124): Deprecation: `scope` allocation of `c` requires that constructor be annotated with `scope`\n+compilable/test23145.d(111):        is the location of the constructor\n+---\n+*/\n+\n+// https://issues.dlang.org/show_bug.cgi?id=23145\n+\n+#line 100\n+\n+class D\n+{\n+    C c;\n+}\n+\n+class C\n+{\n+    D d;\n+    int x=3;\n+    this(int i) scope @safe @nogc;\n+    this(D d) @safe @nogc;\n+}\n+\n+C foo(D d)@nogc @safe\n+{\n+    scope e = new C(1);  // ok\n+    scope c = new C(d);  // deprecation\n+    return c.d.c;\n+}\n+\n+C bax(D d) @safe\n+{\n+    scope e = new C(1);  // ok\n+    scope c = new C(d);  // deprecation\n+    return c.d.c;\n+}"}, {"sha": "c3ae19a21eb998b68d10fda8840ea0da9fc5983a", "filename": "gcc/testsuite/gdc.test/compilable/test23431_minimal.d", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23431_minimal.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23431_minimal.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23431_minimal.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -13,6 +13,13 @@ class Exception : Throwable\n \n class Error { }\n \n+// Needed to lower `new Exception(\"ice\")` to it.\n+T _d_newclassT(T)()\n+if (is(T == class))\n+{\n+    return null;\n+}\n+\n void test23431()\n {\n     int a;"}, {"sha": "dfffa456c8a141107e7341a6ef1be6adab8538fc", "filename": "gcc/testsuite/gdc.test/compilable/test23433.d", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23433.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23433.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23433.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -4,6 +4,13 @@ module object;\n class Throwable { }\n class Exception : Throwable { this(immutable(char)[]) { } }\n \n+// Needed to lower `new Exception(\"ice\")` to it.\n+T _d_newclassT(T)()\n+if (is(T == class))\n+{\n+    return null;\n+}\n+\n void test23433()\n {\n     try"}, {"sha": "cdcb5a801d49d77b535c55b9f17df39ad04539c0", "filename": "gcc/testsuite/gdc.test/compilable/test23598.d", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23598.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23598.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23598.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,87 @@\n+// https://issues.dlang.org/show_bug.cgi?id=23598\n+\n+alias AliasSeq(a...) = a;\n+\n+static if (1)\n+{\n+\n+template sort(alias f, a...)\n+{\n+    static if (a.length > 0)\n+    {\n+        alias x = f!(a[0]);\n+        alias sort = a;\n+    }\n+    else\n+        alias sort = a;\n+}\n+\n+alias SortedItems = sort!(isDependencyOf, String);\n+\n+enum isDependencyOf(Item) = Item.DirectDependencies.length == 0;\n+\n+struct String\n+{\n+    alias DirectDependencies = AliasSeq!();\n+\n+    enum l = SortedItems.length; // (3)\n+}\n+\n+}\n+\n+/*****************************************************/\n+\n+static if (1)\n+{\n+enum x = 1;\n+enum y = 2;\n+\n+template f(T)\n+{\n+    alias b = int;\n+    static if (x)\n+    {\n+        alias c = x;\n+    }\n+    else\n+    {\n+        alias c = y;\n+    }\n+\n+    static if (is(typeof(c)))\n+    {\n+    }\n+    else\n+    {\n+        static assert(0);\n+    }\n+}\n+\n+void g()\n+{\n+    int x = f!int.c;\n+}\n+}\n+\n+/*****************************************************/\n+\n+template forward(args...)\n+{\n+    template fwd(alias arg)\n+    {\n+        alias fwd = arg;\n+    }\n+\n+    alias Result = AliasSeq!();\n+    static foreach (arg; args)\n+        Result = AliasSeq!(Result, fwd!arg);\n+    static if (Result.length == 1)\n+        alias forward = Result[0];\n+    else\n+        alias forward = Result;\n+}\n+\n+void func(int i, int j)\n+{\n+    func(forward!(i, j));\n+}"}, {"sha": "4d8ab2472ba428d394a0908a87d2e9bda44a5d28", "filename": "gcc/testsuite/gdc.test/compilable/test23606.d", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23606.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23606.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23606.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,12 @@\n+/* REQUIRED_ARGS: -betterC\n+ */\n+\n+// https://issues.dlang.org/show_bug.cgi?id=23606\n+\n+string foo()()\n+{\n+    string a, b;\n+    return a ~ b;\n+}\n+\n+enum s = foo();"}, {"sha": "2d03ee7fae9cd27504c48e612657cea62728e93a", "filename": "gcc/testsuite/gdc.test/compilable/test23617.d", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23617.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23617.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23617.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,23 @@\n+// https://issues.dlang.org/show_bug.cgi?id=23617\n+\n+struct S\n+{\n+    void foo() {}\n+}\n+\n+struct Wrapper\n+{\n+    size_t currentIndex;\n+    S[] arrayOfS;\n+\n+    auto opDispatch(string name, T ...)(T t)\n+    {\n+        return __traits(child, arrayOfS[this.currentIndex], __traits(getMember, S, name))(t);\n+    }\n+}\n+\n+void main()\n+{\n+        Wrapper w;\n+        w.opDispatch!\"foo\"();\n+}"}, {"sha": "ac19943e10d7b6f9b4a07a76b02d4539704f80e5", "filename": "gcc/testsuite/gdc.test/compilable/test23626.d", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23626.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23626.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23626.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,8 @@\n+// https://issues.dlang.org/show_bug.cgi?id=23626\n+// EXTRA_SOURCES: extra-files/test23626a.d extra-files/test23626b.d\n+module test23626;\n+\n+struct StaticHashTable(V)\n+{\n+    V v;\n+}"}, {"sha": "e2ec002c848072e6de1ffa07b829b7393f003997", "filename": "gcc/testsuite/gdc.test/compilable/test23639.d", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23639.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23639.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23639.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,12 @@\n+// https://issues.dlang.org/show_bug.cgi?id=23639\n+\n+// REQUIRED_ARGS: -preview=nosharedaccess\n+\n+class T {}\n+\n+shared(T) allocClassMem()\n+{\n+    void *p;\n+    // assume p is allocated here\n+    return cast(shared(T))p;\n+}"}, {"sha": "8c477b0c0b6e4085417859878a8367f6e16bb3b1", "filename": "gcc/testsuite/gdc.test/compilable/test23651.d", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23651.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23651.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23651.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,34 @@\n+// https://issues.dlang.org/show_bug.cgi?id=23651\n+\n+template isCallable(alias callable)\n+{\n+    static if (is(typeof(&callable!())))\n+        enum bool isCallable = isCallable!(typeof(&callable!()));\n+    else\n+        enum bool isCallable = true;\n+}\n+\n+string foo();\n+\n+template FunctionTypeOf(alias func)\n+if (isCallable!func)\n+{\n+    alias FunctionTypeOf = typeof(foo);\n+}\n+\n+template ReturnType(alias func)\n+{\n+    static if (is(FunctionTypeOf!func R == return))\n+        alias ReturnType = R;\n+}\n+\n+template isAttrRange()\n+{\n+    alias NameType  = ReturnType!((string r) => r);\n+    //pragma(msg, \"isAttrRange \", NameType, \" \", string);\n+    static assert(is(NameType == string));\n+\n+    enum isAttrRange = is(NameType == string);\n+}\n+\n+static assert(isAttrRange!());"}, {"sha": "884c3995925f15c8dbc6ed226d3930c39bb3cb65", "filename": "gcc/testsuite/gdc.test/compilable/test23662.d", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23662.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23662.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23662.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,8 @@\n+// https://issues.dlang.org/show_bug.cgi?id=23662\n+// EXTRA_FILES: imports/imp23662.c\n+import imports.imp23662;\n+\n+void main(string[] args) {\n+    auto r = func(A);\n+    assert(r == A);\n+}"}, {"sha": "91a73b9de82639f9e47436505dd8f7cc67039d42", "filename": "gcc/testsuite/gdc.test/compilable/test23676.d", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23676.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23676.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23676.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,16 @@\n+// Issue 23676 - Static foreach hangs compilation for some time\n+// https://issues.dlang.org/show_bug.cgi?id=23676\n+\n+void f()\n+{\n+    int i;\n+    void g(int I)()\n+    {\n+        static foreach(j; 0..11)\n+        {\n+            i++;\n+            g!j();\n+        }\n+    }\n+    g!0;\n+}"}, {"sha": "9264d01928dc4fc707984f5feeca3c4ee736a314", "filename": "gcc/testsuite/gdc.test/compilable/test23679.d", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23679.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23679.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23679.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,3 @@\n+// DISABLED: win32\n+// https://issues.dlang.org/show_bug.cgi?id=23679\n+ubyte [0x7fff_ffffU] arr;"}, {"sha": "a54b0ae173aa5dd8f4282fe6dc7118af4fd4902d", "filename": "gcc/testsuite/gdc.test/compilable/test5973.d", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e2c3dd6afcf9b152df72b30e205b0180c0afd5/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest5973.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e2c3dd6afcf9b152df72b30e205b0180c0afd5/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest5973.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest5973.d?ref=c5e2c3dd6afcf9b152df72b30e205b0180c0afd5", "patch": "@@ -1,41 +0,0 @@\n-// https://issues.dlang.org/show_bug.cgi?id=5973\n-\n-class A { int a = 1; }\n-class B { int b = 2; }\n-class C : A\n-{\n-    B obj;\n-    alias obj this;\n-    this(){ obj = new B(); }\n-}\n-class X : C {}\n-\n-class D\n-{\n-    int i;\n-}\n-\n-class E\n-{\n-    D x;\n-    alias x this;\n-}\n-\n-class F : E\n-{\n-    void test()\n-    {\n-        i = 5;\n-    }\n-}\n-\n-void main()\n-{\n-    auto c = new C();\n-    assert(c.a == 1);   // lookup C -> A, OK\n-    assert(c.b == 2);   // lookup C => B, OK\n-\n-    auto x = new X();\n-    assert(x.a == 1);   // lookup X -> C -> A, OK\n-    assert(x.b == 2);   // lookup X -> C => B, NG (Line 17)\n-}"}, {"sha": "161a94a179d13b168474dc13cae97a9cc3940513", "filename": "gcc/testsuite/gdc.test/compilable/test6777.d", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e2c3dd6afcf9b152df72b30e205b0180c0afd5/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest6777.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e2c3dd6afcf9b152df72b30e205b0180c0afd5/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest6777.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest6777.d?ref=c5e2c3dd6afcf9b152df72b30e205b0180c0afd5", "patch": "@@ -1,11 +0,0 @@\n-struct S {}\n-\n-class C {\n-    S s;\n-    alias s this;\n-}\n-\n-void main() {\n-    auto c = new C;\n-    auto p = cast(void*) c;\n-}"}, {"sha": "77671eb853ff90f1a0d9e1c797c5315f24e52e49", "filename": "gcc/testsuite/gdc.test/fail_compilation/biterrors2.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fbiterrors2.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fbiterrors2.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fbiterrors2.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1,7 +1,7 @@\n /* REQUIRED_ARGS: -preview=bitfields\n  * TEST_OUTPUT:\n ---\n-fail_compilation/biterrors2.d(100): Error: variable `biterrors2.a` bit-field must be member of struct, union, or class\n+fail_compilation/biterrors2.d(100): Error: variable `biterrors2.a` - bit-field must be member of struct, union, or class\n fail_compilation/biterrors2.d(104): Error: bit-field `b` has zero width\n fail_compilation/biterrors2.d(105): Error: bit-field type `float` is not an integer type\n ---"}, {"sha": "da60092c8491f4e0d858ca7e7413a3e3c0cfa1dc", "filename": "gcc/testsuite/gdc.test/fail_compilation/call_function_type.d", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fcall_function_type.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fcall_function_type.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fcall_function_type.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,20 @@\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/call_function_type.d(18): Error: missing argument for parameter #1: `int`\n+fail_compilation/call_function_type.d(19): Error: cannot call `int(int)(3)` at compile time\n+---\n+*/\n+\n+// This is a rare case where `dmd.expressionsem.functionParameters` catches a missing argument error,\n+// which is usually caught earlier by `TypeFunction.callMatch`, and had no test coverage yet.\n+// This was found while implementing named arguments and reduced from `vibe.internal.meta.traits`.\n+\n+int f(int);\n+\n+void m()\n+{\n+\talias FT = typeof(f);\n+\tenum X0 = FT();\n+\tenum X1 = FT(3);\n+}"}, {"sha": "2d8bf7a0fefa3327fe3f3c170f52e1eb18472faf", "filename": "gcc/testsuite/gdc.test/fail_compilation/ctfeblock.d", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fctfeblock.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fctfeblock.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fctfeblock.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,33 @@\n+/* TEST_OUTPUT:\n+---\n+fail_compilation/ctfeblock.d(112): Error: cannot `goto` into `if (__ctfe)` block\n+---\n+*/\n+\n+/*******************************************/\n+// https://issues.dlang.org/show_bug.cgi?id=18472\n+// https://github.com/dlang/dmd/pull/14676\n+\n+#line 100\n+\n+struct T { }\n+\n+@nogc void test1()\n+{\n+    int a;\n+    if (__ctfe)\n+    {\n+L1:\n+        new T();\n+\ta = 3;\n+    }\n+    goto L1;\n+}\n+\n+@nogc void test2()\n+{\n+    if (__ctfe)\n+    {\n+        new T();\n+    }\n+}"}, {"sha": "137482f98ac2a6c27c9c5c3d5c565e515bf0c162", "filename": "gcc/testsuite/gdc.test/fail_compilation/deprecate_getVirtualFunctions.d", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdeprecate_getVirtualFunctions.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdeprecate_getVirtualFunctions.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdeprecate_getVirtualFunctions.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,20 @@\n+// REQUIRED_ARGS: -de\n+\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/deprecate_getVirtualFunctions.d(18): Deprecation: `traits(isVirtualFunction)` is deprecated. Use `traits(isVirtualMethod)` instead\n+fail_compilation/deprecate_getVirtualFunctions.d(19): Deprecation: `traits(getVirtualFunctions)` is deprecated. Use `traits(getVirtualMethods)` instead\n+---\n+*/\n+\n+class A\n+{\n+    void fun() {}\n+}\n+\n+void main()\n+{\n+    auto a = __traits(isVirtualFunction, A.fun);\n+    foreach(f; __traits(getVirtualFunctions, A, \"fun\")) {}\n+}"}, {"sha": "46109247fb6a964ab7b5bfd1ada1d39981f1d303", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag10099.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag10099.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag10099.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag10099.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/diag10099.d(15): Error: variable `diag10099.main.s` default construction is disabled for type `S`\n+fail_compilation/diag10099.d(15): Error: variable `diag10099.main.s` - default construction is disabled for type `S`\n ---\n */\n "}, {"sha": "0bdfe50ca748920516251eb44c0b10223febaf17", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag11132.d", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag11132.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag11132.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag11132.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1,7 +1,8 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/diag11132.d(22): Error: overlapping initialization for field `a` and `b`\n+fail_compilation/diag11132.d(23): Error: overlapping initialization for field `a` and `b`\n+fail_compilation/diag11132.d(23):        `struct` initializers that contain anonymous unions must initialize only the first member of a `union`. All subsequent non-overlapping fields are default initialized\n ---\n */\n "}, {"sha": "307c6be1d09cd22306a8759b304b0ddd5ef736fd", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag12312.d", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag12312.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag12312.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag12312.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1,11 +1,16 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/diag12312.d(10): Error: variable `diag12312.main.arr` `void[16]` does not have a default initializer\n+fail_compilation/diag12312.d(10): Error: variable `diag12312.main.arr` of type `void[16]` does not have a default initializer\n+fail_compilation/diag12312.d(15): Error: variable `diag12312.bug1176.v` of type `void[1]` does not have a default initializer\n ---\n */\n-\n void main()\n {\n     void[16] arr;\n }\n+\n+void bug1176()\n+{\n+    void[1] v;\n+}"}, {"sha": "8c563ba44c9f9c519e2beebbe48589963782640e", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag14235.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag14235.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag14235.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag14235.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -4,7 +4,7 @@ TEST_OUTPUT:\n ---\n fail_compilation/diag14235.d(12): Error: undefined identifier `Undefined` in module `imports.a14235`\n fail_compilation/diag14235.d(13): Error: undefined identifier `Something` in module `imports.a14235`, did you mean struct `SomeThing(T...)`?\n-fail_compilation/diag14235.d(14): Error: `imports.a14235.SomeClass` is not a template, it is a class\n+fail_compilation/diag14235.d(14): Error: `SomeClass` isn't a template\n ---\n */\n "}, {"sha": "0e4fb8b076f7f270a354b03e46016e035b9c4818", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag3438.d", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag3438.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag3438.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag3438.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -7,7 +7,7 @@ fail_compilation/diag3438.d(20): Error: constructor `diag3438.F5.this` is marked\n fail_compilation/diag3438.d(20):        Use `@disable this();` if you want to disable default initialization.\n fail_compilation/diag3438.d(21): Error: constructor `diag3438.F6.this` is marked `@disable`, so it cannot have default arguments for all parameters.\n fail_compilation/diag3438.d(21):        Use `@disable this();` if you want to disable default initialization.\n-fail_compilation/diag3438.d(24): Error: default argument expected for `y`\n+fail_compilation/diag3438.d(22): Error: constructor `diag3438.F7.this` all parameters have default arguments, but structs cannot have default constructors.\n ---\n */\n \n@@ -19,6 +19,4 @@ struct F3 { this(...) { } } // ok\n struct F4 { this(int[] x...) { } }  // ok\n struct F5 { @disable this(int x = 1); }\n struct F6 { @disable this(int x = 1) { } }\n-\n-// Make sure the deprecation doesn't interfere w/ the check for default arguments\n-struct S { this(int x = 1, int y) { } }\n+struct F7 { this(int x = 1, int y = 2) { } }"}, {"sha": "ddc74e28131f7212bc29f933d4cdc04e96fa2142", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag8101.d", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag8101.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag8101.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag8101.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1,30 +1,32 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/diag8101.d(57): Error: function `diag8101.f_0(int)` is not callable using argument types `()`\n-fail_compilation/diag8101.d(57):        too few arguments, expected 1, got 0\n-fail_compilation/diag8101.d(58): Error: none of the overloads of `f_1` are callable using argument types `()`\n-fail_compilation/diag8101.d(33):        Candidates are: `diag8101.f_1(int)`\n-fail_compilation/diag8101.d(34):                        `diag8101.f_1(int, int)`\n-fail_compilation/diag8101.d(59): Error: none of the overloads of `f_2` are callable using argument types `()`\n-fail_compilation/diag8101.d(36):        Candidates are: `diag8101.f_2(int)`\n-fail_compilation/diag8101.d(37):                        `diag8101.f_2(int, int)`\n-fail_compilation/diag8101.d(38):                        `diag8101.f_2(int, int, int)`\n-fail_compilation/diag8101.d(39):                        `diag8101.f_2(int, int, int, int)`\n-fail_compilation/diag8101.d(40):                        `diag8101.f_2(int, int, int, int, int)`\n-fail_compilation/diag8101.d(59):        ... (1 more, -v to show) ...\n-fail_compilation/diag8101.d(61): Error: none of the overloads of template `diag8101.t_0` are callable using argument types `!()()`\n-fail_compilation/diag8101.d(43):        Candidate is: `t_0(T1)()`\n-fail_compilation/diag8101.d(62): Error: none of the overloads of template `diag8101.t_1` are callable using argument types `!()()`\n-fail_compilation/diag8101.d(45):        Candidates are: `t_1(T1)()`\n-fail_compilation/diag8101.d(46):                        `t_1(T1, T2)()`\n-fail_compilation/diag8101.d(63): Error: none of the overloads of template `diag8101.t_2` are callable using argument types `!()()`\n-fail_compilation/diag8101.d(48):        Candidates are: `t_2(T1)()`\n-fail_compilation/diag8101.d(49):                        `t_2(T1, T2)()`\n-fail_compilation/diag8101.d(50):                        `t_2(T1, T2, T3)()`\n-fail_compilation/diag8101.d(51):                        `t_2(T1, T2, T3, T4)()`\n-fail_compilation/diag8101.d(52):                        `t_2(T1, T2, T3, T4, T5)()`\n+fail_compilation/diag8101.d(61): Error: function `diag8101.f_0(int)` is not callable using argument types `()`\n+fail_compilation/diag8101.d(61):        too few arguments, expected 1, got 0\n+fail_compilation/diag8101.d(62): Error: none of the overloads of `f_1` are callable using argument types `()`\n+fail_compilation/diag8101.d(35):        Candidates are: `diag8101.f_1(int)`\n+fail_compilation/diag8101.d(36):                        `diag8101.f_1(int, int)`\n+fail_compilation/diag8101.d(63): Error: none of the overloads of `f_2` are callable using argument types `()`\n+fail_compilation/diag8101.d(38):        Candidates are: `diag8101.f_2(int)`\n+fail_compilation/diag8101.d(39):                        `diag8101.f_2(int, int)`\n+fail_compilation/diag8101.d(40):                        `diag8101.f_2(int, int, int)`\n+fail_compilation/diag8101.d(41):                        `diag8101.f_2(int, int, int, int)`\n+fail_compilation/diag8101.d(42):                        `diag8101.f_2(int, int, int, int, int)`\n+fail_compilation/diag8101.d(43):                        `diag8101.f_2(int, int, int, int, int, int)`\n fail_compilation/diag8101.d(63):        ... (1 more, -v to show) ...\n+fail_compilation/diag8101.d(65): Error: none of the overloads of template `diag8101.t_0` are callable using argument types `!()()`\n+fail_compilation/diag8101.d(46):        Candidate is: `t_0(T1)()`\n+fail_compilation/diag8101.d(66): Error: none of the overloads of template `diag8101.t_1` are callable using argument types `!()()`\n+fail_compilation/diag8101.d(48):        Candidates are: `t_1(T1)()`\n+fail_compilation/diag8101.d(49):                        `t_1(T1, T2)()`\n+fail_compilation/diag8101.d(67): Error: none of the overloads of template `diag8101.t_2` are callable using argument types `!()()`\n+fail_compilation/diag8101.d(51):        Candidates are: `t_2(T1)()`\n+fail_compilation/diag8101.d(52):                        `t_2(T1, T2)()`\n+fail_compilation/diag8101.d(53):                        `t_2(T1, T2, T3)()`\n+fail_compilation/diag8101.d(54):                        `t_2(T1, T2, T3, T4)()`\n+fail_compilation/diag8101.d(55):                        `t_2(T1, T2, T3, T4, T5)()`\n+fail_compilation/diag8101.d(56):                        `t_2(T1, T2, T3, T4, T5, T6)()`\n+fail_compilation/diag8101.d(67):        ... (1 more, -v to show) ...\n ---\n */\n \n@@ -39,6 +41,7 @@ void f_2(int, int, int);\n void f_2(int, int, int, int);\n void f_2(int, int, int, int, int);\n void f_2(int, int, int, int, int, int);\n+void f_2(int, int, int, int, int, int, int);\n \n void t_0(T1)();\n \n@@ -51,6 +54,7 @@ void t_2(T1, T2, T3)();\n void t_2(T1, T2, T3, T4)();\n void t_2(T1, T2, T3, T4, T5)();\n void t_2(T1, T2, T3, T4, T5, T6)();\n+void t_2(T1, T2, T3, T4, T5, T6, T7)();\n \n void main()\n {"}, {"sha": "58dd495ab8eb9299b32459a78e0068d07971fa5e", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag9358.d", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag9358.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag9358.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag9358.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1,9 +1,10 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/diag9358.d(12): Error: `x` must be of integral or string type, it is a `double`\n-fail_compilation/diag9358.d(14): Error: `case` must be a `string` or an integral constant, not `1.1`\n-fail_compilation/diag9358.d(15): Error: `case` must be a `string` or an integral constant, not `2.1`\n+fail_compilation/diag9358.d(13): Error: `x` must be of integral or string type, it is a `double`\n+fail_compilation/diag9358.d(15): Error: `case` expression must be a compile-time `string` or an integral constant, not `1.1`\n+fail_compilation/diag9358.d(16): Error: `case` expression must be a compile-time `string` or an integral constant, not `2.1`\n+fail_compilation/diag9358.d(26): Error: `case` expression must be a compile-time `string` or an integral constant, not `z`\n ---\n */\n void main()\n@@ -16,3 +17,13 @@ void main()\n         default:\n     }\n }\n+\n+void f(immutable string y)\n+{\n+    auto z = y[0..2];\n+    switch (y)\n+    {\n+        case z: break;\n+        default:\n+    }\n+}"}, {"sha": "85923b7189e11db6e053f95dcd34f407de8eddb2", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag9679.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag9679.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag9679.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag9679.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1,8 +1,8 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/diag9679.d(11): Error: variable `diag9679.main.n` only parameters or `foreach` declarations can be `ref`\n-fail_compilation/diag9679.d(12): Error: variable `diag9679.main.n` storage class `auto` has no effect if type is not inferred, did you mean `scope`?\n+fail_compilation/diag9679.d(11): Error: variable `diag9679.main.n` - only parameters, functions and `foreach` declarations can be `ref`\n+fail_compilation/diag9679.d(12): Error: variable `diag9679.main.n` - storage class `auto` has no effect if type is not inferred, did you mean `scope`?\n ---\n */\n "}, {"sha": "f43a6e9ef8d1d4af8fed8ab5c6a22b6fd2adc411", "filename": "gcc/testsuite/gdc.test/fail_compilation/dip25.d", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdip25.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdip25.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdip25.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1,11 +1,11 @@\n /*\n-REQUIRED_ARGS: -de\n+REQUIRED_ARGS:\n TEST_OUTPUT:\n ---\n-fail_compilation/dip25.d(17): Deprecation: returning `this.buffer[]` escapes a reference to parameter `this`\n+fail_compilation/dip25.d(17): Error: returning `this.buffer[]` escapes a reference to parameter `this`\n fail_compilation/dip25.d(15):        perhaps annotate the function with `return`\n fail_compilation/dip25.d(22): Error: returning `identity(x)` escapes a reference to parameter `x`\n-fail_compilation/dip25.d(23): Deprecation: returning `identity(x)` escapes a reference to parameter `x`\n+fail_compilation/dip25.d(23): Error: returning `identity(x)` escapes a reference to parameter `x`\n fail_compilation/dip25.d(23):        perhaps annotate the parameter with `return`\n ---\n */"}, {"sha": "d75ceace611812b9c4a6591e048dcba6c577b402", "filename": "gcc/testsuite/gdc.test/fail_compilation/dip25flag.d", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdip25flag.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdip25flag.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdip25flag.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,7 @@\n+/*\n+REQUIRED_ARGS: -de -dip25\n+TEST_OUTPUT:\n+---\n+Deprecation: `-dip25` no longer has any effect\n+---\n+*/"}, {"sha": "96b23e278cd905c813977da0bd37beeb1ef9f0ab", "filename": "gcc/testsuite/gdc.test/fail_compilation/e15876_5.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fe15876_5.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fe15876_5.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fe15876_5.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -2,7 +2,7 @@\n TEST_OUTPUT:\n ---\n fail_compilation/e15876_5.d(16): Error: basic type expected, not `End of File`\n-fail_compilation/e15876_5.d(16): Error: semicolon expected to close `alias` declaration\n+fail_compilation/e15876_5.d(16): Error: semicolon expected to close `alias` declaration, not `End of File`\n fail_compilation/e15876_5.d(16): Error: found `End of File` when expecting `}` following compound statement\n fail_compilation/e15876_5.d(16): Error: found `End of File` when expecting `]`\n fail_compilation/e15876_5.d(16): Error: no identifier for declarator `p[()"}, {"sha": "51c8b1a66538ceb8c5a071c2ef76eae9049ec04e", "filename": "gcc/testsuite/gdc.test/fail_compilation/enum9921.d", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fenum9921.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fenum9921.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fenum9921.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -3,9 +3,11 @@ TEST_OUTPUT:\n ---\n fail_compilation/enum9921.d(9): Error: enum `enum9921.X` base type must not be `void`\n fail_compilation/enum9921.d(11): Error: enum `enum9921.Z` base type must not be `void`\n+fail_compilation/enum9921.d(13): Error: variable `enum9921.x` - manifest constants must have initializers\n ---\n */\n-\n enum X : void;\n \n enum Z : void { Y };\n+\n+enum int x;"}, {"sha": "8344a4701c778470fec483d52f6873a5e16ce0fa", "filename": "gcc/testsuite/gdc.test/fail_compilation/enum_init.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fenum_init.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fenum_init.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fenum_init.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -56,7 +56,7 @@ https://issues.dlang.org/show_bug.cgi?id=21785\n \n TEST_OUTPUT:\n ---\n-fail_compilation/enum_init.d(306): Error: variable `enum_init.fooOB.ob` no definition of struct `S`\n+fail_compilation/enum_init.d(306): Error: variable `enum_init.fooOB.ob` - no definition of struct `S`\n fail_compilation/enum_init.d(302):        required by type `OpaqueBase`\n ---\n */"}, {"sha": "17577ec84f4ee974e9266e73b56cc52ea2d4dee9", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail10102.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail10102.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail10102.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail10102.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1,8 +1,8 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail10102.d(48): Error: variable `fail10102.main.m` default construction is disabled for type `NotNull!(int*)`\n-fail_compilation/fail10102.d(49): Error: variable `fail10102.main.a` default construction is disabled for type `NotNull!(int*)[3]`\n+fail_compilation/fail10102.d(48): Error: variable `fail10102.main.m` - default construction is disabled for type `NotNull!(int*)`\n+fail_compilation/fail10102.d(49): Error: variable `fail10102.main.a` - default construction is disabled for type `NotNull!(int*)[3]`\n fail_compilation/fail10102.d(50): Error: default construction is disabled for type `NotNull!(int*)`\n fail_compilation/fail10102.d(51): Error: field `S.m` must be initialized because it has no default constructor\n ---"}, {"sha": "f6c8fbb6804bad64ddc984f0dd5f834f1ac5fb18", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail14406.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail14406.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail14406.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail14406.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1,8 +1,8 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail14406.d-mixin-20(20): Error: variable `fail14406.CFrop.bar_obj` cannot be further field because it will change the determined CFrop size\n-fail_compilation/fail14406.d-mixin-25(25): Error: variable `fail14406.IFrop.bar_obj` field not allowed in interface\n+fail_compilation/fail14406.d-mixin-20(20): Error: cannot declare field `bar_obj` because it will change the determined size of `CFrop`\n+fail_compilation/fail14406.d-mixin-25(25): Error: field `bar_obj` not allowed in interface\n ---\n */\n "}, {"sha": "5f73f9a0ea5e4ec9e2232d9c99b17412ba147963", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail155.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail155.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail155.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail155.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail155.d(20): Error: overlapping initialization for `y`\n+fail_compilation/fail155.d(20): Error: overlapping initialization for field `x` and `y`\n fail_compilation/fail155.d(20):        `struct` initializers that contain anonymous unions must initialize only the first member of a `union`. All subsequent non-overlapping fields are default initialized\n ---\n */"}, {"sha": "ccb325415b2a2c708af5a2dbfe934fce30ccdd22", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail156.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail156.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail156.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail156.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -2,9 +2,9 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail156.d(35): Error: overlapping initialization for `y`\n+fail_compilation/fail156.d(35): Error: overlapping initialization for field `x` and `y`\n fail_compilation/fail156.d(35):        `struct` initializers that contain anonymous unions must initialize only the first member of a `union`. All subsequent non-overlapping fields are default initialized\n-fail_compilation/fail156.d(42): Error: overlapping initialization for `y`\n+fail_compilation/fail156.d(42): Error: overlapping initialization for field `x` and `y`\n fail_compilation/fail156.d(42):        `struct` initializers that contain anonymous unions must initialize only the first member of a `union`. All subsequent non-overlapping fields are default initialized\n ---\n */"}, {"sha": "042eee12299aa820f2c1a6f0251ef8bba9b5050d", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail15616a.d", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail15616a.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail15616a.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail15616a.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -7,10 +7,11 @@ fail_compilation/fail15616a.d(17):                        `fail15616a.foo(int a,\n fail_compilation/fail15616a.d(26):                        `fail15616a.foo(int a, int b, int c)`\n fail_compilation/fail15616a.d(29):                        `fail15616a.foo(string a)`\n fail_compilation/fail15616a.d(32):                        `fail15616a.foo(string a, string b)`\n-fail_compilation/fail15616a.d(41):        ... (3 more, -v to show) ...\n+fail_compilation\\fail15616a.d(35):                        `fail15616a.foo(string a, string b, string c)`\n+fail_compilation/fail15616a.d(41):        ... (2 more, -v to show) ...\n ---\n */\n-\n+#line 14\n void foo(int a)\n {}\n "}, {"sha": "092590eff1a2ffac96caaaced5133364f7badc81", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail15616c.d", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail15616c.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail15616c.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail15616c.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,52 @@\n+/*\n+REQUIRED_ARGS: -verror-supplements=0\n+TEST_OUTPUT:\n+---\n+fail_compilation/fail15616c.d(44): Error: none of the overloads of `foo` are callable using argument types `(double)`\n+fail_compilation/fail15616c.d(17):        Candidates are: `fail15616c.foo(int a)`\n+fail_compilation/fail15616c.d(20):                        `fail15616c.foo(int a, int b)`\n+fail_compilation/fail15616c.d(29):                        `fail15616c.foo(int a, int b, int c)`\n+fail_compilation/fail15616c.d(32):                        `fail15616c.foo(string a)`\n+fail_compilation/fail15616c.d(35):                        `fail15616c.foo(string a, string b)`\n+fail_compilation/fail15616c.d(38):                        `fail15616c.foo(string a, string b, string c)`\n+fail_compilation/fail15616c.d(23):                        `foo(T)(T a)`\n+  with `T = double`\n+  must satisfy the following constraint:\n+`       is(T == float)`\n+fail_compilation/fail15616c.d(26):                        `foo(T)(T a)`\n+  with `T = double`\n+  must satisfy the following constraint:\n+`       is(T == char)`\n+---\n+*/\n+\n+#line 17\n+void foo(int a)\n+{}\n+\n+void foo(int a, int b)\n+{}\n+\n+void foo(T)(T a) if (is(T == float))\n+{}\n+\n+void foo(T)(T a) if (is(T == char))\n+{}\n+\n+void foo(int a, int b, int c)\n+{}\n+\n+void foo(string a)\n+{}\n+\n+void foo(string a, string b)\n+{}\n+\n+void foo(string a, string b, string c)\n+{}\n+\n+\n+void main()\n+{\n+    foo(3.14);\n+}"}, {"sha": "a0f85a1df9c8d2fe7edaec882e5cc9b82aa567fe", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail15616d.d", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail15616d.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail15616d.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail15616d.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,41 @@\n+/*\n+REQUIRED_ARGS: -verror-supplements=2\n+TEST_OUTPUT:\n+---\n+fail_compilation/fail15616d.d(44): Error: none of the overloads of `foo` are callable using argument types `(double)`\n+fail_compilation/fail15616d.d(17):        Candidates are: `fail15616d.foo(int a)`\n+fail_compilation/fail15616d.d(20):                        `fail15616d.foo(int a, int b)`\n+fail_compilation/fail15616d.d(44):        ... (6 more, -v to show) ...\n+---\n+*/\n+\n+#line 17\n+void foo(int a)\n+{}\n+\n+void foo(int a, int b)\n+{}\n+\n+void foo(T)(T a) if (is(T == float))\n+{}\n+\n+void foo(T)(T a) if (is(T == char))\n+{}\n+\n+void foo(int a, int b, int c)\n+{}\n+\n+void foo(string a)\n+{}\n+\n+void foo(string a, string b)\n+{}\n+\n+void foo(string a, string b, string c)\n+{}\n+\n+\n+void main()\n+{\n+    foo(3.14);\n+}"}, {"sha": "3253d1671626a66ba7435d837a1ff9f582cee30a", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail158.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail158.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail158.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail158.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail158.d(17): Error: more initializers than fields (2) of `S`\n+fail_compilation/fail158.d(17): Error: too many initializers for `S` with 2 fields\n ---\n */\n "}, {"sha": "95eb5cc8c1f92639456752d5e91b8f7835a5ae5d", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail17955.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail17955.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail17955.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail17955.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -13,7 +13,7 @@ fail_compilation/fail17955.d(32):        instantiated from here: `indicesOf!(isR\n fail_compilation/fail17955.d(67):        instantiated from here: `RedisStripped!(User, true)`\n fail_compilation/fail17955.d(93): Error: need `this` for `fromISOExtString` of type `pure nothrow @nogc @safe immutable(SimpleTimeZone)(dstring _param_0)`\n fail_compilation/fail17955.d(95): Error: undefined identifier `DateTimeException`\n-fail_compilation/fail17955.d(25): Error: variable `fail17955.isISOExtStringSerializable!(SysTime).isISOExtStringSerializable` type `void` is inferred from initializer `fromISOExtString(\"\")`, and variables cannot be of type `void`\n+fail_compilation/fail17955.d(25): Error: variable `fail17955.isISOExtStringSerializable!(SysTime).isISOExtStringSerializable` - type `void` is inferred from initializer `fromISOExtString(\"\")`, and variables cannot be of type `void`\n fail_compilation/fail17955.d(54): Error: function `fail17955.toRedis!(SysTime).toRedis` has no `return` statement, but is expected to return a value of type `string`\n ---\n */"}, {"sha": "2441d6f3caeeb2b9f7a7673725cc0c03cdbb286a", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail19076.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19076.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19076.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19076.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -8,4 +8,4 @@ fail_compilation/fail19076.d(11): Error: `(I).V` cannot be resolved\n \n interface P { }\n interface I : P { }\n-auto F = __traits(getVirtualFunctions, I, \"V\");\n+auto F = __traits(getVirtualMethods, I, \"V\");"}, {"sha": "2e170d096c598891c6659267abf9bd60ab363cfd", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail21243.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail21243.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail21243.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail21243.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -8,7 +8,7 @@ fail_compilation/fail21243.d(17): Error: `auto` can only be used as part of `aut\n fail_compilation/fail21243.d(18): Error: basic type expected, not `(`\n fail_compilation/fail21243.d(18): Error: function declaration without return type. (Note that constructors are always named `this`)\n fail_compilation/fail21243.d(18): Deprecation: storage class `auto` has no effect in type aliases\n-fail_compilation/fail21243.d(18): Error: semicolon expected to close `alias` declaration\n+fail_compilation/fail21243.d(18): Error: semicolon expected to close `alias` declaration, not `=>`\n fail_compilation/fail21243.d(18): Error: declaration expected, not `=>`\n fail_compilation/fail21243.d(19): Error: `auto` can only be used as part of `auto ref` for function literal return values\n ---"}, {"sha": "3df834f7ad0d3e8e7d92275a6709b8ee4030903a", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail22039.d", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22039.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22039.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22039.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,14 @@\n+// https://issues.dlang.org/show_bug.cgi?id=22039\n+\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/fail22039.d(11): Error: recursive evaluation of `func()`\n+fail_compilation/fail22039.d(14): Error: recursive evaluation of `gun(func2())`\n+---\n+*/\n+\n+int func(int x = func()) { return x; }\n+\n+int gun() { return 2; }\n+int func2(int x = gun(func2())) { return x; }"}, {"sha": "e937a480b45c1de4c96a892d7dd40850a0d33e98", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail22570.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22570.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22570.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22570.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -3,8 +3,8 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail22570.d(19): Error: more initializers than fields (1) of `S`\n-fail_compilation/fail22570.d(20): Error: more initializers than fields (1) of `S`\n+fail_compilation/fail22570.d(19): Error: too many initializers for `S` with 1 field\n+fail_compilation/fail22570.d(20): Error: too many initializers for `S` with 1 field\n ---\n */\n "}, {"sha": "7d4d97892dd54df8dbe336a104018948207e8f31", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail233.d", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e2c3dd6afcf9b152df72b30e205b0180c0afd5/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail233.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e2c3dd6afcf9b152df72b30e205b0180c0afd5/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail233.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail233.d?ref=c5e2c3dd6afcf9b152df72b30e205b0180c0afd5", "patch": "@@ -1,12 +0,0 @@\n-// REQUIRED_ARGS: -o-\n-/*\n-TEST_OUTPUT:\n----\n-fail_compilation/fail233.d(11): Error: variable `fail233.bug1176.v` `void[1]` does not have a default initializer\n----\n-*/\n-\n-void bug1176()\n-{\n-    void[1] v;\n-}"}, {"sha": "2943f1a6c4f00b2930db275f5dac7bb5d8d471c1", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail23626a.d", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail23626a.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail23626a.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail23626a.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,16 @@\n+/* TEST_OUTPUT:\n+---\n+fail_compilation/fail23626a.d(10): Deprecation: function `fail23626a.ambig` cannot overload `extern(D)` function at fail_compilation/fail23626a.d(9)\n+fail_compilation/fail23626a.d(13): Deprecation: function `fail23626a.ambigC` cannot overload `extern(C)` function at fail_compilation/fail23626a.d(12)\n+fail_compilation/fail23626a.d(16): Error: function `fail23626a.ambigCxx(int a)` conflicts with previous declaration at fail_compilation/fail23626a.d(15)\n+---\n+*/\n+\n+extern(D) int ambig(int a) { return 0; }\n+extern(D) int ambig(int a) @system { return 1; }\n+\n+extern(C) int ambigC(int a) { return 2; }\n+extern(C) int ambigC(int a) @system { return 3; }\n+\n+extern(C++) int ambigCxx(int a) { return 4; }\n+extern(C++) int ambigCxx(int a) @system { return 5; }"}, {"sha": "758a28b141899d0a76ae688a253b20f6e46ac0a2", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail23626b.d", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail23626b.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail23626b.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail23626b.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,27 @@\n+/* TEST_OUTPUT:\n+---\n+fail_compilation/fail23626b.d(26): Error: `fail23626b.AmbigOpApply.opApply` called with argument types `(int delegate(int i) pure nothrow @nogc @system)` matches both:\n+fail_compilation/fail23626b.d(12):     `fail23626b.AmbigOpApply.opApply(int delegate(int) dg)`\n+and:\n+fail_compilation/fail23626b.d(17):     `fail23626b.AmbigOpApply.opApply(int delegate(int) dg)`\n+---\n+*/\n+\n+struct AmbigOpApply\n+{\n+    int opApply(int delegate(int) dg)\n+    {\n+        return 0;\n+    }\n+\n+    int opApply(int delegate(int) dg) @system\n+    {\n+        return 0;\n+    }\n+}\n+\n+void ambigOpApply() @system\n+{\n+    AmbigOpApply sa;\n+    foreach (int i; sa) { }\n+}"}, {"sha": "eda9e1e63facbb87e15f217fcf52182be16ec785", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail23745.d", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail23745.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail23745.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail23745.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,22 @@\n+// https://issues.dlang.org/show_bug.cgi?id=2374\n+\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/fail23745.d(21): Error: undefined identifier `UndefinedType`\n+fail_compilation/fail23745.d(14): Error: function `fun` does not override any function, did you mean to override `fail23745.A.fun`?\n+fail_compilation/fail23745.d(21):        Function `fail23745.A.fun` contains errors in its declaration, therefore it cannot be correctly overriden\n+---\n+*/\n+\n+class B : A\n+{\n+    override void fun()\n+    {\n+    }\n+}\n+\n+class A\n+{\n+    void fun(UndefinedType);\n+}"}, {"sha": "e6bfbedc7a33c25d25ed2c80a6e6077414cfb260", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail253.d", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail253.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail253.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail253.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1,11 +1,11 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail253.d(13): Error: variable `fail253.main.x` `inout` variables can only be declared inside `inout` functions\n+fail_compilation/fail253.d(13): Error: variable `fail253.main.x` - `inout` variables can only be declared inside `inout` functions\n fail_compilation/fail253.d(16): Error: cannot modify `inout` expression `x`\n+fail_compilation/fail253.d(19): Error: variable `fail253.main.err11` - `inout` variables can only be declared inside `inout` functions\n ---\n */\n-\n void main()\n {\n     foreach (i; 0 .. 2)\n@@ -16,4 +16,5 @@ void main()\n             x = '?';\n         }\n     }\n+    inout(int)* err11;\n }"}, {"sha": "832a9a8d193cdb0ce26e55f20d98377f7afd756e", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail299.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail299.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail299.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail299.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail299.d(14): Error: more initializers than fields (0) of `Foo`\n+fail_compilation/fail299.d(14): Error: initializer provided for struct `Foo` with no fields\n ---\n */\n "}, {"sha": "603fe51db7b050cdb5edfa88cbcc00a95eb5379d", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail308.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail308.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail308.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail308.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -16,6 +16,6 @@ class MinHeap(NodeType)\n     unittest\n     {\n         struct TestType {}\n-        MinHeap!(TestType) foo = new MinHeap!(TestType)();\n+        MinHeap!(TestType) foo;\n     }\n }"}, {"sha": "5b51f54498f90c38395685f991892588ee7f3bce", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail346.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail346.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail346.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail346.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -2,7 +2,7 @@\n TEST_OUTPUT:\n ---\n fail_compilation/fail346.d(15): Error: undefined identifier `P`\n-fail_compilation/fail346.d(15): Error: variable `fail346.S.T!0.T` cannot use template to add field to aggregate `S`\n+fail_compilation/fail346.d(15): Error: variable `fail346.S.T!0.T` - cannot use template to add field to aggregate `S`\n fail_compilation/fail346.d(20): Error: template instance `fail346.S.T!0` error instantiating\n fail_compilation/fail346.d(23):        instantiated from here: `V!(S, 0)`\n ---"}, {"sha": "1ce98065882f1d979e4830c31f3b356f9ace84a1", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail4269a.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4269a.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4269a.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4269a.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -2,7 +2,7 @@\n TEST_OUTPUT:\n ---\n fail_compilation/fail4269a.d(12): Error: undefined identifier `B`\n-fail_compilation/fail4269a.d(12): Error: variable `fail4269a.A.blah` field not allowed in interface\n+fail_compilation/fail4269a.d(12): Error: field `blah` not allowed in interface\n fail_compilation/fail4269a.d(13): Error: undefined identifier `B`\n ---\n */"}, {"sha": "236a956de923e018a7cd24dc23838667ef1ddcce", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail5851.d", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e2c3dd6afcf9b152df72b30e205b0180c0afd5/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail5851.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e2c3dd6afcf9b152df72b30e205b0180c0afd5/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail5851.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail5851.d?ref=c5e2c3dd6afcf9b152df72b30e205b0180c0afd5", "patch": "@@ -1,16 +0,0 @@\n-/*\n-TEST_OUTPUT:\n----\n-fail_compilation/fail5851.d(11): Error: alias this is not reachable as `Foo` already converts to `object.Object`\n----\n-*/\n-\n-class Foo\n-{\n-    Object o;\n-    alias o this;\n-}\n-\n-void main()\n-{\n-}"}, {"sha": "f209592196882a92b8414038713cbf9730944a5c", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail_scope.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail_scope.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail_scope.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail_scope.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -15,7 +15,7 @@ fail_compilation/fail_scope.d(69):     `fail_scope.foo8(return ref int x)`\n fail_compilation/fail_scope.d(82): Error: returning `& string` escapes a reference to local variable `string`\n fail_compilation/fail_scope.d(92): Error: returning `cast(int[])a` escapes a reference to local variable `a`\n fail_compilation/fail_scope.d(100): Error: returning `cast(int[])a` escapes a reference to local variable `a`\n-fail_compilation/fail_scope.d(108): Deprecation: escaping reference to outer local variable `x`\n+fail_compilation/fail_scope.d(108): Error: escaping reference to outer local variable `x`\n fail_compilation/fail_scope.d(127): Deprecation: returning `s.bar()` escapes a reference to local variable `s`\n fail_compilation/fail_scope.d(137): Error: returning `foo16226(i)` escapes a reference to local variable `i`\n ---"}, {"sha": "6fe86434e29f750363bd1809aca994045fa0fde2", "filename": "gcc/testsuite/gdc.test/fail_compilation/failinout2.d", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffailinout2.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffailinout2.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffailinout2.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1,7 +1,13 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/failinout2.d(7): Error: variable `failinout2.x` only parameters or stack based variables can be `inout`\n+fail_compilation/failinout2.d(8): Error: variable `failinout2.x` - only parameters or stack-based variables can be `inout`\n+fail_compilation/failinout2.d(12): Error: variable `failinout2.S3748.err8` - only parameters or stack-based variables can be `inout`\n ---\n */\n inout int x;\n+\n+struct S3748\n+{\n+    inout(int) err8;\n+}"}, {"sha": "77edb7e523d38e317e0de5147fa62fcbd5f205a1", "filename": "gcc/testsuite/gdc.test/fail_compilation/failinout3748a.d", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e2c3dd6afcf9b152df72b30e205b0180c0afd5/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffailinout3748a.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e2c3dd6afcf9b152df72b30e205b0180c0afd5/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffailinout3748a.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffailinout3748a.d?ref=c5e2c3dd6afcf9b152df72b30e205b0180c0afd5", "patch": "@@ -1,10 +0,0 @@\n-/*\n-TEST_OUTPUT:\n----\n-fail_compilation/failinout3748a.d(9): Error: variable `failinout3748a.S3748.err8` only parameters or stack based variables can be `inout`\n----\n-*/\n-struct S3748\n-{\n-    inout(int) err8;\n-}"}, {"sha": "b6dddd879ca938f289a60071834a904bb272fe00", "filename": "gcc/testsuite/gdc.test/fail_compilation/failinout3748b.d", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e2c3dd6afcf9b152df72b30e205b0180c0afd5/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffailinout3748b.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e2c3dd6afcf9b152df72b30e205b0180c0afd5/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffailinout3748b.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffailinout3748b.d?ref=c5e2c3dd6afcf9b152df72b30e205b0180c0afd5", "patch": "@@ -1,10 +0,0 @@\n-/*\n-TEST_OUTPUT:\n----\n-fail_compilation/failinout3748b.d(9): Error: variable `failinout3748b.main.err11` `inout` variables can only be declared inside `inout` functions\n----\n-*/\n-void main()\n-{\n-    inout(int)* err11;\n-}"}, {"sha": "377125d569b5721ad595c415b615339d3d0f3050", "filename": "gcc/testsuite/gdc.test/fail_compilation/failob1.d", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffailob1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffailob1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffailob1.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -2,11 +2,11 @@\n REQUIRED_ARGS:-preview=dip1021\n TEST_OUTPUT:\n ---\n-fail_compilation/failob1.d(104): Error: variable `failob1.test1.a1` is left dangling at return\n-fail_compilation/failob1.d(105): Error: variable `failob1.test2.a2` is left dangling at return\n-fail_compilation/failob1.d(107): Error: variable `failob1.test4.s4` is left dangling at return\n-fail_compilation/failob1.d(108): Error: variable `failob1.test5.dg5` is left dangling at return\n-fail_compilation/failob1.d(115): Error: variable `failob1.test12.p12` is left dangling at return\n+fail_compilation/failob1.d(104): Error: variable `failob1.test1.a1` is not disposed of before return\n+fail_compilation/failob1.d(105): Error: variable `failob1.test2.a2` is not disposed of before return\n+fail_compilation/failob1.d(107): Error: variable `failob1.test4.s4` is not disposed of before return\n+fail_compilation/failob1.d(108): Error: variable `failob1.test5.dg5` is not disposed of before return\n+fail_compilation/failob1.d(115): Error: variable `failob1.test12.p12` is not disposed of before return\n ---\n */\n "}, {"sha": "c8a4c4d93d4cb342aab42cd02d0317ca21347b21", "filename": "gcc/testsuite/gdc.test/fail_compilation/failob2.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffailob2.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffailob2.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffailob2.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -48,7 +48,7 @@ void test1() {\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/failob2.d(205): Error: variable `failob2.foo4!int.foo4.p` is left dangling at return\n+fail_compilation/failob2.d(205): Error: variable `failob2.foo4!int.foo4.p` is not disposed of before return\n fail_compilation/failob2.d(209): Error: template instance `failob2.foo4!int` error instantiating\n ---\n */"}, {"sha": "5862f7a8c88ad5cb3a77721203d893d3ac73a761", "filename": "gcc/testsuite/gdc.test/fail_compilation/fnconstraint.d", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffnconstraint.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffnconstraint.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffnconstraint.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,25 @@\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/fnconstraint.d(13): Error: template constraint must follow parameter lists and attributes\n+fail_compilation/fnconstraint.d(13): Error: declaration expected, not `if`\n+fail_compilation/fnconstraint.d(22): Error: template constraint must follow parameter lists and attributes\n+fail_compilation/fnconstraint.d(22): Error: declaration expected, not `if`\n+fail_compilation/fnconstraint.d(26): Error: `}` expected following members in `struct` declaration at fail_compilation/fnconstraint.d(18)\n+---\n+*/\n+void foo()()\n+in(true)\n+if (true)\n+{}\n+\n+alias f = foo!();\n+\n+struct S\n+{\n+    this()()\n+    if (true)\n+    if (true) {}\n+}\n+\n+S s;"}, {"sha": "d11a7a69916ee4d22de6e3edfca3b607062c1c70", "filename": "gcc/testsuite/gdc.test/fail_compilation/fob1.d", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffob1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffob1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffob1.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -18,7 +18,7 @@ fail_compilation/fob1.d(104): Error: variable `fob1.foo1.p` is returned but is U\n /* TEST_OUTPUT:\n ---\n fail_compilation/fob1.d(204): Error: variable `fob1.foo2.p` assigning to Owner without disposing of owned value\n-fail_compilation/fob1.d(203): Error: variable `fob1.foo2.p` is left dangling at return\n+fail_compilation/fob1.d(203): Error: variable `fob1.foo2.p` is not disposed of before return\n ---\n */\n \n@@ -35,7 +35,7 @@ fail_compilation/fob1.d(203): Error: variable `fob1.foo2.p` is left dangling at\n ---\n fail_compilation/fob1.d(304): Error: variable `fob1.foo3.p` has undefined state and cannot be read\n fail_compilation/fob1.d(304): Error: variable `fob1.foo3.p` is returned but is Undefined\n-fail_compilation/fob1.d(303): Error: variable `fob1.foo3.q` is left dangling at return\n+fail_compilation/fob1.d(303): Error: variable `fob1.foo3.q` is not disposed of before return\n ---\n */\n \n@@ -62,3 +62,20 @@ fail_compilation/fob1.d(405): Error: variable `fob1.foo4.bq` has undefined state\n     *bq = 1;\n     return p;\n }\n+\n+/* TEST_OUTPUT:\n+---\n+fail_compilation/fob1.d(503): Error: more than one mutable reference to `a` in arguments to `fob1.foo5()`\n+---\n+*/\n+\n+// https://issues.dlang.org/show_bug.cgi?id=20781\n+\n+#line 500\n+\n+void test5() {\n+    int a;\n+    foo5(a, a);\n+}\n+\n+@live void foo5(ref int, ref int);"}, {"sha": "e9179da74057c0ecbf3ce1d605d80efa092bc927", "filename": "gcc/testsuite/gdc.test/fail_compilation/fob2.d", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffob2.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffob2.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffob2.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -8,7 +8,7 @@ void free(int*);\n /* TEST_OUTPUT:\n ---\n fail_compilation/fob2.d(110): Error: variable `fob2.foo1.b1` has undefined state and cannot be read\n-fail_compilation/fob2.d(103): Error: variable `fob2.foo1.p` is left dangling at return\n+fail_compilation/fob2.d(103): Error: variable `fob2.foo1.p` is not disposed of before return\n ---\n */\n \n@@ -28,11 +28,13 @@ fail_compilation/fob2.d(103): Error: variable `fob2.foo1.p` is left dangling at\n \n /* TEST_OUTPUT:\n ---\n-fail_compilation/fob2.d(203): Error: variable `fob2.zoo2.p` is passed as Owner more than once\n-fail_compilation/fob2.d(202): Error: variable `fob2.zoo2.p` is left dangling at return\n+fail_compilation/fob2.d(203): Error: more than one mutable reference of `p` in arguments to `fob2.foo2()`\n ---\n */\n \n+//fail_compilation/fob2.d(203): Error: variable `fob2.zoo2.p` is passed as Owner more than once\n+//fail_compilation/fob2.d(202): Error: variable `fob2.zoo2.p` is left dangling at return\n+\n #line 200\n \n @live void zoo2() {\n@@ -44,7 +46,7 @@ fail_compilation/fob2.d(202): Error: variable `fob2.zoo2.p` is left dangling at\n \n /* TEST_OUTPUT:\n ---\n-fail_compilation/fob2.d(303): Error: variable `fob2.foo3.b` is left dangling at return\n+fail_compilation/fob2.d(303): Error: variable `fob2.foo3.b` is not disposed of before return\n ---\n */\n \n@@ -140,7 +142,8 @@ fail_compilation/fob2.d(515): Error: variable `fob2.test52.p` has undefined stat\n \n /* TEST_OUTPUT:\n ---\n-fail_compilation/fob2.d(603): Error: variable `fob2.test6.p` is left dangling at return\n+fail_compilation/fob2.d(603): Error: variable `fob2.test6.p` is not disposed of before return\n+fail_compilation/fob2.d(612): Error: more than one mutable reference of `p` in arguments to `fob2.foo6b()`\n ---\n */\n "}, {"sha": "b571059eb453ceca131a098e5773dd5dcaa41a17", "filename": "gcc/testsuite/gdc.test/fail_compilation/gag4269f.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fgag4269f.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fgag4269f.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fgag4269f.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -3,7 +3,7 @@\n TEST_OUTPUT:\n ---\n fail_compilation/gag4269f.d(11): Error: undefined identifier `Y9`, did you mean interface `X9`?\n-fail_compilation/gag4269f.d(11): Error: variable `gag4269f.X9.y` field not allowed in interface\n+fail_compilation/gag4269f.d(11): Error: field `y` not allowed in interface\n ---\n */\n "}, {"sha": "13eb8e09ed86cba4d95c59dd3fa680d7afe33061", "filename": "gcc/testsuite/gdc.test/fail_compilation/ice12727.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice12727.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice12727.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice12727.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1,13 +1,13 @@\n /*\n TEST_OUTPUT:\n ----\n+fail_compilation/ice12727.d(16): Error: template instance `IndexTuple!(1, 0)` recursive template expansion\n fail_compilation/ice12727.d(16): Error: alias `ice12727.IndexTuple!(1, 0).IndexTuple` recursive alias declaration\n fail_compilation/ice12727.d(23): Error: template instance `ice12727.IndexTuple!(1, 0)` error instantiating\n fail_compilation/ice12727.d(27):        instantiated from here: `Matrix!(float, 3)`\n fail_compilation/ice12727.d(28):        instantiated from here: `Vector!(float, 3)`\n ----\n */\n-\n template IndexTuple(int e, int s = 0, T...)\n {\n     static if (s == e)"}, {"sha": "03763f7c18a535857b0619ea8f88744bbfa9c70e", "filename": "gcc/testsuite/gdc.test/fail_compilation/ice12902.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice12902.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice12902.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice12902.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/ice12902.d(20): Error: variable `ice12902.main.__dollar` type `void` is inferred from initializer `s.opDollar()`, and variables cannot be of type `void`\n+fail_compilation/ice12902.d(20): Error: variable `ice12902.main.__dollar` - type `void` is inferred from initializer `s.opDollar()`, and variables cannot be of type `void`\n fail_compilation/ice12902.d(20): Error: expression `s.opDollar()` is `void` and has no value\n ---\n */"}, {"sha": "3e3989bc290a902312950f7601d2d1e124bd05c4", "filename": "gcc/testsuite/gdc.test/fail_compilation/ice13788.d", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice13788.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice13788.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice13788.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1,10 +1,10 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/ice13788.d(11): Error: pragma `mangle` string expected for mangled name\n+fail_compilation/ice13788.d(11): Error: pragma `mangle` - string expected for mangled name\n fail_compilation/ice13788.d(12): Error: `string` expected for mangled name, not `(1)` of type `int`\n-fail_compilation/ice13788.d(13): Error: pragma `mangle` zero-length string not allowed for mangled name\n-fail_compilation/ice13788.d(14): Error: pragma `mangle` mangled name characters can only be of type `char`\n+fail_compilation/ice13788.d(13): Error: pragma `mangle` - zero-length string not allowed for mangled name\n+fail_compilation/ice13788.d(14): Error: pragma `mangle` - mangled name characters can only be of type `char`\n ---\n */\n "}, {"sha": "aefe273da0c1ba2b1761055f4f8f257128f4cf05", "filename": "gcc/testsuite/gdc.test/fail_compilation/ice13816.d", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice13816.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice13816.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice13816.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1,11 +1,13 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/ice13816.d(15): Error: alias `ice13816.ItemProperty!().ItemProperty` recursive alias declaration\n-fail_compilation/ice13816.d(20): Error: template instance `ice13816.ItemProperty!()` error instantiating\n+fail_compilation/ice13816.d(17): Error: template instance `TypeTuple!(ItemProperty!())` recursive template expansion\n+fail_compilation/ice13816.d(17): Error: alias `ice13816.ItemProperty!().ItemProperty` recursive alias declaration\n+fail_compilation/ice13816.d(22): Error: template instance `ice13816.ItemProperty!()` error instantiating\n ---\n */\n \n+\n alias TypeTuple(T...) = T;\n \n template ItemProperty()"}, {"sha": "f41ab3e754f962c9c0f01d69fb811b04eceefa96", "filename": "gcc/testsuite/gdc.test/fail_compilation/ice18753.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice18753.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice18753.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice18753.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/ice18753.d(21): Error: variable `ice18753.isInputRange!(Group).isInputRange` type `void` is inferred from initializer `ReturnType(func...)`, and variables cannot be of type `void`\n+fail_compilation/ice18753.d(21): Error: variable `ice18753.isInputRange!(Group).isInputRange` - type `void` is inferred from initializer `ReturnType(func...)`, and variables cannot be of type `void`\n fail_compilation/ice18753.d(23): Error: template instance `ice18753.isInputRange!(Group)` error instantiating\n fail_compilation/ice18753.d(18):        instantiated from here: `isForwardRange!(Group)`\n fail_compilation/ice18753.d(18):        while evaluating: `static assert(isForwardRange!(Group))`"}, {"sha": "6fdb71a39763969e146d0829c841e62bf48afb17", "filename": "gcc/testsuite/gdc.test/fail_compilation/ice23569.d", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice23569.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice23569.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice23569.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -2,11 +2,17 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/ice23569.d(18): Error: cannot compare classes for equality because `object.Object` was not declared\n+fail_compilation/ice23569.d(24): Error: cannot compare classes for equality because `object.Object` was not declared\n ---\n */\n module object;\n \n+T _d_newclassT(T)()\n+if (is(T == class))\n+{\n+    return null;\n+}\n+\n @safe unittest1()\n {\n     class F"}, {"sha": "fe4ad78f1accafe810de97e649c4eca253dde580", "filename": "gcc/testsuite/gdc.test/fail_compilation/issue16020.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fissue16020.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fissue16020.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fissue16020.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -2,7 +2,7 @@\n TEST_OUTPUT:\n ---\n fail_compilation/issue16020.d(12): Error: user-defined attributes not allowed for `alias` declarations\n-fail_compilation/issue16020.d(13): Error: semicolon expected to close `alias` declaration\n+fail_compilation/issue16020.d(13): Error: semicolon expected to close `alias` declaration, not `(`\n fail_compilation/issue16020.d(13): Error: declaration expected, not `(`\n ---\n */"}, {"sha": "0900e6010d1fef8ac57cd53582cdb1ed10c4a481", "filename": "gcc/testsuite/gdc.test/fail_compilation/named_arguments_error.d", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fnamed_arguments_error.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fnamed_arguments_error.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fnamed_arguments_error.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,48 @@\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/named_arguments_error.d(32): Error: function `named_arguments_error.f(int x, int y, int z)` is not callable using argument types `(int, int, int)`\n+fail_compilation/named_arguments_error.d(32):        parameter `x` assigned twice\n+fail_compilation/named_arguments_error.d(33): Error: function `named_arguments_error.f(int x, int y, int z)` is not callable using argument types `(int, int, int)`\n+fail_compilation/named_arguments_error.d(33):        argument `4` goes past end of parameter list\n+fail_compilation/named_arguments_error.d(34): Error: function `named_arguments_error.f(int x, int y, int z)` is not callable using argument types `(int, int, int)`\n+fail_compilation/named_arguments_error.d(34):        parameter `y` assigned twice\n+fail_compilation/named_arguments_error.d(35): Error: function `named_arguments_error.f(int x, int y, int z)` is not callable using argument types `(int, int, int)`\n+fail_compilation/named_arguments_error.d(35):        no parameter named `a`\n+fail_compilation/named_arguments_error.d(36): Error: function `named_arguments_error.g(int x, int y, int z = 3)` is not callable using argument types `(int, int)`\n+fail_compilation/named_arguments_error.d(36):        missing argument for parameter #1: `int x`\n+fail_compilation/named_arguments_error.d(38): Error: no named argument `element` allowed for array dimension\n+fail_compilation/named_arguments_error.d(39): Error: no named argument `number` allowed for scalar\n+fail_compilation/named_arguments_error.d(40): Error: cannot implicitly convert expression `g(x: 3, y: 4, z: 5)` of type `int` to `string`\n+fail_compilation/named_arguments_error.d(41): Error: named arguments with Implicit Function Template Instantiation are not supported yet\n+fail_compilation/named_arguments_error.d(41): Error: none of the overloads of template `named_arguments_error.tempfun` are callable using argument types `!()(string, int)`\n+fail_compilation/named_arguments_error.d(45):        Candidate is: `tempfun(T, U)(T t, U u)`\n+---\n+*/\n+\n+\n+\n+\n+void f(int x, int y, int z);\n+\n+int g(int x, int y, int z = 3);\n+\n+void main()\n+{\n+\tf(x: 3, x: 3, 5);\n+\tf(z: 3,    4, 5);\n+\tf(y: 3, x: 4, 5);\n+\tf(a: 3, b: 4, 5);\n+\tg(y: 4, z: 3);\n+\n+\tauto g0 = new int[](element: 3);\n+\tauto g1 = new int(number: 3);\n+\tstring s = g(x: 3, y: 4, z: 5);\n+\tenum x = tempfun(u: \"u\", t: 0);\n+}\n+\n+// template arguments\n+int tempfun(T, U)(T t, U u)\n+{\n+\treturn 3;\n+}"}, {"sha": "a9704464605c8a6dd9c7e6e284e2f21d359747e6", "filename": "gcc/testsuite/gdc.test/fail_compilation/named_arguments_overload.d", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fnamed_arguments_overload.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fnamed_arguments_overload.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fnamed_arguments_overload.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,35 @@\n+/**\n+TEST_OUTPUT:\n+---\n+fail_compilation/named_arguments_overload.d(33): Error: none of the overloads of `snoopy` are callable using argument types `(immutable(S), immutable(T))`\n+fail_compilation/named_arguments_overload.d(17):        Candidates are: `named_arguments_overload.snoopy(S s, int i = 0, T t = T())`\n+fail_compilation/named_arguments_overload.d(18):                        `named_arguments_overload.snoopy(T t, int i, S s)`\n+fail_compilation/named_arguments_overload.d(34): Error: none of the overloads of `snoopy` are callable using argument types `(immutable(T), immutable(S))`\n+fail_compilation/named_arguments_overload.d(17):        Candidates are: `named_arguments_overload.snoopy(S s, int i = 0, T t = T())`\n+fail_compilation/named_arguments_overload.d(18):                        `named_arguments_overload.snoopy(T t, int i, S s)`\n+fail_compilation/named_arguments_overload.d(35): Error: `named_arguments_overload.snoopy` called with argument types `(immutable(S), immutable(T), immutable(int))` matches both:\n+fail_compilation/named_arguments_overload.d(17):     `named_arguments_overload.snoopy(S s, int i = 0, T t = T())`\n+and:\n+fail_compilation/named_arguments_overload.d(18):     `named_arguments_overload.snoopy(T t, int i, S s)`\n+---\n+*/\n+\n+char snoopy(S s, int i = 0, T t = T.init) { return 'B'; }\n+char snoopy(T t, int i, S s) { return 'A'; }\n+\n+struct S { }\n+struct T { }\n+immutable S s = S.init;\n+immutable T t = T.init;\n+immutable int i = 0;\n+\n+static assert(snoopy(t,   i, s    ) == 'A');\n+static assert(snoopy(s,   i, t    ) == 'B');\n+static assert(snoopy(s:s, t:t     ) == 'B');\n+static assert(snoopy(t:t, s:s     ) == 'B');\n+static assert(snoopy(t:t, i,   s:s) == 'A');\n+static assert(snoopy(s:s, t:t, i  ) == 'A');\n+\n+immutable err0 = snoopy(s, t); // error, neither A nor B match\n+immutable err1 = snoopy(t, s); // error, neither A nor B match\n+immutable err2 = snoopy(s:s, t:t, i:i); // error, ambiguous"}, {"sha": "19e230ee519dc1c12907c6666fcea0c0ef21fb02", "filename": "gcc/testsuite/gdc.test/fail_compilation/named_arguments_parse.d", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fnamed_arguments_parse.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fnamed_arguments_parse.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fnamed_arguments_parse.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,15 @@\n+/**\n+TEST_OUTPUT:\n+---\n+fail_compilation/named_arguments_parse.d(10): Error: named arguments not allowed here\n+fail_compilation/named_arguments_parse.d(13): Error: named arguments not allowed here\n+fail_compilation/named_arguments_parse.d(14): Error: named arguments not allowed here\n+---\n+*/\n+\n+@(attribute: 3)\n+void main()\n+{\n+\tmixin(thecode: \"{}\");\n+\tpragma(msg, themsg: \"hello\");\n+}"}, {"sha": "5c581d1db71c2f1dcbc800cf061e1c362236cbbe", "filename": "gcc/testsuite/gdc.test/fail_compilation/retscope6.d", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fretscope6.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fretscope6.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fretscope6.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -141,13 +141,14 @@ void testarchie()\n \n /* TEST_OUTPUT:\n ---\n-fail_compilation/retscope6.d(9022): Error: returning `fred(& i)` escapes a reference to local variable `i`\n+fail_compilation/retscope6.d(9023): Error: returning `fred(& i)` escapes a reference to local variable `i`\n ---\n */\n \n #line 9000\n \n-@safe:\n+@safe\n+{\n \n alias T9 = S9!(); struct S9()\n {\n@@ -199,6 +200,7 @@ void hmac(scope ubyte[] secret)\n     ubyte[10] buffer;\n     secret = buffer[];\n }\n+}\n \n /* TEST_OUTPUT:\n ---\n@@ -289,3 +291,5 @@ ref int escape23021() @safe\n     // ensure we do not infer return ref\n     return infer23021(nonScopePtr); // no error\n }\n+\n+/******************************/"}, {"sha": "afdea64c744720dea5e3243b2e70486d594b5ce2", "filename": "gcc/testsuite/gdc.test/fail_compilation/shared.d", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fshared.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fshared.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fshared.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -86,7 +86,7 @@ fail_compilation/shared.d(2148): Error: direct access to shared `*c` is not allo\n fail_compilation/shared.d(2154): Error: direct access to shared `*c.c1` is not allowed, see `core.atomic`\n fail_compilation/shared.d(2160): Error: direct access to shared `*c.c1.c1` is not allowed, see `core.atomic`\n fail_compilation/shared.d(2181): Error: direct access to shared `k` is not allowed, see `core.atomic`\n-fail_compilation/shared.d(2187): Error: direct access to shared `k.k2.k1` is not allowed, see `core.atomic`\n+fail_compilation/shared.d(2187): Error: direct access to shared `k.k2.k1.value` is not allowed, see `core.atomic`\n fail_compilation/shared.d(2194): Error: direct access to shared `(new shared(K2)).k1` is not allowed, see `core.atomic`\n fail_compilation/shared.d(2202): Error: direct access to shared `c` is not allowed, see `core.atomic`\n fail_compilation/shared.d(2206): Error: function `shared.test_inference_2` function returns `shared` but cannot be inferred `ref`\n@@ -236,3 +236,26 @@ struct BitRange\n         this.bits++;\n     }\n }\n+\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/shared.d(3004): Error: cast from `void*` to `shared(int*)` not allowed in safe code\n+fail_compilation/shared.d(3005): Error: cast from `void*` to `shared(const(int*))` not allowed in safe code\n+fail_compilation/shared.d(3008): Error: cast from `shared(void*)` to `int*` not allowed in safe code\n+fail_compilation/shared.d(3009): Error: cast from `shared(void*)` to `shared(const(int*))` not allowed in safe code\n+---\n+*/\n+\n+#line 3000\n+\n+void test_casting_safe() @safe\n+{\n+    void *p;\n+    auto t1 = cast(shared(int*))p;\n+    auto t2 = cast(const(shared(int*)))p;\n+\n+    shared void* s;\n+    auto x1 = cast(int*)s;\n+    auto x2 = cast(const(shared(int*)))s;\n+}"}, {"sha": "ab12e86602c15b7c2c5007ed4205ac2943c40af1", "filename": "gcc/testsuite/gdc.test/fail_compilation/test15368.d", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest15368.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest15368.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest15368.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,14 @@\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/test15368.d(13): Error: cannot declare `auto` loop variable, omit `auto` to still get type inference\n+---\n+*/\n+\n+// Issue 15368 - Improve error message for \"auto\" keyword inside \"foreach\"\n+// https://issues.dlang.org/show_bug.cgi?id=15368\n+\n+void main()\n+{\n+    foreach (auto e; foo) { }\n+}"}, {"sha": "667d4c2feb774f62d1f5c417674af4e1e1b7182f", "filename": "gcc/testsuite/gdc.test/fail_compilation/test16495.d", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest16495.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest16495.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest16495.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,18 @@\n+/* TEST_OUTPUT:\n+---\n+fail_compilation/test16495.d(12): Error: undefined identifier `q`\n+fail_compilation/test16495.d(17): Error: expected 1 arguments for `fullyQualifiedName` but had 0\n+---\n+ */\n+\n+// https://issues.dlang.org/show_bug.cgi?id=16495\n+\n+void test1()\n+{\n+    auto m = __traits(fullyQualifiedName, q);\n+}\n+\n+void test2()\n+{\n+    auto n = __traits(fullyQualifiedName);\n+}"}, {"sha": "2c431a3849b33b498c8fc2d6db497fa3e29889c3", "filename": "gcc/testsuite/gdc.test/fail_compilation/test17096.d", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest17096.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest17096.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest17096.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1,28 +1,29 @@\n /* TEST_OUTPUT:\n ---\n-fail_compilation/test17096.d(28): Error: expected 1 arguments for `isPOD` but had 2\n-fail_compilation/test17096.d(29): Error: expected 1 arguments for `isNested` but had 2\n-fail_compilation/test17096.d(30): Error: expected 1 arguments for `isVirtualFunction` but had 2\n-fail_compilation/test17096.d(31): Error: expected 1 arguments for `isVirtualMethod` but had 2\n-fail_compilation/test17096.d(32): Error: expected 1 arguments for `isAbstractFunction` but had 2\n-fail_compilation/test17096.d(33): Error: expected 1 arguments for `isFinalFunction` but had 2\n-fail_compilation/test17096.d(34): Error: expected 1 arguments for `isOverrideFunction` but had 2\n-fail_compilation/test17096.d(35): Error: expected 1 arguments for `isStaticFunction` but had 2\n-fail_compilation/test17096.d(36): Error: expected 1 arguments for `isRef` but had 2\n-fail_compilation/test17096.d(37): Error: expected 1 arguments for `isOut` but had 2\n-fail_compilation/test17096.d(38): Error: expected 1 arguments for `isLazy` but had 2\n-fail_compilation/test17096.d(39): Error: expected 1 arguments for `identifier` but had 2\n-fail_compilation/test17096.d(40): Error: expected 1 arguments for `getProtection` but had 2\n-fail_compilation/test17096.d(41): Error: expected 1 arguments for `parent` but had 2\n-fail_compilation/test17096.d(42): Error: expected 1 arguments for `classInstanceSize` but had 2\n-fail_compilation/test17096.d(43): Error: expected 1 arguments for `allMembers` but had 2\n-fail_compilation/test17096.d(44): Error: expected 1 arguments for `derivedMembers` but had 2\n-fail_compilation/test17096.d(45): Error: expected 1 arguments for `getAliasThis` but had 2\n-fail_compilation/test17096.d(46): Error: expected 1 arguments for `getAttributes` but had 2\n-fail_compilation/test17096.d(47): Error: expected 1 arguments for `getFunctionAttributes` but had 2\n-fail_compilation/test17096.d(48): Error: expected 1 arguments for `getUnitTests` but had 2\n-fail_compilation/test17096.d(49): Error: expected 1 arguments for `getVirtualIndex` but had 2\n-fail_compilation/test17096.d(50): Error: a single type expected for trait pointerBitmap\n+fail_compilation/test17096.d(29): Error: expected 1 arguments for `isPOD` but had 2\n+fail_compilation/test17096.d(30): Error: expected 1 arguments for `isNested` but had 2\n+fail_compilation/test17096.d(31): Deprecation: `traits(isVirtualFunction)` is deprecated. Use `traits(isVirtualMethod)` instead\n+fail_compilation/test17096.d(31): Error: expected 1 arguments for `isVirtualFunction` but had 2\n+fail_compilation/test17096.d(32): Error: expected 1 arguments for `isVirtualMethod` but had 2\n+fail_compilation/test17096.d(33): Error: expected 1 arguments for `isAbstractFunction` but had 2\n+fail_compilation/test17096.d(34): Error: expected 1 arguments for `isFinalFunction` but had 2\n+fail_compilation/test17096.d(35): Error: expected 1 arguments for `isOverrideFunction` but had 2\n+fail_compilation/test17096.d(36): Error: expected 1 arguments for `isStaticFunction` but had 2\n+fail_compilation/test17096.d(37): Error: expected 1 arguments for `isRef` but had 2\n+fail_compilation/test17096.d(38): Error: expected 1 arguments for `isOut` but had 2\n+fail_compilation/test17096.d(39): Error: expected 1 arguments for `isLazy` but had 2\n+fail_compilation/test17096.d(40): Error: expected 1 arguments for `identifier` but had 2\n+fail_compilation/test17096.d(41): Error: expected 1 arguments for `getProtection` but had 2\n+fail_compilation/test17096.d(42): Error: expected 1 arguments for `parent` but had 2\n+fail_compilation/test17096.d(43): Error: expected 1 arguments for `classInstanceSize` but had 2\n+fail_compilation/test17096.d(44): Error: expected 1 arguments for `allMembers` but had 2\n+fail_compilation/test17096.d(45): Error: expected 1 arguments for `derivedMembers` but had 2\n+fail_compilation/test17096.d(46): Error: expected 1 arguments for `getAliasThis` but had 2\n+fail_compilation/test17096.d(47): Error: expected 1 arguments for `getAttributes` but had 2\n+fail_compilation/test17096.d(48): Error: expected 1 arguments for `getFunctionAttributes` but had 2\n+fail_compilation/test17096.d(49): Error: expected 1 arguments for `getUnitTests` but had 2\n+fail_compilation/test17096.d(50): Error: expected 1 arguments for `getVirtualIndex` but had 2\n+fail_compilation/test17096.d(51): Error: a single type expected for trait pointerBitmap\n ---\n */\n enum b03 = __traits(isPOD, 1, 2);"}, {"sha": "b0cda2105a22aeff6230696b8dc365db60d8d9a7", "filename": "gcc/testsuite/gdc.test/fail_compilation/test17451.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest17451.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest17451.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest17451.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -2,7 +2,7 @@\n ---\n fail_compilation/test17451.d(22): Error: undefined identifier `allocator`\n fail_compilation/test17451.d(23): Error: `false` has no effect\n-fail_compilation/test17451.d(30): Error: variable `test17451.HashMap!(ThreadSlot).HashMap.__lambda2.v` size of type `ThreadSlot` is invalid\n+fail_compilation/test17451.d(30): Error: variable `test17451.HashMap!(ThreadSlot).HashMap.__lambda2.v` - size of type `ThreadSlot` is invalid\n fail_compilation/test17451.d(44): Error: template instance `test17451.HashMap!(ThreadSlot)` error instantiating\n ---\n */"}, {"sha": "dc95da10eb534c1fe80de4da290c48103509502c", "filename": "gcc/testsuite/gdc.test/fail_compilation/test20549.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest20549.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest20549.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest20549.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ----\n-fail_compilation/test20549.d(12): Error: variable `test.__a_field_0` variables cannot be of type `void`\n+fail_compilation/test20549.d(12): Error: variable `test.__a_field_0` - variables cannot be of type `void`\n ----\n */\n "}, {"sha": "b9305f20f80fac4ff7311e1d0c33053cf0249a8b", "filename": "gcc/testsuite/gdc.test/fail_compilation/test20719.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest20719.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest20719.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest20719.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1,7 +1,7 @@\n /* TEST_OUTPUT:\n ---\n fail_compilation/test20719.d(13): Error: struct `test20719.SumType` no size because of forward reference\n-fail_compilation/test20719.d(32): Error: variable `test20719.isCopyable!(SumType).__lambda2.foo` size of type `SumType` is invalid\n+fail_compilation/test20719.d(32): Error: variable `test20719.isCopyable!(SumType).__lambda2.foo` - size of type `SumType` is invalid\n fail_compilation/test20719.d(18): Error: template instance `test20719.isCopyable!(SumType)` error instantiating\n ---\n */"}, {"sha": "0b452774245f7315b10e3677086c673477536a3c", "filename": "gcc/testsuite/gdc.test/fail_compilation/test20809.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest20809.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest20809.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest20809.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1,8 +1,8 @@\n /*\n-REQUIRED_ARGS: -de\n+REQUIRED_ARGS:\n TEST_OUTPUT:\n ---\n-fail_compilation/test20809.d(114): Deprecation: returning `this.a` escapes a reference to parameter `this`\n+fail_compilation/test20809.d(114): Error: returning `this.a` escapes a reference to parameter `this`\n fail_compilation/test20809.d(112):        perhaps annotate the function with `return`\n ---\n  */"}, {"sha": "2e137ab76316bb3f181cf696f02a9483b213123b", "filename": "gcc/testsuite/gdc.test/fail_compilation/test20998.d", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest20998.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest20998.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest20998.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -6,7 +6,7 @@ TEST_OUTPUT:\n fail_compilation/test20998.d(76): Error: undefined identifier `invalid`\n X x = { invalid, 2, \"asd\" };\n         ^\n-fail_compilation/test20998.d(76): Error: too many initializers for `X`\n+fail_compilation/test20998.d(76): Error: too many initializers for `X` with 2 fields\n X x = { invalid, 2, \"asd\" };\n                     ^\n fail_compilation/test20998.d(83): Error: cannot implicitly convert expression `\"a\"` of type `string` to `int`\n@@ -15,7 +15,7 @@ X2 x2 = { ptr: null, \"a\", ptr: 2, 444 };\n fail_compilation/test20998.d(83): Error: duplicate initializer for field `ptr`\n X2 x2 = { ptr: null, \"a\", ptr: 2, 444 };\n                                ^\n-fail_compilation/test20998.d(83): Error: too many initializers for `X2`\n+fail_compilation/test20998.d(83): Error: too many initializers for `X2` with 3 fields\n X2 x2 = { ptr: null, \"a\", ptr: 2, 444 };\n                                   ^\n fail_compilation/test20998.d(90): Error: overlapping initialization for field `ptr` and `x`\n@@ -27,7 +27,7 @@ X3 x3 = { ptr: null, \"a\", ptr: 2, 444 };\n fail_compilation/test20998.d(90): Error: duplicate initializer for field `ptr`\n X3 x3 = { ptr: null, \"a\", ptr: 2, 444 };\n                                ^\n-fail_compilation/test20998.d(90): Error: too many initializers for `X3`\n+fail_compilation/test20998.d(90): Error: too many initializers for `X3` with 3 fields\n X3 x3 = { ptr: null, \"a\", ptr: 2, 444 };\n                                   ^\n fail_compilation/test20998.d(98): Error: field `X4.ptr` cannot assign to misaligned pointers in `@safe` code\n@@ -36,7 +36,7 @@ fail_compilation/test20998.d(98): Error: field `X4.ptr` cannot assign to misalig\n fail_compilation/test20998.d(98): Error: cannot implicitly convert expression `\"a\"` of type `string` to `int`\n     X4 x4 = { ptr: null, \"a\", 444, ptr: 2, true };\n                          ^\n-fail_compilation/test20998.d(98): Error: too many initializers for `X4`\n+fail_compilation/test20998.d(98): Error: too many initializers for `X4` with 2 fields\n     X4 x4 = { ptr: null, \"a\", 444, ptr: 2, true };\n                               ^\n fail_compilation/test20998.d(102):        called from here: `test()`\n@@ -51,16 +51,16 @@ X2 a5 = { ptr: 1, ptr: 2, ptr: 444, ptr: 555 };\n fail_compilation/test20998.d(104): Error: duplicate initializer for field `ptr`\n X2 a5 = { ptr: 1, ptr: 2, ptr: 444, ptr: 555 };\n                                ^\n-fail_compilation/test20998.d(104): Error: too many initializers for `X2`\n+fail_compilation/test20998.d(104): Error: too many initializers for `X2` with 3 fields\n X2 a5 = { ptr: 1, ptr: 2, ptr: 444, ptr: 555 };\n                                          ^\n-fail_compilation/test20998.d(107): Error: too many initializers for `X2`\n+fail_compilation/test20998.d(107): Error: too many initializers for `X2` with 3 fields\n X2 c6 = { null, 2, true, null };\n                          ^\n fail_compilation/test20998.d(116): Error: cannot implicitly convert expression `1` of type `int` to `immutable(char*)`\n     immutable Struct iStruct = {1, &ch};\n                                 ^\n-fail_compilation/test20998.d(116): Error: too many initializers for `Struct`\n+fail_compilation/test20998.d(116): Error: too many initializers for `Struct` with 1 field\n     immutable Struct iStruct = {1, &ch};\n                                    ^\n fail_compilation/test20998.d(120):        called from here: `test2()`"}, {"sha": "a47c0fe95b761dd76e3800620d77b6eea402b051", "filename": "gcc/testsuite/gdc.test/fail_compilation/test22593.d", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e2c3dd6afcf9b152df72b30e205b0180c0afd5/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest22593.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e2c3dd6afcf9b152df72b30e205b0180c0afd5/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest22593.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest22593.d?ref=c5e2c3dd6afcf9b152df72b30e205b0180c0afd5", "patch": "@@ -1,23 +0,0 @@\n-// https://issues.dlang.org/show_bug.cgi?id=22593\n-\n-/*\n-TEST_OUTPUT:\n----\n-fail_compilation/test22593.d(14): Error: cannot define both an rvalue constructor and a copy constructor for `struct Foo`\n-fail_compilation/test22593.d(22):        Template instance `__ctor!(immutable(Foo!int), immutable(Foo!int))` creates a rvalue constructor for `struct Foo`\n-fail_compilation/test22593.d(22): Error: template instance `test22593.Foo!int.Foo.__ctor!(immutable(Foo!int), immutable(Foo!int))` error instantiating\n----\n-*/\n-\n-struct Foo(T)\n-{\n-    this(Rhs, this This)(scope Rhs rhs){}\n-\n-    this(ref scope typeof(this) rhs){}\n-}\n-\n-void main()\n-{\n-    immutable Foo!int a;\n-    a.__ctor(a);\n-}"}, {"sha": "69b6f39ad7795d5b4c0e4e2f19d2b67d5967ff6b", "filename": "gcc/testsuite/gdc.test/fail_compilation/test23607.d", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest23607.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest23607.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest23607.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,16 @@\n+//https://issues.dlang.org/show_bug.cgi?id=23607\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/test23607.d(15): Error: template `to(T)()` does not have property `bad`\n+fail_compilation/test23607.d(16): Error: template `to(T)()` does not have property `bad`\n+---\n+*/\n+\n+template to(T)\n+{\n+    void to(T)(){}\n+}\n+\n+alias comb = to!int.bad!0;\n+auto combe = to!int.bad!0;"}, {"sha": "0f11de94d9da4c50b54981eb9ff5ba5479179d1a", "filename": "gcc/testsuite/gdc.test/fail_compilation/test23674.d", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest23674.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest23674.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest23674.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,15 @@\n+// https://issues.dlang.org/show_bug.cgi?id=23674\n+\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/test23674.d(14): Error: array index 2 is out of bounds `arr[0 .. 2]`\n+fail_compilation/test23674.d(14): Error: array index 3 is out of bounds `arr[0 .. 2]`\n+---\n+*/\n+\n+void main()\n+{\n+    string[2] arr;\n+    assert(arr[2] == arr[3]);\n+}"}, {"sha": "e834b78f7d57f3a2f4222ad7b3ccbafeae91d79c", "filename": "gcc/testsuite/gdc.test/fail_compilation/test23710.d", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest23710.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest23710.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest23710.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,32 @@\n+/* REQUIRED_ARGS: -betterC\n+TEST_OUTPUT:\n+---\n+fail_compilation/test23710.d(111): Error: array concatenation of expression `foo ~ [1, 2, 3]` requires the GC which is not available with -betterC\n+---\n+ */\n+// https://issues.dlang.org/show_bug.cgi?id=23710\n+\n+#line 100\n+\n+int test(int i)\n+{\n+    int j;\n+    int[] foo;\n+    if (0)\n+    {\n+        for (;;)\n+        {\n+            import core.stdc.stdio;\n+            printf(\"start body\\n\");\n+            foo = foo ~ [1,2,3];\n+L1:\n+            printf(\"foo.length = %zu\\n\", foo.length);\n+\t    j += foo.length;\n+            i += 2;\n+            if (i > 5)\n+                return j;\n+            printf(\"end body\\n\");\n+        }\n+    }\n+    goto L1;\n+}"}, {"sha": "41b6e52545e09aa552b140d4fede23ce21bc0fb8", "filename": "gcc/testsuite/gdc.test/fail_compilation/test_switch_error.d", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest_switch_error.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest_switch_error.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest_switch_error.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -104,7 +104,7 @@ void test5(int i)\n TEST_OUTPUT:\n ---\n fail_compilation/test_switch_error.d(513): Error: undefined identifier `undefinedFunc`\n-fail_compilation/test_switch_error.d(517): Error: `case` must be a `string` or an integral constant, not `Strukt(1)`\n+fail_compilation/test_switch_error.d(517): Error: `case` expression must be a compile-time `string` or an integral constant, not `Strukt(1)`\n fail_compilation/test_switch_error.d(518): Error: `case` variables have to be `const` or `immutable`\n fail_compilation/test_switch_error.d(518): Error: `case` variables not allowed in `final switch` statements\n fail_compilation/test_switch_error.d(519): Error: `case` variables not allowed in `final switch` statements\n@@ -144,8 +144,8 @@ void errorsWithErrors(int param, immutable int constant)\n TEST_OUTPUT:\n ---\n fail_compilation/test_switch_error.d(622): Error: undefined identifier `undefinedFunc`\n-fail_compilation/test_switch_error.d(624): Error: `case` must be a `string` or an integral constant, not `SubtypeOfInt(2)`\n-fail_compilation/test_switch_error.d(625): Error: `case` must be a `string` or an integral constant, not `SubtypeOfIntMethod()`\n+fail_compilation/test_switch_error.d(624): Error: `case` expression must be a compile-time `string` or an integral constant, not `SubtypeOfInt(2)`\n+fail_compilation/test_switch_error.d(625): Error: `case` expression must be a compile-time `string` or an integral constant, not `SubtypeOfIntMethod()`\n ---\n ++/\n #line 600"}, {"sha": "96511f511e4c23f97ed15f2fc1842ee0b61ae99d", "filename": "gcc/testsuite/gdc.test/fail_compilation/testrvaluecpctor.d", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftestrvaluecpctor.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftestrvaluecpctor.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftestrvaluecpctor.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,47 @@\n+// https://issues.dlang.org/show_bug.cgi?id=22593\n+\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/testrvaluecpctor.d(16): Error: cannot define both an rvalue constructor and a copy constructor for `struct Foo`\n+fail_compilation/testrvaluecpctor.d(24):        Template instance `testrvaluecpctor.Foo!int.Foo.__ctor!(immutable(Foo!int), immutable(Foo!int))` creates an rvalue constructor for `struct Foo`\n+fail_compilation/testrvaluecpctor.d(24): Error: none of the overloads of `__ctor` are callable using a `immutable` object\n+fail_compilation/testrvaluecpctor.d(18):        Candidates are: `testrvaluecpctor.Foo!int.Foo.this(ref Foo!int rhs)`\n+fail_compilation/testrvaluecpctor.d(16):                        `__ctor(Rhs, this This)(scope Rhs rhs)`\n+---\n+*/\n+\n+struct Foo(T)\n+{\n+    this(Rhs, this This)(scope Rhs rhs){}\n+\n+    this(ref scope typeof(this) rhs){}\n+}\n+\n+void fail22593()\n+{\n+    immutable Foo!int a;\n+    a.__ctor(a);\n+}\n+\n+// https://issues.dlang.org/show_bug.cgi?id=21613\n+\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/testrvaluecpctor.d(40): Error: cannot define both an rvalue constructor and a copy constructor for `struct Test`\n+fail_compilation/testrvaluecpctor.d(46):        Template instance `testrvaluecpctor.Test.__ctor!()` creates an rvalue constructor for `struct Test`\n+---\n+*/\n+\n+struct Test\n+{\n+    this(ref const typeof(this) rhs){}\n+    this()(const typeof(this) rhs){}    // rvalue ctor\n+}\n+\n+void fail21613()\n+{\n+    const Test cb;\n+    Test b = cb;\n+}"}, {"sha": "cc7b0125953f1a1607d353963755d9c7ee8e5f0a", "filename": "gcc/testsuite/gdc.test/fail_compilation/testscopestatic.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftestscopestatic.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftestscopestatic.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftestscopestatic.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -4,7 +4,7 @@\n fail_compilation/testscopestatic.d(15): Error: variable `testscopestatic.foo.p` cannot be `scope` and `static`\n fail_compilation/testscopestatic.d(16): Error: variable `testscopestatic.foo.b` cannot be `scope` and `extern`\n fail_compilation/testscopestatic.d(17): Error: variable `testscopestatic.foo.c` cannot be `scope` and `__gshared`\n-fail_compilation/testscopestatic.d(21): Error: variable `testscopestatic.foo.S.x` field cannot be `scope`\n+fail_compilation/testscopestatic.d(21): Error: field `x` cannot be `scope`\n ---\n */\n "}, {"sha": "453ebba4e09c5946d053dbd94f2b3da83e7d21a0", "filename": "gcc/testsuite/gdc.test/fail_compilation/udaparams.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fudaparams.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fudaparams.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fudaparams.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -14,9 +14,9 @@ fail_compilation/udaparams.d(44): Error: `@trusted` attribute for function param\n fail_compilation/udaparams.d(45): Error: `@nogc` attribute for function parameter is not supported\n fail_compilation/udaparams.d(51): Error: cannot put a storage-class in an `alias` declaration.\n fail_compilation/udaparams.d(52): Error: cannot put a storage-class in an `alias` declaration.\n-fail_compilation/udaparams.d(53): Error: semicolon expected to close `alias` declaration\n+fail_compilation/udaparams.d(53): Error: semicolon expected to close `alias` declaration, not `=>`\n fail_compilation/udaparams.d(53): Error: declaration expected, not `=>`\n-fail_compilation/udaparams.d(54): Error: semicolon expected to close `alias` declaration\n+fail_compilation/udaparams.d(54): Error: semicolon expected to close `alias` declaration, not `=>`\n fail_compilation/udaparams.d(54): Error: declaration expected, not `=>`\n fail_compilation/udaparams.d(57): Error: basic type expected, not `@`\n fail_compilation/udaparams.d(57): Error: identifier expected for template value parameter"}, {"sha": "50e5c4db64bf60c49ecd727c2a0e7c248ae34c5c", "filename": "gcc/testsuite/gdc.test/runnable/aliasthis.d", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Faliasthis.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Faliasthis.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Faliasthis.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1,7 +1,16 @@\n /*\n TEST_OUTPUT:\n ---\n+runnable/aliasthis.d(103): Deprecation: alias this for classes/interfaces is deprecated\n+runnable/aliasthis.d(291): Deprecation: alias this for classes/interfaces is deprecated\n+runnable/aliasthis.d(292): Deprecation: alias this for classes/interfaces is deprecated\n+runnable/aliasthis.d(294): Deprecation: alias this for classes/interfaces is deprecated\n+runnable/aliasthis.d(465): Deprecation: alias this for classes/interfaces is deprecated\n+runnable/aliasthis.d(466): Deprecation: alias this for classes/interfaces is deprecated\n+runnable/aliasthis.d(477): Deprecation: alias this for classes/interfaces is deprecated\n+runnable/aliasthis.d(1013): Deprecation: alias this for classes/interfaces is deprecated\n false\n+runnable/aliasthis.d(2100): Deprecation: alias this for classes/interfaces is deprecated\n [] = int\n [] = string\n [0] = int\n@@ -10,6 +19,7 @@ false\n [] = int\n [1] = string\n [0] = int\n+runnable/aliasthis.d(741): Deprecation: alias this for classes/interfaces is deprecated\n ---\n \n RUN_OUTPUT:"}, {"sha": "af95545ccc9b3c5554f3824608086fb522ad81ca", "filename": "gcc/testsuite/gdc.test/runnable/auto1.d", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fauto1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fauto1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fauto1.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -67,13 +67,13 @@ int ax;\n \n class A2\n {\n-  this()\n+  this() scope\n   {\n     printf(\"A2.this()\\n\");\n     ax += 1;\n   }\n \n-  ~this()\n+  ~this() scope\n   {\n     printf(\"A2.~this()\\n\");\n     ax += 1000;\n@@ -102,12 +102,12 @@ class Parent3\n \n class Child3 : Parent3\n {\n-        this(){\n+        this() scope {\n                 assert(status3==0);\n                 status3=1;\n         }\n \n-        ~this(){\n+        ~this() scope {\n                 assert(status3==1);\n                 status3=2;\n         }"}, {"sha": "711f309b7a2c3eac69f47a73520e64c1ecbf9f74", "filename": "gcc/testsuite/gdc.test/runnable/cppdtor.d", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fcppdtor.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fcppdtor.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fcppdtor.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -38,38 +38,38 @@ extern (C) int printf(scope const char*, ...);\n extern (C++) class CppA\n {\n \tint num;\n-\tthis(int num)\n+\tthis(int num) scope\n \t{\n \t\tthis.num = num;\n \t}\n \n-\t~this()\n+\t~this() scope\n \t{\n \t\tprintf(\"%d: CppA.~this\\n\", num);\n \t}\n }\n \n extern (C++) class CppB : CppA\n {\n-\tthis(int num)\n+\tthis(int num) scope\n \t{\n \t\tsuper(num);\n \t}\n \n-\t~this()\n+\t~this() scope\n \t{\n \t\tprintf(\"%d: CppB.~this\\n\", num);\n \t}\n }\n \n extern (C++) class CppC : CppB\n {\n-\tthis(int num)\n+\tthis(int num) scope\n \t{\n \t\tsuper(num);\n \t}\n \n-\t~this()\n+\t~this() scope\n \t{\n \t\tprintf(\"%d: CppC.~this\\n\", num);\n \t}\n@@ -78,38 +78,38 @@ extern (C++) class CppC : CppB\n extern (D) class DA\n {\n \tint num;\n-\tthis(int num)\n+\tthis(int num) scope\n \t{\n \t\tthis.num = num;\n \t}\n \n-\t~this()\n+\t~this() scope\n \t{\n \t\tprintf(\"%d: DA.~this\\n\", num);\n \t}\n }\n \n extern (D) class DB : DA\n {\n-\tthis(int num)\n+\tthis(int num) scope\n \t{\n \t\tsuper(num);\n \t}\n \n-\t~this()\n+\t~this() scope\n \t{\n \t\tprintf(\"%d: DB.~this\\n\", num);\n \t}\n }\n \n extern (D) class DC : DB\n {\n-\tthis(int num)\n+\tthis(int num) scope\n \t{\n \t\tsuper(num);\n \t}\n \n-\t~this()\n+\t~this() scope\n \t{\n \t\tprintf(\"%d: DC.~this\\n\", num);\n \t}\n@@ -118,7 +118,7 @@ extern (D) class DC : DB\n extern (C++) class CppNoDestruct\n {\n \tint num;\n-\tthis(int num)\n+\tthis(int num) scope\n \t{\n \t\tthis.num = num;\n \t}"}, {"sha": "ff66310ff2b4ae226436cd9eb040a8b4fe1e45a9", "filename": "gcc/testsuite/gdc.test/runnable/e7804.d", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fe7804.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fe7804.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fe7804.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -63,8 +63,6 @@ TmpPrm!(__traits(getMember, Foo, \"MyInt\")) tpt = TmpPrm!(__traits(getMember, Foo\n     int virtual(int p){return p;}\n     void test(this T)()\n     {\n-        alias vf = __traits(getVirtualFunctions, Class, \"virtual\");\n-        assert(vf.length == 2);\n         alias vm = __traits(getVirtualMethods, Class, \"virtual\");\n         assert(vm.length == 1);\n         assert(vm[0](42) == 42);"}, {"sha": "c8bfdc278bd44d24d2308d1d17b64d52b7253a50", "filename": "gcc/testsuite/gdc.test/runnable/extra-files/test11051.d", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fextra-files%2Ftest11051.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fextra-files%2Ftest11051.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fextra-files%2Ftest11051.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,30 @@\n+module test11051;\n+\n+version (Safe)\n+{\n+    void main() @safe\n+    {\n+        enum E { A, B }\n+        E e = cast(E)-1;\n+\n+        final switch (e)\n+        {\n+            case E.A: break;\n+            case E.B: break;\n+        }\n+    }\n+}\n+else\n+{\n+    void main()\n+    {\n+        enum E { A, B }\n+        E e = cast(E)-1;\n+\n+        final switch (e)\n+        {\n+            case E.A: break;\n+            case E.B: break;\n+        }\n+    }\n+}"}, {"sha": "e6e4fec1c54d5552980949b88b479636616af87e", "filename": "gcc/testsuite/gdc.test/runnable/funclit.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ffunclit.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ffunclit.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ffunclit.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -520,7 +520,6 @@ void test7705()\n {\n     void foo1(void delegate(ref int ) dg){ int x=10; dg(x); }\n     foo1((ref x){ pragma(msg, typeof(x)); assert(x == 10); });\n-    static assert(!__traits(compiles, foo1((x){}) ));\n \n     void foo2(void delegate(int, ...) dg){ dg(20, 3.14); }\n     foo2((x,...){ pragma(msg, typeof(x)); assert(x == 20); });"}, {"sha": "57e8792bd8a326d4550df27a6564f5a31a35a12d", "filename": "gcc/testsuite/gdc.test/runnable/imports/freer.i", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fimports%2Ffreer.i", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fimports%2Ffreer.i", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fimports%2Ffreer.i?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,5 @@\n+typedef struct Foo *FooRef;\n+struct Foo {\n+    int x;\n+};\n+void free_foo(FooRef foo) { }"}, {"sha": "d3a7d9438345f2a9aea5c8e243d57b7230775aaa", "filename": "gcc/testsuite/gdc.test/runnable/imports/maker.i", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fimports%2Fmaker.i", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fimports%2Fmaker.i", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fimports%2Fmaker.i?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,5 @@\n+typedef struct Foo *FooRef;\n+struct Foo {\n+    int x;\n+};\n+FooRef make_foo(void) { return 0; }"}, {"sha": "f9972f235e214e6070a7f83817b242f657890096", "filename": "gcc/testsuite/gdc.test/runnable/interpret.d", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Finterpret.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Finterpret.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Finterpret.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -4,6 +4,7 @@ TEST_OUTPUT:\n true\n g\n &Test109S(&Test109S(<recursion>))\n+runnable/interpret.d(3742): Deprecation: alias this for classes/interfaces is deprecated\n tfoo\n tfoo\n Crash!"}, {"sha": "155144b5bcb82ffbaf75734272c81b4a3412eb05", "filename": "gcc/testsuite/gdc.test/runnable/issue22854.d", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fissue22854.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fissue22854.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fissue22854.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -2,12 +2,12 @@\n void main()\n {\n     uint loops = 0;\n-    static foreach (i; 0 .. 50)\n+    static foreach (i; 0 .. 5)\n     {\n         static foreach (ch; SomeContainer().range)\n             loops++;\n     }\n-    assert(loops == 50 * 50);\n+    assert(loops == 5 * 5);\n }\n \n struct SomeContainer\n@@ -20,7 +20,7 @@ struct TypeWithDestructor { ~this() { } }\n \n struct SomeRange\n {\n-    int count = 50;\n+    int count = 5;\n     int front() { return count; }\n     bool empty() { return count <= 0; }\n     void popFront() { count--; }"}, {"sha": "b24eced9f7f4d014c2b5d1cb7d76e31bf7b847f2", "filename": "gcc/testsuite/gdc.test/runnable/mars1.d", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fmars1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fmars1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fmars1.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -617,6 +617,17 @@ void test11565()\n     assert(cond11565(true) == size_t.max);\n }\n \n+// https://issues.dlang.org/show_bug.cgi?id=23743\n+void test23743()\n+{\n+    ubyte[] a = [1];\n+    foreach (x; a)\n+    {\n+        ubyte v = x >= 1 ? 255 : 0;\n+        assert(v == 255);\n+    }\n+}\n+\n ///////////////////////\n \n int[3] array1 = [1:1,2,0:3];\n@@ -2498,6 +2509,7 @@ int main()\n     testdocond();\n     testnegcom();\n     test11565();\n+    test23743();\n     testoror();\n     testbt();\n     test12095(0);"}, {"sha": "70bf051a46f986123e28ecd63b7793699b40b8ae", "filename": "gcc/testsuite/gdc.test/runnable/mixin2.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fmixin2.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fmixin2.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fmixin2.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -82,13 +82,13 @@ int x5;\n \n class Foo5\n {\n-        this ()\n+        this () scope\n         {\n                 printf (\"Constructor\\n\");\n                 assert(x5 == 0);\n                 x5++;\n         }\n-        ~this ()\n+        ~this () scope\n         {\n                 printf (\"Destructor\\n\");\n                 assert(x5 == 2);"}, {"sha": "dbf4f4b98171f7aea35fb24d8b118f69b9324b8e", "filename": "gcc/testsuite/gdc.test/runnable/test15985.d", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest15985.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest15985.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest15985.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,18 @@\n+/* PERMUTE_ARGS: -allinst\n+ */\n+\n+// https://issues.dlang.org/show_bug.cgi?id=15985\n+\n+void ff()()\n+{\n+    gg!()();\n+    hh!()();\n+}\n+\n+void gg()() { ff!()(); }\n+void hh()() { ff!()(); }\n+\n+enum x = is(typeof(ff!()()));\n+alias my_g = gg!();\n+\n+int main() { return 0; }"}, {"sha": "a5af2d564485fa0b112c9fcf53dbb034c2612ace", "filename": "gcc/testsuite/gdc.test/runnable/test16098.d", "status": "modified", "additions": 61, "deletions": 2, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest16098.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest16098.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest16098.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1,14 +1,73 @@\n \n // https://issues.dlang.org/show_bug.cgi?id=16098\n \n-void main() {\n+/*********************************************/\n+\n+void testDynamicClosure()\n+{\n     byte a;\n     align(128) byte b;\n     assert((cast(size_t) &b) % 128 == 0);\n+    b = 37;\n \n     byte foo() { return b; }\n     dg = &foo;\n-    assert(dg() == false);\n+    assert(dg() == 37);\n }\n \n __gshared byte delegate() dg;\n+\n+/*********************************************/\n+\n+void testStaticClosure()\n+{\n+    byte aa;\n+    align(128) byte b;\n+    assert((cast(size_t) &b) % 128 == 0);\n+    b = 73;\n+\n+    byte foo() { return b; }\n+    assert(foo() == 73);\n+}\n+\n+/*********************************************/\n+\n+void test3()\n+{\n+    struct S\n+    {\n+\talign(32) int b;\n+    }\n+}\n+\n+/*********************************************/\n+\n+align(16)\n+struct Cent\n+{\n+    ulong lo;  // low 64 bits\n+    ulong hi;  // high 64 bits\n+}\n+\n+enum Cent One = { 1 };\n+\n+Cent inc(Cent c) {  return add(c, One); }\n+\n+Cent add(Cent c1, Cent c2) { const Cent ret = { 3, 2 }; return ret; }\n+\n+void test4()\n+{\n+    const Cent C10_0 = { 0, 10 };\n+    const Cent Cm10_0 = inc(C10_0);\n+}\n+\n+/*********************************************/\n+\n+int main()\n+{\n+    testDynamicClosure();\n+    testStaticClosure();\n+    test3();\n+    test4();\n+    return 0;\n+}"}, {"sha": "e10265558e8498afce19511b5f1c3376609678ed", "filename": "gcc/testsuite/gdc.test/runnable/test17684.d", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest17684.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest17684.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest17684.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1,3 +1,13 @@\n+/*\n+TEST_OUTPUT:\n+---\n+runnable/test17684.d(37): Deprecation: alias this for classes/interfaces is deprecated\n+runnable/test17684.d(54): Deprecation: alias this for classes/interfaces is deprecated\n+runnable/test17684.d(54): Deprecation: alias this for classes/interfaces is deprecated\n+runnable/test17684.d(37): Deprecation: alias this for classes/interfaces is deprecated\n+---\n+*/\n+\n struct StructField(T)\n {\n     static T Field;"}, {"sha": "a571b08cfd25fdc837cb779c7598a23e75cf9747", "filename": "gcc/testsuite/gdc.test/runnable/test18472.d", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest18472.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest18472.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest18472.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,53 @@\n+/* REQUIRED_ARGS: -betterC\n+*/\n+\n+/*******************************************/\n+// https://issues.dlang.org/show_bug.cgi?id=18472\n+// https://github.com/dlang/dmd/pull/14676\n+\n+@nogc nothrow pure:\n+immutable(Char)[] format(Char, Args...)(in Char[] fmt, Args args)\n+{\n+\n+    if (__ctfe)\n+    {\n+        auto data2 = new char[5];\n+        auto data = new Data2;\n+        {\n+            auto data3 = new Data2;\n+        }\n+        data2 = cast(char[]) \"test2\";\n+        return data2;\n+    }\n+    else\n+    {\n+        return \"test\";\n+    }\n+}\n+\n+extern(C) void main()\n+{\n+    static assert(getData() == \"test\");\n+    static assert(\"%s %s\".format(\"test\", \"test\") == \"test2\", \"Not working\");\n+    assert(\"%s %s\".format(\"test\", \"test\") == \"test\", \"%s %s\".format(\"test\", \"test\"));\n+    assert(getData() == \"test2\", getData());\n+}\n+\n+string getData()\n+{\n+    if (__ctfe)\n+    {\n+        auto data2 = new ubyte[5];\n+        auto data = new Data2;\n+        return \"test\";\n+    }\n+    else\n+    {\n+        return \"test2\";\n+    }\n+}\n+\n+private struct Data2\n+{\n+    size_t capacity;\n+}"}, {"sha": "61a168bf918aa22a9c486e8e4846d6c8e9ab9292", "filename": "gcc/testsuite/gdc.test/runnable/test19782.d", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest19782.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest19782.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest19782.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1,4 +1,12 @@\n // https://issues.dlang.org/show_bug.cgi?id=19782\n+\n+/*\n+TEST_OUTPUT:\n+---\n+runnable/test19782.d(17): Deprecation: alias this for classes/interfaces is deprecated\n+---\n+*/\n+\n class Inner\n {\n     int a;"}, {"sha": "9f9d3bc98245a2b5f1895e9610ea5746e3b695b4", "filename": "gcc/testsuite/gdc.test/runnable/test19946.d", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest19946.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest19946.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest19946.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,37 @@\n+// https://issues.dlang.org/show_bug.cgi?id=19946\n+\n+import core.stdc.stdio;\n+\n+template Tests(TY)\n+{\n+    void test1()\n+    {\n+\tTY[24] ba;\n+\tba[0..23] = 0x40;\n+\tcheck1(ba[]);\n+    }\n+\n+    void check1(TY[] ba)\n+    {\n+\tforeach (i; 0 .. 23)\n+\t{\n+\t    //printf(\"ba[%d] = 0x%02x\\n\", i, ba[i]);\n+\t    assert(ba[i] == 0x40);\n+\t}\n+\tassert(ba[23] == 0);\n+    }\n+}\n+\n+int main()\n+{\n+    Tests!byte.test1();\n+    Tests!short.test1();\n+    Tests!int.test1();\n+    Tests!long.test1();\n+\n+    Tests!ubyte.test1();\n+    Tests!ushort.test1();\n+    Tests!uint.test1();\n+    Tests!ulong.test1();\n+    return 0;\n+}"}, {"sha": "dd4526667e723765c0545fcb6b88e5662c620042", "filename": "gcc/testsuite/gdc.test/runnable/test20520.d", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest20520.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest20520.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest20520.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,13 @@\n+// https://issues.dlang.org/show_bug.cgi?id=20520\n+\n+class C {}\n+\n+enum Foo {\n+    Bar = new C()\n+}\n+\n+void main()\n+{\n+    //pragma(msg, typeid(Foo.Bar)); // Works fine: typeid(C())\n+    auto t = typeid(Foo.Bar);     // Segfault here\n+}"}, {"sha": "1d2ae50919a6a2d683adaac73c57dcce83daaa1b", "filename": "gcc/testsuite/gdc.test/runnable/test20855.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest20855.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest20855.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest20855.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -4,7 +4,7 @@\n string exp()\n {\n     string s = \"a = b + c * d + a;\";\n-    foreach (i; 0 .. 9)\n+    foreach (i; 0 .. 8)\n \ts = s ~ s;\n     return s;\n }\n@@ -22,6 +22,6 @@ int main()\n {\n     int a = test();\n     printf(\"a = %d\\n\", a);\n-    assert(test() == 7169);\n+    assert(test() == 3585);\n     return 0;\n }"}, {"sha": "f32267ab59e006d26a4dff54157a9cb4b23129fc", "filename": "gcc/testsuite/gdc.test/runnable/test21039.d", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest21039.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest21039.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest21039.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1,5 +1,12 @@\n // https://issues.dlang.org/show_bug.cgi?id=21039\n \n+/*\n+TEST_OUTPUT:\n+---\n+runnable/test21039.d(14): Deprecation: alias this for classes/interfaces is deprecated\n+---\n+*/\n+\n class Inner {}\n \n class Outer {"}, {"sha": "dcb7b8088dbe6f4d91d1d7e60d645b1be4af916c", "filename": "gcc/testsuite/gdc.test/runnable/test21772.d", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest21772.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest21772.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest21772.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,14 @@\n+// https://issues.dlang.org/show_bug.cgi?id=21772\n+\n+import core.stdc.string;\n+\n+int main()\n+{\n+    //import std.stdio : writeln;\n+\n+    double[] a = [-double.nan, double.nan,  double.nan,\n+                          1.0, double.nan, -double.nan];\n+    //writeln(a); // Writes \"[-nan, -nan, -nan, 1, nan, nan]\" (Uh-oh!)\n+    assert(memcmp(&a[0], &a[1], double.sizeof) != 0);\n+    return 0;\n+}"}, {"sha": "d16331d1897a1492d655e61fa68c8dc1fbb2f95d", "filename": "gcc/testsuite/gdc.test/runnable/test21821.d", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest21821.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest21821.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest21821.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,32 @@\n+// REQUIRED_ARGS: -preview=fieldwise -O\n+// https://issues.dlang.org/show_bug.cgi?id=21821\n+\n+// test case comes from unittests in core.lifetime\n+\n+void test()\n+{\n+    alias T = immutable(S);\n+    T source;\n+    T target;\n+    copyEmplacex(source, target);\n+    T expectedCopy = source;\n+    assert(target == expectedCopy);\n+}\n+\n+struct S\n+{\n+    int x = 42;\n+    this(this) { x += 10; }\n+}\n+\n+void copyEmplacex(ref immutable(S) source, ref immutable(S) target) @system\n+{\n+        import core.stdc.string : memcpy;\n+        memcpy(cast(S*) &target, cast(S*) &source, S.sizeof);\n+\t(cast() target).__xpostblit(); // casting away immutable\n+}\n+\n+void main()\n+{\n+    test();\n+}"}, {"sha": "cb951c17faaf0e09c5d0768ea179532922cd790e", "filename": "gcc/testsuite/gdc.test/runnable/test23.d", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest23.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest23.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest23.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1322,22 +1322,22 @@ void test70()\n class C71\n {\n     static int cnt;\n-    this() { printf(\"C()\\n\"); cnt++; }\n-    ~this() { printf(\"~C()\\n\"); cnt--; }\n+    this() scope { printf(\"C()\\n\"); cnt++; }\n+    ~this() scope { printf(\"~C()\\n\"); cnt--; }\n }\n \n class D71\n {\n     static int cnt;\n-    this() { printf(\"D()\\n\"); cnt++; }\n-    ~this() { printf(\"~D()\\n\"); cnt--; }\n+    this() scope { printf(\"D()\\n\"); cnt++; }\n+    ~this() scope { printf(\"~D()\\n\"); cnt--; }\n }\n \n class E71\n {\n     static int cnt;\n-    this() { printf(\"E()\\n\"); cnt++; }\n-    ~this() { printf(\"~E()\\n\"); cnt--; }\n+    this() scope { printf(\"E()\\n\"); cnt++; }\n+    ~this() scope { printf(\"~E()\\n\"); cnt--; }\n }\n \n void test71()"}, {"sha": "f97486404b3bef05b6deb345034bbd1d5baea2bf", "filename": "gcc/testsuite/gdc.test/runnable/test23234.d", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest23234.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest23234.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest23234.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1,5 +1,12 @@\n // https://issues.dlang.org/show_bug.cgi?id=23234\n \n+/*\n+TEST_OUTPUT:\n+---\n+runnable/test23234.d(17): Deprecation: alias this for classes/interfaces is deprecated\n+---\n+*/\n+\n class Bar\n {\n }"}, {"sha": "4419cf1200e19a57accb7472b65895e55f99b60a", "filename": "gcc/testsuite/gdc.test/runnable/test23387.d", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest23387.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest23387.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest23387.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,30 @@\n+/* COMPILE_SEPARATELY:\n+ * EXTRA_SOURCES: imports/maker.i imports/freer.i\n+ */\n+\n+// https://issues.dlang.org/show_bug.cgi?id=23387\n+\n+/+ maker.i\n+typedef struct Foo *FooRef;\n+struct Foo {\n+    int x;\n+};\n+FooRef make_foo(void);\n++/\n+import imports.maker;\n+\n+\n+/+ freer.i\n+typedef struct Foo *FooRef;\n+struct Foo {\n+    int x;\n+};\n+void free_foo(FooRef foo);\n++/\n+import imports.freer;\n+\n+int main(){\n+    FooRef f = make_foo();\n+    free_foo(f);\n+    return 0;\n+}"}, {"sha": "1ba7e218d528d4385d7642969c1845a376ee5352", "filename": "gcc/testsuite/gdc.test/runnable/test23514.d", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest23514.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest23514.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest23514.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,13 @@\n+// DISABLED: win64\n+// https://issues.dlang.org/show_bug.cgi?id=23514\n+\n+// Note: this test is disabled on Win64 because of an issue with the Windows\n+// MS-COFF backend causing it to fail.\n+\n+enum ulong offset = 0xFFFF_FFFF_0000_0000UL;\n+\n+void main()\n+{\n+    ulong voffset = offset;\n+    assert((cast(ulong)&main + voffset) == (cast(ulong)&main + offset));\n+}"}, {"sha": "7cde3ff9bdfa27632a2fa7d22616b8bad2c3429d", "filename": "gcc/testsuite/gdc.test/runnable/test23618.d", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest23618.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest23618.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest23618.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,30 @@\n+\n+// https://issues.dlang.org/show_bug.cgi?id=23618\n+\n+import core.stdc.stdio;\n+\n+uint test1()\n+{\n+    ushort ee = 1028;\n+    ee <<= 5U;\n+    ee >>= 5U;\n+    assert(ee == 1028);\n+    //printf(\"%x, %d\\n\", ee, ee);\n+    return ee;\n+}\n+\n+uint test2()\n+{\n+    ubyte ee = 4;\n+    ee <<= 5U;\n+    ee >>= 5U;\n+    //printf(\"%x, %d\\n\", ee, ee);\n+    assert(ee == 4);\n+    return ee;\n+}\n+\n+void main()\n+{\n+    test1();\n+    test2();\n+}"}, {"sha": "3ce8f5f0759ba6b415aaca8a4472abaf17718a8e", "filename": "gcc/testsuite/gdc.test/runnable/test23650.d", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest23650.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest23650.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest23650.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,13 @@\n+// https://issues.dlang.org/show_bug.cgi?id=23650\n+\n+__gshared int x;\n+\n+void main()\n+{\n+\n+    static assert(__traits(compiles,\n+    {\n+        struct S { int *p = &x; }\n+        auto t = typeid(S);\n+    }));\n+}"}, {"sha": "05ab1e43256aba7bb585856f0111b86ee716d94b", "filename": "gcc/testsuite/gdc.test/runnable/test23710.d", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest23710.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest23710.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest23710.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,30 @@\n+// https://issues.dlang.org/show_bug.cgi?id=23710\n+\n+int test(int i)\n+{\n+    int j;\n+    int[] foo;\n+    if (0)\n+    {\n+        for (;;)\n+        {\n+            import core.stdc.stdio;\n+            printf(\"start body\\n\");\n+            foo = foo ~ [1,2,3];\n+L1:\n+            printf(\"foo.length = %zu\\n\", foo.length);\n+\t    j += foo.length;\n+            i += 2;\n+            if (i > 5)\n+                return j;\n+            printf(\"end body\\n\");\n+        }\n+    }\n+    goto L1;\n+}\n+\n+int main()\n+{\n+    assert(test(1) == 0 + 3 + 6);\n+    return 0;\n+}"}, {"sha": "df461370066404881674a20ac717ba5691061cc2", "filename": "gcc/testsuite/gdc.test/runnable/test34.d", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest34.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest34.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest34.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1,5 +1,3 @@\n-// REQUIRED_ARGS: -d\n-\n module test34;\n \n import core.exception;"}, {"sha": "f10076223d59b6e2b39ddbaeb03fb48116d087b5", "filename": "gcc/testsuite/gdc.test/runnable/test8.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest8.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest8.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest8.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -786,8 +786,8 @@ void test42()\n int x44;\n \n class A44 {\n-     this() { printf(\"A44 ctor\\n\"); x44 += 1; }\n-     ~this() { printf(\"A44 dtor\\n\"); x44 += 0x100; }\n+     this() scope { printf(\"A44 ctor\\n\"); x44 += 1; }\n+     ~this() scope { printf(\"A44 dtor\\n\"); x44 += 0x100; }\n }\n class B44 : A44 { }\n "}, {"sha": "ed5091dff018a040ef7bebd14440a8db2c8331c0", "filename": "gcc/testsuite/gdc.test/runnable/testaliascast.d", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftestaliascast.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftestaliascast.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftestaliascast.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1,5 +1,13 @@\n // https://issues.dlang.org/show_bug.cgi?id=11294\n \n+/*\n+TEST_OUTPUT:\n+---\n+runnable/testaliascast.d(29): Deprecation: alias this for classes/interfaces is deprecated\n+runnable/testaliascast.d(58): Deprecation: alias this for classes/interfaces is deprecated\n+---\n+*/\n+\n string result;\n \n extern(C) void rt_finalize(void *ptr, bool det=true);"}, {"sha": "79a4c57cf3b3c5b90b56e7c342ac7ac2b12980f3", "filename": "gcc/testsuite/gdc.test/runnable/testassign.d", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftestassign.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftestassign.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftestassign.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -2,6 +2,8 @@\n REQUIRED_ARGS: -preview=rvaluerefparam\n TEST_OUTPUT:\n ---\n+runnable/testassign.d(802): Deprecation: alias this for classes/interfaces is deprecated\n+runnable/testassign.d(808): Deprecation: alias this for classes/interfaces is deprecated\n \\\tS1\tS2a\tS2b\tS3a\tS3b\tS4a\tS4b\n -\ttrue\ttrue\ttrue\ttrue\ttrue\ttrue\ttrue\n Xa\ttrue\ttrue\ttrue\ttrue\ttrue\ttrue\ttrue"}, {"sha": "269949fb0c0276f03b925d22397724d86dc70bd7", "filename": "gcc/testsuite/gdc.test/runnable/testdstress.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftestdstress.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftestdstress.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftestdstress.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -494,7 +494,7 @@ void test23()\n int status24;\n \n class C24{\n-        this(){\n+        this() scope {\n                 assert(status24==0);\n                 status24+=2;\n         }"}, {"sha": "5186987deaea57354da92d5bae515532deeef318", "filename": "gcc/testsuite/gdc.test/runnable/traits.d", "status": "modified", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftraits.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftraits.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftraits.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -312,14 +312,6 @@ void test9()\n \n /********************************************************/\n \n-void test10()\n-{\n-    assert(__traits(isVirtualFunction, C.bar) == true);\n-    assert(__traits(isVirtualFunction, S.bar) == false);\n-}\n-\n-/********************************************************/\n-\n void test11()\n {\n     assert(__traits(isAbstractFunction, C.bar) == false);\n@@ -403,24 +395,6 @@ class D15\n     int foo(int) { return 2; }\n }\n \n-void test15()\n-{\n-    D15 d = new D15();\n-\n-    assert(__traits(getVirtualFunctions, D15, \"foo\").length == 2);\n-    assert(typeid(typeof(__traits(getVirtualFunctions, D15, \"foo\")[0])).toString()\n-           == \"void function()\");\n-    assert(typeid(typeof(__traits(getVirtualFunctions, D15, \"foo\")[1])).toString()\n-           == \"int function(int)\");\n-\n-    alias typeof(__traits(getVirtualFunctions, D15, \"foo\")) b;\n-    assert(typeid(b[0]).toString() == \"void function()\");\n-    assert(typeid(b[1]).toString() == \"int function(int)\");\n-\n-    auto i = __traits(getVirtualFunctions, d, \"foo\")[1](1);\n-    assert(i == 2);\n-}\n-\n /********************************************************/\n \n struct S16 { }\n@@ -714,14 +688,6 @@ interface AA\n      int YYY();\n }\n \n-class CC : AA\n-{\n-    final int YYY() { return 4; }\n-}\n-\n-static assert(__traits(isVirtualMethod, CC.YYY));\n-static assert(__traits(getVirtualMethods, CC, \"YYY\").length == 1);\n-\n class DD\n {\n     final int YYY() { return 4; }\n@@ -790,8 +756,6 @@ void test7858()\n \n     static assert(__traits(isFinalFunction, C.ffunc) ==\n                   __traits(isFinalFunction, __traits(getOverloads, C, \"ffunc\")[0]));    // NG\n-    static assert(__traits(isVirtualFunction, C.vfunc) ==\n-                  __traits(isVirtualFunction, __traits(getOverloads, C, \"vfunc\")[0]));  // NG\n     static assert(__traits(isVirtualMethod, C.vfunc) ==\n                   __traits(isVirtualMethod, __traits(getOverloads, C, \"vfunc\")[0]));    // NG\n     static assert(__traits(isAbstractFunction, C.afunc) ==\n@@ -1456,13 +1420,11 @@ int main()\n     test7();\n     test8();\n     test9();\n-    test10();\n     test11();\n     test12();\n     test13();\n     test7123();\n     test14();\n-    test15();\n     test16();\n     test17();\n     test18();"}, {"sha": "ffa0b803ade635f04d40e00ec910dca3717f0332", "filename": "gcc/testsuite/gdc.test/runnable/traits_getPointerBitmap.d", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftraits_getPointerBitmap.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftraits_getPointerBitmap.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftraits_getPointerBitmap.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1,4 +1,3 @@\n-\n module traits_getPointerBitmap;\n \n import core.stdc.stdio;\n@@ -76,19 +75,6 @@ template pOff(T)\n     enum pOff = T.p.offsetof / bytesPerPtr;\n }\n \n-class C(T, aliasTo = void)\n-{\n-    static if(!is(aliasTo == void))\n-    {\n-        aliasTo a;\n-        alias a this;\n-    }\n-\n-    size_t x;\n-    T t = void;\n-    void* p;\n-}\n-\n ///////////////////////////////////////\n \n void _testType(T)(size_t[] expected)\n@@ -118,21 +104,6 @@ void testType(T)(size_t[] expected)\n     // prepend string\n     sexp[0] = (expected[0] << tOff!(S!(T, string))) | (1 << pOff!(S!(T, string))) | 2; // arr ptr\n     _testType!(S!(T, string))(sexp);\n-\n-    // generate bit pattern for C!T\n-    C!T ct = null;\n-    size_t mutexBit = (RTInfoMark__Monitor ? 2 : 0);\n-    size_t ctpOff = ct.p.offsetof / bytesPerPtr;\n-    size_t cttOff = ct.t.offsetof / bytesPerPtr;\n-    sexp[0] = (expected[0] << cttOff) | (1 << ctpOff) | mutexBit;\n-    _testType!(C!(T))(sexp);\n-\n-    C!(T, string) cts = null;\n-    size_t ctspOff = cts.p.offsetof / bytesPerPtr;\n-    size_t ctstOff = cts.t.offsetof / bytesPerPtr;\n-    // generate bit pattern for C!T\n-    sexp[0] = (expected[0] << ctstOff) | (1 << ctspOff) | mutexBit | 0b1000; // arr ptr\n-    _testType!(C!(T, string))(sexp);\n }\n \n ///////////////////////////////////////"}, {"sha": "e57f52f6578364f9a3b19fdea5b8e5a17289d3b7", "filename": "gcc/testsuite/gdc.test/runnable/xtest46.d", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fxtest46.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fxtest46.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fxtest46.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1,12 +1,15 @@\n-// REQUIRED_ARGS: -d -preview=rvaluerefparam\n+// REQUIRED_ARGS: -preview=rvaluerefparam\n //\n /* TEST_OUTPUT:\n ---\n+runnable/xtest46.d(165): Deprecation: alias this for classes/interfaces is deprecated\n Boo!double\n Boo!int\n true\n int\n !! immutable(int)[]\n+runnable/xtest46.d(2932): Deprecation: alias this for classes/interfaces is deprecated\n+runnable/xtest46.d(2964): Deprecation: alias this for classes/interfaces is deprecated\n int(int i, long j = 7L)\n long\n C10390(C10390(C10390(<recursion>)))\n@@ -19,6 +22,7 @@ string[]\n double[]\n double[]\n {}\n+runnable/xtest46.d(4670): Deprecation: alias this for classes/interfaces is deprecated\n tuple(\"m\")\n true\n TFunction1: extern (C) void function()"}, {"sha": "224625c65ecb5b5bcbe64513799530ea2b0ea2d0", "filename": "gcc/testsuite/gdc.test/runnable/xtest46_gc.d", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fxtest46_gc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fxtest46_gc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fxtest46_gc.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1,13 +1,16 @@\n /*\n-REQUIRED_ARGS: -d -lowmem -Jrunnable -preview=rvaluerefparam\n+REQUIRED_ARGS: -lowmem -Jrunnable -preview=rvaluerefparam\n EXTRA_FILES: xtest46.d\n TEST_OUTPUT:\n ---\n+runnable/xtest46_gc.d-mixin-33(197): Deprecation: alias this for classes/interfaces is deprecated\n Boo!double\n Boo!int\n true\n int\n !! immutable(int)[]\n+runnable/xtest46_gc.d-mixin-33(2964): Deprecation: alias this for classes/interfaces is deprecated\n+runnable/xtest46_gc.d-mixin-33(2996): Deprecation: alias this for classes/interfaces is deprecated\n int(int i, long j = 7L)\n long\n C10390(C10390(<recursion>))\n@@ -20,6 +23,7 @@ string[]\n double[]\n double[]\n {}\n+runnable/xtest46_gc.d-mixin-33(4702): Deprecation: alias this for classes/interfaces is deprecated\n tuple(\"m\")\n true\n TFunction1: extern (C) void function()"}, {"sha": "c0f4e6dd78060bea2469c8ed920de53ceb4ed36a", "filename": "gcc/testsuite/gdc.test/runnable_cxx/cpp_abi_tests.d", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Fcpp_abi_tests.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Fcpp_abi_tests.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Fcpp_abi_tests.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -207,6 +207,8 @@ extern(C++, `ns1`)\n \n extern(C++)\n {\n+    // https://issues.dlang.org/show_bug.cgi?id=19563\n+\n     struct SmallStruct\n     {\n         int i;\n@@ -220,6 +222,50 @@ extern(C++)\n     }\n }\n \n+/*********************************************/\n+// https://issues.dlang.org/show_bug.cgi?id=23195\n+\n+extern (C++)\n+{\n+    struct FF\n+    {\n+        float x, y;\n+\n+        ~this() { }\n+    }\n+\n+    float draw(FF min, FF max);\n+\n+    void test23195()\n+    {\n+        FF a = { 1, 2 };\n+        FF b = { 3, 4 };\n+        float f = draw(a, b);\n+        assert(f == 1234);\n+    }\n+\n+    /*********************/\n+\n+    struct FF2\n+    {\n+        float x, y;\n+\n+        this(int i) { }\n+    }\n+\n+    float draw2(FF2 min, FF2 max);\n+\n+    void test23195_2()\n+    {\n+        FF2 a; a.x = 1; a.y = 2;\n+        FF2 b; b.x = 3; b.y = 4;\n+        float f = draw2(a, b);\n+        assert(f == 1234);\n+    }\n+}\n+\n+/*********************************************/\n+\n void main()\n {\n     foreach(bool val; values!bool())     check(val);\n@@ -268,4 +314,6 @@ else\n         doConsume2(sd);\n         assert(Sdtor.counter == 2);\n     }\n+    test23195();\n+    test23195_2();\n }"}, {"sha": "cb268af062230fd16e6464c77cb316183a67621e", "filename": "gcc/testsuite/gdc.test/runnable_cxx/cppa.d", "status": "modified", "additions": 83, "deletions": 121, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Fcppa.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Fcppa.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Fcppa.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -5,8 +5,6 @@\n // CXXFLAGS(linux freebsd osx netbsd dragonflybsd): -std=c++11\n // druntime isn't linked, this prevents missing symbols '_d_arraybounds_slicep':\n // REQUIRED_ARGS: -checkaction=C\n-// Filter a spurious warning on Semaphore:\n-// TRANSFORM_OUTPUT: remove_lines(\"warning: relocation refers to discarded section\")\n \n // N.B MSVC doesn't have a C++11 switch, but it defaults to the latest fully-supported standard\n \n@@ -444,57 +442,10 @@ void test13161()\n \n /****************************************/\n \n-version (linux)\n-{\n-    static if (__traits(getTargetInfo, \"cppStd\") < 201703)\n-    {\n-        // See note on std::allocator below.\n-        extern(C++, __gnu_cxx)\n-        {\n-            struct new_allocator(T)\n-            {\n-                alias size_type = size_t;\n-                static if (is(T : char))\n-                    void deallocate(T*, size_type) { }\n-                else\n-                    void deallocate(T*, size_type);\n-            }\n-        }\n-    }\n-}\n-\n extern (C++, std)\n {\n-    version (linux)\n-    {\n-        static if (__traits(getTargetInfo, \"cppStd\") >= 201703)\n-        {\n-            // std::allocator no longer derives from __gnu_cxx::new_allocator,\n-            // it derives from std::__new_allocator instead.\n-            struct __new_allocator(T)\n-            {\n-                alias size_type = size_t;\n-                static if (is(T : char))\n-                    void deallocate(T*, size_type) { }\n-                else\n-                    void deallocate(T*, size_type);\n-            }\n-        }\n-    }\n-\n     extern (C++, class) struct allocator(T)\n     {\n-        version (linux)\n-        {\n-            alias size_type = size_t;\n-            void deallocate(T* p, size_type sz)\n-            {\n-                static if (__traits(getTargetInfo, \"cppStd\") >= 201703)\n-                    (cast(std.__new_allocator!T*)&this).deallocate(p, sz);\n-                else\n-                    (cast(__gnu_cxx.new_allocator!T*)&this).deallocate(p, sz);\n-            }\n-        }\n     }\n \n     class vector(T, A = allocator!T)\n@@ -586,11 +537,6 @@ void test14()\n \n version (linux)\n {\n-    void test14a(std.allocator!int * pa)\n-    {\n-    pa.deallocate(null, 0);\n-    }\n-\n     void gun(std.vector!int pa)\n     {\n     int x = 42;\n@@ -1115,83 +1061,99 @@ void test15576()\n /****************************************/\n // https://issues.dlang.org/show_bug.cgi?id=15579\n \n-extern (C++)\n+version (DigitalMars)\n {\n-    class Base\n-    {\n-        //~this() {}\n-        void based() { }\n-        ubyte x = 4;\n-    }\n-\n-    interface Interface\n+    version (linux)\n     {\n-        int MethodCPP();\n-        int MethodD();\n+        // Test removed for DMD/linux-only.\n+        // https://issues.dlang.org/show_bug.cgi?id=23660\n     }\n+    else\n+        version = TEST15579;\n+}\n+else\n+    version = TEST15579;\n \n-    class Derived : Base, Interface\n+version (TEST15579)\n+{\n+    extern (C++)\n     {\n-        short y = 5;\n-        int MethodCPP();\n-        int MethodD() {\n-            printf(\"Derived.MethodD(): this = %p, x = %d, y = %d\\n\", this, x, y);\n-            Derived p = this;\n-            //p = cast(Derived)(cast(void*)p - 16);\n-            assert(p.x == 4 || p.x == 7);\n-            assert(p.y == 5 || p.y == 8);\n-            return 3;\n+        class Base\n+        {\n+            //~this() {}\n+            void based() { }\n+            ubyte x = 4;\n         }\n-        int Method() { return 6; }\n-    }\n-\n-    Derived cppfoo(Derived);\n-    Interface cppfooi(Interface);\n-}\n \n-void test15579()\n-{\n-    Derived d = new Derived();\n-    printf(\"d = %p\\n\", d);\n-    assert(d.x == 4);\n-    assert(d.y == 5);\n-    assert((cast(Interface)d).MethodCPP() == 30);\n-    assert((cast(Interface)d).MethodD() == 3);\n-    assert(d.MethodCPP() == 30);\n-    assert(d.MethodD() == 3);\n-    assert(d.Method() == 6);\n+        interface Interface\n+        {\n+            int MethodCPP();\n+            int MethodD();\n+        }\n \n-    d = cppfoo(d);\n-    assert(d.x == 7);\n-    assert(d.y == 8);\n+        class Derived : Base, Interface\n+        {\n+            short y = 5;\n+            int MethodCPP();\n+            int MethodD() {\n+                printf(\"Derived.MethodD(): this = %p, x = %d, y = %d\\n\", this, x, y);\n+                Derived p = this;\n+                //p = cast(Derived)(cast(void*)p - 16);\n+                assert(p.x == 4 || p.x == 7);\n+                assert(p.y == 5 || p.y == 8);\n+                return 3;\n+            }\n+            int Method() { return 6; }\n+        }\n \n-    printf(\"d2 = %p\\n\", d);\n+        Derived cppfoo(Derived);\n+        Interface cppfooi(Interface);\n+    }\n \n-    /* Casting to an interface involves thunks in the vtbl[].\n-     * g++ puts the thunks for MethodD in the same COMDAT as MethodD.\n-     * But D doesn't, so when the linker \"picks one\" of the D generated MethodD\n-     * or the g++ generated MethodD, it may wind up with a messed up thunk,\n-     * resulting in a seg fault. The solution is to not expect objects of the same\n-     * type to be constructed on both sides of the D/C++ divide if the same member\n-     * function (in this case, MethodD) is also defined on both sides.\n-     */\n-    version (Windows)\n+    void test15579()\n     {\n+        Derived d = new Derived();\n+        printf(\"d = %p\\n\", d);\n+        assert(d.x == 4);\n+        assert(d.y == 5);\n+        assert((cast(Interface)d).MethodCPP() == 30);\n         assert((cast(Interface)d).MethodD() == 3);\n-    }\n-    assert((cast(Interface)d).MethodCPP() == 30);\n+        assert(d.MethodCPP() == 30);\n+        assert(d.MethodD() == 3);\n+        assert(d.Method() == 6);\n+\n+        d = cppfoo(d);\n+        assert(d.x == 7);\n+        assert(d.y == 8);\n+\n+        printf(\"d2 = %p\\n\", d);\n+\n+        /* Casting to an interface involves thunks in the vtbl[].\n+         * g++ puts the thunks for MethodD in the same COMDAT as MethodD.\n+         * But D doesn't, so when the linker \"picks one\" of the D generated MethodD\n+         * or the g++ generated MethodD, it may wind up with a messed up thunk,\n+         * resulting in a seg fault. The solution is to not expect objects of the same\n+         * type to be constructed on both sides of the D/C++ divide if the same member\n+         * function (in this case, MethodD) is also defined on both sides.\n+         */\n+        version (Windows)\n+        {\n+            assert((cast(Interface)d).MethodD() == 3);\n+        }\n+        assert((cast(Interface)d).MethodCPP() == 30);\n \n-    assert(d.Method() == 6);\n+        assert(d.Method() == 6);\n \n-    printf(\"d = %p, i = %p\\n\", d, cast(Interface)d);\n-    version (Windows)\n-    {\n-        Interface i = cppfooi(d);\n-        printf(\"i2: %p\\n\", i);\n-        assert(i.MethodD() == 3);\n-        assert(i.MethodCPP() == 30);\n+        printf(\"d = %p, i = %p\\n\", d, cast(Interface)d);\n+        version (Windows)\n+        {\n+            Interface i = cppfooi(d);\n+            printf(\"i2: %p\\n\", i);\n+            assert(i.MethodD() == 3);\n+            assert(i.MethodCPP() == 30);\n+        }\n+        printf(\"test15579() done\\n\");\n     }\n-    printf(\"test15579() done\\n\");\n }\n \n /****************************************/\n@@ -1362,7 +1324,7 @@ extern(C++)\n     class Cpp15589Derived : Cpp15589Base\n     {\n     public:\n-        this();\n+        this() scope;\n         final ~this();\n         int b;\n     }\n@@ -1372,7 +1334,7 @@ extern(C++)\n     public:\n         void beforeDtor();\n \n-        this();\n+        this() scope;\n         ~this();\n \n         void afterDtor();\n@@ -1382,7 +1344,7 @@ extern(C++)\n     class Cpp15589DerivedVirtual : Cpp15589BaseVirtual\n     {\n     public:\n-        this();\n+        this() scope;\n         ~this();\n \n         override void afterDtor();\n@@ -1393,7 +1355,7 @@ extern(C++)\n     class Cpp15589IntroducingVirtual : Cpp15589Base\n     {\n     public:\n-        this();\n+        this() scope;\n         void beforeIntroducedVirtual();\n         ~this();\n         void afterIntroducedVirtual(int);\n@@ -1699,7 +1661,7 @@ void main()\n     testeh2();\n     testeh3();\n     test15576();\n-    test15579();\n+    version (TEST15579) test15579();\n     test15610();\n     test15455();\n     test15372();"}, {"sha": "e1dcc28b8b1d7c7d9ed99d33de68e1a5595ce3fe", "filename": "gcc/testsuite/gdc.test/runnable_cxx/extra-files/cpp_abi_tests.cpp", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Fextra-files%2Fcpp_abi_tests.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Fextra-files%2Fcpp_abi_tests.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Fextra-files%2Fcpp_abi_tests.cpp?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -161,3 +161,29 @@ void doConsume2(Sdtor& value)\n // fn0            passthrough_fn0   (fn0 value) { return value; }\n // typedef int (*fn1)(int);\n // fn1            passthrough_fn1   (fn1 value) { return value; }\n+\n+/******************************/\n+\n+struct FF\n+{\n+    float x, y;\n+    ~FF();\n+};\n+\n+float draw(FF min, FF max)\n+{\n+    return min.x * 1000 + min.y * 100 + max.x * 10 + max.y;\n+}\n+\n+/******************************/\n+\n+struct FF2\n+{\n+    float x, y;\n+    FF2(int i) { }\n+};\n+\n+float draw2(FF2 min, FF2 max)\n+{\n+    return min.x * 1000 + min.y * 100 + max.x * 10 + max.y;\n+}"}, {"sha": "f6890e0cbd41993d5c641a34f23adfedb80b3a1d", "filename": "gcc/testsuite/gdc.test/runnable_cxx/test22898.d", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Ftest22898.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Ftest22898.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Ftest22898.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -4,14 +4,26 @@ import core.stdc.config;\n \n extern(C++):\n \n-version (AArch64) version = UnsignedChar;\n-version (ARM)     version = UnsignedChar;\n-version (RISCV32) version = UnsignedChar;\n-version (RISCV64) version = UnsignedChar;\n-version (PPC)     version = UnsignedChar;\n-version (PPC64)   version = UnsignedChar;\n-version (S390)    version = UnsignedChar;\n-version (SystemZ) version = UnsignedChar;\n+version (OSX)\n+    version = Darwin;\n+else version (iOS)\n+    version = Darwin;\n+else version (TVOS)\n+    version = Darwin;\n+else version (WatchOS)\n+    version = Darwin;\n+\n+version (Darwin) { /* signed on ARM too */ } else\n+{\n+    version (AArch64) version = UnsignedChar;\n+    version (ARM)     version = UnsignedChar;\n+    version (RISCV32) version = UnsignedChar;\n+    version (RISCV64) version = UnsignedChar;\n+    version (PPC)     version = UnsignedChar;\n+    version (PPC64)   version = UnsignedChar;\n+    version (S390)    version = UnsignedChar;\n+    version (SystemZ) version = UnsignedChar;\n+}\n \n version (UnsignedChar)\n     enum __c_char : ubyte;"}, {"sha": "269eebfc483ffc2d35cff980269cfcf3bcefe443", "filename": "libphobos/libdruntime/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMERGE?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1,4 +1,4 @@\n-09faa4eacd4fb147107e94eeebf56b3a73fdcc05\n+4ca4140e584c055a8a9bc727e56a97ebcecd61e0\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/dmd repository."}, {"sha": "8225ba4a0288ee8fb3391fd9573eceae37d8355d", "filename": "libphobos/libdruntime/Makefile.am", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMakefile.am?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -169,7 +169,7 @@ DRUNTIME_CSOURCES = core/stdc/errno_.c\n \n DRUNTIME_DSOURCES = core/atomic.d core/attribute.d core/bitop.d \\\n \tcore/builtins.d core/checkedint.d core/cpuid.d core/demangle.d \\\n-\tcore/exception.d core/gc/config.d core/gc/gcinterface.d \\\n+\tcore/exception.d core/factory.d core/gc/config.d core/gc/gcinterface.d \\\n \tcore/gc/registry.d core/int128.d core/internal/abort.d \\\n \tcore/internal/array/appending.d core/internal/array/arrayassign.d \\\n \tcore/internal/array/capacity.d core/internal/array/casting.d \\"}, {"sha": "797d6435a7ce28d0519a021840e86a904edbdfea", "filename": "libphobos/libdruntime/Makefile.in", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMakefile.in?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -189,9 +189,10 @@ am__DEPENDENCIES_1 =\n am__dirstamp = $(am__leading_dot)dirstamp\n am__objects_1 = core/atomic.lo core/attribute.lo core/bitop.lo \\\n \tcore/builtins.lo core/checkedint.lo core/cpuid.lo \\\n-\tcore/demangle.lo core/exception.lo core/gc/config.lo \\\n-\tcore/gc/gcinterface.lo core/gc/registry.lo core/int128.lo \\\n-\tcore/internal/abort.lo core/internal/array/appending.lo \\\n+\tcore/demangle.lo core/exception.lo core/factory.lo \\\n+\tcore/gc/config.lo core/gc/gcinterface.lo core/gc/registry.lo \\\n+\tcore/int128.lo core/internal/abort.lo \\\n+\tcore/internal/array/appending.lo \\\n \tcore/internal/array/arrayassign.lo \\\n \tcore/internal/array/capacity.lo core/internal/array/casting.lo \\\n \tcore/internal/array/comparison.lo \\\n@@ -838,7 +839,7 @@ libgdruntime_convenience_la_LINK = $(libgdruntime_la_LINK)\n DRUNTIME_CSOURCES = core/stdc/errno_.c\n DRUNTIME_DSOURCES = core/atomic.d core/attribute.d core/bitop.d \\\n \tcore/builtins.d core/checkedint.d core/cpuid.d core/demangle.d \\\n-\tcore/exception.d core/gc/config.d core/gc/gcinterface.d \\\n+\tcore/exception.d core/factory.d core/gc/config.d core/gc/gcinterface.d \\\n \tcore/gc/registry.d core/int128.d core/internal/abort.d \\\n \tcore/internal/array/appending.d core/internal/array/arrayassign.d \\\n \tcore/internal/array/capacity.d core/internal/array/casting.d \\\n@@ -1188,6 +1189,7 @@ core/checkedint.lo: core/$(am__dirstamp)\n core/cpuid.lo: core/$(am__dirstamp)\n core/demangle.lo: core/$(am__dirstamp)\n core/exception.lo: core/$(am__dirstamp)\n+core/factory.lo: core/$(am__dirstamp)\n core/gc/$(am__dirstamp):\n \t@$(MKDIR_P) core/gc\n \t@: > core/gc/$(am__dirstamp)"}, {"sha": "c2a7c334eb77a0e8397b5ae9f47bb47b2401c7d1", "filename": "libphobos/libdruntime/core/attribute.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fattribute.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fattribute.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fattribute.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -236,9 +236,9 @@ version (UdaGNUAbiTag) struct gnuAbiTag\n {\n     string[] tags;\n \n-    this(string[] tags...)\n+    this(string[] tags...) @safe pure nothrow\n     {\n-        this.tags = tags;\n+        this.tags = tags.dup;\n     }\n }\n "}, {"sha": "b79bd1df9c48971ce8139aa77c57b0b9c3d6f971", "filename": "libphobos/libdruntime/core/cpuid.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fcpuid.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fcpuid.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fcpuid.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1080,7 +1080,7 @@ void cpuidSparc()\n }\n */\n \n-shared static this()\n+pragma(crt_constructor) void cpuid_initialization()\n {\n     auto cf = getCpuFeatures();\n "}, {"sha": "3fcb26657c84074e4a446edac1ebed45a4ae176a", "filename": "libphobos/libdruntime/core/demangle.d", "status": "modified", "additions": 10, "deletions": 31, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fdemangle.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fdemangle.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fdemangle.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -801,7 +801,7 @@ pure @safe:\n     TypeTuple:\n         B Number Arguments\n     */\n-    char[] parseType( char[] name = null ) return scope\n+    char[] parseType() return scope\n     {\n         static immutable string[23] primitives = [\n             \"char\", // a\n@@ -830,7 +830,7 @@ pure @safe:\n         ];\n \n         static if (__traits(hasMember, Hooks, \"parseType\"))\n-            if (auto n = hooks.parseType(this, name))\n+            if (auto n = hooks.parseType(this, null))\n                 return n;\n \n         debug(trace) printf( \"parseType+\\n\" );\n@@ -861,27 +861,24 @@ pure @safe:\n         switch ( t )\n         {\n         case 'Q': // Type back reference\n-            return parseBackrefType( () => parseType( name ) );\n+            return parseBackrefType(() => parseType());\n         case 'O': // Shared (O Type)\n             popFront();\n             put( \"shared(\" );\n             parseType();\n             put( ')' );\n-            pad( name );\n             return dst[beg .. len];\n         case 'x': // Const (x Type)\n             popFront();\n             put( \"const(\" );\n             parseType();\n             put( ')' );\n-            pad( name );\n             return dst[beg .. len];\n         case 'y': // Immutable (y Type)\n             popFront();\n             put( \"immutable(\" );\n             parseType();\n             put( ')' );\n-            pad( name );\n             return dst[beg .. len];\n         case 'N':\n             popFront();\n@@ -912,7 +909,6 @@ pure @safe:\n             popFront();\n             parseType();\n             put( \"[]\" );\n-            pad( name );\n             return dst[beg .. len];\n         case 'G': // TypeStaticArray (G Number Type)\n             popFront();\n@@ -921,7 +917,6 @@ pure @safe:\n             put( '[' );\n             put( num );\n             put( ']' );\n-            pad( name );\n             return dst[beg .. len];\n         case 'H': // TypeAssocArray (H Type Type)\n             popFront();\n@@ -931,31 +926,28 @@ pure @safe:\n             put( '[' );\n             put( tx );\n             put( ']' );\n-            pad( name );\n             return dst[beg .. len];\n         case 'P': // TypePointer (P Type)\n             popFront();\n             parseType();\n             put( '*' );\n-            pad( name );\n             return dst[beg .. len];\n         case 'F': case 'U': case 'W': case 'V': case 'R': // TypeFunction\n-            return parseTypeFunction( name );\n+            return parseTypeFunction();\n         case 'C': // TypeClass (C LName)\n         case 'S': // TypeStruct (S LName)\n         case 'E': // TypeEnum (E LName)\n         case 'T': // TypeTypedef (T LName)\n             popFront();\n             parseQualifiedName();\n-            pad( name );\n             return dst[beg .. len];\n         case 'D': // TypeDelegate (D TypeFunction)\n             popFront();\n             auto modifiers = parseModifier();\n             if ( front == 'Q' )\n-                parseBackrefType( () => parseTypeFunction( name, IsDelegate.yes ) );\n+                parseBackrefType(() => parseTypeFunction(IsDelegate.yes));\n             else\n-                parseTypeFunction( name, IsDelegate.yes );\n+                parseTypeFunction(IsDelegate.yes);\n             if (modifiers)\n             {\n                 // write modifiers behind the function arguments\n@@ -989,7 +981,6 @@ pure @safe:\n             {\n                 popFront();\n                 put( primitives[cast(size_t)(t - 'a')] );\n-                pad( name );\n                 return dst[beg .. len];\n             }\n             else if (t == 'z')\n@@ -1000,12 +991,10 @@ pure @safe:\n                 case 'i':\n                     popFront();\n                     put( \"cent\" );\n-                    pad( name );\n                     return dst[beg .. len];\n                 case 'k':\n                     popFront();\n                     put( \"ucent\" );\n-                    pad( name );\n                     return dst[beg .. len];\n                 default:\n                     error();\n@@ -1358,7 +1347,7 @@ pure @safe:\n         TypeFunction:\n             CallConvention FuncAttrs Arguments ArgClose Type\n     */\n-    char[] parseTypeFunction( char[] name = null, IsDelegate isdg = IsDelegate.no ) return scope\n+    char[] parseTypeFunction(IsDelegate isdg = IsDelegate.no) return scope\n     {\n         debug(trace) printf( \"parseTypeFunction+\\n\" );\n         debug(trace) scope(success) printf( \"parseTypeFunction-\\n\" );\n@@ -1383,18 +1372,8 @@ pure @safe:\n         auto retbeg = len;\n         parseType();\n         put( ' ' );\n-        // append name/delegate/function\n-        if ( name.length )\n-        {\n-            if ( !contains( dst[0 .. len], name ) )\n-                put( name );\n-            else if ( shift( name ).ptr != name.ptr )\n-            {\n-                argbeg -= name.length;\n-                retbeg -= name.length;\n-            }\n-        }\n-        else if ( IsDelegate.yes == isdg )\n+        // append delegate/function\n+        if (IsDelegate.yes == isdg)\n             put( \"delegate\" );\n         else\n             put( \"function\" );\n@@ -2933,7 +2912,7 @@ CXX_DEMANGLER getCXXDemangler() nothrow @trusted\n         version (linux) import core.sys.linux.dlfcn : RTLD_DEFAULT;\n         version (NetBSD) import core.sys.netbsd.dlfcn : RTLD_DEFAULT;\n         version (OpenBSD) import core.sys.openbsd.dlfcn : RTLD_DEFAULT;\n-        version (OSX) import core.sys.darwin.dlfcn : RTLD_DEFAULT;\n+        version (Darwin) import core.sys.darwin.dlfcn : RTLD_DEFAULT;\n         version (Solaris) import core.sys.solaris.dlfcn : RTLD_DEFAULT;\n \n         if (auto found = cast(CXX_DEMANGLER) dlsym(RTLD_DEFAULT, \"__cxa_demangle\"))"}, {"sha": "f45a04ea91f957680ae31e9811943ce62a3640d3", "filename": "libphobos/libdruntime/core/factory.d", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Ffactory.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Ffactory.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Ffactory.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -0,0 +1,68 @@\n+/* Create classes from their modules and names.\n+ *\n+ * Copyright: Copyright (C) D Language Foundation 2023\n+ * License:   $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n+ * Authors:   Walter Bright, Steven Schveighoffer\n+ * Source:    $(DRUNTIMESRC core/_factory.d)\n+ */\n+\n+module core.factory;\n+\n+/**\n+ * Create instance of class specified by the module symbol and a string\n+ * representing the name of the class.\n+ * The class must either have no constructors or have\n+ * a default constructor.\n+ * Params:\n+ *   mod = symbol representing the module that the class is in\n+ *   classname = string representing the name of the class\n+ * Returns:\n+ *   null if failed\n+ * Example:\n+ * ---\n+ * module foo.bar;\n+ *\n+ * class C\n+ * {\n+ *     this() { x = 10; }\n+ *     int x;\n+ * }\n+ *\n+ * void main()\n+ * {\n+ *     auto c = cast(C)factory!(foo.bar)(\"C\");\n+ *     assert(c !is null && c.x == 10);\n+ * }\n+ * ---\n+ */\n+Object factory(alias mod)(string classname)\n+{\n+    foreach(cl; _getModuleClasses!mod)\n+    {\n+        if (cl.stringof == classname)\n+            return cl.classinfo.create();\n+    }\n+    return null;\n+}\n+\n+@system unittest\n+{\n+    Object valid_obj = factory!object(\"Object\");\n+    Object invalid_obj = factory!object(\"__this_class_doesnt_exist__\");\n+\n+    assert(valid_obj !is null);\n+    assert(invalid_obj is null);\n+}\n+\n+/**************************************\n+ * Retrieve as a tuple all the types of the top level classes in the module mod.\n+ */\n+private template _getModuleClasses(alias mod) {\n+   alias result = _AliasSeq!();\n+   static foreach(m; __traits(allMembers, mod))\n+      static if(is(__traits(getMember, mod, m) == class))\n+         result = _AliasSeq!(result, __traits(getMember, mod, m));\n+   alias _getModuleClasses = result;\n+}\n+\n+private template _AliasSeq(TList...) { alias _AliasSeq = TList; }"}, {"sha": "20fa7dea1705a7864d7a5e3fc95e4edc97074c15", "filename": "libphobos/libdruntime/core/int128.d", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fint128.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fint128.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fint128.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -18,8 +18,23 @@ alias I = long;\n alias U = ulong;\n enum Ubits = uint(U.sizeof * 8);\n \n-version (X86_64) private enum Cent_alignment = 16;\n-else             private enum Cent_alignment = (size_t.sizeof * 2);\n+version (DigitalMars)\n+{\n+    /* The alignment should follow target.stackAlign(),\n+     * which is `isXmmSupported() ? 16 : (is64bit ? 8 : 4)\n+     */\n+    version (D_SIMD)\n+        private enum Cent_alignment = 16;\n+    else version (X86_64)\n+        private enum Cent_alignment = 8;\n+    else\n+        private enum Cent_alignment = 4;\n+}\n+else\n+{\n+    version (X86_64) private enum Cent_alignment = 16;\n+    else             private enum Cent_alignment = (size_t.sizeof * 2);\n+}\n \n align(Cent_alignment) struct Cent\n {"}, {"sha": "b609167eefe2f02122daef1a2c08f888fd7272de", "filename": "libphobos/libdruntime/core/internal/array/appending.d", "status": "modified", "additions": 29, "deletions": 22, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Finternal%2Farray%2Fappending.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Finternal%2Farray%2Fappending.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Finternal%2Farray%2Fappending.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -17,8 +17,6 @@ private enum isCopyingNothrow(T) = __traits(compiles, (ref T rhs) nothrow { T lh\n /// Implementation of `_d_arrayappendcTX` and `_d_arrayappendcTXTrace`\n template _d_arrayappendcTXImpl(Tarr : T[], T)\n {\n-    import core.internal.array.utils : _d_HookTraceImpl;\n-\n     private enum errorMessage = \"Cannot append to array if compiling without support for runtime type information!\";\n \n     /**\n@@ -51,17 +49,22 @@ template _d_arrayappendcTXImpl(Tarr : T[], T)\n             return px;\n         }\n         else\n-            assert(0, \"Cannot append arrays if compiling without support for runtime type information!\");\n+            assert(0, errorMessage);\n     }\n \n-    /**\n-     * TraceGC wrapper around $(REF _d_arrayappendcTX, rt,array,appending,_d_arrayappendcTXImpl).\n-     * Bugs:\n-     *  This function template was ported from a much older runtime hook that bypassed safety,\n-     *  purity, and throwabilty checks. To prevent breaking existing code, this function template\n-     *  is temporarily declared `@trusted pure` until the implementation can be brought up to modern D expectations.\n-     */\n-    alias _d_arrayappendcTXTrace = _d_HookTraceImpl!(Tarr, _d_arrayappendcTX, errorMessage);\n+    version (D_ProfileGC)\n+    {\n+        import core.internal.array.utils : _d_HookTraceImpl;\n+\n+        /**\n+         * TraceGC wrapper around $(REF _d_arrayappendcTX, rt,array,appending,_d_arrayappendcTXImpl).\n+         * Bugs:\n+         *  This function template was ported from a much older runtime hook that bypassed safety,\n+         *  purity, and throwabilty checks. To prevent breaking existing code, this function template\n+         *  is temporarily declared `@trusted pure` until the implementation can be brought up to modern D expectations.\n+         */\n+        alias _d_arrayappendcTXTrace = _d_HookTraceImpl!(Tarr, _d_arrayappendcTX, errorMessage);\n+    }\n }\n \n /// Implementation of `_d_arrayappendT`\n@@ -71,7 +74,6 @@ ref Tarr _d_arrayappendT(Tarr : T[], T)(return ref scope Tarr x, scope Tarr y) @\n \n     import core.stdc.string : memcpy;\n     import core.internal.traits : hasElaborateCopyConstructor, Unqual;\n-    import core.lifetime : copyEmplace;\n \n     enum hasPostblit = __traits(hasPostblit, T);\n     auto length = x.length;\n@@ -81,6 +83,8 @@ ref Tarr _d_arrayappendT(Tarr : T[], T)(return ref scope Tarr x, scope Tarr y) @\n     // Only call `copyEmplace` if `T` has a copy ctor and no postblit.\n     static if (hasElaborateCopyConstructor!T && !hasPostblit)\n     {\n+        import core.lifetime : copyEmplace;\n+\n         foreach (i, ref elem; y)\n             copyEmplace(elem, x[length + i]);\n     }\n@@ -107,20 +111,23 @@ ref Tarr _d_arrayappendT(Tarr : T[], T)(return ref scope Tarr x, scope Tarr y) @\n     return x;\n }\n \n-/**\n- * TraceGC wrapper around $(REF _d_arrayappendT, core,internal,array,appending).\n- */\n-ref Tarr _d_arrayappendTTrace(Tarr : T[], T)(string file, int line, string funcname, return ref scope Tarr x, scope Tarr y) @trusted\n+version (D_ProfileGC)\n {\n-    version (D_TypeInfo)\n+    /**\n+     * TraceGC wrapper around $(REF _d_arrayappendT, core,internal,array,appending).\n+     */\n+    ref Tarr _d_arrayappendTTrace(Tarr : T[], T)(string file, int line, string funcname, return ref scope Tarr x, scope Tarr y) @trusted\n     {\n-        import core.internal.array.utils: TraceHook, gcStatsPure, accumulatePure;\n-        mixin(TraceHook!(Tarr.stringof, \"_d_arrayappendT\"));\n+        version (D_TypeInfo)\n+        {\n+            import core.internal.array.utils: TraceHook, gcStatsPure, accumulatePure;\n+            mixin(TraceHook!(Tarr.stringof, \"_d_arrayappendT\"));\n \n-        return _d_arrayappendT(x, y);\n+            return _d_arrayappendT(x, y);\n+        }\n+        else\n+            assert(0, \"Cannot append to array if compiling without support for runtime type information!\");\n     }\n-    else\n-        assert(0, \"Cannot append to array if compiling without support for runtime type information!\");\n }\n \n @safe unittest"}, {"sha": "254e9501f632c4905b40086d380f325678bb50e9", "filename": "libphobos/libdruntime/core/internal/array/capacity.d", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Finternal%2Farray%2Fcapacity.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Finternal%2Farray%2Fcapacity.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Finternal%2Farray%2Fcapacity.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -22,8 +22,6 @@ private extern (C) void[] _d_arraysetlengthiT(const TypeInfo ti, size_t newlengt\n /// Implementation of `_d_arraysetlengthT` and `_d_arraysetlengthTTrace`\n template _d_arraysetlengthTImpl(Tarr : T[], T)\n {\n-    import core.internal.array.utils : _d_HookTraceImpl;\n-\n     private enum errorMessage = \"Cannot resize arrays if compiling without support for runtime type information!\";\n \n     /**\n@@ -54,14 +52,19 @@ template _d_arraysetlengthTImpl(Tarr : T[], T)\n             assert(0, errorMessage);\n     }\n \n-    /**\n-    * TraceGC wrapper around $(REF _d_arraysetlengthT, core,internal,array,core.internal.array.capacity).\n-    * Bugs:\n-    *  This function template was ported from a much older runtime hook that bypassed safety,\n-    *  purity, and throwabilty checks. To prevent breaking existing code, this function template\n-    *  is temporarily declared `@trusted pure nothrow` until the implementation can be brought up to modern D expectations.\n-    */\n-    alias _d_arraysetlengthTTrace = _d_HookTraceImpl!(Tarr, _d_arraysetlengthT, errorMessage);\n+    version (D_ProfileGC)\n+    {\n+        import core.internal.array.utils : _d_HookTraceImpl;\n+\n+        /**\n+         * TraceGC wrapper around $(REF _d_arraysetlengthT, core,internal,array,core.internal.array.capacity).\n+         * Bugs:\n+         *  This function template was ported from a much older runtime hook that bypassed safety,\n+         *  purity, and throwabilty checks. To prevent breaking existing code, this function template\n+         *  is temporarily declared `@trusted pure nothrow` until the implementation can be brought up to modern D expectations.\n+         */\n+        alias _d_arraysetlengthTTrace = _d_HookTraceImpl!(Tarr, _d_arraysetlengthT, errorMessage);\n+    }\n }\n \n @safe unittest"}, {"sha": "99f33da7683dc2abab463ac5e9960e10f262a430", "filename": "libphobos/libdruntime/core/internal/array/concatenation.d", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Finternal%2Farray%2Fconcatenation.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Finternal%2Farray%2Fconcatenation.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Finternal%2Farray%2Fconcatenation.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -14,8 +14,6 @@ private extern (C) void[] _d_arraycatnTX(const TypeInfo ti, scope byte[][] arrs)\n /// Implementation of `_d_arraycatnTX` and `_d_arraycatnTXTrace`\n template _d_arraycatnTXImpl(Tarr : ResultArrT[], ResultArrT : T[], T)\n {\n-    import core.internal.array.utils : _d_HookTraceImpl;\n-\n     private enum errorMessage = \"Cannot concatenate arrays if compiling without support for runtime type information!\";\n \n     /**\n@@ -45,14 +43,19 @@ template _d_arraycatnTXImpl(Tarr : ResultArrT[], ResultArrT : T[], T)\n             assert(0, errorMessage);\n     }\n \n-    /**\n-    * TraceGC wrapper around $(REF _d_arraycatnTX, core,internal,array,concat).\n-    * Bugs:\n-    *  This function template was ported from a much older runtime hook that bypassed safety,\n-    *  purity, and throwabilty checks. To prevent breaking existing code, this function template\n-    *  is temporarily declared `@trusted pure nothrow` until the implementation can be brought up to modern D expectations.\n-    */\n-    alias _d_arraycatnTXTrace = _d_HookTraceImpl!(ResultArrT, _d_arraycatnTX, errorMessage);\n+    version (D_ProfileGC)\n+    {\n+        import core.internal.array.utils : _d_HookTraceImpl;\n+\n+        /**\n+         * TraceGC wrapper around $(REF _d_arraycatnTX, core,internal,array,concat).\n+         * Bugs:\n+         *  This function template was ported from a much older runtime hook that bypassed safety,\n+         *  purity, and throwabilty checks. To prevent breaking existing code, this function template\n+         *  is temporarily declared `@trusted pure nothrow` until the implementation can be brought up to modern D expectations.\n+         */\n+        alias _d_arraycatnTXTrace = _d_HookTraceImpl!(ResultArrT, _d_arraycatnTX, errorMessage);\n+    }\n }\n \n @safe unittest"}, {"sha": "21894c29d38585a3361803d18310afb47662f951", "filename": "libphobos/libdruntime/core/internal/array/duplication.d", "status": "modified", "additions": 36, "deletions": 22, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Finternal%2Farray%2Fduplication.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Finternal%2Farray%2Fduplication.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Finternal%2Farray%2Fduplication.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -15,10 +15,17 @@ U[] _dup(T, U)(scope T[] a) pure nothrow @trusted if (__traits(isPOD, T))\n     if (__ctfe)\n         return _dupCtfe!(T, U)(a);\n \n-    import core.stdc.string : memcpy;\n-    auto arr = _d_newarrayU(typeid(T[]), a.length);\n-    memcpy(arr.ptr, cast(const(void)*) a.ptr, T.sizeof * a.length);\n-    return *cast(U[]*) &arr;\n+    version (D_BetterC)\n+    {\n+        return _dupCtfe!(T, U)(a);\n+    }\n+    else\n+    {\n+        import core.stdc.string : memcpy;\n+        auto arr = _d_newarrayU(typeid(T[]), a.length);\n+        memcpy(arr.ptr, cast(const(void)*) a.ptr, T.sizeof * a.length);\n+        return *cast(U[]*) &arr;\n+    }\n }\n \n U[] _dupCtfe(T, U)(scope T[] a)\n@@ -41,25 +48,32 @@ U[] _dup(T, U)(T[] a) if (!__traits(isPOD, T))\n     if (__ctfe)\n         return _dupCtfe!(T, U)(a);\n \n-    import core.lifetime: copyEmplace;\n-    U[] res = () @trusted {\n-        auto arr = cast(U*) _d_newarrayU(typeid(T[]), a.length);\n-        size_t i;\n-        scope (failure)\n-        {\n-            import core.internal.lifetime: emplaceInitializer;\n-            // Initialize all remaining elements to not destruct garbage\n-            foreach (j; i .. a.length)\n-                emplaceInitializer(cast() arr[j]);\n-        }\n-        for (; i < a.length; i++)\n-        {\n-            copyEmplace(a.ptr[i], arr[i]);\n-        }\n-        return cast(U[])(arr[0..a.length]);\n-    } ();\n+    version (D_BetterC)\n+    {\n+        return _dupCtfe!(T, U)(a);\n+    }\n+    else\n+    {\n+        import core.lifetime: copyEmplace;\n+        U[] res = () @trusted {\n+            auto arr = cast(U*) _d_newarrayU(typeid(T[]), a.length);\n+            size_t i;\n+            scope (failure)\n+            {\n+                import core.internal.lifetime: emplaceInitializer;\n+                // Initialize all remaining elements to not destruct garbage\n+                foreach (j; i .. a.length)\n+                    emplaceInitializer(cast() arr[j]);\n+            }\n+            for (; i < a.length; i++)\n+            {\n+                copyEmplace(a.ptr[i], arr[i]);\n+            }\n+            return cast(U[])(arr[0..a.length]);\n+        } ();\n \n-    return res;\n+        return res;\n+    }\n }\n \n // https://issues.dlang.org/show_bug.cgi?id=22107"}, {"sha": "a16005e714de98916c331d756cd74a41d56230b6", "filename": "libphobos/libdruntime/core/internal/array/utils.d", "status": "modified", "additions": 69, "deletions": 66, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Finternal%2Farray%2Futils.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Finternal%2Farray%2Futils.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Finternal%2Farray%2Futils.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -34,76 +34,79 @@ ulong accumulatePure(string file, int line, string funcname, string name, ulong\n     return func(file, line, funcname, name, size);\n }\n \n-/**\n- * TraceGC wrapper generator around the runtime hook `Hook`.\n- * Params:\n- *   Type = The type of hook to report to accumulate\n- *   Hook = The name hook to wrap\n- */\n-template TraceHook(string Type, string Hook)\n+version (D_ProfileGC)\n {\n-    const char[] TraceHook = q{\n-        import core.internal.array.utils : gcStatsPure, accumulatePure;\n-\n-        pragma(inline, false);\n-        string name = } ~ \"`\" ~ Type ~ \"`;\" ~ q{\n-\n-        // FIXME: use rt.tracegc.accumulator when it is accessable in the future.\n-        version (tracegc)\n-    } ~ \"{\\n\" ~ q{\n-            import core.stdc.stdio;\n-\n-            printf(\"%sTrace file = '%.*s' line = %d function = '%.*s' type = %.*s\\n\",\n-            } ~ \"\\\"\" ~ Hook ~ \"\\\".ptr,\" ~ q{\n-                file.length, file.ptr,\n-                line,\n-                funcname.length, funcname.ptr,\n-                name.length, name.ptr\n-            );\n-        } ~ \"}\\n\" ~ q{\n-        ulong currentlyAllocated = gcStatsPure().allocatedInCurrentThread;\n-\n-        scope(exit)\n-        {\n-            ulong size = gcStatsPure().allocatedInCurrentThread - currentlyAllocated;\n-            if (size > 0)\n-                if (!accumulatePure(file, line, funcname, name, size)) {\n-                    // This 'if' and 'assert' is needed to force the compiler to not remove the call to\n-                    // `accumulatePure`. It really want to do that while optimizing as the function is\n-                    // `pure` and it does not influence the result of this hook.\n-\n-                    // `accumulatePure` returns the value of `size`, which can never be zero due to the\n-                    // previous 'if'. So this assert will never be triggered.\n-                    assert(0);\n-                }\n-        }\n-    };\n-}\n+    /**\n+     * TraceGC wrapper generator around the runtime hook `Hook`.\n+     * Params:\n+     *   Type = The type of hook to report to accumulate\n+     *   Hook = The name hook to wrap\n+     */\n+    template TraceHook(string Type, string Hook)\n+    {\n+        const char[] TraceHook = q{\n+            import core.internal.array.utils : gcStatsPure, accumulatePure;\n+\n+            pragma(inline, false);\n+            string name = } ~ \"`\" ~ Type ~ \"`;\" ~ q{\n+\n+            // FIXME: use rt.tracegc.accumulator when it is accessable in the future.\n+            version (tracegc)\n+        } ~ \"{\\n\" ~ q{\n+                import core.stdc.stdio;\n+\n+                printf(\"%sTrace file = '%.*s' line = %d function = '%.*s' type = %.*s\\n\",\n+                } ~ \"\\\"\" ~ Hook ~ \"\\\".ptr,\" ~ q{\n+                    file.length, file.ptr,\n+                    line,\n+                    funcname.length, funcname.ptr,\n+                    name.length, name.ptr\n+                );\n+            } ~ \"}\\n\" ~ q{\n+            ulong currentlyAllocated = gcStatsPure().allocatedInCurrentThread;\n+\n+            scope(exit)\n+            {\n+                ulong size = gcStatsPure().allocatedInCurrentThread - currentlyAllocated;\n+                if (size > 0)\n+                    if (!accumulatePure(file, line, funcname, name, size)) {\n+                        // This 'if' and 'assert' is needed to force the compiler to not remove the call to\n+                        // `accumulatePure`. It really want to do that while optimizing as the function is\n+                        // `pure` and it does not influence the result of this hook.\n+\n+                        // `accumulatePure` returns the value of `size`, which can never be zero due to the\n+                        // previous 'if'. So this assert will never be triggered.\n+                        assert(0);\n+                    }\n+            }\n+        };\n+    }\n \n-/**\n- * TraceGC wrapper around runtime hook `Hook`.\n- * Params:\n- *  T = Type of hook to report to accumulate\n- *  Hook = The hook to wrap\n- *  errorMessage = The error message incase `version != D_TypeInfo`\n- *  file = File that called `_d_HookTraceImpl`\n- *  line = Line inside of `file` that called `_d_HookTraceImpl`\n- *  funcname = Function that called `_d_HookTraceImpl`\n- *  parameters = Parameters that will be used to call `Hook`\n- * Bugs:\n- *  This function template needs be between the compiler and a much older runtime hook that bypassed safety,\n- *  purity, and throwabilty checks. To prevent breaking existing code, this function template\n- *  is temporarily declared `@trusted pure` until the implementation can be brought up to modern D expectations.\n-*/\n-auto _d_HookTraceImpl(T, alias Hook, string errorMessage)(string file, int line, string funcname, Parameters!Hook parameters) @trusted pure\n-{\n-    version (D_TypeInfo)\n+    /**\n+     * TraceGC wrapper around runtime hook `Hook`.\n+     * Params:\n+     *  T = Type of hook to report to accumulate\n+     *  Hook = The hook to wrap\n+     *  errorMessage = The error message incase `version != D_TypeInfo`\n+     *  file = File that called `_d_HookTraceImpl`\n+     *  line = Line inside of `file` that called `_d_HookTraceImpl`\n+     *  funcname = Function that called `_d_HookTraceImpl`\n+     *  parameters = Parameters that will be used to call `Hook`\n+     * Bugs:\n+     *  This function template needs be between the compiler and a much older runtime hook that bypassed safety,\n+     *  purity, and throwabilty checks. To prevent breaking existing code, this function template\n+     *  is temporarily declared `@trusted pure` until the implementation can be brought up to modern D expectations.\n+    */\n+    auto _d_HookTraceImpl(T, alias Hook, string errorMessage)(string file, int line, string funcname, Parameters!Hook parameters) @trusted pure\n     {\n-        mixin(TraceHook!(T.stringof, __traits(identifier, Hook)));\n-        return Hook(parameters);\n+        version (D_TypeInfo)\n+        {\n+            mixin(TraceHook!(T.stringof, __traits(identifier, Hook)));\n+            return Hook(parameters);\n+        }\n+        else\n+            assert(0, errorMessage);\n     }\n-    else\n-        assert(0, errorMessage);\n }\n \n /**"}, {"sha": "966839f176ac6dae9168da2d1bbfc36d88c9c5ad", "filename": "libphobos/libdruntime/core/internal/traits.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Finternal%2Ftraits.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Finternal%2Ftraits.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Finternal%2Ftraits.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -654,7 +654,7 @@ if (func.length == 1 /*&& isCallable!func*/)\n         int  test(int);\n         int  test() @property;\n     }\n-    alias ov = __traits(getVirtualFunctions, Overloads, \"test\");\n+    alias ov = __traits(getVirtualMethods, Overloads, \"test\");\n     alias F_ov0 = FunctionTypeOf!(ov[0]);\n     alias F_ov1 = FunctionTypeOf!(ov[1]);\n     alias F_ov2 = FunctionTypeOf!(ov[2]);"}, {"sha": "5e339c041d12e69f5f1192ad9bc227d0bd9d1e0d", "filename": "libphobos/libdruntime/core/lifetime.d", "status": "modified", "additions": 121, "deletions": 13, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Flifetime.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Flifetime.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Flifetime.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -2385,21 +2385,24 @@ template _d_delstructImpl(T)\n         }\n     }\n \n-    import core.internal.array.utils : _d_HookTraceImpl;\n+    version (D_ProfileGC)\n+    {\n+        import core.internal.array.utils : _d_HookTraceImpl;\n \n-    private enum errorMessage = \"Cannot delete struct if compiling without support for runtime type information!\";\n+        private enum errorMessage = \"Cannot delete struct if compiling without support for runtime type information!\";\n \n-    /**\n-     * TraceGC wrapper around $(REF _d_delstruct, core,lifetime,_d_delstructImpl).\n-     *\n-     * Bugs:\n-     *   This function template was ported from a much older runtime hook that\n-     *   bypassed safety, purity, and throwabilty checks. To prevent breaking\n-     *   existing code, this function template is temporarily declared\n-     *   `@trusted` until the implementation can be brought up to modern D\n-     *   expectations.\n-     */\n-    alias _d_delstructTrace = _d_HookTraceImpl!(T, _d_delstruct, errorMessage);\n+        /**\n+         * TraceGC wrapper around $(REF _d_delstruct, core,lifetime,_d_delstructImpl).\n+         *\n+         * Bugs:\n+         *   This function template was ported from a much older runtime hook that\n+         *   bypassed safety, purity, and throwabilty checks. To prevent breaking\n+         *   existing code, this function template is temporarily declared\n+         *   `@trusted` until the implementation can be brought up to modern D\n+         *   expectations.\n+         */\n+        alias _d_delstructTrace = _d_HookTraceImpl!(T, _d_delstruct, errorMessage);\n+    }\n }\n \n @system pure nothrow unittest\n@@ -2709,3 +2712,108 @@ T _d_newThrowable(T)() @trusted\n     assert(exc.refcount() == 1);\n     assert(e.refcount() == 1);\n }\n+\n+/**\n+ * Create a new class instance.\n+ * Allocates memory and sets fields to their initial value, but does not call a\n+ * constructor.\n+ * ---\n+ * new C() // _d_newclass!(C)()\n+ * ---\n+ * Returns: newly created object\n+ */\n+T _d_newclassT(T)() @trusted\n+if (is(T == class))\n+{\n+    import core.internal.traits : hasIndirections;\n+    import core.exception : onOutOfMemoryError;\n+    import core.memory : GC, pureMalloc;\n+\n+    alias BlkAttr = GC.BlkAttr;\n+\n+    auto init = __traits(initSymbol, T);\n+    void* p;\n+\n+    static if (__traits(getLinkage, T) == \"Windows\")\n+    {\n+        p = pureMalloc(init.length);\n+        if (!p)\n+            onOutOfMemoryError();\n+    }\n+    else\n+    {\n+        BlkAttr attr = BlkAttr.NONE;\n+\n+        /* `extern(C++)`` classes don't have a classinfo pointer in their vtable,\n+         * so the GC can't finalize them.\n+         */\n+        static if (__traits(hasMember, T, \"__dtor\") && __traits(getLinkage, T) != \"C++\")\n+            attr |= BlkAttr.FINALIZE;\n+        static if (!hasIndirections!T)\n+            attr |= BlkAttr.NO_SCAN;\n+\n+        p = GC.malloc(init.length, attr, typeid(T));\n+        debug(PRINTF) printf(\" p = %p\\n\", p);\n+    }\n+\n+    debug(PRINTF)\n+    {\n+        printf(\"p = %p\\n\", p);\n+        printf(\"init.ptr = %p, len = %llu\\n\", init.ptr, cast(ulong)init.length);\n+        printf(\"vptr = %p\\n\", *cast(void**) init);\n+        printf(\"vtbl[0] = %p\\n\", (*cast(void***) init)[0]);\n+        printf(\"vtbl[1] = %p\\n\", (*cast(void***) init)[1]);\n+        printf(\"init[0] = %x\\n\", (cast(uint*) init)[0]);\n+        printf(\"init[1] = %x\\n\", (cast(uint*) init)[1]);\n+        printf(\"init[2] = %x\\n\", (cast(uint*) init)[2]);\n+        printf(\"init[3] = %x\\n\", (cast(uint*) init)[3]);\n+        printf(\"init[4] = %x\\n\", (cast(uint*) init)[4]);\n+    }\n+\n+    // initialize it\n+    p[0 .. init.length] = init[];\n+\n+    debug(PRINTF) printf(\"initialization done\\n\");\n+    return cast(T) p;\n+}\n+\n+// Test allocation\n+@safe unittest\n+{\n+    class C { }\n+    C c = _d_newclassT!C();\n+\n+    assert(c !is null);\n+}\n+\n+// Test initializers\n+@safe unittest\n+{\n+    {\n+        class C { int x, y; }\n+        C c = _d_newclassT!C();\n+\n+        assert(c.x == 0);\n+        assert(c.y == 0);\n+    }\n+    {\n+        class C { int x = 2, y = 3; }\n+        C c = _d_newclassT!C();\n+\n+        assert(c.x == 2);\n+        assert(c.y == 3);\n+    }\n+}\n+\n+T _d_newclassTTrace(T)(string file, int line, string funcname) @trusted\n+{\n+    version (D_TypeInfo)\n+    {\n+        import core.internal.array.utils: TraceHook, gcStatsPure, accumulatePure;\n+        mixin(TraceHook!(T.stringof, \"_d_newclassT\"));\n+\n+        return _d_newclassT!T();\n+    }\n+    else\n+        assert(0, \"Cannot create new class if compiling without support for runtime type information!\");\n+}"}, {"sha": "96c2af478d39e0923129ef4aacf47d445fc8a49b", "filename": "libphobos/libdruntime/core/memory.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fmemory.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fmemory.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fmemory.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -202,8 +202,8 @@ unittest\n // make it more difficult to call the function again, manually.\n private void initialize();\n pragma(crt_constructor)\n-pragma(mangle, `_D` ~ initialize.mangleof)\n-private extern (C) void initialize() @system\n+pragma(mangle, initialize.mangleof)\n+private extern (C) void _initialize() @system\n {\n     version (Posix)\n     {"}, {"sha": "c85682ec0a6b8651b33b47542337198500f71ad2", "filename": "libphobos/libdruntime/core/stdc/config.d", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fconfig.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fconfig.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fconfig.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -312,3 +312,28 @@ alias c_complex_float = __c_complex_float;\n alias c_complex_double = __c_complex_double;\n alias c_complex_real = __c_complex_real;\n }\n+\n+\n+// Returns the mangled name for the 64-bit time_t versions of\n+// functions affected by musl's transition to 64-bit time_t.\n+// https://musl.libc.org/time64.html\n+version (CRuntime_Musl)\n+{\n+    version (CRuntime_Musl_Pre_Time64)\n+        enum muslRedirTime64 = false;\n+    else\n+    {\n+        // time_t was defined as a C long in older Musl versions.\n+        enum muslRedirTime64 = (c_long.sizeof == 4);\n+    }\n+}\n+else\n+    enum muslRedirTime64 = false;\n+\n+package(core) template muslRedirTime64Mangle(string name, string redirectedName)\n+{\n+    static if (muslRedirTime64)\n+        enum muslRedirTime64Mangle = redirectedName;\n+    else\n+        enum muslRedirTime64Mangle = name;\n+}"}, {"sha": "d7a57655fabe63dd41702b91ecc57b2497dd87c3", "filename": "libphobos/libdruntime/core/stdc/time.d", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Ftime.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Ftime.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Ftime.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -30,19 +30,25 @@ nothrow:\n @nogc:\n \n ///\n+pragma(mangle, muslRedirTime64Mangle!(\"difftime\", \"__difftime64\"))\n pure double  difftime(time_t time1, time_t time0); // MT-Safe\n ///\n+pragma(mangle, muslRedirTime64Mangle!(\"mktime\", \"__mktime64\"))\n @system time_t  mktime(scope tm* timeptr); // @system: MT-Safe env locale\n ///\n+pragma(mangle, muslRedirTime64Mangle!(\"time\", \"__time64\"))\n time_t  time(scope time_t* timer);\n \n ///\n @system char*   asctime(const scope tm* timeptr); // @system: MT-Unsafe race:asctime locale\n ///\n+pragma(mangle, muslRedirTime64Mangle!(\"ctime\", \"__ctime64\"))\n @system char*   ctime(const scope time_t* timer); // @system: MT-Unsafe race:tmbuf race:asctime env locale\n ///\n+pragma(mangle, muslRedirTime64Mangle!(\"gmtime\", \"__gmtime64\"))\n @system tm*     gmtime(const scope time_t* timer); // @system: MT-Unsafe race:tmbuf env locale\n ///\n+pragma(mangle, muslRedirTime64Mangle!(\"localtime\", \"__localtime64\"))\n @system tm*     localtime(const scope time_t* timer); // @system: MT-Unsafe race:tmbuf env locale\n ///\n @system size_t  strftime(scope char* s, size_t maxsize, const scope char* format, const scope tm* timeptr); // @system: MT-Safe env locale"}, {"sha": "53504db449e7005857fb024577de958d5b5dde3f", "filename": "libphobos/libdruntime/core/sys/darwin/sys/event.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fdarwin%2Fsys%2Fevent.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fdarwin%2Fsys%2Fevent.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fdarwin%2Fsys%2Fevent.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -46,12 +46,12 @@ enum : short\n     EVFILT_EXCEPT   = -15,\n }\n \n-extern(D) void EV_SET(kevent_t* kevp, typeof(kevent_t.tupleof) args)\n+extern(D) void EV_SET()(kevent_t* kevp, typeof(kevent_t.tupleof) args)\n {\n     *kevp = kevent_t(args);\n }\n \n-extern(D) void EV_SET64(kevent64_s* kevp, typeof(kevent64_s.tupleof) args)\n+extern(D) void EV_SET64()(kevent64_s* kevp, typeof(kevent64_s.tupleof) args)\n {\n     *kevp = kevent64_s(args);\n }"}, {"sha": "3a537a4a575b398dab49e85ba7ce515b751eb0c9", "filename": "libphobos/libdruntime/core/sys/posix/aio.d", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Faio.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Faio.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Faio.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -8,6 +8,7 @@\n  */\n module core.sys.posix.aio;\n \n+import core.stdc.config;\n import core.sys.posix.signal;\n import core.sys.posix.sys.types;\n \n@@ -392,6 +393,7 @@ else\n     int aio_fsync(int op, aiocb* aiocbp);\n     int aio_error(const(aiocb)* aiocbp);\n     ssize_t aio_return(aiocb* aiocbp);\n+    pragma(mangle, muslRedirTime64Mangle!(\"aio_suspend\", \"__aio_suspend_time64\"))\n     int aio_suspend(const(aiocb*)* aiocb_list, int nitems, const(timespec)* timeout);\n     int aio_cancel(int fd, aiocb* aiocbp);\n     int lio_listio(int mode, const(aiocb*)* aiocb_list, int nitems, sigevent* sevp);"}, {"sha": "f4bd2d8ba92fd47a50c922ebf334dfbdbf63495d", "filename": "libphobos/libdruntime/core/sys/posix/dlfcn.d", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fdlfcn.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fdlfcn.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fdlfcn.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -177,6 +177,38 @@ version (CRuntime_Glibc)\n         void* dli_saddr;\n     }\n }\n+else\n+version (CRuntime_Musl)\n+{\n+    enum RTLD_LAZY   = 1;\n+    enum RTLD_NOW    = 2;\n+    enum RTLD_NOLOAD = 4;\n+    enum RTLD_NODELETE = 4096;\n+    enum RTLD_GLOBAL = 256;\n+    enum RTLD_LOCAL  = 0;\n+\n+    enum RTLD_NEXT    = cast(void *)-1;\n+    enum RTLD_DEFAULT = cast(void *)0;\n+\n+    enum RTLD_DI_LINKMAP = 2;\n+\n+    int    dlclose(void *);\n+    char  *dlerror();\n+    void  *dlopen(const(char) *, int);\n+\n+    pragma(mangle, muslRedirTime64Mangle!(\"dlsym\", \"__dlsym_time64\"))\n+    void  *dlsym(void *__restrict, const(char) *__restrict);\n+\n+    struct Dl_info\n+    {\n+        const(char)* dli_fname;\n+        void* dli_fbase;\n+        const(char)* dli_sname;\n+        void* dli_saddr;\n+    }\n+    int dladdr(const(void) *, Dl_info *);\n+    int dlinfo(void *, int, void *);\n+}\n else version (Darwin)\n {\n     enum RTLD_LAZY      = 0x00001;"}, {"sha": "eae50d27d835070f8eb76d3e0c3097d3a1225d15", "filename": "libphobos/libdruntime/core/sys/posix/mqueue.d", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fmqueue.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fmqueue.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fmqueue.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -178,6 +178,7 @@ ssize_t mq_receive (mqd_t mqdes, char* msg_ptr, size_t msg_len, uint* msg_prio);\n  *   On success, mq_receive() returns the number of bytes in the received\n  *   message; on error, -1 is returned, with errno set to indicate the error\n  */\n+pragma(mangle, muslRedirTime64Mangle!(\"mq_timedreceive\", \"__mq_timedreceive_time64\"))\n ssize_t mq_timedreceive (mqd_t mqdes, char* msg_ptr, size_t msg_len,\n                          uint* msg_prio, const(timespec)* abs_timeout);\n \n@@ -216,5 +217,6 @@ int mq_send (mqd_t mqdes, const(char)* msg_ptr, size_t msg_len, uint msg_prio);\n  *   with errno set to indicate the error.\n  *\n  */\n+pragma(mangle, muslRedirTime64Mangle!(\"mq_timedsend\", \"__mq_timedsend_time64\"))\n int mq_timedsend (mqd_t mqdes, const(char)* msg_ptr, size_t msg_len,\n                    uint msg_prio, const(timespec)* abs_timeout);"}, {"sha": "5818ee6e22b6ae10a61ba6208aeab6bcb6756046", "filename": "libphobos/libdruntime/core/sys/posix/netinet/in_.d", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fnetinet%2Fin_.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fnetinet%2Fin_.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fnetinet%2Fin_.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -547,77 +547,77 @@ version (CRuntime_Glibc)\n     }\n \n     // macros\n-    extern (D) int IN6_IS_ADDR_UNSPECIFIED( in6_addr* addr ) pure\n+    extern (D) int IN6_IS_ADDR_UNSPECIFIED( const scope in6_addr* addr ) pure\n     {\n         return (cast(uint32_t*) addr)[0] == 0 &&\n                (cast(uint32_t*) addr)[1] == 0 &&\n                (cast(uint32_t*) addr)[2] == 0 &&\n                (cast(uint32_t*) addr)[3] == 0;\n     }\n \n-    extern (D) int IN6_IS_ADDR_LOOPBACK( in6_addr* addr ) pure\n+    extern (D) int IN6_IS_ADDR_LOOPBACK( const scope in6_addr* addr ) pure\n     {\n         return (cast(uint32_t*) addr)[0] == 0  &&\n                (cast(uint32_t*) addr)[1] == 0  &&\n                (cast(uint32_t*) addr)[2] == 0  &&\n                (cast(uint32_t*) addr)[3] == htonl( 1 );\n     }\n \n-    extern (D) int IN6_IS_ADDR_MULTICAST( in6_addr* addr ) pure\n+    extern (D) int IN6_IS_ADDR_MULTICAST( const scope in6_addr* addr ) pure\n     {\n         return (cast(uint8_t*) addr)[0] == 0xff;\n     }\n \n-    extern (D) int IN6_IS_ADDR_LINKLOCAL( in6_addr* addr ) pure\n+    extern (D) int IN6_IS_ADDR_LINKLOCAL( const scope in6_addr* addr ) pure\n     {\n         return ((cast(uint32_t*) addr)[0] & htonl( 0xffc00000 )) == htonl( 0xfe800000 );\n     }\n \n-    extern (D) int IN6_IS_ADDR_SITELOCAL( in6_addr* addr ) pure\n+    extern (D) int IN6_IS_ADDR_SITELOCAL( const scope in6_addr* addr ) pure\n     {\n         return ((cast(uint32_t*) addr)[0] & htonl( 0xffc00000 )) == htonl( 0xfec00000 );\n     }\n \n-    extern (D) int IN6_IS_ADDR_V4MAPPED( in6_addr* addr ) pure\n+    extern (D) int IN6_IS_ADDR_V4MAPPED( const scope in6_addr* addr ) pure\n     {\n         return (cast(uint32_t*) addr)[0] == 0 &&\n                (cast(uint32_t*) addr)[1] == 0 &&\n                (cast(uint32_t*) addr)[2] == htonl( 0xffff );\n     }\n \n-    extern (D) int IN6_IS_ADDR_V4COMPAT( in6_addr* addr ) pure\n+    extern (D) int IN6_IS_ADDR_V4COMPAT( const scope in6_addr* addr ) pure\n     {\n         return (cast(uint32_t*) addr)[0] == 0 &&\n                (cast(uint32_t*) addr)[1] == 0 &&\n                (cast(uint32_t*) addr)[2] == 0 &&\n                ntohl( (cast(uint32_t*) addr)[3] ) > 1;\n     }\n \n-    extern (D) int IN6_IS_ADDR_MC_NODELOCAL( in6_addr* addr ) pure\n+    extern (D) int IN6_IS_ADDR_MC_NODELOCAL( const scope in6_addr* addr ) pure\n     {\n         return IN6_IS_ADDR_MULTICAST( addr ) &&\n                ((cast(uint8_t*) addr)[1] & 0xf) == 0x1;\n     }\n \n-    extern (D) int IN6_IS_ADDR_MC_LINKLOCAL( in6_addr* addr ) pure\n+    extern (D) int IN6_IS_ADDR_MC_LINKLOCAL( const scope in6_addr* addr ) pure\n     {\n         return IN6_IS_ADDR_MULTICAST( addr ) &&\n                ((cast(uint8_t*) addr)[1] & 0xf) == 0x2;\n     }\n \n-    extern (D) int IN6_IS_ADDR_MC_SITELOCAL( in6_addr* addr ) pure\n+    extern (D) int IN6_IS_ADDR_MC_SITELOCAL( const scope in6_addr* addr ) pure\n     {\n         return IN6_IS_ADDR_MULTICAST(addr) &&\n                ((cast(uint8_t*) addr)[1] & 0xf) == 0x5;\n     }\n \n-    extern (D) int IN6_IS_ADDR_MC_ORGLOCAL( in6_addr* addr ) pure\n+    extern (D) int IN6_IS_ADDR_MC_ORGLOCAL( const scope in6_addr* addr ) pure\n     {\n         return IN6_IS_ADDR_MULTICAST( addr) &&\n                ((cast(uint8_t*) addr)[1] & 0xf) == 0x8;\n     }\n \n-    extern (D) int IN6_IS_ADDR_MC_GLOBAL( in6_addr* addr ) pure\n+    extern (D) int IN6_IS_ADDR_MC_GLOBAL( const scope in6_addr* addr ) pure\n     {\n         return IN6_IS_ADDR_MULTICAST( addr ) &&\n                ((cast(uint8_t*) addr)[1] & 0xf) == 0xe;\n@@ -670,45 +670,45 @@ else version (Darwin)\n     }\n \n     // macros\n-    extern (D) int IN6_IS_ADDR_UNSPECIFIED( in6_addr* addr ) pure\n+    extern (D) int IN6_IS_ADDR_UNSPECIFIED( const scope in6_addr* addr ) pure\n     {\n         return (cast(uint32_t*) addr)[0] == 0 &&\n                (cast(uint32_t*) addr)[1] == 0 &&\n                (cast(uint32_t*) addr)[2] == 0 &&\n                (cast(uint32_t*) addr)[3] == 0;\n     }\n \n-    extern (D) int IN6_IS_ADDR_LOOPBACK( in6_addr* addr ) pure\n+    extern (D) int IN6_IS_ADDR_LOOPBACK( const scope in6_addr* addr ) pure\n     {\n         return (cast(uint32_t*) addr)[0] == 0  &&\n                (cast(uint32_t*) addr)[1] == 0  &&\n                (cast(uint32_t*) addr)[2] == 0  &&\n                (cast(uint32_t*) addr)[3] == ntohl( 1 );\n     }\n \n-    extern (D) int IN6_IS_ADDR_MULTICAST( in6_addr* addr ) pure\n+    extern (D) int IN6_IS_ADDR_MULTICAST( const scope in6_addr* addr ) pure\n     {\n         return addr.s6_addr[0] == 0xff;\n     }\n \n-    extern (D) int IN6_IS_ADDR_LINKLOCAL( in6_addr* addr ) pure\n+    extern (D) int IN6_IS_ADDR_LINKLOCAL( const scope in6_addr* addr ) pure\n     {\n         return addr.s6_addr[0] == 0xfe && (addr.s6_addr[1] & 0xc0) == 0x80;\n     }\n \n-    extern (D) int IN6_IS_ADDR_SITELOCAL( in6_addr* addr ) pure\n+    extern (D) int IN6_IS_ADDR_SITELOCAL( const scope in6_addr* addr ) pure\n     {\n         return addr.s6_addr[0] == 0xfe && (addr.s6_addr[1] & 0xc0) == 0xc0;\n     }\n \n-    extern (D) int IN6_IS_ADDR_V4MAPPED( in6_addr* addr ) pure\n+    extern (D) int IN6_IS_ADDR_V4MAPPED( const scope in6_addr* addr ) pure\n     {\n         return (cast(uint32_t*) addr)[0] == 0 &&\n                (cast(uint32_t*) addr)[1] == 0 &&\n                (cast(uint32_t*) addr)[2] == ntohl( 0x0000ffff );\n     }\n \n-    extern (D) int IN6_IS_ADDR_V4COMPAT( in6_addr* addr ) pure\n+    extern (D) int IN6_IS_ADDR_V4COMPAT( const scope in6_addr* addr ) pure\n     {\n         return (cast(uint32_t*) addr)[0] == 0 &&\n                (cast(uint32_t*) addr)[1] == 0 &&\n@@ -717,31 +717,31 @@ else version (Darwin)\n                (cast(uint32_t*) addr)[3] != ntohl( 1 );\n     }\n \n-    extern (D) int IN6_IS_ADDR_MC_NODELOCAL( in6_addr* addr ) pure\n+    extern (D) int IN6_IS_ADDR_MC_NODELOCAL( const scope in6_addr* addr ) pure\n     {\n         return IN6_IS_ADDR_MULTICAST( addr ) &&\n                ((cast(uint8_t*) addr)[1] & 0xf) == 0x1;\n     }\n \n-    extern (D) int IN6_IS_ADDR_MC_LINKLOCAL( in6_addr* addr ) pure\n+    extern (D) int IN6_IS_ADDR_MC_LINKLOCAL( const scope in6_addr* addr ) pure\n     {\n         return IN6_IS_ADDR_MULTICAST( addr ) &&\n                ((cast(uint8_t*) addr)[1] & 0xf) == 0x2;\n     }\n \n-    extern (D) int IN6_IS_ADDR_MC_SITELOCAL( in6_addr* addr ) pure\n+    extern (D) int IN6_IS_ADDR_MC_SITELOCAL( const scope in6_addr* addr ) pure\n     {\n         return IN6_IS_ADDR_MULTICAST(addr) &&\n                ((cast(uint8_t*) addr)[1] & 0xf) == 0x5;\n     }\n \n-    extern (D) int IN6_IS_ADDR_MC_ORGLOCAL( in6_addr* addr ) pure\n+    extern (D) int IN6_IS_ADDR_MC_ORGLOCAL( const scope in6_addr* addr ) pure\n     {\n         return IN6_IS_ADDR_MULTICAST( addr) &&\n                ((cast(uint8_t*) addr)[1] & 0xf) == 0x8;\n     }\n \n-    extern (D) int IN6_IS_ADDR_MC_GLOBAL( in6_addr* addr ) pure\n+    extern (D) int IN6_IS_ADDR_MC_GLOBAL( const scope in6_addr* addr ) pure\n     {\n         return IN6_IS_ADDR_MULTICAST( addr ) &&\n                ((cast(uint8_t*) addr)[1] & 0xf) == 0xe;"}, {"sha": "ba7ab8984a9c2a6a01d640594b9dbda89f3db1a0", "filename": "libphobos/libdruntime/core/sys/posix/sched.d", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsched.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsched.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsched.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -65,7 +65,10 @@ version (linux)\n         {\n             int sched_priority;\n             int __reserved1;\n-            timespec[2] __reserved2;\n+            static if (muslRedirTime64)\n+                c_long[2] __reserved2;\n+            else\n+                timespec[2] __reserved2;\n             int __reserved3;\n         }\n     }\n@@ -282,6 +285,7 @@ else version (CRuntime_Musl)\n {\n     int sched_get_priority_max(int);\n     int sched_get_priority_min(int);\n+    pragma(mangle, muslRedirTime64Mangle!(\"sched_rr_get_interval\", \"__sched_rr_get_interval_time64\"))\n     int sched_rr_get_interval(pid_t, timespec*);\n }\n else version (CRuntime_UClibc)"}, {"sha": "4f3b6e951c3393f8a419858af3f2bdf2b23d3eb8", "filename": "libphobos/libdruntime/core/sys/posix/semaphore.d", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsemaphore.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsemaphore.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsemaphore.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -216,6 +216,7 @@ else version (CRuntime_Bionic)\n }\n else version (CRuntime_Musl)\n {\n+    pragma(mangle, muslRedirTime64Mangle!(\"sem_timedwait\", \"__sem_timedwait_time64\"))\n     int sem_timedwait(sem_t*, const scope timespec*);\n }\n else version (CRuntime_UClibc)"}, {"sha": "f722bc4df628f4efa2ad8e12c6c2fef8a6064f80", "filename": "libphobos/libdruntime/core/sys/posix/signal.d", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsignal.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsignal.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsignal.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -2990,6 +2990,7 @@ else version (CRuntime_Bionic)\n else version (CRuntime_Musl)\n {\n     int sigqueue(pid_t, int, const sigval);\n+    pragma(mangle, muslRedirTime64Mangle!(\"sigtimedwait\", \"__sigtimedwait_time64\"))\n     int sigtimedwait(const scope sigset_t*, siginfo_t*, const scope timespec*);\n     int sigwaitinfo(const scope sigset_t*, siginfo_t*);\n }"}, {"sha": "b997f112e4d03d39727b2e9fe24662b4ff06cba5", "filename": "libphobos/libdruntime/core/sys/posix/sys/resource.d", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fresource.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fresource.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fresource.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -547,6 +547,7 @@ else version (CRuntime_Musl)\n     int setrlimit(int, const scope rlimit*);\n     alias getrlimit getrlimit64;\n     alias setrlimit setrlimit64;\n+    pragma(mangle, muslRedirTime64Mangle!(\"getrusage\", \"__getrusage_time64\"))\n     int getrusage(int, rusage*);\n }\n else version (Solaris)"}, {"sha": "dd05d08dde6b5d24ed9354602b017cb503f83dfe", "filename": "libphobos/libdruntime/core/sys/posix/sys/select.d", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fselect.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fselect.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fselect.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -501,7 +501,9 @@ else version (CRuntime_Musl)\n     {\n         fdset.fds_bits[0 .. $] = 0;\n     }\n+    pragma(mangle, muslRedirTime64Mangle!(\"pselect\", \"__pselect_time64\"))\n     int pselect(int, fd_set*, fd_set*, fd_set*, const scope timespec*, const scope sigset_t*);\n+    pragma(mangle, muslRedirTime64Mangle!(\"select\", \"__select_time64\"))\n     int select(int, fd_set*, fd_set*, fd_set*, timeval*);\n }\n else version (CRuntime_UClibc)"}, {"sha": "ee9e5da2feb51fb13820b12a2e5b988a30a43aec", "filename": "libphobos/libdruntime/core/sys/posix/sys/stat.d", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fstat.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fstat.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fstat.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1656,7 +1656,6 @@ else version (CRuntime_Bionic)\n }\n else version (CRuntime_Musl)\n {\n-    alias __mode_t = uint;\n     enum {\n         S_IRUSR    = 0x100, // octal 0400\n         S_IWUSR    = 0x080, // octal 0200\n@@ -1890,8 +1889,11 @@ else version (CRuntime_Bionic)\n }\n else version (CRuntime_Musl)\n {\n+    pragma(mangle, muslRedirTime64Mangle!(\"stat\", \"__stat_time64\"))\n     int stat(const scope char*, stat_t*);\n+    pragma(mangle, muslRedirTime64Mangle!(\"fstat\", \"__fstat_time64\"))\n     int fstat(int, stat_t*);\n+    pragma(mangle, muslRedirTime64Mangle!(\"lstat\", \"__lstat_time64\"))\n     int lstat(const scope char*, stat_t*);\n \n     alias fstat fstat64;"}, {"sha": "dda4caf0bf36aa779f121e52283ab546d820388b", "filename": "libphobos/libdruntime/core/sys/posix/sys/time.d", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Ftime.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Ftime.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Ftime.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -89,7 +89,9 @@ else version (CRuntime_Musl)\n         time_t      tv_sec;\n         suseconds_t tv_usec;\n     }\n+    pragma(mangle, muslRedirTime64Mangle!(\"gettimeofday\", \"__gettimeofday_time64\"))\n     int gettimeofday(timeval*, void*);\n+    pragma(mangle, muslRedirTime64Mangle!(\"utimes\", \"__utimes_time64\"))\n     int utimes(const scope char*, ref const(timeval)[2]);\n }\n else version (Darwin)"}, {"sha": "f49764d1964a089d904c67336a826474200e1916", "filename": "libphobos/libdruntime/core/sys/posix/time.d", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Ftime.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Ftime.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Ftime.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -83,6 +83,7 @@ else version (CRuntime_Bionic)\n }\n else version (CRuntime_Musl)\n {\n+    pragma(mangle, muslRedirTime64Mangle!(\"timegm\", \"__timegm_time64\"))\n     time_t timegm(tm*);\n }\n else version (CRuntime_UClibc)\n@@ -483,15 +484,21 @@ else version (CRuntime_Musl)\n \n     int nanosleep(const scope timespec*, timespec*);\n \n+    pragma(mangle, muslRedirTime64Mangle!(\"clock_getres\", \"__clock_getres_time64\"))\n     int clock_getres(clockid_t, timespec*);\n+    pragma(mangle, muslRedirTime64Mangle!(\"clock_gettime\", \"__clock_gettime64\"))\n     int clock_gettime(clockid_t, timespec*);\n+    pragma(mangle, muslRedirTime64Mangle!(\"clock_settime\", \"__clock_settime64\"))\n     int clock_settime(clockid_t, const scope timespec*);\n+    pragma(mangle, muslRedirTime64Mangle!(\"clock_nanosleep\", \"__clock_nanosleep_time64\"))\n     int clock_nanosleep(clockid_t, int, const scope timespec*, timespec*);\n     int clock_getcpuclockid(pid_t, clockid_t *);\n \n     int timer_create(clockid_t, sigevent*, timer_t*);\n     int timer_delete(timer_t);\n+    pragma(mangle, muslRedirTime64Mangle!(\"timer_gettime\", \"__timer_gettime64\"))\n     int timer_gettime(timer_t, itimerspec*);\n+    pragma(mangle, muslRedirTime64Mangle!(\"timer_settime\", \"__timer_settime64\"))\n     int timer_settime(timer_t, int, const scope itimerspec*, itimerspec*);\n     int timer_getoverrun(timer_t);\n }\n@@ -596,8 +603,11 @@ else version (CRuntime_Bionic)\n else version (CRuntime_Musl)\n {\n     char* asctime_r(const scope tm*, char*);\n+    pragma(mangle, muslRedirTime64Mangle!(\"ctime_r\", \"__ctime64_r\"))\n     char* ctime_r(const scope time_t*, char*);\n+    pragma(mangle, muslRedirTime64Mangle!(\"gmtime_r\", \"__gmtime64_r\"))\n     tm*   gmtime_r(const scope time_t*, tm*);\n+    pragma(mangle, muslRedirTime64Mangle!(\"localtime_r\", \"__localtime64_r\"))\n     tm*   localtime_r(const scope time_t*, tm*);\n }\n else version (CRuntime_UClibc)"}, {"sha": "e7059d7128387a5d6d6b0ad232a2e23aa5fa08bf", "filename": "libphobos/libdruntime/core/sys/posix/utime.d", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Futime.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Futime.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Futime.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -62,6 +62,7 @@ else version (CRuntime_Musl)\n         time_t  modtime;\n     }\n \n+    pragma(mangle, muslRedirTime64Mangle!(\"utime\", \"__utime64\"))\n     int utime(const scope char*, const scope utimbuf*);\n }\n else version (Darwin)"}, {"sha": "c10a9175b4d1c78481577870c83f8ac41294bc12", "filename": "libphobos/libdruntime/core/sys/windows/stacktrace.d", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fstacktrace.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fstacktrace.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fstacktrace.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -30,6 +30,7 @@ extern(Windows) DWORD GetEnvironmentVariableA(LPCSTR lpName, LPSTR pBuffer, DWOR\n extern(Windows) alias USHORT function(ULONG FramesToSkip, ULONG FramesToCapture, PVOID *BackTrace, PULONG BackTraceHash) @nogc RtlCaptureStackBackTraceFunc;\n \n private __gshared RtlCaptureStackBackTraceFunc RtlCaptureStackBackTrace;\n+private __gshared CRITICAL_SECTION mutex; // cannot use core.sync.mutex.Mutex unfortunately (cyclic dependency...)\n private __gshared immutable bool initialized;\n \n \n@@ -63,11 +64,11 @@ public:\n \n             skip += INTERNALFRAMES;\n         }\n-        if ( initialized )\n+        if (initialized)\n             m_trace = trace(tracebuf[], skip, context);\n     }\n \n-    int opApply( scope int delegate(ref const(char[])) dg ) const\n+    override int opApply( scope int delegate(ref const(char[])) dg ) const\n     {\n         return opApply( (ref size_t, ref const(char[]) buf)\n                         {\n@@ -76,7 +77,7 @@ public:\n     }\n \n \n-    int opApply( scope int delegate(ref size_t, ref const(char[])) dg ) const\n+    override int opApply( scope int delegate(ref size_t, ref const(char[])) dg ) const\n     {\n         int result;\n         foreach ( i, e; resolve(m_trace) )\n@@ -118,10 +119,10 @@ public:\n     /// ditto\n     static ulong[] trace(ulong[] buffer, size_t skip = 0, CONTEXT* context = null) @nogc\n     {\n-        synchronized( typeid(StackTrace) )\n-        {\n-            return traceNoSync(buffer, skip, context);\n-        }\n+        EnterCriticalSection(&mutex);\n+        scope(exit) LeaveCriticalSection(&mutex);\n+\n+        return traceNoSync(buffer, skip, context);\n     }\n \n     /**\n@@ -133,10 +134,15 @@ public:\n      */\n     @trusted static char[][] resolve(const(ulong)[] addresses)\n     {\n-        synchronized( typeid(StackTrace) )\n-        {\n-            return resolveNoSync(addresses);\n-        }\n+        // FIXME: make @nogc to avoid having to disable resolution within finalizers\n+        import core.memory : GC;\n+        if (GC.inFinalizer)\n+            return null;\n+\n+        EnterCriticalSection(&mutex);\n+        scope(exit) LeaveCriticalSection(&mutex);\n+\n+        return resolveNoSync(addresses);\n     }\n \n private:\n@@ -421,5 +427,6 @@ shared static this()\n \n     dbghelp.SymRegisterCallback64(hProcess, &FixupDebugHeader, 0);\n \n+    InitializeCriticalSection(&mutex);\n     initialized = true;\n }"}, {"sha": "bbb6e9a7b41eb5981fd9170a8a10ce5dd8956950", "filename": "libphobos/libdruntime/core/sys/windows/winbase.d", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fwinbase.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fwinbase.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fwinbase.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -38,6 +38,7 @@ import core.sys.windows.basetyps, core.sys.windows.w32api, core.sys.windows.winn\n // FIXME:\n //alias void va_list;\n import core.stdc.stdarg : va_list;\n+import core.stdc.string : memset, memcpy, memmove;\n \n \n // COMMPROP structure, used by GetCommProperties()\n@@ -1713,23 +1714,15 @@ extern (Windows) nothrow @nogc {\n     BOOL CopyFileExA(LPCSTR, LPCSTR, LPPROGRESS_ROUTINE, LPVOID, LPBOOL, DWORD);\n     BOOL CopyFileExW(LPCWSTR, LPCWSTR, LPPROGRESS_ROUTINE, LPVOID, LPBOOL, DWORD);\n \n-    /+ FIXME\n-    alias memmove RtlMoveMemory;\n-    alias memcpy RtlCopyMemory;\n+    alias RtlMoveMemory = memmove;\n+    alias RtlCopyMemory = memcpy;\n+    pragma(inline, true) void RtlFillMemory(PVOID Destination, SIZE_T Length, BYTE Fill) { memset(Destination, Fill, Length); }\n+    pragma(inline, true) void RtlZeroMemory(PVOID Destination, SIZE_T Length) { memset(Destination, 0, Length); }\n+    alias MoveMemory = RtlMoveMemory;\n+    alias CopyMemory = RtlCopyMemory;\n+    alias FillMemory = RtlFillMemory;\n+    alias ZeroMemory = RtlZeroMemory;\n \n-    void RtlFillMemory(PVOID dest, SIZE_T len, BYTE fill) {\n-        memset(dest, fill, len);\n-    }\n-\n-    void RtlZeroMemory(PVOID dest, SIZE_T len) {\n-        RtlFillMemory(dest, len, 0);\n-    }\n-\n-    alias RtlMoveMemory MoveMemory;\n-    alias RtlCopyMemory CopyMemory;\n-    alias RtlFillMemory FillMemory;\n-    alias RtlZeroMemory ZeroMemory;\n-    +/\n     BOOL CreateDirectoryA(LPCSTR, LPSECURITY_ATTRIBUTES);\n     BOOL CreateDirectoryW(LPCWSTR, LPSECURITY_ATTRIBUTES);\n     BOOL CreateDirectoryExA(LPCSTR, LPCSTR, LPSECURITY_ATTRIBUTES);"}, {"sha": "4590ff1c0525811c2b52ec4406217dca6510629f", "filename": "libphobos/libdruntime/core/thread/fiber.d", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fthread%2Ffiber.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fthread%2Ffiber.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fthread%2Ffiber.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -19,6 +19,8 @@ import core.thread.threadgroup;\n import core.thread.types;\n import core.thread.context;\n \n+import core.memory : pageSize;\n+\n ///////////////////////////////////////////////////////////////////////////////\n // Fiber Platform Detection\n ///////////////////////////////////////////////////////////////////////////////\n@@ -600,7 +602,7 @@ class Fiber\n         version (X86_64)\n             // libunwind on macOS 11 now requires more stack space than 16k, so\n             // default to a larger stack size. This is only applied to X86 as\n-            // the PAGESIZE is still 4k, however on AArch64 it is 16k.\n+            // the pageSize is still 4k, however on AArch64 it is 16k.\n             enum defaultStackPages = 8;\n         else\n             enum defaultStackPages = 4;\n@@ -623,8 +625,8 @@ class Fiber\n      * In:\n      *  fn must not be null.\n      */\n-    this( void function() fn, size_t sz = PAGESIZE * defaultStackPages,\n-          size_t guardPageSize = PAGESIZE ) nothrow\n+    this( void function() fn, size_t sz = pageSize * defaultStackPages,\n+          size_t guardPageSize = pageSize ) nothrow\n     in\n     {\n         assert( fn );\n@@ -651,8 +653,8 @@ class Fiber\n      * In:\n      *  dg must not be null.\n      */\n-    this( void delegate() dg, size_t sz = PAGESIZE * defaultStackPages,\n-          size_t guardPageSize = PAGESIZE ) nothrow\n+    this( void delegate() dg, size_t sz = pageSize * defaultStackPages,\n+          size_t guardPageSize = pageSize ) nothrow\n     {\n         allocStack( sz, guardPageSize );\n         reset( cast(void delegate() const) dg );\n@@ -962,9 +964,9 @@ private:\n     }\n     do\n     {\n-        // adjust alloc size to a multiple of PAGESIZE\n-        sz += PAGESIZE - 1;\n-        sz -= sz % PAGESIZE;\n+        // adjust alloc size to a multiple of pageSize\n+        sz += pageSize - 1;\n+        sz -= sz % pageSize;\n \n         // NOTE: This instance of Thread.Context is dynamic so Fiber objects\n         //       can be collected by the GC so long as no user level references"}, {"sha": "066f39e39c77e9462cc9f45307bf8c7f140c7dd1", "filename": "libphobos/libdruntime/core/thread/osthread.d", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fthread%2Fosthread.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fthread%2Fosthread.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fthread%2Fosthread.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -19,7 +19,7 @@ import core.thread.threadbase;\n import core.thread.context;\n import core.thread.types;\n import core.atomic;\n-import core.memory : GC;\n+import core.memory : GC, pageSize;\n import core.time;\n import core.exception : onOutOfMemoryError;\n import core.internal.traits : externDFunc;\n@@ -1115,7 +1115,7 @@ unittest\n \n unittest\n {\n-    // use >PAGESIZE to avoid stack overflow (e.g. in an syscall)\n+    // use >pageSize to avoid stack overflow (e.g. in an syscall)\n     auto thr = new Thread(function{}, 4096 + 1).start();\n     thr.join();\n }\n@@ -2889,8 +2889,8 @@ private size_t adjustStackSize(size_t sz) nothrow @nogc\n         }\n     }\n \n-    // stack size must be a multiple of PAGESIZE\n-    sz = ((sz + PAGESIZE - 1) & ~(PAGESIZE - 1));\n+    // stack size must be a multiple of pageSize\n+    sz = ((sz + pageSize - 1) & ~(pageSize - 1));\n \n     return sz;\n }"}, {"sha": "eb84ad74b48142c2f2c95458d62f2001e1c7c7ac", "filename": "libphobos/libdruntime/core/thread/types.d", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fthread%2Ftypes.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fcore%2Fthread%2Ftypes.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fthread%2Ftypes.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -47,31 +47,15 @@ else\n \n package\n {\n-    static immutable size_t PAGESIZE;\n     version (Posix) static immutable size_t PTHREAD_STACK_MIN;\n }\n \n shared static this()\n {\n-    version (Windows)\n-    {\n-        import core.sys.windows.winbase;\n-\n-        SYSTEM_INFO info;\n-        GetSystemInfo(&info);\n-\n-        PAGESIZE = info.dwPageSize;\n-        assert(PAGESIZE < int.max);\n-    }\n-    else version (Posix)\n+    version (Posix)\n     {\n         import core.sys.posix.unistd;\n \n-        PAGESIZE = cast(size_t)sysconf(_SC_PAGESIZE);\n         PTHREAD_STACK_MIN = cast(size_t)sysconf(_SC_THREAD_STACK_MIN);\n     }\n-    else\n-    {\n-        static assert(0, \"unimplemented\");\n-    }\n }"}, {"sha": "a77788bec20deb1b141fca2108879fdd07b0a914", "filename": "libphobos/libdruntime/object.d", "status": "modified", "additions": 8, "deletions": 99, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fobject.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Flibdruntime%2Fobject.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fobject.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -246,7 +246,7 @@ class Object\n      * }\n      * ---\n      */\n-    deprecated static Object factory(string classname)\n+    static Object factory(string classname)\n     {\n         auto ci = TypeInfo_Class.find(classname);\n         if (ci)\n@@ -256,7 +256,7 @@ class Object\n         return null;\n     }\n \n-    deprecated @system unittest\n+    @system unittest\n     {\n         Object valid_obj = Object.factory(\"object.Object\");\n         Object invalid_obj = Object.factory(\"object.__this_class_doesnt_exist__\");\n@@ -1417,7 +1417,7 @@ class TypeInfo_Function : TypeInfo\n        int func(int a, int b);\n     }\n \n-    alias functionTypes = typeof(__traits(getVirtualFunctions, C, \"func\"));\n+    alias functionTypes = typeof(__traits(getVirtualMethods, C, \"func\"));\n     assert(typeid(functionTypes[0]).toString() == \"void function()\");\n     assert(typeid(functionTypes[1]).toString() == \"void function(int)\");\n     assert(typeid(functionTypes[2]).toString() == \"int function(int, int)\");\n@@ -1431,7 +1431,7 @@ class TypeInfo_Function : TypeInfo\n        void func(int a);\n     }\n \n-    alias functionTypes = typeof(__traits(getVirtualFunctions, C, \"func\"));\n+    alias functionTypes = typeof(__traits(getVirtualMethods, C, \"func\"));\n \n     Object obj = typeid(functionTypes[0]);\n     assert(obj.opEquals(typeid(functionTypes[0])));\n@@ -2927,25 +2927,6 @@ void clear(Value, Key)(Value[Key]* aa)\n     assert(\"k1\" !in aa);\n }\n \n-// Issue 20559\n-@system unittest\n-{\n-    static class Foo\n-    {\n-        int[string] aa;\n-        alias aa this;\n-    }\n-\n-    auto v = new Foo();\n-    v[\"Hello World\"] = 42;\n-    v.clear;\n-    assert(\"Hello World\" !in v);\n-\n-    // Test for T*\n-    static assert(!__traits(compiles, (&v).clear));\n-    static assert( __traits(compiles, (*(&v)).clear));\n-}\n-\n /***********************************\n  * Reorganizes the associative array in place so that lookups are more\n  * efficient.\n@@ -4278,44 +4259,6 @@ void destroy(bool initialize = true, T)(T obj) if (is(T == interface))\n     destroy!true(new C());\n }\n \n-@system unittest\n-{\n-    // class with an `alias this`\n-    class A\n-    {\n-        static int dtorCount;\n-        ~this()\n-        {\n-            dtorCount++;\n-        }\n-    }\n-\n-    class B\n-    {\n-        A a;\n-        alias a this;\n-        this()\n-        {\n-            a = new A;\n-        }\n-        static int dtorCount;\n-        ~this()\n-        {\n-            dtorCount++;\n-        }\n-    }\n-    auto b = new B;\n-    assert(A.dtorCount == 0);\n-    assert(B.dtorCount == 0);\n-    destroy(b);\n-    assert(A.dtorCount == 0);\n-    assert(B.dtorCount == 1);\n-\n-    auto a = new A;\n-    destroy(a);\n-    assert(A.dtorCount == 1);\n-}\n-\n @system unittest\n {\n     interface I { }\n@@ -4529,43 +4472,6 @@ if (__traits(isStaticArray, T))\n     }\n }\n \n-// https://issues.dlang.org/show_bug.cgi?id=19218\n-@system unittest\n-{\n-    static struct S\n-    {\n-        static dtorCount = 0;\n-        ~this() { ++dtorCount; }\n-    }\n-\n-    static interface I\n-    {\n-        ref S[3] getArray();\n-        alias getArray this;\n-    }\n-\n-    static class C : I\n-    {\n-        static dtorCount = 0;\n-        ~this() { ++dtorCount; }\n-\n-        S[3] a;\n-        alias a this;\n-\n-        ref S[3] getArray() { return a; }\n-    }\n-\n-    C c = new C();\n-    destroy(c);\n-    assert(S.dtorCount == 3);\n-    assert(C.dtorCount == 1);\n-\n-    I i = new C();\n-    destroy(i);\n-    assert(S.dtorCount == 6);\n-    assert(C.dtorCount == 2);\n-}\n-\n /// ditto\n void destroy(bool initialize = true, T)(ref T obj)\n     if (!is(T == struct) && !is(T == interface) && !is(T == class) && !__traits(isStaticArray, T))\n@@ -4622,7 +4528,8 @@ they are only intended to be instantiated by the compiler, not the user.\n public import core.internal.entrypoint : _d_cmain;\n \n public import core.internal.array.appending : _d_arrayappendT;\n-public import core.internal.array.appending : _d_arrayappendTTrace;\n+version (D_ProfileGC)\n+    public import core.internal.array.appending : _d_arrayappendTTrace;\n public import core.internal.array.appending : _d_arrayappendcTXImpl;\n public import core.internal.array.comparison : __cmp;\n public import core.internal.array.equality : __equals;\n@@ -4648,6 +4555,8 @@ public import core.internal.switch_: __switch_error;\n \n public import core.lifetime : _d_delstructImpl;\n public import core.lifetime : _d_newThrowable;\n+public import core.lifetime : _d_newclassT;\n+public import core.lifetime : _d_newclassTTrace;\n \n public @trusted @nogc nothrow pure extern (C) void _d_delThrowable(scope Throwable);\n "}, {"sha": "a21913975993004450bd82bf6f4ddfa16809a1fd", "filename": "libphobos/src/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Fsrc%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Fsrc%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2FMERGE?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1,4 +1,4 @@\n-e5a521ab2bddfa0a42ecf371910ffe6a2fe0a03a\n+454dff14dcbd005f9550302c5836ef8e06ab663a\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/phobos repository."}, {"sha": "82360763adc3d969291abd7aef9f581668261c70", "filename": "libphobos/src/std/algorithm/iteration.d", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fiteration.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fiteration.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fiteration.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -2969,10 +2969,24 @@ iterated from the back to the front, the separator will still be consumed from\n front to back, even if it is a bidirectional range too.\n  */\n auto joiner(RoR, Separator)(RoR r, Separator sep)\n-if (isInputRange!RoR && isInputRange!(ElementType!RoR)\n-        && isForwardRange!Separator\n-        && is(ElementType!Separator : ElementType!(ElementType!RoR)))\n {\n+    static assert(isInputRange!RoR, \"The type of RoR '\", RoR.stringof\n+            , \" must be an InputRange (isInputRange!\", RoR.stringof, \").\");\n+    static assert(isInputRange!(ElementType!RoR), \"The ElementyType of RoR '\"\n+            , ElementType!(RoR).stringof, \"' must be an InputRange \"\n+            , \"(isInputRange!(ElementType!(\", RoR.stringof , \"))).\");\n+    static assert(isForwardRange!Separator, \"The type of the Seperator '\"\n+            , Seperator.stringof, \"' must be a ForwardRange (isForwardRange!(\"\n+            , Seperator.stringof, \")).\");\n+    static assert(is(ElementType!Separator : ElementType!(ElementType!RoR))\n+            , \"The type of the elements of the separator range does not match \"\n+            , \"the type of the elements that are joined. Separator type '\"\n+            , ElementType!(Separator).stringof, \"' is not implicitly\"\n+            , \"convertible to range element type '\"\n+            , ElementType!(ElementType!RoR).stringof, \"' (is(ElementType!\"\n+            , Separator.stringof, \" : ElementType!(ElementType!\", RoR.stringof\n+            , \"))).\");\n+\n     static struct Result\n     {\n         private RoR _items;"}, {"sha": "71bd1d90ceb49345f2e18fcb0818ce389e54c37c", "filename": "libphobos/src/std/algorithm/package.d", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fpackage.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fpackage.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fpackage.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -103,6 +103,7 @@ $(TR\n         $(SUBREF sorting, multiSort)\n         $(SUBREF sorting, nextEvenPermutation)\n         $(SUBREF sorting, nextPermutation)\n+        $(SUBREF sorting, nthPermutation)\n         $(SUBREF sorting, partialSort)\n         $(SUBREF sorting, partition)\n         $(SUBREF sorting, partition3)"}, {"sha": "c5b085d1037f232375dcc5abaf7060dbd0a5f26b", "filename": "libphobos/src/std/algorithm/sorting.d", "status": "modified", "additions": 59, "deletions": 20, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fsorting.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fsorting.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fsorting.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1922,36 +1922,55 @@ See_Also:\n     $(REF binaryFun, std,functional)\n */\n SortedRange!(Range, less)\n-sort(alias less = \"a < b\", SwapStrategy ss = SwapStrategy.unstable,\n-        Range)(Range r)\n-if (((ss == SwapStrategy.unstable && (hasSwappableElements!Range ||\n-    hasAssignableElements!Range)) ||\n-    (ss != SwapStrategy.unstable && hasAssignableElements!Range)) &&\n-    isRandomAccessRange!Range &&\n-    hasSlicing!Range &&\n-    hasLength!Range)\n+sort(alias less = \"a < b\", SwapStrategy ss = SwapStrategy.unstable, Range)\n+(Range r)\n     /+ Unstable sorting uses the quicksort algorithm, which uses swapAt,\n        which either uses swap(...), requiring swappable elements, or just\n        swaps using assignment.\n        Stable sorting uses TimSort, which needs to copy elements into a buffer,\n        requiring assignable elements. +/\n {\n     import std.range : assumeSorted;\n-    alias lessFun = binaryFun!(less);\n-    alias LessRet = typeof(lessFun(r.front, r.front));    // instantiate lessFun\n-    static if (is(LessRet == bool))\n+    static if (ss == SwapStrategy.unstable)\n     {\n-        static if (ss == SwapStrategy.unstable)\n-            quickSortImpl!(lessFun)(r, r.length);\n-        else //use Tim Sort for semistable & stable\n-            TimSortImpl!(lessFun, Range).sort(r, null);\n-\n-        assert(isSorted!lessFun(r), \"Failed to sort range of type \" ~ Range.stringof);\n+        static assert(hasSwappableElements!Range || hasAssignableElements!Range,\n+                  \"When using SwapStrategy.unstable, the passed Range '\"\n+                ~ Range.stringof ~ \"' must\"\n+                ~ \" either fulfill hasSwappableElements, or\"\n+                ~ \" hasAssignableElements, both were not the case\");\n     }\n     else\n     {\n-        static assert(false, \"Invalid predicate passed to sort: \" ~ less.stringof);\n+        static assert(hasAssignableElements!Range, \"When using a SwapStrategy\"\n+                ~ \" != unstable, the\"\n+                ~ \" passed Range '\" ~ Range.stringof ~ \"' must fulfill\"\n+                ~ \" hasAssignableElements, which it did not\");\n     }\n+\n+    static assert(isRandomAccessRange!Range, \"The passed Range '\"\n+            ~ Range.stringof ~ \"' must be a Random AccessRange \"\n+            ~ \"(isRandomAccessRange)\");\n+\n+    static assert(hasSlicing!Range, \"The passed Range '\"\n+            ~ Range.stringof ~ \"' must allow Slicing (hasSlicing)\");\n+\n+    static assert(hasLength!Range, \"The passed Range '\"\n+            ~ Range.stringof ~ \"' must have a length (hasLength)\");\n+\n+    alias lessFun = binaryFun!(less);\n+    alias LessRet = typeof(lessFun(r.front, r.front));    // instantiate lessFun\n+\n+    static assert(is(LessRet == bool), \"The return type of the template\"\n+            ~ \" argument 'less' when used with the binaryFun!less template\"\n+            ~ \" must be a bool. This is not the case, the returned type is '\"\n+            ~ LessRet.stringof ~ \"'\");\n+\n+    static if (ss == SwapStrategy.unstable)\n+        quickSortImpl!(lessFun)(r, r.length);\n+    else //use Tim Sort for semistable & stable\n+        TimSortImpl!(lessFun, Range).sort(r, null);\n+\n+    assert(isSorted!lessFun(r), \"Failed to sort range of type \" ~ Range.stringof);\n     return assumeSorted!less(r);\n }\n \n@@ -2599,8 +2618,16 @@ private template TimSortImpl(alias pred, R)\n             //Test for overflow\n             if (newSize < minCapacity) newSize = minCapacity;\n \n-            if (__ctfe) temp.length = newSize;\n-            else temp = () @trusted { return uninitializedArray!(T[])(newSize); }();\n+            // can't use `temp.length` if there's no default constructor\n+            static if (__traits(compiles, { T defaultConstructed; cast(void) defaultConstructed; }))\n+            {\n+                if (__ctfe) temp.length = newSize;\n+                else temp = () @trusted { return uninitializedArray!(T[])(newSize); }();\n+            }\n+            else\n+            {\n+                temp = () @trusted { return uninitializedArray!(T[])(newSize); }();\n+            }\n         }\n         return temp;\n     }\n@@ -3037,6 +3064,18 @@ private template TimSortImpl(alias pred, R)\n     sort!(cmp, SwapStrategy.stable)(makeArray(minMerge + 5));\n }\n \n+// https://issues.dlang.org/show_bug.cgi?id=23668\n+@safe unittest\n+{\n+    static struct S\n+    {\n+        int opCmp(const S) const { return 1; }\n+        @disable this();\n+    }\n+    S[] array;\n+    array.sort!(\"a < b\", SwapStrategy.stable);\n+}\n+\n // schwartzSort\n /**\n Alternative sorting method that should be used when comparing keys involves an"}, {"sha": "4584dcc92ddb24b721808475a071fe28c03f89f2", "filename": "libphobos/src/std/array.d", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Fsrc%2Fstd%2Farray.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Fsrc%2Fstd%2Farray.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Farray.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -170,7 +170,7 @@ if (isIterable!Range && !isAutodecodableString!Range && !isInfinite!Range)\n \n /// ditto\n ForeachType!(typeof((*Range).init))[] array(Range)(Range r)\n-if (is(Range : U*, U) && isIterable!U && !isAutodecodableString!Range && !isInfinite!Range)\n+if (is(Range == U*, U) && isIterable!U && !isAutodecodableString!Range && !isInfinite!Range)\n {\n     return array(*r);\n }\n@@ -2294,22 +2294,6 @@ if (isInputRange!RoR &&\n     }\n }\n \n-// https://issues.dlang.org/show_bug.cgi?id=10895\n-@safe unittest\n-{\n-    static class A\n-    {\n-        string name;\n-        alias name this;\n-        this(string name) { this.name = name; }\n-    }\n-    auto a = [new A(`foo`)];\n-    assert(a[0].length == 3);\n-    auto temp = join(a, \" \");\n-    assert(a[0].length == 3);\n-    assert(temp.length == 3);\n-}\n-\n // https://issues.dlang.org/show_bug.cgi?id=14230\n @safe unittest\n {"}, {"sha": "b84a6762d195468cef8e8093941dd85d179f3669", "filename": "libphobos/src/std/bitmanip.d", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Fsrc%2Fstd%2Fbitmanip.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Fsrc%2Fstd%2Fbitmanip.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fbitmanip.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -89,22 +89,21 @@ private template createAccessors(\n     }\n     else\n     {\n-        enum ulong\n-            maskAllElse = ((~0uL) >> (64 - len)) << offset,\n-            signBitCheck = 1uL << (len - 1);\n+        enum ulong maskAllElse = ((~0uL) >> (64 - len)) << offset;\n+        enum TSize = 8 * T.sizeof;\n+        enum SignShift = TSize - len;\n \n         static if (T.min < 0)\n         {\n             enum long minVal = -(1uL << (len - 1));\n             enum ulong maxVal = (1uL << (len - 1)) - 1;\n-            alias UT = Unsigned!(T);\n-            enum UT extendSign = cast(UT)~((~0uL) >> (64 - len));\n+            enum RightShiftOp = \">>=\";\n         }\n         else\n         {\n             enum ulong minVal = 0;\n             enum ulong maxVal = (~0uL) >> (64 - len);\n-            enum extendSign = 0;\n+            enum RightShiftOp = \">>>=\";\n         }\n \n         static if (is(T == bool))\n@@ -121,15 +120,11 @@ private template createAccessors(\n         else\n         {\n             // getter\n-            enum createAccessors = \"@property \"~T.stringof~\" \"~name~\"() @safe pure nothrow @nogc const { auto result = \"\n-                ~\"(\"~store~\" & \"\n-                ~ myToString(maskAllElse) ~ \") >>\"\n-                ~ myToString(offset) ~ \";\"\n-                ~ (T.min < 0\n-                   ? \"if (result >= \" ~ myToString(signBitCheck)\n-                   ~ \") result |= \" ~ myToString(extendSign) ~ \";\"\n-                   : \"\")\n-                ~ \" return cast(\"~T.stringof~\") result;}\\n\"\n+            enum createAccessors = \"@property \"~T.stringof~\" \"~name~\"() @safe pure nothrow @nogc const {\"\n+                ~ \"auto result = cast(\"~T.stringof~\") (\" ~ store ~ \" >>\" ~ myToString(offset) ~ \");\"\n+                ~ \"result <<= \" ~ myToString(SignShift) ~ \";\"\n+                ~ \"result \" ~ RightShiftOp ~ myToString(SignShift) ~ \";\"\n+                ~ \" return result;}\\n\"\n             // setter\n                 ~\"@property void \"~name~\"(\"~T.stringof~\" v) @safe pure nothrow @nogc { \"\n                 ~\"assert(v >= \"~name~`_min, \"Value is smaller than the minimum value of bitfield '`~name~`'\"); `"}, {"sha": "7fe52ba55ec7b8b676cd55511d36f834724967e4", "filename": "libphobos/src/std/concurrency.d", "status": "modified", "additions": 78, "deletions": 77, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Fsrc%2Fstd%2Fconcurrency.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Fsrc%2Fstd%2Fconcurrency.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fconcurrency.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -46,7 +46,7 @@\n  *\n  * This is a low-level messaging API upon which more structured or restrictive\n  * APIs may be built.  The general idea is that every messageable entity is\n- * represented by a common handle type called a Tid, which allows messages to\n+ * represented by a common handle type called a `Tid`, which allows messages to\n  * be sent to logical threads that are executing in both the current process\n  * and in external processes using the same interface.  This is an important\n  * aspect of scalability because it allows the components of a program to be\n@@ -55,11 +55,11 @@\n  *\n  * A logical thread is an execution context that has its own stack and which\n  * runs asynchronously to other logical threads.  These may be preemptively\n- * scheduled kernel threads, fibers (cooperative user-space threads), or some\n- * other concept with similar behavior.\n+ * scheduled kernel threads, $(MREF_ALTTEXT fibers, core, thread, fiber)\n+ * (cooperative user-space threads), or some other concept with similar behavior.\n  *\n  * The type of concurrency used when logical threads are created is determined\n- * by the Scheduler selected at initialization time.  The default behavior is\n+ * by the $(LREF Scheduler) selected at initialization time.  The default behavior is\n  * currently to create a new kernel thread per call to spawn, but other\n  * schedulers are available that multiplex fibers across the main thread or\n  * use some combination of the two approaches.\n@@ -274,7 +274,7 @@ static ~this()\n // Exceptions\n \n /**\n- * Thrown on calls to `receiveOnly` if a message other than the type\n+ * Thrown on calls to $(LREF receiveOnly) if a message other than the type\n  * the receiving thread expected is sent.\n  */\n class MessageMismatch : Exception\n@@ -287,7 +287,7 @@ class MessageMismatch : Exception\n }\n \n /**\n- * Thrown on calls to `receive` if the thread that spawned the receiving\n+ * Thrown on calls to $(LREF receive) if the thread that spawned the receiving\n  * thread has terminated and no more messages exist.\n  */\n class OwnerTerminated : Exception\n@@ -354,7 +354,7 @@ class MailboxFull : Exception\n }\n \n /**\n- * Thrown when a Tid is missing, e.g. when `ownerTid` doesn't\n+ * Thrown when a `Tid` is missing, e.g. when $(LREF ownerTid) doesn't\n  * find an owner thread.\n  */\n class TidMissingException : Exception\n@@ -384,11 +384,11 @@ private:\n public:\n \n     /**\n-     * Generate a convenient string for identifying this Tid.  This is only\n-     * useful to see if Tid's that are currently executing are the same or\n+     * Generate a convenient string for identifying this `Tid`.  This is only\n+     * useful to see if `Tid`'s that are currently executing are the same or\n      * different, e.g. for logging and debugging.  It is potentially possible\n-     * that a Tid executed in the future will have the same toString() output\n-     * as another Tid that has already terminated.\n+     * that a `Tid` executed in the future will have the same `toString()` output\n+     * as another `Tid` that has already terminated.\n      */\n     void toString(W)(ref W w) const\n     {\n@@ -420,7 +420,7 @@ public:\n }\n \n /**\n- * Returns: The $(LREF Tid) of the caller's thread.\n+ * Returns: The `Tid` of the caller's thread.\n  */\n @property Tid thisTid() @safe\n {\n@@ -437,7 +437,7 @@ public:\n }\n \n /**\n- * Return the Tid of the thread which spawned the caller's thread.\n+ * Return the `Tid` of the thread which spawned the caller's thread.\n  *\n  * Throws: A `TidMissingException` exception if\n  * there is no owner thread.\n@@ -493,7 +493,7 @@ private template isSpawnable(F, T...)\n }\n \n /**\n- * Starts fn(args) in a new logical thread.\n+ * Starts `fn(args)` in a new logical thread.\n  *\n  * Executes the supplied function in a new logical thread represented by\n  * `Tid`.  The calling thread is designated as the owner of the new thread.\n@@ -506,7 +506,7 @@ private template isSpawnable(F, T...)\n  *  args = Arguments to the function.\n  *\n  * Returns:\n- *  A Tid representing the new logical thread.\n+ *  A `Tid` representing the new logical thread.\n  *\n  * Notes:\n  *  `args` must not have unshared aliasing.  In other words, all arguments\n@@ -573,16 +573,16 @@ if (isSpawnable!(F, T))\n }\n \n /**\n- * Starts fn(args) in a logical thread and will receive a LinkTerminated\n+ * Starts `fn(args)` in a logical thread and will receive a `LinkTerminated`\n  * message when the operation terminates.\n  *\n  * Executes the supplied function in a new logical thread represented by\n- * Tid.  This new thread is linked to the calling thread so that if either\n- * it or the calling thread terminates a LinkTerminated message will be sent\n- * to the other, causing a LinkTerminated exception to be thrown on receive().\n- * The owner relationship from spawn() is preserved as well, so if the link\n+ * `Tid`.  This new thread is linked to the calling thread so that if either\n+ * it or the calling thread terminates a `LinkTerminated` message will be sent\n+ * to the other, causing a `LinkTerminated` exception to be thrown on `receive()`.\n+ * The owner relationship from `spawn()` is preserved as well, so if the link\n  * between threads is broken, owner termination will still result in an\n- * OwnerTerminated exception to be thrown on receive().\n+ * `OwnerTerminated` exception to be thrown on `receive()`.\n  *\n  * Params:\n  *  fn   = The function to execute.\n@@ -1021,7 +1021,7 @@ do\n enum OnCrowding\n {\n     block, /// Wait until room is available.\n-    throwException, /// Throw a MailboxFull exception.\n+    throwException, /// Throw a $(LREF MailboxFull) exception.\n     ignore /// Abort the send and return.\n }\n \n@@ -1178,13 +1178,13 @@ bool unregister(string name)\n }\n \n /**\n- * Gets the Tid associated with name.\n+ * Gets the `Tid` associated with name.\n  *\n  * Params:\n  *  name = The name to locate within the registry.\n  *\n  * Returns:\n- *  The associated Tid or Tid.init if name is not registered.\n+ *  The associated `Tid` or `Tid.init` if name is not registered.\n  */\n Tid locate(string name)\n {\n@@ -1199,7 +1199,7 @@ Tid locate(string name)\n /**\n  * Encapsulates all implementation-level data needed for scheduling.\n  *\n- * When defining a Scheduler, an instance of this struct must be associated\n+ * When defining a $(LREF Scheduler), an instance of this struct must be associated\n  * with each logical thread.  It contains all implementation-level information\n  * needed by the internal API.\n  */\n@@ -1210,11 +1210,11 @@ struct ThreadInfo\n     Tid owner;\n \n     /**\n-     * Gets a thread-local instance of ThreadInfo.\n+     * Gets a thread-local instance of `ThreadInfo`.\n      *\n-     * Gets a thread-local instance of ThreadInfo, which should be used as the\n+     * Gets a thread-local instance of `ThreadInfo`, which should be used as the\n      * default instance when info is requested for a thread not created by the\n-     * Scheduler.\n+     * `Scheduler`.\n      */\n     static @property ref thisInfo() nothrow\n     {\n@@ -1253,15 +1253,15 @@ struct ThreadInfo\n }\n \n /**\n- * A Scheduler controls how threading is performed by spawn.\n+ * A `Scheduler` controls how threading is performed by spawn.\n  *\n- * Implementing a Scheduler allows the concurrency mechanism used by this\n+ * Implementing a `Scheduler` allows the concurrency mechanism used by this\n  * module to be customized according to different needs.  By default, a call\n  * to spawn will create a new kernel thread that executes the supplied routine\n- * and terminates when finished.  But it is possible to create Schedulers that\n- * reuse threads, that multiplex Fibers (coroutines) across a single thread,\n- * or any number of other approaches.  By making the choice of Scheduler a\n- * user-level option, std.concurrency may be used for far more types of\n+ * and terminates when finished.  But it is possible to create `Scheduler`s that\n+ * reuse threads, that multiplex `Fiber`s (coroutines) across a single thread,\n+ * or any number of other approaches.  By making the choice of `Scheduler` a\n+ * user-level option, `std.concurrency` may be used for far more types of\n  * application than if this behavior were predefined.\n  *\n  * Example:\n@@ -1280,25 +1280,25 @@ struct ThreadInfo\n  * ---\n  *\n  * Some schedulers have a dispatching loop that must run if they are to work\n- * properly, so for the sake of consistency, when using a scheduler, start()\n- * must be called within main().  This yields control to the scheduler and\n+ * properly, so for the sake of consistency, when using a scheduler, `start()`\n+ * must be called within `main()`.  This yields control to the scheduler and\n  * will ensure that any spawned threads are executed in an expected manner.\n  */\n interface Scheduler\n {\n     /**\n-     * Spawns the supplied op and starts the Scheduler.\n+     * Spawns the supplied op and starts the `Scheduler`.\n      *\n      * This is intended to be called at the start of the program to yield all\n-     * scheduling to the active Scheduler instance.  This is necessary for\n+     * scheduling to the active `Scheduler` instance.  This is necessary for\n      * schedulers that explicitly dispatch threads rather than simply relying\n      * on the operating system to do so, and so start should always be called\n-     * within main() to begin normal program execution.\n+     * within `main()` to begin normal program execution.\n      *\n      * Params:\n      *  op = A wrapper for whatever the main thread would have done in the\n      *       absence of a custom scheduler.  It will be automatically executed\n-     *       via a call to spawn by the Scheduler.\n+     *       via a call to spawn by the `Scheduler`.\n      */\n     void start(void delegate() op);\n \n@@ -1307,8 +1307,8 @@ interface Scheduler\n      *\n      * This routine is called by spawn.  It is expected to instantiate a new\n      * logical thread and run the supplied operation.  This thread must call\n-     * thisInfo.cleanup() when the thread terminates if the scheduled thread\n-     * is not a kernel thread--all kernel threads will have their ThreadInfo\n+     * `thisInfo.cleanup()` when the thread terminates if the scheduled thread\n+     * is not a kernel thread--all kernel threads will have their `ThreadInfo`\n      * cleaned up automatically by a thread-local destructor.\n      *\n      * Params:\n@@ -1329,36 +1329,36 @@ interface Scheduler\n     void yield() nothrow;\n \n     /**\n-     * Returns an appropriate ThreadInfo instance.\n+     * Returns an appropriate `ThreadInfo` instance.\n      *\n-     * Returns an instance of ThreadInfo specific to the logical thread that\n+     * Returns an instance of `ThreadInfo` specific to the logical thread that\n      * is calling this routine or, if the calling thread was not create by\n-     * this scheduler, returns ThreadInfo.thisInfo instead.\n+     * this scheduler, returns `ThreadInfo.thisInfo` instead.\n      */\n     @property ref ThreadInfo thisInfo() nothrow;\n \n     /**\n-     * Creates a Condition variable analog for signaling.\n+     * Creates a `Condition` variable analog for signaling.\n      *\n-     * Creates a new Condition variable analog which is used to check for and\n+     * Creates a new `Condition` variable analog which is used to check for and\n      * to signal the addition of messages to a thread's message queue.  Like\n      * yield, some schedulers may need to define custom behavior so that calls\n-     * to Condition.wait() yield to another thread when no new messages are\n+     * to `Condition.wait()` yield to another thread when no new messages are\n      * available instead of blocking.\n      *\n      * Params:\n-     *  m = The Mutex that will be associated with this condition.  It will be\n+     *  m = The `Mutex` that will be associated with this condition.  It will be\n      *      locked prior to any operation on the condition, and so in some\n-     *      cases a Scheduler may need to hold this reference and unlock the\n+     *      cases a `Scheduler` may need to hold this reference and unlock the\n      *      mutex before yielding execution to another logical thread.\n      */\n     Condition newCondition(Mutex m) nothrow;\n }\n \n /**\n- * An example Scheduler using kernel threads.\n+ * An example `Scheduler` using kernel threads.\n  *\n- * This is an example Scheduler that mirrors the default scheduling behavior\n+ * This is an example `Scheduler` that mirrors the default scheduling behavior\n  * of creating one kernel thread per call to spawn.  It is fully functional\n  * and may be instantiated and used, but is not a necessary part of the\n  * default functioning of this module.\n@@ -1392,16 +1392,16 @@ class ThreadScheduler : Scheduler\n     }\n \n     /**\n-     * Returns ThreadInfo.thisInfo, since it is a thread-local instance of\n-     * ThreadInfo, which is the correct behavior for this scheduler.\n+     * Returns `ThreadInfo.thisInfo`, since it is a thread-local instance of\n+     * `ThreadInfo`, which is the correct behavior for this scheduler.\n      */\n     @property ref ThreadInfo thisInfo() nothrow\n     {\n         return ThreadInfo.thisInfo;\n     }\n \n     /**\n-     * Creates a new Condition variable.  No custom behavior is needed here.\n+     * Creates a new `Condition` variable.  No custom behavior is needed here.\n      */\n     Condition newCondition(Mutex m) nothrow\n     {\n@@ -1410,15 +1410,15 @@ class ThreadScheduler : Scheduler\n }\n \n /**\n- * An example Scheduler using Fibers.\n+ * An example `Scheduler` using $(MREF_ALTTEXT `Fiber`s, core, thread, fiber).\n  *\n- * This is an example scheduler that creates a new Fiber per call to spawn\n+ * This is an example scheduler that creates a new `Fiber` per call to spawn\n  * and multiplexes the execution of all fibers within the main thread.\n  */\n class FiberScheduler : Scheduler\n {\n     /**\n-     * This creates a new Fiber for the supplied op and then starts the\n+     * This creates a new `Fiber` for the supplied op and then starts the\n      * dispatcher.\n      */\n     void start(void delegate() op)\n@@ -1428,7 +1428,7 @@ class FiberScheduler : Scheduler\n     }\n \n     /**\n-     * This created a new Fiber for the supplied op and adds it to the\n+     * This created a new `Fiber` for the supplied op and adds it to the\n      * dispatch list.\n      */\n     void spawn(void delegate() op) nothrow\n@@ -1438,8 +1438,8 @@ class FiberScheduler : Scheduler\n     }\n \n     /**\n-     * If the caller is a scheduled Fiber, this yields execution to another\n-     * scheduled Fiber.\n+     * If the caller is a scheduled `Fiber`, this yields execution to another\n+     * scheduled `Fiber`.\n      */\n     void yield() nothrow\n     {\n@@ -1451,11 +1451,11 @@ class FiberScheduler : Scheduler\n     }\n \n     /**\n-     * Returns an appropriate ThreadInfo instance.\n+     * Returns an appropriate `ThreadInfo` instance.\n      *\n-     * Returns a ThreadInfo instance specific to the calling Fiber if the\n-     * Fiber was created by this dispatcher, otherwise it returns\n-     * ThreadInfo.thisInfo.\n+     * Returns a `ThreadInfo` instance specific to the calling `Fiber` if the\n+     * `Fiber` was created by this dispatcher, otherwise it returns\n+     * `ThreadInfo.thisInfo`.\n      */\n     @property ref ThreadInfo thisInfo() nothrow\n     {\n@@ -1467,10 +1467,10 @@ class FiberScheduler : Scheduler\n     }\n \n     /**\n-     * Returns a Condition analog that yields when wait or notify is called.\n+     * Returns a `Condition` analog that yields when wait or notify is called.\n      *\n      * Bug:\n-     * For the default implementation, `notifyAll`will behave like `notify`.\n+     * For the default implementation, `notifyAll` will behave like `notify`.\n      *\n      * Params:\n      *   m = A `Mutex` to use for locking if the condition needs to be waited on\n@@ -1485,7 +1485,7 @@ class FiberScheduler : Scheduler\n \n protected:\n     /**\n-     * Creates a new Fiber which calls the given delegate.\n+     * Creates a new `Fiber` which calls the given delegate.\n      *\n      * Params:\n      *   op = The delegate the fiber should call\n@@ -1505,7 +1505,7 @@ protected:\n     }\n \n     /**\n-     * Fiber which embeds a ThreadInfo\n+     * `Fiber` which embeds a `ThreadInfo`\n      */\n     static class InfoFiber : Fiber\n     {\n@@ -1650,19 +1650,19 @@ private:\n }\n \n /**\n- * Sets the Scheduler behavior within the program.\n+ * Sets the `Scheduler` behavior within the program.\n  *\n- * This variable sets the Scheduler behavior within this program.  Typically,\n- * when setting a Scheduler, scheduler.start() should be called in main.  This\n+ * This variable sets the `Scheduler` behavior within this program.  Typically,\n+ * when setting a `Scheduler`, `scheduler.start()` should be called in `main`.  This\n  * routine will not return until program execution is complete.\n  */\n __gshared Scheduler scheduler;\n \n // Generator\n \n /**\n- * If the caller is a Fiber and is not a Generator, this function will call\n- * scheduler.yield() or Fiber.yield(), as appropriate.\n+ * If the caller is a `Fiber` and is not a $(LREF Generator), this function will call\n+ * `scheduler.yield()` or `Fiber.yield()`, as appropriate.\n  */\n void yield() nothrow\n {\n@@ -1684,8 +1684,9 @@ private interface IsGenerator {}\n \n \n /**\n- * A Generator is a Fiber that periodically returns values of type T to the\n- * caller via yield.  This is represented as an InputRange.\n+ * A Generator is a $(MREF_ALTTEXT Fiber, core, thread, fiber)\n+ * that periodically returns values of type `T` to the\n+ * caller via `yield`.  This is represented as an InputRange.\n  */\n class Generator(T) :\n     Fiber, IsGenerator, InputRange!T\n@@ -1829,7 +1830,7 @@ class Generator(T) :\n     /**\n      * Returns the most recently generated value without executing a\n      * copy contructor. Will not compile for element types defining a\n-     * postblit, because Generator does not return by reference.\n+     * postblit, because `Generator` does not return by reference.\n      */\n     final T moveFront()\n     {"}, {"sha": "0fd34526ea72babd494e468a3626fa1df94609e4", "filename": "libphobos/src/std/container/binaryheap.d", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Fsrc%2Fstd%2Fcontainer%2Fbinaryheap.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Fsrc%2Fstd%2Fcontainer%2Fbinaryheap.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fcontainer%2Fbinaryheap.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -597,3 +597,43 @@ BinaryHeap!(Store, less) heapify(alias less = \"a < b\", Store)(Store s,\n     heap.insert(6);\n     assert(equal(heap, [6, 5]));\n }\n+\n+/**\n+Example for unintuitive behaviour\n+It is important not to use the Store after a Heap has been instantiated from\n+it, at least in the cases of Dynamic Arrays. For example, inserting a new element\n+in a Heap, which is using a Dyamic Array as a Store, will cause a reallocation of\n+the Store, if the Store is already full. The Heap will not point anymore to the\n+original Dyamic Array, but point to a new Dynamic Array.\n+ */\n+\n+// https://issues.dlang.org/show_bug.cgi?id=18333\n+@system unittest\n+{\n+    import std.stdio;\n+    import std.algorithm.comparison : equal;\n+    import std.container.binaryheap;\n+\n+    int[] a = [ 4, 1, 3, 2, 16, 9, 10, 14, 8, 7 ];\n+    auto h = heapify(a);\n+\n+    // Internal representation of Binary Heap tree\n+    assert(a.equal([16, 14, 10, 8, 7, 9, 3, 2, 4, 1]));\n+\n+    h.replaceFront(30);\n+    // Value 16 was replaced by 30\n+    assert(a.equal([30, 14, 10, 8, 7, 9, 3, 2, 4, 1]));\n+\n+    // Making changes to the Store will be seen in the Heap\n+    a[0] = 40;\n+    assert(h.front() == 40);\n+\n+    // Inserting a new element will reallocate the Store, leaving\n+    // the original Store unchanged.\n+    h.insert(20);\n+    assert(a.equal([40, 14, 10, 8, 7, 9, 3, 2, 4, 1]));\n+\n+    // Making changes to the original Store will not affect the Heap anymore\n+    a[0] = 60;\n+    assert(h.front() == 40);\n+}"}, {"sha": "6ffc0f7750a8a8a4dd157caa0e1039fcb73990e4", "filename": "libphobos/src/std/exception.d", "status": "modified", "additions": 4, "deletions": 19, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Fsrc%2Fstd%2Fexception.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Fsrc%2Fstd%2Fexception.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fexception.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1069,9 +1069,9 @@ as the language is free to assume objects don't have internal pointers\n */\n bool doesPointTo(S, T, Tdummy=void)(auto ref const S source, ref const T target) @nogc @trusted pure nothrow\n if (__traits(isRef, source) || isDynamicArray!S ||\n-    is(S : U*, U) || is(S == class))\n+    is(S == U*, U) || is(S == class))\n {\n-    static if (is(S : U*, U) || is(S == class) || is(S == interface))\n+    static if (is(S == U*, U) || is(S == class) || is(S == interface))\n     {\n         const m = *cast(void**) &source;\n         const b = cast(void*) &target;\n@@ -1115,9 +1115,9 @@ bool doesPointTo(S, T)(auto ref const shared S source, ref const shared T target\n /// ditto\n bool mayPointTo(S, T, Tdummy=void)(auto ref const S source, ref const T target) @trusted pure nothrow\n if (__traits(isRef, source) || isDynamicArray!S ||\n-    is(S : U*, U) || is(S == class))\n+    is(S == U*, U) || is(S == class))\n {\n-    static if (is(S : U*, U) || is(S == class) || is(S == interface))\n+    static if (is(S == U*, U) || is(S == class) || is(S == interface))\n     {\n         const m = *cast(void**) &source;\n         const b = cast(void*) &target;\n@@ -1533,21 +1533,6 @@ version (StdUnittest)\n     assert( doesPointTo(cast(int*) s, i));\n     assert(!doesPointTo(cast(int*) s, j));\n }\n-@safe unittest //more alias this opCast\n-{\n-    void* p;\n-    class A\n-    {\n-        void* opCast(T)() if (is(T == void*))\n-        {\n-            return p;\n-        }\n-        alias foo = opCast!(void*);\n-        alias foo this;\n-    }\n-    assert(!doesPointTo(A.init, p));\n-    assert(!mayPointTo(A.init, p));\n-}\n \n /+\n Returns true if the field at index `i` in ($D T) shares its address with another field."}, {"sha": "b7bd3fc91cf971f761048a8b913dbbf7ae76dff2", "filename": "libphobos/src/std/file.d", "status": "modified", "additions": 34, "deletions": 3, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Fsrc%2Fstd%2Ffile.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Fsrc%2Fstd%2Ffile.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Ffile.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -1575,7 +1575,7 @@ private void setTimesImpl(scope const(char)[] names, scope const(FSChar)* namez,\n         const ta = SysTimeToFILETIME(accessTime);\n         const tm = SysTimeToFILETIME(modificationTime);\n         alias defaults =\n-            AliasSeq!(GENERIC_WRITE,\n+            AliasSeq!(FILE_WRITE_ATTRIBUTES,\n                       0,\n                       null,\n                       OPEN_EXISTING,\n@@ -1664,6 +1664,16 @@ private void setTimesImpl(scope const(char)[] names, scope const(FSChar)* namez,\n     rmdirRecurse(newdir);\n }\n \n+// https://issues.dlang.org/show_bug.cgi?id=23683\n+@safe unittest\n+{\n+    scope(exit) deleteme.remove;\n+    import std.stdio : File;\n+    auto f = File(deleteme, \"wb\");\n+    SysTime time = SysTime(DateTime(2018, 10, 4, 0, 0, 30));\n+    setTimes(deleteme, time, time);\n+}\n+\n /++\n     Returns the time that the given file was last modified.\n \n@@ -4930,7 +4940,10 @@ alias DirIterator = _DirIterator!dip1000Enabled;\n         $(LREF DirEntry).\n \n     Throws:\n-        $(LREF FileException) if the directory does not exist.\n+        $(UL\n+        $(LI $(LREF FileException) if the $(B path) directory does not exist or read permission is denied.)\n+        $(LI $(LREF FileException) if $(B mode) is not `shallow` and a subdirectory cannot be read.)\n+        )\n \n Example:\n --------------------\n@@ -4971,7 +4984,25 @@ auto dFiles = dirEntries(\"\",\"*.{d,di}\",SpanMode.depth);\n foreach (d; dFiles)\n     writeln(d.name);\n --------------------\n- +/\n+To handle subdirectories with denied read permission, use `SpanMode.shallow`:\n+---\n+void scan(string path)\n+{\n+    foreach (DirEntry entry; dirEntries(path, SpanMode.shallow))\n+    {\n+        try\n+        {\n+            writeln(entry.name);\n+            if (entry.isDir)\n+                scan(entry.name);\n+        }\n+        catch (FileException fe) { continue; } // ignore\n+    }\n+}\n+\n+scan(\"\");\n+---\n++/\n \n // For some reason, doing the same alias-to-a-template trick as with DirIterator\n // does not work here."}, {"sha": "7f127c098478c867812352b09d40a578fb67f7ba", "filename": "libphobos/src/std/format/internal/write.d", "status": "modified", "additions": 2, "deletions": 174, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Fsrc%2Fstd%2Fformat%2Finternal%2Fwrite.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Fsrc%2Fstd%2Fformat%2Finternal%2Fwrite.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fformat%2Finternal%2Fwrite.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -50,27 +50,6 @@ if (is(BooleanTypeOf!T) && !is(T == enum) && !hasToString!(T, Char))\n \n @safe unittest\n {\n-    class C1\n-    {\n-        bool val;\n-        alias val this;\n-        this(bool v){ val = v; }\n-    }\n-\n-    class C2 {\n-        bool val;\n-        alias val this;\n-        this(bool v){ val = v; }\n-        override string toString() const { return \"C\"; }\n-    }\n-\n-    () @trusted {\n-        formatTest(new C1(false), \"false\");\n-        formatTest(new C1(true),  \"true\");\n-        formatTest(new C2(false), \"C\");\n-        formatTest(new C2(true),  \"C\");\n-    } ();\n-\n     struct S1\n     {\n         bool val;\n@@ -411,26 +390,6 @@ private uint baseOfSpec(in char spec) @safe pure\n \n @safe unittest\n {\n-    class C1\n-    {\n-        long val;\n-        alias val this;\n-        this(long v){ val = v; }\n-    }\n-\n-    class C2\n-    {\n-        long val;\n-        alias val this;\n-        this(long v){ val = v; }\n-        override string toString() const { return \"C\"; }\n-    }\n-\n-    () @trusted {\n-        formatTest(new C1(10), \"10\");\n-        formatTest(new C2(10), \"C\");\n-    } ();\n-\n     struct S1\n     {\n         long val;\n@@ -709,26 +668,6 @@ if (is(FloatingPointTypeOf!T) && !is(T == enum) && !hasToString!(T, Char))\n {\n     formatTest(2.25, \"2.25\");\n \n-    class C1\n-    {\n-        double val;\n-        alias val this;\n-        this(double v){ val = v; }\n-    }\n-\n-    class C2\n-    {\n-        double val;\n-        alias val this;\n-        this(double v){ val = v; }\n-        override string toString() const { return \"C\"; }\n-    }\n-\n-    () @trusted {\n-        formatTest(new C1(2.25), \"2.25\");\n-        formatTest(new C2(2.25), \"C\");\n-    } ();\n-\n     struct S1\n     {\n         double val;\n@@ -1078,26 +1017,6 @@ if (is(CharTypeOf!T) && !is(T == enum) && !hasToString!(T, Char))\n \n @safe unittest\n {\n-    class C1\n-    {\n-        char val;\n-        alias val this;\n-        this(char v){ val = v; }\n-    }\n-\n-    class C2\n-    {\n-        char val;\n-        alias val this;\n-        this(char v){ val = v; }\n-        override string toString() const { return \"C\"; }\n-    }\n-\n-    () @trusted {\n-        formatTest(new C1('c'), \"c\");\n-        formatTest(new C2('c'), \"C\");\n-    } ();\n-\n     struct S1\n     {\n         char val;\n@@ -1165,26 +1084,6 @@ if (is(StringTypeOf!T) && !is(StaticArrayTypeOf!T) && !is(T == enum) && !hasToSt\n \n @safe unittest\n {\n-    // Test for bug 5371 for classes\n-    class C1\n-    {\n-        const string var;\n-        alias var this;\n-        this(string s){ var = s; }\n-    }\n-\n-    class C2\n-    {\n-        string var;\n-        alias var this;\n-        this(string s){ var = s; }\n-    }\n-\n-    () @trusted {\n-        formatTest(new C1(\"c1\"), \"c1\");\n-        formatTest(new C2(\"c2\"), \"c2\");\n-    } ();\n-\n     // Test for bug 5371 for structs\n     struct S1\n     {\n@@ -1204,16 +1103,6 @@ if (is(StringTypeOf!T) && !is(StaticArrayTypeOf!T) && !is(T == enum) && !hasToSt\n \n @safe unittest\n {\n-    class C3\n-    {\n-        string val;\n-        alias val this;\n-        this(string s){ val = s; }\n-        override string toString() const { return \"C\"; }\n-    }\n-\n-    () @trusted { formatTest(new C3(\"c3\"), \"C\"); } ();\n-\n     struct S3\n     {\n         string val; alias val this;\n@@ -1436,36 +1325,6 @@ if (is(DynamicArrayTypeOf!T) && !is(StringTypeOf!T) && !is(T == enum) && !hasToS\n     formatTest(S!0b101([0, 1, 2]), \"S\");                // Test for bug 7628\n     formatTest(S!0b110([0, 1, 2]), \"S\");\n     formatTest(S!0b111([0, 1, 2]), \"S\");\n-\n-    class C(uint flags)\n-    {\n-        int[] arr;\n-        static if (flags & 1)\n-            alias arr this;\n-\n-        this(int[] a) { arr = a; }\n-\n-        static if (flags & 2)\n-        {\n-            @property bool empty() const { return arr.length == 0; }\n-            @property int front() const { return arr[0] * 2; }\n-            void popFront() { arr = arr[1 .. $]; }\n-        }\n-\n-        static if (flags & 4)\n-            override string toString() const { return \"C\"; }\n-    }\n-\n-    () @trusted {\n-        formatTest(new C!0b000([0, 1, 2]), (new C!0b000([])).toString());\n-        formatTest(new C!0b001([0, 1, 2]), \"[0, 1, 2]\");    // Test for bug 7628\n-        formatTest(new C!0b010([0, 1, 2]), \"[0, 2, 4]\");\n-        formatTest(new C!0b011([0, 1, 2]), \"[0, 2, 4]\");\n-        formatTest(new C!0b100([0, 1, 2]), \"C\");\n-        formatTest(new C!0b101([0, 1, 2]), \"C\");            // Test for bug 7628\n-        formatTest(new C!0b110([0, 1, 2]), \"C\");\n-        formatTest(new C!0b111([0, 1, 2]), \"C\");\n-    } ();\n }\n \n @safe unittest\n@@ -1901,26 +1760,6 @@ if (is(AssocArrayTypeOf!T) && !is(T == enum) && !hasToString!(T, Char))\n \n @safe unittest\n {\n-    class C1\n-    {\n-        int[char] val;\n-        alias val this;\n-        this(int[char] v){ val = v; }\n-    }\n-\n-    class C2\n-    {\n-        int[char] val;\n-        alias val this;\n-        this(int[char] v){ val = v; }\n-        override string toString() const { return \"C\"; }\n-    }\n-\n-    () @trusted {\n-        formatTest(new C1(['c':1, 'd':2]), [`['c':1, 'd':2]`, `['d':2, 'c':1]`]);\n-        formatTest(new C2(['c':1, 'd':2]), \"C\");\n-    } ();\n-\n     struct S1\n     {\n         int[char] val;\n@@ -1990,7 +1829,8 @@ enum HasToStringResult\n     customPutWriterFormatSpec,\n }\n \n-private enum hasPreviewIn = !is(typeof(mixin(q{(in ref int a) => a})));\n+private alias DScannerBug895 = int[256];\n+private immutable bool hasPreviewIn = ((in DScannerBug895 a) { return __traits(isRef, a); })(DScannerBug895.init);\n \n template hasToString(T, Char)\n {\n@@ -3167,18 +3007,6 @@ if (isPointer!T && !is(T == enum) && !hasToString!(T, Char))\n     formatTest(q, \"FFEECCAA\");\n }\n \n-// https://issues.dlang.org/show_bug.cgi?id=8186\n-@system unittest\n-{\n-    class B\n-    {\n-        int* a;\n-        this() { a = new int; }\n-        alias a this;\n-    }\n-    formatTest(B.init, \"null\");\n-}\n-\n // https://issues.dlang.org/show_bug.cgi?id=9336\n @system pure unittest\n {"}, {"sha": "da9d0dc14db4337eb77c4d5cf31460098ff6b3ce", "filename": "libphobos/src/std/format/read.d", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Fsrc%2Fstd%2Fformat%2Fread.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Fsrc%2Fstd%2Fformat%2Fread.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fformat%2Fread.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -303,8 +303,23 @@ uint formattedRead(alias fmt, Range, Args...)(auto ref Range r, auto ref Args ar\n if (isSomeString!(typeof(fmt)))\n {\n     import std.format : checkFormatException;\n+    import std.meta : staticMap;\n+    import std.typecons : Tuple;\n+\n \n-    alias e = checkFormatException!(fmt, Args);\n+    // formattedRead supports std.typecons.Tuple\n+    // however, checkFormatException does not\n+    // this means that all std.typecons.Tuple's types in Args must be unwrapped\n+    // and passed to checkFormatException\n+    template Flatten(T)\n+    {\n+        static if (is(T : Tuple!Args, Args...))\n+            alias Flatten = Args;\n+        else\n+            alias Flatten = T;\n+    }\n+\n+    alias e = checkFormatException!(fmt, staticMap!(Flatten, Args));\n     static assert(!e, e);\n     return .formattedRead(r, fmt, args);\n }\n@@ -361,6 +376,20 @@ if (isSomeString!(typeof(fmt)))\n     assert(t[0] == 1 && t[1] == 2.125);\n }\n \n+// https://issues.dlang.org/show_bug.cgi?id=23600\n+@safe pure unittest\n+{\n+    import std.typecons : Tuple, tuple;\n+\n+    string h, w;\n+    Tuple!(int, float) t;\n+\n+    assert(\"hello 1 2.34 world\".formattedRead!\"%s %d %f %s\"(h, t, w) == 3);\n+    assert(h == \"hello\");\n+    assert(t == tuple(1, 2.34f));\n+    assert(w == \"world\");\n+}\n+\n @safe unittest\n {\n     import std.math.operations : isClose;"}, {"sha": "42aeb4099e704aab9a6ffd882a8442d5ca1c2949", "filename": "libphobos/src/std/getopt.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Fsrc%2Fstd%2Fgetopt.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Fsrc%2Fstd%2Fgetopt.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fgetopt.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -558,7 +558,7 @@ private template optionValidator(A...)\n     import std.format : format;\n \n     enum fmt = \"getopt validator: %s (at position %d)\";\n-    enum isReceiver(T) = is(T : U*, U) || (is(T == function)) || (is(T == delegate));\n+    enum isReceiver(T) = is(T == U*, U) || (is(T == function)) || (is(T == delegate));\n     enum isOptionStr(T) = isSomeString!T || isSomeChar!T;\n \n     auto validator()"}, {"sha": "093ebd1c19fbeaefee13c1e6662ac8e808284efa", "filename": "libphobos/src/std/internal/unicode_grapheme.d", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Fsrc%2Fstd%2Finternal%2Funicode_grapheme.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8c7d337123b28fdeb539a283d00732118712e/libphobos%2Fsrc%2Fstd%2Finternal%2Funicode_grapheme.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Finternal%2Funicode_grapheme.d?ref=8da8c7d337123b28fdeb539a283d00732118712e", "patch": "@@ -22,10 +22,16 @@ static if (size_t.sizeof == 4)\n enum hangulLVTrieEntries = TrieEntry!(bool, 8, 5, 8)([ 0x0,  0x40,  0x80], [ 0x100,  0x80,  0xa00], [ 0x0,  0x20100,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x20001,  0x40003,  0x60005,  0x10007,  0x30002,  0x50004,  0x70006,  0x20001,  0x40003,  0x60005,  0x10007,  0x30002,  0x50004,  0x70006,  0x20001,  0x40003,  0x60005,  0x10007,  0x30002,  0x50004,  0x70006,  0x80001,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x10000001,  0x1000000,  0x100000,  0x10000,  0x1000,  0x100,  0x10,  0x10000001,  0x1000000,  0x100000,  0x10000,  0x1000,  0x100,  0x10,  0x10000001,  0x1000000,  0x100000,  0x10000,  0x1000,  0x100,  0x10,  0x10000001,  0x1000000,  0x100000,  0x10000,  0x1000,  0x100,  0x10,  0x10000001,  0x1000000,  0x100000,  0x10000,  0x1000,  0x100,  0x10,  0x10000001,  0x1000000,  0x100000,  0x10000,  0x1000,  0x100,  0x10,  0x10000001,  0x1000000,  0x100000,  0x10000,  0x1000,  0x100,  0x10,  0x10000001,  0x1000000,  0x100000,  0x10000,  0x1000,  0x100,  0x10,  0x1000000,  0x100000,  0x10000,  0x1000,  0x100,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0]);\n //832 bytes\n enum hangulLVTTrieEntries = TrieEntry!(bool, 8, 5, 8)([ 0x0,  0x40,  0x80], [ 0x100,  0x80,  0xa00], [ 0x0,  0x20100,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x20001,  0x40003,  0x60005,  0x10007,  0x30002,  0x50004,  0x70006,  0x20001,  0x40003,  0x60005,  0x10007,  0x30002,  0x50004,  0x70006,  0x20001,  0x40003,  0x60005,  0x10007,  0x30002,  0x50004,  0x70006,  0x80001,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0xeffffffe,  0xfeffffff,  0xffefffff,  0xfffeffff,  0xffffefff,  0xfffffeff,  0xffffffef,  0xeffffffe,  0xfeffffff,  0xffefffff,  0xfffeffff,  0xffffefff,  0xfffffeff,  0xffffffef,  0xeffffffe,  0xfeffffff,  0xffefffff,  0xfffeffff,  0xffffefff,  0xfffffeff,  0xffffffef,  0xeffffffe,  0xfeffffff,  0xffefffff,  0xfffeffff,  0xffffefff,  0xfffffeff,  0xffffffef,  0xeffffffe,  0xfeffffff,  0xffefffff,  0xfffeffff,  0xffffefff,  0xfffffeff,  0xffffffef,  0xeffffffe,  0xfeffffff,  0xffefffff,  0xfffeffff,  0xffffefff,  0xfffffeff,  0xffffffef,  0xeffffffe,  0xfeffffff,  0xffefffff,  0xfffeffff,  0xffffefff,  0xfffffeff,  0xffffffef,  0xeffffffe,  0xfeffffff,  0xffefffff,  0xfffeffff,  0xffffefff,  0xfffffeff,  0xffffffef,  0xfeffffff,  0xffefffff,  0xfffeffff,  0xffffefff,  0xfffffeff,  0xf,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0]);\n-//1920 bytes\n-enum mcTrieEntries = TrieEntry!(bool, 8, 5, 8)([ 0x0,  0x40,  0xc0], [ 0x100,  0x100,  0x2400], [ 0x2020100,  0x2020302,  0x5020204,  0x2060202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x10000,  0x30002,  0x50004,  0x60000,  0x7,  0x0,  0x0,  0x80000,  0x90000,  0xb000a,  0xc,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0xd,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0xf000e,  0x110010,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x130012,  0x150014,  0x170016,  0x190018,  0x1b001a,  0x1c,  0x1e001d,  0x20001f,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x210000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x220000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x8,  0xc8000000,  0xde01,  0x0,  0xc,  0xc0000000,  0x801981,  0x0,  0x8,  0xc0000000,  0x1,  0x0,  0x8,  0xc0000000,  0x1a01,  0x0,  0xc,  0x40000000,  0x801981,  0x0,  0x0,  0xc0000000,  0x801dc6,  0x0,  0xe,  0x0,  0x1e,  0x0,  0xc,  0x40000000,  0x600d9f,  0x80000,  0xc,  0xc0000000,  0x801dc1,  0x0,  0xc,  0x0,  0xff038000,  0xc0000,  0x0,  0xc0000000,  0x0,  0x80000000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x19021800,  0xc00000,  0x3f9c,  0x1c009f98,  0x0,  0x0,  0x0,  0x200000,  0x100000,  0x0,  0x0,  0x0,  0xc0400000,  0x1bf,  0x0,  0x0,  0x1fb0e78,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x6000000,  0x0,  0xa00000,  0x7e01a,  0x0,  0x0,  0x0,  0x0,  0x10,  0xe8200000,  0x1b,  0x0,  0x4,  0x4c2,  0x0,  0xc5c80,  0x0,  0x300ff0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x800002,  0x0,  0xc000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x98,  0x0,  0x0,  0x3,  0xfff00000,  0xf,  0x0,  0x0,  0x0,  0xc0000,  0x0,  0x8,  0xcc300000,  0x1,  0x0,  0x0,  0x198000,  0x2000,  0x28000000,  0x0,  0x0,  0x0,  0x20c800,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x16d8,  0x5,  0x0,  0x0,  0x0,  0x4,  0x1870000,  0x0,  0x0,  0x0,  0x1000,  0x60,  0x0,  0x4,  0x80380000,  0x4001,  0x0,  0x0,  0x2c7000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x7,  0xc,  0xc0000000,  0x80399e,  0xc,  0x0,  0x0,  0x0,  0x0,  0x0,  0xe00000,  0x23,  0x0,  0x0,  0x7a070000,  0x2,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x4f038000,  0x0,  0x0,  0x0,  0x58070000,  0x0,  0x0,  0x0,  0x40d000,  0x0,  0x0,  0x0,  0x43,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x1007000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x21bf0000,  0x5,  0x0,  0x0,  0x0,  0xf00e0000,  0x10,  0x0,  0x2000000,  0x1800000,  0x0,  0x800000,  0x0,  0x0,  0x0,  0x0,  0x40008000,  0x0,  0x0,  0x0,  0x120200,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x587c00,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x600000,  0x8,  0xc0300000,  0x2,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0xfffe0000,  0xffffffff,  0xff,  0x0,  0x0,  0x30000,  0x0,  0x0,  0x0,  0x7e060,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0]);\n-//3456 bytes\n-enum graphemeExtendTrieEntries = TrieEntry!(bool, 8, 5, 8)([ 0x0,  0x40,  0x110], [ 0x100,  0x1a0,  0x4a00], [ 0x2020100,  0x4020302,  0x7020605,  0xa090802,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x202020b,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x10000,  0x30002,  0x50004,  0x70006,  0x90008,  0xb000a,  0xd000c,  0xe,  0xf0000,  0x0,  0x100000,  0x120011,  0x140013,  0x160015,  0x0,  0x17,  0x0,  0x0,  0x0,  0x0,  0x0,  0x190018,  0x0,  0x1a,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x1b,  0x1d001c,  0x1f001e,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x200000,  0x0,  0x220021,  0x230000,  0x250024,  0x0,  0x0,  0x0,  0x26,  0x270000,  0x290028,  0x2b002a,  0x2d002c,  0x2f002e,  0x310030,  0x330032,  0x34,  0x360035,  0x380037,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x39,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x3b003a,  0x0,  0x3c0000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x3d,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x3e0000,  0x3f0000,  0x40,  0x0,  0x0,  0x0,  0x41,  0x0,  0x0,  0x3b0042,  0x43,  0x44,  0x0,  0x460045,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x480047,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0xffffffff,  0xffffffff,  0xffffffff,  0xffff,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x3f8,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0xfffe0000,  0xbfffffff,  0xb6,  0x0,  0x7ff0000,  0x0,  0xfffff800,  0x10000,  0x0,  0x0,  0x9fc00000,  0x3d9f,  0x20000,  0xffff0000,  0x7ff,  0x0,  0x0,  0x1ffc0,  0x0,  0x200ff800,  0xfbc00000,  0x3eef,  0xe000000,  0x0,  0xff000000,  0x0,  0xfffffc00,  0xfffffffb,  0x7,  0x14000000,  0xfe21fe,  0xc,  0x2,  0x50000000,  0x80201e,  0x4000000c,  0x6,  0x10000000,  0x23986,  0x230000,  0x6,  0x10000000,  0x21be,  0xfc00000c,  0x2,  0xd0000000,  0xe0201e,  0xc,  0x4,  0x40000000,  0x802001,  0x0,  0x11,  0xd0000000,  0x603dc1,  0xc,  0x2,  0x90000000,  0x603044,  0xc,  0x3,  0x58000000,  0x80201e,  0xc,  0x2,  0x0,  0x805c8400,  0x0,  0x0,  0x7f20000,  0x7f80,  0x0,  0x0,  0x1ff20000,  0x7f00,  0x0,  0x3000000,  0x2a00000,  0x0,  0x7ffe0000,  0xfeffe0df,  0x1fffffff,  0x40,  0x0,  0x0,  0x66fde000,  0xc3000000,  0x1e0001,  0x20002064,  0x0,  0x0,  0x0,  0x0,  0x0,  0xe0000000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x1c0000,  0xc0000,  0xc0000,  0xc0000,  0x0,  0x3fb00000,  0x200ffe40,  0x0,  0xb800,  0x0,  0x0,  0x0,  0x60,  0x200,  0x0,  0x0,  0x0,  0xe040187,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x9800000,  0x0,  0x7f400000,  0x9ff81fe5,  0x0,  0xffff0000,  0x7fff,  0x0,  0xf,  0x17f00000,  0x4,  0xff800,  0x3,  0x3b3c,  0x0,  0x3a340,  0x0,  0xcff000,  0x0,  0x0,  0x0,  0x0,  0xfff70000,  0x31021fd,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0xffffffff,  0xffffffff,  0x1000,  0x0,  0x0,  0x0,  0x0,  0x0,  0xffff0000,  0x1ffff,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x38000,  0x0,  0x0,  0x0,  0x80000000,  0x0,  0x0,  0x0,  0xffffffff,  0x0,  0xfc00,  0x0,  0x0,  0x6000000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x3ff78000,  0xc0000000,  0x0,  0x0,  0x30000,  0x844,  0x1060,  0x0,  0x0,  0x0,  0x0,  0x30,  0x8003ffff,  0x0,  0x3fc0,  0x3ff80,  0x0,  0x7,  0x33c80000,  0x0,  0x20,  0x0,  0x667e00,  0x1008,  0x10000000,  0x0,  0xc19d0000,  0x2,  0x403000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x2120,  0x40000000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0xffff,  0xffff,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0xc0000000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x20000000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x1,  0x0,  0x0,  0x0,  0x7c00000,  0x0,  0x0,  0x0,  0x0,  0xf06e,  0x87000000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x60,  0x0,  0xf0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x1800,  0x0,  0xe0000000,  0x0,  0x0,  0x1ffc0,  0x0,  0x3c,  0x0,  0x0,  0x0,  0x2,  0xff000000,  0x7f,  0x80190000,  0x3,  0x6780000,  0x4,  0x0,  0x7,  0x1fef80,  0x0,  0x80000,  0x3,  0x7fc00000,  0x9e00,  0x0,  0x0,  0x40d38000,  0x2,  0x0,  0x0,  0x0,  0x80000000,  0x7f8,  0x3,  0x58000000,  0x800001,  0x1f1fc0,  0x0,  0x0,  0x0,  0x0,  0x0,  0xff000000,  0x4000005c,  0x0,  0x0,  0xa5f90000,  0xd,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0xb03c8000,  0x30000001,  0x0,  0x0,  0xa7f80000,  0x1,  0x0,  0x0,  0xbf2800,  0x0,  0x0,  0xe0000000,  0xfbc,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x6ff8000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x58010000,  0x8,  0x0,  0x0,  0x0,  0xcf00000,  0x1,  0x7fe,  0x79f80000,  0xe7e0080,  0x0,  0x37ffc00,  0x0,  0x0,  0x0,  0x0,  0xbf7f0000,  0x0,  0x0,  0xfffc0000,  0x6dfcff,  0x0,  0x0,  0x0,  0xb47e0000,  0xbf,  0x0,  0xa30000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x180000,  0x3,  0x7c00000,  0x5,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x3fff81,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x1f0000,  0x0,  0x7f0000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x8000,  0x0,  0x78000,  0x0,  0x0,  0x10,  0x0,  0x0,  0x0,  0x0,  0x60000000,  0x0,  0x0,  0x0,  0xffffffff,  0xffff3fff,  0x7f,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0xf807c3a0,  0xfe7,  0x3c00,  0x0,  0x0,  0x0,  0x0,  0x1c,  0x0,  0x0,  0x0,  0x0,  0x0,  0xffffffff,  0xf87fffff,  0xffffffff,  0x201fff,  0xf8000010,  0xfffe,  0x0,  0x0,  0xf9ffff7f,  0x7db,  0x0,  0x0,  0x8000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x4000,  0x0,  0xf000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0xf000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x7f0000,  0x0,  0x0,  0x0,  0x7f0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0xffffffff,  0xffffffff,  0xffffffff,  0x0,  0x0,  0x0,  0x0,  0xffffffff,  0xffffffff,  0xffffffff,  0xffffffff,  0xffffffff,  0xffffffff,  0xffffffff,  0xffff,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0]);\n+//896 bytes\n+enum prependTrieEntries = TrieEntry!(bool, 8, 5, 8)([ 0x0,  0x40,  0x80], [ 0x100,  0x80,  0xc00], [ 0x1010100,  0x1010101,  0x1010102,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x20001,  0x3,  0x0,  0x40000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x60005,  0x0,  0x0,  0x0,  0x70000,  0x8,  0x90000,  0xa0000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x3f,  0x0,  0x0,  0x0,  0x0,  0x0,  0x20000000,  0x0,  0x8000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x30000,  0x0,  0x0,  0x4,  0x0,  0x0,  0x4000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x20000000,  0x2000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0xc,  0x0,  0x0,  0x80000000,  0x2,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x4000000,  0x0,  0x0,  0x3f0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x40,  0x0,  0x0,  0x0,  0x0,  0x0,  0x4,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0]);\n+//1280 bytes\n+enum controlTrieEntries = TrieEntry!(bool, 8, 5, 8)([ 0x0,  0x40,  0xd0], [ 0x100,  0x120,  0xe00], [ 0x2020100,  0x3020202,  0x2020402,  0x2060502,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020207,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x10000,  0x10001,  0x10001,  0x10002,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10003,  0x10001,  0x10001,  0x10001,  0x10004,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x60005,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10007,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10008,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x90001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0xb000a,  0xc000c,  0xc000c,  0xc000c,  0xc000c,  0xc000c,  0xc000c,  0xc000c,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0xffffdbff,  0x0,  0x0,  0x80000000,  0xffffffff,  0x2000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x10000000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x4000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0xc800,  0x7f00,  0x0,  0xffff,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x80000000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0xfff0000,  0x0,  0xffff0000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0xf,  0x0,  0x0,  0x0,  0x0,  0x0,  0x7f80000,  0x0,  0x0,  0x0,  0x0,  0xffffffff,  0x0,  0x0,  0x0,  0xffffffff,  0xffffffff,  0xffffffff,  0xffffffff,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0xffff0000,  0xffffffff,  0xffffffff,  0xffffffff,  0xffffffff,  0xffffffff,  0xffffffff,  0xffffffff,  0xffffffff,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0]);\n+//1856 bytes\n+enum spacingMarkTrieEntries = TrieEntry!(bool, 8, 5, 8)([ 0x0,  0x40,  0xb0], [ 0x100,  0xe0,  0x2400], [ 0x1010100,  0x1010201,  0x4010103,  0x1050101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x1010101,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x10000,  0x30002,  0x50004,  0x70006,  0x8,  0x0,  0x0,  0x90000,  0xa0000,  0xc000b,  0xd,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0xf000e,  0x110010,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x130012,  0x150014,  0x170016,  0x190018,  0x1b001a,  0x1c,  0x1e001d,  0x20001f,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x210000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x220000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x8,  0xc8000000,  0xde01,  0x0,  0xc,  0x80000000,  0x1981,  0x0,  0x8,  0xc0000000,  0x1,  0x0,  0x8,  0xc0000000,  0x1a01,  0x0,  0xc,  0x0,  0x1981,  0x0,  0x0,  0x80000000,  0x1dc6,  0x0,  0xe,  0x0,  0x1e,  0x0,  0xc,  0x40000000,  0xd9b,  0x80000,  0xc,  0x80000000,  0x1dc1,  0x0,  0xc,  0x0,  0x7f030000,  0xc0000,  0x0,  0x80000,  0x0,  0x0,  0x0,  0x80000,  0x0,  0x0,  0x0,  0xc0000000,  0x0,  0x80000000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x18020000,  0xc00000,  0x0,  0x10,  0x0,  0x0,  0x0,  0x200000,  0x100000,  0x0,  0x0,  0x0,  0xc0400000,  0x1bf,  0x0,  0x0,  0x1fb0e78,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x6000000,  0x0,  0xa00000,  0x7e000,  0x0,  0x0,  0x0,  0x0,  0x10,  0xe8000000,  0x1b,  0x0,  0x4,  0x4c2,  0x0,  0xc5c80,  0x0,  0x300ff0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x800002,  0x0,  0x98,  0x0,  0x0,  0x3,  0xfff00000,  0xf,  0x0,  0x0,  0x0,  0xc0000,  0x0,  0x8,  0xcc300000,  0x1,  0x0,  0x0,  0x198000,  0x2000,  0x0,  0x0,  0x0,  0x0,  0x20c800,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x16d8,  0x5,  0x0,  0x0,  0x0,  0x4,  0x1870000,  0x0,  0x0,  0x0,  0x1000,  0x60,  0x0,  0x4,  0x80380000,  0x4001,  0x0,  0x0,  0x2c7000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x7,  0xc,  0x80000000,  0x399e,  0xc,  0x0,  0x0,  0x0,  0x0,  0x0,  0xe00000,  0x23,  0x0,  0x0,  0x5a060000,  0x2,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x4f030000,  0x0,  0x0,  0x0,  0x58070000,  0x0,  0x0,  0x0,  0x40d000,  0x0,  0x0,  0x0,  0x40,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x1007000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x21be0000,  0x5,  0x0,  0x0,  0x0,  0xf00e0000,  0x10,  0x0,  0x2000000,  0x1800000,  0x0,  0x800000,  0x0,  0x0,  0x0,  0x0,  0x40008000,  0x0,  0x0,  0x0,  0x120200,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x587c00,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x600000,  0x8,  0xc0300000,  0x2,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0xfffe0000,  0xffffffff,  0xff,  0x0,  0x0,  0x30000,  0x0,  0x0,  0x0,  0x2040,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0]);\n+//3488 bytes\n+enum graphemeExtendTrieEntries = TrieEntry!(bool, 8, 5, 8)([ 0x0,  0x40,  0x110], [ 0x100,  0x1a0,  0x4b00], [ 0x2020100,  0x4020302,  0x7020605,  0xa090802,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x202020b,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x10000,  0x30002,  0x50004,  0x70006,  0x90008,  0xb000a,  0xd000c,  0xe,  0xf0000,  0x0,  0x100000,  0x120011,  0x140013,  0x160015,  0x0,  0x17,  0x0,  0x0,  0x0,  0x0,  0x0,  0x190018,  0x0,  0x1a,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x1b,  0x1d001c,  0x1f001e,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x200000,  0x0,  0x220021,  0x230000,  0x250024,  0x0,  0x0,  0x0,  0x26,  0x270000,  0x290028,  0x2b002a,  0x2d002c,  0x2f002e,  0x310030,  0x330032,  0x34,  0x360035,  0x380037,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x39,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x3b003a,  0x0,  0x3c0000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x3d,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x3e0000,  0x3f0000,  0x40,  0x0,  0x0,  0x0,  0x41,  0x0,  0x0,  0x3b0042,  0x43,  0x44,  0x0,  0x460045,  0x0,  0x0,  0x0,  0x0,  0x470000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x490048,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0xffffffff,  0xffffffff,  0xffffffff,  0xffff,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x3f8,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0xfffe0000,  0xbfffffff,  0xb6,  0x0,  0x7ff0000,  0x0,  0xfffff800,  0x10000,  0x0,  0x0,  0x9fc00000,  0x3d9f,  0x20000,  0xffff0000,  0x7ff,  0x0,  0x0,  0x1ffc0,  0x0,  0x200ff800,  0xfbc00000,  0x3eef,  0xe000000,  0x0,  0xff000000,  0x0,  0xfffffc00,  0xfffffffb,  0x7,  0x14000000,  0xfe21fe,  0xc,  0x2,  0x50000000,  0x80201e,  0x4000000c,  0x6,  0x10000000,  0x23986,  0x230000,  0x6,  0x10000000,  0x21be,  0xfc00000c,  0x2,  0xd0000000,  0xe0201e,  0xc,  0x4,  0x40000000,  0x802001,  0x0,  0x11,  0xd0000000,  0x603dc1,  0xc,  0x2,  0x90000000,  0x603044,  0xc,  0x3,  0x58000000,  0x80201e,  0xc,  0x2,  0x0,  0x805c8400,  0x0,  0x0,  0x7f20000,  0x7f80,  0x0,  0x0,  0x1ff20000,  0x7f00,  0x0,  0x3000000,  0x2a00000,  0x0,  0x7ffe0000,  0xfeffe0df,  0x1fffffff,  0x40,  0x0,  0x0,  0x66fde000,  0xc3000000,  0x1e0001,  0x20002064,  0x0,  0x0,  0x0,  0x0,  0x0,  0xe0000000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x1c0000,  0xc0000,  0xc0000,  0xc0000,  0x0,  0x3fb00000,  0x200ffe40,  0x0,  0xb800,  0x0,  0x0,  0x0,  0x60,  0x200,  0x0,  0x0,  0x0,  0xe040187,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x9800000,  0x0,  0x7f400000,  0x9ff81fe5,  0x0,  0xffff0000,  0x7fff,  0x0,  0xf,  0x17f00000,  0x4,  0xff800,  0x3,  0x3b3c,  0x0,  0x3a340,  0x0,  0xcff000,  0x0,  0x0,  0x0,  0x0,  0xfff70000,  0x31021fd,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0xffffffff,  0xffffffff,  0x1000,  0x0,  0x0,  0x0,  0x0,  0x0,  0xffff0000,  0x1ffff,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x38000,  0x0,  0x0,  0x0,  0x80000000,  0x0,  0x0,  0x0,  0xffffffff,  0x0,  0xfc00,  0x0,  0x0,  0x6000000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x3ff78000,  0xc0000000,  0x0,  0x0,  0x30000,  0x844,  0x1060,  0x0,  0x0,  0x0,  0x0,  0x30,  0x8003ffff,  0x0,  0x3fc0,  0x3ff80,  0x0,  0x7,  0x33c80000,  0x0,  0x20,  0x0,  0x667e00,  0x1008,  0x10000000,  0x0,  0xc19d0000,  0x2,  0x403000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x2120,  0x40000000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0xffff,  0xffff,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0xc0000000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x20000000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x1,  0x0,  0x0,  0x0,  0x7c00000,  0x0,  0x0,  0x0,  0x0,  0xf06e,  0x87000000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x60,  0x0,  0xf0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x1800,  0x0,  0xe0000000,  0x0,  0x0,  0x1ffc0,  0x0,  0x3c,  0x0,  0x0,  0x0,  0x2,  0xff000000,  0x7f,  0x80190000,  0x3,  0x6780000,  0x4,  0x0,  0x7,  0x1fef80,  0x0,  0x80000,  0x3,  0x7fc00000,  0x9e00,  0x0,  0x0,  0x40d38000,  0x2,  0x0,  0x0,  0x0,  0x80000000,  0x7f8,  0x3,  0x58000000,  0x800001,  0x1f1fc0,  0x0,  0x0,  0x0,  0x0,  0x0,  0xff000000,  0x4000005c,  0x0,  0x0,  0xa5f90000,  0xd,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0xb03c8000,  0x30000001,  0x0,  0x0,  0xa7f80000,  0x1,  0x0,  0x0,  0xbf2800,  0x0,  0x0,  0xe0000000,  0xfbc,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x6ff8000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x58010000,  0x8,  0x0,  0x0,  0x0,  0xcf00000,  0x1,  0x7fe,  0x79f80000,  0xe7e0080,  0x0,  0x37ffc00,  0x0,  0x0,  0x0,  0x0,  0xbf7f0000,  0x0,  0x0,  0xfffc0000,  0x6dfcff,  0x0,  0x0,  0x0,  0xb47e0000,  0xbf,  0x0,  0xa30000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x180000,  0x3,  0x7c00000,  0x5,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x3fff81,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x1f0000,  0x0,  0x7f0000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x8000,  0x0,  0x78000,  0x0,  0x0,  0x10,  0x0,  0x0,  0x0,  0x0,  0x60000000,  0x0,  0x0,  0x0,  0xffffffff,  0xffff3fff,  0x7f,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0xf807c3a0,  0xfe7,  0x3c00,  0x0,  0x0,  0x0,  0x0,  0x1c,  0x0,  0x0,  0x0,  0x0,  0x0,  0xffffffff,  0xf87fffff,  0xffffffff,  0x201fff,  0xf8000010,  0xfffe,  0x0,  0x0,  0xf9ffff7f,  0x7db,  0x0,  0x0,  0x8000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x4000,  0x0,  0xf000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0xf000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x7f0000,  0x0,  0x0,  0x0,  0x7f0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0xf8000000,  0x0,  0xffffffff,  0xffffffff,  0xffffffff,  0x0,  0x0,  0x0,  0x0,  0xffffffff,  0xffffffff,  0xffffffff,  0xffffffff,  0xffffffff,  0xffffffff,  0xffffffff,  0xffff,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0]);\n+//1344 bytes\n+enum Extended_PictographicTrieEntries = TrieEntry!(bool, 8, 5, 8)([ 0x0,  0x40,  0x90], [ 0x100,  0xa0,  0x1800], [ 0x2020100,  0x2020202,  0x2020202,  0x3020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x2020202,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x10000,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x30002,  0x40001,  0x60005,  0x80007,  0x90001,  0xa0001,  0x10001,  0x10001,  0x1000b,  0x1000c,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0xe000d,  0x10000f,  0x11000d,  0x130012,  0x150014,  0x1000d,  0xd000d,  0x16000d,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x10001,  0x0,  0x0,  0x0,  0x0,  0x0,  0x4200,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x10000000,  0x200,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x2000004,  0x0,  0x0,  0x3f00000,  0x600,  0x0,  0x0,  0xc000000,  0x100,  0x0,  0x0,  0x100,  0x0,  0x8000,  0x70ffe00,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x4,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x400c00,  0x1,  0x78000000,  0xfff7ffbf,  0xffffffff,  0xffffffff,  0xffffffff,  0xffff003f,  0xffffffff,  0xffffffff,  0xffffffff,  0x2057ff3f,  0x180102,  0xb85090,  0xf8,  0xe00000,  0x80010002,  0x0,  0x0,  0x0,  0x300000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x180000e0,  0x0,  0x210000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x20010000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x2800000,  0x0,  0x0,  0x0,  0xffffffff,  0xffffffff,  0xffffffff,  0xffffffff,  0xffffffff,  0xffffffff,  0xffffffff,  0xffffffff,  0xe000,  0x8000,  0x0,  0xc003f000,  0x7fe4000,  0xffffe000,  0xffffffff,  0x3f,  0x400fffe,  0xf7fc8000,  0xfffffe00,  0xffffffff,  0xffffffff,  0xffffffff,  0xffffffff,  0xffffffff,  0xffffffff,  0xffffffff,  0xffffffff,  0xffffffff,  0xffffffff,  0xffffffff,  0xffffffff,  0x7ffffff,  0xffffffff,  0x3fffffff,  0xffffffc0,  0xffffffff,  0xffffffff,  0xffffffff,  0xffffffff,  0xffffffff,  0xffffffff,  0xffffffff,  0xffff,  0x0,  0xffffffff,  0xffffffff,  0xffffffff,  0xffffffff,  0x0,  0x0,  0x0,  0xfff00000,  0x0,  0x0,  0xffe00000,  0xffffffff,  0xf000,  0x0,  0xfc00ff00,  0x0,  0xff00,  0xffffc000,  0xffffffff,  0xffffffff,  0xfffff000,  0xf7ffffff,  0xffffffbf,  0xffffffff,  0xffffffff,  0xffffffff,  0xffffffff,  0xffffffff,  0xffffffff,  0xffffffff,  0xffffffff,  0xffffffff,  0xffffffff,  0xffffffff,  0xffffffff,  0x3fffffff,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0]);\n \n }\n \n@@ -36,10 +42,16 @@ static if (size_t.sizeof == 8)\n enum hangulLVTrieEntries = TrieEntry!(bool, 8, 5, 8)([ 0x0,  0x20,  0x40], [ 0x100,  0x80,  0xa00], [ 0x2010000000000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x4000300020001,  0x1000700060005,  0x5000400030002,  0x2000100070006,  0x6000500040003,  0x3000200010007,  0x7000600050004,  0x4000300020001,  0x1000700060005,  0x5000400030002,  0x8000100070006,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x100000010000001,  0x1000000100000,  0x10000001000,  0x1000000100000010,  0x10000001000000,  0x100000010000,  0x1000000100,  0x100000010000001,  0x1000000100000,  0x10000001000,  0x1000000100000010,  0x10000001000000,  0x100000010000,  0x1000000100,  0x100000010000001,  0x1000000100000,  0x10000001000,  0x1000000100000010,  0x10000001000000,  0x100000010000,  0x1000000100,  0x100000010000001,  0x1000000100000,  0x10000001000,  0x1000000100000010,  0x10000001000000,  0x100000010000,  0x1000000100,  0x10000001000000,  0x100000010000,  0x100,  0x0,  0x0,  0x0,  0x0,  0x0]);\n //832 bytes\n enum hangulLVTTrieEntries = TrieEntry!(bool, 8, 5, 8)([ 0x0,  0x20,  0x40], [ 0x100,  0x80,  0xa00], [ 0x2010000000000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x4000300020001,  0x1000700060005,  0x5000400030002,  0x2000100070006,  0x6000500040003,  0x3000200010007,  0x7000600050004,  0x4000300020001,  0x1000700060005,  0x5000400030002,  0x8000100070006,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0xfeffffffeffffffe,  0xfffeffffffefffff,  0xfffffeffffffefff,  0xeffffffeffffffef,  0xffeffffffeffffff,  0xffffeffffffeffff,  0xffffffeffffffeff,  0xfeffffffeffffffe,  0xfffeffffffefffff,  0xfffffeffffffefff,  0xeffffffeffffffef,  0xffeffffffeffffff,  0xffffeffffffeffff,  0xffffffeffffffeff,  0xfeffffffeffffffe,  0xfffeffffffefffff,  0xfffffeffffffefff,  0xeffffffeffffffef,  0xffeffffffeffffff,  0xffffeffffffeffff,  0xffffffeffffffeff,  0xfeffffffeffffffe,  0xfffeffffffefffff,  0xfffffeffffffefff,  0xeffffffeffffffef,  0xffeffffffeffffff,  0xffffeffffffeffff,  0xffffffeffffffeff,  0xffeffffffeffffff,  0xffffeffffffeffff,  0xffffffeff,  0x0,  0x0,  0x0,  0x0,  0x0]);\n-//1920 bytes\n-enum mcTrieEntries = TrieEntry!(bool, 8, 5, 8)([ 0x0,  0x20,  0x60], [ 0x100,  0x100,  0x2400], [ 0x202030202020100,  0x206020205020204,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x3000200010000,  0x6000000050004,  0x7,  0x8000000000000,  0xb000a00090000,  0xc,  0x0,  0x0,  0x0,  0x0,  0xd,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x110010000f000e,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x15001400130012,  0x19001800170016,  0x1c001b001a,  0x20001f001e001d,  0x0,  0x0,  0x0,  0x21000000000000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x220000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0xc800000000000008,  0xde01,  0xc00000000000000c,  0x801981,  0xc000000000000008,  0x1,  0xc000000000000008,  0x1a01,  0x400000000000000c,  0x801981,  0xc000000000000000,  0x801dc6,  0xe,  0x1e,  0x400000000000000c,  0x8000000600d9f,  0xc00000000000000c,  0x801dc1,  0xc,  0xc0000ff038000,  0xc000000000000000,  0x8000000000000000,  0x0,  0x0,  0x1902180000000000,  0x3f9c00c00000,  0x1c009f98,  0x0,  0x10000000200000,  0x0,  0xc040000000000000,  0x1bf,  0x1fb0e7800000000,  0x0,  0x0,  0x0,  0x6000000,  0x7e01a00a00000,  0x0,  0x0,  0xe820000000000010,  0x1b,  0x4c200000004,  0xc5c8000000000,  0x300ff000000000,  0x0,  0x0,  0x80000200000000,  0xc00000000000,  0x0,  0x0,  0x0,  0x9800000000,  0x0,  0xfff0000000000003,  0xf,  0x0,  0xc0000,  0xcc30000000000008,  0x1,  0x19800000000000,  0x2800000000002000,  0x0,  0x20c80000000000,  0x0,  0x0,  0x0,  0x16d800000000,  0x5,  0x0,  0x187000000000004,  0x0,  0x100000000000,  0x60,  0x8038000000000004,  0x4001,  0x2c700000000000,  0x0,  0x0,  0x700000000,  0xc00000000000000c,  0xc0080399e,  0x0,  0x0,  0xe0000000000000,  0x23,  0x7a07000000000000,  0x2,  0x0,  0x0,  0x4f03800000000000,  0x0,  0x5807000000000000,  0x0,  0x40d00000000000,  0x0,  0x4300000000,  0x0,  0x0,  0x0,  0x100700000000000,  0x0,  0x0,  0x0,  0x21bf000000000000,  0x5,  0x0,  0x10f00e0000,  0x200000000000000,  0x1800000,  0x800000,  0x0,  0x4000800000000000,  0x0,  0x12020000000000,  0x0,  0x0,  0x0,  0x587c00,  0x0,  0x0,  0x0,  0x0,  0x60000000000000,  0xc030000000000008,  0x2,  0x0,  0x0,  0x0,  0xfffffffffffe0000,  0xff,  0x3000000000000,  0x0,  0x7e06000000000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0]);\n-//3456 bytes\n-enum graphemeExtendTrieEntries = TrieEntry!(bool, 8, 5, 8)([ 0x0,  0x20,  0x88], [ 0x100,  0x1a0,  0x4a00], [ 0x402030202020100,  0xa09080207020605,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x20202020202020b,  0x202020202020202,  0x202020202020202,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x1000000000000,  0x5000400030002,  0x9000800070006,  0xd000c000b000a,  0xf00000000000e,  0x10000000000000,  0x14001300120011,  0x160015,  0x17,  0x0,  0x0,  0x190018,  0x1a,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x1b00000000,  0x1f001e001d001c,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x20000000000000,  0x22002100000000,  0x25002400230000,  0x0,  0x2600000000,  0x29002800270000,  0x2d002c002b002a,  0x310030002f002e,  0x3400330032,  0x38003700360035,  0x0,  0x0,  0x0,  0x0,  0x0,  0x39,  0x0,  0x0,  0x0,  0x0,  0x3b003a00000000,  0x3c000000000000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x3d,  0x0,  0x0,  0x0,  0x3e000000000000,  0x40003f0000,  0x0,  0x4100000000,  0x0,  0x43003b0042,  0x44,  0x460045,  0x0,  0x0,  0x0,  0x0,  0x0,  0x480047,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0xffffffffffffffff,  0xffffffffffff,  0x0,  0x0,  0x0,  0x0,  0x3f8,  0x0,  0x0,  0x0,  0xbffffffffffe0000,  0xb6,  0x7ff0000,  0x10000fffff800,  0x0,  0x3d9f9fc00000,  0xffff000000020000,  0x7ff,  0x1ffc000000000,  0x200ff80000000000,  0x3eeffbc00000,  0xe000000,  0xff000000,  0xfffffffbfffffc00,  0x1400000000000007,  0xc00fe21fe,  0x5000000000000002,  0x4000000c0080201e,  0x1000000000000006,  0x23000000023986,  0x1000000000000006,  0xfc00000c000021be,  0xd000000000000002,  0xc00e0201e,  0x4000000000000004,  0x802001,  0xd000000000000011,  0xc00603dc1,  0x9000000000000002,  0xc00603044,  0x5800000000000003,  0xc0080201e,  0x2,  0x805c8400,  0x7f2000000000000,  0x7f80,  0x1ff2000000000000,  0x7f00,  0x2a0000003000000,  0x7ffe000000000000,  0x1ffffffffeffe0df,  0x40,  0x66fde00000000000,  0x1e0001c3000000,  0x20002064,  0x0,  0x0,  0xe0000000,  0x0,  0x0,  0xc0000001c0000,  0xc0000000c0000,  0x3fb0000000000000,  0x200ffe40,  0xb800,  0x0,  0x20000000060,  0x0,  0xe04018700000000,  0x0,  0x0,  0x0,  0x9800000,  0x9ff81fe57f400000,  0xffff000000000000,  0x7fff,  0x17f000000000000f,  0xff80000000004,  0x3b3c00000003,  0x3a34000000000,  0xcff00000000000,  0x0,  0x0,  0x31021fdfff70000,  0x0,  0x0,  0x0,  0xffffffffffffffff,  0x1000,  0x0,  0x0,  0x1ffffffff0000,  0x0,  0x0,  0x0,  0x3800000000000,  0x0,  0x8000000000000000,  0x0,  0xffffffff00000000,  0xfc0000000000,  0x0,  0x6000000,  0x0,  0x0,  0x3ff7800000000000,  0xc0000000,  0x3000000000000,  0x106000000844,  0x0,  0x0,  0x8003ffff00000030,  0x3fc000000000,  0x3ff80,  0x33c8000000000007,  0x2000000000,  0x667e0000000000,  0x1000000000001008,  0xc19d000000000000,  0x40300000000002,  0x0,  0x0,  0x0,  0x212000000000,  0x40000000,  0x0,  0x0,  0x0,  0xffff0000ffff,  0x0,  0x0,  0x0,  0x0,  0x0,  0xc0000000,  0x0,  0x0,  0x0,  0x0,  0x2000000000000000,  0x0,  0x0,  0x0,  0x100000000,  0x0,  0x7c0000000000000,  0x0,  0x0,  0x870000000000f06e,  0x0,  0x0,  0x6000000000,  0xf000000000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x180000000000,  0xe000000000000000,  0x0,  0x1ffc0,  0x3c,  0x0,  0xff00000000000002,  0x801900000000007f,  0x678000000000003,  0x4,  0x1fef8000000007,  0x8000000000000,  0x7fc0000000000003,  0x9e00,  0x40d3800000000000,  0x2,  0x0,  0x7f880000000,  0x5800000000000003,  0x1f1fc000800001,  0x0,  0x0,  0xff00000000000000,  0x4000005c,  0xa5f9000000000000,  0xd,  0x0,  0x0,  0xb03c800000000000,  0x30000001,  0xa7f8000000000000,  0x1,  0xbf280000000000,  0x0,  0xfbce0000000,  0x0,  0x0,  0x0,  0x6ff800000000000,  0x0,  0x0,  0x0,  0x5801000000000000,  0x8,  0x0,  0x10cf00000,  0x79f80000000007fe,  0xe7e0080,  0x37ffc00,  0x0,  0xbf7f000000000000,  0x0,  0x6dfcfffffc0000,  0x0,  0xb47e000000000000,  0xbf,  0xa30000,  0x0,  0x0,  0x0,  0x0,  0x18000000000000,  0x7c0000000000003,  0x5,  0x0,  0x0,  0x0,  0x3fff81,  0x0,  0x0,  0x0,  0x0,  0x0,  0x1f000000000000,  0x7f000000000000,  0x0,  0x0,  0x0,  0x0,  0x8000,  0x78000,  0x1000000000,  0x0,  0x0,  0x60000000,  0x0,  0xffff3fffffffffff,  0x7f,  0x0,  0x0,  0x0,  0xf807c3a000000000,  0x3c0000000fe7,  0x0,  0x0,  0x1c,  0x0,  0x0,  0xf87fffffffffffff,  0x201fffffffffff,  0xfffef8000010,  0x0,  0x7dbf9ffff7f,  0x0,  0x8000,  0x0,  0x0,  0x0,  0x400000000000,  0xf00000000000,  0x0,  0x0,  0x0,  0xf00000000000,  0x0,  0x0,  0x0,  0x7f0000,  0x0,  0x7f0,  0x0,  0x0,  0xffffffff00000000,  0xffffffffffffffff,  0x0,  0x0,  0xffffffffffffffff,  0xffffffffffffffff,  0xffffffffffffffff,  0xffffffffffff,  0x0,  0x0,  0x0,  0x0]);\n+//896 bytes\n+enum prependTrieEntries = TrieEntry!(bool, 8, 5, 8)([ 0x0,  0x20,  0x40], [ 0x100,  0x80,  0xc00], [ 0x101010101010100,  0x101010101010102,  0x101010101010101,  0x101010101010101,  0x101010101010101,  0x101010101010101,  0x101010101010101,  0x101010101010101,  0x101010101010101,  0x101010101010101,  0x101010101010101,  0x101010101010101,  0x101010101010101,  0x101010101010101,  0x101010101010101,  0x101010101010101,  0x101010101010101,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x2000100000000,  0x3,  0x40000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x60005,  0x0,  0x800070000,  0xa000000090000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x3f,  0x0,  0x0,  0x20000000,  0x8000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x30000,  0x400000000,  0x0,  0x4000,  0x0,  0x0,  0x0,  0x0,  0x2000000000000000,  0x2000,  0x0,  0x0,  0x0,  0xc,  0x8000000000000000,  0x2,  0x0,  0x0,  0x400000000000000,  0x0,  0x3f0,  0x0,  0x0,  0x40,  0x0,  0x0,  0x4,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0]);\n+//1280 bytes\n+enum controlTrieEntries = TrieEntry!(bool, 8, 5, 8)([ 0x0,  0x20,  0x68], [ 0x100,  0x120,  0xe00], [ 0x302020202020100,  0x206050202020402,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020207,  0x202020202020202,  0x202020202020202,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x1000100010000,  0x1000200010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010003,  0x1000100010001,  0x1000100010004,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x6000500010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010007,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010008,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100090001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0xc000c000b000a,  0xc000c000c000c,  0xc000c000c000c,  0xc000c000c000c,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0xffffdbff,  0x8000000000000000,  0x2000ffffffff,  0x0,  0x0,  0x0,  0x0,  0x0,  0x10000000,  0x0,  0x0,  0x0,  0x4000,  0x0,  0x0,  0x0,  0x7f000000c800,  0xffff00000000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x8000000000000000,  0x0,  0x0,  0x0,  0xfff000000000000,  0xffff000000000000,  0x0,  0x0,  0x0,  0x0,  0x0,  0xf00000000,  0x0,  0x0,  0x7f8000000000000,  0x0,  0x0,  0xffffffff,  0x0,  0xffffffffffffffff,  0xffffffffffffffff,  0x0,  0x0,  0x0,  0xffff000000000000,  0xffffffffffffffff,  0xffffffffffffffff,  0xffffffffffffffff,  0xffffffffffffffff,  0x0,  0x0,  0x0,  0x0]);\n+//1856 bytes\n+enum spacingMarkTrieEntries = TrieEntry!(bool, 8, 5, 8)([ 0x0,  0x20,  0x58], [ 0x100,  0xe0,  0x2400], [ 0x101020101010100,  0x105010104010103,  0x101010101010101,  0x101010101010101,  0x101010101010101,  0x101010101010101,  0x101010101010101,  0x101010101010101,  0x101010101010101,  0x101010101010101,  0x101010101010101,  0x101010101010101,  0x101010101010101,  0x101010101010101,  0x101010101010101,  0x101010101010101,  0x101010101010101,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x3000200010000,  0x7000600050004,  0x8,  0x9000000000000,  0xc000b000a0000,  0xd,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x110010000f000e,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x15001400130012,  0x19001800170016,  0x1c001b001a,  0x20001f001e001d,  0x0,  0x0,  0x0,  0x21000000000000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x220000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0xc800000000000008,  0xde01,  0x800000000000000c,  0x1981,  0xc000000000000008,  0x1,  0xc000000000000008,  0x1a01,  0xc,  0x1981,  0x8000000000000000,  0x1dc6,  0xe,  0x1e,  0x400000000000000c,  0x8000000000d9b,  0x800000000000000c,  0x1dc1,  0xc,  0xc00007f030000,  0x8000000000000,  0x0,  0x8000000000000,  0x0,  0xc000000000000000,  0x8000000000000000,  0x0,  0x0,  0x1802000000000000,  0xc00000,  0x10,  0x0,  0x10000000200000,  0x0,  0xc040000000000000,  0x1bf,  0x1fb0e7800000000,  0x0,  0x0,  0x0,  0x6000000,  0x7e00000a00000,  0x0,  0x0,  0xe800000000000010,  0x1b,  0x4c200000004,  0xc5c8000000000,  0x300ff000000000,  0x0,  0x0,  0x80000200000000,  0x9800000000,  0x0,  0xfff0000000000003,  0xf,  0x0,  0xc0000,  0xcc30000000000008,  0x1,  0x19800000000000,  0x2000,  0x0,  0x20c80000000000,  0x0,  0x0,  0x0,  0x16d800000000,  0x5,  0x0,  0x187000000000004,  0x0,  0x100000000000,  0x60,  0x8038000000000004,  0x4001,  0x2c700000000000,  0x0,  0x0,  0x700000000,  0x800000000000000c,  0xc0000399e,  0x0,  0x0,  0xe0000000000000,  0x23,  0x5a06000000000000,  0x2,  0x0,  0x0,  0x4f03000000000000,  0x0,  0x5807000000000000,  0x0,  0x40d00000000000,  0x0,  0x4000000000,  0x0,  0x0,  0x0,  0x100700000000000,  0x0,  0x0,  0x0,  0x21be000000000000,  0x5,  0x0,  0x10f00e0000,  0x200000000000000,  0x1800000,  0x800000,  0x0,  0x4000800000000000,  0x0,  0x12020000000000,  0x0,  0x0,  0x0,  0x587c00,  0x0,  0x0,  0x0,  0x0,  0x60000000000000,  0xc030000000000008,  0x2,  0x0,  0x0,  0x0,  0xfffffffffffe0000,  0xff,  0x3000000000000,  0x0,  0x204000000000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0]);\n+//3488 bytes\n+enum graphemeExtendTrieEntries = TrieEntry!(bool, 8, 5, 8)([ 0x0,  0x20,  0x88], [ 0x100,  0x1a0,  0x4b00], [ 0x402030202020100,  0xa09080207020605,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x20202020202020b,  0x202020202020202,  0x202020202020202,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x1000000000000,  0x5000400030002,  0x9000800070006,  0xd000c000b000a,  0xf00000000000e,  0x10000000000000,  0x14001300120011,  0x160015,  0x17,  0x0,  0x0,  0x190018,  0x1a,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x1b00000000,  0x1f001e001d001c,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x20000000000000,  0x22002100000000,  0x25002400230000,  0x0,  0x2600000000,  0x29002800270000,  0x2d002c002b002a,  0x310030002f002e,  0x3400330032,  0x38003700360035,  0x0,  0x0,  0x0,  0x0,  0x0,  0x39,  0x0,  0x0,  0x0,  0x0,  0x3b003a00000000,  0x3c000000000000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x3d,  0x0,  0x0,  0x0,  0x3e000000000000,  0x40003f0000,  0x0,  0x4100000000,  0x0,  0x43003b0042,  0x44,  0x460045,  0x0,  0x47000000000000,  0x0,  0x0,  0x0,  0x490048,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0xffffffffffffffff,  0xffffffffffff,  0x0,  0x0,  0x0,  0x0,  0x3f8,  0x0,  0x0,  0x0,  0xbffffffffffe0000,  0xb6,  0x7ff0000,  0x10000fffff800,  0x0,  0x3d9f9fc00000,  0xffff000000020000,  0x7ff,  0x1ffc000000000,  0x200ff80000000000,  0x3eeffbc00000,  0xe000000,  0xff000000,  0xfffffffbfffffc00,  0x1400000000000007,  0xc00fe21fe,  0x5000000000000002,  0x4000000c0080201e,  0x1000000000000006,  0x23000000023986,  0x1000000000000006,  0xfc00000c000021be,  0xd000000000000002,  0xc00e0201e,  0x4000000000000004,  0x802001,  0xd000000000000011,  0xc00603dc1,  0x9000000000000002,  0xc00603044,  0x5800000000000003,  0xc0080201e,  0x2,  0x805c8400,  0x7f2000000000000,  0x7f80,  0x1ff2000000000000,  0x7f00,  0x2a0000003000000,  0x7ffe000000000000,  0x1ffffffffeffe0df,  0x40,  0x66fde00000000000,  0x1e0001c3000000,  0x20002064,  0x0,  0x0,  0xe0000000,  0x0,  0x0,  0xc0000001c0000,  0xc0000000c0000,  0x3fb0000000000000,  0x200ffe40,  0xb800,  0x0,  0x20000000060,  0x0,  0xe04018700000000,  0x0,  0x0,  0x0,  0x9800000,  0x9ff81fe57f400000,  0xffff000000000000,  0x7fff,  0x17f000000000000f,  0xff80000000004,  0x3b3c00000003,  0x3a34000000000,  0xcff00000000000,  0x0,  0x0,  0x31021fdfff70000,  0x0,  0x0,  0x0,  0xffffffffffffffff,  0x1000,  0x0,  0x0,  0x1ffffffff0000,  0x0,  0x0,  0x0,  0x3800000000000,  0x0,  0x8000000000000000,  0x0,  0xffffffff00000000,  0xfc0000000000,  0x0,  0x6000000,  0x0,  0x0,  0x3ff7800000000000,  0xc0000000,  0x3000000000000,  0x106000000844,  0x0,  0x0,  0x8003ffff00000030,  0x3fc000000000,  0x3ff80,  0x33c8000000000007,  0x2000000000,  0x667e0000000000,  0x1000000000001008,  0xc19d000000000000,  0x40300000000002,  0x0,  0x0,  0x0,  0x212000000000,  0x40000000,  0x0,  0x0,  0x0,  0xffff0000ffff,  0x0,  0x0,  0x0,  0x0,  0x0,  0xc0000000,  0x0,  0x0,  0x0,  0x0,  0x2000000000000000,  0x0,  0x0,  0x0,  0x100000000,  0x0,  0x7c0000000000000,  0x0,  0x0,  0x870000000000f06e,  0x0,  0x0,  0x6000000000,  0xf000000000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x180000000000,  0xe000000000000000,  0x0,  0x1ffc0,  0x3c,  0x0,  0xff00000000000002,  0x801900000000007f,  0x678000000000003,  0x4,  0x1fef8000000007,  0x8000000000000,  0x7fc0000000000003,  0x9e00,  0x40d3800000000000,  0x2,  0x0,  0x7f880000000,  0x5800000000000003,  0x1f1fc000800001,  0x0,  0x0,  0xff00000000000000,  0x4000005c,  0xa5f9000000000000,  0xd,  0x0,  0x0,  0xb03c800000000000,  0x30000001,  0xa7f8000000000000,  0x1,  0xbf280000000000,  0x0,  0xfbce0000000,  0x0,  0x0,  0x0,  0x6ff800000000000,  0x0,  0x0,  0x0,  0x5801000000000000,  0x8,  0x0,  0x10cf00000,  0x79f80000000007fe,  0xe7e0080,  0x37ffc00,  0x0,  0xbf7f000000000000,  0x0,  0x6dfcfffffc0000,  0x0,  0xb47e000000000000,  0xbf,  0xa30000,  0x0,  0x0,  0x0,  0x0,  0x18000000000000,  0x7c0000000000003,  0x5,  0x0,  0x0,  0x0,  0x3fff81,  0x0,  0x0,  0x0,  0x0,  0x0,  0x1f000000000000,  0x7f000000000000,  0x0,  0x0,  0x0,  0x0,  0x8000,  0x78000,  0x1000000000,  0x0,  0x0,  0x60000000,  0x0,  0xffff3fffffffffff,  0x7f,  0x0,  0x0,  0x0,  0xf807c3a000000000,  0x3c0000000fe7,  0x0,  0x0,  0x1c,  0x0,  0x0,  0xf87fffffffffffff,  0x201fffffffffff,  0xfffef8000010,  0x0,  0x7dbf9ffff7f,  0x0,  0x8000,  0x0,  0x0,  0x0,  0x400000000000,  0xf00000000000,  0x0,  0x0,  0x0,  0xf00000000000,  0x0,  0x0,  0x0,  0x7f0000,  0x0,  0x7f0,  0x0,  0x0,  0x0,  0x0,  0x0,  0xf800000000000000,  0xffffffff00000000,  0xffffffffffffffff,  0x0,  0x0,  0xffffffffffffffff,  0xffffffffffffffff,  0xffffffffffffffff,  0xffffffffffff,  0x0,  0x0,  0x0,  0x0]);\n+//1344 bytes\n+enum Extended_PictographicTrieEntries = TrieEntry!(bool, 8, 5, 8)([ 0x0,  0x20,  0x48], [ 0x100,  0xa0,  0x1800], [ 0x202020202020100,  0x302020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x202020202020202,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x1000100010000,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x4000100030002,  0x8000700060005,  0xa000100090001,  0x1000100010001,  0x1000c0001000b,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x10000f000e000d,  0x1300120011000d,  0x1000d00150014,  0x16000d000d000d,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x1000100010001,  0x0,  0x0,  0x420000000000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x1000000000000000,  0x200,  0x0,  0x0,  0x200000400000000,  0x0,  0x60003f00000,  0x0,  0x1000c000000,  0x0,  0x100,  0x70ffe0000008000,  0x0,  0x0,  0x0,  0x4,  0x0,  0x0,  0x400c0000000000,  0x7800000000000001,  0xfffffffffff7ffbf,  0xffffffffffffffff,  0xffffffffffff003f,  0xffffffffffffffff,  0x1801022057ff3f,  0xf800b85090,  0x8001000200e00000,  0x0,  0x30000000000000,  0x0,  0x0,  0x0,  0x180000e0,  0x210000,  0x0,  0x0,  0x2001000000000000,  0x0,  0x0,  0x0,  0x0,  0x0,  0x2800000,  0x0,  0xffffffffffffffff,  0xffffffffffffffff,  0xffffffffffffffff,  0xffffffffffffffff,  0x80000000e000,  0xc003f00000000000,  0xffffe00007fe4000,  0x3fffffffff,  0xf7fc80000400fffe,  0xfffffffffffffe00,  0xffffffffffffffff,  0xffffffffffffffff,  0xffffffffffffffff,  0xffffffffffffffff,  0xffffffffffffffff,  0x7ffffffffffffff,  0x3fffffffffffffff,  0xffffffffffffffc0,  0xffffffffffffffff,  0xffffffffffffffff,  0xffffffffffffffff,  0xffff,  0xffffffffffffffff,  0xffffffffffffffff,  0x0,  0xfff0000000000000,  0x0,  0xffffffffffe00000,  0xf000,  0xfc00ff00,  0xffffc0000000ff00,  0xffffffffffffffff,  0xf7fffffffffff000,  0xffffffffffffffbf,  0xffffffffffffffff,  0xffffffffffffffff,  0xffffffffffffffff,  0xffffffffffffffff,  0xffffffffffffffff,  0x3fffffffffffffff,  0x0,  0x0,  0x0,  0x0]);\n \n }\n "}]}