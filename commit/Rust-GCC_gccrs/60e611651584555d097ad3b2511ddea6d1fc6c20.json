{"sha": "60e611651584555d097ad3b2511ddea6d1fc6c20", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjBlNjExNjUxNTg0NTU1ZDA5N2FkM2IyNTExZGRlYTZkMWZjNmMyMA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-05-16T21:51:44Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-05-16T21:51:44Z"}, "message": "(ereal_from_int, ereal_to_int, etarsingle): Correct signed/unsigned discrepancies.\n\n(ereal_from_int, ereal_to_int, etarsingle):  Correct signed/unsigned\ndiscrepancies.\n(ereal_from_double): Avoid \"right shift count too big\" warning in previous\nchange.\n\nFrom-SVN: r7313", "tree": {"sha": "e365ec8067665f6bde2e816f86addc7195ff7c74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e365ec8067665f6bde2e816f86addc7195ff7c74"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/60e611651584555d097ad3b2511ddea6d1fc6c20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60e611651584555d097ad3b2511ddea6d1fc6c20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60e611651584555d097ad3b2511ddea6d1fc6c20", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60e611651584555d097ad3b2511ddea6d1fc6c20/comments", "author": null, "committer": null, "parents": [{"sha": "04ae9e4ccd10764edd8330e6fa5351e5997f1ead", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04ae9e4ccd10764edd8330e6fa5351e5997f1ead", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04ae9e4ccd10764edd8330e6fa5351e5997f1ead"}], "stats": {"total": 48, "additions": 21, "deletions": 27}, "files": [{"sha": "b56577b459f3e5fea6af88e05e8b046582e3d1ae", "filename": "gcc/real.c", "status": "modified", "additions": 21, "deletions": 27, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60e611651584555d097ad3b2511ddea6d1fc6c20/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60e611651584555d097ad3b2511ddea6d1fc6c20/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=60e611651584555d097ad3b2511ddea6d1fc6c20", "patch": "@@ -778,9 +778,9 @@ ereal_from_int (d, i, j)\n \thigh += 1;\n     }\n   eldexp (eone, HOST_BITS_PER_WIDE_INT, df);\n-  ultoe (&high, dg);\n+  ultoe ((unsigned HOST_WIDE_INT *) &high, dg);\n   emul (dg, df, dg);\n-  ultoe (&low, df);\n+  ultoe ((unsigned HOST_WIDE_INT *) &low, df);\n   eadd (df, dg, dg);\n   if (sign)\n     eneg (dg);\n@@ -838,9 +838,9 @@ ereal_to_int (low, high, rr)\n     }\n   eldexp (eone, HOST_BITS_PER_WIDE_INT, df);\n   ediv (df, d, dg);\t\t/* dg = d / 2^32 is the high word */\n-  euifrac (dg, high, dh);\n+  euifrac (dg, (unsigned HOST_WIDE_INT *) high, dh);\n   emul (df, dh, dg);\t\t/* fractional part is the low word */\n-  euifrac (dg, low, dh);\n+  euifrac (dg, (unsigned HOST_WIDE_INT *)low, dh);\n   if (s)\n     {\n       /* complement and add 1 */\n@@ -1040,7 +1040,7 @@ etarsingle (r)\n      REAL_VALUE_TYPE r;\n {\n   unsigned EMUSHORT e[NE];\n-  unsigned long l;\n+  long l;\n \n   GET_REAL (&r, e);\n   etoe24 (e, e);\n@@ -5533,32 +5533,26 @@ ereal_from_double (d)\n #if FLOAT_WORDS_BIG_ENDIAN\n   s[0] = (unsigned EMUSHORT) (d[0] >> 16);\n   s[1] = (unsigned EMUSHORT) d[0];\n-  if (HOST_BITS_PER_WIDE_INT >= 64)\n-    {\n-      /* In this case the entire target double is contained in the\n-         first array element.  The second element of the input is ignored.  */\n-      s[2] = (unsigned EMUSHORT) (d[0] >> 48);\n-      s[3] = (unsigned EMUSHORT) (d[0] >> 32);\n-    }\n-  else\n-    {\n-      s[2] = (unsigned EMUSHORT) (d[1] >> 16);\n-      s[3] = (unsigned EMUSHORT) d[1];\n-    }\n+#if HOST_BITS_PER_WIDE_INT == 32\n+  s[2] = (unsigned EMUSHORT) (d[1] >> 16);\n+  s[3] = (unsigned EMUSHORT) d[1];\n+#else\n+  /* In this case the entire target double is contained in the\n+     first array element.  The second element of the input is ignored.  */\n+  s[2] = (unsigned EMUSHORT) (d[0] >> 48);\n+  s[3] = (unsigned EMUSHORT) (d[0] >> 32);\n+#endif\n #else\n /* Target float words are little-endian.  */\n   s[0] = (unsigned EMUSHORT) d[0];\n   s[1] = (unsigned EMUSHORT) (d[0] >> 16);\n-  if (HOST_BITS_PER_WIDE_INT >= 64)\n-    {\n-      s[2] = (unsigned EMUSHORT) (d[0] >> 32);\n-      s[3] = (unsigned EMUSHORT) (d[0] >> 48);\n-    }\n-  else\n-    {\n-      s[2] = (unsigned EMUSHORT) d[1];\n-      s[3] = (unsigned EMUSHORT) (d[1] >> 16);\n-    }\n+#if HOST_BITS_PER_WIDE_INT == 32\n+  s[2] = (unsigned EMUSHORT) d[1];\n+  s[3] = (unsigned EMUSHORT) (d[1] >> 16);\n+#else\n+  s[2] = (unsigned EMUSHORT) (d[0] >> 32);\n+  s[3] = (unsigned EMUSHORT) (d[0] >> 48);\n+#endif\n #endif\n   /* Convert target double to E-type. */\n   e53toe (s, e);"}]}