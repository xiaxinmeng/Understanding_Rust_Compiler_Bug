{"sha": "f88a8cfa39503d0d4e5a36cc8207983bea7ad70e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjg4YThjZmEzOTUwM2QwZDRlNWEzNmNjODIwNzk4M2JlYTdhZDcwZQ==", "commit": {"author": {"name": "Dorit Naishlos", "email": "dorit@il.ibm.com", "date": "2004-11-19T18:58:55Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2004-11-19T18:58:55Z"}, "message": "tree-vectorizer.c (slpeel_tree_peel_loop_to_edge): New name for function previously called tree_duplicate_loop_to_edge.\n\n        * tree-vectorizer.c (slpeel_tree_peel_loop_to_edge): New name for\n        function previously called tree_duplicate_loop_to_edge.\n        (slpeel_tree_duplicate_loop_to_edge_cfg): New name for function\n        previously called tree_duplicate_loop_to_edge_cfg.\n        (slpeel_update_phis_for_duplicate_loop): Prefix 'slpeel' added to\n        function name.\n        (slpeel_update_phi_nodes_for_guard): Likewise.\n        (slpeel_make_loop_iterate_ntimes): Likewise.\n        (slpeel_add_loop_guard): Likewise.\n        (allocate_new_names, free_new_names): Function declaration moved to top\n        of file.\n        (rename_use_op, rename_def_op): Likewise.\n        (rename_variables_in_bb, rename_variables_in_loop): Likewise.\n        (vect_generate_tmps_on_preheader): Function declaration moved.\n        (vect_transform_for_unknown_loop_bound): Added missing function\n        declaration.\n\nFrom-SVN: r90929", "tree": {"sha": "7b9fd006bb9ddf770b0407795e0f3755b2233625", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7b9fd006bb9ddf770b0407795e0f3755b2233625"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f88a8cfa39503d0d4e5a36cc8207983bea7ad70e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f88a8cfa39503d0d4e5a36cc8207983bea7ad70e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f88a8cfa39503d0d4e5a36cc8207983bea7ad70e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f88a8cfa39503d0d4e5a36cc8207983bea7ad70e/comments", "author": null, "committer": null, "parents": [{"sha": "33976614d615a6d473c9dbf9396e4a2a213c14a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33976614d615a6d473c9dbf9396e4a2a213c14a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33976614d615a6d473c9dbf9396e4a2a213c14a9"}], "stats": {"total": 158, "additions": 95, "deletions": 63}, "files": [{"sha": "30c378193a3dd575a05d01a0b635a8bd3ffa8205", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f88a8cfa39503d0d4e5a36cc8207983bea7ad70e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f88a8cfa39503d0d4e5a36cc8207983bea7ad70e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f88a8cfa39503d0d4e5a36cc8207983bea7ad70e", "patch": "@@ -1,3 +1,22 @@\n+2004-11-19  Dorit Naishlos  <dorit@il.ibm.com>\n+\n+\t* tree-vectorizer.c (slpeel_tree_peel_loop_to_edge): New name for\n+\tfunction previously called tree_duplicate_loop_to_edge.\n+\t(slpeel_tree_duplicate_loop_to_edge_cfg): New name for function\n+\tpreviously called tree_duplicate_loop_to_edge_cfg.\n+\t(slpeel_update_phis_for_duplicate_loop): Prefix 'slpeel' added to\n+\tfunction name.\n+\t(slpeel_update_phi_nodes_for_guard): Likewise.\n+\t(slpeel_make_loop_iterate_ntimes): Likewise.\n+\t(slpeel_add_loop_guard): Likewise.\n+\t(allocate_new_names, free_new_names): Function declaration moved to top\n+\tof file.\n+\t(rename_use_op, rename_def_op): Likewise.\n+\t(rename_variables_in_bb, rename_variables_in_loop): Likewise.\n+\t(vect_generate_tmps_on_preheader): Function declaration moved.\n+\t(vect_transform_for_unknown_loop_bound): Added missing function\n+\tdeclaration.\n+\n 2004-11-19  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \tPR tree-opt/18507"}, {"sha": "6ad918645c4a1f806d153de01a462e0a8ca30384", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 76, "deletions": 63, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f88a8cfa39503d0d4e5a36cc8207983bea7ad70e/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f88a8cfa39503d0d4e5a36cc8207983bea7ad70e/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=f88a8cfa39503d0d4e5a36cc8207983bea7ad70e", "patch": "@@ -146,6 +146,39 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"tree-vectorizer.h\"\n #include \"tree-pass.h\"\n \n+\n+/*************************************************************************\n+  Simple Loop Peeling Utilities\n+ *************************************************************************/\n+   \n+/* Entry point for peeling of simple loops.\n+   Peel the first/last iterations of a loop.\n+   It can be used outside of the vectorizer for loops that are simple enough\n+   (see function documentation).  In the vectorizer it is used to peel the\n+   last few iterations when the loop bound is unknown or does not evenly\n+   divide by the vectorization factor, and to peel the first few iterations\n+   to force the alignment of data references in the loop.  */\n+struct loop *slpeel_tree_peel_loop_to_edge \n+  (struct loop *, struct loops *, edge, tree, tree, bool);\n+static struct loop *slpeel_tree_duplicate_loop_to_edge_cfg \n+  (struct loop *, struct loops *, edge);\n+static void slpeel_update_phis_for_duplicate_loop \n+  (struct loop *, struct loop *, bool after);\n+static void slpeel_update_phi_nodes_for_guard (edge, struct loop *);\n+static void slpeel_make_loop_iterate_ntimes (struct loop *, tree, tree, tree);\n+static edge slpeel_add_loop_guard (basic_block, tree, basic_block);\n+static void allocate_new_names (bitmap);\n+static void rename_use_op (use_operand_p);\n+static void rename_def_op (def_operand_p, tree);\n+static void rename_variables_in_bb (basic_block);\n+static void free_new_names (bitmap);\n+static void rename_variables_in_loop (struct loop *);\n+\n+\n+/*************************************************************************\n+  Vectorization Utilities. \n+ *************************************************************************/\n+\n /* Main analysis functions.  */\n static loop_vec_info vect_analyze_loop (struct loop *);\n static loop_vec_info vect_analyze_loop_form (struct loop *);\n@@ -184,8 +217,8 @@ static bool vect_get_first_index (tree, tree *);\n static bool vect_can_force_dr_alignment_p (tree, unsigned int);\n static struct data_reference * vect_analyze_pointer_ref_access \n   (tree, tree, bool);\n-static bool vect_analyze_loop_with_symbolic_num_of_iters (tree niters, \n- \t\t\t\t\t\t\t  struct loop *loop);\n+static bool vect_analyze_loop_with_symbolic_num_of_iters \n+  (tree niters, struct loop *loop);\n static tree vect_get_base_and_bit_offset\n   (struct data_reference *, tree, tree, loop_vec_info, tree *, bool*);\n static struct data_reference * vect_analyze_pointer_ref_access\n@@ -212,47 +245,19 @@ static tree vect_build_symbol_bound (tree, int, struct loop *);\n static void vect_finish_stmt_generation \n   (tree stmt, tree vec_stmt, block_stmt_iterator *bsi);\n \n-static void vect_generate_tmps_on_preheader (loop_vec_info, \n-\t\t\t\t\t     tree *, tree *, \n-\t\t\t\t\t     tree *);\n+/* Utility function dealing with loop peeling (not peeling itself).  */\n+static void vect_generate_tmps_on_preheader \n+  (loop_vec_info, tree *, tree *, tree *);\n static tree vect_build_loop_niters (loop_vec_info);\n static void vect_update_ivs_after_vectorizer (struct loop *, tree); \n-\n-/* Loop transformations prior to vectorization.  */\n-\n-/* Loop transformations entry point function. \n-   It can be used outside of the vectorizer \n-   in case the loop to be manipulated answers conditions specified\n-   in function documentation.  */\n-struct loop *tree_duplicate_loop_to_edge (struct loop *, \n-\t\t\t\t\t  struct loops *, edge, \n-\t\t\t\t\t  tree, tree, bool);\n-\n-static void allocate_new_names (bitmap);\n-static void rename_use_op (use_operand_p);\n-static void rename_def_op (def_operand_p, tree);\n-static void rename_variables_in_bb (basic_block);\n-static void free_new_names (bitmap);\n-static void rename_variables_in_loop (struct loop *);\n-static void copy_phi_nodes (struct loop *, struct loop *, bool);\n-static void update_phis_for_duplicate_loop (struct loop *,\n-\t\t\t\t\t    struct loop *, \n-\t\t\t\t\t    bool after);\n-static void update_phi_nodes_for_guard (edge, struct loop *);  \n-static void make_loop_iterate_ntimes (struct loop *, tree, tree, tree);\n-static struct loop *tree_duplicate_loop_to_edge_cfg (struct loop *, \n-\t\t\t\t\t\t     struct loops *, \n-\t\t\t\t\t\t     edge);\n-static edge add_loop_guard (basic_block, tree, basic_block);\n-static bool verify_loop_for_duplication (struct loop *, bool, edge);\n-\n-/* Utilities dealing with loop peeling (not peeling itself).  */\n static tree vect_gen_niters_for_prolog_loop (loop_vec_info, tree);\n static void vect_update_niters_after_peeling (loop_vec_info, tree);\n-static void vect_update_inits_of_dr (struct data_reference *, struct loop *, \n-\t\t\t\t     tree niters);\n+static void vect_update_inits_of_dr \n+  (struct data_reference *, struct loop *, tree niters);\n static void vect_update_inits_of_drs (loop_vec_info, tree);\n static void vect_do_peeling_for_alignment (loop_vec_info, struct loops *);\n+static void vect_transform_for_unknown_loop_bound \n+  (loop_vec_info, tree *, struct loops *);\n \n /* Utilities for creation and deletion of vec_info structs.  */\n loop_vec_info new_loop_vec_info (struct loop *loop);\n@@ -263,7 +268,11 @@ static bool vect_debug_stats (struct loop *loop);\n static bool vect_debug_details (struct loop *loop);\n \n \f\n-/* Utilities to support loop peeling for vectorization purposes.  */\n+/*************************************************************************\n+  Simple Loop Peeling Utilities\n+\n+  Utilities to support loop peeling for vectorization purposes.\n+ *************************************************************************/\n \n \n /* For each definition in DEFINITIONS this function allocates \n@@ -463,8 +472,8 @@ copy_phi_nodes (struct loop *loop, struct loop *new_loop,\n    executes after LOOP, and false if it executes before it.  */\n \n static void\n-update_phis_for_duplicate_loop (struct loop *loop,\n-                                struct loop *new_loop, bool after)\n+slpeel_update_phis_for_duplicate_loop (struct loop *loop,\n+\t\t\t\t       struct loop *new_loop, bool after)\n {\n   edge old_latch;\n   tree *new_name_ptr, new_ssa_name;\n@@ -553,7 +562,7 @@ update_phis_for_duplicate_loop (struct loop *loop,\n    new edge from bb0 to bb4.  */\n \n static void\n-update_phi_nodes_for_guard (edge guard_true_edge, struct loop * loop)\n+slpeel_update_phi_nodes_for_guard (edge guard_true_edge, struct loop * loop)\n {\n   tree phi, phi1;\n   basic_block bb = loop->exit_edges[0]->dest;\n@@ -599,8 +608,8 @@ update_phi_nodes_for_guard (edge guard_true_edge, struct loop * loop)\n    that starts at zero, increases by one and its limit is NITERS.  */\n \n static void\n-make_loop_iterate_ntimes (struct loop *loop, tree niters,\n-\t\t\t  tree begin_label, tree exit_label)\n+slpeel_make_loop_iterate_ntimes (struct loop *loop, tree niters,\n+\t\t\t\t tree begin_label, tree exit_label)\n {\n   tree indx_before_incr, indx_after_incr, cond_stmt, cond;\n   tree orig_cond;\n@@ -645,8 +654,8 @@ make_loop_iterate_ntimes (struct loop *loop, tree niters,\n    on E which is either the entry or exit of LOOP.  */\n \n static struct loop *\n-tree_duplicate_loop_to_edge_cfg (struct loop *loop, struct loops *loops, \n-\t\t\t\t edge e)\n+slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *loop, struct loops *loops, \n+\t\t\t\t\tedge e)\n {\n   struct loop *new_loop;\n   basic_block *new_bbs, *bbs;\n@@ -765,7 +774,7 @@ tree_duplicate_loop_to_edge_cfg (struct loop *loop, struct loops *loops,\n    Returns the skip edge.  */\n \n static edge\n-add_loop_guard (basic_block guard_bb, tree cond, basic_block exit_bb)\n+slpeel_add_loop_guard (basic_block guard_bb, tree cond, basic_block exit_bb)\n {\n   block_stmt_iterator bsi;\n   edge new_e, enter_e;\n@@ -793,8 +802,8 @@ add_loop_guard (basic_block guard_bb, tree cond, basic_block exit_bb)\n /* This function verifies that certain restrictions apply to LOOP.  */\n \n static bool\n-verify_loop_for_duplication (struct loop *loop,\n-\t\t\t     bool update_first_loop_count, edge e)\n+slpeel_verify_loop_for_duplication (struct loop *loop,\n+\t\t\t\t    bool update_first_loop_count, edge e)\n {\n   edge exit_e = loop->exit_edges [0];\n   edge entry_e = loop_preheader_edge (loop);\n@@ -928,9 +937,9 @@ verify_loop_for_duplication (struct loop *loop,\n    transformations failed.  */\n    \n struct loop*\n-tree_duplicate_loop_to_edge (struct loop *loop, struct loops *loops, \n-\t\t\t     edge e, tree first_niters, \n-\t\t\t     tree niters, bool update_first_loop_count)\n+slpeel_tree_peel_loop_to_edge (struct loop *loop, struct loops *loops, \n+\t\t\t       edge e, tree first_niters, \n+\t\t\t       tree niters, bool update_first_loop_count)\n {\n   struct loop *new_loop = NULL, *first_loop, *second_loop;\n   edge skip_e;\n@@ -942,7 +951,7 @@ tree_duplicate_loop_to_edge (struct loop *loop, struct loops *loops,\n \n   gcc_assert (!any_marked_for_rewrite_p ());\n \n-  if (!verify_loop_for_duplication (loop, update_first_loop_count, e))\n+  if (!slpeel_verify_loop_for_duplication (loop, update_first_loop_count, e))\n       return NULL;\n \n   /* We have to initialize cfg_hooks. Then, when calling \n@@ -952,7 +961,7 @@ tree_duplicate_loop_to_edge (struct loop *loop, struct loops *loops,\n   tree_register_cfg_hooks ();\n \n   /* 1. Generate a copy of LOOP and put it on E (entry or exit).  */\n-  if (!(new_loop = tree_duplicate_loop_to_edge_cfg (loop, loops, e)))\n+  if (!(new_loop = slpeel_tree_duplicate_loop_to_edge_cfg (loop, loops, e)))\n     {\n       if (vect_debug_stats (loop) || vect_debug_details (loop))\t\n \tfprintf (dump_file,\n@@ -962,7 +971,7 @@ tree_duplicate_loop_to_edge (struct loop *loop, struct loops *loops,\n \n   definitions = marked_ssa_names ();\n   allocate_new_names (definitions);\n-  update_phis_for_duplicate_loop (loop, new_loop, e == exit_e);\n+  slpeel_update_phis_for_duplicate_loop (loop, new_loop, e == exit_e);\n   /* Here, using assumption (5), we do not propagate new names further \n      than on phis of the exit from the second loop.  */\n   rename_variables_in_loop (new_loop);\n@@ -994,7 +1003,7 @@ tree_duplicate_loop_to_edge (struct loop *loop, struct loops *loops,\n       tree first_loop_latch_lbl = tree_block_label (first_loop->latch);\n       tree first_loop_exit_lbl = tree_block_label (first_exit_bb);\n \n-      make_loop_iterate_ntimes (first_loop, first_niters,\n+      slpeel_make_loop_iterate_ntimes (first_loop, first_niters,\n \t\t\t\tfirst_loop_latch_lbl,\n \t\t\t\tfirst_loop_exit_lbl);\n     }\n@@ -1018,11 +1027,11 @@ tree_duplicate_loop_to_edge (struct loop *loop, struct loops *loops,\n \t\t\t   first_niters, integer_zero_node);\n \n   /* 4c. Add condition at the end of preheader bb.  */\n-  skip_e = add_loop_guard (pre_header_bb, pre_condition, first_exit_bb);\n+  skip_e = slpeel_add_loop_guard (pre_header_bb, pre_condition, first_exit_bb);\n \n   /* 4d. Update phis at first loop exit and propagate changes \n      to the phis of second loop.  */\n-  update_phi_nodes_for_guard (skip_e, first_loop);\n+  slpeel_update_phi_nodes_for_guard (skip_e, first_loop);\n \n   /* 5. Add the guard before second loop:\n \n@@ -1043,8 +1052,8 @@ tree_duplicate_loop_to_edge (struct loop *loop, struct loops *loops,\n \t\t\t   first_niters, niters);\n \n   /* 5c. Add condition at the end of preheader bb.  */\n-  skip_e = add_loop_guard (first_exit_bb, pre_condition, second_exit_bb);\n-  update_phi_nodes_for_guard (skip_e, second_loop);\n+  skip_e = slpeel_add_loop_guard (first_exit_bb, pre_condition, second_exit_bb);\n+  slpeel_update_phi_nodes_for_guard (skip_e, second_loop);\n \n   BITMAP_XFREE (definitions);\n   unmark_all_for_rewrite ();\n@@ -1056,6 +1065,10 @@ tree_duplicate_loop_to_edge (struct loop *loop, struct loops *loops,\n \f\n /* Here the proper Vectorizer starts.  */\n \n+/*************************************************************************\n+  Vectorization Utilities.\n+ *************************************************************************/\n+\n /* Function new_stmt_vec_info.\n \n    Create and initialize a new stmt_vec_info struct for STMT.  */\n@@ -3042,8 +3055,8 @@ vect_transform_for_unknown_loop_bound (loop_vec_info loop_vinfo, tree * ratio,\n #ifdef ENABLE_CHECKING\n   loop_num  = loop->num; \n #endif\n-  new_loop = tree_duplicate_loop_to_edge (loop, loops, loop->exit_edges[0],\n-\t\t\t\t\t  ratio_mult_vf_name, ni_name, true); \n+  new_loop = slpeel_tree_peel_loop_to_edge (loop, loops, loop->exit_edges[0],\n+\t\t\t\t\t    ratio_mult_vf_name, ni_name, true); \n #ifdef ENABLE_CHECKING\n   gcc_assert (new_loop);\n   gcc_assert (loop_num == loop->num);\n@@ -3227,8 +3240,8 @@ vect_do_peeling_for_alignment (loop_vec_info loop_vinfo, struct loops *loops)\n   \n \n   /* Peel the prolog loop and iterate it niters_of_prolog_loop.  */\n-  tree_duplicate_loop_to_edge (loop, loops, loop_preheader_edge(loop), \n-\t\t\t\t  niters_of_prolog_loop, ni_name, false); \n+  slpeel_tree_peel_loop_to_edge (loop, loops, loop_preheader_edge(loop), \n+\t\t\t\t niters_of_prolog_loop, ni_name, false); \n \n   /* Update number of times loop executes.  */\n   vect_update_niters_after_peeling (loop_vinfo, niters_of_prolog_loop);"}]}