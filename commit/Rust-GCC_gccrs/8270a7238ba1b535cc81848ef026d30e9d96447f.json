{"sha": "8270a7238ba1b535cc81848ef026d30e9d96447f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODI3MGE3MjM4YmExYjUzNWNjODE4NDhlZjAyNmQzMGU5ZDk2NDQ3Zg==", "commit": {"author": {"name": "Matthew Glazar", "email": "strager.nds@gmail.com", "date": "2020-11-14T04:59:05Z"}, "committer": {"name": "Jeff Law", "email": "law@torsion.usersys.redhat.com", "date": "2020-11-14T05:02:02Z"}, "message": "Simplify testing symbol sections\n\ngcc/testsuite\n\n\t* lib/scanasm.exp (dg-scan): Extract file globbing code ...\n\t(dg_glob_remote): ... into this new procedure.\n\t(scan-assembler-symbol-section): Define.\n\t(scan-symbol-section): Define.\n\t* g++.dg/gomp/tls-5.C: Add symbol section test.\n\t* g++.dg/opt/const4.C: Likewise.\n\t* gcc.dg/20021029-1.c: Likewise.\n\t* gcc.dg/array-quals-1.c: Likewise.\n\t* gcc.dg/darwin-sections.c: Likewise.\n\t* gcc.dg/pr25376.c: Likewise.\n\t* gcc.test-framework/test-framework.exp: Load scanasm and test .S files.\n\t* gcc.test-framework/dg-scan-symbol-section-1-exp-F.S: New test.\n\t* gcc.test-framework/dg-scan-symbol-section-2-exp-F.S: New test.\n\t* gcc.test-framework/dg-scan-symbol-section-3-exp-F.S: New test.\n\t* gcc.test-framework/dg-scan-symbol-section-exp-P.S: New test.", "tree": {"sha": "538a0af93d1ffce02df1b00f291cfad485a2c6a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/538a0af93d1ffce02df1b00f291cfad485a2c6a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8270a7238ba1b535cc81848ef026d30e9d96447f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8270a7238ba1b535cc81848ef026d30e9d96447f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8270a7238ba1b535cc81848ef026d30e9d96447f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8270a7238ba1b535cc81848ef026d30e9d96447f/comments", "author": {"login": "strager", "id": 48666, "node_id": "MDQ6VXNlcjQ4NjY2", "avatar_url": "https://avatars.githubusercontent.com/u/48666?v=4", "gravatar_id": "", "url": "https://api.github.com/users/strager", "html_url": "https://github.com/strager", "followers_url": "https://api.github.com/users/strager/followers", "following_url": "https://api.github.com/users/strager/following{/other_user}", "gists_url": "https://api.github.com/users/strager/gists{/gist_id}", "starred_url": "https://api.github.com/users/strager/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/strager/subscriptions", "organizations_url": "https://api.github.com/users/strager/orgs", "repos_url": "https://api.github.com/users/strager/repos", "events_url": "https://api.github.com/users/strager/events{/privacy}", "received_events_url": "https://api.github.com/users/strager/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "207de83922bda8707aa33d6a2185e691116377e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/207de83922bda8707aa33d6a2185e691116377e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/207de83922bda8707aa33d6a2185e691116377e7"}], "stats": {"total": 298, "additions": 292, "deletions": 6}, "files": [{"sha": "a1d3120fbfb1cfcb668bc01b24b870fb05e5dd40", "filename": "gcc/testsuite/g++.dg/gomp/tls-5.C", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8270a7238ba1b535cc81848ef026d30e9d96447f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftls-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8270a7238ba1b535cc81848ef026d30e9d96447f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftls-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftls-5.C?ref=8270a7238ba1b535cc81848ef026d30e9d96447f", "patch": "@@ -1,6 +1,8 @@\n // The reference temp should be TLS, not normal data.\n // { dg-require-effective-target c++11 }\n // { dg-final { scan-assembler-not \"\\\\.data\" { target tls_native xfail powerpc-*-aix* } } }\n+// { dg-final { scan-assembler-symbol-section {^_?ir$} {^\\.tbss} } }\n+// { dg-final { scan-assembler-symbol-section {^_?_ZGR2ir_$} {^\\.tdata} } }\n \n extern int&& ir;\n #pragma omp threadprivate (ir)"}, {"sha": "51d5313a312b536621bc5a896ae4c650cb75aa5f", "filename": "gcc/testsuite/g++.dg/opt/const4.C", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8270a7238ba1b535cc81848ef026d30e9d96447f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fconst4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8270a7238ba1b535cc81848ef026d30e9d96447f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fconst4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fconst4.C?ref=8270a7238ba1b535cc81848ef026d30e9d96447f", "patch": "@@ -3,7 +3,8 @@\n // that have it.\n // { dg-do compile }\n \n-const int a[] __attribute__ ((__used__)) = { 0, 1, 2, 3 };\n+// { dg-final { scan-assembler-symbol-section {constant_variable} {^\\.(const|rodata)} } }\n+const int constant_variable[] __attribute__ ((__used__)) = { 0, 1, 2, 3 };\n \n // The MMIX port always switches to the .data section at the end of a file.\n // { dg-final { scan-assembler-not \"\\\\.data(?!\\\\.rel\\\\.ro)\" { xfail powerpc*-*-aix* mmix-*-* } } }"}, {"sha": "c8ae4aa60e2ab292354fea3973d85997b502777d", "filename": "gcc/testsuite/gcc.dg/20021029-1.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8270a7238ba1b535cc81848ef026d30e9d96447f/gcc%2Ftestsuite%2Fgcc.dg%2F20021029-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8270a7238ba1b535cc81848ef026d30e9d96447f/gcc%2Ftestsuite%2Fgcc.dg%2F20021029-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2F20021029-1.c?ref=8270a7238ba1b535cc81848ef026d30e9d96447f", "patch": "@@ -3,6 +3,7 @@\n /* { dg-do compile { target fpic } } */\n /* { dg-options \"-O2 -fpic\" } */\n /* { dg-final { scan-assembler-not \".data.rel.ro.local\" } } */\n+/* { dg-final { scan-assembler-symbol-section {ar} {^\\.(const|rodata)} } } */\n /* { dg-require-effective-target label_values } */\n /* { dg-require-effective-target indirect_jumps } */\n "}, {"sha": "819bd24af76badbaf245e4fda3c6b426c5755fc1", "filename": "gcc/testsuite/gcc.dg/array-quals-1.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8270a7238ba1b535cc81848ef026d30e9d96447f/gcc%2Ftestsuite%2Fgcc.dg%2Farray-quals-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8270a7238ba1b535cc81848ef026d30e9d96447f/gcc%2Ftestsuite%2Fgcc.dg%2Farray-quals-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Farray-quals-1.c?ref=8270a7238ba1b535cc81848ef026d30e9d96447f", "patch": "@@ -6,26 +6,46 @@\n /* { dg-options \"-Wno-discarded-array-qualifiers\" } */\n /* The MMIX port always switches to the .data section at the end of a file.  */\n /* { dg-final { scan-assembler-not \"\\\\.data(?!\\\\.rel\\\\.ro)\" { xfail powerpc*-*-aix* mmix-*-* x86_64-*-mingw* } } } */\n+/* { dg-final { scan-assembler-symbol-section {^_?a$} {^\\.(const|rodata)} } } */\n static const int a[2] = { 1, 2 };\n+/* { dg-final { scan-assembler-symbol-section {^_?a1$} {^\\.(const|rodata)} } } */\n const int a1[2] = { 1, 2 };\n typedef const int ci;\n+/* { dg-final { scan-assembler-symbol-section {^_?b$} {^\\.(const|rodata)} } } */\n static ci b[2] = { 3, 4 };\n+/* { dg-final { scan-assembler-symbol-section {^_?b1$} {^\\.(const|rodata)} } } */\n ci b1[2] = { 3, 4 };\n typedef int ia[2];\n+/* { dg-final { scan-assembler-symbol-section {^_?c$} {^\\.(const|rodata)} } } */\n static const ia c = { 5, 6 };\n+/* { dg-final { scan-assembler-symbol-section {^_?c1$} {^\\.(const|rodata)} } } */\n const ia c1 = { 5, 6 };\n typedef const int cia[2];\n+/* { dg-final { scan-assembler-symbol-section {^_?d$} {^\\.(const|rodata)} } } */\n static cia d = { 7, 8 };\n+/* { dg-final { scan-assembler-symbol-section {^_?d1$} {^\\.(const|rodata)} } } */\n cia d1 = { 7, 8 };\n+/* { dg-final { scan-assembler-symbol-section {^_?e$} {^\\.(const|rodata)} } } */\n static cia e[2] = { { 1, 2 }, { 3, 4 } };\n+/* { dg-final { scan-assembler-symbol-section {^_?e1$} {^\\.(const|rodata)} } } */\n cia e1[2] = { { 1, 2 }, { 3, 4 } };\n+/* { dg-final { scan-assembler-symbol-section {^_?p$} {^\\.(const|rodata)} } } */\n void *const p = &a;\n+/* { dg-final { scan-assembler-symbol-section {^_?q$} {^\\.(const|rodata)} } } */\n void *const q = &b;\n+/* { dg-final { scan-assembler-symbol-section {^_?r$} {^\\.(const|rodata)} } } */\n void *const r = &c;\n+/* { dg-final { scan-assembler-symbol-section {^_?s$} {^\\.(const|rodata)} } } */\n void *const s = &d;\n+/* { dg-final { scan-assembler-symbol-section {^_?t$} {^\\.(const|rodata)} } } */\n void *const t = &e;\n+/* { dg-final { scan-assembler-symbol-section {^_?p1$} {^\\.(const|rodata)} } } */\n void *const p1 = &a1;\n+/* { dg-final { scan-assembler-symbol-section {^_?q1$} {^\\.(const|rodata)} } } */\n void *const q1 = &b1;\n+/* { dg-final { scan-assembler-symbol-section {^_?r1$} {^\\.(const|rodata)} } } */\n void *const r1 = &c1;\n+/* { dg-final { scan-assembler-symbol-section {^_?s1$} {^\\.(const|rodata)} } } */\n void *const s1 = &d1;\n+/* { dg-final { scan-assembler-symbol-section {^_?t1$} {^\\.(const|rodata)} } } */\n void *const t1 = &e1;"}, {"sha": "5fc28603f3fc7b1aa822b9a8d19df82dc8b4c378", "filename": "gcc/testsuite/gcc.dg/darwin-sections.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8270a7238ba1b535cc81848ef026d30e9d96447f/gcc%2Ftestsuite%2Fgcc.dg%2Fdarwin-sections.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8270a7238ba1b535cc81848ef026d30e9d96447f/gcc%2Ftestsuite%2Fgcc.dg%2Fdarwin-sections.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdarwin-sections.c?ref=8270a7238ba1b535cc81848ef026d30e9d96447f", "patch": "@@ -10,7 +10,9 @@ typedef struct _empty {} e_s;\n /* These should go in .comm */\n char ub;\n e_s ea;\n+/* { dg-final { scan-assembler-symbol-section {^_a$} {\\.data} } } */\n /* { dg-final { scan-assembler \".comm\\[\\t \\]_ub,1\" } } */\n+/* { dg-final { scan-assembler-symbol-section {^_b$} {\\.data} } } */\n /* { dg-final { scan-assembler \".comm\\[\\t \\]_ea,1\" } } */\n \n /* These should go into __DATA,__common */"}, {"sha": "25f1b66c9bd796e28cc46cea8bbf39dea6dd7320", "filename": "gcc/testsuite/gcc.dg/pr25376.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8270a7238ba1b535cc81848ef026d30e9d96447f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr25376.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8270a7238ba1b535cc81848ef026d30e9d96447f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr25376.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr25376.c?ref=8270a7238ba1b535cc81848ef026d30e9d96447f", "patch": "@@ -7,3 +7,4 @@ void simple (void)\n }\n \n /* { dg-final { scan-assembler \"my_named_section\" } } */\n+/* { dg-final { scan-assembler-symbol-section {simple$} {^my_named_section$} } } */"}, {"sha": "b4d5b47734858d20853400aa63d575aa49f27ee4", "filename": "gcc/testsuite/gcc.test-framework/dg-scan-symbol-section-1-exp-F.S", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8270a7238ba1b535cc81848ef026d30e9d96447f/gcc%2Ftestsuite%2Fgcc.test-framework%2Fdg-scan-symbol-section-1-exp-F.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8270a7238ba1b535cc81848ef026d30e9d96447f/gcc%2Ftestsuite%2Fgcc.test-framework%2Fdg-scan-symbol-section-1-exp-F.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.test-framework%2Fdg-scan-symbol-section-1-exp-F.S?ref=8270a7238ba1b535cc81848ef026d30e9d96447f", "patch": "@@ -0,0 +1,13 @@\n+// Test the scan-symbol-section directive.\n+// scan-symbol-section should fail with 'FAIL' if a symbol has a different\n+// section than expected.\n+\n+// { dg-do preprocess }\n+// { dg-final { scan-symbol-section \"dg-scan-symbol-section-1-exp-F.i\" {^_test_symbol_.*$} {nomatch} } }\n+// The above assertion should fail with the following messages:\n+// FAIL: gcc.test-framework/dg-scan-symbol-section-1-exp-F.S scan-symbol-section symbol ^_test_symbol_.*$ (found _test_symbol_1) has section nomatch (found .text)\n+// FAIL: gcc.test-framework/dg-scan-symbol-section-1-exp-F.S scan-symbol-section symbol ^_test_symbol_.*$ (found _test_symbol_2) has section nomatch (found .data)\n+    .text\n+_test_symbol_1:\n+    .data\n+_test_symbol_2:"}, {"sha": "01872751d4da4897f47defb7867c021cb8e4e070", "filename": "gcc/testsuite/gcc.test-framework/dg-scan-symbol-section-2-exp-F.S", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8270a7238ba1b535cc81848ef026d30e9d96447f/gcc%2Ftestsuite%2Fgcc.test-framework%2Fdg-scan-symbol-section-2-exp-F.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8270a7238ba1b535cc81848ef026d30e9d96447f/gcc%2Ftestsuite%2Fgcc.test-framework%2Fdg-scan-symbol-section-2-exp-F.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.test-framework%2Fdg-scan-symbol-section-2-exp-F.S?ref=8270a7238ba1b535cc81848ef026d30e9d96447f", "patch": "@@ -0,0 +1,9 @@\n+// Test the scan-symbol-section directive.\n+// scan-symbol-section should fail with 'UNSUPPORTED' if a symbol has no\n+// associated section.\n+\n+// { dg-do preprocess }\n+// { dg-final { scan-symbol-section \"dg-scan-symbol-section-2-exp-F.i\" {^_test_symbol$} {^\\.text$} } }\n+// The above assertion should fail with the following message:\n+// FAIL: gcc.test-framework/dg-scan-symbol-section-2-exp-F.S scan-symbol-section symbol ^_test_symbol$ (found _test_symbol) has section ^\\\\.text$ (no section detected)\n+_test_symbol:"}, {"sha": "87b09a339489f57ea79c5a7855261c4356db8739", "filename": "gcc/testsuite/gcc.test-framework/dg-scan-symbol-section-3-exp-F.S", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8270a7238ba1b535cc81848ef026d30e9d96447f/gcc%2Ftestsuite%2Fgcc.test-framework%2Fdg-scan-symbol-section-3-exp-F.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8270a7238ba1b535cc81848ef026d30e9d96447f/gcc%2Ftestsuite%2Fgcc.test-framework%2Fdg-scan-symbol-section-3-exp-F.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.test-framework%2Fdg-scan-symbol-section-3-exp-F.S?ref=8270a7238ba1b535cc81848ef026d30e9d96447f", "patch": "@@ -0,0 +1,10 @@\n+// Test the scan-symbol-section directive.\n+// scan-symbol-section should fail with 'UNSUPPORTED' if a symbol has no\n+// associated section.\n+\n+// { dg-do preprocess }\n+// { dg-final { scan-symbol-section \"dg-scan-symbol-section-3-exp-F.i\" {^_test_symbol$} {^\\.text$} } }\n+// The above assertion should fail with the following message:\n+// FAIL: gcc.test-framework/dg-scan-symbol-section-3-exp-F.S scan-symbol-section symbol ^_test_symbol$ (no symbol detected) has section ^\\\\.text$\n+    .text\n+_test_wrong_symbol:"}, {"sha": "4e7df419651fb192256a57a3b07a004f3fc08127", "filename": "gcc/testsuite/gcc.test-framework/dg-scan-symbol-section-exp-P.S", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8270a7238ba1b535cc81848ef026d30e9d96447f/gcc%2Ftestsuite%2Fgcc.test-framework%2Fdg-scan-symbol-section-exp-P.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8270a7238ba1b535cc81848ef026d30e9d96447f/gcc%2Ftestsuite%2Fgcc.test-framework%2Fdg-scan-symbol-section-exp-P.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.test-framework%2Fdg-scan-symbol-section-exp-P.S?ref=8270a7238ba1b535cc81848ef026d30e9d96447f", "patch": "@@ -0,0 +1,50 @@\n+// Test the scan-symbol-section directive.\n+\n+// { dg-do preprocess }\n+\n+// The .section directive changes the section for all following symbols.\n+    .section .text\n+// { dg-final { scan-symbol-section \"dg-scan-symbol-section-exp-P.i\" {^_test_function_1$} {^\\.text$} } }\n+_test_function_1:\n+// { dg-final { scan-symbol-section \"dg-scan-symbol-section-exp-P.i\" {^_test_function_2$} {^\\.text$} } }\n+_test_function_2:\n+\n+// For ELF targets, the .section directive can take multiple arguments.\n+    .section .other_text_section,\"ax\",progbits\n+// { dg-final { scan-symbol-section \"dg-scan-symbol-section-exp-P.i\" {^_test_elf_function$} {^\\.other_text_section$} } }\n+_test_elf_function:\n+\n+// For Mach-O targets, the .section directive takes a segment name and a section name.\n+    .section __TEXT,__my_text_section\n+// { dg-final { scan-symbol-section \"dg-scan-symbol-section-exp-P.i\" {^_test_macho_function$} {^__TEXT,__my_text_section$} } }\n+_test_macho_function:\n+// Extra whitespace between .section arguments should be ignored.\n+    .section  __DATA , __testsection\n+// { dg-final { scan-symbol-section \"dg-scan-symbol-section-exp-P.i\" {^_test_macho_var$} {^__DATA,__testsection$} } }\n+_test_macho_var:\n+\n+// The .data directive sets the section for all following symbols to '.data'.\n+// { dg-final { scan-symbol-section \"dg-scan-symbol-section-exp-P.i\" {^_test_var_1$} {^\\.data$} } }\n+    .data\n+_test_var_1:\n+\n+// The .text directive sets the section for all following symbols to '.text'.\n+// { dg-final { scan-symbol-section \"dg-scan-symbol-section-exp-P.i\" {^_test_function_3$} {^\\.text$} } }\n+    .text\n+_test_function_3:\n+\n+// The .const directive sets the section for all following symbols to '.const'.\n+// { dg-final { scan-symbol-section \"dg-scan-symbol-section-exp-P.i\" {^_test_data_1$} {^\\.const$} } }\n+    .const\n+_test_data_1:\n+\n+// Other directives do not affect the section of following symbols.\n+// { dg-final { scan-symbol-section \"dg-scan-symbol-section-exp-P.i\" {^_test_var_2$} {^\\.data$} } }\n+    .data\n+    .p2align 2\n+    .size _test_var_2, 4\n+_test_var_2:\n+\n+// Symbol name patterns can match multiple symbols, and section name patterns\n+// can match multiple sections.\n+// { dg-final { scan-symbol-section \"dg-scan-symbol-section-exp-P.i\" {^_test_function_} {^(\\.|__TEXT,).*text} } }"}, {"sha": "45328bf6d1c6c2acaf23956c8ce80e1eae9f7e36", "filename": "gcc/testsuite/gcc.test-framework/test-framework.exp", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8270a7238ba1b535cc81848ef026d30e9d96447f/gcc%2Ftestsuite%2Fgcc.test-framework%2Ftest-framework.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8270a7238ba1b535cc81848ef026d30e9d96447f/gcc%2Ftestsuite%2Fgcc.test-framework%2Ftest-framework.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.test-framework%2Ftest-framework.exp?ref=8270a7238ba1b535cc81848ef026d30e9d96447f", "patch": "@@ -23,6 +23,7 @@ if { ![info exists env(CHECK_TEST_FRAMEWORK)] } {\n }\n \n load_lib gcc-dg.exp\n+load_lib scanasm.exp\n \n proc dg-require-true { args } {\n     verbose \"dg-require-true\" 2\n@@ -59,7 +60,7 @@ set dg-do-what-default compile\n dg-init\n \n # Run tests from the source directory.\n-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/dg-*.c]] \"\" \"\"\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/dg-*.S $srcdir/$subdir/dg-*.c]] \"\" \"\"\n \n # Skip generated tests unless CHECK_TEST_FRAMEWORK is 1.\n if { $env(CHECK_TEST_FRAMEWORK) != 1 } {"}, {"sha": "5fb145539f4a80b840490effee3acdc79f3df256", "filename": "gcc/testsuite/lib/scanasm.exp", "status": "modified", "additions": 180, "deletions": 4, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8270a7238ba1b535cc81848ef026d30e9d96447f/gcc%2Ftestsuite%2Flib%2Fscanasm.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8270a7238ba1b535cc81848ef026d30e9d96447f/gcc%2Ftestsuite%2Flib%2Fscanasm.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fscanasm.exp?ref=8270a7238ba1b535cc81848ef026d30e9d96447f", "patch": "@@ -52,10 +52,7 @@ proc dg-scan { name positive testcase output_file orig_args } {\n     set pattern [lindex $orig_args 0]\n     set printable_pattern [make_pattern_printable $pattern]\n \n-    if { [is_remote host] } {\n-\tremote_upload host \"$output_file\"\n-    } \n-    set files [glob -nocomplain $output_file]\n+    set files [dg_glob_remote $output_file]\n     if { $files == \"\" } {\n \tverbose -log \"$testcase: output file does not exist\"\n \tunresolved \"$testcase $name $printable_pattern\"\n@@ -73,6 +70,13 @@ proc dg-scan { name positive testcase output_file orig_args } {\n     }\n }\n \n+proc dg_glob_remote { file_pattern } {\n+    if { [is_remote host] } {\n+    remote_upload host $file_pattern\n+    }\n+    return [glob -nocomplain $file_pattern]\n+}\n+\n # Look for a pattern in the .s file produced by the compiler.  See\n # dg-scan for details.\n \n@@ -155,6 +159,178 @@ proc scan-not-hidden { args } {\n     dg-scan \"scan-not-hidden\" 0 $testcase $output_file $args\n }\n \n+# Check that symbols are emitted in the desired section.\n+# Like scan-symbol-section, but using the assembly output generated by\n+# the compiler.\n+#\n+# Example:\n+#\n+# // All numbered functions (func1, func2, etc.) must be in the .text section or\n+# // in a .text sub-section (like .text._func1).\n+# { dg-final { scan-assembler-symbol-section {^_func[1-5]$} {^\\.text($|\\.)} } }\n+\n+proc scan-assembler-symbol-section { args } {\n+    set testcase [testname-for-summary]\n+    set filename [lindex $testcase 0]\n+    set output_file \"[file rootname [file tail $filename]].s\"\n+    set symbol_pattern [lindex $args 0]\n+    set expected_section_pattern [lindex $args 1]\n+    dg-scan-symbol-section \\\n+    \"scan-assembler-symbol-section\" \\\n+    $testcase \\\n+    $output_file \\\n+    $symbol_pattern \\\n+    $expected_section_pattern\n+}\n+\n+# Check that symbols are emitted in the desired section.\n+#\n+# Symbols and sections are interpreted as regexp patterns.\n+#\n+# If no matching symbol is found, scan-symbol-section reports a FAILure.\n+#\n+# Usage:\n+#\n+# { dg-final { scan-symbol-section FILENAME SYMBOL SECTION } }\n+#\n+# Examples:\n+#\n+# // The my_var C symbol must be in the .data section (or in a .data._my_var section\n+# // if -ffunction-sections is in use).\n+# { dg-final { scan-symbol-section \"my-test.s\" {^_my_var$} {^\\.data(\\._my_var)?$} } }\n+#\n+# // All numbered functions (func1, func2, etc.) must be in the .text section\n+# // (and not in any other section like .text._func1).\n+# { dg-final { scan-symbol-section \"my-test.s\" {^_func[1-5]$} {^\\.text$} } }\n+#\n+# Caveats:\n+#\n+# * Only ELF and Mach-O targets are supported. Other\n+#   targets, like PE/COFF, might appear to work.\n+# * For Mach-O targets, the section name matched by scan-symbol-section has one\n+#   of two forms:\n+#   * The Mach-O segment name followed by a comma (',') followed by the Mach-O\n+#     section name. For example, \"__TEXT,__text\". (There is no whitespace\n+#     between the Mach-O segment name and the Mach-O section name.)\n+#   * \".const\", \".data\", or \".text\". For example, the .text assembler directive\n+#     causes the section name to be \".text\" (not \"__TEXT,__text\"). (However, a\n+#     directive such as .section __TEXT,__text will cause the section name to be\n+#     \"__TEXT,__text\".)\n+# * Because scan-symbol-section parses assembly code, scan-symbol-section is\n+#   unaware of section rewriting performed by the linker. For example, the\n+#   sections .text._f1 and .text._f2 would normally be merged by binutils'\n+#   linker into one section called .text, but scan-symbol-section reports the\n+#   sections as .text._f1 and .text._f2 (and not .text).\n+# * The symbol pattern matches any assembly label, including local labels which\n+#   begin with `.L`.\n+\n+proc scan-symbol-section { args } {\n+    set testcase [testname-for-summary]\n+    set output_file [lindex $args 0]\n+    set symbol_pattern [lindex $args 1]\n+    set expected_section_pattern [lindex $args 2]\n+    dg-scan-symbol-section \\\n+    \"scan-symbol-section\" \\\n+    $testcase \\\n+    $output_file \\\n+    $symbol_pattern \\\n+    $expected_section_pattern\n+}\n+\n+# Check that symbols are emitted in the desired section.\n+#\n+# Avoid calling this function directly. In tests, use scan-symbol-section,\n+# scan-assembler-symbol-section, or scan-lto-assembler-symbol-section instead.\n+\n+proc dg-scan-symbol-section { name testcase output_file symbol_pattern expected_section_pattern } {\n+    set printable_symbol_pattern [make_pattern_printable $symbol_pattern]\n+    set printable_expected_section_pattern [make_pattern_printable $expected_section_pattern]\n+\n+    set files [dg_glob_remote $output_file]\n+    if { $files == \"\" } {\n+    verbose -log \"$testcase: output file does not exist\"\n+    unresolved \"$testcase $name symbol $printable_symbol_pattern has section $printable_expected_section_pattern\"\n+    return\n+    }\n+\n+    parse_section_of_symbols $output_file section_by_symbol\n+\n+    set found_symbol 0\n+    foreach symbol_name [lsort [array names section_by_symbol]] {\n+        if { [regexp -- $symbol_pattern $symbol_name] } {\n+            set section $section_by_symbol($symbol_name)\n+            set description \"$testcase $name symbol $printable_symbol_pattern (found $symbol_name) has section $printable_expected_section_pattern\"\n+            if { $section == \"\" } {\n+                fail \"$description (no section detected)\"\n+            } else {\n+                set description \"$description (found $section)\"\n+                if { [regexp -- $expected_section_pattern $section] } {\n+                    pass $description\n+                } else {\n+                    fail $description\n+                }\n+            }\n+            set found_symbol 1\n+        }\n+    }\n+    if { ! $found_symbol } {\n+        fail \"$testcase $name symbol $printable_symbol_pattern (symbol not found) has section $printable_expected_section_pattern\"\n+    }\n+}\n+\n+# Extract a symbol and section names from pre-processed assembly source code.\n+#\n+# This function adds entries in the RESULT array where the key is the symbol's\n+# name (including any leading underscores) and the value is the section's name\n+# (including any leading periods).\n+#\n+# For example, given the following assembly source code in file.s:\n+#\n+#         .text\n+#         .function _my_function\n+# _my_function:\n+#         nop\n+#         .data\n+# _my_data:\n+#         .long 42\n+#\n+# Executing 'parse_section_of_symbols \"file.s\" symbols' would have the same\n+# effect as the following code:\n+#\n+# set $result(_my_function) .text\n+# set $result(_my_data) .data\n+\n+proc parse_section_of_symbols { filename result } {\n+    upvar $result up_result\n+\n+    set section_pattern {^\\s*(?:\\.section\\s+(.*)|(\\.const|\\.data|\\.text)\\s*)$}\n+    set label_pattern {^(\\S+):$}\n+\n+    set fd [open $filename r]\n+    set current_section \"\"\n+    while { [gets $fd line] >= 0 } {\n+        if { [regexp -- $label_pattern $line dummy symbol_name] } {\n+            set up_result($symbol_name) $current_section\n+        } elseif { [regexp -- $section_pattern $line dummy section_directive_arguments full_section_directive] } {\n+            if { $full_section_directive eq \"\" } {\n+                # Example: .section .text,\"ax\",progbits\n+                # Example: .section __TEXT,__text\n+                set arguments [split $section_directive_arguments \",\"]\n+                set current_section [string trim [lindex $arguments 0]]\n+                set arg_1 [string trim [lindex $arguments 1]]\n+                if { [regexp {^_} $arg_1] } {\n+                    # The second argument looks like a Mach-O section name.\n+                    set current_section \"$current_section,$arg_1\"\n+                }\n+            } else {\n+                # Example: .text\n+                set current_section \"$full_section_directive\"\n+            }\n+        }\n+    }\n+    close $fd\n+}\n+\n # Look for a pattern in OUTPUT_FILE.  See dg-scan for details.\n \n proc scan-file { output_file args } {"}]}