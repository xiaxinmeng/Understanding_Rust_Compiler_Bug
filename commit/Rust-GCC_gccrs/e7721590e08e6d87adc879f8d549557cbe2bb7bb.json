{"sha": "e7721590e08e6d87adc879f8d549557cbe2bb7bb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTc3MjE1OTBlMDhlNmQ4N2FkYzg3OWY4ZDU0OTU1N2NiZTJiYjdiYg==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2021-08-23T11:44:37Z"}, "committer": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2021-08-23T11:44:37Z"}, "message": "Improved handling of division/modulus in bit CCP.\n\nThis patch implements support for TRUNC_MOD_EXPR and TRUNC_DIV_EXPR\nin tree-ssa's bit CCP pass.  This is mostly for completeness, as the\nVRP pass already provides better bounds for these operations, but\nseeing mask values of all_ones in my debugging/instrumentation logs\nseemed overly pessimistic.  With this patch, the expression X%10\nhas a nonzero bits of 0x0f (for unsigned X), likewise (X&1)/3 has\na known value of zero, and (X&3)/3 has a nonzero bits mask of 0x1.\n\n2021-08-23  Roger Sayle  <roger@nextmovesoftware.com>\n\ngcc/ChangeLog\n\t* tree-ssa-ccp.c (bit_value_binop) [TRUNC_MOD_EXPR, TRUNC_DIV_EXPR]:\n\tProvide bounds for unsigned (and signed with non-negative operands)\n\tdivision and modulus.", "tree": {"sha": "e07bef1270a6c92bb4bfff28434b3431e4945414", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e07bef1270a6c92bb4bfff28434b3431e4945414"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e7721590e08e6d87adc879f8d549557cbe2bb7bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7721590e08e6d87adc879f8d549557cbe2bb7bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7721590e08e6d87adc879f8d549557cbe2bb7bb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7721590e08e6d87adc879f8d549557cbe2bb7bb/comments", "author": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e5f9ead16d7514b3baa0254084de94f0bfcd216", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e5f9ead16d7514b3baa0254084de94f0bfcd216", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e5f9ead16d7514b3baa0254084de94f0bfcd216"}], "stats": {"total": 62, "additions": 62, "deletions": 0}, "files": [{"sha": "1a94aebb0e4621322ab6a1a37424a1d80d6f3248", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7721590e08e6d87adc879f8d549557cbe2bb7bb/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7721590e08e6d87adc879f8d549557cbe2bb7bb/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=e7721590e08e6d87adc879f8d549557cbe2bb7bb", "patch": "@@ -1736,6 +1736,68 @@ bit_value_binop (enum tree_code code, signop sgn, int width,\n \tbreak;\n       }\n \n+    case TRUNC_MOD_EXPR:\n+      {\n+\twidest_int r1max = r1val | r1mask;\n+\twidest_int r2max = r2val | r2mask;\n+\tif (sgn == UNSIGNED\n+\t    || (!wi::neg_p (r1max) && !wi::neg_p (r2max)))\n+\t  {\n+\t    /* Confirm R2 has some bits set, to avoid division by zero.  */\n+\t    widest_int r2min = wi::bit_and_not (r2val, r2mask);\n+\t    if (r2min != 0)\n+\t      {\n+\t\t/* R1 % R2 is R1 if R1 is always less than R2.  */\n+\t\tif (wi::ltu_p (r1max, r2min))\n+\t\t  {\n+\t\t    *mask = r1mask;\n+\t\t    *val = r1val;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    /* R1 % R2 is always less than the maximum of R2.  */\n+\t\t    unsigned int lzcount = wi::clz (r2max);\n+\t\t    unsigned int bits = wi::get_precision (r2max) - lzcount;\n+\t\t    if (r2max == wi::lshift (1, bits))\n+\t\t      bits--;\n+\t\t    *mask = wi::mask <widest_int> (bits, false);\n+\t\t    *val = 0;\n+\t\t  }\n+\t       }\n+\t    }\n+\t}\n+      break;\n+\n+    case TRUNC_DIV_EXPR:\n+      {\n+\twidest_int r1max = r1val | r1mask;\n+\twidest_int r2max = r2val | r2mask;\n+\tif (sgn == UNSIGNED\n+\t    || (!wi::neg_p (r1max) && !wi::neg_p (r2max)))\n+\t  {\n+\t    /* Confirm R2 has some bits set, to avoid division by zero.  */\n+\t    widest_int r2min = wi::bit_and_not (r2val, r2mask);\n+\t    if (r2min != 0)\n+\t      {\n+\t\t/* R1 / R2 is zero if R1 is always less than R2.  */\n+\t\tif (wi::ltu_p (r1max, r2min))\n+\t\t  {\n+\t\t    *mask = 0;\n+\t\t    *val = 0;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    widest_int upper = wi::udiv_trunc (r1max, r2min);\n+\t\t    unsigned int lzcount = wi::clz (upper);\n+\t\t    unsigned int bits = wi::get_precision (upper) - lzcount;\n+\t\t    *mask = wi::mask <widest_int> (bits, false);\n+\t\t    *val = 0;\n+\t\t  }\n+\t       }\n+\t    }\n+\t}\n+      break;\n+\n     default:;\n     }\n }"}]}