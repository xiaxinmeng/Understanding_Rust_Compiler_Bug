{"sha": "0c2b1bb7b665e77a4f0ebe462447abab90b87ecf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGMyYjFiYjdiNjY1ZTc3YTRmMGViZTQ2MjQ0N2FiYWI5MGI4N2VjZg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-05-06T01:14:34Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-05-06T01:14:34Z"}, "message": "compiler: Use backend interface for array length.\n\nFrom-SVN: r210093", "tree": {"sha": "a1a3d3366149c1edfb32fc9dda9279363a2182ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a1a3d3366149c1edfb32fc9dda9279363a2182ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c2b1bb7b665e77a4f0ebe462447abab90b87ecf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c2b1bb7b665e77a4f0ebe462447abab90b87ecf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c2b1bb7b665e77a4f0ebe462447abab90b87ecf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c2b1bb7b665e77a4f0ebe462447abab90b87ecf/comments", "author": null, "committer": null, "parents": [{"sha": "9239c1b47dd6fe540d7035d1c9a1f393122affb7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9239c1b47dd6fe540d7035d1c9a1f393122affb7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9239c1b47dd6fe540d7035d1c9a1f393122affb7"}], "stats": {"total": 110, "additions": 48, "deletions": 62}, "files": [{"sha": "0ff9c76d68b1580dc4c13ba7fe9131797e9e5db3", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 43, "deletions": 55, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c2b1bb7b665e77a4f0ebe462447abab90b87ecf/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c2b1bb7b665e77a4f0ebe462447abab90b87ecf/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=0c2b1bb7b665e77a4f0ebe462447abab90b87ecf", "patch": "@@ -245,7 +245,7 @@ Type::points_to() const\n   return ptype == NULL ? NULL : ptype->points_to();\n }\n \n-// Return whether this is an open array type.\n+// Return whether this is a slice type.\n \n bool\n Type::is_slice_type() const\n@@ -5839,54 +5839,6 @@ Array_type::write_equal_function(Gogo* gogo, Named_type* name)\n   gogo->add_statement(s);\n }\n \n-// Get a tree for the length of a fixed array.  The length may be\n-// computed using a function call, so we must only evaluate it once.\n-\n-tree\n-Array_type::get_length_tree(Gogo* gogo)\n-{\n-  go_assert(this->length_ != NULL);\n-  if (this->length_tree_ == NULL_TREE)\n-    {\n-      Numeric_constant nc;\n-      mpz_t val;\n-      if (this->length_->numeric_constant_value(&nc) && nc.to_int(&val))\n-\t{\n-\t  if (mpz_sgn(val) < 0)\n-\t    {\n-\t      this->length_tree_ = error_mark_node;\n-\t      return this->length_tree_;\n-\t    }\n-\t  Type* t = nc.type();\n-\t  if (t == NULL)\n-\t    t = Type::lookup_integer_type(\"int\");\n-\t  else if (t->is_abstract())\n-\t    t = t->make_non_abstract_type();\n-          Btype* btype = t->get_backend(gogo);\n-          Bexpression* iexpr =\n-              gogo->backend()->integer_constant_expression(btype, val);\n-\t  this->length_tree_ = expr_to_tree(iexpr);\n-\t  mpz_clear(val);\n-\t}\n-      else\n-\t{\n-\t  // Make up a translation context for the array length\n-\t  // expression.  FIXME: This won't work in general.\n-\t  Translate_context context(gogo, NULL, NULL, NULL);\n-\t  tree len = this->length_->get_tree(&context);\n-\t  if (len != error_mark_node)\n-\t    {\n-\t      Type* int_type = Type::lookup_integer_type(\"int\");\n-\t      tree int_type_tree = type_to_tree(int_type->get_backend(gogo));\n-\t      len = convert_to_integer(int_type_tree, len);\n-\t      len = save_expr(len);\n-\t    }\n-\t  this->length_tree_ = len;\n-\t}\n-    }\n-  return this->length_tree_;\n-}\n-\n // Get the backend representation of the fields of a slice.  This is\n // not declared in types.h so that types.h doesn't have to #include\n // backend.h.\n@@ -5927,7 +5879,7 @@ get_backend_slice_fields(Gogo* gogo, Array_type* type, bool use_placeholder,\n \n // Get a tree for the type of this array.  A fixed array is simply\n // represented as ARRAY_TYPE with the appropriate index--i.e., it is\n-// just like an array in C.  An open array is a struct with three\n+// just like an array in C.  A slice is a struct with three\n // fields: a data pointer, the length, and the capacity.\n \n Btype*\n@@ -5958,12 +5910,48 @@ Array_type::get_backend_element(Gogo* gogo, bool use_placeholder)\n     return this->element_type_->get_backend(gogo);\n }\n \n-// Return the backend representation of the length.\n+// Return the backend representation of the length. The length may be\n+// computed using a function call, so we must only evaluate it once.\n \n Bexpression*\n Array_type::get_backend_length(Gogo* gogo)\n {\n-  return tree_to_expr(this->get_length_tree(gogo));\n+  go_assert(this->length_ != NULL);\n+  if (this->blength_ == NULL)\n+    {\n+      Numeric_constant nc;\n+      mpz_t val;\n+      if (this->length_->numeric_constant_value(&nc) && nc.to_int(&val))\n+\t{\n+\t  if (mpz_sgn(val) < 0)\n+\t    {\n+\t      this->blength_ = gogo->backend()->error_expression();\n+\t      return this->blength_;\n+\t    }\n+\t  Type* t = nc.type();\n+\t  if (t == NULL)\n+\t    t = Type::lookup_integer_type(\"int\");\n+\t  else if (t->is_abstract())\n+\t    t = t->make_non_abstract_type();\n+          Btype* btype = t->get_backend(gogo);\n+          this->blength_ =\n+\t    gogo->backend()->integer_constant_expression(btype, val);\n+\t  mpz_clear(val);\n+\t}\n+      else\n+\t{\n+\t  // Make up a translation context for the array length\n+\t  // expression.  FIXME: This won't work in general.\n+\t  Translate_context context(gogo, NULL, NULL, NULL);\n+\t  this->blength_ = tree_to_expr(this->length_->get_tree(&context));\n+\n+\t  Btype* ibtype = Type::lookup_integer_type(\"int\")->get_backend(gogo);\n+\t  this->blength_ =\n+\t    gogo->backend()->convert_expression(ibtype, this->blength_,\n+\t\t\t\t\t\tthis->length_->location());\n+\t}\n+    }\n+  return this->blength_;\n }\n \n // Finish backend representation of the array.\n@@ -5997,7 +5985,7 @@ Array_type::get_value_pointer(Gogo*, Expression* array) const\n                                    array->location());\n     }\n \n-  // Open array.\n+  // Slice.\n   return Expression::make_slice_info(array,\n                                      Expression::SLICE_INFO_VALUE_POINTER,\n                                      array->location());\n@@ -6012,7 +6000,7 @@ Array_type::get_length(Gogo*, Expression* array) const\n   if (this->length_ != NULL)\n     return this->length_;\n \n-  // This is an open array.  We need to read the length field.\n+  // This is a slice.  We need to read the length field.\n   return Expression::make_slice_info(array, Expression::SLICE_INFO_LENGTH,\n                                      array->location());\n }\n@@ -6026,7 +6014,7 @@ Array_type::get_capacity(Gogo*, Expression* array) const\n   if (this->length_ != NULL)\n     return this->length_;\n \n-  // This is an open array.  We need to read the capacity field.\n+  // This is a slice.  We need to read the capacity field.\n   return Expression::make_slice_info(array, Expression::SLICE_INFO_CAPACITY,\n                                      array->location());\n }"}, {"sha": "b2a49ac3af11ccebbb54e5ac9f575e56702304c3", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c2b1bb7b665e77a4f0ebe462447abab90b87ecf/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c2b1bb7b665e77a4f0ebe462447abab90b87ecf/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=0c2b1bb7b665e77a4f0ebe462447abab90b87ecf", "patch": "@@ -2305,15 +2305,15 @@ class Array_type : public Type\n  public:\n   Array_type(Type* element_type, Expression* length)\n     : Type(TYPE_ARRAY),\n-      element_type_(element_type), length_(length), length_tree_(NULL)\n+      element_type_(element_type), length_(length), blength_(NULL)\n   { }\n \n   // Return the element type.\n   Type*\n   element_type() const\n   { return this->element_type_; }\n \n-  // Return the length.  This will return NULL for an open array.\n+  // Return the length.  This will return NULL for a slice.\n   Expression*\n   length() const\n   { return this->length_; }\n@@ -2407,9 +2407,6 @@ class Array_type : public Type\n   bool\n   verify_length();\n \n-  tree\n-  get_length_tree(Gogo*);\n-\n   Expression*\n   array_type_descriptor(Gogo*, Named_type*);\n \n@@ -2420,8 +2417,9 @@ class Array_type : public Type\n   Type* element_type_;\n   // The number of elements.  This may be NULL.\n   Expression* length_;\n-  // The length as a tree.  We only want to compute this once.\n-  tree length_tree_;\n+  // The backend representation of the length.\n+  // We only want to compute this once.\n+  Bexpression* blength_;\n };\n \n // The type of a map."}]}