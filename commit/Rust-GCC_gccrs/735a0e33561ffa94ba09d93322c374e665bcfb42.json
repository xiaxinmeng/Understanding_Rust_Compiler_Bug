{"sha": "735a0e33561ffa94ba09d93322c374e665bcfb42", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzM1YTBlMzM1NjFmZmE5NGJhMDlkOTMzMjJjMzc0ZTY2NWJjZmI0Mg==", "commit": {"author": {"name": "Ulrich Drepper", "email": "drepper@cygnus.com", "date": "1998-11-23T16:41:12Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1998-11-23T16:41:12Z"}, "message": "Ulrich Drepper <drepper@cygnus.com>\n\nUlrich Drepper  <drepper@cygnus.com>\n        * Makefile.in (OBJS): Add graph.o\n        (graph.o): New dependency list.\n        * flags.h: Declare dump_for_graph and define graph_dump_types type.\n        * print-rtl.c (dump_for_graph): Define new variable.\n        (print_rtx): Rewrite to allow use in graph dumping functions.\n        * toplev.c: Declare print_rtl_graph_with_bb, clean_graph_dump_file,\n        finish_graph_dump_file.\n        Define graph_dump_format.\n        (compile_file): If graph dumping is enabled also clear these files.\n        Finish graph dump files.\n        (rest_of_compilation): Also dump graph information if enabled.\n        (main): Recognize -dv to enabled VCG based graph dumping.\n        * graph.c: New file.  Graph dumping functions.\n\nFrom-SVN: r23813", "tree": {"sha": "3f85798dacd6012a8cc02dc68f10cb4cc26f1b8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f85798dacd6012a8cc02dc68f10cb4cc26f1b8f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/735a0e33561ffa94ba09d93322c374e665bcfb42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/735a0e33561ffa94ba09d93322c374e665bcfb42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/735a0e33561ffa94ba09d93322c374e665bcfb42", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/735a0e33561ffa94ba09d93322c374e665bcfb42/comments", "author": null, "committer": null, "parents": [{"sha": "a05e22b8146978b60f0a43cecaa3756fc7f81793", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a05e22b8146978b60f0a43cecaa3756fc7f81793", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a05e22b8146978b60f0a43cecaa3756fc7f81793"}], "stats": {"total": 924, "additions": 830, "deletions": 94}, "files": [{"sha": "68a8f808a0bf519d83b8f82b6fc1c4bdec073984", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/735a0e33561ffa94ba09d93322c374e665bcfb42/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/735a0e33561ffa94ba09d93322c374e665bcfb42/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=735a0e33561ffa94ba09d93322c374e665bcfb42", "patch": "@@ -1,3 +1,19 @@\n+Mon Nov 23 16:40:00 1998  Ulrich Drepper  <drepper@cygnus.com>\n+\n+        * Makefile.in (OBJS): Add graph.o\n+        (graph.o): New dependency list.\n+        * flags.h: Declare dump_for_graph and define graph_dump_types type.\n+        * print-rtl.c (dump_for_graph): Define new variable.\n+        (print_rtx): Rewrite to allow use in graph dumping functions.\n+        * toplev.c: Declare print_rtl_graph_with_bb, clean_graph_dump_file,\n+        finish_graph_dump_file.\n+        Define graph_dump_format.\n+        (compile_file): If graph dumping is enabled also clear these files.\n+        Finish graph dump files.\n+        (rest_of_compilation): Also dump graph information if enabled.\n+        (main): Recognize -dv to enabled VCG based graph dumping.\n+        * graph.c: New file.  Graph dumping functions.\n+\n Mon Nov 23 16:39:04 1998  Richard Henderson  <rth@cygnus.com>\n \n         * configure.in: Look for <sys/stat.h>."}, {"sha": "439786665e01b9bbee55046f21a7c15959423147", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/735a0e33561ffa94ba09d93322c374e665bcfb42/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/735a0e33561ffa94ba09d93322c374e665bcfb42/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=735a0e33561ffa94ba09d93322c374e665bcfb42", "patch": "@@ -647,7 +647,7 @@ OBJS = toplev.o version.o tree.o print-tree.o stor-layout.o fold-const.o \\\n  insn-peep.o reorg.o $(SCHED_PREFIX)sched.o final.o recog.o reg-stack.o \\\n  insn-opinit.o insn-recog.o insn-extract.o insn-output.o insn-emit.o \\\n  profile.o insn-attrtab.o $(out_object_file) getpwd.o $(EXTRA_OBJS) convert.o \\\n- mbchar.o dyn-string.o splay-tree.o\n+ mbchar.o dyn-string.o splay-tree.o graph.o\n \n # GEN files are listed separately, so they can be built before doing parallel\n #  makes for cc1 or cc1plus.  Otherwise sequent parallel make attempts to load\n@@ -1289,6 +1289,8 @@ c-pragma.o: c-pragma.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) except.h \\\n c-iterate.o: c-iterate.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) c-tree.h \\\n     flags.h toplev.h $(EXPR_H)\n mbchar.o: mbchar.c $(CONFIG_H) system.h mbchar.h\n+graph.o: graph.c $(CONFIG_H) system.h toplev.h flags.h output.h rtl.h \\\n+    hard-reg-set.h basic-block.h\n \n collect2$(exeext): collect2.o tlink.o hash.o cplus-dem.o underscore.o \\\n \tversion.o choose-temp.o mkstemp.o $(LIBDEPS)"}, {"sha": "f25b0ba282ec0adaa52d697d13ecfb5d4c8ca39b", "filename": "gcc/flags.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/735a0e33561ffa94ba09d93322c374e665bcfb42/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/735a0e33561ffa94ba09d93322c374e665bcfb42/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=735a0e33561ffa94ba09d93322c374e665bcfb42", "patch": "@@ -502,3 +502,14 @@ extern int current_function_is_thunk;\n /* Value of the -G xx switch, and whether it was passed or not.  */\n extern int g_switch_value;\n extern int g_switch_set;\n+\n+/* Nonzero if we dump in VCG format, not plain text.  */\n+extern int dump_for_graph;\n+\n+/* Selection of the graph form.  */\n+enum graph_dump_types\n+{\n+  no_graph = 0,\n+  vcg\n+};\n+extern enum graph_dump_types graph_dump_format;"}, {"sha": "a60cd42db430d3405cbbde53ac85e360ed795ee9", "filename": "gcc/graph.c", "status": "added", "additions": 486, "deletions": 0, "changes": 486, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/735a0e33561ffa94ba09d93322c374e665bcfb42/gcc%2Fgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/735a0e33561ffa94ba09d93322c374e665bcfb42/gcc%2Fgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraph.c?ref=735a0e33561ffa94ba09d93322c374e665bcfb42", "patch": "@@ -0,0 +1,486 @@\n+/* Output routines for graphical representation.\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1998.\n+\n+   This file is part of GNU CC.\n+\n+   GNU CC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GNU CC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GNU CC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+#include <config.h>\n+#include \"system.h\"\n+\n+#include \"rtl.h\"\n+#include \"flags.h\"\n+#include \"output.h\"\n+#include \"hard-reg-set.h\"\n+#include \"basic-block.h\"\n+#include \"toplev.h\"\n+\n+static const char *graph_ext[] =\n+{\n+  /* no_graph */ \"\",\n+  /* vcg */      \".vcg\",\n+};\n+\n+/* Output text for new basic block.  */\n+static void\n+start_fct (fp)\n+     FILE *fp;\n+{\n+\n+  switch (graph_dump_format)\n+    {\n+    case vcg:\n+      fprintf (fp, \"\\\n+graph: { title: \\\"%s\\\"\\nfolding: 1\\nhidden: 2\\nnode: { title: \\\"%s.0\\\" }\\n\",\n+\t       current_function_name, current_function_name);\n+      break;\n+    case no_graph:\n+      break;\n+    }\n+}\n+\n+static void\n+start_bb (fp, bb)\n+     FILE *fp;\n+     int bb;\n+{\n+  switch (graph_dump_format)\n+    {\n+    case vcg:\n+      fprintf (fp, \"\\\n+graph: {\\ntitle: \\\"%s.BB%d\\\"\\nfolding: 1\\ncolor: lightblue\\n\\\n+label: \\\"basic block %d\",\n+\t       current_function_name, bb, bb);\n+      break;\n+    case no_graph:\n+      break;\n+    }\n+\n+#if 0\n+  /* FIXME Should this be printed?  It makes the graph significantly larger. */\n+\n+  /* Print the live-at-start register list.  */\n+  fputc ('\\n', fp);\n+  EXECUTE_IF_SET_IN_REG_SET (basic_block_live_at_start[bb], 0, i,\n+\t\t\t     {\n+\t\t\t       fprintf (fp, \" %d\", i);\n+\t\t\t       if (i < FIRST_PSEUDO_REGISTER)\n+\t\t\t\t fprintf (fp, \" [%s]\",\n+\t\t\t\t\t  reg_names[i]);\n+\t\t\t     });\n+#endif\n+\n+  switch (graph_dump_format)\n+    {\n+    case vcg:\n+      fputs (\"\\\"\\n\\n\", fp);\n+      break;\n+    case no_graph:\n+      break;\n+    }\n+}\n+\n+static int\n+node_data (fp, tmp_rtx)\n+     FILE *fp;\n+     rtx tmp_rtx;\n+{\n+  int result;\n+\n+  if (PREV_INSN (tmp_rtx) == 0)\n+    {\n+      /* This is the first instruction.  Add an edge from the starting\n+\t block.  */\n+      switch (graph_dump_format)\n+\t{\n+\tcase vcg:\n+\t  fprintf (fp, \"\\\n+edge: { sourcename: \\\"%s.0\\\" targetname: \\\"%s.%d\\\" }\\n\",\n+\t\t   current_function_name,\n+\t\t   current_function_name, XINT (tmp_rtx, 0));\n+\t  break;\n+\tcase no_graph:\n+\t  break;\n+\t}\n+    }\n+\n+  switch (graph_dump_format)\n+    {\n+    case vcg:\n+      fprintf (fp, \"node: {\\n  title: \\\"%s.%d\\\"\\n  color: %s\\n  \\\n+label: \\\"%s %d\\n\",\n+\t       current_function_name, XINT (tmp_rtx, 0),\n+\t       GET_CODE (tmp_rtx) == NOTE ? \"lightgrey\"\n+\t       : GET_CODE (tmp_rtx) == INSN ? \"green\"\n+\t       : GET_CODE (tmp_rtx) == JUMP_INSN ? \"darkgreen\"\n+\t       : GET_CODE (tmp_rtx) == CALL_INSN ? \"darkgreen\"\n+\t       : GET_CODE (tmp_rtx) == CODE_LABEL ?  \"\\\n+darkgrey\\n  shape: ellipse\" : \"white\",\n+\t       GET_RTX_NAME (GET_CODE (tmp_rtx)), XINT (tmp_rtx, 0));\n+      break;\n+    case no_graph:\n+      break;\n+    }\n+\n+  /* Print the RTL.  */\n+  if (GET_CODE (tmp_rtx) == NOTE)\n+    {\n+      static const char *note_names[] =\n+      {\n+\tNULL,\n+\t\"deleted\",\n+\t\"block_beg\",\n+\t\"block_end\",\n+\t\"loop_beg\",\n+\t\"loop_end\",\n+\t\"function_end\",\n+\t\"setjmp\",\n+\t\"loop_cont\",\n+\t\"loop_vtop\",\n+\t\"prologue_end\",\n+\t\"epilogue_beg\",\n+\t\"deleted_label\",\n+\t\"function_beg\",\n+\t\"eh_region_beg\",\n+\t\"eh_region_end\",\n+\t\"repeated_line_number\",\n+\t\"range_start\",\n+\t\"range_end\",\n+\t\"live\"\n+      };\n+\n+      fprintf (fp, \" %s\",\n+\t       XINT (tmp_rtx, 4) < 0 ? note_names[-XINT (tmp_rtx, 4)] : \"\");\n+    }\n+  else if (GET_RTX_CLASS (GET_CODE (tmp_rtx)) == 'i')\n+    result = print_rtl_single (fp, PATTERN (tmp_rtx));\n+  else\n+    result = print_rtl_single (fp, tmp_rtx);\n+\n+  switch (graph_dump_format)\n+    {\n+    case vcg:\n+      fputs (\"\\\"\\n}\\n\", fp);\n+      break;\n+    case no_graph:\n+      break;\n+    }\n+\n+  return result;\n+}\n+\n+static void\n+draw_edge (fp, from, to, bb_edge, class)\n+     FILE *fp;\n+     int from;\n+     int to;\n+     int bb_edge;\n+     int class;\n+{\n+  switch (graph_dump_format)\n+    {\n+    case vcg:\n+      fprintf (fp,\n+\t       \"edge: { sourcename: \\\"%s.%d\\\" targetname: \\\"%s.%d\\\" %s\",\n+\t       current_function_name, from,\n+\t       current_function_name, to,\n+\t       bb_edge ? \"color: blue \" : class ? \"color: red \" : \"\");\n+      if (class)\n+\tfprintf (fp, \"class: %d \", class);\n+      fputs (\"}\\n\", fp);\n+      break;\n+    case no_graph:\n+      break;\n+    }\n+}\n+\n+static void\n+end_bb (fp, bb)\n+     FILE *fp;\n+     int bb ATTRIBUTE_UNUSED;\n+{\n+  switch (graph_dump_format)\n+    {\n+    case vcg:\n+      fputs (\"}\\n\", fp);\n+      break;\n+    case no_graph:\n+      break;\n+    }\n+}\n+\n+static void\n+end_fct (fp)\n+     FILE *fp;\n+{\n+  switch (graph_dump_format)\n+    {\n+    case vcg:\n+      fprintf (fp, \"node: { title: \\\"%s.999999\\\" label: \\\"END\\\" }\\n}\\n\",\n+\t       current_function_name);\n+      break;\n+    case no_graph:\n+      break;\n+    }\n+}\n+\f\n+/* Like print_rtl, but also print out live information for the start of each\n+   basic block.  */\n+void\n+print_rtl_graph_with_bb (base, suffix, rtx_first)\n+     const char *base;\n+     const char *suffix;\n+     rtx rtx_first;\n+{\n+  register rtx tmp_rtx;\n+  size_t namelen = strlen (base);\n+  size_t suffixlen = strlen (suffix);\n+  size_t extlen = strlen (graph_ext[graph_dump_format]) + 1;\n+  char *buf = (char *) alloca (namelen + suffixlen + extlen);\n+  FILE *fp;\n+\n+  /* Regenerate the basic block information.  */\n+  find_basic_blocks (rtx_first, max_reg_num (), NULL);\n+\n+  memcpy (buf, base, namelen);\n+  memcpy (buf + namelen, suffix, suffixlen);\n+  memcpy (buf + namelen + suffixlen, graph_ext[graph_dump_format], extlen);\n+\n+  fp = fopen (buf, \"a\");\n+  if (fp == NULL)\n+    return;\n+\n+  if (rtx_first == 0)\n+    fprintf (fp, \"(nil)\\n\");\n+  else\n+    {\n+      int i, bb;\n+      enum bb_state { NOT_IN_BB, IN_ONE_BB, IN_MULTIPLE_BB };\n+      int max_uid = get_max_uid ();\n+      int *start = (int *) alloca (max_uid * sizeof (int));\n+      int *end = (int *) alloca (max_uid * sizeof (int));\n+      enum bb_state *in_bb_p = (enum bb_state *)\n+\talloca (max_uid * sizeof (enum bb_state));\n+      /* Element I is a list of I's predecessors/successors.  */\n+      int_list_ptr *s_preds;\n+      int_list_ptr *s_succs;\n+      /* Element I is the number of predecessors/successors of basic\n+        block I.  */\n+      int *num_preds;\n+      int *num_succs;\n+\n+      for (i = 0; i < max_uid; ++i)\n+\t{\n+\t  start[i] = end[i] = -1;\n+\t  in_bb_p[i] = NOT_IN_BB;\n+\t}\n+\n+      for (i = n_basic_blocks - 1; i >= 0; --i)\n+\t{\n+\t  rtx x;\n+\t  start[INSN_UID (basic_block_head[i])] = i;\n+\t  end[INSN_UID (basic_block_end[i])] = i;\n+\t  for (x = basic_block_head[i]; x != NULL_RTX; x = NEXT_INSN (x))\n+\t    {\n+\t      in_bb_p[INSN_UID (x)]\n+\t\t= (in_bb_p[INSN_UID (x)] == NOT_IN_BB)\n+\t\t ? IN_ONE_BB : IN_MULTIPLE_BB;\n+\t      if (x == basic_block_end[i])\n+\t\tbreak;\n+\t    }\n+\t}\n+\n+      /* Get the information about the basic blocks predecessors and\n+\t successors.  */\n+      s_preds = (int_list_ptr *) alloca (n_basic_blocks\n+\t\t\t\t\t * sizeof (int_list_ptr));\n+      s_succs = (int_list_ptr *) alloca (n_basic_blocks\n+\t\t\t\t\t * sizeof (int_list_ptr));\n+      num_preds = (int *) alloca (n_basic_blocks * sizeof (int));\n+      num_succs = (int *) alloca (n_basic_blocks * sizeof (int));\n+      compute_preds_succs (s_preds, s_succs, num_preds, num_succs);\n+\n+      /* Tell print-rtl that we want graph output.  */\n+      dump_for_graph = 1;\n+\n+      /* Start new function.  */\n+      start_fct (fp);\n+\n+      for (tmp_rtx = NEXT_INSN (rtx_first); NULL != tmp_rtx;\n+\t   tmp_rtx = NEXT_INSN (tmp_rtx))\n+\t{\n+\t  int did_output;\n+\t  int edge_printed = 0;\n+\t  rtx next_insn;\n+\n+\t  if (start[INSN_UID (tmp_rtx)] < 0 && end[INSN_UID (tmp_rtx)] < 0)\n+\t    {\n+\t      if (GET_CODE (tmp_rtx) == BARRIER)\n+\t\tcontinue;\n+\t      if (GET_CODE (tmp_rtx) == NOTE\n+\t\t  && (1 || in_bb_p[INSN_UID (tmp_rtx)] == NOT_IN_BB))\n+\t\tcontinue;\n+\t    }\n+\n+\t  if ((bb = start[INSN_UID (tmp_rtx)]) >= 0)\n+\t    {\n+\t      /* We start a subgraph for each basic block.  */\n+\t      start_bb (fp, bb);\n+\n+\t      if (bb == 0)\n+\t\tdraw_edge (fp, 0, INSN_UID (tmp_rtx), 1, 0);\n+\t    }\n+\n+\t  /* Print the data for this node.  */\n+\t  did_output = node_data (fp, tmp_rtx);\n+\t  next_insn = next_nonnote_insn (tmp_rtx);\n+\n+\t  if ((bb = end[INSN_UID (tmp_rtx)]) >= 0)\n+\t    {\n+\t      int_list_ptr p;\n+\n+\t      /* End of the basic block.  */\n+\t      end_bb (fp, bb);\n+\n+\t      /* Now specify the edges to all the successors of this\n+\t\t basic block.  */\n+\t      for (p = s_succs[bb]; p != NULL; p = p->next)\n+\t\t{\n+\t\t  int bb_succ = INT_LIST_VAL (p);\n+\n+\t\t  if (bb_succ >= 0)\n+\t\t    {\n+\t\t      rtx block_head = BLOCK_HEAD (bb_succ);\n+\n+\t\t      draw_edge (fp, INSN_UID (tmp_rtx),\n+\t\t\t\t INSN_UID (block_head),\n+\t\t\t\t next_insn != block_head, 0);\n+\n+\t\t      if (BLOCK_HEAD (bb_succ) == next_insn)\n+\t\t\tedge_printed = 1;\n+\t\t    }\n+\t\t  else if (bb_succ == EXIT_BLOCK)\n+\t\t    {\n+\t\t      draw_edge (fp, INSN_UID (tmp_rtx), 999999,\n+\t\t\t\t next_insn != 0, 0);\n+\n+\t\t      if (next_insn == 0)\n+\t\t\tedge_printed = 1;\n+\t\t    }\n+\t\t  else\n+\t\t    abort ();\n+\t\t}\n+\t    }\n+\n+\t  if (!edge_printed)\n+\t    {\n+\t      /* Don't print edges to barriers.  */\n+\t      if (next_insn == 0\n+\t\t  || GET_CODE (next_insn) != BARRIER)\n+\t\tdraw_edge (fp, XINT (tmp_rtx, 0),\n+\t\t\t   next_insn ? INSN_UID (next_insn) : 999999, 0, 0);\n+\t      else\n+\t\t{\n+\t\t  /* We draw the remaining edges in class 2.  We have\n+\t\t     to skip oevr the barrier since these nodes are\n+\t\t     not printed at all.  */\n+\t\t  do\n+\t\t    next_insn = NEXT_INSN (next_insn);\n+\t\t  while (next_insn\n+\t\t\t && (GET_CODE (next_insn) == NOTE\n+\t\t\t     || GET_CODE (next_insn) == BARRIER));\n+\n+\t\t  draw_edge (fp, XINT (tmp_rtx, 0),\n+\t\t\t     next_insn ? INSN_UID (next_insn) : 999999, 0, 2);\n+\t\t}\n+\t    }\n+\t}\n+\n+      dump_for_graph = 0;\n+\n+      end_fct (fp);\n+    }\n+\n+  fclose (fp);\n+}\n+\n+\n+/* Similar as clean_dump_file, but this time for graph output files.  */\n+void\n+clean_graph_dump_file (base, suffix)\n+     const char *base;\n+     const char *suffix;\n+{\n+  size_t namelen = strlen (base);\n+  size_t suffixlen = strlen (suffix);\n+  size_t extlen = strlen (graph_ext[graph_dump_format]) + 1;\n+  char *buf = (char *) alloca (namelen + extlen + suffixlen);\n+  FILE *fp;\n+\n+  memcpy (buf, base, namelen);\n+  memcpy (buf + namelen, suffix, suffixlen);\n+  memcpy (buf + namelen + suffixlen, graph_ext[graph_dump_format], extlen);\n+\n+  fp = fopen (buf, \"w\");\n+\n+  if (fp == NULL)\n+    pfatal_with_name (buf);\n+\n+  switch (graph_dump_format)\n+    {\n+    case vcg:\n+      fputs (\"graph: {\\nport_sharing: no\\n\", fp);\n+      break;\n+    case no_graph:\n+      abort ();\n+    }\n+\n+  fclose (fp);\n+}\n+\n+\n+/* Do final work on the graph output file.  */\n+void\n+finish_graph_dump_file (base, suffix)\n+     const char *base;\n+     const char *suffix;\n+{\n+  size_t namelen = strlen (base);\n+  size_t suffixlen = strlen (suffix);\n+  size_t extlen = strlen (graph_ext[graph_dump_format]) + 1;\n+  char *buf = (char *) alloca (namelen + suffixlen + extlen);\n+  FILE *fp;\n+\n+  memcpy (buf, base, namelen);\n+  memcpy (buf + namelen, suffix, suffixlen);\n+  memcpy (buf + namelen + suffixlen, graph_ext[graph_dump_format], extlen);\n+\n+  fp = fopen (buf, \"a\");\n+  if (fp != NULL)\n+    {\n+      switch (graph_dump_format)\n+\t{\n+\tcase vcg:\n+\t  fputs (\"}\\n\", fp);\n+\t  break;\n+\tcase no_graph:\n+\t  abort ();\n+\t}\n+\n+      fclose (fp);\n+    }\n+}"}, {"sha": "234b6e45bf418efe307a9c2f750b6e31ee46c4af", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 62, "deletions": 35, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/735a0e33561ffa94ba09d93322c374e665bcfb42/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/735a0e33561ffa94ba09d93322c374e665bcfb42/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=735a0e33561ffa94ba09d93322c374e665bcfb42", "patch": "@@ -1,5 +1,5 @@\n /* Print RTL for GNU C Compiler.\n-   Copyright (C) 1987, 1988, 1992, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1988, 1992, 1997, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -60,13 +60,17 @@ extern char **insn_name_ptr;\n    This must be defined here so that programs like gencodes can be linked.  */\n int flag_dump_unnumbered = 0;\n \n+/* Nonzero if we are dumping graphical description.  */\n+int dump_for_graph;\n+\n /* Print IN_RTX onto OUTFILE.  This is the recursive part of printing.  */\n \n static void\n print_rtx (in_rtx)\n      register rtx in_rtx;\n {\n-  register int i, j;\n+  register int i = 0;\n+  register int j;\n   register char *format_ptr;\n   register int is_insn;\n \n@@ -79,39 +83,54 @@ print_rtx (in_rtx)\n \n   if (in_rtx == 0)\n     {\n-      fprintf (outfile, \"(nil)\");\n+      fputs (\"(nil)\", outfile);\n       sawclose = 1;\n       return;\n     }\n \n-  /* print name of expression code */\n-  fprintf (outfile, \"(%s\", GET_RTX_NAME (GET_CODE (in_rtx)));\n+  is_insn = (GET_RTX_CLASS (GET_CODE (in_rtx)) == 'i');\n+\n+  /* When printing in VCG format we write INSNs, NOTE, LABEL, and BARRIER\n+     in separate nodes and therefore have to handle them special here.  */\n+  if (dump_for_graph &&\n+      (is_insn || GET_CODE (in_rtx) == NOTE || GET_CODE (in_rtx) == CODE_LABEL\n+       || GET_CODE (in_rtx) == BARRIER))\n+    {\n+      i = 3;\n+      indent = 0;\n+    }\n+  else\n+    {\n+      /* print name of expression code */\n+      fprintf (outfile, \"(%s\", GET_RTX_NAME (GET_CODE (in_rtx)));\n \n-  if (in_rtx->in_struct)\n-    fprintf (outfile, \"/s\");\n+      if (in_rtx->in_struct)\n+\tfputs (\"/s\", outfile);\n \n-  if (in_rtx->volatil)\n-    fprintf (outfile, \"/v\");\n+      if (in_rtx->volatil)\n+\tfputs (\"/v\", outfile);\n \n-  if (in_rtx->unchanging)\n-    fprintf (outfile, \"/u\");\n+      if (in_rtx->unchanging)\n+\tfputs (\"/u\", outfile);\n \n-  if (in_rtx->integrated)\n-    fprintf (outfile, \"/i\");\n+      if (in_rtx->integrated)\n+\tfputs (\"/i\", outfile);\n \n-  if (GET_MODE (in_rtx) != VOIDmode)\n-    {\n-      /* Print REG_NOTE names for EXPR_LIST and INSN_LIST.  */\n-      if (GET_CODE (in_rtx) == EXPR_LIST || GET_CODE (in_rtx) == INSN_LIST)\n-\tfprintf (outfile, \":%s\", GET_REG_NOTE_NAME (GET_MODE (in_rtx)));\n-      else\n-\tfprintf (outfile, \":%s\", GET_MODE_NAME (GET_MODE (in_rtx)));\n+      if (GET_MODE (in_rtx) != VOIDmode)\n+\t{\n+\t  /* Print REG_NOTE names for EXPR_LIST and INSN_LIST.  */\n+\t  if (GET_CODE (in_rtx) == EXPR_LIST || GET_CODE (in_rtx) == INSN_LIST)\n+\t    fprintf (outfile, \":%s\", GET_REG_NOTE_NAME (GET_MODE (in_rtx)));\n+\t  else\n+\t    fprintf (outfile, \":%s\", GET_MODE_NAME (GET_MODE (in_rtx)));\n+\t}\n     }\n \n-  is_insn = (GET_RTX_CLASS (GET_CODE (in_rtx)) == 'i');\n-  format_ptr = GET_RTX_FORMAT (GET_CODE (in_rtx));\n+  /* Get the format string and skip the first elements if we have handled\n+     them already.  */\n+  format_ptr = GET_RTX_FORMAT (GET_CODE (in_rtx)) + i;\n \n-  for (i = 0; i < GET_RTX_LENGTH (GET_CODE (in_rtx)); i++)\n+  for (; i < GET_RTX_LENGTH (GET_CODE (in_rtx)); i++)\n     switch (*format_ptr++)\n       {\n       case 'S':\n@@ -141,9 +160,10 @@ print_rtx (in_rtx)\n \t  }\n \n \tif (XSTR (in_rtx, i) == 0)\n-\t  fprintf (outfile, \" \\\"\\\"\");\n+\t  fputs (dump_for_graph ? \" \\\\\\\"\\\\\\\"\" : \" \\\"\\\"\", outfile);\n \telse\n-\t  fprintf (outfile, \" (\\\"%s\\\")\", XSTR (in_rtx, i));\n+\t  fprintf (outfile, dump_for_graph ? \" (\\\\\\\"%s\\\\\\\")\" : \" (\\\"%s\\\")\",\n+\t\t   XSTR (in_rtx, i));\n \tsawclose = 1;\n \tbreak;\n \n@@ -168,7 +188,7 @@ print_rtx (in_rtx)\n \t\t     (spaces + (sizeof spaces - 1 - indent * 2)));\n \t    sawclose = 0;\n \t  }\n-\tfprintf (outfile, \"[ \");\n+\tfputs (\"[ \", outfile);\n \tif (NULL != XVEC (in_rtx, i))\n \t  {\n \t    indent += 2;\n@@ -184,7 +204,7 @@ print_rtx (in_rtx)\n \t  fprintf (outfile, \"\\n%s\",\n \t\t   (spaces + (sizeof spaces - 1 - indent * 2)));\n \n-\tfprintf (outfile, \"] \");\n+\tfputs (\"] \", outfile);\n \tsawclose = 1;\n \tindent -= 2;\n \tbreak;\n@@ -205,7 +225,7 @@ print_rtx (in_rtx)\n \t    }\n \t  else if (flag_dump_unnumbered\n \t\t   && (is_insn || GET_CODE (in_rtx) == NOTE))\n-\t    fprintf (outfile, \"#\");\n+\t    fputc ('#', outfile);\n \t  else\n \t    fprintf (outfile, \" %d\", value);\n \t}\n@@ -230,18 +250,18 @@ print_rtx (in_rtx)\n \tif (XEXP (in_rtx, i) != NULL)\n \t  {\n \t    if (flag_dump_unnumbered)\n-\t      fprintf (outfile, \"#\");\n+\t      fputc ('#', outfile);\n \t    else\n \t      fprintf (outfile, \" %d\", INSN_UID (XEXP (in_rtx, i)));\n \t  }\n \telse\n-\t  fprintf (outfile, \" 0\");\n+\t  fputs (\" 0\", outfile);\n \tsawclose = 0;\n \tbreak;\n \n       case 'b':\n \tif (XBITMAP (in_rtx, i) == NULL)\n-\t  fprintf (outfile, \" {null}\");\n+\t  fputs (\" {null}\", outfile);\n \telse\n \t  bitmap_print (outfile, XBITMAP (in_rtx, i), \" {\", \"}\");\n \tsawclose = 0;\n@@ -253,7 +273,7 @@ print_rtx (in_rtx)\n \tbreak;\n \n       case '*':\n-\tfprintf (outfile, \" Unknown\");\n+\tfputs (\" Unknown\", outfile);\n \tsawclose = 0;\n \tbreak;\n \n@@ -276,8 +296,15 @@ print_rtx (in_rtx)\n     }\n #endif\n \n-  fprintf (outfile, \")\");\n-  sawclose = 1;\n+  if (dump_for_graph\n+      && (is_insn || GET_CODE (in_rtx) == NOTE\n+\t  || GET_CODE (in_rtx) == CODE_LABEL || GET_CODE (in_rtx) == BARRIER))\n+    sawclose = 0;\n+  else\n+    {\n+      fputc (')', outfile);\n+      sawclose = 1;\n+    }\n }\n \n /* Print an rtx on the current line of FILE.  Initially indent IND\n@@ -386,7 +413,7 @@ print_rtl (outf, rtx_first)\n   sawclose = 0;\n \n   if (rtx_first == 0)\n-    fprintf (outf, \"(nil)\\n\");\n+    fputs (\"(nil)\\n\", outf);\n   else\n     switch (GET_CODE (rtx_first))\n       {"}, {"sha": "da28bda18623e8339c7f1d5c61f7aa091a506db5", "filename": "gcc/toplev.c", "status": "modified", "additions": 252, "deletions": 58, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/735a0e33561ffa94ba09d93322c374e665bcfb42/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/735a0e33561ffa94ba09d93322c374e665bcfb42/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=735a0e33561ffa94ba09d93322c374e665bcfb42", "patch": "@@ -212,6 +212,10 @@ static int print_single_switch PROTO((FILE *, int, int, char *, char *, char *,\n \t\t\t\t      char *, char *));\n static void print_switch_values PROTO((FILE *, int, int, char *, char *,\n \t\t\t\t       char *));\n+\n+void print_rtl_graph_with_bb PROTO ((const char *, const char *, rtx));\n+void clean_graph_dump_file PROTO ((const char *, const char *));\n+void finish_graph_dump_file PROTO ((const char *, const char *));\n /* Length of line when printing switch values.  */\n #define MAX_LINE 75\n \n@@ -288,6 +292,7 @@ int stack_reg_dump = 0;\n #ifdef MACHINE_DEPENDENT_REORG\n int mach_dep_reorg_dump = 0;\n #endif\n+enum graph_dump_types graph_dump_format;\n \n /* Name for output file of assembly code, specified with -o.  */\n \n@@ -2606,50 +2611,122 @@ compile_file (name)\n \tpfatal_with_name (aux_info_file_name);\n     }\n \n-  /* Clear the dump files file.  */\n+  /* Clear the dump files.  */\n   if (rtl_dump)\n     clean_dump_file (\".rtl\");\n   if (jump_opt_dump)\n-    clean_dump_file (\".jump\");\n+    {\n+      clean_dump_file (\".jump\");\n+      if (graph_dump_format != no_graph)\n+\tclean_graph_dump_file (dump_base_name, \".jump\");\n+    }\n   if (addressof_dump)\n-    clean_dump_file (\".addressof\");\n+    {\n+      clean_dump_file (\".addressof\");\n+      if (graph_dump_format != no_graph)\n+\tclean_graph_dump_file (dump_base_name, \".addressof\");\n+    }\n   if (cse_dump)\n-    clean_dump_file (\".cse\");\n+    {\n+      clean_dump_file (\".cse\");\n+      if (graph_dump_format != no_graph)\n+\tclean_graph_dump_file (dump_base_name, \".cse\");\n+    }\n   if (loop_dump)\n-    clean_dump_file (\".loop\");\n+    {\n+      clean_dump_file (\".loop\");\n+      if (graph_dump_format != no_graph)\n+\tclean_graph_dump_file (dump_base_name, \".loop\");\n+    }\n   if (cse2_dump)\n-    clean_dump_file (\".cse2\");\n+    {\n+      clean_dump_file (\".cse2\");\n+      if (graph_dump_format != no_graph)\n+\tclean_graph_dump_file (dump_base_name, \".cse2\");\n+    }\n   if (branch_prob_dump)\n-    clean_dump_file (\".bp\");\n+    {\n+      clean_dump_file (\".bp\");\n+      if (graph_dump_format != no_graph)\n+\tclean_graph_dump_file (dump_base_name, \".bp\");\n+    }\n   if (flow_dump)\n-    clean_dump_file (\".flow\");\n+    {\n+      clean_dump_file (\".flow\");\n+      if (graph_dump_format != no_graph)\n+\tclean_graph_dump_file (dump_base_name, \".flow\");\n+    }\n   if (combine_dump)\n-    clean_dump_file (\".combine\");\n+    {\n+      clean_dump_file (\".combine\");\n+      if (graph_dump_format != no_graph)\n+\tclean_graph_dump_file (dump_base_name, \".combine\");\n+    }\n   if (regmove_dump)\n-    clean_dump_file (\".regmove\");\n+    {\n+      clean_dump_file (\".regmove\");\n+      if (graph_dump_format != no_graph)\n+\tclean_graph_dump_file (dump_base_name, \".regmove\");\n+    }\n   if (sched_dump)\n-    clean_dump_file (\".sched\");\n+    {\n+      clean_dump_file (\".sched\");\n+      if (graph_dump_format != no_graph)\n+\tclean_graph_dump_file (dump_base_name, \".sched\");\n+    }\n   if (local_reg_dump)\n-    clean_dump_file (\".lreg\");\n+    {\n+      clean_dump_file (\".lreg\");\n+      if (graph_dump_format != no_graph)\n+\tclean_graph_dump_file (dump_base_name, \".lreg\");\n+    }\n   if (global_reg_dump)\n-    clean_dump_file (\".greg\");\n+    {\n+      clean_dump_file (\".greg\");\n+      if (graph_dump_format != no_graph)\n+\tclean_graph_dump_file (dump_base_name, \".greg\");\n+    }\n   if (sched2_dump)\n-    clean_dump_file (\".sched2\");\n+    {\n+      clean_dump_file (\".sched2\");\n+      if (graph_dump_format != no_graph)\n+\tclean_graph_dump_file (dump_base_name, \".sched2\");\n+    }\n   if (jump2_opt_dump)\n-    clean_dump_file (\".jump2\");\n+    {\n+      clean_dump_file (\".jump2\");\n+      if (graph_dump_format != no_graph)\n+\tclean_graph_dump_file (dump_base_name, \".jump2\");\n+    }\n #ifdef DELAY_SLOTS\n   if (dbr_sched_dump)\n-    clean_dump_file (\".dbr\");\n+    {\n+      clean_dump_file (\".dbr\");\n+      if (graph_dump_format != no_graph)\n+\tclean_graph_dump_file (dump_base_name, \".dbr\");\n+    }\n #endif\n   if (gcse_dump)\n-    clean_dump_file (\".gcse\");\n+    {\n+      clean_dump_file (\".gcse\");\n+      if (graph_dump_format != no_graph)\n+\tclean_graph_dump_file (dump_base_name, \".gcse\");\n+    }\n #ifdef STACK_REGS\n   if (stack_reg_dump)\n-    clean_dump_file (\".stack\");\n+    {\n+      clean_dump_file (\".stack\");\n+      if (graph_dump_format != no_graph)\n+\tclean_graph_dump_file (dump_base_name, \".stack\");\n+    }\n #endif\n #ifdef MACHINE_DEPENDENT_REORG\n   if (mach_dep_reorg_dump)\n-    clean_dump_file (\".mach\");\n+    {\n+      clean_dump_file (\".mach\");\n+      if (graph_dump_format != no_graph)\n+\tclean_graph_dump_file (dump_base_name, \".mach\");\n+    }\n #endif\n \n   /* Open assembler code output file.  */\n@@ -3119,6 +3196,53 @@ compile_file (name)\n       && (ferror (asm_out_file) != 0 || fclose (asm_out_file) != 0))\n     fatal_io_error (asm_file_name);\n \n+  /* Do whatever is necessary to finish printing the graphs.  */\n+  if (graph_dump_format != no_graph)\n+    {\n+      if (jump_opt_dump)\n+\tfinish_graph_dump_file (dump_base_name, \".jump\");\n+      if (addressof_dump)\n+\tfinish_graph_dump_file (dump_base_name, \".addressof\");\n+      if (cse_dump)\n+\tfinish_graph_dump_file (dump_base_name, \".cse\");\n+      if (loop_dump)\n+\tfinish_graph_dump_file (dump_base_name, \".loop\");\n+      if (cse2_dump)\n+\tfinish_graph_dump_file (dump_base_name, \".cse2\");\n+      if (branch_prob_dump)\n+\tfinish_graph_dump_file (dump_base_name, \".bp\");\n+      if (flow_dump)\n+\tfinish_graph_dump_file (dump_base_name, \".flow\");\n+      if (combine_dump)\n+\tfinish_graph_dump_file (dump_base_name, \".combine\");\n+      if (regmove_dump)\n+\tfinish_graph_dump_file (dump_base_name, \".regmove\");\n+      if (sched_dump)\n+\tfinish_graph_dump_file (dump_base_name, \".sched\");\n+      if (local_reg_dump)\n+\tfinish_graph_dump_file (dump_base_name, \".lreg\");\n+      if (global_reg_dump)\n+\tfinish_graph_dump_file (dump_base_name, \".greg\");\n+      if (sched2_dump)\n+\tfinish_graph_dump_file (dump_base_name, \".sched2\");\n+      if (jump2_opt_dump)\n+\tfinish_graph_dump_file (dump_base_name, \".jump2\");\n+#ifdef DELAY_SLOTS\n+      if (dbr_sched_dump)\n+\tfinish_graph_dump_file (dump_base_name, \".dbr\");\n+#endif\n+      if (gcse_dump)\n+\tfinish_graph_dump_file (dump_base_name, \".gcse\");\n+#ifdef STACK_REGS\n+      if (stack_reg_dump)\n+\tfinish_graph_dump_file (dump_base_name, \".stack\");\n+#endif\n+#ifdef MACHINE_DEPENDENT_REORG\n+      if (mach_dep_reorg_dump)\n+\tfinish_graph_dump_file (dump_base_name, \".mach\");\n+#endif\n+    }\n+\n   /* Free up memory for the benefit of leak detectors.  */\n   free_reg_info ();\n \n@@ -3544,28 +3668,40 @@ rest_of_compilation (decl)\n \t\t\t\t\t   !JUMP_AFTER_REGSCAN));\n \n       /* Dump rtl code after cse, if we are doing that.  */\n-      \n+\n       if (cse_dump)\n-\tclose_dump_file (print_rtl, insns);\n+\t{\n+\t  close_dump_file (print_rtl, insns);\n+\t  if (graph_dump_format != no_graph)\n+\t    print_rtl_graph_with_bb (dump_base_name, \".cse\", insns);\n+\t}\n     }\n \n   purge_addressof (insns);\n   reg_scan (insns, max_reg_num (), 1);\n \n   if (addressof_dump)\n-    dump_rtl (\".addressof\", decl, print_rtl, insns);\n-  \n+    {\n+      dump_rtl (\".addressof\", decl, print_rtl, insns);\n+      if (graph_dump_format != no_graph)\n+\tprint_rtl_graph_with_bb (dump_base_name, \".addressof\", insns);\n+    }\n+\n   /* Perform global cse.  */\n \n   if (optimize > 0 && flag_gcse)\n     {\n       if (gcse_dump)\n \topen_dump_file (\".gcse\", IDENTIFIER_POINTER (DECL_NAME (decl)));\n-      \n+\n       TIMEVAR (gcse_time, gcse_main (insns, rtl_dump_file));\n \n       if (gcse_dump)\n-\tclose_dump_file (print_rtl, insns);\n+\t{\n+\t  close_dump_file (print_rtl, insns);\n+\t  if (graph_dump_format != no_graph)\n+\t    print_rtl_graph_with_bb (dump_base_name, \".gcse\", insns);\n+\t}\n     }\n   /* Move constant computations out of loops.  */\n \n@@ -3596,18 +3732,22 @@ rest_of_compilation (decl)\n \t     }\n \t   loop_optimize (insns, rtl_dump_file, flag_unroll_loops, 1);\n \t });\n-      \n+\n       /* Dump rtl code after loop opt, if we are doing that.  */\n-      \n+\n       if (loop_dump)\n-\tclose_dump_file (print_rtl, insns);\n+\t{\n+\t  close_dump_file (print_rtl, insns);\n+\t  if (graph_dump_format != no_graph)\n+\t    print_rtl_graph_with_bb (dump_base_name, \".loop\", insns);\n+\t}\n     }\n \n   if (optimize > 0)\n     {\n       if (cse2_dump)\n \topen_dump_file (\".cse2\", decl_printable_name (decl, 2));\n-      \n+\n       if (flag_rerun_cse_after_loop)\n \t{\n \t  /* Running another jump optimization pass before the second\n@@ -3636,28 +3776,36 @@ rest_of_compilation (decl)\n \t  TIMEVAR (jump_time, reg_scan (insns, max_reg_num (), 0));\n \t  TIMEVAR (jump_time, thread_jumps (insns, max_reg_num (), 0));\n \t}\n-      \n+\n       /* Dump rtl code after cse, if we are doing that.  */\n-      \n+\n       if (cse2_dump)\n-\tclose_dump_file (print_rtl, insns);\n+\t{\n+\t  close_dump_file (print_rtl, insns);\n+\t  if (graph_dump_format != no_graph)\n+\t    print_rtl_graph_with_bb (dump_base_name, \".cse2\", insns);\n+\t}\n     }\n-  \n+\n   if (profile_arc_flag || flag_test_coverage || flag_branch_probabilities)\n     {\n       if (branch_prob_dump)\n \topen_dump_file (\".bp\", decl_printable_name (decl, 2));\n-    \n+\n       TIMEVAR\n \t(branch_prob_time,\n \t {\n \t   branch_prob (insns, rtl_dump_file);\n \t });\n-      \n+\n       if (branch_prob_dump)\n-\tclose_dump_file (print_rtl, insns);\n+\t{\n+\t  close_dump_file (print_rtl, insns);\n+\t  if (graph_dump_format != no_graph)\n+\t    print_rtl_graph_with_bb (dump_base_name, \".bp\", insns);\n+\t}\n     }\n-  \n+\n   /* We are no longer anticipating cse in this function, at least.  */\n \n   cse_not_expected = 1;\n@@ -3708,18 +3856,26 @@ rest_of_compilation (decl)\n   /* Dump rtl after flow analysis.  */\n \n   if (flow_dump)\n-    close_dump_file (print_rtl_with_bb, insns);\n-  \n+    {\n+      close_dump_file (print_rtl_with_bb, insns);\n+      if (graph_dump_format != no_graph)\n+\tprint_rtl_graph_with_bb (dump_base_name, \".flow\", insns);\n+    }\n+\n   /* If -opt, try combining insns through substitution.  */\n \n   if (optimize > 0)\n     {\n       TIMEVAR (combine_time, combine_instructions (insns, max_reg_num ()));\n-      \n+\n       /* Dump rtl code after insn combination.  */\n-      \n+\n       if (combine_dump)\n-\tdump_rtl (\".combine\", decl, print_rtl_with_bb, insns);\n+\t{\n+\t  dump_rtl (\".combine\", decl, print_rtl_with_bb, insns);\n+\t  if (graph_dump_format != no_graph)\n+\t    print_rtl_graph_with_bb (dump_base_name, \".combine\", insns);\n+\t}\n     }\n \n   /* Register allocation pre-pass, to reduce number of moves\n@@ -3728,12 +3884,16 @@ rest_of_compilation (decl)\n     {\n       if (regmove_dump)\n \topen_dump_file (\".regmove\", decl_printable_name (decl, 2));\n-      \n+\n       TIMEVAR (regmove_time, regmove_optimize (insns, max_reg_num (),\n \t\t\t\t\t       rtl_dump_file));\n-      \n+\n       if (regmove_dump)\n-\tclose_dump_file (print_rtl_with_bb, insns);\n+\t{\n+\t  close_dump_file (print_rtl_with_bb, insns);\n+\t  if (graph_dump_format != no_graph)\n+\t    print_rtl_graph_with_bb (dump_base_name, \".regmove\", insns);\n+\t}\n     }\n \n   /* Print function header into sched dump now\n@@ -3743,16 +3903,20 @@ rest_of_compilation (decl)\n     {\n       if (sched_dump)\n \topen_dump_file (\".sched\", decl_printable_name (decl, 2));\n-      \n+\n       /* Do control and data sched analysis,\n \t and write some of the results to dump file.  */\n \n       TIMEVAR (sched_time, schedule_insns (rtl_dump_file));\n-      \n+\n       /* Dump rtl after instruction scheduling.  */\n-      \n+\n       if (sched_dump)\n-\tclose_dump_file (print_rtl_with_bb, insns);\n+\t{\n+\t  close_dump_file (print_rtl_with_bb, insns);\n+\t  if (graph_dump_format != no_graph)\n+\t    print_rtl_graph_with_bb (dump_base_name, \".sched\", insns);\n+\t}\n     }\n \n   /* Unless we did stupid register allocation,\n@@ -3771,11 +3935,13 @@ rest_of_compilation (decl)\n   if (local_reg_dump)\n     {\n       open_dump_file (\".lreg\", decl_printable_name (decl, 2));\n-      \n+\n       TIMEVAR (dump_time, dump_flow_info (rtl_dump_file));\n       TIMEVAR (dump_time, dump_local_alloc (rtl_dump_file));\n-      \n+\n       close_dump_file (print_rtl_with_bb, insns);\n+      if (graph_dump_format != no_graph)\n+\tprint_rtl_graph_with_bb (dump_base_name, \".lreg\", insns);\n     }\n \n   if (global_reg_dump)\n@@ -3823,6 +3989,8 @@ rest_of_compilation (decl)\n     {\n       TIMEVAR (dump_time, dump_global_regs (rtl_dump_file));\n       close_dump_file (print_rtl_with_bb, insns);\n+      if (graph_dump_format != no_graph)\n+\tprint_rtl_graph_with_bb (dump_base_name, \".greg\", insns);\n     }\n   if (optimize > 0 && flag_schedule_insns_after_reload)\n     {\n@@ -3837,7 +4005,11 @@ rest_of_compilation (decl)\n       /* Dump rtl after post-reorder instruction scheduling.  */\n \n       if (sched2_dump)\n-\tclose_dump_file (print_rtl_with_bb, insns);\n+\t{\n+\t  close_dump_file (print_rtl_with_bb, insns);\n+\t  if (graph_dump_format != no_graph)\n+\t    print_rtl_graph_with_bb (dump_base_name, \".sched2\", insns);\n+\t}\n     }\n \n #ifdef LEAF_REGISTERS\n@@ -3856,19 +4028,27 @@ rest_of_compilation (decl)\n       TIMEVAR (jump_time, jump_optimize (insns, JUMP_CROSS_JUMP,\n \t\t\t\t\t JUMP_NOOP_MOVES,\n \t\t\t\t\t !JUMP_AFTER_REGSCAN));\n-      \n+\n       /* Dump rtl code after jump, if we are doing that.  */\n \n       if (jump2_opt_dump)\n-\tdump_rtl (\".jump2\", decl, print_rtl_with_bb, insns);\n+\t{\n+\t  dump_rtl (\".jump2\", decl, print_rtl_with_bb, insns);\n+\t  if (graph_dump_format != no_graph)\n+\t    print_rtl_graph_with_bb (dump_base_name, \".jump2\", insns);\n+\t}\n     }\n \n   /* If a machine dependent reorganization is needed, call it.  */\n #ifdef MACHINE_DEPENDENT_REORG\n    MACHINE_DEPENDENT_REORG (insns);\n \n    if (mach_dep_reorg_dump)\n-     dump_rtl (\".mach\", decl, print_rtl_with_bb, insns);\n+     {\n+       dump_rtl (\".mach\", decl, print_rtl_with_bb, insns);\n+       if (graph_dump_format != no_graph)\n+\t print_rtl_graph_with_bb (dump_base_name, \".mach\", insns);\n+     }\n #endif\n \n   /* If a scheduling pass for delayed branches is to be done,\n@@ -3878,9 +4058,13 @@ rest_of_compilation (decl)\n   if (optimize > 0 && flag_delayed_branch)\n     {\n       TIMEVAR (dbr_sched_time, dbr_schedule (insns, rtl_dump_file));\n-      \n+\n       if (dbr_sched_dump)\n-\tdump_rtl (\".dbr\", decl, print_rtl_with_bb, insns);\n+\t{\n+\t  dump_rtl (\".dbr\", decl, print_rtl_with_bb, insns);\n+\t  if (graph_dump_format != no_graph)\n+\t    print_rtl_graph_with_bb (dump_base_name, \".dbr\", insns);\n+\t}\n     }\n #endif\n \n@@ -3897,7 +4081,11 @@ rest_of_compilation (decl)\n   TIMEVAR (stack_reg_time, reg_to_stack (insns, rtl_dump_file));\n \n   if (stack_reg_dump)\n-    dump_rtl (\".stack\", decl, print_rtl_with_bb, insns);\n+    {\n+      dump_rtl (\".stack\", decl, print_rtl_with_bb, insns);\n+      if (graph_dump_format != no_graph)\n+\tprint_rtl_graph_with_bb (dump_base_name, \".stack\", insns);\n+    }\n #endif\n \n   /* Now turn the rtl into assembler code.  */\n@@ -4015,6 +4203,9 @@ rest_of_compilation (decl)\n      *except* what is spent in this function.  */\n \n   parse_time -= get_run_time () - start_time;\n+\n+  /* Reset global variables.  */\n+  free_basic_block_vars (0);\n }\n \f\n static void\n@@ -4548,6 +4739,9 @@ main (argc, argv)\n \t\t  case 'N':\n \t\t    regmove_dump = 1;\n \t\t    break;\n+\t\t  case 'v':\n+\t\t    graph_dump_format = vcg;\n+\t\t    break;\n \t\t  case 'y':\n \t\t    set_yydebug (1);\n \t\t    break;"}]}