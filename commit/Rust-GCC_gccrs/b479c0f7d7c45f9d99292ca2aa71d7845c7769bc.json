{"sha": "b479c0f7d7c45f9d99292ca2aa71d7845c7769bc", "node_id": "C_kwDOANBUbNoAKGI0NzljMGY3ZDdjNDVmOWQ5OTI5MmNhMmFhNzFkNzg0NWM3NzY5YmM", "commit": {"author": {"name": "Gary Dismukes", "email": "dismukes@adacore.com", "date": "2021-09-13T21:40:34Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-10-05T08:20:03Z"}, "message": "[Ada] Front-end support for Storage_Model feature\n\ngcc/ada/\n\n\t* aspects.ads (type Aspect_Id): Add\n\tAspect_Designated_Storage_Model and Aspect_Storage_Model_Type.\n\t(Aspect_Argument): Add associations for the above new aspects.\n\t(Is_Representation_Aspect): Likewise.\n\t(Aspect_Names, Aspect_Delay): Likewise.\n\t* exp_ch4.adb (Expand_N_Allocator): Call Find_Storage_Op rather\n\tthan Find_Prim_Op.\n\t* exp_intr.adb (Expand_Unc_Deallocation): Likewise.\n\t* exp_util.ads (Find_Storage_Op): New function that locates\n\teither a primitive operation of a storage pool or an operation\n\tof a storage-model type specified in its Storage_Model_Type\n\taspect.\n\t* exp_util.adb (Find_Storage_Op): New function that calls either\n\tFind_Prim_Op or Get_Storage_Model_Type_Entity to locate a\n\tstorage-related operation that is associated with a type.\n\t* sem_ch13.adb (Analyze_Aspects_At_Freeze_Point): Analyzes,\n\tresolves, and validates the arguments of aspect\n\tDesignated_Storage_Model_Type.\n\t(Analyze_Aspect_Specifications): Sets delay-related flags on\n\tstorage-model aspects when Delay_Required. Checks that aspect\n\tDesignated_Storage_Model is only specified for an access type\n\tand that aspect Storage_Model_Type is only specified on an\n\timmutably limited type. Also records such aspects for their\n\tassociated types.\n\t(Check_Aspect_At_Freeze_Point): Resolve each of the argument\n\tassociations given for a Storage_Model_Type aspect.\n\t(Resolve_Storage_Model_Type_Argument): New procedure that\n\tresolves an argument given in the association for a given entity\n\tname associated with a type with aspect Storage_Model_Type,\n\tensuring that it has the proper kind or profile.\n\t(Validate_Storage_Model_Type_Aspect): New procedure that checks\n\tthe legality and completeness of the entity associations given\n\tin a Storage_Model_Type aspect.\n\t* sem_util.ads (package Storage_Model_Support): New nested\n\tpackage that encapsulates a set of convenient utility functions\n\tfor retrieving entities, etc. associated with\n\tstorage-model-related types and objects.\n\t(Get_Storage_Model_Type_Entity): New function to return a\n\tspecified entity associated with a type that has aspect\n\tStorage_Model_Type.\n\t(Has_Designated_Storage_Model_Aspect): New function that returns\n\twhether a type has aspect Designated_Storage_Model.\n\t(Has_Storage_Model_Type_Aspect): New function that returns\n\twhether a type has aspect Storage_Model_Type.\n\t(Storage_Model_Object): New function that returns the object\n\tEntity_Id associated with a type's Designated_Storage_Model\n\taspect.\n\t(Storage_Model_Type): New function that returns the type\n\tassociated with a storage-model object (when the object's type\n\tspecifies Storage_Model_Type).\n\t(Storage_Model_Address_Type): New function that returns the\n\tAddress_Type associated with a type that has aspect\n\tStorage_Model_Type.\n\t(Storage_Model_Null_Address): New function that returns the\n\tNull_Address constant associated with a type that has aspect\n\tStorage_Model_Type.\n\t(Storage_Model_Allocate): New function that returns the Allocate\n\tprocedure associated with a type that has aspect\n\tStorage_Model_Type.\n\t(Storage_Model_Deallocate): New function that returns the\n\tDeallocate procedure associated with a type that has aspect\n\tStorage_Model_Type.\n\t(Storage_Model_Copy_From): New function that returns the\n\tCopy_From procedure associated with a type that has aspect\n\tStorage_Model_Type.\n\t(Storage_Model_Copy_To): New function that returns the Copy_To\n\tprocedure associated with a type that has aspect\n\tStorage_Model_Type.\n\t(Storage_Model_Storage_Size): New function that returns the\n\tStorage_Size function associated with a type that has aspect\n\tStorage_Model_Type.\n\t* sem_util.adb (package Storage_Model_Support): Body of new\n\tnested package that contains the implementations the utility\n\tfunctions declared in the spec of this package.\n\t* snames.ads-tmpl: Add new names Name_Designated_Storage_Pool,\n\tName_Storage_Model, Name_Storage_Model_Type, Name_Address_Type,\n\tName_Copy_From, Name_Copy_To, and Name_Null_Address for the new\n\taspects and associated aspect arguments.", "tree": {"sha": "c56978e4d04b0ec0668cfd6d1d7b80c798941379", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c56978e4d04b0ec0668cfd6d1d7b80c798941379"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b479c0f7d7c45f9d99292ca2aa71d7845c7769bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b479c0f7d7c45f9d99292ca2aa71d7845c7769bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b479c0f7d7c45f9d99292ca2aa71d7845c7769bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b479c0f7d7c45f9d99292ca2aa71d7845c7769bc/comments", "author": {"login": "dismukes", "id": 50880541, "node_id": "MDQ6VXNlcjUwODgwNTQx", "avatar_url": "https://avatars.githubusercontent.com/u/50880541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dismukes", "html_url": "https://github.com/dismukes", "followers_url": "https://api.github.com/users/dismukes/followers", "following_url": "https://api.github.com/users/dismukes/following{/other_user}", "gists_url": "https://api.github.com/users/dismukes/gists{/gist_id}", "starred_url": "https://api.github.com/users/dismukes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dismukes/subscriptions", "organizations_url": "https://api.github.com/users/dismukes/orgs", "repos_url": "https://api.github.com/users/dismukes/repos", "events_url": "https://api.github.com/users/dismukes/events{/privacy}", "received_events_url": "https://api.github.com/users/dismukes/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e035b4f5924b5fa5d32cb91f476221ab6edef0bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e035b4f5924b5fa5d32cb91f476221ab6edef0bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e035b4f5924b5fa5d32cb91f476221ab6edef0bb"}], "stats": {"total": 839, "additions": 834, "deletions": 5}, "files": [{"sha": "ab11bfda2f957a6a908c8001f4ae2e7eae7f0460", "filename": "gcc/ada/aspects.ads", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b479c0f7d7c45f9d99292ca2aa71d7845c7769bc/gcc%2Fada%2Faspects.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b479c0f7d7c45f9d99292ca2aa71d7845c7769bc/gcc%2Fada%2Faspects.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.ads?ref=b479c0f7d7c45f9d99292ca2aa71d7845c7769bc", "patch": "@@ -89,6 +89,7 @@ package Aspects is\n       Aspect_Default_Storage_Pool,\n       Aspect_Default_Value,\n       Aspect_Depends,                       -- GNAT\n+      Aspect_Designated_Storage_Model,      -- GNAT\n       Aspect_Dimension,                     -- GNAT\n       Aspect_Dimension_System,              -- GNAT\n       Aspect_Dispatching_Domain,\n@@ -147,6 +148,7 @@ package Aspects is\n       Aspect_SPARK_Mode,                    -- GNAT\n       Aspect_Stable_Properties,\n       Aspect_Static_Predicate,\n+      Aspect_Storage_Model_Type,            -- GNAT\n       Aspect_Storage_Pool,\n       Aspect_Storage_Size,\n       Aspect_Stream_Size,\n@@ -380,6 +382,7 @@ package Aspects is\n       Aspect_Default_Storage_Pool       => Expression,\n       Aspect_Default_Value              => Expression,\n       Aspect_Depends                    => Expression,\n+      Aspect_Designated_Storage_Model   => Name,\n       Aspect_Dimension                  => Expression,\n       Aspect_Dimension_System           => Expression,\n       Aspect_Dispatching_Domain         => Expression,\n@@ -438,6 +441,7 @@ package Aspects is\n       Aspect_SPARK_Mode                 => Optional_Name,\n       Aspect_Stable_Properties          => Expression,\n       Aspect_Static_Predicate           => Expression,\n+      Aspect_Storage_Model_Type         => Expression,\n       Aspect_Storage_Pool               => Name,\n       Aspect_Storage_Size               => Expression,\n       Aspect_Stream_Size                => Expression,\n@@ -485,6 +489,7 @@ package Aspects is\n       Aspect_Default_Storage_Pool         => True,\n       Aspect_Default_Value                => True,\n       Aspect_Depends                      => False,\n+      Aspect_Designated_Storage_Model     => True,\n       Aspect_Dimension                    => False,\n       Aspect_Dimension_System             => False,\n       Aspect_Dispatching_Domain           => False,\n@@ -544,6 +549,7 @@ package Aspects is\n       Aspect_SPARK_Mode                   => False,\n       Aspect_Stable_Properties            => False,\n       Aspect_Static_Predicate             => False,\n+      Aspect_Storage_Model_Type           => False,\n       Aspect_Storage_Pool                 => True,\n       Aspect_Storage_Size                 => True,\n       Aspect_Stream_Size                  => True,\n@@ -637,6 +643,7 @@ package Aspects is\n       Aspect_Default_Storage_Pool         => Name_Default_Storage_Pool,\n       Aspect_Default_Value                => Name_Default_Value,\n       Aspect_Depends                      => Name_Depends,\n+      Aspect_Designated_Storage_Model     => Name_Designated_Storage_Model,\n       Aspect_Dimension                    => Name_Dimension,\n       Aspect_Dimension_System             => Name_Dimension_System,\n       Aspect_Disable_Controlled           => Name_Disable_Controlled,\n@@ -726,6 +733,7 @@ package Aspects is\n       Aspect_Stable_Properties            => Name_Stable_Properties,\n       Aspect_Static                       => Name_Static,\n       Aspect_Static_Predicate             => Name_Static_Predicate,\n+      Aspect_Storage_Model_Type           => Name_Storage_Model_Type,\n       Aspect_Storage_Pool                 => Name_Storage_Pool,\n       Aspect_Storage_Size                 => Name_Storage_Size,\n       Aspect_Stream_Size                  => Name_Stream_Size,\n@@ -881,6 +889,7 @@ package Aspects is\n       Aspect_Default_Storage_Pool         => Always_Delay,\n       Aspect_Default_Value                => Always_Delay,\n       Aspect_Default_Component_Value      => Always_Delay,\n+      Aspect_Designated_Storage_Model     => Always_Delay,\n       Aspect_Discard_Names                => Always_Delay,\n       Aspect_Dispatching_Domain           => Always_Delay,\n       Aspect_Dynamic_Predicate            => Always_Delay,\n@@ -932,6 +941,7 @@ package Aspects is\n       Aspect_Simple_Storage_Pool          => Always_Delay,\n       Aspect_Simple_Storage_Pool_Type     => Always_Delay,\n       Aspect_Static_Predicate             => Always_Delay,\n+      Aspect_Storage_Model_Type           => Always_Delay,\n       Aspect_Storage_Pool                 => Always_Delay,\n       Aspect_Stream_Size                  => Always_Delay,\n       Aspect_String_Literal               => Always_Delay,"}, {"sha": "8dcfa85e756886cb4c9ceef53cebf44f623011ee", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b479c0f7d7c45f9d99292ca2aa71d7845c7769bc/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b479c0f7d7c45f9d99292ca2aa71d7845c7769bc/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=b479c0f7d7c45f9d99292ca2aa71d7845c7769bc", "patch": "@@ -4704,7 +4704,7 @@ package body Exp_Ch4 is\n \n             else\n                Set_Procedure_To_Call (N,\n-                 Find_Prim_Op (Etype (Pool), Name_Allocate));\n+                 Find_Storage_Op (Etype (Pool), Name_Allocate));\n             end if;\n          end if;\n       end if;"}, {"sha": "86cb70234e61af3f8ee8cfc49816449a001972d3", "filename": "gcc/ada/exp_intr.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b479c0f7d7c45f9d99292ca2aa71d7845c7769bc/gcc%2Fada%2Fexp_intr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b479c0f7d7c45f9d99292ca2aa71d7845c7769bc/gcc%2Fada%2Fexp_intr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_intr.adb?ref=b479c0f7d7c45f9d99292ca2aa71d7845c7769bc", "patch": "@@ -1151,7 +1151,7 @@ package body Exp_Intr is\n \n          else\n             Set_Procedure_To_Call\n-              (Free_Nod, Find_Prim_Op (Etype (Pool), Name_Deallocate));\n+              (Free_Nod, Find_Storage_Op (Etype (Pool), Name_Deallocate));\n          end if;\n       end if;\n "}, {"sha": "cb180967d67fe70a74cfecc73b52876560bd536b", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b479c0f7d7c45f9d99292ca2aa71d7845c7769bc/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b479c0f7d7c45f9d99292ca2aa71d7845c7769bc/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=b479c0f7d7c45f9d99292ca2aa71d7845c7769bc", "patch": "@@ -6256,6 +6256,32 @@ package body Exp_Util is\n       raise Program_Error;\n    end Find_Protection_Type;\n \n+   function Find_Storage_Op\n+     (Typ : Entity_Id;\n+      Nam : Name_Id) return Entity_Id\n+   is\n+      use Sem_Util.Storage_Model_Support;\n+\n+   begin\n+      if Has_Storage_Model_Type_Aspect (Typ) then\n+         declare\n+            SMT_Op : constant Entity_Id :=\n+                       Get_Storage_Model_Type_Entity (Typ, Nam);\n+         begin\n+            if not Present (SMT_Op) then\n+               raise Program_Error;\n+            else\n+               return SMT_Op;\n+            end if;\n+         end;\n+\n+      --  Otherwise we assume that Typ is a descendant of Root_Storage_Pool\n+\n+      else\n+         return Find_Prim_Op (Typ, Nam);\n+      end if;\n+   end Find_Storage_Op;\n+\n    -----------------------\n    -- Find_Hook_Context --\n    -----------------------"}, {"sha": "2b61132107cee01789c535f6ea3f779e03ac09ab", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b479c0f7d7c45f9d99292ca2aa71d7845c7769bc/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b479c0f7d7c45f9d99292ca2aa71d7845c7769bc/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=b479c0f7d7c45f9d99292ca2aa71d7845c7769bc", "patch": "@@ -628,6 +628,16 @@ package Exp_Util is\n    --  Given a protected type or its corresponding record, find the type of\n    --  field _object.\n \n+   function Find_Storage_Op\n+     (Typ : Entity_Id;\n+      Nam : Name_Id) return Entity_Id;\n+   --  Given type Typ that's either a descendant of Root_Storage_Pool or else\n+   --  specifies aspect Storage_Model_Type, returns the Entity_Id of the\n+   --  subprogram associated with Nam, which must either be a primitive op of\n+   --  the type in the case of a storage pool, or the operation corresponding\n+   --  to Nam as specified in the aspect Storage_Model_Type. It is an error if\n+   --  no operation corresponding to the given name is found.\n+\n    function Find_Hook_Context (N : Node_Id) return Node_Id;\n    --  Determine a suitable node on which to attach actions related to N that\n    --  need to be elaborated unconditionally. In general this is the topmost"}, {"sha": "fb1be479de1f7413f4610539a756a3d39340831b", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 547, "deletions": 3, "changes": 550, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b479c0f7d7c45f9d99292ca2aa71d7845c7769bc/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b479c0f7d7c45f9d99292ca2aa71d7845c7769bc/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=b479c0f7d7c45f9d99292ca2aa71d7845c7769bc", "patch": "@@ -262,6 +262,19 @@ package body Sem_Ch13 is\n    --  Check legality of functions given in the Ada 2022 Stable_Properties\n    --  (or Stable_Properties'Class) aspect.\n \n+   procedure Validate_Storage_Model_Type_Aspect\n+     (Typ : Entity_Id; ASN : Node_Id);\n+   --  Check legality and completeness of the aggregate associations given in\n+   --  the Storage_Model_Type aspect associated with Typ.\n+\n+   procedure Resolve_Storage_Model_Type_Argument\n+     (N         : Node_Id;\n+      Typ       : Entity_Id;\n+      Addr_Type : in out Entity_Id;\n+      Nam       : Name_Id);\n+   --  Resolve argument N to be of the proper kind (when a type or constant)\n+   --  or to have the proper profile (when a subprogram).\n+\n    procedure Resolve_Aspect_Stable_Properties\n     (Typ_Or_Subp   : Entity_Id;\n      Expr          : Node_Id;\n@@ -1517,6 +1530,32 @@ package body Sem_Ch13 is\n                   when Aspect_Iterable =>\n                      Validate_Iterable_Aspect (E, ASN);\n \n+                  when Aspect_Designated_Storage_Model =>\n+                     Analyze_And_Resolve (Expression (ASN));\n+\n+                     if not Is_Entity_Name (Expression (ASN))\n+                       or else not Is_Object (Entity (Expression (ASN)))\n+                       or else\n+                         not Present (Find_Aspect (Etype (Expression (ASN)),\n+                                                   Aspect_Storage_Model_Type))\n+                     then\n+                        Error_Msg_N\n+                          (\"must specify name of stand-alone object of type \"\n+                            & \"with aspect Storage_Model_Type\",\n+                           Expression (ASN));\n+\n+                     --  Set access type's Associated_Storage_Pool to denote\n+                     --  the Storage_Model_Type object given for the aspect\n+                     --  (even though that isn't actually an Ada storage pool).\n+\n+                     else\n+                        Set_Associated_Storage_Pool\n+                          (E, Entity (Expression (ASN)));\n+                     end if;\n+\n+                  when Aspect_Storage_Model_Type =>\n+                     Validate_Storage_Model_Type_Aspect (E, ASN);\n+\n                   when Aspect_Aggregate =>\n                      null;\n \n@@ -3065,10 +3104,11 @@ package body Sem_Ch13 is\n \n             if Delay_Required\n \n-               and then A_Id = Aspect_Stable_Properties\n+               and then (A_Id = Aspect_Stable_Properties\n+                          or else A_Id = Aspect_Designated_Storage_Model\n+                          or else A_Id = Aspect_Storage_Model_Type)\n                --  ??? It seems like we should do this for all aspects, not\n-               --  just Stable_Properties, but that causes as-yet-undiagnosed\n-               --  regressions.\n+               --  just these, but that causes as-yet-undiagnosed regressions.\n \n             then\n                Set_Has_Delayed_Aspects (E);\n@@ -4368,6 +4408,44 @@ package body Sem_Ch13 is\n                   Record_Rep_Item (E, Aspect);\n                   goto Continue;\n \n+               when Aspect_Designated_Storage_Model =>\n+                  if not Extensions_Allowed then\n+                     Error_Msg_N\n+                       (\"aspect only allowed if extensions enabled\",\n+                        Aspect);\n+                     Error_Msg_N\n+                       (\"\\unit must be compiled with -gnatX switch\", Aspect);\n+\n+                  elsif not Is_Type (E)\n+                    or else Ekind (E) /= E_Access_Type\n+                  then\n+                     Error_Msg_N\n+                       (\"can only be specified for pool-specific access type\",\n+                        Aspect);\n+                  end if;\n+\n+                  Record_Rep_Item (E, Aspect);\n+                  goto Continue;\n+\n+               when Aspect_Storage_Model_Type =>\n+                  if not Extensions_Allowed then\n+                     Error_Msg_N\n+                       (\"aspect only allowed if extensions enabled\",\n+                        Aspect);\n+                     Error_Msg_N\n+                       (\"\\unit must be compiled with -gnatX switch\", Aspect);\n+\n+                  elsif not Is_Type (E)\n+                    or else not Is_Immutably_Limited_Type (E)\n+                  then\n+                     Error_Msg_N\n+                       (\"can only be specified for immutably limited type\",\n+                        Aspect);\n+                  end if;\n+\n+                  Record_Rep_Item (E, Aspect);\n+                  goto Continue;\n+\n                when Aspect_Integer_Literal\n                   | Aspect_Real_Literal\n                   | Aspect_String_Literal\n@@ -11229,6 +11307,34 @@ package body Sem_Ch13 is\n \n          --  Here is the list of aspects that don't require delay analysis\n \n+         when Aspect_Designated_Storage_Model =>\n+            return;\n+\n+         when Aspect_Storage_Model_Type =>\n+            T := Entity (ASN);\n+\n+            declare\n+               Assoc     : Node_Id;\n+               Expr      : Node_Id;\n+               Addr_Type : Entity_Id := Empty;\n+\n+            begin\n+               Assoc := First (Component_Associations (Expression (ASN)));\n+               while Present (Assoc) loop\n+                  Expr := Expression (Assoc);\n+                  Analyze (Expr);\n+\n+                  if not Error_Posted (Expr) then\n+                     Resolve_Storage_Model_Type_Argument\n+                       (Expr, T, Addr_Type, Chars (First (Choices (Assoc))));\n+                  end if;\n+\n+                  Next (Assoc);\n+               end loop;\n+            end;\n+\n+            return;\n+\n          when Aspect_Abstract_State\n             | Aspect_Annotate\n             | Aspect_Async_Readers\n@@ -16199,6 +16305,334 @@ package body Sem_Ch13 is\n       Set_Analyzed (Expr);\n    end Resolve_Aspect_Stable_Properties;\n \n+   -----------------------------------------\n+   -- Resolve_Storage_Model_Type_Argument --\n+   -----------------------------------------\n+\n+   procedure Resolve_Storage_Model_Type_Argument\n+     (N         : Node_Id;\n+      Typ       : Entity_Id;\n+      Addr_Type : in out Entity_Id;\n+      Nam       : Name_Id)\n+   is\n+\n+      type Formal_Profile is record\n+         Subt : Entity_Id;\n+         Mode : Formal_Kind;\n+      end record;\n+\n+      type Formal_Profiles is array (Positive range <>) of Formal_Profile;\n+\n+      function Aspect_Argument_Profile_Matches\n+        (Subp            : Entity_Id;\n+         Profiles        : Formal_Profiles;\n+         Result_Subt     : Entity_Id;\n+         Err_On_Mismatch : Boolean) return Boolean;\n+      --  Checks that the formal parameters of subprogram Subp conform to the\n+      --  subtypes and modes specified by Profiles, as well as to the result\n+      --  subtype Result_Subt when that is nonempty.\n+\n+      function Aspect_Argument_Profile_Matches\n+        (Subp            : Entity_Id;\n+         Profiles        : Formal_Profiles;\n+         Result_Subt     : Entity_Id;\n+         Err_On_Mismatch : Boolean) return Boolean\n+      is\n+\n+         procedure Report_Argument_Error\n+           (Msg    : String;\n+            Formal : Entity_Id := Empty;\n+            Subt   : Entity_Id := Empty);\n+         --  If Err_On_Mismatch is True, reports an argument error given by Msg\n+         --  associated with Formal and/or Subt.\n+\n+         procedure Report_Argument_Error\n+           (Msg    : String;\n+            Formal : Entity_Id := Empty;\n+            Subt   : Entity_Id := Empty)\n+         is\n+         begin\n+            if Err_On_Mismatch then\n+               if Present (Formal) then\n+                  if Present (Subt) then\n+                     Error_Msg_Node_2 := Subt;\n+                  end if;\n+                  Error_Msg_NE (Msg, N, Formal);\n+\n+               elsif Present (Subt) then\n+                  Error_Msg_NE (Msg, N, Subt);\n+\n+               else\n+                  Error_Msg_N (Msg, N);\n+               end if;\n+            end if;\n+         end Report_Argument_Error;\n+\n+         --  Local variables\n+\n+         Formal    : Entity_Id := First_Formal (Subp);\n+         Is_Error  : Boolean   := False;\n+\n+      --  Start of processing for Aspect_Argument_Profile_Matches\n+\n+      begin\n+         for FP of Profiles loop\n+            if not Present (Formal) then\n+               Is_Error := True;\n+               Report_Argument_Error (\"missing formal of }\", Subt => FP.Subt);\n+               exit;\n+\n+            elsif not Subtypes_Statically_Match\n+                        (Etype (Formal), FP.Subt)\n+            then\n+               Is_Error := True;\n+               Report_Argument_Error\n+                 (\"formal& must be of subtype&\",\n+                  Formal => Formal, Subt => FP.Subt);\n+               exit;\n+\n+            elsif Ekind (Formal) /= FP.Mode then\n+               Is_Error := True;\n+               Report_Argument_Error\n+                 (\"formal& has wrong mode\", Formal => Formal);\n+               exit;\n+            end if;\n+\n+            Formal := Next_Formal (Formal);\n+         end loop;\n+\n+         if not Is_Error\n+           and then Present (Formal)\n+         then\n+            Is_Error := True;\n+            Report_Argument_Error\n+              (\"too many formals for subprogram in aspect\");\n+         end if;\n+\n+         if not Is_Error\n+           and then Present (Result_Subt)\n+           and then not Subtypes_Statically_Match (Etype (Subp), Result_Subt)\n+         then\n+            Is_Error := True;\n+            Report_Argument_Error\n+              (\"subprogram must have result}\", Subt => Result_Subt);\n+         end if;\n+\n+         return not Is_Error;\n+      end Aspect_Argument_Profile_Matches;\n+\n+      --  Local variables\n+\n+      Ent : Entity_Id;\n+\n+      Storage_Count_Type  : constant Entity_Id := RTE (RE_Storage_Count);\n+      System_Address_Type : constant Entity_Id := RTE (RE_Address);\n+\n+   --  Start of processing for Resolve_Storage_Model_Type_Argument\n+\n+   begin\n+      if Nam = Name_Address_Type then\n+         if not Is_Entity_Name (N)\n+           or else not Is_Type (Entity (N))\n+           or else (Root_Type (Entity (N)) /= System_Address_Type\n+                     and then not Is_Integer_Type (Entity (N)))\n+         then\n+            Error_Msg_N (\"named entity must be a descendant of System.Address \"\n+                         & \"or an integer type\", N);\n+         end if;\n+\n+         Addr_Type := Entity (N);\n+\n+         return;\n+\n+      elsif not Present (Addr_Type) then\n+         Error_Msg_N (\"argument association for Address_Type missing; \"\n+                         & \"must be specified as first aspect argument\", N);\n+         return;\n+\n+      elsif Nam = Name_Null_Address then\n+         if not Is_Entity_Name (N)\n+           or else not Is_Constant_Object (Entity (N))\n+           or else\n+             not Subtypes_Statically_Match (Etype (Entity (N)), Addr_Type)\n+         then\n+            Error_Msg_NE\n+              (\"named entity must be constant of subtype}\", N, Addr_Type);\n+         end if;\n+\n+         return;\n+\n+      elsif not Is_Overloaded (N) then\n+         if not Is_Entity_Name (N)\n+           or else Ekind (Entity (N)) not in E_Function | E_Procedure\n+           or else Scope (Entity (N)) /= Scope (Typ)\n+         then\n+            Error_Msg_N (\"argument must be local subprogram name\", N);\n+            return;\n+         end if;\n+\n+         Ent := Entity (N);\n+\n+         if Nam = Name_Allocate then\n+            if not Aspect_Argument_Profile_Matches\n+                     (Ent,\n+                      Profiles        =>\n+                        ((Typ,                E_In_Out_Parameter),\n+                         (Addr_Type,          E_Out_Parameter),\n+                         (Storage_Count_Type, E_In_Parameter),\n+                         (Storage_Count_Type, E_In_Parameter)),\n+                      Result_Subt     => Empty,\n+                      Err_On_Mismatch => True)\n+            then\n+               Error_Msg_N (\"no match for Allocate operation\", N);\n+            end if;\n+\n+         elsif Nam = Name_Deallocate then\n+            if not Aspect_Argument_Profile_Matches\n+                     (Ent,\n+                      Profiles        =>\n+                        ((Typ,                E_In_Out_Parameter),\n+                         (Addr_Type,          E_In_Parameter),\n+                         (Storage_Count_Type, E_In_Parameter),\n+                         (Storage_Count_Type, E_In_Parameter)),\n+                      Result_Subt     => Empty,\n+                      Err_On_Mismatch => True)\n+            then\n+               Error_Msg_N (\"no match for Deallocate operation\", N);\n+            end if;\n+\n+         elsif Nam = Name_Copy_From then\n+            if not Aspect_Argument_Profile_Matches\n+                     (Ent,\n+                      Profiles        =>\n+                        ((Typ,                 E_In_Out_Parameter),\n+                         (System_Address_Type, E_In_Parameter),\n+                         (Addr_Type,           E_In_Parameter),\n+                         (Storage_Count_Type,  E_In_Parameter)),\n+                      Result_Subt     => Empty,\n+                      Err_On_Mismatch => True)\n+            then\n+               Error_Msg_N (\"no match for Copy_From operation\", N);\n+            end if;\n+\n+         elsif Nam = Name_Copy_To then\n+            if not Aspect_Argument_Profile_Matches\n+                     (Ent,\n+                      Profiles        =>\n+                        ((Typ,                 E_In_Out_Parameter),\n+                         (Addr_Type,           E_In_Parameter),\n+                         (System_Address_Type, E_In_Parameter),\n+                         (Storage_Count_Type,  E_In_Parameter)),\n+                      Result_Subt     => Empty,\n+                      Err_On_Mismatch => True)\n+            then\n+               Error_Msg_N (\"no match for Copy_To operation\", N);\n+            end if;\n+\n+         elsif Nam = Name_Storage_Size then\n+            if not Aspect_Argument_Profile_Matches\n+                     (Ent,\n+                      Profiles        => (1 => (Typ, E_In_Parameter)),\n+                      Result_Subt     => Storage_Count_Type,\n+                      Err_On_Mismatch => True)\n+            then\n+               Error_Msg_N (\"no match for Storage_Size operation\", N);\n+            end if;\n+\n+         else\n+            null; -- Error will be caught in Validate_Storage_Model_Type_Aspect\n+         end if;\n+\n+      else\n+         --  Overloaded case: find subprogram with proper signature\n+\n+         declare\n+            I  : Interp_Index;\n+            It : Interp;\n+            Found_Match : Boolean := False;\n+\n+         begin\n+            Get_First_Interp (N, I, It);\n+            while Present (It.Typ) loop\n+               if Ekind (It.Nam) in E_Function | E_Procedure\n+                  and then Scope (It.Nam) = Scope (Typ)\n+               then\n+                  if Nam = Name_Allocate then\n+                     Found_Match :=\n+                       Aspect_Argument_Profile_Matches\n+                         (It.Nam,\n+                          Profiles        =>\n+                            ((Typ,                E_In_Out_Parameter),\n+                             (Addr_Type,          E_Out_Parameter),\n+                             (Storage_Count_Type, E_In_Parameter),\n+                             (Storage_Count_Type, E_In_Parameter)),\n+                          Result_Subt     => Empty,\n+                          Err_On_Mismatch => False);\n+\n+                  elsif Nam = Name_Deallocate then\n+                     Found_Match :=\n+                       Aspect_Argument_Profile_Matches\n+                         (It.Nam,\n+                          Profiles        =>\n+                            ((Typ,                E_In_Out_Parameter),\n+                             (Addr_Type,          E_In_Parameter),\n+                             (Storage_Count_Type, E_In_Parameter),\n+                             (Storage_Count_Type, E_In_Parameter)),\n+                          Result_Subt     => Empty,\n+                          Err_On_Mismatch => False);\n+\n+                  elsif Nam = Name_Copy_From then\n+                     Found_Match :=\n+                       Aspect_Argument_Profile_Matches\n+                         (It.Nam,\n+                          Profiles        =>\n+                            ((Typ,                 E_In_Out_Parameter),\n+                             (System_Address_Type, E_In_Parameter),\n+                             (Addr_Type,           E_In_Parameter),\n+                             (Storage_Count_Type,  E_In_Parameter),\n+                             (Storage_Count_Type,  E_In_Parameter)),\n+                          Result_Subt     => Empty,\n+                          Err_On_Mismatch => False);\n+\n+                  elsif Nam = Name_Copy_To then\n+                     Found_Match :=\n+                       Aspect_Argument_Profile_Matches\n+                         (It.Nam,\n+                          Profiles        =>\n+                            ((Typ,                 E_In_Out_Parameter),\n+                             (Addr_Type,           E_In_Parameter),\n+                             (Storage_Count_Type,  E_In_Parameter),\n+                             (System_Address_Type, E_In_Parameter),\n+                             (Storage_Count_Type,  E_In_Parameter)),\n+                          Result_Subt     => Empty,\n+                          Err_On_Mismatch => False);\n+\n+                  elsif Nam = Name_Storage_Size then\n+                     Found_Match :=\n+                       Aspect_Argument_Profile_Matches\n+                         (It.Nam,\n+                          Profiles        => (1 => (Typ, E_In_Parameter)),\n+                          Result_Subt     => Storage_Count_Type,\n+                          Err_On_Mismatch => False);\n+                  end if;\n+\n+                  if Found_Match then\n+                     Set_Entity (N, It.Nam);\n+                     exit;\n+                  end if;\n+               end if;\n+\n+               Get_Next_Interp (I, It);\n+            end loop;\n+\n+            if not Found_Match then\n+               Error_Msg_N\n+                 (\"no match found for Storage_Model_Type operation\", N);\n+            end if;\n+         end;\n+      end if;\n+   end Resolve_Storage_Model_Type_Argument;\n+\n    ----------------\n    -- Set_Biased --\n    ----------------\n@@ -16781,6 +17215,116 @@ package body Sem_Ch13 is\n       end if;\n    end Validate_Literal_Aspect;\n \n+   ----------------------------------------\n+   -- Validate_Storage_Model_Type_Aspect --\n+   ----------------------------------------\n+\n+   procedure Validate_Storage_Model_Type_Aspect\n+     (Typ : Entity_Id; ASN : Node_Id)\n+   is\n+      Assoc  : Node_Id;\n+      Choice : Entity_Id;\n+      Expr   : Node_Id;\n+\n+      Address_Type_Id : Entity_Id := Empty;\n+      Null_Address_Id : Entity_Id := Empty;\n+      Allocate_Id     : Entity_Id := Empty;\n+      Deallocate_Id   : Entity_Id := Empty;\n+      Copy_From_Id    : Entity_Id := Empty;\n+      Copy_To_Id      : Entity_Id := Empty;\n+      Storage_Size_Id : Entity_Id := Empty;\n+\n+   begin\n+      --  Each expression must resolve to an entity of the right kind or proper\n+      --  profile.\n+\n+      Assoc := First (Component_Associations (Expression (ASN)));\n+      while Present (Assoc) loop\n+         Expr := Expression (Assoc);\n+         Analyze (Expr);\n+\n+         Choice := First (Choices (Assoc));\n+\n+         if Nkind (Choice) /= N_Identifier or else Present (Next (Choice)) then\n+            Error_Msg_N (\"illegal name in association\", Choice);\n+\n+         elsif Chars (Choice) = Name_Address_Type then\n+            if Assoc /= First (Component_Associations (Expression (ASN))) then\n+               Error_Msg_N (\"Address_Type must be first association\", Choice);\n+            end if;\n+\n+            Resolve_Storage_Model_Type_Argument\n+              (Expr, Typ, Address_Type_Id, Name_Address_Type);\n+            Address_Type_Id := Entity (Expr);\n+\n+         --  Shouldn't we check for duplicates of the same subaspect name,\n+         --  and issue an error in such cases???\n+\n+         elsif not Present (Address_Type_Id) then\n+            Error_Msg_N\n+              (\"Address_Type missing, must be first association\", Choice);\n+\n+         elsif Chars (Choice) = Name_Null_Address then\n+            Resolve_Storage_Model_Type_Argument\n+              (Expr, Typ, Address_Type_Id, Name_Null_Address);\n+            Null_Address_Id := Entity (Expr);\n+\n+         elsif Chars (Choice) = Name_Allocate then\n+            Resolve_Storage_Model_Type_Argument\n+              (Expr, Typ, Address_Type_Id, Name_Allocate);\n+            Allocate_Id := Entity (Expr);\n+\n+         elsif Chars (Choice) = Name_Deallocate then\n+            Resolve_Storage_Model_Type_Argument\n+              (Expr, Typ, Address_Type_Id, Name_Deallocate);\n+            Deallocate_Id := Entity (Expr);\n+\n+         elsif Chars (Choice) = Name_Copy_From then\n+            Resolve_Storage_Model_Type_Argument\n+              (Expr, Typ, Address_Type_Id, Name_Copy_From);\n+            Copy_From_Id := Entity (Expr);\n+\n+         elsif Chars (Choice) = Name_Copy_To then\n+            Resolve_Storage_Model_Type_Argument\n+              (Expr, Typ, Address_Type_Id, Name_Copy_To);\n+            Copy_To_Id := Entity (Expr);\n+\n+         elsif Chars (Choice) = Name_Storage_Size then\n+            Resolve_Storage_Model_Type_Argument\n+              (Expr, Typ, Address_Type_Id, Name_Storage_Size);\n+            Storage_Size_Id := Entity (Expr);\n+\n+         else\n+            Error_Msg_N\n+              (\"invalid name for Storage_Model_Type argument\", Choice);\n+         end if;\n+\n+         Next (Assoc);\n+      end loop;\n+\n+      if No (Address_Type_Id) then\n+         Error_Msg_N (\"match for Address_Type not found\", ASN);\n+\n+      elsif No (Null_Address_Id) then\n+         Error_Msg_N (\"match for Null_Address primitive not found\", ASN);\n+\n+      elsif No (Allocate_Id) then\n+         Error_Msg_N (\"match for Allocate primitive not found\", ASN);\n+\n+      elsif No (Deallocate_Id) then\n+         Error_Msg_N (\"match for Deallocate primitive not found\", ASN);\n+\n+      elsif No (Copy_From_Id) then\n+         Error_Msg_N (\"match for Copy_From primitive not found\", ASN);\n+\n+      elsif No (Copy_To_Id) then\n+         Error_Msg_N (\"match for Copy_To primitive not found\", ASN);\n+\n+      elsif No (Storage_Size_Id) then\n+         Error_Msg_N (\"match for Storage_Size primitive not found\", ASN);\n+      end if;\n+   end Validate_Storage_Model_Type_Aspect;\n+\n    -----------------------------------\n    -- Validate_Unchecked_Conversion --\n    -----------------------------------"}, {"sha": "b5f3d4cce034b6536e57168551b09fa78ffa404b", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b479c0f7d7c45f9d99292ca2aa71d7845c7769bc/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b479c0f7d7c45f9d99292ca2aa71d7845c7769bc/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=b479c0f7d7c45f9d99292ca2aa71d7845c7769bc", "patch": "@@ -32153,6 +32153,166 @@ package body Sem_Util is\n \n       end Indirect_Temps;\n    end Old_Attr_Util;\n+\n+   package body Storage_Model_Support is\n+\n+      -----------------------------------\n+      -- Get_Storage_Model_Type_Entity --\n+      -----------------------------------\n+\n+      function Get_Storage_Model_Type_Entity\n+        (Typ : Entity_Id;\n+         Nam : Name_Id) return Entity_Id\n+      is\n+         pragma Assert\n+           (Is_Type (Typ)\n+            and then\n+              Nam in Name_Address_Type\n+                   | Name_Null_Address\n+                   | Name_Allocate\n+                   | Name_Deallocate\n+                   | Name_Copy_From\n+                   | Name_Copy_To\n+                   | Name_Storage_Size);\n+\n+         SMT_Aspect_Value : constant Node_Id :=\n+           Find_Value_Of_Aspect (Typ, Aspect_Storage_Model_Type);\n+         Assoc            : Node_Id;\n+\n+      begin\n+         if No (SMT_Aspect_Value) then\n+            return Empty;\n+\n+         else\n+            Assoc := First (Component_Associations (SMT_Aspect_Value));\n+            while Present (Assoc) loop\n+               if Chars (First (Choices (Assoc))) = Nam then\n+                  return Entity (Expression (Assoc));\n+               end if;\n+\n+               Next (Assoc);\n+            end loop;\n+\n+            return Empty;\n+         end if;\n+      end Get_Storage_Model_Type_Entity;\n+\n+      -----------------------------------------\n+      -- Has_Designated_Storage_Model_Aspect --\n+      -----------------------------------------\n+\n+      function Has_Designated_Storage_Model_Aspect\n+        (Typ : Entity_Id) return Boolean\n+      is\n+      begin\n+         return Present (Find_Aspect (Typ, Aspect_Designated_Storage_Model));\n+      end Has_Designated_Storage_Model_Aspect;\n+\n+      -----------------------------------\n+      -- Has_Storage_Model_Type_Aspect --\n+      -----------------------------------\n+\n+      function Has_Storage_Model_Type_Aspect (Typ : Entity_Id) return Boolean\n+      is\n+      begin\n+         return Present (Find_Aspect (Typ, Aspect_Storage_Model_Type));\n+      end Has_Storage_Model_Type_Aspect;\n+\n+      --------------------------\n+      -- Storage_Model_Object --\n+      --------------------------\n+\n+      function Storage_Model_Object (Typ : Entity_Id) return Entity_Id is\n+      begin\n+         if Has_Designated_Storage_Model_Aspect (Typ) then\n+            return\n+              Entity\n+                (Find_Value_Of_Aspect (Typ, Aspect_Designated_Storage_Model));\n+         else\n+            return Empty;\n+         end if;\n+      end Storage_Model_Object;\n+\n+      ------------------------\n+      -- Storage_Model_Type --\n+      ------------------------\n+\n+      function Storage_Model_Type (Obj : Entity_Id) return Entity_Id is\n+      begin\n+         if Present\n+              (Find_Value_Of_Aspect (Etype (Obj), Aspect_Storage_Model_Type))\n+         then\n+            return Etype (Obj);\n+         else\n+            return Empty;\n+         end if;\n+      end Storage_Model_Type;\n+\n+      --------------------------------\n+      -- Storage_Model_Address_Type --\n+      --------------------------------\n+\n+      function Storage_Model_Address_Type (Typ : Entity_Id) return Entity_Id is\n+      begin\n+         return Get_Storage_Model_Type_Entity (Typ, Name_Address_Type);\n+      end Storage_Model_Address_Type;\n+\n+      --------------------------------\n+      -- Storage_Model_Null_Address --\n+      --------------------------------\n+\n+      function Storage_Model_Null_Address (Typ : Entity_Id) return Entity_Id is\n+      begin\n+         return Get_Storage_Model_Type_Entity (Typ, Name_Null_Address);\n+      end Storage_Model_Null_Address;\n+\n+      ----------------------------\n+      -- Storage_Model_Allocate --\n+      ----------------------------\n+\n+      function Storage_Model_Allocate (Typ : Entity_Id) return Entity_Id is\n+      begin\n+         return Get_Storage_Model_Type_Entity (Typ, Name_Allocate);\n+      end Storage_Model_Allocate;\n+\n+      ------------------------------\n+      -- Storage_Model_Deallocate --\n+      ------------------------------\n+\n+      function Storage_Model_Deallocate (Typ : Entity_Id) return Entity_Id is\n+      begin\n+         return Get_Storage_Model_Type_Entity (Typ, Name_Deallocate);\n+      end Storage_Model_Deallocate;\n+\n+      -----------------------------\n+      -- Storage_Model_Copy_From --\n+      -----------------------------\n+\n+      function Storage_Model_Copy_From (Typ : Entity_Id) return Entity_Id is\n+      begin\n+         return Get_Storage_Model_Type_Entity (Typ, Name_Copy_From);\n+      end Storage_Model_Copy_From;\n+\n+      ---------------------------\n+      -- Storage_Model_Copy_To --\n+      ---------------------------\n+\n+      function Storage_Model_Copy_To (Typ : Entity_Id) return Entity_Id is\n+      begin\n+         return Get_Storage_Model_Type_Entity (Typ, Name_Copy_To);\n+      end Storage_Model_Copy_To;\n+\n+      --------------------------------\n+      -- Storage_Model_Storage_Size --\n+      --------------------------------\n+\n+      function Storage_Model_Storage_Size (Typ : Entity_Id) return Entity_Id is\n+      begin\n+         return Get_Storage_Model_Type_Entity (Typ, Name_Storage_Size);\n+      end Storage_Model_Storage_Size;\n+\n+   end Storage_Model_Support;\n+\n begin\n    Erroutc.Subprogram_Name_Ptr := Subprogram_Name'Access;\n end Sem_Util;"}, {"sha": "85010b5713080c0a71bc47f5603f0df4d6b8d286", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b479c0f7d7c45f9d99292ca2aa71d7845c7769bc/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b479c0f7d7c45f9d99292ca2aa71d7845c7769bc/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=b479c0f7d7c45f9d99292ca2aa71d7845c7769bc", "patch": "@@ -3550,4 +3550,76 @@ package Sem_Util is\n \n       end Indirect_Temps;\n    end Old_Attr_Util;\n+\n+   package Storage_Model_Support is\n+\n+      --  This package provides a set of utility functions related to support\n+      --  for the Storage_Model feature. These functions provide an interface\n+      --  that the compiler (in particular back-end phases such as gigi and\n+      --  GNAT-LLVM) can use to easily obtain entities and operations that\n+      --  are specified for types in the aspects Storage_Model_Type and\n+      --  Designated_Storage_Model.\n+\n+      function Get_Storage_Model_Type_Entity\n+        (Typ : Entity_Id;\n+         Nam : Name_Id) return Entity_Id;\n+      --  Given type Typ with aspect Storage_Model_Type, returns the Entity_Id\n+      --  corresponding to the entity associated with Nam in the aspect. If the\n+      --  type does not specify the aspect, or such an entity is not present,\n+      --  then returns Empty. (Note: This function is modeled on function\n+      --  Get_Iterable_Type_Primitive.)\n+\n+      function Has_Designated_Storage_Model_Aspect\n+        (Typ : Entity_Id) return Boolean;\n+      --  Returns True iff Typ specifies aspect Designated_Storage_Model\n+\n+      function Has_Storage_Model_Type_Aspect (Typ : Entity_Id) return Boolean;\n+      --  Returns True iff Typ specifies aspect Storage_Model_Type\n+\n+      function Storage_Model_Object (Typ : Entity_Id) return Entity_Id;\n+      --  Given an access type with aspect Designated_Storage_Model, returns\n+      --  the storage-model object associated with that type; returns Empty\n+      --  if there is no associated object.\n+\n+      function Storage_Model_Type (Obj : Entity_Id) return Entity_Id;\n+      --  Given an object Obj of a type specifying aspect Storage_Model_Type,\n+      --  returns that type; otherwise returns Empty.\n+\n+      function Storage_Model_Address_Type (Typ : Entity_Id) return Entity_Id;\n+      --  Given a type Typ that specifies aspect Storage_Model_Type, returns\n+      --  the type specified for the Address_Type choice in that aspect;\n+      --  returns Empty if the aspect or the type isn't specified.\n+\n+      function Storage_Model_Null_Address (Typ : Entity_Id) return Entity_Id;\n+      --  Given a type Typ that specifies aspect Storage_Model_Type, returns\n+      --  constant specified for Null_Address choice in that aspect; returns\n+      --  Empty if the aspect or the constant object isn't specified.\n+\n+      function Storage_Model_Allocate (Typ : Entity_Id) return Entity_Id;\n+      --  Given a type Typ that specifies aspect Storage_Model_Type, returns\n+      --  procedure specified for the Allocate choice in that aspect; returns\n+      --  Empty if the aspect or the procedure isn't specified.\n+\n+      function Storage_Model_Deallocate (Typ : Entity_Id) return Entity_Id;\n+      --  Given a type Typ that specifies aspect Storage_Model_Type, returns\n+      --  procedure specified for the Deallocate choice in that aspect; returns\n+      --  Empty if the aspect or the procedure isn't specified.\n+\n+      function Storage_Model_Copy_From (Typ : Entity_Id) return Entity_Id;\n+      --  Given a type Typ that specifies aspect Storage_Model_Type, returns\n+      --  procedure specified for the Copy_From choice in that aspect; returns\n+      --  Empty if the aspect or the procedure isn't specified.\n+\n+      function Storage_Model_Copy_To (Typ : Entity_Id) return Entity_Id;\n+      --  Given a type Typ that specifies aspect Storage_Model_Type, returns\n+      --  procedure specified for the Copy_To choice in that aspect; returns\n+      --  Empty if the aspect or the procedure isn't specified.\n+\n+      function Storage_Model_Storage_Size (Typ : Entity_Id) return Entity_Id;\n+      --  Given a type Typ that specifies aspect Storage_Model_Type, returns\n+      --  function specified for Storage_Size choice in that aspect; returns\n+      --  Empty if the aspect or the procedure isn't specified.\n+\n+   end Storage_Model_Support;\n+\n end Sem_Util;"}, {"sha": "8a98deef3862bc1285d1b178badfd99450b26c42", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b479c0f7d7c45f9d99292ca2aa71d7845c7769bc/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b479c0f7d7c45f9d99292ca2aa71d7845c7769bc/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=b479c0f7d7c45f9d99292ca2aa71d7845c7769bc", "patch": "@@ -149,6 +149,7 @@ package Snames is\n \n    Name_Default_Value                  : constant Name_Id := N + $;\n    Name_Default_Component_Value        : constant Name_Id := N + $;\n+   Name_Designated_Storage_Model       : constant Name_Id := N + $;\n    Name_Dimension                      : constant Name_Id := N + $;\n    Name_Dimension_System               : constant Name_Id := N + $;\n    Name_Disable_Controlled             : constant Name_Id := N + $;\n@@ -162,6 +163,8 @@ package Snames is\n    Name_Relaxed_Initialization         : constant Name_Id := N + $;\n    Name_Stable_Properties              : constant Name_Id := N + $;\n    Name_Static_Predicate               : constant Name_Id := N + $;\n+   Name_Storage_Model                  : constant Name_Id := N + $;\n+   Name_Storage_Model_Type             : constant Name_Id := N + $;\n    Name_String_Literal                 : constant Name_Id := N + $;\n    Name_Synchronization                : constant Name_Id := N + $;\n    Name_Unimplemented                  : constant Name_Id := N + $;\n@@ -779,6 +782,7 @@ package Snames is\n \n    --  Other special names used in processing attributes, aspects, and pragmas\n \n+   Name_Address_Type                   : constant Name_Id := N + $;\n    Name_Aggregate                      : constant Name_Id := N + $;\n    Name_Allow                          : constant Name_Id := N + $;\n    Name_Amount                         : constant Name_Id := N + $;\n@@ -798,6 +802,8 @@ package Snames is\n    Name_Component                      : constant Name_Id := N + $;\n    Name_Component_Size_4               : constant Name_Id := N + $;\n    Name_Copy                           : constant Name_Id := N + $;\n+   Name_Copy_From                      : constant Name_Id := N + $;\n+   Name_Copy_To                        : constant Name_Id := N + $;\n    Name_D_Float                        : constant Name_Id := N + $;\n    Name_Decreases                      : constant Name_Id := N + $;\n    Name_Disable                        : constant Name_Id := N + $;\n@@ -867,6 +873,7 @@ package Snames is\n    Name_Nominal                        : constant Name_Id := N + $;\n    Name_Non_Volatile                   : constant Name_Id := N + $;\n    Name_None                           : constant Name_Id := N + $;\n+   Name_Null_Address                   : constant Name_Id := N + $;\n    Name_On                             : constant Name_Id := N + $;\n    Name_Optional                       : constant Name_Id := N + $;\n    Name_Policy                         : constant Name_Id := N + $;"}]}