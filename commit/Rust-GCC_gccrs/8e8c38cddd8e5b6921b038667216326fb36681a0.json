{"sha": "8e8c38cddd8e5b6921b038667216326fb36681a0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGU4YzM4Y2RkZDhlNWI2OTIxYjAzODY2NzIxNjMyNmZiMzY2ODFhMA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-04-30T23:13:36Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-04-30T23:13:36Z"}, "message": "toplev.c (rest_of_compilation): Don't run cross-jump before bb-reorder.\n\n        * toplev.c (rest_of_compilation): Don't run cross-jump before\n        bb-reorder.\n\t* gcc.dg/20020430-1.c: New.\n\nFrom-SVN: r52981", "tree": {"sha": "06b41285ab3799d97d618f8eb3b40713043d6e83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06b41285ab3799d97d618f8eb3b40713043d6e83"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e8c38cddd8e5b6921b038667216326fb36681a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e8c38cddd8e5b6921b038667216326fb36681a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e8c38cddd8e5b6921b038667216326fb36681a0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e8c38cddd8e5b6921b038667216326fb36681a0/comments", "author": null, "committer": null, "parents": [{"sha": "a125b7bc58ceec58eaca9b6b4eae0b36c98edac8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a125b7bc58ceec58eaca9b6b4eae0b36c98edac8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a125b7bc58ceec58eaca9b6b4eae0b36c98edac8"}], "stats": {"total": 206, "additions": 201, "deletions": 5}, "files": [{"sha": "2ae8455945587888396120ca20ab0924423cb1c1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e8c38cddd8e5b6921b038667216326fb36681a0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e8c38cddd8e5b6921b038667216326fb36681a0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8e8c38cddd8e5b6921b038667216326fb36681a0", "patch": "@@ -1,3 +1,9 @@\n+2002-04-30  Richard Henderson  <rth@redhat.com>\n+\n+\tPR opt/6516\n+\t* toplev.c (rest_of_compilation): Don't run cross-jump before\n+\tbb-reorder.\n+\n 2002-04-30  Tom Rix  <trix@redhat.com>\n \n \t* regrename.c (build_def_use, copyprop_hardreg_forward_1): Sanity "}, {"sha": "981c4f36dabd01393f4025fdd2b6631d15495647", "filename": "gcc/testsuite/gcc.dg/20020430-1.c", "status": "added", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e8c38cddd8e5b6921b038667216326fb36681a0/gcc%2Ftestsuite%2Fgcc.dg%2F20020430-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e8c38cddd8e5b6921b038667216326fb36681a0/gcc%2Ftestsuite%2Fgcc.dg%2F20020430-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2F20020430-1.c?ref=8e8c38cddd8e5b6921b038667216326fb36681a0", "patch": "@@ -0,0 +1,190 @@\n+/* PR opt/6516 */\n+/* On x86, something about the structure of this function prevented\n+   cross-jumping from combining the three arms of the switch statement\n+   until the last moment.  After which we did not delete dead code, \n+   which left a reference to the deleted ADDR_VEC.  */\n+\n+/* { dg-do compile }\n+/* { do-options \"-O2 -frename-registers -fpic\" } */\n+\n+typedef unsigned long XID;\n+typedef XID Window;\n+typedef void Display;\n+typedef unsigned long Time;\n+\n+typedef struct {\n+        int type;\n+        unsigned long serial;\n+        int send_event;\n+        Display *display;\n+        Window window;\n+        Window root;\n+        Window subwindow;\n+        Time time;\n+        int x, y;\n+        int x_root, y_root;\n+        unsigned int state;\n+        unsigned int button;\n+        int same_screen;\n+} XButtonEvent;\n+typedef struct {\n+        int type;\n+        unsigned long serial;\n+        int send_event;\n+        Display *display;\n+        Window window;\n+        Window root;\n+        Window subwindow;\n+        Time time;\n+        int x, y;\n+        int x_root, y_root;\n+        unsigned int state;\n+        char is_hint;\n+        int same_screen;\n+} XMotionEvent;\n+typedef struct {\n+        int type;\n+        unsigned long serial;\n+        int send_event;\n+        Display *display;\n+        Window window;\n+        Window root;\n+        Window subwindow;\n+        Time time;\n+        int x, y;\n+        int x_root, y_root;\n+        int mode;\n+        int detail;\n+        int same_screen;\n+        int focus;\n+        unsigned int state;\n+} XCrossingEvent;\n+typedef union _XEvent {\n+        int type;\n+        XButtonEvent xbutton;\n+        XMotionEvent xmotion;\n+        XCrossingEvent xcrossing;\n+} XEvent;\n+\n+typedef struct {\n+        int width, height;\n+        Display *display;\n+} Screen;\n+typedef struct _CorePart {\n+    Screen *screen;\n+} CorePart;\n+typedef struct _WidgetRec {\n+    CorePart core;\n+} WidgetRec;\n+typedef struct _WidgetRec *Widget;\n+\n+typedef struct _SmeRec *SmeObject;\n+typedef struct _SimpleMenuPart {\n+    SmeObject entry_set;\n+} SimpleMenuPart;\n+typedef struct _SimpleMenuRec {\n+    SimpleMenuPart simple_menu;\n+} SimpleMenuRec;\n+typedef struct _SimpleMenuRec* SimpleMenuWidget;\n+\n+typedef short Position;\n+typedef unsigned short Dimension;\n+typedef char Boolean;\n+\n+typedef struct _RectObjPart {\n+    Position x, y;\n+    Dimension width, height;\n+    Dimension border_width;\n+    Boolean managed;\n+    Boolean sensitive;\n+    Boolean ancestor_sensitive;\n+}RectObjPart;\n+typedef struct _RectObjRec {\n+    RectObjPart rectangle;\n+} RectObjRec;\n+typedef struct _RectObjRec *RectObj;\n+\n+SmeObject DoGetEventEntry();\n+\n+SmeObject\n+GetEventEntry(Widget w, XEvent *event)\n+{\n+    int x_loc, y_loc, x_root;\n+    SimpleMenuWidget smw = (SimpleMenuWidget)w;\n+    SmeObject entry;\n+    int warp, move;\n+    switch (event->type) {\n+        case 6:\n+            x_loc = event->xmotion.x;\n+            y_loc = event->xmotion.y;\n+            x_root = event->xmotion.x_root;\n+            break;\n+        case 7:\n+        case 8:\n+            x_loc = event->xcrossing.x;\n+            y_loc = event->xcrossing.y;\n+            x_root = event->xcrossing.x_root;\n+            break;\n+        case 4:\n+        case 5:\n+            x_loc = event->xbutton.x;\n+            y_loc = event->xbutton.y;\n+            x_root = event->xbutton.x_root;\n+            break;\n+        default:\n+            XtAppError(XtWidgetToApplicationContext(w),\n+                       \"Unknown event type in GetEventEntry().\");\n+            return (((void *)0));\n+    }\n+    if (x_loc < 0 || x_loc >= (((RectObj)smw)->rectangle.width) ||\n+        y_loc < 0 || y_loc >= (((RectObj)smw)->rectangle.height))\n+        return (((void *)0));\n+    if (x_root == ((((w)->core.screen))->width) - 1 &&\n+        (((RectObj)w)->rectangle.x) + (((RectObj)w)->rectangle.width) + ((((RectObj)w)->rectangle.border_width)) > x_root) {\n+        warp = -8;\n+        if (smw->simple_menu.entry_set) {\n+            entry = DoGetEventEntry(w,\n+                                    (((RectObj)smw->simple_menu.entry_set)->rectangle.x)\n+                                    + (((RectObj)smw->simple_menu.entry_set)->rectangle.width) + 1,\n+                                    y_loc);\n+            Unhighlight(w, event, ((void *)0), ((void *)0));\n+            if (entry) {\n+                warp = -(int)(((RectObj)entry)->rectangle.width) >> 1;\n+                move = x_loc - (((RectObj)entry)->rectangle.width) - (((RectObj)entry)->rectangle.x) + (((RectObj)w)->rectangle.border_width);\n+            }\n+            else {\n+                warp = 0;\n+                move = ((((w)->core.screen))->width) -\n+                       ((((RectObj)w)->rectangle.x) + (((RectObj)w)->rectangle.width) + ((((RectObj)w)->rectangle.border_width) << 1));\n+            }\n+        }\n+        else {\n+            warp = 0;\n+            move = ((((w)->core.screen))->width) -\n+                   ((((RectObj)w)->rectangle.x) + (((RectObj)w)->rectangle.width) + ((((RectObj)w)->rectangle.border_width) << 1));\n+        }\n+    }\n+    else if (x_root == 0 && (((RectObj)w)->rectangle.x) < 0) {\n+        warp = 8;\n+        if (smw->simple_menu.entry_set) {\n+            entry = DoGetEventEntry(w, (((RectObj)smw->simple_menu.entry_set)->rectangle.x) - 1,\n+                                    y_loc);\n+            Unhighlight(w, event, ((void *)0), ((void *)0));\n+            if (entry) {\n+                warp = (((RectObj)entry)->rectangle.width) >> 1;\n+                move = x_loc - (((RectObj)entry)->rectangle.x);\n+            }\n+            else\n+                move = x_loc + (((RectObj)w)->rectangle.border_width);\n+        }\n+        else\n+            move = x_loc + (((RectObj)w)->rectangle.border_width);\n+    }\n+    else\n+        move = warp = 0;\n+    if (move)\n+        XtMoveWidget(w, (((RectObj)w)->rectangle.x) + move, (((RectObj)w)->rectangle.y));\n+    if (warp)\n+        XWarpPointer((((w)->core.screen)->display), 0L, 0L, 0, 0, 0, 0, warp, 0);\n+    return (DoGetEventEntry(w, x_loc, y_loc));\n+}"}, {"sha": "580384f184c95f2ce86eae0840181f790fb567b2", "filename": "gcc/toplev.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e8c38cddd8e5b6921b038667216326fb36681a0/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e8c38cddd8e5b6921b038667216326fb36681a0/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=8e8c38cddd8e5b6921b038667216326fb36681a0", "patch": "@@ -3309,11 +3309,11 @@ rest_of_compilation (decl)\n       timevar_push (TV_REORDER_BLOCKS);\n       open_dump_file (DFI_bbro, decl);\n \n-      /* Last attempt to optimize CFG, as scheduling, peepholing\n-\t and insn splitting possibly introduced more crossjumping\n-\t oppurtuntities.  */\n-      cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_POST_REGSTACK\n-\t\t   | (flag_crossjumping ? CLEANUP_CROSSJUMP : 0));\n+      /* Last attempt to optimize CFG, as scheduling, peepholing and insn\n+\t splitting possibly introduced more crossjumping oppurtuntities.\n+\t Except that we can't actually run crossjumping without running \n+\t another DCE pass, which we can't do after reg-stack.  */\n+      cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_POST_REGSTACK);\n       if (flag_reorder_blocks)\n \t{\n \t  reorder_basic_blocks ();"}]}