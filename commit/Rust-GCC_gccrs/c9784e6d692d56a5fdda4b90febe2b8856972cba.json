{"sha": "c9784e6d692d56a5fdda4b90febe2b8856972cba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzk3ODRlNmQ2OTJkNTZhNWZkZGE0YjkwZmViZTJiODg1Njk3MmNiYQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-05-28T21:09:17Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-05-28T21:09:17Z"}, "message": "Makefile.in (OBJS-common): Add tree-cfgcleanup.o.\n\n\t* Makefile.in (OBJS-common): Add tree-cfgcleanup.o.\n\t* tree-flow.h: Add prototypes for start_recording_case_labels\n\tand end_recording_case_labels.\n\t* tree-cfg.c (start_recording_case_labels,\n\tend_recording_case_labels): Export.\n\t(cleanup_tree_cfg_loop, modified_noreturn_calls,\n\tcleanup_control_flow, cleanup_control_expr_graph,\n\tremove_fallthru_edge, phi_alternatives_equal,\n\ttree_forwarder_block_p, has_abnormal_incoming_edge_p,\n\tremove_forwarder_block, cleanup_forwarder_blocks,\n\tremove_forwarder_block_with_phi, merge_phi_nodes,\n\tgate_merge_phi, pass_merge_phi): Move to ...\n\t* tree-cfgcleanup.c: ... here.\n\nFrom-SVN: r100302", "tree": {"sha": "732933d9d157635f6bac7b830e1cead8d3bfa912", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/732933d9d157635f6bac7b830e1cead8d3bfa912"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c9784e6d692d56a5fdda4b90febe2b8856972cba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9784e6d692d56a5fdda4b90febe2b8856972cba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9784e6d692d56a5fdda4b90febe2b8856972cba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9784e6d692d56a5fdda4b90febe2b8856972cba/comments", "author": null, "committer": null, "parents": [{"sha": "795479950392d25da04300337b3c6c9eabd77941", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/795479950392d25da04300337b3c6c9eabd77941", "html_url": "https://github.com/Rust-GCC/gccrs/commit/795479950392d25da04300337b3c6c9eabd77941"}], "stats": {"total": 1507, "additions": 786, "deletions": 721}, "files": [{"sha": "aead37108bbaf93a13b478fb5ab6f8b42682faff", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9784e6d692d56a5fdda4b90febe2b8856972cba/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9784e6d692d56a5fdda4b90febe2b8856972cba/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c9784e6d692d56a5fdda4b90febe2b8856972cba", "patch": "@@ -1,7 +1,21 @@\n 2005-05-28  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* tree-ssa-ccp.c (ccp_fold): Remove code that produces\n-\tnon-gimple min minvariant.\n+\tnon-gimple min invariant.\n+\n+\t* Makefile.in (OBJS-common): Add tree-cfgcleanup.o.\n+\t* tree-flow.h: Add prototypes for start_recording_case_labels\n+\tand end_recording_case_labels.\n+\t* tree-cfg.c (start_recording_case_labels,\n+\tend_recording_case_labels): Export.\n+\t(cleanup_tree_cfg_loop, modified_noreturn_calls,\n+\tcleanup_control_flow, cleanup_control_expr_graph,\n+\tremove_fallthru_edge, phi_alternatives_equal,\n+\ttree_forwarder_block_p, has_abnormal_incoming_edge_p,\n+\tremove_forwarder_block, cleanup_forwarder_blocks,\n+\tremove_forwarder_block_with_phi, merge_phi_nodes,\n+\tgate_merge_phi, pass_merge_phi): Move to ...\n+\t* tree-cfgcleanup.c: ... here.\n \n 2005-05-28  Jan Hubicka  <jh@suse.cz>\n "}, {"sha": "27943057afa1c756e4264825b0a2e824349ad826", "filename": "gcc/Makefile.in", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9784e6d692d56a5fdda4b90febe2b8856972cba/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9784e6d692d56a5fdda4b90febe2b8856972cba/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=c9784e6d692d56a5fdda4b90febe2b8856972cba", "patch": "@@ -961,7 +961,7 @@ OBJS-common = \\\n  et-forest.o cfghooks.o bt-load.o pretty-print.o $(GGC) web.o passes.o\t   \\\n  rtl-profile.o tree-profile.o rtlhooks.o cfgexpand.o lambda-mat.o          \\\n  lambda-trans.o lambda-code.o tree-loop-linear.o tree-ssa-sink.o           \\\n- tree-vrp.o tree-stdarg.o\n+ tree-vrp.o tree-stdarg.o tree-cfgcleanup.o\n \n OBJS-md = $(out_object_file)\n OBJS-archive = $(EXTRA_OBJS) $(host_hook_obj) tree-inline.o\t\t   \\\n@@ -1750,6 +1750,12 @@ tree-cfg.o : tree-cfg.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(TREE_DUMP_H) except.h langhooks.h $(CFGLOOP_H) tree-pass.h \\\n    $(CFGLAYOUT_H) $(BASIC_BLOCK_H) hard-reg-set.h $(HASHTAB_H) toplev.h \\\n    tree-ssa-propagate.h\n+tree-cfgcleanup.o : tree-cfg.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n+   $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) $(FLAGS_H) output.h \\\n+   $(DIAGNOSTIC_H) errors.h function.h $(TIMEVAR_H) $(TM_H) coretypes.h \\\n+   $(TREE_DUMP_H) except.h langhooks.h $(CFGLOOP_H) tree-pass.h \\\n+   $(CFGLAYOUT_H) $(BASIC_BLOCK_H) hard-reg-set.h $(HASHTAB_H) toplev.h \\\n+   tree-ssa-propagate.h\n tree-tailcall.o : tree-tailcall.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) function.h $(TM_H) coretypes.h \\\n    $(TREE_DUMP_H) $(DIAGNOSTIC_H) except.h tree-pass.h $(FLAGS_H) langhooks.h \\"}, {"sha": "970b6b34d34b66d9238880e231ebe1f2ac36f450", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 2, "deletions": 717, "changes": 719, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9784e6d692d56a5fdda4b90febe2b8856972cba/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9784e6d692d56a5fdda4b90febe2b8856972cba/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=c9784e6d692d56a5fdda4b90febe2b8856972cba", "patch": "@@ -108,27 +108,21 @@ static void make_goto_expr_edges (basic_block);\n static edge tree_redirect_edge_and_branch (edge, basic_block);\n static edge tree_try_redirect_by_replacing_jump (edge, basic_block);\n static void split_critical_edges (void);\n-static bool remove_fallthru_edge (VEC(edge,gc) *);\n \n /* Various helpers.  */\n static inline bool stmt_starts_bb_p (tree, tree);\n static int tree_verify_flow_info (void);\n static void tree_make_forwarder_block (edge);\n-static bool tree_forwarder_block_p (basic_block, bool);\n static void tree_cfg2vcg (FILE *);\n \n /* Flowgraph optimization and cleanup.  */\n static void tree_merge_blocks (basic_block, basic_block);\n static bool tree_can_merge_blocks_p (basic_block, basic_block);\n static void remove_bb (basic_block);\n-static bool cleanup_control_flow (void);\n-static bool cleanup_control_expr_graph (basic_block, block_stmt_iterator);\n static edge find_taken_edge_computed_goto (basic_block, tree);\n static edge find_taken_edge_cond_expr (basic_block, tree);\n static edge find_taken_edge_switch_expr (basic_block, tree);\n static tree find_case_label_for_value (tree, tree);\n-static bool phi_alternatives_equal (basic_block, edge, edge);\n-static bool cleanup_forwarder_blocks (void);\n \n void\n init_empty_tree_cfg (void)\n@@ -645,7 +639,7 @@ edge_to_cases_cleanup (void *p)\n \n /* Start recording information mapping edges to case labels.  */\n \n-static void\n+void\n start_recording_case_labels (void)\n {\n   gcc_assert (edge_to_cases == NULL);\n@@ -666,7 +660,7 @@ recording_case_labels_p (void)\n \n /* Stop recording information mapping edges to case labels and\n    remove any information we have recorded.  */\n-static void\n+void\n end_recording_case_labels (void)\n {\n   htab_delete (edge_to_cases);\n@@ -881,73 +875,6 @@ make_goto_expr_edges (basic_block bb)\n \t\t\t       Flowgraph analysis\n ---------------------------------------------------------------------------*/\n \n-/* Remove unreachable blocks and other miscellaneous clean up work.  */\n-\n-bool\n-cleanup_tree_cfg (void)\n-{\n-  bool retval = false;\n-\n-  timevar_push (TV_TREE_CLEANUP_CFG);\n-\n-  retval = cleanup_control_flow ();\n-  retval |= delete_unreachable_blocks ();\n-\n-  /* cleanup_forwarder_blocks can redirect edges out of SWITCH_EXPRs,\n-     which can get expensive.  So we want to enable recording of edge\n-     to CASE_LABEL_EXPR mappings around the call to\n-     cleanup_forwarder_blocks.  */\n-  start_recording_case_labels ();\n-  retval |= cleanup_forwarder_blocks ();\n-  end_recording_case_labels ();\n-\n-#ifdef ENABLE_CHECKING\n-  if (retval)\n-    {\n-      gcc_assert (!cleanup_control_flow ());\n-      gcc_assert (!delete_unreachable_blocks ());\n-      gcc_assert (!cleanup_forwarder_blocks ());\n-    }\n-#endif\n-\n-  /* Merging the blocks creates no new opportunities for the other\n-     optimizations, so do it here.  */\n-  retval |= merge_seq_blocks ();\n-\n-  compact_blocks ();\n-\n-#ifdef ENABLE_CHECKING\n-  verify_flow_info ();\n-#endif\n-  timevar_pop (TV_TREE_CLEANUP_CFG);\n-  return retval;\n-}\n-\n-\n-/* Cleanup cfg and repair loop structures.  */\n-\n-void\n-cleanup_tree_cfg_loop (void)\n-{\n-  bitmap changed_bbs = BITMAP_ALLOC (NULL);\n-\n-  cleanup_tree_cfg ();\n-\n-  fix_loop_structure (current_loops, changed_bbs);\n-  calculate_dominance_info (CDI_DOMINATORS);\n-\n-  /* This usually does nothing.  But sometimes parts of cfg that originally\n-     were inside a loop get out of it due to edge removal (since they\n-     become unreachable by back edges from latch).  */\n-  rewrite_into_loop_closed_ssa (changed_bbs, TODO_update_ssa);\n-\n-  BITMAP_FREE (changed_bbs);\n-\n-#ifdef ENABLE_CHECKING\n-  verify_loop_structure (current_loops);\n-#endif\n-}\n-\n /* Cleanup useless labels in basic blocks.  This is something we wish\n    to do early because it allows us to group case labels before creating\n    the edges for the CFG, and it speeds up block statement iterators in\n@@ -2081,182 +2008,6 @@ remove_bb (basic_block bb)\n   remove_phi_nodes_and_edges_for_unreachable_block (bb);\n }\n \n-/* A list of all the noreturn calls passed to modify_stmt.\n-   cleanup_control_flow uses it to detect cases where a mid-block\n-   indirect call has been turned into a noreturn call.  When this\n-   happens, all the instructions after the call are no longer\n-   reachable and must be deleted as dead.  */\n-\n-VEC(tree,gc) *modified_noreturn_calls;\n-\n-/* Try to remove superfluous control structures.  */\n-\n-static bool\n-cleanup_control_flow (void)\n-{\n-  basic_block bb;\n-  block_stmt_iterator bsi;\n-  bool retval = false;\n-  tree stmt;\n-\n-  /* Detect cases where a mid-block call is now known not to return.  */\n-  while (VEC_length (tree, modified_noreturn_calls))\n-    {\n-      stmt = VEC_pop (tree, modified_noreturn_calls);\n-      bb = bb_for_stmt (stmt);\n-      if (bb != NULL && last_stmt (bb) != stmt && noreturn_call_p (stmt))\n-\tsplit_block (bb, stmt);\n-    }\n-\n-  FOR_EACH_BB (bb)\n-    {\n-      bsi = bsi_last (bb);\n-\n-      if (bsi_end_p (bsi))\n-\tcontinue;\n-      \n-      stmt = bsi_stmt (bsi);\n-      if (TREE_CODE (stmt) == COND_EXPR\n-\t  || TREE_CODE (stmt) == SWITCH_EXPR)\n-\tretval |= cleanup_control_expr_graph (bb, bsi);\n-\n-      /* If we had a computed goto which has a compile-time determinable\n-\t destination, then we can eliminate the goto.  */\n-      if (TREE_CODE (stmt) == GOTO_EXPR\n-\t  && TREE_CODE (GOTO_DESTINATION (stmt)) == ADDR_EXPR\n-\t  && TREE_CODE (TREE_OPERAND (GOTO_DESTINATION (stmt), 0)) == LABEL_DECL)\n-\t{\n-\t  edge e;\n-\t  tree label;\n-\t  edge_iterator ei;\n-\t  basic_block target_block;\n-\t  bool removed_edge = false;\n-\n-\t  /* First look at all the outgoing edges.  Delete any outgoing\n-\t     edges which do not go to the right block.  For the one\n-\t     edge which goes to the right block, fix up its flags.  */\n-\t  label = TREE_OPERAND (GOTO_DESTINATION (stmt), 0);\n-\t  target_block = label_to_block (label);\n-\t  for (ei = ei_start (bb->succs); (e = ei_safe_edge (ei)); )\n-\t    {\n-\t      if (e->dest != target_block)\n-\t\t{\n-\t\t  removed_edge = true;\n-\t\t  remove_edge (e);\n-\t\t}\n-\t      else\n-\t        {\n-\t\t  /* Turn off the EDGE_ABNORMAL flag.  */\n-\t\t  e->flags &= ~EDGE_ABNORMAL;\n-\n-\t\t  /* And set EDGE_FALLTHRU.  */\n-\t\t  e->flags |= EDGE_FALLTHRU;\n-\t\t  ei_next (&ei);\n-\t\t}\n-\t    }\n-\n-\t  /* If we removed one or more edges, then we will need to fix the\n-\t     dominators.  It may be possible to incrementally update them.  */\n-\t  if (removed_edge)\n-\t    free_dominance_info (CDI_DOMINATORS);\n-\n-\t  /* Remove the GOTO_EXPR as it is not needed.  The CFG has all the\n-\t     relevant information we need.  */\n-\t  bsi_remove (&bsi);\n-\t  retval = true;\n-\t}\n-\n-      /* Check for indirect calls that have been turned into\n-\t noreturn calls.  */\n-      if (noreturn_call_p (stmt) && remove_fallthru_edge (bb->succs))\n-\t{\n-\t  free_dominance_info (CDI_DOMINATORS);\n-\t  retval = true;\n-\t}\n-    }\n-  return retval;\n-}\n-\n-\n-/* Disconnect an unreachable block in the control expression starting\n-   at block BB.  */\n-\n-static bool\n-cleanup_control_expr_graph (basic_block bb, block_stmt_iterator bsi)\n-{\n-  edge taken_edge;\n-  bool retval = false;\n-  tree expr = bsi_stmt (bsi), val;\n-\n-  if (!single_succ_p (bb))\n-    {\n-      edge e;\n-      edge_iterator ei;\n-\n-      switch (TREE_CODE (expr))\n-\t{\n-\tcase COND_EXPR:\n-\t  val = COND_EXPR_COND (expr);\n-\t  break;\n-\n-\tcase SWITCH_EXPR:\n-\t  val = SWITCH_COND (expr);\n-\t  if (TREE_CODE (val) != INTEGER_CST)\n-\t    return false;\n-\t  break;\n-\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-\n-      taken_edge = find_taken_edge (bb, val);\n-      if (!taken_edge)\n-\treturn false;\n-\n-      /* Remove all the edges except the one that is always executed.  */\n-      for (ei = ei_start (bb->succs); (e = ei_safe_edge (ei)); )\n-\t{\n-\t  if (e != taken_edge)\n-\t    {\n-\t      taken_edge->probability += e->probability;\n-\t      taken_edge->count += e->count;\n-\t      remove_edge (e);\n-\t      retval = true;\n-\t    }\n-\t  else\n-\t    ei_next (&ei);\n-\t}\n-      if (taken_edge->probability > REG_BR_PROB_BASE)\n-\ttaken_edge->probability = REG_BR_PROB_BASE;\n-    }\n-  else\n-    taken_edge = single_succ_edge (bb);\n-\n-  bsi_remove (&bsi);\n-  taken_edge->flags = EDGE_FALLTHRU;\n-\n-  /* We removed some paths from the cfg.  */\n-  free_dominance_info (CDI_DOMINATORS);\n-\n-  return retval;\n-}\n-\n-/* Remove any fallthru edge from EV.  Return true if an edge was removed.  */\n-\n-static bool\n-remove_fallthru_edge (VEC(edge,gc) *ev)\n-{\n-  edge_iterator ei;\n-  edge e;\n-\n-  FOR_EACH_EDGE (e, ei, ev)\n-    if ((e->flags & EDGE_FALLTHRU) != 0)\n-      {\n-\tremove_edge (e);\n-\treturn true;\n-      }\n-  return false;\n-}\n \n /* Given a basic block BB ending with COND_EXPR or SWITCH_EXPR, and a\n    predicate VAL, return the edge that will be taken out of the block.\n@@ -2387,31 +2138,6 @@ find_case_label_for_value (tree switch_expr, tree val)\n }\n \n \n-/* If all the PHI nodes in DEST have alternatives for E1 and E2 and\n-   those alternatives are equal in each of the PHI nodes, then return\n-   true, else return false.  */\n-\n-static bool\n-phi_alternatives_equal (basic_block dest, edge e1, edge e2)\n-{\n-  int n1 = e1->dest_idx;\n-  int n2 = e2->dest_idx;\n-  tree phi;\n-\n-  for (phi = phi_nodes (dest); phi; phi = PHI_CHAIN (phi))\n-    {\n-      tree val1 = PHI_ARG_DEF (phi, n1);\n-      tree val2 = PHI_ARG_DEF (phi, n2);\n-\n-      gcc_assert (val1 != NULL_TREE);\n-      gcc_assert (val2 != NULL_TREE);\n-\n-      if (!operand_equal_for_phi_arg_p (val1, val2))\n-\treturn false;\n-    }\n-\n-  return true;\n-}\n \n \n /*---------------------------------------------------------------------------\n@@ -4096,447 +3822,6 @@ tree_make_forwarder_block (edge fallthru)\n }\n \n \n-/* Return true if basic block BB does nothing except pass control\n-   flow to another block and that we can safely insert a label at\n-   the start of the successor block.\n-\n-   As a precondition, we require that BB be not equal to\n-   ENTRY_BLOCK_PTR.  */\n-\n-static bool\n-tree_forwarder_block_p (basic_block bb, bool phi_wanted)\n-{\n-  block_stmt_iterator bsi;\n-\n-  /* BB must have a single outgoing edge.  */\n-  if (single_succ_p (bb) != 1\n-      /* If PHI_WANTED is false, BB must not have any PHI nodes.\n-\t Otherwise, BB must have PHI nodes.  */\n-      || (phi_nodes (bb) != NULL_TREE) != phi_wanted\n-      /* BB may not be a predecessor of EXIT_BLOCK_PTR.  */\n-      || single_succ (bb) == EXIT_BLOCK_PTR\n-      /* Nor should this be an infinite loop.  */\n-      || single_succ (bb) == bb\n-      /* BB may not have an abnormal outgoing edge.  */\n-      || (single_succ_edge (bb)->flags & EDGE_ABNORMAL))\n-    return false; \n-\n-#if ENABLE_CHECKING\n-  gcc_assert (bb != ENTRY_BLOCK_PTR);\n-#endif\n-\n-  /* Now walk through the statements backward.  We can ignore labels,\n-     anything else means this is not a forwarder block.  */\n-  for (bsi = bsi_last (bb); !bsi_end_p (bsi); bsi_prev (&bsi))\n-    {\n-      tree stmt = bsi_stmt (bsi);\n- \n-      switch (TREE_CODE (stmt))\n-\t{\n-\tcase LABEL_EXPR:\n-\t  if (DECL_NONLOCAL (LABEL_EXPR_LABEL (stmt)))\n-\t    return false;\n-\t  break;\n-\n-\tdefault:\n-\t  return false;\n-\t}\n-    }\n-\n-  if (find_edge (ENTRY_BLOCK_PTR, bb))\n-    return false;\n-\n-  if (current_loops)\n-    { \n-      basic_block dest;\n-      /* Protect loop latches, headers and preheaders.  */\n-      if (bb->loop_father->header == bb)\n-\treturn false;\n-      dest = EDGE_SUCC (bb, 0)->dest;\n- \n-      if (dest->loop_father->header == dest)\n-\treturn false;\n-    }\n-\n-  return true;\n-}\n-\n-/* Return true if BB has at least one abnormal incoming edge.  */\n-\n-static inline bool\n-has_abnormal_incoming_edge_p (basic_block bb)\n-{\n-  edge e;\n-  edge_iterator ei;\n-\n-  FOR_EACH_EDGE (e, ei, bb->preds)\n-    if (e->flags & EDGE_ABNORMAL)\n-      return true;\n-\n-  return false;\n-}\n-\n-/* Removes forwarder block BB.  Returns false if this failed.  If a new\n-   forwarder block is created due to redirection of edges, it is\n-   stored to worklist.  */\n-\n-static bool\n-remove_forwarder_block (basic_block bb, basic_block **worklist)\n-{\n-  edge succ = single_succ_edge (bb), e, s;\n-  basic_block dest = succ->dest;\n-  tree label;\n-  tree phi;\n-  edge_iterator ei;\n-  block_stmt_iterator bsi, bsi_to;\n-  bool seen_abnormal_edge = false;\n-\n-  /* We check for infinite loops already in tree_forwarder_block_p.\n-     However it may happen that the infinite loop is created\n-     afterwards due to removal of forwarders.  */\n-  if (dest == bb)\n-    return false;\n-\n-  /* If the destination block consists of a nonlocal label, do not merge\n-     it.  */\n-  label = first_stmt (dest);\n-  if (label\n-      && TREE_CODE (label) == LABEL_EXPR\n-      && DECL_NONLOCAL (LABEL_EXPR_LABEL (label)))\n-    return false;\n-\n-  /* If there is an abnormal edge to basic block BB, but not into\n-     dest, problems might occur during removal of the phi node at out\n-     of ssa due to overlapping live ranges of registers.\n-\n-     If there is an abnormal edge in DEST, the problems would occur\n-     anyway since cleanup_dead_labels would then merge the labels for\n-     two different eh regions, and rest of exception handling code\n-     does not like it.\n-     \n-     So if there is an abnormal edge to BB, proceed only if there is\n-     no abnormal edge to DEST and there are no phi nodes in DEST.  */\n-  if (has_abnormal_incoming_edge_p (bb))\n-    {\n-      seen_abnormal_edge = true;\n-\n-      if (has_abnormal_incoming_edge_p (dest)\n-\t  || phi_nodes (dest) != NULL_TREE)\n-\treturn false;\n-    }\n-\n-  /* If there are phi nodes in DEST, and some of the blocks that are\n-     predecessors of BB are also predecessors of DEST, check that the\n-     phi node arguments match.  */\n-  if (phi_nodes (dest))\n-    {\n-      FOR_EACH_EDGE (e, ei, bb->preds)\n-\t{\n-\t  s = find_edge (e->src, dest);\n-\t  if (!s)\n-\t    continue;\n-\n-\t  if (!phi_alternatives_equal (dest, succ, s))\n-\t    return false;\n-\t}\n-    }\n-\n-  /* Redirect the edges.  */\n-  for (ei = ei_start (bb->preds); (e = ei_safe_edge (ei)); )\n-    {\n-      if (e->flags & EDGE_ABNORMAL)\n-\t{\n-\t  /* If there is an abnormal edge, redirect it anyway, and\n-\t     move the labels to the new block to make it legal.  */\n-\t  s = redirect_edge_succ_nodup (e, dest);\n-\t}\n-      else\n-\ts = redirect_edge_and_branch (e, dest);\n-\n-      if (s == e)\n-\t{\n-\t  /* Create arguments for the phi nodes, since the edge was not\n-\t     here before.  */\n-\t  for (phi = phi_nodes (dest); phi; phi = PHI_CHAIN (phi))\n-\t    add_phi_arg (phi, PHI_ARG_DEF (phi, succ->dest_idx), s);\n-\t}\n-      else\n-\t{\n-\t  /* The source basic block might become a forwarder.  We know\n-\t     that it was not a forwarder before, since it used to have\n-\t     at least two outgoing edges, so we may just add it to\n-\t     worklist.  */\n-\t  if (tree_forwarder_block_p (s->src, false))\n-\t    *(*worklist)++ = s->src;\n-\t}\n-    }\n-\n-  if (seen_abnormal_edge)\n-    {\n-      /* Move the labels to the new block, so that the redirection of\n-\t the abnormal edges works.  */\n-\n-      bsi_to = bsi_start (dest);\n-      for (bsi = bsi_start (bb); !bsi_end_p (bsi); )\n-\t{\n-\t  label = bsi_stmt (bsi);\n-\t  gcc_assert (TREE_CODE (label) == LABEL_EXPR);\n-\t  bsi_remove (&bsi);\n-\t  bsi_insert_before (&bsi_to, label, BSI_CONTINUE_LINKING);\n-\t}\n-    }\n-\n-  /* Update the dominators.  */\n-  if (dom_info_available_p (CDI_DOMINATORS))\n-    {\n-      basic_block dom, dombb, domdest;\n-\n-      dombb = get_immediate_dominator (CDI_DOMINATORS, bb);\n-      domdest = get_immediate_dominator (CDI_DOMINATORS, dest);\n-      if (domdest == bb)\n-\t{\n-\t  /* Shortcut to avoid calling (relatively expensive)\n-\t     nearest_common_dominator unless necessary.  */\n-\t  dom = dombb;\n-\t}\n-      else\n-\tdom = nearest_common_dominator (CDI_DOMINATORS, domdest, dombb);\n-\n-      set_immediate_dominator (CDI_DOMINATORS, dest, dom);\n-    }\n-\n-  /* And kill the forwarder block.  */\n-  delete_basic_block (bb);\n-\n-  return true;\n-}\n-\n-/* Removes forwarder blocks.  */\n-\n-static bool\n-cleanup_forwarder_blocks (void)\n-{\n-  basic_block bb;\n-  bool changed = false;\n-  basic_block *worklist = xmalloc (sizeof (basic_block) * n_basic_blocks);\n-  basic_block *current = worklist;\n-\n-  FOR_EACH_BB (bb)\n-    {\n-      if (tree_forwarder_block_p (bb, false))\n-\t*current++ = bb;\n-    }\n-\n-  while (current != worklist)\n-    {\n-      bb = *--current;\n-      changed |= remove_forwarder_block (bb, &current);\n-    }\n-\n-  free (worklist);\n-  return changed;\n-}\n-\n-/* Merge the PHI nodes at BB into those at BB's sole successor.  */\n-\n-static void\n-remove_forwarder_block_with_phi (basic_block bb)\n-{\n-  edge succ = single_succ_edge (bb);\n-  basic_block dest = succ->dest;\n-  tree label;\n-  basic_block dombb, domdest, dom;\n-\n-  /* We check for infinite loops already in tree_forwarder_block_p.\n-     However it may happen that the infinite loop is created\n-     afterwards due to removal of forwarders.  */\n-  if (dest == bb)\n-    return;\n-\n-  /* If the destination block consists of a nonlocal label, do not\n-     merge it.  */\n-  label = first_stmt (dest);\n-  if (label\n-      && TREE_CODE (label) == LABEL_EXPR\n-      && DECL_NONLOCAL (LABEL_EXPR_LABEL (label)))\n-    return;\n-\n-  /* Redirect each incoming edge to BB to DEST.  */\n-  while (EDGE_COUNT (bb->preds) > 0)\n-    {\n-      edge e = EDGE_PRED (bb, 0), s;\n-      tree phi;\n-\n-      s = find_edge (e->src, dest);\n-      if (s)\n-\t{\n-\t  /* We already have an edge S from E->src to DEST.  If S and\n-\t     E->dest's sole successor edge have the same PHI arguments\n-\t     at DEST, redirect S to DEST.  */\n-\t  if (phi_alternatives_equal (dest, s, succ))\n-\t    {\n-\t      e = redirect_edge_and_branch (e, dest);\n-\t      PENDING_STMT (e) = NULL_TREE;\n-\t      continue;\n-\t    }\n-\n-\t  /* PHI arguments are different.  Create a forwarder block by\n-\t     splitting E so that we can merge PHI arguments on E to\n-\t     DEST.  */\n-\t  e = single_succ_edge (split_edge (e));\n-\t}\n-\n-      s = redirect_edge_and_branch (e, dest);\n-\n-      /* redirect_edge_and_branch must not create a new edge.  */\n-      gcc_assert (s == e);\n-\n-      /* Add to the PHI nodes at DEST each PHI argument removed at the\n-\t destination of E.  */\n-      for (phi = phi_nodes (dest); phi; phi = PHI_CHAIN (phi))\n-\t{\n-\t  tree def = PHI_ARG_DEF (phi, succ->dest_idx);\n-\n-\t  if (TREE_CODE (def) == SSA_NAME)\n-\t    {\n-\t      tree var;\n-\n-\t      /* If DEF is one of the results of PHI nodes removed during\n-\t\t redirection, replace it with the PHI argument that used\n-\t\t to be on E.  */\n-\t      for (var = PENDING_STMT (e); var; var = TREE_CHAIN (var))\n-\t\t{\n-\t\t  tree old_arg = TREE_PURPOSE (var);\n-\t\t  tree new_arg = TREE_VALUE (var);\n-\n-\t\t  if (def == old_arg)\n-\t\t    {\n-\t\t      def = new_arg;\n-\t\t      break;\n-\t\t    }\n-\t\t}\n-\t    }\n-\n-\t  add_phi_arg (phi, def, s);\n-\t}\n-\n-      PENDING_STMT (e) = NULL;\n-    }\n-\n-  /* Update the dominators.  */\n-  dombb = get_immediate_dominator (CDI_DOMINATORS, bb);\n-  domdest = get_immediate_dominator (CDI_DOMINATORS, dest);\n-  if (domdest == bb)\n-    {\n-      /* Shortcut to avoid calling (relatively expensive)\n-\t nearest_common_dominator unless necessary.  */\n-      dom = dombb;\n-    }\n-  else\n-    dom = nearest_common_dominator (CDI_DOMINATORS, domdest, dombb);\n-\n-  set_immediate_dominator (CDI_DOMINATORS, dest, dom);\n-  \n-  /* Remove BB since all of BB's incoming edges have been redirected\n-     to DEST.  */\n-  delete_basic_block (bb);\n-}\n-\n-/* This pass merges PHI nodes if one feeds into another.  For example,\n-   suppose we have the following:\n-\n-  goto <bb 9> (<L9>);\n-\n-<L8>:;\n-  tem_17 = foo ();\n-\n-  # tem_6 = PHI <tem_17(8), tem_23(7)>;\n-<L9>:;\n-\n-  # tem_3 = PHI <tem_6(9), tem_2(5)>;\n-<L10>:;\n-\n-  Then we merge the first PHI node into the second one like so:\n-\n-  goto <bb 9> (<L10>);\n-\n-<L8>:;\n-  tem_17 = foo ();\n-\n-  # tem_3 = PHI <tem_23(7), tem_2(5), tem_17(8)>;\n-<L10>:;\n-*/\n-\n-static void\n-merge_phi_nodes (void)\n-{\n-  basic_block *worklist = xmalloc (sizeof (basic_block) * n_basic_blocks);\n-  basic_block *current = worklist;\n-  basic_block bb;\n-\n-  calculate_dominance_info (CDI_DOMINATORS);\n-\n-  /* Find all PHI nodes that we may be able to merge.  */\n-  FOR_EACH_BB (bb)\n-    {\n-      basic_block dest;\n-\n-      /* Look for a forwarder block with PHI nodes.  */\n-      if (!tree_forwarder_block_p (bb, true))\n-\tcontinue;\n-\n-      dest = single_succ (bb);\n-\n-      /* We have to feed into another basic block with PHI\n-\t nodes.  */\n-      if (!phi_nodes (dest)\n-\t  /* We don't want to deal with a basic block with\n-\t     abnormal edges.  */\n-\t  || has_abnormal_incoming_edge_p (bb))\n-\tcontinue;\n-\n-      if (!dominated_by_p (CDI_DOMINATORS, dest, bb))\n-\t{\n-\t  /* If BB does not dominate DEST, then the PHI nodes at\n-\t     DEST must be the only users of the results of the PHI\n-\t     nodes at BB.  */\n-\t  *current++ = bb;\n-\t}\n-    }\n-\n-  /* Now let's drain WORKLIST.  */\n-  while (current != worklist)\n-    {\n-      bb = *--current;\n-      remove_forwarder_block_with_phi (bb);\n-    }\n-\n-  free (worklist);\n-}\n-\n-static bool\n-gate_merge_phi (void)\n-{\n-  return 1;\n-}\n-\n-struct tree_opt_pass pass_merge_phi = {\n-  \"mergephi\",\t\t\t/* name */\n-  gate_merge_phi,\t\t/* gate */\n-  merge_phi_nodes,\t\t/* execute */\n-  NULL,\t\t\t\t/* sub */\n-  NULL,\t\t\t\t/* next */\n-  0,\t\t\t\t/* static_pass_number */\n-  TV_TREE_MERGE_PHI,\t\t/* tv_id */\n-  PROP_cfg | PROP_ssa,\t\t/* properties_required */\n-  0,\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t/* todo_flags_start */\n-  TODO_dump_func | TODO_ggc_collect\t/* todo_flags_finish */\n-  | TODO_verify_ssa,\n-  0\t\t\t\t/* letter */\n-};\n-\n /* Return a non-special label in the head of basic block BLOCK.\n    Create one if it doesn't exist.  */\n "}, {"sha": "f250f1fc05ebfce9adec169deec84a2ec9ca0775", "filename": "gcc/tree-cfgcleanup.c", "status": "added", "additions": 756, "deletions": 0, "changes": 756, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9784e6d692d56a5fdda4b90febe2b8856972cba/gcc%2Ftree-cfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9784e6d692d56a5fdda4b90febe2b8856972cba/gcc%2Ftree-cfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.c?ref=c9784e6d692d56a5fdda4b90febe2b8856972cba", "patch": "@@ -0,0 +1,756 @@\n+/* CFG cleanup for trees.\n+   Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"tm_p.h\"\n+#include \"hard-reg-set.h\"\n+#include \"basic-block.h\"\n+#include \"output.h\"\n+#include \"errors.h\"\n+#include \"flags.h\"\n+#include \"function.h\"\n+#include \"expr.h\"\n+#include \"ggc.h\"\n+#include \"langhooks.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-flow.h\"\n+#include \"timevar.h\"\n+#include \"tree-dump.h\"\n+#include \"tree-pass.h\"\n+#include \"toplev.h\"\n+#include \"except.h\"\n+#include \"cfgloop.h\"\n+#include \"cfglayout.h\"\n+#include \"hashtab.h\"\n+#include \"tree-ssa-propagate.h\"\n+\n+/* Remove any fallthru edge from EV.  Return true if an edge was removed.  */\n+\n+static bool\n+remove_fallthru_edge (VEC(edge,gc) *ev)\n+{\n+  edge_iterator ei;\n+  edge e;\n+\n+  FOR_EACH_EDGE (e, ei, ev)\n+    if ((e->flags & EDGE_FALLTHRU) != 0)\n+      {\n+\tremove_edge (e);\n+\treturn true;\n+      }\n+  return false;\n+}\n+\n+/* Disconnect an unreachable block in the control expression starting\n+   at block BB.  */\n+\n+static bool\n+cleanup_control_expr_graph (basic_block bb, block_stmt_iterator bsi)\n+{\n+  edge taken_edge;\n+  bool retval = false;\n+  tree expr = bsi_stmt (bsi), val;\n+\n+  if (!single_succ_p (bb))\n+    {\n+      edge e;\n+      edge_iterator ei;\n+\n+      switch (TREE_CODE (expr))\n+\t{\n+\tcase COND_EXPR:\n+\t  val = COND_EXPR_COND (expr);\n+\t  break;\n+\n+\tcase SWITCH_EXPR:\n+\t  val = SWITCH_COND (expr);\n+\t  if (TREE_CODE (val) != INTEGER_CST)\n+\t    return false;\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+\n+      taken_edge = find_taken_edge (bb, val);\n+      if (!taken_edge)\n+\treturn false;\n+\n+      /* Remove all the edges except the one that is always executed.  */\n+      for (ei = ei_start (bb->succs); (e = ei_safe_edge (ei)); )\n+\t{\n+\t  if (e != taken_edge)\n+\t    {\n+\t      taken_edge->probability += e->probability;\n+\t      taken_edge->count += e->count;\n+\t      remove_edge (e);\n+\t      retval = true;\n+\t    }\n+\t  else\n+\t    ei_next (&ei);\n+\t}\n+      if (taken_edge->probability > REG_BR_PROB_BASE)\n+\ttaken_edge->probability = REG_BR_PROB_BASE;\n+    }\n+  else\n+    taken_edge = single_succ_edge (bb);\n+\n+  bsi_remove (&bsi);\n+  taken_edge->flags = EDGE_FALLTHRU;\n+\n+  /* We removed some paths from the cfg.  */\n+  free_dominance_info (CDI_DOMINATORS);\n+\n+  return retval;\n+}\n+\n+/* A list of all the noreturn calls passed to modify_stmt.\n+   cleanup_control_flow uses it to detect cases where a mid-block\n+   indirect call has been turned into a noreturn call.  When this\n+   happens, all the instructions after the call are no longer\n+   reachable and must be deleted as dead.  */\n+\n+VEC(tree,gc) *modified_noreturn_calls;\n+\n+/* Try to remove superfluous control structures.  */\n+\n+static bool\n+cleanup_control_flow (void)\n+{\n+  basic_block bb;\n+  block_stmt_iterator bsi;\n+  bool retval = false;\n+  tree stmt;\n+\n+  /* Detect cases where a mid-block call is now known not to return.  */\n+  while (VEC_length (tree, modified_noreturn_calls))\n+    {\n+      stmt = VEC_pop (tree, modified_noreturn_calls);\n+      bb = bb_for_stmt (stmt);\n+      if (bb != NULL && last_stmt (bb) != stmt && noreturn_call_p (stmt))\n+\tsplit_block (bb, stmt);\n+    }\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      bsi = bsi_last (bb);\n+\n+      if (bsi_end_p (bsi))\n+\tcontinue;\n+\n+      stmt = bsi_stmt (bsi);\n+      if (TREE_CODE (stmt) == COND_EXPR\n+\t  || TREE_CODE (stmt) == SWITCH_EXPR)\n+\tretval |= cleanup_control_expr_graph (bb, bsi);\n+\n+      /* If we had a computed goto which has a compile-time determinable\n+\t destination, then we can eliminate the goto.  */\n+      if (TREE_CODE (stmt) == GOTO_EXPR\n+\t  && TREE_CODE (GOTO_DESTINATION (stmt)) == ADDR_EXPR\n+\t  && TREE_CODE (TREE_OPERAND (GOTO_DESTINATION (stmt), 0)) == LABEL_DECL)\n+\t{\n+\t  edge e;\n+\t  tree label;\n+\t  edge_iterator ei;\n+\t  basic_block target_block;\n+\t  bool removed_edge = false;\n+\n+\t  /* First look at all the outgoing edges.  Delete any outgoing\n+\t     edges which do not go to the right block.  For the one\n+\t     edge which goes to the right block, fix up its flags.  */\n+\t  label = TREE_OPERAND (GOTO_DESTINATION (stmt), 0);\n+\t  target_block = label_to_block (label);\n+\t  for (ei = ei_start (bb->succs); (e = ei_safe_edge (ei)); )\n+\t    {\n+\t      if (e->dest != target_block)\n+\t\t{\n+\t\t  removed_edge = true;\n+\t\t  remove_edge (e);\n+\t\t}\n+\t      else\n+\t        {\n+\t\t  /* Turn off the EDGE_ABNORMAL flag.  */\n+\t\t  e->flags &= ~EDGE_ABNORMAL;\n+\n+\t\t  /* And set EDGE_FALLTHRU.  */\n+\t\t  e->flags |= EDGE_FALLTHRU;\n+\t\t  ei_next (&ei);\n+\t\t}\n+\t    }\n+\n+\t  /* If we removed one or more edges, then we will need to fix the\n+\t     dominators.  It may be possible to incrementally update them.  */\n+\t  if (removed_edge)\n+\t    free_dominance_info (CDI_DOMINATORS);\n+\n+\t  /* Remove the GOTO_EXPR as it is not needed.  The CFG has all the\n+\t     relevant information we need.  */\n+\t  bsi_remove (&bsi);\n+\t  retval = true;\n+\t}\n+\n+      /* Check for indirect calls that have been turned into\n+\t noreturn calls.  */\n+      if (noreturn_call_p (stmt) && remove_fallthru_edge (bb->succs))\n+\t{\n+\t  free_dominance_info (CDI_DOMINATORS);\n+\t  retval = true;\n+\t}\n+    }\n+  return retval;\n+}\n+\n+/* Return true if basic block BB does nothing except pass control\n+   flow to another block and that we can safely insert a label at\n+   the start of the successor block.\n+\n+   As a precondition, we require that BB be not equal to\n+   ENTRY_BLOCK_PTR.  */\n+\n+static bool\n+tree_forwarder_block_p (basic_block bb, bool phi_wanted)\n+{\n+  block_stmt_iterator bsi;\n+\n+  /* BB must have a single outgoing edge.  */\n+  if (single_succ_p (bb) != 1\n+      /* If PHI_WANTED is false, BB must not have any PHI nodes.\n+\t Otherwise, BB must have PHI nodes.  */\n+      || (phi_nodes (bb) != NULL_TREE) != phi_wanted\n+      /* BB may not be a predecessor of EXIT_BLOCK_PTR.  */\n+      || single_succ (bb) == EXIT_BLOCK_PTR\n+      /* Nor should this be an infinite loop.  */\n+      || single_succ (bb) == bb\n+      /* BB may not have an abnormal outgoing edge.  */\n+      || (single_succ_edge (bb)->flags & EDGE_ABNORMAL))\n+    return false;\n+\n+#if ENABLE_CHECKING\n+  gcc_assert (bb != ENTRY_BLOCK_PTR);\n+#endif\n+\n+  /* Now walk through the statements backward.  We can ignore labels,\n+     anything else means this is not a forwarder block.  */\n+  for (bsi = bsi_last (bb); !bsi_end_p (bsi); bsi_prev (&bsi))\n+    {\n+      tree stmt = bsi_stmt (bsi);\n+\n+      switch (TREE_CODE (stmt))\n+\t{\n+\tcase LABEL_EXPR:\n+\t  if (DECL_NONLOCAL (LABEL_EXPR_LABEL (stmt)))\n+\t    return false;\n+\t  break;\n+\n+\tdefault:\n+\t  return false;\n+\t}\n+    }\n+\n+  if (find_edge (ENTRY_BLOCK_PTR, bb))\n+    return false;\n+\n+  if (current_loops)\n+    {\n+      basic_block dest;\n+      /* Protect loop latches, headers and preheaders.  */\n+      if (bb->loop_father->header == bb)\n+\treturn false;\n+      dest = EDGE_SUCC (bb, 0)->dest;\n+\n+      if (dest->loop_father->header == dest)\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n+\n+/* Return true if BB has at least one abnormal incoming edge.  */\n+\n+static inline bool\n+has_abnormal_incoming_edge_p (basic_block bb)\n+{\n+  edge e;\n+  edge_iterator ei;\n+\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    if (e->flags & EDGE_ABNORMAL)\n+      return true;\n+\n+  return false;\n+}\n+\n+/* If all the PHI nodes in DEST have alternatives for E1 and E2 and\n+   those alternatives are equal in each of the PHI nodes, then return\n+   true, else return false.  */\n+\n+static bool\n+phi_alternatives_equal (basic_block dest, edge e1, edge e2)\n+{\n+  int n1 = e1->dest_idx;\n+  int n2 = e2->dest_idx;\n+  tree phi;\n+\n+  for (phi = phi_nodes (dest); phi; phi = PHI_CHAIN (phi))\n+    {\n+      tree val1 = PHI_ARG_DEF (phi, n1);\n+      tree val2 = PHI_ARG_DEF (phi, n2);\n+\n+      gcc_assert (val1 != NULL_TREE);\n+      gcc_assert (val2 != NULL_TREE);\n+\n+      if (!operand_equal_for_phi_arg_p (val1, val2))\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n+\n+/* Removes forwarder block BB.  Returns false if this failed.  If a new\n+   forwarder block is created due to redirection of edges, it is\n+   stored to worklist.  */\n+\n+static bool\n+remove_forwarder_block (basic_block bb, basic_block **worklist)\n+{\n+  edge succ = single_succ_edge (bb), e, s;\n+  basic_block dest = succ->dest;\n+  tree label;\n+  tree phi;\n+  edge_iterator ei;\n+  block_stmt_iterator bsi, bsi_to;\n+  bool seen_abnormal_edge = false;\n+\n+  /* We check for infinite loops already in tree_forwarder_block_p.\n+     However it may happen that the infinite loop is created\n+     afterwards due to removal of forwarders.  */\n+  if (dest == bb)\n+    return false;\n+\n+  /* If the destination block consists of a nonlocal label, do not merge\n+     it.  */\n+  label = first_stmt (dest);\n+  if (label\n+      && TREE_CODE (label) == LABEL_EXPR\n+      && DECL_NONLOCAL (LABEL_EXPR_LABEL (label)))\n+    return false;\n+\n+  /* If there is an abnormal edge to basic block BB, but not into\n+     dest, problems might occur during removal of the phi node at out\n+     of ssa due to overlapping live ranges of registers.\n+\n+     If there is an abnormal edge in DEST, the problems would occur\n+     anyway since cleanup_dead_labels would then merge the labels for\n+     two different eh regions, and rest of exception handling code\n+     does not like it.\n+\n+     So if there is an abnormal edge to BB, proceed only if there is\n+     no abnormal edge to DEST and there are no phi nodes in DEST.  */\n+  if (has_abnormal_incoming_edge_p (bb))\n+    {\n+      seen_abnormal_edge = true;\n+\n+      if (has_abnormal_incoming_edge_p (dest)\n+\t  || phi_nodes (dest) != NULL_TREE)\n+\treturn false;\n+    }\n+\n+  /* If there are phi nodes in DEST, and some of the blocks that are\n+     predecessors of BB are also predecessors of DEST, check that the\n+     phi node arguments match.  */\n+  if (phi_nodes (dest))\n+    {\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n+\t{\n+\t  s = find_edge (e->src, dest);\n+\t  if (!s)\n+\t    continue;\n+\n+\t  if (!phi_alternatives_equal (dest, succ, s))\n+\t    return false;\n+\t}\n+    }\n+\n+  /* Redirect the edges.  */\n+  for (ei = ei_start (bb->preds); (e = ei_safe_edge (ei)); )\n+    {\n+      if (e->flags & EDGE_ABNORMAL)\n+\t{\n+\t  /* If there is an abnormal edge, redirect it anyway, and\n+\t     move the labels to the new block to make it legal.  */\n+\t  s = redirect_edge_succ_nodup (e, dest);\n+\t}\n+      else\n+\ts = redirect_edge_and_branch (e, dest);\n+\n+      if (s == e)\n+\t{\n+\t  /* Create arguments for the phi nodes, since the edge was not\n+\t     here before.  */\n+\t  for (phi = phi_nodes (dest); phi; phi = PHI_CHAIN (phi))\n+\t    add_phi_arg (phi, PHI_ARG_DEF (phi, succ->dest_idx), s);\n+\t}\n+      else\n+\t{\n+\t  /* The source basic block might become a forwarder.  We know\n+\t     that it was not a forwarder before, since it used to have\n+\t     at least two outgoing edges, so we may just add it to\n+\t     worklist.  */\n+\t  if (tree_forwarder_block_p (s->src, false))\n+\t    *(*worklist)++ = s->src;\n+\t}\n+    }\n+\n+  if (seen_abnormal_edge)\n+    {\n+      /* Move the labels to the new block, so that the redirection of\n+\t the abnormal edges works.  */\n+\n+      bsi_to = bsi_start (dest);\n+      for (bsi = bsi_start (bb); !bsi_end_p (bsi); )\n+\t{\n+\t  label = bsi_stmt (bsi);\n+\t  gcc_assert (TREE_CODE (label) == LABEL_EXPR);\n+\t  bsi_remove (&bsi);\n+\t  bsi_insert_before (&bsi_to, label, BSI_CONTINUE_LINKING);\n+\t}\n+    }\n+\n+  /* Update the dominators.  */\n+  if (dom_info_available_p (CDI_DOMINATORS))\n+    {\n+      basic_block dom, dombb, domdest;\n+\n+      dombb = get_immediate_dominator (CDI_DOMINATORS, bb);\n+      domdest = get_immediate_dominator (CDI_DOMINATORS, dest);\n+      if (domdest == bb)\n+\t{\n+\t  /* Shortcut to avoid calling (relatively expensive)\n+\t     nearest_common_dominator unless necessary.  */\n+\t  dom = dombb;\n+\t}\n+      else\n+\tdom = nearest_common_dominator (CDI_DOMINATORS, domdest, dombb);\n+\n+      set_immediate_dominator (CDI_DOMINATORS, dest, dom);\n+    }\n+\n+  /* And kill the forwarder block.  */\n+  delete_basic_block (bb);\n+\n+  return true;\n+}\n+\n+/* Removes forwarder blocks.  */\n+\n+static bool\n+cleanup_forwarder_blocks (void)\n+{\n+  basic_block bb;\n+  bool changed = false;\n+  basic_block *worklist = xmalloc (sizeof (basic_block) * n_basic_blocks);\n+  basic_block *current = worklist;\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      if (tree_forwarder_block_p (bb, false))\n+\t*current++ = bb;\n+    }\n+\n+  while (current != worklist)\n+    {\n+      bb = *--current;\n+      changed |= remove_forwarder_block (bb, &current);\n+    }\n+\n+  free (worklist);\n+  return changed;\n+}\n+\n+/* Remove unreachable blocks and other miscellaneous clean up work.  */\n+\n+bool\n+cleanup_tree_cfg (void)\n+{\n+  bool retval = false;\n+\n+  timevar_push (TV_TREE_CLEANUP_CFG);\n+\n+  retval = cleanup_control_flow ();\n+  retval |= delete_unreachable_blocks ();\n+\n+  /* cleanup_forwarder_blocks can redirect edges out of SWITCH_EXPRs,\n+     which can get expensive.  So we want to enable recording of edge\n+     to CASE_LABEL_EXPR mappings around the call to\n+     cleanup_forwarder_blocks.  */\n+  start_recording_case_labels ();\n+  retval |= cleanup_forwarder_blocks ();\n+  end_recording_case_labels ();\n+\n+#ifdef ENABLE_CHECKING\n+  if (retval)\n+    {\n+      gcc_assert (!cleanup_control_flow ());\n+      gcc_assert (!delete_unreachable_blocks ());\n+      gcc_assert (!cleanup_forwarder_blocks ());\n+    }\n+#endif\n+\n+  /* Merging the blocks creates no new opportunities for the other\n+     optimizations, so do it here.  */\n+  retval |= merge_seq_blocks ();\n+\n+  compact_blocks ();\n+\n+#ifdef ENABLE_CHECKING\n+  verify_flow_info ();\n+#endif\n+  timevar_pop (TV_TREE_CLEANUP_CFG);\n+  return retval;\n+}\n+\n+/* Cleanup cfg and repair loop structures.  */\n+\n+void\n+cleanup_tree_cfg_loop (void)\n+{\n+  bitmap changed_bbs = BITMAP_ALLOC (NULL);\n+\n+  cleanup_tree_cfg ();\n+\n+  fix_loop_structure (current_loops, changed_bbs);\n+  calculate_dominance_info (CDI_DOMINATORS);\n+\n+  /* This usually does nothing.  But sometimes parts of cfg that originally\n+     were inside a loop get out of it due to edge removal (since they\n+     become unreachable by back edges from latch).  */\n+  rewrite_into_loop_closed_ssa (changed_bbs, TODO_update_ssa);\n+\n+  BITMAP_FREE (changed_bbs);\n+\n+#ifdef ENABLE_CHECKING\n+  verify_loop_structure (current_loops);\n+#endif\n+}\n+\n+/* Merge the PHI nodes at BB into those at BB's sole successor.  */\n+\n+static void\n+remove_forwarder_block_with_phi (basic_block bb)\n+{\n+  edge succ = single_succ_edge (bb);\n+  basic_block dest = succ->dest;\n+  tree label;\n+  basic_block dombb, domdest, dom;\n+\n+  /* We check for infinite loops already in tree_forwarder_block_p.\n+     However it may happen that the infinite loop is created\n+     afterwards due to removal of forwarders.  */\n+  if (dest == bb)\n+    return;\n+\n+  /* If the destination block consists of a nonlocal label, do not\n+     merge it.  */\n+  label = first_stmt (dest);\n+  if (label\n+      && TREE_CODE (label) == LABEL_EXPR\n+      && DECL_NONLOCAL (LABEL_EXPR_LABEL (label)))\n+    return;\n+\n+  /* Redirect each incoming edge to BB to DEST.  */\n+  while (EDGE_COUNT (bb->preds) > 0)\n+    {\n+      edge e = EDGE_PRED (bb, 0), s;\n+      tree phi;\n+\n+      s = find_edge (e->src, dest);\n+      if (s)\n+\t{\n+\t  /* We already have an edge S from E->src to DEST.  If S and\n+\t     E->dest's sole successor edge have the same PHI arguments\n+\t     at DEST, redirect S to DEST.  */\n+\t  if (phi_alternatives_equal (dest, s, succ))\n+\t    {\n+\t      e = redirect_edge_and_branch (e, dest);\n+\t      PENDING_STMT (e) = NULL_TREE;\n+\t      continue;\n+\t    }\n+\n+\t  /* PHI arguments are different.  Create a forwarder block by\n+\t     splitting E so that we can merge PHI arguments on E to\n+\t     DEST.  */\n+\t  e = single_succ_edge (split_edge (e));\n+\t}\n+\n+      s = redirect_edge_and_branch (e, dest);\n+\n+      /* redirect_edge_and_branch must not create a new edge.  */\n+      gcc_assert (s == e);\n+\n+      /* Add to the PHI nodes at DEST each PHI argument removed at the\n+\t destination of E.  */\n+      for (phi = phi_nodes (dest); phi; phi = PHI_CHAIN (phi))\n+\t{\n+\t  tree def = PHI_ARG_DEF (phi, succ->dest_idx);\n+\n+\t  if (TREE_CODE (def) == SSA_NAME)\n+\t    {\n+\t      tree var;\n+\n+\t      /* If DEF is one of the results of PHI nodes removed during\n+\t\t redirection, replace it with the PHI argument that used\n+\t\t to be on E.  */\n+\t      for (var = PENDING_STMT (e); var; var = TREE_CHAIN (var))\n+\t\t{\n+\t\t  tree old_arg = TREE_PURPOSE (var);\n+\t\t  tree new_arg = TREE_VALUE (var);\n+\n+\t\t  if (def == old_arg)\n+\t\t    {\n+\t\t      def = new_arg;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t    }\n+\n+\t  add_phi_arg (phi, def, s);\n+\t}\n+\n+      PENDING_STMT (e) = NULL;\n+    }\n+\n+  /* Update the dominators.  */\n+  dombb = get_immediate_dominator (CDI_DOMINATORS, bb);\n+  domdest = get_immediate_dominator (CDI_DOMINATORS, dest);\n+  if (domdest == bb)\n+    {\n+      /* Shortcut to avoid calling (relatively expensive)\n+\t nearest_common_dominator unless necessary.  */\n+      dom = dombb;\n+    }\n+  else\n+    dom = nearest_common_dominator (CDI_DOMINATORS, domdest, dombb);\n+\n+  set_immediate_dominator (CDI_DOMINATORS, dest, dom);\n+\n+  /* Remove BB since all of BB's incoming edges have been redirected\n+     to DEST.  */\n+  delete_basic_block (bb);\n+}\n+\n+/* This pass merges PHI nodes if one feeds into another.  For example,\n+   suppose we have the following:\n+\n+  goto <bb 9> (<L9>);\n+\n+<L8>:;\n+  tem_17 = foo ();\n+\n+  # tem_6 = PHI <tem_17(8), tem_23(7)>;\n+<L9>:;\n+\n+  # tem_3 = PHI <tem_6(9), tem_2(5)>;\n+<L10>:;\n+\n+  Then we merge the first PHI node into the second one like so:\n+\n+  goto <bb 9> (<L10>);\n+\n+<L8>:;\n+  tem_17 = foo ();\n+\n+  # tem_3 = PHI <tem_23(7), tem_2(5), tem_17(8)>;\n+<L10>:;\n+*/\n+\n+static void\n+merge_phi_nodes (void)\n+{\n+  basic_block *worklist = xmalloc (sizeof (basic_block) * n_basic_blocks);\n+  basic_block *current = worklist;\n+  basic_block bb;\n+\n+  calculate_dominance_info (CDI_DOMINATORS);\n+\n+  /* Find all PHI nodes that we may be able to merge.  */\n+  FOR_EACH_BB (bb)\n+    {\n+      basic_block dest;\n+\n+      /* Look for a forwarder block with PHI nodes.  */\n+      if (!tree_forwarder_block_p (bb, true))\n+\tcontinue;\n+\n+      dest = single_succ (bb);\n+\n+      /* We have to feed into another basic block with PHI\n+\t nodes.  */\n+      if (!phi_nodes (dest)\n+\t  /* We don't want to deal with a basic block with\n+\t     abnormal edges.  */\n+\t  || has_abnormal_incoming_edge_p (bb))\n+\tcontinue;\n+\n+      if (!dominated_by_p (CDI_DOMINATORS, dest, bb))\n+\t{\n+\t  /* If BB does not dominate DEST, then the PHI nodes at\n+\t     DEST must be the only users of the results of the PHI\n+\t     nodes at BB.  */\n+\t  *current++ = bb;\n+\t}\n+    }\n+\n+  /* Now let's drain WORKLIST.  */\n+  while (current != worklist)\n+    {\n+      bb = *--current;\n+      remove_forwarder_block_with_phi (bb);\n+    }\n+\n+  free (worklist);\n+}\n+\n+static bool\n+gate_merge_phi (void)\n+{\n+  return 1;\n+}\n+\n+struct tree_opt_pass pass_merge_phi = {\n+  \"mergephi\",\t\t\t/* name */\n+  gate_merge_phi,\t\t/* gate */\n+  merge_phi_nodes,\t\t/* execute */\n+  NULL,\t\t\t\t/* sub */\n+  NULL,\t\t\t\t/* next */\n+  0,\t\t\t\t/* static_pass_number */\n+  TV_TREE_MERGE_PHI,\t\t/* tv_id */\n+  PROP_cfg | PROP_ssa,\t\t/* properties_required */\n+  0,\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t/* todo_flags_start */\n+  TODO_dump_func | TODO_ggc_collect\t/* todo_flags_finish */\n+  | TODO_verify_ssa,\n+  0\t\t\t\t/* letter */\n+};"}, {"sha": "0bbfb778a77ce71ee6ffea174658f34bc83439bc", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9784e6d692d56a5fdda4b90febe2b8856972cba/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9784e6d692d56a5fdda4b90febe2b8856972cba/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=c9784e6d692d56a5fdda4b90febe2b8856972cba", "patch": "@@ -489,8 +489,6 @@ extern void debug_loop_ir (void);\n extern void print_loop_ir (FILE *);\n extern void cleanup_dead_labels (void);\n extern void group_case_labels (void);\n-extern bool cleanup_tree_cfg (void);\n-extern void cleanup_tree_cfg_loop (void);\n extern tree first_stmt (basic_block);\n extern tree last_stmt (basic_block);\n extern tree *last_stmt_ptr (basic_block);\n@@ -523,6 +521,12 @@ extern tree gimplify_build3 (block_stmt_iterator *, enum tree_code,\n extern void init_empty_tree_cfg (void);\n extern void fold_cond_expr_cond (void);\n extern void replace_uses_by (tree, tree);\n+extern void start_recording_case_labels (void);\n+extern void end_recording_case_labels (void);\n+\n+/* In tree-cfgcleanup.c  */\n+extern bool cleanup_tree_cfg (void);\n+extern void cleanup_tree_cfg_loop (void);\n \n /* In tree-pretty-print.c.  */\n extern void dump_generic_bb (FILE *, basic_block, int, int);"}]}