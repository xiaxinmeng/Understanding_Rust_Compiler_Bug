{"sha": "821e1ea1b155e9ca33f12e8e7af447042822c66b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODIxZTFlYTFiMTU1ZTljYTMzZjEyZThlN2FmNDQ3MDQyODIyYzY2Yg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2004-06-07T19:52:53Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2004-06-07T19:52:53Z"}, "message": "ada-tree.def (TRANSFORM_EXPR, [...]): Deleted.\n\n\t* ada-tree.def (TRANSFORM_EXPR, ALLOCATE_EXPR, USE_EXPR): Deleted.\n\t(GNAT_NOP_EXPR, GNAT_LOOP_ID, EXPR_STMT, NULL_STMT): Likewise.\n\t(BLOCK_STMT, IF_STMT, GOTO_STMT, LABEL_STMT, RETURN_STMT): Likewise.\n\t(ASM_STMT, BREAK_STMT, REGION_STMT,HANDLER_STMT): Likewise.\n\t(STMT_STMT, USE_STMT): New statement codes.\n\t(LOOP_STMT, EXIT_STMT): Make slight semantic changes.\n\t* ada-tree.h: Reflect above changes.\n \t(struct tree_loop_id): Deleted.\n\t(union lang_tree_node, struct lang_decl, struct lang_type):\n\tNow just contains a tree node; update macros using TYPE_LANG_SPECIFIC\n\tand DECL_LANGUAGE_SPECIFIC to reflect these changes.\n\t(DECL_INIT_BY_ASSIGN_P, TRE_LOOP_NODE_ID, TREE_SLOC): Deleted.\n\t(IS_ADA_STMT): New macro.\n\t* decl.c (annotate_decl_with_node): New function.\n\t(gnat_to_gnu_entity): Use it and Sloc_to_locus instead of set_lineno.\n\t(gnat_to_gnu_entity, case object): Remove call to expand CONVERT_EXPR.\n\tCall add_stmt_with_node to do needed assignments.\n\tAdd call to update setjmp buffer directly, not via EXPR_STMT.\n\t(maybe_variable): Argment GNAT_NODE deleted.\n\t* gigi.h (maybe_variable): Likewise.\n\t(make_transform, add_stmt_with_node, set_block_for_group): New.\n\t(gnat_gimplify_expr, gnat_expand_body, Sloc_to_locus): Likewise.\n\t(set_block_jmpbuf_decl, get_block_jmpbuf_decl): Likewise.\n\t(discard_file_names, gnu_block_stack, gnat_to_code): Deleted.\n\t(set_lineno, set_lineno_from_sloc): Likewise.\n\t(record_code_position, insert_code_for): Likewise.\n\t(gnat_poplevel): Now returns void.\n\t(end_subprog_body): Now takes argument.\n\t* misc.c (cgraph.h, tree-inline.h): New includes.\n\t(gnat_tree_size, LANG_HOOKS_TREE_SIZE): Deleted.\n\t(gnat_post_options, LANG_HOOKS_POST_OPTIONS): New.\n\t(LANG_HOOKS_CALLGRAPH_EXPAND_FUNCTION): Likewise.\n\t(LANG_HOOKS_RTL_EXPAND_STMT, LANG_HOOKS_GIMPLIFY_EXPR): Likewise.\n\t(gnat_parse_file): Don't set immediate_size_expand.\n\tCall cgraph functions.\n\t(gnat_expand_expr): Remove most cases.\n\t(record_code_position, insert_code_for): Remove from here.\n\t* trans.c (toplev.h, tree-gimple.h): Now included.\n\t(discard_file_names): Deleted.\n\t(gnu_block_stack, gnu_block_stmt_node, gnu_block_stmt_free_list): Del.\n\t(first_nondeleted_insn, make_expr_stmt_from_rtl): Likewise.\n\t(struct stmt_group, current_stmt_group, stmt_group_free_list): New.\n\t(gnu_stack_free_list, record_cost_position, insert_code_for): Likewise.\n\t(add_cleanup, push_stack, gnat_gimplify_stmt, add_cleanup): Likewise.\n\t(gnat_gimplify_type_sizes, gnat_gimplify_one_sizepos): Likewise.\n\t(gnat_expand_body_1, gnat_gimplify_expr, annotate_with_node): Likewise.\n\t(set_block_for_group, add_stmt_list): Likewise.\n\t(start_stmt_group): Renamed from start_block_stmt.\n\t(end_stmt_group): Likewise, from end_block_stmt.\n\t(build_stmt_group): Likewise, from build_block_stmt, also add arg.\n\t(gigi): Don't set discard_file_names or call set_lineno.\n\tDisallow front end ZCX; call gnat_to_gnu, not gnat_to_code.\n\t(tree_transform): Deleted, now renamed to be gnat_to_gnu.\n\tNumerous changes throughout to reflect new names and complete\n\tfunction-at-a-time implementation.\n\t(gnat_expand_stmt): Delete or comment out all cases.\n\t(process_inlined_subprograms): Use add_stmt.\n\t(process_decls): Use gnat_to_gnu, not gnat_to_code, and don't\n\tcall set_lineno; also remove unneeded block handling.\n\t(process_type): Remove unneeded block handling.\n\t(build_unit_elab): Remove calls to deleted functions.\n\t* utils.c (cgraph.h, tree-inline.h, tree-gimple.h): Now include.\n\t(tree-dump.h): Likewise.\n\t(struct ada_binding_level): Add field jmpbuf_decl.\n\t(gnat_define_builtin, gnat_install_builtins): New.\n\t(gnat_gimplify_function, gnat_finalize): Likewise.\n\t(gnat_poplevel): No longer return BLOCK, set it instead.\n\tRemove code dealing with nested functions.\n\t(gnat_init_decl_processing): Also set size_type_node.\n\tCall gnat_install_builtins.\n\t(create_var_decl): Don't set DECL_INIT_BY_ASSIGN.\n\t(create_subprog_decl): Change handling of inline_flag; set TREE_STATIC.\n\tRemove special-case for \"main\".\n\t(end_subprog_body): Add arg and rework for tree-ssa.\n\t(convert): Don't use GNAT_NOP_EXPR or look for TRANSFORM_EXPR.\n\tAdd case for BOOLEAN_TYPE.\n\t* utils2.c (rtl.h): Now include.\n\t(build_call_raise): Test Debug_Flag_NN directly.\n\t(build_call_alloc_dealloc): Don't use local stack allocation for now.\n\t(gnat_mark_addressable, case GNAT_NOP_EXPR): Deleted.\n\t(gnat_mark_addressable, case VAR_DECL): Handle both early & late cases.\n\nFrom-SVN: r82714", "tree": {"sha": "b12eaf8066a9e3f36a310863af9847788fd50cf0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b12eaf8066a9e3f36a310863af9847788fd50cf0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/821e1ea1b155e9ca33f12e8e7af447042822c66b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/821e1ea1b155e9ca33f12e8e7af447042822c66b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/821e1ea1b155e9ca33f12e8e7af447042822c66b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/821e1ea1b155e9ca33f12e8e7af447042822c66b/comments", "author": null, "committer": null, "parents": [{"sha": "45b0c94cb45aefa68b1627f8a76a84bad2d5b717", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45b0c94cb45aefa68b1627f8a76a84bad2d5b717", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45b0c94cb45aefa68b1627f8a76a84bad2d5b717"}], "stats": {"total": 3081, "additions": 1474, "deletions": 1607}, "files": [{"sha": "d4a85250bb4afffa80c5086743457218cb808f68", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/821e1ea1b155e9ca33f12e8e7af447042822c66b/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/821e1ea1b155e9ca33f12e8e7af447042822c66b/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=821e1ea1b155e9ca33f12e8e7af447042822c66b", "patch": "@@ -1,3 +1,87 @@\n+2004-06-07  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* ada-tree.def (TRANSFORM_EXPR, ALLOCATE_EXPR, USE_EXPR): Deleted.\n+\t(GNAT_NOP_EXPR, GNAT_LOOP_ID, EXPR_STMT, NULL_STMT): Likewise.\n+\t(BLOCK_STMT, IF_STMT, GOTO_STMT, LABEL_STMT, RETURN_STMT): Likewise.\n+\t(ASM_STMT, BREAK_STMT, REGION_STMT,HANDLER_STMT): Likewise.\n+\t(STMT_STMT, USE_STMT): New statement codes.\n+\t(LOOP_STMT, EXIT_STMT): Make slight semantic changes.\n+\t* ada-tree.h: Reflect above changes.\n+ \t(struct tree_loop_id): Deleted.\n+\t(union lang_tree_node, struct lang_decl, struct lang_type):\n+\tNow just contains a tree node; update macros using TYPE_LANG_SPECIFIC\n+\tand DECL_LANGUAGE_SPECIFIC to reflect these changes.\n+\t(DECL_INIT_BY_ASSIGN_P, TRE_LOOP_NODE_ID, TREE_SLOC): Deleted.\n+\t(IS_ADA_STMT): New macro.\n+\t* decl.c (annotate_decl_with_node): New function.\n+\t(gnat_to_gnu_entity): Use it and Sloc_to_locus instead of set_lineno.\n+\t(gnat_to_gnu_entity, case object): Remove call to expand CONVERT_EXPR.\n+\tCall add_stmt_with_node to do needed assignments.\n+\tAdd call to update setjmp buffer directly, not via EXPR_STMT.\n+\t(maybe_variable): Argment GNAT_NODE deleted.\n+\t* gigi.h (maybe_variable): Likewise.\n+\t(make_transform, add_stmt_with_node, set_block_for_group): New.\n+\t(gnat_gimplify_expr, gnat_expand_body, Sloc_to_locus): Likewise.\n+\t(set_block_jmpbuf_decl, get_block_jmpbuf_decl): Likewise.\n+\t(discard_file_names, gnu_block_stack, gnat_to_code): Deleted.\n+\t(set_lineno, set_lineno_from_sloc): Likewise.\n+\t(record_code_position, insert_code_for): Likewise.\n+\t(gnat_poplevel): Now returns void.\n+\t(end_subprog_body): Now takes argument.\n+\t* misc.c (cgraph.h, tree-inline.h): New includes.\n+\t(gnat_tree_size, LANG_HOOKS_TREE_SIZE): Deleted.\n+\t(gnat_post_options, LANG_HOOKS_POST_OPTIONS): New.\n+\t(LANG_HOOKS_CALLGRAPH_EXPAND_FUNCTION): Likewise.\n+\t(LANG_HOOKS_RTL_EXPAND_STMT, LANG_HOOKS_GIMPLIFY_EXPR): Likewise.\n+\t(gnat_parse_file): Don't set immediate_size_expand.\n+\tCall cgraph functions.\n+\t(gnat_expand_expr): Remove most cases.\n+\t(record_code_position, insert_code_for): Remove from here.\n+\t* trans.c (toplev.h, tree-gimple.h): Now included.\n+\t(discard_file_names): Deleted.\n+\t(gnu_block_stack, gnu_block_stmt_node, gnu_block_stmt_free_list): Del.\n+\t(first_nondeleted_insn, make_expr_stmt_from_rtl): Likewise.\n+\t(struct stmt_group, current_stmt_group, stmt_group_free_list): New.\n+\t(gnu_stack_free_list, record_cost_position, insert_code_for): Likewise.\n+\t(add_cleanup, push_stack, gnat_gimplify_stmt, add_cleanup): Likewise.\n+\t(gnat_gimplify_type_sizes, gnat_gimplify_one_sizepos): Likewise.\n+\t(gnat_expand_body_1, gnat_gimplify_expr, annotate_with_node): Likewise.\n+\t(set_block_for_group, add_stmt_list): Likewise.\n+\t(start_stmt_group): Renamed from start_block_stmt.\n+\t(end_stmt_group): Likewise, from end_block_stmt.\n+\t(build_stmt_group): Likewise, from build_block_stmt, also add arg.\n+\t(gigi): Don't set discard_file_names or call set_lineno.\n+\tDisallow front end ZCX; call gnat_to_gnu, not gnat_to_code.\n+\t(tree_transform): Deleted, now renamed to be gnat_to_gnu.\n+\tNumerous changes throughout to reflect new names and complete\n+\tfunction-at-a-time implementation.\n+\t(gnat_expand_stmt): Delete or comment out all cases.\n+\t(process_inlined_subprograms): Use add_stmt.\n+\t(process_decls): Use gnat_to_gnu, not gnat_to_code, and don't\n+\tcall set_lineno; also remove unneeded block handling.\n+\t(process_type): Remove unneeded block handling.\n+\t(build_unit_elab): Remove calls to deleted functions.\n+\t* utils.c (cgraph.h, tree-inline.h, tree-gimple.h): Now include.\n+\t(tree-dump.h): Likewise.\n+\t(struct ada_binding_level): Add field jmpbuf_decl.\n+\t(gnat_define_builtin, gnat_install_builtins): New.\n+\t(gnat_gimplify_function, gnat_finalize): Likewise.\n+\t(gnat_poplevel): No longer return BLOCK, set it instead.\n+\tRemove code dealing with nested functions.\n+\t(gnat_init_decl_processing): Also set size_type_node.\n+\tCall gnat_install_builtins.\n+\t(create_var_decl): Don't set DECL_INIT_BY_ASSIGN.\n+\t(create_subprog_decl): Change handling of inline_flag; set TREE_STATIC.\n+\tRemove special-case for \"main\".\n+\t(end_subprog_body): Add arg and rework for tree-ssa.\n+\t(convert): Don't use GNAT_NOP_EXPR or look for TRANSFORM_EXPR.\n+\tAdd case for BOOLEAN_TYPE.\n+\t* utils2.c (rtl.h): Now include.\n+\t(build_call_raise): Test Debug_Flag_NN directly.\n+\t(build_call_alloc_dealloc): Don't use local stack allocation for now.\n+\t(gnat_mark_addressable, case GNAT_NOP_EXPR): Deleted.\n+\t(gnat_mark_addressable, case VAR_DECL): Handle both early & late cases.\n+\n 2004-06-07  Robert Dewar  <dewar@gnat.com>\n \n \t* a-direct.ads, einfo.ads: Minor comment updates"}, {"sha": "5922d54ef511f49d9da9642aaef7b973c87ab24c", "filename": "gcc/ada/ada-tree.def", "status": "modified", "additions": 35, "deletions": 70, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/821e1ea1b155e9ca33f12e8e7af447042822c66b/gcc%2Fada%2Fada-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/821e1ea1b155e9ca33f12e8e7af447042822c66b/gcc%2Fada%2Fada-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fada-tree.def?ref=821e1ea1b155e9ca33f12e8e7af447042822c66b", "patch": "@@ -24,21 +24,6 @@\n  *                                                                          *\n  ****************************************************************************/\n \n-/* A GNAT tree node to transform to a GCC tree.  This is only used when the\n-   node would generate code, rather then just a tree, and we are in the global\n-   context.\n-\n-   The only field used is TREE_COMPLEXITY, which contains the GNAT node\n-   number.  */\n-\n-DEFTREECODE (TRANSFORM_EXPR, \"transform_expr\", 'e', 0)\n-\n-/* Dynamically allocate on the stack a number of bytes of memory given\n-   by operand 0 at the alignment given by operand 1 and return the\n-   address of the resulting memory.  */\n-\n-DEFTREECODE (ALLOCATE_EXPR, \"allocate_expr\", '2', 2)\n-\n /* A type that is an unconstrained array itself.  This node is never passed\n    to GCC. TREE_TYPE is the type of the fat pointer and TYPE_OBJECT_RECORD_TYPE\n    is the type of a record containing the template and data.  */\n@@ -54,70 +39,50 @@ DEFTREECODE (UNCONSTRAINED_ARRAY_REF, \"unconstrained_array_ref\", 'r', 1)\n \n /* An expression that returns an RTL suitable for its type.  Operand 0\n    is an expression to be evaluated for side effects only.  */\n-\n DEFTREECODE (NULL_EXPR, \"null_expr\", 'e', 1)\n \n-/* An expression that emits a USE for its single operand.  */\n-\n-DEFTREECODE (USE_EXPR, \"use_expr\", 'e', 1)\n-\n /* Same as ADDR_EXPR, except that if the operand represents a bit field,\n    return the address of the byte containing the bit.  This is used\n    for the 'Address attribute and never shows up in the tree.  */\n DEFTREECODE (ATTR_ADDR_EXPR, \"attr_addr_expr\", 'r', 1)\n \n-/* An expression that is treated as a conversion while generating code, but is\n-   used to prevent infinite recursion when conversions of biased types are\n-   involved.  */\n-\n-DEFTREECODE (GNAT_NOP_EXPR, \"gnat_nop_expr\", '1', 1)\n-\n-/* This is used as a place to store the ID of a loop.\n-\n-   ??? This should be redone at some point.  */\n-\n-DEFTREECODE (GNAT_LOOP_ID, \"gnat_loop_id\", 'x', 0)\n-\n /* Here are the tree codes for the statement types known to Ada.  These\n-   must be at the end of this file to allow IS_STMT to work.\n-\n-   We start with an expression statement, whose only operand is an\n-   expression, EXPR_STMT_EXPR, Execution of the statement means evaluation of\n-   the expression (such as a MODIFY_EXPR) and discarding its result.  */\n-DEFTREECODE (EXPR_STMT, \"expr_stmt\", 's', 1)\n-\n-/* This is a null statement.  The intent is for it not to survive very far.  */\n-DEFTREECODE (NULL_STMT, \"null_stmt\", 's', 0)\n+   must be at the end of this file to allow IS_ADA_STMT to work.  */\n \n-/* This defines the variable in DECL_STMT_VAR and performs any initialization\n-   in DECL_INITIAL.  */\n+/* This defines the variable in DECL_STMT_VAR.  */\n DEFTREECODE (DECL_STMT, \"decl_stmt\", 's', 1)\n \n-/* This represents a list of statements.  BLOCK_STMT_LIST is a list\n-   statement tree, chained via TREE_CHAIN.  BLOCK_STMT_BLOCK, if nonzero,\n-   is the BLOCK node for these statements.  */\n-DEFTREECODE (BLOCK_STMT, \"block_stmt\", 's', 2)\n-\n-/* This is an IF statement.  IF_STMT_COND is the condition being tested,\n-   IF_STMT_TRUE is the statement to be executed if the condition is\n-   true; IF_STMT_ELSEIF, if non-null, is a list of more IF_STMT nodes (where\n-   we only look at IF_STMT_COND and IF_STMT_TRUE) that correspond to\n-   any \"else if\" parts; and IF_STMT_ELSE is the statement to be executed if\n-   all conditions are.  */\n-DEFTREECODE (IF_STMT, \"if_stmt\", 's', 4)\n-\n-/* A goto just points to the label: GOTO_STMT_LABEL.  */\n-DEFTREECODE (GOTO_STMT, \"goto_stmt\", 's', 1)\n-\n-/* A label: LABEL_STMT_LABEL is the label.  */\n-DEFTREECODE (LABEL_STMT, \"label_stmt\", 's', 1)\n-\n-/* A \"return\".  RETURN_STMT_EXPR is the value to return if non-null.  */\n-DEFTREECODE (RETURN_STMT, \"return_stmt\", 's', 1)\n-\n-/* An \"asm\" statement.  The operands are ASM_STMT_TEMPLATE, ASM_STMT_OUTPUT,\n-   ASM_STMT_ORIG_OUT, ASM_STMT_INPUT, and ASM_STMT_CLOBBER.  */\n-DEFTREECODE (ASM_STMT, \"asm_stmt\", 's', 5)\n+/* This is how record_code_position and insert_code_for work.  The former\n+   makes this tree node, whose operand is a statement.  The latter inserts\n+   the actual statements into this node.  Gimplification consists of\n+   just returning the inner statement.  */\n+DEFTREECODE (STMT_STMT, \"stmt_stmt\", 's', 1)\n+\n+/* A loop.  LOOP_STMT_TOP_COND and LOOP_STMT_BOT_COND are the tests to exit a\n+   loop at the top and bottom, respectively.  LOOP_STMT_UPDATE is the statement\n+   to update the loop iterator at the continue point.  LOOP_STMT_BODY are the\n+   statements in the body of the loop.  LOOP_STMT_LABEL is used during\n+   gimplification to point to the LABEL_DECL of the end label of the loop.  */\n+DEFTREECODE (LOOP_STMT, \"loop_stmt\", 's', 5)\n+\n+/* Conditionally exit a loop.  EXIT_STMT_COND is the condition, which, if\n+   true, will cause the loop to be exited.  If no condition is specified,\n+   the loop is unconditionally exited.  EXIT_STMT_LOOP is the LOOP_STMT\n+   corresponding to the loop to exit.  */\n+DEFTREECODE (EXIT_STMT, \"exit_stmt\", 's', 2)\n+\n+/* A exception region.  REGION_STMT_BODY is the statement to be executed\n+   inside the region.  REGION_STMT_HANDLE is a statement that represents\n+   the exception handlers (usually a BLOCK_STMT of HANDLE_STMTs).\n+   REGION_STMT_BLOCK is the BLOCK node for the declarative region, if any.  */\n+DEFTREECODE (REGION_STMT, \"region_stmt\", 's', 3)\n+\n+/* An exception handler.  HANDLER_STMT_ARG is the value to pass to \n+   expand_start_catch, HANDLER_STMT_LIST is the list of statements for the\n+   handler itself, and HANDLER_STMT_BLOCK is the BLOCK node for this\n+   binding. */\n+DEFTREECODE (HANDLER_STMT, \"handler_stmt\", 's', 3)\n+\n+/* A statement that emits a USE for its single operand.  */\n+DEFTREECODE (USE_STMT, \"use_expr\", 's', 1)\n \n-/* An analog to the C \"break\" statement.  */\n-DEFTREECODE (BREAK_STMT, \"break_stmt\", 's', 0)"}, {"sha": "a43cd48ecf270ade2a698d17f1af34f876768b23", "filename": "gcc/ada/ada-tree.h", "status": "modified", "additions": 29, "deletions": 63, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/821e1ea1b155e9ca33f12e8e7af447042822c66b/gcc%2Fada%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/821e1ea1b155e9ca33f12e8e7af447042822c66b/gcc%2Fada%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fada-tree.h?ref=821e1ea1b155e9ca33f12e8e7af447042822c66b", "patch": "@@ -33,35 +33,10 @@ enum gnat_tree_code {\n };\n #undef DEFTREECODE\n \n-/* A tree to hold a loop ID.  */\n-struct tree_loop_id GTY(())\n-{\n-  struct tree_common common;\n-  struct nesting *loop_id;\n-};\n-\n-/* The language-specific tree.  */\n-union lang_tree_node\n-  GTY((desc (\"TREE_CODE (&%h.generic) == GNAT_LOOP_ID\"),\n-       chain_next (\"(union lang_tree_node *)TREE_CHAIN (&%h.generic)\")))\n-{\n-  union tree_node GTY ((tag (\"0\"),\n-\t\t\tdesc (\"tree_node_structure (&%h)\")))\n-    generic;\n-  struct tree_loop_id GTY ((tag (\"1\"))) loop_id;\n-};\n-\n /* Ada uses the lang_decl and lang_type fields to hold more trees.  */\n-struct lang_decl GTY(())\n-{\n-  union lang_tree_node\n-    GTY((desc (\"TREE_CODE (&%h.generic) == GNAT_LOOP_ID\"))) t;\n-};\n-struct lang_type GTY(())\n-{\n-  union lang_tree_node\n-    GTY((desc (\"TREE_CODE (&%h.generic) == GNAT_LOOP_ID\"))) t;\n-};\n+union lang_tree_node GTY((desc (\"0\"))) {union tree_node GTY((tag (\"0\"))) t; };\n+struct lang_decl GTY(()) {union lang_tree_node t; };\n+struct lang_type GTY(()) {union lang_tree_node t; };\n \n /* Flags added to GCC type nodes.  */\n \n@@ -164,28 +139,28 @@ struct lang_type GTY(())\n    by copy in copy out.  It is a CONSTRUCTOR.  For a full description of the\n    cico parameter passing mechanism refer to the routine gnat_to_gnu_entity. */\n #define TYPE_CI_CO_LIST(NODE)   \\\n-  (&TYPE_LANG_SPECIFIC (FUNCTION_TYPE_CHECK (NODE))->t.generic)\n+  (&TYPE_LANG_SPECIFIC (FUNCTION_TYPE_CHECK (NODE))->t.t)\n #define SET_TYPE_CI_CO_LIST(NODE, X)   \\\n   (TYPE_LANG_SPECIFIC (FUNCTION_TYPE_CHECK (NODE)) = (struct lang_type *)(X))\n \n /* For an INTEGER_TYPE with TYPE_MODULAR_P, this is the value of the\n    modulus. */\n #define TYPE_MODULUS(NODE)  \\\n-  (&TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE))->t.generic)\n+  (&TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE))->t.t)\n #define SET_TYPE_MODULUS(NODE, X)  \\\n   (TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE)) = (struct lang_type *)(X))\n \n /* For an INTEGER_TYPE that is the TYPE_DOMAIN of some ARRAY_TYPE, points to\n    the type corresponding to the Ada index type.  */\n #define TYPE_INDEX_TYPE(NODE)\t\\\n-  (&TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE))->t.generic)\n+  (&TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE))->t.t)\n #define SET_TYPE_INDEX_TYPE(NODE, X)\t\\\n   (TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE)) = (struct lang_type *) (X))\n \n /* For an INTEGER_TYPE with TYPE_VAX_FLOATING_POINT_P, stores the\n    Digits_Value.  */\n #define TYPE_DIGITS_VALUE(NODE) \\\n-  (&TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE))->t.generic)\n+  (&TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE))->t.t)\n #define SET_TYPE_DIGITS_VALUE(NODE, X)  \\\n   (TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE)) = (struct lang_type *) (X))\n \n@@ -194,7 +169,7 @@ struct lang_type GTY(())\n \n /* Likewise for ENUMERAL_TYPE.  */\n #define TYPE_RM_SIZE_ENUM(NODE)\t\\\n-  (&TYPE_LANG_SPECIFIC (ENUMERAL_TYPE_CHECK (NODE))->t.generic)\n+  (&TYPE_LANG_SPECIFIC (ENUMERAL_TYPE_CHECK (NODE))->t.t)\n #define SET_TYPE_RM_SIZE_ENUM(NODE, X)\t\\\n   (TYPE_LANG_SPECIFIC (ENUMERAL_TYPE_CHECK (NODE)) = (struct lang_type *)(X))\n \n@@ -207,21 +182,21 @@ struct lang_type GTY(())\n    unconstrained object.  Likewise for a RECORD_TYPE that is pointed\n    to by a thin pointer.  */\n #define TYPE_UNCONSTRAINED_ARRAY(NODE)  \\\n-  (&TYPE_LANG_SPECIFIC (RECORD_TYPE_CHECK (NODE))->t.generic)\n+  (&TYPE_LANG_SPECIFIC (RECORD_TYPE_CHECK (NODE))->t.t)\n #define SET_TYPE_UNCONSTRAINED_ARRAY(NODE, X)  \\\n   (TYPE_LANG_SPECIFIC (RECORD_TYPE_CHECK (NODE)) = (struct lang_type *)(X))\n \n /* For other RECORD_TYPEs and all UNION_TYPEs and QUAL_UNION_TYPEs, the Ada\n    size of the object.  This differs from the GCC size in that it does not\n    include any rounding up to the alignment of the type.  */\n-#define TYPE_ADA_SIZE(NODE)\t(&TYPE_LANG_SPECIFIC (NODE)->t.generic)\n+#define TYPE_ADA_SIZE(NODE)\t(&TYPE_LANG_SPECIFIC (NODE)->t.t)\n #define SET_TYPE_ADA_SIZE(NODE, X) \\\n   (TYPE_LANG_SPECIFIC (NODE) = (struct lang_type *)(X))\n \n /* For an INTEGER_TYPE with TYPE_HAS_ACTUAL_BOUNDS_P or an ARRAY_TYPE, this is\n    the index type that should be used when the actual bounds are required for\n    a template.  This is used in the case of packed arrays.  */\n-#define TYPE_ACTUAL_BOUNDS(NODE)   (&TYPE_LANG_SPECIFIC (NODE)->t.generic)\n+#define TYPE_ACTUAL_BOUNDS(NODE)   (&TYPE_LANG_SPECIFIC (NODE)->t.t)\n #define SET_TYPE_ACTUAL_BOUNDS(NODE, X) \\\n   (TYPE_LANG_SPECIFIC (NODE) = (struct lang_type *)(X))\n \n@@ -238,9 +213,6 @@ struct lang_type GTY(())\n    discriminant.  */\n #define DECL_STUBBED_P(NODE) DECL_LANG_FLAG_0 (FUNCTION_DECL_CHECK (NODE))\n \n-/* Nonzero in a VAR_DECL if it needs to be initialized by an assignment.  */\n-#define DECL_INIT_BY_ASSIGN_P(NODE) DECL_LANG_FLAG_0 (VAR_DECL_CHECK (NODE))\n-\n /* Nonzero if this decl is always used by reference; i.e., an INDIRECT_REF\n    is needed to access the object.  */\n #define DECL_BY_REF_P(NODE) DECL_LANG_FLAG_1 (NODE)\n@@ -270,46 +242,40 @@ struct lang_type GTY(())\n    memory.  Used when a scalar constant is aliased or has its\n    address taken.  */\n #define DECL_CONST_CORRESPONDING_VAR(NODE) \\\n-  (&DECL_LANG_SPECIFIC (CONST_DECL_CHECK (NODE))->t.generic)\n+  (&DECL_LANG_SPECIFIC (CONST_DECL_CHECK (NODE))->t.t)\n #define SET_DECL_CONST_CORRESPONDING_VAR(NODE, X) \\\n   (DECL_LANG_SPECIFIC (CONST_DECL_CHECK (NODE)) = (struct lang_decl *)(X))\n \n /* In a FIELD_DECL, points to the FIELD_DECL that was the ultimate\n    source of the decl.  */\n #define DECL_ORIGINAL_FIELD(NODE) \\\n-  (&DECL_LANG_SPECIFIC (FIELD_DECL_CHECK (NODE))->t.generic)\n+  (&DECL_LANG_SPECIFIC (FIELD_DECL_CHECK (NODE))->t.t)\n #define SET_DECL_ORIGINAL_FIELD(NODE, X) \\\n   (DECL_LANG_SPECIFIC (FIELD_DECL_CHECK (NODE)) = (struct lang_decl *)(X))\n \n /* In a FIELD_DECL corresponding to a discriminant, contains the\n    discriminant number.  */\n #define DECL_DISCRIMINANT_NUMBER(NODE) DECL_INITIAL (FIELD_DECL_CHECK (NODE))\n \n-/* This is the loop id for a GNAT_LOOP_ID node.  */\n-#define TREE_LOOP_ID(NODE) \\\n-  ((union lang_tree_node *) GNAT_LOOP_ID_CHECK (NODE))->loop_id.loop_id\n-\n /* Define fields and macros for statements.\n \n    Start by defining which tree codes are used for statements.  */\n #define IS_STMT(NODE)\t\t(TREE_CODE_CLASS (TREE_CODE (NODE)) == 's')\n+#define IS_ADA_STMT(NODE)\t(IS_STMT (NODE)\t\t\t\t\\\n+\t\t\t\t && TREE_CODE (NODE) >= DECL_STMT)\n \n-/* We store the Sloc in statement nodes.  */\n-#define TREE_SLOC(NODE)\t\tTREE_COMPLEXITY (STMT_CHECK (NODE))\n-\n-#define EXPR_STMT_EXPR(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, EXPR_STMT, 0)\n #define DECL_STMT_VAR(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, DECL_STMT, 0)\n-#define BLOCK_STMT_LIST(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, BLOCK_STMT, 0)\n-#define BLOCK_STMT_BLOCK(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, BLOCK_STMT, 1)\n-#define IF_STMT_COND(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, IF_STMT, 0)\n-#define IF_STMT_TRUE(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, IF_STMT, 1)\n-#define IF_STMT_ELSEIF(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, IF_STMT, 2)\n-#define IF_STMT_ELSE(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, IF_STMT, 3)\n-#define GOTO_STMT_LABEL(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, GOTO_STMT, 0)\n-#define LABEL_STMT_LABEL(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, LABEL_STMT, 0)\n-#define RETURN_STMT_EXPR(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, RETURN_STMT, 0)\n-#define ASM_STMT_TEMPLATE(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, ASM_STMT, 0)\n-#define ASM_STMT_OUTPUT(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, ASM_STMT, 1)\n-#define ASM_STMT_ORIG_OUT(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, ASM_STMT, 2)\n-#define ASM_STMT_INPUT(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, ASM_STMT, 3)\n-#define ASM_STMT_CLOBBER(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, ASM_STMT, 4)\n+#define STMT_STMT_STMT(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, STMT_STMT, 0)\n+#define LOOP_STMT_TOP_COND(NODE) TREE_OPERAND_CHECK_CODE (NODE, LOOP_STMT, 0)\n+#define LOOP_STMT_BOT_COND(NODE) TREE_OPERAND_CHECK_CODE (NODE, LOOP_STMT, 1)\n+#define LOOP_STMT_UPDATE(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, LOOP_STMT, 2)\n+#define LOOP_STMT_BODY(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, LOOP_STMT, 3)\n+#define LOOP_STMT_LABEL(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, LOOP_STMT, 4)\n+#define EXIT_STMT_COND(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, EXIT_STMT, 0)\n+#define EXIT_STMT_LOOP(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, EXIT_STMT, 1)\n+#define REGION_STMT_BODY(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, REGION_STMT, 0)\n+#define REGION_STMT_HANDLE(NODE) TREE_OPERAND_CHECK_CODE (NODE, REGION_STMT, 1)\n+#define REGION_STMT_BLOCK(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, REGION_STMT, 2)\n+#define HANDLER_STMT_ARG(NODE) TREE_OPERAND_CHECK_CODE (NODE, HANDLER_STMT, 0)\n+#define HANDLER_STMT_LIST(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, HANDLER_STMT, 1)\n+#define HANDLER_STMT_BLOCK(NODE) TREE_OPERAND_CHECK_CODE (NODE, HANDLER_STMT, 2)"}, {"sha": "41d405a47d4d103d1b6721c0ed4893fcdfd25368", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 78, "deletions": 83, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/821e1ea1b155e9ca33f12e8e7af447042822c66b/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/821e1ea1b155e9ca33f12e8e7af447042822c66b/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=821e1ea1b155e9ca33f12e8e7af447042822c66b", "patch": "@@ -102,6 +102,7 @@ static void set_rm_size (Uint, tree, Entity_Id);\n static tree make_type_from_size (tree, tree, int);\n static unsigned int validate_alignment (Uint, Entity_Id, unsigned int);\n static void check_ok_for_atomic (tree, Entity_Id, int);\n+static void annotate_decl_with_node (tree, Node_Id);\n \f\n /* Given GNAT_ENTITY, an entity in the incoming GNAT tree, return a\n    GCC type corresponding to that entity.  GNAT_ENTITY is assumed to\n@@ -279,9 +280,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n   /* Get the name of the entity and set up the line number and filename of\n      the original definition for use in any decl we make.  */\n-\n   gnu_entity_id = get_entity_name (gnat_entity);\n-  set_lineno (gnat_entity, 0);\n+  Sloc_to_locus (Sloc (gnat_entity), &input_location);\n \n   /* If we get here, it means we have not yet done anything with this\n      entity.  If we are not defining it here, it must be external,\n@@ -767,14 +767,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t || (staticp (gnu_expr)\n \t\t\t     && ! TREE_SIDE_EFFECTS (gnu_expr))))\n \t      {\n-\t\tset_lineno (gnat_entity, ! global_bindings_p ());\n \t\tgnu_decl = gnat_stabilize_reference (gnu_expr, 1);\n \t\tsave_gnu_tree (gnat_entity, gnu_decl, 1);\n \t\tsaved = 1;\n-\n-\t\tif (! global_bindings_p ())\n-\t\t  expand_expr_stmt (build1 (CONVERT_EXPR, void_type_node,\n-\t\t\t\t\t    gnu_decl));\n \t\tbreak;\n \t      }\n \t    else\n@@ -955,20 +950,21 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t    TYPE_SIZE_UNIT (gnu_type));\n \t    tree gnu_new_var;\n \n-\t    set_lineno (gnat_entity, 1);\n \t    gnu_new_var\n \t      = create_var_decl (create_concat_name (gnat_entity, \"ALIGN\"),\n \t\t\t\t NULL_TREE, gnu_new_type, gnu_expr,\n \t\t\t\t 0, 0, 0, 0, 0);\n+\t    annotate_decl_with_node (gnu_new_var, gnat_entity);\n \t    add_decl_stmt (gnu_new_var, gnat_entity);\n \n \t    if (gnu_expr != 0)\n-\t      expand_expr_stmt\n-\t\t(build_binary_op\n-\t\t (MODIFY_EXPR, NULL_TREE,\n-\t\t  build_component_ref (gnu_new_var, NULL_TREE,\n-\t\t\t\t       TYPE_FIELDS (gnu_new_type), 0),\n-\t\t  gnu_expr));\n+\t      add_stmt_with_node\n+\t\t(build_binary_op (MODIFY_EXPR, NULL_TREE,\n+\t\t\t\t  build_component_ref\n+\t\t\t\t  (gnu_new_var, NULL_TREE,\n+\t\t\t\t   TYPE_FIELDS (gnu_new_type), 0),\n+\t\t\t\t  gnu_expr),\n+\t\t gnat_entity);\n \n \t    gnu_type = build_reference_type (gnu_type);\n \t    gnu_expr\n@@ -1024,13 +1020,12 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t      && TYPE_IS_PADDING_P (gnu_type))))\n \t  static_p = 1;\n \n-\tset_lineno (gnat_entity, ! global_bindings_p ());\n \tgnu_decl = create_var_decl (gnu_entity_id, gnu_ext_name, gnu_type,\n \t\t\t\t    gnu_expr, const_flag,\n \t\t\t\t    Is_Public (gnat_entity),\n \t\t\t\t    imported_p || !definition,\n \t\t\t\t    static_p, attr_list);\n-\n+\tannotate_decl_with_node (gnu_decl, gnat_entity);\n \tDECL_BY_REF_P (gnu_decl) = used_by_ref;\n \tDECL_POINTS_TO_READONLY_P (gnu_decl) = used_by_ref && inner_const_flag;\n \n@@ -1045,25 +1040,16 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tadd_decl_stmt (gnu_decl, gnat_entity);\n \n \tif (definition && DECL_SIZE (gnu_decl) != 0\n-\t    && gnu_block_stack != 0\n-\t    && TREE_VALUE (gnu_block_stack) != 0\n+\t    && get_block_jmpbuf_decl ()\n \t    && (TREE_CODE (DECL_SIZE (gnu_decl)) != INTEGER_CST\n \t\t|| (flag_stack_check && ! STACK_CHECK_BUILTIN\n \t\t    && 0 < compare_tree_int (DECL_SIZE_UNIT (gnu_decl),\n \t\t\t\t\t     STACK_CHECK_MAX_VAR_SIZE))))\n-\t  {\n-\t    tree gnu_stmt\n-\t      = build_nt (EXPR_STMT,\n-\t\t\t  (build_call_1_expr\n-\t\t\t   (update_setjmp_buf_decl,\n-\t\t\t    build_unary_op\n-\t\t\t    (ADDR_EXPR, NULL_TREE,\n-\t\t\t     TREE_VALUE (gnu_block_stack)))));\n-\n-\t    TREE_SLOC (gnu_stmt) = Sloc (gnat_entity);\n-\t    TREE_TYPE (gnu_stmt) = void_type_node;\n-\t    add_stmt (gnu_stmt);\n-\t  }\n+\t  add_stmt_with_node (build_call_1_expr\n+\t\t\t      (update_setjmp_buf_decl,\n+\t\t\t       build_unary_op (ADDR_EXPR, NULL_TREE,\n+\t\t\t\t\t       get_block_jmpbuf_decl ())),\n+\t\t\t      gnat_entity);\n \n \t/* If this is a public constant or we're not optimizing and we're not\n \t   making a VAR_DECL for it, make one just for export or debugger\n@@ -1527,7 +1513,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    /* Make the FIELD_DECLs for the minimum and maximum of this\n \t       type and then make extractions of that field from the\n \t       template.  */\n-\t    set_lineno (gnat_entity, 0);\n \t    sprintf (field_name, \"LB%d\", index);\n \t    gnu_min_field = create_field_decl (get_identifier (field_name),\n \t\t\t\t\t       gnu_ind_subtype,\n@@ -1537,6 +1522,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t\t       gnu_ind_subtype,\n \t\t\t\t\t       gnu_template_type, 0, 0, 0, 0);\n \n+\t    annotate_decl_with_node (gnu_min_field, gnat_entity);\n+\t    annotate_decl_with_node (gnu_max_field, gnat_entity);\n \t    gnu_temp_fields[index] = chainon (gnu_min_field, gnu_max_field);\n \n \t    /* We can't use build_component_ref here since the template\n@@ -2062,14 +2049,15 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t  /* First finish the type we had been making so that we output\n \t     debugging information for it  */\n-\t  gnu_type = build_qualified_type (gnu_type,\n-\t\t\t\t\t   (TYPE_QUALS (gnu_type)\n-\t\t\t\t\t    | (TYPE_QUAL_VOLATILE\n-\t\t\t\t\t       * Treat_As_Volatile (gnat_entity))));\n-\t  set_lineno (gnat_entity, 0);\n+\t  gnu_type\n+\t    = build_qualified_type (gnu_type,\n+\t\t\t\t    (TYPE_QUALS (gnu_type)\n+\t\t\t\t     | (TYPE_QUAL_VOLATILE\n+\t\t\t\t\t* Treat_As_Volatile (gnat_entity))));\n \t  gnu_decl = create_type_decl (gnu_entity_id, gnu_type, attr_list,\n \t\t\t\t       ! Comes_From_Source (gnat_entity),\n \t\t\t\t       debug_info_p);\n+\t  annotate_decl_with_node (gnu_decl, gnat_entity);\n \t  if (! Comes_From_Source (gnat_entity))\n \t    DECL_ARTIFICIAL (gnu_decl) = 1;\n \n@@ -2128,14 +2116,16 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t      for (gnat_index = First_Index (gnat_entity);\n \t\t   Present (gnat_index); gnat_index = Next_Index (gnat_index))\n-\t\tSET_TYPE_ACTUAL_BOUNDS (gnu_inner_type,\n-\t\t    tree_cons (NULL_TREE,\n-\t\t\t       get_unpadded_type (Etype (gnat_index)),\n-\t\t\t       TYPE_ACTUAL_BOUNDS (gnu_inner_type)));\n+\t\tSET_TYPE_ACTUAL_BOUNDS\n+\t\t  (gnu_inner_type,\n+\t\t   tree_cons (NULL_TREE,\n+\t\t\t      get_unpadded_type (Etype (gnat_index)),\n+\t\t\t      TYPE_ACTUAL_BOUNDS (gnu_inner_type)));\n \n \t      if (Convention (gnat_entity) != Convention_Fortran)\n-\t\tSET_TYPE_ACTUAL_BOUNDS (gnu_inner_type,\n-\t\t    nreverse (TYPE_ACTUAL_BOUNDS (gnu_inner_type)));\n+\t\tSET_TYPE_ACTUAL_BOUNDS\n+\t\t  (gnu_inner_type,\n+\t\t   nreverse (TYPE_ACTUAL_BOUNDS (gnu_inner_type)));\n \n \t      if (TREE_CODE (gnu_type) == RECORD_TYPE\n \t\t  && TYPE_LEFT_JUSTIFIED_MODULAR_P (gnu_type))\n@@ -2295,10 +2285,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  {\n \t    defer_incomplete_level++;\n \t    this_deferred = 1;\n-\t    set_lineno (gnat_entity, 0);\n \t    gnu_decl = create_type_decl (gnu_entity_id, gnu_type, attr_list,\n \t\t\t\t\t ! Comes_From_Source (gnat_entity),\n \t\t\t\t\t debug_info_p);\n+\t    annotate_decl_with_node (gnu_decl, gnat_entity);\n \t    save_gnu_tree (gnat_entity, gnu_decl, 0);\n \t    this_made_decl = saved = 1;\n \t  }\n@@ -2656,10 +2646,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t\t    DECL_INTERNAL_P (gnu_field)\n \t\t      = DECL_INTERNAL_P (gnu_old_field);\n-\t\t    SET_DECL_ORIGINAL_FIELD (gnu_field,\n-\t\t        (DECL_ORIGINAL_FIELD (gnu_old_field) != 0\n-\t\t\t ? DECL_ORIGINAL_FIELD (gnu_old_field)\n-\t\t\t : gnu_old_field));\n+\t\t    SET_DECL_ORIGINAL_FIELD\n+\t\t      (gnu_field, (DECL_ORIGINAL_FIELD (gnu_old_field) != 0\n+\t\t\t\t   ? DECL_ORIGINAL_FIELD (gnu_old_field)\n+\t\t\t\t   : gnu_old_field));\n \t\t    DECL_DISCRIMINANT_NUMBER (gnu_field)\n \t\t      = DECL_DISCRIMINANT_NUMBER (gnu_old_field);\n \t\t    TREE_THIS_VOLATILE (gnu_field)\n@@ -2700,10 +2690,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t  && CONTAINS_PLACEHOLDER_P (TYPE_ADA_SIZE (gnu_type)))\n \t\tfor (gnu_temp = gnu_subst_list;\n \t\t     gnu_temp; gnu_temp = TREE_CHAIN (gnu_temp))\n-\t\t  SET_TYPE_ADA_SIZE (gnu_type,\n-\t\t      substitute_in_expr (TYPE_ADA_SIZE (gnu_type),\n-\t\t\t\t\t  TREE_PURPOSE (gnu_temp),\n-\t\t\t\t\t  TREE_VALUE (gnu_temp)));\n+\t\t  SET_TYPE_ADA_SIZE\n+\t\t    (gnu_type, substitute_in_expr (TYPE_ADA_SIZE (gnu_type),\n+\t\t\t\t\t\t   TREE_PURPOSE (gnu_temp),\n+\t\t\t\t\t\t   TREE_VALUE (gnu_temp)));\n \n \t      /* Recompute the mode of this record type now that we know its\n \t\t actual size.  */\n@@ -2901,7 +2891,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\tSET_TYPE_UNCONSTRAINED_ARRAY (gnu_type, gnu_old);\n \t\tTYPE_POINTER_TO (gnu_old) = gnu_type;\n \n-\t\tset_lineno (gnat_entity, 0);\n+\t\tSloc_to_locus (Sloc (gnat_entity), &input_location);\n \t\tfields\n \t\t  = chainon (chainon (NULL_TREE,\n \t\t\t\t      create_field_decl\n@@ -3492,7 +3482,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      gnu_param = 0;\n \t    else\n \t      {\n-\t\tset_lineno (gnat_param, 0);\n \t\tgnu_param\n \t\t  = create_param_decl\n \t\t    (gnu_param_name, gnu_param_type,\n@@ -3505,6 +3494,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\tDECL_POINTS_TO_READONLY_P (gnu_param)\n \t\t  = (Ekind (gnat_param) == E_In_Parameter\n \t\t     && (by_ref_p || by_component_ptr_p));\n+\t\tannotate_decl_with_node (gnu_param, gnat_param);\n \t\tsave_gnu_tree (gnat_param, gnu_param, 0);\n \t\tgnu_param_list = chainon (gnu_param, gnu_param_list);\n \n@@ -3530,9 +3520,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t    has_copy_in_out = 1;\n \t\t  }\n \n-\t\tset_lineno (gnat_param, 0);\n \t\tgnu_field = create_field_decl (gnu_param_name, gnu_param_type,\n \t\t\t\t\t       gnu_return_type, 0, 0, 0, 0);\n+\t\tannotate_decl_with_node (gnu_field, gnat_param);\n \t\tTREE_CHAIN (gnu_field) = gnu_field_list;\n \t\tgnu_field_list = gnu_field;\n \t\tgnu_return_list = tree_cons (gnu_field, gnu_param,\n@@ -3595,7 +3585,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t   | (TYPE_QUAL_CONST * pure_flag)\n \t\t\t\t   | (TYPE_QUAL_VOLATILE * volatile_flag)));\n \n-\tset_lineno (gnat_entity, 0);\n+\tSloc_to_locus (Sloc (gnat_entity), &input_location);\n \n \t/* If there was no specified Interface_Name and the external and\n \t   internal names of the subprogram are the same, only use the\n@@ -3702,10 +3692,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n       /* Save this type as the full declaration's type so we can do any needed\n \t updates when we see it.  */\n-      set_lineno (gnat_entity, 0);\n       gnu_decl = create_type_decl (gnu_entity_id, gnu_type, attr_list,\n \t\t\t\t   ! Comes_From_Source (gnat_entity),\n \t\t\t\t   debug_info_p);\n+      annotate_decl_with_node (gnu_decl, gnat_entity);\n       save_gnu_tree (Full_View (gnat_entity), gnu_decl, 0);\n       break;\n \n@@ -3867,12 +3857,14 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t   size_int (TYPE_ALIGN (gnu_type) / BITS_PER_UNIT));\n \n \t      if (TREE_CODE (gnu_type) == RECORD_TYPE)\n-\t\tSET_TYPE_ADA_SIZE (gnu_type,\n-\t\t    elaborate_expression_1 (gnat_entity, gnat_entity,\n-\t\t\t\t\t    TYPE_ADA_SIZE (gnu_type),\n-\t\t\t\t\t    get_identifier (\"RM_SIZE\"),\n-\t\t\t\t\t    definition, 0));\n-\t    }\n+\t\tSET_TYPE_ADA_SIZE\n+\t\t  (gnu_type,\n+\t\t   elaborate_expression_1 (gnat_entity,\n+\t\t\t\t\t   gnat_entity,\n+\t\t\t\t\t   TYPE_ADA_SIZE (gnu_type),\n+\t\t\t\t\t   get_identifier (\"RM_SIZE\"),\n+\t\t\t\t\t   definition, 0));\n+\t\t }\n \t}\n \n       /* If this is a record type or subtype, call elaborate_expression_1 on\n@@ -3919,10 +3911,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n       if (gnu_decl == 0)\n \t{\n-\t  set_lineno (gnat_entity, 0);\n \t  gnu_decl = create_type_decl (gnu_entity_id, gnu_type, attr_list,\n \t\t\t\t       ! Comes_From_Source (gnat_entity),\n \t\t\t\t       debug_info_p);\n+\t  annotate_decl_with_node (gnu_decl, gnat_entity);\n \t}\n       else\n \tTREE_TYPE (gnu_decl) = gnu_type;\n@@ -4171,8 +4163,8 @@ mark_out_of_scope (Entity_Id gnat_entity)\n     for (gnat_sub_entity = First_Entity (gnat_entity);\n \t Present (gnat_sub_entity);\n \t gnat_sub_entity = Next_Entity (gnat_sub_entity))\n-            if (Scope (gnat_sub_entity) == gnat_entity\n-\t\t&& gnat_sub_entity != gnat_entity)\n+      if (Scope (gnat_sub_entity) == gnat_entity\n+\t  && gnat_sub_entity != gnat_entity)\n \tmark_out_of_scope (gnat_sub_entity);\n \n   /* Now clear this if it has been defined, but only do so if it isn't\n@@ -4427,18 +4419,13 @@ get_unpadded_type (Entity_Id gnat_entity)\n /* Called when we need to protect a variable object using a save_expr.  */\n \n tree\n-maybe_variable (tree gnu_operand, Node_Id gnat_node)\n+maybe_variable (tree gnu_operand)\n {\n   if (TREE_CONSTANT (gnu_operand) || TREE_READONLY (gnu_operand)\n       || TREE_CODE (gnu_operand) == SAVE_EXPR\n       || TREE_CODE (gnu_operand) == NULL_EXPR)\n     return gnu_operand;\n \n-  /* If we will be generating code, make sure we are at the proper\n-     line number.  */\n-  if (! global_bindings_p () && ! CONTAINS_PLACEHOLDER_P (gnu_operand))\n-  set_lineno (gnat_node, 1);\n-\n   if (TREE_CODE (gnu_operand) == UNCONSTRAINED_ARRAY_REF)\n     {\n       tree gnu_result = build1 (UNCONSTRAINED_ARRAY_REF,\n@@ -4554,12 +4541,12 @@ elaborate_expression_1 (Node_Id gnat_expr,\n   /* Now create the variable if we need it.  */\n   if (need_debug || (expr_variable && expr_global))\n     {\n-      set_lineno (gnat_entity, ! global_bindings_p ());\n       gnu_decl\n \t= create_var_decl (create_concat_name (gnat_entity,\n \t\t\t\t\t       IDENTIFIER_POINTER (gnu_name)),\n \t\t\t   NULL_TREE, TREE_TYPE (gnu_expr), gnu_expr, 1,\n \t\t\t   Is_Public (gnat_entity), ! definition, 0, 0);\n+      annotate_decl_with_node (gnu_decl, gnat_entity);\n       add_decl_stmt (gnu_decl, gnat_entity);\n     }\n \n@@ -4570,7 +4557,7 @@ elaborate_expression_1 (Node_Id gnat_expr,\n   else if (! expr_variable)\n     return gnu_expr;\n   else\n-    return maybe_variable (gnu_expr, gnat_expr);\n+    return maybe_variable (gnu_expr);\n }\n \f\n /* Create a record type that contains a field of TYPE with a starting bit\n@@ -4675,9 +4662,9 @@ make_packable_type (tree type)\n \t\t\t\t     ! DECL_NONADDRESSABLE_P (old_field));\n \n       DECL_INTERNAL_P (new_field) = DECL_INTERNAL_P (old_field);\n-      SET_DECL_ORIGINAL_FIELD (new_field,\n-\t  (DECL_ORIGINAL_FIELD (old_field) != 0\n-\t   ? DECL_ORIGINAL_FIELD (old_field) : old_field));\n+      SET_DECL_ORIGINAL_FIELD\n+\t(new_field, (DECL_ORIGINAL_FIELD (old_field) != 0\n+\t\t     ? DECL_ORIGINAL_FIELD (old_field) : old_field));\n \n       if (TREE_CODE (new_type) == QUAL_UNION_TYPE)\n \tDECL_QUALIFIER (new_field) = DECL_QUALIFIER (old_field);\n@@ -5193,11 +5180,10 @@ gnat_to_gnu_field (Entity_Id gnat_field,\n     gigi_abort (118);\n \n   /* Now create the decl for the field.  */\n-  set_lineno (gnat_field, 0);\n   gnu_field = create_field_decl (gnu_field_id, gnu_field_type, gnu_record_type,\n \t\t\t\t packed, gnu_size, gnu_pos,\n \t\t\t\t Is_Aliased (gnat_field));\n-\n+  annotate_decl_with_node (gnu_field, gnat_field);\n   TREE_THIS_VOLATILE (gnu_field) = Treat_As_Volatile (gnat_field);\n \n   if (Ekind (gnat_field) == E_Discriminant)\n@@ -6201,6 +6187,15 @@ check_ok_for_atomic (tree object, Entity_Id gnat_entity, int comp_p)\n \t\t   gnat_error_point, gnat_entity);\n }\n \f\n+/* Set the DECL_SOURCE_LOCATION of GNU_DECL to the location of\n+   GNAT_NODE.  */\n+\n+static void\n+annotate_decl_with_node (tree gnu_decl, Node_Id gnat_node)\n+{\n+  Sloc_to_locus (Sloc (gnat_node), &DECL_SOURCE_LOCATION (gnu_decl));\n+}\n+\f\n /* Given a type T, a FIELD_DECL F, and a replacement value R,\n    return a new type with all size expressions that contain F\n    updated by replacing F with R.  This is identical to GCC's\n@@ -6231,8 +6226,8 @@ gnat_substitute_in_type (tree t, tree f, tree r)\n \n \t  new = build_range_type (TREE_TYPE (t), low, high);\n \t  if (TYPE_INDEX_TYPE (t))\n-\t    SET_TYPE_INDEX_TYPE (new,\n-\t        gnat_substitute_in_type (TYPE_INDEX_TYPE (t), f, r));\n+\t    SET_TYPE_INDEX_TYPE\n+\t      (new, gnat_substitute_in_type (TYPE_INDEX_TYPE (t), f, r));\n \t  return new;\n \t}\n \n@@ -6351,8 +6346,8 @@ gnat_substitute_in_type (tree t, tree f, tree r)\n \n \t    DECL_CONTEXT (new_field) = new;\n \t    SET_DECL_ORIGINAL_FIELD (new_field,\n-\t       (DECL_ORIGINAL_FIELD (field) != 0\n-\t\t? DECL_ORIGINAL_FIELD (field) : field));\n+\t\t\t\t     (DECL_ORIGINAL_FIELD (field) != 0\n+\t\t\t\t      ? DECL_ORIGINAL_FIELD (field) : field));\n \n \t    /* If the size of the old field was set at a constant,\n \t       propagate the size in case the type's size was variable."}, {"sha": "ae8b401b766da70414b1efb46e0db2a58143c589", "filename": "gcc/ada/gigi.h", "status": "modified", "additions": 32, "deletions": 38, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/821e1ea1b155e9ca33f12e8e7af447042822c66b/gcc%2Fada%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/821e1ea1b155e9ca33f12e8e7af447042822c66b/gcc%2Fada%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgigi.h?ref=821e1ea1b155e9ca33f12e8e7af447042822c66b", "patch": "@@ -36,12 +36,6 @@ extern unsigned int largest_move_alignment;\n \n /* Declare all functions and types used by gigi.  */\n \n-/* Record the current code position in GNAT_NODE.  */\n-extern void record_code_position (Node_Id);\n-\n-/* Insert the code for GNAT_NODE at the position saved for that node.  */\n-extern void insert_code_for (Node_Id);\n-\n /* Compute the alignment of the largest mode that can be used for copying\n    objects.  */\n extern void gnat_compute_largest_alignment (void);\n@@ -50,9 +44,6 @@ extern void gnat_compute_largest_alignment (void);\n    expression that contains the last address on the stack to check. */\n extern tree emit_stack_check (tree);\n \n-/* Make a TRANSFORM_EXPR to later expand GNAT_NODE into code.  */\n-extern tree make_transform_expr (Node_Id);\n-\n /* GNU_TYPE is a type. Determine if it should be passed by reference by\n    default.  */\n extern int default_pass_by_ref (tree);\n@@ -92,6 +83,12 @@ extern tree gnat_to_gnu_type (Entity_Id);\n /* Add GNU_STMT to the current BLOCK_STMT node.  */\n extern void add_stmt (tree);\n \n+/* Similar, but set the location of GNU_STMT to that of GNAT_NODE.  */\n+extern void add_stmt_with_node (tree, Node_Id);\n+\n+/* Set the BLOCK node corresponding to the current code group to GNU_BLOCK.  */\n+extern void set_block_for_group (tree);\n+\n /* Add a declaration statement for GNU_DECL to the current BLOCK_STMT node.\n    Get SLOC from Entity_Id.  */\n extern void add_decl_stmt (tree, Entity_Id);\n@@ -111,7 +108,7 @@ extern tree make_dummy_type (Entity_Id);\n extern tree get_unpadded_type (Entity_Id);\n \n /* Called when we need to protect a variable object using a save_expr.  */\n-extern tree maybe_variable (tree, Node_Id);\n+extern tree maybe_variable (tree);\n \n /* Create a record type that contains a field of TYPE with a starting bit\n    position so that it is aligned to ALIGN bits.  */\n@@ -147,22 +144,14 @@ extern tree get_entity_name (Entity_Id);\n    SUFFIX.  */\n extern tree create_concat_name (Entity_Id, const char *);\n \n-/* Flag indicating whether file names are discarded in exception messages */\n-extern int discard_file_names;\n-\n-/* If true, then gigi is being called on an analyzed but unexpanded\n-   tree, and the only purpose of the call is to properly annotate\n-   types with representation information */\n+/* If true, then gigi is being called on an analyzed but unexpanded tree, and\n+   the only purpose of the call is to properly annotate types with\n+   representation information.  */\n extern int type_annotate_only;\n \n /* Current file name without path */\n extern const char *ref_filename;\n \n-/* List of TREE_LIST nodes representing a block stack.  TREE_VALUE\n-   of each gives the variable used for the setjmp buffer in the current\n-   block, if any.  */\n-extern GTY(()) tree gnu_block_stack;\n-\n /* This is the main program of the back-end.  It sets up all the table\n    structures and then generates code.  */\n \n@@ -171,11 +160,6 @@ extern void gigi (Node_Id, int, int, struct Node *, Node_Id *, Node_Id *,\n \t\t  struct String_Entry *, Char_Code *, struct List_Header *,\n \t\t  Int, char *, Entity_Id, Entity_Id, Entity_Id, Int);\n \n-/* This function is the driver of the GNAT to GCC tree transformation process.\n-   GNAT_NODE is the root of some gnat tree.  It generates code for that\n-   part of the tree.  */\n-extern void gnat_to_code (Node_Id);\n-\n /* GNAT_NODE is the root of some GNAT tree.  Return the root of the\n    GCC tree corresponding to that GNAT tree.  Normally, no code is generated;\n    we just return an equivalent tree which is used elsewhere to generate\n@@ -185,19 +169,23 @@ extern tree gnat_to_gnu (Node_Id);\n /* GNU_STMT is a statement.  We generate code for that statement.  */\n extern void gnat_expand_stmt (tree);\n \n+extern int gnat_gimplify_expr (tree *, tree *, tree *);\n+\n+/* Expand the body of GNU_DECL, which is not a nested function.  */\n+extern void gnat_expand_body (tree);\n+\n /* Do the processing for the declaration of a GNAT_ENTITY, a type.  If\n    a separate Freeze node exists, delay the bulk of the processing.  Otherwise\n    make a GCC type for GNAT_ENTITY and set up the correspondance.  */\n \n extern void process_type (Entity_Id);\n \n-/* Determine the input_filename and the input_line from the source location\n-   (Sloc) of GNAT_NODE node.  Set the global variable input_filename and\n-   input_line.  If WRITE_NOTE_P is true, emit a line number note. */\n-extern void set_lineno (Node_Id, int);\n-\n-/* Likewise, but passed a Sloc.  */\n-extern void set_lineno_from_sloc (Source_Ptr, int);\n+/* Convert Sloc into *LOCUS (a location_t).  Return true if this Sloc\n+   corresponds to a source code location and false if it doesn't.  In the\n+   latter case, we don't update *LOCUS.  We also set the Gigi global variable\n+   REF_FILENAME to the reference file name as given by sinput (i.e no\n+   directory).  */\n+extern bool Sloc_to_locus (Source_Ptr, location_t *);\n \n /* Post an error message.  MSG is the error message, properly annotated.\n    NODE is the node at which to post the error and the node to use for the\n@@ -383,10 +371,15 @@ extern int global_bindings_p (void);\n    is in reverse order (it has to be so for back-end compatibility).  */\n extern tree getdecls (void);\n \n-/* Enter and exit a new binding level. We return the BLOCK node, if any\n-   when we exit a binding level.  */\n+/* Enter and exit a new binding level. */\n extern void gnat_pushlevel (void);\n-extern tree gnat_poplevel (void);\n+extern void gnat_poplevel (void);\n+\n+/* Set the jmpbuf_decl for the current binding level to DECL.  */\n+extern void set_block_jmpbuf_decl (tree);\n+\n+/* Get the setjmp_decl, if any, for the current binding level.  */\n+extern tree get_block_jmpbuf_decl (void);\n \n /* Insert BLOCK at the end of the list of subblocks of the\n    current binding level.  This is used when a BIND_EXPR is expanded,\n@@ -563,8 +556,9 @@ extern tree create_label_decl (tree);\n extern void begin_subprog_body (tree);\n \n /* Finish the definition of the current subprogram and compile it all the way\n-   to assembler language output.  */\n-extern void end_subprog_body (void);\n+   to assembler language output.  BODY is the tree corresponding to\n+   the subprogram.  */\n+extern void end_subprog_body (tree);\n \n /* Build a template of type TEMPLATE_TYPE from the array bounds of ARRAY_TYPE.\n    EXPR is an expression that we can use to locate any PLACEHOLDER_EXPRs."}, {"sha": "0cb890582869a272e8a30711a18ca9af8228a55d", "filename": "gcc/ada/misc.c", "status": "modified", "additions": 36, "deletions": 119, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/821e1ea1b155e9ca33f12e8e7af447042822c66b/gcc%2Fada%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/821e1ea1b155e9ca33f12e8e7af447042822c66b/gcc%2Fada%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmisc.c?ref=821e1ea1b155e9ca33f12e8e7af447042822c66b", "patch": "@@ -48,6 +48,8 @@\n #include \"ggc.h\"\n #include \"flags.h\"\n #include \"debug.h\"\n+#include \"cgraph.h\"\n+#include \"tree-inline.h\"\n #include \"insn-codes.h\"\n #include \"insn-flags.h\"\n #include \"insn-config.h\"\n@@ -84,11 +86,11 @@ extern FILE *asm_out_file;\n    move instruction.  */\n unsigned int largest_move_alignment;\n \n-static size_t gnat_tree_size\t\t(enum tree_code);\n static bool gnat_init\t\t\t(void);\n static void gnat_finish_incomplete_decl\t(tree);\n static unsigned int gnat_init_options\t(unsigned int, const char **);\n static int gnat_handle_option\t\t(size_t, const char *, int);\n+static bool gnat_post_options\t\t(const char **);\n static HOST_WIDE_INT gnat_get_alias_set\t(tree);\n static void gnat_print_decl\t\t(FILE *, tree, int);\n static void gnat_print_type\t\t(FILE *, tree, int);\n@@ -107,14 +109,14 @@ static void gnat_adjust_rli\t\t(record_layout_info);\n #define LANG_HOOKS_NAME\t\t\t\"GNU Ada\"\n #undef  LANG_HOOKS_IDENTIFIER_SIZE\n #define LANG_HOOKS_IDENTIFIER_SIZE\tsizeof (struct tree_identifier)\n-#undef  LANG_HOOKS_TREE_SIZE\n-#define LANG_HOOKS_TREE_SIZE\t\tgnat_tree_size\n #undef  LANG_HOOKS_INIT\n #define LANG_HOOKS_INIT\t\t\tgnat_init\n #undef  LANG_HOOKS_INIT_OPTIONS\n #define LANG_HOOKS_INIT_OPTIONS\t\tgnat_init_options\n #undef  LANG_HOOKS_HANDLE_OPTION\n #define LANG_HOOKS_HANDLE_OPTION\tgnat_handle_option\n+#undef LANG_HOOKS_POST_OPTIONS\n+#define LANG_HOOKS_POST_OPTIONS\t\tgnat_post_options\n #undef LANG_HOOKS_PARSE_FILE\n #define LANG_HOOKS_PARSE_FILE\t\tgnat_parse_file\n #undef LANG_HOOKS_HONOR_READONLY\n@@ -143,6 +145,13 @@ static void gnat_adjust_rli\t\t(record_layout_info);\n #define LANG_HOOKS_PRINT_TYPE\t\tgnat_print_type\n #undef LANG_HOOKS_DECL_PRINTABLE_NAME\n #define LANG_HOOKS_DECL_PRINTABLE_NAME\tgnat_printable_name\n+#undef LANG_HOOKS_CALLGRAPH_EXPAND_FUNCTION\n+#define LANG_HOOKS_CALLGRAPH_EXPAND_FUNCTION gnat_expand_body\n+#undef LANG_HOOKS_RTL_EXPAND_STMT\n+#define LANG_HOOKS_RTL_EXPAND_STMT gnat_expand_stmt\n+#undef LANG_HOOKS_GIMPLIFY_EXPR\n+#define LANG_HOOKS_GIMPLIFY_EXPR gnat_gimplify_expr\n+\n #undef LANG_HOOKS_TYPE_FOR_MODE\n #define LANG_HOOKS_TYPE_FOR_MODE\tgnat_type_for_mode\n #undef LANG_HOOKS_TYPE_FOR_SIZE\n@@ -224,10 +233,11 @@ gnat_parse_file (int set_yydebug ATTRIBUTE_UNUSED)\n   /* Call the front-end elaboration procedures */\n   adainit ();\n \n-  immediate_size_expand = 1;\n-\n   /* Call the front end */\n   _ada_gnat1drv ();\n+\n+  cgraph_finalize_compilation_unit ();\n+  cgraph_optimize ();\n }\n \n /* Decode all the language specific options that cannot be decoded by GCC.\n@@ -332,6 +342,24 @@ gnat_init_options (unsigned int argc, const char **argv)\n   return CL_Ada;\n }\n \n+/* Post-switch processing.  */\n+\n+bool\n+gnat_post_options (const char **pfilename ATTRIBUTE_UNUSED)\n+{\n+  flag_inline_trees = 1;\n+\n+  if (!flag_no_inline)\n+    flag_no_inline = 1;\n+  if (flag_inline_functions)\n+    {\n+      flag_inline_trees = 2;\n+      flag_inline_functions = 0;\n+    }\n+\n+  return false;\n+}\n+\n /* Here is the function to handle the compiler error processing in GCC.  */\n \n static void\n@@ -359,21 +387,6 @@ internal_error_function (const char *msgid, va_list *ap)\n   Compiler_Abort (fp, -1);\n }\n \n-/* Langhook for tree_size: Determine size of our 'x' and 'c' nodes.  */\n-\n-static size_t\n-gnat_tree_size (enum tree_code code)\n-{\n-  switch (code)\n-    {\n-    case GNAT_LOOP_ID:\n-      return sizeof (struct tree_loop_id);\n-    default:\n-      abort ();\n-    }\n-  /* NOTREACHED */\n-}\n-\n /* Perform all the initialization steps that are language-specific.  */\n \n static bool\n@@ -559,15 +572,14 @@ gnat_printable_name (tree decl, int verbosity)\n }\n \n /* Expands GNAT-specific GCC tree nodes.  The only ones we support\n-   here are TRANSFORM_EXPR, ALLOCATE_EXPR, USE_EXPR and NULL_EXPR.  */\n+   here are  and NULL_EXPR.  */\n \n static rtx\n gnat_expand_expr (tree exp, rtx target, enum machine_mode tmode,\n \t\t  int modifier, rtx *alt_rtl)\n {\n   tree type = TREE_TYPE (exp);\n   tree new;\n-  rtx result;\n \n   /* If this is a statement, call the expansion routine for statements.  */\n   if (IS_STMT (exp))\n@@ -579,48 +591,14 @@ gnat_expand_expr (tree exp, rtx target, enum machine_mode tmode,\n   /* Update EXP to be the new expression to expand.  */\n   switch (TREE_CODE (exp))\n     {\n-    case TRANSFORM_EXPR:\n-      gnat_to_code (TREE_COMPLEXITY (exp));\n-      return const0_rtx;\n-      break;\n-\n-    case NULL_EXPR:\n-      expand_expr (TREE_OPERAND (exp, 0), const0_rtx, VOIDmode, 0);\n-\n-      /* We aren't going to be doing anything with this memory, but allocate\n-\t it anyway.  If it's variable size, make a bogus address.  */\n-      if (! host_integerp (TYPE_SIZE_UNIT (type), 1))\n-\tresult = gen_rtx_MEM (BLKmode, virtual_stack_vars_rtx);\n-      else\n-\tresult = assign_temp (type, 0, TREE_ADDRESSABLE (exp), 1);\n-\n-      return result;\n-\n+#if 0\n     case ALLOCATE_EXPR:\n       return\n \tallocate_dynamic_stack_space\n \t  (expand_expr (TREE_OPERAND (exp, 0), NULL_RTX, TYPE_MODE (sizetype),\n \t\t\tEXPAND_NORMAL),\n \t   NULL_RTX, tree_low_cst (TREE_OPERAND (exp, 1), 1));\n-\n-    case USE_EXPR:\n-      if (target != const0_rtx)\n-\tgigi_abort (203);\n-\n-      /* First write a volatile ASM_INPUT to prevent anything from being\n-\t moved.  */\n-      result = gen_rtx_ASM_INPUT (VOIDmode, \"\");\n-      MEM_VOLATILE_P (result) = 1;\n-      emit_insn (result);\n-\n-      result = expand_expr (TREE_OPERAND (exp, 0), NULL_RTX, VOIDmode,\n-\t\t\t    modifier);\n-      emit_insn (gen_rtx_USE (VOIDmode, result));\n-      return target;\n-\n-    case GNAT_NOP_EXPR:\n-      return expand_expr_real (build1 (NOP_EXPR, type, TREE_OPERAND (exp, 0)),\n-\t\t\t       target, tmode, modifier, alt_rtl);\n+#endif\n \n     case UNCONSTRAINED_ARRAY_REF:\n       /* If we are evaluating just for side-effects, just evaluate our\n@@ -667,18 +645,6 @@ gnat_adjust_rli (record_layout_info rli ATTRIBUTE_UNUSED)\n     rli->record_align = record_align;\n #endif\n }\n-\n-/* Make a TRANSFORM_EXPR to later expand GNAT_NODE into code.  */\n-\n-tree\n-make_transform_expr (Node_Id gnat_node)\n-{\n-  tree gnu_result = build (TRANSFORM_EXPR, void_type_node);\n-\n-  TREE_SIDE_EFFECTS (gnu_result) = 1;\n-  TREE_COMPLEXITY (gnu_result) = gnat_node;\n-  return gnu_result;\n-}\n \f\n /* These routines are used in conjunction with GCC exception handling.  */\n \n@@ -704,55 +670,6 @@ gnat_eh_type_covers (tree a, tree b)\n   return (a == b || a == integer_zero_node);\n }\n \f\n-/* Record the current code position in GNAT_NODE.  */\n-\n-void\n-record_code_position (Node_Id gnat_node)\n-{\n-  if (global_bindings_p ())\n-    {\n-      /* Make a dummy entry so multiple things at the same location don't\n-\t end up in the same place.  */\n-      add_pending_elaborations (NULL_TREE, NULL_TREE);\n-      save_gnu_tree (gnat_node, get_elaboration_location (), 1);\n-    }\n-  else\n-    /* Always emit another insn in case marking the last insn\n-       addressable needs some fixups and also for above reason.  */\n-    save_gnu_tree (gnat_node,\n-\t\t   build (RTL_EXPR, void_type_node, NULL_TREE,\n-\t\t\t  (tree) emit_note (NOTE_INSN_DELETED), NULL_TREE),\n-\t\t   1);\n-}\n-\n-/* Insert the code for GNAT_NODE at the position saved for that node.  */\n-\n-void\n-insert_code_for (Node_Id gnat_node)\n-{\n-  if (global_bindings_p ())\n-    {\n-      push_pending_elaborations ();\n-      gnat_to_code (gnat_node);\n-      Check_Elaboration_Code_Allowed (gnat_node);\n-      insert_elaboration_list (get_gnu_tree (gnat_node));\n-      pop_pending_elaborations ();\n-    }\n-  else\n-    {\n-      rtx insns;\n-\n-      do_pending_stack_adjust ();\n-      start_sequence ();\n-      mark_all_temps_used ();\n-      gnat_to_code (gnat_node);\n-      do_pending_stack_adjust ();\n-      insns = get_insns ();\n-      end_sequence ();\n-      emit_insn_after (insns, RTL_EXPR_RTL (get_gnu_tree (gnat_node)));\n-    }\n-}\n-\n /* Get the alias set corresponding to a type or expression.  */\n \n static HOST_WIDE_INT"}, {"sha": "e7a5f9fc89a36bbdf06d53dacd6126582f302f90", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 952, "deletions": 1111, "changes": 2063, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/821e1ea1b155e9ca33f12e8e7af447042822c66b/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/821e1ea1b155e9ca33f12e8e7af447042822c66b/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=821e1ea1b155e9ca33f12e8e7af447042822c66b"}, {"sha": "1b50b71313e94fa5a5256ea64b8356b87c436f2f", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 201, "deletions": 112, "changes": 313, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/821e1ea1b155e9ca33f12e8e7af447042822c66b/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/821e1ea1b155e9ca33f12e8e7af447042822c66b/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=821e1ea1b155e9ca33f12e8e7af447042822c66b", "patch": "@@ -38,6 +38,10 @@\n #include \"convert.h\"\n #include \"target.h\"\n #include \"function.h\"\n+#include \"cgraph.h\"\n+#include \"tree-inline.h\"\n+#include \"tree-gimple.h\"\n+#include \"tree-dump.h\"\n \n #include \"ada.h\"\n #include \"types.h\"\n@@ -101,21 +105,18 @@ static GTY(()) tree signed_and_unsigned_types[2 * MAX_BITS_PER_WORD + 1][2];\n /* Likewise for float types, but record these by mode.  */\n static GTY(()) tree float_types[NUM_MACHINE_MODES];\n \n-/* For each binding contour we allocate a binding_level structure which records\n-   the entities defined or declared in that contour. Contours include:\n-\n-\tthe global one\n-\tone for each subprogram definition\n-\tone for each compound statement (declare block)\n-\n-   Binding contours are used to create GCC tree BLOCK nodes.  */\n+/* For each binding contour we allocate a binding_level structure to indicate\n+   the binding depth.  */\n \n struct ada_binding_level GTY((chain_next (\"%h.chain\")))\n {\n   /* The binding level containing this one (the enclosing binding level). */\n   struct ada_binding_level *chain;\n   /* The BLOCK node for this level.  */\n   tree block;\n+  /* If nonzero, the setjmp buffer that needs to be updated for any\n+     variable-sized definition within this context.  */\n+  tree jmpbuf_decl;\n };\n \n /* The binding level currently in effect.  */\n@@ -132,10 +133,14 @@ struct language_function GTY(())\n   int unused;\n };\n \n+static void gnat_define_builtin (const char *, tree, int, const char *, bool);\n+static void gnat_install_builtins (void);\n static tree merge_sizes (tree, tree, tree, int, int);\n static tree compute_related_constant (tree, tree);\n static tree split_plus (tree, tree *);\n static int value_zerop (tree);\n+static void gnat_gimplify_function (tree);\n+static void gnat_finalize (tree);\n static tree float_type_for_precision (int, enum machine_mode);\n static tree convert_to_fat_pointer (tree, tree);\n static tree convert_to_thin_pointer (tree, tree);\n@@ -254,36 +259,37 @@ gnat_pushlevel ()\n   /* Add this level to the front of the chain (stack) of levels that are\n      active.  */\n   newlevel->chain = current_binding_level;\n+  newlevel->jmpbuf_decl = NULL_TREE;\n   current_binding_level = newlevel;\n }\n \n-/* Exit a binding level.  Return the BLOCK node, if any.  */\n+/* Set the jmpbuf_decl for the current binding level to DECL.  */\n+\n+void\n+set_block_jmpbuf_decl (tree decl)\n+{\n+  current_binding_level->jmpbuf_decl = decl;\n+}\n+\n+/* Get the jmpbuf_decl, if any, for the current binding level.  */\n \n tree\n+get_block_jmpbuf_decl ()\n+{\n+  return current_binding_level->jmpbuf_decl;\n+}\n+\n+/* Exit a binding level. Set any BLOCK into the current code group.  */\n+\n+void\n gnat_poplevel ()\n {\n   struct ada_binding_level *level = current_binding_level;\n   tree block = level->block;\n-  tree decl;\n \n   BLOCK_VARS (block) = nreverse (BLOCK_VARS (block));\n   BLOCK_SUBBLOCKS (block) = nreverse (BLOCK_SUBBLOCKS (block));\n \n-  /* Output any nested inline functions within this block which must be\n-     compiled because their address is needed. */\n-  for (decl =  BLOCK_VARS (block); decl; decl = TREE_CHAIN (decl))\n-    if (TREE_CODE (decl) == FUNCTION_DECL\n-\t&& ! TREE_ASM_WRITTEN (decl) && TREE_ADDRESSABLE (decl)\n-\t&& DECL_INITIAL (decl) != 0)\n-      {\n-\tpush_function_context ();\n-\t/* ??? This is temporary.  */\n-\tggc_push_context ();\n-\toutput_inline_function (decl);\n-\tggc_pop_context ();\n-\tpop_function_context ();\n-      }\n-\n   /* If this is a function-level BLOCK don't do anything.  Otherwise, if there\n      are no variables free the block and merge its subblocks into those of its\n      parent block. Otherwise, add it to the list of its parent.  */\n@@ -296,20 +302,19 @@ gnat_poplevel ()\n \t\t   BLOCK_SUBBLOCKS (level->chain->block));\n       TREE_CHAIN (block) = free_block_chain;\n       free_block_chain = block;\n-      block = NULL_TREE;\n     }\n   else\n     {\n       TREE_CHAIN (block) = BLOCK_SUBBLOCKS (level->chain->block);\n       BLOCK_SUBBLOCKS (level->chain->block) = block;\n       TREE_USED (block) = 1;\n+      set_block_for_group (block);\n     }\n \n   /* Free this binding structure.  */\n   current_binding_level = level->chain;\n   level->chain = free_binding_level;\n   free_binding_level = level;\n-  return block;\n }\n \n /* Insert BLOCK at the end of the list of subblocks of the\n@@ -400,7 +405,8 @@ gnat_init_decl_processing (void)\n      Pmode differ, C will use the width of ptr_mode as sizetype.  But we get\n      far better code using the width of Pmode.  Make this here since we need\n      this before we can expand the GNAT types.  */\n-  set_sizetype (gnat_type_for_size (GET_MODE_BITSIZE (Pmode), 0));\n+  size_type_node = gnat_type_for_size (GET_MODE_BITSIZE (Pmode), 0);\n+  set_sizetype (size_type_node);\n   build_common_tree_nodes_2 (0);\n \n   pushdecl (build_decl (TYPE_DECL, get_identifier (SIZE_TYPE), sizetype));\n@@ -414,8 +420,96 @@ gnat_init_decl_processing (void)\n \n   ptr_void_type_node = build_pointer_type (void_type_node);\n \n+  gnat_install_builtins ();\n+}\n+\n+/* Define a builtin function.  This is temporary and is just being done\n+   to initialize implicit_built_in_decls for the middle-end.  We'll want\n+   to do full builtin processing soon.  */\n+\n+static void\n+gnat_define_builtin (const char *name, tree type,\n+\t\t     int function_code, const char *library_name, bool const_p)\n+{\n+  tree decl = build_decl (FUNCTION_DECL, get_identifier (name), type);\n+\n+  DECL_EXTERNAL (decl) = 1;\n+  TREE_PUBLIC (decl) = 1;\n+  if (library_name)\n+    SET_DECL_ASSEMBLER_NAME (decl, get_identifier (library_name));\n+  make_decl_rtl (decl, NULL);\n+  pushdecl (decl);\n+  DECL_BUILT_IN_CLASS (decl) = BUILT_IN_NORMAL;\n+  DECL_FUNCTION_CODE (decl) = function_code;\n+  TREE_READONLY (decl) = const_p;\n+\n+  implicit_built_in_decls[function_code] = decl;\n }\n \n+/* Install the builtin functions the middle-end needs.  */\n+\n+static void\n+gnat_install_builtins ()\n+{\n+  tree ftype;\n+  tree tmp;\n+\n+  tmp = tree_cons (NULL_TREE, long_integer_type_node, void_list_node);\n+  tmp = tree_cons (NULL_TREE, long_integer_type_node, tmp);\n+  ftype = build_function_type (long_integer_type_node, tmp);\n+  gnat_define_builtin (\"__builtin_expect\", ftype, BUILT_IN_EXPECT,\n+\t\t       \"__builtin_expect\", true);\n+\n+  tmp = tree_cons (NULL_TREE, size_type_node, void_list_node);\n+  tmp = tree_cons (NULL_TREE, ptr_void_type_node, tmp);\n+  tmp = tree_cons (NULL_TREE, ptr_void_type_node, tmp);\n+  ftype = build_function_type (ptr_void_type_node, tmp);\n+  gnat_define_builtin (\"__builtin_memcpy\", ftype, BUILT_IN_MEMCPY,\n+\t\t       \"memcpy\", false);\n+\n+  tmp = tree_cons (NULL_TREE, integer_type_node, void_list_node);\n+  ftype = build_function_type (integer_type_node, tmp);\n+  gnat_define_builtin (\"__builtin_clz\", ftype, BUILT_IN_CLZ, \"clz\", true);\n+\n+  tmp = tree_cons (NULL_TREE, long_integer_type_node, void_list_node);\n+  ftype = build_function_type (integer_type_node, tmp);\n+  gnat_define_builtin (\"__builtin_clzl\", ftype, BUILT_IN_CLZL, \"clzl\", true);\n+\n+  tmp = tree_cons (NULL_TREE, long_long_integer_type_node, void_list_node);\n+  ftype = build_function_type (integer_type_node, tmp);\n+  gnat_define_builtin (\"__builtin_clzll\", ftype, BUILT_IN_CLZLL, \"clzll\",\n+\t\t       true);\n+\n+  tmp = tree_cons (NULL_TREE, ptr_void_type_node, void_list_node);\n+  tmp = tree_cons (NULL_TREE, ptr_void_type_node, tmp);\n+  tmp = tree_cons (NULL_TREE, ptr_void_type_node, tmp);\n+  ftype = build_function_type (void_type_node, tmp);\n+  gnat_define_builtin (\"__builtin_init_trampoline\", ftype,\n+\t\t       BUILT_IN_INIT_TRAMPOLINE, \"init_trampoline\", false);\n+\n+  tmp = tree_cons (NULL_TREE, ptr_void_type_node, void_list_node);\n+  ftype = build_function_type (ptr_void_type_node, tmp);\n+  gnat_define_builtin (\"__builtin_adjust_trampoline\", ftype,\n+\t\t       BUILT_IN_ADJUST_TRAMPOLINE, \"adjust_trampoline\", true);\n+\n+  tmp = tree_cons (NULL_TREE, ptr_void_type_node, void_list_node);\n+  tmp = tree_cons (NULL_TREE, size_type_node, void_list_node);\n+  ftype = build_function_type (ptr_void_type_node, tmp);\n+  gnat_define_builtin (\"__builtin_stack_alloc\", ftype, BUILT_IN_STACK_ALLOC,\n+\t\t       \"stack_alloc\", false);\n+\n+  /* The stack_save and stack_restore builtins aren't used directly.  They\n+     are inserted during gimplification to implement stack_alloc calls.  */\n+  ftype = build_function_type (ptr_void_type_node, void_list_node);\n+  gnat_define_builtin (\"__builtin_stack_save\", ftype, BUILT_IN_STACK_SAVE,\n+\t\t       \"stack_save\", false);\n+  tmp = tree_cons (NULL_TREE, ptr_void_type_node, void_list_node);\n+  ftype = build_function_type (void_type_node, tmp);\n+  gnat_define_builtin (\"__builtin_stack_restore\", ftype,\n+\t\t       BUILT_IN_STACK_RESTORE, \"stack_restore\", false);\n+}\n+\n+\n /* Create the predefined scalar types such as `integer_type_node' needed\n    in the gcc back-end and initialize the global binding level.  */\n \n@@ -1229,13 +1323,11 @@ create_var_decl (tree var_name, tree asm_name, tree type, tree var_init,\n \t\t  ? CONST_DECL : VAR_DECL, var_name, type);\n \n   /* If this is external, throw away any initializations unless this is a\n-     CONST_DECL (meaning we have a constant); they will be done elsewhere.  If\n-     we are defining a global here, leave a constant initialization and save\n-     any variable elaborations for the elaboration routine.  Otherwise, if\n-     the initializing expression is not the same as TYPE, generate the\n-     initialization with an assignment statement, since it knows how\n-     to do the required adjustents.  If we are just annotating types,\n-     throw away the initialization if it isn't a constant.  */\n+     CONST_DECL (meaning we have a constant); they will be done elsewhere.\n+     If we are defining a global here, leave a constant initialization and\n+     save any variable elaborations for the elaboration routine.  If we are\n+     just annotating types, throw away the initialization if it isn't a\n+     constant.  */\n \n   if ((extern_flag && TREE_CODE (var_decl) != CONST_DECL)\n       || (type_annotate_only && var_init != 0 && ! TREE_CONSTANT (var_init)))\n@@ -1247,12 +1339,6 @@ create_var_decl (tree var_name, tree asm_name, tree type, tree var_init,\n       var_init = 0;\n     }\n \n-  else if (var_init != 0\n-\t   && ((TYPE_MAIN_VARIANT (TREE_TYPE (var_init))\n-\t\t!= TYPE_MAIN_VARIANT (type))\n-\t       || (static_flag && ! init_const)))\n-    DECL_INIT_BY_ASSIGN_P (var_decl) = 1;\n-\n   DECL_INITIAL  (var_decl) = var_init;\n   TREE_READONLY (var_decl) = const_flag;\n   DECL_EXTERNAL (var_decl) = extern_flag;\n@@ -1703,13 +1789,16 @@ create_subprog_decl (tree subprog_name,\n \n   DECL_EXTERNAL (subprog_decl)  = extern_flag;\n   TREE_PUBLIC (subprog_decl)    = public_flag;\n-  DECL_INLINE (subprog_decl)    = inline_flag;\n+  TREE_STATIC (subprog_decl)\t= 1;\n   TREE_READONLY (subprog_decl)  = TYPE_READONLY (subprog_type);\n   TREE_THIS_VOLATILE (subprog_decl) = TYPE_VOLATILE (subprog_type);\n   TREE_SIDE_EFFECTS (subprog_decl) = TYPE_VOLATILE (subprog_type);\n   DECL_ARGUMENTS (subprog_decl) = param_decl_list;\n   DECL_RESULT (subprog_decl)    = build_decl (RESULT_DECL, 0, return_type);\n \n+  if (inline_flag)\n+    DECL_DECLARED_INLINE_P (subprog_decl) = 1;\n+\n   if (asm_name != 0)\n     SET_DECL_ASSEMBLER_NAME (subprog_decl, asm_name);\n \n@@ -1763,95 +1852,93 @@ begin_subprog_body (tree subprog_decl)\n \n   init_function_start (subprog_decl);\n   expand_function_start (subprog_decl, 0);\n-\n-  /* If this function is `main', emit a call to `__main'\n-     to run global initializers, etc.  */\n-  if (DECL_ASSEMBLER_NAME (subprog_decl) != 0\n-      && MAIN_NAME_P (DECL_ASSEMBLER_NAME (subprog_decl))\n-      && DECL_CONTEXT (subprog_decl) == NULL_TREE)\n-    expand_main_function ();\n }\n \n /* Finish the definition of the current subprogram and compile it all the way\n-   to assembler language output.  */\n+   to assembler language output.  BODY is the tree corresponding to\n+   the subprogram.  */\n \n void\n-end_subprog_body (void)\n+end_subprog_body (tree body)\n {\n-  tree decl;\n-  tree cico_list;\n+  tree fndecl = current_function_decl;\n \n   /* Mark the BLOCK for this level as being for this function and pop the\n      level.  Since the vars in it are the parameters, clear them.  */\n   BLOCK_VARS (current_binding_level->block) = 0;\n-  BLOCK_SUPERCONTEXT (current_binding_level->block) = current_function_decl;\n-  DECL_INITIAL (current_function_decl) = current_binding_level->block;\n+  BLOCK_SUPERCONTEXT (current_binding_level->block) = fndecl;\n+  DECL_INITIAL (fndecl) = current_binding_level->block;\n   gnat_poplevel ();\n \n+  /* Deal with inline.  If declared inline or we should default to inline,\n+     set the flag in the decl.  */\n+  DECL_INLINE (fndecl)\n+    = DECL_DECLARED_INLINE_P (fndecl) || flag_inline_trees == 2;\n+\n+  /* Initialize the RTL code for the function.  */\n+  allocate_struct_function (fndecl);\n+\n+  /* We handle pending sizes via the elaboration of types, so we don't\n+     need to save them.  */\n+  get_pending_sizes ();\n+\n   /* Mark the RESULT_DECL as being in this subprogram. */\n-  DECL_CONTEXT (DECL_RESULT (current_function_decl)) = current_function_decl;\n+  DECL_CONTEXT (DECL_RESULT (fndecl)) = fndecl;\n \n-  expand_function_end ();\n+  DECL_SAVED_TREE (fndecl) = body;\n \n-  /* If this is a nested function, push a new GC context.  That will keep\n-     local variables on the stack from being collected while we're doing\n-     the compilation of this function.  */\n-  if (function_nesting_depth > 1)\n-    ggc_push_context ();\n+  current_function_decl = DECL_CONTEXT (fndecl);\n \n-  /* If we're only annotating types, don't actually compile this\n-     function.  */\n-  if (!type_annotate_only)\n+  /* If we're only annotating types, don't actually compile this function.  */\n+  if (type_annotate_only)\n+    return;\n+\n+  /* We do different things for nested and non-nested functions.\n+     ??? This should be in cgraph.  */\n+  if (!DECL_CONTEXT (fndecl))\n     {\n-      rest_of_compilation (current_function_decl);\n-      if (! DECL_DEFER_OUTPUT (current_function_decl))\n-\t{\n-\t  free_after_compilation (cfun);\n-\t  DECL_STRUCT_FUNCTION (current_function_decl) = 0;\n-\t}\n-      cfun = 0;\n+      gnat_gimplify_function (fndecl);\n+      lower_nested_functions (fndecl);\n+      gnat_finalize (fndecl);\n     }\n+  else\n+    /* Register this function with cgraph just far enough to get it\n+       added to our parent's nested function list.  */\n+    (void) cgraph_node (fndecl);\n+}\n \n-  if (function_nesting_depth > 1)\n-    ggc_pop_context ();\n-\n-  /* Throw away any VAR_DECLs we made for OUT parameters; they must\n-     not be seen when we call this function and will be in\n-     unallocated memory anyway.  */\n-  for (cico_list = TYPE_CI_CO_LIST (TREE_TYPE (current_function_decl));\n-       cico_list != 0; cico_list = TREE_CHAIN (cico_list))\n-    TREE_VALUE (cico_list) = 0;\n+/* Convert FNDECL's code to GIMPLE and handle any nested functions.  */\n \n-  if (DECL_STRUCT_FUNCTION (current_function_decl) == 0)\n-    {\n-      /* Throw away DECL_RTL in any PARM_DECLs unless this function\n-\t was saved for inline, in which case the DECL_RTLs are in\n-\t preserved memory.  */\n-      for (decl = DECL_ARGUMENTS (current_function_decl);\n-\t   decl != 0; decl = TREE_CHAIN (decl))\n-\t{\n-\t  SET_DECL_RTL (decl, 0);\n-\t  DECL_INCOMING_RTL (decl) = 0;\n-\t}\n+static void\n+gnat_gimplify_function (tree fndecl)\n+{\n+  struct cgraph_node *cgn;\n+\n+  dump_function (TDI_original, fndecl);\n+  gimplify_function_tree (fndecl);\n+  dump_function (TDI_generic, fndecl);\n+\n+  /* Convert all nested functions to GIMPLE now.  We do things in this order\n+     so that items like VLA sizes are expanded properly in the context of the\n+     correct function.  */\n+  cgn = cgraph_node (fndecl);\n+  for (cgn = cgn->nested; cgn ; cgn = cgn->next_nested)\n+    gnat_gimplify_function (cgn->decl);\n+}\n \n-      /* Similarly, discard DECL_RTL of the return value.  */\n-      SET_DECL_RTL (DECL_RESULT (current_function_decl), 0);\n+/* Give FNDECL and all its nested functions to cgraph for compilation.  */\n \n-      /* But DECL_INITIAL must remain nonzero so we know this\n-\t was an actual function definition unless toplev.c decided not\n-\t to inline it.  */\n-      if (DECL_INITIAL (current_function_decl) != 0)\n-\tDECL_INITIAL (current_function_decl) = error_mark_node;\n+static void\n+gnat_finalize (tree fndecl)\n+{\n+  struct cgraph_node *cgn;\n \n-      DECL_ARGUMENTS (current_function_decl) = 0;\n-    }\n+  /* Finalize all nested functions now.  */\n+  cgn = cgraph_node (fndecl);\n+  for (cgn = cgn->nested; cgn ; cgn = cgn->next_nested)\n+    gnat_finalize (cgn->decl);\n \n-  /* If we are not at the bottom of the function nesting stack, pop up to\n-     the containing function.  Otherwise show we aren't in any function.  */\n-  if (--function_nesting_depth != 0)\n-    pop_function_context ();\n-  else\n-    current_function_decl = 0;\n+  cgraph_finalize_function (fndecl, false);\n }\n \f\n /* Return a definition for a builtin function named NAME and whose data type\n@@ -2824,7 +2911,7 @@ convert (tree type, tree expr)\n   /* If the input is a biased type, adjust first.  */\n   if (ecode == INTEGER_TYPE && TYPE_BIASED_REPRESENTATION_P (etype))\n     return convert (type, fold (build (PLUS_EXPR, TREE_TYPE (etype),\n-\t\t\t\t       fold (build1 (GNAT_NOP_EXPR,\n+\t\t\t\t       fold (build1 (NOP_EXPR,\n \t\t\t\t\t\t     TREE_TYPE (etype), expr)),\n \t\t\t\t       TYPE_MIN_VALUE (etype))));\n \n@@ -2864,7 +2951,6 @@ convert (tree type, tree expr)\n     case ERROR_MARK:\n       return expr;\n \n-    case TRANSFORM_EXPR:\n     case NULL_EXPR:\n       /* Just set its type here.  For TRANSFORM_EXPR, we will do the actual\n \t conversion in gnat_expand_expr.  NULL_EXPR does not represent\n@@ -2959,6 +3045,9 @@ convert (tree type, tree expr)\n     case VOID_TYPE:\n       return build1 (CONVERT_EXPR, type, expr);\n \n+    case BOOLEAN_TYPE:\n+      return fold (build1 (NOP_EXPR, type, gnat_truthvalue_conversion (expr)));\n+\n     case INTEGER_TYPE:\n       if (TYPE_HAS_ACTUAL_BOUNDS_P (type)\n \t  && (ecode == ARRAY_TYPE || ecode == UNCONSTRAINED_ARRAY_TYPE\n@@ -3106,7 +3195,7 @@ remove_conversions (tree exp, int true_address)\n       break;\n \n     case VIEW_CONVERT_EXPR:  case NON_LVALUE_EXPR:\n-    case NOP_EXPR:  case CONVERT_EXPR:  case GNAT_NOP_EXPR:\n+    case NOP_EXPR:  case CONVERT_EXPR:\n       return remove_conversions (TREE_OPERAND (exp, 0), true_address);\n \n     default:\n@@ -3209,7 +3298,7 @@ unchecked_convert (tree type, tree expr, int notrunc_p)\n \n \t  TYPE_BIASED_REPRESENTATION_P (ntype) = 0;\n \t  TYPE_MAIN_VARIANT (ntype) = ntype;\n-\t  expr = build1 (GNAT_NOP_EXPR, ntype, expr);\n+\t  expr = build1 (NOP_EXPR, ntype, expr);\n \t}\n \n       if (TREE_CODE (type) == INTEGER_TYPE\n@@ -3222,7 +3311,7 @@ unchecked_convert (tree type, tree expr, int notrunc_p)\n \n       expr = convert (rtype, expr);\n       if (type != rtype)\n-\texpr = build1 (GNAT_NOP_EXPR, type, expr);\n+\texpr = build1 (NOP_EXPR, type, expr);\n     }\n \n   /* If we are converting TO an integral type whose precision is not the"}, {"sha": "ed9953103c0b225d12046a0a08c68c90569d5376", "filename": "gcc/ada/utils2.c", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/821e1ea1b155e9ca33f12e8e7af447042822c66b/gcc%2Fada%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/821e1ea1b155e9ca33f12e8e7af447042822c66b/gcc%2Fada%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils2.c?ref=821e1ea1b155e9ca33f12e8e7af447042822c66b", "patch": "@@ -29,6 +29,7 @@\n #include \"coretypes.h\"\n #include \"tm.h\"\n #include \"tree.h\"\n+#include \"rtl.h\"\n #include \"flags.h\"\n #include \"output.h\"\n #include \"ada.h\"\n@@ -1345,23 +1346,20 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n /* Similar, but for COND_EXPR.  */\n \n tree\n-build_cond_expr (tree result_type,\n-                 tree condition_operand,\n-                 tree true_operand,\n-                 tree false_operand)\n+build_cond_expr (tree result_type, tree condition_operand,\n+                 tree true_operand, tree false_operand)\n {\n   tree result;\n   int addr_p = 0;\n \n-  /* Front-end verifies that result, true and false operands have same base\n-     type. Convert everything to the result type.  */\n+  /* The front-end verifies that result, true and false operands have same base\n+     type.  Convert everything to the result type.  */\n \n   true_operand  = convert (result_type, true_operand);\n   false_operand = convert (result_type, false_operand);\n \n   /* If the result type is unconstrained, take the address of\n      the operands and then dereference our result.  */\n-\n   if (TREE_CODE (result_type) == UNCONSTRAINED_ARRAY_TYPE\n       || CONTAINS_PLACEHOLDER_P (TYPE_SIZE (result_type)))\n     {\n@@ -1450,7 +1448,7 @@ tree\n build_call_raise (int msg)\n {\n   tree fndecl = gnat_raise_decls[msg];\n-  const char *str = discard_file_names ? \"\" : ref_filename;\n+  const char *str = Debug_Flag_NN ? \"\" : ref_filename;\n   int len = strlen (str) + 1;\n   tree filename = build_string (len, str);\n \n@@ -1743,7 +1741,11 @@ build_call_alloc_dealloc (tree gnu_obj, tree gnu_size, unsigned align,\n \n   else if (gnu_obj)\n     return build_call_1_expr (free_decl, gnu_obj);\n-  else if (gnat_pool == -1)\n+\n+  /* ??? For now, disable variable-sized allocators in the stack since\n+     we can't yet gimplify an ALLOCATE_EXPR.  */\n+  else if (gnat_pool == -1\n+\t   && TREE_CODE (gnu_size) == INTEGER_CST && !flag_stack_check)\n     {\n       /* If the size is a constant, we can put it in the fixed portion of\n \t the stack frame to avoid the need to adjust the stack pointer.  */\n@@ -1760,7 +1762,10 @@ build_call_alloc_dealloc (tree gnu_obj, tree gnu_size, unsigned align,\n \t\t\t  build_unary_op (ADDR_EXPR, NULL_TREE, gnu_decl));\n \t}\n       else\n+\tabort ();\n+#if 0\n \treturn build (ALLOCATE_EXPR, ptr_void_type_node, gnu_size, gnu_align);\n+#endif\n     }\n   else\n     {\n@@ -1977,7 +1982,6 @@ gnat_mark_addressable (tree expr_node)\n       case VIEW_CONVERT_EXPR:\n       case CONVERT_EXPR:\n       case NON_LVALUE_EXPR:\n-      case GNAT_NOP_EXPR:\n       case NOP_EXPR:\n \texpr_node = TREE_OPERAND (expr_node, 0);\n \tbreak;\n@@ -1989,7 +1993,19 @@ gnat_mark_addressable (tree expr_node)\n       case VAR_DECL:\n       case PARM_DECL:\n       case RESULT_DECL:\n-\tput_var_into_stack (expr_node, true);\n+\t/* If we have already made a REG for this decl, we must put it\n+\t   directly into the stack.  Likewise for a MEM whose address is a\n+\t   pseudo.  Otherwise, set a flag to mark us to do it later.  */\n+\tif (DECL_RTL_SET_P (expr_node)\n+\t    && (GET_CODE (DECL_RTL (expr_node)) == REG\n+\t\t|| (GET_CODE (DECL_RTL (expr_node)) == MEM\n+\t\t    && GET_CODE (XEXP (DECL_RTL (expr_node), 0)) == REG\n+\t\t    && (REGNO (XEXP (DECL_RTL (expr_node), 0))\n+\t\t\t> LAST_VIRTUAL_REGISTER))))\n+\t  put_var_into_stack (expr_node, 1);\n+\telse\n+\t  TREE_ADDRESSABLE (expr_node) = 1;\n+\n \treturn true;\n \n       case FUNCTION_DECL:"}]}