{"sha": "0799a08b5c6a2087de9512252be6d9192e92395a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDc5OWEwOGI1YzZhMjA4N2RlOTUxMjI1MmJlNmQ5MTkyZTkyMzk1YQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-10-18T22:55:34Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-10-18T22:55:34Z"}, "message": "compiler: rewrite Type::are_identical to use flags\n    \n    A single flags parameter replaces the Cmp_tags and errors_are_identical\n    parameters. The existing behavior is unchanged.\n    \n    This is a simplification step for future work that will add a new flag.\n    \n    Reviewed-on: https://go-review.googlesource.com/c/143019\n\nFrom-SVN: r265293", "tree": {"sha": "00e9825d1ae11f944557824d0b88eac6162f48dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/00e9825d1ae11f944557824d0b88eac6162f48dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0799a08b5c6a2087de9512252be6d9192e92395a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0799a08b5c6a2087de9512252be6d9192e92395a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0799a08b5c6a2087de9512252be6d9192e92395a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0799a08b5c6a2087de9512252be6d9192e92395a/comments", "author": null, "committer": null, "parents": [{"sha": "28dd75a330e7cc929a6be489ea3c252dd4a8bd8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28dd75a330e7cc929a6be489ea3c252dd4a8bd8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28dd75a330e7cc929a6be489ea3c252dd4a8bd8a"}], "stats": {"total": 354, "additions": 173, "deletions": 181}, "files": [{"sha": "a2cf0af0634e4105e85ef4add09de6099d55a82a", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0799a08b5c6a2087de9512252be6d9192e92395a/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0799a08b5c6a2087de9512252be6d9192e92395a/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=0799a08b5c6a2087de9512252be6d9192e92395a", "patch": "@@ -1,4 +1,4 @@\n-0494dc5737f0c89ad6f45e04e8313e4161678861\n+84531ef21230307773daa438a50bf095edcdbf93\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "eb23c2dc4a0c21b7eacaf119216dc19d799edf2a", "filename": "gcc/go/gofrontend/escape.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0799a08b5c6a2087de9512252be6d9192e92395a/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0799a08b5c6a2087de9512252be6d9192e92395a/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fescape.cc?ref=0799a08b5c6a2087de9512252be6d9192e92395a", "patch": "@@ -2077,7 +2077,8 @@ Escape_analysis_assign::call(Call_expression* call)\n       else\n \t{\n \t  if (!Type::are_identical(fntype->receiver()->type(),\n-\t\t\t       (*p)->expr()->type(), true, NULL))\n+\t\t\t\t   (*p)->expr()->type(), Type::COMPARE_TAGS,\n+\t\t\t\t   NULL))\n \t    {\n \t      // This will be converted later, preemptively track it instead\n \t      // of its conversion expression which will show up in a later pass.\n@@ -2096,7 +2097,7 @@ Escape_analysis_assign::call(Call_expression* call)\n \t   ++pn, ++p)\n \t{\n \t  if (!Type::are_identical(pn->type(), (*p)->expr()->type(),\n-\t\t\t\t   true, NULL))\n+\t\t\t\t   Type::COMPARE_TAGS, NULL))\n \t    {\n \t      // This will be converted later, preemptively track it instead\n \t      // of its conversion expression which will show up in a later pass."}, {"sha": "0a6910ac87972a00d95f258efd08cf3524894508", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 35, "deletions": 13, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0799a08b5c6a2087de9512252be6d9192e92395a/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0799a08b5c6a2087de9512252be6d9192e92395a/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=0799a08b5c6a2087de9512252be6d9192e92395a", "patch": "@@ -178,7 +178,10 @@ Expression::convert_for_assignment(Gogo*, Type* lhs_type,\n       || rhs->is_error_expression())\n     return Expression::make_error(location);\n \n-  bool are_identical = Type::are_identical(lhs_type, rhs_type, false, NULL);\n+  bool are_identical = Type::are_identical(lhs_type, rhs_type,\n+\t\t\t\t\t   (Type::COMPARE_ERRORS\n+\t\t\t\t\t    | Type::COMPARE_TAGS),\n+\t\t\t\t\t   NULL);\n   if (!are_identical && lhs_type->interface_type() != NULL)\n     {\n       if (rhs_type->interface_type() == NULL)\n@@ -341,7 +344,9 @@ Expression::convert_interface_to_interface(Type *lhs_type, Expression* rhs,\n                                            bool for_type_guard,\n                                            Location location)\n {\n-  if (Type::are_identical(lhs_type, rhs->type(), false, NULL))\n+  if (Type::are_identical(lhs_type, rhs->type(),\n+\t\t\t  Type::COMPARE_ERRORS | Type::COMPARE_TAGS,\n+\t\t\t  NULL))\n     return rhs;\n \n   Interface_type* lhs_interface_type = lhs_type->interface_type();\n@@ -3389,7 +3394,9 @@ Type_conversion_expression::do_is_static_initializer() const\n   if (!this->expr_->is_static_initializer())\n     return false;\n \n-  if (Type::are_identical(type, expr_type, false, NULL))\n+  if (Type::are_identical(type, expr_type,\n+\t\t\t  Type::COMPARE_ERRORS | Type::COMPARE_TAGS,\n+\t\t\t  NULL))\n     return true;\n \n   if (type->is_string_type() && expr_type->is_string_type())\n@@ -3503,7 +3510,9 @@ Type_conversion_expression::do_get_backend(Translate_context* context)\n   Btype* btype = type->get_backend(gogo);\n   Location loc = this->location();\n \n-  if (Type::are_identical(type, expr_type, false, NULL))\n+  if (Type::are_identical(type, expr_type,\n+\t\t\t  Type::COMPARE_ERRORS | Type::COMPARE_TAGS,\n+\t\t\t  NULL))\n     {\n       Bexpression* bexpr = this->expr_->get_backend(context);\n       return gogo->backend()->convert_expression(btype, bexpr, loc);\n@@ -5433,7 +5442,10 @@ Binary_expression::lower_struct_comparison(Gogo* gogo,\n   Struct_type* st2 = this->right_->type()->struct_type();\n   if (st2 == NULL)\n     return this;\n-  if (st != st2 && !Type::are_identical(st, st2, false, NULL))\n+  if (st != st2\n+      && !Type::are_identical(st, st2,\n+\t\t\t      Type::COMPARE_ERRORS | Type::COMPARE_TAGS,\n+\t\t\t      NULL))\n     return this;\n   if (!Type::are_compatible_for_comparison(true, this->left_->type(),\n \t\t\t\t\t   this->right_->type(), NULL))\n@@ -5512,7 +5524,10 @@ Binary_expression::lower_array_comparison(Gogo* gogo,\n   Array_type* at2 = this->right_->type()->array_type();\n   if (at2 == NULL)\n     return this;\n-  if (at != at2 && !Type::are_identical(at, at2, false, NULL))\n+  if (at != at2\n+      && !Type::are_identical(at, at2,\n+\t\t\t      Type::COMPARE_ERRORS | Type::COMPARE_TAGS,\n+\t\t\t      NULL))\n     return this;\n   if (!Type::are_compatible_for_comparison(true, this->left_->type(),\n \t\t\t\t\t   this->right_->type(), NULL))\n@@ -6902,7 +6917,7 @@ Bound_method_expression::do_check_types(Gogo*)\n \t\t ? this->expr_type_\n \t\t : this->expr_->type());\n   etype = etype->deref();\n-  if (!Type::are_identical(rtype, etype, true, NULL))\n+  if (!Type::are_identical(rtype, etype, Type::COMPARE_TAGS, NULL))\n     this->report_error(_(\"method type does not match object type\"));\n }\n \n@@ -8404,7 +8419,9 @@ Builtin_call_expression::do_numeric_constant_value(Numeric_constant* nc) const\n \t  && !rnc.type()->is_abstract()\n \t  && inc.type() != NULL\n \t  && !inc.type()->is_abstract()\n-\t  && !Type::are_identical(rnc.type(), inc.type(), false, NULL))\n+\t  && !Type::are_identical(rnc.type(), inc.type(),\n+\t\t\t\t  Type::COMPARE_ERRORS | Type::COMPARE_TAGS,\n+\t\t\t\t  NULL))\n \treturn false;\n \n       mpfr_t r;\n@@ -8885,7 +8902,7 @@ Builtin_call_expression::do_check_types(Gogo*)\n \tif (arg2_type->is_slice_type())\n \t  {\n \t    Type* e2 = arg2_type->array_type()->element_type();\n-\t    if (!Type::are_identical(e1, e2, true, NULL))\n+\t    if (!Type::are_identical(e1, e2, Type::COMPARE_TAGS, NULL))\n \t      this->report_error(_(\"element types must be the same\"));\n \t  }\n \telse if (arg2_type->is_string_type())\n@@ -9023,7 +9040,8 @@ Builtin_call_expression::do_check_types(Gogo*)\n \t\t || args->back()->type()->is_error())\n \t  this->set_is_error();\n \telse if (!Type::are_identical(args->front()->type(),\n-\t\t\t\t      args->back()->type(), true, NULL))\n+\t\t\t\t      args->back()->type(),\n+\t\t\t\t      Type::COMPARE_TAGS, NULL))\n \t  this->report_error(_(\"complex arguments must have identical types\"));\n \telse if (args->front()->type()->float_type() == NULL)\n \t  this->report_error(_(\"complex arguments must have \"\n@@ -9935,7 +9953,8 @@ Call_expression::do_flatten(Gogo* gogo, Named_object*,\n       for (; pa != this->args_->end(); ++pa, ++pp)\n \t{\n \t  go_assert(pp != fntype->parameters()->end());\n-\t  if (Type::are_identical(pp->type(), (*pa)->type(), true, NULL))\n+\t  if (Type::are_identical(pp->type(), (*pa)->type(),\n+\t\t\t\t  Type::COMPARE_TAGS, NULL))\n \t    args->push_back(*pa);\n \t  else\n \t    {\n@@ -11630,7 +11649,9 @@ Map_index_expression::do_flatten(Gogo* gogo, Named_object*,\n       return Expression::make_error(loc);\n     }\n \n-  if (!Type::are_identical(mt->key_type(), this->index_->type(), false, NULL))\n+  if (!Type::are_identical(mt->key_type(), this->index_->type(),\n+\t\t\t   Type::COMPARE_ERRORS | Type::COMPARE_TAGS,\n+\t\t\t   NULL))\n     {\n       if (this->index_->type()->interface_type() != NULL\n \t  && !this->index_->is_variable())\n@@ -15948,7 +15969,8 @@ Type*\n Conditional_expression::do_type()\n {\n   Type* result_type = Type::make_void_type();\n-  if (Type::are_identical(this->then_->type(), this->else_->type(), false,\n+  if (Type::are_identical(this->then_->type(), this->else_->type(),\n+\t\t\t  Type::COMPARE_ERRORS | Type::COMPARE_TAGS,\n                           NULL))\n     result_type = this->then_->type();\n   else if (this->then_->is_nil_expression()"}, {"sha": "bfbf682fc113ef35ccf87ebf599af9c000a9c4b2", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0799a08b5c6a2087de9512252be6d9192e92395a/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0799a08b5c6a2087de9512252be6d9192e92395a/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=0799a08b5c6a2087de9512252be6d9192e92395a", "patch": "@@ -6492,7 +6492,8 @@ Variable::flatten_init_expression(Gogo* gogo, Named_object* function,\n       // If an interface conversion is needed, we need a temporary\n       // variable.\n       if (this->type_ != NULL\n-\t  && !Type::are_identical(this->type_, this->init_->type(), false,\n+\t  && !Type::are_identical(this->type_, this->init_->type(),\n+\t\t\t\t  Type::COMPARE_ERRORS | Type::COMPARE_TAGS,\n \t\t\t\t  NULL)\n \t  && this->init_->type()->interface_type() != NULL\n \t  && !this->init_->is_variable())"}, {"sha": "c35002df13ce4e7bf5f94614d1120e0517d3633e", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0799a08b5c6a2087de9512252be6d9192e92395a/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0799a08b5c6a2087de9512252be6d9192e92395a/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=0799a08b5c6a2087de9512252be6d9192e92395a", "patch": "@@ -472,7 +472,9 @@ Temporary_statement::do_flatten(Gogo*, Named_object*, Block*,\n \n   if (this->type_ != NULL\n       && this->init_ != NULL\n-      && !Type::are_identical(this->type_, this->init_->type(), false, NULL)\n+      && !Type::are_identical(this->type_, this->init_->type(),\n+\t\t\t      Type::COMPARE_ERRORS | Type::COMPARE_TAGS,\n+\t\t\t      NULL)\n       && this->init_->type()->interface_type() != NULL\n       && !this->init_->is_variable())\n     {\n@@ -841,7 +843,8 @@ Assignment_statement::do_flatten(Gogo*, Named_object*, Block*,\n \n   if (!this->lhs_->is_sink_expression()\n       && !Type::are_identical(this->lhs_->type(), this->rhs_->type(),\n-\t\t\t      false, NULL)\n+\t\t\t      Type::COMPARE_ERRORS | Type::COMPARE_TAGS,\n+\t\t\t      NULL)\n       && this->rhs_->type()->interface_type() != NULL\n       && !this->rhs_->is_variable())\n     {\n@@ -4384,7 +4387,9 @@ Send_statement::do_flatten(Gogo*, Named_object*, Block*,\n     }\n \n   Type* element_type = this->channel_->type()->channel_type()->element_type();\n-  if (!Type::are_identical(element_type, this->val_->type(), false, NULL)\n+  if (!Type::are_identical(element_type, this->val_->type(),\n+\t\t\t   Type::COMPARE_ERRORS | Type::COMPARE_TAGS,\n+\t\t\t   NULL)\n       && this->val_->type()->interface_type() != NULL\n       && !this->val_->is_variable())\n     {"}, {"sha": "bb90e92716a772e910dbfaf1eecff2eb2e0903d9", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 74, "deletions": 109, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0799a08b5c6a2087de9512252be6d9192e92395a/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0799a08b5c6a2087de9512252be6d9192e92395a/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=0799a08b5c6a2087de9512252be6d9192e92395a", "patch": "@@ -336,29 +336,17 @@ Type::do_traverse(Traverse*)\n   return TRAVERSE_CONTINUE;\n }\n \n-// Return whether two types are identical.  If ERRORS_ARE_IDENTICAL,\n-// then return true for all erroneous types; this is used to avoid\n-// cascading errors.  If REASON is not NULL, optionally set *REASON to\n-// the reason the types are not identical.\n+// Return whether two types are identical.  If REASON is not NULL,\n+// optionally set *REASON to the reason the types are not identical.\n \n bool\n-Type::are_identical(const Type* t1, const Type* t2, bool errors_are_identical,\n+Type::are_identical(const Type* t1, const Type* t2, int flags,\n \t\t    std::string* reason)\n-{\n-  return Type::are_identical_cmp_tags(t1, t2, COMPARE_TAGS,\n-\t\t\t\t      errors_are_identical, reason);\n-}\n-\n-// Like are_identical, but with a CMP_TAGS parameter.\n-\n-bool\n-Type::are_identical_cmp_tags(const Type* t1, const Type* t2, Cmp_tags cmp_tags,\n-\t\t\t     bool errors_are_identical, std::string* reason)\n {\n   if (t1 == NULL || t2 == NULL)\n     {\n       // Something is wrong.\n-      return errors_are_identical ? true : t1 == t2;\n+      return (flags & COMPARE_ERRORS) == 0 ? true : t1 == t2;\n     }\n \n   // Skip defined forward declarations.  Ignore aliases.\n@@ -371,12 +359,12 @@ Type::are_identical_cmp_tags(const Type* t1, const Type* t2, Cmp_tags cmp_tags,\n   // An undefined forward declaration is an error.\n   if (t1->forward_declaration_type() != NULL\n       || t2->forward_declaration_type() != NULL)\n-    return errors_are_identical;\n+    return (flags & COMPARE_ERRORS) == 0;\n \n   // Avoid cascading errors with error types.\n   if (t1->is_error_type() || t2->is_error_type())\n     {\n-      if (errors_are_identical)\n+      if ((flags & COMPARE_ERRORS) == 0)\n \treturn true;\n       return t1->is_error_type() && t2->is_error_type();\n     }\n@@ -418,35 +406,26 @@ Type::are_identical_cmp_tags(const Type* t1, const Type* t2, Cmp_tags cmp_tags,\n \n     case TYPE_FUNCTION:\n       return t1->function_type()->is_identical(t2->function_type(),\n-\t\t\t\t\t       false,\n-\t\t\t\t\t       cmp_tags,\n-\t\t\t\t\t       errors_are_identical,\n-\t\t\t\t\t       reason);\n+\t\t\t\t\t       false, flags, reason);\n \n     case TYPE_POINTER:\n-      return Type::are_identical_cmp_tags(t1->points_to(), t2->points_to(),\n-\t\t\t\t\t  cmp_tags, errors_are_identical,\n-\t\t\t\t\t  reason);\n+      return Type::are_identical(t1->points_to(), t2->points_to(), flags,\n+\t\t\t\t reason);\n \n     case TYPE_STRUCT:\n-      return t1->struct_type()->is_identical(t2->struct_type(), cmp_tags,\n-\t\t\t\t\t     errors_are_identical);\n+      return t1->struct_type()->is_identical(t2->struct_type(), flags);\n \n     case TYPE_ARRAY:\n-      return t1->array_type()->is_identical(t2->array_type(), cmp_tags,\n-\t\t\t\t\t    errors_are_identical);\n+      return t1->array_type()->is_identical(t2->array_type(), flags);\n \n     case TYPE_MAP:\n-      return t1->map_type()->is_identical(t2->map_type(), cmp_tags,\n-\t\t\t\t\t  errors_are_identical);\n+      return t1->map_type()->is_identical(t2->map_type(), flags);\n \n     case TYPE_CHANNEL:\n-      return t1->channel_type()->is_identical(t2->channel_type(), cmp_tags,\n-\t\t\t\t\t      errors_are_identical);\n+      return t1->channel_type()->is_identical(t2->channel_type(), flags);\n \n     case TYPE_INTERFACE:\n-      return t1->interface_type()->is_identical(t2->interface_type(), cmp_tags,\n-\t\t\t\t\t\terrors_are_identical);\n+      return t1->interface_type()->is_identical(t2->interface_type(), flags);\n \n     case TYPE_CALL_MULTIPLE_RESULT:\n       if (reason != NULL)\n@@ -464,7 +443,7 @@ Type::are_identical_cmp_tags(const Type* t1, const Type* t2, Cmp_tags cmp_tags,\n bool\n Type::are_compatible_for_binop(const Type* lhs, const Type* rhs)\n {\n-  if (Type::are_identical(lhs, rhs, true, NULL))\n+  if (Type::are_identical(lhs, rhs, Type::COMPARE_TAGS, NULL))\n     return true;\n \n   // A constant of abstract bool type may be mixed with any bool type.\n@@ -675,7 +654,7 @@ Type::are_assignable(const Type* lhs, const Type* rhs, std::string* reason)\n     return true;\n \n   // Identical types are assignable.\n-  if (Type::are_identical(lhs, rhs, true, reason))\n+  if (Type::are_identical(lhs, rhs, Type::COMPARE_TAGS, reason))\n     return true;\n \n   // Ignore aliases, except for error messages.\n@@ -688,7 +667,8 @@ Type::are_assignable(const Type* lhs, const Type* rhs, std::string* reason)\n   // and either LHS or RHS is not a named type.\n   if (((lhs->named_type() != NULL && rhs->named_type() == NULL)\n        || (rhs->named_type() != NULL && lhs->named_type() == NULL))\n-      && Type::are_identical(lhs->base(), rhs->base(), true, reason))\n+      && Type::are_identical(lhs->base(), rhs->base(), Type::COMPARE_TAGS,\n+\t\t\t     reason))\n     return true;\n \n   // The types are assignable if LHS is an interface type and RHS\n@@ -715,7 +695,7 @@ Type::are_assignable(const Type* lhs, const Type* rhs, std::string* reason)\n       && (lhs->named_type() == NULL || rhs->named_type() == NULL)\n       && Type::are_identical(lhs->channel_type()->element_type(),\n \t\t\t     rhs->channel_type()->element_type(),\n-\t\t\t     true,\n+\t\t\t     Type::COMPARE_TAGS,\n \t\t\t     reason))\n     return true;\n \n@@ -796,8 +776,7 @@ Type::are_convertible(const Type* lhs, const Type* rhs, std::string* reason)\n   // The types are convertible if they have identical underlying\n   // types, ignoring struct field tags.\n   if ((lhs->named_type() != NULL || rhs->named_type() != NULL)\n-      && Type::are_identical_cmp_tags(lhs->base(), rhs->base(), IGNORE_TAGS,\n-\t\t\t\t      true, reason))\n+      && Type::are_identical(lhs->base(), rhs->base(), 0, reason))\n     return true;\n \n   // The types are convertible if they are both unnamed pointer types\n@@ -809,11 +788,9 @@ Type::are_convertible(const Type* lhs, const Type* rhs, std::string* reason)\n       && rhs->points_to() != NULL\n       && (lhs->points_to()->named_type() != NULL\n \t  || rhs->points_to()->named_type() != NULL)\n-      && Type::are_identical_cmp_tags(lhs->points_to()->base(),\n-\t\t\t\t      rhs->points_to()->base(),\n-\t\t\t\t      IGNORE_TAGS,\n-\t\t\t\t      true,\n-\t\t\t\t      reason))\n+      && Type::are_identical(lhs->points_to()->base(),\n+\t\t\t     rhs->points_to()->base(),\n+\t\t\t     0, reason))\n     return true;\n \n   // Integer and floating point types are convertible to each other.\n@@ -944,21 +921,21 @@ Type::copy_expressions()\n // Return a hash code for the type to be used for method lookup.\n \n unsigned int\n-Type::hash_for_method(Gogo* gogo) const\n+Type::hash_for_method(Gogo* gogo, int flags) const\n {\n   if (this->named_type() != NULL && this->named_type()->is_alias())\n-    return this->named_type()->real_type()->hash_for_method(gogo);\n+    return this->named_type()->real_type()->hash_for_method(gogo, flags);\n   unsigned int ret = 0;\n   if (this->classification_ != TYPE_FORWARD)\n     ret += this->classification_;\n-  return ret + this->do_hash_for_method(gogo);\n+  return ret + this->do_hash_for_method(gogo, flags);\n }\n \n // Default implementation of do_hash_for_method.  This is appropriate\n // for types with no subfields.\n \n unsigned int\n-Type::do_hash_for_method(Gogo*) const\n+Type::do_hash_for_method(Gogo*, int) const\n {\n   return 0;\n }\n@@ -2370,9 +2347,9 @@ Type::type_descriptor_constructor(Gogo* gogo, int runtime_type_kind,\n   go_assert(p->is_field_name(\"hash\"));\n   unsigned int h;\n   if (name != NULL)\n-    h = name->hash_for_method(gogo);\n+    h = name->hash_for_method(gogo, Type::COMPARE_TAGS);\n   else\n-    h = this->hash_for_method(gogo);\n+    h = this->hash_for_method(gogo, Type::COMPARE_TAGS);\n   vals->push_back(Expression::make_integer_ul(h, p->type(), bloc));\n \n   ++p;\n@@ -3980,7 +3957,7 @@ Integer_type::is_identical(const Integer_type* t) const\n // Hash code.\n \n unsigned int\n-Integer_type::do_hash_for_method(Gogo*) const\n+Integer_type::do_hash_for_method(Gogo*, int) const\n {\n   return ((this->bits_ << 4)\n \t  + ((this->is_unsigned_ ? 1 : 0) << 8)\n@@ -4110,7 +4087,7 @@ Float_type::is_identical(const Float_type* t) const\n // Hash code.\n \n unsigned int\n-Float_type::do_hash_for_method(Gogo*) const\n+Float_type::do_hash_for_method(Gogo*, int) const\n {\n   return (this->bits_ << 4) + ((this->is_abstract_ ? 1 : 0) << 8);\n }\n@@ -4224,7 +4201,7 @@ Complex_type::is_identical(const Complex_type *t) const\n // Hash code.\n \n unsigned int\n-Complex_type::do_hash_for_method(Gogo*) const\n+Complex_type::do_hash_for_method(Gogo*, int) const\n {\n   return (this->bits_ << 4) + ((this->is_abstract_ ? 1 : 0) << 8);\n }\n@@ -4443,7 +4420,7 @@ bool\n Function_type::is_valid_redeclaration(const Function_type* t,\n \t\t\t\t      std::string* reason) const\n {\n-  if (!this->is_identical(t, false, COMPARE_TAGS, true, reason))\n+  if (!this->is_identical(t, false, COMPARE_TAGS, reason))\n     return false;\n \n   // A redeclaration of a function is required to use the same names\n@@ -4521,8 +4498,7 @@ Function_type::is_valid_redeclaration(const Function_type* t,\n \n bool\n Function_type::is_identical(const Function_type* t, bool ignore_receiver,\n-\t\t\t    Cmp_tags cmp_tags, bool errors_are_identical,\n-\t\t\t    std::string* reason) const\n+\t\t\t    int flags, std::string* reason) const\n {\n   if (this->is_backend_function_type() != t->is_backend_function_type())\n     return false;\n@@ -4539,8 +4515,7 @@ Function_type::is_identical(const Function_type* t, bool ignore_receiver,\n \t}\n       if (r1 != NULL)\n \t{\n-\t  if (!Type::are_identical_cmp_tags(r1->type(), r2->type(), cmp_tags,\n-\t\t\t\t\t    errors_are_identical, reason))\n+\t  if (!Type::are_identical(r1->type(), r2->type(), flags, reason))\n \t    {\n \t      if (reason != NULL && !reason->empty())\n \t\t*reason = \"receiver: \" + *reason;\n@@ -4575,8 +4550,7 @@ Function_type::is_identical(const Function_type* t, bool ignore_receiver,\n \t      return false;\n \t    }\n \n-\t  if (!Type::are_identical_cmp_tags(p1->type(), p2->type(), cmp_tags,\n-\t\t\t\t\t    errors_are_identical, NULL))\n+\t  if (!Type::are_identical(p1->type(), p2->type(), flags, NULL))\n \t    {\n \t      if (reason != NULL)\n \t\t*reason = _(\"different parameter types\");\n@@ -4624,9 +4598,7 @@ Function_type::is_identical(const Function_type* t, bool ignore_receiver,\n \t      return false;\n \t    }\n \n-\t  if (!Type::are_identical_cmp_tags(res1->type(), res2->type(),\n-\t\t\t\t\t    cmp_tags, errors_are_identical,\n-\t\t\t\t\t    NULL))\n+\t  if (!Type::are_identical(res1->type(), res2->type(), flags, NULL))\n \t    {\n \t      if (reason != NULL)\n \t\t*reason = _(\"different result types\");\n@@ -4647,7 +4619,7 @@ Function_type::is_identical(const Function_type* t, bool ignore_receiver,\n // Hash code.\n \n unsigned int\n-Function_type::do_hash_for_method(Gogo* gogo) const\n+Function_type::do_hash_for_method(Gogo* gogo, int flags) const\n {\n   unsigned int ret = 0;\n   // We ignore the receiver type for hash codes, because we need to\n@@ -4659,15 +4631,15 @@ Function_type::do_hash_for_method(Gogo* gogo) const\n       for (Typed_identifier_list::const_iterator p = this->parameters_->begin();\n \t   p != this->parameters_->end();\n \t   ++p, ++shift)\n-\tret += p->type()->hash_for_method(gogo) << shift;\n+\tret += p->type()->hash_for_method(gogo, flags) << shift;\n     }\n   if (this->results_ != NULL)\n     {\n       int shift = 2;\n       for (Typed_identifier_list::const_iterator p = this->results_->begin();\n \t   p != this->results_->end();\n \t   ++p, ++shift)\n-\tret += p->type()->hash_for_method(gogo) << shift;\n+\tret += p->type()->hash_for_method(gogo, flags) << shift;\n     }\n   if (this->is_varargs_)\n     ret += 1;\n@@ -4687,7 +4659,7 @@ Function_type::Results_hash::operator()(const Typed_identifier_list* t) const\n     {\n       hash <<= 2;\n       hash = Type::hash_string(p->name(), hash);\n-      hash += p->type()->hash_for_method(NULL);\n+      hash += p->type()->hash_for_method(NULL, Type::COMPARE_TAGS);\n     }\n   return hash;\n }\n@@ -4707,7 +4679,8 @@ Function_type::Results_equal::operator()(const Typed_identifier_list* a,\n        ++pa, ++pb)\n     {\n       if (pa->name() != pb->name()\n-\t  || !Type::are_identical(pa->type(), pb->type(), true, NULL))\n+\t  || !Type::are_identical(pa->type(), pb->type(), Type::COMPARE_TAGS,\n+\t\t\t\t  NULL))\n \treturn false;\n     }\n   return true;\n@@ -5269,9 +5242,9 @@ Pointer_type::do_traverse(Traverse* traverse)\n // Hash code.\n \n unsigned int\n-Pointer_type::do_hash_for_method(Gogo* gogo) const\n+Pointer_type::do_hash_for_method(Gogo* gogo, int flags) const\n {\n-  return this->to_type_->hash_for_method(gogo) << 4;\n+  return this->to_type_->hash_for_method(gogo, flags) << 4;\n }\n \n // Get the backend representation for a pointer type.\n@@ -5723,8 +5696,7 @@ Struct_type::do_has_pointer() const\n // Whether this type is identical to T.\n \n bool\n-Struct_type::is_identical(const Struct_type* t, Cmp_tags cmp_tags,\n-\t\t\t  bool errors_are_identical) const\n+Struct_type::is_identical(const Struct_type* t, int flags) const\n {\n   if (this->is_struct_incomparable_ != t->is_struct_incomparable_)\n     return false;\n@@ -5742,10 +5714,9 @@ Struct_type::is_identical(const Struct_type* t, Cmp_tags cmp_tags,\n       if (pf1->field_name() != pf2->field_name())\n \treturn false;\n       if (pf1->is_anonymous() != pf2->is_anonymous()\n-\t  || !Type::are_identical_cmp_tags(pf1->type(), pf2->type(), cmp_tags,\n-\t\t\t\t\t   errors_are_identical, NULL))\n+\t  || !Type::are_identical(pf1->type(), pf2->type(), flags, NULL))\n \treturn false;\n-      if (cmp_tags == COMPARE_TAGS)\n+      if ((flags & Type::COMPARE_TAGS) != 0)\n \t{\n \t  if (!pf1->has_tag())\n \t    {\n@@ -5876,15 +5847,15 @@ Struct_type::do_in_heap()\n // Hash code.\n \n unsigned int\n-Struct_type::do_hash_for_method(Gogo* gogo) const\n+Struct_type::do_hash_for_method(Gogo* gogo, int flags) const\n {\n   unsigned int ret = 0;\n   if (this->fields() != NULL)\n     {\n       for (Struct_field_list::const_iterator pf = this->fields()->begin();\n \t   pf != this->fields()->end();\n \t   ++pf)\n-\tret = (ret << 1) + pf->type()->hash_for_method(gogo);\n+\tret = (ret << 1) + pf->type()->hash_for_method(gogo, flags);\n     }\n   ret <<= 2;\n   if (this->is_struct_incomparable_)\n@@ -6940,11 +6911,10 @@ Array_type::int_length(int64_t* plen)\n // Whether two array types are identical.\n \n bool\n-Array_type::is_identical(const Array_type* t, Cmp_tags cmp_tags,\n-\t\t\t bool errors_are_identical) const\n+Array_type::is_identical(const Array_type* t, int flags) const\n {\n-  if (!Type::are_identical_cmp_tags(this->element_type(), t->element_type(),\n-\t\t\t\t    cmp_tags, errors_are_identical, NULL))\n+  if (!Type::are_identical(this->element_type(), t->element_type(),\n+\t\t\t   flags, NULL))\n     return false;\n \n   if (this->is_array_incomparable_ != t->is_array_incomparable_)\n@@ -7154,13 +7124,13 @@ Array_type::do_compare_is_identity(Gogo* gogo)\n // Array type hash code.\n \n unsigned int\n-Array_type::do_hash_for_method(Gogo* gogo) const\n+Array_type::do_hash_for_method(Gogo* gogo, int flags) const\n {\n   unsigned int ret;\n \n   // There is no very convenient way to get a hash code for the\n   // length.\n-  ret = this->element_type_->hash_for_method(gogo) + 1;\n+  ret = this->element_type_->hash_for_method(gogo, flags) + 1;\n   if (this->is_array_incomparable_)\n     ret <<= 1;\n   return ret;\n@@ -7873,23 +7843,20 @@ Map_type::do_verify()\n // Whether two map types are identical.\n \n bool\n-Map_type::is_identical(const Map_type* t, Cmp_tags cmp_tags,\n-\t\t       bool errors_are_identical) const\n+Map_type::is_identical(const Map_type* t, int flags) const\n {\n-  return (Type::are_identical_cmp_tags(this->key_type(), t->key_type(),\n-\t\t\t\t       cmp_tags, errors_are_identical, NULL)\n-\t  && Type::are_identical_cmp_tags(this->val_type(), t->val_type(),\n-\t\t\t\t\t  cmp_tags, errors_are_identical,\n-\t\t\t\t\t  NULL));\n+  return (Type::are_identical(this->key_type(), t->key_type(), flags, NULL)\n+\t  && Type::are_identical(this->val_type(), t->val_type(), flags,\n+\t\t\t\t NULL));\n }\n \n // Hash code.\n \n unsigned int\n-Map_type::do_hash_for_method(Gogo* gogo) const\n+Map_type::do_hash_for_method(Gogo* gogo, int flags) const\n {\n-  return (this->key_type_->hash_for_method(gogo)\n-\t  + this->val_type_->hash_for_method(gogo)\n+  return (this->key_type_->hash_for_method(gogo, flags)\n+\t  + this->val_type_->hash_for_method(gogo, flags)\n \t  + 2);\n }\n \n@@ -8386,26 +8353,25 @@ Channel_type::do_verify()\n // Hash code.\n \n unsigned int\n-Channel_type::do_hash_for_method(Gogo* gogo) const\n+Channel_type::do_hash_for_method(Gogo* gogo, int flags) const\n {\n   unsigned int ret = 0;\n   if (this->may_send_)\n     ret += 1;\n   if (this->may_receive_)\n     ret += 2;\n   if (this->element_type_ != NULL)\n-    ret += this->element_type_->hash_for_method(gogo) << 2;\n+    ret += this->element_type_->hash_for_method(gogo, flags) << 2;\n   return ret << 3;\n }\n \n // Whether this type is the same as T.\n \n bool\n-Channel_type::is_identical(const Channel_type* t, Cmp_tags cmp_tags,\n-\t\t\t   bool errors_are_identical) const\n+Channel_type::is_identical(const Channel_type* t, int flags) const\n {\n-  if (!Type::are_identical_cmp_tags(this->element_type(), t->element_type(),\n-\t\t\t\t    cmp_tags, errors_are_identical, NULL))\n+  if (!Type::are_identical(this->element_type(), t->element_type(), flags,\n+\t\t\t   NULL))\n     return false;\n   return (this->may_send_ == t->may_send_\n \t  && this->may_receive_ == t->may_receive_);\n@@ -8775,8 +8741,7 @@ Interface_type::is_unexported_method(Gogo* gogo, const std::string& name) const\n // Whether this type is identical with T.\n \n bool\n-Interface_type::is_identical(const Interface_type* t, Cmp_tags cmp_tags,\n-\t\t\t     bool errors_are_identical) const\n+Interface_type::is_identical(const Interface_type* t, int flags) const\n {\n   // If methods have not been finalized, then we are asking whether\n   // func redeclarations are the same.  This is an error, so for\n@@ -8806,8 +8771,7 @@ Interface_type::is_identical(const Interface_type* t, Cmp_tags cmp_tags,\n       if (p1 == this->all_methods_->end())\n \tbreak;\n       if (p1->name() != p2->name()\n-\t  || !Type::are_identical_cmp_tags(p1->type(), p2->type(), cmp_tags,\n-\t\t\t\t\t   errors_are_identical, NULL))\n+\t  || !Type::are_identical(p1->type(), p2->type(), flags, NULL))\n \tbreak;\n     }\n \n@@ -8863,7 +8827,8 @@ Interface_type::is_compatible_for_assign(const Interface_type* t,\n \t}\n \n       std::string subreason;\n-      if (!Type::are_identical(p->type(), m->type(), true, &subreason))\n+      if (!Type::are_identical(p->type(), m->type(), Type::COMPARE_TAGS,\n+\t\t\t       &subreason))\n \t{\n \t  if (reason != NULL)\n \t    {\n@@ -8891,7 +8856,7 @@ Interface_type::is_compatible_for_assign(const Interface_type* t,\n // Hash code.\n \n unsigned int\n-Interface_type::do_hash_for_method(Gogo*) const\n+Interface_type::do_hash_for_method(Gogo*, int) const\n {\n   go_assert(this->methods_are_finalized_);\n   unsigned int ret = 0;\n@@ -9005,7 +8970,7 @@ Interface_type::implements_interface(const Type* t, std::string* reason) const\n       Function_type* m_fn_type = m->type()->function_type();\n       go_assert(p_fn_type != NULL && m_fn_type != NULL);\n       std::string subreason;\n-      if (!p_fn_type->is_identical(m_fn_type, true, COMPARE_TAGS, true,\n+      if (!p_fn_type->is_identical(m_fn_type, true, Type::COMPARE_TAGS,\n \t\t\t\t   &subreason))\n \t{\n \t  if (reason != NULL)\n@@ -10427,7 +10392,7 @@ Named_type::do_needs_key_update()\n // hash on the name itself.\n \n unsigned int\n-Named_type::do_hash_for_method(Gogo* gogo) const\n+Named_type::do_hash_for_method(Gogo* gogo, int) const\n {\n   if (this->is_error_)\n     return 0;"}, {"sha": "9e3f2f36e3c00d8e105d5f1c00256a7cbf49a87e", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 47, "deletions": 51, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0799a08b5c6a2087de9512252be6d9192e92395a/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0799a08b5c6a2087de9512252be6d9192e92395a/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=0799a08b5c6a2087de9512252be6d9192e92395a", "patch": "@@ -563,29 +563,22 @@ class Type\n   verify()\n   { return this->do_verify(); }\n \n-  // Return true if two types are identical.  If ERRORS_ARE_IDENTICAL,\n-  // returns that an erroneous type is identical to any other type;\n-  // this is used to avoid cascading errors.  If this returns false,\n-  // and REASON is not NULL, it may set *REASON.\n-  static bool\n-  are_identical(const Type* lhs, const Type* rhs, bool errors_are_identical,\n-\t\tstd::string* reason);\n+  // Bit flags to pass to are_identical and friends.\n \n-  // An argument to are_identical_cmp_tags, indicating whether or not\n-  // to compare struct field tags.\n-  enum Cmp_tags {\n-    COMPARE_TAGS,\n-    IGNORE_TAGS\n-  };\n+  // Treat error types as their own distinct type.  Sometimes we\n+  // ignore error types--treat them as identical to every other\n+  // type--to avoid cascading errors.\n+  static const int COMPARE_ERRORS = 1;\n+\n+  // Compare struct field tags when comparing structs.  We ignore\n+  // struct field tags for purposes of type conversion.\n+  static const int COMPARE_TAGS = 2;\n \n-  // Return true if two types are identical.  This is like the\n-  // are_identical function, but also takes a CMP_TAGS argument\n-  // indicating whether to compare struct tags.  Otherwise the\n-  // parameters are as for are_identical.\n+  // Return true if two types are identical.  If this returns false,\n+  // and REASON is not NULL, it may set *REASON.\n   static bool\n-  are_identical_cmp_tags(const Type* lhs, const Type* rhs,\n-\t\t\t Cmp_tags, bool errors_are_identical,\n-\t\t\t std::string* reason);\n+  are_identical(const Type* lhs, const Type* rhs, int flags,\n+\t\tstd::string* reason);\n \n   // Return true if two types are compatible for use in a binary\n   // operation, other than a shift, comparison, or channel send.  This\n@@ -648,7 +641,7 @@ class Type\n   // Types which are equivalent according to are_identical will have\n   // the same hash code.\n   unsigned int\n-  hash_for_method(Gogo*) const;\n+  hash_for_method(Gogo*, int) const;\n \n   // Return the type classification.\n   Type_classification\n@@ -1082,7 +1075,7 @@ class Type\n   { return true; }\n \n   virtual unsigned int\n-  do_hash_for_method(Gogo*) const;\n+  do_hash_for_method(Gogo*, int) const;\n \n   virtual Btype*\n   do_get_backend(Gogo*) = 0;\n@@ -1381,22 +1374,30 @@ class Type\n   bool in_heap_;\n };\n \n-// Type hash table operations.\n+// Type hash table operations, treating aliases as identical to the\n+// types that they alias.\n \n class Type_hash_identical\n {\n  public:\n   unsigned int\n   operator()(const Type* type) const\n-  { return type->hash_for_method(NULL); }\n+  {\n+    return type->hash_for_method(NULL,\n+\t\t\t\t Type::COMPARE_ERRORS | Type::COMPARE_TAGS);\n+  }\n };\n \n class Type_identical\n {\n  public:\n   bool\n   operator()(const Type* t1, const Type* t2) const\n-  { return Type::are_identical(t1, t2, false, NULL); }\n+  {\n+    return Type::are_identical(t1, t2,\n+\t\t\t       Type::COMPARE_ERRORS | Type::COMPARE_TAGS,\n+\t\t\t       NULL);\n+  }\n };\n \n // An identifier with a type.\n@@ -1724,7 +1725,7 @@ class Integer_type : public Type\n   { return true; }\n \n   unsigned int\n-  do_hash_for_method(Gogo*) const;\n+  do_hash_for_method(Gogo*, int) const;\n \n   Btype*\n   do_get_backend(Gogo*);\n@@ -1810,7 +1811,7 @@ class Float_type : public Type\n   { return true; }\n \n   unsigned int\n-  do_hash_for_method(Gogo*) const;\n+  do_hash_for_method(Gogo*, int) const;\n \n   Btype*\n   do_get_backend(Gogo*);\n@@ -1888,7 +1889,7 @@ class Complex_type : public Type\n   { return true; }\n \n   unsigned int\n-  do_hash_for_method(Gogo*) const;\n+  do_hash_for_method(Gogo*, int) const;\n \n   Btype*\n   do_get_backend(Gogo*);\n@@ -2036,8 +2037,8 @@ class Function_type : public Type\n \n   // Whether this type is the same as T.\n   bool\n-  is_identical(const Function_type* t, bool ignore_receiver,\n-\t       Cmp_tags, bool errors_are_identical, std::string*) const;\n+  is_identical(const Function_type* t, bool ignore_receiver, int flags,\n+\t       std::string*) const;\n \n   // Record that this is a varargs function.\n   void\n@@ -2102,7 +2103,7 @@ class Function_type : public Type\n   { return false; }\n \n   unsigned int\n-  do_hash_for_method(Gogo*) const;\n+  do_hash_for_method(Gogo*, int) const;\n \n   Btype*\n   do_get_backend(Gogo*);\n@@ -2231,7 +2232,7 @@ class Pointer_type : public Type\n   { return true; }\n \n   unsigned int\n-  do_hash_for_method(Gogo*) const;\n+  do_hash_for_method(Gogo*, int) const;\n \n   Btype*\n   do_get_backend(Gogo*);\n@@ -2478,8 +2479,7 @@ class Struct_type : public Type\n \n   // Whether this type is identical with T.\n   bool\n-  is_identical(const Struct_type* t, Cmp_tags,\n-\t       bool errors_are_identical) const;\n+  is_identical(const Struct_type* t, int) const;\n \n   // Return whether NAME is a local field which is not exported.  This\n   // is only used for better error reporting.\n@@ -2498,7 +2498,7 @@ class Struct_type : public Type\n   has_any_methods() const\n   { return this->all_methods_ != NULL; }\n \n-  // Return the methods for tihs type.  This should only be called\n+  // Return the methods for this type.  This should only be called\n   // after the finalize_methods pass.\n   const Methods*\n   methods() const\n@@ -2590,7 +2590,7 @@ class Struct_type : public Type\n   do_in_heap();\n \n   unsigned int\n-  do_hash_for_method(Gogo*) const;\n+  do_hash_for_method(Gogo*, int) const;\n \n   Btype*\n   do_get_backend(Gogo*);\n@@ -2684,8 +2684,7 @@ class Array_type : public Type\n \n   // Whether this type is identical with T.\n   bool\n-  is_identical(const Array_type* t, Cmp_tags,\n-\t       bool errors_are_identical) const;\n+  is_identical(const Array_type* t, int) const;\n \n   // Return an expression for the pointer to the values in an array.\n   Expression*\n@@ -2767,7 +2766,7 @@ class Array_type : public Type\n   { return this->length_ == NULL || this->element_type_->in_heap(); }\n \n   unsigned int\n-  do_hash_for_method(Gogo*) const;\n+  do_hash_for_method(Gogo*, int) const;\n \n   Btype*\n   do_get_backend(Gogo*);\n@@ -2850,8 +2849,7 @@ class Map_type : public Type\n \n   // Whether this type is identical with T.\n   bool\n-  is_identical(const Map_type* t, Cmp_tags,\n-\t       bool errors_are_identical) const;\n+  is_identical(const Map_type* t, int) const;\n \n   // Import a map type.\n   static Map_type*\n@@ -2885,7 +2883,7 @@ class Map_type : public Type\n   }\n \n   unsigned int\n-  do_hash_for_method(Gogo*) const;\n+  do_hash_for_method(Gogo*, int) const;\n \n   Btype*\n   do_get_backend(Gogo*);\n@@ -2970,8 +2968,7 @@ class Channel_type : public Type\n \n   // Whether this type is identical with T.\n   bool\n-  is_identical(const Channel_type* t, Cmp_tags,\n-\t       bool errors_are_identical) const;\n+  is_identical(const Channel_type* t, int) const;\n \n   // Import a channel type.\n   static Channel_type*\n@@ -3000,7 +2997,7 @@ class Channel_type : public Type\n   { return true; }\n \n   unsigned int\n-  do_hash_for_method(Gogo*) const;\n+  do_hash_for_method(Gogo*, int) const;\n \n   Btype*\n   do_get_backend(Gogo*);\n@@ -3090,8 +3087,7 @@ class Interface_type : public Type\n   // Whether this type is identical with T.  REASON is as in\n   // implements_interface.\n   bool\n-  is_identical(const Interface_type* t, Cmp_tags,\n-\t       bool errors_are_identical) const;\n+  is_identical(const Interface_type* t, int) const;\n \n   // Whether we can assign T to this type.  is_identical is known to\n   // be false.\n@@ -3151,7 +3147,7 @@ class Interface_type : public Type\n   { return true; }\n \n   unsigned int\n-  do_hash_for_method(Gogo*) const;\n+  do_hash_for_method(Gogo*, int) const;\n \n   Btype*\n   do_get_backend(Gogo*);\n@@ -3476,7 +3472,7 @@ class Named_type : public Type\n   { return this->in_heap_ && this->type_->in_heap(); }\n \n   unsigned int\n-  do_hash_for_method(Gogo*) const;\n+  do_hash_for_method(Gogo*, int) const;\n \n   Btype*\n   do_get_backend(Gogo*);\n@@ -3639,8 +3635,8 @@ class Forward_declaration_type : public Type\n   { return this->real_type()->in_heap(); }\n \n   unsigned int\n-  do_hash_for_method(Gogo* gogo) const\n-  { return this->real_type()->hash_for_method(gogo); }\n+  do_hash_for_method(Gogo* gogo, int flags) const\n+  { return this->real_type()->hash_for_method(gogo, flags); }\n \n   Btype*\n   do_get_backend(Gogo* gogo);"}, {"sha": "3f0a89f8ceb509bb5271903e298f2472759fe3e8", "filename": "gcc/go/gofrontend/wb.cc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0799a08b5c6a2087de9512252be6d9192e92395a/gcc%2Fgo%2Fgofrontend%2Fwb.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0799a08b5c6a2087de9512252be6d9192e92395a/gcc%2Fgo%2Fgofrontend%2Fwb.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fwb.cc?ref=0799a08b5c6a2087de9512252be6d9192e92395a", "patch": "@@ -777,7 +777,9 @@ Gogo::assign_with_write_barrier(Function* function, Block* enclosing,\n   inserter->insert(lhs_temp);\n   lhs = Expression::make_temporary_reference(lhs_temp, loc);\n \n-  if (!Type::are_identical(type, rhs->type(), false, NULL)\n+  if (!Type::are_identical(type, rhs->type(),\n+\t\t\t   Type::COMPARE_ERRORS | Type::COMPARE_TAGS,\n+\t\t\t   NULL)\n       && rhs->type()->interface_type() != NULL\n       && !rhs->is_variable())\n     {"}]}