{"sha": "3e93b2755219dbd75fda52a0300c3073a2c7f177", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2U5M2IyNzU1MjE5ZGJkNzVmZGE1MmEwMzAwYzMwNzNhMmM3ZjE3Nw==", "commit": {"author": {"name": "Chris Fairles", "email": "cfairles@gcc.gnu.org", "date": "2008-10-01T22:04:02Z"}, "committer": {"name": "Chris Fairles", "email": "cfairles@gcc.gnu.org", "date": "2008-10-01T22:04:02Z"}, "message": "tuple (tuple<>::swap): Implement swap for tuple as per DR 522 [Ready].\n\n2008-09-30  Chris Fairles  <cfairles@gcc.gnu.org>\n\n        * include/std/tuple (tuple<>::swap): Implement swap for tuple as per\n        DR 522 [Ready].\n        * testsuite/20_util/tuple/swap.cc: New.\n\nFrom-SVN: r140822", "tree": {"sha": "c80c91c9977fc87421d209601f52d9891fab6ef7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c80c91c9977fc87421d209601f52d9891fab6ef7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3e93b2755219dbd75fda52a0300c3073a2c7f177", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e93b2755219dbd75fda52a0300c3073a2c7f177", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e93b2755219dbd75fda52a0300c3073a2c7f177", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e93b2755219dbd75fda52a0300c3073a2c7f177/comments", "author": null, "committer": null, "parents": [{"sha": "266b48906ac36728e24c49787c6b2e063a1f7df1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/266b48906ac36728e24c49787c6b2e063a1f7df1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/266b48906ac36728e24c49787c6b2e063a1f7df1"}], "stats": {"total": 178, "additions": 176, "deletions": 2}, "files": [{"sha": "2ca3b9e0908ede176df6e199d5a6c122316237e5", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e93b2755219dbd75fda52a0300c3073a2c7f177/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e93b2755219dbd75fda52a0300c3073a2c7f177/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=3e93b2755219dbd75fda52a0300c3073a2c7f177", "patch": "@@ -1,3 +1,9 @@\n+2008-09-30  Chris Fairles  <cfairles@gcc.gnu.org>\n+\n+\t* include/std/tuple (tuple<>::swap): Implement swap for tuple as per \n+\tDR 522 [Ready].\n+\t* testsuite/20_util/tuple/swap.cc: New.\n+\n 2008-09-30  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR libstdc++/30085 (again)"}, {"sha": "33e8731d3aafaab650e6c425ae657e50ca8878ef", "filename": "libstdc++-v3/include/std/tuple", "status": "modified", "additions": 52, "deletions": 2, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e93b2755219dbd75fda52a0300c3073a2c7f177/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e93b2755219dbd75fda52a0300c3073a2c7f177/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple?ref=3e93b2755219dbd75fda52a0300c3073a2c7f177", "patch": "@@ -81,6 +81,8 @@ namespace std\n \n       _Head&       _M_head()       { return *this; }\n       const _Head& _M_head() const { return *this; }\n+\n+      void __swap_impl(_Head&&) { /* no-op */ }\n     };\n \n   template<std::size_t _Idx, typename _Head>\n@@ -99,6 +101,13 @@ namespace std\n       _Head&       _M_head()       { return _M_head_impl; }\n       const _Head& _M_head() const { return _M_head_impl; }        \n \n+      void\n+      __swap_impl(_Head&& __h)\n+      { \n+\tusing std::swap;\n+\tswap(__h, _M_head_impl);\n+      }\n+\n       _Head _M_head_impl; \n     };\n \n@@ -118,7 +127,10 @@ namespace std\n    * inheritance recursion.\n    */\n   template<std::size_t _Idx>\n-    struct _Tuple_impl<_Idx> { };\n+    struct _Tuple_impl<_Idx>\n+    { \n+      void __swap_impl(_Tuple_impl&&) { /* no-op */ }\n+    };\n \n   /**\n    * Recursive tuple implementation. Here we store the @c Head element\n@@ -203,6 +215,13 @@ namespace std\n \t  _M_tail() = std::move(__in._M_tail());\n \t  return *this;\n \t}\n+\n+      void\n+      __swap_impl(_Tuple_impl&& __in)\n+      {\n+\t_Base::__swap_impl(__in._M_head());\n+\t_Inherited::__swap_impl(__in._M_tail());\n+      }\n     };\n \n   /// tuple\n@@ -274,11 +293,19 @@ namespace std\n \t  static_cast<_Inherited&>(*this) = std::move(__in);\n \t  return *this;\n \t}\n+\n+      void\n+      swap(tuple&& __in)\n+      { _Inherited::__swap_impl(__in); }\n     };\n \n \n   template<>  \n-    class tuple<> { };\n+    class tuple<>\n+    {\n+    public:\n+      void swap(tuple&&) { /* no-op */ }\n+    };\n \n   /// tuple (2-element), with construction and assignment from a pair.\n   template<typename _T1, typename _T2>\n@@ -368,6 +395,14 @@ namespace std\n \t  this->_M_tail()._M_head() = std::move(__in.second);\n \t  return *this;\n \t}\n+\n+      void\n+      swap(tuple&& __in)\n+      { \n+\tusing std::swap;\n+\tswap(this->_M_head(), __in._M_head());\n+\tswap(this->_M_tail()._M_head(), __in._M_tail()._M_head());\t\n+      }\n     };\n \n \n@@ -628,6 +663,21 @@ namespace std\n     tie(_Elements&... __args)\n     { return tuple<_Elements&...>(__args...); }\n \n+  template<typename... _Elements>\n+    inline void \n+    swap(tuple<_Elements...>& __x, tuple<_Elements...>& __y)\n+    { __x.swap(__y); }\n+\n+  template<typename... _Elements>\n+    inline void\n+    swap(tuple<_Elements...>&& __x, tuple<_Elements...>& __y)\n+    { __x.swap(__y); }\n+\n+  template<typename... _Elements>\n+    inline void\n+    swap(tuple<_Elements...>& __x, tuple<_Elements...>&& __y)\n+    { __x.swap(__y); }\n+\n   // A class (and instance) which can be used in 'tie' when an element\n   // of a tuple is not required\n   struct _Swallow_assign"}, {"sha": "2bebbe0674bc39d92db838905a0675b93cd7c9ff", "filename": "libstdc++-v3/testsuite/20_util/tuple/swap.cc", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e93b2755219dbd75fda52a0300c3073a2c7f177/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Fswap.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e93b2755219dbd75fda52a0300c3073a2c7f177/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Fswap.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Fswap.cc?ref=3e93b2755219dbd75fda52a0300c3073a2c7f177", "patch": "@@ -0,0 +1,118 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// NOTE: This makes use of the fact that we know how moveable\n+// is implemented on tuple.  If the implementation changed\n+// this test may begin to fail.\n+\n+#include <tuple>\n+#include <utility>\n+#include <testsuite_hooks.h>\n+\n+struct MoveOnly\n+{\n+  explicit MoveOnly (int j) : i(j) { }\n+\n+  MoveOnly (MoveOnly&& m) : i(m.i) { }\n+\n+  MoveOnly& operator=(MoveOnly&& m)\n+  { i = m.i; return *this; }\n+\n+  MoveOnly(MoveOnly const&) = delete;\n+  MoveOnly& operator=(MoveOnly const&) = delete;\n+\n+  bool operator==(MoveOnly const& m)\n+  { return i == m.i; }\n+\n+  void swap(MoveOnly&& m)\n+  { std::swap(m.i, i); }\n+\n+  int i;\n+};\n+\n+void swap(MoveOnly& m1, MoveOnly& m2)\n+{ m1.swap(m2); }\n+\n+MoveOnly\n+make_move_only (int i)\n+{ return MoveOnly(i); }\n+\n+void test01()\n+{\n+  std::tuple<> t1, t2;\n+  std::swap(t1, t2);\n+\n+  VERIFY( t1 == t2 );\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::tuple<int> t1(1), t2(2);\n+  std::swap(t1, t2);\n+  \n+  VERIFY( std::get<0>(t1) == 2 && std::get<0>(t2) == 1 );\n+}\n+\n+void test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::tuple<int, float> t1(1, 1.0f), t2(2, 2.0f);\n+  std::swap(t1, t2);\n+\n+  VERIFY( std::get<0>(t1) == 2 && std::get<0>(t2) == 1 );\n+  VERIFY( std::get<1>(t1) == 2.0f && std::get<1>(t2) == 1.0f );\n+}\n+\n+void test04()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::tuple<int, float, MoveOnly> \n+    t1(1, 1.0f, make_move_only(1)), \n+    t2(2, 2.0f, make_move_only(2));\n+\n+  std::swap(t1, t2);\n+\n+  VERIFY( std::get<0>(t1) == 2 && std::get<0>(t2) == 1 );\n+  VERIFY( std::get<1>(t1) == 2.0f && std::get<1>(t2) == 1.0f );\n+  VERIFY( std::get<2>(t1) == make_move_only(2) \n+\t  && std::get<2>(t2) == make_move_only(1) );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  return 0;\n+}"}]}