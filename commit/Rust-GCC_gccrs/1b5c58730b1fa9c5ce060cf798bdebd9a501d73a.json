{"sha": "1b5c58730b1fa9c5ce060cf798bdebd9a501d73a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWI1YzU4NzMwYjFmYTljNWNlMDYwY2Y3OThiZGViZDlhNTAxZDczYQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-06-23T03:01:03Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-06-23T03:01:03Z"}, "message": "(expand_call): Correctly handle returning BLKmode structures in registers when...\n\n(expand_call): Correctly handle returning BLKmode structures in\nregisters when the size of the structure is not a multiple of\nword_size.\n\nFrom-SVN: r10051", "tree": {"sha": "d264d16d88588a3bbfcefdb07423bc37b0edc500", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d264d16d88588a3bbfcefdb07423bc37b0edc500"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1b5c58730b1fa9c5ce060cf798bdebd9a501d73a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b5c58730b1fa9c5ce060cf798bdebd9a501d73a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b5c58730b1fa9c5ce060cf798bdebd9a501d73a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b5c58730b1fa9c5ce060cf798bdebd9a501d73a/comments", "author": null, "committer": null, "parents": [{"sha": "8ecb1d92459514de8b61309912cc4adf196cdf34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ecb1d92459514de8b61309912cc4adf196cdf34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ecb1d92459514de8b61309912cc4adf196cdf34"}], "stats": {"total": 69, "additions": 41, "deletions": 28}, "files": [{"sha": "4abd2c0e6ed26adc0688f26ca37aa4f5c1e17fe3", "filename": "gcc/calls.c", "status": "modified", "additions": 41, "deletions": 28, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b5c58730b1fa9c5ce060cf798bdebd9a501d73a/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b5c58730b1fa9c5ce060cf798bdebd9a501d73a/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=1b5c58730b1fa9c5ce060cf798bdebd9a501d73a", "patch": "@@ -2047,6 +2047,9 @@ expand_call (exp, target, ignore)\n       int n_regs = (bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n       int i;\n       enum machine_mode tmpmode;\n+      rtx src, dst;\n+      int bitsize = MIN (TYPE_ALIGN (TREE_TYPE (exp)), BITS_PER_WORD);\n+      int bitpos, xbitpos, big_endian_correction = 0;\n       \n       if (target == 0)\n \t{\n@@ -2055,38 +2058,48 @@ expand_call (exp, target, ignore)\n \t  preserve_temp_slots (target);\n \t}\n \n-      /* We could probably emit more efficient code for machines\n+      /* Structures whose size is not a multiple of a word are aligned\n+\t to the least significant byte (to the right).  On a BYTES_BIG_ENDIAN\n+\t machine, this means we must skip the empty high order bytes when\n+\t calculating the bit offset.  */\n+      if (BYTES_BIG_ENDIAN && bytes % UNITS_PER_WORD)\n+\tbig_endian_correction = (BITS_PER_WORD - ((bytes % UNITS_PER_WORD)\n+\t\t\t\t\t\t  * BITS_PER_UNIT));\n+\n+      /* Copy the structure BITSIZE bites at a time.\n+\n+\t We could probably emit more efficient code for machines\n \t which do not use strict alignment, but it doesn't seem\n \t worth the effort at the current time.  */\n-      for (i = 0; i < n_regs; i++)\n+      for (bitpos = 0, xbitpos = big_endian_correction;\n+\t   bitpos < bytes * BITS_PER_UNIT;\n+\t   bitpos += bitsize, xbitpos += bitsize)\n \t{\n-\t  rtx src = operand_subword_force (valreg, i, BLKmode);\n-\t  rtx dst = operand_subword (target, i, 1, BLKmode);\n-\t  int bitsize = MIN (TYPE_ALIGN (TREE_TYPE (exp)), BITS_PER_WORD);\n-\t  int bitpos, big_endian_correction = 0;\n-\t  \n-\t  /* Should never happen.  */\n-\t  if (src == NULL || dst == NULL)\n-\t    abort ();\n-\t  \n-\t  if (BYTES_BIG_ENDIAN && bytes < UNITS_PER_WORD)\n-\t    big_endian_correction\n-\t      = (BITS_PER_WORD - (bytes * BITS_PER_UNIT));\n-\t  \n-\t  for (bitpos = 0;\n-\t       bitpos < BITS_PER_WORD && bytes > 0;\n-\t       bitpos += bitsize, bytes -= bitsize / BITS_PER_UNIT)\n-\t    {\n-\t      int xbitpos = bitpos + big_endian_correction;\n+\n+\t  /* We need a new source operand each time xbitpos is on a \n+\t     word boundary and when xbitpos == big_endian_correction\n+\t     (the first time through).  */\n+\t  if (xbitpos % BITS_PER_WORD == 0\n+\t      || xbitpos == big_endian_correction)\n+\t    src = operand_subword_force (valreg,\n+\t\t\t\t\t xbitpos / BITS_PER_WORD, \n+\t\t\t\t\t BLKmode);\n+\n+\t  /* We need a new destination operand each time bitpos is on\n+\t     a word boundary.  */\n+\t  if (bitpos % BITS_PER_WORD == 0)\n+\t    dst = operand_subword (target, bitpos / BITS_PER_WORD, 1, BLKmode);\n \t      \n-\t      store_bit_field (dst, bitsize, xbitpos, word_mode,\n-\t\t\t       extract_bit_field (src, bitsize, bitpos, 1,\n-\t\t\t\t\t\t  NULL_RTX, word_mode,\n-\t\t\t\t\t\t  word_mode,\n-\t\t\t\t\t\t  bitsize / BITS_PER_UNIT,\n-\t\t\t\t\t\t  BITS_PER_WORD),\n-\t\t\t       bitsize / BITS_PER_UNIT, BITS_PER_WORD);\n-\t    }\n+\t  /* Use xbitpos for the source extraction (right justified) and\n+\t     xbitpos for the destination store (left justified).  */\n+\t  store_bit_field (dst, bitsize, bitpos % BITS_PER_WORD, word_mode,\n+\t\t\t   extract_bit_field (src, bitsize,\n+\t\t\t\t\t      xbitpos % BITS_PER_WORD, 1,\n+\t\t\t\t\t      NULL_RTX, word_mode,\n+\t\t\t\t\t      word_mode,\n+\t\t\t\t\t      bitsize / BITS_PER_UNIT,\n+\t\t\t\t\t      BITS_PER_WORD),\n+\t\t\t   bitsize / BITS_PER_UNIT, BITS_PER_WORD);\n \t}\n     }\n   else"}]}