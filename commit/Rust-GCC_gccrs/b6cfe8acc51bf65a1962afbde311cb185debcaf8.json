{"sha": "b6cfe8acc51bf65a1962afbde311cb185debcaf8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjZjZmU4YWNjNTFiZjY1YTE5NjJhZmJkZTMxMWNiMTg1ZGViY2FmOA==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2010-11-15T23:12:49Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2010-11-15T23:12:49Z"}, "message": "In gcc/objc/: 2010-11-15 Nicola Pero <nicola.pero@meta-innovation.com>\n\nIn gcc/objc/:\n2010-11-15  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        * objc-act.c (objc_build_setter_call): New.\n        (objc_maybe_build_modify_expr): Rewritten to build a compound\n        statement.\n        (objc_build_incr_expr_for_property_ref): Updated calls to\n        objc_maybe_build_modify_expr to call objc_build_setter_call\n        instead.  Use build_modify_expr () instead of build2 (MODIFY_EXPR,\n        ...).  Use convert () instead of build1 (NOP_EXPR, ...).  Use\n        TREE_NO_WARNING on the final compound statement to silence C++\n        warnings.\n\nIn gcc/testsuite/:\n2010-11-15  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        * objc.dg/property/dotsyntax-18.m: New.\n        * objc.dg/property/dotsyntax-19.m: New.\n        * objc.dg/property/dotsyntax-20.m: New.\n        * obj-c++.dg/property/dotsyntax-18.mm: New.\n        * obj-c++.dg/property/dotsyntax-19.mm: New.     \n        * obj-c++.dg/property/dotsyntax-20.mm: New.\n        * objc.dg/property/dotsyntax-4.m: Removed some unused variables and code.\n        * objc.dg/property/dotsyntax-6.m: Same change.\n        * objc.dg/property/dotsyntax-16.m: Same change. \n        * objc.dg/property/dotsyntax-17.m: Same change.\n        * obj-c++.dg/property/dotsyntax-4.mm: Same change.\n        * obj-c++.dg/property/dotsyntax-6.mm: Same change.\n        * obj-c++.dg/property/dotsyntax-16.mm: Same change. \n        * obj-c++.dg/property/dotsyntax-17.mm: Same change.\n        * objc.dg/property/at-property-22.m: Added missing casts.\n        * obj-c++.dg/property/at-property-22.mm: Same change.\n\nFrom-SVN: r166779", "tree": {"sha": "116650c2d71cbf74dc4d68bcf57d5135b736a64b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/116650c2d71cbf74dc4d68bcf57d5135b736a64b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b6cfe8acc51bf65a1962afbde311cb185debcaf8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6cfe8acc51bf65a1962afbde311cb185debcaf8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6cfe8acc51bf65a1962afbde311cb185debcaf8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6cfe8acc51bf65a1962afbde311cb185debcaf8/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "567b99c86ed9aa49d20979160613d735555e81f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/567b99c86ed9aa49d20979160613d735555e81f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/567b99c86ed9aa49d20979160613d735555e81f4"}], "stats": {"total": 816, "additions": 709, "deletions": 107}, "files": [{"sha": "54f08a250bffce09bb5bd43f0424e3970aa9ba5d", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6cfe8acc51bf65a1962afbde311cb185debcaf8/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6cfe8acc51bf65a1962afbde311cb185debcaf8/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=b6cfe8acc51bf65a1962afbde311cb185debcaf8", "patch": "@@ -1,3 +1,15 @@\n+2010-11-15  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* objc-act.c (objc_build_setter_call): New.\n+\t(objc_maybe_build_modify_expr): Rewritten to build a compound\n+\tstatement.\n+\t(objc_build_incr_expr_for_property_ref): Updated calls to\n+\tobjc_maybe_build_modify_expr to call objc_build_setter_call\n+\tinstead.  Use build_modify_expr () instead of build2 (MODIFY_EXPR,\n+\t...).  Use convert () instead of build1 (NOP_EXPR, ...).  Use\n+\tTREE_NO_WARNING on the final compound statement to silence C++\n+\twarnings.\n+\n 2010-11-15  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc-act.c (objc_build_incr_expr_for_property_ref): New."}, {"sha": "bfff1d2f110eb347f17e1338fe86cc6091656a48", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 122, "deletions": 35, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6cfe8acc51bf65a1962afbde311cb185debcaf8/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6cfe8acc51bf65a1962afbde311cb185debcaf8/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=b6cfe8acc51bf65a1962afbde311cb185debcaf8", "patch": "@@ -1748,6 +1748,42 @@ objc_is_property_ref (tree node)\n     return false;\n }\n \n+/* This function builds a setter call for a PROPERTY_REF (real, for a\n+   declared property, or artificial, for a dot-syntax accessor which\n+   is not corresponding to a property).  'lhs' must be a PROPERTY_REF\n+   (the caller must check this beforehand).  'rhs' is the value to\n+   assign to the property.  A plain setter call is returned, or\n+   error_mark_node if the property is readonly.  */\n+\n+static tree\n+objc_build_setter_call (tree lhs, tree rhs)\n+{\n+  tree object_expr = PROPERTY_REF_OBJECT (lhs);\n+  tree property_decl = PROPERTY_REF_PROPERTY_DECL (lhs);\n+  \n+  if (PROPERTY_READONLY (property_decl))\n+    {\n+      error (\"readonly property can not be set\");\t  \n+      return error_mark_node;\n+    }\n+  else\n+    {\n+      tree setter_argument = build_tree_list (NULL_TREE, rhs);\n+      tree setter;\n+      \n+      /* TODO: Check that the setter return type is 'void'.  */\n+\n+      /* TODO: Decay arguments in C.  */\n+      setter = objc_finish_message_expr (object_expr, \n+\t\t\t\t\t PROPERTY_SETTER_NAME (property_decl),\n+\t\t\t\t\t setter_argument);\n+      return setter;\n+    }\n+\n+  /* Unreachable, but the compiler may not realize.  */\n+  return error_mark_node;\n+}\n+\n /* This hook routine is called when a MODIFY_EXPR is being built.  We\n    check what is being modified; if it is a PROPERTY_REF, we need to\n    generate a 'setter' function call for the property.  If this is not\n@@ -1767,27 +1803,69 @@ objc_maybe_build_modify_expr (tree lhs, tree rhs)\n {\n   if (lhs && TREE_CODE (lhs) == PROPERTY_REF)\n     {\n-      tree object_expr = PROPERTY_REF_OBJECT (lhs);\n-      tree property_decl = PROPERTY_REF_PROPERTY_DECL (lhs);\n+      /* Building a simple call to the setter method would work for cases such as\n \n-      if (PROPERTY_READONLY (property_decl))\n-\t{\n-\t  error (\"readonly property can not be set\");\t  \n-\t  return error_mark_node;\n-\t}\n-      else\n-\t{\n-\t  tree setter_argument = build_tree_list (NULL_TREE, rhs);\n-\t  tree setter;\n+      object.count = 1;\n \n-\t  /* TODO: Check that the setter return type is 'void'.  */\n+      but wouldn't work for cases such as\n \n-\t  /* TODO: Decay argument in C.  */\n-\t  setter = objc_finish_message_expr (object_expr, \n-\t\t\t\t\t     PROPERTY_SETTER_NAME (property_decl),\n-\t\t\t\t\t     setter_argument);\n-\t  return setter;\n-\t}\n+      count = object2.count = 1;\n+\n+      to get these to work with very little effort, we build a\n+      compound statement which does the setter call (to set the\n+      property to 'rhs'), but which can also be evaluated returning\n+      the 'rhs'.  So, we want to create the following:\n+\n+      (temp = rhs; [object setProperty: temp]; temp)\n+      */\n+      tree temp_variable_decl, bind;\n+      /* s1, s2 and s3 are the tree statements that we need in the\n+\t compound expression.  */\n+      tree s1, s2, s3, compound_expr;\n+      \n+      /* TODO: If 'rhs' is a constant, we could maybe do without the\n+\t 'temp' variable ? */\n+\n+      /* Declare __objc_property_temp in a local bind.  */\n+      temp_variable_decl = objc_create_temporary_var (TREE_TYPE (rhs), \"__objc_property_temp\");\n+      DECL_SOURCE_LOCATION (temp_variable_decl) = input_location;\n+      bind = build3 (BIND_EXPR, void_type_node, temp_variable_decl, NULL, NULL);\n+      SET_EXPR_LOCATION (bind, input_location);\n+      TREE_SIDE_EFFECTS (bind) = 1;\n+      add_stmt (bind);\n+      \n+      /* Now build the compound statement.  */\n+      \n+      /* s1: __objc_property_temp = rhs */\n+      s1 = build_modify_expr (input_location, temp_variable_decl, NULL_TREE,\n+\t\t\t      NOP_EXPR,\n+\t\t\t      input_location, rhs, NULL_TREE);\n+      SET_EXPR_LOCATION (s1, input_location);\n+  \n+      /* s2: [object setProperty: __objc_property_temp] */\n+      s2 = objc_build_setter_call (lhs, temp_variable_decl);\n+\n+      /* This happens if building the setter failed because the property\n+\t is readonly.  */\n+      if (s2 == error_mark_node)\n+\treturn error_mark_node;\n+\n+      SET_EXPR_LOCATION (s2, input_location);\n+  \n+      /* s3: __objc_property_temp */\n+      s3 = convert (TREE_TYPE (lhs), temp_variable_decl);\n+\n+      /* Now build the compound statement (s1, s2, s3) */\n+      compound_expr = build_compound_expr (input_location, build_compound_expr (input_location, s1, s2), s3);\n+\n+      /* Without this, with -Wall you get a 'valued computed is not\n+\t used' every time there is a \"object.property = x\" where the\n+\t value of the resulting MODIFY_EXPR is not used.  That is\n+\t correct (maybe a more sophisticated implementation could\n+\t avoid generating the compound expression if not needed), but\n+\t we need to turn it off.  */\n+      TREE_NO_WARNING (compound_expr) = 1;\n+      return compound_expr;\n     }\n   else\n     return NULL_TREE;\n@@ -1821,7 +1899,7 @@ objc_build_incr_expr_for_property_ref (location_t location,\n   tree temp_variable_decl, bind;\n   /* s1, s2 and s3 are the tree statements that we need in the\n      compound expression.  */\n-  tree s1, s2, s3;\n+  tree s1, s2, s3, compound_expr;\n   \n   /* Safety check.  */\n   if (!argument || TREE_CODE (argument) != PROPERTY_REF)\n@@ -1846,43 +1924,48 @@ objc_build_incr_expr_for_property_ref (location_t location,\n     {\n     case PREINCREMENT_EXPR:\t \n       /* __objc_property_temp = [object property] + increment */\n-      s1 = build2 (MODIFY_EXPR, void_type_node, temp_variable_decl,\n-\t\t   build2 (PLUS_EXPR, TREE_TYPE (argument), argument, increment));\n+      s1 = build_modify_expr (location, temp_variable_decl, NULL_TREE,\n+\t\t\t      NOP_EXPR,\n+\t\t\t      location, build2 (PLUS_EXPR, TREE_TYPE (argument), \n+\t\t\t\t\t\targument, increment), NULL_TREE);\n       break;\n     case PREDECREMENT_EXPR:\n       /* __objc_property_temp = [object property] - increment */\n-      s1 = build2 (MODIFY_EXPR, void_type_node, temp_variable_decl,\n-\t\t   build2 (MINUS_EXPR, TREE_TYPE (argument), argument, increment));\n+      s1 = build_modify_expr (location, temp_variable_decl, NULL_TREE,\n+\t\t\t      NOP_EXPR,\n+\t\t\t      location, build2 (MINUS_EXPR, TREE_TYPE (argument), \n+\t\t\t\t\t\targument, increment), NULL_TREE);\n       break;\n     case POSTINCREMENT_EXPR:\n     case POSTDECREMENT_EXPR:\n       /* __objc_property_temp = [object property] */\n-      s1 = build2 (MODIFY_EXPR, void_type_node, temp_variable_decl, argument);\n+      s1 = build_modify_expr (location, temp_variable_decl, NULL_TREE,\n+\t\t\t      NOP_EXPR,\n+\t\t\t      location, argument, NULL_TREE);\n       break;\n     default:\n       gcc_unreachable ();\n     }\n-  SET_EXPR_LOCATION (s1, location);\n   \n   /* s2: [object setProperty: __objc_property_temp <+/- increment>] */\n   switch (code)\n     {\n     case PREINCREMENT_EXPR:\t \n     case PREDECREMENT_EXPR:\n       /* [object setProperty: __objc_property_temp] */\n-      s2 = objc_maybe_build_modify_expr (argument, temp_variable_decl);\n+      s2 = objc_build_setter_call (argument, temp_variable_decl);\n       break;\n     case POSTINCREMENT_EXPR:\n       /* [object setProperty: __objc_property_temp + increment] */\n-      s2 = objc_maybe_build_modify_expr (argument,\n-\t\t\t\t\t build2 (PLUS_EXPR, TREE_TYPE (argument), \n-\t\t\t\t\t\t temp_variable_decl, increment));\n+      s2 = objc_build_setter_call (argument,\n+\t\t\t\t   build2 (PLUS_EXPR, TREE_TYPE (argument), \n+\t\t\t\t\t   temp_variable_decl, increment));\n       break;\n     case POSTDECREMENT_EXPR:\n       /* [object setProperty: __objc_property_temp - increment] */\n-      s2 = objc_maybe_build_modify_expr (argument,\n-\t\t\t\t\t build2 (MINUS_EXPR, TREE_TYPE (argument), \n-\t\t\t\t\t\t temp_variable_decl, increment));\n+      s2 = objc_build_setter_call (argument,\n+\t\t\t\t   build2 (MINUS_EXPR, TREE_TYPE (argument), \n+\t\t\t\t\t   temp_variable_decl, increment));\n       break;\n     default:\n       gcc_unreachable ();\n@@ -1896,11 +1979,15 @@ objc_build_incr_expr_for_property_ref (location_t location,\n   SET_EXPR_LOCATION (s2, location); \n   \n   /* s3: __objc_property_temp */\n-  s3 = build1 (NOP_EXPR, TREE_TYPE (argument), temp_variable_decl);\n-  SET_EXPR_LOCATION (s3, location); \n+  s3 = convert (TREE_TYPE (argument), temp_variable_decl);\n   \n   /* Now build the compound statement (s1, s2, s3) */\n-  return build_compound_expr (location, build_compound_expr (location, s1, s2), s3);\n+  compound_expr = build_compound_expr (location, build_compound_expr (location, s1, s2), s3);\n+\n+  /* Prevent C++ from warning with -Wall that \"right operand of comma\n+     operator has no effect\".  */\n+  TREE_NO_WARNING (compound_expr) = 1;\n+  return compound_expr;\n }\n \n tree"}, {"sha": "a1fdddac84dcc667625decba420452a55c334117", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6cfe8acc51bf65a1962afbde311cb185debcaf8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6cfe8acc51bf65a1962afbde311cb185debcaf8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b6cfe8acc51bf65a1962afbde311cb185debcaf8", "patch": "@@ -1,3 +1,22 @@\n+2010-11-15  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* objc.dg/property/dotsyntax-18.m: New.\n+\t* objc.dg/property/dotsyntax-19.m: New.\n+\t* objc.dg/property/dotsyntax-20.m: New.\n+\t* obj-c++.dg/property/dotsyntax-18.mm: New.\n+\t* obj-c++.dg/property/dotsyntax-19.mm: New.\t\n+\t* obj-c++.dg/property/dotsyntax-20.mm: New.\n+\t* objc.dg/property/dotsyntax-4.m: Removed some unused variables and code.\n+\t* objc.dg/property/dotsyntax-6.m: Same change.\n+\t* objc.dg/property/dotsyntax-16.m: Same change. \n+\t* objc.dg/property/dotsyntax-17.m: Same change.\n+\t* obj-c++.dg/property/dotsyntax-4.mm: Same change.\n+\t* obj-c++.dg/property/dotsyntax-6.mm: Same change.\n+\t* obj-c++.dg/property/dotsyntax-16.mm: Same change. \n+\t* obj-c++.dg/property/dotsyntax-17.mm: Same change.\n+\t* objc.dg/property/at-property-22.m: Added missing casts.\n+\t* obj-c++.dg/property/at-property-22.mm: Same change.\n+\t\n 2010-11-15  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/46491"}, {"sha": "03b3d0bb48e2ba06c8610d45c742c36b0c33611f", "filename": "gcc/testsuite/obj-c++.dg/property/at-property-22.mm", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6cfe8acc51bf65a1962afbde311cb185debcaf8/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-22.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6cfe8acc51bf65a1962afbde311cb185debcaf8/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-22.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-22.mm?ref=b6cfe8acc51bf65a1962afbde311cb185debcaf8", "patch": "@@ -128,31 +128,31 @@ int main (void)\n   if (object.penum != Black)\n     abort ();\n \n-  object.pcharp = 0;\n+  object.pcharp = (char *)0;\n   if (object.pcharp != 0)\n     abort ();\n   \n-  object.pshortp = 0;\n+  object.pshortp = (short *)0;\n   if (object.pshortp != 0)\n     abort ();\n \n-  object.pintp = 0;\n+  object.pintp = (int *)0;\n   if (object.pintp != 0)\n     abort ();\n     \n-  object.plongp = 0;\n+  object.plongp = (long *)0;\n   if (object.plongp != 0)\n     abort ();\n     \n-  object.pfloatp = 0;\n+  object.pfloatp = (float *)0;\n   if (object.pfloatp != 0)\n     abort ();\n     \n-  object.pdoublep = 0;\n+  object.pdoublep = (double *)0;\n   if (object.pdoublep != 0)\n     abort ();\n     \n-  object.penump = 0;\n+  object.penump = (enum colour *)0;\n   if (object.penump != 0)\n     abort ();\n "}, {"sha": "893db69d9807591bfb7b8a32f4fb91c95495102b", "filename": "gcc/testsuite/obj-c++.dg/property/dotsyntax-16.mm", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6cfe8acc51bf65a1962afbde311cb185debcaf8/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-16.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6cfe8acc51bf65a1962afbde311cb185debcaf8/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-16.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-16.mm?ref=b6cfe8acc51bf65a1962afbde311cb185debcaf8", "patch": "@@ -37,7 +37,6 @@ - (void) setCount: (int)count\n int main (void)\n {\n   MyRootClass *object = [[MyRootClass alloc] init];\n-  int i;\n \n   object.count = 10;\n   if (object.count != 10)"}, {"sha": "c28e11f484b59747489db5ed74c359fd70d29d6a", "filename": "gcc/testsuite/obj-c++.dg/property/dotsyntax-17.mm", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6cfe8acc51bf65a1962afbde311cb185debcaf8/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-17.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6cfe8acc51bf65a1962afbde311cb185debcaf8/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-17.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-17.mm?ref=b6cfe8acc51bf65a1962afbde311cb185debcaf8", "patch": "@@ -34,7 +34,6 @@ - (void) setWriteOnlyCount: (int)value\n int main (void)\n {\n   MyRootClass *object = [[MyRootClass alloc] init];\n-  int i;\n \n   object.count = 10; /* { dg-error \"readonly property can not be set\" } */\n   if (object.count != 10) /* Ok */"}, {"sha": "5697d311d27b24e3f084352eb28cc2ca92c5e522", "filename": "gcc/testsuite/obj-c++.dg/property/dotsyntax-18.mm", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6cfe8acc51bf65a1962afbde311cb185debcaf8/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-18.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6cfe8acc51bf65a1962afbde311cb185debcaf8/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-18.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-18.mm?ref=b6cfe8acc51bf65a1962afbde311cb185debcaf8", "patch": "@@ -0,0 +1,90 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do run } */\n+/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* Test dot-syntax with tricky assignments.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+  int a;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+- (int) count;\n+- (void) setCount: (int)count;\n+- (int) somethingToExecuteOnlyOnce;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+- (int) count\n+{\n+  return a;\n+}\n+- (void) setCount: (int)count\n+{\n+  a = count;\n+}\n+- (int) somethingToExecuteOnlyOnce\n+{\n+  a++;\n+  return 10;\n+}\n+@end\n+\n+int main (void)\n+{\n+  MyRootClass *object1 = [[MyRootClass alloc] init];\n+  MyRootClass *object2 = [[MyRootClass alloc] init];\n+  MyRootClass *object3 = [[MyRootClass alloc] init];\n+  int i;\n+\n+  object1.count = 10;\n+  if (object1.count != 10)\n+    abort ();\n+\n+  object2.count = 10;\n+  if (object2.count != 10)\n+    abort ();\n+\n+  /* Test multiple assignments to a constant.  */\n+  object1.count = object2.count = 20;\n+\n+  if (object1.count != 20 || object2.count != 20)\n+    abort ();\n+\n+  i = object1.count = 30;\n+\n+  if (i != 30 || object1.count != 30)\n+    abort ();\n+\n+  i = object2.count = 30;\n+\n+  if (i != 30 || object2.count != 30)\n+    abort ();\n+\n+  /* Test a simple assignment to something with a side-effect; the\n+     'rhs' should be evaluated only once.  */\n+  object1.count = ([object2 somethingToExecuteOnlyOnce] > 0 ? 30 : 45);\n+\n+  if (object1.count != 30 || object2.count != 31)\n+    abort ();\n+\n+  /* Test multiple assignments with side effects.  */\n+  object3.count = object1.count = ([object2 somethingToExecuteOnlyOnce] > 0 ? 30 : 45);\n+\n+  if (object1.count != 30 || object2.count != 32 || object3.count != 30)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+"}, {"sha": "df4867b0ad3eb5c10aa7f944234b6d3112472526", "filename": "gcc/testsuite/obj-c++.dg/property/dotsyntax-19.mm", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6cfe8acc51bf65a1962afbde311cb185debcaf8/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-19.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6cfe8acc51bf65a1962afbde311cb185debcaf8/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-19.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-19.mm?ref=b6cfe8acc51bf65a1962afbde311cb185debcaf8", "patch": "@@ -0,0 +1,113 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do run } */\n+/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* Test dot-syntax with more tricky assignments.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+  id a;\n+  id b;\n+  int p1;\n+  float p2;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+\n+@property (assign) id object1;\n+@property (assign) id object2;\n+- (id) test;\n+- (id) myself;\n+- (id) nilObject;\n+\n+@property int p1;\n+@property float p2;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+@synthesize object1 = a;\n+@synthesize object2 = b;\n+- (id) test\n+{\n+  /* Test multiple assignments with 'self'.  */\n+  self.object1 = self.object2 = self;\n+\n+  if (self.object1 != self || self.object2 != self)\n+    abort ();\n+\n+  /* Test multiple assignments with a conditional and method calls.  */\n+  self.object1 = self.object2 = (self ? [self myself] : [self nilObject]);\n+\n+  if (self.object1 != self || self.object2 != self)\n+    abort ();\n+\n+  self.object1 = self.object2 = (self ? [self nilObject] : [self myself]);\n+\n+  if (self.object1 != nil || self.object2 != nil)\n+    abort ();\n+\n+  return self.object1;\n+}\n+- (id) myself\n+{\n+  return self;\n+}\n+- (id) nilObject\n+{\n+  return nil;\n+}\n+\n+@synthesize p1;\n+@synthesize p2;\n+@end\n+\n+int main (void)\n+{\n+  MyRootClass *object = [[MyRootClass alloc] init];\n+  MyRootClass *object1 = [[MyRootClass alloc] init];\n+\n+  [object test];\n+\n+  /* Now, test multiple assignments with different types.  Use\n+     int/float as they seem to happily crash the compiler in gimplify\n+     if proper conversions are not being generated by the\n+     frontend. ;-) */\n+  object.p1 = object.p2 = 12;\n+\n+  if (object.p1 != 12 || object.p2 != 12)\n+    abort ();\n+\n+  object.p1 = object.p2 = 2.7;\n+\n+  if (object.p1 != 2)\n+    abort ();\n+\n+  /* Just try a different loop, mixing in a few different standard C\n+     constructs to cover a few other cases.  */\n+  object.p1 = 10;\n+  object1.p1 = 0;\n+  while (object.p1)\n+    {\n+      object1.p1 += ((object.p2 = 4.56) ? 0 : object.p1);\n+      object.p1--;\n+    }\n+\n+  if (object.p1 != 0 || object1.p1 != 0)\n+    abort ();\n+\n+  if ((object.p1 = 0))\n+    abort ();\n+\n+  return 0;\n+}\n+\n+"}, {"sha": "2bddb7c6b96a676ba5fdb4597c393b4f5244124b", "filename": "gcc/testsuite/obj-c++.dg/property/dotsyntax-20.mm", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6cfe8acc51bf65a1962afbde311cb185debcaf8/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-20.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6cfe8acc51bf65a1962afbde311cb185debcaf8/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-20.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-20.mm?ref=b6cfe8acc51bf65a1962afbde311cb185debcaf8", "patch": "@@ -0,0 +1,67 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wall\" } */\n+\n+/* Test warnings with the dot-syntax.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+  id a;\n+  id b;\n+  int p1;\n+  int p2;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+\n+@property int p1;\n+@property int p2;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+@synthesize p1;\n+@synthesize p2;\n+@end\n+\n+int main (void)\n+{\n+  MyRootClass *object = [[MyRootClass alloc] init];\n+\n+  /* First, test that the artificial code generated by dot-syntax does\n+     not generate unexpected warnings.  */\n+\n+  /* All of the following should generate no warnings.  */\n+  object.p1 = 0;\n+  object.p2 = 0;\n+  object.p1 = object.p2 = 0;\n+  if (object.p1 > 0)\n+    object.p2 = 0;\n+  \n+  object.p1++;\n+  ++object.p1;\n+  object.p1--;\n+  --object.p1;\n+  \n+  while (object.p1)\n+    object.p1--;\n+\n+  /* Now test some warnings.  */\n+  object.p1; /* This warning does not seem to be produced in C++.  dg-warning \"value computed is not used\" */\n+\n+  /* TODO: It would be good to get the following to warn.  */\n+  if (object.p1 = 0) /* dg-warning \"suggest parentheses around assignment used as truth value\" */\n+    abort ();\n+\n+  return 0;\n+}\n+\n+"}, {"sha": "2e918d28215f32a030e2aa1e6e9a95d523f1672c", "filename": "gcc/testsuite/obj-c++.dg/property/dotsyntax-4.mm", "status": "modified", "additions": 2, "deletions": 27, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6cfe8acc51bf65a1962afbde311cb185debcaf8/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-4.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6cfe8acc51bf65a1962afbde311cb185debcaf8/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-4.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-4.mm?ref=b6cfe8acc51bf65a1962afbde311cb185debcaf8", "patch": "@@ -9,48 +9,23 @@\n #include <objc/objc.h>\n #include <objc/runtime.h>\n \n-static int a;\n-static id b;\n-\n @interface MyRootClass\n {\n   Class isa;\n }\n + (id) initialize;\n + (id) alloc;\n - (id) init;\n-+ (int) count;\n-+ (void) setCount: (int)value;\n-+ (id) next;\n-+ (void) setNext: (id)value;\n @end\n \n @implementation MyRootClass\n + (id) initialize { return self; }\n + (id) alloc { return class_createInstance (self, 0); }\n - (id) init { return self; }\n-+ (int) count\n-{\n-  return a;\n-}\n-+ (void) setCount: (int)value\n-{\n-  a = value;\n-}\n-+ (id) next\n-{\n-  return b;\n-}\n-+ (void) setNext: (id)value\n-{\n-  b = value;\n-}\n @end\n \n int main (void)\n {\n-  MyRootClass *object = [[MyRootClass alloc] init];\n-\n   MyRootClass.invalid = 40;      /* { dg-error \"could not find setter.getter\" } */\n   if (MyRootClass.invalid != 40) /* { dg-error \"could not find setter.getter\" } */\n     abort ();\n@@ -60,9 +35,9 @@ int main (void)\n     abort ();\n \n   MyRootClass.int;        /* { dg-error \"expected identifier\" } */\n-                          /* { dg-error \"expected\" \"\" { target *-*-* } 62 } */\n+                          /* { dg-error \"expected\" \"\" { target *-*-* } 37 } */\n   if (MyRootClass.int)    /* { dg-error \"expected identifier\" } */\n-                          /* { dg-error \"expected\" \"\" { target *-*-* } 64 } */\n+                          /* { dg-error \"expected\" \"\" { target *-*-* } 39 } */\n     abort ();\n \n   return 0;"}, {"sha": "7ecd34e3d0b6c32920e395e0b99c8d038e186b1f", "filename": "gcc/testsuite/obj-c++.dg/property/dotsyntax-6.mm", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6cfe8acc51bf65a1962afbde311cb185debcaf8/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-6.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6cfe8acc51bf65a1962afbde311cb185debcaf8/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-6.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-6.mm?ref=b6cfe8acc51bf65a1962afbde311cb185debcaf8", "patch": "@@ -10,7 +10,6 @@\n \n @class MyRootClass;\n \n-static int c;\n static MyRootClass *shared_root = nil;\n \n @interface MyRootClass"}, {"sha": "03b3d0bb48e2ba06c8610d45c742c36b0c33611f", "filename": "gcc/testsuite/objc.dg/property/at-property-22.m", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6cfe8acc51bf65a1962afbde311cb185debcaf8/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-22.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6cfe8acc51bf65a1962afbde311cb185debcaf8/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-22.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-22.m?ref=b6cfe8acc51bf65a1962afbde311cb185debcaf8", "patch": "@@ -128,31 +128,31 @@ int main (void)\n   if (object.penum != Black)\n     abort ();\n \n-  object.pcharp = 0;\n+  object.pcharp = (char *)0;\n   if (object.pcharp != 0)\n     abort ();\n   \n-  object.pshortp = 0;\n+  object.pshortp = (short *)0;\n   if (object.pshortp != 0)\n     abort ();\n \n-  object.pintp = 0;\n+  object.pintp = (int *)0;\n   if (object.pintp != 0)\n     abort ();\n     \n-  object.plongp = 0;\n+  object.plongp = (long *)0;\n   if (object.plongp != 0)\n     abort ();\n     \n-  object.pfloatp = 0;\n+  object.pfloatp = (float *)0;\n   if (object.pfloatp != 0)\n     abort ();\n     \n-  object.pdoublep = 0;\n+  object.pdoublep = (double *)0;\n   if (object.pdoublep != 0)\n     abort ();\n     \n-  object.penump = 0;\n+  object.penump = (enum colour *)0;\n   if (object.penump != 0)\n     abort ();\n "}, {"sha": "893db69d9807591bfb7b8a32f4fb91c95495102b", "filename": "gcc/testsuite/objc.dg/property/dotsyntax-16.m", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6cfe8acc51bf65a1962afbde311cb185debcaf8/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-16.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6cfe8acc51bf65a1962afbde311cb185debcaf8/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-16.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-16.m?ref=b6cfe8acc51bf65a1962afbde311cb185debcaf8", "patch": "@@ -37,7 +37,6 @@ - (void) setCount: (int)count\n int main (void)\n {\n   MyRootClass *object = [[MyRootClass alloc] init];\n-  int i;\n \n   object.count = 10;\n   if (object.count != 10)"}, {"sha": "c28e11f484b59747489db5ed74c359fd70d29d6a", "filename": "gcc/testsuite/objc.dg/property/dotsyntax-17.m", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6cfe8acc51bf65a1962afbde311cb185debcaf8/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-17.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6cfe8acc51bf65a1962afbde311cb185debcaf8/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-17.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-17.m?ref=b6cfe8acc51bf65a1962afbde311cb185debcaf8", "patch": "@@ -34,7 +34,6 @@ - (void) setWriteOnlyCount: (int)value\n int main (void)\n {\n   MyRootClass *object = [[MyRootClass alloc] init];\n-  int i;\n \n   object.count = 10; /* { dg-error \"readonly property can not be set\" } */\n   if (object.count != 10) /* Ok */"}, {"sha": "5697d311d27b24e3f084352eb28cc2ca92c5e522", "filename": "gcc/testsuite/objc.dg/property/dotsyntax-18.m", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6cfe8acc51bf65a1962afbde311cb185debcaf8/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-18.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6cfe8acc51bf65a1962afbde311cb185debcaf8/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-18.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-18.m?ref=b6cfe8acc51bf65a1962afbde311cb185debcaf8", "patch": "@@ -0,0 +1,90 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do run } */\n+/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* Test dot-syntax with tricky assignments.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+  int a;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+- (int) count;\n+- (void) setCount: (int)count;\n+- (int) somethingToExecuteOnlyOnce;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+- (int) count\n+{\n+  return a;\n+}\n+- (void) setCount: (int)count\n+{\n+  a = count;\n+}\n+- (int) somethingToExecuteOnlyOnce\n+{\n+  a++;\n+  return 10;\n+}\n+@end\n+\n+int main (void)\n+{\n+  MyRootClass *object1 = [[MyRootClass alloc] init];\n+  MyRootClass *object2 = [[MyRootClass alloc] init];\n+  MyRootClass *object3 = [[MyRootClass alloc] init];\n+  int i;\n+\n+  object1.count = 10;\n+  if (object1.count != 10)\n+    abort ();\n+\n+  object2.count = 10;\n+  if (object2.count != 10)\n+    abort ();\n+\n+  /* Test multiple assignments to a constant.  */\n+  object1.count = object2.count = 20;\n+\n+  if (object1.count != 20 || object2.count != 20)\n+    abort ();\n+\n+  i = object1.count = 30;\n+\n+  if (i != 30 || object1.count != 30)\n+    abort ();\n+\n+  i = object2.count = 30;\n+\n+  if (i != 30 || object2.count != 30)\n+    abort ();\n+\n+  /* Test a simple assignment to something with a side-effect; the\n+     'rhs' should be evaluated only once.  */\n+  object1.count = ([object2 somethingToExecuteOnlyOnce] > 0 ? 30 : 45);\n+\n+  if (object1.count != 30 || object2.count != 31)\n+    abort ();\n+\n+  /* Test multiple assignments with side effects.  */\n+  object3.count = object1.count = ([object2 somethingToExecuteOnlyOnce] > 0 ? 30 : 45);\n+\n+  if (object1.count != 30 || object2.count != 32 || object3.count != 30)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+"}, {"sha": "df4867b0ad3eb5c10aa7f944234b6d3112472526", "filename": "gcc/testsuite/objc.dg/property/dotsyntax-19.m", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6cfe8acc51bf65a1962afbde311cb185debcaf8/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-19.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6cfe8acc51bf65a1962afbde311cb185debcaf8/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-19.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-19.m?ref=b6cfe8acc51bf65a1962afbde311cb185debcaf8", "patch": "@@ -0,0 +1,113 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do run } */\n+/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* Test dot-syntax with more tricky assignments.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+  id a;\n+  id b;\n+  int p1;\n+  float p2;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+\n+@property (assign) id object1;\n+@property (assign) id object2;\n+- (id) test;\n+- (id) myself;\n+- (id) nilObject;\n+\n+@property int p1;\n+@property float p2;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+@synthesize object1 = a;\n+@synthesize object2 = b;\n+- (id) test\n+{\n+  /* Test multiple assignments with 'self'.  */\n+  self.object1 = self.object2 = self;\n+\n+  if (self.object1 != self || self.object2 != self)\n+    abort ();\n+\n+  /* Test multiple assignments with a conditional and method calls.  */\n+  self.object1 = self.object2 = (self ? [self myself] : [self nilObject]);\n+\n+  if (self.object1 != self || self.object2 != self)\n+    abort ();\n+\n+  self.object1 = self.object2 = (self ? [self nilObject] : [self myself]);\n+\n+  if (self.object1 != nil || self.object2 != nil)\n+    abort ();\n+\n+  return self.object1;\n+}\n+- (id) myself\n+{\n+  return self;\n+}\n+- (id) nilObject\n+{\n+  return nil;\n+}\n+\n+@synthesize p1;\n+@synthesize p2;\n+@end\n+\n+int main (void)\n+{\n+  MyRootClass *object = [[MyRootClass alloc] init];\n+  MyRootClass *object1 = [[MyRootClass alloc] init];\n+\n+  [object test];\n+\n+  /* Now, test multiple assignments with different types.  Use\n+     int/float as they seem to happily crash the compiler in gimplify\n+     if proper conversions are not being generated by the\n+     frontend. ;-) */\n+  object.p1 = object.p2 = 12;\n+\n+  if (object.p1 != 12 || object.p2 != 12)\n+    abort ();\n+\n+  object.p1 = object.p2 = 2.7;\n+\n+  if (object.p1 != 2)\n+    abort ();\n+\n+  /* Just try a different loop, mixing in a few different standard C\n+     constructs to cover a few other cases.  */\n+  object.p1 = 10;\n+  object1.p1 = 0;\n+  while (object.p1)\n+    {\n+      object1.p1 += ((object.p2 = 4.56) ? 0 : object.p1);\n+      object.p1--;\n+    }\n+\n+  if (object.p1 != 0 || object1.p1 != 0)\n+    abort ();\n+\n+  if ((object.p1 = 0))\n+    abort ();\n+\n+  return 0;\n+}\n+\n+"}, {"sha": "f1dd48e612e0f6d9d6f233bbd1ef9adaa9ecd1f5", "filename": "gcc/testsuite/objc.dg/property/dotsyntax-20.m", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6cfe8acc51bf65a1962afbde311cb185debcaf8/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-20.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6cfe8acc51bf65a1962afbde311cb185debcaf8/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-20.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-20.m?ref=b6cfe8acc51bf65a1962afbde311cb185debcaf8", "patch": "@@ -0,0 +1,67 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wall\" } */\n+\n+/* Test warnings with the dot-syntax.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+  id a;\n+  id b;\n+  int p1;\n+  int p2;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+\n+@property int p1;\n+@property int p2;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+@synthesize p1;\n+@synthesize p2;\n+@end\n+\n+int main (void)\n+{\n+  MyRootClass *object = [[MyRootClass alloc] init];\n+\n+  /* First, test that the artificial code generated by dot-syntax does\n+     not generate unexpected warnings.  */\n+\n+  /* All of the following should generate no warnings.  */\n+  object.p1 = 0;\n+  object.p2 = 0;\n+  object.p1 = object.p2 = 0;\n+  if (object.p1 > 0)\n+    object.p2 = 0;\n+  \n+  object.p1++;\n+  ++object.p1;\n+  object.p1--;\n+  --object.p1;\n+  \n+  while (object.p1)\n+    object.p1--;\n+\n+  /* Now test some warnings.  */\n+  object.p1; /* { dg-warning \"value computed is not used\" } */\n+\n+  /* TODO: It would be good to get the following to warn.  */\n+  if (object.p1 = 0) /* dg-warning \"suggest parentheses around assignment used as truth value\" */\n+    abort ();\n+\n+  return 0;\n+}\n+\n+"}, {"sha": "2db067f1fd52f7b8f4c89cab9acd567433af7536", "filename": "gcc/testsuite/objc.dg/property/dotsyntax-4.m", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6cfe8acc51bf65a1962afbde311cb185debcaf8/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-4.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6cfe8acc51bf65a1962afbde311cb185debcaf8/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-4.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-4.m?ref=b6cfe8acc51bf65a1962afbde311cb185debcaf8", "patch": "@@ -9,48 +9,23 @@\n #include <objc/objc.h>\n #include <objc/runtime.h>\n \n-static int a;\n-static id b;\n-\n @interface MyRootClass\n {\n   Class isa;\n }\n + (id) initialize;\n + (id) alloc;\n - (id) init;\n-+ (int) count;\n-+ (void) setCount: (int)value;\n-+ (id) next;\n-+ (void) setNext: (id)value;\n @end\n \n @implementation MyRootClass\n + (id) initialize { return self; }\n + (id) alloc { return class_createInstance (self, 0); }\n - (id) init { return self; }\n-+ (int) count\n-{\n-  return a;\n-}\n-+ (void) setCount: (int)value\n-{\n-  a = value;\n-}\n-+ (id) next\n-{\n-  return b;\n-}\n-+ (void) setNext: (id)value\n-{\n-  b = value;\n-}\n @end\n \n int main (void)\n {\n-  MyRootClass *object = [[MyRootClass alloc] init];\n-\n   MyRootClass.invalid = 40;      /* { dg-error \"could not find setter.getter\" } */\n   if (MyRootClass.invalid != 40) /* { dg-error \"could not find setter.getter\" } */\n     abort ();"}, {"sha": "7ecd34e3d0b6c32920e395e0b99c8d038e186b1f", "filename": "gcc/testsuite/objc.dg/property/dotsyntax-6.m", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6cfe8acc51bf65a1962afbde311cb185debcaf8/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-6.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6cfe8acc51bf65a1962afbde311cb185debcaf8/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-6.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-6.m?ref=b6cfe8acc51bf65a1962afbde311cb185debcaf8", "patch": "@@ -10,7 +10,6 @@\n \n @class MyRootClass;\n \n-static int c;\n static MyRootClass *shared_root = nil;\n \n @interface MyRootClass"}]}