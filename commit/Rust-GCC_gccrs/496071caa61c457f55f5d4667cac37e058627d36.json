{"sha": "496071caa61c457f55f5d4667cac37e058627d36", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDk2MDcxY2FhNjFjNDU3ZjU1ZjVkNDY2N2NhYzM3ZTA1ODYyN2QzNg==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2008-09-09T16:52:55Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2008-09-09T16:52:55Z"}, "message": "ira-conflicts.c (process_regs_for_copy): Check that the hard regno is in the right range.\n\n2008-09-09  Vladimir Makarov  <vmakarov@redhat.com>\n\n\t* ira-conflicts.c (process_regs_for_copy): Check that the hard\n\tregno is in the right range.  Add comments.\n\nFrom-SVN: r140159", "tree": {"sha": "2998213a038cd9de815dbf3b6b46d6692b8023b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2998213a038cd9de815dbf3b6b46d6692b8023b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/496071caa61c457f55f5d4667cac37e058627d36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/496071caa61c457f55f5d4667cac37e058627d36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/496071caa61c457f55f5d4667cac37e058627d36", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/496071caa61c457f55f5d4667cac37e058627d36/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1f57487cf037ee3d06beab4b6dfc6a2dddb9a878", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f57487cf037ee3d06beab4b6dfc6a2dddb9a878", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f57487cf037ee3d06beab4b6dfc6a2dddb9a878"}], "stats": {"total": 21, "additions": 16, "deletions": 5}, "files": [{"sha": "cfa7b26a4eced4002f8ecbd7b96f32c7807d611f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/496071caa61c457f55f5d4667cac37e058627d36/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/496071caa61c457f55f5d4667cac37e058627d36/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=496071caa61c457f55f5d4667cac37e058627d36", "patch": "@@ -1,3 +1,8 @@\n+2008-09-09  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* ira-conflicts.c (process_regs_for_copy): Check that the hard\n+\tregno is in the right range.  Add comments.\n+\n 2008-09-09  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>\n \n \t* Makefile.in (mips-tfile.o-warn): Don't error out on mips-tfile.c"}, {"sha": "e467a7c60ee71da64f22894848bcab72f84a3751", "filename": "gcc/ira-conflicts.c", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/496071caa61c457f55f5d4667cac37e058627d36/gcc%2Fira-conflicts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/496071caa61c457f55f5d4667cac37e058627d36/gcc%2Fira-conflicts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-conflicts.c?ref=496071caa61c457f55f5d4667cac37e058627d36", "patch": "@@ -331,7 +331,7 @@ go_through_subreg (rtx x, int *offset)\n static bool\n process_regs_for_copy (rtx reg1, rtx reg2, rtx insn, int freq)\n {\n-  int hard_regno, cost, index, offset1, offset2;\n+  int allocno_preferenced_hard_regno, cost, index, offset1, offset2;\n   bool only_regs_p;\n   ira_allocno_t a;\n   enum reg_class rclass, cover_class;\n@@ -342,16 +342,18 @@ process_regs_for_copy (rtx reg1, rtx reg2, rtx insn, int freq)\n   only_regs_p = REG_P (reg1) && REG_P (reg2);\n   reg1 = go_through_subreg (reg1, &offset1);\n   reg2 = go_through_subreg (reg2, &offset2);\n+  /* Set up hard regno preferenced by allocno.  If allocno gets the\n+     hard regno the copy (or potential move) insn will be removed.  */\n   if (HARD_REGISTER_P (reg1))\n     {\n       if (HARD_REGISTER_P (reg2))\n \treturn false;\n-      hard_regno = REGNO (reg1) + offset1 - offset2;\n+      allocno_preferenced_hard_regno = REGNO (reg1) + offset1 - offset2;\n       a = ira_curr_regno_allocno_map[REGNO (reg2)];\n     }\n   else if (HARD_REGISTER_P (reg2))\n     {\n-      hard_regno = REGNO (reg2) + offset2 - offset1;\n+      allocno_preferenced_hard_regno = REGNO (reg2) + offset2 - offset1;\n       a = ira_curr_regno_allocno_map[REGNO (reg1)];\n     }\n   else if (!CONFLICT_ALLOCNO_P (ira_curr_regno_allocno_map[REGNO (reg1)],\n@@ -366,7 +368,10 @@ process_regs_for_copy (rtx reg1, rtx reg2, rtx insn, int freq)\n     }\n   else\n     return false;\n-  rclass = REGNO_REG_CLASS (hard_regno);\n+  if (! IN_RANGE (allocno_preferenced_hard_regno, 0, FIRST_PSEUDO_REGISTER - 1))\n+    /* Can not be tied.  */\n+    return false;\n+  rclass = REGNO_REG_CLASS (allocno_preferenced_hard_regno);\n   mode = ALLOCNO_MODE (a);\n   cover_class = ALLOCNO_COVER_CLASS (a);\n   if (! ira_class_subset_p[rclass][cover_class])\n@@ -375,8 +380,9 @@ process_regs_for_copy (rtx reg1, rtx reg2, rtx insn, int freq)\n       && reg_class_size[rclass] <= (unsigned) CLASS_MAX_NREGS (rclass, mode))\n     /* It is already taken into account in ira-costs.c.  */\n     return false;\n-  index = ira_class_hard_reg_index[cover_class][hard_regno];\n+  index = ira_class_hard_reg_index[cover_class][allocno_preferenced_hard_regno];\n   if (index < 0)\n+    /* Can not be tied.  It is not in the cover class.  */\n     return false;\n   if (HARD_REGISTER_P (reg1))\n     cost = ira_register_move_cost[mode][cover_class][rclass] * freq;"}]}