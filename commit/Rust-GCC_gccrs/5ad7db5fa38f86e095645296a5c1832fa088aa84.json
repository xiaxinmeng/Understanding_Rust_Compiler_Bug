{"sha": "5ad7db5fa38f86e095645296a5c1832fa088aa84", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWFkN2RiNWZhMzhmODZlMDk1NjQ1Mjk2YTVjMTgzMmZhMDg4YWE4NA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2011-04-19T18:20:05Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-04-19T18:20:05Z"}, "message": "Use backend interface for blocks.\n\n\t* go-gcc.cc (class Bblock): Define.\n\t(Gcc_backend::if_statement): Change then_block and else_block to\n\tBblock*.\n\t(Gcc_backend::block): New function.\n\t(Gcc_backend::block_add_statements): New function.\n\t(Gcc_backend::block_statement): New function.\n\t(tree_to_block, block_to_tree): New functions.\n\nFrom-SVN: r172731", "tree": {"sha": "bd78a56617f782bc1b6bc7acb061e27f107b8285", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd78a56617f782bc1b6bc7acb061e27f107b8285"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5ad7db5fa38f86e095645296a5c1832fa088aa84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ad7db5fa38f86e095645296a5c1832fa088aa84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ad7db5fa38f86e095645296a5c1832fa088aa84", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ad7db5fa38f86e095645296a5c1832fa088aa84/comments", "author": null, "committer": null, "parents": [{"sha": "f7d2e5d418d88cccfd1d54daebd57de464d9bd92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7d2e5d418d88cccfd1d54daebd57de464d9bd92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7d2e5d418d88cccfd1d54daebd57de464d9bd92"}], "stats": {"total": 430, "additions": 292, "deletions": 138}, "files": [{"sha": "4fe9b4618cf5f17602c7edfd77eb272732130070", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ad7db5fa38f86e095645296a5c1832fa088aa84/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ad7db5fa38f86e095645296a5c1832fa088aa84/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=5ad7db5fa38f86e095645296a5c1832fa088aa84", "patch": "@@ -1,3 +1,13 @@\n+2011-04-19  Ian Lance Taylor  <iant@google.com>\n+\n+\t* go-gcc.cc (class Bblock): Define.\n+\t(Gcc_backend::if_statement): Change then_block and else_block to\n+\tBblock*.\n+\t(Gcc_backend::block): New function.\n+\t(Gcc_backend::block_add_statements): New function.\n+\t(Gcc_backend::block_statement): New function.\n+\t(tree_to_block, block_to_tree): New functions.\n+\n 2011-04-18  Ian Lance Taylor  <iant@google.com>\n \n \t* go-gcc.cc: Include \"go-c.h\"."}, {"sha": "46c149cd3cbc2b3c733a879d5fa37b2ad48300e1", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 145, "deletions": 4, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ad7db5fa38f86e095645296a5c1832fa088aa84/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ad7db5fa38f86e095645296a5c1832fa088aa84/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=5ad7db5fa38f86e095645296a5c1832fa088aa84", "patch": "@@ -92,6 +92,14 @@ class Bfunction : public Gcc_tree\n   { }\n };\n \n+class Bblock : public Gcc_tree\n+{\n+ public:\n+  Bblock(tree t)\n+    : Gcc_tree(t)\n+  { }\n+};\n+\n class Bvariable : public Gcc_tree\n {\n  public:\n@@ -194,8 +202,8 @@ class Gcc_backend : public Backend\n \t\t   source_location);\n \n   Bstatement*\n-  if_statement(Bexpression* condition, Bstatement* then_block,\n-\t       Bstatement* else_block, source_location);\n+  if_statement(Bexpression* condition, Bblock* then_block, Bblock* else_block,\n+\t       source_location);\n \n   Bstatement*\n   switch_statement(Bexpression* value,\n@@ -209,6 +217,18 @@ class Gcc_backend : public Backend\n   Bstatement*\n   statement_list(const std::vector<Bstatement*>&);\n \n+  // Blocks.\n+\n+  Bblock*\n+  block(Bfunction*, Bblock*, const std::vector<Bvariable*>&,\n+\tsource_location, source_location);\n+\n+  void\n+  block_add_statements(Bblock*, const std::vector<Bstatement*>&);\n+\n+  Bstatement*\n+  block_statement(Bblock*);\n+\n   // Variables.\n \n   Bvariable*\n@@ -370,8 +390,8 @@ Gcc_backend::return_statement(Bfunction* bfunction,\n // If.\n \n Bstatement*\n-Gcc_backend::if_statement(Bexpression* condition, Bstatement* then_block,\n-\t\t\t  Bstatement* else_block, source_location location)\n+Gcc_backend::if_statement(Bexpression* condition, Bblock* then_block,\n+\t\t\t  Bblock* else_block, source_location location)\n {\n   tree cond_tree = condition->get_tree();\n   tree then_tree = then_block->get_tree();\n@@ -481,6 +501,114 @@ Gcc_backend::statement_list(const std::vector<Bstatement*>& statements)\n   return this->make_statement(stmt_list);\n }\n \n+// Make a block.  For some reason gcc uses a dual structure for\n+// blocks: BLOCK tree nodes and BIND_EXPR tree nodes.  Since the\n+// BIND_EXPR node points to the BLOCK node, we store the BIND_EXPR in\n+// the Bblock.\n+\n+Bblock*\n+Gcc_backend::block(Bfunction* function, Bblock* enclosing,\n+\t\t   const std::vector<Bvariable*>& vars,\n+\t\t   source_location start_location,\n+\t\t   source_location)\n+{\n+  tree block_tree = make_node(BLOCK);\n+  if (enclosing == NULL)\n+    {\n+      // FIXME: Permitting FUNCTION to be NULL is a temporary measure\n+      // until we have a proper representation of the init function.\n+      tree fndecl;\n+      if (function == NULL)\n+\tfndecl = current_function_decl;\n+      else\n+\tfndecl = function->get_tree();\n+      gcc_assert(fndecl != NULL_TREE);\n+\n+      // We may have already created a block for local variables when\n+      // we take the address of a parameter.\n+      if (DECL_INITIAL(fndecl) == NULL_TREE)\n+\t{\n+\t  BLOCK_SUPERCONTEXT(block_tree) = fndecl;\n+\t  DECL_INITIAL(fndecl) = block_tree;\n+\t}\n+      else\n+\t{\n+\t  tree superblock_tree = DECL_INITIAL(fndecl);\n+\t  BLOCK_SUPERCONTEXT(block_tree) = superblock_tree;\n+\t  tree* pp;\n+\t  for (pp = &BLOCK_SUBBLOCKS(superblock_tree);\n+\t       *pp != NULL_TREE;\n+\t       pp = &BLOCK_CHAIN(*pp))\n+\t    ;\n+\t  *pp = block_tree;\n+\t}\n+    }\n+  else\n+    {\n+      tree superbind_tree = enclosing->get_tree();\n+      tree superblock_tree = BIND_EXPR_BLOCK(superbind_tree);\n+      gcc_assert(TREE_CODE(superblock_tree) == BLOCK);\n+\n+      BLOCK_SUPERCONTEXT(block_tree) = superblock_tree;\n+      tree* pp;\n+      for (pp = &BLOCK_SUBBLOCKS(superblock_tree);\n+\t   *pp != NULL_TREE;\n+\t   pp = &BLOCK_CHAIN(*pp))\n+\t;\n+      *pp = block_tree;\n+    }\n+\n+  tree* pp = &BLOCK_VARS(block_tree);\n+  for (std::vector<Bvariable*>::const_iterator pv = vars.begin();\n+       pv != vars.end();\n+       ++pv)\n+    {\n+      *pp = (*pv)->get_tree();\n+      if (*pp != error_mark_node)\n+\tpp = &DECL_CHAIN(*pp);\n+    }\n+  *pp = NULL_TREE;\n+\n+  TREE_USED(block_tree) = 1;\n+\n+  tree bind_tree = build3_loc(start_location, BIND_EXPR, void_type_node,\n+\t\t\t      BLOCK_VARS(block_tree), NULL_TREE, block_tree);\n+  TREE_SIDE_EFFECTS(bind_tree) = 1;\n+\n+  return new Bblock(bind_tree);\n+}\n+\n+// Add statements to a block.\n+\n+void\n+Gcc_backend::block_add_statements(Bblock* bblock,\n+\t\t\t\t  const std::vector<Bstatement*>& statements)\n+{\n+  tree stmt_list = NULL_TREE;\n+  for (std::vector<Bstatement*>::const_iterator p = statements.begin();\n+       p != statements.end();\n+       ++p)\n+    {\n+      tree s = (*p)->get_tree();\n+      if (s != error_mark_node)\n+\tappend_to_statement_list(s, &stmt_list);\n+    }\n+\n+  tree bind_tree = bblock->get_tree();\n+  gcc_assert(TREE_CODE(bind_tree) == BIND_EXPR);\n+  BIND_EXPR_BODY(bind_tree) = stmt_list;\n+}\n+\n+// Return a block as a statement.\n+\n+Bstatement*\n+Gcc_backend::block_statement(Bblock* bblock)\n+{\n+  tree bind_tree = bblock->get_tree();\n+  gcc_assert(TREE_CODE(bind_tree) == BIND_EXPR);\n+  return this->make_statement(bind_tree);\n+}\n+\n // Make a global variable.\n \n Bvariable*\n@@ -665,6 +793,13 @@ tree_to_function(tree t)\n   return new Bfunction(t);\n }\n \n+Bblock*\n+tree_to_block(tree t)\n+{\n+  gcc_assert(TREE_CODE(t) == BIND_EXPR);\n+  return new Bblock(t);\n+}\n+\n tree\n expr_to_tree(Bexpression* be)\n {\n@@ -677,6 +812,12 @@ stat_to_tree(Bstatement* bs)\n   return bs->get_tree();\n }\n \n+tree\n+block_to_tree(Bblock* bb)\n+{\n+  return bb->get_tree();\n+}\n+\n tree\n var_to_tree(Bvariable* bv)\n {"}, {"sha": "6690a5238dcc6ed7e6b6cc1912e86e667c276ab7", "filename": "gcc/go/gofrontend/backend.h", "status": "modified", "additions": 36, "deletions": 2, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ad7db5fa38f86e095645296a5c1832fa088aa84/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ad7db5fa38f86e095645296a5c1832fa088aa84/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fbackend.h?ref=5ad7db5fa38f86e095645296a5c1832fa088aa84", "patch": "@@ -27,6 +27,9 @@ class Bstatement;\n // The backend representation of a function definition.\n class Bfunction;\n \n+// The backend representation of a block.\n+class Bblock;\n+\n // The backend representation of a variable.\n class Bvariable;\n \n@@ -139,8 +142,8 @@ class Backend\n \n   // Create an if statement.  ELSE_BLOCK may be NULL.\n   virtual Bstatement*\n-  if_statement(Bexpression* condition, Bstatement* then_block,\n-\t       Bstatement* else_block, source_location) = 0;\n+  if_statement(Bexpression* condition, Bblock* then_block, Bblock* else_block,\n+\t       source_location) = 0;\n \n   // Create a switch statement where the case values are constants.\n   // CASES and STATEMENTS must have the same number of entries.  If\n@@ -163,6 +166,35 @@ class Backend\n   virtual Bstatement*\n   statement_list(const std::vector<Bstatement*>&) = 0;\n \n+  // Blocks.\n+\n+  // Create a block.  The frontend will call this function when it\n+  // starts converting a block within a function.  FUNCTION is the\n+  // current function.  ENCLOSING is the enclosing block; it will be\n+  // NULL for the top-level block in a function.  VARS is the list of\n+  // local variables defined within this block; each entry will be\n+  // created by the local_variable function.  START_LOCATION is the\n+  // location of the start of the block, more or less the location of\n+  // the initial curly brace.  END_LOCATION is the location of the end\n+  // of the block, more or less the location of the final curly brace.\n+  // The statements will be added after the block is created.\n+  virtual Bblock*\n+  block(Bfunction* function, Bblock* enclosing,\n+\tconst std::vector<Bvariable*>& vars,\n+\tsource_location start_location, source_location end_location) = 0;\n+\n+  // Add the statements to a block.  The block is created first.  Then\n+  // the statements are created.  Then the statements are added to the\n+  // block.  This will called exactly once per block.  The vector may\n+  // be empty if there are no statements.\n+  virtual void\n+  block_add_statements(Bblock*, const std::vector<Bstatement*>&) = 0;\n+\n+  // Return the block as a statement.  This is used to include a block\n+  // in a list of statements.\n+  virtual Bstatement*\n+  block_statement(Bblock*) = 0;\n+\n   // Variables.\n \n   // Create an error variable.  This is used for cases which should\n@@ -250,8 +282,10 @@ extern Btype* tree_to_type(tree);\n extern Bexpression* tree_to_expr(tree);\n extern Bstatement* tree_to_stat(tree);\n extern Bfunction* tree_to_function(tree);\n+extern Bblock* tree_to_block(tree);\n extern tree expr_to_tree(Bexpression*);\n extern tree stat_to_tree(Bstatement*);\n+extern tree block_to_tree(Bblock*);\n extern tree var_to_tree(Bvariable*);\n \n #endif // !defined(GO_BACKEND_H)"}, {"sha": "ec06c65a13ebfca18e0e9e2262d8b23557d2a71f", "filename": "gcc/go/gofrontend/gogo-tree.cc", "status": "modified", "additions": 13, "deletions": 100, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ad7db5fa38f86e095645296a5c1832fa088aa84/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ad7db5fa38f86e095645296a5c1832fa088aa84/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc?ref=5ad7db5fa38f86e095645296a5c1832fa088aa84", "patch": "@@ -900,7 +900,7 @@ Named_object::get_tree(Gogo* gogo, Named_object* function)\n     case NAMED_OBJECT_CONST:\n       {\n \tNamed_constant* named_constant = this->u_.const_value;\n-\tTranslate_context subcontext(gogo, function, NULL, NULL_TREE);\n+\tTranslate_context subcontext(gogo, function, NULL, NULL);\n \ttree expr_tree = named_constant->expr()->get_tree(&subcontext);\n \tif (expr_tree == error_mark_node)\n \t  decl = error_mark_node;\n@@ -1038,7 +1038,7 @@ Variable::get_init_tree(Gogo* gogo, Named_object* function)\n     }\n   else\n     {\n-      Translate_context context(gogo, function, NULL, NULL_TREE);\n+      Translate_context context(gogo, function, NULL, NULL);\n       tree rhs_tree = this->init_->get_tree(&context);\n       return Expression::convert_for_assignment(&context, this->type(),\n \t\t\t\t\t\tthis->init_->type(),\n@@ -1059,8 +1059,9 @@ Variable::get_init_block(Gogo* gogo, Named_object* function, tree var_decl)\n   // TRY_CATCH_EXPR; if it does, we want to add to the end of the\n   // regular statements.\n \n-  Translate_context context(gogo, function, NULL, NULL_TREE);\n-  tree block_tree = this->preinit_->get_tree(&context);\n+  Translate_context context(gogo, function, NULL, NULL);\n+  Bblock* bblock = this->preinit_->get_backend(&context);\n+  tree block_tree = block_to_tree(bblock);\n   if (block_tree == error_mark_node)\n     return error_mark_node;\n   gcc_assert(TREE_CODE(block_tree) == BIND_EXPR);\n@@ -1472,21 +1473,22 @@ Function::build_tree(Gogo* gogo, Named_object* named_function)\n \t  BLOCK_VARS(block) = declare_vars;\n \t  TREE_USED(block) = 1;\n \n+\t  bind = build3(BIND_EXPR, void_type_node, BLOCK_VARS(block),\n+\t\t\tNULL_TREE, block);\n+\t  TREE_SIDE_EFFECTS(bind) = 1;\n+\n \t  if (this->defer_stack_ != NULL)\n \t    {\n \t      Translate_context dcontext(gogo, named_function, this->block_,\n-\t\t\t\t\t block);\n+\t\t\t\t\t tree_to_block(bind));\n \t      defer_init = this->defer_stack_->get_tree(&dcontext);\n \t    }\n-\n-\t  bind = build3(BIND_EXPR, void_type_node, BLOCK_VARS(block),\n-\t\t\tNULL_TREE, block);\n-\t  TREE_SIDE_EFFECTS(bind) = 1;\n \t}\n \n       // Build the trees for all the statements in the function.\n-      Translate_context context(gogo, named_function, NULL, NULL_TREE);\n-      tree code = this->block_->get_tree(&context);\n+      Translate_context context(gogo, named_function, NULL, NULL);\n+      Bblock* bblock = this->block_->get_backend(&context);\n+      tree code = block_to_tree(bblock);\n \n       tree init = NULL_TREE;\n       tree except = NULL_TREE;\n@@ -1681,95 +1683,6 @@ Function::return_value(Gogo* gogo, Named_object* named_function,\n     }\n }\n \n-// Get a tree for the statements in a block.\n-\n-tree\n-Block::get_tree(Translate_context* context)\n-{\n-  Gogo* gogo = context->gogo();\n-\n-  tree block = make_node(BLOCK);\n-\n-  // Put the new block into the block tree.\n-\n-  if (context->block() == NULL)\n-    {\n-      tree fndecl;\n-      if (context->function() != NULL)\n-\tfndecl = context->function()->func_value()->get_decl();\n-      else\n-\tfndecl = current_function_decl;\n-      gcc_assert(fndecl != NULL_TREE);\n-\n-      // We may have already created a block for the receiver.\n-      if (DECL_INITIAL(fndecl) == NULL_TREE)\n-\t{\n-\t  BLOCK_SUPERCONTEXT(block) = fndecl;\n-\t  DECL_INITIAL(fndecl) = block;\n-\t}\n-      else\n-\t{\n-\t  tree superblock_tree = DECL_INITIAL(fndecl);\n-\t  BLOCK_SUPERCONTEXT(block) = superblock_tree;\n-\t  gcc_assert(BLOCK_CHAIN(block) == NULL_TREE);\n-\t  BLOCK_CHAIN(block) = block;\n-\t}\n-    }\n-  else\n-    {\n-      tree superblock_tree = context->block_tree();\n-      BLOCK_SUPERCONTEXT(block) = superblock_tree;\n-      tree* pp;\n-      for (pp = &BLOCK_SUBBLOCKS(superblock_tree);\n-\t   *pp != NULL_TREE;\n-\t   pp = &BLOCK_CHAIN(*pp))\n-\t;\n-      *pp = block;\n-    }\n-\n-  // Expand local variables in the block.\n-\n-  tree* pp = &BLOCK_VARS(block);\n-  for (Bindings::const_definitions_iterator pv =\n-\t this->bindings_->begin_definitions();\n-       pv != this->bindings_->end_definitions();\n-       ++pv)\n-    {\n-      if ((*pv)->is_variable() && !(*pv)->var_value()->is_parameter())\n-\t{\n-\t  Bvariable* var = (*pv)->get_backend_variable(gogo,\n-\t\t\t\t\t\t       context->function());\n-\t  *pp = var_to_tree(var);\n-\t  if (*pp != error_mark_node)\n-\t    pp = &DECL_CHAIN(*pp);\n-\t}\n-    }\n-  *pp = NULL_TREE;\n-\n-  Translate_context subcontext(gogo, context->function(), this, block);\n-\n-  tree statements = NULL_TREE;\n-\n-  // Expand the statements.\n-\n-  for (std::vector<Statement*>::const_iterator p = this->statements_.begin();\n-       p != this->statements_.end();\n-       ++p)\n-    {\n-      tree statement = (*p)->get_tree(&subcontext);\n-      if (statement != error_mark_node)\n-\tappend_to_statement_list(statement, &statements);\n-    }\n-\n-  TREE_USED(block) = 1;\n-\n-  tree bind = build3(BIND_EXPR, void_type_node, BLOCK_VARS(block), statements,\n-\t\t     block);\n-  TREE_SIDE_EFFECTS(bind) = 1;\n-\n-  return bind;\n-}\n-\n // Return the integer type to use for a size.\n \n GO_EXTERN_C"}, {"sha": "be945c5ced96c54a3448b6596dc7c8f5f67b06b5", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ad7db5fa38f86e095645296a5c1832fa088aa84/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ad7db5fa38f86e095645296a5c1832fa088aa84/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=5ad7db5fa38f86e095645296a5c1832fa088aa84", "patch": "@@ -3285,6 +3285,48 @@ Block::may_fall_through() const\n   return this->statements_.back()->may_fall_through();\n }\n \n+// Convert a block to the backend representation.\n+\n+Bblock*\n+Block::get_backend(Translate_context* context)\n+{\n+  Gogo* gogo = context->gogo();\n+  Named_object* function = context->function();\n+  std::vector<Bvariable*> vars;\n+  vars.reserve(this->bindings_->size_definitions());\n+  for (Bindings::const_definitions_iterator pv =\n+\t this->bindings_->begin_definitions();\n+       pv != this->bindings_->end_definitions();\n+       ++pv)\n+    {\n+      if ((*pv)->is_variable() && !(*pv)->var_value()->is_parameter())\n+\tvars.push_back((*pv)->get_backend_variable(gogo, function));\n+    }\n+\n+  // FIXME: Permitting FUNCTION to be NULL here is a temporary measure\n+  // until we have a proper representation of the init function.\n+  Bfunction* bfunction;\n+  if (function == NULL)\n+    bfunction = NULL;\n+  else\n+    bfunction = tree_to_function(function->func_value()->get_decl());\n+  Bblock* ret = context->backend()->block(bfunction, context->bblock(),\n+\t\t\t\t\t  vars, this->start_location_,\n+\t\t\t\t\t  this->end_location_);\n+\n+  Translate_context subcontext(gogo, function, this, ret);\n+  std::vector<Bstatement*> bstatements;\n+  bstatements.reserve(this->statements_.size());\n+  for (std::vector<Statement*>::const_iterator p = this->statements_.begin();\n+       p != this->statements_.end();\n+       ++p)\n+    bstatements.push_back(tree_to_stat((*p)->get_tree(&subcontext)));\n+\n+  context->backend()->block_add_statements(ret, bstatements);\n+\n+  return ret;\n+}\n+\n // Class Variable.\n \n Variable::Variable(Type* type, Expression* init, bool is_global,"}, {"sha": "f9eba50ec2ec7535d4adedade64cbcec06a80a15", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ad7db5fa38f86e095645296a5c1832fa088aa84/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ad7db5fa38f86e095645296a5c1832fa088aa84/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=5ad7db5fa38f86e095645296a5c1832fa088aa84", "patch": "@@ -43,6 +43,7 @@ class Export;\n class Import;\n class Bexpression;\n class Bstatement;\n+class Bblock;\n class Bvariable;\n class Blabel;\n \n@@ -767,9 +768,9 @@ class Block\n   bool\n   may_fall_through() const;\n \n-  // Return a tree of the code in this block.\n-  tree\n-  get_tree(Translate_context*);\n+  // Convert the block to the backend representation.\n+  Bblock*\n+  get_backend(Translate_context*);\n \n   // Iterate over statements.\n \n@@ -2507,9 +2508,9 @@ class Translate_context\n {\n  public:\n   Translate_context(Gogo* gogo, Named_object* function, Block* block,\n-\t\t    tree block_tree)\n+\t\t    Bblock* bblock)\n     : gogo_(gogo), backend_(gogo->backend()), function_(function),\n-      block_(block), block_tree_(block_tree), is_const_(false)\n+      block_(block), bblock_(bblock), is_const_(false)\n   { }\n \n   // Accessors.\n@@ -2530,9 +2531,9 @@ class Translate_context\n   block()\n   { return this->block_; }\n \n-  tree\n-  block_tree()\n-  { return this->block_tree_; }\n+  Bblock*\n+  bblock()\n+  { return this->bblock_; }\n \n   bool\n   is_const()\n@@ -2548,12 +2549,15 @@ class Translate_context\n   Gogo* gogo_;\n   // The generator for the backend data structures.\n   Backend* backend_;\n-  // The function we are currently translating.\n+  // The function we are currently translating.  NULL if not in a\n+  // function, e.g., the initializer of a global variable.\n   Named_object* function_;\n-  // The block we are currently translating.\n+  // The block we are currently translating.  NULL if not in a\n+  // function.\n   Block *block_;\n-  // The BLOCK node for the current block.\n-  tree block_tree_;\n+  // The backend representation of the current block.  NULL if block_\n+  // is NULL.\n+  Bblock* bblock_;\n   // Whether this is being evaluated in a constant context.  This is\n   // used for type descriptor initializers.\n   bool is_const_;"}, {"sha": "7c6ccb989f59e3ab2c8e59656eaeebb5962e3cf5", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 29, "deletions": 19, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ad7db5fa38f86e095645296a5c1832fa088aa84/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ad7db5fa38f86e095645296a5c1832fa088aa84/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=5ad7db5fa38f86e095645296a5c1832fa088aa84", "patch": "@@ -428,12 +428,14 @@ Temporary_statement::do_get_tree(Translate_context* context)\n       gcc_assert(current_function_decl != NULL_TREE);\n       DECL_CONTEXT(decl) = current_function_decl;\n \n-      // We have to add this variable to the block so that it winds up\n-      // in a BIND_EXPR.\n-      tree block_tree = context->block_tree();\n-      gcc_assert(block_tree != NULL_TREE);\n+      // We have to add this variable to the BLOCK and the BIND_EXPR.\n+      tree bind_tree = block_to_tree(context->bblock());\n+      gcc_assert(bind_tree != NULL_TREE && TREE_CODE(bind_tree) == BIND_EXPR);\n+      tree block_tree = BIND_EXPR_BLOCK(bind_tree);\n+      gcc_assert(TREE_CODE(block_tree) == BLOCK);\n       DECL_CHAIN(decl) = BLOCK_VARS(block_tree);\n       BLOCK_VARS(block_tree) = decl;\n+      BIND_EXPR_VARS(bind_tree) = BLOCK_VARS(block_tree);\n \n       this->decl_ = decl;\n     }\n@@ -1518,13 +1520,22 @@ class Block_statement : public Statement\n   { return this->block_->may_fall_through(); }\n \n   tree\n-  do_get_tree(Translate_context* context)\n-  { return this->block_->get_tree(context); }\n+  do_get_tree(Translate_context* context);\n \n  private:\n   Block* block_;\n };\n \n+// Convert a block to the backend representation of a statement.\n+\n+tree\n+Block_statement::do_get_tree(Translate_context* context)\n+{\n+  Bblock* bblock = this->block_->get_backend(context);\n+  Bstatement* ret = context->backend()->block_statement(bblock);\n+  return stat_to_tree(ret);\n+}\n+\n // Make a block statement.\n \n Statement*\n@@ -2767,19 +2778,14 @@ If_statement::do_get_tree(Translate_context* context)\n   gcc_assert(this->cond_->type()->is_boolean_type()\n \t     || this->cond_->type()->is_error());\n   tree cond_tree = this->cond_->get_tree(context);\n-  tree then_tree = this->then_block_->get_tree(context);\n-  tree else_tree = (this->else_block_ == NULL\n-\t\t    ? NULL_TREE\n-\t\t    : this->else_block_->get_tree(context));\n-\n+  Bblock* then_block = this->then_block_->get_backend(context);\n+  Bblock* else_block = (this->else_block_ == NULL\n+\t\t\t? NULL\n+\t\t\t: this->else_block_->get_backend(context));\n   Bexpression* cond_expr = tree_to_expr(cond_tree);\n-  Bstatement* then_stat = tree_to_stat(then_tree);\n-  Bstatement* else_stat = (else_tree == NULL_TREE\n-\t\t\t   ? NULL\n-\t\t\t   : tree_to_stat(else_tree));\n   \n-  Bstatement* ret = context->backend()->if_statement(cond_expr, then_stat,\n-\t\t\t\t\t\t     else_stat,\n+  Bstatement* ret = context->backend()->if_statement(cond_expr, then_block,\n+\t\t\t\t\t\t     else_block,\n \t\t\t\t\t\t     this->location());\n   return stat_to_tree(ret);\n }\n@@ -3056,7 +3062,10 @@ Case_clauses::Case_clause::get_backend(Translate_context* context,\n   if (this->statements_ == NULL)\n     statements = NULL;\n   else\n-    statements = tree_to_stat(this->statements_->get_tree(context));\n+    {\n+      Bblock* bblock = this->statements_->get_backend(context);\n+      statements = context->backend()->block_statement(bblock);\n+    }\n \n   Bstatement* break_stat;\n   if (this->is_fallthrough_)\n@@ -4070,7 +4079,8 @@ Select_clauses::Select_clause::get_statements_backend(\n {\n   if (this->statements_ == NULL)\n     return NULL;\n-  return tree_to_stat(this->statements_->get_tree(context));\n+  Bblock* bblock = this->statements_->get_backend(context);\n+  return context->backend()->block_statement(bblock);\n }\n \n // Class Select_clauses."}, {"sha": "da22947cb21c58695dc728a314ee9c44a91b7bd9", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ad7db5fa38f86e095645296a5c1832fa088aa84/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ad7db5fa38f86e095645296a5c1832fa088aa84/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=5ad7db5fa38f86e095645296a5c1832fa088aa84", "patch": "@@ -4470,7 +4470,7 @@ Array_type::get_length_tree(Gogo* gogo)\n \n \t  // Make up a translation context for the array length\n \t  // expression.  FIXME: This won't work in general.\n-\t  Translate_context context(gogo, NULL, NULL, NULL_TREE);\n+\t  Translate_context context(gogo, NULL, NULL, NULL);\n \t  tree len = this->length_->get_tree(&context);\n \t  if (len != error_mark_node)\n \t    {"}]}