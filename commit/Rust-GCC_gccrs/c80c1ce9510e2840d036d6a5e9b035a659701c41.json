{"sha": "c80c1ce9510e2840d036d6a5e9b035a659701c41", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzgwYzFjZTk1MTBlMjg0MGQwMzZkNmE1ZTliMDM1YTY1OTcwMWM0MQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2012-05-19T09:32:50Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2012-05-19T09:32:50Z"}, "message": "decl.c (Has_Thiscall_Convention): New macro.\n\n\t* gcc-interface/decl.c (Has_Thiscall_Convention): New macro.\n\t(gnat_to_gnu_entity) <E_Subprogram_Type>: Test it to set the thiscall\n\tcalling convention\n\t(get_minimal_subprog_decl): Likewise.\n\t(gnat_first_param_is_class): New predicate.\n\n\t* gcc-interface/misc.c (gnat_handle_option): Fix formatting.\n\t* gcc-interface/Makefile.in: Likewise.\n\nFrom-SVN: r187676", "tree": {"sha": "52608a68d00e823d6d2ae72fe69bd81af3a8b1c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52608a68d00e823d6d2ae72fe69bd81af3a8b1c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c80c1ce9510e2840d036d6a5e9b035a659701c41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c80c1ce9510e2840d036d6a5e9b035a659701c41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c80c1ce9510e2840d036d6a5e9b035a659701c41", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c80c1ce9510e2840d036d6a5e9b035a659701c41/comments", "author": null, "committer": null, "parents": [{"sha": "2a2aa0391efaad653fba352187d6c51de479f40b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a2aa0391efaad653fba352187d6c51de479f40b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a2aa0391efaad653fba352187d6c51de479f40b"}], "stats": {"total": 89, "additions": 80, "deletions": 9}, "files": [{"sha": "21c247149c2206801391dbfc85e5abe0f13f55a2", "filename": "gcc/ada/gcc-interface/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c80c1ce9510e2840d036d6a5e9b035a659701c41/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c80c1ce9510e2840d036d6a5e9b035a659701c41/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMakefile.in?ref=c80c1ce9510e2840d036d6a5e9b035a659701c41", "patch": "@@ -2148,7 +2148,7 @@ ifeq ($(strip $(filter-out darwin%,$(osys))),)\n     s-taprop.adb<s-taprop-posix.adb \\\n     s-taspri.ads<s-taspri-posix.ads \\\n     s-tpopsp.adb<s-tpopsp-posix-foreign.adb\n-  \n+\n   ifeq ($(strip $(filter-out %86,$(arch))),)\n     LIBGNAT_TARGET_PAIRS += \\\n       s-intman.adb<s-intman-susv3.adb \\\n@@ -2195,7 +2195,7 @@ ifeq ($(strip $(filter-out darwin%,$(osys))),)\n       s-osprim.adb<s-osprim-posix.adb \\\n       a-numaux.ads<a-numaux-darwin.ads \\\n       a-numaux.adb<a-numaux-darwin.adb\n-    \n+\n     ifeq ($(strip $(MULTISUBDIR)),/ppc64)\n       LIBGNAT_TARGET_PAIRS += \\\n         system.ads<system-darwin-ppc64.ads"}, {"sha": "05c9b1a26f5af50600d05a359d86b92fc7f4a37b", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 74, "deletions": 3, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c80c1ce9510e2840d036d6a5e9b035a659701c41/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c80c1ce9510e2840d036d6a5e9b035a659701c41/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=c80c1ce9510e2840d036d6a5e9b035a659701c41", "patch": "@@ -50,19 +50,23 @@\n #include \"ada-tree.h\"\n #include \"gigi.h\"\n \n-/* Convention_Stdcall should be processed in a specific way on 32 bits\n-   Windows targets only.  The macro below is a helper to avoid having to\n-   check for a Windows specific attribute throughout this unit.  */\n+/* \"stdcall\" and \"thiscall\" conventions should be processed in a specific way\n+   on 32-bit x86/Windows only.  The macros below are helpers to avoid having\n+   to check for a Windows specific attribute throughout this unit.  */\n \n #if TARGET_DLLIMPORT_DECL_ATTRIBUTES\n #ifdef TARGET_64BIT\n #define Has_Stdcall_Convention(E) \\\n   (!TARGET_64BIT && Convention (E) == Convention_Stdcall)\n+#define Has_Thiscall_Convention(E) \\\n+  (!TARGET_64BIT && gnat_first_param_is_class (E))\n #else\n #define Has_Stdcall_Convention(E) (Convention (E) == Convention_Stdcall)\n+#define Has_Thiscall_Convention(E) (gnat_first_param_is_class (E))\n #endif\n #else\n #define Has_Stdcall_Convention(E) 0\n+#define Has_Thiscall_Convention(E) 0\n #endif\n \n /* Stack realignment is necessary for functions with foreign conventions when\n@@ -126,6 +130,7 @@ DEF_VEC_ALLOC_O(variant_desc,heap);\n static GTY ((if_marked (\"tree_int_map_marked_p\"),\n \t     param_is (struct tree_int_map))) htab_t annotate_value_cache;\n \n+static bool gnat_first_param_is_class (Entity_Id) ATTRIBUTE_UNUSED;\n static bool allocatable_size_p (tree, bool);\n static void prepend_one_attribute_to (struct attrib **,\n \t\t\t\t      enum attr_type, tree, tree, Node_Id);\n@@ -4403,6 +4408,11 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    (&attr_list, ATTR_MACHINE_ATTRIBUTE,\n \t     get_identifier (\"stdcall\"), NULL_TREE,\n \t     gnat_entity);\n+\telse if (Has_Thiscall_Convention (gnat_entity))\n+\t  prepend_one_attribute_to\n+\t    (&attr_list, ATTR_MACHINE_ATTRIBUTE,\n+\t     get_identifier (\"thiscall\"), NULL_TREE,\n+\t     gnat_entity);\n \n \t/* If we should request stack realignment for a foreign convention\n \t   subprogram, do so.  Note that this applies to task entry points in\n@@ -5266,6 +5276,10 @@ get_minimal_subprog_decl (Entity_Id gnat_entity)\n     prepend_one_attribute_to (&attr_list, ATTR_MACHINE_ATTRIBUTE,\n \t\t\t      get_identifier (\"stdcall\"), NULL_TREE,\n \t\t\t      gnat_entity);\n+  else if (Has_Thiscall_Convention (gnat_entity))\n+    prepend_one_attribute_to (&attr_list, ATTR_MACHINE_ATTRIBUTE,\n+\t\t\t      get_identifier (\"thiscall\"), NULL_TREE,\n+\t\t\t      gnat_entity);\n \n   if (No (Interface_Name (gnat_entity)) && gnu_ext_name == gnu_entity_name)\n     gnu_ext_name = NULL_TREE;\n@@ -5275,6 +5289,63 @@ get_minimal_subprog_decl (Entity_Id gnat_entity)\n \t\t\t false, true, true, true, attr_list, gnat_entity);\n }\n \n+/* Return whether the E_Subprogram_Type/E_Function/E_Procedure GNAT_ENTITY has\n+   a first parameter with a class or equivalent type.\n+\n+   We use the predicate on 32-bit x86/Windows to find out whether we need to\n+   use the \"thiscall\" calling convention for GNAT_ENTITY.  This convention is\n+   the one set for C++ methods (functions with METHOD_TYPE) by the back-end.\n+   Now in Ada primitive operations are regular subprograms (e.g. you can have\n+   common pointers to both) so we cannot compute an equivalent of METHOD_TYPE\n+   and so we set the calling convention in an uniform way.  */\n+\n+static bool\n+gnat_first_param_is_class (Entity_Id gnat_entity)\n+{\n+  Entity_Id gnat_param = First_Formal_With_Extras (gnat_entity);\n+  Entity_Id gnat_type;\n+  Node_Id node;\n+\n+  if (No (gnat_param))\n+    return false;\n+\n+  gnat_type = Underlying_Type (Etype (gnat_param));\n+\n+  /* This is the main case.  Note that we must return the same value for\n+     regular tagged types and CW types since dispatching calls have a CW\n+     type on the caller side and a tagged type on the callee side.  */\n+  if (Is_Tagged_Type (gnat_type))\n+    return True;\n+\n+  /* C++ classes with no virtual functions can be imported as limited\n+     record types, but we need to return true for the constructors.  */\n+  if (Is_CPP_Class (gnat_type))\n+    return True;\n+\n+  /* The language-level \"protected\" calling convention doesn't distinguish\n+     tagged protected types from non-tagged protected types (e.g. you can\n+     have common pointers to both) so we must use a single low-level calling\n+     convention for it.  Since tagged protected types can be derived from\n+     simple limited interfaces, we need to pick the calling convention of\n+     the latters.  */\n+  if (Is_Protected_Record_Type (gnat_type))\n+    return True;\n+\n+  /* If this is the special E_Subprogram_Type built for the declaration of\n+     an access to protected subprogram type, the first parameter will have\n+     type Address, but we must return true to be consistent with above.  */\n+  if (Is_Itype (gnat_entity)\n+      && Present (node = Associated_Node_For_Itype (gnat_entity))\n+      && Nkind (node) == N_Full_Type_Declaration\n+      && Ekind (Defining_Identifier (node)) == E_Access_Subprogram_Type\n+      && Present (node = Original_Access_Type (Defining_Identifier (node)))\n+      && (Ekind (node) == E_Access_Protected_Subprogram_Type\n+\t  || Ekind (node) == E_Anonymous_Access_Protected_Subprogram_Type))\n+    return True;\n+\n+  return False;\n+}\n+\n /* Finalize the processing of From_With_Type incomplete types.  */\n \n void"}, {"sha": "6d77dc804aff7f020dbeccc5cfefdff4543df294", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c80c1ce9510e2840d036d6a5e9b035a659701c41/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c80c1ce9510e2840d036d6a5e9b035a659701c41/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=c80c1ce9510e2840d036d6a5e9b035a659701c41", "patch": "@@ -153,10 +153,10 @@ gnat_handle_option (size_t scode, const char *arg ATTRIBUTE_UNUSED, int value,\n       gcc_unreachable ();\n     }\n \n-  Ada_handle_option_auto (&global_options, &global_options_set, \n-                          scode, arg, value, \n-                          gnat_option_lang_mask (), kind,\n-                          loc, handlers, global_dc);\n+  Ada_handle_option_auto (&global_options, &global_options_set,\n+\t\t\t  scode, arg, value,\n+\t\t\t  gnat_option_lang_mask (), kind,\n+\t\t\t  loc, handlers, global_dc);\n   return true;\n }\n "}]}