{"sha": "ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWFkODRmNzNiMGEwZjM5ZWEzOWFhMDMyOWI2ZGE4M2U0YTllNmUwMg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-04-20T14:09:11Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-04-20T14:09:11Z"}, "message": "lto-symtab.c (lto_cgraph_replace_node): Merge needed instead of force flags.\n\n\t* lto-symtab.c (lto_cgraph_replace_node): Merge needed instead of force flags.\n\t* cgraph.c (cgraph_add_thunk): Use mark_reachable_node.\n\t(cgraph_remove_node): Update.\n\t(cgraph_mark_needed_node): Remove.\n\t(cgraph_mark_force_output_node): New.\n\t(dump_cgraph_node): Do not dump needed flag.\n\t(cgraph_node_cannot_be_local_p_1): Update.\n\t(cgraph_can_remove_if_no_direct_calls_and_refs): Update.\n\t* cgraph.h (symtab_node_base): Add force_output flag.\n\t(cgraph_node): Remove needed flag.\n\t(varpool_node): Remove force_output flag.\n\t(cgraph_mark_needed_node): Remove.\n\t(cgraph_mark_force_output_node): New.\n\t(cgraph_only_called_directly_or_aliased_p,\n\tvarpool_can_remove_if_no_refs, varpool_all_refs_explicit_p): Update.\n\t* ipa-cp.c (ipcp_generate_summary): Remove out of date assert.\n\t* cgraphunit.c (cgraph_decide_is_function_needed): rewrite.\n\t(cgraph_add_new_function); Update.\n\t(cgraph_mark_if_needed); Update.\n\t(verify_cgraph_node): Update.\n\t(cgraph_analyze_function): Alias target is reachable.\n\t(process_function_and_variable_attributes): Update: externally_visible\n\tflag makes function reachable.\n\t(cgraph_analyze_functions): Update dumping.\n\t* lto-cgraph.c (lto_output_node, lto_output_varpool_node,\n\tinput_overwrite_node, input_varpool_node): Update streaming.\n\t* lto-streamer-out.c (produce_symtab): Use force_output.\n\t* ipa.c (process_references): Weakrefs must be processed.\n\t(cgraph_remove_unreachable_nodes): Likewise; update for new\n\tforce_output flag.\n\t(varpool_externally_visible_p); Weakrefs are externally visible\n\teven if they are not.\n\t(function_and_variable_visibility): Update; when processing alias\n\tpair force the targets to be output.\n\t(whole_program_function_and_variable_visility): Use mark_reachable_node.\n\t* trans-mem.c (ipa_tm_mark_needed_node): Remove\n\t(ipa_tm_mark_force_output_node): New function.\n\t(ipa_tm_create_version_alias, ipa_tm_create_version): Update.\n\t* gimple-fold.c (can_refer_decl_in_current_unit_p): Be lax about aliases.\n\t* varasm.c (mark_decl_referenced): Update.\n\t(find_decl_and_mark_needed): Remove.\n\t(find_decl): New function.\n\t(weak_finish, finish_aliases_1, assemble_alias): Update; do not mark\n\talias targets as needed.\n\t(dump_tm_clone_pairs): Update.\n\t* tree-inline.c (copy_bb): Update check.\n\t* symtab.c (dump_symtab_base): Dump force_output.\n\t* tree-ssa-structalias.c (ipa_pta_execute): Use force_output.\n\t* passes.c (execute_todo): Fix dumping.\n\t* varpool.c (decide_is_variable_needed, varpool_finalize_decl): Update.\n\t(varpool_analyze_pending_decls): Alias target is reachable.\n\t(varpool_create_variable_alias): Finalize weakrefs.\n\n\t* class.c (make_local_function_alias): Do not mark symbol referenced.\n\n\t* objc-acct.c (mark_referenced_methods); Use\n\tcgraph_mark_force_output_node.\n\n\t* gcc-interface/utils.c (gnat_write_global_declarations): Update for new\n\tforce_output placement.\n\n\t* lto/lto-partition.c (partition_cgraph_node_p): Use force_output.\n\nFrom-SVN: r186624", "tree": {"sha": "2702c3a55f5c856b2b5eb0aafbdc79ca115c0691", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2702c3a55f5c856b2b5eb0aafbdc79ca115c0691"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/comments", "author": null, "committer": null, "parents": [{"sha": "757e8ba242c179e76379c617a417283a2e1f40f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/757e8ba242c179e76379c617a417283a2e1f40f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/757e8ba242c179e76379c617a417283a2e1f40f4"}], "stats": {"total": 369, "additions": 201, "deletions": 168}, "files": [{"sha": "557968c3a353cd0659c9d5eabb23a01446b8e0ea", "filename": "gcc/ChangeLog", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02", "patch": "@@ -1,3 +1,58 @@\n+2012-04-20  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto-symtab.c (lto_cgraph_replace_node): Merge needed instead of force flags.\n+\t* cgraph.c (cgraph_add_thunk): Use mark_reachable_node.\n+\t(cgraph_remove_node): Update.\n+\t(cgraph_mark_needed_node): Remove.\n+\t(cgraph_mark_force_output_node): New.\n+\t(dump_cgraph_node): Do not dump needed flag.\n+\t(cgraph_node_cannot_be_local_p_1): Update.\n+\t(cgraph_can_remove_if_no_direct_calls_and_refs): Update.\n+\t* cgraph.h (symtab_node_base): Add force_output flag.\n+\t(cgraph_node): Remove needed flag.\n+\t(varpool_node): Remove force_output flag.\n+\t(cgraph_mark_needed_node): Remove.\n+\t(cgraph_mark_force_output_node): New.\n+\t(cgraph_only_called_directly_or_aliased_p,\n+\tvarpool_can_remove_if_no_refs, varpool_all_refs_explicit_p): Update.\n+\t* ipa-cp.c (ipcp_generate_summary): Remove out of date assert.\n+\t* cgraphunit.c (cgraph_decide_is_function_needed): rewrite.\n+\t(cgraph_add_new_function); Update.\n+\t(cgraph_mark_if_needed); Update.\n+\t(verify_cgraph_node): Update.\n+\t(cgraph_analyze_function): Alias target is reachable.\n+\t(process_function_and_variable_attributes): Update: externally_visible\n+\tflag makes function reachable.\n+\t(cgraph_analyze_functions): Update dumping.\n+\t* lto-cgraph.c (lto_output_node, lto_output_varpool_node,\n+\tinput_overwrite_node, input_varpool_node): Update streaming.\n+\t* lto-streamer-out.c (produce_symtab): Use force_output.\n+\t* ipa.c (process_references): Weakrefs must be processed.\n+\t(cgraph_remove_unreachable_nodes): Likewise; update for new\n+\tforce_output flag.\n+\t(varpool_externally_visible_p); Weakrefs are externally visible\n+\teven if they are not.\n+\t(function_and_variable_visibility): Update; when processing alias\n+\tpair force the targets to be output.\n+\t(whole_program_function_and_variable_visility): Use mark_reachable_node.\n+\t* trans-mem.c (ipa_tm_mark_needed_node): Remove\n+\t(ipa_tm_mark_force_output_node): New function.\n+\t(ipa_tm_create_version_alias, ipa_tm_create_version): Update.\n+\t* gimple-fold.c (can_refer_decl_in_current_unit_p): Be lax about aliases.\n+\t* varasm.c (mark_decl_referenced): Update.\n+\t(find_decl_and_mark_needed): Remove.\n+\t(find_decl): New function.\n+\t(weak_finish, finish_aliases_1, assemble_alias): Update; do not mark\n+\talias targets as needed.\n+\t(dump_tm_clone_pairs): Update.\n+\t* tree-inline.c (copy_bb): Update check.\n+\t* symtab.c (dump_symtab_base): Dump force_output.\n+\t* tree-ssa-structalias.c (ipa_pta_execute): Use force_output.\n+\t* passes.c (execute_todo): Fix dumping.\n+\t* varpool.c (decide_is_variable_needed, varpool_finalize_decl): Update.\n+\t(varpool_analyze_pending_decls): Alias target is reachable.\n+\t(varpool_create_variable_alias): Finalize weakrefs.\n+\n 2012-04-20  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR bootstrap/53021"}, {"sha": "8fd284af31fd2f406ca9b3bafab059cefe2bb9bb", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02", "patch": "@@ -1,3 +1,8 @@\n+2012-04-20  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc-interface/utils.c (gnat_write_global_declarations): Update for new\n+\tforce_output placement.\n+\n 2012-04-14  Jan Hubicka  <jh@suse.cz>\n \n \t* gcc-interface/trans.c (finalize_nrv): Update field referenced for new"}, {"sha": "e95e967457f466d55aac38078f3df7b2d642de4b", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02", "patch": "@@ -4859,7 +4859,7 @@ gnat_write_global_declarations (void)\n       TREE_STATIC (dummy_global) = 1;\n       TREE_ASM_WRITTEN (dummy_global) = 1;\n       node = varpool_node (dummy_global);\n-      node->force_output = 1;\n+      node->symbol.force_output = 1;\n       varpool_mark_needed_node (node);\n \n       while (!VEC_empty (tree, types_used_by_cur_var_decl))"}, {"sha": "4588249ac5fa8fc5a98002a02fe6e9952205adc8", "filename": "gcc/cgraph.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02", "patch": "@@ -570,7 +570,7 @@ cgraph_add_thunk (struct cgraph_node *decl_node ATTRIBUTE_UNUSED,\n   node->local.finalized = true;\n \n   if (cgraph_decide_is_function_needed (node, decl))\n-    cgraph_mark_needed_node (node);\n+    cgraph_mark_reachable_node (node);\n \n   if ((TREE_PUBLIC (decl) && !DECL_COMDAT (decl) && !DECL_EXTERNAL (decl))\n       || (DECL_VIRTUAL_P (decl)\n@@ -1362,7 +1362,7 @@ cgraph_remove_node (struct cgraph_node *node)\n \n   /* Incremental inlining access removed nodes stored in the postorder list.\n      */\n-  node->needed = node->reachable = false;\n+  node->symbol.force_output = node->reachable = false;\n   for (n = node->nested; n; n = n->next_nested)\n     n->origin = NULL;\n   node->nested = NULL;\n@@ -1518,9 +1518,9 @@ cgraph_mark_reachable_node (struct cgraph_node *node)\n    external means.  */\n \n void\n-cgraph_mark_needed_node (struct cgraph_node *node)\n+cgraph_mark_force_output_node (struct cgraph_node *node)\n {\n-  node->needed = 1;\n+  node->symbol.force_output = 1;\n   gcc_assert (!node->global.inlined_to);\n   cgraph_mark_reachable_node (node);\n }\n@@ -1642,8 +1642,6 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n \t     (HOST_WIDEST_INT)node->count);\n   if (node->origin)\n     fprintf (f, \" nested in: %s\", cgraph_node_asm_name (node->origin));\n-  if (node->needed)\n-    fprintf (f, \" needed\");\n   else if (node->reachable)\n     fprintf (f, \" reachable\");\n   if (gimple_has_body_p (node->symbol.decl))\n@@ -2134,7 +2132,7 @@ static bool\n cgraph_node_cannot_be_local_p_1 (struct cgraph_node *node,\n \t\t\t\t void *data ATTRIBUTE_UNUSED)\n {\n-  return !(!node->needed\n+  return !(!node->symbol.force_output\n \t   && ((DECL_COMDAT (node->symbol.decl)\n \t\t&& !node->symbol.same_comdat_group)\n \t       || !node->symbol.externally_visible));\n@@ -2570,7 +2568,7 @@ cgraph_can_remove_if_no_direct_calls_and_refs_p (struct cgraph_node *node)\n   if (DECL_EXTERNAL (node->symbol.decl))\n     return true;\n   /* When function is needed, we can not remove it.  */\n-  if (node->needed || node->symbol.used_from_other_partition)\n+  if (node->symbol.force_output || node->symbol.used_from_other_partition)\n     return false;\n   if (DECL_STATIC_CONSTRUCTOR (node->symbol.decl)\n       || DECL_STATIC_DESTRUCTOR (node->symbol.decl))"}, {"sha": "5915a14c6c73043553960374958a42e09a85ef73", "filename": "gcc/cgraph.h", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02", "patch": "@@ -77,6 +77,9 @@ struct GTY(()) symtab_node_base\n   unsigned in_other_partition : 1;\n   /* Set when function is visible by other units.  */\n   unsigned externally_visible : 1;\n+  /* Needed variables might become dead by optimization.  This flag\n+     forces the variable to be output even if it appears dead otherwise.  */\n+  unsigned force_output : 1;\n };\n \n enum availability\n@@ -246,12 +249,6 @@ struct GTY(()) cgraph_node {\n   /* Unique id of the node.  */\n   int uid;\n \n-  /* Set when function must be output for some reason.  The primary\n-     use of this flag is to mark functions needed to be output for\n-     non-standard reason.  Functions that are externally visible\n-     or reachable from functions needed to be output are marked\n-     by specialized flags.  */\n-  unsigned needed : 1;\n   /* Set when decl is an abstract function pointed to by the\n      ABSTRACT_DECL_ORIGIN of a reachable function.  */\n   unsigned abstract_and_needed : 1;\n@@ -433,9 +430,6 @@ struct GTY(()) varpool_node {\n   /* Set when function must be output - it is externally visible\n      or its address is taken.  */\n   unsigned needed : 1;\n-  /* Needed variables might become dead by optimization.  This flag\n-     forces the variable to be output even if it appears dead otherwise.  */\n-  unsigned force_output : 1;\n   /* Set once the variable has been instantiated and its callee\n      lists created.  */\n   unsigned analyzed : 1;\n@@ -610,7 +604,7 @@ void cgraph_mark_if_needed (tree);\n void cgraph_analyze_function (struct cgraph_node *);\n void cgraph_finalize_compilation_unit (void);\n void cgraph_optimize (void);\n-void cgraph_mark_needed_node (struct cgraph_node *);\n+void cgraph_mark_force_output_node (struct cgraph_node *);\n void cgraph_mark_address_taken_node (struct cgraph_node *);\n void cgraph_mark_reachable_node (struct cgraph_node *);\n bool cgraph_inline_p (struct cgraph_edge *, cgraph_inline_failed_t *reason);\n@@ -1118,7 +1112,7 @@ static inline bool\n cgraph_only_called_directly_or_aliased_p (struct cgraph_node *node)\n {\n   gcc_assert (!node->global.inlined_to);\n-  return (!node->needed && !node->symbol.address_taken\n+  return (!node->symbol.force_output && !node->symbol.address_taken\n \t  && !node->symbol.used_from_other_partition\n \t  && !DECL_STATIC_CONSTRUCTOR (node->symbol.decl)\n \t  && !DECL_STATIC_DESTRUCTOR (node->symbol.decl)\n@@ -1131,9 +1125,10 @@ cgraph_only_called_directly_or_aliased_p (struct cgraph_node *node)\n static inline bool\n varpool_can_remove_if_no_refs (struct varpool_node *node)\n {\n-  return (!node->force_output && !node->symbol.used_from_other_partition\n+  return (!node->symbol.force_output && !node->symbol.used_from_other_partition\n   \t  && (DECL_COMDAT (node->symbol.decl)\n-\t  || !node->symbol.externally_visible));\n+\t  || !node->symbol.externally_visible\n+\t  || DECL_EXTERNAL (node->symbol.decl)));\n }\n \n /* Return true when all references to VNODE must be visible in ipa_ref_list.\n@@ -1147,7 +1142,7 @@ varpool_all_refs_explicit_p (struct varpool_node *vnode)\n   return (vnode->analyzed\n \t  && !vnode->symbol.externally_visible\n \t  && !vnode->symbol.used_from_other_partition\n-\t  && !vnode->force_output);\n+\t  && !vnode->symbol.force_output);\n }\n \n /* Constant pool accessor function.  */"}, {"sha": "3e07e501013900242fa3a44f5fe81677efd6a93a", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 52, "deletions": 64, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02", "patch": "@@ -156,56 +156,36 @@ FILE *cgraph_dump_file;\n /* Used for vtable lookup in thunk adjusting.  */\n static GTY (()) tree vtable_entry_type;\n \n-/* Determine if function DECL is needed.  That is, visible to something\n-   either outside this translation unit, something magic in the system\n-   configury.  */\n+/* Determine if function DECL is trivially needed and should stay in the\n+   compilation unit.  This is used at the symbol table construction time\n+   and differs from later logic removing unnecesary functions that can\n+   take into account results of analysis, whole program info etc.  */\n \n bool\n cgraph_decide_is_function_needed (struct cgraph_node *node, tree decl)\n {\n   /* If the user told us it is used, then it must be so.  */\n-  if (node->symbol.externally_visible)\n+  if (node->symbol.force_output)\n     return true;\n \n-  /* ??? If the assembler name is set by hand, it is possible to assemble\n-     the name later after finalizing the function and the fact is noticed\n-     in assemble_name then.  This is arguably a bug.  */\n-  if (DECL_ASSEMBLER_NAME_SET_P (decl)\n-      && (!node->thunk.thunk_p && !node->same_body_alias)\n-      && TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl)))\n-    return true;\n+  /* Double check that no one output the function into assembly file\n+     early.  */\n+  gcc_checking_assert (!DECL_ASSEMBLER_NAME_SET_P (decl)\n+\t               || (node->thunk.thunk_p || node->same_body_alias)\n+\t               ||  !TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl)));\n \n-  /* With -fkeep-inline-functions we are keeping all inline functions except\n-     for extern inline ones.  */\n-  if (flag_keep_inline_functions\n-      && DECL_DECLARED_INLINE_P (decl)\n-      && !DECL_EXTERNAL (decl)\n-      && !DECL_DISREGARD_INLINE_LIMITS (decl))\n-     return true;\n \n-  /* If we decided it was needed before, but at the time we didn't have\n-     the body of the function available, then it's still needed.  We have\n-     to go back and re-check its dependencies now.  */\n-  if (node->needed)\n-    return true;\n+  /* Keep constructors, destructors and virtual functions.  */\n+  if (DECL_STATIC_CONSTRUCTOR (decl)\n+      || DECL_STATIC_DESTRUCTOR (decl)\n+      || (DECL_VIRTUAL_P (decl)\n+\t  && optimize && (DECL_COMDAT (decl) || DECL_EXTERNAL (decl))))\n+     return true;\n \n   /* Externally visible functions must be output.  The exception is\n-     COMDAT functions that must be output only when they are needed.\n+     COMDAT functions that must be output only when they are needed.  */\n \n-     When not optimizing, also output the static functions. (see\n-     PR24561), but don't do so for always_inline functions, functions\n-     declared inline and nested functions.  These were optimized out\n-     in the original implementation and it is unclear whether we want\n-     to change the behavior here.  */\n-  if (((TREE_PUBLIC (decl)\n-\t|| (!optimize\n-\t    && !node->same_body_alias\n-\t    && !DECL_DISREGARD_INLINE_LIMITS (decl)\n-\t    && !DECL_DECLARED_INLINE_P (decl)\n-\t    && !(DECL_CONTEXT (decl)\n-\t\t && TREE_CODE (DECL_CONTEXT (decl)) == FUNCTION_DECL)))\n-       && !flag_whole_program\n-       && !flag_lto)\n+  if (TREE_PUBLIC (decl)\n       && !DECL_COMDAT (decl) && !DECL_EXTERNAL (decl))\n     return true;\n \n@@ -337,22 +317,29 @@ cgraph_finalize_function (tree decl, bool nested)\n   node->local.finalized = true;\n   node->lowered = DECL_STRUCT_FUNCTION (decl)->cfg != NULL;\n \n-  if (cgraph_decide_is_function_needed (node, decl))\n-    cgraph_mark_needed_node (node);\n+  /* With -fkeep-inline-functions we are keeping all inline functions except\n+     for extern inline ones.  */\n+  if (flag_keep_inline_functions\n+      && DECL_DECLARED_INLINE_P (decl)\n+      && !DECL_EXTERNAL (decl)\n+      && !DECL_DISREGARD_INLINE_LIMITS (decl))\n+    node->symbol.force_output = 1;\n \n-  /* Since we reclaim unreachable nodes at the end of every language\n-     level unit, we need to be conservative about possible entry points\n-     there.  */\n-  if ((TREE_PUBLIC (decl) && !DECL_COMDAT (decl) && !DECL_EXTERNAL (decl))\n-      || DECL_STATIC_CONSTRUCTOR (decl)\n-      || DECL_STATIC_DESTRUCTOR (decl)\n-      /* COMDAT virtual functions may be referenced by vtable from\n-\t other compilation unit.  Still we want to devirtualize calls\n-\t to those so we need to analyze them.\n-\t FIXME: We should introduce may edges for this purpose and update\n-\t their handling in unreachable function removal and inliner too.  */\n-      || (DECL_VIRTUAL_P (decl)\n-\t  && optimize && (DECL_COMDAT (decl) || DECL_EXTERNAL (decl))))\n+  /* When not optimizing, also output the static functions. (see\n+     PR24561), but don't do so for always_inline functions, functions\n+     declared inline and nested functions.  These were optimized out\n+     in the original implementation and it is unclear whether we want\n+     to change the behavior here.  */\n+  if ((!optimize\n+       && !node->same_body_alias\n+       && !DECL_DISREGARD_INLINE_LIMITS (decl)\n+       && !DECL_DECLARED_INLINE_P (decl)\n+       && !(DECL_CONTEXT (decl)\n+\t    && TREE_CODE (DECL_CONTEXT (decl)) == FUNCTION_DECL))\n+      && !DECL_COMDAT (decl) && !DECL_EXTERNAL (decl))\n+    node->symbol.force_output = 1;\n+\n+  if (cgraph_decide_is_function_needed (node, decl))\n     cgraph_mark_reachable_node (node);\n \n   /* If we've not yet emitted decl, tell the debug info about it.  */\n@@ -402,7 +389,7 @@ cgraph_add_new_function (tree fndecl, bool lowered)\n \tnode = cgraph_get_create_node (fndecl);\n \tnode->local.local = false;\n \tnode->local.finalized = true;\n-\tnode->reachable = node->needed = true;\n+\tnode->reachable = node->symbol.force_output = true;\n \tif (!lowered && cgraph_state == CGRAPH_STATE_EXPANSION)\n \t  {\n \t    push_cfun (DECL_STRUCT_FUNCTION (fndecl));\n@@ -462,7 +449,7 @@ cgraph_mark_if_needed (tree decl)\n {\n   struct cgraph_node *node = cgraph_get_node (decl);\n   if (node->local.finalized && cgraph_decide_is_function_needed (node, decl))\n-    cgraph_mark_needed_node (node);\n+    cgraph_mark_reachable_node (node);\n }\n \n /* Return TRUE if NODE2 is equivalent to NODE or its clone.  */\n@@ -601,9 +588,9 @@ verify_cgraph_node (struct cgraph_node *node)\n       error (\"inline clone with address taken\");\n       error_found = true;\n     }\n-  if (node->global.inlined_to && node->needed)\n+  if (node->global.inlined_to && node->symbol.force_output)\n     {\n-      error (\"inline clone is needed\");\n+      error (\"inline clone is forced to output\");\n       error_found = true;\n     }\n   for (e = node->indirect_calls; e; e = e->next_callee)\n@@ -901,6 +888,7 @@ cgraph_analyze_function (struct cgraph_node *node)\n       if (!VEC_length (ipa_ref_t, node->symbol.ref_list.references))\n         ipa_record_reference ((symtab_node)node, (symtab_node)tgt,\n \t\t\t      IPA_REF_ALIAS, NULL);\n+      cgraph_mark_reachable_node (tgt);\n       if (node->same_body_alias)\n \t{ \n \t  DECL_VIRTUAL_P (node->symbol.decl) = DECL_VIRTUAL_P (node->thunk.alias);\n@@ -940,7 +928,7 @@ cgraph_analyze_function (struct cgraph_node *node)\n       if (node->symbol.address_taken)\n \tcgraph_mark_address_taken_node (cgraph_alias_aliased_node (node));\n       if (cgraph_decide_is_function_needed (node, node->symbol.decl))\n-\tcgraph_mark_needed_node (node);\n+\tcgraph_mark_reachable_node (node);\n     }\n   else if (node->thunk.thunk_p)\n     {\n@@ -1061,13 +1049,13 @@ process_function_and_variable_attributes (struct cgraph_node *first,\n     {\n       tree decl = node->symbol.decl;\n       if (DECL_PRESERVE_P (decl))\n-\tcgraph_mark_needed_node (node);\n+\tcgraph_mark_force_output_node (node);\n       if (TARGET_DLLIMPORT_DECL_ATTRIBUTES\n \t  && lookup_attribute (\"dllexport\", DECL_ATTRIBUTES (decl))\n \t  && TREE_PUBLIC (node->symbol.decl))\n \t{\n \t  if (node->local.finalized)\n-\t    cgraph_mark_needed_node (node);\n+\t    cgraph_mark_reachable_node (node);\n \t}\n       else if (lookup_attribute (\"externally_visible\", DECL_ATTRIBUTES (decl)))\n \t{\n@@ -1076,7 +1064,7 @@ process_function_and_variable_attributes (struct cgraph_node *first,\n \t\t\t\"%<externally_visible%>\"\n \t\t\t\" attribute have effect only on public objects\");\n \t  else if (node->local.finalized)\n-\t     cgraph_mark_needed_node (node);\n+\t    cgraph_mark_reachable_node (node);\n \t}\n       if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (decl))\n \t  && (node->local.finalized && !node->alias))\n@@ -1104,7 +1092,7 @@ process_function_and_variable_attributes (struct cgraph_node *first,\n       tree decl = vnode->symbol.decl;\n       if (DECL_PRESERVE_P (decl))\n \t{\n-\t  vnode->force_output = true;\n+\t  vnode->symbol.force_output = true;\n \t  if (vnode->finalized)\n \t    varpool_mark_needed_node (vnode);\n \t}\n@@ -1165,7 +1153,7 @@ cgraph_analyze_functions (void)\n       fprintf (cgraph_dump_file, \"Initial entry points:\");\n       for (node = cgraph_first_function (); node != first_analyzed;\n \t   node = cgraph_next_function (node))\n-\tif (node->needed)\n+\tif (cgraph_decide_is_function_needed (node, node->symbol.decl))\n \t  fprintf (cgraph_dump_file, \" %s\", cgraph_node_name (node));\n       fprintf (cgraph_dump_file, \"\\n\");\n     }\n@@ -1241,7 +1229,7 @@ cgraph_analyze_functions (void)\n       fprintf (cgraph_dump_file, \"Unit entry points:\");\n       for (node = cgraph_first_function (); node != first_analyzed;\n \t   node = cgraph_next_function (node))\n-\tif (node->needed)\n+\tif (cgraph_decide_is_function_needed (node, node->symbol.decl))\n \t  fprintf (cgraph_dump_file, \" %s\", cgraph_node_name (node));\n       fprintf (cgraph_dump_file, \"\\n\\nInitial \");\n       dump_symtab (cgraph_dump_file);"}, {"sha": "49505ee94944125a823ec8ad8dead25d3aec7386", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02", "patch": "@@ -70,6 +70,7 @@ can_refer_decl_in_current_unit_p (tree decl)\n \t flags incorrectly.  Those variables should never\n \t be finalized.  */\n       gcc_checking_assert (!(vnode = varpool_get_node (decl))\n+\t\t\t   || vnode->alias\n \t\t\t   || !vnode->finalized);\n       return false;\n     }"}, {"sha": "4826c582c832e4c87348da266cc5438b71fc15b9", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02", "patch": "@@ -2494,8 +2494,6 @@ ipcp_generate_summary (void)\n \n   FOR_EACH_FUNCTION_WITH_GIMPLE_BODY (node)\n       {\n-\t/* Unreachable nodes should have been eliminated before ipcp.  */\n-\tgcc_assert (node->needed || node->reachable);\n \tnode->local.versionable\n \t  = tree_versionable_function_p (node->symbol.decl);\n \tipa_analyze_node (node);"}, {"sha": "f4daf36aa37e7e8037bc7565b0236ed8b934b42d", "filename": "gcc/ipa.c", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02", "patch": "@@ -97,6 +97,7 @@ process_references (struct ipa_ref_list *list,\n \t  if (!node->reachable\n \t      && node->analyzed\n \t      && (!DECL_EXTERNAL (node->symbol.decl)\n+\t\t  || node->alias\n \t          || before_inlining_p))\n \t    node->reachable = true;\n \t  enqueue_cgraph_node (node, first);\n@@ -214,7 +215,7 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n     {\n       vnode->next_needed = NULL;\n       vnode->prev_needed = NULL;\n-      if ((vnode->analyzed || vnode->force_output)\n+      if ((vnode->analyzed || vnode->symbol.force_output)\n \t  && !varpool_can_remove_if_no_refs (vnode))\n \t{\n \t  vnode->needed = false;\n@@ -254,6 +255,7 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t\t      && node->analyzed\n \t\t      && (!e->inline_failed\n \t\t\t  || !DECL_EXTERNAL (e->callee->symbol.decl)\n+\t\t\t  || node->alias\n \t\t\t  || before_inlining_p))\n \t\t    e->callee->reachable = true;\n \t\t  enqueue_cgraph_node (e->callee, &first);\n@@ -659,6 +661,12 @@ cgraph_externally_visible_p (struct cgraph_node *node,\n bool\n varpool_externally_visible_p (struct varpool_node *vnode, bool aliased)\n {\n+  /* Do not touch weakrefs; while they are not externally visible,\n+     dropping their DECL_EXTERNAL flags confuse most\n+     of code handling them.  */\n+  if (vnode->alias && DECL_EXTERNAL (vnode->symbol.decl))\n+    return true;\n+\n   if (!DECL_COMDAT (vnode->symbol.decl) && !TREE_PUBLIC (vnode->symbol.decl))\n     return false;\n \n@@ -700,7 +708,7 @@ varpool_externally_visible_p (struct varpool_node *vnode, bool aliased)\n      is faster for dynamic linking.  Also this match logic hidding vtables\n      from LTO symbol tables.  */\n   if ((in_lto_p || flag_whole_program)\n-      && !vnode->force_output\n+      && !vnode->symbol.force_output\n       && DECL_COMDAT (vnode->symbol.decl) && DECL_VIRTUAL_P (vnode->symbol.decl))\n     return false;\n \n@@ -776,8 +784,7 @@ function_and_variable_visibility (bool whole_program)\n         {\n \t  if (!node->analyzed)\n \t    continue;\n-\t  cgraph_mark_needed_node (node);\n-\t  gcc_assert (node->needed);\n+\t  cgraph_mark_force_output_node (node);\n \t  pointer_set_insert (aliased_nodes, node);\n \t  if (dump_file)\n \t    fprintf (dump_file, \"  node %s/%i\",\n@@ -786,6 +793,7 @@ function_and_variable_visibility (bool whole_program)\n       else if ((vnode = varpool_node_for_asm (p->target)) != NULL\n \t       && !DECL_EXTERNAL (vnode->symbol.decl))\n         {\n+\t  vnode->symbol.force_output = 1;\n \t  varpool_mark_needed_node (vnode);\n \t  gcc_assert (vnode->needed);\n \t  pointer_set_insert (aliased_vnodes, vnode);\n@@ -813,9 +821,9 @@ function_and_variable_visibility (bool whole_program)\n       /* Frontends and alias code marks nodes as needed before parsing is finished.\n \t We may end up marking as node external nodes where this flag is meaningless\n \t strip it.  */\n-      if (node->needed\n+      if (node->symbol.force_output\n \t  && (DECL_EXTERNAL (node->symbol.decl) || !node->analyzed))\n-\tnode->needed = 0;\n+\tnode->symbol.force_output = 0;\n \n       /* C++ FE on lack of COMDAT support create local COMDAT functions\n \t (that ought to be shared but can not due to object format\n@@ -1017,7 +1025,7 @@ whole_program_function_and_variable_visibility (void)\n   FOR_EACH_DEFINED_FUNCTION (node)\n     if ((node->symbol.externally_visible && !DECL_COMDAT (node->symbol.decl))\n         && node->local.finalized)\n-      cgraph_mark_needed_node (node);\n+      cgraph_mark_reachable_node (node);\n   FOR_EACH_DEFINED_VARIABLE (vnode)\n     if (vnode->symbol.externally_visible && !DECL_COMDAT (vnode->symbol.decl))\n       varpool_mark_needed_node (vnode);"}, {"sha": "14eb423b4d64f24e3bd898d4c0643d9a269a4d0d", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02", "patch": "@@ -1,3 +1,7 @@\n+2012-04-20  Jan Hubicka  <jh@suse.cz>\n+\n+\t* class.c (make_local_function_alias): Do not mark symbol referenced.\n+\n 2012-04-11  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* jcf-dump.c (print_constant): Cast JPOOL_USHORT2, JPOOL_USHORT1"}, {"sha": "145bb632016876a8409c41815cb03620f365121d", "filename": "gcc/java/class.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02", "patch": "@@ -1407,7 +1407,6 @@ make_local_function_alias (tree method)\n   DECL_INITIAL (alias) = error_mark_node;\n   TREE_ADDRESSABLE (alias) = 1;\n   TREE_USED (alias) = 1;\n-  TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (alias)) = 1;\n   if (!flag_syntax_only)\n     assemble_alias (alias, DECL_ASSEMBLER_NAME (method));\n   return alias;"}, {"sha": "c0398b41a359a5c873e69957df639b74fb595569", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02", "patch": "@@ -503,7 +503,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   bp_pack_value (&bp, node->local.versionable, 1);\n   bp_pack_value (&bp, node->local.can_change_signature, 1);\n   bp_pack_value (&bp, node->local.redefined_extern_inline, 1);\n-  bp_pack_value (&bp, node->needed, 1);\n+  bp_pack_value (&bp, node->symbol.force_output, 1);\n   bp_pack_value (&bp, node->symbol.address_taken, 1);\n   bp_pack_value (&bp, node->abstract_and_needed, 1);\n   bp_pack_value (&bp, tag == LTO_cgraph_analyzed_node\n@@ -566,7 +566,7 @@ lto_output_varpool_node (struct lto_simple_output_block *ob, struct varpool_node\n   lto_output_var_decl_index (ob->decl_state, ob->main_stream, node->symbol.decl);\n   bp = bitpack_create (ob->main_stream);\n   bp_pack_value (&bp, node->symbol.externally_visible, 1);\n-  bp_pack_value (&bp, node->force_output, 1);\n+  bp_pack_value (&bp, node->symbol.force_output, 1);\n   bp_pack_value (&bp, node->finalized, 1);\n   bp_pack_value (&bp, node->alias, 1);\n   bp_pack_value (&bp, node->alias_of != NULL, 1);\n@@ -911,7 +911,7 @@ input_overwrite_node (struct lto_file_decl_data *file_data,\n   node->local.versionable = bp_unpack_value (bp, 1);\n   node->local.can_change_signature = bp_unpack_value (bp, 1);\n   node->local.redefined_extern_inline = bp_unpack_value (bp, 1);\n-  node->needed = bp_unpack_value (bp, 1);\n+  node->symbol.force_output = bp_unpack_value (bp, 1);\n   node->symbol.address_taken = bp_unpack_value (bp, 1);\n   node->abstract_and_needed = bp_unpack_value (bp, 1);\n   node->symbol.used_from_other_partition = bp_unpack_value (bp, 1);\n@@ -1075,7 +1075,7 @@ input_varpool_node (struct lto_file_decl_data *file_data,\n \n   bp = streamer_read_bitpack (ib);\n   node->symbol.externally_visible = bp_unpack_value (&bp, 1);\n-  node->force_output = bp_unpack_value (&bp, 1);\n+  node->symbol.force_output = bp_unpack_value (&bp, 1);\n   node->finalized = bp_unpack_value (&bp, 1);\n   node->alias = bp_unpack_value (&bp, 1);\n   non_null_aliasof = bp_unpack_value (&bp, 1);"}, {"sha": "89850f0c08a3a90df88d7e24693172e695b59ce2", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02", "patch": "@@ -1456,7 +1456,7 @@ produce_symtab (struct output_block *ob,\n \t in the LTO symbol table to prevent linker from forcing them\n \t into the output. */\n       if (DECL_COMDAT (vnode->symbol.decl)\n-\t  && !vnode->force_output\n+\t  && !vnode->symbol.force_output\n \t  && vnode->finalized \n \t  && DECL_VIRTUAL_P (vnode->symbol.decl))\n \tcontinue;\n@@ -1470,7 +1470,7 @@ produce_symtab (struct output_block *ob,\n       if (!DECL_EXTERNAL (vnode->symbol.decl))\n \tcontinue;\n       if (DECL_COMDAT (vnode->symbol.decl)\n-\t  && !vnode->force_output\n+\t  && !vnode->symbol.force_output\n \t  && vnode->finalized \n \t  && DECL_VIRTUAL_P (vnode->symbol.decl))\n \tcontinue;"}, {"sha": "ed8a651b72139c9bf7100110540096ba902535a6", "filename": "gcc/lto-symtab.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/gcc%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/gcc%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-symtab.c?ref=ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02", "patch": "@@ -223,8 +223,8 @@ lto_cgraph_replace_node (struct cgraph_node *node,\n     }\n \n   /* Merge node flags.  */\n-  if (node->needed)\n-    cgraph_mark_needed_node (prevailing_node);\n+  if (node->symbol.force_output)\n+    cgraph_mark_force_output_node (prevailing_node);\n   if (node->reachable)\n     cgraph_mark_reachable_node (prevailing_node);\n   if (node->symbol.address_taken)"}, {"sha": "6b86475b27fc3f25a3f5c9a3ad7b9175bf2b669c", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02", "patch": "@@ -1,3 +1,7 @@\n+2012-04-20  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto-partition.c (partition_cgraph_node_p): Use force_output.\n+\n 2012-04-18  Jan Hubicka  <jh@suse.cz>\n \n \t* lto-partition.c (add_references_to_partition, lto_balanced_map):"}, {"sha": "8287f8fdd779fde418619fc9157710196db12467", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02", "patch": "@@ -269,6 +269,7 @@ partition_cgraph_node_p (struct cgraph_node *node)\n   /* Extern inlines and comdat are always only in partitions they are needed.  */\n   if (DECL_EXTERNAL (node->symbol.decl)\n       || (DECL_COMDAT (node->symbol.decl)\n+\t  && !node->symbol.force_output\n \t  && !cgraph_used_from_object_file_p (node)))\n     return false;\n   if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (node->symbol.decl)))\n@@ -287,7 +288,7 @@ partition_varpool_node_p (struct varpool_node *vnode)\n   /* Constant pool and comdat are always only in partitions they are needed.  */\n   if (DECL_IN_CONSTANT_POOL (vnode->symbol.decl)\n       || (DECL_COMDAT (vnode->symbol.decl)\n-\t  && !vnode->force_output\n+\t  && !vnode->symbol.force_output\n \t  && !varpool_used_from_object_file_p (vnode)))\n     return false;\n   if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (vnode->symbol.decl)))"}, {"sha": "6fed845690eba4e3132c3261fa6bdf8ef69425e5", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02", "patch": "@@ -1,3 +1,8 @@\n+2012-04-20  Jan Hubicka  <jh@suse.cz>\n+\n+\t* objc-acct.c (mark_referenced_methods); Use\n+\tcgraph_mark_force_output_node.\n+\n 2012-03-21  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* objc-act (objc_build_ivar_assignment): Do not call assemble_external."}, {"sha": "ec07971f02de6f728d4a3733ecd97cfed1f3a1f9", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02", "patch": "@@ -4625,15 +4625,15 @@ mark_referenced_methods (void)\n       chain = CLASS_CLS_METHODS (impent->imp_context);\n       while (chain)\n \t{\n-\t  cgraph_mark_needed_node (\n+\t  cgraph_mark_force_output_node (\n \t\t\t   cgraph_get_create_node (METHOD_DEFINITION (chain)));\n \t  chain = DECL_CHAIN (chain);\n \t}\n \n       chain = CLASS_NST_METHODS (impent->imp_context);\n       while (chain)\n \t{\n-\t  cgraph_mark_needed_node (\n+\t  cgraph_mark_force_output_node (\n \t\t\t   cgraph_get_create_node (METHOD_DEFINITION (chain)));\n \t  chain = DECL_CHAIN (chain);\n \t}"}, {"sha": "ed5da15a3e9e8e18f05a7d0ff077ded94bfffd79", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02", "patch": "@@ -1865,7 +1865,7 @@ execute_todo (unsigned int flags)\n   if ((flags & TODO_dump_symtab) && dump_file && !current_function_decl)\n     {\n       gcc_assert (!cfun);\n-      dump_cgraph (dump_file);\n+      dump_symtab (dump_file);\n       /* Flush the file.  If verification fails, we won't be able to\n \t close the file before aborting.  */\n       fflush (dump_file);"}, {"sha": "75078b089bac9744bd83089600dd72268816c111", "filename": "gcc/symtab.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02", "patch": "@@ -378,6 +378,8 @@ dump_symtab_base (FILE *f, symtab_node node)\n     fprintf (f, \" in_other_partition\");\n   if (node->symbol.used_from_other_partition)\n     fprintf (f, \" used_from_other_partition\");\n+  if (node->symbol.force_output)\n+    fprintf (f, \" force_output\");\n   if (node->symbol.resolution != LDPR_UNKNOWN)\n     fprintf (f, \" %s\",\n  \t     ld_plugin_symbol_resolution_names[(int)node->symbol.resolution]);"}, {"sha": "b1dd2a05e2f202ee3ba99382c15246992d1f4535", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02", "patch": "@@ -4267,9 +4267,9 @@ tm_mangle (tree old_asm_id)\n }\n \n static inline void\n-ipa_tm_mark_needed_node (struct cgraph_node *node)\n+ipa_tm_mark_force_output_node (struct cgraph_node *node)\n {\n-  cgraph_mark_needed_node (node);\n+  cgraph_mark_force_output_node (node);\n   /* ??? function_and_variable_visibility will reset\n      the needed bit, without actually checking.  */\n   node->analyzed = 1;\n@@ -4328,8 +4328,8 @@ ipa_tm_create_version_alias (struct cgraph_node *node, void *data)\n \n   record_tm_clone_pair (old_decl, new_decl);\n \n-  if (info->old_node->needed)\n-    ipa_tm_mark_needed_node (new_node);\n+  if (info->old_node->symbol.force_output)\n+    ipa_tm_mark_force_output_node (new_node);\n   return false;\n }\n \n@@ -4381,8 +4381,8 @@ ipa_tm_create_version (struct cgraph_node *old_node)\n   record_tm_clone_pair (old_decl, new_decl);\n \n   cgraph_call_function_insertion_hooks (new_node);\n-  if (old_node->needed)\n-    ipa_tm_mark_needed_node (new_node);\n+  if (old_node->symbol.force_output)\n+    ipa_tm_mark_force_output_node (new_node);\n \n   /* Do the same thing, but for any aliases of the original node.  */\n   {"}, {"sha": "d0710c0ddf74f62b6c99ac073250cc341567a1f9", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02", "patch": "@@ -1755,7 +1755,7 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t\t     producing dead clone (for further cloning).  In all\n \t\t     other cases we hit a bug (incorrect node sharing is the\n \t\t     most common reason for missing edges).  */\n-\t\t  gcc_assert (dest->needed || !dest->analyzed\n+\t\t  gcc_assert (!dest->analyzed\n \t\t\t      || dest->symbol.address_taken\n \t\t  \t      || !id->src_node->analyzed\n \t\t\t      || !id->dst_node->analyzed);"}, {"sha": "09642a03f425bda3ced2926dfff0af6facba9888", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02", "patch": "@@ -6928,7 +6928,7 @@ ipa_pta_execute (void)\n \t constraints for parameters.  */\n       if (node->symbol.used_from_other_partition\n \t  || node->symbol.externally_visible\n-\t  || node->needed)\n+\t  || node->symbol.force_output)\n \t{\n \t  intra_create_variable_infos ();\n "}, {"sha": "d506b31715444c784a4d0ef987fe39d3bca4332a", "filename": "gcc/varasm.c", "status": "modified", "additions": 17, "deletions": 47, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02", "patch": "@@ -2249,15 +2249,15 @@ mark_decl_referenced (tree decl)\n       struct cgraph_node *node = cgraph_get_create_node (decl);\n       if (!DECL_EXTERNAL (decl)\n \t  && !node->local.finalized)\n-\tcgraph_mark_needed_node (node);\n+\tcgraph_mark_force_output_node (node);\n     }\n   else if (TREE_CODE (decl) == VAR_DECL)\n     {\n       struct varpool_node *node = varpool_node (decl);\n       varpool_mark_needed_node (node);\n       /* C++ frontend use mark_decl_references to force COMDAT variables\n          to be output that might appear dead otherwise.  */\n-      node->force_output = true;\n+      node->symbol.force_output = true;\n     }\n   /* else do nothing - we can get various sorts of CST nodes here,\n      which do not need to be marked.  */\n@@ -5271,13 +5271,20 @@ weak_finish_1 (tree decl)\n #endif\n }\n \n+/* Fiven an assembly name, find the decl it is associated with.  */\n+static tree\n+find_decl (tree target)\n+{\n+  symtab_node node = symtab_node_for_asm (target);\n+  if (node)\n+    return node->symbol.decl;\n+  return NULL_TREE;\n+}\n+\n /* This TREE_LIST contains weakref targets.  */\n \n static GTY(()) tree weakref_targets;\n \n-/* Forward declaration.  */\n-static tree find_decl_and_mark_needed (tree decl, tree target);\n-\n /* Emit any pending weak declarations.  */\n \n void\n@@ -5303,7 +5310,7 @@ weak_finish (void)\n # if defined ASM_WEAKEN_LABEL && ! defined ASM_WEAKEN_DECL\n \t  ASM_WEAKEN_LABEL (asm_out_file, IDENTIFIER_POINTER (target));\n # else\n-\t  tree decl = find_decl_and_mark_needed (alias_decl, target);\n+\t  tree decl = find_decl (target);\n \n \t  if (! decl)\n \t    {\n@@ -5406,43 +5413,6 @@ globalize_decl (tree decl)\n \n VEC(alias_pair,gc) *alias_pairs;\n \n-/* Given an assembly name, find the decl it is associated with.  At the\n-   same time, mark it needed for cgraph.  */\n-\n-static tree\n-find_decl_and_mark_needed (tree decl, tree target)\n-{\n-  struct cgraph_node *fnode = NULL;\n-  struct varpool_node *vnode = NULL;\n-\n-  if (TREE_CODE (decl) == FUNCTION_DECL)\n-    {\n-      fnode = cgraph_node_for_asm (target);\n-      if (fnode == NULL)\n-\tvnode = varpool_node_for_asm (target);\n-    }\n-  else\n-    {\n-      vnode = varpool_node_for_asm (target);\n-      if (vnode == NULL)\n-\tfnode = cgraph_node_for_asm (target);\n-    }\n-\n-  if (fnode)\n-    {\n-      cgraph_mark_needed_node (fnode);\n-      return fnode->symbol.decl;\n-    }\n-  else if (vnode)\n-    {\n-      varpool_mark_needed_node (vnode);\n-      vnode->force_output = 1;\n-      return vnode->symbol.decl;\n-    }\n-  else\n-    return NULL_TREE;\n-}\n-\n /* Output the assembler code for a define (equate) using ASM_OUTPUT_DEF\n    or ASM_OUTPUT_DEF_FROM_DECLS.  The function defines the symbol whose\n    tree node is DECL to have the value of the tree node TARGET.  */\n@@ -5748,7 +5718,7 @@ finish_aliases_1 (void)\n     {\n       tree target_decl;\n \n-      target_decl = find_decl_and_mark_needed (p->decl, p->target);\n+      target_decl = find_decl (p->target);\n       if (target_decl == NULL)\n \t{\n \t  if (symbol_alias_set_contains (defined, p->target))\n@@ -5854,7 +5824,7 @@ assemble_alias (tree decl, tree target)\n   /* If the target has already been emitted, we don't have to queue the\n      alias.  This saves a tad of memory.  */\n   if (cgraph_global_info_ready)\n-    target_decl = find_decl_and_mark_needed (decl, target);\n+    target_decl = find_decl (target);\n   else\n     target_decl= NULL;\n   if (target_decl && TREE_ASM_WRITTEN (target_decl))\n@@ -5960,12 +5930,12 @@ dump_tm_clone_pairs (VEC(tm_alias_pair,heap) *tm_alias_pairs)\n \t TM_GETTMCLONE.  If neither of these are true, we didn't generate\n \t a clone, and we didn't call it indirectly... no sense keeping it\n \t in the clone table.  */\n-      if (!dst_n || !dst_n->needed)\n+      if (!dst_n || !dst_n->analyzed)\n \tcontinue;\n \n       /* This covers the case where we have optimized the original\n \t function away, and only access the transactional clone.  */\n-      if (!src_n || !src_n->needed)\n+      if (!src_n || !src_n->analyzed)\n \tcontinue;\n \n       if (!switched)"}, {"sha": "2423ee88db2d2facef09e9a890ba69775a76e66a", "filename": "gcc/varpool.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02", "patch": "@@ -214,7 +214,7 @@ bool\n decide_is_variable_needed (struct varpool_node *node, tree decl)\n {\n   /* If the user told us it is used, then it must be so.  */\n-  if (node->force_output)\n+  if (node->symbol.force_output)\n     return true;\n \n   gcc_assert (!DECL_EXTERNAL (decl));\n@@ -298,7 +298,7 @@ varpool_finalize_decl (tree decl)\n \t optimizing and when not doing toplevel reoder.  */\n       || (!flag_toplevel_reorder && !DECL_COMDAT (node->symbol.decl)\n \t  && !DECL_ARTIFICIAL (node->symbol.decl)))\n-    node->force_output = true;\n+    node->symbol.force_output = true;\n \n   if (decide_is_variable_needed (node, decl))\n     varpool_mark_needed_node (node);\n@@ -410,6 +410,7 @@ varpool_analyze_pending_decls (void)\n \t\t    }\n \t\t}\n \t    }\n+   \t  varpool_mark_needed_node (tgt);\n \t}\n       else if (DECL_INITIAL (decl))\n \trecord_references_in_initializer (decl, analyzed);\n@@ -621,8 +622,7 @@ varpool_create_variable_alias (tree alias, tree decl)\n   gcc_assert (TREE_CODE (alias) == VAR_DECL);\n   alias_node = varpool_node (alias);\n   alias_node->alias = 1;\n-  if (!DECL_EXTERNAL (alias))\n-    alias_node->finalized = 1;\n+  alias_node->finalized = 1;\n   alias_node->alias_of = decl;\n   if ((!DECL_EXTERNAL (alias)\n        && decide_is_variable_needed (alias_node, alias))"}]}