{"sha": "cd7aa66b1b42d04c2dfee55027864d4143aa2a1f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Q3YWE2NmIxYjQyZDA0YzJkZmVlNTUwMjc4NjRkNDE0M2FhMmExZg==", "commit": {"author": {"name": "Daniel J. Berlin", "email": "dan@cgsoftware.com", "date": "2001-06-14T18:54:44Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2001-06-14T18:54:44Z"}, "message": "gcc.texi: Update passes documentation to be more in tune with reality.\n\n2001-06-14  Daniel J. Berlin <dan@cgsoftware.com>\n\n\t* doc/gcc.texi:  Update passes documentation to be more in tune\n\twith reality.\n\nFrom-SVN: r43376", "tree": {"sha": "31b88e017e1fec4aac7898e70d59d753652c6c91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/31b88e017e1fec4aac7898e70d59d753652c6c91"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cd7aa66b1b42d04c2dfee55027864d4143aa2a1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd7aa66b1b42d04c2dfee55027864d4143aa2a1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd7aa66b1b42d04c2dfee55027864d4143aa2a1f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd7aa66b1b42d04c2dfee55027864d4143aa2a1f/comments", "author": null, "committer": null, "parents": [{"sha": "d19da8d1b42f1a75bef55bcfde5574b9b98474b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d19da8d1b42f1a75bef55bcfde5574b9b98474b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d19da8d1b42f1a75bef55bcfde5574b9b98474b6"}], "stats": {"total": 187, "additions": 153, "deletions": 34}, "files": [{"sha": "8f99787da02d8326180a09a77209f27c924848c1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd7aa66b1b42d04c2dfee55027864d4143aa2a1f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd7aa66b1b42d04c2dfee55027864d4143aa2a1f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cd7aa66b1b42d04c2dfee55027864d4143aa2a1f", "patch": "@@ -1,3 +1,8 @@\n+2001-06-14  Daniel J. Berlin <dan@cgsoftware.com>\n+\n+\t* doc/gcc.texi:  Update passes documentation to be more in tune\n+\twith reality.\n+\n Thu Jun 14 15:38:28 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* i386.c (ix86_expand_prologue): Fix merging conflict."}, {"sha": "46b079a3ef4a0e2c1c210e329bcaef64f696510b", "filename": "gcc/doc/gcc.texi", "status": "modified", "additions": 148, "deletions": 34, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd7aa66b1b42d04c2dfee55027864d4143aa2a1f/gcc%2Fdoc%2Fgcc.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd7aa66b1b42d04c2dfee55027864d4143aa2a1f/gcc%2Fdoc%2Fgcc.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgcc.texi?ref=cd7aa66b1b42d04c2dfee55027864d4143aa2a1f", "patch": "@@ -3124,14 +3124,19 @@ file is responsible for initialization, decoding arguments, opening and\n closing files, and sequencing the passes.\n \n @cindex parsing pass\n-The parsing pass is invoked only once, to parse the entire input.  The RTL\n-intermediate code for a function is generated as the function is parsed, a\n-statement at a time.  Each statement is read in as a syntax tree and then\n-converted to RTL; then the storage for the tree for the statement is\n-reclaimed.  Storage for types (and the expressions for their sizes),\n-declarations, and a representation of the binding contours and how they nest,\n-remain until the function is finished being compiled; these are all needed\n-to output the debugging information.\n+The parsing pass is invoked only once, to parse the entire input.  A\n+high level tree representation is then generated from the input, \n+one function at a time.  This tree code is then transformed into RTL\n+intermediate code, and processed. The files involved in transforming\n+the trees into RTL are @file{expr.c}, @file{expmed.c}, and\n+@file{stmt.c}. \n+@c Note, the above files aren't strictly the only files involved. It's\n+@c all over the place (function.c, final.c,etc).  However, those are\n+@c the files that are supposed to be directly involved, and have\n+@c their purpose listed as such, so i've only listed them.\n+The order of trees that are processed, is not\n+necessarily the same order they are generated from \n+the input, due to deferred inlining, and other considerations.  \n \n @findex rest_of_compilation\n @findex rest_of_decl_compilation\n@@ -3144,7 +3149,8 @@ the assembler language.  All other compiler passes run, in sequence,\n within @code{rest_of_compilation}.  When that function returns from\n compiling a function definition, the storage used for that function\n definition's compilation is entirely freed, unless it is an inline\n-function\n+function, or was deferred for some reason (this can occur in\n+templates, for example).\n @ifset USING\n (@pxref{Inline,,An Inline Function is As Fast As a Macro}).\n @end ifset\n@@ -3159,9 +3165,7 @@ with @option{-d} options.\n @itemize @bullet\n @item\n Parsing.  This pass reads the entire text of a function definition,\n-constructing partial syntax trees.  This and RTL generation are no longer\n-truly separate passes (formerly they were), but it is easier to think\n-of them as separate.\n+constructing a high level tree representation.\n \n The tree representation does not entirely follow C syntax, because it is\n intended to support other languages as well.\n@@ -3170,17 +3174,16 @@ Language-specific data type analysis is also done in this pass, and every\n tree node that represents an expression has a data type attached.\n Variables are represented as declaration nodes.\n \n-@cindex constant folding\n-@cindex arithmetic simplifications\n-@cindex simplifications, arithmetic\n-Constant folding and some arithmetic simplifications are also done\n-during this pass.\n-\n The language-independent source files for parsing are\n @file{stor-layout.c}, @file{fold-const.c}, and @file{tree.c}.\n There are also header files @file{tree.h} and @file{tree.def}\n which define the format of the tree representation.@refill\n \n+C Preprocessing, for language front ends, that want or require it, is\n+performed by cpplib, which is covered in seperate documentation.  In\n+particular, the internals are covered in @xref{Top, ,Cpplib internals, cppinternals, Cpplib Internals}.\n+\n+\n @c Avoiding overfull is tricky here.\n The source files to parse C are\n @file{c-parse.in},\n@@ -3200,7 +3203,8 @@ They are @file{parse.y},\n @file{except.c},@*\n @file{expr.c}, @file{init.c}, @file{lex.c},\n @file{method.c}, @file{ptree.c},@*\n-@file{search.c}, @file{tree.c},\n+@file{search.c}, @file{spew.c}, @*\n+@file{semantics.c}, @file{tree.c},\n @file{typeck2.c}, and\n @file{typeck.c}, along with header files @file{cp-tree.def},\n @file{cp-tree.h}, and @file{decl.h}.\n@@ -3212,11 +3216,31 @@ well.\n \n The file @file{c-common.c} is also used for all of the above languages.\n \n+\n+@cindex Tree optimization\n+@item\n+Tree optimization.   This is the optimization of the tree\n+representation, before converting into RTL code.\n+\n+@cindex inline on trees, automatic\n+Currently, the main optimization performed here is tree-based\n+inlining.  \n+This is implemented for C++ in @file{cp/optimize.c}.  Note that\n+tree based inlining turns off rtx based inlining (since it's more\n+powerful, it would be a waste of time to do rtx based inlining in\n+addition).\n+The C front end currently does not perform tree based inlining. \n+\n+@cindex constant folding\n+@cindex arithmetic simplifications\n+@cindex simplifications, arithmetic\n+Constant folding and some arithmetic simplifications are also done\n+during this pass, on the tree representation.\n+The routines that perform these tasks are located in @file{fold-const.c}. \n+\n @cindex RTL generation\n @item\n RTL generation.  This is the conversion of syntax tree into RTL code.\n-It is actually done statement-by-statement during parsing, but for\n-most purposes it can be thought of as a separate pass.\n \n @cindex target-parameter-dependent code\n This is where the bulk of target-parameter-dependent code is found,\n@@ -3257,7 +3281,7 @@ Aside from debugging information output, none of the following passes\n refers to the tree structure representation of the function (only\n part of which is saved).\n \n-@cindex inline, automatic\n+@cindex inline on rtx, automatic\n The decision of whether the function can and should be expanded inline\n in its subsequent callers is made at the end of rtl generation.  The\n function must meet certain criteria, currently related to the size of\n@@ -3274,6 +3298,22 @@ The option @option{-dr} causes a debugging dump of the RTL code after\n this pass.  This dump file's name is made by appending @samp{.rtl} to\n the input file name.\n \n+@c Should the exception handling pass be talked about here?\n+\n+@cindex sibling call optimization\n+@item\n+Sibiling call optimization.   This pass performs tail recursion\n+elimination, and tail and sibling call optimizations.  The purpose of\n+these optimizations is to reduce the overhead of function calls,\n+whenever possible.\n+\n+The source file of this pass is @file{sibcall.c}\n+\n+@opindex di\n+The option @option{-di} causes a debugging dump of the RTL code after\n+this pass is run. This dump file's name is made by appending\n+@samp{.sibling} to the input file name.\n+\n @cindex jump optimization\n @cindex unreachable code\n @cindex dead code\n@@ -3320,26 +3360,71 @@ the second conditional test.  The source code for this pass is in\n @cindex constant propagation\n @item\n Common subexpression elimination.  This pass also does constant\n-propagation.  Its source file is @file{cse.c}.  If constant\n-propagation causes conditional jumps to become unconditional or to\n-become no-ops, jump optimization is run again when CSE is finished.\n+propagation.  Its source files are @file{cse.c}, and @file{cselib.c}.\n+If constant  propagation causes conditional jumps to become\n+unconditional or to become no-ops, jump optimization is run again when\n+CSE is finished. \n \n @opindex ds\n The option @option{-ds} causes a debugging dump of the RTL code after\n this pass.  This dump file's name is made by appending @samp{.cse} to\n the input file name.\n \n+@cindex SSA optimizations\n+@cindex Single Static Assignment optimizations\n+@opindex fssa\n+@item\n+Static Single Assignment (SSA) based optimization passes. The\n+SSA conversion passes (to/from) are turned on by the @option{-fssa}\n+option (it is also done automatically if you enable an SSA optimization pass).\n+These passes utilize a form called Static Single Assignment. In SSA form,\n+each variable (pseudo register) is only set once, giving you def-use\n+and use-def chains for free, and enabling a lot more optimization\n+passes to be run in linear time.\n+Conversion to and from SSA form is handled by functions in\n+@file{ssa.c}.\n+\n+@opindex de\n+The option @option{-de} causes a debugging dump of the RTL code after\n+this pass.  This dump file's name is made by appending @samp{.ssa} to\n+the input file name.\n+@itemize @bullet\n+@cindex SSA DCE \n+@cindex DCE, SSA based\n+@cindex dead code elimination\n+@opindex fdce\n+@item\n+Dead Code Elimination.  Turned on by the @option{-fdce} option. \n+This pass performs elimination of code considered unnecessary because it\n+is never executed.  It operates in linear time.\n+\n+@opindex dX\n+The option @option{-dX} causes a debugging dump of the RTL code after\n+this pass. This dump file's name is made by appending @samp{.dce} to\n+the input file name.\n+@end itemize\n @cindex global common subexpression elimination\n @cindex constant propagation\n @cindex copy propagation\n @item\n-Global common subexpression elimination.  This pass performs GCSE\n-using Morel-Renvoise Partial Redundancy Elimination, with the exception\n-that it does not try to move invariants out of loops---that is left to\n-the loop optimization pass.  This pass also performs global constant\n-and copy propagation.\n-\n-The source file for this pass is gcse.c.\n+Global common subexpression elimination.  This pass performs two\n+different types of GCSE  depending on whether you are optimizing for\n+size or not (LCM based GCSE tends to increase code size for a gain in\n+speed, while Morel-Renvoise based GCSE does not). \n+When optimizing for size, GCSE is done using Morel-Renvoise Partial\n+Redundancy Elimination, with the exception that it does not try to move\n+invariants out of loops---that is left to  the loop optimization pass.\n+If MR PRE GCSE is done, code hoisting (aka unification) is also done, as\n+well as load motion.\n+If you are optimizing for speed, LCM (lazy code motion) based GCSE is\n+done. LCM is based on the work of Knoop, Ruthing, and Steffen.  LCM\n+based GCSE also does loop invariant code motion.  We also perform load\n+and store motion when optimizing for speed.\n+Regardless of which type of GCSE is used, the GCSE pass also performs\n+global constant and  copy propagation.  \n+\n+The source file for this pass is @file{gcse.c}, and the LCM routines\n+are in @file{lcm.c}. \n \n @opindex dG\n The option @option{-dG} causes a debugging dump of the RTL code after\n@@ -3355,6 +3440,7 @@ and optionally does strength-reduction and loop unrolling as well.\n Its source files are @file{loop.c} and @file{unroll.c}, plus the header\n @file{loop.h} used for communication between them.  Loop unrolling uses\n some functions in @file{integrate.c} and the header @file{integrate.h}.\n+Loop dependency analysis routines are contained in @file{dependence.c}.\n \n @opindex dL\n The option @option{-dL} causes a debugging dump of the RTL code after\n@@ -3406,6 +3492,18 @@ The option @option{-dc} causes a debugging dump of the RTL code after\n this pass.  This dump file's name is made by appending @samp{.combine}\n to the input file name.\n \n+@cindex if conversion\n+@item\n+If-conversion is a transformation that transforms control dependencies\n+into data dependencies (IE it transforms conditional code into a\n+single control stream).\n+It is implemented in the file @file{ifcvt.c}.\n+\n+@opindex dE\n+The option @option{-dE} causes a debugging dump of the RTL code after\n+this pass.  This dump file's name is made by appending @samp{.ce} to\n+the input file name.\n+\n @cindex register movement\n @item\n Register movement (@file{regmove.c}). This pass looks for cases where\n@@ -3495,6 +3593,21 @@ The option @option{-dR} causes a debugging dump of the RTL code after\n this pass.  This dump file's name is made by appending @samp{.sched2}\n to the input file name.\n \n+@cindex basic block reordering\n+@cindex reordering, block\n+@item\n+Basic block reordering.  This pass implements profile guided code\n+positioning. If profile information is not available, various types of\n+static analysis are performed to make the predictions normally coming\n+from the profile feedback (IE execution frequency, branch probability,\n+etc). It is implemented in the file @file{bb-reorder.c}, and the\n+various prediction routines are in @file{predict.c}.\n+\n+@opindex dB\n+The option @option{-dB} causes a debugging dump of the RTL code after\n+this pass. This dump file's name is made by appending @samp{.bbro} to\n+the input file name.\n+\n @cindex cross-jumping\n @cindex no-op move instructions\n @item\n@@ -3558,8 +3671,9 @@ for communication between these files.\n Debugging information output.  This is run after final because it must\n output the stack slot offsets for pseudo registers that did not get\n hard registers.  Source files are @file{dbxout.c} for DBX symbol table\n-format, @file{sdbout.c} for SDB symbol table format, and\n-@file{dwarfout.c} for DWARF symbol table format.\n+format, @file{sdbout.c} for SDB symbol table format,  @file{dwarfout.c}\n+for DWARF symbol table format, and the files @file{dwarf2out.c} and\n+@file{dwarf2asm.c} for DWARF2 symbol table format.\n @end itemize\n \n Some additional files are used by all or many passes:"}]}