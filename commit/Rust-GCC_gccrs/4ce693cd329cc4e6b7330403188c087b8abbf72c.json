{"sha": "4ce693cd329cc4e6b7330403188c087b8abbf72c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGNlNjkzY2QzMjljYzRlNmI3MzMwNDAzMTg4YzA4N2I4YWJiZjcyYw==", "commit": {"author": {"name": "Stan Shebs", "email": "shebs@apple.com", "date": "2001-03-09T03:27:41Z"}, "committer": {"name": "Stan Shebs", "email": "shebs@gcc.gnu.org", "date": "2001-03-09T03:27:41Z"}, "message": "objc-act.c: Fix old typos in comments, add comments for various functions.\n\n        * objc/objc-act.c: Fix old typos in comments, add comments for\n        various functions.\n        (hash_init): Fix file name in error message.\n        (hash_enter): Ditto.\n        (hash_add_attr): Ditto.\n        (continue_class): Ditto.\n\nFrom-SVN: r40338", "tree": {"sha": "ad78bb3e15e7bdc6d4d4bd612bc9dc08b521ec35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad78bb3e15e7bdc6d4d4bd612bc9dc08b521ec35"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ce693cd329cc4e6b7330403188c087b8abbf72c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ce693cd329cc4e6b7330403188c087b8abbf72c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ce693cd329cc4e6b7330403188c087b8abbf72c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ce693cd329cc4e6b7330403188c087b8abbf72c/comments", "author": null, "committer": null, "parents": [{"sha": "6771219aaaea365352a4edece9d20f5e74460896", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6771219aaaea365352a4edece9d20f5e74460896", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6771219aaaea365352a4edece9d20f5e74460896"}], "stats": {"total": 54, "additions": 43, "deletions": 11}, "files": [{"sha": "468d4a0840a107d2db126aa3dbfc3019d738a5c1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ce693cd329cc4e6b7330403188c087b8abbf72c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ce693cd329cc4e6b7330403188c087b8abbf72c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4ce693cd329cc4e6b7330403188c087b8abbf72c", "patch": "@@ -1,3 +1,12 @@\n+2001-03-08  Stan Shebs  <shebs@apple.com>\n+\n+\t* objc/objc-act.c: Fix old typos in comments, add comments for\n+\tvarious functions.\n+\t(hash_init): Fix file name in error message.\n+\t(hash_enter): Ditto.\n+\t(hash_add_attr): Ditto.\n+\t(continue_class): Ditto.\n+\n 2001-03-08  Bruce Korb  <bkorb@gnu.org>\n \n \tgcc.c(main): ensure SIGCHLD handling is set to SIG_DFL so that"}, {"sha": "0d2b8049d8207b392b577efcdeba03d500cdcd52", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 34, "deletions": 11, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ce693cd329cc4e6b7330403188c087b8abbf72c/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ce693cd329cc4e6b7330403188c087b8abbf72c/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=4ce693cd329cc4e6b7330403188c087b8abbf72c", "patch": "@@ -901,7 +901,7 @@ lookup_protocol_in_reflist (rproto_list, lproto)\n {\n    tree rproto, p;\n \n-   /* Make sure the protocol is support by the object on the rhs.  */\n+   /* Make sure the protocol is supported by the object on the rhs.  */\n    if (TREE_CODE (lproto) == PROTOCOL_INTERFACE_TYPE)\n      {\n        tree fnd = 0;\n@@ -1021,7 +1021,7 @@ objc_comptypes (lhs, rhs, reflexive)\n \treturn (TYPED_OBJECT (TREE_TYPE (lhs)) != 0);\n \n       else\n-\t/* Defer to comptypes .*/\n+\t/* Defer to comptypes.  */\n \treturn -1;\n     }\n \n@@ -1118,7 +1118,8 @@ get_static_reference (interface, protocols)\n       TYPE_NEXT_VARIANT (t) = TYPE_NEXT_VARIANT (m);\n       TYPE_NEXT_VARIANT (m) = t;\n \n-      /* Look up protocols and install in lang specific list.  */\n+      /* Look up protocols and install in lang specific list.  Note\n+\t that the protocol list can have a different lifetime than T!  */\n       TYPE_PROTOCOL_LIST (t) = lookup_and_install_protocols (protocols);\n \n       /* This forces a new pointer type to be created later\n@@ -1404,11 +1405,11 @@ my_build_string (len, str)\n }\n \n /* Given a chain of STRING_CST's, build a static instance of\n-   NXConstanString which points at the concatenation of those strings.\n+   NXConstantString which points at the concatenation of those strings.\n    We place the string object in the __string_objects section of the\n    __OBJC segment.  The Objective-C runtime will initialize the isa\n-   pointers of the string objects to point at the NXConstandString class\n-   object.  */\n+   pointers of the string objects to point at the NXConstantString\n+   class object.  */\n \n tree\n build_objc_string_object (strings)\n@@ -3038,6 +3039,9 @@ generate_method_descriptors (protocol)\t/* generate_dispatch_tables */\n     UOBJC_INSTANCE_METHODS_decl = 0;\n }\n \n+/* Generate a temporary FUNCTION_DECL node to be used in\n+   hack_method_prototype below.  */\n+\n static tree\n build_tmp_function_decl ()\n {\n@@ -3071,6 +3075,13 @@ build_tmp_function_decl ()\n   return define_decl (expr_decl, decl_specs);\n }\n \n+/* Generate the prototypes for protocol methods.  This is used to\n+   generate method encodings for these.\n+\n+   NST_METHODS is the method to generate a _DECL node for TMP_DECL is\n+   a decl node to be used.  This is also where the return value is\n+   given.  */\n+\n static void\n hack_method_prototype (nst_methods, tmp_decl)\n      tree nst_methods;\n@@ -5439,7 +5450,7 @@ hash_init ()\n   cls_method_hash_list = (hash *)xmalloc (SIZEHASHTABLE * sizeof (hash));\n \n   if (!nst_method_hash_list || !cls_method_hash_list)\n-    perror (\"unable to allocate space in objc-tree.c\");\n+    perror (\"unable to allocate space in objc-act.c\");\n   else\n     {\n       int i;\n@@ -5452,6 +5463,11 @@ hash_init ()\n     }\n }\n \n+/* WARNING!!!!  hash_enter is called with a method, and will peek\n+   inside to find its selector!  But hash_lookup is given a selector\n+   directly, and looks for the selector that's inside the found\n+   entry's key (method) for comparison.  */\n+\n static void\n hash_enter (hashlist, method)\n      hash *hashlist;\n@@ -5468,7 +5484,7 @@ hash_enter (hashlist, method)\n       hash_alloc_list = (hash) xmalloc (sizeof (struct hashed_entry)\n \t\t\t\t\t* HASH_ALLOC_LIST_SIZE);\n       if (! hash_alloc_list)\n-\tperror (\"unable to allocate in objc-tree.c\");\n+\tperror (\"unable to allocate in objc-act.c\");\n     }\n   obj = &hash_alloc_list[hash_alloc_index++];\n   obj->list = 0;\n@@ -5512,7 +5528,7 @@ hash_add_attr (entry, value)\n       attr_alloc_list = (attr) xmalloc (sizeof (struct hashed_attribute)\n \t\t\t\t\t* ATTR_ALLOC_LIST_SIZE);\n       if (! attr_alloc_list)\n-\tperror (\"unable to allocate in objc-tree.c\");\n+\tperror (\"unable to allocate in objc-act.c\");\n     }\n   obj = &attr_alloc_list[attr_alloc_index++];\n   obj->next = entry->list;\n@@ -5913,6 +5929,9 @@ tree\n get_class_ivars (interface)\n      tree interface;\n {\n+  /* Make sure we copy the leaf ivars in case @defs is used in a local\n+     context.  Otherwise finish_struct will overwrite the layout info\n+     using temporary storage.  */\n   return build_ivar_chain (interface, 1);\n }\n \f\n@@ -6283,7 +6302,7 @@ continue_class (class)\n \n       if (!(imp_entry\n \t    = (struct imp_entry *) xmalloc (sizeof (struct imp_entry))))\n-\tperror (\"unable to allocate in objc-tree.c\");\n+\tperror (\"unable to allocate in objc-act.c\");\n \n       imp_entry->next = imp_list;\n       imp_entry->imp_context = class;\n@@ -7164,6 +7183,8 @@ really_start_method (method, parmlist)\n \n   METHOD_DEFINITION (method) = current_function_decl;\n \n+  /* Check consistency...start_function, pushdecl, duplicate_decls.  */\n+\n   if (implementation_template != implementation_context)\n     {\n       tree proto;\n@@ -7270,6 +7291,7 @@ get_super_receiver ()\n \t  tree super_name = CLASS_SUPER_NAME (implementation_template);\n \t  tree super_class;\n \n+\t  /* Barf if super used in a category of Object. */\n \t  if (!super_name)\n \t    {\n \t      error (\"no super class declared in interface for `%s'\",\n@@ -7368,6 +7390,7 @@ encode_method_def (func_decl)\n       obstack_grow (&util_obstack, buffer, strlen (buffer));\n     }\n \n+  /* Null terminate string.  */\n   obstack_1grow (&util_obstack, 0);\n   result = get_identifier (obstack_finish (&util_obstack));\n   obstack_free (&util_obstack, util_firstobj);\n@@ -7774,7 +7797,7 @@ gen_declspecs (declspecs, buf, raw)\n \t    strcat (buf, \"long double \");\n \t  break;\n \n-      case RECORD_TYPE:\n+\tcase RECORD_TYPE:\n \t  if (TYPE_NAME (declspecs)\n \t      && TREE_CODE (TYPE_NAME (declspecs)) == IDENTIFIER_NODE)\n \t    {"}]}