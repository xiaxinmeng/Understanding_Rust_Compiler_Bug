{"sha": "3386d77eb83f3043afcc46503356165bc5ddfdba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzM4NmQ3N2ViODNmMzA0M2FmY2M0NjUwMzM1NjE2NWJjNWRkZmRiYQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2014-03-13T20:24:56Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2014-03-13T20:24:56Z"}, "message": "re PR debug/60438 (dwarf2cfi :2239 still assert,not the same cause as PR 59575)\n\nPR debug/60438\n\n        * config/i386/i386.c (ix86_split_fp_branch): Remove pushed argument.\n        (ix86_force_to_memory, ix86_free_from_memory): Remove.\n        * config/i386/i386-protos.h: Likewise.\n        * config/i386/i386.md (floathi<X87MODEF>2): Use assign_386_stack_local\n        in the expander instead of a splitter.\n        (float<SWI48x><X87MODEF>2): Use assign_386_stack_local if there is\n        any possibility of requiring a memory.\n        (*floatsi<MODEF>2_vector_mixed): Remove, and the splitters.\n        (*floatsi<MODEF>2_vector_sse): Remove, and the splitters.\n        (fp branch splitters): Update for ix86_split_fp_branch.\n        (*jcc<X87MODEF>_<SWI24>_i387): Remove r/f alternative.\n        (*jcc<X87MODEF>_<SWI24>_r_i387): Likewise.\n        (splitter for jcc<X87MODEF>_<SWI24>_i387 r/f): Remove.\n        (*fop_<MODEF>_2_i387): Remove f/r alternative.\n        (*fop_<MODEF>_3_i387): Likewise.\n        (*fop_xf_2_i387, *fop_xf_3_i387): Likewise.\n        (splitters for the fop_* register patterns): Remove.\n        (fscalexf4_i387): Rename from *fscalexf4_i387.\n        (ldexpxf3): Use gen_floatsixf2 and gen_fscalexf4_i387.\n\nFrom-SVN: r208556", "tree": {"sha": "f3dd0bc1a1c9fa223e48ce3b25fcecd8f54c2fcb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3dd0bc1a1c9fa223e48ce3b25fcecd8f54c2fcb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3386d77eb83f3043afcc46503356165bc5ddfdba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3386d77eb83f3043afcc46503356165bc5ddfdba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3386d77eb83f3043afcc46503356165bc5ddfdba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3386d77eb83f3043afcc46503356165bc5ddfdba/comments", "author": null, "committer": null, "parents": [{"sha": "5b5d7f31c27558a5bc3ba16659defb54ecfc682d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b5d7f31c27558a5bc3ba16659defb54ecfc682d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b5d7f31c27558a5bc3ba16659defb54ecfc682d"}], "stats": {"total": 484, "additions": 133, "deletions": 351}, "files": [{"sha": "8f92d2db8098c4e71745f57c67c1581cc4738eb1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3386d77eb83f3043afcc46503356165bc5ddfdba/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3386d77eb83f3043afcc46503356165bc5ddfdba/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3386d77eb83f3043afcc46503356165bc5ddfdba", "patch": "@@ -1,3 +1,26 @@\n+2014-03-13  Richard Henderson  <rth@redhat.com>\n+\n+\tPR debug/60438\n+\t* config/i386/i386.c (ix86_split_fp_branch): Remove pushed argument.\n+\t(ix86_force_to_memory, ix86_free_from_memory): Remove.\n+\t* config/i386/i386-protos.h: Likewise.\n+\t* config/i386/i386.md (floathi<X87MODEF>2): Use assign_386_stack_local\n+\tin the expander instead of a splitter.\n+\t(float<SWI48x><X87MODEF>2): Use assign_386_stack_local if there is\n+\tany possibility of requiring a memory.\n+\t(*floatsi<MODEF>2_vector_mixed): Remove, and the splitters.\n+\t(*floatsi<MODEF>2_vector_sse): Remove, and the splitters.\n+\t(fp branch splitters): Update for ix86_split_fp_branch.\n+\t(*jcc<X87MODEF>_<SWI24>_i387): Remove r/f alternative.\n+\t(*jcc<X87MODEF>_<SWI24>_r_i387): Likewise.\n+\t(splitter for jcc<X87MODEF>_<SWI24>_i387 r/f): Remove.\n+\t(*fop_<MODEF>_2_i387): Remove f/r alternative.\n+\t(*fop_<MODEF>_3_i387): Likewise.\n+\t(*fop_xf_2_i387, *fop_xf_3_i387): Likewise.\n+\t(splitters for the fop_* register patterns): Remove.\n+\t(fscalexf4_i387): Rename from *fscalexf4_i387.\n+\t(ldexpxf3): Use gen_floatsixf2 and gen_fscalexf4_i387.\n+\t\n 2014-03-13  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/59779"}, {"sha": "6e3297880888039e9165af70ae7b51acce1b6f58", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3386d77eb83f3043afcc46503356165bc5ddfdba/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3386d77eb83f3043afcc46503356165bc5ddfdba/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=3386d77eb83f3043afcc46503356165bc5ddfdba", "patch": "@@ -154,13 +154,11 @@ extern enum machine_mode ix86_fp_compare_mode (enum rtx_code);\n extern rtx ix86_libcall_value (enum machine_mode);\n extern bool ix86_function_arg_regno_p (int);\n extern void ix86_asm_output_function_label (FILE *, const char *, tree);\n-extern rtx ix86_force_to_memory (enum machine_mode, rtx);\n-extern void ix86_free_from_memory (enum machine_mode);\n extern void ix86_call_abi_override (const_tree);\n extern int ix86_reg_parm_stack_space (const_tree);\n \n extern void ix86_split_fp_branch (enum rtx_code code, rtx, rtx,\n-\t\t\t\t  rtx, rtx, rtx, rtx);\n+\t\t\t\t  rtx, rtx, rtx);\n extern bool ix86_hard_regno_mode_ok (int, enum machine_mode);\n extern bool ix86_modes_tieable_p (enum machine_mode, enum machine_mode);\n extern bool ix86_secondary_memory_needed (enum reg_class, enum reg_class,"}, {"sha": "64b8e0a956b014a3dc27b4de53d2c64581f131f9", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 1, "deletions": 104, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3386d77eb83f3043afcc46503356165bc5ddfdba/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3386d77eb83f3043afcc46503356165bc5ddfdba/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=3386d77eb83f3043afcc46503356165bc5ddfdba", "patch": "@@ -19993,7 +19993,7 @@ ix86_expand_branch (enum rtx_code code, rtx op0, rtx op1, rtx label)\n /* Split branch based on floating point condition.  */\n void\n ix86_split_fp_branch (enum rtx_code code, rtx op1, rtx op2,\n-\t\t      rtx target1, rtx target2, rtx tmp, rtx pushed)\n+\t\t      rtx target1, rtx target2, rtx tmp)\n {\n   rtx condition;\n   rtx i;\n@@ -20009,10 +20009,6 @@ ix86_split_fp_branch (enum rtx_code code, rtx op1, rtx op2,\n   condition = ix86_expand_fp_compare (code, op1, op2,\n \t\t\t\t      tmp);\n \n-  /* Remove pushed operand from stack.  */\n-  if (pushed)\n-    ix86_free_from_memory (GET_MODE (pushed));\n-\n   i = emit_jump_insn (gen_rtx_SET\n \t\t      (VOIDmode, pc_rtx,\n \t\t       gen_rtx_IF_THEN_ELSE (VOIDmode,\n@@ -36994,105 +36990,6 @@ avx_vperm2f128_parallel (rtx par, enum machine_mode mode)\n   return mask + 1;\n }\n \f\n-/* Store OPERAND to the memory after reload is completed.  This means\n-   that we can't easily use assign_stack_local.  */\n-rtx\n-ix86_force_to_memory (enum machine_mode mode, rtx operand)\n-{\n-  rtx result;\n-\n-  gcc_assert (reload_completed);\n-  if (ix86_using_red_zone ())\n-    {\n-      result = gen_rtx_MEM (mode,\n-\t\t\t    gen_rtx_PLUS (Pmode,\n-\t\t\t\t\t  stack_pointer_rtx,\n-\t\t\t\t\t  GEN_INT (-RED_ZONE_SIZE)));\n-      emit_move_insn (result, operand);\n-    }\n-  else if (TARGET_64BIT)\n-    {\n-      switch (mode)\n-\t{\n-\tcase HImode:\n-\tcase SImode:\n-\t  operand = gen_lowpart (DImode, operand);\n-\t  /* FALLTHRU */\n-\tcase DImode:\n-\t  emit_insn (\n-\t\t      gen_rtx_SET (VOIDmode,\n-\t\t\t\t   gen_rtx_MEM (DImode,\n-\t\t\t\t\t\tgen_rtx_PRE_DEC (DImode,\n-\t\t\t\t\t\t\tstack_pointer_rtx)),\n-\t\t\t\t   operand));\n-\t  break;\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-      result = gen_rtx_MEM (mode, stack_pointer_rtx);\n-    }\n-  else\n-    {\n-      switch (mode)\n-\t{\n-\tcase DImode:\n-\t  {\n-\t    rtx operands[2];\n-\t    split_double_mode (mode, &operand, 1, operands, operands + 1);\n-\t    emit_insn (\n-\t\t\tgen_rtx_SET (VOIDmode,\n-\t\t\t\t     gen_rtx_MEM (SImode,\n-\t\t\t\t\t\t  gen_rtx_PRE_DEC (Pmode,\n-\t\t\t\t\t\t\tstack_pointer_rtx)),\n-\t\t\t\t     operands[1]));\n-\t    emit_insn (\n-\t\t\tgen_rtx_SET (VOIDmode,\n-\t\t\t\t     gen_rtx_MEM (SImode,\n-\t\t\t\t\t\t  gen_rtx_PRE_DEC (Pmode,\n-\t\t\t\t\t\t\tstack_pointer_rtx)),\n-\t\t\t\t     operands[0]));\n-\t  }\n-\t  break;\n-\tcase HImode:\n-\t  /* Store HImodes as SImodes.  */\n-\t  operand = gen_lowpart (SImode, operand);\n-\t  /* FALLTHRU */\n-\tcase SImode:\n-\t  emit_insn (\n-\t\t      gen_rtx_SET (VOIDmode,\n-\t\t\t\t   gen_rtx_MEM (GET_MODE (operand),\n-\t\t\t\t\t\tgen_rtx_PRE_DEC (SImode,\n-\t\t\t\t\t\t\tstack_pointer_rtx)),\n-\t\t\t\t   operand));\n-\t  break;\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-      result = gen_rtx_MEM (mode, stack_pointer_rtx);\n-    }\n-  return result;\n-}\n-\n-/* Free operand from the memory.  */\n-void\n-ix86_free_from_memory (enum machine_mode mode)\n-{\n-  if (!ix86_using_red_zone ())\n-    {\n-      int size;\n-\n-      if (mode == DImode || TARGET_64BIT)\n-\tsize = 8;\n-      else\n-\tsize = 4;\n-      /* Use LEA to deallocate stack space.  In peephole2 it will be converted\n-         to pop or add instruction if registers are available.  */\n-      emit_insn (gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n-\t\t\t      gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t    GEN_INT (size))));\n-    }\n-}\n-\n /* Return a register priority for hard reg REGNO.  */\n static int\n ix86_register_priority (int hard_regno)"}, {"sha": "03939fd71cc542c30effb038b0ff45e9c78cb6ac", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 74, "deletions": 244, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3386d77eb83f3043afcc46503356165bc5ddfdba/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3386d77eb83f3043afcc46503356165bc5ddfdba/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=3386d77eb83f3043afcc46503356165bc5ddfdba", "patch": "@@ -4656,26 +4656,16 @@\n ;; wants to be able to do this between registers.\n \n (define_expand \"floathi<mode>2\"\n-  [(set (match_operand:X87MODEF 0 \"register_operand\")\n-\t(float:X87MODEF (match_operand:HI 1 \"nonimmediate_operand\")))]\n-  \"TARGET_80387\n-   && (!(SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)\n-       || TARGET_MIX_SSE_I387)\")\n-\n-;; Pre-reload splitter to add memory clobber to the pattern.\n-(define_insn_and_split \"*floathi<mode>2_1\"\n-  [(set (match_operand:X87MODEF 0 \"register_operand\")\n-\t(float:X87MODEF (match_operand:HI 1 \"register_operand\")))]\n+  [(parallel [(set (match_operand:X87MODEF 0 \"register_operand\")\n+\t\t   (float:X87MODEF\n+\t\t     (match_operand:HI 1 \"nonimmediate_operand\")))\n+              (clobber (match_dup 2))])]\n   \"TARGET_80387\n    && (!(SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)\n-       || TARGET_MIX_SSE_I387)\n-   && can_create_pseudo_p ()\"\n-  \"#\"\n-  \"&& 1\"\n-  [(parallel [(set (match_dup 0)\n-\t      (float:X87MODEF (match_dup 1)))\n-   (clobber (match_dup 2))])]\n-  \"operands[2] = assign_386_stack_local (HImode, SLOT_TEMP);\")\n+       || TARGET_MIX_SSE_I387)\"\n+{\n+  operands[2] = assign_386_stack_local (HImode, SLOT_TEMP);\n+})\n \n (define_insn \"*floathi<mode>2_i387_with_temp\"\n   [(set (match_operand:X87MODEF 0 \"register_operand\" \"=f,f\")\n@@ -4723,14 +4713,17 @@\n   [(set (match_dup 0) (float:X87MODEF (match_dup 1)))])\n \n (define_expand \"float<SWI48x:mode><X87MODEF:mode>2\"\n-  [(set (match_operand:X87MODEF 0 \"register_operand\")\n-\t(float:X87MODEF\n-\t  (match_operand:SWI48x 1 \"nonimmediate_operand\")))]\n+  [(parallel [(set (match_operand:X87MODEF 0 \"register_operand\")\n+\t\t   (float:X87MODEF\n+\t\t     (match_operand:SWI48x 1 \"nonimmediate_operand\")))\n+              (clobber (match_dup 2))])]\n   \"TARGET_80387\n    || ((<SWI48x:MODE>mode != DImode || TARGET_64BIT)\n        && SSE_FLOAT_MODE_P (<X87MODEF:MODE>mode) && TARGET_SSE_MATH)\"\n {\n-  if (!((<SWI48x:MODE>mode != DImode || TARGET_64BIT)\n+  bool native_int = TARGET_64BIT || <SWI48x:MODE>mode != DImode;\n+\n+  if (!(native_int\n \t&& SSE_FLOAT_MODE_P (<X87MODEF:MODE>mode) && TARGET_SSE_MATH)\n       && !X87_ENABLE_FLOAT (<X87MODEF:MODE>mode, <SWI48x:MODE>mode))\n     {\n@@ -4749,44 +4742,34 @@\n       emit_insn (insn (operands[0], reg));\n       DONE;\n     }\n-})\n-\n-;; Pre-reload splitter to add memory clobber to the pattern.\n-(define_insn_and_split \"*float<SWI48x:mode><X87MODEF:mode>2_1\"\n-  [(set (match_operand:X87MODEF 0 \"register_operand\")\n-\t(float:X87MODEF (match_operand:SWI48x 1 \"register_operand\")))]\n-  \"((TARGET_80387\n-     && X87_ENABLE_FLOAT (<X87MODEF:MODE>mode, <SWI48x:MODE>mode)\n-     && (!((<SWI48x:MODE>mode != DImode || TARGET_64BIT)\n-\t   && SSE_FLOAT_MODE_P (<X87MODEF:MODE>mode) && TARGET_SSE_MATH)\n-\t || TARGET_MIX_SSE_I387))\n-    || ((<SWI48x:MODE>mode != DImode || TARGET_64BIT)\n-\t&& SSE_FLOAT_MODE_P (<X87MODEF:MODE>mode) && TARGET_SSE_MATH\n-\t&& ((<SWI48x:MODE>mode == SImode\n-\t     && TARGET_SSE2 && TARGET_USE_VECTOR_CONVERTS\n-\t     && optimize_function_for_speed_p (cfun)\n-\t     && flag_trapping_math)\n-\t    || !(TARGET_INTER_UNIT_CONVERSIONS\n-\t         || optimize_function_for_size_p (cfun)))))\n-   && can_create_pseudo_p ()\"\n-  \"#\"\n-  \"&& 1\"\n-  [(parallel [(set (match_dup 0) (float:X87MODEF (match_dup 1)))\n-\t      (clobber (match_dup 2))])]\n-{\n-  operands[2] = assign_386_stack_local (<SWI48x:MODE>mode, SLOT_TEMP);\n \n   /* Avoid store forwarding (partial memory) stall penalty\n      by passing DImode value through XMM registers.  */\n-  if (<SWI48x:MODE>mode == DImode && !TARGET_64BIT\n+  if (!native_int\n       && TARGET_80387 && TARGET_SSE2 && TARGET_INTER_UNIT_MOVES_TO_VEC\n       && optimize_function_for_speed_p (cfun))\n     {\n+      operands[2] = assign_386_stack_local (<SWI48x:MODE>mode, SLOT_TEMP);\n       emit_insn (gen_floatdi<X87MODEF:mode>2_i387_with_xmm (operands[0],\n \t\t\t\t\t\t\t    operands[1],\n \t\t\t\t\t\t\t    operands[2]));\n       DONE;\n     }\n+\n+  /* Notice when we'd convert directly from general registers.  */\n+  if (native_int\n+      && (TARGET_MIX_SSE_I387 || TARGET_SSE_MATH)\n+      && SSE_FLOAT_MODE_P (<X87MODEF:MODE>mode)\n+      && (TARGET_INTER_UNIT_CONVERSIONS\n+          || optimize_function_for_size_p (cfun)))\n+    {\n+      emit_insn (gen_rtx_SET\n+                 (VOIDmode, operands[0],\n+                  gen_rtx_FLOAT (<X87MODEF:MODE>mode, operands[1])));\n+      DONE;\n+    }\n+\n+  operands[2] = assign_386_stack_local (<SWI48x:MODE>mode, SLOT_TEMP);\n })\n \n (define_insn \"*floatsi<mode>2_vector_mixed_with_temp\"\n@@ -4805,22 +4788,6 @@\n    (set_attr \"bdver1_decode\" \"*,*,double,direct,double\")\n    (set_attr \"fp_int_src\" \"true\")])\n \n-(define_insn \"*floatsi<mode>2_vector_mixed\"\n-  [(set (match_operand:MODEF 0 \"register_operand\" \"=f,x\")\n-\t(float:MODEF (match_operand:SI 1 \"memory_operand\" \"m,m\")))]\n-  \"TARGET_SSE2 && TARGET_MIX_SSE_I387\n-   && TARGET_USE_VECTOR_CONVERTS && optimize_function_for_speed_p (cfun)\"\n-  \"@\n-   fild%Z1\\t%1\n-   #\"\n-  [(set_attr \"type\" \"fmov,sseicvt\")\n-   (set_attr \"mode\" \"<MODE>,<ssevecmode>\")\n-   (set_attr \"unit\" \"i387,*\")\n-   (set_attr \"athlon_decode\" \"*,direct\")\n-   (set_attr \"amdfam10_decode\" \"*,double\")\n-   (set_attr \"bdver1_decode\" \"*,direct\")\n-   (set_attr \"fp_int_src\" \"true\")])\n-\n (define_insn \"*float<SWI48:mode><MODEF:mode>2_mixed_with_temp\"\n   [(set (match_operand:MODEF 0 \"register_operand\" \"=f,f,x,x\")\n \t(float:MODEF\n@@ -4836,15 +4803,6 @@\n    (set_attr \"bdver1_decode\" \"*,*,double,direct\")\n    (set_attr \"fp_int_src\" \"true\")])\n \n-(define_split\n-  [(set (match_operand:MODEF 0 \"register_operand\")\n-\t(float:MODEF (match_operand:SWI48 1 \"register_operand\")))\n-   (clobber (match_operand:SWI48 2 \"memory_operand\"))]\n-  \"SSE_FLOAT_MODE_P (<MODEF:MODE>mode) && TARGET_MIX_SSE_I387\n-   && TARGET_INTER_UNIT_CONVERSIONS\n-   && reload_completed && SSE_REG_P (operands[0])\"\n-  [(set (match_dup 0) (float:MODEF (match_dup 1)))])\n-\n (define_split\n   [(set (match_operand:MODEF 0 \"register_operand\")\n \t(float:MODEF (match_operand:SWI48 1 \"register_operand\")))\n@@ -4918,19 +4876,6 @@\n    (set_attr \"bdver1_decode\" \"double,direct,double\")\n    (set_attr \"fp_int_src\" \"true\")])\n \n-(define_insn \"*floatsi<mode>2_vector_sse\"\n-  [(set (match_operand:MODEF 0 \"register_operand\" \"=x\")\n-\t(float:MODEF (match_operand:SI 1 \"memory_operand\" \"m\")))]\n-  \"TARGET_SSE2 && TARGET_SSE_MATH\n-   && TARGET_USE_VECTOR_CONVERTS && optimize_function_for_speed_p (cfun)\"\n-  \"#\"\n-  [(set_attr \"type\" \"sseicvt\")\n-   (set_attr \"mode\" \"<MODE>\")\n-   (set_attr \"athlon_decode\" \"direct\")\n-   (set_attr \"amdfam10_decode\" \"double\")\n-   (set_attr \"bdver1_decode\" \"direct\")\n-   (set_attr \"fp_int_src\" \"true\")])\n-\n (define_split\n   [(set (match_operand:MODEF 0 \"register_operand\")\n \t(float:MODEF (match_operand:SI 1 \"register_operand\")))\n@@ -4993,49 +4938,6 @@\n   DONE;\n })\n \n-(define_split\n-  [(set (match_operand:MODEF 0 \"register_operand\")\n-\t(float:MODEF (match_operand:SI 1 \"register_operand\")))]\n-  \"TARGET_SSE2 && TARGET_SSE_MATH\n-   && TARGET_USE_VECTOR_CONVERTS && optimize_function_for_speed_p (cfun)\n-   && reload_completed && SSE_REG_P (operands[0])\"\n-  [(const_int 0)]\n-{\n-  rtx op1 = operands[1];\n-\n-  operands[3] = simplify_gen_subreg (<ssevecmode>mode, operands[0],\n-\t\t\t\t     <MODE>mode, 0);\n-  if (GET_CODE (op1) == SUBREG)\n-    op1 = SUBREG_REG (op1);\n-\n-  if (GENERAL_REG_P (op1))\n-    {\n-      operands[4] = simplify_gen_subreg (V4SImode, operands[0], <MODE>mode, 0);\n-      if (TARGET_INTER_UNIT_MOVES_TO_VEC)\n-\temit_insn (gen_sse2_loadld (operands[4],\n-\t\t\t\t    CONST0_RTX (V4SImode), operands[1]));\n-      else\n-\t{\n-\t  operands[5] = ix86_force_to_memory (GET_MODE (operands[1]),\n-\t\t\t\t\t      operands[1]);\n-\t  emit_insn (gen_sse2_loadld (operands[4],\n-\t\t\t\t      CONST0_RTX (V4SImode), operands[5]));\n-\t  ix86_free_from_memory (GET_MODE (operands[1]));\n-\t}\n-    }\n-  /* We can ignore possible trapping value in the\n-     high part of SSE register for non-trapping math. */\n-  else if (SSE_REG_P (op1) && !flag_trapping_math)\n-    operands[4] = simplify_gen_subreg (V4SImode, operands[1], SImode, 0);\n-  else\n-    gcc_unreachable ();\n-  if (<ssevecmode>mode == V4SFmode)\n-    emit_insn (gen_floatv4siv4sf2 (operands[3], operands[4]));\n-  else\n-    emit_insn (gen_sse2_cvtdq2pd (operands[3], operands[4]));\n-  DONE;\n-})\n-\n (define_split\n   [(set (match_operand:MODEF 0 \"register_operand\")\n \t(float:MODEF (match_operand:SI 1 \"memory_operand\")))]\n@@ -5134,14 +5036,6 @@\n   [(set (match_dup 2) (match_dup 1))\n    (set (match_dup 0) (float:MODEF (match_dup 2)))])\n \n-(define_split\n-  [(set (match_operand:MODEF 0 \"register_operand\")\n-\t(float:MODEF (match_operand:SWI48 1 \"memory_operand\")))\n-   (clobber (match_operand:SWI48 2 \"memory_operand\"))]\n-  \"SSE_FLOAT_MODE_P (<MODEF:MODE>mode) && TARGET_SSE_MATH\n-   && reload_completed && SSE_REG_P (operands[0])\"\n-  [(set (match_dup 0) (float:MODEF (match_dup 1)))])\n-\n (define_insn \"*float<SWI48x:mode><X87MODEF:mode>2_i387_with_temp\"\n   [(set (match_operand:X87MODEF 0 \"register_operand\" \"=f,f\")\n \t(float:X87MODEF\n@@ -11370,7 +11264,7 @@\n   [(const_int 0)]\n {\n   ix86_split_fp_branch (GET_CODE (operands[0]), operands[1], operands[2],\n-\t                operands[3], operands[4], NULL_RTX, NULL_RTX);\n+\t                operands[3], operands[4], NULL_RTX);\n   DONE;\n })\n \n@@ -11389,7 +11283,7 @@\n   [(const_int 0)]\n {\n   ix86_split_fp_branch (GET_CODE (operands[0]), operands[1], operands[2],\n-\t     \t\toperands[3], operands[4], operands[5], NULL_RTX);\n+\t\t\toperands[3], operands[4], operands[5]);\n   DONE;\n })\n \n@@ -11403,13 +11297,13 @@\n \t(if_then_else\n \t  (match_operator:CCFP 0 \"ix86_swapped_fp_comparison_operator\"\n \t    [(match_operator:X87MODEF 1 \"float_operator\"\n-\t      [(match_operand:SWI24 2 \"nonimmediate_operand\" \"m,?r\")])\n-\t     (match_operand:X87MODEF 3 \"register_operand\" \"f,f\")])\n+\t      [(match_operand:SWI24 2 \"nonimmediate_operand\" \"m\")])\n+\t     (match_operand:X87MODEF 3 \"register_operand\" \"f\")])\n \t  (label_ref (match_operand 4))\n \t  (pc)))\n    (clobber (reg:CCFP FPSR_REG))\n    (clobber (reg:CCFP FLAGS_REG))\n-   (clobber (match_scratch:HI 5 \"=a,a\"))]\n+   (clobber (match_scratch:HI 5 \"=a\"))]\n   \"TARGET_80387 && !TARGET_CMOVE\n    && (TARGET_USE_<SWI24:MODE>MODE_FIOP\n        || optimize_function_for_size_p (cfun))\"\n@@ -11420,13 +11314,13 @@\n \t(if_then_else\n \t  (match_operator:CCFP 0 \"ix86_swapped_fp_comparison_operator\"\n \t    [(match_operator:X87MODEF 1 \"float_operator\"\n-\t      [(match_operand:SWI24 2 \"nonimmediate_operand\" \"m,?r\")])\n-\t     (match_operand:X87MODEF 3 \"register_operand\" \"f,f\")])\n+\t      [(match_operand:SWI24 2 \"nonimmediate_operand\" \"m\")])\n+\t     (match_operand:X87MODEF 3 \"register_operand\" \"f\")])\n \t  (pc)\n \t  (label_ref (match_operand 4))))\n    (clobber (reg:CCFP FPSR_REG))\n    (clobber (reg:CCFP FLAGS_REG))\n-   (clobber (match_scratch:HI 5 \"=a,a\"))]\n+   (clobber (match_scratch:HI 5 \"=a\"))]\n   \"TARGET_80387 && !TARGET_CMOVE\n    && (TARGET_USE_<SWI24:MODE>MODE_FIOP\n        || optimize_function_for_size_p (cfun))\"\n@@ -11450,32 +11344,7 @@\n {\n   ix86_split_fp_branch (swap_condition (GET_CODE (operands[0])), operands[3],\n \t\t        gen_rtx_FLOAT (GET_MODE (operands[1]), operands[2]),\n-\t\t\toperands[4], operands[5], operands[6], NULL_RTX);\n-  DONE;\n-})\n-\n-;; %%% Kill this when reload knows how to do it.\n-(define_split\n-  [(set (pc)\n-\t(if_then_else\n-\t  (match_operator:CCFP 0 \"ix86_swapped_fp_comparison_operator\"\n-\t    [(match_operator:X87MODEF 1 \"float_operator\"\n-\t      [(match_operand:SWI24 2 \"register_operand\")])\n-\t     (match_operand:X87MODEF 3 \"register_operand\")])\n-\t  (match_operand 4)\n-\t  (match_operand 5)))\n-   (clobber (reg:CCFP FPSR_REG))\n-   (clobber (reg:CCFP FLAGS_REG))\n-   (clobber (match_scratch:HI 6))]\n-  \"TARGET_80387 && !TARGET_CMOVE\n-   && reload_completed\"\n-  [(const_int 0)]\n-{\n-  operands[7] = ix86_force_to_memory (GET_MODE (operands[2]), operands[2]);\n-\n-  ix86_split_fp_branch (swap_condition (GET_CODE (operands[0])), operands[3],\n-\t\t       \tgen_rtx_FLOAT (GET_MODE (operands[1]), operands[7]),\n-\t\t\toperands[4], operands[5], operands[6], operands[2]);\n+\t\t\toperands[4], operands[5], operands[6]);\n   DONE;\n })\n \f\n@@ -13423,15 +13292,16 @@\n \n ;; ??? Add SSE splitters for these!\n (define_insn \"*fop_<MODEF:mode>_2_i387\"\n-  [(set (match_operand:MODEF 0 \"register_operand\" \"=f,f\")\n+  [(set (match_operand:MODEF 0 \"register_operand\" \"=f\")\n \t(match_operator:MODEF 3 \"binary_fp_operator\"\n \t  [(float:MODEF\n-\t     (match_operand:SWI24 1 \"nonimmediate_operand\" \"m,?r\"))\n-\t   (match_operand:MODEF 2 \"register_operand\" \"0,0\")]))]\n+\t     (match_operand:SWI24 1 \"nonimmediate_operand\" \"m\"))\n+\t   (match_operand:MODEF 2 \"register_operand\" \"0\")]))]\n   \"TARGET_80387 && X87_ENABLE_FLOAT (<MODEF:MODE>mode, <SWI24:MODE>mode)\n    && !(SSE_FLOAT_MODE_P (<MODEF:MODE>mode) && TARGET_SSE_MATH)\n-   && (TARGET_USE_<SWI24:MODE>MODE_FIOP || optimize_function_for_size_p (cfun))\"\n-  \"* return which_alternative ? \\\"#\\\" : output_387_binary_op (insn, operands);\"\n+   && (TARGET_USE_<SWI24:MODE>MODE_FIOP\n+       || optimize_function_for_size_p (cfun))\"\n+  { return output_387_binary_op (insn, operands); }\n   [(set (attr \"type\")\n         (cond [(match_operand:MODEF 3 \"mult_operator\")\n                  (const_string \"fmul\")\n@@ -13443,15 +13313,16 @@\n    (set_attr \"mode\" \"<SWI24:MODE>\")])\n \n (define_insn \"*fop_<MODEF:mode>_3_i387\"\n-  [(set (match_operand:MODEF 0 \"register_operand\" \"=f,f\")\n+  [(set (match_operand:MODEF 0 \"register_operand\" \"=f\")\n \t(match_operator:MODEF 3 \"binary_fp_operator\"\n-\t  [(match_operand:MODEF 1 \"register_operand\" \"0,0\")\n+\t  [(match_operand:MODEF 1 \"register_operand\" \"0\")\n \t   (float:MODEF\n-\t     (match_operand:SWI24 2 \"nonimmediate_operand\" \"m,?r\"))]))]\n+\t     (match_operand:SWI24 2 \"nonimmediate_operand\" \"m\"))]))]\n   \"TARGET_80387 && X87_ENABLE_FLOAT (<MODEF:MODE>mode, <SWI24:MODE>mode)\n    && !(SSE_FLOAT_MODE_P (<MODEF:MODE>mode) && TARGET_SSE_MATH)\n-   && (TARGET_USE_<SWI24:MODE>MODE_FIOP || optimize_function_for_size_p (cfun))\"\n-  \"* return which_alternative ? \\\"#\\\" : output_387_binary_op (insn, operands);\"\n+   && (TARGET_USE_<SWI24:MODE>MODE_FIOP\n+       || optimize_function_for_size_p (cfun))\"\n+  { return output_387_binary_op (insn, operands); }\n   [(set (attr \"type\")\n         (cond [(match_operand:MODEF 3 \"mult_operator\")\n                  (const_string \"fmul\")\n@@ -13550,13 +13421,14 @@\n    (set_attr \"mode\" \"XF\")])\n \n (define_insn \"*fop_xf_2_i387\"\n-  [(set (match_operand:XF 0 \"register_operand\" \"=f,f\")\n+  [(set (match_operand:XF 0 \"register_operand\" \"=f\")\n \t(match_operator:XF 3 \"binary_fp_operator\"\n \t  [(float:XF\n-\t     (match_operand:SWI24 1 \"nonimmediate_operand\" \"m,?r\"))\n-\t   (match_operand:XF 2 \"register_operand\" \"0,0\")]))]\n-  \"TARGET_80387 && (TARGET_USE_<MODE>MODE_FIOP || optimize_function_for_size_p (cfun))\"\n-  \"* return which_alternative ? \\\"#\\\" : output_387_binary_op (insn, operands);\"\n+\t     (match_operand:SWI24 1 \"nonimmediate_operand\" \"m\"))\n+\t   (match_operand:XF 2 \"register_operand\" \"0\")]))]\n+  \"TARGET_80387\n+   && (TARGET_USE_<MODE>MODE_FIOP || optimize_function_for_size_p (cfun))\"\n+  { return output_387_binary_op (insn, operands); }\n   [(set (attr \"type\")\n         (cond [(match_operand:XF 3 \"mult_operator\")\n                  (const_string \"fmul\")\n@@ -13568,13 +13440,14 @@\n    (set_attr \"mode\" \"<MODE>\")])\n \n (define_insn \"*fop_xf_3_i387\"\n-  [(set (match_operand:XF 0 \"register_operand\" \"=f,f\")\n+  [(set (match_operand:XF 0 \"register_operand\" \"=f\")\n \t(match_operator:XF 3 \"binary_fp_operator\"\n-\t  [(match_operand:XF 1 \"register_operand\" \"0,0\")\n+\t  [(match_operand:XF 1 \"register_operand\" \"0\")\n \t   (float:XF\n-\t     (match_operand:SWI24 2 \"nonimmediate_operand\" \"m,?r\"))]))]\n-  \"TARGET_80387 && (TARGET_USE_<MODE>MODE_FIOP || optimize_function_for_size_p (cfun))\"\n-  \"* return which_alternative ? \\\"#\\\" : output_387_binary_op (insn, operands);\"\n+\t     (match_operand:SWI24 2 \"nonimmediate_operand\" \"m\"))]))]\n+  \"TARGET_80387\n+   && (TARGET_USE_<MODE>MODE_FIOP || optimize_function_for_size_p (cfun))\"\n+  { return output_387_binary_op (insn, operands); }\n   [(set (attr \"type\")\n         (cond [(match_operand:XF 3 \"mult_operator\")\n                  (const_string \"fmul\")\n@@ -13636,48 +13509,6 @@\n               ]\n               (const_string \"fop\")))\n    (set_attr \"mode\" \"<MODE>\")])\n-\n-(define_split\n-  [(set (match_operand 0 \"register_operand\")\n-\t(match_operator 3 \"binary_fp_operator\"\n-\t   [(float (match_operand:SWI24 1 \"register_operand\"))\n-\t    (match_operand 2 \"register_operand\")]))]\n-  \"reload_completed\n-   && X87_FLOAT_MODE_P (GET_MODE (operands[0]))\n-   && X87_ENABLE_FLOAT (GET_MODE (operands[0]), GET_MODE (operands[1]))\"\n-  [(const_int 0)]\n-{\n-  operands[4] = ix86_force_to_memory (GET_MODE (operands[1]), operands[1]);\n-  operands[4] = gen_rtx_FLOAT (GET_MODE (operands[0]), operands[4]);\n-  emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n-\t\t\t  gen_rtx_fmt_ee (GET_CODE (operands[3]),\n-\t\t\t\t\t  GET_MODE (operands[3]),\n-\t\t\t\t\t  operands[4],\n-\t\t\t\t\t  operands[2])));\n-  ix86_free_from_memory (GET_MODE (operands[1]));\n-  DONE;\n-})\n-\n-(define_split\n-  [(set (match_operand 0 \"register_operand\")\n-\t(match_operator 3 \"binary_fp_operator\"\n-\t   [(match_operand 1 \"register_operand\")\n-\t    (float (match_operand:SWI24 2 \"register_operand\"))]))]\n-  \"reload_completed\n-   && X87_FLOAT_MODE_P (GET_MODE (operands[0]))\n-   && X87_ENABLE_FLOAT (GET_MODE (operands[0]), GET_MODE (operands[2]))\"\n-  [(const_int 0)]\n-{\n-  operands[4] = ix86_force_to_memory (GET_MODE (operands[2]), operands[2]);\n-  operands[4] = gen_rtx_FLOAT (GET_MODE (operands[0]), operands[4]);\n-  emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n-\t\t\t  gen_rtx_fmt_ee (GET_CODE (operands[3]),\n-\t\t\t\t\t  GET_MODE (operands[3]),\n-\t\t\t\t\t  operands[1],\n-\t\t\t\t\t  operands[4])));\n-  ix86_free_from_memory (GET_MODE (operands[2]));\n-  DONE;\n-})\n \f\n ;; FPU special functions.\n \n@@ -14567,7 +14398,7 @@\n   [(set_attr \"type\" \"fpspc\")\n    (set_attr \"mode\" \"XF\")])\n \n-(define_insn \"*fscalexf4_i387\"\n+(define_insn \"fscalexf4_i387\"\n   [(set (match_operand:XF 0 \"register_operand\" \"=f\")\n \t(unspec:XF [(match_operand:XF 2 \"register_operand\" \"0\")\n \t\t    (match_operand:XF 3 \"register_operand\" \"1\")]\n@@ -14791,15 +14622,9 @@\n })\n \n (define_expand \"ldexpxf3\"\n-  [(set (match_dup 3)\n-\t(float:XF (match_operand:SI 2 \"register_operand\")))\n-   (parallel [(set (match_operand:XF 0 \" register_operand\")\n-\t\t   (unspec:XF [(match_operand:XF 1 \"register_operand\")\n-\t\t\t       (match_dup 3)]\n-\t\t\t      UNSPEC_FSCALE_FRACT))\n-\t      (set (match_dup 4)\n-\t\t   (unspec:XF [(match_dup 1) (match_dup 3)]\n-\t\t\t      UNSPEC_FSCALE_EXP))])]\n+  [(match_operand:XF 0 \"register_operand\")\n+   (match_operand:XF 1 \"register_operand\")\n+   (match_operand:SI 2 \"register_operand\")]\n   \"TARGET_USE_FANCY_MATH_387\n    && flag_unsafe_math_optimizations\"\n {\n@@ -14808,6 +14633,11 @@\n \n   operands[3] = gen_reg_rtx (XFmode);\n   operands[4] = gen_reg_rtx (XFmode);\n+\n+  emit_insn (gen_floatsixf2 (operands[3], operands[2]));\n+  emit_insn (gen_fscalexf4_i387 (operands[0], operands[4],\n+                                 operands[1], operands[3]));\n+  DONE;\n })\n \n (define_expand \"ldexp<mode>3\""}, {"sha": "d5f33a79cc280b2daf93531a0c6286e61b5f6ffe", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3386d77eb83f3043afcc46503356165bc5ddfdba/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3386d77eb83f3043afcc46503356165bc5ddfdba/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3386d77eb83f3043afcc46503356165bc5ddfdba", "patch": "@@ -1,3 +1,8 @@\n+2014-03-13  Richard Henderson  <rth@redhat.com>\n+\n+\tPR debug/60438\n+\t* g++.dg/torture/pr60438-1.C, g++.dg/torture/pr60438-2.C: New.\n+\n 2014-03-13  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/60383"}, {"sha": "748295aabe048003549afdb321aef55a1a3cfd8e", "filename": "gcc/testsuite/g++.dg/torture/pr60438-1.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3386d77eb83f3043afcc46503356165bc5ddfdba/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr60438-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3386d77eb83f3043afcc46503356165bc5ddfdba/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr60438-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr60438-1.C?ref=3386d77eb83f3043afcc46503356165bc5ddfdba", "patch": "@@ -0,0 +1,26 @@\n+// { dg-do compile }\n+// { dg-options \"-fomit-frame-pointer\" }\n+\n+struct A { int a; };\n+struct B { A foo (); };\n+struct C { B *foo (); };\n+int foo (struct C *, float);\n+void bar (struct C *);\n+void baz (struct A *);\n+int a, b, c;\n+\n+int\n+foo (struct C *y, float x)\n+{\n+  struct A d;\n+  if (c)\n+    bar (y);\n+  else\n+    {\n+      C g;\n+      g.foo ()->foo ();\n+      a = b;\n+      d.a = (int) (b * x);\n+    }\n+  baz (&d);\n+}"}, {"sha": "b32576f67c528c80b27d211218d48ce4cc0a74ea", "filename": "gcc/testsuite/g++.dg/torture/pr60438-2.C", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3386d77eb83f3043afcc46503356165bc5ddfdba/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr60438-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3386d77eb83f3043afcc46503356165bc5ddfdba/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr60438-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr60438-2.C?ref=3386d77eb83f3043afcc46503356165bc5ddfdba", "patch": "@@ -0,0 +1,3 @@\n+// { dg-do compile }\n+// { dg-options \"-fomit-frame-pointer -fno-crossjumping\" }\n+#include \"pr60438-1.C\""}]}