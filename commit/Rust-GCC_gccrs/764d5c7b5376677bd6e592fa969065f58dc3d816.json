{"sha": "764d5c7b5376677bd6e592fa969065f58dc3d816", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzY0ZDVjN2I1Mzc2Njc3YmQ2ZTU5MmZhOTY5MDY1ZjU4ZGMzZDgxNg==", "commit": {"author": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2017-02-05T12:42:31Z"}, "committer": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2017-02-05T12:42:31Z"}, "message": "re PR fortran/78958 (Unallocated memory access after SOURCE-ALLOCATEing unlimited polymorphic object)\n\ngcc/fortran/ChangeLog:\n\n2017-02-05  Andre Vehreschild  <vehre@gcc.gnu.org>\n\n\tPR fortran/78958\n\t* trans-stmt.c (gfc_trans_allocate): Add the multiplying the _len\n\tcomponent of unlimited polymorphic objects when source-allocating.\n\nFrom-SVN: r245192", "tree": {"sha": "ed731d55c2fb0281f28245a8d9e7f4d23be3ab70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ed731d55c2fb0281f28245a8d9e7f4d23be3ab70"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/764d5c7b5376677bd6e592fa969065f58dc3d816", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/764d5c7b5376677bd6e592fa969065f58dc3d816", "html_url": "https://github.com/Rust-GCC/gccrs/commit/764d5c7b5376677bd6e592fa969065f58dc3d816", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/764d5c7b5376677bd6e592fa969065f58dc3d816/comments", "author": null, "committer": null, "parents": [{"sha": "4b9c80d8e4a1d14f6e517aac2267675910488510", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b9c80d8e4a1d14f6e517aac2267675910488510", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b9c80d8e4a1d14f6e517aac2267675910488510"}], "stats": {"total": 29, "additions": 21, "deletions": 8}, "files": [{"sha": "601017dbfdd48d7030af38829bbf542a47d5ce43", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/764d5c7b5376677bd6e592fa969065f58dc3d816/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/764d5c7b5376677bd6e592fa969065f58dc3d816/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=764d5c7b5376677bd6e592fa969065f58dc3d816", "patch": "@@ -1,3 +1,9 @@\n+2017-02-05  Andre Vehreschild  <vehre@gcc.gnu.org>\n+\n+\tPR fortran/78958\n+\t* trans-stmt.c (gfc_trans_allocate): Add the multiplying the _len\n+\tcomponent of unlimited polymorphic objects when source-allocating.\n+\n 2017-02-05  Andre Vehreschild  <vehre@gcc.gnu.org>\n \n \tPR fortran/79230"}, {"sha": "61e597f6a1f974f273f96f88325d16e0264f751b", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/764d5c7b5376677bd6e592fa969065f58dc3d816/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/764d5c7b5376677bd6e592fa969065f58dc3d816/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=764d5c7b5376677bd6e592fa969065f58dc3d816", "patch": "@@ -6009,14 +6009,21 @@ gfc_trans_allocate (gfc_code * code)\n \t needs to be provided, which is done most of the time by the\n \t pre-evaluation step.  */\n       nelems = NULL_TREE;\n-      if (expr3_len && code->expr3->ts.type == BT_CHARACTER)\n-\t/* When al is an array, then the element size for each element\n-\t   in the array is needed, which is the product of the len and\n-\t   esize for char arrays.  */\n-\ttmp = fold_build2_loc (input_location, MULT_EXPR,\n-\t\t\t       TREE_TYPE (expr3_esize), expr3_esize,\n-\t\t\t       fold_convert (TREE_TYPE (expr3_esize),\n-\t\t\t\t\t     expr3_len));\n+      if (expr3_len && (code->expr3->ts.type == BT_CHARACTER\n+\t\t\t|| code->expr3->ts.type == BT_CLASS))\n+\t{\n+\t  /* When al is an array, then the element size for each element\n+\t     in the array is needed, which is the product of the len and\n+\t     esize for char arrays.  For unlimited polymorphics len can be\n+\t     zero, therefore take the maximum of len and one.  */\n+\t  tmp = fold_build2_loc (input_location, MAX_EXPR,\n+\t\t\t\t TREE_TYPE (expr3_len),\n+\t\t\t\t expr3_len, fold_convert (TREE_TYPE (expr3_len),\n+\t\t\t\t\t\t\t  integer_one_node));\n+\t  tmp = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t TREE_TYPE (expr3_esize), expr3_esize,\n+\t\t\t\t fold_convert (TREE_TYPE (expr3_esize), tmp));\n+\t}\n       else\n \ttmp = expr3_esize;\n       if (!gfc_array_allocate (&se, expr, stat, errmsg, errlen,"}]}