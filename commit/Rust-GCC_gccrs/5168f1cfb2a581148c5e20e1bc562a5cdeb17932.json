{"sha": "5168f1cfb2a581148c5e20e1bc562a5cdeb17932", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTE2OGYxY2ZiMmE1ODExNDhjNWUyMGUxYmM1NjJhNWNkZWIxNzkzMg==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2003-03-02T00:02:52Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2003-03-02T00:02:52Z"}, "message": "natObject.cc: Don't include assert.h.\n\n\t* java/lang/natObject.cc: Don't include assert.h.\n\t(heavy_lock_obj_finalization_proc): Use JvAssert.\n\t(remove_all_heavy): Likewise.\n\t(_Jv_MonitorEnter): Likewise.\n\t(_Jv_MonitorExit): Likewise.\n\t(wait): Likewise.\n\nFrom-SVN: r63636", "tree": {"sha": "57fe79acd1240f3ba30275f6045ad27678cd180d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57fe79acd1240f3ba30275f6045ad27678cd180d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5168f1cfb2a581148c5e20e1bc562a5cdeb17932", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5168f1cfb2a581148c5e20e1bc562a5cdeb17932", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5168f1cfb2a581148c5e20e1bc562a5cdeb17932", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5168f1cfb2a581148c5e20e1bc562a5cdeb17932/comments", "author": null, "committer": null, "parents": [{"sha": "5bedfc9356014b29aa696f63421d3a3b000fc57c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bedfc9356014b29aa696f63421d3a3b000fc57c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5bedfc9356014b29aa696f63421d3a3b000fc57c"}], "stats": {"total": 58, "additions": 33, "deletions": 25}, "files": [{"sha": "5af34bf3018e55b56398c0de7ae7fbd9da2273ac", "filename": "libjava/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5168f1cfb2a581148c5e20e1bc562a5cdeb17932/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5168f1cfb2a581148c5e20e1bc562a5cdeb17932/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=5168f1cfb2a581148c5e20e1bc562a5cdeb17932", "patch": "@@ -1,3 +1,12 @@\n+2003-03-01  Tom Tromey  <tromey@redhat.com>\n+\n+\t* java/lang/natObject.cc: Don't include assert.h.\n+\t(heavy_lock_obj_finalization_proc): Use JvAssert.\n+\t(remove_all_heavy): Likewise.\n+\t(_Jv_MonitorEnter): Likewise.\n+\t(_Jv_MonitorExit): Likewise.\n+\t(wait): Likewise.\n+\n 2003-03-01  Ranjit Mathew  <rmathew@hotmail.com>\n \n \t* java/io/File (getAbsolutePath): Prefix drive specifier on"}, {"sha": "e9c74fdb285b893be25292d5a9cbacb77177b2fa", "filename": "libjava/java/lang/natObject.cc", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5168f1cfb2a581148c5e20e1bc562a5cdeb17932/libjava%2Fjava%2Flang%2FnatObject.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5168f1cfb2a581148c5e20e1bc562a5cdeb17932/libjava%2Fjava%2Flang%2FnatObject.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatObject.cc?ref=5168f1cfb2a581148c5e20e1bc562a5cdeb17932", "patch": "@@ -303,7 +303,6 @@ _Jv_MonitorExit (jobject obj)\n // that can atomically update only N bits at a time.\n // Author: Hans-J. Boehm  (Hans_Boehm@hp.com, boehm@acm.org)\n \n-#include <assert.h>\n #include <limits.h>\n #include <unistd.h>\t// for usleep, sysconf.\n #include <gcj/javaprims.h>\n@@ -605,7 +604,7 @@ heavy_lock_obj_finalization_proc (void *obj, void *cd)\n       release_set(&(he -> address), he_address);\n       return;\n     }\n-  assert(hl -> address == addr);\n+  JvAssert(hl -> address == addr);\n   GC_finalization_proc old_finalization_proc = hl -> old_finalization_proc;\n   if (old_finalization_proc != 0)\n     {\n@@ -653,8 +652,8 @@ heavy_lock_obj_finalization_proc (void *obj, void *cd)\n static void\n remove_all_heavy (hash_entry *he, obj_addr_t new_address_val)\n {\n-  assert(he -> heavy_count == 0);\n-  assert(he -> address & LOCKED);\n+  JvAssert(he -> heavy_count == 0);\n+  JvAssert(he -> address & LOCKED);\n   heavy_lock *hl = he -> heavy_locks;\n   he -> heavy_locks = 0;\n   // We would really like to release the lock bit here.  Unfortunately, that\n@@ -664,8 +663,8 @@ remove_all_heavy (hash_entry *he, obj_addr_t new_address_val)\n   for(; 0 != hl; hl = hl->next)\n     {\n       obj_addr_t obj = hl -> address;\n-      assert(0 != obj);\t// If this was previously finalized, it should no\n-      \t\t\t// longer appear on our list.\n+      JvAssert(0 != obj);  // If this was previously finalized, it should no\n+\t\t\t   // longer appear on our list.\n       hl -> address = 0; // Finalization proc might still see it after we\n       \t\t\t // finish.\n       GC_finalization_proc old_finalization_proc = hl -> old_finalization_proc;\n@@ -782,13 +781,13 @@ _Jv_MonitorEnter (jobject obj)\n   if (__builtin_expect(!addr, false))\n     throw new java::lang::NullPointerException;\n    \n-  assert(!(addr & FLAGS));\n+  JvAssert(!(addr & FLAGS));\n retry:\n   if (__builtin_expect(compare_and_swap(&(he -> address),\n \t\t\t\t\t0, addr),true))\n     {\n-      assert(he -> light_thr_id == INVALID_THREAD_ID);\n-      assert(he -> light_count == 0);\n+      JvAssert(he -> light_thr_id == INVALID_THREAD_ID);\n+      JvAssert(he -> light_count == 0);\n       he -> light_thr_id = self;\n       // Count fields are set correctly.  Heavy_count was also zero,\n       // but can change asynchronously.\n@@ -836,7 +835,7 @@ _Jv_MonitorEnter (jobject obj)\n \t  // only be held by other threads waiting for conversion, and\n \t  // they, like us, drop it quickly without blocking.\n \t  _Jv_MutexLock(&(hl->si.mutex));\n-\t  assert(he -> address == address | LOCKED );\n+\t  JvAssert(he -> address == address | LOCKED );\n \t  release_set(&(he -> address), (address | REQUEST_CONVERSION | HEAVY));\n \t\t\t\t// release lock on he\n \t  while ((he -> address & ~FLAGS) == (address & ~FLAGS))\n@@ -849,7 +848,7 @@ _Jv_MonitorEnter (jobject obj)\n \t\t// Guarantee that hl doesn't get unlinked by finalizer.\n \t\t// This is only an issue if the client fails to release\n \t\t// the lock, which is unlikely.\n-\t  assert(he -> address & HEAVY);\n+\t  JvAssert(he -> address & HEAVY);\n \t  // Lock has been converted, we hold the heavyweight lock,\n \t  // heavy_count has been incremented.\n \t  return;\n@@ -866,7 +865,7 @@ _Jv_MonitorEnter (jobject obj)\n     {\n       // Either was_heavy is true, or something changed out from under us,\n       // since the initial test for 0 failed.\n-      assert(!(address & REQUEST_CONVERSION));\n+      JvAssert(!(address & REQUEST_CONVERSION));\n \t// Can't convert a nonexistent lightweight lock.\n       heavy_lock *hl;\n       hl = (was_heavy? find_heavy(addr, he) : 0);\n@@ -879,15 +878,15 @@ _Jv_MonitorEnter (jobject obj)\n \t  // one first and use that.\n \t  he -> light_thr_id = self;  // OK, since nobody else can hold\n \t\t\t\t      // light lock or do this at the same time.\n-\t  assert(he -> light_count == 0);\n-\t  assert(was_heavy == (he -> address & HEAVY));\n+\t  JvAssert(he -> light_count == 0);\n+\t  JvAssert(was_heavy == (he -> address & HEAVY));\n \t  release_set(&(he -> address), (addr | was_heavy));\n         }\n       else\n \t{\n \t  // Must use heavy lock.\n \t  ++ (he -> heavy_count);\n-\t  assert(0 == (address & ~HEAVY));\n+\t  JvAssert(0 == (address & ~HEAVY));\n           release_set(&(he -> address), HEAVY);\n           _Jv_MutexLock(&(hl->si.mutex));\n \t  keep_live(addr);\n@@ -898,7 +897,7 @@ _Jv_MonitorEnter (jobject obj)\n   // We hold the lock on the hash entry, and he -> address can't\n   // change from under us.  Neither can the chain of heavy locks.\n     {\n-      assert(0 == he -> heavy_count || (address & HEAVY));\n+      JvAssert(0 == he -> heavy_count || (address & HEAVY));\n       heavy_lock *hl = get_heavy(addr, he);\n       ++ (he -> heavy_count);\n       release_set(&(he -> address), address | HEAVY);\n@@ -1006,17 +1005,17 @@ _Jv_MonitorExit (jobject obj)\n \t  he -> light_count = count - 1;\n \t  return;\n         }\n-      assert(he -> light_thr_id == self);\n-      assert(address & REQUEST_CONVERSION);\n+      JvAssert(he -> light_thr_id == self);\n+      JvAssert(address & REQUEST_CONVERSION);\n       // Conversion requested\n       // Convert now.\n       if (!compare_and_swap(&(he -> address), address, address | LOCKED))\n \tgoto retry;\n       heavy_lock *hl = find_heavy(addr, he);\n-      assert (0 != hl);\n+      JvAssert (0 != hl);\n \t\t// Requestor created it.\n       he -> light_count = 0;\n-      assert(he -> heavy_count > 0);\n+      JvAssert(he -> heavy_count > 0);\n \t  \t// was incremented by requestor.\n       _Jv_MutexLock(&(hl->si.mutex));\n \t// Release the he lock after acquiring the mutex.\n@@ -1033,8 +1032,8 @@ _Jv_MonitorExit (jobject obj)\n       return;\n     }\n   // lightweight lock not for this object.\n-  assert(!(address & LOCKED));\n-  assert((address & ~FLAGS) != addr);\n+  JvAssert(!(address & LOCKED));\n+  JvAssert((address & ~FLAGS) != addr);\n   if (!compare_and_swap(&(he -> address), address, address | LOCKED))\n \tgoto retry;\n   heavy_lock *hl = find_heavy(addr, he);\n@@ -1049,9 +1048,9 @@ _Jv_MonitorExit (jobject obj)\n       throw new java::lang::IllegalMonitorStateException(\n \t\t\tJvNewStringLatin1(\"current thread not owner\"));\n     }\n-  assert(address & HEAVY);\n+  JvAssert(address & HEAVY);\n   count = he -> heavy_count;\n-  assert(count > 0);\n+  JvAssert(count > 0);\n   --count;\n   he -> heavy_count = count;\n   if (0 == count)\n@@ -1160,7 +1159,7 @@ java::lang::Object::wait (jlong timeout, jint nanos)\n \t  throw new IllegalMonitorStateException (JvNewStringLatin1 \n                           (\"current thread not owner\"));\n \t}\n-      assert(address & HEAVY);\n+      JvAssert(address & HEAVY);\n     }\n   switch (_Jv_CondWait (&(hl->si.condition), &(hl->si.mutex), timeout, nanos))\n     {"}]}