{"sha": "7a3ea2011be31e937186df05335f665a8a983028", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2EzZWEyMDExYmUzMWU5MzcxODZkZjA1MzM1ZjY2NWE4YTk4MzAyOA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-06-01T15:12:23Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-06-01T15:12:23Z"}, "message": "c-parse.in (OFFSETOF, [...]): New.\n\n        * c-parse.in (OFFSETOF, offsetof_member_designator): New.\n        (primary): Handle offsetof.  Add error productions for faux functions.\n        Move component_ref objc checking to build_component_ref.\n        (reswords): Add offsetof.\n        (rid_to_yy): Add offsetof.\n        * c-tree.h (build_offsetof): Declare.\n        * c-common.h (objc_is_public): Declare.\n        * c-typeck.c (build_component_ref): Check objc_is_public.\n        (build_offsetof): New.\n        * stub-objc.c (objc_is_public): New.\n        * objc/objc-act.c, objc/objc-act.h (objc_is_public): Rename\n        from is_public.\n        * ginclude/stddef.h (offsetof): Use __builtin_offsetof.\n        * doc/extend.texi (Offsetof): Move from C++ section to C section\n        and rewrite for __builtin_offsetof.\ncp/\n        * lex.c (reswords): Rename \"__offsetof\" to \"__builtin_offsetof\".\n        * parser.c (struct cp_parser): Remove in_offsetof.\n        (cp_parser_new): Don't set it.\n        (cp_parser_unary_expression): Don't check it.\n        (cp_parser_postfix_open_square_expression): Split out from ...\n        (cp_parser_postfix_expression): ... here.\n        (cp_parser_postfix_dot_deref_expression): Likewise.\n        (cp_parser_builtin_offsetof): New.\n        (cp_parser_primary_expression): Use it.\ntestsuite/\n        * g++.dg/template/dependent-expr4.C: Use __builtin_offsetof.\n\nFrom-SVN: r82549", "tree": {"sha": "bfb9b2da79e35521eae05ac845e476d726baa281", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bfb9b2da79e35521eae05ac845e476d726baa281"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a3ea2011be31e937186df05335f665a8a983028", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a3ea2011be31e937186df05335f665a8a983028", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a3ea2011be31e937186df05335f665a8a983028", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a3ea2011be31e937186df05335f665a8a983028/comments", "author": null, "committer": null, "parents": [{"sha": "c4ec6988bc930288ea6c7fa2ec67a6cfbd0c0d73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4ec6988bc930288ea6c7fa2ec67a6cfbd0c0d73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4ec6988bc930288ea6c7fa2ec67a6cfbd0c0d73"}], "stats": {"total": 668, "additions": 429, "deletions": 239}, "files": [{"sha": "4ee2ec2ba7bca59ee1f9c160c9ec57d64c16d094", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a3ea2011be31e937186df05335f665a8a983028/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a3ea2011be31e937186df05335f665a8a983028/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7a3ea2011be31e937186df05335f665a8a983028", "patch": "@@ -1,3 +1,22 @@\n+2004-06-01  Richard Henderson  <rth@redhat.com>\n+\t    Andrew Pinski  <pinskia@physics.uc.edu>\n+\n+\t* c-parse.in (OFFSETOF, offsetof_member_designator): New.\n+\t(primary): Handle offsetof.  Add error productions for faux functions.\n+\tMove component_ref objc checking to build_component_ref.\n+\t(reswords): Add offsetof.\n+\t(rid_to_yy): Add offsetof.\n+\t* c-tree.h (build_offsetof): Declare.\n+\t* c-common.h (objc_is_public): Declare.\n+\t* c-typeck.c (build_component_ref): Check objc_is_public.\n+\t(build_offsetof): New.\n+\t* stub-objc.c (objc_is_public): New.\n+\t* objc/objc-act.c, objc/objc-act.h (objc_is_public): Rename\n+\tfrom is_public.\n+\t* ginclude/stddef.h (offsetof): Use __builtin_offsetof.\n+\t* doc/extend.texi (Offsetof): Move from C++ section to C section\n+\tand rewrite for __builtin_offsetof.\n+\n 2004-06-01  Peter Barada  <peter@the-baradas.com>\n             Peter Jakubek  <peter@laseranimation.com>\n "}, {"sha": "7394f109c1934219291d413c7f63fd44c0c6624f", "filename": "gcc/c-common.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a3ea2011be31e937186df05335f665a8a983028/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a3ea2011be31e937186df05335f665a8a983028/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=7a3ea2011be31e937186df05335f665a8a983028", "patch": "@@ -1236,6 +1236,7 @@ extern tree objc_message_selector (void);\n extern tree lookup_objc_ivar (tree);\n extern void *get_current_scope (void);\n extern void objc_mark_locals_volatile (void *);\n+extern int objc_is_public (tree, tree);\n \n /* In c-ppoutput.c  */\n extern void init_pp_output (FILE *);"}, {"sha": "9e776fa3e21a1f7d77901cd5783883cb80a049bc", "filename": "gcc/c-parse.in", "status": "modified", "additions": 34, "deletions": 20, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a3ea2011be31e937186df05335f665a8a983028/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a3ea2011be31e937186df05335f665a8a983028/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=7a3ea2011be31e937186df05335f665a8a983028", "patch": "@@ -146,7 +146,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n %token ATTRIBUTE EXTENSION LABEL\n %token REALPART IMAGPART VA_ARG CHOOSE_EXPR TYPES_COMPATIBLE_P\n %token PTR_VALUE PTR_BASE PTR_EXTENT\n-%token FUNC_NAME\n+%token FUNC_NAME OFFSETOF\n \n /* Add precedence rules to solve dangling else s/r conflict */\n %nonassoc IF\n@@ -199,6 +199,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n %type <ttype> maybe_type_quals_attrs typespec_nonattr typespec_attr\n %type <ttype> typespec_reserved_nonattr typespec_reserved_attr\n %type <ttype> typespec_nonreserved_nonattr\n+%type <ttype> offsetof_member_designator\n \n %type <ttype> scspec SCSPEC STATIC TYPESPEC TYPE_QUAL maybe_volatile\n %type <ttype> initdecls notype_initdecls initdcl notype_initdcl init\n@@ -674,17 +675,25 @@ primary:\n \t| VA_ARG '(' expr_no_commas ',' typename ')'\n \t\t{ $$ = build_va_arg ($3, groktypename ($5)); }\n \n-      | CHOOSE_EXPR '(' expr_no_commas ',' expr_no_commas ',' expr_no_commas ')'\n+\t| OFFSETOF '(' typename ',' offsetof_member_designator ')'\n+\t\t{ $$ = build_offsetof (groktypename ($3), $5); }\n+\t| OFFSETOF '(' error ')'\n+\t\t{ $$ = error_mark_node; }\n+\t| CHOOSE_EXPR '(' expr_no_commas ',' expr_no_commas ','\n+\t\t\t  expr_no_commas ')'\n \t\t{\n                   tree c;\n \n                   c = fold ($3);\n                   STRIP_NOPS (c);\n                   if (TREE_CODE (c) != INTEGER_CST)\n-                    error (\"first argument to __builtin_choose_expr not a constant\");\n+                    error (\"first argument to __builtin_choose_expr not\"\n+\t\t\t   \" a constant\");\n                   $$ = integer_zerop (c) ? $7 : $5;\n \t\t}\n-      | TYPES_COMPATIBLE_P '(' typename ',' typename ')'\n+\t| CHOOSE_EXPR '(' error ')'\n+\t\t{ $$ = error_mark_node; }\n+\t| TYPES_COMPATIBLE_P '(' typename ',' typename ')'\n \t\t{\n \t\t  tree e1, e2;\n \n@@ -694,27 +703,16 @@ primary:\n \t\t  $$ = comptypes (e1, e2, COMPARE_STRICT)\n \t\t    ? build_int_2 (1, 0) : build_int_2 (0, 0);\n \t\t}\n+\t| TYPES_COMPATIBLE_P '(' error ')'\n+\t\t{ $$ = error_mark_node; }\n \t| primary '[' expr ']'   %prec '.'\n \t\t{ $$ = build_array_ref ($1, $3); }\n \t| primary '.' identifier\n-\t\t{\n-@@ifobjc\n-\t\t    if (!is_public ($1, $3))\n-\t\t      $$ = error_mark_node;\n-\t\t    else\n-@@end_ifobjc\n-\t\t      $$ = build_component_ref ($1, $3);\n-\t\t}\n+\t\t{ $$ = build_component_ref ($1, $3); }\n \t| primary POINTSAT identifier\n \t\t{\n                   tree expr = build_indirect_ref ($1, \"->\");\n-\n-@@ifobjc\n-\t\t      if (!is_public (expr, $3))\n-\t\t\t$$ = error_mark_node;\n-\t\t      else\n-@@end_ifobjc\n-\t\t\t$$ = build_component_ref (expr, $3);\n+\t\t  $$ = build_component_ref (expr, $3);\n \t\t}\n \t| primary PLUSPLUS\n \t\t{ $$ = build_unary_op (POSTINCREMENT_EXPR, $1, 0); }\n@@ -734,6 +732,21 @@ primary:\n @@end_ifobjc\n \t;\n \n+/* This is the second argument to __builtin_offsetof.  We must have one\n+   identifier, and beyond that we want to accept sub structure and sub\n+   array references.  We return tree list where each element has\n+   PURPOSE set for component refs or VALUE set for array refs.  We'll\n+   turn this into something real inside build_offsetof.  */\n+\n+offsetof_member_designator:\n+\t  identifier\n+\t\t{ $$ = tree_cons ($1, NULL_TREE, NULL_TREE); }\n+\t| offsetof_member_designator '.' identifier\n+\t\t{ $$ = tree_cons ($3, NULL_TREE, $1); }\n+\t| offsetof_member_designator '[' expr ']'\n+\t\t{ $$ = tree_cons (NULL_TREE, $3, $1); }\n+\t;\n+\n old_style_parm_decls:\n \t/* empty */\n \t| datadecls\n@@ -3273,6 +3286,7 @@ static const struct resword reswords[] =\n   { \"__attribute\",\tRID_ATTRIBUTE,\t0 },\n   { \"__attribute__\",\tRID_ATTRIBUTE,\t0 },\n   { \"__builtin_choose_expr\", RID_CHOOSE_EXPR, 0 },\n+  { \"__builtin_offsetof\", RID_OFFSETOF, 0 },\n   { \"__builtin_types_compatible_p\", RID_TYPES_COMPATIBLE_P, 0 },\n   { \"__builtin_va_arg\",\tRID_VA_ARG,\t0 },\n   { \"__complex\",\tRID_COMPLEX,\t0 },\n@@ -3469,7 +3483,7 @@ static const short rid_to_yy[RID_MAX] =\n   /* RID_FALSE */\t0,\n   /* RID_NAMESPACE */\t0,\n   /* RID_NEW */\t\t0,\n-  /* RID_OFFSETOF */    0,\n+  /* RID_OFFSETOF */    OFFSETOF,\n   /* RID_OPERATOR */\t0,\n   /* RID_THIS */\t0,\n   /* RID_THROW */\t0,"}, {"sha": "9e21b4fc9471e998e063b0e9e6199a3b9b1967f4", "filename": "gcc/c-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a3ea2011be31e937186df05335f665a8a983028/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a3ea2011be31e937186df05335f665a8a983028/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=7a3ea2011be31e937186df05335f665a8a983028", "patch": "@@ -258,6 +258,7 @@ extern tree build_asm_expr (tree, tree, tree, tree, bool);\n extern tree build_asm_stmt (tree, tree);\n extern tree c_convert_parm_for_inlining (tree, tree, tree, int);\n extern int c_types_compatible_p (tree, tree);\n+extern tree build_offsetof (tree, tree);\n \n /* Set to 0 at beginning of a function definition, set to 1 if\n    a return statement that specifies a return value is seen.  */"}, {"sha": "bf480942b15f8831055c58d5cfa3d2ed733fc112", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a3ea2011be31e937186df05335f665a8a983028/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a3ea2011be31e937186df05335f665a8a983028/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=7a3ea2011be31e937186df05335f665a8a983028", "patch": "@@ -1347,6 +1347,9 @@ build_component_ref (tree datum, tree component)\n   tree field = NULL;\n   tree ref;\n \n+  if (!objc_is_public (datum, component))\n+    return error_mark_node;\n+\n   /* If DATUM is a COMPOUND_EXPR, move our reference inside it.\n      Ensure that the arguments are not lvalues; otherwise,\n      if the component is an array, it would wrongly decay to a pointer in\n@@ -7114,3 +7117,30 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n   }\n }\n \n+/* Build the result of __builtin_offsetof.  TYPE is the first argument to\n+   offsetof, i.e. a type.  LIST is a tree_list that encodes component and\n+   array references; PURPOSE is set for the former and VALUE is set for\n+   the later.  */\n+\n+tree\n+build_offsetof (tree type, tree list)\n+{\n+  tree t;\n+\n+  /* Build \"*(type *)0\".  */\n+  t = convert (build_pointer_type (type), null_pointer_node);\n+  t = build_indirect_ref (t, \"\");\n+\n+  /* Build COMPONENT and ARRAY_REF expressions as needed.  */\n+  for (list = nreverse (list); list ; list = TREE_CHAIN (list))\n+    if (TREE_PURPOSE (list))\n+      t = build_component_ref (t, TREE_PURPOSE (list));\n+    else\n+      t = build_array_ref (t, TREE_VALUE (list));\n+\n+  /* Finalize the offsetof expression.  For now all we need to do is take\n+     the address of the expression we created, and cast that to an integer\n+     type; this mirrors the traditional macro implementation of offsetof.  */\n+  t = build_unary_op (ADDR_EXPR, t, 0);\n+  return convert (size_type_node, t);\n+}"}, {"sha": "7229ffc37ac023d825b1db75ed07522b8e964235", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a3ea2011be31e937186df05335f665a8a983028/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a3ea2011be31e937186df05335f665a8a983028/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7a3ea2011be31e937186df05335f665a8a983028", "patch": "@@ -1,3 +1,16 @@\n+2004-06-01  Richard Henderson  <rth@redhat.com>\n+\t    Andrew Pinski  <pinskia@physics.uc.edu>\n+\n+\t* lex.c (reswords): Rename \"__offsetof\" to \"__builtin_offsetof\".\n+\t* parser.c (struct cp_parser): Remove in_offsetof.\n+\t(cp_parser_new): Don't set it.\n+\t(cp_parser_unary_expression): Don't check it.\n+\t(cp_parser_postfix_open_square_expression): Split out from ...\n+\t(cp_parser_postfix_expression): ... here.\n+\t(cp_parser_postfix_dot_deref_expression): Likewise.\n+\t(cp_parser_builtin_offsetof): New.\n+\t(cp_parser_primary_expression): Use it.\n+\n 2004-06-01  Giovanni Bajo  <giovannibajo@gcc.gnu.org>\n \n \tPR c++/14932"}, {"sha": "d10fa2e37585698ed2814d6fd7370a5c8943af0d", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a3ea2011be31e937186df05335f665a8a983028/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a3ea2011be31e937186df05335f665a8a983028/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=7a3ea2011be31e937186df05335f665a8a983028", "patch": "@@ -253,6 +253,7 @@ static const struct resword reswords[] =\n   { \"__asm__\",\t\tRID_ASM,\t0 },\n   { \"__attribute\",\tRID_ATTRIBUTE,\t0 },\n   { \"__attribute__\",\tRID_ATTRIBUTE,\t0 },\n+  { \"__builtin_offsetof\", RID_OFFSETOF, 0 },\n   { \"__builtin_va_arg\",\tRID_VA_ARG,\t0 },\n   { \"__complex\",\tRID_COMPLEX,\t0 },\n   { \"__complex__\",\tRID_COMPLEX,\t0 },\n@@ -266,8 +267,6 @@ static const struct resword reswords[] =\n   { \"__inline__\",\tRID_INLINE,\t0 },\n   { \"__label__\",\tRID_LABEL,\t0 },\n   { \"__null\",\t\tRID_NULL,\t0 },\n-  { \"__offsetof\",       RID_OFFSETOF,   0 },\n-  { \"__offsetof__\",     RID_OFFSETOF,   0 },\n   { \"__real\",\t\tRID_REALPART,\t0 },\n   { \"__real__\",\t\tRID_REALPART,\t0 },\n   { \"__restrict\",\tRID_RESTRICT,\t0 },"}, {"sha": "d7253f0a74b9b7a84d722002065d1dd2138529f4", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 284, "deletions": 182, "changes": 466, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a3ea2011be31e937186df05335f665a8a983028/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a3ea2011be31e937186df05335f665a8a983028/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=7a3ea2011be31e937186df05335f665a8a983028", "patch": "@@ -1232,9 +1232,6 @@ typedef struct cp_parser GTY(())\n      been seen that makes the expression non-constant.  */\n   bool non_integral_constant_expression_p;\n \n-  /* TRUE if we are parsing the argument to \"__offsetof__\".  */\n-  bool in_offsetof_p;\n-\n   /* TRUE if local variable names and `this' are forbidden in the\n      current context.  */\n   bool local_variables_forbidden_p;\n@@ -1342,6 +1339,10 @@ static tree cp_parser_class_or_namespace_name\n   (cp_parser *, bool, bool, bool, bool, bool);\n static tree cp_parser_postfix_expression\n   (cp_parser *, bool);\n+static tree cp_parser_postfix_open_square_expression\n+  (cp_parser *, tree, bool);\n+static tree cp_parser_postfix_dot_deref_expression\n+  (cp_parser *, enum cpp_ttype, tree, bool, cp_id_kind *);\n static tree cp_parser_parenthesized_expression_list\n   (cp_parser *, bool, bool *);\n static void cp_parser_pseudo_destructor_name\n@@ -1398,6 +1399,8 @@ static tree cp_parser_expression\n   (cp_parser *);\n static tree cp_parser_constant_expression\n   (cp_parser *, bool, bool *);\n+static tree cp_parser_builtin_offsetof\n+  (cp_parser *);\n \n /* Statements [gram.stmt.stmt]  */\n \n@@ -2324,9 +2327,6 @@ cp_parser_new (void)\n   parser->allow_non_integral_constant_expression_p = false;\n   parser->non_integral_constant_expression_p = false;\n \n-  /* We are not parsing offsetof.  */\n-  parser->in_offsetof_p = false;\n-\n   /* Local variable names are not forbidden.  */\n   parser->local_variables_forbidden_p = false;\n \n@@ -2603,27 +2603,7 @@ cp_parser_primary_expression (cp_parser *parser,\n \t  }\n \n \tcase RID_OFFSETOF:\n-\t  {\n-\t    tree expression;\n-\t    bool saved_in_offsetof_p;\n-\n-\t    /* Consume the \"__offsetof__\" token.  */\n-\t    cp_lexer_consume_token (parser->lexer);\n-\t    /* Consume the opening `('.  */\n-\t    cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\");\n-\t    /* Parse the parenthesized (almost) constant-expression.  */\n-\t    saved_in_offsetof_p = parser->in_offsetof_p;\n-\t    parser->in_offsetof_p = true;\n-\t    expression\n-\t      = cp_parser_constant_expression (parser,\n-\t\t\t\t\t       /*allow_non_constant_p=*/false,\n-\t\t\t\t\t       /*non_constant_p=*/NULL);\n-\t    parser->in_offsetof_p = saved_in_offsetof_p;\n-\t    /* Consume the closing ')'.  */\n-\t    cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n-\n-\t    return expression;\n-\t  }\n+\t  return cp_parser_builtin_offsetof (parser);\n \n \tdefault:\n \t  cp_parser_error (parser, \"expected primary-expression\");\n@@ -3520,9 +3500,6 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \tif (parser->integral_constant_expression_p\n \t    && !dependent_type_p (type)\n \t    && !INTEGRAL_OR_ENUMERATION_TYPE_P (type)\n-\t    /* A cast to pointer or reference type is allowed in the\n-\t       implementation of \"offsetof\".  */\n-\t    && !(parser->in_offsetof_p && POINTER_TYPE_P (type))\n \t    && (cp_parser_non_integral_constant_expression \n \t\t(parser,\n \t\t \"a cast to a type other than an integral or \"\n@@ -3765,29 +3742,11 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n       switch (token->type)\n \t{\n \tcase CPP_OPEN_SQUARE:\n-\t  /* postfix-expression [ expression ] */\n-\t  {\n-\t    tree index;\n-\n-\t    /* Consume the `[' token.  */\n-\t    cp_lexer_consume_token (parser->lexer);\n-\t    /* Parse the index expression.  */\n-\t    index = cp_parser_expression (parser);\n-\t    /* Look for the closing `]'.  */\n-\t    cp_parser_require (parser, CPP_CLOSE_SQUARE, \"`]'\");\n-\n-\t    /* Build the ARRAY_REF.  */\n-\t    postfix_expression\n-\t      = grok_array_decl (postfix_expression, index);\n-\t    idk = CP_ID_KIND_NONE;\n-\t    /* Array references are not permitted in\n-\t       constant-expressions (but they are allowed\n-\t       in offsetof).  */\n-\t    if (!parser->in_offsetof_p\n-\t\t&& cp_parser_non_integral_constant_expression\n-\t\t    (parser, \"an array reference\"))\n-\t      postfix_expression = error_mark_node;\n-\t  }\n+\t  postfix_expression\n+\t    = cp_parser_postfix_open_square_expression (parser,\n+\t\t\t\t\t\t\tpostfix_expression,\n+\t\t\t\t\t\t\tfalse);\n+\t  idk = CP_ID_KIND_NONE;\n \t  break;\n \n \tcase CPP_OPEN_PAREN:\n@@ -3891,132 +3850,14 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \t     postfix-expression . pseudo-destructor-name\n \t     postfix-expression -> template [opt] id-expression\n \t     postfix-expression -> pseudo-destructor-name */\n-\t  {\n-\t    tree name;\n-\t    bool dependent_p;\n-\t    bool template_p;\n-\t    tree scope = NULL_TREE;\n-\t    enum cpp_ttype token_type = token->type;\n-\n-\t    /* If this is a `->' operator, dereference the pointer.  */\n-\t    if (token->type == CPP_DEREF)\n-\t      postfix_expression = build_x_arrow (postfix_expression);\n-\t    /* Check to see whether or not the expression is\n-\t       type-dependent.  */\n-\t    dependent_p = type_dependent_expression_p (postfix_expression);\n-\t    /* The identifier following the `->' or `.' is not\n-\t       qualified.  */\n-\t    parser->scope = NULL_TREE;\n-\t    parser->qualifying_scope = NULL_TREE;\n-\t    parser->object_scope = NULL_TREE;\n-\t    idk = CP_ID_KIND_NONE;\n-\t    /* Enter the scope corresponding to the type of the object\n-\t       given by the POSTFIX_EXPRESSION.  */\n-\t    if (!dependent_p\n-\t\t&& TREE_TYPE (postfix_expression) != NULL_TREE)\n-\t      {\n-\t\tscope = TREE_TYPE (postfix_expression);\n-\t\t/* According to the standard, no expression should\n-\t\t   ever have reference type.  Unfortunately, we do not\n-\t\t   currently match the standard in this respect in\n-\t\t   that our internal representation of an expression\n-\t\t   may have reference type even when the standard says\n-\t\t   it does not.  Therefore, we have to manually obtain\n-\t\t   the underlying type here.  */\n-\t\tscope = non_reference (scope);\n-\t\t/* The type of the POSTFIX_EXPRESSION must be\n-\t\t   complete.  */\n-\t\tscope = complete_type_or_else (scope, NULL_TREE);\n-\t\t/* Let the name lookup machinery know that we are\n-\t\t   processing a class member access expression.  */\n-\t\tparser->context->object_type = scope;\n-\t\t/* If something went wrong, we want to be able to\n-\t\t   discern that case, as opposed to the case where\n-\t\t   there was no SCOPE due to the type of expression\n-\t\t   being dependent.  */\n-\t\tif (!scope)\n-\t\t  scope = error_mark_node;\n-\t\t/* If the SCOPE was erroneous, make the various\n-\t\t   semantic analysis functions exit quickly -- and\n-\t\t   without issuing additional error messages.  */\n-\t\tif (scope == error_mark_node)\n-\t\t  postfix_expression = error_mark_node;\n-\t      }\n-\n-\t    /* Consume the `.' or `->' operator.  */\n-\t    cp_lexer_consume_token (parser->lexer);\n-\t    /* If the SCOPE is not a scalar type, we are looking at an\n-\t       ordinary class member access expression, rather than a\n-\t       pseudo-destructor-name.  */\n-\t    if (!scope || !SCALAR_TYPE_P (scope))\n-\t      {\n-\t\ttemplate_p = cp_parser_optional_template_keyword (parser);\n-\t\t/* Parse the id-expression.  */\n-\t\tname = cp_parser_id_expression (parser,\n-\t\t\t\t\t\ttemplate_p,\n-\t\t\t\t\t\t/*check_dependency_p=*/true,\n-\t\t\t\t\t\t/*template_p=*/NULL,\n-\t\t\t\t\t\t/*declarator_p=*/false);\n-\t\t/* In general, build a SCOPE_REF if the member name is\n-\t\t   qualified.  However, if the name was not dependent\n-\t\t   and has already been resolved; there is no need to\n-\t\t   build the SCOPE_REF.  For example;\n-\n-                     struct X { void f(); };\n-                     template <typename T> void f(T* t) { t->X::f(); }\n-\n-                   Even though \"t\" is dependent, \"X::f\" is not and has\n-\t\t   been resolved to a BASELINK; there is no need to\n-\t\t   include scope information.  */\n-\n-\t\t/* But we do need to remember that there was an explicit\n-\t\t   scope for virtual function calls.  */\n-\t\tif (parser->scope)\n-\t\t  idk = CP_ID_KIND_QUALIFIED;\n-\n-\t\tif (name != error_mark_node\n-\t\t    && !BASELINK_P (name)\n-\t\t    && parser->scope)\n-\t\t  {\n-\t\t    name = build_nt (SCOPE_REF, parser->scope, name);\n-\t\t    parser->scope = NULL_TREE;\n-\t\t    parser->qualifying_scope = NULL_TREE;\n-\t\t    parser->object_scope = NULL_TREE;\n-\t\t  }\n-\t\tif (scope && name && BASELINK_P (name))\n-\t\t  adjust_result_of_qualified_name_lookup \n-\t\t    (name, BINFO_TYPE (BASELINK_BINFO (name)), scope);\n-\t\tpostfix_expression\n-\t\t  = finish_class_member_access_expr (postfix_expression, name);\n-\t      }\n-\t    /* Otherwise, try the pseudo-destructor-name production.  */\n-\t    else\n-\t      {\n-\t\ttree s = NULL_TREE;\n-\t\ttree type;\n-\n-\t\t/* Parse the pseudo-destructor-name.  */\n-\t\tcp_parser_pseudo_destructor_name (parser, &s, &type);\n-\t\t/* Form the call.  */\n-\t\tpostfix_expression\n-\t\t  = finish_pseudo_destructor_expr (postfix_expression,\n-\t\t\t\t\t\t   s, TREE_TYPE (type));\n-\t      }\n+\t\n+\t  /* Consume the `.' or `->' operator.  */\n+\t  cp_lexer_consume_token (parser->lexer);\n \n-\t    /* We no longer need to look up names in the scope of the\n-\t       object on the left-hand side of the `.' or `->'\n-\t       operator.  */\n-\t    parser->context->object_type = NULL_TREE;\n-\t    /* These operators may not appear in constant-expressions.  */\n-\t    if (/* The \"->\" operator is allowed in the implementation\n-\t\t   of \"offsetof\".  The \".\" operator may appear in the\n-\t\t   name of the member.  */\n-\t\t!parser->in_offsetof_p\n-\t\t&& (cp_parser_non_integral_constant_expression \n-\t\t    (parser,\n-\t\t     token_type == CPP_DEREF ? \"'->'\" : \"`.'\")))\n-\t      postfix_expression = error_mark_node;\n-\t  }\n+\t  postfix_expression\n+\t    = cp_parser_postfix_dot_deref_expression (parser, token->type,\n+\t\t\t\t\t\t      postfix_expression,\n+\t\t\t\t\t\t      false, &idk);\n \t  break;\n \n \tcase CPP_PLUS_PLUS:\n@@ -4059,6 +3900,183 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n   return error_mark_node;\n }\n \n+/* A subroutine of cp_parser_postfix_expression that also gets hijacked\n+   by cp_parser_builtin_offsetof.  We're looking for\n+\n+     postfix-expression [ expression ]\n+\n+   FOR_OFFSETOF is set if we're being called in that context, which\n+   changes how we deal with integer constant expressions.  */\n+\n+static tree\n+cp_parser_postfix_open_square_expression (cp_parser *parser,\n+\t\t\t\t\t  tree postfix_expression,\n+\t\t\t\t\t  bool for_offsetof)\n+{\n+  tree index;\n+\n+  /* Consume the `[' token.  */\n+  cp_lexer_consume_token (parser->lexer);\n+\n+  /* Parse the index expression.  */\n+  /* ??? For offsetof, there is a question of what to allow here.  If\n+     offsetof is not being used in an integral constant expression context,\n+     then we *could* get the right answer by computing the value at runtime.\n+     If we are in an integral constant expression context, then we might\n+     could accept any constant expression; hard to say without analysis.\n+     Rather than open the barn door too wide right away, allow only integer\n+     constant expresions here.  */\n+  if (for_offsetof)\n+    index = cp_parser_constant_expression (parser, false, NULL);\n+  else\n+    index = cp_parser_expression (parser);\n+\n+  /* Look for the closing `]'.  */\n+  cp_parser_require (parser, CPP_CLOSE_SQUARE, \"`]'\");\n+\n+  /* Build the ARRAY_REF.  */\n+  postfix_expression = grok_array_decl (postfix_expression, index);\n+\n+  /* When not doing offsetof, array references are not permitted in\n+     constant-expressions.  */\n+  if (!for_offsetof\n+      && (cp_parser_non_integral_constant_expression\n+\t  (parser, \"an array reference\")))\n+    postfix_expression = error_mark_node;\n+\n+  return postfix_expression;\n+}\n+\n+/* A subroutine of cp_parser_postfix_expression that also gets hijacked\n+   by cp_parser_builtin_offsetof.  We're looking for\n+\n+     postfix-expression . template [opt] id-expression\n+     postfix-expression . pseudo-destructor-name\n+     postfix-expression -> template [opt] id-expression\n+     postfix-expression -> pseudo-destructor-name\n+\n+   FOR_OFFSETOF is set if we're being called in that context.  That sorta\n+   limits what of the above we'll actually accept, but nevermind.\n+   TOKEN_TYPE is the \".\" or \"->\" token, which will already have been\n+   removed from the stream.  */\n+\n+static tree\n+cp_parser_postfix_dot_deref_expression (cp_parser *parser,\n+\t\t\t\t\tenum cpp_ttype token_type,\n+\t\t\t\t\ttree postfix_expression,\n+\t\t\t\t\tbool for_offsetof, cp_id_kind *idk)\n+{\n+  tree name;\n+  bool dependent_p;\n+  bool template_p;\n+  tree scope = NULL_TREE;\n+\n+  /* If this is a `->' operator, dereference the pointer.  */\n+  if (token_type == CPP_DEREF)\n+    postfix_expression = build_x_arrow (postfix_expression);\n+  /* Check to see whether or not the expression is type-dependent.  */\n+  dependent_p = type_dependent_expression_p (postfix_expression);\n+  /* The identifier following the `->' or `.' is not qualified.  */\n+  parser->scope = NULL_TREE;\n+  parser->qualifying_scope = NULL_TREE;\n+  parser->object_scope = NULL_TREE;\n+  *idk = CP_ID_KIND_NONE;\n+  /* Enter the scope corresponding to the type of the object\n+     given by the POSTFIX_EXPRESSION.  */\n+  if (!dependent_p && TREE_TYPE (postfix_expression) != NULL_TREE)\n+    {\n+      scope = TREE_TYPE (postfix_expression);\n+      /* According to the standard, no expression should ever have\n+\t reference type.  Unfortunately, we do not currently match\n+\t the standard in this respect in that our internal representation\n+\t of an expression may have reference type even when the standard\n+\t says it does not.  Therefore, we have to manually obtain the\n+\t underlying type here.  */\n+      scope = non_reference (scope);\n+      /* The type of the POSTFIX_EXPRESSION must be complete.  */\n+      scope = complete_type_or_else (scope, NULL_TREE);\n+      /* Let the name lookup machinery know that we are processing a\n+\t class member access expression.  */\n+      parser->context->object_type = scope;\n+      /* If something went wrong, we want to be able to discern that case,\n+\t as opposed to the case where there was no SCOPE due to the type\n+\t of expression being dependent.  */\n+      if (!scope)\n+\tscope = error_mark_node;\n+      /* If the SCOPE was erroneous, make the various semantic analysis\n+\t functions exit quickly -- and without issuing additional error\n+\t messages.  */\n+      if (scope == error_mark_node)\n+\tpostfix_expression = error_mark_node;\n+    }\n+\n+  /* If the SCOPE is not a scalar type, we are looking at an\n+     ordinary class member access expression, rather than a\n+     pseudo-destructor-name.  */\n+  if (!scope || !SCALAR_TYPE_P (scope))\n+    {\n+      template_p = cp_parser_optional_template_keyword (parser);\n+      /* Parse the id-expression.  */\n+      name = cp_parser_id_expression (parser, template_p,\n+\t\t\t\t      /*check_dependency_p=*/true,\n+\t\t\t\t      /*template_p=*/NULL,\n+\t\t\t\t      /*declarator_p=*/false);\n+      /* In general, build a SCOPE_REF if the member name is qualified.\n+\t However, if the name was not dependent and has already been\n+\t resolved; there is no need to build the SCOPE_REF.  For example;\n+\n+             struct X { void f(); };\n+             template <typename T> void f(T* t) { t->X::f(); }\n+\n+\t Even though \"t\" is dependent, \"X::f\" is not and has been resolved\n+\t to a BASELINK; there is no need to include scope information.  */\n+\n+      /* But we do need to remember that there was an explicit scope for\n+\t virtual function calls.  */\n+      if (parser->scope)\n+\t*idk = CP_ID_KIND_QUALIFIED;\n+\n+      if (name != error_mark_node && !BASELINK_P (name) && parser->scope)\n+\t{\n+\t  name = build_nt (SCOPE_REF, parser->scope, name);\n+\t  parser->scope = NULL_TREE;\n+\t  parser->qualifying_scope = NULL_TREE;\n+\t  parser->object_scope = NULL_TREE;\n+\t}\n+      if (scope && name && BASELINK_P (name))\n+\tadjust_result_of_qualified_name_lookup \n+\t  (name, BINFO_TYPE (BASELINK_BINFO (name)), scope);\n+      postfix_expression\n+\t= finish_class_member_access_expr (postfix_expression, name);\n+    }\n+  /* Otherwise, try the pseudo-destructor-name production.  */\n+  else\n+    {\n+      tree s = NULL_TREE;\n+      tree type;\n+\n+      /* Parse the pseudo-destructor-name.  */\n+      cp_parser_pseudo_destructor_name (parser, &s, &type);\n+      /* Form the call.  */\n+      postfix_expression\n+\t= finish_pseudo_destructor_expr (postfix_expression,\n+\t\t\t\t\t s, TREE_TYPE (type));\n+    }\n+\n+  /* We no longer need to look up names in the scope of the object on\n+     the left-hand side of the `.' or `->' operator.  */\n+  parser->context->object_type = NULL_TREE;\n+\n+  /* Outside of offsetof, these operators may not appear in\n+     constant-expressions.  */\n+  if (!for_offsetof\n+      && (cp_parser_non_integral_constant_expression \n+\t  (parser, token_type == CPP_DEREF ? \"'->'\" : \"`.'\")))\n+    postfix_expression = error_mark_node;\n+\n+  return postfix_expression;\n+}\n+\n /* Parse a parenthesized expression-list.\n \n    expression-list:\n@@ -4420,10 +4438,7 @@ cp_parser_unary_expression (cp_parser *parser, bool address_p)\n \t  break;\n \n \tcase ADDR_EXPR:\n-\t  /* The \"&\" operator is allowed in the implementation of\n-\t     \"offsetof\".  */\n-\t  if (!parser->in_offsetof_p)\n-\t    non_constant_p = \"`&'\";\n+\t  non_constant_p = \"`&'\";\n \t  /* Fall through.  */\n \tcase BIT_NOT_EXPR:\n \t  expression = build_x_unary_op (unary_operator, cast_expression);\n@@ -5457,6 +5472,93 @@ cp_parser_constant_expression (cp_parser* parser,\n   return expression;\n }\n \n+/* Parse __builtin_offsetof.\n+\n+   offsetof-expression:\n+     \"__builtin_offsetof\" \"(\" type-id \",\" offsetof-member-designator \")\"\n+\n+   offsetof-member-designator:\n+     id-expression\n+     | offsetof-member-designator \".\" id-expression\n+     | offsetof-member-designator \"[\" expression \"]\"\n+*/\n+\n+static tree\n+cp_parser_builtin_offsetof (cp_parser *parser)\n+{\n+  int save_ice_p, save_non_ice_p;\n+  tree type, expr;\n+  cp_id_kind dummy;\n+\n+  /* We're about to accept non-integral-constant things, but will\n+     definitely yield an integral constant expression.  Save and\n+     restore these values around our local parsing.  */\n+  save_ice_p = parser->integral_constant_expression_p;\n+  save_non_ice_p = parser->non_integral_constant_expression_p;\n+\n+  /* Consume the \"__builtin_offsetof\" token.  */\n+  cp_lexer_consume_token (parser->lexer);\n+  /* Consume the opening `('.  */\n+  cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\");\n+  /* Parse the type-id.  */\n+  type = cp_parser_type_id (parser);\n+  /* Look for the `,'.  */\n+  cp_parser_require (parser, CPP_COMMA, \"`,'\");\n+\n+  /* Build the (type *)null that begins the traditional offsetof macro.  */\n+  expr = build_static_cast (build_pointer_type (type), null_pointer_node);\n+\n+  /* Parse the offsetof-member-designator.  We begin as if we saw \"expr->\".  */\n+  expr = cp_parser_postfix_dot_deref_expression (parser, CPP_DEREF, expr,\n+\t\t\t\t\t\t true, &dummy);\n+  while (true)\n+    {\n+      cp_token *token = cp_lexer_peek_token (parser->lexer);\n+      switch (token->type)\n+\t{\n+\tcase CPP_OPEN_SQUARE:\n+\t  /* offsetof-member-designator \"[\" expression \"]\" */\n+\t  expr = cp_parser_postfix_open_square_expression (parser, expr, true);\n+\t  break;\n+\n+\tcase CPP_DOT:\n+\t  /* offsetof-member-designator \".\" identifier */\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  expr = cp_parser_postfix_dot_deref_expression (parser, CPP_DOT, expr,\n+\t\t\t\t\t\t\t true, &dummy);\n+\t  break;\n+\n+\tcase CPP_CLOSE_PAREN:\n+\t  /* Consume the \")\" token.  */\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  goto success;\n+\n+\tdefault:\n+\t  /* Error.  We know the following require will fail, but\n+\t     that gives the proper error message.  */\n+\t  cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n+\t  cp_parser_skip_to_closing_parenthesis (parser, true, false, true);\n+\t  expr = error_mark_node;\n+\t  goto failure;\n+\t}\n+    }\n+\n+ success:\n+  /* We've finished the parsing, now finish with the semantics.  At present\n+     we're just mirroring the traditional macro implementation.  Better\n+     would be to do the lowering of the ADDR_EXPR to flat pointer arithmetic\n+     here rather than in build_x_unary_op.  */\n+  expr = build_reinterpret_cast (build_reference_type (char_type_node), expr);\n+  expr = build_x_unary_op (ADDR_EXPR, expr);\n+  expr = build_reinterpret_cast (size_type_node, expr);\n+\n+ failure:\n+  parser->integral_constant_expression_p = save_ice_p;\n+  parser->non_integral_constant_expression_p = save_non_ice_p;\n+\n+  return expr;\n+}\n+\n /* Statements [gram.stmt.stmt]  */\n \n /* Parse a statement."}, {"sha": "204c64b100663e052288dbd69fbc70ed111bb992", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 28, "deletions": 20, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a3ea2011be31e937186df05335f665a8a983028/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a3ea2011be31e937186df05335f665a8a983028/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=7a3ea2011be31e937186df05335f665a8a983028", "patch": "@@ -469,6 +469,7 @@ extensions, accepted by GCC in C89 mode and in C++.\n \t\t\t function.\n * Return Address::      Getting the return or frame address of a function.\n * Vector Extensions::   Using vector instructions through built-in functions.\n+* Offsetof::            Special syntax for implementing @code{offsetof}.\n * Other Builtins::      Other built-in functions.\n * Target Builtins::     Built-in functions specific to particular targets.\n * Pragmas::             Pragmas accepted by GCC.\n@@ -4704,6 +4705,33 @@ v4si f (v4si a, v4si b, v4si c)\n \n @end smallexample\n \n+@node Offsetof\n+@section Offsetof\n+@findex __builtin_offsetof\n+\n+GCC implements for both C and C++ a syntactic extension to implement\n+the @code{offsetof} macro.\n+\n+@smallexample\n+primary:\n+\t\"__builtin_offsetof\" \"(\" @code{typename} \",\" offsetof_member_designator \")\"\n+\n+offsetof_member_designator:\n+\t  @code{identifier}\n+\t| offsetof_member_designator \".\" @code{identifier}\n+\t| offsetof_member_designator \"[\" @code{expr} \"]\"\n+@end smallexample\n+\n+This extension is sufficient such that\n+\n+@smallexample\n+#define offsetof(@var{type}, @var{member})  __builtin_offsetof (@var{type}, @var{member})\n+@end smallexample\n+\n+is a suitable definition of the @code{offsetof} macro.  In C++, @var{type}\n+may be dependent.  In either case, @var{member} may consist of a single\n+identifier, or a sequence of member accesses and array references.\n+\n @node Other Builtins\n @section Other built-in functions provided by GCC\n @cindex built-in functions\n@@ -7620,7 +7648,6 @@ Predefined Macros,cpp,The GNU C Preprocessor}).\n                         method denoted by a @samp{->*} or @samp{.*} expression.\n * C++ Attributes::      Variable, function, and type attributes for C++ only.\n * Strong Using::      Strong using-directives for namespace composition.\n-* Offsetof::            Special syntax for implementing @code{offsetof}.\n * Java Exceptions::     Tweaking exception handling to work with Java.\n * Deprecated Features:: Things will disappear from g++.\n * Backwards Compatibility:: Compatibilities with earlier definitions of C++.\n@@ -8265,25 +8292,6 @@ int main()\n @}\n @end smallexample\n \n-@node Offsetof\n-@section Offsetof\n-\n-G++ uses a syntactic extension to implement the @code{offsetof} macro.\n-\n-In particular:\n-\n-@smallexample\n-  __offsetof__ (expression)\n-@end smallexample\n-\n-is equivalent to the parenthesized expression, except that the\n-expression is considered an integral constant expression even if it\n-contains certain operators that are not normally permitted in an\n-integral constant expression.  Users should never use\n-@code{__offsetof__} directly; the only valid use of\n-@code{__offsetof__} is to implement the @code{offsetof} macro in\n-@code{<stddef.h>}.\n-\n @node Java Exceptions\n @section Java Exceptions\n "}, {"sha": "3b49aeb5180b7aa58e415648257beecf90703004", "filename": "gcc/ginclude/stddef.h", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a3ea2011be31e937186df05335f665a8a983028/gcc%2Fginclude%2Fstddef.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a3ea2011be31e937186df05335f665a8a983028/gcc%2Fginclude%2Fstddef.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fstddef.h?ref=7a3ea2011be31e937186df05335f665a8a983028", "patch": "@@ -1,4 +1,5 @@\n-/* Copyright (C) 1989, 1997, 1998, 1999, 2000, 2002 Free Software Foundation, Inc.\n+/* Copyright (C) 1989, 1997, 1998, 1999, 2000, 2002, 2004\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -410,16 +411,8 @@ typedef __WINT_TYPE__ wint_t;\n #ifdef _STDDEF_H\n \n /* Offset of member MEMBER in a struct of type TYPE. */\n-#ifndef __cplusplus\n-#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)\n-#else\n-/* The cast to \"char &\" below avoids problems with user-defined\n-   \"operator &\", which can appear in a POD type.  */\n-#define offsetof(TYPE, MEMBER)\t\t\t\t\\\n-  (__offsetof__ (reinterpret_cast <size_t>\t\t\\\n-                 (&reinterpret_cast <char &>\t\t\\\n-                  (static_cast<TYPE *> (0)->MEMBER))))\n-#endif /* C++ */\n+#define offsetof(TYPE, MEMBER) __builtin_offsetof (TYPE, MEMBER)\n+\n #endif /* _STDDEF_H was defined this time */\n \n #endif /* !_STDDEF_H && !_STDDEF_H_ && !_ANSI_STDDEF_H && !__STDDEF_H__"}, {"sha": "791f320a12acc8a8a9d458398a244571a7f9abda", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a3ea2011be31e937186df05335f665a8a983028/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a3ea2011be31e937186df05335f665a8a983028/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=7a3ea2011be31e937186df05335f665a8a983028", "patch": "@@ -6475,7 +6475,7 @@ is_private (tree decl)\n /* We have an instance variable reference;, check to see if it is public.  */\n \n int\n-is_public (tree expr, tree identifier)\n+objc_is_public (tree expr, tree identifier)\n {\n   tree basetype = TREE_TYPE (expr);\n   enum tree_code code = TREE_CODE (basetype);"}, {"sha": "5738bc9aedebee1712c8284aa548b8f5fb072dbd", "filename": "gcc/objc/objc-act.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a3ea2011be31e937186df05335f665a8a983028/gcc%2Fobjc%2Fobjc-act.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a3ea2011be31e937186df05335f665a8a983028/gcc%2Fobjc%2Fobjc-act.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.h?ref=7a3ea2011be31e937186df05335f665a8a983028", "patch": "@@ -52,7 +52,7 @@ tree objc_build_finally_epilogue (void);\n \n tree is_ivar (tree, tree);\n int is_private (tree);\n-int is_public (tree, tree);\n+int objc_is_public (tree, tree);\n tree add_instance_variable (tree, int, tree, tree, tree);\n tree objc_add_method (tree, tree, int);\n tree get_super_receiver (void);\n@@ -126,7 +126,7 @@ tree build_encode_expr (tree);\n \t ? (TYPE)->type.context : NULL_TREE)\n #define SET_TYPE_PROTOCOL_LIST(TYPE, P) (TYPE_CHECK (TYPE)->type.context = (P))\n \n-/* Set by `continue_class' and checked by `is_public'.  */\n+/* Set by `continue_class' and checked by `objc_is_public'.  */\n \n #define TREE_STATIC_TEMPLATE(record_type) (TREE_PUBLIC (record_type))\n #define TYPED_OBJECT(type) \\"}, {"sha": "9baa5c553cf6a5634e0d02f13c6698386e8e7266", "filename": "gcc/stub-objc.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a3ea2011be31e937186df05335f665a8a983028/gcc%2Fstub-objc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a3ea2011be31e937186df05335f665a8a983028/gcc%2Fstub-objc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstub-objc.c?ref=7a3ea2011be31e937186df05335f665a8a983028", "patch": "@@ -69,3 +69,8 @@ objc_message_selector (void)\n   return 0;\n }\n \n+int\n+objc_is_public (tree expr ATTRIBUTE_UNUSED, tree identifier ATTRIBUTE_UNUSED)\n+{\n+  return 1;\n+}"}, {"sha": "310b61d52527ee491088e95f422b51924e968b71", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a3ea2011be31e937186df05335f665a8a983028/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a3ea2011be31e937186df05335f665a8a983028/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7a3ea2011be31e937186df05335f665a8a983028", "patch": "@@ -1,3 +1,7 @@\n+2004-06-01  Richard Hederson  <rth@redhat.com>\n+\n+\t* g++.dg/template/dependent-expr4.C: Use __builtin_offsetof.\n+\n 2004-06-01  Giovanni Bajo  <giovannibajo@gcc.gnu.org>\n \n \tPR c++/14932"}, {"sha": "8e29654d8364112701dc5e86c8f181a3a691268c", "filename": "gcc/testsuite/g++.dg/template/dependent-expr4.C", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a3ea2011be31e937186df05335f665a8a983028/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdependent-expr4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a3ea2011be31e937186df05335f665a8a983028/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdependent-expr4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdependent-expr4.C?ref=7a3ea2011be31e937186df05335f665a8a983028", "patch": "@@ -1,6 +1,7 @@\n // { dg-do compile }\r\n // Origin: jbrandmeyer at users dot sourceforge dot net\r\n // PR c++/12573: COMPONENT_REFs must be inspected for dependness.\r\n+// Or, more specifically OFFSETOF.\r\n \r\n template <bool> struct S;\r\n \r\n@@ -9,6 +10,6 @@ template <typename K> struct Y {\n };\r\n \r\n template <class T> struct Z {\r\n-  S< (bool)(__offsetof__(&static_cast<Y<T>*>(0)->x) == 0) >\r\n+  S< (bool)(__builtin_offsetof (Y<T>*, x) == 0) >\r\n     s;\r\n };\r"}]}