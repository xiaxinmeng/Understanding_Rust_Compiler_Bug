{"sha": "49579c7e20da4cf0dc82bf1c8458bf4fc7a38007", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDk1NzljN2UyMGRhNGNmMGRjODJiZjFjODQ1OGJmNGZjN2EzODAwNw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2013-11-19T01:09:47Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-11-19T01:09:47Z"}, "message": "configure.ac: Check for support of __atomic extensions.\n\n\t* configure.ac: Check for support of __atomic extensions.\n\t* internal.h: Declare or #define atomic functions for use in\n\tbacktrace code.\n\t* atomic.c: New file.\n\t* dwarf.c (dwarf_lookup_pc): Use atomic functions.\n\t(dwarf_fileline, backtrace_dwarf_add): Likewise.\n\t* elf.c (elf_add_syminfo_data, elf_syminfo): Likewise.\n\t(backtrace_initialize): Likewise.\n\t* fileline.c (fileline_initialize): Likewise.\n\t* Makefile.am (libbacktrace_la_SOURCES): Add atomic.c.\n\t* configure, config.h.in, Makefile.in: Rebuild.\n\nFrom-SVN: r204994", "tree": {"sha": "a715cbe6fb809ff31f1487b709ea67a6f616cec5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a715cbe6fb809ff31f1487b709ea67a6f616cec5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/49579c7e20da4cf0dc82bf1c8458bf4fc7a38007", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49579c7e20da4cf0dc82bf1c8458bf4fc7a38007", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49579c7e20da4cf0dc82bf1c8458bf4fc7a38007", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49579c7e20da4cf0dc82bf1c8458bf4fc7a38007/comments", "author": null, "committer": null, "parents": [{"sha": "7f369373da8aa1cfe4aa172d29ae2180a2b31139", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f369373da8aa1cfe4aa172d29ae2180a2b31139", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f369373da8aa1cfe4aa172d29ae2180a2b31139"}], "stats": {"total": 342, "additions": 263, "deletions": 79}, "files": [{"sha": "134d9a71752c4d8e9dab0b8900ddfd74466d52a7", "filename": "libbacktrace/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49579c7e20da4cf0dc82bf1c8458bf4fc7a38007/libbacktrace%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49579c7e20da4cf0dc82bf1c8458bf4fc7a38007/libbacktrace%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2FChangeLog?ref=49579c7e20da4cf0dc82bf1c8458bf4fc7a38007", "patch": "@@ -1,3 +1,17 @@\n+2013-11-18  Ian Lance Taylor  <iant@google.com>\n+\n+\t* configure.ac: Check for support of __atomic extensions.\n+\t* internal.h: Declare or #define atomic functions for use in\n+\tbacktrace code.\n+\t* atomic.c: New file.\n+\t* dwarf.c (dwarf_lookup_pc): Use atomic functions.\n+\t(dwarf_fileline, backtrace_dwarf_add): Likewise.\n+\t* elf.c (elf_add_syminfo_data, elf_syminfo): Likewise.\n+\t(backtrace_initialize): Likewise.\n+\t* fileline.c (fileline_initialize): Likewise.\n+\t* Makefile.am (libbacktrace_la_SOURCES): Add atomic.c.\n+\t* configure, config.h.in, Makefile.in: Rebuild.\n+\n 2013-11-18  Jakub Jelinek  <jakub@redhat.com>\n \n \t* elf.c (SHN_UNDEF): Define."}, {"sha": "20dbde480c5d8f970eb844a852d31c6ecb8712f3", "filename": "libbacktrace/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49579c7e20da4cf0dc82bf1c8458bf4fc7a38007/libbacktrace%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49579c7e20da4cf0dc82bf1c8458bf4fc7a38007/libbacktrace%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2FMakefile.am?ref=49579c7e20da4cf0dc82bf1c8458bf4fc7a38007", "patch": "@@ -40,6 +40,7 @@ noinst_LTLIBRARIES = libbacktrace.la\n \n libbacktrace_la_SOURCES = \\\n \tbacktrace.h \\\n+\tatomic.c \\\n \tdwarf.c \\\n \tfileline.c \\\n \tinternal.h \\"}, {"sha": "a1e144aca172bd0d7da1963f0bc8de572c405ceb", "filename": "libbacktrace/Makefile.in", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49579c7e20da4cf0dc82bf1c8458bf4fc7a38007/libbacktrace%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49579c7e20da4cf0dc82bf1c8458bf4fc7a38007/libbacktrace%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2FMakefile.in?ref=49579c7e20da4cf0dc82bf1c8458bf4fc7a38007", "patch": "@@ -16,7 +16,7 @@\n @SET_MAKE@\n \n # Makefile.am -- Backtrace Makefile.\n-# Copyright (C) 2012 Free Software Foundation, Inc.\n+# Copyright (C) 2012-2013 Free Software Foundation, Inc.\n \n # Redistribution and use in source and binary forms, with or without\n # modification, are permitted provided that the following conditions are\n@@ -93,8 +93,8 @@ CONFIG_CLEAN_FILES = backtrace-supported.h\n CONFIG_CLEAN_VPATH_FILES =\n LTLIBRARIES = $(noinst_LTLIBRARIES)\n am__DEPENDENCIES_1 =\n-am_libbacktrace_la_OBJECTS = dwarf.lo fileline.lo posix.lo print.lo \\\n-\tstate.lo\n+am_libbacktrace_la_OBJECTS = atomic.lo dwarf.lo fileline.lo posix.lo \\\n+\tprint.lo state.lo\n libbacktrace_la_OBJECTS = $(am_libbacktrace_la_OBJECTS)\n @NATIVE_TRUE@am__EXEEXT_1 = btest$(EXEEXT)\n @NATIVE_TRUE@am_btest_OBJECTS = btest-btest.$(OBJEXT)\n@@ -258,6 +258,7 @@ AM_CFLAGS = $(EXTRA_FLAGS) $(WARN_FLAGS) $(PIC_FLAG)\n noinst_LTLIBRARIES = libbacktrace.la\n libbacktrace_la_SOURCES = \\\n \tbacktrace.h \\\n+\tatomic.c \\\n \tdwarf.c \\\n \tfileline.c \\\n \tinternal.h \\"}, {"sha": "44fa5521ad4d049a154d61db55df6c0f49bd7e70", "filename": "libbacktrace/atomic.c", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49579c7e20da4cf0dc82bf1c8458bf4fc7a38007/libbacktrace%2Fatomic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49579c7e20da4cf0dc82bf1c8458bf4fc7a38007/libbacktrace%2Fatomic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fatomic.c?ref=49579c7e20da4cf0dc82bf1c8458bf4fc7a38007", "patch": "@@ -0,0 +1,111 @@\n+/* atomic.c -- Support for atomic functions if not present.\n+   Copyright (C) 2013 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer. \n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.  \n+    \n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include \"backtrace.h\"\n+#include \"backtrace-supported.h\"\n+#include \"internal.h\"\n+\n+/* This file holds implementations of the atomic functions that are\n+   used if the host compiler has the sync functions but not the atomic\n+   functions, as is true of versions of GCC before 4.7.  */\n+\n+#if !defined (HAVE_ATOMIC_FUNCTIONS) && defined (HAVE_SYNC_FUNCTIONS)\n+\n+/* Do an atomic load of a pointer.  */\n+\n+void *\n+backtrace_atomic_load_pointer (void *arg)\n+{\n+  void **pp;\n+  void *p;\n+\n+  pp = (void **) arg;\n+  p = *pp;\n+  while (!__sync_bool_compare_and_swap (pp, p, p))\n+    p = *pp;\n+  return p;\n+}\n+\n+/* Do an atomic load of an int.  */\n+\n+int\n+backtrace_atomic_load_int (int *p)\n+{\n+  int i;\n+\n+  i = *p;\n+  while (!__sync_bool_compare_and_swap (p, i, i))\n+    i = *p;\n+  return i;\n+}\n+\n+/* Do an atomic store of a pointer.  */\n+\n+void\n+backtrace_atomic_store_pointer (void *arg, void *p)\n+{\n+  void **pp;\n+  void *old;\n+\n+  pp = (void **) arg;\n+  old = *pp;\n+  while (!__sync_bool_compare_and_swap (pp, old, p))\n+    old = *pp;\n+}\n+\n+/* Do an atomic store of a size_t value.  */\n+\n+void\n+backtrace_atomic_store_size_t (size_t *p, size_t v)\n+{\n+  size_t old;\n+\n+  old = *p;\n+  while (!__sync_bool_compare_and_swap (p, old, v))\n+    old = *p;\n+}\n+\n+/* Do an atomic store of a int value.  */\n+\n+void\n+backtrace_atomic_store_int (int *p, int v)\n+{\n+  size_t old;\n+\n+  old = *p;\n+  while (!__sync_bool_compare_and_swap (p, old, v))\n+    old = *p;\n+}\n+\n+#endif"}, {"sha": "87cb805984d4f06782ed96a509fe18a290377f33", "filename": "libbacktrace/config.h.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49579c7e20da4cf0dc82bf1c8458bf4fc7a38007/libbacktrace%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49579c7e20da4cf0dc82bf1c8458bf4fc7a38007/libbacktrace%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fconfig.h.in?ref=49579c7e20da4cf0dc82bf1c8458bf4fc7a38007", "patch": "@@ -3,6 +3,9 @@\n /* ELF size: 32 or 64 */\n #undef BACKTRACE_ELF_SIZE\n \n+/* Define to 1 if you have the __atomic functions */\n+#undef HAVE_ATOMIC_FUNCTIONS\n+\n /* Define to 1 if you have the declaration of `strnlen', and to 0 if you\n    don't. */\n #undef HAVE_DECL_STRNLEN"}, {"sha": "d6bda6e67b682382578877e596c832eeb4f2b9a1", "filename": "libbacktrace/configure", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49579c7e20da4cf0dc82bf1c8458bf4fc7a38007/libbacktrace%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49579c7e20da4cf0dc82bf1c8458bf4fc7a38007/libbacktrace%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fconfigure?ref=49579c7e20da4cf0dc82bf1c8458bf4fc7a38007", "patch": "@@ -11748,6 +11748,44 @@ $as_echo \"#define HAVE_SYNC_FUNCTIONS 1\" >>confdefs.h\n fi\n \n \n+# Test for __atomic support.\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking __atomic extensions\" >&5\n+$as_echo_n \"checking __atomic extensions... \" >&6; }\n+if test \"${libbacktrace_cv_sys_atomic+set}\" = set; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  if test -n \"${with_target_subdir}\"; then\n+   libbacktrace_cv_sys_atomic=yes\n+ else\n+   cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+int i;\n+int\n+main ()\n+{\n+__atomic_load_n (&i, __ATOMIC_ACQUIRE);\n+\t\t       __atomic_store_n (&i, 1, __ATOMIC_RELEASE);\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_c_try_link \"$LINENO\"; then :\n+  libbacktrace_cv_sys_atomic=yes\n+else\n+  libbacktrace_cv_sys_atomic=no\n+fi\n+rm -f core conftest.err conftest.$ac_objext \\\n+    conftest$ac_exeext conftest.$ac_ext\n+ fi\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $libbacktrace_cv_sys_atomic\" >&5\n+$as_echo \"$libbacktrace_cv_sys_atomic\" >&6; }\n+if test \"$libbacktrace_cv_sys_atomic\" = \"yes\"; then\n+\n+$as_echo \"#define HAVE_ATOMIC_FUNCTIONS 1\" >>confdefs.h\n+\n+fi\n+\n # The library needs to be able to read the executable itself.  Compile\n # a file to determine the executable format.  The awk script\n # filetype.awk prints out the file type."}, {"sha": "f97afbc8b746ee7146e1028a7c01b54a407fcd2f", "filename": "libbacktrace/configure.ac", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49579c7e20da4cf0dc82bf1c8458bf4fc7a38007/libbacktrace%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49579c7e20da4cf0dc82bf1c8458bf4fc7a38007/libbacktrace%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fconfigure.ac?ref=49579c7e20da4cf0dc82bf1c8458bf4fc7a38007", "patch": "@@ -194,6 +194,24 @@ if test \"$libbacktrace_cv_sys_sync\" = \"yes\"; then\n fi\n AC_SUBST(BACKTRACE_SUPPORTS_THREADS)\n \n+# Test for __atomic support.\n+AC_CACHE_CHECK([__atomic extensions],\n+[libbacktrace_cv_sys_atomic],\n+[if test -n \"${with_target_subdir}\"; then\n+   libbacktrace_cv_sys_atomic=yes\n+ else\n+   AC_LINK_IFELSE(\n+     [AC_LANG_PROGRAM([int i;],\n+     \t\t      [__atomic_load_n (&i, __ATOMIC_ACQUIRE);\n+\t\t       __atomic_store_n (&i, 1, __ATOMIC_RELEASE);])],\n+     [libbacktrace_cv_sys_atomic=yes],\n+     [libbacktrace_cv_sys_atomic=no])\n+ fi])\n+if test \"$libbacktrace_cv_sys_atomic\" = \"yes\"; then\n+  AC_DEFINE([HAVE_ATOMIC_FUNCTIONS], 1,\n+\t    [Define to 1 if you have the __atomic functions])\n+fi\n+\n # The library needs to be able to read the executable itself.  Compile\n # a file to determine the executable format.  The awk script\n # filetype.awk prints out the file type."}, {"sha": "0aba2d3f574c26f738f362949ec53adbe31f7f80", "filename": "libbacktrace/dwarf.c", "status": "modified", "additions": 9, "deletions": 27, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49579c7e20da4cf0dc82bf1c8458bf4fc7a38007/libbacktrace%2Fdwarf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49579c7e20da4cf0dc82bf1c8458bf4fc7a38007/libbacktrace%2Fdwarf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fdwarf.c?ref=49579c7e20da4cf0dc82bf1c8458bf4fc7a38007", "patch": "@@ -2643,12 +2643,7 @@ dwarf_lookup_pc (struct backtrace_state *state, struct dwarf_data *ddata,\n \t && pc < (entry - 1)->high)\n     {\n       if (state->threaded)\n-\t{\n-\t  /* Use __sync_bool_compare_and_swap to do a\n-\t     load-acquire.  */\n-\t  while (!__sync_bool_compare_and_swap (&u->lines, lines, lines))\n-\t    lines = u->lines;\n-\t}\n+\tlines = (struct line *) backtrace_atomic_load_pointer (&u->lines);\n \n       if (lines != (struct line *) (uintptr_t) -1)\n \tbreak;\n@@ -2659,13 +2654,8 @@ dwarf_lookup_pc (struct backtrace_state *state, struct dwarf_data *ddata,\n       lines = u->lines;\n     }\n \n-  /* Do a load-acquire of u->lines.  */\n   if (state->threaded)\n-    {\n-      /* Use __sync_bool_compare_and_swap to do an atomic load.  */\n-      while (!__sync_bool_compare_and_swap (&u->lines, lines, lines))\n-\tlines = u->lines;\n-    }\n+    lines = backtrace_atomic_load_pointer (&u->lines);\n \n   new_data = 0;\n   if (lines == NULL)\n@@ -2713,12 +2703,11 @@ dwarf_lookup_pc (struct backtrace_state *state, struct dwarf_data *ddata,\n \t}\n       else\n \t{\n-\t  __sync_bool_compare_and_swap (&u->lines_count, 0, count);\n-\t  __sync_bool_compare_and_swap (&u->function_addrs, NULL,\n-\t\t\t\t\tfunction_addrs);\n-\t  __sync_bool_compare_and_swap (&u->function_addrs_count, 0,\n-\t\t\t\t\tfunction_addrs_count);\n-\t  __sync_bool_compare_and_swap (&u->lines, NULL, lines);\n+\t  backtrace_atomic_store_size_t (&u->lines_count, count);\n+\t  backtrace_atomic_store_pointer (&u->function_addrs, function_addrs);\n+\t  backtrace_atomic_store_size_t (&u->function_addrs_count,\n+\t\t\t\t\t function_addrs_count);\n+\t  backtrace_atomic_store_pointer (&u->lines, lines);\n \t}\n     }\n \n@@ -2849,11 +2838,7 @@ dwarf_fileline (struct backtrace_state *state, uintptr_t pc,\n       pp = (struct dwarf_data **) (void *) &state->fileline_data;\n       while (1)\n \t{\n-\t  ddata = *pp;\n-\t  /* Atomic load.  */\n-\t  while (!__sync_bool_compare_and_swap (pp, ddata, ddata))\n-\t    ddata = *pp;\n-\n+\t  ddata = backtrace_atomic_load_pointer (pp);\n \t  if (ddata == NULL)\n \t    break;\n \n@@ -2985,10 +2970,7 @@ backtrace_dwarf_add (struct backtrace_state *state,\n \t    {\n \t      struct dwarf_data *p;\n \n-\t      /* Atomic load.  */\n-\t      p = *pp;\n-\t      while (!__sync_bool_compare_and_swap (pp, p, p))\n-\t\tp = *pp;\n+\t      p = backtrace_atomic_load_pointer (pp);\n \n \t      if (p == NULL)\n \t\tbreak;"}, {"sha": "981ce7f831c48e156f7fba1281351e273cb48b21", "filename": "libbacktrace/elf.c", "status": "modified", "additions": 10, "deletions": 21, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49579c7e20da4cf0dc82bf1c8458bf4fc7a38007/libbacktrace%2Felf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49579c7e20da4cf0dc82bf1c8458bf4fc7a38007/libbacktrace%2Felf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Felf.c?ref=49579c7e20da4cf0dc82bf1c8458bf4fc7a38007", "patch": "@@ -442,10 +442,7 @@ elf_add_syminfo_data (struct backtrace_state *state,\n \t    {\n \t      struct elf_syminfo_data *p;\n \n-\t      /* Atomic load.  */\n-\t      p = *pp;\n-\t      while (!__sync_bool_compare_and_swap (pp, p, p))\n-\t\tp = *pp;\n+\t      p = backtrace_atomic_load_pointer (pp);\n \n \t      if (p == NULL)\n \t\tbreak;\n@@ -490,11 +487,7 @@ elf_syminfo (struct backtrace_state *state, uintptr_t addr,\n       pp = (struct elf_syminfo_data **) (void *) &state->syminfo_data;\n       while (1)\n \t{\n-\t  edata = *pp;\n-\t  /* Atomic load.  */\n-\t  while (!__sync_bool_compare_and_swap (pp, edata, edata))\n-\t    edata = *pp;\n-\n+\t  edata = backtrace_atomic_load_pointer (pp);\n \t  if (edata == NULL)\n \t    break;\n \n@@ -902,7 +895,6 @@ backtrace_initialize (struct backtrace_state *state, int descriptor,\n {\n   int found_sym;\n   int found_dwarf;\n-  syminfo elf_syminfo_fn;\n   fileline elf_fileline_fn;\n   struct phdr_data pd;\n \n@@ -919,18 +911,19 @@ backtrace_initialize (struct backtrace_state *state, int descriptor,\n \n   dl_iterate_phdr (phdr_callback, (void *) &pd);\n \n-  elf_syminfo_fn = found_sym ? elf_syminfo : elf_nosyms;\n   if (!state->threaded)\n     {\n-      if (state->syminfo_fn == NULL || found_sym)\n-\tstate->syminfo_fn = elf_syminfo_fn;\n+      if (found_sym)\n+\tstate->syminfo_fn = elf_syminfo;\n+      else if (state->syminfo_fn == NULL)\n+\tstate->syminfo_fn = elf_nosyms;\n     }\n   else\n     {\n-      __sync_bool_compare_and_swap (&state->syminfo_fn, NULL, elf_syminfo_fn);\n       if (found_sym)\n-\t__sync_bool_compare_and_swap (&state->syminfo_fn, elf_nosyms,\n-\t\t\t\t      elf_syminfo_fn);\n+\tbacktrace_atomic_store_pointer (&state->syminfo_fn, elf_syminfo);\n+      else\n+\t__sync_bool_compare_and_swap (&state->syminfo_fn, NULL, elf_nosyms);\n     }\n \n   if (!state->threaded)\n@@ -942,11 +935,7 @@ backtrace_initialize (struct backtrace_state *state, int descriptor,\n     {\n       fileline current_fn;\n \n-      /* Atomic load.  */\n-      current_fn = state->fileline_fn;\n-      while (!__sync_bool_compare_and_swap (&state->fileline_fn, current_fn,\n-\t\t\t\t\t    current_fn))\n-\tcurrent_fn = state->fileline_fn;\n+      current_fn = backtrace_atomic_load_pointer (&state->fileline_fn);\n       if (current_fn == NULL || current_fn == elf_nodebug)\n \t*fileline_fn = elf_fileline_fn;\n     }"}, {"sha": "cc063f52c0d3d566cf0a3faa256c5b9fd6c86b99", "filename": "libbacktrace/fileline.c", "status": "modified", "additions": 13, "deletions": 27, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49579c7e20da4cf0dc82bf1c8458bf4fc7a38007/libbacktrace%2Ffileline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49579c7e20da4cf0dc82bf1c8458bf4fc7a38007/libbacktrace%2Ffileline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Ffileline.c?ref=49579c7e20da4cf0dc82bf1c8458bf4fc7a38007", "patch": "@@ -58,29 +58,21 @@ fileline_initialize (struct backtrace_state *state,\n   int called_error_callback;\n   int descriptor;\n \n-  failed = state->fileline_initialization_failed;\n-\n-  if (state->threaded)\n-    {\n-      /* Use __sync_bool_compare_and_swap to do an atomic load.  */\n-      while (!__sync_bool_compare_and_swap\n-\t     (&state->fileline_initialization_failed, failed, failed))\n-\tfailed = state->fileline_initialization_failed;\n-    }\n+  if (!state->threaded)\n+    failed = state->fileline_initialization_failed;\n+  else\n+    failed = backtrace_atomic_load_int (&state->fileline_initialization_failed);\n \n   if (failed)\n     {\n       error_callback (data, \"failed to read executable information\", -1);\n       return 0;\n     }\n \n-  fileline_fn = state->fileline_fn;\n-  if (state->threaded)\n-    {\n-      while (!__sync_bool_compare_and_swap (&state->fileline_fn, fileline_fn,\n-\t\t\t\t\t    fileline_fn))\n-\tfileline_fn = state->fileline_fn;\n-    }\n+  if (!state->threaded)\n+    fileline_fn = state->fileline_fn;\n+  else\n+    fileline_fn = backtrace_atomic_load_pointer (&state->fileline_fn);\n   if (fileline_fn != NULL)\n     return 1;\n \n@@ -151,24 +143,18 @@ fileline_initialize (struct backtrace_state *state,\n       if (!state->threaded)\n \tstate->fileline_initialization_failed = 1;\n       else\n-\t__sync_bool_compare_and_swap (&state->fileline_initialization_failed,\n-\t\t\t\t      0, failed);\n+\tbacktrace_atomic_store_int (&state->fileline_initialization_failed, 1);\n       return 0;\n     }\n \n   if (!state->threaded)\n     state->fileline_fn = fileline_fn;\n   else\n     {\n-      __sync_bool_compare_and_swap (&state->fileline_fn, NULL, fileline_fn);\n-\n-      /* At this point we know that state->fileline_fn is not NULL.\n-\t Either we stored our value, or some other thread stored its\n-\t value.  If some other thread stored its value, we leak the\n-\t one we just initialized.  Either way, state->fileline_fn is\n-\t initialized.  The compare_and_swap is a full memory barrier,\n-\t so we should have full access to that value even if it was\n-\t created by another thread.  */\n+      backtrace_atomic_store_pointer (&state->fileline_fn, fileline_fn);\n+\n+      /* Note that if two threads initialize at once, one of the data\n+\t sets may be leaked.  */\n     }\n \n   return 1;"}, {"sha": "c93e89f36f45587a6ab1984fbbfeb98c59e23a54", "filename": "libbacktrace/internal.h", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49579c7e20da4cf0dc82bf1c8458bf4fc7a38007/libbacktrace%2Finternal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49579c7e20da4cf0dc82bf1c8458bf4fc7a38007/libbacktrace%2Finternal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Finternal.h?ref=49579c7e20da4cf0dc82bf1c8458bf4fc7a38007", "patch": "@@ -65,7 +65,48 @@ POSSIBILITY OF SUCH DAMAGE.  */\n #define __sync_lock_test_and_set(A, B) (abort(), 0)\n #define __sync_lock_release(A) abort()\n \n-#endif /* !defined(HAVE_SYNC_FUNCTIONS) */\n+#endif /* !defined (HAVE_SYNC_FUNCTIONS) */\n+\n+#ifdef HAVE_ATOMIC_FUNCTIONS\n+\n+/* We have the atomic builtin functions.  */\n+\n+#define backtrace_atomic_load_pointer(p) \\\n+    __atomic_load_n ((p), __ATOMIC_ACQUIRE)\n+#define backtrace_atomic_load_int(p) \\\n+    __atomic_load_n ((p), __ATOMIC_ACQUIRE)\n+#define backtrace_atomic_store_pointer(p, v) \\\n+    __atomic_store_n ((p), (v), __ATOMIC_RELEASE)\n+#define backtrace_atomic_store_size_t(p, v) \\\n+    __atomic_store_n ((p), (v), __ATOMIC_RELEASE)\n+#define backtrace_atomic_store_int(p, v) \\\n+    __atomic_store_n ((p), (v), __ATOMIC_RELEASE)\n+\n+#else /* !defined (HAVE_ATOMIC_FUNCTIONS) */\n+#ifdef HAVE_SYNC_FUNCTIONS\n+\n+/* We have the sync functions but not the atomic functions.  Define\n+   the atomic ones in terms of the sync ones.  */\n+\n+extern void *backtrace_atomic_load_pointer (void *);\n+extern int backtrace_atomic_load_int (int *);\n+extern void backtrace_atomic_store_pointer (void *, void *);\n+extern void backtrace_atomic_store_size_t (size_t *, size_t);\n+extern void backtrace_atomic_store_int (int *, int);\n+\n+#else /* !defined (HAVE_SYNC_FUNCTIONS) */\n+\n+/* We have neither the sync nor the atomic functions.  These will\n+   never be called.  */\n+\n+#define backtrace_atomic_load_pointer(p) (abort(), 0)\n+#define backtrace_atomic_load_int(p) (abort(), 0)\n+#define backtrace_atomic_store_pointer(p, v) abort()\n+#define backtrace_atomic_store_size_t(p, v) abort()\n+#define backtrace_atomic_store_int(p, v) abort()\n+\n+#endif /* !defined (HAVE_SYNC_FUNCTIONS) */\n+#endif /* !defined (HAVE_ATOMIC_FUNCTIONS) */\n \n /* The type of the function that collects file/line information.  This\n    is like backtrace_pcinfo.  */"}]}