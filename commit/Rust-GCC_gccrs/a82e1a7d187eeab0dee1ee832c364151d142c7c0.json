{"sha": "a82e1a7d187eeab0dee1ee832c364151d142c7c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTgyZTFhN2QxODdlZWFiMGRlZTFlZTgzMmMzNjQxNTFkMTQyYzdjMA==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@integrable-solutions.net", "date": "2004-10-10T21:36:42Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2004-10-10T21:36:42Z"}, "message": "Convert diagnostics to use quoting flag q 7/n\n\ncp/\n        Convert diagnostics to use quoting flag q 7/n\n        * typeck.c (composite_pointer_type_r, composite_pointer_type,\n        cxx_sizeof_or_alignof_type, cxx_sizeof_or_alignof_expr,\n        string_conv_p, build_class_member_access_expr,\n        build_class_member_access_expr, lookup_destructor,\n        finish_class_member_access_expr, build_indirect_ref,\n        get_member_function_from_ptrfunc, build_function_call,\n        convert_arguments, build_binary_op, pointer_diff,\n        build_unary_op,\n        check_for_casting_away_constness, build_static_cast,\n        build_reinterpret_cast, build_const_cast, build_c_cast,\n        build_modify_expr, get_delta_difference, build_ptrmemfunc,\n        dubious_conversion_warnings, convert_for_assignment,\n        convert_for_initialization,\n        maybe_warn_about_returning_address_of_local,\n        check_return_expr):\n        Use quoting marks.\n\n        * typeck2.c (error_not_base_type, readonly_error,\n        abstract_virtuals_error, cxx_incomplete_type_diagnostic,\n        store_init_value, digest_init, build_x_arrow,\n        build_m_component_ref, require_complete_eh_spec_types):\n        Likewise.\n\n        * tree.c (cp_build_qualified_type_real,\n        handle_java_interface_attribute,\n        handle_init_priority_attribute):\n        Likewise.\n\n        * semantics.c (finish_asm_stmt, finish_non_static_data_member,\n        finish_pseudo_destructor_expr,\n        check_template_template_default_arg, begin_class_definition,\n        finish_base_specifier, qualified_name_lookup_error,\n        finish_id_expression, finish_typeof): Likewise.\n\n        * search.c (lookup_base, check_final_overrider,\n        look_for_overrides_r): Likewise.\n\n        * rtti.c (get_tinfo_decl, build_dynamic_cast_1): Likewise.\ntestsuite/\n        * g++.dg/overload/pmf1.C: Adjust quoting marks.\n        * g++.dg/warn/incomplete1.C: Likewise.\n        * g++.dg/template/qualttp20.C: Likewise.\n\nFrom-SVN: r88854", "tree": {"sha": "5cb21df501c05a366c39fc157980cf5347da3f71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5cb21df501c05a366c39fc157980cf5347da3f71"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a82e1a7d187eeab0dee1ee832c364151d142c7c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a82e1a7d187eeab0dee1ee832c364151d142c7c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a82e1a7d187eeab0dee1ee832c364151d142c7c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a82e1a7d187eeab0dee1ee832c364151d142c7c0/comments", "author": {"login": "cxx-undef", "id": 5528103, "node_id": "MDQ6VXNlcjU1MjgxMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/5528103?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cxx-undef", "html_url": "https://github.com/cxx-undef", "followers_url": "https://api.github.com/users/cxx-undef/followers", "following_url": "https://api.github.com/users/cxx-undef/following{/other_user}", "gists_url": "https://api.github.com/users/cxx-undef/gists{/gist_id}", "starred_url": "https://api.github.com/users/cxx-undef/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cxx-undef/subscriptions", "organizations_url": "https://api.github.com/users/cxx-undef/orgs", "repos_url": "https://api.github.com/users/cxx-undef/repos", "events_url": "https://api.github.com/users/cxx-undef/events{/privacy}", "received_events_url": "https://api.github.com/users/cxx-undef/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bba5733fee39b6ce6e73e8637fd2cde9c16ea399", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bba5733fee39b6ce6e73e8637fd2cde9c16ea399", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bba5733fee39b6ce6e73e8637fd2cde9c16ea399"}], "stats": {"total": 496, "additions": 277, "deletions": 219}, "files": [{"sha": "3d7d7409f68e725e1b8bb586c5cd3d2aed1830bb", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a82e1a7d187eeab0dee1ee832c364151d142c7c0/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a82e1a7d187eeab0dee1ee832c364151d142c7c0/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a82e1a7d187eeab0dee1ee832c364151d142c7c0", "patch": "@@ -1,3 +1,41 @@\n+2004-10-10  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\tConvert diagnostics to use quoting flag q 7/n\n+\t* typeck.c (composite_pointer_type_r, composite_pointer_type, \n+\tcxx_sizeof_or_alignof_type, cxx_sizeof_or_alignof_expr, \n+\tstring_conv_p, build_class_member_access_expr, \n+\tbuild_class_member_access_expr, lookup_destructor, \n+\tfinish_class_member_access_expr, build_indirect_ref, \n+\tget_member_function_from_ptrfunc, build_function_call, \n+\tconvert_arguments, build_binary_op, pointer_diff, build_unary_op, \n+\tcheck_for_casting_away_constness, build_static_cast, \n+\tbuild_reinterpret_cast, build_const_cast, build_c_cast, \n+\tbuild_modify_expr, get_delta_difference, build_ptrmemfunc, \n+\tdubious_conversion_warnings, convert_for_assignment, \n+\tconvert_for_initialization, \n+\tmaybe_warn_about_returning_address_of_local, check_return_expr): \n+\tUse quoting marks.\n+\n+\t* typeck2.c (error_not_base_type, readonly_error, \n+\tabstract_virtuals_error, cxx_incomplete_type_diagnostic, \n+\tstore_init_value, digest_init, build_x_arrow, \n+\tbuild_m_component_ref, require_complete_eh_spec_types): Likewise.\n+\n+\t* tree.c (cp_build_qualified_type_real, \n+\thandle_java_interface_attribute, handle_init_priority_attribute):\n+\tLikewise.\n+\n+\t* semantics.c (finish_asm_stmt, finish_non_static_data_member, \n+\tfinish_pseudo_destructor_expr, \n+\tcheck_template_template_default_arg, begin_class_definition, \n+\tfinish_base_specifier, qualified_name_lookup_error, \n+\tfinish_id_expression, finish_typeof): Likewise.\n+\n+\t* search.c (lookup_base, check_final_overrider,\n+\tlook_for_overrides_r): Likewise.\n+\n+\t* rtti.c (get_tinfo_decl, build_dynamic_cast_1): Likewise.\n+\n 2004-10-09  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/17867"}, {"sha": "c2d5d1813817dcee689bc6b9633c62d9dff334ef", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a82e1a7d187eeab0dee1ee832c364151d142c7c0/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a82e1a7d187eeab0dee1ee832c364151d142c7c0/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=a82e1a7d187eeab0dee1ee832c364151d142c7c0", "patch": "@@ -318,7 +318,8 @@ get_tinfo_decl (tree type)\n   if (COMPLETE_TYPE_P (type) \n       && TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n     {\n-      error (\"cannot create type information for type `%T' because its size is variable\", \n+      error (\"cannot create type information for type %qT because \"\n+             \"its size is variable\", \n \t     type);\n       return error_mark_node;\n     }\n@@ -570,8 +571,8 @@ build_dynamic_cast_1 (tree type, tree expr)\n \t\t  && TREE_CODE (TREE_TYPE (old_expr)) == RECORD_TYPE)\n \t\t{\n \t          tree expr = throw_bad_cast ();\n-\t\t  warning (\"dynamic_cast of `%#D' to `%#T' can never succeed\",\n-\t\t\t      old_expr, type);\n+\t\t  warning (\"dynamic_cast of %q#D to %q#T can never succeed\",\n+                           old_expr, type);\n \t          /* Bash it to the expected type.  */\n \t          TREE_TYPE (expr) = type;\n \t\t  return expr;\n@@ -584,8 +585,8 @@ build_dynamic_cast_1 (tree type, tree expr)\n \t      if (TREE_CODE (op) == VAR_DECL\n \t\t  && TREE_CODE (TREE_TYPE (op)) == RECORD_TYPE)\n \t\t{\n-\t\t  warning (\"dynamic_cast of `%#D' to `%#T' can never succeed\",\n-\t\t\t      op, type);\n+\t\t  warning (\"dynamic_cast of %q#D to %q#T can never succeed\",\n+                           op, type);\n \t\t  retval = build_int_cst (type, 0); \n \t\t  return retval;\n \t\t}\n@@ -663,8 +664,8 @@ build_dynamic_cast_1 (tree type, tree expr)\n     errstr = \"source type is not polymorphic\";\n \n  fail:\n-  error (\"cannot dynamic_cast `%E' (of type `%#T') to type `%#T' (%s)\",\n-\t    expr, exprtype, type, errstr);\n+  error (\"cannot dynamic_cast %qE (of type %q#T) to type %q#T (%s)\",\n+         expr, exprtype, type, errstr);\n   return error_mark_node;\n }\n "}, {"sha": "ad5dd9e4f3a401f2bac5bf3c0337f22c79c69503", "filename": "gcc/cp/search.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a82e1a7d187eeab0dee1ee832c364151d142c7c0/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a82e1a7d187eeab0dee1ee832c364151d142c7c0/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=a82e1a7d187eeab0dee1ee832c364151d142c7c0", "patch": "@@ -234,7 +234,7 @@ lookup_base (tree t, tree base, base_access access, base_kind *kind_ptr)\n \tbinfo = NULL_TREE;\n \tif (!(access & ba_quiet))\n \t  {\n-\t    error (\"`%T' is an ambiguous base of `%T'\", base, t);\n+\t    error (\"%qT is an ambiguous base of %qT\", base, t);\n \t    binfo = error_mark_node;\n \t  }\n \tbreak;\n@@ -252,7 +252,7 @@ lookup_base (tree t, tree base, base_access access, base_kind *kind_ptr)\n \t  {\n \t    if (!(access & ba_quiet))\n \t      {\n-\t\terror (\"`%T' is an inaccessible base of `%T'\", base, t);\n+\t\terror (\"%qT is an inaccessible base of %qT\", base, t);\n \t\tbinfo = error_mark_node;\n \t      }\n \t    else\n@@ -1740,14 +1740,14 @@ check_final_overrider (tree overrider, tree basefn)\n     {\n       if (fail == 1)\n \t{\n-\t  cp_error_at (\"invalid covariant return type for `%#D'\", overrider);\n-\t  cp_error_at (\"  overriding `%#D'\", basefn);\n+\t  cp_error_at (\"invalid covariant return type for %q#D\", overrider);\n+\t  cp_error_at (\"  overriding %q#D\", basefn);\n \t}\n       else\n \t{\n-\t  cp_error_at (\"conflicting return type specified for `%#D'\",\n+\t  cp_error_at (\"conflicting return type specified for %q#D\",\n \t\t       overrider);\n-\t  cp_error_at (\"  overriding `%#D'\", basefn);\n+\t  cp_error_at (\"  overriding %q#D\", basefn);\n \t}\n       DECL_INVALID_OVERRIDER_P (overrider) = 1;\n       return 0;\n@@ -1756,8 +1756,8 @@ check_final_overrider (tree overrider, tree basefn)\n   /* Check throw specifier is at least as strict.  */\n   if (!comp_except_specs (base_throw, over_throw, 0))\n     {\n-      cp_error_at (\"looser throw specifier for `%#F'\", overrider);\n-      cp_error_at (\"  overriding `%#F'\", basefn);\n+      cp_error_at (\"looser throw specifier for %q#F\", overrider);\n+      cp_error_at (\"  overriding %q#F\", basefn);\n       DECL_INVALID_OVERRIDER_P (overrider) = 1;\n       return 0;\n     }\n@@ -1850,8 +1850,8 @@ look_for_overrides_r (tree type, tree fndecl)\n \t{\n \t  /* A static member function cannot match an inherited\n \t     virtual member function.  */\n-\t  cp_error_at (\"`%#D' cannot be declared\", fndecl);\n-\t  cp_error_at (\"  since `%#D' declared in base class\", fn);\n+\t  cp_error_at (\"%q#D cannot be declared\", fndecl);\n+\t  cp_error_at (\"  since %q#D declared in base class\", fn);\n \t}\n       else\n \t{"}, {"sha": "124af39e58613a8433bd328de63a69a3a95328b1", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a82e1a7d187eeab0dee1ee832c364151d142c7c0/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a82e1a7d187eeab0dee1ee832c364151d142c7c0/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=a82e1a7d187eeab0dee1ee832c364151d142c7c0", "patch": "@@ -1130,8 +1130,8 @@ finish_asm_stmt (int volatile_p, tree string, tree output_operands,\n \t     resolve the overloading.  */\n \t  if (TREE_TYPE (converted_operand) == unknown_type_node)\n \t    {\n-\t      error (\"type of asm operand `%E' could not be determined\", \n-\t\t\tTREE_VALUE (t));\n+\t      error (\"type of asm operand %qE could not be determined\", \n+                     TREE_VALUE (t));\n \t      converted_operand = error_mark_node;\n \t    }\n \t  TREE_VALUE (t) = converted_operand;\n@@ -1263,10 +1263,10 @@ finish_non_static_data_member (tree decl, tree object, tree qualifying_scope)\n     {\n       if (current_function_decl \n \t  && DECL_STATIC_FUNCTION_P (current_function_decl))\n-\tcp_error_at (\"invalid use of member `%D' in static member function\",\n+\tcp_error_at (\"invalid use of member %qD in static member function\",\n \t\t     decl);\n       else\n-\tcp_error_at (\"invalid use of non-static data member `%D'\", decl);\n+\tcp_error_at (\"invalid use of non-static data member %qD\", decl);\n       error (\"from this location\");\n \n       return error_mark_node;\n@@ -1305,7 +1305,7 @@ finish_non_static_data_member (tree decl, tree object, tree qualifying_scope)\n \n \t  if (!access_type)\n \t    {\n-\t      cp_error_at (\"object missing in reference to `%D'\", decl);\n+\t      cp_error_at (\"object missing in reference to %qD\", decl);\n \t      error (\"from this location\");\n \t      return error_mark_node;\n \t    }\n@@ -1886,7 +1886,7 @@ finish_pseudo_destructor_expr (tree object, tree scope, tree destructor)\n       if (!same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (object), \n \t\t\t\t\t\t      destructor))\n \t{\n-\t  error (\"`%E' is not of type `%T'\", object, destructor);\n+\t  error (\"%qE is not of type %qT\", object, destructor);\n \t  return error_mark_node;\n \t}\n     }\n@@ -2024,10 +2024,10 @@ check_template_template_default_arg (tree argument)\n \t     that the user is using a template instantiation.  */\n \t  if (CLASSTYPE_TEMPLATE_INFO (t) \n \t      && CLASSTYPE_TEMPLATE_INSTANTIATION (t))\n-\t    error (\"invalid use of type `%T' as a default value for a \"\n+\t    error (\"invalid use of type %qT as a default value for a \"\n \t           \"template template-parameter\", t);\n \t  else\n-\t    error (\"invalid use of `%D' as a default value for a template \"\n+\t    error (\"invalid use of %qD as a default value for a template \"\n \t           \"template-parameter\", argument);\n \t}\n       else\n@@ -2048,7 +2048,7 @@ begin_class_definition (tree t)\n \n   if (processing_template_parmlist)\n     {\n-      error (\"definition of `%#T' inside template parameter list\", t);\n+      error (\"definition of %q#T inside template parameter list\", t);\n       return error_mark_node;\n     }\n   /* A non-implicit typename comes from code like:\n@@ -2059,7 +2059,7 @@ begin_class_definition (tree t)\n      This is erroneous.  */\n   else if (TREE_CODE (t) == TYPENAME_TYPE)\n     {\n-      error (\"invalid definition of qualified type `%T'\", t);\n+      error (\"invalid definition of qualified type %qT\", t);\n       t = error_mark_node;\n     }\n \n@@ -2073,8 +2073,8 @@ begin_class_definition (tree t)\n      that's an error.  */\n   if (COMPLETE_TYPE_P (t))\n     {\n-      error (\"redefinition of `%#T'\", t);\n-      cp_error_at (\"previous definition of `%#T'\", t);\n+      error (\"redefinition of %q#T\", t);\n+      cp_error_at (\"previous definition of %q#T\", t);\n       return error_mark_node;\n     }\n \n@@ -2259,7 +2259,7 @@ finish_base_specifier (tree base, tree access, bool virtual_p)\n     {\n       if (cp_type_quals (base) != 0)\n         {\n-          error (\"base class `%T' has cv qualifiers\", base);\n+          error (\"base class %qT has cv qualifiers\", base);\n           base = TYPE_MAIN_VARIANT (base);\n         }\n       result = build_tree_list (access, base);\n@@ -2304,19 +2304,19 @@ qualified_name_lookup_error (tree scope, tree name, tree decl)\n   if (TYPE_P (scope))\n     {\n       if (!COMPLETE_TYPE_P (scope))\n-\terror (\"incomplete type `%T' used in nested name specifier\", scope);\n+\terror (\"incomplete type %qT used in nested name specifier\", scope);\n       else if (TREE_CODE (decl) == TREE_LIST)\n \t{\n-\t  error (\"reference to `%T::%D' is ambiguous\", scope, name);\n+\t  error (\"reference to %<%T::%D%> is ambiguous\", scope, name);\n \t  print_candidates (decl);\n \t}\n       else\n-\terror (\"`%D' is not a member of `%T'\", name, scope);\n+\terror (\"%qD is not a member of %qT\", name, scope);\n     }\n   else if (scope != global_namespace)\n-    error (\"`%D' is not a member of `%D'\", name, scope);\n+    error (\"%qD is not a member of %qD\", name, scope);\n   else\n-    error (\"`::%D' has not been declared\", name);\n+    error (\"%<::%D%> has not been declared\", name);\n }\n \t      \n /* ID_EXPRESSION is a representation of parsed, but unprocessed,\n@@ -2439,7 +2439,7 @@ finish_id_expression (tree id_expression,\n \t  && !INTEGRAL_OR_ENUMERATION_TYPE_P (TREE_TYPE (decl))) \n \t{\n \t  if (!allow_non_integral_constant_expression_p)\n-\t    error (\"template parameter `%D' of type `%T' is not allowed in \"\n+\t    error (\"template parameter %qD of type %qT is not allowed in \"\n \t\t   \"an integral constant expression because it is not of \"\n \t\t   \"integral or enumeration type\", decl, TREE_TYPE (decl));\n \t  *non_integral_constant_expression_p = true;\n@@ -2583,26 +2583,26 @@ finish_id_expression (tree id_expression,\n \t{\n \t  if (!allow_non_integral_constant_expression_p)\n \t    {\n-\t      error (\"`%D' cannot appear in a constant-expression\", decl);\n+\t      error (\"%qD cannot appear in a constant-expression\", decl);\n \t      return error_mark_node;\n \t    }\n \t  *non_integral_constant_expression_p = true;\n \t}\n       \n       if (TREE_CODE (decl) == NAMESPACE_DECL)\n \t{\n-\t  error (\"use of namespace `%D' as expression\", decl);\n+\t  error (\"use of namespace %qD as expression\", decl);\n \t  return error_mark_node;\n \t}\n       else if (DECL_CLASS_TEMPLATE_P (decl))\n \t{\n-\t  error (\"use of class template `%T' as expression\", decl);\n+\t  error (\"use of class template %qT as expression\", decl);\n \t  return error_mark_node;\n \t}\n       else if (TREE_CODE (decl) == TREE_LIST)\n \t{\n \t  /* Ambiguous reference to base members.  */\n-\t  error (\"request for member `%D' is ambiguous in \"\n+\t  error (\"request for member %qD is ambiguous in \"\n \t\t \"multiple inheritance lattice\", id_expression);\n \t  print_candidates (decl);\n \t  return error_mark_node;\n@@ -2665,8 +2665,8 @@ finish_id_expression (tree id_expression,\n \t\t{\n \t\t  error (\"use of %s from containing function\",\n \t\t\t (TREE_CODE (decl) == VAR_DECL\n-\t\t\t  ? \"`auto' variable\" : \"parameter\"));\n-\t\t  cp_error_at (\"  `%#D' declared here\", decl);\n+\t\t\t  ? \"%<auto%> variable\" : \"parameter\"));\n+\t\t  cp_error_at (\"  %q#D declared here\", decl);\n \t\t  return error_mark_node;\n \t\t}\n \t    }\n@@ -2717,7 +2717,7 @@ finish_typeof (tree expr)\n \n   if (!type || type == unknown_type_node)\n     {\n-      error (\"type of `%E' is unknown\", expr);\n+      error (\"type of %qE is unknown\", expr);\n       return error_mark_node;\n     }\n "}, {"sha": "cb9379caf8ae05c0aaeb97ac54654e132dcf62f6", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a82e1a7d187eeab0dee1ee832c364151d142c7c0/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a82e1a7d187eeab0dee1ee832c364151d142c7c0/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=a82e1a7d187eeab0dee1ee832c364151d142c7c0", "patch": "@@ -536,7 +536,7 @@ cp_build_qualified_type_real (tree type,\n  \t  tree bad_type = build_qualified_type (ptr_type_node, bad_quals);\n \n  \t  if (!(complain & tf_ignore_bad_quals))\n- \t    error (\"`%V' qualifiers cannot be applied to `%T'\",\n+ \t    error (\"%qV qualifiers cannot be applied to %qT\",\n \t\t   bad_type, type);\n  \t}\n     }\n@@ -1771,7 +1771,7 @@ handle_java_interface_attribute (tree* node,\n       || !CLASS_TYPE_P (*node)\n       || !TYPE_FOR_JAVA (*node))\n     {\n-      error (\"`%E' attribute can only be applied to Java class definitions\",\n+      error (\"%qE attribute can only be applied to Java class definitions\",\n \t     name);\n       *no_add_attrs = true;\n       return NULL_TREE;\n@@ -1800,13 +1800,12 @@ handle_com_interface_attribute (tree* node,\n       || !CLASS_TYPE_P (*node)\n       || *node != TYPE_MAIN_VARIANT (*node))\n     {\n-      warning (\"`%E' attribute can only be applied to class definitions\",\n-\t       name);\n+      warning (\"%qE attribute can only be applied to class definitions\", name);\n       return NULL_TREE;\n     }\n \n   if (!warned++)\n-    warning (\"`%E' is obsolete; g++ vtables are now COM-compatible by default\",\n+    warning (\"%qE is obsolete; g++ vtables are now COM-compatible by default\",\n \t     name);\n \n   return NULL_TREE;\n@@ -1851,7 +1850,7 @@ handle_init_priority_attribute (tree* node,\n \t init_priority value, so don't allow it.  */\n       || current_function_decl)\n     {\n-      error (\"can only use `%E' attribute on file-scope definitions \"\n+      error (\"can only use %qE attribute on file-scope definitions \"\n              \"of objects of class type\", name);\n       *no_add_attrs = true;\n       return NULL_TREE;\n@@ -1879,7 +1878,7 @@ handle_init_priority_attribute (tree* node,\n     }\n   else\n     {\n-      error (\"`%E' attribute is not supported on this platform\", name);\n+      error (\"%qE attribute is not supported on this platform\", name);\n       *no_add_attrs = true;\n       return NULL_TREE;\n     }"}, {"sha": "e59755416ab65d310ccac968ae4d117f764ba27c", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 120, "deletions": 111, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a82e1a7d187eeab0dee1ee832c364151d142c7c0/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a82e1a7d187eeab0dee1ee832c364151d142c7c0/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=a82e1a7d187eeab0dee1ee832c364151d142c7c0", "patch": "@@ -431,7 +431,7 @@ composite_pointer_type_r (tree t1, tree t2, const char* location)\n     result_type = composite_pointer_type_r (pointee1, pointee2, location);\n   else\n     {\n-      pedwarn (\"%s between distinct pointer types `%T' and `%T' \"\n+      pedwarn (\"%s between distinct pointer types %qT and %qT \"\n \t       \"lacks a cast\",\n \t       location, t1, t2);\n       result_type = void_type_node;\n@@ -445,7 +445,7 @@ composite_pointer_type_r (tree t1, tree t2, const char* location)\n     {\n       if (!same_type_p (TYPE_PTRMEM_CLASS_TYPE (t1),\n \t\t\tTYPE_PTRMEM_CLASS_TYPE (t2)))\n-\tpedwarn (\"%s between distinct pointer types `%T' and `%T' \"\n+\tpedwarn (\"%s between distinct pointer types %qT and %qT \"\n \t\t \"lacks a cast\",\n \t\t location, t1, t2);\n       result_type = build_ptrmem_type (TYPE_PTRMEM_CLASS_TYPE (t1),\n@@ -507,7 +507,8 @@ composite_pointer_type (tree t1, tree t2, tree arg1, tree arg2,\n       tree result_type;\n \n       if (pedantic && TYPE_PTRFN_P (t2))\n-\tpedwarn (\"ISO C++ forbids %s between pointer of type `void *' and pointer-to-function\", location);\n+\tpedwarn (\"ISO C++ forbids %s between pointer of type %<void *%> \"\n+                 \"and pointer-to-function\", location);\n       result_type \n \t= cp_build_qualified_type (void_type_node,\n \t\t\t\t   (cp_type_quals (TREE_TYPE (t1))\n@@ -537,7 +538,7 @@ composite_pointer_type (tree t1, tree t2, tree arg1, tree arg2,\n \t      (cp_build_qualified_type (class2, TYPE_QUALS (class1))));\n       else\n \t{\n-\t  error (\"%s between distinct pointer types `%T' and `%T' \"\n+\t  error (\"%s between distinct pointer types %qT and %qT \"\n \t\t \"lacks a cast\", location, t1, t2);\n \t  return error_mark_node;\n \t}\n@@ -557,7 +558,7 @@ composite_pointer_type (tree t1, tree t2, tree arg1, tree arg2,\n \tt2 = build_ptrmem_type (class1, TYPE_PTRMEM_POINTED_TO_TYPE (t2));\n       else\n \t{\n-\t  error (\"%s between distinct pointer-to-member types `%T' and `%T' \"\n+\t  error (\"%s between distinct pointer-to-member types %qT and %qT \"\n \t\t \"lacks a cast\", location, t1, t2);\n \t  return error_mark_node;\n \t}\n@@ -1244,7 +1245,7 @@ cxx_sizeof_or_alignof_type (tree type, enum tree_code op, bool complain)\n   if (type_code == METHOD_TYPE)\n     {\n       if (complain && (pedantic || warn_pointer_arith))\n-\tpedwarn (\"invalid application of `%s' to a member function\", op_name);\n+\tpedwarn (\"invalid application of %qs to a member function\", op_name);\n       value = size_one_node;\n     }\n   else\n@@ -1277,12 +1278,13 @@ cxx_sizeof_or_alignof_expr (tree e, enum tree_code op)\n       && TREE_CODE (TREE_OPERAND (e, 1)) == FIELD_DECL\n       && DECL_C_BIT_FIELD (TREE_OPERAND (e, 1)))\n     {\n-      error (\"invalid application of `%s' to a bit-field\", op_name);\n+      error (\"invalid application of %qs to a bit-field\", op_name);\n       e = char_type_node;\n     }\n   else if (is_overloaded_fn (e))\n     {\n-      pedwarn (\"ISO C++ forbids applying `%s' to an expression of function type\", op_name);\n+      pedwarn (\"ISO C++ forbids applying %qs to an expression of \"\n+               \"function type\", op_name);\n       e = char_type_node;\n     }\n   else if (type_unknown_p (e))\n@@ -1503,7 +1505,7 @@ string_conv_p (tree totype, tree exp, int warn)\n \n   /* This warning is not very useful, as it complains about printf.  */\n   if (warn && warn_write_strings)\n-    warning (\"deprecated conversion from string constant to `%T'\", totype);\n+    warning (\"deprecated conversion from string constant to %qT'\", totype);\n \n   return 1;\n }\n@@ -1617,7 +1619,7 @@ build_class_member_access_expr (tree object, tree member,\n     return error_mark_node;\n   if (!CLASS_TYPE_P (object_type))\n     {\n-      error (\"request for member `%D' in `%E', which is of non-class type `%T'\", \n+      error (\"request for member %qD in %qE, which is of non-class type %qT\", \n \t     member, object, object_type);\n       return error_mark_node;\n     }\n@@ -1644,9 +1646,9 @@ build_class_member_access_expr (tree object, tree member,\n   if (!member_scope || !DERIVED_FROM_P (member_scope, object_type))\n     {\n       if (TREE_CODE (member) == FIELD_DECL)\n-        error (\"invalid use of nonstatic data member '%E'\", member);\n+        error (\"invalid use of nonstatic data member %qE\", member);\n       else\n-        error (\"`%D' is not a member of `%T'\", member, object_type);\n+        error (\"%qD is not a member of %qT\", member, object_type);\n       return error_mark_node;\n     }\n \n@@ -1696,9 +1698,10 @@ build_class_member_access_expr (tree object, tree member,\n \t     offsetof macro.  */\n \t  if (null_object_p && kind == bk_via_virtual)\n \t    {\n-\t      error (\"invalid access to non-static data member `%D' of NULL object\",\n+\t      error (\"invalid access to non-static data member %qD of \"\n+                     \"NULL object\",\n \t\t     member);\n-\t      error (\"(perhaps the `offsetof' macro was used incorrectly)\");\n+\t      error (\"(perhaps the %<offsetof%> macro was used incorrectly)\");\n \t      return error_mark_node;\n \t    }\n \n@@ -1723,9 +1726,9 @@ build_class_member_access_expr (tree object, tree member,\n \t  && !DECL_FIELD_IS_BASE (member)\n \t  && !skip_evaluation)\n \t{\n-\t  warning (\"invalid access to non-static data member `%D' of NULL object\", \n+\t  warning (\"invalid access to non-static data member %qD of NULL object\", \n \t\t   member);\n-\t  warning  (\"(perhaps the `offsetof' macro was used incorrectly)\");\n+\t  warning  (\"(perhaps the %<offsetof%> macro was used incorrectly)\");\n \t}\n \n       /* If MEMBER is from an anonymous aggregate, we have converted\n@@ -1810,7 +1813,7 @@ build_class_member_access_expr (tree object, tree member,\n     }\n   else\n     {\n-      error (\"invalid use of `%D'\", member);\n+      error (\"invalid use of %qD\", member);\n       return error_mark_node;\n     }\n \n@@ -1836,13 +1839,13 @@ lookup_destructor (tree object, tree scope, tree dtor_name)\n \n   if (scope && !check_dtor_name (scope, dtor_name))\n     {\n-      error (\"qualified type `%T' does not match destructor name `~%T'\",\n+      error (\"qualified type %qT does not match destructor name ~%qT\",\n \t     scope, dtor_type);\n       return error_mark_node;\n     }\n   if (!DERIVED_FROM_P (dtor_type, TYPE_MAIN_VARIANT (object_type)))\n     {\n-      error (\"the type being destroyed is `%T', but the destructor refers to `%T'\",\n+      error (\"the type being destroyed is %qT, but the destructor refers to %qT\",\n \t     TYPE_MAIN_VARIANT (object_type), dtor_type);\n       return error_mark_node;\n     }\n@@ -1915,7 +1918,7 @@ finish_class_member_access_expr (tree object, tree name)\n     return error_mark_node;\n   if (!CLASS_TYPE_P (object_type))\n     {\n-      error (\"request for member `%D' in `%E', which is of non-class type `%T'\", \n+      error (\"request for member %qD in %qE, which is of non-class type %qT\", \n \t     name, object, object_type);\n       return error_mark_node;\n     }\n@@ -1961,7 +1964,7 @@ finish_class_member_access_expr (tree object, tree name)\n \t     name a member of OBJECT_TYPE.  */\n \t  if (TREE_CODE (scope) == NAMESPACE_DECL)\n \t    {\n-\t      error (\"`%D::%D' is not a member of `%T'\", \n+\t      error (\"%<%D::%D%> is not a member of %qT\", \n \t\t     scope, name, object_type);\n \t      return error_mark_node;\n \t    }\n@@ -1972,7 +1975,7 @@ finish_class_member_access_expr (tree object, tree name)\n \t    return error_mark_node;\n \t  if (!access_path)\n \t    {\n-\t      error (\"`%T' is not a base of `%T'\", scope, object_type);\n+\t      error (\"%qT is not a base of %qT\", scope, object_type);\n \t      return error_mark_node;\n \t    }\n \t}\n@@ -1991,7 +1994,7 @@ finish_class_member_access_expr (tree object, tree name)\n \t\t\t\t  /*want_type=*/false);\n \t  if (member == NULL_TREE)\n \t    {\n-\t      error (\"'%D' has no member named '%E'\", object_type, name);\n+\t      error (\"%qD has no member named %qE\", object_type, name);\n \t      return error_mark_node;\n \t    }\n \t  if (member == error_mark_node)\n@@ -2006,7 +2009,7 @@ finish_class_member_access_expr (tree object, tree name)\n \t    template = lookup_template_function (template, template_args);\n \t  else\n \t    {\n-\t      error (\"`%D' is not a member template function\", name);\n+\t      error (\"%qD is not a member template function\", name);\n \t      return error_mark_node;\n \t    }\n \t}\n@@ -2113,7 +2116,7 @@ build_indirect_ref (tree ptr, const char *errorstring)\n         {\n           /* A pointer to incomplete type (other than cv void) can be\n              dereferenced [expr.unary.op]/1  */\n-          error (\"`%T' is not a pointer-to-object type\", type);\n+          error (\"%qT is not a pointer-to-object type\", type);\n           return error_mark_node;\n         }\n       else if (TREE_CODE (pointer) == ADDR_EXPR\n@@ -2138,11 +2141,11 @@ build_indirect_ref (tree ptr, const char *errorstring)\n   /* `pointer' won't be an error_mark_node if we were given a\n      pointer to member, so it's cool to check for this here.  */\n   else if (TYPE_PTR_TO_MEMBER_P (type))\n-    error (\"invalid use of `%s' on pointer to member\", errorstring);\n+    error (\"invalid use of %qs on pointer to member\", errorstring);\n   else if (pointer != error_mark_node)\n     {\n       if (errorstring)\n-\terror (\"invalid type argument of `%s'\", errorstring);\n+\terror (\"invalid type argument of %qs\", errorstring);\n       else\n \terror (\"invalid type argument\");\n     }\n@@ -2208,7 +2211,7 @@ build_array_ref (tree array, tree idx)\n \t must have done so deliberately.  */\n       if (warn_char_subscripts\n \t  && TYPE_MAIN_VARIANT (TREE_TYPE (idx)) == char_type_node)\n-\twarning (\"array subscript has type `char'\");\n+\twarning (\"array subscript has type %<char%>\");\n \n       if (!INTEGRAL_OR_ENUMERATION_TYPE_P (TREE_TYPE (idx)))\n \t{\n@@ -2260,7 +2263,7 @@ build_array_ref (tree array, tree idx)\n \t  while (TREE_CODE (foo) == COMPONENT_REF)\n \t    foo = TREE_OPERAND (foo, 0);\n \t  if (TREE_CODE (foo) == VAR_DECL && DECL_REGISTER (foo))\n-\t    warning (\"subscripting array declared `register'\");\n+\t    warning (\"subscripting array declared %<register%>\");\n \t}\n \n       type = TREE_TYPE (TREE_TYPE (array));\n@@ -2343,7 +2346,7 @@ get_member_function_from_ptrfunc (tree *instance_ptrptr, tree function)\n \t    }\n \t  else\n \t    {\n-\t      error (\"object missing in use of `%E'\", function);\n+\t      error (\"object missing in use of %qE\", function);\n \t      return error_mark_node;\n \t    }\n \t}\n@@ -2444,7 +2447,7 @@ build_function_call (tree function, tree params)\n \n       /* Convert anything with function type to a pointer-to-function.  */\n       if (pedantic && DECL_MAIN_P (function))\n-\tpedwarn (\"ISO C++ forbids calling `::main' from within program\");\n+\tpedwarn (\"ISO C++ forbids calling %<::main%> from within program\");\n \n       /* Differs from default_conversion by not setting TREE_ADDRESSABLE\n \t (because calling an inline function does not mean the function\n@@ -2469,8 +2472,9 @@ build_function_call (tree function, tree params)\n \n   if (TYPE_PTRMEMFUNC_P (fntype))\n     {\n-      error (\"must use .* or ->* to call pointer-to-member function in `%E (...)'\",\n-\t\toriginal);\n+      error (\"must use %<.*%> or %<->*%> to call pointer-to-member \"\n+             \"function in %<%E (...)%>\",\n+             original);\n       return error_mark_node;\n     }\n \n@@ -2482,7 +2486,7 @@ build_function_call (tree function, tree params)\n \t|| is_method\n \t|| TREE_CODE (function) == TEMPLATE_ID_EXPR))\n     {\n-      error (\"`%E' cannot be used as a function\", original);\n+      error (\"%qE cannot be used as a function\", original);\n       return error_mark_node;\n     }\n \n@@ -2561,7 +2565,7 @@ convert_arguments (tree typelist, tree values, tree fndecl, int flags)\n \t{\n \t  if (fndecl)\n \t    {\n-\t      cp_error_at (\"too many arguments to %s `%+#D'\", called_thing,\n+\t      cp_error_at (\"too many arguments to %s %q+#D\", called_thing,\n \t\t\t   fndecl);\n \t      error (\"at this point in file\");\n \t    }\n@@ -2600,10 +2604,10 @@ convert_arguments (tree typelist, tree values, tree fndecl, int flags)\n \t  if (!COMPLETE_TYPE_P (complete_type (type)))\n \t    {\n \t      if (fndecl)\n-\t\terror (\"parameter %P of `%D' has incomplete type `%T'\",\n+\t\terror (\"parameter %P of %qD has incomplete type %qT\",\n \t\t       i, fndecl, type);\n \t      else\n-\t\terror (\"parameter %P has incomplete type `%T'\", i, type);\n+\t\terror (\"parameter %P has incomplete type %qT\", i, type);\n \t      parmval = error_mark_node;\n \t    }\n \t  else\n@@ -2667,7 +2671,7 @@ convert_arguments (tree typelist, tree values, tree fndecl, int flags)\n \t{\n \t  if (fndecl)\n \t    {\n-\t      cp_error_at (\"too few arguments to %s `%+#D'\",\n+\t      cp_error_at (\"too few arguments to %s %q+#D\",\n \t                   called_thing, fndecl);\n \t      error (\"at this point in file\");\n \t    }\n@@ -2819,8 +2823,8 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n       tree t = instantiate_type (TREE_TYPE (op1), op0, tf_none);\n       if (t != error_mark_node)\n \t{\n-\t  pedwarn (\"assuming cast to type `%T' from overloaded function\",\n-\t\t      TREE_TYPE (t));\n+\t  pedwarn (\"assuming cast to type %qT from overloaded function\",\n+                   TREE_TYPE (t));\n \t  op0 = t;\n \t}\n     }\n@@ -2829,8 +2833,8 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n       tree t = instantiate_type (TREE_TYPE (op0), op1, tf_none);\n       if (t != error_mark_node)\n \t{\n-\t  pedwarn (\"assuming cast to type `%T' from overloaded function\",\n-\t\t      TREE_TYPE (t));\n+\t  pedwarn (\"assuming cast to type %qT from overloaded function\",\n+                   TREE_TYPE (t));\n \t  op1 = t;\n \t}\n     }\n@@ -2890,9 +2894,9 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t      || code1 == COMPLEX_TYPE || code1 == VECTOR_TYPE))\n \t{\n \t  if (TREE_CODE (op1) == INTEGER_CST && integer_zerop (op1))\n-\t    warning (\"division by zero in `%E / 0'\", op0);\n+\t    warning (\"division by zero in %<%E / 0%>\", op0);\n \t  else if (TREE_CODE (op1) == REAL_CST && real_zerop (op1))\n-\t    warning (\"division by zero in `%E / 0.'\", op0);\n+\t    warning (\"division by zero in %<%E / 0.%>\", op0);\n \t      \n \t  if (code0 == COMPLEX_TYPE || code0 == VECTOR_TYPE)\n \t    code0 = TREE_CODE (TREE_TYPE (TREE_TYPE (op0)));\n@@ -2926,9 +2930,9 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n     case TRUNC_MOD_EXPR:\n     case FLOOR_MOD_EXPR:\n       if (code1 == INTEGER_TYPE && integer_zerop (op1))\n-\twarning (\"division by zero in `%E %% 0'\", op0);\n+\twarning (\"division by zero in %<%E %% 0%>\", op0);\n       else if (code1 == REAL_TYPE && real_zerop (op1))\n-\twarning (\"division by zero in `%E %% 0.'\", op0);\n+\twarning (\"division by zero in %<%E %% 0.%>\", op0);\n       \n       if (code0 == INTEGER_TYPE && code1 == INTEGER_TYPE)\n \t{\n@@ -3187,7 +3191,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \n   if (!result_type)\n     {\n-      error (\"invalid operands of types `%T' and `%T' to binary `%O'\",\n+      error (\"invalid operands of types %qT and %qT to binary %qO\",\n \t     TREE_TYPE (orig_op0), TREE_TYPE (orig_op1), code);\n       return error_mark_node;\n     }\n@@ -3349,8 +3353,8 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t      && TYPE_MAIN_VARIANT (TREE_TYPE (orig_op0))\n \t         != TYPE_MAIN_VARIANT (TREE_TYPE (orig_op1)))\n \t    {\n-\t      warning (\"comparison between types `%#T' and `%#T'\", \n-\t\t\t  TREE_TYPE (orig_op0), TREE_TYPE (orig_op1));\n+\t      warning (\"comparison between types %q#T and %q#T\", \n+                       TREE_TYPE (orig_op0), TREE_TYPE (orig_op1));\n \t    }\n \n \t  /* Give warnings for comparisons between signed and unsigned\n@@ -3522,7 +3526,7 @@ pointer_diff (tree op0, tree op1, tree ptrtype)\n   if (pedantic || warn_pointer_arith)\n     {\n       if (TREE_CODE (target_type) == VOID_TYPE)\n-\tpedwarn (\"ISO C++ forbids using pointer of type `void *' in subtraction\");\n+\tpedwarn (\"ISO C++ forbids using pointer of type %<void *%> in subtraction\");\n       if (TREE_CODE (target_type) == FUNCTION_TYPE)\n \tpedwarn (\"ISO C++ forbids using pointer to a function in subtraction\");\n       if (TREE_CODE (target_type) == METHOD_TYPE)\n@@ -3884,16 +3888,16 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \t    tree type = complete_type (TREE_TYPE (argtype));\n \t    \n \t    if (!COMPLETE_OR_VOID_TYPE_P (type))\n-\t      error (\"cannot %s a pointer to incomplete type `%T'\",\n-\t\t\t((code == PREINCREMENT_EXPR\n-\t\t\t  || code == POSTINCREMENT_EXPR)\n-\t\t\t ? \"increment\" : \"decrement\"), TREE_TYPE (argtype));\n+\t      error (\"cannot %s a pointer to incomplete type %qT\",\n+                     ((code == PREINCREMENT_EXPR\n+                       || code == POSTINCREMENT_EXPR)\n+                      ? \"increment\" : \"decrement\"), TREE_TYPE (argtype));\n \t    else if ((pedantic || warn_pointer_arith)\n \t\t     && !TYPE_PTROB_P (argtype))\n-\t      pedwarn (\"ISO C++ forbids %sing a pointer of type `%T'\",\n-\t\t\t  ((code == PREINCREMENT_EXPR\n-\t\t\t    || code == POSTINCREMENT_EXPR)\n-\t\t\t   ? \"increment\" : \"decrement\"), argtype);\n+\t      pedwarn (\"ISO C++ forbids %sing a pointer of type %qT\",\n+                       ((code == PREINCREMENT_EXPR\n+                         || code == POSTINCREMENT_EXPR)\n+                        ? \"increment\" : \"decrement\"), argtype);\n \t    inc = cxx_sizeof_nowarn (TREE_TYPE (argtype));\n \t  }\n \telse\n@@ -3950,7 +3954,7 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \t  {\n \t    if (code == POSTDECREMENT_EXPR || code == PREDECREMENT_EXPR)\n \t      {\n-\t\terror (\"invalid use of `--' on bool variable `%D'\", arg);\n+\t\terror (\"invalid use of %<--%> on bool variable %qD\", arg);\n \t\treturn error_mark_node;\n \t      }\n \t    val = boolean_increment (code, arg);\n@@ -3979,7 +3983,7 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \t}\n       else if (pedantic && DECL_MAIN_P (arg))\n \t/* ARM $3.4 */\n-\tpedwarn (\"ISO C++ forbids taking address of function `::main'\");\n+\tpedwarn (\"ISO C++ forbids taking address of function %<::main%>\");\n \n       /* Let &* cancel out to simplify resulting code.  */\n       if (TREE_CODE (arg) == INDIRECT_REF)\n@@ -4035,12 +4039,12 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \t\t/* An expression like &memfn.  */\n \t\tpedwarn (\"ISO C++ forbids taking the address of an unqualified\"\n \t\t\t \" or parenthesized non-static member function to form\"\n-\t\t\t \" a pointer to member function.  Say `&%T::%D'\",\n+\t\t\t \" a pointer to member function.  Say %<&%T::%D%>\",\n \t\t\t base, name);\n \t      else\n \t\tpedwarn (\"ISO C++ forbids taking the address of a bound member\"\n \t\t\t \" function to form a pointer to member function.\"\n-\t\t\t \"  Say `&%T::%D'\",\n+\t\t\t \"  Say %<&%T::%D%>\",\n \t\t\t base, name);\n \t    }\n \t  arg = build_offset_ref (base, name, /*address_p=*/true);\n@@ -4086,7 +4090,7 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \t is an error.  */\n       else if (TREE_CODE (argtype) != FUNCTION_TYPE\n \t       && TREE_CODE (argtype) != METHOD_TYPE\n-\t       && !lvalue_or_else (arg, \"unary `&'\"))\n+\t       && !lvalue_or_else (arg, \"unary %<&$>\"))\n \treturn error_mark_node;\n \n       if (argtype != error_mark_node)\n@@ -4118,7 +4122,7 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \t  }\n \telse if (DECL_C_BIT_FIELD (TREE_OPERAND (arg, 1)))\n \t  {\n-\t    error (\"attempt to take address of bit-field structure member `%D'\",\n+\t    error (\"attempt to take address of bit-field structure member %qD\",\n \t\t   TREE_OPERAND (arg, 1));\n \t    return error_mark_node;\n \t  }\n@@ -4251,7 +4255,7 @@ unary_complex_lvalue (enum tree_code code, tree arg)\n \t  \n \t  if (TREE_CODE (TREE_TYPE (t)) == REFERENCE_TYPE)\n \t    {\n-\t      error (\"cannot create pointer to reference member `%D'\", t);\n+\t      error (\"cannot create pointer to reference member %qD\", t);\n \t      return error_mark_node;\n \t    }\n \n@@ -4333,8 +4337,8 @@ cxx_mark_addressable (tree exp)\n       case RESULT_DECL:\n \tif (DECL_REGISTER (x) && !TREE_ADDRESSABLE (x)\n \t    && !DECL_ARTIFICIAL (x) && extra_warnings)\n-\t  warning (\"address requested for `%D', which is declared `register'\",\n-\t\t      x);\n+\t  warning (\"address requested for %qD, which is declared `register'\",\n+                   x);\n \tTREE_ADDRESSABLE (x) = 1;\n \treturn true;\n \n@@ -4473,7 +4477,7 @@ check_for_casting_away_constness (tree src_type, tree dest_type,\n \t\t\t\t  const char *description)\n {\n   if (casts_away_constness (src_type, dest_type))\n-    error (\"%s from type `%T' to type `%T' casts away constness\",\n+    error (\"%s from type %qT to type %qT casts away constness\",\n \t   description, src_type, dest_type);\n }\n \n@@ -4675,7 +4679,7 @@ build_static_cast (tree type, tree expr)\n       return build_nop (type, expr);\n     }\n \n-  error (\"invalid static_cast from type `%T' to type `%T'\", intype, type);\n+  error (\"invalid static_cast from type %qT to type %qT\", intype, type);\n   return error_mark_node;\n }\n \n@@ -4718,7 +4722,8 @@ build_reinterpret_cast (tree type, tree expr)\n     {\n       if (! real_lvalue_p (expr))\n \t{\n-\t  error (\"invalid reinterpret_cast of an rvalue expression of type `%T' to type `%T'\", intype, type);\n+\t  error (\"invalid reinterpret_cast of an rvalue expression of type \"\n+                 \"%qT to type %qT\", intype, type);\n \t  return error_mark_node;\n \t}\n       expr = build_unary_op (ADDR_EXPR, expr, 0);\n@@ -4738,8 +4743,8 @@ build_reinterpret_cast (tree type, tree expr)\n   else if (TREE_CODE (type) == INTEGER_TYPE && TYPE_PTR_P (intype))\n     {\n       if (TYPE_PRECISION (type) < TYPE_PRECISION (intype))\n-\tpedwarn (\"reinterpret_cast from `%T' to `%T' loses precision\",\n-\t\t    intype, type);\n+\tpedwarn (\"reinterpret_cast from %qT to %qT loses precision\",\n+                 intype, type);\n     }\n   else if ((TYPE_PTRFN_P (type) && TYPE_PTRFN_P (intype))\n \t   || (TYPE_PTRMEMFUNC_P (type) && TYPE_PTRMEMFUNC_P (intype)))\n@@ -4763,8 +4768,8 @@ build_reinterpret_cast (tree type, tree expr)\n     }\n   else\n     {\n-      error (\"invalid reinterpret_cast from type `%T' to type `%T'\",\n-                intype, type);\n+      error (\"invalid reinterpret_cast from type %qT to type %qT\",\n+             intype, type);\n       return error_mark_node;\n     }\n       \n@@ -4791,10 +4796,12 @@ build_const_cast (tree type, tree expr)\n     }\n \n   if (!POINTER_TYPE_P (type) && !TYPE_PTRMEM_P (type))\n-    error (\"invalid use of const_cast with type `%T', which is not a pointer, reference, nor a pointer-to-data-member type\", type);\n+    error (\"invalid use of const_cast with type %qT, which is not a pointer, \"\n+           \"reference, nor a pointer-to-data-member type\", type);\n   else if (TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE)\n     {\n-      error (\"invalid use of const_cast with type `%T', which is a pointer or reference to a function type\", type);\n+      error (\"invalid use of const_cast with type %qT, which is a pointer \"\n+             \"or reference to a function type\", type);\n       return error_mark_node;\n     }\n \n@@ -4817,7 +4824,8 @@ build_const_cast (tree type, tree expr)\n     {\n       if (! real_lvalue_p (expr))\n \t{\n-\t  error (\"invalid const_cast of an rvalue of type `%T' to type `%T'\", intype, type);\n+\t  error (\"invalid const_cast of an rvalue of type %qT to type %qT\",\n+                 intype, type);\n \t  return error_mark_node;\n \t}\n \n@@ -4834,7 +4842,7 @@ build_const_cast (tree type, tree expr)\n \t   && comp_ptr_ttypes_const (TREE_TYPE (type), TREE_TYPE (intype)))\n     return cp_convert (type, expr);\n \n-  error (\"invalid const_cast from type `%T' to type `%T'\", intype, type);\n+  error (\"invalid const_cast from type %qT to type %qT\", intype, type);\n   return error_mark_node;\n }\n \n@@ -4881,20 +4889,20 @@ build_c_cast (tree type, tree expr)\n \t NIHCL uses it. It is not valid ISO C++ however.  */\n       if (TREE_CODE (TREE_TYPE (expr)) == POINTER_TYPE)\n \t{\n-\t  pedwarn (\"ISO C++ forbids casting to an array type `%T'\", type);\n+\t  pedwarn (\"ISO C++ forbids casting to an array type %qT\", type);\n \t  type = build_pointer_type (TREE_TYPE (type));\n \t}\n       else\n \t{\n-\t  error (\"ISO C++ forbids casting to an array type `%T'\", type);\n+\t  error (\"ISO C++ forbids casting to an array type %qT\", type);\n \t  return error_mark_node;\n \t}\n     }\n \n   if (TREE_CODE (type) == FUNCTION_TYPE\n       || TREE_CODE (type) == METHOD_TYPE)\n     {\n-      error (\"invalid cast to function type `%T'\", type);\n+      error (\"invalid cast to function type %qT\", type);\n       return error_mark_node;\n     }\n \n@@ -4950,8 +4958,9 @@ build_c_cast (tree type, tree expr)\n       && TREE_CODE (otype) == POINTER_TYPE\n       && !at_least_as_qualified_p (TREE_TYPE (type),\n \t\t\t\t   TREE_TYPE (otype)))\n-    warning (\"cast from `%T' to `%T' discards qualifiers from pointer target type\",\n-                otype, type);\n+    warning (\"cast from %qT to %qT discards qualifiers from pointer \"\n+             \"target type\",\n+             otype, type);\n \n   if (TREE_CODE (type) == INTEGER_TYPE\n       && TYPE_PTR_P (otype)\n@@ -4998,8 +5007,9 @@ build_c_cast (tree type, tree expr)\n       && COMPLETE_TYPE_P (TREE_TYPE (otype))\n       && COMPLETE_TYPE_P (TREE_TYPE (type))\n       && TYPE_ALIGN (TREE_TYPE (type)) > TYPE_ALIGN (TREE_TYPE (otype)))\n-    warning (\"cast from `%T' to `%T' increases required alignment of target type\",\n-                otype, type);\n+    warning (\"cast from %qT to %qT increases required alignment of \"\n+             \"target type\",\n+             otype, type);\n \n     /* Always produce some operator for an explicit cast,\n        so we can tell (for -pedantic) that the cast is no lvalue.  */\n@@ -5183,7 +5193,7 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n \t  newrhs = cp_build_binary_op (modifycode, lhs, rhs);\n \t  if (newrhs == error_mark_node)\n \t    {\n-\t      error (\"  in evaluation of `%Q(%#T, %#T)'\", modifycode,\n+\t      error (\"  in evaluation of %<%Q(%#T, %#T)%>\", modifycode,\n \t\t     TREE_TYPE (lhs), TREE_TYPE (rhs));\n \t      return error_mark_node;\n \t    }\n@@ -5252,7 +5262,7 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n       if (!same_or_base_type_p (TYPE_MAIN_VARIANT (lhstype),\n \t\t\t\tTYPE_MAIN_VARIANT (TREE_TYPE (rhs))))\n \t{\n-\t  error (\"incompatible types in assignment of `%T' to `%T'\",\n+\t  error (\"incompatible types in assignment of %qT to %qT\",\n \t\t TREE_TYPE (rhs), lhstype);\n \t  return error_mark_node;\n \t}\n@@ -5398,10 +5408,10 @@ get_delta_difference (tree from, tree to, int force)\n \t{\n \t  /* This is a reinterpret cast, we choose to do nothing.  */\n \t  if (force)\n-\t    warning (\"pointer to member cast via virtual base `%T'\",\n+\t    warning (\"pointer to member cast via virtual base %qT\",\n \t\t     BINFO_TYPE (virt_binfo));\n \t  else\n-\t    error (\"pointer to member conversion via virtual base `%T'\",\n+\t    error (\"pointer to member conversion via virtual base %qT\",\n \t\t   BINFO_TYPE (virt_binfo));\n \t}\n     }\n@@ -5474,8 +5484,8 @@ build_ptrmemfunc (tree type, tree pfn, int force)\n \n       if (!force \n \t  && !can_convert_arg (to_type, TREE_TYPE (pfn), pfn))\n-\terror (\"invalid conversion to type `%T' from type `%T'\", \n-\t\t  to_type, pfn_type);\n+\terror (\"invalid conversion to type %qT from type %qT\", \n+               to_type, pfn_type);\n \n       n = get_delta_difference (TYPE_PTRMEMFUNC_OBJECT_TYPE (pfn_type),\n \t\t\t\tTYPE_PTRMEMFUNC_OBJECT_TYPE (to_type),\n@@ -5636,21 +5646,21 @@ dubious_conversion_warnings (tree type, tree expr,\n   if (ARITHMETIC_TYPE_P (type) && expr == null_node)\n     {\n       if (fndecl)\n-        warning (\"passing NULL used for non-pointer %s %P of `%D'\",\n-                    errtype, parmnum, fndecl);\n+        warning (\"passing NULL used for non-pointer %s %P of %qD\",\n+                 errtype, parmnum, fndecl);\n       else\n-        warning (\"%s to non-pointer type `%T' from NULL\", errtype, type);\n+        warning (\"%s to non-pointer type %qT from NULL\", errtype, type);\n     }\n   \n   /* Warn about assigning a floating-point type to an integer type.  */\n   if (TREE_CODE (TREE_TYPE (expr)) == REAL_TYPE\n       && TREE_CODE (type) == INTEGER_TYPE)\n     {\n       if (fndecl)\n-\twarning (\"passing `%T' for %s %P of `%D'\",\n-\t\t    TREE_TYPE (expr), errtype, parmnum, fndecl);\n+\twarning (\"passing %qT for %s %P of %qD\",\n+                 TREE_TYPE (expr), errtype, parmnum, fndecl);\n       else\n-\twarning (\"%s to `%T' from `%T'\", errtype, type, TREE_TYPE (expr));\n+\twarning (\"%s to %qT from %qT\", errtype, type, TREE_TYPE (expr));\n     }\n   /* And warn about assigning a negative value to an unsigned\n      variable.  */\n@@ -5659,11 +5669,10 @@ dubious_conversion_warnings (tree type, tree expr,\n       if (TREE_CODE (expr) == INTEGER_CST && TREE_NEGATED_INT (expr))\n \t{\n \t  if (fndecl)\n-\t    warning (\"passing negative value `%E' for %s %P of `%D'\",\n-\t\t\texpr, errtype, parmnum, fndecl);\n+\t    warning (\"passing negative value %qE for %s %P of %qD\",\n+                     expr, errtype, parmnum, fndecl);\n \t  else\n-\t    warning (\"%s of negative value `%E' to `%T'\",\n-\t\t\terrtype, expr, type);\n+\t    warning (\"%s of negative value %qE to %qT\", errtype, expr, type);\n \t}\n \n       overflow_warning (expr);\n@@ -5749,11 +5758,10 @@ convert_for_assignment (tree type, tree rhs,\n \t  if (rhstype == unknown_type_node)\n \t    instantiate_type (type, rhs, tf_error | tf_warning);\n \t  else if (fndecl)\n-\t    error (\"cannot convert `%T' to `%T' for argument `%P' to `%D'\",\n-\t\t      rhstype, type, parmnum, fndecl);\n+\t    error (\"cannot convert %qT to %qT for argument %qP to %qD\",\n+                   rhstype, type, parmnum, fndecl);\n \t  else\n-\t    error (\"cannot convert `%T' to `%T' in %s\", rhstype, type, \n-\t\t      errtype);\n+\t    error (\"cannot convert %qT to %qT in %s\", rhstype, type, errtype);\n \t  return error_mark_node;\n \t}\n     }\n@@ -5829,9 +5837,9 @@ convert_for_initialization (tree exp, tree type, tree rhs, int flags,\n       if (fndecl)\n \t{\n \t  if (warningcount > savew)\n-\t    cp_warning_at (\"in passing argument %P of `%+D'\", parmnum, fndecl);\n+\t    cp_warning_at (\"in passing argument %P of %q+D\", parmnum, fndecl);\n \t  else if (errorcount > savee)\n-\t    cp_error_at (\"in passing argument %P of `%+D'\", parmnum, fndecl);\n+\t    cp_error_at (\"in passing argument %P of %q+D\", parmnum, fndecl);\n \t}\n       return rhs;\n     }      \n@@ -5900,10 +5908,10 @@ maybe_warn_about_returning_address_of_local (tree retval)\n \t   || TREE_PUBLIC (whats_returned)))\n     {\n       if (TREE_CODE (valtype) == REFERENCE_TYPE)\n-\tcp_warning_at (\"reference to local variable `%D' returned\", \n+\tcp_warning_at (\"reference to local variable %qD returned\", \n \t\t       whats_returned);\n       else\n-\tcp_warning_at (\"address of local variable `%D' returned\", \n+\tcp_warning_at (\"address of local variable %qD returned\", \n \t\t       whats_returned);\n       return;\n     }\n@@ -6006,7 +6014,8 @@ check_return_expr (tree retval)\n       && !TYPE_NOTHROW_P (TREE_TYPE (current_function_decl))\n       && ! flag_check_new\n       && null_ptr_cst_p (retval))\n-    warning (\"`operator new' must not return NULL unless it is declared `throw()' (or -fcheck-new is in effect)\");\n+    warning (\"%<operator new%> must not return NULL unless it is \"\n+             \"declared %<throw()%> (or -fcheck-new is in effect)\");\n \n   /* Effective C++ rule 15.  See also start_function.  */\n   if (warn_ecpp\n@@ -6031,7 +6040,7 @@ check_return_expr (tree retval)\n \t}\n \n       if (warn)\n-\twarning (\"`operator=' should return a reference to `*this'\");\n+\twarning (\"%<operator=%> should return a reference to %<*this%>\");\n     }\n \n   /* The fabled Named Return Value optimization, as per [class.copy]/15:"}, {"sha": "758f5f06de6bcbecdc8b5b05fbcb6d4624c5de05", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 58, "deletions": 53, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a82e1a7d187eeab0dee1ee832c364151d142c7c0/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a82e1a7d187eeab0dee1ee832c364151d142c7c0/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=a82e1a7d187eeab0dee1ee832c364151d142c7c0", "patch": "@@ -49,7 +49,7 @@ error_not_base_type (tree basetype, tree type)\n {\n   if (TREE_CODE (basetype) == FUNCTION_DECL)\n     basetype = DECL_CONTEXT (basetype);\n-  error (\"type `%T' is not a base type for type `%T'\", basetype, type);\n+  error (\"type %qT is not a base type for type %qT\", basetype, type);\n   return error_mark_node;\n }\n \n@@ -84,32 +84,32 @@ readonly_error (tree arg, const char* string, int soft)\n   if (TREE_CODE (arg) == COMPONENT_REF)\n     {\n       if (TYPE_READONLY (TREE_TYPE (TREE_OPERAND (arg, 0))))\n-        fmt = \"%s of data-member `%D' in read-only structure\";\n+        fmt = \"%s of data-member %qD in read-only structure\";\n       else\n-        fmt = \"%s of read-only data-member `%D'\";\n+        fmt = \"%s of read-only data-member %qD\";\n       (*fn) (fmt, string, TREE_OPERAND (arg, 1));\n     }\n   else if (TREE_CODE (arg) == VAR_DECL)\n     {\n       if (DECL_LANG_SPECIFIC (arg)\n \t  && DECL_IN_AGGR_P (arg)\n \t  && !TREE_STATIC (arg))\n-\tfmt = \"%s of constant field `%D'\";\n+\tfmt = \"%s of constant field %qD\";\n       else\n-\tfmt = \"%s of read-only variable `%D'\";\n+\tfmt = \"%s of read-only variable %qD\";\n       (*fn) (fmt, string, arg);\n     }\n   else if (TREE_CODE (arg) == PARM_DECL)\n-    (*fn) (\"%s of read-only parameter `%D'\", string, arg);\n+    (*fn) (\"%s of read-only parameter %qD\", string, arg);\n   else if (TREE_CODE (arg) == INDIRECT_REF\n            && TREE_CODE (TREE_TYPE (TREE_OPERAND (arg, 0))) == REFERENCE_TYPE\n            && (TREE_CODE (TREE_OPERAND (arg, 0)) == VAR_DECL\n                || TREE_CODE (TREE_OPERAND (arg, 0)) == PARM_DECL))\n-    (*fn) (\"%s of read-only reference `%D'\", string, TREE_OPERAND (arg, 0));\n+    (*fn) (\"%s of read-only reference %qD\", string, TREE_OPERAND (arg, 0));\n   else if (TREE_CODE (arg) == RESULT_DECL)\n-    (*fn) (\"%s of read-only named return value `%D'\", string, arg);\n+    (*fn) (\"%s of read-only named return value %qD\", string, arg);\n   else if (TREE_CODE (arg) == FUNCTION_DECL)\n-    (*fn) (\"%s of function `%D'\", string, arg);\n+    (*fn) (\"%s of function %qD\", string, arg);\n   else\n     (*fn) (\"%s of read-only location\", string);\n }\n@@ -289,30 +289,30 @@ abstract_virtuals_error (tree decl, tree type)\n \treturn 0;\n \n       if (TREE_CODE (decl) == VAR_DECL)\n-\tcp_error_at (\"cannot declare variable `%+D' to be of abstract \"\n-\t\t     \"type `%T'\", decl, type);\n+\tcp_error_at (\"cannot declare variable %q+D to be of abstract \"\n+\t\t     \"type %qT\", decl, type);\n       else if (TREE_CODE (decl) == PARM_DECL)\n-\tcp_error_at (\"cannot declare parameter `%+D' to be of abstract \"\n-\t\t     \"type `%T'\", decl, type);\n+\tcp_error_at (\"cannot declare parameter %q+D to be of abstract \"\n+\t\t     \"type %qT\", decl, type);\n       else if (TREE_CODE (decl) == FIELD_DECL)\n-\tcp_error_at (\"cannot declare field `%+D' to be of abstract \"\n-\t\t     \"type `%T'\", decl, type);\n+\tcp_error_at (\"cannot declare field %q+D to be of abstract \"\n+\t\t     \"type %qT\", decl, type);\n       else if (TREE_CODE (decl) == FUNCTION_DECL\n \t       && TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE)\n-\tcp_error_at (\"invalid abstract return type for member function `%+#D'\",\n+\tcp_error_at (\"invalid abstract return type for member function %q+#D\",\n \t\t     decl);\n       else if (TREE_CODE (decl) == FUNCTION_DECL)\n-\tcp_error_at (\"invalid abstract return type for function `%+#D'\", \n+\tcp_error_at (\"invalid abstract return type for function %q+#D\", \n \t\t     decl);\n       else if (TREE_CODE (decl) == IDENTIFIER_NODE)\n \t/* Here we do not have location information, so use error instead\n \t   of cp_error_at.  */\n-\terror (\"invalid abstract type `%T' for `%E'\", type, decl);\n+\terror (\"invalid abstract type %qT for %qE\", type, decl);\n       else\n-\tcp_error_at (\"invalid abstract type for `%+D'\", decl);\n+\tcp_error_at (\"invalid abstract type for %q+D\", decl);\n     }\n   else\n-    error (\"cannot allocate an object of abstract type `%T'\", type);\n+    error (\"cannot allocate an object of abstract type %qT\", type);\n \n   /* Only go through this once.  */\n   if (VEC_length (tree, pure))\n@@ -321,7 +321,7 @@ abstract_virtuals_error (tree decl, tree type)\n       tree fn;\n       \n       inform (\"%J  because the following virtual functions are pure \"\n-\t      \"within `%T':\", TYPE_MAIN_DECL (type), type);\n+\t      \"within %qT:\", TYPE_MAIN_DECL (type), type);\n \n       for (ix = 0; VEC_iterate (tree, pure, ix, fn); ix++)\n \tinform (\"%J\\t%#D\", fn, fn);\n@@ -331,7 +331,7 @@ abstract_virtuals_error (tree decl, tree type)\n       VEC_truncate (tree, pure, 0);\n     }\n   else\n-    inform (\"%J  since type `%T' has pure virtual functions\", \n+    inform (\"%J  since type %qT has pure virtual functions\", \n \t    TYPE_MAIN_DECL (type), type);\n \n   return 1;\n@@ -374,7 +374,7 @@ cxx_incomplete_type_diagnostic (tree value, tree type, int diag_type)\n \t\t     || TREE_CODE (value) == PARM_DECL\n \t\t     || TREE_CODE (value) == FIELD_DECL))\n     {\n-      (*p_msg_at) (\"`%D' has incomplete type\", value);\n+      (*p_msg_at) (\"%qD has incomplete type\", value);\n       decl = 1;\n     }\n  retry:\n@@ -386,15 +386,15 @@ cxx_incomplete_type_diagnostic (tree value, tree type, int diag_type)\n     case UNION_TYPE:\n     case ENUMERAL_TYPE:\n       if (!decl)\n-        (*p_msg) (\"invalid use of undefined type `%#T'\", type);\n+        (*p_msg) (\"invalid use of undefined type %q#T\", type);\n       if (!TYPE_TEMPLATE_INFO (type))\n-\t(*p_msg_at) (\"forward declaration of `%#T'\", type);\n+\t(*p_msg_at) (\"forward declaration of %q#T\", type);\n       else\n-\t(*p_msg_at) (\"declaration of `%#T'\", type);\n+\t(*p_msg_at) (\"declaration of %q#T\", type);\n       break;\n \n     case VOID_TYPE:\n-      (*p_msg) (\"invalid use of `%T'\", type);\n+      (*p_msg) (\"invalid use of %qT\", type);\n       break;\n \n     case ARRAY_TYPE:\n@@ -408,7 +408,7 @@ cxx_incomplete_type_diagnostic (tree value, tree type, int diag_type)\n \n     case OFFSET_TYPE:\n     bad_member:\n-      (*p_msg) (\"invalid use of member (did you forget the `&' ?)\");\n+      (*p_msg) (\"invalid use of member (did you forget the %<&%> ?)\");\n       break;\n \n     case TEMPLATE_TYPE_PARM:\n@@ -419,7 +419,8 @@ cxx_incomplete_type_diagnostic (tree value, tree type, int diag_type)\n       if (value && TREE_CODE (value) == COMPONENT_REF)\n         goto bad_member;\n       else if (value && TREE_CODE (value) == ADDR_EXPR)\n-        (*p_msg) (\"address of overloaded function with no contextual type information\");\n+        (*p_msg) (\"address of overloaded function with no contextual \"\n+                  \"type information\");\n       else if (value && TREE_CODE (value) == OVERLOAD)\n         (*p_msg) (\"overloaded function with no contextual type information\");\n       else\n@@ -577,7 +578,8 @@ store_init_value (tree decl, tree init)\n \n       if (TREE_CODE (init) == TREE_LIST)\n \t{\n-\t  error (\"constructor syntax used, but no constructor declared for type `%T'\", type);\n+\t  error (\"constructor syntax used, but no constructor declared \"\n+                 \"for type %qT\", type);\n \t  init = build_constructor (NULL_TREE, nreverse (init));\n \t}\n     }\n@@ -752,10 +754,10 @@ digest_init (tree type, tree init, tree* tail)\n \t}\n       while (BRACE_ENCLOSED_INITIALIZER_P (init))\n \t{\n-\t  pedwarn (\"braces around scalar initializer for `%T'\", type);\n+\t  pedwarn (\"braces around scalar initializer for %qT\", type);\n \t  init = CONSTRUCTOR_ELTS (init);\n \t  if (TREE_CHAIN (init))\n-\t    pedwarn (\"ignoring extra initializers for `%T'\", type);\n+\t    pedwarn (\"ignoring extra initializers for %qT\", type);\n \t  init = TREE_VALUE (init);\n \t}\n \n@@ -767,7 +769,7 @@ digest_init (tree type, tree init, tree* tail)\n \n   if (COMPLETE_TYPE_P (type) && ! TREE_CONSTANT (TYPE_SIZE (type)))\n     {\n-      error (\"variable-sized object of type `%T' may not be initialized\",\n+      error (\"variable-sized object of type %qT may not be initialized\",\n \t\ttype);\n       return error_mark_node;\n     }\n@@ -778,7 +780,8 @@ digest_init (tree type, tree init, tree* tail)\n \t{\n \t  if (TYPE_NON_AGGREGATE_CLASS (type))\n \t    {\n-\t      error (\"subobject of type `%T' must be initialized by constructor, not by `%E'\",\n+\t      error (\"subobject of type %qT must be initialized by \"\n+                     \"constructor, not by %qE\",\n \t\t     type, init);\n \t      return error_mark_node;\n \t    }\n@@ -1009,23 +1012,22 @@ process_init_constructor (tree type, tree init, tree* elts)\n \t      /* Warn when some struct elements are implicitly initialized.  */\n \t      if (warn_missing_field_initializers\n \t          && (!init || BRACE_ENCLOSED_INITIALIZER_P (init)))\n-\t\twarning (\"missing initializer for member `%D'\", field);\n+\t\twarning (\"missing initializer for member %qD\", field);\n \t    }\n \t  else\n \t    {\n \t      if (TREE_READONLY (field))\n-\t\terror (\"uninitialized const member `%D'\", field);\n+\t\terror (\"uninitialized const member %qD\", field);\n \t      else if (CLASSTYPE_READONLY_FIELDS_NEED_INIT (TREE_TYPE (field)))\n-\t\terror (\"member `%D' with uninitialized const fields\",\n-\t\t\t  field);\n+\t\terror (\"member %qD with uninitialized const fields\", field);\n \t      else if (TREE_CODE (TREE_TYPE (field)) == REFERENCE_TYPE)\n-\t\terror (\"member `%D' is uninitialized reference\", field);\n+\t\terror (\"member %qD is uninitialized reference\", field);\n \n \t      /* Warn when some struct elements are implicitly initialized\n \t\t to zero.  */\n \t      if (warn_missing_field_initializers\n \t          && (!init || BRACE_ENCLOSED_INITIALIZER_P (init)))\n-\t\twarning (\"missing initializer for member `%D'\", field);\n+\t\twarning (\"missing initializer for member %qD\", field);\n \n \t      if (! zero_init_p (TREE_TYPE (field)))\n \t\tnext1 = build_zero_init (TREE_TYPE (field),\n@@ -1078,16 +1080,16 @@ process_init_constructor (tree type, tree init, tree* elts)\n \t      if (temp)\n \t\tfield = temp, win = 1;\n \t      else\n-\t\terror (\"no field `%D' in union being initialized\",\n-\t\t\t  TREE_PURPOSE (tail));\n+\t\terror (\"no field %qD in union being initialized\",\n+                       TREE_PURPOSE (tail));\n \t    }\n \t  if (!win)\n \t    TREE_VALUE (tail) = error_mark_node;\n \t}\n       else if (field == 0)\n \t{\n-\t  error (\"union `%T' with no named members cannot be initialized\",\n-\t\t    type);\n+\t  error (\"union %qT with no named members cannot be initialized\",\n+                 type);\n \t  TREE_VALUE (tail) = error_mark_node;\n \t}\n \n@@ -1248,7 +1250,7 @@ build_x_arrow (tree expr)\n \n       if (last_rval == NULL_TREE)\n \t{\n-\t  error (\"base operand of `->' has non-pointer type `%T'\", type);\n+\t  error (\"base operand of %<->%> has non-pointer type %qT\", type);\n \t  return error_mark_node;\n \t}\n \n@@ -1272,9 +1274,9 @@ build_x_arrow (tree expr)\n     }\n \n   if (types_memoized)\n-    error (\"result of `operator->()' yields non-pointer result\");\n+    error (\"result of %<operator->()%> yields non-pointer result\");\n   else\n-    error (\"base operand of `->' is not a pointer\");\n+    error (\"base operand of %<->%> is not a pointer\");\n   return error_mark_node;\n }\n \n@@ -1298,16 +1300,18 @@ build_m_component_ref (tree datum, tree component)\n   ptrmem_type = TREE_TYPE (component);\n   if (!TYPE_PTR_TO_MEMBER_P (ptrmem_type))\n     {\n-      error (\"`%E' cannot be used as a member pointer, since it is of type `%T'\", \n+      error (\"%qE cannot be used as a member pointer, since it is of \"\n+             \"type %qT\", \n \t     component, ptrmem_type);\n       return error_mark_node;\n     }\n     \n   objtype = TYPE_MAIN_VARIANT (TREE_TYPE (datum));  \n   if (! IS_AGGR_TYPE (objtype))\n     {\n-      error (\"cannot apply member pointer `%E' to `%E', which is of non-aggregate type `%T'\",\n-\t\tcomponent, datum, objtype);\n+      error (\"cannot apply member pointer %qE to %qE, which is of \"\n+             \"non-aggregate type %qT\",\n+             component, datum, objtype);\n       return error_mark_node;\n     }\n \n@@ -1327,7 +1331,8 @@ build_m_component_ref (tree datum, tree component)\n       if (!binfo)\n \t{\n \tmismatch:\n-\t  error (\"pointer to member type `%T' incompatible with object type `%T'\",\n+\t  error (\"pointer to member type %qT incompatible with object \"\n+                 \"type %qT\",\n \t\t type, objtype);\n \t  return error_mark_node;\n \t}\n@@ -1549,10 +1554,10 @@ require_complete_eh_spec_types (tree fntype, tree decl)\n \t{\n \t  if (decl)\n \t    error\n-\t      (\"call to function `%D' which throws incomplete type `%#T'\",\n+\t      (\"call to function %qD which throws incomplete type %q#T\",\n \t       decl, type);\n \t  else\n-\t    error (\"call to function which throws incomplete type `%#T'\",\n+\t    error (\"call to function which throws incomplete type %q#T\",\n \t\t   decl);\n \t}\n     }"}, {"sha": "3ec98ce366fd24cacf916ec8b47b37df3b6cfe14", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a82e1a7d187eeab0dee1ee832c364151d142c7c0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a82e1a7d187eeab0dee1ee832c364151d142c7c0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a82e1a7d187eeab0dee1ee832c364151d142c7c0", "patch": "@@ -1,3 +1,9 @@\n+2004-10-10  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\t* g++.dg/overload/pmf1.C: Adjust quoting marks.\n+\t* g++.dg/warn/incomplete1.C: Likewise.\n+\t* g++.dg/template/qualttp20.C: Likewise.\n+\n 2004-10-10  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \tPR c/17881"}, {"sha": "b97f64e764bfc1c15c0912da9e2fd12354c4d66e", "filename": "gcc/testsuite/g++.dg/overload/pmf1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a82e1a7d187eeab0dee1ee832c364151d142c7c0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Fpmf1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a82e1a7d187eeab0dee1ee832c364151d142c7c0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Fpmf1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Fpmf1.C?ref=a82e1a7d187eeab0dee1ee832c364151d142c7c0", "patch": "@@ -17,5 +17,5 @@ void f (C) {}         // even though this would be well-formed\n \n int main ()\n {\n-  f (aip);  // { dg-error \"`A' is an inaccessible base of `B'\" \"\" }\n+  f (aip);  // { dg-error \"'A' is an inaccessible base of 'B'\" \"\" }\n }"}, {"sha": "5a9c61c4304ffcae3653306228d017fb622366a1", "filename": "gcc/testsuite/g++.dg/template/qualttp20.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a82e1a7d187eeab0dee1ee832c364151d142c7c0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fqualttp20.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a82e1a7d187eeab0dee1ee832c364151d142c7c0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fqualttp20.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fqualttp20.C?ref=a82e1a7d187eeab0dee1ee832c364151d142c7c0", "patch": "@@ -15,8 +15,8 @@ struct AS\n \n template <typename T> struct B1 : T\n {\n-  typedef typename T::L __restrict__ r;// { dg-error \"`__restrict__' qualifiers cannot\" \"\" }\n-  typedef typename T::myT __restrict__ p;// { dg-warning \"ignoring `__restrict__'\" \"\" { xfail *-*-* } }\n+  typedef typename T::L __restrict__ r;// { dg-error \"'__restrict__' qualifiers cannot\" \"\" }\n+  typedef typename T::myT __restrict__ p;// { dg-warning \"ignoring '__restrict__'\" \"\" { xfail *-*-* } }\n \n   // The following are DR 295 dependent\n   typedef typename T::myT volatile *myvolatile;"}, {"sha": "aed32a19ac4948c4fb152bdb14963394d8ab4b5e", "filename": "gcc/testsuite/g++.dg/warn/incomplete1.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a82e1a7d187eeab0dee1ee832c364151d142c7c0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fincomplete1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a82e1a7d187eeab0dee1ee832c364151d142c7c0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fincomplete1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fincomplete1.C?ref=a82e1a7d187eeab0dee1ee832c364151d142c7c0", "patch": "@@ -9,9 +9,9 @@\n // (But the deletion does not constitute an ill-formed program. So the\n // program should nevertheless compile, but it should give a warning.)\n \n-class A;\t// { dg-warning \"forward declaration of `struct A'\" \"\" }\n+class A;\t// { dg-warning \"forward declaration of 'struct A'\" \"\" }\n \n-A *a;\t\t// { dg-warning \"`a' has incomplete type\" \"\" }\n+A *a;\t\t// { dg-warning \"'a' has incomplete type\" \"\" }\n \n int\n main (int argc, char **argv)"}]}