{"sha": "76225d2ca77038233f5af5903ab0bd10aa78e611", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzYyMjVkMmNhNzcwMzgyMzNmNWFmNTkwM2FiMGJkMTBhYTc4ZTYxMQ==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2016-07-11T20:17:56Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2016-07-11T20:17:56Z"}, "message": "stl_vector.h (push_back(const value_type&)): Forward to _M_realloc_insert.\n\n2016-07-11  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n\n\t* include/bits/stl_vector.h (push_back(const value_type&)): Forward\n\tto _M_realloc_insert.\n\t(insert(const_iterator, value_type&&)): Forward to _M_insert_rval.\n\t(_M_realloc_insert): Declare new function.\n\t(_M_emplace_back_aux): Remove definition.\n\t* include/bits/vector.tcc (emplace_back(_Args...)):\n\tUse _M_realloc_insert.\n\t(insert(const_iterator, const value_type&)): Likewise.\n\t(_M_insert_rval, _M_emplace_aux): Likewise.\n\t(_M_emplace_back_aux): Remove declaration.\n\t(_M_realloc_insert): Define.\n\t* testsuite/23_containers/vector/modifiers/insert_vs_emplace.cc:\n\tAdjust expected results for emplacing an lvalue with reallocation.\n\nFrom-SVN: r238226", "tree": {"sha": "2cbe770d616acb22f925cbe299cd8edd0f6e5c08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2cbe770d616acb22f925cbe299cd8edd0f6e5c08"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/76225d2ca77038233f5af5903ab0bd10aa78e611", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76225d2ca77038233f5af5903ab0bd10aa78e611", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76225d2ca77038233f5af5903ab0bd10aa78e611", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76225d2ca77038233f5af5903ab0bd10aa78e611/comments", "author": null, "committer": null, "parents": [{"sha": "4368a420fb0679a0ef78fd0806dbdf7917cd948d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4368a420fb0679a0ef78fd0806dbdf7917cd948d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4368a420fb0679a0ef78fd0806dbdf7917cd948d"}], "stats": {"total": 303, "additions": 147, "deletions": 156}, "files": [{"sha": "1d0abe1c242ab193cc6a6913ac300306f061cc4c", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76225d2ca77038233f5af5903ab0bd10aa78e611/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76225d2ca77038233f5af5903ab0bd10aa78e611/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=76225d2ca77038233f5af5903ab0bd10aa78e611", "patch": "@@ -1,3 +1,19 @@\n+2016-07-11  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n+\n+\t* include/bits/stl_vector.h (push_back(const value_type&)): Forward\n+\tto _M_realloc_insert.\n+\t(insert(const_iterator, value_type&&)): Forward to _M_insert_rval.\n+\t(_M_realloc_insert): Declare new function.\n+\t(_M_emplace_back_aux): Remove definition.\n+\t* include/bits/vector.tcc (emplace_back(_Args...)):\n+\tUse _M_realloc_insert.\n+\t(insert(const_iterator, const value_type&)): Likewise.\n+\t(_M_insert_rval, _M_emplace_aux): Likewise.\n+\t(_M_emplace_back_aux): Remove declaration.\n+\t(_M_realloc_insert): Define.\n+\t* testsuite/23_containers/vector/modifiers/insert_vs_emplace.cc:\n+\tAdjust expected results for emplacing an lvalue with reallocation.\n+\n 2016-07-10  Ville Voutilainen  <ville.voutilainen@gmail.com>\n \n \tImplement std::optional."}, {"sha": "85abf4a3cc0642b6f416910353c48b571ebcefe6", "filename": "libstdc++-v3/include/bits/stl_vector.h", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76225d2ca77038233f5af5903ab0bd10aa78e611/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76225d2ca77038233f5af5903ab0bd10aa78e611/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h?ref=76225d2ca77038233f5af5903ab0bd10aa78e611", "patch": "@@ -946,11 +946,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t    ++this->_M_impl._M_finish;\n \t  }\n \telse\n-#if __cplusplus >= 201103L\n-\t  _M_emplace_back_aux(__x);\n-#else\n-\t  _M_insert_aux(end(), __x);\n-#endif\n+\t  _M_realloc_insert(end(), __x);\n       }\n \n #if __cplusplus >= 201103L\n@@ -1436,6 +1432,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       // Called by insert(p,x)\n       void\n       _M_insert_aux(iterator __position, const value_type& __x);\n+\n+      void\n+      _M_realloc_insert(iterator __position, const value_type& __x);\n #else\n       // A value_type object constructed with _Alloc_traits::construct()\n       // and destroyed with _Alloc_traits::destroy().\n@@ -1469,16 +1468,14 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \tvoid\n \t_M_insert_aux(iterator __position, _Arg&& __arg);\n \n+      template<typename... _Args>\n+\tvoid\n+\t_M_realloc_insert(iterator __position, _Args&&... __args);\n+\n       // Either move-construct at the end, or forward to _M_insert_aux.\n       iterator\n       _M_insert_rval(const_iterator __position, value_type&& __v);\n \n-      // Called by push_back(x) and emplace_back(args) when they need to\n-      // reallocate.\n-      template<typename... _Args>\n-\tvoid\n-\t_M_emplace_back_aux(_Args&&... __args);\n-\n       // Try to emplace at the end, otherwise forward to _M_insert_aux.\n       template<typename... _Args>\n \titerator"}, {"sha": "9717b74a9781f8f39bc6247060586e1641167159", "filename": "libstdc++-v3/include/bits/vector.tcc", "status": "modified", "additions": 120, "deletions": 141, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76225d2ca77038233f5af5903ab0bd10aa78e611/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76225d2ca77038233f5af5903ab0bd10aa78e611/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc?ref=76225d2ca77038233f5af5903ab0bd10aa78e611", "patch": "@@ -98,7 +98,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t    ++this->_M_impl._M_finish;\n \t  }\n \telse\n-\t  _M_emplace_back_aux(std::forward<_Args>(__args)...);\n+\t  _M_realloc_insert(end(), std::forward<_Args>(__args)...);\n       }\n #endif\n \n@@ -112,29 +112,32 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n #endif\n     {\n       const size_type __n = __position - begin();\n-      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage\n-\t  && __position == end())\n-\t{\n-\t  _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, __x);\n-\t  ++this->_M_impl._M_finish;\n-\t}\n-      else\n-\t{\n+      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)\n+\tif (__position == end())\n+\t  {\n+\t    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,\n+\t\t\t\t     __x);\n+\t    ++this->_M_impl._M_finish;\n+\t  }\n+\telse\n+\t  {\n #if __cplusplus >= 201103L\n-\t  const auto __pos = begin() + (__position - cbegin());\n-\t  if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)\n-\t    {\n-\t      // __x could be an existing element of this vector, so make a\n-\t      // copy of it before _M_insert_aux moves elements around.\n-\t      _Temporary_value __x_copy(this, __x);\n-\t      _M_insert_aux(__pos, std::move(__x_copy._M_val()));\n-\t    }\n-\t  else\n-\t    _M_insert_aux(__pos, __x);\n+\t    const auto __pos = begin() + (__position - cbegin());\n+\t    // __x could be an existing element of this vector, so make a\n+\t    // copy of it before _M_insert_aux moves elements around.\n+\t    _Temporary_value __x_copy(this, __x);\n+\t    _M_insert_aux(__pos, std::move(__x_copy._M_val()));\n #else\n \t    _M_insert_aux(__position, __x);\n #endif\n-\t}\n+\t  }\n+      else\n+#if __cplusplus >= 201103L\n+\t_M_realloc_insert(begin() + (__position - cbegin()), __x);\n+#else\n+\t_M_realloc_insert(__position, __x);\n+#endif\n+\n       return iterator(this->_M_impl._M_start + __n);\n     }\n \n@@ -304,15 +307,18 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     _M_insert_rval(const_iterator __position, value_type&& __v) -> iterator\n     {\n       const auto __n = __position - cbegin();\n-      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage\n-\t  && __position == cend())\n-\t{\n-\t  _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,\n-\t\t\t\t   std::move(__v));\n-\t  ++this->_M_impl._M_finish;\n-\t}\n+      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)\n+\tif (__position == cend())\n+\t  {\n+\t    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,\n+\t\t\t\t     std::move(__v));\n+\t    ++this->_M_impl._M_finish;\n+\t  }\n+\telse\n+\t  _M_insert_aux(begin() + __n, std::move(__v));\n       else\n-\t_M_insert_aux(begin() + __n, std::move(__v));\n+\t_M_realloc_insert(begin() + __n, std::move(__v));\n+\n       return iterator(this->_M_impl._M_start + __n);\n     }\n \n@@ -324,16 +330,24 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       -> iterator\n       {\n \tconst auto __n = __position - cbegin();\n-\tif (__position == cend())\n-\t  emplace_back(std::forward<_Args>(__args)...);\n+\tif (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)\n+\t  if (__position == cend())\n+\t    {\n+\t      _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,\n+\t\t\t\t       std::forward<_Args>(__args)...);\n+\t      ++this->_M_impl._M_finish;\n+\t    }\n+\t  else\n+\t    {\n+\t      // We need to construct a temporary because something in __args...\n+\t      // could alias one of the elements of the container and so we\n+\t      // need to use it before _M_insert_aux moves elements around.\n+\t      _Temporary_value __tmp(this, std::forward<_Args>(__args)...);\n+\t      _M_insert_aux(begin() + __n, std::move(__tmp._M_val()));\n+\t    }\n \telse\n-\t  {\n-\t    // We need to construct a temporary because something in __args...\n-\t    // could alias one of the elements of the container and so we\n-\t    // need to use it before _M_insert_aux moves elements around.\n-\t    _Temporary_value __tmp(this, std::forward<_Args>(__args)...);\n-\t    _M_insert_aux(begin() + __n, std::move(__tmp._M_val()));\n-\t  }\n+\t  _M_realloc_insert(begin() + __n, std::forward<_Args>(__args)...);\n+\n \treturn iterator(this->_M_impl._M_start + __n);\n       }\n \n@@ -349,123 +363,88 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     _M_insert_aux(iterator __position, const _Tp& __x)\n #endif\n     {\n-      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)\n-\t{\n-\t  _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,\n-\t\t\t           _GLIBCXX_MOVE(*(this->_M_impl._M_finish\n-\t\t\t\t                   - 1)));\n-\t  ++this->_M_impl._M_finish;\n+      _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,\n+\t\t\t       _GLIBCXX_MOVE(*(this->_M_impl._M_finish\n+\t\t\t\t\t       - 1)));\n+      ++this->_M_impl._M_finish;\n #if __cplusplus < 201103L\n-\t  _Tp __x_copy = __x;\n+      _Tp __x_copy = __x;\n #endif\n-\t  _GLIBCXX_MOVE_BACKWARD3(__position.base(),\n-\t\t\t\t  this->_M_impl._M_finish - 2,\n-\t\t\t\t  this->_M_impl._M_finish - 1);\n+      _GLIBCXX_MOVE_BACKWARD3(__position.base(),\n+\t\t\t      this->_M_impl._M_finish - 2,\n+\t\t\t      this->_M_impl._M_finish - 1);\n #if __cplusplus < 201103L\n-\t  *__position = __x_copy;\n-#else\n-\t  *__position = std::forward<_Arg>(__arg);\n-#endif\n-\t}\n-      else\n-\t{\n-\t  const size_type __len =\n-\t    _M_check_len(size_type(1), \"vector::_M_insert_aux\");\n-\t  const size_type __elems_before = __position - begin();\n-\t  pointer __new_start(this->_M_allocate(__len));\n-\t  pointer __new_finish(__new_start);\n-\t  __try\n-\t    {\n-\t      // The order of the three operations is dictated by the C++11\n-\t      // case, where the moves could alter a new element belonging\n-\t      // to the existing vector.  This is an issue only for callers\n-\t      // taking the element by lvalue ref (see last bullet of C++11\n-\t      // [res.on.arguments]).\n-\t      _Alloc_traits::construct(this->_M_impl,\n-\t\t                       __new_start + __elems_before,\n-#if __cplusplus >= 201103L\n-\t\t\t\t       std::forward<_Arg>(__arg));\n+      *__position = __x_copy;\n #else\n-\t                               __x);\n+      *__position = std::forward<_Arg>(__arg);\n #endif\n-\t      __new_finish = pointer();\n-\n-\t      __new_finish\n-\t\t= std::__uninitialized_move_if_noexcept_a\n-\t\t(this->_M_impl._M_start, __position.base(),\n-\t\t __new_start, _M_get_Tp_allocator());\n-\n-\t      ++__new_finish;\n-\n-\t      __new_finish\n-\t\t= std::__uninitialized_move_if_noexcept_a\n-\t\t(__position.base(), this->_M_impl._M_finish,\n-\t\t __new_finish, _M_get_Tp_allocator());\n-\t    }\n-          __catch(...)\n-\t    {\n-\t      if (!__new_finish)\n-\t\t_Alloc_traits::destroy(this->_M_impl,\n-\t\t                       __new_start + __elems_before);\n-\t      else\n-\t\tstd::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());\n-\t      _M_deallocate(__new_start, __len);\n-\t      __throw_exception_again;\n-\t    }\n-\t  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,\n-\t\t\t_M_get_Tp_allocator());\n-\t  _M_deallocate(this->_M_impl._M_start,\n-\t\t\tthis->_M_impl._M_end_of_storage\n-\t\t\t- this->_M_impl._M_start);\n-\t  this->_M_impl._M_start = __new_start;\n-\t  this->_M_impl._M_finish = __new_finish;\n-\t  this->_M_impl._M_end_of_storage = __new_start + __len;\n-\t}\n     }\n \n #if __cplusplus >= 201103L\n   template<typename _Tp, typename _Alloc>\n     template<typename... _Args>\n       void\n       vector<_Tp, _Alloc>::\n-      _M_emplace_back_aux(_Args&&... __args)\n-      {\n-\tconst size_type __len =\n-\t  _M_check_len(size_type(1), \"vector::_M_emplace_back_aux\");\n-\tpointer __new_start(this->_M_allocate(__len));\n-\tpointer __new_finish(__new_start);\n-\t__try\n-\t  {\n-\t    _Alloc_traits::construct(this->_M_impl, __new_start + size(),\n-\t\t\t\t     std::forward<_Args>(__args)...);\n-\t    __new_finish = pointer();\n+      _M_realloc_insert(iterator __position, _Args&&... __args)\n+#else\n+  template<typename _Tp, typename _Alloc>\n+    void\n+    vector<_Tp, _Alloc>::\n+    _M_realloc_insert(iterator __position, const _Tp& __x)\n+#endif\n+    {\n+      const size_type __len =\n+\t_M_check_len(size_type(1), \"vector::_M_realloc_insert\");\n+      const size_type __elems_before = __position - begin();\n+      pointer __new_start(this->_M_allocate(__len));\n+      pointer __new_finish(__new_start);\n+      __try\n+\t{\n+\t  // The order of the three operations is dictated by the C++11\n+\t  // case, where the moves could alter a new element belonging\n+\t  // to the existing vector.  This is an issue only for callers\n+\t  // taking the element by lvalue ref (see last bullet of C++11\n+\t  // [res.on.arguments]).\n+\t  _Alloc_traits::construct(this->_M_impl,\n+\t\t\t\t   __new_start + __elems_before,\n+#if __cplusplus >= 201103L\n+\t\t\t\t   std::forward<_Args>(__args)...);\n+#else\n+\t\t\t\t   __x);\n+#endif\n+\t  __new_finish = pointer();\n \n-\t    __new_finish\n-\t      = std::__uninitialized_move_if_noexcept_a\n-\t      (this->_M_impl._M_start, this->_M_impl._M_finish,\n-\t       __new_start, _M_get_Tp_allocator());\n+\t  __new_finish\n+\t    = std::__uninitialized_move_if_noexcept_a\n+\t    (this->_M_impl._M_start, __position.base(),\n+\t     __new_start, _M_get_Tp_allocator());\n \n-\t    ++__new_finish;\n-\t  }\n-\t__catch(...)\n-\t  {\n-\t    if (!__new_finish)\n-\t      _Alloc_traits::destroy(this->_M_impl, __new_start + size());\n-\t    else\n-\t      std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());\n-\t    _M_deallocate(__new_start, __len);\n-\t    __throw_exception_again;\n-\t  }\n-\tstd::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,\n-\t\t      _M_get_Tp_allocator());\n-\t_M_deallocate(this->_M_impl._M_start,\n-\t\t      this->_M_impl._M_end_of_storage\n-\t\t      - this->_M_impl._M_start);\n-\tthis->_M_impl._M_start = __new_start;\n-\tthis->_M_impl._M_finish = __new_finish;\n-\tthis->_M_impl._M_end_of_storage = __new_start + __len;\n-      }\n-#endif\n+\t  ++__new_finish;\n+\n+\t  __new_finish\n+\t    = std::__uninitialized_move_if_noexcept_a\n+\t    (__position.base(), this->_M_impl._M_finish,\n+\t     __new_finish, _M_get_Tp_allocator());\n+\t}\n+      __catch(...)\n+\t{\n+\t  if (!__new_finish)\n+\t    _Alloc_traits::destroy(this->_M_impl,\n+\t\t\t\t   __new_start + __elems_before);\n+\t  else\n+\t    std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());\n+\t  _M_deallocate(__new_start, __len);\n+\t  __throw_exception_again;\n+\t}\n+      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,\n+\t\t    _M_get_Tp_allocator());\n+      _M_deallocate(this->_M_impl._M_start,\n+\t\t    this->_M_impl._M_end_of_storage\n+\t\t    - this->_M_impl._M_start);\n+      this->_M_impl._M_start = __new_start;\n+      this->_M_impl._M_finish = __new_finish;\n+      this->_M_impl._M_end_of_storage = __new_start + __len;\n+    }\n \n   template<typename _Tp, typename _Alloc>\n     void\n@@ -520,7 +499,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t      pointer __new_finish(__new_start);\n \t      __try\n \t\t{\n-\t\t  // See _M_insert_aux above.\n+\t\t  // See _M_realloc_insert above.\n \t\t  std::__uninitialized_fill_n_a(__new_start + __elems_before,\n \t\t\t\t\t\t__n, __x,\n \t\t\t\t\t\t_M_get_Tp_allocator());"}, {"sha": "39a3f031b461a705eba5020b1ed5d9b7ebe6e5de", "filename": "libstdc++-v3/testsuite/23_containers/vector/modifiers/insert_vs_emplace.cc", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76225d2ca77038233f5af5903ab0bd10aa78e611/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fmodifiers%2Finsert_vs_emplace.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76225d2ca77038233f5af5903ab0bd10aa78e611/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fmodifiers%2Finsert_vs_emplace.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fmodifiers%2Finsert_vs_emplace.cc?ref=76225d2ca77038233f5af5903ab0bd10aa78e611", "patch": "@@ -223,8 +223,7 @@ test03()\n void\n test04()\n {\n-  const X::special expected_ins{ 0, 3, 1, 0, 3, 0 };\n-  const X::special expected_emp{ 0, 4, 1, 0, 4, 0 };\n+  const X::special expected{ 0, 3, 1, 0, 3, 0 };\n   X::special ins, emp;\n   {\n     std::vector<X> v;\n@@ -254,8 +253,8 @@ test04()\n     // std::cout << \"----\\n\";\n     emp = X::sp;\n   }\n-  VERIFY( ins == expected_ins );\n-  VERIFY( emp == expected_emp );\n+  VERIFY( ins == emp );\n+  VERIFY( ins == expected );\n }\n \n // insert vs emplace xvalue reallocation"}]}