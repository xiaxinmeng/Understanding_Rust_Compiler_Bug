{"sha": "b5f794b47bc09930e3a05b64de0890d315631436", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjVmNzk0YjQ3YmMwOTkzMGUzYTA1YjY0ZGUwODkwZDMxNTYzMTQzNg==", "commit": {"author": {"name": "Sudakshina Das", "email": "sudi.das@arm.com", "date": "2019-01-09T14:21:22Z"}, "committer": {"name": "Sudakshina Das", "email": "sudi@gcc.gnu.org", "date": "2019-01-09T14:21:22Z"}, "message": "[AArch64, 5/6] Enable BTI : Add new pass for BTI.\n\nThis patch is part of a series that enables ARMv8.5-A in GCC and\nadds Branch Target Identification Mechanism.\n\nThis patch adds a new pass called \"bti\" which is triggered by the command\nline argument -mbranch-protection whenever \"bti\" is turned on.\n\nThe pass iterates through the instructions and adds appropriated BTI\ninstructions based on the following:\n  * Add a new \"BTI C\" at the beginning of a function, unless its already\n    protected by a \"PACIASP\". We exempt the functions that are only called\n    directly.\n  * Add a new \"BTI J\" for every target of an indirect jump, jump table\n    targets, non-local goto targets or labels that might be referenced by\n    variables, constant pools, etc (NOTE_INSN_DELETED_LABEL).\n\nSince we have already changed the use of indirect tail calls to only x16 and\nx17, we do not have to use \"BTI JC\".\n(check patch 3/6).\n\n*** gcc/ChangeLog ***\n\n2018-01-09  Sudakshina Das  <sudi.das@arm.com>\n\t    Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n\n\t* config.gcc (aarch64*-*-*): Add aarch64-bti-insert.o.\n\t* gcc/config/aarch64/aarch64.h: Update comment for TRAMPOLINE_SIZE.\n\t* config/aarch64/aarch64.c (aarch64_asm_trampoline_template): Update\n\tif bti is enabled.\n\t* config/aarch64/aarch64-bti-insert.c: New file.\n\t* config/aarch64/aarch64-passes.def (INSERT_PASS_BEFORE): Insert bti\n\tpass.\n\t* config/aarch64/aarch64-protos.h (make_pass_insert_bti): Declare the\n\tnew bti pass.\n\t* config/aarch64/aarch64.md (unspecv): Add UNSPECV_BTI_NOARG,\n\tUNSPECV_BTI_C, UNSPECV_BTI_J and UNSPECV_BTI_JC.\n\t(bti_noarg, bti_j, bti_c, bti_jc): New define_insns.\n\t* config/aarch64/t-aarch64: Add rule for aarch64-bti-insert.o.\n\n*** gcc/testsuite/ChangeLog ***\n\n2018-01-09  Sudakshina Das  <sudi.das@arm.com>\n\n\t* gcc.target/aarch64/bti-1.c: New test.\n\t* gcc.target/aarch64/bti-2.c: New test.\n\t* gcc.target/aarch64/bti-3.c: New test.\n\t* lib/target-supports.exp\n\t(check_effective_target_aarch64_bti_hw): Add new check for BTI hw.\n\nCo-Authored-By: Ramana Radhakrishnan <ramana.radhakrishnan@arm.com>\n\nFrom-SVN: r267769", "tree": {"sha": "42d0229f90e50a750e4e74a9c304b1bfb86af2c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42d0229f90e50a750e4e74a9c304b1bfb86af2c3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5f794b47bc09930e3a05b64de0890d315631436", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5f794b47bc09930e3a05b64de0890d315631436", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5f794b47bc09930e3a05b64de0890d315631436", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5f794b47bc09930e3a05b64de0890d315631436/comments", "author": {"login": "sudakshina-das-arm", "id": 28538945, "node_id": "MDQ6VXNlcjI4NTM4OTQ1", "avatar_url": "https://avatars.githubusercontent.com/u/28538945?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sudakshina-das-arm", "html_url": "https://github.com/sudakshina-das-arm", "followers_url": "https://api.github.com/users/sudakshina-das-arm/followers", "following_url": "https://api.github.com/users/sudakshina-das-arm/following{/other_user}", "gists_url": "https://api.github.com/users/sudakshina-das-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/sudakshina-das-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sudakshina-das-arm/subscriptions", "organizations_url": "https://api.github.com/users/sudakshina-das-arm/orgs", "repos_url": "https://api.github.com/users/sudakshina-das-arm/repos", "events_url": "https://api.github.com/users/sudakshina-das-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/sudakshina-das-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "30afdf34a6d6a3d8d31fdd590ba60044cf0e004c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30afdf34a6d6a3d8d31fdd590ba60044cf0e004c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30afdf34a6d6a3d8d31fdd590ba60044cf0e004c"}], "stats": {"total": 497, "additions": 490, "deletions": 7}, "files": [{"sha": "e19b1aecf9b3854b4bdde33c63fde6d14d7bdd4d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5f794b47bc09930e3a05b64de0890d315631436/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5f794b47bc09930e3a05b64de0890d315631436/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b5f794b47bc09930e3a05b64de0890d315631436", "patch": "@@ -1,3 +1,20 @@\n+2018-01-09  Sudakshina Das  <sudi.das@arm.com>\n+\t    Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n+\n+\t* config.gcc (aarch64*-*-*): Add aarch64-bti-insert.o.\n+\t* gcc/config/aarch64/aarch64.h: Update comment for TRAMPOLINE_SIZE.\n+\t* config/aarch64/aarch64.c (aarch64_asm_trampoline_template): Update\n+\tif bti is enabled.\n+\t* config/aarch64/aarch64-bti-insert.c: New file.\n+\t* config/aarch64/aarch64-passes.def (INSERT_PASS_BEFORE): Insert bti\n+\tpass.\n+\t* config/aarch64/aarch64-protos.h (make_pass_insert_bti): Declare the\n+\tnew bti pass.\n+\t* config/aarch64/aarch64.md (unspecv): Add UNSPECV_BTI_NOARG,\n+\tUNSPECV_BTI_C, UNSPECV_BTI_J and UNSPECV_BTI_JC.\n+\t(bti_noarg, bti_j, bti_c, bti_jc): New define_insns.\n+\t* config/aarch64/t-aarch64: Add rule for aarch64-bti-insert.o.\n+\n 2018-01-09  Sudakshina Das  <sudi.das@arm.com>\n \n \t* config/aarch64/aarch64-protos.h (aarch64_bti_enabled): Declare."}, {"sha": "f7ddb120ee2522110e534b519450038512689066", "filename": "gcc/config.gcc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5f794b47bc09930e3a05b64de0890d315631436/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5f794b47bc09930e3a05b64de0890d315631436/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=b5f794b47bc09930e3a05b64de0890d315631436", "patch": "@@ -318,7 +318,7 @@ aarch64*-*-*)\n \tc_target_objs=\"aarch64-c.o\"\n \tcxx_target_objs=\"aarch64-c.o\"\n \td_target_objs=\"aarch64-d.o\"\n-\textra_objs=\"aarch64-builtins.o aarch-common.o cortex-a57-fma-steering.o aarch64-speculation.o falkor-tag-collision-avoidance.o\"\n+\textra_objs=\"aarch64-builtins.o aarch-common.o cortex-a57-fma-steering.o aarch64-speculation.o falkor-tag-collision-avoidance.o aarch64-bti-insert.o\"\n \ttarget_gtfiles=\"\\$(srcdir)/config/aarch64/aarch64-builtins.c\"\n \ttarget_has_targetm_common=yes\n \t;;"}, {"sha": "e519a0f0ac1751f4268e03381757bc1a10c13144", "filename": "gcc/config/aarch64/aarch64-bti-insert.c", "status": "added", "additions": 235, "deletions": 0, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5f794b47bc09930e3a05b64de0890d315631436/gcc%2Fconfig%2Faarch64%2Faarch64-bti-insert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5f794b47bc09930e3a05b64de0890d315631436/gcc%2Fconfig%2Faarch64%2Faarch64-bti-insert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-bti-insert.c?ref=b5f794b47bc09930e3a05b64de0890d315631436", "patch": "@@ -0,0 +1,235 @@\n+/* Branch Target Identification for AArch64 architecture.\n+   Copyright (C) 2019 Free Software Foundation, Inc.\n+   Contributed by Arm Ltd.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#define IN_TARGET_CODE 1\n+\n+#include \"config.h\"\n+#define INCLUDE_STRING\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"target.h\"\n+#include \"rtl.h\"\n+#include \"tree.h\"\n+#include \"memmodel.h\"\n+#include \"gimple.h\"\n+#include \"tm_p.h\"\n+#include \"stringpool.h\"\n+#include \"attribs.h\"\n+#include \"emit-rtl.h\"\n+#include \"gimplify.h\"\n+#include \"gimple-iterator.h\"\n+#include \"dumpfile.h\"\n+#include \"rtl-iter.h\"\n+#include \"cfgrtl.h\"\n+#include \"tree-pass.h\"\n+#include \"cgraph.h\"\n+\n+/* This pass enables the support for Branch Target Identification Mechanism\n+   for AArch64.  This is a new security feature introduced in ARMv8.5-A\n+   archtitecture.  A BTI instruction is used to guard against the execution\n+   of instructions which are not the intended target of an indirect branch.\n+\n+   Outside of a guarded memory region, a BTI instruction executes as a NOP.\n+   Within a guarded memory region any target of an indirect branch must be\n+   a compatible BTI or BRK, HLT, PACIASP, PACIBASP instruction (even if the\n+   branch is triggered in a non-guarded memory region).  An incompatibility\n+   generates a Branch Target Exception.\n+\n+   The compatibility of the BTI instruction is as follows:\n+   BTI j : Can be a target of any indirect jump (BR Xn).\n+   BTI c : Can be a target of any indirect call (BLR Xn and BR X16/X17).\n+   BTI jc: Can be a target of any indirect call or indirect jump.\n+   BTI   : Can not be a target of any indirect call or indirect jump.\n+\n+  In order to enable this mechanism, this pass iterates through the\n+  control flow of the code and adds appropriate BTI instructions :\n+  * Add a new \"BTI C\" at the beginning of a function, unless its already\n+    protected by a \"PACIASP/PACIBSP\".  We exempt the functions that are only\n+    called directly.\n+  * Add a new \"BTI J\" for every target of an indirect jump, jump table targets,\n+    non-local goto targets or labels that might be referenced by variables,\n+    constant pools, etc (NOTE_INSN_DELETED_LABEL)\n+\n+  Since we have already changed the use of indirect tail calls to only x16\n+  and x17, we do not have to use \"BTI JC\".\n+\n+  This pass is triggered by the command line option -mbranch-protection=bti or\n+  -mbranch-protection=standard.  Since all the BTI instructions are in the HINT\n+  space, this pass does not require any minimum architecture version.  */\n+\n+namespace {\n+\n+const pass_data pass_data_insert_bti =\n+{\n+  RTL_PASS, /* type.  */\n+  \"bti\", /* name.  */\n+  OPTGROUP_NONE, /* optinfo_flags.  */\n+  TV_MACH_DEP, /* tv_id.  */\n+  0, /* properties_required.  */\n+  0, /* properties_provided.  */\n+  0, /* properties_destroyed.  */\n+  0, /* todo_flags_start.  */\n+  0, /* todo_flags_finish.  */\n+};\n+\n+/* Check if X (or any sub-rtx of X) is a PACIASP/PACIBSP instruction.  */\n+static bool\n+aarch64_pac_insn_p (rtx x)\n+{\n+  if (!INSN_P (x))\n+    return x;\n+\n+  subrtx_var_iterator::array_type array;\n+  FOR_EACH_SUBRTX_VAR (iter, array, PATTERN (x), ALL)\n+    {\n+      rtx sub = *iter;\n+      if (sub && GET_CODE (sub) == UNSPEC)\n+\t{\n+\t  int unspec_val = XINT (sub, 1);\n+\t  switch (unspec_val)\n+\t    {\n+\t    case UNSPEC_PACISP:\n+\t      return true;\n+\n+\t    default:\n+\t      return false;\n+\t    }\n+\t  iter.skip_subrtxes ();\n+\t}\n+    }\n+  return false;\n+}\n+\n+/* Insert the BTI instruction.  */\n+/* This is implemented as a late RTL pass that runs before branch\n+   shortening and does the following.  */\n+static unsigned int\n+rest_of_insert_bti (void)\n+{\n+  timevar_push (TV_MACH_DEP);\n+\n+  rtx bti_insn;\n+  rtx_insn *insn;\n+  basic_block bb;\n+\n+  /* Since a Branch Target Exception can only be triggered by an indirect call,\n+     we exempt function that are only called directly.  We also exempt\n+     functions that are already protected by Return Address Signing (PACIASP/\n+     PACIBSP).  For all other cases insert a BTI C at the beginning of the\n+     function.  */\n+  if (!cgraph_node::get (cfun->decl)->only_called_directly_p ())\n+    {\n+      bb = ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb;\n+      insn = BB_HEAD (bb);\n+      if (!aarch64_pac_insn_p (get_first_nonnote_insn ()))\n+\t{\n+\t  bti_insn = gen_bti_c ();\n+\t  emit_insn_before (bti_insn, insn);\n+\t}\n+    }\n+\n+  bb = 0;\n+  FOR_EACH_BB_FN (bb, cfun)\n+    {\n+      for (insn = BB_HEAD (bb); insn != NEXT_INSN (BB_END (bb));\n+\t   insn = NEXT_INSN (insn))\n+\t{\n+\t  /* If a label is marked to be preserved or can be a non-local goto\n+\t     target, it must be protected with a BTI J.  The same applies to\n+\t     NOTE_INSN_DELETED_LABEL since they are basically labels that might\n+\t     be referenced via variables or constant pool.  */\n+\t  if ((LABEL_P (insn)\n+\t       && (LABEL_PRESERVE_P (insn)\n+\t\t   || bb->flags & BB_NON_LOCAL_GOTO_TARGET))\n+\t      || (NOTE_P (insn)\n+\t\t  && NOTE_KIND (insn) == NOTE_INSN_DELETED_LABEL))\n+\t    {\n+\t      bti_insn = gen_bti_j ();\n+\t      emit_insn_after (bti_insn, insn);\n+\t      continue;\n+\t    }\n+\n+\t  /* There could still be more labels that are valid targets of a\n+\t     BTI J instuction.  To find them we start looking through the\n+\t     JUMP_INSN.  If it jumps to a jump table, then we find all labels\n+\t     of the jump table to protect with a BTI J.  */\n+\t  if (JUMP_P (insn))\n+\t    {\n+\t      rtx_jump_table_data *table;\n+\t      if (tablejump_p (insn, NULL, &table))\n+\t\t{\n+\t\t  rtvec vec = table->get_labels ();\n+\t\t  int j;\n+\t\t  rtx_insn *label;\n+\n+\t\t  for (j = GET_NUM_ELEM (vec) - 1; j >= 0; --j)\n+\t\t    {\n+\t\t      label = as_a <rtx_insn *> (XEXP (RTVEC_ELT (vec, j), 0));\n+\t\t      bti_insn = gen_bti_j ();\n+\t\t      emit_insn_after (bti_insn, label);\n+\t\t    }\n+\t\t}\n+\t    }\n+\n+\t  /* Also look for calls to setjmp () which would be marked with\n+\t     REG_SETJMP note and put a BTI J after.  This is where longjump ()\n+\t     will return.  */\n+\t  if (CALL_P (insn) && (find_reg_note (insn, REG_SETJMP, NULL)))\n+\t    {\n+\t      bti_insn = gen_bti_j ();\n+\t      emit_insn_after (bti_insn, insn);\n+\t      continue;\n+\t    }\n+\t}\n+    }\n+\n+  timevar_pop (TV_MACH_DEP);\n+  return 0;\n+}\n+\n+\n+class pass_insert_bti : public rtl_opt_pass\n+{\n+public:\n+  pass_insert_bti (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_insert_bti, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *)\n+    {\n+      return aarch64_bti_enabled ();\n+    }\n+\n+  virtual unsigned int execute (function *)\n+    {\n+      return rest_of_insert_bti ();\n+    }\n+\n+}; // class pass_insert_bti\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_insert_bti (gcc::context *ctxt)\n+{\n+  return new pass_insert_bti (ctxt);\n+}"}, {"sha": "12d1ad6ba39dbaa6a0278b13a67f5421d434b3e3", "filename": "gcc/config/aarch64/aarch64-passes.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5f794b47bc09930e3a05b64de0890d315631436/gcc%2Fconfig%2Faarch64%2Faarch64-passes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5f794b47bc09930e3a05b64de0890d315631436/gcc%2Fconfig%2Faarch64%2Faarch64-passes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-passes.def?ref=b5f794b47bc09930e3a05b64de0890d315631436", "patch": "@@ -21,3 +21,4 @@\n INSERT_PASS_AFTER (pass_regrename, 1, pass_fma_steering);\n INSERT_PASS_BEFORE (pass_reorder_blocks, 1, pass_track_speculation);\n INSERT_PASS_AFTER (pass_machine_reorg, 1, pass_tag_collision_avoidance);\n+INSERT_PASS_BEFORE (pass_shorten_branches, 1, pass_insert_bti);"}, {"sha": "b035e35f33ba86ceb7b0255e7e0e9ad2d69bf829", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5f794b47bc09930e3a05b64de0890d315631436/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5f794b47bc09930e3a05b64de0890d315631436/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=b5f794b47bc09930e3a05b64de0890d315631436", "patch": "@@ -633,6 +633,7 @@ extern void aarch64_d_target_versions (void);\n rtl_opt_pass *make_pass_fma_steering (gcc::context *);\n rtl_opt_pass *make_pass_track_speculation (gcc::context *);\n rtl_opt_pass *make_pass_tag_collision_avoidance (gcc::context *);\n+rtl_opt_pass *make_pass_insert_bti (gcc::context *ctxt);\n \n poly_uint64 aarch64_regmode_natural_size (machine_mode);\n "}, {"sha": "d5e140dd08a85457eef8ad2a1ee7717f5cbc76ac", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5f794b47bc09930e3a05b64de0890d315631436/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5f794b47bc09930e3a05b64de0890d315631436/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=b5f794b47bc09930e3a05b64de0890d315631436", "patch": "@@ -8250,18 +8250,36 @@ aarch64_return_addr (int count, rtx frame ATTRIBUTE_UNUSED)\n static void\n aarch64_asm_trampoline_template (FILE *f)\n {\n+  int offset1 = 16;\n+  int offset2 = 20;\n+\n+  if (aarch64_bti_enabled ())\n+    {\n+      asm_fprintf (f, \"\\thint\\t34 // bti c\\n\");\n+      offset1 -= 4;\n+      offset2 -= 4;\n+    }\n+\n   if (TARGET_ILP32)\n     {\n-      asm_fprintf (f, \"\\tldr\\tw%d, .+16\\n\", IP1_REGNUM - R0_REGNUM);\n-      asm_fprintf (f, \"\\tldr\\tw%d, .+16\\n\", STATIC_CHAIN_REGNUM - R0_REGNUM);\n+      asm_fprintf (f, \"\\tldr\\tw%d, .+%d\\n\", IP1_REGNUM - R0_REGNUM, offset1);\n+      asm_fprintf (f, \"\\tldr\\tw%d, .+%d\\n\", STATIC_CHAIN_REGNUM - R0_REGNUM,\n+\t\t   offset1);\n     }\n   else\n     {\n-      asm_fprintf (f, \"\\tldr\\t%s, .+16\\n\", reg_names [IP1_REGNUM]);\n-      asm_fprintf (f, \"\\tldr\\t%s, .+20\\n\", reg_names [STATIC_CHAIN_REGNUM]);\n+      asm_fprintf (f, \"\\tldr\\t%s, .+%d\\n\", reg_names [IP1_REGNUM], offset1);\n+      asm_fprintf (f, \"\\tldr\\t%s, .+%d\\n\", reg_names [STATIC_CHAIN_REGNUM],\n+\t\t   offset2);\n     }\n   asm_fprintf (f, \"\\tbr\\t%s\\n\", reg_names [IP1_REGNUM]);\n-  assemble_aligned_integer (4, const0_rtx);\n+\n+  /* The trampoline needs an extra padding instruction.  In case if BTI is\n+     enabled the padding instruction is replaced by the BTI instruction at\n+     the beginning.  */\n+  if (!aarch64_bti_enabled ())\n+    assemble_aligned_integer (4, const0_rtx);\n+\n   assemble_aligned_integer (POINTER_BYTES, const0_rtx);\n   assemble_aligned_integer (POINTER_BYTES, const0_rtx);\n }"}, {"sha": "63f3be7fff47675634e9c037415da54b050fba34", "filename": "gcc/config/aarch64/aarch64.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5f794b47bc09930e3a05b64de0890d315631436/gcc%2Fconfig%2Faarch64%2Faarch64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5f794b47bc09930e3a05b64de0890d315631436/gcc%2Fconfig%2Faarch64%2Faarch64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.h?ref=b5f794b47bc09930e3a05b64de0890d315631436", "patch": "@@ -918,7 +918,7 @@ typedef struct\n \n #define RETURN_ADDR_RTX aarch64_return_addr\n \n-/* 3 insns + padding + 2 pointer-sized entries.  */\n+/* BTI c + 3 insns + 2 pointer-sized entries.  */\n #define TRAMPOLINE_SIZE\t(TARGET_ILP32 ? 24 : 32)\n \n /* Trampolines contain dwords, so must be dword aligned.  */"}, {"sha": "513aec1872a7a5d29233d0bcb0bd1331d306eaaf", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5f794b47bc09930e3a05b64de0890d315631436/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5f794b47bc09930e3a05b64de0890d315631436/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=b5f794b47bc09930e3a05b64de0890d315631436", "patch": "@@ -237,6 +237,10 @@\n     UNSPECV_BLOCKAGE\t\t; Represent a blockage\n     UNSPECV_PROBE_STACK_RANGE\t; Represent stack range probing.\n     UNSPECV_SPECULATION_BARRIER ; Represent speculation barrier.\n+    UNSPECV_BTI_NOARG\t\t; Represent BTI.\n+    UNSPECV_BTI_C\t\t; Represent BTI c.\n+    UNSPECV_BTI_J\t\t; Represent BTI j.\n+    UNSPECV_BTI_JC\t\t; Represent BTI jc.\n   ]\n )\n \n@@ -6939,6 +6943,35 @@\n   [(set_attr \"type\" \"csel\")]\n )\n \n+;; BTI <target> instructions\n+(define_insn \"bti_noarg\"\n+  [(unspec_volatile [(const_int 0)] UNSPECV_BTI_NOARG)]\n+  \"\"\n+  \"hint\\t32 // bti\"\n+  [(set_attr \"type\" \"no_insn\")]\n+)\n+\n+(define_insn \"bti_c\"\n+  [(unspec_volatile [(const_int 0)] UNSPECV_BTI_C)]\n+  \"\"\n+  \"hint\\t34 // bti c\"\n+  [(set_attr \"type\" \"no_insn\")]\n+)\n+\n+(define_insn \"bti_j\"\n+  [(unspec_volatile [(const_int 0)] UNSPECV_BTI_J)]\n+  \"\"\n+  \"hint\\t36 // bti j\"\n+  [(set_attr \"type\" \"no_insn\")]\n+)\n+\n+(define_insn \"bti_jc\"\n+  [(unspec_volatile [(const_int 0)] UNSPECV_BTI_JC)]\n+  \"\"\n+  \"hint\\t38 // bti jc\"\n+  [(set_attr \"type\" \"no_insn\")]\n+)\n+\n ;; Helper for aarch64.c code.\n (define_expand \"set_clobber_cc\"\n   [(parallel [(set (match_operand 0)"}, {"sha": "ee471f8983f2afb1f1198a60c95d9df662fbad90", "filename": "gcc/config/aarch64/t-aarch64", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5f794b47bc09930e3a05b64de0890d315631436/gcc%2Fconfig%2Faarch64%2Ft-aarch64", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5f794b47bc09930e3a05b64de0890d315631436/gcc%2Fconfig%2Faarch64%2Ft-aarch64", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Ft-aarch64?ref=b5f794b47bc09930e3a05b64de0890d315631436", "patch": "@@ -91,6 +91,15 @@ falkor-tag-collision-avoidance.o: \\\n \t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n \t\t$(srcdir)/config/aarch64/falkor-tag-collision-avoidance.c\n \n+aarch64-bti-insert.o: $(srcdir)/config/aarch64/aarch64-bti-insert.c \\\n+    $(CONFIG_H) $(SYSTEM_H) $(TM_H) $(REGS_H) insn-config.h $(RTL_BASE_H) \\\n+    dominance.h cfg.h cfganal.h $(BASIC_BLOCK_H) $(INSN_ATTR_H) $(RECOG_H) \\\n+    output.h hash-map.h $(DF_H) $(OBSTACK_H) $(TARGET_H) $(RTL_H) \\\n+    $(CONTEXT_H) $(TREE_PASS_H) regrename.h \\\n+    $(srcdir)/config/aarch64/aarch64-protos.h\n+\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n+\t\t$(srcdir)/config/aarch64/aarch64-bti-insert.c\n+\n comma=,\n MULTILIB_OPTIONS    = $(subst $(comma),/, $(patsubst %, mabi=%, $(subst $(comma),$(comma)mabi=,$(TM_MULTILIB_CONFIG))))\n MULTILIB_DIRNAMES   = $(subst $(comma), ,$(TM_MULTILIB_CONFIG))"}, {"sha": "b55a7abd83e196aa7205360f748b8f36e3d45be9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5f794b47bc09930e3a05b64de0890d315631436/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5f794b47bc09930e3a05b64de0890d315631436/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b5f794b47bc09930e3a05b64de0890d315631436", "patch": "@@ -1,3 +1,11 @@\n+2018-01-09  Sudakshina Das  <sudi.das@arm.com>\n+\n+\t* gcc.target/aarch64/bti-1.c: New test.\n+\t* gcc.target/aarch64/bti-2.c: New test.\n+\t* gcc.target/aarch64/bti-3.c: New test.\n+\t* lib/target-supports.exp\n+\t(check_effective_target_aarch64_bti_hw): Add new check for BTI hw.\n+\n 2018-01-09  Sudakshina Das  <sudi.das@arm.com>\n \n \t* gcc.target/aarch64/test_frame_17.c: Update to check for EP0_REGNUM"}, {"sha": "575d01a5411a19dabcdb56b777e5d87d9703a848", "filename": "gcc/testsuite/gcc.target/aarch64/bti-1.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5f794b47bc09930e3a05b64de0890d315631436/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fbti-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5f794b47bc09930e3a05b64de0890d315631436/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fbti-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fbti-1.c?ref=b5f794b47bc09930e3a05b64de0890d315631436", "patch": "@@ -0,0 +1,59 @@\n+/* { dg-do compile } */\n+/* -Os to create jump table.  */\n+/* { dg-options \"-Os -mbranch-protection=standard\" } */\n+\n+extern int f1 (void);\n+extern int f2 (void);\n+extern int f3 (void);\n+extern int f4 (void);\n+extern int f5 (void);\n+extern int f6 (void);\n+extern int f7 (void);\n+extern int f8 (void);\n+extern int f9 (void);\n+extern int f10 (void);\n+\n+int (*ptr) (void);\n+\n+int\n+f_jump_table (int y, int n)\n+{\n+  int i;\n+  for (i = 0; i < n ;i ++)\n+  {\n+    switch (y)\n+      {\n+      case 0 : ptr = f1; break;\n+      case 1 : ptr = f2; break;\n+      case 2 : ptr = f3; break;\n+      case 3 : ptr = f4; break;\n+      case 4 : ptr = f5; break;\n+      case 5 : ptr = f6; break;\n+      case 6 : ptr = f7; break;\n+      case 7 : ptr = f8; break;\n+      case 8 : ptr = f9; break;\n+      case 9 : ptr = f10; break;\n+      default: break;\n+      }\n+    y += ptr ();\n+  }\n+  return (y == 0)? y+1:4;\n+}\n+/* f_jump_table should have PACIASP and AUTIASP.  */\n+/* { dg-final { scan-assembler-times \"hint\\t25\" 1 } } */\n+/* { dg-final { scan-assembler-times \"hint\\t29\" 1 } } */\n+\n+int\n+f_label_address ()\n+{\n+  static void * addr = &&lab1;\n+  goto *addr;\n+lab1:\n+  addr = &&lab2;\n+  return 1;\n+lab2:\n+  addr = &&lab1;\n+  return 2;\n+}\n+/* { dg-final { scan-assembler-times \"hint\\t34\" 1 } } */\n+/* { dg-final { scan-assembler-times \"hint\\t36\" 12 } } */"}, {"sha": "e50eef15c8936d00716c582e90b235add5da9136", "filename": "gcc/testsuite/gcc.target/aarch64/bti-2.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5f794b47bc09930e3a05b64de0890d315631436/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fbti-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5f794b47bc09930e3a05b64de0890d315631436/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fbti-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fbti-2.c?ref=b5f794b47bc09930e3a05b64de0890d315631436", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target aarch64_bti_hw } */\n+/* { dg-options \"-mbranch-protection=standard\" } */\n+\n+#include<stdio.h>\n+\n+typedef int FP (int);\n+\n+int\n+f1 (FP fp, int n)\n+{\n+  return (fp) (n);\n+}\n+\n+int\n+f2 (int n, FP fp)\n+{\n+  return (fp) (n);\n+}\n+\n+int __attribute__ ((noinline))\n+func (int x)\n+{\n+  return x+1;\n+}\n+\n+int main ()\n+{\n+  int s = 0;\n+  s += f1 (func, 10);\n+  s += f2 (s, func);\n+  printf (\"S: %d\\n\", s);\n+  return !(s == 23);\n+}"}, {"sha": "97cf5d37f42b9313da75481c2ceac884735ac995", "filename": "gcc/testsuite/gcc.target/aarch64/bti-3.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5f794b47bc09930e3a05b64de0890d315631436/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fbti-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5f794b47bc09930e3a05b64de0890d315631436/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fbti-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fbti-3.c?ref=b5f794b47bc09930e3a05b64de0890d315631436", "patch": "@@ -0,0 +1,52 @@\n+/* This is a copy of gcc/testsuite/gcc.c-torture/execute/pr56982.c to test the\n+   setjmp case of the bti pass.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target aarch64_bti_hw } */\n+/* { dg-options \"--save-temps -mbranch-protection=standard\" } */\n+\n+#include <setjmp.h>\n+\n+extern void abort (void);\n+extern void exit (int);\n+\n+static jmp_buf env;\n+\n+void baz (void)\n+{\n+  __asm__ volatile (\"\" : : : \"memory\");\n+}\n+\n+static inline int g(int x)\n+{\n+    if (x)\n+    {\n+        baz();\n+        return 0;\n+    }\n+    else\n+    {\n+        baz();\n+        return 1;\n+    }\n+}\n+\n+int f(int *e)\n+{\n+    if (*e)\n+      return 1;\n+\n+    int x = setjmp(env);\n+    int n = g(x);\n+    if (n == 0)\n+      exit(0);\n+    if (x)\n+      abort();\n+    longjmp(env, 42);\n+}\n+/* { dg-final { scan-assembler \"hint\\t36\" } } */\n+\n+int main(int argc, char** argv)\n+{\n+    int v = 0;\n+    return f(&v);\n+}"}, {"sha": "d694f495493fa014b053f406529d6bef4d67c46e", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5f794b47bc09930e3a05b64de0890d315631436/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5f794b47bc09930e3a05b64de0890d315631436/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=b5f794b47bc09930e3a05b64de0890d315631436", "patch": "@@ -4313,6 +4313,22 @@ proc check_effective_target_arm_neonv2_hw { } {\n     } [add_options_for_arm_neonv2 \"\"]]\n }\n \n+# ID_AA64PFR1_EL1.BT using bits[3:0] == 1 implies BTI implimented.\n+proc check_effective_target_aarch64_bti_hw { } {\n+    if { ![istarget aarch64*-*-*] } {\n+\treturn 0\n+    }\n+    return [check_runtime aarch64_bti_hw_available {\n+\tint\n+\tmain (void)\n+\t{\n+\t  int a;\n+\t  asm volatile (\"mrs %0, id_aa64pfr1_el1\" : \"=r\" (a));\n+\t  return !((a & 0xf) == 1);\n+\t}\n+    } \"-O2\" ]\n+}\n+\n # Return 1 if the target supports the ARMv8.1 Adv.SIMD extension, 0\n # otherwise.  The test is valid for AArch64 and ARM.  Record the command\n # line options needed."}]}