{"sha": "e3417fcd0cb24c81bdcc3e8a36753fc0126148eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTM0MTdmY2QwY2IyNGM4MWJkY2MzZThhMzY3NTNmYzAxMjYxNDhlYg==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1995-02-18T22:06:40Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1995-02-18T22:06:40Z"}, "message": "57 Cygnus<->FSF merge\n\nFrom-SVN: r8971", "tree": {"sha": "47c9aa6e34fc108c9bf87eabafaa3e18e060d8fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/47c9aa6e34fc108c9bf87eabafaa3e18e060d8fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e3417fcd0cb24c81bdcc3e8a36753fc0126148eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3417fcd0cb24c81bdcc3e8a36753fc0126148eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3417fcd0cb24c81bdcc3e8a36753fc0126148eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3417fcd0cb24c81bdcc3e8a36753fc0126148eb/comments", "author": null, "committer": null, "parents": [{"sha": "71a810956e321407dfead626fc34d8c58b739a17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71a810956e321407dfead626fc34d8c58b739a17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71a810956e321407dfead626fc34d8c58b739a17"}], "stats": {"total": 351, "additions": 221, "deletions": 130}, "files": [{"sha": "df22c23039381493e67c2e50594147af25d61fc7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3417fcd0cb24c81bdcc3e8a36753fc0126148eb/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3417fcd0cb24c81bdcc3e8a36753fc0126148eb/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e3417fcd0cb24c81bdcc3e8a36753fc0126148eb", "patch": "@@ -10,6 +10,59 @@ Wed Jan 25 15:02:09 1995  David S. Miller  (davem@nadzieja.rutgers.edu)\n \t* class.c (instantiate_type): Change error message text.\n \t* typeck2.c (store_init_value): Likewise.\n \n+Fri Feb 17 15:31:31 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* decl2.c (reparse_decl_as_expr): Support being called without a\n+\ttype argument.\n+\n+\t* parse.y (primary): Add '(' expr_or_declarator ')'.  Adds 4 r/r\n+\tconflicts.  Sigh.\n+\n+Fri Feb 17 12:02:06 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* parse.y (template_def, fndef, fn.def1, return_init, condition,\n+\tinitdcl0, initdcl, notype_initdcl0, nomods_initdcl0,\n+\tcomponent_decl_1, after_type_component_declarator0,\n+\tnotype_component_declarator0, after_type_component_declarator,\n+\tnotype_component_declarator, after_type_component_declarator,\n+\tfull_parm, maybe_raises, exception_specification_opt): Fix up,\n+\tinclude exception_specification_opt maybeasm maybe_attribute and\n+\tmaybe_init if missing.  Rename maybe_raises to\n+\texception_specification_opt to match draft wording.  Use maybe_init\n+\tto simplify rules.\n+\n+Fri Feb 17 01:54:46 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* init.c (build_new): Set TREE_NO_UNUSED_WARNING on COMPOUND_EXPRs\n+\tbuilt for news of scalar types.\n+\n+Thu Feb 16 17:48:28 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* typeck.c (build_binary_op_nodefault): Update code for warning\n+\tabout signed/unsigned comparisons from C frontend.  Realize that the\n+\tcode in the C frontend is, if anything, even more bogus.  Fix it.\n+\t(build_binary_op): Undo default_conversion if it wasn't useful.\n+\n+\t* typeck.c (build_unary_op, ADDR_EXPR): Lose bogus special case for\n+\tPRE*CREMENT_EXPR.\n+\n+\t* decl2.c (import_export_vtable): Don't try the vtable hack\n+\tif the class doesn't have any real non-inline virtual functions.\n+\t(finish_vtable_vardecl): Don't bother trying to find a non-inline\n+\tvirtual function in a non-polymorphic class.\n+\t(finish_prevtable_vardecl): Ditto.\n+\n+\t* decl2.c (import_export_vtable): Use and set DECL_INTERFACE_KNOWN.\n+\n+\t* cp-tree.h (DECL_INTERFACE_KNOWN): Use DECL_LANG_FLAG_5.\n+\n+\t* init.c (expand_virtual_init): Always call assemble_external.\n+\n+\t* class.c (build_vfn_ref): Always call assemble_external.\n+\t(build_vtable): Always call import_export_vtable.\n+\t(prepare_fresh_vtable): Ditto.\n+\t(add_virtual_function): Don't bother setting TREE_ADDRESSABLE.\n+\n Thu Feb 16 03:28:49 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n \n \t* class.c (finish_struct): Use TYPE_{MIN,MAX}_VALUE to determine"}, {"sha": "2e5f0136c68cf6442089c31ed52805939880f166", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3417fcd0cb24c81bdcc3e8a36753fc0126148eb/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3417fcd0cb24c81bdcc3e8a36753fc0126148eb/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=e3417fcd0cb24c81bdcc3e8a36753fc0126148eb", "patch": "@@ -196,12 +196,12 @@ parse.o : $(PARSE_C) $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h lex.h\n \n $(PARSE_H) : $(PARSE_C)\n $(PARSE_C) : $(srcdir)/parse.y\n-\t@echo expect 1 shift/reduce confict and 34 reduce/reduce conflicts.\n+\t@echo expect 1 shift/reduce confict and 39 reduce/reduce conflicts.\n \tcd $(srcdir); $(BISON) $(BISONFLAGS) -d -o parse.c parse.y\n \tcd $(srcdir); grep '^#define[ \t]*YYEMPTY' parse.c >>parse.h\n #$(PARSE_C) $(PARSE_H) : stamp-parse ; @true\n #stamp-parse: $(srcdir)/parse.y\n-#\t@echo expect 1 shift/reduce confict and 34 reduce/reduce conflicts.\n+#\t@echo expect 1 shift/reduce confict and 39 reduce/reduce conflicts.\n #\t$(BISON) $(BISONFLAGS) -d $(srcdir)/parse.y\n #\tgrep '^#define[ \t]*YYEMPTY' y.tab.c >>y.tab.h\n #\t$(srcdir)/../move-if-change y.tab.c $(PARSE_C)"}, {"sha": "b0332e9af76716852734eac0ce64a456329964aa", "filename": "gcc/cp/class.c", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3417fcd0cb24c81bdcc3e8a36753fc0126148eb/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3417fcd0cb24c81bdcc3e8a36753fc0126148eb/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=e3417fcd0cb24c81bdcc3e8a36753fc0126148eb", "patch": "@@ -478,8 +478,7 @@ build_vfn_ref (ptr_to_instptr, instance, idx)\n \tvtbl = build_indirect_ref (build_vfield_ref (instance, basetype),\n \t\t\t\t   NULL_PTR);\n     }\n-  if (!flag_vtable_thunks)\n-    assemble_external (vtbl);\n+  assemble_external (vtbl);\n   aref = build_array_ref (vtbl, idx);\n \n   /* Save the intermediate result in a SAVE_EXPR so we don't have to\n@@ -552,8 +551,7 @@ build_vtable (binfo, type)\n #endif\n \n   /* Set TREE_PUBLIC and TREE_EXTERN as appropriate.  */\n-  if (! flag_vtable_thunks)\n-    import_export_vtable (decl, type);\n+  import_export_vtable (decl, type, 0);\n \n   IDENTIFIER_GLOBAL_VALUE (name) = decl = pushdecl_top_level (decl);\n   /* Initialize the association list for this type, based\n@@ -699,8 +697,7 @@ prepare_fresh_vtable (binfo, for_type)\n #endif\n \n   /* Set TREE_PUBLIC and TREE_EXTERN as appropriate.  */\n-  if (! flag_vtable_thunks)\n-    import_export_vtable (new_decl, for_type);\n+  import_export_vtable (new_decl, for_type, 0);\n \n   if (TREE_VIA_VIRTUAL (binfo))\n     my_friendly_assert (binfo == binfo_member (BINFO_TYPE (binfo),\n@@ -803,9 +800,6 @@ add_virtual_function (pending_virtuals, has_virtual, fndecl, t)\n \t\tfndecl);\n #endif\n \n-  if (!flag_vtable_thunks)\n-    TREE_ADDRESSABLE (fndecl) = CLASSTYPE_VTABLE_NEEDS_WRITING (t);\n-\n   /* If the virtual function is a redefinition of a prior one,\n      figure out in which base class the new definition goes,\n      and if necessary, make a fresh virtual function table"}, {"sha": "27b616aee0a1e0d7cfc8e1ffcc2b871a9333b1b2", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3417fcd0cb24c81bdcc3e8a36753fc0126148eb/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3417fcd0cb24c81bdcc3e8a36753fc0126148eb/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=e3417fcd0cb24c81bdcc3e8a36753fc0126148eb", "patch": "@@ -954,10 +954,9 @@ struct lang_decl_flags\n   unsigned saved_inline : 1;\n   unsigned use_template : 2;\n \n-  unsigned interface_known : 1;\n   unsigned declared_static : 1;\n   unsigned nonconverting : 1;\n-  unsigned dummy : 5;\n+  unsigned dummy : 6;\n \n   tree access;\n   tree context;\n@@ -1131,7 +1130,7 @@ struct lang_decl\n \n #if 0\n /* Same, but tells if this field is private in current context.  */\n-#define DECL_PRIVATE(NODE) (DECL_LANG_FLAG_5 (NODE))\n+#define DECL_PRIVATE(NODE) (FOO)\n \n /* Same, but tells if this field is private in current context.  */\n #define DECL_PROTECTED(NODE) (DECL_LANG_FLAG_6 (NODE))\n@@ -1337,8 +1336,7 @@ struct lang_decl\n   (CLASSTYPE_USE_TEMPLATE(NODE) = 3)\n \n /* We know what we're doing with this decl now.  */\n-#define DECL_INTERFACE_KNOWN(NODE) \\\n-  (DECL_LANG_SPECIFIC (NODE)->decl_flags.interface_known)\n+#define DECL_INTERFACE_KNOWN(NODE) DECL_LANG_FLAG_5 (NODE)\n \n /* This decl was declared to have internal linkage.  */\n #define DECL_DECLARED_STATIC(NODE) \\"}, {"sha": "b38f1db079ca66d87dbb3a27accbd629c735ea3d", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 63, "deletions": 26, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3417fcd0cb24c81bdcc3e8a36753fc0126148eb/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3417fcd0cb24c81bdcc3e8a36753fc0126148eb/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=e3417fcd0cb24c81bdcc3e8a36753fc0126148eb", "patch": "@@ -144,10 +144,8 @@ int warn_implicit = 1;\n int warn_ctor_dtor_privacy = 1;\n \n /* True if we want to implement vtbvales using \"thunks\".\n-   The default is off now, but will be on later.\n+   The default is off now, but will be on later. */\n \n-   Also causes output of vtables to be controlled by whether\n-   we seen the class's first non-inline virtual function. */\n int flag_vtable_thunks;\n \n /* Nonzero means give string constants the type `const char *'\n@@ -2466,23 +2464,61 @@ mark_vtable_entries (decl)\n    it's public in this file or in another one.  */\n \n void\n-import_export_vtable (decl, type)\n-  tree decl, type;\n+import_export_vtable (decl, type, final)\n+     tree decl, type;\n+     int final;\n {\n-  if (write_virtuals >= 2\n-      || CLASSTYPE_TEMPLATE_INSTANTIATION (type))\n-    {\n-      if (CLASSTYPE_INTERFACE_KNOWN (type))\n-\t{\n-\t  TREE_PUBLIC (decl) = 1;\n-\t  DECL_EXTERNAL (decl) = ! CLASSTYPE_VTABLE_NEEDS_WRITING (type);\n-\t}\n-    }\n-  else if (write_virtuals != 0)\n+  if (DECL_INTERFACE_KNOWN (decl))\n+    return;\n+\n+  /* +e0 or +e1 */\n+  if (write_virtuals < 2 && write_virtuals != 0)\n     {\n       TREE_PUBLIC (decl) = 1;\n       if (write_virtuals < 0)\n \tDECL_EXTERNAL (decl) = 1;\n+      DECL_INTERFACE_KNOWN (decl) = 1;\n+    }\n+  else if (CLASSTYPE_INTERFACE_KNOWN (type))\n+    {\n+      TREE_PUBLIC (decl) = 1;\n+      DECL_EXTERNAL (decl) = ! CLASSTYPE_VTABLE_NEEDS_WRITING (type);\n+      DECL_INTERFACE_KNOWN (decl) = 1;\n+    }\n+  else\n+    {\n+      /* We can only do this optimization if we have real non-inline\n+\t virtual functions in our class, or if we come from a template.  */\n+\n+      int found = CLASSTYPE_TEMPLATE_INSTANTIATION (type);\n+\n+      if (! found && ! final)\n+\t{\n+\t  /* This check only works before the method definitions are seen,\n+\t     since DECL_INLINE may get bashed.  */\n+\t  tree method;\n+\t  for (method = CLASSTYPE_METHODS (type); method != NULL_TREE;\n+\t       method = DECL_NEXT_METHOD (method))\n+\t    if (DECL_VINDEX (method) != NULL_TREE && ! DECL_INLINE (method)\n+\t\t&& ! DECL_ABSTRACT_VIRTUAL_P (method))\n+\t      {\n+\t\tfound = 1;\n+\t\tbreak;\n+\t      }\n+\t}\n+\n+      if (final || ! found)\n+\t{\n+\t  TREE_PUBLIC (decl) = 0;\n+\t  DECL_EXTERNAL (decl) = 0;\n+\t  DECL_INTERFACE_KNOWN (decl) = 1;\n+\t}\n+      else\n+\t{\n+\t  TREE_PUBLIC (decl) = 1;\n+\t  DECL_EXTERNAL (decl) = 1;\n+\t  DECL_INTERFACE_KNOWN (decl) = 0;\n+\t}\n     }\n }\n \n@@ -2506,9 +2542,8 @@ finish_prevtable_vardecl (prev, vars)\n {\n   tree ctype = DECL_CONTEXT (vars);\n   import_export_template (ctype);\n-  import_export_vtable (vars, ctype);\n \n-  if (CLASSTYPE_INTERFACE_UNKNOWN (ctype))\n+  if (CLASSTYPE_INTERFACE_UNKNOWN (ctype) && TYPE_VIRTUAL_P (ctype))\n     {\n       tree method;\n       for (method = CLASSTYPE_METHODS (ctype); method != NULL_TREE;\n@@ -2520,13 +2555,13 @@ finish_prevtable_vardecl (prev, vars)\n \t      SET_CLASSTYPE_INTERFACE_KNOWN (ctype);\n \t      CLASSTYPE_VTABLE_NEEDS_WRITING (ctype) = ! DECL_EXTERNAL (method);\n \t      CLASSTYPE_INTERFACE_ONLY (ctype) = DECL_EXTERNAL (method);\n-\t      TREE_PUBLIC (vars) = 1;\n-\t      DECL_EXTERNAL (vars) = DECL_EXTERNAL (method);\n \t      break;\n \t    }\n \t}\n     }\n \n+  import_export_vtable (vars, ctype, 1);\n+\n   if (write_virtuals >= 0\n       && ! DECL_EXTERNAL (vars) && (TREE_PUBLIC (vars) || TREE_USED (vars)))\n     {\n@@ -2549,9 +2584,8 @@ finish_vtable_vardecl (prev, vars)\n {\n   tree ctype = DECL_CONTEXT (vars);\n   import_export_template (ctype);\n-  import_export_vtable (vars, ctype);\n \n-  if (CLASSTYPE_INTERFACE_UNKNOWN (ctype))\n+  if (CLASSTYPE_INTERFACE_UNKNOWN (ctype) && TYPE_VIRTUAL_P (ctype))\n     {\n       tree method;\n       for (method = CLASSTYPE_METHODS (ctype); method != NULL_TREE;\n@@ -2563,15 +2597,15 @@ finish_vtable_vardecl (prev, vars)\n \t      SET_CLASSTYPE_INTERFACE_KNOWN (ctype);\n \t      CLASSTYPE_VTABLE_NEEDS_WRITING (ctype) = ! DECL_EXTERNAL (method);\n \t      CLASSTYPE_INTERFACE_ONLY (ctype) = DECL_EXTERNAL (method);\n-\t      TREE_PUBLIC (vars) = 1;\n-\t      DECL_EXTERNAL (vars) = DECL_EXTERNAL (method);\n \t      if (flag_rtti)\n \t\tcp_warning (\"compiler error: rtti entry for `%T' decided too late\", ctype);\n \t      break;\n \t    }\n \t}\n     }\n \n+  import_export_vtable (vars, ctype, 1);\n+\n   if (write_virtuals >= 0\n       && ! DECL_EXTERNAL (vars) && (TREE_PUBLIC (vars) || TREE_USED (vars)))\n     {\n@@ -2612,7 +2646,7 @@ finish_vtable_vardecl (prev, vars)\n \n       rest_of_decl_compilation (vars, NULL_PTR, 1, 1);\n     }\n-  else if (TREE_USED (vars) && flag_vtable_thunks)\n+  else if (TREE_USED (vars))\n     assemble_external (vars);\n   /* We know that PREV must be non-zero here.  */\n   TREE_CHAIN (prev) = TREE_CHAIN (vars);\n@@ -3230,8 +3264,11 @@ tree\n reparse_decl_as_expr (type, decl)\n      tree type, decl;\n {\n-  decl = build_tree_list (NULL_TREE, reparse_decl_as_expr1 (decl));\n-  return build_functional_cast (type, decl);\n+  decl = reparse_decl_as_expr1 (decl);\n+  if (type)\n+    return build_functional_cast (type, build_tree_list (NULL_TREE, decl));\n+  else\n+    return decl;\n }\n \n /* This is something of the form `int (*a)' that has turned out to be a"}, {"sha": "63a909cb457835a87e59fd8d58fae9ed8aa3fb85", "filename": "gcc/cp/init.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3417fcd0cb24c81bdcc3e8a36753fc0126148eb/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3417fcd0cb24c81bdcc3e8a36753fc0126148eb/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=e3417fcd0cb24c81bdcc3e8a36753fc0126148eb", "patch": "@@ -730,8 +730,7 @@ expand_virtual_init (binfo, decl)\n   vtype = DECL_CONTEXT (CLASSTYPE_VFIELD (type));\n   vtype_binfo = get_binfo (vtype, TREE_TYPE (TREE_TYPE (decl)), 0);\n   vtbl = BINFO_VTABLE (binfo_value (DECL_FIELD_CONTEXT (CLASSTYPE_VFIELD (type)), binfo));\n-  if (!flag_vtable_thunks)\n-    assemble_external (vtbl);\n+  assemble_external (vtbl);\n   TREE_USED (vtbl) = 1;\n   vtbl = build1 (ADDR_EXPR, TYPE_POINTER_TO (TREE_TYPE (vtbl)), vtbl);\n   decl = convert_pointer_to_real (vtype_binfo, decl);\n@@ -3093,6 +3092,7 @@ build_new (placement, decl, init, use_global_new)\n \t  rval = build (COMPOUND_EXPR, TREE_TYPE (rval),\n \t\t\tbuild_modify_expr (deref, NOP_EXPR, init),\n \t\t\trval);\n+\t  TREE_NO_UNUSED_WARNING (rval) = 1;\n \t  TREE_SIDE_EFFECTS (rval) = 1;\n \t  TREE_CALLS_NEW (rval) = 1;\n \t}"}, {"sha": "b85ffc9d49926cf38c0c9a5f5fb96c8195ebe715", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 60, "deletions": 63, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3417fcd0cb24c81bdcc3e8a36753fc0126148eb/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3417fcd0cb24c81bdcc3e8a36753fc0126148eb/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=e3417fcd0cb24c81bdcc3e8a36753fc0126148eb", "patch": "@@ -205,7 +205,7 @@ empty_parms ()\n %type <ttype> declmods typespec typespecqual_reserved\n %type <ttype> SCSPEC TYPESPEC TYPE_QUAL nonempty_type_quals maybe_type_qual\n %type <itype> initdecls notype_initdecls initdcl\t/* C++ modification */\n-%type <ttype> init initlist maybeasm\n+%type <ttype> init initlist maybeasm maybe_init\n %type <ttype> asm_operands nonnull_asm_operands asm_operand asm_clobbers\n %type <ttype> maybe_attribute attributes attribute attribute_list attrib\n %type <ttype> any_word\n@@ -244,7 +244,7 @@ empty_parms ()\n %type <ttype> class_head base_class_list\n %type <itype> base_class_access_list\n %type <ttype> base_class maybe_base_class_list base_class.1\n-%type <ttype> maybe_raises ansi_raise_identifier ansi_raise_identifiers\n+%type <ttype> exception_specification_opt ansi_raise_identifier ansi_raise_identifiers\n %type <ttype> component_declarator0\n %type <ttype> forhead.1 operator_name\n %type <ttype> object aggr\n@@ -495,7 +495,7 @@ template_def:\n \t\t  /* declare $2 as template name with $1 parm list */\n \t\t}\n \t| template_header /* notype_initdcl0 ';' */\n-\t  notype_declarator maybe_raises maybeasm maybe_attribute\n+\t  notype_declarator exception_specification_opt maybeasm maybe_attribute\n \t  fn_tmpl_end\n \t\t{\n \t\t  tree d;\n@@ -512,7 +512,7 @@ template_def:\n \t\t  resume_momentary (momentary);\n \t\t}\n \t| template_header typed_declspecs /*initdcl0*/\n-\t  declarator maybe_raises maybeasm maybe_attribute\n+\t  declarator exception_specification_opt maybeasm maybe_attribute\n \t  fn_tmpl_end\n \t\t{\n \t\t  tree d;\n@@ -649,17 +649,17 @@ fndef:\n \t;\n \n fn.def1:\n-\t  typed_declspecs declarator maybe_raises\n+\t  typed_declspecs declarator exception_specification_opt\n \t\t{ if (! start_function ($$, $2, $3, 0))\n \t\t    YYERROR1;\n \t\t  reinit_parse_for_function ();\n \t\t  $$ = NULL_TREE; }\n-\t| declmods notype_declarator maybe_raises\n+\t| declmods notype_declarator exception_specification_opt\n \t\t{ if (! start_function ($$, $2, $3, 0))\n \t\t    YYERROR1;\n \t\t  reinit_parse_for_function ();\n \t\t  $$ = NULL_TREE; }\n-\t| notype_declarator maybe_raises\n+\t| notype_declarator exception_specification_opt\n \t\t{ if (! start_function (NULL_TREE, $$, $2, 0))\n \t\t    YYERROR1;\n \t\t  reinit_parse_for_function ();\n@@ -672,7 +672,7 @@ fn.def1:\n /* more C++ complexity.  See component_decl for a comment on the\n    reduce/reduce conflict introduced by these rules.  */\n fn.def2:\n-\t  typed_declspecs '(' parmlist ')' type_quals maybe_raises\n+\t  typed_declspecs '(' parmlist ')' type_quals exception_specification_opt\n \t\t{\n \t\t  $$ = build_parse_node (CALL_EXPR, TREE_VALUE ($1), $3, $5);\n \t\t  $$ = start_method (TREE_CHAIN ($1), $$, $6);\n@@ -682,18 +682,18 @@ fn.def2:\n \t\t  if (yychar == YYEMPTY)\n \t\t    yychar = YYLEX;\n \t\t  reinit_parse_for_method (yychar, $$); }\n-\t| typed_declspecs LEFT_RIGHT type_quals maybe_raises\n+\t| typed_declspecs LEFT_RIGHT type_quals exception_specification_opt\n \t\t{\n \t\t  $$ = build_parse_node (CALL_EXPR, TREE_VALUE ($1),\n \t\t\t\t\t empty_parms (), $3);\n \t\t  $$ = start_method (TREE_CHAIN ($1), $$, $4);\n \t\t  goto rest_of_mdef;\n \t\t}\n-\t| typed_declspecs declarator maybe_raises\n+\t| typed_declspecs declarator exception_specification_opt\n \t\t{ $$ = start_method ($$, $2, $3); goto rest_of_mdef; }\n-\t| declmods notype_declarator maybe_raises\n+\t| declmods notype_declarator exception_specification_opt\n \t\t{ $$ = start_method ($$, $2, $3); goto rest_of_mdef; }\n-\t| notype_declarator maybe_raises\n+\t| notype_declarator exception_specification_opt\n \t\t{ $$ = start_method (NULL_TREE, $$, $2); goto rest_of_mdef; }\n \t;\n \n@@ -705,10 +705,8 @@ return_id: RETURN IDENTIFIER\n \t\t}\n \t;\n \n-return_init: return_id\n-\t\t{ store_return_init ($<ttype>$, NULL_TREE); }\n-\t| return_id '=' init\n-\t\t{ store_return_init ($<ttype>$, $3); }\n+return_init: return_id maybe_init\n+\t\t{ store_return_init ($<ttype>$, $2); }\n \t| return_id '(' nonnull_exprlist ')'\n \t\t{ store_return_init ($<ttype>$, $3); }\n \t| return_id LEFT_RIGHT\n@@ -962,7 +960,7 @@ xcond:\n \t;\n \n condition:\n-\ttype_specifier_seq declarator maybe_raises maybeasm maybe_attribute '='\n+\ttype_specifier_seq declarator exception_specification_opt maybeasm maybe_attribute '='\n \t\t{ {\n \t\t  tree d;\n \t\t  for (d = getdecls (); d; d = TREE_CHAIN (d))\n@@ -1334,12 +1332,21 @@ primary:\n \t| string\n \t\t{ $$ = combine_strings ($$); }\n \t| '(' expr ')'\n-\t\t{ char class = TREE_CODE_CLASS (TREE_CODE ($2));\n+\t\t{ char class;\n+\t\t  $$ = $2;\n+\t\t  class = TREE_CODE_CLASS (TREE_CODE ($$));\n+\t\t  if (class == 'e' || class == '1'\n+\t\t      || class == '2' || class == '<')\n+                    /* This inhibits warnings in truthvalue_conversion. */\n+\t\t    C_SET_EXP_ORIGINAL_CODE ($$, ERROR_MARK); }\n+\t| '(' expr_or_declarator ')'\n+\t\t{ char class;\n+\t\t  $$ = reparse_decl_as_expr (NULL_TREE, $2);\n+\t\t  class = TREE_CODE_CLASS (TREE_CODE ($$));\n \t\t  if (class == 'e' || class == '1'\n \t\t      || class == '2' || class == '<')\n                     /* This inhibits warnings in truthvalue_conversion. */\n-\t\t    C_SET_EXP_ORIGINAL_CODE ($2, ERROR_MARK);\n-\t\t  $$ = $2; }\n+\t\t    C_SET_EXP_ORIGINAL_CODE ($$, ERROR_MARK); }\n \t| '(' error ')'\n \t\t{ $$ = error_mark_node; }\n \t| '('\n@@ -1948,7 +1955,7 @@ maybeasm:\n \t;\n \n initdcl0:\n-\t  declarator maybe_raises maybeasm maybe_attribute '='\n+\t  declarator exception_specification_opt maybeasm maybe_attribute '='\n \t\t{ current_declspecs = $<ttype>0;\n \t\t  if (TREE_CODE (current_declspecs) != TREE_LIST)\n \t\t    current_declspecs = get_decl_list (current_declspecs);\n@@ -1966,7 +1973,7 @@ initdcl0:\n /* Note how the declaration of the variable is in effect while its init is parsed! */\n \t\t{ finish_decl ($<ttype>6, $7, $3, 0, LOOKUP_ONLYCONVERTING);\n \t\t  $$ = $<itype>5; }\n-\t| declarator maybe_raises maybeasm maybe_attribute\n+\t| declarator exception_specification_opt maybeasm maybe_attribute\n \t\t{ tree d;\n \t\t  current_declspecs = $<ttype>0;\n \t\t  if (TREE_CODE (current_declspecs) != TREE_LIST)\n@@ -1985,20 +1992,20 @@ initdcl0:\n \t;\n \n initdcl:\n-\t  declarator maybe_raises maybeasm maybe_attribute '='\n+\t  declarator exception_specification_opt maybeasm maybe_attribute '='\n \t\t{ $<ttype>$ = start_decl ($<ttype>1, current_declspecs, 1, $2);\n \t\t  cplus_decl_attributes ($<ttype>$, $4); }\n \t  init\n /* Note how the declaration of the variable is in effect while its init is parsed! */\n \t\t{ finish_decl ($<ttype>6, $7, $3, 0, LOOKUP_ONLYCONVERTING); }\n-\t| declarator maybe_raises maybeasm maybe_attribute\n+\t| declarator exception_specification_opt maybeasm maybe_attribute\n \t\t{ $<ttype>$ = start_decl ($<ttype>1, current_declspecs, 0, $2);\n \t\t  cplus_decl_attributes ($<ttype>$, $4);\n \t\t  finish_decl ($<ttype>$, NULL_TREE, $3, 0, 0); }\n \t;\n \n notype_initdcl0:\n-\t  notype_declarator maybe_raises maybeasm maybe_attribute '='\n+\t  notype_declarator exception_specification_opt maybeasm maybe_attribute '='\n \t\t{ current_declspecs = $<ttype>0;\n \t\t  $<itype>5 = suspend_momentary ();\n \t\t  $<ttype>$ = start_decl ($<ttype>1, current_declspecs, 1, $2);\n@@ -2007,7 +2014,7 @@ notype_initdcl0:\n /* Note how the declaration of the variable is in effect while its init is parsed! */\n \t\t{ finish_decl ($<ttype>6, $7, $3, 0, LOOKUP_ONLYCONVERTING);\n \t\t  $$ = $<itype>5; }\n-\t| notype_declarator maybe_raises maybeasm maybe_attribute\n+\t| notype_declarator exception_specification_opt maybeasm maybe_attribute\n \t\t{ tree d;\n \t\t  current_declspecs = $<ttype>0;\n \t\t  $$ = suspend_momentary ();\n@@ -2017,7 +2024,7 @@ notype_initdcl0:\n \t;\n \n nomods_initdcl0:\n-\t  notype_declarator maybe_raises maybeasm maybe_attribute '='\n+\t  notype_declarator exception_specification_opt maybeasm maybe_attribute '='\n \t\t{ current_declspecs = NULL_TREE;\n \t\t  $<itype>5 = suspend_momentary ();\n \t\t  $<ttype>$ = start_decl ($1, current_declspecs, 1, $2);\n@@ -2026,7 +2033,7 @@ nomods_initdcl0:\n /* Note how the declaration of the variable is in effect while its init is parsed! */\n \t\t{ finish_decl ($<ttype>6, $7, $3, 0, LOOKUP_ONLYCONVERTING);\n \t\t  $$ = $<itype>5; }\n-\t| notype_declarator maybe_raises maybeasm maybe_attribute\n+\t| notype_declarator exception_specification_opt maybeasm maybe_attribute\n \t\t{ tree d;\n \t\t  current_declspecs = NULL_TREE;\n \t\t  $$ = suspend_momentary ();\n@@ -2094,6 +2101,12 @@ identifiers_or_typenames:\n \t\t{ $$ = chainon ($1, build_tree_list (NULL_TREE, $3)); }\n \t;\n \n+maybe_init:\n+\t%prec EMPTY /* empty */\n+\t\t{ $$ = NULL_TREE; }\n+\t| '=' init\n+\t\t{ $$ = $2; }\n+\n init:\n \t  expr_no_commas %prec '='\n \t| '{' '}'\n@@ -2593,8 +2606,8 @@ component_decl_1:\n \t\t{ \n \t\t  $$ = grok_x_components ($$, $2);\n \t\t}\n-\t| notype_declarator maybe_raises maybeasm maybe_attribute\n-\t\t{ $$ = grokfield ($$, NULL_TREE, $2, NULL_TREE, $3);\n+\t| notype_declarator exception_specification_opt maybeasm maybe_attribute maybe_init\n+\t\t{ $$ = grokfield ($$, NULL_TREE, $2, $5, $3);\n \t\t  cplus_decl_attributes ($$, $4); }\n \t| ':' expr_no_commas\n \t\t{ $$ = grokbitfield (NULL_TREE, NULL_TREE, $2); }\n@@ -2609,16 +2622,16 @@ component_decl_1:\n \t   should \"A::foo\" be declared as a function or \"A::bar\" as a data\n \t   member? In other words, is \"bar\" an after_type_declarator or a\n \t   parmlist? */\n-\t| typed_declspecs '(' parmlist ')' type_quals\n+\t| typed_declspecs '(' parmlist ')' type_quals exception_specification_opt maybeasm maybe_attribute maybe_init\n \t\t{ $$ = build_parse_node (CALL_EXPR, TREE_VALUE ($1),\n \t\t\t\t\t $3, $5);\n-\t\t  $$ = grokfield ($$, TREE_CHAIN ($1), NULL_TREE, NULL_TREE,\n-\t\t\t\t  NULL_TREE); }\n-\t| typed_declspecs LEFT_RIGHT type_quals\n+\t\t  $$ = grokfield ($$, TREE_CHAIN ($1), $6, $9, $7);\n+\t\t  cplus_decl_attributes ($$, $8); }\n+\t| typed_declspecs LEFT_RIGHT type_quals exception_specification_opt maybeasm maybe_attribute maybe_init\n \t\t{ $$ = build_parse_node (CALL_EXPR, TREE_VALUE ($1),\n \t\t\t\t\t empty_parms (), $3);\n-\t\t  $$ = grokfield ($$, TREE_CHAIN ($1), NULL_TREE, NULL_TREE,\n-\t\t\t\t  NULL_TREE); }\n+\t\t  $$ = grokfield ($$, TREE_CHAIN ($1), $4, $7, $5);\n+\t\t  cplus_decl_attributes ($$, $6); }\n \t| using_decl\n \t;\n \n@@ -2664,13 +2677,9 @@ component_declarator:\n \t;\n \n after_type_component_declarator0:\n-\t  after_type_declarator maybe_raises maybeasm maybe_attribute\n-\t\t{ current_declspecs = $<ttype>0;\n-\t\t  $$ = grokfield ($$, current_declspecs, $2, NULL_TREE, $3);\n-\t\t  cplus_decl_attributes ($$, $4); }\n-\t| after_type_declarator maybe_raises maybeasm maybe_attribute '=' init\n+\t  after_type_declarator exception_specification_opt maybeasm maybe_attribute maybe_init\n \t\t{ current_declspecs = $<ttype>0;\n-\t\t  $$ = grokfield ($$, current_declspecs, $2, $6, $3);\n+\t\t  $$ = grokfield ($$, current_declspecs, $2, $5, $3);\n \t\t  cplus_decl_attributes ($$, $4); }\n \t| TYPENAME ':' expr_no_commas maybe_attribute\n \t\t{ current_declspecs = $<ttype>0;\n@@ -2679,13 +2688,9 @@ after_type_component_declarator0:\n \t;\n \n notype_component_declarator0:\n-\t  notype_declarator maybe_raises maybeasm maybe_attribute\n-\t\t{ current_declspecs = $<ttype>0;\n-\t\t  $$ = grokfield ($$, current_declspecs, $2, NULL_TREE, $3);\n-\t\t  cplus_decl_attributes ($$, $4); }\n-\t| notype_declarator maybe_raises maybeasm maybe_attribute '=' init\n+\t  notype_declarator exception_specification_opt maybeasm maybe_attribute maybe_init\n \t\t{ current_declspecs = $<ttype>0;\n-\t\t  $$ = grokfield ($$, current_declspecs, $2, $6, $3);\n+\t\t  $$ = grokfield ($$, current_declspecs, $2, $5, $3);\n \t\t  cplus_decl_attributes ($$, $4); }\n \t| IDENTIFIER ':' expr_no_commas maybe_attribute\n \t\t{ current_declspecs = $<ttype>0;\n@@ -2698,23 +2703,17 @@ notype_component_declarator0:\n \t;\n \n after_type_component_declarator:\n-\t  after_type_declarator maybe_raises maybeasm maybe_attribute\n-\t\t{ $$ = grokfield ($$, current_declspecs, $2, NULL_TREE, $3);\n-\t\t  cplus_decl_attributes ($$, $4); }\n-\t| after_type_declarator maybe_raises maybeasm maybe_attribute '=' init\n-\t\t{ $$ = grokfield ($$, current_declspecs, $2, $6, $3);\n+\t  after_type_declarator exception_specification_opt maybeasm maybe_attribute maybe_init\n+\t\t{ $$ = grokfield ($$, current_declspecs, $2, $5, $3);\n \t\t  cplus_decl_attributes ($$, $4); }\n \t| TYPENAME ':' expr_no_commas maybe_attribute\n \t\t{ $$ = grokbitfield ($$, current_declspecs, $3);\n \t\t  cplus_decl_attributes ($$, $4); }\n \t;\n \n notype_component_declarator:\n-\t  notype_declarator maybe_raises maybeasm maybe_attribute\n-\t\t{ $$ = grokfield ($$, current_declspecs, $2, NULL_TREE, $3);\n-\t\t  cplus_decl_attributes ($$, $4); }\n-\t| notype_declarator maybe_raises maybeasm maybe_attribute '=' init\n-\t\t{ $$ = grokfield ($$, current_declspecs, $2, $6, $3);\n+\t  notype_declarator exception_specification_opt maybeasm maybe_attribute maybe_init\n+\t\t{ $$ = grokfield ($$, current_declspecs, $2, $5, $3);\n \t\t  cplus_decl_attributes ($$, $4); }\n \t| IDENTIFIER ':' expr_no_commas maybe_attribute\n \t\t{ $$ = grokbitfield ($$, current_declspecs, $3);\n@@ -3702,10 +3701,8 @@ named_parm:\n \t;\n \n full_parm:\n-\t  parm\n-\t\t{ $$ = build_tree_list (NULL_TREE, $$); }\n-\t| parm '=' init\n-\t\t{ $$ = build_tree_list ($3, $$); }\n+\t  parm maybe_init\n+\t\t{ $$ = build_tree_list ($2, $$); }\n \t;\n \n parm:\n@@ -3748,7 +3745,7 @@ bad_parm:\n \t\t}\n \t;\n \n-maybe_raises:\n+exception_specification_opt:\n \t  %prec EMPTY /* empty */\n \t\t{ $$ = NULL_TREE; }\n \t| THROW '(' ansi_raise_identifiers  ')' %prec EMPTY"}, {"sha": "b21bbe94567fbced996377bdec94850397d22047", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 35, "deletions": 23, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3417fcd0cb24c81bdcc3e8a36753fc0126148eb/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3417fcd0cb24c81bdcc3e8a36753fc0126148eb/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=e3417fcd0cb24c81bdcc3e8a36753fc0126148eb", "patch": "@@ -2723,8 +2723,9 @@ build_binary_op (code, arg1, arg2, convert_p)\n \n   if (convert_p)\n     {\n-      args[0] = default_conversion (args[0]);\n-      args[1] = default_conversion (args[1]);\n+      tree args_save [2];\n+      args[0] = args_save [0] = default_conversion (args[0]);\n+      args[1] = args_save [1] = default_conversion (args[1]);\n \n       if (type_unknown_p (args[0]))\n \t{\n@@ -2780,6 +2781,11 @@ build_binary_op (code, arg1, arg2, convert_p)\n \t    error (\"ambiguous pointer conversion\");\n \t  args[convert_index] = try;\n \t}\n+\n+      if (args[0] == args_save[0])\n+\targs[0] = arg1;\n+      if (args[1] == args_save[1])\n+\targs[1] = arg2;\n     }\n   return build_binary_op_nodefault (code, args[0], args[1], code);\n }\n@@ -3457,19 +3463,34 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \n       if (short_compare && extra_warnings)\n \t{\n+\t  int op0_signed = ! TREE_UNSIGNED (TREE_TYPE (orig_op0));\n+\t  int op1_signed = ! TREE_UNSIGNED (TREE_TYPE (orig_op1));\n+\n+\t  tree comp_type = TREE_TYPE (op0);\n+\n \t  int unsignedp0, unsignedp1;\n \t  tree primop0 = get_narrower (op0, &unsignedp0);\n \t  tree primop1 = get_narrower (op1, &unsignedp1);\n \n-\t  /* Warn if signed and unsigned are being compared in a size larger\n-\t     than their original size, as this will always fail.  */\n-\n-\t  if (unsignedp0 != unsignedp1\n-\t      && (TYPE_PRECISION (TREE_TYPE (primop0))\n-\t\t  < TYPE_PRECISION (result_type))\n-\t      && (TYPE_PRECISION (TREE_TYPE (primop1))\n-\t\t  < TYPE_PRECISION (result_type)))\n-\t    warning (\"comparison between promoted unsigned and signed\");\n+\t  /* Give warnings for comparisons between signed and unsigned\n+\t     quantities that may fail.  Do not warn if the signed quantity\n+\t     is an unsuffixed integer literal (or some static constant\n+\t     expression involving such literals) and it is positive.\n+\t     Do not warn if the comparison is being done in a signed type,\n+\t     since the signed type will only be chosen if it can represent\n+\t     all the values of the unsigned type.  */\n+\t  /* Do the checking based on the original operand trees, so that\n+\t     casts will be considered, but default promotions won't be.  */\n+\t  if (TREE_UNSIGNED (comp_type)\n+\t      && ((op0_signed\n+\t\t   && (TREE_CODE (op0) != INTEGER_CST\n+\t\t       || (TREE_CODE (op0) == INTEGER_CST\n+\t\t\t   && INT_CST_LT (op0, integer_zero_node))))\n+\t\t  || (op1_signed\n+\t\t      && (TREE_CODE (op1) != INTEGER_CST\n+\t\t\t  || (TREE_CODE (op1) == INTEGER_CST\n+\t\t\t      && INT_CST_LT (op1, integer_zero_node))))))\n+\t    warning (\"comparison between signed and unsigned\");\n \n \t  /* Warn if two unsigned values are being compared in a size\n \t     larger than their original size, and one (and only one) is the\n@@ -3509,7 +3530,7 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t\t    }\n \n \t\t  bits = TYPE_PRECISION (TREE_TYPE (primop));\n-\t\t  if (bits < TYPE_PRECISION (result_type)\n+\t\t  if (bits < TYPE_PRECISION (comp_type)\n \t\t      && bits < HOST_BITS_PER_LONG && unsignedp)\n \t\t    {\n \t\t      mask = (~ (HOST_WIDE_INT) 0) << bits;\n@@ -3519,9 +3540,9 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t\t}\n \t      else if (unsignedp0 && unsignedp1\n \t\t       && (TYPE_PRECISION (TREE_TYPE (primop0))\n-\t\t\t   < TYPE_PRECISION (result_type))\n+\t\t\t   < TYPE_PRECISION (comp_type))\n \t\t       && (TYPE_PRECISION (TREE_TYPE (primop1))\n-\t\t\t   < TYPE_PRECISION (result_type)))\n+\t\t\t   < TYPE_PRECISION (comp_type)))\n \t\twarning (\"comparison of promoted ~unsigned with unsigned\");\n \t    }\n \t}\n@@ -4120,15 +4141,6 @@ build_unary_op (code, xarg, noconvert)\n \t\t\t\t  TREE_OPERAND (arg, 1), 1);\n \t}\n \n-      /* For &(++foo), we are really taking the address of the variable\n-\t being acted upon by the increment/decrement operator.  ARM $5.3.1\n-\t However, according to ARM $5.2.5, we don't allow postfix ++ and\n-\t --, since the prefix operators return lvalues, but the postfix\n-\t operators do not.  */\n-      if (TREE_CODE (arg) == PREINCREMENT_EXPR\n-\t  || TREE_CODE (arg) == PREDECREMENT_EXPR)\n-\targ = TREE_OPERAND (arg, 0);\n-\n       /* Uninstantiated types are all functions.  Taking the\n \t address of a function is a no-op, so just return the\n \t argument.  */"}]}