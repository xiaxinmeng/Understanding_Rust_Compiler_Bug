{"sha": "9a8819b8828490a83eaf9d069a049e26211cc215", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWE4ODE5Yjg4Mjg0OTBhODNlYWY5ZDA2OWEwNDllMjYyMTFjYzIxNQ==", "commit": {"author": {"name": "Pat Haugen", "email": "pthaugen@us.ibm.com", "date": "2019-11-19T19:49:37Z"}, "committer": {"name": "Pat Haugen", "email": "pthaugen@gcc.gnu.org", "date": "2019-11-19T19:49:37Z"}, "message": "rs6000.c (move_to_end_of_ready): New, factored out from common code.\n\n\t* config/rs6000/rs6000.c (move_to_end_of_ready): New, factored out\n\tfrom common code.\n\t(power6_sched_reorder2): Factored out from rs6000_sched_reorder2,\n\tcall new function.\n\t(power9_sched_reorder2): Call new function.\n\t(rs6000_sched_reorder2): Likewise.\n\nFrom-SVN: r278463", "tree": {"sha": "fc3a5bc2617e243ef9fa7eee8489fd7369433176", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fc3a5bc2617e243ef9fa7eee8489fd7369433176"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a8819b8828490a83eaf9d069a049e26211cc215", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a8819b8828490a83eaf9d069a049e26211cc215", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a8819b8828490a83eaf9d069a049e26211cc215", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a8819b8828490a83eaf9d069a049e26211cc215/comments", "author": null, "committer": null, "parents": [{"sha": "dd46a542a8f95ef7abac4da30ee3c03563eb3519", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd46a542a8f95ef7abac4da30ee3c03563eb3519", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd46a542a8f95ef7abac4da30ee3c03563eb3519"}], "stats": {"total": 433, "additions": 220, "deletions": 213}, "files": [{"sha": "d6671a7c1fb74f56827dab6e9ec010e8efc4e478", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a8819b8828490a83eaf9d069a049e26211cc215/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a8819b8828490a83eaf9d069a049e26211cc215/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9a8819b8828490a83eaf9d069a049e26211cc215", "patch": "@@ -1,3 +1,12 @@\n+2019-11-19  Pat Haugen  <pthaugen@us.ibm.com>\n+\n+\t* config/rs6000/rs6000.c (move_to_end_of_ready): New, factored out\n+\tfrom common code.\n+\t(power6_sched_reorder2): Factored out from rs6000_sched_reorder2,\n+\tcall new function.\n+\t(power9_sched_reorder2): Call new function.\n+\t(rs6000_sched_reorder2): Likewise.\n+\n 2019-11-18  Jan Hubicka  <jh@suse.cz>\n \n \t* ipa-fnsummary.c (estimate_edge_size_and_time): Drop parameter PROB."}, {"sha": "0282ebd89432469a0467d590537c6ea7a9d5bc56", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 211, "deletions": 213, "changes": 424, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a8819b8828490a83eaf9d069a049e26211cc215/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a8819b8828490a83eaf9d069a049e26211cc215/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=9a8819b8828490a83eaf9d069a049e26211cc215", "patch": "@@ -17711,14 +17711,216 @@ get_next_active_insn (rtx_insn *insn, rtx_insn *tail)\n   return insn;\n }\n \n+/* Move instruction at POS to the end of the READY list.  */\n+\n+static void\n+move_to_end_of_ready (rtx_insn **ready, int pos, int lastpos)\n+{\n+  rtx_insn *tmp;\n+  int i;\n+\n+  tmp = ready[pos];\n+  for (i = pos; i < lastpos; i++)\n+    ready[i] = ready[i + 1];\n+  ready[lastpos] = tmp;\n+}\n+\n+/* Do Power6 specific sched_reorder2 reordering of ready list.  */\n+\n+static int\n+power6_sched_reorder2 (rtx_insn **ready, int lastpos)\n+{\n+  /* For Power6, we need to handle some special cases to try and keep the\n+     store queue from overflowing and triggering expensive flushes.\n+\n+     This code monitors how load and store instructions are being issued\n+     and skews the ready list one way or the other to increase the likelihood\n+     that a desired instruction is issued at the proper time.\n+\n+     A couple of things are done.  First, we maintain a \"load_store_pendulum\"\n+     to track the current state of load/store issue.\n+\n+       - If the pendulum is at zero, then no loads or stores have been\n+\t issued in the current cycle so we do nothing.\n+\n+       - If the pendulum is 1, then a single load has been issued in this\n+\t cycle and we attempt to locate another load in the ready list to\n+\t issue with it.\n+\n+       - If the pendulum is -2, then two stores have already been\n+\t issued in this cycle, so we increase the priority of the first load\n+\t in the ready list to increase it's likelihood of being chosen first\n+\t in the next cycle.\n+\n+       - If the pendulum is -1, then a single store has been issued in this\n+\t cycle and we attempt to locate another store in the ready list to\n+\t issue with it, preferring a store to an adjacent memory location to\n+\t facilitate store pairing in the store queue.\n+\n+       - If the pendulum is 2, then two loads have already been\n+\t issued in this cycle, so we increase the priority of the first store\n+\t in the ready list to increase it's likelihood of being chosen first\n+\t in the next cycle.\n+\n+       - If the pendulum < -2 or > 2, then do nothing.\n+\n+       Note: This code covers the most common scenarios.  There exist non\n+\t     load/store instructions which make use of the LSU and which\n+\t     would need to be accounted for to strictly model the behavior\n+\t     of the machine.  Those instructions are currently unaccounted\n+\t     for to help minimize compile time overhead of this code.\n+   */\n+  int pos;\n+  rtx load_mem, str_mem;\n+\n+  if (is_store_insn (last_scheduled_insn, &str_mem))\n+    /* Issuing a store, swing the load_store_pendulum to the left */\n+    load_store_pendulum--;\n+  else if (is_load_insn (last_scheduled_insn, &load_mem))\n+    /* Issuing a load, swing the load_store_pendulum to the right */\n+    load_store_pendulum++;\n+  else\n+    return cached_can_issue_more;\n+\n+  /* If the pendulum is balanced, or there is only one instruction on\n+     the ready list, then all is well, so return. */\n+  if ((load_store_pendulum == 0) || (lastpos <= 0))\n+    return cached_can_issue_more;\n+\n+  if (load_store_pendulum == 1)\n+    {\n+      /* A load has been issued in this cycle.  Scan the ready list\n+\t for another load to issue with it */\n+      pos = lastpos;\n+\n+      while (pos >= 0)\n+\t{\n+\t  if (is_load_insn (ready[pos], &load_mem))\n+\t    {\n+\t      /* Found a load.  Move it to the head of the ready list,\n+\t\t and adjust it's priority so that it is more likely to\n+\t\t stay there */\n+\t      move_to_end_of_ready (ready, pos, lastpos);\n+\n+\t      if (!sel_sched_p ()\n+\t\t  && INSN_PRIORITY_KNOWN (ready[lastpos]))\n+\t\tINSN_PRIORITY (ready[lastpos])++;\n+\t      break;\n+\t    }\n+\t  pos--;\n+\t}\n+    }\n+  else if (load_store_pendulum == -2)\n+    {\n+      /* Two stores have been issued in this cycle.  Increase the\n+\t priority of the first load in the ready list to favor it for\n+\t issuing in the next cycle. */\n+      pos = lastpos;\n+\n+      while (pos >= 0)\n+\t{\n+\t  if (is_load_insn (ready[pos], &load_mem)\n+\t      && !sel_sched_p ()\n+\t      && INSN_PRIORITY_KNOWN (ready[pos]))\n+\t    {\n+\t      INSN_PRIORITY (ready[pos])++;\n+\n+\t      /* Adjust the pendulum to account for the fact that a load\n+\t\t was found and increased in priority.  This is to prevent\n+\t\t increasing the priority of multiple loads */\n+\t      load_store_pendulum--;\n+\n+\t      break;\n+\t    }\n+\t  pos--;\n+\t}\n+    }\n+  else if (load_store_pendulum == -1)\n+    {\n+      /* A store has been issued in this cycle.  Scan the ready list for\n+\t another store to issue with it, preferring a store to an adjacent\n+\t memory location */\n+      int first_store_pos = -1;\n+\n+      pos = lastpos;\n+\n+      while (pos >= 0)\n+\t{\n+\t  if (is_store_insn (ready[pos], &str_mem))\n+\t    {\n+\t      rtx str_mem2;\n+\t      /* Maintain the index of the first store found on the\n+\t\t list */\n+\t      if (first_store_pos == -1)\n+\t\tfirst_store_pos = pos;\n+\n+\t      if (is_store_insn (last_scheduled_insn, &str_mem2)\n+\t\t  && adjacent_mem_locations (str_mem, str_mem2))\n+\t\t{\n+\t\t  /* Found an adjacent store.  Move it to the head of the\n+\t\t     ready list, and adjust it's priority so that it is\n+\t\t     more likely to stay there */\n+\t\t  move_to_end_of_ready (ready, pos, lastpos);\n+\n+\t\t  if (!sel_sched_p ()\n+\t\t      && INSN_PRIORITY_KNOWN (ready[lastpos]))\n+\t\t    INSN_PRIORITY (ready[lastpos])++;\n+\n+\t\t  first_store_pos = -1;\n+\n+\t\t  break;\n+\t\t};\n+\t    }\n+\t  pos--;\n+\t}\n+\n+      if (first_store_pos >= 0)\n+\t{\n+\t  /* An adjacent store wasn't found, but a non-adjacent store was,\n+\t     so move the non-adjacent store to the front of the ready\n+\t     list, and adjust its priority so that it is more likely to\n+\t     stay there. */\n+\t  move_to_end_of_ready (ready, first_store_pos, lastpos);\n+\t  if (!sel_sched_p ()\n+\t      && INSN_PRIORITY_KNOWN (ready[lastpos]))\n+\t    INSN_PRIORITY (ready[lastpos])++;\n+\t}\n+    }\n+  else if (load_store_pendulum == 2)\n+    {\n+      /* Two loads have been issued in this cycle.  Increase the priority\n+\t of the first store in the ready list to favor it for issuing in\n+\t the next cycle. */\n+      pos = lastpos;\n+\n+      while (pos >= 0)\n+\t{\n+\t  if (is_store_insn (ready[pos], &str_mem)\n+\t      && !sel_sched_p ()\n+\t      && INSN_PRIORITY_KNOWN (ready[pos]))\n+\t    {\n+\t      INSN_PRIORITY (ready[pos])++;\n+\n+\t      /* Adjust the pendulum to account for the fact that a store\n+\t\t was found and increased in priority.  This is to prevent\n+\t\t increasing the priority of multiple stores */\n+\t      load_store_pendulum++;\n+\n+\t      break;\n+\t    }\n+\t  pos--;\n+\t}\n+    }\n+\n+  return cached_can_issue_more;\n+}\n+\n /* Do Power9 specific sched_reorder2 reordering of ready list.  */\n \n static int\n power9_sched_reorder2 (rtx_insn **ready, int lastpos)\n {\n   int pos;\n-  int i;\n-  rtx_insn *tmp;\n   enum attr_type type, type2;\n \n   type = get_attr_type (last_scheduled_insn);\n@@ -17738,10 +17940,7 @@ power9_sched_reorder2 (rtx_insn **ready, int lastpos)\n \t  if (recog_memoized (ready[pos]) >= 0\n \t      && get_attr_type (ready[pos]) == TYPE_DIV)\n \t    {\n-\t      tmp = ready[pos];\n-\t      for (i = pos; i < lastpos; i++)\n-\t\tready[i] = ready[i + 1];\n-\t      ready[lastpos] = tmp;\n+\t      move_to_end_of_ready (ready, pos, lastpos);\n \t      break;\n \t    }\n \t  pos--;\n@@ -17784,10 +17983,7 @@ power9_sched_reorder2 (rtx_insn **ready, int lastpos)\n \t\t\t{\n \t\t\t  /* Found a vector insn to pair with, move it to the\n \t\t\t     end of the ready list so it is scheduled next.  */\n-\t\t\t  tmp = ready[pos];\n-\t\t\t  for (i = pos; i < lastpos; i++)\n-\t\t\t    ready[i] = ready[i + 1];\n-\t\t\t  ready[lastpos] = tmp;\n+\t\t\t  move_to_end_of_ready (ready, pos, lastpos);\n \t\t\t  vec_pairing = 1;\n \t\t\t  return cached_can_issue_more;\n \t\t\t}\n@@ -17801,10 +17997,7 @@ power9_sched_reorder2 (rtx_insn **ready, int lastpos)\n \t\t{\n \t\t  /* Didn't find a vector to pair with but did find a vecload,\n \t\t     move it to the end of the ready list.  */\n-\t\t  tmp = ready[vecload_pos];\n-\t\t  for (i = vecload_pos; i < lastpos; i++)\n-\t\t    ready[i] = ready[i + 1];\n-\t\t  ready[lastpos] = tmp;\n+\t\t  move_to_end_of_ready (ready, vecload_pos, lastpos);\n \t\t  vec_pairing = 1;\n \t\t  return cached_can_issue_more;\n \t\t}\n@@ -17828,10 +18021,7 @@ power9_sched_reorder2 (rtx_insn **ready, int lastpos)\n \t\t\t{\n \t\t\t  /* Found a vecload insn to pair with, move it to the\n \t\t\t     end of the ready list so it is scheduled next.  */\n-\t\t\t  tmp = ready[pos];\n-\t\t\t  for (i = pos; i < lastpos; i++)\n-\t\t\t    ready[i] = ready[i + 1];\n-\t\t\t  ready[lastpos] = tmp;\n+\t\t\t  move_to_end_of_ready (ready, pos, lastpos);\n \t\t\t  vec_pairing = 1;\n \t\t\t  return cached_can_issue_more;\n \t\t\t}\n@@ -17846,10 +18036,7 @@ power9_sched_reorder2 (rtx_insn **ready, int lastpos)\n \t\t{\n \t\t  /* Didn't find a vecload to pair with but did find a vector\n \t\t     insn, move it to the end of the ready list.  */\n-\t\t  tmp = ready[vec_pos];\n-\t\t  for (i = vec_pos; i < lastpos; i++)\n-\t\t    ready[i] = ready[i + 1];\n-\t\t  ready[lastpos] = tmp;\n+\t\t  move_to_end_of_ready (ready, vec_pos, lastpos);\n \t\t  vec_pairing = 1;\n \t\t  return cached_can_issue_more;\n \t\t}\n@@ -17903,198 +18090,9 @@ rs6000_sched_reorder2 (FILE *dump, int sched_verbose, rtx_insn **ready,\n   if (sched_verbose)\n     fprintf (dump, \"// rs6000_sched_reorder2 :\\n\");\n \n-  /* For Power6, we need to handle some special cases to try and keep the\n-     store queue from overflowing and triggering expensive flushes.\n-\n-     This code monitors how load and store instructions are being issued\n-     and skews the ready list one way or the other to increase the likelihood\n-     that a desired instruction is issued at the proper time.\n-\n-     A couple of things are done.  First, we maintain a \"load_store_pendulum\"\n-     to track the current state of load/store issue.\n-\n-       - If the pendulum is at zero, then no loads or stores have been\n-         issued in the current cycle so we do nothing.\n-\n-       - If the pendulum is 1, then a single load has been issued in this\n-         cycle and we attempt to locate another load in the ready list to\n-         issue with it.\n-\n-       - If the pendulum is -2, then two stores have already been\n-         issued in this cycle, so we increase the priority of the first load\n-         in the ready list to increase it's likelihood of being chosen first\n-         in the next cycle.\n-\n-       - If the pendulum is -1, then a single store has been issued in this\n-         cycle and we attempt to locate another store in the ready list to\n-         issue with it, preferring a store to an adjacent memory location to\n-         facilitate store pairing in the store queue.\n-\n-       - If the pendulum is 2, then two loads have already been\n-         issued in this cycle, so we increase the priority of the first store\n-         in the ready list to increase it's likelihood of being chosen first\n-         in the next cycle.\n-\n-       - If the pendulum < -2 or > 2, then do nothing.\n-\n-       Note: This code covers the most common scenarios.  There exist non\n-             load/store instructions which make use of the LSU and which\n-             would need to be accounted for to strictly model the behavior\n-             of the machine.  Those instructions are currently unaccounted\n-             for to help minimize compile time overhead of this code.\n-   */\n+  /* Do Power6 dependent reordering if necessary.  */\n   if (rs6000_tune == PROCESSOR_POWER6 && last_scheduled_insn)\n-    {\n-      int pos;\n-      int i;\n-      rtx_insn *tmp;\n-      rtx load_mem, str_mem;\n-\n-      if (is_store_insn (last_scheduled_insn, &str_mem))\n-        /* Issuing a store, swing the load_store_pendulum to the left */\n-        load_store_pendulum--;\n-      else if (is_load_insn (last_scheduled_insn, &load_mem))\n-        /* Issuing a load, swing the load_store_pendulum to the right */\n-        load_store_pendulum++;\n-      else\n-        return cached_can_issue_more;\n-\n-      /* If the pendulum is balanced, or there is only one instruction on\n-         the ready list, then all is well, so return. */\n-      if ((load_store_pendulum == 0) || (*pn_ready <= 1))\n-        return cached_can_issue_more;\n-\n-      if (load_store_pendulum == 1)\n-        {\n-          /* A load has been issued in this cycle.  Scan the ready list\n-             for another load to issue with it */\n-          pos = *pn_ready-1;\n-\n-          while (pos >= 0)\n-            {\n-              if (is_load_insn (ready[pos], &load_mem))\n-                {\n-                  /* Found a load.  Move it to the head of the ready list,\n-                     and adjust it's priority so that it is more likely to\n-                     stay there */\n-                  tmp = ready[pos];\n-                  for (i=pos; i<*pn_ready-1; i++)\n-                    ready[i] = ready[i + 1];\n-                  ready[*pn_ready-1] = tmp;\n-\n-                  if (!sel_sched_p () && INSN_PRIORITY_KNOWN (tmp))\n-                    INSN_PRIORITY (tmp)++;\n-                  break;\n-                }\n-              pos--;\n-            }\n-        }\n-      else if (load_store_pendulum == -2)\n-        {\n-          /* Two stores have been issued in this cycle.  Increase the\n-             priority of the first load in the ready list to favor it for\n-             issuing in the next cycle. */\n-          pos = *pn_ready-1;\n-\n-          while (pos >= 0)\n-            {\n-              if (is_load_insn (ready[pos], &load_mem)\n-                  && !sel_sched_p ()\n-\t\t  && INSN_PRIORITY_KNOWN (ready[pos]))\n-                {\n-                  INSN_PRIORITY (ready[pos])++;\n-\n-                  /* Adjust the pendulum to account for the fact that a load\n-                     was found and increased in priority.  This is to prevent\n-                     increasing the priority of multiple loads */\n-                  load_store_pendulum--;\n-\n-                  break;\n-                }\n-              pos--;\n-            }\n-        }\n-      else if (load_store_pendulum == -1)\n-        {\n-          /* A store has been issued in this cycle.  Scan the ready list for\n-             another store to issue with it, preferring a store to an adjacent\n-             memory location */\n-          int first_store_pos = -1;\n-\n-          pos = *pn_ready-1;\n-\n-          while (pos >= 0)\n-            {\n-              if (is_store_insn (ready[pos], &str_mem))\n-                {\n-\t\t  rtx str_mem2;\n-                  /* Maintain the index of the first store found on the\n-                     list */\n-                  if (first_store_pos == -1)\n-                    first_store_pos = pos;\n-\n-                  if (is_store_insn (last_scheduled_insn, &str_mem2)\n-                      && adjacent_mem_locations (str_mem, str_mem2))\n-                    {\n-                      /* Found an adjacent store.  Move it to the head of the\n-                         ready list, and adjust it's priority so that it is\n-                         more likely to stay there */\n-                      tmp = ready[pos];\n-                      for (i=pos; i<*pn_ready-1; i++)\n-                        ready[i] = ready[i + 1];\n-                      ready[*pn_ready-1] = tmp;\n-\n-                      if (!sel_sched_p () && INSN_PRIORITY_KNOWN (tmp))\n-                        INSN_PRIORITY (tmp)++;\n-\n-                      first_store_pos = -1;\n-\n-                      break;\n-                    };\n-                }\n-              pos--;\n-            }\n-\n-          if (first_store_pos >= 0)\n-            {\n-              /* An adjacent store wasn't found, but a non-adjacent store was,\n-                 so move the non-adjacent store to the front of the ready\n-                 list, and adjust its priority so that it is more likely to\n-                 stay there. */\n-              tmp = ready[first_store_pos];\n-              for (i=first_store_pos; i<*pn_ready-1; i++)\n-                ready[i] = ready[i + 1];\n-              ready[*pn_ready-1] = tmp;\n-              if (!sel_sched_p () && INSN_PRIORITY_KNOWN (tmp))\n-                INSN_PRIORITY (tmp)++;\n-            }\n-        }\n-      else if (load_store_pendulum == 2)\n-       {\n-           /* Two loads have been issued in this cycle.  Increase the priority\n-              of the first store in the ready list to favor it for issuing in\n-              the next cycle. */\n-          pos = *pn_ready-1;\n-\n-          while (pos >= 0)\n-            {\n-              if (is_store_insn (ready[pos], &str_mem)\n-                  && !sel_sched_p ()\n-\t\t  && INSN_PRIORITY_KNOWN (ready[pos]))\n-                {\n-                  INSN_PRIORITY (ready[pos])++;\n-\n-                  /* Adjust the pendulum to account for the fact that a store\n-                     was found and increased in priority.  This is to prevent\n-                     increasing the priority of multiple stores */\n-                  load_store_pendulum++;\n-\n-                  break;\n-                }\n-              pos--;\n-            }\n-        }\n-    }\n+    return power6_sched_reorder2 (ready, *pn_ready - 1);\n \n   /* Do Power9 dependent reordering if necessary.  */\n   if (rs6000_tune == PROCESSOR_POWER9 && last_scheduled_insn"}]}