{"sha": "49009afdf737a82926f3f3a245508ef6db51c33e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDkwMDlhZmRmNzM3YTgyOTI2ZjNmM2EyNDU1MDhlZjZkYjUxYzMzZQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2000-08-21T18:01:51Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2000-08-21T18:01:51Z"}, "message": "gcc.c (do_spec_1): Implement %j spec flag.\n\n\t* gcc.c (do_spec_1): Implement %j spec flag.\n\tRemove dead comment.\n\n\t* gcc.texi (The Configuration File): Document HOST_BIT_BUCKET.\n        * system.h (HOST_BIT_BUCKET): Default to \"/dev/null\".\n        * config/i386/xm-dos.h (HOST_BIT_BUCKET): Define as \"NUL\".\n        * config/i386/xm-os2.h, config/winnt/winnt.h: Likewise.\n      * protoize.c (munge_compile_params): Use HOST_BIT_BUCKET (if\n\twritable) instead of hardcoded value.\n\n\t* toplev.c (compile_file): Output to a file even if -fsyntax-only.\n\n        * gcc.c, config/i386/xm-dos.h, config/i386/xm-os2.h: Kill\n        MKTEMP_EACH_FILE.\n\n         * gcc.c (cc1_options): Do not process -o or\n        run the assembler if -fsyntax-only.\n\nFrom-SVN: r35849", "tree": {"sha": "cb0efe07a757f09a75c26e74d5e3d29b0e63d2fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb0efe07a757f09a75c26e74d5e3d29b0e63d2fa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/49009afdf737a82926f3f3a245508ef6db51c33e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49009afdf737a82926f3f3a245508ef6db51c33e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49009afdf737a82926f3f3a245508ef6db51c33e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49009afdf737a82926f3f3a245508ef6db51c33e/comments", "author": null, "committer": null, "parents": [{"sha": "dc13bad72b60849788b55675d3ded5674b7dbdc8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc13bad72b60849788b55675d3ded5674b7dbdc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc13bad72b60849788b55675d3ded5674b7dbdc8"}], "stats": {"total": 198, "additions": 117, "deletions": 81}, "files": [{"sha": "8aabc1dc6b71b06b751e39fa5312c9aa4ade5316", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49009afdf737a82926f3f3a245508ef6db51c33e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49009afdf737a82926f3f3a245508ef6db51c33e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=49009afdf737a82926f3f3a245508ef6db51c33e", "patch": "@@ -1,4 +1,25 @@\n-2000-08-05  Eli Zaretskii  <eliz@is.elta.co.il>\n+2000-08-21  Nix  <nix@esperi.demon.co.uk>\n+\n+\t* gcc.c (do_spec_1): Implement %j spec flag.\n+\tRemove dead comment.\n+\n+\t* gcc.texi (The Configuration File): Document HOST_BIT_BUCKET.\n+        * system.h (HOST_BIT_BUCKET): Default to \"/dev/null\".\n+        * config/i386/xm-dos.h (HOST_BIT_BUCKET): Define as \"NUL\".\n+        * config/i386/xm-os2.h, config/winnt/winnt.h: Likewise.\n+\n+        * protoize.c (munge_compile_params): Use HOST_BIT_BUCKET (if\n+\twritable) instead of hardcoded value.\n+\n+\t* toplev.c (compile_file): Output to a file even if -fsyntax-only.\n+\n+        * gcc.c, config/i386/xm-dos.h, config/i386/xm-os2.h: Kill\n+        MKTEMP_EACH_FILE.\n+\n+        * gcc.c (cc1_options): Do not process -o or run the assembler if\n+\t-fsyntax-only.\n+\n+2000-08-21  Eli Zaretskii  <eliz@is.elta.co.il>\n \n \t* fixinc/fixincl.c (fix_with_system): Pipe the output of\n \t\"external\" fixes through `cat', to avoid truncating the input"}, {"sha": "48d5b11268faa53640977227be0f6ea912d95c69", "filename": "gcc/config/i386/xm-dos.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49009afdf737a82926f3f3a245508ef6db51c33e/gcc%2Fconfig%2Fi386%2Fxm-dos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49009afdf737a82926f3f3a245508ef6db51c33e/gcc%2Fconfig%2Fi386%2Fxm-dos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fxm-dos.h?ref=49009afdf737a82926f3f3a245508ef6db51c33e", "patch": "@@ -33,6 +33,8 @@ Boston, MA 02111-1307, USA.  */\n /* Suffix for executable file names.  */\n #define EXECUTABLE_SUFFIX \".exe\"\n \n-#define MKTEMP_EACH_FILE 1\n+/* Tell GCC about DOS's bit bucket. */\n+\n+#define HOST_BIT_BUCKET \"NUL\"\n \n #define NO_PRECOMPILES 1"}, {"sha": "3c84877794c4a233a161f19c84c7599acdf6efb5", "filename": "gcc/config/i386/xm-os2.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49009afdf737a82926f3f3a245508ef6db51c33e/gcc%2Fconfig%2Fi386%2Fxm-os2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49009afdf737a82926f3f3a245508ef6db51c33e/gcc%2Fconfig%2Fi386%2Fxm-os2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fxm-os2.h?ref=49009afdf737a82926f3f3a245508ef6db51c33e", "patch": "@@ -67,8 +67,8 @@ int spawnvp (int modeflag, char *path, char *argv[]);\n #define OBJECT_SUFFIX \".obj\"\n #endif\n \n-/* This is required to make temporary file names unique on file\n-   systems which severely restrict the length of file names. */\n-#define MKTEMP_EACH_FILE\n+/* Tell GCC about OS/2's bit bucket. */\n+\n+#define HOST_BIT_BUCKET \"NUL\"\n \n #include \"i386/xm-i386.h\""}, {"sha": "243609d5597871237abbed95b43e03618f474ffa", "filename": "gcc/gcc.c", "status": "modified", "additions": 40, "deletions": 44, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49009afdf737a82926f3f3a245508ef6db51c33e/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49009afdf737a82926f3f3a245508ef6db51c33e/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=49009afdf737a82926f3f3a245508ef6db51c33e", "patch": "@@ -292,6 +292,12 @@ or with constant text in a single argument.\n \tfor each `%g.s' and another for each `%U.s'.  Previously, %U was\n \tsimply substituted with a file name chosen for the previous %u,\n \twithout regard to any appended suffix.\n+ %jSUFFIX\n+        substitutes the name of the HOST_BIT_BUCKET, if any, and if it is\n+        writable, and if save-temps is off; otherwise, substitute the name\n+        of a temporary file, just like %u.  This temporary file is not\n+        meant for communication between processes, but rather as a junk\n+        disposal mechanism.\n  %d\tmarks the argument containing or following the %d as a\n \ttemporary file name, so that that file will be deleted if CC exits\n \tsuccessfully.  Unlike %g, this contributes no text to the argument.\n@@ -571,7 +577,8 @@ static const char *cc1_options =\n  %{g*} %{O*} %{W*} %{w} %{pedantic*} %{std*} %{ansi}\\\n  %{traditional} %{v:-version} %{pg:-p} %{p} %{f*}\\\n  %{aux-info*} %{Qn:-fno-ident} %{--help:--help}\\\n- %{S:%W{o*}%{!o*:-o %b.s}}\";\n+ %{!fsyntax-only:%{S:%W{o*}%{!o*:-o %b.s}}}\\\n+ %{fsyntax-only:-o %j}\";\n \n static const char *asm_options =\n \"%a %Y %{c:%W{o*}%{!o*:-o %w%b%O}}%{!c:-o %d%w%u%O}\";\n@@ -690,13 +697,13 @@ static struct compiler default_compilers[] =\n #if USE_CPPLIB\n      \"%{E|M|MM:cpp0 -lang-c %{ansi:-std=c89} %(cpp_options)}\\\n       %{!E:%{!M:%{!MM:cc1 -lang-c %{ansi:-std=c89} %(cpp_options)\\\n-\t\t\t  %(cc1_options) %{!S:-o %{|!pipe:%g.s} |\\n\\\n-      as %(asm_options) %{!pipe:%g.s} %A }}}}\"\n+\t\t\t  %(cc1_options) %{!fsyntax-only:%{!S:-o %{|!pipe:%g.s} |\\n\\\n+      as %(asm_options) %{!pipe:%g.s} %A }}}}}\"\n #else /* ! USE_CPPLIB */\n      \"%(trad_capable_cpp) -lang-c %{ansi:-std=c89} %(cpp_options) \\\n \t\t\t  %{!M:%{!MM:%{!E:%{!pipe:%g.i} |\\n\\\n-      cc1 %{!pipe:%g.i} %(cc1_options)  %{!S:-o %{|!pipe:%g.s} |\\n\\\n-      as %(asm_options) %{!pipe:%g.s} %A }}}}\\n\"\n+      cc1 %{!pipe:%g.i} %(cc1_options) %{!fsyntax-only:%{!S:-o %{|!pipe:%g.s} |\\n\\\n+      as %(asm_options) %{!pipe:%g.s} %A }}}}}\\n\"\n #endif /* ! USE_CPPLIB */\n   },\n   {\"-\",\n@@ -709,8 +716,8 @@ static struct compiler default_compilers[] =\n   {\".i\", \"@cpp-output\"},\n   {\"@cpp-output\",\n    \"%{!M:%{!MM:%{!E:\\\n-    cc1 %i %(cc1_options) %{!S:-o %{|!pipe:%g.s} |\\n\\\n-    as %(asm_options) %{!pipe:%g.s} %A }}}}\"},\n+    cc1 %i %(cc1_options) %{!fsyntax-only:%{!S:-o %{|!pipe:%g.s} |\\n\\\n+    as %(asm_options) %{!pipe:%g.s} %A }}}}}\"},\n   {\".s\", \"@assembler\"},\n   {\"@assembler\",\n    \"%{!M:%{!MM:%{!E:%{!S:as %(asm_options) %i %A }}}}\"},\n@@ -1226,13 +1233,9 @@ static int argbuf_length;\n \n static int argbuf_index;\n \n-/* We want this on by default all the time now.  */\n-#define MKTEMP_EACH_FILE\n-\n-#ifdef MKTEMP_EACH_FILE\n-\n-/* This is the list of suffixes and codes (%g/%u/%U) and the associated\n-   temp file.  */\n+/* This is the list of suffixes and codes (%g/%u/%U/%j) and the associated\n+   temp file.  If the HOST_BIT_BUCKET is used for %j, no entry is made for\n+   it here.  */\n \n static struct temp_name {\n   const char *suffix;\t/* suffix associated with the code.  */\n@@ -1242,8 +1245,6 @@ static struct temp_name {\n   int filename_length;\t/* strlen (filename).  */\n   struct temp_name *next;\n } *temp_names;\n-#endif\n-\n \n /* Number of commands executed so far.  */\n \n@@ -1681,7 +1682,7 @@ read_specs (filename, main_p)\n \n /* This is the common prefix we use to make temp file names.\n    It is chosen once for each run of this program.\n-   It is substituted into a spec by %g.\n+   It is substituted into a spec by %g or %j.\n    Thus, all temp file names contain this prefix.\n    In practice, all temp file names start with this prefix.\n \n@@ -3973,6 +3974,26 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t    }\n \t    break;\n \n+          case 'j':\n+            {\n+              struct stat st;\n+\n+              /* If save_temps_flag is off, and the HOST_BIT_BUCKET is defined,\n+                 and it is not a directory, and it is writable, use it.\n+                 Otherwise, fall through and treat this like any other\n+                 temporary file. */\n+\n+              if ((!save_temps_flag)\n+                  && (stat (HOST_BIT_BUCKET, &st) == 0) && (!S_ISDIR (st.st_mode))\n+                  && (access (HOST_BIT_BUCKET, W_OK) == 0))\n+                {\n+                  obstack_grow (&obstack, HOST_BIT_BUCKET,\n+                                strlen (HOST_BIT_BUCKET));\n+                  delete_this_arg = 0;\n+                  arg_going = 1;\n+                  break;\n+                }\n+            }\n \t  case 'g':\n \t  case 'u':\n \t  case 'U':\n@@ -3983,11 +4004,6 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t      }\n \t    else\n \t      {\n-#ifdef MKTEMP_EACH_FILE\n-\t\t/* ??? This has a problem: the total number of\n-\t\t   values mktemp can return is limited.\n-\t\t   That matters for the names of object files.\n-\t\t   In 2.4, do something about that.  */\n \t\tstruct temp_name *t;\n \t\tint suffix_length;\n \t\tconst char *suffix = p;\n@@ -4024,8 +4040,8 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t\t      && t->unique == (c != 'g'))\n \t\t    break;\n \n-\t\t/* Make a new association if needed.  %u requires one.  */\n-\t\tif (t == 0 || c == 'u')\n+\t\t/* Make a new association if needed.  %u and %j require one.  */\n+\t\tif (t == 0 || c == 'u' || c == 'j')\n \t\t  {\n \t\t    if (t == 0)\n \t\t      {\n@@ -4047,19 +4063,6 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \n \t\tobstack_grow (&obstack, t->filename, t->filename_length);\n \t\tdelete_this_arg = 1;\n-#else\n-\t\tobstack_grow (&obstack, temp_filename, temp_filename_length);\n-\t\tif (c == 'u' || c == 'U')\n-\t\t  {\n-\t\t    static int unique;\n-\t\t    char buff[9];\n-\t\t    if (c == 'u')\n-\t\t      unique++;\n-\t\t    sprintf (buff, \"%d\", unique);\n-\t\t    obstack_grow (&obstack, buff, strlen (buff));\n-\t\t  }\n-#endif\n-\t\tdelete_this_arg = 1;\n \t      }\n \t    arg_going = 1;\n \t    break;\n@@ -5196,13 +5199,6 @@ main (argc, argv)\n   putenv (INIT_ENVIRONMENT);\n #endif\n \n-  /* Choose directory for temp files.  */\n-\n-#ifndef MKTEMP_EACH_FILE\n-  temp_filename = choose_temp_base ();\n-  temp_filename_length = strlen (temp_filename);\n-#endif\n-\n   /* Make a table of what switches there are (switches, n_switches).\n      Make a table of specified input files (infiles, n_infiles).\n      Decode switches that are handled locally.  */"}, {"sha": "7c1f0972eb09a7fc22c12b5d56c4f77db53348c0", "filename": "gcc/gcc.texi", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49009afdf737a82926f3f3a245508ef6db51c33e/gcc%2Fgcc.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49009afdf737a82926f3f3a245508ef6db51c33e/gcc%2Fgcc.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.texi?ref=49009afdf737a82926f3f3a245508ef6db51c33e", "patch": "@@ -3928,6 +3928,15 @@ Define this macro to be a C string representing the suffix for executable\n files on your machine.  If you do not define this macro, GCC will use\n the null string as the suffix for object files.\n \n+@findex HOST_BIT_BUCKET\n+@item HOST_BIT_BUCKET\n+The name of a file or file-like object on the host system which acts as\n+a ``bit bucket''.  If you do not define this macro, GCC will use\n+@samp{/dev/null} as the bit bucket.  If the target does not support a\n+bit bucket, this should be defined to the null string, or some other\n+illegal filename.  If the bit bucket is not writable, GCC will use a\n+temporary file instead.\n+\n @findex COLLECT_EXPORT_LIST\n @item COLLECT_EXPORT_LIST\n If defined, @code{collect2} will scan the individual object files"}, {"sha": "1a51a7d20fa049841965f2c903e81cb63dfea560", "filename": "gcc/protoize.c", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49009afdf737a82926f3f3a245508ef6db51c33e/gcc%2Fprotoize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49009afdf737a82926f3f3a245508ef6db51c33e/gcc%2Fprotoize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprotoize.c?ref=49009afdf737a82926f3f3a245508ef6db51c33e", "patch": "@@ -1952,6 +1952,7 @@ munge_compile_params (params_list)\n     = (const char **) alloca ((strlen (params_list) + 8) * sizeof (char *));\n   int param_count = 0;\n   const char *param;\n+  struct stat st;\n \n   temp_params[param_count++] = compiler_file_name;\n   for (;;)\n@@ -1998,11 +1999,15 @@ munge_compile_params (params_list)\n \n   temp_params[param_count++] = \"-S\";\n   temp_params[param_count++] = \"-o\";\n-#if defined (_WIN32) && ! defined (__CYGWIN__) && ! defined (_UWIN)\n-  temp_params[param_count++] = \"NUL\";\n-#else\n-  temp_params[param_count++] = \"/dev/null\";\n-#endif\n+  \n+  if ((stat (HOST_BIT_BUCKET, &st) == 0) && (!S_ISDIR (st.st_mode))\n+      (access (HOST_BIT_BUCKET, W_OK) == 0))\n+    temp_params[param_count++] = HOST_BIT_BUCKET;\n+  else\n+    /* FIXME: This is hardly likely to be right, if HOST_BIT_BUCKET is not\n+       writable.  But until this is rejigged to use make_temp_file(), this\n+       is the best we can do.  */\n+    temp_params[param_count++] = \"/dev/null\";\n \n   /* Leave room for the input file name argument.  */\n   input_file_name_index = param_count;"}, {"sha": "afaa977a0d97afc2bb78bab83655838b35de9f73", "filename": "gcc/system.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49009afdf737a82926f3f3a245508ef6db51c33e/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49009afdf737a82926f3f3a245508ef6db51c33e/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=49009afdf737a82926f3f3a245508ef6db51c33e", "patch": "@@ -589,6 +589,13 @@ extern void abort PARAMS ((void));\n #define ONLY_INT_FIELDS 0\n #endif \n \n+/* Provide a default for the HOST_BIT_BUCKET.\n+   This suffices for POSIX-like hosts.  */\n+\n+#ifndef HOST_BIT_BUCKET\n+#define HOST_BIT_BUCKET \"/dev/null\"\n+#endif\n+\n /* Enumerated bitfields are safe to use unless we've been explictly told\n    otherwise or if they are signed. */\n  "}, {"sha": "225549ac7ba75546a830f6bf3be53f2d9b73366e", "filename": "gcc/toplev.c", "status": "modified", "additions": 23, "deletions": 27, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49009afdf737a82926f3f3a245508ef6db51c33e/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49009afdf737a82926f3f3a245508ef6db51c33e/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=49009afdf737a82926f3f3a245508ef6db51c33e", "patch": "@@ -2127,38 +2127,35 @@ compile_file (name)\n \tpfatal_with_name (aux_info_file_name);\n     }\n \n-  /* Open assembler code output file.  */\n+  /* Open assembler code output file.  Do this even if -fsyntax-only is on,\n+     because then the driver will have provided the name of a temporary\n+     file or bit bucket for us.  */\n \n-  if (flag_syntax_only)\n-    asm_out_file = NULL;\n+  if (! name_specified && asm_file_name == 0)\n+    asm_out_file = stdout;\n   else\n     {\n-      if (! name_specified && asm_file_name == 0)\n-\tasm_out_file = stdout;\n+      if (asm_file_name == 0)\n+        {\n+          int len = strlen (dump_base_name);\n+          char *dumpname = (char *) xmalloc (len + 6);\n+          memcpy (dumpname, dump_base_name, len + 1);\n+          strip_off_ending (dumpname, len);\n+          strcat (dumpname, \".s\");\n+          asm_file_name = dumpname;\n+        }\n+      if (!strcmp (asm_file_name, \"-\"))\n+        asm_out_file = stdout;\n       else\n-\t{\n-\t  if (asm_file_name == 0)\n-\t    {\n-\t      int len = strlen (dump_base_name);\n-\t      char *dumpname = (char *) xmalloc (len + 6);\n-\t      memcpy (dumpname, dump_base_name, len + 1);\n-\t      strip_off_ending (dumpname, len);\n-\t      strcat (dumpname, \".s\");\n-\t      asm_file_name = dumpname;\n-\t    }\n-\t  if (!strcmp (asm_file_name, \"-\"))\n-\t    asm_out_file = stdout;\n-\t  else\n-\t    asm_out_file = fopen (asm_file_name, \"w\");\n-\t  if (asm_out_file == 0)\n-\t    pfatal_with_name (asm_file_name);\n-\t}\n+        asm_out_file = fopen (asm_file_name, \"w\");\n+      if (asm_out_file == 0)\n+        pfatal_with_name (asm_file_name);\n+    }\n \n #ifdef IO_BUFFER_SIZE\n-      setvbuf (asm_out_file, (char *) xmalloc (IO_BUFFER_SIZE),\n-\t       _IOFBF, IO_BUFFER_SIZE);\n+  setvbuf (asm_out_file, (char *) xmalloc (IO_BUFFER_SIZE),\n+           _IOFBF, IO_BUFFER_SIZE);\n #endif\n-    }\n \n   if (ggc_p && name != 0)\n     name = ggc_alloc_string (name, strlen (name));\n@@ -2427,8 +2424,7 @@ compile_file (name)\n \n   finish_parse ();\n \n-  if (! flag_syntax_only\n-      && (ferror (asm_out_file) != 0 || fclose (asm_out_file) != 0))\n+  if (ferror (asm_out_file) != 0 || fclose (asm_out_file) != 0)\n     fatal_io_error (asm_file_name);\n \n   /* Do whatever is necessary to finish printing the graphs.  */"}]}