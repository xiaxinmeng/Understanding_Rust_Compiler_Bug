{"sha": "c48e0f27232aa6604b80e0d15b6ecb50604400a7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzQ4ZTBmMjcyMzJhYTY2MDRiODBlMGQxNWI2ZWNiNTA2MDQ0MDBhNw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-06T13:21:31Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-06T13:21:31Z"}, "message": "[multiple changes]\n\n2017-09-06  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_ch3.adb, sem_aux.adb, sem_res.adb: Minor reformatting.\n\n2017-09-06  Yannick Moy  <moy@adacore.com>\n\n\t* sem_ch12.adb (Analyze_Instance_And_Renamings): Refactor to set\n\tglobal variable Ignore_SPARK_Mode_Pragmas_In_Instance only once.\n\n2017-09-06  Bob Duff  <duff@adacore.com>\n\n\t* sem_ch8.adb: Change Assert to be consistent with\n\tother similar ones.\n\n2017-09-06  Bob Duff  <duff@adacore.com>\n\n\t* binde.adb (Find_Elab_Order): Do not run Elab_Old unless\n\trequested. Previously, the -do switch meant \"run Elab_New and\n\tElab_Old and use the order chosen by Elab_Old, possibly with\n\tdebugging printouts comparing the two orders.\"\tNow it means\n\t\"do not run Elab_New.\" This is of use if there are bugs that\n\tcause Elab_New to crash.\n\t(Elab_Position, Num_Chosen): Change type to Nat, to avoid various\n\ttype conversions.\n\t* ali.ads (Elab_Position): Change type to Nat, to avoid various\n\ttype conversions.\n\n2017-09-06  Arnaud Charlet  <charlet@adacore.com>\n\n\t* sem_prag.adb (Check_Mode_Restriction_In_Enclosing_Context): Fix\n\treference to SPARK RM.\n\n2017-09-06  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* layout.adb: Use SSU short hand consistently throughout the file.\n\n2017-09-06  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* freeze.adb (Freeze_Record_Type)\n\t<Sized_Component_Total_Round_RM_Size>: New local variable to\n\taccumulate the rounded RM_Size of components.  Update it for\n\tevery component whose RM_Size is statically known.  Add missing\n\tguard to check that bit packing is really required before issuing\n\tthe error about packing.  Swap condition for clarity's sake.\n\t* sem_prag.adb (Usage_Error): fix reference to\n\tSPARK RM in comment\n\n2017-09-06  Fedor Rybin  <frybin@adacore.com>\n\n\t* makeutl.adb, makeutl.ads, mlib.adb, mlib.ads, mlib-fil.adb,\n\tmlib-fil.ads, mlib-prj.adb, mlib-prj.ads, mlib-tgt.adb, mlib-tgt.ads,\n\tmlib-tgt-specific.adb, mlib-tgt-specific.ads,\n\tmlib-tgt-specific-aix.adb, mlib-tgt-specific-darwin.adb,\n\tmlib-tgt-specific-hpux.adb, mlib-tgt-specific-linux.adb,\n\tmlib-tgt-specific-mingw.adb, mlib-tgt-specific-solaris.adb,\n\tmlib-tgt-specific-vxworks.adb, mlib-tgt-specific-xi.adb, mlib-utl.adb,\n\tmlib-utl.ads, prj.adb, prj.ads, prj-attr.adb, prj-attr.ads,\n\tprj-attr-pm.adb, prj-attr-pm.ads, prj-com.ads, prj-conf.adb,\n\tprj-conf.ads, prj-dect.adb, prj-dect.ads, prj-env.adb, prj-env.ads,\n\tprj-err.adb, prj-err.ads, prj-ext.adb, prj-ext.ads, prj-makr.adb,\n\tprj-makr.ads, prj-nmsc.adb, prj-nmsc.ads, prj-pars.adb, prj-pars.ads,\n\tprj-part.adb, prj-part.ads, prj-pp.adb, prj-pp.ads, prj-proc.adb,\n\tprj-proc.ads, prj-strt.adb, prj-strt.ads, prj-tree.adb, prj-tree.ads,\n\tprj-util.adb, prj-util.ads, sinput-p.adb, sinput-p.ads: Remove obsolete\n\tproject manager sources.\n\n2017-09-06  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch5.adb (Analyze_Assigment): If the left-hand side is an\n\tentity of a mutable type and the right-hand side is a conditional\n\texpression, resolve the alternatives of the conditional using\n\tthe base type of the target entity, because the alternatives\n\tmay have distinct subtypes. This is particularly relevant if\n\tthe alternatives are aggregates.\n\nFrom-SVN: r251797", "tree": {"sha": "bfddb1ebb7a5ebb47669f302259856ea4f5a805a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bfddb1ebb7a5ebb47669f302259856ea4f5a805a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c48e0f27232aa6604b80e0d15b6ecb50604400a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c48e0f27232aa6604b80e0d15b6ecb50604400a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c48e0f27232aa6604b80e0d15b6ecb50604400a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c48e0f27232aa6604b80e0d15b6ecb50604400a7/comments", "author": null, "committer": null, "parents": [{"sha": "a87169db7dc0667a978e3f5b63e0fca648d3b793", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a87169db7dc0667a978e3f5b63e0fca648d3b793", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a87169db7dc0667a978e3f5b63e0fca648d3b793"}], "stats": {"total": 50453, "additions": 292, "deletions": 50161}, "files": [{"sha": "81c3e14df0cf818f4be145fa6dcc5ecb61ec3822", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c48e0f27232aa6604b80e0d15b6ecb50604400a7/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c48e0f27232aa6604b80e0d15b6ecb50604400a7/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=c48e0f27232aa6604b80e0d15b6ecb50604400a7", "patch": "@@ -1,3 +1,78 @@\n+2017-09-06  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_ch3.adb, sem_aux.adb, sem_res.adb: Minor reformatting.\n+\n+2017-09-06  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_ch12.adb (Analyze_Instance_And_Renamings): Refactor to set\n+\tglobal variable Ignore_SPARK_Mode_Pragmas_In_Instance only once.\n+\n+2017-09-06  Bob Duff  <duff@adacore.com>\n+\n+\t* sem_ch8.adb: Change Assert to be consistent with\n+\tother similar ones.\n+\n+2017-09-06  Bob Duff  <duff@adacore.com>\n+\n+\t* binde.adb (Find_Elab_Order): Do not run Elab_Old unless\n+\trequested. Previously, the -do switch meant \"run Elab_New and\n+\tElab_Old and use the order chosen by Elab_Old, possibly with\n+\tdebugging printouts comparing the two orders.\"\tNow it means\n+\t\"do not run Elab_New.\" This is of use if there are bugs that\n+\tcause Elab_New to crash.\n+\t(Elab_Position, Num_Chosen): Change type to Nat, to avoid various\n+\ttype conversions.\n+\t* ali.ads (Elab_Position): Change type to Nat, to avoid various\n+\ttype conversions.\n+\n+2017-09-06  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* sem_prag.adb (Check_Mode_Restriction_In_Enclosing_Context): Fix\n+\treference to SPARK RM.\n+\n+2017-09-06  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* layout.adb: Use SSU short hand consistently throughout the file.\n+\n+2017-09-06  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* freeze.adb (Freeze_Record_Type)\n+\t<Sized_Component_Total_Round_RM_Size>: New local variable to\n+\taccumulate the rounded RM_Size of components.  Update it for\n+\tevery component whose RM_Size is statically known.  Add missing\n+\tguard to check that bit packing is really required before issuing\n+\tthe error about packing.  Swap condition for clarity's sake.\n+\t* sem_prag.adb (Usage_Error): fix reference to\n+\tSPARK RM in comment\n+\n+2017-09-06  Fedor Rybin  <frybin@adacore.com>\n+\n+\t* makeutl.adb, makeutl.ads, mlib.adb, mlib.ads, mlib-fil.adb,\n+\tmlib-fil.ads, mlib-prj.adb, mlib-prj.ads, mlib-tgt.adb, mlib-tgt.ads,\n+\tmlib-tgt-specific.adb, mlib-tgt-specific.ads,\n+\tmlib-tgt-specific-aix.adb, mlib-tgt-specific-darwin.adb,\n+\tmlib-tgt-specific-hpux.adb, mlib-tgt-specific-linux.adb,\n+\tmlib-tgt-specific-mingw.adb, mlib-tgt-specific-solaris.adb,\n+\tmlib-tgt-specific-vxworks.adb, mlib-tgt-specific-xi.adb, mlib-utl.adb,\n+\tmlib-utl.ads, prj.adb, prj.ads, prj-attr.adb, prj-attr.ads,\n+\tprj-attr-pm.adb, prj-attr-pm.ads, prj-com.ads, prj-conf.adb,\n+\tprj-conf.ads, prj-dect.adb, prj-dect.ads, prj-env.adb, prj-env.ads,\n+\tprj-err.adb, prj-err.ads, prj-ext.adb, prj-ext.ads, prj-makr.adb,\n+\tprj-makr.ads, prj-nmsc.adb, prj-nmsc.ads, prj-pars.adb, prj-pars.ads,\n+\tprj-part.adb, prj-part.ads, prj-pp.adb, prj-pp.ads, prj-proc.adb,\n+\tprj-proc.ads, prj-strt.adb, prj-strt.ads, prj-tree.adb, prj-tree.ads,\n+\tprj-util.adb, prj-util.ads, sinput-p.adb, sinput-p.ads: Remove obsolete\n+\tproject manager sources.\n+\n+2017-09-06  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch5.adb (Analyze_Assigment): If the left-hand side is an\n+\tentity of a mutable type and the right-hand side is a conditional\n+\texpression, resolve the alternatives of the conditional using\n+\tthe base type of the target entity, because the alternatives\n+\tmay have distinct subtypes. This is particularly relevant if\n+\tthe alternatives are aggregates.\n+\n 2017-09-06  Ed Schonberg  <schonberg@adacore.com>\n \n \t* checks.adb (Apply_Predicate_Check): If the expression is an"}, {"sha": "e15a1c455bdf87dffc303a5524939efb778d1cd4", "filename": "gcc/ada/ali.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c48e0f27232aa6604b80e0d15b6ecb50604400a7/gcc%2Fada%2Fali.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c48e0f27232aa6604b80e0d15b6ecb50604400a7/gcc%2Fada%2Fali.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fali.ads?ref=c48e0f27232aa6604b80e0d15b6ecb50604400a7", "patch": "@@ -361,7 +361,7 @@ package ALI is\n       --  used for informational output, and also for constructing the main\n       --  unit if it is being built in Ada.\n \n-      Elab_Position : aliased Natural;\n+      Elab_Position : Nat;\n       --  Initialized to zero. Set non-zero when a unit is chosen and\n       --  placed in the elaboration order. The value represents the\n       --  ordinal position in the elaboration order."}, {"sha": "329c6ca395fe997bf8199ade7e5cc1d9a4d5c19d", "filename": "gcc/ada/binde.adb", "status": "modified", "additions": 124, "deletions": 97, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c48e0f27232aa6604b80e0d15b6ecb50604400a7/gcc%2Fada%2Fbinde.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c48e0f27232aa6604b80e0d15b6ecb50604400a7/gcc%2Fada%2Fbinde.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbinde.adb?ref=c48e0f27232aa6604b80e0d15b6ecb50604400a7", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -229,7 +229,7 @@ package body Binde is\n       --  Used in computing transitive closure for Elaborate_All and also in\n       --  locating cycles and paths in the diagnose routines.\n \n-      Elab_Position : Natural;\n+      Elab_Position : Nat;\n       --  Initialized to zero. Set non-zero when a unit is chosen and placed in\n       --  the elaboration order. The value represents the ordinal position in\n       --  the elaboration order.\n@@ -279,7 +279,7 @@ package body Binde is\n    --  Current unit, set by Gather_Dependencies, and picked up in Build_Link to\n    --  set the Reason_Unit field of the created dependency link.\n \n-   Num_Chosen : Natural;\n+   Num_Chosen : Nat;\n    --  Number of units chosen in the elaboration order so far\n \n    -----------------------\n@@ -329,7 +329,8 @@ package body Binde is\n    --  the reason for the link is R. Ea_Id is the contents to be placed in the\n    --  Elab_All_Link of the entry.\n \n-   procedure Choose (Elab_Order : in out Unit_Id_Table; Chosen : Unit_Id);\n+   procedure Choose (Elab_Order : in out Unit_Id_Table; Chosen : Unit_Id;\n+                     Msg : String);\n    --  Chosen is the next entry chosen in the elaboration order. This procedure\n    --  updates all data structures appropriately.\n \n@@ -984,7 +985,9 @@ package body Binde is\n    -- Choose --\n    ------------\n \n-   procedure Choose (Elab_Order : in out Unit_Id_Table; Chosen : Unit_Id) is\n+   procedure Choose (Elab_Order : in out Unit_Id_Table; Chosen : Unit_Id;\n+                     Msg : String)\n+   is\n       pragma Assert (Chosen /= No_Unit_Id);\n       S : Successor_Id;\n       U : Unit_Id;\n@@ -993,7 +996,7 @@ package body Binde is\n       if Debug_Flag_C then\n          Write_Str (\"Choosing Unit \");\n          Write_Unit_Name (Units.Table (Chosen).Uname);\n-         Write_Eol;\n+         Write_Str (Msg);\n       end if;\n \n       --  We shouldn't be choosing something with unelaborated predecessors,\n@@ -1081,7 +1084,18 @@ package body Binde is\n       Num_Chosen := Num_Chosen + 1;\n \n       pragma Assert\n-        (Errors_Detected > 0 or else Num_Chosen = Natural (Last (Elab_Order)));\n+        (Errors_Detected > 0 or else Num_Chosen = Last (Elab_Order));\n+      pragma Assert (Units.Last = UNR.Last);\n+      pragma Assert (Num_Chosen + Num_Left = Int (UNR.Last));\n+      if Debug_Flag_C then\n+         Write_Str (\" \");\n+         Write_Int (Int (Num_Chosen));\n+         Write_Str (\"+\");\n+         Write_Int (Num_Left);\n+         Write_Str (\"=\");\n+         Write_Int (Int (UNR.Last));\n+         Write_Eol;\n+      end if;\n \n       UNR.Table (Chosen).Elab_Position := Num_Chosen;\n \n@@ -1099,7 +1113,8 @@ package body Binde is\n          then\n             null;\n          else\n-            Choose (Elab_Order, Corresponding_Body (Chosen));\n+            Choose (Elab_Order, Corresponding_Body (Chosen),\n+                    \" [Elaborate_Body]\");\n          end if;\n       end if;\n    end Choose;\n@@ -1196,7 +1211,7 @@ package body Binde is\n             --  sufficiently long, generate error message and return True.\n \n             if U = Uto and then PL >= ML then\n-               Choose (Elab_Order, U);\n+               Choose (Elab_Order, U, \" [Find_Link: base]\");\n                return True;\n \n             --  All done if already visited\n@@ -1213,7 +1228,7 @@ package body Binde is\n                while S /= No_Successor loop\n                   if Find_Link (Succ.Table (S).After, PL + 1) then\n                      Elab_Error_Msg (S);\n-                     Choose (Elab_Order, U);\n+                     Choose (Elab_Order, U, \" [Find_Link: recursive]\");\n                      return True;\n                   end if;\n \n@@ -1591,7 +1606,7 @@ package body Binde is\n          Error_Msg (\"?since all units compiled with static elaboration model\");\n       end if;\n \n-      if Do_New then\n+      if Do_New and not Debug_Flag_Old and not Debug_Flag_Older then\n          if Debug_Flag_V then\n             Write_Line (\"Doing new...\");\n          end if;\n@@ -1602,13 +1617,14 @@ package body Binde is\n       end if;\n \n       --  Elab_New does not support the pessimistic order, so if that was\n-      --  requested, use the old results. Use Elab_Old if -dp was selected.\n-      --  Elab_New does not yet give proper error messages for illegal\n-      --  Elaborate_Alls, so if there is one, run Elab_Old.\n+      --  requested, use the old results. Use Elab_Old if -dp or -do was\n+      --  selected. Elab_New does not yet give proper error messages for\n+      --  illegal Elaborate_Alls, so if there is one, run Elab_Old.\n \n       if Do_Old\n         or Pessimistic_Elab_Order\n         or Debug_Flag_Old\n+        or Debug_Flag_Older\n         or Illegal_Elab_All\n       then\n          if Debug_Flag_V then\n@@ -1623,119 +1639,129 @@ package body Binde is\n       declare\n          Old_Order : Unit_Id_Array renames\n                        Old_Elab_Order.Table (1 .. Last (Old_Elab_Order));\n-         New_Order : Unit_Id_Array renames\n-                       Elab_Order.Table (1 .. Last (Elab_Order));\n-         Old_Pairs : constant Nat := Num_Spec_Body_Pairs (Old_Order);\n-         New_Pairs : constant Nat := Num_Spec_Body_Pairs (New_Order);\n-\n       begin\n          if Do_Old and Do_New then\n-            Write_Line (Get_Name_String (First_Main_Lib_File));\n-\n-            pragma Assert (Old_Order'Length = New_Order'Length);\n-            pragma Debug (Validate (Old_Order, Doing_New => False));\n-            pragma Debug (Validate (New_Order, Doing_New => True));\n+            declare\n+               New_Order : Unit_Id_Array renames\n+                             Elab_Order.Table (1 .. Last (Elab_Order));\n+               Old_Pairs : constant Nat := Num_Spec_Body_Pairs (Old_Order);\n+               New_Pairs : constant Nat := Num_Spec_Body_Pairs (New_Order);\n \n-            --  Misc debug printouts that can be used for experimentation by\n-            --  changing the 'if's below.\n+            begin\n+               Write_Line (Get_Name_String (First_Main_Lib_File));\n \n-            if True then\n-               if New_Order = Old_Order then\n-                  Write_Line (\"Elab_New: same order.\");\n-               else\n-                  Write_Line (\"Elab_New: diff order.\");\n-               end if;\n-            end if;\n+               pragma Assert (Old_Order'Length = New_Order'Length);\n+               pragma Debug (Validate (Old_Order, Doing_New => False));\n+               pragma Debug (Validate (New_Order, Doing_New => True));\n \n-            if New_Order /= Old_Order and then False then\n-               Write_Line (\"Elaboration orders differ:\");\n-               Write_Elab_Order\n-                 (Old_Order, Title => \"OLD ELABORATION ORDER\");\n-               Write_Elab_Order\n-                 (New_Order, Title => \"NEW ELABORATION ORDER\");\n-            end if;\n+               --  Misc debug printouts that can be used for experimentation by\n+               --  changing the 'if's below.\n \n-            if True then\n-               Write_Str (\"Pairs: \");\n-               Write_Int (Old_Pairs);\n+               if True then\n+                  if New_Order = Old_Order then\n+                     Write_Line (\"Elab_New: same order.\");\n+                  else\n+                     Write_Line (\"Elab_New: diff order.\");\n+                  end if;\n+               end if;\n \n-               if Old_Pairs = New_Pairs then\n-                  Write_Str (\" = \");\n-               elsif Old_Pairs < New_Pairs then\n-                  Write_Str (\" < \");\n-               else\n-                  Write_Str (\" > \");\n+               if New_Order /= Old_Order and then False then\n+                  Write_Line (\"Elaboration orders differ:\");\n+                  Write_Elab_Order\n+                    (Old_Order, Title => \"OLD ELABORATION ORDER\");\n+                  Write_Elab_Order\n+                    (New_Order, Title => \"NEW ELABORATION ORDER\");\n                end if;\n \n-               Write_Int (New_Pairs);\n-               Write_Eol;\n-            end if;\n+               if True then\n+                  Write_Str (\"Pairs: \");\n+                  Write_Int (Old_Pairs);\n \n-            if Old_Pairs /= New_Pairs and then False then\n-               Write_Str (\"Pairs: \");\n-               Write_Int (Old_Pairs);\n+                  if Old_Pairs = New_Pairs then\n+                     Write_Str (\" = \");\n+                  elsif Old_Pairs < New_Pairs then\n+                     Write_Str (\" < \");\n+                  else\n+                     Write_Str (\" > \");\n+                  end if;\n \n-               if Old_Pairs < New_Pairs then\n-                  Write_Str (\" < \");\n-               else\n-                  Write_Str (\" > \");\n+                  Write_Int (New_Pairs);\n+                  Write_Eol;\n                end if;\n \n-               Write_Int (New_Pairs);\n-               Write_Eol;\n+               if Old_Pairs /= New_Pairs and then False then\n+                  Write_Str (\"Pairs: \");\n+                  Write_Int (Old_Pairs);\n \n-               if Old_Pairs /= New_Pairs and then Debug_Flag_V then\n-                  Write_Elab_Order\n-                    (Old_Order, Title => \"OLD ELABORATION ORDER\");\n-                  Write_Elab_Order\n-                    (New_Order, Title => \"NEW ELABORATION ORDER\");\n-                  pragma Assert (New_Pairs >= Old_Pairs);\n+                  if Old_Pairs < New_Pairs then\n+                     Write_Str (\" < \");\n+                  else\n+                     Write_Str (\" > \");\n+                  end if;\n+\n+                  Write_Int (New_Pairs);\n+                  Write_Eol;\n+\n+                  if Old_Pairs /= New_Pairs and then Debug_Flag_V then\n+                     Write_Elab_Order\n+                       (Old_Order, Title => \"OLD ELABORATION ORDER\");\n+                     Write_Elab_Order\n+                       (New_Order, Title => \"NEW ELABORATION ORDER\");\n+                     pragma Assert (New_Pairs >= Old_Pairs);\n+                  end if;\n                end if;\n-            end if;\n+            end;\n          end if;\n \n          --  The Elab_New algorithm doesn't implement the -p switch, so if that\n-         --  was used, use the results from the old algorithm.\n-\n-         if Pessimistic_Elab_Order or Debug_Flag_Old then\n-            New_Order := Old_Order;\n+         --  was used, use the results from the old algorithm. Likewise if the\n+         --  user has requested the old algorithm.\n+\n+         if Pessimistic_Elab_Order or Debug_Flag_Old or Debug_Flag_Older then\n+            pragma Assert\n+              (Last (Elab_Order) = 0\n+                 or else Last (Elab_Order) = Old_Order'Last);\n+            Init (Elab_Order);\n+            Append_All (Elab_Order, Old_Order);\n          end if;\n \n          --  Now set the Elab_Positions in the Units table. It is important to\n          --  do this late, in case we're running both Elab_New and Elab_Old.\n \n          declare\n+            New_Order : Unit_Id_Array renames\n+                          Elab_Order.Table (1 .. Last (Elab_Order));\n             Units_Array : Units.Table_Type renames\n                             Units.Table (Units.First .. Units.Last);\n-\n          begin\n             for J in New_Order'Range loop\n                pragma Assert\n-                 (UNR.Table (New_Order (J)).Elab_Position = Positive (J));\n-               Units_Array  (New_Order (J)).Elab_Position := Positive (J);\n+                 (UNR.Table (New_Order (J)).Elab_Position = J);\n+               Units_Array  (New_Order (J)).Elab_Position := J;\n             end loop;\n-         end;\n \n-         if Errors_Detected = 0 then\n+            if Errors_Detected = 0 then\n \n-            --  Display elaboration order if -l was specified\n+               --  Display elaboration order if -l was specified\n \n-            if Elab_Order_Output then\n-               if Zero_Formatting then\n-                  Write_Elab_Order (New_Order, Title => \"\");\n-               else\n-                  Write_Elab_Order (New_Order, Title => \"ELABORATION ORDER\");\n+               if Elab_Order_Output then\n+                  if Zero_Formatting then\n+                     Write_Elab_Order (New_Order, Title => \"\");\n+                  else\n+                     Write_Elab_Order\n+                       (New_Order, Title => \"ELABORATION ORDER\");\n+                  end if;\n                end if;\n-            end if;\n \n-            --  Display list of sources in the closure (except predefined\n-            --  sources) if -R was used. Include predefined sources if -Ra\n-            --  was used.\n+               --  Display list of sources in the closure (except predefined\n+               --  sources) if -R was used. Include predefined sources if -Ra\n+               --  was used.\n \n-            if List_Closure then\n-               Write_Closure (New_Order);\n+               if List_Closure then\n+                  Write_Closure (New_Order);\n+               end if;\n             end if;\n-         end if;\n+         end;\n       end;\n    end Find_Elab_Order;\n \n@@ -2927,7 +2953,7 @@ package body Binde is\n             --  a circularity. In the latter case, diagnose the circularity,\n             --  removing it from the graph and continue.\n             --  ????But Diagnose_Elaboration_Problem always raises an\n-            --  exception.\n+            --  exception, so the loop never goes around more than once.\n \n             Get_No_Pred : while No_Pred = No_Unit_Id loop\n                exit Outer when Num_Left < 1;\n@@ -2979,7 +3005,7 @@ package body Binde is\n \n             --  Choose the best candidate found\n \n-            Choose (Elab_Order, Best_So_Far);\n+            Choose (Elab_Order, Best_So_Far, \" [Best_So_Far]\");\n \n             --  If it's a spec with a body, and the body is not yet chosen,\n             --  choose the body if possible. The case where the body is\n@@ -3007,7 +3033,8 @@ package body Binde is\n                   end if;\n \n                   if Choose_The_Body then\n-                     Choose (Elab_Order, Corresponding_Body (Best_So_Far));\n+                     Choose (Elab_Order, Corresponding_Body (Best_So_Far),\n+                             \" [body]\");\n                   end if;\n                end;\n             end if;\n@@ -3027,7 +3054,7 @@ package body Binde is\n                        and then UNR.Table (SCC (J)).Num_Pred = 0\n                      then\n                         Chose_One_Or_More := True;\n-                        Choose (Elab_Order, SCC (J));\n+                        Choose (Elab_Order, SCC (J), \" [same SCC]\");\n                      end if;\n                   end loop;\n \n@@ -3074,7 +3101,7 @@ package body Binde is\n          pragma Assert (SCC (U) = U);\n       begin\n          for J in Nodes (U)'Range loop\n-            Write_Int (Int (UNR.Table (Nodes (U) (J)).Elab_Position));\n+            Write_Int (UNR.Table (Nodes (U) (J)).Elab_Position);\n             Write_Str (\". \");\n             Write_Unit_Name (Units.Table (Nodes (U) (J)).Uname);\n             Write_Eol;\n@@ -3125,7 +3152,7 @@ package body Binde is\n             --  a circularity. In the latter case, diagnose the circularity,\n             --  removing it from the graph and continue.\n             --  ????But Diagnose_Elaboration_Problem always raises an\n-            --  exception.\n+            --  exception, so the loop never goes around more than once.\n \n             Get_No_Pred : while No_Pred = No_Unit_Id loop\n                exit Outer when Num_Left < 1;\n@@ -3173,7 +3200,7 @@ package body Binde is\n \n             --  Choose the best candidate found\n \n-            Choose (Elab_Order, Best_So_Far);\n+            Choose (Elab_Order, Best_So_Far, \" [Elab_Old Best_So_Far]\");\n          end loop Outer;\n       end Find_Elab_Order;\n "}, {"sha": "66e8e85a4581a5fa693309855ebdc4c8f1911d18", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 29, "deletions": 14, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c48e0f27232aa6604b80e0d15b6ecb50604400a7/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c48e0f27232aa6604b80e0d15b6ecb50604400a7/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=c48e0f27232aa6604b80e0d15b6ecb50604400a7", "patch": "@@ -3818,6 +3818,10 @@ package body Freeze is\n          --  Accumulates total RM_Size values of all sized components. Used\n          --  for processing of Implicit_Packing.\n \n+         Sized_Component_Total_Round_RM_Size : Uint := Uint_0;\n+         --  Accumulates total RM_Size values of all sized components, rounded\n+         --  individually to a multiple of the storage unit.\n+\n          SSO_ADC : Node_Id;\n          --  Scalar_Storage_Order attribute definition clause for the record\n \n@@ -4123,21 +4127,31 @@ package body Freeze is\n             --  an implicit subtype declaration.\n \n             if Known_Static_RM_Size (Etype (Comp)) then\n-               Sized_Component_Total_RM_Size :=\n-                 Sized_Component_Total_RM_Size + RM_Size (Etype (Comp));\n+               declare\n+                  Comp_Type : constant Entity_Id := Etype (Comp);\n+                  Comp_Size : constant Uint := RM_Size (Comp_Type);\n+                  SSU : constant Int := Ttypes.System_Storage_Unit;\n+               begin\n+                  Sized_Component_Total_RM_Size :=\n+                    Sized_Component_Total_RM_Size + Comp_Size;\n \n-               if Present (Underlying_Type (Etype (Comp)))\n-                 and then Is_Elementary_Type (Underlying_Type (Etype (Comp)))\n-               then\n-                  Elem_Component_Total_Esize :=\n-                    Elem_Component_Total_Esize + Esize (Etype (Comp));\n-               else\n-                  All_Elem_Components := False;\n+                  Sized_Component_Total_Round_RM_Size :=\n+                    Sized_Component_Total_Round_RM_Size +\n+                      (Comp_Size + SSU - 1) / SSU * SSU;\n \n-                  if RM_Size (Etype (Comp)) mod System_Storage_Unit /= 0 then\n-                     All_Storage_Unit_Components := False;\n+                  if Present (Underlying_Type (Comp_Type))\n+                    and then Is_Elementary_Type (Underlying_Type (Comp_Type))\n+                  then\n+                     Elem_Component_Total_Esize :=\n+                       Elem_Component_Total_Esize + Esize (Comp_Type);\n+                  else\n+                     All_Elem_Components := False;\n+\n+                     if Comp_Size mod SSU /= 0 then\n+                        All_Storage_Unit_Components := False;\n+                     end if;\n                   end if;\n-               end if;\n+               end;\n             else\n                All_Sized_Components := False;\n             end if;\n@@ -4603,12 +4617,13 @@ package body Freeze is\n                  and then RM_Size (Rec) < Elem_Component_Total_Esize)\n              or else\n                (not All_Elem_Components\n-                 and then not All_Storage_Unit_Components))\n+                 and then not All_Storage_Unit_Components\n+                 and then RM_Size (Rec) < Sized_Component_Total_Round_RM_Size))\n \n            --  And the total RM size cannot be greater than the specified size\n            --  since otherwise packing will not get us where we have to be.\n \n-           and then RM_Size (Rec) >= Sized_Component_Total_RM_Size\n+           and then Sized_Component_Total_RM_Size <= RM_Size (Rec)\n \n            --  Never do implicit packing in CodePeer or SPARK modes since\n            --  we don't do any packing in these modes, since this generates"}, {"sha": "577cf0403d998ba999a816174adb42bc7f4197c1", "filename": "gcc/ada/layout.adb", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c48e0f27232aa6604b80e0d15b6ecb50604400a7/gcc%2Fada%2Flayout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c48e0f27232aa6604b80e0d15b6ecb50604400a7/gcc%2Fada%2Flayout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flayout.adb?ref=c48e0f27232aa6604b80e0d15b6ecb50604400a7", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -2728,8 +2728,8 @@ package body Layout is\n                --  this means it will be storage-unit addressable).\n \n                if Is_Scalar_Type (E) then\n-                  if Size <= System_Storage_Unit then\n-                     Init_Esize (E, System_Storage_Unit);\n+                  if Size <= SSU then\n+                     Init_Esize (E, SSU);\n                   elsif Size <= 16 then\n                      Init_Esize (E, 16);\n                   elsif Size <= 32 then\n@@ -2741,7 +2741,7 @@ package body Layout is\n                   --  Finally, make sure that alignment is consistent with\n                   --  the newly assigned size.\n \n-                  while Alignment (E) * System_Storage_Unit < Esize (E)\n+                  while Alignment (E) * SSU < Esize (E)\n                     and then Alignment (E) < Maximum_Alignment\n                   loop\n                      Set_Alignment (E, 2 * Alignment (E));\n@@ -2971,23 +2971,23 @@ package body Layout is\n          --  Reset alignment to match size if the known size is exactly 2, 4,\n          --  or 8 storage units.\n \n-         if Siz = 2 * System_Storage_Unit then\n+         if Siz = 2 * SSU then\n             Align := 2;\n-         elsif Siz = 4 * System_Storage_Unit then\n+         elsif Siz = 4 * SSU then\n             Align := 4;\n-         elsif Siz = 8 * System_Storage_Unit then\n+         elsif Siz = 8 * SSU then\n             Align := 8;\n \n             --  If Optimize_Alignment is set to Space, then make sure the\n             --  alignment matches the size, for example, if the size is 17\n             --  bytes then we want an alignment of 1 for the type.\n \n          elsif Optimize_Alignment_Space (E) then\n-            if Siz mod (8 * System_Storage_Unit) = 0 then\n+            if Siz mod (8 * SSU) = 0 then\n                Align := 8;\n-            elsif Siz mod (4 * System_Storage_Unit) = 0 then\n+            elsif Siz mod (4 * SSU) = 0 then\n                Align := 4;\n-            elsif Siz mod (2 * System_Storage_Unit) = 0 then\n+            elsif Siz mod (2 * SSU) = 0 then\n                Align := 2;\n             else\n                Align := 1;\n@@ -2998,14 +2998,14 @@ package body Layout is\n             --  alignment of 4.\n \n          elsif Optimize_Alignment_Time (E)\n-           and then Siz > System_Storage_Unit\n-           and then Siz <= 8 * System_Storage_Unit\n+           and then Siz > SSU\n+           and then Siz <= 8 * SSU\n          then\n-            if Siz <= 2 * System_Storage_Unit then\n+            if Siz <= 2 * SSU then\n                Align := 2;\n-            elsif Siz <= 4 * System_Storage_Unit then\n+            elsif Siz <= 4 * SSU then\n                Align := 4;\n-            else -- Siz <= 8 * System_Storage_Unit then\n+            else -- Siz <= 8 * SSU then\n                Align := 8;\n             end if;\n \n@@ -3034,10 +3034,10 @@ package body Layout is\n          --  words in any case. Omit this if we are optimizing for time,\n          --  since conceivably we may be able to do better.\n \n-         if Align > System_Word_Size / System_Storage_Unit\n+         if Align > System_Word_Size / SSU\n            and then not Optimize_Alignment_Time (E)\n          then\n-            Align := System_Word_Size / System_Storage_Unit;\n+            Align := System_Word_Size / SSU;\n          end if;\n \n          --  Check components. If any component requires a higher alignment,\n@@ -3068,8 +3068,7 @@ package body Layout is\n                             (Unknown_Esize (Comp)\n                               or else (Known_Static_Esize (Comp)\n                                         and then\n-                                          Esize (Comp) =\n-                                              Calign * System_Storage_Unit))\n+                                       Esize (Comp) = Calign * SSU))\n                         then\n                            Align := UI_To_Int (Calign);\n                         end if;\n@@ -3088,9 +3087,9 @@ package body Layout is\n       Set_Alignment (E, UI_From_Int (Align));\n \n       if Known_Static_Esize (E)\n-        and then Esize (E) < Align * System_Storage_Unit\n+        and then Esize (E) < Align * SSU\n       then\n-         Set_Esize (E, UI_From_Int (Align * System_Storage_Unit));\n+         Set_Esize (E, UI_From_Int (Align * SSU));\n       end if;\n    end Set_Composite_Alignment;\n "}, {"sha": "53233a02e306475960154fda550224962b818346", "filename": "gcc/ada/makeutl.adb", "status": "removed", "additions": 0, "deletions": 3595, "changes": 3595, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fmakeutl.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fmakeutl.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeutl.adb?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793"}, {"sha": "c13a151dcb28a15b7ea6c4a6ac20ddb9509c5a0d", "filename": "gcc/ada/makeutl.ads", "status": "removed", "additions": 0, "deletions": 615, "changes": 615, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fmakeutl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fmakeutl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeutl.ads?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793", "patch": "@@ -1,615 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                              M A K E U T L                               --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---          Copyright (C) 2004-2015, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This package contains various subprograms used by the builders, in\n---  particular those subprograms related to project management and build\n---  queue management.\n-\n-with ALI;\n-with Namet;    use Namet;\n-with Opt;\n-with Osint;\n-with Prj;      use Prj;\n-with Prj.Tree;\n-with Snames;   use Snames;\n-with Table;\n-with Types;    use Types;\n-\n-with GNAT.OS_Lib; use GNAT.OS_Lib;\n-\n-package Makeutl is\n-\n-   type Fail_Proc is access procedure (S : String);\n-   --  Pointer to procedure which outputs a failure message\n-\n-   Root_Environment : Prj.Tree.Environment;\n-   --  The environment coming from environment variables and command line\n-   --  switches. When we do not have an aggregate project, this is used for\n-   --  parsing the project tree. When we have an aggregate project, this is\n-   --  used to parse the aggregate project; the latter then generates another\n-   --  environment (with additional external values and project path) to parse\n-   --  the aggregated projects.\n-\n-   Default_Config_Name : constant String := \"default.cgpr\";\n-   --  Name of the configuration file used by gprbuild and generated by\n-   --  gprconfig by default.\n-\n-   On_Windows : constant Boolean := Directory_Separator = '\\';\n-   --  True when on Windows\n-\n-   Source_Info_Option : constant String := \"--source-info=\";\n-   --  Switch to indicate the source info file\n-\n-   Subdirs_Option : constant String := \"--subdirs=\";\n-   --  Switch used to indicate that the real directories (object, exec,\n-   --  library, ...) are subdirectories of those in the project file.\n-\n-   Relocate_Build_Tree_Option : constant String := \"--relocate-build-tree\";\n-   --  Switch to build out-of-tree. In this context the object, exec and\n-   --  library directories are relocated to the current working directory\n-   --  or the directory specified as parameter to this option.\n-\n-   Root_Dir_Option : constant String := \"--root-dir\";\n-   --  The root directory under which all artifacts (objects, library, ali)\n-   --  directory are to be found for the current compilation. This directory\n-   --  will be used to relocate artifacts based on this directory. If this\n-   --  option is not specificed the default value is the directory of the\n-   --  main project.\n-\n-   Unchecked_Shared_Lib_Imports : constant String :=\n-                                    \"--unchecked-shared-lib-imports\";\n-   --  Command line switch to allow shared library projects to import projects\n-   --  that are not shared library projects.\n-\n-   Single_Compile_Per_Obj_Dir_Switch : constant String :=\n-                                         \"--single-compile-per-obj-dir\";\n-   --  Switch to forbid simultaneous compilations for the same object directory\n-   --  when project files are used.\n-\n-   Create_Map_File_Switch : constant String := \"--create-map-file\";\n-   --  Switch to create a map file when an executable is linked\n-\n-   No_Exit_Message_Option : constant String := \"--no-exit-message\";\n-   --  Switch to suppress exit error message when there are compilation\n-   --  failures. This is useful when a tool, such as gnatprove, silently calls\n-   --  the builder and does not want to pollute its output with error messages\n-   --  coming from the builder. This is an internal switch.\n-\n-   Keep_Temp_Files_Option : constant String := \"--keep-temp-files\";\n-   --  Switch to suppress deletion of temp files created by the builder.\n-   --  Note that debug switch -gnatdn also has this effect.\n-\n-   Load_Standard_Base : Boolean := True;\n-   --  False when gprbuild is called with --db-\n-\n-   package Db_Switch_Args is new Table.Table\n-     (Table_Component_Type => Name_Id,\n-      Table_Index_Type     => Integer,\n-      Table_Low_Bound      => 1,\n-      Table_Initial        => 200,\n-      Table_Increment      => 100,\n-      Table_Name           => \"Makegpr.Db_Switch_Args\");\n-   --  Table of all the arguments of --db switches of gprbuild\n-\n-   package Directories is new Table.Table\n-     (Table_Component_Type => Path_Name_Type,\n-      Table_Index_Type     => Integer,\n-      Table_Low_Bound      => 1,\n-      Table_Initial        => 200,\n-      Table_Increment      => 100,\n-      Table_Name           => \"Makegpr.Directories\");\n-   --  Table of all the source or object directories, filled up by\n-   --  Get_Directories.\n-\n-   procedure Add\n-     (Option : String_Access;\n-      To     : in out String_List_Access;\n-      Last   : in out Natural);\n-   procedure Add\n-     (Option : String;\n-      To     : in out String_List_Access;\n-      Last   : in out Natural);\n-   --  Add a string to a list of strings\n-\n-   function Absolute_Path\n-     (Path    : Path_Name_Type;\n-      Project : Project_Id) return String;\n-   --  Returns an absolute path for a configuration pragmas file\n-\n-   function Create_Binder_Mapping_File\n-     (Project_Tree : Project_Tree_Ref) return Path_Name_Type;\n-   --  Create a binder mapping file and returns its path name\n-\n-   function Create_Name (Name : String) return File_Name_Type;\n-   function Create_Name (Name : String) return Name_Id;\n-   function Create_Name (Name : String) return Path_Name_Type;\n-   --  Get an id for a name\n-\n-   function Base_Name_Index_For\n-     (Main            : String;\n-      Main_Index      : Int;\n-      Index_Separator : Character) return File_Name_Type;\n-   --  Returns the base name of Main, without the extension, followed by the\n-   --  Index_Separator followed by the Main_Index if it is non-zero.\n-\n-   function Executable_Prefix_Path return String;\n-   --  Return the absolute path parent directory of the directory where the\n-   --  current executable resides, if its directory is named \"bin\", otherwise\n-   --  return an empty string. When a directory is returned, it is guaranteed\n-   --  to end with a directory separator.\n-\n-   procedure Inform (N : Name_Id := No_Name; Msg : String);\n-   procedure Inform (N : File_Name_Type; Msg : String);\n-   --  Prints out the program name followed by a colon, N and S\n-\n-   function File_Not_A_Source_Of\n-     (Project_Tree : Project_Tree_Ref;\n-      Uname        : Name_Id;\n-      Sfile        : File_Name_Type) return Boolean;\n-   --  Check that file name Sfile is one of the source of unit Uname. Returns\n-   --  True if the unit is in one of the project file, but the file name is not\n-   --  one of its source. Returns False otherwise.\n-\n-   function Check_Source_Info_In_ALI\n-     (The_ALI      : ALI.ALI_Id;\n-      Tree         : Project_Tree_Ref) return Name_Id;\n-   --  Check whether all file references in ALI are still valid (i.e. the\n-   --  source files are still associated with the same units). Return the name\n-   --  of the unit if everything is still valid. Return No_Name otherwise.\n-\n-   procedure Ensure_Absolute_Path\n-     (Switch               : in out String_Access;\n-      Parent               : String;\n-      Do_Fail              : Fail_Proc;\n-      For_Gnatbind         : Boolean := False;\n-      Including_Non_Switch : Boolean := True;\n-      Including_RTS        : Boolean := False);\n-   --  Do nothing if Switch is an absolute path switch. If relative, fail if\n-   --  Parent is the empty string, otherwise prepend the path with Parent. This\n-   --  subprogram is only used when using project files. If For_Gnatbind is\n-   --  True, consider gnatbind specific syntax for -L (not a path, left\n-   --  unchanged) and -A (path is optional, preceded with \"=\" if present).\n-   --  If Including_RTS is True, process also switches --RTS=. Do_Fail is\n-   --  called in case of error. Using Osint.Fail might be appropriate.\n-\n-   function Is_Subunit (Source : Source_Id) return Boolean;\n-   --  Return True if source is a subunit\n-\n-   procedure Initialize_Source_Record (Source : Source_Id);\n-   --  Get information either about the source file, or the object and\n-   --  dependency file, as well as their timestamps.\n-\n-   function Is_External_Assignment\n-     (Env  : Prj.Tree.Environment;\n-      Argv : String) return Boolean;\n-   --  Verify that an external assignment switch is syntactically correct\n-   --\n-   --  Correct forms are:\n-   --\n-   --      -Xname=value\n-   --      -X\"name=other value\"\n-   --\n-   --  Assumptions: 'First = 1, Argv (1 .. 2) = \"-X\"\n-   --\n-   --  When this function returns True, the external assignment has been\n-   --  entered by a call to Prj.Ext.Add, so that in a project file, External\n-   --  (\"name\") will return \"value\".\n-\n-   type Name_Ids is array (Positive range <>) of Name_Id;\n-   No_Names : constant Name_Ids := (1 .. 0 => No_Name);\n-   --  Name_Ids is used for list of language names in procedure Get_Directories\n-   --  below.\n-\n-   Ada_Only : constant Name_Ids := (1 => Name_Ada);\n-   --  Used to invoke Get_Directories in gnatmake\n-\n-   type Activity_Type is (Compilation, Executable_Binding, SAL_Binding);\n-\n-   procedure Get_Directories\n-     (Project_Tree : Project_Tree_Ref;\n-      For_Project  : Project_Id;\n-      Activity     : Activity_Type;\n-      Languages    : Name_Ids);\n-   --  Put in table Directories the source (when Sources is True) or\n-   --  object/library (when Sources is False) directories of project\n-   --  For_Project and of all the project it imports directly or indirectly.\n-   --  The source directories of imported projects are only included if one\n-   --  of the declared languages is in the list Languages.\n-\n-   function Aggregate_Libraries_In (Tree : Project_Tree_Ref) return Boolean;\n-   --  Return True iff there is one or more aggregate library projects in\n-   --  the project tree Tree.\n-\n-   procedure Write_Path_File (FD : File_Descriptor);\n-   --  Write in the specified open path file the directories in table\n-   --  Directories, then closed the path file.\n-\n-   procedure Get_Switches\n-     (Source       : Source_Id;\n-      Pkg_Name     : Name_Id;\n-      Project_Tree : Project_Tree_Ref;\n-      Value        : out Variable_Value;\n-      Is_Default   : out Boolean);\n-   procedure Get_Switches\n-     (Source_File         : File_Name_Type;\n-      Source_Lang         : Name_Id;\n-      Source_Prj          : Project_Id;\n-      Pkg_Name            : Name_Id;\n-      Project_Tree        : Project_Tree_Ref;\n-      Value               : out Variable_Value;\n-      Is_Default          : out Boolean;\n-      Test_Without_Suffix : Boolean := False;\n-      Check_ALI_Suffix    : Boolean := False);\n-   --  Compute the switches (Compilation switches for instance) for the given\n-   --  file. This checks various attributes to see if there are file specific\n-   --  switches, or else defaults on the switches for the corresponding\n-   --  language. Is_Default is set to False if there were file-specific\n-   --  switches. Source_File can be set to No_File to force retrieval of the\n-   --  default switches. If Test_Without_Suffix is True, and there is no \"for\n-   --  Switches(Source_File) use\", then this procedure also tests without the\n-   --  extension of the filename. If Test_Without_Suffix is True and\n-   --  Check_ALI_Suffix is True, then we also replace the file extension with\n-   --  \".ali\" when testing.\n-\n-   function Linker_Options_Switches\n-     (Project  : Project_Id;\n-      Do_Fail  : Fail_Proc;\n-      In_Tree  : Project_Tree_Ref) return String_List;\n-   --  Collect the options specified in the Linker'Linker_Options attributes\n-   --  of project Project, in project tree In_Tree, and in the projects that\n-   --  it imports directly or indirectly, and returns the result.\n-\n-   function Path_Or_File_Name (Path : Path_Name_Type) return String;\n-   --  Returns a file name if -df is used, otherwise return a path name\n-\n-   function Unit_Index_Of (ALI_File : File_Name_Type) return Int;\n-   --  Find the index of a unit in a source file. Return zero if the file is\n-   --  not a multi-unit source file.\n-\n-   procedure Verbose_Msg\n-     (N1                : Name_Id;\n-      S1                : String;\n-      N2                : Name_Id := No_Name;\n-      S2                : String  := \"\";\n-      Prefix            : String  := \"  -> \";\n-      Minimum_Verbosity : Opt.Verbosity_Level_Type := Opt.Low);\n-   procedure Verbose_Msg\n-     (N1                : File_Name_Type;\n-      S1                : String;\n-      N2                : File_Name_Type := No_File;\n-      S2                : String  := \"\";\n-      Prefix            : String  := \"  -> \";\n-      Minimum_Verbosity : Opt.Verbosity_Level_Type := Opt.Low);\n-   --  If the verbose flag (Verbose_Mode) is set and the verbosity level is at\n-   --  least equal to Minimum_Verbosity, then print Prefix to standard output\n-   --  followed by N1 and S1. If N2 /= No_Name then N2 is printed after S1. S2\n-   --  is printed last. Both N1 and N2 are printed in quotation marks. The two\n-   --  forms differ only in taking Name_Id or File_Name_Type arguments.\n-\n-   -------------------------\n-   -- Program termination --\n-   -------------------------\n-\n-   procedure Fail_Program\n-     (Project_Tree   : Project_Tree_Ref;\n-      S              : String;\n-      Flush_Messages : Boolean := True);\n-   --  Terminate program with a message and a fatal status code\n-\n-   procedure Finish_Program\n-     (Project_Tree : Project_Tree_Ref;\n-      Exit_Code    : Osint.Exit_Code_Type := Osint.E_Success;\n-      S            : String := \"\");\n-   --  Terminate program, with or without a message, setting the status code\n-   --  according to Fatal. This properly removes all temporary files.\n-\n-   --------------\n-   -- Switches --\n-   --------------\n-\n-   generic\n-      with function Add_Switch\n-        (Switch      : String;\n-         For_Lang    : Name_Id;\n-         For_Builder : Boolean;\n-         Has_Global_Compilation_Switches : Boolean) return Boolean;\n-      --  For_Builder is true if we have a builder switch. This function\n-      --  should return True in case of success (the switch is valid),\n-      --  False otherwise. The error message will be displayed by\n-      --  Compute_Builder_Switches itself.\n-      --\n-      --  Has_Global_Compilation_Switches is True if the attribute\n-      --  Global_Compilation_Switches is defined in the project.\n-\n-   procedure Compute_Builder_Switches\n-     (Project_Tree     : Project_Tree_Ref;\n-      Env              : in out Prj.Tree.Environment;\n-      Main_Project     : Project_Id;\n-      Only_For_Lang    : Name_Id := No_Name);\n-   --  Compute the builder switches and global compilation switches. Every time\n-   --  a switch is found in the project, it is passed to Add_Switch. You can\n-   --  provide a value for Only_For_Lang so that we only look for this language\n-   --  when parsing the global compilation switches.\n-\n-   -----------------------\n-   -- Project_Tree data --\n-   -----------------------\n-\n-   --  The following types are specific to builders, and associated with each\n-   --  of the loaded project trees.\n-\n-   type Binding_Data_Record;\n-   type Binding_Data is access Binding_Data_Record;\n-   type Binding_Data_Record is record\n-      Language           : Language_Ptr;\n-      Language_Name      : Name_Id;\n-      Binder_Driver_Name : File_Name_Type;\n-      Binder_Driver_Path : String_Access;\n-      Binder_Prefix      : Name_Id;\n-      Next               : Binding_Data;\n-   end record;\n-   --  Data for a language that have a binder driver\n-\n-   type Builder_Project_Tree_Data is new Project_Tree_Appdata with record\n-      Binding : Binding_Data;\n-\n-      There_Are_Binder_Drivers : Boolean := False;\n-      --  True when there is a binder driver. Set by Get_Configuration when\n-      --  an attribute Language_Processing'Binder_Driver is declared.\n-      --  Reset to False if there are no sources of the languages with binder\n-      --  drivers.\n-\n-      Number_Of_Mains : Natural := 0;\n-      --  Number of main units in this project tree\n-\n-      Closure_Needed : Boolean := False;\n-      --  If True, we need to add the closure of the file we just compiled to\n-      --  the queue. If False, it is assumed that all files are already on the\n-      --  queue so we do not waste time computing the closure.\n-\n-      Need_Compilation : Boolean := True;\n-      Need_Binding     : Boolean := True;\n-      Need_Linking     : Boolean := True;\n-      --  Which of the compilation phases are needed for this project tree\n-   end record;\n-   type Builder_Data_Access is access all Builder_Project_Tree_Data;\n-\n-   procedure Free (Data : in out Builder_Project_Tree_Data);\n-   --  Free all memory allocated for Data\n-\n-   function Builder_Data (Tree : Project_Tree_Ref) return Builder_Data_Access;\n-   --  Return (allocate if needed) tree-specific data\n-\n-   procedure Compute_Compilation_Phases\n-     (Tree                  : Project_Tree_Ref;\n-      Root_Project          : Project_Id;\n-      Option_Unique_Compile : Boolean := False;   --  Was \"-u\" specified ?\n-      Option_Compile_Only   : Boolean := False;   --  Was \"-c\" specified ?\n-      Option_Bind_Only      : Boolean := False;\n-      Option_Link_Only      : Boolean := False);\n-   --  Compute which compilation phases will be needed for Tree. This also does\n-   --  the computation for aggregated trees. This also check whether we'll need\n-   --  to check the closure of the files we have just compiled to add them to\n-   --  the queue.\n-\n-   -----------\n-   -- Mains --\n-   -----------\n-\n-   --  Package Mains is used to store the mains specified on the command line\n-   --  and to retrieve them when a project file is used, to verify that the\n-   --  files exist and that they belong to a project file.\n-\n-   --  Mains are stored in a table. An index is used to retrieve the mains\n-   --  from the table.\n-\n-   type Main_Info is record\n-      File      : File_Name_Type;  --  Always canonical casing\n-      Index     : Int := 0;\n-      Location  : Source_Ptr := No_Location;\n-\n-      Source    : Prj.Source_Id := No_Source;\n-      Project   : Project_Id;\n-      Tree      : Project_Tree_Ref;\n-   end record;\n-\n-   No_Main_Info : constant Main_Info :=\n-                    (No_File, 0, No_Location, No_Source, No_Project, null);\n-\n-   package Mains is\n-      procedure Add_Main\n-        (Name     : String;\n-         Index    : Int := 0;\n-         Location : Source_Ptr := No_Location;\n-         Project  : Project_Id := No_Project;\n-         Tree     : Project_Tree_Ref := null);\n-      --  Add one main to the table. This is in general used to add the main\n-      --  files specified on the command line. Index is used for multi-unit\n-      --  source files, and indicates which unit in the source is concerned.\n-      --  Location is the location within the project file (if a project file\n-      --  is used). Project and Tree indicate to which project the main should\n-      --  belong. In particular, for aggregate projects, this isn't necessarily\n-      --  the main project tree. These can be set to No_Project and null when\n-      --  not using projects.\n-\n-      procedure Delete;\n-      --  Empty the table\n-\n-      procedure Reset;\n-      --  Reset the cursor to the beginning of the table\n-\n-      procedure Set_Multi_Unit_Index\n-        (Project_Tree : Project_Tree_Ref := null;\n-         Index        : Int := 0);\n-      --  If a single main file was defined, this subprogram indicates which\n-      --  unit inside it is the main (case of a multi-unit source files).\n-      --  Errors are raised if zero or more than one main file was defined,\n-      --  and Index is non-zaero. This subprogram is used for the handling\n-      --  of the command line switch.\n-\n-      function Next_Main return String;\n-      function Next_Main return Main_Info;\n-      --  Moves the cursor forward and returns the new current entry. Returns\n-      --  No_Main_Info there are no more mains in the table.\n-\n-      function Number_Of_Mains (Tree : Project_Tree_Ref) return Natural;\n-      --  Returns the number of mains in this project tree (if Tree is null, it\n-      --  returns the total number of project trees).\n-\n-      procedure Fill_From_Project\n-        (Root_Project : Project_Id;\n-         Project_Tree : Project_Tree_Ref);\n-      --  If no main was already added (presumably from the command line), add\n-      --  the main units from root_project (or in the case of an aggregate\n-      --  project from all the aggregated projects).\n-\n-      procedure Complete_Mains\n-        (Flags        : Processing_Flags;\n-         Root_Project : Project_Id;\n-         Project_Tree : Project_Tree_Ref);\n-      --  If some main units were already added from the command line, check\n-      --  that they all belong to the root project, and that they are full\n-      --  paths rather than (partial) base names (e.g. no body suffix was\n-      --  specified).\n-\n-   end Mains;\n-\n-   -----------\n-   -- Queue --\n-   -----------\n-\n-   type Source_Info_Format is (Format_Gprbuild, Format_Gnatmake);\n-\n-   package Queue is\n-\n-      --  The queue of sources to be checked for compilation. There can be a\n-      --  single such queue per application.\n-\n-      type Source_Info (Format : Source_Info_Format := Format_Gprbuild) is\n-         record\n-            case Format is\n-               when Format_Gprbuild =>\n-                  Tree    : Project_Tree_Ref := No_Project_Tree;\n-                  Id      : Source_Id        := No_Source;\n-                  Closure : Boolean          := False;\n-\n-               when Format_Gnatmake =>\n-                  File    : File_Name_Type := No_File;\n-                  Unit    : Unit_Name_Type := No_Unit_Name;\n-                  Index   : Int            := 0;\n-                  Project : Project_Id     := No_Project;\n-                  Sid     : Source_Id      := No_Source;\n-            end case;\n-         end record;\n-      --  Information about files stored in the queue. The exact information\n-      --  depends on the builder, and in particular whether it only supports\n-      --  project-based files (in which case we have a full Source_Id record).\n-\n-      No_Source_Info : constant Source_Info :=\n-                         (Format_Gprbuild, null, null, False);\n-\n-      procedure Initialize\n-        (Queue_Per_Obj_Dir : Boolean;\n-         Force             : Boolean := False);\n-      --  Initialize the queue\n-      --\n-      --  Queue_Per_Obj_Dir matches the --single-compile-per-obj-dir switch:\n-      --  when True, there cannot be simultaneous compilations with the object\n-      --  files in the same object directory when project files are used.\n-      --\n-      --  Nothing is done if Force is False and the queue was already\n-      --  initialized.\n-\n-      procedure Remove_Marks;\n-      --  Remove all marks set for the files. This means that the files will be\n-      --  handed to the compiler if they are added to the queue, and is mostly\n-      --  useful when recompiling several executables in non-project mode, as\n-      --  the switches may be different and -s may be in use.\n-\n-      function Is_Empty return Boolean;\n-      --  Returns True if the queue is empty\n-\n-      function Is_Virtually_Empty return Boolean;\n-      --  Returns True if queue is empty or if all object directories are busy\n-\n-      procedure Insert (Source  : Source_Info; With_Roots : Boolean := False);\n-      function Insert\n-        (Source  : Source_Info; With_Roots : Boolean := False) return Boolean;\n-      --  Insert source in the queue. The second version returns False if the\n-      --  Source was already marked in the queue. If With_Roots is True and the\n-      --  source is in Format_Gprbuild mode (ie with a project), this procedure\n-      --  also includes the \"Roots\" for this main, ie all the other files that\n-      --  must be included in the library or binary (in particular to combine\n-      --  Ada and C files connected through pragma Export/Import). When the\n-      --  roots are computed, they are also stored in the corresponding\n-      --  Source_Id for later reuse by the binder.\n-\n-      procedure Insert_Project_Sources\n-        (Project        : Project_Id;\n-         Project_Tree   : Project_Tree_Ref;\n-         All_Projects   : Boolean;\n-         Unique_Compile : Boolean);\n-      --  Insert all the compilable sources of the project in the queue. If\n-      --  All_Project is true, then all sources from imported projects are also\n-      --  inserted. Unique_Compile should be true if \"-u\" was specified on the\n-      --  command line: if True and some files were given on the command line),\n-      --  only those files will be compiled (so Insert_Project_Sources will do\n-      --  nothing). If True and no file was specified on the command line, all\n-      --  files of the project(s) will be compiled. This procedure also\n-      --  processed aggregated projects.\n-\n-      procedure Insert_Withed_Sources_For\n-        (The_ALI               : ALI.ALI_Id;\n-         Project_Tree          : Project_Tree_Ref;\n-         Excluding_Shared_SALs : Boolean := False);\n-      --  Insert in the queue those sources withed by The_ALI, if there are not\n-      --  already in the queue and Only_Interfaces is False or they are part of\n-      --  the interfaces of their project.\n-\n-      procedure Extract\n-        (Found  : out Boolean;\n-         Source : out Source_Info);\n-      --  Get the first source that can be compiled from the queue. If no\n-      --  source may be compiled, sets Found to False. In this case, the value\n-      --  for Source is undefined.\n-\n-      function Size return Natural;\n-      --  Return the total size of the queue, including the sources already\n-      --  extracted.\n-\n-      function Processed return Natural;\n-      --  Return the number of source in the queue that have aready been\n-      --  processed.\n-\n-      procedure Set_Obj_Dir_Busy (Obj_Dir : Path_Name_Type);\n-      procedure Set_Obj_Dir_Free (Obj_Dir : Path_Name_Type);\n-      --  Mark Obj_Dir as busy or free (see the parameter to Initialize)\n-\n-      function Element (Rank : Positive) return File_Name_Type;\n-      --  Get the file name for element of index Rank in the queue\n-\n-   end Queue;\n-\n-end Makeutl;"}, {"sha": "8632ef3caa98a538ccd0f9333e02be43d2350296", "filename": "gcc/ada/mlib-fil.adb", "status": "removed", "additions": 0, "deletions": 149, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fmlib-fil.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fmlib-fil.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-fil.adb?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793", "patch": "@@ -1,149 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                             M L I B . F I L                              --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---                     Copyright (C) 2001-2007, AdaCore                     --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This package provides a set of routines to deal with file extensions\n-\n-with Ada.Strings.Fixed;\n-with MLib.Tgt;\n-\n-package body MLib.Fil is\n-\n-   use Ada;\n-\n-   package Target renames MLib.Tgt;\n-\n-   ---------------\n-   -- Append_To --\n-   ---------------\n-\n-   function Append_To\n-     (Filename : String;\n-      Ext      : String) return String\n-   is\n-   begin\n-      if Ext'Length = 0 then\n-         return Filename;\n-\n-      elsif Filename (Filename'Last) = '.' then\n-         if Ext (Ext'First) = '.' then\n-            return Filename & Ext (Ext'First + 1 .. Ext'Last);\n-\n-         else\n-            return Filename & Ext;\n-         end if;\n-\n-      else\n-         if Ext (Ext'First) = '.' then\n-            return Filename & Ext;\n-\n-         else\n-            return Filename & '.' & Ext;\n-         end if;\n-      end if;\n-   end Append_To;\n-\n-   ------------\n-   -- Ext_To --\n-   ------------\n-\n-   function Ext_To\n-     (Filename : String;\n-      New_Ext  : String := \"\") return String\n-   is\n-      use Strings.Fixed;\n-\n-      J : constant Natural :=\n-            Index (Source  =>  Filename,\n-                   Pattern => \".\",\n-                   Going   => Strings.Backward);\n-\n-   begin\n-      if J = 0 then\n-         if New_Ext = \"\" then\n-            return Filename;\n-         else\n-            return Filename & \".\" & New_Ext;\n-         end if;\n-\n-      else\n-         if New_Ext = \"\" then\n-            return Head (Filename, J - 1);\n-         else\n-            return Head (Filename, J - 1) & '.' & New_Ext;\n-         end if;\n-      end if;\n-   end Ext_To;\n-\n-   -------------\n-   -- Get_Ext --\n-   -------------\n-\n-   function Get_Ext (Filename : String) return String is\n-      use Strings.Fixed;\n-\n-      J : constant Natural :=\n-            Index (Source  =>  Filename,\n-                   Pattern => \".\",\n-                   Going   => Strings.Backward);\n-\n-   begin\n-      if J = 0 then\n-         return \"\";\n-      else\n-         return Filename (J .. Filename'Last);\n-      end if;\n-   end Get_Ext;\n-\n-   ----------------\n-   -- Is_Archive --\n-   ----------------\n-\n-   function Is_Archive (Filename : String) return Boolean is\n-      Ext : constant String := Get_Ext (Filename);\n-   begin\n-      return Target.Is_Archive_Ext (Ext);\n-   end Is_Archive;\n-\n-   ----------\n-   -- Is_C --\n-   ----------\n-\n-   function Is_C (Filename : String) return Boolean is\n-      Ext : constant String := Get_Ext (Filename);\n-   begin\n-      return Target.Is_C_Ext (Ext);\n-   end Is_C;\n-\n-   ------------\n-   -- Is_Obj --\n-   ------------\n-\n-   function Is_Obj (Filename : String) return Boolean is\n-      Ext : constant String := Get_Ext (Filename);\n-   begin\n-      return Target.Is_Object_Ext (Ext);\n-   end Is_Obj;\n-\n-end MLib.Fil;"}, {"sha": "dd5edfeb366f772fb3cd903a956b0c8591193b99", "filename": "gcc/ada/mlib-fil.ads", "status": "removed", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fmlib-fil.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fmlib-fil.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-fil.ads?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793", "patch": "@@ -1,52 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                             M L I B . F I L                              --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---                     Copyright (C) 2001-2007, AdaCore                     --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This package provides a set of routines to deal with file extensions\n-\n-package MLib.Fil is\n-\n-   function Ext_To\n-     (Filename : String;\n-      New_Ext  : String := \"\") return String;\n-   --  Return Filename with the extension changed to New_Ext\n-\n-   function Append_To\n-     (Filename : String;\n-      Ext      : String) return String;\n-   --  Return Filename with the extension Ext\n-\n-   function Get_Ext (Filename : String) return String;\n-   --  Return extension of filename\n-\n-   function Is_Archive (Filename : String) return Boolean;\n-   --  Test if filename is an archive\n-\n-   function Is_C (Filename : String) return Boolean;\n-   --  Test if Filename is a C file\n-\n-   function Is_Obj (Filename : String) return Boolean;\n-   --  Test if Filename is an object file\n-\n-end MLib.Fil;"}, {"sha": "d830b668378fda095f88271b85f5d288afd36d38", "filename": "gcc/ada/mlib-prj.adb", "status": "removed", "additions": 0, "deletions": 2481, "changes": 2481, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fmlib-prj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fmlib-prj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-prj.adb?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793", "patch": "@@ -1,2481 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                            M L I B . P R J                               --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---                     Copyright (C) 2001-2016, AdaCore                     --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-with ALI;      use ALI;\n-with Gnatvsn;  use Gnatvsn;\n-with Makeutl;  use Makeutl;\n-with MLib.Fil; use MLib.Fil;\n-with MLib.Tgt; use MLib.Tgt;\n-with MLib.Utl; use MLib.Utl;\n-with Opt;\n-with Output;   use Output;\n-with Prj.Com;  use Prj.Com;\n-with Prj.Env;  use Prj.Env;\n-with Prj.Util; use Prj.Util;\n-with Sinput.P;\n-with Snames;   use Snames;\n-with Switch;   use Switch;\n-with Table;\n-with Tempdir;\n-with Types;    use Types;\n-\n-with Ada.Characters.Handling;\n-\n-with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n-with GNAT.HTable;\n-with Interfaces.C_Streams;      use Interfaces.C_Streams;\n-with System;                    use System;\n-with System.Case_Util;          use System.Case_Util;\n-\n-package body MLib.Prj is\n-\n-   Prj_Add_Obj_Files : Types.Int;\n-   pragma Import (C, Prj_Add_Obj_Files, \"__gnat_prj_add_obj_files\");\n-   Add_Object_Files : constant Boolean := Prj_Add_Obj_Files /= 0;\n-   --  Indicates if object files in pragmas Linker_Options (found in the\n-   --  binder generated file) should be taken when linking a stand-alone\n-   --  library. False for Windows, True for other platforms.\n-\n-   ALI_Suffix : constant String := \".ali\";\n-\n-   B_Start : constant String := \"b~\";\n-   --  Prefix of bind file\n-\n-   S_Osinte_Ads : File_Name_Type := No_File;\n-   --  Name_Id for \"s-osinte.ads\"\n-\n-   S_Dec_Ads : File_Name_Type := No_File;\n-   --  Name_Id for \"dec.ads\"\n-\n-   Arguments : String_List_Access := No_Argument;\n-   --  Used to accumulate arguments for the invocation of gnatbind and of the\n-   --  compiler. Also used to collect the interface ALI when copying the ALI\n-   --  files to the library directory.\n-\n-   Argument_Number : Natural := 0;\n-   --  Index of the last argument in Arguments\n-\n-   Initial_Argument_Max : constant := 10;\n-   --  Where does the magic constant 10 come from???\n-\n-   No_Main_String        : aliased String         := \"-n\";\n-   No_Main               : constant String_Access := No_Main_String'Access;\n-\n-   Output_Switch_String  : aliased String         := \"-o\";\n-   Output_Switch         : constant String_Access :=\n-                             Output_Switch_String'Access;\n-\n-   Compile_Switch_String : aliased String         := \"-c\";\n-   Compile_Switch        : constant String_Access :=\n-                             Compile_Switch_String'Access;\n-\n-   No_Warning_String     : aliased String         := \"-gnatws\";\n-   No_Warning            : constant String_Access := No_Warning_String'Access;\n-\n-   Auto_Initialize : constant String := \"-a\";\n-\n-   --  List of objects to put inside the library\n-\n-   Object_Files : Argument_List_Access;\n-\n-   package Objects is new Table.Table\n-     (Table_Name           => \"Mlib.Prj.Objects\",\n-      Table_Component_Type => String_Access,\n-      Table_Index_Type     => Natural,\n-      Table_Low_Bound      => 1,\n-      Table_Initial        => 50,\n-      Table_Increment      => 100);\n-\n-   package Objects_Htable is new GNAT.HTable.Simple_HTable\n-     (Header_Num => Header_Num,\n-      Element    => Boolean,\n-      No_Element => False,\n-      Key        => Name_Id,\n-      Hash       => Hash,\n-      Equal      => \"=\");\n-\n-   --  List of ALI files\n-\n-   Ali_Files : Argument_List_Access;\n-\n-   package ALIs is new Table.Table\n-     (Table_Name           => \"Mlib.Prj.Alis\",\n-      Table_Component_Type => String_Access,\n-      Table_Index_Type     => Natural,\n-      Table_Low_Bound      => 1,\n-      Table_Initial        => 50,\n-      Table_Increment      => 100);\n-\n-   --  List of options set in the command line\n-\n-   Options : Argument_List_Access;\n-\n-   package Opts is new Table.Table\n-     (Table_Name           => \"Mlib.Prj.Opts\",\n-      Table_Component_Type => String_Access,\n-      Table_Index_Type     => Natural,\n-      Table_Low_Bound      => 1,\n-      Table_Initial        => 5,\n-      Table_Increment      => 100);\n-\n-   --  All the ALI file in the library\n-\n-   package Library_ALIs is new GNAT.HTable.Simple_HTable\n-     (Header_Num => Header_Num,\n-      Element    => Boolean,\n-      No_Element => False,\n-      Key        => File_Name_Type,\n-      Hash       => Hash,\n-      Equal      => \"=\");\n-\n-   --  The ALI files in the interface sets\n-\n-   package Interface_ALIs is new GNAT.HTable.Simple_HTable\n-     (Header_Num => Header_Num,\n-      Element    => Boolean,\n-      No_Element => False,\n-      Key        => File_Name_Type,\n-      Hash       => Hash,\n-      Equal      => \"=\");\n-\n-   --  The ALI files that have been processed to check if the corresponding\n-   --  library unit is in the interface set.\n-\n-   package Processed_ALIs is new GNAT.HTable.Simple_HTable\n-     (Header_Num => Header_Num,\n-      Element    => Boolean,\n-      No_Element => False,\n-      Key        => File_Name_Type,\n-      Hash       => Hash,\n-      Equal      => \"=\");\n-\n-   --  The projects imported directly or indirectly\n-\n-   package Processed_Projects is new GNAT.HTable.Simple_HTable\n-     (Header_Num => Header_Num,\n-      Element    => Boolean,\n-      No_Element => False,\n-      Key        => Name_Id,\n-      Hash       => Hash,\n-      Equal      => \"=\");\n-\n-   --  The library projects imported directly or indirectly\n-\n-   package Library_Projs is new Table.Table (\n-     Table_Component_Type => Project_Id,\n-     Table_Index_Type     => Integer,\n-     Table_Low_Bound      => 1,\n-     Table_Initial        => 10,\n-     Table_Increment      => 10,\n-     Table_Name           => \"Make.Library_Projs\");\n-\n-   type Build_Mode_State is (None, Static, Dynamic, Relocatable);\n-\n-   procedure Add_Argument (S : String);\n-   --  Add one argument to Arguments array, if array is full, double its size\n-\n-   function ALI_File_Name (Source : String) return String;\n-   --  Return the ALI file name corresponding to a source\n-\n-   procedure Check (Filename : String);\n-   --  Check if filename is a regular file. Fail if it is not\n-\n-   procedure Check_Context;\n-   --  Check each object files in table Object_Files\n-   --  Fail if any of them is not a regular file\n-\n-   procedure Copy_Interface_Sources\n-     (For_Project : Project_Id;\n-      In_Tree     : Project_Tree_Ref;\n-      Interfaces  : Argument_List;\n-      To_Dir      : Path_Name_Type);\n-   --  Copy the interface sources of a SAL to directory To_Dir\n-\n-   procedure Display (Executable : String);\n-   --  Display invocation of gnatbind and of the compiler with the arguments\n-   --  in Arguments, except when Quiet_Output is True.\n-\n-   function Index (S, Pattern : String) return Natural;\n-   --  Return the last occurrence of Pattern in S, or 0 if none\n-\n-   procedure Process_Binder_File (Name : String);\n-   --  For Stand-Alone libraries, get the Linker Options in the binder\n-   --  generated file.\n-\n-   procedure Reset_Tables;\n-   --  Make sure that all the above tables are empty\n-   --  (Objects, Ali_Files, Options).\n-\n-   function SALs_Use_Constructors return Boolean;\n-   --  Indicate if Stand-Alone Libraries are automatically initialized using\n-   --  the constructor mechanism.\n-\n-   ------------------\n-   -- Add_Argument --\n-   ------------------\n-\n-   procedure Add_Argument (S : String) is\n-   begin\n-      if Argument_Number = Arguments'Last then\n-         declare\n-            New_Args : constant String_List_Access :=\n-              new String_List (1 .. 2 * Arguments'Last);\n-\n-         begin\n-            --  Copy the String_Accesses and set them to null in Arguments\n-            --  so that they will not be deallocated by the call to\n-            --  Free (Arguments).\n-\n-            New_Args (Arguments'Range) := Arguments.all;\n-            Arguments.all := (others => null);\n-            Free (Arguments);\n-            Arguments := New_Args;\n-         end;\n-      end if;\n-\n-      Argument_Number := Argument_Number + 1;\n-      Arguments (Argument_Number) := new String'(S);\n-   end Add_Argument;\n-\n-   -------------------\n-   -- ALI_File_Name --\n-   -------------------\n-\n-   function ALI_File_Name (Source : String) return String is\n-   begin\n-      --  If the source name has an extension, then replace it with\n-      --  the ALI suffix.\n-\n-      for Index in reverse Source'First + 1 .. Source'Last loop\n-         if Source (Index) = '.' then\n-            return Source (Source'First .. Index - 1) & ALI_Suffix;\n-         end if;\n-      end loop;\n-\n-      --  If there is no dot, or if it is the first character, just add the\n-      --  ALI suffix.\n-\n-      return Source & ALI_Suffix;\n-   end ALI_File_Name;\n-\n-   -------------------\n-   -- Build_Library --\n-   -------------------\n-\n-   procedure Build_Library\n-     (For_Project   : Project_Id;\n-      In_Tree       : Project_Tree_Ref;\n-      Gnatbind      : String;\n-      Gnatbind_Path : String_Access;\n-      Gcc           : String;\n-      Gcc_Path      : String_Access;\n-      Bind          : Boolean := True;\n-      Link          : Boolean := True)\n-   is\n-      Maximum_Size : Integer;\n-      pragma Import (C, Maximum_Size, \"__gnat_link_max\");\n-      --  Maximum number of bytes to put in an invocation of gnatbind\n-\n-      Size : Integer;\n-      --  The number of bytes for the invocation of gnatbind\n-\n-      Warning_For_Library : Boolean := False;\n-      --  Set True for first warning for a unit missing from the interface set\n-\n-      Current_Proj : Project_Id;\n-\n-      Libgnarl_Needed   : Yes_No_Unknown := For_Project.Libgnarl_Needed;\n-      --  Set True if library needs to be linked with libgnarl\n-\n-      Object_Directory_Path : constant String :=\n-                                Get_Name_String\n-                                  (For_Project.Object_Directory.Display_Name);\n-\n-      Standalone   : constant Boolean := For_Project.Standalone_Library /= No;\n-\n-      Project_Name : constant String := Get_Name_String (For_Project.Name);\n-\n-      Current_Dir  : constant String := Get_Current_Dir;\n-\n-      Lib_Filename : String_Access;\n-      Lib_Dirpath  : String_Access;\n-      Lib_Version  : String_Access := new String'(\"\");\n-\n-      The_Build_Mode : Build_Mode_State := None;\n-\n-      Success : Boolean := False;\n-\n-      Library_Options : Variable_Value := Nil_Variable_Value;\n-\n-      Driver_Name : Name_Id := No_Name;\n-\n-      In_Main_Object_Directory : Boolean := True;\n-\n-      Foreign_Sources : Boolean;\n-\n-      Rpath : String_Access := null;\n-      --  Allocated only if Path Option is supported\n-\n-      Rpath_Last : Natural := 0;\n-      --  Index of last valid character of Rpath\n-\n-      Initial_Rpath_Length : constant := 200;\n-      --  Initial size of Rpath, when first allocated\n-\n-      Path_Option : String_Access := Linker_Library_Path_Option;\n-      --  If null, Path Option is not supported. Not a constant so that it can\n-      --  be deallocated.\n-\n-      First_ALI : File_Name_Type := No_File;\n-      --  Store the ALI file name of a source of the library (the first found)\n-\n-      procedure Add_ALI_For (Source : File_Name_Type);\n-      --  Add name of the ALI file corresponding to Source to the Arguments\n-\n-      procedure Add_Rpath (Path : String);\n-      --  Add a path name to Rpath\n-\n-      function Check_Project (P : Project_Id) return Boolean;\n-      --  Returns True if P is For_Project or a project extended by For_Project\n-\n-      procedure Check_Libs (ALI_File : String; Main_Project : Boolean);\n-      --  Set Libgnarl_Needed if the ALI_File indicates that there is a need\n-      --  to link with -lgnarl (this is the case when there is a dependency\n-      --  on s-osinte.ads).\n-\n-      procedure Process (The_ALI : File_Name_Type);\n-      --  Check if the closure of a library unit which is or should be in the\n-      --  interface set is also in the interface set. Issue a warning for each\n-      --  missing library unit.\n-\n-      procedure Process_Imported_Libraries;\n-      --  Add the -L and -l switches for the imported Library Project Files,\n-      --  and, if Path Option is supported, the library directory path names\n-      --  to Rpath.\n-\n-      -----------------\n-      -- Add_ALI_For --\n-      -----------------\n-\n-      procedure Add_ALI_For (Source : File_Name_Type) is\n-         ALI    : constant String := ALI_File_Name (Get_Name_String (Source));\n-         ALI_Id : File_Name_Type;\n-\n-      begin\n-         if Bind then\n-            Add_Argument (ALI);\n-         end if;\n-\n-         Name_Len := 0;\n-         Add_Str_To_Name_Buffer (S => ALI);\n-         ALI_Id := Name_Find;\n-\n-         --  Add the ALI file name to the library ALIs\n-\n-         if Bind then\n-            Library_ALIs.Set (ALI_Id, True);\n-         end if;\n-\n-         --  Set First_ALI, if not already done\n-\n-         if First_ALI = No_File then\n-            First_ALI := ALI_Id;\n-         end if;\n-      end Add_ALI_For;\n-\n-      ---------------\n-      -- Add_Rpath --\n-      ---------------\n-\n-      procedure Add_Rpath (Path : String) is\n-\n-         procedure Double;\n-         --  Double Rpath size\n-\n-         ------------\n-         -- Double --\n-         ------------\n-\n-         procedure Double is\n-            New_Rpath : constant String_Access :=\n-                          new String (1 .. 2 * Rpath'Length);\n-         begin\n-            New_Rpath (1 .. Rpath_Last) := Rpath (1 .. Rpath_Last);\n-            Free (Rpath);\n-            Rpath := New_Rpath;\n-         end Double;\n-\n-      --  Start of processing for Add_Rpath\n-\n-      begin\n-         --  If first path, allocate initial Rpath\n-\n-         if Rpath = null then\n-            Rpath := new String (1 .. Initial_Rpath_Length);\n-            Rpath_Last := 0;\n-\n-         else\n-            --  Otherwise, add a path separator between two path names\n-\n-            if Rpath_Last = Rpath'Last then\n-               Double;\n-            end if;\n-\n-            Rpath_Last := Rpath_Last + 1;\n-            Rpath (Rpath_Last) := Path_Separator;\n-         end if;\n-\n-         --  Increase Rpath size until it is large enough\n-\n-         while Rpath_Last + Path'Length > Rpath'Last loop\n-            Double;\n-         end loop;\n-\n-         --  Add the path name\n-\n-         Rpath (Rpath_Last + 1 .. Rpath_Last + Path'Length) := Path;\n-         Rpath_Last := Rpath_Last + Path'Length;\n-      end Add_Rpath;\n-\n-      -------------------\n-      -- Check_Project --\n-      -------------------\n-\n-      function Check_Project (P : Project_Id) return Boolean is\n-      begin\n-         if P = For_Project then\n-            return True;\n-\n-         elsif P /= No_Project then\n-            declare\n-               Proj : Project_Id;\n-\n-            begin\n-               Proj := For_Project;\n-               while Proj.Extends /= No_Project loop\n-                  if P = Proj.Extends then\n-                     return True;\n-                  end if;\n-\n-                  Proj := Proj.Extends;\n-               end loop;\n-            end;\n-         end if;\n-\n-         return False;\n-      end Check_Project;\n-\n-      ----------------\n-      -- Check_Libs --\n-      ----------------\n-\n-      procedure Check_Libs (ALI_File : String; Main_Project : Boolean) is\n-         Lib_File : File_Name_Type;\n-         Text     : Text_Buffer_Ptr;\n-         Id       : ALI.ALI_Id;\n-\n-      begin\n-         if Libgnarl_Needed /= Yes then\n-\n-            --  Scan the ALI file\n-\n-            Name_Len := ALI_File'Length;\n-            Name_Buffer (1 .. Name_Len) := ALI_File;\n-            Lib_File := Name_Find;\n-            Text := Read_Library_Info (Lib_File, True);\n-\n-            Id := ALI.Scan_ALI\n-                    (F          => Lib_File,\n-                     T          => Text,\n-                     Ignore_ED  => False,\n-                     Err        => True,\n-                     Read_Lines => \"D\");\n-            Free (Text);\n-\n-            --  Look for s-osinte.ads in the dependencies\n-\n-            for Index in ALI.ALIs.Table (Id).First_Sdep ..\n-                         ALI.ALIs.Table (Id).Last_Sdep\n-            loop\n-               if ALI.Sdep.Table (Index).Sfile = S_Osinte_Ads then\n-                  Libgnarl_Needed := Yes;\n-\n-                  if Main_Project then\n-                     For_Project.Libgnarl_Needed := Yes;\n-                  else\n-                     exit;\n-                  end if;\n-               end if;\n-            end loop;\n-         end if;\n-      end Check_Libs;\n-\n-      -------------\n-      -- Process --\n-      -------------\n-\n-      procedure Process (The_ALI : File_Name_Type) is\n-         Text       : Text_Buffer_Ptr;\n-         Idread     : ALI_Id;\n-         First_Unit : ALI.Unit_Id;\n-         Last_Unit  : ALI.Unit_Id;\n-         Unit_Data  : Unit_Record;\n-         Afile      : File_Name_Type;\n-\n-      begin\n-         --  Nothing to do if the ALI file has already been processed.\n-         --  This happens if an interface imports another interface.\n-\n-         if not Processed_ALIs.Get (The_ALI) then\n-            Processed_ALIs.Set (The_ALI, True);\n-            Text := Read_Library_Info (The_ALI);\n-\n-            if Text /= null then\n-               Idread :=\n-                 Scan_ALI\n-                   (F         => The_ALI,\n-                    T         => Text,\n-                    Ignore_ED => False,\n-                    Err       => True);\n-               Free (Text);\n-\n-               if Idread /= No_ALI_Id then\n-                  First_Unit := ALI.ALIs.Table (Idread).First_Unit;\n-                  Last_Unit  := ALI.ALIs.Table (Idread).Last_Unit;\n-\n-                  --  Process both unit (spec and body) if the body is needed\n-                  --  by the spec (inline or generic). Otherwise, just process\n-                  --  the spec.\n-\n-                  if First_Unit /= Last_Unit and then\n-                    not ALI.Units.Table (Last_Unit).Body_Needed_For_SAL\n-                  then\n-                     First_Unit := Last_Unit;\n-                  end if;\n-\n-                  for Unit in First_Unit .. Last_Unit loop\n-                     Unit_Data := ALI.Units.Table (Unit);\n-\n-                     --  Check if each withed unit which is in the library is\n-                     --  also in the interface set, if it has not yet been\n-                     --  processed.\n-\n-                     for W in Unit_Data.First_With .. Unit_Data.Last_With loop\n-                        Afile := Withs.Table (W).Afile;\n-\n-                        if Afile /= No_File and then Library_ALIs.Get (Afile)\n-                          and then not Processed_ALIs.Get (Afile)\n-                        then\n-                           if not Interface_ALIs.Get (Afile) then\n-                              if not Warning_For_Library then\n-                                 Write_Str (\"Warning: In library project \"\"\");\n-                                 Get_Name_String (Current_Proj.Name);\n-                                 To_Mixed (Name_Buffer (1 .. Name_Len));\n-                                 Write_Str (Name_Buffer (1 .. Name_Len));\n-                                 Write_Line (\"\"\"\");\n-                                 Warning_For_Library := True;\n-                              end if;\n-\n-                              Write_Str (\"         Unit \"\"\");\n-                              Get_Name_String (Withs.Table (W).Uname);\n-                              To_Mixed (Name_Buffer (1 .. Name_Len - 2));\n-                              Write_Str (Name_Buffer (1 .. Name_Len - 2));\n-                              Write_Line (\"\"\" is not in the interface set\");\n-                              Write_Str (\"         but it is needed by \");\n-\n-                              case Unit_Data.Utype is\n-                                 when Is_Spec =>\n-                                    Write_Str (\"the spec of \");\n-\n-                                 when Is_Body =>\n-                                    Write_Str (\"the body of \");\n-\n-                                 when others =>\n-                                    null;\n-                              end case;\n-\n-                              Write_Str (\"\"\"\");\n-                              Get_Name_String (Unit_Data.Uname);\n-                              To_Mixed (Name_Buffer (1 .. Name_Len - 2));\n-                              Write_Str (Name_Buffer (1 .. Name_Len - 2));\n-                              Write_Line (\"\"\"\");\n-                           end if;\n-\n-                           --  Now, process this unit\n-\n-                           Process (Afile);\n-                        end if;\n-                     end loop;\n-                  end loop;\n-               end if;\n-            end if;\n-         end if;\n-      end Process;\n-\n-      --------------------------------\n-      -- Process_Imported_Libraries --\n-      --------------------------------\n-\n-      procedure Process_Imported_Libraries is\n-         Current : Project_Id;\n-\n-         procedure Process_Project (Project : Project_Id);\n-         --  Process Project and its imported projects recursively.\n-         --  Add any library projects to table Library_Projs.\n-\n-         ---------------------\n-         -- Process_Project --\n-         ---------------------\n-\n-         procedure Process_Project (Project : Project_Id) is\n-            Imported : Project_List;\n-\n-         begin\n-            --  Nothing to do if process has already been processed\n-\n-            if not Processed_Projects.Get (Project.Name) then\n-               Processed_Projects.Set (Project.Name, True);\n-\n-               --  Call Process_Project recursively for any imported project.\n-               --  We first process the imported projects to guarantee that\n-               --  we have a proper reverse order for the libraries.\n-\n-               Imported := Project.Imported_Projects;\n-               while Imported /= null loop\n-                  if Imported.Project /= No_Project then\n-                     Process_Project (Imported.Project);\n-                  end if;\n-\n-                  Imported := Imported.Next;\n-               end loop;\n-\n-               --  If it is a library project, add it to Library_Projs\n-\n-               if Project /= For_Project and then Project.Library then\n-                  Library_Projs.Increment_Last;\n-                  Library_Projs.Table (Library_Projs.Last) := Project;\n-\n-                  --  Check if because of this library we need to use libgnarl\n-\n-                  if Libgnarl_Needed = Unknown then\n-                     if Project.Libgnarl_Needed = Unknown\n-                       and then Project.Object_Directory /= No_Path_Information\n-                     then\n-                        --  Check if libgnarl is needed for this library\n-\n-                        declare\n-                           Object_Dir_Path : constant String :=\n-                                               Get_Name_String\n-                                                 (Project.Object_Directory.\n-                                                    Display_Name);\n-                           Object_Dir      : Dir_Type;\n-                           Filename        : String (1 .. 255);\n-                           Last            : Natural;\n-\n-                        begin\n-                           Open (Object_Dir, Object_Dir_Path);\n-\n-                           --  For all entries in the object directory\n-\n-                           loop\n-                              Read (Object_Dir, Filename, Last);\n-                              exit when Last = 0;\n-\n-                              --  Check if it is an object file\n-\n-                              if Is_Obj (Filename (1 .. Last)) then\n-                                 declare\n-                                    Object_Path : constant String :=\n-                                                    Normalize_Pathname\n-                                                      (Object_Dir_Path &\n-                                                       Directory_Separator &\n-                                                       Filename (1 .. Last));\n-                                    ALI_File    : constant String :=\n-                                                    Ext_To\n-                                                      (Object_Path, \"ali\");\n-\n-                                 begin\n-                                    if Is_Regular_File (ALI_File) then\n-\n-                                       --  Find out if for this ALI file,\n-                                       --  libgnarl is necessary.\n-\n-                                       Check_Libs\n-                                         (ALI_File, Main_Project => False);\n-\n-                                       if Libgnarl_Needed = Yes then\n-                                          Project.Libgnarl_Needed := Yes;\n-                                          For_Project.Libgnarl_Needed := Yes;\n-                                          exit;\n-                                       end if;\n-                                    end if;\n-                                 end;\n-                              end if;\n-                           end loop;\n-\n-                           Close (Object_Dir);\n-                        end;\n-                     end if;\n-\n-                     if Project.Libgnarl_Needed = Yes then\n-                        Libgnarl_Needed := Yes;\n-                        For_Project.Libgnarl_Needed := Yes;\n-                     end if;\n-                  end if;\n-               end if;\n-            end if;\n-         end Process_Project;\n-\n-      --  Start of processing for Process_Imported_Libraries\n-\n-      begin\n-         --  Build list of library projects imported directly or indirectly,\n-         --  in the reverse order.\n-\n-         Process_Project (For_Project);\n-\n-         --  Add the -L and -l switches and, if the Rpath option is supported,\n-         --  add the directory to the Rpath. As the library projects are in the\n-         --  wrong order, process from the last to the first.\n-\n-         for Index in reverse 1 .. Library_Projs.Last loop\n-            Current := Library_Projs.Table (Index);\n-\n-            Get_Name_String (Current.Library_Dir.Display_Name);\n-            Opts.Increment_Last;\n-            Opts.Table (Opts.Last) :=\n-              new String'(\"-L\" & Name_Buffer (1 .. Name_Len));\n-\n-            if Path_Option /= null then\n-               Add_Rpath (Name_Buffer (1 .. Name_Len));\n-            end if;\n-\n-            Opts.Increment_Last;\n-            Opts.Table (Opts.Last) :=\n-              new String'(\"-l\" & Get_Name_String (Current.Library_Name));\n-         end loop;\n-      end Process_Imported_Libraries;\n-\n-      Path_FD : File_Descriptor := Invalid_FD;\n-      --  Used for setting the source and object paths\n-\n-   --  Start of processing for Build_Library\n-\n-   begin\n-      Reset_Tables;\n-\n-      --  Fail if project is not a library project\n-\n-      if not For_Project.Library then\n-         Com.Fail (\"project \"\"\" & Project_Name & \"\"\" has no library\");\n-      end if;\n-\n-      --  Do not attempt to build the library if it is externally built\n-\n-      if For_Project.Externally_Built then\n-         return;\n-      end if;\n-\n-      --  If this is the first time Build_Library is called, get the Name_Id\n-      --  of \"s-osinte.ads\".\n-\n-      if S_Osinte_Ads = No_File then\n-         Name_Len := 0;\n-         Add_Str_To_Name_Buffer (\"s-osinte.ads\");\n-         S_Osinte_Ads := Name_Find;\n-      end if;\n-\n-      if S_Dec_Ads = No_File then\n-         Name_Len := 0;\n-         Add_Str_To_Name_Buffer (\"dec.ads\");\n-         S_Dec_Ads := Name_Find;\n-      end if;\n-\n-      --  We work in the object directory\n-\n-      Change_Dir (Object_Directory_Path);\n-\n-      if Standalone then\n-\n-         --  Call gnatbind only if Bind is True\n-\n-         if Bind then\n-            if Gnatbind_Path = null then\n-               Com.Fail (\"unable to locate \" & Gnatbind);\n-            end if;\n-\n-            if Gcc_Path = null then\n-               Com.Fail (\"unable to locate \" & Gcc);\n-            end if;\n-\n-            --  Allocate Arguments, if it is the first time we see a standalone\n-            --  library.\n-\n-            if Arguments = No_Argument then\n-               Arguments := new String_List (1 .. Initial_Argument_Max);\n-            end if;\n-\n-            --  Add \"-n -o b~<lib>.adb -L<lib>_\"\n-\n-            Argument_Number := 2;\n-            Arguments (1) := No_Main;\n-            Arguments (2) := Output_Switch;\n-\n-            Add_Argument\n-              (B_Start & Get_Name_String (For_Project.Library_Name) & \".adb\");\n-\n-            --  Make sure that the init procedure is never \"adainit\"\n-\n-            Get_Name_String (For_Project.Library_Name);\n-\n-            if Name_Buffer (1 .. Name_Len) = \"ada\" then\n-               Add_Argument (\"-Lada_\");\n-            else\n-               Add_Argument\n-                 (\"-L\" & Get_Name_String (For_Project.Library_Name));\n-            end if;\n-\n-            if For_Project.Lib_Auto_Init and then SALs_Use_Constructors then\n-               Add_Argument (Auto_Initialize);\n-            end if;\n-\n-            --  Check if Binder'Default_Switches (\"Ada\") is defined. If it is,\n-            --  add these switches to call gnatbind.\n-\n-            declare\n-               Binder_Package : constant Package_Id :=\n-                                  Value_Of\n-                                    (Name        => Name_Binder,\n-                                     In_Packages => For_Project.Decl.Packages,\n-                                     Shared      => In_Tree.Shared);\n-\n-            begin\n-               if Binder_Package /= No_Package then\n-                  declare\n-                     Defaults : constant Array_Element_Id :=\n-                                  Value_Of\n-                                    (Name      => Name_Default_Switches,\n-                                     In_Arrays =>\n-                                       In_Tree.Shared.Packages.Table\n-                                         (Binder_Package).Decl.Arrays,\n-                                     Shared    => In_Tree.Shared);\n-\n-                     Switches : Variable_Value := Nil_Variable_Value;\n-                     Switch   : String_List_Id := Nil_String;\n-\n-                  begin\n-                     if Defaults /= No_Array_Element then\n-                        Switches :=\n-                          Value_Of\n-                            (Index     => Name_Ada,\n-                             Src_Index => 0,\n-                             In_Array  => Defaults,\n-                             Shared    => In_Tree.Shared);\n-\n-                        if not Switches.Default then\n-                           Switch := Switches.Values;\n-\n-                           while Switch /= Nil_String loop\n-                              Add_Argument\n-                                (Get_Name_String\n-                                   (In_Tree.Shared.String_Elements.Table\n-                                      (Switch).Value));\n-                              Switch := In_Tree.Shared.String_Elements.\n-                                          Table (Switch).Next;\n-                           end loop;\n-                        end if;\n-                     end if;\n-                  end;\n-               end if;\n-            end;\n-         end if;\n-\n-         --  Get all the ALI files of the project file. We do that even if\n-         --  Bind is False, so that First_ALI is set.\n-\n-         declare\n-            Unit : Unit_Index;\n-\n-         begin\n-            Library_ALIs.Reset;\n-            Interface_ALIs.Reset;\n-            Processed_ALIs.Reset;\n-\n-            Unit := Units_Htable.Get_First (In_Tree.Units_HT);\n-            while Unit /= No_Unit_Index loop\n-               if Unit.File_Names (Impl) /= null\n-                 and then not Unit.File_Names (Impl).Locally_Removed\n-               then\n-                  if Check_Project (Unit.File_Names (Impl).Project) then\n-                     if Unit.File_Names (Spec) = null then\n-\n-                        --  Add the ALI file only if it is not a subunit\n-\n-                        declare\n-                           Src_Ind : constant Source_File_Index :=\n-                                       Sinput.P.Load_Project_File\n-                                         (Get_Name_String\n-                                           (Unit.File_Names (Impl).Path.Name));\n-                        begin\n-                           if not\n-                             Sinput.P.Source_File_Is_Subunit (Src_Ind)\n-                           then\n-                              Add_ALI_For (Unit.File_Names (Impl).File);\n-                              exit when not Bind;\n-                           end if;\n-                        end;\n-\n-                     else\n-                        Add_ALI_For (Unit.File_Names (Impl).File);\n-                        exit when not Bind;\n-                     end if;\n-                  end if;\n-\n-               elsif Unit.File_Names (Spec) /= null\n-                 and then not Unit.File_Names (Spec).Locally_Removed\n-                 and then Check_Project (Unit.File_Names (Spec).Project)\n-               then\n-                  Add_ALI_For (Unit.File_Names (Spec).File);\n-                  exit when not Bind;\n-               end if;\n-\n-               Unit := Units_Htable.Get_Next (In_Tree.Units_HT);\n-            end loop;\n-         end;\n-\n-         --  Continue setup and call gnatbind if Bind is True\n-\n-         if Bind then\n-\n-            --  Get an eventual --RTS from the ALI file\n-\n-            if First_ALI /= No_File then\n-               declare\n-                  T : Text_Buffer_Ptr;\n-                  A : ALI_Id;\n-\n-               begin\n-                  --  Load the ALI file\n-\n-                  T := Read_Library_Info (First_ALI, True);\n-\n-                  --  Read it\n-\n-                  A := Scan_ALI\n-                         (First_ALI, T, Ignore_ED => False, Err => False);\n-\n-                  if A /= No_ALI_Id then\n-                     for Index in\n-                       ALI.Units.Table\n-                         (ALI.ALIs.Table (A).First_Unit).First_Arg ..\n-                       ALI.Units.Table\n-                         (ALI.ALIs.Table (A).First_Unit).Last_Arg\n-                     loop\n-                        --  If --RTS found, add switch to call gnatbind\n-\n-                        declare\n-                           Arg : String_Ptr renames Args.Table (Index);\n-                        begin\n-                           if Arg'Length >= 6 and then\n-                              Arg (Arg'First + 2 .. Arg'First + 5) = \"RTS=\"\n-                           then\n-                              Add_Argument (Arg.all);\n-                              exit;\n-                           end if;\n-                        end;\n-                     end loop;\n-                  end if;\n-               end;\n-            end if;\n-\n-            --  Set the paths\n-\n-            --  First the source path\n-\n-            if For_Project.Include_Path_File = No_Path then\n-               Get_Directories\n-                 (Project_Tree => In_Tree,\n-                  For_Project  => For_Project,\n-                  Activity     => Compilation,\n-                  Languages    => Ada_Only);\n-\n-               Create_New_Path_File\n-                 (In_Tree.Shared, Path_FD, For_Project.Include_Path_File);\n-\n-               Write_Path_File (Path_FD);\n-               Path_FD := Invalid_FD;\n-            end if;\n-\n-            if Current_Source_Path_File_Of (In_Tree.Shared) /=\n-                                                For_Project.Include_Path_File\n-            then\n-               Set_Current_Source_Path_File_Of\n-                 (In_Tree.Shared, For_Project.Include_Path_File);\n-               Set_Path_File_Var\n-                 (Project_Include_Path_File,\n-                  Get_Name_String (For_Project.Include_Path_File));\n-            end if;\n-\n-            --  Then, the object path\n-\n-            Get_Directories\n-              (Project_Tree => In_Tree,\n-               For_Project  => For_Project,\n-               Activity     => SAL_Binding,\n-               Languages    => Ada_Only);\n-\n-            declare\n-               Path_File_Name : Path_Name_Type;\n-\n-            begin\n-               Create_New_Path_File (In_Tree.Shared, Path_FD, Path_File_Name);\n-\n-               Write_Path_File (Path_FD);\n-               Path_FD := Invalid_FD;\n-\n-               Set_Path_File_Var\n-                 (Project_Objects_Path_File, Get_Name_String (Path_File_Name));\n-               Set_Current_Source_Path_File_Of\n-                 (In_Tree.Shared, Path_File_Name);\n-            end;\n-\n-            --  Display the gnatbind command, if not in quiet output\n-\n-            Display (Gnatbind);\n-\n-            Size := 0;\n-            for J in 1 .. Argument_Number loop\n-               Size := Size + Arguments (J)'Length + 1;\n-            end loop;\n-\n-            --  Invoke gnatbind with the arguments if the size is not too large\n-\n-            if Size <= Maximum_Size then\n-               Spawn\n-                 (Gnatbind_Path.all,\n-                  Arguments (1 .. Argument_Number),\n-                  Success);\n-\n-            --  Otherwise create a temporary response file\n-\n-            else\n-               declare\n-                  FD            : File_Descriptor;\n-                  Path          : Path_Name_Type;\n-                  Args          : Argument_List (1 .. 1);\n-                  EOL           : constant String (1 .. 1) := (1 => ASCII.LF);\n-                  Status        : Integer;\n-                  Succ          : Boolean;\n-                  Quotes_Needed : Boolean;\n-                  Last_Char     : Natural;\n-                  Ch            : Character;\n-\n-               begin\n-                  Tempdir.Create_Temp_File (FD, Path);\n-                  Args (1) := new String'(\"@\" & Get_Name_String (Path));\n-\n-                  for J in 1 .. Argument_Number loop\n-\n-                     --  Check if the argument should be quoted\n-\n-                     Quotes_Needed := False;\n-                     Last_Char     := Arguments (J)'Length;\n-\n-                     for K in Arguments (J)'Range loop\n-                        Ch := Arguments (J) (K);\n-\n-                        if Ch = ' ' or else Ch = ASCII.HT or else Ch = '\"' then\n-                           Quotes_Needed := True;\n-                           exit;\n-                        end if;\n-                     end loop;\n-\n-                     if Quotes_Needed then\n-\n-                        --  Quote the argument, doubling '\"'\n-\n-                        declare\n-                           Arg : String (1 .. Arguments (J)'Length * 2 + 2);\n-\n-                        begin\n-                           Arg (1) := '\"';\n-                           Last_Char := 1;\n-\n-                           for K in Arguments (J)'Range loop\n-                              Ch := Arguments (J) (K);\n-                              Last_Char := Last_Char + 1;\n-                              Arg (Last_Char) := Ch;\n-\n-                              if Ch = '\"' then\n-                                 Last_Char := Last_Char + 1;\n-                                 Arg (Last_Char) := '\"';\n-                              end if;\n-                           end loop;\n-\n-                           Last_Char := Last_Char + 1;\n-                           Arg (Last_Char) := '\"';\n-\n-                           Status := Write (FD, Arg'Address, Last_Char);\n-                        end;\n-\n-                     else\n-                        Status := Write\n-                          (FD,\n-                           Arguments (J) (Arguments (J)'First)'Address,\n-                           Last_Char);\n-                     end if;\n-\n-                     if Status /= Last_Char then\n-                        Fail (\"disk full\");\n-                     end if;\n-\n-                     Status := Write (FD, EOL (1)'Address, 1);\n-\n-                     if Status /= 1 then\n-                        Fail (\"disk full\");\n-                     end if;\n-                  end loop;\n-\n-                  Close (FD);\n-\n-                  --  And invoke gnatbind with this response file\n-\n-                  Spawn (Gnatbind_Path.all, Args, Success);\n-\n-                  Delete_File (Get_Name_String (Path), Succ);\n-\n-                  --  We ignore a failure in this Delete_File operation.\n-                  --  Is that OK??? If so, worth a comment as to why we\n-                  --  are OK with the operation failing\n-               end;\n-            end if;\n-\n-            if not Success then\n-               Com.Fail (\"could not bind standalone library \"\n-                         & Get_Name_String (For_Project.Library_Name));\n-            end if;\n-         end if;\n-\n-         --  Compile the binder generated file only if Link is true\n-\n-         if Link then\n-\n-            --  Set the paths\n-\n-            Set_Ada_Paths\n-              (Project             => For_Project,\n-               In_Tree             => In_Tree,\n-               Including_Libraries => True);\n-\n-            --  Invoke <gcc> -c b__<lib>.adb\n-\n-            --  Allocate Arguments, if first time we see a standalone library\n-\n-            if Arguments = No_Argument then\n-               Arguments := new String_List (1 .. Initial_Argument_Max);\n-            end if;\n-\n-            Argument_Number := 2;\n-            Arguments (1) := Compile_Switch;\n-            Arguments (2) := No_Warning;\n-\n-            Add_Argument\n-              (B_Start & Get_Name_String (For_Project.Library_Name) & \".adb\");\n-\n-            --  If necessary, add the PIC option\n-\n-            if PIC_Option /= \"\" then\n-               Add_Argument (PIC_Option);\n-            end if;\n-\n-            --  Get the back-end switches and --RTS from the ALI file\n-\n-            if First_ALI /= No_File then\n-               declare\n-                  T : Text_Buffer_Ptr;\n-                  A : ALI_Id;\n-\n-               begin\n-                  --  Load the ALI file\n-\n-                  T := Read_Library_Info (First_ALI, True);\n-\n-                  --  Read it\n-\n-                  A :=\n-                    Scan_ALI (First_ALI, T, Ignore_ED => False, Err => False);\n-\n-                  if A /= No_ALI_Id then\n-                     for Index in\n-                       ALI.Units.Table\n-                         (ALI.ALIs.Table (A).First_Unit).First_Arg ..\n-                       ALI.Units.Table\n-                         (ALI.ALIs.Table (A).First_Unit).Last_Arg\n-                     loop\n-                        --  Do not compile with the front end switches except\n-                        --  for --RTS.\n-\n-                        declare\n-                           Arg : String_Ptr renames Args.Table (Index);\n-                        begin\n-                           if not Is_Front_End_Switch (Arg.all)\n-                             or else\n-                               Arg (Arg'First + 2 .. Arg'First + 5) = \"RTS=\"\n-                           then\n-                              Add_Argument (Arg.all);\n-                           end if;\n-                        end;\n-                     end loop;\n-                  end if;\n-               end;\n-            end if;\n-\n-            --  Now all the arguments are set, compile binder generated file\n-\n-            Display (Gcc);\n-            Spawn\n-              (Gcc_Path.all, Arguments (1 .. Argument_Number), Success);\n-\n-            if not Success then\n-               Com.Fail\n-                (\"could not compile binder generated file for library \"\n-                  & Get_Name_String (For_Project.Library_Name));\n-            end if;\n-\n-            --  Process binder generated file for pragmas Linker_Options\n-\n-            Process_Binder_File (Arguments (3).all & ASCII.NUL);\n-         end if;\n-      end if;\n-\n-      --  Build the library only if Link is True\n-\n-      if Link then\n-\n-         --  If attributes Library_GCC or Linker'Driver were specified, get the\n-         --  driver name.\n-\n-         if For_Project.Config.Shared_Lib_Driver /= No_File then\n-            Driver_Name := Name_Id (For_Project.Config.Shared_Lib_Driver);\n-         end if;\n-\n-         --  If attribute Library_Options was specified, add these options\n-\n-         Library_Options := Value_Of\n-           (Name_Library_Options, For_Project.Decl.Attributes,\n-            In_Tree.Shared);\n-\n-         if not Library_Options.Default then\n-            declare\n-               Current : String_List_Id;\n-               Element : String_Element;\n-\n-            begin\n-               Current := Library_Options.Values;\n-               while Current /= Nil_String loop\n-                  Element := In_Tree.Shared.String_Elements.Table (Current);\n-                  Get_Name_String (Element.Value);\n-\n-                  if Name_Len /= 0 then\n-                     Opts.Increment_Last;\n-                     Opts.Table (Opts.Last) :=\n-                       new String'(Name_Buffer (1 .. Name_Len));\n-                  end if;\n-\n-                  Current := Element.Next;\n-               end loop;\n-            end;\n-         end if;\n-\n-         Lib_Dirpath  :=\n-           new String'(Get_Name_String (For_Project.Library_Dir.Display_Name));\n-         Lib_Filename :=\n-           new String'(Get_Name_String (For_Project.Library_Name));\n-\n-         case For_Project.Library_Kind is\n-            when Static =>\n-               The_Build_Mode := Static;\n-\n-            when Dynamic =>\n-               The_Build_Mode := Dynamic;\n-\n-            when Relocatable =>\n-               The_Build_Mode := Relocatable;\n-\n-               if PIC_Option /= \"\" then\n-                  Opts.Increment_Last;\n-                  Opts.Table (Opts.Last) := new String'(PIC_Option);\n-               end if;\n-         end case;\n-\n-         --  Get the library version, if any\n-\n-         if For_Project.Lib_Internal_Name /= No_Name then\n-            Lib_Version :=\n-              new String'(Get_Name_String (For_Project.Lib_Internal_Name));\n-         end if;\n-\n-         --  Add the objects found in the object directory and the object\n-         --  directories of the extended files, if any, except for generated\n-         --  object files (b~.. or B__..) from extended projects.\n-         --  When there are one or more extended files, only add an object file\n-         --  if no object file with the same name have already been added.\n-\n-         In_Main_Object_Directory := True;\n-\n-         --  For gnatmake, when the project specifies more than just Ada as a\n-         --  language (even if course we could not find any source file for\n-         --  the other languages), we will take all object files found in the\n-         --  object directories. Since we know the project supports at least\n-         --  Ada, we just have to test whether it has at least two languages,\n-         --  and not care about the sources.\n-\n-         Foreign_Sources := For_Project.Languages.Next /= null;\n-         Current_Proj := For_Project;\n-         loop\n-            if Current_Proj.Object_Directory /= No_Path_Information then\n-\n-               --  The following code gets far too indented ... suggest some\n-               --  procedural abstraction here. How about making this declare\n-               --  block a named procedure???\n-\n-               declare\n-                  Object_Dir_Path : constant String :=\n-                                      Get_Name_String\n-                                        (Current_Proj.Object_Directory\n-                                         .Display_Name);\n-\n-                  Object_Dir : Dir_Type;\n-                  Filename   : String (1 .. 255);\n-                  Last       : Natural;\n-                  Id         : Name_Id;\n-\n-               begin\n-                  Open (Dir => Object_Dir, Dir_Name => Object_Dir_Path);\n-\n-                  --  For all entries in the object directory\n-\n-                  loop\n-                     Read (Object_Dir, Filename, Last);\n-\n-                     exit when Last = 0;\n-\n-                     --  Check if it is an object file\n-\n-                     if Is_Obj (Filename (1 .. Last)) then\n-                        declare\n-                           Object_Path  : constant String :=\n-                                            Normalize_Pathname\n-                                              (Object_Dir_Path\n-                                               & Directory_Separator\n-                                               & Filename (1 .. Last));\n-                           Object_File  : constant String :=\n-                                            Filename (1 .. Last);\n-\n-                           C_Filename    : String := Object_File;\n-\n-                        begin\n-                           Canonical_Case_File_Name (C_Filename);\n-\n-                           --  If in the object directory of an extended\n-                           --  project, do not consider generated object files.\n-\n-                           if In_Main_Object_Directory\n-                             or else Last < 5\n-                             or else\n-                               C_Filename (1 .. B_Start'Length) /= B_Start\n-                           then\n-                              Name_Len := 0;\n-                              Add_Str_To_Name_Buffer (C_Filename);\n-                              Id := Name_Find;\n-\n-                              if not Objects_Htable.Get (Id) then\n-                                 declare\n-                                    ALI_File : constant String :=\n-                                                 Ext_To (C_Filename, \"ali\");\n-\n-                                    ALI_Path : constant String :=\n-                                                 Ext_To (Object_Path, \"ali\");\n-\n-                                    Add_It : Boolean;\n-                                    Fname  : File_Name_Type;\n-                                    Proj   : Project_Id;\n-                                    Index  : Unit_Index;\n-\n-                                 begin\n-                                    --  The following assignment could use\n-                                    --  a comment ???\n-\n-                                    Add_It :=\n-                                      Foreign_Sources\n-                                        or else\n-                                          (Last >= 5\n-                                             and then\n-                                               C_Filename (1 .. B_Start'Length)\n-                                                 = B_Start);\n-\n-                                    if Is_Regular_File (ALI_Path) then\n-\n-                                       --  If there is an ALI file, check if\n-                                       --  the object file should be added to\n-                                       --  the library. If there are foreign\n-                                       --  sources we put all object files in\n-                                       --  the library.\n-\n-                                       if not Add_It then\n-                                          Index :=\n-                                            Units_Htable.Get_First\n-                                             (In_Tree.Units_HT);\n-                                          while Index /= null loop\n-                                             if Index.File_Names (Impl) /=\n-                                               null\n-                                             then\n-                                                Proj :=\n-                                                  Index.File_Names (Impl)\n-                                                  .Project;\n-                                                Fname :=\n-                                                  Index.File_Names (Impl).File;\n-\n-                                             elsif Index.File_Names (Spec) /=\n-                                               null\n-                                             then\n-                                                Proj :=\n-                                                  Index.File_Names (Spec)\n-                                                  .Project;\n-                                                Fname :=\n-                                                  Index.File_Names (Spec).File;\n-\n-                                             else\n-                                                Proj := No_Project;\n-                                             end if;\n-\n-                                             Add_It := Proj /= No_Project;\n-\n-                                             --  If the source is in the\n-                                             --  project or a project it\n-                                             --  extends, we may put it in\n-                                             --  the library.\n-\n-                                             if Add_It then\n-                                                Add_It := Check_Project (Proj);\n-                                             end if;\n-\n-                                             --  But we don't, if the ALI file\n-                                             --  does not correspond to the\n-                                             --  unit.\n-\n-                                             if Add_It then\n-                                                declare\n-                                                   F : constant String :=\n-                                                         Ext_To\n-                                                           (Get_Name_String\n-                                                              (Fname), \"ali\");\n-                                                begin\n-                                                   Add_It := F = ALI_File;\n-                                                end;\n-                                             end if;\n-\n-                                             exit when Add_It;\n-\n-                                             Index :=\n-                                               Units_Htable.Get_Next\n-                                                 (In_Tree.Units_HT);\n-                                          end loop;\n-                                       end if;\n-\n-                                       if Add_It then\n-                                          Objects_Htable.Set (Id, True);\n-                                          Objects.Append\n-                                            (new String'(Object_Path));\n-\n-                                          --  Record the ALI file\n-\n-                                          ALIs.Append (new String'(ALI_Path));\n-\n-                                          --  Find out if for this ALI file,\n-                                          --  libgnarl is necessary.\n-\n-                                          Check_Libs (ALI_Path, True);\n-                                       end if;\n-\n-                                    elsif Foreign_Sources then\n-                                       Objects.Append\n-                                         (new String'(Object_Path));\n-                                    end if;\n-                                 end;\n-                              end if;\n-                           end if;\n-                        end;\n-                     end if;\n-                  end loop;\n-\n-                  Close (Dir => Object_Dir);\n-\n-               exception\n-                  when Directory_Error =>\n-                     Com.Fail (\"cannot find object directory \"\"\"\n-                               & Get_Name_String\n-                                  (Current_Proj.Object_Directory.Display_Name)\n-                               & \"\"\"\");\n-               end;\n-            end if;\n-\n-            exit when Current_Proj.Extends = No_Project;\n-\n-            In_Main_Object_Directory  := False;\n-            Current_Proj := Current_Proj.Extends;\n-         end loop;\n-\n-         --  Add the -L and -l switches for the imported Library Project Files,\n-         --  and, if Path Option is supported, the library directory path names\n-         --  to Rpath.\n-\n-         Process_Imported_Libraries;\n-\n-         --  Link with libgnat and possibly libgnarl\n-\n-         Opts.Increment_Last;\n-         Opts.Table (Opts.Last) := new String'(\"-L\" & Lib_Directory);\n-\n-         --  If Path Option supported, add libgnat directory path name to Rpath\n-\n-         if Path_Option /= null then\n-            declare\n-               Libdir    : constant String := Lib_Directory;\n-               GCC_Index : Natural := 0;\n-\n-            begin\n-               Add_Rpath (Libdir);\n-\n-               --  For shared libraries, add to the Path Option the directory\n-               --  of the shared version of libgcc.\n-\n-               if The_Build_Mode /= Static then\n-                  GCC_Index := Index (Libdir, \"/lib/\");\n-\n-                  if GCC_Index = 0 then\n-                     GCC_Index :=\n-                       Index\n-                         (Libdir,\n-                          Directory_Separator & \"lib\" & Directory_Separator);\n-                  end if;\n-\n-                  if GCC_Index /= 0 then\n-                     Add_Rpath (Libdir (Libdir'First .. GCC_Index + 3));\n-                  end if;\n-               end if;\n-            end;\n-         end if;\n-\n-         if Libgnarl_Needed = Yes then\n-            Opts.Increment_Last;\n-\n-            if The_Build_Mode = Static then\n-               Opts.Table (Opts.Last) := new String'(\"-lgnarl\");\n-            else\n-               Opts.Table (Opts.Last) := new String'(Shared_Lib (\"gnarl\"));\n-            end if;\n-         end if;\n-\n-         Opts.Increment_Last;\n-\n-         if The_Build_Mode = Static then\n-            Opts.Table (Opts.Last) := new String'(\"-lgnat\");\n-         else\n-            Opts.Table (Opts.Last) := new String'(Shared_Lib (\"gnat\"));\n-         end if;\n-\n-         --  If Path Option is supported, add the necessary switch with the\n-         --  content of Rpath. As Rpath contains at least libgnat directory\n-         --  path name, it is guaranteed that it is not null.\n-\n-         if Opt.Run_Path_Option and then Path_Option /= null then\n-            Opts.Increment_Last;\n-            Opts.Table (Opts.Last) :=\n-              new String'(Path_Option.all & Rpath (1 .. Rpath_Last));\n-            Free (Path_Option);\n-            Free (Rpath);\n-         end if;\n-\n-         Object_Files :=\n-           new Argument_List'\n-             (Argument_List (Objects.Table (1 .. Objects.Last)));\n-\n-         Ali_Files :=\n-           new Argument_List'(Argument_List (ALIs.Table (1 .. ALIs.Last)));\n-\n-         Options :=\n-           new Argument_List'(Argument_List (Opts.Table (1 .. Opts.Last)));\n-\n-         --  We fail if there are no object to put in the library\n-         --  (Ada or foreign objects).\n-\n-         if Object_Files'Length = 0 then\n-            Com.Fail (\"no object files for library \"\"\" &\n-                      Lib_Filename.all & '\"');\n-         end if;\n-\n-         if not Opt.Quiet_Output then\n-            Write_Eol;\n-            Write_Str  (\"building \");\n-            Write_Str (Ada.Characters.Handling.To_Lower\n-                         (Build_Mode_State'Image (The_Build_Mode)));\n-            Write_Str  (\" library for project \");\n-            Write_Line (Project_Name);\n-\n-            --  Only output list of object files and ALI files in verbose mode\n-\n-            if Opt.Verbose_Mode then\n-               Write_Eol;\n-\n-               Write_Line (\"object files:\");\n-\n-               for Index in Object_Files'Range loop\n-                  Write_Str  (\"   \");\n-                  Write_Line (Object_Files (Index).all);\n-               end loop;\n-\n-               Write_Eol;\n-\n-               if Ali_Files'Length = 0 then\n-                  Write_Line (\"NO ALI files\");\n-\n-               else\n-                  Write_Line (\"ALI files:\");\n-\n-                  for Index in Ali_Files'Range loop\n-                     Write_Str  (\"   \");\n-                     Write_Line (Ali_Files (Index).all);\n-                  end loop;\n-               end if;\n-\n-               Write_Eol;\n-            end if;\n-         end if;\n-\n-         --  We check that all object files are regular files\n-\n-         Check_Context;\n-\n-         --  Delete the existing library file, if it exists. Fail if the\n-         --  library file is not writable, or if it is not possible to delete\n-         --  the file.\n-\n-         declare\n-            DLL_Name : aliased String :=\n-                         Lib_Dirpath.all & Directory_Separator & DLL_Prefix &\n-                           Lib_Filename.all & \".\" & DLL_Ext;\n-\n-            Archive_Name : aliased String :=\n-                             Lib_Dirpath.all & Directory_Separator & \"lib\" &\n-                               Lib_Filename.all & \".\" & Archive_Ext;\n-\n-            type Str_Ptr is access all String;\n-            --  This type is necessary to meet the accessibility rules of Ada.\n-            --  It is not possible to use String_Access here.\n-\n-            Full_Lib_Name : Str_Ptr;\n-            --  Designates the full library path name. Either DLL_Name or\n-            --  Archive_Name, depending on the library kind.\n-\n-            Success : Boolean;\n-            pragma Warnings (Off, Success);\n-            --  Used to call Delete_File\n-\n-         begin\n-            if The_Build_Mode = Static then\n-               Full_Lib_Name := Archive_Name'Access;\n-            else\n-               Full_Lib_Name := DLL_Name'Access;\n-            end if;\n-\n-            if Is_Regular_File (Full_Lib_Name.all) then\n-               if Is_Writable_File (Full_Lib_Name.all) then\n-                  Delete_File (Full_Lib_Name.all, Success);\n-               end if;\n-\n-               if Is_Regular_File (Full_Lib_Name.all) then\n-                  Com.Fail (\"could not delete \"\"\" & Full_Lib_Name.all & \"\"\"\");\n-               end if;\n-            end if;\n-         end;\n-\n-         Argument_Number := 0;\n-\n-         --  If we have a standalone library, gather all the interface ALI.\n-         --  They are flagged as Interface when we copy them to the library\n-         --  directory (by Copy_ALI_Files, below).\n-\n-         if Standalone then\n-            Current_Proj := For_Project;\n-\n-            declare\n-               Iface : String_List_Id := For_Project.Lib_Interface_ALIs;\n-               ALI   : File_Name_Type;\n-\n-            begin\n-               while Iface /= Nil_String loop\n-                  ALI :=\n-                    File_Name_Type\n-                      (In_Tree.Shared.String_Elements.Table (Iface).Value);\n-                  Interface_ALIs.Set (ALI, True);\n-                  Get_Name_String\n-                    (In_Tree.Shared.String_Elements.Table (Iface).Value);\n-                  Add_Argument (Name_Buffer (1 .. Name_Len));\n-                  Iface := In_Tree.Shared.String_Elements.Table (Iface).Next;\n-               end loop;\n-\n-               Iface := For_Project.Lib_Interface_ALIs;\n-\n-               if not Opt.Quiet_Output then\n-\n-                  --  Check that the interface set is complete: any unit in the\n-                  --  library that is needed by an interface should also be an\n-                  --  interface. If it is not the case, output a warning.\n-\n-                  while Iface /= Nil_String loop\n-                     ALI :=\n-                       File_Name_Type\n-                         (In_Tree.Shared.String_Elements.Table (Iface).Value);\n-                     Process (ALI);\n-                     Iface :=\n-                       In_Tree.Shared.String_Elements.Table (Iface).Next;\n-                  end loop;\n-               end if;\n-            end;\n-         end if;\n-\n-         declare\n-            Current_Dir  : constant String := Get_Current_Dir;\n-            Dir          : Dir_Type;\n-\n-            Name : String (1 .. 200);\n-            Last : Natural;\n-\n-            Disregard : Boolean;\n-            pragma Warnings (Off, Disregard);\n-\n-            DLL_Name : aliased constant String :=\n-                         Lib_Filename.all & \".\" & DLL_Ext;\n-\n-            Archive_Name : aliased constant String :=\n-                             Lib_Filename.all & \".\" & Archive_Ext;\n-\n-            Delete : Boolean := False;\n-\n-         begin\n-            --  Clean the library directory: remove any file with the name of\n-            --  the library file and any ALI file of a source of the project.\n-\n-            begin\n-               Get_Name_String (For_Project.Library_Dir.Display_Name);\n-               Change_Dir (Name_Buffer (1 .. Name_Len));\n-\n-            exception\n-               when others =>\n-                  Com.Fail\n-                    (\"unable to access library directory \"\"\"\n-                     & Name_Buffer (1 .. Name_Len)\n-                     & \"\"\"\");\n-            end;\n-\n-            Open (Dir, \".\");\n-\n-            loop\n-               Read (Dir, Name, Last);\n-               exit when Last = 0;\n-\n-               declare\n-                  Filename : constant String := Name (1 .. Last);\n-\n-               begin\n-                  if Is_Regular_File (Filename) then\n-                     Canonical_Case_File_Name (Name (1 .. Last));\n-                     Delete := False;\n-\n-                     if (The_Build_Mode = Static\n-                          and then Name (1 .. Last) = Archive_Name)\n-                       or else\n-                         ((The_Build_Mode = Dynamic\n-                            or else\n-                           The_Build_Mode = Relocatable)\n-                          and then Name (1 .. Last) = DLL_Name)\n-                     then\n-                        Delete := True;\n-\n-                     elsif Last > 4\n-                       and then Name (Last - 3 .. Last) = \".ali\"\n-                     then\n-                        declare\n-                           Unit : Unit_Index;\n-\n-                        begin\n-                           --  Compare with ALI file names of the project\n-\n-                           Unit := Units_Htable.Get_First (In_Tree.Units_HT);\n-                           while Unit /= No_Unit_Index loop\n-                              if Unit.File_Names (Impl) /= null\n-                                and then Unit.File_Names (Impl).Project /=\n-                                                                 No_Project\n-                              then\n-                                 if Ultimate_Extending_Project_Of\n-                                      (Unit.File_Names (Impl).Project) =\n-                                                                 For_Project\n-                                 then\n-                                    Get_Name_String\n-                                      (Unit.File_Names (Impl).File);\n-                                    Name_Len :=\n-                                      Name_Len -\n-                                        File_Extension\n-                                          (Name (1 .. Name_Len))'Length;\n-\n-                                    if Name_Buffer (1 .. Name_Len) =\n-                                      Name (1 .. Last - 4)\n-                                    then\n-                                       Delete := True;\n-                                       exit;\n-                                    end if;\n-                                 end if;\n-\n-                              elsif Unit.File_Names (Spec) /= null\n-                                and then Ultimate_Extending_Project_Of\n-                                           (Unit.File_Names (Spec).Project) =\n-                                                                   For_Project\n-                              then\n-                                 Get_Name_String (Unit.File_Names (Spec).File);\n-                                 Name_Len :=\n-                                   Name_Len -\n-                                     File_Extension (Name (1 .. Last))'Length;\n-\n-                                 if Name_Buffer (1 .. Name_Len) =\n-                                      Name (1 .. Last - 4)\n-                                 then\n-                                    Delete := True;\n-                                    exit;\n-                                 end if;\n-                              end if;\n-\n-                              Unit := Units_Htable.Get_Next (In_Tree.Units_HT);\n-                           end loop;\n-                        end;\n-                     end if;\n-\n-                     if Delete then\n-                        Set_Writable (Filename);\n-                        Delete_File (Filename, Disregard);\n-                     end if;\n-                  end if;\n-               end;\n-            end loop;\n-\n-            Close (Dir);\n-\n-            Change_Dir (Current_Dir);\n-         end;\n-\n-         --  Call procedure to build the library, depending on the build mode\n-\n-         case The_Build_Mode is\n-            when Dynamic\n-               | Relocatable\n-            =>\n-               Build_Dynamic_Library\n-                 (Ofiles        => Object_Files.all,\n-                  Options       => Options.all,\n-                  Interfaces    => Arguments (1 .. Argument_Number),\n-                  Lib_Filename  => Lib_Filename.all,\n-                  Lib_Dir       => Lib_Dirpath.all,\n-                  Symbol_Data   => Current_Proj.Symbol_Data,\n-                  Driver_Name   => Driver_Name,\n-                  Lib_Version   => Lib_Version.all,\n-                  Auto_Init     => Current_Proj.Lib_Auto_Init);\n-\n-            when Static =>\n-               MLib.Build_Library\n-                 (Object_Files.all,\n-                  Lib_Filename.all,\n-                  Lib_Dirpath.all);\n-\n-            when None =>\n-               null;\n-         end case;\n-\n-         --  We need to copy the ALI files from the object directory to the\n-         --  library ALI directory, so that the linker find them there, and\n-         --  does not need to look in the object directory where it would also\n-         --  find the object files; and we don't want that: we want the linker\n-         --  to use the library.\n-\n-         --  Copy the ALI files and make the copies read-only. For interfaces,\n-         --  mark the copies as interfaces.\n-\n-         Copy_ALI_Files\n-           (Files      => Ali_Files.all,\n-            To         => For_Project.Library_ALI_Dir.Display_Name,\n-            Interfaces => Arguments (1 .. Argument_Number));\n-\n-         --  Copy interface sources if Library_Src_Dir specified\n-\n-         if Standalone\n-           and then For_Project.Library_Src_Dir /= No_Path_Information\n-         then\n-            --  Clean the interface copy directory: remove any source that\n-            --  could be a source of the project.\n-\n-            begin\n-               Get_Name_String (For_Project.Library_Src_Dir.Display_Name);\n-               Change_Dir (Name_Buffer (1 .. Name_Len));\n-\n-            exception\n-               when others =>\n-                  Com.Fail\n-                    (\"unable to access library source copy directory \"\"\"\n-                     & Name_Buffer (1 .. Name_Len)\n-                     & \"\"\"\");\n-            end;\n-\n-            declare\n-               Dir    : Dir_Type;\n-               Delete : Boolean := False;\n-               Unit   : Unit_Index;\n-\n-               Name : String (1 .. 200);\n-               Last : Natural;\n-\n-               Disregard : Boolean;\n-               pragma Warnings (Off, Disregard);\n-\n-            begin\n-               Open (Dir, \".\");\n-\n-               loop\n-                  Read (Dir, Name, Last);\n-                  exit when Last = 0;\n-\n-                  if Is_Regular_File (Name (1 .. Last)) then\n-                     Canonical_Case_File_Name (Name (1 .. Last));\n-                     Delete := False;\n-\n-                     --  Compare with source file names of the project\n-\n-                     Unit := Units_Htable.Get_First (In_Tree.Units_HT);\n-                     while Unit /= No_Unit_Index loop\n-                        if Unit.File_Names (Impl) /= null\n-                          and then Ultimate_Extending_Project_Of\n-                            (Unit.File_Names (Impl).Project) = For_Project\n-                          and then\n-                            Get_Name_String\n-                              (Unit.File_Names (Impl).File) =\n-                            Name (1 .. Last)\n-                        then\n-                           Delete := True;\n-                           exit;\n-                        end if;\n-\n-                        if Unit.File_Names (Spec) /= null\n-                          and then Ultimate_Extending_Project_Of\n-                            (Unit.File_Names (Spec).Project) =\n-                             For_Project\n-                          and then\n-                           Get_Name_String\n-                             (Unit.File_Names (Spec).File) =\n-                           Name (1 .. Last)\n-                        then\n-                           Delete := True;\n-                           exit;\n-                        end if;\n-\n-                        Unit := Units_Htable.Get_Next (In_Tree.Units_HT);\n-                     end loop;\n-                  end if;\n-\n-                  if Delete then\n-                     Set_Writable (Name (1 .. Last));\n-                     Delete_File (Name (1 .. Last), Disregard);\n-                  end if;\n-               end loop;\n-\n-               Close (Dir);\n-            end;\n-\n-            Copy_Interface_Sources\n-              (For_Project => For_Project,\n-               In_Tree     => In_Tree,\n-               Interfaces  => Arguments (1 .. Argument_Number),\n-               To_Dir      => For_Project.Library_Src_Dir.Display_Name);\n-         end if;\n-      end if;\n-\n-      --  Reset the current working directory to its previous value\n-\n-      Change_Dir (Current_Dir);\n-   end Build_Library;\n-\n-   -----------\n-   -- Check --\n-   -----------\n-\n-   procedure Check (Filename : String) is\n-   begin\n-      if not Is_Regular_File (Filename) then\n-         Com.Fail (Filename & \" not found.\");\n-      end if;\n-   end Check;\n-\n-   -------------------\n-   -- Check_Context --\n-   -------------------\n-\n-   procedure Check_Context is\n-   begin\n-      --  Check that each object file exists\n-\n-      for F in Object_Files'Range loop\n-         Check (Object_Files (F).all);\n-      end loop;\n-   end Check_Context;\n-\n-   -------------------\n-   -- Check_Library --\n-   -------------------\n-\n-   procedure Check_Library\n-     (For_Project : Project_Id; In_Tree : Project_Tree_Ref)\n-   is\n-      Lib_TS  : Time_Stamp_Type;\n-      Current : constant Dir_Name_Str := Get_Current_Dir;\n-\n-   begin\n-      --  No need to build the library if there is no object directory,\n-      --  hence no object files to build the library.\n-\n-      if For_Project.Library then\n-         declare\n-            Lib_Name : constant File_Name_Type :=\n-                         Library_File_Name_For (For_Project, In_Tree);\n-         begin\n-            Change_Dir\n-              (Get_Name_String (For_Project.Library_Dir.Display_Name));\n-            Lib_TS := File_Stamp (Lib_Name);\n-            For_Project.Library_TS := Lib_TS;\n-         end;\n-\n-         if not For_Project.Externally_Built\n-           and then not For_Project.Need_To_Build_Lib\n-           and then For_Project.Object_Directory /= No_Path_Information\n-         then\n-            declare\n-               Obj_TS     : Time_Stamp_Type;\n-               Object_Dir : Dir_Type;\n-\n-            begin\n-               --  If the library file does not exist, then the time stamp will\n-               --  be Empty_Time_Stamp, earlier than any other time stamp.\n-\n-               Change_Dir\n-                 (Get_Name_String (For_Project.Object_Directory.Display_Name));\n-               Open (Dir => Object_Dir, Dir_Name => \".\");\n-\n-               --  For all entries in the object directory\n-\n-               loop\n-                  Read (Object_Dir, Name_Buffer, Name_Len);\n-                  exit when Name_Len = 0;\n-\n-                  --  Check if it is an object file, but ignore any binder\n-                  --  generated file.\n-\n-                  if Is_Obj (Name_Buffer (1 .. Name_Len))\n-                    and then Name_Buffer (1 .. B_Start'Length) /= B_Start\n-                  then\n-                     --  Get the object file time stamp\n-\n-                     Obj_TS := File_Stamp (File_Name_Type'(Name_Find));\n-\n-                     --  If library file time stamp is earlier, set\n-                     --  Need_To_Build_Lib and return. String comparison is\n-                     --  used, otherwise time stamps may be too close and the\n-                     --  comparison would return True, which would trigger\n-                     --  an unnecessary rebuild of the library.\n-\n-                     if String (Lib_TS) < String (Obj_TS) then\n-\n-                        --  Library must be rebuilt\n-\n-                        For_Project.Need_To_Build_Lib := True;\n-                        exit;\n-                     end if;\n-                  end if;\n-               end loop;\n-\n-               Close (Object_Dir);\n-            end;\n-         end if;\n-\n-         Change_Dir (Current);\n-      end if;\n-   end Check_Library;\n-\n-   ----------------------------\n-   -- Copy_Interface_Sources --\n-   ----------------------------\n-\n-   procedure Copy_Interface_Sources\n-     (For_Project : Project_Id;\n-      In_Tree     : Project_Tree_Ref;\n-      Interfaces  : Argument_List;\n-      To_Dir      : Path_Name_Type)\n-   is\n-      Current : constant Dir_Name_Str := Get_Current_Dir;\n-      --  The current directory, where to return to at the end\n-\n-      Target : constant Dir_Name_Str := Get_Name_String (To_Dir);\n-      --  The directory where to copy sources\n-\n-      Text     : Text_Buffer_Ptr;\n-      The_ALI  : ALI.ALI_Id;\n-      Lib_File : File_Name_Type;\n-\n-      First_Unit  : ALI.Unit_Id;\n-      Second_Unit : ALI.Unit_Id;\n-\n-      Copy_Subunits : Boolean := False;\n-      --  When True, indicates that subunits, if any, need to be copied too\n-\n-      procedure Copy (File_Name : File_Name_Type);\n-      --  Copy one source of the project to the target directory\n-\n-      ----------\n-      -- Copy --\n-      ----------\n-\n-      procedure Copy (File_Name : File_Name_Type) is\n-         Success : Boolean;\n-         pragma Warnings (Off, Success);\n-\n-         Source : Standard.Prj.Source_Id;\n-      begin\n-         Source := Find_Source\n-           (In_Tree, For_Project,\n-            In_Extended_Only => True,\n-            Base_Name => File_Name);\n-\n-         if Source /= No_Source\n-           and then not Source.Locally_Removed\n-           and then Source.Replaced_By = No_Source\n-         then\n-            Copy_File\n-              (Get_Name_String (Source.Path.Name),\n-               Target,\n-               Success,\n-               Mode     => Overwrite,\n-               Preserve => Preserve);\n-         end if;\n-      end Copy;\n-\n-   --  Start of processing for Copy_Interface_Sources\n-\n-   begin\n-      --  Change the working directory to the object directory\n-\n-      Change_Dir (Get_Name_String (For_Project.Object_Directory.Display_Name));\n-\n-      for Index in Interfaces'Range loop\n-\n-         --  First, load the ALI file\n-\n-         Name_Len := 0;\n-         Add_Str_To_Name_Buffer (Interfaces (Index).all);\n-         Lib_File := Name_Find;\n-         Text := Read_Library_Info (Lib_File);\n-         The_ALI := Scan_ALI (Lib_File, Text, Ignore_ED => False, Err => True);\n-         Free (Text);\n-\n-         Second_Unit := No_Unit_Id;\n-         First_Unit := ALI.ALIs.Table (The_ALI).First_Unit;\n-         Copy_Subunits := True;\n-\n-         --  If there is both a spec and a body, check if they are both needed\n-\n-         if ALI.Units.Table (First_Unit).Utype = Is_Body then\n-            Second_Unit := ALI.ALIs.Table (The_ALI).Last_Unit;\n-\n-            --  If the body is not needed, then reset First_Unit\n-\n-            if not ALI.Units.Table (Second_Unit).Body_Needed_For_SAL then\n-               First_Unit := No_Unit_Id;\n-               Copy_Subunits := False;\n-            end if;\n-\n-         elsif ALI.Units.Table (First_Unit).Utype = Is_Spec_Only then\n-            Copy_Subunits := False;\n-         end if;\n-\n-         --  Copy the file(s) that need to be copied\n-\n-         if First_Unit /= No_Unit_Id then\n-            Copy (File_Name => ALI.Units.Table (First_Unit).Sfile);\n-         end if;\n-\n-         if Second_Unit /= No_Unit_Id then\n-            Copy (File_Name => ALI.Units.Table (Second_Unit).Sfile);\n-         end if;\n-\n-         --  Copy all the separates, if any\n-\n-         if Copy_Subunits then\n-            for Dep in ALI.ALIs.Table (The_ALI).First_Sdep ..\n-              ALI.ALIs.Table (The_ALI).Last_Sdep\n-            loop\n-               if Sdep.Table (Dep).Subunit_Name /= No_Name then\n-                  Copy (File_Name => Sdep.Table (Dep).Sfile);\n-               end if;\n-            end loop;\n-         end if;\n-      end loop;\n-\n-      --  Restore the initial working directory\n-\n-      Change_Dir (Current);\n-   end Copy_Interface_Sources;\n-\n-   -------------\n-   -- Display --\n-   -------------\n-\n-   procedure Display (Executable : String) is\n-   begin\n-      if not Opt.Quiet_Output then\n-         Write_Str (Executable);\n-\n-         for Index in 1 .. Argument_Number loop\n-            Write_Char (' ');\n-            Write_Str (Arguments (Index).all);\n-\n-            if not Opt.Verbose_Mode and then Index > 4 then\n-               Write_Str (\" ...\");\n-               exit;\n-            end if;\n-         end loop;\n-\n-         Write_Eol;\n-      end if;\n-   end Display;\n-\n-   -----------\n-   -- Index --\n-   -----------\n-\n-   function Index (S, Pattern : String) return Natural is\n-      Len : constant Natural := Pattern'Length;\n-\n-   begin\n-      for J in reverse S'First .. S'Last - Len + 1 loop\n-         if Pattern = S (J .. J + Len - 1) then\n-            return J;\n-         end if;\n-      end loop;\n-\n-      return 0;\n-   end Index;\n-\n-   -------------------------\n-   -- Process_Binder_File --\n-   -------------------------\n-\n-   procedure Process_Binder_File (Name : String) is\n-      Fd : FILEs;\n-      --  Binder file's descriptor\n-\n-      Read_Mode : constant String := \"r\" & ASCII.NUL;\n-      --  For fopen\n-\n-      Status : Interfaces.C_Streams.int;\n-      pragma Unreferenced (Status);\n-      --  For fclose\n-\n-      Begin_Info : constant String := \"--  BEGIN Object file/option list\";\n-      End_Info   : constant String := \"--  END Object file/option list   \";\n-\n-      Next_Line : String (1 .. 1000);\n-      --  Current line value\n-      --  Where does this odd constant 1000 come from, looks suspicious ???\n-\n-      Nlast : Integer;\n-      --  End of line slice (the slice does not contain the line terminator)\n-\n-      procedure Get_Next_Line;\n-      --  Read the next line from the binder file without the line terminator\n-\n-      -------------------\n-      -- Get_Next_Line --\n-      -------------------\n-\n-      procedure Get_Next_Line is\n-         Fchars : chars;\n-\n-      begin\n-         Fchars := fgets (Next_Line'Address, Next_Line'Length, Fd);\n-\n-         if Fchars = System.Null_Address then\n-            Fail (\"Error reading binder output\");\n-         end if;\n-\n-         Nlast := 1;\n-         while Nlast <= Next_Line'Last\n-           and then Next_Line (Nlast) /= ASCII.LF\n-           and then Next_Line (Nlast) /= ASCII.CR\n-         loop\n-            Nlast := Nlast + 1;\n-         end loop;\n-\n-         Nlast := Nlast - 1;\n-      end Get_Next_Line;\n-\n-   --  Start of processing for Process_Binder_File\n-\n-   begin\n-      Fd := fopen (Name'Address, Read_Mode'Address);\n-\n-      if Fd = NULL_Stream then\n-         Fail (\"Failed to open binder output\");\n-      end if;\n-\n-      --  Skip up to the Begin Info line\n-\n-      loop\n-         Get_Next_Line;\n-         exit when Next_Line (1 .. Nlast) = Begin_Info;\n-      end loop;\n-\n-      --  Find the first switch\n-\n-      loop\n-         Get_Next_Line;\n-\n-         exit when Next_Line (1 .. Nlast) = End_Info;\n-\n-         --  As the binder generated file is in Ada, remove the first eight\n-         --  characters \"   --   \".\n-\n-         Next_Line (1 .. Nlast - 8) := Next_Line (9 .. Nlast);\n-         Nlast := Nlast - 8;\n-\n-         --  Stop when the first switch is found\n-\n-         exit when Next_Line (1) = '-';\n-      end loop;\n-\n-      if Next_Line (1 .. Nlast) /= End_Info then\n-         loop\n-            --  Ignore -static and -shared, since -shared will be used\n-            --  in any case.\n-\n-            --  Ignore -lgnat and -lgnarl as they will be added later,\n-            --  because they are also needed for non Stand-Alone shared\n-            --  libraries.\n-\n-            --  Also ignore the shared libraries which are:\n-\n-            --  -lgnat-<version>  (7 + version'length chars)\n-            --  -lgnarl-<version> (8 + version'length chars)\n-\n-            if Next_Line (1 .. Nlast) /= \"-static\" and then\n-               Next_Line (1 .. Nlast) /= \"-shared\" and then\n-               Next_Line (1 .. Nlast) /= \"-lgnarl\" and then\n-               Next_Line (1 .. Nlast) /= \"-lgnat\"\n-              and then\n-                Next_Line\n-                  (1 .. Natural'Min (Nlast, 8 + Library_Version'Length)) /=\n-                    Shared_Lib (\"gnarl\")\n-              and then\n-                Next_Line\n-                  (1 .. Natural'Min (Nlast, 7 + Library_Version'Length)) /=\n-                    Shared_Lib (\"gnat\")\n-            then\n-               if Next_Line (1) /= '-' then\n-\n-                  --  This is not an option, should we add it?\n-\n-                  if Add_Object_Files then\n-                     Opts.Increment_Last;\n-                     Opts.Table (Opts.Last) :=\n-                       new String'(Next_Line (1 .. Nlast));\n-                  end if;\n-\n-               else\n-                  --  Add all other options\n-\n-                  Opts.Increment_Last;\n-                  Opts.Table (Opts.Last) :=\n-                    new String'(Next_Line (1 .. Nlast));\n-               end if;\n-            end if;\n-\n-            --  Next option, if any\n-\n-            Get_Next_Line;\n-            exit when Next_Line (1 .. Nlast) = End_Info;\n-\n-            --  Remove first eight characters \"   --   \"\n-\n-            Next_Line (1 .. Nlast - 8) := Next_Line (9 .. Nlast);\n-            Nlast := Nlast - 8;\n-         end loop;\n-      end if;\n-\n-      Status := fclose (Fd);\n-\n-      --  Is it really right to ignore any close error ???\n-\n-   end Process_Binder_File;\n-\n-   ------------------\n-   -- Reset_Tables --\n-   ------------------\n-\n-   procedure Reset_Tables is\n-   begin\n-      Objects.Init;\n-      Objects_Htable.Reset;\n-      ALIs.Init;\n-      Opts.Init;\n-      Processed_Projects.Reset;\n-      Library_Projs.Init;\n-   end Reset_Tables;\n-\n-   ---------------------------\n-   -- SALs_Use_Constructors --\n-   ---------------------------\n-\n-   function SALs_Use_Constructors return Boolean is\n-      function C_SALs_Init_Using_Constructors return Integer;\n-      pragma Import (C, C_SALs_Init_Using_Constructors,\n-                     \"__gnat_sals_init_using_constructors\");\n-   begin\n-      return C_SALs_Init_Using_Constructors /= 0;\n-   end SALs_Use_Constructors;\n-\n-end MLib.Prj;"}, {"sha": "6a32dd3521004a0984d210f6a4fe8e8a6dd7ee0c", "filename": "gcc/ada/mlib-prj.ads", "status": "removed", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fmlib-prj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fmlib-prj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-prj.ads?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793", "patch": "@@ -1,55 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                            M L I B . P R J                               --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---                     Copyright (C) 2001-2007, AdaCore                     --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This package builds a library for a library project file\n-\n-with Prj; use Prj;\n-\n-package MLib.Prj is\n-\n-   procedure Build_Library\n-     (For_Project   : Project_Id;\n-      In_Tree       : Project_Tree_Ref;\n-      Gnatbind      : String;\n-      Gnatbind_Path : String_Access;\n-      Gcc           : String;\n-      Gcc_Path      : String_Access;\n-      Bind          : Boolean := True;\n-      Link          : Boolean := True);\n-   --  Build the library of library project For_Project.\n-   --  Fails if For_Project is not a library project file.\n-   --  Gnatbind, Gnatbind_Path, Gcc, Gcc_Path are used for standalone\n-   --  libraries, to call the binder and to compile the binder generated\n-   --  files. If Bind is False the binding of a stand-alone library is skipped.\n-   --  If Link is False, the library is not linked/built.\n-\n-   procedure Check_Library\n-     (For_Project : Project_Id;\n-      In_Tree     : Project_Tree_Ref);\n-   --  Check if the library of a library project needs to be rebuilt,\n-   --  because its time-stamp is earlier than the time stamp of one of its\n-   --  object files.\n-\n-end MLib.Prj;"}, {"sha": "9fb8b1593f92f9ce8e96f7be10496633aa269790", "filename": "gcc/ada/mlib-tgt-specific-aix.adb", "status": "removed", "additions": 0, "deletions": 225, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fmlib-tgt-specific-aix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fmlib-tgt-specific-aix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt-specific-aix.adb?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793", "patch": "@@ -1,225 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                     M L I B . T G T . S P E C I F I C                    --\n---                              (AIX Version)                               --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---                     Copyright (C) 2003-2008, AdaCore                     --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the AIX version of the body\n-\n-with Ada.Strings.Fixed; use Ada.Strings.Fixed;\n-\n-with MLib.Fil;\n-with MLib.Utl;\n-with Opt;\n-with Output;   use Output;\n-with Prj.Com;\n-with Prj.Util; use Prj.Util;\n-\n-package body MLib.Tgt.Specific is\n-\n-   --  Local subprograms\n-   --  These *ALL* require comments ???\n-\n-   function Archive_Indexer return String;\n-   --  What is this???\n-\n-   procedure Build_Dynamic_Library\n-     (Ofiles       : Argument_List;\n-      Options      : Argument_List;\n-      Interfaces   : Argument_List;\n-      Lib_Filename : String;\n-      Lib_Dir      : String;\n-      Symbol_Data  : Symbol_Record;\n-      Driver_Name  : Name_Id := No_Name;\n-      Lib_Version  : String  := \"\";\n-      Auto_Init    : Boolean := False);\n-\n-   function DLL_Ext return String;\n-\n-   function Library_Major_Minor_Id_Supported return Boolean;\n-\n-   function Support_For_Libraries return Library_Support;\n-\n-   --  Local variables\n-\n-   No_Arguments        : aliased Argument_List         := (1 .. 0 => null);\n-   Empty_Argument_List : constant Argument_List_Access := No_Arguments'Access;\n-\n-   Bexpall : aliased String := \"-Wl,-bexpall\";\n-   Bexpall_Option : constant String_Access := Bexpall'Access;\n-   --  The switch to export all symbols\n-\n-   Lpthreads : aliased String := \"-lpthreads\";\n-   Native_Thread_Options : aliased Argument_List := (1 => Lpthreads'Access);\n-   --  The switch to use when linking a library against libgnarl when using\n-   --  Native threads.\n-\n-   Lgthreads : aliased String := \"-lgthreads\";\n-   Lmalloc   : aliased String := \"-lmalloc\";\n-   FSU_Thread_Options : aliased Argument_List :=\n-                          (1 => Lgthreads'Access, 2 => Lmalloc'Access);\n-   --  The switches to use when linking a library against libgnarl when using\n-   --  FSU threads.\n-\n-   Thread_Options : Argument_List_Access := Empty_Argument_List;\n-   --  Designate the thread switches to used when linking a library against\n-   --  libgnarl. Depends on the thread library (Native or FSU). Resolved for\n-   --  the first library linked against libgnarl.\n-\n-   ---------------------\n-   -- Archive_Indexer --\n-   ---------------------\n-\n-   function Archive_Indexer return String is\n-   begin\n-      return \"\";\n-   end Archive_Indexer;\n-\n-   ---------------------------\n-   -- Build_Dynamic_Library --\n-   ---------------------------\n-\n-   procedure Build_Dynamic_Library\n-     (Ofiles       : Argument_List;\n-      Options      : Argument_List;\n-      Interfaces   : Argument_List;\n-      Lib_Filename : String;\n-      Lib_Dir      : String;\n-      Symbol_Data  : Symbol_Record;\n-      Driver_Name  : Name_Id := No_Name;\n-      Lib_Version  : String  := \"\";\n-      Auto_Init    : Boolean := False)\n-   is\n-      pragma Unreferenced (Interfaces);\n-      pragma Unreferenced (Symbol_Data);\n-      pragma Unreferenced (Lib_Version);\n-      pragma Unreferenced (Auto_Init);\n-\n-      Lib_File : constant String :=\n-                   Lib_Dir & Directory_Separator & \"lib\" &\n-                   MLib.Fil.Append_To (Lib_Filename, DLL_Ext);\n-      --  The file name of the library\n-\n-      Thread_Opts : Argument_List_Access := Empty_Argument_List;\n-      --  Set to Thread_Options if -lgnarl is found in the Options\n-\n-   begin\n-      if Opt.Verbose_Mode then\n-         Write_Str (\"building relocatable shared library \");\n-         Write_Line (Lib_File);\n-      end if;\n-\n-      --  Look for -lgnarl in Options. If found, set the thread options\n-\n-      for J in Options'Range loop\n-         if Options (J).all = \"-lgnarl\" then\n-\n-            --  If Thread_Options is null, read s-osinte.ads to discover the\n-            --  thread library and set Thread_Options accordingly.\n-\n-            if Thread_Options = null then\n-               declare\n-                  File : Text_File;\n-                  Line : String (1 .. 100);\n-                  Last : Natural;\n-\n-               begin\n-                  Open\n-                    (File, Include_Dir_Default_Prefix & \"/s-osinte.ads\");\n-\n-                  while not End_Of_File (File) loop\n-                     Get_Line (File, Line, Last);\n-\n-                     if Index (Line (1 .. Last), \"-lpthreads\") /= 0 then\n-                        Thread_Options := Native_Thread_Options'Access;\n-                        exit;\n-\n-                     elsif Index (Line (1 .. Last), \"-lgthreads\") /= 0 then\n-                        Thread_Options := FSU_Thread_Options'Access;\n-                        exit;\n-                     end if;\n-                  end loop;\n-\n-                  Close (File);\n-\n-                  if Thread_Options = null then\n-                     Prj.Com.Fail (\"cannot find the thread library in use\");\n-                  end if;\n-\n-               exception\n-                  when others =>\n-                     Prj.Com.Fail (\"cannot open s-osinte.ads\");\n-               end;\n-            end if;\n-\n-            Thread_Opts := Thread_Options;\n-            exit;\n-         end if;\n-      end loop;\n-\n-      --  Finally, call GCC (or the driver specified) to build the library\n-\n-      MLib.Utl.Gcc\n-        (Output_File => Lib_File,\n-         Objects     => Ofiles,\n-         Options     => Options & Bexpall_Option,\n-         Driver_Name => Driver_Name,\n-         Options_2   => Thread_Opts.all);\n-   end Build_Dynamic_Library;\n-\n-   -------------\n-   -- DLL_Ext --\n-   -------------\n-\n-   function DLL_Ext return String is\n-   begin\n-      return \"a\";\n-   end DLL_Ext;\n-\n-   --------------------------------------\n-   -- Library_Major_Minor_Id_Supported --\n-   --------------------------------------\n-\n-   function Library_Major_Minor_Id_Supported return Boolean is\n-   begin\n-      return False;\n-   end Library_Major_Minor_Id_Supported;\n-\n-   ---------------------------\n-   -- Support_For_Libraries --\n-   ---------------------------\n-\n-   function Support_For_Libraries return Library_Support is\n-   begin\n-      return Static_Only;\n-   end Support_For_Libraries;\n-\n-begin\n-   Archive_Indexer_Ptr := Archive_Indexer'Access;\n-   Build_Dynamic_Library_Ptr := Build_Dynamic_Library'Access;\n-   DLL_Ext_Ptr := DLL_Ext'Access;\n-   Library_Major_Minor_Id_Supported_Ptr :=\n-                                Library_Major_Minor_Id_Supported'Access;\n-   Support_For_Libraries_Ptr := Support_For_Libraries'Access;\n-\n-end MLib.Tgt.Specific;"}, {"sha": "bc54dbfb918948259826fc2e0f66e94c84cf9105", "filename": "gcc/ada/mlib-tgt-specific-darwin.adb", "status": "removed", "additions": 0, "deletions": 171, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fmlib-tgt-specific-darwin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fmlib-tgt-specific-darwin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt-specific-darwin.adb?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793", "patch": "@@ -1,171 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                     M L I B . T G T . S P E C I F I C                    --\n---                             (Darwin Version)                             --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 2001-2011, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the Darwin version of the body\n-\n-with MLib;     use MLib;\n-with MLib.Fil;\n-with MLib.Utl;\n-with Opt;      use Opt;\n-with Output;   use Output;\n-\n-package body MLib.Tgt.Specific is\n-\n-   --  Non default subprograms\n-\n-   procedure Build_Dynamic_Library\n-     (Ofiles       : Argument_List;\n-      Options      : Argument_List;\n-      Interfaces   : Argument_List;\n-      Lib_Filename : String;\n-      Lib_Dir      : String;\n-      Symbol_Data  : Symbol_Record;\n-      Driver_Name  : Name_Id := No_Name;\n-      Lib_Version  : String  := \"\";\n-      Auto_Init    : Boolean := False);\n-\n-   function DLL_Ext return String;\n-\n-   function Dynamic_Option return String;\n-\n-   function Is_Archive_Ext (Ext : String) return Boolean;\n-\n-   --  Local objects\n-\n-   Shared_Libgcc  : aliased String := \"-shared-libgcc\";\n-\n-   Shared_Options : constant Argument_List :=\n-                      (1 => Shared_Libgcc'Access);\n-\n-   ---------------------------\n-   -- Build_Dynamic_Library --\n-   ---------------------------\n-\n-   procedure Build_Dynamic_Library\n-     (Ofiles       : Argument_List;\n-      Options      : Argument_List;\n-      Interfaces   : Argument_List;\n-      Lib_Filename : String;\n-      Lib_Dir      : String;\n-      Symbol_Data  : Symbol_Record;\n-      Driver_Name  : Name_Id := No_Name;\n-      Lib_Version  : String  := \"\";\n-      Auto_Init    : Boolean := False)\n-   is\n-      pragma Unreferenced (Interfaces);\n-      pragma Unreferenced (Symbol_Data);\n-      pragma Unreferenced (Auto_Init);\n-\n-      Lib_File : constant String :=\n-                   \"lib\" & Fil.Append_To (Lib_Filename, DLL_Ext);\n-\n-      Lib_Path : constant String :=\n-                   Lib_Dir & Directory_Separator & Lib_File;\n-\n-      Symbolic_Link_Needed : Boolean := False;\n-\n-   begin\n-      if Opt.Verbose_Mode then\n-         Write_Str (\"building relocatable shared library \");\n-         Write_Line (Lib_File);\n-      end if;\n-\n-      --  If specified, add automatic elaboration/finalization\n-\n-      if Lib_Version = \"\" then\n-         Utl.Gcc\n-           (Output_File => Lib_Path,\n-            Objects     => Ofiles,\n-            Options     => Options & Shared_Options,\n-            Driver_Name => Driver_Name,\n-            Options_2   => No_Argument_List);\n-\n-      else\n-         declare\n-            Maj_Version : constant String :=\n-                            Major_Id_Name (Lib_File, Lib_Version);\n-         begin\n-            if Is_Absolute_Path (Lib_Version) then\n-               Utl.Gcc\n-                 (Output_File => Lib_Version,\n-                  Objects     => Ofiles,\n-                  Options     => Options & Shared_Options,\n-                  Driver_Name => Driver_Name,\n-                  Options_2   => No_Argument_List);\n-               Symbolic_Link_Needed := Lib_Version /= Lib_Path;\n-\n-            else\n-               Utl.Gcc\n-                 (Output_File => Lib_Dir & Directory_Separator & Lib_Version,\n-                  Objects     => Ofiles,\n-                  Options     => Options & Shared_Options,\n-                  Driver_Name => Driver_Name,\n-                  Options_2   => No_Argument_List);\n-               Symbolic_Link_Needed :=\n-                 Lib_Dir & Directory_Separator & Lib_Version /= Lib_Path;\n-            end if;\n-\n-            if Symbolic_Link_Needed then\n-               Create_Sym_Links\n-                 (Lib_Path, Lib_Version, Lib_Dir, Maj_Version);\n-            end if;\n-         end;\n-      end if;\n-   end Build_Dynamic_Library;\n-\n-   -------------\n-   -- DLL_Ext --\n-   -------------\n-\n-   function DLL_Ext return String is\n-   begin\n-      return \"dylib\";\n-   end DLL_Ext;\n-\n-   --------------------\n-   -- Dynamic_Option --\n-   --------------------\n-\n-   function Dynamic_Option return String is\n-   begin\n-      return \"-dynamiclib\";\n-   end Dynamic_Option;\n-\n-   --------------------\n-   -- Is_Archive_Ext --\n-   --------------------\n-\n-   function Is_Archive_Ext (Ext : String) return Boolean is\n-   begin\n-      return Ext = \".dylib\" or else Ext = \".a\";\n-   end Is_Archive_Ext;\n-\n-begin\n-   Build_Dynamic_Library_Ptr := Build_Dynamic_Library'Access;\n-   DLL_Ext_Ptr := DLL_Ext'Access;\n-   Dynamic_Option_Ptr := Dynamic_Option'Access;\n-   Is_Archive_Ext_Ptr := Is_Archive_Ext'Access;\n-end MLib.Tgt.Specific;"}, {"sha": "57e40841a8003688a6a3996dcc758cc14fba11cc", "filename": "gcc/ada/mlib-tgt-specific-hpux.adb", "status": "removed", "additions": 0, "deletions": 163, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fmlib-tgt-specific-hpux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fmlib-tgt-specific-hpux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt-specific-hpux.adb?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793", "patch": "@@ -1,163 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                     M L I B . T G T . S P E C I F I C                    --\n---                             (HP-UX Version)                              --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---                     Copyright (C) 2003-2014, AdaCore                     --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the HP-UX version of the body\n-\n-with MLib.Fil;\n-with MLib.Utl;\n-with Opt;\n-with Output; use Output;\n-\n-package body MLib.Tgt.Specific is\n-\n-   --  Non default subprograms\n-\n-   procedure Build_Dynamic_Library\n-     (Ofiles       : Argument_List;\n-      Options      : Argument_List;\n-      Interfaces   : Argument_List;\n-      Lib_Filename : String;\n-      Lib_Dir      : String;\n-      Symbol_Data  : Symbol_Record;\n-      Driver_Name  : Name_Id := No_Name;\n-      Lib_Version  : String  := \"\";\n-      Auto_Init    : Boolean := False);\n-\n-   function DLL_Ext return String;\n-\n-   function Is_Archive_Ext (Ext : String) return Boolean;\n-\n-   ---------------------------\n-   -- Build_Dynamic_Library --\n-   ---------------------------\n-\n-   procedure Build_Dynamic_Library\n-     (Ofiles       : Argument_List;\n-      Options      : Argument_List;\n-      Interfaces   : Argument_List;\n-      Lib_Filename : String;\n-      Lib_Dir      : String;\n-      Symbol_Data  : Symbol_Record;\n-      Driver_Name  : Name_Id := No_Name;\n-      Lib_Version  : String  := \"\";\n-      Auto_Init    : Boolean := False)\n-   is\n-      pragma Unreferenced (Interfaces);\n-      pragma Unreferenced (Symbol_Data);\n-      pragma Unreferenced (Auto_Init);\n-\n-      Lib_File : constant String :=\n-                   \"lib\" & Fil.Append_To (Lib_Filename, DLL_Ext);\n-\n-      Lib_Path : constant String :=\n-                   Lib_Dir & Directory_Separator & Lib_File;\n-\n-      Version_Arg          : String_Access;\n-      Symbolic_Link_Needed : Boolean := False;\n-\n-      Common_Options : constant Argument_List :=\n-                         Options & new String'(PIC_Option);\n-      --  Common set of options to the gcc command performing the link. On\n-      --  HPUX, this command eventually resorts to collect2, which may generate\n-      --  a C file and compile it on the fly. This compilation also generates\n-      --  position independent code for the final link to succeed.\n-   begin\n-      if Opt.Verbose_Mode then\n-         Write_Str (\"building relocatable shared library \");\n-         Write_Line (Lib_Path);\n-      end if;\n-\n-      if Lib_Version = \"\" then\n-         MLib.Utl.Gcc\n-           (Output_File => Lib_Path,\n-            Objects     => Ofiles,\n-            Options     => Common_Options,\n-            Options_2   => No_Argument_List,\n-            Driver_Name => Driver_Name);\n-\n-      else\n-         declare\n-            Maj_Version : constant String :=\n-                            Major_Id_Name (Lib_File, Lib_Version);\n-         begin\n-            if Maj_Version'Length /= 0 then\n-               Version_Arg := new String'(\"-Wl,+h,\" & Maj_Version);\n-\n-            else\n-               Version_Arg := new String'(\"-Wl,+h,\" & Lib_Version);\n-            end if;\n-\n-            if Is_Absolute_Path (Lib_Version) then\n-               MLib.Utl.Gcc\n-                 (Output_File => Lib_Version,\n-                  Objects     => Ofiles,\n-                  Options     => Common_Options & Version_Arg,\n-                  Options_2   => No_Argument_List,\n-                  Driver_Name => Driver_Name);\n-               Symbolic_Link_Needed := Lib_Version /= Lib_Path;\n-\n-            else\n-               MLib.Utl.Gcc\n-                 (Output_File => Lib_Dir & Directory_Separator & Lib_Version,\n-                  Objects     => Ofiles,\n-                  Options     => Common_Options & Version_Arg,\n-                  Options_2   => No_Argument_List,\n-                  Driver_Name => Driver_Name);\n-               Symbolic_Link_Needed :=\n-                 Lib_Dir & Directory_Separator & Lib_Version /= Lib_Path;\n-            end if;\n-\n-            if Symbolic_Link_Needed then\n-               Create_Sym_Links\n-                 (Lib_Path, Lib_Version, Lib_Dir, Maj_Version);\n-            end if;\n-         end;\n-      end if;\n-   end Build_Dynamic_Library;\n-\n-   -------------\n-   -- DLL_Ext --\n-   -------------\n-\n-   function DLL_Ext return String is\n-   begin\n-      return \"sl\";\n-   end DLL_Ext;\n-\n-   --------------------\n-   -- Is_Archive_Ext --\n-   --------------------\n-\n-   function Is_Archive_Ext (Ext : String) return Boolean is\n-   begin\n-      return Ext = \".a\" or else Ext = \".so\";\n-   end Is_Archive_Ext;\n-\n-begin\n-   Build_Dynamic_Library_Ptr := Build_Dynamic_Library'Access;\n-   DLL_Ext_Ptr := DLL_Ext'Access;\n-   Is_Archive_Ext_Ptr := Is_Archive_Ext'Access;\n-end MLib.Tgt.Specific;"}, {"sha": "8559966bfe56dcdd6a060a4ab626a7406f3cd5e2", "filename": "gcc/ada/mlib-tgt-specific-linux.adb", "status": "removed", "additions": 0, "deletions": 148, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fmlib-tgt-specific-linux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fmlib-tgt-specific-linux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt-specific-linux.adb?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793", "patch": "@@ -1,148 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                    M L I B . T G T . S P E C I F I C                     --\n---                           (GNU/Linux Version)                            --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 2001-2008, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the GNU/Linux version of the body\n-\n-with MLib.Fil;\n-with MLib.Utl;\n-with Opt;\n-with Output; use Output;\n-\n-package body MLib.Tgt.Specific is\n-\n-   use MLib;\n-\n-   --  Non default subprograms\n-\n-   procedure Build_Dynamic_Library\n-     (Ofiles       : Argument_List;\n-      Options      : Argument_List;\n-      Interfaces   : Argument_List;\n-      Lib_Filename : String;\n-      Lib_Dir      : String;\n-      Symbol_Data  : Symbol_Record;\n-      Driver_Name  : Name_Id := No_Name;\n-      Lib_Version  : String  := \"\";\n-      Auto_Init    : Boolean := False);\n-\n-   function Is_Archive_Ext (Ext : String) return Boolean;\n-\n-   ---------------------------\n-   -- Build_Dynamic_Library --\n-   ---------------------------\n-\n-   procedure Build_Dynamic_Library\n-     (Ofiles       : Argument_List;\n-      Options      : Argument_List;\n-      Interfaces   : Argument_List;\n-      Lib_Filename : String;\n-      Lib_Dir      : String;\n-      Symbol_Data  : Symbol_Record;\n-      Driver_Name  : Name_Id := No_Name;\n-      Lib_Version  : String  := \"\";\n-      Auto_Init    : Boolean := False)\n-   is\n-      pragma Unreferenced (Interfaces);\n-      pragma Unreferenced (Symbol_Data);\n-      pragma Unreferenced (Auto_Init);\n-      --  Initialization is done through the constructor mechanism\n-\n-      Lib_File : constant String :=\n-                   \"lib\" & Fil.Append_To (Lib_Filename, DLL_Ext);\n-\n-      Lib_Path : constant String :=\n-                   Lib_Dir & Directory_Separator & Lib_File;\n-\n-      Version_Arg          : String_Access;\n-      Symbolic_Link_Needed : Boolean := False;\n-\n-   begin\n-      if Opt.Verbose_Mode then\n-         Write_Str (\"building relocatable shared library \");\n-         Write_Line (Lib_Path);\n-      end if;\n-\n-      if Lib_Version = \"\" then\n-         Utl.Gcc\n-           (Output_File => Lib_Path,\n-            Objects     => Ofiles,\n-            Options     => Options,\n-            Driver_Name => Driver_Name,\n-            Options_2   => No_Argument_List);\n-\n-      else\n-         declare\n-            Maj_Version : constant String :=\n-                            Major_Id_Name (Lib_File, Lib_Version);\n-         begin\n-            if Maj_Version'Length /= 0 then\n-               Version_Arg := new String'(\"-Wl,-soname,\" & Maj_Version);\n-\n-            else\n-               Version_Arg := new String'(\"-Wl,-soname,\" & Lib_Version);\n-            end if;\n-\n-            if Is_Absolute_Path (Lib_Version) then\n-               Utl.Gcc\n-                 (Output_File => Lib_Version,\n-                  Objects     => Ofiles,\n-                  Options     => Options & Version_Arg,\n-                  Driver_Name => Driver_Name,\n-                  Options_2   => No_Argument_List);\n-               Symbolic_Link_Needed := Lib_Version /= Lib_Path;\n-\n-            else\n-               Utl.Gcc\n-                 (Output_File => Lib_Dir & Directory_Separator & Lib_Version,\n-                  Objects     => Ofiles,\n-                  Options     => Options & Version_Arg,\n-                  Driver_Name => Driver_Name,\n-                  Options_2   => No_Argument_List);\n-               Symbolic_Link_Needed :=\n-                 Lib_Dir & Directory_Separator & Lib_Version /= Lib_Path;\n-            end if;\n-\n-            if Symbolic_Link_Needed then\n-               Create_Sym_Links\n-                 (Lib_Path, Lib_Version, Lib_Dir, Maj_Version);\n-            end if;\n-         end;\n-      end if;\n-   end Build_Dynamic_Library;\n-\n-   --------------------\n-   -- Is_Archive_Ext --\n-   --------------------\n-\n-   function Is_Archive_Ext (Ext : String) return Boolean is\n-   begin\n-      return Ext = \".a\" or else Ext = \".so\";\n-   end Is_Archive_Ext;\n-\n-begin\n-   Build_Dynamic_Library_Ptr := Build_Dynamic_Library'Access;\n-   Is_Archive_Ext_Ptr := Is_Archive_Ext'Access;\n-end MLib.Tgt.Specific;"}, {"sha": "f1eedf5f23455a83722dcdd61335c8c863e6a892", "filename": "gcc/ada/mlib-tgt-specific-mingw.adb", "status": "removed", "additions": 0, "deletions": 162, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fmlib-tgt-specific-mingw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fmlib-tgt-specific-mingw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt-specific-mingw.adb?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793", "patch": "@@ -1,162 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                    M L I B . T G T . S P E C I F I C                     --\n---                            (Windows Version)                             --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 2002-2010, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the Windows version of the body. Works only with GCC versions\n---  supporting the \"-shared\" option.\n-\n-with Opt;\n-with Output; use Output;\n-\n-with MLib.Fil;\n-with MLib.Utl;\n-\n-package body MLib.Tgt.Specific is\n-\n-   package Files renames MLib.Fil;\n-   package Tools renames MLib.Utl;\n-\n-   --  Non default subprograms\n-\n-   procedure Build_Dynamic_Library\n-     (Ofiles       : Argument_List;\n-      Options      : Argument_List;\n-      Interfaces   : Argument_List;\n-      Lib_Filename : String;\n-      Lib_Dir      : String;\n-      Symbol_Data  : Symbol_Record;\n-      Driver_Name  : Name_Id := No_Name;\n-      Lib_Version  : String  := \"\";\n-      Auto_Init    : Boolean := False);\n-\n-   function DLL_Ext return String;\n-\n-   function DLL_Prefix return String;\n-\n-   function Is_Archive_Ext (Ext : String) return Boolean;\n-\n-   function Library_Major_Minor_Id_Supported return Boolean;\n-\n-   function PIC_Option return String;\n-\n-   Shared_Libgcc : aliased String := \"-shared-libgcc\";\n-\n-   Shared_Libgcc_Switch : constant Argument_List :=\n-                            (1 => Shared_Libgcc'Access);\n-\n-   ---------------------------\n-   -- Build_Dynamic_Library --\n-   ---------------------------\n-\n-   procedure Build_Dynamic_Library\n-     (Ofiles       : Argument_List;\n-      Options      : Argument_List;\n-      Interfaces   : Argument_List;\n-      Lib_Filename : String;\n-      Lib_Dir      : String;\n-      Symbol_Data  : Symbol_Record;\n-      Driver_Name  : Name_Id := No_Name;\n-      Lib_Version  : String  := \"\";\n-      Auto_Init    : Boolean := False)\n-   is\n-      pragma Unreferenced (Symbol_Data);\n-      pragma Unreferenced (Interfaces);\n-      pragma Unreferenced (Lib_Version);\n-      pragma Unreferenced (Auto_Init);\n-\n-      Lib_File : constant String :=\n-                   Lib_Dir & Directory_Separator &\n-                   DLL_Prefix & Files.Append_To (Lib_Filename, DLL_Ext);\n-\n-   --  Start of processing for Build_Dynamic_Library\n-\n-   begin\n-      if Opt.Verbose_Mode then\n-         Write_Str (\"building relocatable shared library \");\n-         Write_Line (Lib_File);\n-      end if;\n-\n-      Tools.Gcc\n-        (Output_File => Lib_File,\n-         Objects     => Ofiles,\n-         Options     => Shared_Libgcc_Switch,\n-         Options_2   => Options,\n-         Driver_Name => Driver_Name);\n-   end Build_Dynamic_Library;\n-\n-   -------------\n-   -- DLL_Ext --\n-   -------------\n-\n-   function DLL_Ext return String is\n-   begin\n-      return \"dll\";\n-   end DLL_Ext;\n-\n-   ----------------\n-   -- DLL_Prefix --\n-   ----------------\n-\n-   function DLL_Prefix return String is\n-   begin\n-      return \"lib\";\n-   end DLL_Prefix;\n-\n-   --------------------\n-   -- Is_Archive_Ext --\n-   --------------------\n-\n-   function Is_Archive_Ext (Ext : String) return Boolean is\n-   begin\n-      return Ext = \".a\" or else Ext = \".dll\";\n-   end Is_Archive_Ext;\n-\n-   --------------------------------------\n-   -- Library_Major_Minor_Id_Supported --\n-   --------------------------------------\n-\n-   function Library_Major_Minor_Id_Supported return Boolean is\n-   begin\n-      return False;\n-   end Library_Major_Minor_Id_Supported;\n-\n-   ----------------\n-   -- PIC_Option --\n-   ----------------\n-\n-   function PIC_Option return String is\n-   begin\n-      return \"\";\n-   end PIC_Option;\n-\n-begin\n-   Build_Dynamic_Library_Ptr := Build_Dynamic_Library'Access;\n-   DLL_Ext_Ptr               := DLL_Ext'Access;\n-   DLL_Prefix_Ptr            := DLL_Prefix'Access;\n-   Is_Archive_Ext_Ptr        := Is_Archive_Ext'Access;\n-   PIC_Option_Ptr            := PIC_Option'Access;\n-   Library_Major_Minor_Id_Supported_Ptr :=\n-                                Library_Major_Minor_Id_Supported'Access;\n-end MLib.Tgt.Specific;"}, {"sha": "d7cdfcc49afaeb3eda2c56d38db6fc412da3d6e1", "filename": "gcc/ada/mlib-tgt-specific-solaris.adb", "status": "removed", "additions": 0, "deletions": 145, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fmlib-tgt-specific-solaris.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fmlib-tgt-specific-solaris.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt-specific-solaris.adb?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793", "patch": "@@ -1,145 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                    M L I B . T G T . S P E C I F I C                     --\n---                            (Solaris Version)                             --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---              Copyright (C) 2002-2008, Free Software Foundation, Inc.     --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the Solaris version of the body\n-\n-with MLib.Fil;\n-with MLib.Utl;\n-with Opt;\n-with Output; use Output;\n-\n-package body MLib.Tgt.Specific is\n-\n-   --  Non default subprograms\n-\n-   procedure Build_Dynamic_Library\n-     (Ofiles       : Argument_List;\n-      Options      : Argument_List;\n-      Interfaces   : Argument_List;\n-      Lib_Filename : String;\n-      Lib_Dir      : String;\n-      Symbol_Data  : Symbol_Record;\n-      Driver_Name  : Name_Id := No_Name;\n-      Lib_Version  : String  := \"\";\n-      Auto_Init    : Boolean := False);\n-\n-   function Is_Archive_Ext (Ext : String) return Boolean;\n-\n-   ---------------------------\n-   -- Build_Dynamic_Library --\n-   ---------------------------\n-\n-   procedure Build_Dynamic_Library\n-     (Ofiles       : Argument_List;\n-      Options      : Argument_List;\n-      Interfaces   : Argument_List;\n-      Lib_Filename : String;\n-      Lib_Dir      : String;\n-      Symbol_Data  : Symbol_Record;\n-      Driver_Name  : Name_Id := No_Name;\n-      Lib_Version  : String  := \"\";\n-      Auto_Init    : Boolean := False)\n-   is\n-      pragma Unreferenced (Interfaces);\n-      pragma Unreferenced (Symbol_Data);\n-      pragma Unreferenced (Auto_Init);\n-\n-      Lib_File : constant String :=\n-                   \"lib\" & Fil.Append_To (Lib_Filename, DLL_Ext);\n-\n-      Lib_Path : constant String :=\n-                   Lib_Dir & Directory_Separator & Lib_File;\n-\n-      Version_Arg          : String_Access;\n-      Symbolic_Link_Needed : Boolean := False;\n-\n-   begin\n-      if Opt.Verbose_Mode then\n-         Write_Str (\"building relocatable shared library \");\n-         Write_Line (Lib_Path);\n-      end if;\n-\n-      if Lib_Version = \"\" then\n-         Utl.Gcc\n-           (Output_File => Lib_Path,\n-            Objects     => Ofiles,\n-            Options     => Options,\n-            Options_2   => No_Argument_List,\n-            Driver_Name => Driver_Name);\n-\n-      else\n-         declare\n-            Maj_Version : constant String :=\n-                            Major_Id_Name (Lib_File, Lib_Version);\n-         begin\n-            if Maj_Version'Length /= 0 then\n-               Version_Arg := new String'(\"-Wl,-h,\" & Maj_Version);\n-\n-            else\n-               Version_Arg := new String'(\"-Wl,-h,\" & Lib_Version);\n-            end if;\n-\n-            if Is_Absolute_Path (Lib_Version) then\n-               Utl.Gcc\n-                 (Output_File => Lib_Version,\n-                  Objects     => Ofiles,\n-                  Options     => Options & Version_Arg,\n-                  Options_2   => No_Argument_List,\n-                  Driver_Name => Driver_Name);\n-               Symbolic_Link_Needed := Lib_Version /= Lib_Path;\n-\n-            else\n-               Utl.Gcc\n-                 (Output_File => Lib_Dir & Directory_Separator & Lib_Version,\n-                  Objects     => Ofiles,\n-                  Options     => Options & Version_Arg,\n-                  Options_2   => No_Argument_List,\n-                  Driver_Name => Driver_Name);\n-               Symbolic_Link_Needed :=\n-                 Lib_Dir & Directory_Separator & Lib_Version /= Lib_Path;\n-            end if;\n-\n-            if Symbolic_Link_Needed then\n-               Create_Sym_Links\n-                 (Lib_Path, Lib_Version, Lib_Dir, Maj_Version);\n-            end if;\n-         end;\n-      end if;\n-   end Build_Dynamic_Library;\n-\n-   --------------------\n-   -- Is_Archive_Ext --\n-   --------------------\n-\n-   function Is_Archive_Ext (Ext : String) return Boolean is\n-   begin\n-      return Ext = \".a\" or else Ext = \".so\";\n-   end Is_Archive_Ext;\n-\n-begin\n-   Build_Dynamic_Library_Ptr := Build_Dynamic_Library'Access;\n-   Is_Archive_Ext_Ptr := Is_Archive_Ext'Access;\n-end MLib.Tgt.Specific;"}, {"sha": "29abd80147f6050e22c4fdab80fbfeb6fe709c14", "filename": "gcc/ada/mlib-tgt-specific-vxworks.adb", "status": "removed", "additions": 0, "deletions": 217, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fmlib-tgt-specific-vxworks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fmlib-tgt-specific-vxworks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt-specific-vxworks.adb?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793", "patch": "@@ -1,217 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                    M L I B . T G T . S P E C I F I C                     --\n---                            (VxWorks Version)                             --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 2003-2013, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the VxWorks version of the body\n-\n-with Sdefault;\n-\n-package body MLib.Tgt.Specific is\n-\n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   function Get_Target_Suffix return String;\n-   --  Returns the required suffix for some utilities\n-   --  (such as ar and ranlib) that depend on the real target.\n-\n-   --  Non default subprograms\n-\n-   function Archive_Builder return String;\n-\n-   function Archive_Indexer return String;\n-\n-   procedure Build_Dynamic_Library\n-     (Ofiles       : Argument_List;\n-      Options      : Argument_List;\n-      Interfaces   : Argument_List;\n-      Lib_Filename : String;\n-      Lib_Dir      : String;\n-      Symbol_Data  : Symbol_Record;\n-      Driver_Name  : Name_Id := No_Name;\n-      Lib_Version  : String  := \"\";\n-      Auto_Init    : Boolean := False);\n-\n-   function DLL_Ext return String;\n-\n-   function Dynamic_Option return String;\n-\n-   function Library_Major_Minor_Id_Supported return Boolean;\n-\n-   function PIC_Option return String;\n-\n-   function Standalone_Library_Auto_Init_Is_Supported return Boolean;\n-\n-   function Support_For_Libraries return Library_Support;\n-\n-   ---------------------\n-   -- Archive_Builder --\n-   ---------------------\n-\n-   function Archive_Builder return String is\n-   begin\n-      return \"ar\" & Get_Target_Suffix;\n-   end Archive_Builder;\n-\n-   ---------------------\n-   -- Archive_Indexer --\n-   ---------------------\n-\n-   function Archive_Indexer return String is\n-   begin\n-      return \"ranlib\" & Get_Target_Suffix;\n-   end Archive_Indexer;\n-\n-   ---------------------------\n-   -- Build_Dynamic_Library --\n-   ---------------------------\n-\n-   procedure Build_Dynamic_Library\n-     (Ofiles       : Argument_List;\n-      Options      : Argument_List;\n-      Interfaces   : Argument_List;\n-      Lib_Filename : String;\n-      Lib_Dir      : String;\n-      Symbol_Data  : Symbol_Record;\n-      Driver_Name  : Name_Id := No_Name;\n-      Lib_Version  : String  := \"\";\n-      Auto_Init    : Boolean := False)\n-   is\n-      pragma Unreferenced (Ofiles);\n-      pragma Unreferenced (Options);\n-      pragma Unreferenced (Interfaces);\n-      pragma Unreferenced (Lib_Filename);\n-      pragma Unreferenced (Lib_Dir);\n-      pragma Unreferenced (Symbol_Data);\n-      pragma Unreferenced (Driver_Name);\n-      pragma Unreferenced (Lib_Version);\n-      pragma Unreferenced (Auto_Init);\n-\n-   begin\n-      null;\n-   end Build_Dynamic_Library;\n-\n-   -------------\n-   -- DLL_Ext --\n-   -------------\n-\n-   function DLL_Ext return String is\n-   begin\n-      return \"\";\n-   end DLL_Ext;\n-\n-   --------------------\n-   -- Dynamic_Option --\n-   --------------------\n-\n-   function Dynamic_Option return String is\n-   begin\n-      return \"\";\n-   end Dynamic_Option;\n-\n-   -----------------------\n-   -- Get_Target_Suffix --\n-   -----------------------\n-\n-   function Get_Target_Suffix return String is\n-      Target_Name : constant String := Sdefault.Target_Name.all;\n-      Index       : Positive   := Target_Name'First;\n-\n-   begin\n-      while Index < Target_Name'Last\n-        and then Target_Name (Index + 1) /= '-'\n-      loop\n-         Index := Index + 1;\n-      end loop;\n-\n-      if Target_Name (Target_Name'First .. Index) = \"m68k\" then\n-         return \"68k\";\n-      elsif Target_Name (Target_Name'First .. Index) = \"mips\" then\n-         return \"mips\";\n-      elsif Target_Name (Target_Name'First .. Index) = \"powerpc\" then\n-         return \"ppc\";\n-      elsif Target_Name (Target_Name'First .. Index) = \"sparc\" then\n-         return \"sparc\";\n-      elsif Target_Name (Target_Name'First .. Index) = \"sparc64\" then\n-         return \"sparc64\";\n-      elsif Target_Name (Target_Name'First .. Index) = \"arm\" then\n-         return \"arm\";\n-      elsif Target_Name (Target_Name'First .. Index) = \"i586\" then\n-         return \"pentium\";\n-      else\n-         return \"\";\n-      end if;\n-   end Get_Target_Suffix;\n-\n-   --------------------------------------\n-   -- Library_Major_Minor_Id_Supported --\n-   --------------------------------------\n-\n-   function Library_Major_Minor_Id_Supported return Boolean is\n-   begin\n-      return False;\n-   end Library_Major_Minor_Id_Supported;\n-\n-   ----------------\n-   -- PIC_Option --\n-   ----------------\n-\n-   function PIC_Option return String is\n-   begin\n-      return \"\";\n-   end PIC_Option;\n-\n-   -----------------------------------------------\n-   -- Standalone_Library_Auto_Init_Is_Supported --\n-   -----------------------------------------------\n-\n-   function Standalone_Library_Auto_Init_Is_Supported return Boolean is\n-   begin\n-      return False;\n-   end Standalone_Library_Auto_Init_Is_Supported;\n-\n-   ---------------------------\n-   -- Support_For_Libraries --\n-   ---------------------------\n-\n-   function Support_For_Libraries return Library_Support is\n-   begin\n-      return Static_Only;\n-   end Support_For_Libraries;\n-\n-begin\n-   Archive_Builder_Ptr := Archive_Builder'Access;\n-   Archive_Indexer_Ptr := Archive_Indexer'Access;\n-   Build_Dynamic_Library_Ptr := Build_Dynamic_Library'Access;\n-   DLL_Ext_Ptr := DLL_Ext'Access;\n-   Dynamic_Option_Ptr := Dynamic_Option'Access;\n-   PIC_Option_Ptr := PIC_Option'Access;\n-   Library_Major_Minor_Id_Supported_Ptr :=\n-                                Library_Major_Minor_Id_Supported'Access;\n-   Standalone_Library_Auto_Init_Is_Supported_Ptr :=\n-     Standalone_Library_Auto_Init_Is_Supported'Access;\n-   Support_For_Libraries_Ptr := Support_For_Libraries'Access;\n-end MLib.Tgt.Specific;"}, {"sha": "ac64be4b837c56cc60e1f251654c36d202637ef8", "filename": "gcc/ada/mlib-tgt-specific-xi.adb", "status": "removed", "additions": 0, "deletions": 196, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fmlib-tgt-specific-xi.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fmlib-tgt-specific-xi.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt-specific-xi.adb?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793", "patch": "@@ -1,196 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                     M L I B . T G T. S P E C I F I C                     --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 2003-2011, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the bare board version of the body\n-\n-with Sdefault;\n-with Types; use Types;\n-\n-package body MLib.Tgt.Specific is\n-\n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   function Get_Target_Prefix return String;\n-   --  Returns the required prefix for some utilities\n-   --  (such as ar and ranlib) that depend on the real target.\n-\n-   --  Non default subprograms\n-\n-   function Archive_Builder return String;\n-\n-   function Archive_Indexer return String;\n-\n-   procedure Build_Dynamic_Library\n-     (Ofiles       : Argument_List;\n-      Options      : Argument_List;\n-      Interfaces   : Argument_List;\n-      Lib_Filename : String;\n-      Lib_Dir      : String;\n-      Symbol_Data  : Symbol_Record;\n-      Driver_Name  : Name_Id := No_Name;\n-      Lib_Version  : String  := \"\";\n-      Auto_Init    : Boolean := False);\n-\n-   function DLL_Ext return String;\n-\n-   function Dynamic_Option return String;\n-\n-   function Library_Major_Minor_Id_Supported return Boolean;\n-\n-   function PIC_Option return String;\n-\n-   function Standalone_Library_Auto_Init_Is_Supported return Boolean;\n-\n-   function Support_For_Libraries return Library_Support;\n-\n-   ---------------------\n-   -- Archive_Builder --\n-   ---------------------\n-\n-   function Archive_Builder return String is\n-   begin\n-      return Get_Target_Prefix & \"ar\";\n-   end Archive_Builder;\n-\n-   ---------------------\n-   -- Archive_Indexer --\n-   ---------------------\n-\n-   function Archive_Indexer return String is\n-   begin\n-      return Get_Target_Prefix & \"ranlib\";\n-   end Archive_Indexer;\n-\n-   ---------------------------\n-   -- Build_Dynamic_Library --\n-   ---------------------------\n-\n-   procedure Build_Dynamic_Library\n-     (Ofiles       : Argument_List;\n-      Options      : Argument_List;\n-      Interfaces   : Argument_List;\n-      Lib_Filename : String;\n-      Lib_Dir      : String;\n-      Symbol_Data  : Symbol_Record;\n-      Driver_Name  : Name_Id := No_Name;\n-      Lib_Version  : String  := \"\";\n-      Auto_Init    : Boolean := False)\n-   is\n-      pragma Unreferenced (Ofiles);\n-      pragma Unreferenced (Options);\n-      pragma Unreferenced (Interfaces);\n-      pragma Unreferenced (Lib_Filename);\n-      pragma Unreferenced (Lib_Dir);\n-      pragma Unreferenced (Symbol_Data);\n-      pragma Unreferenced (Driver_Name);\n-      pragma Unreferenced (Lib_Version);\n-      pragma Unreferenced (Auto_Init);\n-\n-   begin\n-      null;\n-   end Build_Dynamic_Library;\n-\n-   -------------\n-   -- DLL_Ext --\n-   -------------\n-\n-   function DLL_Ext return String is\n-   begin\n-      return \"\";\n-   end DLL_Ext;\n-\n-   --------------------\n-   -- Dynamic_Option --\n-   --------------------\n-\n-   function Dynamic_Option return String is\n-   begin\n-      return \"\";\n-   end Dynamic_Option;\n-\n-   -----------------------\n-   -- Get_Target_Prefix --\n-   -----------------------\n-\n-   function Get_Target_Prefix return String is\n-      Target_Name : constant String_Ptr := Sdefault.Target_Name;\n-\n-   begin\n-      --  Target_name is the program prefix without '-' but with a trailing '/'\n-\n-      return Target_Name (Target_Name'First .. Target_Name'Last - 1) & '-';\n-   end Get_Target_Prefix;\n-\n-   --------------------------------------\n-   -- Library_Major_Minor_Id_Supported --\n-   --------------------------------------\n-\n-   function Library_Major_Minor_Id_Supported return Boolean is\n-   begin\n-      return False;\n-   end Library_Major_Minor_Id_Supported;\n-\n-   ----------------\n-   -- PIC_Option --\n-   ----------------\n-\n-   function PIC_Option return String is\n-   begin\n-      return \"\";\n-   end PIC_Option;\n-\n-   -----------------------------------------------\n-   -- Standalone_Library_Auto_Init_Is_Supported --\n-   -----------------------------------------------\n-\n-   function Standalone_Library_Auto_Init_Is_Supported return Boolean is\n-   begin\n-      return False;\n-   end Standalone_Library_Auto_Init_Is_Supported;\n-\n-   ---------------------------\n-   -- Support_For_Libraries --\n-   ---------------------------\n-\n-   function Support_For_Libraries return Library_Support is\n-   begin\n-      return Static_Only;\n-   end Support_For_Libraries;\n-\n-begin\n-   Archive_Builder_Ptr := Archive_Builder'Access;\n-   Archive_Indexer_Ptr := Archive_Indexer'Access;\n-   Build_Dynamic_Library_Ptr := Build_Dynamic_Library'Access;\n-   DLL_Ext_Ptr := DLL_Ext'Access;\n-   Dynamic_Option_Ptr := Dynamic_Option'Access;\n-   Library_Major_Minor_Id_Supported_Ptr :=\n-                                Library_Major_Minor_Id_Supported'Access;\n-   PIC_Option_Ptr := PIC_Option'Access;\n-   Standalone_Library_Auto_Init_Is_Supported_Ptr :=\n-     Standalone_Library_Auto_Init_Is_Supported'Access;\n-   Support_For_Libraries_Ptr := Support_For_Libraries'Access;\n-end MLib.Tgt.Specific;"}, {"sha": "16988b3d6e7cb62acf6f829d97a1288584b9cfb0", "filename": "gcc/ada/mlib-tgt-specific.adb", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fmlib-tgt-specific.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fmlib-tgt-specific.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt-specific.adb?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793", "patch": "@@ -1,47 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                    M L I B . T G T . S P E C I F I C                     --\n---                          (Default empty version)                         --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---                     Copyright (C) 2007, AdaCore                          --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  Default version\n-\n-package body MLib.Tgt.Specific is\n-\n-   --  By default, libraries are not supported at all\n-\n-   function Support_For_Libraries return Library_Support;\n-   --  Function indicating if libraries are supported\n-\n-   ---------------------------\n-   -- Support_For_Libraries --\n-   ---------------------------\n-\n-   function Support_For_Libraries return Library_Support is\n-   begin\n-      return None;\n-   end Support_For_Libraries;\n-\n-begin\n-   Support_For_Libraries_Ptr := Support_For_Libraries'Access;\n-end MLib.Tgt.Specific;"}, {"sha": "7cc891bd7e7d6e2cf5b4109557a4a8aafa91fedc", "filename": "gcc/ada/mlib-tgt-specific.ads", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fmlib-tgt-specific.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fmlib-tgt-specific.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt-specific.ads?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793", "patch": "@@ -1,34 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                    M L I B . T G T . S P E C I F I C                     --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---                     Copyright (C) 2007, AdaCore                          --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This child package of package MLib.Tgt has no interface.\n---  For each platform, there is a specific body that defines the subprogram\n---  that are different from the default defined in the body of MLib.Tgt,\n---  and modify the corresponding access to subprogram value in the private\n---  part of MLib.Tgt.\n-\n-package MLib.Tgt.Specific is\n-   pragma Elaborate_Body;\n-end MLib.Tgt.Specific;"}, {"sha": "4d8597c1f73099af4f6f5b4cbf9e78ecb4b3f11c", "filename": "gcc/ada/mlib-tgt.adb", "status": "removed", "additions": 0, "deletions": 505, "changes": 505, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fmlib-tgt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fmlib-tgt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt.adb?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793", "patch": "@@ -1,505 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                             M L I B . T G T                              --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---                     Copyright (C) 2001-2010, AdaCore                     --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-with MLib.Fil;\n-with Prj.Com;\n-\n-with MLib.Tgt.Specific;\n-pragma Warnings (Off, MLib.Tgt.Specific);\n---  MLib.Tgt.Specific is with'ed only for elaboration purposes\n-\n-package body MLib.Tgt is\n-\n-   ---------------------\n-   -- Archive_Builder --\n-   ---------------------\n-\n-   function Archive_Builder return String is\n-   begin\n-      return Archive_Builder_Ptr.all;\n-   end Archive_Builder;\n-\n-   -----------------------------\n-   -- Archive_Builder_Default --\n-   -----------------------------\n-\n-   function Archive_Builder_Default return String is\n-   begin\n-      return \"ar\";\n-   end Archive_Builder_Default;\n-\n-   -----------------------------\n-   -- Archive_Builder_Options --\n-   -----------------------------\n-\n-   function Archive_Builder_Options return String_List_Access is\n-   begin\n-      return Archive_Builder_Options_Ptr.all;\n-   end Archive_Builder_Options;\n-\n-   -------------------------------------\n-   -- Archive_Builder_Options_Default --\n-   -------------------------------------\n-\n-   function Archive_Builder_Options_Default return String_List_Access is\n-   begin\n-      return new String_List'(1 => new String'(\"cr\"));\n-   end Archive_Builder_Options_Default;\n-\n-   ------------------------------------\n-   -- Archive_Builder_Append_Options --\n-   ------------------------------------\n-\n-   function Archive_Builder_Append_Options return String_List_Access is\n-   begin\n-      return Archive_Builder_Append_Options_Ptr.all;\n-   end Archive_Builder_Append_Options;\n-\n-   --------------------------------------------\n-   -- Archive_Builder_Append_Options_Default --\n-   --------------------------------------------\n-\n-   function Archive_Builder_Append_Options_Default return String_List_Access is\n-   begin\n-      return new String_List'(1 => new String'(\"q\"));\n-   end Archive_Builder_Append_Options_Default;\n-\n-   -----------------\n-   -- Archive_Ext --\n-   -----------------\n-\n-   function Archive_Ext return String is\n-   begin\n-      return Archive_Ext_Ptr.all;\n-   end Archive_Ext;\n-\n-   -------------------------\n-   -- Archive_Ext_Default --\n-   -------------------------\n-\n-   function Archive_Ext_Default return String is\n-   begin\n-      return \"a\";\n-   end Archive_Ext_Default;\n-\n-   ---------------------\n-   -- Archive_Indexer --\n-   ---------------------\n-\n-   function Archive_Indexer return String is\n-   begin\n-      return Archive_Indexer_Ptr.all;\n-   end Archive_Indexer;\n-\n-   -----------------------------\n-   -- Archive_Indexer_Default --\n-   -----------------------------\n-\n-   function Archive_Indexer_Default return String is\n-   begin\n-      return \"ranlib\";\n-   end Archive_Indexer_Default;\n-\n-   -----------------------------\n-   -- Archive_Indexer_Options --\n-   -----------------------------\n-\n-   function Archive_Indexer_Options return String_List_Access is\n-   begin\n-      return Archive_Indexer_Options_Ptr.all;\n-   end Archive_Indexer_Options;\n-\n-   -------------------------------------\n-   -- Archive_Indexer_Options_Default --\n-   -------------------------------------\n-\n-   function Archive_Indexer_Options_Default return String_List_Access is\n-   begin\n-      return new String_List (1 .. 0);\n-   end Archive_Indexer_Options_Default;\n-\n-   ---------------------------\n-   -- Build_Dynamic_Library --\n-   ---------------------------\n-\n-   procedure Build_Dynamic_Library\n-     (Ofiles       : Argument_List;\n-      Options      : Argument_List;\n-      Interfaces   : Argument_List;\n-      Lib_Filename : String;\n-      Lib_Dir      : String;\n-      Symbol_Data  : Symbol_Record;\n-      Driver_Name  : Name_Id := No_Name;\n-      Lib_Version  : String  := \"\";\n-      Auto_Init    : Boolean := False)\n-   is\n-   begin\n-      Build_Dynamic_Library_Ptr\n-        (Ofiles,\n-         Options,\n-         Interfaces,\n-         Lib_Filename,\n-         Lib_Dir,\n-         Symbol_Data,\n-         Driver_Name,\n-         Lib_Version,\n-         Auto_Init);\n-   end Build_Dynamic_Library;\n-\n-   ------------------------------\n-   -- Default_Symbol_File_Name --\n-   ------------------------------\n-\n-   function Default_Symbol_File_Name return String is\n-   begin\n-      return Default_Symbol_File_Name_Ptr.all;\n-   end Default_Symbol_File_Name;\n-\n-   --------------------------------------\n-   -- Default_Symbol_File_Name_Default --\n-   --------------------------------------\n-\n-   function Default_Symbol_File_Name_Default return String is\n-   begin\n-      return \"\";\n-   end Default_Symbol_File_Name_Default;\n-\n-   -------------\n-   -- DLL_Ext --\n-   -------------\n-\n-   function DLL_Ext return String is\n-   begin\n-      return DLL_Ext_Ptr.all;\n-   end DLL_Ext;\n-\n-   ---------------------\n-   -- DLL_Ext_Default --\n-   ---------------------\n-\n-   function DLL_Ext_Default return String is\n-   begin\n-      return \"so\";\n-   end DLL_Ext_Default;\n-\n-   ----------------\n-   -- DLL_Prefix --\n-   ----------------\n-\n-   function DLL_Prefix return String is\n-   begin\n-      return DLL_Prefix_Ptr.all;\n-   end DLL_Prefix;\n-\n-   ------------------------\n-   -- DLL_Prefix_Default --\n-   ------------------------\n-\n-   function DLL_Prefix_Default return String is\n-   begin\n-      return \"lib\";\n-   end DLL_Prefix_Default;\n-\n-   --------------------\n-   -- Dynamic_Option --\n-   --------------------\n-\n-   function Dynamic_Option return String is\n-   begin\n-      return Dynamic_Option_Ptr.all;\n-   end Dynamic_Option;\n-\n-   ----------------------------\n-   -- Dynamic_Option_Default --\n-   ----------------------------\n-\n-   function Dynamic_Option_Default return String is\n-   begin\n-      return \"-shared\";\n-   end Dynamic_Option_Default;\n-\n-   -------------------\n-   -- Is_Object_Ext --\n-   -------------------\n-\n-   function Is_Object_Ext (Ext : String) return Boolean is\n-   begin\n-      return Is_Object_Ext_Ptr (Ext);\n-   end Is_Object_Ext;\n-\n-   ---------------------------\n-   -- Is_Object_Ext_Default --\n-   ---------------------------\n-\n-   function Is_Object_Ext_Default (Ext : String) return Boolean is\n-   begin\n-      return Ext = \".o\";\n-   end Is_Object_Ext_Default;\n-\n-   --------------\n-   -- Is_C_Ext --\n-   --------------\n-\n-   function Is_C_Ext (Ext : String) return Boolean is\n-   begin\n-      return Is_C_Ext_Ptr (Ext);\n-   end Is_C_Ext;\n-\n-   ----------------------\n-   -- Is_C_Ext_Default --\n-   ----------------------\n-\n-   function Is_C_Ext_Default (Ext : String) return Boolean is\n-   begin\n-      return Ext = \".c\";\n-   end Is_C_Ext_Default;\n-\n-   --------------------\n-   -- Is_Archive_Ext --\n-   --------------------\n-\n-   function Is_Archive_Ext (Ext : String) return Boolean is\n-   begin\n-      return Is_Archive_Ext_Ptr (Ext);\n-   end Is_Archive_Ext;\n-\n-   ----------------------------\n-   -- Is_Archive_Ext_Default --\n-   ----------------------------\n-\n-   function Is_Archive_Ext_Default (Ext : String) return Boolean is\n-   begin\n-      return Ext = \".a\";\n-   end Is_Archive_Ext_Default;\n-\n-   -------------\n-   -- Libgnat --\n-   -------------\n-\n-   function Libgnat return String is\n-   begin\n-      return Libgnat_Ptr.all;\n-   end Libgnat;\n-\n-   ---------------------\n-   -- Libgnat_Default --\n-   ---------------------\n-\n-   function Libgnat_Default return String is\n-   begin\n-      return \"libgnat.a\";\n-   end Libgnat_Default;\n-\n-   ------------------------\n-   -- Library_Exists_For --\n-   ------------------------\n-\n-   function Library_Exists_For\n-     (Project : Project_Id;\n-      In_Tree : Project_Tree_Ref) return Boolean\n-   is\n-   begin\n-      return Library_Exists_For_Ptr (Project, In_Tree);\n-   end Library_Exists_For;\n-\n-   --------------------------------\n-   -- Library_Exists_For_Default --\n-   --------------------------------\n-\n-   function Library_Exists_For_Default\n-     (Project : Project_Id;\n-      In_Tree : Project_Tree_Ref) return Boolean\n-   is\n-      pragma Unreferenced (In_Tree);\n-\n-   begin\n-      if not Project.Library then\n-         Prj.Com.Fail (\"INTERNAL ERROR: Library_Exists_For called \" &\n-                       \"for non library project\");\n-         return False;\n-\n-      else\n-         declare\n-            Lib_Dir  : constant String :=\n-                         Get_Name_String (Project.Library_Dir.Display_Name);\n-            Lib_Name : constant String :=\n-                         Get_Name_String (Project.Library_Name);\n-\n-         begin\n-            if Project.Library_Kind = Static then\n-               return Is_Regular_File\n-                 (Lib_Dir & Directory_Separator & \"lib\" &\n-                  Fil.Append_To (Lib_Name, Archive_Ext));\n-\n-            else\n-               return Is_Regular_File\n-                 (Lib_Dir & Directory_Separator & DLL_Prefix &\n-                  Fil.Append_To (Lib_Name, DLL_Ext));\n-            end if;\n-         end;\n-      end if;\n-   end Library_Exists_For_Default;\n-\n-   ---------------------------\n-   -- Library_File_Name_For --\n-   ---------------------------\n-\n-   function Library_File_Name_For\n-     (Project : Project_Id;\n-      In_Tree : Project_Tree_Ref) return File_Name_Type\n-   is\n-   begin\n-      return Library_File_Name_For_Ptr (Project, In_Tree);\n-   end Library_File_Name_For;\n-\n-   -----------------------------------\n-   -- Library_File_Name_For_Default --\n-   -----------------------------------\n-\n-   function Library_File_Name_For_Default\n-     (Project : Project_Id;\n-      In_Tree : Project_Tree_Ref) return File_Name_Type\n-   is\n-      pragma Unreferenced (In_Tree);\n-   begin\n-      if not Project.Library then\n-         Prj.Com.Fail (\"INTERNAL ERROR: Library_File_Name_For called \" &\n-                       \"for non library project\");\n-         return No_File;\n-\n-      else\n-         declare\n-            Lib_Name : constant String :=\n-                         Get_Name_String (Project.Library_Name);\n-\n-         begin\n-            if Project.Library_Kind =\n-                 Static\n-            then\n-               Name_Len := 3;\n-               Name_Buffer (1 .. Name_Len) := \"lib\";\n-               Add_Str_To_Name_Buffer (Fil.Append_To (Lib_Name, Archive_Ext));\n-            else\n-               Name_Len := 0;\n-               Add_Str_To_Name_Buffer (DLL_Prefix);\n-               Add_Str_To_Name_Buffer (Fil.Append_To (Lib_Name, DLL_Ext));\n-            end if;\n-\n-            return Name_Find;\n-         end;\n-      end if;\n-   end Library_File_Name_For_Default;\n-\n-   --------------------------------------\n-   -- Library_Major_Minor_Id_Supported --\n-   --------------------------------------\n-\n-   function Library_Major_Minor_Id_Supported return Boolean is\n-   begin\n-      return Library_Major_Minor_Id_Supported_Ptr.all;\n-   end Library_Major_Minor_Id_Supported;\n-\n-   ----------------------------------------------\n-   -- Library_Major_Minor_Id_Supported_Default --\n-   ----------------------------------------------\n-\n-   function Library_Major_Minor_Id_Supported_Default return Boolean is\n-   begin\n-      return True;\n-   end Library_Major_Minor_Id_Supported_Default;\n-\n-   ----------------\n-   -- Object_Ext --\n-   ----------------\n-\n-   function Object_Ext return String is\n-   begin\n-      return Object_Ext_Ptr.all;\n-   end Object_Ext;\n-\n-   ------------------------\n-   -- Object_Ext_Default --\n-   ------------------------\n-\n-   function Object_Ext_Default return String is\n-   begin\n-      return \"o\";\n-   end Object_Ext_Default;\n-\n-   ----------------\n-   -- PIC_Option --\n-   ----------------\n-\n-   function PIC_Option return String is\n-   begin\n-      return PIC_Option_Ptr.all;\n-   end PIC_Option;\n-\n-   ------------------------\n-   -- PIC_Option_Default --\n-   ------------------------\n-\n-   function PIC_Option_Default return String is\n-   begin\n-      return \"-fPIC\";\n-   end PIC_Option_Default;\n-\n-   -----------------------------------------------\n-   -- Standalone_Library_Auto_Init_Is_Supported --\n-   -----------------------------------------------\n-\n-   function Standalone_Library_Auto_Init_Is_Supported return Boolean is\n-   begin\n-      return Standalone_Library_Auto_Init_Is_Supported_Ptr.all;\n-   end Standalone_Library_Auto_Init_Is_Supported;\n-\n-   -------------------------------------------------------\n-   -- Standalone_Library_Auto_Init_Is_Supported_Default --\n-   -------------------------------------------------------\n-\n-   function Standalone_Library_Auto_Init_Is_Supported_Default return Boolean is\n-   begin\n-      return True;\n-   end Standalone_Library_Auto_Init_Is_Supported_Default;\n-\n-   ---------------------------\n-   -- Support_For_Libraries --\n-   ---------------------------\n-\n-   function Support_For_Libraries return Library_Support is\n-   begin\n-      return Support_For_Libraries_Ptr.all;\n-   end Support_For_Libraries;\n-\n-   -----------------------------------\n-   -- Support_For_Libraries_Default --\n-   -----------------------------------\n-\n-   function Support_For_Libraries_Default return Library_Support is\n-   begin\n-      return Full;\n-   end Support_For_Libraries_Default;\n-\n-end MLib.Tgt;"}, {"sha": "0260159bfebf90549a1f8813946db82ce50cdb73", "filename": "gcc/ada/mlib-tgt.ads", "status": "removed", "additions": 0, "deletions": 270, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fmlib-tgt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fmlib-tgt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt.ads?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793", "patch": "@@ -1,270 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                             M L I B . T G T                              --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---                     Copyright (C) 2001-2014, AdaCore                     --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This package provides a set of target dependent routines to build static,\n---  dynamic and shared libraries. There are several packages providing\n---  the actual routines. This package calls them indirectly by means of\n---  access-to-subprogram values. Each target-dependent package initializes\n---  these values in its elaboration block.\n-\n-with Prj; use Prj;\n-\n-package MLib.Tgt is\n-\n-   function Support_For_Libraries return Library_Support;\n-   --  Indicates how building libraries by gnatmake is supported by the GNAT\n-   --  implementation for the platform.\n-\n-   function Standalone_Library_Auto_Init_Is_Supported return Boolean;\n-   --  Indicates if when building a dynamic Standalone Library,\n-   --  automatic initialization is supported. If it is, then it is the default,\n-   --  unless attribute Library_Auto_Init has the value \"false\".\n-\n-   function Archive_Builder return String;\n-   --  Returns the name of the archive builder program, usually \"ar\"\n-\n-   function Archive_Builder_Options return String_List_Access;\n-   --  A list of options to invoke the Archive_Builder, usually \"cr\" for \"ar\"\n-\n-   function Archive_Builder_Append_Options return String_List_Access;\n-   --  A list of options to use with the archive builder to append object\n-   --  files (\"q\", for example).\n-\n-   function Archive_Indexer return String;\n-   --  Returns the name of the program, if any, that generates an index to the\n-   --  contents of an archive, usually \"ranlib\". If there is no archive indexer\n-   --  to be used, returns an empty string.\n-\n-   function Archive_Indexer_Options return String_List_Access;\n-   --  A list of options to invoke the Archive_Indexer, usually empty\n-\n-   function Dynamic_Option return String;\n-   --  gcc option to create a dynamic library.\n-   --  For Unix, returns \"-shared\", for Windows returns \"-mdll\".\n-\n-   function Libgnat return String;\n-   --  System dependent static GNAT library\n-\n-   function Archive_Ext return  String;\n-   --  System dependent static library extension, without leading dot.\n-   --  For Unix and Windows, return \"a\".\n-\n-   function Object_Ext return String;\n-   --  System dependent object extension, without leading dot.\n-   --  On Unix, returns \"o\".\n-\n-   function DLL_Prefix return String;\n-   --  System dependent dynamic library prefix.\n-   --  On Windows, returns \"\". On other platforms, returns \"lib\".\n-\n-   function DLL_Ext return String;\n-   --  System dependent dynamic library extension, without leading dot.\n-   --  On Windows, returns \"dll\". On Unix, usually returns \"so\", but not\n-   --  always, e.g. on HP-UX the extension for shared libraries is \"sl\".\n-\n-   function PIC_Option return String;\n-   --  Position independent code option\n-\n-   function Is_Object_Ext (Ext : String) return Boolean;\n-   --  Returns True iff Ext is an object file extension\n-\n-   function Is_C_Ext (Ext : String) return Boolean;\n-   --  Returns True iff Ext is a C file extension\n-\n-   function Is_Archive_Ext (Ext : String) return Boolean;\n-   --  Returns True iff Ext is an extension for a library\n-\n-   function Default_Symbol_File_Name return String;\n-   --  Returns the name of the symbol file when Library_Symbol_File is not\n-   --  specified. Return the empty string when symbol files are not supported.\n-\n-   procedure Build_Dynamic_Library\n-     (Ofiles       : Argument_List;\n-      Options      : Argument_List;\n-      Interfaces   : Argument_List;\n-      Lib_Filename : String;\n-      Lib_Dir      : String;\n-      Symbol_Data  : Symbol_Record;\n-      Driver_Name  : Name_Id := No_Name;\n-      Lib_Version  : String  := \"\";\n-      Auto_Init    : Boolean := False);\n-   --  Build a dynamic/relocatable library\n-   --\n-   --  Ofiles is the list of all object files in the library\n-   --\n-   --  Options is a list of options to be passed to the tool\n-   --  (gcc or other) that effectively builds the dynamic library.\n-   --\n-   --  Interfaces is the list of ALI files for the interfaces of a SAL.\n-   --  It is empty if the library is not a SAL.\n-   --\n-   --  Lib_Filename is the name of the library, without any prefix or\n-   --  extension. For example, on Unix, if Lib_Filename is \"toto\", the\n-   --  name of the library file will be \"libtoto.so\".\n-   --\n-   --  Lib_Dir is the directory path where the library will be located\n-   --\n-   --  For OSes that support symbolic links, Lib_Version, if non null,\n-   --  is the actual file name of the library. For example on Unix, if\n-   --  Lib_Filename is \"toto\" and Lib_Version is \"libtoto.so.2.1\",\n-   --  \"libtoto.so\" will be a symbolic link to \"libtoto.so.2.1\" which\n-   --  will be the actual library file.\n-   --\n-   --  Symbol_Data is used for some platforms, to generate the symbols to be\n-   --  exported by the library (not certain if it is currently in use or not).\n-   --\n-   --  Note: Depending on the OS, some of the parameters may not be taken into\n-   --  account. For example, on Linux, Interfaces, Symbol_Data and Auto_Init\n-   --  are ignored.\n-\n-   function Library_Exists_For\n-     (Project : Project_Id;\n-      In_Tree : Project_Tree_Ref) return Boolean;\n-   --  Return True if the library file for a library project already exists.\n-   --  This function can only be called for library projects.\n-\n-   function Library_File_Name_For\n-     (Project : Project_Id;\n-      In_Tree : Project_Tree_Ref) return File_Name_Type;\n-   --  Returns the file name of the library file of a library project.\n-   --  This function can only be called for library projects.\n-\n-   function Library_Major_Minor_Id_Supported return Boolean;\n-   --  Indicates if major and minor ids are supported for libraries.\n-   --  If they are supported, then a Library_Version such as libtoto.so.1.2\n-   --  will have a major id of 1 and a minor id of 2. Then libtoto.so,\n-   --  libtoto.so.1 and libtoto.so.1.2 will be created, all three designating\n-   --  the same file.\n-\n-private\n-   No_Argument_List : constant Argument_List := (1 .. 0 => null);\n-\n-   --  Access to subprogram types for indirection\n-\n-   type String_Function is access function return String;\n-   type Is_Ext_Function is access function (Ext : String) return Boolean;\n-   type String_List_Access_Function is access function\n-     return String_List_Access;\n-\n-   type Build_Dynamic_Library_Function is access procedure\n-     (Ofiles       : Argument_List;\n-      Options      : Argument_List;\n-      Interfaces   : Argument_List;\n-      Lib_Filename : String;\n-      Lib_Dir      : String;\n-      Symbol_Data  : Symbol_Record;\n-      Driver_Name  : Name_Id := No_Name;\n-      Lib_Version  : String  := \"\";\n-      Auto_Init    : Boolean := False);\n-\n-   type Library_Exists_For_Function is access function\n-     (Project : Project_Id;\n-      In_Tree : Project_Tree_Ref) return Boolean;\n-\n-   type Library_File_Name_For_Function is access function\n-     (Project : Project_Id;\n-      In_Tree : Project_Tree_Ref) return File_Name_Type;\n-\n-   type Boolean_Function is access function return Boolean;\n-   type Library_Support_Function is access function return Library_Support;\n-\n-   function Archive_Builder_Default return String;\n-   Archive_Builder_Ptr : String_Function := Archive_Builder_Default'Access;\n-\n-   function Archive_Builder_Options_Default return String_List_Access;\n-   Archive_Builder_Options_Ptr : String_List_Access_Function :=\n-                                   Archive_Builder_Options_Default'Access;\n-\n-   function Archive_Builder_Append_Options_Default return String_List_Access;\n-   Archive_Builder_Append_Options_Ptr : String_List_Access_Function :=\n-                                Archive_Builder_Append_Options_Default'Access;\n-\n-   function Archive_Ext_Default return String;\n-   Archive_Ext_Ptr : String_Function := Archive_Ext_Default'Access;\n-\n-   function Archive_Indexer_Default return String;\n-   Archive_Indexer_Ptr : String_Function := Archive_Indexer_Default'Access;\n-\n-   function Archive_Indexer_Options_Default return String_List_Access;\n-   Archive_Indexer_Options_Ptr : String_List_Access_Function :=\n-                                   Archive_Indexer_Options_Default'Access;\n-\n-   function Default_Symbol_File_Name_Default return String;\n-   Default_Symbol_File_Name_Ptr : String_Function :=\n-                                    Default_Symbol_File_Name_Default'Access;\n-\n-   Build_Dynamic_Library_Ptr : Build_Dynamic_Library_Function;\n-\n-   function DLL_Ext_Default return String;\n-   DLL_Ext_Ptr : String_Function := DLL_Ext_Default'Access;\n-\n-   function DLL_Prefix_Default return String;\n-   DLL_Prefix_Ptr : String_Function := DLL_Prefix_Default'Access;\n-\n-   function Dynamic_Option_Default return String;\n-   Dynamic_Option_Ptr : String_Function := Dynamic_Option_Default'Access;\n-\n-   function Is_Object_Ext_Default (Ext : String) return Boolean;\n-   Is_Object_Ext_Ptr : Is_Ext_Function := Is_Object_Ext_Default'Access;\n-\n-   function Is_C_Ext_Default (Ext : String) return Boolean;\n-   Is_C_Ext_Ptr : Is_Ext_Function := Is_C_Ext_Default'Access;\n-\n-   function Is_Archive_Ext_Default (Ext : String) return Boolean;\n-   Is_Archive_Ext_Ptr : Is_Ext_Function := Is_Archive_Ext_Default'Access;\n-\n-   function Libgnat_Default return String;\n-   Libgnat_Ptr : String_Function := Libgnat_Default'Access;\n-\n-   function Library_Exists_For_Default\n-     (Project : Project_Id;\n-      In_Tree : Project_Tree_Ref) return Boolean;\n-   Library_Exists_For_Ptr : Library_Exists_For_Function :=\n-                              Library_Exists_For_Default'Access;\n-\n-   function Library_File_Name_For_Default\n-     (Project : Project_Id;\n-      In_Tree : Project_Tree_Ref) return File_Name_Type;\n-   Library_File_Name_For_Ptr : Library_File_Name_For_Function :=\n-                                 Library_File_Name_For_Default'Access;\n-\n-   function Object_Ext_Default return String;\n-   Object_Ext_Ptr : String_Function := Object_Ext_Default'Access;\n-\n-   function PIC_Option_Default return String;\n-   PIC_Option_Ptr : String_Function := PIC_Option_Default'Access;\n-\n-   function Standalone_Library_Auto_Init_Is_Supported_Default return Boolean;\n-   Standalone_Library_Auto_Init_Is_Supported_Ptr : Boolean_Function :=\n-            Standalone_Library_Auto_Init_Is_Supported_Default'Access;\n-\n-   function Support_For_Libraries_Default return Library_Support;\n-   Support_For_Libraries_Ptr : Library_Support_Function :=\n-                                 Support_For_Libraries_Default'Access;\n-\n-   function Library_Major_Minor_Id_Supported_Default return Boolean;\n-   Library_Major_Minor_Id_Supported_Ptr : Boolean_Function :=\n-             Library_Major_Minor_Id_Supported_Default'Access;\n-end MLib.Tgt;"}, {"sha": "91890a15dc4c6db7fccf5a2627fe410a9da9b011", "filename": "gcc/ada/mlib-utl.adb", "status": "removed", "additions": 0, "deletions": 644, "changes": 644, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fmlib-utl.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fmlib-utl.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-utl.adb?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793", "patch": "@@ -1,644 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                             M L I B . U T L                              --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---                     Copyright (C) 2002-2014, AdaCore                     --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-with MLib.Fil; use MLib.Fil;\n-with MLib.Tgt; use MLib.Tgt;\n-with Opt;\n-with Osint;\n-with Output;   use Output;\n-\n-with Interfaces.C.Strings; use Interfaces.C.Strings;\n-\n-package body MLib.Utl is\n-\n-   Adalib_Path : String_Access := null;\n-   --  Path of the GNAT adalib directory, specified in procedure\n-   --  Specify_Adalib_Dir. Used in function Lib_Directory.\n-\n-   Gcc_Name : String_Access;\n-   --  Default value of the \"gcc\" executable used in procedure Gcc\n-\n-   Gcc_Exec : String_Access;\n-   --  The full path name of the \"gcc\" executable\n-\n-   Ar_Name : String_Access;\n-   --  The name of the archive builder for the platform, set when procedure Ar\n-   --  is called for the first time.\n-\n-   Ar_Exec : String_Access;\n-   --  The full path name of the archive builder\n-\n-   Ar_Options : String_List_Access;\n-   --  The minimum options used when invoking the archive builder\n-\n-   Ar_Append_Options : String_List_Access;\n-   --  The options to be used when invoking the archive builder to add chunks\n-   --  of object files, when building the archive in chunks.\n-\n-   Opt_Length : Natural := 0;\n-   --  The max number of options for the Archive_Builder\n-\n-   Initial_Size : Natural := 0;\n-   --  The minimum number of bytes for the invocation of the Archive Builder\n-   --  (without name of the archive or object files).\n-\n-   Ranlib_Name : String_Access;\n-   --  The name of the archive indexer for the platform, if there is one\n-\n-   Ranlib_Exec : String_Access := null;\n-   --  The full path name of the archive indexer\n-\n-   Ranlib_Options : String_List_Access := null;\n-   --  The options to be used when invoking the archive indexer, if any\n-\n-   --------\n-   -- Ar --\n-   --------\n-\n-   procedure Ar (Output_File : String; Objects : Argument_List) is\n-      Full_Output_File : constant String :=\n-                             Ext_To (Output_File, Archive_Ext);\n-\n-      Arguments   : Argument_List_Access;\n-      Last_Arg    : Natural := 0;\n-      Success     : Boolean;\n-      Line_Length : Natural := 0;\n-\n-      Maximum_Size : Integer;\n-      pragma Import (C, Maximum_Size, \"__gnat_link_max\");\n-      --  Maximum number of bytes to put in an invocation of the\n-      --  Archive_Builder.\n-\n-      Size : Integer;\n-      --  The number of bytes for the invocation of the archive builder\n-\n-      Current_Object : Natural;\n-\n-      procedure Display;\n-      --  Display an invocation of the Archive Builder\n-\n-      -------------\n-      -- Display --\n-      -------------\n-\n-      procedure Display is\n-      begin\n-         if not Opt.Quiet_Output then\n-            Write_Str (Ar_Name.all);\n-            Line_Length := Ar_Name'Length;\n-\n-            for J in 1 .. Last_Arg loop\n-\n-               --  Make sure the Output buffer does not overflow\n-\n-               if Line_Length + 1 + Arguments (J)'Length > Buffer_Max then\n-                  Write_Eol;\n-                  Line_Length := 0;\n-               end if;\n-\n-               Write_Char (' ');\n-\n-               --  Only output the first object files when not in verbose mode\n-\n-               if (not Opt.Verbose_Mode) and then J = Opt_Length + 3 then\n-                  Write_Str (\"...\");\n-                  exit;\n-               end if;\n-\n-               Write_Str (Arguments (J).all);\n-               Line_Length := Line_Length + 1 + Arguments (J)'Length;\n-            end loop;\n-\n-            Write_Eol;\n-         end if;\n-\n-      end Display;\n-\n-   begin\n-      if Ar_Exec = null then\n-         Ar_Name := Osint.Program_Name (Archive_Builder, \"gnatmake\");\n-         Ar_Exec := Locate_Exec_On_Path (Ar_Name.all);\n-\n-         if Ar_Exec = null then\n-            Free (Ar_Name);\n-            Ar_Name := new String'(Archive_Builder);\n-            Ar_Exec := Locate_Exec_On_Path (Ar_Name.all);\n-         end if;\n-\n-         if Ar_Exec = null then\n-            Fail (Ar_Name.all & \" not found in path\");\n-\n-         elsif Opt.Verbose_Mode then\n-            Write_Str  (\"found \");\n-            Write_Line (Ar_Exec.all);\n-         end if;\n-\n-         Ar_Options := Archive_Builder_Options;\n-\n-         Initial_Size := 0;\n-         for J in Ar_Options'Range loop\n-            Initial_Size := Initial_Size + Ar_Options (J)'Length + 1;\n-         end loop;\n-\n-         Ar_Append_Options := Archive_Builder_Append_Options;\n-\n-         Opt_Length := Ar_Options'Length;\n-\n-         if Ar_Append_Options /= null then\n-            Opt_Length := Natural'Max (Ar_Append_Options'Length, Opt_Length);\n-\n-            Size := 0;\n-            for J in Ar_Append_Options'Range loop\n-               Size := Size + Ar_Append_Options (J)'Length + 1;\n-            end loop;\n-\n-            Initial_Size := Integer'Max (Initial_Size, Size);\n-         end if;\n-\n-         --  ranlib\n-\n-         Ranlib_Name := Osint.Program_Name (Archive_Indexer, \"gnatmake\");\n-\n-         if Ranlib_Name'Length > 0 then\n-            Ranlib_Exec := Locate_Exec_On_Path (Ranlib_Name.all);\n-\n-            if Ranlib_Exec = null then\n-               Free (Ranlib_Name);\n-               Ranlib_Name := new String'(Archive_Indexer);\n-               Ranlib_Exec := Locate_Exec_On_Path (Ranlib_Name.all);\n-            end if;\n-\n-            if Ranlib_Exec /= null and then Opt.Verbose_Mode then\n-               Write_Str (\"found \");\n-               Write_Line (Ranlib_Exec.all);\n-            end if;\n-         end if;\n-\n-         Ranlib_Options := Archive_Indexer_Options;\n-      end if;\n-\n-      Arguments :=\n-        new String_List (1 .. 1 + Opt_Length + Objects'Length);\n-      Arguments (1 .. Ar_Options'Length) := Ar_Options.all; --  \"ar cr ...\"\n-      Arguments (Ar_Options'Length + 1) := new String'(Full_Output_File);\n-\n-      Delete_File (Full_Output_File);\n-\n-      Size := Initial_Size + Full_Output_File'Length + 1;\n-\n-      --  Check the full size of a call of the archive builder with all the\n-      --  object files.\n-\n-      for J in Objects'Range loop\n-         Size := Size + Objects (J)'Length + 1;\n-      end loop;\n-\n-      --  If the size is not too large or if it is not possible to build the\n-      --  archive in chunks, build the archive in a single invocation.\n-\n-      if Size <= Maximum_Size or else Ar_Append_Options = null then\n-         Last_Arg := Ar_Options'Length + 1 + Objects'Length;\n-         Arguments (Ar_Options'Length + 2 .. Last_Arg) := Objects;\n-\n-         Display;\n-\n-         Spawn (Ar_Exec.all, Arguments (1 .. Last_Arg), Success);\n-\n-      else\n-         --  Build the archive in several invocation, making sure to not\n-         --  go over the maximum size for each invocation.\n-\n-         Last_Arg := Ar_Options'Length + 1;\n-         Current_Object := Objects'First;\n-         Size := Initial_Size + Full_Output_File'Length + 1;\n-\n-         --  First invocation\n-\n-         while Current_Object <= Objects'Last loop\n-            Size := Size + Objects (Current_Object)'Length + 1;\n-            exit when Size > Maximum_Size;\n-            Last_Arg := Last_Arg + 1;\n-            Arguments (Last_Arg) := Objects (Current_Object);\n-            Current_Object := Current_Object + 1;\n-         end loop;\n-\n-         Display;\n-\n-         Spawn (Ar_Exec.all, Arguments (1 .. Last_Arg), Success);\n-\n-         Arguments (1 .. Ar_Append_Options'Length) := Ar_Append_Options.all;\n-         Arguments\n-           (Ar_Append_Options'Length + 1) := new String'(Full_Output_File);\n-\n-         --  Appending invocation(s)\n-\n-         Big_Loop : while Success and then Current_Object <= Objects'Last loop\n-            Last_Arg := Ar_Append_Options'Length + 1;\n-            Size := Initial_Size + Full_Output_File'Length + 1;\n-\n-            Inner_Loop : while Current_Object <= Objects'Last loop\n-               Size := Size + Objects (Current_Object)'Length + 1;\n-               exit Inner_Loop when Size > Maximum_Size;\n-               Last_Arg := Last_Arg + 1;\n-               Arguments (Last_Arg) := Objects (Current_Object);\n-               Current_Object := Current_Object + 1;\n-            end loop Inner_Loop;\n-\n-            Display;\n-\n-            Spawn (Ar_Exec.all, Arguments (1 .. Last_Arg), Success);\n-         end loop Big_Loop;\n-      end if;\n-\n-      if not Success then\n-         Fail (Ar_Name.all & \" execution error.\");\n-      end if;\n-\n-      --  If we have found ranlib, run it over the library\n-\n-      if Ranlib_Exec /= null then\n-         if not Opt.Quiet_Output then\n-            Write_Str  (Ranlib_Name.all);\n-            Write_Char (' ');\n-\n-            for J in Ranlib_Options'Range loop\n-               Write_Str  (Ranlib_Options (J).all);\n-               Write_Char (' ');\n-            end loop;\n-\n-            Write_Line (Arguments (Ar_Options'Length + 1).all);\n-         end if;\n-\n-         Spawn\n-           (Ranlib_Exec.all,\n-            Ranlib_Options.all & (Arguments (Ar_Options'Length + 1)),\n-            Success);\n-\n-         if not Success then\n-            Fail (Ranlib_Name.all & \" execution error.\");\n-         end if;\n-      end if;\n-   end Ar;\n-\n-   -----------------\n-   -- Delete_File --\n-   -----------------\n-\n-   procedure Delete_File (Filename : String) is\n-      File    : constant String := Filename & ASCII.NUL;\n-      Success : Boolean;\n-\n-   begin\n-      Delete_File (File'Address, Success);\n-\n-      if Opt.Verbose_Mode then\n-         if Success then\n-            Write_Str (\"deleted \");\n-\n-         else\n-            Write_Str (\"could not delete \");\n-         end if;\n-\n-         Write_Line (Filename);\n-      end if;\n-   end Delete_File;\n-\n-   ---------\n-   -- Gcc --\n-   ---------\n-\n-   procedure Gcc\n-     (Output_File : String;\n-      Objects     : Argument_List;\n-      Options     : Argument_List;\n-      Options_2   : Argument_List;\n-      Driver_Name : Name_Id := No_Name)\n-   is\n-      Link_Bytes : Integer := 0;\n-      --  Projected number of bytes for the linker command line\n-\n-      Link_Max : Integer;\n-      pragma Import (C, Link_Max, \"__gnat_link_max\");\n-      --  Maximum number of bytes on the command line supported by the OS\n-      --  linker. Passed this limit the response file mechanism must be used\n-      --  if supported.\n-\n-      Object_List_File_Supported : Boolean;\n-      for Object_List_File_Supported'Size use Character'Size;\n-      pragma Import\n-        (C, Object_List_File_Supported, \"__gnat_objlist_file_supported\");\n-      --  Predicate indicating whether the linker has an option whereby the\n-      --  names of object files can be passed to the linker in a file.\n-\n-      Object_File_Option_Ptr : Interfaces.C.Strings.chars_ptr;\n-      pragma Import (C, Object_File_Option_Ptr, \"__gnat_object_file_option\");\n-      --  Pointer to a string representing the linker option which specifies\n-      --  the response file.\n-\n-      Object_File_Option : constant String := Value (Object_File_Option_Ptr);\n-      --  The linker option which specifies the response file as a string\n-\n-      Using_GNU_response_file : constant Boolean :=\n-                                  Object_File_Option'Length > 0\n-                                    and then\n-                                      Object_File_Option\n-                                        (Object_File_Option'Last) = '@';\n-      --  Whether a GNU response file is used\n-\n-      Tname    : String_Access;\n-      Tname_FD : File_Descriptor := Invalid_FD;\n-      --  Temporary file used by linker to pass list of object files on\n-      --  certain systems with limitations on size of arguments.\n-\n-      Closing_Status : Boolean;\n-      --  For call to Close\n-\n-      Arguments :\n-        Argument_List\n-          (1 .. 7 + Objects'Length + Options'Length + Options_2'Length);\n-\n-      A       : Natural := 0;\n-      Success : Boolean;\n-\n-      Out_Opt : constant String_Access := new String'(\"-o\");\n-      Out_V   : constant String_Access := new String'(Output_File);\n-      Lib_Dir : constant String_Access := new String'(\"-L\" & Lib_Directory);\n-      Lib_Opt : constant String_Access := new String'(Dynamic_Option);\n-\n-      Driver : String_Access;\n-\n-      type Object_Position is (First, Second, Last);\n-\n-      Position : Object_Position;\n-\n-      procedure Write_RF (S : String);\n-      --  Write a string to the response file and check if it was successful.\n-      --  Fail the program if it was not successful (disk full).\n-\n-      --------------\n-      -- Write_RF --\n-      --------------\n-\n-      procedure Write_RF (S : String) is\n-         Success    : Boolean            := True;\n-         Back_Slash : constant Character := '\\';\n-\n-      begin\n-         --  If a GNU response file is used, space and backslash need to be\n-         --  escaped because they are interpreted as a string separator and\n-         --  an escape character respectively by the underlying mechanism.\n-         --  On the other hand, quote and double-quote are not escaped since\n-         --  they are interpreted as string delimiters on both sides.\n-\n-         if Using_GNU_response_file then\n-            for J in S'Range loop\n-               if S (J) = ' ' or else S (J) = '\\' then\n-                  if Write (Tname_FD, Back_Slash'Address, 1) /= 1 then\n-                     Success := False;\n-                  end if;\n-               end if;\n-\n-               if Write (Tname_FD, S (J)'Address, 1) /= 1 then\n-                  Success := False;\n-               end if;\n-            end loop;\n-\n-         else\n-            if Write (Tname_FD, S'Address, S'Length) /= S'Length then\n-               Success := False;\n-            end if;\n-         end if;\n-\n-         if Write (Tname_FD, ASCII.LF'Address, 1) /= 1 then\n-            Success := False;\n-         end if;\n-\n-         if not Success then\n-            Fail (\"cannot generate response file to link library: disk full\");\n-         end if;\n-      end Write_RF;\n-\n-   --  Start of processing for Gcc\n-\n-   begin\n-      if Driver_Name = No_Name then\n-         if Gcc_Exec = null then\n-            if Gcc_Name = null then\n-               Gcc_Name := Osint.Program_Name (\"gcc\", \"gnatmake\");\n-            end if;\n-\n-            Gcc_Exec := Locate_Exec_On_Path (Gcc_Name.all);\n-\n-            if Gcc_Exec = null then\n-               Fail (Gcc_Name.all & \" not found in path\");\n-            end if;\n-         end if;\n-\n-         Driver := Gcc_Exec;\n-\n-      else\n-         Driver := Locate_Exec_On_Path (Get_Name_String (Driver_Name));\n-\n-         if Driver = null then\n-            Fail (Get_Name_String (Driver_Name) & \" not found in path\");\n-         end if;\n-      end if;\n-\n-      Link_Bytes := 0;\n-\n-      if Lib_Opt'Length /= 0 then\n-         A := A + 1;\n-         Arguments (A) := Lib_Opt;\n-         Link_Bytes := Link_Bytes + Lib_Opt'Length + 1;\n-      end if;\n-\n-      A := A + 1;\n-      Arguments (A) := Out_Opt;\n-      Link_Bytes := Link_Bytes + Out_Opt'Length + 1;\n-\n-      A := A + 1;\n-      Arguments (A) := Out_V;\n-      Link_Bytes := Link_Bytes + Out_V'Length + 1;\n-\n-      A := A + 1;\n-      Arguments (A) := Lib_Dir;\n-      Link_Bytes := Link_Bytes + Lib_Dir'Length + 1;\n-\n-      A := A + Options'Length;\n-      Arguments (A - Options'Length + 1 .. A) := Options;\n-\n-      for J in Options'Range loop\n-         Link_Bytes := Link_Bytes + Options (J)'Length + 1;\n-      end loop;\n-\n-      if not Opt.Quiet_Output then\n-         if Opt.Verbose_Mode then\n-            Write_Str (Driver.all);\n-\n-         elsif Driver_Name /= No_Name then\n-            Write_Str (Get_Name_String (Driver_Name));\n-\n-         else\n-            Write_Str (Gcc_Name.all);\n-         end if;\n-\n-         for J in 1 .. A loop\n-            if Opt.Verbose_Mode or else J < 4 then\n-               Write_Char (' ');\n-               Write_Str  (Arguments (J).all);\n-\n-            else\n-               Write_Str (\" ...\");\n-               exit;\n-            end if;\n-         end loop;\n-\n-         --  Do not display all the object files if not in verbose mode, only\n-         --  the first one.\n-\n-         Position := First;\n-         for J in Objects'Range loop\n-            if Opt.Verbose_Mode or else Position = First then\n-               Write_Char (' ');\n-               Write_Str (Objects (J).all);\n-               Position := Second;\n-\n-            elsif Position = Second then\n-               Write_Str (\" ...\");\n-               Position := Last;\n-               exit;\n-            end if;\n-         end loop;\n-\n-         for J in Options_2'Range loop\n-            if not Opt.Verbose_Mode then\n-               if Position = Second then\n-                  Write_Str (\" ...\");\n-               end if;\n-\n-               exit;\n-            end if;\n-\n-            Write_Char (' ');\n-            Write_Str (Options_2 (J).all);\n-         end loop;\n-\n-         Write_Eol;\n-      end if;\n-\n-      for J in Objects'Range loop\n-         Link_Bytes := Link_Bytes + Objects (J)'Length + 1;\n-      end loop;\n-\n-      for J in Options_2'Range loop\n-         Link_Bytes := Link_Bytes + Options_2 (J)'Length + 1;\n-      end loop;\n-\n-      if Object_List_File_Supported and then Link_Bytes > Link_Max then\n-\n-         --  Create a temporary file containing the object files, one object\n-         --  file per line for maximal compatibility with linkers supporting\n-         --  this option.\n-\n-         Create_Temp_File (Tname_FD, Tname);\n-\n-         for J in Objects'Range loop\n-            Write_RF (Objects (J).all);\n-         end loop;\n-\n-         Close (Tname_FD, Closing_Status);\n-\n-         if not Closing_Status then\n-            Fail (\"cannot generate response file to link library: disk full\");\n-         end if;\n-\n-         A := A + 1;\n-         Arguments (A) := new String'(Object_File_Option & Tname.all);\n-\n-      else\n-         A := A + Objects'Length;\n-         Arguments (A - Objects'Length + 1 .. A) := Objects;\n-      end if;\n-\n-      A := A + Options_2'Length;\n-      Arguments (A - Options_2'Length + 1 .. A) := Options_2;\n-\n-      Spawn (Driver.all, Arguments (1 .. A), Success);\n-\n-      if Success then\n-         --  Delete the temporary file used in conjunction with linking\n-         --  if one was created.\n-\n-         if Tname_FD /= Invalid_FD then\n-            Delete_File (Tname.all);\n-         end if;\n-\n-      else\n-         if Driver_Name = No_Name then\n-            Fail (Gcc_Name.all & \" execution error\");\n-         else\n-            Fail (Get_Name_String (Driver_Name) & \" execution error\");\n-         end if;\n-      end if;\n-   end Gcc;\n-\n-   -------------------\n-   -- Lib_Directory --\n-   -------------------\n-\n-   function Lib_Directory return String is\n-      Libgnat : constant String := Tgt.Libgnat;\n-\n-   begin\n-      --  If procedure Specify_Adalib_Dir has been called, used the specified\n-      --  value.\n-\n-      if Adalib_Path /= null then\n-         return Adalib_Path.all;\n-      end if;\n-\n-      Name_Len := Libgnat'Length;\n-      Name_Buffer (1 .. Name_Len) := Libgnat;\n-      Get_Name_String (Osint.Find_File (Name_Enter, Osint.Library));\n-\n-      --  Remove libgnat.a\n-\n-      return Name_Buffer (1 .. Name_Len - Libgnat'Length);\n-   end Lib_Directory;\n-\n-   ------------------------\n-   -- Specify_Adalib_Dir --\n-   ------------------------\n-\n-   procedure Specify_Adalib_Dir (Path : String) is\n-   begin\n-      if Path'Length = 0 then\n-         Adalib_Path := null;\n-      else\n-         Adalib_Path := new String'(Path);\n-      end if;\n-   end Specify_Adalib_Dir;\n-\n-end MLib.Utl;"}, {"sha": "f91eebf7f516771a35f1aebcbf65eed04a707250", "filename": "gcc/ada/mlib-utl.ads", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fmlib-utl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fmlib-utl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-utl.ads?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793", "patch": "@@ -1,67 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                             M L I B . U T L                              --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---                     Copyright (C) 2001-2008, AdaCore                     --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This package provides an easy way of calling various tools such as gcc,\n---  ar, etc...\n-\n-package MLib.Utl is\n-\n-   procedure Delete_File (Filename : String);\n-   --  Delete the file Filename and output the name of the deleted file in\n-   --  verbose mode.\n-\n-   procedure Gcc\n-     (Output_File : String;\n-      Objects     : Argument_List;\n-      Options     : Argument_List;\n-      Options_2   : Argument_List;\n-      Driver_Name : Name_Id := No_Name);\n-   --  Driver_Name indicates the \"driver\" to invoke; by default, the \"driver\"\n-   --  is gcc. This procedure invokes the driver to create a shared library.\n-   --  Options are passed to gcc before the objects, Options_2 after.\n-   --  Output_File is the name of the library file to create. Objects are the\n-   --  names of the object files to put in the library.\n-\n-   procedure Ar\n-     (Output_File : String;\n-      Objects     : Argument_List);\n-   --  Run ar to move all the binaries inside the archive. If ranlib is on\n-   --  the path, run it also. Output_File is the path name of the archive to\n-   --  create. Objects is the list of the path names of the object files to be\n-   --  put in the archive. This procedure currently assumes that it is always\n-   --  called in the context of gnatmake. If other executables start using this\n-   --  procedure, an additional parameter would need to be added, and calls to\n-   --  Osint.Program_Name updated accordingly in the body.\n-\n-   function Lib_Directory return String;\n-   --  Return the directory containing libgnat\n-\n-   procedure Specify_Adalib_Dir (Path : String);\n-   --  Specify the path of the GNAT adalib directory, to be returned by\n-   --  function Lib_Directory without looking for it. This is used only in\n-   --  gprlib, because we cannot rely on the search in Lib_Directory, as the\n-   --  GNAT version may be different for gprbuild/gprlib and the compiler.\n-\n-end MLib.Utl;"}, {"sha": "c4faea0e4a162fe56bea90469be5e0e6cc5f0d17", "filename": "gcc/ada/mlib.adb", "status": "removed", "additions": 0, "deletions": 464, "changes": 464, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fmlib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fmlib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib.adb?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793", "patch": "@@ -1,464 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                                 M L I B                                  --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---                     Copyright (C) 1999-2014, AdaCore                     --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-with Ada.Characters.Handling; use Ada.Characters.Handling;\n-with Interfaces.C.Strings;\n-with System;\n-\n-with Opt;\n-with Output; use Output;\n-\n-with MLib.Utl; use MLib.Utl;\n-\n-with Prj.Com;\n-\n-with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n-\n-package body MLib is\n-\n-   -------------------\n-   -- Build_Library --\n-   -------------------\n-\n-   procedure Build_Library\n-     (Ofiles      : Argument_List;\n-      Output_File : String;\n-      Output_Dir  : String)\n-   is\n-   begin\n-      if Opt.Verbose_Mode and not Opt.Quiet_Output then\n-         Write_Line (\"building a library...\");\n-         Write_Str  (\"   make \");\n-         Write_Line (Output_File);\n-      end if;\n-\n-      Ar (Output_Dir &\n-          \"lib\" & Output_File & \".a\", Objects => Ofiles);\n-   end Build_Library;\n-\n-   ------------------------\n-   -- Check_Library_Name --\n-   ------------------------\n-\n-   procedure Check_Library_Name (Name : String) is\n-   begin\n-      if Name'Length = 0 then\n-         Prj.Com.Fail (\"library name cannot be empty\");\n-      end if;\n-\n-      if Name'Length > Max_Characters_In_Library_Name then\n-         Prj.Com.Fail (\"illegal library name \"\"\"\n-                       & Name\n-                       & \"\"\": too long\");\n-      end if;\n-\n-      if not Is_Letter (Name (Name'First)) then\n-         Prj.Com.Fail (\"illegal library name \"\"\"\n-                       & Name\n-                       & \"\"\": should start with a letter\");\n-      end if;\n-\n-      for Index in Name'Range loop\n-         if not Is_Alphanumeric (Name (Index)) then\n-            Prj.Com.Fail (\"illegal library name \"\"\"\n-                          & Name\n-                          & \"\"\": should include only letters and digits\");\n-         end if;\n-      end loop;\n-   end Check_Library_Name;\n-\n-   --------------------\n-   -- Copy_ALI_Files --\n-   --------------------\n-\n-   procedure Copy_ALI_Files\n-     (Files      : Argument_List;\n-      To         : Path_Name_Type;\n-      Interfaces : String_List)\n-   is\n-      Success      : Boolean := False;\n-      To_Dir       : constant String := Get_Name_String (To);\n-      Is_Interface : Boolean := False;\n-\n-      procedure Verbose_Copy (Index : Positive);\n-      --  In verbose mode, output a message that the indexed file is copied\n-      --  to the destination directory.\n-\n-      ------------------\n-      -- Verbose_Copy --\n-      ------------------\n-\n-      procedure Verbose_Copy (Index : Positive) is\n-      begin\n-         if Opt.Verbose_Mode then\n-            Write_Str (\"Copying \"\"\");\n-            Write_Str (Files (Index).all);\n-            Write_Str (\"\"\" to \"\"\");\n-            Write_Str (To_Dir);\n-            Write_Line (\"\"\"\");\n-         end if;\n-      end Verbose_Copy;\n-\n-   --  Start of processing for Copy_ALI_Files\n-\n-   begin\n-      if Interfaces'Length = 0 then\n-\n-         --  If there are no Interfaces, copy all the ALI files as is\n-\n-         for Index in Files'Range loop\n-            Verbose_Copy (Index);\n-            Set_Writable\n-              (To_Dir &\n-               Directory_Separator &\n-               Base_Name (Files (Index).all));\n-            Copy_File\n-              (Files (Index).all,\n-               To_Dir,\n-               Success,\n-               Mode => Overwrite,\n-               Preserve => Preserve);\n-\n-            exit when not Success;\n-         end loop;\n-\n-      else\n-         --  Copy only the interface ALI file, and put the special indicator\n-         --  \"SL\" on the P line.\n-\n-         for Index in Files'Range loop\n-\n-            declare\n-               File_Name : String := Base_Name (Files (Index).all);\n-\n-            begin\n-               Canonical_Case_File_Name (File_Name);\n-\n-               --  Check if this is one of the interface ALIs\n-\n-               Is_Interface := False;\n-\n-               for Index in Interfaces'Range loop\n-                  if File_Name = Interfaces (Index).all then\n-                     Is_Interface := True;\n-                     exit;\n-                  end if;\n-               end loop;\n-\n-               --  If it is an interface ALI, copy line by line. Insert\n-               --  the interface indication at the end of the P line.\n-               --  Do not copy ALI files that are not Interfaces.\n-\n-               if Is_Interface then\n-                  Success := False;\n-                  Verbose_Copy (Index);\n-                  Set_Writable\n-                    (To_Dir &\n-                     Directory_Separator &\n-                     Base_Name (Files (Index).all));\n-\n-                  declare\n-                     FD           : File_Descriptor;\n-                     Len          : Integer;\n-                     Actual_Len   : Integer;\n-                     S            : String_Access;\n-                     Curr         : Natural;\n-                     P_Line_Found : Boolean;\n-                     Status       : Boolean;\n-\n-                  begin\n-                     --  Open the file\n-\n-                     Name_Len := Files (Index)'Length;\n-                     Name_Buffer (1 .. Name_Len) := Files (Index).all;\n-                     Name_Len := Name_Len + 1;\n-                     Name_Buffer (Name_Len) := ASCII.NUL;\n-\n-                     FD := Open_Read (Name_Buffer'Address, Binary);\n-\n-                     if FD /= Invalid_FD then\n-                        Len := Integer (File_Length (FD));\n-\n-                        --  ??? Why \"+3\" here\n-\n-                        S := new String (1 .. Len + 3);\n-\n-                        --  Read the file. This loop is probably not necessary\n-                        --  since on most (all?) targets, the whole file is\n-                        --  read in at once, but we have encountered systems\n-                        --  in the past where this was not true, and we retain\n-                        --  this loop in case we encounter that in the future.\n-\n-                        Curr := S'First;\n-                        while Curr <= Len loop\n-                           Actual_Len := Read (FD, S (Curr)'Address, Len);\n-\n-                           --  Exit if we could not read for some reason\n-\n-                           exit when Actual_Len = 0;\n-\n-                           Curr := Curr + Actual_Len;\n-                        end loop;\n-\n-                        --  We are done with the input file, so we close it\n-                        --  ignoring any bad status.\n-\n-                        Close (FD, Status);\n-\n-                        P_Line_Found := False;\n-\n-                        --  Look for the P line. When found, add marker SL\n-                        --  at the beginning of the P line.\n-\n-                        for Index in 1 .. Len - 3 loop\n-                           if (S (Index) = ASCII.LF\n-                                 or else\n-                               S (Index) = ASCII.CR)\n-                             and then S (Index + 1) = 'P'\n-                           then\n-                              S (Index + 5 .. Len + 3) := S (Index + 2 .. Len);\n-                              S (Index + 2 .. Index + 4) := \" SL\";\n-                              P_Line_Found := True;\n-                              exit;\n-                           end if;\n-                        end loop;\n-\n-                        if P_Line_Found then\n-\n-                           --  Create new modified ALI file\n-\n-                           Name_Len := To_Dir'Length;\n-                           Name_Buffer (1 .. Name_Len) := To_Dir;\n-                           Name_Len := Name_Len + 1;\n-                           Name_Buffer (Name_Len) := Directory_Separator;\n-                           Name_Buffer\n-                             (Name_Len + 1 .. Name_Len + File_Name'Length) :=\n-                                File_Name;\n-                           Name_Len := Name_Len + File_Name'Length + 1;\n-                           Name_Buffer (Name_Len) := ASCII.NUL;\n-\n-                           FD := Create_File (Name_Buffer'Address, Binary);\n-\n-                           --  Write the modified text and close the newly\n-                           --  created file.\n-\n-                           if FD /= Invalid_FD then\n-                              Actual_Len := Write (FD, S (1)'Address, Len + 3);\n-\n-                              Close (FD, Status);\n-\n-                              --  Set Success to True only if the newly\n-                              --  created file has been correctly written.\n-\n-                              Success := Status and then Actual_Len = Len + 3;\n-\n-                              if Success then\n-\n-                                 --  Set_Read_Only is used here, rather than\n-                                 --  Set_Non_Writable, so that gprbuild can\n-                                 --  he compiled with older compilers.\n-\n-                                 Set_Read_Only\n-                                   (Name_Buffer (1 .. Name_Len - 1));\n-                              end if;\n-                           end if;\n-                        end if;\n-                     end if;\n-                  end;\n-\n-               --  This is not an interface ALI\n-\n-               else\n-                  Success := True;\n-               end if;\n-            end;\n-\n-            if not Success then\n-               Prj.Com.Fail (\"could not copy ALI files to library dir\");\n-            end if;\n-         end loop;\n-      end if;\n-   end Copy_ALI_Files;\n-\n-   ----------------------\n-   -- Create_Sym_Links --\n-   ----------------------\n-\n-   procedure Create_Sym_Links\n-     (Lib_Path    : String;\n-      Lib_Version : String;\n-      Lib_Dir     : String;\n-      Maj_Version : String)\n-   is\n-      function Symlink\n-        (Oldpath : System.Address;\n-         Newpath : System.Address) return Integer;\n-      pragma Import (C, Symlink, \"__gnat_symlink\");\n-\n-      Version_Path : String_Access;\n-\n-      Success : Boolean;\n-      Result  : Integer;\n-      pragma Unreferenced (Success, Result);\n-\n-   begin\n-      Version_Path := new String (1 .. Lib_Version'Length + 1);\n-      Version_Path (1 .. Lib_Version'Length) := Lib_Version;\n-      Version_Path (Version_Path'Last)       := ASCII.NUL;\n-\n-      if Maj_Version'Length = 0 then\n-         declare\n-            Newpath : String (1 .. Lib_Path'Length + 1);\n-         begin\n-            Newpath (1 .. Lib_Path'Length) := Lib_Path;\n-            Newpath (Newpath'Last)         := ASCII.NUL;\n-            Delete_File (Lib_Path, Success);\n-            Result := Symlink (Version_Path (1)'Address, Newpath'Address);\n-         end;\n-\n-      else\n-         declare\n-            Newpath1 : String (1 .. Lib_Path'Length + 1);\n-            Maj_Path : constant String :=\n-                         Lib_Dir & Directory_Separator & Maj_Version;\n-            Newpath2 : String (1 .. Maj_Path'Length + 1);\n-            Maj_Ver  : String (1 .. Maj_Version'Length + 1);\n-\n-         begin\n-            Newpath1 (1 .. Lib_Path'Length) := Lib_Path;\n-            Newpath1 (Newpath1'Last)        := ASCII.NUL;\n-\n-            Newpath2 (1 .. Maj_Path'Length) := Maj_Path;\n-            Newpath2 (Newpath2'Last)        := ASCII.NUL;\n-\n-            Maj_Ver (1 .. Maj_Version'Length) := Maj_Version;\n-            Maj_Ver (Maj_Ver'Last)            := ASCII.NUL;\n-\n-            Delete_File (Maj_Path, Success);\n-\n-            Result := Symlink (Version_Path (1)'Address, Newpath2'Address);\n-\n-            Delete_File (Lib_Path, Success);\n-\n-            Result := Symlink (Maj_Ver'Address, Newpath1'Address);\n-         end;\n-      end if;\n-   end Create_Sym_Links;\n-\n-   --------------------------------\n-   -- Linker_Library_Path_Option --\n-   --------------------------------\n-\n-   function Linker_Library_Path_Option return String_Access is\n-\n-      Run_Path_Option_Ptr : Interfaces.C.Strings.chars_ptr;\n-      pragma Import (C, Run_Path_Option_Ptr, \"__gnat_run_path_option\");\n-      --  Pointer to string representing the native linker option which\n-      --  specifies the path where the dynamic loader should find shared\n-      --  libraries. Equal to null string if this system doesn't support it.\n-\n-      S : constant String := Interfaces.C.Strings.Value (Run_Path_Option_Ptr);\n-\n-   begin\n-      if S'Length = 0 then\n-         return null;\n-      else\n-         return new String'(S);\n-      end if;\n-   end Linker_Library_Path_Option;\n-\n-   -------------------\n-   -- Major_Id_Name --\n-   -------------------\n-\n-   function Major_Id_Name\n-     (Lib_Filename : String;\n-      Lib_Version  : String)\n-      return String\n-   is\n-      Maj_Version : constant String := Lib_Version;\n-      Last_Maj    : Positive;\n-      Last        : Positive;\n-      Ok_Maj      : Boolean := False;\n-\n-   begin\n-      Last_Maj := Maj_Version'Last;\n-      while Last_Maj > Maj_Version'First loop\n-         if Maj_Version (Last_Maj) in '0' .. '9' then\n-            Last_Maj := Last_Maj - 1;\n-\n-         else\n-            Ok_Maj := Last_Maj /= Maj_Version'Last and then\n-            Maj_Version (Last_Maj) = '.';\n-\n-            if Ok_Maj then\n-               Last_Maj := Last_Maj - 1;\n-            end if;\n-\n-            exit;\n-         end if;\n-      end loop;\n-\n-      if Ok_Maj then\n-         Last := Last_Maj;\n-         while Last > Maj_Version'First loop\n-            if Maj_Version (Last) in '0' .. '9' then\n-               Last := Last - 1;\n-\n-            else\n-               Ok_Maj := Last /= Last_Maj and then\n-               Maj_Version (Last) = '.';\n-\n-               if Ok_Maj then\n-                  Last := Last - 1;\n-                  Ok_Maj :=\n-                    Maj_Version (Maj_Version'First .. Last) = Lib_Filename;\n-               end if;\n-\n-               exit;\n-            end if;\n-         end loop;\n-      end if;\n-\n-      if Ok_Maj then\n-         return Maj_Version (Maj_Version'First .. Last_Maj);\n-      else\n-         return \"\";\n-      end if;\n-   end Major_Id_Name;\n-\n-   -------------------------------\n-   -- Separate_Run_Path_Options --\n-   -------------------------------\n-\n-   function Separate_Run_Path_Options return Boolean is\n-      Separate_Paths : Boolean;\n-      for Separate_Paths'Size use Character'Size;\n-      pragma Import (C, Separate_Paths, \"__gnat_separate_run_path_options\");\n-   begin\n-      return Separate_Paths;\n-   end Separate_Run_Path_Options;\n-\n-end MLib;"}, {"sha": "e370fa48de9962efd8f48d7ca5263b8b67ff999e", "filename": "gcc/ada/mlib.ads", "status": "removed", "additions": 0, "deletions": 95, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fmlib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fmlib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib.ads?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793", "patch": "@@ -1,95 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                                 M L I B                                  --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---                     Copyright (C) 1999-2014, AdaCore                     --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This package provides the core high level routines used by GNATMLIB\n---  and GNATMAKE to build libraries\n-\n-with Namet; use Namet;\n-with Osint; use Osint;\n-\n-with GNAT.OS_Lib; use GNAT.OS_Lib;\n-\n-package MLib is\n-\n-   No_Argument_List : aliased String_List := (1 .. 0 => null);\n-   No_Argument      : constant String_List_Access := No_Argument_List'Access;\n-\n-   Max_Characters_In_Library_Name : constant := 20;\n-   --  Maximum number of characters in a library name.\n-   --  Used by Check_Library_Name below.\n-\n-   type Fail_Proc is access procedure (S1 : String);\n-\n-   Fail : Fail_Proc := Osint.Fail'Access;\n-   --  This procedure is used in the MLib hierarchy, instead of\n-   --  directly calling Osint.Fail.\n-   --  It is redirected to Make.Make_Failed by gnatmake.\n-\n-   procedure Check_Library_Name (Name : String);\n-   --  Verify that the name of a library has the following characteristics\n-   --   - starts with a letter\n-   --   - includes only letters and digits\n-   --   - contains not more than Max_Characters_In_Library_Name characters\n-\n-   procedure Build_Library\n-     (Ofiles      : Argument_List;\n-      Output_File : String;\n-      Output_Dir  : String);\n-   --  Build a static library from a set of object files\n-\n-   procedure Copy_ALI_Files\n-     (Files      : Argument_List;\n-      To         : Path_Name_Type;\n-      Interfaces : String_List);\n-   --  Copy all ALI files Files to directory To.\n-   --  Mark Interfaces ALI files as interfaces, if any.\n-\n-   procedure Create_Sym_Links\n-     (Lib_Path    : String;\n-      Lib_Version : String;\n-      Lib_Dir     : String;\n-      Maj_Version : String);\n-\n-   function Linker_Library_Path_Option return String_Access;\n-   --  Linker option to specify to the linker the library directory path.\n-   --  If non null, the library directory path is to be appended.\n-   --  Should be deallocated by the caller, when no longer needed.\n-\n-   function Major_Id_Name\n-     (Lib_Filename : String;\n-      Lib_Version  : String) return String;\n-   --  Returns the major id library file name, if it exists.\n-   --  For example, if Lib_Filename is \"libtoto.so\" and Lib_Version is\n-   --  \"libtoto.so.1.2\", then \"libtoto.so.1\" is returned.\n-\n-   function Separate_Run_Path_Options return Boolean;\n-   --  Return True if separate rpath arguments must be passed to the linker\n-   --  for each directory in the rpath.\n-\n-private\n-   Preserve : Attribute := Time_Stamps;\n-   --  Used by Copy_ALI_Files\n-\n-end MLib;"}, {"sha": "f9f41b1628368334e6b7c08b845e04ce0a2565bd", "filename": "gcc/ada/prj-attr-pm.adb", "status": "removed", "additions": 0, "deletions": 74, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-attr-pm.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-attr-pm.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-attr-pm.adb?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793", "patch": "@@ -1,74 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                          P R J . A T T R . P M                           --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 2004-2014, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-package body Prj.Attr.PM is\n-\n-   -------------------\n-   -- Add_Attribute --\n-   -------------------\n-\n-   procedure Add_Attribute\n-     (To_Package     : Package_Node_Id;\n-      Attribute_Name : Name_Id;\n-      Attribute_Node : out Attribute_Node_Id)\n-   is\n-   begin\n-      --  Only add attribute if package is already defined and is not unknown\n-\n-      if To_Package /= Empty_Package   and then\n-         To_Package /= Unknown_Package\n-      then\n-         Attrs.Append (\n-           (Name           => Attribute_Name,\n-            Var_Kind       => Undefined,\n-            Optional_Index => False,\n-            Attr_Kind      => Unknown,\n-            Read_Only      => False,\n-            Others_Allowed => False,\n-            Default        => Empty_Value,\n-            Next           =>\n-              Package_Attributes.Table (To_Package.Value).First_Attribute));\n-\n-         Package_Attributes.Table (To_Package.Value).First_Attribute :=\n-           Attrs.Last;\n-         Attribute_Node := (Value => Attrs.Last);\n-      end if;\n-   end Add_Attribute;\n-\n-   -------------------------\n-   -- Add_Unknown_Package --\n-   -------------------------\n-\n-   procedure Add_Unknown_Package (Name : Name_Id; Id : out Package_Node_Id) is\n-   begin\n-      Package_Attributes.Increment_Last;\n-      Id := (Value => Package_Attributes.Last);\n-      Package_Attributes.Table (Id.Value) :=\n-        (Name             => Name,\n-         Known            => False,\n-         First_Attribute  => Empty_Attr);\n-   end Add_Unknown_Package;\n-\n-end Prj.Attr.PM;"}, {"sha": "0c6ce2e0fed05e2aea97299cb710c4681151465c", "filename": "gcc/ada/prj-attr-pm.ads", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-attr-pm.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-attr-pm.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-attr-pm.ads?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793", "patch": "@@ -1,48 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                          P R J . A T T R . P M                           --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---          Copyright (C) 2005-2007, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This package contains insecure procedures that are intended to be used\n---  only inside the Prj and MLib hierarchies. It should not be imported by\n---  other tools, such as GPS.\n-\n-package Prj.Attr.PM is\n-\n-   --  The following procedures are not secure and should only be used by the\n-   --  Project Manager, that is the packages of the Prj or MLib hierarchies.\n-   --  What does \"not secure\" mean???\n-\n-   procedure Add_Unknown_Package (Name : Name_Id; Id : out Package_Node_Id);\n-   --  Add a new unknown package. The Name cannot be the name of a predefined\n-   --  or already registered package, but this is not checked.\n-\n-   procedure Add_Attribute\n-     (To_Package     : Package_Node_Id;\n-      Attribute_Name : Name_Id;\n-      Attribute_Node : out Attribute_Node_Id);\n-   --  Add an attribute to the list for package To_Package. Attribute_Name\n-   --  cannot be the name of an existing attribute of the package, but this is\n-   --  not checked. Does nothing if To_Package is Empty_Package.\n-\n-end Prj.Attr.PM;"}, {"sha": "767fdb9a3846a852a35d5794909d4425a49bedf7", "filename": "gcc/ada/prj-attr.adb", "status": "removed", "additions": 0, "deletions": 1107, "changes": 1107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-attr.adb?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793", "patch": "@@ -1,1107 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                             P R J . A T T R                              --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 2001-2016, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-with Osint;\n-with Prj.Com; use Prj.Com;\n-\n-with GNAT.Case_Util; use GNAT.Case_Util;\n-\n-package body Prj.Attr is\n-\n-   use GNAT;\n-\n-   --  Data for predefined attributes and packages\n-\n-   --  Names are in lower case and end with '#' or 'D'\n-\n-   --  Package names are preceded by 'P'\n-\n-   --  Attribute names are preceded by two or three letters:\n-\n-   --  The first letter is one of\n-   --    'S' for Single\n-   --    's' for Single with optional index\n-   --    'L' for List\n-   --    'l' for List of strings with optional indexes\n-\n-   --  The second letter is one of\n-   --    'V' for single variable\n-   --    'A' for associative array\n-   --    'a' for case insensitive associative array\n-   --    'b' for associative array, case insensitive if file names are case\n-   --        insensitive\n-   --    'c' same as 'b', with optional index\n-\n-   --  The third optional letter is\n-   --     'R' the attribute is read-only\n-   --     'O' others is allowed as an index for an associative array\n-\n-   --  If the character after the name in lower case letter is a 'D' (for\n-   --  default), then 'D' must be followed by an enumeration value of type\n-   --  Attribute_Default_Value, followed by a '#'.\n-\n-   --  Example:\n-   --    \"SVobject_dirDdot_value#\"\n-\n-   --  End is indicated by two consecutive '#'.\n-\n-   Initialization_Data : constant String :=\n-\n-   --  project level attributes\n-\n-   --  General\n-\n-   \"SVRname#\" &\n-   \"SVRproject_dir#\" &\n-   \"lVmain#\" &\n-   \"LVlanguages#\" &\n-   \"Lbroots#\" &\n-   \"SVexternally_built#\" &\n-\n-   --  Directories\n-\n-   \"SVobject_dirDdot_value#\" &\n-   \"SVexec_dirDobject_dir_value#\" &\n-   \"LVsource_dirsDdot_value#\" &\n-   \"Lainherit_source_path#\" &\n-   \"LVexcluded_source_dirs#\" &\n-   \"LVignore_source_sub_dirs#\" &\n-\n-   --  Source files\n-\n-   \"LVsource_files#\" &\n-   \"LVlocally_removed_files#\" &\n-   \"LVexcluded_source_files#\" &\n-   \"SVsource_list_file#\" &\n-   \"SVexcluded_source_list_file#\" &\n-   \"LVinterfaces#\" &\n-\n-   --  Projects (in aggregate projects)\n-\n-   \"LVproject_files#\" &\n-   \"LVproject_path#\" &\n-   \"SAexternal#\" &\n-\n-   --  Libraries\n-\n-   \"SVlibrary_dir#\" &\n-   \"SVlibrary_name#\" &\n-   \"SVlibrary_kind#\" &\n-   \"SVlibrary_version#\" &\n-   \"LVlibrary_interface#\" &\n-   \"SVlibrary_standalone#\" &\n-   \"LVlibrary_encapsulated_options#\" &\n-   \"SVlibrary_encapsulated_supported#\" &\n-   \"SVlibrary_auto_init#\" &\n-   \"LVleading_library_options#\" &\n-   \"LVlibrary_options#\" &\n-   \"Lalibrary_rpath_options#\" &\n-   \"SVlibrary_src_dir#\" &\n-   \"SVlibrary_ali_dir#\" &\n-   \"SVlibrary_gcc#\" &\n-   \"SVlibrary_symbol_file#\" &\n-   \"SVlibrary_symbol_policy#\" &\n-   \"SVlibrary_reference_symbol_file#\" &\n-\n-   --  Configuration - General\n-\n-   \"SVdefault_language#\" &\n-   \"LVrun_path_option#\" &\n-   \"SVrun_path_origin#\" &\n-   \"SVseparate_run_path_options#\" &\n-   \"Satoolchain_version#\" &\n-   \"Satoolchain_description#\" &\n-   \"Saobject_generated#\" &\n-   \"Saobjects_linked#\" &\n-   \"SVtargetDtarget_value#\" &\n-   \"SaruntimeDruntime_value#\" &\n-\n-   --  Configuration - Libraries\n-\n-   \"SVlibrary_builder#\" &\n-   \"SVlibrary_support#\" &\n-\n-   --  Configuration - Archives\n-\n-   \"LVarchive_builder#\" &\n-   \"LVarchive_builder_append_option#\" &\n-   \"LVarchive_indexer#\" &\n-   \"SVarchive_suffix#\" &\n-   \"LVlibrary_partial_linker#\" &\n-\n-   --  Configuration - Shared libraries\n-\n-   \"SVshared_library_prefix#\" &\n-   \"SVshared_library_suffix#\" &\n-   \"SVsymbolic_link_supported#\" &\n-   \"SVlibrary_major_minor_id_supported#\" &\n-   \"SVlibrary_auto_init_supported#\" &\n-   \"LVshared_library_minimum_switches#\" &\n-   \"LVlibrary_version_switches#\" &\n-   \"SVlibrary_install_name_option#\" &\n-   \"Saruntime_library_dir#\" &\n-   \"Saruntime_source_dir#\" &\n-\n-   --  package Naming\n-   --  Some attributes are obsolescent, and renamed in the tree (see\n-   --  Prj.Dect.Rename_Obsolescent_Attributes).\n-\n-   \"Pnaming#\" &\n-   \"Saspecification_suffix#\" &  --  Always renamed to \"spec_suffix\" in tree\n-   \"Saspec_suffix#\" &\n-   \"Saimplementation_suffix#\" & --  Always renamed to \"body_suffix\" in tree\n-   \"Sabody_suffix#\" &\n-   \"SVseparate_suffix#\" &\n-   \"SVcasing#\" &\n-   \"SVdot_replacement#\" &\n-   \"saspecification#\" &  --  Always renamed to \"spec\" in project tree\n-   \"saspec#\" &\n-   \"saimplementation#\" & --  Always renamed to \"body\" in project tree\n-   \"sabody#\" &\n-   \"Laspecification_exceptions#\" &\n-   \"Laimplementation_exceptions#\" &\n-\n-   --  package Compiler\n-\n-   \"Pcompiler#\" &\n-   \"Ladefault_switches#\" &\n-   \"LcOswitches#\" &\n-   \"SVlocal_configuration_pragmas#\" &\n-   \"Salocal_config_file#\" &\n-\n-   --  Configuration - Compiling\n-\n-   \"Sadriver#\" &\n-   \"Salanguage_kind#\" &\n-   \"Sadependency_kind#\" &\n-   \"Larequired_switches#\" &\n-   \"Laleading_required_switches#\" &\n-   \"Latrailing_required_switches#\" &\n-   \"Lapic_option#\" &\n-   \"Sapath_syntax#\" &\n-   \"Lasource_file_switches#\" &\n-   \"Saobject_file_suffix#\" &\n-   \"Laobject_file_switches#\" &\n-   \"Lamulti_unit_switches#\" &\n-   \"Samulti_unit_object_separator#\" &\n-\n-   --  Configuration - Mapping files\n-\n-   \"Lamapping_file_switches#\" &\n-   \"Samapping_spec_suffix#\" &\n-   \"Samapping_body_suffix#\" &\n-\n-   --  Configuration - Config files\n-\n-   \"Laconfig_file_switches#\" &\n-   \"Saconfig_body_file_name#\" &\n-   \"Saconfig_body_file_name_index#\" &\n-   \"Saconfig_body_file_name_pattern#\" &\n-   \"Saconfig_spec_file_name#\" &\n-   \"Saconfig_spec_file_name_index#\" &\n-   \"Saconfig_spec_file_name_pattern#\" &\n-   \"Saconfig_file_unique#\" &\n-\n-   --  Configuration - Dependencies\n-\n-   \"Ladependency_switches#\" &\n-   \"Ladependency_driver#\" &\n-\n-   --  Configuration - Search paths\n-\n-   \"Lainclude_switches#\" &\n-   \"Sainclude_path#\" &\n-   \"Sainclude_path_file#\" &\n-   \"Laobject_path_switches#\" &\n-\n-   --  package Builder\n-\n-   \"Pbuilder#\" &\n-   \"Ladefault_switches#\" &\n-   \"LcOswitches#\" &\n-   \"Lcglobal_compilation_switches#\" &\n-   \"Scexecutable#\" &\n-   \"SVexecutable_suffix#\" &\n-   \"SVglobal_configuration_pragmas#\" &\n-   \"Saglobal_config_file#\" &\n-\n-   --  package gnatls\n-\n-   \"Pgnatls#\" &\n-   \"LVswitches#\" &\n-\n-   --  package Binder\n-\n-   \"Pbinder#\" &\n-   \"Ladefault_switches#\" &\n-   \"LcOswitches#\" &\n-\n-   --  Configuration - Binding\n-\n-   \"Sadriver#\" &\n-   \"Larequired_switches#\" &\n-   \"Saprefix#\" &\n-   \"Saobjects_path#\" &\n-   \"Saobjects_path_file#\" &\n-\n-   --  package Linker\n-\n-   \"Plinker#\" &\n-   \"LVrequired_switches#\" &\n-   \"Ladefault_switches#\" &\n-   \"LcOleading_switches#\" &\n-   \"LcOswitches#\" &\n-   \"LcOtrailing_switches#\" &\n-   \"LVlinker_options#\" &\n-   \"SVmap_file_option#\" &\n-\n-   --  Configuration - Linking\n-\n-   \"SVdriver#\" &\n-\n-   --  Configuration - Response files\n-\n-   \"SVmax_command_line_length#\" &\n-   \"SVresponse_file_format#\" &\n-   \"LVresponse_file_switches#\" &\n-\n-   --  package Clean\n-\n-   \"Pclean#\" &\n-   \"LVswitches#\" &\n-   \"Lasource_artifact_extensions#\" &\n-   \"Laobject_artifact_extensions#\" &\n-   \"LVartifacts_in_exec_dir#\" &\n-   \"LVartifacts_in_object_dir#\" &\n-\n-   --  package Cross_Reference\n-\n-   \"Pcross_reference#\" &\n-   \"Ladefault_switches#\" &\n-   \"LbOswitches#\" &\n-\n-   --  package Finder\n-\n-   \"Pfinder#\" &\n-   \"Ladefault_switches#\" &\n-   \"LbOswitches#\" &\n-\n-   --  package Pretty_Printer\n-\n-   \"Ppretty_printer#\" &\n-   \"Ladefault_switches#\" &\n-   \"LbOswitches#\" &\n-\n-   --  package gnatstub\n-\n-   \"Pgnatstub#\" &\n-   \"Ladefault_switches#\" &\n-   \"LbOswitches#\" &\n-\n-   --  package Check\n-\n-   \"Pcheck#\" &\n-   \"Ladefault_switches#\" &\n-   \"LbOswitches#\" &\n-\n-   --  package Eliminate\n-\n-   \"Peliminate#\" &\n-   \"Ladefault_switches#\" &\n-   \"LbOswitches#\" &\n-\n-   --  package Metrics\n-\n-   \"Pmetrics#\" &\n-   \"Ladefault_switches#\" &\n-   \"LbOswitches#\" &\n-\n-   --  package Ide\n-\n-   \"Pide#\" &\n-   \"Ladefault_switches#\" &\n-   \"SVremote_host#\" &\n-   \"SVprogram_host#\" &\n-   \"SVcommunication_protocol#\" &\n-   \"Sacompiler_command#\" &\n-   \"SVdebugger_command#\" &\n-   \"SVgnatlist#\" &\n-   \"SVvcs_kind#\" &\n-   \"SVvcs_file_check#\" &\n-   \"SVvcs_log_check#\" &\n-   \"SVdocumentation_dir#\" &\n-\n-   --  package Install\n-\n-   \"Pinstall#\" &\n-   \"SVprefix#\" &\n-   \"SVsources_subdir#\" &\n-   \"SVexec_subdir#\" &\n-   \"SVlib_subdir#\" &\n-   \"SVproject_subdir#\" &\n-   \"SVactive#\" &\n-   \"LAartifacts#\" &\n-   \"LArequired_artifacts#\" &\n-   \"SVmode#\" &\n-   \"SVinstall_name#\" &\n-\n-   --  package Remote\n-\n-   \"Premote#\" &\n-   \"SVroot_dir#\" &\n-   \"LVexcluded_patterns#\" &\n-   \"LVincluded_patterns#\" &\n-   \"LVincluded_artifact_patterns#\" &\n-\n-   --  package Stack\n-\n-   \"Pstack#\" &\n-   \"LVswitches#\" &\n-\n-   --  package Codepeer\n-\n-   \"Pcodepeer#\" &\n-   \"SVoutput_directory#\" &\n-   \"SVdatabase_directory#\" &\n-   \"SVmessage_patterns#\" &\n-   \"SVadditional_patterns#\" &\n-   \"LVswitches#\" &\n-   \"LVexcluded_source_files#\" &\n-\n-   --  package Prove\n-\n-   \"Pprove#\" &\n-\n-   --  package GnatTest\n-\n-   \"Pgnattest#\" &\n-\n-   \"#\";\n-\n-   Initialized : Boolean := False;\n-   --  A flag to avoid multiple initialization\n-\n-   Package_Names     : String_List_Access := new Strings.String_List (1 .. 20);\n-   Last_Package_Name : Natural := 0;\n-   --  Package_Names (1 .. Last_Package_Name) contains the list of the known\n-   --  package names, coming from the Initialization_Data string or from\n-   --  calls to one of the two procedures Register_New_Package.\n-\n-   procedure Add_Package_Name (Name : String);\n-   --  Add a package name in the Package_Name list, extending it, if necessary\n-\n-   function Name_Id_Of (Name : String) return Name_Id;\n-   --  Returns the Name_Id for Name in lower case\n-\n-   ----------------------\n-   -- Add_Package_Name --\n-   ----------------------\n-\n-   procedure Add_Package_Name (Name : String) is\n-   begin\n-      if Last_Package_Name = Package_Names'Last then\n-         declare\n-            New_List : constant Strings.String_List_Access :=\n-                         new Strings.String_List (1 .. Package_Names'Last * 2);\n-         begin\n-            New_List (Package_Names'Range) := Package_Names.all;\n-            Package_Names := New_List;\n-         end;\n-      end if;\n-\n-      Last_Package_Name := Last_Package_Name + 1;\n-      Package_Names (Last_Package_Name) := new String'(Name);\n-   end Add_Package_Name;\n-\n-   --------------------------\n-   -- Attribute_Default_Of --\n-   --------------------------\n-\n-   function Attribute_Default_Of\n-     (Attribute : Attribute_Node_Id) return Attribute_Default_Value\n-   is\n-   begin\n-      if Attribute = Empty_Attribute then\n-         return Empty_Value;\n-      else\n-         return Attrs.Table (Attribute.Value).Default;\n-      end if;\n-   end Attribute_Default_Of;\n-\n-   -----------------------\n-   -- Attribute_Kind_Of --\n-   -----------------------\n-\n-   function Attribute_Kind_Of\n-     (Attribute : Attribute_Node_Id) return Attribute_Kind\n-   is\n-   begin\n-      if Attribute = Empty_Attribute then\n-         return Unknown;\n-      else\n-         return Attrs.Table (Attribute.Value).Attr_Kind;\n-      end if;\n-   end Attribute_Kind_Of;\n-\n-   -----------------------\n-   -- Attribute_Name_Of --\n-   -----------------------\n-\n-   function Attribute_Name_Of (Attribute : Attribute_Node_Id) return Name_Id is\n-   begin\n-      if Attribute = Empty_Attribute then\n-         return No_Name;\n-      else\n-         return Attrs.Table (Attribute.Value).Name;\n-      end if;\n-   end Attribute_Name_Of;\n-\n-   --------------------------\n-   -- Attribute_Node_Id_Of --\n-   --------------------------\n-\n-   function Attribute_Node_Id_Of\n-     (Name        : Name_Id;\n-      Starting_At : Attribute_Node_Id) return Attribute_Node_Id\n-   is\n-      Id : Attr_Node_Id := Starting_At.Value;\n-\n-   begin\n-      while Id /= Empty_Attr\n-        and then Attrs.Table (Id).Name /= Name\n-      loop\n-         Id := Attrs.Table (Id).Next;\n-      end loop;\n-\n-      return (Value => Id);\n-   end Attribute_Node_Id_Of;\n-\n-   ----------------\n-   -- Initialize --\n-   ----------------\n-\n-   procedure Initialize is\n-      Start             : Positive          := Initialization_Data'First;\n-      Finish            : Positive          := Start;\n-      Current_Package   : Pkg_Node_Id       := Empty_Pkg;\n-      Current_Attribute : Attr_Node_Id      := Empty_Attr;\n-      Is_An_Attribute   : Boolean           := False;\n-      Var_Kind          : Variable_Kind     := Undefined;\n-      Optional_Index    : Boolean           := False;\n-      Attr_Kind         : Attribute_Kind    := Single;\n-      Package_Name      : Name_Id           := No_Name;\n-      Attribute_Name    : Name_Id           := No_Name;\n-      First_Attribute   : Attr_Node_Id      := Attr.First_Attribute;\n-      Read_Only         : Boolean;\n-      Others_Allowed    : Boolean;\n-      Default           : Attribute_Default_Value;\n-\n-      function Attribute_Location return String;\n-      --  Returns a string depending if we are in the project level attributes\n-      --  or in the attributes of a package.\n-\n-      ------------------------\n-      -- Attribute_Location --\n-      ------------------------\n-\n-      function Attribute_Location return String is\n-      begin\n-         if Package_Name = No_Name then\n-            return \"project level attributes\";\n-\n-         else\n-            return \"attribute of package \"\"\" &\n-            Get_Name_String (Package_Name) & \"\"\"\";\n-         end if;\n-      end Attribute_Location;\n-\n-   --  Start of processing for Initialize\n-\n-   begin\n-      --  Don't allow Initialize action to be repeated\n-\n-      if Initialized then\n-         return;\n-      end if;\n-\n-      --  Make sure the two tables are empty\n-\n-      Attrs.Init;\n-      Package_Attributes.Init;\n-\n-      while Initialization_Data (Start) /= '#' loop\n-         Is_An_Attribute := True;\n-         case Initialization_Data (Start) is\n-            when 'P' =>\n-\n-               --  New allowed package\n-\n-               Start := Start + 1;\n-\n-               Finish := Start;\n-               while Initialization_Data (Finish) /= '#' loop\n-                  Finish := Finish + 1;\n-               end loop;\n-\n-               Package_Name :=\n-                 Name_Id_Of (Initialization_Data (Start .. Finish - 1));\n-\n-               for Index in First_Package .. Package_Attributes.Last loop\n-                  if Package_Name = Package_Attributes.Table (Index).Name then\n-                     Osint.Fail (\"duplicate name \"\"\"\n-                                 & Initialization_Data (Start .. Finish - 1)\n-                                 & \"\"\" in predefined packages.\");\n-                  end if;\n-               end loop;\n-\n-               Is_An_Attribute := False;\n-               Current_Attribute := Empty_Attr;\n-               Package_Attributes.Increment_Last;\n-               Current_Package := Package_Attributes.Last;\n-               Package_Attributes.Table (Current_Package) :=\n-                 (Name             => Package_Name,\n-                  Known            => True,\n-                  First_Attribute  => Empty_Attr);\n-               Start := Finish + 1;\n-\n-               Add_Package_Name (Get_Name_String (Package_Name));\n-\n-            when 'S' =>\n-               Var_Kind       := Single;\n-               Optional_Index := False;\n-\n-            when 's' =>\n-               Var_Kind       := Single;\n-               Optional_Index := True;\n-\n-            when 'L' =>\n-               Var_Kind       := List;\n-               Optional_Index := False;\n-\n-            when 'l' =>\n-               Var_Kind         := List;\n-               Optional_Index := True;\n-\n-            when others =>\n-               raise Program_Error;\n-         end case;\n-\n-         if Is_An_Attribute then\n-\n-            --  New attribute\n-\n-            Start := Start + 1;\n-            case Initialization_Data (Start) is\n-               when 'V' =>\n-                  Attr_Kind := Single;\n-\n-               when 'A' =>\n-                  Attr_Kind := Associative_Array;\n-\n-               when 'a' =>\n-                  Attr_Kind := Case_Insensitive_Associative_Array;\n-\n-               when 'b' =>\n-                  if Osint.File_Names_Case_Sensitive then\n-                     Attr_Kind := Associative_Array;\n-                  else\n-                     Attr_Kind := Case_Insensitive_Associative_Array;\n-                  end if;\n-\n-               when 'c' =>\n-                  if Osint.File_Names_Case_Sensitive then\n-                     Attr_Kind := Optional_Index_Associative_Array;\n-                  else\n-                     Attr_Kind :=\n-                       Optional_Index_Case_Insensitive_Associative_Array;\n-                  end if;\n-\n-               when others =>\n-                  raise Program_Error;\n-            end case;\n-\n-            Start := Start + 1;\n-\n-            Read_Only := False;\n-            Others_Allowed := False;\n-            Default := Empty_Value;\n-\n-            if Initialization_Data (Start) = 'R' then\n-               Read_Only := True;\n-               Default := Read_Only_Value;\n-               Start := Start + 1;\n-\n-            elsif Initialization_Data (Start) = 'O' then\n-               Others_Allowed := True;\n-               Start := Start + 1;\n-            end if;\n-\n-            Finish := Start;\n-\n-            while Initialization_Data (Finish) /= '#'\n-                    and then\n-                  Initialization_Data (Finish) /= 'D'\n-            loop\n-               Finish := Finish + 1;\n-            end loop;\n-\n-            Attribute_Name :=\n-              Name_Id_Of (Initialization_Data (Start .. Finish - 1));\n-\n-            if Initialization_Data (Finish) = 'D' then\n-               Start := Finish + 1;\n-\n-               Finish := Start;\n-               while Initialization_Data (Finish) /= '#' loop\n-                  Finish := Finish + 1;\n-               end loop;\n-\n-               declare\n-                  Default_Name : constant String :=\n-                                   Initialization_Data (Start .. Finish - 1);\n-                  pragma Unsuppress (All_Checks);\n-               begin\n-                  Default := Attribute_Default_Value'Value (Default_Name);\n-               exception\n-                  when Constraint_Error =>\n-                     Osint.Fail\n-                       (\"illegal default value \"\"\" &\n-                        Default_Name &\n-                        \"\"\" for attribute \" &\n-                        Get_Name_String (Attribute_Name));\n-               end;\n-            end if;\n-\n-            Attrs.Increment_Last;\n-\n-            if Current_Attribute = Empty_Attr then\n-               First_Attribute := Attrs.Last;\n-\n-               if Current_Package /= Empty_Pkg then\n-                  Package_Attributes.Table (Current_Package).First_Attribute\n-                    := Attrs.Last;\n-               end if;\n-\n-            else\n-               --  Check that there are no duplicate attributes\n-\n-               for Index in First_Attribute .. Attrs.Last - 1 loop\n-                  if Attribute_Name = Attrs.Table (Index).Name then\n-                     Osint.Fail (\"duplicate attribute \"\"\"\n-                                 & Initialization_Data (Start .. Finish - 1)\n-                                 & \"\"\" in \" & Attribute_Location);\n-                  end if;\n-               end loop;\n-\n-               Attrs.Table (Current_Attribute).Next :=\n-                 Attrs.Last;\n-            end if;\n-\n-            Current_Attribute := Attrs.Last;\n-            Attrs.Table (Current_Attribute) :=\n-              (Name           => Attribute_Name,\n-               Var_Kind       => Var_Kind,\n-               Optional_Index => Optional_Index,\n-               Attr_Kind      => Attr_Kind,\n-               Read_Only      => Read_Only,\n-               Others_Allowed => Others_Allowed,\n-               Default        => Default,\n-               Next           => Empty_Attr);\n-            Start := Finish + 1;\n-         end if;\n-      end loop;\n-\n-      Initialized := True;\n-   end Initialize;\n-\n-   ------------------\n-   -- Is_Read_Only --\n-   ------------------\n-\n-   function Is_Read_Only (Attribute : Attribute_Node_Id) return Boolean is\n-   begin\n-      return Attrs.Table (Attribute.Value).Read_Only;\n-   end Is_Read_Only;\n-\n-   ----------------\n-   -- Name_Id_Of --\n-   ----------------\n-\n-   function Name_Id_Of (Name : String) return Name_Id is\n-   begin\n-      Name_Len := 0;\n-      Add_Str_To_Name_Buffer (Name);\n-      To_Lower (Name_Buffer (1 .. Name_Len));\n-      return Name_Find;\n-   end Name_Id_Of;\n-\n-   --------------------\n-   -- Next_Attribute --\n-   --------------------\n-\n-   function Next_Attribute\n-     (After : Attribute_Node_Id) return Attribute_Node_Id\n-   is\n-   begin\n-      if After = Empty_Attribute then\n-         return Empty_Attribute;\n-      else\n-         return (Value => Attrs.Table (After.Value).Next);\n-      end if;\n-   end Next_Attribute;\n-\n-   -----------------------\n-   -- Optional_Index_Of --\n-   -----------------------\n-\n-   function Optional_Index_Of (Attribute : Attribute_Node_Id) return Boolean is\n-   begin\n-      if Attribute = Empty_Attribute then\n-         return False;\n-      else\n-         return Attrs.Table (Attribute.Value).Optional_Index;\n-      end if;\n-   end Optional_Index_Of;\n-\n-   function Others_Allowed_For\n-     (Attribute : Attribute_Node_Id) return Boolean\n-   is\n-   begin\n-      if Attribute = Empty_Attribute then\n-         return False;\n-      else\n-         return Attrs.Table (Attribute.Value).Others_Allowed;\n-      end if;\n-   end Others_Allowed_For;\n-\n-   -----------------------\n-   -- Package_Name_List --\n-   -----------------------\n-\n-   function Package_Name_List return Strings.String_List is\n-   begin\n-      return Package_Names (1 .. Last_Package_Name);\n-   end Package_Name_List;\n-\n-   ------------------------\n-   -- Package_Node_Id_Of --\n-   ------------------------\n-\n-   function Package_Node_Id_Of (Name : Name_Id) return Package_Node_Id is\n-   begin\n-      for Index in Package_Attributes.First .. Package_Attributes.Last loop\n-         if Package_Attributes.Table (Index).Name = Name then\n-            if Package_Attributes.Table (Index).Known then\n-               return (Value => Index);\n-            else\n-               return Unknown_Package;\n-            end if;\n-         end if;\n-      end loop;\n-\n-      --  If there is no package with this name, return Empty_Package\n-\n-      return Empty_Package;\n-   end Package_Node_Id_Of;\n-\n-   ----------------------------\n-   -- Register_New_Attribute --\n-   ----------------------------\n-\n-   procedure Register_New_Attribute\n-     (Name               : String;\n-      In_Package         : Package_Node_Id;\n-      Attr_Kind          : Defined_Attribute_Kind;\n-      Var_Kind           : Defined_Variable_Kind;\n-      Index_Is_File_Name : Boolean                 := False;\n-      Opt_Index          : Boolean                 := False;\n-      Default            : Attribute_Default_Value := Empty_Value)\n-   is\n-      Attr_Name       : Name_Id;\n-      First_Attr      : Attr_Node_Id := Empty_Attr;\n-      Curr_Attr       : Attr_Node_Id;\n-      Real_Attr_Kind  : Attribute_Kind;\n-\n-   begin\n-      if Name'Length = 0 then\n-         Fail (\"cannot register an attribute with no name\");\n-         raise Project_Error;\n-      end if;\n-\n-      if In_Package = Empty_Package then\n-         Fail (\"attempt to add attribute \"\"\"\n-               & Name\n-               & \"\"\" to an undefined package\");\n-         raise Project_Error;\n-      end if;\n-\n-      Attr_Name := Name_Id_Of (Name);\n-\n-      First_Attr :=\n-        Package_Attributes.Table (In_Package.Value).First_Attribute;\n-\n-      --  Check if attribute name is a duplicate\n-\n-      Curr_Attr := First_Attr;\n-      while Curr_Attr /= Empty_Attr loop\n-         if Attrs.Table (Curr_Attr).Name = Attr_Name then\n-            Fail (\"duplicate attribute name \"\"\"\n-                  & Name\n-                  & \"\"\" in package \"\"\"\n-                  & Get_Name_String\n-                     (Package_Attributes.Table (In_Package.Value).Name)\n-                  & \"\"\"\");\n-            raise Project_Error;\n-         end if;\n-\n-         Curr_Attr := Attrs.Table (Curr_Attr).Next;\n-      end loop;\n-\n-      Real_Attr_Kind := Attr_Kind;\n-\n-      --  If Index_Is_File_Name, change the attribute kind if necessary\n-\n-      if Index_Is_File_Name and then not Osint.File_Names_Case_Sensitive then\n-         case Attr_Kind is\n-            when Associative_Array =>\n-               Real_Attr_Kind := Case_Insensitive_Associative_Array;\n-\n-            when Optional_Index_Associative_Array =>\n-               Real_Attr_Kind :=\n-                 Optional_Index_Case_Insensitive_Associative_Array;\n-\n-            when others =>\n-               null;\n-         end case;\n-      end if;\n-\n-      --  Add the new attribute\n-\n-      Attrs.Increment_Last;\n-      Attrs.Table (Attrs.Last) :=\n-        (Name           => Attr_Name,\n-         Var_Kind       => Var_Kind,\n-         Optional_Index => Opt_Index,\n-         Attr_Kind      => Real_Attr_Kind,\n-         Read_Only      => False,\n-         Others_Allowed => False,\n-         Default        => Default,\n-         Next           => First_Attr);\n-\n-      Package_Attributes.Table (In_Package.Value).First_Attribute :=\n-        Attrs.Last;\n-   end Register_New_Attribute;\n-\n-   --------------------------\n-   -- Register_New_Package --\n-   --------------------------\n-\n-   procedure Register_New_Package (Name : String; Id : out Package_Node_Id) is\n-      Pkg_Name : Name_Id;\n-      Found    : Boolean := False;\n-\n-   begin\n-      if Name'Length = 0 then\n-         Fail (\"cannot register a package with no name\");\n-         Id := Empty_Package;\n-         return;\n-      end if;\n-\n-      Pkg_Name := Name_Id_Of (Name);\n-\n-      for Index in Package_Attributes.First .. Package_Attributes.Last loop\n-         if Package_Attributes.Table (Index).Name = Pkg_Name then\n-            if Package_Attributes.Table (Index).Known then\n-               Fail (\"cannot register a package with a non unique name \"\"\"\n-                     & Name\n-                     & \"\"\"\");\n-               Id := Empty_Package;\n-               return;\n-\n-            else\n-               Found := True;\n-               Id := (Value => Index);\n-               exit;\n-            end if;\n-         end if;\n-      end loop;\n-\n-      if not Found then\n-         Package_Attributes.Increment_Last;\n-         Id := (Value => Package_Attributes.Last);\n-      end if;\n-\n-      Package_Attributes.Table (Id.Value) :=\n-        (Name             => Pkg_Name,\n-         Known            => True,\n-         First_Attribute  => Empty_Attr);\n-\n-      Add_Package_Name (Get_Name_String (Pkg_Name));\n-   end Register_New_Package;\n-\n-   procedure Register_New_Package\n-     (Name       : String;\n-      Attributes : Attribute_Data_Array)\n-   is\n-      Pkg_Name   : Name_Id;\n-      Attr_Name  : Name_Id;\n-      First_Attr : Attr_Node_Id := Empty_Attr;\n-      Curr_Attr  : Attr_Node_Id;\n-      Attr_Kind  : Attribute_Kind;\n-\n-   begin\n-      if Name'Length = 0 then\n-         Fail (\"cannot register a package with no name\");\n-         raise Project_Error;\n-      end if;\n-\n-      Pkg_Name := Name_Id_Of (Name);\n-\n-      for Index in Package_Attributes.First .. Package_Attributes.Last loop\n-         if Package_Attributes.Table (Index).Name = Pkg_Name then\n-            Fail (\"cannot register a package with a non unique name \"\"\"\n-                  & Name\n-                  & \"\"\"\");\n-            raise Project_Error;\n-         end if;\n-      end loop;\n-\n-      for Index in Attributes'Range loop\n-         Attr_Name := Name_Id_Of (Attributes (Index).Name);\n-\n-         Curr_Attr := First_Attr;\n-         while Curr_Attr /= Empty_Attr loop\n-            if Attrs.Table (Curr_Attr).Name = Attr_Name then\n-               Fail (\"duplicate attribute name \"\"\"\n-                     & Attributes (Index).Name\n-                     & \"\"\" in new package \"\"\"\n-                     & Name\n-                     & \"\"\"\");\n-               raise Project_Error;\n-            end if;\n-\n-            Curr_Attr := Attrs.Table (Curr_Attr).Next;\n-         end loop;\n-\n-         Attr_Kind := Attributes (Index).Attr_Kind;\n-\n-         if Attributes (Index).Index_Is_File_Name\n-           and then not Osint.File_Names_Case_Sensitive\n-         then\n-            case Attr_Kind is\n-               when Associative_Array =>\n-                  Attr_Kind := Case_Insensitive_Associative_Array;\n-\n-               when Optional_Index_Associative_Array =>\n-                  Attr_Kind :=\n-                    Optional_Index_Case_Insensitive_Associative_Array;\n-\n-               when others =>\n-                  null;\n-            end case;\n-         end if;\n-\n-         Attrs.Increment_Last;\n-         Attrs.Table (Attrs.Last) :=\n-           (Name           => Attr_Name,\n-            Var_Kind       => Attributes (Index).Var_Kind,\n-            Optional_Index => Attributes (Index).Opt_Index,\n-            Attr_Kind      => Attr_Kind,\n-            Read_Only      => False,\n-            Others_Allowed => False,\n-            Default        => Attributes (Index).Default,\n-            Next           => First_Attr);\n-         First_Attr := Attrs.Last;\n-      end loop;\n-\n-      Package_Attributes.Increment_Last;\n-      Package_Attributes.Table (Package_Attributes.Last) :=\n-        (Name             => Pkg_Name,\n-         Known            => True,\n-         First_Attribute  => First_Attr);\n-\n-      Add_Package_Name (Get_Name_String (Pkg_Name));\n-   end Register_New_Package;\n-\n-   ---------------------------\n-   -- Set_Attribute_Kind_Of --\n-   ---------------------------\n-\n-   procedure Set_Attribute_Kind_Of\n-     (Attribute : Attribute_Node_Id;\n-      To        : Attribute_Kind)\n-   is\n-   begin\n-      if Attribute /= Empty_Attribute then\n-         Attrs.Table (Attribute.Value).Attr_Kind := To;\n-      end if;\n-   end Set_Attribute_Kind_Of;\n-\n-   --------------------------\n-   -- Set_Variable_Kind_Of --\n-   --------------------------\n-\n-   procedure Set_Variable_Kind_Of\n-     (Attribute : Attribute_Node_Id;\n-      To        : Variable_Kind)\n-   is\n-   begin\n-      if Attribute /= Empty_Attribute then\n-         Attrs.Table (Attribute.Value).Var_Kind := To;\n-      end if;\n-   end Set_Variable_Kind_Of;\n-\n-   ----------------------\n-   -- Variable_Kind_Of --\n-   ----------------------\n-\n-   function Variable_Kind_Of\n-     (Attribute : Attribute_Node_Id) return Variable_Kind\n-   is\n-   begin\n-      if Attribute = Empty_Attribute then\n-         return Undefined;\n-      else\n-         return Attrs.Table (Attribute.Value).Var_Kind;\n-      end if;\n-   end Variable_Kind_Of;\n-\n-   ------------------------\n-   -- First_Attribute_Of --\n-   ------------------------\n-\n-   function First_Attribute_Of\n-     (Pkg : Package_Node_Id) return Attribute_Node_Id\n-   is\n-   begin\n-      if Pkg = Empty_Package or else Pkg = Unknown_Package then\n-         return Empty_Attribute;\n-      else\n-         return\n-           (Value => Package_Attributes.Table (Pkg.Value).First_Attribute);\n-      end if;\n-   end First_Attribute_Of;\n-\n-end Prj.Attr;"}, {"sha": "ad2f033e7ad4c80d79a9ea434e02f9a7c95decdf", "filename": "gcc/ada/prj-attr.ads", "status": "removed", "additions": 0, "deletions": 368, "changes": 368, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-attr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-attr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-attr.ads?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793", "patch": "@@ -1,368 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                             P R J . A T T R                              --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---          Copyright (C) 2001-2017, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This package defines packages and attributes in GNAT project files.\n---  There are predefined packages and attributes.\n-\n---  It is also possible to define new packages with their attributes\n-\n-with Table;\n-\n-with GNAT.Strings;\n-\n-package Prj.Attr is\n-\n-   function Package_Name_List return GNAT.Strings.String_List;\n-   --  Returns the list of valid package names, including those added by\n-   --  procedures Register_New_Package below. The String_Access components of\n-   --  the returned String_List should never be freed.\n-\n-   procedure Initialize;\n-   --  Initialize the predefined project level attributes and the predefined\n-   --  packages and their attribute. This procedure should be called by\n-   --  Prj.Initialize.\n-\n-   type Attribute_Kind is (\n-      Unknown,\n-      --  The attribute does not exist\n-\n-      Single,\n-      --  Single variable attribute (not an associative array)\n-\n-      Associative_Array,\n-      --  Associative array attribute with a case sensitive index\n-\n-      Optional_Index_Associative_Array,\n-      --  Associative array attribute with a case sensitive index and an\n-      --  optional source index.\n-\n-      Case_Insensitive_Associative_Array,\n-      --  Associative array attribute with a case insensitive index\n-\n-      Optional_Index_Case_Insensitive_Associative_Array\n-      --  Associative array attribute with a case insensitive index and an\n-      --  optional source index.\n-   );\n-   --  Characteristics of an attribute. Optional_Index indicates that there\n-   --  may be an optional index in the index of the associative array, as in\n-   --     for Switches (\"files.ada\" at 2) use ...\n-\n-   subtype Defined_Attribute_Kind is Attribute_Kind\n-     range Single .. Optional_Index_Case_Insensitive_Associative_Array;\n-   --  Subset of Attribute_Kinds that may be used for the attributes that is\n-   --  used when defining a new package.\n-\n-   subtype All_Case_Insensitive_Associative_Array is Attribute_Kind range\n-     Case_Insensitive_Associative_Array ..\n-     Optional_Index_Case_Insensitive_Associative_Array;\n-   --  Subtype including both cases of Case_Insensitive_Associative_Array\n-\n-   Max_Attribute_Name_Length : constant := 64;\n-   --  The maximum length of attribute names\n-\n-   subtype Attribute_Name_Length is\n-     Positive range 1 .. Max_Attribute_Name_Length;\n-\n-   type Attribute_Data (Name_Length : Attribute_Name_Length := 1) is record\n-      Name : String (1 .. Name_Length);\n-      pragma Warnings (Off, Name);  --  Reorder it instead???\n-      --  The name of the attribute\n-\n-      Attr_Kind  : Defined_Attribute_Kind;\n-      --  The type of the attribute\n-\n-      Index_Is_File_Name : Boolean;\n-      --  For associative arrays, indicate if the index is a file name, so\n-      --  that the attribute kind may be modified depending on the case\n-      --  sensitivity of file names. This is only taken into account when\n-      --  Attr_Kind is Associative_Array or Optional_Index_Associative_Array.\n-\n-      Opt_Index : Boolean;\n-      --  True if there may be an optional index in the value of the index,\n-      --  as in:\n-      --    \"file.ada\" at 2\n-      --    (\"main.adb\", \"file.ada\" at 1)\n-\n-      Var_Kind : Defined_Variable_Kind;\n-      --  The attribute value kind: single or list\n-\n-      Default : Attribute_Default_Value := Empty_Value;\n-      --  The value of the attribute when referenced if the attribute has not\n-      --  yet been declared.\n-\n-   end record;\n-   --  Name and characteristics of an attribute in a package registered\n-   --  explicitly with Register_New_Package (see below).\n-\n-   type Attribute_Data_Array is array (Positive range <>) of Attribute_Data;\n-   --  A list of attribute name/characteristics to be used as parameter of\n-   --  procedure Register_New_Package below.\n-\n-   --  In the subprograms below, when it is specified that the subprogram\n-   --  \"fails\", procedure Prj.Com.Fail is called. Unless it is specified\n-   --  otherwise, if Prj.Com.Fail returns, exception Prj.Prj_Error is raised.\n-\n-   procedure Register_New_Package\n-     (Name       : String;\n-      Attributes : Attribute_Data_Array);\n-   --  Add a new package with its attributes. This procedure can only be\n-   --  called after Initialize, but before any other call to a service of\n-   --  the Project Manager. Fail if the name of the package is empty or not\n-   --  unique, or if the names of the attributes are not different.\n-\n-   ----------------\n-   -- Attributes --\n-   ----------------\n-\n-   type Attribute_Node_Id is private;\n-   --  The type to refers to an attribute, self-initialized\n-\n-   Empty_Attribute : constant Attribute_Node_Id;\n-   --  Indicates no attribute. Default value of Attribute_Node_Id objects\n-\n-   Attribute_First : constant Attribute_Node_Id;\n-   --  First attribute node id of project level attributes\n-\n-   function Attribute_Node_Id_Of\n-     (Name        : Name_Id;\n-      Starting_At : Attribute_Node_Id) return Attribute_Node_Id;\n-   --  Returns the node id of an attribute at the project level or in\n-   --  a package. Starting_At indicates the first known attribute node where\n-   --  to start the search. Returns Empty_Attribute if the attribute cannot\n-   --  be found.\n-\n-   function Attribute_Kind_Of\n-     (Attribute : Attribute_Node_Id) return Attribute_Kind;\n-   --  Returns the attribute kind of a known attribute. Returns Unknown if\n-   --  Attribute is Empty_Attribute.\n-   --\n-   --  To use this function, the following code should be used:\n-   --\n-   --      Pkg : constant Package_Node_Id :=\n-   --              Prj.Attr.Package_Node_Id_Of (Name => <package name>);\n-   --      Att : constant Attribute_Node_Id :=\n-   --              Prj.Attr.Attribute_Node_Id_Of\n-   --                (Name        => <attribute name>,\n-   --                 Starting_At => First_Attribute_Of (Pkg));\n-   --      Kind : constant Attribute_Kind := Attribute_Kind_Of (Att);\n-   --\n-   --  However, do not use this function once you have an already parsed\n-   --  project tree. Instead, given a Project_Node_Id corresponding to the\n-   --  attribute declaration (\"for Attr (index) use ...\"), use for example:\n-   --\n-   --      if Case_Insensitive (Attr, Tree) then ...\n-\n-   procedure Set_Attribute_Kind_Of\n-     (Attribute : Attribute_Node_Id;\n-      To        : Attribute_Kind);\n-   --  Set the attribute kind of a known attribute. Does nothing if\n-   --  Attribute is Empty_Attribute.\n-\n-   function Attribute_Name_Of (Attribute : Attribute_Node_Id) return Name_Id;\n-   --  Returns the name of a known attribute. Returns No_Name if Attribute is\n-   --  Empty_Attribute.\n-\n-   function Variable_Kind_Of\n-     (Attribute : Attribute_Node_Id) return Variable_Kind;\n-   --  Returns the variable kind of a known attribute. Returns Undefined if\n-   --  Attribute is Empty_Attribute.\n-\n-   procedure Set_Variable_Kind_Of\n-     (Attribute : Attribute_Node_Id;\n-      To        : Variable_Kind);\n-   --  Set the variable kind of a known attribute. Does nothing if Attribute is\n-   --  Empty_Attribute.\n-\n-   function Attribute_Default_Of\n-     (Attribute : Attribute_Node_Id) return Attribute_Default_Value;\n-   --  Returns the default of the attribute, Read_Only_Value for read only\n-   --  attributes, Empty_Value when default not specified, or specified value.\n-\n-   function Optional_Index_Of (Attribute : Attribute_Node_Id) return Boolean;\n-   --  Returns True if Attribute is a known attribute and may have an\n-   --  optional index. Returns False otherwise.\n-\n-   function Is_Read_Only (Attribute : Attribute_Node_Id) return Boolean;\n-\n-   function Next_Attribute\n-     (After : Attribute_Node_Id) return Attribute_Node_Id;\n-   --  Returns the attribute that follow After in the list of project level\n-   --  attributes or the list of attributes in a package.\n-   --  Returns Empty_Attribute if After is either Empty_Attribute or is the\n-   --  last of the list.\n-\n-   function Others_Allowed_For (Attribute : Attribute_Node_Id) return Boolean;\n-   --  True iff the index for an associative array attributes may be others\n-\n-   --------------\n-   -- Packages --\n-   --------------\n-\n-   type Package_Node_Id is private;\n-   --  Type to refer to a package, self initialized\n-\n-   Empty_Package : constant Package_Node_Id;\n-   --  Default value of Package_Node_Id objects\n-\n-   Unknown_Package : constant Package_Node_Id;\n-   --  Value of an unknown package that has been found but is unknown\n-\n-   procedure Register_New_Package (Name : String; Id : out Package_Node_Id);\n-   --  Add a new package. Fails if Name (the package name) is empty or is\n-   --  already the name of a package, and set Id to Empty_Package,\n-   --  if Prj.Com.Fail returns. Initially, the new package has no attributes.\n-   --  Id may be used to add attributes using procedure Register_New_Attribute\n-   --  below.\n-\n-   procedure Register_New_Attribute\n-     (Name               : String;\n-      In_Package         : Package_Node_Id;\n-      Attr_Kind          : Defined_Attribute_Kind;\n-      Var_Kind           : Defined_Variable_Kind;\n-      Index_Is_File_Name : Boolean                 := False;\n-      Opt_Index          : Boolean                 := False;\n-      Default            : Attribute_Default_Value := Empty_Value);\n-   --  Add a new attribute to registered package In_Package. Fails if Name\n-   --  (the attribute name) is empty, if In_Package is Empty_Package or if\n-   --  the attribute name has a duplicate name. See definition of type\n-   --  Attribute_Data above for the meaning of parameters Attr_Kind, Var_Kind,\n-   --  Index_Is_File_Name, Opt_Index, and Default.\n-\n-   function Package_Node_Id_Of (Name : Name_Id) return Package_Node_Id;\n-   --  Returns the package node id of the package with name Name. Returns\n-   --  Empty_Package if there is no package with this name.\n-\n-   function First_Attribute_Of\n-     (Pkg : Package_Node_Id) return Attribute_Node_Id;\n-   --  Returns the first attribute in the list of attributes of package Pkg.\n-   --  Returns Empty_Attribute if Pkg is Empty_Package or Unknown_Package.\n-\n-private\n-   ----------------\n-   -- Attributes --\n-   ----------------\n-\n-   Attributes_Initial   : constant := 50;\n-   Attributes_Increment : constant := 100;\n-\n-   Attribute_Node_Low_Bound  : constant := 0;\n-   Attribute_Node_High_Bound : constant := 099_999_999;\n-\n-   type Attr_Node_Id is\n-     range Attribute_Node_Low_Bound .. Attribute_Node_High_Bound;\n-   --  Index type for table Attrs in the body\n-\n-   type Attribute_Node_Id is record\n-      Value : Attr_Node_Id := Attribute_Node_Low_Bound;\n-   end record;\n-   --  Full declaration of self-initialized private type\n-\n-   Empty_Attr : constant Attr_Node_Id := Attribute_Node_Low_Bound;\n-\n-   Empty_Attribute : constant Attribute_Node_Id := (Value => Empty_Attr);\n-\n-   First_Attribute : constant Attr_Node_Id := Attribute_Node_Low_Bound + 1;\n-\n-   First_Attribute_Node_Id : constant Attribute_Node_Id :=\n-                               (Value => First_Attribute);\n-\n-   Attribute_First : constant Attribute_Node_Id := First_Attribute_Node_Id;\n-\n-   --------------\n-   -- Packages --\n-   --------------\n-\n-   Packages_Initial   : constant := 10;\n-   Packages_Increment : constant := 100;\n-\n-   Package_Node_Low_Bound  : constant := 0;\n-   Package_Node_High_Bound : constant := 099_999_999;\n-\n-   type Pkg_Node_Id is\n-     range Package_Node_Low_Bound .. Package_Node_High_Bound;\n-   --  Index type for table Package_Attributes in the body\n-\n-   type Package_Node_Id is record\n-      Value : Pkg_Node_Id := Package_Node_Low_Bound;\n-   end record;\n-   --  Full declaration of self-initialized private type\n-\n-   Empty_Pkg       : constant Pkg_Node_Id     := Package_Node_Low_Bound;\n-   Empty_Package   : constant Package_Node_Id := (Value => Empty_Pkg);\n-   Unknown_Pkg     : constant Pkg_Node_Id     := Package_Node_High_Bound;\n-   Unknown_Package : constant Package_Node_Id := (Value => Unknown_Pkg);\n-   First_Package   : constant Pkg_Node_Id     := Package_Node_Low_Bound + 1;\n-\n-   First_Package_Node_Id  : constant Package_Node_Id :=\n-                              (Value => First_Package);\n-\n-   Package_First : constant Package_Node_Id := First_Package_Node_Id;\n-\n-   ----------------\n-   -- Attributes --\n-   ----------------\n-\n-   type Attribute_Record is record\n-      Name           : Name_Id;\n-      Var_Kind       : Variable_Kind;\n-      Optional_Index : Boolean;\n-      Attr_Kind      : Attribute_Kind;\n-      Read_Only      : Boolean;\n-      Others_Allowed : Boolean;\n-      Default        : Attribute_Default_Value;\n-      Next           : Attr_Node_Id;\n-   end record;\n-   --  Data for an attribute\n-\n-   package Attrs is\n-      new Table.Table (Table_Component_Type => Attribute_Record,\n-                       Table_Index_Type     => Attr_Node_Id,\n-                       Table_Low_Bound      => First_Attribute,\n-                       Table_Initial        => Attributes_Initial,\n-                       Table_Increment      => Attributes_Increment,\n-                       Table_Name           => \"Prj.Attr.Attrs\");\n-   --  The table of the attributes\n-\n-   --------------\n-   -- Packages --\n-   --------------\n-\n-   type Package_Record is record\n-      Name             : Name_Id;\n-      Known            : Boolean := True;\n-      First_Attribute  : Attr_Node_Id;\n-   end record;\n-   --  Data for a package\n-\n-   package Package_Attributes is\n-      new Table.Table (Table_Component_Type => Package_Record,\n-                       Table_Index_Type     => Pkg_Node_Id,\n-                       Table_Low_Bound      => First_Package,\n-                       Table_Initial        => Packages_Initial,\n-                       Table_Increment      => Packages_Increment,\n-                       Table_Name           => \"Prj.Attr.Packages\");\n-   --  The table of the packages\n-\n-end Prj.Attr;"}, {"sha": "f5f2fa689f97da2da646c84506fb9f0bc830ed09", "filename": "gcc/ada/prj-com.ads", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-com.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-com.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-com.ads?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793", "patch": "@@ -1,40 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                              P R J . C O M                               --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---          Copyright (C) 2000-2008, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  The following package declares a Fail procedure that is used in the\n---  Project Manager.\n-\n-with Osint;\n-\n-package Prj.Com is\n-\n-   type Fail_Proc is access procedure (S : String);\n-\n-   Fail : Fail_Proc := Osint.Fail'Access;\n-   --  This procedure is used in the project facility, instead of directly\n-   --  calling Osint.Fail. It may be specified by tools to do clean up before\n-   --  calling Osint.Fail, or to simply report an error and return.\n-\n-end Prj.Com;"}, {"sha": "e48b7fba016800f94f03b220de6df5e27ec0dfde", "filename": "gcc/ada/prj-conf.adb", "status": "removed", "additions": 0, "deletions": 2314, "changes": 2314, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-conf.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-conf.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-conf.adb?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793", "patch": "@@ -1,2314 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                             P R J . C O N F                              --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---            Copyright (C) 2006-2015, Free Software Foundation, Inc.       --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-with Makeutl;  use Makeutl;\n-with MLib.Tgt;\n-with Opt;      use Opt;\n-with Output;   use Output;\n-with Prj.Env;\n-with Prj.Err;\n-with Prj.Part;\n-with Prj.PP;\n-with Prj.Proc; use Prj.Proc;\n-with Prj.Tree; use Prj.Tree;\n-with Prj.Util; use Prj.Util;\n-with Prj;      use Prj;\n-with Snames;   use Snames;\n-\n-with Ada.Directories; use Ada.Directories;\n-with Ada.Exceptions;  use Ada.Exceptions;\n-\n-with GNAT.Case_Util; use GNAT.Case_Util;\n-with GNAT.HTable;    use GNAT.HTable;\n-\n-package body Prj.Conf is\n-\n-   Auto_Cgpr : constant String := \"auto.cgpr\";\n-\n-   Config_Project_Env_Var : constant String := \"GPR_CONFIG\";\n-   --  Name of the environment variable that provides the name of the\n-   --  configuration file to use.\n-\n-   Gprconfig_Name : constant String := \"gprconfig\";\n-\n-   Warn_For_RTS : Boolean := True;\n-   --  Set to False when gprbuild parse again the project files, to avoid\n-   --  an incorrect warning.\n-\n-   type Runtime_Root_Data;\n-   type Runtime_Root_Ptr is access Runtime_Root_Data;\n-   type Runtime_Root_Data is record\n-      Root : String_Access;\n-      Next : Runtime_Root_Ptr;\n-   end record;\n-   --  Data for a runtime root to be used when adding directories to the\n-   --  project path.\n-\n-   type Compiler_Root_Data;\n-   type Compiler_Root_Ptr is access Compiler_Root_Data;\n-   type Compiler_Root_Data is record\n-      Root : String_Access;\n-      Runtimes : Runtime_Root_Ptr;\n-      Next     : Compiler_Root_Ptr;\n-   end record;\n-   --  Data for a compiler root to be used when adding directories to the\n-   --  project path.\n-\n-   First_Compiler_Root : Compiler_Root_Ptr := null;\n-   --  Head of the list of compiler roots\n-\n-   package RTS_Languages is new GNAT.HTable.Simple_HTable\n-     (Header_Num => Prj.Header_Num,\n-      Element    => Name_Id,\n-      No_Element => No_Name,\n-      Key        => Name_Id,\n-      Hash       => Prj.Hash,\n-      Equal      => \"=\");\n-   --  Stores the runtime names for the various languages. This is in general\n-   --  set from a --RTS command line option.\n-\n-   -----------------------\n-   -- Local_Subprograms --\n-   -----------------------\n-\n-   function Check_Target\n-     (Config_File        : Prj.Project_Id;\n-      Autoconf_Specified : Boolean;\n-      Project_Tree       : Prj.Project_Tree_Ref;\n-      Target             : String := \"\") return Boolean;\n-   --  Check that the config file's target matches Target.\n-   --  Target should be set to the empty string when the user did not specify\n-   --  a target. If the target in the configuration file is invalid, this\n-   --  function will raise Invalid_Config with an appropriate message.\n-   --  Autoconf_Specified should be set to True if the user has used\n-   --  autoconf.\n-\n-   function Locate_Config_File (Name : String) return String_Access;\n-   --  Search for Name in the config files directory. Return full path if\n-   --  found, or null otherwise.\n-\n-   procedure Raise_Invalid_Config (Msg : String);\n-   pragma No_Return (Raise_Invalid_Config);\n-   --  Raises exception Invalid_Config with given message\n-\n-   procedure Apply_Config_File\n-     (Config_File  : Prj.Project_Id;\n-      Project_Tree : Prj.Project_Tree_Ref);\n-   --  Apply the configuration file settings to all the projects in the\n-   --  project tree. The Project_Tree must have been parsed first, and\n-   --  processed through the first phase so that all its projects are known.\n-   --\n-   --  Currently, this will add new attributes and packages in the various\n-   --  projects, so that when the second phase of the processing is performed\n-   --  these attributes are automatically taken into account.\n-\n-   type State is (No_State);\n-\n-   procedure Look_For_Project_Paths\n-     (Project    : Project_Id;\n-      Tree       : Project_Tree_Ref;\n-      With_State : in out State);\n-   --  Check the compilers in the Project and add record them in the list\n-   --  rooted at First_Compiler_Root, with their runtimes, if they are not\n-   --  already in the list.\n-\n-   procedure Update_Project_Path is new\n-     For_Every_Project_Imported\n-       (State  => State,\n-        Action => Look_For_Project_Paths);\n-\n-   ------------------------------------\n-   -- Add_Default_GNAT_Naming_Scheme --\n-   ------------------------------------\n-\n-   procedure Add_Default_GNAT_Naming_Scheme\n-     (Config_File  : in out Project_Node_Id;\n-      Project_Tree : Project_Node_Tree_Ref)\n-   is\n-      procedure Create_Attribute\n-        (Name  : Name_Id;\n-         Value : String;\n-         Index : String := \"\";\n-         Pkg   : Project_Node_Id := Empty_Node);\n-\n-      ----------------------\n-      -- Create_Attribute --\n-      ----------------------\n-\n-      procedure Create_Attribute\n-        (Name  : Name_Id;\n-         Value : String;\n-         Index : String := \"\";\n-         Pkg   : Project_Node_Id := Empty_Node)\n-      is\n-         Attr : Project_Node_Id;\n-         pragma Unreferenced (Attr);\n-\n-         Expr   : Name_Id         := No_Name;\n-         Val    : Name_Id         := No_Name;\n-         Parent : Project_Node_Id := Config_File;\n-\n-      begin\n-         if Index /= \"\" then\n-            Name_Len := Index'Length;\n-            Name_Buffer (1 .. Name_Len) := Index;\n-            Val := Name_Find;\n-         end if;\n-\n-         if Pkg /= Empty_Node then\n-            Parent := Pkg;\n-         end if;\n-\n-         Name_Len := Value'Length;\n-         Name_Buffer (1 .. Name_Len) := Value;\n-         Expr := Name_Find;\n-\n-         Attr := Create_Attribute\n-           (Tree       => Project_Tree,\n-            Prj_Or_Pkg => Parent,\n-            Name       => Name,\n-            Index_Name => Val,\n-            Kind       => Prj.Single,\n-            Value      => Create_Literal_String (Expr, Project_Tree));\n-      end Create_Attribute;\n-\n-      --  Local variables\n-\n-      Name     : Name_Id;\n-      Naming   : Project_Node_Id;\n-      Compiler : Project_Node_Id;\n-\n-   --  Start of processing for Add_Default_GNAT_Naming_Scheme\n-\n-   begin\n-      if Config_File = Empty_Node then\n-\n-         --  Create a dummy config file if none was found\n-\n-         Name_Len := Auto_Cgpr'Length;\n-         Name_Buffer (1 .. Name_Len) := Auto_Cgpr;\n-         Name := Name_Find;\n-\n-         --  An invalid project name to avoid conflicts with user-created ones\n-\n-         Name_Len := 5;\n-         Name_Buffer (1 .. Name_Len) := \"_auto\";\n-\n-         Config_File :=\n-           Create_Project\n-             (In_Tree        => Project_Tree,\n-              Name           => Name_Find,\n-              Full_Path      => Path_Name_Type (Name),\n-              Is_Config_File => True);\n-\n-         --  Setup library support\n-\n-         case MLib.Tgt.Support_For_Libraries is\n-            when None =>\n-               null;\n-\n-            when Static_Only =>\n-               Create_Attribute (Name_Library_Support, \"static_only\");\n-\n-            when Full =>\n-               Create_Attribute (Name_Library_Support, \"full\");\n-         end case;\n-\n-         if MLib.Tgt.Standalone_Library_Auto_Init_Is_Supported then\n-            Create_Attribute (Name_Library_Auto_Init_Supported, \"true\");\n-         else\n-            Create_Attribute (Name_Library_Auto_Init_Supported, \"false\");\n-         end if;\n-\n-         --  Declare an empty target\n-\n-         Create_Attribute (Name_Target, \"\");\n-\n-         --  Setup Ada support (Ada is the default language here, since this\n-         --  is only called when no config file existed initially, ie for\n-         --  gnatmake).\n-\n-         Create_Attribute (Name_Default_Language, \"ada\");\n-\n-         Compiler := Create_Package (Project_Tree, Config_File, \"compiler\");\n-         Create_Attribute\n-           (Name_Driver, \"gcc\", \"ada\", Pkg => Compiler);\n-         Create_Attribute\n-           (Name_Language_Kind, \"unit_based\", \"ada\", Pkg => Compiler);\n-         Create_Attribute\n-           (Name_Dependency_Kind, \"ALI_File\", \"ada\", Pkg => Compiler);\n-\n-         Naming := Create_Package (Project_Tree, Config_File, \"naming\");\n-         Create_Attribute (Name_Spec_Suffix, \".ads\", \"ada\",     Pkg => Naming);\n-         Create_Attribute (Name_Separate_Suffix, \".adb\", \"ada\", Pkg => Naming);\n-         Create_Attribute (Name_Body_Suffix, \".adb\", \"ada\",     Pkg => Naming);\n-         Create_Attribute (Name_Dot_Replacement, \"-\",           Pkg => Naming);\n-         Create_Attribute (Name_Casing,          \"lowercase\",   Pkg => Naming);\n-\n-         if Current_Verbosity = High then\n-            Write_Line (\"Automatically generated (in-memory) config file\");\n-            Prj.PP.Pretty_Print\n-              (Project                => Config_File,\n-               In_Tree                => Project_Tree,\n-               Backward_Compatibility => False);\n-         end if;\n-      end if;\n-   end Add_Default_GNAT_Naming_Scheme;\n-\n-   -----------------------\n-   -- Apply_Config_File --\n-   -----------------------\n-\n-   procedure Apply_Config_File\n-     (Config_File  : Prj.Project_Id;\n-      Project_Tree : Prj.Project_Tree_Ref)\n-   is\n-      procedure Add_Attributes\n-        (Project_Tree : Project_Tree_Ref;\n-         Conf_Decl    : Declarations;\n-         User_Decl    : in out Declarations);\n-      --  Process the attributes in the config declarations.  For\n-      --  single string values, if the attribute is not declared in\n-      --  the user declarations, declare it with the value in the\n-      --  config declarations.  For string list values, prepend the\n-      --  value in the user declarations with the value in the config\n-      --  declarations.\n-\n-      --------------------\n-      -- Add_Attributes --\n-      --------------------\n-\n-      procedure Add_Attributes\n-        (Project_Tree : Project_Tree_Ref;\n-         Conf_Decl    : Declarations;\n-         User_Decl    : in out Declarations)\n-      is\n-         Shared             : constant Shared_Project_Tree_Data_Access :=\n-                                Project_Tree.Shared;\n-         Conf_Attr_Id       : Variable_Id;\n-         Conf_Attr          : Variable;\n-         Conf_Array_Id      : Array_Id;\n-         Conf_Array         : Array_Data;\n-         Conf_Array_Elem_Id : Array_Element_Id;\n-         Conf_Array_Elem    : Array_Element;\n-         Conf_List          : String_List_Id;\n-         Conf_List_Elem     : String_Element;\n-\n-         User_Attr_Id       : Variable_Id;\n-         User_Attr          : Variable;\n-         User_Array_Id      : Array_Id;\n-         User_Array         : Array_Data;\n-         User_Array_Elem_Id : Array_Element_Id;\n-         User_Array_Elem    : Array_Element;\n-\n-      begin\n-         Conf_Attr_Id := Conf_Decl.Attributes;\n-         User_Attr_Id := User_Decl.Attributes;\n-\n-         while Conf_Attr_Id /= No_Variable loop\n-            Conf_Attr := Shared.Variable_Elements.Table (Conf_Attr_Id);\n-            User_Attr := Shared.Variable_Elements.Table (User_Attr_Id);\n-\n-            if not Conf_Attr.Value.Default then\n-               if User_Attr.Value.Default then\n-\n-                  --  No attribute declared in user project file: just copy\n-                  --  the value of the configuration attribute.\n-\n-                  User_Attr.Value := Conf_Attr.Value;\n-                  Shared.Variable_Elements.Table (User_Attr_Id) := User_Attr;\n-\n-               elsif User_Attr.Value.Kind = List\n-                 and then Conf_Attr.Value.Values /= Nil_String\n-               then\n-                  --  List attribute declared in both the user project and the\n-                  --  configuration project: prepend the user list with the\n-                  --  configuration list.\n-\n-                  declare\n-                     User_List : constant String_List_Id :=\n-                                   User_Attr.Value.Values;\n-                     Conf_List : String_List_Id := Conf_Attr.Value.Values;\n-                     Conf_Elem : String_Element;\n-                     New_List  : String_List_Id;\n-                     New_Elem  : String_Element;\n-\n-                  begin\n-                     --  Create new list\n-\n-                     String_Element_Table.Increment_Last\n-                       (Shared.String_Elements);\n-                     New_List :=\n-                       String_Element_Table.Last (Shared.String_Elements);\n-\n-                     --  Value of attribute is new list\n-\n-                     User_Attr.Value.Values := New_List;\n-                     Shared.Variable_Elements.Table (User_Attr_Id) :=\n-                       User_Attr;\n-\n-                     loop\n-                        --  Get each element of configuration list\n-\n-                        Conf_Elem := Shared.String_Elements.Table (Conf_List);\n-                        New_Elem  := Conf_Elem;\n-                        Conf_List := Conf_Elem.Next;\n-\n-                        if Conf_List = Nil_String then\n-\n-                           --  If it is the last element in the list, connect\n-                           --  to first element of user list, and we are done.\n-\n-                           New_Elem.Next := User_List;\n-                           Shared.String_Elements.Table (New_List) := New_Elem;\n-                           exit;\n-\n-                        else\n-                           --  If it is not the last element in the list, add\n-                           --  to new list.\n-\n-                           String_Element_Table.Increment_Last\n-                             (Shared.String_Elements);\n-                           New_Elem.Next := String_Element_Table.Last\n-                             (Shared.String_Elements);\n-                           Shared.String_Elements.Table (New_List) := New_Elem;\n-                           New_List := New_Elem.Next;\n-                        end if;\n-                     end loop;\n-                  end;\n-               end if;\n-            end if;\n-\n-            Conf_Attr_Id := Conf_Attr.Next;\n-            User_Attr_Id := User_Attr.Next;\n-         end loop;\n-\n-         Conf_Array_Id := Conf_Decl.Arrays;\n-         while Conf_Array_Id /= No_Array loop\n-            Conf_Array := Shared.Arrays.Table (Conf_Array_Id);\n-\n-            User_Array_Id := User_Decl.Arrays;\n-            while User_Array_Id /= No_Array loop\n-               User_Array := Shared.Arrays.Table (User_Array_Id);\n-               exit when User_Array.Name = Conf_Array.Name;\n-               User_Array_Id := User_Array.Next;\n-            end loop;\n-\n-            --  If this associative array does not exist in the user project\n-            --  file, do a shallow copy of the full associative array.\n-\n-            if User_Array_Id = No_Array then\n-               Array_Table.Increment_Last (Shared.Arrays);\n-               User_Array := Conf_Array;\n-               User_Array.Next := User_Decl.Arrays;\n-               User_Decl.Arrays := Array_Table.Last (Shared.Arrays);\n-               Shared.Arrays.Table (User_Decl.Arrays) := User_Array;\n-\n-            --  Otherwise, check each array element\n-\n-            else\n-               Conf_Array_Elem_Id := Conf_Array.Value;\n-               while Conf_Array_Elem_Id /= No_Array_Element loop\n-                  Conf_Array_Elem :=\n-                    Shared.Array_Elements.Table (Conf_Array_Elem_Id);\n-\n-                  User_Array_Elem_Id := User_Array.Value;\n-                  while User_Array_Elem_Id /= No_Array_Element loop\n-                     User_Array_Elem :=\n-                       Shared.Array_Elements.Table (User_Array_Elem_Id);\n-                     exit when User_Array_Elem.Index = Conf_Array_Elem.Index;\n-                     User_Array_Elem_Id := User_Array_Elem.Next;\n-                  end loop;\n-\n-                  --  If the array element doesn't exist in the user array,\n-                  --  insert a shallow copy of the conf array element in the\n-                  --  user array.\n-\n-                  if User_Array_Elem_Id = No_Array_Element then\n-                     Array_Element_Table.Increment_Last\n-                       (Shared.Array_Elements);\n-                     User_Array_Elem := Conf_Array_Elem;\n-                     User_Array_Elem.Next := User_Array.Value;\n-                     User_Array.Value :=\n-                       Array_Element_Table.Last (Shared.Array_Elements);\n-                     Shared.Array_Elements.Table (User_Array.Value) :=\n-                       User_Array_Elem;\n-                     Shared.Arrays.Table (User_Array_Id) := User_Array;\n-\n-                  --  Otherwise, if the value is a string list, prepend the\n-                  --  conf array element value to the array element.\n-\n-                  elsif Conf_Array_Elem.Value.Kind = List then\n-                     Conf_List := Conf_Array_Elem.Value.Values;\n-\n-                     if Conf_List /= Nil_String then\n-                        declare\n-                           Link     : constant String_List_Id :=\n-                                        User_Array_Elem.Value.Values;\n-                           Previous : String_List_Id := Nil_String;\n-                           Next     : String_List_Id;\n-\n-                        begin\n-                           loop\n-                              Conf_List_Elem :=\n-                                Shared.String_Elements.Table (Conf_List);\n-                              String_Element_Table.Increment_Last\n-                                (Shared.String_Elements);\n-                              Next :=\n-                                String_Element_Table.Last\n-                                (Shared.String_Elements);\n-                              Shared.String_Elements.Table (Next) :=\n-                                Conf_List_Elem;\n-\n-                              if Previous = Nil_String then\n-                                 User_Array_Elem.Value.Values := Next;\n-                                 Shared.Array_Elements.Table\n-                                   (User_Array_Elem_Id) := User_Array_Elem;\n-\n-                              else\n-                                 Shared.String_Elements.Table\n-                                   (Previous).Next := Next;\n-                              end if;\n-\n-                              Previous := Next;\n-\n-                              Conf_List := Conf_List_Elem.Next;\n-\n-                              if Conf_List = Nil_String then\n-                                 Shared.String_Elements.Table\n-                                   (Previous).Next := Link;\n-                                 exit;\n-                              end if;\n-                           end loop;\n-                        end;\n-                     end if;\n-                  end if;\n-\n-                  Conf_Array_Elem_Id := Conf_Array_Elem.Next;\n-               end loop;\n-            end if;\n-\n-            Conf_Array_Id := Conf_Array.Next;\n-         end loop;\n-      end Add_Attributes;\n-\n-      Shared : constant Shared_Project_Tree_Data_Access := Project_Tree.Shared;\n-\n-      Conf_Decl    : constant Declarations := Config_File.Decl;\n-      Conf_Pack_Id : Package_Id;\n-      Conf_Pack    : Package_Element;\n-\n-      User_Decl    : Declarations;\n-      User_Pack_Id : Package_Id;\n-      User_Pack    : Package_Element;\n-      Proj         : Project_List;\n-\n-   begin\n-      Debug_Output (\"Applying config file to a project tree\");\n-\n-      Proj := Project_Tree.Projects;\n-      while Proj /= null loop\n-         if Proj.Project /= Config_File then\n-            User_Decl := Proj.Project.Decl;\n-            Add_Attributes\n-              (Project_Tree => Project_Tree,\n-               Conf_Decl    => Conf_Decl,\n-               User_Decl    => User_Decl);\n-\n-            Conf_Pack_Id := Conf_Decl.Packages;\n-            while Conf_Pack_Id /= No_Package loop\n-               Conf_Pack := Shared.Packages.Table (Conf_Pack_Id);\n-\n-               User_Pack_Id := User_Decl.Packages;\n-               while User_Pack_Id /= No_Package loop\n-                  User_Pack := Shared.Packages.Table (User_Pack_Id);\n-                  exit when User_Pack.Name = Conf_Pack.Name;\n-                  User_Pack_Id := User_Pack.Next;\n-               end loop;\n-\n-               if User_Pack_Id = No_Package then\n-                  Package_Table.Increment_Last (Shared.Packages);\n-                  User_Pack := Conf_Pack;\n-                  User_Pack.Next := User_Decl.Packages;\n-                  User_Decl.Packages := Package_Table.Last (Shared.Packages);\n-                  Shared.Packages.Table (User_Decl.Packages) := User_Pack;\n-\n-               else\n-                  Add_Attributes\n-                    (Project_Tree => Project_Tree,\n-                     Conf_Decl    => Conf_Pack.Decl,\n-                     User_Decl    => Shared.Packages.Table\n-                                       (User_Pack_Id).Decl);\n-               end if;\n-\n-               Conf_Pack_Id := Conf_Pack.Next;\n-            end loop;\n-\n-            Proj.Project.Decl := User_Decl;\n-\n-            --  For aggregate projects, we need to apply the config to all\n-            --  their aggregated trees as well.\n-\n-            if Proj.Project.Qualifier in Aggregate_Project then\n-               declare\n-                  List : Aggregated_Project_List;\n-               begin\n-                  List := Proj.Project.Aggregated_Projects;\n-                  while List /= null loop\n-                     Debug_Output\n-                       (\"Recursively apply config to aggregated tree\",\n-                        List.Project.Name);\n-                     Apply_Config_File\n-                       (Config_File, Project_Tree => List.Tree);\n-                     List := List.Next;\n-                  end loop;\n-               end;\n-            end if;\n-         end if;\n-\n-         Proj := Proj.Next;\n-      end loop;\n-   end Apply_Config_File;\n-\n-   ------------------\n-   -- Check_Target --\n-   ------------------\n-\n-   function Check_Target\n-     (Config_File        : Project_Id;\n-      Autoconf_Specified : Boolean;\n-      Project_Tree       : Prj.Project_Tree_Ref;\n-      Target             : String := \"\") return Boolean\n-   is\n-      Shared   : constant Shared_Project_Tree_Data_Access :=\n-                   Project_Tree.Shared;\n-      Variable : constant Variable_Value :=\n-                   Value_Of\n-                     (Name_Target, Config_File.Decl.Attributes, Shared);\n-      Tgt_Name : Name_Id := No_Name;\n-      OK       : Boolean;\n-\n-   begin\n-      if Variable /= Nil_Variable_Value and then not Variable.Default then\n-         Tgt_Name := Variable.Value;\n-      end if;\n-\n-      OK :=\n-        Target = \"\"\n-          or else\n-            (Tgt_Name /= No_Name\n-              and then (Length_Of_Name (Tgt_Name) = 0\n-                         or else Target = Get_Name_String (Tgt_Name)));\n-\n-      if not OK then\n-         if Autoconf_Specified then\n-            if Verbose_Mode then\n-               Write_Line (\"inconsistent targets, performing autoconf\");\n-            end if;\n-\n-            return False;\n-\n-         else\n-            if Tgt_Name /= No_Name then\n-               Raise_Invalid_Config\n-                 (\"mismatched targets: \"\"\"\n-                  & Get_Name_String (Tgt_Name) & \"\"\" in configuration, \"\"\"\n-                  & Target & \"\"\" specified\");\n-            else\n-               Raise_Invalid_Config\n-                 (\"no target specified in configuration file\");\n-            end if;\n-         end if;\n-      end if;\n-\n-      return True;\n-   end Check_Target;\n-\n-   --------------------------------------\n-   -- Get_Or_Create_Configuration_File --\n-   --------------------------------------\n-\n-   procedure Get_Or_Create_Configuration_File\n-     (Project                    : Project_Id;\n-      Conf_Project               : Project_Id;\n-      Project_Tree               : Project_Tree_Ref;\n-      Project_Node_Tree          : Prj.Tree.Project_Node_Tree_Ref;\n-      Env                        : in out Prj.Tree.Environment;\n-      Allow_Automatic_Generation : Boolean;\n-      Config_File_Name           : String := \"\";\n-      Autoconf_Specified         : Boolean;\n-      Target_Name                : String := \"\";\n-      Normalized_Hostname        : String;\n-      Packages_To_Check          : String_List_Access := null;\n-      Config                     : out Prj.Project_Id;\n-      Config_File_Path           : out String_Access;\n-      Automatically_Generated    : out Boolean;\n-      On_Load_Config             : Config_File_Hook := null)\n-   is\n-      Shared : constant Shared_Project_Tree_Data_Access := Project_Tree.Shared;\n-\n-      At_Least_One_Compiler_Command : Boolean := False;\n-      --  Set to True if at least one attribute Ide'Compiler_Command is\n-      --  specified for one language of the system.\n-\n-      Conf_File_Name : String_Access := new String'(Config_File_Name);\n-      --  The configuration project file name. May be modified if there are\n-      --  switches --config= in the Builder package of the main project.\n-\n-      Selected_Target : String_Access := new String'(Target_Name);\n-\n-      function Default_File_Name return String;\n-      --  Return the name of the default config file that should be tested\n-\n-      procedure Do_Autoconf;\n-      --  Generate a new config file through gprconfig. In case of error, this\n-      --  raises the Invalid_Config exception with an appropriate message\n-\n-      procedure Check_Builder_Switches;\n-      --  Check for switches --config and --RTS in package Builder\n-\n-      procedure Get_Project_Target;\n-      --  If Target_Name is empty, get the specified target in the project\n-      --  file, if any.\n-\n-      procedure Get_Project_Runtimes;\n-      --  Get the various Runtime (<lang>) in the project file or any project\n-      --  it extends, if any are specified.\n-\n-      function Get_Config_Switches return Argument_List_Access;\n-      --  Return the --config switches to use for gprconfig\n-\n-      function Get_Db_Switches return Argument_List_Access;\n-      --  Return the --db switches to use for gprconfig\n-\n-      function Might_Have_Sources (Project : Project_Id) return Boolean;\n-      --  True if the specified project might have sources (ie the user has not\n-      --  explicitly specified it. We haven't checked the file system, nor do\n-      --  we need to at this stage.\n-\n-      ----------------------------\n-      -- Check_Builder_Switches --\n-      ----------------------------\n-\n-      procedure Check_Builder_Switches is\n-         Get_RTS_Switches : constant Boolean :=\n-                              RTS_Languages.Get_First = No_Name;\n-         --  If no switch --RTS have been specified on the command line, look\n-         --  for --RTS switches in the Builder switches.\n-\n-         Builder : constant Package_Id :=\n-                     Value_Of (Name_Builder, Project.Decl.Packages, Shared);\n-\n-         Switch_Array_Id : Array_Element_Id;\n-         --  The Switches to be checked\n-\n-         procedure Check_Switches;\n-         --  Check the switches in Switch_Array_Id\n-\n-         --------------------\n-         -- Check_Switches --\n-         --------------------\n-\n-         procedure Check_Switches is\n-            Switch_Array    : Array_Element;\n-            Switch_List     : String_List_Id := Nil_String;\n-            Switch          : String_Element;\n-            Lang            : Name_Id;\n-            Lang_Last       : Positive;\n-\n-         begin\n-            while Switch_Array_Id /= No_Array_Element loop\n-               Switch_Array :=\n-                 Shared.Array_Elements.Table (Switch_Array_Id);\n-\n-               Switch_List := Switch_Array.Value.Values;\n-               List_Loop : while Switch_List /= Nil_String loop\n-                  Switch := Shared.String_Elements.Table (Switch_List);\n-\n-                  if Switch.Value /= No_Name then\n-                     Get_Name_String (Switch.Value);\n-\n-                     if Conf_File_Name'Length = 0\n-                       and then Name_Len > 9\n-                       and then Name_Buffer (1 .. 9) = \"--config=\"\n-                     then\n-                        Conf_File_Name :=\n-                          new String'(Name_Buffer (10 .. Name_Len));\n-\n-                     elsif Get_RTS_Switches\n-                       and then Name_Len >= 7\n-                       and then Name_Buffer (1 .. 5) = \"--RTS\"\n-                     then\n-                        if Name_Buffer (6) = '=' then\n-                           if not Runtime_Name_Set_For (Name_Ada) then\n-                              Set_Runtime_For\n-                                (Name_Ada,\n-                                 Name_Buffer (7 .. Name_Len));\n-                           end if;\n-\n-                        elsif Name_Len > 7\n-                          and then Name_Buffer (6) = ':'\n-                          and then Name_Buffer (7) /= '='\n-                        then\n-                           Lang_Last := 7;\n-                           while Lang_Last < Name_Len\n-                             and then Name_Buffer (Lang_Last + 1) /= '='\n-                           loop\n-                              Lang_Last := Lang_Last + 1;\n-                           end loop;\n-\n-                           if Name_Buffer (Lang_Last + 1) = '=' then\n-                              declare\n-                                 RTS : constant String :=\n-                                   Name_Buffer (Lang_Last + 2 .. Name_Len);\n-                              begin\n-                                 Name_Buffer (1 .. Lang_Last - 6) :=\n-                                   Name_Buffer (7 .. Lang_Last);\n-                                 Name_Len := Lang_Last - 6;\n-                                 To_Lower (Name_Buffer (1 .. Name_Len));\n-                                 Lang := Name_Find;\n-\n-                                 if not Runtime_Name_Set_For (Lang) then\n-                                    Set_Runtime_For (Lang, RTS);\n-                                 end if;\n-                              end;\n-                           end if;\n-                        end if;\n-                     end if;\n-                  end if;\n-\n-                  Switch_List := Switch.Next;\n-               end loop List_Loop;\n-\n-               Switch_Array_Id := Switch_Array.Next;\n-            end loop;\n-         end Check_Switches;\n-\n-      --  Start of processing for Check_Builder_Switches\n-\n-      begin\n-         if Builder /= No_Package then\n-            Switch_Array_Id :=\n-              Value_Of\n-                (Name      => Name_Switches,\n-                 In_Arrays => Shared.Packages.Table (Builder).Decl.Arrays,\n-                 Shared    => Shared);\n-            Check_Switches;\n-\n-            Switch_Array_Id :=\n-              Value_Of\n-                (Name      => Name_Default_Switches,\n-                 In_Arrays => Shared.Packages.Table (Builder).Decl.Arrays,\n-                 Shared    => Shared);\n-            Check_Switches;\n-         end if;\n-      end Check_Builder_Switches;\n-\n-      ------------------------\n-      -- Get_Project_Target --\n-      ------------------------\n-\n-      procedure Get_Project_Target is\n-      begin\n-         if Selected_Target'Length = 0 then\n-\n-            --  Check if attribute Target is specified in the main\n-            --  project, or in a project it extends. If it is, use this\n-            --  target to invoke gprconfig.\n-\n-            declare\n-               Variable : Variable_Value;\n-               Proj     : Project_Id;\n-               Tgt_Name : Name_Id := No_Name;\n-\n-            begin\n-               Proj := Project;\n-               Project_Loop :\n-               while Proj /= No_Project loop\n-                  Variable :=\n-                    Value_Of (Name_Target, Proj.Decl.Attributes, Shared);\n-\n-                  if Variable /= Nil_Variable_Value\n-                    and then not Variable.Default\n-                    and then Variable.Value /= No_Name\n-                  then\n-                     Tgt_Name := Variable.Value;\n-                     exit Project_Loop;\n-                  end if;\n-\n-                  Proj := Proj.Extends;\n-               end loop Project_Loop;\n-\n-               if Tgt_Name /= No_Name then\n-                  Selected_Target := new String'(Get_Name_String (Tgt_Name));\n-               end if;\n-            end;\n-         end if;\n-      end Get_Project_Target;\n-\n-      --------------------------\n-      -- Get_Project_Runtimes --\n-      --------------------------\n-\n-      procedure Get_Project_Runtimes is\n-         Element : Array_Element;\n-         Id      : Array_Element_Id;\n-         Lang    : Name_Id;\n-         Proj    : Project_Id;\n-\n-      begin\n-         Proj := Project;\n-         while Proj /= No_Project loop\n-            Id := Value_Of (Name_Runtime, Proj.Decl.Arrays, Shared);\n-            while Id /= No_Array_Element loop\n-               Element := Shared.Array_Elements.Table (Id);\n-               Lang := Element.Index;\n-\n-               if not Runtime_Name_Set_For (Lang) then\n-                  Set_Runtime_For\n-                    (Lang, RTS_Name => Get_Name_String (Element.Value.Value));\n-               end if;\n-\n-               Id := Element.Next;\n-            end loop;\n-\n-            Proj := Proj.Extends;\n-         end loop;\n-      end Get_Project_Runtimes;\n-\n-      -----------------------\n-      -- Default_File_Name --\n-      -----------------------\n-\n-      function Default_File_Name return String is\n-         Ada_RTS : constant String := Runtime_Name_For (Name_Ada);\n-         Tmp     : String_Access;\n-\n-      begin\n-         if Selected_Target'Length /= 0 then\n-            if Ada_RTS /= \"\" then\n-               return\n-                 Selected_Target.all & '-' &\n-                 Ada_RTS & Config_Project_File_Extension;\n-            else\n-               return\n-                 Selected_Target.all & Config_Project_File_Extension;\n-            end if;\n-\n-         elsif Ada_RTS /= \"\" then\n-            return Ada_RTS & Config_Project_File_Extension;\n-\n-         else\n-            Tmp := Getenv (Config_Project_Env_Var);\n-\n-            declare\n-               T : constant String := Tmp.all;\n-\n-            begin\n-               Free (Tmp);\n-\n-               if T'Length = 0 then\n-                  return Default_Config_Name;\n-               else\n-                  return T;\n-               end if;\n-            end;\n-         end if;\n-      end Default_File_Name;\n-\n-      -----------------\n-      -- Do_Autoconf --\n-      -----------------\n-\n-      procedure Do_Autoconf is\n-         Obj_Dir : constant Variable_Value :=\n-                     Value_Of\n-                       (Name_Object_Dir,\n-                        Conf_Project.Decl.Attributes,\n-                        Shared);\n-\n-         Gprconfig_Path  : String_Access;\n-         Success         : Boolean;\n-\n-      begin\n-         Gprconfig_Path := Locate_Exec_On_Path (Gprconfig_Name);\n-\n-         if Gprconfig_Path = null then\n-            Raise_Invalid_Config\n-              (\"could not locate gprconfig for auto-configuration\");\n-         end if;\n-\n-         --  First, find the object directory of the Conf_Project\n-\n-         --  If the object directory is a relative one and Build_Tree_Dir is\n-         --  set, first add it.\n-\n-         Name_Len := 0;\n-\n-         if Obj_Dir = Nil_Variable_Value or else Obj_Dir.Default then\n-\n-            if Build_Tree_Dir /= null then\n-               Add_Str_To_Name_Buffer (Build_Tree_Dir.all);\n-\n-               if Get_Name_String (Conf_Project.Directory.Display_Name)'Length\n-                                                         < Root_Dir'Length\n-               then\n-                  Raise_Invalid_Config\n-                    (\"cannot relocate deeper than object directory\");\n-               end if;\n-\n-               Add_Str_To_Name_Buffer\n-                 (Relative_Path\n-                    (Get_Name_String (Conf_Project.Directory.Display_Name),\n-                     Root_Dir.all));\n-            else\n-               Get_Name_String (Conf_Project.Directory.Display_Name);\n-            end if;\n-\n-         else\n-            if Is_Absolute_Path (Get_Name_String (Obj_Dir.Value)) then\n-               Get_Name_String (Obj_Dir.Value);\n-\n-            else\n-               if Build_Tree_Dir /= null then\n-                  if Get_Name_String\n-                    (Conf_Project.Directory.Display_Name)'Length <\n-                                                          Root_Dir'Length\n-                  then\n-                     Raise_Invalid_Config\n-                       (\"cannot relocate deeper than object directory\");\n-                  end if;\n-\n-                  Add_Str_To_Name_Buffer (Build_Tree_Dir.all);\n-                  Add_Str_To_Name_Buffer\n-                    (Relative_Path\n-                       (Get_Name_String (Conf_Project.Directory.Display_Name),\n-                        Root_Dir.all));\n-               else\n-                  Add_Str_To_Name_Buffer\n-                    (Get_Name_String (Conf_Project.Directory.Display_Name));\n-               end if;\n-\n-               Add_Str_To_Name_Buffer (Get_Name_String (Obj_Dir.Value));\n-            end if;\n-         end if;\n-\n-         if Subdirs /= null then\n-            Add_Char_To_Name_Buffer (Directory_Separator);\n-            Add_Str_To_Name_Buffer (Subdirs.all);\n-         end if;\n-\n-         for J in 1 .. Name_Len loop\n-            if Name_Buffer (J) = '/' then\n-               Name_Buffer (J) := Directory_Separator;\n-            end if;\n-         end loop;\n-\n-         --  Make sure that Obj_Dir ends with a directory separator\n-\n-         if Name_Buffer (Name_Len) /= Directory_Separator then\n-            Name_Len := Name_Len + 1;\n-            Name_Buffer (Name_Len) := Directory_Separator;\n-         end if;\n-\n-         declare\n-            Obj_Dir         : constant String := Name_Buffer (1 .. Name_Len);\n-            Config_Switches : Argument_List_Access;\n-            Db_Switches     : Argument_List_Access;\n-            Args            : Argument_List (1 .. 5);\n-            Arg_Last        : Positive;\n-            Obj_Dir_Exists  : Boolean := True;\n-\n-         begin\n-            --  Check if the object directory exists. If Setup_Projects is True\n-            --  (-p) and directory does not exist, attempt to create it.\n-            --  Otherwise, if directory does not exist, fail without calling\n-            --  gprconfig.\n-\n-            if not Is_Directory (Obj_Dir)\n-              and then (Setup_Projects or else Subdirs /= null)\n-            then\n-               begin\n-                  Create_Path (Obj_Dir);\n-\n-                  if not Quiet_Output then\n-                     Write_Str (\"object directory \"\"\");\n-                     Write_Str (Obj_Dir);\n-                     Write_Line (\"\"\" created\");\n-                  end if;\n-\n-               exception\n-                  when others =>\n-                     Raise_Invalid_Config\n-                       (\"could not create object directory \" & Obj_Dir);\n-               end;\n-            end if;\n-\n-            if not Is_Directory (Obj_Dir) then\n-               case Env.Flags.Require_Obj_Dirs is\n-                  when Error =>\n-                     Raise_Invalid_Config\n-                       (\"object directory \" & Obj_Dir & \" does not exist\");\n-\n-                  when Warning =>\n-                     Prj.Err.Error_Msg\n-                       (Env.Flags,\n-                        \"?object directory \" & Obj_Dir & \" does not exist\");\n-                     Obj_Dir_Exists := False;\n-\n-                  when Silent =>\n-                     null;\n-               end case;\n-            end if;\n-\n-            --  Get the config switches. This should be done only now, as some\n-            --  runtimes may have been found in the Builder switches.\n-\n-            Config_Switches := Get_Config_Switches;\n-\n-            --  Get eventual --db switches\n-\n-            Db_Switches := Get_Db_Switches;\n-\n-            --  Invoke gprconfig\n-\n-            Args (1) := new String'(\"--batch\");\n-            Args (2) := new String'(\"-o\");\n-\n-            --  If no config file was specified, set the auto.cgpr one\n-\n-            if Conf_File_Name'Length = 0 then\n-               if Obj_Dir_Exists then\n-                  Args (3) := new String'(Obj_Dir & Auto_Cgpr);\n-\n-               else\n-                  declare\n-                     Path_FD   : File_Descriptor;\n-                     Path_Name : Path_Name_Type;\n-\n-                  begin\n-                     Prj.Env.Create_Temp_File\n-                       (Shared    => Project_Tree.Shared,\n-                        Path_FD   => Path_FD,\n-                        Path_Name => Path_Name,\n-                        File_Use  => \"configuration file\");\n-\n-                     if Path_FD /= Invalid_FD then\n-                        declare\n-                           Temp_Dir : constant String :=\n-                                        Containing_Directory\n-                                          (Get_Name_String (Path_Name));\n-                        begin\n-                           GNAT.OS_Lib.Close (Path_FD);\n-                           Args (3) :=\n-                             new String'(Temp_Dir &\n-                                         Directory_Separator &\n-                                         Auto_Cgpr);\n-                           Delete_File (Get_Name_String (Path_Name));\n-                        end;\n-\n-                     else\n-                        --  We'll have an error message later on\n-\n-                        Args (3) := new String'(Obj_Dir & Auto_Cgpr);\n-                     end if;\n-                  end;\n-               end if;\n-            else\n-               Args (3) := Conf_File_Name;\n-            end if;\n-\n-            Arg_Last := 3;\n-\n-            if Selected_Target /= null and then\n-               Selected_Target.all /= \"\"\n-\n-            then\n-               Args (4) :=\n-                  new String'(\"--target=\" & Selected_Target.all);\n-               Arg_Last := 4;\n-\n-            elsif Normalized_Hostname /= \"\" then\n-               if At_Least_One_Compiler_Command then\n-                  Args (4) := new String'(\"--target=all\");\n-               else\n-                  Args (4) := new String'(\"--target=\" & Normalized_Hostname);\n-               end if;\n-\n-               Arg_Last := 4;\n-            end if;\n-\n-            if not Verbose_Mode then\n-               Arg_Last := Arg_Last + 1;\n-               Args (Arg_Last) := new String'(\"-q\");\n-            end if;\n-\n-            if Verbose_Mode then\n-               Write_Str (Gprconfig_Name);\n-\n-               for J in 1 .. Arg_Last loop\n-                  Write_Char (' ');\n-                  Write_Str (Args (J).all);\n-               end loop;\n-\n-               for J in Config_Switches'Range loop\n-                  Write_Char (' ');\n-                  Write_Str (Config_Switches (J).all);\n-               end loop;\n-\n-               for J in Db_Switches'Range loop\n-                  Write_Char (' ');\n-                  Write_Str (Db_Switches (J).all);\n-               end loop;\n-\n-               Write_Eol;\n-\n-            elsif not Quiet_Output then\n-\n-               --  Display no message if we are creating auto.cgpr, unless in\n-               --  verbose mode.\n-\n-               if Config_File_Name'Length > 0 or else Verbose_Mode then\n-                  Write_Str (\"creating \");\n-                  Write_Str (Simple_Name (Args (3).all));\n-                  Write_Eol;\n-               end if;\n-            end if;\n-\n-            Spawn (Gprconfig_Path.all, Args (1 .. Arg_Last) &\n-                   Config_Switches.all & Db_Switches.all,\n-                   Success);\n-\n-            Free (Config_Switches);\n-\n-            Config_File_Path := Locate_Config_File (Args (3).all);\n-\n-            if Config_File_Path = null then\n-               Raise_Invalid_Config\n-                 (\"could not create \" & Args (3).all);\n-            end if;\n-\n-            for F in Args'Range loop\n-               Free (Args (F));\n-            end loop;\n-         end;\n-      end Do_Autoconf;\n-\n-      ---------------------\n-      -- Get_Db_Switches --\n-      ---------------------\n-\n-      function Get_Db_Switches return Argument_List_Access is\n-         Result : Argument_List_Access;\n-         Nmb_Arg : Natural;\n-      begin\n-         Nmb_Arg :=\n-           (2 * Db_Switch_Args.Last) + Boolean'Pos (not Load_Standard_Base);\n-         Result := new Argument_List (1 .. Nmb_Arg);\n-\n-         if Nmb_Arg /= 0 then\n-            for J in 1 .. Db_Switch_Args.Last loop\n-               Result (2 * J - 1) :=\n-                 new String'(\"--db\");\n-               Result (2 * J) :=\n-                 new String'(Get_Name_String (Db_Switch_Args.Table (J)));\n-            end loop;\n-\n-            if not Load_Standard_Base then\n-               Result (Result'Last) := new String'(\"--db-\");\n-            end if;\n-         end if;\n-\n-         return Result;\n-      end Get_Db_Switches;\n-\n-      -------------------------\n-      -- Get_Config_Switches --\n-      -------------------------\n-\n-      function Get_Config_Switches return Argument_List_Access is\n-\n-         package Language_Htable is new GNAT.HTable.Simple_HTable\n-           (Header_Num => Prj.Header_Num,\n-            Element    => Name_Id,\n-            No_Element => No_Name,\n-            Key        => Name_Id,\n-            Hash       => Prj.Hash,\n-            Equal      => \"=\");\n-         --  Hash table to keep the languages used in the project tree\n-\n-         IDE : constant Package_Id :=\n-                 Value_Of (Name_Ide, Project.Decl.Packages, Shared);\n-\n-         procedure Add_Config_Switches_For_Project\n-           (Project    : Project_Id;\n-            Tree       : Project_Tree_Ref;\n-            With_State : in out Integer);\n-         --  Add all --config switches for this project. This is also called\n-         --  for aggregate projects.\n-\n-         -------------------------------------\n-         -- Add_Config_Switches_For_Project --\n-         -------------------------------------\n-\n-         procedure Add_Config_Switches_For_Project\n-           (Project    : Project_Id;\n-            Tree       : Project_Tree_Ref;\n-            With_State : in out Integer)\n-         is\n-            pragma Unreferenced (With_State);\n-\n-            Shared : constant Shared_Project_Tree_Data_Access := Tree.Shared;\n-\n-            Variable      : Variable_Value;\n-            Check_Default : Boolean;\n-            Lang          : Name_Id;\n-            List          : String_List_Id;\n-            Elem          : String_Element;\n-\n-         begin\n-            if Might_Have_Sources (Project) then\n-               Variable :=\n-                 Value_Of (Name_Languages, Project.Decl.Attributes, Shared);\n-\n-               if Variable = Nil_Variable_Value or else Variable.Default then\n-\n-                  --  Languages is not declared. If it is not an extending\n-                  --  project, or if it extends a project with no Languages,\n-                  --  check for Default_Language.\n-\n-                  Check_Default := Project.Extends = No_Project;\n-\n-                  if not Check_Default then\n-                     Variable :=\n-                       Value_Of\n-                         (Name_Languages,\n-                          Project.Extends.Decl.Attributes,\n-                          Shared);\n-                     Check_Default :=\n-                       Variable /= Nil_Variable_Value\n-                         and then Variable.Values = Nil_String;\n-                  end if;\n-\n-                  if Check_Default then\n-                     Variable :=\n-                       Value_Of\n-                         (Name_Default_Language,\n-                          Project.Decl.Attributes,\n-                          Shared);\n-\n-                     if Variable /= Nil_Variable_Value\n-                       and then not Variable.Default\n-                     then\n-                        Get_Name_String (Variable.Value);\n-                        To_Lower (Name_Buffer (1 .. Name_Len));\n-                        Lang := Name_Find;\n-                        Language_Htable.Set (Lang, Lang);\n-\n-                     --  If no default language is declared, default to Ada\n-\n-                     else\n-                        Language_Htable.Set (Name_Ada, Name_Ada);\n-                     end if;\n-                  end if;\n-\n-               elsif Variable.Values /= Nil_String then\n-\n-                  --  Attribute Languages is declared with a non empty list:\n-                  --  put all the languages in Language_HTable.\n-\n-                  List := Variable.Values;\n-                  while List /= Nil_String loop\n-                     Elem := Shared.String_Elements.Table (List);\n-\n-                     Get_Name_String (Elem.Value);\n-                     To_Lower (Name_Buffer (1 .. Name_Len));\n-                     Lang := Name_Find;\n-                     Language_Htable.Set (Lang, Lang);\n-\n-                     List := Elem.Next;\n-                  end loop;\n-               end if;\n-            end if;\n-         end Add_Config_Switches_For_Project;\n-\n-         procedure For_Every_Imported_Project is new For_Every_Project_Imported\n-           (State => Integer, Action => Add_Config_Switches_For_Project);\n-         --  Document this procedure ???\n-\n-         --  Local variables\n-\n-         Name     : Name_Id;\n-         Count    : Natural;\n-         Result   : Argument_List_Access;\n-         Variable : Variable_Value;\n-         Dummy    : Integer := 0;\n-\n-      --  Start of processing for Get_Config_Switches\n-\n-      begin\n-         For_Every_Imported_Project\n-           (By                 => Project,\n-            Tree               => Project_Tree,\n-            With_State         => Dummy,\n-            Include_Aggregated => True);\n-\n-         Name  := Language_Htable.Get_First;\n-         Count := 0;\n-         while Name /= No_Name loop\n-            Count := Count + 1;\n-            Name := Language_Htable.Get_Next;\n-         end loop;\n-\n-         Result := new String_List (1 .. Count);\n-\n-         Count := 1;\n-         Name  := Language_Htable.Get_First;\n-         while Name /= No_Name loop\n-\n-            --  Check if IDE'Compiler_Command is declared for the language.\n-            --  If it is, use its value to invoke gprconfig.\n-\n-            Variable :=\n-              Value_Of\n-                (Name,\n-                 Attribute_Or_Array_Name => Name_Compiler_Command,\n-                 In_Package              => IDE,\n-                 Shared                  => Shared,\n-                 Force_Lower_Case_Index  => True);\n-\n-            declare\n-               Config_Command : constant String :=\n-                                  \"--config=\" & Get_Name_String (Name);\n-\n-               Runtime_Name : constant String := Runtime_Name_For (Name);\n-\n-            begin\n-               --  In CodePeer mode, we do not take into account any compiler\n-               --  command from the package IDE.\n-\n-               if CodePeer_Mode\n-                 or else Variable = Nil_Variable_Value\n-                 or else Length_Of_Name (Variable.Value) = 0\n-               then\n-                  Result (Count) :=\n-                    new String'(Config_Command & \",,\" & Runtime_Name);\n-\n-               else\n-                  At_Least_One_Compiler_Command := True;\n-\n-                  declare\n-                     Compiler_Command : constant String :=\n-                                          Get_Name_String (Variable.Value);\n-\n-                  begin\n-                     if Is_Absolute_Path (Compiler_Command) then\n-                        Result (Count) :=\n-                          new String'\n-                            (Config_Command & \",,\" & Runtime_Name & \",\"\n-                             & Containing_Directory (Compiler_Command) & \",\"\n-                             & Simple_Name (Compiler_Command));\n-                     else\n-                        Result (Count) :=\n-                          new String'\n-                            (Config_Command & \",,\" & Runtime_Name & \",,\"\n-                             & Compiler_Command);\n-                     end if;\n-                  end;\n-               end if;\n-            end;\n-\n-            Count := Count + 1;\n-            Name  := Language_Htable.Get_Next;\n-         end loop;\n-\n-         return Result;\n-      end Get_Config_Switches;\n-\n-      ------------------------\n-      -- Might_Have_Sources --\n-      ------------------------\n-\n-      function Might_Have_Sources (Project : Project_Id) return Boolean is\n-         Variable : Variable_Value;\n-\n-      begin\n-         Variable :=\n-           Value_Of (Name_Source_Dirs, Project.Decl.Attributes, Shared);\n-\n-         if Variable = Nil_Variable_Value\n-           or else Variable.Default\n-           or else Variable.Values /= Nil_String\n-         then\n-            Variable :=\n-              Value_Of (Name_Source_Files, Project.Decl.Attributes, Shared);\n-            return Variable = Nil_Variable_Value\n-              or else Variable.Default\n-              or else Variable.Values /= Nil_String;\n-\n-         else\n-            return False;\n-         end if;\n-      end Might_Have_Sources;\n-\n-      --  Local Variables\n-\n-      Success             : Boolean;\n-      Config_Project_Node : Project_Node_Id := Empty_Node;\n-\n-   --  Start of processing for Get_Or_Create_Configuration_File\n-\n-   begin\n-      pragma Assert (Prj.Env.Is_Initialized (Env.Project_Path));\n-\n-      Free (Config_File_Path);\n-      Config := No_Project;\n-\n-      Get_Project_Target;\n-      Get_Project_Runtimes;\n-      Check_Builder_Switches;\n-\n-      --  Do not attempt to find a configuration project file when\n-      --  Config_File_Name is No_Configuration_File.\n-\n-      if Config_File_Name = No_Configuration_File then\n-         Config_File_Path := null;\n-\n-      else\n-         if Conf_File_Name'Length > 0 then\n-            Config_File_Path := Locate_Config_File (Conf_File_Name.all);\n-         else\n-            Config_File_Path := Locate_Config_File (Default_File_Name);\n-         end if;\n-\n-         if Config_File_Path = null then\n-            if not Allow_Automatic_Generation\n-              and then Conf_File_Name'Length > 0\n-            then\n-               Raise_Invalid_Config\n-                 (\"could not locate main configuration project \"\n-                  & Conf_File_Name.all);\n-            end if;\n-         end if;\n-      end if;\n-\n-      Automatically_Generated :=\n-        Allow_Automatic_Generation and then Config_File_Path = null;\n-\n-      <<Process_Config_File>>\n-\n-      if Automatically_Generated then\n-\n-         --  This might raise an Invalid_Config exception\n-\n-         Do_Autoconf;\n-\n-      --  If the config file is not auto-generated, warn if there is any --RTS\n-      --  switch, but not when the config file is generated in memory.\n-\n-      elsif Warn_For_RTS\n-        and then RTS_Languages.Get_First /= No_Name\n-        and then Opt.Warning_Mode /= Opt.Suppress\n-        and then On_Load_Config = null\n-      then\n-         Write_Line\n-           (\"warning: \" &\n-              \"runtimes are taken into account only in auto-configuration\");\n-      end if;\n-\n-      --  Parse the configuration file\n-\n-      if Verbose_Mode and then Config_File_Path /= null then\n-         Write_Str  (\"Checking configuration \");\n-         Write_Line (Config_File_Path.all);\n-      end if;\n-\n-      if Config_File_Path /= null then\n-         Prj.Part.Parse\n-           (In_Tree           => Project_Node_Tree,\n-            Project           => Config_Project_Node,\n-            Project_File_Name => Config_File_Path.all,\n-            Errout_Handling   => Prj.Part.Finalize_If_Error,\n-            Packages_To_Check => Packages_To_Check,\n-            Current_Directory => Current_Directory,\n-            Is_Config_File    => True,\n-            Env               => Env);\n-      else\n-         Config_Project_Node := Empty_Node;\n-      end if;\n-\n-      if On_Load_Config /= null then\n-         On_Load_Config\n-           (Config_File       => Config_Project_Node,\n-            Project_Node_Tree => Project_Node_Tree);\n-      end if;\n-\n-      if Config_Project_Node /= Empty_Node then\n-         Prj.Proc.Process_Project_Tree_Phase_1\n-           (In_Tree                => Project_Tree,\n-            Project                => Config,\n-            Packages_To_Check      => Packages_To_Check,\n-            Success                => Success,\n-            From_Project_Node      => Config_Project_Node,\n-            From_Project_Node_Tree => Project_Node_Tree,\n-            Env                    => Env,\n-            Reset_Tree             => False,\n-            On_New_Tree_Loaded     => null);\n-      end if;\n-\n-      if Config_Project_Node = Empty_Node or else Config = No_Project then\n-         Raise_Invalid_Config\n-           (\"processing of configuration project \"\"\"\n-            & Config_File_Path.all & \"\"\" failed\");\n-      end if;\n-\n-      --  Check that the target of the configuration file is the one the user\n-      --  specified on the command line. We do not need to check that when in\n-      --  auto-conf mode, since the appropriate target was passed to gprconfig.\n-\n-      if not Automatically_Generated\n-        and then not\n-          Check_Target\n-            (Config, Autoconf_Specified, Project_Tree, Selected_Target.all)\n-      then\n-         Automatically_Generated := True;\n-         goto Process_Config_File;\n-      end if;\n-   end Get_Or_Create_Configuration_File;\n-\n-   ------------------------\n-   -- Locate_Config_File --\n-   ------------------------\n-\n-   function Locate_Config_File (Name : String) return String_Access is\n-      Prefix_Path : constant String := Executable_Prefix_Path;\n-   begin\n-      if Prefix_Path'Length /= 0 then\n-         return Locate_Regular_File\n-           (Name,\n-            \".\" & Path_Separator &\n-            Prefix_Path & \"share\" & Directory_Separator & \"gpr\");\n-      else\n-         return Locate_Regular_File (Name, \".\");\n-      end if;\n-   end Locate_Config_File;\n-\n-   ------------------------------------\n-   -- Parse_Project_And_Apply_Config --\n-   ------------------------------------\n-\n-   procedure Parse_Project_And_Apply_Config\n-     (Main_Project               : out Prj.Project_Id;\n-      User_Project_Node          : out Prj.Tree.Project_Node_Id;\n-      Config_File_Name           : String := \"\";\n-      Autoconf_Specified         : Boolean;\n-      Project_File_Name          : String;\n-      Project_Tree               : Prj.Project_Tree_Ref;\n-      Project_Node_Tree          : Prj.Tree.Project_Node_Tree_Ref;\n-      Env                        : in out Prj.Tree.Environment;\n-      Packages_To_Check          : String_List_Access;\n-      Allow_Automatic_Generation : Boolean := True;\n-      Automatically_Generated    : out Boolean;\n-      Config_File_Path           : out String_Access;\n-      Target_Name                : String := \"\";\n-      Normalized_Hostname        : String;\n-      On_Load_Config             : Config_File_Hook := null;\n-      Implicit_Project           : Boolean := False;\n-      On_New_Tree_Loaded         : Prj.Proc.Tree_Loaded_Callback := null)\n-   is\n-      Success          : Boolean := False;\n-      Target_Try_Again : Boolean := True;\n-      Config_Try_Again : Boolean;\n-\n-      Finalization : Prj.Part.Errout_Mode := Prj.Part.Always_Finalize;\n-\n-      S : State := No_State;\n-\n-      Conf_File_Name : String_Access := new String'(Config_File_Name);\n-\n-      procedure Add_Directory (Dir : String);\n-      --  Add a directory at the end of the Project Path\n-\n-      Auto_Generated : Boolean;\n-\n-      -------------------\n-      -- Add_Directory --\n-      -------------------\n-\n-      procedure Add_Directory (Dir : String) is\n-      begin\n-         if Opt.Verbose_Mode then\n-            Write_Line (\"   Adding directory \"\"\" & Dir & \"\"\"\");\n-         end if;\n-\n-         Prj.Env.Add_Directories (Env.Project_Path, Dir);\n-      end Add_Directory;\n-\n-   begin\n-      pragma Assert (Prj.Env.Is_Initialized (Env.Project_Path));\n-\n-      --  Start with ignoring missing withed projects\n-\n-      Set_Ignore_Missing_With (Env.Flags, True);\n-\n-      --  Note: If in fact the config file is automatically generated, then\n-      --  Automatically_Generated will be set to True after invocation of\n-      --  Process_Project_And_Apply_Config.\n-\n-      Automatically_Generated := False;\n-\n-      --  Record Target_Value and Target_Origin\n-\n-      if Target_Name = \"\" then\n-         Opt.Target_Value  := new String'(Normalized_Hostname);\n-         Opt.Target_Origin := Default;\n-      else\n-         Opt.Target_Value  := new String'(Target_Name);\n-         Opt.Target_Origin := Specified;\n-      end if;\n-\n-      <<Parse_Again>>\n-\n-      --  Parse the user project tree\n-\n-      Project_Node_Tree.Incomplete_With := False;\n-      Env.Flags.Incomplete_Withs := False;\n-      Prj.Initialize (Project_Tree);\n-\n-      Main_Project := No_Project;\n-\n-      Prj.Part.Parse\n-        (In_Tree           => Project_Node_Tree,\n-         Project           => User_Project_Node,\n-         Project_File_Name => Project_File_Name,\n-         Errout_Handling   => Finalization,\n-         Packages_To_Check => Packages_To_Check,\n-         Current_Directory => Current_Directory,\n-         Is_Config_File    => False,\n-         Env               => Env,\n-         Implicit_Project  => Implicit_Project);\n-\n-      Finalization := Prj.Part.Finalize_If_Error;\n-\n-      if User_Project_Node = Empty_Node then\n-         return;\n-      end if;\n-\n-      --  If --target was not specified on the command line, then do Phase 1 to\n-      --  check if attribute Target is declared in the main project.\n-\n-      if Opt.Target_Origin /= Specified then\n-         Main_Project := No_Project;\n-         Process_Project_Tree_Phase_1\n-           (In_Tree                => Project_Tree,\n-            Project                => Main_Project,\n-            Packages_To_Check      => Packages_To_Check,\n-            Success                => Success,\n-            From_Project_Node      => User_Project_Node,\n-            From_Project_Node_Tree => Project_Node_Tree,\n-            Env                    => Env,\n-            Reset_Tree             => True,\n-            On_New_Tree_Loaded     => On_New_Tree_Loaded);\n-\n-         if not Success then\n-            Main_Project := No_Project;\n-            return;\n-         end if;\n-\n-         declare\n-            Variable : constant Variable_Value :=\n-              Value_Of\n-                (Name_Target,\n-                 Main_Project.Decl.Attributes,\n-                 Project_Tree.Shared);\n-         begin\n-            if Variable /= Nil_Variable_Value\n-              and then not Variable.Default\n-              and then\n-                Get_Name_String (Variable.Value) /= Opt.Target_Value.all\n-            then\n-               if Target_Try_Again then\n-                  Opt.Target_Value :=\n-                    new String'(Get_Name_String (Variable.Value));\n-                  Target_Try_Again := False;\n-                  goto Parse_Again;\n-\n-               else\n-                  Fail_Program\n-                    (Project_Tree,\n-                     \"inconsistent value of attribute Target\");\n-               end if;\n-            end if;\n-         end;\n-      end if;\n-\n-      --  If there are missing withed projects, the projects will be parsed\n-      --  again after the project path is extended with directories rooted\n-      --  at the compiler roots.\n-\n-      Config_Try_Again := Project_Node_Tree.Incomplete_With;\n-\n-      Process_Project_And_Apply_Config\n-        (Main_Project               => Main_Project,\n-         User_Project_Node          => User_Project_Node,\n-         Config_File_Name           => Conf_File_Name.all,\n-         Autoconf_Specified         => Autoconf_Specified,\n-         Project_Tree               => Project_Tree,\n-         Project_Node_Tree          => Project_Node_Tree,\n-         Env                        => Env,\n-         Packages_To_Check          => Packages_To_Check,\n-         Allow_Automatic_Generation => Allow_Automatic_Generation,\n-         Automatically_Generated    => Auto_Generated,\n-         Config_File_Path           => Config_File_Path,\n-         Target_Name                => Target_Name,\n-         Normalized_Hostname        => Normalized_Hostname,\n-         On_Load_Config             => On_Load_Config,\n-         On_New_Tree_Loaded         => On_New_Tree_Loaded,\n-         Do_Phase_1                 => Opt.Target_Origin = Specified);\n-\n-      if Auto_Generated then\n-         Automatically_Generated := True;\n-      end if;\n-\n-      --  Exit if there was an error. Otherwise, if Config_Try_Again is True,\n-      --  update the project path and try again.\n-\n-      if Main_Project /= No_Project and then Config_Try_Again then\n-         Set_Ignore_Missing_With (Env.Flags, False);\n-\n-         if Config_File_Path /= null then\n-            Conf_File_Name := new String'(Config_File_Path.all);\n-         end if;\n-\n-         --  For the second time the project files are parsed, the warning for\n-         --  --RTS= being only taken into account in auto-configuration are\n-         --  suppressed, as we are no longer in auto-configuration.\n-\n-         Warn_For_RTS := False;\n-\n-         --  Add the default directories corresponding to the compilers\n-\n-         Update_Project_Path\n-           (By                 => Main_Project,\n-            Tree               => Project_Tree,\n-            With_State         => S,\n-            Include_Aggregated => True,\n-            Imported_First     => False);\n-\n-         declare\n-            Compiler_Root : Compiler_Root_Ptr;\n-            Prefix        : String_Access;\n-            Runtime_Root  : Runtime_Root_Ptr;\n-            Path_Value : constant String_Access := Getenv (\"PATH\");\n-\n-         begin\n-            if Opt.Verbose_Mode then\n-               Write_Line (\"Setting the default project search directories\");\n-\n-               if Prj.Current_Verbosity = High then\n-                  if Path_Value = null or else Path_Value'Length = 0 then\n-                     Write_Line (\"No environment variable PATH\");\n-\n-                  else\n-                     Write_Line (\"PATH =\");\n-                     Write_Line (\"   \" & Path_Value.all);\n-                  end if;\n-               end if;\n-            end if;\n-\n-            --  Reorder the compiler roots in the PATH order\n-\n-            if First_Compiler_Root /= null\n-              and then First_Compiler_Root.Next /= null\n-            then\n-               declare\n-                  Pred : Compiler_Root_Ptr;\n-                  First_New_Comp : Compiler_Root_Ptr := null;\n-                  New_Comp : Compiler_Root_Ptr := null;\n-                  First : Positive := Path_Value'First;\n-                  Last  : Positive;\n-                  Path_Last : Positive;\n-               begin\n-                  while First <= Path_Value'Last loop\n-                     Last := First;\n-\n-                     if Path_Value (First) /= Path_Separator then\n-                        while Last < Path_Value'Last\n-                          and then Path_Value (Last + 1) /= Path_Separator\n-                        loop\n-                           Last := Last + 1;\n-                        end loop;\n-\n-                        Path_Last := Last;\n-                        while Path_Last > First\n-                          and then\n-                            Path_Value (Path_Last) = Directory_Separator\n-                        loop\n-                           Path_Last := Path_Last - 1;\n-                        end loop;\n-\n-                        if Path_Last > First + 4\n-                          and then\n-                            Path_Value (Path_Last - 2 .. Path_Last) = \"bin\"\n-                          and then\n-                            Path_Value (Path_Last - 3) = Directory_Separator\n-                        then\n-                           Path_Last := Path_Last - 4;\n-                           Pred := null;\n-                           Compiler_Root := First_Compiler_Root;\n-                           while Compiler_Root /= null\n-                             and then Compiler_Root.Root.all /=\n-                               Path_Value (First .. Path_Last)\n-                           loop\n-                              Pred := Compiler_Root;\n-                              Compiler_Root := Compiler_Root.Next;\n-                           end loop;\n-\n-                           if Compiler_Root /= null then\n-                              if Pred = null then\n-                                 First_Compiler_Root :=\n-                                   First_Compiler_Root.Next;\n-                              else\n-                                 Pred.Next := Compiler_Root.Next;\n-                              end if;\n-\n-                              if First_New_Comp = null then\n-                                 First_New_Comp := Compiler_Root;\n-                              else\n-                                 New_Comp.Next := Compiler_Root;\n-                              end if;\n-\n-                              New_Comp := Compiler_Root;\n-                              New_Comp.Next := null;\n-                           end if;\n-                        end if;\n-                     end if;\n-\n-                     First := Last + 1;\n-                  end loop;\n-\n-                  if First_New_Comp /= null then\n-                     New_Comp.Next := First_Compiler_Root;\n-                     First_Compiler_Root := First_New_Comp;\n-                  end if;\n-               end;\n-            end if;\n-\n-            --  Now that the compiler roots are in a correct order, add the\n-            --  directories corresponding to these compiler roots in the\n-            --  project path.\n-\n-            Compiler_Root := First_Compiler_Root;\n-            while Compiler_Root /= null loop\n-               Prefix := Compiler_Root.Root;\n-\n-               Runtime_Root := Compiler_Root.Runtimes;\n-               while Runtime_Root /= null loop\n-                  Add_Directory\n-                    (Runtime_Root.Root.all &\n-                       Directory_Separator &\n-                       \"lib\" &\n-                       Directory_Separator &\n-                       \"gnat\");\n-                  Add_Directory\n-                    (Runtime_Root.Root.all &\n-                       Directory_Separator &\n-                       \"share\" &\n-                       Directory_Separator &\n-                       \"gpr\");\n-                  Runtime_Root := Runtime_Root.Next;\n-               end loop;\n-\n-               Add_Directory\n-                 (Prefix.all &\n-                    Directory_Separator &\n-                    Opt.Target_Value.all &\n-                    Directory_Separator &\n-                    \"lib\" &\n-                    Directory_Separator &\n-                    \"gnat\");\n-               Add_Directory\n-                 (Prefix.all &\n-                    Directory_Separator &\n-                    Opt.Target_Value.all &\n-                    Directory_Separator &\n-                    \"share\" &\n-                    Directory_Separator &\n-                    \"gpr\");\n-               Add_Directory\n-                 (Prefix.all &\n-                    Directory_Separator &\n-                    \"share\" &\n-                    Directory_Separator &\n-                    \"gpr\");\n-               Add_Directory\n-                 (Prefix.all &\n-                    Directory_Separator &\n-                    \"lib\" &\n-                    Directory_Separator &\n-                    \"gnat\");\n-               Compiler_Root := Compiler_Root.Next;\n-            end loop;\n-         end;\n-\n-         --  And parse again the project files. There will be no missing\n-         --  withed projects, as Ignore_Missing_With is set to False in\n-         --  the environment flags, so there is no risk of endless loop here.\n-\n-         goto Parse_Again;\n-      end if;\n-   end Parse_Project_And_Apply_Config;\n-\n-   --------------------------------------\n-   -- Process_Project_And_Apply_Config --\n-   --------------------------------------\n-\n-   procedure Process_Project_And_Apply_Config\n-     (Main_Project               : out Prj.Project_Id;\n-      User_Project_Node          : Prj.Tree.Project_Node_Id;\n-      Config_File_Name           : String := \"\";\n-      Autoconf_Specified         : Boolean;\n-      Project_Tree               : Prj.Project_Tree_Ref;\n-      Project_Node_Tree          : Prj.Tree.Project_Node_Tree_Ref;\n-      Env                        : in out Prj.Tree.Environment;\n-      Packages_To_Check          : String_List_Access;\n-      Allow_Automatic_Generation : Boolean := True;\n-      Automatically_Generated    : out Boolean;\n-      Config_File_Path           : out String_Access;\n-      Target_Name                : String := \"\";\n-      Normalized_Hostname        : String;\n-      On_Load_Config             : Config_File_Hook := null;\n-      Reset_Tree                 : Boolean := True;\n-      On_New_Tree_Loaded         : Prj.Proc.Tree_Loaded_Callback := null;\n-      Do_Phase_1                 : Boolean := True)\n-   is\n-      Shared              : constant Shared_Project_Tree_Data_Access :=\n-                              Project_Tree.Shared;\n-      Main_Config_Project : Project_Id;\n-      Success             : Boolean;\n-\n-      Conf_Project : Project_Id := No_Project;\n-      --  The object directory of this project is used to store the config\n-      --  project file in auto-configuration. Set by Check_Project below.\n-\n-      procedure Check_Project (Project : Project_Id);\n-      --  Look for a non aggregate project. If one is found, put its project Id\n-      --  in Conf_Project.\n-\n-      -------------------\n-      -- Check_Project --\n-      -------------------\n-\n-      procedure Check_Project (Project : Project_Id) is\n-      begin\n-         if Project.Qualifier = Aggregate\n-              or else\n-            Project.Qualifier = Aggregate_Library\n-         then\n-            declare\n-               List : Aggregated_Project_List := Project.Aggregated_Projects;\n-\n-            begin\n-               --  Look for a non aggregate project until one is found\n-\n-               while Conf_Project = No_Project and then List /= null loop\n-                  Check_Project (List.Project);\n-                  List := List.Next;\n-               end loop;\n-            end;\n-\n-         else\n-            Conf_Project := Project;\n-         end if;\n-      end Check_Project;\n-\n-   --  Start of processing for Process_Project_And_Apply_Config\n-\n-   begin\n-      Automatically_Generated := False;\n-\n-      if Do_Phase_1 then\n-         Main_Project := No_Project;\n-         Process_Project_Tree_Phase_1\n-           (In_Tree                => Project_Tree,\n-            Project                => Main_Project,\n-            Packages_To_Check      => Packages_To_Check,\n-            Success                => Success,\n-            From_Project_Node      => User_Project_Node,\n-            From_Project_Node_Tree => Project_Node_Tree,\n-            Env                    => Env,\n-            Reset_Tree             => Reset_Tree,\n-            On_New_Tree_Loaded     => On_New_Tree_Loaded);\n-\n-         if not Success then\n-            Main_Project := No_Project;\n-            return;\n-         end if;\n-      end if;\n-\n-      if Project_Tree.Source_Info_File_Name /= null then\n-         if not Is_Absolute_Path (Project_Tree.Source_Info_File_Name.all) then\n-            declare\n-               Obj_Dir : constant Variable_Value :=\n-                           Value_Of\n-                             (Name_Object_Dir,\n-                              Main_Project.Decl.Attributes,\n-                              Shared);\n-\n-            begin\n-               if Obj_Dir = Nil_Variable_Value or else Obj_Dir.Default then\n-                  Get_Name_String (Main_Project.Directory.Display_Name);\n-\n-               else\n-                  if Is_Absolute_Path (Get_Name_String (Obj_Dir.Value)) then\n-                     Get_Name_String (Obj_Dir.Value);\n-\n-                  else\n-                     Name_Len := 0;\n-                     Add_Str_To_Name_Buffer\n-                       (Get_Name_String (Main_Project.Directory.Display_Name));\n-                     Add_Str_To_Name_Buffer (Get_Name_String (Obj_Dir.Value));\n-                  end if;\n-               end if;\n-\n-               Add_Char_To_Name_Buffer (Directory_Separator);\n-               Add_Str_To_Name_Buffer (Project_Tree.Source_Info_File_Name.all);\n-               Free (Project_Tree.Source_Info_File_Name);\n-               Project_Tree.Source_Info_File_Name :=\n-                 new String'(Name_Buffer (1 .. Name_Len));\n-            end;\n-         end if;\n-\n-         Read_Source_Info_File (Project_Tree);\n-      end if;\n-\n-      --  Get the first project that is not an aggregate project or an\n-      --  aggregate library project. The object directory of this project will\n-      --  be used to store the config project file in auto-configuration.\n-\n-      Check_Project (Main_Project);\n-\n-      --  Fail if there is only aggregate projects and aggregate library\n-      --  projects in the project tree.\n-\n-      if Conf_Project = No_Project then\n-         Raise_Invalid_Config (\"there are no non-aggregate projects\");\n-      end if;\n-\n-      --  Find configuration file\n-\n-      Get_Or_Create_Configuration_File\n-        (Config                     => Main_Config_Project,\n-         Project                    => Main_Project,\n-         Conf_Project               => Conf_Project,\n-         Project_Tree               => Project_Tree,\n-         Project_Node_Tree          => Project_Node_Tree,\n-         Env                        => Env,\n-         Allow_Automatic_Generation => Allow_Automatic_Generation,\n-         Config_File_Name           => Config_File_Name,\n-         Autoconf_Specified         => Autoconf_Specified,\n-         Target_Name                => Target_Name,\n-         Normalized_Hostname        => Normalized_Hostname,\n-         Packages_To_Check          => Packages_To_Check,\n-         Config_File_Path           => Config_File_Path,\n-         Automatically_Generated    => Automatically_Generated,\n-         On_Load_Config             => On_Load_Config);\n-\n-      Apply_Config_File (Main_Config_Project, Project_Tree);\n-\n-      --  Finish processing the user's project\n-\n-      Prj.Proc.Process_Project_Tree_Phase_2\n-        (In_Tree                => Project_Tree,\n-         Project                => Main_Project,\n-         Success                => Success,\n-         From_Project_Node      => User_Project_Node,\n-         From_Project_Node_Tree => Project_Node_Tree,\n-         Env                    => Env);\n-\n-      if Success then\n-         if Project_Tree.Source_Info_File_Name /= null\n-           and then not Project_Tree.Source_Info_File_Exists\n-         then\n-            Write_Source_Info_File (Project_Tree);\n-         end if;\n-\n-      else\n-         Main_Project := No_Project;\n-      end if;\n-   end Process_Project_And_Apply_Config;\n-\n-   --------------------------\n-   -- Raise_Invalid_Config --\n-   --------------------------\n-\n-   procedure Raise_Invalid_Config (Msg : String) is\n-   begin\n-      Raise_Exception (Invalid_Config'Identity, Msg);\n-   end Raise_Invalid_Config;\n-\n-   ----------------------\n-   -- Runtime_Name_For --\n-   ----------------------\n-\n-   function Runtime_Name_For (Language : Name_Id) return String is\n-   begin\n-      if RTS_Languages.Get (Language) /= No_Name then\n-         return Get_Name_String (RTS_Languages.Get (Language));\n-      else\n-         return \"\";\n-      end if;\n-   end Runtime_Name_For;\n-\n-   --------------------------\n-   -- Runtime_Name_Set_For --\n-   --------------------------\n-\n-   function Runtime_Name_Set_For (Language : Name_Id) return Boolean is\n-   begin\n-      return RTS_Languages.Get (Language) /= No_Name;\n-   end Runtime_Name_Set_For;\n-\n-   ---------------------\n-   -- Set_Runtime_For --\n-   ---------------------\n-\n-   procedure Set_Runtime_For (Language : Name_Id; RTS_Name : String) is\n-   begin\n-      Name_Len := RTS_Name'Length;\n-      Name_Buffer (1 .. Name_Len) := RTS_Name;\n-      RTS_Languages.Set (Language, Name_Find);\n-   end Set_Runtime_For;\n-\n-   ----------------------------\n-   -- Look_For_Project_Paths --\n-   ----------------------------\n-\n-   procedure Look_For_Project_Paths\n-     (Project    : Project_Id;\n-      Tree       : Project_Tree_Ref;\n-      With_State : in out State)\n-   is\n-      Lang_Id       : Language_Ptr;\n-      Compiler_Root : Compiler_Root_Ptr;\n-      Runtime_Root  : Runtime_Root_Ptr;\n-      Comp_Driver   : String_Access;\n-      Comp_Dir      : String_Access;\n-      Prefix   : String_Access;\n-\n-      pragma Unreferenced (Tree);\n-\n-   begin\n-      With_State := No_State;\n-\n-      Lang_Id := Project.Languages;\n-      while Lang_Id /= No_Language_Index loop\n-         if Lang_Id.Config.Compiler_Driver /= No_File then\n-            Comp_Driver :=\n-              new String'\n-                (Get_Name_String (Lang_Id.Config.Compiler_Driver));\n-\n-            --  Get the absolute path of the compiler driver\n-\n-            if not Is_Absolute_Path (Comp_Driver.all) then\n-               Comp_Driver := Locate_Exec_On_Path (Comp_Driver.all);\n-            end if;\n-\n-            if Comp_Driver /= null and then Comp_Driver'Length > 0 then\n-               Comp_Dir :=\n-                 new String'\n-                   (Containing_Directory (Comp_Driver.all));\n-\n-               --  Consider only the compiler drivers that are in \"bin\"\n-               --  subdirectories.\n-\n-               if Simple_Name (Comp_Dir.all) = \"bin\" then\n-                  Prefix :=\n-                    new String'(Containing_Directory (Comp_Dir.all));\n-\n-                  --  Check if the compiler root is already in the list. If it\n-                  --  is not, add it to the list.\n-\n-                  Compiler_Root := First_Compiler_Root;\n-                  while Compiler_Root /= null loop\n-                     exit when Prefix.all = Compiler_Root.Root.all;\n-                     Compiler_Root := Compiler_Root.Next;\n-                  end loop;\n-\n-                  if Compiler_Root = null then\n-                     First_Compiler_Root :=\n-                       new Compiler_Root_Data'\n-                         (Root => Prefix,\n-                          Runtimes => null,\n-                          Next => First_Compiler_Root);\n-                     Compiler_Root := First_Compiler_Root;\n-                  end if;\n-\n-                  --  If there is a runtime for this compiler, check if it is\n-                  --  recorded with the compiler root. If it is not, record\n-                  --  the runtime.\n-\n-                  declare\n-                     Runtime : constant String :=\n-                                 Runtime_Name_For (Lang_Id.Name);\n-                     Root    : String_Access;\n-\n-                  begin\n-                     if Runtime'Length > 0 then\n-                        if Is_Absolute_Path (Runtime) then\n-                           Root := new String'(Runtime);\n-\n-                        else\n-                           Root :=\n-                             new String'\n-                               (Prefix.all &\n-                                  Directory_Separator &\n-                                  Opt.Target_Value.all &\n-                                  Directory_Separator &\n-                                  Runtime);\n-                        end if;\n-\n-                        Runtime_Root := Compiler_Root.Runtimes;\n-                        while Runtime_Root /= null loop\n-                           exit when Root.all = Runtime_Root.Root.all;\n-                           Runtime_Root := Runtime_Root.Next;\n-                        end loop;\n-\n-                        if Runtime_Root = null then\n-                           Compiler_Root.Runtimes :=\n-                             new Runtime_Root_Data'\n-                               (Root => Root,\n-                                Next => Compiler_Root.Runtimes);\n-                        end if;\n-                     end if;\n-                  end;\n-               end if;\n-            end if;\n-         end if;\n-\n-         Lang_Id := Lang_Id.Next;\n-      end loop;\n-   end Look_For_Project_Paths;\n-end Prj.Conf;"}, {"sha": "41ef5eb858cf0d6f0a818063df4e4f6c7d6811dd", "filename": "gcc/ada/prj-conf.ads", "status": "removed", "additions": 0, "deletions": 223, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-conf.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-conf.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-conf.ads?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793", "patch": "@@ -1,223 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                              P R J . C O N F                             --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---            Copyright (C) 2006-2017, Free Software Foundation, Inc.       --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  The following package manipulates the configuration files\n-\n-with Prj.Tree;\n-with Prj.Proc;\n-\n-package Prj.Conf is\n-\n-   type Config_File_Hook is access procedure\n-     (Config_File       : in out Prj.Tree.Project_Node_Id;\n-      Project_Node_Tree : Prj.Tree.Project_Node_Tree_Ref);\n-   --  Hook called after the config file has been parsed. This lets the\n-   --  application do last minute changes to it (GPS uses this to add the\n-   --  default naming schemes for instance). At that point, the config file\n-   --  has not been applied to the project yet. When no config file was found,\n-   --  and automatic generation is disabled, it is possible that Config_File\n-   --  is set to Empty_Node when this procedure is called. You can then decide\n-   --  to create a new config file if you need.\n-\n-   No_Configuration_File : constant String := \"/\";\n-   --  When specified as a parameter Config_File_Name in the procedures below,\n-   --  no existing configuration project file is parsed. This is used by\n-   --  gnatmake, gnatclean and the GNAT driver to avoid parsing an existing\n-   --  default configuration project file.\n-\n-   procedure Parse_Project_And_Apply_Config\n-     (Main_Project               : out Prj.Project_Id;\n-      User_Project_Node          : out Prj.Tree.Project_Node_Id;\n-      Config_File_Name           : String                        := \"\";\n-      Autoconf_Specified         : Boolean;\n-      Project_File_Name          : String;\n-      Project_Tree               : Prj.Project_Tree_Ref;\n-      Project_Node_Tree          : Prj.Tree.Project_Node_Tree_Ref;\n-      Env                        : in out Prj.Tree.Environment;\n-      Packages_To_Check          : String_List_Access;\n-      Allow_Automatic_Generation : Boolean                       := True;\n-      Automatically_Generated    : out Boolean;\n-      Config_File_Path           : out String_Access;\n-      Target_Name                : String                        := \"\";\n-      Normalized_Hostname        : String;\n-      On_Load_Config             : Config_File_Hook              := null;\n-      Implicit_Project           : Boolean                       := False;\n-      On_New_Tree_Loaded         : Prj.Proc.Tree_Loaded_Callback := null);\n-   --  Find the main configuration project and parse the project tree rooted at\n-   --  this configuration project.\n-   --\n-   --  Project_Node_Tree must have been initialized first (and possibly the\n-   --  value for external references and project path should also have been\n-   --  set).\n-   --\n-   --  If the processing fails, Main_Project is set to No_Project. If the error\n-   --  happened while parsing the project itself (i.e. creating the tree),\n-   --  User_Project_Node is also set to Empty_Node.\n-   --\n-   --  If Config_File_Name is No_Configuration_File, then no configuration\n-   --  project file is parsed. Normally, in this case On_Load_Config is not\n-   --  null, and it is used to create a configuration project file in memory.\n-   --\n-   --  Autoconf_Specified indicates whether the user has specified --autoconf.\n-   --  If this is the case, the config file might be (re)generated, as\n-   --  appropriate, to match languages and target if the one specified doesn't\n-   --  already match.\n-   --\n-   --  Normalized_Hostname is the host on which gprbuild is returned,\n-   --  normalized so that we can more easily compare it with what is stored in\n-   --  configuration files. It is used when the target is unspecified, although\n-   --  we need to know the target specified by the user (Target_Name) when\n-   --  computing the name of the default config file that should be used.\n-   --\n-   --  If specified, On_Load_Config is called just after the config file has\n-   --  been created/loaded. You can then modify it before it is later applied\n-   --  to the project itself.\n-   --\n-   --  Any error in generating or parsing the config file is reported via the\n-   --  Invalid_Config exception, with an appropriate message. Any error while\n-   --  parsing the project file results in No_Project.\n-   --\n-   --  If Implicit_Project is True, the main project file being parsed is\n-   --  deemed to be in the current working directory, even if it is not the\n-   --  case. Implicit_Project is set to True when a tool such as gprbuild is\n-   --  invoked without a project file and is using an implicit project file\n-   --  that is virtually in the current working directory, but is physically\n-   --  in another directory.\n-   --\n-   --  If specified, On_New_Tree_Loaded is called after each aggregated project\n-   --  has been processed successfully.\n-\n-   procedure Process_Project_And_Apply_Config\n-     (Main_Project               : out Prj.Project_Id;\n-      User_Project_Node          : Prj.Tree.Project_Node_Id;\n-      Config_File_Name           : String                        := \"\";\n-      Autoconf_Specified         : Boolean;\n-      Project_Tree               : Prj.Project_Tree_Ref;\n-      Project_Node_Tree          : Prj.Tree.Project_Node_Tree_Ref;\n-      Env                        : in out Prj.Tree.Environment;\n-      Packages_To_Check          : String_List_Access;\n-      Allow_Automatic_Generation : Boolean                       := True;\n-      Automatically_Generated    : out Boolean;\n-      Config_File_Path           : out String_Access;\n-      Target_Name                : String                        := \"\";\n-      Normalized_Hostname        : String;\n-      On_Load_Config             : Config_File_Hook              := null;\n-      Reset_Tree                 : Boolean                       := True;\n-      On_New_Tree_Loaded         : Prj.Proc.Tree_Loaded_Callback := null;\n-      Do_Phase_1                 : Boolean                       := True);\n-   --  Same as above, except the project must already have been parsed through\n-   --  Prj.Part.Parse, and only the processing of the project and the\n-   --  configuration is done at this level.\n-   --\n-   --  If Reset_Tree is true, all projects are first removed from the tree.\n-   --  When_No_Sources indicates what should be done when no sources are found\n-   --  for one of the languages of the project.\n-   --\n-   --  If Require_Sources_Other_Lang is true, then all languages must have at\n-   --  least one source file, or an error is reported via When_No_Sources. If\n-   --  it is false, this is only required for Ada (and only if it is a language\n-   --  of the project).\n-   --\n-   --  If Do_Phase_1 is False, then Prj.Proc.Process_Project_Tree_Phase_1\n-   --  should not be called, as it has already been invoked successfully.\n-\n-   Invalid_Config : exception;\n-\n-   procedure Get_Or_Create_Configuration_File\n-     (Project                    : Prj.Project_Id;\n-      Conf_Project               : Project_Id;\n-      Project_Tree               : Prj.Project_Tree_Ref;\n-      Project_Node_Tree          : Prj.Tree.Project_Node_Tree_Ref;\n-      Env                        : in out Prj.Tree.Environment;\n-      Allow_Automatic_Generation : Boolean;\n-      Config_File_Name           : String             := \"\";\n-      Autoconf_Specified         : Boolean;\n-      Target_Name                : String             := \"\";\n-      Normalized_Hostname        : String;\n-      Packages_To_Check          : String_List_Access := null;\n-      Config                     : out Prj.Project_Id;\n-      Config_File_Path           : out String_Access;\n-      Automatically_Generated    : out Boolean;\n-      On_Load_Config             : Config_File_Hook   := null);\n-   --  Compute the name of the configuration file that should be used. If no\n-   --  default configuration file is found, a new one will be automatically\n-   --  generated if Allow_Automatic_Generation is true. This configuration\n-   --  project file will be generated in the object directory of project\n-   --  Conf_Project.\n-   --\n-   --  Any error in generating or parsing the config file is reported via the\n-   --  Invalid_Config exception, with an appropriate message.\n-   --\n-   --  On exit, Configuration_Project_Path is never null (if none could be\n-   --  found, Os.Fail was called and the program exited anyway).\n-   --\n-   --  The choice and generation of a configuration file depends on several\n-   --  attributes of the user's project file (given by the Project argument),\n-   --  e.g. list of languages that must be supported. Project must therefore\n-   --  have been partially processed (phase one of the processing only).\n-   --\n-   --  Config_File_Name should be set to the name of the config file specified\n-   --  by the user (either through gprbuild's --config or --autoconf switches).\n-   --  In the latter case, Autoconf_Specified should be set to true to indicate\n-   --  that the configuration file can be regenerated to match target and\n-   --  languages. This name can either be an absolute path, or the base name\n-   --  that will be searched in the default config file directories (which\n-   --  depends on the installation path for the tools).\n-   --\n-   --  Target_Name is used to chose the configuration file that will be used\n-   --  from among several possibilities.\n-   --\n-   --  If a project file could be found, it is automatically parsed and\n-   --  processed (and Packages_To_Check is used to indicate which packages\n-   --  should be processed).\n-\n-   procedure Add_Default_GNAT_Naming_Scheme\n-     (Config_File  : in out Prj.Tree.Project_Node_Id;\n-      Project_Tree : Prj.Tree.Project_Node_Tree_Ref);\n-   --  A hook that will create a new config file (in memory), used for\n-   --  Get_Or_Create_Configuration_File and Process_Project_And_Apply_Config\n-   --  and add the default GNAT naming scheme to it. Nothing is done if the\n-   --  config_file already exists, to avoid overriding what the user might\n-   --  have put in there.\n-\n-   --------------\n-   -- Runtimes --\n-   --------------\n-\n-   procedure Set_Runtime_For (Language : Name_Id; RTS_Name : String);\n-   --  Specifies the runtime to use for a specific language. Most of the time\n-   --  this should be used for Ada, but other languages can also specify their\n-   --  own runtime. This is in general specified via the --RTS command line\n-   --  switch, and results in a specific component passed to gprconfig's\n-   --  --config switch then automatically generating a configuration file.\n-\n-   function Runtime_Name_For (Language : Name_Id) return String;\n-   --  Returns the runtime name for a language. Returns an empty string if no\n-   --  runtime was specified for the language using option --RTS.\n-\n-   function Runtime_Name_Set_For (Language : Name_Id) return Boolean;\n-   --  Returns True only if Set_Runtime_For has been called for the Language\n-\n-end Prj.Conf;"}, {"sha": "9c9472cc61ebf64c4e95f77a5d00f106b9c40a6c", "filename": "gcc/ada/prj-dect.adb", "status": "removed", "additions": 0, "deletions": 1809, "changes": 1809, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-dect.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-dect.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-dect.adb?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793", "patch": "@@ -1,1809 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                              P R J . D E C T                             --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 2001-2016, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-with Err_Vars;    use Err_Vars;\n-with Opt;         use Opt;\n-with Prj.Attr;    use Prj.Attr;\n-with Prj.Attr.PM; use Prj.Attr.PM;\n-with Prj.Err;     use Prj.Err;\n-with Prj.Strt;    use Prj.Strt;\n-with Prj.Tree;    use Prj.Tree;\n-with Snames;\n-with Uintp;       use Uintp;\n-\n-with GNAT;                  use GNAT;\n-with GNAT.Case_Util;        use GNAT.Case_Util;\n-with GNAT.Spelling_Checker; use GNAT.Spelling_Checker;\n-with GNAT.Strings;\n-\n-package body Prj.Dect is\n-\n-   type Zone is (In_Project, In_Package, In_Case_Construction);\n-   --  Used to indicate if we are parsing a package (In_Package), a case\n-   --  construction (In_Case_Construction) or none of those two (In_Project).\n-\n-   procedure Rename_Obsolescent_Attributes\n-     (In_Tree         : Project_Node_Tree_Ref;\n-      Attribute       : Project_Node_Id;\n-      Current_Package : Project_Node_Id);\n-   --  Rename obsolescent attributes in the tree. When the attribute has been\n-   --  renamed since its initial introduction in the design of projects, we\n-   --  replace the old name in the tree with the new name, so that the code\n-   --  does not have to check both names forever.\n-\n-   procedure Check_Attribute_Allowed\n-     (In_Tree   : Project_Node_Tree_Ref;\n-      Project   : Project_Node_Id;\n-      Attribute : Project_Node_Id;\n-      Flags     : Processing_Flags);\n-   --  Check whether the attribute is valid in this project. In particular,\n-   --  depending on the type of project (qualifier), some attributes might\n-   --  be disabled.\n-\n-   procedure Check_Package_Allowed\n-     (In_Tree         : Project_Node_Tree_Ref;\n-      Project         : Project_Node_Id;\n-      Current_Package : Project_Node_Id;\n-      Flags           : Processing_Flags);\n-   --  Check whether the package is valid in this project\n-\n-   procedure Parse_Attribute_Declaration\n-     (In_Tree           : Project_Node_Tree_Ref;\n-      Attribute         : out Project_Node_Id;\n-      First_Attribute   : Attribute_Node_Id;\n-      Current_Project   : Project_Node_Id;\n-      Current_Package   : Project_Node_Id;\n-      Packages_To_Check : String_List_Access;\n-      Flags             : Processing_Flags);\n-   --  Parse an attribute declaration\n-\n-   procedure Parse_Case_Construction\n-     (In_Tree           : Project_Node_Tree_Ref;\n-      Case_Construction : out Project_Node_Id;\n-      First_Attribute   : Attribute_Node_Id;\n-      Current_Project   : Project_Node_Id;\n-      Current_Package   : Project_Node_Id;\n-      Packages_To_Check : String_List_Access;\n-      Is_Config_File    : Boolean;\n-      Flags             : Processing_Flags);\n-   --  Parse a case construction\n-\n-   procedure Parse_Declarative_Items\n-     (In_Tree           : Project_Node_Tree_Ref;\n-      Declarations      : out Project_Node_Id;\n-      In_Zone           : Zone;\n-      First_Attribute   : Attribute_Node_Id;\n-      Current_Project   : Project_Node_Id;\n-      Current_Package   : Project_Node_Id;\n-      Packages_To_Check : String_List_Access;\n-      Is_Config_File    : Boolean;\n-      Flags             : Processing_Flags);\n-   --  Parse declarative items. Depending on In_Zone, some declarative items\n-   --  may be forbidden. Is_Config_File should be set to True if the project\n-   --  represents a config file (.cgpr) since some specific checks apply.\n-\n-   procedure Parse_Package_Declaration\n-     (In_Tree             : Project_Node_Tree_Ref;\n-      Package_Declaration : out Project_Node_Id;\n-      Current_Project     : Project_Node_Id;\n-      Packages_To_Check   : String_List_Access;\n-      Is_Config_File      : Boolean;\n-      Flags               : Processing_Flags);\n-   --  Parse a package declaration.\n-   --  Is_Config_File should be set to True if the project represents a config\n-   --  file (.cgpr) since some specific checks apply.\n-\n-   procedure Parse_String_Type_Declaration\n-     (In_Tree         : Project_Node_Tree_Ref;\n-      String_Type     : out Project_Node_Id;\n-      Current_Project : Project_Node_Id;\n-      Flags           : Processing_Flags);\n-   --  type <name> is ( <literal_string> { , <literal_string> } ) ;\n-\n-   procedure Parse_Variable_Declaration\n-     (In_Tree         : Project_Node_Tree_Ref;\n-      Variable        : out Project_Node_Id;\n-      Current_Project : Project_Node_Id;\n-      Current_Package : Project_Node_Id;\n-      Flags           : Processing_Flags);\n-   --  Parse a variable assignment\n-   --  <variable_Name> := <expression>; OR\n-   --  <variable_Name> : <string_type_Name> := <string_expression>;\n-\n-   -----------\n-   -- Parse --\n-   -----------\n-\n-   procedure Parse\n-     (In_Tree           : Project_Node_Tree_Ref;\n-      Declarations      : out Project_Node_Id;\n-      Current_Project   : Project_Node_Id;\n-      Extends           : Project_Node_Id;\n-      Packages_To_Check : String_List_Access;\n-      Is_Config_File    : Boolean;\n-      Flags             : Processing_Flags)\n-   is\n-      First_Declarative_Item : Project_Node_Id := Empty_Node;\n-\n-   begin\n-      Declarations :=\n-        Default_Project_Node\n-          (Of_Kind => N_Project_Declaration, In_Tree => In_Tree);\n-      Set_Location_Of (Declarations, In_Tree, To => Token_Ptr);\n-      Set_Extended_Project_Of (Declarations, In_Tree, To => Extends);\n-      Set_Project_Declaration_Of (Current_Project, In_Tree, Declarations);\n-      Parse_Declarative_Items\n-        (Declarations      => First_Declarative_Item,\n-         In_Tree           => In_Tree,\n-         In_Zone           => In_Project,\n-         First_Attribute   => Prj.Attr.Attribute_First,\n-         Current_Project   => Current_Project,\n-         Current_Package   => Empty_Node,\n-         Packages_To_Check => Packages_To_Check,\n-         Is_Config_File    => Is_Config_File,\n-         Flags             => Flags);\n-      Set_First_Declarative_Item_Of\n-        (Declarations, In_Tree, To => First_Declarative_Item);\n-   end Parse;\n-\n-   -----------------------------------\n-   -- Rename_Obsolescent_Attributes --\n-   -----------------------------------\n-\n-   procedure Rename_Obsolescent_Attributes\n-     (In_Tree         : Project_Node_Tree_Ref;\n-      Attribute       : Project_Node_Id;\n-      Current_Package : Project_Node_Id)\n-   is\n-   begin\n-      if Present (Current_Package)\n-        and then Expression_Kind_Of (Current_Package, In_Tree) /= Ignored\n-      then\n-         case Name_Of (Attribute, In_Tree) is\n-            when Snames.Name_Specification =>\n-               Set_Name_Of (Attribute, In_Tree, To => Snames.Name_Spec);\n-\n-            when Snames.Name_Specification_Suffix =>\n-               Set_Name_Of (Attribute, In_Tree, To => Snames.Name_Spec_Suffix);\n-\n-            when Snames.Name_Implementation =>\n-               Set_Name_Of (Attribute, In_Tree, To => Snames.Name_Body);\n-\n-            when Snames.Name_Implementation_Suffix =>\n-               Set_Name_Of (Attribute, In_Tree, To => Snames.Name_Body_Suffix);\n-\n-            when others =>\n-               null;\n-         end case;\n-      end if;\n-   end Rename_Obsolescent_Attributes;\n-\n-   ---------------------------\n-   -- Check_Package_Allowed --\n-   ---------------------------\n-\n-   procedure Check_Package_Allowed\n-     (In_Tree         : Project_Node_Tree_Ref;\n-      Project         : Project_Node_Id;\n-      Current_Package : Project_Node_Id;\n-      Flags           : Processing_Flags)\n-   is\n-      Qualif : constant Project_Qualifier :=\n-                 Project_Qualifier_Of (Project, In_Tree);\n-      Name   : constant Name_Id := Name_Of (Current_Package, In_Tree);\n-   begin\n-      if Name /= Snames.Name_Ide\n-        and then\n-          ((Qualif = Aggregate         and then Name /= Snames.Name_Builder)\n-              or else\n-           (Qualif = Aggregate_Library and then Name /= Snames.Name_Builder\n-                                       and then Name /= Snames.Name_Install))\n-      then\n-         Error_Msg_Name_1 := Name;\n-         Error_Msg\n-           (Flags,\n-            \"package %% is forbidden in aggregate projects\",\n-            Location_Of (Current_Package, In_Tree));\n-      end if;\n-   end Check_Package_Allowed;\n-\n-   -----------------------------\n-   -- Check_Attribute_Allowed --\n-   -----------------------------\n-\n-   procedure Check_Attribute_Allowed\n-     (In_Tree   : Project_Node_Tree_Ref;\n-      Project   : Project_Node_Id;\n-      Attribute : Project_Node_Id;\n-      Flags     : Processing_Flags)\n-   is\n-      Qualif : constant Project_Qualifier :=\n-                 Project_Qualifier_Of (Project, In_Tree);\n-      Name   : constant Name_Id := Name_Of (Attribute, In_Tree);\n-\n-   begin\n-      case Qualif is\n-         when Aggregate\n-            | Aggregate_Library\n-         =>\n-            if        Name = Snames.Name_Languages\n-              or else Name = Snames.Name_Source_Files\n-              or else Name = Snames.Name_Source_List_File\n-              or else Name = Snames.Name_Locally_Removed_Files\n-              or else Name = Snames.Name_Excluded_Source_Files\n-              or else Name = Snames.Name_Excluded_Source_List_File\n-              or else Name = Snames.Name_Interfaces\n-              or else Name = Snames.Name_Object_Dir\n-              or else Name = Snames.Name_Exec_Dir\n-              or else Name = Snames.Name_Source_Dirs\n-              or else Name = Snames.Name_Inherit_Source_Path\n-              or else\n-                (Qualif = Aggregate and then Name = Snames.Name_Library_Dir)\n-              or else\n-                (Qualif = Aggregate and then Name = Snames.Name_Library_Name)\n-              or else Name = Snames.Name_Main\n-              or else Name = Snames.Name_Roots\n-              or else Name = Snames.Name_Externally_Built\n-              or else Name = Snames.Name_Executable\n-              or else Name = Snames.Name_Executable_Suffix\n-              or else Name = Snames.Name_Default_Switches\n-            then\n-               Error_Msg_Name_1 := Name;\n-               Error_Msg\n-                 (Flags,\n-                  \"%% is not valid in aggregate projects\",\n-                  Location_Of (Attribute, In_Tree));\n-            end if;\n-\n-         when others =>\n-            if Name = Snames.Name_Project_Files\n-              or else Name = Snames.Name_Project_Path\n-              or else Name = Snames.Name_External\n-            then\n-               Error_Msg_Name_1 := Name;\n-               Error_Msg\n-                 (Flags,\n-                  \"%% is only valid in aggregate projects\",\n-                  Location_Of (Attribute, In_Tree));\n-            end if;\n-      end case;\n-   end Check_Attribute_Allowed;\n-\n-   ---------------------------------\n-   -- Parse_Attribute_Declaration --\n-   ---------------------------------\n-\n-   procedure Parse_Attribute_Declaration\n-     (In_Tree           : Project_Node_Tree_Ref;\n-      Attribute         : out Project_Node_Id;\n-      First_Attribute   : Attribute_Node_Id;\n-      Current_Project   : Project_Node_Id;\n-      Current_Package   : Project_Node_Id;\n-      Packages_To_Check : String_List_Access;\n-      Flags             : Processing_Flags)\n-   is\n-      Current_Attribute      : Attribute_Node_Id := First_Attribute;\n-      Full_Associative_Array : Boolean           := False;\n-      Attribute_Name         : Name_Id           := No_Name;\n-      Optional_Index         : Boolean           := False;\n-      Pkg_Id                 : Package_Node_Id   := Empty_Package;\n-\n-      procedure Process_Attribute_Name;\n-      --  Read the name of the attribute, and check its type\n-\n-      procedure Process_Associative_Array_Index;\n-      --  Read the index of the associative array and check its validity\n-\n-      ----------------------------\n-      -- Process_Attribute_Name --\n-      ----------------------------\n-\n-      procedure Process_Attribute_Name is\n-         Ignore : Boolean;\n-\n-      begin\n-         Attribute_Name := Token_Name;\n-         Set_Name_Of (Attribute, In_Tree, To => Attribute_Name);\n-         Set_Location_Of (Attribute, In_Tree, To => Token_Ptr);\n-\n-         --  Find the attribute\n-\n-         Current_Attribute :=\n-           Attribute_Node_Id_Of (Attribute_Name, First_Attribute);\n-\n-         --  If the attribute cannot be found, create the attribute if inside\n-         --  an unknown package.\n-\n-         if Current_Attribute = Empty_Attribute then\n-            if Present (Current_Package)\n-              and then Expression_Kind_Of (Current_Package, In_Tree) = Ignored\n-            then\n-               Pkg_Id := Package_Id_Of (Current_Package, In_Tree);\n-               Add_Attribute (Pkg_Id, Token_Name, Current_Attribute);\n-\n-            else\n-               --  If not a valid attribute name, issue an error if inside\n-               --  a package that need to be checked.\n-\n-               Ignore := Present (Current_Package) and then\n-                          Packages_To_Check /= All_Packages;\n-\n-               if Ignore then\n-\n-                  --  Check that we are not in a package to check\n-\n-                  Get_Name_String (Name_Of (Current_Package, In_Tree));\n-\n-                  for Index in Packages_To_Check'Range loop\n-                     if Name_Buffer (1 .. Name_Len) =\n-                       Packages_To_Check (Index).all\n-                     then\n-                        Ignore := False;\n-                        exit;\n-                     end if;\n-                  end loop;\n-               end if;\n-\n-               if not Ignore then\n-                  Error_Msg_Name_1 := Token_Name;\n-                  Error_Msg (Flags, \"undefined attribute %%\", Token_Ptr);\n-               end if;\n-            end if;\n-\n-         --  Set, if appropriate the index case insensitivity flag\n-\n-         else\n-            if Is_Read_Only (Current_Attribute) then\n-               Error_Msg_Name_1 := Token_Name;\n-               Error_Msg\n-                 (Flags, \"read-only attribute %% cannot be given a value\",\n-                  Token_Ptr);\n-            end if;\n-\n-            if Attribute_Kind_Of (Current_Attribute) in\n-                 All_Case_Insensitive_Associative_Array\n-            then\n-               Set_Case_Insensitive (Attribute, In_Tree, To => True);\n-            end if;\n-         end if;\n-\n-         Scan (In_Tree); --  past the attribute name\n-\n-         --  Set the expression kind of the attribute\n-\n-         if Current_Attribute /= Empty_Attribute then\n-            Set_Expression_Kind_Of\n-              (Attribute, In_Tree, To => Variable_Kind_Of (Current_Attribute));\n-            Optional_Index := Optional_Index_Of (Current_Attribute);\n-         end if;\n-      end Process_Attribute_Name;\n-\n-      -------------------------------------\n-      -- Process_Associative_Array_Index --\n-      -------------------------------------\n-\n-      procedure Process_Associative_Array_Index is\n-      begin\n-         --  If the attribute is not an associative array attribute, report\n-         --  an error. If this information is still unknown, set the kind\n-         --  to Associative_Array.\n-\n-         if Current_Attribute /= Empty_Attribute\n-           and then Attribute_Kind_Of (Current_Attribute) = Single\n-         then\n-            Error_Msg (Flags,\n-                       \"the attribute \"\"\" &\n-                       Get_Name_String (Attribute_Name_Of (Current_Attribute))\n-                       & \"\"\" cannot be an associative array\",\n-                       Location_Of (Attribute, In_Tree));\n-\n-         elsif Attribute_Kind_Of (Current_Attribute) = Unknown then\n-            Set_Attribute_Kind_Of (Current_Attribute, To => Associative_Array);\n-         end if;\n-\n-         Scan (In_Tree); --  past the left parenthesis\n-\n-         if Others_Allowed_For (Current_Attribute)\n-           and then Token = Tok_Others\n-         then\n-            Set_Associative_Array_Index_Of\n-              (Attribute, In_Tree, All_Other_Names);\n-            Scan (In_Tree); --  past others\n-\n-         else\n-            if Others_Allowed_For (Current_Attribute) then\n-               Expect (Tok_String_Literal, \"literal string or others\");\n-            else\n-               Expect (Tok_String_Literal, \"literal string\");\n-            end if;\n-\n-            if Token = Tok_String_Literal then\n-               Get_Name_String (Token_Name);\n-\n-               if Case_Insensitive (Attribute, In_Tree) then\n-                  To_Lower (Name_Buffer (1 .. Name_Len));\n-               end if;\n-\n-               Set_Associative_Array_Index_Of (Attribute, In_Tree, Name_Find);\n-               Scan (In_Tree); --  past the literal string index\n-\n-               if Token = Tok_At then\n-                  case Attribute_Kind_Of (Current_Attribute) is\n-                     when Optional_Index_Associative_Array\n-                        | Optional_Index_Case_Insensitive_Associative_Array\n-                     =>\n-                        Scan (In_Tree);\n-                        Expect (Tok_Integer_Literal, \"integer literal\");\n-\n-                        if Token = Tok_Integer_Literal then\n-\n-                           --  Set the source index value from given literal\n-\n-                           declare\n-                              Index : constant Int :=\n-                                        UI_To_Int (Int_Literal_Value);\n-                           begin\n-                              if Index = 0 then\n-                                 Error_Msg\n-                                   (Flags, \"index cannot be zero\", Token_Ptr);\n-                              else\n-                                 Set_Source_Index_Of\n-                                   (Attribute, In_Tree, To => Index);\n-                              end if;\n-                           end;\n-\n-                           Scan (In_Tree);\n-                        end if;\n-\n-                     when others =>\n-                        Error_Msg (Flags, \"index not allowed here\", Token_Ptr);\n-                        Scan (In_Tree);\n-\n-                        if Token = Tok_Integer_Literal then\n-                           Scan (In_Tree);\n-                        end if;\n-                  end case;\n-               end if;\n-            end if;\n-         end if;\n-\n-         Expect (Tok_Right_Paren, \"`)`\");\n-\n-         if Token = Tok_Right_Paren then\n-            Scan (In_Tree); --  past the right parenthesis\n-         end if;\n-      end Process_Associative_Array_Index;\n-\n-   begin\n-      Attribute :=\n-        Default_Project_Node\n-          (Of_Kind => N_Attribute_Declaration, In_Tree => In_Tree);\n-      Set_Location_Of (Attribute, In_Tree, To => Token_Ptr);\n-      Set_Previous_Line_Node (Attribute);\n-\n-      --  Scan past \"for\"\n-\n-      Scan (In_Tree);\n-\n-      --  Body or External may be an attribute name\n-\n-      if Token = Tok_Body then\n-         Token := Tok_Identifier;\n-         Token_Name := Snames.Name_Body;\n-      end if;\n-\n-      if Token = Tok_External then\n-         Token := Tok_Identifier;\n-         Token_Name := Snames.Name_External;\n-      end if;\n-\n-      Expect (Tok_Identifier, \"identifier\");\n-      Process_Attribute_Name;\n-      Rename_Obsolescent_Attributes (In_Tree, Attribute, Current_Package);\n-      Check_Attribute_Allowed (In_Tree, Current_Project, Attribute, Flags);\n-\n-      --  Associative array attributes\n-\n-      if Token = Tok_Left_Paren then\n-         Process_Associative_Array_Index;\n-\n-      else\n-         --  If it is an associative array attribute and there are no left\n-         --  parenthesis, then this is a full associative array declaration.\n-         --  Flag it as such for later processing of its value.\n-\n-         if Current_Attribute /= Empty_Attribute\n-           and then\n-             Attribute_Kind_Of (Current_Attribute) /= Single\n-         then\n-            if Attribute_Kind_Of (Current_Attribute) = Unknown then\n-               Set_Attribute_Kind_Of (Current_Attribute, To => Single);\n-\n-            else\n-               Full_Associative_Array := True;\n-            end if;\n-         end if;\n-      end if;\n-\n-      Expect (Tok_Use, \"USE\");\n-\n-      if Token = Tok_Use then\n-         Scan (In_Tree);\n-\n-         if Full_Associative_Array then\n-\n-            --  Expect <project>'<same_attribute_name>, or\n-            --  <project>.<same_package_name>'<same_attribute_name>\n-\n-            declare\n-               The_Project : Project_Node_Id := Empty_Node;\n-               --  The node of the project where the associative array is\n-               --  declared.\n-\n-               The_Package : Project_Node_Id := Empty_Node;\n-               --  The node of the package where the associative array is\n-               --  declared, if any.\n-\n-               Project_Name : Name_Id := No_Name;\n-               --  The name of the project where the associative array is\n-               --  declared.\n-\n-               Location : Source_Ptr := No_Location;\n-               --  The location of the project name\n-\n-            begin\n-               Expect (Tok_Identifier, \"identifier\");\n-\n-               if Token = Tok_Identifier then\n-                  Location := Token_Ptr;\n-\n-                  --  Find the project node in the imported project or\n-                  --  in the project being extended.\n-\n-                  The_Project := Imported_Or_Extended_Project_Of\n-                                   (Current_Project, In_Tree, Token_Name);\n-\n-                  if No (The_Project) and then not In_Tree.Incomplete_With then\n-                     Error_Msg (Flags, \"unknown project\", Location);\n-                     Scan (In_Tree); --  past the project name\n-\n-                  else\n-                     Project_Name := Token_Name;\n-                     Scan (In_Tree); --  past the project name\n-\n-                     --  If this is inside a package, a dot followed by the\n-                     --  name of the package must followed the project name.\n-\n-                     if Present (Current_Package) then\n-                        Expect (Tok_Dot, \"`.`\");\n-\n-                        if Token /= Tok_Dot then\n-                           The_Project := Empty_Node;\n-\n-                        else\n-                           Scan (In_Tree); --  past the dot\n-                           Expect (Tok_Identifier, \"identifier\");\n-\n-                           if Token /= Tok_Identifier then\n-                              The_Project := Empty_Node;\n-\n-                           --  If it is not the same package name, issue error\n-\n-                           elsif\n-                             Token_Name /= Name_Of (Current_Package, In_Tree)\n-                           then\n-                              The_Project := Empty_Node;\n-                              Error_Msg\n-                                (Flags, \"not the same package as \" &\n-                                 Get_Name_String\n-                                   (Name_Of (Current_Package, In_Tree)),\n-                                 Token_Ptr);\n-                              Scan (In_Tree); --  past the package name\n-\n-                           else\n-                              if Present (The_Project) then\n-                                 The_Package :=\n-                                   First_Package_Of (The_Project, In_Tree);\n-\n-                                 --  Look for the package node\n-\n-                                 while Present (The_Package)\n-                                   and then Name_Of (The_Package, In_Tree) /=\n-                                                                    Token_Name\n-                                 loop\n-                                    The_Package :=\n-                                      Next_Package_In_Project\n-                                        (The_Package, In_Tree);\n-                                 end loop;\n-\n-                                 --  If the package cannot be found in the\n-                                 --  project, issue an error.\n-\n-                                 if No (The_Package) then\n-                                    The_Project := Empty_Node;\n-                                    Error_Msg_Name_2 := Project_Name;\n-                                    Error_Msg_Name_1 := Token_Name;\n-                                    Error_Msg\n-                                      (Flags,\n-                                       \"package % not declared in project %\",\n-                                       Token_Ptr);\n-                                 end if;\n-                              end if;\n-\n-                              Scan (In_Tree); --  past the package name\n-                           end if;\n-                        end if;\n-                     end if;\n-                  end if;\n-               end if;\n-\n-               if Present (The_Project) or else In_Tree.Incomplete_With then\n-\n-                  --  Looking for '<same attribute name>\n-\n-                  Expect (Tok_Apostrophe, \"`''`\");\n-\n-                  if Token /= Tok_Apostrophe then\n-                     The_Project := Empty_Node;\n-\n-                  else\n-                     Scan (In_Tree); --  past the apostrophe\n-                     Expect (Tok_Identifier, \"identifier\");\n-\n-                     if Token /= Tok_Identifier then\n-                        The_Project := Empty_Node;\n-\n-                     else\n-                        --  If it is not the same attribute name, issue error\n-\n-                        if Token_Name /= Attribute_Name then\n-                           The_Project := Empty_Node;\n-                           Error_Msg_Name_1 := Attribute_Name;\n-                           Error_Msg\n-                             (Flags, \"invalid name, should be %\", Token_Ptr);\n-                        end if;\n-\n-                        Scan (In_Tree); --  past the attribute name\n-                     end if;\n-                  end if;\n-               end if;\n-\n-               if No (The_Project) then\n-\n-                  --  If there were any problem, set the attribute id to null,\n-                  --  so that the node will not be recorded.\n-\n-                  Current_Attribute := Empty_Attribute;\n-\n-               else\n-                  --  Set the appropriate field in the node.\n-                  --  Note that the index and the expression are nil. This\n-                  --  characterizes full associative array attribute\n-                  --  declarations.\n-\n-                  Set_Associative_Project_Of (Attribute, In_Tree, The_Project);\n-                  Set_Associative_Package_Of (Attribute, In_Tree, The_Package);\n-               end if;\n-            end;\n-\n-         --  Other attribute declarations (not full associative array)\n-\n-         else\n-            declare\n-               Expression_Location : constant Source_Ptr := Token_Ptr;\n-               --  The location of the first token of the expression\n-\n-               Expression          : Project_Node_Id     := Empty_Node;\n-               --  The expression, value for the attribute declaration\n-\n-            begin\n-               --  Get the expression value and set it in the attribute node\n-\n-               Parse_Expression\n-                 (In_Tree         => In_Tree,\n-                  Expression      => Expression,\n-                  Flags           => Flags,\n-                  Current_Project => Current_Project,\n-                  Current_Package => Current_Package,\n-                  Optional_Index  => Optional_Index);\n-               Set_Expression_Of (Attribute, In_Tree, To => Expression);\n-\n-               --  If the expression is legal, but not of the right kind\n-               --  for the attribute, issue an error.\n-\n-               if Current_Attribute /= Empty_Attribute\n-                 and then Present (Expression)\n-                 and then Variable_Kind_Of (Current_Attribute) /=\n-                 Expression_Kind_Of (Expression, In_Tree)\n-               then\n-                  if Variable_Kind_Of (Current_Attribute) = Undefined then\n-                     Set_Variable_Kind_Of\n-                       (Current_Attribute,\n-                        To => Expression_Kind_Of (Expression, In_Tree));\n-\n-                  else\n-                     Error_Msg\n-                       (Flags, \"wrong expression kind for attribute \"\"\" &\n-                        Get_Name_String\n-                          (Attribute_Name_Of (Current_Attribute)) &\n-                        \"\"\"\",\n-                        Expression_Location);\n-                  end if;\n-               end if;\n-            end;\n-         end if;\n-      end if;\n-\n-      --  If the attribute was not recognized, return an empty node.\n-      --  It may be that it is not in a package to check, and the node will\n-      --  not be added to the tree.\n-\n-      if Current_Attribute = Empty_Attribute then\n-         Attribute := Empty_Node;\n-      end if;\n-\n-      Set_End_Of_Line (Attribute);\n-      Set_Previous_Line_Node (Attribute);\n-   end Parse_Attribute_Declaration;\n-\n-   -----------------------------\n-   -- Parse_Case_Construction --\n-   -----------------------------\n-\n-   procedure Parse_Case_Construction\n-     (In_Tree           : Project_Node_Tree_Ref;\n-      Case_Construction : out Project_Node_Id;\n-      First_Attribute   : Attribute_Node_Id;\n-      Current_Project   : Project_Node_Id;\n-      Current_Package   : Project_Node_Id;\n-      Packages_To_Check : String_List_Access;\n-      Is_Config_File    : Boolean;\n-      Flags             : Processing_Flags)\n-   is\n-      Current_Item    : Project_Node_Id := Empty_Node;\n-      Next_Item       : Project_Node_Id := Empty_Node;\n-      First_Case_Item : Boolean := True;\n-\n-      Variable_Location : Source_Ptr := No_Location;\n-\n-      String_Type : Project_Node_Id := Empty_Node;\n-\n-      Case_Variable : Project_Node_Id := Empty_Node;\n-\n-      First_Declarative_Item : Project_Node_Id := Empty_Node;\n-\n-      First_Choice           : Project_Node_Id := Empty_Node;\n-\n-      When_Others            : Boolean := False;\n-      --  Set to True when there is a \"when others =>\" clause\n-\n-   begin\n-      Case_Construction  :=\n-        Default_Project_Node\n-          (Of_Kind => N_Case_Construction, In_Tree => In_Tree);\n-      Set_Location_Of (Case_Construction, In_Tree, To => Token_Ptr);\n-\n-      --  Scan past \"case\"\n-\n-      Scan (In_Tree);\n-\n-      --  Get the switch variable\n-\n-      Expect (Tok_Identifier, \"identifier\");\n-\n-      if Token = Tok_Identifier then\n-         Variable_Location := Token_Ptr;\n-         Parse_Variable_Reference\n-           (In_Tree         => In_Tree,\n-            Variable        => Case_Variable,\n-            Flags           => Flags,\n-            Current_Project => Current_Project,\n-            Current_Package => Current_Package);\n-         Set_Case_Variable_Reference_Of\n-           (Case_Construction, In_Tree, To => Case_Variable);\n-\n-      else\n-         if Token /= Tok_Is then\n-            Scan (In_Tree);\n-         end if;\n-      end if;\n-\n-      if Present (Case_Variable) then\n-         String_Type := String_Type_Of (Case_Variable, In_Tree);\n-\n-         if Expression_Kind_Of (Case_Variable, In_Tree) /= Single then\n-            Error_Msg (Flags,\n-                       \"variable \"\"\" &\n-                       Get_Name_String (Name_Of (Case_Variable, In_Tree)) &\n-                       \"\"\" is not a single string\",\n-                       Variable_Location);\n-         end if;\n-      end if;\n-\n-      Expect (Tok_Is, \"IS\");\n-\n-      if Token = Tok_Is then\n-         Set_End_Of_Line (Case_Construction);\n-         Set_Previous_Line_Node (Case_Construction);\n-         Set_Next_End_Node (Case_Construction);\n-\n-         --  Scan past \"is\"\n-\n-         Scan (In_Tree);\n-      end if;\n-\n-      Start_New_Case_Construction (In_Tree, String_Type);\n-\n-      When_Loop :\n-\n-      while Token = Tok_When loop\n-\n-         if First_Case_Item then\n-            Current_Item :=\n-              Default_Project_Node\n-                (Of_Kind => N_Case_Item, In_Tree => In_Tree);\n-            Set_First_Case_Item_Of\n-              (Case_Construction, In_Tree, To => Current_Item);\n-            First_Case_Item := False;\n-\n-         else\n-            Next_Item :=\n-              Default_Project_Node\n-                (Of_Kind => N_Case_Item, In_Tree => In_Tree);\n-            Set_Next_Case_Item (Current_Item, In_Tree, To => Next_Item);\n-            Current_Item := Next_Item;\n-         end if;\n-\n-         Set_Location_Of (Current_Item, In_Tree, To => Token_Ptr);\n-\n-         --  Scan past \"when\"\n-\n-         Scan (In_Tree);\n-\n-         if Token = Tok_Others then\n-            When_Others := True;\n-\n-            --  Scan past \"others\"\n-\n-            Scan (In_Tree);\n-\n-            Expect (Tok_Arrow, \"`=>`\");\n-            Set_End_Of_Line (Current_Item);\n-            Set_Previous_Line_Node (Current_Item);\n-\n-            --  Empty_Node in Field1 of a Case_Item indicates\n-            --  the \"when others =>\" branch.\n-\n-            Set_First_Choice_Of (Current_Item, In_Tree, To => Empty_Node);\n-\n-            Parse_Declarative_Items\n-              (In_Tree           => In_Tree,\n-               Declarations      => First_Declarative_Item,\n-               In_Zone           => In_Case_Construction,\n-               First_Attribute   => First_Attribute,\n-               Current_Project   => Current_Project,\n-               Current_Package   => Current_Package,\n-               Packages_To_Check => Packages_To_Check,\n-               Is_Config_File    => Is_Config_File,\n-               Flags             => Flags);\n-\n-            --  \"when others =>\" must be the last branch, so save the\n-            --  Case_Item and exit\n-\n-            Set_First_Declarative_Item_Of\n-              (Current_Item, In_Tree, To => First_Declarative_Item);\n-            exit When_Loop;\n-\n-         else\n-            Parse_Choice_List\n-              (In_Tree      => In_Tree,\n-               First_Choice => First_Choice,\n-               Flags        => Flags,\n-               String_Type  => Present (String_Type));\n-            Set_First_Choice_Of (Current_Item, In_Tree, To => First_Choice);\n-\n-            Expect (Tok_Arrow, \"`=>`\");\n-            Set_End_Of_Line (Current_Item);\n-            Set_Previous_Line_Node (Current_Item);\n-\n-            Parse_Declarative_Items\n-              (In_Tree           => In_Tree,\n-               Declarations      => First_Declarative_Item,\n-               In_Zone           => In_Case_Construction,\n-               First_Attribute   => First_Attribute,\n-               Current_Project   => Current_Project,\n-               Current_Package   => Current_Package,\n-               Packages_To_Check => Packages_To_Check,\n-               Is_Config_File    => Is_Config_File,\n-               Flags             => Flags);\n-\n-            Set_First_Declarative_Item_Of\n-              (Current_Item, In_Tree, To => First_Declarative_Item);\n-\n-         end if;\n-      end loop When_Loop;\n-\n-      End_Case_Construction\n-        (Check_All_Labels => not When_Others and not Quiet_Output,\n-         Case_Location    => Location_Of (Case_Construction, In_Tree),\n-         Flags            => Flags,\n-         String_Type      => Present (String_Type));\n-\n-      Expect (Tok_End, \"`END CASE`\");\n-      Remove_Next_End_Node;\n-\n-      if Token = Tok_End then\n-\n-         --  Scan past \"end\"\n-\n-         Scan (In_Tree);\n-\n-         Expect (Tok_Case, \"CASE\");\n-\n-      end if;\n-\n-      --  Scan past \"case\"\n-\n-      Scan (In_Tree);\n-\n-      Expect (Tok_Semicolon, \"`;`\");\n-      Set_Previous_End_Node (Case_Construction);\n-\n-   end Parse_Case_Construction;\n-\n-   -----------------------------\n-   -- Parse_Declarative_Items --\n-   -----------------------------\n-\n-   procedure Parse_Declarative_Items\n-     (In_Tree           : Project_Node_Tree_Ref;\n-      Declarations      : out Project_Node_Id;\n-      In_Zone           : Zone;\n-      First_Attribute   : Attribute_Node_Id;\n-      Current_Project   : Project_Node_Id;\n-      Current_Package   : Project_Node_Id;\n-      Packages_To_Check : String_List_Access;\n-      Is_Config_File    : Boolean;\n-      Flags             : Processing_Flags)\n-   is\n-      Current_Declarative_Item : Project_Node_Id := Empty_Node;\n-      Next_Declarative_Item    : Project_Node_Id := Empty_Node;\n-      Current_Declaration      : Project_Node_Id := Empty_Node;\n-      Item_Location            : Source_Ptr      := No_Location;\n-\n-   begin\n-      Declarations := Empty_Node;\n-\n-      loop\n-         --  We are always positioned at the token that precedes the first\n-         --  token of the declarative element. Scan past it.\n-\n-         Scan (In_Tree);\n-\n-         Item_Location := Token_Ptr;\n-\n-         case Token is\n-            when Tok_Identifier =>\n-\n-               if In_Zone = In_Case_Construction then\n-\n-                  --  Check if the variable has already been declared\n-\n-                  declare\n-                     The_Variable : Project_Node_Id := Empty_Node;\n-\n-                  begin\n-                     if Present (Current_Package) then\n-                        The_Variable :=\n-                          First_Variable_Of (Current_Package, In_Tree);\n-                     elsif Present (Current_Project) then\n-                        The_Variable :=\n-                          First_Variable_Of (Current_Project, In_Tree);\n-                     end if;\n-\n-                     while Present (The_Variable)\n-                       and then Name_Of (The_Variable, In_Tree) /=\n-                                  Token_Name\n-                     loop\n-                        The_Variable := Next_Variable (The_Variable, In_Tree);\n-                     end loop;\n-\n-                     --  It is an error to declare a variable in a case\n-                     --  construction for the first time.\n-\n-                     if No (The_Variable) then\n-                        Error_Msg\n-                          (Flags, \"a variable cannot be declared for the \"\n-                           & \"first time here\", Token_Ptr);\n-                     end if;\n-                  end;\n-               end if;\n-\n-               Parse_Variable_Declaration\n-                 (In_Tree,\n-                  Current_Declaration,\n-                  Current_Project => Current_Project,\n-                  Current_Package => Current_Package,\n-                  Flags           => Flags);\n-\n-               Set_End_Of_Line (Current_Declaration);\n-               Set_Previous_Line_Node (Current_Declaration);\n-\n-            when Tok_For =>\n-               Parse_Attribute_Declaration\n-                 (In_Tree           => In_Tree,\n-                  Attribute         => Current_Declaration,\n-                  First_Attribute   => First_Attribute,\n-                  Current_Project   => Current_Project,\n-                  Current_Package   => Current_Package,\n-                  Packages_To_Check => Packages_To_Check,\n-                  Flags             => Flags);\n-\n-               Set_End_Of_Line (Current_Declaration);\n-               Set_Previous_Line_Node (Current_Declaration);\n-\n-            when Tok_Null =>\n-               Scan (In_Tree); --  past \"null\"\n-\n-            when Tok_Package =>\n-\n-               --  Package declaration\n-\n-               if In_Zone /= In_Project then\n-                  Error_Msg\n-                    (Flags, \"a package cannot be declared here\", Token_Ptr);\n-               end if;\n-\n-               Parse_Package_Declaration\n-                 (In_Tree             => In_Tree,\n-                  Package_Declaration => Current_Declaration,\n-                  Current_Project     => Current_Project,\n-                  Packages_To_Check   => Packages_To_Check,\n-                  Is_Config_File      => Is_Config_File,\n-                  Flags               => Flags);\n-\n-               Set_Previous_End_Node (Current_Declaration);\n-\n-            when Tok_Type =>\n-\n-               --  Type String Declaration\n-\n-               if In_Zone /= In_Project then\n-                  Error_Msg (Flags,\n-                             \"a string type cannot be declared here\",\n-                             Token_Ptr);\n-               end if;\n-\n-               Parse_String_Type_Declaration\n-                 (In_Tree         => In_Tree,\n-                  String_Type     => Current_Declaration,\n-                  Current_Project => Current_Project,\n-                  Flags           => Flags);\n-\n-               Set_End_Of_Line (Current_Declaration);\n-               Set_Previous_Line_Node (Current_Declaration);\n-\n-            when Tok_Case =>\n-\n-               --  Case construction\n-\n-               Parse_Case_Construction\n-                 (In_Tree           => In_Tree,\n-                  Case_Construction => Current_Declaration,\n-                  First_Attribute   => First_Attribute,\n-                  Current_Project   => Current_Project,\n-                  Current_Package   => Current_Package,\n-                  Packages_To_Check => Packages_To_Check,\n-                  Is_Config_File    => Is_Config_File,\n-                  Flags             => Flags);\n-\n-               Set_Previous_End_Node (Current_Declaration);\n-\n-            when others =>\n-               exit;\n-\n-               --  We are leaving Parse_Declarative_Items positioned\n-               --  at the first token after the list of declarative items.\n-               --  It could be \"end\" (for a project, a package declaration or\n-               --  a case construction) or \"when\" (for a case construction)\n-\n-         end case;\n-\n-         Expect (Tok_Semicolon, \"`;` after declarative items\");\n-\n-         --  Insert an N_Declarative_Item in the tree, but only if\n-         --  Current_Declaration is not an empty node.\n-\n-         if Present (Current_Declaration) then\n-            if No (Current_Declarative_Item) then\n-               Current_Declarative_Item :=\n-                 Default_Project_Node\n-                   (Of_Kind => N_Declarative_Item, In_Tree => In_Tree);\n-               Declarations  := Current_Declarative_Item;\n-\n-            else\n-               Next_Declarative_Item :=\n-                 Default_Project_Node\n-                   (Of_Kind => N_Declarative_Item, In_Tree => In_Tree);\n-               Set_Next_Declarative_Item\n-                 (Current_Declarative_Item, In_Tree,\n-                  To => Next_Declarative_Item);\n-               Current_Declarative_Item := Next_Declarative_Item;\n-            end if;\n-\n-            Set_Current_Item_Node\n-              (Current_Declarative_Item, In_Tree,\n-               To => Current_Declaration);\n-            Set_Location_Of\n-              (Current_Declarative_Item, In_Tree, To => Item_Location);\n-         end if;\n-      end loop;\n-   end Parse_Declarative_Items;\n-\n-   -------------------------------\n-   -- Parse_Package_Declaration --\n-   -------------------------------\n-\n-   procedure Parse_Package_Declaration\n-     (In_Tree             : Project_Node_Tree_Ref;\n-      Package_Declaration : out Project_Node_Id;\n-      Current_Project     : Project_Node_Id;\n-      Packages_To_Check   : String_List_Access;\n-      Is_Config_File      : Boolean;\n-      Flags               : Processing_Flags)\n-   is\n-      First_Attribute        : Attribute_Node_Id := Empty_Attribute;\n-      Current_Package        : Package_Node_Id   := Empty_Package;\n-      First_Declarative_Item : Project_Node_Id   := Empty_Node;\n-      Package_Location       : constant Source_Ptr := Token_Ptr;\n-      Renaming               : Boolean := False;\n-      Extending              : Boolean := False;\n-\n-   begin\n-      Package_Declaration :=\n-        Default_Project_Node\n-          (Of_Kind => N_Package_Declaration, In_Tree => In_Tree);\n-      Set_Location_Of (Package_Declaration, In_Tree, To => Package_Location);\n-\n-      --  Scan past \"package\"\n-\n-      Scan (In_Tree);\n-      Expect (Tok_Identifier, \"identifier\");\n-\n-      if Token = Tok_Identifier then\n-         Set_Name_Of (Package_Declaration, In_Tree, To => Token_Name);\n-\n-         Current_Package := Package_Node_Id_Of (Token_Name);\n-\n-         if Current_Package = Empty_Package then\n-            if not Quiet_Output then\n-               declare\n-                  List  : constant Strings.String_List := Package_Name_List;\n-                  Index : Natural;\n-                  Name  : constant String := Get_Name_String (Token_Name);\n-\n-               begin\n-                  --  Check for possible misspelling of a known package name\n-\n-                  Index := 0;\n-                  loop\n-                     if Index >= List'Last then\n-                        Index := 0;\n-                        exit;\n-                     end if;\n-\n-                     Index := Index + 1;\n-                     exit when\n-                       GNAT.Spelling_Checker.Is_Bad_Spelling_Of\n-                         (Name, List (Index).all);\n-                  end loop;\n-\n-                  --  Issue warning(s) in verbose mode or when a possible\n-                  --  misspelling has been found.\n-\n-                  if Verbose_Mode or else Index /= 0 then\n-                     Error_Msg (Flags,\n-                                \"?\"\"\" &\n-                                Get_Name_String\n-                                 (Name_Of (Package_Declaration, In_Tree)) &\n-                                \"\"\" is not a known package name\",\n-                                Token_Ptr);\n-                  end if;\n-\n-                  if Index /= 0 then\n-                     Error_Msg -- CODEFIX\n-                       (Flags,\n-                        \"\\?possible misspelling of \"\"\" &\n-                        List (Index).all & \"\"\"\", Token_Ptr);\n-                  end if;\n-               end;\n-            end if;\n-\n-            --  Set the package declaration to \"ignored\" so that it is not\n-            --  processed by Prj.Proc.Process.\n-\n-            Set_Expression_Kind_Of (Package_Declaration, In_Tree, Ignored);\n-\n-            --  Add the unknown package in the list of packages\n-\n-            Add_Unknown_Package (Token_Name, Current_Package);\n-\n-         elsif Current_Package = Unknown_Package then\n-\n-            --  Set the package declaration to \"ignored\" so that it is not\n-            --  processed by Prj.Proc.Process.\n-\n-            Set_Expression_Kind_Of (Package_Declaration, In_Tree, Ignored);\n-\n-         else\n-            First_Attribute := First_Attribute_Of (Current_Package);\n-         end if;\n-\n-         Set_Package_Id_Of\n-           (Package_Declaration, In_Tree, To => Current_Package);\n-\n-         declare\n-            Current : Project_Node_Id :=\n-                        First_Package_Of (Current_Project, In_Tree);\n-\n-         begin\n-            while Present (Current)\n-              and then Name_Of (Current, In_Tree) /= Token_Name\n-            loop\n-               Current := Next_Package_In_Project (Current, In_Tree);\n-            end loop;\n-\n-            if Present (Current) then\n-               Error_Msg\n-                 (Flags,\n-                  \"package \"\"\" &\n-                  Get_Name_String (Name_Of (Package_Declaration, In_Tree)) &\n-                  \"\"\" is declared twice in the same project\",\n-                  Token_Ptr);\n-\n-            else\n-               --  Add the package to the project list\n-\n-               Set_Next_Package_In_Project\n-                 (Package_Declaration, In_Tree,\n-                  To => First_Package_Of (Current_Project, In_Tree));\n-               Set_First_Package_Of\n-                 (Current_Project, In_Tree, To => Package_Declaration);\n-            end if;\n-         end;\n-\n-         --  Scan past the package name\n-\n-         Scan (In_Tree);\n-      end if;\n-\n-      Check_Package_Allowed\n-        (In_Tree, Current_Project, Package_Declaration, Flags);\n-\n-      if Token = Tok_Renames then\n-         Renaming := True;\n-      elsif Token = Tok_Extends then\n-         Extending := True;\n-      end if;\n-\n-      if Renaming or else Extending then\n-         if Is_Config_File then\n-            Error_Msg\n-              (Flags,\n-               \"no package rename or extension in configuration projects\",\n-               Token_Ptr);\n-         end if;\n-\n-         --  Scan past \"renames\" or \"extends\"\n-\n-         Scan (In_Tree);\n-\n-         Expect (Tok_Identifier, \"identifier\");\n-\n-         if Token = Tok_Identifier then\n-            declare\n-               Project_Name : constant Name_Id := Token_Name;\n-\n-               Clause       : Project_Node_Id :=\n-                              First_With_Clause_Of (Current_Project, In_Tree);\n-               The_Project  : Project_Node_Id := Empty_Node;\n-               Extended     : constant Project_Node_Id :=\n-                                Extended_Project_Of\n-                                  (Project_Declaration_Of\n-                                    (Current_Project, In_Tree),\n-                                   In_Tree);\n-            begin\n-               while Present (Clause) loop\n-                  --  Only non limited imported projects may be used in a\n-                  --  renames declaration.\n-\n-                  The_Project :=\n-                    Non_Limited_Project_Node_Of (Clause, In_Tree);\n-                  exit when Present (The_Project)\n-                    and then Name_Of (The_Project, In_Tree) = Project_Name;\n-                  Clause := Next_With_Clause_Of (Clause, In_Tree);\n-               end loop;\n-\n-               if No (Clause) then\n-                  --  As we have not found the project in the imports, we check\n-                  --  if it's the name of an eventual extended project.\n-\n-                  if Present (Extended)\n-                    and then Name_Of (Extended, In_Tree) = Project_Name\n-                  then\n-                     Set_Project_Of_Renamed_Package_Of\n-                       (Package_Declaration, In_Tree, To => Extended);\n-                  else\n-                     Error_Msg_Name_1 := Project_Name;\n-                     Error_Msg\n-                       (Flags,\n-                        \"% is not an imported or extended project\", Token_Ptr);\n-                  end if;\n-               else\n-                  Set_Project_Of_Renamed_Package_Of\n-                    (Package_Declaration, In_Tree, To => The_Project);\n-               end if;\n-            end;\n-\n-            Scan (In_Tree);\n-            Expect (Tok_Dot, \"`.`\");\n-\n-            if Token = Tok_Dot then\n-               Scan (In_Tree);\n-               Expect (Tok_Identifier, \"identifier\");\n-\n-               if Token = Tok_Identifier then\n-                  if Name_Of (Package_Declaration, In_Tree) /= Token_Name then\n-                     Error_Msg (Flags, \"not the same package name\", Token_Ptr);\n-                  elsif\n-                    Present (Project_Of_Renamed_Package_Of\n-                               (Package_Declaration, In_Tree))\n-                  then\n-                     declare\n-                        Current : Project_Node_Id :=\n-                                    First_Package_Of\n-                                      (Project_Of_Renamed_Package_Of\n-                                           (Package_Declaration, In_Tree),\n-                                       In_Tree);\n-\n-                     begin\n-                        while Present (Current)\n-                          and then Name_Of (Current, In_Tree) /= Token_Name\n-                        loop\n-                           Current :=\n-                             Next_Package_In_Project (Current, In_Tree);\n-                        end loop;\n-\n-                        if No (Current) then\n-                           Error_Msg\n-                             (Flags, \"\"\"\" &\n-                              Get_Name_String (Token_Name) &\n-                              \"\"\" is not a package declared by the project\",\n-                              Token_Ptr);\n-                        end if;\n-                     end;\n-                  end if;\n-\n-                  Scan (In_Tree);\n-               end if;\n-            end if;\n-         end if;\n-      end if;\n-\n-      if Renaming then\n-         Expect (Tok_Semicolon, \"`;`\");\n-         Set_End_Of_Line (Package_Declaration);\n-         Set_Previous_Line_Node (Package_Declaration);\n-\n-      elsif Token = Tok_Is then\n-         Set_End_Of_Line (Package_Declaration);\n-         Set_Previous_Line_Node (Package_Declaration);\n-         Set_Next_End_Node (Package_Declaration);\n-\n-         Parse_Declarative_Items\n-           (In_Tree           => In_Tree,\n-            Declarations      => First_Declarative_Item,\n-            In_Zone           => In_Package,\n-            First_Attribute   => First_Attribute,\n-            Current_Project   => Current_Project,\n-            Current_Package   => Package_Declaration,\n-            Packages_To_Check => Packages_To_Check,\n-            Is_Config_File    => Is_Config_File,\n-            Flags             => Flags);\n-\n-         Set_First_Declarative_Item_Of\n-           (Package_Declaration, In_Tree, To => First_Declarative_Item);\n-\n-         Expect (Tok_End, \"END\");\n-\n-         if Token = Tok_End then\n-\n-            --  Scan past \"end\"\n-\n-            Scan (In_Tree);\n-         end if;\n-\n-         --  We should have the name of the package after \"end\"\n-\n-         Expect (Tok_Identifier, \"identifier\");\n-\n-         if Token = Tok_Identifier\n-           and then Name_Of (Package_Declaration, In_Tree) /= No_Name\n-           and then Token_Name /= Name_Of (Package_Declaration, In_Tree)\n-         then\n-            Error_Msg_Name_1 := Name_Of (Package_Declaration, In_Tree);\n-            Error_Msg (Flags, \"expected %%\", Token_Ptr);\n-         end if;\n-\n-         if Token /= Tok_Semicolon then\n-\n-            --  Scan past the package name\n-\n-            Scan (In_Tree);\n-         end if;\n-\n-         Expect (Tok_Semicolon, \"`;`\");\n-         Remove_Next_End_Node;\n-\n-      else\n-         Error_Msg (Flags, \"expected IS\", Token_Ptr);\n-      end if;\n-\n-   end Parse_Package_Declaration;\n-\n-   -----------------------------------\n-   -- Parse_String_Type_Declaration --\n-   -----------------------------------\n-\n-   procedure Parse_String_Type_Declaration\n-     (In_Tree         : Project_Node_Tree_Ref;\n-      String_Type     : out Project_Node_Id;\n-      Current_Project : Project_Node_Id;\n-      Flags           : Processing_Flags)\n-   is\n-      Current      : Project_Node_Id := Empty_Node;\n-      First_String : Project_Node_Id := Empty_Node;\n-\n-   begin\n-      String_Type :=\n-        Default_Project_Node\n-          (Of_Kind => N_String_Type_Declaration, In_Tree => In_Tree);\n-\n-      Set_Location_Of (String_Type, In_Tree, To => Token_Ptr);\n-\n-      --  Scan past \"type\"\n-\n-      Scan (In_Tree);\n-\n-      Expect (Tok_Identifier, \"identifier\");\n-\n-      if Token = Tok_Identifier then\n-         Set_Name_Of (String_Type, In_Tree, To => Token_Name);\n-\n-         Current := First_String_Type_Of (Current_Project, In_Tree);\n-         while Present (Current)\n-           and then\n-           Name_Of (Current, In_Tree) /= Token_Name\n-         loop\n-            Current := Next_String_Type (Current, In_Tree);\n-         end loop;\n-\n-         if Present (Current) then\n-            Error_Msg (Flags,\n-                       \"duplicate string type name \"\"\" &\n-                       Get_Name_String (Token_Name) &\n-                       \"\"\"\",\n-                       Token_Ptr);\n-         else\n-            Current := First_Variable_Of (Current_Project, In_Tree);\n-            while Present (Current)\n-              and then Name_Of (Current, In_Tree) /= Token_Name\n-            loop\n-               Current := Next_Variable (Current, In_Tree);\n-            end loop;\n-\n-            if Present (Current) then\n-               Error_Msg (Flags,\n-                          \"\"\"\" &\n-                          Get_Name_String (Token_Name) &\n-                          \"\"\" is already a variable name\", Token_Ptr);\n-            else\n-               Set_Next_String_Type\n-                 (String_Type, In_Tree,\n-                  To => First_String_Type_Of (Current_Project, In_Tree));\n-               Set_First_String_Type_Of\n-                 (Current_Project, In_Tree, To => String_Type);\n-            end if;\n-         end if;\n-\n-         --  Scan past the name\n-\n-         Scan (In_Tree);\n-      end if;\n-\n-      Expect (Tok_Is, \"IS\");\n-\n-      if Token = Tok_Is then\n-         Scan (In_Tree);\n-      end if;\n-\n-      Expect (Tok_Left_Paren, \"`(`\");\n-\n-      if Token = Tok_Left_Paren then\n-         Scan (In_Tree);\n-      end if;\n-\n-      Parse_String_Type_List\n-        (In_Tree => In_Tree, First_String => First_String, Flags => Flags);\n-      Set_First_Literal_String (String_Type, In_Tree, To => First_String);\n-\n-      Expect (Tok_Right_Paren, \"`)`\");\n-\n-      if Token = Tok_Right_Paren then\n-         Scan (In_Tree);\n-      end if;\n-   end Parse_String_Type_Declaration;\n-\n-   --------------------------------\n-   -- Parse_Variable_Declaration --\n-   --------------------------------\n-\n-   procedure Parse_Variable_Declaration\n-     (In_Tree         : Project_Node_Tree_Ref;\n-      Variable        : out Project_Node_Id;\n-      Current_Project : Project_Node_Id;\n-      Current_Package : Project_Node_Id;\n-      Flags           : Processing_Flags)\n-   is\n-      Expression_Location      : Source_Ptr;\n-      String_Type_Name         : Name_Id := No_Name;\n-      Project_String_Type_Name : Name_Id := No_Name;\n-      Type_Location            : Source_Ptr := No_Location;\n-      Project_Location         : Source_Ptr := No_Location;\n-      Expression               : Project_Node_Id := Empty_Node;\n-      Variable_Name            : constant Name_Id := Token_Name;\n-      OK                       : Boolean := True;\n-\n-   begin\n-      Variable :=\n-        Default_Project_Node\n-          (Of_Kind => N_Variable_Declaration, In_Tree => In_Tree);\n-      Set_Name_Of (Variable, In_Tree, To => Variable_Name);\n-      Set_Location_Of (Variable, In_Tree, To => Token_Ptr);\n-\n-      --  Scan past the variable name\n-\n-      Scan (In_Tree);\n-\n-      if Token = Tok_Colon then\n-\n-         --  Typed string variable declaration\n-\n-         Scan (In_Tree);\n-         Set_Kind_Of (Variable, In_Tree, N_Typed_Variable_Declaration);\n-         Expect (Tok_Identifier, \"identifier\");\n-\n-         OK := Token = Tok_Identifier;\n-\n-         if OK then\n-            String_Type_Name := Token_Name;\n-            Type_Location := Token_Ptr;\n-            Scan (In_Tree);\n-\n-            if Token = Tok_Dot then\n-               Project_String_Type_Name := String_Type_Name;\n-               Project_Location := Type_Location;\n-\n-               --  Scan past the dot\n-\n-               Scan (In_Tree);\n-               Expect (Tok_Identifier, \"identifier\");\n-\n-               if Token = Tok_Identifier then\n-                  String_Type_Name := Token_Name;\n-                  Type_Location := Token_Ptr;\n-                  Scan (In_Tree);\n-               else\n-                  OK := False;\n-               end if;\n-            end if;\n-\n-            if OK then\n-               declare\n-                  Proj    : Project_Node_Id := Current_Project;\n-                  Current : Project_Node_Id := Empty_Node;\n-\n-               begin\n-                  if Project_String_Type_Name /= No_Name then\n-                     declare\n-                        The_Project_Name_And_Node : constant\n-                          Tree_Private_Part.Project_Name_And_Node :=\n-                          Tree_Private_Part.Projects_Htable.Get\n-                            (In_Tree.Projects_HT, Project_String_Type_Name);\n-\n-                        use Tree_Private_Part;\n-\n-                     begin\n-                        if The_Project_Name_And_Node =\n-                             Tree_Private_Part.No_Project_Name_And_Node\n-                        then\n-                           Error_Msg (Flags,\n-                                      \"unknown project \"\"\" &\n-                                      Get_Name_String\n-                                         (Project_String_Type_Name) &\n-                                      \"\"\"\",\n-                                      Project_Location);\n-                           Current := Empty_Node;\n-                        else\n-                           Current :=\n-                             First_String_Type_Of\n-                               (The_Project_Name_And_Node.Node, In_Tree);\n-                           while\n-                             Present (Current)\n-                             and then\n-                               Name_Of (Current, In_Tree) /= String_Type_Name\n-                           loop\n-                              Current := Next_String_Type (Current, In_Tree);\n-                           end loop;\n-                        end if;\n-                     end;\n-\n-                  else\n-                     --  Look for a string type with the correct name in this\n-                     --  project or in any of its ancestors.\n-\n-                     loop\n-                        Current :=\n-                          First_String_Type_Of (Proj, In_Tree);\n-                        while\n-                          Present (Current)\n-                          and then\n-                            Name_Of (Current, In_Tree) /= String_Type_Name\n-                        loop\n-                           Current := Next_String_Type (Current, In_Tree);\n-                        end loop;\n-\n-                        exit when Present (Current);\n-\n-                        Proj := Parent_Project_Of (Proj, In_Tree);\n-                        exit when No (Proj);\n-                     end loop;\n-                  end if;\n-\n-                  if No (Current) then\n-                     Error_Msg (Flags,\n-                                \"unknown string type \"\"\" &\n-                                Get_Name_String (String_Type_Name) &\n-                                \"\"\"\",\n-                                Type_Location);\n-                     OK := False;\n-\n-                  else\n-                     Set_String_Type_Of\n-                       (Variable, In_Tree, To => Current);\n-                  end if;\n-               end;\n-            end if;\n-         end if;\n-      end if;\n-\n-      Expect (Tok_Colon_Equal, \"`:=`\");\n-\n-      OK := OK and then Token = Tok_Colon_Equal;\n-\n-      if Token = Tok_Colon_Equal then\n-         Scan (In_Tree);\n-      end if;\n-\n-      --  Get the single string or string list value\n-\n-      Expression_Location := Token_Ptr;\n-\n-      Parse_Expression\n-        (In_Tree         => In_Tree,\n-         Expression      => Expression,\n-         Flags           => Flags,\n-         Current_Project => Current_Project,\n-         Current_Package => Current_Package,\n-         Optional_Index  => False);\n-      Set_Expression_Of (Variable, In_Tree, To => Expression);\n-\n-      if Present (Expression) then\n-         --  A typed string must have a single string value, not a list\n-\n-         if Kind_Of (Variable, In_Tree) = N_Typed_Variable_Declaration\n-           and then Expression_Kind_Of (Expression, In_Tree) = List\n-         then\n-            Error_Msg\n-              (Flags,\n-               \"expression must be a single string\", Expression_Location);\n-         end if;\n-\n-         Set_Expression_Kind_Of\n-           (Variable, In_Tree,\n-            To => Expression_Kind_Of (Expression, In_Tree));\n-      end if;\n-\n-      if OK then\n-         declare\n-            The_Variable : Project_Node_Id := Empty_Node;\n-\n-         begin\n-            if Present (Current_Package) then\n-               The_Variable := First_Variable_Of (Current_Package, In_Tree);\n-            elsif Present (Current_Project) then\n-               The_Variable := First_Variable_Of (Current_Project, In_Tree);\n-            end if;\n-\n-            while Present (The_Variable)\n-              and then Name_Of (The_Variable, In_Tree) /= Variable_Name\n-            loop\n-               The_Variable := Next_Variable (The_Variable, In_Tree);\n-            end loop;\n-\n-            if No (The_Variable) then\n-               if Present (Current_Package) then\n-                  Set_Next_Variable\n-                    (Variable, In_Tree,\n-                     To => First_Variable_Of (Current_Package, In_Tree));\n-                  Set_First_Variable_Of\n-                    (Current_Package, In_Tree, To => Variable);\n-\n-               elsif Present (Current_Project) then\n-                  Set_Next_Variable\n-                    (Variable, In_Tree,\n-                     To => First_Variable_Of (Current_Project, In_Tree));\n-                  Set_First_Variable_Of\n-                    (Current_Project, In_Tree, To => Variable);\n-               end if;\n-\n-            else\n-               if Expression_Kind_Of (Variable, In_Tree) /= Undefined then\n-                  if Expression_Kind_Of (The_Variable, In_Tree) =\n-                                                            Undefined\n-                  then\n-                     Set_Expression_Kind_Of\n-                       (The_Variable, In_Tree,\n-                        To => Expression_Kind_Of (Variable, In_Tree));\n-\n-                  else\n-                     if Expression_Kind_Of (The_Variable, In_Tree) /=\n-                       Expression_Kind_Of (Variable, In_Tree)\n-                     then\n-                        Error_Msg (Flags,\n-                                   \"wrong expression kind for variable \"\"\" &\n-                                   Get_Name_String\n-                                     (Name_Of (The_Variable, In_Tree)) &\n-                                     \"\"\"\",\n-                                   Expression_Location);\n-                     end if;\n-                  end if;\n-               end if;\n-            end if;\n-         end;\n-      end if;\n-   end Parse_Variable_Declaration;\n-\n-end Prj.Dect;"}, {"sha": "2af6e27fd0bcd476148d9ae58d90d61481d4877f", "filename": "gcc/ada/prj-dect.ads", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-dect.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-dect.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-dect.ads?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793", "patch": "@@ -1,61 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                              P R J . D E C T                             --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---          Copyright (C) 2001-2009, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  Parse a list of declarative items in a project file\n-\n-with Prj.Tree;\n-\n-private package Prj.Dect is\n-\n-   procedure Parse\n-     (In_Tree           : Prj.Tree.Project_Node_Tree_Ref;\n-      Declarations      : out Prj.Tree.Project_Node_Id;\n-      Current_Project   : Prj.Tree.Project_Node_Id;\n-      Extends           : Prj.Tree.Project_Node_Id;\n-      Packages_To_Check : String_List_Access;\n-      Is_Config_File    : Boolean;\n-      Flags             : Processing_Flags);\n-   --  Parse project declarative items\n-   --\n-   --  In_Tree is the project node tree\n-   --\n-   --  Declarations is the resulting project node\n-   --\n-   --  Current_Project is the project node of the project for which the\n-   --  declarative items are parsed.\n-   --\n-   --  Extends is the project node of the project that project Current_Project\n-   --  extends. If project Current-Project does not extend any project,\n-   --  Extends has the value Empty_Node.\n-   --\n-   --  Packages_To_Check is the list of packages that needs to be checked.\n-   --  For legal packages declared in project Current_Project that are not in\n-   --  Packages_To_Check, only the syntax of the declarations are checked, not\n-   --  the attribute names and kinds.\n-   --\n-   --  Is_Config_File should be set to True if the project represents a config\n-   --  file (.cgpr) since some specific checks apply.\n-\n-end Prj.Dect;"}, {"sha": "18741be7917dfe9be570d9ce03101ad5b9f228a3", "filename": "gcc/ada/prj-env.adb", "status": "removed", "additions": 0, "deletions": 2429, "changes": 2429, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-env.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-env.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-env.adb?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793", "patch": "@@ -1,2429 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                              P R J . E N V                               --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 2001-2016, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-with Fmap;\n-with Makeutl;  use Makeutl;\n-with Opt;\n-with Osint;    use Osint;\n-with Output;   use Output;\n-with Prj.Com;  use Prj.Com;\n-with Sdefault;\n-with Tempdir;\n-\n-with Ada.Text_IO; use Ada.Text_IO;\n-\n-with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n-\n-package body Prj.Env is\n-\n-   Buffer_Initial : constant := 1_000;\n-   --  Initial arbitrary size of buffers\n-\n-   Uninitialized_Prefix : constant String := '#' & Path_Separator;\n-   --  Prefix to indicate that the project path has not been initialized yet.\n-   --  Must be two characters long\n-\n-   No_Project_Default_Dir : constant String := \"-\";\n-   --  Indicator in the project path to indicate that the default search\n-   --  directories should not be added to the path\n-\n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   package Source_Path_Table is new GNAT.Dynamic_Tables\n-     (Table_Component_Type => Name_Id,\n-      Table_Index_Type     => Natural,\n-      Table_Low_Bound      => 1,\n-      Table_Initial        => 50,\n-      Table_Increment      => 100);\n-   --  A table to store the source dirs before creating the source path file\n-\n-   package Object_Path_Table is new GNAT.Dynamic_Tables\n-     (Table_Component_Type => Path_Name_Type,\n-      Table_Index_Type     => Natural,\n-      Table_Low_Bound      => 1,\n-      Table_Initial        => 50,\n-      Table_Increment      => 100);\n-   --  A table to store the object dirs, before creating the object path file\n-\n-   procedure Add_To_Buffer\n-     (S           : String;\n-      Buffer      : in out String_Access;\n-      Buffer_Last : in out Natural);\n-   --  Add a string to Buffer, extending Buffer if needed\n-\n-   procedure Add_To_Path\n-     (Source_Dirs : String_List_Id;\n-      Shared      : Shared_Project_Tree_Data_Access;\n-      Buffer      : in out String_Access;\n-      Buffer_Last : in out Natural);\n-   --  Add to Ada_Path_Buffer all the source directories in string list\n-   --  Source_Dirs, if any.\n-\n-   procedure Add_To_Path\n-     (Dir         : String;\n-      Buffer      : in out String_Access;\n-      Buffer_Last : in out Natural);\n-   --  If Dir is not already in the global variable Ada_Path_Buffer, add it.\n-   --  If Buffer_Last /= 0, prepend a Path_Separator character to Path.\n-\n-   procedure Add_To_Source_Path\n-     (Source_Dirs  : String_List_Id;\n-      Shared       : Shared_Project_Tree_Data_Access;\n-      Source_Paths : in out Source_Path_Table.Instance);\n-   --  Add to Ada_Path_B all the source directories in string list\n-   --  Source_Dirs, if any. Increment Ada_Path_Length.\n-\n-   procedure Add_To_Object_Path\n-     (Object_Dir   : Path_Name_Type;\n-      Object_Paths : in out Object_Path_Table.Instance);\n-   --  Add Object_Dir to object path table. Make sure it is not duplicate\n-   --  and it is the last one in the current table.\n-\n-   ----------------------\n-   -- Ada_Include_Path --\n-   ----------------------\n-\n-   function Ada_Include_Path\n-     (Project   : Project_Id;\n-      In_Tree   : Project_Tree_Ref;\n-      Recursive : Boolean := False) return String\n-   is\n-      Buffer      : String_Access;\n-      Buffer_Last : Natural := 0;\n-\n-      procedure Add\n-        (Project : Project_Id;\n-         In_Tree : Project_Tree_Ref;\n-         Dummy   : in out Boolean);\n-      --  Add source dirs of Project to the path\n-\n-      ---------\n-      -- Add --\n-      ---------\n-\n-      procedure Add\n-        (Project : Project_Id;\n-         In_Tree : Project_Tree_Ref;\n-         Dummy   : in out Boolean)\n-      is\n-      begin\n-         Add_To_Path\n-           (Project.Source_Dirs, In_Tree.Shared, Buffer, Buffer_Last);\n-      end Add;\n-\n-      procedure For_All_Projects is\n-        new For_Every_Project_Imported (Boolean, Add);\n-\n-      Dummy : Boolean := False;\n-\n-   --  Start of processing for Ada_Include_Path\n-\n-   begin\n-      if Recursive then\n-\n-         --  If it is the first time we call this function for this project,\n-         --  compute the source path.\n-\n-         if Project.Ada_Include_Path = null then\n-            Buffer := new String (1 .. Buffer_Initial);\n-            For_All_Projects\n-              (Project, In_Tree, Dummy, Include_Aggregated => True);\n-            Project.Ada_Include_Path := new String'(Buffer (1 .. Buffer_Last));\n-            Free (Buffer);\n-         end if;\n-\n-         return Project.Ada_Include_Path.all;\n-\n-      else\n-         Buffer := new String (1 .. Buffer_Initial);\n-         Add_To_Path\n-           (Project.Source_Dirs, In_Tree.Shared, Buffer, Buffer_Last);\n-\n-         declare\n-            Result : constant String := Buffer (1 .. Buffer_Last);\n-         begin\n-            Free (Buffer);\n-            return Result;\n-         end;\n-      end if;\n-   end Ada_Include_Path;\n-\n-   ----------------------\n-   -- Ada_Objects_Path --\n-   ----------------------\n-\n-   function Ada_Objects_Path\n-     (Project             : Project_Id;\n-      In_Tree             : Project_Tree_Ref;\n-      Including_Libraries : Boolean := True) return String_Access\n-   is\n-      Buffer      : String_Access;\n-      Buffer_Last : Natural := 0;\n-\n-      procedure Add\n-        (Project : Project_Id;\n-         In_Tree : Project_Tree_Ref;\n-         Dummy   : in out Boolean);\n-      --  Add all the object directories of a project to the path\n-\n-      ---------\n-      -- Add --\n-      ---------\n-\n-      procedure Add\n-        (Project : Project_Id;\n-         In_Tree : Project_Tree_Ref;\n-         Dummy   : in out Boolean)\n-      is\n-         pragma Unreferenced (In_Tree);\n-\n-         Path : constant Path_Name_Type :=\n-                  Get_Object_Directory\n-                    (Project,\n-                     Including_Libraries => Including_Libraries,\n-                     Only_If_Ada         => False);\n-      begin\n-         if Path /= No_Path then\n-            Add_To_Path (Get_Name_String (Path), Buffer, Buffer_Last);\n-         end if;\n-      end Add;\n-\n-      procedure For_All_Projects is\n-        new For_Every_Project_Imported (Boolean, Add);\n-\n-      Dummy : Boolean := False;\n-\n-      Result : String_Access;\n-\n-   --  Start of processing for Ada_Objects_Path\n-\n-   begin\n-      --  If it is the first time we call this function for\n-      --  this project, compute the objects path\n-\n-      if Including_Libraries and then Project.Ada_Objects_Path /= null then\n-         return Project.Ada_Objects_Path;\n-\n-      elsif not Including_Libraries\n-        and then Project.Ada_Objects_Path_No_Libs /= null\n-      then\n-         return Project.Ada_Objects_Path_No_Libs;\n-\n-      else\n-         Buffer := new String (1 .. Buffer_Initial);\n-         For_All_Projects (Project, In_Tree, Dummy);\n-         Result := new String'(Buffer (1 .. Buffer_Last));\n-         Free (Buffer);\n-\n-         if Including_Libraries then\n-            Project.Ada_Objects_Path := Result;\n-         else\n-            Project.Ada_Objects_Path_No_Libs := Result;\n-         end if;\n-\n-         return Result;\n-      end if;\n-   end Ada_Objects_Path;\n-\n-   -------------------\n-   -- Add_To_Buffer --\n-   -------------------\n-\n-   procedure Add_To_Buffer\n-     (S           : String;\n-      Buffer      : in out String_Access;\n-      Buffer_Last : in out Natural)\n-   is\n-      Last : constant Natural := Buffer_Last + S'Length;\n-\n-   begin\n-      while Last > Buffer'Last loop\n-         declare\n-            New_Buffer : constant String_Access :=\n-                           new String (1 .. 2 * Buffer'Last);\n-         begin\n-            New_Buffer (1 .. Buffer_Last) := Buffer (1 .. Buffer_Last);\n-            Free (Buffer);\n-            Buffer := New_Buffer;\n-         end;\n-      end loop;\n-\n-      Buffer (Buffer_Last + 1 .. Last) := S;\n-      Buffer_Last := Last;\n-   end Add_To_Buffer;\n-\n-   ------------------------\n-   -- Add_To_Object_Path --\n-   ------------------------\n-\n-   procedure Add_To_Object_Path\n-     (Object_Dir   : Path_Name_Type;\n-      Object_Paths : in out Object_Path_Table.Instance)\n-   is\n-   begin\n-      --  Check if the directory is already in the table\n-\n-      for Index in\n-        Object_Path_Table.First .. Object_Path_Table.Last (Object_Paths)\n-      loop\n-         --  If it is, remove it, and add it as the last one\n-\n-         if Object_Paths.Table (Index) = Object_Dir then\n-            for Index2 in\n-              Index + 1 .. Object_Path_Table.Last (Object_Paths)\n-            loop\n-               Object_Paths.Table (Index2 - 1) := Object_Paths.Table (Index2);\n-            end loop;\n-\n-            Object_Paths.Table\n-              (Object_Path_Table.Last (Object_Paths)) := Object_Dir;\n-            return;\n-         end if;\n-      end loop;\n-\n-      --  The directory is not already in the table, add it\n-\n-      Object_Path_Table.Append (Object_Paths, Object_Dir);\n-   end Add_To_Object_Path;\n-\n-   -----------------\n-   -- Add_To_Path --\n-   -----------------\n-\n-   procedure Add_To_Path\n-     (Source_Dirs : String_List_Id;\n-      Shared      : Shared_Project_Tree_Data_Access;\n-      Buffer      : in out String_Access;\n-      Buffer_Last : in out Natural)\n-   is\n-      Current    : String_List_Id;\n-      Source_Dir : String_Element;\n-   begin\n-      Current := Source_Dirs;\n-      while Current /= Nil_String loop\n-         Source_Dir := Shared.String_Elements.Table (Current);\n-         Add_To_Path (Get_Name_String (Source_Dir.Display_Value),\n-                      Buffer, Buffer_Last);\n-         Current := Source_Dir.Next;\n-      end loop;\n-   end Add_To_Path;\n-\n-   procedure Add_To_Path\n-     (Dir         : String;\n-      Buffer      : in out String_Access;\n-      Buffer_Last : in out Natural)\n-   is\n-      Len        : Natural;\n-      New_Buffer : String_Access;\n-      Min_Len    : Natural;\n-\n-      function Is_Present (Path : String; Dir : String) return Boolean;\n-      --  Return True if Dir is part of Path\n-\n-      ----------------\n-      -- Is_Present --\n-      ----------------\n-\n-      function Is_Present (Path : String; Dir : String) return Boolean is\n-         Last : constant Integer := Path'Last - Dir'Length + 1;\n-\n-      begin\n-         for J in Path'First .. Last loop\n-\n-            --  Note: the order of the conditions below is important, since\n-            --  it ensures a minimal number of string comparisons.\n-\n-            if (J = Path'First or else Path (J - 1) = Path_Separator)\n-              and then\n-                (J + Dir'Length > Path'Last\n-                  or else Path (J + Dir'Length) = Path_Separator)\n-              and then Dir = Path (J .. J + Dir'Length - 1)\n-            then\n-               return True;\n-            end if;\n-         end loop;\n-\n-         return False;\n-      end Is_Present;\n-\n-   --  Start of processing for Add_To_Path\n-\n-   begin\n-      if Is_Present (Buffer (1 .. Buffer_Last), Dir) then\n-\n-         --  Dir is already in the path, nothing to do\n-\n-         return;\n-      end if;\n-\n-      Min_Len := Buffer_Last + Dir'Length;\n-\n-      if Buffer_Last > 0 then\n-\n-         --  Add 1 for the Path_Separator character\n-\n-         Min_Len := Min_Len + 1;\n-      end if;\n-\n-      --  If Ada_Path_Buffer is too small, increase it\n-\n-      Len := Buffer'Last;\n-\n-      if Len < Min_Len then\n-         loop\n-            Len := Len * 2;\n-            exit when Len >= Min_Len;\n-         end loop;\n-\n-         New_Buffer := new String (1 .. Len);\n-         New_Buffer (1 .. Buffer_Last) := Buffer (1 .. Buffer_Last);\n-         Free (Buffer);\n-         Buffer := New_Buffer;\n-      end if;\n-\n-      if Buffer_Last > 0 then\n-         Buffer_Last := Buffer_Last + 1;\n-         Buffer (Buffer_Last) := Path_Separator;\n-      end if;\n-\n-      Buffer (Buffer_Last + 1 .. Buffer_Last + Dir'Length) := Dir;\n-      Buffer_Last := Buffer_Last + Dir'Length;\n-   end Add_To_Path;\n-\n-   ------------------------\n-   -- Add_To_Source_Path --\n-   ------------------------\n-\n-   procedure Add_To_Source_Path\n-     (Source_Dirs  : String_List_Id;\n-      Shared       : Shared_Project_Tree_Data_Access;\n-      Source_Paths : in out Source_Path_Table.Instance)\n-   is\n-      Current    : String_List_Id;\n-      Source_Dir : String_Element;\n-      Add_It     : Boolean;\n-\n-   begin\n-      --  Add each source directory\n-\n-      Current := Source_Dirs;\n-      while Current /= Nil_String loop\n-         Source_Dir := Shared.String_Elements.Table (Current);\n-         Add_It := True;\n-\n-         --  Check if the source directory is already in the table\n-\n-         for Index in\n-           Source_Path_Table.First .. Source_Path_Table.Last (Source_Paths)\n-         loop\n-            --  If it is already, no need to add it\n-\n-            if Source_Paths.Table (Index) = Source_Dir.Value then\n-               Add_It := False;\n-               exit;\n-            end if;\n-         end loop;\n-\n-         if Add_It then\n-            Source_Path_Table.Append (Source_Paths, Source_Dir.Display_Value);\n-         end if;\n-\n-         --  Next source directory\n-\n-         Current := Source_Dir.Next;\n-      end loop;\n-   end Add_To_Source_Path;\n-\n-   --------------------------------\n-   -- Create_Config_Pragmas_File --\n-   --------------------------------\n-\n-   procedure Create_Config_Pragmas_File\n-     (For_Project : Project_Id;\n-      In_Tree     : Project_Tree_Ref)\n-   is\n-      type Naming_Id is new Nat;\n-      package Naming_Table is new GNAT.Dynamic_Tables\n-        (Table_Component_Type => Lang_Naming_Data,\n-         Table_Index_Type     => Naming_Id,\n-         Table_Low_Bound      => 1,\n-         Table_Initial        => 5,\n-         Table_Increment      => 100);\n-\n-      Default_Naming : constant Naming_Id := Naming_Table.First;\n-      Namings        : Naming_Table.Instance;\n-      --  Table storing the naming data for gnatmake/gprmake\n-\n-      Buffer      : String_Access := new String (1 .. Buffer_Initial);\n-      Buffer_Last : Natural := 0;\n-\n-      File_Name : Path_Name_Type  := No_Path;\n-      File      : File_Descriptor := Invalid_FD;\n-\n-      Current_Naming : Naming_Id;\n-\n-      procedure Check\n-        (Project : Project_Id;\n-         In_Tree : Project_Tree_Ref;\n-         State   : in out Integer);\n-      --  Recursive procedure that put in the config pragmas file any non\n-      --  standard naming schemes, if it is not already in the file, then call\n-      --  itself for any imported project.\n-\n-      procedure Put (Source : Source_Id);\n-      --  Put an SFN pragma in the temporary file\n-\n-      procedure Put (S : String);\n-      procedure Put_Line (S : String);\n-      --  Output procedures, analogous to normal Text_IO procs of same name.\n-      --  The text is put in Buffer, then it will be written into a temporary\n-      --  file with procedure Write_Temp_File below.\n-\n-      procedure Write_Temp_File;\n-      --  Create a temporary file and put the content of the buffer in it\n-\n-      -----------\n-      -- Check --\n-      -----------\n-\n-      procedure Check\n-        (Project : Project_Id;\n-         In_Tree : Project_Tree_Ref;\n-         State   : in out Integer)\n-      is\n-         pragma Unreferenced (State);\n-\n-         Lang   : constant Language_Ptr :=\n-                    Get_Language_From_Name (Project, \"ada\");\n-         Naming : Lang_Naming_Data;\n-         Iter   : Source_Iterator;\n-         Source : Source_Id;\n-\n-      begin\n-         if Current_Verbosity = High then\n-            Debug_Output (\"Checking project file:\", Project.Name);\n-         end if;\n-\n-         if Lang = null then\n-            if Current_Verbosity = High then\n-               Debug_Output (\"Languages does not contain Ada, nothing to do\");\n-            end if;\n-\n-            return;\n-         end if;\n-\n-         --  Visit all the files and process those that need an SFN pragma\n-\n-         Iter := For_Each_Source (In_Tree, Project);\n-         while Element (Iter) /= No_Source loop\n-            Source := Element (Iter);\n-\n-            if not Source.Locally_Removed\n-              and then Source.Unit /= null\n-              and then\n-                (Source.Index >= 1 or else Source.Naming_Exception /= No)\n-            then\n-               Put (Source);\n-            end if;\n-\n-            Next (Iter);\n-         end loop;\n-\n-         Naming := Lang.Config.Naming_Data;\n-\n-         --  Is the naming scheme of this project one that we know?\n-\n-         Current_Naming := Default_Naming;\n-         while Current_Naming <= Naming_Table.Last (Namings)\n-           and then Namings.Table (Current_Naming).Dot_Replacement =\n-                                                    Naming.Dot_Replacement\n-           and then Namings.Table (Current_Naming).Casing =\n-                                                    Naming.Casing\n-           and then Namings.Table (Current_Naming).Separate_Suffix =\n-                                                    Naming.Separate_Suffix\n-         loop\n-            Current_Naming := Current_Naming + 1;\n-         end loop;\n-\n-         --  If we don't know it, add it\n-\n-         if Current_Naming > Naming_Table.Last (Namings) then\n-            Naming_Table.Increment_Last (Namings);\n-            Namings.Table (Naming_Table.Last (Namings)) := Naming;\n-\n-            --  Put the SFN pragmas for the naming scheme\n-\n-            --  Spec\n-\n-            Put_Line\n-              (\"pragma Source_File_Name_Project\");\n-            Put_Line\n-              (\"  (Spec_File_Name  => \"\"*\" &\n-               Get_Name_String (Naming.Spec_Suffix) & \"\"\",\");\n-            Put_Line\n-              (\"   Casing          => \" &\n-               Image (Naming.Casing) & \",\");\n-            Put_Line\n-              (\"   Dot_Replacement => \"\"\" &\n-               Get_Name_String (Naming.Dot_Replacement) & \"\"\");\");\n-\n-            --  and body\n-\n-            Put_Line\n-              (\"pragma Source_File_Name_Project\");\n-            Put_Line\n-              (\"  (Body_File_Name  => \"\"*\" &\n-               Get_Name_String (Naming.Body_Suffix) & \"\"\",\");\n-            Put_Line\n-              (\"   Casing          => \" &\n-               Image (Naming.Casing) & \",\");\n-            Put_Line\n-              (\"   Dot_Replacement => \"\"\" &\n-               Get_Name_String (Naming.Dot_Replacement) &\n-               \"\"\");\");\n-\n-            --  and maybe separate\n-\n-            if Naming.Body_Suffix /= Naming.Separate_Suffix then\n-               Put_Line (\"pragma Source_File_Name_Project\");\n-               Put_Line\n-                 (\"  (Subunit_File_Name  => \"\"*\" &\n-                  Get_Name_String (Naming.Separate_Suffix) & \"\"\",\");\n-               Put_Line\n-                 (\"   Casing          => \" &\n-                  Image (Naming.Casing) & \",\");\n-               Put_Line\n-                 (\"   Dot_Replacement => \"\"\" &\n-                  Get_Name_String (Naming.Dot_Replacement) &\n-                  \"\"\");\");\n-            end if;\n-         end if;\n-      end Check;\n-\n-      ---------\n-      -- Put --\n-      ---------\n-\n-      procedure Put (Source : Source_Id) is\n-      begin\n-         --  Put the pragma SFN for the unit kind (spec or body)\n-\n-         Put (\"pragma Source_File_Name_Project (\");\n-         Put (Namet.Get_Name_String (Source.Unit.Name));\n-\n-         if Source.Kind = Spec then\n-            Put (\", Spec_File_Name => \"\"\");\n-         else\n-            Put (\", Body_File_Name => \"\"\");\n-         end if;\n-\n-         Put (Namet.Get_Name_String (Source.File));\n-         Put (\"\"\"\");\n-\n-         if Source.Index /= 0 then\n-            Put (\", Index =>\");\n-            Put (Source.Index'Img);\n-         end if;\n-\n-         Put_Line (\");\");\n-      end Put;\n-\n-      procedure Put (S : String) is\n-      begin\n-         Add_To_Buffer (S, Buffer, Buffer_Last);\n-\n-         if Current_Verbosity = High then\n-            Write_Str (S);\n-         end if;\n-      end Put;\n-\n-      --------------\n-      -- Put_Line --\n-      --------------\n-\n-      procedure Put_Line (S : String) is\n-      begin\n-         --  Add an ASCII.LF to the string. As this config file is supposed to\n-         --  be used only by the compiler, we don't care about the characters\n-         --  for the end of line. In fact we could have put a space, but\n-         --  it is more convenient to be able to read gnat.adc during\n-         --  development, for which the ASCII.LF is fine.\n-\n-         Put (S);\n-         Put (S => (1 => ASCII.LF));\n-      end Put_Line;\n-\n-      ---------------------\n-      -- Write_Temp_File --\n-      ---------------------\n-\n-      procedure Write_Temp_File is\n-         Status : Boolean := False;\n-         Last   : Natural;\n-\n-      begin\n-         Tempdir.Create_Temp_File (File, File_Name);\n-\n-         if File /= Invalid_FD then\n-            Last := Write (File, Buffer (1)'Address, Buffer_Last);\n-\n-            if Last = Buffer_Last then\n-               Close (File, Status);\n-            end if;\n-         end if;\n-\n-         if not Status then\n-            Prj.Com.Fail (\"unable to create temporary file\");\n-         end if;\n-      end Write_Temp_File;\n-\n-      procedure Check_Imported_Projects is\n-        new For_Every_Project_Imported (Integer, Check);\n-\n-      Dummy : Integer := 0;\n-\n-   --  Start of processing for Create_Config_Pragmas_File\n-\n-   begin\n-      if not For_Project.Config_Checked then\n-         Naming_Table.Init (Namings);\n-\n-         --  Check the naming schemes\n-\n-         Check_Imported_Projects\n-           (For_Project, In_Tree, Dummy, Imported_First => False);\n-\n-         --  If there are no non standard naming scheme, issue the GNAT\n-         --  standard naming scheme. This will tell the compiler that\n-         --  a project file is used and will forbid any pragma SFN.\n-\n-         if Buffer_Last = 0 then\n-\n-            Put_Line (\"pragma Source_File_Name_Project\");\n-            Put_Line (\"   (Spec_File_Name  => \"\"*.ads\"\",\");\n-            Put_Line (\"    Dot_Replacement => \"\"-\"\",\");\n-            Put_Line (\"    Casing          => lowercase);\");\n-\n-            Put_Line (\"pragma Source_File_Name_Project\");\n-            Put_Line (\"   (Body_File_Name  => \"\"*.adb\"\",\");\n-            Put_Line (\"    Dot_Replacement => \"\"-\"\",\");\n-            Put_Line (\"    Casing          => lowercase);\");\n-         end if;\n-\n-         --  Close the temporary file\n-\n-         Write_Temp_File;\n-\n-         if Opt.Verbose_Mode then\n-            Write_Str (\"Created configuration file \"\"\");\n-            Write_Str (Get_Name_String (File_Name));\n-            Write_Line (\"\"\"\");\n-         end if;\n-\n-         For_Project.Config_File_Name := File_Name;\n-         For_Project.Config_File_Temp := True;\n-         For_Project.Config_Checked   := True;\n-      end if;\n-\n-      Free (Buffer);\n-   end Create_Config_Pragmas_File;\n-\n-   --------------------\n-   -- Create_Mapping --\n-   --------------------\n-\n-   procedure Create_Mapping (In_Tree : Project_Tree_Ref) is\n-      Data : Source_Id;\n-      Iter : Source_Iterator;\n-\n-   begin\n-      Fmap.Reset_Tables;\n-\n-      Iter := For_Each_Source (In_Tree);\n-      loop\n-         Data := Element (Iter);\n-         exit when Data = No_Source;\n-\n-         if Data.Unit /= No_Unit_Index then\n-            if Data.Locally_Removed and then not Data.Suppressed then\n-               Fmap.Add_Forbidden_File_Name (Data.File);\n-            else\n-               Fmap.Add_To_File_Map\n-                 (Unit_Name => Unit_Name_Type (Data.Unit.Name),\n-                  File_Name => Data.File,\n-                  Path_Name => File_Name_Type (Data.Path.Display_Name));\n-            end if;\n-         end if;\n-\n-         Next (Iter);\n-      end loop;\n-   end Create_Mapping;\n-\n-   -------------------------\n-   -- Create_Mapping_File --\n-   -------------------------\n-\n-   procedure Create_Mapping_File\n-     (Project  : Project_Id;\n-      Language : Name_Id;\n-      In_Tree  : Project_Tree_Ref;\n-      Name     : out Path_Name_Type)\n-   is\n-      File        : File_Descriptor := Invalid_FD;\n-      Buffer      : String_Access   := new String (1 .. Buffer_Initial);\n-      Buffer_Last : Natural         := 0;\n-\n-      procedure Put_Name_Buffer;\n-      --  Put the line contained in the Name_Buffer in the global buffer\n-\n-      procedure Process\n-        (Project : Project_Id;\n-         In_Tree : Project_Tree_Ref;\n-         State   : in out Integer);\n-      --  Generate the mapping file for Project (not recursively)\n-\n-      ---------------------\n-      -- Put_Name_Buffer --\n-      ---------------------\n-\n-      procedure Put_Name_Buffer is\n-      begin\n-         if Current_Verbosity = High then\n-            Debug_Output (Name_Buffer (1 .. Name_Len));\n-         end if;\n-\n-         Name_Len := Name_Len + 1;\n-         Name_Buffer (Name_Len) := ASCII.LF;\n-         Add_To_Buffer (Name_Buffer (1 .. Name_Len), Buffer, Buffer_Last);\n-      end Put_Name_Buffer;\n-\n-      -------------\n-      -- Process --\n-      -------------\n-\n-      procedure Process\n-        (Project : Project_Id;\n-         In_Tree : Project_Tree_Ref;\n-         State   : in out Integer)\n-      is\n-         pragma Unreferenced (State);\n-\n-         Source : Source_Id;\n-         Suffix : File_Name_Type;\n-         Iter   : Source_Iterator;\n-\n-      begin\n-         Debug_Output (\"Add mapping for project\", Project.Name);\n-         Iter := For_Each_Source (In_Tree, Project, Language => Language);\n-\n-         loop\n-            Source := Prj.Element (Iter);\n-            exit when Source = No_Source;\n-\n-            if not Source.Suppressed\n-              and then Source.Replaced_By = No_Source\n-              and then Source.Path.Name /= No_Path\n-              and then (Source.Language.Config.Kind = File_Based\n-                         or else Source.Unit /= No_Unit_Index)\n-            then\n-               if Source.Unit /= No_Unit_Index then\n-\n-                  --  Put the encoded unit name in the name buffer\n-\n-                  declare\n-                     Uname : constant String :=\n-                               Get_Name_String (Source.Unit.Name);\n-\n-                  begin\n-                     Name_Len := 0;\n-                     for J in Uname'Range loop\n-                        if Uname (J) in Upper_Half_Character then\n-                           Store_Encoded_Character (Get_Char_Code (Uname (J)));\n-                        else\n-                           Add_Char_To_Name_Buffer (Uname (J));\n-                        end if;\n-                     end loop;\n-                  end;\n-\n-                  if Source.Language.Config.Kind = Unit_Based then\n-\n-                     --  ??? Mapping_Spec_Suffix could be set in the case of\n-                     --  gnatmake as well\n-\n-                     Add_Char_To_Name_Buffer ('%');\n-\n-                     if Source.Kind = Spec then\n-                        Add_Char_To_Name_Buffer ('s');\n-                     else\n-                        Add_Char_To_Name_Buffer ('b');\n-                     end if;\n-\n-                  else\n-                     case Source.Kind is\n-                        when Spec =>\n-                           Suffix :=\n-                             Source.Language.Config.Mapping_Spec_Suffix;\n-\n-                        when Impl\n-                           | Sep\n-                        =>\n-                           Suffix :=\n-                             Source.Language.Config.Mapping_Body_Suffix;\n-                     end case;\n-\n-                     if Suffix /= No_File then\n-                        Add_Str_To_Name_Buffer (Get_Name_String (Suffix));\n-                     end if;\n-                  end if;\n-\n-                  Put_Name_Buffer;\n-               end if;\n-\n-               Get_Name_String (Source.Display_File);\n-               Put_Name_Buffer;\n-\n-               if Source.Locally_Removed then\n-                  Name_Len := 1;\n-                  Name_Buffer (1) := '/';\n-               else\n-                  Get_Name_String (Source.Path.Display_Name);\n-               end if;\n-\n-               Put_Name_Buffer;\n-            end if;\n-\n-            Next (Iter);\n-         end loop;\n-      end Process;\n-\n-      procedure For_Every_Imported_Project is new\n-        For_Every_Project_Imported (State => Integer, Action => Process);\n-\n-      --  Local variables\n-\n-      Dummy : Integer := 0;\n-\n-   --  Start of processing for Create_Mapping_File\n-\n-   begin\n-      if Current_Verbosity = High then\n-         Debug_Output (\"Create mapping file for\", Debug_Name (In_Tree));\n-      end if;\n-\n-      Create_Temp_File (In_Tree.Shared, File, Name, \"mapping\");\n-\n-      if Current_Verbosity = High then\n-         Debug_Increase_Indent (\"Create mapping file \", Name_Id (Name));\n-      end if;\n-\n-      For_Every_Imported_Project\n-        (Project, In_Tree, Dummy, Include_Aggregated => False);\n-\n-      declare\n-         Last   : Natural;\n-         Status : Boolean := False;\n-\n-      begin\n-         if File /= Invalid_FD then\n-            Last := Write (File, Buffer (1)'Address, Buffer_Last);\n-\n-            if Last = Buffer_Last then\n-               GNAT.OS_Lib.Close (File, Status);\n-            end if;\n-         end if;\n-\n-         if not Status then\n-            Prj.Com.Fail (\"could not write mapping file\");\n-         end if;\n-      end;\n-\n-      Free (Buffer);\n-\n-      Debug_Decrease_Indent (\"Done create mapping file\");\n-   end Create_Mapping_File;\n-\n-   ----------------------\n-   -- Create_Temp_File --\n-   ----------------------\n-\n-   procedure Create_Temp_File\n-     (Shared    : Shared_Project_Tree_Data_Access;\n-      Path_FD   : out File_Descriptor;\n-      Path_Name : out Path_Name_Type;\n-      File_Use  : String)\n-   is\n-   begin\n-      Tempdir.Create_Temp_File (Path_FD, Path_Name);\n-\n-      if Path_Name /= No_Path then\n-         if Current_Verbosity = High then\n-            Write_Line (\"Create temp file (\" & File_Use & \") \"\n-                        & Get_Name_String (Path_Name));\n-         end if;\n-\n-         Record_Temp_File (Shared, Path_Name);\n-\n-      else\n-         Prj.Com.Fail\n-           (\"unable to create temporary \" & File_Use & \" file\");\n-      end if;\n-   end Create_Temp_File;\n-\n-   --------------------------\n-   -- Create_New_Path_File --\n-   --------------------------\n-\n-   procedure Create_New_Path_File\n-     (Shared    : Shared_Project_Tree_Data_Access;\n-      Path_FD   : out File_Descriptor;\n-      Path_Name : out Path_Name_Type)\n-   is\n-   begin\n-      Create_Temp_File (Shared, Path_FD, Path_Name, \"path file\");\n-   end Create_New_Path_File;\n-\n-   ------------------------------------\n-   -- File_Name_Of_Library_Unit_Body --\n-   ------------------------------------\n-\n-   function File_Name_Of_Library_Unit_Body\n-     (Name              : String;\n-      Project           : Project_Id;\n-      In_Tree           : Project_Tree_Ref;\n-      Main_Project_Only : Boolean := True;\n-      Full_Path         : Boolean := False) return String\n-   is\n-\n-      Lang          : constant Language_Ptr :=\n-                        Get_Language_From_Name (Project, \"ada\");\n-      The_Project   : Project_Id := Project;\n-      Original_Name : String := Name;\n-\n-      Unit              : Unit_Index;\n-      The_Original_Name : Name_Id;\n-      The_Spec_Name     : Name_Id;\n-      The_Body_Name     : Name_Id;\n-\n-   begin\n-      --  ??? Same block in Project_Of\n-      Canonical_Case_File_Name (Original_Name);\n-      Name_Len := Original_Name'Length;\n-      Name_Buffer (1 .. Name_Len) := Original_Name;\n-      The_Original_Name := Name_Find;\n-\n-      if Lang /= null then\n-         declare\n-            Naming : constant Lang_Naming_Data := Lang.Config.Naming_Data;\n-            Extended_Spec_Name : String :=\n-                                   Name & Namet.Get_Name_String\n-                                            (Naming.Spec_Suffix);\n-            Extended_Body_Name : String :=\n-                                   Name & Namet.Get_Name_String\n-                                            (Naming.Body_Suffix);\n-\n-         begin\n-            Canonical_Case_File_Name (Extended_Spec_Name);\n-            Name_Len := Extended_Spec_Name'Length;\n-            Name_Buffer (1 .. Name_Len) := Extended_Spec_Name;\n-            The_Spec_Name := Name_Find;\n-\n-            Canonical_Case_File_Name (Extended_Body_Name);\n-            Name_Len := Extended_Body_Name'Length;\n-            Name_Buffer (1 .. Name_Len) := Extended_Body_Name;\n-            The_Body_Name := Name_Find;\n-         end;\n-\n-      else\n-         Name_Len := Name'Length;\n-         Name_Buffer (1 .. Name_Len) := Name;\n-         Canonical_Case_File_Name (Name_Buffer);\n-         The_Spec_Name := Name_Find;\n-         The_Body_Name := The_Spec_Name;\n-      end if;\n-\n-      if Current_Verbosity = High then\n-         Write_Str  (\"Looking for file name of \"\"\");\n-         Write_Str  (Name);\n-         Write_Char ('\"');\n-         Write_Eol;\n-         Write_Str  (\"   Extended Spec Name = \"\"\");\n-         Write_Str  (Get_Name_String (The_Spec_Name));\n-         Write_Char ('\"');\n-         Write_Eol;\n-         Write_Str  (\"   Extended Body Name = \"\"\");\n-         Write_Str  (Get_Name_String (The_Body_Name));\n-         Write_Char ('\"');\n-         Write_Eol;\n-      end if;\n-\n-      --  For extending project, search in the extended project if the source\n-      --  is not found. For non extending projects, this loop will be run only\n-      --  once.\n-\n-      loop\n-         --  Loop through units\n-\n-         Unit := Units_Htable.Get_First (In_Tree.Units_HT);\n-         while Unit /= null loop\n-\n-            --  Check for body\n-\n-            if not Main_Project_Only\n-              or else\n-                (Unit.File_Names (Impl) /= null\n-                  and then Unit.File_Names (Impl).Project = The_Project)\n-            then\n-               declare\n-                  Current_Name : File_Name_Type;\n-\n-               begin\n-                  --  Case of a body present\n-\n-                  if Unit.File_Names (Impl) /= null then\n-                     Current_Name := Unit.File_Names (Impl).File;\n-\n-                     if Current_Verbosity = High then\n-                        Write_Str  (\"   Comparing with \"\"\");\n-                        Write_Str  (Get_Name_String (Current_Name));\n-                        Write_Char ('\"');\n-                        Write_Eol;\n-                     end if;\n-\n-                     --  If it has the name of the original name, return the\n-                     --  original name.\n-\n-                     if Unit.Name = The_Original_Name\n-                       or else\n-                         Current_Name = File_Name_Type (The_Original_Name)\n-                     then\n-                        if Current_Verbosity = High then\n-                           Write_Line (\"   OK\");\n-                        end if;\n-\n-                        if Full_Path then\n-                           return Get_Name_String\n-                             (Unit.File_Names (Impl).Path.Name);\n-\n-                        else\n-                           return Get_Name_String (Current_Name);\n-                        end if;\n-\n-                        --  If it has the name of the extended body name,\n-                        --  return the extended body name\n-\n-                     elsif Current_Name = File_Name_Type (The_Body_Name) then\n-                        if Current_Verbosity = High then\n-                           Write_Line (\"   OK\");\n-                        end if;\n-\n-                        if Full_Path then\n-                           return Get_Name_String\n-                             (Unit.File_Names (Impl).Path.Name);\n-\n-                        else\n-                           return Get_Name_String (The_Body_Name);\n-                        end if;\n-\n-                     else\n-                        if Current_Verbosity = High then\n-                           Write_Line (\"   not good\");\n-                        end if;\n-                     end if;\n-                  end if;\n-               end;\n-            end if;\n-\n-            --  Check for spec\n-\n-            if not Main_Project_Only\n-              or else (Unit.File_Names (Spec) /= null\n-                        and then Unit.File_Names (Spec).Project = The_Project)\n-            then\n-               declare\n-                  Current_Name : File_Name_Type;\n-\n-               begin\n-                  --  Case of spec present\n-\n-                  if Unit.File_Names (Spec) /= null then\n-                     Current_Name := Unit.File_Names (Spec).File;\n-                     if Current_Verbosity = High then\n-                        Write_Str  (\"   Comparing with \"\"\");\n-                        Write_Str  (Get_Name_String (Current_Name));\n-                        Write_Char ('\"');\n-                        Write_Eol;\n-                     end if;\n-\n-                     --  If name same as original name, return original name\n-\n-                     if Unit.Name = The_Original_Name\n-                       or else\n-                         Current_Name = File_Name_Type (The_Original_Name)\n-                     then\n-                        if Current_Verbosity = High then\n-                           Write_Line (\"   OK\");\n-                        end if;\n-\n-                        if Full_Path then\n-                           return Get_Name_String\n-                             (Unit.File_Names (Spec).Path.Name);\n-                        else\n-                           return Get_Name_String (Current_Name);\n-                        end if;\n-\n-                        --  If it has the same name as the extended spec name,\n-                        --  return the extended spec name.\n-\n-                     elsif Current_Name = File_Name_Type (The_Spec_Name) then\n-                        if Current_Verbosity = High then\n-                           Write_Line (\"   OK\");\n-                        end if;\n-\n-                        if Full_Path then\n-                           return Get_Name_String\n-                             (Unit.File_Names (Spec).Path.Name);\n-                        else\n-                           return Get_Name_String (The_Spec_Name);\n-                        end if;\n-\n-                     else\n-                        if Current_Verbosity = High then\n-                           Write_Line (\"   not good\");\n-                        end if;\n-                     end if;\n-                  end if;\n-               end;\n-            end if;\n-\n-            Unit := Units_Htable.Get_Next (In_Tree.Units_HT);\n-         end loop;\n-\n-         --  If we are not in an extending project, give up\n-\n-         exit when not Main_Project_Only\n-           or else The_Project.Extends = No_Project;\n-\n-         --  Otherwise, look in the project we are extending\n-\n-         The_Project := The_Project.Extends;\n-      end loop;\n-\n-      --  We don't know this file name, return an empty string\n-\n-      return \"\";\n-   end File_Name_Of_Library_Unit_Body;\n-\n-   -------------------------\n-   -- For_All_Object_Dirs --\n-   -------------------------\n-\n-   procedure For_All_Object_Dirs\n-     (Project : Project_Id;\n-      Tree    : Project_Tree_Ref)\n-   is\n-      procedure For_Project\n-        (Prj   : Project_Id;\n-         Tree  : Project_Tree_Ref;\n-         Dummy : in out Integer);\n-      --  Get all object directories of Prj\n-\n-      -----------------\n-      -- For_Project --\n-      -----------------\n-\n-      procedure For_Project\n-        (Prj   : Project_Id;\n-         Tree  : Project_Tree_Ref;\n-         Dummy : in out Integer)\n-      is\n-         pragma Unreferenced (Tree);\n-\n-      begin\n-         --  ??? Set_Ada_Paths has a different behavior for library project\n-         --  files, should we have the same ?\n-\n-         if Prj.Object_Directory /= No_Path_Information then\n-            Get_Name_String (Prj.Object_Directory.Display_Name);\n-            Action (Name_Buffer (1 .. Name_Len));\n-         end if;\n-      end For_Project;\n-\n-      procedure Get_Object_Dirs is\n-        new For_Every_Project_Imported (Integer, For_Project);\n-      Dummy : Integer := 1;\n-\n-   --  Start of processing for For_All_Object_Dirs\n-\n-   begin\n-      Get_Object_Dirs (Project, Tree, Dummy);\n-   end For_All_Object_Dirs;\n-\n-   -------------------------\n-   -- For_All_Source_Dirs --\n-   -------------------------\n-\n-   procedure For_All_Source_Dirs\n-     (Project : Project_Id;\n-      In_Tree : Project_Tree_Ref)\n-   is\n-      procedure For_Project\n-        (Prj     : Project_Id;\n-         In_Tree : Project_Tree_Ref;\n-         Dummy   : in out Integer);\n-      --  Get all object directories of Prj\n-\n-      -----------------\n-      -- For_Project --\n-      -----------------\n-\n-      procedure For_Project\n-        (Prj     : Project_Id;\n-         In_Tree : Project_Tree_Ref;\n-         Dummy   : in out Integer)\n-      is\n-         Current    : String_List_Id := Prj.Source_Dirs;\n-         The_String : String_Element;\n-\n-      begin\n-         --  If there are Ada sources, call action with the name of every\n-         --  source directory.\n-\n-         if Has_Ada_Sources (Prj) then\n-            while Current /= Nil_String loop\n-               The_String := In_Tree.Shared.String_Elements.Table (Current);\n-               Action (Get_Name_String (The_String.Display_Value));\n-               Current := The_String.Next;\n-            end loop;\n-         end if;\n-      end For_Project;\n-\n-      procedure Get_Source_Dirs is\n-        new For_Every_Project_Imported (Integer, For_Project);\n-      Dummy : Integer := 1;\n-\n-   --  Start of processing for For_All_Source_Dirs\n-\n-   begin\n-      Get_Source_Dirs (Project, In_Tree, Dummy);\n-   end For_All_Source_Dirs;\n-\n-   -------------------\n-   -- Get_Reference --\n-   -------------------\n-\n-   procedure Get_Reference\n-     (Source_File_Name : String;\n-      In_Tree          : Project_Tree_Ref;\n-      Project          : out Project_Id;\n-      Path             : out Path_Name_Type)\n-   is\n-   begin\n-      --  Body below could use some comments ???\n-\n-      if Current_Verbosity > Default then\n-         Write_Str (\"Getting Reference_Of (\"\"\");\n-         Write_Str (Source_File_Name);\n-         Write_Str (\"\"\") ... \");\n-      end if;\n-\n-      declare\n-         Original_Name : String := Source_File_Name;\n-         Unit          : Unit_Index;\n-\n-      begin\n-         Canonical_Case_File_Name (Original_Name);\n-         Unit := Units_Htable.Get_First (In_Tree.Units_HT);\n-\n-         while Unit /= null loop\n-            if Unit.File_Names (Spec) /= null\n-              and then not Unit.File_Names (Spec).Locally_Removed\n-              and then Unit.File_Names (Spec).File /= No_File\n-              and then\n-                (Namet.Get_Name_String\n-                   (Unit.File_Names (Spec).File) = Original_Name\n-                 or else (Unit.File_Names (Spec).Path /= No_Path_Information\n-                           and then\n-                             Namet.Get_Name_String\n-                               (Unit.File_Names (Spec).Path.Name) =\n-                                                           Original_Name))\n-            then\n-               Project :=\n-                 Ultimate_Extending_Project_Of\n-                   (Unit.File_Names (Spec).Project);\n-               Path := Unit.File_Names (Spec).Path.Display_Name;\n-\n-               if Current_Verbosity > Default then\n-                  Write_Str (\"Done: Spec.\");\n-                  Write_Eol;\n-               end if;\n-\n-               return;\n-\n-            elsif Unit.File_Names (Impl) /= null\n-              and then Unit.File_Names (Impl).File /= No_File\n-              and then not Unit.File_Names (Impl).Locally_Removed\n-              and then\n-                (Namet.Get_Name_String\n-                   (Unit.File_Names (Impl).File) = Original_Name\n-                  or else (Unit.File_Names (Impl).Path /= No_Path_Information\n-                            and then Namet.Get_Name_String\n-                                       (Unit.File_Names (Impl).Path.Name) =\n-                                                              Original_Name))\n-            then\n-               Project :=\n-                 Ultimate_Extending_Project_Of\n-                   (Unit.File_Names (Impl).Project);\n-               Path := Unit.File_Names (Impl).Path.Display_Name;\n-\n-               if Current_Verbosity > Default then\n-                  Write_Str (\"Done: Body.\");\n-                  Write_Eol;\n-               end if;\n-\n-               return;\n-            end if;\n-\n-            Unit := Units_Htable.Get_Next (In_Tree.Units_HT);\n-         end loop;\n-      end;\n-\n-      Project := No_Project;\n-      Path    := No_Path;\n-\n-      if Current_Verbosity > Default then\n-         Write_Str (\"Cannot be found.\");\n-         Write_Eol;\n-      end if;\n-   end Get_Reference;\n-\n-   ----------------------\n-   -- Get_Runtime_Path --\n-   ----------------------\n-\n-   function Get_Runtime_Path\n-     (Self : Project_Search_Path;\n-      Name : String) return String_Access\n-   is\n-      function Find_Rts_In_Path is\n-        new Prj.Env.Find_Name_In_Path (Check_Filename => Is_Directory);\n-   begin\n-      return Find_Rts_In_Path (Self, Name);\n-   end Get_Runtime_Path;\n-\n-   ----------------\n-   -- Initialize --\n-   ----------------\n-\n-   procedure Initialize (In_Tree : Project_Tree_Ref) is\n-   begin\n-      In_Tree.Shared.Private_Part.Current_Source_Path_File := No_Path;\n-      In_Tree.Shared.Private_Part.Current_Object_Path_File := No_Path;\n-   end Initialize;\n-\n-   -------------------\n-   -- Print_Sources --\n-   -------------------\n-\n-   --  Could use some comments in this body ???\n-\n-   procedure Print_Sources (In_Tree : Project_Tree_Ref) is\n-      Unit : Unit_Index;\n-\n-   begin\n-      Write_Line (\"List of Sources:\");\n-\n-      Unit := Units_Htable.Get_First (In_Tree.Units_HT);\n-      while Unit /= No_Unit_Index loop\n-         Write_Str  (\"   \");\n-         Write_Line (Namet.Get_Name_String (Unit.Name));\n-\n-         if Unit.File_Names (Spec).File /= No_File then\n-            if Unit.File_Names (Spec).Project = No_Project then\n-               Write_Line (\"   No project\");\n-\n-            else\n-               Write_Str  (\"   Project: \");\n-               Get_Name_String\n-                 (Unit.File_Names (Spec).Project.Path.Name);\n-               Write_Line (Name_Buffer (1 .. Name_Len));\n-            end if;\n-\n-            Write_Str  (\"      spec: \");\n-            Write_Line\n-              (Namet.Get_Name_String\n-               (Unit.File_Names (Spec).File));\n-         end if;\n-\n-         if Unit.File_Names (Impl).File /= No_File then\n-            if Unit.File_Names (Impl).Project = No_Project then\n-               Write_Line (\"   No project\");\n-\n-            else\n-               Write_Str  (\"   Project: \");\n-               Get_Name_String\n-                 (Unit.File_Names (Impl).Project.Path.Name);\n-               Write_Line (Name_Buffer (1 .. Name_Len));\n-            end if;\n-\n-            Write_Str  (\"      body: \");\n-            Write_Line\n-              (Namet.Get_Name_String (Unit.File_Names (Impl).File));\n-         end if;\n-\n-         Unit := Units_Htable.Get_Next (In_Tree.Units_HT);\n-      end loop;\n-\n-      Write_Line (\"end of List of Sources.\");\n-   end Print_Sources;\n-\n-   ----------------\n-   -- Project_Of --\n-   ----------------\n-\n-   function Project_Of\n-     (Name         : String;\n-      Main_Project : Project_Id;\n-      In_Tree      : Project_Tree_Ref) return Project_Id\n-   is\n-      Result : Project_Id := No_Project;\n-\n-      Original_Name : String := Name;\n-\n-      Lang : constant Language_Ptr :=\n-               Get_Language_From_Name (Main_Project, \"ada\");\n-\n-      Unit : Unit_Index;\n-\n-      Current_Name      : File_Name_Type;\n-      The_Original_Name : File_Name_Type;\n-      The_Spec_Name     : File_Name_Type;\n-      The_Body_Name     : File_Name_Type;\n-\n-   begin\n-      --  ??? Same block in File_Name_Of_Library_Unit_Body\n-      Canonical_Case_File_Name (Original_Name);\n-      Name_Len := Original_Name'Length;\n-      Name_Buffer (1 .. Name_Len) := Original_Name;\n-      The_Original_Name := Name_Find;\n-\n-      if Lang /= null then\n-         declare\n-            Naming : Lang_Naming_Data renames Lang.Config.Naming_Data;\n-            Extended_Spec_Name : String :=\n-                                   Name & Namet.Get_Name_String\n-                                            (Naming.Spec_Suffix);\n-            Extended_Body_Name : String :=\n-                                   Name & Namet.Get_Name_String\n-                                            (Naming.Body_Suffix);\n-\n-         begin\n-            Canonical_Case_File_Name (Extended_Spec_Name);\n-            Name_Len := Extended_Spec_Name'Length;\n-            Name_Buffer (1 .. Name_Len) := Extended_Spec_Name;\n-            The_Spec_Name := Name_Find;\n-\n-            Canonical_Case_File_Name (Extended_Body_Name);\n-            Name_Len := Extended_Body_Name'Length;\n-            Name_Buffer (1 .. Name_Len) := Extended_Body_Name;\n-            The_Body_Name := Name_Find;\n-         end;\n-\n-      else\n-         The_Spec_Name := The_Original_Name;\n-         The_Body_Name := The_Original_Name;\n-      end if;\n-\n-      Unit := Units_Htable.Get_First (In_Tree.Units_HT);\n-      while Unit /= null loop\n-\n-         --  Case of a body present\n-\n-         if Unit.File_Names (Impl) /= null then\n-            Current_Name := Unit.File_Names (Impl).File;\n-\n-            --  If it has the name of the original name or the body name,\n-            --  we have found the project.\n-\n-            if Unit.Name = Name_Id (The_Original_Name)\n-              or else Current_Name = The_Original_Name\n-              or else Current_Name = The_Body_Name\n-            then\n-               Result := Unit.File_Names (Impl).Project;\n-               exit;\n-            end if;\n-         end if;\n-\n-         --  Check for spec\n-\n-         if Unit.File_Names (Spec) /= null then\n-            Current_Name := Unit.File_Names (Spec).File;\n-\n-            --  If name same as the original name, or the spec name, we have\n-            --  found the project.\n-\n-            if Unit.Name = Name_Id (The_Original_Name)\n-              or else Current_Name = The_Original_Name\n-              or else Current_Name = The_Spec_Name\n-            then\n-               Result := Unit.File_Names (Spec).Project;\n-               exit;\n-            end if;\n-         end if;\n-\n-         Unit := Units_Htable.Get_Next (In_Tree.Units_HT);\n-      end loop;\n-\n-      return Ultimate_Extending_Project_Of (Result);\n-   end Project_Of;\n-\n-   -------------------\n-   -- Set_Ada_Paths --\n-   -------------------\n-\n-   procedure Set_Ada_Paths\n-     (Project             : Project_Id;\n-      In_Tree             : Project_Tree_Ref;\n-      Including_Libraries : Boolean;\n-      Include_Path        : Boolean := True;\n-      Objects_Path        : Boolean := True)\n-\n-   is\n-      Shared : constant Shared_Project_Tree_Data_Access := In_Tree.Shared;\n-\n-      Source_Paths : Source_Path_Table.Instance;\n-      Object_Paths : Object_Path_Table.Instance;\n-      --  List of source or object dirs. Only computed the first time this\n-      --  procedure is called (since Source_FD is then reused)\n-\n-      Source_FD : File_Descriptor := Invalid_FD;\n-      Object_FD : File_Descriptor := Invalid_FD;\n-      --  The temporary files to store the paths. These are only created the\n-      --  first time this procedure is called, and reused from then on.\n-\n-      Process_Source_Dirs : Boolean := False;\n-      Process_Object_Dirs : Boolean := False;\n-\n-      Status : Boolean;\n-      --  For calls to Close\n-\n-      Last        : Natural;\n-      Buffer      : String_Access := new String (1 .. Buffer_Initial);\n-      Buffer_Last : Natural := 0;\n-\n-      procedure Recursive_Add\n-        (Project : Project_Id;\n-         In_Tree : Project_Tree_Ref;\n-         Dummy   : in out Boolean);\n-      --  Recursive procedure to add the source/object paths of extended/\n-      --  imported projects.\n-\n-      -------------------\n-      -- Recursive_Add --\n-      -------------------\n-\n-      procedure Recursive_Add\n-        (Project : Project_Id;\n-         In_Tree : Project_Tree_Ref;\n-         Dummy   : in out Boolean)\n-      is\n-         pragma Unreferenced (In_Tree);\n-\n-         Path : Path_Name_Type;\n-\n-      begin\n-         if Process_Source_Dirs then\n-\n-            --  Add to path all source directories of this project if there are\n-            --  Ada sources.\n-\n-            if Has_Ada_Sources (Project) then\n-               Add_To_Source_Path (Project.Source_Dirs, Shared, Source_Paths);\n-            end if;\n-         end if;\n-\n-         if Process_Object_Dirs then\n-            Path := Get_Object_Directory\n-              (Project,\n-               Including_Libraries => Including_Libraries,\n-               Only_If_Ada         => True);\n-\n-            if Path /= No_Path then\n-               Add_To_Object_Path (Path, Object_Paths);\n-            end if;\n-         end if;\n-      end Recursive_Add;\n-\n-      procedure For_All_Projects is\n-        new For_Every_Project_Imported (Boolean, Recursive_Add);\n-\n-      Dummy : Boolean := False;\n-\n-   --  Start of processing for Set_Ada_Paths\n-\n-   begin\n-      --  If it is the first time we call this procedure for this project,\n-      --  compute the source path and/or the object path.\n-\n-      if Include_Path and then Project.Include_Path_File = No_Path then\n-         Source_Path_Table.Init (Source_Paths);\n-         Process_Source_Dirs := True;\n-         Create_New_Path_File (Shared, Source_FD, Project.Include_Path_File);\n-      end if;\n-\n-      --  For the object path, we make a distinction depending on\n-      --  Including_Libraries.\n-\n-      if Objects_Path and Including_Libraries then\n-         if Project.Objects_Path_File_With_Libs = No_Path then\n-            Object_Path_Table.Init (Object_Paths);\n-            Process_Object_Dirs := True;\n-            Create_New_Path_File\n-              (Shared, Object_FD, Project.Objects_Path_File_With_Libs);\n-         end if;\n-\n-      elsif Objects_Path then\n-         if Project.Objects_Path_File_Without_Libs = No_Path then\n-            Object_Path_Table.Init (Object_Paths);\n-            Process_Object_Dirs := True;\n-            Create_New_Path_File\n-              (Shared, Object_FD, Project.Objects_Path_File_Without_Libs);\n-         end if;\n-      end if;\n-\n-      --  If there is something to do, set Seen to False for all projects,\n-      --  then call the recursive procedure Add for Project.\n-\n-      if Process_Source_Dirs or Process_Object_Dirs then\n-         For_All_Projects (Project, In_Tree, Dummy);\n-      end if;\n-\n-      --  Write and close any file that has been created. Source_FD is not set\n-      --  when this subprogram is called a second time or more, since we reuse\n-      --  the previous version of the file.\n-\n-      if Source_FD /= Invalid_FD then\n-         Buffer_Last := 0;\n-\n-         for Index in\n-           Source_Path_Table.First .. Source_Path_Table.Last (Source_Paths)\n-         loop\n-            Get_Name_String (Source_Paths.Table (Index));\n-            Name_Len := Name_Len + 1;\n-            Name_Buffer (Name_Len) := ASCII.LF;\n-            Add_To_Buffer (Name_Buffer (1 .. Name_Len), Buffer, Buffer_Last);\n-         end loop;\n-\n-         Last := Write (Source_FD, Buffer (1)'Address, Buffer_Last);\n-\n-         if Last = Buffer_Last then\n-            Close (Source_FD, Status);\n-\n-         else\n-            Status := False;\n-         end if;\n-\n-         if not Status then\n-            Prj.Com.Fail (\"could not write temporary file\");\n-         end if;\n-      end if;\n-\n-      if Object_FD /= Invalid_FD then\n-         Buffer_Last := 0;\n-\n-         for Index in\n-           Object_Path_Table.First .. Object_Path_Table.Last (Object_Paths)\n-         loop\n-            Get_Name_String (Object_Paths.Table (Index));\n-            Name_Len := Name_Len + 1;\n-            Name_Buffer (Name_Len) := ASCII.LF;\n-            Add_To_Buffer (Name_Buffer (1 .. Name_Len), Buffer, Buffer_Last);\n-         end loop;\n-\n-         Last := Write (Object_FD, Buffer (1)'Address, Buffer_Last);\n-\n-         if Last = Buffer_Last then\n-            Close (Object_FD, Status);\n-         else\n-            Status := False;\n-         end if;\n-\n-         if not Status then\n-            Prj.Com.Fail (\"could not write temporary file\");\n-         end if;\n-      end if;\n-\n-      --  Set the env vars, if they need to be changed, and set the\n-      --  corresponding flags.\n-\n-      if Include_Path\n-        and then\n-          Shared.Private_Part.Current_Source_Path_File /=\n-            Project.Include_Path_File\n-      then\n-         Shared.Private_Part.Current_Source_Path_File :=\n-           Project.Include_Path_File;\n-         Set_Path_File_Var\n-           (Project_Include_Path_File,\n-            Get_Name_String (Shared.Private_Part.Current_Source_Path_File));\n-      end if;\n-\n-      if Objects_Path then\n-         if Including_Libraries then\n-            if Shared.Private_Part.Current_Object_Path_File /=\n-              Project.Objects_Path_File_With_Libs\n-            then\n-               Shared.Private_Part.Current_Object_Path_File :=\n-                 Project.Objects_Path_File_With_Libs;\n-               Set_Path_File_Var\n-                 (Project_Objects_Path_File,\n-                  Get_Name_String\n-                    (Shared.Private_Part.Current_Object_Path_File));\n-            end if;\n-\n-         else\n-            if Shared.Private_Part.Current_Object_Path_File /=\n-              Project.Objects_Path_File_Without_Libs\n-            then\n-               Shared.Private_Part.Current_Object_Path_File :=\n-                 Project.Objects_Path_File_Without_Libs;\n-               Set_Path_File_Var\n-                 (Project_Objects_Path_File,\n-                  Get_Name_String\n-                    (Shared.Private_Part.Current_Object_Path_File));\n-            end if;\n-         end if;\n-      end if;\n-\n-      Free (Buffer);\n-   end Set_Ada_Paths;\n-\n-   ---------------------\n-   -- Add_Directories --\n-   ---------------------\n-\n-   procedure Add_Directories\n-     (Self    : in out Project_Search_Path;\n-      Path    : String;\n-      Prepend : Boolean := False)\n-   is\n-      Tmp : String_Access;\n-   begin\n-      if Self.Path = null then\n-         Self.Path := new String'(Uninitialized_Prefix & Path);\n-      else\n-         Tmp := Self.Path;\n-         if Prepend then\n-            Self.Path := new String'(Path & Path_Separator & Tmp.all);\n-         else\n-            Self.Path := new String'(Tmp.all & Path_Separator & Path);\n-         end if;\n-         Free (Tmp);\n-      end if;\n-\n-      if Current_Verbosity = High then\n-         Debug_Output (\"Adding directories to Project_Path: \"\"\"\n-                       & Path & '\"');\n-      end if;\n-   end Add_Directories;\n-\n-   --------------------\n-   -- Is_Initialized --\n-   --------------------\n-\n-   function Is_Initialized (Self : Project_Search_Path) return Boolean is\n-   begin\n-      return Self.Path /= null\n-        and then (Self.Path'Length = 0\n-                   or else Self.Path (Self.Path'First) /= '#');\n-   end Is_Initialized;\n-\n-   ----------------------\n-   -- Initialize_Empty --\n-   ----------------------\n-\n-   procedure Initialize_Empty (Self : in out Project_Search_Path) is\n-   begin\n-      Free (Self.Path);\n-      Self.Path := new String'(\"\");\n-   end Initialize_Empty;\n-\n-   -------------------------------------\n-   -- Initialize_Default_Project_Path --\n-   -------------------------------------\n-\n-   procedure Initialize_Default_Project_Path\n-     (Self         : in out Project_Search_Path;\n-      Target_Name  : String;\n-      Runtime_Name : String := \"\")\n-   is\n-      Add_Default_Dir : Boolean := Target_Name /= \"-\";\n-      First           : Positive;\n-      Last            : Positive;\n-\n-      Ada_Project_Path      : constant String := \"ADA_PROJECT_PATH\";\n-      Gpr_Project_Path      : constant String := \"GPR_PROJECT_PATH\";\n-      Gpr_Project_Path_File : constant String := \"GPR_PROJECT_PATH_FILE\";\n-      --  Names of alternate env. variable that contain path name(s) of\n-      --  directories where project files may reside. They are taken into\n-      --  account in this order: GPR_PROJECT_PATH_FILE, GPR_PROJECT_PATH,\n-      --  ADA_PROJECT_PATH.\n-\n-      Gpr_Prj_Path_File : String_Access;\n-      Gpr_Prj_Path      : String_Access;\n-      Ada_Prj_Path      : String_Access;\n-      --  The path name(s) of directories where project files may reside.\n-      --  May be empty.\n-\n-      Prefix  : String_Ptr;\n-      Runtime : String_Ptr;\n-\n-      procedure Add_Target;\n-      --  Add :<prefix>/<target> to the project path\n-\n-      ----------------\n-      -- Add_Target --\n-      ----------------\n-\n-      procedure Add_Target is\n-      begin\n-         Add_Str_To_Name_Buffer\n-           (Path_Separator & Prefix.all & Target_Name);\n-\n-         --  Note: Target_Name has a trailing / when it comes from Sdefault\n-\n-         if Name_Buffer (Name_Len) /= '/' then\n-            Add_Char_To_Name_Buffer (Directory_Separator);\n-         end if;\n-      end Add_Target;\n-\n-   --  Start of processing for Initialize_Default_Project_Path\n-\n-   begin\n-      if Is_Initialized (Self) then\n-         return;\n-      end if;\n-\n-      --  The current directory is always first in the search path. Since the\n-      --  Project_Path currently starts with '#:' as a sign that it isn't\n-      --  initialized, we simply replace '#' with '.'\n-\n-      if Self.Path = null then\n-         Self.Path := new String'('.' & Path_Separator);\n-      else\n-         Self.Path (Self.Path'First) := '.';\n-      end if;\n-\n-      --  Then the reset of the project path (if any) currently contains the\n-      --  directories added through Add_Search_Project_Directory\n-\n-      --  If environment variables are defined and not empty, add their content\n-\n-      Gpr_Prj_Path_File := Getenv (Gpr_Project_Path_File);\n-      Gpr_Prj_Path      := Getenv (Gpr_Project_Path);\n-      Ada_Prj_Path      := Getenv (Ada_Project_Path);\n-\n-      if Gpr_Prj_Path_File.all /= \"\" then\n-         declare\n-            File : Ada.Text_IO.File_Type;\n-            Line : String (1 .. 10_000);\n-            Last : Natural;\n-\n-            Tmp : String_Access;\n-\n-         begin\n-            Open (File, In_File, Gpr_Prj_Path_File.all);\n-\n-            while not End_Of_File (File) loop\n-               Get_Line (File, Line, Last);\n-\n-               if Last /= 0\n-                 and then (Last = 1 or else Line (1 .. 2) /= \"--\")\n-               then\n-                  Tmp := Self.Path;\n-                  Self.Path :=\n-                    new String'\n-                      (Tmp.all & Path_Separator & Line (1 .. Last));\n-                  Free (Tmp);\n-               end if;\n-\n-               if Current_Verbosity = High then\n-                  Debug_Output (\"Adding directory to Project_Path: \"\"\"\n-                                & Line (1 .. Last) & '\"');\n-               end if;\n-            end loop;\n-\n-            Close (File);\n-\n-         exception\n-            when others =>\n-               Write_Str (\"warning: could not read project path file \"\"\");\n-               Write_Str (Gpr_Prj_Path_File.all);\n-               Write_Line (\"\"\"\");\n-         end;\n-\n-      end if;\n-\n-      if Gpr_Prj_Path.all /= \"\" then\n-         Add_Directories (Self, Gpr_Prj_Path.all);\n-      end if;\n-\n-      Free (Gpr_Prj_Path);\n-\n-      if Ada_Prj_Path.all /= \"\" then\n-         Add_Directories (Self, Ada_Prj_Path.all);\n-      end if;\n-\n-      Free (Ada_Prj_Path);\n-\n-      --  Copy to Name_Buffer, since we will need to manipulate the path\n-\n-      Name_Len := Self.Path'Length;\n-      Name_Buffer (1 .. Name_Len) := Self.Path.all;\n-\n-      --  Scan the directory path to see if \"-\" is one of the directories.\n-      --  Remove each occurrence of \"-\" and set Add_Default_Dir to False.\n-      --  Also resolve relative paths and symbolic links.\n-\n-      First := 3;\n-      loop\n-         while First <= Name_Len\n-           and then (Name_Buffer (First) = Path_Separator)\n-         loop\n-            First := First + 1;\n-         end loop;\n-\n-         exit when First > Name_Len;\n-\n-         Last := First;\n-\n-         while Last < Name_Len\n-           and then Name_Buffer (Last + 1) /= Path_Separator\n-         loop\n-            Last := Last + 1;\n-         end loop;\n-\n-         --  If the directory is \"-\", set Add_Default_Dir to False and\n-         --  remove from path.\n-\n-         if Name_Buffer (First .. Last) = No_Project_Default_Dir then\n-            Add_Default_Dir := False;\n-\n-            for J in Last + 1 .. Name_Len loop\n-               Name_Buffer (J - No_Project_Default_Dir'Length - 1) :=\n-                 Name_Buffer (J);\n-            end loop;\n-\n-            Name_Len := Name_Len - No_Project_Default_Dir'Length - 1;\n-\n-            --  After removing the '-', go back one character to get the next\n-            --  directory correctly.\n-\n-            Last := Last - 1;\n-\n-         else\n-            declare\n-               New_Dir : constant String :=\n-                           Normalize_Pathname\n-                             (Name_Buffer (First .. Last),\n-                              Resolve_Links => Opt.Follow_Links_For_Dirs);\n-               New_Len  : Positive;\n-               New_Last : Positive;\n-\n-            begin\n-               --  If the absolute path was resolved and is different from\n-               --  the original, replace original with the resolved path.\n-\n-               if New_Dir /= Name_Buffer (First .. Last)\n-                 and then New_Dir'Length /= 0\n-               then\n-                  New_Len := Name_Len + New_Dir'Length - (Last - First + 1);\n-                  New_Last := First + New_Dir'Length - 1;\n-                  Name_Buffer (New_Last + 1 .. New_Len) :=\n-                    Name_Buffer (Last + 1 .. Name_Len);\n-                  Name_Buffer (First .. New_Last) := New_Dir;\n-                  Name_Len := New_Len;\n-                  Last := New_Last;\n-               end if;\n-            end;\n-         end if;\n-\n-         First := Last + 1;\n-      end loop;\n-\n-      Free (Self.Path);\n-\n-      --  Set the initial value of Current_Project_Path\n-\n-      if Add_Default_Dir then\n-         if Sdefault.Search_Dir_Prefix = null then\n-\n-            --  gprbuild case\n-\n-            Prefix := new String'(Executable_Prefix_Path);\n-\n-         else\n-            Prefix := new String'(Sdefault.Search_Dir_Prefix.all\n-                                  & \"..\" & Dir_Separator\n-                                  & \"..\" & Dir_Separator\n-                                  & \"..\" & Dir_Separator\n-                                  & \"..\" & Dir_Separator);\n-         end if;\n-\n-         if Prefix.all /= \"\" then\n-            if Target_Name /= \"\" then\n-\n-               if Runtime_Name /= \"\" then\n-                  if Base_Name (Runtime_Name) = Runtime_Name then\n-\n-                     --  $prefix/$target/$runtime/lib/gnat\n-                     Add_Target;\n-                     Add_Str_To_Name_Buffer\n-                       (Runtime_Name & Directory_Separator &\n-                          \"lib\" & Directory_Separator & \"gnat\");\n-\n-                     --  $prefix/$target/$runtime/share/gpr\n-                     Add_Target;\n-                     Add_Str_To_Name_Buffer\n-                       (Runtime_Name & Directory_Separator &\n-                          \"share\" & Directory_Separator & \"gpr\");\n-\n-                  else\n-                     Runtime :=\n-                       new String'(Normalize_Pathname (Runtime_Name));\n-\n-                     --  $runtime_dir/lib/gnat\n-                     Add_Str_To_Name_Buffer\n-                       (Path_Separator & Runtime.all & Directory_Separator &\n-                        \"lib\" & Directory_Separator & \"gnat\");\n-\n-                     --  $runtime_dir/share/gpr\n-                     Add_Str_To_Name_Buffer\n-                       (Path_Separator & Runtime.all & Directory_Separator &\n-                        \"share\" & Directory_Separator & \"gpr\");\n-                  end if;\n-               end if;\n-\n-               --  $prefix/$target/lib/gnat\n-\n-               Add_Target;\n-               Add_Str_To_Name_Buffer\n-                 (\"lib\" & Directory_Separator & \"gnat\");\n-\n-               --  $prefix/$target/share/gpr\n-\n-               Add_Target;\n-               Add_Str_To_Name_Buffer\n-                 (\"share\" & Directory_Separator & \"gpr\");\n-            end if;\n-\n-            --  $prefix/share/gpr\n-\n-            Add_Str_To_Name_Buffer\n-              (Path_Separator & Prefix.all & \"share\"\n-               & Directory_Separator & \"gpr\");\n-\n-            --  $prefix/lib/gnat\n-\n-            Add_Str_To_Name_Buffer\n-              (Path_Separator & Prefix.all & \"lib\"\n-               & Directory_Separator & \"gnat\");\n-         end if;\n-\n-         Free (Prefix);\n-      end if;\n-\n-      Self.Path := new String'(Name_Buffer (1 .. Name_Len));\n-   end Initialize_Default_Project_Path;\n-\n-   --------------\n-   -- Get_Path --\n-   --------------\n-\n-   procedure Get_Path (Self : Project_Search_Path; Path : out String_Access) is\n-   begin\n-      pragma Assert (Is_Initialized (Self));\n-      Path := Self.Path;\n-   end Get_Path;\n-\n-   --------------\n-   -- Set_Path --\n-   --------------\n-\n-   procedure Set_Path (Self : in out Project_Search_Path; Path : String) is\n-   begin\n-      Free (Self.Path);\n-      Self.Path := new String'(Path);\n-      Projects_Paths.Reset (Self.Cache);\n-   end Set_Path;\n-\n-   -----------------------\n-   -- Find_Name_In_Path --\n-   -----------------------\n-\n-   function Find_Name_In_Path\n-     (Self : Project_Search_Path;\n-      Path : String) return String_Access\n-   is\n-      First : Natural;\n-      Last  : Natural;\n-\n-   begin\n-      if Current_Verbosity = High then\n-         Debug_Output (\"Trying \" & Path);\n-      end if;\n-\n-      if Is_Absolute_Path (Path) then\n-         if Check_Filename (Path) then\n-            return new String'(Path);\n-         else\n-            return null;\n-         end if;\n-\n-      else\n-         --  Because we don't want to resolve symbolic links, we cannot use\n-         --  Locate_Regular_File. So, we try each possible path successively.\n-\n-         First := Self.Path'First;\n-         while First <= Self.Path'Last loop\n-            while First <= Self.Path'Last\n-              and then Self.Path (First) = Path_Separator\n-            loop\n-               First := First + 1;\n-            end loop;\n-\n-            exit when First > Self.Path'Last;\n-\n-            Last := First;\n-            while Last < Self.Path'Last\n-              and then Self.Path (Last + 1) /= Path_Separator\n-            loop\n-               Last := Last + 1;\n-            end loop;\n-\n-            Name_Len := 0;\n-\n-            if not Is_Absolute_Path (Self.Path (First .. Last)) then\n-               Add_Str_To_Name_Buffer (Get_Current_Dir);  -- ??? System call\n-               Add_Char_To_Name_Buffer (Directory_Separator);\n-            end if;\n-\n-            Add_Str_To_Name_Buffer (Self.Path (First .. Last));\n-            Add_Char_To_Name_Buffer (Directory_Separator);\n-            Add_Str_To_Name_Buffer (Path);\n-\n-            if Current_Verbosity = High then\n-               Debug_Output (\"Testing file \" & Name_Buffer (1 .. Name_Len));\n-            end if;\n-\n-            if Check_Filename (Name_Buffer (1 .. Name_Len)) then\n-               return new String'(Name_Buffer (1 .. Name_Len));\n-            end if;\n-\n-            First := Last + 1;\n-         end loop;\n-      end if;\n-\n-      return null;\n-   end Find_Name_In_Path;\n-\n-   ------------------\n-   -- Find_Project --\n-   ------------------\n-\n-   procedure Find_Project\n-     (Self               : in out Project_Search_Path;\n-      Project_File_Name  : String;\n-      Directory          : String;\n-      Path               : out Namet.Path_Name_Type)\n-   is\n-      Result  : String_Access;\n-      Has_Dot : Boolean := False;\n-      Key     : Name_Id;\n-\n-      File : constant String := Project_File_Name;\n-      --  Have to do a copy, in case the parameter is Name_Buffer, which we\n-      --  modify below.\n-\n-      Cached_Path : Namet.Path_Name_Type;\n-      --  This should be commented rather than making us guess from the name???\n-\n-      function Try_Path_Name is new\n-        Find_Name_In_Path (Check_Filename => Is_Regular_File);\n-      --  Find a file in the project search path\n-\n-   --  Start of processing for Find_Project\n-\n-   begin\n-      pragma Assert (Is_Initialized (Self));\n-\n-      if Current_Verbosity = High then\n-         Debug_Increase_Indent\n-           (\"Searching for project \"\"\" & File & \"\"\" in \"\"\"\n-            & Directory & '\"');\n-      end if;\n-\n-      --  Check the project cache\n-\n-      Name_Len := File'Length;\n-      Name_Buffer (1 .. Name_Len) := File;\n-      Key := Name_Find;\n-      Cached_Path := Projects_Paths.Get (Self.Cache, Key);\n-\n-      --  Check if File contains an extension (a dot before a\n-      --  directory separator). If it is the case we do not try project file\n-      --  with an added extension as it is not possible to have multiple dots\n-      --  on a project file name.\n-\n-      Check_Dot : for K in reverse File'Range loop\n-         if File (K) = '.' then\n-            Has_Dot := True;\n-            exit Check_Dot;\n-         end if;\n-\n-         exit Check_Dot when Is_Directory_Separator (File (K));\n-      end loop Check_Dot;\n-\n-      if not Is_Absolute_Path (File) then\n-\n-         --  If we have found project in the cache, check if in the directory\n-\n-         if Cached_Path /= No_Path then\n-            declare\n-               Cached : constant String := Get_Name_String (Cached_Path);\n-            begin\n-               if (not Has_Dot\n-                    and then Cached =\n-                      GNAT.OS_Lib.Normalize_Pathname\n-                        (File & Project_File_Extension,\n-                         Directory      => Directory,\n-                         Resolve_Links  => Opt.Follow_Links_For_Files,\n-                         Case_Sensitive => True))\n-                 or else\n-                   Cached =\n-                     GNAT.OS_Lib.Normalize_Pathname\n-                       (File,\n-                        Directory      => Directory,\n-                        Resolve_Links  => Opt.Follow_Links_For_Files,\n-                        Case_Sensitive => True)\n-               then\n-                  Path := Cached_Path;\n-                  Debug_Decrease_Indent;\n-                  return;\n-               end if;\n-            end;\n-         end if;\n-\n-         --  First we try <directory>/<file_name>.<extension>\n-\n-         if not Has_Dot then\n-            Result :=\n-              Try_Path_Name\n-                (Self,\n-                 Directory & Directory_Separator\n-                 & File & Project_File_Extension);\n-         end if;\n-\n-         --  Then we try <directory>/<file_name>\n-\n-         if Result = null then\n-            Result :=\n-              Try_Path_Name (Self, Directory & Directory_Separator & File);\n-         end if;\n-      end if;\n-\n-      --  If we found the path in the cache, this is the one\n-\n-      if Result = null and then Cached_Path /= No_Path then\n-         Path := Cached_Path;\n-         Debug_Decrease_Indent;\n-         return;\n-      end if;\n-\n-      --  Then we try <file_name>.<extension>\n-\n-      if Result = null and then not Has_Dot then\n-         Result := Try_Path_Name (Self, File & Project_File_Extension);\n-      end if;\n-\n-      --  Then we try <file_name>\n-\n-      if Result = null then\n-         Result := Try_Path_Name (Self, File);\n-      end if;\n-\n-      --  If we cannot find the project file, we return an empty string\n-\n-      if Result = null then\n-         Path := Namet.No_Path;\n-         return;\n-\n-      else\n-         declare\n-            Final_Result : constant String :=\n-                             GNAT.OS_Lib.Normalize_Pathname\n-                               (Result.all,\n-                                Directory      => Directory,\n-                                Resolve_Links  => Opt.Follow_Links_For_Files,\n-                                Case_Sensitive => True);\n-         begin\n-            Free (Result);\n-            Name_Len := Final_Result'Length;\n-            Name_Buffer (1 .. Name_Len) := Final_Result;\n-            Path := Name_Find;\n-            Projects_Paths.Set (Self.Cache, Key, Path);\n-         end;\n-      end if;\n-\n-      Debug_Decrease_Indent;\n-   end Find_Project;\n-\n-   ----------\n-   -- Free --\n-   ----------\n-\n-   procedure Free (Self : in out Project_Search_Path) is\n-   begin\n-      Free (Self.Path);\n-      Projects_Paths.Reset (Self.Cache);\n-   end Free;\n-\n-   ----------\n-   -- Copy --\n-   ----------\n-\n-   procedure Copy (From : Project_Search_Path; To : out Project_Search_Path) is\n-   begin\n-      Free (To);\n-\n-      if From.Path /= null then\n-         To.Path := new String'(From.Path.all);\n-      end if;\n-\n-      --  No need to copy the Cache, it will be recomputed as needed\n-   end Copy;\n-\n-end Prj.Env;"}, {"sha": "a7617afab909ff55299425edf9385aed04c57fe9", "filename": "gcc/ada/prj-env.ads", "status": "removed", "additions": 0, "deletions": 275, "changes": 275, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-env.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-env.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-env.ads?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793", "patch": "@@ -1,275 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                              P R J . E N V                               --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---          Copyright (C) 2001-2014, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This package implements services for Project-aware tools, mostly related\n---  to the environment (configuration pragma files, path files, mapping files).\n-\n-with GNAT.Dynamic_HTables;\n-with GNAT.OS_Lib;\n-\n-package Prj.Env is\n-\n-   procedure Initialize (In_Tree : Project_Tree_Ref);\n-   --  Initialize global components relative to environment variables\n-\n-   procedure Print_Sources (In_Tree : Project_Tree_Ref);\n-   --  Output the list of sources after Project files have been scanned\n-\n-   procedure Create_Mapping (In_Tree : Project_Tree_Ref);\n-   --  Create in memory mapping from the sources of all the projects (in body\n-   --  of package Fmap), so that Osint.Find_File will find the correct path\n-   --  corresponding to a source.\n-\n-   procedure Create_Temp_File\n-     (Shared    : Shared_Project_Tree_Data_Access;\n-      Path_FD   : out File_Descriptor;\n-      Path_Name : out Path_Name_Type;\n-      File_Use  : String);\n-   --  Create temporary file, fail with an error if it could not be created\n-\n-   procedure Create_Mapping_File\n-     (Project  : Project_Id;\n-      Language : Name_Id;\n-      In_Tree  : Project_Tree_Ref;\n-      Name     : out Path_Name_Type);\n-   --  Create a temporary mapping file for project Project. For each source or\n-   --  template of Language in the Project, put the mapping of its file name\n-   --  and path name in this file. See fmap for a description of the format\n-   --  of the mapping file.\n-   --\n-   --  Implementation note: we pass a language name, not a language_index here,\n-   --  since the latter would have to match exactly the index of that language\n-   --  for the specified project, and that is not information available in\n-   --  buildgpr.adb.\n-\n-   procedure Create_Config_Pragmas_File\n-     (For_Project : Project_Id;\n-      In_Tree     : Project_Tree_Ref);\n-   --  If we need SFN pragmas, either for non standard naming schemes or for\n-   --  individual units.\n-\n-   procedure Create_New_Path_File\n-     (Shared    : Shared_Project_Tree_Data_Access;\n-      Path_FD   : out File_Descriptor;\n-      Path_Name : out Path_Name_Type);\n-   --  Create a new temporary path file, placing file name in Path_Name\n-\n-   function Ada_Include_Path\n-     (Project   : Project_Id;\n-      In_Tree   : Project_Tree_Ref;\n-      Recursive : Boolean := False) return String;\n-   --  Get the source search path of a Project file. If Recursive it True, get\n-   --  all the source directories of the imported and modified project files\n-   --  (recursively). If Recursive is False, just get the path for the source\n-   --  directories of Project. Note: the resulting String may be empty if there\n-   --  is no source directory in the project file.\n-\n-   function Ada_Objects_Path\n-     (Project             : Project_Id;\n-      In_Tree             : Project_Tree_Ref;\n-      Including_Libraries : Boolean := True) return String_Access;\n-   --  Get the ADA_OBJECTS_PATH of a Project file. For the first call with the\n-   --  exact same parameters, compute it and cache it. When Including_Libraries\n-   --  is True, the object directory of a library project is replaced with the\n-   --  library ALI directory of this project (usually the library directory of\n-   --  the project, except when attribute Library_ALI_Dir is declared) except\n-   --  when the library ALI directory does not contain any ALI file.\n-\n-   procedure Set_Ada_Paths\n-     (Project             : Project_Id;\n-      In_Tree             : Project_Tree_Ref;\n-      Including_Libraries : Boolean;\n-      Include_Path        : Boolean := True;\n-      Objects_Path        : Boolean := True);\n-   --  Set the environment variables for additional project path files, after\n-   --  creating the path files if necessary.\n-\n-   function File_Name_Of_Library_Unit_Body\n-     (Name              : String;\n-      Project           : Project_Id;\n-      In_Tree           : Project_Tree_Ref;\n-      Main_Project_Only : Boolean := True;\n-      Full_Path         : Boolean := False) return String;\n-   --  Returns the file name of a library unit, in canonical case. Name may or\n-   --  may not have an extension (corresponding to the naming scheme of the\n-   --  project). If there is no body with this name, but there is a spec, the\n-   --  name of the spec is returned.\n-   --\n-   --  If Full_Path is False (the default), the simple file name is returned.\n-   --  If Full_Path is True, the absolute path name is returned.\n-   --\n-   --  If neither a body nor a spec can be found, an empty string is returned.\n-   --  If Main_Project_Only is True, the unit must be an immediate source of\n-   --  Project. If it is False, it may be a source of one of its imported\n-   --  projects.\n-\n-   function Project_Of\n-     (Name         : String;\n-      Main_Project : Project_Id;\n-      In_Tree      : Project_Tree_Ref) return Project_Id;\n-   --  Get the project of a source. The source file name may be truncated\n-   --  (\".adb\" or \".ads\" may be missing). If the source is in a project being\n-   --  extended, return the ultimate extending project. If it is not a source\n-   --  of any project, return No_Project.\n-\n-   procedure Get_Reference\n-     (Source_File_Name : String;\n-      In_Tree          : Project_Tree_Ref;\n-      Project          : out Project_Id;\n-      Path             : out Path_Name_Type);\n-   --  Returns the project of a source and its path in displayable form\n-\n-   generic\n-      with procedure Action (Path : String);\n-   procedure For_All_Source_Dirs\n-     (Project : Project_Id;\n-      In_Tree : Project_Tree_Ref);\n-   --  Iterate through all the source directories of a project, including those\n-   --  of imported or modified projects. Only returns those directories that\n-   --  potentially contain Ada sources (ie ignore projects that have no Ada\n-   --  sources\n-\n-   generic\n-      with procedure Action (Path : String);\n-   procedure For_All_Object_Dirs\n-     (Project : Project_Id;\n-      Tree    : Project_Tree_Ref);\n-   --  Iterate through all the object directories of a project, including those\n-   --  of imported or modified projects.\n-\n-   ------------------\n-   -- Project Path --\n-   ------------------\n-\n-   type Project_Search_Path is private;\n-   --  An abstraction of the project path. This object provides subprograms\n-   --  to search for projects on the path (and caches the results to improve\n-   --  efficiency).\n-\n-   No_Project_Search_Path : constant Project_Search_Path;\n-\n-   procedure Initialize_Default_Project_Path\n-     (Self         : in out Project_Search_Path;\n-      Target_Name  : String;\n-      Runtime_Name : String := \"\");\n-   --  Initialize Self. It will then contain the default project path on\n-   --  the given target and runtime (including directories specified by the\n-   --  environment variables GPR_PROJECT_PATH_FILE, GPR_PROJECT_PATH and\n-   --  ADA_PROJECT_PATH). If one of the directory or Target_Name is \"-\", then\n-   --  the path contains only those directories specified by the environment\n-   --  variables (except \"-\"). This does nothing if Self has already been\n-   --  initialized.\n-\n-   procedure Copy (From : Project_Search_Path; To : out Project_Search_Path);\n-   --  Copy From into To\n-\n-   procedure Initialize_Empty (Self : in out Project_Search_Path);\n-   --  Initialize self with an empty list of directories. If Self had already\n-   --  been set, it is reset.\n-\n-   function Is_Initialized (Self : Project_Search_Path) return Boolean;\n-   --  Whether Self has been initialized\n-\n-   procedure Free (Self : in out Project_Search_Path);\n-   --  Free the memory used by Self\n-\n-   procedure Add_Directories\n-     (Self    : in out Project_Search_Path;\n-      Path    : String;\n-      Prepend : Boolean := False);\n-   --  Add one or more directories to the path. Directories added with this\n-   --  procedure are added in order after the current directory and before the\n-   --  path given by the environment variable GPR_PROJECT_PATH. A value of \"-\"\n-   --  will remove the default project directory from the project path.\n-   --\n-   --  Calls to this subprogram must be performed before the first call to\n-   --  Find_Project below, or PATH will be added at the end of the search path.\n-\n-   procedure Get_Path (Self : Project_Search_Path; Path : out String_Access);\n-   --  Return the current value of the project path, either the value set\n-   --  during elaboration of the package or, if procedure Set_Project_Path has\n-   --  been called, the value set by the last call to Set_Project_Path. The\n-   --  returned value must not be modified.\n-   --  Self must have been initialized first.\n-\n-   procedure Set_Path (Self : in out Project_Search_Path; Path : String);\n-   --  Override the value of the project path. This also removes the implicit\n-   --  default search directories.\n-\n-   generic\n-      with function Check_Filename (Name : String) return Boolean;\n-   function Find_Name_In_Path\n-     (Self : Project_Search_Path;\n-      Path : String) return String_Access;\n-   --  Find a name in the project search path of Self. Check_Filename is\n-   --  the predicate to valid the search.  If Path is an absolute filename,\n-   --  simply calls the predicate with Path. Otherwise, calls the predicate\n-   --  for each component of the path. Stops as soon as the predicate\n-   --  returns True and returns the name, or returns null in case of failure.\n-\n-   procedure Find_Project\n-     (Self               : in out Project_Search_Path;\n-      Project_File_Name  : String;\n-      Directory          : String;\n-      Path               : out Namet.Path_Name_Type);\n-   --  Search for a project with the given name either in Directory (which\n-   --  often will be the directory contain the project we are currently parsing\n-   --  and which we found a reference to another project), or in the project\n-   --  path Self. Self must have been initialized first.\n-   --\n-   --  Project_File_Name can optionally contain directories, and the extension\n-   --  (.gpr) for the file name is optional.\n-   --\n-   --  Returns No_Name if no such project was found\n-\n-   function Get_Runtime_Path\n-     (Self : Project_Search_Path;\n-      Name : String) return String_Access;\n-   --  Compute the full path for the project-based runtime name.\n-   --  Name is simply searched on the project path.\n-\n-private\n-   package Projects_Paths is new GNAT.Dynamic_HTables.Simple_HTable\n-     (Header_Num => Header_Num,\n-      Element    => Path_Name_Type,\n-      No_Element => No_Path,\n-      Key        => Name_Id,\n-      Hash       => Hash,\n-      Equal      => \"=\");\n-\n-   type Project_Search_Path is record\n-      Path : GNAT.OS_Lib.String_Access;\n-      --  As a special case, if the first character is '#:\" or this variable\n-      --  is unset, this means that the PATH has not been fully initialized\n-      --  yet (although subprograms above will properly take care of that).\n-\n-      Cache : Projects_Paths.Instance;\n-   end record;\n-\n-   No_Project_Search_Path : constant Project_Search_Path :=\n-                              (Path  => null,\n-                               Cache => Projects_Paths.Nil);\n-\n-end Prj.Env;"}, {"sha": "44ad905c21ab70015a2498ba8a6b31948f9dafc4", "filename": "gcc/ada/prj-err.adb", "status": "removed", "additions": 0, "deletions": 131, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-err.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-err.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-err.adb?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793", "patch": "@@ -1,131 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                              P R J . E R R                               --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 2002-2014, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-with Err_Vars;\n-with Output;   use Output;\n-with Stringt;  use Stringt;\n-\n-package body Prj.Err is\n-\n-   ---------------\n-   -- Post_Scan --\n-   ---------------\n-\n-   procedure Post_Scan is\n-      Debug_Tokens : constant Boolean := False;\n-\n-   begin\n-      --  Change operator symbol to literal strings, since that's the way\n-      --  we treat all strings in a project file.\n-\n-      if Token = Tok_Operator_Symbol\n-        or else Token = Tok_String_Literal\n-      then\n-         Token := Tok_String_Literal;\n-         String_To_Name_Buffer (String_Literal_Id);\n-         Token_Name := Name_Find;\n-      end if;\n-\n-      if Debug_Tokens then\n-         Write_Line (Token_Type'Image (Token));\n-\n-         if Token = Tok_Identifier\n-           or else Token = Tok_String_Literal\n-         then\n-            Write_Line (\"  \" & Get_Name_String (Token_Name));\n-         end if;\n-      end if;\n-   end Post_Scan;\n-\n-   ---------------\n-   -- Error_Msg --\n-   ---------------\n-\n-   procedure Error_Msg\n-     (Flags    : Processing_Flags;\n-      Msg      : String;\n-      Location : Source_Ptr := No_Location;\n-      Project  : Project_Id := null)\n-   is\n-      Real_Location : Source_Ptr := Location;\n-\n-   begin\n-      --  Don't post message if incompleted with's (avoid junk cascaded errors)\n-\n-      if Flags.Incomplete_Withs then\n-         return;\n-      end if;\n-\n-      --  Display the error message in the traces so that it appears in the\n-      --  correct location in the traces (otherwise error messages are only\n-      --  displayed at the end and it is difficult to see when they were\n-      --  triggered)\n-\n-      if Current_Verbosity = High then\n-         Debug_Output (\"ERROR: \" & Msg);\n-      end if;\n-\n-      --  If location of error is unknown, use the location of the project\n-\n-      if Real_Location = No_Location\n-        and then Project /= null\n-      then\n-         Real_Location := Project.Location;\n-      end if;\n-\n-      if Real_Location = No_Location then\n-\n-         --  If still null, we are parsing a project that was created in-memory\n-         --  so we shouldn't report errors for projects that the user has no\n-         --  access to in any case.\n-\n-         if Current_Verbosity = High then\n-            Debug_Output (\"Error in in-memory project, ignored\");\n-         end if;\n-\n-         return;\n-      end if;\n-\n-      --  Report the error through Errutil, so that duplicate errors are\n-      --  properly removed, messages are sorted, and correctly interpreted,...\n-\n-      Errutil.Error_Msg (Msg, Real_Location);\n-\n-      --  Let the application know there was an error\n-\n-      if Flags.Report_Error /= null then\n-         Flags.Report_Error\n-           (Project,\n-            Is_Warning =>\n-              Msg (Msg'First) = '?'\n-                or else (Msg (Msg'First) = '<'\n-                          and then Err_Vars.Error_Msg_Warn)\n-                or else (Msg (Msg'First) = '\\'\n-                          and then Msg (Msg'First + 1) = '<'\n-                          and then Err_Vars.Error_Msg_Warn));\n-      end if;\n-   end Error_Msg;\n-\n-end Prj.Err;"}, {"sha": "3f6b684130cd0badc525c7305307ffe9cb713d77", "filename": "gcc/ada/prj-err.ads", "status": "removed", "additions": 0, "deletions": 97, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-err.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-err.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-err.ads?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793", "patch": "@@ -1,97 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                              P R J . E R R                               --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---          Copyright (C) 2002-2010, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This package contains the routines to output error messages and the scanner\n---  for the project files. It replaces Errout and Scn. It is not dependent on\n---  the GNAT tree packages (Atree, Sinfo, ...). It uses exactly the same global\n---  variables as Errout, located in package Err_Vars. Like Errout, it also uses\n---  the common variables and routines in package Erroutc.\n---\n---  Parameters are set through Err_Vars.Error_Msg_File_* or\n---  Err_Vars.Error_Msg_Name_*, and replaced automatically in the messages\n---  (\"{{\" for files, \"%%\" for names).\n---\n---  However, in this package you can configure the error messages to be sent\n---  to your own callback by setting Report_Error in the flags. This ensures\n---  that applications can control where error messages are displayed.\n-\n-with Scng;\n-with Errutil;\n-\n-package Prj.Err is\n-\n-   ---------------------------------------------------------\n-   -- Error Message Text and Message Insertion Characters --\n-   ---------------------------------------------------------\n-\n-   --  See errutil.ads\n-\n-   -----------------------------------------------------\n-   -- Format of Messages and Manual Quotation Control --\n-   -----------------------------------------------------\n-\n-   --  See errutil.ads\n-\n-   ------------------------------\n-   -- Error Output Subprograms --\n-   ------------------------------\n-\n-   procedure Initialize renames Errutil.Initialize;\n-   --  Initializes for output of error messages. Must be called for each\n-   --  file before using any of the other routines in the package.\n-\n-   procedure Finalize (Source_Type : String := \"project\")\n-     renames Errutil.Finalize;\n-   --  Finalize processing of error messages for one file and output message\n-   --  indicating the number of detected errors.\n-\n-   procedure Error_Msg\n-     (Flags    : Processing_Flags;\n-      Msg      : String;\n-      Location : Source_Ptr := No_Location;\n-      Project  : Project_Id := null);\n-   --  Output an error message, either through Flags.Error_Report or through\n-   --  Errutil. The location defaults to the project's location (\"project\"\n-   --  in the source code). If Msg starts with \"?\", this is a warning, and\n-   --  Warning: is added at the beginning. If Msg starts with \"<\", see comment\n-   --  for Err_Vars.Error_Msg_Warn.\n-\n-   -------------\n-   -- Scanner --\n-   -------------\n-\n-   procedure Post_Scan;\n-   --  Convert an Ada operator symbol into a standard string\n-\n-   package Scanner is new Scng\n-     (Post_Scan    => Post_Scan,\n-      Error_Msg    => Errutil.Error_Msg,\n-      Error_Msg_S  => Errutil.Error_Msg_S,\n-      Error_Msg_SC => Errutil.Error_Msg_SC,\n-      Error_Msg_SP => Errutil.Error_Msg_SP,\n-      Style        => Errutil.Style);\n-   --  Instantiation of the generic scanner\n-\n-end Prj.Err;"}, {"sha": "127438d8a24875d88346510a62bcef28d8dd5723", "filename": "gcc/ada/prj-ext.adb", "status": "removed", "additions": 0, "deletions": 290, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-ext.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-ext.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-ext.adb?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793", "patch": "@@ -1,290 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                              P R J . E X T                               --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 2000-2016, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-with Osint;    use Osint;\n-\n-with Ada.Unchecked_Deallocation;\n-\n-package body Prj.Ext is\n-\n-   ----------------\n-   -- Initialize --\n-   ----------------\n-\n-   procedure Initialize\n-     (Self      : out External_References;\n-      Copy_From : External_References := No_External_Refs)\n-   is\n-      N  : Name_To_Name_Ptr;\n-      N2 : Name_To_Name_Ptr;\n-   begin\n-      if Self.Refs = null then\n-         Self.Refs := new Name_To_Name_HTable.Instance;\n-\n-         if Copy_From.Refs /= null then\n-            N := Name_To_Name_HTable.Get_First (Copy_From.Refs.all);\n-            while N /= null loop\n-               N2 := new Name_To_Name'\n-                           (Key    => N.Key,\n-                            Value  => N.Value,\n-                            Source => N.Source,\n-                            Next   => null);\n-               Name_To_Name_HTable.Set (Self.Refs.all, N2);\n-               N := Name_To_Name_HTable.Get_Next (Copy_From.Refs.all);\n-            end loop;\n-         end if;\n-      end if;\n-   end Initialize;\n-\n-   ---------\n-   -- Add --\n-   ---------\n-\n-   procedure Add\n-     (Self          : External_References;\n-      External_Name : String;\n-      Value         : String;\n-      Source        : External_Source := External_Source'First;\n-      Silent        : Boolean := False)\n-   is\n-      Key : Name_Id;\n-      N   : Name_To_Name_Ptr;\n-\n-   begin\n-      --  For external attribute, set the environment variable\n-\n-      if Source = From_External_Attribute and then External_Name /= \"\" then\n-         declare\n-            Env_Var : String_Access := Getenv (External_Name);\n-\n-         begin\n-            if Env_Var = null or else Env_Var.all = \"\" then\n-               Setenv (Name => External_Name, Value => Value);\n-\n-               if not Silent then\n-                  Debug_Output\n-                    (\"Environment variable \"\"\" & External_Name\n-                     & \"\"\" = \"\"\" & Value & '\"');\n-               end if;\n-\n-            elsif not Silent then\n-               Debug_Output\n-                 (\"Not overriding existing environment variable \"\"\"\n-                  & External_Name & \"\"\", value is \"\"\" & Env_Var.all & '\"');\n-            end if;\n-\n-            Free (Env_Var);\n-         end;\n-      end if;\n-\n-      Name_Len := External_Name'Length;\n-      Name_Buffer (1 .. Name_Len) := External_Name;\n-      Canonical_Case_Env_Var_Name (Name_Buffer (1 .. Name_Len));\n-      Key := Name_Find;\n-\n-      --  Check whether the value is already defined, to properly respect the\n-      --  overriding order.\n-\n-      if Source /= External_Source'First then\n-         N := Name_To_Name_HTable.Get (Self.Refs.all, Key);\n-\n-         if N /= null then\n-            if External_Source'Pos (N.Source) <\n-               External_Source'Pos (Source)\n-            then\n-               if not Silent then\n-                  Debug_Output\n-                    (\"Not overriding existing external reference '\"\n-                     & External_Name & \"', value was defined in \"\n-                     & N.Source'Img);\n-               end if;\n-\n-               return;\n-            end if;\n-         end if;\n-      end if;\n-\n-      Name_Len := Value'Length;\n-      Name_Buffer (1 .. Name_Len) := Value;\n-      N := new Name_To_Name'\n-                 (Key    => Key,\n-                  Source => Source,\n-                  Value  => Name_Find,\n-                  Next   => null);\n-\n-      if not Silent then\n-         Debug_Output (\"Add external (\" & External_Name & \") is\", N.Value);\n-      end if;\n-\n-      Name_To_Name_HTable.Set (Self.Refs.all, N);\n-   end Add;\n-\n-   -----------\n-   -- Check --\n-   -----------\n-\n-   function Check\n-     (Self        : External_References;\n-      Declaration : String) return Boolean\n-   is\n-   begin\n-      for Equal_Pos in Declaration'Range loop\n-         if Declaration (Equal_Pos) = '=' then\n-            exit when Equal_Pos = Declaration'First;\n-            Add\n-              (Self          => Self,\n-               External_Name =>\n-                 Declaration (Declaration'First .. Equal_Pos - 1),\n-               Value         =>\n-                 Declaration (Equal_Pos + 1 .. Declaration'Last),\n-               Source        => From_Command_Line);\n-            return True;\n-         end if;\n-      end loop;\n-\n-      return False;\n-   end Check;\n-\n-   -----------\n-   -- Reset --\n-   -----------\n-\n-   procedure Reset (Self : External_References) is\n-   begin\n-      if Self.Refs /= null then\n-         Debug_Output (\"Reset external references\");\n-         Name_To_Name_HTable.Reset (Self.Refs.all);\n-      end if;\n-   end Reset;\n-\n-   --------------\n-   -- Value_Of --\n-   --------------\n-\n-   function Value_Of\n-     (Self          : External_References;\n-      External_Name : Name_Id;\n-      With_Default  : Name_Id := No_Name)\n-      return          Name_Id\n-   is\n-      Value : Name_To_Name_Ptr;\n-      Val   : Name_Id;\n-      Name  : String := Get_Name_String (External_Name);\n-\n-   begin\n-      Canonical_Case_Env_Var_Name (Name);\n-\n-      if Self.Refs /= null then\n-         Name_Len := Name'Length;\n-         Name_Buffer (1 .. Name_Len) := Name;\n-         Value := Name_To_Name_HTable.Get (Self.Refs.all, Name_Find);\n-\n-         if Value /= null then\n-            Debug_Output (\"Value_Of (\" & Name & \") is in cache\", Value.Value);\n-            return Value.Value;\n-         end if;\n-      end if;\n-\n-      --  Find if it is an environment, if it is, put value in the hash table\n-\n-      declare\n-         Env_Value : String_Access := Getenv (Name);\n-\n-      begin\n-         if Env_Value /= null and then Env_Value'Length > 0 then\n-            Name_Len := Env_Value'Length;\n-            Name_Buffer (1 .. Name_Len) := Env_Value.all;\n-            Val := Name_Find;\n-\n-            if Current_Verbosity = High then\n-               Debug_Output (\"Value_Of (\" & Name & \") is\", Val);\n-            end if;\n-\n-            if Self.Refs /= null then\n-               Value := new Name_To_Name'\n-                 (Key    => External_Name,\n-                  Value  => Val,\n-                  Source => From_Environment,\n-                  Next   => null);\n-               Name_To_Name_HTable.Set (Self.Refs.all, Value);\n-            end if;\n-\n-            Free (Env_Value);\n-            return Val;\n-\n-         else\n-            if Current_Verbosity = High then\n-               Debug_Output\n-                 (\"Value_Of (\" & Name & \") is default\", With_Default);\n-            end if;\n-\n-            Free (Env_Value);\n-            return With_Default;\n-         end if;\n-      end;\n-   end Value_Of;\n-\n-   ----------\n-   -- Free --\n-   ----------\n-\n-   procedure Free (Self : in out External_References) is\n-      procedure Unchecked_Free is new Ada.Unchecked_Deallocation\n-        (Name_To_Name_HTable.Instance, Instance_Access);\n-   begin\n-      if Self.Refs /= null then\n-         Reset (Self);\n-         Unchecked_Free (Self.Refs);\n-      end if;\n-   end Free;\n-\n-   --------------\n-   -- Set_Next --\n-   --------------\n-\n-   procedure Set_Next (E : Name_To_Name_Ptr; Next : Name_To_Name_Ptr) is\n-   begin\n-      E.Next := Next;\n-   end Set_Next;\n-\n-   ----------\n-   -- Next --\n-   ----------\n-\n-   function Next (E : Name_To_Name_Ptr) return Name_To_Name_Ptr is\n-   begin\n-      return E.Next;\n-   end Next;\n-\n-   -------------\n-   -- Get_Key --\n-   -------------\n-\n-   function Get_Key (E : Name_To_Name_Ptr) return Name_Id is\n-   begin\n-      return E.Key;\n-   end Get_Key;\n-\n-end Prj.Ext;"}, {"sha": "ca01959789ecbc9465e28908d08b227070be3a7c", "filename": "gcc/ada/prj-ext.ads", "status": "removed", "additions": 0, "deletions": 142, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-ext.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-ext.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-ext.ads?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793", "patch": "@@ -1,142 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                              P R J . E X T                               --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---          Copyright (C) 2000-2013, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  Subprograms to set, get and cache external references, to be used as\n---  External functions in project files.\n-\n-with GNAT.Dynamic_HTables;\n-\n-package Prj.Ext is\n-\n-   -------------------------\n-   -- External References --\n-   -------------------------\n-\n-   --  External references influence the way a project tree is processed (in\n-   --  particular they provide the values for the typed string variables that\n-   --  are then used in case constructions).\n-\n-   --  External references are project-tree specific, so that when multiple\n-   --  trees are loaded in parallel we can have different scenarios (or even\n-   --  load the same tree twice and see different views of it).\n-\n-   type External_References is private;\n-   No_External_Refs : constant External_References;\n-\n-   procedure Initialize\n-     (Self      : out External_References;\n-      Copy_From : External_References := No_External_Refs);\n-   --  Initialize Self, and copy all values from Copy_From if needed.\n-   --  This has no effect if Self was already initialized.\n-\n-   procedure Free (Self : in out External_References);\n-   --  Free memory used by Self\n-\n-   type External_Source is\n-     (From_Command_Line,\n-      From_Environment,\n-      From_External_Attribute);\n-   --  Indicates where was the value of an external reference defined. They are\n-   --  prioritized in that order, so that a user can always use the command\n-   --  line to override a value coming from his environment, or an environment\n-   --  variable to override a value defined in an aggregate project through the\n-   --  \"for External()...\" attribute.\n-\n-   procedure Add\n-     (Self          : External_References;\n-      External_Name : String;\n-      Value         : String;\n-      Source        : External_Source := External_Source'First;\n-      Silent        : Boolean := False);\n-   --  Add an external reference (or modify an existing one). No overriding is\n-   --  done if the Source's priority is less than the one used to previously\n-   --  set the value of the variable. The default for Source is such that\n-   --  overriding always occurs. When Silent is True, nothing is output even\n-   --  with non default verbosity.\n-\n-   function Value_Of\n-     (Self          : External_References;\n-      External_Name : Name_Id;\n-      With_Default  : Name_Id := No_Name)\n-      return          Name_Id;\n-   --  Get the value of an external reference, and cache it for future uses\n-\n-   function Check\n-     (Self        : External_References;\n-      Declaration : String) return Boolean;\n-   --  Check that an external declaration <external>=<value> is correct.\n-   --  If it is correct, the external reference is Added.\n-\n-   procedure Reset (Self : External_References);\n-   --  Clear the internal data structure that stores the external references\n-   --  and free any allocated memory.\n-\n-private\n-   --  Use a Static_HTable, rather than a Simple_HTable\n-\n-   --  The issue is that we need to be able to copy the contents of the table\n-   --  (in Initialize), but this isn't doable for Simple_HTable for which\n-   --  iterators do not return the key.\n-\n-   type Name_To_Name;\n-   type Name_To_Name_Ptr is access all Name_To_Name;\n-   type Name_To_Name is record\n-      Key    : Name_Id;\n-      Value  : Name_Id;\n-      Source : External_Source;\n-      Next   : Name_To_Name_Ptr;\n-   end record;\n-\n-   procedure Set_Next (E : Name_To_Name_Ptr; Next : Name_To_Name_Ptr);\n-   function  Next     (E : Name_To_Name_Ptr) return Name_To_Name_Ptr;\n-   function  Get_Key  (E : Name_To_Name_Ptr) return Name_Id;\n-\n-   package Name_To_Name_HTable is new GNAT.Dynamic_HTables.Static_HTable\n-     (Header_Num => Header_Num,\n-      Element    => Name_To_Name,\n-      Elmt_Ptr   => Name_To_Name_Ptr,\n-      Null_Ptr   => null,\n-      Set_Next   => Set_Next,\n-      Next       => Next,\n-      Key        => Name_Id,\n-      Get_Key    => Get_Key,\n-      Hash       => Hash,\n-      Equal      => \"=\");\n-   --  General type for htables associating name_id to name_id. This is in\n-   --  particular used to store the values of external references.\n-\n-   type Instance_Access is access all Name_To_Name_HTable.Instance;\n-\n-   type External_References is record\n-      Refs : Instance_Access;\n-      --  External references are stored in this hash table (and manipulated\n-      --  through subprogrames in prj-ext.ads). External references are\n-      --  project-tree specific so that one can load the same tree twice but\n-      --  have two views of it, for instance.\n-   end record;\n-\n-   No_External_Refs : constant External_References := (Refs => null);\n-\n-end Prj.Ext;"}, {"sha": "06cb64b32e89fcdc70b2752b05a0e6104a253398", "filename": "gcc/ada/prj-makr.adb", "status": "removed", "additions": 0, "deletions": 1571, "changes": 1571, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-makr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-makr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-makr.adb?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793", "patch": "@@ -1,1571 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                             P R J . M A K R                              --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 2001-2014, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-with Csets;\n-with Makeutl;  use Makeutl;\n-with Opt;\n-with Output;\n-with Osint;    use Osint;\n-with Prj;      use Prj;\n-with Prj.Com;\n-with Prj.Env;\n-with Prj.Part;\n-with Prj.PP;\n-with Prj.Tree; use Prj.Tree;\n-with Prj.Util; use Prj.Util;\n-with Sdefault;\n-with Snames;   use Snames;\n-with Stringt;\n-with Table;    use Table;\n-with Tempdir;\n-\n-with Ada.Characters.Handling;   use Ada.Characters.Handling;\n-with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n-\n-with System.Case_Util; use System.Case_Util;\n-with System.CRTL;\n-with System.HTable;\n-\n-package body Prj.Makr is\n-\n-   --  Packages of project files where unknown attributes are errors\n-\n-   --  All the following need comments ??? All global variables and\n-   --  subprograms must be fully commented.\n-\n-   Very_Verbose : Boolean := False;\n-   --  Set in call to Initialize to indicate very verbose output\n-\n-   Project_File : Boolean := False;\n-   --  True when gnatname is creating/modifying a project file. False when\n-   --  gnatname is creating a configuration pragmas file.\n-\n-   Tree : constant Project_Node_Tree_Ref := new Project_Node_Tree_Data;\n-   --  The project tree where the project file is parsed\n-\n-   Args : Argument_List_Access;\n-   --  The list of arguments for calls to the compiler to get the unit names\n-   --  and kinds (spec or body) in the Ada sources.\n-\n-   Path_Name : String_Access;\n-\n-   Path_Last : Natural;\n-\n-   Directory_Last    : Natural := 0;\n-\n-   Output_Name      : String_Access;\n-   Output_Name_Last : Natural;\n-   Output_Name_Id   : Name_Id;\n-\n-   Project_Naming_File_Name : String_Access;\n-   --  String (1 .. Output_Name'Length +  Naming_File_Suffix'Length);\n-\n-   Project_Naming_Last : Natural;\n-   Project_Naming_Id   : Name_Id := No_Name;\n-\n-   Source_List_Path : String_Access;\n-   --  (1 .. Output_Name'Length + Source_List_File_Suffix'Length);\n-   Source_List_Last : Natural;\n-\n-   Source_List_FD : File_Descriptor;\n-\n-   Project_Node        : Project_Node_Id := Empty_Node;\n-   Project_Declaration : Project_Node_Id := Empty_Node;\n-   Source_Dirs_List    : Project_Node_Id := Empty_Node;\n-\n-   Project_Naming_Node     : Project_Node_Id := Empty_Node;\n-   Project_Naming_Decl     : Project_Node_Id := Empty_Node;\n-   Naming_Package          : Project_Node_Id := Empty_Node;\n-   Naming_Package_Comments : Project_Node_Id := Empty_Node;\n-\n-   Source_Files_Comments     : Project_Node_Id := Empty_Node;\n-   Source_Dirs_Comments      : Project_Node_Id := Empty_Node;\n-   Source_List_File_Comments : Project_Node_Id := Empty_Node;\n-\n-   Naming_String : aliased String := \"naming\";\n-\n-   Gnatname_Packages : aliased String_List := (1 => Naming_String'Access);\n-\n-   Packages_To_Check_By_Gnatname : constant String_List_Access :=\n-                                     Gnatname_Packages'Access;\n-\n-   function Dup (Fd : File_Descriptor) return File_Descriptor;\n-\n-   procedure Dup2 (Old_Fd, New_Fd : File_Descriptor);\n-\n-   Gcc      : constant String := \"gcc\";\n-   Gcc_Path : String_Access := null;\n-\n-   Non_Empty_Node : constant Project_Node_Id := 1;\n-   --  Used for the With_Clause of the naming project\n-\n-   --  Turn off warnings for now around this redefinition of True and False,\n-   --  but it really seems a bit horrible to do this redefinition ???\n-\n-   pragma Warnings (Off);\n-   type Matched_Type is (True, False, Excluded);\n-   pragma Warnings (On);\n-\n-   Naming_File_Suffix      : constant String := \"_naming\";\n-   Source_List_File_Suffix : constant String := \"_source_list.txt\";\n-\n-   Output_FD : File_Descriptor;\n-   --  To save the project file and its naming project file\n-\n-   procedure Write_Eol;\n-   --  Output an empty line\n-\n-   procedure Write_A_Char (C : Character);\n-   --  Write one character to Output_FD\n-\n-   procedure Write_A_String (S : String);\n-   --  Write a String to Output_FD\n-\n-   package Processed_Directories is new Table.Table\n-     (Table_Component_Type => String_Access,\n-      Table_Index_Type     => Natural,\n-      Table_Low_Bound      => 0,\n-      Table_Initial        => 10,\n-      Table_Increment      => 100,\n-      Table_Name           => \"Prj.Makr.Processed_Directories\");\n-   --  The list of already processed directories for each section, to avoid\n-   --  processing several times the same directory in the same section.\n-\n-   package Source_Directories is new Table.Table\n-     (Table_Component_Type => String_Access,\n-      Table_Index_Type     => Natural,\n-      Table_Low_Bound      => 0,\n-      Table_Initial        => 10,\n-      Table_Increment      => 100,\n-      Table_Name           => \"Prj.Makr.Source_Directories\");\n-   --  The complete list of directories to be put in attribute Source_Dirs in\n-   --  the project file.\n-\n-   type Source is record\n-      File_Name : Name_Id;\n-      Unit_Name : Name_Id;\n-      Index     : Int := 0;\n-      Spec      : Boolean;\n-   end record;\n-\n-   package Sources is new Table.Table\n-     (Table_Component_Type => Source,\n-      Table_Index_Type     => Natural,\n-      Table_Low_Bound      => 0,\n-      Table_Initial        => 10,\n-      Table_Increment      => 100,\n-      Table_Name           => \"Prj.Makr.Sources\");\n-   --  The list of Ada sources found, with their unit name and kind, to be put\n-   --  in the source attribute and package Naming of the project file, or in\n-   --  the pragmas Source_File_Name in the configuration pragmas file.\n-\n-   package Source_Files is new System.HTable.Simple_HTable\n-     (Header_Num => Prj.Header_Num,\n-      Element    => Boolean,\n-      No_Element => False,\n-      Key        => Name_Id,\n-      Hash       => Prj.Hash,\n-      Equal      => \"=\");\n-   --  Hash table to keep track of source file names, to avoid putting several\n-   --  times the same file name in case of multi-unit files.\n-\n-   ---------\n-   -- Dup --\n-   ---------\n-\n-   function Dup  (Fd : File_Descriptor) return File_Descriptor is\n-   begin\n-      return File_Descriptor (System.CRTL.dup (Integer (Fd)));\n-   end Dup;\n-\n-   ----------\n-   -- Dup2 --\n-   ----------\n-\n-   procedure Dup2 (Old_Fd, New_Fd : File_Descriptor) is\n-      Fd : Integer;\n-      pragma Warnings (Off, Fd);\n-   begin\n-      Fd := System.CRTL.dup2 (Integer (Old_Fd), Integer (New_Fd));\n-   end Dup2;\n-\n-   --------------\n-   -- Finalize --\n-   --------------\n-\n-   procedure Finalize is\n-      Discard : Boolean;\n-      pragma Warnings (Off, Discard);\n-\n-      Current_Source_Dir : Project_Node_Id := Empty_Node;\n-\n-   begin\n-      if Project_File then\n-         --  If there were no already existing project file, or if the parsing\n-         --  was unsuccessful, create an empty project node with the correct\n-         --  name and its project declaration node.\n-\n-         if No (Project_Node) then\n-            Project_Node :=\n-              Default_Project_Node (Of_Kind => N_Project, In_Tree => Tree);\n-            Set_Name_Of (Project_Node, Tree, To => Output_Name_Id);\n-            Set_Project_Declaration_Of\n-              (Project_Node, Tree,\n-               To => Default_Project_Node\n-                 (Of_Kind => N_Project_Declaration, In_Tree => Tree));\n-\n-         end if;\n-\n-      end if;\n-\n-      --  Delete the file if it already exists\n-\n-      Delete_File\n-        (Path_Name (Directory_Last + 1 .. Path_Last),\n-         Success => Discard);\n-\n-      --  Create a new one\n-\n-      if Opt.Verbose_Mode then\n-         Output.Write_Str (\"Creating new file \"\"\");\n-         Output.Write_Str (Path_Name (Directory_Last + 1 .. Path_Last));\n-         Output.Write_Line (\"\"\"\");\n-      end if;\n-\n-      Output_FD := Create_New_File\n-        (Path_Name (Directory_Last + 1 .. Path_Last),\n-         Fmode => Text);\n-\n-      --  Fails if project file cannot be created\n-\n-      if Output_FD = Invalid_FD then\n-         Prj.Com.Fail\n-           (\"cannot create new \"\"\" & Path_Name (1 .. Path_Last) & \"\"\"\");\n-      end if;\n-\n-      if Project_File then\n-\n-         --  Delete the source list file, if it already exists\n-\n-         declare\n-            Discard : Boolean;\n-            pragma Warnings (Off, Discard);\n-         begin\n-            Delete_File\n-              (Source_List_Path (1 .. Source_List_Last),\n-               Success => Discard);\n-         end;\n-\n-         --  And create a new source list file, fail if file cannot be created\n-\n-         Source_List_FD := Create_New_File\n-           (Name  => Source_List_Path (1 .. Source_List_Last),\n-            Fmode => Text);\n-\n-         if Source_List_FD = Invalid_FD then\n-            Prj.Com.Fail\n-              (\"cannot create file \"\"\"\n-               & Source_List_Path (1 .. Source_List_Last)\n-               & \"\"\"\");\n-         end if;\n-\n-         if Opt.Verbose_Mode then\n-            Output.Write_Str (\"Naming project file name is \"\"\");\n-            Output.Write_Str\n-              (Project_Naming_File_Name (1 .. Project_Naming_Last));\n-            Output.Write_Line (\"\"\"\");\n-         end if;\n-\n-         --  Create the naming project node\n-\n-         Project_Naming_Node :=\n-           Default_Project_Node (Of_Kind => N_Project, In_Tree => Tree);\n-         Set_Name_Of (Project_Naming_Node, Tree, To => Project_Naming_Id);\n-         Project_Naming_Decl :=\n-           Default_Project_Node\n-             (Of_Kind => N_Project_Declaration, In_Tree => Tree);\n-         Set_Project_Declaration_Of\n-           (Project_Naming_Node, Tree, Project_Naming_Decl);\n-         Naming_Package :=\n-           Default_Project_Node\n-             (Of_Kind => N_Package_Declaration, In_Tree => Tree);\n-         Set_Name_Of (Naming_Package, Tree, To => Name_Naming);\n-\n-         --  Add an attribute declaration for Source_Files as an empty list (to\n-         --  indicate there are no sources in the naming project) and a package\n-         --  Naming (that will be filled later).\n-\n-         declare\n-            Decl_Item : constant Project_Node_Id :=\n-                          Default_Project_Node\n-                            (Of_Kind => N_Declarative_Item, In_Tree => Tree);\n-\n-            Attribute : constant Project_Node_Id :=\n-                          Default_Project_Node\n-                            (Of_Kind       => N_Attribute_Declaration,\n-                             In_Tree       => Tree,\n-                             And_Expr_Kind => List);\n-\n-            Expression : constant Project_Node_Id :=\n-                           Default_Project_Node\n-                             (Of_Kind       => N_Expression,\n-                              In_Tree       => Tree,\n-                              And_Expr_Kind => List);\n-\n-            Term      : constant Project_Node_Id :=\n-                          Default_Project_Node\n-                            (Of_Kind       => N_Term,\n-                             In_Tree       => Tree,\n-                             And_Expr_Kind => List);\n-\n-            Empty_List : constant Project_Node_Id :=\n-                           Default_Project_Node\n-                             (Of_Kind => N_Literal_String_List,\n-                              In_Tree => Tree);\n-\n-         begin\n-            Set_First_Declarative_Item_Of\n-              (Project_Naming_Decl, Tree, To => Decl_Item);\n-            Set_Next_Declarative_Item (Decl_Item, Tree, Naming_Package);\n-            Set_Current_Item_Node (Decl_Item, Tree, To => Attribute);\n-            Set_Name_Of (Attribute, Tree, To => Name_Source_Files);\n-            Set_Expression_Of (Attribute, Tree, To => Expression);\n-            Set_First_Term (Expression, Tree, To => Term);\n-            Set_Current_Term (Term, Tree, To => Empty_List);\n-         end;\n-\n-         --  Add a with clause on the naming project in the main project, if\n-         --  there is not already one.\n-\n-         declare\n-            With_Clause : Project_Node_Id :=\n-                                  First_With_Clause_Of (Project_Node, Tree);\n-\n-         begin\n-            while Present (With_Clause) loop\n-               exit when\n-                 Prj.Tree.Name_Of (With_Clause, Tree) = Project_Naming_Id;\n-               With_Clause := Next_With_Clause_Of (With_Clause, Tree);\n-            end loop;\n-\n-            if No (With_Clause) then\n-               With_Clause := Default_Project_Node\n-                 (Of_Kind => N_With_Clause, In_Tree => Tree);\n-               Set_Next_With_Clause_Of\n-                 (With_Clause, Tree,\n-                  To => First_With_Clause_Of (Project_Node, Tree));\n-               Set_First_With_Clause_Of\n-                 (Project_Node, Tree, To => With_Clause);\n-               Set_Name_Of (With_Clause, Tree, To => Project_Naming_Id);\n-\n-               --  We set the project node to something different than\n-               --  Empty_Node, so that Prj.PP does not generate a limited\n-               --  with clause.\n-\n-               Set_Project_Node_Of (With_Clause, Tree, Non_Empty_Node);\n-\n-               Name_Len := Project_Naming_Last;\n-               Name_Buffer (1 .. Name_Len) :=\n-                 Project_Naming_File_Name (1 .. Project_Naming_Last);\n-               Set_String_Value_Of (With_Clause, Tree, To => Name_Find);\n-            end if;\n-         end;\n-\n-         Project_Declaration := Project_Declaration_Of (Project_Node, Tree);\n-\n-         --  Add a package Naming in the main project, that is a renaming of\n-         --  package Naming in the naming project.\n-\n-         declare\n-            Decl_Item  : constant Project_Node_Id :=\n-                           Default_Project_Node\n-                             (Of_Kind => N_Declarative_Item,\n-                              In_Tree => Tree);\n-\n-            Naming : constant Project_Node_Id :=\n-                           Default_Project_Node\n-                             (Of_Kind => N_Package_Declaration,\n-                              In_Tree => Tree);\n-\n-         begin\n-            Set_Next_Declarative_Item\n-              (Decl_Item, Tree,\n-               To => First_Declarative_Item_Of (Project_Declaration, Tree));\n-            Set_First_Declarative_Item_Of\n-              (Project_Declaration, Tree, To => Decl_Item);\n-            Set_Current_Item_Node (Decl_Item, Tree, To => Naming);\n-            Set_Name_Of (Naming, Tree, To => Name_Naming);\n-            Set_Project_Of_Renamed_Package_Of\n-              (Naming, Tree, To => Project_Naming_Node);\n-\n-            --  Attach the comments, if any, that were saved for package\n-            --  Naming.\n-\n-            Tree.Project_Nodes.Table (Naming).Comments :=\n-              Naming_Package_Comments;\n-         end;\n-\n-         --  Add an attribute declaration for Source_Dirs, initialized as an\n-         --  empty list.\n-\n-         declare\n-            Decl_Item  : constant Project_Node_Id :=\n-                           Default_Project_Node\n-                             (Of_Kind => N_Declarative_Item,\n-                              In_Tree => Tree);\n-\n-            Attribute : constant Project_Node_Id :=\n-                           Default_Project_Node\n-                             (Of_Kind       => N_Attribute_Declaration,\n-                              In_Tree       => Tree,\n-                              And_Expr_Kind => List);\n-\n-            Expression : constant Project_Node_Id :=\n-                           Default_Project_Node\n-                             (Of_Kind       => N_Expression,\n-                              In_Tree       => Tree,\n-                              And_Expr_Kind => List);\n-\n-            Term  : constant Project_Node_Id :=\n-                           Default_Project_Node\n-                             (Of_Kind       => N_Term, In_Tree => Tree,\n-                              And_Expr_Kind => List);\n-\n-         begin\n-            Set_Next_Declarative_Item\n-              (Decl_Item, Tree,\n-               To => First_Declarative_Item_Of (Project_Declaration, Tree));\n-            Set_First_Declarative_Item_Of\n-              (Project_Declaration, Tree, To => Decl_Item);\n-            Set_Current_Item_Node (Decl_Item, Tree, To => Attribute);\n-            Set_Name_Of (Attribute, Tree, To => Name_Source_Dirs);\n-            Set_Expression_Of (Attribute, Tree, To => Expression);\n-            Set_First_Term (Expression, Tree, To => Term);\n-            Source_Dirs_List :=\n-              Default_Project_Node\n-                (Of_Kind       => N_Literal_String_List,\n-                 In_Tree       => Tree,\n-                 And_Expr_Kind => List);\n-            Set_Current_Term (Term, Tree, To => Source_Dirs_List);\n-\n-            --  Attach the comments, if any, that were saved for attribute\n-            --  Source_Dirs.\n-\n-            Tree.Project_Nodes.Table (Attribute).Comments :=\n-              Source_Dirs_Comments;\n-         end;\n-\n-         --  Put the source directories in attribute Source_Dirs\n-\n-         for Source_Dir_Index in 1 .. Source_Directories.Last loop\n-            declare\n-               Expression : constant Project_Node_Id :=\n-                              Default_Project_Node\n-                                (Of_Kind       => N_Expression,\n-                                 In_Tree       => Tree,\n-                                 And_Expr_Kind => Single);\n-\n-               Term       : constant Project_Node_Id :=\n-                              Default_Project_Node\n-                                (Of_Kind       => N_Term,\n-                                 In_Tree       => Tree,\n-                                 And_Expr_Kind => Single);\n-\n-               Value      : constant Project_Node_Id :=\n-                              Default_Project_Node\n-                                (Of_Kind       => N_Literal_String,\n-                                 In_Tree       => Tree,\n-                                 And_Expr_Kind => Single);\n-\n-            begin\n-               if No (Current_Source_Dir) then\n-                  Set_First_Expression_In_List\n-                    (Source_Dirs_List, Tree, To => Expression);\n-               else\n-                  Set_Next_Expression_In_List\n-                    (Current_Source_Dir, Tree, To => Expression);\n-               end if;\n-\n-               Current_Source_Dir := Expression;\n-               Set_First_Term (Expression, Tree, To => Term);\n-               Set_Current_Term (Term, Tree, To => Value);\n-               Name_Len := 0;\n-               Add_Str_To_Name_Buffer\n-                 (Source_Directories.Table (Source_Dir_Index).all);\n-               Set_String_Value_Of (Value, Tree, To => Name_Find);\n-            end;\n-         end loop;\n-\n-         --  Add an attribute declaration for Source_Files or Source_List_File\n-         --  with the source list file name that will be created.\n-\n-         declare\n-            Decl_Item  : constant Project_Node_Id :=\n-                           Default_Project_Node\n-                             (Of_Kind => N_Declarative_Item,\n-                              In_Tree => Tree);\n-\n-            Attribute  : constant Project_Node_Id :=\n-                            Default_Project_Node\n-                              (Of_Kind       => N_Attribute_Declaration,\n-                               In_Tree       => Tree,\n-                               And_Expr_Kind => Single);\n-\n-            Expression : constant Project_Node_Id :=\n-                           Default_Project_Node\n-                             (Of_Kind       => N_Expression,\n-                              In_Tree       => Tree,\n-                              And_Expr_Kind => Single);\n-\n-            Term       : constant Project_Node_Id :=\n-                           Default_Project_Node\n-                             (Of_Kind       => N_Term,\n-                              In_Tree       => Tree,\n-                              And_Expr_Kind => Single);\n-\n-            Value      : constant Project_Node_Id :=\n-                           Default_Project_Node\n-                             (Of_Kind       => N_Literal_String,\n-                              In_Tree       => Tree,\n-                              And_Expr_Kind => Single);\n-\n-         begin\n-            Set_Next_Declarative_Item\n-              (Decl_Item, Tree,\n-               To => First_Declarative_Item_Of (Project_Declaration, Tree));\n-            Set_First_Declarative_Item_Of\n-              (Project_Declaration, Tree, To => Decl_Item);\n-            Set_Current_Item_Node (Decl_Item, Tree, To => Attribute);\n-\n-            Set_Name_Of (Attribute, Tree, To => Name_Source_List_File);\n-            Set_Expression_Of (Attribute, Tree, To => Expression);\n-            Set_First_Term (Expression, Tree, To => Term);\n-            Set_Current_Term (Term, Tree, To => Value);\n-            Name_Len := Source_List_Last;\n-            Name_Buffer (1 .. Name_Len) :=\n-              Source_List_Path (1 .. Source_List_Last);\n-            Set_String_Value_Of (Value, Tree, To => Name_Find);\n-\n-            --  If there was no comments for attribute Source_List_File, put\n-            --  those for Source_Files, if they exist.\n-\n-            if Present (Source_List_File_Comments) then\n-               Tree.Project_Nodes.Table (Attribute).Comments :=\n-                 Source_List_File_Comments;\n-            else\n-               Tree.Project_Nodes.Table (Attribute).Comments :=\n-                 Source_Files_Comments;\n-            end if;\n-         end;\n-\n-         --  Put the sources in the source list files and in the naming\n-         --  project.\n-\n-         for Source_Index in 1 .. Sources.Last loop\n-\n-            --  Add the corresponding attribute in the\n-            --  Naming package of the naming project.\n-\n-            declare\n-               Current_Source : constant Source :=\n-                                  Sources.Table (Source_Index);\n-\n-               Decl_Item : constant Project_Node_Id :=\n-                             Default_Project_Node\n-                               (Of_Kind =>\n-                                                N_Declarative_Item,\n-                                In_Tree => Tree);\n-\n-               Attribute : constant Project_Node_Id :=\n-                             Default_Project_Node\n-                               (Of_Kind =>\n-                                                N_Attribute_Declaration,\n-                                In_Tree => Tree);\n-\n-               Expression : constant Project_Node_Id :=\n-                              Default_Project_Node\n-                                (Of_Kind       => N_Expression,\n-                                 And_Expr_Kind => Single,\n-                                 In_Tree       => Tree);\n-\n-               Term      : constant Project_Node_Id :=\n-                             Default_Project_Node\n-                               (Of_Kind       => N_Term,\n-                                And_Expr_Kind => Single,\n-                                In_Tree       => Tree);\n-\n-               Value     : constant Project_Node_Id :=\n-                             Default_Project_Node\n-                               (Of_Kind       => N_Literal_String,\n-                                And_Expr_Kind => Single,\n-                                In_Tree       => Tree);\n-\n-            begin\n-               --  Add source file name to the source list file if it is not\n-               --  already there.\n-\n-               if not Source_Files.Get (Current_Source.File_Name) then\n-                  Source_Files.Set (Current_Source.File_Name, True);\n-                  Get_Name_String (Current_Source.File_Name);\n-                  Add_Char_To_Name_Buffer (ASCII.LF);\n-\n-                  if Write (Source_List_FD,\n-                            Name_Buffer (1)'Address,\n-                            Name_Len) /= Name_Len\n-                  then\n-                     Prj.Com.Fail (\"disk full\");\n-                  end if;\n-               end if;\n-\n-               --  For an Ada source, add entry in package Naming\n-\n-               if Current_Source.Unit_Name /= No_Name then\n-                  Set_Next_Declarative_Item\n-                    (Decl_Item,\n-                     To      => First_Declarative_Item_Of\n-                       (Naming_Package, Tree),\n-                     In_Tree => Tree);\n-                  Set_First_Declarative_Item_Of\n-                    (Naming_Package,\n-                     To      => Decl_Item,\n-                     In_Tree => Tree);\n-                  Set_Current_Item_Node\n-                    (Decl_Item,\n-                     To      => Attribute,\n-                     In_Tree => Tree);\n-\n-                  --  Is it a spec or a body?\n-\n-                  if Current_Source.Spec then\n-                     Set_Name_Of\n-                       (Attribute, Tree,\n-                        To => Name_Spec);\n-                  else\n-                     Set_Name_Of\n-                       (Attribute, Tree,\n-                        To => Name_Body);\n-                  end if;\n-\n-                  --  Get the name of the unit\n-\n-                  Get_Name_String (Current_Source.Unit_Name);\n-                  To_Lower (Name_Buffer (1 .. Name_Len));\n-                  Set_Associative_Array_Index_Of\n-                    (Attribute, Tree, To => Name_Find);\n-\n-                  Set_Expression_Of\n-                    (Attribute, Tree, To => Expression);\n-                  Set_First_Term\n-                    (Expression, Tree, To => Term);\n-                  Set_Current_Term\n-                    (Term, Tree, To => Value);\n-\n-                  --  And set the name of the file\n-\n-                  Set_String_Value_Of\n-                    (Value, Tree, To => Current_Source.File_Name);\n-                  Set_Source_Index_Of\n-                    (Value, Tree, To => Current_Source.Index);\n-               end if;\n-            end;\n-         end loop;\n-\n-         --  Close the source list file\n-\n-         Close (Source_List_FD);\n-\n-         --  Output the project file\n-\n-         Prj.PP.Pretty_Print\n-           (Project_Node, Tree,\n-            W_Char                 => Write_A_Char'Access,\n-            W_Eol                  => Write_Eol'Access,\n-            W_Str                  => Write_A_String'Access,\n-            Backward_Compatibility => False,\n-            Max_Line_Length        => 79);\n-         Close (Output_FD);\n-\n-         --  Delete the naming project file if it already exists\n-\n-         Delete_File\n-           (Project_Naming_File_Name (1 .. Project_Naming_Last),\n-            Success => Discard);\n-\n-         --  Create a new one\n-\n-         if Opt.Verbose_Mode then\n-            Output.Write_Str (\"Creating new naming project file \"\"\");\n-            Output.Write_Str (Project_Naming_File_Name\n-                              (1 .. Project_Naming_Last));\n-            Output.Write_Line (\"\"\"\");\n-         end if;\n-\n-         Output_FD := Create_New_File\n-           (Project_Naming_File_Name (1 .. Project_Naming_Last),\n-            Fmode => Text);\n-\n-         --  Fails if naming project file cannot be created\n-\n-         if Output_FD = Invalid_FD then\n-            Prj.Com.Fail\n-              (\"cannot create new \"\"\"\n-               & Project_Naming_File_Name (1 .. Project_Naming_Last)\n-               & \"\"\"\");\n-         end if;\n-\n-         --  Output the naming project file\n-\n-         Prj.PP.Pretty_Print\n-           (Project_Naming_Node, Tree,\n-            W_Char                 => Write_A_Char'Access,\n-            W_Eol                  => Write_Eol'Access,\n-            W_Str                  => Write_A_String'Access,\n-            Backward_Compatibility => False);\n-         Close (Output_FD);\n-\n-      else\n-         --  For each Ada source, write a pragma Source_File_Name to the\n-         --  configuration pragmas file.\n-\n-         for Index in 1 .. Sources.Last loop\n-            if Sources.Table (Index).Unit_Name /= No_Name then\n-               Write_A_String (\"pragma Source_File_Name\");\n-               Write_Eol;\n-               Write_A_String (\"  (\");\n-               Write_A_String\n-                 (Get_Name_String (Sources.Table (Index).Unit_Name));\n-               Write_A_String (\",\");\n-               Write_Eol;\n-\n-               if Sources.Table (Index).Spec then\n-                  Write_A_String (\"   Spec_File_Name => \"\"\");\n-\n-               else\n-                  Write_A_String (\"   Body_File_Name => \"\"\");\n-               end if;\n-\n-               Write_A_String\n-                 (Get_Name_String (Sources.Table (Index).File_Name));\n-\n-               Write_A_String (\"\"\"\");\n-\n-               if Sources.Table (Index).Index /= 0 then\n-                  Write_A_String (\", Index =>\");\n-                  Write_A_String (Sources.Table (Index).Index'Img);\n-               end if;\n-\n-               Write_A_String (\");\");\n-               Write_Eol;\n-            end if;\n-         end loop;\n-\n-         Close (Output_FD);\n-      end if;\n-   end Finalize;\n-\n-   ----------------\n-   -- Initialize --\n-   ----------------\n-\n-   procedure Initialize\n-     (File_Path         : String;\n-      Project_File      : Boolean;\n-      Preproc_Switches  : Argument_List;\n-      Very_Verbose      : Boolean;\n-      Flags             : Processing_Flags)\n-   is\n-   begin\n-      Makr.Very_Verbose := Initialize.Very_Verbose;\n-      Makr.Project_File := Initialize.Project_File;\n-\n-      --  Do some needed initializations\n-\n-      Csets.Initialize;\n-      Snames.Initialize;\n-      Stringt.Initialize;\n-\n-      Prj.Initialize (No_Project_Tree);\n-\n-      Prj.Tree.Initialize (Root_Environment, Flags);\n-      Prj.Env.Initialize_Default_Project_Path\n-        (Root_Environment.Project_Path,\n-         Target_Name => Sdefault.Target_Name.all);\n-\n-      Prj.Tree.Initialize (Tree);\n-\n-      Sources.Set_Last (0);\n-      Source_Directories.Set_Last (0);\n-\n-      --  Initialize the compiler switches\n-\n-      Args := new Argument_List (1 .. Preproc_Switches'Length + 6);\n-      Args (1) := new String'(\"-c\");\n-      Args (2) := new String'(\"-gnats\");\n-      Args (3) := new String'(\"-gnatu\");\n-      Args (4 .. 3 + Preproc_Switches'Length) := Preproc_Switches;\n-      Args (4 + Preproc_Switches'Length) := new String'(\"-x\");\n-      Args (5 + Preproc_Switches'Length) := new String'(\"ada\");\n-\n-      --  Get the path and file names\n-\n-      Path_Name := new\n-        String (1 .. File_Path'Length + Project_File_Extension'Length);\n-      Path_Last := File_Path'Length;\n-\n-      if File_Names_Case_Sensitive then\n-         Path_Name (1 .. Path_Last) := File_Path;\n-      else\n-         Path_Name (1 .. Path_Last) := To_Lower (File_Path);\n-      end if;\n-\n-      Path_Name (Path_Last + 1 .. Path_Name'Last) :=\n-        Project_File_Extension;\n-\n-      --  Get the end of directory information, if any\n-\n-      for Index in reverse 1 .. Path_Last loop\n-         if Path_Name (Index) = Directory_Separator then\n-            Directory_Last := Index;\n-            exit;\n-         end if;\n-      end loop;\n-\n-      if Project_File then\n-         if Path_Last < Project_File_Extension'Length + 1\n-           or else Path_Name\n-           (Path_Last - Project_File_Extension'Length + 1 .. Path_Last)\n-           /= Project_File_Extension\n-         then\n-            Path_Last := Path_Name'Last;\n-         end if;\n-\n-         Output_Name := new String'(To_Lower (Path_Name (1 .. Path_Last)));\n-         Output_Name_Last := Output_Name'Last - 4;\n-\n-         --  If there is already a project file with the specified name, parse\n-         --  it to get the components that are not automatically generated.\n-\n-         if Is_Regular_File (Output_Name (1 .. Path_Last)) then\n-            if Opt.Verbose_Mode then\n-               Output.Write_Str (\"Parsing already existing project file \"\"\");\n-               Output.Write_Str (Output_Name.all);\n-               Output.Write_Line (\"\"\"\");\n-            end if;\n-\n-            Part.Parse\n-              (In_Tree                => Tree,\n-               Project                => Project_Node,\n-               Project_File_Name      => Output_Name.all,\n-               Errout_Handling        => Part.Finalize_If_Error,\n-               Store_Comments         => True,\n-               Is_Config_File         => False,\n-               Env                    => Root_Environment,\n-               Current_Directory      => Get_Current_Dir,\n-               Packages_To_Check      => Packages_To_Check_By_Gnatname);\n-\n-            --  Fail if parsing was not successful\n-\n-            if No (Project_Node) then\n-               Prj.Com.Fail (\"parsing of existing project file failed\");\n-\n-            elsif Project_Qualifier_Of (Project_Node, Tree) = Aggregate then\n-               Prj.Com.Fail (\"aggregate projects are not supported\");\n-\n-            elsif Project_Qualifier_Of (Project_Node, Tree) =\n-                                                    Aggregate_Library\n-            then\n-               Prj.Com.Fail (\"aggregate library projects are not supported\");\n-\n-            else\n-               --  If parsing was successful, remove the components that are\n-               --  automatically generated, if any, so that they will be\n-               --  unconditionally added later.\n-\n-               --  Remove the with clause for the naming project file\n-\n-               declare\n-                  With_Clause : Project_Node_Id :=\n-                                  First_With_Clause_Of (Project_Node, Tree);\n-                  Previous    : Project_Node_Id := Empty_Node;\n-\n-               begin\n-                  while Present (With_Clause) loop\n-                     if Prj.Tree.Name_Of (With_Clause, Tree) =\n-                          Project_Naming_Id\n-                     then\n-                        if No (Previous) then\n-                           Set_First_With_Clause_Of\n-                             (Project_Node, Tree,\n-                              To => Next_With_Clause_Of (With_Clause, Tree));\n-                        else\n-                           Set_Next_With_Clause_Of\n-                             (Previous, Tree,\n-                              To => Next_With_Clause_Of (With_Clause, Tree));\n-                        end if;\n-\n-                        exit;\n-                     end if;\n-\n-                     Previous := With_Clause;\n-                     With_Clause := Next_With_Clause_Of (With_Clause, Tree);\n-                  end loop;\n-               end;\n-\n-               --  Remove attribute declarations of Source_Files,\n-               --  Source_List_File, Source_Dirs, and the declaration of\n-               --  package Naming, if they exist, but preserve the comments\n-               --  attached to these nodes.\n-\n-               declare\n-                  Declaration  : Project_Node_Id :=\n-                                   First_Declarative_Item_Of\n-                                     (Project_Declaration_Of\n-                                        (Project_Node, Tree),\n-                                      Tree);\n-                  Previous     : Project_Node_Id := Empty_Node;\n-                  Current_Node : Project_Node_Id := Empty_Node;\n-\n-                  Name         : Name_Id;\n-                  Kind_Of_Node : Project_Node_Kind;\n-                  Comments     : Project_Node_Id;\n-\n-               begin\n-                  while Present (Declaration) loop\n-                     Current_Node := Current_Item_Node (Declaration, Tree);\n-\n-                     Kind_Of_Node := Kind_Of (Current_Node, Tree);\n-\n-                     if Kind_Of_Node = N_Attribute_Declaration or else\n-                       Kind_Of_Node = N_Package_Declaration\n-                     then\n-                        Name := Prj.Tree.Name_Of (Current_Node, Tree);\n-\n-                        if Nam_In (Name, Name_Source_Files,\n-                                         Name_Source_List_File,\n-                                         Name_Source_Dirs,\n-                                         Name_Naming)\n-                        then\n-                           Comments :=\n-                             Tree.Project_Nodes.Table (Current_Node).Comments;\n-\n-                           if Name = Name_Source_Files then\n-                              Source_Files_Comments := Comments;\n-\n-                           elsif Name = Name_Source_List_File then\n-                              Source_List_File_Comments := Comments;\n-\n-                           elsif Name = Name_Source_Dirs then\n-                              Source_Dirs_Comments := Comments;\n-\n-                           elsif Name = Name_Naming then\n-                              Naming_Package_Comments := Comments;\n-                           end if;\n-\n-                           if No (Previous) then\n-                              Set_First_Declarative_Item_Of\n-                                (Project_Declaration_Of (Project_Node, Tree),\n-                                 Tree,\n-                                 To => Next_Declarative_Item\n-                                         (Declaration, Tree));\n-\n-                           else\n-                              Set_Next_Declarative_Item\n-                                (Previous, Tree,\n-                                 To => Next_Declarative_Item\n-                                         (Declaration, Tree));\n-                           end if;\n-\n-                        else\n-                           Previous := Declaration;\n-                        end if;\n-                     end if;\n-\n-                     Declaration := Next_Declarative_Item (Declaration, Tree);\n-                  end loop;\n-               end;\n-            end if;\n-         end if;\n-\n-         if Directory_Last /= 0 then\n-            Output_Name (1 .. Output_Name_Last - Directory_Last) :=\n-              Output_Name (Directory_Last + 1 .. Output_Name_Last);\n-            Output_Name_Last := Output_Name_Last - Directory_Last;\n-         end if;\n-\n-         --  Get the project name id\n-\n-         Name_Len := Output_Name_Last;\n-         Name_Buffer (1 .. Name_Len) := Output_Name (1 .. Name_Len);\n-         Output_Name_Id := Name_Find;\n-\n-         --  Create the project naming file name\n-\n-         Project_Naming_Last := Output_Name_Last;\n-         Project_Naming_File_Name :=\n-           new String'(Output_Name (1 .. Output_Name_Last) &\n-                       Naming_File_Suffix &\n-                       Project_File_Extension);\n-         Project_Naming_Last :=\n-           Project_Naming_Last + Naming_File_Suffix'Length;\n-\n-         --  Get the project naming id\n-\n-         Name_Len := Project_Naming_Last;\n-         Name_Buffer (1 .. Name_Len) :=\n-           Project_Naming_File_Name (1 .. Name_Len);\n-         Project_Naming_Id := Name_Find;\n-\n-         Project_Naming_Last :=\n-           Project_Naming_Last + Project_File_Extension'Length;\n-\n-         --  Create the source list file name\n-\n-         Source_List_Last := Output_Name_Last;\n-         Source_List_Path :=\n-           new String'(Output_Name (1 .. Output_Name_Last) &\n-                       Source_List_File_Suffix);\n-         Source_List_Last :=\n-           Output_Name_Last + Source_List_File_Suffix'Length;\n-\n-         --  Add the project file extension to the project name\n-\n-         Output_Name\n-           (Output_Name_Last + 1 ..\n-              Output_Name_Last + Project_File_Extension'Length) :=\n-           Project_File_Extension;\n-         Output_Name_Last := Output_Name_Last + Project_File_Extension'Length;\n-\n-         --  Back up project file if it already exists\n-\n-         if not Opt.No_Backup\n-           and then Is_Regular_File (Path_Name (1 .. Path_Last))\n-         then\n-            declare\n-               Discard    : Boolean;\n-               Saved_Path : constant String :=\n-                              Path_Name (1 .. Path_Last) & \".saved_\";\n-               Nmb        : Natural;\n-\n-            begin\n-               Nmb := 0;\n-               loop\n-                  declare\n-                     Img : constant String := Nmb'Img;\n-\n-                  begin\n-                     if not Is_Regular_File\n-                              (Saved_Path & Img (2 .. Img'Last))\n-                     then\n-                        Copy_File\n-                          (Name     => Path_Name (1 .. Path_Last),\n-                           Pathname => Saved_Path & Img (2 .. Img'Last),\n-                           Mode     => Overwrite,\n-                           Success  => Discard);\n-                        exit;\n-                     end if;\n-\n-                     Nmb := Nmb + 1;\n-                  end;\n-               end loop;\n-            end;\n-         end if;\n-      end if;\n-\n-      --  Change the current directory to the directory of the project file,\n-      --  if any directory information is specified.\n-\n-      if Directory_Last /= 0 then\n-         begin\n-            Change_Dir (Path_Name (1 .. Directory_Last));\n-         exception\n-            when Directory_Error =>\n-               Prj.Com.Fail\n-                 (\"unknown directory \"\"\"\n-                  & Path_Name (1 .. Directory_Last)\n-                  & \"\"\"\");\n-         end;\n-      end if;\n-   end Initialize;\n-\n-   -------------\n-   -- Process --\n-   -------------\n-\n-   procedure Process\n-     (Directories       : Argument_List;\n-      Name_Patterns     : Regexp_List;\n-      Excluded_Patterns : Regexp_List;\n-      Foreign_Patterns  : Regexp_List)\n-  is\n-      procedure Process_Directory (Dir_Name : String; Recursively : Boolean);\n-      --  Look for Ada and foreign sources in a directory, according to the\n-      --  patterns. When Recursively is True, after looking for sources in\n-      --  Dir_Name, look also in its subdirectories, if any.\n-\n-      -----------------------\n-      -- Process_Directory --\n-      -----------------------\n-\n-      procedure Process_Directory (Dir_Name : String; Recursively : Boolean) is\n-         Matched : Matched_Type := False;\n-         Str     : String (1 .. 2_000);\n-         Canon   : String (1 .. 2_000);\n-         Last    : Natural;\n-         Dir     : Dir_Type;\n-         Do_Process : Boolean := True;\n-\n-         Temp_File_Name         : String_Access := null;\n-         Save_Last_Source_Index : Natural := 0;\n-         File_Name_Id           : Name_Id := No_Name;\n-\n-         Current_Source : Source;\n-\n-      begin\n-         --  Avoid processing the same directory more than once\n-\n-         for Index in 1 .. Processed_Directories.Last loop\n-            if Processed_Directories.Table (Index).all = Dir_Name then\n-               Do_Process := False;\n-               exit;\n-            end if;\n-         end loop;\n-\n-         if Do_Process then\n-            if Opt.Verbose_Mode then\n-               Output.Write_Str (\"Processing directory \"\"\");\n-               Output.Write_Str (Dir_Name);\n-               Output.Write_Line (\"\"\"\");\n-            end if;\n-\n-            Processed_Directories. Increment_Last;\n-            Processed_Directories.Table (Processed_Directories.Last) :=\n-              new String'(Dir_Name);\n-\n-            --  Get the source file names from the directory. Fails if the\n-            --  directory does not exist.\n-\n-            begin\n-               Open (Dir, Dir_Name);\n-            exception\n-               when Directory_Error =>\n-                  Prj.Com.Fail (\"cannot open directory \"\"\" & Dir_Name & \"\"\"\");\n-            end;\n-\n-            --  Process each regular file in the directory\n-\n-            File_Loop : loop\n-               Read (Dir, Str, Last);\n-               exit File_Loop when Last = 0;\n-\n-               --  Copy the file name and put it in canonical case to match\n-               --  against the patterns that have themselves already been put\n-               --  in canonical case.\n-\n-               Canon (1 .. Last) := Str (1 .. Last);\n-               Canonical_Case_File_Name (Canon (1 .. Last));\n-\n-               if Is_Regular_File\n-                    (Dir_Name & Directory_Separator & Str (1 .. Last))\n-               then\n-                  Matched := True;\n-\n-                  Name_Len := Last;\n-                  Name_Buffer (1 .. Name_Len) := Str (1 .. Last);\n-                  File_Name_Id := Name_Find;\n-\n-                  --  First, check if the file name matches at least one of\n-                  --  the excluded expressions;\n-\n-                  for Index in Excluded_Patterns'Range loop\n-                     if\n-                       Match (Canon (1 .. Last), Excluded_Patterns (Index))\n-                     then\n-                        Matched := Excluded;\n-                        exit;\n-                     end if;\n-                  end loop;\n-\n-                  --  If it does not match any of the excluded expressions,\n-                  --  check if the file name matches at least one of the\n-                  --  regular expressions.\n-\n-                  if Matched = True then\n-                     Matched := False;\n-\n-                     for Index in Name_Patterns'Range loop\n-                        if\n-                          Match\n-                            (Canon (1 .. Last), Name_Patterns (Index))\n-                        then\n-                           Matched := True;\n-                           exit;\n-                        end if;\n-                     end loop;\n-                  end if;\n-\n-                  if Very_Verbose\n-                    or else (Matched = True and then Opt.Verbose_Mode)\n-                  then\n-                     Output.Write_Str (\"   Checking \"\"\");\n-                     Output.Write_Str (Str (1 .. Last));\n-                     Output.Write_Line (\"\"\": \");\n-                  end if;\n-\n-                  --  If the file name matches one of the regular expressions,\n-                  --  parse it to get its unit name.\n-\n-                  if Matched = True then\n-                     declare\n-                        FD : File_Descriptor;\n-                        Success : Boolean;\n-                        Saved_Output : File_Descriptor;\n-                        Saved_Error  : File_Descriptor;\n-                        Tmp_File     : Path_Name_Type;\n-\n-                     begin\n-                        --  If we don't have the path of the compiler yet,\n-                        --  get it now. The compiler name may have a prefix,\n-                        --  so we get the potentially prefixed name.\n-\n-                        if Gcc_Path = null then\n-                           declare\n-                              Prefix_Gcc : String_Access :=\n-                                             Program_Name (Gcc, \"gnatname\");\n-                           begin\n-                              Gcc_Path :=\n-                                Locate_Exec_On_Path (Prefix_Gcc.all);\n-                              Free (Prefix_Gcc);\n-                           end;\n-\n-                           if Gcc_Path = null then\n-                              Prj.Com.Fail (\"could not locate \" & Gcc);\n-                           end if;\n-                        end if;\n-\n-                        --  Create the temporary file\n-\n-                        Tempdir.Create_Temp_File (FD, Tmp_File);\n-\n-                        if FD = Invalid_FD then\n-                           Prj.Com.Fail\n-                             (\"could not create temporary file\");\n-\n-                        else\n-                           Temp_File_Name :=\n-                             new String'(Get_Name_String (Tmp_File));\n-                        end if;\n-\n-                        Args (Args'Last) :=\n-                          new String'\n-                            (Dir_Name & Directory_Separator & Str (1 .. Last));\n-\n-                        --  Save the standard output and error\n-\n-                        Saved_Output := Dup (Standout);\n-                        Saved_Error  := Dup (Standerr);\n-\n-                        --  Set standard output and error to the temporary file\n-\n-                        Dup2 (FD, Standout);\n-                        Dup2 (FD, Standerr);\n-\n-                        --  And spawn the compiler\n-\n-                        Spawn (Gcc_Path.all, Args.all, Success);\n-\n-                        --  Restore the standard output and error\n-\n-                        Dup2 (Saved_Output, Standout);\n-                        Dup2 (Saved_Error, Standerr);\n-\n-                        --  Close the temporary file\n-\n-                        Close (FD);\n-\n-                        --  And close the saved standard output and error to\n-                        --  avoid too many file descriptors.\n-\n-                        Close (Saved_Output);\n-                        Close (Saved_Error);\n-\n-                        --  Now that standard output is restored, check if\n-                        --  the compiler ran correctly.\n-\n-                        --  Read the lines of the temporary file:\n-                        --  they should contain the kind and name of the unit.\n-\n-                        declare\n-                           File      : Text_File;\n-                           Text_Line : String (1 .. 1_000);\n-                           Text_Last : Natural;\n-\n-                        begin\n-                           Open (File, Temp_File_Name.all);\n-\n-                           if not Is_Valid (File) then\n-                              Prj.Com.Fail\n-                                (\"could not read temporary file \" &\n-                                 Temp_File_Name.all);\n-                           end if;\n-\n-                           Save_Last_Source_Index := Sources.Last;\n-\n-                           if End_Of_File (File) then\n-                              if Opt.Verbose_Mode then\n-                                 if not Success then\n-                                    Output.Write_Str (\"      (process died) \");\n-                                 end if;\n-                              end if;\n-\n-                           else\n-                              Line_Loop : while not End_Of_File (File) loop\n-                                 Get_Line (File, Text_Line, Text_Last);\n-\n-                                 --  Find the first closing parenthesis\n-\n-                                 Char_Loop : for J in 1 .. Text_Last loop\n-                                    if Text_Line (J) = ')' then\n-                                       if J >= 13 and then\n-                                         Text_Line (1 .. 4) = \"Unit\"\n-                                       then\n-                                          --  Add entry to Sources table\n-\n-                                          Name_Len := J - 12;\n-                                          Name_Buffer (1 .. Name_Len) :=\n-                                            Text_Line (6 .. J - 7);\n-                                          Current_Source :=\n-                                            (Unit_Name  => Name_Find,\n-                                             File_Name  => File_Name_Id,\n-                                             Index => 0,\n-                                             Spec  => Text_Line (J - 5 .. J) =\n-                                                        \"(spec)\");\n-\n-                                          Sources.Append (Current_Source);\n-                                       end if;\n-\n-                                       exit Char_Loop;\n-                                    end if;\n-                                 end loop Char_Loop;\n-                              end loop Line_Loop;\n-                           end if;\n-\n-                           if Save_Last_Source_Index = Sources.Last then\n-                              if Opt.Verbose_Mode then\n-                                 Output.Write_Line (\"      not a unit\");\n-                              end if;\n-\n-                           else\n-                              if Sources.Last >\n-                                   Save_Last_Source_Index + 1\n-                              then\n-                                 for Index in Save_Last_Source_Index + 1 ..\n-                                                Sources.Last\n-                                 loop\n-                                    Sources.Table (Index).Index :=\n-                                      Int (Index - Save_Last_Source_Index);\n-                                 end loop;\n-                              end if;\n-\n-                              for Index in Save_Last_Source_Index + 1 ..\n-                                             Sources.Last\n-                              loop\n-                                 Current_Source := Sources.Table (Index);\n-\n-                                 if Opt.Verbose_Mode then\n-                                    if Current_Source.Spec then\n-                                       Output.Write_Str (\"      spec of \");\n-\n-                                    else\n-                                       Output.Write_Str (\"      body of \");\n-                                    end if;\n-\n-                                    Output.Write_Line\n-                                      (Get_Name_String\n-                                         (Current_Source.Unit_Name));\n-                                 end if;\n-                              end loop;\n-                           end if;\n-\n-                           Close (File);\n-\n-                           Delete_File (Temp_File_Name.all, Success);\n-                        end;\n-                     end;\n-\n-                  --  File name matches none of the regular expressions\n-\n-                  else\n-                     --  If file is not excluded, see if this is foreign source\n-\n-                     if Matched /= Excluded then\n-                        for Index in Foreign_Patterns'Range loop\n-                           if Match (Canon (1 .. Last),\n-                                     Foreign_Patterns (Index))\n-                           then\n-                              Matched := True;\n-                              exit;\n-                           end if;\n-                        end loop;\n-                     end if;\n-\n-                     if Very_Verbose then\n-                        case Matched is\n-                           when False =>\n-                              Output.Write_Line (\"no match\");\n-\n-                           when Excluded =>\n-                              Output.Write_Line (\"excluded\");\n-\n-                           when True =>\n-                              Output.Write_Line (\"foreign source\");\n-                        end case;\n-                     end if;\n-\n-                     if Matched = True then\n-\n-                        --  Add source file name without unit name\n-\n-                        Name_Len := 0;\n-                        Add_Str_To_Name_Buffer (Canon (1 .. Last));\n-                        Sources.Append\n-                          ((File_Name => Name_Find,\n-                            Unit_Name => No_Name,\n-                            Index     => 0,\n-                            Spec      => False));\n-                     end if;\n-                  end if;\n-               end if;\n-            end loop File_Loop;\n-\n-            Close (Dir);\n-         end if;\n-\n-         --  If Recursively is True, call itself for each subdirectory.\n-         --  We do that, even when this directory has already been processed,\n-         --  because all of its subdirectories may not have been processed.\n-\n-         if Recursively then\n-            Open (Dir, Dir_Name);\n-\n-            loop\n-               Read (Dir, Str, Last);\n-               exit when Last = 0;\n-\n-               --  Do not call itself for \".\" or \"..\"\n-\n-               if Is_Directory\n-                    (Dir_Name & Directory_Separator & Str (1 .. Last))\n-                 and then Str (1 .. Last) /= \".\"\n-                 and then Str (1 .. Last) /= \"..\"\n-               then\n-                  Process_Directory\n-                    (Dir_Name & Directory_Separator & Str (1 .. Last),\n-                     Recursively => True);\n-               end if;\n-            end loop;\n-\n-            Close (Dir);\n-         end if;\n-      end Process_Directory;\n-\n-   --  Start of processing for Process\n-\n-   begin\n-      Processed_Directories.Set_Last (0);\n-\n-      --  Process each directory\n-\n-      for Index in Directories'Range  loop\n-\n-         declare\n-            Dir_Name    : constant String := Directories (Index).all;\n-            Last        : Natural := Dir_Name'Last;\n-            Recursively : Boolean := False;\n-            Found       : Boolean;\n-            Canonical   : String (1 .. Dir_Name'Length) := Dir_Name;\n-\n-         begin\n-            Canonical_Case_File_Name (Canonical);\n-\n-            Found := False;\n-            for J in 1 .. Source_Directories.Last loop\n-               if Source_Directories.Table (J).all = Canonical then\n-                  Found := True;\n-                  exit;\n-               end if;\n-            end loop;\n-\n-            if not Found then\n-               Source_Directories.Append (new String'(Canonical));\n-            end if;\n-\n-            if Dir_Name'Length >= 4\n-              and then (Dir_Name (Last - 2 .. Last) = \"/**\")\n-            then\n-               Last := Last - 3;\n-               Recursively := True;\n-            end if;\n-\n-            Process_Directory (Dir_Name (Dir_Name'First .. Last), Recursively);\n-         end;\n-\n-      end loop;\n-   end Process;\n-\n-   ----------------\n-   -- Write_Char --\n-   ----------------\n-   procedure Write_A_Char (C : Character) is\n-   begin\n-      Write_A_String ((1 => C));\n-   end Write_A_Char;\n-\n-   ---------------\n-   -- Write_Eol --\n-   ---------------\n-\n-   procedure Write_Eol is\n-   begin\n-      Write_A_String ((1 => ASCII.LF));\n-   end Write_Eol;\n-\n-   --------------------\n-   -- Write_A_String --\n-   --------------------\n-\n-   procedure Write_A_String (S : String) is\n-      Str : String (1 .. S'Length);\n-\n-   begin\n-      if S'Length > 0 then\n-         Str := S;\n-\n-         if Write (Output_FD, Str (1)'Address, Str'Length) /= Str'Length then\n-            Prj.Com.Fail (\"disk full\");\n-         end if;\n-      end if;\n-   end Write_A_String;\n-\n-end Prj.Makr;"}, {"sha": "91543a2ff79c6359097b06462b68c3962d544e4d", "filename": "gcc/ada/prj-makr.ads", "status": "removed", "additions": 0, "deletions": 88, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-makr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-makr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-makr.ads?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793", "patch": "@@ -1,88 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                             P R J . M A K R                              --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---          Copyright (C) 2001-2009, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  Support for procedure Gnatname\n-\n---  For arbitrary naming schemes, create or update a project file, or create a\n---  configuration pragmas file.\n-\n-with System.Regexp; use System.Regexp;\n-\n-package Prj.Makr is\n-\n-   procedure Initialize\n-     (File_Path         : String;\n-      Project_File      : Boolean;\n-      Preproc_Switches  : Argument_List;\n-      Very_Verbose      : Boolean;\n-      Flags             : Processing_Flags);\n-   --  Start the creation of a configuration pragmas file or the creation or\n-   --  modification of a project file, for gnatname.\n-   --\n-   --  When Project_File is False, File_Path is the name of a configuration\n-   --  pragmas file to create. When Project_File is True, File_Path is the name\n-   --  of a project file to create if it does not exist or to modify if it\n-   --  already exists.\n-   --\n-   --  Preproc_Switches is a list of switches to be used when invoking the\n-   --  compiler to get the name and kind of unit of a source file.\n-   --\n-   --  Very_Verbose controls the verbosity of the output, in conjunction with\n-   --  Opt.Verbose_Mode.\n-\n-   type Regexp_List is array (Positive range <>) of Regexp;\n-\n-   procedure Process\n-     (Directories       : Argument_List;\n-      Name_Patterns     : Regexp_List;\n-      Excluded_Patterns : Regexp_List;\n-      Foreign_Patterns  : Regexp_List);\n-   --  Look for source files in the specified directories, with the specified\n-   --  patterns.\n-   --\n-   --  Directories is the list of source directories where to look for sources.\n-   --\n-   --  Name_Patterns is a potentially empty list of file name patterns to check\n-   --  for Ada Sources.\n-   --\n-   --  Excluded_Patterns is a potentially empty list of file name patterns that\n-   --  should not be checked for Ada or non Ada sources.\n-   --\n-   --  Foreign_Patterns is a potentially empty list of file name patterns to\n-   --  check for non Ada sources.\n-   --\n-   --  At least one of Name_Patterns and Foreign_Patterns is not empty\n-   --\n-   --  Note that this procedure currently assumes that it is only used by\n-   --  gnatname. If other processes start using it, then an additional\n-   --  parameter would need to be added, and call to Osint.Program_Name\n-   --  updated accordingly in the body.\n-\n-   procedure Finalize;\n-   --  Write the configuration pragmas file or the project file indicated in a\n-   --  call to procedure Initialize, after one or several calls to procedure\n-   --  Process.\n-\n-end Prj.Makr;"}, {"sha": "a224e7d038448808e5c4c0fa1bbe4bd2941712cd", "filename": "gcc/ada/prj-nmsc.adb", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793"}, {"sha": "fd45ba91e7f295889c0743e1f90259ca28a691bc", "filename": "gcc/ada/prj-nmsc.ads", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-nmsc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-nmsc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.ads?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793"}, {"sha": "a37e13aec93bf856ff663b3701d7451500f6e2c4", "filename": "gcc/ada/prj-pars.adb", "status": "removed", "additions": 0, "deletions": 142, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-pars.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-pars.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-pars.adb?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793"}, {"sha": "23f3347d7002370a785c8a0d00bebeb6b6f85db0", "filename": "gcc/ada/prj-pars.ads", "status": "removed", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-pars.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-pars.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-pars.ads?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793"}, {"sha": "7afe8c0a3d0771dc95382cb9f1124003de09756d", "filename": "gcc/ada/prj-part.adb", "status": "removed", "additions": 0, "deletions": 2213, "changes": 2213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-part.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-part.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-part.adb?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793"}, {"sha": "1bf1366fb5c9704832cd841cce7ea7bc33ee18c7", "filename": "gcc/ada/prj-part.ads", "status": "removed", "additions": 0, "deletions": 78, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-part.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-part.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-part.ads?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793"}, {"sha": "6da5ae2325d0389b3ef0f49a4c9052aad0905523", "filename": "gcc/ada/prj-pp.adb", "status": "removed", "additions": 0, "deletions": 1010, "changes": 1010, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-pp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-pp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-pp.adb?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793"}, {"sha": "771b4c3f2d4a3352361765b523579b6ebdf63f6c", "filename": "gcc/ada/prj-pp.ads", "status": "removed", "additions": 0, "deletions": 99, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-pp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-pp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-pp.ads?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793"}, {"sha": "ec52c2340e22e97f249a06c70bbdbfef3abcc138", "filename": "gcc/ada/prj-proc.adb", "status": "removed", "additions": 0, "deletions": 3179, "changes": 3179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-proc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-proc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-proc.adb?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793"}, {"sha": "face045b5f4a554d30179d09200b7039b152e104", "filename": "gcc/ada/prj-proc.ads", "status": "removed", "additions": 0, "deletions": 97, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-proc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-proc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-proc.ads?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793"}, {"sha": "eb7aaa3f4dffe5d97dadb31ef910e4f58506f55f", "filename": "gcc/ada/prj-strt.adb", "status": "removed", "additions": 0, "deletions": 1597, "changes": 1597, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-strt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-strt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-strt.adb?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793"}, {"sha": "ab43346ef574255fd2e172a396ec57af6443a6c2", "filename": "gcc/ada/prj-strt.ads", "status": "removed", "additions": 0, "deletions": 110, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-strt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-strt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-strt.ads?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793"}, {"sha": "ea852d110c7ea942b48fc097c38ece4ac058073f", "filename": "gcc/ada/prj-tree.adb", "status": "removed", "additions": 0, "deletions": 3261, "changes": 3261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-tree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-tree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-tree.adb?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793"}, {"sha": "f2290bb20ab83b5136b9019bfb8461dc0437f6e2", "filename": "gcc/ada/prj-tree.ads", "status": "removed", "additions": 0, "deletions": 1563, "changes": 1563, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-tree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-tree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-tree.ads?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793"}, {"sha": "3f3b358311e6c32c212fcef84615d73ea52e05fa", "filename": "gcc/ada/prj-util.adb", "status": "removed", "additions": 0, "deletions": 1432, "changes": 1432, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-util.adb?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793"}, {"sha": "3cdd0c73aeddb6a0b23f73d9fcd9fcf80ca5b6c8", "filename": "gcc/ada/prj-util.ads", "status": "removed", "additions": 0, "deletions": 269, "changes": 269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj-util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-util.ads?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793"}, {"sha": "e14f63e7feb78e80a5b082c5ba02aa3f17ca3c9c", "filename": "gcc/ada/prj.adb", "status": "removed", "additions": 0, "deletions": 2177, "changes": 2177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.adb?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793"}, {"sha": "8920890dcfc400e74a0f43f8b62cf4df432af0d5", "filename": "gcc/ada/prj.ads", "status": "removed", "additions": 0, "deletions": 2135, "changes": 2135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fprj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.ads?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793"}, {"sha": "82548bdf7fba64ab4cdc3db2311149b62b0bb64d", "filename": "gcc/ada/sem_aux.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c48e0f27232aa6604b80e0d15b6ecb50604400a7/gcc%2Fada%2Fsem_aux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c48e0f27232aa6604b80e0d15b6ecb50604400a7/gcc%2Fada%2Fsem_aux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.adb?ref=c48e0f27232aa6604b80e0d15b6ecb50604400a7"}, {"sha": "38180dd469cc2cd8794ee92621aa6a39792b6e3a", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c48e0f27232aa6604b80e0d15b6ecb50604400a7/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c48e0f27232aa6604b80e0d15b6ecb50604400a7/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=c48e0f27232aa6604b80e0d15b6ecb50604400a7"}, {"sha": "75348c7b26720b37e28f7ffdcaa3f4dc55272c46", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c48e0f27232aa6604b80e0d15b6ecb50604400a7/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c48e0f27232aa6604b80e0d15b6ecb50604400a7/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=c48e0f27232aa6604b80e0d15b6ecb50604400a7"}, {"sha": "7c33e381b5fe1ad5a9e8d42b33673d6df1bfd951", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c48e0f27232aa6604b80e0d15b6ecb50604400a7/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c48e0f27232aa6604b80e0d15b6ecb50604400a7/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=c48e0f27232aa6604b80e0d15b6ecb50604400a7"}, {"sha": "621de0315ec70ddbf49f4e9a48e6aa4db10b0789", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c48e0f27232aa6604b80e0d15b6ecb50604400a7/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c48e0f27232aa6604b80e0d15b6ecb50604400a7/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=c48e0f27232aa6604b80e0d15b6ecb50604400a7"}, {"sha": "1cea29aa8a607fc3d6be2699b4b29338727ec552", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c48e0f27232aa6604b80e0d15b6ecb50604400a7/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c48e0f27232aa6604b80e0d15b6ecb50604400a7/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=c48e0f27232aa6604b80e0d15b6ecb50604400a7"}, {"sha": "2d8751c459b2b4a214cf02f96a6d84e8f5578b3d", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c48e0f27232aa6604b80e0d15b6ecb50604400a7/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c48e0f27232aa6604b80e0d15b6ecb50604400a7/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=c48e0f27232aa6604b80e0d15b6ecb50604400a7"}, {"sha": "d643d6466ec65c76d79107539aa908c7a3d395f7", "filename": "gcc/ada/sinput-p.adb", "status": "removed", "additions": 0, "deletions": 163, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fsinput-p.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fsinput-p.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput-p.adb?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793"}, {"sha": "112a6f7d5da3cb40326b9a1c1db44f717606ae4b", "filename": "gcc/ada/sinput-p.ads", "status": "removed", "additions": 0, "deletions": 82, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fsinput-p.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87169db7dc0667a978e3f5b63e0fca648d3b793/gcc%2Fada%2Fsinput-p.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput-p.ads?ref=a87169db7dc0667a978e3f5b63e0fca648d3b793"}]}