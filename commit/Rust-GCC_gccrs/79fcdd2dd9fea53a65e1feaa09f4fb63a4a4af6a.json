{"sha": "79fcdd2dd9fea53a65e1feaa09f4fb63a4a4af6a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzlmY2RkMmRkOWZlYTUzYTY1ZTFmZWFhMDlmNGZiNjNhNGE0YWY2YQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-07-10T09:58:41Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-07-13T07:30:12Z"}, "message": "make var-tracking iteration consistent\n\nThis eliminates the visited bitmap and makes whether a to be processed\nblock goes to the next or the current iteration only depend on its\nposition in RPO order rather than on whether it was visited in the\ncurrent iteration.  As optimization single-BB iteration is processed\nimmediately.\n\n2020-07-10  Richard Biener  <rguenther@suse.de>\n\n\t* var-tracking.c (bb_heap_node_t): Remove unused typedef.\n\t(vt_find_locations): Eliminate visited bitmap in favor of\n\tRPO order check.  Dump statistics about the number of\n\tlocal BB dataflow computes.", "tree": {"sha": "28c78584849931aa9afdeedc859501c73e420b3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28c78584849931aa9afdeedc859501c73e420b3a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79fcdd2dd9fea53a65e1feaa09f4fb63a4a4af6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79fcdd2dd9fea53a65e1feaa09f4fb63a4a4af6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79fcdd2dd9fea53a65e1feaa09f4fb63a4a4af6a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79fcdd2dd9fea53a65e1feaa09f4fb63a4a4af6a/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a4aca1edaf37d43b2b7e9111825837a7a317b1b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4aca1edaf37d43b2b7e9111825837a7a317b1b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4aca1edaf37d43b2b7e9111825837a7a317b1b0"}], "stats": {"total": 235, "additions": 115, "deletions": 120}, "files": [{"sha": "cca75064c8b7f9c48ecf990a350f09d46083f5b2", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 115, "deletions": 120, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79fcdd2dd9fea53a65e1feaa09f4fb63a4a4af6a/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79fcdd2dd9fea53a65e1feaa09f4fb63a4a4af6a/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=79fcdd2dd9fea53a65e1feaa09f4fb63a4a4af6a", "patch": "@@ -118,7 +118,6 @@\n #include \"function-abi.h\"\n \n typedef fibonacci_heap <long, basic_block_def> bb_heap_t;\n-typedef fibonacci_node <long, basic_block_def> bb_heap_node_t;\n \n /* var-tracking.c assumes that tree code with the same value as VALUE rtx code\n    has no chance to appear in REG_EXPR/MEM_EXPRs and isn't a decl.\n@@ -7078,6 +7077,7 @@ vt_find_locations (void)\n   int htabsz = 0;\n   int htabmax = param_max_vartrack_size;\n   bool success = true;\n+  unsigned int n_blocks_processed = 0;\n \n   timevar_push (TV_VAR_TRACKING_DATAFLOW);\n   /* Compute reverse completion order of depth first search of the CFG\n@@ -7089,7 +7089,6 @@ vt_find_locations (void)\n     bb_order[rc_order[i]] = i;\n   free (rc_order);\n \n-  auto_sbitmap visited (last_basic_block_for_fn (cfun));\n   in_worklist = sbitmap_alloc (last_basic_block_for_fn (cfun));\n   in_pending = sbitmap_alloc (last_basic_block_for_fn (cfun));\n   bitmap_clear (in_worklist);\n@@ -7103,154 +7102,150 @@ vt_find_locations (void)\n       std::swap (worklist, pending);\n       std::swap (in_worklist, in_pending);\n \n-      bitmap_clear (visited);\n-\n       while (!worklist->empty ())\n \t{\n+\t  bool changed;\n+\t  edge_iterator ei;\n+\t  int oldinsz, oldoutsz;\n+\n \t  bb = worklist->extract_min ();\n \t  bitmap_clear_bit (in_worklist, bb->index);\n-\t  gcc_assert (!bitmap_bit_p (visited, bb->index));\n-\t  if (!bitmap_bit_p (visited, bb->index))\n+\n+\t  if (VTI (bb)->in.vars)\n \t    {\n-\t      bool changed;\n-\t      edge_iterator ei;\n-\t      int oldinsz, oldoutsz;\n+\t      htabsz -= (shared_hash_htab (VTI (bb)->in.vars)->size ()\n+\t\t\t + shared_hash_htab (VTI (bb)->out.vars)->size ());\n+\t      oldinsz = shared_hash_htab (VTI (bb)->in.vars)->elements ();\n+\t      oldoutsz = shared_hash_htab (VTI (bb)->out.vars)->elements ();\n+\t    }\n+\t  else\n+\t    oldinsz = oldoutsz = 0;\n \n-\t      bitmap_set_bit (visited, bb->index);\n+\t  if (MAY_HAVE_DEBUG_BIND_INSNS)\n+\t    {\n+\t      dataflow_set *in = &VTI (bb)->in, *first_out = NULL;\n+\t      bool first = true, adjust = false;\n \n-\t      if (VTI (bb)->in.vars)\n-\t\t{\n-\t\t  htabsz\n-\t\t    -= shared_hash_htab (VTI (bb)->in.vars)->size ()\n-\t\t\t+ shared_hash_htab (VTI (bb)->out.vars)->size ();\n-\t\t  oldinsz = shared_hash_htab (VTI (bb)->in.vars)->elements ();\n-\t\t  oldoutsz\n-\t\t    = shared_hash_htab (VTI (bb)->out.vars)->elements ();\n-\t\t}\n-\t      else\n-\t\toldinsz = oldoutsz = 0;\n+\t      /* Calculate the IN set as the intersection of\n+\t\t predecessor OUT sets.  */\n \n-\t      if (MAY_HAVE_DEBUG_BIND_INSNS)\n-\t\t{\n-\t\t  dataflow_set *in = &VTI (bb)->in, *first_out = NULL;\n-\t\t  bool first = true, adjust = false;\n+\t      dataflow_set_clear (in);\n+\t      dst_can_be_shared = true;\n \n-\t\t  /* Calculate the IN set as the intersection of\n-\t\t     predecessor OUT sets.  */\n+\t      FOR_EACH_EDGE (e, ei, bb->preds)\n+\t\tif (!VTI (e->src)->flooded)\n+\t\t  gcc_assert (bb_order[bb->index]\n+\t\t\t      <= bb_order[e->src->index]);\n+\t\telse if (first)\n+\t\t  {\n+\t\t    dataflow_set_copy (in, &VTI (e->src)->out);\n+\t\t    first_out = &VTI (e->src)->out;\n+\t\t    first = false;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    dataflow_set_merge (in, &VTI (e->src)->out);\n+\t\t    adjust = true;\n+\t\t  }\n \n-\t\t  dataflow_set_clear (in);\n-\t\t  dst_can_be_shared = true;\n+\t      if (adjust)\n+\t\t{\n+\t\t  dataflow_post_merge_adjust (in, &VTI (bb)->permp);\n \n-\t\t  FOR_EACH_EDGE (e, ei, bb->preds)\n-\t\t    if (!VTI (e->src)->flooded)\n-\t\t      gcc_assert (bb_order[bb->index]\n-\t\t\t\t  <= bb_order[e->src->index]);\n-\t\t    else if (first)\n-\t\t      {\n-\t\t\tdataflow_set_copy (in, &VTI (e->src)->out);\n-\t\t\tfirst_out = &VTI (e->src)->out;\n-\t\t\tfirst = false;\n-\t\t      }\n-\t\t    else\n-\t\t      {\n-\t\t\tdataflow_set_merge (in, &VTI (e->src)->out);\n-\t\t\tadjust = true;\n-\t\t      }\n+\t\t  if (flag_checking)\n+\t\t    /* Merge and merge_adjust should keep entries in\n+\t\t       canonical order.  */\n+\t\t    shared_hash_htab (in->vars)\n+\t\t      ->traverse <dataflow_set *,\n+\t\t\t\t  canonicalize_loc_order_check> (in);\n \n-\t\t  if (adjust)\n+\t\t  if (dst_can_be_shared)\n \t\t    {\n-\t\t      dataflow_post_merge_adjust (in, &VTI (bb)->permp);\n+\t\t      shared_hash_destroy (in->vars);\n+\t\t      in->vars = shared_hash_copy (first_out->vars);\n+\t\t    }\n+\t\t}\n \n-\t\t      if (flag_checking)\n-\t\t\t/* Merge and merge_adjust should keep entries in\n-\t\t\t   canonical order.  */\n-\t\t\tshared_hash_htab (in->vars)\n-\t\t\t  ->traverse <dataflow_set *,\n-\t\t\t\t      canonicalize_loc_order_check> (in);\n+\t      VTI (bb)->flooded = true;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Calculate the IN set as union of predecessor OUT sets.  */\n+\t      dataflow_set_clear (&VTI (bb)->in);\n+\t      FOR_EACH_EDGE (e, ei, bb->preds)\n+\t\tdataflow_set_union (&VTI (bb)->in, &VTI (e->src)->out);\n+\t    }\n \n-\t\t      if (dst_can_be_shared)\n-\t\t\t{\n-\t\t\t  shared_hash_destroy (in->vars);\n-\t\t\t  in->vars = shared_hash_copy (first_out->vars);\n-\t\t\t}\n-\t\t    }\n+\t  changed = compute_bb_dataflow (bb);\n+\t  n_blocks_processed++;\n+\t  htabsz += (shared_hash_htab (VTI (bb)->in.vars)->size ()\n+\t\t     + shared_hash_htab (VTI (bb)->out.vars)->size ());\n \n-\t\t  VTI (bb)->flooded = true;\n-\t\t}\n+\t  if (htabmax && htabsz > htabmax)\n+\t    {\n+\t      if (MAY_HAVE_DEBUG_BIND_INSNS)\n+\t\tinform (DECL_SOURCE_LOCATION (cfun->decl),\n+\t\t\t\"variable tracking size limit exceeded with \"\n+\t\t\t\"%<-fvar-tracking-assignments%>, retrying without\");\n \t      else\n-\t\t{\n-\t\t  /* Calculate the IN set as union of predecessor OUT sets.  */\n-\t\t  dataflow_set_clear (&VTI (bb)->in);\n-\t\t  FOR_EACH_EDGE (e, ei, bb->preds)\n-\t\t    dataflow_set_union (&VTI (bb)->in, &VTI (e->src)->out);\n-\t\t}\n-\n-\t      changed = compute_bb_dataflow (bb);\n-\t      htabsz += shared_hash_htab (VTI (bb)->in.vars)->size ()\n-\t\t\t + shared_hash_htab (VTI (bb)->out.vars)->size ();\n+\t\tinform (DECL_SOURCE_LOCATION (cfun->decl),\n+\t\t\t\"variable tracking size limit exceeded\");\n+\t      success = false;\n+\t      break;\n+\t    }\n \n-\t      if (htabmax && htabsz > htabmax)\n+\t  if (changed)\n+\t    {\n+\t      FOR_EACH_EDGE (e, ei, bb->succs)\n \t\t{\n-\t\t  if (MAY_HAVE_DEBUG_BIND_INSNS)\n-\t\t    inform (DECL_SOURCE_LOCATION (cfun->decl),\n-\t\t\t    \"variable tracking size limit exceeded with \"\n-\t\t\t    \"%<-fvar-tracking-assignments%>, retrying without\");\n-\t\t  else\n-\t\t    inform (DECL_SOURCE_LOCATION (cfun->decl),\n-\t\t\t    \"variable tracking size limit exceeded\");\n-\t\t  success = false;\n-\t\t  break;\n-\t\t}\n+\t\t  if (e->dest == EXIT_BLOCK_PTR_FOR_FN (cfun))\n+\t\t    continue;\n \n-\t      if (changed)\n-\t\t{\n-\t\t  FOR_EACH_EDGE (e, ei, bb->succs)\n+\t\t  /* Iterate to an earlier block in RPO in the next\n+\t\t     round, iterate to the same block immediately.  */\n+\t\t  if (bb_order[e->dest->index] < bb_order[bb->index])\n \t\t    {\n-\t\t      if (e->dest == EXIT_BLOCK_PTR_FOR_FN (cfun))\n-\t\t\tcontinue;\n-\n-\t\t      if (bitmap_bit_p (visited, e->dest->index))\n+\t\t      if (!bitmap_bit_p (in_pending, e->dest->index))\n \t\t\t{\n-\t\t\t  if (!bitmap_bit_p (in_pending, e->dest->index))\n-\t\t\t    {\n-\t\t\t      /* Send E->DEST to next round.  */\n-\t\t\t      bitmap_set_bit (in_pending, e->dest->index);\n-\t\t\t      pending->insert (bb_order[e->dest->index],\n-\t\t\t\t\t       e->dest);\n-\t\t\t    }\n-\t\t\t}\n-\t\t      else if (!bitmap_bit_p (in_worklist, e->dest->index))\n-\t\t\t{\n-\t\t\t  /* Add E->DEST to current round.  */\n-\t\t\t  bitmap_set_bit (in_worklist, e->dest->index);\n-\t\t\t  worklist->insert (bb_order[e->dest->index],\n-\t\t\t\t\t    e->dest);\n+\t\t\t  /* Send E->DEST to next round.  */\n+\t\t\t  bitmap_set_bit (in_pending, e->dest->index);\n+\t\t\t  pending->insert (bb_order[e->dest->index],\n+\t\t\t\t\t   e->dest);\n \t\t\t}\n \t\t    }\n+\t\t  else if (!bitmap_bit_p (in_worklist, e->dest->index))\n+\t\t    {\n+\t\t      /* Add E->DEST to current round.  */\n+\t\t      bitmap_set_bit (in_worklist, e->dest->index);\n+\t\t      worklist->insert (bb_order[e->dest->index],\n+\t\t\t\t\te->dest);\n+\t\t    }\n \t\t}\n+\t    }\n \n-\t      if (dump_file)\n-\t\tfprintf (dump_file,\n-\t\t\t \"BB %i: in %i (was %i), out %i (was %i), rem %i + %i, tsz %i\\n\",\n-\t\t\t bb->index,\n-\t\t\t (int)shared_hash_htab (VTI (bb)->in.vars)->size (),\n-\t\t\t oldinsz,\n-\t\t\t (int)shared_hash_htab (VTI (bb)->out.vars)->size (),\n-\t\t\t oldoutsz,\n-\t\t\t (int)worklist->nodes (), (int)pending->nodes (),\n-\t\t\t htabsz);\n-\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t{\n-\t\t  fprintf (dump_file, \"BB %i IN:\\n\", bb->index);\n-\t\t  dump_dataflow_set (&VTI (bb)->in);\n-\t\t  fprintf (dump_file, \"BB %i OUT:\\n\", bb->index);\n-\t\t  dump_dataflow_set (&VTI (bb)->out);\n-\t\t}\n+\t  if (dump_file)\n+\t    fprintf (dump_file,\n+\t\t     \"BB %i: in %i (was %i), out %i (was %i), rem %i + %i, tsz %i\\n\",\n+\t\t     bb->index,\n+\t\t     (int)shared_hash_htab (VTI (bb)->in.vars)->size (),\n+\t\t     oldinsz,\n+\t\t     (int)shared_hash_htab (VTI (bb)->out.vars)->size (),\n+\t\t     oldoutsz,\n+\t\t     (int)worklist->nodes (), (int)pending->nodes (), htabsz);\n+\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"BB %i IN:\\n\", bb->index);\n+\t      dump_dataflow_set (&VTI (bb)->in);\n+\t      fprintf (dump_file, \"BB %i OUT:\\n\", bb->index);\n+\t      dump_dataflow_set (&VTI (bb)->out);\n \t    }\n \t}\n     }\n \n+  statistics_counter_event (cfun, \"compute_bb_dataflow times\",\n+\t\t\t    n_blocks_processed);\n+\n   if (success && MAY_HAVE_DEBUG_BIND_INSNS)\n     FOR_EACH_BB_FN (bb, cfun)\n       gcc_assert (VTI (bb)->flooded);"}]}