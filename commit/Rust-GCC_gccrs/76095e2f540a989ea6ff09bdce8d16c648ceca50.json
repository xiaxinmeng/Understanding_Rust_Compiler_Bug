{"sha": "76095e2f540a989ea6ff09bdce8d16c648ceca50", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzYwOTVlMmY1NDBhOTg5ZWE2ZmYwOWJkY2U4ZDE2YzY0OGNlY2E1MA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-09-09T07:07:41Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-09-09T07:07:41Z"}, "message": "combine.c (SUBST): Break out to a real function do_SUBST.\n\n        * combine.c (SUBST): Break out to a real function do_SUBST.\n        (SUBST_INT): Likewise.\n        * gcse.c (free_pre_mem): Free `temp_bitmap'.\n        (pre_insert): Free `inserted'.\n        * loop.c (basic_induction_var): Always set `location'.\n\n        * function.c (expand_function_end): Add initial_trampoline as a root.\n        * rtl.h (init_varasm_once): Declare.\n        * toplev.c (compile_file): Call it.\n        * ggc-simple.c (ggc_mark_string_ptr): New.\n        (ggc_add_string_root): New.\n        (ggc_collect): Disable collection avoidance temporarily.\n        * ggc.h (ggc_add_string_root): Declare.\n        * except.c (create_rethrow_ref): Use ggc_alloc_string.\n        * optabs.c (init_libfuncs): Likewise.\n        * varasm.c (named_section): Use ggc_alloc_string.\n        (make_function_rtl): Likewise.\n        (make_decl_rtl): Likewise.\n        (assemble_static_space): Likewise.\n        (assemble_trampoline_template): Likewise.\n        (output_constant_def): Likewise.\n        (force_const_mem): Likewise.\n        (mark_const_hash_entry): New.\n        (mark_pool_sym_hash_table): New.\n        (mark_varasm_state): Use it.\n        (init_varasm_once): New.\n\n        * expr.h (init_one_libfunc): Declare.\n        * optabs.c (init_one_libfunc): New.\n        (init_optabs): Use it.\n        * config/gofast.h: Likewise.\n        * config/sparc/sol2.h (INIT_SUBTARGET_OPTABS): Likewise.\n        * config/sparc/sparc.h (INIT_TARGET_OPTABS): Likewise.\n\nFrom-SVN: r29226", "tree": {"sha": "a7da2e093783d85c65b07fb9ce3252698327f53b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a7da2e093783d85c65b07fb9ce3252698327f53b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/76095e2f540a989ea6ff09bdce8d16c648ceca50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76095e2f540a989ea6ff09bdce8d16c648ceca50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76095e2f540a989ea6ff09bdce8d16c648ceca50", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76095e2f540a989ea6ff09bdce8d16c648ceca50/comments", "author": null, "committer": null, "parents": [{"sha": "e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65"}], "stats": {"total": 667, "additions": 394, "deletions": 273}, "files": [{"sha": "589c7244c633e9908a91b1baab958efea0cc5705", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76095e2f540a989ea6ff09bdce8d16c648ceca50/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76095e2f540a989ea6ff09bdce8d16c648ceca50/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=76095e2f540a989ea6ff09bdce8d16c648ceca50", "patch": "@@ -1,3 +1,39 @@\n+Wed Sep  8 23:53:22 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* combine.c (SUBST): Break out to a real function do_SUBST.\n+\t(SUBST_INT): Likewise.\n+\t* gcse.c (free_pre_mem): Free `temp_bitmap'.\n+\t(pre_insert): Free `inserted'.\n+\t* loop.c (basic_induction_var): Always set `location'.\n+\n+\t* function.c (expand_function_end): Add initial_trampoline as a root.\n+\t* rtl.h (init_varasm_once): Declare.\n+\t* toplev.c (compile_file): Call it.\n+\t* ggc-simple.c (ggc_mark_string_ptr): New.\n+\t(ggc_add_string_root): New.\n+\t(ggc_collect): Disable collection avoidance temporarily.\n+\t* ggc.h (ggc_add_string_root): Declare.\n+\t* except.c (create_rethrow_ref): Use ggc_alloc_string.\n+\t* optabs.c (init_libfuncs): Likewise.\n+\t* varasm.c (named_section): Use ggc_alloc_string.\n+\t(make_function_rtl): Likewise.\n+\t(make_decl_rtl): Likewise.\n+\t(assemble_static_space): Likewise.\n+\t(assemble_trampoline_template): Likewise.\n+\t(output_constant_def): Likewise.\n+\t(force_const_mem): Likewise.\n+\t(mark_const_hash_entry): New.\n+\t(mark_pool_sym_hash_table): New.\n+\t(mark_varasm_state): Use it.\n+\t(init_varasm_once): New.\n+\n+\t* expr.h (init_one_libfunc): Declare.\n+\t* optabs.c (init_one_libfunc): New.\n+\t(init_optabs): Use it.\n+\t* config/gofast.h: Likewise.\n+\t* config/sparc/sol2.h (INIT_SUBTARGET_OPTABS): Likewise.\n+\t* config/sparc/sparc.h (INIT_TARGET_OPTABS): Likewise.\n+\n Thu Sep  9 13:46:06 1999  Geoffrey Keating  <geoffk@cygnus.com>\n \n \t* Makefile.in (cppexp.o): Depend on cpphash.h."}, {"sha": "b0646c21b0b041748a05132b855f381c22419e23", "filename": "gcc/combine.c", "status": "modified", "additions": 62, "deletions": 47, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76095e2f540a989ea6ff09bdce8d16c648ceca50/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76095e2f540a989ea6ff09bdce8d16c648ceca50/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=76095e2f540a989ea6ff09bdce8d16c648ceca50", "patch": "@@ -338,58 +338,13 @@ struct undobuf\n \n static struct undobuf undobuf;\n \n-/* Substitute NEWVAL, an rtx expression, into INTO, a place in some\n-   insn.  The substitution can be undone by undo_all.  If INTO is already\n-   set to NEWVAL, do not record this change.  Because computing NEWVAL might\n-   also call SUBST, we have to compute it before we put anything into\n-   the undo table.  */\n-\n-#define SUBST(INTO, NEWVAL)  \\\n- do { rtx _new = (NEWVAL);\t\t\t\t\t\\\n-      struct undo *_buf;\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-      if (undobuf.frees)\t\t\t\t\t\\\n-\t_buf = undobuf.frees, undobuf.frees = _buf->next;\t\\\n-      else\t\t\t\t\t\t\t\\\n-\t_buf = (struct undo *) xmalloc (sizeof (struct undo));\t\\\n-\t\t\t\t\t\t\t\t\\\n-      _buf->is_int = 0;\t\t\t\t\t\t\\\n-      _buf->where.r = &INTO;\t\t\t\t\t\\\n-      _buf->old_contents.r = INTO;\t\t\t\t\\\n-      INTO = _new;\t\t\t\t\t\t\\\n-      if (_buf->old_contents.r == INTO)\t\t\t\t\\\n-\t_buf->next = undobuf.frees, undobuf.frees = _buf;\t\\\n-      else\t\t\t\t\t\t\t\\\n-\t_buf->next = undobuf.undos, undobuf.undos = _buf;\t\\\n-    } while (0)\n-\n-/* Similar to SUBST, but NEWVAL is an int expression.  Note that substitution\n-   for the value of a HOST_WIDE_INT value (including CONST_INT) is\n-   not safe.  */\n-\n-#define SUBST_INT(INTO, NEWVAL)  \\\n- do { struct undo *_buf;\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-      if (undobuf.frees)\t\t\t\t\t\\\n-\t_buf = undobuf.frees, undobuf.frees = _buf->next;\t\\\n-      else\t\t\t\t\t\t\t\\\n-\t_buf = (struct undo *) xmalloc (sizeof (struct undo));\t\\\n-\t\t\t\t\t\t\t\t\\\n-      _buf->is_int = 1;\t\t\t\t\t\t\\\n-      _buf->where.i = (int *) &INTO;\t\t\t\t\\\n-      _buf->old_contents.i = INTO;\t\t\t\t\\\n-      INTO = NEWVAL;\t\t\t\t\t\t\\\n-      if (_buf->old_contents.i == INTO)\t\t\t\t\\\n-\t_buf->next = undobuf.frees, undobuf.frees = _buf;\t\\\n-      else\t\t\t\t\t\t\t\\\n-\t_buf->next = undobuf.undos, undobuf.undos = _buf;\t\\\n-     } while (0)\n-\n /* Number of times the pseudo being substituted for\n    was found and replaced.  */\n \n static int n_occurrences;\n \n+static void do_SUBST\t\t\tPROTO((rtx *, rtx));\n+static void do_SUBST_INT\t\tPROTO((int *, int));\n static void init_reg_last_arrays\tPROTO((void));\n static void setup_incoming_promotions   PROTO((void));\n static void set_nonzero_bits_and_sign_copies  PROTO((rtx, rtx));\n@@ -453,6 +408,66 @@ static void distribute_links\tPROTO((rtx));\n static void mark_used_regs_combine PROTO((rtx));\n static int insn_cuid\t\tPROTO((rtx));\n \f\n+/* Substitute NEWVAL, an rtx expression, into INTO, a place in some\n+   insn.  The substitution can be undone by undo_all.  If INTO is already\n+   set to NEWVAL, do not record this change.  Because computing NEWVAL might\n+   also call SUBST, we have to compute it before we put anything into\n+   the undo table.  */\n+\n+static void\n+do_SUBST(into, newval)\n+     rtx *into, newval;\n+{\n+  struct undo *buf;\n+  rtx oldval = *into;\n+\n+  if (oldval == newval)\n+    return;\n+\n+  if (undobuf.frees)\n+    buf = undobuf.frees, undobuf.frees = buf->next;\n+  else\n+    buf = (struct undo *) xmalloc (sizeof (struct undo));\n+\n+  buf->is_int = 0;\n+  buf->where.r = into;\n+  buf->old_contents.r = oldval;\n+  *into = newval;\n+\n+  buf->next = undobuf.undos, undobuf.undos = buf;\n+}\n+\n+#define SUBST(INTO, NEWVAL)\tdo_SUBST(&(INTO), (NEWVAL))\n+\n+/* Similar to SUBST, but NEWVAL is an int expression.  Note that substitution\n+   for the value of a HOST_WIDE_INT value (including CONST_INT) is\n+   not safe.  */\n+\n+static void\n+do_SUBST_INT(into, newval)\n+     int *into, newval;\n+{\n+  struct undo *buf;\n+  int oldval = *into;\n+\n+  if (oldval == newval)\n+    return;\n+\n+  if (undobuf.frees)\n+    buf = undobuf.frees, undobuf.frees = buf->next;\n+  else\n+    buf = (struct undo *) xmalloc (sizeof (struct undo));\n+\n+  buf->is_int = 1;\n+  buf->where.i = into;\n+  buf->old_contents.i = oldval;\n+  *into = newval;\n+\n+  buf->next = undobuf.undos, undobuf.undos = buf;\n+}\n+\n+#define SUBST_INT(INTO, NEWVAL)  do_SUBST_INT(&(INTO), (NEWVAL))\n+\f\n /* Main entry point for combiner.  F is the first insn of the function.\n    NREGS is the first unused pseudo-reg number.  */\n "}, {"sha": "dd09ea11b144e87bd472a31e9210a8578d597ebb", "filename": "gcc/config/gofast.h", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76095e2f540a989ea6ff09bdce8d16c648ceca50/gcc%2Fconfig%2Fgofast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76095e2f540a989ea6ff09bdce8d16c648ceca50/gcc%2Fconfig%2Fgofast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgofast.h?ref=76095e2f540a989ea6ff09bdce8d16c648ceca50", "patch": "@@ -44,33 +44,33 @@ Boston, MA 02111-1307, USA.  */\n   } while (0)\n \n #define GOFAST_RENAME_LIBCALLS \\\n-  add_optab->handlers[(int) SFmode].libfunc = gen_rtx_SYMBOL_REF (Pmode, \"fpadd\"); \\\n-  add_optab->handlers[(int) DFmode].libfunc = gen_rtx_SYMBOL_REF (Pmode, \"dpadd\"); \\\n-  sub_optab->handlers[(int) SFmode].libfunc = gen_rtx_SYMBOL_REF (Pmode, \"fpsub\"); \\\n-  sub_optab->handlers[(int) DFmode].libfunc = gen_rtx_SYMBOL_REF (Pmode, \"dpsub\"); \\\n-  smul_optab->handlers[(int) SFmode].libfunc = gen_rtx_SYMBOL_REF (Pmode, \"fpmul\"); \\\n-  smul_optab->handlers[(int) DFmode].libfunc = gen_rtx_SYMBOL_REF (Pmode, \"dpmul\"); \\\n-  flodiv_optab->handlers[(int) SFmode].libfunc = gen_rtx_SYMBOL_REF (Pmode, \"fpdiv\"); \\\n-  flodiv_optab->handlers[(int) DFmode].libfunc = gen_rtx_SYMBOL_REF (Pmode, \"dpdiv\"); \\\n-  cmp_optab->handlers[(int) SFmode].libfunc = gen_rtx_SYMBOL_REF (Pmode, \"fpcmp\"); \\\n-  cmp_optab->handlers[(int) DFmode].libfunc = gen_rtx_SYMBOL_REF (Pmode, \"dpcmp\"); \\\n+  add_optab->handlers[(int) SFmode].libfunc = init_one_libfunc (\"fpadd\"); \\\n+  add_optab->handlers[(int) DFmode].libfunc = init_one_libfunc (\"dpadd\"); \\\n+  sub_optab->handlers[(int) SFmode].libfunc = init_one_libfunc (\"fpsub\"); \\\n+  sub_optab->handlers[(int) DFmode].libfunc = init_one_libfunc (\"dpsub\"); \\\n+  smul_optab->handlers[(int) SFmode].libfunc = init_one_libfunc (\"fpmul\"); \\\n+  smul_optab->handlers[(int) DFmode].libfunc = init_one_libfunc (\"dpmul\"); \\\n+  flodiv_optab->handlers[(int) SFmode].libfunc = init_one_libfunc (\"fpdiv\"); \\\n+  flodiv_optab->handlers[(int) DFmode].libfunc = init_one_libfunc (\"dpdiv\"); \\\n+  cmp_optab->handlers[(int) SFmode].libfunc = init_one_libfunc (\"fpcmp\"); \\\n+  cmp_optab->handlers[(int) DFmode].libfunc = init_one_libfunc (\"dpcmp\"); \\\n \\\n-  extendsfdf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"fptodp\"); \\\n-  truncdfsf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"dptofp\"); \\\n+  extendsfdf2_libfunc = init_one_libfunc (\"fptodp\"); \\\n+  truncdfsf2_libfunc = init_one_libfunc (\"dptofp\"); \\\n \\\n-  eqsf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"fpcmp\"); \\\n-  nesf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"fpcmp\"); \\\n-  gtsf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"fpcmp\"); \\\n-  gesf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"fpcmp\"); \\\n-  ltsf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"fpcmp\"); \\\n-  lesf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"fpcmp\"); \\\n+  eqsf2_libfunc = init_one_libfunc (\"fpcmp\"); \\\n+  nesf2_libfunc = init_one_libfunc (\"fpcmp\"); \\\n+  gtsf2_libfunc = init_one_libfunc (\"fpcmp\"); \\\n+  gesf2_libfunc = init_one_libfunc (\"fpcmp\"); \\\n+  ltsf2_libfunc = init_one_libfunc (\"fpcmp\"); \\\n+  lesf2_libfunc = init_one_libfunc (\"fpcmp\"); \\\n \\\n-  eqdf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"dpcmp\"); \\\n-  nedf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"dpcmp\"); \\\n-  gtdf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"dpcmp\"); \\\n-  gedf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"dpcmp\"); \\\n-  ltdf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"dpcmp\"); \\\n-  ledf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"dpcmp\"); \\\n+  eqdf2_libfunc = init_one_libfunc (\"dpcmp\"); \\\n+  nedf2_libfunc = init_one_libfunc (\"dpcmp\"); \\\n+  gtdf2_libfunc = init_one_libfunc (\"dpcmp\"); \\\n+  gedf2_libfunc = init_one_libfunc (\"dpcmp\"); \\\n+  ltdf2_libfunc = init_one_libfunc (\"dpcmp\"); \\\n+  ledf2_libfunc = init_one_libfunc (\"dpcmp\"); \\\n \\\n   eqxf2_libfunc = NULL_RTX; \\\n   nexf2_libfunc = NULL_RTX; \\\n@@ -86,11 +86,11 @@ Boston, MA 02111-1307, USA.  */\n   lttf2_libfunc = NULL_RTX; \\\n   letf2_libfunc = NULL_RTX; \\\n \\\n-  floatsisf_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"sitofp\"); \\\n-  floatsidf_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"litodp\"); \\\n-  fixsfsi_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"fptosi\"); \\\n-  fixdfsi_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"dptoli\"); \\\n-  fixunssfsi_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"fptoui\"); \\\n-  fixunsdfsi_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"dptoul\"); \\\n+  floatsisf_libfunc = init_one_libfunc (\"sitofp\"); \\\n+  floatsidf_libfunc = init_one_libfunc (\"litodp\"); \\\n+  fixsfsi_libfunc = init_one_libfunc (\"fptosi\"); \\\n+  fixdfsi_libfunc = init_one_libfunc (\"dptoli\"); \\\n+  fixunssfsi_libfunc = init_one_libfunc (\"fptoui\"); \\\n+  fixunsdfsi_libfunc = init_one_libfunc (\"dptoul\"); \\\n \n /* End of GOFAST_RENAME_LIBCALLS */"}, {"sha": "92e44d6e78f534657b63848519ccfe289d23e0fd", "filename": "gcc/config/sparc/sol2.h", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76095e2f540a989ea6ff09bdce8d16c648ceca50/gcc%2Fconfig%2Fsparc%2Fsol2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76095e2f540a989ea6ff09bdce8d16c648ceca50/gcc%2Fconfig%2Fsparc%2Fsol2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsol2.h?ref=76095e2f540a989ea6ff09bdce8d16c648ceca50", "patch": "@@ -194,15 +194,15 @@ Boston, MA 02111-1307, USA.  */\n #define UMODDI3_LIBCALL \"__urem64\"\n \n #undef INIT_SUBTARGET_OPTABS\n-#define INIT_SUBTARGET_OPTABS\t\\\n-  fixsfdi_libfunc = gen_rtx_SYMBOL_REF (Pmode, \\\n-\tTARGET_ARCH64 ? \"__ftol\" : \"__ftoll\");\t\\\n-  fixunssfdi_libfunc = gen_rtx_SYMBOL_REF (Pmode, \\\n-\tTARGET_ARCH64 ? \"__ftoul\" : \"__ftoull\");\t\\\n-  fixdfdi_libfunc = gen_rtx_SYMBOL_REF (Pmode, \\\n-\tTARGET_ARCH64 ? \"__dtol\" : \"__dtoll\");\t\\\n-  fixunsdfdi_libfunc = gen_rtx_SYMBOL_REF (Pmode, \\\n-\tTARGET_ARCH64 ? \"__dtoul\" : \"__dtoull\")\n+#define INIT_SUBTARGET_OPTABS\t\t\t\t\t\t\\\n+  fixsfdi_libfunc\t\t\t\t\t\t\t\\\n+    = init_one_libfunc (TARGET_ARCH64 ? \"__ftol\" : \"__ftoll\");\t\t\\\n+  fixunssfdi_libfunc\t\t\t\t\t\t\t\\\n+    = init_one_libfunc (TARGET_ARCH64 ? \"__ftoul\" : \"__ftoull\");\t\\\n+  fixdfdi_libfunc\t\t\t\t\t\t\t\\\n+    = init_one_libfunc (TARGET_ARCH64 ? \"__dtol\" : \"__dtoll\");\t\t\\\n+  fixunsdfdi_libfunc\t\t\t\t\t\t\t\\\n+    = init_one_libfunc (TARGET_ARCH64 ? \"__dtoul\" : \"__dtoull\")\n \n /* No weird SPARC variants on Solaris */\n #undef TARGET_LIVE_G0"}, {"sha": "6957a12ecef4f0360693889b33b4b4c9a3714bf7", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76095e2f540a989ea6ff09bdce8d16c648ceca50/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76095e2f540a989ea6ff09bdce8d16c648ceca50/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=76095e2f540a989ea6ff09bdce8d16c648ceca50", "patch": "@@ -2637,32 +2637,32 @@ do {                                                                    \\\n #define INIT_TARGET_OPTABS\t\t\t\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n     add_optab->handlers[(int) TFmode].libfunc\t\t\t\t\\\n-      = gen_rtx_SYMBOL_REF (Pmode, ADDTF3_LIBCALL);\t\t\t\\\n+      = init_one_libfunc (ADDTF3_LIBCALL);\t\t\t\t\\\n     sub_optab->handlers[(int) TFmode].libfunc\t\t\t\t\\\n-      = gen_rtx_SYMBOL_REF (Pmode, SUBTF3_LIBCALL);\t\t\t\\\n+      = init_one_libfunc (SUBTF3_LIBCALL);\t\t\t\t\\\n     neg_optab->handlers[(int) TFmode].libfunc\t\t\t\t\\\n-      = gen_rtx_SYMBOL_REF (Pmode, NEGTF2_LIBCALL);\t\t\t\\\n+      = init_one_libfunc (NEGTF2_LIBCALL);\t\t\t\t\\\n     smul_optab->handlers[(int) TFmode].libfunc\t\t\t\t\\\n-      = gen_rtx_SYMBOL_REF (Pmode, MULTF3_LIBCALL);\t\t\t\\\n+      = init_one_libfunc (MULTF3_LIBCALL);\t\t\t\t\\\n     flodiv_optab->handlers[(int) TFmode].libfunc\t\t\t\\\n-      = gen_rtx_SYMBOL_REF (Pmode, DIVTF3_LIBCALL);\t\t\t\\\n-    eqtf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, EQTF2_LIBCALL);\t\t\\\n-    netf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, NETF2_LIBCALL);\t\t\\\n-    gttf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, GTTF2_LIBCALL);\t\t\\\n-    getf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, GETF2_LIBCALL);\t\t\\\n-    lttf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, LTTF2_LIBCALL);\t\t\\\n-    letf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, LETF2_LIBCALL);\t\t\\\n-    trunctfsf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, TRUNCTFSF2_LIBCALL);   \\\n-    trunctfdf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, TRUNCTFDF2_LIBCALL);   \\\n-    extendsftf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, EXTENDSFTF2_LIBCALL); \\\n-    extenddftf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, EXTENDDFTF2_LIBCALL); \\\n-    floatsitf_libfunc = gen_rtx_SYMBOL_REF (Pmode, FLOATSITF2_LIBCALL);    \\\n-    fixtfsi_libfunc = gen_rtx_SYMBOL_REF (Pmode, FIX_TRUNCTFSI2_LIBCALL);  \\\n+      = init_one_libfunc (DIVTF3_LIBCALL);\t\t\t\t\\\n+    eqtf2_libfunc = init_one_libfunc (EQTF2_LIBCALL);\t\t\t\\\n+    netf2_libfunc = init_one_libfunc (NETF2_LIBCALL);\t\t\t\\\n+    gttf2_libfunc = init_one_libfunc (GTTF2_LIBCALL);\t\t\t\\\n+    getf2_libfunc = init_one_libfunc (GETF2_LIBCALL);\t\t\t\\\n+    lttf2_libfunc = init_one_libfunc (LTTF2_LIBCALL);\t\t\t\\\n+    letf2_libfunc = init_one_libfunc (LETF2_LIBCALL);\t\t\t\\\n+    trunctfsf2_libfunc = init_one_libfunc (TRUNCTFSF2_LIBCALL);\t\t\\\n+    trunctfdf2_libfunc = init_one_libfunc (TRUNCTFDF2_LIBCALL);\t\t\\\n+    extendsftf2_libfunc = init_one_libfunc (EXTENDSFTF2_LIBCALL);\t\\\n+    extenddftf2_libfunc = init_one_libfunc (EXTENDDFTF2_LIBCALL);\t\\\n+    floatsitf_libfunc = init_one_libfunc (FLOATSITF2_LIBCALL);\t\t\\\n+    fixtfsi_libfunc = init_one_libfunc (FIX_TRUNCTFSI2_LIBCALL);\t\\\n     fixunstfsi_libfunc\t\t\t\t\t\t\t\\\n-      = gen_rtx_SYMBOL_REF (Pmode, FIXUNS_TRUNCTFSI2_LIBCALL);\t\t\\\n+      = init_one_libfunc (FIXUNS_TRUNCTFSI2_LIBCALL);\t\t\t\\\n     if (TARGET_FPU)\t\t\t\t\t\t\t\\\n       sqrt_optab->handlers[(int) TFmode].libfunc\t\t\t\\\n-\t= gen_rtx_SYMBOL_REF (Pmode, \"_Q_sqrt\");\t\t\t\\\n+\t= init_one_libfunc (\"_Q_sqrt\");\t\t\t\t\t\\\n     INIT_SUBTARGET_OPTABS;\t\t\t\t\t\t\\\n   } while (0)\n "}, {"sha": "ca2c89d8df6a8d71d74b7dabfa6b552c91072e06", "filename": "gcc/except.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76095e2f540a989ea6ff09bdce8d16c648ceca50/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76095e2f540a989ea6ff09bdce8d16c648ceca50/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=76095e2f540a989ea6ff09bdce8d16c648ceca50", "patch": "@@ -494,7 +494,7 @@ create_rethrow_ref (region_num)\n   end_temporary_allocation ();\n \n   ASM_GENERATE_INTERNAL_LABEL (buf, \"LRTH\", region_num);\n-  ptr = (char *) obstack_copy0 (&permanent_obstack, buf, strlen (buf));\n+  ptr = ggc_alloc_string (buf, -1);\n   def = gen_rtx_SYMBOL_REF (Pmode, ptr);\n   SYMBOL_REF_NEED_ADJUST (def) = 1;\n "}, {"sha": "26c53cf8dbc826c6676ccd8db7227f3daf074689", "filename": "gcc/expr.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76095e2f540a989ea6ff09bdce8d16c648ceca50/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76095e2f540a989ea6ff09bdce8d16c648ceca50/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=76095e2f540a989ea6ff09bdce8d16c648ceca50", "patch": "@@ -828,6 +828,9 @@ extern void expand_float PROTO((rtx, rtx, int));\n /* Generate code for a FIX_EXPR.  */\n extern void expand_fix PROTO((rtx, rtx, int));\n \n+/* Call this to initialize an optab function entry.  */\n+extern rtx init_one_libfunc PROTO ((const char *));\n+\n /* Call this once to initialize the contents of the optabs\n    appropriately for the current target machine.  */\n extern void init_optabs\tPROTO((void));"}, {"sha": "3f14350b8add3f6fb0181494fc00c9e39618ba1c", "filename": "gcc/function.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76095e2f540a989ea6ff09bdce8d16c648ceca50/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76095e2f540a989ea6ff09bdce8d16c648ceca50/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=76095e2f540a989ea6ff09bdce8d16c648ceca50", "patch": "@@ -6066,6 +6066,8 @@ expand_function_end (filename, line, end_bindings)\n \t  initial_trampoline\n \t    = gen_rtx_MEM (BLKmode, assemble_trampoline_template ());\n \t  resume_temporary_allocation ();\n+\n+\t  ggc_add_rtx_root (&initial_trampoline, 1);\n \t}\n #endif\n "}, {"sha": "a90a200cf93d49df5ecb9869d7a5eb16505e9b2d", "filename": "gcc/gcse.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76095e2f540a989ea6ff09bdce8d16c648ceca50/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76095e2f540a989ea6ff09bdce8d16c648ceca50/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=76095e2f540a989ea6ff09bdce8d16c648ceca50", "patch": "@@ -4086,6 +4086,7 @@ free_pre_mem ()\n   free (comp);\n   free (antloc);\n \n+  free (temp_bitmap);\n   free (pre_optimal);\n   free (pre_redundant);\n   free (transpout);\n@@ -4412,6 +4413,8 @@ pre_insert (index_map)\n \t    }\n \t}\n     }\n+\n+  sbitmap_vector_free (inserted);\n }\n \n /* Copy the result of INSN to REG."}, {"sha": "e4064a8140b139c77a13d4cb06d12d46bfac912d", "filename": "gcc/ggc-simple.c", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76095e2f540a989ea6ff09bdce8d16c648ceca50/gcc%2Fggc-simple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76095e2f540a989ea6ff09bdce8d16c648ceca50/gcc%2Fggc-simple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-simple.c?ref=76095e2f540a989ea6ff09bdce8d16c648ceca50", "patch": "@@ -125,6 +125,7 @@ static void ggc_free_rtx PROTO ((struct ggc_rtx *r));\n static void ggc_free_tree PROTO ((struct ggc_tree *t));\n static void ggc_mark_rtx_ptr PROTO ((void *elt));\n static void ggc_mark_tree_ptr PROTO ((void *elt));\n+static void ggc_mark_string_ptr PROTO ((void *elt));\n static void ggc_mark_tree_varray_ptr PROTO ((void *elt));\n static void ggc_mark_tree_hash_table_ptr PROTO ((void *elt));\n static boolean ggc_mark_tree_hash_table_entry PROTO ((struct hash_entry *,\n@@ -691,7 +692,7 @@ ggc_collect ()\n   struct ggc_any *a, **ap;\n   int time, n_rtxs, n_trees, n_vecs, n_strings, n_anys;\n \n-#ifndef ENABLE_CHECKING\n+#if 0\n   /* See if it's even worth our while.  */\n   if (ggc_chain->bytes_alloced_since_gc < 64*1024)\n     return;\n@@ -883,6 +884,14 @@ ggc_add_tree_root (base, nelt)\n   ggc_add_root (base, nelt, sizeof(tree), ggc_mark_tree_ptr);\n }\n \n+void\n+ggc_add_string_root (base, nelt)\n+     char **base;\n+     int nelt;\n+{\n+  ggc_add_root (base, nelt, sizeof(char *), ggc_mark_string_ptr);\n+}\n+\n /* Add V (a varray full of trees) to the list of GC roots.  */\n \n void\n@@ -942,6 +951,16 @@ ggc_mark_tree_ptr (elt)\n   ggc_mark_tree (*(tree *)elt);\n }\n \n+/* Type-correct function to pass to ggc_add_root.  It just forwards\n+   ELT (which is really a char **) to ggc_mark_string.  */\n+\n+static void\n+ggc_mark_string_ptr (elt)\n+     void *elt;\n+{\n+  ggc_mark_string (*(char **)elt);\n+}\n+\n /* Type-correct function to pass to ggc_add_root.  It just forwards\n    ELT (which is really a varray_type *) to ggc_mark_tree_varray.  */\n "}, {"sha": "f2e6da384b0727b25fcff5e36706e102558b8bf2", "filename": "gcc/ggc.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76095e2f540a989ea6ff09bdce8d16c648ceca50/gcc%2Fggc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76095e2f540a989ea6ff09bdce8d16c648ceca50/gcc%2Fggc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc.h?ref=76095e2f540a989ea6ff09bdce8d16c648ceca50", "patch": "@@ -64,10 +64,10 @@ void *ggc_alloc PROTO ((size_t));\n void ggc_collect PROTO ((void));\n \n /* Manipulate global roots that are needed between calls to gc.  */\n-void ggc_add_root PROTO ((void *base, int nelt, int size,\n-\t\t\t   void (*)(void *)));\n+void ggc_add_root PROTO ((void *base, int nelt, int size, void (*)(void *)));\n void ggc_add_rtx_root PROTO ((struct rtx_def **, int nelt));\n void ggc_add_tree_root PROTO ((union tree_node **, int nelt));\n+void ggc_add_string_root PROTO ((char **, int nelt));\n void ggc_add_tree_varray_root PROTO ((struct varray_head_tag **, int nelt));\n void ggc_add_tree_hash_table_root PROTO ((struct hash_table **, int nelt));\n void ggc_del_root PROTO ((void *base));"}, {"sha": "8ac169fb36316a396fab8e8dc2733c9772cd0fb5", "filename": "gcc/loop.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76095e2f540a989ea6ff09bdce8d16c648ceca50/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76095e2f540a989ea6ff09bdce8d16c648ceca50/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=76095e2f540a989ea6ff09bdce8d16c648ceca50", "patch": "@@ -6000,6 +6000,7 @@ basic_induction_var (x, mode, dest_reg, p, inc_val, mult_val, location)\n   rtx insn, set = 0;\n \n   code = GET_CODE (x);\n+  *location = NULL_RTX;\n   switch (code)\n     {\n     case PLUS:"}, {"sha": "91e757b1da43ef049802d88337358698a24ead7a", "filename": "gcc/optabs.c", "status": "modified", "additions": 142, "deletions": 132, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76095e2f540a989ea6ff09bdce8d16c648ceca50/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76095e2f540a989ea6ff09bdce8d16c648ceca50/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=76095e2f540a989ea6ff09bdce8d16c648ceca50", "patch": "@@ -4308,7 +4308,7 @@ init_libfuncs (optable, first_mode, last_mode, opname, suffix)\n       register const char *mname = GET_MODE_NAME(mode);\n       register unsigned mname_len = strlen (mname);\n       register char *libfunc_name\n-\t= (char *) xmalloc (2 + opname_len + mname_len + 1 + 1);\n+\t= ggc_alloc_string (NULL, 2 + opname_len + mname_len + 1 + 1);\n       register char *p;\n       register const char *q;\n \n@@ -4321,6 +4321,7 @@ init_libfuncs (optable, first_mode, last_mode, opname, suffix)\n \t*p++ = tolower ((unsigned char)*q);\n       *p++ = suffix;\n       *p++ = '\\0';\n+\n       optable->handlers[(int) mode].libfunc\n \t= gen_rtx_SYMBOL_REF (Pmode, libfunc_name);\n     }\n@@ -4354,6 +4355,15 @@ init_floating_libfuncs (optable, opname, suffix)\n   init_libfuncs (optable, SFmode, TFmode, opname, suffix);\n }\n \n+rtx\n+init_one_libfunc (name)\n+     register const char *name;\n+{\n+  if (ggc_p)\n+    name = ggc_alloc_string (name, -1);\n+  return gen_rtx_SYMBOL_REF (Pmode, name);\n+}\n+\n /* Mark ARG (which is really an OPTAB *) for GC.  */\n \n void\n@@ -4511,189 +4521,189 @@ init_optabs ()\n \n #ifdef MULSI3_LIBCALL\n   smul_optab->handlers[(int) SImode].libfunc\n-    = gen_rtx_SYMBOL_REF (Pmode, MULSI3_LIBCALL);\n+    = init_one_libfunc (MULSI3_LIBCALL);\n #endif\n #ifdef MULDI3_LIBCALL\n   smul_optab->handlers[(int) DImode].libfunc\n-    = gen_rtx_SYMBOL_REF (Pmode, MULDI3_LIBCALL);\n+    = init_one_libfunc (MULDI3_LIBCALL);\n #endif\n \n #ifdef DIVSI3_LIBCALL\n   sdiv_optab->handlers[(int) SImode].libfunc\n-    = gen_rtx_SYMBOL_REF (Pmode, DIVSI3_LIBCALL);\n+    = init_one_libfunc (DIVSI3_LIBCALL);\n #endif\n #ifdef DIVDI3_LIBCALL\n   sdiv_optab->handlers[(int) DImode].libfunc\n-    = gen_rtx_SYMBOL_REF (Pmode, DIVDI3_LIBCALL);\n+    = init_one_libfunc (DIVDI3_LIBCALL);\n #endif\n \n #ifdef UDIVSI3_LIBCALL\n   udiv_optab->handlers[(int) SImode].libfunc\n-    = gen_rtx_SYMBOL_REF (Pmode, UDIVSI3_LIBCALL);\n+    = init_one_libfunc (UDIVSI3_LIBCALL);\n #endif\n #ifdef UDIVDI3_LIBCALL\n   udiv_optab->handlers[(int) DImode].libfunc\n-    = gen_rtx_SYMBOL_REF (Pmode, UDIVDI3_LIBCALL);\n+    = init_one_libfunc (UDIVDI3_LIBCALL);\n #endif\n \n #ifdef MODSI3_LIBCALL\n   smod_optab->handlers[(int) SImode].libfunc\n-    = gen_rtx_SYMBOL_REF (Pmode, MODSI3_LIBCALL);\n+    = init_one_libfunc (MODSI3_LIBCALL);\n #endif\n #ifdef MODDI3_LIBCALL\n   smod_optab->handlers[(int) DImode].libfunc\n-    = gen_rtx_SYMBOL_REF (Pmode, MODDI3_LIBCALL);\n+    = init_one_libfunc (MODDI3_LIBCALL);\n #endif\n \n #ifdef UMODSI3_LIBCALL\n   umod_optab->handlers[(int) SImode].libfunc\n-    = gen_rtx_SYMBOL_REF (Pmode, UMODSI3_LIBCALL);\n+    = init_one_libfunc (UMODSI3_LIBCALL);\n #endif\n #ifdef UMODDI3_LIBCALL\n   umod_optab->handlers[(int) DImode].libfunc\n-    = gen_rtx_SYMBOL_REF (Pmode, UMODDI3_LIBCALL);\n+    = init_one_libfunc (UMODDI3_LIBCALL);\n #endif\n \n   /* Use cabs for DC complex abs, since systems generally have cabs.\n      Don't define any libcall for SCmode, so that cabs will be used.  */\n   abs_optab->handlers[(int) DCmode].libfunc\n-    = gen_rtx_SYMBOL_REF (Pmode, \"cabs\");\n+    = init_one_libfunc (\"cabs\");\n \n   /* The ffs function operates on `int'.  */\n #ifndef INT_TYPE_SIZE\n #define INT_TYPE_SIZE BITS_PER_WORD\n #endif\n   ffs_optab->handlers[(int) mode_for_size (INT_TYPE_SIZE, MODE_INT, 0)].libfunc\n-    = gen_rtx_SYMBOL_REF (Pmode, \"ffs\");\n-\n-  extendsfdf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__extendsfdf2\");\n-  extendsfxf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__extendsfxf2\");\n-  extendsftf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__extendsftf2\");\n-  extenddfxf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__extenddfxf2\");\n-  extenddftf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__extenddftf2\");\n-\n-  truncdfsf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__truncdfsf2\");\n-  truncxfsf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__truncxfsf2\");\n-  trunctfsf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__trunctfsf2\");\n-  truncxfdf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__truncxfdf2\");\n-  trunctfdf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__trunctfdf2\");\n-\n-  memcpy_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"memcpy\");\n-  bcopy_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"bcopy\");\n-  memcmp_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"memcmp\");\n-  bcmp_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__gcc_bcmp\");\n-  memset_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"memset\");\n-  bzero_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"bzero\");\n-\n-  throw_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__throw\");\n-  rethrow_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__rethrow\");\n-  sjthrow_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__sjthrow\");\n-  sjpopnthrow_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__sjpopnthrow\");\n-  terminate_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__terminate\");\n-  eh_rtime_match_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__eh_rtime_match\");\n+    = init_one_libfunc (\"ffs\");\n+\n+  extendsfdf2_libfunc = init_one_libfunc (\"__extendsfdf2\");\n+  extendsfxf2_libfunc = init_one_libfunc (\"__extendsfxf2\");\n+  extendsftf2_libfunc = init_one_libfunc (\"__extendsftf2\");\n+  extenddfxf2_libfunc = init_one_libfunc (\"__extenddfxf2\");\n+  extenddftf2_libfunc = init_one_libfunc (\"__extenddftf2\");\n+\n+  truncdfsf2_libfunc = init_one_libfunc (\"__truncdfsf2\");\n+  truncxfsf2_libfunc = init_one_libfunc (\"__truncxfsf2\");\n+  trunctfsf2_libfunc = init_one_libfunc (\"__trunctfsf2\");\n+  truncxfdf2_libfunc = init_one_libfunc (\"__truncxfdf2\");\n+  trunctfdf2_libfunc = init_one_libfunc (\"__trunctfdf2\");\n+\n+  memcpy_libfunc = init_one_libfunc (\"memcpy\");\n+  bcopy_libfunc = init_one_libfunc (\"bcopy\");\n+  memcmp_libfunc = init_one_libfunc (\"memcmp\");\n+  bcmp_libfunc = init_one_libfunc (\"__gcc_bcmp\");\n+  memset_libfunc = init_one_libfunc (\"memset\");\n+  bzero_libfunc = init_one_libfunc (\"bzero\");\n+\n+  throw_libfunc = init_one_libfunc (\"__throw\");\n+  rethrow_libfunc = init_one_libfunc (\"__rethrow\");\n+  sjthrow_libfunc = init_one_libfunc (\"__sjthrow\");\n+  sjpopnthrow_libfunc = init_one_libfunc (\"__sjpopnthrow\");\n+  terminate_libfunc = init_one_libfunc (\"__terminate\");\n+  eh_rtime_match_libfunc = init_one_libfunc (\"__eh_rtime_match\");\n #ifndef DONT_USE_BUILTIN_SETJMP\n-  setjmp_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__builtin_setjmp\");\n-  longjmp_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__builtin_longjmp\");\n+  setjmp_libfunc = init_one_libfunc (\"__builtin_setjmp\");\n+  longjmp_libfunc = init_one_libfunc (\"__builtin_longjmp\");\n #else\n-  setjmp_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"setjmp\");\n-  longjmp_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"longjmp\");\n+  setjmp_libfunc = init_one_libfunc (\"setjmp\");\n+  longjmp_libfunc = init_one_libfunc (\"longjmp\");\n #endif\n \n-  eqhf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__eqhf2\");\n-  nehf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__nehf2\");\n-  gthf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__gthf2\");\n-  gehf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__gehf2\");\n-  lthf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__lthf2\");\n-  lehf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__lehf2\");\n-\n-  eqsf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__eqsf2\");\n-  nesf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__nesf2\");\n-  gtsf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__gtsf2\");\n-  gesf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__gesf2\");\n-  ltsf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__ltsf2\");\n-  lesf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__lesf2\");\n-\n-  eqdf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__eqdf2\");\n-  nedf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__nedf2\");\n-  gtdf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__gtdf2\");\n-  gedf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__gedf2\");\n-  ltdf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__ltdf2\");\n-  ledf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__ledf2\");\n-\n-  eqxf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__eqxf2\");\n-  nexf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__nexf2\");\n-  gtxf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__gtxf2\");\n-  gexf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__gexf2\");\n-  ltxf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__ltxf2\");\n-  lexf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__lexf2\");\n-\n-  eqtf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__eqtf2\");\n-  netf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__netf2\");\n-  gttf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__gttf2\");\n-  getf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__getf2\");\n-  lttf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__lttf2\");\n-  letf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__letf2\");\n-\n-  floatsisf_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__floatsisf\");\n-  floatdisf_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__floatdisf\");\n-  floattisf_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__floattisf\");\n-\n-  floatsidf_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__floatsidf\");\n-  floatdidf_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__floatdidf\");\n-  floattidf_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__floattidf\");\n-\n-  floatsixf_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__floatsixf\");\n-  floatdixf_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__floatdixf\");\n-  floattixf_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__floattixf\");\n-\n-  floatsitf_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__floatsitf\");\n-  floatditf_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__floatditf\");\n-  floattitf_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__floattitf\");\n-\n-  fixsfsi_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__fixsfsi\");\n-  fixsfdi_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__fixsfdi\");\n-  fixsfti_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__fixsfti\");\n-\n-  fixdfsi_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__fixdfsi\");\n-  fixdfdi_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__fixdfdi\");\n-  fixdfti_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__fixdfti\");\n-\n-  fixxfsi_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__fixxfsi\");\n-  fixxfdi_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__fixxfdi\");\n-  fixxfti_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__fixxfti\");\n-\n-  fixtfsi_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__fixtfsi\");\n-  fixtfdi_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__fixtfdi\");\n-  fixtfti_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__fixtfti\");\n-\n-  fixunssfsi_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__fixunssfsi\");\n-  fixunssfdi_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__fixunssfdi\");\n-  fixunssfti_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__fixunssfti\");\n-\n-  fixunsdfsi_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__fixunsdfsi\");\n-  fixunsdfdi_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__fixunsdfdi\");\n-  fixunsdfti_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__fixunsdfti\");\n-\n-  fixunsxfsi_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__fixunsxfsi\");\n-  fixunsxfdi_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__fixunsxfdi\");\n-  fixunsxfti_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__fixunsxfti\");\n-\n-  fixunstfsi_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__fixunstfsi\");\n-  fixunstfdi_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__fixunstfdi\");\n-  fixunstfti_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__fixunstfti\");\n+  eqhf2_libfunc = init_one_libfunc (\"__eqhf2\");\n+  nehf2_libfunc = init_one_libfunc (\"__nehf2\");\n+  gthf2_libfunc = init_one_libfunc (\"__gthf2\");\n+  gehf2_libfunc = init_one_libfunc (\"__gehf2\");\n+  lthf2_libfunc = init_one_libfunc (\"__lthf2\");\n+  lehf2_libfunc = init_one_libfunc (\"__lehf2\");\n+\n+  eqsf2_libfunc = init_one_libfunc (\"__eqsf2\");\n+  nesf2_libfunc = init_one_libfunc (\"__nesf2\");\n+  gtsf2_libfunc = init_one_libfunc (\"__gtsf2\");\n+  gesf2_libfunc = init_one_libfunc (\"__gesf2\");\n+  ltsf2_libfunc = init_one_libfunc (\"__ltsf2\");\n+  lesf2_libfunc = init_one_libfunc (\"__lesf2\");\n+\n+  eqdf2_libfunc = init_one_libfunc (\"__eqdf2\");\n+  nedf2_libfunc = init_one_libfunc (\"__nedf2\");\n+  gtdf2_libfunc = init_one_libfunc (\"__gtdf2\");\n+  gedf2_libfunc = init_one_libfunc (\"__gedf2\");\n+  ltdf2_libfunc = init_one_libfunc (\"__ltdf2\");\n+  ledf2_libfunc = init_one_libfunc (\"__ledf2\");\n+\n+  eqxf2_libfunc = init_one_libfunc (\"__eqxf2\");\n+  nexf2_libfunc = init_one_libfunc (\"__nexf2\");\n+  gtxf2_libfunc = init_one_libfunc (\"__gtxf2\");\n+  gexf2_libfunc = init_one_libfunc (\"__gexf2\");\n+  ltxf2_libfunc = init_one_libfunc (\"__ltxf2\");\n+  lexf2_libfunc = init_one_libfunc (\"__lexf2\");\n+\n+  eqtf2_libfunc = init_one_libfunc (\"__eqtf2\");\n+  netf2_libfunc = init_one_libfunc (\"__netf2\");\n+  gttf2_libfunc = init_one_libfunc (\"__gttf2\");\n+  getf2_libfunc = init_one_libfunc (\"__getf2\");\n+  lttf2_libfunc = init_one_libfunc (\"__lttf2\");\n+  letf2_libfunc = init_one_libfunc (\"__letf2\");\n+\n+  floatsisf_libfunc = init_one_libfunc (\"__floatsisf\");\n+  floatdisf_libfunc = init_one_libfunc (\"__floatdisf\");\n+  floattisf_libfunc = init_one_libfunc (\"__floattisf\");\n+\n+  floatsidf_libfunc = init_one_libfunc (\"__floatsidf\");\n+  floatdidf_libfunc = init_one_libfunc (\"__floatdidf\");\n+  floattidf_libfunc = init_one_libfunc (\"__floattidf\");\n+\n+  floatsixf_libfunc = init_one_libfunc (\"__floatsixf\");\n+  floatdixf_libfunc = init_one_libfunc (\"__floatdixf\");\n+  floattixf_libfunc = init_one_libfunc (\"__floattixf\");\n+\n+  floatsitf_libfunc = init_one_libfunc (\"__floatsitf\");\n+  floatditf_libfunc = init_one_libfunc (\"__floatditf\");\n+  floattitf_libfunc = init_one_libfunc (\"__floattitf\");\n+\n+  fixsfsi_libfunc = init_one_libfunc (\"__fixsfsi\");\n+  fixsfdi_libfunc = init_one_libfunc (\"__fixsfdi\");\n+  fixsfti_libfunc = init_one_libfunc (\"__fixsfti\");\n+\n+  fixdfsi_libfunc = init_one_libfunc (\"__fixdfsi\");\n+  fixdfdi_libfunc = init_one_libfunc (\"__fixdfdi\");\n+  fixdfti_libfunc = init_one_libfunc (\"__fixdfti\");\n+\n+  fixxfsi_libfunc = init_one_libfunc (\"__fixxfsi\");\n+  fixxfdi_libfunc = init_one_libfunc (\"__fixxfdi\");\n+  fixxfti_libfunc = init_one_libfunc (\"__fixxfti\");\n+\n+  fixtfsi_libfunc = init_one_libfunc (\"__fixtfsi\");\n+  fixtfdi_libfunc = init_one_libfunc (\"__fixtfdi\");\n+  fixtfti_libfunc = init_one_libfunc (\"__fixtfti\");\n+\n+  fixunssfsi_libfunc = init_one_libfunc (\"__fixunssfsi\");\n+  fixunssfdi_libfunc = init_one_libfunc (\"__fixunssfdi\");\n+  fixunssfti_libfunc = init_one_libfunc (\"__fixunssfti\");\n+\n+  fixunsdfsi_libfunc = init_one_libfunc (\"__fixunsdfsi\");\n+  fixunsdfdi_libfunc = init_one_libfunc (\"__fixunsdfdi\");\n+  fixunsdfti_libfunc = init_one_libfunc (\"__fixunsdfti\");\n+\n+  fixunsxfsi_libfunc = init_one_libfunc (\"__fixunsxfsi\");\n+  fixunsxfdi_libfunc = init_one_libfunc (\"__fixunsxfdi\");\n+  fixunsxfti_libfunc = init_one_libfunc (\"__fixunsxfti\");\n+\n+  fixunstfsi_libfunc = init_one_libfunc (\"__fixunstfsi\");\n+  fixunstfdi_libfunc = init_one_libfunc (\"__fixunstfdi\");\n+  fixunstfti_libfunc = init_one_libfunc (\"__fixunstfti\");\n \n   /* For check-memory-usage.  */\n-  chkr_check_addr_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"chkr_check_addr\");\n-  chkr_set_right_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"chkr_set_right\");\n-  chkr_copy_bitmap_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"chkr_copy_bitmap\");\n-  chkr_check_exec_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"chkr_check_exec\");\n-  chkr_check_str_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"chkr_check_str\");\n+  chkr_check_addr_libfunc = init_one_libfunc (\"chkr_check_addr\");\n+  chkr_set_right_libfunc = init_one_libfunc (\"chkr_set_right\");\n+  chkr_copy_bitmap_libfunc = init_one_libfunc (\"chkr_copy_bitmap\");\n+  chkr_check_exec_libfunc = init_one_libfunc (\"chkr_check_exec\");\n+  chkr_check_str_libfunc = init_one_libfunc (\"chkr_check_str\");\n \n   /* For function entry/exit instrumentation.  */\n   profile_function_entry_libfunc\n-    = gen_rtx_SYMBOL_REF (Pmode, \"__cyg_profile_func_enter\");\n+    = init_one_libfunc (\"__cyg_profile_func_enter\");\n   profile_function_exit_libfunc\n-    = gen_rtx_SYMBOL_REF (Pmode, \"__cyg_profile_func_exit\");\n+    = init_one_libfunc (\"__cyg_profile_func_exit\");\n \n #ifdef HAVE_conditional_trap\n   init_traps ();"}, {"sha": "be81bebe6dbb9a1455ea1d32e51b88a4d61844eb", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76095e2f540a989ea6ff09bdce8d16c648ceca50/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76095e2f540a989ea6ff09bdce8d16c648ceca50/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=76095e2f540a989ea6ff09bdce8d16c648ceca50", "patch": "@@ -1652,6 +1652,7 @@ extern int set_dominates_use\t\tPROTO ((int, int, int, rtx, rtx));\n extern void bss_section\t\t\tPROTO ((void));\n extern int in_data_section\t\tPROTO ((void));\n extern int supports_one_only\t\tPROTO ((void));\n+extern void init_varasm_once\t\tPROTO ((void));\n \n /* In rtl.c */\n extern void init_rtl\t\t\tPROTO ((void));"}, {"sha": "f104e85db256719876f5c85de081ef630c2acff0", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76095e2f540a989ea6ff09bdce8d16c648ceca50/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76095e2f540a989ea6ff09bdce8d16c648ceca50/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=76095e2f540a989ea6ff09bdce8d16c648ceca50", "patch": "@@ -2893,6 +2893,7 @@ compile_file (name)\n   init_alias_once ();\n   init_function_once ();\n   init_stor_layout_once ();\n+  init_varasm_once ();\n \n   /* The following initialization functions need to generate rtl, so\n      provide a dummy function context for them.  */"}, {"sha": "887fc787c3421c69b0e645e8ddb8ce1de965d11a", "filename": "gcc/varasm.c", "status": "modified", "additions": 62, "deletions": 32, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76095e2f540a989ea6ff09bdce8d16c648ceca50/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76095e2f540a989ea6ff09bdce8d16c648ceca50/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=76095e2f540a989ea6ff09bdce8d16c648ceca50", "patch": "@@ -187,6 +187,7 @@ static void asm_output_aligned_bss\tPROTO((FILE *, tree, char *, int, int));\n #endif\n #endif /* BSS_SECTION_ASM_OP */\n static void mark_pool_constant          PROTO((struct pool_constant *));\n+static void mark_pool_sym_hash_table\tPROTO((struct pool_sym **));\n \f\n static enum in_section { no_section, in_text, in_data, in_named\n #ifdef BSS_SECTION_ASM_OP\n@@ -313,8 +314,7 @@ named_section (decl, name, reloc)\n       abort ();\n #endif\n \n-      in_named_name = obstack_alloc (&permanent_obstack, strlen (name) + 1);\n-      strcpy (in_named_name, name);\n+      in_named_name = ggc_alloc_string (name, -1);\n       in_section = in_named;\n     }\n }\n@@ -528,7 +528,7 @@ make_function_rtl (decl)\n \n       name = IDENTIFIER_POINTER (DECL_NAME (decl));\n       ASM_FORMAT_PRIVATE_NAME (label, name, var_labelno);\n-      name = obstack_copy0 (saveable_obstack, label, strlen (label));\n+      name = ggc_alloc_string (label, -1);\n       var_labelno++;\n     }\n   else\n@@ -539,10 +539,12 @@ make_function_rtl (decl)\n          is not prefixed.  */\n       if (flag_prefix_function_name)\n         {\n-          new_name = (char *) alloca (strlen (name) + CHKR_PREFIX_SIZE + 1);\n-          strcpy (new_name, CHKR_PREFIX);\n-          strcpy (new_name + CHKR_PREFIX_SIZE, name);\n-          name = obstack_copy0 (saveable_obstack, new_name, strlen (new_name));\n+\t  size_t name_len = strlen (name);\n+\n+          new_name = ggc_alloc_string (NULL, name_len + CHKR_PREFIX_SIZE);\n+\t  memcpy (new_name, CHKR_PREFIX, CHKR_PREFIX_SIZE);\n+\t  memcpy (new_name + CHKR_PREFIX_SIZE, name, name_len + 1);\n+          name = new_name;\n         }\n     }\n \n@@ -678,10 +680,11 @@ make_decl_rtl (decl, asmspec, top_level)\n   if (reg_number == -2)\n     {\n       /* ASMSPEC is given, and not the name of a register.  */\n-      name = (char *) obstack_alloc (saveable_obstack,\n-\t\t\t\t     strlen (asmspec) + 2);\n+      size_t len = strlen (asmspec);\n+\n+      name = ggc_alloc_string (NULL, len + 1);\n       name[0] = '*';\n-      strcpy (&name[1], asmspec);\n+      memcpy (&name[1], asmspec, len + 1);\n     }\n \n   /* For a duplicate declaration, we can be called twice on the\n@@ -771,7 +774,7 @@ make_decl_rtl (decl, asmspec, top_level)\n \t      char *label;\n \n \t      ASM_FORMAT_PRIVATE_NAME (label, name, var_labelno);\n-\t      name = obstack_copy0 (saveable_obstack, label, strlen (label));\n+\t      name = ggc_alloc_string (label, -1);\n \t      var_labelno++;\n \t    }\n \n@@ -783,13 +786,13 @@ make_decl_rtl (decl, asmspec, top_level)\n \t     prefixed.  */\n \t  if (flag_prefix_function_name && TREE_CODE (decl) == FUNCTION_DECL)\n \t    {\n+\t      size_t name_len = strlen (name);\n \t      char *new_name;\n-\t      new_name = (char *) alloca (strlen (name) + CHKR_PREFIX_SIZE \n-\t      \t\t\t\t  + 1);\n-\t      strcpy (new_name, CHKR_PREFIX);\n-\t      strcpy (new_name + CHKR_PREFIX_SIZE, name);\n-\t      name = obstack_copy0 (saveable_obstack,\n-\t      \t\t\t   new_name, strlen (new_name));\n+\n+\t      new_name = ggc_alloc_string (NULL, name_len + CHKR_PREFIX_SIZE);\n+\t      memcpy (new_name, CHKR_PREFIX, CHKR_PREFIX_SIZE);\n+\t      memcpy (new_name + CHKR_PREFIX_SIZE, name, name_len + 1);\n+\t      name = new_name;\n \t    }\n \n \t  DECL_RTL (decl) = gen_rtx_MEM (DECL_MODE (decl),\n@@ -1770,10 +1773,7 @@ assemble_static_space (size)\n \n   ASM_GENERATE_INTERNAL_LABEL (name, \"LF\", const_labelno);\n   ++const_labelno;\n-\n-  namestring = (char *) obstack_alloc (saveable_obstack,\n-\t\t\t\t       strlen (name) + 2);\n-  strcpy (namestring, name);\n+  namestring = ggc_alloc_string (name, -1);\n \n   x = gen_rtx_SYMBOL_REF (Pmode, namestring);\n \n@@ -1829,8 +1829,7 @@ assemble_trampoline_template ()\n \n   /* Record the rtl to refer to it.  */\n   ASM_GENERATE_INTERNAL_LABEL (label, \"LTRAMP\", 0);\n-  name\n-    = (char *) obstack_copy0 (&permanent_obstack, label, strlen (label));\n+  name = ggc_alloc_string (label, -1);\n   return gen_rtx_SYMBOL_REF (Pmode, name);\n }\n #endif\n@@ -2304,6 +2303,21 @@ struct constant_descriptor\n #define MAX_HASH_TABLE 1009\n static struct constant_descriptor *const_hash_table[MAX_HASH_TABLE];\n \n+/* Mark a const_hash_table descriptor for GC.  */\n+\n+static void \n+mark_const_hash_entry (ptr)\n+     void *ptr;\n+{\n+  struct constant_descriptor *desc = * (struct constant_descriptor **) ptr;\n+\n+  while (desc)\n+    {\n+      ggc_mark_string (desc->label);\n+      desc = desc->next;\n+    }\n+}\n+\n /* Compute a hash code for a constant expression.  */\n \n static int\n@@ -3003,15 +3017,9 @@ output_constant_def (exp)\n \n       desc = record_constant (exp);\n       desc->next = const_hash_table[hash];\n-      desc->label\n-\t= (char *) obstack_copy0 (&permanent_obstack, label, strlen (label));\n+      desc->label = ggc_alloc_string (label, -1);\n       const_hash_table[hash] = desc;\n     }\n-  else\n-    {\n-      /* Create a string containing the label name, in LABEL.  */\n-      ASM_GENERATE_INTERNAL_LABEL (label, \"LC\", const_labelno);\n-    }\n   \n   /* We have a symbol name; construct the SYMBOL_REF and the MEM.  */\n \n@@ -3200,13 +3208,28 @@ mark_pool_constant (pc)\n     }\n }\n \n+/* Mark PPS for GC.  */\n+\n+static void\n+mark_pool_sym_hash_table (pps)\n+     struct pool_sym **pps;\n+{\n+  struct pool_sym *ps;\n+  int i;\n+\n+  for (i = 0; i < MAX_RTX_HASH_TABLE; ++i)\n+    for (ps = pps[i]; ps ; ps = ps->next)\n+      ggc_mark_string (ps->label);\n+}\n+\n /* Mark P for GC.  */\n \n void\n mark_varasm_state (p)\n   struct varasm_status *p;\n {\n   mark_pool_constant (p->x_first_pool);\n+  mark_pool_sym_hash_table (p->x_const_rtx_sym_hash_table);\n   ggc_mark_rtx (p->x_const_double_chain);\n }\n \n@@ -3548,8 +3571,7 @@ force_const_mem (mode, x)\n \n       ++const_labelno;\n \n-      desc->label = found\n-\t= (char *) obstack_copy0 (saveable_obstack, label, strlen (label));\n+      desc->label = found = ggc_alloc_string (label, -1);\n \n       /* Add label to symbol hash table.  */\n       hash = SYMHASH (found);\n@@ -4538,3 +4560,11 @@ make_decl_one_only (decl)\n   else\n     abort ();\n }\n+\n+void\n+init_varasm_once ()\n+{\n+  ggc_add_root (const_hash_table, MAX_HASH_TABLE, sizeof(const_hash_table[0]),\n+\t\tmark_const_hash_entry);\n+  ggc_add_string_root (&in_named_name, 1);\n+}"}]}