{"sha": "cc1446556229298c9ab0d0e502f9298a23042c61", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2MxNDQ2NTU2MjI5Mjk4YzlhYjBkMGU1MDJmOTI5OGEyMzA0MmM2MQ==", "commit": {"author": {"name": "Gavin Romig-Koch", "email": "gavin@cygnus.com", "date": "1999-07-21T12:48:13Z"}, "committer": {"name": "Gavin Romig-Koch", "email": "gavin@gcc.gnu.org", "date": "1999-07-21T12:48:13Z"}, "message": "For gcc:\n\n\t* c-lex.c (yylex) : Correct the test for overflow when lexing\n\tinteger literals.\n\nFor gcc/cp:\n\t* lex.c (real_yylex) : Correct the test for overflow when lexing\n\tinteger literals.\n\nFrom-SVN: r28206", "tree": {"sha": "18a978b65c1955538288e08abc9951fe096952c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/18a978b65c1955538288e08abc9951fe096952c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc1446556229298c9ab0d0e502f9298a23042c61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc1446556229298c9ab0d0e502f9298a23042c61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc1446556229298c9ab0d0e502f9298a23042c61", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc1446556229298c9ab0d0e502f9298a23042c61/comments", "author": null, "committer": null, "parents": [{"sha": "0f03776326098b582ff036d3f76ad2bda47850db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f03776326098b582ff036d3f76ad2bda47850db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f03776326098b582ff036d3f76ad2bda47850db"}], "stats": {"total": 100, "additions": 63, "deletions": 37}, "files": [{"sha": "efe62f95fbc8f0330240e6710b3978229bc906d5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc1446556229298c9ab0d0e502f9298a23042c61/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc1446556229298c9ab0d0e502f9298a23042c61/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cc1446556229298c9ab0d0e502f9298a23042c61", "patch": "@@ -1,3 +1,8 @@\n+Wed Jul 21 08:39:22 1999  Gavin Romig-Koch  <gavin@cygnus.com>\n+\n+\t* c-lex.c (yylex) : Correct the test for overflow when lexing\n+\tinteger literals.\n+\n Tue Jul 20 18:02:42 1999  Richard Henderson  <rth@cygnus.com>\n \n \t* haifa-sched.c (insn_cost): FREE implies cost 0 and vice versa."}, {"sha": "52387f883e5955cfdadc4e324996d595572a67ba", "filename": "gcc/c-lex.c", "status": "modified", "additions": 27, "deletions": 19, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc1446556229298c9ab0d0e502f9298a23042c61/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc1446556229298c9ab0d0e502f9298a23042c61/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=cc1446556229298c9ab0d0e502f9298a23042c61", "patch": "@@ -1477,16 +1477,19 @@ yylex ()\n \tint count = 0;\n \tint largest_digit = 0;\n \tint numdigits = 0;\n-\t/* for multi-precision arithmetic,\n-\t   we actually store only HOST_BITS_PER_CHAR bits in each part.\n-\t   The number of parts is chosen so as to be sufficient to hold\n-\t   the enough bits to fit into the two HOST_WIDE_INTs that contain\n-\t   the integer value (this is always at least as many bits as are\n-\t   in a target `long long' value, but may be wider).  */\n-#define TOTAL_PARTS ((HOST_BITS_PER_WIDE_INT / HOST_BITS_PER_CHAR) * 2 + 2)\n-\tint parts[TOTAL_PARTS];\n \tint overflow = 0;\n \n+\t/* We actually store only HOST_BITS_PER_CHAR bits in each part.\n+\t   The code below which fills the parts array assumes that a host\n+\t   int is at least twice as wide as a host char, and that \n+\t   HOST_BITS_PER_WIDE_INT is an even multiple of HOST_BITS_PER_CHAR.\n+\t   Two HOST_WIDE_INTs is the largest int literal we can store.\n+\t   In order to detect overflow below, the number of parts (TOTAL_PARTS)\n+\t   must be exactly the number of parts needed to hold the bits\n+\t   of two HOST_WIDE_INTs. */\n+#define TOTAL_PARTS ((HOST_BITS_PER_WIDE_INT / HOST_BITS_PER_CHAR) * 2)\n+\tunsigned int parts[TOTAL_PARTS];\n+\n \tenum anon1 { NOT_FLOAT, AFTER_POINT, TOO_MANY_POINTS, AFTER_EXPON}\n \t  floatflag = NOT_FLOAT;\n \n@@ -1616,11 +1619,16 @@ yylex ()\n \t\t    else\n \t\t      parts[0] += c;\n \t\t  }\n-\n-\t\t/* If the extra highest-order part ever gets anything in it,\n-\t\t   the number is certainly too big.  */\n-\t\tif (parts[TOTAL_PARTS - 1] != 0)\n-\t\t  overflow = 1;\n+\t\t\n+\t\t/* If the highest-order part overflows (gets larger than\n+\t\t   a host char will hold) then the whole number has \n+\t\t   overflowed.  Record this and truncate the highest-order\n+\t\t   part. */\n+\t\tif (parts[TOTAL_PARTS - 1] >> HOST_BITS_PER_CHAR)\n+\t\t  {\n+\t\t    overflow = 1;\n+\t\t    parts[TOTAL_PARTS - 1] &= (1 << HOST_BITS_PER_CHAR) - 1;\n+\t\t  }\n \n \t\tif (p >= token_buffer + maxtoken - 3)\n \t\t  p = extend_token_buffer (p);\n@@ -1772,12 +1780,12 @@ yylex ()\n \t\tc = GETC();\n \t      }\n \n-\t    /* If it won't fit in the host's representation for integers,\n-\t       then pedwarn. */\n-\n-\t    warn = overflow;\n-\t    if (warn)\n-\t      pedwarn (\"integer constant is too large for this configuration of the compiler - truncated to %d bits\", HOST_BITS_PER_WIDE_INT * 2);\n+\t    /* If the literal overflowed, pedwarn about it now. */\n+\t    if (overflow)\n+\t      {\n+\t\twarn = 1;\n+\t\tpedwarn (\"integer constant is too large for this configuration of the compiler - truncated to %d bits\", HOST_BITS_PER_WIDE_INT * 2);\n+\t      }\n \n \t    /* This is simplified by the fact that our constant\n \t       is always positive.  */"}, {"sha": "d5d2fa1fd6b084726c4ce2466ed7a1f00c0d2e57", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc1446556229298c9ab0d0e502f9298a23042c61/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc1446556229298c9ab0d0e502f9298a23042c61/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=cc1446556229298c9ab0d0e502f9298a23042c61", "patch": "@@ -1,3 +1,8 @@\n+1999-07-21  Gavin Romig-Koch  <gavin@cygnus.com>\n+\n+\t* lex.c (real_yylex) : Correct the test for overflow when lexing\n+\tinteger literals.\n+\n 1999-07-20  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* decl.c (warn_extern_redeclared_static): Check DECL_ARTIFICIAL,"}, {"sha": "a656ac4bd9e31ceb411272c0a5533eaaf9f6884f", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc1446556229298c9ab0d0e502f9298a23042c61/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc1446556229298c9ab0d0e502f9298a23042c61/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=cc1446556229298c9ab0d0e502f9298a23042c61", "patch": "@@ -3578,16 +3578,19 @@ real_yylex ()\n \tint count = 0;\n \tint largest_digit = 0;\n \tint numdigits = 0;\n-\t/* for multi-precision arithmetic,\n-\t   we actually store only HOST_BITS_PER_CHAR bits in each part.\n-\t   The number of parts is chosen so as to be sufficient to hold\n-\t   the enough bits to fit into the two HOST_WIDE_INTs that contain\n-\t   the integer value (this is always at least as many bits as are\n-\t   in a target `long long' value, but may be wider).  */\n-#define TOTAL_PARTS ((HOST_BITS_PER_WIDE_INT / HOST_BITS_PER_CHAR) * 2 + 2)\n-\tint parts[TOTAL_PARTS];\n \tint overflow = 0;\n \n+\t/* We actually store only HOST_BITS_PER_CHAR bits in each part.\n+\t   The code below which fills the parts array assumes that a host\n+\t   int is at least twice as wide as a host char, and that \n+\t   HOST_BITS_PER_WIDE_INT is an even multiple of HOST_BITS_PER_CHAR.\n+\t   Two HOST_WIDE_INTs is the largest int literal we can store.\n+\t   In order to detect overflow below, the number of parts (TOTAL_PARTS)\n+\t   must be exactly the number of parts needed to hold the bits\n+\t   of two HOST_WIDE_INTs. */\n+#define TOTAL_PARTS ((HOST_BITS_PER_WIDE_INT / HOST_BITS_PER_CHAR) * 2)\n+\tunsigned int parts[TOTAL_PARTS];\n+\n \tenum anon1 { NOT_FLOAT, AFTER_POINT, TOO_MANY_POINTS} floatflag\n \t  = NOT_FLOAT;\n \n@@ -3694,10 +3697,15 @@ real_yylex ()\n \t\t      parts[0] += c;\n \t\t  }\n \n-\t\t/* If the extra highest-order part ever gets anything in it,\n-\t\t   the number is certainly too big.  */\n-\t\tif (parts[TOTAL_PARTS - 1] != 0)\n-\t\t  overflow = 1;\n+\t\t/* If the highest-order part overflows (gets larger than\n+\t\t   a host char will hold) then the whole number has \n+\t\t   overflowed.  Record this and truncate the highest-order\n+\t\t   part. */\n+\t\tif (parts[TOTAL_PARTS - 1] >> HOST_BITS_PER_CHAR)\n+\t\t  {\n+\t\t    overflow = 1;\n+\t\t    parts[TOTAL_PARTS - 1] &= (1 << HOST_BITS_PER_CHAR) - 1;\n+\t\t  }\n \n \t\tif (p >= token_buffer + maxtoken - 3)\n \t\t  p = extend_token_buffer (p);\n@@ -3850,12 +3858,12 @@ real_yylex ()\n \t\tc = token_getch ();\n \t      }\n \n-\t    /* If it won't fit in the host's representation for integers,\n-\t       then pedwarn. */\n-\n-\t    warn = overflow;\n-\t    if (warn)\n-\t      pedwarn (\"integer constant is too large for this configuration of the compiler - truncated to %d bits\", HOST_BITS_PER_WIDE_INT * 2);\n+\t    /* If the literal overflowed, pedwarn about it now. */\n+\t    if (overflow)\n+\t      {\n+\t\twarn = 1;\n+\t\tpedwarn (\"integer constant is too large for this configuration of the compiler - truncated to %d bits\", HOST_BITS_PER_WIDE_INT * 2);\n+\t      }\n \n \t    /* This is simplified by the fact that our constant\n \t       is always positive.  */"}]}