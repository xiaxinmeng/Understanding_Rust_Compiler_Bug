{"sha": "f81497d9055fc3635140c6d6ecaf00f06a5509a1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjgxNDk3ZDkwNTVmYzM2MzUxNDBjNmQ2ZWNhZjAwZjA2YTU1MDlhMQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-03-29T08:23:24Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-03-29T08:23:24Z"}, "message": "(expand_expr, case MAX_EXPR/MIN_EXPR): If mode is multiword int,\n\nuse do_jump_by_parts_greater_rtx to compare efficiently.\n(do_jump_by_parts_greater_rtx): New function.\n\nFrom-SVN: r3909", "tree": {"sha": "60e74e6a1918df70fe8de59c91fef9927176ef65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/60e74e6a1918df70fe8de59c91fef9927176ef65"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f81497d9055fc3635140c6d6ecaf00f06a5509a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f81497d9055fc3635140c6d6ecaf00f06a5509a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f81497d9055fc3635140c6d6ecaf00f06a5509a1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f81497d9055fc3635140c6d6ecaf00f06a5509a1/comments", "author": null, "committer": null, "parents": [{"sha": "42f00318aba3341cfb48acf57c0d5d6718554344", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42f00318aba3341cfb48acf57c0d5d6718554344", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42f00318aba3341cfb48acf57c0d5d6718554344"}], "stats": {"total": 106, "additions": 92, "deletions": 14}, "files": [{"sha": "f3c1c767eeaf367996d16375184f54f43bb87f2a", "filename": "gcc/expr.c", "status": "modified", "additions": 92, "deletions": 14, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f81497d9055fc3635140c6d6ecaf00f06a5509a1/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f81497d9055fc3635140c6d6ecaf00f06a5509a1/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=f81497d9055fc3635140c6d6ecaf00f06a5509a1", "patch": "@@ -139,6 +139,7 @@ static void expand_builtin_return PROTO((rtx));\n static rtx expand_increment\tPROTO((tree, int));\n static void preexpand_calls\tPROTO((tree));\n static void do_jump_by_parts_greater PROTO((tree, int, rtx, rtx));\n+static void do_jump_by_parts_greater_rtx PROTO((enum machine_mode, int, rtx, rtx, rtx, rtx));\n static void do_jump_by_parts_equality PROTO((tree, rtx, rtx));\n static void do_jump_by_parts_equality_rtx PROTO((rtx, rtx, rtx));\n static void do_jump_for_compare\tPROTO((rtx, rtx, rtx));\n@@ -4577,24 +4578,38 @@ expand_expr (exp, target, tmode, modifier)\n       if (target != op0)\n \temit_move_insn (target, op0);\n       op0 = gen_label_rtx ();\n-      if (code == MAX_EXPR)\n-\ttemp = (TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 1)))\n-\t\t? compare_from_rtx (target, op1, GEU, 1, mode, NULL_RTX, 0)\n-\t\t: compare_from_rtx (target, op1, GE, 0, mode, NULL_RTX, 0));\n-      else\n-\ttemp = (TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 1)))\n-\t\t? compare_from_rtx (target, op1, LEU, 1, mode, NULL_RTX, 0)\n-\t\t: compare_from_rtx (target, op1, LE, 0, mode, NULL_RTX, 0));\n-      if (temp == const0_rtx)\n-\temit_move_insn (target, op1);\n-      else if (temp != const_true_rtx)\n+      /* If this mode is an integer too wide to compare properly,\n+\t compare word by word.  Rely on cse to optimize constant cases.  */\n+      if (GET_MODE_CLASS (mode) == MODE_INT\n+\t  && !can_compare_p (mode))\n \t{\n-\t  if (bcc_gen_fctn[(int) GET_CODE (temp)] != 0)\n-\t    emit_jump_insn ((*bcc_gen_fctn[(int) GET_CODE (temp)]) (op0));\n+\t  if (code == MAX_EXPR)\n+\t    do_jump_by_parts_greater_rtx (mode, TREE_UNSIGNED (type), target, op1, NULL, op0);\n \t  else\n-\t    abort ();\n+\t    do_jump_by_parts_greater_rtx (mode, TREE_UNSIGNED (type), op1, target, NULL, op0);\n \t  emit_move_insn (target, op1);\n \t}\n+      else\n+\t{\n+\t  if (code == MAX_EXPR)\n+\t    temp = (TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 1)))\n+\t\t    ? compare_from_rtx (target, op1, GEU, 1, mode, NULL_RTX, 0)\n+\t\t    : compare_from_rtx (target, op1, GE, 0, mode, NULL_RTX, 0));\n+\t  else\n+\t    temp = (TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 1)))\n+\t\t    ? compare_from_rtx (target, op1, LEU, 1, mode, NULL_RTX, 0)\n+\t\t    : compare_from_rtx (target, op1, LE, 0, mode, NULL_RTX, 0));\n+\t  if (temp == const0_rtx)\n+\t    emit_move_insn (target, op1);\n+\t  else if (temp != const_true_rtx)\n+\t    {\n+\t      if (bcc_gen_fctn[(int) GET_CODE (temp)] != 0)\n+\t\temit_jump_insn ((*bcc_gen_fctn[(int) GET_CODE (temp)]) (op0));\n+\t      else\n+\t\tabort ();\n+\t      emit_move_insn (target, op1);\n+\t    }\n+\t}\n       emit_label (op0);\n       return target;\n \n@@ -7331,6 +7346,69 @@ do_jump_by_parts_greater (exp, swap, if_false_label, if_true_label)\n     emit_label (drop_through_label);\n }\n \n+/* Compare OP0 with OP1, word at a time, in mode MODE.\n+   UNSIGNEDP says to do unsigned comparison.\n+   Jump to IF_TRUE_LABEL if OP0 is greater, IF_FALSE_LABEL otherwise.  */\n+\n+static void\n+do_jump_by_parts_greater_rtx (mode, unsignedp, op0, op1, if_false_label, if_true_label)\n+     enum machine_mode mode;\n+     int unsignedp;\n+     rtx op0, op1;\n+     rtx if_false_label, if_true_label;\n+{\n+  int nwords = (GET_MODE_SIZE (mode) / UNITS_PER_WORD);\n+  rtx drop_through_label = 0;\n+  int i;\n+\n+  if (! if_true_label || ! if_false_label)\n+    drop_through_label = gen_label_rtx ();\n+  if (! if_true_label)\n+    if_true_label = drop_through_label;\n+  if (! if_false_label)\n+    if_false_label = drop_through_label;\n+\n+  /* Compare a word at a time, high order first.  */\n+  for (i = 0; i < nwords; i++)\n+    {\n+      rtx comp;\n+      rtx op0_word, op1_word;\n+\n+      if (WORDS_BIG_ENDIAN)\n+\t{\n+\t  op0_word = operand_subword_force (op0, i, mode);\n+\t  op1_word = operand_subword_force (op1, i, mode);\n+\t}\n+      else\n+\t{\n+\t  op0_word = operand_subword_force (op0, nwords - 1 - i, mode);\n+\t  op1_word = operand_subword_force (op1, nwords - 1 - i, mode);\n+\t}\n+\n+      /* All but high-order word must be compared as unsigned.  */\n+      comp = compare_from_rtx (op0_word, op1_word,\n+\t\t\t       (unsignedp || i > 0) ? GTU : GT,\n+\t\t\t       unsignedp, word_mode, NULL_RTX, 0);\n+      if (comp == const_true_rtx)\n+\temit_jump (if_true_label);\n+      else if (comp != const0_rtx)\n+\tdo_jump_for_compare (comp, NULL_RTX, if_true_label);\n+\n+      /* Consider lower words only if these are equal.  */\n+      comp = compare_from_rtx (op0_word, op1_word, NE, unsignedp, word_mode,\n+\t\t\t       NULL_RTX, 0);\n+      if (comp == const_true_rtx)\n+\temit_jump (if_false_label);\n+      else if (comp != const0_rtx)\n+\tdo_jump_for_compare (comp, NULL_RTX, if_false_label);\n+    }\n+\n+  if (if_false_label)\n+    emit_jump (if_false_label);\n+  if (drop_through_label)\n+    emit_label (drop_through_label);\n+}\n+\n /* Given an EQ_EXPR expression EXP for values too wide to be compared\n    with one insn, test the comparison and jump to the appropriate label.  */\n "}]}