{"sha": "90a7788bbc9890f681aa8434a861d88c3a9eb815", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTBhNzc4OGJiYzk4OTBmNjgxYWE4NDM0YTg2MWQ4OGMzYTllYjgxNQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2010-05-31T15:38:35Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2010-05-31T15:38:35Z"}, "message": "re PR tree-optimization/44182 (-fcompare-debug failure (length) with -O1)\n\n\tPR tree-optimization/44182\n\t* tree-inline.c (copy_edges_for_bb): Don't split bb if a stmt that\n\tnewly needs to end a bb is followed by debug stmts, instead return\n\ttrue from the function at the end.\n\t(maybe_move_debug_stmts_to_successors): New function.\n\t(copy_cfg_body): Call it if copy_edges_for_bb returned true.\n\n\t* g++.dg/debug/pr44182.C: New test.\n\nFrom-SVN: r160074", "tree": {"sha": "df14b009ae81deca2b86203a098a50621e0bf602", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df14b009ae81deca2b86203a098a50621e0bf602"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90a7788bbc9890f681aa8434a861d88c3a9eb815", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90a7788bbc9890f681aa8434a861d88c3a9eb815", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90a7788bbc9890f681aa8434a861d88c3a9eb815", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90a7788bbc9890f681aa8434a861d88c3a9eb815/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1e2c0906eeaf6050034a17d06c9d40c16a3f29cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e2c0906eeaf6050034a17d06c9d40c16a3f29cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e2c0906eeaf6050034a17d06c9d40c16a3f29cd"}], "stats": {"total": 126, "additions": 121, "deletions": 5}, "files": [{"sha": "30fe267e3bb8fb330298e65e9880728c3746d0f0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90a7788bbc9890f681aa8434a861d88c3a9eb815/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90a7788bbc9890f681aa8434a861d88c3a9eb815/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=90a7788bbc9890f681aa8434a861d88c3a9eb815", "patch": "@@ -1,3 +1,12 @@\n+2010-05-31  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/44182\n+\t* tree-inline.c (copy_edges_for_bb): Don't split bb if a stmt that\n+\tnewly needs to end a bb is followed by debug stmts, instead return\n+\ttrue from the function at the end.\n+\t(maybe_move_debug_stmts_to_successors): New function.\n+\t(copy_cfg_body): Call it if copy_edges_for_bb returned true.\n+\n 2010-05-31  Kai Tietz  <kai.tietz@onevision.com>\n \n \tPR target/44161"}, {"sha": "4dc9a4158a391654b486767a38219a3c429ec8f2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90a7788bbc9890f681aa8434a861d88c3a9eb815/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90a7788bbc9890f681aa8434a861d88c3a9eb815/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=90a7788bbc9890f681aa8434a861d88c3a9eb815", "patch": "@@ -1,3 +1,8 @@\n+2010-05-31  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/44182\n+\t* g++.dg/debug/pr44182.C: New test.\n+\n 2010-05-31  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc.dg/nested-func-7.c: New test."}, {"sha": "3e062a3fe8477d997a7fb80d6fad94c6391fb280", "filename": "gcc/testsuite/g++.dg/debug/pr44182.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90a7788bbc9890f681aa8434a861d88c3a9eb815/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fpr44182.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90a7788bbc9890f681aa8434a861d88c3a9eb815/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fpr44182.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fpr44182.C?ref=90a7788bbc9890f681aa8434a861d88c3a9eb815", "patch": "@@ -0,0 +1,26 @@\n+// PR tree-optimization/44182\n+// { dg-do compile }\n+// { dg-options \"-fcompare-debug\" }\n+\n+struct S\n+{\n+  int i;\n+  S ();\n+  ~S ();\n+  void f1 ();\n+  void f2 (S s)\n+  {\n+    f3 (s.i);\n+    for (int j = 0; j < s.i; j++) f1 ();\n+  }\n+  void f3 (int j)\n+  {\n+    if (j > i) f1 ();\n+  }\n+};\n+\n+void\n+f (S *x)\n+{\n+  x->f2 (S ());\n+}"}, {"sha": "3055b5797fb4be8be6d6338ededa4592081c8d47", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 81, "deletions": 5, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90a7788bbc9890f681aa8434a861d88c3a9eb815/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90a7788bbc9890f681aa8434a861d88c3a9eb815/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=90a7788bbc9890f681aa8434a861d88c3a9eb815", "patch": "@@ -1834,16 +1834,18 @@ update_ssa_across_abnormal_edges (basic_block bb, basic_block ret_bb,\n \n /* Copy edges from BB into its copy constructed earlier, scale profile\n    accordingly.  Edges will be taken care of later.  Assume aux\n-   pointers to point to the copies of each BB.  */\n+   pointers to point to the copies of each BB.  Return true if any\n+   debug stmts are left after a statement that must end the basic block.  */\n \n-static void\n+static bool\n copy_edges_for_bb (basic_block bb, gcov_type count_scale, basic_block ret_bb)\n {\n   basic_block new_bb = (basic_block) bb->aux;\n   edge_iterator ei;\n   edge old_edge;\n   gimple_stmt_iterator si;\n   int flags;\n+  bool need_debug_cleanup = false;\n \n   /* Use the indices from the original blocks to create edges for the\n      new ones.  */\n@@ -1864,7 +1866,7 @@ copy_edges_for_bb (basic_block bb, gcov_type count_scale, basic_block ret_bb)\n       }\n \n   if (bb->index == ENTRY_BLOCK || bb->index == EXIT_BLOCK)\n-    return;\n+    return false;\n \n   for (si = gsi_start_bb (new_bb); !gsi_end_p (si);)\n     {\n@@ -1898,6 +1900,13 @@ copy_edges_for_bb (basic_block bb, gcov_type count_scale, basic_block ret_bb)\n \n       if (can_throw || nonlocal_goto)\n \t{\n+\t  if (!gsi_end_p (si))\n+\t    {\n+\t      while (!gsi_end_p (si) && is_gimple_debug (gsi_stmt (si)))\n+\t\tgsi_next (&si);\n+\t      if (gsi_end_p (si))\n+\t\tneed_debug_cleanup = true;\n+\t    }\n \t  if (!gsi_end_p (si))\n \t    /* Note that bb's predecessor edges aren't necessarily\n \t       right at this point; split_block doesn't care.  */\n@@ -1923,6 +1932,7 @@ copy_edges_for_bb (basic_block bb, gcov_type count_scale, basic_block ret_bb)\n \tupdate_ssa_across_abnormal_edges (gimple_bb (copy_stmt), ret_bb,\n \t\t\t\t\t  can_throw, nonlocal_goto);\n     }\n+  return need_debug_cleanup;\n }\n \n /* Copy the PHIs.  All blocks and edges are copied, some blocks\n@@ -2059,6 +2069,63 @@ initialize_cfun (tree new_fndecl, tree callee_fndecl, gcov_type count)\n   pop_cfun ();\n }\n \n+/* Helper function for copy_cfg_body.  Move debug stmts from the end\n+   of NEW_BB to the beginning of successor basic blocks when needed.  If the\n+   successor has multiple predecessors, reset them, otherwise keep\n+   their value.  */\n+\n+static void\n+maybe_move_debug_stmts_to_successors (copy_body_data *id, basic_block new_bb)\n+{\n+  edge e;\n+  edge_iterator ei;\n+  gimple_stmt_iterator si = gsi_last_nondebug_bb (new_bb);\n+\n+  if (gsi_end_p (si)\n+      || gsi_one_before_end_p (si)\n+      || !(stmt_can_throw_internal (gsi_stmt (si))\n+\t   || stmt_can_make_abnormal_goto (gsi_stmt (si))))\n+    return;\n+\n+  FOR_EACH_EDGE (e, ei, new_bb->succs)\n+    {\n+      gimple_stmt_iterator ssi = gsi_last_bb (new_bb);\n+      gimple_stmt_iterator dsi = gsi_after_labels (e->dest);\n+      while (is_gimple_debug (gsi_stmt (ssi)))\n+\t{\n+\t  gimple stmt = gsi_stmt (ssi), new_stmt;\n+\t  tree var;\n+\t  tree value;\n+\n+\t  /* For the last edge move the debug stmts instead of copying\n+\t     them.  */\n+\t  if (ei_one_before_end_p (ei))\n+\t    {\n+\t      si = ssi;\n+\t      gsi_prev (&ssi);\n+\t      if (!single_pred_p (e->dest))\n+\t\tgimple_debug_bind_reset_value (stmt);\n+\t      gsi_remove (&si, false);\n+\t      gsi_insert_before (&dsi, stmt, GSI_SAME_STMT);\n+\t      continue;\n+\t    }\n+\n+\t  var = gimple_debug_bind_get_var (stmt);\n+\t  if (single_pred_p (e->dest))\n+\t    {\n+\t      value = gimple_debug_bind_get_value (stmt);\n+\t      value = unshare_expr (value);\n+\t    }\n+\t  else\n+\t    value = NULL_TREE;\n+\t  new_stmt = gimple_build_debug_bind (var, value, stmt);\n+\t  gsi_insert_before (&dsi, new_stmt, GSI_SAME_STMT);\n+\t  VEC_safe_push (gimple, heap, id->debug_stmts, new_stmt);\n+\t  gsi_prev (&ssi);\n+\t}\n+    }\n+}\n+\n /* Make a copy of the body of FN so that it can be inserted inline in\n    another function.  Walks FN via CFG, returns new fndecl.  */\n \n@@ -2072,6 +2139,7 @@ copy_cfg_body (copy_body_data * id, gcov_type count, int frequency_scale,\n   struct function *cfun_to_copy;\n   basic_block bb;\n   tree new_fndecl = NULL;\n+  bool need_debug_cleanup = false;\n   gcov_type count_scale;\n   int last;\n \n@@ -2112,22 +2180,30 @@ copy_cfg_body (copy_body_data * id, gcov_type count, int frequency_scale,\n \n   /* Now that we've duplicated the blocks, duplicate their edges.  */\n   FOR_ALL_BB_FN (bb, cfun_to_copy)\n-    copy_edges_for_bb (bb, count_scale, exit_block_map);\n+    need_debug_cleanup |= copy_edges_for_bb (bb, count_scale, exit_block_map);\n \n   if (gimple_in_ssa_p (cfun))\n     FOR_ALL_BB_FN (bb, cfun_to_copy)\n       copy_phis_for_bb (bb, id);\n \n   FOR_ALL_BB_FN (bb, cfun_to_copy)\n     {\n+      if (need_debug_cleanup\n+\t  && bb->index != ENTRY_BLOCK\n+\t  && bb->index != EXIT_BLOCK)\n+\tmaybe_move_debug_stmts_to_successors (id, (basic_block) bb->aux);\n       ((basic_block)bb->aux)->aux = NULL;\n       bb->aux = NULL;\n     }\n \n   /* Zero out AUX fields of newly created block during EH edge\n      insertion. */\n   for (; last < last_basic_block; last++)\n-    BASIC_BLOCK (last)->aux = NULL;\n+    {\n+      if (need_debug_cleanup)\n+\tmaybe_move_debug_stmts_to_successors (id, BASIC_BLOCK (last));\n+      BASIC_BLOCK (last)->aux = NULL;\n+    }\n   entry_block_map->aux = NULL;\n   exit_block_map->aux = NULL;\n "}]}