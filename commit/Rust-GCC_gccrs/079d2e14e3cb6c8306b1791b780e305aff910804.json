{"sha": "079d2e14e3cb6c8306b1791b780e305aff910804", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDc5ZDJlMTRlM2NiNmM4MzA2YjE3OTFiNzgwZTMwNWFmZjkxMDgwNA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-06-14T17:20:33Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-06-14T17:20:33Z"}, "message": "escape: Implement flood phase.\n\n    \n    Walks the connection graphs built in the assign phase from the\n    function context's sink, propagating the escape level to each\n    visited node and uncovering nodes that leak out of their scope\n    which implies they must be heap allocated.\n    \n    Reviewed-on: https://go-review.googlesource.com/18413\n\nFrom-SVN: r237453", "tree": {"sha": "7e63b9f510cb285d3fd9ecb391fe366ef32d7178", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e63b9f510cb285d3fd9ecb391fe366ef32d7178"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/079d2e14e3cb6c8306b1791b780e305aff910804", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/079d2e14e3cb6c8306b1791b780e305aff910804", "html_url": "https://github.com/Rust-GCC/gccrs/commit/079d2e14e3cb6c8306b1791b780e305aff910804", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/079d2e14e3cb6c8306b1791b780e305aff910804/comments", "author": null, "committer": null, "parents": [{"sha": "eed7fbc5e35259367407b809d3b8e17a9552f5ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eed7fbc5e35259367407b809d3b8e17a9552f5ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eed7fbc5e35259367407b809d3b8e17a9552f5ee"}], "stats": {"total": 368, "additions": 363, "deletions": 5}, "files": [{"sha": "e2a7a8d36eebd8276c9781f3f400807a06394f98", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/079d2e14e3cb6c8306b1791b780e305aff910804/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/079d2e14e3cb6c8306b1791b780e305aff910804/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=079d2e14e3cb6c8306b1791b780e305aff910804", "patch": "@@ -1,4 +1,4 @@\n-f768153eb2a7a72587c9c0997955cdbbc70322d0\n+1f2f2c77c7ec92efa254e07162a8fc0d22a550e7\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "7a558183f379df6eed47ac7dfe6fd9e5a6216212", "filename": "gcc/go/gofrontend/escape.cc", "status": "modified", "additions": 362, "deletions": 4, "changes": 366, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/079d2e14e3cb6c8306b1791b780e305aff910804/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/079d2e14e3cb6c8306b1791b780e305aff910804/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fescape.cc?ref=079d2e14e3cb6c8306b1791b780e305aff910804", "patch": "@@ -245,7 +245,8 @@ Node::note_inout_flows(int e, int index, Level level)\n \n Escape_context::Escape_context(Gogo* gogo, bool recursive)\n   : gogo_(gogo), current_function_(NULL), recursive_(recursive),\n-    sink_(Node::make_node(Named_object::make_sink())), loop_depth_(0)\n+    sink_(Node::make_node(Named_object::make_sink())), loop_depth_(0),\n+    flood_id_(0), pdepth_(0)\n {\n   // The sink always escapes to heap and strictly lives outside of the\n   // current function i.e. loop_depth == -1.\n@@ -1827,13 +1828,370 @@ Gogo::assign_connectivity(Escape_context* context, Named_object* fn)\n   context->set_loop_depth(save_depth);\n }\n \n+class Escape_analysis_flood\n+{\n+ public:\n+  Escape_analysis_flood(Escape_context* context)\n+    : context_(context)\n+  { }\n+\n+  // Use the escape information in dst to update the escape information in src\n+  // and src's upstream.\n+  void\n+  flood(Level, Node* dst, Node* src, int);\n+\n+ private:\n+  // The escape context for the group of functions being flooded.\n+  Escape_context* context_;\n+};\n+\n+// Whenever we hit a dereference node, the level goes up by one, and whenever\n+// we hit an address-of, the level goes down by one. as long as we're on a\n+// level > 0 finding an address-of just means we're following the upstream\n+// of a dereference, so this address doesn't leak (yet).\n+// If level == 0, it means the /value/ of this node can reach the root of this\n+// flood so if this node is an address-of, its argument should be marked as\n+// escaping iff its current function and loop depth are different from the\n+// flood's root.\n+// Once an object has been moved to the heap, all of its upstream should be\n+// considered escaping to the global scope.\n+// This is an implementation of gc/esc.go:escwalkBody.\n+\n+void\n+Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n+\t\t\t     int extra_loop_depth)\n+{\n+  // No need to flood src if it is a literal.\n+  if (src->expr() != NULL)\n+    {\n+      switch (src->expr()->classification())\n+        {\n+\tcase Expression::EXPRESSION_BOOLEAN:\n+\tcase Expression::EXPRESSION_STRING:\n+\tcase Expression::EXPRESSION_INTEGER:\n+\tcase Expression::EXPRESSION_FLOAT:\n+\tcase Expression::EXPRESSION_COMPLEX:\n+\tcase Expression::EXPRESSION_NIL:\n+\tcase Expression::EXPRESSION_IOTA:\n+\t  return;\n+\n+\tdefault:\n+\t  break;\n+        }\n+    }\n+\n+  Node::Escape_state* src_state = src->state(this->context_, NULL);\n+  if (src_state->flood_id == this->context_->flood_id())\n+    {\n+      // Esclevels are vectors, do not compare as integers,\n+      // and must use \"min\" of old and new to guarantee\n+      // convergence.\n+      level = level.min(src_state->level);\n+      if (level == src_state->level)\n+\t{\n+\t  // Have we been here already with an extraloopdepth,\n+\t  // or is the extraloopdepth provided no improvement on\n+\t  // what's already been seen?\n+\t  if (src_state->max_extra_loop_depth >= extra_loop_depth\n+\t      || src_state->loop_depth >= extra_loop_depth)\n+\t    return;\n+\t  src_state->max_extra_loop_depth = extra_loop_depth;\n+\t}\n+    }\n+  else\n+    src_state->max_extra_loop_depth = -1;\n+\n+  src_state->flood_id = this->context_->flood_id();\n+  src_state->level = level;\n+  int mod_loop_depth = std::max(extra_loop_depth, src_state->loop_depth);\n+\n+  this->context_->increase_pdepth();\n+\n+  // Input parameter flowing into output parameter?\n+  Named_object* src_no = NULL;\n+  if (src->expr() != NULL && src->expr()->var_expression() != NULL)\n+    src_no = src->expr()->var_expression()->named_object();\n+  else\n+    src_no = src->object();\n+  bool src_is_param = (src_no != NULL\n+\t\t       && src_no->is_variable()\n+\t\t       && src_no->var_value()->is_parameter());\n+\n+  Named_object* dst_no = NULL;\n+  if (dst->expr() != NULL && dst->expr()->var_expression() != NULL)\n+    dst_no = dst->expr()->var_expression()->named_object();\n+  else\n+    dst_no = dst->object();\n+  bool dst_is_result = dst_no != NULL && dst_no->is_result_variable();\n+\n+  if (src_is_param\n+      && dst_is_result\n+      && (src->encoding() & ESCAPE_MASK) < int(Node::ESCAPE_SCOPE)\n+      && dst->encoding() != Node::ESCAPE_HEAP)\n+    {\n+      // This case handles:\n+      // 1. return in\n+      // 2. return &in\n+      // 3. tmp := in; return &tmp\n+      // 4. return *in\n+      if ((src->encoding() & ESCAPE_MASK) != Node::ESCAPE_RETURN)\n+\t{\n+\t  int enc =\n+\t    Node::ESCAPE_RETURN | (src->encoding() & ESCAPE_CONTENT_ESCAPES);\n+\t  src->set_encoding(enc);\n+\t}\n+\n+      int enc = Node::note_inout_flows(src->encoding(),\n+\t\t\t\t       dst_no->result_var_value()->index(),\n+\t\t\t\t       level);\n+      src->set_encoding(enc);\n+\n+      // In gc/esc.go:escwalkBody, this is a goto to the label for recursively\n+      // flooding the connection graph.  Inlined here for convenience.\n+      level = level.copy();\n+      for (std::set<Node*>::const_iterator p = src_state->flows.begin();\n+\t   p != src_state->flows.end();\n+\t   ++p)\n+\tthis->flood(level, dst, *p, extra_loop_depth);\n+      return;\n+    }\n+\n+  // If parameter content escape to heap, set ESCAPE_CONTENT_ESCAPES.\n+  // Note minor confusion around escape from pointer-to-struct vs\n+  // escape from struct.\n+  if (src_is_param\n+      && dst->encoding() == Node::ESCAPE_HEAP\n+      && (src->encoding() & ESCAPE_MASK) < int(Node::ESCAPE_SCOPE)\n+      && level.value() > 0)\n+    {\n+      int enc =\n+\tNode::max_encoding((src->encoding() | ESCAPE_CONTENT_ESCAPES),\n+\t\t\t   Node::ESCAPE_NONE);\n+      src->set_encoding(enc);\n+    }\n+\n+  // A src object leaks if its value or address is assigned to a dst object\n+  // in a different scope (at a different loop depth).\n+  Node::Escape_state* dst_state = dst->state(this->context_, NULL);\n+  bool src_leaks = (level.value() <= 0\n+\t\t    && level.suffix_value() <= 0\n+\t\t    && dst_state->loop_depth < mod_loop_depth);\n+\n+  if (src_is_param\n+      && (src_leaks || dst_state->loop_depth < 0)\n+      && (src->encoding() & ESCAPE_MASK) < int(Node::ESCAPE_SCOPE))\n+    {\n+      if (level.suffix_value() > 0)\n+\t{\n+\t  int enc =\n+\t    Node::max_encoding((src->encoding() | ESCAPE_CONTENT_ESCAPES),\n+\t\t\t       Node::ESCAPE_NONE);\n+\t  src->set_encoding(enc);\n+\t}\n+      else\n+\t{\n+\t  src->set_encoding(Node::ESCAPE_SCOPE);\n+\t}\n+    }\n+  else if (src->expr() != NULL)\n+    {\n+      Expression* e = src->expr();\n+      if (e->enclosed_var_expression() != NULL)\n+\t{\n+\t  Node* enclosed_node =\n+\t    Node::make_node(e->enclosed_var_expression()->variable());\n+\t  this->flood(level, dst, enclosed_node, -1);\n+\t}\n+      else if (e->heap_expression() != NULL\n+\t  || (e->unary_expression() != NULL\n+\t      && e->unary_expression()->op() == OPERATOR_AND))\n+\t{\n+\t  // Pointer literals and address-of expressions.\n+\t  Expression* underlying;\n+\t  if (e->heap_expression())\n+\t    underlying = e->heap_expression()->expr();\n+\t  else\n+\t    underlying = e->unary_expression()->operand();\n+\t  Node* underlying_node = Node::make_node(underlying);\n+\n+\t  // If the address leaks, the underyling object must be moved\n+\t  // to the heap.\n+\t  underlying->address_taken(src_leaks);\n+\t  if (src_leaks)\n+\t    {\n+\t      src->set_encoding(Node::ESCAPE_HEAP);\n+\t      this->flood(level.decrease(), dst,\n+\t\t\t  underlying_node, mod_loop_depth);\n+\t      extra_loop_depth = mod_loop_depth;\n+\t    }\n+\t  else\n+\t    {\n+\t      // Decrease the level each time we take the address of the object.\n+\t      this->flood(level.decrease(), dst, underlying_node, -1);\n+\t    }\n+\t}\n+      else if (e->slice_literal() != NULL)\n+\t{\n+\t  Slice_construction_expression* slice = e->slice_literal();\n+\t  if (slice->vals() != NULL)\n+\t    {\n+\t      for (Expression_list::const_iterator p = slice->vals()->begin();\n+\t\t   p != slice->vals()->end();\n+\t\t   ++p)\n+\t\t{\n+\t\t  if ((*p) != NULL)\n+\t\t    this->flood(level.decrease(), dst, Node::make_node(*p), -1);\n+\t\t}\n+\t    }\n+\t  if (src_leaks)\n+\t    {\n+\t      src->set_encoding(Node::ESCAPE_HEAP);\n+\t      extra_loop_depth = mod_loop_depth;\n+\t    }\n+\t}\n+      else if (e->call_expression() != NULL)\n+\t{\n+\t  Call_expression* call = e->call_expression();\n+\t  if (call->fn()->func_expression() != NULL)\n+\t    {\n+\t      Func_expression* func = call->fn()->func_expression();\n+\t      if (func->is_runtime_function())\n+\t\t{\n+\t\t  switch (func->runtime_code())\n+\t\t    {\n+\t\t    case Runtime::APPEND:\n+\t\t      {\n+\t\t\t// Propagate escape information to appendee.\n+\t\t\tExpression* appendee = call->args()->front();\n+\t\t\tthis->flood(level, dst, Node::make_node(appendee), -1);\n+\t\t      }\n+\t\t      break;\n+\n+\t\t    case Runtime::MAKECHAN:\n+\t\t    case Runtime::MAKECHANBIG:\n+\t\t    case Runtime::MAKEMAP:\n+\t\t    case Runtime::MAKEMAPBIG:\n+\t\t    case Runtime::MAKESLICE1:\n+\t\t    case Runtime::MAKESLICE2:\n+\t\t    case Runtime::MAKESLICE1BIG:\n+\t\t    case Runtime::MAKESLICE2BIG:\n+\t\t    case Runtime::BYTE_ARRAY_TO_STRING:\n+\t\t    case Runtime::INT_ARRAY_TO_STRING:\n+\t\t    case Runtime::STRING_TO_BYTE_ARRAY:\n+\t\t    case Runtime::STRING_TO_INT_ARRAY:\n+\t\t    case Runtime::STRING_PLUS:\n+\t\t    case Runtime::CONSTRUCT_MAP:\n+\t\t    case Runtime::INT_TO_STRING:\n+\t\t    case Runtime::CONVERT_INTERFACE:\n+\t\t      // All runtime calls that involve allocation of memory\n+\t\t      // except new.  Runtime::NEW gets lowered into an\n+\t\t      // allocation expression.\n+\t\t      if (src_leaks)\n+\t\t\t{\n+\t\t\t  src->set_encoding(Node::ESCAPE_HEAP);\n+\t\t\t  extra_loop_depth = mod_loop_depth;\n+\t\t\t}\n+\t\t      break;\n+\n+\t\t    default:\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      else if (src_leaks\n+\t\t       && (func->closure() != NULL\n+\t\t\t   || func->bound_method_expression() != NULL))\n+\t\t{\n+\t\t  // A closure or bound method; we lost track of actual function\n+\t\t  // so if this leaks, this call must be done on the heap.\n+\t\t  src->set_encoding(Node::ESCAPE_HEAP);\n+\t\t}\n+\t    }\n+\t}\n+      else if (e->allocation_expression() != NULL && src_leaks)\n+\t{\n+\t  // Calls to Runtime::NEW get lowered into an allocation expression.\n+\t  src->set_encoding(Node::ESCAPE_HEAP);\n+\t}\n+      else if ((e->field_reference_expression() != NULL\n+\t\t&& e->field_reference_expression()->expr()->unary_expression() == NULL)\n+\t       || e->type_guard_expression() != NULL\n+\t       || (e->array_index_expression() != NULL\n+\t\t   && e->type()->is_slice_type())\n+\t       || (e->string_index_expression() != NULL\n+\t\t   && e->type()->is_slice_type()))\n+\t{\n+\t  Expression* underlying;\n+\t  if (e->field_reference_expression() != NULL)\n+\t    underlying = e->field_reference_expression()->expr();\n+\t  else if (e->type_guard_expression() != NULL)\n+\t    underlying = e->type_guard_expression()->expr();\n+\t  else if (e->array_index_expression() != NULL)\n+\t    underlying = e->array_index_expression()->array();\n+\t  else\n+\t    underlying = e->string_index_expression()->string();\n+\n+\t  Node* underlying_node = Node::make_node(underlying);\n+\t  this->flood(level, dst, underlying_node, -1);\n+\t}\n+      else if ((e->field_reference_expression() != NULL\n+\t\t&& e->field_reference_expression()->expr()->unary_expression() != NULL)\n+\t       || e->array_index_expression() != NULL\n+\t       || e->map_index_expression() != NULL\n+\t       || (e->unary_expression() != NULL\n+\t\t   && e->unary_expression()->op() == OPERATOR_MULT))\n+\t{\n+\t  Expression* underlying;\n+\t  if (e->field_reference_expression() != NULL)\n+\t    {\n+\t      underlying = e->field_reference_expression()->expr();\n+\t      underlying = underlying->unary_expression()->operand();\n+\t    }\n+\t  else if (e->array_index_expression() != NULL)\n+\t    {\n+\t      underlying = e->array_index_expression()->array();\n+\t      if (!underlying->type()->is_slice_type())\n+\t\t{\n+\t\t  Node* underlying_node = Node::make_node(underlying);\n+\t\t  this->flood(level, dst, underlying_node, 1);\n+\t\t}\n+\t    }\n+\t  else if (e->map_index_expression() != NULL)\n+\t    underlying = e->map_index_expression()->map();\n+\t  else\n+\t    underlying = e->unary_expression()->operand();\n+\n+\t  // Increase the level for a dereference.\n+\t  Node* underlying_node = Node::make_node(underlying);\n+\t  this->flood(level.increase(), dst, underlying_node, -1);\n+\t}\n+\n+      // TODO(cmang): Add case for Issue #10466.\n+    }\n+\n+  level = level.copy();\n+  for (std::set<Node*>::const_iterator p = src_state->flows.begin();\n+       p != src_state->flows.end();\n+       ++p)\n+    this->flood(level, dst, *p, extra_loop_depth);\n+\n+  this->context_->decrease_pdepth();\n+}\n+\n // Propagate escape information across the nodes modeled in this Analysis_set.\n+// This is an implementation of gc/esc.go:escflood.\n \n void\n-Gogo::propagate_escape(Escape_context*, Node*)\n+Gogo::propagate_escape(Escape_context* context, Node* dst)\n {\n-  // TODO(cmang): Do a breadth-first traversal of a node's upstream, adjusting\n-  // the Level appropriately.\n+  Node::Escape_state* state = dst->state(context, NULL);\n+  Escape_analysis_flood eaf(context);\n+  for (std::set<Node*>::const_iterator p = state->flows.begin();\n+       p != state->flows.end();\n+       ++p)\n+    {\n+      context->increase_flood_id();\n+      eaf.flood(Level::From(0), dst, *p, -1);\n+    }\n }\n \n "}]}