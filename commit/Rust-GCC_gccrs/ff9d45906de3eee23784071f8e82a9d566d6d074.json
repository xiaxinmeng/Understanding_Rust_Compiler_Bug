{"sha": "ff9d45906de3eee23784071f8e82a9d566d6d074", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmY5ZDQ1OTA2ZGUzZWVlMjM3ODQwNzFmOGU4MmE5ZDU2NmQ2ZDA3NA==", "commit": {"author": {"name": "Jan-Benedict Glaw", "email": "jbglaw@lug-owl.de", "date": "2006-03-15T16:49:20Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2006-03-15T16:49:20Z"}, "message": "vax.c (split_quadword_operands): Use MEM_P() instead of GET_CODE() == MEM and REG_P() instead of GET_CODE() == REG.\n\n\t* config/vax/vax.c (split_quadword_operands): Use MEM_P()\n\tinstead of GET_CODE() == MEM and REG_P() instead of\n\tGET_CODE() == REG.\n\t(print_operand_address): Likewise.\n\t(vax_address_cost): Likewise.\n\t(vax_rtx_costs): Likewise.\n\t(vax_notice_update_cc): Likewise.\n\t(vax_output_int_add): Likewise.\n\t(INDEX_REGISTER_P): Likewise.\n\t(BASE_REGISTER_P): Likewise.\n\t(nonindexed_address_p): Likewise.\n\t(vax_mode_dependent_address_p): Likewise.\n\t* config/vax/vax.h (EXTRA_CONSTRAINT): Likewise.\n\t(PRINT_OPERAND): Likewise.\n\t* config/vax/vax.md (ashlsi3): Likewise.\n\t(ashlsi3): Likewise.\n\t(some more unnamed insns): Likewise.\n\nFrom-SVN: r112090", "tree": {"sha": "15c8f31c998bb8f32511a4ef7af1bed8b31671c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/15c8f31c998bb8f32511a4ef7af1bed8b31671c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff9d45906de3eee23784071f8e82a9d566d6d074", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff9d45906de3eee23784071f8e82a9d566d6d074", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff9d45906de3eee23784071f8e82a9d566d6d074", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff9d45906de3eee23784071f8e82a9d566d6d074/comments", "author": {"login": "jbglaw", "id": 7965297, "node_id": "MDQ6VXNlcjc5NjUyOTc=", "avatar_url": "https://avatars.githubusercontent.com/u/7965297?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbglaw", "html_url": "https://github.com/jbglaw", "followers_url": "https://api.github.com/users/jbglaw/followers", "following_url": "https://api.github.com/users/jbglaw/following{/other_user}", "gists_url": "https://api.github.com/users/jbglaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbglaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbglaw/subscriptions", "organizations_url": "https://api.github.com/users/jbglaw/orgs", "repos_url": "https://api.github.com/users/jbglaw/repos", "events_url": "https://api.github.com/users/jbglaw/events{/privacy}", "received_events_url": "https://api.github.com/users/jbglaw/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "db490c3983f6ad40724aa1a22e3e8b74dc092b6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db490c3983f6ad40724aa1a22e3e8b74dc092b6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db490c3983f6ad40724aa1a22e3e8b74dc092b6d"}], "stats": {"total": 100, "additions": 60, "deletions": 40}, "files": [{"sha": "2a05ddb43f199a23ebefa38a20fe5a7dd283c85a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff9d45906de3eee23784071f8e82a9d566d6d074/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff9d45906de3eee23784071f8e82a9d566d6d074/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ff9d45906de3eee23784071f8e82a9d566d6d074", "patch": "@@ -1,3 +1,23 @@\n+2006-03-15  Jan-Benedict Glaw  <jbglaw@lug-owl.de>\n+\n+\t* config/vax/vax.c (split_quadword_operands): Use MEM_P()\n+\tinstead of GET_CODE() == MEM and REG_P() instead of\n+\tGET_CODE() == REG.\n+\t(print_operand_address): Likewise.\n+\t(vax_address_cost): Likewise.\n+\t(vax_rtx_costs): Likewise.\n+\t(vax_notice_update_cc): Likewise.\n+\t(vax_output_int_add): Likewise.\n+\t(INDEX_REGISTER_P): Likewise.\n+\t(BASE_REGISTER_P): Likewise.\n+\t(nonindexed_address_p): Likewise.\n+\t(vax_mode_dependent_address_p): Likewise.\n+\t* config/vax/vax.h (EXTRA_CONSTRAINT): Likewise.\n+\t(PRINT_OPERAND): Likewise.\n+\t* config/vax/vax.md (ashlsi3): Likewise.\n+\t(ashlsi3): Likewise.\n+\t(some more unnamed insns): Likewise.\n+\n 2006-03-15  Kazu Hirata  <kazu@codesourcery.com>\n \n \t* tree-ssa-dce.c (EXECUTE_IF_CONTROL_DEPENDENT): Make it an"}, {"sha": "8a3425816881db085642d146dd1dc64ce587ff0a", "filename": "gcc/config/vax/vax.c", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff9d45906de3eee23784071f8e82a9d566d6d074/gcc%2Fconfig%2Fvax%2Fvax.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff9d45906de3eee23784071f8e82a9d566d6d074/gcc%2Fconfig%2Fvax%2Fvax.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.c?ref=ff9d45906de3eee23784071f8e82a9d566d6d074", "patch": "@@ -179,7 +179,7 @@ split_quadword_operands (rtx * operands, rtx * low, int n ATTRIBUTE_UNUSED)\n     {\n       if (low[i])\n \t/* it's already been figured out */;\n-      else if (GET_CODE (operands[i]) == MEM\n+      else if (MEM_P (operands[i])\n \t       && (GET_CODE (XEXP (operands[i], 0)) == POST_INC))\n \t{\n \t  rtx addr = XEXP (operands[i], 0);\n@@ -237,13 +237,13 @@ print_operand_address (FILE * file, rtx addr)\n       reg1 = 0; ireg = 0; breg = 0; offset = 0;\n \n       if (CONSTANT_ADDRESS_P (XEXP (addr, 0))\n-\t  || GET_CODE (XEXP (addr, 0)) == MEM)\n+\t  || MEM_P (XEXP (addr, 0)))\n \t{\n \t  offset = XEXP (addr, 0);\n \t  addr = XEXP (addr, 1);\n \t}\n       else if (CONSTANT_ADDRESS_P (XEXP (addr, 1))\n-\t       || GET_CODE (XEXP (addr, 1)) == MEM)\n+\t       || MEM_P (XEXP (addr, 1)))\n \t{\n \t  offset = XEXP (addr, 1);\n \t  addr = XEXP (addr, 0);\n@@ -258,20 +258,20 @@ print_operand_address (FILE * file, rtx addr)\n \t  ireg = XEXP (addr, 0);\n \t  addr = XEXP (addr, 1);\n \t}\n-      else if (GET_CODE (XEXP (addr, 1)) == REG)\n+      else if (REG_P (XEXP (addr, 1)))\n \t{\n \t  reg1 = XEXP (addr, 1);\n \t  addr = XEXP (addr, 0);\n \t}\n-      else if (GET_CODE (XEXP (addr, 0)) == REG)\n+      else if (REG_P (XEXP (addr, 0)))\n \t{\n \t  reg1 = XEXP (addr, 0);\n \t  addr = XEXP (addr, 1);\n \t}\n       else\n \tgcc_unreachable ();\n \n-      if (GET_CODE (addr) == REG)\n+      if (REG_P (addr))\n \t{\n \t  if (reg1)\n \t    ireg = addr;\n@@ -284,7 +284,7 @@ print_operand_address (FILE * file, rtx addr)\n \t{\n \t  gcc_assert (GET_CODE (addr) == PLUS);\n \t  if (CONSTANT_ADDRESS_P (XEXP (addr, 0))\n-\t      || GET_CODE (XEXP (addr, 0)) == MEM)\n+\t      || MEM_P (XEXP (addr, 0)))\n \t    {\n \t      if (offset)\n \t\t{\n@@ -298,7 +298,7 @@ print_operand_address (FILE * file, rtx addr)\n \t\t}\n \t      offset = XEXP (addr, 0);\n \t    }\n-\t  else if (GET_CODE (XEXP (addr, 0)) == REG)\n+\t  else if (REG_P (XEXP (addr, 0)))\n \t    {\n \t      if (reg1)\n \t\tireg = reg1, breg = XEXP (addr, 0), reg1 = 0;\n@@ -313,7 +313,7 @@ print_operand_address (FILE * file, rtx addr)\n \t    }\n \n \t  if (CONSTANT_ADDRESS_P (XEXP (addr, 1))\n-\t      || GET_CODE (XEXP (addr, 1)) == MEM)\n+\t      || MEM_P (XEXP (addr, 1)))\n \t    {\n \t      if (offset)\n \t\t{\n@@ -327,7 +327,7 @@ print_operand_address (FILE * file, rtx addr)\n \t\t}\n \t      offset = XEXP (addr, 1);\n \t    }\n-\t  else if (GET_CODE (XEXP (addr, 1)) == REG)\n+\t  else if (REG_P (XEXP (addr, 1)))\n \t    {\n \t      if (reg1)\n \t\tireg = reg1, breg = XEXP (addr, 1), reg1 = 0;\n@@ -345,7 +345,7 @@ print_operand_address (FILE * file, rtx addr)\n       /* If REG1 is nonzero, figure out if it is a base or index register.  */\n       if (reg1)\n \t{\n-\t  if (breg != 0 || (offset && GET_CODE (offset) == MEM))\n+\t  if (breg != 0 || (offset && MEM_P (offset)))\n \t    {\n \t      gcc_assert (!ireg);\n \t      ireg = reg1;\n@@ -364,7 +364,7 @@ print_operand_address (FILE * file, rtx addr)\n \t{\n \t  if (GET_CODE (ireg) == MULT)\n \t    ireg = XEXP (ireg, 0);\n-\t  gcc_assert (GET_CODE (ireg) == REG);\n+\t  gcc_assert (REG_P (ireg));\n \t  fprintf (file, \"[%s]\", reg_names[REGNO (ireg)]);\n \t}\n       break;\n@@ -523,7 +523,7 @@ vax_address_cost_1 (rtx addr)\n static int\n vax_address_cost (rtx x)\n {\n-  return (1 + (GET_CODE (x) == REG ? 0 : vax_address_cost_1 (x)));\n+  return (1 + (REG_P (x) ? 0 : vax_address_cost_1 (x)));\n }\n \n /* Cost of an expression on a VAX.  This version has costs tuned for the\n@@ -725,7 +725,7 @@ vax_rtx_costs (rtx x, int code, int outer_code, int *total)\n       else\n \t*total = 3;\t\t/* 4 on VAX 2 */\n       x = XEXP (x, 0);\n-      if (GET_CODE (x) != REG && GET_CODE (x) != POST_INC)\n+      if (!REG_P (x) && GET_CODE (x) != POST_INC)\n \t*total += vax_address_cost_1 (x);\n       return true;\n \n@@ -789,7 +789,7 @@ vax_rtx_costs (rtx x, int code, int outer_code, int *total)\n \t  break;\n \tcase MEM:\n \t  *total += 1;\t\t/* 2 on VAX 2 */\n-\t  if (GET_CODE (XEXP (op, 0)) != REG)\n+\t  if (!REG_P (XEXP (op, 0)))\n \t    *total += vax_address_cost_1 (XEXP (op, 0));\n \t  break;\n \tcase REG:\n@@ -888,13 +888,13 @@ vax_notice_update_cc (rtx exp, rtx insn ATTRIBUTE_UNUSED)\n     }\n   else\n     CC_STATUS_INIT;\n-  if (cc_status.value1 && GET_CODE (cc_status.value1) == REG\n+  if (cc_status.value1 && REG_P (cc_status.value1)\n       && cc_status.value2\n       && reg_overlap_mentioned_p (cc_status.value1, cc_status.value2))\n     cc_status.value2 = 0;\n-  if (cc_status.value1 && GET_CODE (cc_status.value1) == MEM\n+  if (cc_status.value1 && MEM_P (cc_status.value1)\n       && cc_status.value2\n-      && GET_CODE (cc_status.value2) == MEM)\n+      && MEM_P (cc_status.value2))\n     cc_status.value2 = 0;\n   /* Actual condition, one line up, should be that value2's address\n      depends on value1, but that is too much of a pain.  */\n@@ -999,7 +999,7 @@ vax_output_int_add (rtx insn ATTRIBUTE_UNUSED, rtx *operands,\n \t    return \"subl2 $%n2,%0\";\n \t  if (GET_CODE (operands[2]) == CONST_INT\n \t      && (unsigned) INTVAL (operands[2]) >= 64\n-\t      && GET_CODE (operands[1]) == REG\n+\t      && REG_P (operands[1])\n \t      && ((INTVAL (operands[2]) < 32767 && INTVAL (operands[2]) > -32768)\n \t\t   || REGNO (operands[1]) > 11))\n \t    return \"movab %c2(%1),%0\";\n@@ -1012,7 +1012,7 @@ vax_output_int_add (rtx insn ATTRIBUTE_UNUSED, rtx *operands,\n       if (GET_CODE (operands[2]) == CONST_INT\n \t  && INTVAL (operands[2]) < 32767\n \t  && INTVAL (operands[2]) > -32768\n-\t  && GET_CODE (operands[1]) == REG\n+\t  && REG_P (operands[1])\n \t  && push_operand (operands[0], SImode))\n \treturn \"pushab %c2(%1)\";\n \n@@ -1022,7 +1022,7 @@ vax_output_int_add (rtx insn ATTRIBUTE_UNUSED, rtx *operands,\n \n       if (GET_CODE (operands[2]) == CONST_INT\n \t  && (unsigned) INTVAL (operands[2]) >= 64\n-\t  && GET_CODE (operands[1]) == REG\n+\t  && REG_P (operands[1])\n \t  && ((INTVAL (operands[2]) < 32767 && INTVAL (operands[2]) > -32768)\n \t       || REGNO (operands[1]) > 11))\n \treturn \"movab %c2(%1),%0\";\n@@ -1121,12 +1121,12 @@ legitimate_constant_p (rtx x ATTRIBUTE_UNUSED)\n /* Nonzero if X is a hard reg that can be used as an index\n    or, if not strict, if it is a pseudo reg.  */\n #define\tINDEX_REGISTER_P(X, STRICT) \\\n-(GET_CODE (X) == REG && (!(STRICT) || REGNO_OK_FOR_INDEX_P (REGNO (X))))\n+(REG_P (X) && (!(STRICT) || REGNO_OK_FOR_INDEX_P (REGNO (X))))\n \n /* Nonzero if X is a hard reg that can be used as a base reg\n    or, if not strict, if it is a pseudo reg.  */\n #define\tBASE_REGISTER_P(X, STRICT) \\\n-(GET_CODE (X) == REG && (!(STRICT) || REGNO_OK_FOR_BASE_P (REGNO (X))))\n+(REG_P (X) && (!(STRICT) || REGNO_OK_FOR_BASE_P (REGNO (X))))\n \n #ifdef NO_EXTERNAL_INDIRECT_ADDRESS\n \n@@ -1179,7 +1179,7 @@ static int\n nonindexed_address_p (rtx x, int strict)\n {\n   rtx xfoo0;\n-  if (GET_CODE (x) == REG)\n+  if (REG_P (x))\n     {\n       extern rtx *reg_equiv_mem;\n       if (! reload_in_progress\n@@ -1192,7 +1192,7 @@ nonindexed_address_p (rtx x, int strict)\n   if (indirectable_address_p (x, strict))\n     return 1;\n   xfoo0 = XEXP (x, 0);\n-  if (GET_CODE (x) == MEM && indirectable_address_p (xfoo0, strict))\n+  if (MEM_P (x) && indirectable_address_p (xfoo0, strict))\n     return 1;\n   if ((GET_CODE (x) == PRE_DEC || GET_CODE (x) == POST_INC)\n       && BASE_REGISTER_P (xfoo0, strict))\n@@ -1314,9 +1314,9 @@ vax_mode_dependent_address_p (rtx x)\n   xfoo0 = XEXP (x, 0);\n   xfoo1 = XEXP (x, 1);\n \n-  if (CONSTANT_ADDRESS_P (xfoo0) && GET_CODE (xfoo1) == REG)\n+  if (CONSTANT_ADDRESS_P (xfoo0) && REG_P (xfoo1))\n     return 0;\n-  if (CONSTANT_ADDRESS_P (xfoo1) && GET_CODE (xfoo0) == REG)\n+  if (CONSTANT_ADDRESS_P (xfoo1) && REG_P (xfoo0))\n     return 0;\n \n   return 1;"}, {"sha": "dae115aa1c4a058ec0b659b43a3b7dcec02f3f88", "filename": "gcc/config/vax/vax.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff9d45906de3eee23784071f8e82a9d566d6d074/gcc%2Fconfig%2Fvax%2Fvax.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff9d45906de3eee23784071f8e82a9d566d6d074/gcc%2Fconfig%2Fvax%2Fvax.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.h?ref=ff9d45906de3eee23784071f8e82a9d566d6d074", "patch": "@@ -291,7 +291,7 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n \n #define EXTRA_CONSTRAINT(OP, C)\t\t\t\t\t\t\\\n   ((C) == 'Q'\t\t\t\t\t\t\t\t\\\n-   ? GET_CODE (OP) == MEM && ! mode_dependent_address_p (XEXP (OP, 0))\t\\\n+   ? MEM_P (OP) && ! mode_dependent_address_p (XEXP (OP, 0))\t\\\n    : 0)\n \n /* Given an rtx X being reloaded into a reg required to be\n@@ -891,9 +891,9 @@ VAX operand formatting codes:\n     fprintf (FILE, \"$%d\", (int) (0xff & - INTVAL (X)));\t\t\t\\\n   else if (CODE == 'M' && GET_CODE (X) == CONST_INT)\t\t\t\\\n     fprintf (FILE, \"$%d\", ~((1 << INTVAL (x)) - 1));\t\t\t\\\n-  else if (GET_CODE (X) == REG)\t\t\t\t\t\t\\\n+  else if (REG_P (X))\t\t\t\t\t\t\t\\\n     fprintf (FILE, \"%s\", reg_names[REGNO (X)]);\t\t\t\t\\\n-  else if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n+  else if (MEM_P (X))\t\t\t\t\t\t\t\\\n     output_address (XEXP (X, 0));\t\t\t\t\t\\\n   else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) == SFmode)\t\\\n     { char dstr[30];\t\t\t\t\t\t\t\\"}, {"sha": "2e1a379ea0e8d0436d96b4a6614e12c5cdfeeeb4", "filename": "gcc/config/vax/vax.md", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff9d45906de3eee23784071f8e82a9d566d6d074/gcc%2Fconfig%2Fvax%2Fvax.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff9d45906de3eee23784071f8e82a9d566d6d074/gcc%2Fconfig%2Fvax%2Fvax.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.md?ref=ff9d45906de3eee23784071f8e82a9d566d6d074", "patch": "@@ -648,7 +648,7 @@\n {\n   if (operands[2] == const1_rtx && rtx_equal_p (operands[0], operands[1]))\n     return \\\"addl2 %0,%0\\\";\n-  if (GET_CODE (operands[1]) == REG\n+  if (REG_P (operands[1])\n       && GET_CODE (operands[2]) == CONST_INT)\n     {\n       int i = INTVAL (operands[2]);\n@@ -761,7 +761,7 @@\n \t(match_operand:SI 3 \"general_operand\" \"g\"))]\n    \"(INTVAL (operands[1]) == 8 || INTVAL (operands[1]) == 16)\n    && INTVAL (operands[2]) % INTVAL (operands[1]) == 0\n-   && (GET_CODE (operands[0]) == REG\n+   && (REG_P (operands[0])\n        || ! mode_dependent_address_p (XEXP (operands[0], 0)))\"\n   \"*\n {\n@@ -789,7 +789,7 @@\n \t\t\t (match_operand:SI 3 \"const_int_operand\" \"n\")))]\n   \"(INTVAL (operands[2]) == 8 || INTVAL (operands[2]) == 16)\n    && INTVAL (operands[3]) % INTVAL (operands[2]) == 0\n-   && (GET_CODE (operands[1]) == REG\n+   && (REG_P (operands[1])\n        || ! mode_dependent_address_p (XEXP (operands[1], 0)))\"\n   \"*\n {\n@@ -816,7 +816,7 @@\n \t\t\t (match_operand:SI 3 \"const_int_operand\" \"n\")))]\n   \"(INTVAL (operands[2]) == 8 || INTVAL (operands[2]) == 16)\n    && INTVAL (operands[3]) % INTVAL (operands[2]) == 0\n-   && (GET_CODE (operands[1]) == REG\n+   && (REG_P (operands[1])\n        || ! mode_dependent_address_p (XEXP (operands[1], 0)))\"\n   \"*\n {\n@@ -872,7 +872,7 @@\n   \"*\n {\n   if (GET_CODE (operands[3]) != CONST_INT || GET_CODE (operands[2]) != CONST_INT\n-      || GET_CODE (operands[0]) != REG\n+      || !REG_P (operands[0])\n       || (INTVAL (operands[2]) != 8 && INTVAL (operands[2]) != 16))\n     return \\\"extv %3,%2,%1,%0\\\";\n   if (INTVAL (operands[2]) == 8)\n@@ -889,7 +889,7 @@\n   \"*\n {\n   if (GET_CODE (operands[3]) != CONST_INT || GET_CODE (operands[2]) != CONST_INT\n-      || GET_CODE (operands[0]) != REG)\n+      || !REG_P (operands[0]))\n     return \\\"extzv %3,%2,%1,%0\\\";\n   if (INTVAL (operands[2]) == 8)\n     return \\\"rotl %R3,%1,%0\\;movzbl %0,%0\\\";\n@@ -934,12 +934,12 @@\n   \"\"\n   \"*\n {\n-  if (GET_CODE (operands[0]) != REG || GET_CODE (operands[2]) != CONST_INT\n+  if (!REG_P (operands[0]) || GET_CODE (operands[2]) != CONST_INT\n       || GET_CODE (operands[3]) != CONST_INT\n       || (INTVAL (operands[2]) != 8 && INTVAL (operands[2]) != 16)\n       || INTVAL (operands[2]) + INTVAL (operands[3]) > 32\n       || side_effects_p (operands[1])\n-      || (GET_CODE (operands[1]) == MEM\n+      || (MEM_P (operands[1])\n \t  && mode_dependent_address_p (XEXP (operands[1], 0))))\n     return \\\"extv %3,%2,%1,%0\\\";\n   if (INTVAL (operands[2]) == 8)\n@@ -963,11 +963,11 @@\n   \"\"\n   \"*\n {\n-  if (GET_CODE (operands[0]) != REG || GET_CODE (operands[2]) != CONST_INT\n+  if (! REG_P (operands[0]) || GET_CODE (operands[2]) != CONST_INT\n       || GET_CODE (operands[3]) != CONST_INT\n       || INTVAL (operands[2]) + INTVAL (operands[3]) > 32\n       || side_effects_p (operands[1])\n-      || (GET_CODE (operands[1]) == MEM\n+      || (MEM_P (operands[1])\n \t  && mode_dependent_address_p (XEXP (operands[1], 0))))\n     return \\\"extzv %3,%2,%1,%0\\\";\n   if (INTVAL (operands[2]) == 8)"}]}