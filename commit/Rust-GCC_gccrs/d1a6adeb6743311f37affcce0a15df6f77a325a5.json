{"sha": "d1a6adeb6743311f37affcce0a15df6f77a325a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDFhNmFkZWI2NzQzMzExZjM3YWZmY2NlMGExNWRmNmY3N2EzMjVhNQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-03-20T05:21:41Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-03-20T05:21:41Z"}, "message": "c-common.c, [...]: Fix comment typos.\n\n\t* c-common.c, cfgcleanup.c, cgraphunit.c, c-pretty-print.c,\n\texpmed.c, ggc-common.c, jump.c, passes.c, recog.c, regmove.c,\n\treorg.c, tree.h: Fix comment typos.\n\nFrom-SVN: r79730", "tree": {"sha": "89910945dd096ed9ce8332b32730542c69fd2051", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/89910945dd096ed9ce8332b32730542c69fd2051"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d1a6adeb6743311f37affcce0a15df6f77a325a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1a6adeb6743311f37affcce0a15df6f77a325a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1a6adeb6743311f37affcce0a15df6f77a325a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1a6adeb6743311f37affcce0a15df6f77a325a5/comments", "author": null, "committer": null, "parents": [{"sha": "5fd9b17875e5e720108ed599b262ad9464576956", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fd9b17875e5e720108ed599b262ad9464576956", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fd9b17875e5e720108ed599b262ad9464576956"}], "stats": {"total": 45, "additions": 26, "deletions": 19}, "files": [{"sha": "292b9561ef869d9d6a4a91823f1048b00ab1fceb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1a6adeb6743311f37affcce0a15df6f77a325a5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1a6adeb6743311f37affcce0a15df6f77a325a5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d1a6adeb6743311f37affcce0a15df6f77a325a5", "patch": "@@ -1,3 +1,9 @@\n+2004-03-20  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* c-common.c, cfgcleanup.c, cgraphunit.c, c-pretty-print.c,\n+\texpmed.c, ggc-common.c, jump.c, passes.c, recog.c, regmove.c,\n+\treorg.c, tree.h: Fix comment typos.\n+\n 2004-03-19  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* alias.c, attribs.c, bt-load.c, builtins.c, c-common.c,"}, {"sha": "5f79d37f413712908014e4c6ae08e6de8029b436", "filename": "gcc/c-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1a6adeb6743311f37affcce0a15df6f77a325a5/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1a6adeb6743311f37affcce0a15df6f77a325a5/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=d1a6adeb6743311f37affcce0a15df6f77a325a5", "patch": "@@ -2229,7 +2229,7 @@ shorten_compare (tree *op0_ptr, tree *op1_ptr, tree *restype_ptr,\n \t\t\t\t\t       TREE_TYPE (primop0));\n \n       /* In C, if TYPE is an enumeration, then we need to get its\n-\t min/max values from it's underlying integral type, not the\n+\t min/max values from its underlying integral type, not the\n \t enumerated type itself.  In C++, TYPE_MAX_VALUE and\n \t TYPE_MIN_VALUE have already been set correctly on the\n \t enumeration type.  */"}, {"sha": "51e34e7720839a8bcff91a07915c5c6deeeba290", "filename": "gcc/c-pretty-print.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1a6adeb6743311f37affcce0a15df6f77a325a5/gcc%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1a6adeb6743311f37affcce0a15df6f77a325a5/gcc%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pretty-print.c?ref=d1a6adeb6743311f37affcce0a15df6f77a325a5", "patch": "@@ -932,7 +932,7 @@ pp_c_constant (c_pretty_printer *pp, tree e)\n     }\n }\n \n-/* Pretty-print an IDENTIFIER_NODE, precedeed by whitespace is necessary.  */\n+/* Pretty-print an IDENTIFIER_NODE, preceded by whitespace is necessary.  */\n \n void\n pp_c_identifier (c_pretty_printer *pp, const char *id)"}, {"sha": "3cde9b27ab8781bd5a720e064d73332073bbacff", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1a6adeb6743311f37affcce0a15df6f77a325a5/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1a6adeb6743311f37affcce0a15df6f77a325a5/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=d1a6adeb6743311f37affcce0a15df6f77a325a5", "patch": "@@ -23,7 +23,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    cleanup_cfg.  Following optimizations are performed:\n \n    - Unreachable blocks removal\n-   - Edge forwarding (edge to the forwarder block is forwarded to it's\n+   - Edge forwarding (edge to the forwarder block is forwarded to its\n      successor.  Simplification of the branch instruction is performed by\n      underlying infrastructure so branch can be converted to simplejump or\n      eliminated)."}, {"sha": "f871ef4ed6ea60b9de0b6ad847a92dc09abb7403", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1a6adeb6743311f37affcce0a15df6f77a325a5/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1a6adeb6743311f37affcce0a15df6f77a325a5/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=d1a6adeb6743311f37affcce0a15df6f77a325a5", "patch": "@@ -398,7 +398,7 @@ cgraph_finalize_compilation_unit (void)\n       cgraph_nodes_queue = cgraph_nodes_queue->next_needed;\n \n       /* ??? It is possible to create extern inline function and later using\n-\t weak alas attribute to kill it's body. See\n+\t weak alas attribute to kill its body. See\n \t gcc.c-torture/compile/20011119-1.c  */\n       if (!DECL_SAVED_TREE (decl))\n \tcontinue;\n@@ -1508,7 +1508,7 @@ cgraph_inline_p (tree caller_decl, tree callee_decl, const char **reason)\n    Attempt to topologically sort the nodes so function is output when\n    all called functions are already assembled to allow data to be\n    propagated across the callgraph.  Use a stack to get smaller distance\n-   between a function and it's callees (later we may choose to use a more\n+   between a function and its callees (later we may choose to use a more\n    sophisticated algorithm for function reordering; we will likely want\n    to use subsections to make the output functions appear in top-down\n    order).  */\n@@ -1543,7 +1543,7 @@ cgraph_expand_all_functions (void)\n /* Mark all local functions.\n \n    A local function is one whose calls can occur only in the\n-   current compilation unit and all it's calls are explicit,\n+   current compilation unit and all its calls are explicit,\n    so we can change its calling convention.\n    We simply mark all static functions whose address is not taken\n    as local.  */"}, {"sha": "bb42ce92919ad802017b7d12e853ea0e1b984f66", "filename": "gcc/expmed.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1a6adeb6743311f37affcce0a15df6f77a325a5/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1a6adeb6743311f37affcce0a15df6f77a325a5/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=d1a6adeb6743311f37affcce0a15df6f77a325a5", "patch": "@@ -2409,7 +2409,7 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n \t  alg_out->ops * sizeof *alg_out->log);\n }\n \f\n-/* Find the cheapeast way of multiplying a value of mode MODE by VAL.\n+/* Find the cheapest way of multiplying a value of mode MODE by VAL.\n    Try three variations:\n \n        - a shift/add sequence based on VAL itself"}, {"sha": "4939cb6988886ed9ef870ada95a1305caad68e07", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1a6adeb6743311f37affcce0a15df6f77a325a5/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1a6adeb6743311f37affcce0a15df6f77a325a5/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=d1a6adeb6743311f37affcce0a15df6f77a325a5", "patch": "@@ -615,7 +615,7 @@ default_gt_pch_use_address (void *base, size_t size, int fd ATTRIBUTE_UNUSED,\n #if HAVE_MMAP_FILE\n /* Default version of HOST_HOOKS_GT_PCH_GET_ADDRESS when mmap is present.\n    We temporarily allocate SIZE bytes, and let the kernel place the data\n-   whereever it will.  If it worked, that's our spot, if not we're likely\n+   wherever it will.  If it worked, that's our spot, if not we're likely\n    to be in trouble.  */\n \n void *\n@@ -793,9 +793,10 @@ loc_descriptor (const char *name, int line, const char *function)\n   return *slot;\n }\n \n-/* Record ALLOCATED and OVERHEAD bytes to descritor NAME:LINE (FUNCTION).  */\n-void ggc_record_overhead (size_t allocated, size_t overhead,\n-\t\t\t  const char *name, int line, const char *function)\n+/* Record ALLOCATED and OVERHEAD bytes to descriptor NAME:LINE (FUNCTION).  */\n+void\n+ggc_record_overhead (size_t allocated, size_t overhead,\n+\t\t     const char *name, int line, const char *function)\n {\n   struct loc_descriptor *loc = loc_descriptor (name, line, function);\n "}, {"sha": "643a714c7ad0c312ee2673786fb8e424688b7fc0", "filename": "gcc/jump.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1a6adeb6743311f37affcce0a15df6f77a325a5/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1a6adeb6743311f37affcce0a15df6f77a325a5/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=d1a6adeb6743311f37affcce0a15df6f77a325a5", "patch": "@@ -645,9 +645,9 @@ reversed_comparison_code_parts (enum rtx_code code, rtx arg0, rtx arg1, rtx insn\n   if (mode == VOIDmode)\n     mode = GET_MODE (arg1);\n \n-  /* First see if machine description supply us way to reverse the comparison.\n-     Give it priority over everything else to allow machine description to do\n-     tricks.  */\n+  /* First see if machine description supplies us way to reverse the\n+     comparison.  Give it priority over everything else to allow\n+     machine description to do tricks.  */\n   if (GET_MODE_CLASS (mode) == MODE_CC\n       && REVERSIBLE_CC_MODE (mode))\n     {"}, {"sha": "5ee44d4a6545fbf723875df57e463e0e16e2b2a9", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1a6adeb6743311f37affcce0a15df6f77a325a5/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1a6adeb6743311f37affcce0a15df6f77a325a5/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=d1a6adeb6743311f37affcce0a15df6f77a325a5", "patch": "@@ -1677,7 +1677,7 @@ rest_of_compilation (tree decl)\n \n #ifdef SETJMP_VIA_SAVE_AREA\n   /* This must be performed before virtual register instantiation.\n-     Please be aware the everything in the compiler that can look\n+     Please be aware that everything in the compiler that can look\n      at the RTL up to this point must understand that REG_SAVE_AREA\n      is just like a use of the REG contained inside.  */\n   if (current_function_calls_alloca)"}, {"sha": "6d6135a565806a291ce2ba5cf8db1ab943bf6eb4", "filename": "gcc/recog.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1a6adeb6743311f37affcce0a15df6f77a325a5/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1a6adeb6743311f37affcce0a15df6f77a325a5/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=d1a6adeb6743311f37affcce0a15df6f77a325a5", "patch": "@@ -1591,7 +1591,7 @@ decode_asm_operands (rtx body, rtx *operands, rtx **operand_locs,\n   return template;\n }\n \n-/* Check if an asm_operand matches it's constraints.\n+/* Check if an asm_operand matches its constraints.\n    Return > 0 if ok, = 0 if bad, < 0 if inconclusive.  */\n \n int"}, {"sha": "13a6d39bdea66a3db5b63503f5e5f48ea2345cf6", "filename": "gcc/regmove.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1a6adeb6743311f37affcce0a15df6f77a325a5/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1a6adeb6743311f37affcce0a15df6f77a325a5/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=d1a6adeb6743311f37affcce0a15df6f77a325a5", "patch": "@@ -291,7 +291,7 @@ mark_flags_life_zones (rtx flags)\n #endif\n \t      PUT_MODE (insn, (live ? HImode : VOIDmode));\n \n-\t      /* In either case, birth is denoted simply by it's presence\n+\t      /* In either case, birth is denoted simply by its presence\n \t\t as the destination of a set.  */\n \t      flags_set_1_set = 0;\n \t      note_stores (PATTERN (insn), flags_set_1, NULL);"}, {"sha": "9a58d34b29f658071b729656968532e92e72a308", "filename": "gcc/reorg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1a6adeb6743311f37affcce0a15df6f77a325a5/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1a6adeb6743311f37affcce0a15df6f77a325a5/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=d1a6adeb6743311f37affcce0a15df6f77a325a5", "patch": "@@ -3170,7 +3170,7 @@ relax_delay_slots (rtx first)\n \n       /* See if we have a RETURN insn with a filled delay slot followed\n \t by a RETURN insn with an unfilled a delay slot.  If so, we can delete\n-\t the first RETURN (but not it's delay insn).  This gives the same\n+\t the first RETURN (but not its delay insn).  This gives the same\n \t effect in fewer instructions.\n \n \t Only do so if optimizing for size since this results in slower, but"}, {"sha": "5e5a88e6d8fd56cbb6924f5fd5ab1c1a7a5a41f4", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1a6adeb6743311f37affcce0a15df6f77a325a5/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1a6adeb6743311f37affcce0a15df6f77a325a5/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=d1a6adeb6743311f37affcce0a15df6f77a325a5", "patch": "@@ -1000,7 +1000,7 @@ struct tree_block GTY(())\n /* See tree.def for documentation of the use of these fields.\n    Look at the documentation of the various ..._TYPE tree codes.\n \n-   Note that the type.values, type.minval, and type.maxval fiels are\n+   Note that the type.values, type.minval, and type.maxval fields are\n    overloaded and used for different macros in different kinds of types.\n    Each macro must check to ensure the tree node is of the proper kind of\n    type.  Note also that some of the front-ends also overload these fields,"}]}