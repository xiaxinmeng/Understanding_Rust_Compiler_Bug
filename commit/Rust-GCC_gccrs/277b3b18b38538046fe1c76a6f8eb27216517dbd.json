{"sha": "277b3b18b38538046fe1c76a6f8eb27216517dbd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjc3YjNiMThiMzg1MzgwNDZmZTFjNzZhNmY4ZWIyNzIxNjUxN2RiZA==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "joern.rennecke@superh.com", "date": "2003-04-22T11:41:58Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2003-04-22T11:41:58Z"}, "message": "function.c (purge_addressof_1): In (mem (addressof (reg))) case for reg notes...\n\n\t* function.c (purge_addressof_1): In (mem (addressof (reg))) case\n\tfor reg notes, if there are no substitutions, just use a SUBREG.\n\nFrom-SVN: r65934", "tree": {"sha": "c049d277acc5ca50bb350b36ee01d6ea5f202863", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c049d277acc5ca50bb350b36ee01d6ea5f202863"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/277b3b18b38538046fe1c76a6f8eb27216517dbd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/277b3b18b38538046fe1c76a6f8eb27216517dbd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/277b3b18b38538046fe1c76a6f8eb27216517dbd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/277b3b18b38538046fe1c76a6f8eb27216517dbd/comments", "author": null, "committer": null, "parents": [{"sha": "6adb9463cd343bcab5a1b9842894cdc90d5249b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6adb9463cd343bcab5a1b9842894cdc90d5249b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6adb9463cd343bcab5a1b9842894cdc90d5249b3"}], "stats": {"total": 35, "additions": 35, "deletions": 0}, "files": [{"sha": "9965b90bca1823c5e7aed95b933bad18563d34de", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/277b3b18b38538046fe1c76a6f8eb27216517dbd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/277b3b18b38538046fe1c76a6f8eb27216517dbd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=277b3b18b38538046fe1c76a6f8eb27216517dbd", "patch": "@@ -1,3 +1,8 @@\n+2003-04-22  J\"orn Rennecke <joern.rennecke@superh.com>\n+\n+\t* function.c (purge_addressof_1): In (mem (addressof (reg))) case\n+\tfor reg notes, if there are no substitutions, just use a SUBREG.\n+\n 2003-04-21  Mark Mitchell  <mark@codesourcery.com>\n \n \t* Makefile.in (calls.o): Depend on except.h."}, {"sha": "de10f7310037c43eb6d4ad91a573dd4e912b61c3", "filename": "gcc/function.c", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/277b3b18b38538046fe1c76a6f8eb27216517dbd/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/277b3b18b38538046fe1c76a6f8eb27216517dbd/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=277b3b18b38538046fe1c76a6f8eb27216517dbd", "patch": "@@ -3147,6 +3147,36 @@ purge_addressof_1 (loc, insn, force, store, may_postpone, ht)\n \t\t    return true;\n \t\t  }\n \n+\t      /* When we are processing the REG_NOTES of the last instruction\n+\t\t of a libcall, there will be typically no replacements\n+\t\t for that insn; the replacements happened before, piecemeal\n+\t\t fashion.  OTOH we are not interested in the details of\n+\t\t this for the REG_EQUAL note, we want to know the big picture,\n+\t\t which can be succinctly described with a simple SUBREG.\n+\t\t Note that removing the REG_EQUAL note is not an option\n+\t\t on the last insn of a libcall, so we must do a replacement.  */\n+\t      if (! purge_addressof_replacements\n+\t\t  && ! purge_bitfield_addressof_replacements)\n+\t\t{\n+\t\t  /* In compile/990107-1.c:7 compiled at -O1 -m1 for sh-elf,\n+\t\t     we got\n+\t\t     (mem:DI (addressof:SI (reg/v:DF 160) 159 0x401c8510)\n+\t\t      [0 S8 A32]), which can be expressed with a simple\n+\t\t     same-size subreg  */\n+\t\t  if ((GET_MODE_SIZE (GET_MODE (x))\n+\t\t       == GET_MODE_SIZE (GET_MODE (sub)))\n+\t\t      /* Again, invalid pointer casts (as in\n+\t\t\t compile/990203-1.c) can require paradoxical\n+\t\t\t subregs.  */\n+\t\t      || (GET_MODE_SIZE (GET_MODE (x)) > UNITS_PER_WORD\n+\t\t\t  && (GET_MODE_SIZE (GET_MODE (x))\n+\t\t\t      > GET_MODE_SIZE (GET_MODE (sub)))))\n+\t\t    {\n+\t\t      *loc = gen_rtx_SUBREG (GET_MODE (x), sub, 0);\n+\t\t      return true;\n+\t\t    }\n+\t\t  /* ??? Are there other cases we should handle?  */\n+\t\t}\n \t      /* Sometimes we may not be able to find the replacement.  For\n \t\t example when the original insn was a MEM in a wider mode,\n \t\t and the note is part of a sign extension of a narrowed"}]}