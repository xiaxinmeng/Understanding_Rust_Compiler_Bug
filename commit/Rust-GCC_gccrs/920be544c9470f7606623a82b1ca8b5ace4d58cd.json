{"sha": "920be544c9470f7606623a82b1ca8b5ace4d58cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTIwYmU1NDRjOTQ3MGY3NjA2NjIzYTgyYjFjYThiNWFjZTRkNThjZA==", "commit": {"author": {"name": "Guilhem Lavaux", "email": "guilhem@kaffe.org", "date": "2003-12-28T11:54:17Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-12-28T11:54:17Z"}, "message": "2003-12-28  Guilhem Lavaux <guilhem@kaffe.org>\n\n\t* java/io/LineNumberReader.java\n\t(mark): Improved error checking.\n\t(read): Likewise.\n\t(skip): Likewise. Skip is now really eating the specified number of\n\tcharacters.\n\t* java/io/CharArrayReader.java (read): It should throw\n\tIndexOutOfBoundsException and not ArrayIndexOutOfBoundsException (see\n\tmauve).\n\t* java/io/BufferedReader.java (readLine): Make readLine() really block\n\tuntil either EOF is reached or a true error happens.\n\nFrom-SVN: r75180", "tree": {"sha": "41837312c288c51281dc7c93eade8553e241f38a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/41837312c288c51281dc7c93eade8553e241f38a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/920be544c9470f7606623a82b1ca8b5ace4d58cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/920be544c9470f7606623a82b1ca8b5ace4d58cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/920be544c9470f7606623a82b1ca8b5ace4d58cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/920be544c9470f7606623a82b1ca8b5ace4d58cd/comments", "author": null, "committer": null, "parents": [{"sha": "07dc48e01452222a461e6660d242cf497b3f584d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07dc48e01452222a461e6660d242cf497b3f584d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07dc48e01452222a461e6660d242cf497b3f584d"}], "stats": {"total": 50, "additions": 42, "deletions": 8}, "files": [{"sha": "493c3bb34074ef324d18326d78745fa2bc6d397f", "filename": "libjava/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/920be544c9470f7606623a82b1ca8b5ace4d58cd/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/920be544c9470f7606623a82b1ca8b5ace4d58cd/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=920be544c9470f7606623a82b1ca8b5ace4d58cd", "patch": "@@ -1,3 +1,16 @@\n+2003-12-28  Guilhem Lavaux <guilhem@kaffe.org>\n+\n+\t* java/io/LineNumberReader.java\n+\t(mark): Improved error checking.\n+\t(read): Likewise.\n+\t(skip): Likewise. Skip is now really eating the specified number of\n+\tcharacters.\n+\t* java/io/CharArrayReader.java (read): It should throw\n+\tIndexOutOfBoundsException and not ArrayIndexOutOfBoundsException (see\n+\tmauve).\n+\t* java/io/BufferedReader.java (readLine): Make readLine() really block\n+\tuntil either EOF is reached or a true error happens.\n+\n 2003-12-27  Michael Koch  <konqueror@gmx.de>\n \n \t* gnu/java/net/protocol/http/Connection.java"}, {"sha": "e29c8dd88442a157d43726f176522c0b7bbdb757", "filename": "libjava/java/io/BufferedReader.java", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/920be544c9470f7606623a82b1ca8b5ace4d58cd/libjava%2Fjava%2Fio%2FBufferedReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/920be544c9470f7606623a82b1ca8b5ace4d58cd/libjava%2Fjava%2Fio%2FBufferedReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FBufferedReader.java?ref=920be544c9470f7606623a82b1ca8b5ace4d58cd", "patch": "@@ -460,12 +460,19 @@ public String readLine() throws IOException\n     boolean eof = false;\n     for (;;)\n       {\n-\tint ch = read();\n-\tif (ch < 0)\n+\t// readLine should block. So we must not return until a -1 is reached.\n+\tif (pos >= limit)\n \t  {\n-\t    eof = true;\n-\t    break;\n+\t    // here count == 0 isn't sufficient to give a failure.\n+\t    int count = fill();\n+\t    if (count < 0)\n+\t      {\n+\t\teof = true;\n+\t\tbreak;\n+\t      }\n+\t    continue;\n \t  }\n+\tint ch = buffer[pos++];\n \tif (ch == '\\n' || ch == '\\r')\n \t  {\n \t    // Check here if a '\\r' was the last char in the buffer; if so,"}, {"sha": "9d5382bef1e80276e1b50f8a98b8830bdf60cc5f", "filename": "libjava/java/io/CharArrayReader.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/920be544c9470f7606623a82b1ca8b5ace4d58cd/libjava%2Fjava%2Fio%2FCharArrayReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/920be544c9470f7606623a82b1ca8b5ace4d58cd/libjava%2Fjava%2Fio%2FCharArrayReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FCharArrayReader.java?ref=920be544c9470f7606623a82b1ca8b5ace4d58cd", "patch": "@@ -228,7 +228,7 @@ public int read(char[] b, int off, int len) throws IOException\n \n \t/* Don't need to check pos value, arraycopy will check it. */\n \tif (off < 0 || len < 0 || off + len > b.length)\n-\t  throw new ArrayIndexOutOfBoundsException();\n+\t  throw new IndexOutOfBoundsException();\n \n \tif (pos >= count)\n \t  return -1;"}, {"sha": "439a760fbf11556c6c3d99799dc0b0d58cf94551", "filename": "libjava/java/io/LineNumberReader.java", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/920be544c9470f7606623a82b1ca8b5ace4d58cd/libjava%2Fjava%2Fio%2FLineNumberReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/920be544c9470f7606623a82b1ca8b5ace4d58cd/libjava%2Fjava%2Fio%2FLineNumberReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FLineNumberReader.java?ref=920be544c9470f7606623a82b1ca8b5ace4d58cd", "patch": "@@ -155,6 +155,9 @@ private static int countLines (char[] buffer, int off, int len)\n     */\n   public void mark(int readLimit) throws IOException\n   {\n+    if (readLimit < 0)\n+      throw new IllegalArgumentException(\"Read-ahead limit is negative\");\n+\n     synchronized (lock)\n       {\n \t// This is basically the same as BufferedReader.mark.\n@@ -265,9 +268,17 @@ public int read() throws IOException\n     * @return The actual number of chars read, or -1 if end of stream\n     *\n     * @exception IOException If an error occurs.\n+    * @exception NullPointerException If buf is null (in any case).\n+    * @exception IndexOutOfBoundsException If buffer parameters (offset and\n+    * count) lies outside of the buffer capacity.\n     */\n   public int read(char[] buf, int offset, int count) throws IOException\n   {\n+    if (buf == null)\n+      throw new NullPointerException();\n+    if (offset + count > buf.length || offset < 0)\n+      throw new IndexOutOfBoundsException();\n+\n     if (count <= 0)\n       {\n \tif (count < 0)\n@@ -376,14 +387,17 @@ public String readLine() throws IOException\n     */\n   public long skip (long count) throws IOException\n   {\n-    if (count <= 0)\n+    if (count < 0)\n+      throw new IllegalArgumentException(\"skip() value is negative\");\n+    if (count == 0)\n       return 0;\n \n     int skipped;\n-    \n+    char[] buf = new char[1];\n+   \n     for (skipped = 0; skipped < count; skipped++)\n       {\n-        int ch = read();\n+        int ch = read(buf, 0, 1);\n \n         if (ch < 0)\n           break;"}]}