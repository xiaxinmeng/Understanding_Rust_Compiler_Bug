{"sha": "77022fa8734fdd0b5ac892ba109b77e0ec7dd13b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzcwMjJmYTg3MzRmZGQwYjVhYzg5MmJhMTA5Yjc3ZTBlYzdkZDEzYg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2009-04-20T17:41:33Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2009-04-20T17:41:33Z"}, "message": "ada-tree.h (DECL_HAS_REP_P): Delete.\n\n\t* gcc-interface/ada-tree.h (DECL_HAS_REP_P): Delete.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity): Add support for extension\n\tof types with unknown discriminants.\n\t(substitute_in_type): Rewrite and restrict to formal substitutions.\n\t* gcc-interface/utils.c (create_field_decl): Do not set DECL_HAS_REP_P.\n\t(update_pointer_to): Update comment.\n\nFrom-SVN: r146447", "tree": {"sha": "3ce42ab31f3cb68208edbe8786a1bfaa418b3238", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ce42ab31f3cb68208edbe8786a1bfaa418b3238"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/77022fa8734fdd0b5ac892ba109b77e0ec7dd13b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77022fa8734fdd0b5ac892ba109b77e0ec7dd13b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77022fa8734fdd0b5ac892ba109b77e0ec7dd13b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77022fa8734fdd0b5ac892ba109b77e0ec7dd13b/comments", "author": null, "committer": null, "parents": [{"sha": "d9d3eaab8c71fd2efa242d244b9279b4311dc807", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9d3eaab8c71fd2efa242d244b9279b4311dc807", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9d3eaab8c71fd2efa242d244b9279b4311dc807"}], "stats": {"total": 276, "additions": 137, "deletions": 139}, "files": [{"sha": "0c0ed033017d0f61db1cb45bde44e10797e2bc07", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77022fa8734fdd0b5ac892ba109b77e0ec7dd13b/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77022fa8734fdd0b5ac892ba109b77e0ec7dd13b/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=77022fa8734fdd0b5ac892ba109b77e0ec7dd13b", "patch": "@@ -1,3 +1,12 @@\n+2009-04-20  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/ada-tree.h (DECL_HAS_REP_P): Delete.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity): Add support for extension\n+\tof types with unknown discriminants.\n+\t(substitute_in_type): Rewrite and restrict to formal substitutions.\n+\t* gcc-interface/utils.c (create_field_decl): Do not set DECL_HAS_REP_P.\n+\t(update_pointer_to): Update comment.\n+\n 2009-04-20  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_ch8.adb (Use_One_Package): In an instance, if two"}, {"sha": "846dc909dd496ee54a62e018c778887ee1208f43", "filename": "gcc/ada/gcc-interface/ada-tree.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77022fa8734fdd0b5ac892ba109b77e0ec7dd13b/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77022fa8734fdd0b5ac892ba109b77e0ec7dd13b/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada-tree.h?ref=77022fa8734fdd0b5ac892ba109b77e0ec7dd13b", "patch": "@@ -249,9 +249,6 @@ struct lang_type GTY(()) {tree t; };\n    is readonly.  Used mostly for fat pointers.  */\n #define DECL_POINTS_TO_READONLY_P(NODE) DECL_LANG_FLAG_4 (NODE)\n \n-/* Nonzero in a FIELD_DECL if there was a record rep clause.  */\n-#define DECL_HAS_REP_P(NODE) DECL_LANG_FLAG_5 (FIELD_DECL_CHECK (NODE))\n-\n /* Nonzero in a PARM_DECL if we are to pass by descriptor.  */\n #define DECL_BY_DESCRIPTOR_P(NODE) DECL_LANG_FLAG_5 (PARM_DECL_CHECK (NODE))\n "}, {"sha": "a06248e4a4404895a4f3f5319e976a8e541af571", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 96, "deletions": 130, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77022fa8734fdd0b5ac892ba109b77e0ec7dd13b/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77022fa8734fdd0b5ac892ba109b77e0ec7dd13b/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=77022fa8734fdd0b5ac892ba109b77e0ec7dd13b", "patch": "@@ -2765,8 +2765,46 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t     NULL_TREE),\n \t\t     true);\n \n-\t    /* Then we build the parent subtype.  */\n-\t    gnu_parent = gnat_to_gnu_type (gnat_parent);\n+\t    /* Then we build the parent subtype.  If it has discriminants but\n+\t       the type itself has unknown discriminants, this means that it\n+\t       doesn't contain information about how the discriminants are\n+\t       derived from those of the ancestor type, so it cannot be used\n+\t       directly.  Instead it is built by cloning the parent subtype\n+\t       of the underlying record view of the type, for which the above\n+\t       derivation of discriminants has been made explicit.  */\n+\t    if (Has_Discriminants (gnat_parent)\n+\t\t&& Has_Unknown_Discriminants (gnat_entity))\n+\t      {\n+\t\tEntity_Id gnat_uview = Underlying_Record_View (gnat_entity);\n+\n+\t\t/* If we are defining the type, the underlying record\n+\t\t   view must already have been elaborated at this point.\n+\t\t   Otherwise do it now as its parent subtype cannot be\n+\t\t   technically elaborated on its own.  */\n+\t\tif (definition)\n+\t\t  gcc_assert (present_gnu_tree (gnat_uview));\n+\t\telse\n+\t\t  gnat_to_gnu_entity (gnat_uview, NULL_TREE, 0);\n+\n+\t\tgnu_parent = gnat_to_gnu_type (Parent_Subtype (gnat_uview));\n+\n+\t\t/* Substitute the \"get to the parent\" of the type for that\n+\t\t   of its underlying record view in the cloned type.  */\n+\t\tfor (gnat_field = First_Stored_Discriminant (gnat_uview);\n+\t\t     Present (gnat_field);\n+\t\t     gnat_field = Next_Stored_Discriminant (gnat_field))\n+\t\t  if (Present (Corresponding_Discriminant (gnat_field)))\n+\t\t    {\n+\t\t      tree gnu_field = gnat_to_gnu_field_decl (gnat_field);\n+\t\t      tree gnu_ref\n+\t\t\t= build3 (COMPONENT_REF, TREE_TYPE (gnu_field),\n+\t\t\t\t  gnu_get_parent, gnu_field, NULL_TREE);\n+\t\t      gnu_parent\n+\t\t\t= substitute_in_type (gnu_parent, gnu_field, gnu_ref);\n+\t\t    }\n+\t      }\n+\t    else\n+\t      gnu_parent = gnat_to_gnu_type (gnat_parent);\n \n \t    /* Finally we fix up both kinds of twisted COMPONENT_REF we have\n \t       initially built.  The discriminants must reference the fields\n@@ -7526,16 +7564,20 @@ compatible_signatures_p (tree ftype1, tree ftype2)\n   return 1;\n }\n \f\n-/* Given a type T, a FIELD_DECL F, and a replacement value R, return a new\n-   type with all size expressions that contain F updated by replacing F\n-   with R.  If F is NULL_TREE, always make a new RECORD_TYPE, even if\n-   nothing has changed.  */\n+/* Given a type T, a FIELD_DECL F, and a replacement value R, return a\n+   type with all size expressions that contain F in a PLACEHOLDER_EXPR\n+   updated by replacing F with R.\n+\n+   The function doesn't update the layout of the type, i.e. it assumes\n+   that the substitution is purely formal.  That's why the replacement\n+   value R must itself contain a PLACEHOLDER_EXPR.  */\n \n tree\n substitute_in_type (tree t, tree f, tree r)\n {\n-  tree new = t;\n-  tree tem;\n+  tree new;\n+\n+  gcc_assert (CONTAINS_PLACEHOLDER_P (r));\n \n   switch (TREE_CODE (t))\n     {\n@@ -7564,34 +7606,32 @@ substitute_in_type (tree t, tree f, tree r)\n       if (CONTAINS_PLACEHOLDER_P (TYPE_MIN_VALUE (t))\n \t  || CONTAINS_PLACEHOLDER_P (TYPE_MAX_VALUE (t)))\n \t{\n-\t  tree low = NULL_TREE, high = NULL_TREE;\n-\n-\t  if (TYPE_MIN_VALUE (t))\n-\t    low = SUBSTITUTE_IN_EXPR (TYPE_MIN_VALUE (t), f, r);\n-\t  if (TYPE_MAX_VALUE (t))\n-\t    high = SUBSTITUTE_IN_EXPR (TYPE_MAX_VALUE (t), f, r);\n+\t  tree low = SUBSTITUTE_IN_EXPR (TYPE_MIN_VALUE (t), f, r);\n+\t  tree high = SUBSTITUTE_IN_EXPR (TYPE_MAX_VALUE (t), f, r);\n \n \t  if (low == TYPE_MIN_VALUE (t) && high == TYPE_MAX_VALUE (t))\n \t    return t;\n \n-\t  t = copy_type (t);\n-\t  TYPE_MIN_VALUE (t) = low;\n-\t  TYPE_MAX_VALUE (t) = high;\n+\t  new = copy_type (t);\n+\t  TYPE_MIN_VALUE (new) = low;\n+\t  TYPE_MAX_VALUE (new) = high;\n+\t  return new;\n \t}\n+\n       return t;\n \n     case COMPLEX_TYPE:\n-      tem = substitute_in_type (TREE_TYPE (t), f, r);\n-      if (tem == TREE_TYPE (t))\n+      new = substitute_in_type (TREE_TYPE (t), f, r);\n+      if (new == TREE_TYPE (t))\n \treturn t;\n \n-      return build_complex_type (tem);\n+      return build_complex_type (new);\n \n     case OFFSET_TYPE:\n     case METHOD_TYPE:\n     case FUNCTION_TYPE:\n     case LANG_TYPE:\n-      /* Don't know how to do these yet.  */\n+      /* These should never show up here.  */\n       gcc_unreachable ();\n \n     case ARRAY_TYPE:\n@@ -7603,79 +7643,56 @@ substitute_in_type (tree t, tree f, tree r)\n \t  return t;\n \n \tnew = build_array_type (component, domain);\n-\tTYPE_SIZE (new) = 0;\n+\tTYPE_ALIGN (new) = TYPE_ALIGN (t);\n+\tTYPE_USER_ALIGN (new) = TYPE_USER_ALIGN (t);\n+\tSET_TYPE_MODE (new, TYPE_MODE (t));\n+\tTYPE_SIZE (new) = SUBSTITUTE_IN_EXPR (TYPE_SIZE (t), f, r);\n+\tTYPE_SIZE_UNIT (new) = SUBSTITUTE_IN_EXPR (TYPE_SIZE_UNIT (t), f, r);\n \tTYPE_NONALIASED_COMPONENT (new) = TYPE_NONALIASED_COMPONENT (t);\n \tTYPE_MULTI_ARRAY_P (new) = TYPE_MULTI_ARRAY_P (t);\n \tTYPE_CONVENTION_FORTRAN_P (new) = TYPE_CONVENTION_FORTRAN_P (t);\n-\tlayout_type (new);\n-\tTYPE_ALIGN (new) = TYPE_ALIGN (t);\n-\tTYPE_USER_ALIGN (new) = TYPE_USER_ALIGN (t);\n-\n-\t/* If we had bounded the sizes of T by a constant, bound the sizes of\n-\t   NEW by the same constant.  */\n-\tif (TREE_CODE (TYPE_SIZE (t)) == MIN_EXPR)\n-\t  TYPE_SIZE (new)\n-\t    = size_binop (MIN_EXPR, TREE_OPERAND (TYPE_SIZE (t), 1),\n-\t\t\t  TYPE_SIZE (new));\n-\tif (TREE_CODE (TYPE_SIZE_UNIT (t)) == MIN_EXPR)\n-\t  TYPE_SIZE_UNIT (new)\n-\t    = size_binop (MIN_EXPR, TREE_OPERAND (TYPE_SIZE_UNIT (t), 1),\n-\t\t\t  TYPE_SIZE_UNIT (new));\n \treturn new;\n       }\n \n     case RECORD_TYPE:\n     case UNION_TYPE:\n     case QUAL_UNION_TYPE:\n       {\n+\tbool changed_field = false;\n \ttree field;\n-\tbool changed_field\n-\t  = (f == NULL_TREE && !TREE_CONSTANT (TYPE_SIZE (t)));\n-\tbool field_has_rep = false;\n-\ttree last_field = NULL_TREE;\n-\n-\ttree new = copy_type (t);\n \n \t/* Start out with no fields, make new fields, and chain them\n \t   in.  If we haven't actually changed the type of any field,\n \t   discard everything we've done and return the old type.  */\n-\n+\tnew = copy_type (t);\n \tTYPE_FIELDS (new) = NULL_TREE;\n-\tTYPE_SIZE (new) = NULL_TREE;\n \n \tfor (field = TYPE_FIELDS (t); field; field = TREE_CHAIN (field))\n \t  {\n-\t    tree new_field = copy_node (field);\n-\n-\t    TREE_TYPE (new_field)\n-\t      = substitute_in_type (TREE_TYPE (new_field), f, r);\n-\n-\t    if (DECL_HAS_REP_P (field) && !DECL_INTERNAL_P (field))\n-\t      field_has_rep = true;\n-\t    else if (TREE_TYPE (new_field) != TREE_TYPE (field))\n-\t      changed_field = true;\n-\n-\t    /* If this is an internal field and the type of this field is\n-\t       a UNION_TYPE or RECORD_TYPE with no elements, ignore it.  If\n-\t       the type just has one element, treat that as the field.\n-\t       But don't do this if we are processing a QUAL_UNION_TYPE.  */\n-\t    if (TREE_CODE (t) != QUAL_UNION_TYPE\n-\t\t&& DECL_INTERNAL_P (new_field)\n-\t\t&& (TREE_CODE (TREE_TYPE (new_field)) == UNION_TYPE\n-\t\t    || TREE_CODE (TREE_TYPE (new_field)) == RECORD_TYPE))\n+\t    tree new_field = copy_node (field), new_n;\n+\n+\t    new_n = substitute_in_type (TREE_TYPE (field), f, r);\n+\t    if (new_n != TREE_TYPE (field))\n \t      {\n-\t\tif (!TYPE_FIELDS (TREE_TYPE (new_field)))\n-\t\t  continue;\n+\t\tTREE_TYPE (new_field) = new_n;\n+\t\tchanged_field = true;\n+\t      }\n \n-\t\tif (!TREE_CHAIN (TYPE_FIELDS (TREE_TYPE (new_field))))\n-\t\t  {\n-\t\t    tree next_new_field\n-\t\t      = copy_node (TYPE_FIELDS (TREE_TYPE (new_field)));\n+\t    new_n = SUBSTITUTE_IN_EXPR (DECL_FIELD_OFFSET (field), f, r);\n+\t    if (new_n != DECL_FIELD_OFFSET (field))\n+\t      {\n+\t\tDECL_FIELD_OFFSET (new_field) = new_n;\n+\t\tchanged_field = true;\n+\t      }\n \n-\t\t    /* Make sure omitting the union doesn't change\n-\t\t       the layout.  */\n-\t\t    DECL_ALIGN (next_new_field) = DECL_ALIGN (new_field);\n-\t\t    new_field = next_new_field;\n+\t    /* Do the substitution inside the qualifier, if any.  */\n+\t    if (TREE_CODE (t) == QUAL_UNION_TYPE)\n+\t      {\n+\t\tnew_n = SUBSTITUTE_IN_EXPR (DECL_QUALIFIER (field), f, r);\n+\t\tif (new_n != DECL_QUALIFIER (field))\n+\t\t  {\n+\t\t    DECL_QUALIFIER (new_field) = new_n;\n+\t\t    changed_field = true;\n \t\t  }\n \t      }\n \n@@ -7684,68 +7701,17 @@ substitute_in_type (tree t, tree f, tree r)\n \t\t\t\t     (DECL_ORIGINAL_FIELD (field)\n \t\t\t\t      ? DECL_ORIGINAL_FIELD (field) : field));\n \n-\t    /* If the size of the old field was set at a constant,\n-\t       propagate the size in case the type's size was variable.\n-\t       (This occurs in the case of a variant or discriminated\n-\t       record with a default size used as a field of another\n-\t       record.)  */\n-\t    DECL_SIZE (new_field)\n-\t      = TREE_CODE (DECL_SIZE (field)) == INTEGER_CST\n-\t\t? DECL_SIZE (field) : NULL_TREE;\n-\t    DECL_SIZE_UNIT (new_field)\n-\t      = TREE_CODE (DECL_SIZE_UNIT (field)) == INTEGER_CST\n-\t\t? DECL_SIZE_UNIT (field) : NULL_TREE;\n-\n-\t    if (TREE_CODE (t) == QUAL_UNION_TYPE)\n-\t      {\n-\t\ttree new_q = SUBSTITUTE_IN_EXPR (DECL_QUALIFIER (field), f, r);\n-\n-\t\tif (new_q != DECL_QUALIFIER (new_field))\n-\t\t  changed_field = true;\n-\n-\t\t/* Do the substitution inside the qualifier and if we find\n-\t\t   that this field will not be present, omit it.  */\n-\t\tDECL_QUALIFIER (new_field) = new_q;\n-\n-\t\tif (integer_zerop (DECL_QUALIFIER (new_field)))\n-\t\t  continue;\n-\t      }\n-\n-\t    if (!last_field)\n-\t      TYPE_FIELDS (new) = new_field;\n-\t    else\n-\t      TREE_CHAIN (last_field) = new_field;\n-\n-\t    last_field = new_field;\n-\n-\t    /* If this is a qualified type and this field will always be\n-\t       present, we are done.  */\n-\t    if (TREE_CODE (t) == QUAL_UNION_TYPE\n-\t\t&& integer_onep (DECL_QUALIFIER (new_field)))\n-\t      break;\n+\t    TREE_CHAIN (new_field) = TYPE_FIELDS (new);\n+\t    TYPE_FIELDS (new) = new_field;\n \t  }\n \n-\t/* If this used to be a qualified union type, but we now know what\n-\t   field will be present, make this a normal union.  */\n-\tif (changed_field && TREE_CODE (new) == QUAL_UNION_TYPE\n-\t    && (!TYPE_FIELDS (new)\n-\t\t|| integer_onep (DECL_QUALIFIER (TYPE_FIELDS (new)))))\n-\t  TREE_SET_CODE (new, UNION_TYPE);\n-\telse if (!changed_field)\n+\tif (!changed_field)\n \t  return t;\n \n-\tgcc_assert (!field_has_rep);\n-\tlayout_type (new);\n-\n-\t/* If the size was originally a constant use it.  */\n-\tif (TYPE_SIZE (t) && TREE_CODE (TYPE_SIZE (t)) == INTEGER_CST\n-\t    && TREE_CODE (TYPE_SIZE (new)) != INTEGER_CST)\n-\t  {\n-\t    TYPE_SIZE (new) = TYPE_SIZE (t);\n-\t    TYPE_SIZE_UNIT (new) = TYPE_SIZE_UNIT (t);\n-\t    SET_TYPE_ADA_SIZE (new, TYPE_ADA_SIZE (t));\n-\t  }\n-\n+\tTYPE_FIELDS (new) = nreverse (TYPE_FIELDS (new));\n+\tTYPE_SIZE (new) = SUBSTITUTE_IN_EXPR (TYPE_SIZE (t), f, r);\n+\tTYPE_SIZE_UNIT (new) = SUBSTITUTE_IN_EXPR (TYPE_SIZE_UNIT (t), f, r);\n+\tSET_TYPE_ADA_SIZE (new, SUBSTITUTE_IN_EXPR (TYPE_ADA_SIZE (t), f, r));\n \treturn new;\n       }\n "}, {"sha": "55e474c98298a8c1181bb9d2d9329b6ab9a84476", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77022fa8734fdd0b5ac892ba109b77e0ec7dd13b/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77022fa8734fdd0b5ac892ba109b77e0ec7dd13b/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=77022fa8734fdd0b5ac892ba109b77e0ec7dd13b", "patch": "@@ -1521,8 +1521,6 @@ create_field_decl (tree field_name, tree field_type, tree record_type,\n       pos_from_bit (&DECL_FIELD_OFFSET (field_decl),\n \t\t    &DECL_FIELD_BIT_OFFSET (field_decl),\n \t\t    DECL_OFFSET_ALIGN (field_decl), pos);\n-\n-      DECL_HAS_REP_P (field_decl) = 1;\n     }\n \n   /* In addition to what our caller says, claim the field is addressable if we\n@@ -3606,10 +3604,7 @@ update_pointer_to (tree old_type, tree new_type)\n \t\t\tbounds_field, NULL_TREE);\n \n       /* Create the new array for the new PLACEHOLDER_EXPR and make pointers\n-\t to the dummy array point to it.\n-\n-\t ??? This is now the only use of substitute_in_type, which is a very\n-\t \"heavy\" routine to do this, it should be replaced at some point.  */\n+\t to the dummy array point to it.  */\n       update_pointer_to\n \t(TREE_TYPE (TREE_TYPE (array_field)),\n \t substitute_in_type (TREE_TYPE (TREE_TYPE (TYPE_FIELDS (new_ptr))),"}, {"sha": "5a072fc876582278e5f412cc699873cb98f063f1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77022fa8734fdd0b5ac892ba109b77e0ec7dd13b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77022fa8734fdd0b5ac892ba109b77e0ec7dd13b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=77022fa8734fdd0b5ac892ba109b77e0ec7dd13b", "patch": "@@ -1,3 +1,8 @@\n+2009-04-20  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/discr11.ad[sb]: New test.\n+\t* gnat.dg/discr11_pkg.ads: New helper.\n+\n 2009-04-20  Ira Rosen  <irar@il.ibm.com>\n \n \tPR tree-optimization/39675"}, {"sha": "ceec4cefb477511762c5ac23219bc5e180fb03c9", "filename": "gcc/testsuite/gnat.dg/discr11.adb", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77022fa8734fdd0b5ac892ba109b77e0ec7dd13b/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77022fa8734fdd0b5ac892ba109b77e0ec7dd13b/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr11.adb?ref=77022fa8734fdd0b5ac892ba109b77e0ec7dd13b", "patch": "@@ -0,0 +1,9 @@\n+-- { dg-do compile }\n+\n+package body Discr11 is\n+   function Create return DT_2 is\n+   begin\n+      return DT_2'(DT_1'(Create) with More => 1234);\n+   end;\n+end Discr11;\n+"}, {"sha": "b3911999d399d139f05c3e29a5da42df9986e3a7", "filename": "gcc/testsuite/gnat.dg/discr11.ads", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77022fa8734fdd0b5ac892ba109b77e0ec7dd13b/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr11.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77022fa8734fdd0b5ac892ba109b77e0ec7dd13b/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr11.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr11.ads?ref=77022fa8734fdd0b5ac892ba109b77e0ec7dd13b", "patch": "@@ -0,0 +1,9 @@\n+with Discr11_Pkg; use Discr11_Pkg;\n+\n+package Discr11 is\n+   type DT_2 is new DT_1 with record\n+     More : Integer;\n+   end record;\n+\n+   function Create return DT_2;\n+end Discr11;"}, {"sha": "1b0a979bb30d541418005d1f1ddc6404178f1c8f", "filename": "gcc/testsuite/gnat.dg/discr11_pkg.ads", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77022fa8734fdd0b5ac892ba109b77e0ec7dd13b/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr11_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77022fa8734fdd0b5ac892ba109b77e0ec7dd13b/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr11_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr11_pkg.ads?ref=77022fa8734fdd0b5ac892ba109b77e0ec7dd13b", "patch": "@@ -0,0 +1,8 @@\n+package Discr11_Pkg is\n+   type DT_1 (<>) is tagged private;\n+   function Create return DT_1;\n+private\n+   type DT_1 (Size : Positive) is tagged record\n+      Data : String (1 .. Size);\n+   end record;\n+end Discr11_Pkg;"}]}