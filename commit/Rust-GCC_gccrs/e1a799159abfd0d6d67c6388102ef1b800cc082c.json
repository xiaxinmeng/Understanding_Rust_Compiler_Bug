{"sha": "e1a799159abfd0d6d67c6388102ef1b800cc082c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTFhNzk5MTU5YWJmZDBkNmQ2N2M2Mzg4MTAyZWYxYjgwMGNjMDgyYw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1991-12-24T04:31:09Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1991-12-24T04:31:09Z"}, "message": "Initial revision\n\nFrom-SVN: r137", "tree": {"sha": "f95f8848a80df329dd4f60be08559178bcddc2e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f95f8848a80df329dd4f60be08559178bcddc2e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e1a799159abfd0d6d67c6388102ef1b800cc082c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1a799159abfd0d6d67c6388102ef1b800cc082c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1a799159abfd0d6d67c6388102ef1b800cc082c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1a799159abfd0d6d67c6388102ef1b800cc082c/comments", "author": null, "committer": null, "parents": [{"sha": "64a93ac5582208c6adf7ad8cb62079ebe98c9f25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64a93ac5582208c6adf7ad8cb62079ebe98c9f25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64a93ac5582208c6adf7ad8cb62079ebe98c9f25"}], "stats": {"total": 979, "additions": 979, "deletions": 0}, "files": [{"sha": "e64f38e68dd4ecaa1eb798be3e7fb399d8f8215e", "filename": "gcc/longlong.h", "status": "added", "additions": 750, "deletions": 0, "changes": 750, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1a799159abfd0d6d67c6388102ef1b800cc082c/gcc%2Flonglong.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1a799159abfd0d6d67c6388102ef1b800cc082c/gcc%2Flonglong.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flonglong.h?ref=e1a799159abfd0d6d67c6388102ef1b800cc082c", "patch": "@@ -0,0 +1,750 @@\n+/* longlong.h -- definitions for mixed size 32/64 bit arithmetic.\n+   Copyright (C) 1991 Free Software Foundation, Inc.\n+\n+   This definition file is free software; you can redistribute it\n+   and/or modify it under the terms of the GNU General Public\n+   License as published by the Free Software Foundation; either\n+   version 2, or (at your option) any later version.\n+\n+   This definition file is distributed in the hope that it will be\n+   useful, but WITHOUT ANY WARRANTY; without even the implied\n+   warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+   See the GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; if not, write to the Free Software\n+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#ifndef LONG_TYPE_SIZE\n+#define LONG_TYPE_SIZE 32\n+#endif\n+\n+#define __BITS4 (LONG_TYPE_SIZE / 4)\n+#define __ll_B (1L << (LONG_TYPE_SIZE / 2))\n+#define __ll_lowpart(t) ((unsigned long int) (t) % __ll_B)\n+#define __ll_highpart(t) ((unsigned long int) (t) / __ll_B)\n+\n+/* Define auxilliary asm macros.\n+\n+   1) umul_ppmm(high_prod, low_prod, multipler, multiplicand)\n+   multiplies two unsigned long integers MULTIPLER and MULTIPLICAND,\n+   and generates a two unsigned word product in HIGH_PROD and\n+   LOW_PROD.\n+\n+   2) __umulsidi3(a,b) multiplies two unsigned long integers A and B,\n+   and returns a long long product.  This is just a variant of umul_ppmm.\n+\n+   3) udiv_qrnnd(quotient, remainder, high_numerator, low_numerator,\n+   denominator) divides a two-word unsigned integer, composed by the\n+   integers HIGH_NUMERATOR and LOW_NUMERATOR, by DENOMINATOR and\n+   places the quotient in QUOTIENT and the remainder in REMAINDER.\n+   HIGH_NUMERATOR must be less than DENOMINATOR for correct operation.\n+   If, in addition, the most significant bit of DENOMINATOR must be 1,\n+   then the pre-processor symbol UDIV_NEEDS_NORMALIZATION is defined to 1.\n+\n+   4) count_leading_zeros(count, x) counts the number of zero-bits from\n+   the msb to the first non-zero bit.  This is the number of steps X\n+   needs to be shifted left to set the msb.  Undefined for X == 0.\n+\n+   5) add_ssaaaa(high_sum, low_sum, high_addend_1, low_addend_1,\n+   high_addend_2, low_addend_2) adds two two-word unsigned integers,\n+   composed by HIGH_ADDEND_1 and LOW_ADDEND_1, and HIGH_ADDEND_2 and\n+   LOW_ADDEND_2 respectively.  The result is placed in HIGH_SUM and\n+   LOW_SUM.  Overflow (i.e. carry out) is not stored anywhere, and is\n+   lost.\n+\n+   6) sub_ddmmss(high_difference, low_difference, high_minuend,\n+   low_minuend, high_subtrahend, low_subtrahend) subtracts two\n+   two-word unsigned integers, composed by HIGH_MINUEND_1 and\n+   LOW_MINUEND_1, and HIGH_SUBTRAHEND_2 and LOW_SUBTRAHEND_2\n+   respectively.  The result is placed in HIGH_DIFFERENCE and\n+   LOW_DIFFERENCE.  Overflow (i.e. carry out) is not stored anywhere,\n+   and is lost.\n+\n+   If any of these macros are left undefined for a particular CPU,\n+   C macros are used.  */\n+\n+/* The CPUs come in alphabetical order below.\n+\n+   Please add support for more CPUs here, or improve the current support\n+   for the CPUs below!\n+   (E.g. WE32100, HP-PA (xmpyu?), i960, IBM360, TRON.)  */\n+\n+#if defined (__GNUC__) && !defined (NO_ASM)\n+\n+#if defined (__a29k__) || defined (___AM29K__)\n+#define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n+  __asm__ (\"add %1,%4,%5\n+\taddc %0,%2,%3\"\t\t\t\t\t\t\t\\\n+\t : \"=r\" ((unsigned long int)(sh)), \"=&r\" ((unsigned long int)(sl)) \\\n+\t : \"%r\" ((unsigned long int)(ah)), \"rI\" ((unsigned long int)(bh)), \\\n+\t   \"%r\" ((unsigned long int)(al)), \"rI\" ((unsigned long int)(bl)))\n+#define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n+  __asm__ (\"sub %1,%4,%5\n+\tsubc %0,%2,%3\"\t\t\t\t\t\t\t\\\n+\t : \"=r\" ((unsigned long int)(sh)), \"=&r\" ((unsigned long int)(sl)) \\\n+\t : \"r\" ((unsigned long int)(ah)), \"rI\" ((unsigned long int)(bh)), \\\n+\t   \"r\" ((unsigned long int)(al)), \"rI\" ((unsigned long int)(bl)))\n+#define umul_ppmm(xh, xl, m0, m1) \\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    unsigned long int __m0 = (m0), __m1 = (m1);\t\t\t\t\\\n+    __asm__ (\"multiplu %0,%1,%2\" : \"=r\" ((unsigned long int)(xl))\t\\\n+\t     : \"r\" (__m0), \"r\" (__m1));\t\t\t\t\t\\\n+    __asm__ (\"multmu %0,%1,%2\" : \"=r\" ((unsigned long int)(xh))\t\t\\\n+\t     : \"r\" (__m0), \"r\" (__m1));\t\t\t\t\t\\\n+  } while (0)\n+#define udiv_qrnnd(q, r, n1, n0, d) \\\n+  __asm__ (\"dividu %0,%3,%4\"\t\t\t\t\t\t\\\n+\t: \"=r\" ((unsigned long int)(q)), \"=q\" ((unsigned long int)(r))\t\\\n+\t: \"1\" ((unsigned long int)(n1)), \"r\" ((unsigned long int)(n0)),\t\\\n+\t  \"r\" ((unsigned long int)(d)))\n+#define count_leading_zeros(count, x) \\\n+    __asm__ (\"clz %0,%1\" : \"=r\" ((unsigned long int)(count))\t\t\\\n+\t     : \"r\" ((unsigned long int)(x)))\n+#endif /* __a29k__ */\n+\n+#if defined (__arm__)\n+#define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n+  __asm__ (\"adds %1,%4,%5\n+\tadc %0,%2,%3\"\t\t\t\t\t\t\t\\\n+\t: \"=r\" ((unsigned long int)(sh)), \"=&r\" ((unsigned long int)(sl)) \\\n+\t: \"%r\" ((unsigned long int)(ah)), \"rI\" ((unsigned long int)(bh)), \\\n+\t  \"%r\" ((unsigned long int)(al)), \"rI\" ((unsigned long int)(bl)))\n+#define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n+  __asm__ (\"subs %1,%4,%5\n+\tsbc %0,%2,%3\"\t\t\t\t\t\t\t\\\n+\t: \"=r\" ((unsigned long int)(sh)), \"=&r\" ((unsigned long int)(sl)) \\\n+\t: \"r\" ((unsigned long int)(ah)), \"rI\" ((unsigned long int)(bh)), \\\n+\t  \"r\" ((unsigned long int)(al)), \"rI\" ((unsigned long int)(bl)))\n+#endif /* __arm__ */\n+\n+#if defined (__gmicro__)\n+#define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n+  __asm__ (\"add.w %5,%1\n+\taddx %3,%0\"\t\t\t\t\t\t\t\\\n+       : \"=g\" ((unsigned long int)(sh)), \"=&g\" ((unsigned long int)(sl))\\\n+       : \"%0\" ((unsigned long int)(ah)), \"g\" ((unsigned long int)(bh)),\t\\\n+\t \"%1\" ((unsigned long int)(al)), \"g\" ((unsigned long int)(bl)))\n+#define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n+  __asm__ (\"sub.w %5,%1\n+\tsubx %3,%0\"\t\t\t\t\t\t\t\\\n+       : \"=g\" ((unsigned long int)(sh)), \"=&g\" ((unsigned long int)(sl))\\\n+       : \"0\" ((unsigned long int)(ah)), \"g\" ((unsigned long int)(bh)),\t\\\n+\t \"1\" ((unsigned long int)(al)), \"g\" ((unsigned long int)(bl)))\n+#define umul_ppmm(ph, pl, m0, m1) \\\n+  __asm__ (\"mulx %3,%0,%1\"\t\t\t\t\t\t\\\n+\t: \"=g\" ((unsigned long int)(ph)), \"=r\" ((unsigned long int)(pl))\\\n+\t: \"%0\" ((unsigned long int)(m0)), \"g\" ((unsigned long int)(m1)))\n+#define udiv_qrnnd(q, r, nh, nl, d) \\\n+  __asm__ (\"divx %4,%0,%1\"\t\t\t\t\t\t\\\n+\t: \"=g\" ((unsigned long int)(q)), \"=r\" ((unsigned long int)(r))\t\\\n+\t: \"1\" ((unsigned long int)(nh)), \"0\" ((unsigned long int)(nl)),\t\\\n+\t  \"g\" ((unsigned long int)(d)))\n+#define count_leading_zeros(count, x) \\\n+  __asm__ (\"bsch/1 %1,%0\"\t\t\t\t\t\t\\\n+\t: \"=g\" (count)\t\t\t\t\t\t\t\\\n+\t: \"g\" ((unsigned long int)(x)), \"0\" (0UL))\n+#endif\n+\n+#if defined (__hppa)\n+#define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n+  __asm__ (\"add %4,%5,%1\n+\taddc %2,%3,%0\"\t\t\t\t\t\t\t\\\n+\t: \"=r\" ((unsigned long int)(sh)), \"=&r\" ((unsigned long int)(sl))\\\n+\t: \"%r\" ((unsigned long int)(ah)), \"r\" ((unsigned long int)(bh)),\\\n+\t  \"%r\" ((unsigned long int)(al)), \"r\" ((unsigned long int)(bl)))\n+#define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n+  __asm__ (\"sub %5,%4,%1\n+\tsubb %3,%2,%0\"\t\t\t\t\t\t\t\\\n+\t: \"=r\" ((unsigned long int)(sh)), \"=&r\" ((unsigned long int)(sl))\\\n+\t: \"r\" ((unsigned long int)(ah)), \"r\" ((unsigned long int)(bh)),\t\\\n+\t  \"r\" ((unsigned long int)(al)), \"r\" ((unsigned long int)(bl)))\n+#endif\n+\n+#if defined (__i386__) || defined (__i486__)\n+#define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n+  __asm__ (\"addl %5,%1\n+\tadcl %3,%0\"\t\t\t\t\t\t\t\\\n+       : \"=r\" ((unsigned long int)(sh)), \"=&r\" ((unsigned long int)(sl))\\\n+       : \"%0\" ((unsigned long int)(ah)), \"g\" ((unsigned long int)(bh)),\t\\\n+\t \"%1\" ((unsigned long int)(al)), \"g\" ((unsigned long int)(bl)))\n+#define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n+  __asm__ (\"subl %5,%1\n+\tsbbl %3,%0\"\t\t\t\t\t\t\t\\\n+       : \"=r\" ((unsigned long int)(sh)), \"=&r\" ((unsigned long int)(sl))\\\n+       : \"0\" ((unsigned long int)(ah)), \"g\" ((unsigned long int)(bh)),\t\\\n+\t \"1\" ((unsigned long int)(al)), \"g\" ((unsigned long int)(bl)))\n+#define umul_ppmm(w1, w0, u, v) \\\n+  __asm__ (\"mull %3\"\t\t\t\t\t\t\t\\\n+\t: \"=a\" ((unsigned long int)(w0)), \"=d\" ((unsigned long int)(w1))\\\n+\t: \"%0\" ((unsigned long int)(u)), \"rm\" ((unsigned long int)(v)))\n+#define udiv_qrnnd(q, r, n1, n0, d) \\\n+  __asm__ (\"divl %4\"\t\t\t\t\t\t\t\\\n+\t: \"=a\" ((unsigned long int)(q)), \"=d\" ((unsigned long int)(r))\t\\\n+\t: \"0\" ((unsigned long int)(n0)), \"1\" ((unsigned long int)(n1)),\t\\\n+\t  \"rm\" ((unsigned long int)(d)))\n+#define count_leading_zeros(count, x) \\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    unsigned long int __cbtmp;\t\t\t\t\t\t\\\n+    __asm__ (\"bsrl %1,%0\"\t\t\t\t\t\t\\\n+\t     : \"=r\" (__cbtmp) : \"rm\" ((unsigned long int)(x)));\t\t\\\n+    (count) = __cbtmp ^ 31;\t\t\t\t\t\t\\\n+  } while (0)\n+#endif /* 80x86 */\n+\n+#if defined (__i860__)\n+#if 0\n+/* Make sure these patterns really improve the code before\n+   switching them on.  */\n+#define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    union\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tlong long int ll;\t\t\t\t\t\t\\\n+\tstruct {unsigned long int l, h;} i;\t\t\t\t\\\n+      }  __a, __b, __s;\t\t\t\t\t\t\t\\\n+    __a.i.l = (al); __a.i.h = (ah);\t\t\t\t\t\\\n+    __b.i.l = (bl); __b.i.h = (bh);\t\t\t\t\t\\\n+    __asm__ (\"fiadd.dd %1,%2,%0\"\t\t\t\t\t\\\n+\t     : \"=f\" (__s.ll)\t\t\t\t\t\t\\\n+\t     : \"%f\" (__a.ll), \"f\" (__b.ll));\t\t\t\t\\\n+    (sh) = __s.i.h; (sl) = __s.i.l;\t\t\t\t\t\\\n+    } while (0)\n+#define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    union\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tlong long int ll;\t\t\t\t\t\t\\\n+\tstruct {unsigned long int l, h;} i;\t\t\t\t\\\n+      }  __a, __b, __s;\t\t\t\t\t\t\t\\\n+    __a.i.l = (al); __a.i.h = (ah);\t\t\t\t\t\\\n+    __b.i.l = (bl); __b.i.h = (bh);\t\t\t\t\t\\\n+    __asm__ (\"fisub.dd %1,%2,%0\"\t\t\t\t\t\\\n+\t     : \"=f\" (__s.ll)\t\t\t\t\t\t\\\n+\t     : \"%f\" (__a.ll), \"f\" (__b.ll));\t\t\t\t\\\n+    (sh) = __s.i.h; (sl) = __s.i.l;\t\t\t\t\t\\\n+    } while (0)\n+#endif\n+#endif /* __i860__ */\n+\n+#if defined (___IBMR2__) /* IBM RS6000 */\n+#define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n+  __asm__ (\"a %1,%4,%5\n+\tae %0,%2,%3\"\t\t\t\t\t\t\t\\\n+\t: \"=r\" ((unsigned long int)(sh)), \"=&r\" ((unsigned long int)(sl))\\\n+\t: \"%r\" ((unsigned long int)(ah)), \"r\" ((unsigned long int)(bh)),\\\n+\t  \"%r\" ((unsigned long int)(al)), \"r\" ((unsigned long int)(bl)))\n+#define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n+  __asm__ (\"sf %1,%5,%4\n+\tsfe %0,%3,%2\"\t\t\t\t\t\t\t\\\n+\t: \"=r\" ((unsigned long int)(sh)), \"=&r\" ((unsigned long int)(sl))\\\n+\t: \"r\" ((unsigned long int)(ah)), \"r\" ((unsigned long int)(bh)),\t\\\n+\t  \"r\" ((unsigned long int)(al)), \"r\" ((unsigned long int)(bl)))\n+#define umul_ppmm(xh, xl, m0, m1) \\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    unsigned long int __m0 = (m0), __m1 = (m1);\t\t\t\t\\\n+    __asm__ (\"mul %0,%2,%3\"\t\t\t\t\t\t\\\n+\t: \"=r\" ((unsigned long int)(xh)), \"=q\" ((unsigned long int)(xl))\\\n+\t: \"r\" (__m0), \"r\" (__m1));\t\t\t\t\t\\\n+    (xh) += ((((signed long int) __m0 >> 31) & __m1)\t\t\t\\\n+\t     + (((signed long int) __m1 >> 31) & __m0));\t\t\\\n+  } while (0)\n+#define UMUL_TIME 8\n+#define udiv_qrnnd(q, r, nh, nl, d) \\\n+  do { /* Use the signed \"div\" insn, and adjust the result. */\t\t\\\n+    unsigned long int __q, __r, __nh, __nl, __d, __xh, __xl;\t\t\\\n+    __nh = 0;\t\t\t\t\t\t\t\t\\\n+    __nl = (((unsigned long int)(nh)) << 30) | ((unsigned long int)(nl) >> 2);\\\n+    __nh = (unsigned long int)(nh) >> 2;\t\t\t\t\\\n+    __d = ((unsigned long int)(d) >> 1);\t\t\t\t\\\n+    __asm__ (\"div %0,%2,%4\"\t\t\t\t\t\t\\\n+\t     : \"=r\" (__q), \"=q\" (__r)\t\t\t\t\t\\\n+\t     : \"r\" (__nh), \"1\" (__nl), \"r\" (__d));\t\t\t\\\n+    __q <<= 1;\t\t\t\t\t\t\t\t\\\n+    __asm__ (\"mul %0,%2,%3\"\t\t\t\t\t\t\\\n+\t     : \"=r\" (__xh), \"=q\" (__xl)\t\t\t\t\t\\\n+\t     : \"r\" (__q), \"r\" ((unsigned long int)(d)));\t\t\\\n+    __xh += (((signed long int) __q >> 31) & (d)) + __q;\t\t\\\n+    if ((nh) < __xh || ((nh) == __xh && (nl) < __xl))\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tdo\t\t\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    sub_ddmmss (__xh, __xl, __xh, __xl, 0, (d));\t\t\\\n+\t    __q--;\t\t\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\twhile ((nh) < __xh || ((nh) == __xh && (nl) < __xl));\t\t\\\n+\t__xl = (nl) - __xl;\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tsub_ddmmss (__xh, __xl, (nh), (nl), __xh, __xl);\t\t\\\n+\tif (__xh != 0)\t\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    do\t\t\t\t\t\t\t\t\\\n+\t      {\t\t\t\t\t\t\t\t\\\n+\t\tsub_ddmmss (__xh, __xl, __xh, __xl, 0, (d));\t\t\\\n+\t\t__q++;\t\t\t\t\t\t\t\\\n+\t      }\t\t\t\t\t\t\t\t\\\n+\t    while (__xh != 0);\t\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\tif (__xl >= (d))\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    __xl -= (d);\t\t\t\t\t\t\\\n+\t    __q++;\t\t\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    (q) = __q;\t\t\t\t\t\t\t\t\\\n+    (r) = __xl;\t\t\t\t\t\t\t\t\\\n+  } while (0)\n+#define UDIV_TIME 40\n+#define UDIV_NEEDS_NORMALIZATION 1\n+#define count_leading_zeros(count, x) \\\n+  __asm__ (\"cntlz %0,%1\"\t\t\t\t\t\t\\\n+\t: \"=r\" ((unsigned long int)(count)) : \"r\" ((unsigned long int)(x)))\n+#endif /* ___IBMR2__ */\n+\n+#if defined (__mc68000__)\n+#define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n+  __asm__ (\"add%.l %5,%1\n+\taddx%.l %3,%0\"\t\t\t\t\t\t\t\\\n+       : \"=d\" ((unsigned long int)(sh)), \"=&d\" ((unsigned long int)(sl))\\\n+       : \"%0\" ((unsigned long int)(ah)), \"d\" ((unsigned long int)(bh)),\t\\\n+\t \"%1\" ((unsigned long int)(al)), \"g\" ((unsigned long int)(bl)))\n+#define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n+  __asm__ (\"sub%.l %5,%1\n+\tsubx%.l %3,%0\"\t\t\t\t\t\t\t\\\n+       : \"=d\" ((unsigned long int)(sh)), \"=&d\" ((unsigned long int)(sl))\\\n+       : \"0\" ((unsigned long int)(ah)), \"d\" ((unsigned long int)(bh)),\t\\\n+\t \"1\" ((unsigned long int)(al)), \"g\" ((unsigned long int)(bl)))\n+#if defined (__mc68020__) || defined (__NeXT__) || defined(mc68020)\n+#define umul_ppmm(w1, w0, u, v) \\\n+  __asm__ (\"mulu%.l %3,%1:%0\"\t\t\t\t\t\t\\\n+\t: \"=d\" ((unsigned long int)(w0)), \"=d\" ((unsigned long int)(w1))\\\n+\t: \"%0\" ((unsigned long int)(u)), \"dmi\" ((unsigned long int)(v)))\n+#define udiv_qrnnd(q, r, n1, n0, d) \\\n+  __asm__ (\"divu%.l %4,%1:%0\"\t\t\t\t\t\t\\\n+\t: \"=d\" ((unsigned long int)(q)), \"=d\" ((unsigned long int)(r))\t\\\n+\t: \"0\" ((unsigned long int)(n0)), \"1\" ((unsigned long int)(n1)),\t\\\n+\t  \"dmi\" ((unsigned long int)(d)))\n+#define count_leading_zeros(count, x) \\\n+  __asm__ (\"bfffo %1{%b2:%b2},%0\"\t\t\t\t\t\\\n+\t: \"=d\" ((unsigned long int)(count))\t\t\t\t\\\n+\t: \"od\" ((unsigned long int)(x)), \"n\" (0))\n+#else /* not mc68020 */\n+#define umul_ppmm(xh, xl, a, b) \\\n+  __asm__ (\"| Inlined umul_ppmm\n+\tmovel\t%2,d0\n+\tmovel\t%3,d1\n+\tmovel\td0,d2\n+\tswap\td0\n+\tmovel\td1,d3\n+\tswap\td1\n+\tmovew\td2,d4\n+\tmulu\td3,d4\n+\tmulu\td1,d2\n+\tmulu\td0,d3\n+\tmulu\td0,d1\n+\tmovel\td4,d0\n+\teorw\td0,d0\n+\tswap\td0\n+\taddl\td0,d2\n+\taddl\td3,d2\n+\tjcc\t1f\n+\taddl\t#65536,d1\n+1:\tswap\td2\n+\tmoveq\t#0,d0\n+\tmovew\td2,d0\n+\tmovew\td4,d2\n+\tmovel\td2,%1\n+\taddl\td1,d0\n+\tmovel\td0,%0\"\t\t\t\t\t\t\t\\\n+       : \"=g\" ((unsigned long int)(xh)), \"=g\" ((unsigned long int)(xl))\t\\\n+       :\"g\" ((unsigned long int)(a)), \"g\" ((unsigned long int)(b))\t\\\n+       : \"d0\", \"d1\", \"d2\", \"d3\", \"d4\")\n+#endif /* not mc68020 */\n+#endif /* mc68000 */\n+\n+#if defined (__m88000__)\n+#define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n+  __asm__ (\"addu.co %1,%r4,%r5\n+\taddu.ci %0,%r2,%r3\"\t\t\t\t\t\t\\\n+\t: \"=r\" ((unsigned long int)(sh)), \"=&r\" ((unsigned long int)(sl))\\\n+\t: \"%rJ\" ((unsigned long int)(ah)), \"rJ\" ((unsigned long int)(bh)),\\\n+\t  \"%rJ\" ((unsigned long int)(al)), \"rJ\" ((unsigned long int)(bl)))\n+#define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n+  __asm__ (\"subu.co %1,%r4,%r5\n+\tsubu.ci %0,%r2,%r3\"\t\t\t\t\t\t\\\n+\t: \"=r\" ((unsigned long int)(sh)), \"=&r\" ((unsigned long int)(sl))\\\n+\t: \"rJ\" ((unsigned long int)(ah)), \"rJ\" ((unsigned long int)(bh)),\\\n+\t  \"rJ\" ((unsigned long int)(al)), \"rJ\" ((unsigned long int)(bl)))\n+#define UMUL_TIME 17\n+#define UDIV_TIME 150\n+#define count_leading_zeros(count, x) \\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    unsigned long int __cbtmp;\t\t\t\t\t\t\\\n+    __asm__ (\"ff1 %0,%1\"\t\t\t\t\t\t\\\n+\t     : \"=r\" (__cbtmp) : \"r\" ((unsigned long int)(x)));\t\t\\\n+    (count) = __cbtmp ^ 31;\t\t\t\t\t\t\\\n+  } while (0)\n+#endif /* __m88000__ */\n+\n+#if defined (__mips__)\n+#define umul_ppmm(w1, w0, u, v) \\\n+  __asm__ (\"multu %2,%3\n+\tmflo %0\n+\tmfhi %1\"\t\t\t\t\t\t\t\\\n+\t: \"=r\" ((unsigned long int)(w0)), \"=r\" ((unsigned long int)(w1))\\\n+\t: \"r\" ((unsigned long int)(u)), \"r\" ((unsigned long int)(v)))\n+#define UMUL_TIME 5\n+#define UDIV_TIME 100\n+#endif /* __mips__ */\n+\n+#if defined (__ns32000__)\n+#define __umulsidi3(u, v) \\\n+  ({long long int __w;\t\t\t\t\t\t\t\\\n+      __asm__ (\"meid %2,%0\" : \"=g\" (__w)\t\t\t\t\\\n+\t: \"%0\" ((unsigned long int)(u)), \"g\" ((unsigned long int)(v)));\t\\\n+      __w; })\n+#define div_qrnnd(q, r, n1, n0, d) \\\n+  __asm__ (\"movd %2,r0\n+\tmovd %3,r1\n+\tdeid %4,r0\n+\tmovd r1,%0\n+\tmovd r0,%1\"\t\t\t\t\t\t\t\\\n+\t: \"=g\" ((unsigned long int)(q)), \"=g\" ((unsigned long int)(r))\t\\\n+\t: \"g\" ((unsigned long int)(n0)), \"g\" ((unsigned long int)(n1)),\t\\\n+\t  \"g\" ((unsigned long int)(d)) : \"r0\", \"r1\")\n+#endif /* __ns32000__ */\n+\n+#if defined (__pyr__)\n+#define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n+  __asm__ (\"addw\t%5,%1\n+\taddwc\t%3,%0\"\t\t\t\t\t\t\t\\\n+\t: \"=r\" ((unsigned long int)(sh)), \"=&r\" ((unsigned long int)(sl))\\\n+\t: \"%0\" ((unsigned long int)(ah)), \"g\" ((unsigned long int)(bh)),\\\n+\t  \"%1\" ((unsigned long int)(al)), \"g\" ((unsigned long int)(bl)))\n+#define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n+  __asm__ (\"subw\t%5,%1\n+\tsubwb\t%3,%0\"\t\t\t\t\t\t\t\\\n+\t: \"=r\" ((unsigned long int)(sh)), \"=&r\" ((unsigned long int)(sl))\\\n+\t: \"0\" ((unsigned long int)(ah)), \"g\" ((unsigned long int)(bh)),\t\\\n+\t  \"1\" ((unsigned long int)(al)), \"g\" ((unsigned long int)(bl)))\n+/* This insn doesn't work on ancient pyramids.  */\n+#define umul_ppmm(w1, w0, u, v) \\\n+  __asm__ (\"movw %2,tr11\n+\tuemul %3,tr10\n+\tmovw tr10,%0\n+\tmovw tr11,%1\"\t\t\t\t\t\t\t\\\n+\t: \"=r\" ((unsigned long int)(w1)), \"=r\" ((unsigned long int)(w0))\\\n+\t: \"r\" ((unsigned long int)(u)), \"r\" ((unsigned long int)(v))\t\\\n+\t: \"tr10\", \"tr11\")\n+#endif /* __pyr__ */\n+\n+#if defined (__ibm032__) /* RT/ROMP */\n+#define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n+  __asm__ (\"a %1,%5\n+\tae %0,%3\"\t\t\t\t\t\t\t\\\n+\t: \"=r\" ((unsigned long int)(sh)), \"=&r\" ((unsigned long int)(sl))\\\n+\t: \"%0\" ((unsigned long int)(ah)), \"r\" ((unsigned long int)(bh)),\\\n+\t  \"%1\" ((unsigned long int)(al)), \"r\" ((unsigned long int)(bl)))\n+#define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n+  __asm__ (\"s %1,%5\n+\tse %0,%3\"\t\t\t\t\t\t\t\\\n+\t: \"=r\" ((unsigned long int)(sh)), \"=&r\" ((unsigned long int)(sl))\\\n+\t: \"0\" ((unsigned long int)(ah)), \"r\" ((unsigned long int)(bh)),\t\\\n+\t  \"1\" ((unsigned long int)(al)), \"r\" ((unsigned long int)(bl)))\n+#define umul_ppmm(ph, pl, m0, m1) \\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    unsigned long int __m0 = (m0), __m1 = (m1);\t\t\t\t\\\n+    __asm__ (\t\t\t\t\t\t\t\t\\\n+       \"s\tr2,r2\n+\tmts\tr10,%2\n+\tm\tr2,%3\n+\tm\tr2,%3\n+\tm\tr2,%3\n+\tm\tr2,%3\n+\tm\tr2,%3\n+\tm\tr2,%3\n+\tm\tr2,%3\n+\tm\tr2,%3\n+\tm\tr2,%3\n+\tm\tr2,%3\n+\tm\tr2,%3\n+\tm\tr2,%3\n+\tm\tr2,%3\n+\tm\tr2,%3\n+\tm\tr2,%3\n+\tm\tr2,%3\n+\tcas\t%0,r2,r0\n+\tmfs\tr10,%1\"\t\t\t\t\t\t\t\\\n+       : \"=r\" ((unsigned long int)(ph)), \"=r\" ((unsigned long int)(pl))\t\\\n+       : \"%r\" (__m0), \"r\" (__m1)\t\t\t\t\t\\\n+       : \"r2\");\t\t\t\t\t\t\t\t\\\n+    (ph) += ((((signed long int) __m0 >> 31) & __m1)\t\t\t\\\n+\t     + (((signed long int) __m1 >> 31) & __m0));\t\t\\\n+  } while (0)\n+#define count_leading_zeros(count, x) \\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    if ((x) >= 0x10000)\t\t\t\t\t\t\t\\\n+      __asm__ (\"clz\t%0,%1\"\t\t\t\t\t\t\\\n+\t       : \"=r\" ((unsigned long int)(count))\t\t\t\\\n+\t       : \"r\" ((unsigned long int)(x) >> 16));\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\t__asm__ (\"clz\t%0,%1\"\t\t\t\t\t\t\\\n+\t\t : \"=r\" ((unsigned long int)(count))\t\t\t\\\n+\t\t : \"r\" ((unsigned long int)(x)));\t\t\t\\\n+\t(count) += 16;\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  } while (0)\n+#endif\n+\n+#if defined (__sparc__)\n+#define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n+  __asm__ (\"addcc %4,%5,%1\n+\taddx %2,%3,%0\"\t\t\t\t\t\t\t\\\n+\t: \"=r\" ((unsigned long int)(sh)), \"=&r\" ((unsigned long int)(sl))\\\n+\t: \"%r\" ((unsigned long int)(ah)), \"rI\" ((unsigned long int)(bh)),\\\n+\t  \"%r\" ((unsigned long int)(al)), \"rI\" ((unsigned long int)(bl)))\n+#define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n+  __asm__ (\"subcc %4,%5,%1\n+\tsubx %2,%3,%0\"\t\t\t\t\t\t\t\\\n+\t: \"=r\" ((unsigned long int)(sh)), \"=&r\" ((unsigned long int)(sl))\\\n+\t: \"r\" ((unsigned long int)(ah)), \"rI\" ((unsigned long int)(bh)),\\\n+\t  \"r\" ((unsigned long int)(al)), \"rI\" ((unsigned long int)(bl)))\n+#if defined (__sparc8__)\t/* How do we recog. version 8 SPARC?  */\n+#define umul_ppmm(w1, w0, u, v) \\\n+  __asm__ (\"umul %2,%3,%1;rd %%y,%0\"\t\t\t\t\t\\\n+\t: \"=r\" ((unsigned long int)(w1)), \"=r\" ((unsigned long int)(w0))\\\n+\t: \"r\" ((unsigned long int)(u)), \"r\" ((unsigned long int)(v)))\n+#define udiv_qrnnd(q, r, n1, n0, d) \\\n+  __asm__ (\"mov %2,%%y;nop;nop;nop;udiv %3,%4,%0;umul %0,%4,%1;sub %3,%1,%1\"\\\n+\t: \"=&r\" ((unsigned long int)(q)), \"=&r\" ((unsigned long int)(r))\\\n+\t: \"r\" ((unsigned long int)(n1)), \"r\" ((unsigned long int)(n0)),\t\\\n+\t  \"r\" ((unsigned long int)(d)))\n+#else\n+/* SPARC without integer multiplication and divide instructions.\n+   (i.e. at least Sun4/20,40,60,65,75,110,260,280,330,360,380,470,490) */\n+#define umul_ppmm(w1, w0, u, v) \\\n+  __asm__ (\"! Inlined umul_ppmm\n+\twr\t%%g0,%2,%%y\t! SPARC has 0-3 delay insn after a wr\n+\tsra\t%3,31,%%g2\t! Don't move this insn\n+\tand\t%2,%%g2,%%g2\t! Don't move this insn\n+\tandcc\t%%g0,0,%%g1\t! Don't move this insn\n+\tmulscc\t%%g1,%3,%%g1\n+\tmulscc\t%%g1,%3,%%g1\n+\tmulscc\t%%g1,%3,%%g1\n+\tmulscc\t%%g1,%3,%%g1\n+\tmulscc\t%%g1,%3,%%g1\n+\tmulscc\t%%g1,%3,%%g1\n+\tmulscc\t%%g1,%3,%%g1\n+\tmulscc\t%%g1,%3,%%g1\n+\tmulscc\t%%g1,%3,%%g1\n+\tmulscc\t%%g1,%3,%%g1\n+\tmulscc\t%%g1,%3,%%g1\n+\tmulscc\t%%g1,%3,%%g1\n+\tmulscc\t%%g1,%3,%%g1\n+\tmulscc\t%%g1,%3,%%g1\n+\tmulscc\t%%g1,%3,%%g1\n+\tmulscc\t%%g1,%3,%%g1\n+\tmulscc\t%%g1,%3,%%g1\n+\tmulscc\t%%g1,%3,%%g1\n+\tmulscc\t%%g1,%3,%%g1\n+\tmulscc\t%%g1,%3,%%g1\n+\tmulscc\t%%g1,%3,%%g1\n+\tmulscc\t%%g1,%3,%%g1\n+\tmulscc\t%%g1,%3,%%g1\n+\tmulscc\t%%g1,%3,%%g1\n+\tmulscc\t%%g1,%3,%%g1\n+\tmulscc\t%%g1,%3,%%g1\n+\tmulscc\t%%g1,%3,%%g1\n+\tmulscc\t%%g1,%3,%%g1\n+\tmulscc\t%%g1,%3,%%g1\n+\tmulscc\t%%g1,%3,%%g1\n+\tmulscc\t%%g1,%3,%%g1\n+\tmulscc\t%%g1,%3,%%g1\n+\tmulscc\t%%g1,0,%%g1\n+\tadd\t%%g1,%%g2,%0\n+\trd\t%%y,%1\"\t\t\t\t\t\t\t\\\n+\t: \"=r\" ((unsigned long int)(w1)), \"=r\" ((unsigned long int)(w0))\\\n+\t: \"%rI\" ((unsigned long int)(u)), \"r\" ((unsigned long int)(v))\t\\\n+       : \"%g1\", \"%g2\")\n+#define UMUL_TIME 39\t\t/* 39 instructions */\n+/* It's quite necessary to add this much assembler for the sparc.\n+   The default udiv_qrnnd (in C) is more than 10 times slower!  */\n+#define udiv_qrnnd(q, r, n1, n0, d) \\\n+  __asm__ (\"! Inlined udiv_qrnnd\n+\tmov\t32,%%g1\n+\tsubcc\t%1,%2,%%g0\n+1:\tbcs\t5f\n+\t addxcc %0,%0,%0\t! shift n1n0 and a q-bit in lsb\n+\tsub\t%1,%2,%1\t! this kills msb of n\n+\taddx\t%1,%1,%1\t! so this can't give carry\n+\tsubcc\t%%g1,1,%%g1\n+2:\tbne\t1b\n+\t subcc\t%1,%2,%%g0\n+\tbcs\t3f\n+\t addxcc %0,%0,%0\t! shift n1n0 and a q-bit in lsb\n+\tb\t3f\n+\t sub\t%1,%2,%1\t! this kills msb of n\n+4:\tsub\t%1,%2,%1\n+5:\taddxcc\t%1,%1,%1\n+\tbcc\t2b\n+\t subcc\t%%g1,1,%%g1\n+! Got carry from n.  Subtract next step to cancel this carry.\n+\tbne\t4b\n+\t addcc\t%0,%0,%0\t! shift n1n0 and a 0-bit in lsb\n+\tsub\t%1,%2,%1\n+3:\txnor\t%0,0,%0\n+\t! End of inline udiv_qrnnd\"\t\t\t\t\t\\\n+\t: \"=r&\" ((unsigned long int)(q)), \"=r&\" ((unsigned long int)(r))\\\n+\t: \"r\" ((unsigned long int)(d)), \"1\" ((unsigned long int)(n1)),\t\\\n+\t  \"0\" ((unsigned long int)(n0)) : \"%g1\")\n+#define UDIV_TIME (3+7*32)\t/* 7 instructions/iteration. 32 iterations. */\n+#endif\n+#endif /* __sparc8__ */\n+\n+#if defined (__vax__)\n+#define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n+  __asm__ (\"addl2 %5,%1\n+\tadwc %3,%0\"\t\t\t\t\t\t\t\\\n+\t: \"=g\" ((unsigned long int)(sh)), \"=&g\" ((unsigned long int)(sl))\\\n+\t: \"%0\" ((unsigned long int)(ah)), \"g\" ((unsigned long int)(bh)),\\\n+\t  \"%1\" ((unsigned long int)(al)), \"g\" ((unsigned long int)(bl)))\n+#define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n+  __asm__ (\"subl2 %5,%1\n+\tsbwc %3,%0\"\t\t\t\t\t\t\t\\\n+\t: \"=g\" ((unsigned long int)(sh)), \"=&g\" ((unsigned long int)(sl))\\\n+\t: \"0\" ((unsigned long int)(ah)), \"g\" ((unsigned long int)(bh)),\t\\\n+\t  \"1\" ((unsigned long int)(al)), \"g\" ((unsigned long int)(bl)))\n+#define umul_ppmm(xh, xl, m0, m1) \\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    union {long long int ll;struct {unsigned long int l, h;} i;} __xx;\t\\\n+    unsigned long int __m0 = (m0), __m1 = (m1);\t\t\t\t\\\n+    __asm__ (\"emul %1,%2,$0,%0\"\t\t\t\t\t\t\\\n+\t : \"=r\" (__xx.ll) : \"g\" (__m0), \"g\" (__m1));\t\t\t\\\n+    (xh) = __xx.i.h; (xl) = __xx.i.l;\t\t\t\t\t\\\n+    (xh) += ((((signed long int) __m0 >> 31) & __m1)\t\t\t\\\n+\t     + (((signed long int) __m1 >> 31) & __m0));\t\t\\\n+  } while (0)\n+#endif /* __vax__ */\n+\n+#endif /* __GNUC__ */\n+\n+/* If this machine has no inline assembler, use C macros.  */\n+\n+#if !defined (add_ssaaaa)\n+#define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    unsigned long int __x;\t\t\t\t\t\t\\\n+    __x = (al) + (bl);\t\t\t\t\t\t\t\\\n+    (sh) = (ah) + (bh) + (__x < (al));\t\t\t\t\t\\\n+    (sl) = __x;\t\t\t\t\t\t\t\t\\\n+  } while (0)\n+#endif\n+\n+#if !defined (sub_ddmmss)\n+#define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    unsigned long int __x;\t\t\t\t\t\t\\\n+    __x = (al) - (bl);\t\t\t\t\t\t\t\\\n+    (sh) = (ah) - (bh) - (__x > (al));\t\t\t\t\t\\\n+    (sl) = __x;\t\t\t\t\t\t\t\t\\\n+  } while (0)\n+#endif\n+\n+#if !defined (umul_ppmm)\n+#define umul_ppmm(w1, w0, u, v)\t\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    unsigned long int __x0, __x1, __x2, __x3;\t\t\t\t\\\n+    unsigned int __ul, __vl, __uh, __vh;\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    __ul = __ll_lowpart (u);\t\t\t\t\t\t\\\n+    __uh = __ll_highpart (u);\t\t\t\t\t\t\\\n+    __vl = __ll_lowpart (v);\t\t\t\t\t\t\\\n+    __vh = __ll_highpart (v);\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    __x0 = (unsigned long int) __ul * __vl;\t\t\t\t\\\n+    __x1 = (unsigned long int) __ul * __vh;\t\t\t\t\\\n+    __x2 = (unsigned long int) __uh * __vl;\t\t\t\t\\\n+    __x3 = (unsigned long int) __uh * __vh;\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    __x1 += __ll_highpart (__x0);/* this can't give carry */\t\t\\\n+    __x1 += __x2;\t\t/* but this indeed can */\t\t\\\n+    if (__x1 < __x2)\t\t/* did we get it? */\t\t\t\\\n+      __x3 += __ll_B;\t\t/* yes, add it in the proper pos. */\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    (w1) = __x3 + __ll_highpart (__x1);\t\t\t\t\t\\\n+    (w0) = __ll_lowpart (__x1) * __ll_B + __ll_lowpart (__x0);\t\t\\\n+  } while (0)\n+#endif\n+\n+#if !defined (__umulsidi3)\n+#define __umulsidi3(u, v) \\\n+  ({long_long __w;\t\t\t\t\t\t\t\\\n+    umul_ppmm (__w.s.high, __w.s.low, u, v);\t\t\t\t\\\n+    __w.ll; })\n+#endif\n+\n+#if !defined (udiv_qrnnd)  || defined (__LLDEBUG__)\n+#define UDIV_NEEDS_NORMALIZATION 1\n+#ifndef __LLDEBUG__\n+#define udiv_qrnnd udiv_qrnnd_c\n+#endif\n+#define udiv_qrnnd_c(q, r, n1, n0, d) \\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    unsigned int __d1, __d0, __q1, __q0;\t\t\t\t\\\n+    unsigned long int __r1, __r0, __m;\t\t\t\t\t\\\n+    __d1 = __ll_highpart (d);\t\t\t\t\t\t\\\n+    __d0 = __ll_lowpart (d);\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    __r1 = (n1) % __d1;\t\t\t\t\t\t\t\\\n+    __q1 = (n1) / __d1;\t\t\t\t\t\t\t\\\n+    __m = (unsigned long int) __q1 * __d0;\t\t\t\t\\\n+    __r1 = __r1 * __ll_B | __ll_highpart (n0);\t\t\t\t\\\n+    if (__r1 < __m)\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\t__q1--, __r1 += (d);\t\t\t\t\t\t\\\n+\tif (__r1 >= (d)) /* i.e. we didn't get carry when adding to __r1 */\\\n+\t  if (__r1 < __m)\t\t\t\t\t\t\\\n+\t    __q1--, __r1 += (d);\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    __r1 -= __m;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    __r0 = __r1 % __d1;\t\t\t\t\t\t\t\\\n+    __q0 = __r1 / __d1;\t\t\t\t\t\t\t\\\n+    __m = (unsigned long int) __q0 * __d0;\t\t\t\t\\\n+    __r0 = __r0 * __ll_B | __ll_lowpart (n0);\t\t\t\t\\\n+    if (__r0 < __m)\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\t__q0--, __r0 += (d);\t\t\t\t\t\t\\\n+\tif (__r0 >= (d))\t\t\t\t\t\t\\\n+\t  if (__r0 < __m)\t\t\t\t\t\t\\\n+\t    __q0--, __r0 += (d);\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    __r0 -= __m;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    (q) = (unsigned long int) __q1 * __ll_B | __q0;\t\t\t\\\n+    (r) = __r0;\t\t\t\t\t\t\t\t\\\n+  } while (0)\n+#endif\n+\n+#if !defined (count_leading_zeros)\n+extern const unsigned char __clz_tab[];\n+\n+#define count_leading_zeros(count, x) \\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    unsigned long int xr = (x);\t\t\t\t\t\t\\\n+    unsigned int a;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    a = xr < (1<<2*__BITS4)\t\t\t\t\t\t\\\n+      ? (xr < (1<<__BITS4) ? 0 : __BITS4)\t\t\t\t\\\n+      : (xr < (1<<3*__BITS4) ?  2*__BITS4 : 3*__BITS4);\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    (count) = 4*__BITS4 - (__clz_tab[xr >> a] + a);\t\t\t\\\n+  } while (0)\n+#endif\n+\n+#ifndef UDIV_NEEDS_NORMALIZATION\n+#define UDIV_NEEDS_NORMALIZATION 0\n+#endif"}, {"sha": "75d0c0afa4b64513248b467b9fab8befc2ce24b2", "filename": "gcc/print-rtl.c", "status": "added", "additions": 229, "deletions": 0, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1a799159abfd0d6d67c6388102ef1b800cc082c/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1a799159abfd0d6d67c6388102ef1b800cc082c/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=e1a799159abfd0d6d67c6388102ef1b800cc082c", "patch": "@@ -0,0 +1,229 @@\n+/* Print RTL for GNU C Compiler.\n+   Copyright (C) 1987-1991 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+#include \"config.h\"\n+#include <ctype.h>\n+#include <stdio.h>\n+#include \"rtl.h\"\n+\n+\n+static FILE *outfile;\n+\n+char spaces[] = \"                                                                                                                                                                \";\n+\n+static int sawclose = 0;\n+\n+/* Names for patterns.  Non-zero only when linked with insn-output.c.  */\n+\n+extern char **insn_name_ptr;\n+\n+/* Print IN_RTX onto OUTFILE.  This is the recursive part of printing.  */\n+\n+static void\n+print_rtx (in_rtx)\n+     register rtx in_rtx;\n+{\n+  static int indent;\n+  register int i, j;\n+  register char *format_ptr;\n+  register int is_insn;\n+\n+  if (sawclose)\n+    {\n+      fprintf (outfile, \"\\n%s\",\n+\t       (spaces + (sizeof spaces - indent * 2)));\n+      sawclose = 0;\n+    }\n+\n+  if (in_rtx == 0)\n+    {\n+      fprintf (outfile, \"(nil)\");\n+      sawclose = 1;\n+      return;\n+    }\n+\n+  /* print name of expression code */\n+  fprintf (outfile, \"(%s\", GET_RTX_NAME (GET_CODE (in_rtx)));\n+\n+  if (in_rtx->in_struct)\n+    fprintf (outfile, \"/s\");\n+\n+  if (in_rtx->volatil)\n+    fprintf (outfile, \"/v\");\n+\n+  if (in_rtx->unchanging)\n+    fprintf (outfile, \"/u\");\n+\n+  if (in_rtx->integrated)\n+    fprintf (outfile, \"/i\");\n+\n+  if (GET_MODE (in_rtx) != VOIDmode)\n+    {\n+      /* Print REG_NOTE names for EXPR_LIST and INSN_LIST.  */\n+      if (GET_CODE (in_rtx) == EXPR_LIST || GET_CODE (in_rtx) == INSN_LIST)\n+\tfprintf (outfile, \":%s\", GET_REG_NOTE_NAME (GET_MODE (in_rtx)));\n+      else\n+\tfprintf (outfile, \":%s\", GET_MODE_NAME (GET_MODE (in_rtx)));\n+    }\n+\n+  is_insn = (GET_RTX_CLASS (GET_CODE (in_rtx)) == 'i');\n+  format_ptr = GET_RTX_FORMAT (GET_CODE (in_rtx));\n+\n+  for (i = 0; i < GET_RTX_LENGTH (GET_CODE (in_rtx)); i++)\n+    switch (*format_ptr++)\n+      {\n+      case 'S':\n+      case 's':\n+\tif (XSTR (in_rtx, i) == 0)\n+\t  fprintf (outfile, \" \\\"\\\"\");\n+\telse\n+\t  fprintf (outfile, \" (\\\"%s\\\")\", XSTR (in_rtx, i));\n+\tsawclose = 1;\n+\tbreak;\n+\n+\t/* 0 indicates a field for internal use that should not be printed.  */\n+      case '0':\n+\tbreak;\n+\n+      case 'e':\n+\tindent += 2;\n+\tif (!sawclose)\n+\t  fprintf (outfile, \" \");\n+\tprint_rtx (XEXP (in_rtx, i));\n+\tindent -= 2;\n+\tbreak;\n+\n+      case 'E':\n+      case 'V':\n+\tindent += 2;\n+\tif (sawclose)\n+\t  {\n+\t    fprintf (outfile, \"\\n%s\",\n+\t\t     (spaces + (sizeof spaces - indent * 2)));\n+\t    sawclose = 0;\n+\t  }\n+\tfprintf (outfile, \"[ \");\n+\tif (NULL != XVEC (in_rtx, i))\n+\t  {\n+\t    indent += 2;\n+\t    if (XVECLEN (in_rtx, i))\n+\t      sawclose = 1;\n+\n+\t    for (j = 0; j < XVECLEN (in_rtx, i); j++)\n+\t      print_rtx (XVECEXP (in_rtx, i, j));\n+\n+\t    indent -= 2;\n+\t  }\n+\tif (sawclose)\n+\t  fprintf (outfile, \"\\n%s\",\n+\t\t   (spaces + (sizeof spaces - indent * 2)));\n+\n+\tfprintf (outfile, \"] \");\n+\tsawclose = 1;\n+\tindent -= 2;\n+\tbreak;\n+\n+      case 'i':\n+\tfprintf (outfile, \" %d\", XINT (in_rtx, i));\n+\tif (is_insn && &INSN_CODE (in_rtx) == &XINT (in_rtx, i)\n+\t    && insn_name_ptr\n+\t    && XINT (in_rtx, i) >= 0)\n+\t    fprintf (outfile, \" {%s}\", insn_name_ptr[XINT (in_rtx, i)]);\n+\tsawclose = 0;\n+\tbreak;\n+\n+      /* Print NOTE_INSN names rather than integer codes.  */\n+\n+      case 'n':\n+\tif (XINT (in_rtx, i) <= 0)\n+\t  fprintf (outfile, \" %s\", GET_NOTE_INSN_NAME (XINT (in_rtx, i)));\n+\telse\n+\t  fprintf (outfile, \" %d\", XINT (in_rtx, i));\n+\tsawclose = 0;\n+\tbreak;\n+\n+      case 'u':\n+\tif (XEXP (in_rtx, i) != NULL)\n+\t  fprintf(outfile, \" %d\", INSN_UID (XEXP (in_rtx, i)));\n+\telse\n+\t  fprintf(outfile, \" 0\");\n+\tsawclose = 0;\n+\tbreak;\n+\n+      default:\n+\tfprintf (stderr,\n+\t\t \"switch format wrong in rtl.print_rtx(). format was: %c.\\n\",\n+\t\t format_ptr[-1]);\n+\tabort ();\n+      }\n+\n+  fprintf (outfile, \")\");\n+  sawclose = 1;\n+}\n+\n+/* Call this function from the debugger to see what X looks like.  */\n+\n+void\n+debug_rtx (x)\n+     rtx x;\n+{\n+  outfile = stderr;\n+  print_rtx (x);\n+  fprintf (stderr, \"\\n\");\n+}\n+\n+/* External entry point for printing a chain of insns\n+   starting with RTX_FIRST onto file OUTF.\n+   A blank line separates insns.\n+\n+   If RTX_FIRST is not an insn, then it alone is printed, with no newline.  */\n+\n+void\n+print_rtl (outf, rtx_first)\n+     FILE *outf;\n+     rtx rtx_first;\n+{\n+  register rtx tmp_rtx;\n+\n+  outfile = outf;\n+  sawclose = 0;\n+\n+  if (rtx_first == 0)\n+    fprintf (outf, \"(nil)\\n\");\n+  else\n+    switch (GET_CODE (rtx_first))\n+      {\n+      case INSN:\n+      case JUMP_INSN:\n+      case CALL_INSN:\n+      case NOTE:\n+      case CODE_LABEL:\n+      case BARRIER:\n+\tfor (tmp_rtx = rtx_first; NULL != tmp_rtx; tmp_rtx = NEXT_INSN (tmp_rtx))\n+\t  {\n+\t    print_rtx (tmp_rtx);\n+\t    fprintf (outfile, \"\\n\");\n+\t  }\n+\tbreak;\n+\n+      default:\n+\tprint_rtx (rtx_first);\n+      }\n+}"}]}