{"sha": "b16caf72c73fd21bc729b9f039869800194bb1a0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjE2Y2FmNzJjNzNmZDIxYmM3MjliOWYwMzk4Njk4MDAxOTRiYjFhMA==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2006-02-17T04:15:32Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2006-02-17T04:15:32Z"}, "message": "tree-vrp.c (set_value_range_to_nonnegative): New function.\n\n\n\t* tree-vrp.c (set_value_range_to_nonnegative): New function.\n\t(vrp_expr_computes_nonnegative, ssa_name_nonnegative_p): Likewise.\n\t(ssa_name_nonzero_p): Likewise.\n\t(get_value_range): Return NULL if VRP is not running.\n\t(extract_range_from_expr): Fallback to tree_expr_XXX_p if\n\tVRP routines do not discover a range.\n\t(vrp_finalize): Clear VR_VALUE to indicate VRP is not running.\n\t* tree.h (ssa_name_nonzero_p, ssa_name_nonnegative_p): Prototype.\n\t* fold-const.c (tree_expr_nonzero_p): For SSA_NAMEs, query VRP.\n\t(tree_expr_nonnegative_p): Similarly.\n\t* tree-ssa-dom.c (nonzero_vars, nonzero_vars_stack): Remove.\n\t(restore_nonzero_vars_to_original_value): Remove.\n\t(unsafe_associative_fp_binop): Remove.\n\t(tree_ssa_dominator_optimize): Remove initialization and\n\tfinalization of nonzero_vars and nonzero_vars_stack.\n\t(dom_opt_initialize_block): No longer push marker on\n\tnonzero_vars_stack.\n\t(dom_opt_finalize_block): No longer call\n\trestore_nonzero_vars_to_original_value.\n\t(record_equivalences_from_phis): No longer look for\n\tnonzero PHI arguments.\n\t(cprop_into_successor_phis): No longer propagate nonzero\n\tproperty into PHI arguments.  Lose unused argument.  Caller\n\tupdated.\n\t(record_equivalences_from_stmt): No longer record nonzero\n\tvalues for SSA_NAMEs.\n\t(lookup_avail_expr): No longer use nonzero_vars.\n\n\t* gcc.dg/tree-ssa/vrp24.c: Update expected output.\n\t* gcc.dg/tree-ssa/vrp26.c: New test.\n\nFrom-SVN: r111175", "tree": {"sha": "baa21343ce68c59242247d5fe6009ab29fba14f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/baa21343ce68c59242247d5fe6009ab29fba14f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b16caf72c73fd21bc729b9f039869800194bb1a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b16caf72c73fd21bc729b9f039869800194bb1a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b16caf72c73fd21bc729b9f039869800194bb1a0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b16caf72c73fd21bc729b9f039869800194bb1a0/comments", "author": null, "committer": null, "parents": [{"sha": "7f18f91710ecaf3f6f90989716f07f5a247d0764", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f18f91710ecaf3f6f90989716f07f5a247d0764", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f18f91710ecaf3f6f90989716f07f5a247d0764"}], "stats": {"total": 330, "additions": 163, "deletions": 167}, "files": [{"sha": "79edc91b808177755c7e9b7aa7a5883fa7d49489", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b16caf72c73fd21bc729b9f039869800194bb1a0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b16caf72c73fd21bc729b9f039869800194bb1a0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b16caf72c73fd21bc729b9f039869800194bb1a0", "patch": "@@ -1,5 +1,33 @@\n 2006-02-16  Jeff Law  <law@redhat.com>\n \n+\t* tree-vrp.c (set_value_range_to_nonnegative): New function.\n+\t(vrp_expr_computes_nonnegative, ssa_name_nonnegative_p): Likewise.\n+\t(ssa_name_nonzero_p): Likewise.\n+\t(get_value_range): Return NULL if VRP is not running.\n+\t(extract_range_from_expr): Fallback to tree_expr_XXX_p if\n+\tVRP routines do not discover a range.\n+\t(vrp_finalize): Clear VR_VALUE to indicate VRP is not running.\n+\t* tree.h (ssa_name_nonzero_p, ssa_name_nonnegative_p): Prototype.\n+\t* fold-const.c (tree_expr_nonzero_p): For SSA_NAMEs, query VRP.\n+\t(tree_expr_nonnegative_p): Similarly.\n+\t* tree-ssa-dom.c (nonzero_vars, nonzero_vars_stack): Remove.\n+\t(restore_nonzero_vars_to_original_value): Remove.\n+\t(unsafe_associative_fp_binop): Remove.\n+\t(tree_ssa_dominator_optimize): Remove initialization and\n+\tfinalization of nonzero_vars and nonzero_vars_stack.\n+\t(dom_opt_initialize_block): No longer push marker on\n+\tnonzero_vars_stack.\n+\t(dom_opt_finalize_block): No longer call\n+\trestore_nonzero_vars_to_original_value.\n+\t(record_equivalences_from_phis): No longer look for\n+\tnonzero PHI arguments.\n+\t(cprop_into_successor_phis): No longer propagate nonzero\n+\tproperty into PHI arguments.  Lose unused argument.  Caller\n+\tupdated.\n+\t(record_equivalences_from_stmt): No longer record nonzero\n+\tvalues for SSA_NAMEs.\n+\t(lookup_avail_expr): No longer use nonzero_vars.\n+\n \t* stor-layout.c (set_sizetype): Set TYPE_MAX_VALUE properly\n \tfor sizetype when sizetype is unsigned.\n "}, {"sha": "7413883a904e0fe2aafc7373e3f61cdab9ee2de8", "filename": "gcc/fold-const.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b16caf72c73fd21bc729b9f039869800194bb1a0/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b16caf72c73fd21bc729b9f039869800194bb1a0/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=b16caf72c73fd21bc729b9f039869800194bb1a0", "patch": "@@ -11054,6 +11054,11 @@ tree_expr_nonnegative_p (tree t)\n \n   switch (TREE_CODE (t))\n     {\n+    case SSA_NAME:\n+      /* Query VRP to see if it has recorded any information about\n+\t the range of this object.  */\n+      return ssa_name_nonnegative_p (t);\n+\n     case ABS_EXPR:\n       /* We can't return 1 if flag_wrapv is set because\n \t ABS_EXPR<INT_MIN> = INT_MIN.  */\n@@ -11317,6 +11322,11 @@ tree_expr_nonzero_p (tree t)\n \n   switch (TREE_CODE (t))\n     {\n+    case SSA_NAME:\n+      /* Query VRP to see if it has recorded any information about\n+\t the range of this object.  */\n+      return ssa_name_nonzero_p (t);\n+\n     case ABS_EXPR:\n       return tree_expr_nonzero_p (TREE_OPERAND (t, 0));\n "}, {"sha": "cb41751d97c1dbb649d35f729494f7affd8785d8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b16caf72c73fd21bc729b9f039869800194bb1a0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b16caf72c73fd21bc729b9f039869800194bb1a0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b16caf72c73fd21bc729b9f039869800194bb1a0", "patch": "@@ -1,3 +1,8 @@\n+2006-02-16  Jeff Law  <law@redhat.com>\n+\n+\t* gcc.dg/tree-ssa/vrp24.c: Update expected output.\n+\t* gcc.dg/tree-ssa/vrp26.c: New test.\n+\n 2006-02-16  Joseph S. Myers  <joseph@codesourcery.com>\n \n \tPR target/20353"}, {"sha": "85e5b62d14804e1661a802445093690daa24f6ad", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp24.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b16caf72c73fd21bc729b9f039869800194bb1a0/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp24.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b16caf72c73fd21bc729b9f039869800194bb1a0/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp24.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp24.c?ref=b16caf72c73fd21bc729b9f039869800194bb1a0", "patch": "@@ -79,11 +79,13 @@ sss (rtx insn, int code1, int code2, int code3)\n \n }\n \n-\n-\n-/* The n_sets > 0 test can be simplified into n_sets == 1 since the\n-   only way to reach the test is when n_sets <= 1, and the only value\n-   which satisfies both conditions is n_sets == 1.  */\n-/* { dg-final { scan-tree-dump-times \"Simplified relational\" 1 \"vrp1\" } } */\n+/* The first n_sets > 0 test can be simplfiied into n_sets == 1 since\n+   n_sets can only have the values [0, 1] as it's the result of a\n+   boolean operation.\n+\n+   The second n_sets > 0 test can also be simplified into n_sets == 1\n+   as the only way to reach the tests is when n_sets <= 1 and the only\n+   value which satisfies both conditions is n_sets == 1.  */\n+/* { dg-final { scan-tree-dump-times \"Simplified relational\" 2 \"vrp1\" } } */\n /* { dg-final { cleanup-tree-dump \"vrp1\" } } */\n "}, {"sha": "621541630bb9f756cff5cf5f7bfcd6a97aa29080", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp26.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b16caf72c73fd21bc729b9f039869800194bb1a0/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp26.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b16caf72c73fd21bc729b9f039869800194bb1a0/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp26.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp26.c?ref=b16caf72c73fd21bc729b9f039869800194bb1a0", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1\" } */\n+\n+int \n+foo(int a)\n+{\n+  int z = a | 1;\n+  return z != 0;\n+}\n+\n+/* VRP should optimize this to a trivial \"return 1\".   */\n+/* { dg-final { scan-tree-dump-times \"return 1\" 1 \"vrp1\" } } * /\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */\n+\n+\n+\n+"}, {"sha": "c79a4ca636aa24de25c65cff71b796ffed33ed09", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 6, "deletions": 157, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b16caf72c73fd21bc729b9f039869800194bb1a0/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b16caf72c73fd21bc729b9f039869800194bb1a0/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=b16caf72c73fd21bc729b9f039869800194bb1a0", "patch": "@@ -135,17 +135,6 @@ struct expr_hash_elt\n    restored during finalization of this block.  */\n static VEC(tree,heap) *const_and_copies_stack;\n \n-/* Bitmap of SSA_NAMEs known to have a nonzero value, even if we do not\n-   know their exact value.  */\n-static bitmap nonzero_vars;\n-\n-/* Stack of SSA_NAMEs which need their NONZERO_VARS property cleared\n-   when the current block is finalized. \n-\n-   A NULL entry is used to mark the end of names needing their \n-   entry in NONZERO_VARS cleared during finalization of this block.  */\n-static VEC(tree,heap) *nonzero_vars_stack;\n-\n /* Track whether or not we have changed the control flow graph.  */\n static bool cfg_altered;\n \n@@ -194,8 +183,6 @@ static void propagate_to_outgoing_edges (struct dom_walk_data *, basic_block);\n static void remove_local_expressions_from_table (void);\n static void restore_vars_to_original_value (void);\n static edge single_incoming_edge_ignoring_loop_edges (basic_block);\n-static void restore_nonzero_vars_to_original_value (void);\n-static inline bool unsafe_associative_fp_binop (tree);\n \n \n /* Allocate an EDGE_INFO for edge E and attach it to E.\n@@ -261,9 +248,7 @@ tree_ssa_dominator_optimize (void)\n   avail_exprs = htab_create (1024, real_avail_expr_hash, avail_expr_eq, free);\n   avail_exprs_stack = VEC_alloc (tree, heap, 20);\n   const_and_copies_stack = VEC_alloc (tree, heap, 20);\n-  nonzero_vars_stack = VEC_alloc (tree, heap, 20);\n   stmts_to_rescan = VEC_alloc (tree, heap, 20);\n-  nonzero_vars = BITMAP_ALLOC (NULL);\n   need_eh_cleanup = BITMAP_ALLOC (NULL);\n \n   /* Setup callbacks for the generic dominator tree walker.  */\n@@ -367,13 +352,11 @@ tree_ssa_dominator_optimize (void)\n   /* And finalize the dominator walker.  */\n   fini_walk_dominator_tree (&walk_data);\n \n-  /* Free nonzero_vars.  */\n-  BITMAP_FREE (nonzero_vars);\n+  /* Free asserted bitmaps and stacks.  */\n   BITMAP_FREE (need_eh_cleanup);\n   \n   VEC_free (tree, heap, avail_exprs_stack);\n   VEC_free (tree, heap, const_and_copies_stack);\n-  VEC_free (tree, heap, nonzero_vars_stack);\n   VEC_free (tree, heap, stmts_to_rescan);\n }\n \n@@ -466,7 +449,6 @@ dom_opt_initialize_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n      far to unwind when we finalize this block.  */\n   VEC_safe_push (tree, heap, avail_exprs_stack, NULL_TREE);\n   VEC_safe_push (tree, heap, const_and_copies_stack, NULL_TREE);\n-  VEC_safe_push (tree, heap, nonzero_vars_stack, NULL_TREE);\n \n   record_equivalences_from_incoming_edge (bb);\n \n@@ -540,23 +522,6 @@ remove_local_expressions_from_table (void)\n     }\n }\n \n-/* Use the SSA_NAMES in LOCALS to restore TABLE to its original\n-   state, stopping when there are LIMIT entries left in LOCALs.  */\n-\n-static void\n-restore_nonzero_vars_to_original_value (void)\n-{\n-  while (VEC_length (tree, nonzero_vars_stack) > 0)\n-    {\n-      tree name = VEC_pop (tree, nonzero_vars_stack);\n-\n-      if (name == NULL)\n-\tbreak;\n-\n-      bitmap_clear_bit (nonzero_vars, SSA_NAME_VERSION (name));\n-    }\n-}\n-\n /* Use the source/dest pairs in CONST_AND_COPIES_STACK to restore\n    CONST_AND_COPIES to its original state, stopping when we hit a\n    NULL marker.  */\n@@ -728,7 +693,6 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n     }\n \n   remove_local_expressions_from_table ();\n-  restore_nonzero_vars_to_original_value ();\n   restore_vars_to_original_value ();\n \n   /* If we queued any statements to rescan in this block, then\n@@ -750,11 +714,7 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n \n    Ignoring any alternatives which are the same as the result, if\n    all the alternatives are equal, then the PHI node creates an\n-   equivalence.\n-\n-   Additionally, if all the PHI alternatives are known to have a nonzero\n-   value, then the result of this PHI is known to have a nonzero value,\n-   even if we do not know its exact value.  */\n+   equivalence.  */\n \n static void\n record_equivalences_from_phis (basic_block bb)\n@@ -802,17 +762,6 @@ record_equivalences_from_phis (basic_block bb)\n       if (i == PHI_NUM_ARGS (phi)\n \t  && may_propagate_copy (lhs, rhs))\n \tSSA_NAME_VALUE (lhs) = rhs;\n-\n-      /* Now see if we know anything about the nonzero property for the\n-\t result of this PHI.  */\n-      for (i = 0; i < PHI_NUM_ARGS (phi); i++)\n-\t{\n-\t  if (!PHI_ARG_NONZERO (phi, i))\n-\t    break;\n-\t}\n-\n-      if (i == PHI_NUM_ARGS (phi))\n-\tbitmap_set_bit (nonzero_vars, SSA_NAME_VERSION (PHI_RESULT (phi)));\n     }\n }\n \n@@ -944,26 +893,6 @@ htab_statistics (FILE *file, htab_t htab)\n \t   htab_collisions (htab));\n }\n \n-/* Record the fact that VAR has a nonzero value, though we may not know\n-   its exact value.  Note that if VAR is already known to have a nonzero\n-   value, then we do nothing.  */\n-\n-static void\n-record_var_is_nonzero (tree var)\n-{\n-  int indx = SSA_NAME_VERSION (var);\n-\n-  if (bitmap_bit_p (nonzero_vars, indx))\n-    return;\n-\n-  /* Mark it in the global table.  */\n-  bitmap_set_bit (nonzero_vars, indx);\n-\n-  /* Record this SSA_NAME so that we can reset the global table\n-     when we leave this block.  */\n-  VEC_safe_push (tree, heap, nonzero_vars_stack, var);\n-}\n-\n /* Enter a statement into the true/false expression hash table indicating\n    that the condition COND has the value VALUE.  */\n \n@@ -1213,19 +1142,6 @@ record_equality (tree x, tree y)\n   record_const_or_copy_1 (x, y, prev_x);\n }\n \n-/* Return true, if it is ok to do folding of an associative expression.\n-   EXP is the tree for the associative expression.  */ \n-\n-static inline bool\n-unsafe_associative_fp_binop (tree exp)\n-{\n-  enum tree_code code = TREE_CODE (exp);\n-  return !(!flag_unsafe_math_optimizations\n-           && (code == MULT_EXPR || code == PLUS_EXPR\n-\t       || code == MINUS_EXPR)\n-           && FLOAT_TYPE_P (TREE_TYPE (exp)));\n-}\n-\n /* Returns true when STMT is a simple iv increment.  It detects the\n    following situation:\n    \n@@ -1269,14 +1185,11 @@ simple_iv_increment_p (tree stmt)\n /* CONST_AND_COPIES is a table which maps an SSA_NAME to the current\n    known value for that SSA_NAME (or NULL if no value is known).  \n \n-   NONZERO_VARS is the set SSA_NAMES known to have a nonzero value,\n-   even if we don't know their precise value.\n-\n-   Propagate values from CONST_AND_COPIES and NONZERO_VARS into the PHI\n-   nodes of the successors of BB.  */\n+   Propagate values from CONST_AND_COPIES into the PHI nodes of the\n+   successors of BB.  */\n \n static void\n-cprop_into_successor_phis (basic_block bb, bitmap nonzero_vars)\n+cprop_into_successor_phis (basic_block bb)\n {\n   edge e;\n   edge_iterator ei;\n@@ -1309,11 +1222,6 @@ cprop_into_successor_phis (basic_block bb, bitmap nonzero_vars)\n \t  if (TREE_CODE (orig) != SSA_NAME)\n \t    continue;\n \n-\t  /* If the alternative is known to have a nonzero value, record\n-\t     that fact in the PHI node itself for future use.  */\n-\t  if (bitmap_bit_p (nonzero_vars, SSA_NAME_VERSION (orig)))\n-\t    PHI_ARG_NONZERO (phi, indx) = true;\n-\n \t  /* If we have *ORIG_P in our constant/copy table, then replace\n \t     ORIG_P with its value in our constant/copy table.  */\n \t  new = SSA_NAME_VALUE (orig);\n@@ -1518,7 +1426,7 @@ propagate_to_outgoing_edges (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n \t\t\t     basic_block bb)\n {\n   record_edge_info (bb);\n-  cprop_into_successor_phis (bb, nonzero_vars);\n+  cprop_into_successor_phis (bb);\n }\n \n /* Search for redundant computations in STMT.  If any are found, then\n@@ -1626,7 +1534,6 @@ record_equivalences_from_stmt (tree stmt,\n {\n   tree lhs = TREE_OPERAND (stmt, 0);\n   enum tree_code lhs_code = TREE_CODE (lhs);\n-  int i;\n \n   if (lhs_code == SSA_NAME)\n     {\n@@ -1645,48 +1552,8 @@ record_equivalences_from_stmt (tree stmt,\n \t  && (TREE_CODE (rhs) == SSA_NAME\n \t      || is_gimple_min_invariant (rhs)))\n \tSSA_NAME_VALUE (lhs) = rhs;\n-\n-      if (tree_expr_nonzero_p (rhs))\n-\trecord_var_is_nonzero (lhs);\n     }\n \n-  /* Look at both sides for pointer dereferences.  If we find one, then\n-     the pointer must be nonnull and we can enter that equivalence into\n-     the hash tables.  */\n-  if (flag_delete_null_pointer_checks)\n-    for (i = 0; i < 2; i++)\n-      {\n-\ttree t = TREE_OPERAND (stmt, i);\n-\n-\t/* Strip away any COMPONENT_REFs.  */\n-\twhile (TREE_CODE (t) == COMPONENT_REF)\n-\t  t = TREE_OPERAND (t, 0);\n-\n-\t/* Now see if this is a pointer dereference.  */\n-\tif (INDIRECT_REF_P (t))\n-          {\n-\t    tree op = TREE_OPERAND (t, 0);\n-\n-\t    /* If the pointer is a SSA variable, then enter new\n-\t       equivalences into the hash table.  */\n-\t    while (TREE_CODE (op) == SSA_NAME)\n-\t      {\n-\t\ttree def = SSA_NAME_DEF_STMT (op);\n-\n-\t\trecord_var_is_nonzero (op);\n-\n-\t\t/* And walk up the USE-DEF chains noting other SSA_NAMEs\n-\t\t   which are known to have a nonzero value.  */\n-\t\tif (def\n-\t\t    && TREE_CODE (def) == MODIFY_EXPR\n-\t\t    && TREE_CODE (TREE_OPERAND (def, 1)) == NOP_EXPR)\n-\t\t  op = TREE_OPERAND (TREE_OPERAND (def, 1), 0);\n-\t\telse\n-\t\t  break;\n-\t      }\n-\t  }\n-      }\n-\n   /* A memory store, even an aliased store, creates a useful\n      equivalence.  By exchanging the LHS and RHS, creating suitable\n      vops and recording the result in the available expression table,\n@@ -2047,24 +1914,6 @@ lookup_avail_expr (tree stmt, bool insert)\n       return NULL_TREE;\n     }\n \n-  /* If this is an equality test against zero, see if we have recorded a\n-     nonzero value for the variable in question.  */\n-  if ((TREE_CODE (element->rhs) == EQ_EXPR\n-       || TREE_CODE  (element->rhs) == NE_EXPR)\n-      && TREE_CODE (TREE_OPERAND (element->rhs, 0)) == SSA_NAME\n-      && integer_zerop (TREE_OPERAND (element->rhs, 1)))\n-    {\n-      int indx = SSA_NAME_VERSION (TREE_OPERAND (element->rhs, 0));\n-\n-      if (bitmap_bit_p (nonzero_vars, indx))\n-\t{\n-\t  tree t = element->rhs;\n-\t  free (element);\n-\t  return constant_boolean_node (TREE_CODE (t) != EQ_EXPR,\n-\t\t\t\t\tTREE_TYPE (t));\n-\t}\n-    }\n-\n   /* Finally try to find the expression in the main expression hash table.  */\n   slot = htab_find_slot_with_hash (avail_exprs, element, element->hash,\n \t\t\t\t   (insert ? INSERT : NO_INSERT));"}, {"sha": "b6b6d409d0b92e9c2d650adfa8f1576e07eb15e3", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 85, "deletions": 4, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b16caf72c73fd21bc729b9f039869800194bb1a0/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b16caf72c73fd21bc729b9f039869800194bb1a0/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=b16caf72c73fd21bc729b9f039869800194bb1a0", "patch": "@@ -191,6 +191,14 @@ copy_value_range (value_range_t *to, value_range_t *from)\n   set_value_range (to, from->type, from->min, from->max, from->equiv);\n }\n \n+/* Set value range VR to a non-negative range of type TYPE.  */\n+\n+static inline void\n+set_value_range_to_nonnegative (value_range_t *vr, tree type)\n+{\n+  tree zero = build_int_cst (type, 0);\n+  set_value_range (vr, VR_RANGE, zero, TYPE_MAX_VALUE (type), vr->equiv);\n+}\n \n /* Set value range VR to a non-NULL range of type TYPE.  */\n \n@@ -236,8 +244,10 @@ set_value_range_to_undefined (value_range_t *vr)\n }\n \n \n-/* Return value range information for VAR.  Create an empty range\n-   if none existed.  */\n+/* Return value range information for VAR.  \n+\n+   If we have no values ranges recorded (ie, VRP is not running), then\n+   return NULL.  Otherwise create an empty range if none existed for VAR.  */\n \n static value_range_t *\n get_value_range (tree var)\n@@ -246,6 +256,10 @@ get_value_range (tree var)\n   tree sym;\n   unsigned ver = SSA_NAME_VERSION (var);\n \n+  /* If we have no recorded ranges, then return NULL.  */\n+  if (! vr_value)\n+    return NULL;\n+\n   vr = vr_value[ver];\n   if (vr)\n     return vr;\n@@ -358,6 +372,14 @@ symbolic_range_p (value_range_t *vr)\n           || !is_gimple_min_invariant (vr->max));\n }\n \n+/* Like tree_expr_nonnegative_p, but this function uses value ranges\n+   obtained so far.  */\n+\n+static bool\n+vrp_expr_computes_nonnegative (tree expr)\n+{\n+  return tree_expr_nonnegative_p (expr);\n+}\n \n /* Like tree_expr_nonzero_p, but this function uses value ranges\n    obtained so far.  */\n@@ -629,6 +651,50 @@ range_includes_zero_p (value_range_t *vr)\n   return (value_inside_range (zero, vr) == 1);\n }\n \n+/* Return true if T, an SSA_NAME, is known to be nonnegative.  Return\n+   false otherwise or if no value range information is available.  */\n+\n+bool\n+ssa_name_nonnegative_p (tree t)\n+{\n+  value_range_t *vr = get_value_range (t);\n+\n+  if (!vr)\n+    return false;\n+\n+  /* Testing for VR_ANTI_RANGE is not useful here as any anti-range\n+     which would return a useful value should be encoded as a VR_RANGE.  */\n+  if (vr->type == VR_RANGE)\n+    {\n+      int result = compare_values (vr->min, integer_zero_node);\n+\n+      return (result == 0 || result == 1);\n+    }\n+  return false;\n+}\n+\n+/* Return true if T, an SSA_NAME, is known to be nonzero.  Return\n+   false otherwise or if no value range information is available.  */\n+\n+bool\n+ssa_name_nonzero_p (tree t)\n+{\n+  value_range_t *vr = get_value_range (t);\n+\n+  if (!vr)\n+    return false;\n+\n+  /* A VR_RANGE which does not include zero is a nonzero value.  */\n+  if (vr->type == VR_RANGE && !symbolic_range_p (vr))\n+    return ! range_includes_zero_p (vr);\n+\n+  /* A VR_ANTI_RANGE which does include zero is a nonzero value.  */\n+  if (vr->type == VR_ANTI_RANGE && !symbolic_range_p (vr))\n+    return range_includes_zero_p (vr);\n+\n+  return false;\n+}\n+\n \n /* When extracting ranges from X_i = ASSERT_EXPR <Y_j, pred>, we will\n    initially consider X_i and Y_j equivalent, so the equivalence set\n@@ -1868,10 +1934,21 @@ extract_range_from_expr (value_range_t *vr, tree expr)\n     extract_range_from_comparison (vr, expr);\n   else if (is_gimple_min_invariant (expr))\n     set_value_range (vr, VR_RANGE, expr, expr, NULL);\n-  else if (vrp_expr_computes_nonzero (expr))\n-    set_value_range_to_nonnull (vr, TREE_TYPE (expr));\n   else\n     set_value_range_to_varying (vr);\n+\n+  /* If we got a varying range from the tests above, try a final\n+     time to derive a nonnegative or nonzero range.  This time\n+     relying primarily on generic routines in fold in conjunction\n+     with range data.  */\n+  if (vr->type == VR_VARYING)\n+    {\n+      if (INTEGRAL_TYPE_P (TREE_TYPE (expr))\n+\t  && vrp_expr_computes_nonnegative (expr))\n+        set_value_range_to_nonnegative (vr, TREE_TYPE (expr));\n+      else if (vrp_expr_computes_nonzero (expr))\n+        set_value_range_to_nonnull (vr, TREE_TYPE (expr));\n+    }\n }\n \n /* Given a range VR, a LOOP and a variable VAR, determine whether it\n@@ -4428,6 +4505,10 @@ vrp_finalize (void)\n \n   free (single_val_range);\n   free (vr_value);\n+\n+  /* So that we can distinguish between VRP data being available\n+     and not available.  */\n+  vr_value = NULL;\n }\n \n "}, {"sha": "3a321eb1872fae6d319f8df8b83e6dce76d50b0a", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b16caf72c73fd21bc729b9f039869800194bb1a0/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b16caf72c73fd21bc729b9f039869800194bb1a0/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=b16caf72c73fd21bc729b9f039869800194bb1a0", "patch": "@@ -4520,6 +4520,10 @@ extern int tree_map_eq (const void *, const void *);\n extern tree tree_mem_ref_addr (tree, tree);\n extern void copy_mem_ref_info (tree, tree);\n \n+/* In tree-vrp.c */\n+extern bool ssa_name_nonzero_p (tree);\n+extern bool ssa_name_nonnegative_p (tree);\n+\n /* In tree-object-size.c.  */\n extern void init_object_sizes (void);\n extern void fini_object_sizes (void);"}]}