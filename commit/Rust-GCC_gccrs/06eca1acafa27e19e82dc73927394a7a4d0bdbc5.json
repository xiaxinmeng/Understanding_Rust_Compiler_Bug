{"sha": "06eca1acafa27e19e82dc73927394a7a4d0bdbc5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDZlY2ExYWNhZmEyN2UxOWU4MmRjNzM5MjczOTRhN2E0ZDBiZGJjNQ==", "commit": {"author": {"name": "Thomas K\u00f6nig", "email": "tkoenig@gcc.gnu.org", "date": "2020-04-23T18:30:01Z"}, "committer": {"name": "Thomas K\u00f6nig", "email": "tkoenig@gcc.gnu.org", "date": "2020-04-23T18:30:01Z"}, "message": "Fix PR 93956, wrong pointer when returned via function.\n\nThis one took a bit of detective work.  When array pointers point\nto components of derived types, we currently set the span field\nand then create an array temporary when we pass the array\npointer to a procedure as a non-pointer or non-target argument.\n(This is inefficient, but that's for another release).\n\nNow, the compiler detected this case when there was a direct assignment\nlike p => a%b, but not when p was returned either as a function result\nor via an argument.  This patch fixes that.\n\n2020-04-23  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/93956\n\t* expr.c (gfc_check_pointer_assign): Also set subref_array_pointer\n\twhen a function returns a pointer.\n\t* interface.c (gfc_set_subref_array_pointer_arg): New function.\n\t(gfc_procedure_use): Call it.\n\n2020-04-23  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/93956\n\t* gfortran.dg/pointer_assign_13.f90: New test.", "tree": {"sha": "4c1c6756bd17f5900f4ee9ff8d9386336cae1533", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4c1c6756bd17f5900f4ee9ff8d9386336cae1533"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/06eca1acafa27e19e82dc73927394a7a4d0bdbc5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06eca1acafa27e19e82dc73927394a7a4d0bdbc5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06eca1acafa27e19e82dc73927394a7a4d0bdbc5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06eca1acafa27e19e82dc73927394a7a4d0bdbc5/comments", "author": null, "committer": null, "parents": [{"sha": "dcf69ac5448fd6a16137cfe9fe6deadd0ec0243d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcf69ac5448fd6a16137cfe9fe6deadd0ec0243d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dcf69ac5448fd6a16137cfe9fe6deadd0ec0243d"}], "stats": {"total": 103, "additions": 100, "deletions": 3}, "files": [{"sha": "2274ce05e0359e6ef3b14e1da87de5bb5a404a5c", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06eca1acafa27e19e82dc73927394a7a4d0bdbc5/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06eca1acafa27e19e82dc73927394a7a4d0bdbc5/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=06eca1acafa27e19e82dc73927394a7a4d0bdbc5", "patch": "@@ -1,3 +1,11 @@\n+2020-04-23  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/93956\n+\t* expr.c (gfc_check_pointer_assign): Also set subref_array_pointer\n+\twhen a function returns a pointer.\n+\t* interface.c (gfc_set_subref_array_pointer_arg): New function.\n+\t(gfc_procedure_use): Call it.\n+\n 2020-04-22  Fritz Reese  <foreese@gcc.gnu.org>\n \n \t* trigd_fe.inc: Use mpfr to compute cosd(30) rather than a host-"}, {"sha": "618c98a592ddbce7354ddd85e3289e636ad98332", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06eca1acafa27e19e82dc73927394a7a4d0bdbc5/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06eca1acafa27e19e82dc73927394a7a4d0bdbc5/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=06eca1acafa27e19e82dc73927394a7a4d0bdbc5", "patch": "@@ -4242,8 +4242,11 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue,\n   if (rvalue->expr_type == EXPR_NULL)\n     return true;\n \n-  if (rvalue->expr_type == EXPR_VARIABLE && is_subref_array (rvalue))\n-    lvalue->symtree->n.sym->attr.subref_array_pointer = 1;\n+  /* A function may also return subref arrray pointer.  */\n+\n+  if ((rvalue->expr_type == EXPR_VARIABLE && is_subref_array (rvalue))\n+      || rvalue->expr_type == EXPR_FUNCTION)\n+      lvalue->symtree->n.sym->attr.subref_array_pointer = 1;\n \n   attr = gfc_expr_attr (rvalue);\n "}, {"sha": "58b7abf31e9119d2783eea57ddaba5cebc476a2a", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06eca1acafa27e19e82dc73927394a7a4d0bdbc5/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06eca1acafa27e19e82dc73927394a7a4d0bdbc5/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=06eca1acafa27e19e82dc73927394a7a4d0bdbc5", "patch": "@@ -3788,6 +3788,36 @@ check_intents (gfc_formal_arglist *f, gfc_actual_arglist *a)\n   return true;\n }\n \n+/* Go through the argument list of a procedure and look for\n+   pointers which may be set, possibly introducing a span.  */\n+\n+static void\n+gfc_set_subref_array_pointer_arg (gfc_formal_arglist *dummy_args,\n+\t\t\t\t  gfc_actual_arglist *actual_args)\n+{\n+  gfc_formal_arglist *f;\n+  gfc_actual_arglist *a;\n+  gfc_symbol *a_sym;\n+  for (f = dummy_args, a = actual_args; f && a ; f = f->next, a = a->next)\n+    {\n+\n+      if (f->sym == NULL)\n+\tcontinue;\n+\n+      if (!f->sym->attr.pointer || f->sym->attr.intent == INTENT_IN)\n+\tcontinue;\n+\n+      if (a->expr == NULL || a->expr->expr_type != EXPR_VARIABLE)\n+\tcontinue;\n+      a_sym = a->expr->symtree->n.sym;\n+\n+      if (!a_sym->attr.pointer)\n+\tcontinue;\n+\n+      a_sym->attr.subref_array_pointer = 1;\n+    }\n+  return;\n+}\n \n /* Check how a procedure is used against its interface.  If all goes\n    well, the actual argument list will also end up being properly\n@@ -3968,6 +3998,10 @@ gfc_procedure_use (gfc_symbol *sym, gfc_actual_arglist **ap, locus *where)\n   if (warn_aliasing)\n     check_some_aliasing (dummy_args, *ap);\n \n+  /* Set the subref_array_pointer_arg if needed.  */\n+  if (dummy_args)\n+    gfc_set_subref_array_pointer_arg (dummy_args, *ap);\n+\n   return true;\n }\n "}, {"sha": "25515c9aa3a90cfcf9491676dfaea284a348a8c9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06eca1acafa27e19e82dc73927394a7a4d0bdbc5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06eca1acafa27e19e82dc73927394a7a4d0bdbc5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=06eca1acafa27e19e82dc73927394a7a4d0bdbc5", "patch": "@@ -1,4 +1,9 @@\n-2020-04-23 Iain Sandoe <iain@sandoe.co.uk>\n+2020-04-23  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/93956\n+\t* gfortran.dg/pointer_assign_13.f90: New test.\n+\n+\t2020-04-23 Iain Sandoe <iain@sandoe.co.uk>\n \n \t* g++.dg/coroutines/coro-bad-alloc-00-bad-op-new.C: Adjust for\n \tchanged inline namespace."}, {"sha": "b3f2cd9dab7af0dbb2f97991030dca14d9cfa48e", "filename": "gcc/testsuite/gfortran.dg/pointer_assign_13.f90", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06eca1acafa27e19e82dc73927394a7a4d0bdbc5/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_assign_13.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06eca1acafa27e19e82dc73927394a7a4d0bdbc5/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_assign_13.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_assign_13.f90?ref=06eca1acafa27e19e82dc73927394a7a4d0bdbc5", "patch": "@@ -0,0 +1,47 @@\n+! { dg-do run }\n+! PR 93956 - span was set incorrectly, leading to wrong code.\n+! Original test case by \"martin\".\n+program array_temps\n+  implicit none\n+  \n+  type :: tt\n+     integer :: u = 1\n+     integer :: v = 2\n+  end type tt\n+\n+  type(tt), dimension(:), pointer :: r\n+  integer :: n\n+  integer, dimension(:), pointer :: p, q, u\n+\n+  n = 10\n+  allocate(r(1:n))\n+  call foo(r%v,n)\n+  p => get(r(:))\n+  call foo(p, n)\n+  call get2(r,u)\n+  call foo(u,n)\n+  q => r%v\n+  call foo(q, n)\n+\n+deallocate(r)\n+\n+contains\n+\n+   subroutine foo(a, n)\n+      integer, dimension(:), intent(in) :: a\n+      integer, intent(in) :: n\n+      if (sum(a(1:n)) /= 2*n) stop 1\n+   end subroutine foo\n+\n+   function get(x) result(q)\n+      type(tt), dimension(:), target, intent(in) :: x\n+      integer, dimension(:), pointer :: q\n+      q => x(:)%v\n+   end function get\n+\n+   subroutine get2(x,q)\n+      type(tt), dimension(:), target, intent(in) :: x\n+      integer, dimension(:), pointer, intent(out) :: q\n+      q => x(:)%v\n+    end subroutine get2\n+end program array_temps"}]}