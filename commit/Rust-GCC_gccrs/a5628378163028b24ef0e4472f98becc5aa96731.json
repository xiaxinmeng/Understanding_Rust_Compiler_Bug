{"sha": "a5628378163028b24ef0e4472f98becc5aa96731", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTU2MjgzNzgxNjMwMjhiMjRlZjBlNDQ3MmY5OGJlY2M1YWE5NjczMQ==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2012-02-25T12:09:41Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2012-02-25T12:09:41Z"}, "message": "re PR debug/52001 (Huge compile-time regression with var-tracking)\n\nPR debug/52001\n* alias.c (refs_newer_value_cb, refs_newer_value_p): New.\n(get_addr): Walk canonical value's locs.  Avoid returning VALUEs\nand locs that reference values newer than the non-canonical value\nat hand.  Return the canonical value as a worst case.\n(memrefs_conflict_p): Walk canonical value's locs.\n\nFrom-SVN: r184572", "tree": {"sha": "7bde4a2ac693ba3d3312bb5937c7160118e45921", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7bde4a2ac693ba3d3312bb5937c7160118e45921"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a5628378163028b24ef0e4472f98becc5aa96731", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5628378163028b24ef0e4472f98becc5aa96731", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5628378163028b24ef0e4472f98becc5aa96731", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5628378163028b24ef0e4472f98becc5aa96731/comments", "author": null, "committer": null, "parents": [{"sha": "0e22465644731d86e2d317bf5fbfab2a76eccc9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e22465644731d86e2d317bf5fbfab2a76eccc9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e22465644731d86e2d317bf5fbfab2a76eccc9c"}], "stats": {"total": 48, "additions": 43, "deletions": 5}, "files": [{"sha": "5dfe71f3c2f4991b8f2f76501ef8e625d336e07f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5628378163028b24ef0e4472f98becc5aa96731/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5628378163028b24ef0e4472f98becc5aa96731/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a5628378163028b24ef0e4472f98becc5aa96731", "patch": "@@ -1,5 +1,12 @@\n 2012-02-25  Alexandre Oliva  <aoliva@redhat.com>\n \n+\tPR debug/52001\n+\t* alias.c (refs_newer_value_cb, refs_newer_value_p): New.\n+\t(get_addr): Walk canonical value's locs.  Avoid returning VALUEs\n+\tand locs that reference values newer than the non-canonical value\n+\tat hand.  Return the canonical value as a worst case.\n+\t(memrefs_conflict_p): Walk canonical value's locs.\n+\n \tPR debug/52001\n \t* cselib.c (preserve_only_constants): Rename to...\n \t(preserve_constants_and_equivs): ... this.  Split out..."}, {"sha": "4bda40d8836dae52a1e2ecfdf61290c67360aab4", "filename": "gcc/alias.c", "status": "modified", "additions": 36, "deletions": 5, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5628378163028b24ef0e4472f98becc5aa96731/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5628378163028b24ef0e4472f98becc5aa96731/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=a5628378163028b24ef0e4472f98becc5aa96731", "patch": "@@ -1773,6 +1773,29 @@ base_alias_check (rtx x, rtx y, enum machine_mode x_mode,\n   return 1;\n }\n \n+/* Callback for for_each_rtx, that returns 1 upon encountering a VALUE\n+   whose UID is greater than the int uid that D points to.  */\n+\n+static int\n+refs_newer_value_cb (rtx *x, void *d)\n+{\n+  if (GET_CODE (*x) == VALUE && CSELIB_VAL_PTR (*x)->uid > *(int *)d)\n+    return 1;\n+\n+  return 0;\n+}\n+\n+/* Return TRUE if EXPR refers to a VALUE whose uid is greater than\n+   that of V.  */\n+\n+static bool\n+refs_newer_value_p (rtx expr, rtx v)\n+{\n+  int minuid = CSELIB_VAL_PTR (v)->uid;\n+\n+  return for_each_rtx (&expr, refs_newer_value_cb, &minuid);\n+}\n+\n /* Convert the address X into something we can use.  This is done by returning\n    it unchanged unless it is a value; in the latter case we call cselib to get\n    a more useful rtx.  */\n@@ -1788,14 +1811,20 @@ get_addr (rtx x)\n   v = CSELIB_VAL_PTR (x);\n   if (v)\n     {\n+      v = canonical_cselib_val (v);\n       for (l = v->locs; l; l = l->next)\n \tif (CONSTANT_P (l->loc))\n \t  return l->loc;\n       for (l = v->locs; l; l = l->next)\n-\tif (!REG_P (l->loc) && !MEM_P (l->loc))\n+\tif (!REG_P (l->loc) && !MEM_P (l->loc) && GET_CODE (l->loc) != VALUE\n+\t    && !refs_newer_value_p (l->loc, x))\n+\t  return l->loc;\n+      for (l = v->locs; l; l = l->next)\n+\tif (REG_P (l->loc) || (GET_CODE (l->loc) != VALUE\n+\t\t\t       && !refs_newer_value_p (l->loc, x)))\n \t  return l->loc;\n-      if (v->locs)\n-\treturn v->locs->loc;\n+      /* Return the canonical value.  */\n+      return v->val_rtx;\n     }\n   return x;\n }\n@@ -1873,7 +1902,8 @@ memrefs_conflict_p (int xsize, rtx x, int ysize, rtx y, HOST_WIDE_INT c)\n \t{\n \t  struct elt_loc_list *l = NULL;\n \t  if (CSELIB_VAL_PTR (x))\n-\t    for (l = CSELIB_VAL_PTR (x)->locs; l; l = l->next)\n+\t    for (l = canonical_cselib_val (CSELIB_VAL_PTR (x))->locs;\n+\t\t l; l = l->next)\n \t      if (REG_P (l->loc) && rtx_equal_for_memref_p (l->loc, y))\n \t\tbreak;\n \t  if (l)\n@@ -1891,7 +1921,8 @@ memrefs_conflict_p (int xsize, rtx x, int ysize, rtx y, HOST_WIDE_INT c)\n \t{\n \t  struct elt_loc_list *l = NULL;\n \t  if (CSELIB_VAL_PTR (y))\n-\t    for (l = CSELIB_VAL_PTR (y)->locs; l; l = l->next)\n+\t    for (l = canonical_cselib_val (CSELIB_VAL_PTR (y))->locs;\n+\t\t l; l = l->next)\n \t      if (REG_P (l->loc) && rtx_equal_for_memref_p (l->loc, x))\n \t\tbreak;\n \t  if (l)"}]}