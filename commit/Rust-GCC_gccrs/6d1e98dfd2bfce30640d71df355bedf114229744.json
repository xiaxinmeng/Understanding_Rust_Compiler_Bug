{"sha": "6d1e98dfd2bfce30640d71df355bedf114229744", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmQxZTk4ZGZkMmJmY2UzMDY0MGQ3MWRmMzU1YmVkZjExNDIyOTc0NA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-09-30T16:39:38Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-09-30T16:39:38Z"}, "message": "Make ira call df_set_regs_ever_live for extra call-clobbered regs\n\nIf we support multiple ABIs in the same translation unit, it can\nsometimes be the case that a callee clobbers more registers than\nits caller is allowed to.  We need to call df_set_regs_ever_live\non these extra registers so that the prologue and epilogue code\ncan handle them appropriately.\n\nThis patch does that in IRA.  I wanted to avoid another full\ninstruction walk just for this, so I combined it with the existing\nset_paradoxical_subreg walk.  This happens before the first\ncalculation of elimination offsets.\n\n2019-09-30  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* function-abi.h (function_abi_aggregator): New class.\n\t* function-abi.cc (function_abi_aggregator::caller_save_regs): New\n\tfunction.\n\t* ira.c (update_equiv_regs_prescan): New function.  Call\n\tset_paradoxical_subreg here rather than...\n\t(update_equiv_regs): ...here.\n\t(ira): Call update_equiv_regs_prescan.\n\nFrom-SVN: r276339", "tree": {"sha": "4fd650f51b146fd95f2345a09063f202a8768f53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4fd650f51b146fd95f2345a09063f202a8768f53"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d1e98dfd2bfce30640d71df355bedf114229744", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d1e98dfd2bfce30640d71df355bedf114229744", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d1e98dfd2bfce30640d71df355bedf114229744", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d1e98dfd2bfce30640d71df355bedf114229744/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7c3958812bd5e2e139c7f0adf8f03b505fda67f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c3958812bd5e2e139c7f0adf8f03b505fda67f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c3958812bd5e2e139c7f0adf8f03b505fda67f2"}], "stats": {"total": 108, "additions": 99, "deletions": 9}, "files": [{"sha": "28e411c9efe43e3826b6e879918c34f25b816c3e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d1e98dfd2bfce30640d71df355bedf114229744/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d1e98dfd2bfce30640d71df355bedf114229744/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6d1e98dfd2bfce30640d71df355bedf114229744", "patch": "@@ -1,3 +1,13 @@\n+2019-09-30  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* function-abi.h (function_abi_aggregator): New class.\n+\t* function-abi.cc (function_abi_aggregator::caller_save_regs): New\n+\tfunction.\n+\t* ira.c (update_equiv_regs_prescan): New function.  Call\n+\tset_paradoxical_subreg here rather than...\n+\t(update_equiv_regs): ...here.\n+\t(ira): Call update_equiv_regs_prescan.\n+\n 2019-09-30  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* hard-reg-set.h (regs_invalidated_by_call): Only define if"}, {"sha": "eee789a29e8e1581d365508c2a8afc8f30024729", "filename": "gcc/function-abi.cc", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d1e98dfd2bfce30640d71df355bedf114229744/gcc%2Ffunction-abi.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d1e98dfd2bfce30640d71df355bedf114229744/gcc%2Ffunction-abi.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction-abi.cc?ref=6d1e98dfd2bfce30640d71df355bedf114229744", "patch": "@@ -126,6 +126,42 @@ predefined_function_abi::add_full_reg_clobber (unsigned int regno)\n     SET_HARD_REG_BIT (m_mode_clobbers[i], regno);\n }\n \n+/* Return the set of registers that the caller of the recorded functions must\n+   save in order to honor the requirements of CALLER_ABI.  */\n+\n+HARD_REG_SET\n+function_abi_aggregator::\n+caller_save_regs (const function_abi &caller_abi) const\n+{\n+  HARD_REG_SET result;\n+  CLEAR_HARD_REG_SET (result);\n+  for (unsigned int abi_id = 0; abi_id < NUM_ABI_IDS; ++abi_id)\n+    {\n+      const predefined_function_abi &callee_abi = function_abis[abi_id];\n+\n+      /* Skip cases that clearly aren't problematic.  */\n+      if (abi_id == caller_abi.id ()\n+\t  || hard_reg_set_empty_p (m_abi_clobbers[abi_id]))\n+\tcontinue;\n+\n+      /* Collect the set of registers that can be \"more clobbered\" by\n+\t CALLEE_ABI than by CALLER_ABI.  */\n+      HARD_REG_SET extra_clobbers;\n+      CLEAR_HARD_REG_SET (extra_clobbers);\n+      for (unsigned int i = 0; i < NUM_MACHINE_MODES; ++i)\n+\t{\n+\t  machine_mode mode = (machine_mode) i;\n+\t  extra_clobbers |= (callee_abi.mode_clobbers (mode)\n+\t\t\t     & ~caller_abi.mode_clobbers (mode));\n+\t}\n+\n+      /* Restrict it to the set of registers that we actually saw\n+\t clobbers for (e.g. taking -fipa-ra into account).  */\n+      result |= (extra_clobbers & m_abi_clobbers[abi_id]);\n+    }\n+  return result;\n+}\n+\n /* Return the set of registers that cannot be used to hold a value of\n    mode MODE across the calls in a region described by ABIS and MASK, where:\n "}, {"sha": "9bb4d1768b397e6085c995ed4cf2f3ddd3fb358b", "filename": "gcc/function-abi.h", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d1e98dfd2bfce30640d71df355bedf114229744/gcc%2Ffunction-abi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d1e98dfd2bfce30640d71df355bedf114229744/gcc%2Ffunction-abi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction-abi.h?ref=6d1e98dfd2bfce30640d71df355bedf114229744", "patch": "@@ -208,6 +208,27 @@ class function_abi\n   HARD_REG_SET m_mask;\n };\n \n+/* This class collects information about the ABIs of functions that are\n+   called in a particular region of code.  It is mostly intended to be\n+   used as a local variable during an IR walk.  */\n+class function_abi_aggregator\n+{\n+public:\n+  function_abi_aggregator () : m_abi_clobbers () {}\n+\n+  /* Record that the code region calls a function with the given ABI.  */\n+  void\n+  note_callee_abi (const function_abi &abi)\n+  {\n+    m_abi_clobbers[abi.id ()] |= abi.full_and_partial_reg_clobbers ();\n+  }\n+\n+  HARD_REG_SET caller_save_regs (const function_abi &) const;\n+\n+private:\n+  HARD_REG_SET m_abi_clobbers[NUM_ABI_IDS];\n+};\n+\n struct target_function_abi_info\n {\n   /* An array of all the target ABIs that are available in this"}, {"sha": "3b4f9a87c551aacdfab4535ce16dcc4f45cb4e8e", "filename": "gcc/ira.c", "status": "modified", "additions": 32, "deletions": 9, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d1e98dfd2bfce30640d71df355bedf114229744/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d1e98dfd2bfce30640d71df355bedf114229744/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=6d1e98dfd2bfce30640d71df355bedf114229744", "patch": "@@ -3362,6 +3362,37 @@ def_dominates_uses (int regno)\n   return true;\n }\n \n+/* Scan the instructions before update_equiv_regs.  Record which registers\n+   are referenced as paradoxical subregs.  Also check for cases in which\n+   the current function needs to save a register that one of its call\n+   instructions clobbers.\n+\n+   These things are logically unrelated, but it's more efficient to do\n+   them together.  */\n+\n+static void\n+update_equiv_regs_prescan (void)\n+{\n+  basic_block bb;\n+  rtx_insn *insn;\n+  function_abi_aggregator callee_abis;\n+\n+  FOR_EACH_BB_FN (bb, cfun)\n+    FOR_BB_INSNS (bb, insn)\n+      if (NONDEBUG_INSN_P (insn))\n+\t{\n+\t  set_paradoxical_subreg (insn);\n+\t  if (CALL_P (insn))\n+\t    callee_abis.note_callee_abi (insn_callee_abi (insn));\n+\t}\n+\n+  HARD_REG_SET extra_caller_saves = callee_abis.caller_save_regs (*crtl->abi);\n+  if (!hard_reg_set_empty_p (extra_caller_saves))\n+    for (unsigned int regno = 0; regno < FIRST_PSEUDO_REGISTER; ++regno)\n+      if (TEST_HARD_REG_BIT (extra_caller_saves, regno))\n+\tdf_set_regs_ever_live (regno, true);\n+}\n+\n /* Find registers that are equivalent to a single value throughout the\n    compilation (either because they can be referenced in memory or are\n    set once from a single constant).  Lower their priority for a\n@@ -3378,15 +3409,6 @@ update_equiv_regs (void)\n   rtx_insn *insn;\n   basic_block bb;\n \n-  /* Scan insns and set pdx_subregs if the reg is used in a\n-     paradoxical subreg.  Don't set such reg equivalent to a mem,\n-     because lra will not substitute such equiv memory in order to\n-     prevent access beyond allocated memory for paradoxical memory subreg.  */\n-  FOR_EACH_BB_FN (bb, cfun)\n-    FOR_BB_INSNS (bb, insn)\n-      if (NONDEBUG_INSN_P (insn))\n-\tset_paradoxical_subreg (insn);\n-\n   /* Scan the insns and find which registers have equivalences.  Do this\n      in a separate scan of the insns because (due to -fcse-follow-jumps)\n      a register can be set below its use.  */\n@@ -5276,6 +5298,7 @@ ira (FILE *f)\n   init_alias_analysis ();\n   loop_optimizer_init (AVOID_CFG_MODIFICATIONS);\n   reg_equiv = XCNEWVEC (struct equivalence, max_reg_num ());\n+  update_equiv_regs_prescan ();\n   update_equiv_regs ();\n \n   /* Don't move insns if live range shrinkage or register"}]}