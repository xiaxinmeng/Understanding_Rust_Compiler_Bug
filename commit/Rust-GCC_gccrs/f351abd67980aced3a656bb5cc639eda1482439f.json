{"sha": "f351abd67980aced3a656bb5cc639eda1482439f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjM1MWFiZDY3OTgwYWNlZDNhNjU2YmI1Y2M2MzllZGExNDgyNDM5Zg==", "commit": {"author": {"name": "Thomas Preud'homme", "email": "thomas.preudhomme@arm.com", "date": "2014-11-12T09:50:20Z"}, "committer": {"name": "Thomas Preud'homme", "email": "thopre01@gcc.gnu.org", "date": "2014-11-12T09:50:20Z"}, "message": "[multiple changes]\n\n2014-11-12  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n\n    gcc/\n    PR tree-optimization/63761\n    * tree-ssa-math-opts.c (bswap_replace): Construct gsi from cur_stmt\n    rather than taking it as a parameter. Add some comments to explain the\n    gsi_move_before in case of load and why canonicalization of bswap into\n    a rotation is only done for 16bit values.\n    (pass_optimize_bswap::execute): Adapt for loop via gsi to make gsi\n    refer to the statement just before cur_stmt. Ignore 16bit bswap that\n    are already in canonical form. Adapt bswap_replace to removal of its\n    gsi parameter.\n\n    2014-11-12  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n\n    gcc/testsuite/\n    PR tree-optimization/63761\n    * gcc.c-torture/compile/pr63761.c: New test.\n\nFrom-SVN: r217409", "tree": {"sha": "9be0a8ea34db66b2d907cf7b363d3e981fa99a70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9be0a8ea34db66b2d907cf7b363d3e981fa99a70"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f351abd67980aced3a656bb5cc639eda1482439f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f351abd67980aced3a656bb5cc639eda1482439f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f351abd67980aced3a656bb5cc639eda1482439f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f351abd67980aced3a656bb5cc639eda1482439f/comments", "author": {"login": "RoboTux", "id": 272327, "node_id": "MDQ6VXNlcjI3MjMyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/272327?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RoboTux", "html_url": "https://github.com/RoboTux", "followers_url": "https://api.github.com/users/RoboTux/followers", "following_url": "https://api.github.com/users/RoboTux/following{/other_user}", "gists_url": "https://api.github.com/users/RoboTux/gists{/gist_id}", "starred_url": "https://api.github.com/users/RoboTux/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RoboTux/subscriptions", "organizations_url": "https://api.github.com/users/RoboTux/orgs", "repos_url": "https://api.github.com/users/RoboTux/repos", "events_url": "https://api.github.com/users/RoboTux/events{/privacy}", "received_events_url": "https://api.github.com/users/RoboTux/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d30fc980ac0178eb8a64277c063d518cb691f1d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d30fc980ac0178eb8a64277c063d518cb691f1d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d30fc980ac0178eb8a64277c063d518cb691f1d2"}], "stats": {"total": 92, "additions": 74, "deletions": 18}, "files": [{"sha": "d6c7d383db68a9f2a0ea3913e11ffecb181b52e3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f351abd67980aced3a656bb5cc639eda1482439f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f351abd67980aced3a656bb5cc639eda1482439f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f351abd67980aced3a656bb5cc639eda1482439f", "patch": "@@ -1,3 +1,15 @@\n+2014-11-12  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n+\n+\tPR tree-optimization/63761\n+\t* tree-ssa-math-opts.c (bswap_replace): Construct gsi from cur_stmt\n+\trather than taking it as a parameter. Add some comments to explain the\n+\tgsi_move_before in case of load and why canonicalization of bswap into\n+\ta rotation is only done for 16bit values.\n+\t(pass_optimize_bswap::execute): Adapt for loop via gsi to make gsi\n+\trefer to the statement just before cur_stmt. Ignore 16bit bswap that\n+\tare already in canonical form. Adapt bswap_replace to removal of its\n+\tgsi parameter.\n+\n 2014-11-12  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* rtl.h (rtx_function, for_each_rtx, for_each_rtx_in_insn): Delete."}, {"sha": "10c4e6f9fafa193f8f1f23db66539070f2d92698", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f351abd67980aced3a656bb5cc639eda1482439f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f351abd67980aced3a656bb5cc639eda1482439f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f351abd67980aced3a656bb5cc639eda1482439f", "patch": "@@ -1,3 +1,8 @@\n+2014-11-12  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n+\n+\tPR tree-optimization/63761\n+\t* gcc.c-torture/compile/pr63761.c: New test.\n+\n 2014-11-12  Jiong Wang  <jiong.wang@arm.com>\n \n \t* lib/gcc-dg.exp (${tool}_load): Truncate gcc output."}, {"sha": "5cda3f1bd8bab928ac9e4a320ab4c344442f0127", "filename": "gcc/testsuite/gcc.c-torture/compile/pr63761.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f351abd67980aced3a656bb5cc639eda1482439f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr63761.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f351abd67980aced3a656bb5cc639eda1482439f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr63761.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr63761.c?ref=f351abd67980aced3a656bb5cc639eda1482439f", "patch": "@@ -0,0 +1,17 @@\n+int a, b;\n+short c;\n+\n+void fn1 ();\n+\n+void\n+fn2 (unsigned short p1)\n+{\n+  int d;\n+\n+  c = p1 >> 8 | p1 << 8;\n+  d = b;\n+  if (d)\n+    fn1 ();\n+  a = d >> 8 & 0x00FF\n+    | d << 8 & 0xFF00;\n+}"}, {"sha": "aab056c338e00aa0c0c9846fd5a24ee6639acf12", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 40, "deletions": 18, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f351abd67980aced3a656bb5cc639eda1482439f/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f351abd67980aced3a656bb5cc639eda1482439f/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=f351abd67980aced3a656bb5cc639eda1482439f", "patch": "@@ -2172,23 +2172,28 @@ class pass_optimize_bswap : public gimple_opt_pass\n \n }; // class pass_optimize_bswap\n \n-/* Perform the bswap optimization: replace the statement CUR_STMT at\n-   GSI with a load of type, VUSE and set-alias as described by N if a\n-   memory source is involved (N->base_addr is non null), followed by\n-   the builtin bswap invocation in FNDECL if BSWAP is true.  SRC_STMT\n-   gives where should the replacement be made.  It also gives the\n-   source on which CUR_STMT is operating via its rhs's first tree nad\n-   N->range gives the size of the expression involved for maintaining\n-   some statistics.  */\n+/* Perform the bswap optimization: replace the expression computed in the rhs\n+   of CUR_STMT by an equivalent bswap, load or load + bswap expression.\n+   Which of these alternatives replace the rhs is given by N->base_addr (non\n+   null if a load is needed) and BSWAP.  The type, VUSE and set-alias of the\n+   load to perform are also given in N while the builtin bswap invoke is given\n+   in FNDEL.  Finally, if a load is involved, SRC_STMT refers to one of the\n+   load statements involved to construct the rhs in CUR_STMT and N->range gives\n+   the size of the rhs expression for maintaining some statistics.\n+\n+   Note that if the replacement involve a load, CUR_STMT is moved just after\n+   SRC_STMT to do the load with the same VUSE which can lead to CUR_STMT\n+   changing of basic block.  */\n \n static bool\n-bswap_replace (gimple cur_stmt, gimple_stmt_iterator gsi, gimple src_stmt,\n-\t       tree fndecl, tree bswap_type, tree load_type,\n-\t       struct symbolic_number *n, bool bswap)\n+bswap_replace (gimple cur_stmt, gimple src_stmt, tree fndecl, tree bswap_type,\n+\t       tree load_type, struct symbolic_number *n, bool bswap)\n {\n+  gimple_stmt_iterator gsi;\n   tree src, tmp, tgt;\n   gimple bswap_stmt;\n \n+  gsi = gsi_for_stmt (cur_stmt);\n   src = gimple_assign_rhs1 (src_stmt);\n   tgt = gimple_assign_lhs (cur_stmt);\n \n@@ -2207,6 +2212,9 @@ bswap_replace (gimple cur_stmt, gimple_stmt_iterator gsi, gimple src_stmt,\n \t  && SLOW_UNALIGNED_ACCESS (TYPE_MODE (load_type), align))\n \treturn false;\n \n+      /* Move cur_stmt just before  one of the load of the original\n+\t to ensure it has the same VUSE.  See PR61517 for what could\n+\t go wrong.  */\n       gsi_move_before (&gsi, &gsi_ins);\n       gsi = gsi_for_stmt (cur_stmt);\n \n@@ -2293,7 +2301,10 @@ bswap_replace (gimple cur_stmt, gimple_stmt_iterator gsi, gimple src_stmt,\n \n   tmp = src;\n \n-  /* Canonical form for 16 bit bswap is a rotate expression.  */\n+  /* Canonical form for 16 bit bswap is a rotate expression.  Only 16bit values\n+     are considered as rotation of 2N bit values by N bits is generally not\n+     equivalent to a bswap.  Consider for instance 0x01020304 >> 16 which gives\n+     0x03040102 while a bswap for that value is 0x04030201.  */\n   if (bswap && n->range == 16)\n     {\n       tree count = build_int_cst (NULL, BITS_PER_UNIT);\n@@ -2393,17 +2404,25 @@ pass_optimize_bswap::execute (function *fun)\n       gimple_stmt_iterator gsi;\n \n       /* We do a reverse scan for bswap patterns to make sure we get the\n-\t widest match. As bswap pattern matching doesn't handle\n-\t previously inserted smaller bswap replacements as sub-\n-\t patterns, the wider variant wouldn't be detected.  */\n-      for (gsi = gsi_last_bb (bb); !gsi_end_p (gsi); gsi_prev (&gsi))\n+\t widest match. As bswap pattern matching doesn't handle previously\n+\t inserted smaller bswap replacements as sub-patterns, the wider\n+\t variant wouldn't be detected.  */\n+      for (gsi = gsi_last_bb (bb); !gsi_end_p (gsi);)\n         {\n \t  gimple src_stmt, cur_stmt = gsi_stmt (gsi);\n \t  tree fndecl = NULL_TREE, bswap_type = NULL_TREE, load_type;\n \t  enum tree_code code;\n \t  struct symbolic_number n;\n \t  bool bswap;\n \n+\t  /* This gsi_prev (&gsi) is not part of the for loop because cur_stmt\n+\t     might be moved to a different basic block by bswap_replace and gsi\n+\t     must not points to it if that's the case.  Moving the gsi_prev\n+\t     there make sure that gsi points to the statement previous to\n+\t     cur_stmt while still making sure that all statements are\n+\t     considered in this basic block.  */\n+\t  gsi_prev (&gsi);\n+\n \t  if (!is_gimple_assign (cur_stmt))\n \t    continue;\n \n@@ -2431,6 +2450,9 @@ pass_optimize_bswap::execute (function *fun)\n \t  switch (n.range)\n \t    {\n \t    case 16:\n+\t      /* Already in canonical form, nothing to do.  */\n+\t      if (code == LROTATE_EXPR || code == RROTATE_EXPR)\n+\t\tcontinue;\n \t      load_type = uint16_type_node;\n \t      if (bswap16_p)\n \t\t{\n@@ -2461,8 +2483,8 @@ pass_optimize_bswap::execute (function *fun)\n \t  if (bswap && !fndecl)\n \t    continue;\n \n-\t  if (bswap_replace (cur_stmt, gsi, src_stmt, fndecl, bswap_type,\n-\t\t\t     load_type, &n, bswap))\n+\t  if (bswap_replace (cur_stmt, src_stmt, fndecl, bswap_type, load_type,\n+\t\t\t     &n, bswap))\n \t    changed = true;\n \t}\n     }"}]}