{"sha": "981234802e8314987fc1e9c6b9594462bb5aa0f4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTgxMjM0ODAyZTgzMTQ5ODdmYzFlOWM2Yjk1OTQ0NjJiYjVhYTBmNA==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2005-03-29T16:20:30Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-03-29T16:20:30Z"}, "message": "sem_ch4.adb (Analyze_Selected_Component): Do not generate an actual subtype if code is being pre-analyzed...\n\n2005-03-29  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch4.adb (Analyze_Selected_Component): Do not generate an actual\n\tsubtype if code is being pre-analyzed, to prevent un-expanded\n\treferences to protected formals, among others.\n\t(Analyze_Explicit_Dereference): If the overloaded prefix includes some\n\tinterpretation that can be a call, include the result of the call as a\n\tpossible interpretation of the dereference.\n\n\t* sem_ch5.adb (Process_Bounds): Determine type of range by\n\tpre-analyzing a copy of the original range, and then analyze the range\n\twith the expected type.\n\n\t* sem_res.adb (Check_Parameterless_Call): For an explicit dereference\n\twith an overloaded prefix where not all interpretations yield an\n\taccess to subprogram, do not rewrite node as a call.\n\t(Resolve_Explicit_Dereference): Recognize the previous case and rewrite\n\tthe node as a call once the context identifies the interpretation of\n\tthe prefix whose call yields the context type.\n\t(Valid_Conversion): For the case of a conversion between\n\tlocal access-to-subprogram types, check subtype conformance using\n\tCheck_Subtype_Conformant instead of Subtype_Conformant, to have a more\n\tdetailed error message.\n\nFrom-SVN: r97184", "tree": {"sha": "395b2798e3377b361bd8d161e38756dabc97f3d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/395b2798e3377b361bd8d161e38756dabc97f3d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/981234802e8314987fc1e9c6b9594462bb5aa0f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/981234802e8314987fc1e9c6b9594462bb5aa0f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/981234802e8314987fc1e9c6b9594462bb5aa0f4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/981234802e8314987fc1e9c6b9594462bb5aa0f4/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f7a8593d14ff6d549cacca879601a9129d5691e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7a8593d14ff6d549cacca879601a9129d5691e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7a8593d14ff6d549cacca879601a9129d5691e0"}], "stats": {"total": 130, "additions": 89, "deletions": 41}, "files": [{"sha": "88035b8a1f436860b60d08fde1e4d84caba1cc82", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 55, "deletions": 26, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/981234802e8314987fc1e9c6b9594462bb5aa0f4/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/981234802e8314987fc1e9c6b9594462bb5aa0f4/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=981234802e8314987fc1e9c6b9594462bb5aa0f4", "patch": "@@ -1197,7 +1197,7 @@ package body Sem_Ch4 is\n          end if;\n       end Is_Function_Type;\n \n-   --  Start of processing for Analyze_Explicit_Deference\n+   --  Start of processing for Analyze_Explicit_Dereference\n \n    begin\n       Analyze (P);\n@@ -1251,8 +1251,6 @@ package body Sem_Ch4 is\n             Get_Next_Interp (I, It);\n          end loop;\n \n-         End_Interp_List;\n-\n          --  Error if no interpretation of the prefix has an access type\n \n          if Etype (N) = Any_Type then\n@@ -1281,10 +1279,11 @@ package body Sem_Ch4 is\n       then\n          --  Name is a function call with no actuals, in a context that\n          --  requires deproceduring (including as an actual in an enclosing\n-         --  function or procedure call). We can conceive of pathological cases\n+         --  function or procedure call). There are some pathological cases\n          --  where the prefix might include functions that return access to\n          --  subprograms and others that return a regular type. Disambiguation\n-         --  of those will have to take place in Resolve. See e.g. 7117-014.\n+         --  of those has to take place in Resolve.\n+         --  See e.g. 7117-014 and E317-001.\n \n          New_N :=\n            Make_Function_Call (Loc,\n@@ -1311,6 +1310,25 @@ package body Sem_Ch4 is\n \n          Rewrite (N, New_N);\n          Analyze (N);\n+\n+      elsif not Is_Function_Type\n+        and then Is_Overloaded (N)\n+      then\n+         --  The prefix may include access to subprograms and other access\n+         --  types. If the context selects the interpretation that is a call,\n+         --  we cannot rewrite the node yet, but we include the result of\n+         --  the call interpretation.\n+\n+         Get_First_Interp (N, I, It);\n+         while Present (It.Nam) loop\n+            if Ekind (Base_Type (It.Typ)) = E_Subprogram_Type\n+               and then Etype (Base_Type (It.Typ)) /= Standard_Void_Type\n+            then\n+               Add_One_Interp (N, Etype (It.Typ), Etype (It.Typ));\n+            end if;\n+\n+            Get_Next_Interp (I, It);\n+         end loop;\n       end if;\n \n       --  A value of remote access-to-class-wide must not be dereferenced\n@@ -2652,14 +2670,20 @@ package body Sem_Ch4 is\n                then\n                   Set_Etype (N, Etype (Comp));\n \n-               --  In all other cases, we currently build an actual subtype. It\n-               --  seems likely that many of these cases can be avoided, but\n-               --  right now, the front end makes direct references to the\n+               --  If full analysis is not enabled, we do not generate an\n+               --  actual subtype, because in the absence of expansion\n+               --  reference to a formal of a protected type, for example,\n+               --  will not be properly transformed, and will lead to\n+               --  out-of-scope references in gigi.\n+\n+               --  In all other cases, we currently build an actual subtype.\n+               --  It seems likely that many of these cases can be avoided,\n+               --  but right now, the front end makes direct references to the\n                --  bounds (e.g. in generating a length check), and if we do\n                --  not make an actual subtype, we end up getting a direct\n-               --  reference to a discriminant which will not do.\n+               --  reference to a discriminant, which will not do.\n \n-               else\n+               elsif Full_Analysis then\n                   Act_Decl :=\n                     Build_Actual_Subtype_Of_Component (Etype (Comp), N);\n                   Insert_Action (N, Act_Decl);\n@@ -2681,6 +2705,11 @@ package body Sem_Ch4 is\n                         Set_Etype (N, Subt);\n                      end;\n                   end if;\n+\n+               --  If Full_Analysis not enabled, just set the Etype\n+\n+               else\n+                  Set_Etype (N, Etype (Comp));\n                end if;\n \n                return;\n@@ -2697,17 +2726,17 @@ package body Sem_Ch4 is\n          then\n             return;\n \n-            --  If the transformation fails, it will be necessary\n-            --  to redo the analysis with all errors enabled, to indicate\n-            --  candidate interpretations and reasons for each failure ???\n+            --  If the transformation fails, it will be necessary to redo the\n+            --  analysis with all errors enabled, to indicate candidate\n+            --  interpretations and reasons for each failure ???\n \n          end if;\n \n       elsif Is_Private_Type (Prefix_Type) then\n \n-         --  Allow access only to discriminants of the type. If the\n-         --  type has no full view, gigi uses the parent type for\n-         --  the components, so we do the same here.\n+         --  Allow access only to discriminants of the type. If the type has\n+         --  no full view, gigi uses the parent type for the components, so we\n+         --  do the same here.\n \n          if No (Full_View (Prefix_Type)) then\n             Entity_List := Root_Type (Base_Type (Prefix_Type));\n@@ -2747,11 +2776,11 @@ package body Sem_Ch4 is\n       elsif Is_Concurrent_Type (Prefix_Type) then\n \n          --  Prefix is concurrent type. Find visible operation with given name\n-         --  For a task, this can only include entries or discriminants if\n-         --  the task type is not an enclosing scope. If it is an enclosing\n-         --  scope (e.g. in an inner task) then all entities are visible, but\n-         --  the prefix must denote the enclosing scope, i.e. can only be\n-         --  a direct name or an expanded name.\n+         --  For a task, this can only include entries or discriminants if the\n+         --  task type is not an enclosing scope. If it is an enclosing scope\n+         --  (e.g. in an inner task) then all entities are visible, but the\n+         --  prefix must denote the enclosing scope, i.e. can only be a direct\n+         --  name or an expanded name.\n \n          Set_Etype (Sel,  Any_Type);\n          In_Scope := In_Open_Scopes (Prefix_Type);\n@@ -2780,8 +2809,8 @@ package body Sem_Ch4 is\n                   Set_Original_Discriminant (Sel, Comp);\n                end if;\n \n-               --  For access type case, introduce explicit deference for\n-               --  more uniform treatment of entry calls.\n+               --  For access type case, introduce explicit deference for more\n+               --  uniform treatment of entry calls.\n \n                if Is_Access_Type (Etype (Name)) then\n                   Insert_Explicit_Dereference (Name);\n@@ -2809,8 +2838,8 @@ package body Sem_Ch4 is\n \n       if Etype (N) = Any_Type then\n \n-         --  If the prefix is a single concurrent object, use its name in\n-         --  the error message, rather than that of its anonymous type.\n+         --  If the prefix is a single concurrent object, use its name in the\n+         --  error message, rather than that of its anonymous type.\n \n          if Is_Concurrent_Type (Prefix_Type)\n            and then Is_Internal_Name (Chars (Prefix_Type))\n@@ -2828,7 +2857,7 @@ package body Sem_Ch4 is\n            and then Prefix_Type /= Etype (Prefix_Type)\n            and then Is_Record_Type (Etype (Prefix_Type))\n          then\n-            --  If this is a derived formal type, the parent may have a\n+            --  If this is a derived formal type, the parent may have\n             --  different visibility at this point. Try for an inherited\n             --  component before reporting an error.\n "}, {"sha": "163365fc46a3f1577eef6c6a146d7bd547263f4c", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 34, "deletions": 15, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/981234802e8314987fc1e9c6b9594462bb5aa0f4/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/981234802e8314987fc1e9c6b9594462bb5aa0f4/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=981234802e8314987fc1e9c6b9594462bb5aa0f4", "patch": "@@ -1112,7 +1112,9 @@ package body Sem_Ch5 is\n       --  If the iteration is given by a range, create temporaries and\n       --  assignment statements block to capture the bounds and perform\n       --  required finalization actions in case a bound includes a function\n-      --  call that uses the temporary stack.\n+      --  call that uses the temporary stack. We first pre-analyze a copy of\n+      --  the range in order to determine the expected type, and analyze\n+      --  and resolve the original bounds.\n \n       procedure Check_Controlled_Array_Attribute (DS : Node_Id);\n       --  If the bounds are given by a 'Range reference on a function call\n@@ -1126,13 +1128,16 @@ package body Sem_Ch5 is\n \n       procedure Process_Bounds (R : Node_Id) is\n          Loc          : constant Source_Ptr := Sloc (N);\n+         R_Copy       : constant Node_Id := New_Copy_Tree (R);\n          Lo           : constant Node_Id := Low_Bound  (R);\n          Hi           : constant Node_Id := High_Bound (R);\n          New_Lo_Bound : Node_Id := Empty;\n          New_Hi_Bound : Node_Id := Empty;\n-         Typ          : constant Entity_Id := Etype (R);\n+         Typ          : Entity_Id;\n \n-         function One_Bound (Bound : Node_Id) return Node_Id;\n+         function One_Bound\n+           (Original_Bound : Node_Id;\n+            Analyzed_Bound : Node_Id) return Node_Id;\n          --  Create one declaration followed by one assignment statement\n          --  to capture the value of bound. We create a separate assignment\n          --  in order to force the creation of a block in case the bound\n@@ -1142,7 +1147,10 @@ package body Sem_Ch5 is\n          -- One_Bound --\n          ---------------\n \n-         function One_Bound (Bound : Node_Id) return Node_Id is\n+         function One_Bound\n+           (Original_Bound : Node_Id;\n+            Analyzed_Bound : Node_Id) return Node_Id\n+         is\n             Assign   : Node_Id;\n             Id       : Entity_Id;\n             Decl     : Node_Id;\n@@ -1156,11 +1164,17 @@ package body Sem_Ch5 is\n             --  part of the call to Make_Index (literal bounds may need to\n             --  be resolved to type Integer).\n \n-            if Nkind (Bound) = N_Integer_Literal\n-              or else Is_Entity_Name (Bound)\n-              or else Analyzed (Bound)\n+            if Analyzed (Original_Bound) then\n+               return Original_Bound;\n+\n+            elsif Nkind (Analyzed_Bound) = N_Integer_Literal\n+              or else Is_Entity_Name (Analyzed_Bound)\n             then\n-               return Bound;\n+               Analyze_And_Resolve (Original_Bound, Typ);\n+               return Original_Bound;\n+\n+            else\n+               Analyze_And_Resolve (Original_Bound, Typ);\n             end if;\n \n             Id :=\n@@ -1188,26 +1202,32 @@ package body Sem_Ch5 is\n             Assign :=\n               Make_Assignment_Statement (Loc,\n                 Name        => New_Occurrence_Of (Id, Loc),\n-                Expression  => Relocate_Node (Bound));\n+                Expression  => Relocate_Node (Original_Bound));\n \n-            Save_Interps (Bound, Expression (Assign));\n             Insert_Before (Parent (N), Assign);\n             Analyze (Assign);\n \n-            Rewrite (Bound, New_Occurrence_Of (Id, Loc));\n+            Rewrite (Original_Bound, New_Occurrence_Of (Id, Loc));\n \n             if Nkind (Assign) = N_Assignment_Statement then\n                return Expression (Assign);\n             else\n-               return Bound;\n+               return Original_Bound;\n             end if;\n          end One_Bound;\n \n       --  Start of processing for Process_Bounds\n \n       begin\n-         New_Lo_Bound := One_Bound (Lo);\n-         New_Hi_Bound := One_Bound (Hi);\n+         --  Determine expected type of range by analyzing separate copy.\n+\n+         Set_Parent (R_Copy, Parent (R));\n+         Pre_Analyze_And_Resolve (R_Copy);\n+         Typ := Etype (R_Copy);\n+         Set_Etype (R, Typ);\n+\n+         New_Lo_Bound := One_Bound (Lo, Low_Bound  (R_Copy));\n+         New_Hi_Bound := One_Bound (Hi, High_Bound (R_Copy));\n \n          --  Propagate staticness to loop range itself, in case the\n          --  corresponding subtype is static.\n@@ -1332,7 +1352,6 @@ package body Sem_Ch5 is\n                   if Nkind (DS) = N_Range\n                     and then Expander_Active\n                   then\n-                     Pre_Analyze_And_Resolve (DS);\n                      Process_Bounds (DS);\n                   else\n                      Analyze (DS);"}]}