{"sha": "42f97fd2c234f561c35a3ec046e03b7c76317079", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDJmOTdmZDJjMjM0ZjU2MWMzNWEzZWMwNDZlMDNiN2M3NjMxNzA3OQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2004-09-16T00:01:41Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2004-09-16T00:01:41Z"}, "message": "predict.c (expr_expected_value, [...]): New function.\n\n\t* predict.c (expr_expected_value, strip_builtin_expect): New function.\n\t(tree_predict_by_opcode): Use it.\n\t(tree_estimate_probability): Add, for now disabled,\n\tstrip_builtin_expect call.\n\nFrom-SVN: r87578", "tree": {"sha": "39e0215cb436739d062e1eda8a445f17a7e3f81b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/39e0215cb436739d062e1eda8a445f17a7e3f81b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/42f97fd2c234f561c35a3ec046e03b7c76317079", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42f97fd2c234f561c35a3ec046e03b7c76317079", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42f97fd2c234f561c35a3ec046e03b7c76317079", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42f97fd2c234f561c35a3ec046e03b7c76317079/comments", "author": null, "committer": null, "parents": [{"sha": "097f3d486a63f934e76229d47857478b40c76748", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/097f3d486a63f934e76229d47857478b40c76748", "html_url": "https://github.com/Rust-GCC/gccrs/commit/097f3d486a63f934e76229d47857478b40c76748"}], "stats": {"total": 154, "additions": 154, "deletions": 0}, "files": [{"sha": "8649f2eb7c46a80b2ff84954f96f49088d6570f3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42f97fd2c234f561c35a3ec046e03b7c76317079/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42f97fd2c234f561c35a3ec046e03b7c76317079/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=42f97fd2c234f561c35a3ec046e03b7c76317079", "patch": "@@ -1,3 +1,10 @@\n+2004-09-13  Jan Hubicka  <jh@suse.cz>\n+\n+\t* predict.c (expr_expected_value, strip_builtin_expect): New function.\n+\t(tree_predict_by_opcode): Use it.\n+\t(tree_estimate_probability): Add, for now disabled,\n+\tstrip_builtin_expect call.\n+\n 2004-09-15  James E Wilson  <wilson@specifixinc.com>\n \n \tPR target/17455"}, {"sha": "af92acaf2bd2bc761cf9b86272ceb9f8eac02b01", "filename": "gcc/predict.c", "status": "modified", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42f97fd2c234f561c35a3ec046e03b7c76317079/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42f97fd2c234f561c35a3ec046e03b7c76317079/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=42f97fd2c234f561c35a3ec046e03b7c76317079", "patch": "@@ -897,7 +897,139 @@ guess_outgoing_edge_probabilities (basic_block bb)\n   combine_predictions_for_insn (BB_END (bb), bb);\n }\n \f\n+/* Return constant EXPR will likely have at execution time, NULL if unknown. \n+   The function is used by builtin_expect branch predictor so the evidence\n+   must come from this construct and additional possible constant folding.\n+  \n+   We may want to implement more involved value guess (such as value range\n+   propagation based prediction), but such tricks shall go to new\n+   implementation.  */\n+\n+static tree\n+expr_expected_value (tree expr, bitmap visited)\n+{\n+  if (TREE_CONSTANT (expr))\n+    return expr;\n+  else if (TREE_CODE (expr) == SSA_NAME)\n+    {\n+      tree def = SSA_NAME_DEF_STMT (expr);\n+\n+      /* If we were already here, break the infinite cycle.  */\n+      if (bitmap_bit_p (visited, SSA_NAME_VERSION (expr)))\n+\treturn NULL;\n+      bitmap_set_bit (visited, SSA_NAME_VERSION (expr));\n+\n+      if (TREE_CODE (def) == PHI_NODE)\n+\t{\n+\t  /* All the arguments of the PHI node must have the same constant\n+\t     length.  */\n+\t  int i;\n+\t  tree val = NULL, new_val;\n \n+\t  for (i = 0; i < PHI_NUM_ARGS (def); i++)\n+\t    {\n+\t      tree arg = PHI_ARG_DEF (def, i);\n+\n+\t      /* If this PHI has itself as an argument, we cannot\n+\t\t determine the string length of this argument.  However,\n+\t\t if we can find a expectd constant value for the other\n+\t\t PHI args then we can still be sure that this is\n+\t\t likely a constant.  So be optimistic and just\n+\t\t continue with the next argument.  */\n+\t      if (arg == PHI_RESULT (def))\n+\t\tcontinue;\n+\n+\t      new_val = expr_expected_value (arg, visited);\n+\t      if (!new_val)\n+\t\treturn NULL;\n+\t      if (!val)\n+\t\tval = new_val;\n+\t      else if (!operand_equal_p (val, new_val, false))\n+\t\treturn NULL;\n+\t    }\n+\t  return val;\n+\t}\n+      if (TREE_CODE (def) != MODIFY_EXPR || TREE_OPERAND (def, 0) != expr)\n+\treturn NULL;\n+      return expr_expected_value (TREE_OPERAND (def, 1), visited);\n+    }\n+  else if (TREE_CODE (expr) == CALL_EXPR)\n+    {\n+      tree decl = get_callee_fndecl (expr);\n+      if (!decl)\n+\treturn NULL;\n+      if (DECL_BUILT_IN (decl) && DECL_FUNCTION_CODE (decl) == BUILT_IN_EXPECT)\n+\t{\n+\t  tree arglist = TREE_OPERAND (expr, 1);\n+\t  tree val;\n+\n+\t  if (arglist == NULL_TREE\n+\t      || TREE_CHAIN (arglist) == NULL_TREE)\n+\t    return NULL; \n+\t  val = TREE_VALUE (TREE_CHAIN (TREE_OPERAND (expr, 1)));\n+\t  if (TREE_CONSTANT (val))\n+\t    return val;\n+\t  return TREE_VALUE (TREE_CHAIN (TREE_OPERAND (expr, 1)));\n+\t}\n+    }\n+  if (TREE_CODE_CLASS (TREE_CODE (expr)) == '2'\n+      || TREE_CODE_CLASS (TREE_CODE (expr)) == '<')\n+    {\n+      tree op0, op1, res;\n+      op0 = expr_expected_value (TREE_OPERAND (expr, 0), visited);\n+      if (!op0)\n+\treturn NULL;\n+      op1 = expr_expected_value (TREE_OPERAND (expr, 1), visited);\n+      if (!op1)\n+\treturn NULL;\n+      res = fold (build (TREE_CODE (expr), TREE_TYPE (expr), op0, op1));\n+      if (TREE_CONSTANT (res))\n+\treturn res;\n+      return NULL;\n+    }\n+  if (TREE_CODE_CLASS (TREE_CODE (expr)) == '1')\n+    {\n+      tree op0, res;\n+      op0 = expr_expected_value (TREE_OPERAND (expr, 0), visited);\n+      if (!op0)\n+\treturn NULL;\n+      res = fold (build1 (TREE_CODE (expr), TREE_TYPE (expr), op0));\n+      if (TREE_CONSTANT (res))\n+\treturn res;\n+      return NULL;\n+    }\n+  return NULL;\n+}\n+\f\n+/* Get rid of all builtin_expect calls we no longer need.  */\n+static void\n+strip_builtin_expect (void)\n+{\n+  basic_block bb;\n+  FOR_EACH_BB (bb)\n+    {\n+      block_stmt_iterator bi;\n+      for (bi = bsi_start (bb); !bsi_end_p (bi); bsi_next (&bi))\n+\t{\n+\t  tree stmt = bsi_stmt (bi);\n+\t  tree fndecl;\n+\t  tree arglist;\n+\n+\t  if (TREE_CODE (stmt) == MODIFY_EXPR\n+\t      && TREE_CODE (TREE_OPERAND (stmt, 1)) == CALL_EXPR\n+\t      && (fndecl = get_callee_fndecl (TREE_OPERAND (stmt, 1)))\n+\t      && DECL_BUILT_IN (fndecl)\n+\t      && DECL_FUNCTION_CODE (fndecl) == BUILT_IN_EXPECT\n+\t      && (arglist = TREE_OPERAND (TREE_OPERAND (stmt, 1), 1))\n+\t      && TREE_CHAIN (arglist))\n+\t    {\n+\t      TREE_OPERAND (stmt, 1) = TREE_VALUE (arglist);\n+\t      modify_stmt (stmt);\n+\t    }\n+\t}\n+    }\n+}\n+\f\n /* Predict using opcode of the last statement in basic block.  */\n static void\n tree_predict_by_opcode (basic_block bb)\n@@ -907,6 +1039,8 @@ tree_predict_by_opcode (basic_block bb)\n   tree cond;\n   tree op0;\n   tree type;\n+  tree val;\n+  bitmap visited;\n \n   if (!stmt || TREE_CODE (stmt) != COND_EXPR)\n     return;\n@@ -918,6 +1052,17 @@ tree_predict_by_opcode (basic_block bb)\n     return;\n   op0 = TREE_OPERAND (cond, 0);\n   type = TREE_TYPE (op0);\n+  visited = BITMAP_XMALLOC ();\n+  val = expr_expected_value (cond, visited);\n+  BITMAP_XFREE (visited);\n+  if (val)\n+    {\n+      if (integer_zerop (val))\n+\tpredict_edge_def (then_edge, PRED_BUILTIN_EXPECT, NOT_TAKEN);\n+      else\n+\tpredict_edge_def (then_edge, PRED_BUILTIN_EXPECT, TAKEN);\n+      return;\n+    }\n   /* Try \"pointer heuristic.\"\n      A comparison ptr == 0 is predicted as false.\n      Similarly, a comparison ptr1 == ptr2 is predicted as false.  */\n@@ -1072,6 +1217,8 @@ tree_estimate_probability (void)\n   FOR_EACH_BB (bb)\n     combine_predictions_for_bb (dump_file, bb);\n \n+  if (0)  /* FIXME: Enable once we are pass down the profile to RTL level.  */\n+    strip_builtin_expect ();\n   estimate_bb_frequencies (&loops_info);\n   free_dominance_info (CDI_POST_DOMINATORS);\n   remove_fake_exit_edges ();"}]}