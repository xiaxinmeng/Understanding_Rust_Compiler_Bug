{"sha": "62415523eb8b4369892c63aa5e51942423178b78", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjI0MTU1MjNlYjhiNDM2OTg5MmM2M2FhNWU1MTk0MjQyMzE3OGI3OA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-02-13T10:47:03Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-02-13T10:47:03Z"}, "message": "Fix breakage in my previous checkin.\n\nFrom-SVN: r39623", "tree": {"sha": "ab4eba41b2a4cd8e89b76a924c4a8c8388a10fb7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ab4eba41b2a4cd8e89b76a924c4a8c8388a10fb7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/62415523eb8b4369892c63aa5e51942423178b78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62415523eb8b4369892c63aa5e51942423178b78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62415523eb8b4369892c63aa5e51942423178b78", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62415523eb8b4369892c63aa5e51942423178b78/comments", "author": null, "committer": null, "parents": [{"sha": "f84aa48ac1c8718f7f3275496aa4bcc734c6e36a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f84aa48ac1c8718f7f3275496aa4bcc734c6e36a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f84aa48ac1c8718f7f3275496aa4bcc734c6e36a"}], "stats": {"total": 12, "additions": 6, "deletions": 6}, "files": [{"sha": "49d8376f83b772281b0bd04aa1c362f8d84b039e", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62415523eb8b4369892c63aa5e51942423178b78/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62415523eb8b4369892c63aa5e51942423178b78/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=62415523eb8b4369892c63aa5e51942423178b78", "patch": "@@ -8814,15 +8814,15 @@ ix86_register_move_cost (mode, class1, class2)\n      stall.  Count this as arbitarily high cost of 20.  */\n   if (ix86_secondary_memory_needed (class1, class2, mode, 0))\n     {\n-      if (CLASS_MAX_NREGS (CLASS1, MODE) > CLASS_MAX_NREGS (CLASS2, MODE))\n+      if (CLASS_MAX_NREGS (class1, mode) > CLASS_MAX_NREGS (class2, mode))\n \treturn 10;\n-      return (MEMORY_MOVE_COST (MODE, CLASS1, 0)\n-\t      + MEMORY_MOVE_COST (MODE, CLASS2, 1));\n+      return (MEMORY_MOVE_COST (mode, class1, 0)\n+\t      + MEMORY_MOVE_COST (mode, class2, 1));\n     }\n   /* Moves between SSE/MMX and integer unit are expensive.\n      ??? We should make this cost CPU specific.  */\n-  if (MMX_CLASS_P (CLASS1) != MMX_CLASS_P (CLASS2)\n-      || SSE_CLASS_P (CLASS1) != SSE_CLASS_P (CLASS2))\n+  if (MMX_CLASS_P (class1) != MMX_CLASS_P (class2)\n+      || SSE_CLASS_P (class1) != SSE_CLASS_P (class2))\n     return 3;\n   return 2;\n }\n@@ -8852,7 +8852,7 @@ ix86_hard_regno_mode_ok (regno, mode)\n     return 0;\n   /* Take care for QImode values - they can be in non-QI regs, but then\n      they do cause partial register stalls.  */\n-  if (QI_REG_P (regno) || mode != QImode)\n+  if (regno < 4 || mode != QImode)\n     return 1;\n   return reload_in_progress || reload_completed || !TARGET_PARTIAL_REG_STALL;\n }"}]}