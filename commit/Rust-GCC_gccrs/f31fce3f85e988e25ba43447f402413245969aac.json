{"sha": "f31fce3f85e988e25ba43447f402413245969aac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjMxZmNlM2Y4NWU5ODhlMjViYTQzNDQ3ZjQwMjQxMzI0NTk2OWFhYw==", "commit": {"author": {"name": "John Wehle", "email": "john@feith.com", "date": "1998-04-05T20:32:31Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-04-05T20:32:31Z"}, "message": "i386.md (movsf_push, movsf_mem): Remove.\n\n        * i386.md (movsf_push, movsf_mem): Remove.\n        (movsf_push): Rename from movsf_push_nomove and move in front of\n        movsf.  Use nonmemory_operand predicate and don't bother checking\n        TARGET_MOVE.\n        (movsf_push_memory): New pattern.\n        (movsf): Don't bother checking for push_operand.  If TARGET_MOVE and\n        both operands refer to memory then force operand[1] into a register.\n        (movsf_normal): Change to unnamed pattern.\n        Likewise for movdf, movxf, and friends.\n\nFrom-SVN: r19011", "tree": {"sha": "17c0da4a2a93d0dd1da71f898c8e4ac142ab0db7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/17c0da4a2a93d0dd1da71f898c8e4ac142ab0db7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f31fce3f85e988e25ba43447f402413245969aac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f31fce3f85e988e25ba43447f402413245969aac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f31fce3f85e988e25ba43447f402413245969aac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f31fce3f85e988e25ba43447f402413245969aac/comments", "author": {"login": "jlwehle", "id": 46985578, "node_id": "MDQ6VXNlcjQ2OTg1NTc4", "avatar_url": "https://avatars.githubusercontent.com/u/46985578?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jlwehle", "html_url": "https://github.com/jlwehle", "followers_url": "https://api.github.com/users/jlwehle/followers", "following_url": "https://api.github.com/users/jlwehle/following{/other_user}", "gists_url": "https://api.github.com/users/jlwehle/gists{/gist_id}", "starred_url": "https://api.github.com/users/jlwehle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jlwehle/subscriptions", "organizations_url": "https://api.github.com/users/jlwehle/orgs", "repos_url": "https://api.github.com/users/jlwehle/repos", "events_url": "https://api.github.com/users/jlwehle/events{/privacy}", "received_events_url": "https://api.github.com/users/jlwehle/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "27ebc03eb1a14773bede4a81ae43ffedae4720ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27ebc03eb1a14773bede4a81ae43ffedae4720ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27ebc03eb1a14773bede4a81ae43ffedae4720ee"}], "stats": {"total": 362, "additions": 123, "deletions": 239}, "files": [{"sha": "7ee2053e5c46ab775d818ed810cf2527daa0501e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f31fce3f85e988e25ba43447f402413245969aac/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f31fce3f85e988e25ba43447f402413245969aac/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f31fce3f85e988e25ba43447f402413245969aac", "patch": "@@ -1,3 +1,15 @@\n+Sun Apr  5 21:31:24 1998  John Wehle  (john@feith.com)\n+\n+\t* i386.md (movsf_push, movsf_mem): Remove.\n+\t(movsf_push): Rename from movsf_push_nomove and move in front of\n+\tmovsf.  Use nonmemory_operand predicate and don't bother checking\n+\tTARGET_MOVE.\n+\t(movsf_push_memory): New pattern.\n+\t(movsf): Don't bother checking for push_operand.  If TARGET_MOVE and\n+\tboth operands refer to memory then force operand[1] into a register.\n+\t(movsf_normal): Change to unnamed pattern.\n+\tLikewise for movdf, movxf, and friends.\n+\n Sun Apr 5 18:45:51 PDT 1998 Jeff Law  (law@cygnus.com)\n \n \t* version.c: Bump for snapshot."}, {"sha": "78d284883441cc62f2312c5620eaba5135070735", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 111, "deletions": 239, "changes": 350, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f31fce3f85e988e25ba43447f402413245969aac/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f31fce3f85e988e25ba43447f402413245969aac/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=f31fce3f85e988e25ba43447f402413245969aac", "patch": "@@ -1180,31 +1180,61 @@\n   return AS2 (mov%B0,%1,%0);\n }\")\n \n+(define_insn \"movsf_push\"\n+  [(set (match_operand:SF 0 \"push_operand\" \"=<,<\")\n+\t(match_operand:SF 1 \"nonmemory_operand\" \"rF,f\"))]\n+  \"\"\n+  \"*\n+{\n+  if (STACK_REG_P (operands[1]))\n+    {\n+      rtx xops[3];\n+\n+      if (! STACK_TOP_P (operands[1]))\n+        abort ();\n+\n+      xops[0] = AT_SP (SFmode);\n+      xops[1] = GEN_INT (4);\n+      xops[2] = stack_pointer_rtx;\n+\n+      output_asm_insn (AS2 (sub%L2,%1,%2), xops);\n+\n+      if (find_regno_note (insn, REG_DEAD, FIRST_STACK_REG))\n+        output_asm_insn (AS1 (fstp%S0,%0), xops);\n+      else\n+        output_asm_insn (AS1 (fst%S0,%0), xops);\n+\n+      RET;\n+    }\n+  return AS1 (push%L0,%1);\n+}\")\n+\n+(define_insn \"movsf_push_memory\"\n+  [(set (match_operand:SF 0 \"push_operand\" \"=<\")\n+\t(match_operand:SF 1 \"memory_operand\" \"m\"))]\n+  \"TARGET_PUSH_MEMORY\"\n+  \"* return AS1 (push%L0,%1);\")\n+\n (define_expand \"movsf\"\n   [(set (match_operand:SF 0 \"general_operand\" \"\")\n \t(match_operand:SF 1 \"general_operand\" \"\"))]\n   \"\"\n   \"\n {\n-  /* Special case memory->memory moves and pushes */\n+  /* Don't generate memory->memory moves, go through a register */\n   if (TARGET_MOVE\n       && (reload_in_progress | reload_completed) == 0\n       && GET_CODE (operands[0]) == MEM\n-      && (GET_CODE (operands[1]) == MEM || push_operand (operands[0], SFmode)))\n+      && GET_CODE (operands[1]) == MEM)\n     {\n-      rtx (*genfunc) PROTO((rtx, rtx)) = (push_operand (operands[0], SFmode))\n-\t\t\t\t\t\t? gen_movsf_push\n-\t\t\t\t\t\t: gen_movsf_mem;\n-\n-      emit_insn ((*genfunc) (operands[0], operands[1]));\n-      DONE;\n+      operands[1] = force_reg (SFmode, operands[1]);\n     }\n \n   /* If we are loading a floating point constant that isn't 0 or 1\n      into a register, indicate we need the pic register loaded.  This could\n      be optimized into stores of constants if the target eventually moves\n      to memory, but better safe than sorry.  */\n-  if ((reload_in_progress | reload_completed) == 0\n+  else if ((reload_in_progress | reload_completed) == 0\n       && GET_CODE (operands[0]) != MEM\n       && GET_CODE (operands[1]) == CONST_DOUBLE\n       && !standard_80387_constant_p (operands[1]))\n@@ -1225,86 +1255,8 @@\n     }\n }\")\n \n-(define_insn \"movsf_push_nomove\"\n-  [(set (match_operand:SF 0 \"push_operand\" \"=<,<\")\n-\t(match_operand:SF 1 \"general_operand\" \"gF,f\"))]\n-  \"!TARGET_MOVE\"\n-  \"*\n-{\n-  if (STACK_REG_P (operands[1]))\n-    {\n-      rtx xops[3];\n-\n-      if (! STACK_TOP_P (operands[1]))\n-        abort ();\n-\n-      xops[0] = AT_SP (SFmode);\n-      xops[1] = GEN_INT (4);\n-      xops[2] = stack_pointer_rtx;\n-\n-      output_asm_insn (AS2 (sub%L2,%1,%2), xops);\n-\n-      if (find_regno_note (insn, REG_DEAD, FIRST_STACK_REG))\n-        output_asm_insn (AS1 (fstp%S0,%0), xops);\n-      else\n-        output_asm_insn (AS1 (fst%S0,%0), xops);\n-      RET;\n-    }\n-  return AS1 (push%L1,%1);\n-}\")\n-\n-(define_insn \"movsf_push\"\n-  [(set (match_operand:SF 0 \"push_operand\" \"=<,<,<,<\")\n-\t(match_operand:SF 1 \"general_operand\" \"rF,f,m,m\"))\n-   (clobber (match_scratch:SI 2 \"=X,X,r,X\"))]\n-  \"\"\n-  \"*\n-{\n-  if (STACK_REG_P (operands[1]))\n-    {\n-      rtx xops[3];\n-\n-      if (! STACK_TOP_P (operands[1]))\n-        abort ();\n-\n-      xops[0] = AT_SP (SFmode);\n-      xops[1] = GEN_INT (4);\n-      xops[2] = stack_pointer_rtx;\n-\n-      output_asm_insn (AS2 (sub%L2,%1,%2), xops);\n-\n-      if (find_regno_note (insn, REG_DEAD, FIRST_STACK_REG))\n-        output_asm_insn (AS1 (fstp%S0,%0), xops);\n-      else\n-        output_asm_insn (AS1 (fst%S0,%0), xops);\n-      RET;\n-    }\n-\n-  else if (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != REG)\n-    return AS1 (push%L1,%1);\n-\n-  else\n-    {\n-      output_asm_insn (AS2 (mov%L2,%1,%2), operands);\n-      return AS1 (push%L2,%2);\n-    }\n-}\")\n-\n-;; Special memory<->memory pattern that combine will recreate from the\n-;; moves to pseudos.\n-(define_insn \"movsf_mem\"\n-  [(set (match_operand:SF 0 \"memory_operand\" \"=m\")\n-\t(match_operand:SF 1 \"memory_operand\" \"m\"))\n-   (clobber (match_scratch:SI 2 \"=&r\"))]\n-  \"\"\n-  \"*\n-{\n-  output_asm_insn (AS2 (mov%L2,%1,%2), operands);\n-  return AS2 (mov%L0,%2,%0);\n-}\")\n-\n ;; For the purposes of regclass, prefer FLOAT_REGS.\n-(define_insn \"movsf_normal\"\n+(define_insn \"\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=*rfm,*rf,f,!*rm\")\n \t(match_operand:SF 1 \"general_operand\" \"*rf,*rfm,fG,fF\"))]\n   \"(!TARGET_MOVE || GET_CODE (operands[0]) != MEM) || (GET_CODE (operands[1]) != MEM)\"\n@@ -1375,31 +1327,58 @@\n     return AS1 (fxch,%0);\n }\")\n \n+(define_insn \"movdf_push\"\n+  [(set (match_operand:DF 0 \"push_operand\" \"=<,<\")\n+\t(match_operand:DF 1 \"nonmemory_operand\" \"rF,f\"))]\n+  \"\"\n+  \"*\n+{\n+  if (STACK_REG_P (operands[1]))\n+    {\n+      rtx xops[3];\n+\n+      xops[0] = AT_SP (DFmode);\n+      xops[1] = GEN_INT (8);\n+      xops[2] = stack_pointer_rtx;\n+\n+      output_asm_insn (AS2 (sub%L2,%1,%2), xops);\n+\n+      if (find_regno_note (insn, REG_DEAD, FIRST_STACK_REG))\n+        output_asm_insn (AS1 (fstp%Q0,%0), xops);\n+      else\n+        output_asm_insn (AS1 (fst%Q0,%0), xops);\n+\n+      RET;\n+    }\n+  return output_move_double (operands);\n+}\")\n+\n+(define_insn \"movdf_push_memory\"\n+  [(set (match_operand:DF 0 \"push_operand\" \"=<\")\n+\t(match_operand:DF 1 \"memory_operand\" \"o\"))]\n+  \"TARGET_PUSH_MEMORY\"\n+  \"* return output_move_pushmem (operands, insn, GET_MODE_SIZE (DFmode),0,0);\")\n+\n (define_expand \"movdf\"\n   [(set (match_operand:DF 0 \"general_operand\" \"\")\n \t(match_operand:DF 1 \"general_operand\" \"\"))]\n   \"\"\n   \"\n {\n-  /* Special case memory->memory moves and pushes */\n+  /* Don't generate memory->memory moves, go through a register */\n   if (TARGET_MOVE\n       && (reload_in_progress | reload_completed) == 0\n       && GET_CODE (operands[0]) == MEM\n-      && (GET_CODE (operands[1]) == MEM || push_operand (operands[0], DFmode)))\n+      && GET_CODE (operands[1]) == MEM)\n     {\n-      rtx (*genfunc) PROTO((rtx, rtx)) = (push_operand (operands[0], DFmode))\n-\t\t\t\t\t\t? gen_movdf_push\n-\t\t\t\t\t\t: gen_movdf_mem;\n-\n-      emit_insn ((*genfunc) (operands[0], operands[1]));\n-      DONE;\n+      operands[1] = force_reg (DFmode, operands[1]);\n     }\n \n   /* If we are loading a floating point constant that isn't 0 or 1 into a\n      register, indicate we need the pic register loaded.  This could be\n      optimized into stores of constants if the target eventually moves to\n      memory, but better safe than sorry.  */\n-  if ((reload_in_progress | reload_completed) == 0\n+  else if ((reload_in_progress | reload_completed) == 0\n       && GET_CODE (operands[0]) != MEM\n       && GET_CODE (operands[1]) == CONST_DOUBLE\n       && !standard_80387_constant_p (operands[1]))\n@@ -1420,74 +1399,6 @@\n     }\n }\")\n \n-(define_insn \"movdf_push_nomove\"\n-  [(set (match_operand:DF 0 \"push_operand\" \"=<,<\")\n-\t(match_operand:DF 1 \"general_operand\" \"gF,f\"))]\n-  \"!TARGET_MOVE\"\n-  \"*\n-{\n-  if (STACK_REG_P (operands[1]))\n-    {\n-      rtx xops[3];\n-\n-      xops[0] = AT_SP (SFmode);\n-      xops[1] = GEN_INT (8);\n-      xops[2] = stack_pointer_rtx;\n-\n-      output_asm_insn (AS2 (sub%L2,%1,%2), xops);\n-\n-      if (find_regno_note (insn, REG_DEAD, FIRST_STACK_REG))\n-        output_asm_insn (AS1 (fstp%Q0,%0), xops);\n-      else\n-        output_asm_insn (AS1 (fst%Q0,%0), xops);\n-\n-      RET;\n-    }\n-  else\n-    return output_move_double (operands);\n-}\")\n-\n-(define_insn \"movdf_push\"\n-  [(set (match_operand:DF 0 \"push_operand\" \"=<,<,<,<,<\")\n-\t(match_operand:DF 1 \"general_operand\" \"rF,f,o,o,o\"))\n-   (clobber (match_scratch:SI 2 \"=X,X,&r,&r,X\"))\n-   (clobber (match_scratch:SI 3 \"=X,X,&r,X,X\"))]\n-  \"\"\n-  \"*\n-{\n-  if (STACK_REG_P (operands[1]))\n-    {\n-      rtx xops[3];\n-\n-      xops[0] = AT_SP (SFmode);\n-      xops[1] = GEN_INT (8);\n-      xops[2] = stack_pointer_rtx;\n-\n-      output_asm_insn (AS2 (sub%L2,%1,%2), xops);\n-\n-      if (find_regno_note (insn, REG_DEAD, FIRST_STACK_REG))\n-        output_asm_insn (AS1 (fstp%Q0,%0), xops);\n-      else\n-        output_asm_insn (AS1 (fst%Q0,%0), xops);\n-\n-      RET;\n-    }\n-\n-  else if (GET_CODE (operands[1]) != MEM)\n-    return output_move_double (operands);\n-\n-  else\n-    return output_move_pushmem (operands, insn, GET_MODE_SIZE (DFmode), 2, 4);\n-}\")\n-\n-(define_insn \"movdf_mem\"\n-  [(set (match_operand:DF 0 \"memory_operand\" \"=o,o\")\n-\t(match_operand:DF 1 \"memory_operand\" \"o,o\"))\n-   (clobber (match_scratch:SI 2 \"=&r,&r\"))\n-   (clobber (match_scratch:SI 3 \"=&r,X\"))]\n-  \"\"\n-  \"* return output_move_memory (operands, insn, GET_MODE_SIZE (DFmode), 2, 4);\")\n-\n ;; For the purposes of regclass, prefer FLOAT_REGS.\n (define_insn \"\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f,fm,!*rf,!*rm\")\n@@ -1562,31 +1473,57 @@\n     return AS1 (fxch,%0);\n }\")\n \n+(define_insn \"movxf_push\"\n+  [(set (match_operand:XF 0 \"push_operand\" \"=<,<\")\n+ \t(match_operand:XF 1 \"nonmemory_operand\" \"rF,f\"))]\n+  \"\"\n+  \"*\n+{\n+  if (STACK_REG_P (operands[1]))\n+    {\n+      rtx xops[3];\n+\n+      xops[0] = AT_SP (XFmode);\n+      xops[1] = GEN_INT (12);\n+      xops[2] = stack_pointer_rtx;\n+\n+      output_asm_insn (AS2 (sub%L2,%1,%2), xops);\n+\n+      output_asm_insn (AS1 (fstp%T0,%0), xops);\n+      if (! find_regno_note (insn, REG_DEAD, FIRST_STACK_REG))\n+\toutput_asm_insn (AS1 (fld%T0,%0), xops);\n+\n+      RET;\n+    }\n+  return output_move_double (operands);\n+ }\")\n+\n+(define_insn \"movxf_push_memory\"\n+  [(set (match_operand:XF 0 \"push_operand\" \"=<\")\n+ \t(match_operand:XF 1 \"memory_operand\" \"o\"))]\n+  \"TARGET_PUSH_MEMORY\"\n+  \"* return output_move_pushmem (operands, insn, GET_MODE_SIZE (XFmode),0,0);\")\n+\n (define_expand \"movxf\"\n   [(set (match_operand:XF 0 \"general_operand\" \"\")\n \t(match_operand:XF 1 \"general_operand\" \"\"))]\n   \"\"\n   \"\n {\n-  /* Special case memory->memory moves and pushes */\n+  /* Don't generate memory->memory moves, go through a register */\n   if (TARGET_MOVE\n       && (reload_in_progress | reload_completed) == 0\n       && GET_CODE (operands[0]) == MEM\n-      && (GET_CODE (operands[1]) == MEM || push_operand (operands[0], XFmode)))\n+      && GET_CODE (operands[1]) == MEM)\n     {\n-      rtx (*genfunc) PROTO((rtx, rtx)) = (push_operand (operands[0], XFmode))\n-\t\t\t\t\t\t? gen_movxf_push\n-\t\t\t\t\t\t: gen_movxf_mem;\n-\n-      emit_insn ((*genfunc) (operands[0], operands[1]));\n-      DONE;\n+      operands[1] = force_reg (XFmode, operands[1]);\n     }\n \n   /* If we are loading a floating point constant that isn't 0 or 1\n      into a register, indicate we need the pic register loaded.  This could\n      be optimized into stores of constants if the target eventually moves\n      to memory, but better safe than sorry.  */\n-  if ((reload_in_progress | reload_completed) == 0\n+  else if ((reload_in_progress | reload_completed) == 0\n       && GET_CODE (operands[0]) != MEM\n       && GET_CODE (operands[1]) == CONST_DOUBLE\n       && !standard_80387_constant_p (operands[1]))\n@@ -1608,71 +1545,6 @@\n }\")\n \n \n-(define_insn \"movxf_push_nomove\"\n-  [(set (match_operand:XF 0 \"push_operand\" \"=<,<\")\n- \t(match_operand:XF 1 \"general_operand\" \"gF,f\"))]\n-  \"!TARGET_MOVE\"\n-  \"*\n-{\n-  if (STACK_REG_P (operands[1]))\n-    {\n-      rtx xops[3];\n-\n-      xops[0] = AT_SP (SFmode);\n-      xops[1] = GEN_INT (12);\n-      xops[2] = stack_pointer_rtx;\n-\n-      output_asm_insn (AS2 (sub%L2,%1,%2), xops);\n-      output_asm_insn (AS1 (fstp%T0,%0), xops);\n-      if (! find_regno_note (insn, REG_DEAD, FIRST_STACK_REG))\n-\toutput_asm_insn (AS1 (fld%T0,%0), xops);\n-\n-      RET;\n-    }\n-  else\n-    return output_move_double (operands);\n- }\")\n-\n-(define_insn \"movxf_push\"\n-  [(set (match_operand:XF 0 \"push_operand\" \"=<,<,<,<,<\")\n- \t(match_operand:XF 1 \"general_operand\" \"rF,f,o,o,o\"))\n-   (clobber (match_scratch:SI 2 \"=X,X,&r,&r,X\"))\n-   (clobber (match_scratch:SI 3 \"=X,X,&r,X,X\"))]\n-  \"\"\n-  \"*\n-{\n-  if (STACK_REG_P (operands[1]))\n-    {\n-      rtx xops[3];\n-\n-      xops[0] = AT_SP (SFmode);\n-      xops[1] = GEN_INT (12);\n-      xops[2] = stack_pointer_rtx;\n-\n-      output_asm_insn (AS2 (sub%L2,%1,%2), xops);\n-      output_asm_insn (AS1 (fstp%T0,%0), xops);\n-      if (! find_regno_note (insn, REG_DEAD, FIRST_STACK_REG))\n-\toutput_asm_insn (AS1 (fld%T0,%0), xops);\n-\n-      RET;\n-    }\n-\n-  else if (GET_CODE (operands[1]) != MEM\n-\t   || GET_CODE (operands[2]) != REG)\n-    return output_move_double (operands);\n-\n-  else\n-    return output_move_pushmem (operands, insn, GET_MODE_SIZE (XFmode), 2, 4);\n-}\")\n-\n-(define_insn \"movxf_mem\"\n-  [(set (match_operand:XF 0 \"memory_operand\" \"=o,o\")\n-\t(match_operand:XF 1 \"memory_operand\" \"o,o\"))\n-   (clobber (match_scratch:SI 2 \"=&r,&r\"))\n-   (clobber (match_scratch:SI 3 \"=&r,X\"))]\n-  \"\"\n-  \"* return output_move_memory (operands, insn, GET_MODE_SIZE (XFmode), 2, 4);\")\n-\n (define_insn \"\"\n   [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f,fm,!*rf,!*rm\")\n \t(match_operand:XF 1 \"general_operand\" \"fmG,f,*rfm,*rfF\"))]"}]}