{"sha": "478baf913e79d1d3219b513b494943c830850593", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDc4YmFmOTEzZTc5ZDFkMzIxOWI1MTNiNDk0OTQzYzgzMDg1MDU5Mw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2016-03-23T13:20:16Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2016-03-23T13:20:16Z"}, "message": "re PR tree-optimization/64058 (Performance degradation after r216304)\n\n\tPR tree-optimization/64058\n\t* tree-ssa-coalesce.c (struct coalesce_pair): Add new field\n\tCONFLICT_COUNT.\n\t(struct ssa_conflicts): Move up earlier in the file.\n\t(conflicts_, var_map_): New static variables.\n\t(initialize_conflict_count): New function to initialize the\n\tCONFLICT_COUNT field for each conflict pair.\n\t(compare_pairs): Lazily initialize the conflict count and use it\n\tas the first tie-breaker.\n\t(sort_coalesce_list): Add new arguments conflicts, map.  Initialize\n\tand wipe conflicts_ and map_ around the call to qsort.  Remove\n\tspecial case for 2 coalesce pairs.\n\t* bitmap.c (bitmap_count_unique_bits): New function.\n\t(bitmap_count_bits_in_word): New function, extracted from\n\tbitmap_count_bits.\n\t(bitmap_count_bits): Use bitmap_count_bits_in_word.\n\t* bitmap.h (bitmap_count_unique_bits): Declare it.\n\nFrom-SVN: r234425", "tree": {"sha": "a015e0e499c5e938dbce68a3de2ecabc309f489a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a015e0e499c5e938dbce68a3de2ecabc309f489a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/478baf913e79d1d3219b513b494943c830850593", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/478baf913e79d1d3219b513b494943c830850593", "html_url": "https://github.com/Rust-GCC/gccrs/commit/478baf913e79d1d3219b513b494943c830850593", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/478baf913e79d1d3219b513b494943c830850593/comments", "author": null, "committer": null, "parents": [{"sha": "b01e88e56b3ad6bf76c18500035bc4ed8ef036cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b01e88e56b3ad6bf76c18500035bc4ed8ef036cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b01e88e56b3ad6bf76c18500035bc4ed8ef036cd"}], "stats": {"total": 209, "additions": 168, "deletions": 41}, "files": [{"sha": "f9b2af2fa852ff0750722d1b0665c358621ef077", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/478baf913e79d1d3219b513b494943c830850593/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/478baf913e79d1d3219b513b494943c830850593/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=478baf913e79d1d3219b513b494943c830850593", "patch": "@@ -1,3 +1,23 @@\n+2016-03-23  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/64058\n+\t* tree-ssa-coalesce.c (struct coalesce_pair): Add new field\n+\tCONFLICT_COUNT.\n+\t(struct ssa_conflicts): Move up earlier in the file.\n+\t(conflicts_, var_map_): New static variables.\n+\t(initialize_conflict_count): New function to initialize the\n+\tCONFLICT_COUNT field for each conflict pair.\n+\t(compare_pairs): Lazily initialize the conflict count and use it\n+\tas the first tie-breaker.\n+\t(sort_coalesce_list): Add new arguments conflicts, map.  Initialize\n+\tand wipe conflicts_ and map_ around the call to qsort.  Remove\n+\tspecial case for 2 coalesce pairs.\n+\t* bitmap.c (bitmap_count_unique_bits): New function.\n+\t(bitmap_count_bits_in_word): New function, extracted from\n+\tbitmap_count_bits.\n+\t(bitmap_count_bits): Use bitmap_count_bits_in_word.\n+\t* bitmap.h (bitmap_count_unique_bits): Declare it.\n+\n 2016-03-23  Ilya Enkovich  <enkovich.gnu@gmail.com>\n \n \tPR target/69917"}, {"sha": "0c05512b66691b0f40d40c8b683398584643d6f0", "filename": "gcc/bitmap.c", "status": "modified", "additions": 54, "deletions": 9, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/478baf913e79d1d3219b513b494943c830850593/gcc%2Fbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/478baf913e79d1d3219b513b494943c830850593/gcc%2Fbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.c?ref=478baf913e79d1d3219b513b494943c830850593", "patch": "@@ -662,26 +662,71 @@ bitmap_popcount (BITMAP_WORD a)\n   return ret;\n }\n #endif\n+\n+/* Count and return the number of bits set in the bitmap word BITS.  */\n+static unsigned long\n+bitmap_count_bits_in_word (const BITMAP_WORD *bits)\n+{\n+  unsigned long count = 0;\n+\n+  for (unsigned ix = 0; ix != BITMAP_ELEMENT_WORDS; ix++)\n+    {\n+#if GCC_VERSION >= 3400\n+      /* Note that popcountl matches BITMAP_WORD in type, so the actual size\n+\t of BITMAP_WORD is not material.  */\n+      count += __builtin_popcountl (bits[ix]);\n+#else\n+      count += bitmap_popcount (bits[ix]);\n+#endif\n+    }\n+  return count;\n+}\n+\n /* Count the number of bits set in the bitmap, and return it.  */\n \n unsigned long\n bitmap_count_bits (const_bitmap a)\n {\n   unsigned long count = 0;\n   const bitmap_element *elt;\n-  unsigned ix;\n \n   for (elt = a->first; elt; elt = elt->next)\n+    count += bitmap_count_bits_in_word (elt->bits);\n+\n+  return count;\n+}\n+\n+/* Count the number of unique bits set in A and B and return it.  */\n+\n+unsigned long\n+bitmap_count_unique_bits (const_bitmap a, const_bitmap b)\n+{\n+  unsigned long count = 0;\n+  const bitmap_element *elt_a, *elt_b;\n+\n+  for (elt_a = a->first, elt_b = b->first; elt_a && elt_b; )\n     {\n-      for (ix = 0; ix != BITMAP_ELEMENT_WORDS; ix++)\n+      /* If we're at different indices, then count all the bits\n+\t in the lower element.  If we're at the same index, then\n+\t count the bits in the IOR of the two elements.  */\n+      if (elt_a->indx < elt_b->indx)\n \t{\n-#if GCC_VERSION >= 3400\n- \t  /* Note that popcountl matches BITMAP_WORD in type, so the actual size\n-\t of BITMAP_WORD is not material.  */\n-\t  count += __builtin_popcountl (elt->bits[ix]);\n-#else\n-\t  count += bitmap_popcount (elt->bits[ix]);\n-#endif\n+\t  count += bitmap_count_bits_in_word (elt_a->bits);\n+\t  elt_a = elt_a->next;\n+\t}\n+      else if (elt_b->indx < elt_a->indx)\n+\t{\n+\t  count += bitmap_count_bits_in_word (elt_b->bits);\n+\t  elt_b = elt_b->next;\n+\t}\n+      else\n+\t{\n+\t  BITMAP_WORD bits[BITMAP_ELEMENT_WORDS];\n+\t  for (unsigned ix = 0; ix != BITMAP_ELEMENT_WORDS; ix++)\n+\t    bits[ix] = elt_a->bits[ix] | elt_b->bits[ix];\n+\t  count += bitmap_count_bits_in_word (bits);\n+\t  elt_a = elt_a->next;\n+\t  elt_b = elt_b->next;\n \t}\n     }\n   return count;"}, {"sha": "111571186b76402f09e5326fdd81c4e2f01fa172", "filename": "gcc/bitmap.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/478baf913e79d1d3219b513b494943c830850593/gcc%2Fbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/478baf913e79d1d3219b513b494943c830850593/gcc%2Fbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.h?ref=478baf913e79d1d3219b513b494943c830850593", "patch": "@@ -280,6 +280,9 @@ extern bool bitmap_single_bit_set_p (const_bitmap);\n /* Count the number of bits set in the bitmap.  */\n extern unsigned long bitmap_count_bits (const_bitmap);\n \n+/* Count the number of unique bits set across the two bitmaps.  */\n+extern unsigned long bitmap_count_unique_bits (const_bitmap, const_bitmap);\n+\n /* Boolean operations on bitmaps.  The _into variants are two operand\n    versions that modify the first source operand.  The other variants\n    are three operand versions that to not destroy the source bitmaps."}, {"sha": "57fc6530e69517426efd8d935e927c6a83bf35a2", "filename": "gcc/tree-ssa-coalesce.c", "status": "modified", "additions": 91, "deletions": 32, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/478baf913e79d1d3219b513b494943c830850593/gcc%2Ftree-ssa-coalesce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/478baf913e79d1d3219b513b494943c830850593/gcc%2Ftree-ssa-coalesce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-coalesce.c?ref=478baf913e79d1d3219b513b494943c830850593", "patch": "@@ -51,12 +51,40 @@ struct coalesce_pair\n   int second_element;\n   int cost;\n \n+  /* A count of the number of unique partitions this pair would conflict\n+     with if coalescing was successful.  This is the secondary sort key,\n+     given two pairs with equal costs, we will prefer the pair with a smaller\n+     conflict set.\n+\n+     This is lazily initialized when we discover two coalescing pairs have\n+     the same primary cost.\n+\n+     Note this is not updated and propagated as pairs are coalesced.  */\n+  int conflict_count;\n+\n   /* The order in which coalescing pairs are discovered is recorded in this\n      field, which is used as the final tie breaker when sorting coalesce\n      pairs.  */\n   int index;\n };\n \n+/* This represents a conflict graph.  Implemented as an array of bitmaps.\n+   A full matrix is used for conflicts rather than just upper triangular form.\n+   this make sit much simpler and faster to perform conflict merges.  */\n+\n+struct ssa_conflicts\n+{\n+  bitmap_obstack obstack;\t/* A place to allocate our bitmaps.  */\n+  vec<bitmap> conflicts;\n+};\n+\n+/* The narrow API of the qsort comparison function doesn't allow easy\n+   access to additional arguments.  So we have two globals (ick) to hold\n+   the data we need.  They're initialized before the call to qsort and\n+   wiped immediately after.  */\n+static ssa_conflicts *conflicts_;\n+static var_map map_;\n+\n /* Coalesce pair hashtable helpers.  */\n \n struct coalesce_pair_hasher : nofree_ptr_hash <coalesce_pair>\n@@ -303,6 +331,7 @@ find_coalesce_pair (coalesce_list *cl, int p1, int p2, bool create)\n       pair->second_element = p.second_element;\n       pair->cost = 0;\n       pair->index = num_coalesce_pairs (cl);\n+      pair->conflict_count = 0;\n       *slot = pair;\n     }\n \n@@ -345,21 +374,66 @@ add_coalesce (coalesce_list *cl, int p1, int p2, int value)\n     }\n }\n \n+/* Compute and record how many unique conflicts would exist for the\n+   representative partition for each coalesce pair in CL.\n+\n+   CONFLICTS is the conflict graph and MAP is the current partition view.  */\n+\n+static void\n+initialize_conflict_count (coalesce_pair *p,\n+\t\t\t   ssa_conflicts *conflicts,\n+\t\t\t   var_map map)\n+{\n+  int p1 = var_to_partition (map, ssa_name (p->first_element));\n+  int p2 = var_to_partition (map, ssa_name (p->second_element));\n+\n+  /* 4 cases.  If both P1 and P2 have conflicts, then build their\n+     union and count the members.  Else handle the degenerate cases\n+     in the obvious ways.  */\n+  if (conflicts->conflicts[p1] && conflicts->conflicts[p2])\n+    p->conflict_count = bitmap_count_unique_bits (conflicts->conflicts[p1],\n+\t\t\t\t\t\t  conflicts->conflicts[p2]);\n+  else if (conflicts->conflicts[p1])\n+    p->conflict_count = bitmap_count_bits (conflicts->conflicts[p1]);\n+  else if (conflicts->conflicts[p2])\n+    p->conflict_count = bitmap_count_bits (conflicts->conflicts[p2]);\n+  else\n+    p->conflict_count = 0;\n+}\n+\n \n /* Comparison function to allow qsort to sort P1 and P2 in Ascending order.  */\n \n static int\n compare_pairs (const void *p1, const void *p2)\n {\n-  const coalesce_pair *const *const pp1 = (const coalesce_pair *const *) p1;\n-  const coalesce_pair *const *const pp2 = (const coalesce_pair *const *) p2;\n+  coalesce_pair *const *const pp1 = (coalesce_pair *const *) p1;\n+  coalesce_pair *const *const pp2 = (coalesce_pair *const *) p2;\n   int result;\n \n   result = (* pp1)->cost - (* pp2)->cost;\n-  /* And if everything else is equal, then sort based on which\n-     coalesce pair was found first.  */\n+  /* We use the size of the resulting conflict set as the secondary sort key.\n+     Given two equal costing coalesce pairs, we want to prefer the pair that\n+     has the smaller conflict set.  */\n   if (result == 0)\n-    result = (*pp2)->index - (*pp1)->index;\n+    {\n+      if (flag_expensive_optimizations)\n+\t{\n+\t  /* Lazily initialize the conflict counts as it's fairly expensive\n+\t     to compute.  */\n+\t  if ((*pp2)->conflict_count == 0)\n+\t    initialize_conflict_count (*pp2, conflicts_, map_);\n+\t  if ((*pp1)->conflict_count == 0)\n+\t    initialize_conflict_count (*pp1, conflicts_, map_);\n+\n+\t  result = (*pp2)->conflict_count - (*pp1)->conflict_count;\n+\t}\n+\n+      /* And if everything else is equal, then sort based on which\n+\t coalesce pair was found first.  */\n+      if (result == 0)\n+\tresult = (*pp2)->index - (*pp1)->index;\n+    }\n \n   return result;\n }\n@@ -374,7 +448,7 @@ compare_pairs (const void *p1, const void *p2)\n    in order from most important coalesce to least important.  */\n \n static void\n-sort_coalesce_list (coalesce_list *cl)\n+sort_coalesce_list (coalesce_list *cl, ssa_conflicts *conflicts, var_map map)\n {\n   unsigned x, num;\n   coalesce_pair *p;\n@@ -400,19 +474,14 @@ sort_coalesce_list (coalesce_list *cl)\n   if (num == 1)\n     return;\n \n-  /* If there are only 2, just pick swap them if the order isn't correct.  */\n-  if (num == 2)\n-    {\n-      if (cl->sorted[0]->cost > cl->sorted[1]->cost)\n-\tstd::swap (cl->sorted[0], cl->sorted[1]);\n-      return;\n-    }\n-\n-  /* Only call qsort if there are more than 2 items.\n-     ??? Maybe std::sort will do better, provided that compare_pairs\n-     can be inlined.  */\n-  if (num > 2)\n-      qsort (cl->sorted, num, sizeof (coalesce_pair *), compare_pairs);\n+  /* We don't want to depend on qsort_r, so we have to stuff away\n+     additional data into globals so it can be referenced in\n+     compare_pairs.  */\n+  conflicts_ = conflicts;\n+  map_ = map;\n+  qsort (cl->sorted, num, sizeof (coalesce_pair *), compare_pairs);\n+  conflicts_ = NULL;\n+  map_ = NULL;\n }\n \n \n@@ -437,7 +506,7 @@ dump_coalesce_list (FILE *f, coalesce_list *cl)\n \t  print_generic_expr (f, var1, TDF_SLIM);\n \t  fprintf (f, \" <-> \");\n \t  print_generic_expr (f, var2, TDF_SLIM);\n-\t  fprintf (f, \"  (%1d), \", node->cost);\n+\t  fprintf (f, \"  (%1d, %1d), \", node->cost, node->conflict_count);\n \t  fprintf (f, \"\\n\");\n \t}\n     }\n@@ -447,7 +516,7 @@ dump_coalesce_list (FILE *f, coalesce_list *cl)\n       for (x = cl->num_sorted - 1 ; x >=0; x--)\n         {\n \t  node = cl->sorted[x];\n-\t  fprintf (f, \"(%d) \", node->cost);\n+\t  fprintf (f, \"(%d, %d) \", node->cost, node->conflict_count);\n \t  var = ssa_name (node->first_element);\n \t  print_generic_expr (f, var, TDF_SLIM);\n \t  fprintf (f, \" <-> \");\n@@ -459,16 +528,6 @@ dump_coalesce_list (FILE *f, coalesce_list *cl)\n }\n \n \n-/* This represents a conflict graph.  Implemented as an array of bitmaps.\n-   A full matrix is used for conflicts rather than just upper triangular form.\n-   this make sit much simpler and faster to perform conflict merges.  */\n-\n-struct ssa_conflicts\n-{\n-  bitmap_obstack obstack;\t/* A place to allocate our bitmaps.  */\n-  vec<bitmap> conflicts;\n-};\n-\n /* Return an empty new conflict graph for SIZE elements.  */\n \n static inline ssa_conflicts *\n@@ -1800,7 +1859,7 @@ coalesce_ssa_name (void)\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     ssa_conflicts_dump (dump_file, graph);\n \n-  sort_coalesce_list (cl);\n+  sort_coalesce_list (cl, graph, map);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {"}]}