{"sha": "25413fdb2ac24933214123e24ba165026452a6f2", "node_id": "C_kwDOANBUbNoAKDI1NDEzZmRiMmFjMjQ5MzMyMTQxMjNlMjRiYTE2NTAyNjQ1MmE2ZjI", "commit": {"author": {"name": "Andre Vieira", "email": "andre.simoesdiasvieira@arm.com", "date": "2022-10-11T09:49:27Z"}, "committer": {"name": "Andre Vieira", "email": "andre.simoesdiasvieira@arm.com", "date": "2022-10-11T09:49:27Z"}, "message": "vect: Teach vectorizer how to handle bitfield accesses\n\ngcc/ChangeLog:\n\n\t* tree-if-conv.cc (if_convertible_loop_p_1): Move ordering of loop bb's from\n\there...\n\t(tree_if_conversion): ... to here.  Also call bitfield lowering when\n\tappropriate.\n\t(version_loop_for_if_conversion): Adapt to enable loop versioning when we only\n\tneed to lower bitfields.\n\t(ifcvt_split_critical_edges): Relax condition of expected loop form as this is\n\tchecked earlier.\n\t(get_bitfield_rep): New function.\n\t(lower_bitfield): Likewise.\n\t(bitfields_to_lower_p): Likewise.\n\t(need_to_lower_bitfields): New global boolean.\n\t(need_to_ifcvt): Likewise.\n\t* tree-vect-data-refs.cc (vect_find_stmt_data_reference): Improve diagnostic\n\tmessage.\n\t* tree-vect-patterns.cc (vect_recog_temp_ssa_var): Add default value for last\n\tparameter.\n\t(vect_recog_bitfield_ref_pattern): New.\n\t(vect_recog_bit_insert_pattern): New.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/vect/vect-bitfield-read-1.c: New test.\n\t* gcc.dg/vect/vect-bitfield-read-2.c: New test.\n\t* gcc.dg/vect/vect-bitfield-read-3.c: New test.\n\t* gcc.dg/vect/vect-bitfield-read-4.c: New test.\n\t* gcc.dg/vect/vect-bitfield-read-5.c: New test.\n\t* gcc.dg/vect/vect-bitfield-read-6.c: New test.\n\t* gcc.dg/vect/vect-bitfield-write-1.c: New test.\n\t* gcc.dg/vect/vect-bitfield-write-2.c: New test.\n\t* gcc.dg/vect/vect-bitfield-write-3.c: New test.\n\t* gcc.dg/vect/vect-bitfield-write-4.c: New test.\n\t* gcc.dg/vect/vect-bitfield-write-5.c: New test.", "tree": {"sha": "bebdf25b6e50f3f7da4fa924f74ad060dd0395f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bebdf25b6e50f3f7da4fa924f74ad060dd0395f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/25413fdb2ac24933214123e24ba165026452a6f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25413fdb2ac24933214123e24ba165026452a6f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25413fdb2ac24933214123e24ba165026452a6f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25413fdb2ac24933214123e24ba165026452a6f2/comments", "author": {"login": "avieira-arm", "id": 68072104, "node_id": "MDQ6VXNlcjY4MDcyMTA0", "avatar_url": "https://avatars.githubusercontent.com/u/68072104?v=4", "gravatar_id": "", "url": "https://api.github.com/users/avieira-arm", "html_url": "https://github.com/avieira-arm", "followers_url": "https://api.github.com/users/avieira-arm/followers", "following_url": "https://api.github.com/users/avieira-arm/following{/other_user}", "gists_url": "https://api.github.com/users/avieira-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/avieira-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/avieira-arm/subscriptions", "organizations_url": "https://api.github.com/users/avieira-arm/orgs", "repos_url": "https://api.github.com/users/avieira-arm/repos", "events_url": "https://api.github.com/users/avieira-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/avieira-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "avieira-arm", "id": 68072104, "node_id": "MDQ6VXNlcjY4MDcyMTA0", "avatar_url": "https://avatars.githubusercontent.com/u/68072104?v=4", "gravatar_id": "", "url": "https://api.github.com/users/avieira-arm", "html_url": "https://github.com/avieira-arm", "followers_url": "https://api.github.com/users/avieira-arm/followers", "following_url": "https://api.github.com/users/avieira-arm/following{/other_user}", "gists_url": "https://api.github.com/users/avieira-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/avieira-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/avieira-arm/subscriptions", "organizations_url": "https://api.github.com/users/avieira-arm/orgs", "repos_url": "https://api.github.com/users/avieira-arm/repos", "events_url": "https://api.github.com/users/avieira-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/avieira-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "498ad738690b3c464f901d63dcd4d0f49a50dd00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/498ad738690b3c464f901d63dcd4d0f49a50dd00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/498ad738690b3c464f901d63dcd4d0f49a50dd00"}], "stats": {"total": 1110, "additions": 1079, "deletions": 31}, "files": [{"sha": "01cf34fb44484ca926ca5de99eef76dd99b69e92", "filename": "gcc/testsuite/gcc.dg/vect/vect-bitfield-read-1.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25413fdb2ac24933214123e24ba165026452a6f2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-bitfield-read-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25413fdb2ac24933214123e24ba165026452a6f2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-bitfield-read-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-bitfield-read-1.c?ref=25413fdb2ac24933214123e24ba165026452a6f2", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+extern void abort(void);\n+\n+struct s { int i : 31; };\n+\n+#define ELT0 {0}\n+#define ELT1 {1}\n+#define ELT2 {2}\n+#define ELT3 {3}\n+#define N 32\n+#define RES 48\n+struct s A[N]\n+  = { ELT0, ELT1, ELT2, ELT3, ELT0, ELT1, ELT2, ELT3,\n+      ELT0, ELT1, ELT2, ELT3, ELT0, ELT1, ELT2, ELT3,\n+      ELT0, ELT1, ELT2, ELT3, ELT0, ELT1, ELT2, ELT3,\n+      ELT0, ELT1, ELT2, ELT3, ELT0, ELT1, ELT2, ELT3};\n+\n+int __attribute__ ((noipa))\n+f(struct s *ptr, unsigned n) {\n+    int res = 0;\n+    for (int i = 0; i < n; ++i)\n+      res += ptr[i].i;\n+    return res;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  if (f(&A[0], N) != RES)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */"}, {"sha": "1a4a1579c1478b9407ad21b19e8fbdca9f674b42", "filename": "gcc/testsuite/gcc.dg/vect/vect-bitfield-read-2.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25413fdb2ac24933214123e24ba165026452a6f2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-bitfield-read-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25413fdb2ac24933214123e24ba165026452a6f2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-bitfield-read-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-bitfield-read-2.c?ref=25413fdb2ac24933214123e24ba165026452a6f2", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+extern void abort(void);\n+\n+struct s {\n+    unsigned i : 31;\n+    char a : 4;\n+};\n+\n+#define N 32\n+#define ELT0 {0x7FFFFFFFUL, 0}\n+#define ELT1 {0x7FFFFFFFUL, 1}\n+#define ELT2 {0x7FFFFFFFUL, 2}\n+#define ELT3 {0x7FFFFFFFUL, 3}\n+#define RES 48\n+struct s A[N]\n+  = { ELT0, ELT1, ELT2, ELT3, ELT0, ELT1, ELT2, ELT3,\n+      ELT0, ELT1, ELT2, ELT3, ELT0, ELT1, ELT2, ELT3,\n+      ELT0, ELT1, ELT2, ELT3, ELT0, ELT1, ELT2, ELT3,\n+      ELT0, ELT1, ELT2, ELT3, ELT0, ELT1, ELT2, ELT3};\n+\n+int __attribute__ ((noipa))\n+f(struct s *ptr, unsigned n) {\n+    int res = 0;\n+    for (int i = 0; i < n; ++i)\n+      res += ptr[i].a;\n+    return res;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  if (f(&A[0], N) != RES)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */"}, {"sha": "849f4a017e1818eee4abd66385417a326c497696", "filename": "gcc/testsuite/gcc.dg/vect/vect-bitfield-read-3.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25413fdb2ac24933214123e24ba165026452a6f2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-bitfield-read-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25413fdb2ac24933214123e24ba165026452a6f2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-bitfield-read-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-bitfield-read-3.c?ref=25413fdb2ac24933214123e24ba165026452a6f2", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+#include <stdbool.h>\n+\n+extern void abort(void);\n+\n+typedef struct {\n+    int  c;\n+    int  b;\n+    bool a : 1;\n+    int  d : 31;\n+} struct_t;\n+\n+#define N 16\n+#define ELT_F { 0xFFFFFFFF, 0xFFFFFFFF, 0, 0x7FFFFFFF }\n+#define ELT_T { 0xFFFFFFFF, 0xFFFFFFFF, 1, 0x7FFFFFFF }\n+\n+struct_t vect_false[N] = { ELT_F, ELT_F, ELT_F, ELT_F, ELT_F, ELT_F, ELT_F, ELT_F,\n+\t\t\t   ELT_F, ELT_F, ELT_F, ELT_F, ELT_F, ELT_F, ELT_F, ELT_F  };\n+struct_t vect_true[N]  = { ELT_F, ELT_F, ELT_T, ELT_F, ELT_F, ELT_F, ELT_F, ELT_F,\n+\t\t\t   ELT_F, ELT_F, ELT_T, ELT_F, ELT_F, ELT_F, ELT_F, ELT_F  };\n+int main (void)\n+{\n+  unsigned ret = 0;\n+  for (unsigned i = 0; i < N; i++)\n+  {\n+      ret |= vect_false[i].a;\n+  }\n+  if (ret)\n+    abort ();\n+\n+  for (unsigned i = 0; i < N; i++)\n+  {\n+      ret |= vect_true[i].a;\n+  }\n+  if (!ret)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" } } */"}, {"sha": "5bc9c412e9616aefcbf49a4518f1603380a54b2f", "filename": "gcc/testsuite/gcc.dg/vect/vect-bitfield-read-4.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25413fdb2ac24933214123e24ba165026452a6f2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-bitfield-read-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25413fdb2ac24933214123e24ba165026452a6f2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-bitfield-read-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-bitfield-read-4.c?ref=25413fdb2ac24933214123e24ba165026452a6f2", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+extern void abort(void);\n+\n+struct s {\n+    unsigned i : 31;\n+    char x : 2;\n+    char a : 4;\n+};\n+\n+#define N 32\n+#define ELT0 {0x7FFFFFFFUL, 3, 0}\n+#define ELT1 {0x7FFFFFFFUL, 3, 1}\n+#define ELT2 {0x7FFFFFFFUL, 3, 2}\n+#define ELT3 {0x7FFFFFFFUL, 3, 3}\n+#define RES 48\n+struct s A[N]\n+  = { ELT0, ELT1, ELT2, ELT3, ELT0, ELT1, ELT2, ELT3,\n+      ELT0, ELT1, ELT2, ELT3, ELT0, ELT1, ELT2, ELT3,\n+      ELT0, ELT1, ELT2, ELT3, ELT0, ELT1, ELT2, ELT3,\n+      ELT0, ELT1, ELT2, ELT3, ELT0, ELT1, ELT2, ELT3};\n+\n+int __attribute__ ((noipa))\n+f(struct s *ptr, unsigned n) {\n+    int res = 0;\n+    for (int i = 0; i < n; ++i)\n+      res += ptr[i].a;\n+    return res;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  if (f(&A[0], N) != RES)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+"}, {"sha": "1dc24d3eded192144dc9ad94589b4c5c3d999e65", "filename": "gcc/testsuite/gcc.dg/vect/vect-bitfield-read-5.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25413fdb2ac24933214123e24ba165026452a6f2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-bitfield-read-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25413fdb2ac24933214123e24ba165026452a6f2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-bitfield-read-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-bitfield-read-5.c?ref=25413fdb2ac24933214123e24ba165026452a6f2", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+extern void abort(void);\n+\n+struct s {\n+    unsigned a : 23; unsigned b : 9;\n+};\n+\n+#define N 32\n+#define ELT0 {0x7FFFFFUL, 0}\n+#define ELT1 {0x7FFFFFUL, 1}\n+#define ELT2 {0x7FFFFFUL, 2}\n+#define ELT3 {0x7FFFFFUL, 3}\n+#define RES 48\n+struct s A[N]\n+  = { ELT0, ELT1, ELT2, ELT3, ELT0, ELT1, ELT2, ELT3,\n+      ELT0, ELT1, ELT2, ELT3, ELT0, ELT1, ELT2, ELT3,\n+      ELT0, ELT1, ELT2, ELT3, ELT0, ELT1, ELT2, ELT3,\n+      ELT0, ELT1, ELT2, ELT3, ELT0, ELT1, ELT2, ELT3};\n+\n+int __attribute__ ((noipa))\n+f(struct s *ptr, unsigned n) {\n+    int res = 0;\n+    for (int i = 0; i < n; ++i)\n+      res += ptr[i].b;\n+    return res;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  if (f(&A[0], N) != RES)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */"}, {"sha": "7d24c29975865883a7cdc7aa057fbb6bf413e0bc", "filename": "gcc/testsuite/gcc.dg/vect/vect-bitfield-read-6.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25413fdb2ac24933214123e24ba165026452a6f2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-bitfield-read-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25413fdb2ac24933214123e24ba165026452a6f2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-bitfield-read-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-bitfield-read-6.c?ref=25413fdb2ac24933214123e24ba165026452a6f2", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+extern void abort(void);\n+\n+struct s {\n+    unsigned a : 23; unsigned b : 8;\n+};\n+\n+#define N 32\n+#define ELT0 {0x7FFFFFUL, 0}\n+#define ELT1 {0x7FFFFFUL, 1}\n+#define ELT2 {0x7FFFFFUL, 2}\n+#define ELT3 {0x7FFFFFUL, 3}\n+#define RES 48\n+struct s A[N]\n+  = { ELT0, ELT1, ELT2, ELT3, ELT0, ELT1, ELT2, ELT3,\n+      ELT0, ELT1, ELT2, ELT3, ELT0, ELT1, ELT2, ELT3,\n+      ELT0, ELT1, ELT2, ELT3, ELT0, ELT1, ELT2, ELT3,\n+      ELT0, ELT1, ELT2, ELT3, ELT0, ELT1, ELT2, ELT3};\n+\n+int __attribute__ ((noipa))\n+f(struct s *ptr, unsigned n) {\n+    int res = 0;\n+    for (int i = 0; i < n; ++i)\n+      res += ptr[i].b;\n+    return res;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  if (f(&A[0], N) != RES)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */"}, {"sha": "19683d277b1ade1034496136f1d03bb2b446900f", "filename": "gcc/testsuite/gcc.dg/vect/vect-bitfield-write-1.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25413fdb2ac24933214123e24ba165026452a6f2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-bitfield-write-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25413fdb2ac24933214123e24ba165026452a6f2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-bitfield-write-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-bitfield-write-1.c?ref=25413fdb2ac24933214123e24ba165026452a6f2", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+extern void abort(void);\n+\n+struct s { int i : 31; };\n+\n+#define N 32\n+#define V 5\n+struct s A[N];\n+\n+void __attribute__ ((noipa))\n+f(struct s *ptr, unsigned n) {\n+    for (int i = 0; i < n; ++i)\n+      ptr[i].i = V;\n+}\n+\n+void __attribute__ ((noipa))\n+check_f(struct s *ptr) {\n+    for (unsigned i = 0; i < N; ++i)\n+      if (ptr[i].i != V)\n+\tabort ();\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+  __builtin_memset (&A[0], 0, sizeof(struct s) * N);\n+\n+  f(&A[0], N);\n+  check_f (&A[0]);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+"}, {"sha": "d550dd35ab75eb67f6e53f89fbf55b7315e50bc9", "filename": "gcc/testsuite/gcc.dg/vect/vect-bitfield-write-2.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25413fdb2ac24933214123e24ba165026452a6f2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-bitfield-write-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25413fdb2ac24933214123e24ba165026452a6f2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-bitfield-write-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-bitfield-write-2.c?ref=25413fdb2ac24933214123e24ba165026452a6f2", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+extern void abort(void);\n+\n+struct s {\n+    unsigned i : 31;\n+    char a : 4;\n+};\n+\n+#define N 32\n+#define V 5\n+struct s A[N];\n+\n+void __attribute__ ((noipa))\n+f(struct s *ptr, unsigned n) {\n+    for (int i = 0; i < n; ++i)\n+      ptr[i].a = V;\n+}\n+\n+void __attribute__ ((noipa))\n+check_f(struct s *ptr) {\n+    for (unsigned i = 0; i < N; ++i)\n+      if (ptr[i].a != V)\n+\tabort ();\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+  __builtin_memset (&A[0], 0, sizeof(struct s) * N);\n+\n+  f(&A[0], N);\n+  check_f (&A[0]);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+"}, {"sha": "3303d2610ff972d986be172962c129634ee64254", "filename": "gcc/testsuite/gcc.dg/vect/vect-bitfield-write-3.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25413fdb2ac24933214123e24ba165026452a6f2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-bitfield-write-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25413fdb2ac24933214123e24ba165026452a6f2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-bitfield-write-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-bitfield-write-3.c?ref=25413fdb2ac24933214123e24ba165026452a6f2", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+extern void abort(void);\n+\n+struct s {\n+    unsigned i : 31;\n+    char x : 2;\n+    char a : 4;\n+};\n+\n+#define N 32\n+#define V 5\n+struct s A[N];\n+\n+void __attribute__ ((noipa))\n+f(struct s *ptr, unsigned n) {\n+    for (int i = 0; i < n; ++i)\n+      ptr[i].a = V;\n+}\n+\n+void __attribute__ ((noipa))\n+check_f(struct s *ptr) {\n+    for (unsigned i = 0; i < N; ++i)\n+      if (ptr[i].a != V)\n+\tabort ();\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+  __builtin_memset (&A[0], 0, sizeof(struct s) * N);\n+\n+  f(&A[0], N);\n+  check_f (&A[0]);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+"}, {"sha": "fae6ea3557dcaba7b330ebdaa471281d33d2ba15", "filename": "gcc/testsuite/gcc.dg/vect/vect-bitfield-write-4.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25413fdb2ac24933214123e24ba165026452a6f2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-bitfield-write-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25413fdb2ac24933214123e24ba165026452a6f2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-bitfield-write-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-bitfield-write-4.c?ref=25413fdb2ac24933214123e24ba165026452a6f2", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+extern void abort(void);\n+\n+struct s {\n+    unsigned b : 23;\n+    unsigned a : 9;\n+};\n+\n+#define N 32\n+#define V 5\n+struct s A[N];\n+\n+void __attribute__ ((noipa))\n+f(struct s *ptr, unsigned n) {\n+    for (int i = 0; i < n; ++i)\n+      ptr[i].a = V;\n+}\n+\n+void __attribute__ ((noipa))\n+check_f(struct s *ptr) {\n+    for (unsigned i = 0; i < N; ++i)\n+      if (ptr[i].a != V)\n+\tabort ();\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+  __builtin_memset (&A[0], 0, sizeof(struct s) * N);\n+\n+  f(&A[0], N);\n+  check_f (&A[0]);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+"}, {"sha": "99360c2967b076212c67eb4f34b8fd91711d8821", "filename": "gcc/testsuite/gcc.dg/vect/vect-bitfield-write-5.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25413fdb2ac24933214123e24ba165026452a6f2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-bitfield-write-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25413fdb2ac24933214123e24ba165026452a6f2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-bitfield-write-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-bitfield-write-5.c?ref=25413fdb2ac24933214123e24ba165026452a6f2", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+extern void abort(void);\n+\n+struct s {\n+    unsigned b : 23;\n+    unsigned a : 8;\n+};\n+\n+#define N 32\n+#define V 5\n+struct s A[N];\n+\n+void __attribute__ ((noipa))\n+f(struct s *ptr, unsigned n) {\n+    for (int i = 0; i < n; ++i)\n+      ptr[i].a = V;\n+}\n+\n+void __attribute__ ((noipa))\n+check_f(struct s *ptr) {\n+    for (unsigned i = 0; i < N; ++i)\n+      if (ptr[i].a != V)\n+\tabort ();\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+  __builtin_memset (&A[0], 0, sizeof(struct s) * N);\n+\n+  f(&A[0], N);\n+  check_f (&A[0]);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+"}, {"sha": "e468a4659fa28a3a31c3390cf19bee65f4590b80", "filename": "gcc/tree-if-conv.cc", "status": "modified", "additions": 284, "deletions": 29, "changes": 313, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25413fdb2ac24933214123e24ba165026452a6f2/gcc%2Ftree-if-conv.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25413fdb2ac24933214123e24ba165026452a6f2/gcc%2Ftree-if-conv.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.cc?ref=25413fdb2ac24933214123e24ba165026452a6f2", "patch": "@@ -91,6 +91,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pass.h\"\n #include \"ssa.h\"\n #include \"expmed.h\"\n+#include \"expr.h\"\n #include \"optabs-query.h\"\n #include \"gimple-pretty-print.h\"\n #include \"alias.h\"\n@@ -123,6 +124,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-vectorizer.h\"\n #include \"tree-eh.h\"\n \n+/* For lang_hooks.types.type_for_mode.  */\n+#include \"langhooks.h\"\n+\n /* Only handle PHIs with no more arguments unless we are asked to by\n    simd pragma.  */\n #define MAX_PHI_ARG_NUM \\\n@@ -145,6 +149,12 @@ static bool need_to_rewrite_undefined;\n    before phi_convertible_by_degenerating_args.  */\n static bool any_complicated_phi;\n \n+/* True if we have bitfield accesses we can lower.  */\n+static bool need_to_lower_bitfields;\n+\n+/* True if there is any ifcvting to be done.  */\n+static bool need_to_ifcvt;\n+\n /* Hash for struct innermost_loop_behavior.  It depends on the user to\n    free the memory.  */\n \n@@ -1411,15 +1421,6 @@ if_convertible_loop_p_1 (class loop *loop, vec<data_reference_p> *refs)\n \n   calculate_dominance_info (CDI_DOMINATORS);\n \n-  /* Allow statements that can be handled during if-conversion.  */\n-  ifc_bbs = get_loop_body_in_if_conv_order (loop);\n-  if (!ifc_bbs)\n-    {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \"Irreducible loop\\n\");\n-      return false;\n-    }\n-\n   for (i = 0; i < loop->num_nodes; i++)\n     {\n       basic_block bb = ifc_bbs[i];\n@@ -2899,18 +2900,22 @@ version_loop_for_if_conversion (class loop *loop, vec<gimple *> *preds)\n   class loop *new_loop;\n   gimple *g;\n   gimple_stmt_iterator gsi;\n-  unsigned int save_length;\n+  unsigned int save_length = 0;\n \n   g = gimple_build_call_internal (IFN_LOOP_VECTORIZED, 2,\n \t\t\t\t  build_int_cst (integer_type_node, loop->num),\n \t\t\t\t  integer_zero_node);\n   gimple_call_set_lhs (g, cond);\n \n-  /* Save BB->aux around loop_version as that uses the same field.  */\n-  save_length = loop->inner ? loop->inner->num_nodes : loop->num_nodes;\n-  void **saved_preds = XALLOCAVEC (void *, save_length);\n-  for (unsigned i = 0; i < save_length; i++)\n-    saved_preds[i] = ifc_bbs[i]->aux;\n+  void **saved_preds = NULL;\n+  if (any_complicated_phi || need_to_predicate)\n+    {\n+      /* Save BB->aux around loop_version as that uses the same field.  */\n+      save_length = loop->inner ? loop->inner->num_nodes : loop->num_nodes;\n+      saved_preds = XALLOCAVEC (void *, save_length);\n+      for (unsigned i = 0; i < save_length; i++)\n+\tsaved_preds[i] = ifc_bbs[i]->aux;\n+    }\n \n   initialize_original_copy_tables ();\n   /* At this point we invalidate porfile confistency until IFN_LOOP_VECTORIZED\n@@ -2922,8 +2927,9 @@ version_loop_for_if_conversion (class loop *loop, vec<gimple *> *preds)\n \t\t\t   profile_probability::always (), true);\n   free_original_copy_tables ();\n \n-  for (unsigned i = 0; i < save_length; i++)\n-    ifc_bbs[i]->aux = saved_preds[i];\n+  if (any_complicated_phi || need_to_predicate)\n+    for (unsigned i = 0; i < save_length; i++)\n+      ifc_bbs[i]->aux = saved_preds[i];\n \n   if (new_loop == NULL)\n     return NULL;\n@@ -2999,7 +3005,7 @@ ifcvt_split_critical_edges (class loop *loop, bool aggressive_if_conv)\n   auto_vec<edge> critical_edges;\n \n   /* Loop is not well formed.  */\n-  if (num <= 2 || loop->inner || !single_exit (loop))\n+  if (loop->inner)\n     return false;\n \n   body = get_loop_body (loop);\n@@ -3260,6 +3266,201 @@ ifcvt_hoist_invariants (class loop *loop, edge pe)\n   free (body);\n }\n \n+/* Returns the DECL_FIELD_BIT_OFFSET of the bitfield accesse in stmt iff its\n+   type mode is not BLKmode.  If BITPOS is not NULL it will hold the poly_int64\n+   value of the DECL_FIELD_BIT_OFFSET of the bitfield access and STRUCT_EXPR,\n+   if not NULL, will hold the tree representing the base struct of this\n+   bitfield.  */\n+\n+static tree\n+get_bitfield_rep (gassign *stmt, bool write, tree *bitpos,\n+\t\t  tree *struct_expr)\n+{\n+  tree comp_ref = write ? gimple_assign_lhs (stmt)\n+\t\t\t: gimple_assign_rhs1 (stmt);\n+\n+  tree field_decl = TREE_OPERAND (comp_ref, 1);\n+  tree rep_decl = DECL_BIT_FIELD_REPRESENTATIVE (field_decl);\n+\n+  /* Bail out if the representative is BLKmode as we will not be able to\n+     vectorize this.  */\n+  if (TYPE_MODE (TREE_TYPE (rep_decl)) == E_BLKmode)\n+    return NULL_TREE;\n+\n+  /* Bail out if the DECL_SIZE of the field_decl isn't the same as the BF's\n+     precision.  */\n+  unsigned HOST_WIDE_INT bf_prec\n+    = TYPE_PRECISION (TREE_TYPE (gimple_assign_lhs (stmt)));\n+  if (compare_tree_int (DECL_SIZE (field_decl), bf_prec) != 0)\n+    return NULL_TREE;\n+\n+  if (struct_expr)\n+    *struct_expr = TREE_OPERAND (comp_ref, 0);\n+\n+  if (bitpos)\n+    *bitpos\n+      = fold_build2 (MINUS_EXPR, bitsizetype,\n+\t\t     DECL_FIELD_BIT_OFFSET (field_decl),\n+\t\t     DECL_FIELD_BIT_OFFSET (rep_decl));\n+\n+  return rep_decl;\n+\n+}\n+\n+/* Lowers the bitfield described by DATA.\n+   For a write like:\n+\n+   struct.bf = _1;\n+\n+   lower to:\n+\n+   __ifc_1 = struct.<representative>;\n+   __ifc_2 = BIT_INSERT_EXPR (__ifc_1, _1, bitpos);\n+   struct.<representative> = __ifc_2;\n+\n+   For a read:\n+\n+   _1 = struct.bf;\n+\n+    lower to:\n+\n+    __ifc_1 = struct.<representative>;\n+    _1 =  BIT_FIELD_REF (__ifc_1, bitsize, bitpos);\n+\n+    where representative is a legal load that contains the bitfield value,\n+    bitsize is the size of the bitfield and bitpos the offset to the start of\n+    the bitfield within the representative.  */\n+\n+static void\n+lower_bitfield (gassign *stmt, bool write)\n+{\n+  tree struct_expr;\n+  tree bitpos;\n+  tree rep_decl = get_bitfield_rep (stmt, write, &bitpos, &struct_expr);\n+  tree rep_type = TREE_TYPE (rep_decl);\n+  tree bf_type = TREE_TYPE (gimple_assign_lhs (stmt));\n+\n+  gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"Lowering:\\n\");\n+      print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n+      fprintf (dump_file, \"to:\\n\");\n+    }\n+\n+  /* REP_COMP_REF is a COMPONENT_REF for the representative.  NEW_VAL is it's\n+     defining SSA_NAME.  */\n+  tree rep_comp_ref = build3 (COMPONENT_REF, rep_type, struct_expr, rep_decl,\n+\t\t\t      NULL_TREE);\n+  tree new_val = ifc_temp_var (rep_type, rep_comp_ref, &gsi);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    print_gimple_stmt (dump_file, SSA_NAME_DEF_STMT (new_val), 0, TDF_SLIM);\n+\n+  if (write)\n+    {\n+      new_val = ifc_temp_var (rep_type,\n+\t\t\t      build3 (BIT_INSERT_EXPR, rep_type, new_val,\n+\t\t\t\t      unshare_expr (gimple_assign_rhs1 (stmt)),\n+\t\t\t\t      bitpos), &gsi);\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tprint_gimple_stmt (dump_file, SSA_NAME_DEF_STMT (new_val), 0, TDF_SLIM);\n+\n+      gimple *new_stmt = gimple_build_assign (unshare_expr (rep_comp_ref),\n+\t\t\t\t\t      new_val);\n+      gimple_move_vops (new_stmt, stmt);\n+      gsi_insert_before (&gsi, new_stmt, GSI_SAME_STMT);\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tprint_gimple_stmt (dump_file, new_stmt, 0, TDF_SLIM);\n+    }\n+  else\n+    {\n+      tree bfr = build3 (BIT_FIELD_REF, bf_type, new_val,\n+\t\t\t build_int_cst (bitsizetype, TYPE_PRECISION (bf_type)),\n+\t\t\t bitpos);\n+      new_val = ifc_temp_var (bf_type, bfr, &gsi);\n+\n+      gimple *new_stmt = gimple_build_assign (gimple_assign_lhs (stmt),\n+\t\t\t\t\t      new_val);\n+      gimple_move_vops (new_stmt, stmt);\n+      gsi_insert_before (&gsi, new_stmt, GSI_SAME_STMT);\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tprint_gimple_stmt (dump_file, new_stmt, 0, TDF_SLIM);\n+    }\n+\n+  gsi_remove (&gsi, true);\n+}\n+\n+/* Return TRUE if there are bitfields to lower in this LOOP.  Fill TO_LOWER\n+   with data structures representing these bitfields.  */\n+\n+static bool\n+bitfields_to_lower_p (class loop *loop,\n+\t\t      vec <gassign *> &reads_to_lower,\n+\t\t      vec <gassign *> &writes_to_lower)\n+{\n+  gimple_stmt_iterator gsi;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"Analyzing loop %d for bitfields:\\n\", loop->num);\n+    }\n+\n+  for (unsigned i = 0; i < loop->num_nodes; ++i)\n+    {\n+      basic_block bb = ifc_bbs[i];\n+      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t{\n+\t  gassign *stmt = dyn_cast<gassign*> (gsi_stmt (gsi));\n+\t  if (!stmt)\n+\t    continue;\n+\n+\t  tree op = gimple_assign_lhs (stmt);\n+\t  bool write = TREE_CODE (op) == COMPONENT_REF;\n+\n+\t  if (!write)\n+\t    op = gimple_assign_rhs1 (stmt);\n+\n+\t  if (TREE_CODE (op) != COMPONENT_REF)\n+\t    continue;\n+\n+\t  if (DECL_BIT_FIELD_TYPE (TREE_OPERAND (op, 1)))\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tprint_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n+\n+\t      if (!INTEGRAL_TYPE_P (TREE_TYPE (op)))\n+\t\t{\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    fprintf (dump_file, \"\\t Bitfield NO OK to lower,\"\n+\t\t\t\t\t\" field type is not Integral.\\n\");\n+\t\t  return false;\n+\t\t}\n+\n+\t      if (!get_bitfield_rep (stmt, write, NULL, NULL))\n+\t\t{\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    fprintf (dump_file, \"\\t Bitfield NOT OK to lower,\"\n+\t\t\t\t\t\" representative is BLKmode.\\n\");\n+\t\t  return false;\n+\t\t}\n+\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file, \"\\tBitfield OK to lower.\\n\");\n+\t      if (write)\n+\t\twrites_to_lower.safe_push (stmt);\n+\t      else\n+\t\treads_to_lower.safe_push (stmt);\n+\t    }\n+\t}\n+    }\n+  return !reads_to_lower.is_empty () || !writes_to_lower.is_empty ();\n+}\n+\n+\n /* If-convert LOOP when it is legal.  For the moment this pass has no\n    profitability analysis.  Returns non-zero todo flags when something\n    changed.  */\n@@ -3270,12 +3471,16 @@ tree_if_conversion (class loop *loop, vec<gimple *> *preds)\n   unsigned int todo = 0;\n   bool aggressive_if_conv;\n   class loop *rloop;\n+  auto_vec <gassign *, 4> reads_to_lower;\n+  auto_vec <gassign *, 4> writes_to_lower;\n   bitmap exit_bbs;\n   edge pe;\n \n  again:\n   rloop = NULL;\n   ifc_bbs = NULL;\n+  need_to_lower_bitfields = false;\n+  need_to_ifcvt = false;\n   need_to_predicate = false;\n   need_to_rewrite_undefined = false;\n   any_complicated_phi = false;\n@@ -3291,16 +3496,42 @@ tree_if_conversion (class loop *loop, vec<gimple *> *preds)\n \taggressive_if_conv = true;\n     }\n \n-  if (!ifcvt_split_critical_edges (loop, aggressive_if_conv))\n+  if (!single_exit (loop))\n     goto cleanup;\n \n-  if (!if_convertible_loop_p (loop)\n-      || !dbg_cnt (if_conversion_tree))\n+  /* If there are more than two BBs in the loop then there is at least one if\n+     to convert.  */\n+  if (loop->num_nodes > 2\n+      && !ifcvt_split_critical_edges (loop, aggressive_if_conv))\n     goto cleanup;\n \n-  if ((need_to_predicate || any_complicated_phi)\n-      && ((!flag_tree_loop_vectorize && !loop->force_vectorize)\n-\t  || loop->dont_vectorize))\n+  ifc_bbs = get_loop_body_in_if_conv_order (loop);\n+  if (!ifc_bbs)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"Irreducible loop\\n\");\n+      goto cleanup;\n+    }\n+\n+  if (loop->num_nodes > 2)\n+    {\n+      need_to_ifcvt = true;\n+\n+      if (!if_convertible_loop_p (loop) || !dbg_cnt (if_conversion_tree))\n+\tgoto cleanup;\n+\n+      if ((need_to_predicate || any_complicated_phi)\n+\t  && ((!flag_tree_loop_vectorize && !loop->force_vectorize)\n+\t      || loop->dont_vectorize))\n+\tgoto cleanup;\n+    }\n+\n+  if ((flag_tree_loop_vectorize || loop->force_vectorize)\n+      && !loop->dont_vectorize)\n+    need_to_lower_bitfields = bitfields_to_lower_p (loop, reads_to_lower,\n+\t\t\t\t\t\t    writes_to_lower);\n+\n+  if (!need_to_ifcvt && !need_to_lower_bitfields)\n     goto cleanup;\n \n   /* The edge to insert invariant stmts on.  */\n@@ -3311,7 +3542,8 @@ tree_if_conversion (class loop *loop, vec<gimple *> *preds)\n      Either version this loop, or if the pattern is right for outer-loop\n      vectorization, version the outer loop.  In the latter case we will\n      still if-convert the original inner loop.  */\n-  if (need_to_predicate\n+  if (need_to_lower_bitfields\n+      || need_to_predicate\n       || any_complicated_phi\n       || flag_tree_loop_if_convert != 1)\n     {\n@@ -3351,10 +3583,31 @@ tree_if_conversion (class loop *loop, vec<gimple *> *preds)\n \tpe = single_pred_edge (gimple_bb (preds->last ()));\n     }\n \n-  /* Now all statements are if-convertible.  Combine all the basic\n-     blocks into one huge basic block doing the if-conversion\n-     on-the-fly.  */\n-  combine_blocks (loop);\n+  if (need_to_lower_bitfields)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"-------------------------\\n\");\n+\t  fprintf (dump_file, \"Start lowering bitfields\\n\");\n+\t}\n+      while (!reads_to_lower.is_empty ())\n+\tlower_bitfield (reads_to_lower.pop (), false);\n+      while (!writes_to_lower.is_empty ())\n+\tlower_bitfield (writes_to_lower.pop (), true);\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"Done lowering bitfields\\n\");\n+\t  fprintf (dump_file, \"-------------------------\\n\");\n+\t}\n+    }\n+  if (need_to_ifcvt)\n+    {\n+      /* Now all statements are if-convertible.  Combine all the basic\n+\t blocks into one huge basic block doing the if-conversion\n+\t on-the-fly.  */\n+      combine_blocks (loop);\n+    }\n \n   /* Perform local CSE, this esp. helps the vectorizer analysis if loads\n      and stores are involved.  CSE only the loop body, not the entry\n@@ -3394,6 +3647,8 @@ tree_if_conversion (class loop *loop, vec<gimple *> *preds)\n   if (rloop != NULL)\n     {\n       loop = rloop;\n+      reads_to_lower.truncate (0);\n+      writes_to_lower.truncate (0);\n       goto again;\n     }\n "}, {"sha": "4a23d6172aaa12ad7049dc626e5c4afbd5ca3f74", "filename": "gcc/tree-vect-data-refs.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25413fdb2ac24933214123e24ba165026452a6f2/gcc%2Ftree-vect-data-refs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25413fdb2ac24933214123e24ba165026452a6f2/gcc%2Ftree-vect-data-refs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.cc?ref=25413fdb2ac24933214123e24ba165026452a6f2", "patch": "@@ -4302,7 +4302,8 @@ vect_find_stmt_data_reference (loop_p loop, gimple *stmt,\n       free_data_ref (dr);\n       return opt_result::failure_at (stmt,\n \t\t\t\t     \"not vectorized:\"\n-\t\t\t\t     \" statement is bitfield access %G\", stmt);\n+\t\t\t\t     \" statement is an unsupported\"\n+\t\t\t\t     \" bitfield access %G\", stmt);\n     }\n \n   if (DR_BASE_ADDRESS (dr)"}, {"sha": "0cc315d312667c05a27df4cdf435f0d0e6fd4a52", "filename": "gcc/tree-vect-patterns.cc", "status": "modified", "additions": 329, "deletions": 1, "changes": 330, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25413fdb2ac24933214123e24ba165026452a6f2/gcc%2Ftree-vect-patterns.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25413fdb2ac24933214123e24ba165026452a6f2/gcc%2Ftree-vect-patterns.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.cc?ref=25413fdb2ac24933214123e24ba165026452a6f2", "patch": "@@ -35,6 +35,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-eh.h\"\n #include \"gimplify.h\"\n #include \"gimple-iterator.h\"\n+#include \"gimple-fold.h\"\n+#include \"gimplify-me.h\"\n #include \"cfgloop.h\"\n #include \"tree-vectorizer.h\"\n #include \"dumpfile.h\"\n@@ -663,7 +665,7 @@ vect_widened_op_tree (vec_info *vinfo, stmt_vec_info stmt_info, tree_code code,\n    is NULL, the caller must set SSA_NAME_DEF_STMT for the returned SSA var. */\n \n static tree\n-vect_recog_temp_ssa_var (tree type, gimple *stmt)\n+vect_recog_temp_ssa_var (tree type, gimple *stmt = NULL)\n {\n   return make_temp_ssa_name (type, stmt, \"patt\");\n }\n@@ -1829,6 +1831,330 @@ vect_recog_widen_sum_pattern (vec_info *vinfo,\n   return pattern_stmt;\n }\n \n+/* Function vect_recog_bitfield_ref_pattern\n+\n+   Try to find the following pattern:\n+\n+   bf_value = BIT_FIELD_REF (container, bitsize, bitpos);\n+   result = (type_out) bf_value;\n+\n+   where type_out is a non-bitfield type, that is to say, it's precision matches\n+   2^(TYPE_SIZE(type_out) - (TYPE_UNSIGNED (type_out) ? 1 : 2)).\n+\n+   Input:\n+\n+   * STMT_VINFO: The stmt from which the pattern search begins.\n+   here it starts with:\n+   result = (type_out) bf_value;\n+\n+   Output:\n+\n+   * TYPE_OUT: The vector type of the output of this pattern.\n+\n+   * Return value: A new stmt that will be used to replace the sequence of\n+   stmts that constitute the pattern. If the precision of type_out is bigger\n+   than the precision type of _1 we perform the widening before the shifting,\n+   since the new precision will be large enough to shift the value and moving\n+   widening operations up the statement chain enables the generation of\n+   widening loads.  If we are widening and the operation after the pattern is\n+   an addition then we mask first and shift later, to enable the generation of\n+   shifting adds.  In the case of narrowing we will always mask first, shift\n+   last and then perform a narrowing operation.  This will enable the\n+   generation of narrowing shifts.\n+\n+   Widening with mask first, shift later:\n+   container = (type_out) container;\n+   masked = container & (((1 << bitsize) - 1) << bitpos);\n+   result = patt2 >> masked;\n+\n+   Widening with shift first, mask last:\n+   container = (type_out) container;\n+   shifted = container >> bitpos;\n+   result = shifted & ((1 << bitsize) - 1);\n+\n+   Narrowing:\n+   masked = container & (((1 << bitsize) - 1) << bitpos);\n+   result = masked >> bitpos;\n+   result = (type_out) result;\n+\n+   The shifting is always optional depending on whether bitpos != 0.\n+\n+*/\n+\n+static gimple *\n+vect_recog_bitfield_ref_pattern (vec_info *vinfo, stmt_vec_info stmt_info,\n+\t\t\t\t tree *type_out)\n+{\n+  gassign *first_stmt = dyn_cast <gassign *> (stmt_info->stmt);\n+\n+  if (!first_stmt)\n+    return NULL;\n+\n+  gassign *bf_stmt;\n+  if (CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (first_stmt))\n+      && TREE_CODE (gimple_assign_rhs1 (first_stmt)) == SSA_NAME)\n+    {\n+      gimple *second_stmt\n+\t= SSA_NAME_DEF_STMT (gimple_assign_rhs1 (first_stmt));\n+      bf_stmt = dyn_cast <gassign *> (second_stmt);\n+      if (!bf_stmt\n+\t  || gimple_assign_rhs_code (bf_stmt) != BIT_FIELD_REF)\n+\treturn NULL;\n+    }\n+  else\n+    return NULL;\n+\n+  tree bf_ref = gimple_assign_rhs1 (bf_stmt);\n+  tree container = TREE_OPERAND (bf_ref, 0);\n+\n+  if (!bit_field_offset (bf_ref).is_constant ()\n+      || !bit_field_size (bf_ref).is_constant ()\n+      || !tree_fits_uhwi_p (TYPE_SIZE (TREE_TYPE (container))))\n+    return NULL;\n+\n+  if (!INTEGRAL_TYPE_P (TREE_TYPE (bf_ref))\n+      || TYPE_MODE (TREE_TYPE (container)) == E_BLKmode)\n+    return NULL;\n+\n+  gimple *use_stmt, *pattern_stmt;\n+  use_operand_p use_p;\n+  tree ret = gimple_assign_lhs (first_stmt);\n+  tree ret_type = TREE_TYPE (ret);\n+  bool shift_first = true;\n+  tree vectype;\n+\n+  /* If the first operand of the BIT_FIELD_REF is not an INTEGER type, convert\n+     it to one of the same width so we can perform the necessary masking and\n+     shifting.  */\n+  if (!INTEGRAL_TYPE_P (TREE_TYPE (container)))\n+    {\n+      unsigned HOST_WIDE_INT container_size =\n+\ttree_to_uhwi (TYPE_SIZE (TREE_TYPE (container)));\n+      tree int_type = build_nonstandard_integer_type (container_size, true);\n+      pattern_stmt\n+\t= gimple_build_assign (vect_recog_temp_ssa_var (int_type),\n+\t\t\t       VIEW_CONVERT_EXPR, container);\n+      vectype = get_vectype_for_scalar_type (vinfo, int_type);\n+      container = gimple_assign_lhs (pattern_stmt);\n+      append_pattern_def_seq (vinfo, stmt_info, pattern_stmt, vectype);\n+    }\n+  else\n+    vectype = get_vectype_for_scalar_type (vinfo, TREE_TYPE (container));\n+\n+  /* We move the conversion earlier if the loaded type is smaller than the\n+     return type to enable the use of widening loads.  */\n+  if (TYPE_PRECISION (TREE_TYPE (container)) < TYPE_PRECISION (ret_type)\n+      && !useless_type_conversion_p (TREE_TYPE (container), ret_type))\n+    {\n+      pattern_stmt\n+\t= gimple_build_assign (vect_recog_temp_ssa_var (ret_type),\n+\t\t\t       NOP_EXPR, container);\n+      container = gimple_get_lhs (pattern_stmt);\n+      append_pattern_def_seq (vinfo, stmt_info, pattern_stmt);\n+    }\n+  else if (!useless_type_conversion_p (TREE_TYPE (container), ret_type))\n+    /* If we are doing the conversion last then also delay the shift as we may\n+       be able to combine the shift and conversion in certain cases.  */\n+    shift_first = false;\n+\n+  tree container_type = TREE_TYPE (container);\n+\n+  /* If the only use of the result of this BIT_FIELD_REF + CONVERT is a\n+     PLUS_EXPR then do the shift last as some targets can combine the shift and\n+     add into a single instruction.  */\n+  if (single_imm_use (gimple_assign_lhs (first_stmt), &use_p, &use_stmt))\n+    {\n+      if (gimple_code (use_stmt) == GIMPLE_ASSIGN\n+\t  && gimple_assign_rhs_code (use_stmt) == PLUS_EXPR)\n+\tshift_first = false;\n+    }\n+\n+  unsigned HOST_WIDE_INT shift_n = bit_field_offset (bf_ref).to_constant ();\n+  unsigned HOST_WIDE_INT mask_width = bit_field_size (bf_ref).to_constant ();\n+  unsigned HOST_WIDE_INT prec = tree_to_uhwi (TYPE_SIZE (container_type));\n+  if (BYTES_BIG_ENDIAN)\n+    shift_n = prec - shift_n - mask_width;\n+\n+  /* If we don't have to shift we only generate the mask, so just fix the\n+     code-path to shift_first.  */\n+  if (shift_n == 0)\n+    shift_first = true;\n+\n+  tree result;\n+  if (shift_first)\n+    {\n+      tree shifted = container;\n+      if (shift_n)\n+\t{\n+\t  pattern_stmt\n+\t    = gimple_build_assign (vect_recog_temp_ssa_var (container_type),\n+\t\t\t\t   RSHIFT_EXPR, container,\n+\t\t\t\t   build_int_cst (sizetype, shift_n));\n+\t  shifted = gimple_assign_lhs (pattern_stmt);\n+\t  append_pattern_def_seq (vinfo, stmt_info, pattern_stmt, vectype);\n+\t}\n+\n+      tree mask = wide_int_to_tree (container_type,\n+\t\t\t\t    wi::mask (mask_width, false, prec));\n+\n+      pattern_stmt\n+\t= gimple_build_assign (vect_recog_temp_ssa_var (container_type),\n+\t\t\t       BIT_AND_EXPR, shifted, mask);\n+      result = gimple_assign_lhs (pattern_stmt);\n+    }\n+  else\n+    {\n+      tree mask = wide_int_to_tree (container_type,\n+\t\t\t\t    wi::shifted_mask (shift_n, mask_width,\n+\t\t\t\t\t\t      false, prec));\n+      pattern_stmt\n+\t= gimple_build_assign (vect_recog_temp_ssa_var (container_type),\n+\t\t\t       BIT_AND_EXPR, container, mask);\n+      tree masked = gimple_assign_lhs (pattern_stmt);\n+\n+      append_pattern_def_seq (vinfo, stmt_info, pattern_stmt, vectype);\n+      pattern_stmt\n+\t= gimple_build_assign (vect_recog_temp_ssa_var (container_type),\n+\t\t\t       RSHIFT_EXPR, masked,\n+\t\t\t       build_int_cst (sizetype, shift_n));\n+      result = gimple_assign_lhs (pattern_stmt);\n+    }\n+\n+  if (!useless_type_conversion_p (TREE_TYPE (result), ret_type))\n+    {\n+      append_pattern_def_seq (vinfo, stmt_info, pattern_stmt, vectype);\n+      pattern_stmt\n+\t= gimple_build_assign (vect_recog_temp_ssa_var (ret_type),\n+\t\t\t       NOP_EXPR, result);\n+    }\n+\n+  *type_out = STMT_VINFO_VECTYPE (stmt_info);\n+  vect_pattern_detected (\"bitfield_ref pattern\", stmt_info->stmt);\n+\n+  return pattern_stmt;\n+}\n+\n+/* Function vect_recog_bit_insert_pattern\n+\n+   Try to find the following pattern:\n+\n+   written = BIT_INSERT_EXPR (container, value, bitpos);\n+\n+   Input:\n+\n+   * STMT_VINFO: The stmt we want to replace.\n+\n+   Output:\n+\n+   * TYPE_OUT: The vector type of the output of this pattern.\n+\n+   * Return value: A new stmt that will be used to replace the sequence of\n+   stmts that constitute the pattern. In this case it will be:\n+   value = (container_type) value;\t    // Make sure\n+   shifted = value << bitpos;\t\t    // Shift value into place\n+   masked = shifted & (mask << bitpos);\t    // Mask off the non-relevant bits in\n+\t\t\t\t\t    // the 'to-write value'.\n+   cleared = container & ~(mask << bitpos); // Clearing the bits we want to\n+\t\t\t\t\t    // write to from the value we want\n+\t\t\t\t\t    // to write to.\n+   written = cleared | masked;\t\t    // Write bits.\n+\n+\n+   where mask = ((1 << TYPE_PRECISION (value)) - 1), a mask to keep the number of\n+   bits corresponding to the real size of the bitfield value we are writing to.\n+   The shifting is always optional depending on whether bitpos != 0.\n+\n+*/\n+\n+static gimple *\n+vect_recog_bit_insert_pattern (vec_info *vinfo, stmt_vec_info stmt_info,\n+\t\t\t       tree *type_out)\n+{\n+  gassign *bf_stmt = dyn_cast <gassign *> (stmt_info->stmt);\n+  if (!bf_stmt || gimple_assign_rhs_code (bf_stmt) != BIT_INSERT_EXPR)\n+    return NULL;\n+\n+  tree container = gimple_assign_rhs1 (bf_stmt);\n+  tree value = gimple_assign_rhs2 (bf_stmt);\n+  tree shift = gimple_assign_rhs3 (bf_stmt);\n+\n+  tree bf_type = TREE_TYPE (value);\n+  tree container_type = TREE_TYPE (container);\n+\n+  if (!INTEGRAL_TYPE_P (container_type)\n+      || !tree_fits_uhwi_p (TYPE_SIZE (container_type)))\n+    return NULL;\n+\n+  gimple *pattern_stmt;\n+\n+  vect_unpromoted_value unprom;\n+  unprom.set_op (value, vect_internal_def);\n+  value = vect_convert_input (vinfo, stmt_info, container_type, &unprom,\n+\t\t\t      get_vectype_for_scalar_type (vinfo,\n+\t\t\t\t\t\t\t   container_type));\n+\n+  unsigned HOST_WIDE_INT mask_width = TYPE_PRECISION (bf_type);\n+  unsigned HOST_WIDE_INT prec = tree_to_uhwi (TYPE_SIZE (container_type));\n+  unsigned HOST_WIDE_INT shift_n = tree_to_uhwi (shift);\n+  if (BYTES_BIG_ENDIAN)\n+    {\n+      shift_n = prec - shift_n - mask_width;\n+      shift = build_int_cst (TREE_TYPE (shift), shift_n);\n+    }\n+\n+  if (!useless_type_conversion_p (TREE_TYPE (value), container_type))\n+    {\n+      pattern_stmt =\n+\tgimple_build_assign (vect_recog_temp_ssa_var (container_type),\n+\t\t\t     NOP_EXPR, value);\n+      append_pattern_def_seq (vinfo, stmt_info, pattern_stmt);\n+      value = gimple_get_lhs (pattern_stmt);\n+    }\n+\n+  /* Shift VALUE into place.  */\n+  tree shifted = value;\n+  if (shift_n)\n+    {\n+      pattern_stmt\n+\t= gimple_build_assign (vect_recog_temp_ssa_var (container_type),\n+\t\t\t       LSHIFT_EXPR, value, shift);\n+      append_pattern_def_seq (vinfo, stmt_info, pattern_stmt);\n+      shifted = gimple_get_lhs (pattern_stmt);\n+    }\n+\n+  tree mask_t\n+    = wide_int_to_tree (container_type,\n+\t\t\twi::shifted_mask (shift_n, mask_width, false, prec));\n+\n+  /* Clear bits we don't want to write back from SHIFTED.  */\n+  gimple_seq stmts = NULL;\n+  tree masked = gimple_build (&stmts, BIT_AND_EXPR, container_type, shifted,\n+\t\t\t      mask_t);\n+  if (!gimple_seq_empty_p (stmts))\n+    {\n+      pattern_stmt = gimple_seq_first_stmt (stmts);\n+      append_pattern_def_seq (vinfo, stmt_info, pattern_stmt);\n+    }\n+\n+  /* Mask off the bits in the container that we are to write to.  */\n+  mask_t = wide_int_to_tree (container_type,\n+\t\t\t     wi::shifted_mask (shift_n, mask_width, true, prec));\n+  tree cleared = vect_recog_temp_ssa_var (container_type);\n+  pattern_stmt = gimple_build_assign (cleared, BIT_AND_EXPR, container, mask_t);\n+  append_pattern_def_seq (vinfo, stmt_info, pattern_stmt);\n+\n+  /* Write MASKED into CLEARED.  */\n+  pattern_stmt\n+    = gimple_build_assign (vect_recog_temp_ssa_var (container_type),\n+\t\t\t   BIT_IOR_EXPR, cleared, masked);\n+\n+  *type_out = STMT_VINFO_VECTYPE (stmt_info);\n+  vect_pattern_detected (\"bit_insert pattern\", stmt_info->stmt);\n+\n+  return pattern_stmt;\n+}\n+\n+\n /* Recognize cases in which an operation is performed in one type WTYPE\n    but could be done more efficiently in a narrower type NTYPE.  For example,\n    if we have:\n@@ -5622,6 +5948,8 @@ struct vect_recog_func\n    taken which means usually the more complex one needs to preceed the\n    less comples onex (widen_sum only after dot_prod or sad for example).  */\n static vect_recog_func vect_vect_recog_func_ptrs[] = {\n+  { vect_recog_bitfield_ref_pattern, \"bitfield_ref\" },\n+  { vect_recog_bit_insert_pattern, \"bit_insert\" },\n   { vect_recog_over_widening_pattern, \"over_widening\" },\n   /* Must come after over_widening, which narrows the shift as much as\n      possible beforehand.  */"}]}