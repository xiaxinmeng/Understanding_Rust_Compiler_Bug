{"sha": "9f55aee9dca759da84afd4563ff72d3ca8ab8a1c", "node_id": "C_kwDOANBUbNoAKDlmNTVhZWU5ZGNhNzU5ZGE4NGFmZDQ1NjNmZjcyZDNjYThhYjhhMWM", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2022-01-25T18:16:06Z"}, "committer": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2022-06-20T09:11:38Z"}, "message": "Add operators / and * for profile_{count,probability}.\n\ngcc/ChangeLog:\n\n\t* bb-reorder.cc (find_traces_1_round): Add operators / and * and\n\tuse them.\n\t(better_edge_p): Likewise.\n\t* cfgloop.cc (find_subloop_latch_edge_by_profile): Likewise.\n\t* cfgloopmanip.cc (scale_loop_profile): Likewise.\n\t* cfgrtl.cc (force_nonfallthru_and_redirect): Likewise.\n\t* cgraph.cc (cgraph_edge::maybe_hot_p): Likewise.\n\t* config/sh/sh.cc (expand_cbranchdi4): Likewise.\n\t* dojump.cc (do_compare_rtx_and_jump): Likewise.\n\t* final.cc (compute_alignments): Likewise.\n\t* ipa-cp.cc (update_counts_for_self_gen_clones): Likewise.\n\t(decide_about_value): Likewise.\n\t* ipa-inline-analysis.cc (do_estimate_edge_time): Likewise.\n\t* loop-unroll.cc (unroll_loop_runtime_iterations): Likewise.\n\t* modulo-sched.cc (sms_schedule): Likewise.\n\t* omp-expand.cc (extract_omp_for_update_vars): Likewise.\n\t(expand_omp_ordered_sink): Likewise.\n\t(expand_omp_for_ordered_loops): Likewise.\n\t(expand_omp_for_static_nochunk): Likewise.\n\t* predict.cc (maybe_hot_count_p): Likewise.\n\t(probably_never_executed): Likewise.\n\t(set_even_probabilities): Likewise.\n\t(handle_missing_profiles): Likewise.\n\t(expensive_function_p): Likewise.\n\t* profile-count.h: Likewise.\n\t* profile.cc (compute_branch_probabilities): Likewise.\n\t* stmt.cc (emit_case_dispatch_table): Likewise.\n\t* symtab-thunks.cc (expand_thunk): Likewise.\n\t* tree-ssa-loop-manip.cc (tree_transform_and_unroll_loop): Likewise.\n\t* tree-ssa-sink.cc (select_best_block): Likewise.\n\t* tree-switch-conversion.cc (switch_decision_tree::analyze_switch_statement): Likewise.\n\t(switch_decision_tree::balance_case_nodes): Likewise.\n\t(switch_decision_tree::emit_case_nodes): Likewise.\n\t* tree-vect-loop.cc (scale_profile_for_vect_loop): Likewise.", "tree": {"sha": "7414224cafb6e6aed06e7664cfaa3528017aa8d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7414224cafb6e6aed06e7664cfaa3528017aa8d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9f55aee9dca759da84afd4563ff72d3ca8ab8a1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f55aee9dca759da84afd4563ff72d3ca8ab8a1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f55aee9dca759da84afd4563ff72d3ca8ab8a1c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f55aee9dca759da84afd4563ff72d3ca8ab8a1c/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "970b03c0037549a571ecea9afa41de78eb859b3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/970b03c0037549a571ecea9afa41de78eb859b3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/970b03c0037549a571ecea9afa41de78eb859b3a"}], "stats": {"total": 257, "additions": 137, "deletions": 120}, "files": [{"sha": "6600f44d4d744db09228f3d9d0a6006bc6c222b5", "filename": "gcc/bb-reorder.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f55aee9dca759da84afd4563ff72d3ca8ab8a1c/gcc%2Fbb-reorder.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f55aee9dca759da84afd4563ff72d3ca8ab8a1c/gcc%2Fbb-reorder.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.cc?ref=9f55aee9dca759da84afd4563ff72d3ca8ab8a1c", "patch": "@@ -761,7 +761,7 @@ find_traces_1_round (int branch_th, profile_count count_th,\n \t\t\t    & EDGE_CAN_FALLTHRU)\n \t\t\t&& !(single_succ_edge (e->dest)->flags & EDGE_COMPLEX)\n \t\t\t&& single_succ (e->dest) == best_edge->dest\n-\t\t\t&& (e->dest->count.apply_scale (2, 1)\n+\t\t\t&& (e->dest->count * 2\n \t\t\t    >= best_edge->count () || for_size))\n \t\t      {\n \t\t\tbest_edge = e;\n@@ -944,7 +944,7 @@ better_edge_p (const_basic_block bb, const_edge e, profile_probability prob,\n \n   /* The BEST_* values do not have to be best, but can be a bit smaller than\n      maximum values.  */\n-  profile_probability diff_prob = best_prob.apply_scale (1, 10);\n+  profile_probability diff_prob = best_prob / 10;\n \n   /* The smaller one is better to keep the original order.  */\n   if (optimize_function_for_size_p (cfun))\n@@ -966,7 +966,7 @@ better_edge_p (const_basic_block bb, const_edge e, profile_probability prob,\n     is_better_edge = false;\n   else\n     {\n-      profile_count diff_count = best_count.apply_scale (1, 10);\n+      profile_count diff_count = best_count / 10;\n       if (count < best_count - diff_count\n \t  || (!best_count.initialized_p ()\n \t      && count.nonzero_p ()))"}, {"sha": "57bf7b1855d4dd20fb3f42388124932d0ca2b48a", "filename": "gcc/cfgloop.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f55aee9dca759da84afd4563ff72d3ca8ab8a1c/gcc%2Fcfgloop.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f55aee9dca759da84afd4563ff72d3ca8ab8a1c/gcc%2Fcfgloop.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.cc?ref=9f55aee9dca759da84afd4563ff72d3ca8ab8a1c", "patch": "@@ -619,7 +619,7 @@ find_subloop_latch_edge_by_profile (vec<edge> latches)\n     }\n \n   if (!tcount.initialized_p () || !(tcount.ipa () > HEAVY_EDGE_MIN_SAMPLES)\n-      || (tcount - mcount).apply_scale (HEAVY_EDGE_RATIO, 1) > tcount)\n+      || (tcount - mcount) * HEAVY_EDGE_RATIO > tcount)\n     return NULL;\n \n   if (dump_file)"}, {"sha": "db07fd65dc91b45ec56868f478b8c5a0fdfb2268", "filename": "gcc/cfgloopmanip.cc", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f55aee9dca759da84afd4563ff72d3ca8ab8a1c/gcc%2Fcfgloopmanip.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f55aee9dca759da84afd4563ff72d3ca8ab8a1c/gcc%2Fcfgloopmanip.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.cc?ref=9f55aee9dca759da84afd4563ff72d3ca8ab8a1c", "patch": "@@ -563,8 +563,7 @@ scale_loop_profile (class loop *loop, profile_probability p,\n \n \t  /* Probability of exit must be 1/iterations.  */\n \t  count_delta = e->count ();\n-\t  e->probability = profile_probability::always ()\n-\t\t\t\t    .apply_scale (1, iteration_bound);\n+\t  e->probability = profile_probability::always () / iteration_bound;\n \t  other_e->probability = e->probability.invert ();\n \n \t  /* In code below we only handle the following two updates.  */\n@@ -586,7 +585,7 @@ scale_loop_profile (class loop *loop, profile_probability p,\n \t we look at the actual profile, if it is available.  */\n       p = profile_probability::always ();\n \n-      count_in = count_in.apply_scale (iteration_bound, 1);\n+      count_in *= iteration_bound;\n       p = count_in.probability_in (loop->header->count);\n       if (!(p > profile_probability::never ()))\n \tp = profile_probability::very_unlikely ();"}, {"sha": "afbdbfe3450a7400adacaaef96b95596027537af", "filename": "gcc/cfgrtl.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f55aee9dca759da84afd4563ff72d3ca8ab8a1c/gcc%2Fcfgrtl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f55aee9dca759da84afd4563ff72d3ca8ab8a1c/gcc%2Fcfgrtl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.cc?ref=9f55aee9dca759da84afd4563ff72d3ca8ab8a1c", "patch": "@@ -1686,8 +1686,8 @@ force_nonfallthru_and_redirect (edge e, basic_block target, rtx jump_label)\n \t add also edge from asm goto bb to target.  */\n       if (asm_goto_edge)\n \t{\n-\t  new_edge->probability = new_edge->probability.apply_scale (1, 2);\n-\t  jump_block->count = jump_block->count.apply_scale (1, 2);\n+\t  new_edge->probability /= 2;\n+\t  jump_block->count /= 2;\n \t  edge new_edge2 = make_edge (new_edge->src, target,\n \t\t\t\t      e->flags & ~EDGE_FALLTHRU);\n \t  new_edge2->probability = probability - new_edge->probability;"}, {"sha": "7eeda53ca8472afe3512a543697ebccff657703f", "filename": "gcc/cgraph.cc", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f55aee9dca759da84afd4563ff72d3ca8ab8a1c/gcc%2Fcgraph.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f55aee9dca759da84afd4563ff72d3ca8ab8a1c/gcc%2Fcgraph.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.cc?ref=9f55aee9dca759da84afd4563ff72d3ca8ab8a1c", "patch": "@@ -2935,11 +2935,10 @@ cgraph_edge::maybe_hot_p (void)\n     return false;\n   if (caller->frequency == NODE_FREQUENCY_EXECUTED_ONCE)\n     {\n-      if (count.apply_scale (2, 1) < where->count.apply_scale (3, 1))\n+      if (count * 2 < where->count * 3)\n \treturn false;\n     }\n-  else if (count.apply_scale (param_hot_bb_frequency_fraction , 1)\n-\t   < where->count)\n+  else if (count * param_hot_bb_frequency_fraction < where->count)\n     return false;\n   return true;\n }"}, {"sha": "9bee618b639f611b4b7ffdcd7700093124ab5bd0", "filename": "gcc/config/sh/sh.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f55aee9dca759da84afd4563ff72d3ca8ab8a1c/gcc%2Fconfig%2Fsh%2Fsh.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f55aee9dca759da84afd4563ff72d3ca8ab8a1c/gcc%2Fconfig%2Fsh%2Fsh.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.cc?ref=9f55aee9dca759da84afd4563ff72d3ca8ab8a1c", "patch": "@@ -2178,7 +2178,7 @@ expand_cbranchdi4 (rtx *operands, enum rtx_code comparison)\n \t  && prob.to_reg_br_prob_base () >= (int) (REG_BR_PROB_BASE * 3 / 8U)\n \t  && prob.to_reg_br_prob_base () <= (int) (REG_BR_PROB_BASE * 5 / 8U))\n \t{\n-\t  msw_taken_prob = prob.apply_scale (1, 2);\n+\t  msw_taken_prob = prob / 2;\n \t  msw_skip_prob = rev_prob.apply_scale (REG_BR_PROB_BASE,\n \t\t\t\t\t\trev_prob.to_reg_br_prob_base ()\n \t\t\t\t\t\t+ REG_BR_PROB_BASE);"}, {"sha": "2af0cd1aca3b6af13d5d8799094ee93f18022296", "filename": "gcc/dojump.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f55aee9dca759da84afd4563ff72d3ca8ab8a1c/gcc%2Fdojump.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f55aee9dca759da84afd4563ff72d3ca8ab8a1c/gcc%2Fdojump.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.cc?ref=9f55aee9dca759da84afd4563ff72d3ca8ab8a1c", "patch": "@@ -1131,7 +1131,7 @@ do_compare_rtx_and_jump (rtx op0, rtx op1, enum rtx_code code, int unsignedp,\n \t      profile_probability cprob\n \t\t= profile_probability::guessed_always ();\n \t      if (first_code == UNORDERED)\n-\t\tcprob = cprob.apply_scale (1, 100);\n+\t\tcprob /= 100;\n \t      else if (first_code == ORDERED)\n \t\tcprob = cprob.apply_scale (99, 100);\n \t      else"}, {"sha": "c5427d2110d79dc11bf61fb170ac83e46be10d3b", "filename": "gcc/final.cc", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f55aee9dca759da84afd4563ff72d3ca8ab8a1c/gcc%2Ffinal.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f55aee9dca759da84afd4563ff72d3ca8ab8a1c/gcc%2Ffinal.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.cc?ref=9f55aee9dca759da84afd4563ff72d3ca8ab8a1c", "patch": "@@ -642,8 +642,7 @@ compute_alignments (void)\n       flow_loops_dump (dump_file, NULL, 1);\n     }\n   loop_optimizer_init (AVOID_CFG_MODIFICATIONS);\n-  profile_count count_threshold = cfun->cfg->count_max.apply_scale\n-\t\t (1, param_align_threshold);\n+  profile_count count_threshold = cfun->cfg->count_max / param_align_threshold;\n \n   if (dump_file)\n     {\n@@ -710,10 +709,9 @@ compute_alignments (void)\n \n       if (!has_fallthru\n \t  && (branch_count > count_threshold\n-\t      || (bb->count > bb->prev_bb->count.apply_scale (10, 1)\n+\t      || (bb->count > bb->prev_bb->count * 10\n \t\t  && (bb->prev_bb->count\n-\t\t      <= ENTRY_BLOCK_PTR_FOR_FN (cfun)\n-\t\t\t   ->count.apply_scale (1, 2)))))\n+\t\t      <= ENTRY_BLOCK_PTR_FOR_FN (cfun)->count / 2))))\n \t{\n \t  align_flags alignment = JUMP_ALIGN (label);\n \t  if (dump_file)\n@@ -727,9 +725,7 @@ compute_alignments (void)\n \t       && single_succ (bb) == EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t  && optimize_bb_for_speed_p (bb)\n \t  && branch_count + fallthru_count > count_threshold\n-\t  && (branch_count\n-\t      > fallthru_count.apply_scale\n-\t\t    (param_align_loop_iterations, 1)))\n+\t  && (branch_count > fallthru_count * param_align_loop_iterations))\n \t{\n \t  align_flags alignment = LOOP_ALIGN (label);\n \t  if (dump_file)"}, {"sha": "f26bfcc4ee09684f9de7c692a526df85f821bcd3", "filename": "gcc/ipa-cp.cc", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f55aee9dca759da84afd4563ff72d3ca8ab8a1c/gcc%2Fipa-cp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f55aee9dca759da84afd4563ff72d3ca8ab8a1c/gcc%2Fipa-cp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.cc?ref=9f55aee9dca759da84afd4563ff72d3ca8ab8a1c", "patch": "@@ -4652,8 +4652,7 @@ update_counts_for_self_gen_clones (cgraph_node *orig_node,\n     {\n       profile_count orig_count = n->count;\n       profile_count new_count\n-\t= (redist_sum.apply_scale (1, self_gen_clones.length ())\n-\t   + other_edges_count[i]);\n+\t= (redist_sum / self_gen_clones.length () + other_edges_count[i]);\n       new_count = lenient_count_portion_handling (new_count, orig_node);\n       n->count = new_count;\n       profile_count::adjust_for_ipa_scaling (&new_count, &orig_count);\n@@ -4685,7 +4684,7 @@ update_counts_for_self_gen_clones (cgraph_node *orig_node,\n \t    for (cgraph_edge *e = cs; e; e = get_next_cgraph_edge_clone (e))\n \t      if (e->callee->ultimate_alias_target () == orig_node\n \t\t  && processed_edges.contains (e))\n-\t\te->count = e->count.apply_scale (1, den);\n+\t\te->count /= den;\n \t}\n     }\n \n@@ -4713,8 +4712,7 @@ update_counts_for_self_gen_clones (cgraph_node *orig_node,\n \t      && desc.unproc_orig_rec_edges > 0)\n \t    {\n \t      desc.count = n->count - desc.count;\n-\t      desc.count\n-\t\t= desc.count.apply_scale (1, desc.unproc_orig_rec_edges);\n+\t      desc.count = desc.count /= desc.unproc_orig_rec_edges;\n \t      adjust_clone_incoming_counts (n, &desc);\n \t    }\n \t  else if (dump_file)\n@@ -6084,7 +6082,7 @@ decide_about_value (struct cgraph_node *node, int index, HOST_WIDE_INT offset,\n       if (node->count.ipa ().nonzero_p ())\n \t{\n \t  unsigned dem = self_gen_clones->length () + 1;\n-\t  rec_count_sum = node->count.ipa ().apply_scale (1, dem);\n+\t  rec_count_sum = node->count.ipa () / dem;\n \t}\n       else\n \trec_count_sum = profile_count::zero ();"}, {"sha": "1ca685d1b0ee679fdeeb95ca05e147206b5c82f9", "filename": "gcc/ipa-inline-analysis.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f55aee9dca759da84afd4563ff72d3ca8ab8a1c/gcc%2Fipa-inline-analysis.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f55aee9dca759da84afd4563ff72d3ca8ab8a1c/gcc%2Fipa-inline-analysis.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.cc?ref=9f55aee9dca759da84afd4563ff72d3ca8ab8a1c", "patch": "@@ -254,7 +254,7 @@ do_estimate_edge_time (struct cgraph_edge *edge, sreal *ret_nonspec_time)\n      probability that caller will call the callee is low however, since it\n      may hurt optimization of the caller's hot path.  */\n   if (edge->count.ipa ().initialized_p () && edge->maybe_hot_p ()\n-      && (edge->count.ipa ().apply_scale (2, 1)\n+      && (edge->count.ipa () * 2\n \t  > (edge->caller->inlined_to\n \t     ? edge->caller->inlined_to->count.ipa ()\n \t     : edge->caller->count.ipa ())))"}, {"sha": "1956c54609c36a2bd239614ba74e5db1270512c2", "filename": "gcc/loop-unroll.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f55aee9dca759da84afd4563ff72d3ca8ab8a1c/gcc%2Floop-unroll.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f55aee9dca759da84afd4563ff72d3ca8ab8a1c/gcc%2Floop-unroll.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.cc?ref=9f55aee9dca759da84afd4563ff72d3ca8ab8a1c", "patch": "@@ -978,7 +978,7 @@ unroll_loop_runtime_iterations (class loop *loop)\n   /* Compute count increments for each switch block and initialize\n      innermost switch block.  Switch blocks and peeled loop copies are built\n      from innermost outward.  */\n-  iter_count = new_count = swtch->count.apply_scale (1, max_unroll + 1);\n+  iter_count = new_count = swtch->count / (max_unroll + 1);\n   swtch->count = new_count;\n \n   for (i = 0; i < n_peel; i++)\n@@ -995,7 +995,7 @@ unroll_loop_runtime_iterations (class loop *loop)\n \n       /* Create item for switch.  */\n       unsigned j = n_peel - i - (extra_zero_check ? 0 : 1);\n-      p = profile_probability::always ().apply_scale (1, i + 2);\n+      p = profile_probability::always () / (i + 2);\n \n       preheader = split_edge (loop_preheader_edge (loop));\n       /* Add in count of edge from switch block.  */\n@@ -1021,12 +1021,12 @@ unroll_loop_runtime_iterations (class loop *loop)\n   if (extra_zero_check)\n     {\n       /* Add branch for zero iterations.  */\n-      p = profile_probability::always ().apply_scale (1, max_unroll + 1);\n+      p = profile_probability::always () / (max_unroll + 1);\n       swtch = ezc_swtch;\n       preheader = split_edge (loop_preheader_edge (loop));\n       /* Recompute count adjustments since initial peel copy may\n \t have exited and reduced those values that were computed above.  */\n-      iter_count = swtch->count.apply_scale (1, max_unroll + 1);\n+      iter_count = swtch->count / (max_unroll + 1);\n       /* Add in count of edge from switch block.  */\n       preheader->count += iter_count;\n       branch_code = compare_and_jump_seq (copy_rtx (niter), const0_rtx, EQ,"}, {"sha": "2c95c0995ee3ed6aa10a45bc41625e435f08c7b1", "filename": "gcc/modulo-sched.cc", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f55aee9dca759da84afd4563ff72d3ca8ab8a1c/gcc%2Fmodulo-sched.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f55aee9dca759da84afd4563ff72d3ca8ab8a1c/gcc%2Fmodulo-sched.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.cc?ref=9f55aee9dca759da84afd4563ff72d3ca8ab8a1c", "patch": "@@ -1439,10 +1439,10 @@ sms_schedule (void)\n \n       /* Perform SMS only on loops that their average count is above threshold.  */\n \n-      if ( latch_edge->count () > profile_count::zero ()\n-          && (latch_edge->count()\n-\t      < single_exit (loop)->count ().apply_scale\n-\t\t\t\t (param_sms_loop_average_count_threshold, 1)))\n+      if (latch_edge->count () > profile_count::zero ()\n+\t  && (latch_edge->count ()\n+\t      < (single_exit (loop)->count ()\n+\t\t * param_sms_loop_average_count_threshold)))\n \t{\n \t  if (dump_file)\n \t    {\n@@ -1464,12 +1464,12 @@ sms_schedule (void)\n         }\n \n       /* Make sure this is a doloop.  */\n-      if ( !(count_reg = doloop_register_get (head, tail)))\n-      {\n-        if (dump_file)\n-          fprintf (dump_file, \"SMS doloop_register_get failed\\n\");\n-\tcontinue;\n-      }\n+      if (!(count_reg = doloop_register_get (head, tail)))\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"SMS doloop_register_get failed\\n\");\n+\t  continue;\n+\t}\n \n       /* Don't handle BBs with calls or barriers\n \t or !single_set with the exception of do-loop control part insns."}, {"sha": "2572957f72e22b6a508e217103b7751709b2718d", "filename": "gcc/omp-expand.cc", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f55aee9dca759da84afd4563ff72d3ca8ab8a1c/gcc%2Fomp-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f55aee9dca759da84afd4563ff72d3ca8ab8a1c/gcc%2Fomp-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-expand.cc?ref=9f55aee9dca759da84afd4563ff72d3ca8ab8a1c", "patch": "@@ -3120,8 +3120,7 @@ extract_omp_for_update_vars (struct omp_for_data *fd, tree *nonrect_bounds,\n       if (i < fd->collapse - 1)\n \t{\n \t  e = make_edge (last_bb, bb, EDGE_FALSE_VALUE);\n-\t  e->probability\n-\t    = profile_probability::guessed_always ().apply_scale (1, 8);\n+\t  e->probability = profile_probability::guessed_always () / 8;\n \n \t  struct omp_for_data_loop *l = &fd->loops[i + 1];\n \t  if (l->m1 == NULL_TREE || l->outer != 1)\n@@ -3240,8 +3239,7 @@ extract_omp_for_update_vars (struct omp_for_data *fd, tree *nonrect_bounds,\n \t\tif (update_bb == NULL)\n \t\t  update_bb = this_bb;\n \t\te = make_edge (this_bb, bb, EDGE_FALSE_VALUE);\n-\t\te->probability\n-\t\t  = profile_probability::guessed_always ().apply_scale (1, 8);\n+\t\te->probability = profile_probability::guessed_always () / 8;\n \t\tif (prev_bb == NULL)\n \t\t  set_immediate_dominator (CDI_DOMINATORS, this_bb, bb);\n \t\tprev_bb = this_bb;\n@@ -3533,7 +3531,7 @@ expand_omp_ordered_sink (gimple_stmt_iterator *gsi, struct omp_for_data *fd,\n \t\t\t\t   GSI_CONTINUE_LINKING);\n   gsi_insert_after (gsi, gimple_build_cond_empty (cond), GSI_NEW_STMT);\n   edge e3 = make_edge (e1->src, e2->dest, EDGE_FALSE_VALUE);\n-  e3->probability = profile_probability::guessed_always ().apply_scale (1, 8);\n+  e3->probability = profile_probability::guessed_always () / 8;\n   e1->probability = e3->probability.invert ();\n   e1->flags = EDGE_TRUE_VALUE;\n   set_immediate_dominator (CDI_DOMINATORS, e2->dest, e1->src);\n@@ -3687,7 +3685,7 @@ expand_omp_for_ordered_loops (struct omp_for_data *fd, tree *counts,\n       remove_edge (e1);\n       make_edge (body_bb, new_header, EDGE_FALLTHRU);\n       e3->flags = EDGE_FALSE_VALUE;\n-      e3->probability = profile_probability::guessed_always ().apply_scale (1, 8);\n+      e3->probability = profile_probability::guessed_always () / 8;\n       e1 = make_edge (new_header, new_body, EDGE_TRUE_VALUE);\n       e1->probability = e3->probability.invert ();\n \n@@ -5484,16 +5482,14 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n   ep->probability = profile_probability::guessed_always ().apply_scale (3, 4);\n   ep = find_edge (entry_bb, second_bb);\n   ep->flags = EDGE_TRUE_VALUE;\n-  ep->probability = profile_probability::guessed_always ().apply_scale (1, 4);\n+  ep->probability = profile_probability::guessed_always () / 4;\n   if (fourth_bb)\n     {\n       ep = make_edge (third_bb, fifth_bb, EDGE_FALSE_VALUE);\n-      ep->probability\n-\t= profile_probability::guessed_always ().apply_scale (1, 2);\n+      ep->probability = profile_probability::guessed_always () / 2;\n       ep = find_edge (third_bb, fourth_bb);\n       ep->flags = EDGE_TRUE_VALUE;\n-      ep->probability\n-\t= profile_probability::guessed_always ().apply_scale (1, 2);\n+      ep->probability = profile_probability::guessed_always () / 2;\n       ep = find_edge (fourth_bb, fifth_bb);\n       redirect_edge_and_branch (ep, sixth_bb);\n     }\n@@ -5504,12 +5500,10 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n   if (exit1_bb)\n     {\n       ep = make_edge (exit_bb, exit2_bb, EDGE_FALSE_VALUE);\n-      ep->probability\n-\t= profile_probability::guessed_always ().apply_scale (1, 2);\n+      ep->probability = profile_probability::guessed_always () / 2;\n       ep = find_edge (exit_bb, exit1_bb);\n       ep->flags = EDGE_TRUE_VALUE;\n-      ep->probability\n-\t= profile_probability::guessed_always ().apply_scale (1, 2);\n+      ep->probability = profile_probability::guessed_always () / 2;\n       ep = find_edge (exit1_bb, exit2_bb);\n       redirect_edge_and_branch (ep, exit3_bb);\n     }"}, {"sha": "62da149e2b6939c6c8cbbff97bd390ecd3598de9", "filename": "gcc/predict.cc", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f55aee9dca759da84afd4563ff72d3ca8ab8a1c/gcc%2Fpredict.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f55aee9dca759da84afd4563ff72d3ca8ab8a1c/gcc%2Fpredict.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.cc?ref=9f55aee9dca759da84afd4563ff72d3ca8ab8a1c", "patch": "@@ -172,7 +172,7 @@ maybe_hot_count_p (struct function *fun, profile_count count)\n       if (node->frequency == NODE_FREQUENCY_EXECUTED_ONCE\n \t  && count < (ENTRY_BLOCK_PTR_FOR_FN (fun)->count.apply_scale (2, 3)))\n \treturn false;\n-      if (count.apply_scale (param_hot_bb_frequency_fraction, 1)\n+      if (count * param_hot_bb_frequency_fraction\n \t  < ENTRY_BLOCK_PTR_FOR_FN (fun)->count)\n \treturn false;\n       return true;\n@@ -219,7 +219,7 @@ probably_never_executed (struct function *fun, profile_count count)\n   if (count.precise_p () && profile_status_for_fn (fun) == PROFILE_READ)\n     {\n       const int unlikely_frac = param_unlikely_bb_count_fraction;\n-      if (count.apply_scale (unlikely_frac, 1) >= profile_info->runs)\n+      if (count * unlikely_frac >= profile_info->runs)\n \treturn false;\n       return true;\n     }\n@@ -916,12 +916,12 @@ set_even_probabilities (basic_block bb,\n \t    else\n \t      {\n \t\tprofile_probability remainder = prob.invert ();\n-\t\tremainder -= profile_probability::very_unlikely ()\n-\t\t  .apply_scale (unlikely_count, 1);\n+\t\tremainder -= (profile_probability::very_unlikely ()\n+\t\t\t      * unlikely_count);\n \t\tint count = nedges - unlikely_count - 1;\n \t\tgcc_assert (count >= 0);\n \n-\t\te->probability = remainder.apply_scale (1, count);\n+\t\te->probability = remainder / count;\n \t      }\n \t  }\n \telse\n@@ -940,7 +940,7 @@ set_even_probabilities (basic_block bb,\n \t    if (unlikely_edges != NULL && unlikely_edges->contains (e))\n \t      e->probability = profile_probability::very_unlikely ();\n \t    else\n-\t      e->probability = all.apply_scale (1, scale);\n+\t      e->probability = all / scale;\n \t  }\n \telse\n \t  e->probability = profile_probability::never ();\n@@ -3619,7 +3619,7 @@ handle_missing_profiles (void)\n \n       if (call_count > 0\n           && fn && fn->cfg\n-          && call_count.apply_scale (unlikely_frac, 1) >= profile_info->runs)\n+\t  && call_count * unlikely_frac >= profile_info->runs)\n         {\n           drop_profile (node, call_count);\n           worklist.safe_push (node);\n@@ -3684,8 +3684,7 @@ expensive_function_p (int threshold)\n   if (!ENTRY_BLOCK_PTR_FOR_FN (cfun)->count.nonzero_p ())\n     return true;\n \n-  profile_count limit = ENTRY_BLOCK_PTR_FOR_FN\n-\t\t\t   (cfun)->count.apply_scale (threshold, 1);\n+  profile_count limit = ENTRY_BLOCK_PTR_FOR_FN (cfun)->count * threshold;\n   profile_count sum = profile_count::zero ();\n   FOR_EACH_BB_FN (bb, cfun)\n     {"}, {"sha": "be6e2d57cf7a2c43ba56b932669a02d200471221", "filename": "gcc/profile-count.h", "status": "modified", "additions": 43, "deletions": 3, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f55aee9dca759da84afd4563ff72d3ca8ab8a1c/gcc%2Fprofile-count.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f55aee9dca759da84afd4563ff72d3ca8ab8a1c/gcc%2Fprofile-count.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile-count.h?ref=9f55aee9dca759da84afd4563ff72d3ca8ab8a1c", "patch": "@@ -185,22 +185,22 @@ class GTY((user)) profile_probability\n   static profile_probability very_unlikely ()\n     {\n       /* Be consistent with PROB_VERY_UNLIKELY in predict.h.  */\n-      profile_probability r = guessed_always ().apply_scale (1, 2000);\n+      profile_probability r = guessed_always () / 2000;\n       r.m_val--;\n       return r;\n     }\n \n   static profile_probability unlikely ()\n     {\n       /* Be consistent with PROB_VERY_LIKELY in predict.h.  */\n-      profile_probability r = guessed_always ().apply_scale (1, 5);\n+      profile_probability r = guessed_always () / 5;\n       r.m_val--;\n       return r;\n     }\n \n   static profile_probability even ()\n     {\n-      return guessed_always ().apply_scale (1, 2);\n+      return guessed_always () / 2;\n     }\n \n   static profile_probability very_likely ()\n@@ -600,6 +600,26 @@ class GTY((user)) profile_probability\n       return initialized_p () && other.initialized_p () && m_val >= other.m_val;\n     }\n \n+  profile_probability operator* (int64_t num) const\n+    {\n+      return apply_scale (num, 1);\n+    }\n+\n+  profile_probability operator*= (int64_t den) const\n+    {\n+      return *this * den;\n+    }\n+\n+  profile_probability operator/ (int64_t den) const\n+    {\n+      return apply_scale (1, den);\n+    }\n+\n+  profile_probability operator/= (int64_t den) const\n+    {\n+      return *this / den;\n+    }\n+\n   /* Get the value of the count.  */\n   uint32_t value () const { return m_val; }\n \n@@ -992,6 +1012,26 @@ struct GTY(()) profile_count\n       return ipa ().initialized_p () && ipa ().m_val >= (uint64_t) other;\n     }\n \n+  profile_count operator* (int64_t num) const\n+    {\n+      return apply_scale (num, 1);\n+    }\n+\n+  profile_count operator*= (int64_t den) const\n+    {\n+      return *this * den;\n+    }\n+\n+  profile_count operator/ (int64_t den) const\n+    {\n+      return apply_scale (1, den);\n+    }\n+\n+  profile_count operator/= (int64_t den) const\n+    {\n+      return *this / den;\n+    }\n+\n   /* Return true when value is not zero and can be used for scaling. \n      This is different from *this > 0 because that requires counter to\n      be IPA.  */"}, {"sha": "08af512cbcae392fca19d0f8b7283561bb7f51a4", "filename": "gcc/profile.cc", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f55aee9dca759da84afd4563ff72d3ca8ab8a1c/gcc%2Fprofile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f55aee9dca759da84afd4563ff72d3ca8ab8a1c/gcc%2Fprofile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.cc?ref=9f55aee9dca759da84afd4563ff72d3ca8ab8a1c", "patch": "@@ -716,16 +716,15 @@ compute_branch_probabilities (unsigned cfg_checksum, unsigned lineno_checksum)\n \t      FOR_EACH_EDGE (e, ei, bb->succs)\n \t\tif (!(e->flags & (EDGE_COMPLEX | EDGE_FAKE)))\n \t\t  e->probability\n-\t\t    = profile_probability::guessed_always ().apply_scale (1, total);\n+\t\t    = profile_probability::guessed_always () / total;\n \t\telse\n \t\t  e->probability = profile_probability::never ();\n \t    }\n \t  else\n \t    {\n \t      total += EDGE_COUNT (bb->succs);\n \t      FOR_EACH_EDGE (e, ei, bb->succs)\n-\t\te->probability\n-\t\t = profile_probability::guessed_always ().apply_scale (1, total);\n+\t\te->probability = profile_probability::guessed_always () / total;\n \t    }\n \t  if (bb->index >= NUM_FIXED_BLOCKS\n \t      && block_ends_with_condjump_p (bb)"}, {"sha": "11cc70f0013ff874672d7446f8808a65b87ba02c", "filename": "gcc/stmt.cc", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f55aee9dca759da84afd4563ff72d3ca8ab8a1c/gcc%2Fstmt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f55aee9dca759da84afd4563ff72d3ca8ab8a1c/gcc%2Fstmt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.cc?ref=9f55aee9dca759da84afd4563ff72d3ca8ab8a1c", "patch": "@@ -822,9 +822,8 @@ emit_case_dispatch_table (tree index_expr, tree index_type,\n          through the indirect jump or the direct conditional jump\n          before that. Split the probability of reaching the\n          default label among these two jumps.  */\n-      new_default_prob\n-\t= conditional_probability (default_prob.apply_scale (1, 2), base);\n-      default_prob = default_prob.apply_scale (1, 2);\n+      new_default_prob = conditional_probability (default_prob / 2, base);\n+      default_prob /= 2;\n       base -= default_prob;\n     }\n   else"}, {"sha": "b04397022303d74c41d0662aae862a12ef3b0ac7", "filename": "gcc/symtab-thunks.cc", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f55aee9dca759da84afd4563ff72d3ca8ab8a1c/gcc%2Fsymtab-thunks.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f55aee9dca759da84afd4563ff72d3ca8ab8a1c/gcc%2Fsymtab-thunks.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab-thunks.cc?ref=9f55aee9dca759da84afd4563ff72d3ca8ab8a1c", "patch": "@@ -579,11 +579,11 @@ expand_thunk (cgraph_node *node, bool output_asm_thunks,\n \t\t     adjustment, because that's why we're emitting a\n \t\t     thunk.  */\n \t\t  then_bb = create_basic_block (NULL, bb);\n-\t\t  then_bb->count = cfg_count - cfg_count.apply_scale (1, 16);\n+\t\t  then_bb->count = cfg_count - cfg_count / 16;\n \t\t  return_bb = create_basic_block (NULL, then_bb);\n \t\t  return_bb->count = cfg_count;\n \t\t  else_bb = create_basic_block (NULL, else_bb);\n-\t\t  else_bb->count = cfg_count.apply_scale (1, 16);\n+\t\t  else_bb->count = cfg_count / 16;\n \t\t  add_bb_to_loop (then_bb, bb->loop_father);\n \t\t  add_bb_to_loop (return_bb, bb->loop_father);\n \t\t  add_bb_to_loop (else_bb, bb->loop_father);\n@@ -594,11 +594,9 @@ expand_thunk (cgraph_node *node, bool output_asm_thunks,\n \t\t\t\t\t    NULL_TREE, NULL_TREE);\n \t\t  gsi_insert_after (&bsi, stmt, GSI_NEW_STMT);\n \t\t  e = make_edge (bb, then_bb, EDGE_TRUE_VALUE);\n-\t\t  e->probability = profile_probability::guessed_always ()\n-\t\t\t\t\t.apply_scale (1, 16);\n+\t\t  e->probability = profile_probability::guessed_always () / 16;\n \t\t  e = make_edge (bb, else_bb, EDGE_FALSE_VALUE);\n-\t\t  e->probability = profile_probability::guessed_always ()\n-\t\t\t\t\t.apply_scale (1, 16);\n+\t\t  e->probability = profile_probability::guessed_always () / 16;\n \t\t  make_single_succ_edge (return_bb,\n \t\t\t\t\t EXIT_BLOCK_PTR_FOR_FN (cfun), 0);\n \t\t  make_single_succ_edge (then_bb, return_bb, EDGE_FALLTHRU);"}, {"sha": "5d435637e982f3594a147fe505d900d08b5ea33e", "filename": "gcc/tree-ssa-loop-manip.cc", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f55aee9dca759da84afd4563ff72d3ca8ab8a1c/gcc%2Ftree-ssa-loop-manip.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f55aee9dca759da84afd4563ff72d3ca8ab8a1c/gcc%2Ftree-ssa-loop-manip.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.cc?ref=9f55aee9dca759da84afd4563ff72d3ca8ab8a1c", "patch": "@@ -1421,8 +1421,8 @@ tree_transform_and_unroll_loop (class loop *loop, unsigned factor,\n \t}\n \n       basic_block rest = new_exit->dest;\n-      new_exit->probability = profile_probability::always ()\n-\t.apply_scale (1, new_est_niter + 1);\n+      new_exit->probability\n+\t= (profile_probability::always () / (new_est_niter + 1));\n \n       rest->count += new_exit->count ();\n \n@@ -1463,8 +1463,7 @@ tree_transform_and_unroll_loop (class loop *loop, unsigned factor,\n \t  && TREE_CODE (desc->niter) == INTEGER_CST)\n \t{\n \t  /* The + 1 converts latch counts to iteration counts.  */\n-\t  profile_count new_header_count\n-\t    = (in_count.apply_scale (new_est_niter + 1, 1));\n+\t  profile_count new_header_count = in_count * (new_est_niter + 1);\n \t  basic_block *body = get_loop_body (loop);\n \t  scale_bbs_frequencies_profile_count (body, loop->num_nodes,\n \t\t\t\t\t       new_header_count,\n@@ -1502,8 +1501,8 @@ tree_transform_and_unroll_loop (class loop *loop, unsigned factor,\n \t    e->dest->count / e->src->count ~= new e->probability\n \n \t for every outgoing edge e of NEW_EXIT->src.  */\n-      profile_probability new_exit_prob = profile_probability::always ()\n-\t.apply_scale (1, new_est_niter + 1);\n+      profile_probability new_exit_prob\n+\t= profile_probability::always () / (new_est_niter + 1);\n       change_edge_frequency (new_exit, new_exit_prob);\n     }\n "}, {"sha": "bb50cbc8380b30dbad99d0ffa0c272004136bad1", "filename": "gcc/tree-ssa-sink.cc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f55aee9dca759da84afd4563ff72d3ca8ab8a1c/gcc%2Ftree-ssa-sink.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f55aee9dca759da84afd4563ff72d3ca8ab8a1c/gcc%2Ftree-ssa-sink.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sink.cc?ref=9f55aee9dca759da84afd4563ff72d3ca8ab8a1c", "patch": "@@ -230,8 +230,7 @@ select_best_block (basic_block early_bb,\n   if (bb_loop_depth (best_bb) == bb_loop_depth (early_bb)\n       /* If result of comparsion is unknown, prefer EARLY_BB.\n \t Thus use !(...>=..) rather than (...<...)  */\n-      && !(best_bb->count.apply_scale (100, 1)\n-\t   >= early_bb->count.apply_scale (threshold, 1)))\n+      && !(best_bb->count * 100 >= early_bb->count * threshold))\n     return best_bb;\n \n   /* No better block found, so return EARLY_BB, which happens to be the"}, {"sha": "990f5e1c6d058e532f9bba508fd8cb064011b8fa", "filename": "gcc/tree-switch-conversion.cc", "status": "modified", "additions": 26, "deletions": 27, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f55aee9dca759da84afd4563ff72d3ca8ab8a1c/gcc%2Ftree-switch-conversion.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f55aee9dca759da84afd4563ff72d3ca8ab8a1c/gcc%2Ftree-switch-conversion.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.cc?ref=9f55aee9dca759da84afd4563ff72d3ca8ab8a1c", "patch": "@@ -1782,7 +1782,7 @@ switch_decision_tree::analyze_switch_statement ()\n       tree high = CASE_HIGH (elt);\n \n       profile_probability p\n-\t= case_edge->probability.apply_scale (1, (intptr_t) (case_edge->aux));\n+\t= case_edge->probability / ((intptr_t) (case_edge->aux));\n       clusters.quick_push (new simple_cluster (low, high, elt, case_edge->dest,\n \t\t\t\t\t       p));\n       m_case_bbs.quick_push (case_edge->dest);\n@@ -2057,7 +2057,7 @@ switch_decision_tree::balance_case_nodes (case_tree_node **head,\n \t  /* Split this list if it is long enough for that to help.  */\n \t  npp = head;\n \t  left = *npp;\n-\t  profile_probability pivot_prob = prob.apply_scale (1, 2);\n+\t  profile_probability pivot_prob = prob / 2;\n \n \t  /* Find the place in the list that bisects the list's total cost\n \t     by probability.  */\n@@ -2259,12 +2259,11 @@ switch_decision_tree::emit_case_nodes (basic_block bb, tree index,\n \t      redirect_edge_succ (single_pred_edge (test_bb),\n \t\t\t\t  single_succ_edge (bb)->dest);\n \n-\t      p = ((node->m_right->m_c->m_subtree_prob\n-\t\t    + default_prob.apply_scale (1, 2))\n+\t      p = ((node->m_right->m_c->m_subtree_prob + default_prob / 2)\n \t\t   / (node->m_c->m_subtree_prob + default_prob));\n \t      bb = emit_cmp_and_jump_insns (bb, index, node->m_c->get_high (),\n \t\t\t\t\t    GT_EXPR, test_bb, p, loc);\n-\t      default_prob = default_prob.apply_scale (1, 2);\n+\t      default_prob /= 2;\n \n \t      /* Handle the left-hand subtree.  */\n \t      bb = emit_case_nodes (bb, index, node->m_left,\n@@ -2293,11 +2292,11 @@ switch_decision_tree::emit_case_nodes (basic_block bb, tree index,\n \t  if (node->m_right->has_child ()\n \t      || !node->m_right->m_c->is_single_value_p ())\n \t    {\n-\t      p = (default_prob.apply_scale (1, 2)\n+\t      p = ((default_prob / 2)\n \t\t   / (node->m_c->m_subtree_prob + default_prob));\n \t      bb = emit_cmp_and_jump_insns (bb, index, node->m_c->get_low (),\n \t\t\t\t\t    LT_EXPR, m_default_bb, p, loc);\n-\t      default_prob = default_prob.apply_scale (1, 2);\n+\t      default_prob /= 2;\n \n \t      bb = emit_case_nodes (bb, index, node->m_right, default_prob,\n \t\t\t\t    index_type, loc);\n@@ -2320,11 +2319,11 @@ switch_decision_tree::emit_case_nodes (basic_block bb, tree index,\n \t  if (node->m_left->has_child ()\n \t      || !node->m_left->m_c->is_single_value_p ())\n \t    {\n-\t      p = (default_prob.apply_scale (1, 2)\n+\t      p = ((default_prob / 2)\n \t\t   / (node->m_c->m_subtree_prob + default_prob));\n \t      bb = emit_cmp_and_jump_insns (bb, index, node->m_c->get_high (),\n \t\t\t\t\t    GT_EXPR, m_default_bb, p, loc);\n-\t\t  default_prob = default_prob.apply_scale (1, 2);\n+\t      default_prob /= 2;\n \n \t      bb = emit_case_nodes (bb, index, node->m_left, default_prob,\n \t\t\t\t    index_type, loc);\n@@ -2357,29 +2356,29 @@ switch_decision_tree::emit_case_nodes (basic_block bb, tree index,\n \t   profile_probability right_prob = profile_probability::never ();\n \t   if (node->m_right)\n \t     right_prob = node->m_right->m_c->m_subtree_prob;\n-\t  p = ((right_prob + default_prob.apply_scale (1, 2))\n-\t       / (node->m_c->m_subtree_prob + default_prob));\n+\t   p = ((right_prob + default_prob / 2)\n+\t\t/ (node->m_c->m_subtree_prob + default_prob));\n \n-\t  bb = emit_cmp_and_jump_insns (bb, index, node->m_c->get_high (),\n-\t\t\t\t\tGT_EXPR, test_bb, p, loc);\n-\t  default_prob = default_prob.apply_scale (1, 2);\n+\t   bb = emit_cmp_and_jump_insns (bb, index, node->m_c->get_high (),\n+\t\t\t\t\t GT_EXPR, test_bb, p, loc);\n+\t   default_prob /= 2;\n \n-\t  /* Value belongs to this node or to the left-hand subtree.  */\n-\t  p = node->m_c->m_prob / (node->m_c->m_subtree_prob + default_prob);\n-\t  bb = emit_cmp_and_jump_insns (bb, index, node->m_c->get_low (),\n-\t\t\t\t\tGE_EXPR, node->m_c->m_case_bb, p, loc);\n+\t   /* Value belongs to this node or to the left-hand subtree.  */\n+\t   p = node->m_c->m_prob / (node->m_c->m_subtree_prob + default_prob);\n+\t   bb = emit_cmp_and_jump_insns (bb, index, node->m_c->get_low (),\n+\t\t\t\t\t GE_EXPR, node->m_c->m_case_bb, p, loc);\n \n-\t  /* Handle the left-hand subtree.  */\n-\t  bb = emit_case_nodes (bb, index, node->m_left,\n-\t\t\t\tdefault_prob, index_type, loc);\n+\t   /* Handle the left-hand subtree.  */\n+\t   bb = emit_case_nodes (bb, index, node->m_left, default_prob,\n+\t\t\t\t index_type, loc);\n \n-\t  /* If the left-hand subtree fell through,\n-\t     don't let it fall into the right-hand subtree.  */\n-\t  if (bb && m_default_bb)\n-\t    emit_jump (bb, m_default_bb);\n+\t   /* If the left-hand subtree fell through,\n+\t      don't let it fall into the right-hand subtree.  */\n+\t   if (bb && m_default_bb)\n+\t     emit_jump (bb, m_default_bb);\n \n-\t  bb = emit_case_nodes (test_bb, index, node->m_right,\n-\t\t\t\tdefault_prob, index_type, loc);\n+\t   bb = emit_case_nodes (test_bb, index, node->m_right, default_prob,\n+\t\t\t\t index_type, loc);\n \t}\n       else\n \t{"}, {"sha": "47e094224f825e82c1ea74ff343b6c6c0f720ba4", "filename": "gcc/tree-vect-loop.cc", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f55aee9dca759da84afd4563ff72d3ca8ab8a1c/gcc%2Ftree-vect-loop.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f55aee9dca759da84afd4563ff72d3ca8ab8a1c/gcc%2Ftree-vect-loop.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.cc?ref=9f55aee9dca759da84afd4563ff72d3ca8ab8a1c", "patch": "@@ -9343,13 +9343,12 @@ scale_profile_for_vect_loop (class loop *loop, unsigned vf)\n \t in loop's preheader.  */\n       if (!(freq_e == profile_count::zero ()))\n         freq_e = freq_e.force_nonzero ();\n-      p = freq_e.apply_scale (new_est_niter + 1, 1).probability_in (freq_h);\n+      p = (freq_e * (new_est_niter + 1)).probability_in (freq_h);\n       scale_loop_frequencies (loop, p);\n     }\n \n   edge exit_e = single_exit (loop);\n-  exit_e->probability = profile_probability::always ()\n-\t\t\t\t .apply_scale (1, new_est_niter + 1);\n+  exit_e->probability = profile_probability::always () / (new_est_niter + 1);\n \n   edge exit_l = single_pred_edge (loop->latch);\n   profile_probability prob = exit_l->probability;"}]}