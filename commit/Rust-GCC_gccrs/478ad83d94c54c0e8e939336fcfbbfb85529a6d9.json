{"sha": "478ad83d94c54c0e8e939336fcfbbfb85529a6d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDc4YWQ4M2Q5NGM1NGMwZThlOTM5MzM2ZmNmYmJmYjg1NTI5YTZkOQ==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2012-06-18T18:31:54Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2012-06-18T18:31:54Z"}, "message": "re PR fortran/53692 (OPTIONAL: Scalarizing over the wrong array)\n\n2012-06-18  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/53692\n        * trans-array.c (set_loop_bounds): Don't scalarize via absent\n        optional arrays.\n        * resolve.c (resolve_elemental_actual): Don't stop resolving\n        after printing a warning.\n\n2012-06-18  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/53692\n        * gfortran.dg/elemental_optional_args_6.f90: New.\n\nFrom-SVN: r188749", "tree": {"sha": "3fd75f61b5e57a6a5cac11296c0f7173d323cd01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3fd75f61b5e57a6a5cac11296c0f7173d323cd01"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/478ad83d94c54c0e8e939336fcfbbfb85529a6d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/478ad83d94c54c0e8e939336fcfbbfb85529a6d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/478ad83d94c54c0e8e939336fcfbbfb85529a6d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/478ad83d94c54c0e8e939336fcfbbfb85529a6d9/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c1fb34c3ae740ed96d771e3f2b009e3bf3278242", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1fb34c3ae740ed96d771e3f2b009e3bf3278242", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1fb34c3ae740ed96d771e3f2b009e3bf3278242"}], "stats": {"total": 86, "additions": 84, "deletions": 2}, "files": [{"sha": "a89e197f954050f9297ddf3b69b9397a095ffe7d", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/478ad83d94c54c0e8e939336fcfbbfb85529a6d9/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/478ad83d94c54c0e8e939336fcfbbfb85529a6d9/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=478ad83d94c54c0e8e939336fcfbbfb85529a6d9", "patch": "@@ -1,3 +1,11 @@\n+2012-06-18  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/53692\n+\t* trans-array.c (set_loop_bounds): Don't scalarize via absent\n+\toptional arrays.\n+\t* resolve.c (resolve_elemental_actual): Don't stop resolving after printing\n+\ta warning.\n+\n 2012-06-18  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/53526"}, {"sha": "d09cb11bd3fcbd178c821a4329fb871616d4b610", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/478ad83d94c54c0e8e939336fcfbbfb85529a6d9/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/478ad83d94c54c0e8e939336fcfbbfb85529a6d9/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=478ad83d94c54c0e8e939336fcfbbfb85529a6d9", "patch": "@@ -1957,7 +1957,6 @@ resolve_elemental_actual (gfc_expr *expr, gfc_code *c)\n \t\t       \"ELEMENTAL procedure unless there is a non-optional \"\n \t\t       \"argument with the same rank (12.4.1.5)\",\n \t\t       arg->expr->symtree->n.sym->name, &arg->expr->where);\n-\t  return FAILURE;\n \t}\n     }\n "}, {"sha": "f135af1ef30a7cc06be1f28d65a76a1acbb27318", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/478ad83d94c54c0e8e939336fcfbbfb85529a6d9/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/478ad83d94c54c0e8e939336fcfbbfb85529a6d9/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=478ad83d94c54c0e8e939336fcfbbfb85529a6d9", "patch": "@@ -4337,6 +4337,7 @@ set_loop_bounds (gfc_loopinfo *loop)\n   bool dynamic[GFC_MAX_DIMENSIONS];\n   mpz_t *cshape;\n   mpz_t i;\n+  bool nonoptional_arr;\n \n   loopspec = loop->specloop;\n \n@@ -4345,6 +4346,18 @@ set_loop_bounds (gfc_loopinfo *loop)\n     {\n       loopspec[n] = NULL;\n       dynamic[n] = false;\n+\n+      /* If there are both optional and nonoptional array arguments, scalarize\n+\t over the nonoptional; otherwise, it does not matter as then all\n+\t (optional) arrays have to be present per F2008, 125.2.12p3(6).  */\n+\n+      nonoptional_arr = false;\n+\n+      for (ss = loop->ss; ss != gfc_ss_terminator; ss = ss->loop_chain)\n+\tif (ss->info->type != GFC_SS_SCALAR && ss->info->type != GFC_SS_TEMP\n+\t    && ss->info->type != GFC_SS_REFERENCE && !ss->info->can_be_null_ref)\n+\t  nonoptional_arr = true;\n+\n       /* We use one SS term, and use that to determine the bounds of the\n \t loop for this dimension.  We try to pick the simplest term.  */\n       for (ss = loop->ss; ss != gfc_ss_terminator; ss = ss->loop_chain)\n@@ -4354,7 +4367,8 @@ set_loop_bounds (gfc_loopinfo *loop)\n \t  ss_type = ss->info->type;\n \t  if (ss_type == GFC_SS_SCALAR\n \t      || ss_type == GFC_SS_TEMP\n-\t      || ss_type == GFC_SS_REFERENCE)\n+\t      || ss_type == GFC_SS_REFERENCE\n+\t      || (ss->info->can_be_null_ref && nonoptional_arr))\n \t    continue;\n \n \t  info = &ss->info->data.array;"}, {"sha": "6dc143e64ebea61404077f0d10f914d806ebab98", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/478ad83d94c54c0e8e939336fcfbbfb85529a6d9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/478ad83d94c54c0e8e939336fcfbbfb85529a6d9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=478ad83d94c54c0e8e939336fcfbbfb85529a6d9", "patch": "@@ -1,3 +1,8 @@\n+2012-06-18  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/53692\n+\t* gfortran.dg/elemental_optional_args_6.f90: New.\n+\n 2012-06-18  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/53526"}, {"sha": "ad1c252fb00eda195722951ab52748a20c032074", "filename": "gcc/testsuite/gfortran.dg/elemental_optional_args_6.f90", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/478ad83d94c54c0e8e939336fcfbbfb85529a6d9/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_optional_args_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/478ad83d94c54c0e8e939336fcfbbfb85529a6d9/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_optional_args_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_optional_args_6.f90?ref=478ad83d94c54c0e8e939336fcfbbfb85529a6d9", "patch": "@@ -0,0 +1,56 @@\n+! { dg-do run }\n+!\n+! PR fortran/53692\n+!\n+! Check that the nonabsent arrary is used for scalarization:\n+! Either the NONOPTIONAL one or, if there are none, any array.\n+!\n+! Based on a program by Daniel C Chen\n+!\n+Program main\n+  implicit none\n+  integer :: arr1(2), arr2(2)\n+  arr1 = [ 1, 2 ]\n+  arr2 = [ 1, 2 ]\n+  call sub1 (arg2=arr2)\n+\n+  call two ()\n+contains\n+   subroutine sub1 (arg1, arg2)\n+      integer, optional :: arg1(:)\n+      integer :: arg2(:)\n+!      print *, fun1 (arg1, arg2)\n+      if (size (fun1 (arg1, arg2)) /= 2) call abort() ! { dg-warning \"is an array and OPTIONAL\" }\n+      if (any (fun1 (arg1, arg2) /= [1,2])) call abort() ! { dg-warning \"is an array and OPTIONAL\" }\n+   end subroutine\n+\n+   elemental function fun1 (arg1, arg2)\n+      integer,intent(in), optional :: arg1\n+      integer,intent(in)           :: arg2\n+      integer                      :: fun1\n+      fun1 = arg2\n+   end function\n+end program\n+\n+subroutine two ()\n+  implicit none\n+  integer :: arr1(2), arr2(2)\n+  arr1 = [ 1, 2 ]\n+  arr2 = [ 1, 2 ]\n+  call sub2 (arr1, arg2=arr2)\n+contains\n+   subroutine sub2 (arg1, arg2)\n+      integer, optional :: arg1(:)\n+      integer, optional :: arg2(:)\n+!      print *, fun2 (arg1, arg2)\n+      if (size (fun2 (arg1, arg2)) /= 2) call abort() ! { dg-warning \"is an array and OPTIONAL\" }\n+      if (any (fun2 (arg1, arg2) /= [1,2])) call abort() ! { dg-warning \"is an array and OPTIONAL\" }\n+   end subroutine\n+\n+   elemental function fun2 (arg1,arg2)\n+      integer,intent(in), optional :: arg1\n+      integer,intent(in), optional :: arg2\n+      integer                      :: fun2\n+      fun2 = arg2\n+   end function\n+end subroutine two"}]}