{"sha": "15e73e0657a51d046752b513b8087adb4131be65", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTVlNzNlMDY1N2E1MWQwNDY3NTJiNTEzYjgwODdhZGI0MTMxYmU2NQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2012-01-26T21:17:27Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2012-01-26T21:17:27Z"}, "message": "Use maybe_expand_insn in maybe_emit_atomic_test_and_set.\n\n        * optabs.c (gen_atomic_test_and_set): Remove default.\n        (maybe_emit_atomic_test_and_set): Use maybe_expand_insn.\n\nFrom-SVN: r183580", "tree": {"sha": "a8968cc2f54a8bb059a180fd4f4df74e942109fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a8968cc2f54a8bb059a180fd4f4df74e942109fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15e73e0657a51d046752b513b8087adb4131be65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15e73e0657a51d046752b513b8087adb4131be65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15e73e0657a51d046752b513b8087adb4131be65", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15e73e0657a51d046752b513b8087adb4131be65/comments", "author": null, "committer": null, "parents": [{"sha": "13b61722048dfbfe6ba5ec6f52c728c37dd2cb4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13b61722048dfbfe6ba5ec6f52c728c37dd2cb4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13b61722048dfbfe6ba5ec6f52c728c37dd2cb4d"}], "stats": {"total": 30, "additions": 15, "deletions": 15}, "files": [{"sha": "0e81d1af04e80c1b02acc7a7c8f886ec7c5b92ed", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e73e0657a51d046752b513b8087adb4131be65/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e73e0657a51d046752b513b8087adb4131be65/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=15e73e0657a51d046752b513b8087adb4131be65", "patch": "@@ -1,3 +1,8 @@\n+2012-01-27  Richard Henderson  <rth@redhat.com>\n+\n+\t* optabs.c (gen_atomic_test_and_set): Remove default.\n+\t(maybe_emit_atomic_test_and_set): Use maybe_expand_insn.\n+\n 2012-01-26  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR rtl-optimization/51978"}, {"sha": "87cce8ef4b0430a0f1b2dd929d2c1b3af1817a76", "filename": "gcc/optabs.c", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e73e0657a51d046752b513b8087adb4131be65/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e73e0657a51d046752b513b8087adb4131be65/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=15e73e0657a51d046752b513b8087adb4131be65", "patch": "@@ -7311,39 +7311,34 @@ maybe_emit_compare_and_swap_exchange_loop (rtx target, rtx mem, rtx val)\n #ifndef HAVE_atomic_test_and_set\n #define HAVE_atomic_test_and_set 0\n #define CODE_FOR_atomic_test_and_set CODE_FOR_nothing\n-#define gen_atomic_test_and_set(x,y,z) \\\n-  (gcc_unreachable (), (void) (0 && (x) && (y) && (z)), NULL_RTX)\n #endif\n \n static rtx\n maybe_emit_atomic_test_and_set (rtx target, rtx mem, enum memmodel model)\n {\n   enum machine_mode pat_bool_mode;\n-  const struct insn_data_d *id;\n+  struct expand_operand ops[3];\n \n   if (!HAVE_atomic_test_and_set)\n     return NULL_RTX;\n \n-  id = &insn_data[CODE_FOR_atomic_test_and_set];\n-  pat_bool_mode = id->operand[0].mode;\n-\n-  /* ??? We only support test-and-set on single bytes at the moment.\n-     We'd have to change the builtin to allow wider memories.  */\n-  gcc_checking_assert (id->operand[1].mode == QImode);\n-\n   /* While we always get QImode from __atomic_test_and_set, we get\n      other memory modes from __sync_lock_test_and_set.  Note that we\n      use no endian adjustment here.  This matches the 4.6 behavior\n      in the Sparc backend.  */\n+  gcc_checking_assert\n+    (insn_data[CODE_FOR_atomic_test_and_set].operand[1].mode == QImode);\n   if (GET_MODE (mem) != QImode)\n     mem = adjust_address_nv (mem, QImode, 0);\n \n-  if (target == NULL || GET_MODE (target) != pat_bool_mode)\n-    target = gen_reg_rtx (pat_bool_mode);\n-\n-  emit_insn (gen_atomic_test_and_set (target, mem, GEN_INT (model)));\n+  pat_bool_mode = insn_data[CODE_FOR_atomic_test_and_set].operand[0].mode;\n+  create_output_operand (&ops[0], target, pat_bool_mode);\n+  create_fixed_operand (&ops[1], mem);\n+  create_integer_operand (&ops[2], model);\n \n-  return target;\n+  if (maybe_expand_insn (CODE_FOR_atomic_test_and_set, 3, ops))\n+    return ops[0].value;\n+  return NULL_RTX;\n }\n \n /* This function expands the legacy _sync_lock test_and_set operation which is"}]}