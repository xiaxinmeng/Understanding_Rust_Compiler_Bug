{"sha": "ff69f95af086f0041be775afb527e3b98f9e8bf6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmY2OWY5NWFmMDg2ZjAwNDFiZTc3NWFmYjUyN2UzYjk4ZjllOGJmNg==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2009-04-08T14:25:35Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-08T14:25:35Z"}, "message": "sem_cat.adb (Check_Categorization_Dependencies): Handle Preelaborate properly in the presence of Remote_Types or...\n\n2009-04-08  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_cat.adb (Check_Categorization_Dependencies): Handle Preelaborate\n\tproperly in the presence of Remote_Types or Remote_Call_Interface.\n\n\t* sem_util.adb: Add comment.\n\nFrom-SVN: r145739", "tree": {"sha": "0d29d2c6b65a09fbeeb31495ce6c38799285dab9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0d29d2c6b65a09fbeeb31495ce6c38799285dab9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff69f95af086f0041be775afb527e3b98f9e8bf6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff69f95af086f0041be775afb527e3b98f9e8bf6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff69f95af086f0041be775afb527e3b98f9e8bf6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff69f95af086f0041be775afb527e3b98f9e8bf6/comments", "author": null, "committer": null, "parents": [{"sha": "4d84fe7ceeda4dfa363b4cfe273db99003b87abe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d84fe7ceeda4dfa363b4cfe273db99003b87abe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d84fe7ceeda4dfa363b4cfe273db99003b87abe"}], "stats": {"total": 125, "additions": 72, "deletions": 53}, "files": [{"sha": "f9afe51cae9d51b8bedaf4db7c7d6ffd4af2ee97", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff69f95af086f0041be775afb527e3b98f9e8bf6/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff69f95af086f0041be775afb527e3b98f9e8bf6/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ff69f95af086f0041be775afb527e3b98f9e8bf6", "patch": "@@ -1,3 +1,10 @@\n+2009-04-08  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_cat.adb (Check_Categorization_Dependencies): Handle Preelaborate\n+\tproperly in the presence of Remote_Types or Remote_Call_Interface.\n+\n+\t* sem_util.adb: Add comment.\n+\n 2009-04-08  Robert Dewar  <dewar@adacore.com>\n \n \t* ug_words: Add /ASSUME_VALID for -gnatB"}, {"sha": "76f5f5e1c4d7fb3c5e1f1da3536324b2d351a6a4", "filename": "gcc/ada/sem_cat.adb", "status": "modified", "additions": 60, "deletions": 53, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff69f95af086f0041be775afb527e3b98f9e8bf6/gcc%2Fada%2Fsem_cat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff69f95af086f0041be775afb527e3b98f9e8bf6/gcc%2Fada%2Fsem_cat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_cat.adb?ref=ff69f95af086f0041be775afb527e3b98f9e8bf6", "patch": "@@ -113,22 +113,18 @@ package body Sem_Cat is\n       Info_Node       : Node_Id;\n       Is_Subunit      : Boolean)\n    is\n-      N : constant Node_Id := Info_Node;\n+      N   : constant Node_Id := Info_Node;\n+      Err : Boolean;\n \n       --  Here we define an enumeration type to represent categorization types,\n       --  ordered so that a unit with a given categorization can only WITH\n       --  units with lower or equal categorization type.\n \n-      --  Note that we take advantage of E.2(14) to define a category\n-      --  Preelaborated and treat pragma Preelaborate as a categorization\n-      --  pragma that defines that category.\n-\n       type Categorization is\n         (Pure,\n          Shared_Passive,\n          Remote_Types,\n          Remote_Call_Interface,\n-         Preelaborated,\n          Normal);\n \n       function Get_Categorization (E : Entity_Id) return Categorization;\n@@ -165,9 +161,6 @@ package body Sem_Cat is\n          elsif Is_Remote_Call_Interface (E) then\n             return Remote_Call_Interface;\n \n-         elsif Is_Preelaborated (E) then\n-            return Preelaborated;\n-\n          else\n             return Normal;\n          end if;\n@@ -186,73 +179,87 @@ package body Sem_Cat is\n          return;\n       end if;\n \n-      Unit_Category := Get_Categorization (Unit_Entity);\n-      With_Category := Get_Categorization (Depended_Entity);\n+      --  First check 10.2.1 (11/1) rules on preelaborate packages\n \n-      --  These messages are warnings in GNAT mode, to allow it to be\n-      --  judiciously turned off. Otherwise it is a real error.\n+      if Is_Preelaborated (Unit_Entity)\n+        and then not Is_Preelaborated (Depended_Entity)\n+        and then not Is_Pure (Depended_Entity)\n+      then\n+         Err := True;\n+      else\n+         Err := False;\n+      end if;\n \n-      Error_Msg_Warn := GNAT_Mode;\n+      --  Check categorization rules of RM E.2(5)\n \n-      --  Check for possible error\n+      Unit_Category := Get_Categorization (Unit_Entity);\n+      With_Category := Get_Categorization (Depended_Entity);\n \n       if With_Category > Unit_Category then\n \n          --  Special case: Remote_Types and Remote_Call_Interface are allowed\n-         --  with anything in the package body, per (RM E.2(5)).\n+         --  to WITH anything in the package body, per (RM E.2(5)).\n \n          if (Unit_Category = Remote_Types\n                or else Unit_Category = Remote_Call_Interface)\n            and then In_Package_Body (Unit_Entity)\n          then\n             null;\n+         else\n+            Err := True;\n+         end if;\n+      end if;\n \n-         --  Here we have an error\n+      --  Here if we have an error\n \n-         else\n-            --  Don't give error if main unit is not an internal unit, and the\n-            --  unit generating the message is an internal unit. This is the\n-            --  situation in which such messages would be ignored in any case,\n-            --  so it is convenient not to generate them (since it causes\n-            --  annoying interference with debugging).\n-\n-            if Is_Internal_File_Name (Unit_File_Name (Current_Sem_Unit))\n-              and then not Is_Internal_File_Name (Unit_File_Name (Main_Unit))\n-            then\n-               return;\n+      if Err then\n \n-            --  Subunit case\n+         --  These messages are warnings in GNAT mode, to allow it to be\n+         --  judiciously turned off. Otherwise it is a real error.\n \n-            elsif Is_Subunit then\n-               Error_Msg_NE\n-                 (\"<subunit cannot depend on& \" &\n-                  \"(parent has wrong categorization)\", N, Depended_Entity);\n+         Error_Msg_Warn := GNAT_Mode;\n \n-            --  Normal unit, not subunit\n+         --  Don't give error if main unit is not an internal unit, and the\n+         --  unit generating the message is an internal unit. This is the\n+         --  situation in which such messages would be ignored in any case,\n+         --  so it is convenient not to generate them (since it causes\n+         --  annoying interference with debugging).\n \n-            else\n-               Error_Msg_NE\n-                 (\"<cannot depend on& \" &\n-                  \"(wrong categorization)\", N, Depended_Entity);\n-            end if;\n+         if Is_Internal_File_Name (Unit_File_Name (Current_Sem_Unit))\n+           and then not Is_Internal_File_Name (Unit_File_Name (Main_Unit))\n+         then\n+            return;\n \n-            --  Add further explanation for common cases\n+         --  Subunit case\n \n-            case Unit_Category is\n-               when Pure =>\n-                  Error_Msg_NE\n-                    (\"\\<pure unit cannot depend on non-pure unit\",\n-                    N, Depended_Entity);\n+         elsif Is_Subunit then\n+            Error_Msg_NE\n+              (\"<subunit cannot depend on& \" &\n+               \"(parent has wrong categorization)\", N, Depended_Entity);\n \n-               when Preelaborated =>\n-                  Error_Msg_NE\n-                    (\"\\<preelaborated unit cannot depend on \" &\n-                     \"non-preelaborated unit\",\n-                     N, Depended_Entity);\n+         --  Normal unit, not subunit\n \n-               when others =>\n-                  null;\n-            end case;\n+         else\n+            Error_Msg_NE\n+              (\"<cannot depend on& \" &\n+               \"(wrong categorization)\", N, Depended_Entity);\n+         end if;\n+\n+         --  Add further explanation for Pure/Preelaborate common cases\n+\n+         if Unit_Category = Pure then\n+            Error_Msg_NE\n+              (\"\\<pure unit cannot depend on non-pure unit\",\n+               N, Depended_Entity);\n+\n+         elsif Is_Preelaborated (Unit_Entity)\n+           and then not Is_Preelaborated (Depended_Entity)\n+           and then not Is_Pure (Depended_Entity)\n+         then\n+            Error_Msg_NE\n+              (\"\\<preelaborated unit cannot depend on \"\n+               & \"non-preelaborated unit\",\n+               N, Depended_Entity);\n          end if;\n       end if;\n    end Check_Categorization_Dependencies;"}, {"sha": "4876303f0a0996e17b9ef4faa6038ce26ef56fd8", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff69f95af086f0041be775afb527e3b98f9e8bf6/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff69f95af086f0041be775afb527e3b98f9e8bf6/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=ff69f95af086f0041be775afb527e3b98f9e8bf6", "patch": "@@ -6802,6 +6802,11 @@ package body Sem_Util is\n         and then Present (Etype (Orig_Node))\n         and then Is_Access_Type (Etype (Orig_Node))\n       then\n+         --  Note that if the prefix is an explicit dereference that does not\n+         --  come from source, we must check for a rewritten function call in\n+         --  prefixed notation before other forms of rewriting, to prevent a\n+         --  compiler crash.\n+\n          return\n            (Nkind (Orig_Node) = N_Function_Call\n              and then not Is_Access_Constant (Etype (Prefix (N))))"}]}