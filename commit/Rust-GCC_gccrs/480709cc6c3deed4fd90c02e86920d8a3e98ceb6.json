{"sha": "480709cc6c3deed4fd90c02e86920d8a3e98ceb6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDgwNzA5Y2M2YzNkZWVkNGZkOTBjMDJlODY5MjBkOGEzZTk4Y2ViNg==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-10-21T14:04:42Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-10-21T14:04:42Z"}, "message": "cpphash.h (struct cpp_buffer): Delete read_ahead and extra_char.\n\n\t* cpphash.h (struct cpp_buffer): Delete read_ahead and extra_char.\n\t* cpplex.c (lex_percent, lex_dot): Remove.\n\t(get_effective_char, skip_block_comment, skip_line_comment,\n\tparse_identifier_slow, parse_number, parse_string, save_comment,\n\t_cpp_lex_direct): Update to do lookback freely.\n\t(IF_NEXT_IS, BACKUP): New macros.\n\t* cpplib.c (cpp_push_buffer): Don't set read_ahead and extra_char.\n\t* cppmacro.c (paste_tokens): Update.\n\nFrom-SVN: r46392", "tree": {"sha": "89ea5c85908fbe5e7d5dbc18983341f4a856a863", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/89ea5c85908fbe5e7d5dbc18983341f4a856a863"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/480709cc6c3deed4fd90c02e86920d8a3e98ceb6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/480709cc6c3deed4fd90c02e86920d8a3e98ceb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/480709cc6c3deed4fd90c02e86920d8a3e98ceb6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/480709cc6c3deed4fd90c02e86920d8a3e98ceb6/comments", "author": null, "committer": null, "parents": [{"sha": "28d8dc3a10515f24498449589849dee132b75cd1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28d8dc3a10515f24498449589849dee132b75cd1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28d8dc3a10515f24498449589849dee132b75cd1"}], "stats": {"total": 472, "additions": 212, "deletions": 260}, "files": [{"sha": "83c536f1b674b1edf30c9fb7c518c6581f64771c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/480709cc6c3deed4fd90c02e86920d8a3e98ceb6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/480709cc6c3deed4fd90c02e86920d8a3e98ceb6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=480709cc6c3deed4fd90c02e86920d8a3e98ceb6", "patch": "@@ -1,3 +1,14 @@\n+2001-10-21  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cpphash.h (struct cpp_buffer): Delete read_ahead and extra_char.\n+\t* cpplex.c (lex_percent, lex_dot): Remove.\n+\t(get_effective_char, skip_block_comment, skip_line_comment,\n+\tparse_identifier_slow, parse_number, parse_string, save_comment,\n+\t_cpp_lex_direct): Update to do lookback freely.\n+\t(IF_NEXT_IS, BACKUP): New macros.\n+\t* cpplib.c (cpp_push_buffer): Don't set read_ahead and extra_char.\n+\t* cppmacro.c (paste_tokens): Update.\n+\n 2001-10-20  Nick Clifton  <nickc@cambridge.redhat.com>\n \n \t* doc/invoke.texi (i386 and x86-64 Options): Fix typo."}, {"sha": "ccb9a47cee8bc55c8860f388a29d7ca2de8df48f", "filename": "gcc/cpphash.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/480709cc6c3deed4fd90c02e86920d8a3e98ceb6/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/480709cc6c3deed4fd90c02e86920d8a3e98ceb6/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=480709cc6c3deed4fd90c02e86920d8a3e98ceb6", "patch": "@@ -171,10 +171,9 @@ struct spec_nodes\n struct cpp_buffer\n {\n   const unsigned char *cur;\t /* current position */\n+  const unsigned char *backup_to; /* if peeked character is not wanted */\n   const unsigned char *rlimit; /* end of valid data */\n   const unsigned char *line_base; /* start of current line */\n-  cppchar_t read_ahead;\t\t/* read ahead character */\n-  cppchar_t extra_char;\t\t/* extra read-ahead for long tokens.  */\n \n   struct cpp_buffer *prev;\n "}, {"sha": "45ca635e4bd56dcd4a163716644e5a519e358827", "filename": "gcc/cpplex.c", "status": "modified", "additions": 199, "deletions": 252, "changes": 451, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/480709cc6c3deed4fd90c02e86920d8a3e98ceb6/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/480709cc6c3deed4fd90c02e86920d8a3e98ceb6/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=480709cc6c3deed4fd90c02e86920d8a3e98ceb6", "patch": "@@ -66,6 +66,7 @@ static const struct token_spelling token_spellings[N_TTYPES] = { TTYPE_TABLE };\n \n #define TOKEN_SPELL(token) (token_spellings[(token)->type].category)\n #define TOKEN_NAME(token) (token_spellings[(token)->type].name)\n+#define BACKUP() do {buffer->cur = buffer->backup_to;} while (0)\n \n static void handle_newline PARAMS ((cpp_reader *));\n static cppchar_t skip_escaped_newlines PARAMS ((cpp_reader *));\n@@ -84,8 +85,6 @@ static void parse_string PARAMS ((cpp_reader *, cpp_token *, cppchar_t));\n static void unterminated PARAMS ((cpp_reader *, int));\n static bool trigraph_p PARAMS ((cpp_reader *));\n static void save_comment PARAMS ((cpp_reader *, cpp_token *, const U_CHAR *));\n-static void lex_percent PARAMS ((cpp_reader *, cpp_token *));\n-static void lex_dot PARAMS ((cpp_reader *, cpp_token *));\n static int name_p PARAMS ((cpp_reader *, const cpp_string *));\n static int maybe_read_ucs PARAMS ((cpp_reader *, const unsigned char **,\n \t\t\t\t   const unsigned char *, unsigned int *));\n@@ -172,14 +171,10 @@ trigraph_p (pfile)\n   return accept;\n }\n \n-/* Assumes local variables buffer and result.  */\n-#define ACCEPT_CHAR(t) \\\n-  do { result->type = t; buffer->read_ahead = EOF; } while (0)\n-\n /* Skips any escaped newlines introduced by '?' or a '\\\\', assumed to\n-   lie in buffer->cur[-1].  Returns the next character, which will\n-   then be in buffer->cur[-1].  This routine performs preprocessing\n-   stages 1 and 2 of the ISO C standard.  */\n+   lie in buffer->cur[-1].  Returns the next byte, which will be in\n+   buffer->cur[-1].  This routine performs preprocessing stages 1 and\n+   2 of the ISO C standard.  */\n static cppchar_t\n skip_escaped_newlines (pfile)\n      cpp_reader *pfile;\n@@ -231,6 +226,7 @@ skip_escaped_newlines (pfile)\n \t    cpp_warning (pfile, \"backslash and newline separated by space\");\n \n \t  handle_newline (pfile);\n+\t  buffer->backup_to = buffer->cur;\n \t  if (buffer->cur == buffer->rlimit)\n \t    {\n \t      cpp_pedwarn (pfile, \"backslash-newline at end of file\");\n@@ -248,28 +244,24 @@ skip_escaped_newlines (pfile)\n /* Obtain the next character, after trigraph conversion and skipping\n    an arbitrarily long string of escaped newlines.  The common case of\n    no trigraphs or escaped newlines falls through quickly.  On return,\n-   buffer->cur points after the returned character.  */\n+   buffer->backup_to points to where to return to if the character is\n+   not to be processed.  */\n static cppchar_t\n get_effective_char (pfile)\n      cpp_reader *pfile;\n {\n-  cpp_buffer *buffer = pfile->buffer;\n   cppchar_t next = EOF;\n+  cpp_buffer *buffer = pfile->buffer;\n \n+  buffer->backup_to = buffer->cur;\n   if (buffer->cur < buffer->rlimit)\n     {\n       next = *buffer->cur++;\n-\n-      /* '?' can introduce trigraphs (and therefore backslash); '\\\\'\n-\t can introduce escaped newlines, which we want to skip, or\n-\t UCNs, which, depending upon lexer state, we will handle in\n-\t the future.  */\n-      if (next == '?' || next == '\\\\')\n+      if (__builtin_expect (next == '?' || next == '\\\\', 0))\n \tnext = skip_escaped_newlines (pfile);\n     }\n \n-  buffer->read_ahead = next;\n-  return next;\n+   return next;\n }\n \n /* Skip a C-style block comment.  We find the end of the comment by\n@@ -316,13 +308,12 @@ skip_block_comment (pfile)\n     }\n \n   pfile->state.lexing_comment = 0;\n-  buffer->read_ahead = EOF;\n   return c != '/' || prevc != '*';\n }\n \n-/* Skip a C++ line comment.  Handles escaped newlines.  Returns\n-   non-zero if a multiline comment.  The following new line, if any,\n-   is left in buffer->read_ahead.  */\n+/* Skip a C++ line comment, leaving buffer->cur pointing to the\n+   terminating newline.  Handles escaped newlines.  Returns non-zero\n+   if a multiline comment.  */\n static int\n skip_line_comment (pfile)\n      cpp_reader *pfile;\n@@ -334,18 +325,20 @@ skip_line_comment (pfile)\n   pfile->state.lexing_comment = 1;\n   do\n     {\n-      c = EOF;\n       if (buffer->cur == buffer->rlimit)\n-\tbreak;\n+\tgoto at_eof;\n \n       c = *buffer->cur++;\n       if (c == '?' || c == '\\\\')\n \tc = skip_escaped_newlines (pfile);\n     }\n   while (!is_vspace (c));\n \n+  /* Step back over the newline, except at EOF.  */\n+  buffer->cur--;\n+ at_eof:\n+\n   pfile->state.lexing_comment = 0;\n-  buffer->read_ahead = c;\t/* Leave any newline for caller.  */\n   return orig_line != pfile->line;\n }\n \n@@ -397,16 +390,14 @@ skip_whitespace (pfile, c)\n \t\t\t       \"%s in preprocessing directive\",\n \t\t\t       c == '\\f' ? \"form feed\" : \"vertical tab\");\n \n-      c = EOF;\n       if (buffer->cur == buffer->rlimit)\n-\tbreak;\n+\treturn;\n       c = *buffer->cur++;\n     }\n   /* We only want non-vertical space, i.e. ' ' \\t \\f \\v \\0.  */\n   while (is_nvspace (c));\n \n-  /* Remember the next character.  */\n-  buffer->read_ahead = c;\n+  buffer->cur--;\n }\n \n /* See if the characters of a number token are valid in a name (no\n@@ -510,22 +501,23 @@ parse_identifier_slow (pfile, cur)\n           if (c == '$')\n             saw_dollar++;\n \n-          c = EOF;\n           if (buffer->cur == buffer->rlimit)\n-            break;\n+            goto at_eof;\n \n           c = *buffer->cur++;\n         }\n \n       /* Potential escaped newline?  */\n+      buffer->backup_to = buffer->cur - 1;\n       if (c != '?' && c != '\\\\')\n         break;\n       c = skip_escaped_newlines (pfile);\n     }\n   while (is_idchar (c));\n \n-  /* Remember the next character.  */\n-  buffer->read_ahead = c;\n+  /* Step back over the unwanted char, except at EOF.  */\n+  BACKUP ();\n+ at_eof:\n \n   /* $ is not an identifier character in the standard, but is commonly\n      accepted as an extension.  Don't warn about it in skipped\n@@ -581,23 +573,24 @@ parse_number (pfile, number, c, leading_period)\n \t    }\n \t  *dest++ = c;\n \n-\t  c = EOF;\n \t  if (buffer->cur == buffer->rlimit)\n-\t    break;\n+\t    goto at_eof;\n \n \t  c = *buffer->cur++;\n \t}\n       while (is_numchar (c) || c == '.' || VALID_SIGN (c, dest[-1]));\n \n       /* Potential escaped newline?  */\n+      buffer->backup_to = buffer->cur - 1;\n       if (c != '?' && c != '\\\\')\n \tbreak;\n       c = skip_escaped_newlines (pfile);\n     }\n   while (is_numchar (c) || c == '.' || VALID_SIGN (c, dest[-1]));\n \n-  /* Remember the next character.  */\n-  buffer->read_ahead = c;\n+  /* Step back over the unwanted char, except at EOF.  */\n+  BACKUP ();\n+ at_eof:\n \n   /* Null-terminate the number.  */\n   *dest = '\\0';\n@@ -740,7 +733,6 @@ parse_string (pfile, token, terminator)\n       *dest++ = c;\n     }\n \n-  buffer->read_ahead = EOF;\n   *dest = '\\0';\n \n   token->val.str.text = BUFF_FRONT (pfile->u_buff);\n@@ -759,9 +751,10 @@ save_comment (pfile, token, from)\n   unsigned int len;\n   \n   len = pfile->buffer->cur - from + 1; /* + 1 for the initial '/'.  */\n+\n   /* C++ comments probably (not definitely) have moved past a new\n      line, which we don't want to save in the comment.  */\n-  if (pfile->buffer->read_ahead != EOF)\n+  if (is_vspace (pfile->buffer->cur[-1]))\n     len--;\n   buffer = _cpp_unaligned_alloc (pfile, len);\n   \n@@ -773,101 +766,6 @@ save_comment (pfile, token, from)\n   memcpy (buffer + 1, from, len - 1);\n }\n \n-/* Subroutine of _cpp_lex_direct to handle '%'.  A little tricky, since we\n-   want to avoid stepping back when lexing %:%X.  */\n-static void\n-lex_percent (pfile, result)\n-     cpp_reader *pfile;\n-     cpp_token *result;\n-{\n-  cpp_buffer *buffer= pfile->buffer;\n-  cppchar_t c;\n-\n-  result->type = CPP_MOD;\n-  /* Parsing %:%X could leave an extra character.  */\n-  if (buffer->extra_char == EOF)\n-    c = get_effective_char (pfile);\n-  else\n-    {\n-      c = buffer->read_ahead = buffer->extra_char;\n-      buffer->extra_char = EOF;\n-    }\n-\n-  if (c == '=')\n-    ACCEPT_CHAR (CPP_MOD_EQ);\n-  else if (CPP_OPTION (pfile, digraphs))\n-    {\n-      if (c == ':')\n-\t{\n-\t  result->flags |= DIGRAPH;\n-\t  ACCEPT_CHAR (CPP_HASH);\n-\t  if (get_effective_char (pfile) == '%')\n-\t    {\n-\t      buffer->extra_char = get_effective_char (pfile);\n-\t      if (buffer->extra_char == ':')\n-\t\t{\n-\t\t  buffer->extra_char = EOF;\n-\t\t  ACCEPT_CHAR (CPP_PASTE);\n-\t\t}\n-\t      else\n-\t\t/* We'll catch the extra_char when we're called back.  */\n-\t\tbuffer->read_ahead = '%';\n-\t    }\n-\t}\n-      else if (c == '>')\n-\t{\n-\t  result->flags |= DIGRAPH;\n-\t  ACCEPT_CHAR (CPP_CLOSE_BRACE);\n-\t}\n-    }\n-}\n-\n-/* Subroutine of _cpp_lex_direct to handle '.'.  This is tricky, since we\n-   want to avoid stepping back when lexing '...' or '.123'.  In the\n-   latter case we should also set a flag for parse_number.  */\n-static void\n-lex_dot (pfile, result)\n-     cpp_reader *pfile;\n-     cpp_token *result;\n-{\n-  cpp_buffer *buffer = pfile->buffer;\n-  cppchar_t c;\n-\n-  /* Parsing ..X could leave an extra character.  */\n-  if (buffer->extra_char == EOF)\n-    c = get_effective_char (pfile);\n-  else\n-    {\n-      c = buffer->read_ahead = buffer->extra_char;\n-      buffer->extra_char = EOF;\n-    }\n-\n-  /* All known character sets have 0...9 contiguous.  */\n-  if (c >= '0' && c <= '9')\n-    {\n-      result->type = CPP_NUMBER;\n-      parse_number (pfile, &result->val.str, c, 1);\n-    }\n-  else\n-    {\n-      result->type = CPP_DOT;\n-      if (c == '.')\n-\t{\n-\t  buffer->extra_char = get_effective_char (pfile);\n-\t  if (buffer->extra_char == '.')\n-\t    {\n-\t      buffer->extra_char = EOF;\n-\t      ACCEPT_CHAR (CPP_ELLIPSIS);\n-\t    }\n-\t  else\n-\t    /* We'll catch the extra_char when we're called back.  */\n-\t    buffer->read_ahead = '.';\n-\t}\n-      else if (c == '*' && CPP_OPTION (pfile, cplusplus))\n-\tACCEPT_CHAR (CPP_DOT_STAR);\n-    }\n-}\n-\n /* Allocate COUNT tokens for RUN.  */\n void\n _cpp_init_tokenrun (run, count)\n@@ -970,6 +868,17 @@ _cpp_lex_token (pfile)\n   return result;\n }\n \n+#define IF_NEXT_IS(CHAR, THEN_TYPE, ELSE_TYPE)\t\\\n+  do {\t\t\t\t\t\t\\\n+    if (get_effective_char (pfile) == CHAR)\t\\\n+      result->type = THEN_TYPE;\t\t\t\\\n+    else\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\\\n+        BACKUP ();\t\t\t\t\\\n+        result->type = ELSE_TYPE;\t\t\\\n+      }\t\t\t\t\t\t\\\n+  } while (0)\n+\n /* Lex a token into pfile->cur_token, which is also incremented, to\n    get diagnostics pointing to the correct location.\n \n@@ -998,16 +907,15 @@ _cpp_lex_direct (pfile)\n   result->line = pfile->line;\n \n  skipped_white:\n-  c = buffer->read_ahead;\n-  if (c == EOF && buffer->cur < buffer->rlimit)\n-    c = *buffer->cur++;\n+  if (buffer->cur == buffer->rlimit)\n+    goto at_eof;\n+  c = *buffer->cur++;\n   result->col = CPP_BUF_COLUMN (buffer, buffer->cur);\n-  buffer->read_ahead = EOF;\n \n  trigraph:\n   switch (c)\n     {\n-    case EOF:\n+    at_eof:\n       buffer->saved_flags = BOL;\n       if (!pfile->state.parsing_args && !pfile->state.in_directive)\n \t{\n@@ -1066,20 +974,20 @@ _cpp_lex_direct (pfile)\n \tc = skip_escaped_newlines (pfile);\n \tif (line != pfile->line)\n \t  {\n-\t    buffer->read_ahead = c;\n+\t    buffer->cur--;\n \t    /* We had at least one escaped newline of some sort.\n \t       Update the token's line and column.  */\n \t    goto update_tokens_line;\n \t  }\n+      }\n \n-\t/* We are either the original '?' or '\\\\', or a trigraph.  */\n+      /* We are either the original '?' or '\\\\', or a trigraph.  */\n+      if (c == '?')\n \tresult->type = CPP_QUERY;\n-\tbuffer->read_ahead = EOF;\n-\tif (c == '\\\\')\n-\t  goto random_char;\n-\telse if (c != '?')\n-\t  goto trigraph;\n-      }\n+      else if (c == '\\\\')\n+\tgoto random_char;\n+      else\n+\tgoto trigraph;\n       break;\n \n     case '0': case '1': case '2': case '3': case '4':\n@@ -1108,16 +1016,15 @@ _cpp_lex_direct (pfile)\n       result->val.node = parse_identifier (pfile);\n \n       /* 'L' may introduce wide characters or strings.  */\n-      if (result->val.node == pfile->spec_nodes.n_L)\n+      if (result->val.node == pfile->spec_nodes.n_L\n+\t  && buffer->cur < buffer->rlimit)\n \t{\n-\t  c = buffer->read_ahead;\n-\t  if (c == EOF && buffer->cur < buffer->rlimit)\n-\t    c = *buffer->cur;\n+\t  c = *buffer->cur;\n \t  if (c == '\\'' || c == '\"')\n \t    {\n \t      buffer->cur++;\n-\t      ACCEPT_CHAR (c == '\"' ? CPP_WSTRING: CPP_WCHAR);\n-\t      goto make_string;\n+\t      result->type = (c == '\"' ? CPP_WSTRING: CPP_WCHAR);\n+\t      parse_string (pfile, result, c);\n \t    }\n \t}\n       /* Convert named operators to their proper types.  */\n@@ -1131,31 +1038,22 @@ _cpp_lex_direct (pfile)\n     case '\\'':\n     case '\"':\n       result->type = c == '\"' ? CPP_STRING: CPP_CHAR;\n-    make_string:\n       parse_string (pfile, result, c);\n       break;\n \n     case '/':\n       /* A potential block or line comment.  */\n       comment_start = buffer->cur;\n-      result->type = CPP_DIV;\n       c = get_effective_char (pfile);\n-      if (c == '=')\n-\tACCEPT_CHAR (CPP_DIV_EQ);\n-      if (c != '/' && c != '*')\n-\tbreak;\n-      \n+\n       if (c == '*')\n \t{\n \t  if (skip_block_comment (pfile))\n \t    cpp_error (pfile, \"unterminated comment\");\n \t}\n-      else\n+      else if (c == '/' && (CPP_OPTION (pfile, cplusplus_comments)\n+\t\t\t    || CPP_IN_SYSTEM_HEADER (pfile)))\n \t{\n-\t  if (!CPP_OPTION (pfile, cplusplus_comments)\n-\t      && !CPP_IN_SYSTEM_HEADER (pfile))\n-\t    break;\n-\n \t  /* Warn about comments only if pedantically GNUC89, and not\n \t     in system headers.  */\n \t  if (CPP_OPTION (pfile, lang) == CLK_GNUC89 && CPP_PEDANTIC (pfile)\n@@ -1168,12 +1066,21 @@ _cpp_lex_direct (pfile)\n \t      buffer->warned_cplusplus_comments = 1;\n \t    }\n \n-\t  /* Skip_line_comment updates buffer->read_ahead.  */\n \t  if (skip_line_comment (pfile) && CPP_OPTION (pfile, warn_comments))\n \t    cpp_warning (pfile, \"multi-line comment\");\n \t}\n+      else if (c == '=')\n+\t{\n+\t  result->type = CPP_DIV_EQ;\n+\t  break;\n+\t}\n+      else\n+\t{\n+\t  BACKUP ();\n+\t  result->type = CPP_DIV;\n+\t  break;\n+\t}\n \n-      /* Skipping the comment has updated buffer->read_ahead.  */\n       if (!pfile->state.save_comments)\n \t{\n \t  result->flags |= PREV_WHITE;\n@@ -1188,150 +1095,190 @@ _cpp_lex_direct (pfile)\n       if (pfile->state.angled_headers)\n \t{\n \t  result->type = CPP_HEADER_NAME;\n-\t  c = '>';\t\t/* terminator.  */\n-\t  goto make_string;\n+\t  parse_string (pfile, result, '>');\n+\t  break;\n \t}\n \n-      result->type = CPP_LESS;\n       c = get_effective_char (pfile);\n       if (c == '=')\n-\tACCEPT_CHAR (CPP_LESS_EQ);\n+\tresult->type = CPP_LESS_EQ;\n       else if (c == '<')\n-\t{\n-\t  ACCEPT_CHAR (CPP_LSHIFT);\n-\t  if (get_effective_char (pfile) == '=')\n-\t    ACCEPT_CHAR (CPP_LSHIFT_EQ);\n-\t}\n+\tIF_NEXT_IS ('=', CPP_LSHIFT_EQ, CPP_LSHIFT);\n       else if (c == '?' && CPP_OPTION (pfile, cplusplus))\n-\t{\n-\t  ACCEPT_CHAR (CPP_MIN);\n-\t  if (get_effective_char (pfile) == '=')\n-\t    ACCEPT_CHAR (CPP_MIN_EQ);\n-\t}\n+\tIF_NEXT_IS ('=', CPP_MIN_EQ, CPP_MIN);\n       else if (c == ':' && CPP_OPTION (pfile, digraphs))\n \t{\n-\t  ACCEPT_CHAR (CPP_OPEN_SQUARE);\n+\t  result->type = CPP_OPEN_SQUARE;\n \t  result->flags |= DIGRAPH;\n \t}\n       else if (c == '%' && CPP_OPTION (pfile, digraphs))\n \t{\n-\t  ACCEPT_CHAR (CPP_OPEN_BRACE);\n+\t  result->type = CPP_OPEN_BRACE;\n \t  result->flags |= DIGRAPH;\n \t}\n+      else\n+\t{\n+\t  BACKUP ();\n+\t  result->type = CPP_LESS;\n+\t}\n       break;\n \n     case '>':\n-      result->type = CPP_GREATER;\n       c = get_effective_char (pfile);\n       if (c == '=')\n-\tACCEPT_CHAR (CPP_GREATER_EQ);\n+\tresult->type = CPP_GREATER_EQ;\n       else if (c == '>')\n-\t{\n-\t  ACCEPT_CHAR (CPP_RSHIFT);\n-\t  if (get_effective_char (pfile) == '=')\n-\t    ACCEPT_CHAR (CPP_RSHIFT_EQ);\n-\t}\n+\tIF_NEXT_IS ('=', CPP_RSHIFT_EQ, CPP_RSHIFT);\n       else if (c == '?' && CPP_OPTION (pfile, cplusplus))\n+\tIF_NEXT_IS ('=', CPP_MAX_EQ, CPP_MAX);\n+      else\n \t{\n-\t  ACCEPT_CHAR (CPP_MAX);\n-\t  if (get_effective_char (pfile) == '=')\n-\t    ACCEPT_CHAR (CPP_MAX_EQ);\n+\t  BACKUP ();\n+\t  result->type = CPP_GREATER;\n \t}\n       break;\n \n     case '%':\n-      lex_percent (pfile, result);\n+      c = get_effective_char (pfile);\n+      if (c == '=')\n+\tresult->type = CPP_MOD_EQ;\n+      else if (CPP_OPTION (pfile, digraphs) && c == ':')\n+\t{\n+\t  result->flags |= DIGRAPH;\n+\t  result->type = CPP_HASH;\n+\t  if (get_effective_char (pfile) == '%')\n+\t    {\n+\t      const unsigned char *pos = buffer->cur;\n+\n+\t      if (get_effective_char (pfile) == ':')\n+\t\tresult->type = CPP_PASTE;\n+\t      else\n+\t\tbuffer->cur = pos - 1;\n+\t    }\n+\t  else\n+\t    BACKUP ();\n+\t}\n+      else if (CPP_OPTION (pfile, digraphs) && c == '>')\n+\t{\n+\t  result->flags |= DIGRAPH;\n+\t  result->type = CPP_CLOSE_BRACE;\n+\t}\n+      else\n+\t{\n+\t  BACKUP ();\n+\t  result->type = CPP_MOD;\n+\t}\n       break;\n \n     case '.':\n-      lex_dot (pfile, result);\n+      result->type = CPP_DOT;\n+      c = get_effective_char (pfile);\n+      if (c == '.')\n+\t{\n+\t  const unsigned char *pos = buffer->cur;\n+\n+\t  if (get_effective_char (pfile) == '.')\n+\t    result->type = CPP_ELLIPSIS;\n+\t  else\n+\t    buffer->cur = pos - 1;\n+\t}\n+      /* All known character sets have 0...9 contiguous.  */\n+      else if (c >= '0' && c <= '9')\n+\t{\n+\t  result->type = CPP_NUMBER;\n+\t  parse_number (pfile, &result->val.str, c, 1);\n+\t}\n+      else if (c == '*' && CPP_OPTION (pfile, cplusplus))\n+\tresult->type = CPP_DOT_STAR;\n+      else\n+\tBACKUP ();\n       break;\n \n     case '+':\n-      result->type = CPP_PLUS;\n       c = get_effective_char (pfile);\n-      if (c == '=')\n-\tACCEPT_CHAR (CPP_PLUS_EQ);\n-      else if (c == '+')\n-\tACCEPT_CHAR (CPP_PLUS_PLUS);\n+      if (c == '+')\n+\tresult->type = CPP_PLUS_PLUS;\n+      else if (c == '=')\n+\tresult->type = CPP_PLUS_EQ;\n+      else\n+\t{\n+\t  BACKUP ();\n+\t  result->type = CPP_PLUS;\n+\t}\n       break;\n \n     case '-':\n-      result->type = CPP_MINUS;\n       c = get_effective_char (pfile);\n       if (c == '>')\n \t{\n-\t  ACCEPT_CHAR (CPP_DEREF);\n-\t  if (CPP_OPTION (pfile, cplusplus)\n-\t      && get_effective_char (pfile) == '*')\n-\t    ACCEPT_CHAR (CPP_DEREF_STAR);\n+\t  result->type = CPP_DEREF;\n+\t  if (CPP_OPTION (pfile, cplusplus))\n+\t    {\n+\t      if (get_effective_char (pfile) == '*')\n+\t\tresult->type = CPP_DEREF_STAR;\n+\t      else\n+\t\tBACKUP ();\n+\t    }\n \t}\n-      else if (c == '=')\n-\tACCEPT_CHAR (CPP_MINUS_EQ);\n       else if (c == '-')\n-\tACCEPT_CHAR (CPP_MINUS_MINUS);\n-      break;\n-\n-    case '*':\n-      result->type = CPP_MULT;\n-      if (get_effective_char (pfile) == '=')\n-\tACCEPT_CHAR (CPP_MULT_EQ);\n-      break;\n-\n-    case '=':\n-      result->type = CPP_EQ;\n-      if (get_effective_char (pfile) == '=')\n-\tACCEPT_CHAR (CPP_EQ_EQ);\n-      break;\n-\n-    case '!':\n-      result->type = CPP_NOT;\n-      if (get_effective_char (pfile) == '=')\n-\tACCEPT_CHAR (CPP_NOT_EQ);\n+\tresult->type = CPP_MINUS_MINUS;\n+      else if (c == '=')\n+\tresult->type = CPP_MINUS_EQ;\n+      else\n+\t{\n+\t  BACKUP ();\n+\t  result->type = CPP_MINUS;\n+\t}\n       break;\n \n     case '&':\n-      result->type = CPP_AND;\n       c = get_effective_char (pfile);\n-      if (c == '=')\n-\tACCEPT_CHAR (CPP_AND_EQ);\n-      else if (c == '&')\n-\tACCEPT_CHAR (CPP_AND_AND);\n+      if (c == '&')\n+\tresult->type = CPP_AND_AND;\n+      else if (c == '=')\n+\tresult->type = CPP_AND_EQ;\n+      else\n+\t{\n+\t  BACKUP ();\n+\t  result->type = CPP_AND;\n+\t}\n       break;\n \t  \n-    case '#':\n-      result->type = CPP_HASH;\n-      if (get_effective_char (pfile) == '#')\n-\t  ACCEPT_CHAR (CPP_PASTE);\n-      break;\n-\n     case '|':\n-      result->type = CPP_OR;\n       c = get_effective_char (pfile);\n-      if (c == '=')\n-\tACCEPT_CHAR (CPP_OR_EQ);\n-      else if (c == '|')\n-\tACCEPT_CHAR (CPP_OR_OR);\n-      break;\n-\n-    case '^':\n-      result->type = CPP_XOR;\n-      if (get_effective_char (pfile) == '=')\n-\tACCEPT_CHAR (CPP_XOR_EQ);\n+      if (c == '|')\n+\tresult->type = CPP_OR_OR;\n+      else if (c == '=')\n+\tresult->type = CPP_OR_EQ;\n+      else\n+\t{\n+\t  BACKUP ();\n+\t  result->type = CPP_OR;\n+\t}\n       break;\n \n     case ':':\n-      result->type = CPP_COLON;\n       c = get_effective_char (pfile);\n       if (c == ':' && CPP_OPTION (pfile, cplusplus))\n-\tACCEPT_CHAR (CPP_SCOPE);\n+\tresult->type = CPP_SCOPE;\n       else if (c == '>' && CPP_OPTION (pfile, digraphs))\n \t{\n \t  result->flags |= DIGRAPH;\n-\t  ACCEPT_CHAR (CPP_CLOSE_SQUARE);\n+\t  result->type = CPP_CLOSE_SQUARE;\n+\t}\n+      else\n+\t{\n+\t  BACKUP ();\n+\t  result->type = CPP_COLON;\n \t}\n       break;\n \n+    case '*': IF_NEXT_IS ('=', CPP_MULT_EQ, CPP_MULT); break;\n+    case '=': IF_NEXT_IS ('=', CPP_EQ_EQ, CPP_EQ); break;\n+    case '!': IF_NEXT_IS ('=', CPP_NOT_EQ, CPP_NOT); break;\n+    case '^': IF_NEXT_IS ('=', CPP_XOR_EQ, CPP_XOR); break;\n+    case '#': IF_NEXT_IS ('#', CPP_PASTE, CPP_HASH); break;\n+\n     case '~': result->type = CPP_COMPL; break;\n     case ',': result->type = CPP_COMMA; break;\n     case '(': result->type = CPP_OPEN_PAREN; break;"}, {"sha": "2f25f87164925131f113b3ff12efd67682af9463", "filename": "gcc/cpplib.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/480709cc6c3deed4fd90c02e86920d8a3e98ceb6/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/480709cc6c3deed4fd90c02e86920d8a3e98ceb6/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=480709cc6c3deed4fd90c02e86920d8a3e98ceb6", "patch": "@@ -1784,10 +1784,6 @@ cpp_push_buffer (pfile, buffer, len, from_stage3, return_at_eof)\n \n   new->line_base = new->buf = new->cur = buffer;\n   new->rlimit = buffer + len;\n-\n-  /* No read ahead or extra char initially.  */\n-  new->read_ahead = EOF;\n-  new->extra_char = EOF;\n   new->from_stage3 = from_stage3;\n   new->prev = pfile->buffer;\n   new->return_at_eof = return_at_eof;"}, {"sha": "9390cbce3b57976c232a3c213c9425381a0000ee", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/480709cc6c3deed4fd90c02e86920d8a3e98ceb6/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/480709cc6c3deed4fd90c02e86920d8a3e98ceb6/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=480709cc6c3deed4fd90c02e86920d8a3e98ceb6", "patch": "@@ -392,8 +392,7 @@ paste_tokens (pfile, plhs, rhs)\n   /* Set pfile->cur_token as required by _cpp_lex_direct.  */\n   pfile->cur_token = _cpp_temp_token (pfile);\n   *plhs = _cpp_lex_direct (pfile);\n-  valid = (pfile->buffer->cur == pfile->buffer->rlimit\n-\t   && pfile->buffer->read_ahead == EOF);\n+  valid = pfile->buffer->cur == pfile->buffer->rlimit;\n   _cpp_pop_buffer (pfile);\n \n   return valid;"}]}