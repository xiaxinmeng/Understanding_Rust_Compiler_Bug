{"sha": "0b47c1a9a9dd7c84df337b80cc17642d153595dd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGI0N2MxYTlhOWRkN2M4NGRmMzM3YjgwY2MxNzY0MmQxNTM1OTVkZA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2011-09-27T14:55:11Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2011-09-27T14:55:11Z"}, "message": "re PR rtl-optimization/50249 (ira marks wrong value for inheriting)\n\n\tPR rtl-optimization/50249\n\t* reload1.c (reload_reg_reaches_end_p): Accept a reloadnum argument\n\tinstead of opnum and type.  All callers changed.  Remove useless\n\tdeclaration.\n\tSearch forward for other reloads of the same type for the same operand\n\tusing the same register; if any are found, return false.\n\t(reload_regs_reach_end_p): Same argument changes; all callers changed.\n\nFrom-SVN: r179272", "tree": {"sha": "8e7b9e95f4f1a507bf826e229c87aabe59135a5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e7b9e95f4f1a507bf826e229c87aabe59135a5b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b47c1a9a9dd7c84df337b80cc17642d153595dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b47c1a9a9dd7c84df337b80cc17642d153595dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b47c1a9a9dd7c84df337b80cc17642d153595dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b47c1a9a9dd7c84df337b80cc17642d153595dd/comments", "author": null, "committer": null, "parents": [{"sha": "cc8547a776d53c324e8edc19a143a1ac75e7ca0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc8547a776d53c324e8edc19a143a1ac75e7ca0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc8547a776d53c324e8edc19a143a1ac75e7ca0a"}], "stats": {"total": 51, "additions": 37, "deletions": 14}, "files": [{"sha": "bc70a4d30df0dfa7c59e1530f01e38e89a8458a9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b47c1a9a9dd7c84df337b80cc17642d153595dd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b47c1a9a9dd7c84df337b80cc17642d153595dd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0b47c1a9a9dd7c84df337b80cc17642d153595dd", "patch": "@@ -1,3 +1,13 @@\n+2011-09-27  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\tPR rtl-optimization/50249\n+\t* reload1.c (reload_reg_reaches_end_p): Accept a reloadnum argument\n+\tinstead of opnum and type.  All callers changed.  Remove useless\n+\tdeclaration.\n+\tSearch forward for other reloads of the same type for the same operand\n+\tusing the same register; if any are found, return false.\n+\t(reload_regs_reach_end_p): Same argument changes; all callers changed.\n+\n 2011-09-27  Andi Kleen  <ak@linux.intel.com>\n \t    Jan Hubicka  <jh@suse.cz>\n "}, {"sha": "6070eaa81a6494a559007b13a78c286f40eded7c", "filename": "gcc/reload1.c", "status": "modified", "additions": 27, "deletions": 14, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b47c1a9a9dd7c84df337b80cc17642d153595dd/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b47c1a9a9dd7c84df337b80cc17642d153595dd/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=0b47c1a9a9dd7c84df337b80cc17642d153595dd", "patch": "@@ -396,7 +396,6 @@ static int reload_reg_free_for_value_p (int, int, int, enum reload_type,\n \t\t\t\t\trtx, rtx, int, int);\n static int free_for_value_p (int, enum machine_mode, int, enum reload_type,\n \t\t\t     rtx, rtx, int, int);\n-static int reload_reg_reaches_end_p (unsigned int, int, enum reload_type);\n static int allocate_reload_reg (struct insn_chain *, int, int);\n static int conflicts_with_override (rtx);\n static void failed_reload (rtx, int);\n@@ -5346,19 +5345,37 @@ reload_reg_free_p (unsigned int regno, int opnum, enum reload_type type)\n     }\n }\n \n-/* Return 1 if the value in reload reg REGNO, as used by a reload\n-   needed for the part of the insn specified by OPNUM and TYPE,\n-   is still available in REGNO at the end of the insn.\n+/* Return 1 if the value in reload reg REGNO, as used by the reload with\n+   the number RELOADNUM, is still available in REGNO at the end of the insn.\n \n    We can assume that the reload reg was already tested for availability\n    at the time it is needed, and we should not check this again,\n    in case the reg has already been marked in use.  */\n \n static int\n-reload_reg_reaches_end_p (unsigned int regno, int opnum, enum reload_type type)\n+reload_reg_reaches_end_p (unsigned int regno, int reloadnum)\n {\n+  int opnum = rld[reloadnum].opnum;\n+  enum reload_type type = rld[reloadnum].when_needed;\n   int i;\n \n+  /* See if there is a reload with the same type for this operand, using\n+     the same register. This case is not handled by the code below.  */\n+  for (i = reloadnum + 1; i < n_reloads; i++)\n+    {\n+      rtx reg;\n+      int nregs;\n+\n+      if (rld[i].opnum != opnum || rld[i].when_needed != type)\n+\tcontinue;\n+      reg = rld[i].reg_rtx;\n+      if (reg == NULL_RTX)\n+\tcontinue;\n+      nregs = hard_regno_nregs[REGNO (reg)][GET_MODE (reg)];\n+      if (regno >= REGNO (reg) && regno < REGNO (reg) + nregs)\n+\treturn 0;\n+    }\n+  \n   switch (type)\n     {\n     case RELOAD_OTHER:\n@@ -5485,13 +5502,12 @@ reload_reg_reaches_end_p (unsigned int regno, int opnum, enum reload_type type)\n    every register in the range [REGNO, REGNO + NREGS).  */\n \n static bool\n-reload_regs_reach_end_p (unsigned int regno, int nregs,\n-\t\t\t int opnum, enum reload_type type)\n+reload_regs_reach_end_p (unsigned int regno, int nregs, int reloadnum)\n {\n   int i;\n \n   for (i = 0; i < nregs; i++)\n-    if (!reload_reg_reaches_end_p (regno + i, opnum, type))\n+    if (!reload_reg_reaches_end_p (regno + i, reloadnum))\n       return false;\n   return true;\n }\n@@ -8103,8 +8119,7 @@ emit_reload_insns (struct insn_chain *chain)\n \t  /* For a multi register reload, we need to check if all or part\n \t     of the value lives to the end.  */\n \t  for (k = 0; k < nr; k++)\n-\t    if (reload_reg_reaches_end_p (i + k, rld[r].opnum,\n-\t\t\t\t\t  rld[r].when_needed))\n+\t    if (reload_reg_reaches_end_p (i + k, r))\n \t      CLEAR_HARD_REG_BIT (reg_reloaded_valid, i + k);\n \n \t  /* Maybe the spill reg contains a copy of reload_out.  */\n@@ -8135,8 +8150,7 @@ emit_reload_insns (struct insn_chain *chain)\n \t      mode = GET_MODE (reg);\n \t      regno = REGNO (reg);\n \t      nregs = hard_regno_nregs[regno][mode];\n-\t      if (reload_regs_reach_end_p (regno, nregs, rld[r].opnum,\n-\t\t\t\t\t   rld[r].when_needed))\n+\t      if (reload_regs_reach_end_p (regno, nregs, r))\n \t\t{\n \t\t  rtx out = (REG_P (rld[r].out)\n \t\t\t     ? rld[r].out\n@@ -8208,8 +8222,7 @@ emit_reload_insns (struct insn_chain *chain)\n \t      mode = GET_MODE (reg);\n \t      regno = REGNO (reg);\n \t      nregs = hard_regno_nregs[regno][mode];\n-\t      if (reload_regs_reach_end_p (regno, nregs, rld[r].opnum,\n-\t\t\t\t\t   rld[r].when_needed))\n+\t      if (reload_regs_reach_end_p (regno, nregs, r))\n \t\t{\n \t\t  int in_regno;\n \t\t  int in_nregs;"}]}