{"sha": "55a3be2f5255d69e740d61b2c5aaba1ccbc643b8", "node_id": "C_kwDOANBUbNoAKDU1YTNiZTJmNTI1NWQ2OWU3NDBkNjFiMmM1YWFiYTFjY2JjNjQzYjg", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-10-04T08:57:45Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-10-04T14:52:50Z"}, "message": "tree-optimization/102570 - teach VN about internal functions\n\nWe're now using internal functions for a lot of stuff but there's\nstill missing VN support out of laziness.  The following instantiates\nsupport and adds testcases for FRE and PRE (hoisting).\n\n2021-10-04  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/102570\n\t* tree-ssa-sccvn.h (vn_reference_op_struct): Document\n\twe are using clique for the internal function code.\n\t* tree-ssa-sccvn.c (vn_reference_op_eq): Compare the\n\tinternal function code.\n\t(print_vn_reference_ops): Print the internal function code.\n\t(vn_reference_op_compute_hash): Hash it.\n\t(copy_reference_ops_from_call): Record it.\n\t(visit_stmt): Remove the restriction around internal function\n\tcalls.\n\t(fully_constant_vn_reference_p): Use fold_const_call and handle\n\tinternal functions.\n\t(vn_reference_eq): Compare call return types.\n\t* tree-ssa-pre.c (create_expression_by_pieces): Handle\n\tgenerating calls to internal functions.\n\t(compute_avail): Remove the restriction around internal function\n\tcalls.\n\n\t* gcc.dg/tree-ssa/ssa-fre-96.c: New testcase.\n\t* gcc.dg/tree-ssa/ssa-pre-33.c: Likewise.", "tree": {"sha": "cfa0ab6b826ab7ef1d8368fd4bae6aefe420614e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cfa0ab6b826ab7ef1d8368fd4bae6aefe420614e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/55a3be2f5255d69e740d61b2c5aaba1ccbc643b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55a3be2f5255d69e740d61b2c5aaba1ccbc643b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55a3be2f5255d69e740d61b2c5aaba1ccbc643b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55a3be2f5255d69e740d61b2c5aaba1ccbc643b8/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22d34a2a50651d01669b6fbcdb9677c18d2197c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22d34a2a50651d01669b6fbcdb9677c18d2197c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22d34a2a50651d01669b6fbcdb9677c18d2197c5"}], "stats": {"total": 150, "additions": 103, "deletions": 47}, "files": [{"sha": "fd1d5713b5f4c0ad687f8c890c9380ab4a3dcea1", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-96.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55a3be2f5255d69e740d61b2c5aaba1ccbc643b8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-96.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55a3be2f5255d69e740d61b2c5aaba1ccbc643b8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-96.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-96.c?ref=55a3be2f5255d69e740d61b2c5aaba1ccbc643b8", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-fre1\" } */\n+\n+_Bool f1(unsigned x, unsigned y, unsigned *res)\n+{\n+    _Bool t = __builtin_add_overflow(x, y, res);\n+    unsigned res1;\n+    _Bool t1 = __builtin_add_overflow(x, y, &res1);\n+    *res -= res1;\n+    return t==t1;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"ADD_OVERFLOW\" 1 \"fre1\" } } */\n+/* { dg-final { scan-tree-dump \"return 1;\" \"fre1\" } } */"}, {"sha": "3b3bd629bc25eb202eff9e54141b6128d915098e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-33.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55a3be2f5255d69e740d61b2c5aaba1ccbc643b8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-33.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55a3be2f5255d69e740d61b2c5aaba1ccbc643b8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-33.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-33.c?ref=55a3be2f5255d69e740d61b2c5aaba1ccbc643b8", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-pre\" } */\n+\n+_Bool f1(unsigned x, unsigned y, unsigned *res, int flag, _Bool *t)\n+{\n+  if (flag)\n+    *t = __builtin_add_overflow(x, y, res);\n+  unsigned res1;\n+  _Bool t1 = __builtin_add_overflow(x, y, &res1);\n+  *res -= res1;\n+  return *t==t1;\n+}\n+\n+/* We should hoist the .ADD_OVERFLOW to before the check.  */\n+/* { dg-final { scan-tree-dump-times \"ADD_OVERFLOW\" 1 \"pre\" } } */"}, {"sha": "1cc1aae694fe9083125d84ea93d4ef4938d7c983", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55a3be2f5255d69e740d61b2c5aaba1ccbc643b8/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55a3be2f5255d69e740d61b2c5aaba1ccbc643b8/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=55a3be2f5255d69e740d61b2c5aaba1ccbc643b8", "patch": "@@ -2855,9 +2855,13 @@ create_expression_by_pieces (basic_block block, pre_expr expr,\n \t  unsigned int operand = 1;\n \t  vn_reference_op_t currop = &ref->operands[0];\n \t  tree sc = NULL_TREE;\n-\t  tree fn  = find_or_generate_expression (block, currop->op0, stmts);\n-\t  if (!fn)\n-\t    return NULL_TREE;\n+\t  tree fn = NULL_TREE;\n+\t  if (currop->op0)\n+\t    {\n+\t      fn = find_or_generate_expression (block, currop->op0, stmts);\n+\t      if (!fn)\n+\t\treturn NULL_TREE;\n+\t    }\n \t  if (currop->op1)\n \t    {\n \t      sc = find_or_generate_expression (block, currop->op1, stmts);\n@@ -2873,12 +2877,19 @@ create_expression_by_pieces (basic_block block, pre_expr expr,\n \t\treturn NULL_TREE;\n \t      args.quick_push (arg);\n \t    }\n-\t  gcall *call = gimple_build_call_vec (fn, args);\n+\t  gcall *call;\n+\t  if (currop->op0)\n+\t    {\n+\t      call = gimple_build_call_vec (fn, args);\n+\t      gimple_call_set_fntype (call, currop->type);\n+\t    }\n+\t  else\n+\t    call = gimple_build_call_internal_vec ((internal_fn)currop->clique,\n+\t\t\t\t\t\t   args);\n \t  gimple_set_location (call, expr->loc);\n-\t  gimple_call_set_fntype (call, currop->type);\n \t  if (sc)\n \t    gimple_call_set_chain (call, sc);\n-\t  tree forcedname = make_ssa_name (TREE_TYPE (currop->type));\n+\t  tree forcedname = make_ssa_name (ref->type);\n \t  gimple_call_set_lhs (call, forcedname);\n \t  /* There's no CCP pass after PRE which would re-compute alignment\n \t     information so make sure we re-materialize this here.  */\n@@ -4004,10 +4015,6 @@ compute_avail (function *fun)\n \t\tvn_reference_s ref1;\n \t\tpre_expr result = NULL;\n \n-\t\t/* We can value number only calls to real functions.  */\n-\t\tif (gimple_call_internal_p (stmt))\n-\t\t  continue;\n-\n \t\tvn_reference_lookup_call (as_a <gcall *> (stmt), &ref, &ref1);\n \t\t/* There is no point to PRE a call without a value.  */\n \t\tif (!ref || !ref->result)"}, {"sha": "0d9422182794f561a9bb50ce4b186a07a9d74c73", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 55, "deletions": 36, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55a3be2f5255d69e740d61b2c5aaba1ccbc643b8/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55a3be2f5255d69e740d61b2c5aaba1ccbc643b8/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=55a3be2f5255d69e740d61b2c5aaba1ccbc643b8", "patch": "@@ -70,6 +70,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-scalar-evolution.h\"\n #include \"tree-ssa-loop-niter.h\"\n #include \"builtins.h\"\n+#include \"fold-const-call.h\"\n #include \"tree-ssa-sccvn.h\"\n \n /* This algorithm is based on the SCC algorithm presented by Keith\n@@ -212,7 +213,8 @@ vn_reference_op_eq (const void *p1, const void *p2)\n \t\t\t\t\t TYPE_MAIN_VARIANT (vro2->type))))\n \t  && expressions_equal_p (vro1->op0, vro2->op0)\n \t  && expressions_equal_p (vro1->op1, vro2->op1)\n-\t  && expressions_equal_p (vro1->op2, vro2->op2));\n+\t  && expressions_equal_p (vro1->op2, vro2->op2)\n+\t  && (vro1->opcode != CALL_EXPR || vro1->clique == vro2->clique));\n }\n \n /* Free a reference operation structure VP.  */\n@@ -264,15 +266,18 @@ print_vn_reference_ops (FILE *outfile, const vec<vn_reference_op_s> ops)\n \t  && TREE_CODE_CLASS (vro->opcode) != tcc_declaration)\n \t{\n \t  fprintf (outfile, \"%s\", get_tree_code_name (vro->opcode));\n-\t  if (vro->op0)\n+\t  if (vro->op0 || vro->opcode == CALL_EXPR)\n \t    {\n \t      fprintf (outfile, \"<\");\n \t      closebrace = true;\n \t    }\n \t}\n-      if (vro->op0)\n+      if (vro->op0 || vro->opcode == CALL_EXPR)\n \t{\n-\t  print_generic_expr (outfile, vro->op0);\n+\t  if (!vro->op0)\n+\t    fprintf (outfile, internal_fn_name ((internal_fn)vro->clique));\n+\t  else\n+\t    print_generic_expr (outfile, vro->op0);\n \t  if (vro->op1)\n \t    {\n \t      fprintf (outfile, \",\");\n@@ -684,6 +689,8 @@ static void\n vn_reference_op_compute_hash (const vn_reference_op_t vro1, inchash::hash &hstate)\n {\n   hstate.add_int (vro1->opcode);\n+  if (vro1->opcode == CALL_EXPR && !vro1->op0)\n+    hstate.add_int (vro1->clique);\n   if (vro1->op0)\n     inchash::add_expr (vro1->op0, hstate);\n   if (vro1->op1)\n@@ -769,11 +776,16 @@ vn_reference_eq (const_vn_reference_t const vr1, const_vn_reference_t const vr2)\n       if (vr1->type != vr2->type)\n \treturn false;\n     }\n+  else if (vr1->type == vr2->type)\n+    ;\n   else if (COMPLETE_TYPE_P (vr1->type) != COMPLETE_TYPE_P (vr2->type)\n \t   || (COMPLETE_TYPE_P (vr1->type)\n \t       && !expressions_equal_p (TYPE_SIZE (vr1->type),\n \t\t\t\t\tTYPE_SIZE (vr2->type))))\n     return false;\n+  else if (vr1->operands[0].opcode == CALL_EXPR\n+\t   && !types_compatible_p (vr1->type, vr2->type))\n+    return false;\n   else if (INTEGRAL_TYPE_P (vr1->type)\n \t   && INTEGRAL_TYPE_P (vr2->type))\n     {\n@@ -1270,6 +1282,8 @@ copy_reference_ops_from_call (gcall *call,\n   temp.type = gimple_call_fntype (call);\n   temp.opcode = CALL_EXPR;\n   temp.op0 = gimple_call_fn (call);\n+  if (gimple_call_internal_p (call))\n+    temp.clique = gimple_call_internal_fn (call);\n   temp.op1 = gimple_call_chain (call);\n   if (stmt_could_throw_p (cfun, call) && (lr = lookup_stmt_eh_lp (call)) > 0)\n     temp.op2 = size_int (lr);\n@@ -1459,9 +1473,11 @@ fully_constant_vn_reference_p (vn_reference_t ref)\n      a call to a builtin function with at most two arguments.  */\n   op = &operands[0];\n   if (op->opcode == CALL_EXPR\n-      && TREE_CODE (op->op0) == ADDR_EXPR\n-      && TREE_CODE (TREE_OPERAND (op->op0, 0)) == FUNCTION_DECL\n-      && fndecl_built_in_p (TREE_OPERAND (op->op0, 0))\n+      && (!op->op0\n+\t  || (TREE_CODE (op->op0) == ADDR_EXPR\n+\t      && TREE_CODE (TREE_OPERAND (op->op0, 0)) == FUNCTION_DECL\n+\t      && fndecl_built_in_p (TREE_OPERAND (op->op0, 0),\n+\t\t\t\t    BUILT_IN_NORMAL)))\n       && operands.length () >= 2\n       && operands.length () <= 3)\n     {\n@@ -1481,13 +1497,17 @@ fully_constant_vn_reference_p (vn_reference_t ref)\n \tanyconst = true;\n       if (anyconst)\n \t{\n-\t  tree folded = build_call_expr (TREE_OPERAND (op->op0, 0),\n-\t\t\t\t\t arg1 ? 2 : 1,\n-\t\t\t\t\t arg0->op0,\n-\t\t\t\t\t arg1 ? arg1->op0 : NULL);\n-\t  if (folded\n-\t      && TREE_CODE (folded) == NOP_EXPR)\n-\t    folded = TREE_OPERAND (folded, 0);\n+\t  combined_fn fn;\n+\t  if (op->op0)\n+\t    fn = as_combined_fn (DECL_FUNCTION_CODE\n+\t\t\t\t\t(TREE_OPERAND (op->op0, 0)));\n+\t  else\n+\t    fn = as_combined_fn ((internal_fn) op->clique);\n+\t  tree folded;\n+\t  if (arg1)\n+\t    folded = fold_const_call (fn, ref->type, arg0->op0, arg1->op0);\n+\t  else\n+\t    folded = fold_const_call (fn, ref->type, arg0->op0);\n \t  if (folded\n \t      && is_gimple_min_invariant (folded))\n \t    return folded;\n@@ -5648,28 +5668,27 @@ visit_stmt (gimple *stmt, bool backedges_varying_p = false)\n \t      && TREE_CODE (TREE_OPERAND (fn, 0)) == FUNCTION_DECL)\n \t    extra_fnflags = flags_from_decl_or_type (TREE_OPERAND (fn, 0));\n \t}\n-      if (!gimple_call_internal_p (call_stmt)\n-\t  && (/* Calls to the same function with the same vuse\n-\t\t and the same operands do not necessarily return the same\n-\t\t value, unless they're pure or const.  */\n-\t      ((gimple_call_flags (call_stmt) | extra_fnflags)\n-\t       & (ECF_PURE | ECF_CONST))\n-\t      /* If calls have a vdef, subsequent calls won't have\n-\t\t the same incoming vuse.  So, if 2 calls with vdef have the\n-\t\t same vuse, we know they're not subsequent.\n-\t\t We can value number 2 calls to the same function with the\n-\t\t same vuse and the same operands which are not subsequent\n-\t\t the same, because there is no code in the program that can\n-\t\t compare the 2 values...  */\n-\t      || (gimple_vdef (call_stmt)\n-\t\t  /* ... unless the call returns a pointer which does\n-\t\t     not alias with anything else.  In which case the\n-\t\t     information that the values are distinct are encoded\n-\t\t     in the IL.  */\n-\t\t  && !(gimple_call_return_flags (call_stmt) & ERF_NOALIAS)\n-\t\t  /* Only perform the following when being called from PRE\n-\t\t     which embeds tail merging.  */\n-\t\t  && default_vn_walk_kind == VN_WALK)))\n+      if (/* Calls to the same function with the same vuse\n+\t     and the same operands do not necessarily return the same\n+\t     value, unless they're pure or const.  */\n+\t  ((gimple_call_flags (call_stmt) | extra_fnflags)\n+\t   & (ECF_PURE | ECF_CONST))\n+\t  /* If calls have a vdef, subsequent calls won't have\n+\t     the same incoming vuse.  So, if 2 calls with vdef have the\n+\t     same vuse, we know they're not subsequent.\n+\t     We can value number 2 calls to the same function with the\n+\t     same vuse and the same operands which are not subsequent\n+\t     the same, because there is no code in the program that can\n+\t     compare the 2 values...  */\n+\t  || (gimple_vdef (call_stmt)\n+\t      /* ... unless the call returns a pointer which does\n+\t\t not alias with anything else.  In which case the\n+\t\t information that the values are distinct are encoded\n+\t\t in the IL.  */\n+\t      && !(gimple_call_return_flags (call_stmt) & ERF_NOALIAS)\n+\t      /* Only perform the following when being called from PRE\n+\t\t which embeds tail merging.  */\n+\t      && default_vn_walk_kind == VN_WALK))\n \tchanged = visit_reference_op_call (lhs, call_stmt);\n       else\n \tchanged = defs_to_varying (call_stmt);"}, {"sha": "8a1b649c726bf2d05bcf3407f13b1a583dd46b78", "filename": "gcc/tree-ssa-sccvn.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55a3be2f5255d69e740d61b2c5aaba1ccbc643b8/gcc%2Ftree-ssa-sccvn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55a3be2f5255d69e740d61b2c5aaba1ccbc643b8/gcc%2Ftree-ssa-sccvn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.h?ref=55a3be2f5255d69e740d61b2c5aaba1ccbc643b8", "patch": "@@ -106,7 +106,8 @@ typedef const struct vn_phi_s *const_vn_phi_t;\n typedef struct vn_reference_op_struct\n {\n   ENUM_BITFIELD(tree_code) opcode : 16;\n-  /* Dependence info, used for [TARGET_]MEM_REF only.  */\n+  /* Dependence info, used for [TARGET_]MEM_REF only.  For internal\n+     function calls clique is also used for the internal function code.  */\n   unsigned short clique;\n   unsigned short base;\n   unsigned reverse : 1;"}]}