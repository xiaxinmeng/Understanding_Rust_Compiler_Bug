{"sha": "3a8b20947f2b1559a7d5dcb62918f91344908c62", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2E4YjIwOTQ3ZjJiMTU1OWE3ZDVkY2I2MjkxOGY5MTM0NDkwOGM2Mg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-10-28T09:38:01Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-10-28T09:38:01Z"}, "message": "openmp: Parsing and some semantic analysis of OpenMP allocate clause\n\nThis patch adds parsing of OpenMP allocate clause, but still ignores\nit during OpenMP lowering where we should for privatized variables\nwith allocate clause use the corresponding allocators rather than\nallocating them on the stack.\n\n2020-10-28  Jakub Jelinek  <jakub@redhat.com>\n\ngcc/\n\t* tree-core.h (enum omp_clause_code): Add OMP_CLAUSE_ALLOCATE.\n\t* tree.h (OMP_CLAUSE_ALLOCATE_ALLOCATOR,\n\tOMP_CLAUSE_ALLOCATE_COMBINED): Define.\n\t* tree.c (omp_clause_num_ops, omp_clause_code_name): Add allocate\n\tclause.\n\t(walk_tree_1): Handle OMP_CLAUSE_ALLOCATE.\n\t* tree-pretty-print.c (dump_omp_clause): Likewise.\n\t* gimplify.c (gimplify_scan_omp_clauses, gimplify_adjust_omp_clauses,\n\tgimplify_omp_for): Likewise.\n\t* tree-nested.c (convert_nonlocal_omp_clauses,\n\tconvert_local_omp_clauses): Likewise.\n\t* omp-low.c (scan_sharing_clauses): Likewise.\ngcc/c-family/\n\t* c-pragma.h (enum pragma_omp_clause): Add PRAGMA_OMP_CLAUSE_ALLOCATE.\n\t* c-omp.c: Include bitmap.h.\n\t(c_omp_split_clauses): Handle OMP_CLAUSE_ALLOCATE.\ngcc/c/\n\t* c-parser.c (c_parser_omp_clause_name): Handle allocate.\n\t(c_parser_omp_clause_allocate): New function.\n\t(c_parser_omp_all_clauses): Handle PRAGMA_OMP_CLAUSE_ALLOCATE.\n\t(OMP_FOR_CLAUSE_MASK, OMP_SECTIONS_CLAUSE_MASK,\n\tOMP_PARALLEL_CLAUSE_MASK, OMP_SINGLE_CLAUSE_MASK,\n\tOMP_TASK_CLAUSE_MASK, OMP_TASKGROUP_CLAUSE_MASK,\n\tOMP_DISTRIBUTE_CLAUSE_MASK, OMP_TEAMS_CLAUSE_MASK,\n\tOMP_TARGET_CLAUSE_MASK, OMP_TASKLOOP_CLAUSE_MASK): Add\n\tPRAGMA_OMP_CLAUSE_ALLOCATE.\n\t* c-typeck.c (c_finish_omp_clauses): Handle OMP_CLAUSE_ALLOCATE.\ngcc/cp/\n\t* parser.c (cp_parser_omp_clause_name): Handle allocate.\n\t(cp_parser_omp_clause_allocate): New function.\n\t(cp_parser_omp_all_clauses): Handle PRAGMA_OMP_CLAUSE_ALLOCATE.\n\t(OMP_FOR_CLAUSE_MASK, OMP_SECTIONS_CLAUSE_MASK,\n\tOMP_PARALLEL_CLAUSE_MASK, OMP_SINGLE_CLAUSE_MASK,\n\tOMP_TASK_CLAUSE_MASK, OMP_TASKGROUP_CLAUSE_MASK,\n\tOMP_DISTRIBUTE_CLAUSE_MASK, OMP_TEAMS_CLAUSE_MASK,\n\tOMP_TARGET_CLAUSE_MASK, OMP_TASKLOOP_CLAUSE_MASK): Add\n\tPRAGMA_OMP_CLAUSE_ALLOCATE.\n\t* semantics.c (finish_omp_clauses): Handle OMP_CLAUSE_ALLOCATE.\n\t* pt.c (tsubst_omp_clauses): Likewise.\ngcc/testsuite/\n\t* c-c++-common/gomp/allocate-1.c: New test.\n\t* c-c++-common/gomp/allocate-2.c: New test.\n\t* c-c++-common/gomp/clauses-1.c (omp_allocator_handle_t): New typedef.\n\t(foo, bar, baz): Add allocate clauses where allowed.", "tree": {"sha": "ff6700e4ff3c7bad2285b8786255a17effb21ef1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff6700e4ff3c7bad2285b8786255a17effb21ef1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a8b20947f2b1559a7d5dcb62918f91344908c62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a8b20947f2b1559a7d5dcb62918f91344908c62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a8b20947f2b1559a7d5dcb62918f91344908c62", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a8b20947f2b1559a7d5dcb62918f91344908c62/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2298ca2d3e133945f5034065e843e2ea0f36e0bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2298ca2d3e133945f5034065e843e2ea0f36e0bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2298ca2d3e133945f5034065e843e2ea0f36e0bb"}], "stats": {"total": 796, "additions": 739, "deletions": 57}, "files": [{"sha": "bce2f8e076f46885f18eeaee948daac7cc4aa097", "filename": "gcc/c-family/c-omp.c", "status": "modified", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a8b20947f2b1559a7d5dcb62918f91344908c62/gcc%2Fc-family%2Fc-omp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a8b20947f2b1559a7d5dcb62918f91344908c62/gcc%2Fc-family%2Fc-omp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-omp.c?ref=3a8b20947f2b1559a7d5dcb62918f91344908c62", "patch": "@@ -35,6 +35,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"attribs.h\"\n #include \"gimplify.h\"\n #include \"langhooks.h\"\n+#include \"bitmap.h\"\n \n \n /* Complete a #pragma oacc wait construct.  LOC is the location of\n@@ -1575,6 +1576,7 @@ c_omp_split_clauses (location_t loc, enum tree_code code,\n   tree next, c;\n   enum c_omp_clause_split s;\n   int i;\n+  bool has_dup_allocate = false;\n \n   for (i = 0; i < C_OMP_CLAUSE_SPLIT_COUNT; i++)\n     cclauses[i] = NULL;\n@@ -2198,13 +2200,180 @@ c_omp_split_clauses (location_t loc, enum tree_code code,\n \t  else\n \t    s = C_OMP_CLAUSE_SPLIT_FOR;\n \t  break;\n+\t/* Allocate clause is allowed on target, teams, distribute, parallel,\n+\t   for, sections and taskloop.  Distribute it to all.  */\n+\tcase OMP_CLAUSE_ALLOCATE:\n+\t  s = C_OMP_CLAUSE_SPLIT_COUNT;\n+\t  for (i = 0; i < C_OMP_CLAUSE_SPLIT_COUNT; i++)\n+\t    {\n+\t      switch (i)\n+\t\t{\n+\t\tcase C_OMP_CLAUSE_SPLIT_TARGET:\n+\t\t  if ((mask & (OMP_CLAUSE_MASK_1\n+\t\t\t       << PRAGMA_OMP_CLAUSE_MAP)) == 0)\n+\t\t    continue;\n+\t\t  break;\n+\t\tcase C_OMP_CLAUSE_SPLIT_TEAMS:\n+\t\t  if ((mask & (OMP_CLAUSE_MASK_1\n+\t\t\t       << PRAGMA_OMP_CLAUSE_NUM_TEAMS)) == 0)\n+\t\t    continue;\n+\t\t  break;\n+\t\tcase C_OMP_CLAUSE_SPLIT_DISTRIBUTE:\n+\t\t  if ((mask & (OMP_CLAUSE_MASK_1\n+\t\t\t       << PRAGMA_OMP_CLAUSE_DIST_SCHEDULE)) == 0)\n+\t\t    continue;\n+\t\t  break;\n+\t\tcase C_OMP_CLAUSE_SPLIT_PARALLEL:\n+\t\t  if ((mask & (OMP_CLAUSE_MASK_1\n+\t\t\t       << PRAGMA_OMP_CLAUSE_NUM_THREADS)) == 0)\n+\t\t    continue;\n+\t\t  break;\n+\t\tcase C_OMP_CLAUSE_SPLIT_FOR:\n+\t\t  STATIC_ASSERT (C_OMP_CLAUSE_SPLIT_SECTIONS\n+\t\t\t\t == C_OMP_CLAUSE_SPLIT_FOR\n+\t\t\t\t && (C_OMP_CLAUSE_SPLIT_TASKLOOP\n+\t\t\t\t     == C_OMP_CLAUSE_SPLIT_FOR)\n+\t\t\t\t && (C_OMP_CLAUSE_SPLIT_LOOP\n+\t\t\t\t     == C_OMP_CLAUSE_SPLIT_FOR));\n+\t\t  if (code == OMP_SECTIONS)\n+\t\t    break;\n+\t\t  if ((mask & (OMP_CLAUSE_MASK_1\n+\t\t\t       << PRAGMA_OMP_CLAUSE_SCHEDULE)) != 0)\n+\t\t    break;\n+\t\t  if ((mask & (OMP_CLAUSE_MASK_1\n+\t\t\t       << PRAGMA_OMP_CLAUSE_NOGROUP)) != 0)\n+\t\t    break;\n+\t\t  continue;\n+\t\tcase C_OMP_CLAUSE_SPLIT_SIMD:\n+\t\t  continue;\n+\t\tdefault:\n+\t\t  gcc_unreachable ();\n+\t\t}\n+\t      if (s != C_OMP_CLAUSE_SPLIT_COUNT)\n+\t\t{\n+\t\t  c = build_omp_clause (OMP_CLAUSE_LOCATION (clauses),\n+\t\t\t\t\tOMP_CLAUSE_ALLOCATE);\n+\t\t  OMP_CLAUSE_DECL (c)\n+\t\t    = OMP_CLAUSE_DECL (clauses);\n+\t\t  OMP_CLAUSE_ALLOCATE_ALLOCATOR (c)\n+\t\t    = OMP_CLAUSE_ALLOCATE_ALLOCATOR (clauses);\n+\t\t  OMP_CLAUSE_CHAIN (c) = cclauses[s];\n+\t\t  cclauses[s] = c;\n+\t\t  has_dup_allocate = true;\n+\t\t}\n+\t      s = (enum c_omp_clause_split) i;\n+\t    }\n+\t  gcc_assert (s != C_OMP_CLAUSE_SPLIT_COUNT);\n+\t  break;\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n       OMP_CLAUSE_CHAIN (clauses) = cclauses[s];\n       cclauses[s] = clauses;\n     }\n \n+  if (has_dup_allocate)\n+    {\n+      bool need_prune = false;\n+      bitmap_obstack_initialize (NULL);\n+      for (i = 0; i < C_OMP_CLAUSE_SPLIT_SIMD - (code == OMP_LOOP); i++)\n+\tif (cclauses[i])\n+\t  {\n+\t    bitmap_head allocate_head;\n+\t    bitmap_initialize (&allocate_head, &bitmap_default_obstack);\n+\t    for (c = cclauses[i]; c; c = OMP_CLAUSE_CHAIN (c))\n+\t      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_ALLOCATE\n+\t\t  && DECL_P (OMP_CLAUSE_DECL (c)))\n+\t\tbitmap_set_bit (&allocate_head,\n+\t\t\t\tDECL_UID (OMP_CLAUSE_DECL (c)));\n+\t    for (c = cclauses[i]; c; c = OMP_CLAUSE_CHAIN (c))\n+\t      switch (OMP_CLAUSE_CODE (c))\n+\t\t{\n+\t\tcase OMP_CLAUSE_PRIVATE:\n+\t\tcase OMP_CLAUSE_FIRSTPRIVATE:\n+\t\tcase OMP_CLAUSE_LASTPRIVATE:\n+\t\tcase OMP_CLAUSE_LINEAR:\n+\t\tcase OMP_CLAUSE_REDUCTION:\n+\t\tcase OMP_CLAUSE_IN_REDUCTION:\n+\t\tcase OMP_CLAUSE_TASK_REDUCTION:\n+\t\t  if (DECL_P (OMP_CLAUSE_DECL (c)))\n+\t\t    bitmap_clear_bit (&allocate_head,\n+\t\t\t\t      DECL_UID (OMP_CLAUSE_DECL (c)));\n+\t\t  break;\n+\t\tdefault:\n+\t\t  break;\n+\t\t}\n+\t    for (c = cclauses[i]; c; c = OMP_CLAUSE_CHAIN (c))\n+\t      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_ALLOCATE\n+\t\t  && DECL_P (OMP_CLAUSE_DECL (c))\n+\t\t  && bitmap_bit_p (&allocate_head,\n+\t\t\t\t   DECL_UID (OMP_CLAUSE_DECL (c))))\n+\t\t{\n+\t\t  /* Mark allocate clauses which don't have corresponding\n+\t\t     explicit data sharing clause.  */\n+\t\t  OMP_CLAUSE_ALLOCATE_COMBINED (c) = 1;\n+\t\t  need_prune = true;\n+\t\t}\n+\t  }\n+      bitmap_obstack_release (NULL);\n+      if (need_prune)\n+\t{\n+\t  /* At least one allocate clause has been marked.  Walk all the\n+\t     duplicated allocate clauses in sync.  If it is marked in all\n+\t     constituent constructs, diagnose it as invalid and remove\n+\t     them.  Otherwise, remove all marked inner clauses inside\n+\t     a construct that doesn't have them marked.  Keep the outer\n+\t     marked ones, because some clause duplication is done only\n+\t     during gimplification.  */\n+\t  tree *p[C_OMP_CLAUSE_SPLIT_COUNT];\n+\t  for (i = 0; i < C_OMP_CLAUSE_SPLIT_COUNT; i++)\n+\t    if (cclauses[i] == NULL_TREE\n+\t\t|| i == C_OMP_CLAUSE_SPLIT_SIMD\n+\t\t|| (i == C_OMP_CLAUSE_SPLIT_LOOP && code == OMP_LOOP))\n+\t      p[i] = NULL;\n+\t    else\n+\t      p[i] = &cclauses[i];\n+\t  do\n+\t    {\n+\t      int j = -1;\n+\t      tree seen = NULL_TREE;\n+\t      for (i = C_OMP_CLAUSE_SPLIT_COUNT - 1; i >= 0; i--)\n+\t\tif (p[i])\n+\t\t  {\n+\t\t    while (*p[i]\n+\t\t\t   && OMP_CLAUSE_CODE (*p[i]) != OMP_CLAUSE_ALLOCATE)\n+\t\t      p[i] = &OMP_CLAUSE_CHAIN (*p[i]);\n+\t\t    if (*p[i] == NULL_TREE)\n+\t\t      {\n+\t\t\ti = C_OMP_CLAUSE_SPLIT_COUNT;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t    if (!OMP_CLAUSE_ALLOCATE_COMBINED (*p[i]) && j == -1)\n+\t\t      j = i;\n+\t\t    seen = *p[i];\n+\t\t  }\n+\t      if (i == C_OMP_CLAUSE_SPLIT_COUNT)\n+\t\tbreak;\n+\t      if (j == -1)\n+\t\terror_at (OMP_CLAUSE_LOCATION (seen),\n+\t\t\t  \"%qD specified in %<allocate%> clause but not in \"\n+\t\t\t  \"an explicit privatization clause\",\n+\t\t\t  OMP_CLAUSE_DECL (seen));\n+\t      for (i = 0; i < C_OMP_CLAUSE_SPLIT_COUNT; i++)\n+\t\tif (p[i])\n+\t\t  {\n+\t\t    if (i > j)\n+\t\t      /* Remove.  */\n+\t\t      *p[i] = OMP_CLAUSE_CHAIN (*p[i]);\n+\t\t    else\n+\t\t      /* Keep.  */\n+\t\t      p[i] = &OMP_CLAUSE_CHAIN (*p[i]);\n+\t\t  }\n+\t    }\n+\t  while (1);\n+\t}\n+    }\n+\n   if (!flag_checking)\n     return;\n "}, {"sha": "5a493fe51753b91547d2af0e9d3f2ea740ed44a1", "filename": "gcc/c-family/c-pragma.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a8b20947f2b1559a7d5dcb62918f91344908c62/gcc%2Fc-family%2Fc-pragma.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a8b20947f2b1559a7d5dcb62918f91344908c62/gcc%2Fc-family%2Fc-pragma.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.h?ref=3a8b20947f2b1559a7d5dcb62918f91344908c62", "patch": "@@ -86,6 +86,7 @@ enum pragma_omp_clause {\n   PRAGMA_OMP_CLAUSE_NONE = 0,\n \n   PRAGMA_OMP_CLAUSE_ALIGNED,\n+  PRAGMA_OMP_CLAUSE_ALLOCATE,\n   PRAGMA_OMP_CLAUSE_BIND,\n   PRAGMA_OMP_CLAUSE_COLLAPSE,\n   PRAGMA_OMP_CLAUSE_COPYIN,"}, {"sha": "b921c4e3852765644f0fad0eecd8e127175f2de0", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 73, "deletions": 1, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a8b20947f2b1559a7d5dcb62918f91344908c62/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a8b20947f2b1559a7d5dcb62918f91344908c62/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=3a8b20947f2b1559a7d5dcb62918f91344908c62", "patch": "@@ -12603,6 +12603,8 @@ c_parser_omp_clause_name (c_parser *parser)\n \tcase 'a':\n \t  if (!strcmp (\"aligned\", p))\n \t    result = PRAGMA_OMP_CLAUSE_ALIGNED;\n+\t  else if (!strcmp (\"allocate\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_ALLOCATE;\n \t  else if (!strcmp (\"async\", p))\n \t    result = PRAGMA_OACC_CLAUSE_ASYNC;\n \t  else if (!strcmp (\"attach\", p))\n@@ -15112,6 +15114,62 @@ c_parser_omp_clause_aligned (c_parser *parser, tree list)\n   return nl;\n }\n \n+/* OpenMP 5.0:\n+   allocate ( variable-list )\n+   allocate ( expression : variable-list ) */\n+\n+static tree\n+c_parser_omp_clause_allocate (c_parser *parser, tree list)\n+{\n+  location_t clause_loc = c_parser_peek_token (parser)->location;\n+  tree nl, c;\n+  tree allocator = NULL_TREE;\n+\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n+    return list;\n+\n+  if ((c_parser_next_token_is_not (parser, CPP_NAME)\n+       && c_parser_next_token_is_not (parser, CPP_KEYWORD))\n+      || (c_parser_peek_2nd_token (parser)->type != CPP_COMMA\n+\t  && c_parser_peek_2nd_token (parser)->type != CPP_CLOSE_PAREN))\n+    {\n+      location_t expr_loc = c_parser_peek_token (parser)->location;\n+      c_expr expr = c_parser_expr_no_commas (parser, NULL);\n+      expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);\n+      allocator = expr.value;\n+      allocator = c_fully_fold (allocator, false, NULL);\n+      tree orig_type\n+\t= expr.original_type ? expr.original_type : TREE_TYPE (allocator);\n+      orig_type = TYPE_MAIN_VARIANT (orig_type);\n+      if (!INTEGRAL_TYPE_P (TREE_TYPE (allocator))\n+\t  || TREE_CODE (orig_type) != ENUMERAL_TYPE\n+\t  || TYPE_NAME (orig_type) != get_identifier (\"omp_allocator_handle_t\"))\n+        {\n+          error_at (clause_loc, \"%<allocate%> clause allocator expression \"\n+\t\t\t\t\"has type %qT rather than \"\n+\t\t\t\t\"%<omp_allocator_handle_t%>\",\n+\t\t\t\tTREE_TYPE (allocator));\n+          allocator = NULL_TREE;\n+        }\n+      if (!c_parser_require (parser, CPP_COLON, \"expected %<:%>\"))\n+\t{\n+\t  parens.skip_until_found_close (parser);\n+\t  return list;\n+\t}\n+    }\n+\n+  nl = c_parser_omp_variable_list (parser, clause_loc,\n+\t\t\t\t   OMP_CLAUSE_ALLOCATE, list);\n+\n+  if (allocator)\n+    for (c = nl; c != list; c = OMP_CLAUSE_CHAIN (c))\n+      OMP_CLAUSE_ALLOCATE_ALLOCATOR (c) = allocator;\n+\n+  parens.skip_until_found_close (parser);\n+  return nl;\n+}\n+\n /* OpenMP 4.0:\n    linear ( variable-list )\n    linear ( variable-list : expression )\n@@ -16354,6 +16412,10 @@ c_parser_omp_all_clauses (c_parser *parser, omp_clause_mask mask,\n \t  clauses = c_parser_omp_clause_aligned (parser, clauses);\n \t  c_name = \"aligned\";\n \t  break;\n+\tcase PRAGMA_OMP_CLAUSE_ALLOCATE:\n+\t  clauses = c_parser_omp_clause_allocate (parser, clauses);\n+\t  c_name = \"allocate\";\n+\t  break;\n \tcase PRAGMA_OMP_CLAUSE_LINEAR: \n \t  clauses = c_parser_omp_clause_linear (parser, clauses); \n \t  c_name = \"linear\";\n@@ -18534,6 +18596,7 @@ c_parser_omp_simd (location_t loc, c_parser *parser,\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_SCHEDULE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_COLLAPSE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NOWAIT)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_ALLOCATE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_ORDER))\n \n static tree\n@@ -18825,6 +18888,7 @@ c_parser_omp_sections_scope (location_t sections_loc, c_parser *parser)\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_LASTPRIVATE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_REDUCTION)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_ALLOCATE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NOWAIT))\n \n static tree\n@@ -18879,6 +18943,7 @@ c_parser_omp_sections (location_t loc, c_parser *parser,\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_COPYIN)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_REDUCTION)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NUM_THREADS)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_ALLOCATE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_PROC_BIND))\n \n static tree\n@@ -19020,6 +19085,7 @@ c_parser_omp_parallel (location_t loc, c_parser *parser,\n \t( (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_PRIVATE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_COPYPRIVATE)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_ALLOCATE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NOWAIT))\n \n static tree\n@@ -19054,6 +19120,7 @@ c_parser_omp_single (location_t loc, c_parser *parser, bool *if_p)\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_MERGEABLE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEPEND)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_PRIORITY)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_ALLOCATE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_IN_REDUCTION))\n \n static tree\n@@ -19124,7 +19191,8 @@ c_parser_omp_taskyield (c_parser *parser)\n */\n \n #define OMP_TASKGROUP_CLAUSE_MASK\t\t\t\t\\\n-\t( (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_TASK_REDUCTION))\n+\t( (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_ALLOCATE)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_TASK_REDUCTION))\n \n static tree\n c_parser_omp_taskgroup (location_t loc, c_parser *parser, bool *if_p)\n@@ -19225,6 +19293,7 @@ c_parser_omp_cancellation_point (c_parser *parser, enum pragma_context context)\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_LASTPRIVATE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DIST_SCHEDULE)\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_ALLOCATE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_COLLAPSE))\n \n static tree\n@@ -19314,6 +19383,7 @@ c_parser_omp_distribute (location_t loc, c_parser *parser,\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_REDUCTION)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NUM_TEAMS)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_THREAD_LIMIT)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_ALLOCATE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEFAULT))\n \n static tree\n@@ -19701,6 +19771,7 @@ c_parser_omp_target_exit_data (location_t loc, c_parser *parser,\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NOWAIT)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_PRIVATE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_ALLOCATE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEFAULTMAP)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_IS_DEVICE_PTR))\n \n@@ -21331,6 +21402,7 @@ c_finish_taskloop_clauses (tree clauses)\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_MERGEABLE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NOGROUP)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_PRIORITY)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_ALLOCATE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_REDUCTION)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_IN_REDUCTION))\n "}, {"sha": "cc9a2627d7bb2e14a601965708b327f6c9c414d1", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 61, "deletions": 1, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a8b20947f2b1559a7d5dcb62918f91344908c62/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a8b20947f2b1559a7d5dcb62918f91344908c62/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=3a8b20947f2b1559a7d5dcb62918f91344908c62", "patch": "@@ -13795,6 +13795,7 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n   /* 1 if normal/task reduction has been seen, -1 if inscan reduction\n      has been seen, -2 if mixed inscan/normal reduction diagnosed.  */\n   int reduction_seen = 0;\n+  bool allocate_seen = false;\n \n   bitmap_obstack_initialize (NULL);\n   bitmap_initialize (&generic_head, &bitmap_default_obstack);\n@@ -14344,6 +14345,29 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t    bitmap_set_bit (&oacc_reduction_head, DECL_UID (t));\n \t  break;\n \n+\tcase OMP_CLAUSE_ALLOCATE:\n+\t  t = OMP_CLAUSE_DECL (c);\n+\t  if (!VAR_P (t) && TREE_CODE (t) != PARM_DECL)\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%qE is not a variable in %<allocate%> clause\", t);\n+\t      remove = true;\n+\t    }\n+\t  else if (bitmap_bit_p (&aligned_head, DECL_UID (t)))\n+\t    {\n+\t      warning_at (OMP_CLAUSE_LOCATION (c), 0,\n+\t\t\t  \"%qE appears more than once in %<allocate%> clauses\",\n+\t\t\t  t);\n+\t      remove = true;\n+\t    }\n+\t  else\n+\t    {\n+\t      bitmap_set_bit (&aligned_head, DECL_UID (t));\n+\t      if (!OMP_CLAUSE_ALLOCATE_COMBINED (c))\n+\t\tallocate_seen = true;\n+\t    }\n+\t  break;\n+\n \tcase OMP_CLAUSE_DEPEND:\n \t  t = OMP_CLAUSE_DECL (c);\n \t  if (t == NULL_TREE)\n@@ -15041,10 +15065,27 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n       reduction_seen = -2;\n     }\n \n-  if (linear_variable_step_check || reduction_seen == -2)\n+  if (linear_variable_step_check || reduction_seen == -2 || allocate_seen)\n     for (pc = &clauses, c = clauses; c ; c = *pc)\n       {\n \tbool remove = false;\n+\tif (allocate_seen)\n+\t  switch (OMP_CLAUSE_CODE (c))\n+\t    {\n+\t    case OMP_CLAUSE_PRIVATE:\n+\t    case OMP_CLAUSE_FIRSTPRIVATE:\n+\t    case OMP_CLAUSE_LASTPRIVATE:\n+\t    case OMP_CLAUSE_LINEAR:\n+\t    case OMP_CLAUSE_REDUCTION:\n+\t    case OMP_CLAUSE_IN_REDUCTION:\n+\t    case OMP_CLAUSE_TASK_REDUCTION:\n+\t      if (DECL_P (OMP_CLAUSE_DECL (c)))\n+\t\tbitmap_clear_bit (&aligned_head,\n+\t\t\t\t  DECL_UID (OMP_CLAUSE_DECL (c)));\n+\t      break;\n+\t    default:\n+\t      break;\n+\t    }\n \tif (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LINEAR\n \t    && OMP_CLAUSE_LINEAR_VARIABLE_STRIDE (c)\n \t    && !bitmap_bit_p (&map_head,\n@@ -15065,6 +15106,25 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t  pc = &OMP_CLAUSE_CHAIN (c);\n       }\n \n+  if (allocate_seen)\n+    for (pc = &clauses, c = clauses; c ; c = *pc)\n+      {\n+\tbool remove = false;\n+\tif (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_ALLOCATE\n+\t    && !OMP_CLAUSE_ALLOCATE_COMBINED (c)\n+\t    && bitmap_bit_p (&aligned_head, DECL_UID (OMP_CLAUSE_DECL (c))))\n+\t  {\n+\t    error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t      \"%qD specified in %<allocate%> clause but not in \"\n+\t\t      \"an explicit privatization clause\", OMP_CLAUSE_DECL (c));\n+\t    remove = true;\n+\t  }\n+\tif (remove)\n+\t  *pc = OMP_CLAUSE_CHAIN (c);\n+\telse\n+\t  pc = &OMP_CLAUSE_CHAIN (c);\n+      }\n+\n   if (nogroup_seen && reduction_seen)\n     {\n       error_at (OMP_CLAUSE_LOCATION (*nogroup_seen),"}, {"sha": "03780fab0a72adb9b496022e7f00e86822912618", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 58, "deletions": 1, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a8b20947f2b1559a7d5dcb62918f91344908c62/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a8b20947f2b1559a7d5dcb62918f91344908c62/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=3a8b20947f2b1559a7d5dcb62918f91344908c62", "patch": "@@ -34127,6 +34127,8 @@ cp_parser_omp_clause_name (cp_parser *parser)\n \tcase 'a':\n \t  if (!strcmp (\"aligned\", p))\n \t    result = PRAGMA_OMP_CLAUSE_ALIGNED;\n+\t  else if (!strcmp (\"allocate\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_ALLOCATE;\n \t  else if (!strcmp (\"async\", p))\n \t    result = PRAGMA_OACC_CLAUSE_ASYNC;\n \t  else if (!strcmp (\"attach\", p))\n@@ -36282,6 +36284,47 @@ cp_parser_omp_clause_aligned (cp_parser *parser, tree list)\n   return nlist;\n }\n \n+/* OpenMP 5.0:\n+   allocate ( variable-list )\n+   allocate ( expression : variable-list )  */\n+\n+static tree\n+cp_parser_omp_clause_allocate (cp_parser *parser, tree list)\n+{\n+  tree nlist, c, allocator = NULL_TREE;\n+  bool colon;\n+\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n+    return list;\n+\n+  cp_parser_parse_tentatively (parser);\n+  bool saved_colon_corrects_to_scope_p = parser->colon_corrects_to_scope_p;\n+  parser->colon_corrects_to_scope_p = false;\n+  allocator = cp_parser_assignment_expression (parser);\n+  parser->colon_corrects_to_scope_p = saved_colon_corrects_to_scope_p;\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_COLON))\n+    {\n+      cp_parser_parse_definitely (parser);\n+      cp_lexer_consume_token (parser->lexer);\n+      if (allocator == error_mark_node)\n+\tallocator = NULL_TREE;\n+    }\n+  else\n+    {\n+      cp_parser_abort_tentative_parse (parser);\n+      allocator = NULL_TREE;\n+    }\n+\n+  nlist = cp_parser_omp_var_list_no_open (parser, OMP_CLAUSE_ALLOCATE, list,\n+\t\t\t\t\t  &colon);\n+\n+  for (c = nlist; c != list; c = OMP_CLAUSE_CHAIN (c))\n+    OMP_CLAUSE_ALLOCATE_ALLOCATOR (c) = allocator;\n+\n+  return nlist;\n+}\n+\n /* OpenMP 2.5:\n    lastprivate ( variable-list )\n \n@@ -37599,6 +37642,10 @@ cp_parser_omp_all_clauses (cp_parser *parser, omp_clause_mask mask,\n \t  clauses = cp_parser_omp_clause_aligned (parser, clauses);\n \t  c_name = \"aligned\";\n \t  break;\n+\tcase PRAGMA_OMP_CLAUSE_ALLOCATE:\n+\t  clauses = cp_parser_omp_clause_allocate (parser, clauses);\n+\t  c_name = \"allocate\";\n+\t  break;\n \tcase PRAGMA_OMP_CLAUSE_LINEAR:\n \t  {\n \t    bool declare_simd = false;\n@@ -39618,6 +39665,7 @@ cp_parser_omp_simd (cp_parser *parser, cp_token *pragma_tok,\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_SCHEDULE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NOWAIT)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_COLLAPSE)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_ALLOCATE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_ORDER))\n \n static tree\n@@ -39902,6 +39950,7 @@ cp_parser_omp_sections_scope (cp_parser *parser)\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_LASTPRIVATE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_REDUCTION)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_ALLOCATE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NOWAIT))\n \n static tree\n@@ -39952,6 +40001,7 @@ cp_parser_omp_sections (cp_parser *parser, cp_token *pragma_tok,\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_COPYIN)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_REDUCTION)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NUM_THREADS)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_ALLOCATE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_PROC_BIND))\n \n static tree\n@@ -40097,6 +40147,7 @@ cp_parser_omp_parallel (cp_parser *parser, cp_token *pragma_tok,\n \t( (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_PRIVATE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_COPYPRIVATE)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_ALLOCATE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NOWAIT))\n \n static tree\n@@ -40129,6 +40180,7 @@ cp_parser_omp_single (cp_parser *parser, cp_token *pragma_tok, bool *if_p)\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_MERGEABLE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEPEND)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_PRIORITY)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_ALLOCATE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_IN_REDUCTION))\n \n static tree\n@@ -40193,7 +40245,8 @@ cp_parser_omp_taskyield (cp_parser *parser, cp_token *pragma_tok)\n    # pragma omp taskgroup taskgroup-clause[optseq] new-line  */\n \n #define OMP_TASKGROUP_CLAUSE_MASK\t\t\t\t\\\n-\t( (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_TASK_REDUCTION))\n+\t( (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_ALLOCATE)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_TASK_REDUCTION))\n \n static tree\n cp_parser_omp_taskgroup (cp_parser *parser, cp_token *pragma_tok, bool *if_p)\n@@ -40302,6 +40355,7 @@ cp_parser_omp_cancellation_point (cp_parser *parser, cp_token *pragma_tok,\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_LASTPRIVATE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DIST_SCHEDULE)\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_ALLOCATE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_COLLAPSE))\n \n static tree\n@@ -40400,6 +40454,7 @@ cp_parser_omp_distribute (cp_parser *parser, cp_token *pragma_tok,\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_REDUCTION)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NUM_TEAMS)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_THREAD_LIMIT)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_ALLOCATE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEFAULT))\n \n static tree\n@@ -40806,6 +40861,7 @@ cp_parser_omp_target_update (cp_parser *parser, cp_token *pragma_tok,\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_PRIVATE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEFAULTMAP)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_ALLOCATE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_IS_DEVICE_PTR))\n \n static bool\n@@ -42955,6 +43011,7 @@ cp_parser_omp_requires (cp_parser *parser, cp_token *pragma_tok)\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_MERGEABLE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NOGROUP)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_PRIORITY)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_ALLOCATE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_REDUCTION)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_IN_REDUCTION))\n "}, {"sha": "3c0f2546489d9014a571b11361330b8cc9e00460", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a8b20947f2b1559a7d5dcb62918f91344908c62/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a8b20947f2b1559a7d5dcb62918f91344908c62/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=3a8b20947f2b1559a7d5dcb62918f91344908c62", "patch": "@@ -17306,6 +17306,7 @@ tsubst_omp_clauses (tree clauses, enum c_omp_region_type ort,\n \t  break;\n \tcase OMP_CLAUSE_GANG:\n \tcase OMP_CLAUSE_ALIGNED:\n+\tcase OMP_CLAUSE_ALLOCATE:\n \t  OMP_CLAUSE_DECL (nc)\n \t    = tsubst_omp_clause_decl (OMP_CLAUSE_DECL (oc), args, complain,\n \t\t\t\t      in_decl, NULL);"}, {"sha": "d8d3baf92493ba4f83ed7c8e4f436b49303a8bb5", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a8b20947f2b1559a7d5dcb62918f91344908c62/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a8b20947f2b1559a7d5dcb62918f91344908c62/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=3a8b20947f2b1559a7d5dcb62918f91344908c62", "patch": "@@ -6373,6 +6373,7 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n   /* 1 if normal/task reduction has been seen, -1 if inscan reduction\n      has been seen, -2 if mixed inscan/normal reduction diagnosed.  */\n   int reduction_seen = 0;\n+  bool allocate_seen = false;\n \n   bitmap_obstack_initialize (NULL);\n   bitmap_initialize (&generic_head, &bitmap_default_obstack);\n@@ -7198,6 +7199,73 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t    bitmap_set_bit (&oacc_reduction_head, DECL_UID (t));\n \t  break;\n \n+\tcase OMP_CLAUSE_ALLOCATE:\n+\t  t = OMP_CLAUSE_DECL (c);\n+\t  if (t == current_class_ptr)\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%<this%> not allowed in %<allocate%> clause\");\n+\t      remove = true;\n+\t      break;\n+\t    }\n+\t  if (!VAR_P (t) && TREE_CODE (t) != PARM_DECL)\n+\t    {\n+\t      if (processing_template_decl && TREE_CODE (t) != OVERLOAD)\n+\t\tbreak;\n+\t      if (DECL_P (t))\n+\t\terror_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t  \"%qD is not a variable in %<allocate%> clause\", t);\n+\t      else\n+\t\terror_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t  \"%qE is not a variable in %<allocate%> clause\", t);\n+\t      remove = true;\n+\t    }\n+\t  else if (bitmap_bit_p (&aligned_head, DECL_UID (t)))\n+\t    {\n+\t      warning_at (OMP_CLAUSE_LOCATION (c), 0,\n+\t\t\t\"%qD appears more than once in %<allocate%> clauses\",\n+\t\t\tt);\n+\t      remove = true;\n+\t    }\n+\t  else\n+\t    {\n+\t      bitmap_set_bit (&aligned_head, DECL_UID (t));\n+\t      allocate_seen = true;\n+\t    }\n+\t  t = OMP_CLAUSE_ALLOCATE_ALLOCATOR (c);\n+\t  if (error_operand_p (t))\n+\t    {\n+\t      remove = true;\n+\t      break;\n+\t    }\n+\t  if (t == NULL_TREE)\n+\t    break;\n+\t  tree allocatort;\n+\t  allocatort = TYPE_MAIN_VARIANT (TREE_TYPE (t));\n+\t  if (!type_dependent_expression_p (t)\n+\t      && (TREE_CODE (allocatort) != ENUMERAL_TYPE\n+\t\t  || TYPE_NAME (allocatort) == NULL_TREE\n+\t\t  || TREE_CODE (TYPE_NAME (allocatort)) != TYPE_DECL\n+\t\t  || (DECL_NAME (TYPE_NAME (allocatort))\n+\t\t      != get_identifier (\"omp_allocator_handle_t\"))\n+\t\t  || (TYPE_CONTEXT (allocatort)\n+\t\t      != DECL_CONTEXT (global_namespace))))\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%<allocate%> clause allocator expression has \"\n+\t\t\t\"type %qT rather than %<omp_allocator_handle_t%>\",\n+\t\t\tTREE_TYPE (t));\n+\t      remove = true;\n+\t    }\n+\t  else\n+\t    {\n+\t      t = mark_rvalue_use (t);\n+\t      if (!processing_template_decl)\n+\t\tt = maybe_constant_value (t);\n+\t      OMP_CLAUSE_ALLOCATE_ALLOCATOR (c) = t;\n+\t    }\n+\t  break;\n+\n \tcase OMP_CLAUSE_DEPEND:\n \t  t = OMP_CLAUSE_DECL (c);\n \t  if (t == NULL_TREE)\n@@ -8169,6 +8237,12 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t{\n \t  const char *share_name = NULL;\n \n+\t  if (allocate_seen\n+\t      && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_SHARED\n+\t      && DECL_P (t))\n+\t    bitmap_clear_bit (&aligned_head,\n+\t\t\t      DECL_UID (OMP_CLAUSE_DECL (c)));\n+\t    \n \t  if (VAR_P (t) && CP_DECL_THREAD_LOCAL_P (t))\n \t    share_name = \"threadprivate\";\n \t  else switch (cxx_omp_predetermined_sharing_1 (t))\n@@ -8262,6 +8336,25 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \tpc = &OMP_CLAUSE_CHAIN (c);\n     }\n \n+  if (allocate_seen)\n+    for (pc = &clauses, c = clauses; c ; c = *pc)\n+      {\n+\tbool remove = false;\n+\tif (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_ALLOCATE\n+\t    && !OMP_CLAUSE_ALLOCATE_COMBINED (c)\n+\t    && bitmap_bit_p (&aligned_head, DECL_UID (OMP_CLAUSE_DECL (c))))\n+\t  {\n+\t    error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t      \"%qD specified in %<allocate%> clause but not in \"\n+\t\t      \"an explicit privatization clause\", OMP_CLAUSE_DECL (c));\n+\t    remove = true;\n+\t  }\n+\tif (remove)\n+\t  *pc = OMP_CLAUSE_CHAIN (c);\n+\telse\n+\t  pc = &OMP_CLAUSE_CHAIN (c);\n+      }\n+\n   bitmap_obstack_release (NULL);\n   return clauses;\n }"}, {"sha": "f766fee24b9b28b9bde997bc70dde4ccf729eb33", "filename": "gcc/gimplify.c", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a8b20947f2b1559a7d5dcb62918f91344908c62/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a8b20947f2b1559a7d5dcb62918f91344908c62/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=3a8b20947f2b1559a7d5dcb62918f91344908c62", "patch": "@@ -9708,6 +9708,21 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t  omp_add_variable (ctx, decl, GOVD_NONTEMPORAL);\n \t  break;\n \n+\tcase OMP_CLAUSE_ALLOCATE:\n+\t  decl = OMP_CLAUSE_DECL (c);\n+\t  if (error_operand_p (decl))\n+\t    {\n+\t      remove = true;\n+\t      break;\n+\t    }\n+\t  if (gimplify_expr (&OMP_CLAUSE_ALLOCATE_ALLOCATOR (c), pre_p, NULL,\n+\t\t\t     is_gimple_val, fb_rvalue) == GS_ERROR)\n+\t    {\n+\t      remove = true;\n+\t      break;\n+\t    }\n+\t  break;\n+\n \tcase OMP_CLAUSE_DEFAULT:\n \t  ctx->default_kind = OMP_CLAUSE_DEFAULT_KIND (c);\n \t  break;\n@@ -10618,6 +10633,7 @@ gimplify_adjust_omp_clauses (gimple_seq *pre_p, gimple_seq body, tree *list_p,\n \tcase OMP_CLAUSE_FINALIZE:\n \tcase OMP_CLAUSE_INCLUSIVE:\n \tcase OMP_CLAUSE_EXCLUSIVE:\n+\tcase OMP_CLAUSE_ALLOCATE:\n \t  break;\n \n \tdefault:\n@@ -12149,7 +12165,7 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t    *gforo_clauses_ptr = c;\n \t    gforo_clauses_ptr = &OMP_CLAUSE_CHAIN (c);\n \t    break;\n-\t  /* Taskloop clause we duplicate on both taskloops.  */\n+\t  /* Collapse clause we duplicate on both taskloops.  */\n \t  case OMP_CLAUSE_COLLAPSE:\n \t    *gfor_clauses_ptr = c;\n \t    gfor_clauses_ptr = &OMP_CLAUSE_CHAIN (c);\n@@ -12191,6 +12207,13 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t    gtask_clauses_ptr\n \t      = &OMP_CLAUSE_CHAIN (*gtask_clauses_ptr);\n \t    break;\n+\t  /* Allocate clause we duplicate on task and inner taskloop.  */\n+\t  case OMP_CLAUSE_ALLOCATE:\n+\t    *gfor_clauses_ptr = c;\n+\t    gfor_clauses_ptr = &OMP_CLAUSE_CHAIN (c);\n+\t    *gtask_clauses_ptr = copy_node (c);\n+\t    gtask_clauses_ptr = &OMP_CLAUSE_CHAIN (*gtask_clauses_ptr);\n+\t    break;\n \t  default:\n \t    gcc_unreachable ();\n \t  }"}, {"sha": "5392fa7e3086844aabae73a4ddd0b00b414a2d07", "filename": "gcc/omp-low.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a8b20947f2b1559a7d5dcb62918f91344908c62/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a8b20947f2b1559a7d5dcb62918f91344908c62/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=3a8b20947f2b1559a7d5dcb62918f91344908c62", "patch": "@@ -1486,6 +1486,7 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \tcase OMP_CLAUSE_IF_PRESENT:\n \tcase OMP_CLAUSE_FINALIZE:\n \tcase OMP_CLAUSE_TASK_REDUCTION:\n+\tcase OMP_CLAUSE_ALLOCATE:\n \t  break;\n \n \tcase OMP_CLAUSE_ALIGNED:\n@@ -1653,6 +1654,7 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \tcase OMP_CLAUSE_SIMDLEN:\n \tcase OMP_CLAUSE_ALIGNED:\n \tcase OMP_CLAUSE_DEPEND:\n+\tcase OMP_CLAUSE_ALLOCATE:\n \tcase OMP_CLAUSE__LOOPTEMP_:\n \tcase OMP_CLAUSE__REDUCTEMP_:\n \tcase OMP_CLAUSE_TO:"}, {"sha": "29ebdf1a79aaacb998950c2060b7f061b838dd48", "filename": "gcc/testsuite/c-c++-common/gomp/allocate-1.c", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a8b20947f2b1559a7d5dcb62918f91344908c62/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fallocate-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a8b20947f2b1559a7d5dcb62918f91344908c62/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fallocate-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fallocate-1.c?ref=3a8b20947f2b1559a7d5dcb62918f91344908c62", "patch": "@@ -0,0 +1,76 @@\n+typedef enum omp_allocator_handle_t\n+#if __cplusplus >= 201103L\n+: __UINTPTR_TYPE__\n+#endif\n+{\n+  omp_null_allocator = 0,\n+  omp_default_mem_alloc = 1,\n+  omp_large_cap_mem_alloc = 2,\n+  omp_const_mem_alloc = 3,\n+  omp_high_bw_mem_alloc = 4,\n+  omp_low_lat_mem_alloc = 5,\n+  omp_cgroup_mem_alloc = 6,\n+  omp_pteam_mem_alloc = 7,\n+  omp_thread_mem_alloc = 8,\n+  __omp_allocator_handle_t_max__ = __UINTPTR_MAX__\n+} omp_allocator_handle_t;\n+\n+int bar (int, int *, int);\n+omp_allocator_handle_t baz (void);\n+\n+void\n+foo (int x, int z)\n+{\n+  int y[16] = { 0 }, r = 0, i;\n+  omp_allocator_handle_t h = baz ();\n+  #pragma omp parallel allocate (x) allocate (omp_default_mem_alloc : y) \\\n+\t      allocate ((omp_allocator_handle_t) omp_default_mem_alloc:z) firstprivate (x, y, z)\n+  bar (x, y, z);\n+  #pragma omp task private (x) firstprivate (z) allocate (omp_low_lat_mem_alloc:x,z)\n+  bar (0, &x, z);\n+  #pragma omp taskwait\n+  #pragma omp target teams distribute parallel for private (x) firstprivate (y) \\\n+\t      allocate ((omp_allocator_handle_t)(omp_default_mem_alloc + 0):z) \\\n+\t      allocate (omp_default_mem_alloc: x, y) allocate (omp_low_lat_mem_alloc: r) \\\n+\t      lastprivate (z) reduction(+:r)\n+  for (i = 0; i < 64; i++)\n+    {\n+      z = bar (0, &x, 0);\n+      r += bar (1, y, 0);\n+    }\n+  #pragma omp single private (x) allocate (h:x)\n+  ;\n+  #pragma omp single allocate (*&h : x) private (x)\n+  ;\n+  #pragma omp parallel shared (r, x, z)\n+  #pragma omp single firstprivate (r) allocate (x, r, z) private (x, z)\n+  ;\n+  #pragma omp for allocate (x) private (x)\n+  for (i = 0; i < 64; i++)\n+    x = 1;\n+  #pragma omp sections private (x) allocate (omp_low_lat_mem_alloc: x)\n+  {\n+    x = 1;\n+    #pragma omp section\n+    x = 2;\n+    #pragma omp section\n+    x = 3;\n+  }\n+  #pragma omp taskgroup task_reduction(+:r) allocate (omp_default_mem_alloc : r)\n+  #pragma omp task in_reduction(+:r) allocate (omp_default_mem_alloc : r)\n+  r += bar (r, &r, 0);\n+  #pragma omp teams private (x) firstprivate (y) allocate (h : x, y)\n+  bar (x, y, 0);\n+  #pragma omp taskloop lastprivate (x) reduction (+:r) allocate (h : x, r)\n+  for (i = 0; i < 16; i++)\n+    {\n+      r += bar (0, &r, 0);\n+      x = i;\n+    }\n+  #pragma omp taskgroup task_reduction(+:r) allocate (omp_default_mem_alloc : r)\n+  #pragma omp taskloop firstprivate (x) in_reduction (+:r) \\\n+\t\t       allocate (omp_default_mem_alloc : x, r)\n+  for (i = 0; i < 16; i++)\n+    r += bar (x, &r, 0);\n+  #pragma omp taskwait\n+}"}, {"sha": "cc77efc8ffead59eff2a9decb9c3eb33ec5f6e68", "filename": "gcc/testsuite/c-c++-common/gomp/allocate-2.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a8b20947f2b1559a7d5dcb62918f91344908c62/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fallocate-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a8b20947f2b1559a7d5dcb62918f91344908c62/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fallocate-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fallocate-2.c?ref=3a8b20947f2b1559a7d5dcb62918f91344908c62", "patch": "@@ -0,0 +1,45 @@\n+typedef enum omp_allocator_handle_t\n+#if __cplusplus >= 201103L\n+: __UINTPTR_TYPE__\n+#endif\n+{\n+  omp_null_allocator = 0,\n+  omp_default_mem_alloc = 1,\n+  omp_large_cap_mem_alloc = 2,\n+  omp_const_mem_alloc = 3,\n+  omp_high_bw_mem_alloc = 4,\n+  omp_low_lat_mem_alloc = 5,\n+  omp_cgroup_mem_alloc = 6,\n+  omp_pteam_mem_alloc = 7,\n+  omp_thread_mem_alloc = 8,\n+  __omp_allocator_handle_t_max__ = __UINTPTR_MAX__\n+} omp_allocator_handle_t;\n+\n+int bar (int, int *, int);\n+omp_allocator_handle_t baz (void);\n+\n+void\n+foo (int x, int z)\n+{\n+  int i;\n+  #pragma omp task allocate (x)\t\t/* { dg-error \"'x' specified in 'allocate' clause but not in an explicit privatization clause\" } */\n+  bar (x, &x, 0);\n+  #pragma omp taskwait\n+  #pragma omp parallel allocate (x)\t/* { dg-error \"'x' specified in 'allocate' clause but not in an explicit privatization clause\" } */\n+  bar (x, &x, 0);\n+  #pragma omp parallel for simd private (x) allocate (x)\t/* { dg-error \"'x' specified in 'allocate' clause but not in an explicit privatization clause\" } */\n+  for (i = 0; i < 16; i++)\n+    x = i;\n+  #pragma omp parallel allocate (foo)\t/* { dg-error \"'\\[^\\n\\r]*foo\\[^\\n\\r]*' is not a variable in 'allocate' clause\" } */\n+  ;\n+  #pragma omp parallel allocate (x) shared (x)\t/* { dg-error \"'x' specified in 'allocate' clause but not in an explicit privatization clause\" } */\n+  bar (x, &x, 0);\n+  #pragma omp parallel private (x) allocate (x) allocate (x)\t/* { dg-warning \"'x' appears more than once in 'allocate' clauses\" } */\n+  bar (x, &x, 0);\n+  #pragma omp parallel private (x) allocate (x, x)\t/* { dg-warning \"'x' appears more than once in 'allocate' clauses\" } */\n+  bar (x, &x, 0);\n+  #pragma omp parallel private (x) allocate (0.0 : x)\t/* { dg-error \"'allocate' clause allocator expression has type 'double' rather than 'omp_allocator_handle_t'\" } */\n+  bar (x, &x, 0);\n+  #pragma omp parallel private (x) allocate (0 : x)\t/* { dg-error \"'allocate' clause allocator expression has type 'int' rather than 'omp_allocator_handle_t'\" } */\n+  bar (x, &x, 0);\n+}"}, {"sha": "105288ea6ec4321a85c5ff625f262be647df873b", "filename": "gcc/testsuite/c-c++-common/gomp/clauses-1.c", "status": "modified", "additions": 85, "deletions": 53, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a8b20947f2b1559a7d5dcb62918f91344908c62/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fclauses-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a8b20947f2b1559a7d5dcb62918f91344908c62/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fclauses-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fclauses-1.c?ref=3a8b20947f2b1559a7d5dcb62918f91344908c62", "patch": "@@ -1,6 +1,23 @@\n /* { dg-do compile } */\n /* { dg-additional-options \"-std=c99\" { target c } } */\n \n+typedef enum omp_allocator_handle_t\n+#if __cplusplus >= 201103L\n+: __UINTPTR_TYPE__\n+#endif\n+{\n+  omp_null_allocator = 0,\n+  omp_default_mem_alloc = 1,\n+  omp_large_cap_mem_alloc = 2,\n+  omp_const_mem_alloc = 3,\n+  omp_high_bw_mem_alloc = 4,\n+  omp_low_lat_mem_alloc = 5,\n+  omp_cgroup_mem_alloc = 6,\n+  omp_pteam_mem_alloc = 7,\n+  omp_thread_mem_alloc = 8,\n+  __omp_allocator_handle_t_max__ = __UINTPTR_MAX__\n+} omp_allocator_handle_t;\n+\n int t;\n #pragma omp threadprivate (t)\n \n@@ -14,20 +31,20 @@ foo (int d, int m, int i1, int i2, int p, int *idp, int s,\n   #pragma omp distribute parallel for \\\n     private (p) firstprivate (f) collapse(1) dist_schedule(static, 16) \\\n     if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) \\\n-    lastprivate (l) schedule(static, 4) order(concurrent)\n+    lastprivate (l) schedule(static, 4) order(concurrent) allocate (omp_default_mem_alloc:f)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp distribute parallel for simd \\\n     private (p) firstprivate (f) collapse(1) dist_schedule(static, 16) \\\n     if (parallel: i2) if(simd: i1) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) \\\n     lastprivate (l) schedule(static, 4) nontemporal(ntm) \\\n-    safelen(8) simdlen(4) aligned(q: 32) order(concurrent)\n+    safelen(8) simdlen(4) aligned(q: 32) order(concurrent) allocate (omp_default_mem_alloc:f)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp distribute simd \\\n     private (p) firstprivate (f) collapse(1) dist_schedule(static, 16) \\\n     safelen(8) simdlen(4) aligned(q: 32) reduction(+:r) if(i1) nontemporal(ntm) \\\n-    order(concurrent)\n+    order(concurrent) allocate (omp_default_mem_alloc:f)\n   for (int i = 0; i < 64; i++)\n     ll++;\n }\n@@ -49,20 +66,20 @@ baz (int d, int m, int i1, int i2, int p, int *idp, int s,\n   #pragma omp distribute parallel for \\\n     private (p) firstprivate (f) collapse(1) dist_schedule(static, 16) \\\n     if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) \\\n-    lastprivate (l) schedule(static, 4) copyin(t) order(concurrent)\n+    lastprivate (l) schedule(static, 4) copyin(t) order(concurrent) allocate (p)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp distribute parallel for simd \\\n     private (p) firstprivate (f) collapse(1) dist_schedule(static, 16) \\\n     if (parallel: i2) if(simd: i1) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) \\\n     lastprivate (l) schedule(static, 4) nontemporal(ntm) \\\n-    safelen(8) simdlen(4) aligned(q: 32) copyin(t) order(concurrent)\n+    safelen(8) simdlen(4) aligned(q: 32) copyin(t) order(concurrent) allocate (f)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp distribute simd \\\n     private (p) firstprivate (f) collapse(1) dist_schedule(static, 16) \\\n     safelen(8) simdlen(4) aligned(q: 32) reduction(+:r) if(i1) nontemporal(ntm) \\\n-    order(concurrent)\n+    order(concurrent) allocate (f)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp loop bind(parallel) order(concurrent) \\\n@@ -77,28 +94,28 @@ bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int s,\n {\n   #pragma omp for simd \\\n     private (p) firstprivate (f) lastprivate (l) linear (ll:1) reduction(+:r) schedule(static, 4) collapse(1) nowait \\\n-    safelen(8) simdlen(4) aligned(q: 32) nontemporal(ntm) if(i1) order(concurrent)\n+    safelen(8) simdlen(4) aligned(q: 32) nontemporal(ntm) if(i1) order(concurrent) allocate (f)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp parallel for \\\n     private (p) firstprivate (f) if (parallel: i2) default(shared) shared(s) copyin(t) reduction(+:r) num_threads (nth) proc_bind(spread) \\\n-    lastprivate (l) linear (ll:1) ordered schedule(static, 4) collapse(1)\n+    lastprivate (l) linear (ll:1) ordered schedule(static, 4) collapse(1) allocate (f)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp parallel for \\\n     private (p) firstprivate (f) if (parallel: i2) default(shared) shared(s) copyin(t) reduction(+:r) num_threads (nth) proc_bind(spread) \\\n-    lastprivate (l) linear (ll:1) schedule(static, 4) collapse(1) order(concurrent)\n+    lastprivate (l) linear (ll:1) schedule(static, 4) collapse(1) order(concurrent) allocate (f)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp parallel for simd \\\n     private (p) firstprivate (f) if (i2) default(shared) shared(s) copyin(t) reduction(+:r) num_threads (nth) proc_bind(spread) \\\n     lastprivate (l) linear (ll:1) schedule(static, 4) collapse(1) \\\n-    safelen(8) simdlen(4) aligned(q: 32) nontemporal(ntm) order(concurrent)\n+    safelen(8) simdlen(4) aligned(q: 32) nontemporal(ntm) order(concurrent) allocate (f)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp parallel sections \\\n     private (p) firstprivate (f) if (parallel: i2) default(shared) shared(s) copyin(t) reduction(+:r) num_threads (nth) proc_bind(spread) \\\n-    lastprivate (l)\n+    lastprivate (l) allocate (f)\n   {\n     #pragma omp section\n     {}\n@@ -108,43 +125,48 @@ bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int s,\n   #pragma omp target parallel \\\n     device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \\\n     if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) \\\n-    nowait depend(inout: dd[0])\n+    nowait depend(inout: dd[0]) allocate (omp_default_mem_alloc:f)\n     ;\n   #pragma omp target parallel for \\\n     device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \\\n     if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) \\\n-    lastprivate (l) linear (ll:1) ordered schedule(static, 4) collapse(1) nowait depend(inout: dd[0])\n+    lastprivate (l) linear (ll:1) ordered schedule(static, 4) collapse(1) nowait depend(inout: dd[0]) \\\n+    allocate (omp_default_mem_alloc:f)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp target parallel for \\\n     device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \\\n     if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) \\\n-    lastprivate (l) linear (ll:1) schedule(static, 4) collapse(1) nowait depend(inout: dd[0]) order(concurrent)\n+    lastprivate (l) linear (ll:1) schedule(static, 4) collapse(1) nowait depend(inout: dd[0]) order(concurrent) \\\n+    allocate (omp_default_mem_alloc:f)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp target parallel for simd \\\n     device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \\\n     if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) \\\n     lastprivate (l) linear (ll:1) schedule(static, 4) collapse(1) \\\n-    safelen(8) simdlen(4) aligned(q: 32) nowait depend(inout: dd[0]) nontemporal(ntm) if (simd: i3) order(concurrent)\n+    safelen(8) simdlen(4) aligned(q: 32) nowait depend(inout: dd[0]) nontemporal(ntm) if (simd: i3) order(concurrent) \\\n+    allocate (omp_default_mem_alloc:f)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp target teams \\\n     device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \\\n-    shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) nowait depend(inout: dd[0])\n+    shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) nowait depend(inout: dd[0]) \\\n+    allocate (omp_default_mem_alloc:f)\n     ;\n   #pragma omp target teams distribute \\\n     device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \\\n     shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) \\\n-    collapse(1) dist_schedule(static, 16) nowait depend(inout: dd[0])\n+    collapse(1) dist_schedule(static, 16) nowait depend(inout: dd[0]) allocate (omp_default_mem_alloc:f)\n   for (int i = 0; i < 64; i++)\n     ;\n   #pragma omp target teams distribute parallel for \\\n     device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \\\n     shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) \\\n     collapse(1) dist_schedule(static, 16) \\\n     if (parallel: i2) num_threads (nth) proc_bind(spread) \\\n-    lastprivate (l) schedule(static, 4) nowait depend(inout: dd[0]) order(concurrent)\n+    lastprivate (l) schedule(static, 4) nowait depend(inout: dd[0]) order(concurrent) \\\n+     allocate (omp_default_mem_alloc:f)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp target teams distribute parallel for simd \\\n@@ -153,55 +175,58 @@ bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int s,\n     collapse(1) dist_schedule(static, 16) \\\n     if (parallel: i2) num_threads (nth) proc_bind(spread) \\\n     lastprivate (l) schedule(static, 4) order(concurrent) \\\n-    safelen(8) simdlen(4) aligned(q: 32) nowait depend(inout: dd[0]) nontemporal(ntm) if (simd: i3)\n+    safelen(8) simdlen(4) aligned(q: 32) nowait depend(inout: dd[0]) nontemporal(ntm) if (simd: i3) \\\n+    allocate (omp_default_mem_alloc:f)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp target teams distribute simd \\\n     device(d) map (tofrom: m) if (i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \\\n     shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) \\\n     collapse(1) dist_schedule(static, 16) order(concurrent) \\\n-    safelen(8) simdlen(4) aligned(q: 32) nowait depend(inout: dd[0]) nontemporal(ntm)\n+    safelen(8) simdlen(4) aligned(q: 32) nowait depend(inout: dd[0]) nontemporal(ntm) \\\n+    allocate (omp_default_mem_alloc:f)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp target simd \\\n     device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \\\n     safelen(8) simdlen(4) lastprivate (l) linear(ll: 1) aligned(q: 32) reduction(+:r) \\\n-     nowait depend(inout: dd[0]) nontemporal(ntm) if(simd:i3) order(concurrent)\n+    nowait depend(inout: dd[0]) nontemporal(ntm) if(simd:i3) order(concurrent) \\\n+    allocate (omp_default_mem_alloc:f)\n   for (int i = 0; i < 64; i++)\n     ll++;\n-  #pragma omp taskgroup task_reduction(+:r2)\n+  #pragma omp taskgroup task_reduction(+:r2) allocate (r2)\n   #pragma omp taskloop simd \\\n     private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied if(taskloop: i1) if(simd: i2) final(fi) mergeable priority (pp) \\\n     safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) in_reduction(+:r2) nontemporal(ntm) \\\n-    order(concurrent)\n+    order(concurrent) allocate (f)\n   for (int i = 0; i < 64; i++)\n     ll++;\n-  #pragma omp taskgroup task_reduction(+:r)\n+  #pragma omp taskgroup task_reduction(+:r) allocate (r)\n   #pragma omp taskloop simd \\\n     private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied if(i1) final(fi) mergeable nogroup priority (pp) \\\n     safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) in_reduction(+:r) nontemporal(ntm) \\\n-    order(concurrent)\n+    order(concurrent) allocate (f)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp taskwait\n   #pragma omp taskloop simd \\\n     private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) if(taskloop: i1) final(fi) priority (pp) \\\n     safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(+:r) if (simd: i3) nontemporal(ntm) \\\n-    order(concurrent)\n+    order(concurrent) allocate (f)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp target nowait depend(inout: dd[0])\n   #pragma omp teams distribute \\\n     private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) \\\n-    collapse(1) dist_schedule(static, 16)\n+    collapse(1) dist_schedule(static, 16) allocate (omp_default_mem_alloc: f)\n   for (int i = 0; i < 64; i++)\n     ;\n   #pragma omp target\n   #pragma omp teams distribute parallel for \\\n     private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) \\\n     collapse(1) dist_schedule(static, 16) \\\n     if (parallel: i2) num_threads (nth) proc_bind(spread) \\\n-    lastprivate (l) schedule(static, 4) order(concurrent)\n+    lastprivate (l) schedule(static, 4) order(concurrent) allocate (omp_default_mem_alloc: f)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp target\n@@ -210,87 +235,90 @@ bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int s,\n     collapse(1) dist_schedule(static, 16) \\\n     if (parallel: i2) num_threads (nth) proc_bind(spread) \\\n     lastprivate (l) schedule(static, 4) order(concurrent) \\\n-    safelen(8) simdlen(4) aligned(q: 32) if (simd: i3) nontemporal(ntm)\n+    safelen(8) simdlen(4) aligned(q: 32) if (simd: i3) nontemporal(ntm) \\\n+    allocate (omp_default_mem_alloc: f)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp target\n   #pragma omp teams distribute simd \\\n     private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) \\\n     collapse(1) dist_schedule(static, 16) order(concurrent) \\\n-    safelen(8) simdlen(4) aligned(q: 32) if(i3) nontemporal(ntm)\n+    safelen(8) simdlen(4) aligned(q: 32) if(i3) nontemporal(ntm) \\\n+    allocate (omp_default_mem_alloc: f)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp teams distribute parallel for \\\n     private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) \\\n     collapse(1) dist_schedule(static, 16) order(concurrent) \\\n     if (parallel: i2) num_threads (nth) proc_bind(spread) \\\n-    lastprivate (l) schedule(static, 4) copyin(t)\n+    lastprivate (l) schedule(static, 4) copyin(t) allocate (f)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp teams distribute parallel for simd \\\n     private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) \\\n     collapse(1) dist_schedule(static, 16) \\\n     if (parallel: i2) num_threads (nth) proc_bind(spread) \\\n     lastprivate (l) schedule(static, 4) order(concurrent) \\\n-    safelen(8) simdlen(4) aligned(q: 32) if (simd: i3) nontemporal(ntm) copyin(t)\n+    safelen(8) simdlen(4) aligned(q: 32) if (simd: i3) nontemporal(ntm) copyin(t) \\\n+    allocate (f)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp teams distribute simd \\\n     private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) \\\n     collapse(1) dist_schedule(static, 16) order(concurrent) \\\n-    safelen(8) simdlen(4) aligned(q: 32) if(i3) nontemporal(ntm)\n+    safelen(8) simdlen(4) aligned(q: 32) if(i3) nontemporal(ntm) allocate(f)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp parallel master \\\n     private (p) firstprivate (f) if (parallel: i2) default(shared) shared(s) reduction(+:r) \\\n-    num_threads (nth) proc_bind(spread) copyin(t)\n+    num_threads (nth) proc_bind(spread) copyin(t) allocate (f)\n     ;\n-  #pragma omp taskgroup task_reduction (+:r2)\n+  #pragma omp taskgroup task_reduction (+:r2) allocate (r2)\n   #pragma omp master taskloop \\\n     private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied if(taskloop: i1) final(fi) mergeable priority (pp) \\\n-    reduction(default, +:r) in_reduction(+:r2)\n+    reduction(default, +:r) in_reduction(+:r2) allocate (f)\n   for (int i = 0; i < 64; i++)\n     ll++;\n-  #pragma omp taskgroup task_reduction (+:r2)\n+  #pragma omp taskgroup task_reduction (+:r2) allocate (r2)\n   #pragma omp master taskloop simd \\\n     private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied if(taskloop: i1) if(simd: i2) final(fi) mergeable priority (pp) \\\n     safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) in_reduction(+:r2) nontemporal(ntm) \\\n-    order(concurrent)\n+    order(concurrent) allocate (f)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp parallel master taskloop \\\n     private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied if(taskloop: i1) final(fi) mergeable priority (pp) \\\n-    reduction(default, +:r) if (parallel: i2) num_threads (nth) proc_bind(spread) copyin(t)\n+    reduction(default, +:r) if (parallel: i2) num_threads (nth) proc_bind(spread) copyin(t) allocate (f)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp parallel master taskloop simd \\\n     private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied if(taskloop: i1) if(simd: i2) final(fi) mergeable priority (pp) \\\n     safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) nontemporal(ntm) if (parallel: i2) num_threads (nth) proc_bind(spread) copyin(t) \\\n-    order(concurrent)\n+    order(concurrent) allocate (f)\n   for (int i = 0; i < 64; i++)\n     ll++;\n-  #pragma omp taskgroup task_reduction (+:r2)\n+  #pragma omp taskgroup task_reduction (+:r2) allocate (r2)\n   #pragma omp master taskloop \\\n     private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) untied if(i1) final(fi) mergeable priority (pp) \\\n     reduction(default, +:r) in_reduction(+:r2)\n   for (int i = 0; i < 64; i++)\n     ll++;\n-  #pragma omp taskgroup task_reduction (+:r2)\n+  #pragma omp taskgroup task_reduction (+:r2) allocate (r2)\n   #pragma omp master taskloop simd \\\n     private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) untied if(i1) final(fi) mergeable priority (pp) \\\n     safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) in_reduction(+:r2) nontemporal(ntm) \\\n-    order(concurrent)\n+    order(concurrent) allocate (f)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp parallel master taskloop \\\n     private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) untied if(i1) final(fi) mergeable priority (pp) \\\n-    reduction(default, +:r) num_threads (nth) proc_bind(spread) copyin(t)\n+    reduction(default, +:r) num_threads (nth) proc_bind(spread) copyin(t) allocate (f)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp parallel master taskloop simd \\\n     private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) untied if(i1) final(fi) mergeable priority (pp) \\\n     safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) nontemporal(ntm) num_threads (nth) proc_bind(spread) copyin(t) \\\n-    order(concurrent)\n+    order(concurrent) allocate (f)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp loop bind(thread) order(concurrent) \\\n@@ -299,46 +327,50 @@ bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int s,\n     ll++;\n   #pragma omp parallel loop \\\n     private (p) firstprivate (f) if (parallel: i2) default(shared) shared(s) copyin(t) reduction(+:r) num_threads (nth) proc_bind(spread) \\\n-    lastprivate (l) collapse(1) bind(parallel) order(concurrent)\n+    lastprivate (l) collapse(1) bind(parallel) order(concurrent) allocate (f)\n   for (l = 0; l < 64; l++)\n     ll++;\n   #pragma omp parallel loop \\\n     private (p) firstprivate (f) if (parallel: i2) default(shared) shared(s) copyin(t) reduction(+:r) num_threads (nth) proc_bind(spread) \\\n-    lastprivate (l) collapse(1)\n+    lastprivate (l) collapse(1) allocate (f)\n   for (l = 0; l < 64; l++)\n     ll++;\n   #pragma omp teams loop \\\n     private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) \\\n-    collapse(1) lastprivate (l) bind(teams)\n+    collapse(1) lastprivate (l) bind(teams) allocate (f)\n   for (l = 0; l < 64; ++l)\n     ;\n   #pragma omp teams loop \\\n     private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) \\\n-    collapse(1) lastprivate (l) order(concurrent)\n+    collapse(1) lastprivate (l) order(concurrent) allocate (f)\n   for (l = 0; l < 64; ++l)\n     ;\n   #pragma omp target parallel loop \\\n     device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \\\n     if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) \\\n-    nowait depend(inout: dd[0]) lastprivate (l) bind(parallel) order(concurrent) collapse(1)\n+    nowait depend(inout: dd[0]) lastprivate (l) bind(parallel) order(concurrent) collapse(1) \\\n+    allocate (omp_default_mem_alloc: f)\n   for (l = 0; l < 64; ++l)\n     ;\n   #pragma omp target parallel loop \\\n     device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \\\n     if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) \\\n-    nowait depend(inout: dd[0]) lastprivate (l) order(concurrent) collapse(1)\n+    nowait depend(inout: dd[0]) lastprivate (l) order(concurrent) collapse(1) \\\n+    allocate (omp_default_mem_alloc: f)\n   for (l = 0; l < 64; ++l)\n     ;\n   #pragma omp target teams loop \\\n     device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \\\n     shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) nowait depend(inout: dd[0]) \\\n-    lastprivate (l) bind(teams) collapse(1)\n+    lastprivate (l) bind(teams) collapse(1) \\\n+    allocate (omp_default_mem_alloc: f)\n   for (l = 0; l < 64; ++l)\n     ;\n   #pragma omp target teams loop \\\n     device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \\\n     shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) nowait depend(inout: dd[0]) \\\n-    lastprivate (l) order(concurrent) collapse(1)\n+    lastprivate (l) order(concurrent) collapse(1) \\\n+    allocate (omp_default_mem_alloc: f)\n   for (l = 0; l < 64; ++l)\n     ;\n }"}, {"sha": "c9280a8d3b115921d3df704a58e6e83f334a8bf3", "filename": "gcc/tree-core.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a8b20947f2b1559a7d5dcb62918f91344908c62/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a8b20947f2b1559a7d5dcb62918f91344908c62/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=3a8b20947f2b1559a7d5dcb62918f91344908c62", "patch": "@@ -276,6 +276,9 @@ enum omp_clause_code {\n   /* OpenMP clause: aligned (variable-list[:alignment]).  */\n   OMP_CLAUSE_ALIGNED,\n \n+  /* OpenMP clause: allocate ([allocator:]variable-list).  */\n+  OMP_CLAUSE_ALLOCATE,\n+\n   /* OpenMP clause: depend ({in,out,inout}:variable-list).  */\n   OMP_CLAUSE_DEPEND,\n "}, {"sha": "a4d82174e103b6767e744b51433d279d2f4d490d", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a8b20947f2b1559a7d5dcb62918f91344908c62/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a8b20947f2b1559a7d5dcb62918f91344908c62/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=3a8b20947f2b1559a7d5dcb62918f91344908c62", "patch": "@@ -1441,6 +1441,7 @@ convert_nonlocal_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \t    }\n \t  /* FALLTHRU */\n \tcase OMP_CLAUSE_NONTEMPORAL:\n+\tdo_decl_clause_no_supp:\n \t  /* Like do_decl_clause, but don't add any suppression.  */\n \t  decl = OMP_CLAUSE_DECL (clause);\n \t  if (VAR_P (decl)\n@@ -1453,6 +1454,16 @@ convert_nonlocal_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \t    }\n \t  break;\n \n+\tcase OMP_CLAUSE_ALLOCATE:\n+\t  if (OMP_CLAUSE_ALLOCATE_ALLOCATOR (clause))\n+\t    {\n+\t      wi->val_only = true;\n+\t      wi->is_lhs = false;\n+\t      convert_nonlocal_reference_op\n+\t\t(&OMP_CLAUSE_ALLOCATE_ALLOCATOR (clause), &dummy, wi);\n+\t    }\n+\t  goto do_decl_clause_no_supp;\n+\n \tcase OMP_CLAUSE_NOWAIT:\n \tcase OMP_CLAUSE_ORDERED:\n \tcase OMP_CLAUSE_DEFAULT:\n@@ -2203,6 +2214,7 @@ convert_local_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \t    }\n \t  /* FALLTHRU */\n \tcase OMP_CLAUSE_NONTEMPORAL:\n+\tdo_decl_clause_no_supp:\n \t  /* Like do_decl_clause, but don't add any suppression.  */\n \t  decl = OMP_CLAUSE_DECL (clause);\n \t  if (VAR_P (decl)\n@@ -2221,6 +2233,16 @@ convert_local_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \t    }\n \t  break;\n \n+\tcase OMP_CLAUSE_ALLOCATE:\n+\t  if (OMP_CLAUSE_ALLOCATE_ALLOCATOR (clause))\n+\t    {\n+\t      wi->val_only = true;\n+\t      wi->is_lhs = false;\n+\t      convert_local_reference_op\n+\t\t(&OMP_CLAUSE_ALLOCATE_ALLOCATOR (clause), &dummy, wi);\n+\t    }\n+\t  goto do_decl_clause_no_supp;\n+\n \tcase OMP_CLAUSE_NOWAIT:\n \tcase OMP_CLAUSE_ORDERED:\n \tcase OMP_CLAUSE_DEFAULT:"}, {"sha": "bd60d74d1af8294a76e44c50e8331154ca55d98c", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a8b20947f2b1559a7d5dcb62918f91344908c62/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a8b20947f2b1559a7d5dcb62918f91344908c62/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=3a8b20947f2b1559a7d5dcb62918f91344908c62", "patch": "@@ -712,6 +712,19 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, dump_flags_t flags)\n       pp_right_paren (pp);\n       break;\n \n+    case OMP_CLAUSE_ALLOCATE:\n+      pp_string (pp, \"allocate(\");\n+      if (OMP_CLAUSE_ALLOCATE_ALLOCATOR (clause))\n+\t{\n+\t  dump_generic_node (pp, OMP_CLAUSE_ALLOCATE_ALLOCATOR (clause),\n+\t\t\t     spc, flags, false);\n+\t  pp_colon (pp);\n+\t}\n+      dump_generic_node (pp, OMP_CLAUSE_DECL (clause),\n+\t\t\t spc, flags, false);\n+      pp_right_paren (pp);\n+      break;\n+\n     case OMP_CLAUSE_DEPEND:\n       pp_string (pp, \"depend(\");\n       switch (OMP_CLAUSE_DEPEND_KIND (clause))"}, {"sha": "81f867ddded8a3cd1fc1de2e7b531b0ce865ac3c", "filename": "gcc/tree.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a8b20947f2b1559a7d5dcb62918f91344908c62/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a8b20947f2b1559a7d5dcb62918f91344908c62/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=3a8b20947f2b1559a7d5dcb62918f91344908c62", "patch": "@@ -291,6 +291,7 @@ unsigned const char omp_clause_num_ops[] =\n   1, /* OMP_CLAUSE_COPYPRIVATE  */\n   3, /* OMP_CLAUSE_LINEAR  */\n   2, /* OMP_CLAUSE_ALIGNED  */\n+  2, /* OMP_CLAUSE_ALLOCATE  */\n   1, /* OMP_CLAUSE_DEPEND  */\n   1, /* OMP_CLAUSE_NONTEMPORAL  */\n   1, /* OMP_CLAUSE_UNIFORM  */\n@@ -375,6 +376,7 @@ const char * const omp_clause_code_name[] =\n   \"copyprivate\",\n   \"linear\",\n   \"aligned\",\n+  \"allocate\",\n   \"depend\",\n   \"nontemporal\",\n   \"uniform\",\n@@ -12213,6 +12215,7 @@ walk_tree_1 (tree *tp, walk_tree_fn func, void *data,\n \t  WALK_SUBTREE_TAIL (OMP_CLAUSE_CHAIN (*tp));\n \n \tcase OMP_CLAUSE_ALIGNED:\n+\tcase OMP_CLAUSE_ALLOCATE:\n \tcase OMP_CLAUSE_FROM:\n \tcase OMP_CLAUSE_TO:\n \tcase OMP_CLAUSE_MAP:"}, {"sha": "7f0aa5b8d1d13dd45773b6d04ef94f7c388df97b", "filename": "gcc/tree.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a8b20947f2b1559a7d5dcb62918f91344908c62/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a8b20947f2b1559a7d5dcb62918f91344908c62/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=3a8b20947f2b1559a7d5dcb62918f91344908c62", "patch": "@@ -1731,6 +1731,16 @@ class auto_suppress_location_wrappers\n #define OMP_CLAUSE_ALIGNED_ALIGNMENT(NODE) \\\n   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_ALIGNED), 1)\n \n+#define OMP_CLAUSE_ALLOCATE_ALLOCATOR(NODE) \\\n+  OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_ALLOCATE), 1)\n+\n+/* True if an ALLOCATE clause was present on a combined or composite\n+   construct and the code for splitting the clauses has already performed\n+   checking if the listed variable has explicit privatization on the\n+   construct.  */\n+#define OMP_CLAUSE_ALLOCATE_COMBINED(NODE) \\\n+  (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_ALLOCATE)->base.public_flag)\n+\n #define OMP_CLAUSE_NUM_TEAMS_EXPR(NODE) \\\n   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_NUM_TEAMS), 0)\n "}]}