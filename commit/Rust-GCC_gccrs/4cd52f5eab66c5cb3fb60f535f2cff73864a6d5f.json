{"sha": "4cd52f5eab66c5cb3fb60f535f2cff73864a6d5f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGNkNTJmNWVhYjY2YzVjYjNmYjYwZjUzNWYyY2ZmNzM4NjRhNmQ1Zg==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2007-04-06T09:17:57Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-04-06T09:17:57Z"}, "message": "atree.h, [...] (Copy_Node_With_Replacement): When copying a parameter list in a call...\n\n2007-04-06  Ed Schonberg  <schonberg@adacore.com>\n\t    Bob Duff  <duff@adacore.com>\n\n\t* atree.h, atree.ads, atree.adb (Copy_Node_With_Replacement): When\n\tcopying a parameter list in a call, set properly the First_Named_Formal\n\tand Next_Named_Formal fields in the new list and in the enclosing call.\n\t(Watch_Node,New_Node_Breakpoint,New_Node_Debugging_Output): Shorten\n\tnames, to ease typing in the debugger. Improve comments.\n\t(Watch_Node): New variable, intended to be set in the debugger.\n\t(New_Node_Breakpoint): New do-nothing procedure to set a breakpoint on,\n\tcalled when the watched node is created.\n\t(New_Node_Debugging_Output): Combined version of local procedures\n\tNew_Node_Debugging_Output and New_Entity_Debugging_Output, now global,\n\twith a parameter so that conditional breakpoints like \"if Node = 12345\"\n\twork.\n\t(New_Node, New_Entity): Call the global New_Node_Debugging_Output.\n\tAdd Elist1 function\n\nFrom-SVN: r123553", "tree": {"sha": "30698c187f8b06f111165d33b77ffec900835612", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/30698c187f8b06f111165d33b77ffec900835612"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4cd52f5eab66c5cb3fb60f535f2cff73864a6d5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cd52f5eab66c5cb3fb60f535f2cff73864a6d5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4cd52f5eab66c5cb3fb60f535f2cff73864a6d5f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cd52f5eab66c5cb3fb60f535f2cff73864a6d5f/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0669bebef6c745891bea707a1b65e44073fe2332", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0669bebef6c745891bea707a1b65e44073fe2332", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0669bebef6c745891bea707a1b65e44073fe2332"}], "stats": {"total": 242, "additions": 191, "deletions": 51}, "files": [{"sha": "e079c69b98a03070008396cc2ddcfe0e11da97cc", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 183, "deletions": 50, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cd52f5eab66c5cb3fb60f535f2cff73864a6d5f/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cd52f5eab66c5cb3fb60f535f2cff73864a6d5f/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=4cd52f5eab66c5cb3fb60f535f2cff73864a6d5f", "patch": "@@ -35,8 +35,8 @@ pragma Style_Checks (All_Checks);\n --  Turn off subprogram ordering check for this package\n \n --  WARNING: There is a C version of this package. Any changes to this source\n---  file must be properly reflected in the C header a-atree.h (for inlined\n---  bodies) and the C file a-atree.c (for remaining non-inlined bodies).\n+--  file must be properly reflected in the file atree.h which is a C header\n+--  file containing equivalent definitions for use by gigi.\n \n with Debug;   use Debug;\n with Namet;   use Namet;\n@@ -50,6 +50,55 @@ with GNAT.HTable; use GNAT.HTable;\n \n package body Atree is\n \n+   ---------------\n+   -- Debugging --\n+   ---------------\n+\n+   --  Suppose you find that node 12345 is messed up. You might want to find\n+   --  the code that created that node. There are two ways to do this:\n+\n+   --  One way is to set a conditional breakpoint on New_Node_Debugging_Output\n+   --  (nickname \"nnd\"):\n+   --     break nnd if n = 12345\n+   --  and run gnat1 again from the beginning.\n+\n+   --  The other way is to set a breakpoint near the beginning (e.g. on\n+   --  gnat1drv), and run. Then set Watch_Node (nickname \"ww\") to 12345 in gdb:\n+   --     ww := 12345\n+   --  and set a breakpoint on New_Node_Breakpoint (nickname \"nn\"). Continue.\n+\n+   --  Either way, gnat1 will stop when node 12345 is created\n+\n+   --  The second method is faster\n+\n+   ww : Node_Id'Base := Node_Id'First - 1;\n+   pragma Export (Ada, ww); --  trick the optimizer\n+   Watch_Node : Node_Id'Base renames ww;\n+   --  Node to \"watch\"; that is, whenever a node is created, we check if it is\n+   --  equal to Watch_Node, and if so, call New_Node_Breakpoint. You have\n+   --  presumably set a breakpoint on New_Node_Breakpoint. Note that the\n+   --  initial value of Node_Id'First - 1 ensures that by default, no node\n+   --  will be equal to Watch_Node.\n+\n+   procedure nn;\n+   pragma Export (Ada, nn);\n+   procedure New_Node_Breakpoint renames nn;\n+   --  This doesn't do anything interesting; it's just for setting breakpoint\n+   --  on as explained above.\n+\n+   procedure nnd (N : Node_Id);\n+   pragma Export (Ada, nnd);\n+   procedure New_Node_Debugging_Output (N : Node_Id) renames nnd;\n+   --  For debugging. If debugging is turned on, New_Node and New_Entity call\n+   --  this. If debug flag N is turned on, this prints out the new node.\n+   --\n+   --  If Node = Watch_Node, this prints out the new node and calls\n+   --  New_Node_Breakpoint. Otherwise, does nothing.\n+\n+   -----------------------------\n+   -- Local Objects and Types --\n+   -----------------------------\n+\n    Node_Count : Nat;\n    --  Count allocated nodes for Num_Nodes function\n \n@@ -1387,13 +1436,72 @@ package body Atree is\n       is\n          New_Node : Node_Id;\n \n+         procedure Adjust_Named_Associations\n+           (Old_Node : Node_Id;\n+            New_Node : Node_Id);\n+         --  If a call node has named associations, these are chained through\n+         --  the First_Named_Actual, Next_Named_Actual links. These must be\n+         --  propagated separately to the new parameter list, because these\n+         --  are not syntactic fields.\n+\n          function Copy_Field_With_Replacement\n            (Field : Union_Id) return Union_Id;\n          --  Given Field, which is a field of Old_Node, return a copy of it\n          --  if it is a syntactic field (i.e. its parent is Node), setting\n          --  the parent of the copy to poit to New_Node. Otherwise returns\n          --  the field (possibly mapped if it is an entity).\n \n+         -------------------------------\n+         -- Adjust_Named_Associations --\n+         -------------------------------\n+\n+         procedure Adjust_Named_Associations\n+           (Old_Node : Node_Id;\n+            New_Node : Node_Id)\n+         is\n+            Old_E : Node_Id;\n+            New_E : Node_Id;\n+\n+            Old_Next : Node_Id;\n+            New_Next : Node_Id;\n+\n+         begin\n+            Old_E := First (Parameter_Associations (Old_Node));\n+            New_E := First (Parameter_Associations (New_Node));\n+            while Present (Old_E) loop\n+               if Nkind (Old_E) = N_Parameter_Association\n+                 and then Present (Next_Named_Actual (Old_E))\n+               then\n+                  if First_Named_Actual (Old_Node)\n+                    =  Explicit_Actual_Parameter (Old_E)\n+                  then\n+                     Set_First_Named_Actual\n+                       (New_Node, Explicit_Actual_Parameter (New_E));\n+                  end if;\n+\n+                  --  Now scan parameter list from the beginning,to locate\n+                  --  next named actual, which can be out of order.\n+\n+                  Old_Next := First (Parameter_Associations (Old_Node));\n+                  New_Next := First (Parameter_Associations (New_Node));\n+\n+                  while Nkind (Old_Next) /= N_Parameter_Association\n+                    or else  Explicit_Actual_Parameter (Old_Next)\n+                      /= Next_Named_Actual (Old_E)\n+                  loop\n+                     Next (Old_Next);\n+                     Next (New_Next);\n+                  end loop;\n+\n+                  Set_Next_Named_Actual\n+                    (New_E, Explicit_Actual_Parameter (New_Next));\n+               end if;\n+\n+               Next (Old_E);\n+               Next (New_E);\n+            end loop;\n+         end Adjust_Named_Associations;\n+\n          ---------------------------------\n          -- Copy_Field_With_Replacement --\n          ---------------------------------\n@@ -1536,6 +1644,18 @@ package body Atree is\n                  Default_Node.Comes_From_Source;\n             end if;\n \n+            --  If the node is call and has named associations,\n+            --  set the corresponding links in the copy.\n+\n+            if (Nkind (Old_Node) = N_Function_Call\n+                 or else Nkind (Old_Node) = N_Entry_Call_Statement\n+                 or else\n+                   Nkind (Old_Node) = N_Procedure_Call_Statement)\n+              and then Present (First_Named_Actual (Old_Node))\n+            then\n+               Adjust_Named_Associations (Old_Node, New_Node);\n+            end if;\n+\n             --  Reset First_Real_Statement for Handled_Sequence_Of_Statements.\n             --  The replacement mechanism applies to entities, and is not used\n             --  here. Eventually we may need a more general graph-copying\n@@ -1935,29 +2055,6 @@ package body Atree is\n    is\n       Ent : Entity_Id;\n \n-      procedure New_Entity_Debugging_Output;\n-      pragma Inline (New_Entity_Debugging_Output);\n-      --  Debugging routine for debug flag N\n-\n-      ---------------------------------\n-      -- New_Entity_Debugging_Output --\n-      ---------------------------------\n-\n-      procedure New_Entity_Debugging_Output is\n-      begin\n-         if Debug_Flag_N then\n-            Write_Str (\"Allocate entity, Id = \");\n-            Write_Int (Int (Ent));\n-            Write_Str (\"  \");\n-            Write_Location (New_Sloc);\n-            Write_Str (\"  \");\n-            Write_Str (Node_Kind'Image (New_Node_Kind));\n-            Write_Eol;\n-         end if;\n-      end New_Entity_Debugging_Output;\n-\n-   --  Start of processing for New_Entity\n-\n    begin\n       pragma Assert (New_Node_Kind in N_Entity);\n \n@@ -1973,7 +2070,7 @@ package body Atree is\n \n       Nodes.Table (Ent).Nkind  := New_Node_Kind;\n       Nodes.Table (Ent).Sloc   := New_Sloc;\n-      pragma Debug (New_Entity_Debugging_Output);\n+      pragma Debug (New_Node_Debugging_Output (Ent));\n \n       return Ent;\n    end New_Entity;\n@@ -1988,35 +2085,12 @@ package body Atree is\n    is\n       Nod : Node_Id;\n \n-      procedure New_Node_Debugging_Output;\n-      pragma Inline (New_Node_Debugging_Output);\n-      --  Debugging routine for debug flag N\n-\n-      --------------------------\n-      -- New_Debugging_Output --\n-      --------------------------\n-\n-      procedure New_Node_Debugging_Output is\n-      begin\n-         if Debug_Flag_N then\n-            Write_Str (\"Allocate node, Id = \");\n-            Write_Int (Int (Nod));\n-            Write_Str (\"  \");\n-            Write_Location (New_Sloc);\n-            Write_Str (\"  \");\n-            Write_Str (Node_Kind'Image (New_Node_Kind));\n-            Write_Eol;\n-         end if;\n-      end New_Node_Debugging_Output;\n-\n-   --  Start of processing for New_Node\n-\n    begin\n       pragma Assert (New_Node_Kind not in N_Entity);\n       Nod := Allocate_Initialize_Node (Empty, With_Extension => False);\n       Nodes.Table (Nod).Nkind := New_Node_Kind;\n       Nodes.Table (Nod).Sloc  := New_Sloc;\n-      pragma Debug (New_Node_Debugging_Output);\n+      pragma Debug (New_Node_Debugging_Output (Nod));\n \n       --  If this is a node with a real location and we are generating\n       --  source nodes, then reset Current_Error_Node. This is useful\n@@ -2029,6 +2103,49 @@ package body Atree is\n       return Nod;\n    end New_Node;\n \n+   -------------------------\n+   -- New_Node_Breakpoint --\n+   -------------------------\n+\n+   procedure nn is -- New_Node_Breakpoint\n+   begin\n+      Write_Str (\"Watched node \");\n+      Write_Int (Int (Watch_Node));\n+      Write_Str (\" created\");\n+      Write_Eol;\n+   end nn;\n+\n+   -------------------------------\n+   -- New_Node_Debugging_Output --\n+   -------------------------------\n+\n+   procedure nnd (N : Node_Id) is -- New_Node_Debugging_Output\n+      Node_Is_Watched : constant Boolean := N = Watch_Node;\n+\n+   begin\n+      if Debug_Flag_N or else Node_Is_Watched then\n+         Write_Str (\"Allocate \");\n+\n+         if Nkind (N) in N_Entity then\n+            Write_Str (\"entity\");\n+         else\n+            Write_Str (\"node\");\n+         end if;\n+\n+         Write_Str (\", Id = \");\n+         Write_Int (Int (N));\n+         Write_Str (\"  \");\n+         Write_Location (Sloc (N));\n+         Write_Str (\"  \");\n+         Write_Str (Node_Kind'Image (Nkind (N)));\n+         Write_Eol;\n+\n+         if Node_Is_Watched then\n+            New_Node_Breakpoint;\n+         end if;\n+      end if;\n+   end nnd;\n+\n    -----------\n    -- Nkind --\n    -----------\n@@ -2897,6 +3014,17 @@ package body Atree is\n          return List_Id (Nodes.Table (N + 2).Field7);\n       end List14;\n \n+      function Elist1 (N : Node_Id) return Elist_Id is\n+         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         Value : constant Union_Id := Nodes.Table (N).Field1;\n+      begin\n+         if Value = 0 then\n+            return No_Elist;\n+         else\n+            return Elist_Id (Value);\n+         end if;\n+      end Elist1;\n+\n       function Elist2 (N : Node_Id) return Elist_Id is\n          pragma Assert (N in Nodes.First .. Nodes.Last);\n          Value : constant Union_Id := Nodes.Table (N).Field2;\n@@ -4875,6 +5003,11 @@ package body Atree is\n          Nodes.Table (N + 2).Field7 := Union_Id (Val);\n       end Set_List14;\n \n+      procedure Set_Elist1 (N : Node_Id; Val : Elist_Id) is\n+      begin\n+         Nodes.Table (N).Field1 := Union_Id (Val);\n+      end Set_Elist1;\n+\n       procedure Set_Elist2 (N : Node_Id; Val : Elist_Id) is\n       begin\n          Nodes.Table (N).Field2 := Union_Id (Val);"}, {"sha": "3d1192bff3f0a88aa35e6b104c9c2e1cc3706fc4", "filename": "gcc/ada/atree.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cd52f5eab66c5cb3fb60f535f2cff73864a6d5f/gcc%2Fada%2Fatree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cd52f5eab66c5cb3fb60f535f2cff73864a6d5f/gcc%2Fada%2Fatree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.ads?ref=4cd52f5eab66c5cb3fb60f535f2cff73864a6d5f", "patch": "@@ -968,6 +968,9 @@ package Atree is\n       function List14 (N : Node_Id) return List_Id;\n       pragma Inline (List14);\n \n+      function Elist1 (N : Node_Id) return Elist_Id;\n+      pragma Inline (Elist1);\n+\n       function Elist2 (N : Node_Id) return Elist_Id;\n       pragma Inline (Elist2);\n \n@@ -1899,6 +1902,9 @@ package Atree is\n       procedure Set_List14 (N : Node_Id; Val : List_Id);\n       pragma Inline (Set_List14);\n \n+      procedure Set_Elist1 (N : Node_Id; Val : Elist_Id);\n+      pragma Inline (Set_Elist1);\n+\n       procedure Set_Elist2 (N : Node_Id; Val : Elist_Id);\n       pragma Inline (Set_Elist2);\n "}, {"sha": "5e8a1a7e8852583d97932b84356f4588b46ff641", "filename": "gcc/ada/atree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cd52f5eab66c5cb3fb60f535f2cff73864a6d5f/gcc%2Fada%2Fatree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cd52f5eab66c5cb3fb60f535f2cff73864a6d5f/gcc%2Fada%2Fatree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.h?ref=4cd52f5eab66c5cb3fb60f535f2cff73864a6d5f", "patch": "@@ -26,7 +26,7 @@\n \n /* This is the C header corresponding to the Ada package specification for\n    Atree. It also contains the implementations of inlined functions from the\n-   package body for Tree.  It was generated manually from atree.ads and\n+   package body for Atree.  It was generated manually from atree.ads and\n    atree.adb and must be kept synchronized with changes in these files.\n \n    Note that only routines for reading the tree are included, since the tree\n@@ -421,6 +421,7 @@ extern Node_Id Current_Error_Node;\n #define List10(N)     Field10 (N)\n #define List14(N)     Field14 (N)\n \n+#define Elist1(N)     Field1  (N)\n #define Elist2(N)     Field2  (N)\n #define Elist3(N)     Field3  (N)\n #define Elist4(N)     Field4  (N)"}]}