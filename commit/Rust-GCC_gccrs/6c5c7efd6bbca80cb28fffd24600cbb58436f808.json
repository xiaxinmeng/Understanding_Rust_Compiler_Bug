{"sha": "6c5c7efd6bbca80cb28fffd24600cbb58436f808", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmM1YzdlZmQ2YmJjYTgwY2IyOGZmZmQyNDYwMGNiYjU4NDM2ZjgwOA==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2010-10-16T21:26:59Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2010-10-16T21:26:59Z"}, "message": "In libobjc/: 2010-10-16 Nicola Pero <nicola.pero@meta-innovation.com>\n\nIn libobjc/:\n2010-10-16  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        * objc/runtime.h: Updated comments.\n        (class_addMethod): New.\n        (class_addIvar): New.\n        (class_replaceMethod): New.\n        (objc_allocateClassPair): New.\n        (objc_registerClassPair): New.\n        (objc_disposeClassPair): New.\n        * class.c (objc_allocateClassPair): New.\n        (objc_registerClassPair): New.\n        (objc_disposeClassPair): New.\n        (class_getSuperclass): Return Nil if a class is in construction.\n        * init.c (__objc_exec_class): Call __objc_init_class.\n        (__objc_init_class): New.\n        * ivars.c (class_copyIvarList): Return NULL if class is in\n        construction.  Do not lock the runtime mutex.\n        (class_getInstanceVariable): Return NULL if class is in\n        construction.  Do not lock the runtime mutex.\n        (class_addIvar): New.\n        * sendmsg.c (class_addMethod): New.\n        (class_replaceMethod): New.\n        * objc-private/module-abi-8.h (__CLS_SETNOTINFO): New.\n        (_CLS_IN_CONSTRUCTION): New.\n        (CLS_IS_IN_CONSTRUCTION): New.\n        (CLS_SET_IN_CONSTRUCTION): New.\n        (CLS_SET_NOT_IN_CONSTRUCTION): New.\n        * objc-private/runtime.h (__objc_init_class): New.\n\nFrom-SVN: r165563", "tree": {"sha": "3920a8a13cd2db3193c61dca0c4a3e93ab0c05f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3920a8a13cd2db3193c61dca0c4a3e93ab0c05f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c5c7efd6bbca80cb28fffd24600cbb58436f808", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c5c7efd6bbca80cb28fffd24600cbb58436f808", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c5c7efd6bbca80cb28fffd24600cbb58436f808", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c5c7efd6bbca80cb28fffd24600cbb58436f808/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d4d9b0a64193609249caa5db60afc6cb0bf50e2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4d9b0a64193609249caa5db60afc6cb0bf50e2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4d9b0a64193609249caa5db60afc6cb0bf50e2a"}], "stats": {"total": 593, "additions": 550, "deletions": 43}, "files": [{"sha": "1d2b2948605c34cdf2f4d11ce111329d2796cc05", "filename": "libobjc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c5c7efd6bbca80cb28fffd24600cbb58436f808/libobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c5c7efd6bbca80cb28fffd24600cbb58436f808/libobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FChangeLog?ref=6c5c7efd6bbca80cb28fffd24600cbb58436f808", "patch": "@@ -1,3 +1,32 @@\n+2010-10-16  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* objc/runtime.h: Updated comments.\n+\t(class_addMethod): New.\n+\t(class_addIvar): New.\n+\t(class_replaceMethod): New.\n+\t(objc_allocateClassPair): New.\n+\t(objc_registerClassPair): New.\n+\t(objc_disposeClassPair): New.\n+\t* class.c (objc_allocateClassPair): New.\n+\t(objc_registerClassPair): New.\n+\t(objc_disposeClassPair): New.\n+\t(class_getSuperclass): Return Nil if a class is in construction.\n+\t* init.c (__objc_exec_class): Call __objc_init_class.\n+\t(__objc_init_class): New.\n+\t* ivars.c (class_copyIvarList): Return NULL if class is in\n+\tconstruction.  Do not lock the runtime mutex.\n+\t(class_getInstanceVariable): Return NULL if class is in\n+\tconstruction.  Do not lock the runtime mutex.\n+\t(class_addIvar): New.\n+\t* sendmsg.c (class_addMethod): New.\n+\t(class_replaceMethod): New.\n+\t* objc-private/module-abi-8.h (__CLS_SETNOTINFO): New.\n+\t(_CLS_IN_CONSTRUCTION): New.\n+\t(CLS_IS_IN_CONSTRUCTION): New.\n+\t(CLS_SET_IN_CONSTRUCTION): New.\n+\t(CLS_SET_NOT_IN_CONSTRUCTION): New.\n+\t* objc-private/runtime.h (__objc_init_class): New.\n+\n 2010-10-16  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* class.c (class_getSuperclass): Call __objc_resolve_class_links"}, {"sha": "ade5a71f453e004d34ed1093b493b8e5d5ae46ed", "filename": "libobjc/class.c", "status": "modified", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c5c7efd6bbca80cb28fffd24600cbb58436f808/libobjc%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c5c7efd6bbca80cb28fffd24600cbb58436f808/libobjc%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fclass.c?ref=6c5c7efd6bbca80cb28fffd24600cbb58436f808", "patch": "@@ -570,6 +570,199 @@ objc_getClassList (Class *returnValue, int maxNumberOfClassesToReturn)\n   return count;\n }\n \n+Class\n+objc_allocateClassPair (Class super_class, const char *class_name, size_t extraBytes)\n+{\n+  Class new_class;\n+  Class new_meta_class;\n+\n+  if (class_name == NULL)\n+    return Nil;\n+\n+  if (objc_getClass (class_name))\n+    return Nil;\n+\n+  if (super_class)\n+    {\n+      /* If you want to build a hierarchy of classes, you need to\n+\t build and register them one at a time.  The risk is that you\n+\t are able to cause confusion by registering a subclass before\n+\t the superclass or similar.  */\n+      if (CLS_IS_IN_CONSTRUCTION (super_class))\n+\treturn Nil;\n+    }\n+\n+  /* Technically, we should create the metaclass first, then use\n+     class_createInstance() to create the class.  That complication\n+     would be relevant if we had class variables, but we don't, so we\n+     just ignore it and create everything directly and assume all\n+     classes have the same size.  */\n+  new_class = objc_calloc (1, sizeof (struct objc_class) + extraBytes);\n+  new_meta_class = objc_calloc (1, sizeof (struct objc_class) + extraBytes);\n+\n+  /* We create an unresolved class, similar to one generated by the\n+     compiler.  It will be resolved later when we register it.\n+\n+     Note how the metaclass details are not that important; when the\n+     class is resolved, the ones that matter will be fixed up.  */\n+  new_class->class_pointer = new_meta_class;\n+  new_meta_class->class_pointer = 0;\n+\n+  if (super_class)\n+    {\n+      /* Force the name of the superclass in place of the link to the\n+\t actual superclass, which will be put there when the class is\n+\t resolved.  */\n+      const char *super_class_name = class_getName (super_class);\n+      new_class->super_class = (void *)super_class_name;\n+      new_meta_class->super_class = (void *)super_class_name;\n+    }\n+  else\n+    {\n+      new_class->super_class = (void *)0;\n+      new_meta_class->super_class = (void *)0;\n+    }\n+\n+  new_class->name = objc_malloc (strlen (class_name) + 1);\n+  strcpy ((char*)new_class->name, class_name);\n+  new_meta_class->name = new_class->name;\n+\n+  new_class->version = 0;\n+  new_meta_class->version = 0;\n+\n+  new_class->info = _CLS_CLASS | _CLS_IN_CONSTRUCTION;\n+  new_meta_class->info = _CLS_META | _CLS_IN_CONSTRUCTION;\n+\n+  if (super_class)\n+    new_class->instance_size = super_class->instance_size;\n+  else\n+    new_class->instance_size = 0;\n+  new_meta_class->instance_size = sizeof (struct objc_class);\n+\n+  return new_class;\n+}\n+\n+void\n+objc_registerClassPair (Class class_)\n+{\n+  if (class_ == Nil)\n+    return;\n+\n+  if ((! CLS_ISCLASS (class_)) || (! CLS_IS_IN_CONSTRUCTION (class_)))\n+    return;\n+\n+  if ((! CLS_ISMETA (class_->class_pointer)) || (! CLS_IS_IN_CONSTRUCTION (class_->class_pointer)))\n+    return;\n+\n+  objc_mutex_lock (__objc_runtime_mutex);\n+\n+  if (objc_getClass (class_->name))\n+    {\n+      objc_mutex_unlock (__objc_runtime_mutex);\n+      return;\n+    }\n+\n+  CLS_SET_NOT_IN_CONSTRUCTION (class_);\n+  CLS_SET_NOT_IN_CONSTRUCTION (class_->class_pointer);\n+\n+  __objc_init_class (class_);\n+\n+  /* Resolve class links immediately.  No point in waiting.  */\n+  __objc_resolve_class_links ();\n+\n+  objc_mutex_unlock (__objc_runtime_mutex);\n+}\n+\n+void\n+objc_disposeClassPair (Class class_)\n+{\n+  if (class_ == Nil)\n+    return;\n+\n+  if ((! CLS_ISCLASS (class_)) || (! CLS_IS_IN_CONSTRUCTION (class_)))\n+    return;\n+\n+  if ((! CLS_ISMETA (class_->class_pointer)) || (! CLS_IS_IN_CONSTRUCTION (class_->class_pointer)))\n+    return;\n+\n+  /* Undo any class_addIvar().  */\n+  if (class_->ivars)\n+    {\n+      int i;\n+      for (i = 0; i < class_->ivars->ivar_count; i++)\n+\t{\n+\t  struct objc_ivar *ivar = &(class_->ivars->ivar_list[i]);\n+\n+\t  objc_free ((char *)ivar->ivar_name);\n+\t  objc_free ((char *)ivar->ivar_type);\n+\t}\n+      \n+      objc_free (class_->ivars);\n+    }\n+\n+  /* Undo any class_addMethod().  */\n+  if (class_->methods)\n+    {\n+      struct objc_method_list *list = class_->methods;\n+      while (list)\n+\t{\n+\t  int i;\n+\t  struct objc_method_list *next = list->method_next;\n+\n+\t  for (i = 0; i < list->method_count; i++)\n+\t    {\n+\t      struct objc_method *method = &(list->method_list[i]);\n+\n+\t      objc_free ((char *)method->method_name);\n+\t      objc_free ((char *)method->method_types);\n+\t    }\n+\n+\t  objc_free (list);\n+\t  list = next;\n+\t}\n+    }\n+\n+  /* Undo any class_addProtocol().  */\n+  if (class_->protocols)\n+    {\n+      struct objc_protocol_list *list = class_->protocols;\n+      while (list)\n+\t{\n+\t  struct objc_protocol_list *next = list->next;\n+\n+\t  objc_free (list);\n+\t  list = next;\n+\t}\n+    }\n+  \n+  /* Undo any class_addMethod() on the meta-class.  */\n+  if (class_->class_pointer->methods)\n+    {\n+      struct objc_method_list *list = class_->class_pointer->methods;\n+      while (list)\n+\t{\n+\t  int i;\n+\t  struct objc_method_list *next = list->method_next;\n+\n+\t  for (i = 0; i < list->method_count; i++)\n+\t    {\n+\t      struct objc_method *method = &(list->method_list[i]);\n+\n+\t      objc_free ((char *)method->method_name);\n+\t      objc_free ((char *)method->method_types);\n+\t    }\n+\n+\t  objc_free (list);\n+\t  list = next;\n+\t}\n+    }\n+\n+  /* Undo objc_allocateClassPair().  */\n+  objc_free ((char *)(class_->name));\n+  objc_free (class_->class_pointer);\n+  objc_free (class_);\n+}\n+\n /* Traditional GNU Objective-C Runtime API.  */\n /* Get the class object for the class named NAME.  If NAME does not\n    identify a known class, the hook _objc_lookup_class is called.  If\n@@ -807,6 +1000,11 @@ class_getSuperclass (Class class_)\n   if (class_ == Nil)\n     return Nil;\n \n+  /* Classes that are in construction are not resolved and can not be\n+     resolved!  */\n+  if (CLS_IS_IN_CONSTRUCTION (class_))\n+    return Nil;\n+\n   /* If the class is not resolved yet, super_class would point to a\n      string (the name of the super class) as opposed to the actual\n      super class.  In that case, we need to resolve the class links"}, {"sha": "dd8789c9cac04aa3b2629b5f18f444a59073aece", "filename": "libobjc/init.c", "status": "modified", "additions": 24, "deletions": 17, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c5c7efd6bbca80cb28fffd24600cbb58436f808/libobjc%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c5c7efd6bbca80cb28fffd24600cbb58436f808/libobjc%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Finit.c?ref=6c5c7efd6bbca80cb28fffd24600cbb58436f808", "patch": "@@ -623,23 +623,7 @@ __objc_exec_class (Module_t module)\n \t In some cases it isn't and this crashes the program.  */\n       class->subclass_list = NULL;\n \n-      /* Store the class in the class table and assign class numbers.  */\n-      __objc_add_class_to_hash (class);\n-\n-      /* Register all of the selectors in the class and meta class.  */\n-      __objc_register_selectors_from_class (class);\n-      __objc_register_selectors_from_class ((Class) class->class_pointer);\n-\n-      /* Install the fake dispatch tables */\n-      __objc_install_premature_dtable (class);\n-      __objc_install_premature_dtable (class->class_pointer);\n-\n-      /* Register the instance methods as class methods, this is\n-\t only done for root classes.  */\n-      __objc_register_instance_methods_to_class (class);\n-\n-      if (class->protocols)\n-\t__objc_init_protocols (class->protocols);\n+      __objc_init_class (class);\n \n       /* Check to see if the superclass is known in this point. If it's not\n \t add the class to the unresolved_classes list.  */\n@@ -864,6 +848,29 @@ init_check_module_version (Module_t module)\n     }\n }\n \n+/* __objc_init_class must be called with __objc_runtime_mutex already locked.  */\n+void\n+__objc_init_class (Class class)\n+{\n+  /* Store the class in the class table and assign class numbers.  */\n+  __objc_add_class_to_hash (class);\n+  \n+  /* Register all of the selectors in the class and meta class.  */\n+  __objc_register_selectors_from_class (class);\n+  __objc_register_selectors_from_class ((Class) class->class_pointer);\n+\n+  /* Install the fake dispatch tables */\n+  __objc_install_premature_dtable (class);\n+  __objc_install_premature_dtable (class->class_pointer);\n+\n+  /* Register the instance methods as class methods, this is only done\n+     for root classes.  */\n+  __objc_register_instance_methods_to_class (class);\n+\n+  if (class->protocols)\n+    __objc_init_protocols (class->protocols);\n+}\n+\n /* __objc_init_protocol must be called with __objc_runtime_mutex\n    already locked, and the \"Protocol\" class already registered.  */\n static void"}, {"sha": "8d5f4abdd393bb2f4436b00df46a10594df08afe", "filename": "libobjc/ivars.c", "status": "modified", "additions": 90, "deletions": 17, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c5c7efd6bbca80cb28fffd24600cbb58436f808/libobjc%2Fivars.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c5c7efd6bbca80cb28fffd24600cbb58436f808/libobjc%2Fivars.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fivars.c?ref=6c5c7efd6bbca80cb28fffd24600cbb58436f808", "patch": "@@ -32,9 +32,8 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n struct objc_ivar *\n class_getInstanceVariable (Class class_, const char *name)\n {\n-  if (class_ != Nil  &&  name != NULL)\n+  if (class_ != Nil  &&  name != NULL  &&  ! CLS_IS_IN_CONSTRUCTION (class_))\n     {\n-      objc_mutex_lock (__objc_runtime_mutex);\n       while (class_ != Nil)\n \t{\n \t  struct objc_ivar_list *ivars = class_->ivars;\n@@ -48,14 +47,12 @@ class_getInstanceVariable (Class class_, const char *name)\n \t\t  \n \t\t  if (!strcmp (ivar->ivar_name, name))\n \t\t    {\n-\t\t      objc_mutex_unlock (__objc_runtime_mutex);\n \t\t      return ivar;\n \t\t    }\n \t\t}\n \t    }\n \t  class_ = class_getSuperclass (class_);\n \t}\n-      objc_mutex_unlock (__objc_runtime_mutex);\n     }\n   return NULL;\n }\n@@ -185,22 +182,13 @@ struct objc_ivar ** class_copyIvarList (Class class_, unsigned int *numberOfRetu\n   struct objc_ivar **returnValue = NULL;\n   struct objc_ivar_list* ivar_list;\n \n-  if (class_ == Nil)\n+  if (class_ == Nil  ||  CLS_IS_IN_CONSTRUCTION (class_))\n     {\n       if (numberOfReturnedIvars)\n \t*numberOfReturnedIvars = 0;\n       return NULL;\n     }\n-\n-  /* TODO: We do not need to lock the runtime mutex if the class has\n-     been registered with the runtime, since the instance variable\n-     list can not change after the class is registered.  The only case\n-     where the lock may be useful if the class is still being created\n-     using objc_allocateClassPair(), but has not been registered using\n-     objc_registerClassPair() yet.  I'm not even sure that is\n-     allowed.  */\n-  objc_mutex_lock (__objc_runtime_mutex);\n-\n+    \n   /* Count how many ivars we have.  */\n   ivar_list = class_->ivars;\n   count = ivar_list->ivar_count;\n@@ -221,14 +209,99 @@ struct objc_ivar ** class_copyIvarList (Class class_, unsigned int *numberOfRetu\n       returnValue[i] = NULL;\n     }\n   \n-  objc_mutex_unlock (__objc_runtime_mutex);\n-\n   if (numberOfReturnedIvars)\n     *numberOfReturnedIvars = count;\n \n   return returnValue;\n }\n \n+BOOL\n+class_addIvar (Class class_, const char * ivar_name, size_t size,\n+\t       unsigned char alignment, const char *type)\n+{\n+  struct objc_ivar_list *ivars;\n+\n+  if (class_ == Nil\n+      || (! CLS_IS_IN_CONSTRUCTION (class_))  \n+      || ivar_name == NULL  \n+      || (strcmp (ivar_name, \"\") == 0)\n+      || size == 0\n+      || type == NULL)\n+    return NO;\n+\n+  /* Check if the class has an instance variable with that name\n+     already.  */\n+  ivars = class_->ivars;\n+\n+  if (ivars != NULL)\n+    {\n+      int i;\n+      \n+      for (i = 0; i < ivars->ivar_count; i++)\n+\t{\n+\t  struct objc_ivar *ivar = &(ivars->ivar_list[i]);\n+\t  \n+\t  if (strcmp (ivar->ivar_name, ivar_name) == 0)\n+\t    {\n+\t      return NO;\n+\t    }\n+\t}\n+    }\n+\n+  /* Ok, no direct ivars.  Check superclasses.  */\n+  if (class_getInstanceVariable (objc_getClass ((char *)(class_->super_class)),\n+\t\t\t\t ivar_name))\n+    return NO;\n+\n+  /* Good.  Create space for the new instance variable.  */\n+  if (ivars)\n+    {\n+      int ivar_count = ivars->ivar_count + 1;\n+      int new_size = sizeof (struct objc_ivar_list) \n+\t+ (ivar_count - 1) * sizeof (struct objc_ivar);\n+      \n+      ivars = (struct objc_ivar_list*) objc_realloc (ivars, new_size);\n+      ivars->ivar_count = ivar_count;\n+      class_->ivars = ivars;\n+    }\n+  else\n+    {\n+      int new_size = sizeof (struct objc_ivar_list);\n+      \n+      ivars = (struct objc_ivar_list*) objc_malloc (new_size);\n+      ivars->ivar_count = 1;\n+      class_->ivars = ivars;\n+    }\n+    \n+  /* Now ivars is set to a list of instance variables of the right\n+     size. */\n+  {\n+    struct objc_ivar *ivar = &(ivars->ivar_list[ivars->ivar_count - 1]);\n+    int misalignment;\n+    \n+    ivar->ivar_name = objc_malloc (strlen (ivar_name) + 1);\n+    strcpy ((char *)ivar->ivar_name, ivar_name);\n+\n+    ivar->ivar_type = objc_malloc (strlen (type) + 1);\n+    strcpy ((char *)ivar->ivar_type, type);\n+\n+    /* The new instance variable is placed at the end of the existing\n+       instance_size, at the first byte that is aligned with\n+       alignment.  */\n+    misalignment = class_->instance_size % alignment;\n+    \n+    if (misalignment == 0)\n+      ivar->ivar_offset = class_->instance_size;\n+    else\n+      ivar->ivar_offset = class_->instance_size - misalignment + alignment;\n+    \n+    class_->instance_size = ivar->ivar_offset + objc_sizeof_type (ivar->ivar_type);\n+  }\n+  \n+  return YES;\n+}\n+\n+\n const char *\n property_getName (struct objc_property * property __attribute__ ((__unused__)))\n {"}, {"sha": "bad547834ffda25c8c21e33e4932a66585a02e4b", "filename": "libobjc/objc-private/module-abi-8.h", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c5c7efd6bbca80cb28fffd24600cbb58436f808/libobjc%2Fobjc-private%2Fmodule-abi-8.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c5c7efd6bbca80cb28fffd24600cbb58436f808/libobjc%2Fobjc-private%2Fmodule-abi-8.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fobjc-private%2Fmodule-abi-8.h?ref=6c5c7efd6bbca80cb28fffd24600cbb58436f808", "patch": "@@ -181,7 +181,7 @@ struct objc_protocol_list\n   places a string in the following member variables: super_class.\n */\n #ifndef __objc_STRUCT_OBJC_CLASS_defined\n-struct objc_class {     \n+struct objc_class {\n   struct objc_class*  class_pointer;    /* Pointer to the class's meta\n \t\t\t\t\t   class. */\n   struct objc_class*  super_class;      /* Pointer to the super\n@@ -234,6 +234,7 @@ struct objc_class {\n #define __CLS_INFO(cls) ((cls)->info)\n #define __CLS_ISINFO(cls, mask) ((__CLS_INFO(cls)&mask)==mask)\n #define __CLS_SETINFO(cls, mask) (__CLS_INFO(cls) |= mask)\n+#define __CLS_SETNOTINFO(cls, mask) (__CLS_INFO(cls) &= ~mask)\n \n /* The structure is of type MetaClass */\n #define _CLS_META 0x2L\n@@ -255,6 +256,16 @@ struct objc_class {\n #define CLS_ISINITIALIZED(cls) __CLS_ISINFO(cls, _CLS_INITIALIZED)\n #define CLS_SETINITIALIZED(cls) __CLS_SETINFO(cls, _CLS_INITIALIZED)\n \n+/* The class is being constructed; it has been allocated using\n+   objc_allocateClassPair(), but has not been registered yet by using\n+   objc_registerClassPair().  This means it is possible to freely add\n+   instance variables to the class, but it can't be used for anything\n+   yet.  */\n+#define _CLS_IN_CONSTRUCTION 0x10L\n+#define CLS_IS_IN_CONSTRUCTION(cls) __CLS_ISINFO(cls, _CLS_IN_CONSTRUCTION)\n+#define CLS_SET_IN_CONSTRUCTION(cls) __CLS_SETINFO(cls, _CLS_IN_CONSTRUCTION)\n+#define CLS_SET_NOT_IN_CONSTRUCTION(cls) __CLS_SETNOTINFO(cls, _CLS_IN_CONSTRUCTION)\n+\n /* The class number of this class.  This must be the same for both the\n    class and its meta class object.  */\n #define CLS_GETNUMBER(cls) (__CLS_INFO(cls) >> (HOST_BITS_PER_LONG/2))"}, {"sha": "4769d0f659291810c0594627da36c685112b23b1", "filename": "libobjc/objc-private/runtime.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c5c7efd6bbca80cb28fffd24600cbb58436f808/libobjc%2Fobjc-private%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c5c7efd6bbca80cb28fffd24600cbb58436f808/libobjc%2Fobjc-private%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fobjc-private%2Fruntime.h?ref=6c5c7efd6bbca80cb28fffd24600cbb58436f808", "patch": "@@ -67,7 +67,7 @@ extern void __objc_update_dispatch_table_for_class (Class);/* (objc-msg.c) */\n extern int  __objc_init_thread_system(void);    /* thread.c */\n extern int  __objc_fini_thread_system(void);    /* thread.c */\n extern void __objc_print_dtable_stats(void);    /* sendmsg.c */\n-\n+extern void __objc_init_class (Class class);  /* init.c */\n extern void class_add_method_list(Class, struct objc_method_list *);\n \n /* Registering instance methods as class methods for root classes */"}, {"sha": "0b6f3dfc99b30a62a2413fdb4cefdd6257afcb97", "filename": "libobjc/objc/runtime.h", "status": "modified", "additions": 118, "deletions": 7, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c5c7efd6bbca80cb28fffd24600cbb58436f808/libobjc%2Fobjc%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c5c7efd6bbca80cb28fffd24600cbb58436f808/libobjc%2Fobjc%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fobjc%2Fruntime.h?ref=6c5c7efd6bbca80cb28fffd24600cbb58436f808", "patch": "@@ -302,9 +302,36 @@ objc_EXPORT const char * ivar_getTypeEncoding (Ivar variable);\n    include instance variables of superclasses.  The list is terminated\n    by NULL.  Optionally, if you pass a non-NULL\n    'numberOfReturnedIvars' pointer, the unsigned int that it points to\n-   will be filled with the number of instance variables returned.  */\n+   will be filled with the number of instance variables returned.\n+   Return NULL for classes still in construction (ie, allocated using\n+   objc_allocatedClassPair() but not yet registered with the runtime\n+   using objc_registerClassPair()).  */\n objc_EXPORT Ivar * class_copyIvarList (Class class_, unsigned int *numberOfReturnedIvars);\n \n+/* Add an instance variable with name 'ivar_name' to class 'class_',\n+   where 'class_' is a class in construction that has been created\n+   using objc_allocateClassPair() and has not been registered with the\n+   runtime using objc_registerClassPair() yet.  You can not add\n+   instance variables to classes already registered with the runtime.\n+   'size' is the size of the instance variable, 'alignment' the\n+   alignment, and 'type' the type encoding of the variable type.  You\n+   can use objc_sizeof_type() (or sizeof()), objc_alignof_type() (or\n+   __alignof__()) and @encode() to determine the right 'size',\n+   'alignment' and 'type' for your instance variable.  For example, to\n+   add an instance variable name \"my_variable\" and of type 'id', you\n+   can use:\n+\n+   class_addIvar (class, \"my_variable\", sizeof (id), __alignof__ (id), \n+                  @encode (id));\n+\n+   Return YES if the variable was added, and NO if not.  In\n+   particular, return NO if 'class_' is Nil, or a meta-class or a\n+   class not in construction.  Return Nil also if 'ivar_name' or\n+   'type' is NULL, or 'size' is 0.\n+ */\n+objc_EXPORT BOOL class_addIvar (Class class_, const char * ivar_name, size_t size,\n+\t\t\t\tunsigned char alignment, const char *type);\n+\n /* Return the name of the property.  Return NULL if 'property' is\n    NULL.  */\n objc_EXPORT const char * property_getName (Property property);\n@@ -383,7 +410,6 @@ typedef Class (*objc_get_unknown_class_handler)(const char *class_name);\n objc_get_unknown_class_handler\n objc_setGetUnknownClassHandler (objc_get_unknown_class_handler new_handler);\n \n-\n /* Return the class with name 'name', if it is already registered with\n    the runtime.  If it is not registered, and\n    objc_setGetUnknownClassHandler() has been called to set a handler\n@@ -437,11 +463,11 @@ objc_EXPORT const char * class_getName (Class class_);\n    is Nil, return NO.  */\n objc_EXPORT BOOL class_isMetaClass (Class class_);\n \n-/* Return the superclass of 'class_'.  If 'class_' is Nil, or it is a root\n-   class, return Nil.\n-\n-   TODO: It may be worth to define this inline, since it is usually\n-   used in loops when traversing the class hierarchy.  */\n+/* Return the superclass of 'class_'.  If 'class_' is Nil, or it is a\n+   root class, return Nil.  If 'class_' is a class being constructed,\n+   that is, a class returned by objc_allocateClassPair() but before it\n+   has been registered with the runtime using\n+   objc_registerClassPair(), return Nil.  */\n objc_EXPORT Class class_getSuperclass (Class class_);\n \n /* Return the 'version' number of the class, which is an integer that\n@@ -496,6 +522,64 @@ method_setImplementation (Method method, IMP implementation);\n objc_EXPORT void\n method_exchangeImplementations (Method method_a, Method method_b);\n \n+/* Create a new class/meta-class pair.  This function is called to\n+   create a new class at runtime.  The class is created with\n+   superclass 'superclass' (use 'Nil' to create a new root class) and\n+   name 'class_name'.  'extraBytes' can be used to specify some extra\n+   space for indexed variables to be added at the end of the class and\n+   meta-class objects (it is recommended that you set extraBytes to\n+   0).  Once you have created the class, it is not usable yet.  You\n+   need to add any instance variables (by using class_addIvar()), any\n+   instance methods (by using class_addMethod()) and any class methods\n+   (by using class_addMethod() on the meta-class, as in\n+   class_addMethod (object_getClass (class), method)) that are\n+   required, and then you need to call objc_registerClassPair() to\n+   activate the class.  If you need to create a hierarchy of classes,\n+   you need to create and register them one at a time.  You can not\n+   create a new class using another class in construction as\n+   superclass.  Return Nil if 'class-name' is NULL or if a class with\n+   that name already exists or 'superclass' is a class still in\n+   construction.\n+\n+   Implementation Note: in the GNU runtime, allocating a class pair\n+   only creates the structures for the class pair, but does not\n+   register anything with the runtime.  The class is registered with\n+   the runtime only when objc_registerClassPair() is called.  In\n+   particular, if a class is in construction, objc_getClass() will not\n+   find it, the superclass will not know about it,\n+   class_getSuperclass() will return Nil and another thread may\n+   allocate a class pair with the same name; the conflict will only be\n+   detected when the classes are registered with the runtime.\n+ */\n+objc_EXPORT Class\n+objc_allocateClassPair (Class super_class, const char *class_name, \n+\t\t\tsize_t extraBytes);\n+\n+/* Register a class pair that was created with\n+   objc_allocateClassPair().  After you register a class, you can no\n+   longer make changes to its instance variables, but you can start\n+   creating instances of it.  Do nothing if 'class_' is NULL or if it\n+   is not a class allocated by objc_allocateClassPair() and still in\n+   construction.  */\n+objc_EXPORT void\n+objc_registerClassPair (Class class_);\n+\n+/* Dispose of a class pair created using objc_allocateClassPair().\n+   Call this function if you started creating a new class with\n+   objc_allocateClassPair() but then want to abort the process.  You\n+   should not access 'class_' after calling this method.  Note that if\n+   'class_' has already been registered with the runtime via\n+   objc_registerClassPair(), this function does nothing; you can only\n+   dispose of class pairs that are still being constructed.  Do\n+   nothing if class is 'Nil' or if 'class_' is not a class being\n+   constructed.  */\n+objc_EXPORT void\n+objc_disposeClassPair (Class class_);\n+\n+/* Compatibility Note: The Apple/NeXT runtime has the function\n+   objc_duplicateClass () but it's undocumented.  The GNU runtime does\n+   not have it.  */\n+\n \n /** Implementation: the following functions are in sendmsg.c.  */\n \n@@ -534,6 +618,33 @@ objc_EXPORT IMP class_getMethodImplementation (Class class_, SEL selector);\n    (object_getClass (class_), selector)).  */\n objc_EXPORT BOOL class_respondsToSelector (Class class_, SEL selector);\n \n+/* Add a method to a class.  Use this function to add a new method to\n+   a class (potentially overriding a method with the same selector in\n+   the superclass); if you want to modify an existing method, use\n+   method_setImplementation() instead (or class_replaceMethod ()).\n+   This method adds an instance method to 'class_'; to add a class\n+   method, get the meta class first, then add the method to the meta\n+   class, that is, use\n+\n+   class_addMethod (object_getClass (class_), selector,\n+   implementation, type);\n+\n+   Return YES if the method was added, and NO if not.  Do nothing if\n+   one of the arguments is NULL.  */\n+objc_EXPORT BOOL class_addMethod (Class class_, SEL selector, IMP implementation,\n+\t\t\t\t  const char *method_types);\n+\n+/* Replace a method in a class.  If the class already have a method\n+   with this 'selector', find it and use method_setImplementation() to\n+   replace the implementation with 'implementation' (method_types is\n+   ignored in that case).  If the class does not already have a method\n+   with this 'selector', call 'class_addMethod() to add it.\n+\n+   Return the previous implementation of the method, or NULL if none\n+   was found.  Return NULL if any of the arguments is NULL.  */\n+objc_EXPORT IMP class_replaceMethod (Class class_, SEL selector, IMP implementation,\n+\t\t\t\t     const char *method_types);\n+\n \n /** Implementation: the following functions are in methods.c.  */\n "}, {"sha": "ee1f0a36150c6ae0de0987291f02a994bd31cc6d", "filename": "libobjc/sendmsg.c", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c5c7efd6bbca80cb28fffd24600cbb58436f808/libobjc%2Fsendmsg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c5c7efd6bbca80cb28fffd24600cbb58436f808/libobjc%2Fsendmsg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fsendmsg.c?ref=6c5c7efd6bbca80cb28fffd24600cbb58436f808", "patch": "@@ -42,6 +42,10 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <assert.h> /* For assert */\n #include <string.h> /* For strlen */\n \n+/* Temporarily while we include objc/objc-api.h instead of objc-private/module-abi-8.h.  */\n+#define _CLS_IN_CONSTRUCTION 0x10L\n+#define CLS_IS_IN_CONSTRUCTION(cls) __CLS_ISINFO(cls, _CLS_IN_CONSTRUCTION)\n+\n /* This is how we hack STRUCT_VALUE to be 1 or 0.   */\n #define gen_rtx(args...) 1\n #define gen_rtx_MEM(args...) 1\n@@ -573,6 +577,80 @@ class_getClassMethod (Class class_, SEL selector)\n \t\t\t\t\t selector);\n }\n \n+BOOL\n+class_addMethod (Class class_, SEL selector, IMP implementation,\n+\t\t const char *method_types)\n+{\n+  struct objc_method_list *method_list;\n+  struct objc_method *method;\n+  const char *method_name;\n+\n+  if (class_ == Nil  ||  selector == NULL  ||  implementation == NULL  \n+      || method_types == NULL  || (strcmp (method_types, \"\") == 0))\n+    return NO;\n+\n+  method_name = sel_get_name (selector);\n+  if (method_name == NULL)\n+    return NO;\n+\n+  method_list = (struct objc_method_list *)objc_calloc (1, sizeof (struct objc_method_list));\n+  method_list->method_count = 1;\n+\n+  method = &(method_list->method_list[0]);\n+  method->method_name = objc_malloc (strlen (method_name) + 1);\n+  strcpy ((char *)method->method_name, method_name);\n+\n+  method->method_types = objc_malloc (strlen (method_types) + 1);\n+  strcpy ((char *)method->method_types, method_types);\n+  \n+  method->method_imp = implementation;\n+  \n+  if (CLS_IS_IN_CONSTRUCTION (class_))\n+    {\n+      /* We only need to add the method to the list.  It will be\n+\t registered with the runtime when the class pair is registered\n+\t (if ever).  */\n+      method_list->method_next = class_->methods;\n+      class_->methods = method_list;\n+    }\n+  else\n+    {\n+      /* Add the method to a live class.  */\n+      objc_mutex_lock (__objc_runtime_mutex);\n+      class_add_method_list (class_, method_list);\n+      objc_mutex_unlock (__objc_runtime_mutex);\n+    }\n+\n+  return YES;\n+}\n+\n+/* Temporarily, until we include objc/runtime.h.  */\n+extern IMP\n+method_setImplementation (struct objc_method * method, IMP implementation);\n+\n+IMP\n+class_replaceMethod (Class class_, SEL selector, IMP implementation,\n+\t\t     const char *method_types)\n+{\n+  struct objc_method * method;\n+\n+  if (class_ == Nil  ||  selector == NULL  ||  implementation == NULL\n+      || method_types == NULL)\n+    return NULL;\n+\n+  method = search_for_method_in_hierarchy (class_, selector);\n+\n+  if (method)\n+    {\n+      return method_setImplementation (method, implementation);\n+    }\n+  else\n+    {\n+      class_addMethod (class_, selector, implementation, method_types);\n+      return NULL;\n+    }\n+}\n+\n /* Search for a method starting from the current class up its hierarchy.\n    Return a pointer to the method's method structure if found.  NULL\n    otherwise. */   "}]}