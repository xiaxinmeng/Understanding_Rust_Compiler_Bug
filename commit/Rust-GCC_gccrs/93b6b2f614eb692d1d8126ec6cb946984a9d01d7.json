{"sha": "93b6b2f614eb692d1d8126ec6cb946984a9d01d7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTNiNmIyZjYxNGViNjkyZDFkODEyNmVjNmNiOTQ2OTg0YTlkMDFkNw==", "commit": {"author": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2021-08-18T14:22:03Z"}, "committer": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2021-09-02T23:41:02Z"}, "message": "libgfortran: Further fixes for GFC/CFI descriptor conversions.\n\nThis patch is for:\nPR100907 - Bind(c): failure handling wide character\nPR100911 - Bind(c): failure handling C_PTR\nPR100914 - Bind(c): errors handling complex\nPR100915 - Bind(c): failure handling C_FUNPTR\nPR100917 - Bind(c): errors handling long double real\n\nAll of these problems are related to the GFC descriptors constructed\nby the Fortran front end containing ambigous or incomplete\ninformation.  This patch does not attempt to change the GFC data\nstructure or the front end, and only makes the runtime interpret it in\nmore reasonable ways.  It's not a complete fix for any of the listed\nissues.\n\nThe Fortran front end does not distinguish between C_PTR and\nC_FUNPTR, mapping both onto BT_VOID.  That is what this patch does also.\n\nThe other bugs are related to GFC descriptors only containing elem_len\nand not kind.  For complex types, the elem_len needs to be divided by\n2 and then mapped onto a real kind.  On x86 targets, the kind\ncorresponding to C long double is different than its elem_len; since\nwe cannot accurately disambiguate between a 16-byte kind 10 long\ndouble from __float128, this patch arbitrarily prefers to interpret that as\nthe standard long double type rather than the GNU extension.\n\nSimilarly, for character types, the GFC descriptor cannot distinguish\nbetween character(kind=c_char, len=4) and character(kind=ucs4, len=1).\nBut since the front end currently rejects anything other than len=1\n(PR92482) this patch uses the latter interpretation.\n\n2021-09-01  Sandra Loosemore  <sandra@codesourcery.com>\n\t    Jos\u00e9 Rui Faustino de Sousa  <jrfsousa@gmail.com>\n\ngcc/testsuite/\n\tPR fortran/100911\n\tPR fortran/100915\n\tPR fortran/100916\n\t* gfortran.dg/PR100911.c: New file.\n\t* gfortran.dg/PR100911.f90: New file.\n\t* gfortran.dg/PR100914.c: New file.\n\t* gfortran.dg/PR100914.f90: New file.\n\t* gfortran.dg/PR100915.c: New file.\n\t* gfortran.dg/PR100915.f90: New file.\n\nlibgfortran/\n\tPR fortran/100907\n\tPR fortran/100911\n\tPR fortran/100914\n\tPR fortran/100915\n\tPR fortran/100917\n\t* ISO_Fortran_binding-1-tmpl.h (CFI_type_cfunptr): Make equivalent\n\tto CFI_type_cptr.\n\t* runtime/ISO_Fortran_binding.c (cfi_desc_to_gfc_desc): Fix\n\thandling of CFI_type_cptr and CFI_type_cfunptr.  Additional error\n\tchecking and code cleanup.\n\t(gfc_desc_to_cfi_desc): Likewise.  Also correct kind mapping\n\tfor character, complex, and long double types.", "tree": {"sha": "80aa640fe5bba90f1e1bc8e6b59cb24d9a0988d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/80aa640fe5bba90f1e1bc8e6b59cb24d9a0988d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93b6b2f614eb692d1d8126ec6cb946984a9d01d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93b6b2f614eb692d1d8126ec6cb946984a9d01d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93b6b2f614eb692d1d8126ec6cb946984a9d01d7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93b6b2f614eb692d1d8126ec6cb946984a9d01d7/comments", "author": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb17b5054118ec0f727956fd6e034b577b5e261c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb17b5054118ec0f727956fd6e034b577b5e261c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb17b5054118ec0f727956fd6e034b577b5e261c"}], "stats": {"total": 1723, "additions": 1696, "deletions": 27}, "files": [{"sha": "f3345ad2c937f2e70b232b8d575d32cf6636433b", "filename": "gcc/testsuite/gfortran.dg/PR100911.c", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93b6b2f614eb692d1d8126ec6cb946984a9d01d7/gcc%2Ftestsuite%2Fgfortran.dg%2FPR100911.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93b6b2f614eb692d1d8126ec6cb946984a9d01d7/gcc%2Ftestsuite%2Fgfortran.dg%2FPR100911.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FPR100911.c?ref=93b6b2f614eb692d1d8126ec6cb946984a9d01d7", "patch": "@@ -0,0 +1,82 @@\n+/* Test the fix for PR100911 */\n+\n+#include <assert.h>\n+#include <stdbool.h>\n+#include <stdio.h>\n+\n+#include <ISO_Fortran_binding.h>\n+\n+#define _CFI_type_mask 0xFF\n+#define _CFI_type_kind_shift 8\n+\n+#define _CFI_decode_type(NAME) (signed char)((NAME) & CFI_type_mask)\n+#define _CFI_decode_kind(NAME) (signed char)(((NAME) >> CFI_type_kind_shift) & CFI_type_mask)\n+\n+#define _CFI_encode_type(TYPE, KIND) (int16_t)\\\n+((((KIND) & CFI_type_mask) << CFI_type_kind_shift)\\\n+ | ((TYPE) & CFI_type_mask))\n+\n+#define N 11\n+#define M 7\n+\n+#define CFI_type_Cptr CFI_type_cptr\n+\n+typedef int* c_ptr;\n+\n+bool c_vrfy_cptr (const CFI_cdesc_t *restrict);\n+ \n+void check_tk (const CFI_cdesc_t*restrict, const CFI_type_t, const signed char, const size_t, const size_t);\n+\n+bool\n+c_vrfy_cptr (const CFI_cdesc_t *restrict auxp)\n+{\n+  CFI_index_t i, lb, ub, ex;\n+  size_t sz;\n+  c_ptr *ip = NULL;\n+\n+  assert (auxp);\n+  assert (auxp->base_addr);\n+  assert (auxp->elem_len>0);\n+  lb = auxp->dim[0].lower_bound;\n+  ex = auxp->dim[0].extent;\n+  assert (ex==11);\n+  sz = (size_t)auxp->elem_len / sizeof (c_ptr);\n+  assert (sz==1);\n+  ub = ex + lb - 1;\n+  ip = (c_ptr*)auxp->base_addr;\n+  for (i=0; i<ex; i++, ip+=sz)\n+    if ((**ip) != (int)(i+1))\n+      return false;\n+  for (i=lb; i<ub+1; i++)\n+    {\n+      ip = (c_ptr*)CFI_address(auxp, &i);\n+      if ((**ip) != (int)(i-lb+1))\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+void\n+check_tk (const CFI_cdesc_t *restrict auxp, const CFI_type_t type, const signed char kind, const size_t elem_len, const size_t nelem)\n+{\n+  signed char ityp, iknd;\n+\n+  assert (auxp);\n+  assert (auxp->elem_len==elem_len*nelem);\n+  assert (auxp->rank==1);\n+  assert (auxp->dim[0].sm>0);\n+  assert ((size_t)auxp->dim[0].sm==elem_len*nelem);\n+  /*  */\n+  assert (auxp->type==type);\n+  ityp = _CFI_decode_type(auxp->type);\n+  assert (ityp == CFI_type_cptr);\n+  iknd = _CFI_decode_kind(auxp->type);\n+  assert (_CFI_decode_type(type)==ityp);\n+  assert (kind==iknd);\n+  assert (c_vrfy_cptr (auxp));\n+  return;\n+}\n+\n+// Local Variables:\n+// mode: C\n+// End:"}, {"sha": "69f485b59de2e1f664284f32d2bec8d8bfcdbc3d", "filename": "gcc/testsuite/gfortran.dg/PR100911.f90", "status": "added", "additions": 282, "deletions": 0, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93b6b2f614eb692d1d8126ec6cb946984a9d01d7/gcc%2Ftestsuite%2Fgfortran.dg%2FPR100911.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93b6b2f614eb692d1d8126ec6cb946984a9d01d7/gcc%2Ftestsuite%2Fgfortran.dg%2FPR100911.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FPR100911.f90?ref=93b6b2f614eb692d1d8126ec6cb946984a9d01d7", "patch": "@@ -0,0 +1,282 @@\n+! { dg-do run }\n+! { dg-additional-sources PR100911.c }\n+!\n+! Test the fix for PR100911\n+! \n+\n+module isof_m\n+\n+  use, intrinsic :: iso_c_binding, only: &\n+    c_signed_char, c_int16_t\n+  \n+  implicit none\n+\n+  private\n+  \n+  public :: &\n+    CFI_type_cptr\n+ \n+  public ::      &\n+    check_tk_as, &\n+    check_tk_ar\n+  \n+  public ::          &\n+    cfi_encode_type\n+  \n+  integer, parameter :: CFI_type_t = c_int16_t\n+  \n+  integer(kind=c_int16_t), parameter :: CFI_type_mask = int(z\"FF\", kind=c_int16_t)\n+  integer(kind=c_int16_t), parameter :: CFI_type_kind_shift = 8_c_int16_t\n+\n+  ! Intrinsic types. Their kind number defines their storage size. */\n+  integer(kind=c_signed_char), parameter :: CFI_type_cptr   = 7\n+\n+  interface\n+    subroutine check_tk_as(a, t, k, e, n) &\n+      bind(c, name=\"check_tk\")\n+      use, intrinsic :: iso_c_binding, only: &\n+        c_int16_t, c_signed_char, c_size_t\n+      implicit none\n+      type(*),                       intent(in) :: a(:)\n+      integer(c_int16_t),     value, intent(in) :: t\n+      integer(c_signed_char), value, intent(in) :: k\n+      integer(c_size_t),      value, intent(in) :: e\n+      integer(c_size_t),      value, intent(in) :: n\n+    end subroutine check_tk_as\n+    subroutine check_tk_ar(a, t, k, e, n) &\n+      bind(c, name=\"check_tk\")\n+      use, intrinsic :: iso_c_binding, only: &\n+        c_int16_t, c_signed_char, c_size_t\n+      implicit none\n+      type(*),                       intent(in) :: a(..)\n+      integer(c_int16_t),     value, intent(in) :: t\n+      integer(c_signed_char), value, intent(in) :: k\n+      integer(c_size_t),      value, intent(in) :: e\n+      integer(c_size_t),      value, intent(in) :: n\n+    end subroutine check_tk_ar\n+  end interface\n+\n+contains\n+\n+  elemental function cfi_encode_type(type, kind) result(itype)\n+    integer(kind=c_signed_char), intent(in) :: type\n+    integer(kind=c_signed_char), intent(in) :: kind\n+\n+    integer(kind=c_int16_t) :: itype, ikind\n+\n+    itype = int(type, kind=c_int16_t)\n+    itype = iand(itype, CFI_type_mask)\n+    ikind = int(kind, kind=c_int16_t)\n+    ikind = iand(ikind, CFI_type_mask)\n+    ikind = shiftl(ikind, CFI_type_kind_shift)\n+    itype = ior(ikind, itype)\n+    return\n+  end function cfi_encode_type\n+  \n+end module isof_m\n+\n+module iso_check_m\n+\n+  use, intrinsic :: iso_c_binding, only: &\n+    c_signed_char, c_int16_t, c_size_t\n+\n+  use, intrinsic :: iso_c_binding, only: &\n+    c_int, c_ptr, c_loc, c_associated\n+\n+  use, intrinsic :: iso_c_binding, only: &\n+    c_ptr\n+\n+  use :: isof_m, only:  &\n+    CFI_type_cptr\n+\n+  use :: isof_m, only: &\n+    check_tk_as,       &\n+    check_tk_ar\n+\n+  use :: isof_m, only: &\n+    cfi_encode_type\n+  \n+  implicit none\n+\n+  integer                           :: i\n+  integer(kind=c_size_t), parameter :: b = 8\n+  integer,                parameter :: n = 11\n+  \n+  type, bind(c) :: c_foo_t\n+    integer(kind=c_int) :: a\n+  end type c_foo_t\n+  \n+  type(c_foo_t), parameter :: ref_c_foo_t(*) = [(c_foo_t(a=i), i=1,n)]\n+  \n+  type(c_foo_t), protected, target :: target_c_foo_t(n)\n+\n+  \n+contains\n+\n+  subroutine check_c_ptr()\n+    type(c_ptr) :: p(n)\n+    integer :: i\n+    !\n+    target_c_foo_t = ref_c_foo_t\n+    p = [(c_loc(target_c_foo_t(i)), i=1,n)]\n+    call f_check_c_ptr_as(p)\n+    if(any(target_c_foo_t(:)%a/=ref_c_foo_t(:)%a)) stop 1\n+    do i = 1, n\n+      if(.not.c_associated(p(i), c_loc(target_c_foo_t(i)))) stop 2\n+    end do\n+    target_c_foo_t = ref_c_foo_t\n+    p = [(c_loc(target_c_foo_t(i)), i=1,n)]\n+    call c_check_c_ptr_as(p)\n+    if(any(target_c_foo_t(:)%a/=ref_c_foo_t(:)%a)) stop 3\n+    do i = 1, n\n+      if(.not.c_associated(p(i), c_loc(target_c_foo_t(i)))) stop 4\n+    end do\n+    target_c_foo_t = ref_c_foo_t\n+    p = [(c_loc(target_c_foo_t(i)), i=1,n)]\n+    call f_check_c_ptr_ar(p)\n+    if(any(target_c_foo_t(:)%a/=ref_c_foo_t(:)%a)) stop 5\n+    do i = 1, n\n+      if(.not.c_associated(p(i), c_loc(target_c_foo_t(i)))) stop 6\n+    end do\n+    target_c_foo_t = ref_c_foo_t\n+    p = [(c_loc(target_c_foo_t(i)), i=1,n)]\n+    call c_check_c_ptr_ar(p)\n+    if(any(target_c_foo_t(:)%a/=ref_c_foo_t(:)%a)) stop 7\n+    do i = 1, n\n+      if(.not.c_associated(p(i), c_loc(target_c_foo_t(i)))) stop 8\n+    end do\n+    return\n+  end subroutine check_c_ptr\n+\n+  subroutine f_check_c_ptr_as(a)\n+    type(c_ptr), intent(in) :: a(:)\n+    !\n+    integer(kind=c_int16_t)     :: t\n+    integer(kind=c_signed_char) :: k\n+    integer(kind=c_size_t)      :: e\n+    !\n+    k = 0\n+    e = storage_size(a)/b\n+    t = cfi_encode_type(CFI_type_cptr, k)\n+    ! Assumes 64-bit target.\n+    ! if(e/=8) stop 9\n+    if(any(target_c_foo_t(:)%a/=ref_c_foo_t(:)%a)) stop 10\n+    do i = 1, n\n+      if(.not.c_associated(a(i), c_loc(target_c_foo_t(i)))) stop 11\n+    end do\n+    call check_tk_as(a, t, k, e, 1_c_size_t)\n+    if(any(target_c_foo_t(:)%a/=ref_c_foo_t(:)%a)) stop 12\n+    do i = 1, n\n+      if(.not.c_associated(a(i), c_loc(target_c_foo_t(i)))) stop 13\n+    end do\n+    return\n+  end subroutine f_check_c_ptr_as\n+\n+  subroutine c_check_c_ptr_as(a) bind(c)\n+    type(c_ptr), intent(in) :: a(:)\n+    integer(kind=c_int16_t)     :: t\n+    integer(kind=c_signed_char) :: k\n+    integer(kind=c_size_t)      :: e\n+    !\n+    k = 0\n+    e = storage_size(a)/b\n+    t = cfi_encode_type(CFI_type_cptr, k)\n+    ! Assumes 64-bit target.\n+    ! if(e/=8) stop 14\n+    if(any(target_c_foo_t(:)%a/=ref_c_foo_t(:)%a)) stop 15\n+    do i = 1, n\n+      if(.not.c_associated(a(i), c_loc(target_c_foo_t(i)))) stop 16\n+    end do\n+    call check_tk_as(a, t, k, e, 1_c_size_t)\n+    if(any(target_c_foo_t(:)%a/=ref_c_foo_t(:)%a)) stop 17\n+    do i = 1, n\n+      if(.not.c_associated(a(i), c_loc(target_c_foo_t(i)))) stop 18\n+    end do\n+    return\n+  end subroutine c_check_c_ptr_as\n+\n+  subroutine f_check_c_ptr_ar(a)\n+    type(c_ptr), intent(in) :: a(..)\n+    !\n+    integer(kind=c_int16_t)     :: t\n+    integer(kind=c_signed_char) :: k\n+    integer(kind=c_size_t)      :: e\n+    !\n+    k = 0\n+    e = storage_size(a)/b\n+    t = cfi_encode_type(CFI_type_cptr, k)\n+    ! Assumes 64-bit target.\n+    ! if(e/=8) stop 19\n+    select rank(a)\n+    rank(1)\n+      if(any(target_c_foo_t(:)%a/=ref_c_foo_t(:)%a)) stop 20\n+      do i = 1, n\n+        if(.not.c_associated(a(i), c_loc(target_c_foo_t(i)))) stop 21\n+      end do\n+    rank default\n+      stop 22\n+    end select\n+    call check_tk_ar(a, t, k, e, 1_c_size_t)\n+    select rank(a)\n+    rank(1)\n+      if(any(target_c_foo_t(:)%a/=ref_c_foo_t(:)%a)) stop 23\n+      do i = 1, n\n+        if(.not.c_associated(a(i), c_loc(target_c_foo_t(i)))) stop 24\n+      end do\n+    rank default\n+      stop 25\n+    end select\n+    return\n+  end subroutine f_check_c_ptr_ar\n+\n+  subroutine c_check_c_ptr_ar(a) bind(c)\n+    type(c_ptr), intent(in) :: a(..)\n+    integer(kind=c_int16_t)     :: t\n+    integer(kind=c_signed_char) :: k\n+    integer(kind=c_size_t)      :: e\n+    !\n+    k = 0\n+    e = storage_size(a)/b\n+    t = cfi_encode_type(CFI_type_cptr, k)\n+    ! Assumes 64-bit target.\n+    ! if(e/=8) stop 26\n+    select rank(a)\n+    rank(1)\n+      if(any(target_c_foo_t(:)%a/=ref_c_foo_t(:)%a)) stop 27\n+      do i = 1, n\n+        if(.not.c_associated(a(i), c_loc(target_c_foo_t(i)))) stop 28\n+      end do\n+    rank default\n+      stop 29\n+    end select\n+    call check_tk_ar(a, t, k, e, 1_c_size_t)\n+    select rank(a)\n+    rank(1)\n+      if(any(target_c_foo_t(:)%a/=ref_c_foo_t(:)%a)) stop 30\n+      do i = 1, n\n+        if(.not.c_associated(a(i), c_loc(target_c_foo_t(i)))) stop 31\n+      end do\n+    rank default\n+      stop 32\n+    end select\n+    return\n+  end subroutine c_check_c_ptr_ar\n+\n+end module iso_check_m\n+\n+program main_p\n+  \n+  use :: iso_check_m, only: &\n+    check_c_ptr\n+\n+  implicit none\n+\n+  call check_c_ptr()\n+  stop\n+\n+end program main_p\n+\n+!! Local Variables:\n+!! mode: f90\n+!! End:\n+"}, {"sha": "c6bd9733e0b70ae945f7a59b953fbec38799f23e", "filename": "gcc/testsuite/gfortran.dg/PR100914.c", "status": "added", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93b6b2f614eb692d1d8126ec6cb946984a9d01d7/gcc%2Ftestsuite%2Fgfortran.dg%2FPR100914.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93b6b2f614eb692d1d8126ec6cb946984a9d01d7/gcc%2Ftestsuite%2Fgfortran.dg%2FPR100914.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FPR100914.c?ref=93b6b2f614eb692d1d8126ec6cb946984a9d01d7", "patch": "@@ -0,0 +1,226 @@\n+/* Test the fix for PR100914 */\n+\n+#include <assert.h>\n+#include <complex.h>\n+#include <stdbool.h>\n+#include <stdio.h>\n+#include <math.h>\n+#include <quadmath.h>\n+\n+#include <ISO_Fortran_binding.h>\n+\n+#define _CFI_type_mask 0xFF\n+#define _CFI_type_kind_shift 8\n+\n+#define _CFI_decode_type(NAME) (signed char)((NAME) & CFI_type_mask)\n+#define _CFI_decode_kind(NAME) (signed char)(((NAME) >> CFI_type_kind_shift) & CFI_type_mask)\n+\n+#define _CFI_encode_type(TYPE, KIND) (int16_t)\\\n+((((KIND) & CFI_type_mask) << CFI_type_kind_shift)\\\n+ | ((TYPE) & CFI_type_mask))\n+\n+#undef CMPLXF\n+#define CMPLXF(x, y) ((float complex)((float)(x) + I * (float)(y)))\n+\n+#undef CMPLX\n+#define CMPLX(x, y) ((double complex)((double)(x) + (double complex)I * (double)(y)))\n+\n+#undef CMPLXL\n+#define CMPLXL(x, y) ((long double complex)((long double)(x) + (long double complex)I * (long double)(y)))\n+\n+#undef CMPLX\n+#define CMPLX(x, y) ((__complex128 )((double)(x) + (double complex)I * (double)(y)))\n+\n+#define N 11\n+#define M 7\n+\n+typedef float _Complex c_float_complex;\n+typedef double _Complex c_double_complex;\n+typedef long double _Complex c_long_double_complex;\n+typedef __complex128 c_float128_complex;\n+\n+bool c_vrfy_c_float_complex (const CFI_cdesc_t *restrict);\n+\n+bool c_vrfy_c_double_complex (const CFI_cdesc_t *restrict);\n+\n+bool c_vrfy_c_long_double_complex (const CFI_cdesc_t *restrict);\n+\n+bool c_vrfy_c_float128_complex (const CFI_cdesc_t *restrict);\n+\n+bool c_vrfy_complex (const CFI_cdesc_t *restrict);\n+ \n+bool c_vrfy_desc (const CFI_cdesc_t*restrict, const CFI_type_t, const signed char, const size_t, const size_t);\n+\n+void check_tk (const CFI_cdesc_t*restrict, const CFI_type_t, const signed char, const size_t, const size_t);\n+ \n+\n+\n+bool\n+c_vrfy_c_float_complex (const CFI_cdesc_t *restrict auxp)\n+{\n+  CFI_index_t i, lb, ub, ex;\n+  size_t sz;\n+  c_float_complex *ip = NULL;\n+\n+  assert (auxp);\n+  assert (auxp->base_addr);\n+  assert (auxp->elem_len>0);\n+  lb = auxp->dim[0].lower_bound;\n+  ex = auxp->dim[0].extent;\n+  assert (ex==11);\n+  sz = (size_t)auxp->elem_len / sizeof (c_float_complex);\n+  assert (sz==1);\n+  ub = ex + lb - 1;\n+  ip = (c_float_complex*)auxp->base_addr;\n+  for (i=0; i<ex; i++, ip+=sz)\n+    if ((cabsf (*ip-(c_float_complex)(CMPLXF((i+1), (2*(i+1)))))>(float)0.0))\n+      return false;\n+  for (i=lb; i<ub+1; i++)\n+    {\n+      ip = (c_float_complex*)CFI_address(auxp, &i);\n+      if ((cabsf (*ip-(c_float_complex)(CMPLXF((i-lb+1), (2*(i-lb+1)))))>(float)0.0))\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+bool\n+c_vrfy_c_double_complex (const CFI_cdesc_t *restrict auxp)\n+{\n+  CFI_index_t i, lb, ub, ex;\n+  size_t sz;\n+  c_double_complex *ip = NULL;\n+\n+  assert (auxp);\n+  assert (auxp->base_addr);\n+  assert (auxp->elem_len>0);\n+  lb = auxp->dim[0].lower_bound;\n+  ex = auxp->dim[0].extent;\n+  assert (ex==11);\n+  sz = (size_t)auxp->elem_len / sizeof (c_double_complex);\n+  assert (sz==1);\n+  ub = ex + lb - 1;\n+  ip = (c_double_complex*)auxp->base_addr;\n+  for (i=0; i<ex; i++, ip+=sz)\n+    if ((cabs (*ip-(c_double_complex)(CMPLX((i+1), (2*(i+1)))))>(double)0.0))\n+      return false;\n+  for (i=lb; i<ub+1; i++)\n+    {\n+      ip = (c_double_complex*)CFI_address(auxp, &i);\n+      if ((cabs (*ip-(c_double_complex)(CMPLX((i-lb+1), (2*(i-lb+1)))))>(double)0.0))\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+bool\n+c_vrfy_c_long_double_complex (const CFI_cdesc_t *restrict auxp)\n+{\n+  CFI_index_t i, lb, ub, ex;\n+  size_t sz;\n+  c_long_double_complex *ip = NULL;\n+\n+  assert (auxp);\n+  assert (auxp->base_addr);\n+  assert (auxp->elem_len>0);\n+  lb = auxp->dim[0].lower_bound;\n+  ex = auxp->dim[0].extent;\n+  assert (ex==11);\n+  sz = (size_t)auxp->elem_len / sizeof (c_long_double_complex);\n+  assert (sz==1);\n+  ub = ex + lb - 1;\n+  ip = (c_long_double_complex*)auxp->base_addr;\n+  for (i=0; i<ex; i++, ip+=sz)\n+    if ((cabsl (*ip-(c_long_double_complex)(CMPLXL((i+1), (2*(i+1)))))>(long double)0.0))\n+      return false;\n+  for (i=lb; i<ub+1; i++)\n+    {\n+      ip = (c_long_double_complex*)CFI_address(auxp, &i);\n+      if ((cabsl (*ip-(c_long_double_complex)(CMPLXL((i-lb+1), (2*(i-lb+1)))))>(long double)0.0))\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+bool\n+c_vrfy_c_float128_complex (const CFI_cdesc_t *restrict auxp)\n+{\n+  CFI_index_t i, lb, ub, ex;\n+  size_t sz;\n+  c_float128_complex *ip = NULL;\n+\n+  assert (auxp);\n+  assert (auxp->base_addr);\n+  assert (auxp->elem_len>0);\n+  lb = auxp->dim[0].lower_bound;\n+  ex = auxp->dim[0].extent;\n+  assert (ex==11);\n+  sz = (size_t)auxp->elem_len / sizeof (c_float128_complex);\n+  assert (sz==1);\n+  ub = ex + lb - 1;\n+  ip = (c_float128_complex*)auxp->base_addr;\n+  for (i=0; i<ex; i++, ip+=sz)\n+    if ((cabs ((double complex)(*ip-(c_float128_complex)(CMPLX((i+1), (2*(i+1))))))>(double)0.0))\n+      return false;\n+  for (i=lb; i<ub+1; i++)\n+    {\n+      ip = (c_float128_complex*)CFI_address(auxp, &i);\n+      if ((cabs ((double complex)(*ip-(c_float128_complex)(CMPLX((i-lb+1), (2*(i-lb+1))))))>(double)0.0))\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+bool\n+c_vrfy_complex (const CFI_cdesc_t *restrict auxp)\n+{\n+  signed char type, kind;\n+  \n+  assert (auxp);\n+  type = _CFI_decode_type(auxp->type);\n+  kind = _CFI_decode_kind(auxp->type);\n+  assert (type == CFI_type_Complex);\n+  switch (kind)\n+    {\n+    case 4:\n+      return c_vrfy_c_float_complex (auxp);\n+      break;\n+    case 8:\n+      return c_vrfy_c_double_complex (auxp);\n+      break;\n+    case 10:\n+      return c_vrfy_c_long_double_complex (auxp);\n+      break;\n+    case 16:\n+      return c_vrfy_c_float128_complex (auxp);\n+      break;\n+    default:\n+      assert (false);\n+    }\n+  return true;\n+}\n+\n+void\n+check_tk (const CFI_cdesc_t *restrict auxp, const CFI_type_t type, const signed char kind, const size_t elem_len, const size_t nelem)\n+{\n+  signed char ityp, iknd;\n+\n+  assert (auxp);\n+  assert (auxp->elem_len==elem_len*nelem);\n+  assert (auxp->rank==1);\n+  assert (auxp->dim[0].sm>0);\n+  assert ((size_t)auxp->dim[0].sm==elem_len*nelem);\n+  /*  */\n+  assert (auxp->type==type);\n+  ityp = _CFI_decode_type(auxp->type);\n+  assert (ityp == CFI_type_Complex);\n+  iknd = _CFI_decode_kind(auxp->type);\n+  assert (_CFI_decode_type(type)==ityp);\n+  assert (kind==iknd);\n+  assert (c_vrfy_complex (auxp));\n+  return;\n+}\n+\n+// Local Variables:\n+// mode: C\n+// End:"}, {"sha": "64b333506e3989bd63fafda482814e38cb57a513", "filename": "gcc/testsuite/gfortran.dg/PR100914.f90", "status": "added", "additions": 651, "deletions": 0, "changes": 651, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93b6b2f614eb692d1d8126ec6cb946984a9d01d7/gcc%2Ftestsuite%2Fgfortran.dg%2FPR100914.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93b6b2f614eb692d1d8126ec6cb946984a9d01d7/gcc%2Ftestsuite%2Fgfortran.dg%2FPR100914.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FPR100914.f90?ref=93b6b2f614eb692d1d8126ec6cb946984a9d01d7", "patch": "@@ -0,0 +1,651 @@\n+! Fails on x86 targets where sizeof(long double) == 16.\n+! { dg-do run { xfail { { x86_64*-*-* i?86*-*-* } && longdouble128 } } }\n+! { dg-additional-sources PR100914.c }\n+! { dg-require-effective-target fortran_real_c_float128 }\n+!\n+! Test the fix for PR100914\n+! \n+\n+module isof_m\n+\n+  use, intrinsic :: iso_c_binding, only: &\n+    c_signed_char, c_int16_t\n+  \n+  implicit none\n+\n+  private\n+  \n+  public ::                       &\n+    CFI_type_Complex,             &\n+    CFI_type_float_Complex,       &\n+    CFI_type_double_Complex,      &\n+    CFI_type_long_double_Complex, &\n+    CFI_type_float128_Complex\n+ \n+  public ::      &\n+    check_tk_as, &\n+    check_tk_ar\n+  \n+  \n+  public ::          &\n+    cfi_encode_type\n+  \n+  integer, parameter :: CFI_type_t = c_int16_t\n+  \n+  integer(kind=c_int16_t), parameter :: CFI_type_mask = int(z\"FF\", kind=c_int16_t)\n+  integer(kind=c_int16_t), parameter :: CFI_type_kind_shift = 8_c_int16_t\n+\n+  ! Intrinsic types. Their kind number defines their storage size. */\n+  integer(kind=c_signed_char), parameter :: CFI_type_Complex = 4\n+\n+  ! C-Fortran Interoperability types.\n+  integer(kind=cfi_type_t), parameter :: CFI_type_float_Complex = &\n+    ior(int(CFI_type_Complex, kind=c_int16_t), shiftl(4_c_int16_t, CFI_type_kind_shift))\n+  integer(kind=cfi_type_t), parameter :: CFI_type_double_Complex = &\n+    ior(int(CFI_type_Complex, kind=c_int16_t), shiftl(8_c_int16_t, CFI_type_kind_shift))\n+  integer(kind=cfi_type_t), parameter :: CFI_type_long_double_Complex = &\n+    ior(int(CFI_type_Complex, kind=c_int16_t), shiftl(10_c_int16_t, CFI_type_kind_shift))\n+  integer(kind=cfi_type_t), parameter :: CFI_type_float128_Complex = &\n+    ior(int(CFI_type_Complex, kind=c_int16_t), shiftl(16_c_int16_t, CFI_type_kind_shift))\n+\n+  interface\n+    subroutine check_tk_as(a, t, k, e, n) &\n+      bind(c, name=\"check_tk\")\n+      use, intrinsic :: iso_c_binding, only: &\n+        c_int16_t, c_signed_char, c_size_t\n+      implicit none\n+      type(*),                       intent(in) :: a(:)\n+      integer(c_int16_t),     value, intent(in) :: t\n+      integer(c_signed_char), value, intent(in) :: k\n+      integer(c_size_t),      value, intent(in) :: e\n+      integer(c_size_t),      value, intent(in) :: n\n+    end subroutine check_tk_as\n+    subroutine check_tk_ar(a, t, k, e, n) &\n+      bind(c, name=\"check_tk\")\n+      use, intrinsic :: iso_c_binding, only: &\n+        c_int16_t, c_signed_char, c_size_t\n+      implicit none\n+      type(*),                       intent(in) :: a(..)\n+      integer(c_int16_t),     value, intent(in) :: t\n+      integer(c_signed_char), value, intent(in) :: k\n+      integer(c_size_t),      value, intent(in) :: e\n+      integer(c_size_t),      value, intent(in) :: n\n+    end subroutine check_tk_ar\n+  end interface\n+\n+contains\n+\n+  elemental function cfi_encode_type(type, kind) result(itype)\n+    integer(kind=c_signed_char), intent(in) :: type\n+    integer(kind=c_signed_char), intent(in) :: kind\n+\n+    integer(kind=c_int16_t) :: itype, ikind\n+\n+    itype = int(type, kind=c_int16_t)\n+    itype = iand(itype, CFI_type_mask)\n+    ikind = int(kind, kind=c_int16_t)\n+    ikind = iand(ikind, CFI_type_mask)\n+    ikind = shiftl(ikind, CFI_type_kind_shift)\n+    itype = ior(ikind, itype)\n+    return\n+  end function cfi_encode_type\n+  \n+end module isof_m\n+\n+module iso_check_m\n+\n+  use, intrinsic :: iso_c_binding, only: &\n+    c_signed_char, c_int16_t, c_size_t\n+\n+  use, intrinsic :: iso_c_binding, only: &\n+    c_float_complex,                      &\n+    c_double_complex,                     &\n+    c_long_double_complex,                &\n+    c_float128_complex\n+\n+  use :: isof_m, only:  &\n+    CFI_type_Complex\n+\n+  use :: isof_m, only:            &\n+    CFI_type_float_Complex,       &\n+    CFI_type_double_Complex,      &\n+    CFI_type_long_double_Complex, &\n+    CFI_type_float128_Complex\n+\n+  use :: isof_m, only: &\n+    check_tk_as,       &\n+    check_tk_ar\n+\n+  use :: isof_m, only: &\n+    cfi_encode_type\n+  \n+  implicit none\n+\n+  private\n+\n+  public ::                      &\n+    check_c_float_complex,       &\n+    check_c_double_complex,      &\n+    check_c_long_double_complex, &\n+    check_c_float128_complex    \n+\n+  integer                           :: i\n+  integer(kind=c_size_t), parameter :: b = 8\n+  integer,                parameter :: n = 11  \n+  \n+  complex(kind=c_float_complex), parameter :: ref_c_float_complex(*)  = &\n+    [(cmplx(i, 2*i, kind=c_float_complex),  i=1,n)]\n+  complex(kind=c_double_complex), parameter :: ref_c_double_complex(*)  = &\n+    [(cmplx(i, 2*i, kind=c_double_complex),  i=1,n)]\n+  complex(kind=c_long_double_complex), parameter :: ref_c_long_double_complex(*)  = &\n+    [(cmplx(i, 2*i, kind=c_long_double_complex),  i=1,n)]\n+  complex(kind=c_float128_complex), parameter :: ref_c_float128_complex(*)  = &\n+    [(cmplx(i, 2*i, kind=c_float128_complex),  i=1,n)]\n+  \n+contains\n+\n+  ! CFI_type_float_complex\n+  subroutine check_c_float_complex()\n+    complex(kind=c_float_complex) :: a(n)\n+    !\n+    if (c_float_complex/=4) stop 1\n+    a = ref_c_float_complex\n+    call f_check_c_float_complex_as(a)\n+    if(any(abs(a-ref_c_float_complex)>0.0_c_float_complex)) stop 2\n+    a = ref_c_float_complex\n+    call c_check_c_float_complex_as(a)\n+    if(any(abs(a-ref_c_float_complex)>0.0_c_float_complex)) stop 3\n+    a = ref_c_float_complex\n+    call f_check_c_float_complex_ar(a)\n+    if(any(abs(a-ref_c_float_complex)>0.0_c_float_complex)) stop 4\n+    a = ref_c_float_complex\n+    call c_check_c_float_complex_ar(a)\n+    if(any(abs(a-ref_c_float_complex)>0.0_c_float_complex)) stop 5\n+    return\n+  end subroutine check_c_float_complex\n+\n+  subroutine f_check_c_float_complex_as(a)\n+    complex(kind=c_float_complex), intent(in) :: a(:)\n+    !\n+    integer(kind=c_int16_t)     :: t\n+    integer(kind=c_signed_char) :: k\n+    integer(kind=c_size_t)      :: e\n+    !\n+    k = kind(a)\n+    e = storage_size(a)/b\n+    t = cfi_encode_type(CFI_type_complex, k)\n+    if(k<=0_c_signed_char) stop 6\n+    if(k/=4_c_signed_char) stop 7\n+    if(int(k, kind=c_size_t)/=(e/2)) stop 8\n+    if(t/=CFI_type_float_complex) stop 9\n+    if(any(abs(a-ref_c_float_complex)>0.0_c_float_complex)) stop 10\n+    call check_tk_as(a, t, k, e, 1_c_size_t)\n+    if(any(abs(a-ref_c_float_complex)>0.0_c_float_complex)) stop 11\n+    return\n+  end subroutine f_check_c_float_complex_as\n+\n+  subroutine c_check_c_float_complex_as(a) bind(c)\n+    complex(kind=c_float_complex), intent(in) :: a(:)\n+    !\n+    integer(kind=c_int16_t)     :: t\n+    integer(kind=c_signed_char) :: k\n+    integer(kind=c_size_t)      :: e\n+    !\n+    k = kind(a)\n+    e = storage_size(a)/b\n+    t = cfi_encode_type(CFI_type_complex, k)\n+    if(k<=0_c_signed_char) stop 12\n+    if(k/=4_c_signed_char) stop 13\n+    if(int(k, kind=c_size_t)/=(e/2)) stop 14\n+    if(t/=CFI_type_float_complex) stop 15\n+    if(any(abs(a-ref_c_float_complex)>0.0_c_float_complex)) stop 16\n+    call check_tk_as(a, t, k, e, 1_c_size_t)\n+    if(any(abs(a-ref_c_float_complex)>0.0_c_float_complex)) stop 17\n+    return\n+  end subroutine c_check_c_float_complex_as\n+\n+  subroutine f_check_c_float_complex_ar(a)\n+    complex(kind=c_float_complex), intent(in) :: a(..)\n+    !\n+    integer(kind=c_int16_t)     :: t\n+    integer(kind=c_signed_char) :: k\n+    integer(kind=c_size_t)      :: e\n+    !\n+    k = kind(a)\n+    e = storage_size(a)/b\n+    t = cfi_encode_type(CFI_type_complex, k)\n+    if(k<=0_c_signed_char) stop 18\n+    if(k/=4_c_signed_char) stop 19\n+    if(int(k, kind=c_size_t)/=(e/2)) stop 20\n+    if(t/=CFI_type_float_complex) stop 21\n+    select rank(a)\n+    rank(1)\n+      if(any(abs(a-ref_c_float_complex)>0.0_c_float_complex)) stop 22\n+    rank default\n+      stop 23\n+    end select\n+    call check_tk_ar(a, t, k, e, 1_c_size_t)\n+    select rank(a)\n+    rank(1)\n+      if(any(abs(a-ref_c_float_complex)>0.0_c_float_complex)) stop 24\n+    rank default\n+      stop 25\n+    end select\n+    return\n+  end subroutine f_check_c_float_complex_ar\n+\n+  subroutine c_check_c_float_complex_ar(a) bind(c)\n+    complex(kind=c_float_complex), intent(in) :: a(..)\n+    !\n+    integer(kind=c_int16_t)     :: t\n+    integer(kind=c_signed_char) :: k\n+    integer(kind=c_size_t)      :: e\n+    !\n+    k = kind(a)\n+    e = storage_size(a)/b\n+    t = cfi_encode_type(CFI_type_complex, k)\n+    if(k<=0_c_signed_char) stop 26\n+    if(k/=4_c_signed_char) stop 27\n+    if(int(k, kind=c_size_t)/=(e/2)) stop 28\n+    if(t/=CFI_type_float_complex) stop 29\n+    select rank(a)\n+    rank(1)\n+      if(any(abs(a-ref_c_float_complex)>0.0_c_float_complex)) stop 30\n+    rank default\n+      stop 31\n+    end select\n+    call check_tk_ar(a, t, k, e, 1_c_size_t)\n+    select rank(a)\n+    rank(1)\n+      if(any(abs(a-ref_c_float_complex)>0.0_c_float_complex)) stop 32\n+    rank default\n+      stop 33\n+    end select\n+    return\n+  end subroutine c_check_c_float_complex_ar\n+\n+  ! CFI_type_double_complex\n+  subroutine check_c_double_complex()\n+    complex(kind=c_double_complex) :: a(n)\n+    !\n+    if (c_double_complex/=8) stop 34\n+    a = ref_c_double_complex\n+    call f_check_c_double_complex_as(a)\n+    if(any(abs(a-ref_c_double_complex)>0.0_c_double_complex)) stop 35\n+    a = ref_c_double_complex\n+    call c_check_c_double_complex_as(a)\n+    if(any(abs(a-ref_c_double_complex)>0.0_c_double_complex)) stop 36\n+    a = ref_c_double_complex\n+    call f_check_c_double_complex_ar(a)\n+    if(any(abs(a-ref_c_double_complex)>0.0_c_double_complex)) stop 37\n+    a = ref_c_double_complex\n+    call c_check_c_double_complex_ar(a)\n+    if(any(abs(a-ref_c_double_complex)>0.0_c_double_complex)) stop 38\n+    return\n+  end subroutine check_c_double_complex\n+\n+  subroutine f_check_c_double_complex_as(a)\n+    complex(kind=c_double_complex), intent(in) :: a(:)\n+    !\n+    integer(kind=c_int16_t)     :: t\n+    integer(kind=c_signed_char) :: k\n+    integer(kind=c_size_t)      :: e\n+    !\n+    k = kind(a)\n+    e = storage_size(a)/b\n+    t = cfi_encode_type(CFI_type_complex, k)\n+    if(k<=0_c_signed_char) stop 39\n+    if(k/=8_c_signed_char) stop 40\n+    if(int(k, kind=c_size_t)/=(e/2)) stop 41\n+    if(t/=CFI_type_double_complex) stop 42\n+    if(any(abs(a-ref_c_double_complex)>0.0_c_double_complex)) stop 43\n+    call check_tk_as(a, t, k, e, 1_c_size_t)\n+    if(any(abs(a-ref_c_double_complex)>0.0_c_double_complex)) stop 44\n+    return\n+  end subroutine f_check_c_double_complex_as\n+\n+  subroutine c_check_c_double_complex_as(a) bind(c)\n+    complex(kind=c_double_complex), intent(in) :: a(:)\n+    !\n+    integer(kind=c_int16_t)     :: t\n+    integer(kind=c_signed_char) :: k\n+    integer(kind=c_size_t)      :: e\n+    !\n+    k = kind(a)\n+    e = storage_size(a)/b\n+    t = cfi_encode_type(CFI_type_complex, k)\n+    if(k<=0_c_signed_char) stop 45\n+    if(k/=8_c_signed_char) stop 46\n+    if(int(k, kind=c_size_t)/=(e/2)) stop 47\n+    if(t/=CFI_type_double_complex) stop 48\n+    if(any(abs(a-ref_c_double_complex)>0.0_c_double_complex)) stop 49\n+    call check_tk_as(a, t, k, e, 1_c_size_t)\n+    if(any(abs(a-ref_c_double_complex)>0.0_c_double_complex)) stop 50\n+    return\n+  end subroutine c_check_c_double_complex_as\n+\n+  subroutine f_check_c_double_complex_ar(a)\n+    complex(kind=c_double_complex), intent(in) :: a(..)\n+    !\n+    integer(kind=c_int16_t)     :: t\n+    integer(kind=c_signed_char) :: k\n+    integer(kind=c_size_t)      :: e\n+    !\n+    k = kind(a)\n+    e = storage_size(a)/b\n+    t = cfi_encode_type(CFI_type_complex, k)\n+    if(k<=0_c_signed_char) stop 51\n+    if(k/=8_c_signed_char) stop 52\n+    if(int(k, kind=c_size_t)/=(e/2)) stop 53\n+    if(t/=CFI_type_double_complex) stop 54\n+    select rank(a)\n+    rank(1)\n+      if(any(abs(a-ref_c_double_complex)>0.0_c_double_complex)) stop 55\n+    rank default\n+      stop 56\n+    end select\n+    call check_tk_ar(a, t, k, e, 1_c_size_t)\n+    select rank(a)\n+    rank(1)\n+      if(any(abs(a-ref_c_double_complex)>0.0_c_double_complex)) stop 57\n+    rank default\n+      stop 58\n+    end select\n+    return\n+  end subroutine f_check_c_double_complex_ar\n+\n+  subroutine c_check_c_double_complex_ar(a) bind(c)\n+    complex(kind=c_double_complex), intent(in) :: a(..)\n+    !\n+    integer(kind=c_int16_t)     :: t\n+    integer(kind=c_signed_char) :: k\n+    integer(kind=c_size_t)      :: e\n+    !\n+    k = kind(a)\n+    e = storage_size(a)/b\n+    t = cfi_encode_type(CFI_type_complex, k)\n+    if(k<=0_c_signed_char) stop 59\n+    if(k/=8_c_signed_char) stop 60\n+    if(int(k, kind=c_size_t)/=(e/2)) stop 61\n+    if(t/=CFI_type_double_complex) stop 62\n+    select rank(a)\n+    rank(1)\n+      if(any(abs(a-ref_c_double_complex)>0.0_c_double_complex)) stop 63\n+    rank default\n+      stop 64\n+    end select\n+    call check_tk_ar(a, t, k, e, 1_c_size_t)\n+    select rank(a)\n+    rank(1)\n+      if(any(abs(a-ref_c_double_complex)>0.0_c_double_complex)) stop 65\n+    rank default\n+      stop 66\n+    end select\n+    return\n+  end subroutine c_check_c_double_complex_ar\n+\n+  ! CFI_type_long_double_complex\n+  subroutine check_c_long_double_complex()\n+    complex(kind=c_long_double_complex) :: a(n)\n+    !\n+    if (c_long_double_complex/=10) stop 67\n+    a = ref_c_long_double_complex\n+    call f_check_c_long_double_complex_as(a)\n+    if(any(abs(a-ref_c_long_double_complex)>0.0_c_long_double_complex)) stop 68\n+    a = ref_c_long_double_complex\n+    call c_check_c_long_double_complex_as(a)\n+    if(any(abs(a-ref_c_long_double_complex)>0.0_c_long_double_complex)) stop 69\n+    a = ref_c_long_double_complex\n+    call f_check_c_long_double_complex_ar(a)\n+    if(any(abs(a-ref_c_long_double_complex)>0.0_c_long_double_complex)) stop 70\n+    a = ref_c_long_double_complex\n+    call c_check_c_long_double_complex_ar(a)\n+    if(any(abs(a-ref_c_long_double_complex)>0.0_c_long_double_complex)) stop 71\n+    return\n+  end subroutine check_c_long_double_complex\n+\n+  subroutine f_check_c_long_double_complex_as(a)\n+    complex(kind=c_long_double_complex), intent(in) :: a(:)\n+    !\n+    integer(kind=c_int16_t)     :: t\n+    integer(kind=c_signed_char) :: k\n+    integer(kind=c_size_t)      :: e\n+    !\n+    k = kind(a)\n+    e = storage_size(a)/b\n+    t = cfi_encode_type(CFI_type_complex, k)\n+    if(k<=0_c_signed_char) stop 72\n+    if(k/=10_c_signed_char) stop 73\n+    if(e/=32) stop 74\n+    if(t/=CFI_type_long_double_complex) stop 75\n+    if(any(abs(a-ref_c_long_double_complex)>0.0_c_long_double_complex)) stop 76\n+    call check_tk_as(a, t, k, e, 1_c_size_t)\n+    if(any(abs(a-ref_c_long_double_complex)>0.0_c_long_double_complex)) stop 77\n+    return\n+  end subroutine f_check_c_long_double_complex_as\n+\n+  subroutine c_check_c_long_double_complex_as(a) bind(c)\n+    complex(kind=c_long_double_complex), intent(in) :: a(:)\n+    !\n+    integer(kind=c_int16_t)     :: t\n+    integer(kind=c_signed_char) :: k\n+    integer(kind=c_size_t)      :: e\n+    !\n+    k = kind(a)\n+    e = storage_size(a)/b\n+    t = cfi_encode_type(CFI_type_complex, k)\n+    if(k<=0_c_signed_char) stop 78\n+    if(k/=10_c_signed_char) stop 79\n+    if(e/=32) stop 80\n+    if(t/=CFI_type_long_double_complex) stop 81\n+    if(any(abs(a-ref_c_long_double_complex)>0.0_c_long_double_complex)) stop 82\n+    call check_tk_as(a, t, k, e, 1_c_size_t)\n+    if(any(abs(a-ref_c_long_double_complex)>0.0_c_long_double_complex)) stop 83\n+    return\n+  end subroutine c_check_c_long_double_complex_as\n+\n+  subroutine f_check_c_long_double_complex_ar(a)\n+    complex(kind=c_long_double_complex), intent(in) :: a(..)\n+    !\n+    integer(kind=c_int16_t)     :: t\n+    integer(kind=c_signed_char) :: k\n+    integer(kind=c_size_t)      :: e\n+    !\n+    k = kind(a)\n+    e = storage_size(a)/b\n+    t = cfi_encode_type(CFI_type_complex, k)\n+    if(k<=0_c_signed_char) stop 84\n+    if(k/=10_c_signed_char) stop 85\n+    if(e/=32) stop 86\n+    if(t/=CFI_type_long_double_complex) stop 87\n+    select rank(a)\n+    rank(1)\n+      if(any(abs(a-ref_c_long_double_complex)>0.0_c_long_double_complex)) stop 88\n+    rank default\n+      stop 89\n+    end select\n+    call check_tk_ar(a, t, k, e, 1_c_size_t)\n+    select rank(a)\n+    rank(1)\n+      if(any(abs(a-ref_c_long_double_complex)>0.0_c_long_double_complex)) stop 90\n+    rank default\n+      stop 91\n+    end select\n+    return\n+  end subroutine f_check_c_long_double_complex_ar\n+\n+  subroutine c_check_c_long_double_complex_ar(a) bind(c)\n+    complex(kind=c_long_double_complex), intent(in) :: a(..)\n+    !\n+    integer(kind=c_int16_t)     :: t\n+    integer(kind=c_signed_char) :: k\n+    integer(kind=c_size_t)      :: e\n+    !\n+    k = kind(a)\n+    e = storage_size(a)/b\n+    t = cfi_encode_type(CFI_type_complex, k)\n+    if(k<=0_c_signed_char) stop 92\n+    if(k/=10_c_signed_char) stop 93\n+    if(e/=32) stop 94\n+    if(t/=CFI_type_long_double_complex) stop 95\n+    select rank(a)\n+    rank(1)\n+      if(any(abs(a-ref_c_long_double_complex)>0.0_c_long_double_complex)) stop 96\n+    rank default\n+      stop 97\n+    end select\n+    call check_tk_ar(a, t, k, e, 1_c_size_t)\n+    select rank(a)\n+    rank(1)\n+      if(any(abs(a-ref_c_long_double_complex)>0.0_c_long_double_complex)) stop 98\n+    rank default\n+      stop 99\n+    end select\n+    return\n+  end subroutine c_check_c_long_double_complex_ar\n+\n+  ! CFI_type_float128_complex\n+  subroutine check_c_float128_complex()\n+    complex(kind=c_float128_complex) :: a(n)\n+    !\n+    if (c_float128_complex/=16) stop 100\n+    a = ref_c_float128_complex\n+    call f_check_c_float128_complex_as(a)\n+    if(any(abs(a-ref_c_float128_complex)>0.0_c_float128_complex)) stop 101\n+    a = ref_c_float128_complex\n+    call c_check_c_float128_complex_as(a)\n+    if(any(abs(a-ref_c_float128_complex)>0.0_c_float128_complex)) stop 102\n+    a = ref_c_float128_complex\n+    call f_check_c_float128_complex_ar(a)\n+    if(any(abs(a-ref_c_float128_complex)>0.0_c_float128_complex)) stop 103\n+    a = ref_c_float128_complex\n+    call c_check_c_float128_complex_ar(a)\n+    if(any(abs(a-ref_c_float128_complex)>0.0_c_float128_complex)) stop 104\n+    return\n+  end subroutine check_c_float128_complex\n+\n+  subroutine f_check_c_float128_complex_as(a)\n+    complex(kind=c_float128_complex), intent(in) :: a(:)\n+    !\n+    integer(kind=c_int16_t)     :: t\n+    integer(kind=c_signed_char) :: k\n+    integer(kind=c_size_t)      :: e\n+    !\n+    k = kind(a)\n+    e = storage_size(a)/b\n+    t = cfi_encode_type(CFI_type_complex, k)\n+    if(k<=0_c_signed_char) stop 105\n+    if(k/=16_c_signed_char) stop 106\n+    if(int(k, kind=c_size_t)/=(e/2)) stop 107\n+    if(t/=CFI_type_float128_complex) stop 108\n+    if(any(abs(a-ref_c_float128_complex)>0.0_c_float128_complex)) stop 109\n+    call check_tk_as(a, t, k, e, 1_c_size_t)\n+    if(any(abs(a-ref_c_float128_complex)>0.0_c_float128_complex)) stop 110\n+    return\n+  end subroutine f_check_c_float128_complex_as\n+\n+  subroutine c_check_c_float128_complex_as(a) bind(c)\n+    complex(kind=c_float128_complex), intent(in) :: a(:)\n+    !\n+    integer(kind=c_int16_t)     :: t\n+    integer(kind=c_signed_char) :: k\n+    integer(kind=c_size_t)      :: e\n+    !\n+    k = kind(a)\n+    e = storage_size(a)/b\n+    t = cfi_encode_type(CFI_type_complex, k)\n+    if(k<=0_c_signed_char) stop 111\n+    if(k/=16_c_signed_char) stop 112\n+    if(int(k, kind=c_size_t)/=(e/2)) stop 113\n+    if(t/=CFI_type_float128_complex) stop 114\n+    if(any(abs(a-ref_c_float128_complex)>0.0_c_float128_complex)) stop 115\n+    call check_tk_as(a, t, k, e, 1_c_size_t)\n+    if(any(abs(a-ref_c_float128_complex)>0.0_c_float128_complex)) stop 116\n+    return\n+  end subroutine c_check_c_float128_complex_as\n+\n+  subroutine f_check_c_float128_complex_ar(a)\n+    complex(kind=c_float128_complex), intent(in) :: a(..)\n+    !\n+    integer(kind=c_int16_t)     :: t\n+    integer(kind=c_signed_char) :: k\n+    integer(kind=c_size_t)      :: e\n+    !\n+    k = kind(a)\n+    e = storage_size(a)/b\n+    t = cfi_encode_type(CFI_type_complex, k)\n+    if(k<=0_c_signed_char) stop 117\n+    if(k/=16_c_signed_char) stop 118\n+    if(int(k, kind=c_size_t)/=(e/2)) stop 119\n+    if(t/=CFI_type_float128_complex) stop 120\n+    select rank(a)\n+    rank(1)\n+      if(any(abs(a-ref_c_float128_complex)>0.0_c_float128_complex)) stop 121\n+    rank default\n+      stop 122\n+    end select\n+    call check_tk_ar(a, t, k, e, 1_c_size_t)\n+    select rank(a)\n+    rank(1)\n+      if(any(abs(a-ref_c_float128_complex)>0.0_c_float128_complex)) stop 123\n+    rank default\n+      stop 124\n+    end select\n+    return\n+  end subroutine f_check_c_float128_complex_ar\n+\n+  subroutine c_check_c_float128_complex_ar(a) bind(c)\n+    complex(kind=c_float128_complex), intent(in) :: a(..)\n+    !\n+    integer(kind=c_int16_t)     :: t\n+    integer(kind=c_signed_char) :: k\n+    integer(kind=c_size_t)      :: e\n+    !\n+    k = kind(a)\n+    e = storage_size(a)/b\n+    t = cfi_encode_type(CFI_type_complex, k)\n+    if(k<=0_c_signed_char) stop 125\n+    if(k/=16_c_signed_char) stop 126\n+    if(int(k, kind=c_size_t)/=(e/2)) stop 127\n+    if(t/=CFI_type_float128_complex) stop 128\n+    select rank(a)\n+    rank(1)\n+      if(any(abs(a-ref_c_float128_complex)>0.0_c_float128_complex)) stop 129\n+    rank default\n+      stop 130\n+    end select\n+    call check_tk_ar(a, t, k, e, 1_c_size_t)\n+    select rank(a)\n+    rank(1)\n+      if(any(abs(a-ref_c_float128_complex)>0.0_c_float128_complex)) stop 131\n+    rank default\n+      stop 132\n+    end select\n+    return\n+  end subroutine c_check_c_float128_complex_ar\n+\n+end module iso_check_m\n+\n+program main_p\n+  \n+  use :: iso_check_m, only:      &\n+    check_c_float_complex,       &\n+    check_c_double_complex,      &\n+    check_c_long_double_complex, &\n+    check_c_float128_complex\n+\n+  implicit none\n+\n+  call check_c_float_complex()\n+  call check_c_double_complex()\n+  ! see PR100910\n+  ! call check_c_long_double_complex()\n+  call check_c_float128_complex()\n+  stop\n+\n+end program main_p\n+\n+!! Local Variables:\n+!! mode: f90\n+!! End:\n+"}, {"sha": "5b219b371876b862db96ad28f5edd561ae3dda21", "filename": "gcc/testsuite/gfortran.dg/PR100915.c", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93b6b2f614eb692d1d8126ec6cb946984a9d01d7/gcc%2Ftestsuite%2Fgfortran.dg%2FPR100915.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93b6b2f614eb692d1d8126ec6cb946984a9d01d7/gcc%2Ftestsuite%2Fgfortran.dg%2FPR100915.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FPR100915.c?ref=93b6b2f614eb692d1d8126ec6cb946984a9d01d7", "patch": "@@ -0,0 +1,80 @@\n+/* Test the fix for PR100915 */\n+\n+#include <assert.h>\n+#include <stdbool.h>\n+#include <stdio.h>\n+\n+#include <ISO_Fortran_binding.h>\n+\n+#define _CFI_type_mask 0xFF\n+#define _CFI_type_kind_shift 8\n+\n+#define _CFI_decode_type(NAME) (signed char)((NAME) & CFI_type_mask)\n+#define _CFI_decode_kind(NAME) (signed char)(((NAME) >> CFI_type_kind_shift) & CFI_type_mask)\n+\n+#define _CFI_encode_type(TYPE, KIND) (int16_t)\\\n+((((KIND) & CFI_type_mask) << CFI_type_kind_shift)\\\n+ | ((TYPE) & CFI_type_mask))\n+\n+#define N 11\n+#define M 7\n+\n+typedef int(*c_funptr)(int);\n+\n+bool c_vrfy_c_funptr (const CFI_cdesc_t *restrict);\n+\n+void check_fn (const CFI_cdesc_t*restrict, const CFI_type_t, const signed char, const size_t, const size_t);\n+\n+bool\n+c_vrfy_c_funptr (const CFI_cdesc_t *restrict auxp)\n+{\n+  CFI_index_t i, lb, ub, ex;\n+  size_t sz;\n+  c_funptr *ip = NULL;\n+\n+  assert (auxp);\n+  assert (auxp->base_addr);\n+  assert (auxp->elem_len>0);\n+  lb = auxp->dim[0].lower_bound;\n+  ex = auxp->dim[0].extent;\n+  assert (ex==11);\n+  sz = (size_t)auxp->elem_len / sizeof (c_funptr);\n+  assert (sz==1);\n+  ub = ex + lb - 1;\n+  ip = (c_funptr*)auxp->base_addr;\n+  for (i=0; i<ex; i++, ip+=sz)\n+    if ((**ip)((int)(i)) != 2*(int)(i))\n+      return false;\n+  for (i=lb; i<ub+1; i++)\n+    {\n+      ip = (c_funptr*)CFI_address(auxp, &i);\n+      if ((**ip)((int)(i-lb)) != 2*(int)(i-lb))\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+void\n+check_fn (const CFI_cdesc_t *restrict auxp, const CFI_type_t type, const signed char kind, const size_t elem_len, const size_t nelem)\n+{\n+  signed char ityp, iknd;\n+\n+  assert (auxp);\n+  assert (auxp->elem_len==elem_len*nelem);\n+  assert (auxp->rank==1);\n+  assert (auxp->dim[0].sm>0);\n+  assert ((size_t)auxp->dim[0].sm==elem_len*nelem);\n+  /*  */\n+  assert (auxp->type==type);\n+  ityp = _CFI_decode_type(auxp->type);\n+  assert (ityp == CFI_type_cptr);\n+  iknd = _CFI_decode_kind(auxp->type);\n+  assert (_CFI_decode_type(type)==ityp);\n+  assert (kind==iknd);\n+  assert (c_vrfy_c_funptr (auxp));\n+  return;\n+}\n+\n+// Local Variables:\n+// mode: C\n+// End:"}, {"sha": "083565e5ddf7f87aaf521e468cb968010da13249", "filename": "gcc/testsuite/gfortran.dg/PR100915.f90", "status": "added", "additions": 272, "deletions": 0, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93b6b2f614eb692d1d8126ec6cb946984a9d01d7/gcc%2Ftestsuite%2Fgfortran.dg%2FPR100915.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93b6b2f614eb692d1d8126ec6cb946984a9d01d7/gcc%2Ftestsuite%2Fgfortran.dg%2FPR100915.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FPR100915.f90?ref=93b6b2f614eb692d1d8126ec6cb946984a9d01d7", "patch": "@@ -0,0 +1,272 @@\n+! { dg-do run }\n+! { dg-additional-sources PR100915.c }\n+!\n+! Test the fix for PR100915\n+! \n+\n+module isof_m\n+\n+  use, intrinsic :: iso_c_binding, only: &\n+    c_signed_char, c_int16_t\n+  \n+  implicit none\n+\n+  private\n+  \n+  public :: &\n+    CFI_type_cptr\n+  \n+  public ::      &\n+    check_fn_as, &\n+    check_fn_ar\n+  \n+  public :: &\n+    mult2\n+  \n+  public ::          &\n+    cfi_encode_type\n+  \n+  integer, parameter :: CFI_type_t = c_int16_t\n+  \n+  integer(kind=c_int16_t), parameter :: CFI_type_mask = int(z\"FF\", kind=c_int16_t)\n+  integer(kind=c_int16_t), parameter :: CFI_type_kind_shift = 8_c_int16_t\n+\n+  ! Intrinsic types. Their kind number defines their storage size. */\n+  integer(kind=c_signed_char), parameter :: CFI_type_cptr   = 7\n+\n+  interface\n+    subroutine check_fn_as(a, t, k, e, n) &\n+      bind(c, name=\"check_fn\")\n+      use, intrinsic :: iso_c_binding, only: &\n+        c_int16_t, c_signed_char, c_size_t\n+      implicit none\n+      type(*),                       intent(in) :: a(:)\n+      integer(c_int16_t),     value, intent(in) :: t\n+      integer(c_signed_char), value, intent(in) :: k\n+      integer(c_size_t),      value, intent(in) :: e\n+      integer(c_size_t),      value, intent(in) :: n\n+    end subroutine check_fn_as\n+    subroutine check_fn_ar(a, t, k, e, n) &\n+      bind(c, name=\"check_fn\")\n+      use, intrinsic :: iso_c_binding, only: &\n+        c_int16_t, c_signed_char, c_size_t\n+      implicit none\n+      type(*),                       intent(in) :: a(..)\n+      integer(c_int16_t),     value, intent(in) :: t\n+      integer(c_signed_char), value, intent(in) :: k\n+      integer(c_size_t),      value, intent(in) :: e\n+      integer(c_size_t),      value, intent(in) :: n\n+    end subroutine check_fn_ar\n+  end interface\n+\n+contains\n+\n+  function mult2(a) result(b) bind(c)\n+    use, intrinsic :: iso_c_binding, only: &\n+      c_int\n+  \n+    integer(kind=c_int), value, intent(in) :: a\n+\n+    integer(kind=c_int) :: b\n+\n+    b = 2_c_int * a\n+    return\n+  end function mult2\n+  \n+  elemental function cfi_encode_type(type, kind) result(itype)\n+    integer(kind=c_signed_char), intent(in) :: type\n+    integer(kind=c_signed_char), intent(in) :: kind\n+\n+    integer(kind=c_int16_t) :: itype, ikind\n+\n+    itype = int(type, kind=c_int16_t)\n+    itype = iand(itype, CFI_type_mask)\n+    ikind = int(kind, kind=c_int16_t)\n+    ikind = iand(ikind, CFI_type_mask)\n+    ikind = shiftl(ikind, CFI_type_kind_shift)\n+    itype = ior(ikind, itype)\n+    return\n+  end function cfi_encode_type\n+  \n+end module isof_m\n+\n+module iso_check_m\n+\n+  use, intrinsic :: iso_c_binding, only: &\n+    c_signed_char, c_int16_t, c_size_t\n+\n+  use, intrinsic :: iso_c_binding, only: &\n+    c_funptr, c_funloc, c_associated\n+\n+  use :: isof_m, only:  &\n+    CFI_type_cptr\n+  \n+  use :: isof_m, only: &\n+    check_fn_as,       &\n+    check_fn_ar\n+  \n+  use :: isof_m, only: &\n+    mult2\n+  \n+  use :: isof_m, only: &\n+    cfi_encode_type\n+  \n+  implicit none\n+\n+  integer                           :: i\n+  integer(kind=c_size_t), parameter :: b = 8\n+  integer,                parameter :: n = 11\n+  \n+contains\n+\n+  subroutine check_c_funptr()\n+    type(c_funptr) :: p(n)\n+    integer :: i\n+    !\n+    p = [(c_funloc(mult2), i=1,n)]\n+    call f_check_c_funptr_as(p)\n+    do i = 1, n\n+      if(.not.c_associated(p(i), c_funloc(mult2))) stop 1\n+    end do\n+    p = [(c_funloc(mult2), i=1,n)]\n+    call c_check_c_funptr_as(p)\n+    do i = 1, n\n+      if(.not.c_associated(p(i), c_funloc(mult2))) stop 2\n+    end do\n+    p = [(c_funloc(mult2), i=1,n)]\n+    call f_check_c_funptr_ar(p)\n+    do i = 1, n\n+      if(.not.c_associated(p(i), c_funloc(mult2))) stop 3\n+    end do\n+    p = [(c_funloc(mult2), i=1,n)]\n+    call c_check_c_funptr_ar(p)\n+    do i = 1, n\n+      if(.not.c_associated(p(i), c_funloc(mult2))) stop 4\n+    end do\n+    return\n+  end subroutine check_c_funptr\n+\n+  subroutine f_check_c_funptr_as(a)\n+    type(c_funptr), intent(in) :: a(:)\n+    !\n+    integer(kind=c_int16_t)     :: t\n+    integer(kind=c_signed_char) :: k\n+    integer(kind=c_size_t)      :: e\n+    !\n+    k = 0\n+    e = storage_size(a)/b\n+    t = cfi_encode_type(CFI_type_cptr, k)\n+    ! Assumes 64-bit target.\n+    ! if(e/=8) stop 5\n+    do i = 1, n\n+      if(.not.c_associated(a(i), c_funloc(mult2))) stop 6\n+    end do\n+    call check_fn_as(a, t, k, e, 1_c_size_t)\n+    do i = 1, n\n+      if(.not.c_associated(a(i), c_funloc(mult2))) stop 7\n+    end do\n+    return\n+  end subroutine f_check_c_funptr_as\n+\n+  subroutine c_check_c_funptr_as(a) bind(c)\n+    type(c_funptr), intent(in) :: a(:)\n+    integer(kind=c_int16_t)     :: t\n+    integer(kind=c_signed_char) :: k\n+    integer(kind=c_size_t)      :: e\n+    !\n+    k = 0\n+    e = storage_size(a)/b\n+    t = cfi_encode_type(CFI_type_cptr, k)\n+    ! Assumes 64-bit target.\n+    ! if(e/=8) stop 8\n+    do i = 1, n\n+      if(.not.c_associated(a(i), c_funloc(mult2))) stop 9\n+    end do\n+    call check_fn_as(a, t, k, e, 1_c_size_t)\n+    do i = 1, n\n+      if(.not.c_associated(a(i), c_funloc(mult2))) stop 10\n+    end do\n+    return\n+  end subroutine c_check_c_funptr_as\n+\n+  subroutine f_check_c_funptr_ar(a)\n+    type(c_funptr), intent(in) :: a(..)\n+    !\n+    integer(kind=c_int16_t)     :: t\n+    integer(kind=c_signed_char) :: k\n+    integer(kind=c_size_t)      :: e\n+    !\n+    k = 0\n+    e = storage_size(a)/b\n+    t = cfi_encode_type(CFI_type_cptr, k)\n+    ! Assumes 64-bit target.\n+    ! if(e/=8) stop 11\n+    select rank(a)\n+    rank(1)\n+      do i = 1, n\n+        if(.not.c_associated(a(i), c_funloc(mult2))) stop 12\n+      end do\n+    rank default\n+      stop 13\n+    end select\n+    call check_fn_ar(a, t, k, e, 1_c_size_t)\n+    select rank(a)\n+    rank(1)\n+      do i = 1, n\n+        if(.not.c_associated(a(i), c_funloc(mult2))) stop 14\n+      end do\n+    rank default\n+      stop 15\n+    end select\n+    return\n+  end subroutine f_check_c_funptr_ar\n+\n+  subroutine c_check_c_funptr_ar(a) bind(c)\n+    type(c_funptr), intent(in) :: a(..)\n+    integer(kind=c_int16_t)     :: t\n+    integer(kind=c_signed_char) :: k\n+    integer(kind=c_size_t)      :: e\n+    !\n+    k = 0\n+    e = storage_size(a)/b\n+    t = cfi_encode_type(CFI_type_cptr, k)\n+    ! Assumes 64-bit target.\n+    ! if(e/=8) stop 16\n+    select rank(a)\n+    rank(1)\n+      do i = 1, n\n+        if(.not.c_associated(a(i), c_funloc(mult2))) stop 17\n+      end do\n+    rank default\n+      stop 18\n+    end select\n+    call check_fn_ar(a, t, k, e, 1_c_size_t)\n+    select rank(a)\n+    rank(1)\n+      do i = 1, n\n+        if(.not.c_associated(a(i), c_funloc(mult2))) stop 19\n+      end do\n+    rank default\n+      stop 20\n+    end select\n+    return\n+  end subroutine c_check_c_funptr_ar\n+\n+end module iso_check_m\n+\n+program main_p\n+  \n+  use :: iso_check_m, only: &\n+    check_c_funptr\n+\n+  implicit none\n+\n+  call check_c_funptr()\n+  stop\n+\n+end program main_p\n+\n+!! Local Variables:\n+!! mode: f90\n+!! End:\n+"}, {"sha": "b998d6ca8ee35c6346ea15a639b2b1e8480dfb75", "filename": "libgfortran/ISO_Fortran_binding-1-tmpl.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93b6b2f614eb692d1d8126ec6cb946984a9d01d7/libgfortran%2FISO_Fortran_binding-1-tmpl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93b6b2f614eb692d1d8126ec6cb946984a9d01d7/libgfortran%2FISO_Fortran_binding-1-tmpl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FISO_Fortran_binding-1-tmpl.h?ref=93b6b2f614eb692d1d8126ec6cb946984a9d01d7", "patch": "@@ -152,10 +152,14 @@ extern int CFI_setpointer (CFI_cdesc_t *, CFI_cdesc_t *, const CFI_index_t []);\n #define CFI_type_Complex 4\n #define CFI_type_Character 5\n \n-/* Types with no kind. */\n+/* Types with no kind.  FIXME: GFC descriptors currently use BT_VOID for\n+   both C_PTR and C_FUNPTR, so we have no choice but to make them\n+   identical here too.  That can potentially break on targets where\n+   function and data pointers have different sizes/representations.\n+   See PR 100915.  */\n #define CFI_type_struct 6\n #define CFI_type_cptr 7\n-#define CFI_type_cfunptr 8\n+#define CFI_type_cfunptr CFI_type_cptr\n #define CFI_type_other -1\n \n /* Types with kind parameter."}, {"sha": "0e1a419460a962abf2d99e2cf0f26cfaf87ba46b", "filename": "libgfortran/runtime/ISO_Fortran_binding.c", "status": "modified", "additions": 97, "deletions": 25, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93b6b2f614eb692d1d8126ec6cb946984a9d01d7/libgfortran%2Fruntime%2FISO_Fortran_binding.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93b6b2f614eb692d1d8126ec6cb946984a9d01d7/libgfortran%2Fruntime%2FISO_Fortran_binding.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2FISO_Fortran_binding.c?ref=93b6b2f614eb692d1d8126ec6cb946984a9d01d7", "patch": "@@ -37,15 +37,16 @@ export_proto(cfi_desc_to_gfc_desc);\n void\n cfi_desc_to_gfc_desc (gfc_array_void *d, CFI_cdesc_t **s_ptr)\n {\n+  signed char type;\n+  size_t size;\n   int n;\n-  index_type kind;\n   CFI_cdesc_t *s = *s_ptr;\n \n   if (!s)\n     return;\n \n   /* Verify descriptor.  */\n-  switch(s->attribute)\n+  switch (s->attribute)\n     {\n     case CFI_attribute_pointer:\n     case CFI_attribute_allocatable:\n@@ -63,23 +64,33 @@ cfi_desc_to_gfc_desc (gfc_array_void *d, CFI_cdesc_t **s_ptr)\n       break;\n     }\n   GFC_DESCRIPTOR_DATA (d) = s->base_addr;\n-  GFC_DESCRIPTOR_TYPE (d) = (signed char)(s->type & CFI_type_mask);\n-  kind = (index_type)((s->type - (s->type & CFI_type_mask)) >> CFI_type_kind_shift);\n \n   /* Correct the unfortunate difference in order with types.  */\n-  if (GFC_DESCRIPTOR_TYPE (d) == BT_CHARACTER)\n-    GFC_DESCRIPTOR_TYPE (d) = BT_DERIVED;\n-  else if (GFC_DESCRIPTOR_TYPE (d) == BT_DERIVED)\n-    GFC_DESCRIPTOR_TYPE (d) = BT_CHARACTER;\n-\n-  if (!s->rank || s->dim[0].sm == (CFI_index_t)s->elem_len)\n-    GFC_DESCRIPTOR_SIZE (d) = s->elem_len;\n-  else if (GFC_DESCRIPTOR_TYPE (d) != BT_DERIVED)\n-    GFC_DESCRIPTOR_SIZE (d) = kind;\n-  else\n-    GFC_DESCRIPTOR_SIZE (d) = s->elem_len;\n+  type = (signed char)(s->type & CFI_type_mask);\n+  switch (type)\n+    {\n+    case CFI_type_Character:\n+      type = BT_CHARACTER;\n+      break;\n+    case CFI_type_struct:\n+      type = BT_DERIVED;\n+      break;\n+    case CFI_type_cptr:\n+      /* FIXME: PR 100915.  GFC descriptors do not distinguish between\n+\t CFI_type_cptr and CFI_type_cfunptr.  */\n+      type = BT_VOID;\n+      break;\n+    default:\n+      break;\n+    }\n+\n+  GFC_DESCRIPTOR_TYPE (d) = type;\n+  GFC_DESCRIPTOR_SIZE (d) = s->elem_len;\n \n   d->dtype.version = 0;\n+\n+  if (s->rank < 0 || s->rank > CFI_MAX_RANK)\n+    internal_error (NULL, \"Invalid rank in descriptor\");\n   GFC_DESCRIPTOR_RANK (d) = (signed char)s->rank;\n \n   d->dtype.attribute = (signed short)s->attribute;\n@@ -116,13 +127,14 @@ gfc_desc_to_cfi_desc (CFI_cdesc_t **d_ptr, const gfc_array_void *s)\n {\n   int n;\n   CFI_cdesc_t *d;\n+  signed char type, kind;\n \n   /* Play it safe with allocation of the flexible array member 'dim'\n      by setting the length to CFI_MAX_RANK. This should not be necessary\n      but valgrind complains accesses after the allocated block.  */\n   if (*d_ptr == NULL)\n-    d = malloc (sizeof (CFI_cdesc_t)\n-\t\t+ (CFI_type_t)(CFI_MAX_RANK * sizeof (CFI_dim_t)));\n+    d = calloc (1, (sizeof (CFI_cdesc_t)\n+\t\t    + (CFI_type_t)(CFI_MAX_RANK * sizeof (CFI_dim_t))));\n   else\n     d = *d_ptr;\n \n@@ -145,20 +157,80 @@ gfc_desc_to_cfi_desc (CFI_cdesc_t **d_ptr, const gfc_array_void *s)\n     }\n   d->base_addr = GFC_DESCRIPTOR_DATA (s);\n   d->elem_len = GFC_DESCRIPTOR_SIZE (s);\n+  if (d->elem_len <= 0)\n+    internal_error (NULL, \"Invalid size in descriptor\");\n+\n   d->version = CFI_VERSION;\n+\n   d->rank = (CFI_rank_t)GFC_DESCRIPTOR_RANK (s);\n+  if (d->rank < 0 || d->rank > CFI_MAX_RANK)\n+    internal_error (NULL, \"Invalid rank in descriptor\");\n+\n   d->attribute = (CFI_attribute_t)s->dtype.attribute;\n \n-  if (GFC_DESCRIPTOR_TYPE (s) == BT_CHARACTER)\n-    d->type = CFI_type_Character;\n-  else if (GFC_DESCRIPTOR_TYPE (s) == BT_DERIVED)\n-    d->type = CFI_type_struct;\n-  else\n-    d->type = (CFI_type_t)GFC_DESCRIPTOR_TYPE (s);\n+  type = GFC_DESCRIPTOR_TYPE (s);\n+  switch (type)\n+    {\n+    case BT_CHARACTER:\n+      d->type = CFI_type_Character;\n+      break;\n+    case BT_DERIVED:\n+      d->type = CFI_type_struct;\n+      break;\n+    case BT_VOID:\n+      /* FIXME: PR 100915.  GFC descriptors do not distinguish between\n+\t CFI_type_cptr and CFI_type_cfunptr.  */\n+      d->type = CFI_type_cptr;\n+      break;\n+    default:\n+      d->type = (CFI_type_t)type;\n+      break;\n+    }\n \n-  if (GFC_DESCRIPTOR_TYPE (s) != BT_DERIVED)\n+  switch (d->type)\n+    {\n+    case CFI_type_Integer:\n+    case CFI_type_Logical:\n+    case CFI_type_Real:\n+      kind = (signed char)d->elem_len;\n+      break;\n+    case CFI_type_Complex:\n+      kind = (signed char)(d->elem_len >> 1);\n+      break;\n+    case CFI_type_Character:\n+      /* FIXME: we can't distinguish between kind/len because\n+\t the GFC descriptor only encodes the elem_len..\n+\t Until PR92482 is fixed, assume elem_len refers to the\n+\t character size and not the string length.  */\n+      kind = (signed char)d->elem_len;\n+      break;\n+    case CFI_type_struct:\n+    case CFI_type_cptr:\n+    case CFI_type_other:\n+      /* FIXME: PR 100915.  GFC descriptors do not distinguish between\n+\t CFI_type_cptr and CFI_type_cfunptr.  */\n+      kind = 0;\n+      break;\n+    default:\n+      internal_error (NULL, \"Invalid type in descriptor\");\n+    }\n+\n+  if (kind < 0)\n+    internal_error (NULL, \"Invalid kind in descriptor\");\n+\n+  /* FIXME: This is PR100917.  Because the GFC descriptor encodes only the\n+     elem_len and not the kind, we get into trouble with long double kinds\n+     that do not correspond directly to the elem_len, specifically the\n+     kind 10 80-bit long double on x86 targets.  On x86_64, this has size\n+     16 and cannot be differentiated from true __float128.  Prefer the\n+     standard long double type over the GNU extension in that case.  */\n+  if (d->type == CFI_type_Real && kind == sizeof (long double))\n+    d->type = CFI_type_long_double;\n+  else if (d->type == CFI_type_Complex && kind == sizeof (long double))\n+    d->type = CFI_type_long_double_Complex;\n+  else\n     d->type = (CFI_type_t)(d->type\n-\t\t+ ((CFI_type_t)d->elem_len << CFI_type_kind_shift));\n+\t\t\t   + ((CFI_type_t)kind << CFI_type_kind_shift));\n \n   if (d->base_addr)\n     /* Full pointer or allocatable arrays retain their lower_bounds.  */"}]}