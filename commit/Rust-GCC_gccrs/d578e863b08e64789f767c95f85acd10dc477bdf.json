{"sha": "d578e863b08e64789f767c95f85acd10dc477bdf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDU3OGU4NjNiMDhlNjQ3ODlmNzY3Yzk1Zjg1YWNkMTBkYzQ3N2JkZg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2012-10-31T08:45:27Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2012-10-31T08:45:27Z"}, "message": "re PR tree-optimization/19105 (fold does not spot anti-range test)\n\n\tPR tree-optimization/19105\n\tPR tree-optimization/21643\n\tPR tree-optimization/46309\n\t* tree-ssa-reassoc.c (init_range_entry): Add STMT argument\n\tand use it if EXP is NULL.\n\t(update_range_test): Handle OPCODE equal to ERROR_MARK\n\tand oe->op NULL.\n\t(optimize_range_tests): Likewise.\n\t(final_range_test_p, suitable_cond_bb, no_side_effect_bb, get_ops,\n\tmaybe_optimize_range_tests): New functions.\n\t(reassociate_bb): Call maybe_optimize_range_tests if last\n\tstmt of bb is GIMPLE_COND that hasn't been visited yet.\n\n\t* gcc.dg/pr19105.c: New test.\n\t* gcc.dg/pr21643.c: New test.\n\t* gcc.dg/pr46309-2.c: New test.\n\t* gcc.c-torture/execute/pr46309.c: New test.\n\nFrom-SVN: r193028", "tree": {"sha": "260b507c59290539996f49c796ce84539ec8f3cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/260b507c59290539996f49c796ce84539ec8f3cc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d578e863b08e64789f767c95f85acd10dc477bdf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d578e863b08e64789f767c95f85acd10dc477bdf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d578e863b08e64789f767c95f85acd10dc477bdf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d578e863b08e64789f767c95f85acd10dc477bdf/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c727fb67fb48a1f45675a2584b7fe41c4745a929", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c727fb67fb48a1f45675a2584b7fe41c4745a929", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c727fb67fb48a1f45675a2584b7fe41c4745a929"}], "stats": {"total": 972, "additions": 942, "deletions": 30}, "files": [{"sha": "462fe341523575da7da8980ca49a8a75fc9cd4f9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d578e863b08e64789f767c95f85acd10dc477bdf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d578e863b08e64789f767c95f85acd10dc477bdf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d578e863b08e64789f767c95f85acd10dc477bdf", "patch": "@@ -1,3 +1,18 @@\n+2012-10-31  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/19105\n+\tPR tree-optimization/21643\n+\tPR tree-optimization/46309\n+\t* tree-ssa-reassoc.c (init_range_entry): Add STMT argument\n+\tand use it if EXP is NULL.\n+\t(update_range_test): Handle OPCODE equal to ERROR_MARK\n+\tand oe->op NULL.\n+\t(optimize_range_tests): Likewise.\n+\t(final_range_test_p, suitable_cond_bb, no_side_effect_bb, get_ops,\n+\tmaybe_optimize_range_tests): New functions.\n+\t(reassociate_bb): Call maybe_optimize_range_tests if last\n+\tstmt of bb is GIMPLE_COND that hasn't been visited yet.\n+\n 2012-10-31  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* config/rs6000/rs6000.md (insvsi, insvdi, extvsi, extvdi): Rename to..."}, {"sha": "ac09b8ada55bfffc8d024145da262d313edcaee4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d578e863b08e64789f767c95f85acd10dc477bdf/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d578e863b08e64789f767c95f85acd10dc477bdf/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d578e863b08e64789f767c95f85acd10dc477bdf", "patch": "@@ -1,3 +1,13 @@\n+2012-10-31  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/19105\n+\tPR tree-optimization/21643\n+\tPR tree-optimization/46309\n+\t* gcc.dg/pr19105.c: New test.\n+\t* gcc.dg/pr21643.c: New test.\n+\t* gcc.dg/pr46309-2.c: New test.\n+\t* gcc.c-torture/execute/pr46309.c: New test.\n+\n 2012-10-31  Alan Modra  <amodra@gmail.com>\n \n \t* gcc.target/powerpc/dimode_off.c: New."}, {"sha": "46e10ab4bf43a0e090c268c7585b4dbefa0897b6", "filename": "gcc/testsuite/gcc.c-torture/execute/pr46309.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d578e863b08e64789f767c95f85acd10dc477bdf/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr46309.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d578e863b08e64789f767c95f85acd10dc477bdf/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr46309.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr46309.c?ref=d578e863b08e64789f767c95f85acd10dc477bdf", "patch": "@@ -0,0 +1,31 @@\n+/* PR tree-optimization/46309 */\n+\n+extern void abort (void);\n+\n+unsigned int *q;\n+\n+__attribute__((noinline, noclone)) void\n+bar (unsigned int *p)\n+{\n+  if (*p != 2 && *p != 3)\n+    (!(!(*q & 263) || *p != 1)) ? abort () : 0;\n+}\n+\n+int\n+main ()\n+{\n+  unsigned int x, y;\n+  asm volatile (\"\" : : : \"memory\");\n+  x = 2;\n+  bar (&x);\n+  x = 3;\n+  bar (&x);\n+  y = 1;\n+  x = 0;\n+  q = &y;\n+  bar (&x);\n+  y = 0;\n+  x = 1;\n+  bar (&x);\n+  return 0;\n+}"}, {"sha": "1267bbf17a79a73da06a427d2b9d767d3232cce0", "filename": "gcc/testsuite/gcc.dg/pr19105.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d578e863b08e64789f767c95f85acd10dc477bdf/gcc%2Ftestsuite%2Fgcc.dg%2Fpr19105.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d578e863b08e64789f767c95f85acd10dc477bdf/gcc%2Ftestsuite%2Fgcc.dg%2Fpr19105.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr19105.c?ref=d578e863b08e64789f767c95f85acd10dc477bdf", "patch": "@@ -0,0 +1,22 @@\n+/* PR tree-optimization/19105 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-reassoc1-details\" } */\n+\n+enum e\n+{\n+  a, b, c, d, e, f, g, h\n+};\n+\n+int range1 (enum e v, int x)\n+{\n+  return x && v != c && v != d && v != e;\n+}\n+\n+int range2 (enum e v, int x)\n+{\n+  return x && (v != c && v != d && v != e);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Optimizing range tests v_\\[0-9\\]*.D. -.2, 2. and -.3, 4.\\[\\n\\r\\]* into\" 1 \"reassoc1\" } } */\n+/* { dg-final { cleanup-tree-dump \"reassoc1\" } } */\n+"}, {"sha": "be5a15e98d2f848431bd7725dd97e75ba6930f04", "filename": "gcc/testsuite/gcc.dg/pr21643.c", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d578e863b08e64789f767c95f85acd10dc477bdf/gcc%2Ftestsuite%2Fgcc.dg%2Fpr21643.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d578e863b08e64789f767c95f85acd10dc477bdf/gcc%2Ftestsuite%2Fgcc.dg%2Fpr21643.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr21643.c?ref=d578e863b08e64789f767c95f85acd10dc477bdf", "patch": "@@ -0,0 +1,90 @@\n+/* PR tree-optimization/21643 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-reassoc1-details\" } */\n+\n+int\n+f1 (unsigned char c)\n+{\n+  if (c == 0x22 || c == 0x20 || c < 0x20)\n+    return 1;\n+  return 0;\n+}\n+\n+int\n+f2 (unsigned char c)\n+{\n+  if (c == 0x22 || c <= 0x20)\n+    return 1;\n+  return 0;\n+}\n+\n+int\n+f3 (unsigned char c)\n+{\n+  if (c == 0x22)\n+    return 1;\n+  if (c == 0x20)\n+    return 1;\n+  if (c < 0x20)\n+    return 1;\n+  return 0;\n+}\n+\n+int\n+f4 (unsigned char c)\n+{\n+  if (c == 0x22 || c == 0x20 || c < 0x20)\n+    return 2;\n+  return 0;\n+}\n+\n+int\n+f5 (unsigned char c)\n+{\n+  if (c == 0x22 || c <= 0x20)\n+    return 2;\n+  return 0;\n+}\n+\n+int\n+f6 (unsigned char c)\n+{\n+  if (c == 0x22)\n+    return 2;\n+  if (c == 0x20)\n+    return 2;\n+  if (c < 0x20)\n+    return 2;\n+  return 0;\n+}\n+\n+int\n+f7 (unsigned char c)\n+{\n+  if (c != 0x22 && c != 0x20 && c >= 0x20)\n+    return 0;\n+  return 1;\n+}\n+\n+int\n+f8 (unsigned char c)\n+{\n+  if (c == 0x22 && c <= 0x20)\n+    return 0;\n+  return 1;\n+}\n+\n+int\n+f9 (unsigned char c)\n+{\n+  if (c == 0x22)\n+    return 0;\n+  if (c == 0x20)\n+    return 0;\n+  if (c < 0x20)\n+    return 0;\n+  return 1;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Optimizing range tests c_\\[0-9\\]*.D. -.0, 31. and -.32, 32.\\[\\n\\r\\]* into\" 6 \"reassoc1\" } } */\n+/* { dg-final { cleanup-tree-dump \"reassoc1\" } } */"}, {"sha": "f407e6607054ab9a160fc097a0b7078fdc37ba99", "filename": "gcc/testsuite/gcc.dg/pr46309-2.c", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d578e863b08e64789f767c95f85acd10dc477bdf/gcc%2Ftestsuite%2Fgcc.dg%2Fpr46309-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d578e863b08e64789f767c95f85acd10dc477bdf/gcc%2Ftestsuite%2Fgcc.dg%2Fpr46309-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr46309-2.c?ref=d578e863b08e64789f767c95f85acd10dc477bdf", "patch": "@@ -0,0 +1,147 @@\n+/* PR tree-optimization/46309 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-reassoc-details\" } */\n+\n+int foo (void);\n+\n+void\n+f1 (int a)\n+{\n+  _Bool v1 = (a == 3);\n+  _Bool v2 = (a == 1);\n+  _Bool v3 = (a == 4);\n+  _Bool v4 = (a == 2);\n+  if (v1 || v2 || v3 || v4)\n+    foo ();\n+}\n+\n+void\n+f2 (int a)\n+{\n+  _Bool v1 = (a == 1);\n+  _Bool v2 = (a == 2);\n+  _Bool v3 = (a == 3);\n+  _Bool v4 = (a == 4);\n+  if (v1 || v2 || v3 || v4)\n+    foo ();\n+}\n+\n+void\n+f3 (unsigned int a)\n+{\n+  _Bool v1 = (a <= 31);\n+  _Bool v2 = (a >= 64 && a <= 95);\n+  _Bool v3 = (a >= 128 && a <= 159);\n+  _Bool v4 = (a >= 192 && a <= 223);\n+  if (v1 || v2 || v3 || v4)\n+    foo ();\n+}\n+\n+void\n+f4 (int a)\n+{\n+  _Bool v1 = (a == 3);\n+  _Bool v2 = (a == 1);\n+  _Bool v3 = (a == 4);\n+  _Bool v4 = (a == 2);\n+  _Bool v5 = (a == 7);\n+  _Bool v6 = (a == 5);\n+  _Bool v7 = (a == 8);\n+  _Bool v8 = (a == 6);\n+  if (v1 || v2 || v3 || v4 || v5 || v6 || v7 || v8)\n+    foo ();\n+}\n+\n+void\n+f5 (int a)\n+{\n+  _Bool v1 = (a != 3);\n+  _Bool v2 = (a != 1);\n+  _Bool v3 = (a != 4);\n+  _Bool v4 = (a != 2);\n+  _Bool v5 = (a != 7);\n+  _Bool v6 = (a != 5);\n+  _Bool v7 = (a != 8);\n+  _Bool v8 = (a != 6);\n+  if (v1 && v2 && v3 && v4 && v5 && v6 && v7 && v8)\n+    foo ();\n+}\n+\n+void\n+f6 (int a)\n+{\n+  _Bool v1 = (a != 3);\n+  _Bool v2 = (a != 1);\n+  _Bool v3 = (a != 4);\n+  _Bool v4 = (a != 2);\n+  _Bool v5 = (a != 7);\n+  _Bool v6 = (a != 5);\n+  _Bool v7 = (a != 8);\n+  _Bool v8 = (a != 6);\n+  if ((v1 && v2 && v3 && v4) && (v5 && v6 && v7 && v8))\n+    foo ();\n+}\n+\n+int\n+f7 (int a)\n+{\n+  _Bool v1 = (a == 3);\n+  _Bool v2 = (a == 1);\n+  _Bool v3 = (a == 4);\n+  _Bool v4 = (a == 2);\n+  _Bool v5 = (a == 7);\n+  _Bool v6 = (a == 5);\n+  _Bool v7 = (a == 8);\n+  _Bool v8 = (a == 6);\n+  return v1 || v2 || v3 || v4 || v5 || v6 || v7 || v8;\n+}\n+\n+_Bool\n+f8 (int a)\n+{\n+  _Bool v1 = (a == 3);\n+  _Bool v2 = (a == 1);\n+  _Bool v3 = (a == 4);\n+  _Bool v4 = (a == 2);\n+  _Bool v5 = (a == 7);\n+  _Bool v6 = (a == 5);\n+  _Bool v7 = (a == 8);\n+  _Bool v8 = (a == 6);\n+  return v1 || v2 || v3 || v4 || v5 || v6 || v7 || v8;\n+}\n+\n+int\n+f9 (int a)\n+{\n+  _Bool v1 = (a != 3);\n+  _Bool v2 = (a != 1);\n+  _Bool v3 = (a != 4);\n+  _Bool v4 = (a != 2);\n+  _Bool v5 = (a != 7);\n+  _Bool v6 = (a != 5);\n+  _Bool v7 = (a != 8);\n+  _Bool v8 = (a != 6);\n+  return v1 && v2 && v3 && v4 && v5 && v6 && v7 && v8;\n+}\n+\n+_Bool\n+f10 (int a)\n+{\n+  _Bool v1 = (a != 3);\n+  _Bool v2 = (a != 1);\n+  _Bool v3 = (a != 4);\n+  _Bool v4 = (a != 2);\n+  _Bool v5 = (a != 7);\n+  _Bool v6 = (a != 5);\n+  _Bool v7 = (a != 8);\n+  _Bool v8 = (a != 6);\n+  return v1 && v2 && v3 && v4 && v5 && v6 && v7 && v8;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Optimizing range tests a_\\[0-9\\]*.D. -.1, 1. and -.2, 2. and -.3, 3. and -.4, 4.\\[\\n\\r\\]* into\" 2 \"reassoc1\" } } */\n+/* { dg-final { scan-tree-dump-times \"Optimizing range tests a_\\[0-9\\]*.D. -.0, 31. and -.64, 95.\\[\\n\\r\\]* into\" 1 \"reassoc1\" } } */\n+/* { dg-final { scan-tree-dump-times \"Optimizing range tests a_\\[0-9\\]*.D. -.128, 159. and -.192, 223.\\[\\n\\r\\]* into\" 1 \"reassoc1\" } } */\n+/* { dg-final { scan-tree-dump-times \"Optimizing range tests a_\\[0-9\\]*.D. -.1, 1. and -.2, 2. and -.3, 3. and -.4, 4. and -.5, 5. and -.6, 6. and -.7, 7. and -.8, 8.\\[\\n\\r\\]* into\" 7 \"reassoc1\" } } */\n+/* { dg-final { scan-tree-dump-times \"Optimizing range tests \\[^\\r\\n\\]*_\\[0-9\\]* -.0, 31. and -.128, 159.\\[\\n\\r\\]* into\" 1 \"reassoc2\" } } */\n+/* { dg-final { cleanup-tree-dump \"reassoc1\" } } */\n+/* { dg-final { cleanup-tree-dump \"reassoc2\" } } */"}, {"sha": "67c5c12e13cdef83cda182acec9d25db9e018305", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 627, "deletions": 30, "changes": 657, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d578e863b08e64789f767c95f85acd10dc477bdf/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d578e863b08e64789f767c95f85acd10dc477bdf/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=d578e863b08e64789f767c95f85acd10dc477bdf", "patch": "@@ -1,5 +1,5 @@\n /* Reassociation for trees.\n-   Copyright (C) 2005, 2007, 2008, 2009, 2010, 2011\n+   Copyright (C) 2005, 2007, 2008, 2009, 2010, 2011, 2012\n    Free Software Foundation, Inc.\n    Contributed by Daniel Berlin <dan@dberlin.org>\n \n@@ -1713,10 +1713,12 @@ struct range_entry\n };\n \n /* This is similar to make_range in fold-const.c, but on top of\n-   GIMPLE instead of trees.  */\n+   GIMPLE instead of trees.  If EXP is non-NULL, it should be\n+   an SSA_NAME and STMT argument is ignored, otherwise STMT\n+   argument should be a GIMPLE_COND.  */\n \n static void\n-init_range_entry (struct range_entry *r, tree exp)\n+init_range_entry (struct range_entry *r, tree exp, gimple stmt)\n {\n   int in_p;\n   tree low, high;\n@@ -1727,20 +1729,23 @@ init_range_entry (struct range_entry *r, tree exp)\n   r->strict_overflow_p = false;\n   r->low = NULL_TREE;\n   r->high = NULL_TREE;\n-  if (TREE_CODE (exp) != SSA_NAME || !INTEGRAL_TYPE_P (TREE_TYPE (exp)))\n+  if (exp != NULL_TREE\n+      && (TREE_CODE (exp) != SSA_NAME || !INTEGRAL_TYPE_P (TREE_TYPE (exp))))\n     return;\n \n   /* Start with simply saying \"EXP != 0\" and then look at the code of EXP\n      and see if we can refine the range.  Some of the cases below may not\n      happen, but it doesn't seem worth worrying about this.  We \"continue\"\n      the outer loop when we've changed something; otherwise we \"break\"\n      the switch, which will \"break\" the while.  */\n-  low = build_int_cst (TREE_TYPE (exp), 0);\n+  low = exp ? build_int_cst (TREE_TYPE (exp), 0) : boolean_false_node;\n   high = low;\n   in_p = 0;\n   strict_overflow_p = false;\n   is_bool = false;\n-  if (TYPE_PRECISION (TREE_TYPE (exp)) == 1)\n+  if (exp == NULL_TREE)\n+    is_bool = true;\n+  else if (TYPE_PRECISION (TREE_TYPE (exp)) == 1)\n     {\n       if (TYPE_UNSIGNED (TREE_TYPE (exp)))\n \tis_bool = true;\n@@ -1752,25 +1757,35 @@ init_range_entry (struct range_entry *r, tree exp)\n \n   while (1)\n     {\n-      gimple stmt;\n       enum tree_code code;\n       tree arg0, arg1, exp_type;\n       tree nexp;\n       location_t loc;\n \n-      if (TREE_CODE (exp) != SSA_NAME)\n-\tbreak;\n+      if (exp != NULL_TREE)\n+\t{\n+\t  if (TREE_CODE (exp) != SSA_NAME)\n+\t    break;\n \n-      stmt = SSA_NAME_DEF_STMT (exp);\n-      if (!is_gimple_assign (stmt))\n-\tbreak;\n+\t  stmt = SSA_NAME_DEF_STMT (exp);\n+\t  if (!is_gimple_assign (stmt))\n+\t    break;\n+\n+\t  code = gimple_assign_rhs_code (stmt);\n+\t  arg0 = gimple_assign_rhs1 (stmt);\n+\t  arg1 = gimple_assign_rhs2 (stmt);\n+\t  exp_type = TREE_TYPE (exp);\n+\t}\n+      else\n+\t{\n+\t  code = gimple_cond_code (stmt);\n+\t  arg0 = gimple_cond_lhs (stmt);\n+\t  arg1 = gimple_cond_rhs (stmt);\n+\t  exp_type = boolean_type_node;\n+\t}\n \n-      code = gimple_assign_rhs_code (stmt);\n-      arg0 = gimple_assign_rhs1 (stmt);\n       if (TREE_CODE (arg0) != SSA_NAME)\n \tbreak;\n-      arg1 = gimple_assign_rhs2 (stmt);\n-      exp_type = TREE_TYPE (exp);\n       loc = gimple_location (stmt);\n       switch (code)\n \t{\n@@ -1916,17 +1931,24 @@ range_entry_cmp (const void *a, const void *b)\n    [EXP, IN_P, LOW, HIGH, STRICT_OVERFLOW_P] is a merged range for\n    RANGE and OTHERRANGE through OTHERRANGE + COUNT - 1 ranges,\n    OPCODE and OPS are arguments of optimize_range_tests.  Return\n-   true if the range merge has been successful.  */\n+   true if the range merge has been successful.\n+   If OPCODE is ERROR_MARK, this is called from within\n+   maybe_optimize_range_tests and is performing inter-bb range optimization.\n+   Changes should be then performed right away, and whether an op is\n+   BIT_AND_EXPR or BIT_IOR_EXPR is found in oe->rank.  */\n \n static bool\n update_range_test (struct range_entry *range, struct range_entry *otherrange,\n \t\t   unsigned int count, enum tree_code opcode,\n \t\t   VEC (operand_entry_t, heap) **ops, tree exp, bool in_p,\n \t\t   tree low, tree high, bool strict_overflow_p)\n {\n-  tree op = VEC_index (operand_entry_t, *ops, range->idx)->op;\n-  location_t loc = gimple_location (SSA_NAME_DEF_STMT (op));\n-  tree tem = build_range_check (loc, TREE_TYPE (op), exp, in_p, low, high);\n+  operand_entry_t oe = VEC_index (oeprand_entry_t, *ops, range->idx);\n+  tree op = oe->op;\n+  gimple stmt = op ? SSA_NAME_DEF_STMT (op) : last_stmt (BASIC_BLOCK (oe->id));\n+  location_t loc = gimple_location (stmt);\n+  tree optype = op ? TREE_TYPE (op) : boolean_type_node;\n+  tree tem = build_range_check (loc, optype, exp, in_p, low, high);\n   enum warn_strict_overflow_code wc = WARN_STRICT_OVERFLOW_COMPARISON;\n   gimple_stmt_iterator gsi;\n \n@@ -1961,15 +1983,45 @@ update_range_test (struct range_entry *range, struct range_entry *otherrange,\n       fprintf (dump_file, \"\\n\");\n     }\n \n-  if (opcode == BIT_IOR_EXPR)\n+  if (opcode == BIT_IOR_EXPR\n+      || (opcode == ERROR_MARK && oe->rank == BIT_IOR_EXPR))\n     tem = invert_truthvalue_loc (loc, tem);\n \n-  tem = fold_convert_loc (loc, TREE_TYPE (op), tem);\n-  gsi = gsi_for_stmt (SSA_NAME_DEF_STMT (op));\n+  tem = fold_convert_loc (loc, optype, tem);\n+  gsi = gsi_for_stmt (stmt);\n   tem = force_gimple_operand_gsi (&gsi, tem, true, NULL_TREE, true,\n \t\t\t\t  GSI_SAME_STMT);\n \n-  VEC_index (operand_entry_t, *ops, range->idx)->op = tem;\n+  /* If doing inter-bb range test optimization, update the\n+     stmts immediately.  Start with changing the first range test\n+     immediate use to the new value (TEM), or, if the first range\n+     test is a GIMPLE_COND stmt, change that condition.  */\n+  if (opcode == ERROR_MARK)\n+    {\n+      if (op)\n+\t{\n+\t  imm_use_iterator iter;\n+\t  use_operand_p use_p;\n+\t  gimple use_stmt;\n+\n+\t  FOR_EACH_IMM_USE_STMT (use_stmt, iter, op)\n+\t    {\n+\t      if (is_gimple_debug (use_stmt))\n+\t\tcontinue;\n+\t      FOR_EACH_IMM_USE_ON_STMT (use_p, iter)\n+\t\tSET_USE (use_p, tem);\n+\t      update_stmt (use_stmt);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  gimple_cond_set_code (stmt, NE_EXPR);\n+\t  gimple_cond_set_lhs (stmt, tem);\n+\t  gimple_cond_set_rhs (stmt, boolean_false_node);\n+\t  update_stmt (stmt);\n+\t}\n+    }\n+  oe->op = tem;\n   range->exp = exp;\n   range->low = low;\n   range->high = high;\n@@ -1978,15 +2030,97 @@ update_range_test (struct range_entry *range, struct range_entry *otherrange,\n \n   for (range = otherrange; range < otherrange + count; range++)\n     {\n-      VEC_index (operand_entry_t, *ops, range->idx)->op = error_mark_node;\n+      oe = VEC_index (oeprand_entry_t, *ops, range->idx);\n+      /* Now change all the other range test immediate uses, so that\n+\t those tests will be optimized away.  */\n+      if (opcode == ERROR_MARK)\n+\t{\n+\t  if (oe->op)\n+\t    {\n+\t      imm_use_iterator iter;\n+\t      use_operand_p use_p;\n+\t      gimple use_stmt;\n+\n+\t      FOR_EACH_IMM_USE_STMT (use_stmt, iter, oe->op)\n+\t\t{\n+\t\t  if (is_gimple_debug (use_stmt))\n+\t\t    continue;\n+\t\t  /* If imm use of _8 is a statement like _7 = _8 | _9;,\n+\t\t     adjust it into _7 = _9;.  */\n+\t\t  if (is_gimple_assign (use_stmt)\n+\t\t      && gimple_assign_rhs_code (use_stmt) == oe->rank)\n+\t\t    {\n+\t\t      tree expr = NULL_TREE;\n+\t\t      if (oe->op == gimple_assign_rhs1 (use_stmt))\n+\t\t\texpr = gimple_assign_rhs2 (use_stmt);\n+\t\t      else if (oe->op == gimple_assign_rhs2 (use_stmt))\n+\t\t\texpr = gimple_assign_rhs1 (use_stmt);\n+\t\t      if (expr\n+\t\t\t  && expr != oe->op\n+\t\t\t  && TREE_CODE (expr) == SSA_NAME)\n+\t\t\t{\n+\t\t\t  gimple_stmt_iterator gsi2 = gsi_for_stmt (use_stmt);\n+\t\t\t  gimple_assign_set_rhs_with_ops (&gsi2, SSA_NAME,\n+\t\t\t\t\t\t\t  expr, NULL_TREE);\n+\t\t\t  update_stmt (use_stmt);\n+\t\t\t  continue;\n+\t\t\t}\n+\t\t    }\n+\t\t  /* If imm use of _8 is a statement like _7 = (int) _8;,\n+\t\t     adjust it into _7 = 0; or _7 = 1;.  */\n+\t\t  if (gimple_assign_cast_p (use_stmt)\n+\t\t      && oe->op == gimple_assign_rhs1 (use_stmt))\n+\t\t    {\n+\t\t      tree lhs = gimple_assign_lhs (use_stmt);\n+\t\t      if (INTEGRAL_TYPE_P (TREE_TYPE (lhs)))\n+\t\t\t{\n+\t\t\t  gimple_stmt_iterator gsi2\n+\t\t\t    = gsi_for_stmt (use_stmt);\n+\t\t\t  tree expr = build_int_cst (TREE_TYPE (lhs),\n+\t\t\t\t\t\t     oe->rank == BIT_IOR_EXPR\n+\t\t\t\t\t\t     ? 0 : 1);\n+\t\t\t  gimple_assign_set_rhs_with_ops (&gsi2,\n+\t\t\t\t\t\t\t  INTEGER_CST,\n+\t\t\t\t\t\t\t  expr, NULL_TREE);\n+\t\t\t  update_stmt (use_stmt);\n+\t\t\t  continue;\n+\t\t\t}\n+\t\t    }\n+\t\t  /* Otherwise replace the use with 0 or 1.  */\n+\t\t  FOR_EACH_IMM_USE_ON_STMT (use_p, iter)\n+\t\t    SET_USE (use_p,\n+\t\t\t     build_int_cst (TREE_TYPE (oe->op),\n+\t\t\t\t\t    oe->rank == BIT_IOR_EXPR\n+\t\t\t\t\t    ? 0 : 1));\n+\t\t  update_stmt (use_stmt);\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      /* If range test was a GIMPLE_COND, simply change it\n+\t\t into an always false or always true condition.  */\n+\t      stmt = last_stmt (BASIC_BLOCK (oe->id));\n+\t      if (oe->rank == BIT_IOR_EXPR)\n+\t\tgimple_cond_make_false (stmt);\n+\t      else\n+\t\tgimple_cond_make_true (stmt);\n+\t      update_stmt (stmt);\n+\t    }\n+\t}\n+      oe->op = error_mark_node;\n       range->exp = NULL_TREE;\n     }\n   return true;\n }\n \n /* Optimize range tests, similarly how fold_range_test optimizes\n    it on trees.  The tree code for the binary\n-   operation between all the operands is OPCODE.  */\n+   operation between all the operands is OPCODE.\n+   If OPCODE is ERROR_MARK, optimize_range_tests is called from within\n+   maybe_optimize_range_tests for inter-bb range optimization.\n+   In that case if oe->op is NULL, oe->id is bb->index whose\n+   GIMPLE_COND is && or ||ed into the test, and oe->rank says\n+   the actual opcode.  */\n \n static void\n optimize_range_tests (enum tree_code opcode,\n@@ -2003,11 +2137,14 @@ optimize_range_tests (enum tree_code opcode,\n   ranges = XNEWVEC (struct range_entry, length);\n   for (i = 0; i < length; i++)\n     {\n+      oe = VEC_index (operand_entry_t, *ops, i);\n       ranges[i].idx = i;\n-      init_range_entry (ranges + i, VEC_index (operand_entry_t, *ops, i)->op);\n+      init_range_entry (ranges + i, oe->op,\n+\t\t\toe->op ? NULL : last_stmt (BASIC_BLOCK (oe->id)));\n       /* For | invert it now, we will invert it again before emitting\n \t the optimized expression.  */\n-      if (opcode == BIT_IOR_EXPR)\n+      if (opcode == BIT_IOR_EXPR\n+\t  || (opcode == ERROR_MARK && oe->rank == BIT_IOR_EXPR))\n \tranges[i].in_p = !ranges[i].in_p;\n     }\n \n@@ -2124,7 +2261,7 @@ optimize_range_tests (enum tree_code opcode,\n \t}\n     }\n \n-  if (any_changes)\n+  if (any_changes && opcode != ERROR_MARK)\n     {\n       j = 0;\n       FOR_EACH_VEC_ELT (operand_entry_t, *ops, i, oe)\n@@ -2141,6 +2278,462 @@ optimize_range_tests (enum tree_code opcode,\n   XDELETEVEC (ranges);\n }\n \n+/* Return true if STMT is a cast like:\n+   <bb N>:\n+   ...\n+   _123 = (int) _234;\n+\n+   <bb M>:\n+   # _345 = PHI <_123(N), 1(...), 1(...)>\n+   where _234 has bool type, _123 has single use and\n+   bb N has a single successor M.  This is commonly used in\n+   the last block of a range test.  */\n+\n+static bool\n+final_range_test_p (gimple stmt)\n+{\n+  basic_block bb, rhs_bb;\n+  edge e;\n+  tree lhs, rhs;\n+  use_operand_p use_p;\n+  gimple use_stmt;\n+\n+  if (!gimple_assign_cast_p (stmt))\n+    return false;\n+  bb = gimple_bb (stmt);\n+  if (!single_succ_p (bb))\n+    return false;\n+  e = single_succ_edge (bb);\n+  if (e->flags & EDGE_COMPLEX)\n+    return false;\n+\n+  lhs = gimple_assign_lhs (stmt);\n+  rhs = gimple_assign_rhs1 (stmt);\n+  if (!INTEGRAL_TYPE_P (TREE_TYPE (lhs))\n+      || TREE_CODE (rhs) != SSA_NAME\n+      || TREE_CODE (TREE_TYPE (rhs)) != BOOLEAN_TYPE)\n+    return false;\n+\n+  /* Test whether lhs is consumed only by a PHI in the only successor bb.  */\n+  if (!single_imm_use (lhs, &use_p, &use_stmt))\n+    return false;\n+\n+  if (gimple_code (use_stmt) != GIMPLE_PHI\n+      || gimple_bb (use_stmt) != e->dest)\n+    return false;\n+\n+  /* And that the rhs is defined in the same loop.  */\n+  rhs_bb = gimple_bb (SSA_NAME_DEF_STMT (rhs));\n+  if (rhs_bb == NULL\n+      || !flow_bb_inside_loop_p (loop_containing_stmt (stmt), rhs_bb))\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Return true if BB is suitable basic block for inter-bb range test\n+   optimization.  If BACKWARD is true, BB should be the only predecessor\n+   of TEST_BB, and *OTHER_BB is either NULL and filled by the routine,\n+   or compared with to find a common basic block to which all conditions\n+   branch to if true resp. false.  If BACKWARD is false, TEST_BB should\n+   be the only predecessor of BB.  */\n+\n+static bool\n+suitable_cond_bb (basic_block bb, basic_block test_bb, basic_block *other_bb,\n+\t\t  bool backward)\n+{\n+  edge_iterator ei, ei2;\n+  edge e, e2;\n+  gimple stmt;\n+  gimple_stmt_iterator gsi;\n+  bool other_edge_seen = false;\n+  bool is_cond;\n+\n+  if (test_bb == bb)\n+    return false;\n+  /* Check last stmt first.  */\n+  stmt = last_stmt (bb);\n+  if (stmt == NULL\n+      || (gimple_code (stmt) != GIMPLE_COND\n+\t  && (backward || !final_range_test_p (stmt)))\n+      || gimple_visited_p (stmt)\n+      || stmt_could_throw_p (stmt)\n+      || *other_bb == bb)\n+    return false;\n+  is_cond = gimple_code (stmt) == GIMPLE_COND;\n+  if (is_cond)\n+    {\n+      /* If last stmt is GIMPLE_COND, verify that one of the succ edges\n+\t goes to the next bb (if BACKWARD, it is TEST_BB), and the other\n+\t to *OTHER_BB (if not set yet, try to find it out).  */\n+      if (EDGE_COUNT (bb->succs) != 2)\n+\treturn false;\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\t{\n+\t  if (!(e->flags & (EDGE_TRUE_VALUE | EDGE_FALSE_VALUE)))\n+\t    return false;\n+\t  if (e->dest == test_bb)\n+\t    {\n+\t      if (backward)\n+\t\tcontinue;\n+\t      else\n+\t\treturn false;\n+\t    }\n+\t  if (e->dest == bb)\n+\t    return false;\n+\t  if (*other_bb == NULL)\n+\t    {\n+\t      FOR_EACH_EDGE (e2, ei2, test_bb->succs)\n+\t\tif (!(e2->flags & (EDGE_TRUE_VALUE | EDGE_FALSE_VALUE)))\n+\t\t  return false;\n+\t\telse if (e->dest == e2->dest)\n+\t\t  *other_bb = e->dest;\n+\t      if (*other_bb == NULL)\n+\t\treturn false;\n+\t    }\n+\t  if (e->dest == *other_bb)\n+\t    other_edge_seen = true;\n+\t  else if (backward)\n+\t    return false;\n+\t}\n+      if (*other_bb == NULL || !other_edge_seen)\n+\treturn false;\n+    }\n+  else if (single_succ (bb) != *other_bb)\n+    return false;\n+\n+  /* Now check all PHIs of *OTHER_BB.  */\n+  e = find_edge (bb, *other_bb);\n+  e2 = find_edge (test_bb, *other_bb);\n+  for (gsi = gsi_start_phis (e->dest); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gimple phi = gsi_stmt (gsi);\n+      /* If both BB and TEST_BB end with GIMPLE_COND, all PHI arguments\n+\t corresponding to BB and TEST_BB predecessor must be the same.  */\n+      if (!operand_equal_p (gimple_phi_arg_def (phi, e->dest_idx),\n+\t\t\t    gimple_phi_arg_def (phi, e2->dest_idx), 0))\n+\t{\n+\t  /* Otherwise, if one of the blocks doesn't end with GIMPLE_COND,\n+\t     one of the PHIs should have the lhs of the last stmt in\n+\t     that block as PHI arg and that PHI should have 0 or 1\n+\t     corresponding to it in all other range test basic blocks\n+\t     considered.  */\n+\t  if (!is_cond)\n+\t    {\n+\t      if (gimple_phi_arg_def (phi, e->dest_idx)\n+\t\t  == gimple_assign_lhs (stmt)\n+\t\t  && (integer_zerop (gimple_phi_arg_def (phi, e2->dest_idx))\n+\t\t      || integer_onep (gimple_phi_arg_def (phi,\n+\t\t\t\t\t\t\t   e2->dest_idx))))\n+\t\tcontinue;\n+\t    }\n+\t  else\n+\t    {\n+\t      gimple test_last = last_stmt (test_bb);\n+\t      if (gimple_code (test_last) != GIMPLE_COND\n+\t\t  && gimple_phi_arg_def (phi, e2->dest_idx)\n+\t\t     == gimple_assign_lhs (test_last)\n+\t\t  && (integer_zerop (gimple_phi_arg_def (phi, e->dest_idx))\n+\t\t      || integer_onep (gimple_phi_arg_def (phi, e->dest_idx))))\n+\t\tcontinue;\n+\t    }\n+\n+\t  return false;\n+\t}\n+    }\n+  return true;\n+}\n+\n+/* Return true if BB doesn't have side-effects that would disallow\n+   range test optimization, all SSA_NAMEs set in the bb are consumed\n+   in the bb and there are no PHIs.  */\n+\n+static bool\n+no_side_effect_bb (basic_block bb)\n+{\n+  gimple_stmt_iterator gsi;\n+  gimple last;\n+\n+  if (!gimple_seq_empty_p (phi_nodes (bb)))\n+    return false;\n+  last = last_stmt (bb);\n+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gimple stmt = gsi_stmt (gsi);\n+      tree lhs;\n+      imm_use_iterator imm_iter;\n+      use_operand_p use_p;\n+\n+      if (is_gimple_debug (stmt))\n+\tcontinue;\n+      if (gimple_has_side_effects (stmt))\n+\treturn false;\n+      if (stmt == last)\n+\treturn true;\n+      if (!is_gimple_assign (stmt))\n+\treturn false;\n+      lhs = gimple_assign_lhs (stmt);\n+      if (TREE_CODE (lhs) != SSA_NAME)\n+\treturn false;\n+      if (gimple_assign_rhs_could_trap_p (stmt))\n+\treturn false;\n+      FOR_EACH_IMM_USE_FAST (use_p, imm_iter, lhs)\n+\t{\n+\t  gimple use_stmt = USE_STMT (use_p);\n+\t  if (is_gimple_debug (use_stmt))\n+\t    continue;\n+\t  if (gimple_bb (use_stmt) != bb)\n+\t    return false;\n+\t}\n+    }\n+  return false;\n+}\n+\n+/* If VAR is set by CODE (BIT_{AND,IOR}_EXPR) which is reassociable,\n+   return true and fill in *OPS recursively.  */\n+\n+static bool\n+get_ops (tree var, enum tree_code code, VEC(operand_entry_t, heap) **ops,\n+\t struct loop *loop)\n+{\n+  gimple stmt = SSA_NAME_DEF_STMT (var);\n+  tree rhs[2];\n+  int i;\n+\n+  if (!is_reassociable_op (stmt, code, loop))\n+    return false;\n+\n+  rhs[0] = gimple_assign_rhs1 (stmt);\n+  rhs[1] = gimple_assign_rhs2 (stmt);\n+  gimple_set_visited (stmt, true);\n+  for (i = 0; i < 2; i++)\n+    if (TREE_CODE (rhs[i]) == SSA_NAME\n+\t&& !get_ops (rhs[i], code, ops, loop)\n+\t&& has_single_use (rhs[i]))\n+      {\n+\toperand_entry_t oe = (operand_entry_t) pool_alloc (operand_entry_pool);\n+\n+\toe->op = rhs[i];\n+\toe->rank = code;\n+\toe->id = 0;\n+\toe->count = 1;\n+\tVEC_safe_push (operand_entry_t, heap, *ops, oe);\n+      }\n+  return true;\n+}\n+\n+/* Inter-bb range test optimization.  */\n+\n+static void\n+maybe_optimize_range_tests (gimple stmt)\n+{\n+  basic_block first_bb = gimple_bb (stmt);\n+  basic_block last_bb = first_bb;\n+  basic_block other_bb = NULL;\n+  basic_block bb;\n+  edge_iterator ei;\n+  edge e;\n+  VEC(operand_entry_t, heap) *ops = NULL;\n+\n+  /* Consider only basic blocks that end with GIMPLE_COND or\n+     a cast statement satisfying final_range_test_p.  All\n+     but the last bb in the first_bb .. last_bb range\n+     should end with GIMPLE_COND.  */\n+  if (gimple_code (stmt) == GIMPLE_COND)\n+    {\n+      if (EDGE_COUNT (first_bb->succs) != 2)\n+\treturn;\n+    }\n+  else if (final_range_test_p (stmt))\n+    other_bb = single_succ (first_bb);\n+  else\n+    return;\n+\n+  if (stmt_could_throw_p (stmt))\n+    return;\n+\n+  /* As relative ordering of post-dominator sons isn't fixed,\n+     maybe_optimize_range_tests can be called first on any\n+     bb in the range we want to optimize.  So, start searching\n+     backwards, if first_bb can be set to a predecessor.  */\n+  while (single_pred_p (first_bb))\n+    {\n+      basic_block pred_bb = single_pred (first_bb);\n+      if (!suitable_cond_bb (pred_bb, first_bb, &other_bb, true))\n+\tbreak;\n+      if (!no_side_effect_bb (first_bb))\n+\tbreak;\n+      first_bb = pred_bb;\n+    }\n+  /* If first_bb is last_bb, other_bb hasn't been computed yet.\n+     Before starting forward search in last_bb successors, find\n+     out the other_bb.  */\n+  if (first_bb == last_bb)\n+    {\n+      other_bb = NULL;\n+      /* As non-GIMPLE_COND last stmt always terminates the range,\n+\t if forward search didn't discover anything, just give up.  */\n+      if (gimple_code (stmt) != GIMPLE_COND)\n+\treturn;\n+      /* Look at both successors.  Either it ends with a GIMPLE_COND\n+\t and satisfies suitable_cond_bb, or ends with a cast and\n+\t other_bb is that cast's successor.  */\n+      FOR_EACH_EDGE (e, ei, first_bb->succs)\n+\tif (!(e->flags & (EDGE_TRUE_VALUE | EDGE_FALSE_VALUE))\n+\t    || e->dest == first_bb)\n+\t  return;\n+\telse if (single_pred_p (e->dest))\n+\t  {\n+\t    stmt = last_stmt (e->dest);\n+\t    if (stmt\n+\t\t&& gimple_code (stmt) == GIMPLE_COND\n+\t\t&& EDGE_COUNT (e->dest->succs) == 2)\n+\t      {\n+\t\tif (suitable_cond_bb (first_bb, e->dest, &other_bb, true))\n+\t\t  break;\n+\t\telse\n+\t\t  other_bb = NULL;\n+\t      }\n+\t    else if (stmt\n+\t\t     && final_range_test_p (stmt)\n+\t\t     && find_edge (first_bb, single_succ (e->dest)))\n+\t      {\n+\t\tother_bb = single_succ (e->dest);\n+\t\tif (other_bb == first_bb)\n+\t\t  other_bb = NULL;\n+\t      }\n+\t  }\n+      if (other_bb == NULL)\n+\treturn;\n+    }\n+  /* Now do the forward search, moving last_bb to successor bbs\n+     that aren't other_bb.  */\n+  while (EDGE_COUNT (last_bb->succs) == 2)\n+    {\n+      FOR_EACH_EDGE (e, ei, last_bb->succs)\n+\tif (e->dest != other_bb)\n+\t  break;\n+      if (e == NULL)\n+\tbreak;\n+      if (!single_pred_p (e->dest))\n+\tbreak;\n+      if (!suitable_cond_bb (e->dest, last_bb, &other_bb, false))\n+\tbreak;\n+      if (!no_side_effect_bb (e->dest))\n+\tbreak;\n+      last_bb = e->dest;\n+    }\n+  if (first_bb == last_bb)\n+    return;\n+  /* Here basic blocks first_bb through last_bb's predecessor\n+     end with GIMPLE_COND, all of them have one of the edges to\n+     other_bb and another to another block in the range,\n+     all blocks except first_bb don't have side-effects and\n+     last_bb ends with either GIMPLE_COND, or cast satisfying\n+     final_range_test_p.  */\n+  for (bb = last_bb; ; bb = single_pred (bb))\n+    {\n+      enum tree_code code;\n+      tree lhs, rhs;\n+\n+      e = find_edge (bb, other_bb);\n+      stmt = last_stmt (bb);\n+      gimple_set_visited (stmt, true);\n+      if (gimple_code (stmt) != GIMPLE_COND)\n+\t{\n+\t  use_operand_p use_p;\n+\t  gimple phi;\n+\t  edge e2;\n+\t  unsigned int d;\n+\n+\t  lhs = gimple_assign_lhs (stmt);\n+\t  rhs = gimple_assign_rhs1 (stmt);\n+\t  gcc_assert (bb == last_bb);\n+\n+\t  /* stmt is\n+\t     _123 = (int) _234;\n+\n+\t     followed by:\n+\t     <bb M>:\n+\t     # _345 = PHI <_123(N), 1(...), 1(...)>\n+\n+\t     or 0 instead of 1.  If it is 0, the _234\n+\t     range test is anded together with all the\n+\t     other range tests, if it is 1, it is ored with\n+\t     them.  */\n+\t  single_imm_use (lhs, &use_p, &phi);\n+\t  gcc_assert (gimple_code (phi) == GIMPLE_PHI);\n+\t  e2 = find_edge (first_bb, other_bb);\n+\t  d = e2->dest_idx;\n+\t  gcc_assert (gimple_phi_arg_def (phi, e->dest_idx) == lhs);\n+\t  if (integer_zerop (gimple_phi_arg_def (phi, d)))\n+\t    code = BIT_AND_EXPR;\n+\t  else\n+\t    {\n+\t      gcc_checking_assert (integer_onep (gimple_phi_arg_def (phi, d)));\n+\t      code = BIT_IOR_EXPR;\n+\t    }\n+\n+\t  /* If _234 SSA_NAME_DEF_STMT is\n+\t     _234 = _567 | _789;\n+\t     (or &, corresponding to 1/0 in the phi arguments,\n+\t     push into ops the individual range test arguments\n+\t     of the bitwise or resp. and, recursively.  */\n+\t  if (!get_ops (rhs, code, &ops,\n+\t\t\tloop_containing_stmt (stmt))\n+\t      && has_single_use (rhs))\n+\t    {\n+\t      /* Otherwise, push the _234 range test itself.  */\n+\t      operand_entry_t oe\n+\t\t= (operand_entry_t) pool_alloc (operand_entry_pool);\n+\n+\t      oe->op = rhs;\n+\t      oe->rank = code;\n+\t      oe->id = 0;\n+\t      oe->count = 1;\n+\t      VEC_safe_push (operand_entry_t, heap, ops, oe);\n+\t    }\n+\t  continue;\n+\t}\n+      /* Otherwise stmt is GIMPLE_COND.  */\n+      code = gimple_cond_code (stmt);\n+      lhs = gimple_cond_lhs (stmt);\n+      rhs = gimple_cond_rhs (stmt);\n+      if (TREE_CODE (lhs) == SSA_NAME\n+\t  && INTEGRAL_TYPE_P (TREE_TYPE (lhs))\n+\t  && ((code != EQ_EXPR && code != NE_EXPR)\n+\t      || rhs != boolean_false_node\n+\t\t /* Either push into ops the individual bitwise\n+\t\t    or resp. and operands, depending on which\n+\t\t    edge is other_bb.  */\n+\t      || !get_ops (lhs, (((e->flags & EDGE_TRUE_VALUE) == 0)\n+\t\t\t\t ^ (code == EQ_EXPR))\n+\t\t\t\t? BIT_AND_EXPR : BIT_IOR_EXPR, &ops,\n+\t\t\t   loop_containing_stmt (stmt))))\n+\t{\n+\t  /* Or push the GIMPLE_COND stmt itself.  */\n+\t  operand_entry_t oe\n+\t    = (operand_entry_t) pool_alloc (operand_entry_pool);\n+\n+\t  oe->op = NULL;\n+\t  oe->rank = (e->flags & EDGE_TRUE_VALUE)\n+\t\t     ? BIT_IOR_EXPR : BIT_AND_EXPR;\n+\t  /* oe->op = NULL signs that there is no SSA_NAME\n+\t     for the range test, and oe->id instead is the\n+\t     basic block number, at which's end the GIMPLE_COND\n+\t     is.  */\n+\t  oe->id = bb->index;\n+\t  oe->count = 1;\n+\t  VEC_safe_push (operand_entry_t, heap, ops, oe);\n+\t}\n+      if (bb == first_bb)\n+\tbreak;\n+    }\n+  if (VEC_length (operand_entry_t, ops) > 1)\n+    optimize_range_tests (ERROR_MARK, &ops);\n+  VEC_free (operand_entry_t, heap, ops);\n+}\n+\n /* Return true if OPERAND is defined by a PHI node which uses the LHS\n    of STMT in it's operands.  This is also known as a \"destructive\n    update\" operation.  */\n@@ -3427,10 +4020,14 @@ reassociate_bb (basic_block bb)\n {\n   gimple_stmt_iterator gsi;\n   basic_block son;\n+  gimple stmt = last_stmt (bb);\n+\n+  if (stmt && !gimple_visited_p (stmt))\n+    maybe_optimize_range_tests (stmt);\n \n   for (gsi = gsi_last_bb (bb); !gsi_end_p (gsi); gsi_prev (&gsi))\n     {\n-      gimple stmt = gsi_stmt (gsi);\n+      stmt = gsi_stmt (gsi);\n \n       if (is_gimple_assign (stmt)\n \t  && !stmt_could_throw_p (stmt))"}]}