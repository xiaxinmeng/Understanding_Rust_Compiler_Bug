{"sha": "8121d2c3841bac793b1f1c1c3d028fae303de516", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODEyMWQyYzM4NDFiYWM3OTNiMWYxYzFjM2QwMjhmYWUzMDNkZTUxNg==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-01-13T14:32:59Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-01-13T14:32:59Z"}, "message": "cpplib.h (cpp_pool, [...]): Move to cpphash.h (struct macro_args): Delete.\n\n        * cpplib.h (cpp_pool, mi_state, mi_ind, struct cpp_macro,\n        struct cpp_chunk, struct htab, struct toklist,\n        struct cpp_context, CPP_STACK_MAX, struct lexer_state,\n        struct spec_nodes, struct cpp_reader, CPP_OPTION, CPP_BUFFER,\n        CPP_BUF_LINE, CPP_BUF_COL, CPP_BUF_COLUMN, U, ustrcmp, ustrncmp,\n        ustrlen, uxstrdup, ustrchr, ufputs): Move to cpphash.h\n        (struct macro_args): Delete.\n        * cpphash.h: See above.\n\nFrom-SVN: r38984", "tree": {"sha": "8f66a31f44c98652908a70e5a12478382433f2b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f66a31f44c98652908a70e5a12478382433f2b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8121d2c3841bac793b1f1c1c3d028fae303de516", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8121d2c3841bac793b1f1c1c3d028fae303de516", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8121d2c3841bac793b1f1c1c3d028fae303de516", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8121d2c3841bac793b1f1c1c3d028fae303de516/comments", "author": null, "committer": null, "parents": [{"sha": "620ef26c8c9bf5e8acb0068e1a52d9c0f6713eec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/620ef26c8c9bf5e8acb0068e1a52d9c0f6713eec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/620ef26c8c9bf5e8acb0068e1a52d9c0f6713eec"}], "stats": {"total": 546, "additions": 277, "deletions": 269}, "files": [{"sha": "9b629d466cc358121c2307abd0100bd31710550d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8121d2c3841bac793b1f1c1c3d028fae303de516/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8121d2c3841bac793b1f1c1c3d028fae303de516/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8121d2c3841bac793b1f1c1c3d028fae303de516", "patch": "@@ -1,3 +1,14 @@\n+2001-01-13  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+        * cpplib.h (cpp_pool, mi_state, mi_ind, struct cpp_macro,\n+        struct cpp_chunk, struct htab, struct toklist,\n+        struct cpp_context, CPP_STACK_MAX, struct lexer_state,\n+        struct spec_nodes, struct cpp_reader, CPP_OPTION, CPP_BUFFER,\n+        CPP_BUF_LINE, CPP_BUF_COL, CPP_BUF_COLUMN, U, ustrcmp, ustrncmp,\n+        ustrlen, uxstrdup, ustrchr, ufputs): Move to cpphash.h.\n+        (struct macro_args): Delete.\n+        * cpphash.h: See above.\n+\n 2001-01-13  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n         * cppmain.c (struct printer): Remove no_line_dirs."}, {"sha": "af60ba43e75b170c1b83bb55b606c00d31e18dda", "filename": "gcc/cpphash.h", "status": "modified", "additions": 266, "deletions": 0, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8121d2c3841bac793b1f1c1c3d028fae303de516/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8121d2c3841bac793b1f1c1c3d028fae303de516/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=8121d2c3841bac793b1f1c1c3d028fae303de516", "patch": "@@ -22,13 +22,26 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #ifndef __GCC_CPPHASH__\n #define __GCC_CPPHASH__\n \n+struct directive;\t\t/* These are deliberately incomplete.  */\n+struct htab;\n+\n /* Test if a sign is valid within a preprocessing number.  */\n #define VALID_SIGN(c, prevc) \\\n   (((c) == '+' || (c) == '-') && \\\n    ((prevc) == 'e' || (prevc) == 'E' \\\n     || (((prevc) == 'p' || (prevc) == 'P') \\\n         && CPP_OPTION (pfile, extended_numbers))))\n \n+#define CPP_OPTION(PFILE, OPTION) ((PFILE)->opts.OPTION)\n+#define CPP_BUFFER(PFILE) ((PFILE)->buffer)\n+#define CPP_BUF_LINE(BUF) ((BUF)->lineno)\n+#define CPP_BUF_COLUMN(BUF, CUR) ((CUR) - (BUF)->line_base + (BUF)->col_adjust)\n+#define CPP_BUF_COL(BUF) CPP_BUF_COLUMN(BUF, (BUF)->cur)\n+\n+/* Maximum nesting of cpp_buffers.  We use a static limit, partly for\n+   efficiency, and partly to limit runaway recursion.  */\n+#define CPP_STACK_MAX 200\n+\n /* Memory pools.  */\n #define ALIGN(size, align) (((size) + ((align) - 1)) & ~((align) - 1))\n #define POOL_FRONT(p) ((p)->cur->front)\n@@ -49,6 +62,15 @@ struct cpp_chunk\n   unsigned char *base;\n };\n \n+typedef struct cpp_pool cpp_pool;\n+struct cpp_pool\n+{\n+  struct cpp_chunk *cur, *locked;\n+  unsigned char *pos;\t\t/* Current position.  */\n+  unsigned int align;\n+  unsigned int locks;\n+};\n+\n /* List of directories to look for include files in. */\n struct file_name_list\n {\n@@ -69,6 +91,76 @@ struct file_name_list\n   struct file_name_map *name_map;\n };\n \n+/* Multiple-include optimisation.  */\n+enum mi_state {MI_FAILED = 0, MI_OUTSIDE};\n+enum mi_ind {MI_IND_NONE = 0, MI_IND_NOT};\n+\n+typedef struct toklist toklist;\n+struct toklist\n+{\n+  cpp_token *first;\n+  cpp_token *limit;\n+};\n+\n+typedef struct cpp_context cpp_context;\n+struct cpp_context\n+{\n+  /* Doubly-linked list.  */\n+  cpp_context *next, *prev;\n+\n+  /* Contexts other than the base context are contiguous tokens.\n+     e.g. macro expansions, expanded argument tokens.  */\n+  struct toklist list;\n+\n+  /* For a macro context, these are the macro and its arguments.  */\n+  cpp_macro *macro;\n+};\n+\n+struct lexer_state\n+{\n+  /* Nonzero if first token on line is CPP_HASH.  */\n+  unsigned char in_directive;\n+\n+  /* Nonzero if in a directive that takes angle-bracketed headers.  */\n+  unsigned char angled_headers;\n+\n+  /* Nonzero to save comments.  Turned off if discard_comments, and in\n+     all directives apart from #define.  */\n+  unsigned char save_comments;\n+\n+  /* If nonzero the next token is at the beginning of the line.  */\n+  unsigned char next_bol;\n+\n+  /* Nonzero if we're mid-comment.  */\n+  unsigned char lexing_comment;\n+\n+  /* Nonzero if lexing __VA_ARGS__ is valid.  */\n+  unsigned char va_args_ok;\n+\n+  /* Nonzero if lexing poisoned identifiers is valid.  */\n+  unsigned char poisoned_ok;\n+\n+  /* Nonzero to prevent macro expansion.  */\n+  unsigned char prevent_expansion;  \n+\n+  /* Nonzero when parsing arguments to a function-like macro.  */\n+  unsigned char parsing_args;\n+\n+  /* Nonzero when in a # NUMBER directive.  */\n+  unsigned char line_extension;\n+};\n+\n+/* Special nodes - identifiers with predefined significance.  */\n+struct spec_nodes\n+{\n+  cpp_hashnode *n_L;\t\t\t/* L\"str\" */\n+  cpp_hashnode *n_defined;\t\t/* defined operator */\n+  cpp_hashnode *n__Pragma;\t\t/* _Pragma operator */\n+  cpp_hashnode *n__STRICT_ANSI__;\t/* STDC_0_IN_SYSTEM_HEADERS */\n+  cpp_hashnode *n__CHAR_UNSIGNED__;\t/* plain char is unsigned */\n+  cpp_hashnode *n__VA_ARGS__;\t\t/* C99 vararg macros */\n+};\n+\n struct cpp_buffer\n {\n   const unsigned char *cur;\t /* current position */\n@@ -131,6 +223,122 @@ struct cpp_buffer\n   ENUM_BITFIELD (cpp_buffer_type) type : 8;\n };\n \n+/* A cpp_reader encapsulates the \"state\" of a pre-processor run.\n+   Applying cpp_get_token repeatedly yields a stream of pre-processor\n+   tokens.  Usually, there is only one cpp_reader object active.  */\n+\n+struct cpp_reader\n+{\n+  /* Top of buffer stack.  */\n+  cpp_buffer *buffer;\n+\n+  /* Lexer state.  */\n+  struct lexer_state state;\n+\n+  /* The position of the last lexed token and last lexed directive.  */\n+  cpp_lexer_pos lexer_pos;\n+  cpp_lexer_pos directive_pos;\n+\n+  /* Memory pools.  */\n+  cpp_pool ident_pool;\t\t/* For all identifiers, and permanent\n+\t\t\t\t   numbers and strings.  */\n+  cpp_pool macro_pool;\t\t/* For macro definitions.  Permanent.  */\n+  cpp_pool argument_pool;\t/* For macro arguments.  Temporary.   */\n+\n+  /* Context stack.  */\n+  struct cpp_context base_context;\n+  struct cpp_context *context;\n+\n+  /* If in_directive, the directive if known.  */\n+  const struct directive *directive;\n+\n+  /* Multiple inlcude optimisation.  */\n+  enum mi_state mi_state;\n+  enum mi_ind mi_if_not_defined;\n+  unsigned int mi_lexed;\n+  const cpp_hashnode *mi_cmacro;\n+  const cpp_hashnode *mi_ind_cmacro;\n+\n+  /* Token lookahead.  */\n+  struct cpp_lookahead *la_read;\t/* Read from this lookahead.  */\n+  struct cpp_lookahead *la_write;\t/* Write to this lookahead.  */\n+  struct cpp_lookahead *la_unused;\t/* Free store.  */\n+  struct cpp_lookahead *la_saved;\t/* Backup when entering directive.  */\n+\n+  /* Error counter for exit code.  */\n+  unsigned int errors;\n+\n+  /* Line and column where a newline was first seen in a string\n+     constant (multi-line strings).  */\n+  cpp_lexer_pos mlstring_pos;\n+\n+  /* Buffer to hold macro definition string.  */\n+  unsigned char *macro_buffer;\n+  unsigned int macro_buffer_len;\n+\n+  /* Current depth in #include directives that use <...>.  */\n+  unsigned int system_include_depth;\n+\n+  /* Current depth of buffer stack.  */\n+  unsigned int buffer_stack_depth;\n+\n+  /* Current depth in #include directives.  */\n+  unsigned int include_depth;\n+\n+  /* Hash table of macros and assertions.  See cpphash.c.  */\n+  struct htab *hashtab;\n+\n+  /* Tree of other included files.  See cppfiles.c.  */\n+  struct splay_tree_s *all_include_files;\n+\n+  /* Chain of `actual directory' file_name_list entries, for \"\"\n+     inclusion.  */\n+  struct file_name_list *actual_dirs;\n+\n+  /* Current maximum length of directory names in the search path\n+     for include files.  (Altered as we get more of them.)  */\n+  unsigned int max_include_len;\n+\n+  /* Date and time tokens.  Calculated together if either is requested.  */\n+  cpp_token date;\n+  cpp_token time;\n+\n+  /* Opaque handle to the dependencies of mkdeps.c.  Used by -M etc.  */\n+  struct deps *deps;\n+\n+  /* Obstack holding all macro hash nodes.  This never shrinks.\n+     See cpphash.c */\n+  struct obstack *hash_ob;\n+\n+  /* Obstack holding buffer and conditional structures.  This is a\n+     real stack.  See cpplib.c */\n+  struct obstack *buffer_ob;\n+\n+  /* Pragma table - dynamic, because a library user can add to the\n+     list of recognized pragmas.  */\n+  struct pragma_entry *pragmas;\n+\n+  /* Call backs.  */\n+  struct cpp_callbacks cb;\n+\n+  /* User visible options.  */\n+  struct cpp_options opts;\n+\n+  /* Special nodes - identifiers with predefined significance to the\n+     preprocessor.  */\n+  struct spec_nodes spec_nodes;\n+\n+  /* We're printed a warning recommending against using #import.  */\n+  unsigned char import_warning;\n+\n+  /* True after cpp_start_read completes.  Used to inhibit some\n+     warnings while parsing the command line.  */\n+  unsigned char done_initializing;\n+\n+  /* True if we are skipping a failed conditional group.  */\n+  unsigned char skipping;\n+};\n+\n /* Character classes.  Based on the more primitive macros in safe-ctype.h.\n    If the definition of `numchar' looks odd to you, please look up the\n    definition of a pp-number in the C standard [section 6.4.8 of C99].\n@@ -240,4 +448,62 @@ extern void _cpp_do_file_change PARAMS ((cpp_reader *, enum cpp_fc_reason,\n #define xcnewvec(T, N)\t(T *) xcalloc (N, sizeof(T))\n #define xobnew(O, T)\t(T *) obstack_alloc (O, sizeof(T))\n \n+/* These are inline functions instead of macros so we can get type\n+   checking.  */\n+typedef unsigned char U_CHAR;\n+#define U (const U_CHAR *)  /* Intended use: U\"string\" */\n+\n+static inline int ustrcmp\tPARAMS ((const U_CHAR *, const U_CHAR *));\n+static inline int ustrncmp\tPARAMS ((const U_CHAR *, const U_CHAR *,\n+\t\t\t\t\t size_t));\n+static inline size_t ustrlen\tPARAMS ((const U_CHAR *));\n+static inline U_CHAR *uxstrdup\tPARAMS ((const U_CHAR *));\n+static inline U_CHAR *ustrchr\tPARAMS ((const U_CHAR *, int));\n+static inline int ufputs\tPARAMS ((const U_CHAR *, FILE *));\n+\n+static inline int\n+ustrcmp (s1, s2)\n+     const U_CHAR *s1, *s2;\n+{\n+  return strcmp ((const char *)s1, (const char *)s2);\n+}\n+\n+static inline int\n+ustrncmp (s1, s2, n)\n+     const U_CHAR *s1, *s2;\n+     size_t n;\n+{\n+  return strncmp ((const char *)s1, (const char *)s2, n);\n+}\n+\n+static inline size_t\n+ustrlen (s1)\n+     const U_CHAR *s1;\n+{\n+  return strlen ((const char *)s1);\n+}\n+\n+static inline U_CHAR *\n+uxstrdup (s1)\n+     const U_CHAR *s1;\n+{\n+  return (U_CHAR *) xstrdup ((const char *)s1);\n+}\n+\n+static inline U_CHAR *\n+ustrchr (s1, c)\n+     const U_CHAR *s1;\n+     int c;\n+{\n+  return (U_CHAR *) strchr ((const char *)s1, c);\n+}\n+\n+static inline int\n+ufputs (s, f)\n+     const U_CHAR *s;\n+     FILE *f;\n+{\n+  return fputs ((const char *)s, f);\n+}\n+\n #endif"}, {"sha": "e332a2786e5326f59c34118c78b34324091498da", "filename": "gcc/cpplib.h", "status": "modified", "additions": 0, "deletions": 269, "changes": 269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8121d2c3841bac793b1f1c1c3d028fae303de516/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8121d2c3841bac793b1f1c1c3d028fae303de516/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=8121d2c3841bac793b1f1c1c3d028fae303de516", "patch": "@@ -38,19 +38,13 @@ typedef struct cpp_options cpp_options;\n typedef struct cpp_token cpp_token;\n typedef struct cpp_string cpp_string;\n typedef struct cpp_hashnode cpp_hashnode;\n-typedef struct cpp_pool cpp_pool;\n typedef struct cpp_macro cpp_macro;\n typedef struct cpp_lexer_pos cpp_lexer_pos;\n typedef struct cpp_lookahead cpp_lookahead;\n typedef struct cpp_callbacks cpp_callbacks;\n \n-struct directive;\t\t/* These are deliberately incomplete.  */\n struct answer;\n-struct cpp_macro;\n-struct macro_args;\n-struct cpp_chunk;\n struct file_name_map_list;\n-struct htab;\n \n /* The first two groups, apart from '=', can appear in preprocessor\n    expressions.  This allows a lookup table to be implemented in\n@@ -158,10 +152,6 @@ enum cpp_ttype\n enum c_lang {CLK_GNUC89 = 0, CLK_GNUC99, CLK_STDC89, CLK_STDC94, CLK_STDC99,\n \t     CLK_GNUCXX, CLK_CXX98, CLK_OBJC, CLK_OBJCXX, CLK_ASM};\n \n-/* Multiple-include optimisation.  */\n-enum mi_state {MI_FAILED = 0, MI_OUTSIDE};\n-enum mi_ind {MI_IND_NONE = 0, MI_IND_NOT};\n-\n /* Payload of a NUMBER, FLOAT, STRING, or COMMENT token.  */\n struct cpp_string\n {\n@@ -217,44 +207,10 @@ struct cpp_lookahead\n   unsigned int cur, count, cap;\n };\n \n-/* Memory pools.  */\n-struct cpp_pool\n-{\n-  struct cpp_chunk *cur, *locked;\n-  unsigned char *pos;\t\t/* Current position.  */\n-  unsigned int align;\n-  unsigned int locks;\n-};\n-\n-typedef struct toklist toklist;\n-struct toklist\n-{\n-  cpp_token *first;\n-  cpp_token *limit;\n-};\n-\n-typedef struct cpp_context cpp_context;\n-struct cpp_context\n-{\n-  /* Doubly-linked list.  */\n-  cpp_context *next, *prev;\n-\n-  /* Contexts other than the base context are contiguous tokens.\n-     e.g. macro expansions, expanded argument tokens.  */\n-  struct toklist list;\n-\n-  /* For a macro context, these are the macro and its arguments.  */\n-  cpp_macro *macro;\n-};\n-\n /* A standalone character.  We may want to make it unsigned for the\n    same reason we use unsigned char - to avoid signedness issues.  */\n typedef int cppchar_t;\n \n-/* Maximum nesting of cpp_buffers.  We use a static limit, partly for\n-   efficiency, and partly to limit runaway recursion.  */\n-#define CPP_STACK_MAX 200\n-\n /* Values for opts.dump_macros.\n   dump_only means inhibit output of the preprocessed text\n              and instead output the definitions of all user-defined\n@@ -427,51 +383,6 @@ struct cpp_options\n   unsigned char help_only;\n };\n \n-struct lexer_state\n-{\n-  /* Nonzero if first token on line is CPP_HASH.  */\n-  unsigned char in_directive;\n-\n-  /* Nonzero if in a directive that takes angle-bracketed headers.  */\n-  unsigned char angled_headers;\n-\n-  /* Nonzero to save comments.  Turned off if discard_comments, and in\n-     all directives apart from #define.  */\n-  unsigned char save_comments;\n-\n-  /* If nonzero the next token is at the beginning of the line.  */\n-  unsigned char next_bol;\n-\n-  /* Nonzero if we're mid-comment.  */\n-  unsigned char lexing_comment;\n-\n-  /* Nonzero if lexing __VA_ARGS__ is valid.  */\n-  unsigned char va_args_ok;\n-\n-  /* Nonzero if lexing poisoned identifiers is valid.  */\n-  unsigned char poisoned_ok;\n-\n-  /* Nonzero to prevent macro expansion.  */\n-  unsigned char prevent_expansion;  \n-\n-  /* Nonzero when parsing arguments to a function-like macro.  */\n-  unsigned char parsing_args;\n-\n-  /* Nonzero when in a # NUMBER directive.  */\n-  unsigned char line_extension;\n-};\n-\n-/* Special nodes - identifiers with predefined significance.  */\n-struct spec_nodes\n-{\n-  cpp_hashnode *n_L;\t\t\t/* L\"str\" */\n-  cpp_hashnode *n_defined;\t\t/* defined operator */\n-  cpp_hashnode *n__Pragma;\t\t/* _Pragma operator */\n-  cpp_hashnode *n__STRICT_ANSI__;\t/* STDC_0_IN_SYSTEM_HEADERS */\n-  cpp_hashnode *n__CHAR_UNSIGNED__;\t/* plain char is unsigned */\n-  cpp_hashnode *n__VA_ARGS__;\t\t/* C99 vararg macros */\n-};\n-\n /* This structure is passed to the call back when changing file.  */\n enum cpp_fc_reason {FC_ENTER = 0, FC_LEAVE, FC_RENAME};\n \n@@ -504,132 +415,10 @@ struct cpp_callbacks\n     void (*def_pragma) PARAMS ((cpp_reader *));\n };\n \n-/* A cpp_reader encapsulates the \"state\" of a pre-processor run.\n-   Applying cpp_get_token repeatedly yields a stream of pre-processor\n-   tokens.  Usually, there is only one cpp_reader object active.  */\n-\n-struct cpp_reader\n-{\n-  /* Top of buffer stack.  */\n-  cpp_buffer *buffer;\n-\n-  /* Lexer state.  */\n-  struct lexer_state state;\n-\n-  /* The position of the last lexed token and last lexed directive.  */\n-  cpp_lexer_pos lexer_pos;\n-  cpp_lexer_pos directive_pos;\n-\n-  /* Memory pools.  */\n-  cpp_pool ident_pool;\t\t/* For all identifiers, and permanent\n-\t\t\t\t   numbers and strings.  */\n-  cpp_pool macro_pool;\t\t/* For macro definitions.  Permanent.  */\n-  cpp_pool argument_pool;\t/* For macro arguments.  Temporary.   */\n-\n-  /* Context stack.  */\n-  struct cpp_context base_context;\n-  struct cpp_context *context;\n-\n-  /* If in_directive, the directive if known.  */\n-  const struct directive *directive;\n-\n-  /* Multiple inlcude optimisation.  */\n-  enum mi_state mi_state;\n-  enum mi_ind mi_if_not_defined;\n-  unsigned int mi_lexed;\n-  const cpp_hashnode *mi_cmacro;\n-  const cpp_hashnode *mi_ind_cmacro;\n-\n-  /* Token lookahead.  */\n-  struct cpp_lookahead *la_read;\t/* Read from this lookahead.  */\n-  struct cpp_lookahead *la_write;\t/* Write to this lookahead.  */\n-  struct cpp_lookahead *la_unused;\t/* Free store.  */\n-  struct cpp_lookahead *la_saved;\t/* Backup when entering directive.  */\n-\n-  /* Error counter for exit code.  */\n-  unsigned int errors;\n-\n-  /* Line and column where a newline was first seen in a string\n-     constant (multi-line strings).  */\n-  cpp_lexer_pos mlstring_pos;\n-\n-  /* Buffer to hold macro definition string.  */\n-  unsigned char *macro_buffer;\n-  unsigned int macro_buffer_len;\n-\n-  /* Current depth in #include directives that use <...>.  */\n-  unsigned int system_include_depth;\n-\n-  /* Current depth of buffer stack.  */\n-  unsigned int buffer_stack_depth;\n-\n-  /* Current depth in #include directives.  */\n-  unsigned int include_depth;\n-\n-  /* Hash table of macros and assertions.  See cpphash.c.  */\n-  struct htab *hashtab;\n-\n-  /* Tree of other included files.  See cppfiles.c.  */\n-  struct splay_tree_s *all_include_files;\n-\n-  /* Chain of `actual directory' file_name_list entries, for \"\"\n-     inclusion.  */\n-  struct file_name_list *actual_dirs;\n-\n-  /* Current maximum length of directory names in the search path\n-     for include files.  (Altered as we get more of them.)  */\n-  unsigned int max_include_len;\n-\n-  /* Date and time tokens.  Calculated together if either is requested.  */\n-  cpp_token date;\n-  cpp_token time;\n-\n-  /* Opaque handle to the dependencies of mkdeps.c.  Used by -M etc.  */\n-  struct deps *deps;\n-\n-  /* Obstack holding all macro hash nodes.  This never shrinks.\n-     See cpphash.c */\n-  struct obstack *hash_ob;\n-\n-  /* Obstack holding buffer and conditional structures.  This is a\n-     real stack.  See cpplib.c */\n-  struct obstack *buffer_ob;\n-\n-  /* Pragma table - dynamic, because a library user can add to the\n-     list of recognized pragmas.  */\n-  struct pragma_entry *pragmas;\n-\n-  /* Call backs.  */\n-  struct cpp_callbacks cb;\n-\n-  /* User visible options.  */\n-  struct cpp_options opts;\n-\n-  /* Special nodes - identifiers with predefined significance to the\n-     preprocessor.  */\n-  struct spec_nodes spec_nodes;\n-\n-  /* We're printed a warning recommending against using #import.  */\n-  unsigned char import_warning;\n-\n-  /* True after cpp_start_read completes.  Used to inhibit some\n-     warnings while parsing the command line.  */\n-  unsigned char done_initializing;\n-\n-  /* True if we are skipping a failed conditional group.  */\n-  unsigned char skipping;\n-};\n-\n #define CPP_FATAL_LIMIT 1000\n /* True if we have seen a \"fatal\" error. */\n #define CPP_FATAL_ERRORS(PFILE) (cpp_errors (PFILE) >= CPP_FATAL_LIMIT)\n \n-#define CPP_OPTION(PFILE, OPTION) ((PFILE)->opts.OPTION)\n-#define CPP_BUFFER(PFILE) ((PFILE)->buffer)\n-#define CPP_BUF_LINE(BUF) ((BUF)->lineno)\n-#define CPP_BUF_COLUMN(BUF, CUR) ((CUR) - (BUF)->line_base + (BUF)->col_adjust)\n-#define CPP_BUF_COL(BUF) CPP_BUF_COLUMN(BUF, (BUF)->cur)\n-\n /* Name under which this program was invoked.  */\n extern const char *progname;\n \n@@ -816,64 +605,6 @@ extern void cpp_stop_lookahead\t\tPARAMS ((cpp_reader *, int));\n extern int cpp_included\tPARAMS ((cpp_reader *, const char *));\n extern void cpp_make_system_header PARAMS ((cpp_reader *, int, int));\n \n-/* These are inline functions instead of macros so we can get type\n-   checking.  */\n-typedef unsigned char U_CHAR;\n-#define U (const U_CHAR *)  /* Intended use: U\"string\" */\n-\n-static inline int ustrcmp\tPARAMS ((const U_CHAR *, const U_CHAR *));\n-static inline int ustrncmp\tPARAMS ((const U_CHAR *, const U_CHAR *,\n-\t\t\t\t\t size_t));\n-static inline size_t ustrlen\tPARAMS ((const U_CHAR *));\n-static inline U_CHAR *uxstrdup\tPARAMS ((const U_CHAR *));\n-static inline U_CHAR *ustrchr\tPARAMS ((const U_CHAR *, int));\n-static inline int ufputs\tPARAMS ((const U_CHAR *, FILE *));\n-\n-static inline int\n-ustrcmp (s1, s2)\n-     const U_CHAR *s1, *s2;\n-{\n-  return strcmp ((const char *)s1, (const char *)s2);\n-}\n-\n-static inline int\n-ustrncmp (s1, s2, n)\n-     const U_CHAR *s1, *s2;\n-     size_t n;\n-{\n-  return strncmp ((const char *)s1, (const char *)s2, n);\n-}\n-\n-static inline size_t\n-ustrlen (s1)\n-     const U_CHAR *s1;\n-{\n-  return strlen ((const char *)s1);\n-}\n-\n-static inline U_CHAR *\n-uxstrdup (s1)\n-     const U_CHAR *s1;\n-{\n-  return (U_CHAR *) xstrdup ((const char *)s1);\n-}\n-\n-static inline U_CHAR *\n-ustrchr (s1, c)\n-     const U_CHAR *s1;\n-     int c;\n-{\n-  return (U_CHAR *) strchr ((const char *)s1, c);\n-}\n-\n-static inline int\n-ufputs (s, f)\n-     const U_CHAR *s;\n-     FILE *f;\n-{\n-  return fputs ((const char *)s, f);\n-}\n-\n #ifdef __cplusplus\n }\n #endif"}]}