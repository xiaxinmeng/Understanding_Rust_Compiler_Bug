{"sha": "9f2f79df19fbfaa1c4be313c2f2b5ce04646433e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWYyZjc5ZGYxOWZiZmFhMWM0YmUzMTNjMmYyYjVjZTA0NjQ2NDMzZQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-08-25T05:17:10Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-08-25T05:17:10Z"}, "message": "gimple-fold: Don't optimize wierdo floating point value reads [PR95450]\n\nMy patch to introduce native_encode_initializer to fold_ctor_reference\napparently broke gnulib/m4 on powerpc64.\nThere it uses a const union with two doubles and corresponding IBM double\ndouble long double which actually is the largest normalizable long double\nvalue (1 ulp higher than __LDBL_MAX__).  The reason our __LDBL_MAX__ is\nsmaller is that we internally treat the double double type as one having\n106-bit precision, but it actually has a variable 53-bit to 2000-ish bit precision\nand for the\n0x1.fffffffffffff7ffffffffffffc000p+1023L\nvalue gnulib uses we need 107-bit precision, therefore for GCC __LDBL_MAX__\nis\n0x1.fffffffffffff7ffffffffffff8000p+1023L\nBefore my changes, we wouldn't be able to fold_ctor_reference it and it\nworked fine at runtime, but with the change we are able to do that, but\nbecause it is larger than anything we can handle internally, we treat it\nweirdly.  Similar problem would be if somebody creates this way valid,\nbut much more than 106 bit precision e.g. 1.0 + 1.0e-768.\nNow, I think similar problem could happen e.g. on i?86/x86_64 with long\ndouble there, it also has some weird values in the format, e.g. the\nunnormals, pseudo infinities and various other magic values.\n\nThis patch for floating point types (including vector and complex types\nwith such elements) will try to encode the returned value again and punt\nif it has different memory representation from the original.  Note, this\nis only done in the path where native_encode_initializer was used, in order\nnot to affect e.g. just reading an unpunned long double value; the value\nshould be compiler generated in that case and thus should be properly\nrepresentable.  It will punt also if e.g. the padding bits are initialized\nto non-zero values.\n\nI think the verification that what we encode can be interpreted back\nwoiuld be only an internal consistency check (so perhaps for ENABLE_CHECKING\nif flag_checking only, but if both directions perform it, then we need\nto avoid mutual recursion).\nWhile for the other direction (interpretation), at least for the broken by\ndesign long doubles we just know we can't represent in GCC all valid values.\nThe other floating point formats are just theoretical case, perhaps we would\ncanonicalize something to a value that wouldn't trigger invalid exception\nwhen without canonicalization it would trigger it at runtime, so let's just\nignore those.\n\nAdjusted (so far untested) patch to do it in native_interpret_real instead\nand limit it to the MODE_COMPOSITE_P cases, for which e.g.\nfold-const.c/simplify-rtx.c punts in several other places too because we just\nknow we can't represent everything.\n\nE.g.\n      /* Don't constant fold this floating point operation if the\n         result may dependent upon the run-time rounding mode and\n         flag_rounding_math is set, or if GCC's software emulation\n         is unable to accurately represent the result.  */\n      if ((flag_rounding_math\n           || (MODE_COMPOSITE_P (mode) && !flag_unsafe_math_optimizations))\n          && (inexact || !real_identical (&result, &value)))\n        return NULL_TREE;\nOr perhaps guard it with MODE_COMPOSITE_P (mode) && !flag_unsafe_math_optimizations\ntoo, thus break what gnulib / m4 does with -ffast-math, but not normally?\n\n2020-08-25  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR target/95450\n\t* fold-const.c (native_interpret_real): For MODE_COMPOSITE_P modes\n\tpunt if the to be returned REAL_CST does not encode to the bitwise\n\tsame representation.\n\n\t* gcc.target/powerpc/pr95450.c: New test.", "tree": {"sha": "625dcb51c916cd6a94ca93bd621352cc8f0001e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/625dcb51c916cd6a94ca93bd621352cc8f0001e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9f2f79df19fbfaa1c4be313c2f2b5ce04646433e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f2f79df19fbfaa1c4be313c2f2b5ce04646433e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f2f79df19fbfaa1c4be313c2f2b5ce04646433e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f2f79df19fbfaa1c4be313c2f2b5ce04646433e/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b958ee0fd0e1b2a2b22784ffbe531ed74358a22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b958ee0fd0e1b2a2b22784ffbe531ed74358a22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b958ee0fd0e1b2a2b22784ffbe531ed74358a22"}], "stats": {"total": 43, "additions": 42, "deletions": 1}, "files": [{"sha": "78f72f0cfa3846509d75263987c6e3200fe37b4a", "filename": "gcc/fold-const.c", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f2f79df19fbfaa1c4be313c2f2b5ce04646433e/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f2f79df19fbfaa1c4be313c2f2b5ce04646433e/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=9f2f79df19fbfaa1c4be313c2f2b5ce04646433e", "patch": "@@ -8328,7 +8328,19 @@ native_interpret_real (tree type, const unsigned char *ptr, int len)\n     }\n \n   real_from_target (&r, tmp, mode);\n-  return build_real (type, r);\n+  tree ret = build_real (type, r);\n+  if (MODE_COMPOSITE_P (mode))\n+    {\n+      /* For floating point values in composite modes, punt if this folding\n+\t doesn't preserve bit representation.  As the mode doesn't have fixed\n+\t precision while GCC pretends it does, there could be valid values that\n+\t GCC can't really represent accurately.  See PR95450.  */\n+      unsigned char buf[24];\n+      if (native_encode_expr (ret, buf, total_bytes, 0) != total_bytes\n+\t  || memcmp (ptr, buf, total_bytes) != 0)\n+\tret = NULL_TREE;\n+    }\n+  return ret;\n }\n \n "}, {"sha": "569d2b2c536fe3421540da896f0d4da1a61d847c", "filename": "gcc/testsuite/gcc.target/powerpc/pr95450.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f2f79df19fbfaa1c4be313c2f2b5ce04646433e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr95450.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f2f79df19fbfaa1c4be313c2f2b5ce04646433e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr95450.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr95450.c?ref=9f2f79df19fbfaa1c4be313c2f2b5ce04646433e", "patch": "@@ -0,0 +1,29 @@\n+/* PR target/95450 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+/* { dg-final { scan-tree-dump-not \"return \\[0-9.e+]\\+;\" \"optimized\" } } */\n+\n+/* Verify this is not optimized for double double into return floating_point_constant,\n+   as while that constant is the maximum normalized floating point value, it needs\n+   107 bit precision, which is more than GCC supports for this format.  */\n+\n+#if __LDBL_MANT_DIG__ == 106\n+union U\n+{\n+  struct { double hi; double lo; } dd;\n+  long double ld;\n+};\n+\n+const union U g = { { __DBL_MAX__, __DBL_MAX__ / (double)134217728UL / (double)134217728UL } };\n+#else\n+struct S\n+{\n+  long double ld;\n+} g;\n+#endif\n+\n+long double\n+foo (void)\n+{\n+  return g.ld;\n+}"}]}