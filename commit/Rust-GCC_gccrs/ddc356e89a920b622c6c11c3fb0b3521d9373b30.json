{"sha": "ddc356e89a920b622c6c11c3fb0b3521d9373b30", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGRjMzU2ZTg5YTkyMGI2MjJjNmMxMWMzZmIwYjM1MjFkOTM3M2IzMA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2000-08-14T14:31:23Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2000-08-14T14:31:23Z"}, "message": "* cse.c: Fix formatting.\n\nFrom-SVN: r35675", "tree": {"sha": "fd3e0dd09d53ca81e32605ab0349d05ab081ae38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd3e0dd09d53ca81e32605ab0349d05ab081ae38"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ddc356e89a920b622c6c11c3fb0b3521d9373b30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddc356e89a920b622c6c11c3fb0b3521d9373b30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ddc356e89a920b622c6c11c3fb0b3521d9373b30", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddc356e89a920b622c6c11c3fb0b3521d9373b30/comments", "author": null, "committer": null, "parents": [{"sha": "b310e72532d00c583353b817dbb3498f3f926221", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b310e72532d00c583353b817dbb3498f3f926221", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b310e72532d00c583353b817dbb3498f3f926221"}], "stats": {"total": 46, "additions": 24, "deletions": 22}, "files": [{"sha": "beaff7af77296ae9074126753031f5698fda8f06", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc356e89a920b622c6c11c3fb0b3521d9373b30/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc356e89a920b622c6c11c3fb0b3521d9373b30/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ddc356e89a920b622c6c11c3fb0b3521d9373b30", "patch": "@@ -1,3 +1,7 @@\n+2000-08-13  Kazu Hirata  <kazu@hxi.com>\n+\n+\t* cse.c: Fix formatting.\n+\n 2000-08-13  Geoff Keating  <geoffk@cygnus.com>\n \n \t* flow.c (attempt_auto_inc): Remove unused variable `bb'."}, {"sha": "a65cecabdfa1516d0eac95ac799d517f67b71a95", "filename": "gcc/cse.c", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc356e89a920b622c6c11c3fb0b3521d9373b30/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc356e89a920b622c6c11c3fb0b3521d9373b30/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=ddc356e89a920b622c6c11c3fb0b3521d9373b30", "patch": "@@ -1952,7 +1952,7 @@ remove_invalid_subreg_refs (regno, word, mode)\n \t\t|| (((SUBREG_WORD (exp)\n \t\t      + (GET_MODE_SIZE (GET_MODE (exp)) - 1) / UNITS_PER_WORD)\n \t\t     >= word)\n-\t\t && SUBREG_WORD (exp) <= end))\n+\t\t    && SUBREG_WORD (exp) <= end))\n \t    && refers_to_regno_p (regno, regno + 1, p->exp, NULL_PTR))\n \t  remove_from_table (p, i);\n       }\n@@ -2240,13 +2240,11 @@ canon_hash (x, mode)\n \n       /* Assume there is only one rtx object for any given label.  */\n     case LABEL_REF:\n-      hash\n-\t+= ((unsigned) LABEL_REF << 7) + (unsigned long) XEXP (x, 0);\n+      hash += ((unsigned) LABEL_REF << 7) + (unsigned long) XEXP (x, 0);\n       return hash;\n \n     case SYMBOL_REF:\n-      hash\n-\t+= ((unsigned) SYMBOL_REF << 7) + (unsigned long) XSTR (x, 0);\n+      hash += ((unsigned) SYMBOL_REF << 7) + (unsigned long) XSTR (x, 0);\n       return hash;\n \n     case MEM:\n@@ -2329,7 +2327,8 @@ canon_hash (x, mode)\n \t  hash += tem;\n \t}\n       else if (fmt[i] == '0' || fmt[i] == 't')\n-\t/* unused */;\n+\t/* Unused.  */\n+\t;\n       else\n \tabort ();\n     }\n@@ -3200,8 +3199,7 @@ fold_rtx (x, insn)\n \t      && GET_MODE_SIZE (imode) <= UNITS_PER_WORD\n \t      && (elt = lookup (SUBREG_REG (x), HASH (SUBREG_REG (x), imode),\n \t\t\t\timode)) != 0)\n-\t    for (elt = elt->first_same_value;\n-\t\t elt; elt = elt->next_same_value)\n+\t    for (elt = elt->first_same_value; elt; elt = elt->next_same_value)\n \t      {\n \t\tif (CONSTANT_P (elt->exp)\n \t\t    && GET_MODE (elt->exp) == VOIDmode)\n@@ -3886,7 +3884,7 @@ fold_rtx (x, insn)\n \t    {\n \t      rtx y\n \t\t= GET_CODE (folded_arg0) == MINUS ? folded_arg0\n-\t\t  : lookup_as_function (folded_arg0, MINUS);\n+\t\t: lookup_as_function (folded_arg0, MINUS);\n \n \t      if (y != 0 && GET_CODE (XEXP (y, 1)) == LABEL_REF\n \t\t  && XEXP (XEXP (y, 1), 0) == XEXP (const_arg1, 0))\n@@ -3897,7 +3895,7 @@ fold_rtx (x, insn)\n \t\t\t: lookup_as_function (folded_arg0, CONST))) != 0\n \t\t  && GET_CODE (XEXP (y, 0)) == MINUS\n \t\t  && GET_CODE (XEXP (XEXP (y, 0), 1)) == LABEL_REF\n-\t\t  && XEXP (XEXP (XEXP (y, 0),1), 0) == XEXP (const_arg1, 0))\n+\t\t  && XEXP (XEXP (XEXP (y, 0), 1), 0) == XEXP (const_arg1, 0))\n \t\treturn XEXP (XEXP (y, 0), 0);\n \t    }\n \n@@ -3906,7 +3904,7 @@ fold_rtx (x, insn)\n \t    {\n \t      rtx y\n \t\t= GET_CODE (folded_arg1) == MINUS ? folded_arg1\n-\t\t  : lookup_as_function (folded_arg1, MINUS);\n+\t\t: lookup_as_function (folded_arg1, MINUS);\n \n \t      if (y != 0 && GET_CODE (XEXP (y, 1)) == LABEL_REF\n \t\t  && XEXP (XEXP (y, 1), 0) == XEXP (const_arg0, 0))\n@@ -3917,7 +3915,7 @@ fold_rtx (x, insn)\n \t\t\t: lookup_as_function (folded_arg1, CONST))) != 0\n \t\t  && GET_CODE (XEXP (y, 0)) == MINUS\n \t\t  && GET_CODE (XEXP (XEXP (y, 0), 1)) == LABEL_REF\n-\t\t  && XEXP (XEXP (XEXP (y, 0),1), 0) == XEXP (const_arg0, 0))\n+\t\t  && XEXP (XEXP (XEXP (y, 0), 1), 0) == XEXP (const_arg0, 0))\n \t\treturn XEXP (XEXP (y, 0), 0);\n \t    }\n \n@@ -3935,7 +3933,7 @@ fold_rtx (x, insn)\n \t      && INTVAL (const_arg1) < 0\n \t      /* This used to test\n \n-\t         - INTVAL (const_arg1) >= 0\n+\t         -INTVAL (const_arg1) >= 0\n \n \t\t But The Sun V5.0 compilers mis-compiled that test.  So\n \t\t instead we test for the problematic value in a more direct\n@@ -3944,7 +3942,7 @@ fold_rtx (x, insn)\n \t        ((HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT - 1))\n \t      && GET_CODE (folded_arg1) == REG)\n \t    {\n-\t      rtx new_const = GEN_INT (- INTVAL (const_arg1));\n+\t      rtx new_const = GEN_INT (-INTVAL (const_arg1));\n \t      struct table_elt *p\n \t\t= lookup (new_const, safe_hash (new_const, mode) & HASH_MASK,\n \t\t\t  mode);\n@@ -3969,7 +3967,7 @@ fold_rtx (x, insn)\n \t\t\t\t NULL_RTX);\n \t    }\n \n-\t  /* ... fall through ...  */\n+\t  /* Fall through.  */\n \n \tfrom_plus:\n \tcase SMIN:    case SMAX:      case UMIN:    case UMAX:\n@@ -4090,7 +4088,7 @@ fold_rtx (x, insn)\n       break;\n \n     case 'x':\n-      /* Always eliminate CONSTANT_P_RTX at this stage. */\n+      /* Always eliminate CONSTANT_P_RTX at this stage.  */\n       if (code == CONSTANT_P_RTX)\n \treturn (const_arg0 ? const1_rtx : const0_rtx);\n       break;\n@@ -4469,7 +4467,7 @@ record_jump_cond (code, mode, op0, op1, reversed_nonequality)\n \n    If LIBCALL_INSN is nonzero, don't record any equivalence made in\n    the insn.  It means that INSN is inside libcall block.  In this\n-   case LIBCALL_INSN is the corresponding insn with REG_LIBCALL. */\n+   case LIBCALL_INSN is the corresponding insn with REG_LIBCALL.  */\n \n /* Data on one SET contained in the instruction.  */\n \n@@ -5052,7 +5050,7 @@ cse_insn (insn, libcall_insn)\n \t also have such operations, but this is only likely to be\n \t beneficial these machines.  */\n \n-      if (flag_expensive_optimizations &&  src_related == 0\n+      if (flag_expensive_optimizations && src_related == 0\n \t  && (GET_MODE_SIZE (mode) < UNITS_PER_WORD)\n \t  && GET_MODE_CLASS (mode) == MODE_INT\n \t  && GET_CODE (src) == MEM && ! do_not_record\n@@ -5225,7 +5223,7 @@ cse_insn (insn, libcall_insn)\n \t  if (elt)\n \t    src_elt_cost = elt->cost;\n \n-          /* Find cheapest and skip it for the next time.   For items\n+\t  /* Find cheapest and skip it for the next time.   For items\n \t     of equal cost, use this order:\n \t     src_folded, src, src_eqv, src_related and hash table entry.  */\n \t  if (src_folded_cost <= src_cost\n@@ -5287,7 +5285,7 @@ cse_insn (insn, libcall_insn)\n \t    }\n \n \t  /* Look for a substitution that makes a valid insn.  */\n-          else if (validate_change (insn, &SET_SRC (sets[i].rtl), trial, 0))\n+\t  else if (validate_change (insn, &SET_SRC (sets[i].rtl), trial, 0))\n \t    {\n \t      /* If we just made a substitution inside a libcall, then we\n \t\t need to make the same substitution in any notes attached\n@@ -6331,7 +6329,7 @@ invalidate_skipped_set (dest, set, data)\n   enum rtx_code code = GET_CODE (dest);\n \n   if (code == MEM\n-      && ! addr_affects_sp_p (dest)\t/* If this is not a stack push ... */\n+      && ! addr_affects_sp_p (dest)\t/* If this is not a stack push ...  */\n       /* There are times when an address can appear varying and be a PLUS\n \t during this scan when it would be a fixed address were we to know\n \t the proper equivalences.  So invalidate all memory if there is\n@@ -7198,8 +7196,8 @@ count_reg_usage (x, counts, dest, incr)\n \n     case CALL_INSN:\n       count_reg_usage (CALL_INSN_FUNCTION_USAGE (x), counts, NULL_RTX, incr);\n+      /* Fall through.  */\n \n-      /* ... falls through ...  */\n     case INSN:\n     case JUMP_INSN:\n       count_reg_usage (PATTERN (x), counts, NULL_RTX, incr);"}]}