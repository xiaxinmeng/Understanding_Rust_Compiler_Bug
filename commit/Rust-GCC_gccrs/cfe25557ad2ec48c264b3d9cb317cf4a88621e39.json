{"sha": "cfe25557ad2ec48c264b3d9cb317cf4a88621e39", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2ZlMjU1NTdhZDJlYzQ4YzI2NGIzZDljYjMxN2NmNGE4ODYyMWUzOQ==", "commit": {"author": {"name": "Francois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2015-08-06T09:22:30Z"}, "committer": {"name": "Fran\u00e7ois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2015-08-06T09:22:30Z"}, "message": "re PR fortran/64022 ([F2003][IEEE] ieee_support_flag does not handle kind=10 and kind=16 REAL variables)\n\n\tPR fortran/64022\n\t* gfortran.dg/ieee/large_2.f90: New test.\n\t* gfortran.dg/ieee/large_3.F90: New test.\n\nFrom-SVN: r226670", "tree": {"sha": "c2d720fe1a97f48b05867163e81668f2e448b7bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c2d720fe1a97f48b05867163e81668f2e448b7bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cfe25557ad2ec48c264b3d9cb317cf4a88621e39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfe25557ad2ec48c264b3d9cb317cf4a88621e39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cfe25557ad2ec48c264b3d9cb317cf4a88621e39", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfe25557ad2ec48c264b3d9cb317cf4a88621e39/comments", "author": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a3fe41f5c986c9557518bb9b4dc76269568a8af7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3fe41f5c986c9557518bb9b4dc76269568a8af7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3fe41f5c986c9557518bb9b4dc76269568a8af7"}], "stats": {"total": 308, "additions": 308, "deletions": 0}, "files": [{"sha": "dad3c512bb20175d2f95a80685a5414212384961", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfe25557ad2ec48c264b3d9cb317cf4a88621e39/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfe25557ad2ec48c264b3d9cb317cf4a88621e39/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cfe25557ad2ec48c264b3d9cb317cf4a88621e39", "patch": "@@ -1,3 +1,9 @@\n+2015-08-06  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\tPR fortran/64022\n+\t* gfortran.dg/ieee/large_2.f90: New test.\n+\t* gfortran.dg/ieee/large_3.F90: New test.\n+\n 2015-08-06  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \tPR fortran/64022"}, {"sha": "54e339710541fc5d321bee7fa625a14b5e5cb9a6", "filename": "gcc/testsuite/gfortran.dg/ieee/large_2.f90", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfe25557ad2ec48c264b3d9cb317cf4a88621e39/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Flarge_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfe25557ad2ec48c264b3d9cb317cf4a88621e39/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Flarge_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Flarge_2.f90?ref=cfe25557ad2ec48c264b3d9cb317cf4a88621e39", "patch": "@@ -0,0 +1,145 @@\n+! { dg-do run }\n+! { dg-additional-options \"-mfp-rounding-mode=d\" { target alpha*-*-* } }\n+\n+  use, intrinsic :: ieee_features\n+  use, intrinsic :: ieee_arithmetic\n+  implicit none\n+\n+  ! k1 and k2 will be large real kinds, if supported, and single/double\n+  ! otherwise\n+  integer, parameter :: k1 = &\n+    max(ieee_selected_real_kind(precision(0.d0) + 1), kind(0.))\n+  integer, parameter :: k2 = &\n+    max(ieee_selected_real_kind(precision(0._k1) + 1), kind(0.d0))\n+\n+  interface check_equal\n+    procedure check_equal1, check_equal2\n+  end interface\n+\n+  interface check_not_equal\n+    procedure check_not_equal1, check_not_equal2\n+  end interface\n+\n+  interface divide\n+    procedure divide1, divide2\n+  end interface\n+\n+  real(kind=k1) :: x1, x2, x3\n+  real(kind=k2) :: y1, y2, y3\n+  type(ieee_round_type) :: mode\n+\n+  if (ieee_support_rounding(ieee_up, x1) .and. &\n+      ieee_support_rounding(ieee_down, x1) .and. &\n+      ieee_support_rounding(ieee_nearest, x1) .and. &\n+      ieee_support_rounding(ieee_to_zero, x1)) then\n+\n+    x1 = 1\n+    x2 = 3\n+    x1 = divide(x1, x2, ieee_up)\n+\n+    x3 = 1\n+    x2 = 3\n+    x3 = divide(x3, x2, ieee_down)\n+    call check_not_equal(x1, x3)\n+    call check_equal(x3, nearest(x1, -1._k1))\n+    call check_equal(x1, nearest(x3,  1._k1))\n+\n+    call check_equal(1._k1/3._k1, divide(1._k1, 3._k1, ieee_nearest))\n+    call check_equal(-1._k1/3._k1, divide(-1._k1, 3._k1, ieee_nearest))\n+\n+    call check_equal(divide(3._k1, 7._k1, ieee_to_zero), &\n+                    divide(3._k1, 7._k1, ieee_down))\n+    call check_equal(divide(-3._k1, 7._k1, ieee_to_zero), &\n+                    divide(-3._k1, 7._k1, ieee_up))\n+\n+  end if\n+\n+  if (ieee_support_rounding(ieee_up, y1) .and. &\n+      ieee_support_rounding(ieee_down, y1) .and. &\n+      ieee_support_rounding(ieee_nearest, y1) .and. &\n+      ieee_support_rounding(ieee_to_zero, y1)) then\n+\n+    y1 = 1\n+    y2 = 3\n+    y1 = divide(y1, y2, ieee_up)\n+\n+    y3 = 1\n+    y2 = 3\n+    y3 = divide(y3, y2, ieee_down)\n+    call check_not_equal(y1, y3)\n+    call check_equal(y3, nearest(y1, -1._k2))\n+    call check_equal(y1, nearest(y3,  1._k2))\n+\n+    call check_equal(1._k2/3._k2, divide(1._k2, 3._k2, ieee_nearest))\n+    call check_equal(-1._k2/3._k2, divide(-1._k2, 3._k2, ieee_nearest))\n+\n+    call check_equal(divide(3._k2, 7._k2, ieee_to_zero), &\n+                    divide(3._k2, 7._k2, ieee_down))\n+    call check_equal(divide(-3._k2, 7._k2, ieee_to_zero), &\n+                    divide(-3._k2, 7._k2, ieee_up))\n+\n+  end if\n+\n+contains\n+\n+  real(kind=k1) function divide1 (x, y, rounding) result(res)\n+    use, intrinsic :: ieee_arithmetic\n+    real(kind=k1), intent(in) :: x, y\n+    type(ieee_round_type), intent(in) :: rounding\n+    type(ieee_round_type) :: old\n+\n+    call ieee_get_rounding_mode (old)\n+    call ieee_set_rounding_mode (rounding)\n+\n+    res = x / y\n+\n+    call ieee_set_rounding_mode (old)\n+  end function\n+\n+  real(kind=k2) function divide2 (x, y, rounding) result(res)\n+    use, intrinsic :: ieee_arithmetic\n+    real(kind=k2), intent(in) :: x, y\n+    type(ieee_round_type), intent(in) :: rounding\n+    type(ieee_round_type) :: old\n+\n+    call ieee_get_rounding_mode (old)\n+    call ieee_set_rounding_mode (rounding)\n+\n+    res = x / y\n+\n+    call ieee_set_rounding_mode (old)\n+  end function\n+\n+  subroutine check_equal1 (x, y)\n+    real(kind=k1), intent(in) :: x, y\n+    if (x /= y) then\n+      print *, x, y\n+      call abort\n+    end if\n+  end subroutine\n+\n+  subroutine check_equal2 (x, y)\n+    real(kind=k2), intent(in) :: x, y\n+    if (x /= y) then\n+      print *, x, y\n+      call abort\n+    end if\n+  end subroutine\n+\n+  subroutine check_not_equal1 (x, y)\n+    real(kind=k1), intent(in) :: x, y\n+    if (x == y) then\n+      print *, x, y\n+      call abort\n+    end if\n+  end subroutine\n+\n+  subroutine check_not_equal2 (x, y)\n+    real(kind=k2), intent(in) :: x, y\n+    if (x == y) then\n+      print *, x, y\n+      call abort\n+    end if\n+  end subroutine\n+\n+end"}, {"sha": "fbba091d031af0d305444e165790fcc177baf8b4", "filename": "gcc/testsuite/gfortran.dg/ieee/large_3.F90", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfe25557ad2ec48c264b3d9cb317cf4a88621e39/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Flarge_3.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfe25557ad2ec48c264b3d9cb317cf4a88621e39/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Flarge_3.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Flarge_3.F90?ref=cfe25557ad2ec48c264b3d9cb317cf4a88621e39", "patch": "@@ -0,0 +1,157 @@\n+! { dg-do run }\n+! { dg-additional-options \"-ffree-line-length-none\" }\n+! { dg-additional-options \"-mfp-trap-mode=sui\" { target alpha*-*-* } }\n+!\n+! Use dg-additional-options rather than dg-options to avoid overwriting the\n+! default IEEE options which are passed by ieee.exp and necessary.\n+\n+  use ieee_features\n+  use ieee_exceptions\n+  use ieee_arithmetic\n+\n+  implicit none\n+\n+  ! k1 and k2 will be large real kinds, if supported, and single/double\n+  ! otherwise\n+  integer, parameter :: k1 = &\n+    max(ieee_selected_real_kind(precision(0.d0) + 1), kind(0.))\n+  integer, parameter :: k2 = &\n+    max(ieee_selected_real_kind(precision(0._k1) + 1), kind(0.d0))\n+\n+  type(ieee_flag_type), parameter :: x(5) = &\n+    [ IEEE_INVALID, IEEE_OVERFLOW, IEEE_DIVIDE_BY_ZERO, &\n+      IEEE_UNDERFLOW, IEEE_INEXACT ]\n+  logical :: l(5) = .false.\n+  character(len=5) :: s\n+\n+#define FLAGS_STRING(S) \\\n+  call ieee_get_flag(x, l) ; \\\n+  write(S,\"(5(A1))\") merge([\"I\",\"O\",\"Z\",\"U\",\"P\"],[\" \",\" \",\" \",\" \",\" \"],l)\n+\n+#define CHECK_FLAGS(expected) \\\n+  FLAGS_STRING(s) ; \\\n+  if (s /= expected) then ; \\\n+    write (*,\"(A,I0,A,A)\") \"Flags at line \", __LINE__, \": \", s ; \\\n+    call abort ; \\\n+  end if ; \\\n+  call check_flag_sub\n+\n+  real(kind=k1), volatile :: sx\n+  real(kind=k2), volatile :: dx\n+\n+  ! This file tests IEEE_SET_FLAG and IEEE_GET_FLAG\n+\n+  !!!! Large kind 1\n+\n+  ! Initial flags are all off\n+  CHECK_FLAGS(\"     \")\n+\n+  ! Check we can clear them\n+  call ieee_set_flag(ieee_all, .false.)\n+  CHECK_FLAGS(\"     \")\n+\n+  ! Raise invalid, then clear\n+  sx = -1\n+  sx = sqrt(sx)\n+  CHECK_FLAGS(\"I    \")\n+  call ieee_set_flag(ieee_all, .false.)\n+  CHECK_FLAGS(\"     \")\n+\n+  ! Raise overflow and precision\n+  sx = huge(sx)\n+  CHECK_FLAGS(\"     \")\n+  sx = sx*sx\n+  CHECK_FLAGS(\" O  P\")\n+\n+  ! Also raise divide-by-zero\n+  sx = 0\n+  sx = 1 / sx\n+  CHECK_FLAGS(\" OZ P\")\n+\n+  ! Clear them\n+  call ieee_set_flag([ieee_overflow,ieee_inexact,&\n+                      ieee_divide_by_zero],[.false.,.false.,.true.])\n+  CHECK_FLAGS(\"  Z  \")\n+  call ieee_set_flag(ieee_divide_by_zero, .false.)\n+  CHECK_FLAGS(\"     \")\n+\n+  ! Raise underflow\n+  sx = tiny(sx)\n+  CHECK_FLAGS(\"     \")\n+  sx = sx / 10\n+  CHECK_FLAGS(\"   UP\")\n+\n+  ! Raise everything\n+  call ieee_set_flag(ieee_all, .true.)\n+  CHECK_FLAGS(\"IOZUP\")\n+\n+  ! And clear\n+  call ieee_set_flag(ieee_all, .false.)\n+  CHECK_FLAGS(\"     \")\n+\n+\n+  !!!! Large kind 2\n+\n+  ! Initial flags are all off\n+  CHECK_FLAGS(\"     \")\n+\n+  ! Check we can clear them\n+  call ieee_set_flag(ieee_all, .false.)\n+  CHECK_FLAGS(\"     \")\n+\n+  ! Raise invalid, then clear\n+  dx = -1\n+  dx = sqrt(dx)\n+  CHECK_FLAGS(\"I    \")\n+  call ieee_set_flag(ieee_all, .false.)\n+  CHECK_FLAGS(\"     \")\n+\n+  ! Raise overflow and precision\n+  dx = huge(dx)\n+  CHECK_FLAGS(\"     \")\n+  dx = dx*dx\n+  CHECK_FLAGS(\" O  P\")\n+\n+  ! Also raise divide-by-zero\n+  dx = 0\n+  dx = 1 / dx\n+  CHECK_FLAGS(\" OZ P\")\n+\n+  ! Clear them\n+  call ieee_set_flag([ieee_overflow,ieee_inexact,&\n+                      ieee_divide_by_zero],[.false.,.false.,.true.])\n+  CHECK_FLAGS(\"  Z  \")\n+  call ieee_set_flag(ieee_divide_by_zero, .false.)\n+  CHECK_FLAGS(\"     \")\n+\n+  ! Raise underflow\n+  dx = tiny(dx)\n+  CHECK_FLAGS(\"     \")\n+  dx = dx / 10\n+  CHECK_FLAGS(\"   UP\")\n+\n+  ! Raise everything\n+  call ieee_set_flag(ieee_all, .true.)\n+  CHECK_FLAGS(\"IOZUP\")\n+\n+  ! And clear\n+  call ieee_set_flag(ieee_all, .false.)\n+  CHECK_FLAGS(\"     \")\n+\n+contains\n+\n+  subroutine check_flag_sub\n+    use ieee_exceptions\n+    logical :: l(5) = .false.\n+    type(ieee_flag_type), parameter :: x(5) = &\n+      [ IEEE_INVALID, IEEE_OVERFLOW, IEEE_DIVIDE_BY_ZERO, &\n+        IEEE_UNDERFLOW, IEEE_INEXACT ]\n+    call ieee_get_flag(x, l)\n+\n+    if (any(l)) then\n+      print *, \"Flags not cleared in subroutine\"\n+      call abort\n+    end if\n+  end subroutine\n+\n+end"}]}