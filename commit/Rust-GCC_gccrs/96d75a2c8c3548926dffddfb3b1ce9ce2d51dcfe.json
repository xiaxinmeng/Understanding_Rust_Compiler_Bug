{"sha": "96d75a2c8c3548926dffddfb3b1ce9ce2d51dcfe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTZkNzVhMmM4YzM1NDg5MjZkZmZkZGZiM2IxY2U5Y2UyZDUxZGNmZQ==", "commit": {"author": {"name": "Yufeng Zhang", "email": "yufeng.zhang@arm.com", "date": "2013-12-04T08:06:16Z"}, "committer": {"name": "Yufeng Zhang", "email": "yufeng@gcc.gnu.org", "date": "2013-12-04T08:06:16Z"}, "message": "gimple-ssa-strength-reduction.c: Include tree-affine.h.\n\ngcc/\n\n\t* gimple-ssa-strength-reduction.c: Include tree-affine.h.\n\t(name_expansions): New static variable.\n\t(alt_base_map): Ditto.\n\t(get_alternative_base): New function.\n\t(find_basis_for_candidate): For CAND_REF, optionally call\n\tfind_basis_for_base_expr with the returned value from\n\tget_alternative_base.\n\t(record_potential_basis): Add new parameter 'base' of type 'tree';\n\tadd an assertion of non-NULL base; use base to set node->base_expr.\n\t(alloc_cand_and_find_basis): Update; call record_potential_basis\n\tfor CAND_REF with the returned value from get_alternative_base.\n\t(replace_refs): Dump details on the replacing.\n\t(execute_strength_reduction): Call pointer_map_create for\n\talt_base_map; call free_affine_expand_cache with &name_expansions.\n\ngcc/testsuite/\n\n\t* gcc.dg/tree-ssa/slsr-39.c: Update.\n\t* gcc.dg/tree-ssa/slsr-41.c: New test.\n\nFrom-SVN: r205655", "tree": {"sha": "94c5fbe90a160607cb09f605cc0b5e8b6382bc01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/94c5fbe90a160607cb09f605cc0b5e8b6382bc01"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/96d75a2c8c3548926dffddfb3b1ce9ce2d51dcfe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96d75a2c8c3548926dffddfb3b1ce9ce2d51dcfe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96d75a2c8c3548926dffddfb3b1ce9ce2d51dcfe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96d75a2c8c3548926dffddfb3b1ce9ce2d51dcfe/comments", "author": null, "committer": null, "parents": [{"sha": "50312b2ff0e52bcbc8e8ff3bec3b229608c289f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50312b2ff0e52bcbc8e8ff3bec3b229608c289f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50312b2ff0e52bcbc8e8ff3bec3b229608c289f4"}], "stats": {"total": 150, "additions": 139, "deletions": 11}, "files": [{"sha": "0e947b7493814eb77d96f2bb6663a30d9c1f0df1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96d75a2c8c3548926dffddfb3b1ce9ce2d51dcfe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96d75a2c8c3548926dffddfb3b1ce9ce2d51dcfe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=96d75a2c8c3548926dffddfb3b1ce9ce2d51dcfe", "patch": "@@ -1,3 +1,20 @@\n+2013-12-04  Yufeng Zhang  <yufeng.zhang@arm.com>\n+\n+\t* gimple-ssa-strength-reduction.c: Include tree-affine.h.\n+\t(name_expansions): New static variable.\n+\t(alt_base_map): Ditto.\n+\t(get_alternative_base): New function.\n+\t(find_basis_for_candidate): For CAND_REF, optionally call\n+\tfind_basis_for_base_expr with the returned value from\n+\tget_alternative_base.\n+\t(record_potential_basis): Add new parameter 'base' of type 'tree';\n+\tadd an assertion of non-NULL base; use base to set node->base_expr.\n+\t(alloc_cand_and_find_basis): Update; call record_potential_basis\n+\tfor CAND_REF with the returned value from get_alternative_base.\n+\t(replace_refs): Dump details on the replacing.\n+\t(execute_strength_reduction): Call pointer_map_create for\n+\talt_base_map; call free_affine_expand_cache with &name_expansions.\n+\n 2013-12-03  Wei Mi  <wmi@google.com>\n \n \tPR rtl-optimization/59020"}, {"sha": "8471812b8f157f63181e659ca44008cd903dbda5", "filename": "gcc/gimple-ssa-strength-reduction.c", "status": "modified", "additions": 91, "deletions": 9, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96d75a2c8c3548926dffddfb3b1ce9ce2d51dcfe/gcc%2Fgimple-ssa-strength-reduction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96d75a2c8c3548926dffddfb3b1ce9ce2d51dcfe/gcc%2Fgimple-ssa-strength-reduction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-strength-reduction.c?ref=96d75a2c8c3548926dffddfb3b1ce9ce2d51dcfe", "patch": "@@ -62,6 +62,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"expmed.h\"\n #include \"params.h\"\n #include \"tree-ssa-address.h\"\n+#include \"tree-affine.h\"\n \f\n /* Information about a strength reduction candidate.  Each statement\n    in the candidate table represents an expression of one of the\n@@ -429,6 +430,42 @@ cand_chain_hasher::equal (const value_type *chain1, const compare_type *chain2)\n /* Hash table embodying a mapping from base exprs to chains of candidates.  */\n static hash_table <cand_chain_hasher> base_cand_map;\n \f\n+/* Pointer map used by tree_to_aff_combination_expand.  */\n+static struct pointer_map_t *name_expansions;\n+/* Pointer map embodying a mapping from bases to alternative bases.  */\n+static struct pointer_map_t *alt_base_map;\n+\n+/* Given BASE, use the tree affine combiniation facilities to\n+   find the underlying tree expression for BASE, with any\n+   immediate offset excluded.  */\n+\n+static tree\n+get_alternative_base (tree base)\n+{\n+  tree *result = (tree *) pointer_map_contains (alt_base_map, base);\n+\n+  if (result == NULL)\n+    {\n+      tree expr;\n+      aff_tree aff;\n+\n+      tree_to_aff_combination_expand (base, TREE_TYPE (base),\n+\t\t\t\t      &aff, &name_expansions);\n+      aff.offset = tree_to_double_int (integer_zero_node);\n+      expr = aff_combination_to_tree (&aff);\n+\n+      result = (tree *) pointer_map_insert (alt_base_map, base);\n+      gcc_assert (!*result);\n+\n+      if (expr == base)\n+\t*result = NULL;\n+      else\n+\t*result = expr;\n+    }\n+\n+  return *result;\n+}\n+\n /* Look in the candidate table for a CAND_PHI that defines BASE and\n    return it if found; otherwise return NULL.  */\n \n@@ -449,8 +486,9 @@ find_phi_def (tree base)\n }\n \n /* Helper routine for find_basis_for_candidate.  May be called twice:\n-   once for the candidate's base expr, and optionally again for the\n-   candidate's phi definition.  */\n+   once for the candidate's base expr, and optionally again either for\n+   the candidate's phi definition or for a CAND_REF's alternative base\n+   expression.  */\n \n static slsr_cand_t\n find_basis_for_base_expr (slsr_cand_t c, tree base_expr)\n@@ -527,6 +565,13 @@ find_basis_for_candidate (slsr_cand_t c)\n \t}\n     }\n \n+  if (!basis && c->kind == CAND_REF)\n+    {\n+      tree alt_base_expr = get_alternative_base (c->base_expr);\n+      if (alt_base_expr)\n+\tbasis = find_basis_for_base_expr (c, alt_base_expr);\n+    }\n+\n   if (basis)\n     {\n       c->sibling = basis->dependent;\n@@ -537,17 +582,21 @@ find_basis_for_candidate (slsr_cand_t c)\n   return 0;\n }\n \n-/* Record a mapping from the base expression of C to C itself, indicating that\n-   C may potentially serve as a basis using that base expression.  */\n+/* Record a mapping from BASE to C, indicating that C may potentially serve\n+   as a basis using that base expression.  BASE may be the same as\n+   C->BASE_EXPR; alternatively BASE can be a different tree that share the\n+   underlining expression of C->BASE_EXPR.  */\n \n static void\n-record_potential_basis (slsr_cand_t c)\n+record_potential_basis (slsr_cand_t c, tree base)\n {\n   cand_chain_t node;\n   cand_chain **slot;\n \n+  gcc_assert (base);\n+\n   node = (cand_chain_t) obstack_alloc (&chain_obstack, sizeof (cand_chain));\n-  node->base_expr = c->base_expr;\n+  node->base_expr = base;\n   node->cand = c;\n   node->next = NULL;\n   slot = base_cand_map.find_slot (node, INSERT);\n@@ -563,10 +612,18 @@ record_potential_basis (slsr_cand_t c)\n }\n \n /* Allocate storage for a new candidate and initialize its fields.\n-   Attempt to find a basis for the candidate.  */\n+   Attempt to find a basis for the candidate.\n+\n+   For CAND_REF, an alternative base may also be recorded and used\n+   to find a basis.  This helps cases where the expression hidden\n+   behind BASE (which is usually an SSA_NAME) has immediate offset,\n+   e.g.\n+\n+     a2[i][j] = 1;\n+     a2[i + 20][j] = 2;  */\n \n static slsr_cand_t\n-alloc_cand_and_find_basis (enum cand_kind kind, gimple gs, tree base, \n+alloc_cand_and_find_basis (enum cand_kind kind, gimple gs, tree base,\n \t\t\t   double_int index, tree stride, tree ctype,\n \t\t\t   unsigned savings)\n {\n@@ -592,7 +649,13 @@ alloc_cand_and_find_basis (enum cand_kind kind, gimple gs, tree base,\n   else\n     c->basis = find_basis_for_candidate (c);\n \n-  record_potential_basis (c);\n+  record_potential_basis (c, base);\n+  if (kind == CAND_REF)\n+    {\n+      tree alt_base = get_alternative_base (base);\n+      if (alt_base)\n+\trecord_potential_basis (c, alt_base);\n+    }\n \n   return c;\n }\n@@ -1852,6 +1915,12 @@ replace_ref (tree *expr, slsr_cand_t c)\n static void\n replace_refs (slsr_cand_t c)\n {\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fputs (\"Replacing reference: \", dump_file);\n+      print_gimple_stmt (dump_file, c->cand_stmt, 0, 0);\n+    }\n+\n   if (gimple_vdef (c->cand_stmt))\n     {\n       tree *lhs = gimple_assign_lhs_ptr (c->cand_stmt);\n@@ -1863,6 +1932,13 @@ replace_refs (slsr_cand_t c)\n       replace_ref (rhs, c);\n     }\n \n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fputs (\"With: \", dump_file);\n+      print_gimple_stmt (dump_file, c->cand_stmt, 0, 0);\n+      fputs (\"\\n\", dump_file);\n+    }\n+\n   if (c->sibling)\n     replace_refs (lookup_cand (c->sibling));\n \n@@ -3533,6 +3609,9 @@ execute_strength_reduction (void)\n   /* Allocate the mapping from base expressions to candidate chains.  */\n   base_cand_map.create (500);\n \n+  /* Allocate the mapping from bases to alternative bases.  */\n+  alt_base_map = pointer_map_create ();\n+\n   /* Initialize the loop optimizer.  We need to detect flow across\n      back edges, and this gives us dominator information as well.  */\n   loop_optimizer_init (AVOID_CFG_MODIFICATIONS);\n@@ -3548,6 +3627,9 @@ execute_strength_reduction (void)\n       dump_cand_chains ();\n     }\n \n+  pointer_map_destroy (alt_base_map);\n+  free_affine_expand_cache (&name_expansions);\n+\n   /* Analyze costs and make appropriate replacements.  */\n   analyze_candidates_and_replace ();\n "}, {"sha": "dcc02b54d7f69de71cccbf1b87987fd36acb5b14", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96d75a2c8c3548926dffddfb3b1ce9ce2d51dcfe/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96d75a2c8c3548926dffddfb3b1ce9ce2d51dcfe/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=96d75a2c8c3548926dffddfb3b1ce9ce2d51dcfe", "patch": "@@ -1,3 +1,8 @@\n+2013-12-04  Yufeng Zhang  <yufeng.zhang@arm.com>\n+\n+\t* gcc.dg/tree-ssa/slsr-39.c: Update.\n+\t* gcc.dg/tree-ssa/slsr-41.c: New test.\n+\n 2013-12-03  Adhemerval Zanella  <azanella@linux.vnet.ibm.com>\n \n \t* gcc.target/powerpc/pr57363.c: New test."}, {"sha": "c1462195c9d882b2d428d59f679ad8189d7d906c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/slsr-39.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96d75a2c8c3548926dffddfb3b1ce9ce2d51dcfe/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-39.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96d75a2c8c3548926dffddfb3b1ce9ce2d51dcfe/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-39.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-39.c?ref=96d75a2c8c3548926dffddfb3b1ce9ce2d51dcfe", "patch": "@@ -6,7 +6,7 @@\n     *PINDEX:   C1 + (C2 * C3) + C4  */\n \n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-slsr\" } */\n+/* { dg-options \"-O2 -fdump-tree-slsr-details\" } */\n \n typedef int arr_2[50][50];\n \n@@ -22,5 +22,5 @@ void foo (arr_2 a2, int v1)\n   return;\n }\n \n-/* { dg-final { scan-tree-dump-times \"MEM\" 4 \"slsr\" } } */\n+/* { dg-final { scan-tree-dump-times \"Replacing reference: \" 4 \"slsr\" } } */\n /* { dg-final { cleanup-tree-dump \"slsr\" } } */"}, {"sha": "2c9d90880b8fb4532a7bbf96e0aa5a84b0b1d532", "filename": "gcc/testsuite/gcc.dg/tree-ssa/slsr-41.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96d75a2c8c3548926dffddfb3b1ce9ce2d51dcfe/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-41.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96d75a2c8c3548926dffddfb3b1ce9ce2d51dcfe/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-41.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-41.c?ref=96d75a2c8c3548926dffddfb3b1ce9ce2d51dcfe", "patch": "@@ -0,0 +1,24 @@\n+/* Verify straight-line strength reduction in using\n+   alternative base expr to record and look for the\n+   potential candidate.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-slsr-details\" } */\n+\n+typedef int arr_2[50][50];\n+\n+void foo (arr_2 a2, int v1)\n+{\n+  int i, j;\n+\n+  i = v1 + 5;\n+  j = i;\n+  a2 [i-10] [j] = 2;\n+  a2 [i] [j++] = i;\n+  a2 [i+20] [j++] = i;\n+  a2 [i-3] [i-1] += 1;\n+  return;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Replacing reference: \" 5 \"slsr\" } } */\n+/* { dg-final { cleanup-tree-dump \"slsr\" } } */"}]}