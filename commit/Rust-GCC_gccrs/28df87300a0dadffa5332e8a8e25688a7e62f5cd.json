{"sha": "28df87300a0dadffa5332e8a8e25688a7e62f5cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjhkZjg3MzAwYTBkYWRmZmE1MzMyZThhOGUyNTY4OGE3ZTYyZjVjZA==", "commit": {"author": {"name": "Michael Matz", "email": "matz@suse.de", "date": "2016-10-20T12:18:32Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2016-10-20T12:18:32Z"}, "message": "loop splitting\n\n(approved at https://gcc.gnu.org/ml/gcc-patches/2015-12/msg00648.html )\n\n\t* common.opt (-fsplit-loops): New flag.\n\t* passes.def (pass_loop_split): Add.\n\t* opts.c (default_options_table): Add OPT_fsplit_loops entry at -O3.\n\t(enable_fdo_optimizations): Add loop splitting.\n\t* timevar.def (TV_LOOP_SPLIT): Add.\n\t* tree-pass.h (make_pass_loop_split): Declare.\n\t* tree-ssa-loop-manip.h (rewrite_into_loop_closed_ssa_1): Declare.\n\t* tree-ssa-loop-unswitch.c: Include tree-ssa-loop-manip.h,\n\t* tree-ssa-loop-split.c: New file.\n\t* Makefile.in (OBJS): Add tree-ssa-loop-split.o.\n\t* doc/invoke.texi (fsplit-loops): Document.\n\t* doc/passes.texi (Loop optimization): Add paragraph about loop\n\tsplitting.\n\ntestsuite/\n\t* gcc.dg/loop-split.c: New test.\n\t* gcc.dg/tree-ssa/ifc-9.c: Update.\n\t* gcc.dg/tree-ssa/ifc-10.c: Update.\n\nFrom-SVN: r241374", "tree": {"sha": "6e07e23b33a8db22031caaaa3e7c9e1df95f4a16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e07e23b33a8db22031caaaa3e7c9e1df95f4a16"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/28df87300a0dadffa5332e8a8e25688a7e62f5cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28df87300a0dadffa5332e8a8e25688a7e62f5cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28df87300a0dadffa5332e8a8e25688a7e62f5cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28df87300a0dadffa5332e8a8e25688a7e62f5cd/comments", "author": {"login": "susematz", "id": 4117296, "node_id": "MDQ6VXNlcjQxMTcyOTY=", "avatar_url": "https://avatars.githubusercontent.com/u/4117296?v=4", "gravatar_id": "", "url": "https://api.github.com/users/susematz", "html_url": "https://github.com/susematz", "followers_url": "https://api.github.com/users/susematz/followers", "following_url": "https://api.github.com/users/susematz/following{/other_user}", "gists_url": "https://api.github.com/users/susematz/gists{/gist_id}", "starred_url": "https://api.github.com/users/susematz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/susematz/subscriptions", "organizations_url": "https://api.github.com/users/susematz/orgs", "repos_url": "https://api.github.com/users/susematz/repos", "events_url": "https://api.github.com/users/susematz/events{/privacy}", "received_events_url": "https://api.github.com/users/susematz/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a2e0054e1d169984ec64d64145b71a88a9628537", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2e0054e1d169984ec64d64145b71a88a9628537", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2e0054e1d169984ec64d64145b71a88a9628537"}], "stats": {"total": 887, "additions": 884, "deletions": 3}, "files": [{"sha": "4265d0871075d682dd603de2ed6f482c6f7f0103", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28df87300a0dadffa5332e8a8e25688a7e62f5cd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28df87300a0dadffa5332e8a8e25688a7e62f5cd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=28df87300a0dadffa5332e8a8e25688a7e62f5cd", "patch": "@@ -1,3 +1,20 @@\n+2016-10-20  Michael Matz  <matz@suse.de>\n+\n+\tLoop splitting.\n+\t* common.opt (-fsplit-loops): New flag.\n+\t* passes.def (pass_loop_split): Add.\n+\t* opts.c (default_options_table): Add OPT_fsplit_loops entry at -O3.\n+\t(enable_fdo_optimizations): Add loop splitting.\n+\t* timevar.def (TV_LOOP_SPLIT): Add.\n+\t* tree-pass.h (make_pass_loop_split): Declare.\n+\t* tree-ssa-loop-manip.h (rewrite_into_loop_closed_ssa_1): Declare.\n+\t* tree-ssa-loop-unswitch.c: Include tree-ssa-loop-manip.h,\n+\t* tree-ssa-loop-split.c: New file.\n+\t* Makefile.in (OBJS): Add tree-ssa-loop-split.o.\n+\t* doc/invoke.texi (fsplit-loops): Document.\n+\t* doc/passes.texi (Loop optimization): Add paragraph about loop\n+\tsplitting.\n+\n 2016-10-20  Richard Biener  <rguenther@suse.de>\n \n \t* cgraphunit.c (analyze_functions): Set node->definition to"}, {"sha": "d5fd1048d7dca71cbbf20b4f3fca129ebfb34dea", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28df87300a0dadffa5332e8a8e25688a7e62f5cd/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28df87300a0dadffa5332e8a8e25688a7e62f5cd/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=28df87300a0dadffa5332e8a8e25688a7e62f5cd", "patch": "@@ -1508,6 +1508,7 @@ OBJS = \\\n \ttree-ssa-loop-manip.o \\\n \ttree-ssa-loop-niter.o \\\n \ttree-ssa-loop-prefetch.o \\\n+\ttree-ssa-loop-split.o \\\n \ttree-ssa-loop-unswitch.o \\\n \ttree-ssa-loop.o \\\n \ttree-ssa-math-opts.o \\"}, {"sha": "eefbb4601bd3eb52886f931cc80f0f7e0a2e8711", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28df87300a0dadffa5332e8a8e25688a7e62f5cd/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28df87300a0dadffa5332e8a8e25688a7e62f5cd/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=28df87300a0dadffa5332e8a8e25688a7e62f5cd", "patch": "@@ -2576,6 +2576,10 @@ funswitch-loops\n Common Report Var(flag_unswitch_loops) Optimization\n Perform loop unswitching.\n \n+fsplit-loops\n+Common Report Var(flag_split_loops) Optimization\n+Perform loop splitting.\n+\n funwind-tables\n Common Report Var(flag_unwind_tables) Optimization\n Just generate unwind tables for exception handling."}, {"sha": "9f57d52d51629056d04276b10433687bcc827535", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28df87300a0dadffa5332e8a8e25688a7e62f5cd/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28df87300a0dadffa5332e8a8e25688a7e62f5cd/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=28df87300a0dadffa5332e8a8e25688a7e62f5cd", "patch": "@@ -402,7 +402,7 @@ Objective-C and Objective-C++ Dialects}.\n -fsel-sched-pipelining -fsel-sched-pipelining-outer-loops @gol\n -fsemantic-interposition -fshrink-wrap -fshrink-wrap-separate @gol\n -fsignaling-nans @gol\n--fsingle-precision-constant -fsplit-ivs-in-unroller @gol\n+-fsingle-precision-constant -fsplit-ivs-in-unroller -fsplit-loops@gol\n -fsplit-paths @gol\n -fsplit-wide-types -fssa-backprop -fssa-phiopt @gol\n -fstdarg-opt -fstrict-aliasing @gol\n@@ -9224,6 +9224,11 @@ Enabled with @option{-O3} and/or @option{-fprofile-use}.\n Enables the loop invariant motion pass in the RTL loop optimizer.  Enabled\n at level @option{-O1}\n \n+@item -fsplit-loops\n+@opindex fsplit-loops\n+Split a loop into two if it contains a condition that's always true\n+for one side of the iteration space and false for the other.\n+\n @item -funswitch-loops\n @opindex funswitch-loops\n Move branches with loop invariant conditions out of the loop, with duplicates"}, {"sha": "bffc3e3ee2b44705a8041b16d04a55726c9e9b2a", "filename": "gcc/doc/passes.texi", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28df87300a0dadffa5332e8a8e25688a7e62f5cd/gcc%2Fdoc%2Fpasses.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28df87300a0dadffa5332e8a8e25688a7e62f5cd/gcc%2Fdoc%2Fpasses.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fpasses.texi?ref=28df87300a0dadffa5332e8a8e25688a7e62f5cd", "patch": "@@ -484,6 +484,12 @@ out of the loops.  To achieve this, a duplicate of the loop is created for\n each possible outcome of conditional jump(s).  The pass is implemented in\n @file{tree-ssa-loop-unswitch.c}.\n \n+Loop splitting.  If a loop contains a conditional statement that is\n+always true for one part of the iteration space and false for the other\n+this pass splits the loop into two, one dealing with one side the other\n+only with the other, thereby removing one inner-loop conditional.  The\n+pass is implemented in @file{tree-ssa-loop-split.c}.\n+\n The optimizations also use various utility functions contained in\n @file{tree-ssa-loop-manip.c}, @file{cfgloop.c}, @file{cfgloopanal.c} and\n @file{cfgloopmanip.c}."}, {"sha": "5f447500a9fe89a8ddb0b2f14278bab8a15b45c2", "filename": "gcc/opts.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28df87300a0dadffa5332e8a8e25688a7e62f5cd/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28df87300a0dadffa5332e8a8e25688a7e62f5cd/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=28df87300a0dadffa5332e8a8e25688a7e62f5cd", "patch": "@@ -530,6 +530,7 @@ static const struct default_options default_options_table[] =\n        regardless of them being declared inline.  */\n     { OPT_LEVELS_3_PLUS_AND_SIZE, OPT_finline_functions, NULL, 1 },\n     { OPT_LEVELS_1_PLUS_NOT_DEBUG, OPT_finline_functions_called_once, NULL, 1 },\n+    { OPT_LEVELS_3_PLUS, OPT_fsplit_loops, NULL, 1 },\n     { OPT_LEVELS_3_PLUS, OPT_funswitch_loops, NULL, 1 },\n     { OPT_LEVELS_3_PLUS, OPT_fgcse_after_reload, NULL, 1 },\n     { OPT_LEVELS_3_PLUS, OPT_ftree_loop_vectorize, NULL, 1 },\n@@ -1427,6 +1428,8 @@ enable_fdo_optimizations (struct gcc_options *opts,\n     opts->x_flag_ipa_bit_cp = value;\n   if (!opts_set->x_flag_predictive_commoning)\n     opts->x_flag_predictive_commoning = value;\n+  if (!opts_set->x_flag_split_loops)\n+    opts->x_flag_split_loops = value;\n   if (!opts_set->x_flag_unswitch_loops)\n     opts->x_flag_unswitch_loops = value;\n   if (!opts_set->x_flag_gcse_after_reload)"}, {"sha": "bb3f0939ef3665267eb4ce6812d80955b79c76c3", "filename": "gcc/passes.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28df87300a0dadffa5332e8a8e25688a7e62f5cd/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28df87300a0dadffa5332e8a8e25688a7e62f5cd/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=28df87300a0dadffa5332e8a8e25688a7e62f5cd", "patch": "@@ -269,6 +269,7 @@ along with GCC; see the file COPYING3.  If not see\n \t  NEXT_PASS (pass_tree_loop_init);\n \t  NEXT_PASS (pass_tree_unswitch);\n \t  NEXT_PASS (pass_scev_cprop);\n+\t  NEXT_PASS (pass_loop_split);\n \t  NEXT_PASS (pass_record_bounds);\n \t  NEXT_PASS (pass_loop_distribution);\n \t  NEXT_PASS (pass_copy_prop);"}, {"sha": "33e86f68cb7628b303007e3275e35d33eaf9098b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28df87300a0dadffa5332e8a8e25688a7e62f5cd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28df87300a0dadffa5332e8a8e25688a7e62f5cd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=28df87300a0dadffa5332e8a8e25688a7e62f5cd", "patch": "@@ -1,3 +1,9 @@\n+2016-10-20  Michael Matz  <matz@suse.de>\n+\n+\t* gcc.dg/loop-split.c: New test.\n+\t* gcc.dg/tree-ssa/ifc-9.c: Update.\n+\t* gcc.dg/tree-ssa/ifc-10.c: Update.\n+\n 2016-10-20  Richard Biener  <rguenther@suse.de>\n \n \t* gcc.dg/graphite/pr35356-1.c: Update."}, {"sha": "859e2ec3a9ba9729c4d31de25b55198795ca1a10", "filename": "gcc/testsuite/gcc.dg/loop-split.c", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28df87300a0dadffa5332e8a8e25688a7e62f5cd/gcc%2Ftestsuite%2Fgcc.dg%2Floop-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28df87300a0dadffa5332e8a8e25688a7e62f5cd/gcc%2Ftestsuite%2Fgcc.dg%2Floop-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Floop-split.c?ref=28df87300a0dadffa5332e8a8e25688a7e62f5cd", "patch": "@@ -0,0 +1,147 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fsplit-loops -fdump-tree-lsplit-details\" } */\n+\n+#ifdef __cplusplus\n+extern \"C\" int printf (const char *, ...);\n+extern \"C\" void abort (void);\n+#else\n+extern int printf (const char *, ...);\n+extern void abort (void);\n+#endif\n+\n+/* Define TRACE to 1 or 2 to get detailed tracing.\n+   Define SINGLE_TEST to 1 or 2 to get a simple routine with\n+   just one loop, called only one time or with multiple parameters,\n+   to make debugging easier.  */\n+#ifndef TRACE\n+#define TRACE 0\n+#endif\n+\n+#define loop(beg,step,beg2,cond1,cond2) \\\n+    do \\\n+      { \\\n+\tsum = 0; \\\n+        for (i = (beg), j = (beg2); (cond1); i+=(step),j+=(step)) \\\n+          { \\\n+            if (cond2) { \\\n+\t      if (TRACE > 1) printf (\"a: %d %d\\n\", i, j); \\\n+              sum += a[i]; \\\n+\t    } else { \\\n+\t      if (TRACE > 1) printf (\"b: %d %d\\n\", i, j); \\\n+              sum += b[i]; \\\n+\t    } \\\n+          } \\\n+\tif (TRACE > 0) printf (\"sum: %d\\n\", sum); \\\n+\tcheck = check * 47 + sum; \\\n+      } while (0)\n+\n+#ifndef SINGLE_TEST\n+unsigned __attribute__((noinline, noclone)) dotest (int beg, int end, int step,\n+\t\t\t\t\t       int c, int *a, int *b, int beg2)\n+{\n+  unsigned check = 0;\n+  int sum;\n+  int i, j;\n+  loop (beg, 1, beg2, i < end, j < c);\n+  loop (beg, 1, beg2, i <= end, j < c);\n+  loop (beg, 1, beg2, i < end, j <= c);\n+  loop (beg, 1, beg2, i <= end, j <= c);\n+  loop (beg, 1, beg2, i < end, j > c);\n+  loop (beg, 1, beg2, i <= end, j > c);\n+  loop (beg, 1, beg2, i < end, j >= c);\n+  loop (beg, 1, beg2, i <= end, j >= c);\n+  beg2 += end-beg;\n+  loop (end, -1, beg2, i >= beg, j >= c);\n+  loop (end, -1, beg2, i >= beg, j > c);\n+  loop (end, -1, beg2, i > beg, j >= c);\n+  loop (end, -1, beg2, i > beg, j > c);\n+  loop (end, -1, beg2, i >= beg, j <= c);\n+  loop (end, -1, beg2, i >= beg, j < c);\n+  loop (end, -1, beg2, i > beg, j <= c);\n+  loop (end, -1, beg2, i > beg, j < c);\n+  return check;\n+}\n+\n+#else\n+\n+int __attribute__((noinline, noclone)) f (int beg, int end, int step,\n+\t\t\t\t\t  int c, int *a, int *b, int beg2)\n+{\n+  int sum = 0;\n+  int i, j;\n+  //for (i = beg, j = beg2; i < end; i += 1, j++ /*step*/)\n+  for (i = end, j = beg2 + (end-beg); i > beg; i += -1, j-- /*step*/)\n+    {\n+      // i - j == X --> i = X + j\n+      // --> i < end == X+j < end == j < end - X\n+      // --> newend = end - (i_init - j_init)\n+      // j < end-X && j < c --> j < min(end-X,c)\n+      // j < end-X && j <= c --> j <= min(end-X-1,c) or j < min(end-X,c+1{OF!})\n+      //if (j < c)\n+      if (j >= c)\n+\tprintf (\"a: %d %d\\n\", i, j);\n+      /*else\n+\tprintf (\"b: %d %d\\n\", i, j);*/\n+\t/*sum += a[i];\n+      else\n+\tsum += b[i];*/\n+    }\n+  return sum;\n+}\n+\n+int __attribute__((noinline, noclone)) f2 (int *beg, int *end, int step,\n+\t\t\t\t\t  int *c, int *a, int *b, int *beg2)\n+{\n+  int sum = 0;\n+  int *i, *j;\n+  for (i = beg, j = beg2; i < end; i += 1, j++ /*step*/)\n+    {\n+      if (j <= c)\n+\tprintf (\"%d %d\\n\", i - beg, j - beg);\n+\t/*sum += a[i];\n+      else\n+\tsum += b[i];*/\n+    }\n+  return sum;\n+}\n+#endif\n+\n+extern int printf (const char *, ...);\n+\n+int main ()\n+{\n+  int a[] = {0,0,0,0,0, 1,2,3,4,5,6,7,8,9,          0,0,0,0,0};\n+  int b[] = {0,0,0,0,0, -1,-2,-3,-4,-5,-6,-7,-8,-9, 0,0,0,0,0,};\n+  int c;\n+  int diff = 0;\n+  unsigned check = 0;\n+#if defined(SINGLE_TEST) && (SINGLE_TEST == 1)\n+  //dotest (0, 9, 1, -1, a+5, b+5, -1);\n+  //return 0;\n+  f (0, 9, 1, 5, a+5, b+5, -1);\n+  return 0;\n+#endif\n+  for (diff = -5; diff <= 5; diff++)\n+    {\n+      for (c = -1; c <= 10; c++)\n+\t{\n+#ifdef SINGLE_TEST\n+\t  int s = f (0, 9, 1, c, a+5, b+5, diff);\n+\t  //int s = f2 (a+0, a+9, 1, a+c, a+5, b+5, a+diff);\n+\t  printf (\"%d \", s);\n+#else\n+\t  if (TRACE > 0)\n+\t    printf (\"check %d %d\\n\", c, diff);\n+\t  check = check * 51 + dotest (0, 9, 1, c, a+5, b+5, diff);\n+#endif\n+\t}\n+      //printf (\"\\n\");\n+    }\n+  //printf (\"%u\\n\", check);\n+  if (check != 3213344948)\n+    abort ();\n+  return 0;\n+}\n+\n+/* All 16 loops in dotest should be split.  */\n+/* { dg-final { scan-tree-dump-times \"Loop split\" 16 \"lsplit\" } } */"}, {"sha": "fbac009944606dbad8ed6911c30666940318a36f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ifc-10.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28df87300a0dadffa5332e8a8e25688a7e62f5cd/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28df87300a0dadffa5332e8a8e25688a7e62f5cd/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-10.c?ref=28df87300a0dadffa5332e8a8e25688a7e62f5cd", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-Ofast -fdump-tree-ifcvt-stats\" } */\n+/* { dg-options \"-Ofast -fno-split-loops -fdump-tree-ifcvt-stats\" } */\n /* { dg-require-visibility \"\" } */\n \n int b[256] = {0}, y;"}, {"sha": "338ea2545d24822f8706247bea66b56d334e1f7c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ifc-9.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28df87300a0dadffa5332e8a8e25688a7e62f5cd/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28df87300a0dadffa5332e8a8e25688a7e62f5cd/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-9.c?ref=28df87300a0dadffa5332e8a8e25688a7e62f5cd", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-Ofast -fdump-tree-ifcvt-stats\" } */\n+/* { dg-options \"-Ofast -fno-split-loops -fdump-tree-ifcvt-stats\" } */\n /* { dg-require-visibility \"\" } */\n \n extern int b[256], y;"}, {"sha": "14730c62723a2ff0c85f78181a573787d6c790c8", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28df87300a0dadffa5332e8a8e25688a7e62f5cd/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28df87300a0dadffa5332e8a8e25688a7e62f5cd/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=28df87300a0dadffa5332e8a8e25688a7e62f5cd", "patch": "@@ -185,6 +185,7 @@ DEFTIMEVAR (TV_LIM                   , \"tree loop invariant motion\")\n DEFTIMEVAR (TV_TREE_LOOP_IVCANON     , \"tree canonical iv\")\n DEFTIMEVAR (TV_SCEV_CONST            , \"scev constant prop\")\n DEFTIMEVAR (TV_TREE_LOOP_UNSWITCH    , \"tree loop unswitching\")\n+DEFTIMEVAR (TV_LOOP_SPLIT            , \"loop splitting\")\n DEFTIMEVAR (TV_COMPLETE_UNROLL       , \"complete unrolling\")\n DEFTIMEVAR (TV_TREE_PARALLELIZE_LOOPS, \"tree parallelize loops\")\n DEFTIMEVAR (TV_TREE_VECTORIZATION    , \"tree vectorization\")"}, {"sha": "fce98390fbe920bc87b79c2930511f630d78a4d5", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28df87300a0dadffa5332e8a8e25688a7e62f5cd/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28df87300a0dadffa5332e8a8e25688a7e62f5cd/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=28df87300a0dadffa5332e8a8e25688a7e62f5cd", "patch": "@@ -367,6 +367,7 @@ extern gimple_opt_pass *make_pass_tree_no_loop (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_tree_loop_init (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_lim (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_tree_unswitch (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_loop_split (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_predcom (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_iv_canon (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_scev_cprop (gcc::context *ctxt);"}, {"sha": "56e4f1ffecba6f2f586cedbdb56a5ac0a07e2b6e", "filename": "gcc/tree-ssa-loop-manip.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28df87300a0dadffa5332e8a8e25688a7e62f5cd/gcc%2Ftree-ssa-loop-manip.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28df87300a0dadffa5332e8a8e25688a7e62f5cd/gcc%2Ftree-ssa-loop-manip.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.h?ref=28df87300a0dadffa5332e8a8e25688a7e62f5cd", "patch": "@@ -24,6 +24,8 @@ typedef void (*transform_callback)(struct loop *, void *);\n \n extern void create_iv (tree, tree, tree, struct loop *, gimple_stmt_iterator *,\n \t\t       bool, tree *, tree *);\n+extern void rewrite_into_loop_closed_ssa_1 (bitmap, unsigned, int,\n+\t\t\t\t\t    struct loop *);\n extern void rewrite_into_loop_closed_ssa (bitmap, unsigned);\n extern void rewrite_virtuals_into_loop_closed_ssa (struct loop *);\n extern void verify_loop_closed_ssa (bool);"}, {"sha": "e2bfd783cb221990d27394d625e2f15f81fc9625", "filename": "gcc/tree-ssa-loop-split.c", "status": "added", "additions": 687, "deletions": 0, "changes": 687, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28df87300a0dadffa5332e8a8e25688a7e62f5cd/gcc%2Ftree-ssa-loop-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28df87300a0dadffa5332e8a8e25688a7e62f5cd/gcc%2Ftree-ssa-loop-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-split.c?ref=28df87300a0dadffa5332e8a8e25688a7e62f5cd", "patch": "@@ -0,0 +1,687 @@\n+/* Loop splitting.\n+   Copyright (C) 2015 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 3, or (at your option) any\n+later version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"tree-pass.h\"\n+#include \"ssa.h\"\n+#include \"fold-const.h\"\n+#include \"tree-cfg.h\"\n+#include \"tree-ssa.h\"\n+#include \"tree-ssa-loop-niter.h\"\n+#include \"tree-ssa-loop.h\"\n+#include \"tree-ssa-loop-manip.h\"\n+#include \"tree-into-ssa.h\"\n+#include \"cfgloop.h\"\n+#include \"tree-scalar-evolution.h\"\n+#include \"gimple-iterator.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"cfghooks.h\"\n+#include \"gimple-fold.h\"\n+#include \"gimplify-me.h\"\n+\n+/* This file implements loop splitting, i.e. transformation of loops like\n+\n+   for (i = 0; i < 100; i++)\n+     {\n+       if (i < 50)\n+         A;\n+       else\n+         B;\n+     }\n+\n+   into:\n+\n+   for (i = 0; i < 50; i++)\n+     {\n+       A;\n+     }\n+   for (; i < 100; i++)\n+     {\n+       B;\n+     }\n+\n+   */\n+\n+/* Return true when BB inside LOOP is a potential iteration space\n+   split point, i.e. ends with a condition like \"IV < comp\", which\n+   is true on one side of the iteration space and false on the other,\n+   and the split point can be computed.  If so, also return the border\n+   point in *BORDER and the comparison induction variable in IV.  */\n+\n+static tree\n+split_at_bb_p (struct loop *loop, basic_block bb, tree *border, affine_iv *iv)\n+{\n+  gimple *last;\n+  gcond *stmt;\n+  affine_iv iv2;\n+\n+  /* BB must end in a simple conditional jump.  */\n+  last = last_stmt (bb);\n+  if (!last || gimple_code (last) != GIMPLE_COND)\n+    return NULL_TREE;\n+  stmt = as_a <gcond *> (last);\n+\n+  enum tree_code code = gimple_cond_code (stmt);\n+\n+  /* Only handle relational comparisons, for equality and non-equality\n+     we'd have to split the loop into two loops and a middle statement.  */\n+  switch (code)\n+    {\n+      case LT_EXPR:\n+      case LE_EXPR:\n+      case GT_EXPR:\n+      case GE_EXPR:\n+\tbreak;\n+      default:\n+\treturn NULL_TREE;\n+    }\n+\n+  if (loop_exits_from_bb_p (loop, bb))\n+    return NULL_TREE;\n+\n+  tree op0 = gimple_cond_lhs (stmt);\n+  tree op1 = gimple_cond_rhs (stmt);\n+\n+  if (!simple_iv (loop, loop, op0, iv, false))\n+    return NULL_TREE;\n+  if (!simple_iv (loop, loop, op1, &iv2, false))\n+    return NULL_TREE;\n+\n+  /* Make it so that the first argument of the condition is\n+     the looping one.  */\n+  if (!integer_zerop (iv2.step))\n+    {\n+      std::swap (op0, op1);\n+      std::swap (*iv, iv2);\n+      code = swap_tree_comparison (code);\n+      gimple_cond_set_condition (stmt, code, op0, op1);\n+      update_stmt (stmt);\n+    }\n+  else if (integer_zerop (iv->step))\n+    return NULL_TREE;\n+  if (!integer_zerop (iv2.step))\n+    return NULL_TREE;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"Found potential split point: \");\n+      print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n+      fprintf (dump_file, \" { \");\n+      print_generic_expr (dump_file, iv->base, TDF_SLIM);\n+      fprintf (dump_file, \" + I*\");\n+      print_generic_expr (dump_file, iv->step, TDF_SLIM);\n+      fprintf (dump_file, \" } %s \", get_tree_code_name (code));\n+      print_generic_expr (dump_file, iv2.base, TDF_SLIM);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  *border = iv2.base;\n+  return op0;\n+}\n+\n+/* Given a GUARD conditional stmt inside LOOP, which we want to make always\n+   true or false depending on INITIAL_TRUE, and adjusted values NEXTVAL\n+   (a post-increment IV) and NEWBOUND (the comparator) adjust the loop\n+   exit test statement to loop back only if the GUARD statement will\n+   also be true/false in the next iteration.  */\n+\n+static void\n+patch_loop_exit (struct loop *loop, gcond *guard, tree nextval, tree newbound,\n+\t\t bool initial_true)\n+{\n+  edge exit = single_exit (loop);\n+  gcond *stmt = as_a <gcond *> (last_stmt (exit->src));\n+  gimple_cond_set_condition (stmt, gimple_cond_code (guard),\n+\t\t\t     nextval, newbound);\n+  update_stmt (stmt);\n+\n+  edge stay = single_pred_edge (loop->latch);\n+\n+  exit->flags &= ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE);\n+  stay->flags &= ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE);\n+\n+  if (initial_true)\n+    {\n+      exit->flags |= EDGE_FALSE_VALUE;\n+      stay->flags |= EDGE_TRUE_VALUE;\n+    }\n+  else\n+    {\n+      exit->flags |= EDGE_TRUE_VALUE;\n+      stay->flags |= EDGE_FALSE_VALUE;\n+    }\n+}\n+\n+/* Give an induction variable GUARD_IV, and its affine descriptor IV,\n+   find the loop phi node in LOOP defining it directly, or create\n+   such phi node.  Return that phi node.  */\n+\n+static gphi *\n+find_or_create_guard_phi (struct loop *loop, tree guard_iv, affine_iv * /*iv*/)\n+{\n+  gimple *def = SSA_NAME_DEF_STMT (guard_iv);\n+  gphi *phi;\n+  if ((phi = dyn_cast <gphi *> (def))\n+      && gimple_bb (phi) == loop->header)\n+    return phi;\n+\n+  /* XXX Create the PHI instead.  */\n+  return NULL;\n+}\n+\n+/* This function updates the SSA form after connect_loops made a new\n+   edge NEW_E leading from LOOP1 exit to LOOP2 (via in intermediate\n+   conditional).  I.e. the second loop can now be entered either\n+   via the original entry or via NEW_E, so the entry values of LOOP2\n+   phi nodes are either the original ones or those at the exit\n+   of LOOP1.  Insert new phi nodes in LOOP2 pre-header reflecting\n+   this.  */\n+\n+static void\n+connect_loop_phis (struct loop *loop1, struct loop *loop2, edge new_e)\n+{\n+  basic_block rest = loop_preheader_edge (loop2)->src;\n+  gcc_assert (new_e->dest == rest);\n+  edge skip_first = EDGE_PRED (rest, EDGE_PRED (rest, 0) == new_e);\n+\n+  edge firste = loop_preheader_edge (loop1);\n+  edge seconde = loop_preheader_edge (loop2);\n+  edge firstn = loop_latch_edge (loop1);\n+  gphi_iterator psi_first, psi_second;\n+  for (psi_first = gsi_start_phis (loop1->header),\n+       psi_second = gsi_start_phis (loop2->header);\n+       !gsi_end_p (psi_first);\n+       gsi_next (&psi_first), gsi_next (&psi_second))\n+    {\n+      tree init, next, new_init;\n+      use_operand_p op;\n+      gphi *phi_first = psi_first.phi ();\n+      gphi *phi_second = psi_second.phi ();\n+\n+      init = PHI_ARG_DEF_FROM_EDGE (phi_first, firste);\n+      next = PHI_ARG_DEF_FROM_EDGE (phi_first, firstn);\n+      op = PHI_ARG_DEF_PTR_FROM_EDGE (phi_second, seconde);\n+      gcc_assert (operand_equal_for_phi_arg_p (init, USE_FROM_PTR (op)));\n+\n+      /* Prefer using original variable as a base for the new ssa name.\n+\t This is necessary for virtual ops, and useful in order to avoid\n+\t losing debug info for real ops.  */\n+      if (TREE_CODE (next) == SSA_NAME\n+\t  && useless_type_conversion_p (TREE_TYPE (next),\n+\t\t\t\t\tTREE_TYPE (init)))\n+\tnew_init = copy_ssa_name (next);\n+      else if (TREE_CODE (init) == SSA_NAME\n+\t       && useless_type_conversion_p (TREE_TYPE (init),\n+\t\t\t\t\t     TREE_TYPE (next)))\n+\tnew_init = copy_ssa_name (init);\n+      else if (useless_type_conversion_p (TREE_TYPE (next),\n+\t\t\t\t\t  TREE_TYPE (init)))\n+\tnew_init = make_temp_ssa_name (TREE_TYPE (next), NULL,\n+\t\t\t\t       \"unrinittmp\");\n+      else\n+\tnew_init = make_temp_ssa_name (TREE_TYPE (init), NULL,\n+\t\t\t\t       \"unrinittmp\");\n+\n+      gphi * newphi = create_phi_node (new_init, rest);\n+      add_phi_arg (newphi, init, skip_first, UNKNOWN_LOCATION);\n+      add_phi_arg (newphi, next, new_e, UNKNOWN_LOCATION);\n+      SET_USE (op, new_init);\n+    }\n+}\n+\n+/* The two loops LOOP1 and LOOP2 were just created by loop versioning,\n+   they are still equivalent and placed in two arms of a diamond, like so:\n+\n+               .------if (cond)------.\n+               v                     v\n+             pre1                   pre2\n+              |                      |\n+        .--->h1                     h2<----.\n+        |     |                      |     |\n+        |    ex1---.            .---ex2    |\n+        |    /     |            |     \\    |\n+        '---l1     X            |     l2---'\n+                   |            |\n+                   |            |\n+                   '--->join<---'\n+\n+   This function transforms the program such that LOOP1 is conditionally\n+   falling through to LOOP2, or skipping it.  This is done by splitting\n+   the ex1->join edge at X in the diagram above, and inserting a condition\n+   whose one arm goes to pre2, resulting in this situation:\n+   \n+               .------if (cond)------.\n+               v                     v\n+             pre1       .---------->pre2\n+              |         |            |\n+        .--->h1         |           h2<----.\n+        |     |         |            |     |\n+        |    ex1---.    |       .---ex2    |\n+        |    /     v    |       |     \\    |\n+        '---l1   skip---'       |     l2---'\n+                   |            |\n+                   |            |\n+                   '--->join<---'\n+\n+   \n+   The condition used is the exit condition of LOOP1, which effectively means\n+   that when the first loop exits (for whatever reason) but the real original\n+   exit expression is still false the second loop will be entered.\n+   The function returns the new edge cond->pre2.\n+   \n+   This doesn't update the SSA form, see connect_loop_phis for that.  */\n+\n+static edge\n+connect_loops (struct loop *loop1, struct loop *loop2)\n+{\n+  edge exit = single_exit (loop1);\n+  basic_block skip_bb = split_edge (exit);\n+  gcond *skip_stmt;\n+  gimple_stmt_iterator gsi;\n+  edge new_e, skip_e;\n+\n+  gimple *stmt = last_stmt (exit->src);\n+  skip_stmt = gimple_build_cond (gimple_cond_code (stmt),\n+\t\t\t\t gimple_cond_lhs (stmt),\n+\t\t\t\t gimple_cond_rhs (stmt),\n+\t\t\t\t NULL_TREE, NULL_TREE);\n+  gsi = gsi_last_bb (skip_bb);\n+  gsi_insert_after (&gsi, skip_stmt, GSI_NEW_STMT);\n+\n+  skip_e = EDGE_SUCC (skip_bb, 0);\n+  skip_e->flags &= ~EDGE_FALLTHRU;\n+  new_e = make_edge (skip_bb, loop_preheader_edge (loop2)->src, 0);\n+  if (exit->flags & EDGE_TRUE_VALUE)\n+    {\n+      skip_e->flags |= EDGE_TRUE_VALUE;\n+      new_e->flags |= EDGE_FALSE_VALUE;\n+    }\n+  else\n+    {\n+      skip_e->flags |= EDGE_FALSE_VALUE;\n+      new_e->flags |= EDGE_TRUE_VALUE;\n+    }\n+\n+  new_e->count = skip_bb->count;\n+  new_e->probability = PROB_LIKELY;\n+  new_e->count = apply_probability (skip_e->count, PROB_LIKELY);\n+  skip_e->count -= new_e->count;\n+  skip_e->probability = inverse_probability (PROB_LIKELY);\n+\n+  return new_e;\n+}\n+\n+/* This returns the new bound for iterations given the original iteration\n+   space in NITER, an arbitrary new bound BORDER, assumed to be some\n+   comparison value with a different IV, the initial value GUARD_INIT of\n+   that other IV, and the comparison code GUARD_CODE that compares\n+   that other IV with BORDER.  We return an SSA name, and place any\n+   necessary statements for that computation into *STMTS.\n+\n+   For example for such a loop:\n+\n+     for (i = beg, j = guard_init; i < end; i++, j++)\n+       if (j < border)  // this is supposed to be true/false\n+         ...\n+\n+   we want to return a new bound (on j) that makes the loop iterate\n+   as long as the condition j < border stays true.  We also don't want\n+   to iterate more often than the original loop, so we have to introduce\n+   some cut-off as well (via min/max), effectively resulting in:\n+\n+     newend = min (end+guard_init-beg, border)\n+     for (i = beg; j = guard_init; j < newend; i++, j++)\n+       if (j < c)\n+         ...\n+\n+   Depending on the direction of the IVs and if the exit tests\n+   are strict or non-strict we need to use MIN or MAX,\n+   and add or subtract 1.  This routine computes newend above.  */\n+\n+static tree\n+compute_new_first_bound (gimple_seq *stmts, struct tree_niter_desc *niter,\n+\t\t\t tree border,\n+\t\t\t enum tree_code guard_code, tree guard_init)\n+{\n+  /* The niter structure contains the after-increment IV, we need\n+     the loop-enter base, so subtract STEP once.  */\n+  tree controlbase = force_gimple_operand (niter->control.base,\n+\t\t\t\t\t   stmts, true, NULL_TREE);\n+  tree controlstep = niter->control.step;\n+  tree enddiff;\n+  if (POINTER_TYPE_P (TREE_TYPE (controlbase)))\n+    {\n+      controlstep = gimple_build (stmts, NEGATE_EXPR,\n+\t\t\t\t  TREE_TYPE (controlstep), controlstep);\n+      enddiff = gimple_build (stmts, POINTER_PLUS_EXPR,\n+\t\t\t      TREE_TYPE (controlbase),\n+\t\t\t      controlbase, controlstep);\n+    }\n+  else\n+    enddiff = gimple_build (stmts, MINUS_EXPR,\n+\t\t\t    TREE_TYPE (controlbase),\n+\t\t\t    controlbase, controlstep);\n+\n+  /* Compute beg-guard_init.  */\n+  if (POINTER_TYPE_P (TREE_TYPE (enddiff)))\n+    {\n+      tree tem = gimple_convert (stmts, sizetype, guard_init);\n+      tem = gimple_build (stmts, NEGATE_EXPR, sizetype, tem);\n+      enddiff = gimple_build (stmts, POINTER_PLUS_EXPR,\n+\t\t\t      TREE_TYPE (enddiff),\n+\t\t\t      enddiff, tem);\n+    }\n+  else\n+    enddiff = gimple_build (stmts, MINUS_EXPR, TREE_TYPE (enddiff),\n+\t\t\t    enddiff, guard_init);\n+\n+  /* Compute end-(beg-guard_init).  */\n+  gimple_seq stmts2;\n+  tree newbound = force_gimple_operand (niter->bound, &stmts2,\n+\t\t\t\t\ttrue, NULL_TREE);\n+  gimple_seq_add_seq_without_update (stmts, stmts2);\n+\n+  if (POINTER_TYPE_P (TREE_TYPE (enddiff))\n+      || POINTER_TYPE_P (TREE_TYPE (newbound)))\n+    {\n+      enddiff = gimple_convert (stmts, sizetype, enddiff);\n+      enddiff = gimple_build (stmts, NEGATE_EXPR, sizetype, enddiff);\n+      newbound = gimple_build (stmts, POINTER_PLUS_EXPR,\n+\t\t\t       TREE_TYPE (newbound),\n+\t\t\t       newbound, enddiff);\n+    }\n+  else\n+    newbound = gimple_build (stmts, MINUS_EXPR, TREE_TYPE (enddiff),\n+\t\t\t     newbound, enddiff);\n+\n+  /* Depending on the direction of the IVs the new bound for the first\n+     loop is the minimum or maximum of old bound and border.\n+     Also, if the guard condition isn't strictly less or greater,\n+     we need to adjust the bound.  */ \n+  int addbound = 0;\n+  enum tree_code minmax;\n+  if (niter->cmp == LT_EXPR)\n+    {\n+      /* GT and LE are the same, inverted.  */\n+      if (guard_code == GT_EXPR || guard_code == LE_EXPR)\n+\taddbound = -1;\n+      minmax = MIN_EXPR;\n+    }\n+  else\n+    {\n+      gcc_assert (niter->cmp == GT_EXPR);\n+      if (guard_code == GE_EXPR || guard_code == LT_EXPR)\n+\taddbound = 1;\n+      minmax = MAX_EXPR;\n+    }\n+\n+  if (addbound)\n+    {\n+      tree type2 = TREE_TYPE (newbound);\n+      if (POINTER_TYPE_P (type2))\n+\ttype2 = sizetype;\n+      newbound = gimple_build (stmts,\n+\t\t\t       POINTER_TYPE_P (TREE_TYPE (newbound))\n+\t\t\t       ? POINTER_PLUS_EXPR : PLUS_EXPR,\n+\t\t\t       TREE_TYPE (newbound),\n+\t\t\t       newbound,\n+\t\t\t       build_int_cst (type2, addbound));\n+    }\n+\n+  newbound = gimple_convert (stmts, TREE_TYPE (border), newbound);\n+  tree newend = gimple_build (stmts, minmax, TREE_TYPE (border),\n+\t\t\t      border, newbound);\n+  return newend;\n+}\n+\n+/* Checks if LOOP contains an conditional block whose condition\n+   depends on which side in the iteration space it is, and if so\n+   splits the iteration space into two loops.  Returns true if the\n+   loop was split.  NITER must contain the iteration descriptor for the\n+   single exit of LOOP.  */\n+\n+static bool\n+split_loop (struct loop *loop1, struct tree_niter_desc *niter)\n+{\n+  basic_block *bbs;\n+  unsigned i;\n+  bool changed = false;\n+  tree guard_iv;\n+  tree border;\n+  affine_iv iv;\n+\n+  bbs = get_loop_body (loop1);\n+\n+  /* Find a splitting opportunity.  */\n+  for (i = 0; i < loop1->num_nodes; i++)\n+    if ((guard_iv = split_at_bb_p (loop1, bbs[i], &border, &iv)))\n+      {\n+\t/* Handling opposite steps is not implemented yet.  Neither\n+\t   is handling different step sizes.  */\n+\tif ((tree_int_cst_sign_bit (iv.step)\n+\t     != tree_int_cst_sign_bit (niter->control.step))\n+\t    || !tree_int_cst_equal (iv.step, niter->control.step))\n+\t  continue;\n+\n+\t/* Find a loop PHI node that defines guard_iv directly,\n+\t   or create one doing that.  */\n+\tgphi *phi = find_or_create_guard_phi (loop1, guard_iv, &iv);\n+\tif (!phi)\n+\t  continue;\n+\tgcond *guard_stmt = as_a<gcond *> (last_stmt (bbs[i]));\n+\ttree guard_init = PHI_ARG_DEF_FROM_EDGE (phi,\n+\t\t\t\t\t\t loop_preheader_edge (loop1));\n+\tenum tree_code guard_code = gimple_cond_code (guard_stmt);\n+\n+\t/* Loop splitting is implemented by versioning the loop, placing\n+\t   the new loop after the old loop, make the first loop iterate\n+\t   as long as the conditional stays true (or false) and let the\n+\t   second (new) loop handle the rest of the iterations.\n+\n+\t   First we need to determine if the condition will start being true\n+\t   or false in the first loop.  */\n+\tbool initial_true;\n+\tswitch (guard_code)\n+\t  {\n+\t    case LT_EXPR:\n+\t    case LE_EXPR:\n+\t      initial_true = !tree_int_cst_sign_bit (iv.step);\n+\t      break;\n+\t    case GT_EXPR:\n+\t    case GE_EXPR:\n+\t      initial_true = tree_int_cst_sign_bit (iv.step);\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t  }\n+\n+\t/* Build a condition that will skip the first loop when the\n+\t   guard condition won't ever be true (or false).  */\n+\tgimple_seq stmts2;\n+\tborder = force_gimple_operand (border, &stmts2, true, NULL_TREE);\n+\tif (stmts2)\n+\t  gsi_insert_seq_on_edge_immediate (loop_preheader_edge (loop1),\n+\t\t\t\t\t    stmts2);\n+\ttree cond = build2 (guard_code, boolean_type_node, guard_init, border);\n+\tif (!initial_true)\n+\t  cond = fold_build1 (TRUTH_NOT_EXPR, boolean_type_node, cond); \n+\n+\t/* Now version the loop, placing loop2 after loop1 connecting\n+\t   them, and fix up SSA form for that.  */\n+\tinitialize_original_copy_tables ();\n+\tbasic_block cond_bb;\n+\tstruct loop *loop2 = loop_version (loop1, cond, &cond_bb,\n+\t\t\t\t\t   REG_BR_PROB_BASE, REG_BR_PROB_BASE,\n+\t\t\t\t\t   REG_BR_PROB_BASE, true);\n+\tgcc_assert (loop2);\n+\tupdate_ssa (TODO_update_ssa);\n+\n+\tedge new_e = connect_loops (loop1, loop2);\n+\tconnect_loop_phis (loop1, loop2, new_e);\n+\n+\t/* The iterations of the second loop is now already\n+\t   exactly those that the first loop didn't do, but the\n+\t   iteration space of the first loop is still the original one.\n+\t   Compute the new bound for the guarding IV and patch the\n+\t   loop exit to use it instead of original IV and bound.  */\n+\tgimple_seq stmts = NULL;\n+\ttree newend = compute_new_first_bound (&stmts, niter, border,\n+\t\t\t\t\t       guard_code, guard_init);\n+\tif (stmts)\n+\t  gsi_insert_seq_on_edge_immediate (loop_preheader_edge (loop1),\n+\t\t\t\t\t    stmts);\n+\ttree guard_next = PHI_ARG_DEF_FROM_EDGE (phi, loop_latch_edge (loop1));\n+\tpatch_loop_exit (loop1, guard_stmt, guard_next, newend, initial_true);\n+\n+\t/* Finally patch out the two copies of the condition to be always\n+\t   true/false (or opposite).  */\n+\tgcond *force_true = as_a<gcond *> (last_stmt (bbs[i]));\n+\tgcond *force_false = as_a<gcond *> (last_stmt (get_bb_copy (bbs[i])));\n+\tif (!initial_true)\n+\t  std::swap (force_true, force_false);\n+\tgimple_cond_make_true (force_true);\n+\tgimple_cond_make_false (force_false);\n+\tupdate_stmt (force_true);\n+\tupdate_stmt (force_false);\n+\n+\tfree_original_copy_tables ();\n+\n+\t/* We destroyed LCSSA form above.  Eventually we might be able\n+\t   to fix it on the fly, for now simply punt and use the helper.  */\n+\trewrite_into_loop_closed_ssa_1 (NULL, 0, SSA_OP_USE, loop1);\n+\n+\tchanged = true;\n+\tif (dump_file && (dump_flags & TDF_DETAILS))\n+\t  fprintf (dump_file, \";; Loop split.\\n\");\n+\n+\t/* Only deal with the first opportunity.  */\n+\tbreak;\n+      }\n+\n+  free (bbs);\n+  return changed;\n+}\n+\n+/* Main entry point.  Perform loop splitting on all suitable loops.  */\n+\n+static unsigned int\n+tree_ssa_split_loops (void)\n+{\n+  struct loop *loop;\n+  bool changed = false;\n+\n+  gcc_assert (scev_initialized_p ());\n+  FOR_EACH_LOOP (loop, 0)\n+    loop->aux = NULL;\n+\n+  /* Go through all loops starting from innermost.  */\n+  FOR_EACH_LOOP (loop, LI_FROM_INNERMOST)\n+    {\n+      struct tree_niter_desc niter;\n+      if (loop->aux)\n+\t{\n+\t  /* If any of our inner loops was split, don't split us,\n+\t     and mark our containing loop as having had splits as well.  */\n+\t  loop_outer (loop)->aux = loop;\n+\t  continue;\n+\t}\n+\n+      if (single_exit (loop)\n+\t  /* ??? We could handle non-empty latches when we split\n+\t     the latch edge (not the exit edge), and put the new\n+\t     exit condition in the new block.  OTOH this executes some\n+\t     code unconditionally that might have been skipped by the\n+\t     original exit before.  */\n+\t  && empty_block_p (loop->latch)\n+\t  && !optimize_loop_for_size_p (loop)\n+\t  && number_of_iterations_exit (loop, single_exit (loop), &niter,\n+\t\t\t\t\tfalse, true)\n+\t  && niter.cmp != ERROR_MARK\n+\t  /* We can't yet handle loops controlled by a != predicate.  */\n+\t  && niter.cmp != NE_EXPR)\n+\t{\n+\t  if (split_loop (loop, &niter))\n+\t    {\n+\t      /* Mark our containing loop as having had some split inner\n+\t         loops.  */\n+\t      loop_outer (loop)->aux = loop;\n+\t      changed = true;\n+\t    }\n+\t}\n+    }\n+\n+  FOR_EACH_LOOP (loop, 0)\n+    loop->aux = NULL;\n+\n+  if (changed)\n+    return TODO_cleanup_cfg;\n+  return 0;\n+}\n+\n+/* Loop splitting pass.  */\n+\n+namespace {\n+\n+const pass_data pass_data_loop_split =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"lsplit\", /* name */\n+  OPTGROUP_LOOP, /* optinfo_flags */\n+  TV_LOOP_SPLIT, /* tv_id */\n+  PROP_cfg, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_loop_split : public gimple_opt_pass\n+{\n+public:\n+  pass_loop_split (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_loop_split, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *) { return flag_split_loops != 0; }\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_loop_split\n+\n+unsigned int\n+pass_loop_split::execute (function *fun)\n+{\n+  if (number_of_loops (fun) <= 1)\n+    return 0;\n+\n+  return tree_ssa_split_loops ();\n+}\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_loop_split (gcc::context *ctxt)\n+{\n+  return new pass_loop_split (ctxt);\n+}"}]}