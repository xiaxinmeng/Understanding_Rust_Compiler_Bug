{"sha": "8734dfacbbd841ccf1fb9682a631896013442807", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODczNGRmYWNiYmQ4NDFjY2YxZmI5NjgyYTYzMTg5NjAxMzQ0MjgwNw==", "commit": {"author": {"name": "Wilco Dijkstra", "email": "wdijkstr@arm.com", "date": "2016-12-07T14:44:45Z"}, "committer": {"name": "Wilco Dijkstra", "email": "wilco@gcc.gnu.org", "date": "2016-12-07T14:44:45Z"}, "message": "Improve TI mode address offsets - these may either use LDP of 64-bit or LDR of 128-bit...\n\nImprove TI mode address offsets - these may either use LDP of 64-bit or\nLDR of 128-bit, so we need to use the correct intersection of offsets.\nWhen splitting a large offset into base and offset, use a signed 9-bit \nunscaled offset.\n\nRemove the Ump constraint on movti and movtf instructions as this blocks\nthe reload optimizer from merging address CSEs (is this supposed to work\nonly on 'm' constraints?).  The result is improved codesize, especially\nwrf and gamess in SPEC2006.\n\n    gcc/\n\t* config/aarch64/aarch64.md (movti_aarch64): Change Ump to m.\n\t(movtf_aarch64): Likewise.\n\t* config/aarch64/aarch64.c (aarch64_classify_address):\n\tUse correct intersection of offsets.\n\t(aarch64_legitimize_address_displacement): Use 9-bit signed offsets.\n\t(aarch64_legitimize_address): Use 9-bit signed offsets for TI/TF mode.\n\tUse 7-bit signed scaled mode for modes > 16 bytes.\n\nFrom-SVN: r243346", "tree": {"sha": "adf987aeed65942cde7f7134d237e7d4564799c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/adf987aeed65942cde7f7134d237e7d4564799c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8734dfacbbd841ccf1fb9682a631896013442807", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8734dfacbbd841ccf1fb9682a631896013442807", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8734dfacbbd841ccf1fb9682a631896013442807", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8734dfacbbd841ccf1fb9682a631896013442807/comments", "author": null, "committer": null, "parents": [{"sha": "da88ea0265af5c877429a0c096cfdc0d4b3fecaa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da88ea0265af5c877429a0c096cfdc0d4b3fecaa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da88ea0265af5c877429a0c096cfdc0d4b3fecaa"}], "stats": {"total": 46, "additions": 29, "deletions": 17}, "files": [{"sha": "c1b8784ce9d0639b9a11468fc31a905e6370fa8a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8734dfacbbd841ccf1fb9682a631896013442807/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8734dfacbbd841ccf1fb9682a631896013442807/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8734dfacbbd841ccf1fb9682a631896013442807", "patch": "@@ -1,3 +1,13 @@\n+2016-12-07  Wilco Dijkstra  <wdijkstr@arm.com>\n+\n+\t* config/aarch64/aarch64.md (movti_aarch64): Change Ump to m.\n+\t(movtf_aarch64): Likewise.\n+\t* config/aarch64/aarch64.c (aarch64_classify_address):\n+\tUse correct intersection of offsets.\n+\t(aarch64_legitimize_address_displacement): Use 9-bit signed offsets.\n+\t(aarch64_legitimize_address): Use 9-bit signed offsets for TI/TF mode.\n+\tUse 7-bit signed scaled mode for modes > 16 bytes.\n+\n 2016-12-07  James Greenhalgh  <james.greenhalgh@arm.com>\n \n \tPR rtl-optimization/78561"}, {"sha": "128f32bda238488d8ccac9d105802d9be69c48db", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8734dfacbbd841ccf1fb9682a631896013442807/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8734dfacbbd841ccf1fb9682a631896013442807/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=8734dfacbbd841ccf1fb9682a631896013442807", "patch": "@@ -4330,7 +4330,8 @@ aarch64_classify_address (struct aarch64_address_info *info,\n \t     instruction memory accesses.  */\n \t  if (mode == TImode || mode == TFmode)\n \t    return (aarch64_offset_7bit_signed_scaled_p (DImode, offset)\n-\t\t    && offset_9bit_signed_unscaled_p (mode, offset));\n+\t\t    && (offset_9bit_signed_unscaled_p (mode, offset)\n+\t\t\t|| offset_12bit_unsigned_scaled_p (mode, offset)));\n \n \t  /* A 7bit offset check because OImode will emit a ldp/stp\n \t     instruction (only big endian will get here).\n@@ -4534,18 +4535,19 @@ aarch64_legitimate_address_p (machine_mode mode, rtx x,\n /* Split an out-of-range address displacement into a base and offset.\n    Use 4KB range for 1- and 2-byte accesses and a 16KB range otherwise\n    to increase opportunities for sharing the base address of different sizes.\n-   For TI/TFmode and unaligned accesses use a 256-byte range.  */\n+   For unaligned accesses and TI/TF mode use the signed 9-bit range.  */\n static bool\n aarch64_legitimize_address_displacement (rtx *disp, rtx *off, machine_mode mode)\n {\n-  HOST_WIDE_INT mask = GET_MODE_SIZE (mode) < 4 ? 0xfff : 0x3fff;\n+  HOST_WIDE_INT offset = INTVAL (*disp);\n+  HOST_WIDE_INT base = offset & ~(GET_MODE_SIZE (mode) < 4 ? 0xfff : 0x3ffc);\n \n-  if (mode == TImode || mode == TFmode ||\n-      (INTVAL (*disp) & (GET_MODE_SIZE (mode) - 1)) != 0)\n-    mask = 0xff;\n+  if (mode == TImode || mode == TFmode\n+      || (offset & (GET_MODE_SIZE (mode) - 1)) != 0)\n+    base = (offset + 0x100) & ~0x1ff;\n \n-  *off = GEN_INT (INTVAL (*disp) & ~mask);\n-  *disp = GEN_INT (INTVAL (*disp) & mask);\n+  *off = GEN_INT (base);\n+  *disp = GEN_INT (offset - base);\n   return true;\n }\n \n@@ -5412,12 +5414,10 @@ aarch64_legitimize_address (rtx x, rtx /* orig_x  */, machine_mode mode)\n \t  x = gen_rtx_PLUS (Pmode, base, offset_rtx);\n \t}\n \n-      /* Does it look like we'll need a load/store-pair operation?  */\n+      /* Does it look like we'll need a 16-byte load/store-pair operation?  */\n       HOST_WIDE_INT base_offset;\n-      if (GET_MODE_SIZE (mode) > 16\n-\t  || mode == TImode)\n-\tbase_offset = ((offset + 64 * GET_MODE_SIZE (mode))\n-\t\t       & ~((128 * GET_MODE_SIZE (mode)) - 1));\n+      if (GET_MODE_SIZE (mode) > 16)\n+\tbase_offset = (offset + 0x400) & ~0x7f0;\n       /* For offsets aren't a multiple of the access size, the limit is\n \t -256...255.  */\n       else if (offset & (GET_MODE_SIZE (mode) - 1))\n@@ -5431,6 +5431,8 @@ aarch64_legitimize_address (rtx x, rtx /* orig_x  */, machine_mode mode)\n       /* Small negative offsets are supported.  */\n       else if (IN_RANGE (offset, -256, 0))\n \tbase_offset = 0;\n+      else if (mode == TImode || mode == TFmode)\n+\tbase_offset = (offset + 0x100) & ~0x1ff;\n       /* Use 12-bit offset by access size.  */\n       else\n \tbase_offset = offset & (~0xfff * GET_MODE_SIZE (mode));"}, {"sha": "811a0785e7df1b89bde785f1541e73842b38ee6c", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8734dfacbbd841ccf1fb9682a631896013442807/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8734dfacbbd841ccf1fb9682a631896013442807/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=8734dfacbbd841ccf1fb9682a631896013442807", "patch": "@@ -1120,9 +1120,9 @@\n \n (define_insn \"*movti_aarch64\"\n   [(set (match_operand:TI 0\n-\t \"nonimmediate_operand\"  \"=r, *w,r ,*w,r  ,Ump,Ump,*w,m\")\n+\t \"nonimmediate_operand\"  \"=r, *w,r ,*w,r,m,m,*w,m\")\n \t(match_operand:TI 1\n-\t \"aarch64_movti_operand\" \" rn,r ,*w,*w,Ump,r  ,Z  , m,*w\"))]\n+\t \"aarch64_movti_operand\" \" rn,r ,*w,*w,m,r,Z, m,*w\"))]\n   \"(register_operand (operands[0], TImode)\n     || aarch64_reg_or_zero (operands[1], TImode))\"\n   \"@\n@@ -1237,9 +1237,9 @@\n \n (define_insn \"*movtf_aarch64\"\n   [(set (match_operand:TF 0\n-\t \"nonimmediate_operand\" \"=w,?&r,w ,?r,w,?w,w,m,?r ,Ump,Ump\")\n+\t \"nonimmediate_operand\" \"=w,?&r,w ,?r,w,?w,w,m,?r,m ,m\")\n \t(match_operand:TF 1\n-\t \"general_operand\"      \" w,?r, ?r,w ,Y,Y ,m,w,Ump,?r ,Y\"))]\n+\t \"general_operand\"      \" w,?r, ?r,w ,Y,Y ,m,w,m ,?r,Y\"))]\n   \"TARGET_FLOAT && (register_operand (operands[0], TFmode)\n     || aarch64_reg_or_fp_zero (operands[1], TFmode))\"\n   \"@"}]}