{"sha": "fb607032b8009d141409b8dc3c5e4df42c93a231", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmI2MDcwMzJiODAwOWQxNDE0MDliOGRjM2M1ZTRkZjQyYzkzYTIzMQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2017-12-01T13:33:40Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2017-12-01T13:33:40Z"}, "message": "re PR tree-optimization/83232 (fma3d spec2000 regression on zen with -Ofast (generic tuning) after r255268 by missed SLP oppurtunity)\n\n2017-12-01  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/83232\n\t* tree-vect-data-refs.c (vect_analyze_data_ref_accesses): Fix\n\tdetection of same access. Instead of breaking the group here\n\tdo not consider the duplicate.  Add comment explaining real fix.\n\n\t* gfortran.dg/vect/pr83232.f90: New testcase.\n\nFrom-SVN: r255307", "tree": {"sha": "57a7118f898507f4361145e0aa9875bb0e7c7f81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57a7118f898507f4361145e0aa9875bb0e7c7f81"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fb607032b8009d141409b8dc3c5e4df42c93a231", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb607032b8009d141409b8dc3c5e4df42c93a231", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb607032b8009d141409b8dc3c5e4df42c93a231", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb607032b8009d141409b8dc3c5e4df42c93a231/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d5f9df6a08d8f41fb7f77d588a63d6fecf2429d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5f9df6a08d8f41fb7f77d588a63d6fecf2429d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5f9df6a08d8f41fb7f77d588a63d6fecf2429d7"}], "stats": {"total": 74, "additions": 65, "deletions": 9}, "files": [{"sha": "0213e8b092953e0a6ddd7239d4ac519628e8a74b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb607032b8009d141409b8dc3c5e4df42c93a231/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb607032b8009d141409b8dc3c5e4df42c93a231/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fb607032b8009d141409b8dc3c5e4df42c93a231", "patch": "@@ -1,3 +1,10 @@\n+2017-12-01  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/83232\n+\t* tree-vect-data-refs.c (vect_analyze_data_ref_accesses): Fix\n+\tdetection of same access. Instead of breaking the group here\n+\tdo not consider the duplicate.  Add comment explaining real fix.\n+\n 2017-12-01  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* doc/md.texi (Insn Splitting): Fix \"central flowgraph\" typo."}, {"sha": "245ab25ac10881003d24d7c7462e642acb60abb3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb607032b8009d141409b8dc3c5e4df42c93a231/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb607032b8009d141409b8dc3c5e4df42c93a231/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fb607032b8009d141409b8dc3c5e4df42c93a231", "patch": "@@ -1,3 +1,8 @@\n+2017-12-01  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/83232\n+\t* gfortran.dg/vect/pr83232.f90: New testcase.\n+\n 2017-12-01  Sudakshina Das  <sudi.das@arm.com>\n \n \t* gcc.target/arm/armv8_2-fp16-move-2.c: New test."}, {"sha": "8fd9f0373ebe2e33a8c81c206d736ea1e8db45de", "filename": "gcc/testsuite/gfortran.dg/vect/pr83232.f90", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb607032b8009d141409b8dc3c5e4df42c93a231/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fpr83232.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb607032b8009d141409b8dc3c5e4df42c93a231/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fpr83232.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fpr83232.f90?ref=fb607032b8009d141409b8dc3c5e4df42c93a231", "patch": "@@ -0,0 +1,33 @@\n+! { dg-do compile }\n+! { dg-require-effective-target vect_double }\n+! { dg-additional-options \"-funroll-loops --param vect-max-peeling-for-alignment=0 -fdump-tree-slp-details\" }\n+\n+      SUBROUTINE MATERIAL_41_INTEGRATION ( STRESS,YLDC,EFPS,                   &\n+     &  DTnext,Dxx,Dyy,Dzz,Dxy,Dxz,Dyz,MatID,P1,P3 )\n+      REAL(KIND(0D0)), INTENT(INOUT) :: STRESS(6)\n+      REAL(KIND(0D0)), INTENT(IN)    :: DTnext\n+      REAL(KIND(0D0)), INTENT(IN)    :: Dxx,Dyy,Dzz,Dxy,Dxz,Dyz\n+      REAL(KIND(0D0)) :: Einc(6)\n+      REAL(KIND(0D0)) :: P1,P3\n+\n+      Einc(1) = DTnext * Dxx ! (1)\n+      Einc(2) = DTnext * Dyy\n+      Einc(3) = DTnext * Dzz\n+      Einc(4) = DTnext * Dxy\n+      Einc(5) = DTnext * Dxz\n+      Einc(6) = DTnext * Dyz\n+      DO i = 1,6\n+        STRESS(i) = STRESS(i) + P3*Einc(i)\n+      ENDDO\n+      STRESS(1) = STRESS(1) + (DTnext * P1 * (Dxx+Dyy+Dzz)) ! (2)\n+      STRESS(2) = STRESS(2) + (DTnext * P1 * (Dxx+Dyy+Dzz))\n+      STRESS(3) = 0.0\n+      Einc(5) = 0.0  ! (3)\n+      Einc(6) = 0.0\n+      call foo (Einc)\n+      END SUBROUTINE\n+\n+! We should vectorize (1) and (2)\n+! { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"slp1\" } }\n+! We fail to vectorize at (3), this can be fixed in the future\n+! { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 3 \"slp1\" { xfail *-*-* } } }"}, {"sha": "996d156a239a34234e22dd9d148c309a85a3458e", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb607032b8009d141409b8dc3c5e4df42c93a231/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb607032b8009d141409b8dc3c5e4df42c93a231/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=fb607032b8009d141409b8dc3c5e4df42c93a231", "patch": "@@ -2841,10 +2841,6 @@ vect_analyze_data_ref_accesses (vec_info *vinfo)\n \t  if (data_ref_compare_tree (DR_STEP (dra), DR_STEP (drb)) != 0)\n \t    break;\n \n-\t  /* Do not place the same access in the interleaving chain twice.  */\n-\t  if (tree_int_cst_compare (DR_INIT (dra), DR_INIT (drb)) == 0)\n-\t    break;\n-\n \t  /* Check the types are compatible.\n \t     ???  We don't distinguish this during sorting.  */\n \t  if (!types_compatible_p (TREE_TYPE (DR_REF (dra)),\n@@ -2854,7 +2850,25 @@ vect_analyze_data_ref_accesses (vec_info *vinfo)\n \t  /* Sorting has ensured that DR_INIT (dra) <= DR_INIT (drb).  */\n \t  HOST_WIDE_INT init_a = TREE_INT_CST_LOW (DR_INIT (dra));\n \t  HOST_WIDE_INT init_b = TREE_INT_CST_LOW (DR_INIT (drb));\n-\t  gcc_assert (init_a <= init_b);\n+\t  HOST_WIDE_INT init_prev\n+\t    = TREE_INT_CST_LOW (DR_INIT (datarefs_copy[i-1]));\n+\t  gcc_assert (init_a <= init_b\n+\t\t      && init_a <= init_prev\n+\t\t      && init_prev <= init_b);\n+\n+\t  /* Do not place the same access in the interleaving chain twice.  */\n+\t  if (init_b == init_prev)\n+\t    {\n+\t      gcc_assert (gimple_uid (DR_STMT (datarefs_copy[i-1]))\n+\t\t\t  < gimple_uid (DR_STMT (drb)));\n+\t      /* ???  For now we simply \"drop\" the later reference which is\n+\t         otherwise the same rather than finishing off this group.\n+\t\t In the end we'd want to re-process duplicates forming\n+\t\t multiple groups from the refs, likely by just collecting\n+\t\t all candidates (including duplicates and split points\n+\t\t below) in a vector and then process them together.  */\n+\t      continue;\n+\t    }\n \n \t  /* If init_b == init_a + the size of the type * k, we have an\n \t     interleaving, and DRA is accessed before DRB.  */\n@@ -2866,10 +2880,7 @@ vect_analyze_data_ref_accesses (vec_info *vinfo)\n \t  /* If we have a store, the accesses are adjacent.  This splits\n \t     groups into chunks we support (we don't support vectorization\n \t     of stores with gaps).  */\n-\t  if (!DR_IS_READ (dra)\n-\t      && (init_b - (HOST_WIDE_INT) TREE_INT_CST_LOW\n-\t\t\t\t\t     (DR_INIT (datarefs_copy[i-1]))\n-\t\t  != type_size_a))\n+\t  if (!DR_IS_READ (dra) && init_b - init_prev != type_size_a)\n \t    break;\n \n \t  /* If the step (if not zero or non-constant) is greater than the"}]}