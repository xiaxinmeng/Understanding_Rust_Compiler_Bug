{"sha": "8ba464346aca59a32206a53da84d3909265efab4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGJhNDY0MzQ2YWNhNTlhMzIyMDZhNTNkYTg0ZDM5MDkyNjVlZmFiNA==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "joern.rennecke@superh.com", "date": "2002-08-13T13:50:22Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2002-08-13T13:50:22Z"}, "message": "gcse.c (adjust_libcall_notes): New function.\n\n\t* gcse.c (adjust_libcall_notes): New function.\n\t(do_local_cprop): Use it.  Add fourth parameter.  Changed caller.\n\nFrom-SVN: r56252", "tree": {"sha": "6a9671186c94a6ddb9ff4cd08ace96f04bdd19a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6a9671186c94a6ddb9ff4cd08ace96f04bdd19a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ba464346aca59a32206a53da84d3909265efab4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ba464346aca59a32206a53da84d3909265efab4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ba464346aca59a32206a53da84d3909265efab4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ba464346aca59a32206a53da84d3909265efab4/comments", "author": null, "committer": null, "parents": [{"sha": "4320085abdc32252f24606d578ed5a14110f1414", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4320085abdc32252f24606d578ed5a14110f1414", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4320085abdc32252f24606d578ed5a14110f1414"}], "stats": {"total": 83, "additions": 77, "deletions": 6}, "files": [{"sha": "349fc3de87cc815e6dea0484de2dc976b08eb717", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ba464346aca59a32206a53da84d3909265efab4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ba464346aca59a32206a53da84d3909265efab4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8ba464346aca59a32206a53da84d3909265efab4", "patch": "@@ -1,3 +1,8 @@\n+Tue Aug 13 14:49:20 2002  J\"orn Rennecke <joern.rennecke@superh.com>\n+\n+\t* gcse.c (adjust_libcall_notes): New function.\n+\t(do_local_cprop): Use it.  Add fourth parameter.  Changed caller.\n+\n 2002-08-13  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* libgcc2.c (L_bb): Remove unneeded #includes."}, {"sha": "2af1122282abb3a29d8414e8ab1252257e0dfbec", "filename": "gcc/gcse.c", "status": "modified", "additions": 72, "deletions": 6, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ba464346aca59a32206a53da84d3909265efab4/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ba464346aca59a32206a53da84d3909265efab4/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=8ba464346aca59a32206a53da84d3909265efab4", "patch": "@@ -699,7 +699,8 @@ static void free_insn_expr_list_list\tPARAMS ((rtx *));\n static void clear_modify_mem_tables\tPARAMS ((void));\n static void free_modify_mem_tables\tPARAMS ((void));\n static rtx gcse_emit_move_after\t\tPARAMS ((rtx, rtx, rtx));\n-static bool do_local_cprop\t\tPARAMS ((rtx, rtx, int));\n+static bool do_local_cprop\t\tPARAMS ((rtx, rtx, int, rtx*));\n+static bool adjust_libcall_notes\tPARAMS ((rtx, rtx, rtx, rtx*));\n static void local_cprop_pass\t\tPARAMS ((int));\n \f\n /* Entry point for global common subexpression elimination.\n@@ -4241,16 +4242,18 @@ cprop_insn (insn, alter_jumps)\n   return changed;\n }\n \n+/* LIBCALL_SP is a zero-terminated array of insns at the end of a libcall;\n+   their REG_EQUAL notes need updating.  */\n static bool\n-do_local_cprop (x, insn, alter_jumps)\n+do_local_cprop (x, insn, alter_jumps, libcall_sp)\n      rtx x;\n      rtx insn;\n      int alter_jumps;\n+     rtx *libcall_sp;\n {\n   rtx newreg = NULL, newcnst = NULL;\n \n-  /* Rule out USE instructions and ASM statements as we don't want to change the hard\n-     registers mentioned.  */\n+  /* Rule out USE instructions and ASM statements as we don't want to change the hard registers mentioned.  */\n   if (GET_CODE (x) == REG\n       && (REGNO (x) >= FIRST_PSEUDO_REGISTER\n           || (GET_CODE (PATTERN (insn)) != USE && asm_noperands (PATTERN (insn)) < 0)))\n@@ -4279,6 +4282,13 @@ do_local_cprop (x, insn, alter_jumps)\n \t}\n       if (newcnst && constprop_register (insn, x, newcnst, alter_jumps))\n \t{\n+\t  /* If we find a case where we can't fix the retval REG_EQUAL notes\n+\t     match the new register, we either have to abandom this replacement\n+\t     or fix delete_trivially_dead_insns to preserve the setting insn,\n+\t     or make it delete the REG_EUAQL note, and fix up all passes that\n+\t     require the REG_EQUAL note there.  */\n+\t  if (!adjust_libcall_notes (x, newcnst, insn, libcall_sp))\n+\t    abort ();\n \t  if (gcse_file != NULL)\n \t    {\n \t      fprintf (gcse_file, \"LOCAL CONST-PROP: Replacing reg %d in \",\n@@ -4293,6 +4303,7 @@ do_local_cprop (x, insn, alter_jumps)\n \t}\n       else if (newreg && newreg != x && try_replace_reg (x, newreg, insn))\n \t{\n+\t  adjust_libcall_notes (x, newreg, insn, libcall_sp);\n \t  if (gcse_file != NULL)\n \t    {\n \t      fprintf (gcse_file,\n@@ -4307,20 +4318,74 @@ do_local_cprop (x, insn, alter_jumps)\n   return false;\n }\n \n+/* LIBCALL_SP is a zero-terminated array of insns at the end of a libcall;\n+   their REG_EQUAL notes need updating to reflect that OLDREG has been\n+   replaced with NEWVAL in INSN.  Return true if all substitutions could\n+   be made.  */\n+static bool\n+adjust_libcall_notes (oldreg, newval, insn, libcall_sp)\n+     rtx oldreg, newval, insn, *libcall_sp;\n+{\n+  rtx end;\n+\n+  while ((end = *libcall_sp++))\n+    {\n+      rtx note = find_reg_equal_equiv_note (end);\n+\n+      if (! note)\n+\tcontinue;\n+\n+      if (REG_P (newval))\n+\t{\n+\t  if (reg_set_between_p (newval, PREV_INSN (insn), end))\n+\t    {\n+\t      do\n+\t\t{\n+\t\t  note = find_reg_equal_equiv_note (end);\n+\t\t  if (! note)\n+\t\t    continue;\n+\t\t  if (reg_mentioned_p (newval, XEXP (note, 0)))\n+\t\t    return false;\n+\t\t}\n+\t      while ((end = *libcall_sp++));\n+\t      return true;\n+\t    }\n+\t}\n+      XEXP (note, 0) = replace_rtx (XEXP (note, 0), oldreg, newval);\n+      insn = end;\n+    }\n+  return true;\n+}\n+\n+#define MAX_NESTED_LIBCALLS 9\n+\n static void\n local_cprop_pass (alter_jumps)\n      int alter_jumps;\n {\n   rtx insn;\n   struct reg_use *reg_used;\n+  rtx libcall_stack[MAX_NESTED_LIBCALLS + 1], *libcall_sp;\n \n   cselib_init ();\n+  libcall_sp = &libcall_stack[MAX_NESTED_LIBCALLS];\n+  *libcall_sp = 0;\n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n       if (INSN_P (insn))\n \t{\n-\t  rtx note = find_reg_equal_equiv_note (insn);\n+\t  rtx note = find_reg_note (insn, REG_LIBCALL, NULL_RTX);\n \n+\t  if (note)\n+\t    {\n+\t      if (libcall_sp == libcall_stack)\n+\t\tabort ();\n+\t      *--libcall_sp = XEXP (note, 0);\n+\t    }\n+\t  note = find_reg_note (insn, REG_RETVAL, NULL_RTX);\n+\t  if (note)\n+\t    libcall_sp++;\n+\t  note = find_reg_equal_equiv_note (insn);\n \t  do\n \t    {\n \t      reg_use_count = 0;\n@@ -4330,7 +4395,8 @@ local_cprop_pass (alter_jumps)\n \n \t      for (reg_used = &reg_use_table[0]; reg_use_count > 0;\n \t\t   reg_used++, reg_use_count--)\n-\t\tif (do_local_cprop (reg_used->reg_rtx, insn, alter_jumps))\n+\t\tif (do_local_cprop (reg_used->reg_rtx, insn, alter_jumps,\n+\t\t    libcall_sp))\n \t\t  break;\n \t    }\n \t  while (reg_use_count);"}]}