{"sha": "62c6e26e3326d13b47fba3b4375b261a8431d422", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjJjNmUyNmUzMzI2ZDEzYjQ3ZmJhM2I0Mzc1YjI2MWE4NDMxZDQyMg==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2013-12-13T16:34:39Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2013-12-13T16:34:39Z"}, "message": "re PR tree-optimization/45685 (missed conditional move opportunity in loop)\n\n\tPR tree-optimization/45685\n\t* tree-ssa-phiopt.c (neg_replacement): New function.\n\t(tree_ssa_phiopt_worker): Call it.\n\n\tPR tree-optimization/45685\n\t* gcc.dg/tree-ssa/pr45685.c: New test.\n\nFrom-SVN: r205963", "tree": {"sha": "73aedaaa5e23c1bfcf30818f587c63183516efb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/73aedaaa5e23c1bfcf30818f587c63183516efb3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/62c6e26e3326d13b47fba3b4375b261a8431d422", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62c6e26e3326d13b47fba3b4375b261a8431d422", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62c6e26e3326d13b47fba3b4375b261a8431d422", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62c6e26e3326d13b47fba3b4375b261a8431d422/comments", "author": null, "committer": null, "parents": [{"sha": "b0d97c338781ef524f1dbc44c4dffbe4b707ac19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0d97c338781ef524f1dbc44c4dffbe4b707ac19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0d97c338781ef524f1dbc44c4dffbe4b707ac19"}], "stats": {"total": 211, "additions": 211, "deletions": 0}, "files": [{"sha": "3ee682bbe231dbc71f0a71beb075546affd3b3cd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62c6e26e3326d13b47fba3b4375b261a8431d422/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62c6e26e3326d13b47fba3b4375b261a8431d422/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=62c6e26e3326d13b47fba3b4375b261a8431d422", "patch": "@@ -1,3 +1,9 @@\n+2013-12-13  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/45685\n+\t* tree-ssa-phiopt.c (neg_replacement): New function.\n+\t(tree_ssa_phiopt_worker): Call it.\n+\n 2013-12-13  Yuri Rumyantsev  <ysrumyan@gmail.com>\n \n \t* config/i386/i386.c (slm_cost): Fix imul cost for HI."}, {"sha": "70b1bc475b522573c4cd8c974a5aadd4ee19ccf5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62c6e26e3326d13b47fba3b4375b261a8431d422/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62c6e26e3326d13b47fba3b4375b261a8431d422/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=62c6e26e3326d13b47fba3b4375b261a8431d422", "patch": "@@ -1,3 +1,8 @@\n+2013-12-03  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/45685\n+\t* gcc.dg/tree-ssa/pr45685.c: New test.\n+\n 2013-12-13  Bin Cheng  <bin.cheng@arm.com>\n \n \tPR tree-optimization/58296"}, {"sha": "06289430fa353b8957f452019e730bb3b2c45138", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr45685.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62c6e26e3326d13b47fba3b4375b261a8431d422/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr45685.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62c6e26e3326d13b47fba3b4375b261a8431d422/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr45685.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr45685.c?ref=62c6e26e3326d13b47fba3b4375b261a8431d422", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-phiopt1-details\" } */\n+\n+typedef unsigned long int uint64_t;\n+typedef long int int64_t;\n+int summation_helper_1(int64_t* products, uint64_t count)\n+{\n+\tint s = 0;\n+\tuint64_t i;\n+\tfor(i=0; i<count; i++)\n+\t{\t\n+\t\tint64_t val = (products[i]>0) ? 1 : -1;\n+\t\tproducts[i] *= val;\n+\t\tif(products[i] != i)\n+\t\t\tval = -val;\n+\t\tproducts[i] = val;\n+\t\ts += val;\n+\t}\n+\treturn s;\n+}\n+\n+\n+int summation_helper_2(int64_t* products, uint64_t count)\n+{\n+\tint s = 0;\n+\tuint64_t i;\n+\tfor(i=0; i<count; i++)\n+\t{\t\n+\t\tint val = (products[i]>0) ? 1 : -1;\n+\t\tproducts[i] *= val;\n+\t\tif(products[i] != i)\n+\t\t\tval = -val;\n+\t\tproducts[i] = val;\n+\t\ts += val;\n+\t}\n+\treturn s;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"converted to straightline code\" 2 \"phiopt1\" } } */\n+/* { dg-final { cleanup-tree-dump \"phiopt1\" } } */\n+"}, {"sha": "b6bb7e9d906707b781c712ff5e0aab53e06c693d", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62c6e26e3326d13b47fba3b4375b261a8431d422/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62c6e26e3326d13b47fba3b4375b261a8431d422/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=62c6e26e3326d13b47fba3b4375b261a8431d422", "patch": "@@ -69,6 +69,8 @@ static bool minmax_replacement (basic_block, basic_block,\n \t\t\t\tedge, edge, gimple, tree, tree);\n static bool abs_replacement (basic_block, basic_block,\n \t\t\t     edge, edge, gimple, tree, tree);\n+static bool neg_replacement (basic_block, basic_block,\n+\t\t\t     edge, edge, gimple, tree, tree);\n static bool cond_store_replacement (basic_block, basic_block, edge, edge,\n \t\t\t\t    struct pointer_set_t *);\n static bool cond_if_else_store_replacement (basic_block, basic_block, basic_block);\n@@ -336,6 +338,23 @@ tree_ssa_phiopt_worker (bool do_store_elim, bool do_hoist_loads)\n     /* Calculate the set of non-trapping memory accesses.  */\n     nontrap = get_non_trapping ();\n \n+  /* The replacement of conditional negation with a non-branching\n+     sequence is really only a win when optimizing for speed and we\n+     can avoid transformations by gimple if-conversion that result\n+     in poor RTL generation.\n+\n+     Ideally either gimple if-conversion or the RTL expanders will\n+     be improved and the code to emit branchless conditional negation\n+     can be removed.  */\n+  bool replace_conditional_negation = false;\n+  if (!do_store_elim)\n+    replace_conditional_negation\n+      = ((!optimize_size && optimize >= 2)\n+\t || (((flag_tree_loop_vectorize || cfun->has_force_vect_loops)\n+\t      && flag_tree_loop_if_convert != 0)\n+\t     || flag_tree_loop_if_convert == 1\n+\t     || flag_tree_loop_if_convert_stores == 1));\n+\n   /* Search every basic block for COND_EXPR we may be able to optimize.\n \n      We walk the blocks in order that guarantees that a block with\n@@ -489,6 +508,9 @@ tree_ssa_phiopt_worker (bool do_store_elim, bool do_hoist_loads)\n \t    cfgchanged = true;\n \t  else if (abs_replacement (bb, bb1, e1, e2, phi, arg0, arg1))\n \t    cfgchanged = true;\n+\t  else if (replace_conditional_negation\n+\t\t   && neg_replacement (bb, bb1, e1, e2, phi, arg0, arg1))\n+\t    cfgchanged = true;\n \t  else if (minmax_replacement (bb, bb1, e1, e2, phi, arg0, arg1))\n \t    cfgchanged = true;\n \t}\n@@ -1285,6 +1307,143 @@ abs_replacement (basic_block cond_bb, basic_block middle_bb,\n   return true;\n }\n \n+/*  The function neg_replacement replaces conditional negation with\n+    equivalent straight line code.  Returns TRUE if replacement is done,\n+    otherwise returns FALSE.\n+\n+    COND_BB branches around negation occuring in MIDDLE_BB.\n+\n+    E0 and E1 are edges out of COND_BB.  E0 reaches MIDDLE_BB and\n+    E1 reaches the other successor which should contain PHI with\n+    arguments ARG0 and ARG1.\n+\n+    Assuming negation is to occur when the condition is true,\n+    then the non-branching sequence is:\n+\n+       result = (rhs ^ -cond) + cond\n+\n+    Inverting the condition or its result gives us negation\n+    when the original condition is false.  */\n+\n+static bool\n+neg_replacement (basic_block cond_bb, basic_block middle_bb,\n+\t\t edge e0 ATTRIBUTE_UNUSED, edge e1,\n+\t\t gimple phi, tree arg0, tree arg1)\n+{\n+  gimple new_stmt, cond;\n+  gimple_stmt_iterator gsi;\n+  gimple assign;\n+  edge true_edge, false_edge;\n+  tree rhs, lhs;\n+  enum tree_code cond_code;\n+  bool invert = false;\n+\n+  /* This transformation performs logical operations on the\n+     incoming arguments.  So force them to be integral types.   */\n+  if (!INTEGRAL_TYPE_P (TREE_TYPE (arg0)))\n+    return false;\n+\n+  /* OTHER_BLOCK must have only one executable statement which must have the\n+     form arg0 = -arg1 or arg1 = -arg0.  */\n+\n+  assign = last_and_only_stmt (middle_bb);\n+  /* If we did not find the proper negation assignment, then we can not\n+     optimize.  */\n+  if (assign == NULL)\n+    return false;\n+\n+  /* If we got here, then we have found the only executable statement\n+     in OTHER_BLOCK.  If it is anything other than arg0 = -arg1 or\n+     arg1 = -arg0, then we can not optimize.  */\n+  if (gimple_code (assign) != GIMPLE_ASSIGN)\n+    return false;\n+\n+  lhs = gimple_assign_lhs (assign);\n+\n+  if (gimple_assign_rhs_code (assign) != NEGATE_EXPR)\n+    return false;\n+\n+  rhs = gimple_assign_rhs1 (assign);\n+\n+  /* The assignment has to be arg0 = -arg1 or arg1 = -arg0.  */\n+  if (!(lhs == arg0 && rhs == arg1)\n+      && !(lhs == arg1 && rhs == arg0))\n+    return false;\n+\n+  /* The basic sequence assumes we negate when the condition is true.\n+     If we need the opposite, then we will either need to invert the\n+     condition or its result.  */\n+  extract_true_false_edges_from_block (cond_bb, &true_edge, &false_edge);\n+  invert = false_edge->dest == middle_bb;\n+\n+  /* Unlike abs_replacement, we can handle arbitrary conditionals here.  */\n+  cond = last_stmt (cond_bb);\n+  cond_code = gimple_cond_code (cond);\n+\n+  /* If inversion is needed, first try to invert the test since\n+     that's cheapest.  */\n+  if (invert)\n+    {\n+      bool honor_nans\n+\t= HONOR_NANS (TYPE_MODE (TREE_TYPE (gimple_cond_lhs (cond))));\n+      enum tree_code new_code = invert_tree_comparison (cond_code, honor_nans);\n+\n+      /* If invert_tree_comparison was successful, then use its return\n+\t value as the new code and note that inversion is no longer\n+\t needed.  */\n+      if (new_code != ERROR_MARK)\n+\t{\n+\t  cond_code = new_code;\n+\t  invert = false;\n+\t}\n+    }\n+\n+  tree cond_val = make_ssa_name (boolean_type_node, NULL);\n+  new_stmt = gimple_build_assign_with_ops (cond_code, cond_val,\n+\t\t\t\t\t   gimple_cond_lhs (cond),\n+\t\t\t\t\t   gimple_cond_rhs (cond));\n+  gsi = gsi_last_bb (cond_bb);\n+  gsi_insert_before (&gsi, new_stmt, GSI_NEW_STMT);\n+\n+  /* If we still need inversion, then invert the result of the\n+     condition.  */\n+  if (invert)\n+    {\n+      tree tmp = make_ssa_name (boolean_type_node, NULL);\n+      new_stmt = gimple_build_assign_with_ops (BIT_XOR_EXPR, tmp,\n+\t\t\t\t\t       cond_val, boolean_true_node);\n+      gsi_insert_after (&gsi, new_stmt, GSI_NEW_STMT);\n+      cond_val = tmp;\n+    }\n+\n+  /* Get the condition in the right type so that we can perform\n+     logical and arithmetic operations on it.  */\n+  tree cond_val_converted = make_ssa_name (TREE_TYPE (rhs), NULL);\n+  new_stmt = gimple_build_assign_with_ops (NOP_EXPR, cond_val_converted,\n+\t\t\t\t\t   cond_val, NULL_TREE);\n+  gsi_insert_after (&gsi, new_stmt, GSI_NEW_STMT);\n+\n+  tree neg_cond_val_converted = make_ssa_name (TREE_TYPE (rhs), NULL);\n+  new_stmt = gimple_build_assign_with_ops (NEGATE_EXPR, neg_cond_val_converted,\n+\t\t\t\t\t   cond_val_converted, NULL_TREE);\n+  gsi_insert_after (&gsi, new_stmt, GSI_NEW_STMT);\n+\n+  tree tmp = make_ssa_name (TREE_TYPE (rhs), NULL);\n+  new_stmt = gimple_build_assign_with_ops (BIT_XOR_EXPR, tmp,\n+\t\t\t\t\t   rhs, neg_cond_val_converted);\n+  gsi_insert_after (&gsi, new_stmt, GSI_NEW_STMT);\n+\n+  tree new_lhs = make_ssa_name (TREE_TYPE (rhs), NULL);\n+  new_stmt = gimple_build_assign_with_ops (PLUS_EXPR, new_lhs,\n+\t\t\t\t\t   tmp, cond_val_converted);\n+  gsi_insert_after (&gsi, new_stmt, GSI_NEW_STMT);\n+\n+  replace_phi_edge_with_variable (cond_bb, e1, phi, new_lhs);\n+\n+  /* Note that we optimized this PHI.  */\n+  return true;\n+}\n+\n /* Auxiliary functions to determine the set of memory accesses which\n    can't trap because they are preceded by accesses to the same memory\n    portion.  We do that for MEM_REFs, so we only need to track"}]}