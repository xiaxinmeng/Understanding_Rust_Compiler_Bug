{"sha": "f35db108b96cac4fd3f2b62024ed93ac006ff932", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjM1ZGIxMDhiOTZjYWM0ZmQzZjJiNjIwMjRlZDkzYWMwMDZmZjkzMg==", "commit": {"author": {"name": "Wei Mi", "email": "wmi@google.com", "date": "2012-11-12T15:53:47Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2012-11-12T15:53:47Z"}, "message": "Import the asan runtime library into GCC tree\n\nThis patch imports the runtime library in the GCC tree, ensures that\n-lasan is passed to the linker when -faddress-sanitizer is used and\nsets up the build system accordingly.\n\nChangeLog:\n\n\t* configure.ac: Add libsanitizer to target_libraries.\n\t* Makefile.def: Ditto.\n\t* configure: Regenerate.\n\t* Makefile.in: Regenerate.\n\t* libsanitizer: New directory for asan runtime.  Contains an empty\n\ttsan directory.\n\ngcc/ChangeLog:\n\n\t* gcc.c (LINK_COMMAND_SPEC): Add -laddress-sanitizer to link\n\tcommand if -faddress-sanitizer is on.\n\nlibsanitizer:\n\n\tInitial checkin: migrate asan runtime from llvm.\n\nFrom-SVN: r193441", "tree": {"sha": "78af479c74cf29780202765e911b12f4bf192001", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78af479c74cf29780202765e911b12f4bf192001"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f35db108b96cac4fd3f2b62024ed93ac006ff932", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f35db108b96cac4fd3f2b62024ed93ac006ff932", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f35db108b96cac4fd3f2b62024ed93ac006ff932", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f35db108b96cac4fd3f2b62024ed93ac006ff932/comments", "author": {"login": "wmi-11", "id": 59629650, "node_id": "MDQ6VXNlcjU5NjI5NjUw", "avatar_url": "https://avatars.githubusercontent.com/u/59629650?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wmi-11", "html_url": "https://github.com/wmi-11", "followers_url": "https://api.github.com/users/wmi-11/followers", "following_url": "https://api.github.com/users/wmi-11/following{/other_user}", "gists_url": "https://api.github.com/users/wmi-11/gists{/gist_id}", "starred_url": "https://api.github.com/users/wmi-11/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wmi-11/subscriptions", "organizations_url": "https://api.github.com/users/wmi-11/orgs", "repos_url": "https://api.github.com/users/wmi-11/repos", "events_url": "https://api.github.com/users/wmi-11/events{/privacy}", "received_events_url": "https://api.github.com/users/wmi-11/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "25ae50273ad2801ecc262ba75fa8bac0c4e0001b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25ae50273ad2801ecc262ba75fa8bac0c4e0001b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25ae50273ad2801ecc262ba75fa8bac0c4e0001b"}], "stats": {"total": 56918, "additions": 56917, "deletions": 1}, "files": [{"sha": "74d6ee83eb52f79a22029a7b836fdc90acc3d7af", "filename": "ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -1,3 +1,12 @@\n+2012-11-12  Wei Mi <wmi@google.com>\n+\n+\t* configure.ac: Add libsanitizer to target_libraries.\n+\t* Makefile.def: Ditto.\n+\t* configure: Regenerate.\n+\t* Makefile.in: Regenerate.\n+\t* libsanitizer: New directory for asan runtime.  Contains an empty\n+\ttsan directory.\n+\n 2012-11-03  Corinna Vinschen  <corinna@vinschen.de>\n \n \t* configure.ac (FLAGS_FOR_TARGET,target=cygwin): Fix for building"}, {"sha": "5d265872e97b565ad3d7c4487b3436516706100f", "filename": "ChangeLog.asan", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/ChangeLog.asan", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/ChangeLog.asan", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog.asan?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,16 @@\n+2012-11-1  Wei Mi  <wmi@google.com>\n+\n+\t* configure.ac: Change target-libasan to target-libsanitizer.\n+\t* configure.in: Regenerate.\n+\t* Makefile.def: Change libasan module to libsanitizer.  \n+\t* Makefile.in: Regenerate.\n+\t* libsanitizer: Change libasan to libsanitizer and add\n+\tan empty tsan directory under libsanitizer. \n+\n+2012-10-29  Wei Mi  <wmi@google.com>\n+\n+\t* configure.ac: Add libasan to target_libraries\n+\t* Makefile.def: Ditto\n+\t* configure: Regenerate\n+\t* Makefile.in: Regenerate\n+\t* libasan: New directory for asan runtime"}, {"sha": "1ea63ac10f82768b550e76dc3e6864fa7b398ba1", "filename": "Makefile.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/Makefile.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/Makefile.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.def?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -119,6 +119,7 @@ target_modules = { module= libstdc++-v3;\n \t\t   lib_path=src/.libs;\n \t\t   raw_cxx=true; };\n target_modules = { module= libmudflap; lib_path=.libs; };\n+target_modules = { module= libsanitizer; lib_path=.libs; };\n target_modules = { module= libssp; lib_path=.libs; };\n target_modules = { module= newlib; };\n target_modules = { module= libgcc; bootstrap=true; no_check=true; };\n@@ -503,6 +504,7 @@ dependencies = { module=all-target-libjava; on=all-target-libffi; };\n dependencies = { module=configure-target-libobjc; on=configure-target-boehm-gc; };\n dependencies = { module=all-target-libobjc; on=all-target-boehm-gc; };\n dependencies = { module=configure-target-libstdc++-v3; on=configure-target-libgomp; };\n+dependencies = { module=configure-target-libsanitizer; on=all-target-libstdc++-v3; };\n // parallel_list.o and parallel_settings.o depend on omp.h, which is\n // generated by the libgomp configure.  Unfortunately, due to the use of\n //  recursive make, we can't be that specific."}, {"sha": "636b2ba18e9ca95fd20704c0f5152f141a3b89af", "filename": "Makefile.in", "status": "modified", "additions": 486, "deletions": 1, "changes": 487, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/Makefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/Makefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.in?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -575,7 +575,7 @@ all:\n \n # This is the list of directories that may be needed in RPATH_ENVVAR\n # so that programs built for the target machine work.\n-TARGET_LIB_PATH = $(TARGET_LIB_PATH_libstdc++-v3)$(TARGET_LIB_PATH_libmudflap)$(TARGET_LIB_PATH_libssp)$(TARGET_LIB_PATH_libgomp)$(TARGET_LIB_PATH_libitm)$(TARGET_LIB_PATH_libatomic)$(HOST_LIB_PATH_gcc)\n+TARGET_LIB_PATH = $(TARGET_LIB_PATH_libstdc++-v3)$(TARGET_LIB_PATH_libmudflap)$(TARGET_LIB_PATH_libsanitizer)$(TARGET_LIB_PATH_libssp)$(TARGET_LIB_PATH_libgomp)$(TARGET_LIB_PATH_libitm)$(TARGET_LIB_PATH_libatomic)$(HOST_LIB_PATH_gcc)\n \n @if target-libstdc++-v3\n TARGET_LIB_PATH_libstdc++-v3 = $$r/$(TARGET_SUBDIR)/libstdc++-v3/src/.libs:\n@@ -585,6 +585,10 @@ TARGET_LIB_PATH_libstdc++-v3 = $$r/$(TARGET_SUBDIR)/libstdc++-v3/src/.libs:\n TARGET_LIB_PATH_libmudflap = $$r/$(TARGET_SUBDIR)/libmudflap/.libs:\n @endif target-libmudflap\n \n+@if target-libsanitizer\n+TARGET_LIB_PATH_libsanitizer = $$r/$(TARGET_SUBDIR)/libsanitizer/.libs:\n+@endif target-libsanitizer\n+\n @if target-libssp\n TARGET_LIB_PATH_libssp = $$r/$(TARGET_SUBDIR)/libssp/.libs:\n @endif target-libssp\n@@ -920,6 +924,7 @@ configure-host:  \\\n configure-target:  \\\n     maybe-configure-target-libstdc++-v3 \\\n     maybe-configure-target-libmudflap \\\n+    maybe-configure-target-libsanitizer \\\n     maybe-configure-target-libssp \\\n     maybe-configure-target-newlib \\\n     maybe-configure-target-libgcc \\\n@@ -1068,6 +1073,7 @@ all-host: maybe-all-lto-plugin\n all-target: maybe-all-target-libstdc++-v3\n @endif target-libstdc++-v3-no-bootstrap\n all-target: maybe-all-target-libmudflap\n+all-target: maybe-all-target-libsanitizer\n all-target: maybe-all-target-libssp\n all-target: maybe-all-target-newlib\n @if target-libgcc-no-bootstrap\n@@ -1158,6 +1164,7 @@ info-host: maybe-info-lto-plugin\n \n info-target: maybe-info-target-libstdc++-v3\n info-target: maybe-info-target-libmudflap\n+info-target: maybe-info-target-libsanitizer\n info-target: maybe-info-target-libssp\n info-target: maybe-info-target-newlib\n info-target: maybe-info-target-libgcc\n@@ -1239,6 +1246,7 @@ dvi-host: maybe-dvi-lto-plugin\n \n dvi-target: maybe-dvi-target-libstdc++-v3\n dvi-target: maybe-dvi-target-libmudflap\n+dvi-target: maybe-dvi-target-libsanitizer\n dvi-target: maybe-dvi-target-libssp\n dvi-target: maybe-dvi-target-newlib\n dvi-target: maybe-dvi-target-libgcc\n@@ -1320,6 +1328,7 @@ pdf-host: maybe-pdf-lto-plugin\n \n pdf-target: maybe-pdf-target-libstdc++-v3\n pdf-target: maybe-pdf-target-libmudflap\n+pdf-target: maybe-pdf-target-libsanitizer\n pdf-target: maybe-pdf-target-libssp\n pdf-target: maybe-pdf-target-newlib\n pdf-target: maybe-pdf-target-libgcc\n@@ -1401,6 +1410,7 @@ html-host: maybe-html-lto-plugin\n \n html-target: maybe-html-target-libstdc++-v3\n html-target: maybe-html-target-libmudflap\n+html-target: maybe-html-target-libsanitizer\n html-target: maybe-html-target-libssp\n html-target: maybe-html-target-newlib\n html-target: maybe-html-target-libgcc\n@@ -1482,6 +1492,7 @@ TAGS-host: maybe-TAGS-lto-plugin\n \n TAGS-target: maybe-TAGS-target-libstdc++-v3\n TAGS-target: maybe-TAGS-target-libmudflap\n+TAGS-target: maybe-TAGS-target-libsanitizer\n TAGS-target: maybe-TAGS-target-libssp\n TAGS-target: maybe-TAGS-target-newlib\n TAGS-target: maybe-TAGS-target-libgcc\n@@ -1563,6 +1574,7 @@ install-info-host: maybe-install-info-lto-plugin\n \n install-info-target: maybe-install-info-target-libstdc++-v3\n install-info-target: maybe-install-info-target-libmudflap\n+install-info-target: maybe-install-info-target-libsanitizer\n install-info-target: maybe-install-info-target-libssp\n install-info-target: maybe-install-info-target-newlib\n install-info-target: maybe-install-info-target-libgcc\n@@ -1644,6 +1656,7 @@ install-pdf-host: maybe-install-pdf-lto-plugin\n \n install-pdf-target: maybe-install-pdf-target-libstdc++-v3\n install-pdf-target: maybe-install-pdf-target-libmudflap\n+install-pdf-target: maybe-install-pdf-target-libsanitizer\n install-pdf-target: maybe-install-pdf-target-libssp\n install-pdf-target: maybe-install-pdf-target-newlib\n install-pdf-target: maybe-install-pdf-target-libgcc\n@@ -1725,6 +1738,7 @@ install-html-host: maybe-install-html-lto-plugin\n \n install-html-target: maybe-install-html-target-libstdc++-v3\n install-html-target: maybe-install-html-target-libmudflap\n+install-html-target: maybe-install-html-target-libsanitizer\n install-html-target: maybe-install-html-target-libssp\n install-html-target: maybe-install-html-target-newlib\n install-html-target: maybe-install-html-target-libgcc\n@@ -1806,6 +1820,7 @@ installcheck-host: maybe-installcheck-lto-plugin\n \n installcheck-target: maybe-installcheck-target-libstdc++-v3\n installcheck-target: maybe-installcheck-target-libmudflap\n+installcheck-target: maybe-installcheck-target-libsanitizer\n installcheck-target: maybe-installcheck-target-libssp\n installcheck-target: maybe-installcheck-target-newlib\n installcheck-target: maybe-installcheck-target-libgcc\n@@ -1887,6 +1902,7 @@ mostlyclean-host: maybe-mostlyclean-lto-plugin\n \n mostlyclean-target: maybe-mostlyclean-target-libstdc++-v3\n mostlyclean-target: maybe-mostlyclean-target-libmudflap\n+mostlyclean-target: maybe-mostlyclean-target-libsanitizer\n mostlyclean-target: maybe-mostlyclean-target-libssp\n mostlyclean-target: maybe-mostlyclean-target-newlib\n mostlyclean-target: maybe-mostlyclean-target-libgcc\n@@ -1968,6 +1984,7 @@ clean-host: maybe-clean-lto-plugin\n \n clean-target: maybe-clean-target-libstdc++-v3\n clean-target: maybe-clean-target-libmudflap\n+clean-target: maybe-clean-target-libsanitizer\n clean-target: maybe-clean-target-libssp\n clean-target: maybe-clean-target-newlib\n clean-target: maybe-clean-target-libgcc\n@@ -2049,6 +2066,7 @@ distclean-host: maybe-distclean-lto-plugin\n \n distclean-target: maybe-distclean-target-libstdc++-v3\n distclean-target: maybe-distclean-target-libmudflap\n+distclean-target: maybe-distclean-target-libsanitizer\n distclean-target: maybe-distclean-target-libssp\n distclean-target: maybe-distclean-target-newlib\n distclean-target: maybe-distclean-target-libgcc\n@@ -2130,6 +2148,7 @@ maintainer-clean-host: maybe-maintainer-clean-lto-plugin\n \n maintainer-clean-target: maybe-maintainer-clean-target-libstdc++-v3\n maintainer-clean-target: maybe-maintainer-clean-target-libmudflap\n+maintainer-clean-target: maybe-maintainer-clean-target-libsanitizer\n maintainer-clean-target: maybe-maintainer-clean-target-libssp\n maintainer-clean-target: maybe-maintainer-clean-target-newlib\n maintainer-clean-target: maybe-maintainer-clean-target-libgcc\n@@ -2266,6 +2285,7 @@ check-host:  \\\n check-target:  \\\n     maybe-check-target-libstdc++-v3 \\\n     maybe-check-target-libmudflap \\\n+    maybe-check-target-libsanitizer \\\n     maybe-check-target-libssp \\\n     maybe-check-target-newlib \\\n     maybe-check-target-libgcc \\\n@@ -2420,6 +2440,7 @@ install-host:  \\\n install-target:  \\\n     maybe-install-target-libstdc++-v3 \\\n     maybe-install-target-libmudflap \\\n+    maybe-install-target-libsanitizer \\\n     maybe-install-target-libssp \\\n     maybe-install-target-newlib \\\n     maybe-install-target-libgcc \\\n@@ -2521,6 +2542,7 @@ install-strip-host:  \\\n install-strip-target:  \\\n     maybe-install-strip-target-libstdc++-v3 \\\n     maybe-install-strip-target-libmudflap \\\n+    maybe-install-strip-target-libsanitizer \\\n     maybe-install-strip-target-libssp \\\n     maybe-install-strip-target-newlib \\\n     maybe-install-strip-target-libgcc \\\n@@ -32154,6 +32176,463 @@ maintainer-clean-target-libmudflap:\n \n \n \n+.PHONY: configure-target-libsanitizer maybe-configure-target-libsanitizer\n+maybe-configure-target-libsanitizer:\n+@if gcc-bootstrap\n+configure-target-libsanitizer: stage_current\n+@endif gcc-bootstrap\n+@if target-libsanitizer\n+maybe-configure-target-libsanitizer: configure-target-libsanitizer\n+configure-target-libsanitizer: \n+\t@: $(MAKE); $(unstage)\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\techo \"Checking multilib configuration for libsanitizer...\"; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libsanitizer ; \\\n+\t$(CC_FOR_TARGET) --print-multi-lib > $(TARGET_SUBDIR)/libsanitizer/multilib.tmp 2> /dev/null ; \\\n+\tif test -r $(TARGET_SUBDIR)/libsanitizer/multilib.out; then \\\n+\t  if cmp -s $(TARGET_SUBDIR)/libsanitizer/multilib.tmp $(TARGET_SUBDIR)/libsanitizer/multilib.out; then \\\n+\t    rm -f $(TARGET_SUBDIR)/libsanitizer/multilib.tmp; \\\n+\t  else \\\n+\t    rm -f $(TARGET_SUBDIR)/libsanitizer/Makefile; \\\n+\t    mv $(TARGET_SUBDIR)/libsanitizer/multilib.tmp $(TARGET_SUBDIR)/libsanitizer/multilib.out; \\\n+\t  fi; \\\n+\telse \\\n+\t  mv $(TARGET_SUBDIR)/libsanitizer/multilib.tmp $(TARGET_SUBDIR)/libsanitizer/multilib.out; \\\n+\tfi; \\\n+\ttest ! -f $(TARGET_SUBDIR)/libsanitizer/Makefile || exit 0; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libsanitizer ; \\\n+\t$(NORMAL_TARGET_EXPORTS)  \\\n+\techo Configuring in $(TARGET_SUBDIR)/libsanitizer; \\\n+\tcd \"$(TARGET_SUBDIR)/libsanitizer\" || exit 1; \\\n+\tcase $(srcdir) in \\\n+\t  /* | [A-Za-z]:[\\\\/]*) topdir=$(srcdir) ;; \\\n+\t  *) topdir=`echo $(TARGET_SUBDIR)/libsanitizer/ | \\\n+\t\tsed -e 's,\\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \\\n+\tesac; \\\n+\tsrcdiroption=\"--srcdir=$${topdir}/libsanitizer\"; \\\n+\tlibsrcdir=\"$$s/libsanitizer\"; \\\n+\trm -f no-such-file || : ; \\\n+\tCONFIG_SITE=no-such-file $(SHELL) $${libsrcdir}/configure \\\n+\t  $(TARGET_CONFIGARGS) --build=${build_alias} --host=${target_alias} \\\n+\t  --target=${target_alias} $${srcdiroption}  \\\n+\t  || exit 1\n+@endif target-libsanitizer\n+\n+\n+\n+\n+\n+.PHONY: all-target-libsanitizer maybe-all-target-libsanitizer\n+maybe-all-target-libsanitizer:\n+@if gcc-bootstrap\n+all-target-libsanitizer: stage_current\n+@endif gcc-bootstrap\n+@if target-libsanitizer\n+TARGET-target-libsanitizer=all\n+maybe-all-target-libsanitizer: all-target-libsanitizer\n+all-target-libsanitizer: configure-target-libsanitizer\n+\t@: $(MAKE); $(unstage)\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS)  \\\n+\t(cd $(TARGET_SUBDIR)/libsanitizer && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) $(EXTRA_TARGET_FLAGS)   \\\n+\t\t$(TARGET-target-libsanitizer))\n+@endif target-libsanitizer\n+\n+\n+\n+\n+\n+.PHONY: check-target-libsanitizer maybe-check-target-libsanitizer\n+maybe-check-target-libsanitizer:\n+@if target-libsanitizer\n+maybe-check-target-libsanitizer: check-target-libsanitizer\n+\n+check-target-libsanitizer:\n+\t@: $(MAKE); $(unstage)\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\t(cd $(TARGET_SUBDIR)/libsanitizer && \\\n+\t  $(MAKE) $(TARGET_FLAGS_TO_PASS)   check)\n+\n+@endif target-libsanitizer\n+\n+.PHONY: install-target-libsanitizer maybe-install-target-libsanitizer\n+maybe-install-target-libsanitizer:\n+@if target-libsanitizer\n+maybe-install-target-libsanitizer: install-target-libsanitizer\n+\n+install-target-libsanitizer: installdirs\n+\t@: $(MAKE); $(unstage)\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\t(cd $(TARGET_SUBDIR)/libsanitizer && \\\n+\t  $(MAKE) $(TARGET_FLAGS_TO_PASS)  install)\n+\n+@endif target-libsanitizer\n+\n+.PHONY: install-strip-target-libsanitizer maybe-install-strip-target-libsanitizer\n+maybe-install-strip-target-libsanitizer:\n+@if target-libsanitizer\n+maybe-install-strip-target-libsanitizer: install-strip-target-libsanitizer\n+\n+install-strip-target-libsanitizer: installdirs\n+\t@: $(MAKE); $(unstage)\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\t(cd $(TARGET_SUBDIR)/libsanitizer && \\\n+\t  $(MAKE) $(TARGET_FLAGS_TO_PASS)  install-strip)\n+\n+@endif target-libsanitizer\n+\n+# Other targets (info, dvi, pdf, etc.)\n+\n+.PHONY: maybe-info-target-libsanitizer info-target-libsanitizer\n+maybe-info-target-libsanitizer:\n+@if target-libsanitizer\n+maybe-info-target-libsanitizer: info-target-libsanitizer\n+\n+info-target-libsanitizer: \\\n+    configure-target-libsanitizer \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libsanitizer/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing info in $(TARGET_SUBDIR)/libsanitizer\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libsanitizer && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           info) \\\n+\t  || exit 1\n+\n+@endif target-libsanitizer\n+\n+.PHONY: maybe-dvi-target-libsanitizer dvi-target-libsanitizer\n+maybe-dvi-target-libsanitizer:\n+@if target-libsanitizer\n+maybe-dvi-target-libsanitizer: dvi-target-libsanitizer\n+\n+dvi-target-libsanitizer: \\\n+    configure-target-libsanitizer \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libsanitizer/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing dvi in $(TARGET_SUBDIR)/libsanitizer\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libsanitizer && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           dvi) \\\n+\t  || exit 1\n+\n+@endif target-libsanitizer\n+\n+.PHONY: maybe-pdf-target-libsanitizer pdf-target-libsanitizer\n+maybe-pdf-target-libsanitizer:\n+@if target-libsanitizer\n+maybe-pdf-target-libsanitizer: pdf-target-libsanitizer\n+\n+pdf-target-libsanitizer: \\\n+    configure-target-libsanitizer \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libsanitizer/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing pdf in $(TARGET_SUBDIR)/libsanitizer\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libsanitizer && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           pdf) \\\n+\t  || exit 1\n+\n+@endif target-libsanitizer\n+\n+.PHONY: maybe-html-target-libsanitizer html-target-libsanitizer\n+maybe-html-target-libsanitizer:\n+@if target-libsanitizer\n+maybe-html-target-libsanitizer: html-target-libsanitizer\n+\n+html-target-libsanitizer: \\\n+    configure-target-libsanitizer \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libsanitizer/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing html in $(TARGET_SUBDIR)/libsanitizer\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libsanitizer && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           html) \\\n+\t  || exit 1\n+\n+@endif target-libsanitizer\n+\n+.PHONY: maybe-TAGS-target-libsanitizer TAGS-target-libsanitizer\n+maybe-TAGS-target-libsanitizer:\n+@if target-libsanitizer\n+maybe-TAGS-target-libsanitizer: TAGS-target-libsanitizer\n+\n+TAGS-target-libsanitizer: \\\n+    configure-target-libsanitizer \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libsanitizer/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing TAGS in $(TARGET_SUBDIR)/libsanitizer\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libsanitizer && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           TAGS) \\\n+\t  || exit 1\n+\n+@endif target-libsanitizer\n+\n+.PHONY: maybe-install-info-target-libsanitizer install-info-target-libsanitizer\n+maybe-install-info-target-libsanitizer:\n+@if target-libsanitizer\n+maybe-install-info-target-libsanitizer: install-info-target-libsanitizer\n+\n+install-info-target-libsanitizer: \\\n+    configure-target-libsanitizer \\\n+    info-target-libsanitizer \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libsanitizer/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing install-info in $(TARGET_SUBDIR)/libsanitizer\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libsanitizer && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           install-info) \\\n+\t  || exit 1\n+\n+@endif target-libsanitizer\n+\n+.PHONY: maybe-install-pdf-target-libsanitizer install-pdf-target-libsanitizer\n+maybe-install-pdf-target-libsanitizer:\n+@if target-libsanitizer\n+maybe-install-pdf-target-libsanitizer: install-pdf-target-libsanitizer\n+\n+install-pdf-target-libsanitizer: \\\n+    configure-target-libsanitizer \\\n+    pdf-target-libsanitizer \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libsanitizer/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing install-pdf in $(TARGET_SUBDIR)/libsanitizer\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libsanitizer && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           install-pdf) \\\n+\t  || exit 1\n+\n+@endif target-libsanitizer\n+\n+.PHONY: maybe-install-html-target-libsanitizer install-html-target-libsanitizer\n+maybe-install-html-target-libsanitizer:\n+@if target-libsanitizer\n+maybe-install-html-target-libsanitizer: install-html-target-libsanitizer\n+\n+install-html-target-libsanitizer: \\\n+    configure-target-libsanitizer \\\n+    html-target-libsanitizer \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libsanitizer/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing install-html in $(TARGET_SUBDIR)/libsanitizer\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libsanitizer && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           install-html) \\\n+\t  || exit 1\n+\n+@endif target-libsanitizer\n+\n+.PHONY: maybe-installcheck-target-libsanitizer installcheck-target-libsanitizer\n+maybe-installcheck-target-libsanitizer:\n+@if target-libsanitizer\n+maybe-installcheck-target-libsanitizer: installcheck-target-libsanitizer\n+\n+installcheck-target-libsanitizer: \\\n+    configure-target-libsanitizer \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libsanitizer/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing installcheck in $(TARGET_SUBDIR)/libsanitizer\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libsanitizer && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           installcheck) \\\n+\t  || exit 1\n+\n+@endif target-libsanitizer\n+\n+.PHONY: maybe-mostlyclean-target-libsanitizer mostlyclean-target-libsanitizer\n+maybe-mostlyclean-target-libsanitizer:\n+@if target-libsanitizer\n+maybe-mostlyclean-target-libsanitizer: mostlyclean-target-libsanitizer\n+\n+mostlyclean-target-libsanitizer: \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libsanitizer/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing mostlyclean in $(TARGET_SUBDIR)/libsanitizer\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libsanitizer && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           mostlyclean) \\\n+\t  || exit 1\n+\n+@endif target-libsanitizer\n+\n+.PHONY: maybe-clean-target-libsanitizer clean-target-libsanitizer\n+maybe-clean-target-libsanitizer:\n+@if target-libsanitizer\n+maybe-clean-target-libsanitizer: clean-target-libsanitizer\n+\n+clean-target-libsanitizer: \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libsanitizer/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing clean in $(TARGET_SUBDIR)/libsanitizer\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libsanitizer && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           clean) \\\n+\t  || exit 1\n+\n+@endif target-libsanitizer\n+\n+.PHONY: maybe-distclean-target-libsanitizer distclean-target-libsanitizer\n+maybe-distclean-target-libsanitizer:\n+@if target-libsanitizer\n+maybe-distclean-target-libsanitizer: distclean-target-libsanitizer\n+\n+distclean-target-libsanitizer: \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libsanitizer/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing distclean in $(TARGET_SUBDIR)/libsanitizer\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libsanitizer && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           distclean) \\\n+\t  || exit 1\n+\n+@endif target-libsanitizer\n+\n+.PHONY: maybe-maintainer-clean-target-libsanitizer maintainer-clean-target-libsanitizer\n+maybe-maintainer-clean-target-libsanitizer:\n+@if target-libsanitizer\n+maybe-maintainer-clean-target-libsanitizer: maintainer-clean-target-libsanitizer\n+\n+maintainer-clean-target-libsanitizer: \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libsanitizer/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing maintainer-clean in $(TARGET_SUBDIR)/libsanitizer\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libsanitizer && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           maintainer-clean) \\\n+\t  || exit 1\n+\n+@endif target-libsanitizer\n+\n+\n+\n+\n+\n .PHONY: configure-target-libssp maybe-configure-target-libssp\n maybe-configure-target-libssp:\n @if gcc-bootstrap\n@@ -44390,6 +44869,7 @@ configure-stage4-target-libstdc++-v3: maybe-all-stage4-gcc\n configure-stageprofile-target-libstdc++-v3: maybe-all-stageprofile-gcc\n configure-stagefeedback-target-libstdc++-v3: maybe-all-stagefeedback-gcc\n configure-target-libmudflap: stage_last\n+configure-target-libsanitizer: stage_last\n configure-target-libssp: stage_last\n configure-target-newlib: stage_last\n configure-stage1-target-libgcc: maybe-all-stage1-gcc\n@@ -44425,6 +44905,7 @@ configure-target-libatomic: stage_last\n @if gcc-no-bootstrap\n configure-target-libstdc++-v3: maybe-all-gcc\n configure-target-libmudflap: maybe-all-gcc\n+configure-target-libsanitizer: maybe-all-gcc\n configure-target-libssp: maybe-all-gcc\n configure-target-newlib: maybe-all-gcc\n configure-target-libgcc: maybe-all-gcc\n@@ -45166,6 +45647,7 @@ configure-stage3-target-libstdc++-v3: maybe-configure-stage3-target-libgomp\n configure-stage4-target-libstdc++-v3: maybe-configure-stage4-target-libgomp\n configure-stageprofile-target-libstdc++-v3: maybe-configure-stageprofile-target-libgomp\n configure-stagefeedback-target-libstdc++-v3: maybe-configure-stagefeedback-target-libgomp\n+configure-target-libsanitizer: maybe-all-target-libstdc++-v3\n all-target-libstdc++-v3: maybe-configure-target-libgomp\n \n all-stage1-target-libstdc++-v3: maybe-configure-stage1-target-libgomp\n@@ -45204,6 +45686,7 @@ configure-stagefeedback-target-libgomp: maybe-all-stagefeedback-target-libgcc\n @if gcc-no-bootstrap\n configure-target-libstdc++-v3: maybe-all-target-libgcc\n configure-target-libmudflap: maybe-all-target-libgcc\n+configure-target-libsanitizer: maybe-all-target-libgcc\n configure-target-libssp: maybe-all-target-libgcc\n configure-target-newlib: maybe-all-target-libgcc\n configure-target-libbacktrace: maybe-all-target-libgcc\n@@ -45230,6 +45713,8 @@ configure-target-libstdc++-v3: maybe-all-target-newlib maybe-all-target-libgloss\n \n configure-target-libmudflap: maybe-all-target-newlib maybe-all-target-libgloss\n \n+configure-target-libsanitizer: maybe-all-target-newlib maybe-all-target-libgloss\n+\n configure-target-libssp: maybe-all-target-newlib maybe-all-target-libgloss\n \n "}, {"sha": "b8b1ebf50d370b1af00e9622e9595f5dadcd072c", "filename": "configure", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/configure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/configure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -2773,6 +2773,7 @@ target_libraries=\"target-libgcc \\\n \t\ttarget-libitm \\\n \t\ttarget-libstdc++-v3 \\\n \t\ttarget-libmudflap \\\n+\t\ttarget-libsanitizer \\\n \t\ttarget-libssp \\\n \t\ttarget-libquadmath \\\n \t\ttarget-libgfortran \\"}, {"sha": "00d2b6ce5bb74ae869c205d83e5c32642f300ffa", "filename": "configure.ac", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/configure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/configure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure.ac?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -160,6 +160,7 @@ target_libraries=\"target-libgcc \\\n \t\ttarget-libitm \\\n \t\ttarget-libstdc++-v3 \\\n \t\ttarget-libmudflap \\\n+\t\ttarget-libsanitizer \\\n \t\ttarget-libssp \\\n \t\ttarget-libquadmath \\\n \t\ttarget-libgfortran \\"}, {"sha": "cb2f0eb2f29a0b5f4d05d9a93d31208bae98420e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -1,3 +1,8 @@\n+2012-11-12  Wei Mi <wmi@google.com>\n+\n+\t* gcc.c (LINK_COMMAND_SPEC): Add -lasan to link command if\n+\t-faddress-sanitizer is on.\n+\n 2012-11-12  Dodji Seketeli  <dodji@redhat.com>\n \n \t* gimple.h (is_gimple_builtin_call): Declare ..."}, {"sha": "210277130f5f9f91900c881cda1e9f507a89bce3", "filename": "gcc/gcc.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -687,6 +687,7 @@ proper position among the other output files.  */\n     %{fgnu-tm:%:include(libitm.spec)%(link_itm)}\\\n     %(mflib) \" STACK_SPLIT_SPEC \"\\\n     %{fprofile-arcs|fprofile-generate*|coverage:-lgcov}\\\n+    %{faddress-sanitizer:-lasan}\\\n     %{!nostdlib:%{!nodefaultlibs:%(link_ssp) %(link_gcc_c_sequence)}}\\\n     %{!nostdlib:%{!nostartfiles:%E}} %{T*} }}}}}}\"\n #endif"}, {"sha": "7fe3c0cdc64a945162f6a470f362d705cd89c696", "filename": "libsanitizer/ChangeLog.asan", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2FChangeLog.asan", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2FChangeLog.asan", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FChangeLog.asan?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,3 @@\n+2012-10-29  Wei Mi  <wmi@google.com>\n+\n+\tInitial checkin: migrate asan runtime from llvm."}, {"sha": "f7179425605e425255143641d681118bdc2f8425", "filename": "libsanitizer/LICENSE.TXT", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2FLICENSE.TXT", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2FLICENSE.TXT", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FLICENSE.TXT?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,97 @@\n+==============================================================================\n+compiler_rt License\n+==============================================================================\n+\n+The compiler_rt library is dual licensed under both the University of Illinois\n+\"BSD-Like\" license and the MIT license.  As a user of this code you may choose\n+to use it under either license.  As a contributor, you agree to allow your code\n+to be used under both.\n+\n+Full text of the relevant licenses is included below.\n+\n+==============================================================================\n+\n+University of Illinois/NCSA\n+Open Source License\n+\n+Copyright (c) 2009-2012 by the contributors listed in CREDITS.TXT\n+\n+All rights reserved.\n+\n+Developed by:\n+\n+    LLVM Team\n+\n+    University of Illinois at Urbana-Champaign\n+\n+    http://llvm.org\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy of\n+this software and associated documentation files (the \"Software\"), to deal with\n+the Software without restriction, including without limitation the rights to\n+use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n+of the Software, and to permit persons to whom the Software is furnished to do\n+so, subject to the following conditions:\n+\n+    * Redistributions of source code must retain the above copyright notice,\n+      this list of conditions and the following disclaimers.\n+\n+    * Redistributions in binary form must reproduce the above copyright notice,\n+      this list of conditions and the following disclaimers in the\n+      documentation and/or other materials provided with the distribution.\n+\n+    * Neither the names of the LLVM Team, University of Illinois at\n+      Urbana-Champaign, nor the names of its contributors may be used to\n+      endorse or promote products derived from this Software without specific\n+      prior written permission.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n+FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n+CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE\n+SOFTWARE.\n+\n+==============================================================================\n+\n+Copyright (c) 2009-2012 by the contributors listed in CREDITS.TXT\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy\n+of this software and associated documentation files (the \"Software\"), to deal\n+in the Software without restriction, including without limitation the rights\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+copies of the Software, and to permit persons to whom the Software is\n+furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in\n+all copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+THE SOFTWARE.\n+\n+==============================================================================\n+Copyrights and Licenses for Third Party Software Distributed with LLVM:\n+==============================================================================\n+The LLVM software contains code written by third parties.  Such software will\n+have its own individual LICENSE.TXT file in the directory in which it appears.\n+This file will describe the copyrights, license, and restrictions which apply\n+to that code.\n+\n+The disclaimer of warranty in the University of Illinois Open Source License\n+applies to all code in the LLVM Distribution, and nothing in any of the\n+other licenses gives permission to use the names of the LLVM Team or the\n+University of Illinois to endorse or promote products derived from this\n+Software.\n+\n+The following pieces of software have additional or alternate copyrights,\n+licenses, and/or restrictions:\n+\n+Program             Directory\n+-------             ---------\n+mach_override       lib/interception/mach_override"}, {"sha": "b28eb3280fce201864f14592fca34b320b54335a", "filename": "libsanitizer/Makefile.am", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FMakefile.am?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,46 @@\n+SUBDIRS = interception sanitizer_common asan \n+\n+# Work around what appears to be a GNU make bug handling MAKEFLAGS\n+# values defined in terms of make variables, as is the case for CC and\n+# friends when we are called from the top level Makefile.\n+AM_MAKEFLAGS = \\\n+\t\"AR_FLAGS=$(AR_FLAGS)\" \\\n+\t\"CC_FOR_BUILD=$(CC_FOR_BUILD)\" \\\n+\t\"CFLAGS=$(CFLAGS)\" \\\n+\t\"CXXFLAGS=$(CXXFLAGS)\" \\\n+\t\"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)\" \\\n+\t\"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)\" \\\n+\t\"INSTALL=$(INSTALL)\" \\\n+\t\"INSTALL_DATA=$(INSTALL_DATA)\" \\\n+\t\"INSTALL_PROGRAM=$(INSTALL_PROGRAM)\" \\\n+\t\"INSTALL_SCRIPT=$(INSTALL_SCRIPT)\" \\\n+\t\"JC1FLAGS=$(JC1FLAGS)\" \\\n+\t\"LDFLAGS=$(LDFLAGS)\" \\\n+\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+\t\"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\"MAKE=$(MAKE)\" \\\n+\t\"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)\" \\\n+\t\"PICFLAG=$(PICFLAG)\" \\\n+\t\"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)\" \\\n+\t\"SHELL=$(SHELL)\" \\\n+\t\"RUNTESTFLAGS=$(RUNTESTFLAGS)\" \\\n+\t\"exec_prefix=$(exec_prefix)\" \\\n+\t\"infodir=$(infodir)\" \\\n+\t\"libdir=$(libdir)\" \\\n+\t\"prefix=$(prefix)\" \\\n+\t\"includedir=$(includedir)\" \\\n+\t\"AR=$(AR)\" \\\n+\t\"AS=$(AS)\" \\\n+\t\"CC=$(CC)\" \\\n+\t\"CXX=$(CXX)\" \\\n+\t\"LD=$(LD)\" \\\n+\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+\t\"NM=$(NM)\" \\\n+\t\"PICFLAG=$(PICFLAG)\" \\\n+\t\"RANLIB=$(RANLIB)\" \\\n+\t\"DESTDIR=$(DESTDIR)\"\n+\n+MAKEOVERRIDES=\n+\n+## ################################################################\n+"}, {"sha": "67251a87649bd2f819189b2189daef9d94d3034c", "filename": "libsanitizer/Makefile.in", "status": "added", "additions": 773, "deletions": 0, "changes": 773, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FMakefile.in?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,773 @@\n+# Makefile.in generated by automake 1.11.3 from Makefile.am.\n+# @configure_input@\n+\n+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n+# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software\n+# Foundation, Inc.\n+# This Makefile.in is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+# PARTICULAR PURPOSE.\n+\n+@SET_MAKE@\n+VPATH = @srcdir@\n+pkgdatadir = $(datadir)/@PACKAGE@\n+pkgincludedir = $(includedir)/@PACKAGE@\n+pkglibdir = $(libdir)/@PACKAGE@\n+pkglibexecdir = $(libexecdir)/@PACKAGE@\n+am__cd = CDPATH=\"$${ZSH_VERSION+.}$(PATH_SEPARATOR)\" && cd\n+install_sh_DATA = $(install_sh) -c -m 644\n+install_sh_PROGRAM = $(install_sh) -c\n+install_sh_SCRIPT = $(install_sh) -c\n+INSTALL_HEADER = $(INSTALL_DATA)\n+transform = $(program_transform_name)\n+NORMAL_INSTALL = :\n+PRE_INSTALL = :\n+POST_INSTALL = :\n+NORMAL_UNINSTALL = :\n+PRE_UNINSTALL = :\n+POST_UNINSTALL = :\n+build_triplet = @build@\n+host_triplet = @host@\n+subdir = .\n+DIST_COMMON = $(am__configure_deps) $(srcdir)/Makefile.am \\\n+\t$(srcdir)/Makefile.in $(top_srcdir)/configure config.guess \\\n+\tconfig.sub depcomp install-sh ltmain.sh missing\n+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n+am__aclocal_m4_deps = $(top_srcdir)/configure.ac\n+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n+\t$(ACLOCAL_M4)\n+am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \\\n+ configure.lineno config.status.lineno\n+mkinstalldirs = $(install_sh) -d\n+CONFIG_CLEAN_FILES =\n+CONFIG_CLEAN_VPATH_FILES =\n+SOURCES =\n+DIST_SOURCES =\n+RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \\\n+\thtml-recursive info-recursive install-data-recursive \\\n+\tinstall-dvi-recursive install-exec-recursive \\\n+\tinstall-html-recursive install-info-recursive \\\n+\tinstall-pdf-recursive install-ps-recursive install-recursive \\\n+\tinstallcheck-recursive installdirs-recursive pdf-recursive \\\n+\tps-recursive uninstall-recursive\n+RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive\t\\\n+  distclean-recursive maintainer-clean-recursive\n+AM_RECURSIVE_TARGETS = $(RECURSIVE_TARGETS:-recursive=) \\\n+\t$(RECURSIVE_CLEAN_TARGETS:-recursive=) tags TAGS ctags CTAGS \\\n+\tdistdir dist dist-all distcheck\n+ETAGS = etags\n+CTAGS = ctags\n+DIST_SUBDIRS = $(SUBDIRS)\n+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)\n+distdir = $(PACKAGE)-$(VERSION)\n+top_distdir = $(distdir)\n+am__remove_distdir = \\\n+  if test -d \"$(distdir)\"; then \\\n+    find \"$(distdir)\" -type d ! -perm -200 -exec chmod u+w {} ';' \\\n+      && rm -rf \"$(distdir)\" \\\n+      || { sleep 5 && rm -rf \"$(distdir)\"; }; \\\n+  else :; fi\n+am__relativize = \\\n+  dir0=`pwd`; \\\n+  sed_first='s,^\\([^/]*\\)/.*$$,\\1,'; \\\n+  sed_rest='s,^[^/]*/*,,'; \\\n+  sed_last='s,^.*/\\([^/]*\\)$$,\\1,'; \\\n+  sed_butlast='s,/*[^/]*$$,,'; \\\n+  while test -n \"$$dir1\"; do \\\n+    first=`echo \"$$dir1\" | sed -e \"$$sed_first\"`; \\\n+    if test \"$$first\" != \".\"; then \\\n+      if test \"$$first\" = \"..\"; then \\\n+        dir2=`echo \"$$dir0\" | sed -e \"$$sed_last\"`/\"$$dir2\"; \\\n+        dir0=`echo \"$$dir0\" | sed -e \"$$sed_butlast\"`; \\\n+      else \\\n+        first2=`echo \"$$dir2\" | sed -e \"$$sed_first\"`; \\\n+        if test \"$$first2\" = \"$$first\"; then \\\n+          dir2=`echo \"$$dir2\" | sed -e \"$$sed_rest\"`; \\\n+        else \\\n+          dir2=\"../$$dir2\"; \\\n+        fi; \\\n+        dir0=\"$$dir0\"/\"$$first\"; \\\n+      fi; \\\n+    fi; \\\n+    dir1=`echo \"$$dir1\" | sed -e \"$$sed_rest\"`; \\\n+  done; \\\n+  reldir=\"$$dir2\"\n+DIST_ARCHIVES = $(distdir).tar.gz\n+GZIP_ENV = --best\n+distuninstallcheck_listfiles = find . -type f -print\n+am__distuninstallcheck_listfiles = $(distuninstallcheck_listfiles) \\\n+  | sed 's|^\\./|$(prefix)/|' | grep -v '$(infodir)/dir$$'\n+distcleancheck_listfiles = find . -type f -print\n+ACLOCAL = @ACLOCAL@\n+AMTAR = @AMTAR@\n+AR = @AR@\n+AUTOCONF = @AUTOCONF@\n+AUTOHEADER = @AUTOHEADER@\n+AUTOMAKE = @AUTOMAKE@\n+AWK = @AWK@\n+CC = @CC@\n+CCAS = @CCAS@\n+CCASDEPMODE = @CCASDEPMODE@\n+CCASFLAGS = @CCASFLAGS@\n+CCDEPMODE = @CCDEPMODE@\n+CFLAGS = @CFLAGS@\n+CPP = @CPP@\n+CPPFLAGS = @CPPFLAGS@\n+CXX = @CXX@\n+CXXCPP = @CXXCPP@\n+CXXDEPMODE = @CXXDEPMODE@\n+CXXFLAGS = @CXXFLAGS@\n+CYGPATH_W = @CYGPATH_W@\n+DEFS = @DEFS@\n+DEPDIR = @DEPDIR@\n+DLLTOOL = @DLLTOOL@\n+DSYMUTIL = @DSYMUTIL@\n+DUMPBIN = @DUMPBIN@\n+ECHO_C = @ECHO_C@\n+ECHO_N = @ECHO_N@\n+ECHO_T = @ECHO_T@\n+EGREP = @EGREP@\n+EXEEXT = @EXEEXT@\n+FGREP = @FGREP@\n+GREP = @GREP@\n+INSTALL = @INSTALL@\n+INSTALL_DATA = @INSTALL_DATA@\n+INSTALL_PROGRAM = @INSTALL_PROGRAM@\n+INSTALL_SCRIPT = @INSTALL_SCRIPT@\n+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@\n+LD = @LD@\n+LDFLAGS = @LDFLAGS@\n+LIBOBJS = @LIBOBJS@\n+LIBS = @LIBS@\n+LIBTOOL = @LIBTOOL@\n+LIPO = @LIPO@\n+LN_S = @LN_S@\n+LTLIBOBJS = @LTLIBOBJS@\n+MAKEINFO = @MAKEINFO@\n+MANIFEST_TOOL = @MANIFEST_TOOL@\n+MKDIR_P = @MKDIR_P@\n+NM = @NM@\n+NMEDIT = @NMEDIT@\n+OBJDUMP = @OBJDUMP@\n+OBJEXT = @OBJEXT@\n+OTOOL = @OTOOL@\n+OTOOL64 = @OTOOL64@\n+PACKAGE = @PACKAGE@\n+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\n+PACKAGE_NAME = @PACKAGE_NAME@\n+PACKAGE_STRING = @PACKAGE_STRING@\n+PACKAGE_TARNAME = @PACKAGE_TARNAME@\n+PACKAGE_URL = @PACKAGE_URL@\n+PACKAGE_VERSION = @PACKAGE_VERSION@\n+PATH_SEPARATOR = @PATH_SEPARATOR@\n+RANLIB = @RANLIB@\n+SED = @SED@\n+SET_MAKE = @SET_MAKE@\n+SHELL = @SHELL@\n+STRIP = @STRIP@\n+VERSION = @VERSION@\n+abs_builddir = @abs_builddir@\n+abs_srcdir = @abs_srcdir@\n+abs_top_builddir = @abs_top_builddir@\n+abs_top_srcdir = @abs_top_srcdir@\n+ac_ct_AR = @ac_ct_AR@\n+ac_ct_CC = @ac_ct_CC@\n+ac_ct_CXX = @ac_ct_CXX@\n+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@\n+am__include = @am__include@\n+am__leading_dot = @am__leading_dot@\n+am__quote = @am__quote@\n+am__tar = @am__tar@\n+am__untar = @am__untar@\n+bindir = @bindir@\n+build = @build@\n+build_alias = @build_alias@\n+build_cpu = @build_cpu@\n+build_os = @build_os@\n+build_vendor = @build_vendor@\n+builddir = @builddir@\n+datadir = @datadir@\n+datarootdir = @datarootdir@\n+docdir = @docdir@\n+dvidir = @dvidir@\n+enable_shared = @enable_shared@\n+enable_static = @enable_static@\n+exec_prefix = @exec_prefix@\n+host = @host@\n+host_alias = @host_alias@\n+host_cpu = @host_cpu@\n+host_os = @host_os@\n+host_vendor = @host_vendor@\n+htmldir = @htmldir@\n+includedir = @includedir@\n+infodir = @infodir@\n+install_sh = @install_sh@\n+libdir = @libdir@\n+libexecdir = @libexecdir@\n+localedir = @localedir@\n+localstatedir = @localstatedir@\n+mandir = @mandir@\n+mkdir_p = @mkdir_p@\n+oldincludedir = @oldincludedir@\n+pdfdir = @pdfdir@\n+prefix = @prefix@\n+program_transform_name = @program_transform_name@\n+psdir = @psdir@\n+sbindir = @sbindir@\n+sharedstatedir = @sharedstatedir@\n+srcdir = @srcdir@\n+sysconfdir = @sysconfdir@\n+target_alias = @target_alias@\n+toolexecdir = @toolexecdir@\n+toolexeclibdir = @toolexeclibdir@\n+top_build_prefix = @top_build_prefix@\n+top_builddir = @top_builddir@\n+top_srcdir = @top_srcdir@\n+SUBDIRS = interception sanitizer_common asan \n+\n+# Work around what appears to be a GNU make bug handling MAKEFLAGS\n+# values defined in terms of make variables, as is the case for CC and\n+# friends when we are called from the top level Makefile.\n+AM_MAKEFLAGS = \\\n+\t\"AR_FLAGS=$(AR_FLAGS)\" \\\n+\t\"CC_FOR_BUILD=$(CC_FOR_BUILD)\" \\\n+\t\"CFLAGS=$(CFLAGS)\" \\\n+\t\"CXXFLAGS=$(CXXFLAGS)\" \\\n+\t\"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)\" \\\n+\t\"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)\" \\\n+\t\"INSTALL=$(INSTALL)\" \\\n+\t\"INSTALL_DATA=$(INSTALL_DATA)\" \\\n+\t\"INSTALL_PROGRAM=$(INSTALL_PROGRAM)\" \\\n+\t\"INSTALL_SCRIPT=$(INSTALL_SCRIPT)\" \\\n+\t\"JC1FLAGS=$(JC1FLAGS)\" \\\n+\t\"LDFLAGS=$(LDFLAGS)\" \\\n+\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+\t\"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\"MAKE=$(MAKE)\" \\\n+\t\"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)\" \\\n+\t\"PICFLAG=$(PICFLAG)\" \\\n+\t\"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)\" \\\n+\t\"SHELL=$(SHELL)\" \\\n+\t\"RUNTESTFLAGS=$(RUNTESTFLAGS)\" \\\n+\t\"exec_prefix=$(exec_prefix)\" \\\n+\t\"infodir=$(infodir)\" \\\n+\t\"libdir=$(libdir)\" \\\n+\t\"prefix=$(prefix)\" \\\n+\t\"includedir=$(includedir)\" \\\n+\t\"AR=$(AR)\" \\\n+\t\"AS=$(AS)\" \\\n+\t\"CC=$(CC)\" \\\n+\t\"CXX=$(CXX)\" \\\n+\t\"LD=$(LD)\" \\\n+\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+\t\"NM=$(NM)\" \\\n+\t\"PICFLAG=$(PICFLAG)\" \\\n+\t\"RANLIB=$(RANLIB)\" \\\n+\t\"DESTDIR=$(DESTDIR)\"\n+\n+MAKEOVERRIDES = \n+all: all-recursive\n+\n+.SUFFIXES:\n+am--refresh: Makefile\n+\t@:\n+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)\n+\t@for dep in $?; do \\\n+\t  case '$(am__configure_deps)' in \\\n+\t    *$$dep*) \\\n+\t      echo ' cd $(srcdir) && $(AUTOMAKE) --foreign'; \\\n+\t      $(am__cd) $(srcdir) && $(AUTOMAKE) --foreign \\\n+\t\t&& exit 0; \\\n+\t      exit 1;; \\\n+\t  esac; \\\n+\tdone; \\\n+\techo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign Makefile'; \\\n+\t$(am__cd) $(top_srcdir) && \\\n+\t  $(AUTOMAKE) --foreign Makefile\n+.PRECIOUS: Makefile\n+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n+\t@case '$?' in \\\n+\t  *config.status*) \\\n+\t    echo ' $(SHELL) ./config.status'; \\\n+\t    $(SHELL) ./config.status;; \\\n+\t  *) \\\n+\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe)'; \\\n+\t    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe);; \\\n+\tesac;\n+\n+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)\n+\t$(SHELL) ./config.status --recheck\n+\n+$(top_srcdir)/configure:  $(am__configure_deps)\n+\t$(am__cd) $(srcdir) && $(AUTOCONF)\n+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)\n+\t$(am__cd) $(srcdir) && $(ACLOCAL) $(ACLOCAL_AMFLAGS)\n+$(am__aclocal_m4_deps):\n+\n+mostlyclean-libtool:\n+\t-rm -f *.lo\n+\n+clean-libtool:\n+\t-rm -rf .libs _libs\n+\n+distclean-libtool:\n+\t-rm -f libtool config.lt\n+\n+# This directory's subdirectories are mostly independent; you can cd\n+# into them and run `make' without going through this Makefile.\n+# To change the values of `make' variables: instead of editing Makefiles,\n+# (1) if the variable is set in `config.status', edit `config.status'\n+#     (which will cause the Makefiles to be regenerated when you run `make');\n+# (2) otherwise, pass the desired values on the `make' command line.\n+$(RECURSIVE_TARGETS):\n+\t@fail= failcom='exit 1'; \\\n+\tfor f in x $$MAKEFLAGS; do \\\n+\t  case $$f in \\\n+\t    *=* | --[!k]*);; \\\n+\t    *k*) failcom='fail=yes';; \\\n+\t  esac; \\\n+\tdone; \\\n+\tdot_seen=no; \\\n+\ttarget=`echo $@ | sed s/-recursive//`; \\\n+\tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n+\t  echo \"Making $$target in $$subdir\"; \\\n+\t  if test \"$$subdir\" = \".\"; then \\\n+\t    dot_seen=yes; \\\n+\t    local_target=\"$$target-am\"; \\\n+\t  else \\\n+\t    local_target=\"$$target\"; \\\n+\t  fi; \\\n+\t  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \\\n+\t  || eval $$failcom; \\\n+\tdone; \\\n+\tif test \"$$dot_seen\" = \"no\"; then \\\n+\t  $(MAKE) $(AM_MAKEFLAGS) \"$$target-am\" || exit 1; \\\n+\tfi; test -z \"$$fail\"\n+\n+$(RECURSIVE_CLEAN_TARGETS):\n+\t@fail= failcom='exit 1'; \\\n+\tfor f in x $$MAKEFLAGS; do \\\n+\t  case $$f in \\\n+\t    *=* | --[!k]*);; \\\n+\t    *k*) failcom='fail=yes';; \\\n+\t  esac; \\\n+\tdone; \\\n+\tdot_seen=no; \\\n+\tcase \"$@\" in \\\n+\t  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \\\n+\t  *) list='$(SUBDIRS)' ;; \\\n+\tesac; \\\n+\trev=''; for subdir in $$list; do \\\n+\t  if test \"$$subdir\" = \".\"; then :; else \\\n+\t    rev=\"$$subdir $$rev\"; \\\n+\t  fi; \\\n+\tdone; \\\n+\trev=\"$$rev .\"; \\\n+\ttarget=`echo $@ | sed s/-recursive//`; \\\n+\tfor subdir in $$rev; do \\\n+\t  echo \"Making $$target in $$subdir\"; \\\n+\t  if test \"$$subdir\" = \".\"; then \\\n+\t    local_target=\"$$target-am\"; \\\n+\t  else \\\n+\t    local_target=\"$$target\"; \\\n+\t  fi; \\\n+\t  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \\\n+\t  || eval $$failcom; \\\n+\tdone && test -z \"$$fail\"\n+tags-recursive:\n+\tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n+\t  test \"$$subdir\" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \\\n+\tdone\n+ctags-recursive:\n+\tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n+\t  test \"$$subdir\" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \\\n+\tdone\n+\n+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)\n+\tlist='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\tmkid -fID $$unique\n+tags: TAGS\n+\n+TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \\\n+\t\t$(TAGS_FILES) $(LISP)\n+\tset x; \\\n+\there=`pwd`; \\\n+\tif ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \\\n+\t  include_option=--etags-include; \\\n+\t  empty_fix=.; \\\n+\telse \\\n+\t  include_option=--include; \\\n+\t  empty_fix=; \\\n+\tfi; \\\n+\tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n+\t  if test \"$$subdir\" = .; then :; else \\\n+\t    test ! -f $$subdir/TAGS || \\\n+\t      set \"$$@\" \"$$include_option=$$here/$$subdir/TAGS\"; \\\n+\t  fi; \\\n+\tdone; \\\n+\tlist='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\tshift; \\\n+\tif test -z \"$(ETAGS_ARGS)$$*$$unique\"; then :; else \\\n+\t  test -n \"$$unique\" || unique=$$empty_fix; \\\n+\t  if test $$# -gt 0; then \\\n+\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n+\t      \"$$@\" $$unique; \\\n+\t  else \\\n+\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n+\t      $$unique; \\\n+\t  fi; \\\n+\tfi\n+ctags: CTAGS\n+CTAGS: ctags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \\\n+\t\t$(TAGS_FILES) $(LISP)\n+\tlist='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\ttest -z \"$(CTAGS_ARGS)$$unique\" \\\n+\t  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \\\n+\t     $$unique\n+\n+GTAGS:\n+\there=`$(am__cd) $(top_builddir) && pwd` \\\n+\t  && $(am__cd) $(top_srcdir) \\\n+\t  && gtags -i $(GTAGS_ARGS) \"$$here\"\n+\n+distclean-tags:\n+\t-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags\n+\n+distdir: $(DISTFILES)\n+\t$(am__remove_distdir)\n+\ttest -d \"$(distdir)\" || mkdir \"$(distdir)\"\n+\t@srcdirstrip=`echo \"$(srcdir)\" | sed 's/[].[^$$\\\\*]/\\\\\\\\&/g'`; \\\n+\ttopsrcdirstrip=`echo \"$(top_srcdir)\" | sed 's/[].[^$$\\\\*]/\\\\\\\\&/g'`; \\\n+\tlist='$(DISTFILES)'; \\\n+\t  dist_files=`for file in $$list; do echo $$file; done | \\\n+\t  sed -e \"s|^$$srcdirstrip/||;t\" \\\n+\t      -e \"s|^$$topsrcdirstrip/|$(top_builddir)/|;t\"`; \\\n+\tcase $$dist_files in \\\n+\t  */*) $(MKDIR_P) `echo \"$$dist_files\" | \\\n+\t\t\t   sed '/\\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \\\n+\t\t\t   sort -u` ;; \\\n+\tesac; \\\n+\tfor file in $$dist_files; do \\\n+\t  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \\\n+\t  if test -d $$d/$$file; then \\\n+\t    dir=`echo \"/$$file\" | sed -e 's,/[^/]*$$,,'`; \\\n+\t    if test -d \"$(distdir)/$$file\"; then \\\n+\t      find \"$(distdir)/$$file\" -type d ! -perm -700 -exec chmod u+rwx {} \\;; \\\n+\t    fi; \\\n+\t    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \\\n+\t      cp -fpR $(srcdir)/$$file \"$(distdir)$$dir\" || exit 1; \\\n+\t      find \"$(distdir)/$$file\" -type d ! -perm -700 -exec chmod u+rwx {} \\;; \\\n+\t    fi; \\\n+\t    cp -fpR $$d/$$file \"$(distdir)$$dir\" || exit 1; \\\n+\t  else \\\n+\t    test -f \"$(distdir)/$$file\" \\\n+\t    || cp -p $$d/$$file \"$(distdir)/$$file\" \\\n+\t    || exit 1; \\\n+\t  fi; \\\n+\tdone\n+\t@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \\\n+\t  if test \"$$subdir\" = .; then :; else \\\n+\t    test -d \"$(distdir)/$$subdir\" \\\n+\t    || $(MKDIR_P) \"$(distdir)/$$subdir\" \\\n+\t    || exit 1; \\\n+\t  fi; \\\n+\tdone\n+\t@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \\\n+\t  if test \"$$subdir\" = .; then :; else \\\n+\t    dir1=$$subdir; dir2=\"$(distdir)/$$subdir\"; \\\n+\t    $(am__relativize); \\\n+\t    new_distdir=$$reldir; \\\n+\t    dir1=$$subdir; dir2=\"$(top_distdir)\"; \\\n+\t    $(am__relativize); \\\n+\t    new_top_distdir=$$reldir; \\\n+\t    echo \" (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) top_distdir=\"$$new_top_distdir\" distdir=\"$$new_distdir\" \\\\\"; \\\n+\t    echo \"     am__remove_distdir=: am__skip_length_check=: am__skip_mode_fix=: distdir)\"; \\\n+\t    ($(am__cd) $$subdir && \\\n+\t      $(MAKE) $(AM_MAKEFLAGS) \\\n+\t        top_distdir=\"$$new_top_distdir\" \\\n+\t        distdir=\"$$new_distdir\" \\\n+\t\tam__remove_distdir=: \\\n+\t\tam__skip_length_check=: \\\n+\t\tam__skip_mode_fix=: \\\n+\t        distdir) \\\n+\t      || exit 1; \\\n+\t  fi; \\\n+\tdone\n+\t-test -n \"$(am__skip_mode_fix)\" \\\n+\t|| find \"$(distdir)\" -type d ! -perm -755 \\\n+\t\t-exec chmod u+rwx,go+rx {} \\; -o \\\n+\t  ! -type d ! -perm -444 -links 1 -exec chmod a+r {} \\; -o \\\n+\t  ! -type d ! -perm -400 -exec chmod a+r {} \\; -o \\\n+\t  ! -type d ! -perm -444 -exec $(install_sh) -c -m a+r {} {} \\; \\\n+\t|| chmod -R a+r \"$(distdir)\"\n+dist-gzip: distdir\n+\ttardir=$(distdir) && $(am__tar) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).tar.gz\n+\t$(am__remove_distdir)\n+\n+dist-bzip2: distdir\n+\ttardir=$(distdir) && $(am__tar) | BZIP2=$${BZIP2--9} bzip2 -c >$(distdir).tar.bz2\n+\t$(am__remove_distdir)\n+\n+dist-lzip: distdir\n+\ttardir=$(distdir) && $(am__tar) | lzip -c $${LZIP_OPT--9} >$(distdir).tar.lz\n+\t$(am__remove_distdir)\n+\n+dist-lzma: distdir\n+\ttardir=$(distdir) && $(am__tar) | lzma -9 -c >$(distdir).tar.lzma\n+\t$(am__remove_distdir)\n+\n+dist-xz: distdir\n+\ttardir=$(distdir) && $(am__tar) | XZ_OPT=$${XZ_OPT--e} xz -c >$(distdir).tar.xz\n+\t$(am__remove_distdir)\n+\n+dist-tarZ: distdir\n+\ttardir=$(distdir) && $(am__tar) | compress -c >$(distdir).tar.Z\n+\t$(am__remove_distdir)\n+\n+dist-shar: distdir\n+\tshar $(distdir) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).shar.gz\n+\t$(am__remove_distdir)\n+\n+dist-zip: distdir\n+\t-rm -f $(distdir).zip\n+\tzip -rq $(distdir).zip $(distdir)\n+\t$(am__remove_distdir)\n+\n+dist dist-all: distdir\n+\ttardir=$(distdir) && $(am__tar) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).tar.gz\n+\t$(am__remove_distdir)\n+\n+# This target untars the dist file and tries a VPATH configuration.  Then\n+# it guarantees that the distribution is self-contained by making another\n+# tarfile.\n+distcheck: dist\n+\tcase '$(DIST_ARCHIVES)' in \\\n+\t*.tar.gz*) \\\n+\t  GZIP=$(GZIP_ENV) gzip -dc $(distdir).tar.gz | $(am__untar) ;;\\\n+\t*.tar.bz2*) \\\n+\t  bzip2 -dc $(distdir).tar.bz2 | $(am__untar) ;;\\\n+\t*.tar.lzma*) \\\n+\t  lzma -dc $(distdir).tar.lzma | $(am__untar) ;;\\\n+\t*.tar.lz*) \\\n+\t  lzip -dc $(distdir).tar.lz | $(am__untar) ;;\\\n+\t*.tar.xz*) \\\n+\t  xz -dc $(distdir).tar.xz | $(am__untar) ;;\\\n+\t*.tar.Z*) \\\n+\t  uncompress -c $(distdir).tar.Z | $(am__untar) ;;\\\n+\t*.shar.gz*) \\\n+\t  GZIP=$(GZIP_ENV) gzip -dc $(distdir).shar.gz | unshar ;;\\\n+\t*.zip*) \\\n+\t  unzip $(distdir).zip ;;\\\n+\tesac\n+\tchmod -R a-w $(distdir); chmod a+w $(distdir)\n+\tmkdir $(distdir)/_build\n+\tmkdir $(distdir)/_inst\n+\tchmod a-w $(distdir)\n+\ttest -d $(distdir)/_build || exit 0; \\\n+\tdc_install_base=`$(am__cd) $(distdir)/_inst && pwd | sed -e 's,^[^:\\\\/]:[\\\\/],/,'` \\\n+\t  && dc_destdir=\"$${TMPDIR-/tmp}/am-dc-$$$$/\" \\\n+\t  && am__cwd=`pwd` \\\n+\t  && $(am__cd) $(distdir)/_build \\\n+\t  && ../configure --srcdir=.. --prefix=\"$$dc_install_base\" \\\n+\t    $(AM_DISTCHECK_CONFIGURE_FLAGS) \\\n+\t    $(DISTCHECK_CONFIGURE_FLAGS) \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) dvi \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) check \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) install \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) installcheck \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) uninstall \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) distuninstallcheck_dir=\"$$dc_install_base\" \\\n+\t        distuninstallcheck \\\n+\t  && chmod -R a-w \"$$dc_install_base\" \\\n+\t  && ({ \\\n+\t       (cd ../.. && umask 077 && mkdir \"$$dc_destdir\") \\\n+\t       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR=\"$$dc_destdir\" install \\\n+\t       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR=\"$$dc_destdir\" uninstall \\\n+\t       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR=\"$$dc_destdir\" \\\n+\t            distuninstallcheck_dir=\"$$dc_destdir\" distuninstallcheck; \\\n+\t      } || { rm -rf \"$$dc_destdir\"; exit 1; }) \\\n+\t  && rm -rf \"$$dc_destdir\" \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) dist \\\n+\t  && rm -rf $(DIST_ARCHIVES) \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) distcleancheck \\\n+\t  && cd \"$$am__cwd\" \\\n+\t  || exit 1\n+\t$(am__remove_distdir)\n+\t@(echo \"$(distdir) archives ready for distribution: \"; \\\n+\t  list='$(DIST_ARCHIVES)'; for i in $$list; do echo $$i; done) | \\\n+\t  sed -e 1h -e 1s/./=/g -e 1p -e 1x -e '$$p' -e '$$x'\n+distuninstallcheck:\n+\t@test -n '$(distuninstallcheck_dir)' || { \\\n+\t  echo 'ERROR: trying to run $@ with an empty' \\\n+\t       '$$(distuninstallcheck_dir)' >&2; \\\n+\t  exit 1; \\\n+\t}; \\\n+\t$(am__cd) '$(distuninstallcheck_dir)' || { \\\n+\t  echo 'ERROR: cannot chdir into $(distuninstallcheck_dir)' >&2; \\\n+\t  exit 1; \\\n+\t}; \\\n+\ttest `$(am__distuninstallcheck_listfiles) | wc -l` -eq 0 \\\n+\t   || { echo \"ERROR: files left after uninstall:\" ; \\\n+\t        if test -n \"$(DESTDIR)\"; then \\\n+\t          echo \"  (check DESTDIR support)\"; \\\n+\t        fi ; \\\n+\t        $(distuninstallcheck_listfiles) ; \\\n+\t        exit 1; } >&2\n+distcleancheck: distclean\n+\t@if test '$(srcdir)' = . ; then \\\n+\t  echo \"ERROR: distcleancheck can only run from a VPATH build\" ; \\\n+\t  exit 1 ; \\\n+\tfi\n+\t@test `$(distcleancheck_listfiles) | wc -l` -eq 0 \\\n+\t  || { echo \"ERROR: files left in build directory after distclean:\" ; \\\n+\t       $(distcleancheck_listfiles) ; \\\n+\t       exit 1; } >&2\n+check-am: all-am\n+check: check-recursive\n+all-am: Makefile\n+installdirs: installdirs-recursive\n+installdirs-am:\n+install: install-recursive\n+install-exec: install-exec-recursive\n+install-data: install-data-recursive\n+uninstall: uninstall-recursive\n+\n+install-am: all-am\n+\t@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am\n+\n+installcheck: installcheck-recursive\n+install-strip:\n+\tif test -z '$(STRIP)'; then \\\n+\t  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n+\t    install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n+\t      install; \\\n+\telse \\\n+\t  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n+\t    install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n+\t    \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\" install; \\\n+\tfi\n+mostlyclean-generic:\n+\n+clean-generic:\n+\n+distclean-generic:\n+\t-test -z \"$(CONFIG_CLEAN_FILES)\" || rm -f $(CONFIG_CLEAN_FILES)\n+\t-test . = \"$(srcdir)\" || test -z \"$(CONFIG_CLEAN_VPATH_FILES)\" || rm -f $(CONFIG_CLEAN_VPATH_FILES)\n+\n+maintainer-clean-generic:\n+\t@echo \"This command is intended for maintainers to use\"\n+\t@echo \"it deletes files that may require special tools to rebuild.\"\n+clean: clean-recursive\n+\n+clean-am: clean-generic clean-libtool mostlyclean-am\n+\n+distclean: distclean-recursive\n+\t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n+\t-rm -f Makefile\n+distclean-am: clean-am distclean-generic distclean-libtool \\\n+\tdistclean-tags\n+\n+dvi: dvi-recursive\n+\n+dvi-am:\n+\n+html: html-recursive\n+\n+html-am:\n+\n+info: info-recursive\n+\n+info-am:\n+\n+install-data-am:\n+\n+install-dvi: install-dvi-recursive\n+\n+install-dvi-am:\n+\n+install-exec-am:\n+\n+install-html: install-html-recursive\n+\n+install-html-am:\n+\n+install-info: install-info-recursive\n+\n+install-info-am:\n+\n+install-man:\n+\n+install-pdf: install-pdf-recursive\n+\n+install-pdf-am:\n+\n+install-ps: install-ps-recursive\n+\n+install-ps-am:\n+\n+installcheck-am:\n+\n+maintainer-clean: maintainer-clean-recursive\n+\t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n+\t-rm -rf $(top_srcdir)/autom4te.cache\n+\t-rm -f Makefile\n+maintainer-clean-am: distclean-am maintainer-clean-generic\n+\n+mostlyclean: mostlyclean-recursive\n+\n+mostlyclean-am: mostlyclean-generic mostlyclean-libtool\n+\n+pdf: pdf-recursive\n+\n+pdf-am:\n+\n+ps: ps-recursive\n+\n+ps-am:\n+\n+uninstall-am:\n+\n+.MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) ctags-recursive \\\n+\tinstall-am install-strip tags-recursive\n+\n+.PHONY: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) CTAGS GTAGS \\\n+\tall all-am am--refresh check check-am clean clean-generic \\\n+\tclean-libtool ctags ctags-recursive dist dist-all dist-bzip2 \\\n+\tdist-gzip dist-lzip dist-lzma dist-shar dist-tarZ dist-xz \\\n+\tdist-zip distcheck distclean distclean-generic \\\n+\tdistclean-libtool distclean-tags distcleancheck distdir \\\n+\tdistuninstallcheck dvi dvi-am html html-am info info-am \\\n+\tinstall install-am install-data install-data-am install-dvi \\\n+\tinstall-dvi-am install-exec install-exec-am install-html \\\n+\tinstall-html-am install-info install-info-am install-man \\\n+\tinstall-pdf install-pdf-am install-ps install-ps-am \\\n+\tinstall-strip installcheck installcheck-am installdirs \\\n+\tinstalldirs-am maintainer-clean maintainer-clean-generic \\\n+\tmostlyclean mostlyclean-generic mostlyclean-libtool pdf pdf-am \\\n+\tps ps-am tags tags-recursive uninstall uninstall-am\n+\n+\n+# Tell versions [3.59,3.63) of GNU make to not export all variables.\n+# Otherwise a system limit (for SysV at least) may be exceeded.\n+.NOEXPORT:"}, {"sha": "0f80703605265661e6efde8aa62d6f6e53e7680a", "filename": "libsanitizer/README.gcc", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2FREADME.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2FREADME.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FREADME.gcc?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,4 @@\n+The AddressSanitizer (http://code.google.com/p/address-sanitizer) is\n+a project developed by Google Inc. The source files of the project\n+are hosted at http://llvm.org/svn/llvm-project/compiler-rt. These files\n+are the ones in the asan subdirectory of that project."}, {"sha": "9f3bb9a4cbff0798b810a56e4895558348782e0a", "filename": "libsanitizer/aclocal.m4", "status": "added", "additions": 9599, "deletions": 0, "changes": 9599, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Faclocal.m4?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932"}, {"sha": "c76c15835933b301c6ef1113360567aa6cb270ea", "filename": "libsanitizer/asan/Makefile.am", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2FMakefile.am?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,76 @@\n+AM_CPPFLAGS = -I $(top_srcdir)/include -I $(top_srcdir)\n+ \n+DEFS = -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -DASAN_HAS_EXCEPTIONS=1 -DASAN_FLEXIBLE_MAPPING_AND_OFFSET=0 -DASAN_NEEDS_SEGV=1\n+AM_CXXFLAGS = -Wall -W -Wno-unused-parameter -Wwrite-strings -pedantic -Wno-long-long  -fPIC -fno-builtin -fno-exceptions -fomit-frame-pointer -funwind-tables -fvisibility=hidden -Wno-variadic-macros -Wno-c99-extensions \n+ACLOCAL_AMFLAGS = -I m4\n+\n+toolexeclib_LTLIBRARIES = libasan.la\n+\n+asan_files = \\\n+\tasan_allocator.cc \\\n+\tasan_interceptors.cc \\\n+\tasan_mac.cc \\\n+\tasan_malloc_mac.cc \\\n+\tasan_new_delete.cc \\\n+\tasan_posix.cc \\\n+\tasan_rtl.cc \\\n+\tasan_stats.cc \\\n+\tasan_thread_registry.cc \\\n+\tasan_globals.cc \\\n+\tasan_linux.cc \\\n+\tasan_malloc_linux.cc \\\n+\tasan_malloc_win.cc \\\n+\tasan_poisoning.cc \\\n+\tasan_report.cc \\\n+\tasan_stack.cc \\\n+\tasan_thread.cc \\\n+\tasan_win.cc\n+\n+libasan_la_SOURCES = $(asan_files) \n+libasan_la_LIBADD = $(top_builddir)/sanitizer_common/libsanitizer_common.la $(top_builddir)/interception/libinterception.la $(top_builddir)/../libstdc++-v3/src/libstdc++.la\n+libasan_la_LDFLAGS = -version-info `grep -v '^\\#' $(srcdir)/libtool-version` -lpthread -ldl\n+\n+# Work around what appears to be a GNU make bug handling MAKEFLAGS\n+# values defined in terms of make variables, as is the case for CC and\n+# friends when we are called from the top level Makefile.\n+AM_MAKEFLAGS = \\\n+\t\"AR_FLAGS=$(AR_FLAGS)\" \\\n+\t\"CC_FOR_BUILD=$(CC_FOR_BUILD)\" \\\n+\t\"CFLAGS=$(CFLAGS)\" \\\n+\t\"CXXFLAGS=$(CXXFLAGS)\" \\\n+\t\"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)\" \\\n+\t\"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)\" \\\n+\t\"INSTALL=$(INSTALL)\" \\\n+\t\"INSTALL_DATA=$(INSTALL_DATA)\" \\\n+\t\"INSTALL_PROGRAM=$(INSTALL_PROGRAM)\" \\\n+\t\"INSTALL_SCRIPT=$(INSTALL_SCRIPT)\" \\\n+\t\"JC1FLAGS=$(JC1FLAGS)\" \\\n+\t\"LDFLAGS=$(LDFLAGS)\" \\\n+\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+\t\"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\"MAKE=$(MAKE)\" \\\n+\t\"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)\" \\\n+\t\"PICFLAG=$(PICFLAG)\" \\\n+\t\"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)\" \\\n+\t\"SHELL=$(SHELL)\" \\\n+\t\"RUNTESTFLAGS=$(RUNTESTFLAGS)\" \\\n+\t\"exec_prefix=$(exec_prefix)\" \\\n+\t\"infodir=$(infodir)\" \\\n+\t\"libdir=$(libdir)\" \\\n+\t\"prefix=$(prefix)\" \\\n+\t\"includedir=$(includedir)\" \\\n+\t\"AR=$(AR)\" \\\n+\t\"AS=$(AS)\" \\\n+\t\"CC=$(CC)\" \\\n+\t\"CXX=$(CXX)\" \\\n+\t\"LD=$(LD)\" \\\n+\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+\t\"NM=$(NM)\" \\\n+\t\"PICFLAG=$(PICFLAG)\" \\\n+\t\"RANLIB=$(RANLIB)\" \\\n+\t\"DESTDIR=$(DESTDIR)\"\n+\n+MAKEOVERRIDES=\n+\n+## ################################################################\n+"}, {"sha": "e84dfb427c636c4b7f98336d722e658727788c6f", "filename": "libsanitizer/asan/Makefile.in", "status": "added", "additions": 631, "deletions": 0, "changes": 631, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2FMakefile.in?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,631 @@\n+# Makefile.in generated by automake 1.11.3 from Makefile.am.\n+# @configure_input@\n+\n+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n+# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software\n+# Foundation, Inc.\n+# This Makefile.in is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+# PARTICULAR PURPOSE.\n+\n+@SET_MAKE@\n+\n+VPATH = @srcdir@\n+pkgdatadir = $(datadir)/@PACKAGE@\n+pkgincludedir = $(includedir)/@PACKAGE@\n+pkglibdir = $(libdir)/@PACKAGE@\n+pkglibexecdir = $(libexecdir)/@PACKAGE@\n+am__cd = CDPATH=\"$${ZSH_VERSION+.}$(PATH_SEPARATOR)\" && cd\n+install_sh_DATA = $(install_sh) -c -m 644\n+install_sh_PROGRAM = $(install_sh) -c\n+install_sh_SCRIPT = $(install_sh) -c\n+INSTALL_HEADER = $(INSTALL_DATA)\n+transform = $(program_transform_name)\n+NORMAL_INSTALL = :\n+PRE_INSTALL = :\n+POST_INSTALL = :\n+NORMAL_UNINSTALL = :\n+PRE_UNINSTALL = :\n+POST_UNINSTALL = :\n+build_triplet = @build@\n+host_triplet = @host@\n+subdir = asan\n+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in\n+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n+am__aclocal_m4_deps = $(top_srcdir)/configure.ac\n+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n+\t$(ACLOCAL_M4)\n+mkinstalldirs = $(install_sh) -d\n+CONFIG_CLEAN_FILES =\n+CONFIG_CLEAN_VPATH_FILES =\n+am__vpath_adj_setup = srcdirstrip=`echo \"$(srcdir)\" | sed 's|.|.|g'`;\n+am__vpath_adj = case $$p in \\\n+    $(srcdir)/*) f=`echo \"$$p\" | sed \"s|^$$srcdirstrip/||\"`;; \\\n+    *) f=$$p;; \\\n+  esac;\n+am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;\n+am__install_max = 40\n+am__nobase_strip_setup = \\\n+  srcdirstrip=`echo \"$(srcdir)\" | sed 's/[].[^$$\\\\*|]/\\\\\\\\&/g'`\n+am__nobase_strip = \\\n+  for p in $$list; do echo \"$$p\"; done | sed -e \"s|$$srcdirstrip/||\"\n+am__nobase_list = $(am__nobase_strip_setup); \\\n+  for p in $$list; do echo \"$$p $$p\"; done | \\\n+  sed \"s| $$srcdirstrip/| |;\"' / .*\\//!s/ .*/ ./; s,\\( .*\\)/[^/]*$$,\\1,' | \\\n+  $(AWK) 'BEGIN { files[\".\"] = \"\" } { files[$$2] = files[$$2] \" \" $$1; \\\n+    if (++n[$$2] == $(am__install_max)) \\\n+      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = \"\" } } \\\n+    END { for (dir in files) print dir, files[dir] }'\n+am__base_list = \\\n+  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\\n/ /g' | \\\n+  sed '$$!N;$$!N;$$!N;$$!N;s/\\n/ /g'\n+am__uninstall_files_from_dir = { \\\n+  test -z \"$$files\" \\\n+    || { test ! -d \"$$dir\" && test ! -f \"$$dir\" && test ! -r \"$$dir\"; } \\\n+    || { echo \" ( cd '$$dir' && rm -f\" $$files \")\"; \\\n+         $(am__cd) \"$$dir\" && rm -f $$files; }; \\\n+  }\n+am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\"\n+LTLIBRARIES = $(toolexeclib_LTLIBRARIES)\n+libasan_la_DEPENDENCIES =  \\\n+\t$(top_builddir)/sanitizer_common/libsanitizer_common.la \\\n+\t$(top_builddir)/interception/libinterception.la \\\n+\t$(top_builddir)/../libstdc++-v3/src/libstdc++.la\n+am__objects_1 = asan_allocator.lo asan_interceptors.lo asan_mac.lo \\\n+\tasan_malloc_mac.lo asan_new_delete.lo asan_posix.lo \\\n+\tasan_rtl.lo asan_stats.lo asan_thread_registry.lo \\\n+\tasan_globals.lo asan_linux.lo asan_malloc_linux.lo \\\n+\tasan_malloc_win.lo asan_poisoning.lo asan_report.lo \\\n+\tasan_stack.lo asan_thread.lo asan_win.lo\n+am_libasan_la_OBJECTS = $(am__objects_1)\n+libasan_la_OBJECTS = $(am_libasan_la_OBJECTS)\n+libasan_la_LINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) \\\n+\t$(LIBTOOLFLAGS) --mode=link $(CXXLD) $(AM_CXXFLAGS) \\\n+\t$(CXXFLAGS) $(libasan_la_LDFLAGS) $(LDFLAGS) -o $@\n+DEFAULT_INCLUDES = -I.@am__isrc@\n+depcomp = $(SHELL) $(top_srcdir)/depcomp\n+am__depfiles_maybe = depfiles\n+am__mv = mv -f\n+CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n+\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)\n+LTCXXCOMPILE = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n+\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)\n+CXXLD = $(CXX)\n+CXXLINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=link $(CXXLD) $(AM_CXXFLAGS) $(CXXFLAGS) $(AM_LDFLAGS) \\\n+\t$(LDFLAGS) -o $@\n+SOURCES = $(libasan_la_SOURCES)\n+DIST_SOURCES = $(libasan_la_SOURCES)\n+ETAGS = etags\n+CTAGS = ctags\n+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)\n+ACLOCAL = @ACLOCAL@\n+AMTAR = @AMTAR@\n+AR = @AR@\n+AUTOCONF = @AUTOCONF@\n+AUTOHEADER = @AUTOHEADER@\n+AUTOMAKE = @AUTOMAKE@\n+AWK = @AWK@\n+CC = @CC@\n+CCAS = @CCAS@\n+CCASDEPMODE = @CCASDEPMODE@\n+CCASFLAGS = @CCASFLAGS@\n+CCDEPMODE = @CCDEPMODE@\n+CFLAGS = @CFLAGS@\n+CPP = @CPP@\n+CPPFLAGS = @CPPFLAGS@\n+CXX = @CXX@\n+CXXCPP = @CXXCPP@\n+CXXDEPMODE = @CXXDEPMODE@\n+CXXFLAGS = @CXXFLAGS@\n+CYGPATH_W = @CYGPATH_W@\n+DEFS = -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -DASAN_HAS_EXCEPTIONS=1 -DASAN_FLEXIBLE_MAPPING_AND_OFFSET=0 -DASAN_NEEDS_SEGV=1\n+DEPDIR = @DEPDIR@\n+DLLTOOL = @DLLTOOL@\n+DSYMUTIL = @DSYMUTIL@\n+DUMPBIN = @DUMPBIN@\n+ECHO_C = @ECHO_C@\n+ECHO_N = @ECHO_N@\n+ECHO_T = @ECHO_T@\n+EGREP = @EGREP@\n+EXEEXT = @EXEEXT@\n+FGREP = @FGREP@\n+GREP = @GREP@\n+INSTALL = @INSTALL@\n+INSTALL_DATA = @INSTALL_DATA@\n+INSTALL_PROGRAM = @INSTALL_PROGRAM@\n+INSTALL_SCRIPT = @INSTALL_SCRIPT@\n+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@\n+LD = @LD@\n+LDFLAGS = @LDFLAGS@\n+LIBOBJS = @LIBOBJS@\n+LIBS = @LIBS@\n+LIBTOOL = @LIBTOOL@\n+LIPO = @LIPO@\n+LN_S = @LN_S@\n+LTLIBOBJS = @LTLIBOBJS@\n+MAKEINFO = @MAKEINFO@\n+MANIFEST_TOOL = @MANIFEST_TOOL@\n+MKDIR_P = @MKDIR_P@\n+NM = @NM@\n+NMEDIT = @NMEDIT@\n+OBJDUMP = @OBJDUMP@\n+OBJEXT = @OBJEXT@\n+OTOOL = @OTOOL@\n+OTOOL64 = @OTOOL64@\n+PACKAGE = @PACKAGE@\n+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\n+PACKAGE_NAME = @PACKAGE_NAME@\n+PACKAGE_STRING = @PACKAGE_STRING@\n+PACKAGE_TARNAME = @PACKAGE_TARNAME@\n+PACKAGE_URL = @PACKAGE_URL@\n+PACKAGE_VERSION = @PACKAGE_VERSION@\n+PATH_SEPARATOR = @PATH_SEPARATOR@\n+RANLIB = @RANLIB@\n+SED = @SED@\n+SET_MAKE = @SET_MAKE@\n+SHELL = @SHELL@\n+STRIP = @STRIP@\n+VERSION = @VERSION@\n+abs_builddir = @abs_builddir@\n+abs_srcdir = @abs_srcdir@\n+abs_top_builddir = @abs_top_builddir@\n+abs_top_srcdir = @abs_top_srcdir@\n+ac_ct_AR = @ac_ct_AR@\n+ac_ct_CC = @ac_ct_CC@\n+ac_ct_CXX = @ac_ct_CXX@\n+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@\n+am__include = @am__include@\n+am__leading_dot = @am__leading_dot@\n+am__quote = @am__quote@\n+am__tar = @am__tar@\n+am__untar = @am__untar@\n+bindir = @bindir@\n+build = @build@\n+build_alias = @build_alias@\n+build_cpu = @build_cpu@\n+build_os = @build_os@\n+build_vendor = @build_vendor@\n+builddir = @builddir@\n+datadir = @datadir@\n+datarootdir = @datarootdir@\n+docdir = @docdir@\n+dvidir = @dvidir@\n+enable_shared = @enable_shared@\n+enable_static = @enable_static@\n+exec_prefix = @exec_prefix@\n+host = @host@\n+host_alias = @host_alias@\n+host_cpu = @host_cpu@\n+host_os = @host_os@\n+host_vendor = @host_vendor@\n+htmldir = @htmldir@\n+includedir = @includedir@\n+infodir = @infodir@\n+install_sh = @install_sh@\n+libdir = @libdir@\n+libexecdir = @libexecdir@\n+localedir = @localedir@\n+localstatedir = @localstatedir@\n+mandir = @mandir@\n+mkdir_p = @mkdir_p@\n+oldincludedir = @oldincludedir@\n+pdfdir = @pdfdir@\n+prefix = @prefix@\n+program_transform_name = @program_transform_name@\n+psdir = @psdir@\n+sbindir = @sbindir@\n+sharedstatedir = @sharedstatedir@\n+srcdir = @srcdir@\n+sysconfdir = @sysconfdir@\n+target_alias = @target_alias@\n+toolexecdir = @toolexecdir@\n+toolexeclibdir = @toolexeclibdir@\n+top_build_prefix = @top_build_prefix@\n+top_builddir = @top_builddir@\n+top_srcdir = @top_srcdir@\n+AM_CPPFLAGS = -I $(top_srcdir)/include -I $(top_srcdir)\n+AM_CXXFLAGS = -Wall -W -Wno-unused-parameter -Wwrite-strings -pedantic -Wno-long-long  -fPIC -fno-builtin -fno-exceptions -fomit-frame-pointer -funwind-tables -fvisibility=hidden -Wno-variadic-macros -Wno-c99-extensions \n+ACLOCAL_AMFLAGS = -I m4\n+toolexeclib_LTLIBRARIES = libasan.la\n+asan_files = \\\n+\tasan_allocator.cc \\\n+\tasan_interceptors.cc \\\n+\tasan_mac.cc \\\n+\tasan_malloc_mac.cc \\\n+\tasan_new_delete.cc \\\n+\tasan_posix.cc \\\n+\tasan_rtl.cc \\\n+\tasan_stats.cc \\\n+\tasan_thread_registry.cc \\\n+\tasan_globals.cc \\\n+\tasan_linux.cc \\\n+\tasan_malloc_linux.cc \\\n+\tasan_malloc_win.cc \\\n+\tasan_poisoning.cc \\\n+\tasan_report.cc \\\n+\tasan_stack.cc \\\n+\tasan_thread.cc \\\n+\tasan_win.cc\n+\n+libasan_la_SOURCES = $(asan_files) \n+libasan_la_LIBADD = $(top_builddir)/sanitizer_common/libsanitizer_common.la $(top_builddir)/interception/libinterception.la $(top_builddir)/../libstdc++-v3/src/libstdc++.la\n+libasan_la_LDFLAGS = -version-info `grep -v '^\\#' $(srcdir)/libtool-version` -lpthread -ldl\n+\n+# Work around what appears to be a GNU make bug handling MAKEFLAGS\n+# values defined in terms of make variables, as is the case for CC and\n+# friends when we are called from the top level Makefile.\n+AM_MAKEFLAGS = \\\n+\t\"AR_FLAGS=$(AR_FLAGS)\" \\\n+\t\"CC_FOR_BUILD=$(CC_FOR_BUILD)\" \\\n+\t\"CFLAGS=$(CFLAGS)\" \\\n+\t\"CXXFLAGS=$(CXXFLAGS)\" \\\n+\t\"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)\" \\\n+\t\"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)\" \\\n+\t\"INSTALL=$(INSTALL)\" \\\n+\t\"INSTALL_DATA=$(INSTALL_DATA)\" \\\n+\t\"INSTALL_PROGRAM=$(INSTALL_PROGRAM)\" \\\n+\t\"INSTALL_SCRIPT=$(INSTALL_SCRIPT)\" \\\n+\t\"JC1FLAGS=$(JC1FLAGS)\" \\\n+\t\"LDFLAGS=$(LDFLAGS)\" \\\n+\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+\t\"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\"MAKE=$(MAKE)\" \\\n+\t\"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)\" \\\n+\t\"PICFLAG=$(PICFLAG)\" \\\n+\t\"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)\" \\\n+\t\"SHELL=$(SHELL)\" \\\n+\t\"RUNTESTFLAGS=$(RUNTESTFLAGS)\" \\\n+\t\"exec_prefix=$(exec_prefix)\" \\\n+\t\"infodir=$(infodir)\" \\\n+\t\"libdir=$(libdir)\" \\\n+\t\"prefix=$(prefix)\" \\\n+\t\"includedir=$(includedir)\" \\\n+\t\"AR=$(AR)\" \\\n+\t\"AS=$(AS)\" \\\n+\t\"CC=$(CC)\" \\\n+\t\"CXX=$(CXX)\" \\\n+\t\"LD=$(LD)\" \\\n+\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+\t\"NM=$(NM)\" \\\n+\t\"PICFLAG=$(PICFLAG)\" \\\n+\t\"RANLIB=$(RANLIB)\" \\\n+\t\"DESTDIR=$(DESTDIR)\"\n+\n+MAKEOVERRIDES = \n+all: all-am\n+\n+.SUFFIXES:\n+.SUFFIXES: .cc .lo .o .obj\n+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)\n+\t@for dep in $?; do \\\n+\t  case '$(am__configure_deps)' in \\\n+\t    *$$dep*) \\\n+\t      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \\\n+\t        && { if test -f $@; then exit 0; else break; fi; }; \\\n+\t      exit 1;; \\\n+\t  esac; \\\n+\tdone; \\\n+\techo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign asan/Makefile'; \\\n+\t$(am__cd) $(top_srcdir) && \\\n+\t  $(AUTOMAKE) --foreign asan/Makefile\n+.PRECIOUS: Makefile\n+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n+\t@case '$?' in \\\n+\t  *config.status*) \\\n+\t    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \\\n+\t  *) \\\n+\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \\\n+\t    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \\\n+\tesac;\n+\n+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)\n+\tcd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh\n+\n+$(top_srcdir)/configure:  $(am__configure_deps)\n+\tcd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh\n+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)\n+\tcd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh\n+$(am__aclocal_m4_deps):\n+install-toolexeclibLTLIBRARIES: $(toolexeclib_LTLIBRARIES)\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(toolexeclibdir)\" || $(MKDIR_P) \"$(DESTDIR)$(toolexeclibdir)\"\n+\t@list='$(toolexeclib_LTLIBRARIES)'; test -n \"$(toolexeclibdir)\" || list=; \\\n+\tlist2=; for p in $$list; do \\\n+\t  if test -f $$p; then \\\n+\t    list2=\"$$list2 $$p\"; \\\n+\t  else :; fi; \\\n+\tdone; \\\n+\ttest -z \"$$list2\" || { \\\n+\t  echo \" $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 '$(DESTDIR)$(toolexeclibdir)'\"; \\\n+\t  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 \"$(DESTDIR)$(toolexeclibdir)\"; \\\n+\t}\n+\n+uninstall-toolexeclibLTLIBRARIES:\n+\t@$(NORMAL_UNINSTALL)\n+\t@list='$(toolexeclib_LTLIBRARIES)'; test -n \"$(toolexeclibdir)\" || list=; \\\n+\tfor p in $$list; do \\\n+\t  $(am__strip_dir) \\\n+\t  echo \" $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f '$(DESTDIR)$(toolexeclibdir)/$$f'\"; \\\n+\t  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f \"$(DESTDIR)$(toolexeclibdir)/$$f\"; \\\n+\tdone\n+\n+clean-toolexeclibLTLIBRARIES:\n+\t-test -z \"$(toolexeclib_LTLIBRARIES)\" || rm -f $(toolexeclib_LTLIBRARIES)\n+\t@list='$(toolexeclib_LTLIBRARIES)'; for p in $$list; do \\\n+\t  dir=\"`echo $$p | sed -e 's|/[^/]*$$||'`\"; \\\n+\t  test \"$$dir\" != \"$$p\" || dir=.; \\\n+\t  echo \"rm -f \\\"$${dir}/so_locations\\\"\"; \\\n+\t  rm -f \"$${dir}/so_locations\"; \\\n+\tdone\n+libasan.la: $(libasan_la_OBJECTS) $(libasan_la_DEPENDENCIES) $(EXTRA_libasan_la_DEPENDENCIES) \n+\t$(libasan_la_LINK) -rpath $(toolexeclibdir) $(libasan_la_OBJECTS) $(libasan_la_LIBADD) $(LIBS)\n+\n+mostlyclean-compile:\n+\t-rm -f *.$(OBJEXT)\n+\n+distclean-compile:\n+\t-rm -f *.tab.c\n+\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_allocator.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_globals.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_interceptors.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_linux.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_mac.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_malloc_linux.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_malloc_mac.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_malloc_win.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_new_delete.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_poisoning.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_posix.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_report.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_rtl.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_stack.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_stats.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_thread.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_thread_registry.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_win.Plo@am__quote@\n+\n+.cc.o:\n+@am__fastdepCXX_TRUE@\t$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(CXXCOMPILE) -c -o $@ $<\n+\n+.cc.obj:\n+@am__fastdepCXX_TRUE@\t$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`\n+\n+.cc.lo:\n+@am__fastdepCXX_TRUE@\t$(LTCXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='$<' object='$@' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(LTCXXCOMPILE) -c -o $@ $<\n+\n+mostlyclean-libtool:\n+\t-rm -f *.lo\n+\n+clean-libtool:\n+\t-rm -rf .libs _libs\n+\n+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)\n+\tlist='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\tmkid -fID $$unique\n+tags: TAGS\n+\n+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \\\n+\t\t$(TAGS_FILES) $(LISP)\n+\tset x; \\\n+\there=`pwd`; \\\n+\tlist='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\tshift; \\\n+\tif test -z \"$(ETAGS_ARGS)$$*$$unique\"; then :; else \\\n+\t  test -n \"$$unique\" || unique=$$empty_fix; \\\n+\t  if test $$# -gt 0; then \\\n+\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n+\t      \"$$@\" $$unique; \\\n+\t  else \\\n+\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n+\t      $$unique; \\\n+\t  fi; \\\n+\tfi\n+ctags: CTAGS\n+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \\\n+\t\t$(TAGS_FILES) $(LISP)\n+\tlist='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\ttest -z \"$(CTAGS_ARGS)$$unique\" \\\n+\t  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \\\n+\t     $$unique\n+\n+GTAGS:\n+\there=`$(am__cd) $(top_builddir) && pwd` \\\n+\t  && $(am__cd) $(top_srcdir) \\\n+\t  && gtags -i $(GTAGS_ARGS) \"$$here\"\n+\n+distclean-tags:\n+\t-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags\n+\n+distdir: $(DISTFILES)\n+\t@srcdirstrip=`echo \"$(srcdir)\" | sed 's/[].[^$$\\\\*]/\\\\\\\\&/g'`; \\\n+\ttopsrcdirstrip=`echo \"$(top_srcdir)\" | sed 's/[].[^$$\\\\*]/\\\\\\\\&/g'`; \\\n+\tlist='$(DISTFILES)'; \\\n+\t  dist_files=`for file in $$list; do echo $$file; done | \\\n+\t  sed -e \"s|^$$srcdirstrip/||;t\" \\\n+\t      -e \"s|^$$topsrcdirstrip/|$(top_builddir)/|;t\"`; \\\n+\tcase $$dist_files in \\\n+\t  */*) $(MKDIR_P) `echo \"$$dist_files\" | \\\n+\t\t\t   sed '/\\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \\\n+\t\t\t   sort -u` ;; \\\n+\tesac; \\\n+\tfor file in $$dist_files; do \\\n+\t  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \\\n+\t  if test -d $$d/$$file; then \\\n+\t    dir=`echo \"/$$file\" | sed -e 's,/[^/]*$$,,'`; \\\n+\t    if test -d \"$(distdir)/$$file\"; then \\\n+\t      find \"$(distdir)/$$file\" -type d ! -perm -700 -exec chmod u+rwx {} \\;; \\\n+\t    fi; \\\n+\t    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \\\n+\t      cp -fpR $(srcdir)/$$file \"$(distdir)$$dir\" || exit 1; \\\n+\t      find \"$(distdir)/$$file\" -type d ! -perm -700 -exec chmod u+rwx {} \\;; \\\n+\t    fi; \\\n+\t    cp -fpR $$d/$$file \"$(distdir)$$dir\" || exit 1; \\\n+\t  else \\\n+\t    test -f \"$(distdir)/$$file\" \\\n+\t    || cp -p $$d/$$file \"$(distdir)/$$file\" \\\n+\t    || exit 1; \\\n+\t  fi; \\\n+\tdone\n+check-am: all-am\n+check: check-am\n+all-am: Makefile $(LTLIBRARIES)\n+installdirs:\n+\tfor dir in \"$(DESTDIR)$(toolexeclibdir)\"; do \\\n+\t  test -z \"$$dir\" || $(MKDIR_P) \"$$dir\"; \\\n+\tdone\n+install: install-am\n+install-exec: install-exec-am\n+install-data: install-data-am\n+uninstall: uninstall-am\n+\n+install-am: all-am\n+\t@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am\n+\n+installcheck: installcheck-am\n+install-strip:\n+\tif test -z '$(STRIP)'; then \\\n+\t  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n+\t    install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n+\t      install; \\\n+\telse \\\n+\t  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n+\t    install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n+\t    \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\" install; \\\n+\tfi\n+mostlyclean-generic:\n+\n+clean-generic:\n+\n+distclean-generic:\n+\t-test -z \"$(CONFIG_CLEAN_FILES)\" || rm -f $(CONFIG_CLEAN_FILES)\n+\t-test . = \"$(srcdir)\" || test -z \"$(CONFIG_CLEAN_VPATH_FILES)\" || rm -f $(CONFIG_CLEAN_VPATH_FILES)\n+\n+maintainer-clean-generic:\n+\t@echo \"This command is intended for maintainers to use\"\n+\t@echo \"it deletes files that may require special tools to rebuild.\"\n+clean: clean-am\n+\n+clean-am: clean-generic clean-libtool clean-toolexeclibLTLIBRARIES \\\n+\tmostlyclean-am\n+\n+distclean: distclean-am\n+\t-rm -rf ./$(DEPDIR)\n+\t-rm -f Makefile\n+distclean-am: clean-am distclean-compile distclean-generic \\\n+\tdistclean-tags\n+\n+dvi: dvi-am\n+\n+dvi-am:\n+\n+html: html-am\n+\n+html-am:\n+\n+info: info-am\n+\n+info-am:\n+\n+install-data-am:\n+\n+install-dvi: install-dvi-am\n+\n+install-dvi-am:\n+\n+install-exec-am: install-toolexeclibLTLIBRARIES\n+\n+install-html: install-html-am\n+\n+install-html-am:\n+\n+install-info: install-info-am\n+\n+install-info-am:\n+\n+install-man:\n+\n+install-pdf: install-pdf-am\n+\n+install-pdf-am:\n+\n+install-ps: install-ps-am\n+\n+install-ps-am:\n+\n+installcheck-am:\n+\n+maintainer-clean: maintainer-clean-am\n+\t-rm -rf ./$(DEPDIR)\n+\t-rm -f Makefile\n+maintainer-clean-am: distclean-am maintainer-clean-generic\n+\n+mostlyclean: mostlyclean-am\n+\n+mostlyclean-am: mostlyclean-compile mostlyclean-generic \\\n+\tmostlyclean-libtool\n+\n+pdf: pdf-am\n+\n+pdf-am:\n+\n+ps: ps-am\n+\n+ps-am:\n+\n+uninstall-am: uninstall-toolexeclibLTLIBRARIES\n+\n+.MAKE: install-am install-strip\n+\n+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \\\n+\tclean-libtool clean-toolexeclibLTLIBRARIES ctags distclean \\\n+\tdistclean-compile distclean-generic distclean-libtool \\\n+\tdistclean-tags distdir dvi dvi-am html html-am info info-am \\\n+\tinstall install-am install-data install-data-am install-dvi \\\n+\tinstall-dvi-am install-exec install-exec-am install-html \\\n+\tinstall-html-am install-info install-info-am install-man \\\n+\tinstall-pdf install-pdf-am install-ps install-ps-am \\\n+\tinstall-strip install-toolexeclibLTLIBRARIES installcheck \\\n+\tinstallcheck-am installdirs maintainer-clean \\\n+\tmaintainer-clean-generic mostlyclean mostlyclean-compile \\\n+\tmostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \\\n+\ttags uninstall uninstall-am uninstall-toolexeclibLTLIBRARIES\n+\n+\n+# Tell versions [3.59,3.63) of GNU make to not export all variables.\n+# Otherwise a system limit (for SysV at least) may be exceeded.\n+.NOEXPORT:"}, {"sha": "3a92802e9722200efc14f674a9c180852c5b09a4", "filename": "libsanitizer/asan/asan_allocator.cc", "status": "added", "additions": 1045, "deletions": 0, "changes": 1045, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_allocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_allocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_allocator.cc?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,1045 @@\n+//===-- asan_allocator.cc -------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// Implementation of ASan's memory allocator.\n+// Evey piece of memory (AsanChunk) allocated by the allocator\n+// has a left redzone of REDZONE bytes and\n+// a right redzone such that the end of the chunk is aligned by REDZONE\n+// (i.e. the right redzone is between 0 and REDZONE-1).\n+// The left redzone is always poisoned.\n+// The right redzone is poisoned on malloc, the body is poisoned on free.\n+// Once freed, a chunk is moved to a quarantine (fifo list).\n+// After quarantine, a chunk is returned to freelists.\n+//\n+// The left redzone contains ASan's internal data and the stack trace of\n+// the malloc call.\n+// Once freed, the body of the chunk contains the stack trace of the free call.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"asan_allocator.h\"\n+#include \"asan_interceptors.h\"\n+#include \"asan_internal.h\"\n+#include \"asan_lock.h\"\n+#include \"asan_mapping.h\"\n+#include \"asan_stats.h\"\n+#include \"asan_report.h\"\n+#include \"asan_thread.h\"\n+#include \"asan_thread_registry.h\"\n+#include \"sanitizer/asan_interface.h\"\n+#include \"sanitizer_common/sanitizer_atomic.h\"\n+\n+#if defined(_WIN32) && !defined(__clang__)\n+#include <intrin.h>\n+#endif\n+\n+namespace __asan {\n+\n+#define REDZONE ((uptr)(flags()->redzone))\n+static const uptr kMinAllocSize = REDZONE * 2;\n+static const u64 kMaxAvailableRam = 128ULL << 30;  // 128G\n+static const uptr kMaxThreadLocalQuarantine = 1 << 20;  // 1M\n+\n+static const uptr kMinMmapSize = (ASAN_LOW_MEMORY) ? 4UL << 17 : 4UL << 20;\n+static const uptr kMaxSizeForThreadLocalFreeList =\n+    (ASAN_LOW_MEMORY) ? 1 << 15 : 1 << 17;\n+\n+// Size classes less than kMallocSizeClassStep are powers of two.\n+// All other size classes are multiples of kMallocSizeClassStep.\n+static const uptr kMallocSizeClassStepLog = 26;\n+static const uptr kMallocSizeClassStep = 1UL << kMallocSizeClassStepLog;\n+\n+static const uptr kMaxAllowedMallocSize =\n+    (__WORDSIZE == 32) ? 3UL << 30 : 8UL << 30;\n+\n+static inline bool IsAligned(uptr a, uptr alignment) {\n+  return (a & (alignment - 1)) == 0;\n+}\n+\n+static inline uptr Log2(uptr x) {\n+  CHECK(IsPowerOfTwo(x));\n+#if !defined(_WIN32) || defined(__clang__)\n+  return __builtin_ctzl(x);\n+#elif defined(_WIN64)\n+  unsigned long ret;  // NOLINT\n+  _BitScanForward64(&ret, x);\n+  return ret;\n+#else\n+  unsigned long ret;  // NOLINT\n+  _BitScanForward(&ret, x);\n+  return ret;\n+#endif\n+}\n+\n+static inline uptr RoundUpToPowerOfTwo(uptr size) {\n+  CHECK(size);\n+  if (IsPowerOfTwo(size)) return size;\n+\n+  unsigned long up;  // NOLINT\n+#if !defined(_WIN32) || defined(__clang__)\n+  up = __WORDSIZE - 1 - __builtin_clzl(size);\n+#elif defined(_WIN64)\n+  _BitScanReverse64(&up, size);\n+#else\n+  _BitScanReverse(&up, size);\n+#endif\n+  CHECK(size < (1ULL << (up + 1)));\n+  CHECK(size > (1ULL << up));\n+  return 1UL << (up + 1);\n+}\n+\n+static inline uptr SizeClassToSize(u8 size_class) {\n+  CHECK(size_class < kNumberOfSizeClasses);\n+  if (size_class <= kMallocSizeClassStepLog) {\n+    return 1UL << size_class;\n+  } else {\n+    return (size_class - kMallocSizeClassStepLog) * kMallocSizeClassStep;\n+  }\n+}\n+\n+static inline u8 SizeToSizeClass(uptr size) {\n+  u8 res = 0;\n+  if (size <= kMallocSizeClassStep) {\n+    uptr rounded = RoundUpToPowerOfTwo(size);\n+    res = Log2(rounded);\n+  } else {\n+    res = ((size + kMallocSizeClassStep - 1) / kMallocSizeClassStep)\n+        + kMallocSizeClassStepLog;\n+  }\n+  CHECK(res < kNumberOfSizeClasses);\n+  CHECK(size <= SizeClassToSize(res));\n+  return res;\n+}\n+\n+// Given REDZONE bytes, we need to mark first size bytes\n+// as addressable and the rest REDZONE-size bytes as unaddressable.\n+static void PoisonHeapPartialRightRedzone(uptr mem, uptr size) {\n+  CHECK(size <= REDZONE);\n+  CHECK(IsAligned(mem, REDZONE));\n+  CHECK(IsPowerOfTwo(SHADOW_GRANULARITY));\n+  CHECK(IsPowerOfTwo(REDZONE));\n+  CHECK(REDZONE >= SHADOW_GRANULARITY);\n+  PoisonShadowPartialRightRedzone(mem, size, REDZONE,\n+                                  kAsanHeapRightRedzoneMagic);\n+}\n+\n+static u8 *MmapNewPagesAndPoisonShadow(uptr size) {\n+  CHECK(IsAligned(size, kPageSize));\n+  u8 *res = (u8*)MmapOrDie(size, __FUNCTION__);\n+  PoisonShadow((uptr)res, size, kAsanHeapLeftRedzoneMagic);\n+  if (flags()->debug) {\n+    Printf(\"ASAN_MMAP: [%p, %p)\\n\", res, res + size);\n+  }\n+  return res;\n+}\n+\n+// Every chunk of memory allocated by this allocator can be in one of 3 states:\n+// CHUNK_AVAILABLE: the chunk is in the free list and ready to be allocated.\n+// CHUNK_ALLOCATED: the chunk is allocated and not yet freed.\n+// CHUNK_QUARANTINE: the chunk was freed and put into quarantine zone.\n+//\n+// The pseudo state CHUNK_MEMALIGN is used to mark that the address is not\n+// the beginning of a AsanChunk (in which the actual chunk resides at\n+// this - this->used_size).\n+//\n+// The magic numbers for the enum values are taken randomly.\n+enum {\n+  CHUNK_AVAILABLE  = 0x57,\n+  CHUNK_ALLOCATED  = 0x32,\n+  CHUNK_QUARANTINE = 0x19,\n+  CHUNK_MEMALIGN   = 0xDC\n+};\n+\n+struct ChunkBase {\n+  // First 8 bytes.\n+  uptr  chunk_state : 8;\n+  uptr  alloc_tid   : 24;\n+  uptr  size_class  : 8;\n+  uptr  free_tid    : 24;\n+\n+  // Second 8 bytes.\n+  uptr alignment_log : 8;\n+  uptr used_size : FIRST_32_SECOND_64(32, 56);  // Size requested by the user.\n+\n+  // This field may overlap with the user area and thus should not\n+  // be used while the chunk is in CHUNK_ALLOCATED state.\n+  AsanChunk *next;\n+\n+  // Typically the beginning of the user-accessible memory is 'this'+REDZONE\n+  // and is also aligned by REDZONE. However, if the memory is allocated\n+  // by memalign, the alignment might be higher and the user-accessible memory\n+  // starts at the first properly aligned address after 'this'.\n+  uptr Beg() { return RoundUpTo((uptr)this + 1, 1 << alignment_log); }\n+  uptr Size() { return SizeClassToSize(size_class); }\n+  u8 SizeClass() { return size_class; }\n+};\n+\n+struct AsanChunk: public ChunkBase {\n+  u32 *compressed_alloc_stack() {\n+    return (u32*)((uptr)this + sizeof(ChunkBase));\n+  }\n+  u32 *compressed_free_stack() {\n+    return (u32*)((uptr)this + Max((uptr)REDZONE, (uptr)sizeof(ChunkBase)));\n+  }\n+\n+  // The left redzone after the ChunkBase is given to the alloc stack trace.\n+  uptr compressed_alloc_stack_size() {\n+    if (REDZONE < sizeof(ChunkBase)) return 0;\n+    return (REDZONE - sizeof(ChunkBase)) / sizeof(u32);\n+  }\n+  uptr compressed_free_stack_size() {\n+    if (REDZONE < sizeof(ChunkBase)) return 0;\n+    return (REDZONE) / sizeof(u32);\n+  }\n+};\n+\n+uptr AsanChunkView::Beg() { return chunk_->Beg(); }\n+uptr AsanChunkView::End() { return Beg() + UsedSize(); }\n+uptr AsanChunkView::UsedSize() { return chunk_->used_size; }\n+uptr AsanChunkView::AllocTid() { return chunk_->alloc_tid; }\n+uptr AsanChunkView::FreeTid() { return chunk_->free_tid; }\n+\n+void AsanChunkView::GetAllocStack(StackTrace *stack) {\n+  StackTrace::UncompressStack(stack, chunk_->compressed_alloc_stack(),\n+                              chunk_->compressed_alloc_stack_size());\n+}\n+\n+void AsanChunkView::GetFreeStack(StackTrace *stack) {\n+  StackTrace::UncompressStack(stack, chunk_->compressed_free_stack(),\n+                              chunk_->compressed_free_stack_size());\n+}\n+\n+bool AsanChunkView::AddrIsInside(uptr addr, uptr access_size, uptr *offset) {\n+  if (addr >= Beg() && (addr + access_size) <= End()) {\n+    *offset = addr - Beg();\n+    return true;\n+  }\n+  return false;\n+}\n+\n+bool AsanChunkView::AddrIsAtLeft(uptr addr, uptr access_size, uptr *offset) {\n+  if (addr < Beg()) {\n+    *offset = Beg() - addr;\n+    return true;\n+  }\n+  return false;\n+}\n+\n+bool AsanChunkView::AddrIsAtRight(uptr addr, uptr access_size, uptr *offset) {\n+  if (addr + access_size >= End()) {\n+    if (addr <= End())\n+      *offset = 0;\n+    else\n+      *offset = addr - End();\n+    return true;\n+  }\n+  return false;\n+}\n+\n+static AsanChunk *PtrToChunk(uptr ptr) {\n+  AsanChunk *m = (AsanChunk*)(ptr - REDZONE);\n+  if (m->chunk_state == CHUNK_MEMALIGN) {\n+    m = (AsanChunk*)((uptr)m - m->used_size);\n+  }\n+  return m;\n+}\n+\n+void AsanChunkFifoList::PushList(AsanChunkFifoList *q) {\n+  CHECK(q->size() > 0);\n+  if (last_) {\n+    CHECK(first_);\n+    CHECK(!last_->next);\n+    last_->next = q->first_;\n+    last_ = q->last_;\n+  } else {\n+    CHECK(!first_);\n+    last_ = q->last_;\n+    first_ = q->first_;\n+    CHECK(first_);\n+  }\n+  CHECK(last_);\n+  CHECK(!last_->next);\n+  size_ += q->size();\n+  q->clear();\n+}\n+\n+void AsanChunkFifoList::Push(AsanChunk *n) {\n+  CHECK(n->next == 0);\n+  if (last_) {\n+    CHECK(first_);\n+    CHECK(!last_->next);\n+    last_->next = n;\n+    last_ = n;\n+  } else {\n+    CHECK(!first_);\n+    last_ = first_ = n;\n+  }\n+  size_ += n->Size();\n+}\n+\n+// Interesting performance observation: this function takes up to 15% of overal\n+// allocator time. That's because *first_ has been evicted from cache long time\n+// ago. Not sure if we can or want to do anything with this.\n+AsanChunk *AsanChunkFifoList::Pop() {\n+  CHECK(first_);\n+  AsanChunk *res = first_;\n+  first_ = first_->next;\n+  if (first_ == 0)\n+    last_ = 0;\n+  CHECK(size_ >= res->Size());\n+  size_ -= res->Size();\n+  if (last_) {\n+    CHECK(!last_->next);\n+  }\n+  return res;\n+}\n+\n+// All pages we ever allocated.\n+struct PageGroup {\n+  uptr beg;\n+  uptr end;\n+  uptr size_of_chunk;\n+  uptr last_chunk;\n+  bool InRange(uptr addr) {\n+    return addr >= beg && addr < end;\n+  }\n+};\n+\n+class MallocInfo {\n+ public:\n+  explicit MallocInfo(LinkerInitialized x) : mu_(x) { }\n+\n+  AsanChunk *AllocateChunks(u8 size_class, uptr n_chunks) {\n+    AsanChunk *m = 0;\n+    AsanChunk **fl = &free_lists_[size_class];\n+    {\n+      ScopedLock lock(&mu_);\n+      for (uptr i = 0; i < n_chunks; i++) {\n+        if (!(*fl)) {\n+          *fl = GetNewChunks(size_class);\n+        }\n+        AsanChunk *t = *fl;\n+        *fl = t->next;\n+        t->next = m;\n+        CHECK(t->chunk_state == CHUNK_AVAILABLE);\n+        m = t;\n+      }\n+    }\n+    return m;\n+  }\n+\n+  void SwallowThreadLocalMallocStorage(AsanThreadLocalMallocStorage *x,\n+                                       bool eat_free_lists) {\n+    CHECK(flags()->quarantine_size > 0);\n+    ScopedLock lock(&mu_);\n+    AsanChunkFifoList *q = &x->quarantine_;\n+    if (q->size() > 0) {\n+      quarantine_.PushList(q);\n+      while (quarantine_.size() > (uptr)flags()->quarantine_size) {\n+        QuarantinePop();\n+      }\n+    }\n+    if (eat_free_lists) {\n+      for (uptr size_class = 0; size_class < kNumberOfSizeClasses;\n+           size_class++) {\n+        AsanChunk *m = x->free_lists_[size_class];\n+        while (m) {\n+          AsanChunk *t = m->next;\n+          m->next = free_lists_[size_class];\n+          free_lists_[size_class] = m;\n+          m = t;\n+        }\n+        x->free_lists_[size_class] = 0;\n+      }\n+    }\n+  }\n+\n+  void BypassThreadLocalQuarantine(AsanChunk *chunk) {\n+    ScopedLock lock(&mu_);\n+    quarantine_.Push(chunk);\n+  }\n+\n+  AsanChunk *FindChunkByAddr(uptr addr) {\n+    ScopedLock lock(&mu_);\n+    return FindChunkByAddrUnlocked(addr);\n+  }\n+\n+  uptr AllocationSize(uptr ptr) {\n+    if (!ptr) return 0;\n+    ScopedLock lock(&mu_);\n+\n+    // Make sure this is our chunk and |ptr| actually points to the beginning\n+    // of the allocated memory.\n+    AsanChunk *m = FindChunkByAddrUnlocked(ptr);\n+    if (!m || m->Beg() != ptr) return 0;\n+\n+    if (m->chunk_state == CHUNK_ALLOCATED) {\n+      return m->used_size;\n+    } else {\n+      return 0;\n+    }\n+  }\n+\n+  void ForceLock() {\n+    mu_.Lock();\n+  }\n+\n+  void ForceUnlock() {\n+    mu_.Unlock();\n+  }\n+\n+  void PrintStatus() {\n+    ScopedLock lock(&mu_);\n+    uptr malloced = 0;\n+\n+    Printf(\" MallocInfo: in quarantine: %zu malloced: %zu; \",\n+           quarantine_.size() >> 20, malloced >> 20);\n+    for (uptr j = 1; j < kNumberOfSizeClasses; j++) {\n+      AsanChunk *i = free_lists_[j];\n+      if (!i) continue;\n+      uptr t = 0;\n+      for (; i; i = i->next) {\n+        t += i->Size();\n+      }\n+      Printf(\"%zu:%zu \", j, t >> 20);\n+    }\n+    Printf(\"\\n\");\n+  }\n+\n+  PageGroup *FindPageGroup(uptr addr) {\n+    ScopedLock lock(&mu_);\n+    return FindPageGroupUnlocked(addr);\n+  }\n+\n+ private:\n+  PageGroup *FindPageGroupUnlocked(uptr addr) {\n+    int n = atomic_load(&n_page_groups_, memory_order_relaxed);\n+    // If the page groups are not sorted yet, sort them.\n+    if (n_sorted_page_groups_ < n) {\n+      SortArray((uptr*)page_groups_, n);\n+      n_sorted_page_groups_ = n;\n+    }\n+    // Binary search over the page groups.\n+    int beg = 0, end = n;\n+    while (beg < end) {\n+      int med = (beg + end) / 2;\n+      uptr g = (uptr)page_groups_[med];\n+      if (addr > g) {\n+        // 'g' points to the end of the group, so 'addr'\n+        // may not belong to page_groups_[med] or any previous group.\n+        beg = med + 1;\n+      } else {\n+        // 'addr' may belong to page_groups_[med] or a previous group.\n+        end = med;\n+      }\n+    }\n+    if (beg >= n)\n+      return 0;\n+    PageGroup *g = page_groups_[beg];\n+    CHECK(g);\n+    if (g->InRange(addr))\n+      return g;\n+    return 0;\n+  }\n+\n+  // We have an address between two chunks, and we want to report just one.\n+  AsanChunk *ChooseChunk(uptr addr,\n+                         AsanChunk *left_chunk, AsanChunk *right_chunk) {\n+    // Prefer an allocated chunk or a chunk from quarantine.\n+    if (left_chunk->chunk_state == CHUNK_AVAILABLE &&\n+        right_chunk->chunk_state != CHUNK_AVAILABLE)\n+      return right_chunk;\n+    if (right_chunk->chunk_state == CHUNK_AVAILABLE &&\n+        left_chunk->chunk_state != CHUNK_AVAILABLE)\n+      return left_chunk;\n+    // Choose based on offset.\n+    uptr l_offset = 0, r_offset = 0;\n+    CHECK(AsanChunkView(left_chunk).AddrIsAtRight(addr, 1, &l_offset));\n+    CHECK(AsanChunkView(right_chunk).AddrIsAtLeft(addr, 1, &r_offset));\n+    if (l_offset < r_offset)\n+      return left_chunk;\n+    return right_chunk;\n+  }\n+\n+  AsanChunk *FindChunkByAddrUnlocked(uptr addr) {\n+    PageGroup *g = FindPageGroupUnlocked(addr);\n+    if (!g) return 0;\n+    CHECK(g->size_of_chunk);\n+    uptr offset_from_beg = addr - g->beg;\n+    uptr this_chunk_addr = g->beg +\n+        (offset_from_beg / g->size_of_chunk) * g->size_of_chunk;\n+    CHECK(g->InRange(this_chunk_addr));\n+    AsanChunk *m = (AsanChunk*)this_chunk_addr;\n+    CHECK(m->chunk_state == CHUNK_ALLOCATED ||\n+          m->chunk_state == CHUNK_AVAILABLE ||\n+          m->chunk_state == CHUNK_QUARANTINE);\n+    uptr offset = 0;\n+    AsanChunkView m_view(m);\n+    if (m_view.AddrIsInside(addr, 1, &offset))\n+      return m;\n+\n+    if (m_view.AddrIsAtRight(addr, 1, &offset)) {\n+      if (this_chunk_addr == g->last_chunk)  // rightmost chunk\n+        return m;\n+      uptr right_chunk_addr = this_chunk_addr + g->size_of_chunk;\n+      CHECK(g->InRange(right_chunk_addr));\n+      return ChooseChunk(addr, m, (AsanChunk*)right_chunk_addr);\n+    } else {\n+      CHECK(m_view.AddrIsAtLeft(addr, 1, &offset));\n+      if (this_chunk_addr == g->beg)  // leftmost chunk\n+        return m;\n+      uptr left_chunk_addr = this_chunk_addr - g->size_of_chunk;\n+      CHECK(g->InRange(left_chunk_addr));\n+      return ChooseChunk(addr, (AsanChunk*)left_chunk_addr, m);\n+    }\n+  }\n+\n+  void QuarantinePop() {\n+    CHECK(quarantine_.size() > 0);\n+    AsanChunk *m = quarantine_.Pop();\n+    CHECK(m);\n+    // if (F_v >= 2) Printf(\"MallocInfo::pop %p\\n\", m);\n+\n+    CHECK(m->chunk_state == CHUNK_QUARANTINE);\n+    m->chunk_state = CHUNK_AVAILABLE;\n+    PoisonShadow((uptr)m, m->Size(), kAsanHeapLeftRedzoneMagic);\n+    CHECK(m->alloc_tid >= 0);\n+    CHECK(m->free_tid >= 0);\n+\n+    uptr size_class = m->SizeClass();\n+    m->next = free_lists_[size_class];\n+    free_lists_[size_class] = m;\n+\n+    // Statistics.\n+    AsanStats &thread_stats = asanThreadRegistry().GetCurrentThreadStats();\n+    thread_stats.real_frees++;\n+    thread_stats.really_freed += m->used_size;\n+    thread_stats.really_freed_redzones += m->Size() - m->used_size;\n+    thread_stats.really_freed_by_size[m->SizeClass()]++;\n+  }\n+\n+  // Get a list of newly allocated chunks.\n+  AsanChunk *GetNewChunks(u8 size_class) {\n+    uptr size = SizeClassToSize(size_class);\n+    CHECK(IsPowerOfTwo(kMinMmapSize));\n+    CHECK(size < kMinMmapSize || (size % kMinMmapSize) == 0);\n+    uptr mmap_size = Max(size, kMinMmapSize);\n+    uptr n_chunks = mmap_size / size;\n+    CHECK(n_chunks * size == mmap_size);\n+    if (size < kPageSize) {\n+      // Size is small, just poison the last chunk.\n+      n_chunks--;\n+    } else {\n+      // Size is large, allocate an extra page at right and poison it.\n+      mmap_size += kPageSize;\n+    }\n+    CHECK(n_chunks > 0);\n+    u8 *mem = MmapNewPagesAndPoisonShadow(mmap_size);\n+\n+    // Statistics.\n+    AsanStats &thread_stats = asanThreadRegistry().GetCurrentThreadStats();\n+    thread_stats.mmaps++;\n+    thread_stats.mmaped += mmap_size;\n+    thread_stats.mmaped_by_size[size_class] += n_chunks;\n+\n+    AsanChunk *res = 0;\n+    for (uptr i = 0; i < n_chunks; i++) {\n+      AsanChunk *m = (AsanChunk*)(mem + i * size);\n+      m->chunk_state = CHUNK_AVAILABLE;\n+      m->size_class = size_class;\n+      m->next = res;\n+      res = m;\n+    }\n+    PageGroup *pg = (PageGroup*)(mem + n_chunks * size);\n+    // This memory is already poisoned, no need to poison it again.\n+    pg->beg = (uptr)mem;\n+    pg->end = pg->beg + mmap_size;\n+    pg->size_of_chunk = size;\n+    pg->last_chunk = (uptr)(mem + size * (n_chunks - 1));\n+    int idx = atomic_fetch_add(&n_page_groups_, 1, memory_order_relaxed);\n+    CHECK(idx < (int)ARRAY_SIZE(page_groups_));\n+    page_groups_[idx] = pg;\n+    return res;\n+  }\n+\n+  AsanChunk *free_lists_[kNumberOfSizeClasses];\n+  AsanChunkFifoList quarantine_;\n+  AsanLock mu_;\n+\n+  PageGroup *page_groups_[kMaxAvailableRam / kMinMmapSize];\n+  atomic_uint32_t n_page_groups_;\n+  int n_sorted_page_groups_;\n+};\n+\n+static MallocInfo malloc_info(LINKER_INITIALIZED);\n+\n+void AsanThreadLocalMallocStorage::CommitBack() {\n+  malloc_info.SwallowThreadLocalMallocStorage(this, true);\n+}\n+\n+AsanChunkView FindHeapChunkByAddress(uptr address) {\n+  return AsanChunkView(malloc_info.FindChunkByAddr(address));\n+}\n+\n+static u8 *Allocate(uptr alignment, uptr size, StackTrace *stack) {\n+  __asan_init();\n+  CHECK(stack);\n+  if (size == 0) {\n+    size = 1;  // TODO(kcc): do something smarter\n+  }\n+  CHECK(IsPowerOfTwo(alignment));\n+  uptr rounded_size = RoundUpTo(size, REDZONE);\n+  uptr needed_size = rounded_size + REDZONE;\n+  if (alignment > REDZONE) {\n+    needed_size += alignment;\n+  }\n+  CHECK(IsAligned(needed_size, REDZONE));\n+  if (size > kMaxAllowedMallocSize || needed_size > kMaxAllowedMallocSize) {\n+    Report(\"WARNING: AddressSanitizer failed to allocate %p bytes\\n\",\n+           (void*)size);\n+    return 0;\n+  }\n+\n+  u8 size_class = SizeToSizeClass(needed_size);\n+  uptr size_to_allocate = SizeClassToSize(size_class);\n+  CHECK(size_to_allocate >= kMinAllocSize);\n+  CHECK(size_to_allocate >= needed_size);\n+  CHECK(IsAligned(size_to_allocate, REDZONE));\n+\n+  if (flags()->verbosity >= 3) {\n+    Printf(\"Allocate align: %zu size: %zu class: %u real: %zu\\n\",\n+         alignment, size, size_class, size_to_allocate);\n+  }\n+\n+  AsanThread *t = asanThreadRegistry().GetCurrent();\n+  AsanStats &thread_stats = asanThreadRegistry().GetCurrentThreadStats();\n+  // Statistics\n+  thread_stats.mallocs++;\n+  thread_stats.malloced += size;\n+  thread_stats.malloced_redzones += size_to_allocate - size;\n+  thread_stats.malloced_by_size[size_class]++;\n+\n+  AsanChunk *m = 0;\n+  if (!t || size_to_allocate >= kMaxSizeForThreadLocalFreeList) {\n+    // get directly from global storage.\n+    m = malloc_info.AllocateChunks(size_class, 1);\n+    thread_stats.malloc_large++;\n+  } else {\n+    // get from the thread-local storage.\n+    AsanChunk **fl = &t->malloc_storage().free_lists_[size_class];\n+    if (!*fl) {\n+      uptr n_new_chunks = kMaxSizeForThreadLocalFreeList / size_to_allocate;\n+      *fl = malloc_info.AllocateChunks(size_class, n_new_chunks);\n+      thread_stats.malloc_small_slow++;\n+    }\n+    m = *fl;\n+    *fl = (*fl)->next;\n+  }\n+  CHECK(m);\n+  CHECK(m->chunk_state == CHUNK_AVAILABLE);\n+  m->chunk_state = CHUNK_ALLOCATED;\n+  m->next = 0;\n+  CHECK(m->Size() == size_to_allocate);\n+  uptr addr = (uptr)m + REDZONE;\n+  CHECK(addr <= (uptr)m->compressed_free_stack());\n+\n+  if (alignment > REDZONE && (addr & (alignment - 1))) {\n+    addr = RoundUpTo(addr, alignment);\n+    CHECK((addr & (alignment - 1)) == 0);\n+    AsanChunk *p = (AsanChunk*)(addr - REDZONE);\n+    p->chunk_state = CHUNK_MEMALIGN;\n+    p->used_size = (uptr)p - (uptr)m;\n+    m->alignment_log = Log2(alignment);\n+    CHECK(m->Beg() == addr);\n+  } else {\n+    m->alignment_log = Log2(REDZONE);\n+  }\n+  CHECK(m == PtrToChunk(addr));\n+  m->used_size = size;\n+  CHECK(m->Beg() == addr);\n+  m->alloc_tid = t ? t->tid() : 0;\n+  m->free_tid   = kInvalidTid;\n+  StackTrace::CompressStack(stack, m->compressed_alloc_stack(),\n+                                m->compressed_alloc_stack_size());\n+  PoisonShadow(addr, rounded_size, 0);\n+  if (size < rounded_size) {\n+    PoisonHeapPartialRightRedzone(addr + rounded_size - REDZONE,\n+                                  size & (REDZONE - 1));\n+  }\n+  if (size <= (uptr)(flags()->max_malloc_fill_size)) {\n+    REAL(memset)((void*)addr, 0, rounded_size);\n+  }\n+  return (u8*)addr;\n+}\n+\n+static void Deallocate(u8 *ptr, StackTrace *stack) {\n+  if (!ptr) return;\n+  CHECK(stack);\n+\n+  if (flags()->debug) {\n+    CHECK(malloc_info.FindPageGroup((uptr)ptr));\n+  }\n+\n+  // Printf(\"Deallocate %p\\n\", ptr);\n+  AsanChunk *m = PtrToChunk((uptr)ptr);\n+\n+  // Flip the chunk_state atomically to avoid race on double-free.\n+  u8 old_chunk_state = atomic_exchange((atomic_uint8_t*)m, CHUNK_QUARANTINE,\n+                                       memory_order_acq_rel);\n+\n+  if (old_chunk_state == CHUNK_QUARANTINE) {\n+    ReportDoubleFree((uptr)ptr, stack);\n+  } else if (old_chunk_state != CHUNK_ALLOCATED) {\n+    ReportFreeNotMalloced((uptr)ptr, stack);\n+  }\n+  CHECK(old_chunk_state == CHUNK_ALLOCATED);\n+  // With REDZONE==16 m->next is in the user area, otherwise it should be 0.\n+  CHECK(REDZONE <= 16 || !m->next);\n+  CHECK(m->free_tid == kInvalidTid);\n+  CHECK(m->alloc_tid >= 0);\n+  AsanThread *t = asanThreadRegistry().GetCurrent();\n+  m->free_tid = t ? t->tid() : 0;\n+  StackTrace::CompressStack(stack, m->compressed_free_stack(),\n+                                m->compressed_free_stack_size());\n+  uptr rounded_size = RoundUpTo(m->used_size, REDZONE);\n+  PoisonShadow((uptr)ptr, rounded_size, kAsanHeapFreeMagic);\n+\n+  // Statistics.\n+  AsanStats &thread_stats = asanThreadRegistry().GetCurrentThreadStats();\n+  thread_stats.frees++;\n+  thread_stats.freed += m->used_size;\n+  thread_stats.freed_by_size[m->SizeClass()]++;\n+\n+  CHECK(m->chunk_state == CHUNK_QUARANTINE);\n+\n+  if (t) {\n+    AsanThreadLocalMallocStorage *ms = &t->malloc_storage();\n+    ms->quarantine_.Push(m);\n+\n+    if (ms->quarantine_.size() > kMaxThreadLocalQuarantine) {\n+      malloc_info.SwallowThreadLocalMallocStorage(ms, false);\n+    }\n+  } else {\n+    malloc_info.BypassThreadLocalQuarantine(m);\n+  }\n+}\n+\n+static u8 *Reallocate(u8 *old_ptr, uptr new_size,\n+                           StackTrace *stack) {\n+  CHECK(old_ptr && new_size);\n+\n+  // Statistics.\n+  AsanStats &thread_stats = asanThreadRegistry().GetCurrentThreadStats();\n+  thread_stats.reallocs++;\n+  thread_stats.realloced += new_size;\n+\n+  AsanChunk *m = PtrToChunk((uptr)old_ptr);\n+  CHECK(m->chunk_state == CHUNK_ALLOCATED);\n+  uptr old_size = m->used_size;\n+  uptr memcpy_size = Min(new_size, old_size);\n+  u8 *new_ptr = Allocate(0, new_size, stack);\n+  if (new_ptr) {\n+    CHECK(REAL(memcpy) != 0);\n+    REAL(memcpy)(new_ptr, old_ptr, memcpy_size);\n+    Deallocate(old_ptr, stack);\n+  }\n+  return new_ptr;\n+}\n+\n+}  // namespace __asan\n+\n+// Default (no-op) implementation of malloc hooks.\n+extern \"C\" {\n+SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n+void __asan_malloc_hook(void *ptr, uptr size) {\n+  (void)ptr;\n+  (void)size;\n+}\n+SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n+void __asan_free_hook(void *ptr) {\n+  (void)ptr;\n+}\n+}  // extern \"C\"\n+\n+namespace __asan {\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void *asan_memalign(uptr alignment, uptr size, StackTrace *stack) {\n+  void *ptr = (void*)Allocate(alignment, size, stack);\n+  __asan_malloc_hook(ptr, size);\n+  return ptr;\n+}\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void asan_free(void *ptr, StackTrace *stack) {\n+  __asan_free_hook(ptr);\n+  Deallocate((u8*)ptr, stack);\n+}\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void *asan_malloc(uptr size, StackTrace *stack) {\n+  void *ptr = (void*)Allocate(0, size, stack);\n+  __asan_malloc_hook(ptr, size);\n+  return ptr;\n+}\n+\n+void *asan_calloc(uptr nmemb, uptr size, StackTrace *stack) {\n+  void *ptr = (void*)Allocate(0, nmemb * size, stack);\n+  if (ptr)\n+    REAL(memset)(ptr, 0, nmemb * size);\n+  __asan_malloc_hook(ptr, nmemb * size);\n+  return ptr;\n+}\n+\n+void *asan_realloc(void *p, uptr size, StackTrace *stack) {\n+  if (p == 0) {\n+    void *ptr = (void*)Allocate(0, size, stack);\n+    __asan_malloc_hook(ptr, size);\n+    return ptr;\n+  } else if (size == 0) {\n+    __asan_free_hook(p);\n+    Deallocate((u8*)p, stack);\n+    return 0;\n+  }\n+  return Reallocate((u8*)p, size, stack);\n+}\n+\n+void *asan_valloc(uptr size, StackTrace *stack) {\n+  void *ptr = (void*)Allocate(kPageSize, size, stack);\n+  __asan_malloc_hook(ptr, size);\n+  return ptr;\n+}\n+\n+void *asan_pvalloc(uptr size, StackTrace *stack) {\n+  size = RoundUpTo(size, kPageSize);\n+  if (size == 0) {\n+    // pvalloc(0) should allocate one page.\n+    size = kPageSize;\n+  }\n+  void *ptr = (void*)Allocate(kPageSize, size, stack);\n+  __asan_malloc_hook(ptr, size);\n+  return ptr;\n+}\n+\n+int asan_posix_memalign(void **memptr, uptr alignment, uptr size,\n+                          StackTrace *stack) {\n+  void *ptr = Allocate(alignment, size, stack);\n+  CHECK(IsAligned((uptr)ptr, alignment));\n+  __asan_malloc_hook(ptr, size);\n+  *memptr = ptr;\n+  return 0;\n+}\n+\n+uptr asan_malloc_usable_size(void *ptr, StackTrace *stack) {\n+  CHECK(stack);\n+  if (ptr == 0) return 0;\n+  uptr usable_size = malloc_info.AllocationSize((uptr)ptr);\n+  if (flags()->check_malloc_usable_size && (usable_size == 0)) {\n+    ReportMallocUsableSizeNotOwned((uptr)ptr, stack);\n+  }\n+  return usable_size;\n+}\n+\n+uptr asan_mz_size(const void *ptr) {\n+  return malloc_info.AllocationSize((uptr)ptr);\n+}\n+\n+void asan_mz_force_lock() {\n+  malloc_info.ForceLock();\n+}\n+\n+void asan_mz_force_unlock() {\n+  malloc_info.ForceUnlock();\n+}\n+\n+// ---------------------- Fake stack-------------------- {{{1\n+FakeStack::FakeStack() {\n+  CHECK(REAL(memset) != 0);\n+  REAL(memset)(this, 0, sizeof(*this));\n+}\n+\n+bool FakeStack::AddrIsInSizeClass(uptr addr, uptr size_class) {\n+  uptr mem = allocated_size_classes_[size_class];\n+  uptr size = ClassMmapSize(size_class);\n+  bool res = mem && addr >= mem && addr < mem + size;\n+  return res;\n+}\n+\n+uptr FakeStack::AddrIsInFakeStack(uptr addr) {\n+  for (uptr i = 0; i < kNumberOfSizeClasses; i++) {\n+    if (AddrIsInSizeClass(addr, i)) return allocated_size_classes_[i];\n+  }\n+  return 0;\n+}\n+\n+// We may want to compute this during compilation.\n+inline uptr FakeStack::ComputeSizeClass(uptr alloc_size) {\n+  uptr rounded_size = RoundUpToPowerOfTwo(alloc_size);\n+  uptr log = Log2(rounded_size);\n+  CHECK(alloc_size <= (1UL << log));\n+  if (!(alloc_size > (1UL << (log-1)))) {\n+    Printf(\"alloc_size %zu log %zu\\n\", alloc_size, log);\n+  }\n+  CHECK(alloc_size > (1UL << (log-1)));\n+  uptr res = log < kMinStackFrameSizeLog ? 0 : log - kMinStackFrameSizeLog;\n+  CHECK(res < kNumberOfSizeClasses);\n+  CHECK(ClassSize(res) >= rounded_size);\n+  return res;\n+}\n+\n+void FakeFrameFifo::FifoPush(FakeFrame *node) {\n+  CHECK(node);\n+  node->next = 0;\n+  if (first_ == 0 && last_ == 0) {\n+    first_ = last_ = node;\n+  } else {\n+    CHECK(first_);\n+    CHECK(last_);\n+    last_->next = node;\n+    last_ = node;\n+  }\n+}\n+\n+FakeFrame *FakeFrameFifo::FifoPop() {\n+  CHECK(first_ && last_ && \"Exhausted fake stack\");\n+  FakeFrame *res = 0;\n+  if (first_ == last_) {\n+    res = first_;\n+    first_ = last_ = 0;\n+  } else {\n+    res = first_;\n+    first_ = first_->next;\n+  }\n+  return res;\n+}\n+\n+void FakeStack::Init(uptr stack_size) {\n+  stack_size_ = stack_size;\n+  alive_ = true;\n+}\n+\n+void FakeStack::Cleanup() {\n+  alive_ = false;\n+  for (uptr i = 0; i < kNumberOfSizeClasses; i++) {\n+    uptr mem = allocated_size_classes_[i];\n+    if (mem) {\n+      PoisonShadow(mem, ClassMmapSize(i), 0);\n+      allocated_size_classes_[i] = 0;\n+      UnmapOrDie((void*)mem, ClassMmapSize(i));\n+    }\n+  }\n+}\n+\n+uptr FakeStack::ClassMmapSize(uptr size_class) {\n+  return RoundUpToPowerOfTwo(stack_size_);\n+}\n+\n+void FakeStack::AllocateOneSizeClass(uptr size_class) {\n+  CHECK(ClassMmapSize(size_class) >= kPageSize);\n+  uptr new_mem = (uptr)MmapOrDie(\n+      ClassMmapSize(size_class), __FUNCTION__);\n+  // Printf(\"T%d new_mem[%zu]: %p-%p mmap %zu\\n\",\n+  //       asanThreadRegistry().GetCurrent()->tid(),\n+  //       size_class, new_mem, new_mem + ClassMmapSize(size_class),\n+  //       ClassMmapSize(size_class));\n+  uptr i;\n+  for (i = 0; i < ClassMmapSize(size_class);\n+       i += ClassSize(size_class)) {\n+    size_classes_[size_class].FifoPush((FakeFrame*)(new_mem + i));\n+  }\n+  CHECK(i == ClassMmapSize(size_class));\n+  allocated_size_classes_[size_class] = new_mem;\n+}\n+\n+uptr FakeStack::AllocateStack(uptr size, uptr real_stack) {\n+  if (!alive_) return real_stack;\n+  CHECK(size <= kMaxStackMallocSize && size > 1);\n+  uptr size_class = ComputeSizeClass(size);\n+  if (!allocated_size_classes_[size_class]) {\n+    AllocateOneSizeClass(size_class);\n+  }\n+  FakeFrame *fake_frame = size_classes_[size_class].FifoPop();\n+  CHECK(fake_frame);\n+  fake_frame->size_minus_one = size - 1;\n+  fake_frame->real_stack = real_stack;\n+  while (FakeFrame *top = call_stack_.top()) {\n+    if (top->real_stack > real_stack) break;\n+    call_stack_.LifoPop();\n+    DeallocateFrame(top);\n+  }\n+  call_stack_.LifoPush(fake_frame);\n+  uptr ptr = (uptr)fake_frame;\n+  PoisonShadow(ptr, size, 0);\n+  return ptr;\n+}\n+\n+void FakeStack::DeallocateFrame(FakeFrame *fake_frame) {\n+  CHECK(alive_);\n+  uptr size = fake_frame->size_minus_one + 1;\n+  uptr size_class = ComputeSizeClass(size);\n+  CHECK(allocated_size_classes_[size_class]);\n+  uptr ptr = (uptr)fake_frame;\n+  CHECK(AddrIsInSizeClass(ptr, size_class));\n+  CHECK(AddrIsInSizeClass(ptr + size - 1, size_class));\n+  size_classes_[size_class].FifoPush(fake_frame);\n+}\n+\n+void FakeStack::OnFree(uptr ptr, uptr size, uptr real_stack) {\n+  FakeFrame *fake_frame = (FakeFrame*)ptr;\n+  CHECK(fake_frame->magic = kRetiredStackFrameMagic);\n+  CHECK(fake_frame->descr != 0);\n+  CHECK(fake_frame->size_minus_one == size - 1);\n+  PoisonShadow(ptr, size, kAsanStackAfterReturnMagic);\n+}\n+\n+}  // namespace __asan\n+\n+// ---------------------- Interface ---------------- {{{1\n+using namespace __asan;  // NOLINT\n+\n+uptr __asan_stack_malloc(uptr size, uptr real_stack) {\n+  if (!flags()->use_fake_stack) return real_stack;\n+  AsanThread *t = asanThreadRegistry().GetCurrent();\n+  if (!t) {\n+    // TSD is gone, use the real stack.\n+    return real_stack;\n+  }\n+  uptr ptr = t->fake_stack().AllocateStack(size, real_stack);\n+  // Printf(\"__asan_stack_malloc %p %zu %p\\n\", ptr, size, real_stack);\n+  return ptr;\n+}\n+\n+void __asan_stack_free(uptr ptr, uptr size, uptr real_stack) {\n+  if (!flags()->use_fake_stack) return;\n+  if (ptr != real_stack) {\n+    FakeStack::OnFree(ptr, size, real_stack);\n+  }\n+}\n+\n+// ASan allocator doesn't reserve extra bytes, so normally we would\n+// just return \"size\".\n+uptr __asan_get_estimated_allocated_size(uptr size) {\n+  if (size == 0) return 1;\n+  return Min(size, kMaxAllowedMallocSize);\n+}\n+\n+bool __asan_get_ownership(const void *p) {\n+  return malloc_info.AllocationSize((uptr)p) > 0;\n+}\n+\n+uptr __asan_get_allocated_size(const void *p) {\n+  if (p == 0) return 0;\n+  uptr allocated_size = malloc_info.AllocationSize((uptr)p);\n+  // Die if p is not malloced or if it is already freed.\n+  if (allocated_size == 0) {\n+    GET_STACK_TRACE_HERE(kStackTraceMax);\n+    ReportAsanGetAllocatedSizeNotOwned((uptr)p, &stack);\n+  }\n+  return allocated_size;\n+}"}, {"sha": "372ca0635ed43db9bb00b56be305ca6560b7f51b", "filename": "libsanitizer/asan/asan_allocator.h", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_allocator.h?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,177 @@\n+//===-- asan_allocator.h ----------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// ASan-private header for asan_allocator.cc.\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef ASAN_ALLOCATOR_H\n+#define ASAN_ALLOCATOR_H\n+\n+#include \"asan_internal.h\"\n+#include \"asan_interceptors.h\"\n+\n+namespace __asan {\n+\n+static const uptr kNumberOfSizeClasses = 255;\n+struct AsanChunk;\n+\n+class AsanChunkView {\n+ public:\n+  explicit AsanChunkView(AsanChunk *chunk) : chunk_(chunk) {}\n+  bool IsValid() { return chunk_ != 0; }\n+  uptr Beg();       // first byte of user memory.\n+  uptr End();       // last byte of user memory.\n+  uptr UsedSize();  // size requested by the user.\n+  uptr AllocTid();\n+  uptr FreeTid();\n+  void GetAllocStack(StackTrace *stack);\n+  void GetFreeStack(StackTrace *stack);\n+  bool AddrIsInside(uptr addr, uptr access_size, uptr *offset);\n+  bool AddrIsAtLeft(uptr addr, uptr access_size, uptr *offset);\n+  bool AddrIsAtRight(uptr addr, uptr access_size, uptr *offset);\n+ private:\n+  AsanChunk *const chunk_;\n+};\n+\n+AsanChunkView FindHeapChunkByAddress(uptr address);\n+\n+class AsanChunkFifoList {\n+ public:\n+  explicit AsanChunkFifoList(LinkerInitialized) { }\n+  AsanChunkFifoList() { clear(); }\n+  void Push(AsanChunk *n);\n+  void PushList(AsanChunkFifoList *q);\n+  AsanChunk *Pop();\n+  uptr size() { return size_; }\n+  void clear() {\n+    first_ = last_ = 0;\n+    size_ = 0;\n+  }\n+ private:\n+  AsanChunk *first_;\n+  AsanChunk *last_;\n+  uptr size_;\n+};\n+\n+struct AsanThreadLocalMallocStorage {\n+  explicit AsanThreadLocalMallocStorage(LinkerInitialized x)\n+      : quarantine_(x) { }\n+  AsanThreadLocalMallocStorage() {\n+    CHECK(REAL(memset));\n+    REAL(memset)(this, 0, sizeof(AsanThreadLocalMallocStorage));\n+  }\n+\n+  AsanChunkFifoList quarantine_;\n+  AsanChunk *free_lists_[kNumberOfSizeClasses];\n+  void CommitBack();\n+};\n+\n+// Fake stack frame contains local variables of one function.\n+// This struct should fit into a stack redzone (32 bytes).\n+struct FakeFrame {\n+  uptr magic;  // Modified by the instrumented code.\n+  uptr descr;  // Modified by the instrumented code.\n+  FakeFrame *next;\n+  u64 real_stack     : 48;\n+  u64 size_minus_one : 16;\n+};\n+\n+struct FakeFrameFifo {\n+ public:\n+  void FifoPush(FakeFrame *node);\n+  FakeFrame *FifoPop();\n+ private:\n+  FakeFrame *first_, *last_;\n+};\n+\n+class FakeFrameLifo {\n+ public:\n+  void LifoPush(FakeFrame *node) {\n+    node->next = top_;\n+    top_ = node;\n+  }\n+  void LifoPop() {\n+    CHECK(top_);\n+    top_ = top_->next;\n+  }\n+  FakeFrame *top() { return top_; }\n+ private:\n+  FakeFrame *top_;\n+};\n+\n+// For each thread we create a fake stack and place stack objects on this fake\n+// stack instead of the real stack. The fake stack is not really a stack but\n+// a fast malloc-like allocator so that when a function exits the fake stack\n+// is not poped but remains there for quite some time until gets used again.\n+// So, we poison the objects on the fake stack when function returns.\n+// It helps us find use-after-return bugs.\n+// We can not rely on __asan_stack_free being called on every function exit,\n+// so we maintain a lifo list of all current fake frames and update it on every\n+// call to __asan_stack_malloc.\n+class FakeStack {\n+ public:\n+  FakeStack();\n+  explicit FakeStack(LinkerInitialized) {}\n+  void Init(uptr stack_size);\n+  void StopUsingFakeStack() { alive_ = false; }\n+  void Cleanup();\n+  uptr AllocateStack(uptr size, uptr real_stack);\n+  static void OnFree(uptr ptr, uptr size, uptr real_stack);\n+  // Return the bottom of the maped region.\n+  uptr AddrIsInFakeStack(uptr addr);\n+  bool StackSize() { return stack_size_; }\n+\n+ private:\n+  static const uptr kMinStackFrameSizeLog = 9;  // Min frame is 512B.\n+  static const uptr kMaxStackFrameSizeLog = 16;  // Max stack frame is 64K.\n+  static const uptr kMaxStackMallocSize = 1 << kMaxStackFrameSizeLog;\n+  static const uptr kNumberOfSizeClasses =\n+      kMaxStackFrameSizeLog - kMinStackFrameSizeLog + 1;\n+\n+  bool AddrIsInSizeClass(uptr addr, uptr size_class);\n+\n+  // Each size class should be large enough to hold all frames.\n+  uptr ClassMmapSize(uptr size_class);\n+\n+  uptr ClassSize(uptr size_class) {\n+    return 1UL << (size_class + kMinStackFrameSizeLog);\n+  }\n+\n+  void DeallocateFrame(FakeFrame *fake_frame);\n+\n+  uptr ComputeSizeClass(uptr alloc_size);\n+  void AllocateOneSizeClass(uptr size_class);\n+\n+  uptr stack_size_;\n+  bool   alive_;\n+\n+  uptr allocated_size_classes_[kNumberOfSizeClasses];\n+  FakeFrameFifo size_classes_[kNumberOfSizeClasses];\n+  FakeFrameLifo call_stack_;\n+};\n+\n+void *asan_memalign(uptr alignment, uptr size, StackTrace *stack);\n+void asan_free(void *ptr, StackTrace *stack);\n+\n+void *asan_malloc(uptr size, StackTrace *stack);\n+void *asan_calloc(uptr nmemb, uptr size, StackTrace *stack);\n+void *asan_realloc(void *p, uptr size, StackTrace *stack);\n+void *asan_valloc(uptr size, StackTrace *stack);\n+void *asan_pvalloc(uptr size, StackTrace *stack);\n+\n+int asan_posix_memalign(void **memptr, uptr alignment, uptr size,\n+                          StackTrace *stack);\n+uptr asan_malloc_usable_size(void *ptr, StackTrace *stack);\n+\n+uptr asan_mz_size(const void *ptr);\n+void asan_mz_force_lock();\n+void asan_mz_force_unlock();\n+\n+}  // namespace __asan\n+#endif  // ASAN_ALLOCATOR_H"}, {"sha": "a0dcf3e8a571fb11c925fff0344aac6580a30f27", "filename": "libsanitizer/asan/asan_flags.h", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_flags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_flags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_flags.h?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,103 @@\n+//===-- asan_flags.h -------------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// ASan runtime flags.\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef ASAN_FLAGS_H\n+#define ASAN_FLAGS_H\n+\n+#include \"sanitizer/common_interface_defs.h\"\n+\n+// ASan flag values can be defined in three ways:\n+// 1) initialized with default values at startup.\n+// 2) overriden from string returned by user-specified function\n+//    __asan_default_options().\n+// 3) overriden from env variable ASAN_OPTIONS.\n+\n+namespace __asan {\n+\n+struct Flags {\n+  // Size (in bytes) of quarantine used to detect use-after-free errors.\n+  // Lower value may reduce memory usage but increase the chance of\n+  // false negatives.\n+  int  quarantine_size;\n+  // If set, uses in-process symbolizer from common sanitizer runtime.\n+  bool symbolize;\n+  // Verbosity level (0 - silent, 1 - a bit of output, 2+ - more output).\n+  int  verbosity;\n+  // Size (in bytes) of redzones around heap objects.\n+  // Requirement: redzone >= 32, is a power of two.\n+  int  redzone;\n+  // If set, prints some debugging information and does additional checks.\n+  bool debug;\n+  // Controls the way to handle globals (0 - don't detect buffer overflow\n+  // on globals, 1 - detect buffer overflow, 2 - print data about registered\n+  // globals).\n+  int  report_globals;\n+  // If set, attempts to catch initialization order issues.\n+  bool check_initialization_order;\n+  // Max number of stack frames kept for each allocation.\n+  int  malloc_context_size;\n+  // If set, uses custom wrappers and replacements for libc string functions\n+  // to find more errors.\n+  bool replace_str;\n+  // If set, uses custom wrappers for memset/memcpy/memmove intinsics.\n+  bool replace_intrin;\n+  // Used on Mac only. See comments in asan_mac.cc and asan_malloc_mac.cc.\n+  bool replace_cfallocator;\n+  // Used on Mac only.\n+  bool mac_ignore_invalid_free;\n+  // ASan allocator flag. See asan_allocator.cc.\n+  bool use_fake_stack;\n+  // ASan allocator flag. Sets the maximal size of allocation request\n+  // that would return memory filled with zero bytes.\n+  int  max_malloc_fill_size;\n+  // Override exit status if something was reported.\n+  int  exitcode;\n+  // If set, user may manually mark memory regions as poisoned or unpoisoned.\n+  bool allow_user_poisoning;\n+  // Number of seconds to sleep between printing an error report and\n+  // terminating application. Useful for debug purposes (when one needs\n+  // to attach gdb, for example).\n+  int  sleep_before_dying;\n+  // If set, registers ASan custom segv handler.\n+  bool handle_segv;\n+  // If set, uses alternate stack for signal handling.\n+  bool use_sigaltstack;\n+  // Allow the users to work around the bug in Nvidia drivers prior to 295.*.\n+  bool check_malloc_usable_size;\n+  // If set, explicitly unmaps (huge) shadow at exit.\n+  bool unmap_shadow_on_exit;\n+  // If set, calls abort() instead of _exit() after printing an error report.\n+  bool abort_on_error;\n+  // If set, prints ASan exit stats even after program terminates successfully.\n+  bool atexit;\n+  // By default, disable core dumper on 64-bit - it makes little sense\n+  // to dump 16T+ core.\n+  bool disable_core;\n+  // Allow the tool to re-exec the program. This may interfere badly with the\n+  // debugger.\n+  bool allow_reexec;\n+  // Strips this prefix from file paths in error reports.\n+  const char *strip_path_prefix;\n+  // If set, prints not only thread creation stacks for threads in error report,\n+  // but also thread creation stacks for threads that created those threads,\n+  // etc. up to main thread.\n+  bool print_full_thread_history;\n+  // ASan will write logs to \"log_path.pid\" instead of stderr.\n+  const char *log_path;\n+};\n+\n+Flags *flags();\n+void InitializeFlags(Flags *f, const char *env);\n+\n+}  // namespace __asan\n+\n+#endif  // ASAN_FLAGS_H"}, {"sha": "b195a9091b34ba6311d38a51a957b75e7630c914", "filename": "libsanitizer/asan/asan_globals.cc", "status": "added", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_globals.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_globals.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_globals.cc?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,206 @@\n+//===-- asan_globals.cc ---------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// Handle globals.\n+//===----------------------------------------------------------------------===//\n+#include \"asan_interceptors.h\"\n+#include \"asan_internal.h\"\n+#include \"asan_lock.h\"\n+#include \"asan_mapping.h\"\n+#include \"asan_report.h\"\n+#include \"asan_stack.h\"\n+#include \"asan_stats.h\"\n+#include \"asan_thread.h\"\n+#include \"sanitizer/asan_interface.h\"\n+\n+namespace __asan {\n+\n+typedef __asan_global Global;\n+\n+struct ListOfGlobals {\n+  const Global *g;\n+  ListOfGlobals *next;\n+};\n+\n+static AsanLock mu_for_globals(LINKER_INITIALIZED);\n+static LowLevelAllocator allocator_for_globals;\n+static ListOfGlobals *list_of_all_globals;\n+static ListOfGlobals *list_of_dynamic_init_globals;\n+\n+void PoisonRedZones(const Global &g)  {\n+  uptr shadow_rz_size = kGlobalAndStackRedzone >> SHADOW_SCALE;\n+  CHECK(shadow_rz_size == 1 || shadow_rz_size == 2 || shadow_rz_size == 4);\n+  // full right redzone\n+  uptr g_aligned_size = kGlobalAndStackRedzone *\n+      ((g.size + kGlobalAndStackRedzone - 1) / kGlobalAndStackRedzone);\n+  PoisonShadow(g.beg + g_aligned_size,\n+               kGlobalAndStackRedzone, kAsanGlobalRedzoneMagic);\n+  if ((g.size % kGlobalAndStackRedzone) != 0) {\n+    // partial right redzone\n+    u64 g_aligned_down_size = kGlobalAndStackRedzone *\n+        (g.size / kGlobalAndStackRedzone);\n+    CHECK(g_aligned_down_size == g_aligned_size - kGlobalAndStackRedzone);\n+    PoisonShadowPartialRightRedzone(g.beg + g_aligned_down_size,\n+                                    g.size % kGlobalAndStackRedzone,\n+                                    kGlobalAndStackRedzone,\n+                                    kAsanGlobalRedzoneMagic);\n+  }\n+}\n+\n+static uptr GetAlignedSize(uptr size) {\n+  return ((size + kGlobalAndStackRedzone - 1) / kGlobalAndStackRedzone)\n+      * kGlobalAndStackRedzone;\n+}\n+\n+bool DescribeAddressIfGlobal(uptr addr) {\n+  if (!flags()->report_globals) return false;\n+  ScopedLock lock(&mu_for_globals);\n+  bool res = false;\n+  for (ListOfGlobals *l = list_of_all_globals; l; l = l->next) {\n+    const Global &g = *l->g;\n+    if (flags()->report_globals >= 2)\n+      Report(\"Search Global: beg=%p size=%zu name=%s\\n\",\n+             (void*)g.beg, g.size, (char*)g.name);\n+    res |= DescribeAddressRelativeToGlobal(addr, g);\n+  }\n+  return res;\n+}\n+\n+// Register a global variable.\n+// This function may be called more than once for every global\n+// so we store the globals in a map.\n+static void RegisterGlobal(const Global *g) {\n+  CHECK(asan_inited);\n+  if (flags()->report_globals >= 2)\n+    Report(\"Added Global: beg=%p size=%zu/%zu name=%s dyn.init=%zu\\n\",\n+           (void*)g->beg, g->size, g->size_with_redzone, g->name,\n+           g->has_dynamic_init);\n+  CHECK(flags()->report_globals);\n+  CHECK(AddrIsInMem(g->beg));\n+  CHECK(AddrIsAlignedByGranularity(g->beg));\n+  CHECK(AddrIsAlignedByGranularity(g->size_with_redzone));\n+  PoisonRedZones(*g);\n+  ListOfGlobals *l =\n+      (ListOfGlobals*)allocator_for_globals.Allocate(sizeof(ListOfGlobals));\n+  l->g = g;\n+  l->next = list_of_all_globals;\n+  list_of_all_globals = l;\n+  if (g->has_dynamic_init) {\n+    l = (ListOfGlobals*)allocator_for_globals.Allocate(sizeof(ListOfGlobals));\n+    l->g = g;\n+    l->next = list_of_dynamic_init_globals;\n+    list_of_dynamic_init_globals = l;\n+  }\n+}\n+\n+static void UnregisterGlobal(const Global *g) {\n+  CHECK(asan_inited);\n+  CHECK(flags()->report_globals);\n+  CHECK(AddrIsInMem(g->beg));\n+  CHECK(AddrIsAlignedByGranularity(g->beg));\n+  CHECK(AddrIsAlignedByGranularity(g->size_with_redzone));\n+  PoisonShadow(g->beg, g->size_with_redzone, 0);\n+  // We unpoison the shadow memory for the global but we do not remove it from\n+  // the list because that would require O(n^2) time with the current list\n+  // implementation. It might not be worth doing anyway.\n+}\n+\n+// Poison all shadow memory for a single global.\n+static void PoisonGlobalAndRedzones(const Global *g) {\n+  CHECK(asan_inited);\n+  CHECK(flags()->check_initialization_order);\n+  CHECK(AddrIsInMem(g->beg));\n+  CHECK(AddrIsAlignedByGranularity(g->beg));\n+  CHECK(AddrIsAlignedByGranularity(g->size_with_redzone));\n+  if (flags()->report_globals >= 3)\n+    Printf(\"DynInitPoison  : %s\\n\", g->name);\n+  PoisonShadow(g->beg, g->size_with_redzone, kAsanInitializationOrderMagic);\n+}\n+\n+static void UnpoisonGlobal(const Global *g) {\n+  CHECK(asan_inited);\n+  CHECK(flags()->check_initialization_order);\n+  CHECK(AddrIsInMem(g->beg));\n+  CHECK(AddrIsAlignedByGranularity(g->beg));\n+  CHECK(AddrIsAlignedByGranularity(g->size_with_redzone));\n+  if (flags()->report_globals >= 3)\n+    Printf(\"DynInitUnpoison: %s\\n\", g->name);\n+  PoisonShadow(g->beg, g->size_with_redzone, 0);\n+  PoisonRedZones(*g);\n+}\n+\n+}  // namespace __asan\n+\n+// ---------------------- Interface ---------------- {{{1\n+using namespace __asan;  // NOLINT\n+\n+// Register one global with a default redzone.\n+void __asan_register_global(uptr addr, uptr size,\n+                            const char *name) {\n+  if (!flags()->report_globals) return;\n+  ScopedLock lock(&mu_for_globals);\n+  Global *g = (Global *)allocator_for_globals.Allocate(sizeof(Global));\n+  g->beg = addr;\n+  g->size = size;\n+  g->size_with_redzone = GetAlignedSize(size) + kGlobalAndStackRedzone;\n+  g->name = name;\n+  RegisterGlobal(g);\n+}\n+\n+// Register an array of globals.\n+void __asan_register_globals(__asan_global *globals, uptr n) {\n+  if (!flags()->report_globals) return;\n+  ScopedLock lock(&mu_for_globals);\n+  for (uptr i = 0; i < n; i++) {\n+    RegisterGlobal(&globals[i]);\n+  }\n+}\n+\n+// Unregister an array of globals.\n+// We must do this when a shared objects gets dlclosed.\n+void __asan_unregister_globals(__asan_global *globals, uptr n) {\n+  if (!flags()->report_globals) return;\n+  ScopedLock lock(&mu_for_globals);\n+  for (uptr i = 0; i < n; i++) {\n+    UnregisterGlobal(&globals[i]);\n+  }\n+}\n+\n+// This method runs immediately prior to dynamic initialization in each TU,\n+// when all dynamically initialized globals are unpoisoned.  This method\n+// poisons all global variables not defined in this TU, so that a dynamic\n+// initializer can only touch global variables in the same TU.\n+void __asan_before_dynamic_init(uptr first_addr, uptr last_addr) {\n+  if (!flags()->check_initialization_order) return;\n+  CHECK(list_of_dynamic_init_globals);\n+  ScopedLock lock(&mu_for_globals);\n+  bool from_current_tu = false;\n+  // The list looks like:\n+  // a => ... => b => last_addr => ... => first_addr => c => ...\n+  // The globals of the current TU reside between last_addr and first_addr.\n+  for (ListOfGlobals *l = list_of_dynamic_init_globals; l; l = l->next) {\n+    if (l->g->beg == last_addr)\n+      from_current_tu = true;\n+    if (!from_current_tu)\n+      PoisonGlobalAndRedzones(l->g);\n+    if (l->g->beg == first_addr)\n+      from_current_tu = false;\n+  }\n+  CHECK(!from_current_tu);\n+}\n+\n+// This method runs immediately after dynamic initialization in each TU, when\n+// all dynamically initialized globals except for those defined in the current\n+// TU are poisoned.  It simply unpoisons all dynamically initialized globals.\n+void __asan_after_dynamic_init() {\n+  if (!flags()->check_initialization_order) return;\n+  ScopedLock lock(&mu_for_globals);\n+  for (ListOfGlobals *l = list_of_dynamic_init_globals; l; l = l->next)\n+    UnpoisonGlobal(l->g);\n+}"}, {"sha": "ceb596cd48ecea2e309e7cddc5c85391b4703790", "filename": "libsanitizer/asan/asan_intercepted_functions.h", "status": "added", "additions": 217, "deletions": 0, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_intercepted_functions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_intercepted_functions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_intercepted_functions.h?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,217 @@\n+//===-- asan_intercepted_functions.h ----------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// ASan-private header containing prototypes for wrapper functions and wrappers\n+//===----------------------------------------------------------------------===//\n+#ifndef ASAN_INTERCEPTED_FUNCTIONS_H\n+#define ASAN_INTERCEPTED_FUNCTIONS_H\n+\n+#include \"asan_internal.h\"\n+#include \"interception/interception.h\"\n+\n+using __sanitizer::uptr;\n+\n+// Use macro to describe if specific function should be\n+// intercepted on a given platform.\n+#if !defined(_WIN32)\n+# define ASAN_INTERCEPT_ATOLL_AND_STRTOLL 1\n+# define ASAN_INTERCEPT__LONGJMP 1\n+# define ASAN_INTERCEPT_STRDUP 1\n+# define ASAN_INTERCEPT_STRCASECMP_AND_STRNCASECMP 1\n+# define ASAN_INTERCEPT_INDEX 1\n+# define ASAN_INTERCEPT_PTHREAD_CREATE 1\n+# define ASAN_INTERCEPT_MLOCKX 1\n+#else\n+# define ASAN_INTERCEPT_ATOLL_AND_STRTOLL 0\n+# define ASAN_INTERCEPT__LONGJMP 0\n+# define ASAN_INTERCEPT_STRDUP 0\n+# define ASAN_INTERCEPT_STRCASECMP_AND_STRNCASECMP 0\n+# define ASAN_INTERCEPT_INDEX 0\n+# define ASAN_INTERCEPT_PTHREAD_CREATE 0\n+# define ASAN_INTERCEPT_MLOCKX 0\n+#endif\n+\n+#if defined(__linux__)\n+# define ASAN_USE_ALIAS_ATTRIBUTE_FOR_INDEX 1\n+#else\n+# define ASAN_USE_ALIAS_ATTRIBUTE_FOR_INDEX 0\n+#endif\n+\n+#if !defined(__APPLE__)\n+# define ASAN_INTERCEPT_STRNLEN 1\n+#else\n+# define ASAN_INTERCEPT_STRNLEN 0\n+#endif\n+\n+#if !defined(ANDROID) && !defined(_WIN32)\n+# define ASAN_INTERCEPT_SIGNAL_AND_SIGACTION 1\n+#else\n+# define ASAN_INTERCEPT_SIGNAL_AND_SIGACTION 0\n+#endif\n+\n+// On Darwin siglongjmp tailcalls longjmp, so we don't want to intercept it\n+// there.\n+#if !defined(_WIN32) && (!defined(__APPLE__) || MAC_INTERPOSE_FUNCTIONS)\n+# define ASAN_INTERCEPT_SIGLONGJMP 1\n+#else\n+# define ASAN_INTERCEPT_SIGLONGJMP 0\n+#endif\n+\n+#if ASAN_HAS_EXCEPTIONS && !defined(_WIN32)\n+# define ASAN_INTERCEPT___CXA_THROW 1\n+#else\n+# define ASAN_INTERCEPT___CXA_THROW 0\n+#endif\n+\n+#define DECLARE_FUNCTION_AND_WRAPPER(ret_type, func, ...) \\\n+  ret_type func(__VA_ARGS__); \\\n+  ret_type WRAP(func)(__VA_ARGS__)\n+\n+// Use extern declarations of intercepted functions on Mac and Windows\n+// to avoid including system headers.\n+#if defined(__APPLE__) || (defined(_WIN32) && !defined(_DLL))\n+extern \"C\" {\n+// signal.h\n+# if ASAN_INTERCEPT_SIGNAL_AND_SIGACTION\n+struct sigaction;\n+DECLARE_FUNCTION_AND_WRAPPER(int, sigaction, int sig,\n+              const struct sigaction *act,\n+              struct sigaction *oldact);\n+DECLARE_FUNCTION_AND_WRAPPER(void*, signal, int signum, void *handler);\n+# endif\n+\n+// setjmp.h\n+DECLARE_FUNCTION_AND_WRAPPER(void, longjmp, void *env, int value);\n+# if ASAN_INTERCEPT__LONGJMP\n+DECLARE_FUNCTION_AND_WRAPPER(void, _longjmp, void *env, int value);\n+# endif\n+# if ASAN_INTERCEPT_SIGLONGJMP\n+DECLARE_FUNCTION_AND_WRAPPER(void, siglongjmp, void *env, int value);\n+# endif\n+# if ASAN_INTERCEPT___CXA_THROW\n+DECLARE_FUNCTION_AND_WRAPPER(void, __cxa_throw, void *a, void *b, void *c);\n+#endif\n+\n+// string.h / strings.h\n+DECLARE_FUNCTION_AND_WRAPPER(int, memcmp,\n+                             const void *a1, const void *a2, uptr size);\n+DECLARE_FUNCTION_AND_WRAPPER(void*, memmove,\n+                             void *to, const void *from, uptr size);\n+DECLARE_FUNCTION_AND_WRAPPER(void*, memcpy,\n+                             void *to, const void *from, uptr size);\n+DECLARE_FUNCTION_AND_WRAPPER(void*, memset, void *block, int c, uptr size);\n+DECLARE_FUNCTION_AND_WRAPPER(char*, strchr, const char *str, int c);\n+DECLARE_FUNCTION_AND_WRAPPER(char*, strcat,  /* NOLINT */\n+                             char *to, const char* from);\n+DECLARE_FUNCTION_AND_WRAPPER(char*, strncat,\n+                             char *to, const char* from, uptr size);\n+DECLARE_FUNCTION_AND_WRAPPER(char*, strcpy,  /* NOLINT */\n+                             char *to, const char* from);\n+DECLARE_FUNCTION_AND_WRAPPER(char*, strncpy,\n+                             char *to, const char* from, uptr size);\n+DECLARE_FUNCTION_AND_WRAPPER(int, strcmp, const char *s1, const char* s2);\n+DECLARE_FUNCTION_AND_WRAPPER(int, strncmp,\n+                             const char *s1, const char* s2, uptr size);\n+DECLARE_FUNCTION_AND_WRAPPER(uptr, strlen, const char *s);\n+# if ASAN_INTERCEPT_STRCASECMP_AND_STRNCASECMP\n+DECLARE_FUNCTION_AND_WRAPPER(int, strcasecmp, const char *s1, const char *s2);\n+DECLARE_FUNCTION_AND_WRAPPER(int, strncasecmp,\n+                             const char *s1, const char *s2, uptr n);\n+# endif\n+# if ASAN_INTERCEPT_STRDUP\n+DECLARE_FUNCTION_AND_WRAPPER(char*, strdup, const char *s);\n+# endif\n+# if ASAN_INTERCEPT_STRNLEN\n+DECLARE_FUNCTION_AND_WRAPPER(uptr, strnlen, const char *s, uptr maxlen);\n+# endif\n+#if ASAN_INTERCEPT_INDEX\n+DECLARE_FUNCTION_AND_WRAPPER(char*, index, const char *string, int c);\n+#endif\n+\n+// stdlib.h\n+DECLARE_FUNCTION_AND_WRAPPER(int, atoi, const char *nptr);\n+DECLARE_FUNCTION_AND_WRAPPER(long, atol, const char *nptr);  // NOLINT\n+DECLARE_FUNCTION_AND_WRAPPER(long, strtol, const char *nptr, char **endptr, int base);  // NOLINT\n+# if ASAN_INTERCEPT_ATOLL_AND_STRTOLL\n+DECLARE_FUNCTION_AND_WRAPPER(long long, atoll, const char *nptr);  // NOLINT\n+DECLARE_FUNCTION_AND_WRAPPER(long long, strtoll, const char *nptr, char **endptr, int base);  // NOLINT\n+# endif\n+\n+# if ASAN_INTERCEPT_MLOCKX\n+// mlock/munlock\n+DECLARE_FUNCTION_AND_WRAPPER(int, mlock, const void *addr, size_t len);\n+DECLARE_FUNCTION_AND_WRAPPER(int, munlock, const void *addr, size_t len);\n+DECLARE_FUNCTION_AND_WRAPPER(int, mlockall, int flags);\n+DECLARE_FUNCTION_AND_WRAPPER(int, munlockall, void);\n+# endif\n+\n+// Windows threads.\n+# if defined(_WIN32)\n+__declspec(dllimport)\n+void* __stdcall CreateThread(void *sec, uptr st, void* start,\n+                             void *arg, DWORD fl, DWORD *id);\n+# endif\n+// Posix threads.\n+# if ASAN_INTERCEPT_PTHREAD_CREATE\n+DECLARE_FUNCTION_AND_WRAPPER(int, pthread_create,\n+                             void *thread, void *attr,\n+                             void *(*start_routine)(void*), void *arg);\n+# endif\n+\n+#if defined(__APPLE__)\n+typedef void* pthread_workqueue_t;\n+typedef void* pthread_workitem_handle_t;\n+\n+typedef void* dispatch_group_t;\n+typedef void* dispatch_queue_t;\n+typedef void* dispatch_source_t;\n+typedef u64 dispatch_time_t;\n+typedef void (*dispatch_function_t)(void *block);\n+typedef void* (*worker_t)(void *block);\n+typedef void* CFStringRef;\n+typedef void* CFAllocatorRef;\n+\n+DECLARE_FUNCTION_AND_WRAPPER(void, dispatch_async_f,\n+                             dispatch_queue_t dq,\n+                             void *ctxt, dispatch_function_t func);\n+DECLARE_FUNCTION_AND_WRAPPER(void, dispatch_sync_f,\n+                             dispatch_queue_t dq,\n+                             void *ctxt, dispatch_function_t func);\n+DECLARE_FUNCTION_AND_WRAPPER(void, dispatch_after_f,\n+                             dispatch_time_t when, dispatch_queue_t dq,\n+                             void *ctxt, dispatch_function_t func);\n+DECLARE_FUNCTION_AND_WRAPPER(void, dispatch_barrier_async_f,\n+                             dispatch_queue_t dq,\n+                             void *ctxt, dispatch_function_t func);\n+DECLARE_FUNCTION_AND_WRAPPER(void, dispatch_group_async_f,\n+                             dispatch_group_t group, dispatch_queue_t dq,\n+                             void *ctxt, dispatch_function_t func);\n+\n+DECLARE_FUNCTION_AND_WRAPPER(void, __CFInitialize, void);\n+DECLARE_FUNCTION_AND_WRAPPER(CFStringRef, CFStringCreateCopy,\n+                             CFAllocatorRef alloc, CFStringRef str);\n+DECLARE_FUNCTION_AND_WRAPPER(void, free, void* ptr);\n+#if MAC_INTERPOSE_FUNCTIONS\n+DECLARE_FUNCTION_AND_WRAPPER(void, dispatch_group_async,\n+                             dispatch_group_t dg,\n+                             dispatch_queue_t dq, void (^work)(void));\n+DECLARE_FUNCTION_AND_WRAPPER(void, dispatch_async,\n+                             dispatch_queue_t dq, void (^work)(void));\n+DECLARE_FUNCTION_AND_WRAPPER(void, dispatch_after,\n+                             dispatch_queue_t dq, void (^work)(void));\n+DECLARE_FUNCTION_AND_WRAPPER(void, dispatch_source_set_event_handler,\n+                             dispatch_source_t ds, void (^work)(void));\n+DECLARE_FUNCTION_AND_WRAPPER(void, dispatch_source_set_cancel_handler,\n+                             dispatch_source_t ds, void (^work)(void));\n+#endif  // MAC_INTERPOSE_FUNCTIONS\n+#endif  // __APPLE__\n+}  // extern \"C\"\n+#endif\n+\n+#endif  // ASAN_INTERCEPTED_FUNCTIONS_H"}, {"sha": "8e15d341b8c521efaafbbe572e3783d46a3751b0", "filename": "libsanitizer/asan/asan_interceptors.cc", "status": "added", "additions": 704, "deletions": 0, "changes": 704, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_interceptors.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_interceptors.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interceptors.cc?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,704 @@\n+//===-- asan_interceptors.cc ----------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// Intercept various libc functions.\n+//===----------------------------------------------------------------------===//\n+#include \"asan_interceptors.h\"\n+\n+#include \"asan_allocator.h\"\n+#include \"asan_intercepted_functions.h\"\n+#include \"asan_internal.h\"\n+#include \"asan_mapping.h\"\n+#include \"asan_report.h\"\n+#include \"asan_stack.h\"\n+#include \"asan_stats.h\"\n+#include \"asan_thread_registry.h\"\n+#include \"interception/interception.h\"\n+#include \"sanitizer/asan_interface.h\"\n+#include \"sanitizer_common/sanitizer_libc.h\"\n+\n+namespace __asan {\n+\n+// Instruments read/write access to a single byte in memory.\n+// On error calls __asan_report_error, which aborts the program.\n+#define ACCESS_ADDRESS(address, isWrite)   do {         \\\n+  if (!AddrIsInMem(address) || AddressIsPoisoned(address)) {                \\\n+    GET_CURRENT_PC_BP_SP;                               \\\n+    __asan_report_error(pc, bp, sp, address, isWrite, /* access_size */ 1); \\\n+  } \\\n+} while (0)\n+\n+// We implement ACCESS_MEMORY_RANGE, ASAN_READ_RANGE,\n+// and ASAN_WRITE_RANGE as macro instead of function so\n+// that no extra frames are created, and stack trace contains\n+// relevant information only.\n+\n+// Instruments read/write access to a memory range.\n+// More complex implementation is possible, for now just\n+// checking the first and the last byte of a range.\n+#define ACCESS_MEMORY_RANGE(offset, size, isWrite) do { \\\n+  if (size > 0) { \\\n+    uptr ptr = (uptr)(offset); \\\n+    ACCESS_ADDRESS(ptr, isWrite); \\\n+    ACCESS_ADDRESS(ptr + (size) - 1, isWrite); \\\n+  } \\\n+} while (0)\n+\n+#define ASAN_READ_RANGE(offset, size) do { \\\n+  ACCESS_MEMORY_RANGE(offset, size, false); \\\n+} while (0)\n+\n+#define ASAN_WRITE_RANGE(offset, size) do { \\\n+  ACCESS_MEMORY_RANGE(offset, size, true); \\\n+} while (0)\n+\n+// Behavior of functions like \"memcpy\" or \"strcpy\" is undefined\n+// if memory intervals overlap. We report error in this case.\n+// Macro is used to avoid creation of new frames.\n+static inline bool RangesOverlap(const char *offset1, uptr length1,\n+                                 const char *offset2, uptr length2) {\n+  return !((offset1 + length1 <= offset2) || (offset2 + length2 <= offset1));\n+}\n+#define CHECK_RANGES_OVERLAP(name, _offset1, length1, _offset2, length2) do { \\\n+  const char *offset1 = (const char*)_offset1; \\\n+  const char *offset2 = (const char*)_offset2; \\\n+  if (RangesOverlap(offset1, length1, offset2, length2)) { \\\n+    GET_STACK_TRACE_HERE(kStackTraceMax); \\\n+    ReportStringFunctionMemoryRangesOverlap(name, offset1, length1, \\\n+                                            offset2, length2, &stack); \\\n+  } \\\n+} while (0)\n+\n+#define ENSURE_ASAN_INITED() do { \\\n+  CHECK(!asan_init_is_running); \\\n+  if (!asan_inited) { \\\n+    __asan_init(); \\\n+  } \\\n+} while (0)\n+\n+static inline uptr MaybeRealStrnlen(const char *s, uptr maxlen) {\n+#if ASAN_INTERCEPT_STRNLEN\n+  if (REAL(strnlen) != 0) {\n+    return REAL(strnlen)(s, maxlen);\n+  }\n+#endif\n+  return internal_strnlen(s, maxlen);\n+}\n+\n+}  // namespace __asan\n+\n+// ---------------------- Wrappers ---------------- {{{1\n+using namespace __asan;  // NOLINT\n+\n+static thread_return_t THREAD_CALLING_CONV asan_thread_start(void *arg) {\n+  AsanThread *t = (AsanThread*)arg;\n+  asanThreadRegistry().SetCurrent(t);\n+  return t->ThreadStart();\n+}\n+\n+#if ASAN_INTERCEPT_PTHREAD_CREATE\n+INTERCEPTOR(int, pthread_create, void *thread,\n+    void *attr, void *(*start_routine)(void*), void *arg) {\n+  GET_STACK_TRACE_HERE(kStackTraceMax);\n+  u32 current_tid = asanThreadRegistry().GetCurrentTidOrInvalid();\n+  AsanThread *t = AsanThread::Create(current_tid, start_routine, arg, &stack);\n+  asanThreadRegistry().RegisterThread(t);\n+  return REAL(pthread_create)(thread, attr, asan_thread_start, t);\n+}\n+#endif  // ASAN_INTERCEPT_PTHREAD_CREATE\n+\n+#if ASAN_INTERCEPT_SIGNAL_AND_SIGACTION\n+INTERCEPTOR(void*, signal, int signum, void *handler) {\n+  if (!AsanInterceptsSignal(signum)) {\n+    return REAL(signal)(signum, handler);\n+  }\n+  return 0;\n+}\n+\n+INTERCEPTOR(int, sigaction, int signum, const struct sigaction *act,\n+                            struct sigaction *oldact) {\n+  if (!AsanInterceptsSignal(signum)) {\n+    return REAL(sigaction)(signum, act, oldact);\n+  }\n+  return 0;\n+}\n+#elif ASAN_POSIX\n+// We need to have defined REAL(sigaction) on posix systems.\n+DEFINE_REAL(int, sigaction, int signum, const struct sigaction *act,\n+    struct sigaction *oldact);\n+#endif  // ASAN_INTERCEPT_SIGNAL_AND_SIGACTION\n+\n+INTERCEPTOR(void, longjmp, void *env, int val) {\n+  __asan_handle_no_return();\n+  REAL(longjmp)(env, val);\n+}\n+\n+#if ASAN_INTERCEPT__LONGJMP\n+INTERCEPTOR(void, _longjmp, void *env, int val) {\n+  __asan_handle_no_return();\n+  REAL(_longjmp)(env, val);\n+}\n+#endif\n+\n+#if ASAN_INTERCEPT_SIGLONGJMP\n+INTERCEPTOR(void, siglongjmp, void *env, int val) {\n+  __asan_handle_no_return();\n+  REAL(siglongjmp)(env, val);\n+}\n+#endif\n+\n+#if ASAN_INTERCEPT___CXA_THROW\n+INTERCEPTOR(void, __cxa_throw, void *a, void *b, void *c) {\n+  CHECK(REAL(__cxa_throw));\n+  __asan_handle_no_return();\n+  REAL(__cxa_throw)(a, b, c);\n+}\n+#endif\n+\n+// intercept mlock and friends.\n+// Since asan maps 16T of RAM, mlock is completely unfriendly to asan.\n+// All functions return 0 (success).\n+static void MlockIsUnsupported() {\n+  static bool printed = 0;\n+  if (printed) return;\n+  printed = true;\n+  Printf(\"INFO: AddressSanitizer ignores mlock/mlockall/munlock/munlockall\\n\");\n+}\n+\n+extern \"C\" {\n+INTERCEPTOR(int, mlock, const void *addr, uptr len) {\n+  MlockIsUnsupported();\n+  return 0;\n+}\n+\n+INTERCEPTOR(int, munlock, const void *addr, uptr len) {\n+  MlockIsUnsupported();\n+  return 0;\n+}\n+\n+INTERCEPTOR(int, mlockall, int flags) {\n+  MlockIsUnsupported();\n+  return 0;\n+}\n+\n+INTERCEPTOR(int, munlockall, void) {\n+  MlockIsUnsupported();\n+  return 0;\n+}\n+}  // extern \"C\"\n+\n+static inline int CharCmp(unsigned char c1, unsigned char c2) {\n+  return (c1 == c2) ? 0 : (c1 < c2) ? -1 : 1;\n+}\n+\n+static inline int CharCaseCmp(unsigned char c1, unsigned char c2) {\n+  int c1_low = ToLower(c1);\n+  int c2_low = ToLower(c2);\n+  return c1_low - c2_low;\n+}\n+\n+INTERCEPTOR(int, memcmp, const void *a1, const void *a2, uptr size) {\n+  if (!asan_inited) return internal_memcmp(a1, a2, size);\n+  ENSURE_ASAN_INITED();\n+  unsigned char c1 = 0, c2 = 0;\n+  const unsigned char *s1 = (const unsigned char*)a1;\n+  const unsigned char *s2 = (const unsigned char*)a2;\n+  uptr i;\n+  for (i = 0; i < size; i++) {\n+    c1 = s1[i];\n+    c2 = s2[i];\n+    if (c1 != c2) break;\n+  }\n+  ASAN_READ_RANGE(s1, Min(i + 1, size));\n+  ASAN_READ_RANGE(s2, Min(i + 1, size));\n+  return CharCmp(c1, c2);\n+}\n+\n+INTERCEPTOR(void*, memcpy, void *to, const void *from, uptr size) {\n+  if (!asan_inited) return internal_memcpy(to, from, size);\n+  // memcpy is called during __asan_init() from the internals\n+  // of printf(...).\n+  if (asan_init_is_running) {\n+    return REAL(memcpy)(to, from, size);\n+  }\n+  ENSURE_ASAN_INITED();\n+  if (flags()->replace_intrin) {\n+    if (to != from) {\n+      // We do not treat memcpy with to==from as a bug.\n+      // See http://llvm.org/bugs/show_bug.cgi?id=11763.\n+      CHECK_RANGES_OVERLAP(\"memcpy\", to, size, from, size);\n+    }\n+    ASAN_WRITE_RANGE(from, size);\n+    ASAN_READ_RANGE(to, size);\n+  }\n+  return REAL(memcpy)(to, from, size);\n+}\n+\n+INTERCEPTOR(void*, memmove, void *to, const void *from, uptr size) {\n+#if MAC_INTERPOSE_FUNCTIONS\n+  if (!asan_inited) return REAL(memmove)(to, from, size);\n+#endif\n+  if (asan_init_is_running) {\n+    return REAL(memmove)(to, from, size);\n+  }\n+  ENSURE_ASAN_INITED();\n+  if (flags()->replace_intrin) {\n+    ASAN_WRITE_RANGE(from, size);\n+    ASAN_READ_RANGE(to, size);\n+  }\n+  return REAL(memmove)(to, from, size);\n+}\n+\n+INTERCEPTOR(void*, memset, void *block, int c, uptr size) {\n+  if (!asan_inited) return internal_memset(block, c, size);\n+  // memset is called inside Printf.\n+  if (asan_init_is_running) {\n+    return REAL(memset)(block, c, size);\n+  }\n+  ENSURE_ASAN_INITED();\n+  if (flags()->replace_intrin) {\n+    ASAN_WRITE_RANGE(block, size);\n+  }\n+  return REAL(memset)(block, c, size);\n+}\n+\n+INTERCEPTOR(char*, strchr, const char *str, int c) {\n+  if (!asan_inited) return internal_strchr(str, c);\n+  // strchr is called inside create_purgeable_zone() when MallocGuardEdges=1 is\n+  // used.\n+  if (asan_init_is_running) {\n+    return REAL(strchr)(str, c);\n+  }\n+  ENSURE_ASAN_INITED();\n+  char *result = REAL(strchr)(str, c);\n+  if (flags()->replace_str) {\n+    uptr bytes_read = (result ? result - str : REAL(strlen)(str)) + 1;\n+    ASAN_READ_RANGE(str, bytes_read);\n+  }\n+  return result;\n+}\n+\n+#if ASAN_INTERCEPT_INDEX\n+# if ASAN_USE_ALIAS_ATTRIBUTE_FOR_INDEX\n+INTERCEPTOR(char*, index, const char *string, int c)\n+  ALIAS(WRAPPER_NAME(strchr));\n+# else\n+DEFINE_REAL(char*, index, const char *string, int c)\n+# endif\n+#endif  // ASAN_INTERCEPT_INDEX\n+\n+// For both strcat() and strncat() we need to check the validity of |to|\n+// argument irrespective of the |from| length.\n+INTERCEPTOR(char*, strcat, char *to, const char *from) {  // NOLINT\n+  ENSURE_ASAN_INITED();\n+  if (flags()->replace_str) {\n+    uptr from_length = REAL(strlen)(from);\n+    ASAN_READ_RANGE(from, from_length + 1);\n+    uptr to_length = REAL(strlen)(to);\n+    ASAN_READ_RANGE(to, to_length);\n+    ASAN_WRITE_RANGE(to + to_length, from_length + 1);\n+    // If the copying actually happens, the |from| string should not overlap\n+    // with the resulting string starting at |to|, which has a length of\n+    // to_length + from_length + 1.\n+    if (from_length > 0) {\n+      CHECK_RANGES_OVERLAP(\"strcat\", to, from_length + to_length + 1,\n+                           from, from_length + 1);\n+    }\n+  }\n+  return REAL(strcat)(to, from);  // NOLINT\n+}\n+\n+INTERCEPTOR(char*, strncat, char *to, const char *from, uptr size) {\n+  ENSURE_ASAN_INITED();\n+  if (flags()->replace_str) {\n+    uptr from_length = MaybeRealStrnlen(from, size);\n+    uptr copy_length = Min(size, from_length + 1);\n+    ASAN_READ_RANGE(from, copy_length);\n+    uptr to_length = REAL(strlen)(to);\n+    ASAN_READ_RANGE(to, to_length);\n+    ASAN_WRITE_RANGE(to + to_length, from_length + 1);\n+    if (from_length > 0) {\n+      CHECK_RANGES_OVERLAP(\"strncat\", to, to_length + copy_length + 1,\n+                           from, copy_length);\n+    }\n+  }\n+  return REAL(strncat)(to, from, size);\n+}\n+\n+INTERCEPTOR(int, strcmp, const char *s1, const char *s2) {\n+  if (!asan_inited) return internal_strcmp(s1, s2);\n+  if (asan_init_is_running) {\n+    return REAL(strcmp)(s1, s2);\n+  }\n+  ENSURE_ASAN_INITED();\n+  unsigned char c1, c2;\n+  uptr i;\n+  for (i = 0; ; i++) {\n+    c1 = (unsigned char)s1[i];\n+    c2 = (unsigned char)s2[i];\n+    if (c1 != c2 || c1 == '\\0') break;\n+  }\n+  ASAN_READ_RANGE(s1, i + 1);\n+  ASAN_READ_RANGE(s2, i + 1);\n+  return CharCmp(c1, c2);\n+}\n+\n+INTERCEPTOR(char*, strcpy, char *to, const char *from) {  // NOLINT\n+#if MAC_INTERPOSE_FUNCTIONS\n+  if (!asan_inited) return REAL(strcpy)(to, from);  // NOLINT\n+#endif\n+  // strcpy is called from malloc_default_purgeable_zone()\n+  // in __asan::ReplaceSystemAlloc() on Mac.\n+  if (asan_init_is_running) {\n+    return REAL(strcpy)(to, from);  // NOLINT\n+  }\n+  ENSURE_ASAN_INITED();\n+  if (flags()->replace_str) {\n+    uptr from_size = REAL(strlen)(from) + 1;\n+    CHECK_RANGES_OVERLAP(\"strcpy\", to, from_size, from, from_size);\n+    ASAN_READ_RANGE(from, from_size);\n+    ASAN_WRITE_RANGE(to, from_size);\n+  }\n+  return REAL(strcpy)(to, from);  // NOLINT\n+}\n+\n+#if ASAN_INTERCEPT_STRDUP\n+INTERCEPTOR(char*, strdup, const char *s) {\n+  if (!asan_inited) return internal_strdup(s);\n+  ENSURE_ASAN_INITED();\n+  if (flags()->replace_str) {\n+    uptr length = REAL(strlen)(s);\n+    ASAN_READ_RANGE(s, length + 1);\n+  }\n+  return REAL(strdup)(s);\n+}\n+#endif\n+\n+INTERCEPTOR(uptr, strlen, const char *s) {\n+  if (!asan_inited) return internal_strlen(s);\n+  // strlen is called from malloc_default_purgeable_zone()\n+  // in __asan::ReplaceSystemAlloc() on Mac.\n+  if (asan_init_is_running) {\n+    return REAL(strlen)(s);\n+  }\n+  ENSURE_ASAN_INITED();\n+  uptr length = REAL(strlen)(s);\n+  if (flags()->replace_str) {\n+    ASAN_READ_RANGE(s, length + 1);\n+  }\n+  return length;\n+}\n+\n+#if ASAN_INTERCEPT_STRCASECMP_AND_STRNCASECMP\n+INTERCEPTOR(int, strcasecmp, const char *s1, const char *s2) {\n+  ENSURE_ASAN_INITED();\n+  unsigned char c1, c2;\n+  uptr i;\n+  for (i = 0; ; i++) {\n+    c1 = (unsigned char)s1[i];\n+    c2 = (unsigned char)s2[i];\n+    if (CharCaseCmp(c1, c2) != 0 || c1 == '\\0') break;\n+  }\n+  ASAN_READ_RANGE(s1, i + 1);\n+  ASAN_READ_RANGE(s2, i + 1);\n+  return CharCaseCmp(c1, c2);\n+}\n+\n+INTERCEPTOR(int, strncasecmp, const char *s1, const char *s2, uptr n) {\n+  ENSURE_ASAN_INITED();\n+  unsigned char c1 = 0, c2 = 0;\n+  uptr i;\n+  for (i = 0; i < n; i++) {\n+    c1 = (unsigned char)s1[i];\n+    c2 = (unsigned char)s2[i];\n+    if (CharCaseCmp(c1, c2) != 0 || c1 == '\\0') break;\n+  }\n+  ASAN_READ_RANGE(s1, Min(i + 1, n));\n+  ASAN_READ_RANGE(s2, Min(i + 1, n));\n+  return CharCaseCmp(c1, c2);\n+}\n+#endif  // ASAN_INTERCEPT_STRCASECMP_AND_STRNCASECMP\n+\n+INTERCEPTOR(int, strncmp, const char *s1, const char *s2, uptr size) {\n+  if (!asan_inited) return internal_strncmp(s1, s2, size);\n+  // strncmp is called from malloc_default_purgeable_zone()\n+  // in __asan::ReplaceSystemAlloc() on Mac.\n+  if (asan_init_is_running) {\n+    return REAL(strncmp)(s1, s2, size);\n+  }\n+  ENSURE_ASAN_INITED();\n+  unsigned char c1 = 0, c2 = 0;\n+  uptr i;\n+  for (i = 0; i < size; i++) {\n+    c1 = (unsigned char)s1[i];\n+    c2 = (unsigned char)s2[i];\n+    if (c1 != c2 || c1 == '\\0') break;\n+  }\n+  ASAN_READ_RANGE(s1, Min(i + 1, size));\n+  ASAN_READ_RANGE(s2, Min(i + 1, size));\n+  return CharCmp(c1, c2);\n+}\n+\n+INTERCEPTOR(char*, strncpy, char *to, const char *from, uptr size) {\n+  ENSURE_ASAN_INITED();\n+  if (flags()->replace_str) {\n+    uptr from_size = Min(size, MaybeRealStrnlen(from, size) + 1);\n+    CHECK_RANGES_OVERLAP(\"strncpy\", to, from_size, from, from_size);\n+    ASAN_READ_RANGE(from, from_size);\n+    ASAN_WRITE_RANGE(to, size);\n+  }\n+  return REAL(strncpy)(to, from, size);\n+}\n+\n+#if ASAN_INTERCEPT_STRNLEN\n+INTERCEPTOR(uptr, strnlen, const char *s, uptr maxlen) {\n+  ENSURE_ASAN_INITED();\n+  uptr length = REAL(strnlen)(s, maxlen);\n+  if (flags()->replace_str) {\n+    ASAN_READ_RANGE(s, Min(length + 1, maxlen));\n+  }\n+  return length;\n+}\n+#endif  // ASAN_INTERCEPT_STRNLEN\n+\n+static inline bool IsValidStrtolBase(int base) {\n+  return (base == 0) || (2 <= base && base <= 36);\n+}\n+\n+static inline void FixRealStrtolEndptr(const char *nptr, char **endptr) {\n+  CHECK(endptr != 0);\n+  if (nptr == *endptr) {\n+    // No digits were found at strtol call, we need to find out the last\n+    // symbol accessed by strtoll on our own.\n+    // We get this symbol by skipping leading blanks and optional +/- sign.\n+    while (IsSpace(*nptr)) nptr++;\n+    if (*nptr == '+' || *nptr == '-') nptr++;\n+    *endptr = (char*)nptr;\n+  }\n+  CHECK(*endptr >= nptr);\n+}\n+\n+INTERCEPTOR(long, strtol, const char *nptr,  // NOLINT\n+            char **endptr, int base) {\n+  ENSURE_ASAN_INITED();\n+  if (!flags()->replace_str) {\n+    return REAL(strtol)(nptr, endptr, base);\n+  }\n+  char *real_endptr;\n+  long result = REAL(strtol)(nptr, &real_endptr, base);  // NOLINT\n+  if (endptr != 0) {\n+    *endptr = real_endptr;\n+  }\n+  if (IsValidStrtolBase(base)) {\n+    FixRealStrtolEndptr(nptr, &real_endptr);\n+    ASAN_READ_RANGE(nptr, (real_endptr - nptr) + 1);\n+  }\n+  return result;\n+}\n+\n+INTERCEPTOR(int, atoi, const char *nptr) {\n+#if MAC_INTERPOSE_FUNCTIONS\n+  if (!asan_inited) return REAL(atoi)(nptr);\n+#endif\n+  ENSURE_ASAN_INITED();\n+  if (!flags()->replace_str) {\n+    return REAL(atoi)(nptr);\n+  }\n+  char *real_endptr;\n+  // \"man atoi\" tells that behavior of atoi(nptr) is the same as\n+  // strtol(nptr, 0, 10), i.e. it sets errno to ERANGE if the\n+  // parsed integer can't be stored in *long* type (even if it's\n+  // different from int). So, we just imitate this behavior.\n+  int result = REAL(strtol)(nptr, &real_endptr, 10);\n+  FixRealStrtolEndptr(nptr, &real_endptr);\n+  ASAN_READ_RANGE(nptr, (real_endptr - nptr) + 1);\n+  return result;\n+}\n+\n+INTERCEPTOR(long, atol, const char *nptr) {  // NOLINT\n+#if MAC_INTERPOSE_FUNCTIONS\n+  if (!asan_inited) return REAL(atol)(nptr);\n+#endif\n+  ENSURE_ASAN_INITED();\n+  if (!flags()->replace_str) {\n+    return REAL(atol)(nptr);\n+  }\n+  char *real_endptr;\n+  long result = REAL(strtol)(nptr, &real_endptr, 10);  // NOLINT\n+  FixRealStrtolEndptr(nptr, &real_endptr);\n+  ASAN_READ_RANGE(nptr, (real_endptr - nptr) + 1);\n+  return result;\n+}\n+\n+#if ASAN_INTERCEPT_ATOLL_AND_STRTOLL\n+INTERCEPTOR(long long, strtoll, const char *nptr,  // NOLINT\n+            char **endptr, int base) {\n+  ENSURE_ASAN_INITED();\n+  if (!flags()->replace_str) {\n+    return REAL(strtoll)(nptr, endptr, base);\n+  }\n+  char *real_endptr;\n+  long long result = REAL(strtoll)(nptr, &real_endptr, base);  // NOLINT\n+  if (endptr != 0) {\n+    *endptr = real_endptr;\n+  }\n+  // If base has unsupported value, strtoll can exit with EINVAL\n+  // without reading any characters. So do additional checks only\n+  // if base is valid.\n+  if (IsValidStrtolBase(base)) {\n+    FixRealStrtolEndptr(nptr, &real_endptr);\n+    ASAN_READ_RANGE(nptr, (real_endptr - nptr) + 1);\n+  }\n+  return result;\n+}\n+\n+INTERCEPTOR(long long, atoll, const char *nptr) {  // NOLINT\n+  ENSURE_ASAN_INITED();\n+  if (!flags()->replace_str) {\n+    return REAL(atoll)(nptr);\n+  }\n+  char *real_endptr;\n+  long long result = REAL(strtoll)(nptr, &real_endptr, 10);  // NOLINT\n+  FixRealStrtolEndptr(nptr, &real_endptr);\n+  ASAN_READ_RANGE(nptr, (real_endptr - nptr) + 1);\n+  return result;\n+}\n+#endif  // ASAN_INTERCEPT_ATOLL_AND_STRTOLL\n+\n+#define ASAN_INTERCEPT_FUNC(name) do { \\\n+      if (!INTERCEPT_FUNCTION(name) && flags()->verbosity > 0) \\\n+        Report(\"AddressSanitizer: failed to intercept '\" #name \"'\\n\"); \\\n+    } while (0)\n+\n+#if defined(_WIN32)\n+INTERCEPTOR_WINAPI(DWORD, CreateThread,\n+                   void* security, uptr stack_size,\n+                   DWORD (__stdcall *start_routine)(void*), void* arg,\n+                   DWORD flags, void* tid) {\n+  GET_STACK_TRACE_HERE(kStackTraceMax);\n+  u32 current_tid = asanThreadRegistry().GetCurrentTidOrInvalid();\n+  AsanThread *t = AsanThread::Create(current_tid, start_routine, arg, &stack);\n+  asanThreadRegistry().RegisterThread(t);\n+  return REAL(CreateThread)(security, stack_size,\n+                            asan_thread_start, t, flags, tid);\n+}\n+\n+namespace __asan {\n+void InitializeWindowsInterceptors() {\n+  ASAN_INTERCEPT_FUNC(CreateThread);\n+}\n+\n+}  // namespace __asan\n+#endif\n+\n+// ---------------------- InitializeAsanInterceptors ---------------- {{{1\n+namespace __asan {\n+void InitializeAsanInterceptors() {\n+  static bool was_called_once;\n+  CHECK(was_called_once == false);\n+  was_called_once = true;\n+#if MAC_INTERPOSE_FUNCTIONS\n+  return;\n+#endif\n+  // Intercept mem* functions.\n+  ASAN_INTERCEPT_FUNC(memcmp);\n+  ASAN_INTERCEPT_FUNC(memmove);\n+  ASAN_INTERCEPT_FUNC(memset);\n+  if (PLATFORM_HAS_DIFFERENT_MEMCPY_AND_MEMMOVE) {\n+    ASAN_INTERCEPT_FUNC(memcpy);\n+  } else {\n+#if !MAC_INTERPOSE_FUNCTIONS\n+    // If we're using dynamic interceptors on Mac, these two are just plain\n+    // functions.\n+    internal_memcpy(&REAL(memcpy), &REAL(memmove), sizeof(REAL(memmove)));\n+#endif\n+  }\n+\n+  // Intercept str* functions.\n+  ASAN_INTERCEPT_FUNC(strcat);  // NOLINT\n+  ASAN_INTERCEPT_FUNC(strchr);\n+  ASAN_INTERCEPT_FUNC(strcmp);\n+  ASAN_INTERCEPT_FUNC(strcpy);  // NOLINT\n+  ASAN_INTERCEPT_FUNC(strlen);\n+  ASAN_INTERCEPT_FUNC(strncat);\n+  ASAN_INTERCEPT_FUNC(strncmp);\n+  ASAN_INTERCEPT_FUNC(strncpy);\n+#if ASAN_INTERCEPT_STRCASECMP_AND_STRNCASECMP\n+  ASAN_INTERCEPT_FUNC(strcasecmp);\n+  ASAN_INTERCEPT_FUNC(strncasecmp);\n+#endif\n+#if ASAN_INTERCEPT_STRDUP\n+  ASAN_INTERCEPT_FUNC(strdup);\n+#endif\n+#if ASAN_INTERCEPT_STRNLEN\n+  ASAN_INTERCEPT_FUNC(strnlen);\n+#endif\n+#if ASAN_INTERCEPT_INDEX\n+# if ASAN_USE_ALIAS_ATTRIBUTE_FOR_INDEX\n+  ASAN_INTERCEPT_FUNC(index);\n+# else\n+  CHECK(OVERRIDE_FUNCTION(index, WRAP(strchr)));\n+# endif\n+#endif\n+\n+  ASAN_INTERCEPT_FUNC(atoi);\n+  ASAN_INTERCEPT_FUNC(atol);\n+  ASAN_INTERCEPT_FUNC(strtol);\n+#if ASAN_INTERCEPT_ATOLL_AND_STRTOLL\n+  ASAN_INTERCEPT_FUNC(atoll);\n+  ASAN_INTERCEPT_FUNC(strtoll);\n+#endif\n+\n+#if ASAN_INTERCEPT_MLOCKX\n+  // Intercept mlock/munlock.\n+  ASAN_INTERCEPT_FUNC(mlock);\n+  ASAN_INTERCEPT_FUNC(munlock);\n+  ASAN_INTERCEPT_FUNC(mlockall);\n+  ASAN_INTERCEPT_FUNC(munlockall);\n+#endif\n+\n+  // Intecept signal- and jump-related functions.\n+  ASAN_INTERCEPT_FUNC(longjmp);\n+#if ASAN_INTERCEPT_SIGNAL_AND_SIGACTION\n+  ASAN_INTERCEPT_FUNC(sigaction);\n+  ASAN_INTERCEPT_FUNC(signal);\n+#endif\n+#if ASAN_INTERCEPT__LONGJMP\n+  ASAN_INTERCEPT_FUNC(_longjmp);\n+#endif\n+#if ASAN_INTERCEPT_SIGLONGJMP\n+  ASAN_INTERCEPT_FUNC(siglongjmp);\n+#endif\n+\n+  // Intercept exception handling functions.\n+#if ASAN_INTERCEPT___CXA_THROW\n+  INTERCEPT_FUNCTION(__cxa_throw);\n+#endif\n+\n+  // Intercept threading-related functions\n+#if ASAN_INTERCEPT_PTHREAD_CREATE\n+  ASAN_INTERCEPT_FUNC(pthread_create);\n+#endif\n+\n+  // Some Windows-specific interceptors.\n+#if defined(_WIN32)\n+  InitializeWindowsInterceptors();\n+#endif\n+\n+  // Some Mac-specific interceptors.\n+#if defined(__APPLE__)\n+  InitializeMacInterceptors();\n+#endif\n+\n+  if (flags()->verbosity > 0) {\n+    Report(\"AddressSanitizer: libc interceptors initialized\\n\");\n+  }\n+}\n+\n+}  // namespace __asan"}, {"sha": "a6ab0309bffe85ab1e56a034781cf30a7707482d", "filename": "libsanitizer/asan/asan_interceptors.h", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interceptors.h?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,39 @@\n+//===-- asan_interceptors.h -------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// ASan-private header for asan_interceptors.cc\n+//===----------------------------------------------------------------------===//\n+#ifndef ASAN_INTERCEPTORS_H\n+#define ASAN_INTERCEPTORS_H\n+\n+#include \"asan_internal.h\"\n+#include \"interception/interception.h\"\n+\n+DECLARE_REAL(int, memcmp, const void *a1, const void *a2, uptr size)\n+DECLARE_REAL(void*, memcpy, void *to, const void *from, uptr size)\n+DECLARE_REAL(void*, memset, void *block, int c, uptr size)\n+DECLARE_REAL(char*, strchr, const char *str, int c)\n+DECLARE_REAL(uptr, strlen, const char *s)\n+DECLARE_REAL(char*, strncpy, char *to, const char *from, uptr size)\n+DECLARE_REAL(uptr, strnlen, const char *s, uptr maxlen)\n+DECLARE_REAL(char*, strstr, const char *s1, const char *s2)\n+struct sigaction;\n+DECLARE_REAL(int, sigaction, int signum, const struct sigaction *act,\n+                             struct sigaction *oldact)\n+\n+namespace __asan {\n+\n+void InitializeAsanInterceptors();\n+#if defined(__APPLE__)\n+void InitializeMacInterceptors();\n+#endif  // __APPLE__\n+\n+}  // namespace __asan\n+\n+#endif  // ASAN_INTERCEPTORS_H"}, {"sha": "21368eef7c98ed881bb85ff56a2d246aae9ad633", "filename": "libsanitizer/asan/asan_internal.h", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_internal.h?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,169 @@\n+//===-- asan_internal.h -----------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// ASan-private header which defines various general utilities.\n+//===----------------------------------------------------------------------===//\n+#ifndef ASAN_INTERNAL_H\n+#define ASAN_INTERNAL_H\n+\n+#include \"asan_flags.h\"\n+#include \"sanitizer_common/sanitizer_common.h\"\n+#include \"sanitizer_common/sanitizer_internal_defs.h\"\n+#include \"sanitizer_common/sanitizer_stacktrace.h\"\n+#include \"sanitizer_common/sanitizer_libc.h\"\n+\n+#if !defined(__linux__) && !defined(__APPLE__) && !defined(_WIN32)\n+# error \"This operating system is not supported by AddressSanitizer\"\n+#endif\n+\n+#define ASAN_DEFAULT_FAILURE_EXITCODE 1\n+\n+#if defined(__linux__)\n+# define ASAN_LINUX   1\n+#else\n+# define ASAN_LINUX   0\n+#endif\n+\n+#if defined(__APPLE__)\n+# define ASAN_MAC     1\n+#else\n+# define ASAN_MAC     0\n+#endif\n+\n+#if defined(_WIN32)\n+# define ASAN_WINDOWS 1\n+#else\n+# define ASAN_WINDOWS 0\n+#endif\n+\n+#if defined(__ANDROID__) || defined(ANDROID)\n+# define ASAN_ANDROID 1\n+#else\n+# define ASAN_ANDROID 0\n+#endif\n+\n+\n+#define ASAN_POSIX (ASAN_LINUX || ASAN_MAC)\n+\n+#if __has_feature(address_sanitizer)\n+# error \"The AddressSanitizer run-time should not be\"\n+        \" instrumented by AddressSanitizer\"\n+#endif\n+\n+// Build-time configuration options.\n+\n+// If set, asan will install its own SEGV signal handler.\n+#ifndef ASAN_NEEDS_SEGV\n+# if ASAN_ANDROID == 1\n+#  define ASAN_NEEDS_SEGV 0\n+# else\n+#  define ASAN_NEEDS_SEGV 1\n+# endif\n+#endif\n+\n+// If set, asan will intercept C++ exception api call(s).\n+#ifndef ASAN_HAS_EXCEPTIONS\n+# define ASAN_HAS_EXCEPTIONS 1\n+#endif\n+\n+// If set, asan uses the values of SHADOW_SCALE and SHADOW_OFFSET\n+// provided by the instrumented objects. Otherwise constants are used.\n+#ifndef ASAN_FLEXIBLE_MAPPING_AND_OFFSET\n+# define ASAN_FLEXIBLE_MAPPING_AND_OFFSET 0\n+#endif\n+\n+// If set, values like allocator chunk size, as well as defaults for some flags\n+// will be changed towards less memory overhead.\n+#ifndef ASAN_LOW_MEMORY\n+# ifdef ASAN_ANDROID\n+#  define ASAN_LOW_MEMORY 1\n+# else\n+#  define ASAN_LOW_MEMORY 0\n+# endif\n+#endif\n+\n+// All internal functions in asan reside inside the __asan namespace\n+// to avoid namespace collisions with the user programs.\n+// Seperate namespace also makes it simpler to distinguish the asan run-time\n+// functions from the instrumented user code in a profile.\n+namespace __asan {\n+\n+class AsanThread;\n+using __sanitizer::StackTrace;\n+\n+// asan_rtl.cc\n+void NORETURN ShowStatsAndAbort();\n+\n+void ReplaceOperatorsNewAndDelete();\n+// asan_malloc_linux.cc / asan_malloc_mac.cc\n+void ReplaceSystemMalloc();\n+\n+// asan_linux.cc / asan_mac.cc / asan_win.cc\n+void *AsanDoesNotSupportStaticLinkage();\n+\n+void GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp);\n+\n+void MaybeReexec();\n+bool AsanInterceptsSignal(int signum);\n+void SetAlternateSignalStack();\n+void UnsetAlternateSignalStack();\n+void InstallSignalHandlers();\n+void AsanPlatformThreadInit();\n+\n+// Wrapper for TLS/TSD.\n+void AsanTSDInit(void (*destructor)(void *tsd));\n+void *AsanTSDGet();\n+void AsanTSDSet(void *tsd);\n+\n+void AppendToErrorMessageBuffer(const char *buffer);\n+\n+// asan_poisoning.cc\n+// Poisons the shadow memory for \"size\" bytes starting from \"addr\".\n+void PoisonShadow(uptr addr, uptr size, u8 value);\n+// Poisons the shadow memory for \"redzone_size\" bytes starting from\n+// \"addr + size\".\n+void PoisonShadowPartialRightRedzone(uptr addr,\n+                                     uptr size,\n+                                     uptr redzone_size,\n+                                     u8 value);\n+\n+// Platfrom-specific options.\n+#ifdef __APPLE__\n+bool PlatformHasDifferentMemcpyAndMemmove();\n+# define PLATFORM_HAS_DIFFERENT_MEMCPY_AND_MEMMOVE \\\n+    (PlatformHasDifferentMemcpyAndMemmove())\n+#else\n+# define PLATFORM_HAS_DIFFERENT_MEMCPY_AND_MEMMOVE true\n+#endif  // __APPLE__\n+\n+extern int asan_inited;\n+// Used to avoid infinite recursion in __asan_init().\n+extern bool asan_init_is_running;\n+extern void (*death_callback)(void);\n+\n+// These magic values are written to shadow for better error reporting.\n+const int kAsanHeapLeftRedzoneMagic = 0xfa;\n+const int kAsanHeapRightRedzoneMagic = 0xfb;\n+const int kAsanHeapFreeMagic = 0xfd;\n+const int kAsanStackLeftRedzoneMagic = 0xf1;\n+const int kAsanStackMidRedzoneMagic = 0xf2;\n+const int kAsanStackRightRedzoneMagic = 0xf3;\n+const int kAsanStackPartialRedzoneMagic = 0xf4;\n+const int kAsanStackAfterReturnMagic = 0xf5;\n+const int kAsanInitializationOrderMagic = 0xf6;\n+const int kAsanUserPoisonedMemoryMagic = 0xf7;\n+const int kAsanGlobalRedzoneMagic = 0xf9;\n+const int kAsanInternalHeapMagic = 0xfe;\n+\n+static const uptr kCurrentStackFrameMagic = 0x41B58AB3;\n+static const uptr kRetiredStackFrameMagic = 0x45E0360E;\n+\n+}  // namespace __asan\n+\n+#endif  // ASAN_INTERNAL_H"}, {"sha": "2922740e7f2b7e5cf081333fbc6b769c9fdb47bd", "filename": "libsanitizer/asan/asan_linux.cc", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_linux.cc?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,150 @@\n+//===-- asan_linux.cc -----------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// Linux-specific details.\n+//===----------------------------------------------------------------------===//\n+#ifdef __linux__\n+\n+#include \"asan_interceptors.h\"\n+#include \"asan_internal.h\"\n+#include \"asan_lock.h\"\n+#include \"asan_thread.h\"\n+#include \"asan_thread_registry.h\"\n+#include \"sanitizer_common/sanitizer_libc.h\"\n+#include \"sanitizer_common/sanitizer_procmaps.h\"\n+\n+#include <sys/time.h>\n+#include <sys/resource.h>\n+#include <sys/mman.h>\n+#include <sys/syscall.h>\n+#include <sys/types.h>\n+#include <fcntl.h>\n+#include <pthread.h>\n+#include <stdio.h>\n+#include <unistd.h>\n+#include <unwind.h>\n+\n+#if !ASAN_ANDROID\n+// FIXME: where to get ucontext on Android?\n+#include <sys/ucontext.h>\n+#endif\n+\n+extern \"C\" void* _DYNAMIC;\n+\n+namespace __asan {\n+\n+void MaybeReexec() {\n+  // No need to re-exec on Linux.\n+}\n+\n+void *AsanDoesNotSupportStaticLinkage() {\n+  // This will fail to link with -static.\n+  return &_DYNAMIC;  // defined in link.h\n+}\n+\n+void GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp) {\n+#if ASAN_ANDROID\n+  *pc = *sp = *bp = 0;\n+#elif defined(__arm__)\n+  ucontext_t *ucontext = (ucontext_t*)context;\n+  *pc = ucontext->uc_mcontext.arm_pc;\n+  *bp = ucontext->uc_mcontext.arm_fp;\n+  *sp = ucontext->uc_mcontext.arm_sp;\n+# elif defined(__x86_64__)\n+  ucontext_t *ucontext = (ucontext_t*)context;\n+  *pc = ucontext->uc_mcontext.gregs[REG_RIP];\n+  *bp = ucontext->uc_mcontext.gregs[REG_RBP];\n+  *sp = ucontext->uc_mcontext.gregs[REG_RSP];\n+# elif defined(__i386__)\n+  ucontext_t *ucontext = (ucontext_t*)context;\n+  *pc = ucontext->uc_mcontext.gregs[REG_EIP];\n+  *bp = ucontext->uc_mcontext.gregs[REG_EBP];\n+  *sp = ucontext->uc_mcontext.gregs[REG_ESP];\n+#else\n+# error \"Unsupported arch\"\n+#endif\n+}\n+\n+bool AsanInterceptsSignal(int signum) {\n+  return signum == SIGSEGV && flags()->handle_segv;\n+}\n+\n+void AsanPlatformThreadInit() {\n+  // Nothing here for now.\n+}\n+\n+AsanLock::AsanLock(LinkerInitialized) {\n+  // We assume that pthread_mutex_t initialized to all zeroes is a valid\n+  // unlocked mutex. We can not use PTHREAD_MUTEX_INITIALIZER as it triggers\n+  // a gcc warning:\n+  // extended initializer lists only available with -std=c++0x or -std=gnu++0x\n+}\n+\n+void AsanLock::Lock() {\n+  CHECK(sizeof(pthread_mutex_t) <= sizeof(opaque_storage_));\n+  pthread_mutex_lock((pthread_mutex_t*)&opaque_storage_);\n+  CHECK(!owner_);\n+  owner_ = (uptr)pthread_self();\n+}\n+\n+void AsanLock::Unlock() {\n+  CHECK(owner_ == (uptr)pthread_self());\n+  owner_ = 0;\n+  pthread_mutex_unlock((pthread_mutex_t*)&opaque_storage_);\n+}\n+\n+#ifdef __arm__\n+#define UNWIND_STOP _URC_END_OF_STACK\n+#define UNWIND_CONTINUE _URC_NO_REASON\n+#else\n+#define UNWIND_STOP _URC_NORMAL_STOP\n+#define UNWIND_CONTINUE _URC_NO_REASON\n+#endif\n+\n+uptr Unwind_GetIP(struct _Unwind_Context *ctx) {\n+#ifdef __arm__\n+  uptr val;\n+  _Unwind_VRS_Result res = _Unwind_VRS_Get(ctx, _UVRSC_CORE,\n+      15 /* r15 = PC */, _UVRSD_UINT32, &val);\n+  CHECK(res == _UVRSR_OK && \"_Unwind_VRS_Get failed\");\n+  // Clear the Thumb bit.\n+  return val & ~(uptr)1;\n+#else\n+  return _Unwind_GetIP(ctx);\n+#endif\n+}\n+\n+_Unwind_Reason_Code Unwind_Trace(struct _Unwind_Context *ctx,\n+    void *param) {\n+  StackTrace *b = (StackTrace*)param;\n+  CHECK(b->size < b->max_size);\n+  uptr pc = Unwind_GetIP(ctx);\n+  b->trace[b->size++] = pc;\n+  if (b->size == b->max_size) return UNWIND_STOP;\n+  return UNWIND_CONTINUE;\n+}\n+\n+void GetStackTrace(StackTrace *stack, uptr max_s, uptr pc, uptr bp) {\n+  stack->size = 0;\n+  stack->trace[0] = pc;\n+  if ((max_s) > 1) {\n+    stack->max_size = max_s;\n+#ifdef __arm__\n+    _Unwind_Backtrace(Unwind_Trace, stack);\n+#else\n+    if (!asan_inited) return;\n+    if (AsanThread *t = asanThreadRegistry().GetCurrent())\n+      stack->FastUnwindStack(pc, bp, t->stack_top(), t->stack_bottom());\n+#endif\n+  }\n+}\n+\n+}  // namespace __asan\n+\n+#endif  // __linux__"}, {"sha": "2392e3c0e7b5a18275c5ff81d713d35ce9c71501", "filename": "libsanitizer/asan/asan_lock.h", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_lock.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_lock.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_lock.h?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,40 @@\n+//===-- asan_lock.h ---------------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// A wrapper for a simple lock.\n+//===----------------------------------------------------------------------===//\n+#ifndef ASAN_LOCK_H\n+#define ASAN_LOCK_H\n+\n+#include \"sanitizer_common/sanitizer_mutex.h\"\n+#include \"asan_internal.h\"\n+\n+// The locks in ASan are global objects and they are never destroyed to avoid\n+// at-exit races (that is, a lock is being used by other threads while the main\n+// thread is doing atexit destructors).\n+// We define the class using opaque storage to avoid including system headers.\n+\n+namespace __asan {\n+\n+class AsanLock {\n+ public:\n+  explicit AsanLock(LinkerInitialized);\n+  void Lock();\n+  void Unlock();\n+  bool IsLocked() { return owner_ != 0; }\n+ private:\n+  uptr opaque_storage_[10];\n+  uptr owner_;  // for debugging and for malloc_introspection_t interface\n+};\n+\n+typedef GenericScopedLock<AsanLock> ScopedLock;\n+\n+}  // namespace __asan\n+\n+#endif  // ASAN_LOCK_H"}, {"sha": "81e25e8ef599fe01fc2f71b504323580e70fb7de", "filename": "libsanitizer/asan/asan_mac.cc", "status": "added", "additions": 526, "deletions": 0, "changes": 526, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mac.cc?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,526 @@\n+//===-- asan_mac.cc -------------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// Mac-specific details.\n+//===----------------------------------------------------------------------===//\n+\n+#ifdef __APPLE__\n+\n+#include \"asan_interceptors.h\"\n+#include \"asan_internal.h\"\n+#include \"asan_mac.h\"\n+#include \"asan_mapping.h\"\n+#include \"asan_stack.h\"\n+#include \"asan_thread.h\"\n+#include \"asan_thread_registry.h\"\n+#include \"sanitizer_common/sanitizer_libc.h\"\n+\n+#include <crt_externs.h>  // for _NSGetArgv\n+#include <dlfcn.h>  // for dladdr()\n+#include <mach-o/dyld.h>\n+#include <mach-o/loader.h>\n+#include <sys/mman.h>\n+#include <sys/resource.h>\n+#include <sys/sysctl.h>\n+#include <sys/ucontext.h>\n+#include <fcntl.h>\n+#include <pthread.h>\n+#include <stdlib.h>  // for free()\n+#include <unistd.h>\n+#include <libkern/OSAtomic.h>\n+#include <CoreFoundation/CFString.h>\n+\n+namespace __asan {\n+\n+void GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp) {\n+  ucontext_t *ucontext = (ucontext_t*)context;\n+# if __WORDSIZE == 64\n+  *pc = ucontext->uc_mcontext->__ss.__rip;\n+  *bp = ucontext->uc_mcontext->__ss.__rbp;\n+  *sp = ucontext->uc_mcontext->__ss.__rsp;\n+# else\n+  *pc = ucontext->uc_mcontext->__ss.__eip;\n+  *bp = ucontext->uc_mcontext->__ss.__ebp;\n+  *sp = ucontext->uc_mcontext->__ss.__esp;\n+# endif  // __WORDSIZE\n+}\n+\n+int GetMacosVersion() {\n+  int mib[2] = { CTL_KERN, KERN_OSRELEASE };\n+  char version[100];\n+  uptr len = 0, maxlen = sizeof(version) / sizeof(version[0]);\n+  for (uptr i = 0; i < maxlen; i++) version[i] = '\\0';\n+  // Get the version length.\n+  CHECK(sysctl(mib, 2, 0, &len, 0, 0) != -1);\n+  CHECK(len < maxlen);\n+  CHECK(sysctl(mib, 2, version, &len, 0, 0) != -1);\n+  switch (version[0]) {\n+    case '9': return MACOS_VERSION_LEOPARD;\n+    case '1': {\n+      switch (version[1]) {\n+        case '0': return MACOS_VERSION_SNOW_LEOPARD;\n+        case '1': return MACOS_VERSION_LION;\n+        default: return MACOS_VERSION_UNKNOWN;\n+      }\n+    }\n+    default: return MACOS_VERSION_UNKNOWN;\n+  }\n+}\n+\n+bool PlatformHasDifferentMemcpyAndMemmove() {\n+  // On OS X 10.7 memcpy() and memmove() are both resolved\n+  // into memmove$VARIANT$sse42.\n+  // See also http://code.google.com/p/address-sanitizer/issues/detail?id=34.\n+  // TODO(glider): need to check dynamically that memcpy() and memmove() are\n+  // actually the same function.\n+  return GetMacosVersion() == MACOS_VERSION_SNOW_LEOPARD;\n+}\n+\n+extern \"C\"\n+void __asan_init();\n+\n+static const char kDyldInsertLibraries[] = \"DYLD_INSERT_LIBRARIES\";\n+\n+void MaybeReexec() {\n+  if (!flags()->allow_reexec) return;\n+#if MAC_INTERPOSE_FUNCTIONS\n+  // If the program is linked with the dynamic ASan runtime library, make sure\n+  // the library is preloaded so that the wrappers work. If it is not, set\n+  // DYLD_INSERT_LIBRARIES and re-exec ourselves.\n+  Dl_info info;\n+  CHECK(dladdr((void*)((uptr)__asan_init), &info));\n+  const char *dyld_insert_libraries = GetEnv(kDyldInsertLibraries);\n+  if (!dyld_insert_libraries ||\n+      !REAL(strstr)(dyld_insert_libraries, info.dli_fname)) {\n+    // DYLD_INSERT_LIBRARIES is not set or does not contain the runtime\n+    // library.\n+    char program_name[1024];\n+    uint32_t buf_size = sizeof(program_name);\n+    _NSGetExecutablePath(program_name, &buf_size);\n+    // Ok to use setenv() since the wrappers don't depend on the value of\n+    // asan_inited.\n+    setenv(kDyldInsertLibraries, info.dli_fname, /*overwrite*/0);\n+    if (flags()->verbosity >= 1) {\n+      Report(\"exec()-ing the program with\\n\");\n+      Report(\"%s=%s\\n\", kDyldInsertLibraries, info.dli_fname);\n+      Report(\"to enable ASan wrappers.\\n\");\n+      Report(\"Set ASAN_OPTIONS=allow_reexec=0 to disable this.\\n\");\n+    }\n+    execv(program_name, *_NSGetArgv());\n+  }\n+#endif  // MAC_INTERPOSE_FUNCTIONS\n+  // If we're not using the dynamic runtime, do nothing.\n+}\n+\n+// No-op. Mac does not support static linkage anyway.\n+void *AsanDoesNotSupportStaticLinkage() {\n+  return 0;\n+}\n+\n+bool AsanInterceptsSignal(int signum) {\n+  return (signum == SIGSEGV || signum == SIGBUS) && flags()->handle_segv;\n+}\n+\n+void AsanPlatformThreadInit() {\n+  ReplaceCFAllocator();\n+}\n+\n+AsanLock::AsanLock(LinkerInitialized) {\n+  // We assume that OS_SPINLOCK_INIT is zero\n+}\n+\n+void AsanLock::Lock() {\n+  CHECK(sizeof(OSSpinLock) <= sizeof(opaque_storage_));\n+  CHECK(OS_SPINLOCK_INIT == 0);\n+  CHECK(owner_ != (uptr)pthread_self());\n+  OSSpinLockLock((OSSpinLock*)&opaque_storage_);\n+  CHECK(!owner_);\n+  owner_ = (uptr)pthread_self();\n+}\n+\n+void AsanLock::Unlock() {\n+  CHECK(owner_ == (uptr)pthread_self());\n+  owner_ = 0;\n+  OSSpinLockUnlock((OSSpinLock*)&opaque_storage_);\n+}\n+\n+void GetStackTrace(StackTrace *stack, uptr max_s, uptr pc, uptr bp) {\n+  stack->size = 0;\n+  stack->trace[0] = pc;\n+  if ((max_s) > 1) {\n+    stack->max_size = max_s;\n+    if (!asan_inited) return;\n+    if (AsanThread *t = asanThreadRegistry().GetCurrent())\n+      stack->FastUnwindStack(pc, bp, t->stack_top(), t->stack_bottom());\n+  }\n+}\n+\n+// The range of pages to be used for escape islands.\n+// TODO(glider): instead of mapping a fixed range we must find a range of\n+// unmapped pages in vmmap and take them.\n+// These constants were chosen empirically and may not work if the shadow\n+// memory layout changes. Unfortunately they do necessarily depend on\n+// kHighMemBeg or kHighMemEnd.\n+static void *island_allocator_pos = 0;\n+\n+#if __WORDSIZE == 32\n+# define kIslandEnd (0xffdf0000 - kPageSize)\n+# define kIslandBeg (kIslandEnd - 256 * kPageSize)\n+#else\n+# define kIslandEnd (0x7fffffdf0000 - kPageSize)\n+# define kIslandBeg (kIslandEnd - 256 * kPageSize)\n+#endif\n+\n+extern \"C\"\n+mach_error_t __interception_allocate_island(void **ptr,\n+                                            uptr unused_size,\n+                                            void *unused_hint) {\n+  if (!island_allocator_pos) {\n+    island_allocator_pos =\n+        internal_mmap((void*)kIslandBeg, kIslandEnd - kIslandBeg,\n+                      PROT_READ | PROT_WRITE | PROT_EXEC,\n+                      MAP_PRIVATE | MAP_ANON | MAP_FIXED,\n+                      -1, 0);\n+    if (island_allocator_pos != (void*)kIslandBeg) {\n+      return KERN_NO_SPACE;\n+    }\n+    if (flags()->verbosity) {\n+      Report(\"Mapped pages %p--%p for branch islands.\\n\",\n+             (void*)kIslandBeg, (void*)kIslandEnd);\n+    }\n+    // Should not be very performance-critical.\n+    internal_memset(island_allocator_pos, 0xCC, kIslandEnd - kIslandBeg);\n+  };\n+  *ptr = island_allocator_pos;\n+  island_allocator_pos = (char*)island_allocator_pos + kPageSize;\n+  if (flags()->verbosity) {\n+    Report(\"Branch island allocated at %p\\n\", *ptr);\n+  }\n+  return err_none;\n+}\n+\n+extern \"C\"\n+mach_error_t __interception_deallocate_island(void *ptr) {\n+  // Do nothing.\n+  // TODO(glider): allow to free and reuse the island memory.\n+  return err_none;\n+}\n+\n+// Support for the following functions from libdispatch on Mac OS:\n+//   dispatch_async_f()\n+//   dispatch_async()\n+//   dispatch_sync_f()\n+//   dispatch_sync()\n+//   dispatch_after_f()\n+//   dispatch_after()\n+//   dispatch_group_async_f()\n+//   dispatch_group_async()\n+// TODO(glider): libdispatch API contains other functions that we don't support\n+// yet.\n+//\n+// dispatch_sync() and dispatch_sync_f() are synchronous, although chances are\n+// they can cause jobs to run on a thread different from the current one.\n+// TODO(glider): if so, we need a test for this (otherwise we should remove\n+// them).\n+//\n+// The following functions use dispatch_barrier_async_f() (which isn't a library\n+// function but is exported) and are thus supported:\n+//   dispatch_source_set_cancel_handler_f()\n+//   dispatch_source_set_cancel_handler()\n+//   dispatch_source_set_event_handler_f()\n+//   dispatch_source_set_event_handler()\n+//\n+// The reference manual for Grand Central Dispatch is available at\n+//   http://developer.apple.com/library/mac/#documentation/Performance/Reference/GCD_libdispatch_Ref/Reference/reference.html\n+// The implementation details are at\n+//   http://libdispatch.macosforge.org/trac/browser/trunk/src/queue.c\n+\n+typedef void* pthread_workqueue_t;\n+typedef void* pthread_workitem_handle_t;\n+\n+typedef void* dispatch_group_t;\n+typedef void* dispatch_queue_t;\n+typedef void* dispatch_source_t;\n+typedef u64 dispatch_time_t;\n+typedef void (*dispatch_function_t)(void *block);\n+typedef void* (*worker_t)(void *block);\n+\n+// A wrapper for the ObjC blocks used to support libdispatch.\n+typedef struct {\n+  void *block;\n+  dispatch_function_t func;\n+  u32 parent_tid;\n+} asan_block_context_t;\n+\n+// We use extern declarations of libdispatch functions here instead\n+// of including <dispatch/dispatch.h>. This header is not present on\n+// Mac OS X Leopard and eariler, and although we don't expect ASan to\n+// work on legacy systems, it's bad to break the build of\n+// LLVM compiler-rt there.\n+extern \"C\" {\n+void dispatch_async_f(dispatch_queue_t dq, void *ctxt,\n+                      dispatch_function_t func);\n+void dispatch_sync_f(dispatch_queue_t dq, void *ctxt,\n+                     dispatch_function_t func);\n+void dispatch_after_f(dispatch_time_t when, dispatch_queue_t dq, void *ctxt,\n+                      dispatch_function_t func);\n+void dispatch_barrier_async_f(dispatch_queue_t dq, void *ctxt,\n+                              dispatch_function_t func);\n+void dispatch_group_async_f(dispatch_group_t group, dispatch_queue_t dq,\n+                            void *ctxt, dispatch_function_t func);\n+int pthread_workqueue_additem_np(pthread_workqueue_t workq,\n+    void *(*workitem_func)(void *), void * workitem_arg,\n+    pthread_workitem_handle_t * itemhandlep, unsigned int *gencountp);\n+}  // extern \"C\"\n+\n+static ALWAYS_INLINE\n+void asan_register_worker_thread(int parent_tid, StackTrace *stack) {\n+  AsanThread *t = asanThreadRegistry().GetCurrent();\n+  if (!t) {\n+    t = AsanThread::Create(parent_tid, 0, 0, stack);\n+    asanThreadRegistry().RegisterThread(t);\n+    t->Init();\n+    asanThreadRegistry().SetCurrent(t);\n+  }\n+}\n+\n+// For use by only those functions that allocated the context via\n+// alloc_asan_context().\n+extern \"C\"\n+void asan_dispatch_call_block_and_release(void *block) {\n+  GET_STACK_TRACE_HERE(kStackTraceMax);\n+  asan_block_context_t *context = (asan_block_context_t*)block;\n+  if (flags()->verbosity >= 2) {\n+    Report(\"asan_dispatch_call_block_and_release(): \"\n+           \"context: %p, pthread_self: %p\\n\",\n+           block, pthread_self());\n+  }\n+  asan_register_worker_thread(context->parent_tid, &stack);\n+  // Call the original dispatcher for the block.\n+  context->func(context->block);\n+  asan_free(context, &stack);\n+}\n+\n+}  // namespace __asan\n+\n+using namespace __asan;  // NOLINT\n+\n+// Wrap |ctxt| and |func| into an asan_block_context_t.\n+// The caller retains control of the allocated context.\n+extern \"C\"\n+asan_block_context_t *alloc_asan_context(void *ctxt, dispatch_function_t func,\n+                                         StackTrace *stack) {\n+  asan_block_context_t *asan_ctxt =\n+      (asan_block_context_t*) asan_malloc(sizeof(asan_block_context_t), stack);\n+  asan_ctxt->block = ctxt;\n+  asan_ctxt->func = func;\n+  asan_ctxt->parent_tid = asanThreadRegistry().GetCurrentTidOrInvalid();\n+  return asan_ctxt;\n+}\n+\n+// Define interceptor for dispatch_*_f function with the three most common\n+// parameters: dispatch_queue_t, context, dispatch_function_t.\n+#define INTERCEPT_DISPATCH_X_F_3(dispatch_x_f)                                \\\n+  INTERCEPTOR(void, dispatch_x_f, dispatch_queue_t dq, void *ctxt,            \\\n+                                  dispatch_function_t func) {                 \\\n+    GET_STACK_TRACE_HERE(kStackTraceMax);                                     \\\n+    asan_block_context_t *asan_ctxt = alloc_asan_context(ctxt, func, &stack); \\\n+    if (flags()->verbosity >= 2) {                                            \\\n+      Report(#dispatch_x_f \"(): context: %p, pthread_self: %p\\n\",             \\\n+             asan_ctxt, pthread_self());                                      \\\n+       PRINT_CURRENT_STACK();                                                 \\\n+     }                                                                        \\\n+     return REAL(dispatch_x_f)(dq, (void*)asan_ctxt,                          \\\n+                               asan_dispatch_call_block_and_release);         \\\n+  }\n+\n+INTERCEPT_DISPATCH_X_F_3(dispatch_async_f)\n+INTERCEPT_DISPATCH_X_F_3(dispatch_sync_f)\n+INTERCEPT_DISPATCH_X_F_3(dispatch_barrier_async_f)\n+\n+INTERCEPTOR(void, dispatch_after_f, dispatch_time_t when,\n+                                    dispatch_queue_t dq, void *ctxt,\n+                                    dispatch_function_t func) {\n+  GET_STACK_TRACE_HERE(kStackTraceMax);\n+  asan_block_context_t *asan_ctxt = alloc_asan_context(ctxt, func, &stack);\n+  if (flags()->verbosity >= 2) {\n+    Report(\"dispatch_after_f: %p\\n\", asan_ctxt);\n+    PRINT_CURRENT_STACK();\n+  }\n+  return REAL(dispatch_after_f)(when, dq, (void*)asan_ctxt,\n+                                asan_dispatch_call_block_and_release);\n+}\n+\n+INTERCEPTOR(void, dispatch_group_async_f, dispatch_group_t group,\n+                                          dispatch_queue_t dq, void *ctxt,\n+                                          dispatch_function_t func) {\n+  GET_STACK_TRACE_HERE(kStackTraceMax);\n+  asan_block_context_t *asan_ctxt = alloc_asan_context(ctxt, func, &stack);\n+  if (flags()->verbosity >= 2) {\n+    Report(\"dispatch_group_async_f(): context: %p, pthread_self: %p\\n\",\n+           asan_ctxt, pthread_self());\n+    PRINT_CURRENT_STACK();\n+  }\n+  REAL(dispatch_group_async_f)(group, dq, (void*)asan_ctxt,\n+                               asan_dispatch_call_block_and_release);\n+}\n+\n+#if MAC_INTERPOSE_FUNCTIONS\n+// dispatch_async, dispatch_group_async and others tailcall the corresponding\n+// dispatch_*_f functions. When wrapping functions with mach_override, those\n+// dispatch_*_f are intercepted automatically. But with dylib interposition\n+// this does not work, because the calls within the same library are not\n+// interposed.\n+// Therefore we need to re-implement dispatch_async and friends.\n+\n+extern \"C\" {\n+// FIXME: consolidate these declarations with asan_intercepted_functions.h.\n+void dispatch_async(dispatch_queue_t dq, void(^work)(void));\n+void dispatch_group_async(dispatch_group_t dg, dispatch_queue_t dq,\n+                          void(^work)(void));\n+void dispatch_after(dispatch_time_t when, dispatch_queue_t queue,\n+                    void(^work)(void));\n+void dispatch_source_set_cancel_handler(dispatch_source_t ds,\n+                                        void(^work)(void));\n+void dispatch_source_set_event_handler(dispatch_source_t ds, void(^work)(void));\n+}\n+\n+#define GET_ASAN_BLOCK(work) \\\n+  void (^asan_block)(void);  \\\n+  int parent_tid = asanThreadRegistry().GetCurrentTidOrInvalid(); \\\n+  asan_block = ^(void) { \\\n+    GET_STACK_TRACE_HERE(kStackTraceMax); \\\n+    asan_register_worker_thread(parent_tid, &stack); \\\n+    work(); \\\n+  }\n+\n+INTERCEPTOR(void, dispatch_async,\n+            dispatch_queue_t dq, void(^work)(void)) {\n+  GET_ASAN_BLOCK(work);\n+  REAL(dispatch_async)(dq, asan_block);\n+}\n+\n+INTERCEPTOR(void, dispatch_group_async,\n+            dispatch_group_t dg, dispatch_queue_t dq, void(^work)(void)) {\n+  GET_ASAN_BLOCK(work);\n+  REAL(dispatch_group_async)(dg, dq, asan_block);\n+}\n+\n+INTERCEPTOR(void, dispatch_after,\n+            dispatch_time_t when, dispatch_queue_t queue, void(^work)(void)) {\n+  GET_ASAN_BLOCK(work);\n+  REAL(dispatch_after)(when, queue, asan_block);\n+}\n+\n+INTERCEPTOR(void, dispatch_source_set_cancel_handler,\n+            dispatch_source_t ds, void(^work)(void)) {\n+  GET_ASAN_BLOCK(work);\n+  REAL(dispatch_source_set_cancel_handler)(ds, asan_block);\n+}\n+\n+INTERCEPTOR(void, dispatch_source_set_event_handler,\n+            dispatch_source_t ds, void(^work)(void)) {\n+  GET_ASAN_BLOCK(work);\n+  REAL(dispatch_source_set_event_handler)(ds, asan_block);\n+}\n+#endif\n+\n+// The following stuff has been extremely helpful while looking for the\n+// unhandled functions that spawned jobs on Chromium shutdown. If the verbosity\n+// level is 2 or greater, we wrap pthread_workqueue_additem_np() in order to\n+// find the points of worker thread creation (each of such threads may be used\n+// to run several tasks, that's why this is not enough to support the whole\n+// libdispatch API.\n+extern \"C\"\n+void *wrap_workitem_func(void *arg) {\n+  if (flags()->verbosity >= 2) {\n+    Report(\"wrap_workitem_func: %p, pthread_self: %p\\n\", arg, pthread_self());\n+  }\n+  asan_block_context_t *ctxt = (asan_block_context_t*)arg;\n+  worker_t fn = (worker_t)(ctxt->func);\n+  void *result =  fn(ctxt->block);\n+  GET_STACK_TRACE_HERE(kStackTraceMax);\n+  asan_free(arg, &stack);\n+  return result;\n+}\n+\n+INTERCEPTOR(int, pthread_workqueue_additem_np, pthread_workqueue_t workq,\n+    void *(*workitem_func)(void *), void * workitem_arg,\n+    pthread_workitem_handle_t * itemhandlep, unsigned int *gencountp) {\n+  GET_STACK_TRACE_HERE(kStackTraceMax);\n+  asan_block_context_t *asan_ctxt =\n+      (asan_block_context_t*) asan_malloc(sizeof(asan_block_context_t), &stack);\n+  asan_ctxt->block = workitem_arg;\n+  asan_ctxt->func = (dispatch_function_t)workitem_func;\n+  asan_ctxt->parent_tid = asanThreadRegistry().GetCurrentTidOrInvalid();\n+  if (flags()->verbosity >= 2) {\n+    Report(\"pthread_workqueue_additem_np: %p\\n\", asan_ctxt);\n+    PRINT_CURRENT_STACK();\n+  }\n+  return REAL(pthread_workqueue_additem_np)(workq, wrap_workitem_func,\n+                                            asan_ctxt, itemhandlep,\n+                                            gencountp);\n+}\n+\n+// See http://opensource.apple.com/source/CF/CF-635.15/CFString.c\n+int __CFStrIsConstant(CFStringRef str) {\n+  CFRuntimeBase *base = (CFRuntimeBase*)str;\n+#if __LP64__\n+  return base->_rc == 0;\n+#else\n+  return (base->_cfinfo[CF_RC_BITS]) == 0;\n+#endif\n+}\n+\n+INTERCEPTOR(CFStringRef, CFStringCreateCopy, CFAllocatorRef alloc,\n+                                             CFStringRef str) {\n+  if (__CFStrIsConstant(str)) {\n+    return str;\n+  } else {\n+    return REAL(CFStringCreateCopy)(alloc, str);\n+  }\n+}\n+\n+DECLARE_REAL_AND_INTERCEPTOR(void, free, void *ptr)\n+\n+DECLARE_REAL_AND_INTERCEPTOR(void, __CFInitialize, void)\n+\n+namespace __asan {\n+\n+void InitializeMacInterceptors() {\n+  CHECK(INTERCEPT_FUNCTION(dispatch_async_f));\n+  CHECK(INTERCEPT_FUNCTION(dispatch_sync_f));\n+  CHECK(INTERCEPT_FUNCTION(dispatch_after_f));\n+  CHECK(INTERCEPT_FUNCTION(dispatch_barrier_async_f));\n+  CHECK(INTERCEPT_FUNCTION(dispatch_group_async_f));\n+  // We don't need to intercept pthread_workqueue_additem_np() to support the\n+  // libdispatch API, but it helps us to debug the unsupported functions. Let's\n+  // intercept it only during verbose runs.\n+  if (flags()->verbosity >= 2) {\n+    CHECK(INTERCEPT_FUNCTION(pthread_workqueue_additem_np));\n+  }\n+  // Normally CFStringCreateCopy should not copy constant CF strings.\n+  // Replacing the default CFAllocator causes constant strings to be copied\n+  // rather than just returned, which leads to bugs in big applications like\n+  // Chromium and WebKit, see\n+  // http://code.google.com/p/address-sanitizer/issues/detail?id=10\n+  // Until this problem is fixed we need to check that the string is\n+  // non-constant before calling CFStringCreateCopy.\n+  CHECK(INTERCEPT_FUNCTION(CFStringCreateCopy));\n+  // Some of the library functions call free() directly, so we have to\n+  // intercept it.\n+  CHECK(INTERCEPT_FUNCTION(free));\n+  if (flags()->replace_cfallocator) {\n+    CHECK(INTERCEPT_FUNCTION(__CFInitialize));\n+  }\n+}\n+\n+}  // namespace __asan\n+\n+#endif  // __APPLE__"}, {"sha": "18aca0dd84e1dbf92afbc4865ca193aa1796703e", "filename": "libsanitizer/asan/asan_mac.h", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_mac.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_mac.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mac.h?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,54 @@\n+//===-- asan_mac.h ----------------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// Mac-specific ASan definitions.\n+//===----------------------------------------------------------------------===//\n+#ifndef ASAN_MAC_H\n+#define ASAN_MAC_H\n+\n+// CF_RC_BITS, the layout of CFRuntimeBase and __CFStrIsConstant are internal\n+// and subject to change in further CoreFoundation versions. Apple does not\n+// guarantee any binary compatibility from release to release.\n+\n+// See http://opensource.apple.com/source/CF/CF-635.15/CFInternal.h\n+#if defined(__BIG_ENDIAN__)\n+#define CF_RC_BITS 0\n+#endif\n+\n+#if defined(__LITTLE_ENDIAN__)\n+#define CF_RC_BITS 3\n+#endif\n+\n+// See http://opensource.apple.com/source/CF/CF-635.15/CFRuntime.h\n+typedef struct __CFRuntimeBase {\n+  uptr _cfisa;\n+  u8 _cfinfo[4];\n+#if __LP64__\n+  u32 _rc;\n+#endif\n+} CFRuntimeBase;\n+\n+enum {\n+  MACOS_VERSION_UNKNOWN = 0,\n+  MACOS_VERSION_LEOPARD,\n+  MACOS_VERSION_SNOW_LEOPARD,\n+  MACOS_VERSION_LION\n+};\n+\n+// Used by asan_malloc_mac.cc and asan_mac.cc\n+extern \"C\" void __CFInitialize();\n+\n+namespace __asan {\n+\n+int GetMacosVersion();\n+void ReplaceCFAllocator();\n+\n+}  // namespace __asan\n+\n+#endif  // ASAN_MAC_H"}, {"sha": "b00bbe5deca13843aa68d79635c24a61ca637209", "filename": "libsanitizer/asan/asan_malloc_linux.cc", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_malloc_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_malloc_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_malloc_linux.cc?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,142 @@\n+//===-- asan_malloc_linux.cc ----------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// Linux-specific malloc interception.\n+// We simply define functions like malloc, free, realloc, etc.\n+// They will replace the corresponding libc functions automagically.\n+//===----------------------------------------------------------------------===//\n+#ifdef __linux__\n+\n+#include \"asan_allocator.h\"\n+#include \"asan_interceptors.h\"\n+#include \"asan_internal.h\"\n+#include \"asan_stack.h\"\n+\n+#if ASAN_ANDROID\n+DECLARE_REAL_AND_INTERCEPTOR(void*, malloc, uptr size)\n+DECLARE_REAL_AND_INTERCEPTOR(void, free, void *ptr)\n+DECLARE_REAL_AND_INTERCEPTOR(void*, calloc, uptr nmemb, uptr size)\n+DECLARE_REAL_AND_INTERCEPTOR(void*, realloc, void *ptr, uptr size)\n+DECLARE_REAL_AND_INTERCEPTOR(void*, memalign, uptr boundary, uptr size)\n+\n+struct MallocDebug {\n+  void* (*malloc)(uptr bytes);\n+  void  (*free)(void* mem);\n+  void* (*calloc)(uptr n_elements, uptr elem_size);\n+  void* (*realloc)(void* oldMem, uptr bytes);\n+  void* (*memalign)(uptr alignment, uptr bytes);\n+};\n+\n+const MallocDebug asan_malloc_dispatch ALIGNED(32) = {\n+  WRAP(malloc), WRAP(free), WRAP(calloc), WRAP(realloc), WRAP(memalign)\n+};\n+\n+extern \"C\" const MallocDebug* __libc_malloc_dispatch;\n+\n+namespace __asan {\n+void ReplaceSystemMalloc() {\n+  __libc_malloc_dispatch = &asan_malloc_dispatch;\n+}\n+}  // namespace __asan\n+\n+#else  // ANDROID\n+\n+namespace __asan {\n+void ReplaceSystemMalloc() {\n+}\n+}  // namespace __asan\n+#endif  // ANDROID\n+\n+// ---------------------- Replacement functions ---------------- {{{1\n+using namespace __asan;  // NOLINT\n+\n+INTERCEPTOR(void, free, void *ptr) {\n+  GET_STACK_TRACE_HERE_FOR_FREE(ptr);\n+  asan_free(ptr, &stack);\n+}\n+\n+INTERCEPTOR(void, cfree, void *ptr) {\n+  GET_STACK_TRACE_HERE_FOR_FREE(ptr);\n+  asan_free(ptr, &stack);\n+}\n+\n+INTERCEPTOR(void*, malloc, uptr size) {\n+  GET_STACK_TRACE_HERE_FOR_MALLOC;\n+  return asan_malloc(size, &stack);\n+}\n+\n+INTERCEPTOR(void*, calloc, uptr nmemb, uptr size) {\n+  if (!asan_inited) {\n+    // Hack: dlsym calls calloc before REAL(calloc) is retrieved from dlsym.\n+    const uptr kCallocPoolSize = 1024;\n+    static uptr calloc_memory_for_dlsym[kCallocPoolSize];\n+    static uptr allocated;\n+    uptr size_in_words = ((nmemb * size) + kWordSize - 1) / kWordSize;\n+    void *mem = (void*)&calloc_memory_for_dlsym[allocated];\n+    allocated += size_in_words;\n+    CHECK(allocated < kCallocPoolSize);\n+    return mem;\n+  }\n+  GET_STACK_TRACE_HERE_FOR_MALLOC;\n+  return asan_calloc(nmemb, size, &stack);\n+}\n+\n+INTERCEPTOR(void*, realloc, void *ptr, uptr size) {\n+  GET_STACK_TRACE_HERE_FOR_MALLOC;\n+  return asan_realloc(ptr, size, &stack);\n+}\n+\n+INTERCEPTOR(void*, memalign, uptr boundary, uptr size) {\n+  GET_STACK_TRACE_HERE_FOR_MALLOC;\n+  return asan_memalign(boundary, size, &stack);\n+}\n+\n+INTERCEPTOR(void*, __libc_memalign, uptr align, uptr s)\n+  ALIAS(\"memalign\");\n+\n+INTERCEPTOR(uptr, malloc_usable_size, void *ptr) {\n+  GET_STACK_TRACE_HERE_FOR_MALLOC;\n+  return asan_malloc_usable_size(ptr, &stack);\n+}\n+\n+// We avoid including malloc.h for portability reasons.\n+// man mallinfo says the fields are \"long\", but the implementation uses int.\n+// It doesn't matter much -- we just need to make sure that the libc's mallinfo\n+// is not called.\n+struct fake_mallinfo {\n+  int x[10];\n+};\n+\n+INTERCEPTOR(struct fake_mallinfo, mallinfo, void) {\n+  struct fake_mallinfo res;\n+  REAL(memset)(&res, 0, sizeof(res));\n+  return res;\n+}\n+\n+INTERCEPTOR(int, mallopt, int cmd, int value) {\n+  return -1;\n+}\n+\n+INTERCEPTOR(int, posix_memalign, void **memptr, uptr alignment, uptr size) {\n+  GET_STACK_TRACE_HERE_FOR_MALLOC;\n+  // Printf(\"posix_memalign: %zx %zu\\n\", alignment, size);\n+  return asan_posix_memalign(memptr, alignment, size, &stack);\n+}\n+\n+INTERCEPTOR(void*, valloc, uptr size) {\n+  GET_STACK_TRACE_HERE_FOR_MALLOC;\n+  return asan_valloc(size, &stack);\n+}\n+\n+INTERCEPTOR(void*, pvalloc, uptr size) {\n+  GET_STACK_TRACE_HERE_FOR_MALLOC;\n+  return asan_pvalloc(size, &stack);\n+}\n+\n+#endif  // __linux__"}, {"sha": "2df34845f12455bda977754b1199f22ede9ff9b6", "filename": "libsanitizer/asan/asan_malloc_mac.cc", "status": "added", "additions": 427, "deletions": 0, "changes": 427, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_malloc_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_malloc_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_malloc_mac.cc?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,427 @@\n+//===-- asan_malloc_mac.cc ------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// Mac-specific malloc interception.\n+//===----------------------------------------------------------------------===//\n+\n+#ifdef __APPLE__\n+\n+#include <AvailabilityMacros.h>\n+#include <CoreFoundation/CFBase.h>\n+#include <dlfcn.h>\n+#include <malloc/malloc.h>\n+\n+#include \"asan_allocator.h\"\n+#include \"asan_interceptors.h\"\n+#include \"asan_internal.h\"\n+#include \"asan_mac.h\"\n+#include \"asan_report.h\"\n+#include \"asan_stack.h\"\n+#include \"asan_stats.h\"\n+#include \"asan_thread_registry.h\"\n+\n+// Similar code is used in Google Perftools,\n+// http://code.google.com/p/google-perftools.\n+\n+// ---------------------- Replacement functions ---------------- {{{1\n+using namespace __asan;  // NOLINT\n+\n+// TODO(glider): do we need both zones?\n+static malloc_zone_t *system_malloc_zone = 0;\n+static malloc_zone_t *system_purgeable_zone = 0;\n+static malloc_zone_t asan_zone;\n+CFAllocatorRef cf_asan = 0;\n+\n+// _CFRuntimeCreateInstance() checks whether the supplied allocator is\n+// kCFAllocatorSystemDefault and, if it is not, stores the allocator reference\n+// at the beginning of the allocated memory and returns the pointer to the\n+// allocated memory plus sizeof(CFAllocatorRef). See\n+// http://www.opensource.apple.com/source/CF/CF-635.21/CFRuntime.c\n+// Pointers returned by _CFRuntimeCreateInstance() can then be passed directly\n+// to free() or CFAllocatorDeallocate(), which leads to false invalid free\n+// reports.\n+// The corresponding rdar bug is http://openradar.appspot.com/radar?id=1796404.\n+void* ALWAYS_INLINE get_saved_cfallocator_ref(void *ptr) {\n+  if (flags()->replace_cfallocator) {\n+    // Make sure we're not hitting the previous page. This may be incorrect\n+    // if ASan's malloc returns an address ending with 0xFF8, which will be\n+    // then padded to a page boundary with a CFAllocatorRef.\n+    uptr arith_ptr = (uptr)ptr;\n+    if ((arith_ptr & 0xFFF) > sizeof(CFAllocatorRef)) {\n+      CFAllocatorRef *saved =\n+          (CFAllocatorRef*)(arith_ptr - sizeof(CFAllocatorRef));\n+      if ((*saved == cf_asan) && asan_mz_size(saved)) ptr = (void*)saved;\n+    }\n+  }\n+  return ptr;\n+}\n+\n+// The free() implementation provided by OS X calls malloc_zone_from_ptr()\n+// to find the owner of |ptr|. If the result is 0, an invalid free() is\n+// reported. Our implementation falls back to asan_free() in this case\n+// in order to print an ASan-style report.\n+//\n+// For the objects created by _CFRuntimeCreateInstance a CFAllocatorRef is\n+// placed at the beginning of the allocated chunk and the pointer returned by\n+// our allocator is off by sizeof(CFAllocatorRef). This pointer can be then\n+// passed directly to free(), which will lead to errors.\n+// To overcome this we're checking whether |ptr-sizeof(CFAllocatorRef)|\n+// contains a pointer to our CFAllocator (assuming no other allocator is used).\n+// See http://code.google.com/p/address-sanitizer/issues/detail?id=70 for more\n+// info.\n+INTERCEPTOR(void, free, void *ptr) {\n+  malloc_zone_t *zone = malloc_zone_from_ptr(ptr);\n+  if (zone) {\n+#if defined(MAC_OS_X_VERSION_10_6) && \\\n+    MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_6\n+    if ((zone->version >= 6) && (zone->free_definite_size)) {\n+      zone->free_definite_size(zone, ptr, malloc_size(ptr));\n+    } else {\n+      malloc_zone_free(zone, ptr);\n+    }\n+#else\n+    malloc_zone_free(zone, ptr);\n+#endif\n+  } else {\n+    if (!asan_mz_size(ptr)) ptr = get_saved_cfallocator_ref(ptr);\n+    GET_STACK_TRACE_HERE_FOR_FREE(ptr);\n+    asan_free(ptr, &stack);\n+  }\n+}\n+\n+namespace __asan {\n+  void ReplaceCFAllocator();\n+}\n+\n+// We can't always replace the default CFAllocator with cf_asan right in\n+// ReplaceSystemMalloc(), because it is sometimes called before\n+// __CFInitialize(), when the default allocator is invalid and replacing it may\n+// crash the program. Instead we wait for the allocator to initialize and jump\n+// in just after __CFInitialize(). Nobody is going to allocate memory using\n+// CFAllocators before that, so we won't miss anything.\n+//\n+// See http://code.google.com/p/address-sanitizer/issues/detail?id=87\n+// and http://opensource.apple.com/source/CF/CF-550.43/CFRuntime.c\n+INTERCEPTOR(void, __CFInitialize, void) {\n+  // If the runtime is built as dynamic library, __CFInitialize wrapper may be\n+  // called before __asan_init.\n+#if !MAC_INTERPOSE_FUNCTIONS\n+  CHECK(flags()->replace_cfallocator);\n+  CHECK(asan_inited);\n+#endif\n+  REAL(__CFInitialize)();\n+  if (!cf_asan && asan_inited) ReplaceCFAllocator();\n+}\n+\n+namespace {\n+\n+// TODO(glider): the mz_* functions should be united with the Linux wrappers,\n+// as they are basically copied from there.\n+size_t mz_size(malloc_zone_t* zone, const void* ptr) {\n+  return asan_mz_size(ptr);\n+}\n+\n+void *mz_malloc(malloc_zone_t *zone, size_t size) {\n+  if (!asan_inited) {\n+    CHECK(system_malloc_zone);\n+    return malloc_zone_malloc(system_malloc_zone, size);\n+  }\n+  GET_STACK_TRACE_HERE_FOR_MALLOC;\n+  return asan_malloc(size, &stack);\n+}\n+\n+void *cf_malloc(CFIndex size, CFOptionFlags hint, void *info) {\n+  if (!asan_inited) {\n+    CHECK(system_malloc_zone);\n+    return malloc_zone_malloc(system_malloc_zone, size);\n+  }\n+  GET_STACK_TRACE_HERE_FOR_MALLOC;\n+  return asan_malloc(size, &stack);\n+}\n+\n+void *mz_calloc(malloc_zone_t *zone, size_t nmemb, size_t size) {\n+  if (!asan_inited) {\n+    // Hack: dlsym calls calloc before REAL(calloc) is retrieved from dlsym.\n+    const size_t kCallocPoolSize = 1024;\n+    static uptr calloc_memory_for_dlsym[kCallocPoolSize];\n+    static size_t allocated;\n+    size_t size_in_words = ((nmemb * size) + kWordSize - 1) / kWordSize;\n+    void *mem = (void*)&calloc_memory_for_dlsym[allocated];\n+    allocated += size_in_words;\n+    CHECK(allocated < kCallocPoolSize);\n+    return mem;\n+  }\n+  GET_STACK_TRACE_HERE_FOR_MALLOC;\n+  return asan_calloc(nmemb, size, &stack);\n+}\n+\n+void *mz_valloc(malloc_zone_t *zone, size_t size) {\n+  if (!asan_inited) {\n+    CHECK(system_malloc_zone);\n+    return malloc_zone_valloc(system_malloc_zone, size);\n+  }\n+  GET_STACK_TRACE_HERE_FOR_MALLOC;\n+  return asan_memalign(kPageSize, size, &stack);\n+}\n+\n+#define GET_ZONE_FOR_PTR(ptr) \\\n+  malloc_zone_t *zone_ptr = malloc_zone_from_ptr(ptr); \\\n+  const char *zone_name = (zone_ptr == 0) ? 0 : zone_ptr->zone_name\n+\n+void ALWAYS_INLINE free_common(void *context, void *ptr) {\n+  if (!ptr) return;\n+  if (asan_mz_size(ptr)) {\n+    GET_STACK_TRACE_HERE_FOR_FREE(ptr);\n+    asan_free(ptr, &stack);\n+  } else {\n+    // If the pointer does not belong to any of the zones, use one of the\n+    // fallback methods to free memory.\n+    malloc_zone_t *zone_ptr = malloc_zone_from_ptr(ptr);\n+    if (zone_ptr == system_purgeable_zone) {\n+      // allocations from malloc_default_purgeable_zone() done before\n+      // __asan_init() may be occasionally freed via free_common().\n+      // see http://code.google.com/p/address-sanitizer/issues/detail?id=99.\n+      malloc_zone_free(zone_ptr, ptr);\n+    } else {\n+      // If the memory chunk pointer was moved to store additional\n+      // CFAllocatorRef, fix it back.\n+      ptr = get_saved_cfallocator_ref(ptr);\n+      GET_STACK_TRACE_HERE_FOR_FREE(ptr);\n+      if (!flags()->mac_ignore_invalid_free) {\n+        asan_free(ptr, &stack);\n+      } else {\n+        GET_ZONE_FOR_PTR(ptr);\n+        WarnMacFreeUnallocated((uptr)ptr, (uptr)zone_ptr, zone_name, &stack);\n+        return;\n+      }\n+    }\n+  }\n+}\n+\n+// TODO(glider): the allocation callbacks need to be refactored.\n+void mz_free(malloc_zone_t *zone, void *ptr) {\n+  free_common(zone, ptr);\n+}\n+\n+void cf_free(void *ptr, void *info) {\n+  free_common(info, ptr);\n+}\n+\n+void *mz_realloc(malloc_zone_t *zone, void *ptr, size_t size) {\n+  if (!ptr) {\n+    GET_STACK_TRACE_HERE_FOR_MALLOC;\n+    return asan_malloc(size, &stack);\n+  } else {\n+    if (asan_mz_size(ptr)) {\n+      GET_STACK_TRACE_HERE_FOR_MALLOC;\n+      return asan_realloc(ptr, size, &stack);\n+    } else {\n+      // We can't recover from reallocating an unknown address, because\n+      // this would require reading at most |size| bytes from\n+      // potentially unaccessible memory.\n+      GET_STACK_TRACE_HERE_FOR_FREE(ptr);\n+      GET_ZONE_FOR_PTR(ptr);\n+      ReportMacMzReallocUnknown((uptr)ptr, (uptr)zone_ptr, zone_name, &stack);\n+    }\n+  }\n+}\n+\n+void *cf_realloc(void *ptr, CFIndex size, CFOptionFlags hint, void *info) {\n+  if (!ptr) {\n+    GET_STACK_TRACE_HERE_FOR_MALLOC;\n+    return asan_malloc(size, &stack);\n+  } else {\n+    if (asan_mz_size(ptr)) {\n+      GET_STACK_TRACE_HERE_FOR_MALLOC;\n+      return asan_realloc(ptr, size, &stack);\n+    } else {\n+      // We can't recover from reallocating an unknown address, because\n+      // this would require reading at most |size| bytes from\n+      // potentially unaccessible memory.\n+      GET_STACK_TRACE_HERE_FOR_FREE(ptr);\n+      GET_ZONE_FOR_PTR(ptr);\n+      ReportMacCfReallocUnknown((uptr)ptr, (uptr)zone_ptr, zone_name, &stack);\n+    }\n+  }\n+}\n+\n+void mz_destroy(malloc_zone_t* zone) {\n+  // A no-op -- we will not be destroyed!\n+  Printf(\"mz_destroy() called -- ignoring\\n\");\n+}\n+  // from AvailabilityMacros.h\n+#if defined(MAC_OS_X_VERSION_10_6) && \\\n+    MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_6\n+void *mz_memalign(malloc_zone_t *zone, size_t align, size_t size) {\n+  if (!asan_inited) {\n+    CHECK(system_malloc_zone);\n+    return malloc_zone_memalign(system_malloc_zone, align, size);\n+  }\n+  GET_STACK_TRACE_HERE_FOR_MALLOC;\n+  return asan_memalign(align, size, &stack);\n+}\n+\n+// This function is currently unused, and we build with -Werror.\n+#if 0\n+void mz_free_definite_size(malloc_zone_t* zone, void *ptr, size_t size) {\n+  // TODO(glider): check that |size| is valid.\n+  UNIMPLEMENTED();\n+}\n+#endif\n+#endif\n+\n+kern_return_t mi_enumerator(task_t task, void *,\n+                            unsigned type_mask, vm_address_t zone_address,\n+                            memory_reader_t reader,\n+                            vm_range_recorder_t recorder) {\n+  // Should enumerate all the pointers we have.  Seems like a lot of work.\n+  return KERN_FAILURE;\n+}\n+\n+size_t mi_good_size(malloc_zone_t *zone, size_t size) {\n+  // I think it's always safe to return size, but we maybe could do better.\n+  return size;\n+}\n+\n+boolean_t mi_check(malloc_zone_t *zone) {\n+  UNIMPLEMENTED();\n+  return true;\n+}\n+\n+void mi_print(malloc_zone_t *zone, boolean_t verbose) {\n+  UNIMPLEMENTED();\n+  return;\n+}\n+\n+void mi_log(malloc_zone_t *zone, void *address) {\n+  // I don't think we support anything like this\n+}\n+\n+void mi_force_lock(malloc_zone_t *zone) {\n+  asan_mz_force_lock();\n+}\n+\n+void mi_force_unlock(malloc_zone_t *zone) {\n+  asan_mz_force_unlock();\n+}\n+\n+void mi_statistics(malloc_zone_t *zone, malloc_statistics_t *stats) {\n+  AsanMallocStats malloc_stats;\n+  asanThreadRegistry().FillMallocStatistics(&malloc_stats);\n+  CHECK(sizeof(malloc_statistics_t) == sizeof(AsanMallocStats));\n+  internal_memcpy(stats, &malloc_stats, sizeof(malloc_statistics_t));\n+}\n+\n+#if defined(MAC_OS_X_VERSION_10_6) && \\\n+    MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_6\n+boolean_t mi_zone_locked(malloc_zone_t *zone) {\n+  // UNIMPLEMENTED();\n+  return false;\n+}\n+#endif\n+\n+}  // unnamed namespace\n+\n+extern int __CFRuntimeClassTableSize;\n+\n+namespace __asan {\n+void ReplaceCFAllocator() {\n+  static CFAllocatorContext asan_context = {\n+        /*version*/ 0, /*info*/ &asan_zone,\n+        /*retain*/ 0, /*release*/ 0,\n+        /*copyDescription*/0,\n+        /*allocate*/ &cf_malloc,\n+        /*reallocate*/ &cf_realloc,\n+        /*deallocate*/ &cf_free,\n+        /*preferredSize*/ 0 };\n+  if (!cf_asan)\n+    cf_asan = CFAllocatorCreate(kCFAllocatorUseContext, &asan_context);\n+  if (CFAllocatorGetDefault() != cf_asan)\n+    CFAllocatorSetDefault(cf_asan);\n+}\n+\n+void ReplaceSystemMalloc() {\n+  static malloc_introspection_t asan_introspection;\n+  // Ok to use internal_memset, these places are not performance-critical.\n+  internal_memset(&asan_introspection, 0, sizeof(asan_introspection));\n+\n+  asan_introspection.enumerator = &mi_enumerator;\n+  asan_introspection.good_size = &mi_good_size;\n+  asan_introspection.check = &mi_check;\n+  asan_introspection.print = &mi_print;\n+  asan_introspection.log = &mi_log;\n+  asan_introspection.force_lock = &mi_force_lock;\n+  asan_introspection.force_unlock = &mi_force_unlock;\n+  asan_introspection.statistics = &mi_statistics;\n+\n+  internal_memset(&asan_zone, 0, sizeof(malloc_zone_t));\n+\n+  // Start with a version 4 zone which is used for OS X 10.4 and 10.5.\n+  asan_zone.version = 4;\n+  asan_zone.zone_name = \"asan\";\n+  asan_zone.size = &mz_size;\n+  asan_zone.malloc = &mz_malloc;\n+  asan_zone.calloc = &mz_calloc;\n+  asan_zone.valloc = &mz_valloc;\n+  asan_zone.free = &mz_free;\n+  asan_zone.realloc = &mz_realloc;\n+  asan_zone.destroy = &mz_destroy;\n+  asan_zone.batch_malloc = 0;\n+  asan_zone.batch_free = 0;\n+  asan_zone.introspect = &asan_introspection;\n+\n+  // from AvailabilityMacros.h\n+#if defined(MAC_OS_X_VERSION_10_6) && \\\n+    MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_6\n+  // Switch to version 6 on OSX 10.6 to support memalign.\n+  asan_zone.version = 6;\n+  asan_zone.free_definite_size = 0;\n+  asan_zone.memalign = &mz_memalign;\n+  asan_introspection.zone_locked = &mi_zone_locked;\n+\n+  // Request the default purgable zone to force its creation. The\n+  // current default zone is registered with the purgable zone for\n+  // doing tiny and small allocs.  Sadly, it assumes that the default\n+  // zone is the szone implementation from OS X and will crash if it\n+  // isn't.  By creating the zone now, this will be true and changing\n+  // the default zone won't cause a problem.  (OS X 10.6 and higher.)\n+  system_purgeable_zone = malloc_default_purgeable_zone();\n+#endif\n+\n+  // Register the ASan zone. At this point, it will not be the\n+  // default zone.\n+  malloc_zone_register(&asan_zone);\n+\n+  // Unregister and reregister the default zone.  Unregistering swaps\n+  // the specified zone with the last one registered which for the\n+  // default zone makes the more recently registered zone the default\n+  // zone.  The default zone is then re-registered to ensure that\n+  // allocations made from it earlier will be handled correctly.\n+  // Things are not guaranteed to work that way, but it's how they work now.\n+  system_malloc_zone = malloc_default_zone();\n+  malloc_zone_unregister(system_malloc_zone);\n+  malloc_zone_register(system_malloc_zone);\n+  // Make sure the default allocator was replaced.\n+  CHECK(malloc_default_zone() == &asan_zone);\n+\n+  if (flags()->replace_cfallocator) {\n+    // If __CFInitialize() hasn't been called yet, cf_asan will be created and\n+    // installed as the default allocator after __CFInitialize() finishes (see\n+    // the interceptor for __CFInitialize() above). Otherwise install cf_asan\n+    // right now. On both Snow Leopard and Lion __CFInitialize() calls\n+    // __CFAllocatorInitialize(), which initializes the _base._cfisa field of\n+    // the default allocators we check here.\n+    if (((CFRuntimeBase*)kCFAllocatorSystemDefault)->_cfisa) {\n+      ReplaceCFAllocator();\n+    }\n+  }\n+}\n+}  // namespace __asan\n+\n+#endif  // __APPLE__"}, {"sha": "7389a2572487e50570f1aebedd1bbc370c38ed84", "filename": "libsanitizer/asan/asan_malloc_win.cc", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_malloc_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_malloc_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_malloc_win.cc?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,140 @@\n+//===-- asan_malloc_win.cc ------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// Windows-specific malloc interception.\n+//===----------------------------------------------------------------------===//\n+#ifdef _WIN32\n+\n+#include \"asan_allocator.h\"\n+#include \"asan_interceptors.h\"\n+#include \"asan_internal.h\"\n+#include \"asan_stack.h\"\n+#include \"interception/interception.h\"\n+\n+#include <stddef.h>\n+\n+// ---------------------- Replacement functions ---------------- {{{1\n+using namespace __asan;  // NOLINT\n+\n+// FIXME: Simply defining functions with the same signature in *.obj\n+// files overrides the standard functions in *.lib\n+// This works well for simple helloworld-like tests but might need to be\n+// revisited in the future.\n+\n+extern \"C\" {\n+void free(void *ptr) {\n+  GET_STACK_TRACE_HERE_FOR_FREE(ptr);\n+  return asan_free(ptr, &stack);\n+}\n+\n+void _free_dbg(void* ptr, int) {\n+  free(ptr);\n+}\n+\n+void cfree(void *ptr) {\n+  CHECK(!\"cfree() should not be used on Windows?\");\n+}\n+\n+void *malloc(size_t size) {\n+  GET_STACK_TRACE_HERE_FOR_MALLOC;\n+  return asan_malloc(size, &stack);\n+}\n+\n+void* _malloc_dbg(size_t size, int , const char*, int) {\n+  return malloc(size);\n+}\n+\n+void *calloc(size_t nmemb, size_t size) {\n+  GET_STACK_TRACE_HERE_FOR_MALLOC;\n+  return asan_calloc(nmemb, size, &stack);\n+}\n+\n+void* _calloc_dbg(size_t n, size_t size, int, const char*, int) {\n+  return calloc(n, size);\n+}\n+\n+void *_calloc_impl(size_t nmemb, size_t size, int *errno_tmp) {\n+  return calloc(nmemb, size);\n+}\n+\n+void *realloc(void *ptr, size_t size) {\n+  GET_STACK_TRACE_HERE_FOR_MALLOC;\n+  return asan_realloc(ptr, size, &stack);\n+}\n+\n+void *_realloc_dbg(void *ptr, size_t size, int) {\n+  CHECK(!\"_realloc_dbg should not exist!\");\n+  return 0;\n+}\n+\n+void* _recalloc(void* p, size_t n, size_t elem_size) {\n+  if (!p)\n+    return calloc(n, elem_size);\n+  const size_t size = n * elem_size;\n+  if (elem_size != 0 && size / elem_size != n)\n+    return 0;\n+  return realloc(p, size);\n+}\n+\n+size_t _msize(void *ptr) {\n+  GET_STACK_TRACE_HERE_FOR_MALLOC;\n+  return asan_malloc_usable_size(ptr, &stack);\n+}\n+\n+int _CrtDbgReport(int, const char*, int,\n+                  const char*, const char*, ...) {\n+  ShowStatsAndAbort();\n+}\n+\n+int _CrtDbgReportW(int reportType, const wchar_t*, int,\n+                   const wchar_t*, const wchar_t*, ...) {\n+  ShowStatsAndAbort();\n+}\n+\n+int _CrtSetReportMode(int, int) {\n+  return 0;\n+}\n+}  // extern \"C\"\n+\n+using __interception::GetRealFunctionAddress;\n+\n+// We don't want to include \"windows.h\" in this file to avoid extra attributes\n+// set on malloc/free etc (e.g. dllimport), so declare a few things manually:\n+extern \"C\" int __stdcall VirtualProtect(void* addr, size_t size,\n+                                        DWORD prot, DWORD *old_prot);\n+const int PAGE_EXECUTE_READWRITE = 0x40;\n+\n+namespace __asan {\n+void ReplaceSystemMalloc() {\n+#if defined(_DLL)\n+# ifdef _WIN64\n+#  error ReplaceSystemMalloc was not tested on x64\n+# endif\n+  char *crt_malloc;\n+  if (GetRealFunctionAddress(\"malloc\", (void**)&crt_malloc)) {\n+    // Replace malloc in the CRT dll with a jump to our malloc.\n+    DWORD old_prot, unused;\n+    CHECK(VirtualProtect(crt_malloc, 16, PAGE_EXECUTE_READWRITE, &old_prot));\n+    REAL(memset)(crt_malloc, 0xCC /* int 3 */, 16);  // just in case.\n+\n+    ptrdiff_t jmp_offset = (char*)malloc - (char*)crt_malloc - 5;\n+    crt_malloc[0] = 0xE9;  // jmp, should be followed by an offset.\n+    REAL(memcpy)(crt_malloc + 1, &jmp_offset, sizeof(jmp_offset));\n+\n+    CHECK(VirtualProtect(crt_malloc, 16, old_prot, &unused));\n+\n+    // FYI: FlushInstructionCache is needed on Itanium etc but not on x86/x64.\n+  }\n+\n+  // FIXME: investigate whether anything else is needed.\n+#endif\n+}\n+}  // namespace __asan\n+\n+#endif  // _WIN32"}, {"sha": "40a38db0544f2f5b4f420a4d2392017fa7fddd10", "filename": "libsanitizer/asan/asan_mapping.h", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_mapping.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_mapping.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mapping.h?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,120 @@\n+//===-- asan_mapping.h ------------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// Defines ASan memory mapping.\n+//===----------------------------------------------------------------------===//\n+#ifndef ASAN_MAPPING_H\n+#define ASAN_MAPPING_H\n+\n+#include \"asan_internal.h\"\n+\n+// The full explanation of the memory mapping could be found here:\n+// http://code.google.com/p/address-sanitizer/wiki/AddressSanitizerAlgorithm\n+\n+#if ASAN_FLEXIBLE_MAPPING_AND_OFFSET == 1\n+extern __attribute__((visibility(\"default\"))) uptr __asan_mapping_scale;\n+extern __attribute__((visibility(\"default\"))) uptr __asan_mapping_offset;\n+# define SHADOW_SCALE (__asan_mapping_scale)\n+# define SHADOW_OFFSET (__asan_mapping_offset)\n+#else\n+# if ASAN_ANDROID\n+#  define SHADOW_SCALE (3)\n+#  define SHADOW_OFFSET (0)\n+# else\n+#  define SHADOW_SCALE (3)\n+#  if __WORDSIZE == 32\n+#   define SHADOW_OFFSET (1 << 29)\n+#  else\n+#   define SHADOW_OFFSET (1ULL << 44)\n+#  endif\n+# endif\n+#endif  // ASAN_FLEXIBLE_MAPPING_AND_OFFSET\n+\n+#define SHADOW_GRANULARITY (1ULL << SHADOW_SCALE)\n+#define MEM_TO_SHADOW(mem) (((mem) >> SHADOW_SCALE) | (SHADOW_OFFSET))\n+#define SHADOW_TO_MEM(shadow) (((shadow) - SHADOW_OFFSET) << SHADOW_SCALE)\n+\n+#if __WORDSIZE == 64\n+  static const uptr kHighMemEnd = 0x00007fffffffffffUL;\n+#else  // __WORDSIZE == 32\n+  static const uptr kHighMemEnd = 0xffffffff;\n+#endif  // __WORDSIZE\n+\n+\n+#define kLowMemBeg      0\n+#define kLowMemEnd      (SHADOW_OFFSET ? SHADOW_OFFSET - 1 : 0)\n+\n+#define kLowShadowBeg   SHADOW_OFFSET\n+#define kLowShadowEnd   MEM_TO_SHADOW(kLowMemEnd)\n+\n+#define kHighMemBeg     (MEM_TO_SHADOW(kHighMemEnd) + 1)\n+\n+#define kHighShadowBeg  MEM_TO_SHADOW(kHighMemBeg)\n+#define kHighShadowEnd  MEM_TO_SHADOW(kHighMemEnd)\n+\n+#define kShadowGapBeg   (kLowShadowEnd ? kLowShadowEnd + 1 : 16 * kPageSize)\n+#define kShadowGapEnd   (kHighShadowBeg - 1)\n+\n+#define kGlobalAndStackRedzone \\\n+      (SHADOW_GRANULARITY < 32 ? 32 : SHADOW_GRANULARITY)\n+\n+namespace __asan {\n+\n+static inline bool AddrIsInLowMem(uptr a) {\n+  return a < kLowMemEnd;\n+}\n+\n+static inline bool AddrIsInLowShadow(uptr a) {\n+  return a >= kLowShadowBeg && a <= kLowShadowEnd;\n+}\n+\n+static inline bool AddrIsInHighMem(uptr a) {\n+  return a >= kHighMemBeg && a <= kHighMemEnd;\n+}\n+\n+static inline bool AddrIsInMem(uptr a) {\n+  return AddrIsInLowMem(a) || AddrIsInHighMem(a);\n+}\n+\n+static inline uptr MemToShadow(uptr p) {\n+  CHECK(AddrIsInMem(p));\n+  return MEM_TO_SHADOW(p);\n+}\n+\n+static inline bool AddrIsInHighShadow(uptr a) {\n+  return a >= kHighShadowBeg && a <=  kHighMemEnd;\n+}\n+\n+static inline bool AddrIsInShadow(uptr a) {\n+  return AddrIsInLowShadow(a) || AddrIsInHighShadow(a);\n+}\n+\n+static inline bool AddrIsInShadowGap(uptr a) {\n+  return a >= kShadowGapBeg && a <= kShadowGapEnd;\n+}\n+\n+static inline bool AddrIsAlignedByGranularity(uptr a) {\n+  return (a & (SHADOW_GRANULARITY - 1)) == 0;\n+}\n+\n+static inline bool AddressIsPoisoned(uptr a) {\n+  const uptr kAccessSize = 1;\n+  u8 *shadow_address = (u8*)MemToShadow(a);\n+  s8 shadow_value = *shadow_address;\n+  if (shadow_value) {\n+    u8 last_accessed_byte = (a & (SHADOW_GRANULARITY - 1))\n+                                 + kAccessSize - 1;\n+    return (last_accessed_byte >= shadow_value);\n+  }\n+  return false;\n+}\n+\n+}  // namespace __asan\n+\n+#endif  // ASAN_MAPPING_H"}, {"sha": "a2180ae94442b28af76c4ed9239843da9cd8f5f3", "filename": "libsanitizer/asan/asan_new_delete.cc", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_new_delete.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_new_delete.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_new_delete.cc?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,54 @@\n+//===-- asan_interceptors.cc ----------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// Interceptors for operators new and delete.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"asan_allocator.h\"\n+#include \"asan_internal.h\"\n+#include \"asan_stack.h\"\n+\n+#include <stddef.h>\n+#include <new>\n+\n+namespace __asan {\n+// This function is a no-op. We need it to make sure that object file\n+// with our replacements will actually be loaded from static ASan\n+// run-time library at link-time.\n+void ReplaceOperatorsNewAndDelete() { }\n+}\n+\n+using namespace __asan;  // NOLINT\n+\n+#define OPERATOR_NEW_BODY \\\n+  GET_STACK_TRACE_HERE_FOR_MALLOC;\\\n+  return asan_memalign(0, size, &stack);\n+\n+#if ASAN_ANDROID\n+void *operator new(size_t size) { OPERATOR_NEW_BODY; }\n+void *operator new[](size_t size) { OPERATOR_NEW_BODY; }\n+#else\n+void *operator new(size_t size) throw(std::bad_alloc) { OPERATOR_NEW_BODY; }\n+void *operator new[](size_t size) throw(std::bad_alloc) { OPERATOR_NEW_BODY; }\n+void *operator new(size_t size, std::nothrow_t const&) throw()\n+{ OPERATOR_NEW_BODY; }\n+void *operator new[](size_t size, std::nothrow_t const&) throw()\n+{ OPERATOR_NEW_BODY; }\n+#endif\n+\n+#define OPERATOR_DELETE_BODY \\\n+  GET_STACK_TRACE_HERE_FOR_FREE(ptr);\\\n+  asan_free(ptr, &stack);\n+\n+void operator delete(void *ptr) throw() { OPERATOR_DELETE_BODY; }\n+void operator delete[](void *ptr) throw() { OPERATOR_DELETE_BODY; }\n+void operator delete(void *ptr, std::nothrow_t const&) throw()\n+{ OPERATOR_DELETE_BODY; }\n+void operator delete[](void *ptr, std::nothrow_t const&) throw()\n+{ OPERATOR_DELETE_BODY; }"}, {"sha": "716be7e41700ac4f4b6bb14693a5116424deb3fb", "filename": "libsanitizer/asan/asan_poisoning.cc", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_poisoning.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_poisoning.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_poisoning.cc?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,151 @@\n+//===-- asan_poisoning.cc -------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// Shadow memory poisoning by ASan RTL and by user application.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"asan_interceptors.h\"\n+#include \"asan_internal.h\"\n+#include \"asan_mapping.h\"\n+#include \"sanitizer/asan_interface.h\"\n+\n+namespace __asan {\n+\n+void PoisonShadow(uptr addr, uptr size, u8 value) {\n+  CHECK(AddrIsAlignedByGranularity(addr));\n+  CHECK(AddrIsAlignedByGranularity(addr + size));\n+  uptr shadow_beg = MemToShadow(addr);\n+  uptr shadow_end = MemToShadow(addr + size);\n+  CHECK(REAL(memset) != 0);\n+  REAL(memset)((void*)shadow_beg, value, shadow_end - shadow_beg);\n+}\n+\n+void PoisonShadowPartialRightRedzone(uptr addr,\n+                                     uptr size,\n+                                     uptr redzone_size,\n+                                     u8 value) {\n+  CHECK(AddrIsAlignedByGranularity(addr));\n+  u8 *shadow = (u8*)MemToShadow(addr);\n+  for (uptr i = 0; i < redzone_size;\n+       i += SHADOW_GRANULARITY, shadow++) {\n+    if (i + SHADOW_GRANULARITY <= size) {\n+      *shadow = 0;  // fully addressable\n+    } else if (i >= size) {\n+      *shadow = (SHADOW_GRANULARITY == 128) ? 0xff : value;  // unaddressable\n+    } else {\n+      *shadow = size - i;  // first size-i bytes are addressable\n+    }\n+  }\n+}\n+\n+\n+struct ShadowSegmentEndpoint {\n+  u8 *chunk;\n+  s8 offset;  // in [0, SHADOW_GRANULARITY)\n+  s8 value;  // = *chunk;\n+\n+  explicit ShadowSegmentEndpoint(uptr address) {\n+    chunk = (u8*)MemToShadow(address);\n+    offset = address & (SHADOW_GRANULARITY - 1);\n+    value = *chunk;\n+  }\n+};\n+\n+}  // namespace __asan\n+\n+// ---------------------- Interface ---------------- {{{1\n+using namespace __asan;  // NOLINT\n+\n+// Current implementation of __asan_(un)poison_memory_region doesn't check\n+// that user program (un)poisons the memory it owns. It poisons memory\n+// conservatively, and unpoisons progressively to make sure asan shadow\n+// mapping invariant is preserved (see detailed mapping description here:\n+// http://code.google.com/p/address-sanitizer/wiki/AddressSanitizerAlgorithm).\n+//\n+// * if user asks to poison region [left, right), the program poisons\n+// at least [left, AlignDown(right)).\n+// * if user asks to unpoison region [left, right), the program unpoisons\n+// at most [AlignDown(left), right).\n+void __asan_poison_memory_region(void const volatile *addr, uptr size) {\n+  if (!flags()->allow_user_poisoning || size == 0) return;\n+  uptr beg_addr = (uptr)addr;\n+  uptr end_addr = beg_addr + size;\n+  if (flags()->verbosity >= 1) {\n+    Printf(\"Trying to poison memory region [%p, %p)\\n\",\n+           (void*)beg_addr, (void*)end_addr);\n+  }\n+  ShadowSegmentEndpoint beg(beg_addr);\n+  ShadowSegmentEndpoint end(end_addr);\n+  if (beg.chunk == end.chunk) {\n+    CHECK(beg.offset < end.offset);\n+    s8 value = beg.value;\n+    CHECK(value == end.value);\n+    // We can only poison memory if the byte in end.offset is unaddressable.\n+    // No need to re-poison memory if it is poisoned already.\n+    if (value > 0 && value <= end.offset) {\n+      if (beg.offset > 0) {\n+        *beg.chunk = Min(value, beg.offset);\n+      } else {\n+        *beg.chunk = kAsanUserPoisonedMemoryMagic;\n+      }\n+    }\n+    return;\n+  }\n+  CHECK(beg.chunk < end.chunk);\n+  if (beg.offset > 0) {\n+    // Mark bytes from beg.offset as unaddressable.\n+    if (beg.value == 0) {\n+      *beg.chunk = beg.offset;\n+    } else {\n+      *beg.chunk = Min(beg.value, beg.offset);\n+    }\n+    beg.chunk++;\n+  }\n+  REAL(memset)(beg.chunk, kAsanUserPoisonedMemoryMagic, end.chunk - beg.chunk);\n+  // Poison if byte in end.offset is unaddressable.\n+  if (end.value > 0 && end.value <= end.offset) {\n+    *end.chunk = kAsanUserPoisonedMemoryMagic;\n+  }\n+}\n+\n+void __asan_unpoison_memory_region(void const volatile *addr, uptr size) {\n+  if (!flags()->allow_user_poisoning || size == 0) return;\n+  uptr beg_addr = (uptr)addr;\n+  uptr end_addr = beg_addr + size;\n+  if (flags()->verbosity >= 1) {\n+    Printf(\"Trying to unpoison memory region [%p, %p)\\n\",\n+           (void*)beg_addr, (void*)end_addr);\n+  }\n+  ShadowSegmentEndpoint beg(beg_addr);\n+  ShadowSegmentEndpoint end(end_addr);\n+  if (beg.chunk == end.chunk) {\n+    CHECK(beg.offset < end.offset);\n+    s8 value = beg.value;\n+    CHECK(value == end.value);\n+    // We unpoison memory bytes up to enbytes up to end.offset if it is not\n+    // unpoisoned already.\n+    if (value != 0) {\n+      *beg.chunk = Max(value, end.offset);\n+    }\n+    return;\n+  }\n+  CHECK(beg.chunk < end.chunk);\n+  if (beg.offset > 0) {\n+    *beg.chunk = 0;\n+    beg.chunk++;\n+  }\n+  REAL(memset)(beg.chunk, 0, end.chunk - beg.chunk);\n+  if (end.offset > 0 && end.value != 0) {\n+    *end.chunk = Max(end.value, end.offset);\n+  }\n+}\n+\n+bool __asan_address_is_poisoned(void const volatile *addr) {\n+  return __asan::AddressIsPoisoned((uptr)addr);\n+}"}, {"sha": "177b84ae67fb009e00a2ba24c544ebb088f6d35e", "filename": "libsanitizer/asan/asan_posix.cc", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_posix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_posix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_posix.cc?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,118 @@\n+//===-- asan_linux.cc -----------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// Posix-specific details.\n+//===----------------------------------------------------------------------===//\n+#if defined(__linux__) || defined(__APPLE__)\n+\n+#include \"asan_internal.h\"\n+#include \"asan_interceptors.h\"\n+#include \"asan_mapping.h\"\n+#include \"asan_report.h\"\n+#include \"asan_stack.h\"\n+#include \"asan_thread_registry.h\"\n+#include \"sanitizer_common/sanitizer_libc.h\"\n+#include \"sanitizer_common/sanitizer_procmaps.h\"\n+\n+#include <pthread.h>\n+#include <signal.h>\n+#include <stdlib.h>\n+#include <sys/time.h>\n+#include <sys/resource.h>\n+#include <unistd.h>\n+\n+static const uptr kAltStackSize = SIGSTKSZ * 4;  // SIGSTKSZ is not enough.\n+\n+namespace __asan {\n+\n+static void MaybeInstallSigaction(int signum,\n+                                  void (*handler)(int, siginfo_t *, void *)) {\n+  if (!AsanInterceptsSignal(signum))\n+    return;\n+  struct sigaction sigact;\n+  REAL(memset)(&sigact, 0, sizeof(sigact));\n+  sigact.sa_sigaction = handler;\n+  sigact.sa_flags = SA_SIGINFO;\n+  if (flags()->use_sigaltstack) sigact.sa_flags |= SA_ONSTACK;\n+  CHECK(0 == REAL(sigaction)(signum, &sigact, 0));\n+  if (flags()->verbosity >= 1) {\n+    Report(\"Installed the sigaction for signal %d\\n\", signum);\n+  }\n+}\n+\n+static void     ASAN_OnSIGSEGV(int, siginfo_t *siginfo, void *context) {\n+  uptr addr = (uptr)siginfo->si_addr;\n+  // Write the first message using the bullet-proof write.\n+  if (13 != internal_write(2, \"ASAN:SIGSEGV\\n\", 13)) Die();\n+  uptr pc, sp, bp;\n+  GetPcSpBp(context, &pc, &sp, &bp);\n+  ReportSIGSEGV(pc, sp, bp, addr);\n+}\n+\n+void SetAlternateSignalStack() {\n+  stack_t altstack, oldstack;\n+  CHECK(0 == sigaltstack(0, &oldstack));\n+  // If the alternate stack is already in place, do nothing.\n+  if ((oldstack.ss_flags & SS_DISABLE) == 0) return;\n+  // TODO(glider): the mapped stack should have the MAP_STACK flag in the\n+  // future. It is not required by man 2 sigaltstack now (they're using\n+  // malloc()).\n+  void* base = MmapOrDie(kAltStackSize, __FUNCTION__);\n+  altstack.ss_sp = base;\n+  altstack.ss_flags = 0;\n+  altstack.ss_size = kAltStackSize;\n+  CHECK(0 == sigaltstack(&altstack, 0));\n+  if (flags()->verbosity > 0) {\n+    Report(\"Alternative stack for T%d set: [%p,%p)\\n\",\n+           asanThreadRegistry().GetCurrentTidOrInvalid(),\n+           altstack.ss_sp, (char*)altstack.ss_sp + altstack.ss_size);\n+  }\n+}\n+\n+void UnsetAlternateSignalStack() {\n+  stack_t altstack, oldstack;\n+  altstack.ss_sp = 0;\n+  altstack.ss_flags = SS_DISABLE;\n+  altstack.ss_size = 0;\n+  CHECK(0 == sigaltstack(&altstack, &oldstack));\n+  UnmapOrDie(oldstack.ss_sp, oldstack.ss_size);\n+}\n+\n+void InstallSignalHandlers() {\n+  // Set the alternate signal stack for the main thread.\n+  // This will cause SetAlternateSignalStack to be called twice, but the stack\n+  // will be actually set only once.\n+  if (flags()->use_sigaltstack) SetAlternateSignalStack();\n+  MaybeInstallSigaction(SIGSEGV, ASAN_OnSIGSEGV);\n+  MaybeInstallSigaction(SIGBUS, ASAN_OnSIGSEGV);\n+}\n+\n+// ---------------------- TSD ---------------- {{{1\n+\n+static pthread_key_t tsd_key;\n+static bool tsd_key_inited = false;\n+void AsanTSDInit(void (*destructor)(void *tsd)) {\n+  CHECK(!tsd_key_inited);\n+  tsd_key_inited = true;\n+  CHECK(0 == pthread_key_create(&tsd_key, destructor));\n+}\n+\n+void *AsanTSDGet() {\n+  CHECK(tsd_key_inited);\n+  return pthread_getspecific(tsd_key);\n+}\n+\n+void AsanTSDSet(void *tsd) {\n+  CHECK(tsd_key_inited);\n+  pthread_setspecific(tsd_key, tsd);\n+}\n+\n+}  // namespace __asan\n+\n+#endif  // __linux__ || __APPLE_"}, {"sha": "7e6381c2beb0d37033322b77a0a05166056f570e", "filename": "libsanitizer/asan/asan_report.cc", "status": "added", "additions": 492, "deletions": 0, "changes": 492, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_report.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_report.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_report.cc?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,492 @@\n+//===-- asan_report.cc ----------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// This file contains error reporting code.\n+//===----------------------------------------------------------------------===//\n+#include \"asan_flags.h\"\n+#include \"asan_internal.h\"\n+#include \"asan_mapping.h\"\n+#include \"asan_report.h\"\n+#include \"asan_stack.h\"\n+#include \"asan_thread.h\"\n+#include \"asan_thread_registry.h\"\n+\n+namespace __asan {\n+\n+// -------------------- User-specified callbacks ----------------- {{{1\n+static void (*error_report_callback)(const char*);\n+static char *error_message_buffer = 0;\n+static uptr error_message_buffer_pos = 0;\n+static uptr error_message_buffer_size = 0;\n+\n+void AppendToErrorMessageBuffer(const char *buffer) {\n+  if (error_message_buffer) {\n+    uptr length = internal_strlen(buffer);\n+    CHECK_GE(error_message_buffer_size, error_message_buffer_pos);\n+    uptr remaining = error_message_buffer_size - error_message_buffer_pos;\n+    internal_strncpy(error_message_buffer + error_message_buffer_pos,\n+                     buffer, remaining);\n+    error_message_buffer[error_message_buffer_size - 1] = '\\0';\n+    // FIXME: reallocate the buffer instead of truncating the message.\n+    error_message_buffer_pos += remaining > length ? length : remaining;\n+  }\n+}\n+\n+// ---------------------- Helper functions ----------------------- {{{1\n+\n+static void PrintBytes(const char *before, uptr *a) {\n+  u8 *bytes = (u8*)a;\n+  uptr byte_num = (__WORDSIZE) / 8;\n+  Printf(\"%s%p:\", before, (void*)a);\n+  for (uptr i = 0; i < byte_num; i++) {\n+    Printf(\" %x%x\", bytes[i] >> 4, bytes[i] & 15);\n+  }\n+  Printf(\"\\n\");\n+}\n+\n+static void PrintShadowMemoryForAddress(uptr addr) {\n+  if (!AddrIsInMem(addr))\n+    return;\n+  uptr shadow_addr = MemToShadow(addr);\n+  Printf(\"Shadow byte and word:\\n\");\n+  Printf(\"  %p: %x\\n\", (void*)shadow_addr, *(unsigned char*)shadow_addr);\n+  uptr aligned_shadow = shadow_addr & ~(kWordSize - 1);\n+  PrintBytes(\"  \", (uptr*)(aligned_shadow));\n+  Printf(\"More shadow bytes:\\n\");\n+  for (int i = -4; i <= 4; i++) {\n+    const char *prefix = (i == 0) ? \"=>\" : \"  \";\n+    PrintBytes(prefix, (uptr*)(aligned_shadow + i * kWordSize));\n+  }\n+}\n+\n+static void PrintZoneForPointer(uptr ptr, uptr zone_ptr,\n+                                const char *zone_name) {\n+  if (zone_ptr) {\n+    if (zone_name) {\n+      Printf(\"malloc_zone_from_ptr(%p) = %p, which is %s\\n\",\n+                 ptr, zone_ptr, zone_name);\n+    } else {\n+      Printf(\"malloc_zone_from_ptr(%p) = %p, which doesn't have a name\\n\",\n+                 ptr, zone_ptr);\n+    }\n+  } else {\n+    Printf(\"malloc_zone_from_ptr(%p) = 0\\n\", ptr);\n+  }\n+}\n+\n+// ---------------------- Address Descriptions ------------------- {{{1\n+\n+static bool IsASCII(unsigned char c) {\n+  return /*0x00 <= c &&*/ c <= 0x7F;\n+}\n+\n+// Check if the global is a zero-terminated ASCII string. If so, print it.\n+static void PrintGlobalNameIfASCII(const __asan_global &g) {\n+  for (uptr p = g.beg; p < g.beg + g.size - 1; p++) {\n+    if (!IsASCII(*(unsigned char*)p)) return;\n+  }\n+  if (*(char*)(g.beg + g.size - 1) != 0) return;\n+  Printf(\"  '%s' is ascii string '%s'\\n\", g.name, (char*)g.beg);\n+}\n+\n+bool DescribeAddressRelativeToGlobal(uptr addr, const __asan_global &g) {\n+  if (addr < g.beg - kGlobalAndStackRedzone) return false;\n+  if (addr >= g.beg + g.size_with_redzone) return false;\n+  Printf(\"%p is located \", (void*)addr);\n+  if (addr < g.beg) {\n+    Printf(\"%zd bytes to the left\", g.beg - addr);\n+  } else if (addr >= g.beg + g.size) {\n+    Printf(\"%zd bytes to the right\", addr - (g.beg + g.size));\n+  } else {\n+    Printf(\"%zd bytes inside\", addr - g.beg);  // Can it happen?\n+  }\n+  Printf(\" of global variable '%s' (0x%zx) of size %zu\\n\",\n+             g.name, g.beg, g.size);\n+  PrintGlobalNameIfASCII(g);\n+  return true;\n+}\n+\n+bool DescribeAddressIfShadow(uptr addr) {\n+  if (AddrIsInMem(addr))\n+    return false;\n+  static const char kAddrInShadowReport[] =\n+      \"Address %p is located in the %s.\\n\";\n+  if (AddrIsInShadowGap(addr)) {\n+    Printf(kAddrInShadowReport, addr, \"shadow gap area\");\n+    return true;\n+  }\n+  if (AddrIsInHighShadow(addr)) {\n+    Printf(kAddrInShadowReport, addr, \"high shadow area\");\n+    return true;\n+  }\n+  if (AddrIsInLowShadow(addr)) {\n+    Printf(kAddrInShadowReport, addr, \"low shadow area\");\n+    return true;\n+  }\n+  CHECK(0 && \"Address is not in memory and not in shadow?\");\n+  return false;\n+}\n+\n+bool DescribeAddressIfStack(uptr addr, uptr access_size) {\n+  AsanThread *t = asanThreadRegistry().FindThreadByStackAddress(addr);\n+  if (!t) return false;\n+  const sptr kBufSize = 4095;\n+  char buf[kBufSize];\n+  uptr offset = 0;\n+  const char *frame_descr = t->GetFrameNameByAddr(addr, &offset);\n+  // This string is created by the compiler and has the following form:\n+  // \"FunctioName n alloc_1 alloc_2 ... alloc_n\"\n+  // where alloc_i looks like \"offset size len ObjectName \".\n+  CHECK(frame_descr);\n+  // Report the function name and the offset.\n+  const char *name_end = internal_strchr(frame_descr, ' ');\n+  CHECK(name_end);\n+  buf[0] = 0;\n+  internal_strncat(buf, frame_descr,\n+                   Min(kBufSize,\n+                       static_cast<sptr>(name_end - frame_descr)));\n+  Printf(\"Address %p is located at offset %zu \"\n+             \"in frame <%s> of T%d's stack:\\n\",\n+             (void*)addr, offset, buf, t->tid());\n+  // Report the number of stack objects.\n+  char *p;\n+  uptr n_objects = internal_simple_strtoll(name_end, &p, 10);\n+  CHECK(n_objects > 0);\n+  Printf(\"  This frame has %zu object(s):\\n\", n_objects);\n+  // Report all objects in this frame.\n+  for (uptr i = 0; i < n_objects; i++) {\n+    uptr beg, size;\n+    sptr len;\n+    beg  = internal_simple_strtoll(p, &p, 10);\n+    size = internal_simple_strtoll(p, &p, 10);\n+    len  = internal_simple_strtoll(p, &p, 10);\n+    if (beg <= 0 || size <= 0 || len < 0 || *p != ' ') {\n+      Printf(\"AddressSanitizer can't parse the stack frame \"\n+                 \"descriptor: |%s|\\n\", frame_descr);\n+      break;\n+    }\n+    p++;\n+    buf[0] = 0;\n+    internal_strncat(buf, p, Min(kBufSize, len));\n+    p += len;\n+    Printf(\"    [%zu, %zu) '%s'\\n\", beg, beg + size, buf);\n+  }\n+  Printf(\"HINT: this may be a false positive if your program uses \"\n+             \"some custom stack unwind mechanism\\n\"\n+             \"      (longjmp and C++ exceptions *are* supported)\\n\");\n+  DescribeThread(t->summary());\n+  return true;\n+}\n+\n+static void DescribeAccessToHeapChunk(AsanChunkView chunk, uptr addr,\n+                                      uptr access_size) {\n+  uptr offset;\n+  Printf(\"%p is located \", (void*)addr);\n+  if (chunk.AddrIsInside(addr, access_size, &offset)) {\n+    Printf(\"%zu bytes inside of\", offset);\n+  } else if (chunk.AddrIsAtLeft(addr, access_size, &offset)) {\n+    Printf(\"%zu bytes to the left of\", offset);\n+  } else if (chunk.AddrIsAtRight(addr, access_size, &offset)) {\n+    Printf(\"%zu bytes to the right of\", offset);\n+  } else {\n+    Printf(\" somewhere around (this is AddressSanitizer bug!)\");\n+  }\n+  Printf(\" %zu-byte region [%p,%p)\\n\", chunk.UsedSize(),\n+         (void*)(chunk.Beg()), (void*)(chunk.End()));\n+}\n+\n+void DescribeHeapAddress(uptr addr, uptr access_size) {\n+  AsanChunkView chunk = FindHeapChunkByAddress(addr);\n+  if (!chunk.IsValid()) return;\n+  DescribeAccessToHeapChunk(chunk, addr, access_size);\n+  CHECK(chunk.AllocTid() != kInvalidTid);\n+  AsanThreadSummary *alloc_thread =\n+      asanThreadRegistry().FindByTid(chunk.AllocTid());\n+  StackTrace alloc_stack;\n+  chunk.GetAllocStack(&alloc_stack);\n+  AsanThread *t = asanThreadRegistry().GetCurrent();\n+  CHECK(t);\n+  if (chunk.FreeTid() != kInvalidTid) {\n+    AsanThreadSummary *free_thread =\n+        asanThreadRegistry().FindByTid(chunk.FreeTid());\n+    Printf(\"freed by thread T%d here:\\n\", free_thread->tid());\n+    StackTrace free_stack;\n+    chunk.GetFreeStack(&free_stack);\n+    PrintStack(&free_stack);\n+    Printf(\"previously allocated by thread T%d here:\\n\", alloc_thread->tid());\n+    PrintStack(&alloc_stack);\n+    DescribeThread(t->summary());\n+    DescribeThread(free_thread);\n+    DescribeThread(alloc_thread);\n+  } else {\n+    Printf(\"allocated by thread T%d here:\\n\", alloc_thread->tid());\n+    PrintStack(&alloc_stack);\n+    DescribeThread(t->summary());\n+    DescribeThread(alloc_thread);\n+  }\n+}\n+\n+void DescribeAddress(uptr addr, uptr access_size) {\n+  // Check if this is shadow or shadow gap.\n+  if (DescribeAddressIfShadow(addr))\n+    return;\n+  CHECK(AddrIsInMem(addr));\n+  if (DescribeAddressIfGlobal(addr))\n+    return;\n+  if (DescribeAddressIfStack(addr, access_size))\n+    return;\n+  // Assume it is a heap address.\n+  DescribeHeapAddress(addr, access_size);\n+}\n+\n+// ------------------- Thread description -------------------- {{{1\n+\n+void DescribeThread(AsanThreadSummary *summary) {\n+  CHECK(summary);\n+  // No need to announce the main thread.\n+  if (summary->tid() == 0 || summary->announced()) {\n+    return;\n+  }\n+  summary->set_announced(true);\n+  Printf(\"Thread T%d created by T%d here:\\n\",\n+         summary->tid(), summary->parent_tid());\n+  PrintStack(summary->stack());\n+  // Recursively described parent thread if needed.\n+  if (flags()->print_full_thread_history) {\n+    AsanThreadSummary *parent_summary =\n+        asanThreadRegistry().FindByTid(summary->parent_tid());\n+    DescribeThread(parent_summary);\n+  }\n+}\n+\n+// -------------------- Different kinds of reports ----------------- {{{1\n+\n+// Use ScopedInErrorReport to run common actions just before and\n+// immediately after printing error report.\n+class ScopedInErrorReport {\n+ public:\n+  ScopedInErrorReport() {\n+    static atomic_uint32_t num_calls;\n+    static u32 reporting_thread_tid;\n+    if (atomic_fetch_add(&num_calls, 1, memory_order_relaxed) != 0) {\n+      // Do not print more than one report, otherwise they will mix up.\n+      // Error reporting functions shouldn't return at this situation, as\n+      // they are defined as no-return.\n+      Report(\"AddressSanitizer: while reporting a bug found another one.\"\n+                 \"Ignoring.\\n\");\n+      u32 current_tid = asanThreadRegistry().GetCurrentTidOrInvalid();\n+      if (current_tid != reporting_thread_tid) {\n+        // ASan found two bugs in different threads simultaneously. Sleep\n+        // long enough to make sure that the thread which started to print\n+        // an error report will finish doing it.\n+        SleepForSeconds(Max(100, flags()->sleep_before_dying + 1));\n+      }\n+      Die();\n+    }\n+    __asan_on_error();\n+    reporting_thread_tid = asanThreadRegistry().GetCurrentTidOrInvalid();\n+    Printf(\"====================================================\"\n+           \"=============\\n\");\n+    if (reporting_thread_tid != kInvalidTid) {\n+      // We started reporting an error message. Stop using the fake stack\n+      // in case we call an instrumented function from a symbolizer.\n+      AsanThread *curr_thread = asanThreadRegistry().GetCurrent();\n+      CHECK(curr_thread);\n+      curr_thread->fake_stack().StopUsingFakeStack();\n+    }\n+  }\n+  // Destructor is NORETURN, as functions that report errors are.\n+  NORETURN ~ScopedInErrorReport() {\n+    // Make sure the current thread is announced.\n+    AsanThread *curr_thread = asanThreadRegistry().GetCurrent();\n+    if (curr_thread) {\n+      DescribeThread(curr_thread->summary());\n+    }\n+    // Print memory stats.\n+    __asan_print_accumulated_stats();\n+    if (error_report_callback) {\n+      error_report_callback(error_message_buffer);\n+    }\n+    Report(\"ABORTING\\n\");\n+    Die();\n+  }\n+};\n+\n+void ReportSIGSEGV(uptr pc, uptr sp, uptr bp, uptr addr) {\n+  ScopedInErrorReport in_report;\n+  Report(\"ERROR: AddressSanitizer crashed on unknown address %p\"\n+             \" (pc %p sp %p bp %p T%d)\\n\",\n+             (void*)addr, (void*)pc, (void*)sp, (void*)bp,\n+             asanThreadRegistry().GetCurrentTidOrInvalid());\n+  Printf(\"AddressSanitizer can not provide additional info.\\n\");\n+  GET_STACK_TRACE_WITH_PC_AND_BP(kStackTraceMax, pc, bp);\n+  PrintStack(&stack);\n+}\n+\n+void ReportDoubleFree(uptr addr, StackTrace *stack) {\n+  ScopedInErrorReport in_report;\n+  Report(\"ERROR: AddressSanitizer attempting double-free on %p:\\n\", addr);\n+  PrintStack(stack);\n+  DescribeHeapAddress(addr, 1);\n+}\n+\n+void ReportFreeNotMalloced(uptr addr, StackTrace *stack) {\n+  ScopedInErrorReport in_report;\n+  Report(\"ERROR: AddressSanitizer attempting free on address \"\n+             \"which was not malloc()-ed: %p\\n\", addr);\n+  PrintStack(stack);\n+  DescribeHeapAddress(addr, 1);\n+}\n+\n+void ReportMallocUsableSizeNotOwned(uptr addr, StackTrace *stack) {\n+  ScopedInErrorReport in_report;\n+  Report(\"ERROR: AddressSanitizer attempting to call \"\n+             \"malloc_usable_size() for pointer which is \"\n+             \"not owned: %p\\n\", addr);\n+  PrintStack(stack);\n+  DescribeHeapAddress(addr, 1);\n+}\n+\n+void ReportAsanGetAllocatedSizeNotOwned(uptr addr, StackTrace *stack) {\n+  ScopedInErrorReport in_report;\n+  Report(\"ERROR: AddressSanitizer attempting to call \"\n+             \"__asan_get_allocated_size() for pointer which is \"\n+             \"not owned: %p\\n\", addr);\n+  PrintStack(stack);\n+  DescribeHeapAddress(addr, 1);\n+}\n+\n+void ReportStringFunctionMemoryRangesOverlap(\n+    const char *function, const char *offset1, uptr length1,\n+    const char *offset2, uptr length2, StackTrace *stack) {\n+  ScopedInErrorReport in_report;\n+  Report(\"ERROR: AddressSanitizer %s-param-overlap: \"\n+             \"memory ranges [%p,%p) and [%p, %p) overlap\\n\", \\\n+             function, offset1, offset1 + length1, offset2, offset2 + length2);\n+  PrintStack(stack);\n+  DescribeAddress((uptr)offset1, length1);\n+  DescribeAddress((uptr)offset2, length2);\n+}\n+\n+// ----------------------- Mac-specific reports ----------------- {{{1\n+\n+void WarnMacFreeUnallocated(\n+    uptr addr, uptr zone_ptr, const char *zone_name, StackTrace *stack) {\n+  // Just print a warning here.\n+  Printf(\"free_common(%p) -- attempting to free unallocated memory.\\n\"\n+             \"AddressSanitizer is ignoring this error on Mac OS now.\\n\",\n+             addr);\n+  PrintZoneForPointer(addr, zone_ptr, zone_name);\n+  PrintStack(stack);\n+  DescribeHeapAddress(addr, 1);\n+}\n+\n+void ReportMacMzReallocUnknown(\n+    uptr addr, uptr zone_ptr, const char *zone_name, StackTrace *stack) {\n+  ScopedInErrorReport in_report;\n+  Printf(\"mz_realloc(%p) -- attempting to realloc unallocated memory.\\n\"\n+             \"This is an unrecoverable problem, exiting now.\\n\",\n+             addr);\n+  PrintZoneForPointer(addr, zone_ptr, zone_name);\n+  PrintStack(stack);\n+  DescribeHeapAddress(addr, 1);\n+}\n+\n+void ReportMacCfReallocUnknown(\n+    uptr addr, uptr zone_ptr, const char *zone_name, StackTrace *stack) {\n+  ScopedInErrorReport in_report;\n+  Printf(\"cf_realloc(%p) -- attempting to realloc unallocated memory.\\n\"\n+             \"This is an unrecoverable problem, exiting now.\\n\",\n+             addr);\n+  PrintZoneForPointer(addr, zone_ptr, zone_name);\n+  PrintStack(stack);\n+  DescribeHeapAddress(addr, 1);\n+}\n+\n+}  // namespace __asan\n+\n+// --------------------------- Interface --------------------- {{{1\n+using namespace __asan;  // NOLINT\n+\n+void __asan_report_error(uptr pc, uptr bp, uptr sp,\n+                         uptr addr, bool is_write, uptr access_size) {\n+  ScopedInErrorReport in_report;\n+\n+  // Determine the error type.\n+  const char *bug_descr = \"unknown-crash\";\n+  if (AddrIsInMem(addr)) {\n+    u8 *shadow_addr = (u8*)MemToShadow(addr);\n+    // If we are accessing 16 bytes, look at the second shadow byte.\n+    if (*shadow_addr == 0 && access_size > SHADOW_GRANULARITY)\n+      shadow_addr++;\n+    // If we are in the partial right redzone, look at the next shadow byte.\n+    if (*shadow_addr > 0 && *shadow_addr < 128)\n+      shadow_addr++;\n+    switch (*shadow_addr) {\n+      case kAsanHeapLeftRedzoneMagic:\n+      case kAsanHeapRightRedzoneMagic:\n+        bug_descr = \"heap-buffer-overflow\";\n+        break;\n+      case kAsanHeapFreeMagic:\n+        bug_descr = \"heap-use-after-free\";\n+        break;\n+      case kAsanStackLeftRedzoneMagic:\n+        bug_descr = \"stack-buffer-underflow\";\n+        break;\n+      case kAsanInitializationOrderMagic:\n+        bug_descr = \"initialization-order-fiasco\";\n+        break;\n+      case kAsanStackMidRedzoneMagic:\n+      case kAsanStackRightRedzoneMagic:\n+      case kAsanStackPartialRedzoneMagic:\n+        bug_descr = \"stack-buffer-overflow\";\n+        break;\n+      case kAsanStackAfterReturnMagic:\n+        bug_descr = \"stack-use-after-return\";\n+        break;\n+      case kAsanUserPoisonedMemoryMagic:\n+        bug_descr = \"use-after-poison\";\n+        break;\n+      case kAsanGlobalRedzoneMagic:\n+        bug_descr = \"global-buffer-overflow\";\n+        break;\n+    }\n+  }\n+\n+  Report(\"ERROR: AddressSanitizer %s on address \"\n+             \"%p at pc 0x%zx bp 0x%zx sp 0x%zx\\n\",\n+             bug_descr, (void*)addr, pc, bp, sp);\n+\n+  u32 curr_tid = asanThreadRegistry().GetCurrentTidOrInvalid();\n+  Printf(\"%s of size %zu at %p thread T%d\\n\",\n+             access_size ? (is_write ? \"WRITE\" : \"READ\") : \"ACCESS\",\n+             access_size, (void*)addr, curr_tid);\n+\n+  GET_STACK_TRACE_WITH_PC_AND_BP(kStackTraceMax, pc, bp);\n+  PrintStack(&stack);\n+\n+  DescribeAddress(addr, access_size);\n+\n+  PrintShadowMemoryForAddress(addr);\n+}\n+\n+void NOINLINE __asan_set_error_report_callback(void (*callback)(const char*)) {\n+  error_report_callback = callback;\n+  if (callback) {\n+    error_message_buffer_size = 1 << 16;\n+    error_message_buffer =\n+        (char*)MmapOrDie(error_message_buffer_size, __FUNCTION__);\n+    error_message_buffer_pos = 0;\n+  }\n+}\n+\n+// Provide default implementation of __asan_on_error that does nothing\n+// and may be overriden by user.\n+SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE NOINLINE\n+void __asan_on_error() {}"}, {"sha": "9710bd7968ea11577cefc688a928b41beb5d91ef", "filename": "libsanitizer/asan/asan_report.h", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_report.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_report.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_report.h?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,51 @@\n+//===-- asan_report.h -------------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// ASan-private header for error reporting functions.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"asan_internal.h\"\n+#include \"asan_thread.h\"\n+#include \"sanitizer/asan_interface.h\"\n+\n+namespace __asan {\n+\n+// The following functions prints address description depending\n+// on the memory type (shadow/heap/stack/global).\n+void DescribeHeapAddress(uptr addr, uptr access_size);\n+bool DescribeAddressIfGlobal(uptr addr);\n+bool DescribeAddressRelativeToGlobal(uptr addr, const __asan_global &g);\n+bool DescribeAddressIfShadow(uptr addr);\n+bool DescribeAddressIfStack(uptr addr, uptr access_size);\n+// Determines memory type on its own.\n+void DescribeAddress(uptr addr, uptr access_size);\n+\n+void DescribeThread(AsanThreadSummary *summary);\n+\n+// Different kinds of error reports.\n+void NORETURN ReportSIGSEGV(uptr pc, uptr sp, uptr bp, uptr addr);\n+void NORETURN ReportDoubleFree(uptr addr, StackTrace *stack);\n+void NORETURN ReportFreeNotMalloced(uptr addr, StackTrace *stack);\n+void NORETURN ReportMallocUsableSizeNotOwned(uptr addr,\n+                                             StackTrace *stack);\n+void NORETURN ReportAsanGetAllocatedSizeNotOwned(uptr addr,\n+                                                 StackTrace *stack);\n+void NORETURN ReportStringFunctionMemoryRangesOverlap(\n+    const char *function, const char *offset1, uptr length1,\n+    const char *offset2, uptr length2, StackTrace *stack);\n+\n+// Mac-specific errors and warnings.\n+void WarnMacFreeUnallocated(\n+    uptr addr, uptr zone_ptr, const char *zone_name, StackTrace *stack);\n+void NORETURN ReportMacMzReallocUnknown(\n+    uptr addr, uptr zone_ptr, const char *zone_name, StackTrace *stack);\n+void NORETURN ReportMacCfReallocUnknown(\n+    uptr addr, uptr zone_ptr, const char *zone_name, StackTrace *stack);\n+\n+}  // namespace __asan"}, {"sha": "442d41c4f23c889c4f546161e48cdf207adb4f6d", "filename": "libsanitizer/asan/asan_rtl.cc", "status": "added", "additions": 404, "deletions": 0, "changes": 404, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_rtl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_rtl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_rtl.cc?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,404 @@\n+//===-- asan_rtl.cc -------------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// Main file of the ASan run-time library.\n+//===----------------------------------------------------------------------===//\n+#include \"asan_allocator.h\"\n+#include \"asan_interceptors.h\"\n+#include \"asan_internal.h\"\n+#include \"asan_lock.h\"\n+#include \"asan_mapping.h\"\n+#include \"asan_report.h\"\n+#include \"asan_stack.h\"\n+#include \"asan_stats.h\"\n+#include \"asan_thread.h\"\n+#include \"asan_thread_registry.h\"\n+#include \"sanitizer/asan_interface.h\"\n+#include \"sanitizer_common/sanitizer_atomic.h\"\n+#include \"sanitizer_common/sanitizer_flags.h\"\n+#include \"sanitizer_common/sanitizer_libc.h\"\n+#include \"sanitizer_common/sanitizer_symbolizer.h\"\n+\n+namespace __asan {\n+\n+static void AsanDie() {\n+  static atomic_uint32_t num_calls;\n+  if (atomic_fetch_add(&num_calls, 1, memory_order_relaxed) != 0) {\n+    // Don't die twice - run a busy loop.\n+    while (1) { }\n+  }\n+  if (flags()->sleep_before_dying) {\n+    Report(\"Sleeping for %d second(s)\\n\", flags()->sleep_before_dying);\n+    SleepForSeconds(flags()->sleep_before_dying);\n+  }\n+  if (flags()->unmap_shadow_on_exit)\n+    UnmapOrDie((void*)kLowShadowBeg, kHighShadowEnd - kLowShadowBeg);\n+  if (death_callback)\n+    death_callback();\n+  if (flags()->abort_on_error)\n+    Abort();\n+  Exit(flags()->exitcode);\n+}\n+\n+static void AsanCheckFailed(const char *file, int line, const char *cond,\n+                            u64 v1, u64 v2) {\n+  Report(\"AddressSanitizer CHECK failed: %s:%d \\\"%s\\\" (0x%zx, 0x%zx)\\n\",\n+             file, line, cond, (uptr)v1, (uptr)v2);\n+  // FIXME: check for infinite recursion without a thread-local counter here.\n+  PRINT_CURRENT_STACK();\n+  ShowStatsAndAbort();\n+}\n+\n+// -------------------------- Flags ------------------------- {{{1\n+static const int kDeafultMallocContextSize = 30;\n+\n+static Flags asan_flags;\n+\n+Flags *flags() {\n+  return &asan_flags;\n+}\n+\n+static void ParseFlagsFromString(Flags *f, const char *str) {\n+  ParseFlag(str, &f->quarantine_size, \"quarantine_size\");\n+  ParseFlag(str, &f->symbolize, \"symbolize\");\n+  ParseFlag(str, &f->verbosity, \"verbosity\");\n+  ParseFlag(str, &f->redzone, \"redzone\");\n+  CHECK(f->redzone >= 16);\n+  CHECK(IsPowerOfTwo(f->redzone));\n+\n+  ParseFlag(str, &f->debug, \"debug\");\n+  ParseFlag(str, &f->report_globals, \"report_globals\");\n+  ParseFlag(str, &f->check_initialization_order, \"initialization_order\");\n+  ParseFlag(str, &f->malloc_context_size, \"malloc_context_size\");\n+  CHECK((uptr)f->malloc_context_size <= kStackTraceMax);\n+\n+  ParseFlag(str, &f->replace_str, \"replace_str\");\n+  ParseFlag(str, &f->replace_intrin, \"replace_intrin\");\n+  ParseFlag(str, &f->replace_cfallocator, \"replace_cfallocator\");\n+  ParseFlag(str, &f->mac_ignore_invalid_free, \"mac_ignore_invalid_free\");\n+  ParseFlag(str, &f->use_fake_stack, \"use_fake_stack\");\n+  ParseFlag(str, &f->max_malloc_fill_size, \"max_malloc_fill_size\");\n+  ParseFlag(str, &f->exitcode, \"exitcode\");\n+  ParseFlag(str, &f->allow_user_poisoning, \"allow_user_poisoning\");\n+  ParseFlag(str, &f->sleep_before_dying, \"sleep_before_dying\");\n+  ParseFlag(str, &f->handle_segv, \"handle_segv\");\n+  ParseFlag(str, &f->use_sigaltstack, \"use_sigaltstack\");\n+  ParseFlag(str, &f->check_malloc_usable_size, \"check_malloc_usable_size\");\n+  ParseFlag(str, &f->unmap_shadow_on_exit, \"unmap_shadow_on_exit\");\n+  ParseFlag(str, &f->abort_on_error, \"abort_on_error\");\n+  ParseFlag(str, &f->atexit, \"atexit\");\n+  ParseFlag(str, &f->disable_core, \"disable_core\");\n+  ParseFlag(str, &f->strip_path_prefix, \"strip_path_prefix\");\n+  ParseFlag(str, &f->allow_reexec, \"allow_reexec\");\n+  ParseFlag(str, &f->print_full_thread_history, \"print_full_thread_history\");\n+  ParseFlag(str, &f->log_path, \"log_path\");\n+}\n+\n+extern \"C\" {\n+SANITIZER_WEAK_ATTRIBUTE\n+SANITIZER_INTERFACE_ATTRIBUTE\n+const char* __asan_default_options() { return \"\"; }\n+}  // extern \"C\"\n+\n+void InitializeFlags(Flags *f, const char *env) {\n+  internal_memset(f, 0, sizeof(*f));\n+\n+  f->quarantine_size = (ASAN_LOW_MEMORY) ? 1UL << 26 : 1UL << 28;\n+  f->symbolize = false;\n+  f->verbosity = 0;\n+  f->redzone = (ASAN_LOW_MEMORY) ? 64 : 128;\n+  f->debug = false;\n+  f->report_globals = 1;\n+  f->check_initialization_order = true;\n+  f->malloc_context_size = kDeafultMallocContextSize;\n+  f->replace_str = true;\n+  f->replace_intrin = true;\n+  f->replace_cfallocator = true;\n+  f->mac_ignore_invalid_free = false;\n+  f->use_fake_stack = true;\n+  f->max_malloc_fill_size = 0;\n+  f->exitcode = ASAN_DEFAULT_FAILURE_EXITCODE;\n+  f->allow_user_poisoning = true;\n+  f->sleep_before_dying = 0;\n+  f->handle_segv = ASAN_NEEDS_SEGV;\n+  f->use_sigaltstack = false;\n+  f->check_malloc_usable_size = true;\n+  f->unmap_shadow_on_exit = false;\n+  f->abort_on_error = false;\n+  f->atexit = false;\n+  f->disable_core = (__WORDSIZE == 64);\n+  f->strip_path_prefix = \"\";\n+  f->allow_reexec = true;\n+  f->print_full_thread_history = true;\n+  f->log_path = 0;\n+\n+  // Override from user-specified string.\n+  ParseFlagsFromString(f, __asan_default_options());\n+  if (flags()->verbosity) {\n+    Report(\"Using the defaults from __asan_default_options: %s\\n\",\n+           __asan_default_options());\n+  }\n+\n+  // Override from command line.\n+  ParseFlagsFromString(f, env);\n+}\n+\n+// -------------------------- Globals --------------------- {{{1\n+int asan_inited;\n+bool asan_init_is_running;\n+void (*death_callback)(void);\n+\n+// -------------------------- Misc ---------------- {{{1\n+void ShowStatsAndAbort() {\n+  __asan_print_accumulated_stats();\n+  Die();\n+}\n+\n+// ---------------------- mmap -------------------- {{{1\n+// Reserve memory range [beg, end].\n+static void ReserveShadowMemoryRange(uptr beg, uptr end) {\n+  CHECK((beg % kPageSize) == 0);\n+  CHECK(((end + 1) % kPageSize) == 0);\n+  uptr size = end - beg + 1;\n+  void *res = MmapFixedNoReserve(beg, size);\n+  if (res != (void*)beg) {\n+    Report(\"ReserveShadowMemoryRange failed while trying to map 0x%zx bytes. \"\n+           \"Perhaps you're using ulimit -v\\n\", size);\n+    Abort();\n+  }\n+}\n+\n+// --------------- LowLevelAllocateCallbac ---------- {{{1\n+static void OnLowLevelAllocate(uptr ptr, uptr size) {\n+  PoisonShadow(ptr, size, kAsanInternalHeapMagic);\n+}\n+\n+// -------------------------- Run-time entry ------------------- {{{1\n+// exported functions\n+#define ASAN_REPORT_ERROR(type, is_write, size)                     \\\n+extern \"C\" NOINLINE INTERFACE_ATTRIBUTE                        \\\n+void __asan_report_ ## type ## size(uptr addr);                \\\n+void __asan_report_ ## type ## size(uptr addr) {               \\\n+  GET_CALLER_PC_BP_SP;                                              \\\n+  __asan_report_error(pc, bp, sp, addr, is_write, size);            \\\n+}\n+\n+ASAN_REPORT_ERROR(load, false, 1)\n+ASAN_REPORT_ERROR(load, false, 2)\n+ASAN_REPORT_ERROR(load, false, 4)\n+ASAN_REPORT_ERROR(load, false, 8)\n+ASAN_REPORT_ERROR(load, false, 16)\n+ASAN_REPORT_ERROR(store, true, 1)\n+ASAN_REPORT_ERROR(store, true, 2)\n+ASAN_REPORT_ERROR(store, true, 4)\n+ASAN_REPORT_ERROR(store, true, 8)\n+ASAN_REPORT_ERROR(store, true, 16)\n+\n+// Force the linker to keep the symbols for various ASan interface functions.\n+// We want to keep those in the executable in order to let the instrumented\n+// dynamic libraries access the symbol even if it is not used by the executable\n+// itself. This should help if the build system is removing dead code at link\n+// time.\n+static NOINLINE void force_interface_symbols() {\n+  volatile int fake_condition = 0;  // prevent dead condition elimination.\n+  // __asan_report_* functions are noreturn, so we need a switch to prevent\n+  // the compiler from removing any of them.\n+  switch (fake_condition) {\n+    case 1: __asan_report_load1(0); break;\n+    case 2: __asan_report_load2(0); break;\n+    case 3: __asan_report_load4(0); break;\n+    case 4: __asan_report_load8(0); break;\n+    case 5: __asan_report_load16(0); break;\n+    case 6: __asan_report_store1(0); break;\n+    case 7: __asan_report_store2(0); break;\n+    case 8: __asan_report_store4(0); break;\n+    case 9: __asan_report_store8(0); break;\n+    case 10: __asan_report_store16(0); break;\n+    case 11: __asan_register_global(0, 0, 0); break;\n+    case 12: __asan_register_globals(0, 0); break;\n+    case 13: __asan_unregister_globals(0, 0); break;\n+    case 14: __asan_set_death_callback(0); break;\n+    case 15: __asan_set_error_report_callback(0); break;\n+    case 16: __asan_handle_no_return(); break;\n+    case 17: __asan_address_is_poisoned(0); break;\n+    case 18: __asan_get_allocated_size(0); break;\n+    case 19: __asan_get_current_allocated_bytes(); break;\n+    case 20: __asan_get_estimated_allocated_size(0); break;\n+    case 21: __asan_get_free_bytes(); break;\n+    case 22: __asan_get_heap_size(); break;\n+    case 23: __asan_get_ownership(0); break;\n+    case 24: __asan_get_unmapped_bytes(); break;\n+    case 25: __asan_poison_memory_region(0, 0); break;\n+    case 26: __asan_unpoison_memory_region(0, 0); break;\n+    case 27: __asan_set_error_exit_code(0); break;\n+    case 28: __asan_stack_free(0, 0, 0); break;\n+    case 29: __asan_stack_malloc(0, 0); break;\n+    case 30: __asan_on_error(); break;\n+    case 31: __asan_default_options(); break;\n+    case 32: __asan_before_dynamic_init(0, 0); break;\n+    case 33: __asan_after_dynamic_init(); break;\n+    case 34: __asan_malloc_hook(0, 0); break;\n+    case 35: __asan_free_hook(0); break;\n+    case 36: __asan_symbolize(0, 0, 0); break;\n+  }\n+}\n+\n+static void asan_atexit() {\n+  Printf(\"AddressSanitizer exit stats:\\n\");\n+  __asan_print_accumulated_stats();\n+}\n+\n+}  // namespace __asan\n+\n+// ---------------------- Interface ---------------- {{{1\n+using namespace __asan;  // NOLINT\n+\n+int NOINLINE __asan_set_error_exit_code(int exit_code) {\n+  int old = flags()->exitcode;\n+  flags()->exitcode = exit_code;\n+  return old;\n+}\n+\n+void NOINLINE __asan_handle_no_return() {\n+  int local_stack;\n+  AsanThread *curr_thread = asanThreadRegistry().GetCurrent();\n+  CHECK(curr_thread);\n+  uptr top = curr_thread->stack_top();\n+  uptr bottom = ((uptr)&local_stack - kPageSize) & ~(kPageSize-1);\n+  PoisonShadow(bottom, top - bottom, 0);\n+}\n+\n+void NOINLINE __asan_set_death_callback(void (*callback)(void)) {\n+  death_callback = callback;\n+}\n+\n+void __asan_init() {\n+  if (asan_inited) return;\n+  CHECK(!asan_init_is_running && \"ASan init calls itself!\");\n+  asan_init_is_running = true;\n+\n+  // Make sure we are not statically linked.\n+  AsanDoesNotSupportStaticLinkage();\n+\n+  // Install tool-specific callbacks in sanitizer_common.\n+  SetDieCallback(AsanDie);\n+  SetCheckFailedCallback(AsanCheckFailed);\n+  SetPrintfAndReportCallback(AppendToErrorMessageBuffer);\n+\n+  // Initialize flags. This must be done early, because most of the\n+  // initialization steps look at flags().\n+  const char *options = GetEnv(\"ASAN_OPTIONS\");\n+  InitializeFlags(flags(), options);\n+  __sanitizer_set_report_path(flags()->log_path);\n+\n+  if (flags()->verbosity && options) {\n+    Report(\"Parsed ASAN_OPTIONS: %s\\n\", options);\n+  }\n+\n+  // Re-exec ourselves if we need to set additional env or command line args.\n+  MaybeReexec();\n+\n+  // Setup internal allocator callback.\n+  SetLowLevelAllocateCallback(OnLowLevelAllocate);\n+\n+  if (flags()->atexit) {\n+    Atexit(asan_atexit);\n+  }\n+\n+  // interceptors\n+  InitializeAsanInterceptors();\n+\n+  ReplaceSystemMalloc();\n+  ReplaceOperatorsNewAndDelete();\n+\n+  if (flags()->verbosity) {\n+    Printf(\"|| `[%p, %p]` || HighMem    ||\\n\",\n+           (void*)kHighMemBeg, (void*)kHighMemEnd);\n+    Printf(\"|| `[%p, %p]` || HighShadow ||\\n\",\n+           (void*)kHighShadowBeg, (void*)kHighShadowEnd);\n+    Printf(\"|| `[%p, %p]` || ShadowGap  ||\\n\",\n+           (void*)kShadowGapBeg, (void*)kShadowGapEnd);\n+    Printf(\"|| `[%p, %p]` || LowShadow  ||\\n\",\n+           (void*)kLowShadowBeg, (void*)kLowShadowEnd);\n+    Printf(\"|| `[%p, %p]` || LowMem     ||\\n\",\n+           (void*)kLowMemBeg, (void*)kLowMemEnd);\n+    Printf(\"MemToShadow(shadow): %p %p %p %p\\n\",\n+           (void*)MEM_TO_SHADOW(kLowShadowBeg),\n+           (void*)MEM_TO_SHADOW(kLowShadowEnd),\n+           (void*)MEM_TO_SHADOW(kHighShadowBeg),\n+           (void*)MEM_TO_SHADOW(kHighShadowEnd));\n+    Printf(\"red_zone=%zu\\n\", (uptr)flags()->redzone);\n+    Printf(\"malloc_context_size=%zu\\n\", (uptr)flags()->malloc_context_size);\n+\n+    Printf(\"SHADOW_SCALE: %zx\\n\", (uptr)SHADOW_SCALE);\n+    Printf(\"SHADOW_GRANULARITY: %zx\\n\", (uptr)SHADOW_GRANULARITY);\n+    Printf(\"SHADOW_OFFSET: %zx\\n\", (uptr)SHADOW_OFFSET);\n+    CHECK(SHADOW_SCALE >= 3 && SHADOW_SCALE <= 7);\n+  }\n+\n+  if (flags()->disable_core) {\n+    DisableCoreDumper();\n+  }\n+\n+  uptr shadow_start = kLowShadowBeg;\n+  if (kLowShadowBeg > 0) shadow_start -= kMmapGranularity;\n+  uptr shadow_end = kHighShadowEnd;\n+  if (MemoryRangeIsAvailable(shadow_start, shadow_end)) {\n+    if (kLowShadowBeg != kLowShadowEnd) {\n+      // mmap the low shadow plus at least one page.\n+      ReserveShadowMemoryRange(kLowShadowBeg - kMmapGranularity, kLowShadowEnd);\n+    }\n+    // mmap the high shadow.\n+    ReserveShadowMemoryRange(kHighShadowBeg, kHighShadowEnd);\n+    // protect the gap\n+    void *prot = Mprotect(kShadowGapBeg, kShadowGapEnd - kShadowGapBeg + 1);\n+    CHECK(prot == (void*)kShadowGapBeg);\n+  } else {\n+    Report(\"Shadow memory range interleaves with an existing memory mapping. \"\n+           \"ASan cannot proceed correctly. ABORTING.\\n\");\n+    DumpProcessMap();\n+    Die();\n+  }\n+\n+  InstallSignalHandlers();\n+  // Start symbolizer process if necessary.\n+  if (flags()->symbolize) {\n+    const char *external_symbolizer = GetEnv(\"ASAN_SYMBOLIZER_PATH\");\n+    if (external_symbolizer) {\n+      InitializeExternalSymbolizer(external_symbolizer);\n+    }\n+  }\n+\n+  // On Linux AsanThread::ThreadStart() calls malloc() that's why asan_inited\n+  // should be set to 1 prior to initializing the threads.\n+  asan_inited = 1;\n+  asan_init_is_running = false;\n+\n+  asanThreadRegistry().Init();\n+  asanThreadRegistry().GetMain()->ThreadStart();\n+  force_interface_symbols();  // no-op.\n+\n+  if (flags()->verbosity) {\n+    Report(\"AddressSanitizer Init done\\n\");\n+  }\n+}\n+\n+#if defined(ASAN_USE_PREINIT_ARRAY)\n+  // On Linux, we force __asan_init to be called before anyone else\n+  // by placing it into .preinit_array section.\n+  // FIXME: do we have anything like this on Mac?\n+  __attribute__((section(\".preinit_array\")))\n+    typeof(__asan_init) *__asan_preinit =__asan_init;\n+#elif defined(_WIN32) && defined(_DLL)\n+  // On Windows, when using dynamic CRT (/MD), we can put a pointer\n+  // to __asan_init into the global list of C initializers.\n+  // See crt0dat.c in the CRT sources for the details.\n+  #pragma section(\".CRT$XIB\", long, read)  // NOLINT\n+  __declspec(allocate(\".CRT$XIB\")) void (*__asan_preinit)() = __asan_init;\n+#endif"}, {"sha": "2531a7f9df800193ca7c90b6b1094d360e7e77c0", "filename": "libsanitizer/asan/asan_stack.cc", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_stack.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_stack.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_stack.cc?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,35 @@\n+//===-- asan_stack.cc -----------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// Code for ASan stack trace.\n+//===----------------------------------------------------------------------===//\n+#include \"asan_flags.h\"\n+#include \"asan_stack.h\"\n+#include \"sanitizer/asan_interface.h\"\n+\n+namespace __asan {\n+\n+void PrintStack(StackTrace *stack) {\n+  stack->PrintStack(stack->trace, stack->size, flags()->symbolize,\n+                    flags()->strip_path_prefix, __asan_symbolize);\n+}\n+\n+}  // namespace __asan\n+\n+// ------------------ Interface -------------- {{{1\n+\n+// Provide default implementation of __asan_symbolize that does nothing\n+// and may be overriden by user if he wants to use his own symbolization.\n+// ASan on Windows has its own implementation of this.\n+#ifndef _WIN32\n+SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE NOINLINE\n+bool __asan_symbolize(const void *pc, char *out_buffer, int out_size) {\n+  return false;\n+}\n+#endif"}, {"sha": "da622ed8eec0fb5e97a22679447909806c6a3196", "filename": "libsanitizer/asan/asan_stack.h", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_stack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_stack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_stack.h?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,52 @@\n+//===-- asan_stack.h --------------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// ASan-private header for asan_stack.cc.\n+//===----------------------------------------------------------------------===//\n+#ifndef ASAN_STACK_H\n+#define ASAN_STACK_H\n+\n+#include \"sanitizer_common/sanitizer_stacktrace.h\"\n+\n+namespace __asan {\n+\n+void GetStackTrace(StackTrace *stack, uptr max_s, uptr pc, uptr bp);\n+void PrintStack(StackTrace *stack);\n+\n+}  // namespace __asan\n+\n+// Get the stack trace with the given pc and bp.\n+// The pc will be in the position 0 of the resulting stack trace.\n+// The bp may refer to the current frame or to the caller's frame.\n+// fast_unwind is currently unused.\n+#define GET_STACK_TRACE_WITH_PC_AND_BP(max_s, pc, bp)               \\\n+  StackTrace stack;                                             \\\n+  GetStackTrace(&stack, max_s, pc, bp)\n+\n+// NOTE: A Rule of thumb is to retrieve stack trace in the interceptors\n+// as early as possible (in functions exposed to the user), as we generally\n+// don't want stack trace to contain functions from ASan internals.\n+\n+#define GET_STACK_TRACE_HERE(max_size)                        \\\n+  GET_STACK_TRACE_WITH_PC_AND_BP(max_size,                    \\\n+      StackTrace::GetCurrentPc(), GET_CURRENT_FRAME())\n+\n+#define GET_STACK_TRACE_HERE_FOR_MALLOC                             \\\n+  GET_STACK_TRACE_HERE(flags()->malloc_context_size)\n+\n+#define GET_STACK_TRACE_HERE_FOR_FREE(ptr)                          \\\n+  GET_STACK_TRACE_HERE(flags()->malloc_context_size)\n+\n+#define PRINT_CURRENT_STACK()                    \\\n+  {                                              \\\n+    GET_STACK_TRACE_HERE(kStackTraceMax);        \\\n+    PrintStack(&stack);                          \\\n+  }\n+\n+#endif  // ASAN_STACK_H"}, {"sha": "fa4adcb7f9aaabce1ee326ef0c5c404875c0fa78", "filename": "libsanitizer/asan/asan_stats.cc", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_stats.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_stats.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_stats.cc?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,86 @@\n+//===-- asan_stats.cc -----------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// Code related to statistics collected by AddressSanitizer.\n+//===----------------------------------------------------------------------===//\n+#include \"asan_interceptors.h\"\n+#include \"asan_internal.h\"\n+#include \"asan_lock.h\"\n+#include \"asan_stats.h\"\n+#include \"asan_thread_registry.h\"\n+#include \"sanitizer/asan_interface.h\"\n+\n+namespace __asan {\n+\n+AsanStats::AsanStats() {\n+  CHECK(REAL(memset) != 0);\n+  REAL(memset)(this, 0, sizeof(AsanStats));\n+}\n+\n+static void PrintMallocStatsArray(const char *prefix,\n+                                  uptr (&array)[kNumberOfSizeClasses]) {\n+  Printf(\"%s\", prefix);\n+  for (uptr i = 0; i < kNumberOfSizeClasses; i++) {\n+    if (!array[i]) continue;\n+    Printf(\"%zu:%zu; \", i, array[i]);\n+  }\n+  Printf(\"\\n\");\n+}\n+\n+void AsanStats::Print() {\n+  Printf(\"Stats: %zuM malloced (%zuM for red zones) by %zu calls\\n\",\n+             malloced>>20, malloced_redzones>>20, mallocs);\n+  Printf(\"Stats: %zuM realloced by %zu calls\\n\", realloced>>20, reallocs);\n+  Printf(\"Stats: %zuM freed by %zu calls\\n\", freed>>20, frees);\n+  Printf(\"Stats: %zuM really freed by %zu calls\\n\",\n+             really_freed>>20, real_frees);\n+  Printf(\"Stats: %zuM (%zu full pages) mmaped in %zu calls\\n\",\n+             mmaped>>20, mmaped / kPageSize, mmaps);\n+\n+  PrintMallocStatsArray(\"  mmaps   by size class: \", mmaped_by_size);\n+  PrintMallocStatsArray(\"  mallocs by size class: \", malloced_by_size);\n+  PrintMallocStatsArray(\"  frees   by size class: \", freed_by_size);\n+  PrintMallocStatsArray(\"  rfrees  by size class: \", really_freed_by_size);\n+  Printf(\"Stats: malloc large: %zu small slow: %zu\\n\",\n+             malloc_large, malloc_small_slow);\n+}\n+\n+static AsanLock print_lock(LINKER_INITIALIZED);\n+\n+static void PrintAccumulatedStats() {\n+  AsanStats stats = asanThreadRegistry().GetAccumulatedStats();\n+  // Use lock to keep reports from mixing up.\n+  ScopedLock lock(&print_lock);\n+  stats.Print();\n+}\n+\n+}  // namespace __asan\n+\n+// ---------------------- Interface ---------------- {{{1\n+using namespace __asan;  // NOLINT\n+\n+uptr __asan_get_current_allocated_bytes() {\n+  return asanThreadRegistry().GetCurrentAllocatedBytes();\n+}\n+\n+uptr __asan_get_heap_size() {\n+  return asanThreadRegistry().GetHeapSize();\n+}\n+\n+uptr __asan_get_free_bytes() {\n+  return asanThreadRegistry().GetFreeBytes();\n+}\n+\n+uptr __asan_get_unmapped_bytes() {\n+  return 0;\n+}\n+\n+void __asan_print_accumulated_stats() {\n+  PrintAccumulatedStats();\n+}"}, {"sha": "c2b3298266b9f62729ba6396e11353d55edbd9b0", "filename": "libsanitizer/asan/asan_stats.h", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_stats.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_stats.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_stats.h?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,65 @@\n+//===-- asan_stats.h --------------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// ASan-private header for statistics.\n+//===----------------------------------------------------------------------===//\n+#ifndef ASAN_STATS_H\n+#define ASAN_STATS_H\n+\n+#include \"asan_allocator.h\"\n+#include \"asan_internal.h\"\n+\n+namespace __asan {\n+\n+// AsanStats struct is NOT thread-safe.\n+// Each AsanThread has its own AsanStats, which are sometimes flushed\n+// to the accumulated AsanStats.\n+struct AsanStats {\n+  // AsanStats must be a struct consisting of uptr fields only.\n+  // When merging two AsanStats structs, we treat them as arrays of uptr.\n+  uptr mallocs;\n+  uptr malloced;\n+  uptr malloced_redzones;\n+  uptr frees;\n+  uptr freed;\n+  uptr real_frees;\n+  uptr really_freed;\n+  uptr really_freed_redzones;\n+  uptr reallocs;\n+  uptr realloced;\n+  uptr mmaps;\n+  uptr mmaped;\n+  uptr mmaped_by_size[kNumberOfSizeClasses];\n+  uptr malloced_by_size[kNumberOfSizeClasses];\n+  uptr freed_by_size[kNumberOfSizeClasses];\n+  uptr really_freed_by_size[kNumberOfSizeClasses];\n+\n+  uptr malloc_large;\n+  uptr malloc_small_slow;\n+\n+  // Ctor for global AsanStats (accumulated stats and main thread stats).\n+  explicit AsanStats(LinkerInitialized) { }\n+  // Default ctor for thread-local stats.\n+  AsanStats();\n+\n+  // Prints formatted stats to stderr.\n+  void Print();\n+};\n+\n+// A cross-platform equivalent of malloc_statistics_t on Mac OS.\n+struct AsanMallocStats {\n+  uptr blocks_in_use;\n+  uptr size_in_use;\n+  uptr max_size_in_use;\n+  uptr size_allocated;\n+};\n+\n+}  // namespace __asan\n+\n+#endif  // ASAN_STATS_H"}, {"sha": "9295c1570ecf9f611daab53e91950ea9f14f7401", "filename": "libsanitizer/asan/asan_thread.cc", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_thread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_thread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_thread.cc?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,153 @@\n+//===-- asan_thread.cc ----------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// Thread-related code.\n+//===----------------------------------------------------------------------===//\n+#include \"asan_allocator.h\"\n+#include \"asan_interceptors.h\"\n+#include \"asan_stack.h\"\n+#include \"asan_thread.h\"\n+#include \"asan_thread_registry.h\"\n+#include \"asan_mapping.h\"\n+#include \"sanitizer_common/sanitizer_common.h\"\n+\n+namespace __asan {\n+\n+AsanThread::AsanThread(LinkerInitialized x)\n+    : fake_stack_(x),\n+      malloc_storage_(x),\n+      stats_(x) { }\n+\n+AsanThread *AsanThread::Create(u32 parent_tid, thread_callback_t start_routine,\n+                               void *arg, StackTrace *stack) {\n+  uptr size = RoundUpTo(sizeof(AsanThread), kPageSize);\n+  AsanThread *thread = (AsanThread*)MmapOrDie(size, __FUNCTION__);\n+  thread->start_routine_ = start_routine;\n+  thread->arg_ = arg;\n+\n+  const uptr kSummaryAllocSize = kPageSize;\n+  CHECK_LE(sizeof(AsanThreadSummary), kSummaryAllocSize);\n+  AsanThreadSummary *summary =\n+      (AsanThreadSummary*)MmapOrDie(kPageSize, \"AsanThreadSummary\");\n+  summary->Init(parent_tid, stack);\n+  summary->set_thread(thread);\n+  thread->set_summary(summary);\n+\n+  return thread;\n+}\n+\n+void AsanThreadSummary::TSDDtor(void *tsd) {\n+  AsanThreadSummary *summary = (AsanThreadSummary*)tsd;\n+  if (flags()->verbosity >= 1) {\n+    Report(\"T%d TSDDtor\\n\", summary->tid());\n+  }\n+  if (summary->thread()) {\n+    summary->thread()->Destroy();\n+  }\n+}\n+\n+void AsanThread::Destroy() {\n+  if (flags()->verbosity >= 1) {\n+    Report(\"T%d exited\\n\", tid());\n+  }\n+\n+  asanThreadRegistry().UnregisterThread(this);\n+  CHECK(summary()->thread() == 0);\n+  // We also clear the shadow on thread destruction because\n+  // some code may still be executing in later TSD destructors\n+  // and we don't want it to have any poisoned stack.\n+  ClearShadowForThreadStack();\n+  fake_stack().Cleanup();\n+  uptr size = RoundUpTo(sizeof(AsanThread), kPageSize);\n+  UnmapOrDie(this, size);\n+}\n+\n+void AsanThread::Init() {\n+  SetThreadStackTopAndBottom();\n+  CHECK(AddrIsInMem(stack_bottom_));\n+  CHECK(AddrIsInMem(stack_top_));\n+  ClearShadowForThreadStack();\n+  if (flags()->verbosity >= 1) {\n+    int local = 0;\n+    Report(\"T%d: stack [%p,%p) size 0x%zx; local=%p\\n\",\n+           tid(), (void*)stack_bottom_, (void*)stack_top_,\n+           stack_top_ - stack_bottom_, &local);\n+  }\n+  fake_stack_.Init(stack_size());\n+  AsanPlatformThreadInit();\n+}\n+\n+thread_return_t AsanThread::ThreadStart() {\n+  Init();\n+  if (flags()->use_sigaltstack) SetAlternateSignalStack();\n+\n+  if (!start_routine_) {\n+    // start_routine_ == 0 if we're on the main thread or on one of the\n+    // OS X libdispatch worker threads. But nobody is supposed to call\n+    // ThreadStart() for the worker threads.\n+    CHECK(tid() == 0);\n+    return 0;\n+  }\n+\n+  thread_return_t res = start_routine_(arg_);\n+  malloc_storage().CommitBack();\n+  if (flags()->use_sigaltstack) UnsetAlternateSignalStack();\n+\n+  this->Destroy();\n+\n+  return res;\n+}\n+\n+void AsanThread::SetThreadStackTopAndBottom() {\n+  GetThreadStackTopAndBottom(tid() == 0, &stack_top_, &stack_bottom_);\n+  int local;\n+  CHECK(AddrIsInStack((uptr)&local));\n+}\n+\n+void AsanThread::ClearShadowForThreadStack() {\n+  PoisonShadow(stack_bottom_, stack_top_ - stack_bottom_, 0);\n+}\n+\n+const char *AsanThread::GetFrameNameByAddr(uptr addr, uptr *offset) {\n+  uptr bottom = 0;\n+  bool is_fake_stack = false;\n+  if (AddrIsInStack(addr)) {\n+    bottom = stack_bottom();\n+  } else {\n+    bottom = fake_stack().AddrIsInFakeStack(addr);\n+    CHECK(bottom);\n+    is_fake_stack = true;\n+  }\n+  uptr aligned_addr = addr & ~(__WORDSIZE/8 - 1);  // align addr.\n+  u8 *shadow_ptr = (u8*)MemToShadow(aligned_addr);\n+  u8 *shadow_bottom = (u8*)MemToShadow(bottom);\n+\n+  while (shadow_ptr >= shadow_bottom &&\n+      *shadow_ptr != kAsanStackLeftRedzoneMagic) {\n+    shadow_ptr--;\n+  }\n+\n+  while (shadow_ptr >= shadow_bottom &&\n+      *shadow_ptr == kAsanStackLeftRedzoneMagic) {\n+    shadow_ptr--;\n+  }\n+\n+  if (shadow_ptr < shadow_bottom) {\n+    *offset = 0;\n+    return \"UNKNOWN\";\n+  }\n+\n+  uptr* ptr = (uptr*)SHADOW_TO_MEM((uptr)(shadow_ptr + 1));\n+  CHECK((ptr[0] == kCurrentStackFrameMagic) ||\n+      (is_fake_stack && ptr[0] == kRetiredStackFrameMagic));\n+  *offset = addr - (uptr)ptr;\n+  return (const char*)ptr[1];\n+}\n+\n+}  // namespace __asan"}, {"sha": "dff8c88528a11c1a74d183c2c1f5890f53bb1bfb", "filename": "libsanitizer/asan/asan_thread.h", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_thread.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_thread.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_thread.h?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,103 @@\n+//===-- asan_thread.h -------------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// ASan-private header for asan_thread.cc.\n+//===----------------------------------------------------------------------===//\n+#ifndef ASAN_THREAD_H\n+#define ASAN_THREAD_H\n+\n+#include \"asan_allocator.h\"\n+#include \"asan_internal.h\"\n+#include \"asan_stack.h\"\n+#include \"asan_stats.h\"\n+#include \"sanitizer_common/sanitizer_libc.h\"\n+\n+namespace __asan {\n+\n+const u32 kInvalidTid = 0xffffff;  // Must fit into 24 bits.\n+\n+class AsanThread;\n+\n+// These objects are created for every thread and are never deleted,\n+// so we can find them by tid even if the thread is long dead.\n+class AsanThreadSummary {\n+ public:\n+  explicit AsanThreadSummary(LinkerInitialized) { }  // for T0.\n+  void Init(u32 parent_tid, StackTrace *stack) {\n+    parent_tid_ = parent_tid;\n+    announced_ = false;\n+    tid_ = kInvalidTid;\n+    if (stack) {\n+      internal_memcpy(&stack_, stack, sizeof(*stack));\n+    }\n+    thread_ = 0;\n+  }\n+  u32 tid() { return tid_; }\n+  void set_tid(u32 tid) { tid_ = tid; }\n+  u32 parent_tid() { return parent_tid_; }\n+  bool announced() { return announced_; }\n+  void set_announced(bool announced) { announced_ = announced; }\n+  StackTrace *stack() { return &stack_; }\n+  AsanThread *thread() { return thread_; }\n+  void set_thread(AsanThread *thread) { thread_ = thread; }\n+  static void TSDDtor(void *tsd);\n+\n+ private:\n+  u32 tid_;\n+  u32 parent_tid_;\n+  bool announced_;\n+  StackTrace stack_;\n+  AsanThread *thread_;\n+};\n+\n+// AsanThread are stored in TSD and destroyed when the thread dies.\n+class AsanThread {\n+ public:\n+  explicit AsanThread(LinkerInitialized);  // for T0.\n+  static AsanThread *Create(u32 parent_tid, thread_callback_t start_routine,\n+                            void *arg, StackTrace *stack);\n+  void Destroy();\n+\n+  void Init();  // Should be called from the thread itself.\n+  thread_return_t ThreadStart();\n+\n+  uptr stack_top() { return stack_top_; }\n+  uptr stack_bottom() { return stack_bottom_; }\n+  uptr stack_size() { return stack_top_ - stack_bottom_; }\n+  u32 tid() { return summary_->tid(); }\n+  AsanThreadSummary *summary() { return summary_; }\n+  void set_summary(AsanThreadSummary *summary) { summary_ = summary; }\n+\n+  const char *GetFrameNameByAddr(uptr addr, uptr *offset);\n+\n+  bool AddrIsInStack(uptr addr) {\n+    return addr >= stack_bottom_ && addr < stack_top_;\n+  }\n+\n+  FakeStack &fake_stack() { return fake_stack_; }\n+  AsanThreadLocalMallocStorage &malloc_storage() { return malloc_storage_; }\n+  AsanStats &stats() { return stats_; }\n+\n+ private:\n+  void SetThreadStackTopAndBottom();\n+  void ClearShadowForThreadStack();\n+  AsanThreadSummary *summary_;\n+  thread_callback_t start_routine_;\n+  void *arg_;\n+  uptr  stack_top_;\n+  uptr  stack_bottom_;\n+\n+  FakeStack fake_stack_;\n+  AsanThreadLocalMallocStorage malloc_storage_;\n+  AsanStats stats_;\n+};\n+\n+}  // namespace __asan\n+\n+#endif  // ASAN_THREAD_H"}, {"sha": "840837e00042905cd17eaf67d539c91b22823ddd", "filename": "libsanitizer/asan/asan_thread_registry.cc", "status": "added", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_thread_registry.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_thread_registry.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_thread_registry.cc?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,188 @@\n+//===-- asan_thread_registry.cc -------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// AsanThreadRegistry-related code. AsanThreadRegistry is a container\n+// for summaries of all created threads.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"asan_stack.h\"\n+#include \"asan_thread.h\"\n+#include \"asan_thread_registry.h\"\n+#include \"sanitizer_common/sanitizer_common.h\"\n+\n+namespace __asan {\n+\n+static AsanThreadRegistry asan_thread_registry(LINKER_INITIALIZED);\n+\n+AsanThreadRegistry &asanThreadRegistry() {\n+  return asan_thread_registry;\n+}\n+\n+AsanThreadRegistry::AsanThreadRegistry(LinkerInitialized x)\n+    : main_thread_(x),\n+      main_thread_summary_(x),\n+      accumulated_stats_(x),\n+      max_malloced_memory_(x),\n+      mu_(x) { }\n+\n+void AsanThreadRegistry::Init() {\n+  AsanTSDInit(AsanThreadSummary::TSDDtor);\n+  main_thread_.set_summary(&main_thread_summary_);\n+  main_thread_summary_.set_thread(&main_thread_);\n+  RegisterThread(&main_thread_);\n+  SetCurrent(&main_thread_);\n+  // At this point only one thread exists.\n+  inited_ = true;\n+}\n+\n+void AsanThreadRegistry::RegisterThread(AsanThread *thread) {\n+  ScopedLock lock(&mu_);\n+  u32 tid = n_threads_;\n+  n_threads_++;\n+  CHECK(n_threads_ < kMaxNumberOfThreads);\n+\n+  AsanThreadSummary *summary = thread->summary();\n+  CHECK(summary != 0);\n+  summary->set_tid(tid);\n+  thread_summaries_[tid] = summary;\n+}\n+\n+void AsanThreadRegistry::UnregisterThread(AsanThread *thread) {\n+  ScopedLock lock(&mu_);\n+  FlushToAccumulatedStatsUnlocked(&thread->stats());\n+  AsanThreadSummary *summary = thread->summary();\n+  CHECK(summary);\n+  summary->set_thread(0);\n+}\n+\n+AsanThread *AsanThreadRegistry::GetMain() {\n+  return &main_thread_;\n+}\n+\n+AsanThread *AsanThreadRegistry::GetCurrent() {\n+  AsanThreadSummary *summary = (AsanThreadSummary *)AsanTSDGet();\n+  if (!summary) {\n+#if ASAN_ANDROID\n+    // On Android, libc constructor is called _after_ asan_init, and cleans up\n+    // TSD. Try to figure out if this is still the main thread by the stack\n+    // address. We are not entirely sure that we have correct main thread\n+    // limits, so only do this magic on Android, and only if the found thread is\n+    // the main thread.\n+    AsanThread* thread = FindThreadByStackAddress((uptr)&summary);\n+    if (thread && thread->tid() == 0) {\n+      SetCurrent(thread);\n+      return thread;\n+    }\n+#endif\n+    return 0;\n+  }\n+  return summary->thread();\n+}\n+\n+void AsanThreadRegistry::SetCurrent(AsanThread *t) {\n+  CHECK(t->summary());\n+  if (flags()->verbosity >= 2) {\n+    Report(\"SetCurrent: %p for thread %p\\n\",\n+           t->summary(), (void*)GetThreadSelf());\n+  }\n+  // Make sure we do not reset the current AsanThread.\n+  CHECK(AsanTSDGet() == 0);\n+  AsanTSDSet(t->summary());\n+  CHECK(AsanTSDGet() == t->summary());\n+}\n+\n+AsanStats &AsanThreadRegistry::GetCurrentThreadStats() {\n+  AsanThread *t = GetCurrent();\n+  return (t) ? t->stats() : main_thread_.stats();\n+}\n+\n+AsanStats AsanThreadRegistry::GetAccumulatedStats() {\n+  ScopedLock lock(&mu_);\n+  UpdateAccumulatedStatsUnlocked();\n+  return accumulated_stats_;\n+}\n+\n+uptr AsanThreadRegistry::GetCurrentAllocatedBytes() {\n+  ScopedLock lock(&mu_);\n+  UpdateAccumulatedStatsUnlocked();\n+  return accumulated_stats_.malloced - accumulated_stats_.freed;\n+}\n+\n+uptr AsanThreadRegistry::GetHeapSize() {\n+  ScopedLock lock(&mu_);\n+  UpdateAccumulatedStatsUnlocked();\n+  return accumulated_stats_.mmaped;\n+}\n+\n+uptr AsanThreadRegistry::GetFreeBytes() {\n+  ScopedLock lock(&mu_);\n+  UpdateAccumulatedStatsUnlocked();\n+  return accumulated_stats_.mmaped\n+         - accumulated_stats_.malloced\n+         - accumulated_stats_.malloced_redzones\n+         + accumulated_stats_.really_freed\n+         + accumulated_stats_.really_freed_redzones;\n+}\n+\n+// Return several stats counters with a single call to\n+// UpdateAccumulatedStatsUnlocked().\n+void AsanThreadRegistry::FillMallocStatistics(AsanMallocStats *malloc_stats) {\n+  ScopedLock lock(&mu_);\n+  UpdateAccumulatedStatsUnlocked();\n+  malloc_stats->blocks_in_use = accumulated_stats_.mallocs;\n+  malloc_stats->size_in_use = accumulated_stats_.malloced;\n+  malloc_stats->max_size_in_use = max_malloced_memory_;\n+  malloc_stats->size_allocated = accumulated_stats_.mmaped;\n+}\n+\n+AsanThreadSummary *AsanThreadRegistry::FindByTid(u32 tid) {\n+  CHECK(tid < n_threads_);\n+  CHECK(thread_summaries_[tid]);\n+  return thread_summaries_[tid];\n+}\n+\n+AsanThread *AsanThreadRegistry::FindThreadByStackAddress(uptr addr) {\n+  ScopedLock lock(&mu_);\n+  for (u32 tid = 0; tid < n_threads_; tid++) {\n+    AsanThread *t = thread_summaries_[tid]->thread();\n+    if (!t || !(t->fake_stack().StackSize())) continue;\n+    if (t->fake_stack().AddrIsInFakeStack(addr) || t->AddrIsInStack(addr)) {\n+      return t;\n+    }\n+  }\n+  return 0;\n+}\n+\n+void AsanThreadRegistry::UpdateAccumulatedStatsUnlocked() {\n+  for (u32 tid = 0; tid < n_threads_; tid++) {\n+    AsanThread *t = thread_summaries_[tid]->thread();\n+    if (t != 0) {\n+      FlushToAccumulatedStatsUnlocked(&t->stats());\n+    }\n+  }\n+  // This is not very accurate: we may miss allocation peaks that happen\n+  // between two updates of accumulated_stats_. For more accurate bookkeeping\n+  // the maximum should be updated on every malloc(), which is unacceptable.\n+  if (max_malloced_memory_ < accumulated_stats_.malloced) {\n+    max_malloced_memory_ = accumulated_stats_.malloced;\n+  }\n+}\n+\n+void AsanThreadRegistry::FlushToAccumulatedStatsUnlocked(AsanStats *stats) {\n+  // AsanStats consists of variables of type uptr only.\n+  uptr *dst = (uptr*)&accumulated_stats_;\n+  uptr *src = (uptr*)stats;\n+  uptr num_fields = sizeof(AsanStats) / sizeof(uptr);\n+  for (uptr i = 0; i < num_fields; i++) {\n+    dst[i] += src[i];\n+    src[i] = 0;\n+  }\n+}\n+\n+}  // namespace __asan"}, {"sha": "99d5cb56af0878826bf8e48966b10afe59b3c880", "filename": "libsanitizer/asan/asan_thread_registry.h", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_thread_registry.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_thread_registry.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_thread_registry.h?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,83 @@\n+//===-- asan_thread_registry.h ----------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// ASan-private header for asan_thread_registry.cc\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef ASAN_THREAD_REGISTRY_H\n+#define ASAN_THREAD_REGISTRY_H\n+\n+#include \"asan_lock.h\"\n+#include \"asan_stack.h\"\n+#include \"asan_stats.h\"\n+#include \"asan_thread.h\"\n+\n+namespace __asan {\n+\n+// Stores summaries of all created threads, returns current thread,\n+// thread by tid, thread by stack address. There is a single instance\n+// of AsanThreadRegistry for the whole program.\n+// AsanThreadRegistry is thread-safe.\n+class AsanThreadRegistry {\n+ public:\n+  explicit AsanThreadRegistry(LinkerInitialized);\n+  void Init();\n+  void RegisterThread(AsanThread *thread);\n+  void UnregisterThread(AsanThread *thread);\n+\n+  AsanThread *GetMain();\n+  // Get the current thread. May return 0.\n+  AsanThread *GetCurrent();\n+  void SetCurrent(AsanThread *t);\n+\n+  u32 GetCurrentTidOrInvalid() {\n+    if (!inited_) return 0;\n+    AsanThread *t = GetCurrent();\n+    return t ? t->tid() : kInvalidTid;\n+  }\n+\n+  // Returns stats for GetCurrent(), or stats for\n+  // T0 if GetCurrent() returns 0.\n+  AsanStats &GetCurrentThreadStats();\n+  // Flushes all thread-local stats to accumulated stats, and returns\n+  // a copy of accumulated stats.\n+  AsanStats GetAccumulatedStats();\n+  uptr GetCurrentAllocatedBytes();\n+  uptr GetHeapSize();\n+  uptr GetFreeBytes();\n+  void FillMallocStatistics(AsanMallocStats *malloc_stats);\n+\n+  AsanThreadSummary *FindByTid(u32 tid);\n+  AsanThread *FindThreadByStackAddress(uptr addr);\n+\n+ private:\n+  void UpdateAccumulatedStatsUnlocked();\n+  // Adds values of all counters in \"stats\" to accumulated stats,\n+  // and fills \"stats\" with zeroes.\n+  void FlushToAccumulatedStatsUnlocked(AsanStats *stats);\n+\n+  static const u32 kMaxNumberOfThreads = (1 << 22);  // 4M\n+  AsanThreadSummary *thread_summaries_[kMaxNumberOfThreads];\n+  AsanThread main_thread_;\n+  AsanThreadSummary main_thread_summary_;\n+  AsanStats accumulated_stats_;\n+  // Required for malloc_zone_statistics() on OS X. This can't be stored in\n+  // per-thread AsanStats.\n+  uptr max_malloced_memory_;\n+  u32 n_threads_;\n+  AsanLock mu_;\n+  bool inited_;\n+};\n+\n+// Returns a single instance of registry.\n+AsanThreadRegistry &asanThreadRegistry();\n+\n+}  // namespace __asan\n+\n+#endif  // ASAN_THREAD_REGISTRY_H"}, {"sha": "a5c0441dafa6adafb54dd532ae035bd956d5b436", "filename": "libsanitizer/asan/asan_win.cc", "status": "added", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Fasan_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_win.cc?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,190 @@\n+//===-- asan_win.cc -------------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// Windows-specific details.\n+//===----------------------------------------------------------------------===//\n+#ifdef _WIN32\n+#include <windows.h>\n+\n+#include <dbghelp.h>\n+#include <stdlib.h>\n+\n+#include <new>  // FIXME: temporarily needed for placement new in AsanLock.\n+\n+#include \"asan_interceptors.h\"\n+#include \"asan_internal.h\"\n+#include \"asan_lock.h\"\n+#include \"asan_thread.h\"\n+#include \"sanitizer_common/sanitizer_libc.h\"\n+\n+namespace __asan {\n+\n+// ---------------------- Stacktraces, symbols, etc. ---------------- {{{1\n+static AsanLock dbghelp_lock(LINKER_INITIALIZED);\n+static bool dbghelp_initialized = false;\n+#pragma comment(lib, \"dbghelp.lib\")\n+\n+void GetStackTrace(StackTrace *stack, uptr max_s, uptr pc, uptr bp) {\n+  stack->max_size = max_s;\n+  void *tmp[kStackTraceMax];\n+\n+  // FIXME: CaptureStackBackTrace might be too slow for us.\n+  // FIXME: Compare with StackWalk64.\n+  // FIXME: Look at LLVMUnhandledExceptionFilter in Signals.inc\n+  uptr cs_ret = CaptureStackBackTrace(1, stack->max_size, tmp, 0);\n+  uptr offset = 0;\n+  // Skip the RTL frames by searching for the PC in the stacktrace.\n+  // FIXME: this doesn't work well for the malloc/free stacks yet.\n+  for (uptr i = 0; i < cs_ret; i++) {\n+    if (pc != (uptr)tmp[i])\n+      continue;\n+    offset = i;\n+    break;\n+  }\n+\n+  stack->size = cs_ret - offset;\n+  for (uptr i = 0; i < stack->size; i++)\n+    stack->trace[i] = (uptr)tmp[i + offset];\n+}\n+\n+// ---------------------- AsanLock ---------------- {{{1\n+enum LockState {\n+  LOCK_UNINITIALIZED = 0,\n+  LOCK_READY = -1,\n+};\n+\n+AsanLock::AsanLock(LinkerInitialized li) {\n+  // FIXME: see comments in AsanLock::Lock() for the details.\n+  CHECK(li == LINKER_INITIALIZED || owner_ == LOCK_UNINITIALIZED);\n+\n+  CHECK(sizeof(CRITICAL_SECTION) <= sizeof(opaque_storage_));\n+  InitializeCriticalSection((LPCRITICAL_SECTION)opaque_storage_);\n+  owner_ = LOCK_READY;\n+}\n+\n+void AsanLock::Lock() {\n+  if (owner_ == LOCK_UNINITIALIZED) {\n+    // FIXME: hm, global AsanLock objects are not initialized?!?\n+    // This might be a side effect of the clang+cl+link Frankenbuild...\n+    new(this) AsanLock((LinkerInitialized)(LINKER_INITIALIZED + 1));\n+\n+    // FIXME: If it turns out the linker doesn't invoke our\n+    // constructors, we should probably manually Lock/Unlock all the global\n+    // locks while we're starting in one thread to avoid double-init races.\n+  }\n+  EnterCriticalSection((LPCRITICAL_SECTION)opaque_storage_);\n+  CHECK(owner_ == LOCK_READY);\n+  owner_ = GetThreadSelf();\n+}\n+\n+void AsanLock::Unlock() {\n+  CHECK(owner_ == GetThreadSelf());\n+  owner_ = LOCK_READY;\n+  LeaveCriticalSection((LPCRITICAL_SECTION)opaque_storage_);\n+}\n+\n+// ---------------------- TSD ---------------- {{{1\n+static bool tsd_key_inited = false;\n+\n+static __declspec(thread) void *fake_tsd = 0;\n+\n+void AsanTSDInit(void (*destructor)(void *tsd)) {\n+  // FIXME: we're ignoring the destructor for now.\n+  tsd_key_inited = true;\n+}\n+\n+void *AsanTSDGet() {\n+  CHECK(tsd_key_inited);\n+  return fake_tsd;\n+}\n+\n+void AsanTSDSet(void *tsd) {\n+  CHECK(tsd_key_inited);\n+  fake_tsd = tsd;\n+}\n+\n+// ---------------------- Various stuff ---------------- {{{1\n+void MaybeReexec() {\n+  // No need to re-exec on Windows.\n+}\n+\n+void *AsanDoesNotSupportStaticLinkage() {\n+#if defined(_DEBUG)\n+#error Please build the runtime with a non-debug CRT: /MD or /MT\n+#endif\n+  return 0;\n+}\n+\n+void SetAlternateSignalStack() {\n+  // FIXME: Decide what to do on Windows.\n+}\n+\n+void UnsetAlternateSignalStack() {\n+  // FIXME: Decide what to do on Windows.\n+}\n+\n+void InstallSignalHandlers() {\n+  // FIXME: Decide what to do on Windows.\n+}\n+\n+void AsanPlatformThreadInit() {\n+  // Nothing here for now.\n+}\n+\n+}  // namespace __asan\n+\n+// ---------------------- Interface ---------------- {{{1\n+using namespace __asan;  // NOLINT\n+\n+extern \"C\" {\n+SANITIZER_INTERFACE_ATTRIBUTE NOINLINE\n+bool __asan_symbolize(const void *addr, char *out_buffer, int buffer_size) {\n+  ScopedLock lock(&dbghelp_lock);\n+  if (!dbghelp_initialized) {\n+    SymSetOptions(SYMOPT_DEFERRED_LOADS |\n+                  SYMOPT_UNDNAME |\n+                  SYMOPT_LOAD_LINES);\n+    CHECK(SymInitialize(GetCurrentProcess(), 0, TRUE));\n+    // FIXME: We don't call SymCleanup() on exit yet - should we?\n+    dbghelp_initialized = true;\n+  }\n+\n+  // See http://msdn.microsoft.com/en-us/library/ms680578(VS.85).aspx\n+  char buffer[sizeof(SYMBOL_INFO) + MAX_SYM_NAME * sizeof(CHAR)];\n+  PSYMBOL_INFO symbol = (PSYMBOL_INFO)buffer;\n+  symbol->SizeOfStruct = sizeof(SYMBOL_INFO);\n+  symbol->MaxNameLen = MAX_SYM_NAME;\n+  DWORD64 offset = 0;\n+  BOOL got_objname = SymFromAddr(GetCurrentProcess(),\n+                                 (DWORD64)addr, &offset, symbol);\n+  if (!got_objname)\n+    return false;\n+\n+  DWORD  unused;\n+  IMAGEHLP_LINE64 info;\n+  info.SizeOfStruct = sizeof(IMAGEHLP_LINE64);\n+  BOOL got_fileline = SymGetLineFromAddr64(GetCurrentProcess(),\n+                                           (DWORD64)addr, &unused, &info);\n+  int written = 0;\n+  out_buffer[0] = '\\0';\n+  // FIXME: it might be useful to print out 'obj' or 'obj+offset' info too.\n+  if (got_fileline) {\n+    written += internal_snprintf(out_buffer + written, buffer_size - written,\n+                        \" %s %s:%d\", symbol->Name,\n+                        info.FileName, info.LineNumber);\n+  } else {\n+    written += internal_snprintf(out_buffer + written, buffer_size - written,\n+                        \" %s+0x%p\", symbol->Name, offset);\n+  }\n+  return true;\n+}\n+}  // extern \"C\"\n+\n+\n+#endif  // _WIN32"}, {"sha": "204fdd2d8e5fe21a5a9f9e23d6a6cf17d353362a", "filename": "libsanitizer/asan/libtool-version", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Flibtool-version", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fasan%2Flibtool-version", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Flibtool-version?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,6 @@\n+# This file is used to maintain libtool version info for libmudflap.  See\n+# the libtool manual to understand the meaning of the fields.  This is\n+# a separate file so that version updates don't involve re-running\n+# automake.\n+# CURRENT:REVISION:AGE\n+0:0:0"}, {"sha": "d622a44e551f209d5e8c5462b3fe53a162f7b330", "filename": "libsanitizer/config.guess", "status": "added", "additions": 1530, "deletions": 0, "changes": 1530, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fconfig.guess", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fconfig.guess", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fconfig.guess?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,1530 @@\n+#! /bin/sh\n+# Attempt to guess a canonical system name.\n+#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n+#   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n+#   2011, 2012 Free Software Foundation, Inc.\n+\n+timestamp='2012-02-10'\n+\n+# This file is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful, but\n+# WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+# General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, see <http://www.gnu.org/licenses/>.\n+#\n+# As a special exception to the GNU General Public License, if you\n+# distribute this file as part of a program that contains a\n+# configuration script generated by Autoconf, you may include it under\n+# the same distribution terms that you use for the rest of that program.\n+\n+\n+# Originally written by Per Bothner.  Please send patches (context\n+# diff format) to <config-patches@gnu.org> and include a ChangeLog\n+# entry.\n+#\n+# This script attempts to guess a canonical system name similar to\n+# config.sub.  If it succeeds, it prints the system name on stdout, and\n+# exits with 0.  Otherwise, it exits with 1.\n+#\n+# You can get the latest version of this script from:\n+# http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD\n+\n+me=`echo \"$0\" | sed -e 's,.*/,,'`\n+\n+usage=\"\\\n+Usage: $0 [OPTION]\n+\n+Output the configuration name of the system \\`$me' is run on.\n+\n+Operation modes:\n+  -h, --help         print this help, then exit\n+  -t, --time-stamp   print date of last modification, then exit\n+  -v, --version      print version number, then exit\n+\n+Report bugs and patches to <config-patches@gnu.org>.\"\n+\n+version=\"\\\n+GNU config.guess ($timestamp)\n+\n+Originally written by Per Bothner.\n+Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,\n+2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012\n+Free Software Foundation, Inc.\n+\n+This is free software; see the source for copying conditions.  There is NO\n+warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\"\n+\n+help=\"\n+Try \\`$me --help' for more information.\"\n+\n+# Parse command line\n+while test $# -gt 0 ; do\n+  case $1 in\n+    --time-stamp | --time* | -t )\n+       echo \"$timestamp\" ; exit ;;\n+    --version | -v )\n+       echo \"$version\" ; exit ;;\n+    --help | --h* | -h )\n+       echo \"$usage\"; exit ;;\n+    -- )     # Stop option processing\n+       shift; break ;;\n+    - )\t# Use stdin as input.\n+       break ;;\n+    -* )\n+       echo \"$me: invalid option $1$help\" >&2\n+       exit 1 ;;\n+    * )\n+       break ;;\n+  esac\n+done\n+\n+if test $# != 0; then\n+  echo \"$me: too many arguments$help\" >&2\n+  exit 1\n+fi\n+\n+trap 'exit 1' 1 2 15\n+\n+# CC_FOR_BUILD -- compiler used by this script. Note that the use of a\n+# compiler to aid in system detection is discouraged as it requires\n+# temporary files to be created and, as you can see below, it is a\n+# headache to deal with in a portable fashion.\n+\n+# Historically, `CC_FOR_BUILD' used to be named `HOST_CC'. We still\n+# use `HOST_CC' if defined, but it is deprecated.\n+\n+# Portable tmp directory creation inspired by the Autoconf team.\n+\n+set_cc_for_build='\n+trap \"exitcode=\\$?; (rm -f \\$tmpfiles 2>/dev/null; rmdir \\$tmp 2>/dev/null) && exit \\$exitcode\" 0 ;\n+trap \"rm -f \\$tmpfiles 2>/dev/null; rmdir \\$tmp 2>/dev/null; exit 1\" 1 2 13 15 ;\n+: ${TMPDIR=/tmp} ;\n+ { tmp=`(umask 077 && mktemp -d \"$TMPDIR/cgXXXXXX\") 2>/dev/null` && test -n \"$tmp\" && test -d \"$tmp\" ; } ||\n+ { test -n \"$RANDOM\" && tmp=$TMPDIR/cg$$-$RANDOM && (umask 077 && mkdir $tmp) ; } ||\n+ { tmp=$TMPDIR/cg-$$ && (umask 077 && mkdir $tmp) && echo \"Warning: creating insecure temp directory\" >&2 ; } ||\n+ { echo \"$me: cannot create a temporary directory in $TMPDIR\" >&2 ; exit 1 ; } ;\n+dummy=$tmp/dummy ;\n+tmpfiles=\"$dummy.c $dummy.o $dummy.rel $dummy\" ;\n+case $CC_FOR_BUILD,$HOST_CC,$CC in\n+ ,,)    echo \"int x;\" > $dummy.c ;\n+\tfor c in cc gcc c89 c99 ; do\n+\t  if ($c -c -o $dummy.o $dummy.c) >/dev/null 2>&1 ; then\n+\t     CC_FOR_BUILD=\"$c\"; break ;\n+\t  fi ;\n+\tdone ;\n+\tif test x\"$CC_FOR_BUILD\" = x ; then\n+\t  CC_FOR_BUILD=no_compiler_found ;\n+\tfi\n+\t;;\n+ ,,*)   CC_FOR_BUILD=$CC ;;\n+ ,*,*)  CC_FOR_BUILD=$HOST_CC ;;\n+esac ; set_cc_for_build= ;'\n+\n+# This is needed to find uname on a Pyramid OSx when run in the BSD universe.\n+# (ghazi@noc.rutgers.edu 1994-08-24)\n+if (test -f /.attbin/uname) >/dev/null 2>&1 ; then\n+\tPATH=$PATH:/.attbin ; export PATH\n+fi\n+\n+UNAME_MACHINE=`(uname -m) 2>/dev/null` || UNAME_MACHINE=unknown\n+UNAME_RELEASE=`(uname -r) 2>/dev/null` || UNAME_RELEASE=unknown\n+UNAME_SYSTEM=`(uname -s) 2>/dev/null`  || UNAME_SYSTEM=unknown\n+UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown\n+\n+# Note: order is significant - the case branches are not exclusive.\n+\n+case \"${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}\" in\n+    *:NetBSD:*:*)\n+\t# NetBSD (nbsd) targets should (where applicable) match one or\n+\t# more of the tuples: *-*-netbsdelf*, *-*-netbsdaout*,\n+\t# *-*-netbsdecoff* and *-*-netbsd*.  For targets that recently\n+\t# switched to ELF, *-*-netbsd* would select the old\n+\t# object file format.  This provides both forward\n+\t# compatibility and a consistent mechanism for selecting the\n+\t# object file format.\n+\t#\n+\t# Note: NetBSD doesn't particularly care about the vendor\n+\t# portion of the name.  We always set it to \"unknown\".\n+\tsysctl=\"sysctl -n hw.machine_arch\"\n+\tUNAME_MACHINE_ARCH=`(/sbin/$sysctl 2>/dev/null || \\\n+\t    /usr/sbin/$sysctl 2>/dev/null || echo unknown)`\n+\tcase \"${UNAME_MACHINE_ARCH}\" in\n+\t    armeb) machine=armeb-unknown ;;\n+\t    arm*) machine=arm-unknown ;;\n+\t    sh3el) machine=shl-unknown ;;\n+\t    sh3eb) machine=sh-unknown ;;\n+\t    sh5el) machine=sh5le-unknown ;;\n+\t    *) machine=${UNAME_MACHINE_ARCH}-unknown ;;\n+\tesac\n+\t# The Operating System including object format, if it has switched\n+\t# to ELF recently, or will in the future.\n+\tcase \"${UNAME_MACHINE_ARCH}\" in\n+\t    arm*|i386|m68k|ns32k|sh3*|sparc|vax)\n+\t\teval $set_cc_for_build\n+\t\tif echo __ELF__ | $CC_FOR_BUILD -E - 2>/dev/null \\\n+\t\t\t| grep -q __ELF__\n+\t\tthen\n+\t\t    # Once all utilities can be ECOFF (netbsdecoff) or a.out (netbsdaout).\n+\t\t    # Return netbsd for either.  FIX?\n+\t\t    os=netbsd\n+\t\telse\n+\t\t    os=netbsdelf\n+\t\tfi\n+\t\t;;\n+\t    *)\n+\t\tos=netbsd\n+\t\t;;\n+\tesac\n+\t# The OS release\n+\t# Debian GNU/NetBSD machines have a different userland, and\n+\t# thus, need a distinct triplet. However, they do not need\n+\t# kernel version information, so it can be replaced with a\n+\t# suitable tag, in the style of linux-gnu.\n+\tcase \"${UNAME_VERSION}\" in\n+\t    Debian*)\n+\t\trelease='-gnu'\n+\t\t;;\n+\t    *)\n+\t\trelease=`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\\./'`\n+\t\t;;\n+\tesac\n+\t# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:\n+\t# contains redundant information, the shorter form:\n+\t# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.\n+\techo \"${machine}-${os}${release}\"\n+\texit ;;\n+    *:OpenBSD:*:*)\n+\tUNAME_MACHINE_ARCH=`arch | sed 's/OpenBSD.//'`\n+\techo ${UNAME_MACHINE_ARCH}-unknown-openbsd${UNAME_RELEASE}\n+\texit ;;\n+    *:ekkoBSD:*:*)\n+\techo ${UNAME_MACHINE}-unknown-ekkobsd${UNAME_RELEASE}\n+\texit ;;\n+    *:SolidBSD:*:*)\n+\techo ${UNAME_MACHINE}-unknown-solidbsd${UNAME_RELEASE}\n+\texit ;;\n+    macppc:MirBSD:*:*)\n+\techo powerpc-unknown-mirbsd${UNAME_RELEASE}\n+\texit ;;\n+    *:MirBSD:*:*)\n+\techo ${UNAME_MACHINE}-unknown-mirbsd${UNAME_RELEASE}\n+\texit ;;\n+    alpha:OSF1:*:*)\n+\tcase $UNAME_RELEASE in\n+\t*4.0)\n+\t\tUNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $3}'`\n+\t\t;;\n+\t*5.*)\n+\t\tUNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $4}'`\n+\t\t;;\n+\tesac\n+\t# According to Compaq, /usr/sbin/psrinfo has been available on\n+\t# OSF/1 and Tru64 systems produced since 1995.  I hope that\n+\t# covers most systems running today.  This code pipes the CPU\n+\t# types through head -n 1, so we only detect the type of CPU 0.\n+\tALPHA_CPU_TYPE=`/usr/sbin/psrinfo -v | sed -n -e 's/^  The alpha \\(.*\\) processor.*$/\\1/p' | head -n 1`\n+\tcase \"$ALPHA_CPU_TYPE\" in\n+\t    \"EV4 (21064)\")\n+\t\tUNAME_MACHINE=\"alpha\" ;;\n+\t    \"EV4.5 (21064)\")\n+\t\tUNAME_MACHINE=\"alpha\" ;;\n+\t    \"LCA4 (21066/21068)\")\n+\t\tUNAME_MACHINE=\"alpha\" ;;\n+\t    \"EV5 (21164)\")\n+\t\tUNAME_MACHINE=\"alphaev5\" ;;\n+\t    \"EV5.6 (21164A)\")\n+\t\tUNAME_MACHINE=\"alphaev56\" ;;\n+\t    \"EV5.6 (21164PC)\")\n+\t\tUNAME_MACHINE=\"alphapca56\" ;;\n+\t    \"EV5.7 (21164PC)\")\n+\t\tUNAME_MACHINE=\"alphapca57\" ;;\n+\t    \"EV6 (21264)\")\n+\t\tUNAME_MACHINE=\"alphaev6\" ;;\n+\t    \"EV6.7 (21264A)\")\n+\t\tUNAME_MACHINE=\"alphaev67\" ;;\n+\t    \"EV6.8CB (21264C)\")\n+\t\tUNAME_MACHINE=\"alphaev68\" ;;\n+\t    \"EV6.8AL (21264B)\")\n+\t\tUNAME_MACHINE=\"alphaev68\" ;;\n+\t    \"EV6.8CX (21264D)\")\n+\t\tUNAME_MACHINE=\"alphaev68\" ;;\n+\t    \"EV6.9A (21264/EV69A)\")\n+\t\tUNAME_MACHINE=\"alphaev69\" ;;\n+\t    \"EV7 (21364)\")\n+\t\tUNAME_MACHINE=\"alphaev7\" ;;\n+\t    \"EV7.9 (21364A)\")\n+\t\tUNAME_MACHINE=\"alphaev79\" ;;\n+\tesac\n+\t# A Pn.n version is a patched version.\n+\t# A Vn.n version is a released version.\n+\t# A Tn.n version is a released field test version.\n+\t# A Xn.n version is an unreleased experimental baselevel.\n+\t# 1.2 uses \"1.2\" for uname -r.\n+\techo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[PVTX]//' | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`\n+\t# Reset EXIT trap before exiting to avoid spurious non-zero exit code.\n+\texitcode=$?\n+\ttrap '' 0\n+\texit $exitcode ;;\n+    Alpha\\ *:Windows_NT*:*)\n+\t# How do we know it's Interix rather than the generic POSIX subsystem?\n+\t# Should we change UNAME_MACHINE based on the output of uname instead\n+\t# of the specific Alpha model?\n+\techo alpha-pc-interix\n+\texit ;;\n+    21064:Windows_NT:50:3)\n+\techo alpha-dec-winnt3.5\n+\texit ;;\n+    Amiga*:UNIX_System_V:4.0:*)\n+\techo m68k-unknown-sysv4\n+\texit ;;\n+    *:[Aa]miga[Oo][Ss]:*:*)\n+\techo ${UNAME_MACHINE}-unknown-amigaos\n+\texit ;;\n+    *:[Mm]orph[Oo][Ss]:*:*)\n+\techo ${UNAME_MACHINE}-unknown-morphos\n+\texit ;;\n+    *:OS/390:*:*)\n+\techo i370-ibm-openedition\n+\texit ;;\n+    *:z/VM:*:*)\n+\techo s390-ibm-zvmoe\n+\texit ;;\n+    *:OS400:*:*)\n+\techo powerpc-ibm-os400\n+\texit ;;\n+    arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)\n+\techo arm-acorn-riscix${UNAME_RELEASE}\n+\texit ;;\n+    arm:riscos:*:*|arm:RISCOS:*:*)\n+\techo arm-unknown-riscos\n+\texit ;;\n+    SR2?01:HI-UX/MPP:*:* | SR8000:HI-UX/MPP:*:*)\n+\techo hppa1.1-hitachi-hiuxmpp\n+\texit ;;\n+    Pyramid*:OSx*:*:* | MIS*:OSx*:*:* | MIS*:SMP_DC-OSx*:*:*)\n+\t# akee@wpdis03.wpafb.af.mil (Earle F. Ake) contributed MIS and NILE.\n+\tif test \"`(/bin/universe) 2>/dev/null`\" = att ; then\n+\t\techo pyramid-pyramid-sysv3\n+\telse\n+\t\techo pyramid-pyramid-bsd\n+\tfi\n+\texit ;;\n+    NILE*:*:*:dcosx)\n+\techo pyramid-pyramid-svr4\n+\texit ;;\n+    DRS?6000:unix:4.0:6*)\n+\techo sparc-icl-nx6\n+\texit ;;\n+    DRS?6000:UNIX_SV:4.2*:7* | DRS?6000:isis:4.2*:7*)\n+\tcase `/usr/bin/uname -p` in\n+\t    sparc) echo sparc-icl-nx7; exit ;;\n+\tesac ;;\n+    s390x:SunOS:*:*)\n+\techo ${UNAME_MACHINE}-ibm-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`\n+\texit ;;\n+    sun4H:SunOS:5.*:*)\n+\techo sparc-hal-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`\n+\texit ;;\n+    sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)\n+\techo sparc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`\n+\texit ;;\n+    i86pc:AuroraUX:5.*:* | i86xen:AuroraUX:5.*:*)\n+\techo i386-pc-auroraux${UNAME_RELEASE}\n+\texit ;;\n+    i86pc:SunOS:5.*:* | i86xen:SunOS:5.*:*)\n+\teval $set_cc_for_build\n+\tSUN_ARCH=\"i386\"\n+\t# If there is a compiler, see if it is configured for 64-bit objects.\n+\t# Note that the Sun cc does not turn __LP64__ into 1 like gcc does.\n+\t# This test works for both compilers.\n+\tif [ \"$CC_FOR_BUILD\" != 'no_compiler_found' ]; then\n+\t    if (echo '#ifdef __amd64'; echo IS_64BIT_ARCH; echo '#endif') | \\\n+\t\t(CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) | \\\n+\t\tgrep IS_64BIT_ARCH >/dev/null\n+\t    then\n+\t\tSUN_ARCH=\"x86_64\"\n+\t    fi\n+\tfi\n+\techo ${SUN_ARCH}-pc-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`\n+\texit ;;\n+    sun4*:SunOS:6*:*)\n+\t# According to config.sub, this is the proper way to canonicalize\n+\t# SunOS6.  Hard to guess exactly what SunOS6 will be like, but\n+\t# it's likely to be more like Solaris than SunOS4.\n+\techo sparc-sun-solaris3`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`\n+\texit ;;\n+    sun4*:SunOS:*:*)\n+\tcase \"`/usr/bin/arch -k`\" in\n+\t    Series*|S4*)\n+\t\tUNAME_RELEASE=`uname -v`\n+\t\t;;\n+\tesac\n+\t# Japanese Language versions have a version number like `4.1.3-JL'.\n+\techo sparc-sun-sunos`echo ${UNAME_RELEASE}|sed -e 's/-/_/'`\n+\texit ;;\n+    sun3*:SunOS:*:*)\n+\techo m68k-sun-sunos${UNAME_RELEASE}\n+\texit ;;\n+    sun*:*:4.2BSD:*)\n+\tUNAME_RELEASE=`(sed 1q /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`\n+\ttest \"x${UNAME_RELEASE}\" = \"x\" && UNAME_RELEASE=3\n+\tcase \"`/bin/arch`\" in\n+\t    sun3)\n+\t\techo m68k-sun-sunos${UNAME_RELEASE}\n+\t\t;;\n+\t    sun4)\n+\t\techo sparc-sun-sunos${UNAME_RELEASE}\n+\t\t;;\n+\tesac\n+\texit ;;\n+    aushp:SunOS:*:*)\n+\techo sparc-auspex-sunos${UNAME_RELEASE}\n+\texit ;;\n+    # The situation for MiNT is a little confusing.  The machine name\n+    # can be virtually everything (everything which is not\n+    # \"atarist\" or \"atariste\" at least should have a processor\n+    # > m68000).  The system name ranges from \"MiNT\" over \"FreeMiNT\"\n+    # to the lowercase version \"mint\" (or \"freemint\").  Finally\n+    # the system name \"TOS\" denotes a system which is actually not\n+    # MiNT.  But MiNT is downward compatible to TOS, so this should\n+    # be no problem.\n+    atarist[e]:*MiNT:*:* | atarist[e]:*mint:*:* | atarist[e]:*TOS:*:*)\n+\techo m68k-atari-mint${UNAME_RELEASE}\n+\texit ;;\n+    atari*:*MiNT:*:* | atari*:*mint:*:* | atarist[e]:*TOS:*:*)\n+\techo m68k-atari-mint${UNAME_RELEASE}\n+\texit ;;\n+    *falcon*:*MiNT:*:* | *falcon*:*mint:*:* | *falcon*:*TOS:*:*)\n+\techo m68k-atari-mint${UNAME_RELEASE}\n+\texit ;;\n+    milan*:*MiNT:*:* | milan*:*mint:*:* | *milan*:*TOS:*:*)\n+\techo m68k-milan-mint${UNAME_RELEASE}\n+\texit ;;\n+    hades*:*MiNT:*:* | hades*:*mint:*:* | *hades*:*TOS:*:*)\n+\techo m68k-hades-mint${UNAME_RELEASE}\n+\texit ;;\n+    *:*MiNT:*:* | *:*mint:*:* | *:*TOS:*:*)\n+\techo m68k-unknown-mint${UNAME_RELEASE}\n+\texit ;;\n+    m68k:machten:*:*)\n+\techo m68k-apple-machten${UNAME_RELEASE}\n+\texit ;;\n+    powerpc:machten:*:*)\n+\techo powerpc-apple-machten${UNAME_RELEASE}\n+\texit ;;\n+    RISC*:Mach:*:*)\n+\techo mips-dec-mach_bsd4.3\n+\texit ;;\n+    RISC*:ULTRIX:*:*)\n+\techo mips-dec-ultrix${UNAME_RELEASE}\n+\texit ;;\n+    VAX*:ULTRIX*:*:*)\n+\techo vax-dec-ultrix${UNAME_RELEASE}\n+\texit ;;\n+    2020:CLIX:*:* | 2430:CLIX:*:*)\n+\techo clipper-intergraph-clix${UNAME_RELEASE}\n+\texit ;;\n+    mips:*:*:UMIPS | mips:*:*:RISCos)\n+\teval $set_cc_for_build\n+\tsed 's/^\t//' << EOF >$dummy.c\n+#ifdef __cplusplus\n+#include <stdio.h>  /* for printf() prototype */\n+\tint main (int argc, char *argv[]) {\n+#else\n+\tint main (argc, argv) int argc; char *argv[]; {\n+#endif\n+\t#if defined (host_mips) && defined (MIPSEB)\n+\t#if defined (SYSTYPE_SYSV)\n+\t  printf (\"mips-mips-riscos%ssysv\\n\", argv[1]); exit (0);\n+\t#endif\n+\t#if defined (SYSTYPE_SVR4)\n+\t  printf (\"mips-mips-riscos%ssvr4\\n\", argv[1]); exit (0);\n+\t#endif\n+\t#if defined (SYSTYPE_BSD43) || defined(SYSTYPE_BSD)\n+\t  printf (\"mips-mips-riscos%sbsd\\n\", argv[1]); exit (0);\n+\t#endif\n+\t#endif\n+\t  exit (-1);\n+\t}\n+EOF\n+\t$CC_FOR_BUILD -o $dummy $dummy.c &&\n+\t  dummyarg=`echo \"${UNAME_RELEASE}\" | sed -n 's/\\([0-9]*\\).*/\\1/p'` &&\n+\t  SYSTEM_NAME=`$dummy $dummyarg` &&\n+\t    { echo \"$SYSTEM_NAME\"; exit; }\n+\techo mips-mips-riscos${UNAME_RELEASE}\n+\texit ;;\n+    Motorola:PowerMAX_OS:*:*)\n+\techo powerpc-motorola-powermax\n+\texit ;;\n+    Motorola:*:4.3:PL8-*)\n+\techo powerpc-harris-powermax\n+\texit ;;\n+    Night_Hawk:*:*:PowerMAX_OS | Synergy:PowerMAX_OS:*:*)\n+\techo powerpc-harris-powermax\n+\texit ;;\n+    Night_Hawk:Power_UNIX:*:*)\n+\techo powerpc-harris-powerunix\n+\texit ;;\n+    m88k:CX/UX:7*:*)\n+\techo m88k-harris-cxux7\n+\texit ;;\n+    m88k:*:4*:R4*)\n+\techo m88k-motorola-sysv4\n+\texit ;;\n+    m88k:*:3*:R3*)\n+\techo m88k-motorola-sysv3\n+\texit ;;\n+    AViiON:dgux:*:*)\n+\t# DG/UX returns AViiON for all architectures\n+\tUNAME_PROCESSOR=`/usr/bin/uname -p`\n+\tif [ $UNAME_PROCESSOR = mc88100 ] || [ $UNAME_PROCESSOR = mc88110 ]\n+\tthen\n+\t    if [ ${TARGET_BINARY_INTERFACE}x = m88kdguxelfx ] || \\\n+\t       [ ${TARGET_BINARY_INTERFACE}x = x ]\n+\t    then\n+\t\techo m88k-dg-dgux${UNAME_RELEASE}\n+\t    else\n+\t\techo m88k-dg-dguxbcs${UNAME_RELEASE}\n+\t    fi\n+\telse\n+\t    echo i586-dg-dgux${UNAME_RELEASE}\n+\tfi\n+\texit ;;\n+    M88*:DolphinOS:*:*)\t# DolphinOS (SVR3)\n+\techo m88k-dolphin-sysv3\n+\texit ;;\n+    M88*:*:R3*:*)\n+\t# Delta 88k system running SVR3\n+\techo m88k-motorola-sysv3\n+\texit ;;\n+    XD88*:*:*:*) # Tektronix XD88 system running UTekV (SVR3)\n+\techo m88k-tektronix-sysv3\n+\texit ;;\n+    Tek43[0-9][0-9]:UTek:*:*) # Tektronix 4300 system running UTek (BSD)\n+\techo m68k-tektronix-bsd\n+\texit ;;\n+    *:IRIX*:*:*)\n+\techo mips-sgi-irix`echo ${UNAME_RELEASE}|sed -e 's/-/_/g'`\n+\texit ;;\n+    ????????:AIX?:[12].1:2)   # AIX 2.2.1 or AIX 2.1.1 is RT/PC AIX.\n+\techo romp-ibm-aix     # uname -m gives an 8 hex-code CPU id\n+\texit ;;               # Note that: echo \"'`uname -s`'\" gives 'AIX '\n+    i*86:AIX:*:*)\n+\techo i386-ibm-aix\n+\texit ;;\n+    ia64:AIX:*:*)\n+\tif [ -x /usr/bin/oslevel ] ; then\n+\t\tIBM_REV=`/usr/bin/oslevel`\n+\telse\n+\t\tIBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}\n+\tfi\n+\techo ${UNAME_MACHINE}-ibm-aix${IBM_REV}\n+\texit ;;\n+    *:AIX:2:3)\n+\tif grep bos325 /usr/include/stdio.h >/dev/null 2>&1; then\n+\t\teval $set_cc_for_build\n+\t\tsed 's/^\t\t//' << EOF >$dummy.c\n+\t\t#include <sys/systemcfg.h>\n+\n+\t\tmain()\n+\t\t\t{\n+\t\t\tif (!__power_pc())\n+\t\t\t\texit(1);\n+\t\t\tputs(\"powerpc-ibm-aix3.2.5\");\n+\t\t\texit(0);\n+\t\t\t}\n+EOF\n+\t\tif $CC_FOR_BUILD -o $dummy $dummy.c && SYSTEM_NAME=`$dummy`\n+\t\tthen\n+\t\t\techo \"$SYSTEM_NAME\"\n+\t\telse\n+\t\t\techo rs6000-ibm-aix3.2.5\n+\t\tfi\n+\telif grep bos324 /usr/include/stdio.h >/dev/null 2>&1; then\n+\t\techo rs6000-ibm-aix3.2.4\n+\telse\n+\t\techo rs6000-ibm-aix3.2\n+\tfi\n+\texit ;;\n+    *:AIX:*:[4567])\n+\tIBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | sed 1q | awk '{ print $1 }'`\n+\tif /usr/sbin/lsattr -El ${IBM_CPU_ID} | grep ' POWER' >/dev/null 2>&1; then\n+\t\tIBM_ARCH=rs6000\n+\telse\n+\t\tIBM_ARCH=powerpc\n+\tfi\n+\tif [ -x /usr/bin/oslevel ] ; then\n+\t\tIBM_REV=`/usr/bin/oslevel`\n+\telse\n+\t\tIBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}\n+\tfi\n+\techo ${IBM_ARCH}-ibm-aix${IBM_REV}\n+\texit ;;\n+    *:AIX:*:*)\n+\techo rs6000-ibm-aix\n+\texit ;;\n+    ibmrt:4.4BSD:*|romp-ibm:BSD:*)\n+\techo romp-ibm-bsd4.4\n+\texit ;;\n+    ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC BSD and\n+\techo romp-ibm-bsd${UNAME_RELEASE}   # 4.3 with uname added to\n+\texit ;;                             # report: romp-ibm BSD 4.3\n+    *:BOSX:*:*)\n+\techo rs6000-bull-bosx\n+\texit ;;\n+    DPX/2?00:B.O.S.:*:*)\n+\techo m68k-bull-sysv3\n+\texit ;;\n+    9000/[34]??:4.3bsd:1.*:*)\n+\techo m68k-hp-bsd\n+\texit ;;\n+    hp300:4.4BSD:*:* | 9000/[34]??:4.3bsd:2.*:*)\n+\techo m68k-hp-bsd4.4\n+\texit ;;\n+    9000/[34678]??:HP-UX:*:*)\n+\tHPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`\n+\tcase \"${UNAME_MACHINE}\" in\n+\t    9000/31? )            HP_ARCH=m68000 ;;\n+\t    9000/[34]?? )         HP_ARCH=m68k ;;\n+\t    9000/[678][0-9][0-9])\n+\t\tif [ -x /usr/bin/getconf ]; then\n+\t\t    sc_cpu_version=`/usr/bin/getconf SC_CPU_VERSION 2>/dev/null`\n+\t\t    sc_kernel_bits=`/usr/bin/getconf SC_KERNEL_BITS 2>/dev/null`\n+\t\t    case \"${sc_cpu_version}\" in\n+\t\t      523) HP_ARCH=\"hppa1.0\" ;; # CPU_PA_RISC1_0\n+\t\t      528) HP_ARCH=\"hppa1.1\" ;; # CPU_PA_RISC1_1\n+\t\t      532)                      # CPU_PA_RISC2_0\n+\t\t\tcase \"${sc_kernel_bits}\" in\n+\t\t\t  32) HP_ARCH=\"hppa2.0n\" ;;\n+\t\t\t  64) HP_ARCH=\"hppa2.0w\" ;;\n+\t\t\t  '') HP_ARCH=\"hppa2.0\" ;;   # HP-UX 10.20\n+\t\t\tesac ;;\n+\t\t    esac\n+\t\tfi\n+\t\tif [ \"${HP_ARCH}\" = \"\" ]; then\n+\t\t    eval $set_cc_for_build\n+\t\t    sed 's/^\t\t//' << EOF >$dummy.c\n+\n+\t\t#define _HPUX_SOURCE\n+\t\t#include <stdlib.h>\n+\t\t#include <unistd.h>\n+\n+\t\tint main ()\n+\t\t{\n+\t\t#if defined(_SC_KERNEL_BITS)\n+\t\t    long bits = sysconf(_SC_KERNEL_BITS);\n+\t\t#endif\n+\t\t    long cpu  = sysconf (_SC_CPU_VERSION);\n+\n+\t\t    switch (cpu)\n+\t\t\t{\n+\t\t\tcase CPU_PA_RISC1_0: puts (\"hppa1.0\"); break;\n+\t\t\tcase CPU_PA_RISC1_1: puts (\"hppa1.1\"); break;\n+\t\t\tcase CPU_PA_RISC2_0:\n+\t\t#if defined(_SC_KERNEL_BITS)\n+\t\t\t    switch (bits)\n+\t\t\t\t{\n+\t\t\t\tcase 64: puts (\"hppa2.0w\"); break;\n+\t\t\t\tcase 32: puts (\"hppa2.0n\"); break;\n+\t\t\t\tdefault: puts (\"hppa2.0\"); break;\n+\t\t\t\t} break;\n+\t\t#else  /* !defined(_SC_KERNEL_BITS) */\n+\t\t\t    puts (\"hppa2.0\"); break;\n+\t\t#endif\n+\t\t\tdefault: puts (\"hppa1.0\"); break;\n+\t\t\t}\n+\t\t    exit (0);\n+\t\t}\n+EOF\n+\t\t    (CCOPTS= $CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null) && HP_ARCH=`$dummy`\n+\t\t    test -z \"$HP_ARCH\" && HP_ARCH=hppa\n+\t\tfi ;;\n+\tesac\n+\tif [ ${HP_ARCH} = \"hppa2.0w\" ]\n+\tthen\n+\t    eval $set_cc_for_build\n+\n+\t    # hppa2.0w-hp-hpux* has a 64-bit kernel and a compiler generating\n+\t    # 32-bit code.  hppa64-hp-hpux* has the same kernel and a compiler\n+\t    # generating 64-bit code.  GNU and HP use different nomenclature:\n+\t    #\n+\t    # $ CC_FOR_BUILD=cc ./config.guess\n+\t    # => hppa2.0w-hp-hpux11.23\n+\t    # $ CC_FOR_BUILD=\"cc +DA2.0w\" ./config.guess\n+\t    # => hppa64-hp-hpux11.23\n+\n+\t    if echo __LP64__ | (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) |\n+\t\tgrep -q __LP64__\n+\t    then\n+\t\tHP_ARCH=\"hppa2.0w\"\n+\t    else\n+\t\tHP_ARCH=\"hppa64\"\n+\t    fi\n+\tfi\n+\techo ${HP_ARCH}-hp-hpux${HPUX_REV}\n+\texit ;;\n+    ia64:HP-UX:*:*)\n+\tHPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`\n+\techo ia64-hp-hpux${HPUX_REV}\n+\texit ;;\n+    3050*:HI-UX:*:*)\n+\teval $set_cc_for_build\n+\tsed 's/^\t//' << EOF >$dummy.c\n+\t#include <unistd.h>\n+\tint\n+\tmain ()\n+\t{\n+\t  long cpu = sysconf (_SC_CPU_VERSION);\n+\t  /* The order matters, because CPU_IS_HP_MC68K erroneously returns\n+\t     true for CPU_PA_RISC1_0.  CPU_IS_PA_RISC returns correct\n+\t     results, however.  */\n+\t  if (CPU_IS_PA_RISC (cpu))\n+\t    {\n+\t      switch (cpu)\n+\t\t{\n+\t\t  case CPU_PA_RISC1_0: puts (\"hppa1.0-hitachi-hiuxwe2\"); break;\n+\t\t  case CPU_PA_RISC1_1: puts (\"hppa1.1-hitachi-hiuxwe2\"); break;\n+\t\t  case CPU_PA_RISC2_0: puts (\"hppa2.0-hitachi-hiuxwe2\"); break;\n+\t\t  default: puts (\"hppa-hitachi-hiuxwe2\"); break;\n+\t\t}\n+\t    }\n+\t  else if (CPU_IS_HP_MC68K (cpu))\n+\t    puts (\"m68k-hitachi-hiuxwe2\");\n+\t  else puts (\"unknown-hitachi-hiuxwe2\");\n+\t  exit (0);\n+\t}\n+EOF\n+\t$CC_FOR_BUILD -o $dummy $dummy.c && SYSTEM_NAME=`$dummy` &&\n+\t\t{ echo \"$SYSTEM_NAME\"; exit; }\n+\techo unknown-hitachi-hiuxwe2\n+\texit ;;\n+    9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:* )\n+\techo hppa1.1-hp-bsd\n+\texit ;;\n+    9000/8??:4.3bsd:*:*)\n+\techo hppa1.0-hp-bsd\n+\texit ;;\n+    *9??*:MPE/iX:*:* | *3000*:MPE/iX:*:*)\n+\techo hppa1.0-hp-mpeix\n+\texit ;;\n+    hp7??:OSF1:*:* | hp8?[79]:OSF1:*:* )\n+\techo hppa1.1-hp-osf\n+\texit ;;\n+    hp8??:OSF1:*:*)\n+\techo hppa1.0-hp-osf\n+\texit ;;\n+    i*86:OSF1:*:*)\n+\tif [ -x /usr/sbin/sysversion ] ; then\n+\t    echo ${UNAME_MACHINE}-unknown-osf1mk\n+\telse\n+\t    echo ${UNAME_MACHINE}-unknown-osf1\n+\tfi\n+\texit ;;\n+    parisc*:Lites*:*:*)\n+\techo hppa1.1-hp-lites\n+\texit ;;\n+    C1*:ConvexOS:*:* | convex:ConvexOS:C1*:*)\n+\techo c1-convex-bsd\n+\texit ;;\n+    C2*:ConvexOS:*:* | convex:ConvexOS:C2*:*)\n+\tif getsysinfo -f scalar_acc\n+\tthen echo c32-convex-bsd\n+\telse echo c2-convex-bsd\n+\tfi\n+\texit ;;\n+    C34*:ConvexOS:*:* | convex:ConvexOS:C34*:*)\n+\techo c34-convex-bsd\n+\texit ;;\n+    C38*:ConvexOS:*:* | convex:ConvexOS:C38*:*)\n+\techo c38-convex-bsd\n+\texit ;;\n+    C4*:ConvexOS:*:* | convex:ConvexOS:C4*:*)\n+\techo c4-convex-bsd\n+\texit ;;\n+    CRAY*Y-MP:*:*:*)\n+\techo ymp-cray-unicos${UNAME_RELEASE} | sed -e 's/\\.[^.]*$/.X/'\n+\texit ;;\n+    CRAY*[A-Z]90:*:*:*)\n+\techo ${UNAME_MACHINE}-cray-unicos${UNAME_RELEASE} \\\n+\t| sed -e 's/CRAY.*\\([A-Z]90\\)/\\1/' \\\n+\t      -e y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/ \\\n+\t      -e 's/\\.[^.]*$/.X/'\n+\texit ;;\n+    CRAY*TS:*:*:*)\n+\techo t90-cray-unicos${UNAME_RELEASE} | sed -e 's/\\.[^.]*$/.X/'\n+\texit ;;\n+    CRAY*T3E:*:*:*)\n+\techo alphaev5-cray-unicosmk${UNAME_RELEASE} | sed -e 's/\\.[^.]*$/.X/'\n+\texit ;;\n+    CRAY*SV1:*:*:*)\n+\techo sv1-cray-unicos${UNAME_RELEASE} | sed -e 's/\\.[^.]*$/.X/'\n+\texit ;;\n+    *:UNICOS/mp:*:*)\n+\techo craynv-cray-unicosmp${UNAME_RELEASE} | sed -e 's/\\.[^.]*$/.X/'\n+\texit ;;\n+    F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)\n+\tFUJITSU_PROC=`uname -m | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`\n+\tFUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\\///'`\n+\tFUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`\n+\techo \"${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}\"\n+\texit ;;\n+    5000:UNIX_System_V:4.*:*)\n+\tFUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\\///'`\n+\tFUJITSU_REL=`echo ${UNAME_RELEASE} | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/ /_/'`\n+\techo \"sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}\"\n+\texit ;;\n+    i*86:BSD/386:*:* | i*86:BSD/OS:*:* | *:Ascend\\ Embedded/OS:*:*)\n+\techo ${UNAME_MACHINE}-pc-bsdi${UNAME_RELEASE}\n+\texit ;;\n+    sparc*:BSD/OS:*:*)\n+\techo sparc-unknown-bsdi${UNAME_RELEASE}\n+\texit ;;\n+    *:BSD/OS:*:*)\n+\techo ${UNAME_MACHINE}-unknown-bsdi${UNAME_RELEASE}\n+\texit ;;\n+    *:FreeBSD:*:*)\n+\tUNAME_PROCESSOR=`/usr/bin/uname -p`\n+\tcase ${UNAME_PROCESSOR} in\n+\t    amd64)\n+\t\techo x86_64-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;\n+\t    *)\n+\t\techo ${UNAME_PROCESSOR}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;\n+\tesac\n+\texit ;;\n+    i*:CYGWIN*:*)\n+\techo ${UNAME_MACHINE}-pc-cygwin\n+\texit ;;\n+    *:MINGW*:*)\n+\techo ${UNAME_MACHINE}-pc-mingw32\n+\texit ;;\n+    i*:MSYS*:*)\n+\techo ${UNAME_MACHINE}-pc-msys\n+\texit ;;\n+    i*:windows32*:*)\n+\t# uname -m includes \"-pc\" on this system.\n+\techo ${UNAME_MACHINE}-mingw32\n+\texit ;;\n+    i*:PW*:*)\n+\techo ${UNAME_MACHINE}-pc-pw32\n+\texit ;;\n+    *:Interix*:*)\n+\tcase ${UNAME_MACHINE} in\n+\t    x86)\n+\t\techo i586-pc-interix${UNAME_RELEASE}\n+\t\texit ;;\n+\t    authenticamd | genuineintel | EM64T)\n+\t\techo x86_64-unknown-interix${UNAME_RELEASE}\n+\t\texit ;;\n+\t    IA64)\n+\t\techo ia64-unknown-interix${UNAME_RELEASE}\n+\t\texit ;;\n+\tesac ;;\n+    [345]86:Windows_95:* | [345]86:Windows_98:* | [345]86:Windows_NT:*)\n+\techo i${UNAME_MACHINE}-pc-mks\n+\texit ;;\n+    8664:Windows_NT:*)\n+\techo x86_64-pc-mks\n+\texit ;;\n+    i*:Windows_NT*:* | Pentium*:Windows_NT*:*)\n+\t# How do we know it's Interix rather than the generic POSIX subsystem?\n+\t# It also conflicts with pre-2.0 versions of AT&T UWIN. Should we\n+\t# UNAME_MACHINE based on the output of uname instead of i386?\n+\techo i586-pc-interix\n+\texit ;;\n+    i*:UWIN*:*)\n+\techo ${UNAME_MACHINE}-pc-uwin\n+\texit ;;\n+    amd64:CYGWIN*:*:* | x86_64:CYGWIN*:*:*)\n+\techo x86_64-unknown-cygwin\n+\texit ;;\n+    p*:CYGWIN*:*)\n+\techo powerpcle-unknown-cygwin\n+\texit ;;\n+    prep*:SunOS:5.*:*)\n+\techo powerpcle-unknown-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`\n+\texit ;;\n+    *:GNU:*:*)\n+\t# the GNU system\n+\techo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-gnu`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`\n+\texit ;;\n+    *:GNU/*:*:*)\n+\t# other systems with GNU libc and userland\n+\techo ${UNAME_MACHINE}-unknown-`echo ${UNAME_SYSTEM} | sed 's,^[^/]*/,,' | tr '[A-Z]' '[a-z]'``echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`-gnu\n+\texit ;;\n+    i*86:Minix:*:*)\n+\techo ${UNAME_MACHINE}-pc-minix\n+\texit ;;\n+    aarch64:Linux:*:*)\n+\techo ${UNAME_MACHINE}-unknown-linux-gnu\n+\texit ;;\n+    aarch64_be:Linux:*:*)\n+\tUNAME_MACHINE=aarch64_be\n+\techo ${UNAME_MACHINE}-unknown-linux-gnu\n+\texit ;;\n+    alpha:Linux:*:*)\n+\tcase `sed -n '/^cpu model/s/^.*: \\(.*\\)/\\1/p' < /proc/cpuinfo` in\n+\t  EV5)   UNAME_MACHINE=alphaev5 ;;\n+\t  EV56)  UNAME_MACHINE=alphaev56 ;;\n+\t  PCA56) UNAME_MACHINE=alphapca56 ;;\n+\t  PCA57) UNAME_MACHINE=alphapca56 ;;\n+\t  EV6)   UNAME_MACHINE=alphaev6 ;;\n+\t  EV67)  UNAME_MACHINE=alphaev67 ;;\n+\t  EV68*) UNAME_MACHINE=alphaev68 ;;\n+\tesac\n+\tobjdump --private-headers /bin/sh | grep -q ld.so.1\n+\tif test \"$?\" = 0 ; then LIBC=\"libc1\" ; else LIBC=\"\" ; fi\n+\techo ${UNAME_MACHINE}-unknown-linux-gnu${LIBC}\n+\texit ;;\n+    arm*:Linux:*:*)\n+\teval $set_cc_for_build\n+\tif echo __ARM_EABI__ | $CC_FOR_BUILD -E - 2>/dev/null \\\n+\t    | grep -q __ARM_EABI__\n+\tthen\n+\t    echo ${UNAME_MACHINE}-unknown-linux-gnu\n+\telse\n+\t    if echo __ARM_PCS_VFP | $CC_FOR_BUILD -E - 2>/dev/null \\\n+\t\t| grep -q __ARM_PCS_VFP\n+\t    then\n+\t\techo ${UNAME_MACHINE}-unknown-linux-gnueabi\n+\t    else\n+\t\techo ${UNAME_MACHINE}-unknown-linux-gnueabihf\n+\t    fi\n+\tfi\n+\texit ;;\n+    avr32*:Linux:*:*)\n+\techo ${UNAME_MACHINE}-unknown-linux-gnu\n+\texit ;;\n+    cris:Linux:*:*)\n+\techo ${UNAME_MACHINE}-axis-linux-gnu\n+\texit ;;\n+    crisv32:Linux:*:*)\n+\techo ${UNAME_MACHINE}-axis-linux-gnu\n+\texit ;;\n+    frv:Linux:*:*)\n+\techo ${UNAME_MACHINE}-unknown-linux-gnu\n+\texit ;;\n+    hexagon:Linux:*:*)\n+\techo ${UNAME_MACHINE}-unknown-linux-gnu\n+\texit ;;\n+    i*86:Linux:*:*)\n+\tLIBC=gnu\n+\teval $set_cc_for_build\n+\tsed 's/^\t//' << EOF >$dummy.c\n+\t#ifdef __dietlibc__\n+\tLIBC=dietlibc\n+\t#endif\n+EOF\n+\teval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^LIBC'`\n+\techo \"${UNAME_MACHINE}-pc-linux-${LIBC}\"\n+\texit ;;\n+    ia64:Linux:*:*)\n+\techo ${UNAME_MACHINE}-unknown-linux-gnu\n+\texit ;;\n+    m32r*:Linux:*:*)\n+\techo ${UNAME_MACHINE}-unknown-linux-gnu\n+\texit ;;\n+    m68*:Linux:*:*)\n+\techo ${UNAME_MACHINE}-unknown-linux-gnu\n+\texit ;;\n+    mips:Linux:*:* | mips64:Linux:*:*)\n+\teval $set_cc_for_build\n+\tsed 's/^\t//' << EOF >$dummy.c\n+\t#undef CPU\n+\t#undef ${UNAME_MACHINE}\n+\t#undef ${UNAME_MACHINE}el\n+\t#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)\n+\tCPU=${UNAME_MACHINE}el\n+\t#else\n+\t#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)\n+\tCPU=${UNAME_MACHINE}\n+\t#else\n+\tCPU=\n+\t#endif\n+\t#endif\n+EOF\n+\teval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^CPU'`\n+\ttest x\"${CPU}\" != x && { echo \"${CPU}-unknown-linux-gnu\"; exit; }\n+\t;;\n+    or32:Linux:*:*)\n+\techo ${UNAME_MACHINE}-unknown-linux-gnu\n+\texit ;;\n+    padre:Linux:*:*)\n+\techo sparc-unknown-linux-gnu\n+\texit ;;\n+    parisc64:Linux:*:* | hppa64:Linux:*:*)\n+\techo hppa64-unknown-linux-gnu\n+\texit ;;\n+    parisc:Linux:*:* | hppa:Linux:*:*)\n+\t# Look for CPU level\n+\tcase `grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2` in\n+\t  PA7*) echo hppa1.1-unknown-linux-gnu ;;\n+\t  PA8*) echo hppa2.0-unknown-linux-gnu ;;\n+\t  *)    echo hppa-unknown-linux-gnu ;;\n+\tesac\n+\texit ;;\n+    ppc64:Linux:*:*)\n+\techo powerpc64-unknown-linux-gnu\n+\texit ;;\n+    ppc:Linux:*:*)\n+\techo powerpc-unknown-linux-gnu\n+\texit ;;\n+    s390:Linux:*:* | s390x:Linux:*:*)\n+\techo ${UNAME_MACHINE}-ibm-linux\n+\texit ;;\n+    sh64*:Linux:*:*)\n+\techo ${UNAME_MACHINE}-unknown-linux-gnu\n+\texit ;;\n+    sh*:Linux:*:*)\n+\techo ${UNAME_MACHINE}-unknown-linux-gnu\n+\texit ;;\n+    sparc:Linux:*:* | sparc64:Linux:*:*)\n+\techo ${UNAME_MACHINE}-unknown-linux-gnu\n+\texit ;;\n+    tile*:Linux:*:*)\n+\techo ${UNAME_MACHINE}-unknown-linux-gnu\n+\texit ;;\n+    vax:Linux:*:*)\n+\techo ${UNAME_MACHINE}-dec-linux-gnu\n+\texit ;;\n+    x86_64:Linux:*:*)\n+\techo ${UNAME_MACHINE}-unknown-linux-gnu\n+\texit ;;\n+    xtensa*:Linux:*:*)\n+\techo ${UNAME_MACHINE}-unknown-linux-gnu\n+\texit ;;\n+    i*86:DYNIX/ptx:4*:*)\n+\t# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.\n+\t# earlier versions are messed up and put the nodename in both\n+\t# sysname and nodename.\n+\techo i386-sequent-sysv4\n+\texit ;;\n+    i*86:UNIX_SV:4.2MP:2.*)\n+\t# Unixware is an offshoot of SVR4, but it has its own version\n+\t# number series starting with 2...\n+\t# I am not positive that other SVR4 systems won't match this,\n+\t# I just have to hope.  -- rms.\n+\t# Use sysv4.2uw... so that sysv4* matches it.\n+\techo ${UNAME_MACHINE}-pc-sysv4.2uw${UNAME_VERSION}\n+\texit ;;\n+    i*86:OS/2:*:*)\n+\t# If we were able to find `uname', then EMX Unix compatibility\n+\t# is probably installed.\n+\techo ${UNAME_MACHINE}-pc-os2-emx\n+\texit ;;\n+    i*86:XTS-300:*:STOP)\n+\techo ${UNAME_MACHINE}-unknown-stop\n+\texit ;;\n+    i*86:atheos:*:*)\n+\techo ${UNAME_MACHINE}-unknown-atheos\n+\texit ;;\n+    i*86:syllable:*:*)\n+\techo ${UNAME_MACHINE}-pc-syllable\n+\texit ;;\n+    i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.[02]*:*)\n+\techo i386-unknown-lynxos${UNAME_RELEASE}\n+\texit ;;\n+    i*86:*DOS:*:*)\n+\techo ${UNAME_MACHINE}-pc-msdosdjgpp\n+\texit ;;\n+    i*86:*:4.*:* | i*86:SYSTEM_V:4.*:*)\n+\tUNAME_REL=`echo ${UNAME_RELEASE} | sed 's/\\/MP$//'`\n+\tif grep Novell /usr/include/link.h >/dev/null 2>/dev/null; then\n+\t\techo ${UNAME_MACHINE}-univel-sysv${UNAME_REL}\n+\telse\n+\t\techo ${UNAME_MACHINE}-pc-sysv${UNAME_REL}\n+\tfi\n+\texit ;;\n+    i*86:*:5:[678]*)\n+\t# UnixWare 7.x, OpenUNIX and OpenServer 6.\n+\tcase `/bin/uname -X | grep \"^Machine\"` in\n+\t    *486*)\t     UNAME_MACHINE=i486 ;;\n+\t    *Pentium)\t     UNAME_MACHINE=i586 ;;\n+\t    *Pent*|*Celeron) UNAME_MACHINE=i686 ;;\n+\tesac\n+\techo ${UNAME_MACHINE}-unknown-sysv${UNAME_RELEASE}${UNAME_SYSTEM}${UNAME_VERSION}\n+\texit ;;\n+    i*86:*:3.2:*)\n+\tif test -f /usr/options/cb.name; then\n+\t\tUNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`\n+\t\techo ${UNAME_MACHINE}-pc-isc$UNAME_REL\n+\telif /bin/uname -X 2>/dev/null >/dev/null ; then\n+\t\tUNAME_REL=`(/bin/uname -X|grep Release|sed -e 's/.*= //')`\n+\t\t(/bin/uname -X|grep i80486 >/dev/null) && UNAME_MACHINE=i486\n+\t\t(/bin/uname -X|grep '^Machine.*Pentium' >/dev/null) \\\n+\t\t\t&& UNAME_MACHINE=i586\n+\t\t(/bin/uname -X|grep '^Machine.*Pent *II' >/dev/null) \\\n+\t\t\t&& UNAME_MACHINE=i686\n+\t\t(/bin/uname -X|grep '^Machine.*Pentium Pro' >/dev/null) \\\n+\t\t\t&& UNAME_MACHINE=i686\n+\t\techo ${UNAME_MACHINE}-pc-sco$UNAME_REL\n+\telse\n+\t\techo ${UNAME_MACHINE}-pc-sysv32\n+\tfi\n+\texit ;;\n+    pc:*:*:*)\n+\t# Left here for compatibility:\n+\t# uname -m prints for DJGPP always 'pc', but it prints nothing about\n+\t# the processor, so we play safe by assuming i586.\n+\t# Note: whatever this is, it MUST be the same as what config.sub\n+\t# prints for the \"djgpp\" host, or else GDB configury will decide that\n+\t# this is a cross-build.\n+\techo i586-pc-msdosdjgpp\n+\texit ;;\n+    Intel:Mach:3*:*)\n+\techo i386-pc-mach3\n+\texit ;;\n+    paragon:*:*:*)\n+\techo i860-intel-osf1\n+\texit ;;\n+    i860:*:4.*:*) # i860-SVR4\n+\tif grep Stardent /usr/include/sys/uadmin.h >/dev/null 2>&1 ; then\n+\t  echo i860-stardent-sysv${UNAME_RELEASE} # Stardent Vistra i860-SVR4\n+\telse # Add other i860-SVR4 vendors below as they are discovered.\n+\t  echo i860-unknown-sysv${UNAME_RELEASE}  # Unknown i860-SVR4\n+\tfi\n+\texit ;;\n+    mini*:CTIX:SYS*5:*)\n+\t# \"miniframe\"\n+\techo m68010-convergent-sysv\n+\texit ;;\n+    mc68k:UNIX:SYSTEM5:3.51m)\n+\techo m68k-convergent-sysv\n+\texit ;;\n+    M680?0:D-NIX:5.3:*)\n+\techo m68k-diab-dnix\n+\texit ;;\n+    M68*:*:R3V[5678]*:*)\n+\ttest -r /sysV68 && { echo 'm68k-motorola-sysv'; exit; } ;;\n+    3[345]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 3[34]??/*:*:4.0:3.0 | 4400:*:4.0:3.0 | 4850:*:4.0:3.0 | SKA40:*:4.0:3.0 | SDS2:*:4.0:3.0 | SHG2:*:4.0:3.0 | S7501*:*:4.0:3.0)\n+\tOS_REL=''\n+\ttest -r /etc/.relid \\\n+\t&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \\([0-9][0-9]\\).*/\\1/p' < /etc/.relid`\n+\t/bin/uname -p 2>/dev/null | grep 86 >/dev/null \\\n+\t  && { echo i486-ncr-sysv4.3${OS_REL}; exit; }\n+\t/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \\\n+\t  && { echo i586-ncr-sysv4.3${OS_REL}; exit; } ;;\n+    3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)\n+\t/bin/uname -p 2>/dev/null | grep 86 >/dev/null \\\n+\t  && { echo i486-ncr-sysv4; exit; } ;;\n+    NCR*:*:4.2:* | MPRAS*:*:4.2:*)\n+\tOS_REL='.3'\n+\ttest -r /etc/.relid \\\n+\t    && OS_REL=.`sed -n 's/[^ ]* [^ ]* \\([0-9][0-9]\\).*/\\1/p' < /etc/.relid`\n+\t/bin/uname -p 2>/dev/null | grep 86 >/dev/null \\\n+\t    && { echo i486-ncr-sysv4.3${OS_REL}; exit; }\n+\t/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \\\n+\t    && { echo i586-ncr-sysv4.3${OS_REL}; exit; }\n+\t/bin/uname -p 2>/dev/null | /bin/grep pteron >/dev/null \\\n+\t    && { echo i586-ncr-sysv4.3${OS_REL}; exit; } ;;\n+    m68*:LynxOS:2.*:* | m68*:LynxOS:3.0*:*)\n+\techo m68k-unknown-lynxos${UNAME_RELEASE}\n+\texit ;;\n+    mc68030:UNIX_System_V:4.*:*)\n+\techo m68k-atari-sysv4\n+\texit ;;\n+    TSUNAMI:LynxOS:2.*:*)\n+\techo sparc-unknown-lynxos${UNAME_RELEASE}\n+\texit ;;\n+    rs6000:LynxOS:2.*:*)\n+\techo rs6000-unknown-lynxos${UNAME_RELEASE}\n+\texit ;;\n+    PowerPC:LynxOS:2.*:* | PowerPC:LynxOS:3.[01]*:* | PowerPC:LynxOS:4.[02]*:*)\n+\techo powerpc-unknown-lynxos${UNAME_RELEASE}\n+\texit ;;\n+    SM[BE]S:UNIX_SV:*:*)\n+\techo mips-dde-sysv${UNAME_RELEASE}\n+\texit ;;\n+    RM*:ReliantUNIX-*:*:*)\n+\techo mips-sni-sysv4\n+\texit ;;\n+    RM*:SINIX-*:*:*)\n+\techo mips-sni-sysv4\n+\texit ;;\n+    *:SINIX-*:*:*)\n+\tif uname -p 2>/dev/null >/dev/null ; then\n+\t\tUNAME_MACHINE=`(uname -p) 2>/dev/null`\n+\t\techo ${UNAME_MACHINE}-sni-sysv4\n+\telse\n+\t\techo ns32k-sni-sysv\n+\tfi\n+\texit ;;\n+    PENTIUM:*:4.0*:*)\t# Unisys `ClearPath HMP IX 4000' SVR4/MP effort\n+\t\t\t# says <Richard.M.Bartel@ccMail.Census.GOV>\n+\techo i586-unisys-sysv4\n+\texit ;;\n+    *:UNIX_System_V:4*:FTX*)\n+\t# From Gerald Hewes <hewes@openmarket.com>.\n+\t# How about differentiating between stratus architectures? -djm\n+\techo hppa1.1-stratus-sysv4\n+\texit ;;\n+    *:*:*:FTX*)\n+\t# From seanf@swdc.stratus.com.\n+\techo i860-stratus-sysv4\n+\texit ;;\n+    i*86:VOS:*:*)\n+\t# From Paul.Green@stratus.com.\n+\techo ${UNAME_MACHINE}-stratus-vos\n+\texit ;;\n+    *:VOS:*:*)\n+\t# From Paul.Green@stratus.com.\n+\techo hppa1.1-stratus-vos\n+\texit ;;\n+    mc68*:A/UX:*:*)\n+\techo m68k-apple-aux${UNAME_RELEASE}\n+\texit ;;\n+    news*:NEWS-OS:6*:*)\n+\techo mips-sony-newsos6\n+\texit ;;\n+    R[34]000:*System_V*:*:* | R4000:UNIX_SYSV:*:* | R*000:UNIX_SV:*:*)\n+\tif [ -d /usr/nec ]; then\n+\t\techo mips-nec-sysv${UNAME_RELEASE}\n+\telse\n+\t\techo mips-unknown-sysv${UNAME_RELEASE}\n+\tfi\n+\texit ;;\n+    BeBox:BeOS:*:*)\t# BeOS running on hardware made by Be, PPC only.\n+\techo powerpc-be-beos\n+\texit ;;\n+    BeMac:BeOS:*:*)\t# BeOS running on Mac or Mac clone, PPC only.\n+\techo powerpc-apple-beos\n+\texit ;;\n+    BePC:BeOS:*:*)\t# BeOS running on Intel PC compatible.\n+\techo i586-pc-beos\n+\texit ;;\n+    BePC:Haiku:*:*)\t# Haiku running on Intel PC compatible.\n+\techo i586-pc-haiku\n+\texit ;;\n+    SX-4:SUPER-UX:*:*)\n+\techo sx4-nec-superux${UNAME_RELEASE}\n+\texit ;;\n+    SX-5:SUPER-UX:*:*)\n+\techo sx5-nec-superux${UNAME_RELEASE}\n+\texit ;;\n+    SX-6:SUPER-UX:*:*)\n+\techo sx6-nec-superux${UNAME_RELEASE}\n+\texit ;;\n+    SX-7:SUPER-UX:*:*)\n+\techo sx7-nec-superux${UNAME_RELEASE}\n+\texit ;;\n+    SX-8:SUPER-UX:*:*)\n+\techo sx8-nec-superux${UNAME_RELEASE}\n+\texit ;;\n+    SX-8R:SUPER-UX:*:*)\n+\techo sx8r-nec-superux${UNAME_RELEASE}\n+\texit ;;\n+    Power*:Rhapsody:*:*)\n+\techo powerpc-apple-rhapsody${UNAME_RELEASE}\n+\texit ;;\n+    *:Rhapsody:*:*)\n+\techo ${UNAME_MACHINE}-apple-rhapsody${UNAME_RELEASE}\n+\texit ;;\n+    *:Darwin:*:*)\n+\tUNAME_PROCESSOR=`uname -p` || UNAME_PROCESSOR=unknown\n+\tcase $UNAME_PROCESSOR in\n+\t    i386)\n+\t\teval $set_cc_for_build\n+\t\tif [ \"$CC_FOR_BUILD\" != 'no_compiler_found' ]; then\n+\t\t  if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \\\n+\t\t      (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) | \\\n+\t\t      grep IS_64BIT_ARCH >/dev/null\n+\t\t  then\n+\t\t      UNAME_PROCESSOR=\"x86_64\"\n+\t\t  fi\n+\t\tfi ;;\n+\t    unknown) UNAME_PROCESSOR=powerpc ;;\n+\tesac\n+\techo ${UNAME_PROCESSOR}-apple-darwin${UNAME_RELEASE}\n+\texit ;;\n+    *:procnto*:*:* | *:QNX:[0123456789]*:*)\n+\tUNAME_PROCESSOR=`uname -p`\n+\tif test \"$UNAME_PROCESSOR\" = \"x86\"; then\n+\t\tUNAME_PROCESSOR=i386\n+\t\tUNAME_MACHINE=pc\n+\tfi\n+\techo ${UNAME_PROCESSOR}-${UNAME_MACHINE}-nto-qnx${UNAME_RELEASE}\n+\texit ;;\n+    *:QNX:*:4*)\n+\techo i386-pc-qnx\n+\texit ;;\n+    NEO-?:NONSTOP_KERNEL:*:*)\n+\techo neo-tandem-nsk${UNAME_RELEASE}\n+\texit ;;\n+    NSE-?:NONSTOP_KERNEL:*:*)\n+\techo nse-tandem-nsk${UNAME_RELEASE}\n+\texit ;;\n+    NSR-?:NONSTOP_KERNEL:*:*)\n+\techo nsr-tandem-nsk${UNAME_RELEASE}\n+\texit ;;\n+    *:NonStop-UX:*:*)\n+\techo mips-compaq-nonstopux\n+\texit ;;\n+    BS2000:POSIX*:*:*)\n+\techo bs2000-siemens-sysv\n+\texit ;;\n+    DS/*:UNIX_System_V:*:*)\n+\techo ${UNAME_MACHINE}-${UNAME_SYSTEM}-${UNAME_RELEASE}\n+\texit ;;\n+    *:Plan9:*:*)\n+\t# \"uname -m\" is not consistent, so use $cputype instead. 386\n+\t# is converted to i386 for consistency with other x86\n+\t# operating systems.\n+\tif test \"$cputype\" = \"386\"; then\n+\t    UNAME_MACHINE=i386\n+\telse\n+\t    UNAME_MACHINE=\"$cputype\"\n+\tfi\n+\techo ${UNAME_MACHINE}-unknown-plan9\n+\texit ;;\n+    *:TOPS-10:*:*)\n+\techo pdp10-unknown-tops10\n+\texit ;;\n+    *:TENEX:*:*)\n+\techo pdp10-unknown-tenex\n+\texit ;;\n+    KS10:TOPS-20:*:* | KL10:TOPS-20:*:* | TYPE4:TOPS-20:*:*)\n+\techo pdp10-dec-tops20\n+\texit ;;\n+    XKL-1:TOPS-20:*:* | TYPE5:TOPS-20:*:*)\n+\techo pdp10-xkl-tops20\n+\texit ;;\n+    *:TOPS-20:*:*)\n+\techo pdp10-unknown-tops20\n+\texit ;;\n+    *:ITS:*:*)\n+\techo pdp10-unknown-its\n+\texit ;;\n+    SEI:*:*:SEIUX)\n+\techo mips-sei-seiux${UNAME_RELEASE}\n+\texit ;;\n+    *:DragonFly:*:*)\n+\techo ${UNAME_MACHINE}-unknown-dragonfly`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`\n+\texit ;;\n+    *:*VMS:*:*)\n+\tUNAME_MACHINE=`(uname -p) 2>/dev/null`\n+\tcase \"${UNAME_MACHINE}\" in\n+\t    A*) echo alpha-dec-vms ; exit ;;\n+\t    I*) echo ia64-dec-vms ; exit ;;\n+\t    V*) echo vax-dec-vms ; exit ;;\n+\tesac ;;\n+    *:XENIX:*:SysV)\n+\techo i386-pc-xenix\n+\texit ;;\n+    i*86:skyos:*:*)\n+\techo ${UNAME_MACHINE}-pc-skyos`echo ${UNAME_RELEASE}` | sed -e 's/ .*$//'\n+\texit ;;\n+    i*86:rdos:*:*)\n+\techo ${UNAME_MACHINE}-pc-rdos\n+\texit ;;\n+    i*86:AROS:*:*)\n+\techo ${UNAME_MACHINE}-pc-aros\n+\texit ;;\n+    x86_64:VMkernel:*:*)\n+\techo ${UNAME_MACHINE}-unknown-esx\n+\texit ;;\n+esac\n+\n+#echo '(No uname command or uname output not recognized.)' 1>&2\n+#echo \"${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}\" 1>&2\n+\n+eval $set_cc_for_build\n+cat >$dummy.c <<EOF\n+#ifdef _SEQUENT_\n+# include <sys/types.h>\n+# include <sys/utsname.h>\n+#endif\n+main ()\n+{\n+#if defined (sony)\n+#if defined (MIPSEB)\n+  /* BFD wants \"bsd\" instead of \"newsos\".  Perhaps BFD should be changed,\n+     I don't know....  */\n+  printf (\"mips-sony-bsd\\n\"); exit (0);\n+#else\n+#include <sys/param.h>\n+  printf (\"m68k-sony-newsos%s\\n\",\n+#ifdef NEWSOS4\n+\t\"4\"\n+#else\n+\t\"\"\n+#endif\n+\t); exit (0);\n+#endif\n+#endif\n+\n+#if defined (__arm) && defined (__acorn) && defined (__unix)\n+  printf (\"arm-acorn-riscix\\n\"); exit (0);\n+#endif\n+\n+#if defined (hp300) && !defined (hpux)\n+  printf (\"m68k-hp-bsd\\n\"); exit (0);\n+#endif\n+\n+#if defined (NeXT)\n+#if !defined (__ARCHITECTURE__)\n+#define __ARCHITECTURE__ \"m68k\"\n+#endif\n+  int version;\n+  version=`(hostinfo | sed -n 's/.*NeXT Mach \\([0-9]*\\).*/\\1/p') 2>/dev/null`;\n+  if (version < 4)\n+    printf (\"%s-next-nextstep%d\\n\", __ARCHITECTURE__, version);\n+  else\n+    printf (\"%s-next-openstep%d\\n\", __ARCHITECTURE__, version);\n+  exit (0);\n+#endif\n+\n+#if defined (MULTIMAX) || defined (n16)\n+#if defined (UMAXV)\n+  printf (\"ns32k-encore-sysv\\n\"); exit (0);\n+#else\n+#if defined (CMU)\n+  printf (\"ns32k-encore-mach\\n\"); exit (0);\n+#else\n+  printf (\"ns32k-encore-bsd\\n\"); exit (0);\n+#endif\n+#endif\n+#endif\n+\n+#if defined (__386BSD__)\n+  printf (\"i386-pc-bsd\\n\"); exit (0);\n+#endif\n+\n+#if defined (sequent)\n+#if defined (i386)\n+  printf (\"i386-sequent-dynix\\n\"); exit (0);\n+#endif\n+#if defined (ns32000)\n+  printf (\"ns32k-sequent-dynix\\n\"); exit (0);\n+#endif\n+#endif\n+\n+#if defined (_SEQUENT_)\n+    struct utsname un;\n+\n+    uname(&un);\n+\n+    if (strncmp(un.version, \"V2\", 2) == 0) {\n+\tprintf (\"i386-sequent-ptx2\\n\"); exit (0);\n+    }\n+    if (strncmp(un.version, \"V1\", 2) == 0) { /* XXX is V1 correct? */\n+\tprintf (\"i386-sequent-ptx1\\n\"); exit (0);\n+    }\n+    printf (\"i386-sequent-ptx\\n\"); exit (0);\n+\n+#endif\n+\n+#if defined (vax)\n+# if !defined (ultrix)\n+#  include <sys/param.h>\n+#  if defined (BSD)\n+#   if BSD == 43\n+      printf (\"vax-dec-bsd4.3\\n\"); exit (0);\n+#   else\n+#    if BSD == 199006\n+      printf (\"vax-dec-bsd4.3reno\\n\"); exit (0);\n+#    else\n+      printf (\"vax-dec-bsd\\n\"); exit (0);\n+#    endif\n+#   endif\n+#  else\n+    printf (\"vax-dec-bsd\\n\"); exit (0);\n+#  endif\n+# else\n+    printf (\"vax-dec-ultrix\\n\"); exit (0);\n+# endif\n+#endif\n+\n+#if defined (alliant) && defined (i860)\n+  printf (\"i860-alliant-bsd\\n\"); exit (0);\n+#endif\n+\n+  exit (1);\n+}\n+EOF\n+\n+$CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null && SYSTEM_NAME=`$dummy` &&\n+\t{ echo \"$SYSTEM_NAME\"; exit; }\n+\n+# Apollos put the system type in the environment.\n+\n+test -d /usr/apollo && { echo ${ISP}-apollo-${SYSTYPE}; exit; }\n+\n+# Convex versions that predate uname can use getsysinfo(1)\n+\n+if [ -x /usr/convex/getsysinfo ]\n+then\n+    case `getsysinfo -f cpu_type` in\n+    c1*)\n+\techo c1-convex-bsd\n+\texit ;;\n+    c2*)\n+\tif getsysinfo -f scalar_acc\n+\tthen echo c32-convex-bsd\n+\telse echo c2-convex-bsd\n+\tfi\n+\texit ;;\n+    c34*)\n+\techo c34-convex-bsd\n+\texit ;;\n+    c38*)\n+\techo c38-convex-bsd\n+\texit ;;\n+    c4*)\n+\techo c4-convex-bsd\n+\texit ;;\n+    esac\n+fi\n+\n+cat >&2 <<EOF\n+$0: unable to guess system type\n+\n+This script, last modified $timestamp, has failed to recognize\n+the operating system you are using. It is advised that you\n+download the most up to date version of the config scripts from\n+\n+  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD\n+and\n+  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub;hb=HEAD\n+\n+If the version you run ($0) is already up to date, please\n+send the following data and any information you think might be\n+pertinent to <config-patches@gnu.org> in order to provide the needed\n+information to handle your system.\n+\n+config.guess timestamp = $timestamp\n+\n+uname -m = `(uname -m) 2>/dev/null || echo unknown`\n+uname -r = `(uname -r) 2>/dev/null || echo unknown`\n+uname -s = `(uname -s) 2>/dev/null || echo unknown`\n+uname -v = `(uname -v) 2>/dev/null || echo unknown`\n+\n+/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null`\n+/bin/uname -X     = `(/bin/uname -X) 2>/dev/null`\n+\n+hostinfo               = `(hostinfo) 2>/dev/null`\n+/bin/universe          = `(/bin/universe) 2>/dev/null`\n+/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null`\n+/bin/arch              = `(/bin/arch) 2>/dev/null`\n+/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null`\n+/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null`\n+\n+UNAME_MACHINE = ${UNAME_MACHINE}\n+UNAME_RELEASE = ${UNAME_RELEASE}\n+UNAME_SYSTEM  = ${UNAME_SYSTEM}\n+UNAME_VERSION = ${UNAME_VERSION}\n+EOF\n+\n+exit 1\n+\n+# Local variables:\n+# eval: (add-hook 'write-file-hooks 'time-stamp)\n+# time-stamp-start: \"timestamp='\"\n+# time-stamp-format: \"%:y-%02m-%02d\"\n+# time-stamp-end: \"'\"\n+# End:"}, {"sha": "c894da45500c4af1bf5688e713a8895622d18182", "filename": "libsanitizer/config.sub", "status": "added", "additions": 1773, "deletions": 0, "changes": 1773, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fconfig.sub", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fconfig.sub", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fconfig.sub?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,1773 @@\n+#! /bin/sh\n+# Configuration validation subroutine script.\n+#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n+#   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n+#   2011, 2012 Free Software Foundation, Inc.\n+\n+timestamp='2012-02-10'\n+\n+# This file is (in principle) common to ALL GNU software.\n+# The presence of a machine in this file suggests that SOME GNU software\n+# can handle that machine.  It does not imply ALL GNU software can.\n+#\n+# This file is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, see <http://www.gnu.org/licenses/>.\n+#\n+# As a special exception to the GNU General Public License, if you\n+# distribute this file as part of a program that contains a\n+# configuration script generated by Autoconf, you may include it under\n+# the same distribution terms that you use for the rest of that program.\n+\n+\n+# Please send patches to <config-patches@gnu.org>.  Submit a context\n+# diff and a properly formatted GNU ChangeLog entry.\n+#\n+# Configuration subroutine to validate and canonicalize a configuration type.\n+# Supply the specified configuration type as an argument.\n+# If it is invalid, we print an error message on stderr and exit with code 1.\n+# Otherwise, we print the canonical config type on stdout and succeed.\n+\n+# You can get the latest version of this script from:\n+# http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub;hb=HEAD\n+\n+# This file is supposed to be the same for all GNU packages\n+# and recognize all the CPU types, system types and aliases\n+# that are meaningful with *any* GNU software.\n+# Each package is responsible for reporting which valid configurations\n+# it does not support.  The user should be able to distinguish\n+# a failure to support a valid configuration from a meaningless\n+# configuration.\n+\n+# The goal of this file is to map all the various variations of a given\n+# machine specification into a single specification in the form:\n+#\tCPU_TYPE-MANUFACTURER-OPERATING_SYSTEM\n+# or in some cases, the newer four-part form:\n+#\tCPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM\n+# It is wrong to echo any other type of specification.\n+\n+me=`echo \"$0\" | sed -e 's,.*/,,'`\n+\n+usage=\"\\\n+Usage: $0 [OPTION] CPU-MFR-OPSYS\n+       $0 [OPTION] ALIAS\n+\n+Canonicalize a configuration name.\n+\n+Operation modes:\n+  -h, --help         print this help, then exit\n+  -t, --time-stamp   print date of last modification, then exit\n+  -v, --version      print version number, then exit\n+\n+Report bugs and patches to <config-patches@gnu.org>.\"\n+\n+version=\"\\\n+GNU config.sub ($timestamp)\n+\n+Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,\n+2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012\n+Free Software Foundation, Inc.\n+\n+This is free software; see the source for copying conditions.  There is NO\n+warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\"\n+\n+help=\"\n+Try \\`$me --help' for more information.\"\n+\n+# Parse command line\n+while test $# -gt 0 ; do\n+  case $1 in\n+    --time-stamp | --time* | -t )\n+       echo \"$timestamp\" ; exit ;;\n+    --version | -v )\n+       echo \"$version\" ; exit ;;\n+    --help | --h* | -h )\n+       echo \"$usage\"; exit ;;\n+    -- )     # Stop option processing\n+       shift; break ;;\n+    - )\t# Use stdin as input.\n+       break ;;\n+    -* )\n+       echo \"$me: invalid option $1$help\"\n+       exit 1 ;;\n+\n+    *local*)\n+       # First pass through any local machine types.\n+       echo $1\n+       exit ;;\n+\n+    * )\n+       break ;;\n+  esac\n+done\n+\n+case $# in\n+ 0) echo \"$me: missing argument$help\" >&2\n+    exit 1;;\n+ 1) ;;\n+ *) echo \"$me: too many arguments$help\" >&2\n+    exit 1;;\n+esac\n+\n+# Separate what the user gave into CPU-COMPANY and OS or KERNEL-OS (if any).\n+# Here we must recognize all the valid KERNEL-OS combinations.\n+maybe_os=`echo $1 | sed 's/^\\(.*\\)-\\([^-]*-[^-]*\\)$/\\2/'`\n+case $maybe_os in\n+  nto-qnx* | linux-gnu* | linux-android* | linux-dietlibc | linux-newlib* | \\\n+  linux-uclibc* | uclinux-uclibc* | uclinux-gnu* | kfreebsd*-gnu* | \\\n+  knetbsd*-gnu* | netbsd*-gnu* | \\\n+  kopensolaris*-gnu* | \\\n+  storm-chaos* | os2-emx* | rtmk-nova*)\n+    os=-$maybe_os\n+    basic_machine=`echo $1 | sed 's/^\\(.*\\)-\\([^-]*-[^-]*\\)$/\\1/'`\n+    ;;\n+  android-linux)\n+    os=-linux-android\n+    basic_machine=`echo $1 | sed 's/^\\(.*\\)-\\([^-]*-[^-]*\\)$/\\1/'`-unknown\n+    ;;\n+  *)\n+    basic_machine=`echo $1 | sed 's/-[^-]*$//'`\n+    if [ $basic_machine != $1 ]\n+    then os=`echo $1 | sed 's/.*-/-/'`\n+    else os=; fi\n+    ;;\n+esac\n+\n+### Let's recognize common machines as not being operating systems so\n+### that things like config.sub decstation-3100 work.  We also\n+### recognize some manufacturers as not being operating systems, so we\n+### can provide default operating systems below.\n+case $os in\n+\t-sun*os*)\n+\t\t# Prevent following clause from handling this invalid input.\n+\t\t;;\n+\t-dec* | -mips* | -sequent* | -encore* | -pc532* | -sgi* | -sony* | \\\n+\t-att* | -7300* | -3300* | -delta* | -motorola* | -sun[234]* | \\\n+\t-unicom* | -ibm* | -next | -hp | -isi* | -apollo | -altos* | \\\n+\t-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\\\n+\t-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \\\n+\t-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp | \\\n+\t-apple | -axis | -knuth | -cray | -microblaze)\n+\t\tos=\n+\t\tbasic_machine=$1\n+\t\t;;\n+\t-bluegene*)\n+\t\tos=-cnk\n+\t\t;;\n+\t-sim | -cisco | -oki | -wec | -winbond)\n+\t\tos=\n+\t\tbasic_machine=$1\n+\t\t;;\n+\t-scout)\n+\t\t;;\n+\t-wrs)\n+\t\tos=-vxworks\n+\t\tbasic_machine=$1\n+\t\t;;\n+\t-chorusos*)\n+\t\tos=-chorusos\n+\t\tbasic_machine=$1\n+\t\t;;\n+\t-chorusrdb)\n+\t\tos=-chorusrdb\n+\t\tbasic_machine=$1\n+\t\t;;\n+\t-hiux*)\n+\t\tos=-hiuxwe2\n+\t\t;;\n+\t-sco6)\n+\t\tos=-sco5v6\n+\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n+\t\t;;\n+\t-sco5)\n+\t\tos=-sco3.2v5\n+\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n+\t\t;;\n+\t-sco4)\n+\t\tos=-sco3.2v4\n+\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n+\t\t;;\n+\t-sco3.2.[4-9]*)\n+\t\tos=`echo $os | sed -e 's/sco3.2./sco3.2v/'`\n+\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n+\t\t;;\n+\t-sco3.2v[4-9]*)\n+\t\t# Don't forget version if it is 3.2v4 or newer.\n+\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n+\t\t;;\n+\t-sco5v6*)\n+\t\t# Don't forget version if it is 3.2v4 or newer.\n+\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n+\t\t;;\n+\t-sco*)\n+\t\tos=-sco3.2v2\n+\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n+\t\t;;\n+\t-udk*)\n+\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n+\t\t;;\n+\t-isc)\n+\t\tos=-isc2.2\n+\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n+\t\t;;\n+\t-clix*)\n+\t\tbasic_machine=clipper-intergraph\n+\t\t;;\n+\t-isc*)\n+\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n+\t\t;;\n+\t-lynx*)\n+\t\tos=-lynxos\n+\t\t;;\n+\t-ptx*)\n+\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-sequent/'`\n+\t\t;;\n+\t-windowsnt*)\n+\t\tos=`echo $os | sed -e 's/windowsnt/winnt/'`\n+\t\t;;\n+\t-psos*)\n+\t\tos=-psos\n+\t\t;;\n+\t-mint | -mint[0-9]*)\n+\t\tbasic_machine=m68k-atari\n+\t\tos=-mint\n+\t\t;;\n+esac\n+\n+# Decode aliases for certain CPU-COMPANY combinations.\n+case $basic_machine in\n+\t# Recognize the basic CPU types without company name.\n+\t# Some are omitted here because they have special meanings below.\n+\t1750a | 580 \\\n+\t| a29k \\\n+\t| aarch64 | aarch64_be \\\n+\t| alpha | alphaev[4-8] | alphaev56 | alphaev6[78] | alphapca5[67] \\\n+\t| alpha64 | alpha64ev[4-8] | alpha64ev56 | alpha64ev6[78] | alpha64pca5[67] \\\n+\t| am33_2.0 \\\n+\t| arc | arm | arm[bl]e | arme[lb] | armv[2345] | armv[345][lb] | avr | avr32 \\\n+        | be32 | be64 \\\n+\t| bfin \\\n+\t| c4x | clipper \\\n+\t| d10v | d30v | dlx | dsp16xx \\\n+\t| epiphany \\\n+\t| fido | fr30 | frv \\\n+\t| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \\\n+\t| hexagon \\\n+\t| i370 | i860 | i960 | ia64 \\\n+\t| ip2k | iq2000 \\\n+\t| le32 | le64 \\\n+\t| lm32 \\\n+\t| m32c | m32r | m32rle | m68000 | m68k | m88k \\\n+\t| maxq | mb | microblaze | mcore | mep | metag \\\n+\t| mips | mipsbe | mipseb | mipsel | mipsle \\\n+\t| mips16 \\\n+\t| mips64 | mips64el \\\n+\t| mips64octeon | mips64octeonel \\\n+\t| mips64orion | mips64orionel \\\n+\t| mips64r5900 | mips64r5900el \\\n+\t| mips64vr | mips64vrel \\\n+\t| mips64vr4100 | mips64vr4100el \\\n+\t| mips64vr4300 | mips64vr4300el \\\n+\t| mips64vr5000 | mips64vr5000el \\\n+\t| mips64vr5900 | mips64vr5900el \\\n+\t| mipsisa32 | mipsisa32el \\\n+\t| mipsisa32r2 | mipsisa32r2el \\\n+\t| mipsisa64 | mipsisa64el \\\n+\t| mipsisa64r2 | mipsisa64r2el \\\n+\t| mipsisa64sb1 | mipsisa64sb1el \\\n+\t| mipsisa64sr71k | mipsisa64sr71kel \\\n+\t| mipstx39 | mipstx39el \\\n+\t| mn10200 | mn10300 \\\n+\t| moxie \\\n+\t| mt \\\n+\t| msp430 \\\n+\t| nds32 | nds32le | nds32be \\\n+\t| nios | nios2 \\\n+\t| ns16k | ns32k \\\n+\t| open8 \\\n+\t| or32 \\\n+\t| pdp10 | pdp11 | pj | pjl \\\n+\t| powerpc | powerpc64 | powerpc64le | powerpcle \\\n+\t| pyramid \\\n+\t| rl78 | rx \\\n+\t| score \\\n+\t| sh | sh[1234] | sh[24]a | sh[24]aeb | sh[23]e | sh[34]eb | sheb | shbe | shle | sh[1234]le | sh3ele \\\n+\t| sh64 | sh64le \\\n+\t| sparc | sparc64 | sparc64b | sparc64v | sparc86x | sparclet | sparclite \\\n+\t| sparcv8 | sparcv9 | sparcv9b | sparcv9v \\\n+\t| spu \\\n+\t| tahoe | tic4x | tic54x | tic55x | tic6x | tic80 | tron \\\n+\t| ubicom32 \\\n+\t| v850 | v850e | v850e1 | v850e2 | v850es | v850e2v3 \\\n+\t| we32k \\\n+\t| x86 | xc16x | xstormy16 | xtensa \\\n+\t| z8k | z80)\n+\t\tbasic_machine=$basic_machine-unknown\n+\t\t;;\n+\tc54x)\n+\t\tbasic_machine=tic54x-unknown\n+\t\t;;\n+\tc55x)\n+\t\tbasic_machine=tic55x-unknown\n+\t\t;;\n+\tc6x)\n+\t\tbasic_machine=tic6x-unknown\n+\t\t;;\n+\tm6811 | m68hc11 | m6812 | m68hc12 | m68hcs12x | picochip)\n+\t\tbasic_machine=$basic_machine-unknown\n+\t\tos=-none\n+\t\t;;\n+\tm88110 | m680[12346]0 | m683?2 | m68360 | m5200 | v70 | w65 | z8k)\n+\t\t;;\n+\tms1)\n+\t\tbasic_machine=mt-unknown\n+\t\t;;\n+\n+\tstrongarm | thumb | xscale)\n+\t\tbasic_machine=arm-unknown\n+\t\t;;\n+\txgate)\n+\t\tbasic_machine=$basic_machine-unknown\n+\t\tos=-none\n+\t\t;;\n+\txscaleeb)\n+\t\tbasic_machine=armeb-unknown\n+\t\t;;\n+\n+\txscaleel)\n+\t\tbasic_machine=armel-unknown\n+\t\t;;\n+\n+\t# We use `pc' rather than `unknown'\n+\t# because (1) that's what they normally are, and\n+\t# (2) the word \"unknown\" tends to confuse beginning users.\n+\ti*86 | x86_64)\n+\t  basic_machine=$basic_machine-pc\n+\t  ;;\n+\t# Object if more than one company name word.\n+\t*-*-*)\n+\t\techo Invalid configuration \\`$1\\': machine \\`$basic_machine\\' not recognized 1>&2\n+\t\texit 1\n+\t\t;;\n+\t# Recognize the basic CPU types with company name.\n+\t580-* \\\n+\t| a29k-* \\\n+\t| aarch64-* | aarch64_be-* \\\n+\t| alpha-* | alphaev[4-8]-* | alphaev56-* | alphaev6[78]-* \\\n+\t| alpha64-* | alpha64ev[4-8]-* | alpha64ev56-* | alpha64ev6[78]-* \\\n+\t| alphapca5[67]-* | alpha64pca5[67]-* | arc-* \\\n+\t| arm-*  | armbe-* | armle-* | armeb-* | armv*-* \\\n+\t| avr-* | avr32-* \\\n+\t| be32-* | be64-* \\\n+\t| bfin-* | bs2000-* \\\n+\t| c[123]* | c30-* | [cjt]90-* | c4x-* \\\n+\t| clipper-* | craynv-* | cydra-* \\\n+\t| d10v-* | d30v-* | dlx-* \\\n+\t| elxsi-* \\\n+\t| f30[01]-* | f700-* | fido-* | fr30-* | frv-* | fx80-* \\\n+\t| h8300-* | h8500-* \\\n+\t| hppa-* | hppa1.[01]-* | hppa2.0-* | hppa2.0[nw]-* | hppa64-* \\\n+\t| hexagon-* \\\n+\t| i*86-* | i860-* | i960-* | ia64-* \\\n+\t| ip2k-* | iq2000-* \\\n+\t| le32-* | le64-* \\\n+\t| lm32-* \\\n+\t| m32c-* | m32r-* | m32rle-* \\\n+\t| m68000-* | m680[012346]0-* | m68360-* | m683?2-* | m68k-* \\\n+\t| m88110-* | m88k-* | maxq-* | mcore-* | metag-* | microblaze-* \\\n+\t| mips-* | mipsbe-* | mipseb-* | mipsel-* | mipsle-* \\\n+\t| mips16-* \\\n+\t| mips64-* | mips64el-* \\\n+\t| mips64octeon-* | mips64octeonel-* \\\n+\t| mips64orion-* | mips64orionel-* \\\n+\t| mips64r5900-* | mips64r5900el-* \\\n+\t| mips64vr-* | mips64vrel-* \\\n+\t| mips64vr4100-* | mips64vr4100el-* \\\n+\t| mips64vr4300-* | mips64vr4300el-* \\\n+\t| mips64vr5000-* | mips64vr5000el-* \\\n+\t| mips64vr5900-* | mips64vr5900el-* \\\n+\t| mipsisa32-* | mipsisa32el-* \\\n+\t| mipsisa32r2-* | mipsisa32r2el-* \\\n+\t| mipsisa64-* | mipsisa64el-* \\\n+\t| mipsisa64r2-* | mipsisa64r2el-* \\\n+\t| mipsisa64sb1-* | mipsisa64sb1el-* \\\n+\t| mipsisa64sr71k-* | mipsisa64sr71kel-* \\\n+\t| mipstx39-* | mipstx39el-* \\\n+\t| mmix-* \\\n+\t| mt-* \\\n+\t| msp430-* \\\n+\t| nds32-* | nds32le-* | nds32be-* \\\n+\t| nios-* | nios2-* \\\n+\t| none-* | np1-* | ns16k-* | ns32k-* \\\n+\t| open8-* \\\n+\t| orion-* \\\n+\t| pdp10-* | pdp11-* | pj-* | pjl-* | pn-* | power-* \\\n+\t| powerpc-* | powerpc64-* | powerpc64le-* | powerpcle-* \\\n+\t| pyramid-* \\\n+\t| rl78-* | romp-* | rs6000-* | rx-* \\\n+\t| sh-* | sh[1234]-* | sh[24]a-* | sh[24]aeb-* | sh[23]e-* | sh[34]eb-* | sheb-* | shbe-* \\\n+\t| shle-* | sh[1234]le-* | sh3ele-* | sh64-* | sh64le-* \\\n+\t| sparc-* | sparc64-* | sparc64b-* | sparc64v-* | sparc86x-* | sparclet-* \\\n+\t| sparclite-* \\\n+\t| sparcv8-* | sparcv9-* | sparcv9b-* | sparcv9v-* | sv1-* | sx?-* \\\n+\t| tahoe-* \\\n+\t| tic30-* | tic4x-* | tic54x-* | tic55x-* | tic6x-* | tic80-* \\\n+\t| tile*-* \\\n+\t| tron-* \\\n+\t| ubicom32-* \\\n+\t| v850-* | v850e-* | v850e1-* | v850es-* | v850e2-* | v850e2v3-* \\\n+\t| vax-* \\\n+\t| we32k-* \\\n+\t| x86-* | x86_64-* | xc16x-* | xps100-* \\\n+\t| xstormy16-* | xtensa*-* \\\n+\t| ymp-* \\\n+\t| z8k-* | z80-*)\n+\t\t;;\n+\t# Recognize the basic CPU types without company name, with glob match.\n+\txtensa*)\n+\t\tbasic_machine=$basic_machine-unknown\n+\t\t;;\n+\t# Recognize the various machine names and aliases which stand\n+\t# for a CPU type and a company and sometimes even an OS.\n+\t386bsd)\n+\t\tbasic_machine=i386-unknown\n+\t\tos=-bsd\n+\t\t;;\n+\t3b1 | 7300 | 7300-att | att-7300 | pc7300 | safari | unixpc)\n+\t\tbasic_machine=m68000-att\n+\t\t;;\n+\t3b*)\n+\t\tbasic_machine=we32k-att\n+\t\t;;\n+\ta29khif)\n+\t\tbasic_machine=a29k-amd\n+\t\tos=-udi\n+\t\t;;\n+\tabacus)\n+\t\tbasic_machine=abacus-unknown\n+\t\t;;\n+\tadobe68k)\n+\t\tbasic_machine=m68010-adobe\n+\t\tos=-scout\n+\t\t;;\n+\talliant | fx80)\n+\t\tbasic_machine=fx80-alliant\n+\t\t;;\n+\taltos | altos3068)\n+\t\tbasic_machine=m68k-altos\n+\t\t;;\n+\tam29k)\n+\t\tbasic_machine=a29k-none\n+\t\tos=-bsd\n+\t\t;;\n+\tamd64)\n+\t\tbasic_machine=x86_64-pc\n+\t\t;;\n+\tamd64-*)\n+\t\tbasic_machine=x86_64-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\t;;\n+\tamdahl)\n+\t\tbasic_machine=580-amdahl\n+\t\tos=-sysv\n+\t\t;;\n+\tamiga | amiga-*)\n+\t\tbasic_machine=m68k-unknown\n+\t\t;;\n+\tamigaos | amigados)\n+\t\tbasic_machine=m68k-unknown\n+\t\tos=-amigaos\n+\t\t;;\n+\tamigaunix | amix)\n+\t\tbasic_machine=m68k-unknown\n+\t\tos=-sysv4\n+\t\t;;\n+\tapollo68)\n+\t\tbasic_machine=m68k-apollo\n+\t\tos=-sysv\n+\t\t;;\n+\tapollo68bsd)\n+\t\tbasic_machine=m68k-apollo\n+\t\tos=-bsd\n+\t\t;;\n+\taros)\n+\t\tbasic_machine=i386-pc\n+\t\tos=-aros\n+\t\t;;\n+\taux)\n+\t\tbasic_machine=m68k-apple\n+\t\tos=-aux\n+\t\t;;\n+\tbalance)\n+\t\tbasic_machine=ns32k-sequent\n+\t\tos=-dynix\n+\t\t;;\n+\tblackfin)\n+\t\tbasic_machine=bfin-unknown\n+\t\tos=-linux\n+\t\t;;\n+\tblackfin-*)\n+\t\tbasic_machine=bfin-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\tos=-linux\n+\t\t;;\n+\tbluegene*)\n+\t\tbasic_machine=powerpc-ibm\n+\t\tos=-cnk\n+\t\t;;\n+\tc54x-*)\n+\t\tbasic_machine=tic54x-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\t;;\n+\tc55x-*)\n+\t\tbasic_machine=tic55x-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\t;;\n+\tc6x-*)\n+\t\tbasic_machine=tic6x-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\t;;\n+\tc90)\n+\t\tbasic_machine=c90-cray\n+\t\tos=-unicos\n+\t\t;;\n+\tcegcc)\n+\t\tbasic_machine=arm-unknown\n+\t\tos=-cegcc\n+\t\t;;\n+\tconvex-c1)\n+\t\tbasic_machine=c1-convex\n+\t\tos=-bsd\n+\t\t;;\n+\tconvex-c2)\n+\t\tbasic_machine=c2-convex\n+\t\tos=-bsd\n+\t\t;;\n+\tconvex-c32)\n+\t\tbasic_machine=c32-convex\n+\t\tos=-bsd\n+\t\t;;\n+\tconvex-c34)\n+\t\tbasic_machine=c34-convex\n+\t\tos=-bsd\n+\t\t;;\n+\tconvex-c38)\n+\t\tbasic_machine=c38-convex\n+\t\tos=-bsd\n+\t\t;;\n+\tcray | j90)\n+\t\tbasic_machine=j90-cray\n+\t\tos=-unicos\n+\t\t;;\n+\tcraynv)\n+\t\tbasic_machine=craynv-cray\n+\t\tos=-unicosmp\n+\t\t;;\n+\tcr16 | cr16-*)\n+\t\tbasic_machine=cr16-unknown\n+\t\tos=-elf\n+\t\t;;\n+\tcrds | unos)\n+\t\tbasic_machine=m68k-crds\n+\t\t;;\n+\tcrisv32 | crisv32-* | etraxfs*)\n+\t\tbasic_machine=crisv32-axis\n+\t\t;;\n+\tcris | cris-* | etrax*)\n+\t\tbasic_machine=cris-axis\n+\t\t;;\n+\tcrx)\n+\t\tbasic_machine=crx-unknown\n+\t\tos=-elf\n+\t\t;;\n+\tda30 | da30-*)\n+\t\tbasic_machine=m68k-da30\n+\t\t;;\n+\tdecstation | decstation-3100 | pmax | pmax-* | pmin | dec3100 | decstatn)\n+\t\tbasic_machine=mips-dec\n+\t\t;;\n+\tdecsystem10* | dec10*)\n+\t\tbasic_machine=pdp10-dec\n+\t\tos=-tops10\n+\t\t;;\n+\tdecsystem20* | dec20*)\n+\t\tbasic_machine=pdp10-dec\n+\t\tos=-tops20\n+\t\t;;\n+\tdelta | 3300 | motorola-3300 | motorola-delta \\\n+\t      | 3300-motorola | delta-motorola)\n+\t\tbasic_machine=m68k-motorola\n+\t\t;;\n+\tdelta88)\n+\t\tbasic_machine=m88k-motorola\n+\t\tos=-sysv3\n+\t\t;;\n+\tdicos)\n+\t\tbasic_machine=i686-pc\n+\t\tos=-dicos\n+\t\t;;\n+\tdjgpp)\n+\t\tbasic_machine=i586-pc\n+\t\tos=-msdosdjgpp\n+\t\t;;\n+\tdpx20 | dpx20-*)\n+\t\tbasic_machine=rs6000-bull\n+\t\tos=-bosx\n+\t\t;;\n+\tdpx2* | dpx2*-bull)\n+\t\tbasic_machine=m68k-bull\n+\t\tos=-sysv3\n+\t\t;;\n+\tebmon29k)\n+\t\tbasic_machine=a29k-amd\n+\t\tos=-ebmon\n+\t\t;;\n+\telxsi)\n+\t\tbasic_machine=elxsi-elxsi\n+\t\tos=-bsd\n+\t\t;;\n+\tencore | umax | mmax)\n+\t\tbasic_machine=ns32k-encore\n+\t\t;;\n+\tes1800 | OSE68k | ose68k | ose | OSE)\n+\t\tbasic_machine=m68k-ericsson\n+\t\tos=-ose\n+\t\t;;\n+\tfx2800)\n+\t\tbasic_machine=i860-alliant\n+\t\t;;\n+\tgenix)\n+\t\tbasic_machine=ns32k-ns\n+\t\t;;\n+\tgmicro)\n+\t\tbasic_machine=tron-gmicro\n+\t\tos=-sysv\n+\t\t;;\n+\tgo32)\n+\t\tbasic_machine=i386-pc\n+\t\tos=-go32\n+\t\t;;\n+\th3050r* | hiux*)\n+\t\tbasic_machine=hppa1.1-hitachi\n+\t\tos=-hiuxwe2\n+\t\t;;\n+\th8300hms)\n+\t\tbasic_machine=h8300-hitachi\n+\t\tos=-hms\n+\t\t;;\n+\th8300xray)\n+\t\tbasic_machine=h8300-hitachi\n+\t\tos=-xray\n+\t\t;;\n+\th8500hms)\n+\t\tbasic_machine=h8500-hitachi\n+\t\tos=-hms\n+\t\t;;\n+\tharris)\n+\t\tbasic_machine=m88k-harris\n+\t\tos=-sysv3\n+\t\t;;\n+\thp300-*)\n+\t\tbasic_machine=m68k-hp\n+\t\t;;\n+\thp300bsd)\n+\t\tbasic_machine=m68k-hp\n+\t\tos=-bsd\n+\t\t;;\n+\thp300hpux)\n+\t\tbasic_machine=m68k-hp\n+\t\tos=-hpux\n+\t\t;;\n+\thp3k9[0-9][0-9] | hp9[0-9][0-9])\n+\t\tbasic_machine=hppa1.0-hp\n+\t\t;;\n+\thp9k2[0-9][0-9] | hp9k31[0-9])\n+\t\tbasic_machine=m68000-hp\n+\t\t;;\n+\thp9k3[2-9][0-9])\n+\t\tbasic_machine=m68k-hp\n+\t\t;;\n+\thp9k6[0-9][0-9] | hp6[0-9][0-9])\n+\t\tbasic_machine=hppa1.0-hp\n+\t\t;;\n+\thp9k7[0-79][0-9] | hp7[0-79][0-9])\n+\t\tbasic_machine=hppa1.1-hp\n+\t\t;;\n+\thp9k78[0-9] | hp78[0-9])\n+\t\t# FIXME: really hppa2.0-hp\n+\t\tbasic_machine=hppa1.1-hp\n+\t\t;;\n+\thp9k8[67]1 | hp8[67]1 | hp9k80[24] | hp80[24] | hp9k8[78]9 | hp8[78]9 | hp9k893 | hp893)\n+\t\t# FIXME: really hppa2.0-hp\n+\t\tbasic_machine=hppa1.1-hp\n+\t\t;;\n+\thp9k8[0-9][13679] | hp8[0-9][13679])\n+\t\tbasic_machine=hppa1.1-hp\n+\t\t;;\n+\thp9k8[0-9][0-9] | hp8[0-9][0-9])\n+\t\tbasic_machine=hppa1.0-hp\n+\t\t;;\n+\thppa-next)\n+\t\tos=-nextstep3\n+\t\t;;\n+\thppaosf)\n+\t\tbasic_machine=hppa1.1-hp\n+\t\tos=-osf\n+\t\t;;\n+\thppro)\n+\t\tbasic_machine=hppa1.1-hp\n+\t\tos=-proelf\n+\t\t;;\n+\ti370-ibm* | ibm*)\n+\t\tbasic_machine=i370-ibm\n+\t\t;;\n+\ti*86v32)\n+\t\tbasic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`\n+\t\tos=-sysv32\n+\t\t;;\n+\ti*86v4*)\n+\t\tbasic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`\n+\t\tos=-sysv4\n+\t\t;;\n+\ti*86v)\n+\t\tbasic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`\n+\t\tos=-sysv\n+\t\t;;\n+\ti*86sol2)\n+\t\tbasic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`\n+\t\tos=-solaris2\n+\t\t;;\n+\ti386mach)\n+\t\tbasic_machine=i386-mach\n+\t\tos=-mach\n+\t\t;;\n+\ti386-vsta | vsta)\n+\t\tbasic_machine=i386-unknown\n+\t\tos=-vsta\n+\t\t;;\n+\tiris | iris4d)\n+\t\tbasic_machine=mips-sgi\n+\t\tcase $os in\n+\t\t    -irix*)\n+\t\t\t;;\n+\t\t    *)\n+\t\t\tos=-irix4\n+\t\t\t;;\n+\t\tesac\n+\t\t;;\n+\tisi68 | isi)\n+\t\tbasic_machine=m68k-isi\n+\t\tos=-sysv\n+\t\t;;\n+\tm68knommu)\n+\t\tbasic_machine=m68k-unknown\n+\t\tos=-linux\n+\t\t;;\n+\tm68knommu-*)\n+\t\tbasic_machine=m68k-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\tos=-linux\n+\t\t;;\n+\tm88k-omron*)\n+\t\tbasic_machine=m88k-omron\n+\t\t;;\n+\tmagnum | m3230)\n+\t\tbasic_machine=mips-mips\n+\t\tos=-sysv\n+\t\t;;\n+\tmerlin)\n+\t\tbasic_machine=ns32k-utek\n+\t\tos=-sysv\n+\t\t;;\n+\tmicroblaze)\n+\t\tbasic_machine=microblaze-xilinx\n+\t\t;;\n+\tmingw32)\n+\t\tbasic_machine=i386-pc\n+\t\tos=-mingw32\n+\t\t;;\n+\tmingw32ce)\n+\t\tbasic_machine=arm-unknown\n+\t\tos=-mingw32ce\n+\t\t;;\n+\tminiframe)\n+\t\tbasic_machine=m68000-convergent\n+\t\t;;\n+\t*mint | -mint[0-9]* | *MiNT | *MiNT[0-9]*)\n+\t\tbasic_machine=m68k-atari\n+\t\tos=-mint\n+\t\t;;\n+\tmips3*-*)\n+\t\tbasic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`\n+\t\t;;\n+\tmips3*)\n+\t\tbasic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`-unknown\n+\t\t;;\n+\tmonitor)\n+\t\tbasic_machine=m68k-rom68k\n+\t\tos=-coff\n+\t\t;;\n+\tmorphos)\n+\t\tbasic_machine=powerpc-unknown\n+\t\tos=-morphos\n+\t\t;;\n+\tmsdos)\n+\t\tbasic_machine=i386-pc\n+\t\tos=-msdos\n+\t\t;;\n+\tms1-*)\n+\t\tbasic_machine=`echo $basic_machine | sed -e 's/ms1-/mt-/'`\n+\t\t;;\n+\tmsys)\n+\t\tbasic_machine=i386-pc\n+\t\tos=-msys\n+\t\t;;\n+\tmvs)\n+\t\tbasic_machine=i370-ibm\n+\t\tos=-mvs\n+\t\t;;\n+\tnacl)\n+\t\tbasic_machine=le32-unknown\n+\t\tos=-nacl\n+\t\t;;\n+\tncr3000)\n+\t\tbasic_machine=i486-ncr\n+\t\tos=-sysv4\n+\t\t;;\n+\tnetbsd386)\n+\t\tbasic_machine=i386-unknown\n+\t\tos=-netbsd\n+\t\t;;\n+\tnetwinder)\n+\t\tbasic_machine=armv4l-rebel\n+\t\tos=-linux\n+\t\t;;\n+\tnews | news700 | news800 | news900)\n+\t\tbasic_machine=m68k-sony\n+\t\tos=-newsos\n+\t\t;;\n+\tnews1000)\n+\t\tbasic_machine=m68030-sony\n+\t\tos=-newsos\n+\t\t;;\n+\tnews-3600 | risc-news)\n+\t\tbasic_machine=mips-sony\n+\t\tos=-newsos\n+\t\t;;\n+\tnecv70)\n+\t\tbasic_machine=v70-nec\n+\t\tos=-sysv\n+\t\t;;\n+\tnext | m*-next )\n+\t\tbasic_machine=m68k-next\n+\t\tcase $os in\n+\t\t    -nextstep* )\n+\t\t\t;;\n+\t\t    -ns2*)\n+\t\t      os=-nextstep2\n+\t\t\t;;\n+\t\t    *)\n+\t\t      os=-nextstep3\n+\t\t\t;;\n+\t\tesac\n+\t\t;;\n+\tnh3000)\n+\t\tbasic_machine=m68k-harris\n+\t\tos=-cxux\n+\t\t;;\n+\tnh[45]000)\n+\t\tbasic_machine=m88k-harris\n+\t\tos=-cxux\n+\t\t;;\n+\tnindy960)\n+\t\tbasic_machine=i960-intel\n+\t\tos=-nindy\n+\t\t;;\n+\tmon960)\n+\t\tbasic_machine=i960-intel\n+\t\tos=-mon960\n+\t\t;;\n+\tnonstopux)\n+\t\tbasic_machine=mips-compaq\n+\t\tos=-nonstopux\n+\t\t;;\n+\tnp1)\n+\t\tbasic_machine=np1-gould\n+\t\t;;\n+\tneo-tandem)\n+\t\tbasic_machine=neo-tandem\n+\t\t;;\n+\tnse-tandem)\n+\t\tbasic_machine=nse-tandem\n+\t\t;;\n+\tnsr-tandem)\n+\t\tbasic_machine=nsr-tandem\n+\t\t;;\n+\top50n-* | op60c-*)\n+\t\tbasic_machine=hppa1.1-oki\n+\t\tos=-proelf\n+\t\t;;\n+\topenrisc | openrisc-*)\n+\t\tbasic_machine=or32-unknown\n+\t\t;;\n+\tos400)\n+\t\tbasic_machine=powerpc-ibm\n+\t\tos=-os400\n+\t\t;;\n+\tOSE68000 | ose68000)\n+\t\tbasic_machine=m68000-ericsson\n+\t\tos=-ose\n+\t\t;;\n+\tos68k)\n+\t\tbasic_machine=m68k-none\n+\t\tos=-os68k\n+\t\t;;\n+\tpa-hitachi)\n+\t\tbasic_machine=hppa1.1-hitachi\n+\t\tos=-hiuxwe2\n+\t\t;;\n+\tparagon)\n+\t\tbasic_machine=i860-intel\n+\t\tos=-osf\n+\t\t;;\n+\tparisc)\n+\t\tbasic_machine=hppa-unknown\n+\t\tos=-linux\n+\t\t;;\n+\tparisc-*)\n+\t\tbasic_machine=hppa-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\tos=-linux\n+\t\t;;\n+\tpbd)\n+\t\tbasic_machine=sparc-tti\n+\t\t;;\n+\tpbb)\n+\t\tbasic_machine=m68k-tti\n+\t\t;;\n+\tpc532 | pc532-*)\n+\t\tbasic_machine=ns32k-pc532\n+\t\t;;\n+\tpc98)\n+\t\tbasic_machine=i386-pc\n+\t\t;;\n+\tpc98-*)\n+\t\tbasic_machine=i386-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\t;;\n+\tpentium | p5 | k5 | k6 | nexgen | viac3)\n+\t\tbasic_machine=i586-pc\n+\t\t;;\n+\tpentiumpro | p6 | 6x86 | athlon | athlon_*)\n+\t\tbasic_machine=i686-pc\n+\t\t;;\n+\tpentiumii | pentium2 | pentiumiii | pentium3)\n+\t\tbasic_machine=i686-pc\n+\t\t;;\n+\tpentium4)\n+\t\tbasic_machine=i786-pc\n+\t\t;;\n+\tpentium-* | p5-* | k5-* | k6-* | nexgen-* | viac3-*)\n+\t\tbasic_machine=i586-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\t;;\n+\tpentiumpro-* | p6-* | 6x86-* | athlon-*)\n+\t\tbasic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\t;;\n+\tpentiumii-* | pentium2-* | pentiumiii-* | pentium3-*)\n+\t\tbasic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\t;;\n+\tpentium4-*)\n+\t\tbasic_machine=i786-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\t;;\n+\tpn)\n+\t\tbasic_machine=pn-gould\n+\t\t;;\n+\tpower)\tbasic_machine=power-ibm\n+\t\t;;\n+\tppc | ppcbe)\tbasic_machine=powerpc-unknown\n+\t\t;;\n+\tppc-* | ppcbe-*)\n+\t\tbasic_machine=powerpc-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\t;;\n+\tppcle | powerpclittle | ppc-le | powerpc-little)\n+\t\tbasic_machine=powerpcle-unknown\n+\t\t;;\n+\tppcle-* | powerpclittle-*)\n+\t\tbasic_machine=powerpcle-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\t;;\n+\tppc64)\tbasic_machine=powerpc64-unknown\n+\t\t;;\n+\tppc64-*) basic_machine=powerpc64-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\t;;\n+\tppc64le | powerpc64little | ppc64-le | powerpc64-little)\n+\t\tbasic_machine=powerpc64le-unknown\n+\t\t;;\n+\tppc64le-* | powerpc64little-*)\n+\t\tbasic_machine=powerpc64le-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\t;;\n+\tps2)\n+\t\tbasic_machine=i386-ibm\n+\t\t;;\n+\tpw32)\n+\t\tbasic_machine=i586-unknown\n+\t\tos=-pw32\n+\t\t;;\n+\trdos)\n+\t\tbasic_machine=i386-pc\n+\t\tos=-rdos\n+\t\t;;\n+\trom68k)\n+\t\tbasic_machine=m68k-rom68k\n+\t\tos=-coff\n+\t\t;;\n+\trm[46]00)\n+\t\tbasic_machine=mips-siemens\n+\t\t;;\n+\trtpc | rtpc-*)\n+\t\tbasic_machine=romp-ibm\n+\t\t;;\n+\ts390 | s390-*)\n+\t\tbasic_machine=s390-ibm\n+\t\t;;\n+\ts390x | s390x-*)\n+\t\tbasic_machine=s390x-ibm\n+\t\t;;\n+\tsa29200)\n+\t\tbasic_machine=a29k-amd\n+\t\tos=-udi\n+\t\t;;\n+\tsb1)\n+\t\tbasic_machine=mipsisa64sb1-unknown\n+\t\t;;\n+\tsb1el)\n+\t\tbasic_machine=mipsisa64sb1el-unknown\n+\t\t;;\n+\tsde)\n+\t\tbasic_machine=mipsisa32-sde\n+\t\tos=-elf\n+\t\t;;\n+\tsei)\n+\t\tbasic_machine=mips-sei\n+\t\tos=-seiux\n+\t\t;;\n+\tsequent)\n+\t\tbasic_machine=i386-sequent\n+\t\t;;\n+\tsh)\n+\t\tbasic_machine=sh-hitachi\n+\t\tos=-hms\n+\t\t;;\n+\tsh5el)\n+\t\tbasic_machine=sh5le-unknown\n+\t\t;;\n+\tsh64)\n+\t\tbasic_machine=sh64-unknown\n+\t\t;;\n+\tsparclite-wrs | simso-wrs)\n+\t\tbasic_machine=sparclite-wrs\n+\t\tos=-vxworks\n+\t\t;;\n+\tsps7)\n+\t\tbasic_machine=m68k-bull\n+\t\tos=-sysv2\n+\t\t;;\n+\tspur)\n+\t\tbasic_machine=spur-unknown\n+\t\t;;\n+\tst2000)\n+\t\tbasic_machine=m68k-tandem\n+\t\t;;\n+\tstratus)\n+\t\tbasic_machine=i860-stratus\n+\t\tos=-sysv4\n+\t\t;;\n+\tstrongarm-* | thumb-*)\n+\t\tbasic_machine=arm-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\t;;\n+\tsun2)\n+\t\tbasic_machine=m68000-sun\n+\t\t;;\n+\tsun2os3)\n+\t\tbasic_machine=m68000-sun\n+\t\tos=-sunos3\n+\t\t;;\n+\tsun2os4)\n+\t\tbasic_machine=m68000-sun\n+\t\tos=-sunos4\n+\t\t;;\n+\tsun3os3)\n+\t\tbasic_machine=m68k-sun\n+\t\tos=-sunos3\n+\t\t;;\n+\tsun3os4)\n+\t\tbasic_machine=m68k-sun\n+\t\tos=-sunos4\n+\t\t;;\n+\tsun4os3)\n+\t\tbasic_machine=sparc-sun\n+\t\tos=-sunos3\n+\t\t;;\n+\tsun4os4)\n+\t\tbasic_machine=sparc-sun\n+\t\tos=-sunos4\n+\t\t;;\n+\tsun4sol2)\n+\t\tbasic_machine=sparc-sun\n+\t\tos=-solaris2\n+\t\t;;\n+\tsun3 | sun3-*)\n+\t\tbasic_machine=m68k-sun\n+\t\t;;\n+\tsun4)\n+\t\tbasic_machine=sparc-sun\n+\t\t;;\n+\tsun386 | sun386i | roadrunner)\n+\t\tbasic_machine=i386-sun\n+\t\t;;\n+\tsv1)\n+\t\tbasic_machine=sv1-cray\n+\t\tos=-unicos\n+\t\t;;\n+\tsymmetry)\n+\t\tbasic_machine=i386-sequent\n+\t\tos=-dynix\n+\t\t;;\n+\tt3e)\n+\t\tbasic_machine=alphaev5-cray\n+\t\tos=-unicos\n+\t\t;;\n+\tt90)\n+\t\tbasic_machine=t90-cray\n+\t\tos=-unicos\n+\t\t;;\n+\ttile*)\n+\t\tbasic_machine=$basic_machine-unknown\n+\t\tos=-linux-gnu\n+\t\t;;\n+\ttx39)\n+\t\tbasic_machine=mipstx39-unknown\n+\t\t;;\n+\ttx39el)\n+\t\tbasic_machine=mipstx39el-unknown\n+\t\t;;\n+\ttoad1)\n+\t\tbasic_machine=pdp10-xkl\n+\t\tos=-tops20\n+\t\t;;\n+\ttower | tower-32)\n+\t\tbasic_machine=m68k-ncr\n+\t\t;;\n+\ttpf)\n+\t\tbasic_machine=s390x-ibm\n+\t\tos=-tpf\n+\t\t;;\n+\tudi29k)\n+\t\tbasic_machine=a29k-amd\n+\t\tos=-udi\n+\t\t;;\n+\tultra3)\n+\t\tbasic_machine=a29k-nyu\n+\t\tos=-sym1\n+\t\t;;\n+\tv810 | necv810)\n+\t\tbasic_machine=v810-nec\n+\t\tos=-none\n+\t\t;;\n+\tvaxv)\n+\t\tbasic_machine=vax-dec\n+\t\tos=-sysv\n+\t\t;;\n+\tvms)\n+\t\tbasic_machine=vax-dec\n+\t\tos=-vms\n+\t\t;;\n+\tvpp*|vx|vx-*)\n+\t\tbasic_machine=f301-fujitsu\n+\t\t;;\n+\tvxworks960)\n+\t\tbasic_machine=i960-wrs\n+\t\tos=-vxworks\n+\t\t;;\n+\tvxworks68)\n+\t\tbasic_machine=m68k-wrs\n+\t\tos=-vxworks\n+\t\t;;\n+\tvxworks29k)\n+\t\tbasic_machine=a29k-wrs\n+\t\tos=-vxworks\n+\t\t;;\n+\tw65*)\n+\t\tbasic_machine=w65-wdc\n+\t\tos=-none\n+\t\t;;\n+\tw89k-*)\n+\t\tbasic_machine=hppa1.1-winbond\n+\t\tos=-proelf\n+\t\t;;\n+\txbox)\n+\t\tbasic_machine=i686-pc\n+\t\tos=-mingw32\n+\t\t;;\n+\txps | xps100)\n+\t\tbasic_machine=xps100-honeywell\n+\t\t;;\n+\txscale-* | xscalee[bl]-*)\n+\t\tbasic_machine=`echo $basic_machine | sed 's/^xscale/arm/'`\n+\t\t;;\n+\tymp)\n+\t\tbasic_machine=ymp-cray\n+\t\tos=-unicos\n+\t\t;;\n+\tz8k-*-coff)\n+\t\tbasic_machine=z8k-unknown\n+\t\tos=-sim\n+\t\t;;\n+\tz80-*-coff)\n+\t\tbasic_machine=z80-unknown\n+\t\tos=-sim\n+\t\t;;\n+\tnone)\n+\t\tbasic_machine=none-none\n+\t\tos=-none\n+\t\t;;\n+\n+# Here we handle the default manufacturer of certain CPU types.  It is in\n+# some cases the only manufacturer, in others, it is the most popular.\n+\tw89k)\n+\t\tbasic_machine=hppa1.1-winbond\n+\t\t;;\n+\top50n)\n+\t\tbasic_machine=hppa1.1-oki\n+\t\t;;\n+\top60c)\n+\t\tbasic_machine=hppa1.1-oki\n+\t\t;;\n+\tromp)\n+\t\tbasic_machine=romp-ibm\n+\t\t;;\n+\tmmix)\n+\t\tbasic_machine=mmix-knuth\n+\t\t;;\n+\trs6000)\n+\t\tbasic_machine=rs6000-ibm\n+\t\t;;\n+\tvax)\n+\t\tbasic_machine=vax-dec\n+\t\t;;\n+\tpdp10)\n+\t\t# there are many clones, so DEC is not a safe bet\n+\t\tbasic_machine=pdp10-unknown\n+\t\t;;\n+\tpdp11)\n+\t\tbasic_machine=pdp11-dec\n+\t\t;;\n+\twe32k)\n+\t\tbasic_machine=we32k-att\n+\t\t;;\n+\tsh[1234] | sh[24]a | sh[24]aeb | sh[34]eb | sh[1234]le | sh[23]ele)\n+\t\tbasic_machine=sh-unknown\n+\t\t;;\n+\tsparc | sparcv8 | sparcv9 | sparcv9b | sparcv9v)\n+\t\tbasic_machine=sparc-sun\n+\t\t;;\n+\tcydra)\n+\t\tbasic_machine=cydra-cydrome\n+\t\t;;\n+\torion)\n+\t\tbasic_machine=orion-highlevel\n+\t\t;;\n+\torion105)\n+\t\tbasic_machine=clipper-highlevel\n+\t\t;;\n+\tmac | mpw | mac-mpw)\n+\t\tbasic_machine=m68k-apple\n+\t\t;;\n+\tpmac | pmac-mpw)\n+\t\tbasic_machine=powerpc-apple\n+\t\t;;\n+\t*-unknown)\n+\t\t# Make sure to match an already-canonicalized machine name.\n+\t\t;;\n+\t*)\n+\t\techo Invalid configuration \\`$1\\': machine \\`$basic_machine\\' not recognized 1>&2\n+\t\texit 1\n+\t\t;;\n+esac\n+\n+# Here we canonicalize certain aliases for manufacturers.\n+case $basic_machine in\n+\t*-digital*)\n+\t\tbasic_machine=`echo $basic_machine | sed 's/digital.*/dec/'`\n+\t\t;;\n+\t*-commodore*)\n+\t\tbasic_machine=`echo $basic_machine | sed 's/commodore.*/cbm/'`\n+\t\t;;\n+\t*)\n+\t\t;;\n+esac\n+\n+# Decode manufacturer-specific aliases for certain operating systems.\n+\n+if [ x\"$os\" != x\"\" ]\n+then\n+case $os in\n+\t# First match some system type aliases\n+\t# that might get confused with valid system types.\n+\t# -solaris* is a basic system type, with this one exception.\n+\t-auroraux)\n+\t\tos=-auroraux\n+\t\t;;\n+\t-solaris1 | -solaris1.*)\n+\t\tos=`echo $os | sed -e 's|solaris1|sunos4|'`\n+\t\t;;\n+\t-solaris)\n+\t\tos=-solaris2\n+\t\t;;\n+\t-svr4*)\n+\t\tos=-sysv4\n+\t\t;;\n+\t-unixware*)\n+\t\tos=-sysv4.2uw\n+\t\t;;\n+\t-gnu/linux*)\n+\t\tos=`echo $os | sed -e 's|gnu/linux|linux-gnu|'`\n+\t\t;;\n+\t# First accept the basic system types.\n+\t# The portable systems comes first.\n+\t# Each alternative MUST END IN A *, to match a version number.\n+\t# -sysv* is not here because it comes later, after sysvr4.\n+\t-gnu* | -bsd* | -mach* | -minix* | -genix* | -ultrix* | -irix* \\\n+\t      | -*vms* | -sco* | -esix* | -isc* | -aix* | -cnk* | -sunos | -sunos[34]*\\\n+\t      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -auroraux* | -solaris* \\\n+\t      | -sym* | -kopensolaris* \\\n+\t      | -amigaos* | -amigados* | -msdos* | -newsos* | -unicos* | -aof* \\\n+\t      | -aos* | -aros* \\\n+\t      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \\\n+\t      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \\\n+\t      | -hiux* | -386bsd* | -knetbsd* | -mirbsd* | -netbsd* \\\n+\t      | -openbsd* | -solidbsd* \\\n+\t      | -ekkobsd* | -kfreebsd* | -freebsd* | -riscix* | -lynxos* \\\n+\t      | -bosx* | -nextstep* | -cxux* | -aout* | -elf* | -oabi* \\\n+\t      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \\\n+\t      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \\\n+\t      | -chorusos* | -chorusrdb* | -cegcc* \\\n+\t      | -cygwin* | -msys* | -pe* | -psos* | -moss* | -proelf* | -rtems* \\\n+\t      | -mingw32* | -linux-gnu* | -linux-android* \\\n+\t      | -linux-newlib* | -linux-uclibc* \\\n+\t      | -uxpv* | -beos* | -mpeix* | -udk* \\\n+\t      | -interix* | -uwin* | -mks* | -rhapsody* | -darwin* | -opened* \\\n+\t      | -openstep* | -oskit* | -conix* | -pw32* | -nonstopux* \\\n+\t      | -storm-chaos* | -tops10* | -tenex* | -tops20* | -its* \\\n+\t      | -os2* | -vos* | -palmos* | -uclinux* | -nucleus* \\\n+\t      | -morphos* | -superux* | -rtmk* | -rtmk-nova* | -windiss* \\\n+\t      | -powermax* | -dnix* | -nx6 | -nx7 | -sei* | -dragonfly* \\\n+\t      | -skyos* | -haiku* | -rdos* | -toppers* | -drops* | -es*)\n+\t# Remember, each alternative MUST END IN *, to match a version number.\n+\t\t;;\n+\t-qnx*)\n+\t\tcase $basic_machine in\n+\t\t    x86-* | i*86-*)\n+\t\t\t;;\n+\t\t    *)\n+\t\t\tos=-nto$os\n+\t\t\t;;\n+\t\tesac\n+\t\t;;\n+\t-nto-qnx*)\n+\t\t;;\n+\t-nto*)\n+\t\tos=`echo $os | sed -e 's|nto|nto-qnx|'`\n+\t\t;;\n+\t-sim | -es1800* | -hms* | -xray | -os68k* | -none* | -v88r* \\\n+\t      | -windows* | -osx | -abug | -netware* | -os9* | -beos* | -haiku* \\\n+\t      | -macos* | -mpw* | -magic* | -mmixware* | -mon960* | -lnews*)\n+\t\t;;\n+\t-mac*)\n+\t\tos=`echo $os | sed -e 's|mac|macos|'`\n+\t\t;;\n+\t-linux-dietlibc)\n+\t\tos=-linux-dietlibc\n+\t\t;;\n+\t-linux*)\n+\t\tos=`echo $os | sed -e 's|linux|linux-gnu|'`\n+\t\t;;\n+\t-sunos5*)\n+\t\tos=`echo $os | sed -e 's|sunos5|solaris2|'`\n+\t\t;;\n+\t-sunos6*)\n+\t\tos=`echo $os | sed -e 's|sunos6|solaris3|'`\n+\t\t;;\n+\t-opened*)\n+\t\tos=-openedition\n+\t\t;;\n+\t-os400*)\n+\t\tos=-os400\n+\t\t;;\n+\t-wince*)\n+\t\tos=-wince\n+\t\t;;\n+\t-osfrose*)\n+\t\tos=-osfrose\n+\t\t;;\n+\t-osf*)\n+\t\tos=-osf\n+\t\t;;\n+\t-utek*)\n+\t\tos=-bsd\n+\t\t;;\n+\t-dynix*)\n+\t\tos=-bsd\n+\t\t;;\n+\t-acis*)\n+\t\tos=-aos\n+\t\t;;\n+\t-atheos*)\n+\t\tos=-atheos\n+\t\t;;\n+\t-syllable*)\n+\t\tos=-syllable\n+\t\t;;\n+\t-386bsd)\n+\t\tos=-bsd\n+\t\t;;\n+\t-ctix* | -uts*)\n+\t\tos=-sysv\n+\t\t;;\n+\t-nova*)\n+\t\tos=-rtmk-nova\n+\t\t;;\n+\t-ns2 )\n+\t\tos=-nextstep2\n+\t\t;;\n+\t-nsk*)\n+\t\tos=-nsk\n+\t\t;;\n+\t# Preserve the version number of sinix5.\n+\t-sinix5.*)\n+\t\tos=`echo $os | sed -e 's|sinix|sysv|'`\n+\t\t;;\n+\t-sinix*)\n+\t\tos=-sysv4\n+\t\t;;\n+\t-tpf*)\n+\t\tos=-tpf\n+\t\t;;\n+\t-triton*)\n+\t\tos=-sysv3\n+\t\t;;\n+\t-oss*)\n+\t\tos=-sysv3\n+\t\t;;\n+\t-svr4)\n+\t\tos=-sysv4\n+\t\t;;\n+\t-svr3)\n+\t\tos=-sysv3\n+\t\t;;\n+\t-sysvr4)\n+\t\tos=-sysv4\n+\t\t;;\n+\t# This must come after -sysvr4.\n+\t-sysv*)\n+\t\t;;\n+\t-ose*)\n+\t\tos=-ose\n+\t\t;;\n+\t-es1800*)\n+\t\tos=-ose\n+\t\t;;\n+\t-xenix)\n+\t\tos=-xenix\n+\t\t;;\n+\t-*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)\n+\t\tos=-mint\n+\t\t;;\n+\t-aros*)\n+\t\tos=-aros\n+\t\t;;\n+\t-kaos*)\n+\t\tos=-kaos\n+\t\t;;\n+\t-zvmoe)\n+\t\tos=-zvmoe\n+\t\t;;\n+\t-dicos*)\n+\t\tos=-dicos\n+\t\t;;\n+\t-nacl*)\n+\t\t;;\n+\t-none)\n+\t\t;;\n+\t*)\n+\t\t# Get rid of the `-' at the beginning of $os.\n+\t\tos=`echo $os | sed 's/[^-]*-//'`\n+\t\techo Invalid configuration \\`$1\\': system \\`$os\\' not recognized 1>&2\n+\t\texit 1\n+\t\t;;\n+esac\n+else\n+\n+# Here we handle the default operating systems that come with various machines.\n+# The value should be what the vendor currently ships out the door with their\n+# machine or put another way, the most popular os provided with the machine.\n+\n+# Note that if you're going to try to match \"-MANUFACTURER\" here (say,\n+# \"-sun\"), then you have to tell the case statement up towards the top\n+# that MANUFACTURER isn't an operating system.  Otherwise, code above\n+# will signal an error saying that MANUFACTURER isn't an operating\n+# system, and we'll never get to this point.\n+\n+case $basic_machine in\n+\tscore-*)\n+\t\tos=-elf\n+\t\t;;\n+\tspu-*)\n+\t\tos=-elf\n+\t\t;;\n+\t*-acorn)\n+\t\tos=-riscix1.2\n+\t\t;;\n+\tarm*-rebel)\n+\t\tos=-linux\n+\t\t;;\n+\tarm*-semi)\n+\t\tos=-aout\n+\t\t;;\n+\tc4x-* | tic4x-*)\n+\t\tos=-coff\n+\t\t;;\n+\ttic54x-*)\n+\t\tos=-coff\n+\t\t;;\n+\ttic55x-*)\n+\t\tos=-coff\n+\t\t;;\n+\ttic6x-*)\n+\t\tos=-coff\n+\t\t;;\n+\t# This must come before the *-dec entry.\n+\tpdp10-*)\n+\t\tos=-tops20\n+\t\t;;\n+\tpdp11-*)\n+\t\tos=-none\n+\t\t;;\n+\t*-dec | vax-*)\n+\t\tos=-ultrix4.2\n+\t\t;;\n+\tm68*-apollo)\n+\t\tos=-domain\n+\t\t;;\n+\ti386-sun)\n+\t\tos=-sunos4.0.2\n+\t\t;;\n+\tm68000-sun)\n+\t\tos=-sunos3\n+\t\t;;\n+\tm68*-cisco)\n+\t\tos=-aout\n+\t\t;;\n+\tmep-*)\n+\t\tos=-elf\n+\t\t;;\n+\tmips*-cisco)\n+\t\tos=-elf\n+\t\t;;\n+\tmips*-*)\n+\t\tos=-elf\n+\t\t;;\n+\tor32-*)\n+\t\tos=-coff\n+\t\t;;\n+\t*-tti)\t# must be before sparc entry or we get the wrong os.\n+\t\tos=-sysv3\n+\t\t;;\n+\tsparc-* | *-sun)\n+\t\tos=-sunos4.1.1\n+\t\t;;\n+\t*-be)\n+\t\tos=-beos\n+\t\t;;\n+\t*-haiku)\n+\t\tos=-haiku\n+\t\t;;\n+\t*-ibm)\n+\t\tos=-aix\n+\t\t;;\n+\t*-knuth)\n+\t\tos=-mmixware\n+\t\t;;\n+\t*-wec)\n+\t\tos=-proelf\n+\t\t;;\n+\t*-winbond)\n+\t\tos=-proelf\n+\t\t;;\n+\t*-oki)\n+\t\tos=-proelf\n+\t\t;;\n+\t*-hp)\n+\t\tos=-hpux\n+\t\t;;\n+\t*-hitachi)\n+\t\tos=-hiux\n+\t\t;;\n+\ti860-* | *-att | *-ncr | *-altos | *-motorola | *-convergent)\n+\t\tos=-sysv\n+\t\t;;\n+\t*-cbm)\n+\t\tos=-amigaos\n+\t\t;;\n+\t*-dg)\n+\t\tos=-dgux\n+\t\t;;\n+\t*-dolphin)\n+\t\tos=-sysv3\n+\t\t;;\n+\tm68k-ccur)\n+\t\tos=-rtu\n+\t\t;;\n+\tm88k-omron*)\n+\t\tos=-luna\n+\t\t;;\n+\t*-next )\n+\t\tos=-nextstep\n+\t\t;;\n+\t*-sequent)\n+\t\tos=-ptx\n+\t\t;;\n+\t*-crds)\n+\t\tos=-unos\n+\t\t;;\n+\t*-ns)\n+\t\tos=-genix\n+\t\t;;\n+\ti370-*)\n+\t\tos=-mvs\n+\t\t;;\n+\t*-next)\n+\t\tos=-nextstep3\n+\t\t;;\n+\t*-gould)\n+\t\tos=-sysv\n+\t\t;;\n+\t*-highlevel)\n+\t\tos=-bsd\n+\t\t;;\n+\t*-encore)\n+\t\tos=-bsd\n+\t\t;;\n+\t*-sgi)\n+\t\tos=-irix\n+\t\t;;\n+\t*-siemens)\n+\t\tos=-sysv4\n+\t\t;;\n+\t*-masscomp)\n+\t\tos=-rtu\n+\t\t;;\n+\tf30[01]-fujitsu | f700-fujitsu)\n+\t\tos=-uxpv\n+\t\t;;\n+\t*-rom68k)\n+\t\tos=-coff\n+\t\t;;\n+\t*-*bug)\n+\t\tos=-coff\n+\t\t;;\n+\t*-apple)\n+\t\tos=-macos\n+\t\t;;\n+\t*-atari*)\n+\t\tos=-mint\n+\t\t;;\n+\t*)\n+\t\tos=-none\n+\t\t;;\n+esac\n+fi\n+\n+# Here we handle the case where we know the os, and the CPU type, but not the\n+# manufacturer.  We pick the logical manufacturer.\n+vendor=unknown\n+case $basic_machine in\n+\t*-unknown)\n+\t\tcase $os in\n+\t\t\t-riscix*)\n+\t\t\t\tvendor=acorn\n+\t\t\t\t;;\n+\t\t\t-sunos*)\n+\t\t\t\tvendor=sun\n+\t\t\t\t;;\n+\t\t\t-cnk*|-aix*)\n+\t\t\t\tvendor=ibm\n+\t\t\t\t;;\n+\t\t\t-beos*)\n+\t\t\t\tvendor=be\n+\t\t\t\t;;\n+\t\t\t-hpux*)\n+\t\t\t\tvendor=hp\n+\t\t\t\t;;\n+\t\t\t-mpeix*)\n+\t\t\t\tvendor=hp\n+\t\t\t\t;;\n+\t\t\t-hiux*)\n+\t\t\t\tvendor=hitachi\n+\t\t\t\t;;\n+\t\t\t-unos*)\n+\t\t\t\tvendor=crds\n+\t\t\t\t;;\n+\t\t\t-dgux*)\n+\t\t\t\tvendor=dg\n+\t\t\t\t;;\n+\t\t\t-luna*)\n+\t\t\t\tvendor=omron\n+\t\t\t\t;;\n+\t\t\t-genix*)\n+\t\t\t\tvendor=ns\n+\t\t\t\t;;\n+\t\t\t-mvs* | -opened*)\n+\t\t\t\tvendor=ibm\n+\t\t\t\t;;\n+\t\t\t-os400*)\n+\t\t\t\tvendor=ibm\n+\t\t\t\t;;\n+\t\t\t-ptx*)\n+\t\t\t\tvendor=sequent\n+\t\t\t\t;;\n+\t\t\t-tpf*)\n+\t\t\t\tvendor=ibm\n+\t\t\t\t;;\n+\t\t\t-vxsim* | -vxworks* | -windiss*)\n+\t\t\t\tvendor=wrs\n+\t\t\t\t;;\n+\t\t\t-aux*)\n+\t\t\t\tvendor=apple\n+\t\t\t\t;;\n+\t\t\t-hms*)\n+\t\t\t\tvendor=hitachi\n+\t\t\t\t;;\n+\t\t\t-mpw* | -macos*)\n+\t\t\t\tvendor=apple\n+\t\t\t\t;;\n+\t\t\t-*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)\n+\t\t\t\tvendor=atari\n+\t\t\t\t;;\n+\t\t\t-vos*)\n+\t\t\t\tvendor=stratus\n+\t\t\t\t;;\n+\t\tesac\n+\t\tbasic_machine=`echo $basic_machine | sed \"s/unknown/$vendor/\"`\n+\t\t;;\n+esac\n+\n+echo $basic_machine$os\n+exit\n+\n+# Local variables:\n+# eval: (add-hook 'write-file-hooks 'time-stamp)\n+# time-stamp-start: \"timestamp='\"\n+# time-stamp-format: \"%:y-%02m-%02d\"\n+# time-stamp-end: \"'\"\n+# End:"}, {"sha": "b16c6a72204e40772688d5e460e1a5e1490a6269", "filename": "libsanitizer/configure", "status": "added", "additions": 17589, "deletions": 0, "changes": 17589, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fconfigure?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932"}, {"sha": "3f186c2b767aa00305a2c36e7dcf9b34fe92a626", "filename": "libsanitizer/configure.ac", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fconfigure.ac?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,42 @@\n+#                                               -*- Autoconf -*-\n+# Process this file with autoconf to produce a configure script.\n+\n+AC_PREREQ([2.68])\n+AC_INIT(package-unused, version-unused, libsanitizer)\n+AC_CONFIG_SRCDIR([include/sanitizer/common_interface_defs.h])\n+AC_CONFIG_AUX_DIR(.)\n+AM_INIT_AUTOMAKE(foreign)\n+\n+# Checks for programs.\n+AC_PROG_CC\n+AC_PROG_CXX\n+AM_PROG_AS\n+\n+AC_LIBTOOL_DLOPEN\n+AM_PROG_LIBTOOL\n+\n+AC_SUBST(enable_shared)\n+AC_SUBST(enable_static)\n+\n+#AM_ENABLE_MULTILIB(, ..)\n+target_alias=${target_alias-$host_alias}\n+AC_SUBST(target_alias)\n+\n+toolexecdir='$(libdir)/gcc-lib/$(target_alias)'\n+toolexeclibdir='$(libdir)'\n+AC_SUBST(toolexecdir)\n+AC_SUBST(toolexeclibdir)\n+\n+AC_CONFIG_FILES([Makefile])\n+\n+AC_CONFIG_FILES(AC_FOREACH([DIR], [interception sanitizer_common asan], [DIR/Makefile ]),\n+  [cat > vpsed$$ << \\_EOF\n+s!`test -f '$<' || echo '$(srcdir)/'`!!\n+_EOF\n+   sed -f vpsed$$ $ac_file > tmp$$\n+   mv tmp$$ $ac_file\n+   rm vpsed$$\n+   echo 'MULTISUBDIR =' >> $ac_file\n+])\n+\n+AC_OUTPUT"}, {"sha": "df8eea7e4ce8862105fcd7929b20bdb45488048b", "filename": "libsanitizer/depcomp", "status": "added", "additions": 630, "deletions": 0, "changes": 630, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fdepcomp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fdepcomp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fdepcomp?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,630 @@\n+#! /bin/sh\n+# depcomp - compile a program generating dependencies as side-effects\n+\n+scriptversion=2009-04-28.21; # UTC\n+\n+# Copyright (C) 1999, 2000, 2003, 2004, 2005, 2006, 2007, 2009 Free\n+# Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2, or (at your option)\n+# any later version.\n+\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+# As a special exception to the GNU General Public License, if you\n+# distribute this file as part of a program that contains a\n+# configuration script generated by Autoconf, you may include it under\n+# the same distribution terms that you use for the rest of that program.\n+\n+# Originally written by Alexandre Oliva <oliva@dcc.unicamp.br>.\n+\n+case $1 in\n+  '')\n+     echo \"$0: No command.  Try \\`$0 --help' for more information.\" 1>&2\n+     exit 1;\n+     ;;\n+  -h | --h*)\n+    cat <<\\EOF\n+Usage: depcomp [--help] [--version] PROGRAM [ARGS]\n+\n+Run PROGRAMS ARGS to compile a file, generating dependencies\n+as side-effects.\n+\n+Environment variables:\n+  depmode     Dependency tracking mode.\n+  source      Source file read by `PROGRAMS ARGS'.\n+  object      Object file output by `PROGRAMS ARGS'.\n+  DEPDIR      directory where to store dependencies.\n+  depfile     Dependency file to output.\n+  tmpdepfile  Temporary file to use when outputing dependencies.\n+  libtool     Whether libtool is used (yes/no).\n+\n+Report bugs to <bug-automake@gnu.org>.\n+EOF\n+    exit $?\n+    ;;\n+  -v | --v*)\n+    echo \"depcomp $scriptversion\"\n+    exit $?\n+    ;;\n+esac\n+\n+if test -z \"$depmode\" || test -z \"$source\" || test -z \"$object\"; then\n+  echo \"depcomp: Variables source, object and depmode must be set\" 1>&2\n+  exit 1\n+fi\n+\n+# Dependencies for sub/bar.o or sub/bar.obj go into sub/.deps/bar.Po.\n+depfile=${depfile-`echo \"$object\" |\n+  sed 's|[^\\\\/]*$|'${DEPDIR-.deps}'/&|;s|\\.\\([^.]*\\)$|.P\\1|;s|Pobj$|Po|'`}\n+tmpdepfile=${tmpdepfile-`echo \"$depfile\" | sed 's/\\.\\([^.]*\\)$/.T\\1/'`}\n+\n+rm -f \"$tmpdepfile\"\n+\n+# Some modes work just like other modes, but use different flags.  We\n+# parameterize here, but still list the modes in the big case below,\n+# to make depend.m4 easier to write.  Note that we *cannot* use a case\n+# here, because this file can only contain one case statement.\n+if test \"$depmode\" = hp; then\n+  # HP compiler uses -M and no extra arg.\n+  gccflag=-M\n+  depmode=gcc\n+fi\n+\n+if test \"$depmode\" = dashXmstdout; then\n+   # This is just like dashmstdout with a different argument.\n+   dashmflag=-xM\n+   depmode=dashmstdout\n+fi\n+\n+cygpath_u=\"cygpath -u -f -\"\n+if test \"$depmode\" = msvcmsys; then\n+   # This is just like msvisualcpp but w/o cygpath translation.\n+   # Just convert the backslash-escaped backslashes to single forward\n+   # slashes to satisfy depend.m4\n+   cygpath_u=\"sed s,\\\\\\\\\\\\\\\\,/,g\"\n+   depmode=msvisualcpp\n+fi\n+\n+case \"$depmode\" in\n+gcc3)\n+## gcc 3 implements dependency tracking that does exactly what\n+## we want.  Yay!  Note: for some reason libtool 1.4 doesn't like\n+## it if -MD -MP comes after the -MF stuff.  Hmm.\n+## Unfortunately, FreeBSD c89 acceptance of flags depends upon\n+## the command line argument order; so add the flags where they\n+## appear in depend2.am.  Note that the slowdown incurred here\n+## affects only configure: in makefiles, %FASTDEP% shortcuts this.\n+  for arg\n+  do\n+    case $arg in\n+    -c) set fnord \"$@\" -MT \"$object\" -MD -MP -MF \"$tmpdepfile\" \"$arg\" ;;\n+    *)  set fnord \"$@\" \"$arg\" ;;\n+    esac\n+    shift # fnord\n+    shift # $arg\n+  done\n+  \"$@\"\n+  stat=$?\n+  if test $stat -eq 0; then :\n+  else\n+    rm -f \"$tmpdepfile\"\n+    exit $stat\n+  fi\n+  mv \"$tmpdepfile\" \"$depfile\"\n+  ;;\n+\n+gcc)\n+## There are various ways to get dependency output from gcc.  Here's\n+## why we pick this rather obscure method:\n+## - Don't want to use -MD because we'd like the dependencies to end\n+##   up in a subdir.  Having to rename by hand is ugly.\n+##   (We might end up doing this anyway to support other compilers.)\n+## - The DEPENDENCIES_OUTPUT environment variable makes gcc act like\n+##   -MM, not -M (despite what the docs say).\n+## - Using -M directly means running the compiler twice (even worse\n+##   than renaming).\n+  if test -z \"$gccflag\"; then\n+    gccflag=-MD,\n+  fi\n+  \"$@\" -Wp,\"$gccflag$tmpdepfile\"\n+  stat=$?\n+  if test $stat -eq 0; then :\n+  else\n+    rm -f \"$tmpdepfile\"\n+    exit $stat\n+  fi\n+  rm -f \"$depfile\"\n+  echo \"$object : \\\\\" > \"$depfile\"\n+  alpha=ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\n+## The second -e expression handles DOS-style file names with drive letters.\n+  sed -e 's/^[^:]*: / /' \\\n+      -e 's/^['$alpha']:\\/[^:]*: / /' < \"$tmpdepfile\" >> \"$depfile\"\n+## This next piece of magic avoids the `deleted header file' problem.\n+## The problem is that when a header file which appears in a .P file\n+## is deleted, the dependency causes make to die (because there is\n+## typically no way to rebuild the header).  We avoid this by adding\n+## dummy dependencies for each header file.  Too bad gcc doesn't do\n+## this for us directly.\n+  tr ' ' '\n+' < \"$tmpdepfile\" |\n+## Some versions of gcc put a space before the `:'.  On the theory\n+## that the space means something, we add a space to the output as\n+## well.\n+## Some versions of the HPUX 10.20 sed can't process this invocation\n+## correctly.  Breaking it into two sed invocations is a workaround.\n+    sed -e 's/^\\\\$//' -e '/^$/d' -e '/:$/d' | sed -e 's/$/ :/' >> \"$depfile\"\n+  rm -f \"$tmpdepfile\"\n+  ;;\n+\n+hp)\n+  # This case exists only to let depend.m4 do its work.  It works by\n+  # looking at the text of this script.  This case will never be run,\n+  # since it is checked for above.\n+  exit 1\n+  ;;\n+\n+sgi)\n+  if test \"$libtool\" = yes; then\n+    \"$@\" \"-Wp,-MDupdate,$tmpdepfile\"\n+  else\n+    \"$@\" -MDupdate \"$tmpdepfile\"\n+  fi\n+  stat=$?\n+  if test $stat -eq 0; then :\n+  else\n+    rm -f \"$tmpdepfile\"\n+    exit $stat\n+  fi\n+  rm -f \"$depfile\"\n+\n+  if test -f \"$tmpdepfile\"; then  # yes, the sourcefile depend on other files\n+    echo \"$object : \\\\\" > \"$depfile\"\n+\n+    # Clip off the initial element (the dependent).  Don't try to be\n+    # clever and replace this with sed code, as IRIX sed won't handle\n+    # lines with more than a fixed number of characters (4096 in\n+    # IRIX 6.2 sed, 8192 in IRIX 6.5).  We also remove comment lines;\n+    # the IRIX cc adds comments like `#:fec' to the end of the\n+    # dependency line.\n+    tr ' ' '\n+' < \"$tmpdepfile\" \\\n+    | sed -e 's/^.*\\.o://' -e 's/#.*$//' -e '/^$/ d' | \\\n+    tr '\n+' ' ' >> \"$depfile\"\n+    echo >> \"$depfile\"\n+\n+    # The second pass generates a dummy entry for each header file.\n+    tr ' ' '\n+' < \"$tmpdepfile\" \\\n+   | sed -e 's/^.*\\.o://' -e 's/#.*$//' -e '/^$/ d' -e 's/$/:/' \\\n+   >> \"$depfile\"\n+  else\n+    # The sourcefile does not contain any dependencies, so just\n+    # store a dummy comment line, to avoid errors with the Makefile\n+    # \"include basename.Plo\" scheme.\n+    echo \"#dummy\" > \"$depfile\"\n+  fi\n+  rm -f \"$tmpdepfile\"\n+  ;;\n+\n+aix)\n+  # The C for AIX Compiler uses -M and outputs the dependencies\n+  # in a .u file.  In older versions, this file always lives in the\n+  # current directory.  Also, the AIX compiler puts `$object:' at the\n+  # start of each line; $object doesn't have directory information.\n+  # Version 6 uses the directory in both cases.\n+  dir=`echo \"$object\" | sed -e 's|/[^/]*$|/|'`\n+  test \"x$dir\" = \"x$object\" && dir=\n+  base=`echo \"$object\" | sed -e 's|^.*/||' -e 's/\\.o$//' -e 's/\\.lo$//'`\n+  if test \"$libtool\" = yes; then\n+    tmpdepfile1=$dir$base.u\n+    tmpdepfile2=$base.u\n+    tmpdepfile3=$dir.libs/$base.u\n+    \"$@\" -Wc,-M\n+  else\n+    tmpdepfile1=$dir$base.u\n+    tmpdepfile2=$dir$base.u\n+    tmpdepfile3=$dir$base.u\n+    \"$@\" -M\n+  fi\n+  stat=$?\n+\n+  if test $stat -eq 0; then :\n+  else\n+    rm -f \"$tmpdepfile1\" \"$tmpdepfile2\" \"$tmpdepfile3\"\n+    exit $stat\n+  fi\n+\n+  for tmpdepfile in \"$tmpdepfile1\" \"$tmpdepfile2\" \"$tmpdepfile3\"\n+  do\n+    test -f \"$tmpdepfile\" && break\n+  done\n+  if test -f \"$tmpdepfile\"; then\n+    # Each line is of the form `foo.o: dependent.h'.\n+    # Do two passes, one to just change these to\n+    # `$object: dependent.h' and one to simply `dependent.h:'.\n+    sed -e \"s,^.*\\.[a-z]*:,$object:,\" < \"$tmpdepfile\" > \"$depfile\"\n+    # That's a tab and a space in the [].\n+    sed -e 's,^.*\\.[a-z]*:[\t ]*,,' -e 's,$,:,' < \"$tmpdepfile\" >> \"$depfile\"\n+  else\n+    # The sourcefile does not contain any dependencies, so just\n+    # store a dummy comment line, to avoid errors with the Makefile\n+    # \"include basename.Plo\" scheme.\n+    echo \"#dummy\" > \"$depfile\"\n+  fi\n+  rm -f \"$tmpdepfile\"\n+  ;;\n+\n+icc)\n+  # Intel's C compiler understands `-MD -MF file'.  However on\n+  #    icc -MD -MF foo.d -c -o sub/foo.o sub/foo.c\n+  # ICC 7.0 will fill foo.d with something like\n+  #    foo.o: sub/foo.c\n+  #    foo.o: sub/foo.h\n+  # which is wrong.  We want:\n+  #    sub/foo.o: sub/foo.c\n+  #    sub/foo.o: sub/foo.h\n+  #    sub/foo.c:\n+  #    sub/foo.h:\n+  # ICC 7.1 will output\n+  #    foo.o: sub/foo.c sub/foo.h\n+  # and will wrap long lines using \\ :\n+  #    foo.o: sub/foo.c ... \\\n+  #     sub/foo.h ... \\\n+  #     ...\n+\n+  \"$@\" -MD -MF \"$tmpdepfile\"\n+  stat=$?\n+  if test $stat -eq 0; then :\n+  else\n+    rm -f \"$tmpdepfile\"\n+    exit $stat\n+  fi\n+  rm -f \"$depfile\"\n+  # Each line is of the form `foo.o: dependent.h',\n+  # or `foo.o: dep1.h dep2.h \\', or ` dep3.h dep4.h \\'.\n+  # Do two passes, one to just change these to\n+  # `$object: dependent.h' and one to simply `dependent.h:'.\n+  sed \"s,^[^:]*:,$object :,\" < \"$tmpdepfile\" > \"$depfile\"\n+  # Some versions of the HPUX 10.20 sed can't process this invocation\n+  # correctly.  Breaking it into two sed invocations is a workaround.\n+  sed 's,^[^:]*: \\(.*\\)$,\\1,;s/^\\\\$//;/^$/d;/:$/d' < \"$tmpdepfile\" |\n+    sed -e 's/$/ :/' >> \"$depfile\"\n+  rm -f \"$tmpdepfile\"\n+  ;;\n+\n+hp2)\n+  # The \"hp\" stanza above does not work with aCC (C++) and HP's ia64\n+  # compilers, which have integrated preprocessors.  The correct option\n+  # to use with these is +Maked; it writes dependencies to a file named\n+  # 'foo.d', which lands next to the object file, wherever that\n+  # happens to be.\n+  # Much of this is similar to the tru64 case; see comments there.\n+  dir=`echo \"$object\" | sed -e 's|/[^/]*$|/|'`\n+  test \"x$dir\" = \"x$object\" && dir=\n+  base=`echo \"$object\" | sed -e 's|^.*/||' -e 's/\\.o$//' -e 's/\\.lo$//'`\n+  if test \"$libtool\" = yes; then\n+    tmpdepfile1=$dir$base.d\n+    tmpdepfile2=$dir.libs/$base.d\n+    \"$@\" -Wc,+Maked\n+  else\n+    tmpdepfile1=$dir$base.d\n+    tmpdepfile2=$dir$base.d\n+    \"$@\" +Maked\n+  fi\n+  stat=$?\n+  if test $stat -eq 0; then :\n+  else\n+     rm -f \"$tmpdepfile1\" \"$tmpdepfile2\"\n+     exit $stat\n+  fi\n+\n+  for tmpdepfile in \"$tmpdepfile1\" \"$tmpdepfile2\"\n+  do\n+    test -f \"$tmpdepfile\" && break\n+  done\n+  if test -f \"$tmpdepfile\"; then\n+    sed -e \"s,^.*\\.[a-z]*:,$object:,\" \"$tmpdepfile\" > \"$depfile\"\n+    # Add `dependent.h:' lines.\n+    sed -ne '2,${\n+\t       s/^ *//\n+\t       s/ \\\\*$//\n+\t       s/$/:/\n+\t       p\n+\t     }' \"$tmpdepfile\" >> \"$depfile\"\n+  else\n+    echo \"#dummy\" > \"$depfile\"\n+  fi\n+  rm -f \"$tmpdepfile\" \"$tmpdepfile2\"\n+  ;;\n+\n+tru64)\n+   # The Tru64 compiler uses -MD to generate dependencies as a side\n+   # effect.  `cc -MD -o foo.o ...' puts the dependencies into `foo.o.d'.\n+   # At least on Alpha/Redhat 6.1, Compaq CCC V6.2-504 seems to put\n+   # dependencies in `foo.d' instead, so we check for that too.\n+   # Subdirectories are respected.\n+   dir=`echo \"$object\" | sed -e 's|/[^/]*$|/|'`\n+   test \"x$dir\" = \"x$object\" && dir=\n+   base=`echo \"$object\" | sed -e 's|^.*/||' -e 's/\\.o$//' -e 's/\\.lo$//'`\n+\n+   if test \"$libtool\" = yes; then\n+      # With Tru64 cc, shared objects can also be used to make a\n+      # static library.  This mechanism is used in libtool 1.4 series to\n+      # handle both shared and static libraries in a single compilation.\n+      # With libtool 1.4, dependencies were output in $dir.libs/$base.lo.d.\n+      #\n+      # With libtool 1.5 this exception was removed, and libtool now\n+      # generates 2 separate objects for the 2 libraries.  These two\n+      # compilations output dependencies in $dir.libs/$base.o.d and\n+      # in $dir$base.o.d.  We have to check for both files, because\n+      # one of the two compilations can be disabled.  We should prefer\n+      # $dir$base.o.d over $dir.libs/$base.o.d because the latter is\n+      # automatically cleaned when .libs/ is deleted, while ignoring\n+      # the former would cause a distcleancheck panic.\n+      tmpdepfile1=$dir.libs/$base.lo.d   # libtool 1.4\n+      tmpdepfile2=$dir$base.o.d          # libtool 1.5\n+      tmpdepfile3=$dir.libs/$base.o.d    # libtool 1.5\n+      tmpdepfile4=$dir.libs/$base.d      # Compaq CCC V6.2-504\n+      \"$@\" -Wc,-MD\n+   else\n+      tmpdepfile1=$dir$base.o.d\n+      tmpdepfile2=$dir$base.d\n+      tmpdepfile3=$dir$base.d\n+      tmpdepfile4=$dir$base.d\n+      \"$@\" -MD\n+   fi\n+\n+   stat=$?\n+   if test $stat -eq 0; then :\n+   else\n+      rm -f \"$tmpdepfile1\" \"$tmpdepfile2\" \"$tmpdepfile3\" \"$tmpdepfile4\"\n+      exit $stat\n+   fi\n+\n+   for tmpdepfile in \"$tmpdepfile1\" \"$tmpdepfile2\" \"$tmpdepfile3\" \"$tmpdepfile4\"\n+   do\n+     test -f \"$tmpdepfile\" && break\n+   done\n+   if test -f \"$tmpdepfile\"; then\n+      sed -e \"s,^.*\\.[a-z]*:,$object:,\" < \"$tmpdepfile\" > \"$depfile\"\n+      # That's a tab and a space in the [].\n+      sed -e 's,^.*\\.[a-z]*:[\t ]*,,' -e 's,$,:,' < \"$tmpdepfile\" >> \"$depfile\"\n+   else\n+      echo \"#dummy\" > \"$depfile\"\n+   fi\n+   rm -f \"$tmpdepfile\"\n+   ;;\n+\n+#nosideeffect)\n+  # This comment above is used by automake to tell side-effect\n+  # dependency tracking mechanisms from slower ones.\n+\n+dashmstdout)\n+  # Important note: in order to support this mode, a compiler *must*\n+  # always write the preprocessed file to stdout, regardless of -o.\n+  \"$@\" || exit $?\n+\n+  # Remove the call to Libtool.\n+  if test \"$libtool\" = yes; then\n+    while test \"X$1\" != 'X--mode=compile'; do\n+      shift\n+    done\n+    shift\n+  fi\n+\n+  # Remove `-o $object'.\n+  IFS=\" \"\n+  for arg\n+  do\n+    case $arg in\n+    -o)\n+      shift\n+      ;;\n+    $object)\n+      shift\n+      ;;\n+    *)\n+      set fnord \"$@\" \"$arg\"\n+      shift # fnord\n+      shift # $arg\n+      ;;\n+    esac\n+  done\n+\n+  test -z \"$dashmflag\" && dashmflag=-M\n+  # Require at least two characters before searching for `:'\n+  # in the target name.  This is to cope with DOS-style filenames:\n+  # a dependency such as `c:/foo/bar' could be seen as target `c' otherwise.\n+  \"$@\" $dashmflag |\n+    sed 's:^[  ]*[^: ][^:][^:]*\\:[    ]*:'\"$object\"'\\: :' > \"$tmpdepfile\"\n+  rm -f \"$depfile\"\n+  cat < \"$tmpdepfile\" > \"$depfile\"\n+  tr ' ' '\n+' < \"$tmpdepfile\" | \\\n+## Some versions of the HPUX 10.20 sed can't process this invocation\n+## correctly.  Breaking it into two sed invocations is a workaround.\n+    sed -e 's/^\\\\$//' -e '/^$/d' -e '/:$/d' | sed -e 's/$/ :/' >> \"$depfile\"\n+  rm -f \"$tmpdepfile\"\n+  ;;\n+\n+dashXmstdout)\n+  # This case only exists to satisfy depend.m4.  It is never actually\n+  # run, as this mode is specially recognized in the preamble.\n+  exit 1\n+  ;;\n+\n+makedepend)\n+  \"$@\" || exit $?\n+  # Remove any Libtool call\n+  if test \"$libtool\" = yes; then\n+    while test \"X$1\" != 'X--mode=compile'; do\n+      shift\n+    done\n+    shift\n+  fi\n+  # X makedepend\n+  shift\n+  cleared=no eat=no\n+  for arg\n+  do\n+    case $cleared in\n+    no)\n+      set \"\"; shift\n+      cleared=yes ;;\n+    esac\n+    if test $eat = yes; then\n+      eat=no\n+      continue\n+    fi\n+    case \"$arg\" in\n+    -D*|-I*)\n+      set fnord \"$@\" \"$arg\"; shift ;;\n+    # Strip any option that makedepend may not understand.  Remove\n+    # the object too, otherwise makedepend will parse it as a source file.\n+    -arch)\n+      eat=yes ;;\n+    -*|$object)\n+      ;;\n+    *)\n+      set fnord \"$@\" \"$arg\"; shift ;;\n+    esac\n+  done\n+  obj_suffix=`echo \"$object\" | sed 's/^.*\\././'`\n+  touch \"$tmpdepfile\"\n+  ${MAKEDEPEND-makedepend} -o\"$obj_suffix\" -f\"$tmpdepfile\" \"$@\"\n+  rm -f \"$depfile\"\n+  cat < \"$tmpdepfile\" > \"$depfile\"\n+  sed '1,2d' \"$tmpdepfile\" | tr ' ' '\n+' | \\\n+## Some versions of the HPUX 10.20 sed can't process this invocation\n+## correctly.  Breaking it into two sed invocations is a workaround.\n+    sed -e 's/^\\\\$//' -e '/^$/d' -e '/:$/d' | sed -e 's/$/ :/' >> \"$depfile\"\n+  rm -f \"$tmpdepfile\" \"$tmpdepfile\".bak\n+  ;;\n+\n+cpp)\n+  # Important note: in order to support this mode, a compiler *must*\n+  # always write the preprocessed file to stdout.\n+  \"$@\" || exit $?\n+\n+  # Remove the call to Libtool.\n+  if test \"$libtool\" = yes; then\n+    while test \"X$1\" != 'X--mode=compile'; do\n+      shift\n+    done\n+    shift\n+  fi\n+\n+  # Remove `-o $object'.\n+  IFS=\" \"\n+  for arg\n+  do\n+    case $arg in\n+    -o)\n+      shift\n+      ;;\n+    $object)\n+      shift\n+      ;;\n+    *)\n+      set fnord \"$@\" \"$arg\"\n+      shift # fnord\n+      shift # $arg\n+      ;;\n+    esac\n+  done\n+\n+  \"$@\" -E |\n+    sed -n -e '/^# [0-9][0-9]* \"\\([^\"]*\\)\".*/ s:: \\1 \\\\:p' \\\n+       -e '/^#line [0-9][0-9]* \"\\([^\"]*\\)\".*/ s:: \\1 \\\\:p' |\n+    sed '$ s: \\\\$::' > \"$tmpdepfile\"\n+  rm -f \"$depfile\"\n+  echo \"$object : \\\\\" > \"$depfile\"\n+  cat < \"$tmpdepfile\" >> \"$depfile\"\n+  sed < \"$tmpdepfile\" '/^$/d;s/^ //;s/ \\\\$//;s/$/ :/' >> \"$depfile\"\n+  rm -f \"$tmpdepfile\"\n+  ;;\n+\n+msvisualcpp)\n+  # Important note: in order to support this mode, a compiler *must*\n+  # always write the preprocessed file to stdout.\n+  \"$@\" || exit $?\n+\n+  # Remove the call to Libtool.\n+  if test \"$libtool\" = yes; then\n+    while test \"X$1\" != 'X--mode=compile'; do\n+      shift\n+    done\n+    shift\n+  fi\n+\n+  IFS=\" \"\n+  for arg\n+  do\n+    case \"$arg\" in\n+    -o)\n+      shift\n+      ;;\n+    $object)\n+      shift\n+      ;;\n+    \"-Gm\"|\"/Gm\"|\"-Gi\"|\"/Gi\"|\"-ZI\"|\"/ZI\")\n+\tset fnord \"$@\"\n+\tshift\n+\tshift\n+\t;;\n+    *)\n+\tset fnord \"$@\" \"$arg\"\n+\tshift\n+\tshift\n+\t;;\n+    esac\n+  done\n+  \"$@\" -E 2>/dev/null |\n+  sed -n '/^#line [0-9][0-9]* \"\\([^\"]*\\)\"/ s::\\1:p' | $cygpath_u | sort -u > \"$tmpdepfile\"\n+  rm -f \"$depfile\"\n+  echo \"$object : \\\\\" > \"$depfile\"\n+  sed < \"$tmpdepfile\" -n -e 's% %\\\\ %g' -e '/^\\(.*\\)$/ s::\t\\1 \\\\:p' >> \"$depfile\"\n+  echo \"\t\" >> \"$depfile\"\n+  sed < \"$tmpdepfile\" -n -e 's% %\\\\ %g' -e '/^\\(.*\\)$/ s::\\1\\::p' >> \"$depfile\"\n+  rm -f \"$tmpdepfile\"\n+  ;;\n+\n+msvcmsys)\n+  # This case exists only to let depend.m4 do its work.  It works by\n+  # looking at the text of this script.  This case will never be run,\n+  # since it is checked for above.\n+  exit 1\n+  ;;\n+\n+none)\n+  exec \"$@\"\n+  ;;\n+\n+*)\n+  echo \"Unknown depmode $depmode\" 1>&2\n+  exit 1\n+  ;;\n+esac\n+\n+exit 0\n+\n+# Local Variables:\n+# mode: shell-script\n+# sh-indentation: 2\n+# eval: (add-hook 'write-file-hooks 'time-stamp)\n+# time-stamp-start: \"scriptversion=\"\n+# time-stamp-format: \"%:y-%02m-%02d.%02H\"\n+# time-stamp-time-zone: \"UTC\"\n+# time-stamp-end: \"; # UTC\"\n+# End:"}, {"sha": "c7d57d604bfb424259411d49df945fdfaf6e47a6", "filename": "libsanitizer/include/sanitizer/asan_interface.h", "status": "added", "additions": 197, "deletions": 0, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Finclude%2Fsanitizer%2Fasan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Finclude%2Fsanitizer%2Fasan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fasan_interface.h?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,197 @@\n+//===-- sanitizer/asan_interface.h ------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// This header can be included by the instrumented program to fetch\n+// data (mostly allocator statistics) from ASan runtime library.\n+//===----------------------------------------------------------------------===//\n+#ifndef SANITIZER_ASAN_INTERFACE_H\n+#define SANITIZER_ASAN_INTERFACE_H\n+\n+#include <sanitizer/common_interface_defs.h>\n+\n+// ----------- ATTENTION -------------\n+// This header should NOT include any other headers from ASan runtime.\n+// All functions in this header are extern \"C\" and start with __asan_.\n+\n+using __sanitizer::uptr;\n+\n+extern \"C\" {\n+  // This function should be called at the very beginning of the process,\n+  // before any instrumented code is executed and before any call to malloc.\n+  void __asan_init() SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+  // This function should be called by the instrumented code.\n+  // 'addr' is the address of a global variable called 'name' of 'size' bytes.\n+  void __asan_register_global(uptr addr, uptr size, const char *name)\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+  // This structure describes an instrumented global variable.\n+  struct __asan_global {\n+    uptr beg;                // The address of the global.\n+    uptr size;               // The original size of the global.\n+    uptr size_with_redzone;  // The size with the redzone.\n+    const char *name;        // Name as a C string.\n+    uptr has_dynamic_init;   // Non-zero if the global has dynamic initializer.\n+  };\n+\n+  // These two functions should be called by the instrumented code.\n+  // 'globals' is an array of structures describing 'n' globals.\n+  void __asan_register_globals(__asan_global *globals, uptr n)\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n+  void __asan_unregister_globals(__asan_global *globals, uptr n)\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+  // These two functions should be called before and after dynamic initializers\n+  // run, respectively.  They should be called with parameters describing all\n+  // dynamically initialized globals defined in the calling TU.\n+  void __asan_before_dynamic_init(uptr first_addr, uptr last_addr)\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n+  void __asan_after_dynamic_init()\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+  // These two functions are used by the instrumented code in the\n+  // use-after-return mode. __asan_stack_malloc allocates size bytes of\n+  // fake stack and __asan_stack_free poisons it. real_stack is a pointer to\n+  // the real stack region.\n+  uptr __asan_stack_malloc(uptr size, uptr real_stack)\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n+  void __asan_stack_free(uptr ptr, uptr size, uptr real_stack)\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+  // Marks memory region [addr, addr+size) as unaddressable.\n+  // This memory must be previously allocated by the user program. Accessing\n+  // addresses in this region from instrumented code is forbidden until\n+  // this region is unpoisoned. This function is not guaranteed to poison\n+  // the whole region - it may poison only subregion of [addr, addr+size) due\n+  // to ASan alignment restrictions.\n+  // Method is NOT thread-safe in the sense that no two threads can\n+  // (un)poison memory in the same memory region simultaneously.\n+  void __asan_poison_memory_region(void const volatile *addr, uptr size)\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n+  // Marks memory region [addr, addr+size) as addressable.\n+  // This memory must be previously allocated by the user program. Accessing\n+  // addresses in this region is allowed until this region is poisoned again.\n+  // This function may unpoison a superregion of [addr, addr+size) due to\n+  // ASan alignment restrictions.\n+  // Method is NOT thread-safe in the sense that no two threads can\n+  // (un)poison memory in the same memory region simultaneously.\n+  void __asan_unpoison_memory_region(void const volatile *addr, uptr size)\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+  // Performs cleanup before a NoReturn function. Must be called before things\n+  // like _exit and execl to avoid false positives on stack.\n+  void __asan_handle_no_return() SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+// User code should use macro instead of functions.\n+#if __has_feature(address_sanitizer)\n+#define ASAN_POISON_MEMORY_REGION(addr, size) \\\n+  __asan_poison_memory_region((addr), (size))\n+#define ASAN_UNPOISON_MEMORY_REGION(addr, size) \\\n+  __asan_unpoison_memory_region((addr), (size))\n+#else\n+#define ASAN_POISON_MEMORY_REGION(addr, size) \\\n+  ((void)(addr), (void)(size))\n+#define ASAN_UNPOISON_MEMORY_REGION(addr, size) \\\n+  ((void)(addr), (void)(size))\n+#endif\n+\n+  // Returns true iff addr is poisoned (i.e. 1-byte read/write access to this\n+  // address will result in error report from AddressSanitizer).\n+  bool __asan_address_is_poisoned(void const volatile *addr)\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+  // This is an internal function that is called to report an error.\n+  // However it is still a part of the interface because users may want to\n+  // set a breakpoint on this function in a debugger.\n+  void __asan_report_error(uptr pc, uptr bp, uptr sp,\n+                           uptr addr, bool is_write, uptr access_size)\n+    SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+  // Sets the exit code to use when reporting an error.\n+  // Returns the old value.\n+  int __asan_set_error_exit_code(int exit_code)\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+  // Sets the callback to be called right before death on error.\n+  // Passing 0 will unset the callback.\n+  void __asan_set_death_callback(void (*callback)(void))\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+  void __asan_set_error_report_callback(void (*callback)(const char*))\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+  // User may provide function that would be called right when ASan detects\n+  // an error. This can be used to notice cases when ASan detects an error, but\n+  // the program crashes before ASan report is printed.\n+  void __asan_on_error()\n+      SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+  // User may provide its own implementation for symbolization function.\n+  // It should print the description of instruction at address \"pc\" to\n+  // \"out_buffer\". Description should be at most \"out_size\" bytes long.\n+  // User-specified function should return true if symbolization was\n+  // successful.\n+  bool __asan_symbolize(const void *pc, char *out_buffer, int out_size)\n+      SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+  // Returns the estimated number of bytes that will be reserved by allocator\n+  // for request of \"size\" bytes. If ASan allocator can't allocate that much\n+  // memory, returns the maximal possible allocation size, otherwise returns\n+  // \"size\".\n+  uptr __asan_get_estimated_allocated_size(uptr size)\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n+  // Returns true if p was returned by the ASan allocator and\n+  // is not yet freed.\n+  bool __asan_get_ownership(const void *p)\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n+  // Returns the number of bytes reserved for the pointer p.\n+  // Requires (get_ownership(p) == true) or (p == 0).\n+  uptr __asan_get_allocated_size(const void *p)\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n+  // Number of bytes, allocated and not yet freed by the application.\n+  uptr __asan_get_current_allocated_bytes()\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n+  // Number of bytes, mmaped by asan allocator to fulfill allocation requests.\n+  // Generally, for request of X bytes, allocator can reserve and add to free\n+  // lists a large number of chunks of size X to use them for future requests.\n+  // All these chunks count toward the heap size. Currently, allocator never\n+  // releases memory to OS (instead, it just puts freed chunks to free lists).\n+  uptr __asan_get_heap_size()\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n+  // Number of bytes, mmaped by asan allocator, which can be used to fulfill\n+  // allocation requests. When a user program frees memory chunk, it can first\n+  // fall into quarantine and will count toward __asan_get_free_bytes() later.\n+  uptr __asan_get_free_bytes()\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n+  // Number of bytes in unmapped pages, that are released to OS. Currently,\n+  // always returns 0.\n+  uptr __asan_get_unmapped_bytes()\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n+  // Prints accumulated stats to stderr. Used for debugging.\n+  void __asan_print_accumulated_stats()\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+  // This function may be overriden by user to provide a string containing\n+  // ASan runtime options. See asan_flags.h for details.\n+  const char* __asan_default_options()\n+      SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+  // Malloc hooks that may be overriden by user.\n+  // __asan_malloc_hook(ptr, size) is called immediately after\n+  //   allocation of \"size\" bytes, which returned \"ptr\".\n+  // __asan_free_hook(ptr) is called immediately before\n+  //   deallocation of \"ptr\".\n+  // If user doesn't provide implementations of these hooks, they are no-op.\n+  void __asan_malloc_hook(void *ptr, uptr size)\n+      SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+  void __asan_free_hook(void *ptr)\n+      SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+}  // extern \"C\"\n+\n+#endif  // SANITIZER_ASAN_INTERFACE_H"}, {"sha": "4ac7609c6759d9ec66f43a7e1d7cc5c625e8241c", "filename": "libsanitizer/include/sanitizer/common_interface_defs.h", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,66 @@\n+//===-- sanitizer/common_interface_defs.h -----------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is shared between AddressSanitizer and ThreadSanitizer.\n+// It contains basic macro and types.\n+// NOTE: This file may be included into user code.\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef SANITIZER_COMMON_INTERFACE_DEFS_H\n+#define SANITIZER_COMMON_INTERFACE_DEFS_H\n+\n+// ----------- ATTENTION -------------\n+// This header should NOT include any other headers to avoid portability issues.\n+\n+#if defined(_WIN32)\n+// FIXME find out what we need on Windows. __declspec(dllexport) ?\n+# define SANITIZER_INTERFACE_ATTRIBUTE\n+# define SANITIZER_WEAK_ATTRIBUTE\n+#elif defined(SANITIZER_GO)\n+# define SANITIZER_INTERFACE_ATTRIBUTE\n+# define SANITIZER_WEAK_ATTRIBUTE\n+#else\n+# define SANITIZER_INTERFACE_ATTRIBUTE __attribute__((visibility(\"default\")))\n+# define SANITIZER_WEAK_ATTRIBUTE  __attribute__((weak))\n+#endif\n+\n+// __has_feature\n+#if !defined(__has_feature)\n+# define __has_feature(x) 0\n+#endif\n+\n+// For portability reasons we do not include stddef.h, stdint.h or any other\n+// system header, but we do need some basic types that are not defined\n+// in a portable way by the language itself.\n+namespace __sanitizer {\n+\n+#if defined(_WIN64)\n+// 64-bit Windows uses LLP64 data model.\n+typedef unsigned long long uptr;  // NOLINT\n+typedef signed   long long sptr;  // NOLINT\n+#else\n+typedef unsigned long uptr;  // NOLINT\n+typedef signed   long sptr;  // NOLINT\n+#endif  // defined(_WIN64)\n+typedef unsigned char u8;\n+typedef unsigned short u16;  // NOLINT\n+typedef unsigned int u32;\n+typedef unsigned long long u64;  // NOLINT\n+typedef signed   char s8;\n+typedef signed   short s16;  // NOLINT\n+typedef signed   int s32;\n+typedef signed   long long s64;  // NOLINT\n+\n+}  // namespace __sanitizer\n+\n+extern \"C\" {\n+  // Tell the tools to write their reports to \"path.<pid>\" instead of stderr.\n+  void __sanitizer_set_report_path(const char *path)\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n+}  // extern \"C\"\n+\n+#endif  // SANITIZER_COMMON_INTERFACE_DEFS_H"}, {"sha": "a9244eb0786534553fdd9eb0050bb4b172bad0a3", "filename": "libsanitizer/install-sh", "status": "added", "additions": 527, "deletions": 0, "changes": 527, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Finstall-sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Finstall-sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finstall-sh?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,527 @@\n+#!/bin/sh\n+# install - install a program, script, or datafile\n+\n+scriptversion=2011-01-19.21; # UTC\n+\n+# This originates from X11R5 (mit/util/scripts/install.sh), which was\n+# later released in X11R6 (xc/config/util/install.sh) with the\n+# following copyright and license.\n+#\n+# Copyright (C) 1994 X Consortium\n+#\n+# Permission is hereby granted, free of charge, to any person obtaining a copy\n+# of this software and associated documentation files (the \"Software\"), to\n+# deal in the Software without restriction, including without limitation the\n+# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+# sell copies of the Software, and to permit persons to whom the Software is\n+# furnished to do so, subject to the following conditions:\n+#\n+# The above copyright notice and this permission notice shall be included in\n+# all copies or substantial portions of the Software.\n+#\n+# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n+# X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN\n+# AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNEC-\n+# TION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n+#\n+# Except as contained in this notice, the name of the X Consortium shall not\n+# be used in advertising or otherwise to promote the sale, use or other deal-\n+# ings in this Software without prior written authorization from the X Consor-\n+# tium.\n+#\n+#\n+# FSF changes to this file are in the public domain.\n+#\n+# Calling this script install-sh is preferred over install.sh, to prevent\n+# `make' implicit rules from creating a file called install from it\n+# when there is no Makefile.\n+#\n+# This script is compatible with the BSD install script, but was written\n+# from scratch.\n+\n+nl='\n+'\n+IFS=\" \"\"\t$nl\"\n+\n+# set DOITPROG to echo to test this script\n+\n+# Don't use :- since 4.3BSD and earlier shells don't like it.\n+doit=${DOITPROG-}\n+if test -z \"$doit\"; then\n+  doit_exec=exec\n+else\n+  doit_exec=$doit\n+fi\n+\n+# Put in absolute file names if you don't have them in your path;\n+# or use environment vars.\n+\n+chgrpprog=${CHGRPPROG-chgrp}\n+chmodprog=${CHMODPROG-chmod}\n+chownprog=${CHOWNPROG-chown}\n+cmpprog=${CMPPROG-cmp}\n+cpprog=${CPPROG-cp}\n+mkdirprog=${MKDIRPROG-mkdir}\n+mvprog=${MVPROG-mv}\n+rmprog=${RMPROG-rm}\n+stripprog=${STRIPPROG-strip}\n+\n+posix_glob='?'\n+initialize_posix_glob='\n+  test \"$posix_glob\" != \"?\" || {\n+    if (set -f) 2>/dev/null; then\n+      posix_glob=\n+    else\n+      posix_glob=:\n+    fi\n+  }\n+'\n+\n+posix_mkdir=\n+\n+# Desired mode of installed file.\n+mode=0755\n+\n+chgrpcmd=\n+chmodcmd=$chmodprog\n+chowncmd=\n+mvcmd=$mvprog\n+rmcmd=\"$rmprog -f\"\n+stripcmd=\n+\n+src=\n+dst=\n+dir_arg=\n+dst_arg=\n+\n+copy_on_change=false\n+no_target_directory=\n+\n+usage=\"\\\n+Usage: $0 [OPTION]... [-T] SRCFILE DSTFILE\n+   or: $0 [OPTION]... SRCFILES... DIRECTORY\n+   or: $0 [OPTION]... -t DIRECTORY SRCFILES...\n+   or: $0 [OPTION]... -d DIRECTORIES...\n+\n+In the 1st form, copy SRCFILE to DSTFILE.\n+In the 2nd and 3rd, copy all SRCFILES to DIRECTORY.\n+In the 4th, create DIRECTORIES.\n+\n+Options:\n+     --help     display this help and exit.\n+     --version  display version info and exit.\n+\n+  -c            (ignored)\n+  -C            install only if different (preserve the last data modification time)\n+  -d            create directories instead of installing files.\n+  -g GROUP      $chgrpprog installed files to GROUP.\n+  -m MODE       $chmodprog installed files to MODE.\n+  -o USER       $chownprog installed files to USER.\n+  -s            $stripprog installed files.\n+  -t DIRECTORY  install into DIRECTORY.\n+  -T            report an error if DSTFILE is a directory.\n+\n+Environment variables override the default commands:\n+  CHGRPPROG CHMODPROG CHOWNPROG CMPPROG CPPROG MKDIRPROG MVPROG\n+  RMPROG STRIPPROG\n+\"\n+\n+while test $# -ne 0; do\n+  case $1 in\n+    -c) ;;\n+\n+    -C) copy_on_change=true;;\n+\n+    -d) dir_arg=true;;\n+\n+    -g) chgrpcmd=\"$chgrpprog $2\"\n+\tshift;;\n+\n+    --help) echo \"$usage\"; exit $?;;\n+\n+    -m) mode=$2\n+\tcase $mode in\n+\t  *' '* | *'\t'* | *'\n+'*\t  | *'*'* | *'?'* | *'['*)\n+\t    echo \"$0: invalid mode: $mode\" >&2\n+\t    exit 1;;\n+\tesac\n+\tshift;;\n+\n+    -o) chowncmd=\"$chownprog $2\"\n+\tshift;;\n+\n+    -s) stripcmd=$stripprog;;\n+\n+    -t) dst_arg=$2\n+\t# Protect names problematic for `test' and other utilities.\n+\tcase $dst_arg in\n+\t  -* | [=\\(\\)!]) dst_arg=./$dst_arg;;\n+\tesac\n+\tshift;;\n+\n+    -T) no_target_directory=true;;\n+\n+    --version) echo \"$0 $scriptversion\"; exit $?;;\n+\n+    --)\tshift\n+\tbreak;;\n+\n+    -*)\techo \"$0: invalid option: $1\" >&2\n+\texit 1;;\n+\n+    *)  break;;\n+  esac\n+  shift\n+done\n+\n+if test $# -ne 0 && test -z \"$dir_arg$dst_arg\"; then\n+  # When -d is used, all remaining arguments are directories to create.\n+  # When -t is used, the destination is already specified.\n+  # Otherwise, the last argument is the destination.  Remove it from $@.\n+  for arg\n+  do\n+    if test -n \"$dst_arg\"; then\n+      # $@ is not empty: it contains at least $arg.\n+      set fnord \"$@\" \"$dst_arg\"\n+      shift # fnord\n+    fi\n+    shift # arg\n+    dst_arg=$arg\n+    # Protect names problematic for `test' and other utilities.\n+    case $dst_arg in\n+      -* | [=\\(\\)!]) dst_arg=./$dst_arg;;\n+    esac\n+  done\n+fi\n+\n+if test $# -eq 0; then\n+  if test -z \"$dir_arg\"; then\n+    echo \"$0: no input file specified.\" >&2\n+    exit 1\n+  fi\n+  # It's OK to call `install-sh -d' without argument.\n+  # This can happen when creating conditional directories.\n+  exit 0\n+fi\n+\n+if test -z \"$dir_arg\"; then\n+  do_exit='(exit $ret); exit $ret'\n+  trap \"ret=129; $do_exit\" 1\n+  trap \"ret=130; $do_exit\" 2\n+  trap \"ret=141; $do_exit\" 13\n+  trap \"ret=143; $do_exit\" 15\n+\n+  # Set umask so as not to create temps with too-generous modes.\n+  # However, 'strip' requires both read and write access to temps.\n+  case $mode in\n+    # Optimize common cases.\n+    *644) cp_umask=133;;\n+    *755) cp_umask=22;;\n+\n+    *[0-7])\n+      if test -z \"$stripcmd\"; then\n+\tu_plus_rw=\n+      else\n+\tu_plus_rw='% 200'\n+      fi\n+      cp_umask=`expr '(' 777 - $mode % 1000 ')' $u_plus_rw`;;\n+    *)\n+      if test -z \"$stripcmd\"; then\n+\tu_plus_rw=\n+      else\n+\tu_plus_rw=,u+rw\n+      fi\n+      cp_umask=$mode$u_plus_rw;;\n+  esac\n+fi\n+\n+for src\n+do\n+  # Protect names problematic for `test' and other utilities.\n+  case $src in\n+    -* | [=\\(\\)!]) src=./$src;;\n+  esac\n+\n+  if test -n \"$dir_arg\"; then\n+    dst=$src\n+    dstdir=$dst\n+    test -d \"$dstdir\"\n+    dstdir_status=$?\n+  else\n+\n+    # Waiting for this to be detected by the \"$cpprog $src $dsttmp\" command\n+    # might cause directories to be created, which would be especially bad\n+    # if $src (and thus $dsttmp) contains '*'.\n+    if test ! -f \"$src\" && test ! -d \"$src\"; then\n+      echo \"$0: $src does not exist.\" >&2\n+      exit 1\n+    fi\n+\n+    if test -z \"$dst_arg\"; then\n+      echo \"$0: no destination specified.\" >&2\n+      exit 1\n+    fi\n+    dst=$dst_arg\n+\n+    # If destination is a directory, append the input filename; won't work\n+    # if double slashes aren't ignored.\n+    if test -d \"$dst\"; then\n+      if test -n \"$no_target_directory\"; then\n+\techo \"$0: $dst_arg: Is a directory\" >&2\n+\texit 1\n+      fi\n+      dstdir=$dst\n+      dst=$dstdir/`basename \"$src\"`\n+      dstdir_status=0\n+    else\n+      # Prefer dirname, but fall back on a substitute if dirname fails.\n+      dstdir=`\n+\t(dirname \"$dst\") 2>/dev/null ||\n+\texpr X\"$dst\" : 'X\\(.*[^/]\\)//*[^/][^/]*/*$' \\| \\\n+\t     X\"$dst\" : 'X\\(//\\)[^/]' \\| \\\n+\t     X\"$dst\" : 'X\\(//\\)$' \\| \\\n+\t     X\"$dst\" : 'X\\(/\\)' \\| . 2>/dev/null ||\n+\techo X\"$dst\" |\n+\t    sed '/^X\\(.*[^/]\\)\\/\\/*[^/][^/]*\\/*$/{\n+\t\t   s//\\1/\n+\t\t   q\n+\t\t }\n+\t\t /^X\\(\\/\\/\\)[^/].*/{\n+\t\t   s//\\1/\n+\t\t   q\n+\t\t }\n+\t\t /^X\\(\\/\\/\\)$/{\n+\t\t   s//\\1/\n+\t\t   q\n+\t\t }\n+\t\t /^X\\(\\/\\).*/{\n+\t\t   s//\\1/\n+\t\t   q\n+\t\t }\n+\t\t s/.*/./; q'\n+      `\n+\n+      test -d \"$dstdir\"\n+      dstdir_status=$?\n+    fi\n+  fi\n+\n+  obsolete_mkdir_used=false\n+\n+  if test $dstdir_status != 0; then\n+    case $posix_mkdir in\n+      '')\n+\t# Create intermediate dirs using mode 755 as modified by the umask.\n+\t# This is like FreeBSD 'install' as of 1997-10-28.\n+\tumask=`umask`\n+\tcase $stripcmd.$umask in\n+\t  # Optimize common cases.\n+\t  *[2367][2367]) mkdir_umask=$umask;;\n+\t  .*0[02][02] | .[02][02] | .[02]) mkdir_umask=22;;\n+\n+\t  *[0-7])\n+\t    mkdir_umask=`expr $umask + 22 \\\n+\t      - $umask % 100 % 40 + $umask % 20 \\\n+\t      - $umask % 10 % 4 + $umask % 2\n+\t    `;;\n+\t  *) mkdir_umask=$umask,go-w;;\n+\tesac\n+\n+\t# With -d, create the new directory with the user-specified mode.\n+\t# Otherwise, rely on $mkdir_umask.\n+\tif test -n \"$dir_arg\"; then\n+\t  mkdir_mode=-m$mode\n+\telse\n+\t  mkdir_mode=\n+\tfi\n+\n+\tposix_mkdir=false\n+\tcase $umask in\n+\t  *[123567][0-7][0-7])\n+\t    # POSIX mkdir -p sets u+wx bits regardless of umask, which\n+\t    # is incompatible with FreeBSD 'install' when (umask & 300) != 0.\n+\t    ;;\n+\t  *)\n+\t    tmpdir=${TMPDIR-/tmp}/ins$RANDOM-$$\n+\t    trap 'ret=$?; rmdir \"$tmpdir/d\" \"$tmpdir\" 2>/dev/null; exit $ret' 0\n+\n+\t    if (umask $mkdir_umask &&\n+\t\texec $mkdirprog $mkdir_mode -p -- \"$tmpdir/d\") >/dev/null 2>&1\n+\t    then\n+\t      if test -z \"$dir_arg\" || {\n+\t\t   # Check for POSIX incompatibilities with -m.\n+\t\t   # HP-UX 11.23 and IRIX 6.5 mkdir -m -p sets group- or\n+\t\t   # other-writeable bit of parent directory when it shouldn't.\n+\t\t   # FreeBSD 6.1 mkdir -m -p sets mode of existing directory.\n+\t\t   ls_ld_tmpdir=`ls -ld \"$tmpdir\"`\n+\t\t   case $ls_ld_tmpdir in\n+\t\t     d????-?r-*) different_mode=700;;\n+\t\t     d????-?--*) different_mode=755;;\n+\t\t     *) false;;\n+\t\t   esac &&\n+\t\t   $mkdirprog -m$different_mode -p -- \"$tmpdir\" && {\n+\t\t     ls_ld_tmpdir_1=`ls -ld \"$tmpdir\"`\n+\t\t     test \"$ls_ld_tmpdir\" = \"$ls_ld_tmpdir_1\"\n+\t\t   }\n+\t\t }\n+\t      then posix_mkdir=:\n+\t      fi\n+\t      rmdir \"$tmpdir/d\" \"$tmpdir\"\n+\t    else\n+\t      # Remove any dirs left behind by ancient mkdir implementations.\n+\t      rmdir ./$mkdir_mode ./-p ./-- 2>/dev/null\n+\t    fi\n+\t    trap '' 0;;\n+\tesac;;\n+    esac\n+\n+    if\n+      $posix_mkdir && (\n+\tumask $mkdir_umask &&\n+\t$doit_exec $mkdirprog $mkdir_mode -p -- \"$dstdir\"\n+      )\n+    then :\n+    else\n+\n+      # The umask is ridiculous, or mkdir does not conform to POSIX,\n+      # or it failed possibly due to a race condition.  Create the\n+      # directory the slow way, step by step, checking for races as we go.\n+\n+      case $dstdir in\n+\t/*) prefix='/';;\n+\t[-=\\(\\)!]*) prefix='./';;\n+\t*)  prefix='';;\n+      esac\n+\n+      eval \"$initialize_posix_glob\"\n+\n+      oIFS=$IFS\n+      IFS=/\n+      $posix_glob set -f\n+      set fnord $dstdir\n+      shift\n+      $posix_glob set +f\n+      IFS=$oIFS\n+\n+      prefixes=\n+\n+      for d\n+      do\n+\ttest X\"$d\" = X && continue\n+\n+\tprefix=$prefix$d\n+\tif test -d \"$prefix\"; then\n+\t  prefixes=\n+\telse\n+\t  if $posix_mkdir; then\n+\t    (umask=$mkdir_umask &&\n+\t     $doit_exec $mkdirprog $mkdir_mode -p -- \"$dstdir\") && break\n+\t    # Don't fail if two instances are running concurrently.\n+\t    test -d \"$prefix\" || exit 1\n+\t  else\n+\t    case $prefix in\n+\t      *\\'*) qprefix=`echo \"$prefix\" | sed \"s/'/'\\\\\\\\\\\\\\\\''/g\"`;;\n+\t      *) qprefix=$prefix;;\n+\t    esac\n+\t    prefixes=\"$prefixes '$qprefix'\"\n+\t  fi\n+\tfi\n+\tprefix=$prefix/\n+      done\n+\n+      if test -n \"$prefixes\"; then\n+\t# Don't fail if two instances are running concurrently.\n+\t(umask $mkdir_umask &&\n+\t eval \"\\$doit_exec \\$mkdirprog $prefixes\") ||\n+\t  test -d \"$dstdir\" || exit 1\n+\tobsolete_mkdir_used=true\n+      fi\n+    fi\n+  fi\n+\n+  if test -n \"$dir_arg\"; then\n+    { test -z \"$chowncmd\" || $doit $chowncmd \"$dst\"; } &&\n+    { test -z \"$chgrpcmd\" || $doit $chgrpcmd \"$dst\"; } &&\n+    { test \"$obsolete_mkdir_used$chowncmd$chgrpcmd\" = false ||\n+      test -z \"$chmodcmd\" || $doit $chmodcmd $mode \"$dst\"; } || exit 1\n+  else\n+\n+    # Make a couple of temp file names in the proper directory.\n+    dsttmp=$dstdir/_inst.$$_\n+    rmtmp=$dstdir/_rm.$$_\n+\n+    # Trap to clean up those temp files at exit.\n+    trap 'ret=$?; rm -f \"$dsttmp\" \"$rmtmp\" && exit $ret' 0\n+\n+    # Copy the file name to the temp name.\n+    (umask $cp_umask && $doit_exec $cpprog \"$src\" \"$dsttmp\") &&\n+\n+    # and set any options; do chmod last to preserve setuid bits.\n+    #\n+    # If any of these fail, we abort the whole thing.  If we want to\n+    # ignore errors from any of these, just make sure not to ignore\n+    # errors from the above \"$doit $cpprog $src $dsttmp\" command.\n+    #\n+    { test -z \"$chowncmd\" || $doit $chowncmd \"$dsttmp\"; } &&\n+    { test -z \"$chgrpcmd\" || $doit $chgrpcmd \"$dsttmp\"; } &&\n+    { test -z \"$stripcmd\" || $doit $stripcmd \"$dsttmp\"; } &&\n+    { test -z \"$chmodcmd\" || $doit $chmodcmd $mode \"$dsttmp\"; } &&\n+\n+    # If -C, don't bother to copy if it wouldn't change the file.\n+    if $copy_on_change &&\n+       old=`LC_ALL=C ls -dlL \"$dst\"\t2>/dev/null` &&\n+       new=`LC_ALL=C ls -dlL \"$dsttmp\"\t2>/dev/null` &&\n+\n+       eval \"$initialize_posix_glob\" &&\n+       $posix_glob set -f &&\n+       set X $old && old=:$2:$4:$5:$6 &&\n+       set X $new && new=:$2:$4:$5:$6 &&\n+       $posix_glob set +f &&\n+\n+       test \"$old\" = \"$new\" &&\n+       $cmpprog \"$dst\" \"$dsttmp\" >/dev/null 2>&1\n+    then\n+      rm -f \"$dsttmp\"\n+    else\n+      # Rename the file to the real destination.\n+      $doit $mvcmd -f \"$dsttmp\" \"$dst\" 2>/dev/null ||\n+\n+      # The rename failed, perhaps because mv can't rename something else\n+      # to itself, or perhaps because mv is so ancient that it does not\n+      # support -f.\n+      {\n+\t# Now remove or move aside any old file at destination location.\n+\t# We try this two ways since rm can't unlink itself on some\n+\t# systems and the destination file might be busy for other\n+\t# reasons.  In this case, the final cleanup might fail but the new\n+\t# file should still install successfully.\n+\t{\n+\t  test ! -f \"$dst\" ||\n+\t  $doit $rmcmd -f \"$dst\" 2>/dev/null ||\n+\t  { $doit $mvcmd -f \"$dst\" \"$rmtmp\" 2>/dev/null &&\n+\t    { $doit $rmcmd -f \"$rmtmp\" 2>/dev/null; :; }\n+\t  } ||\n+\t  { echo \"$0: cannot unlink or rename $dst\" >&2\n+\t    (exit 1); exit 1\n+\t  }\n+\t} &&\n+\n+\t# Now rename the file to the real destination.\n+\t$doit $mvcmd \"$dsttmp\" \"$dst\"\n+      }\n+    fi || exit 1\n+\n+    trap '' 0\n+  fi\n+done\n+\n+# Local variables:\n+# eval: (add-hook 'write-file-hooks 'time-stamp)\n+# time-stamp-start: \"scriptversion=\"\n+# time-stamp-format: \"%:y-%02m-%02d.%02H\"\n+# time-stamp-time-zone: \"UTC\"\n+# time-stamp-end: \"; # UTC\"\n+# End:"}, {"sha": "4fd200cadcb8a7f1fe3e05cd3ed53c66be720504", "filename": "libsanitizer/interception/Makefile.am", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Finterception%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Finterception%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2FMakefile.am?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,59 @@\n+AM_CPPFLAGS = -I $(top_srcdir)/include \n+ \n+DEFS = -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS \n+AM_CXXFLAGS = -Wall -W -Wno-unused-parameter -Wwrite-strings -pedantic -Wno-long-long  -fPIC -fno-builtin -fno-exceptions -fomit-frame-pointer -funwind-tables -fvisibility=hidden -Wno-variadic-macros -Wno-c99-extensions \n+ACLOCAL_AMFLAGS = -I m4\n+\n+noinst_LTLIBRARIES = libinterception.la\n+\n+interception_files = \\\n+        interception_linux.cc \\\n+        interception_mac.cc \\\n+        interception_win.cc\n+\n+libinterception_la_SOURCES = $(interception_files) \n+\n+# Work around what appears to be a GNU make bug handling MAKEFLAGS\n+# values defined in terms of make variables, as is the case for CC and\n+# friends when we are called from the top level Makefile.\n+AM_MAKEFLAGS = \\\n+\t\"AR_FLAGS=$(AR_FLAGS)\" \\\n+\t\"CC_FOR_BUILD=$(CC_FOR_BUILD)\" \\\n+\t\"CFLAGS=$(CFLAGS)\" \\\n+\t\"CXXFLAGS=$(CXXFLAGS)\" \\\n+\t\"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)\" \\\n+\t\"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)\" \\\n+\t\"INSTALL=$(INSTALL)\" \\\n+\t\"INSTALL_DATA=$(INSTALL_DATA)\" \\\n+\t\"INSTALL_PROGRAM=$(INSTALL_PROGRAM)\" \\\n+\t\"INSTALL_SCRIPT=$(INSTALL_SCRIPT)\" \\\n+\t\"JC1FLAGS=$(JC1FLAGS)\" \\\n+\t\"LDFLAGS=$(LDFLAGS)\" \\\n+\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+\t\"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\"MAKE=$(MAKE)\" \\\n+\t\"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)\" \\\n+\t\"PICFLAG=$(PICFLAG)\" \\\n+\t\"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)\" \\\n+\t\"SHELL=$(SHELL)\" \\\n+\t\"RUNTESTFLAGS=$(RUNTESTFLAGS)\" \\\n+\t\"exec_prefix=$(exec_prefix)\" \\\n+\t\"infodir=$(infodir)\" \\\n+\t\"libdir=$(libdir)\" \\\n+\t\"prefix=$(prefix)\" \\\n+\t\"includedir=$(includedir)\" \\\n+\t\"AR=$(AR)\" \\\n+\t\"AS=$(AS)\" \\\n+\t\"CC=$(CC)\" \\\n+\t\"CXX=$(CXX)\" \\\n+\t\"LD=$(LD)\" \\\n+\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+\t\"NM=$(NM)\" \\\n+\t\"PICFLAG=$(PICFLAG)\" \\\n+\t\"RANLIB=$(RANLIB)\" \\\n+\t\"DESTDIR=$(DESTDIR)\"\n+\n+MAKEOVERRIDES=\n+\n+## ################################################################\n+"}, {"sha": "56eb54c5c6871ab471083a02615eca6eeec9b5b6", "filename": "libsanitizer/interception/Makefile.in", "status": "added", "additions": 535, "deletions": 0, "changes": 535, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Finterception%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Finterception%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2FMakefile.in?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,535 @@\n+# Makefile.in generated by automake 1.11.3 from Makefile.am.\n+# @configure_input@\n+\n+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n+# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software\n+# Foundation, Inc.\n+# This Makefile.in is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+# PARTICULAR PURPOSE.\n+\n+@SET_MAKE@\n+\n+VPATH = @srcdir@\n+pkgdatadir = $(datadir)/@PACKAGE@\n+pkgincludedir = $(includedir)/@PACKAGE@\n+pkglibdir = $(libdir)/@PACKAGE@\n+pkglibexecdir = $(libexecdir)/@PACKAGE@\n+am__cd = CDPATH=\"$${ZSH_VERSION+.}$(PATH_SEPARATOR)\" && cd\n+install_sh_DATA = $(install_sh) -c -m 644\n+install_sh_PROGRAM = $(install_sh) -c\n+install_sh_SCRIPT = $(install_sh) -c\n+INSTALL_HEADER = $(INSTALL_DATA)\n+transform = $(program_transform_name)\n+NORMAL_INSTALL = :\n+PRE_INSTALL = :\n+POST_INSTALL = :\n+NORMAL_UNINSTALL = :\n+PRE_UNINSTALL = :\n+POST_UNINSTALL = :\n+build_triplet = @build@\n+host_triplet = @host@\n+subdir = interception\n+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in\n+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n+am__aclocal_m4_deps = $(top_srcdir)/configure.ac\n+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n+\t$(ACLOCAL_M4)\n+mkinstalldirs = $(install_sh) -d\n+CONFIG_CLEAN_FILES =\n+CONFIG_CLEAN_VPATH_FILES =\n+LTLIBRARIES = $(noinst_LTLIBRARIES)\n+libinterception_la_LIBADD =\n+am__objects_1 = interception_linux.lo interception_mac.lo \\\n+\tinterception_win.lo\n+am_libinterception_la_OBJECTS = $(am__objects_1)\n+libinterception_la_OBJECTS = $(am_libinterception_la_OBJECTS)\n+DEFAULT_INCLUDES = -I.@am__isrc@\n+depcomp = $(SHELL) $(top_srcdir)/depcomp\n+am__depfiles_maybe = depfiles\n+am__mv = mv -f\n+CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n+\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)\n+LTCXXCOMPILE = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n+\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)\n+CXXLD = $(CXX)\n+CXXLINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=link $(CXXLD) $(AM_CXXFLAGS) $(CXXFLAGS) $(AM_LDFLAGS) \\\n+\t$(LDFLAGS) -o $@\n+SOURCES = $(libinterception_la_SOURCES)\n+DIST_SOURCES = $(libinterception_la_SOURCES)\n+ETAGS = etags\n+CTAGS = ctags\n+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)\n+ACLOCAL = @ACLOCAL@\n+AMTAR = @AMTAR@\n+AR = @AR@\n+AUTOCONF = @AUTOCONF@\n+AUTOHEADER = @AUTOHEADER@\n+AUTOMAKE = @AUTOMAKE@\n+AWK = @AWK@\n+CC = @CC@\n+CCAS = @CCAS@\n+CCASDEPMODE = @CCASDEPMODE@\n+CCASFLAGS = @CCASFLAGS@\n+CCDEPMODE = @CCDEPMODE@\n+CFLAGS = @CFLAGS@\n+CPP = @CPP@\n+CPPFLAGS = @CPPFLAGS@\n+CXX = @CXX@\n+CXXCPP = @CXXCPP@\n+CXXDEPMODE = @CXXDEPMODE@\n+CXXFLAGS = @CXXFLAGS@\n+CYGPATH_W = @CYGPATH_W@\n+DEFS = -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS \n+DEPDIR = @DEPDIR@\n+DLLTOOL = @DLLTOOL@\n+DSYMUTIL = @DSYMUTIL@\n+DUMPBIN = @DUMPBIN@\n+ECHO_C = @ECHO_C@\n+ECHO_N = @ECHO_N@\n+ECHO_T = @ECHO_T@\n+EGREP = @EGREP@\n+EXEEXT = @EXEEXT@\n+FGREP = @FGREP@\n+GREP = @GREP@\n+INSTALL = @INSTALL@\n+INSTALL_DATA = @INSTALL_DATA@\n+INSTALL_PROGRAM = @INSTALL_PROGRAM@\n+INSTALL_SCRIPT = @INSTALL_SCRIPT@\n+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@\n+LD = @LD@\n+LDFLAGS = @LDFLAGS@\n+LIBOBJS = @LIBOBJS@\n+LIBS = @LIBS@\n+LIBTOOL = @LIBTOOL@\n+LIPO = @LIPO@\n+LN_S = @LN_S@\n+LTLIBOBJS = @LTLIBOBJS@\n+MAKEINFO = @MAKEINFO@\n+MANIFEST_TOOL = @MANIFEST_TOOL@\n+MKDIR_P = @MKDIR_P@\n+NM = @NM@\n+NMEDIT = @NMEDIT@\n+OBJDUMP = @OBJDUMP@\n+OBJEXT = @OBJEXT@\n+OTOOL = @OTOOL@\n+OTOOL64 = @OTOOL64@\n+PACKAGE = @PACKAGE@\n+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\n+PACKAGE_NAME = @PACKAGE_NAME@\n+PACKAGE_STRING = @PACKAGE_STRING@\n+PACKAGE_TARNAME = @PACKAGE_TARNAME@\n+PACKAGE_URL = @PACKAGE_URL@\n+PACKAGE_VERSION = @PACKAGE_VERSION@\n+PATH_SEPARATOR = @PATH_SEPARATOR@\n+RANLIB = @RANLIB@\n+SED = @SED@\n+SET_MAKE = @SET_MAKE@\n+SHELL = @SHELL@\n+STRIP = @STRIP@\n+VERSION = @VERSION@\n+abs_builddir = @abs_builddir@\n+abs_srcdir = @abs_srcdir@\n+abs_top_builddir = @abs_top_builddir@\n+abs_top_srcdir = @abs_top_srcdir@\n+ac_ct_AR = @ac_ct_AR@\n+ac_ct_CC = @ac_ct_CC@\n+ac_ct_CXX = @ac_ct_CXX@\n+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@\n+am__include = @am__include@\n+am__leading_dot = @am__leading_dot@\n+am__quote = @am__quote@\n+am__tar = @am__tar@\n+am__untar = @am__untar@\n+bindir = @bindir@\n+build = @build@\n+build_alias = @build_alias@\n+build_cpu = @build_cpu@\n+build_os = @build_os@\n+build_vendor = @build_vendor@\n+builddir = @builddir@\n+datadir = @datadir@\n+datarootdir = @datarootdir@\n+docdir = @docdir@\n+dvidir = @dvidir@\n+enable_shared = @enable_shared@\n+enable_static = @enable_static@\n+exec_prefix = @exec_prefix@\n+host = @host@\n+host_alias = @host_alias@\n+host_cpu = @host_cpu@\n+host_os = @host_os@\n+host_vendor = @host_vendor@\n+htmldir = @htmldir@\n+includedir = @includedir@\n+infodir = @infodir@\n+install_sh = @install_sh@\n+libdir = @libdir@\n+libexecdir = @libexecdir@\n+localedir = @localedir@\n+localstatedir = @localstatedir@\n+mandir = @mandir@\n+mkdir_p = @mkdir_p@\n+oldincludedir = @oldincludedir@\n+pdfdir = @pdfdir@\n+prefix = @prefix@\n+program_transform_name = @program_transform_name@\n+psdir = @psdir@\n+sbindir = @sbindir@\n+sharedstatedir = @sharedstatedir@\n+srcdir = @srcdir@\n+sysconfdir = @sysconfdir@\n+target_alias = @target_alias@\n+toolexecdir = @toolexecdir@\n+toolexeclibdir = @toolexeclibdir@\n+top_build_prefix = @top_build_prefix@\n+top_builddir = @top_builddir@\n+top_srcdir = @top_srcdir@\n+AM_CPPFLAGS = -I $(top_srcdir)/include \n+AM_CXXFLAGS = -Wall -W -Wno-unused-parameter -Wwrite-strings -pedantic -Wno-long-long  -fPIC -fno-builtin -fno-exceptions -fomit-frame-pointer -funwind-tables -fvisibility=hidden -Wno-variadic-macros -Wno-c99-extensions \n+ACLOCAL_AMFLAGS = -I m4\n+noinst_LTLIBRARIES = libinterception.la\n+interception_files = \\\n+        interception_linux.cc \\\n+        interception_mac.cc \\\n+        interception_win.cc\n+\n+libinterception_la_SOURCES = $(interception_files) \n+\n+# Work around what appears to be a GNU make bug handling MAKEFLAGS\n+# values defined in terms of make variables, as is the case for CC and\n+# friends when we are called from the top level Makefile.\n+AM_MAKEFLAGS = \\\n+\t\"AR_FLAGS=$(AR_FLAGS)\" \\\n+\t\"CC_FOR_BUILD=$(CC_FOR_BUILD)\" \\\n+\t\"CFLAGS=$(CFLAGS)\" \\\n+\t\"CXXFLAGS=$(CXXFLAGS)\" \\\n+\t\"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)\" \\\n+\t\"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)\" \\\n+\t\"INSTALL=$(INSTALL)\" \\\n+\t\"INSTALL_DATA=$(INSTALL_DATA)\" \\\n+\t\"INSTALL_PROGRAM=$(INSTALL_PROGRAM)\" \\\n+\t\"INSTALL_SCRIPT=$(INSTALL_SCRIPT)\" \\\n+\t\"JC1FLAGS=$(JC1FLAGS)\" \\\n+\t\"LDFLAGS=$(LDFLAGS)\" \\\n+\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+\t\"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\"MAKE=$(MAKE)\" \\\n+\t\"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)\" \\\n+\t\"PICFLAG=$(PICFLAG)\" \\\n+\t\"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)\" \\\n+\t\"SHELL=$(SHELL)\" \\\n+\t\"RUNTESTFLAGS=$(RUNTESTFLAGS)\" \\\n+\t\"exec_prefix=$(exec_prefix)\" \\\n+\t\"infodir=$(infodir)\" \\\n+\t\"libdir=$(libdir)\" \\\n+\t\"prefix=$(prefix)\" \\\n+\t\"includedir=$(includedir)\" \\\n+\t\"AR=$(AR)\" \\\n+\t\"AS=$(AS)\" \\\n+\t\"CC=$(CC)\" \\\n+\t\"CXX=$(CXX)\" \\\n+\t\"LD=$(LD)\" \\\n+\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+\t\"NM=$(NM)\" \\\n+\t\"PICFLAG=$(PICFLAG)\" \\\n+\t\"RANLIB=$(RANLIB)\" \\\n+\t\"DESTDIR=$(DESTDIR)\"\n+\n+MAKEOVERRIDES = \n+all: all-am\n+\n+.SUFFIXES:\n+.SUFFIXES: .cc .lo .o .obj\n+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)\n+\t@for dep in $?; do \\\n+\t  case '$(am__configure_deps)' in \\\n+\t    *$$dep*) \\\n+\t      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \\\n+\t        && { if test -f $@; then exit 0; else break; fi; }; \\\n+\t      exit 1;; \\\n+\t  esac; \\\n+\tdone; \\\n+\techo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign interception/Makefile'; \\\n+\t$(am__cd) $(top_srcdir) && \\\n+\t  $(AUTOMAKE) --foreign interception/Makefile\n+.PRECIOUS: Makefile\n+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n+\t@case '$?' in \\\n+\t  *config.status*) \\\n+\t    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \\\n+\t  *) \\\n+\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \\\n+\t    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \\\n+\tesac;\n+\n+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)\n+\tcd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh\n+\n+$(top_srcdir)/configure:  $(am__configure_deps)\n+\tcd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh\n+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)\n+\tcd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh\n+$(am__aclocal_m4_deps):\n+\n+clean-noinstLTLIBRARIES:\n+\t-test -z \"$(noinst_LTLIBRARIES)\" || rm -f $(noinst_LTLIBRARIES)\n+\t@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \\\n+\t  dir=\"`echo $$p | sed -e 's|/[^/]*$$||'`\"; \\\n+\t  test \"$$dir\" != \"$$p\" || dir=.; \\\n+\t  echo \"rm -f \\\"$${dir}/so_locations\\\"\"; \\\n+\t  rm -f \"$${dir}/so_locations\"; \\\n+\tdone\n+libinterception.la: $(libinterception_la_OBJECTS) $(libinterception_la_DEPENDENCIES) $(EXTRA_libinterception_la_DEPENDENCIES) \n+\t$(CXXLINK)  $(libinterception_la_OBJECTS) $(libinterception_la_LIBADD) $(LIBS)\n+\n+mostlyclean-compile:\n+\t-rm -f *.$(OBJEXT)\n+\n+distclean-compile:\n+\t-rm -f *.tab.c\n+\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/interception_linux.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/interception_mac.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/interception_win.Plo@am__quote@\n+\n+.cc.o:\n+@am__fastdepCXX_TRUE@\t$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(CXXCOMPILE) -c -o $@ $<\n+\n+.cc.obj:\n+@am__fastdepCXX_TRUE@\t$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`\n+\n+.cc.lo:\n+@am__fastdepCXX_TRUE@\t$(LTCXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='$<' object='$@' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(LTCXXCOMPILE) -c -o $@ $<\n+\n+mostlyclean-libtool:\n+\t-rm -f *.lo\n+\n+clean-libtool:\n+\t-rm -rf .libs _libs\n+\n+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)\n+\tlist='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\tmkid -fID $$unique\n+tags: TAGS\n+\n+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \\\n+\t\t$(TAGS_FILES) $(LISP)\n+\tset x; \\\n+\there=`pwd`; \\\n+\tlist='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\tshift; \\\n+\tif test -z \"$(ETAGS_ARGS)$$*$$unique\"; then :; else \\\n+\t  test -n \"$$unique\" || unique=$$empty_fix; \\\n+\t  if test $$# -gt 0; then \\\n+\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n+\t      \"$$@\" $$unique; \\\n+\t  else \\\n+\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n+\t      $$unique; \\\n+\t  fi; \\\n+\tfi\n+ctags: CTAGS\n+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \\\n+\t\t$(TAGS_FILES) $(LISP)\n+\tlist='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\ttest -z \"$(CTAGS_ARGS)$$unique\" \\\n+\t  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \\\n+\t     $$unique\n+\n+GTAGS:\n+\there=`$(am__cd) $(top_builddir) && pwd` \\\n+\t  && $(am__cd) $(top_srcdir) \\\n+\t  && gtags -i $(GTAGS_ARGS) \"$$here\"\n+\n+distclean-tags:\n+\t-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags\n+\n+distdir: $(DISTFILES)\n+\t@srcdirstrip=`echo \"$(srcdir)\" | sed 's/[].[^$$\\\\*]/\\\\\\\\&/g'`; \\\n+\ttopsrcdirstrip=`echo \"$(top_srcdir)\" | sed 's/[].[^$$\\\\*]/\\\\\\\\&/g'`; \\\n+\tlist='$(DISTFILES)'; \\\n+\t  dist_files=`for file in $$list; do echo $$file; done | \\\n+\t  sed -e \"s|^$$srcdirstrip/||;t\" \\\n+\t      -e \"s|^$$topsrcdirstrip/|$(top_builddir)/|;t\"`; \\\n+\tcase $$dist_files in \\\n+\t  */*) $(MKDIR_P) `echo \"$$dist_files\" | \\\n+\t\t\t   sed '/\\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \\\n+\t\t\t   sort -u` ;; \\\n+\tesac; \\\n+\tfor file in $$dist_files; do \\\n+\t  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \\\n+\t  if test -d $$d/$$file; then \\\n+\t    dir=`echo \"/$$file\" | sed -e 's,/[^/]*$$,,'`; \\\n+\t    if test -d \"$(distdir)/$$file\"; then \\\n+\t      find \"$(distdir)/$$file\" -type d ! -perm -700 -exec chmod u+rwx {} \\;; \\\n+\t    fi; \\\n+\t    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \\\n+\t      cp -fpR $(srcdir)/$$file \"$(distdir)$$dir\" || exit 1; \\\n+\t      find \"$(distdir)/$$file\" -type d ! -perm -700 -exec chmod u+rwx {} \\;; \\\n+\t    fi; \\\n+\t    cp -fpR $$d/$$file \"$(distdir)$$dir\" || exit 1; \\\n+\t  else \\\n+\t    test -f \"$(distdir)/$$file\" \\\n+\t    || cp -p $$d/$$file \"$(distdir)/$$file\" \\\n+\t    || exit 1; \\\n+\t  fi; \\\n+\tdone\n+check-am: all-am\n+check: check-am\n+all-am: Makefile $(LTLIBRARIES)\n+installdirs:\n+install: install-am\n+install-exec: install-exec-am\n+install-data: install-data-am\n+uninstall: uninstall-am\n+\n+install-am: all-am\n+\t@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am\n+\n+installcheck: installcheck-am\n+install-strip:\n+\tif test -z '$(STRIP)'; then \\\n+\t  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n+\t    install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n+\t      install; \\\n+\telse \\\n+\t  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n+\t    install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n+\t    \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\" install; \\\n+\tfi\n+mostlyclean-generic:\n+\n+clean-generic:\n+\n+distclean-generic:\n+\t-test -z \"$(CONFIG_CLEAN_FILES)\" || rm -f $(CONFIG_CLEAN_FILES)\n+\t-test . = \"$(srcdir)\" || test -z \"$(CONFIG_CLEAN_VPATH_FILES)\" || rm -f $(CONFIG_CLEAN_VPATH_FILES)\n+\n+maintainer-clean-generic:\n+\t@echo \"This command is intended for maintainers to use\"\n+\t@echo \"it deletes files that may require special tools to rebuild.\"\n+clean: clean-am\n+\n+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \\\n+\tmostlyclean-am\n+\n+distclean: distclean-am\n+\t-rm -rf ./$(DEPDIR)\n+\t-rm -f Makefile\n+distclean-am: clean-am distclean-compile distclean-generic \\\n+\tdistclean-tags\n+\n+dvi: dvi-am\n+\n+dvi-am:\n+\n+html: html-am\n+\n+html-am:\n+\n+info: info-am\n+\n+info-am:\n+\n+install-data-am:\n+\n+install-dvi: install-dvi-am\n+\n+install-dvi-am:\n+\n+install-exec-am:\n+\n+install-html: install-html-am\n+\n+install-html-am:\n+\n+install-info: install-info-am\n+\n+install-info-am:\n+\n+install-man:\n+\n+install-pdf: install-pdf-am\n+\n+install-pdf-am:\n+\n+install-ps: install-ps-am\n+\n+install-ps-am:\n+\n+installcheck-am:\n+\n+maintainer-clean: maintainer-clean-am\n+\t-rm -rf ./$(DEPDIR)\n+\t-rm -f Makefile\n+maintainer-clean-am: distclean-am maintainer-clean-generic\n+\n+mostlyclean: mostlyclean-am\n+\n+mostlyclean-am: mostlyclean-compile mostlyclean-generic \\\n+\tmostlyclean-libtool\n+\n+pdf: pdf-am\n+\n+pdf-am:\n+\n+ps: ps-am\n+\n+ps-am:\n+\n+uninstall-am:\n+\n+.MAKE: install-am install-strip\n+\n+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \\\n+\tclean-libtool clean-noinstLTLIBRARIES ctags distclean \\\n+\tdistclean-compile distclean-generic distclean-libtool \\\n+\tdistclean-tags distdir dvi dvi-am html html-am info info-am \\\n+\tinstall install-am install-data install-data-am install-dvi \\\n+\tinstall-dvi-am install-exec install-exec-am install-html \\\n+\tinstall-html-am install-info install-info-am install-man \\\n+\tinstall-pdf install-pdf-am install-ps install-ps-am \\\n+\tinstall-strip installcheck installcheck-am installdirs \\\n+\tmaintainer-clean maintainer-clean-generic mostlyclean \\\n+\tmostlyclean-compile mostlyclean-generic mostlyclean-libtool \\\n+\tpdf pdf-am ps ps-am tags uninstall uninstall-am\n+\n+\n+# Tell versions [3.59,3.63) of GNU make to not export all variables.\n+# Otherwise a system limit (for SysV at least) may be exceeded.\n+.NOEXPORT:"}, {"sha": "8094fe5d34512ed35f81b4812409716ddf686597", "filename": "libsanitizer/interception/interception.h", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Finterception%2Finterception.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Finterception%2Finterception.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception.h?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,195 @@\n+//===-- interception.h ------------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// Machinery for providing replacements/wrappers for system functions.\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef INTERCEPTION_H\n+#define INTERCEPTION_H\n+\n+#if !defined(__linux__) && !defined(__APPLE__) && !defined(_WIN32)\n+# error \"Interception doesn't work on this operating system.\"\n+#endif\n+\n+// How to use this library:\n+//      1) Include this header to define your own interceptors\n+//         (see details below).\n+//      2) Build all *.cc files and link against them.\n+// On Mac you will also need to:\n+//      3) Provide your own implementation for the following functions:\n+//           mach_error_t __interception::allocate_island(void **ptr,\n+//                                                      size_t size,\n+//                                                      void *hint);\n+//           mach_error_t __interception::deallocate_island(void *ptr);\n+//         See \"interception_mac.h\" for more details.\n+\n+// How to add an interceptor:\n+// Suppose you need to wrap/replace system function (generally, from libc):\n+//      int foo(const char *bar, double baz);\n+// You'll need to:\n+//      1) define INTERCEPTOR(int, foo, const char *bar, double baz) { ... } in\n+//         your source file.\n+//      2) Call \"INTERCEPT_FUNCTION(foo)\" prior to the first call of \"foo\".\n+//         INTERCEPT_FUNCTION(foo) evaluates to \"true\" iff the function was\n+//         intercepted successfully.\n+// You can access original function by calling REAL(foo)(bar, baz).\n+// By default, REAL(foo) will be visible only inside your interceptor, and if\n+// you want to use it in other parts of RTL, you'll need to:\n+//      3a) add DECLARE_REAL(int, foo, const char*, double) to a\n+//          header file.\n+// However, if the call \"INTERCEPT_FUNCTION(foo)\" and definition for\n+// INTERCEPTOR(..., foo, ...) are in different files, you'll instead need to:\n+//      3b) add DECLARE_REAL_AND_INTERCEPTOR(int, foo, const char*, double)\n+//          to a header file.\n+\n+// Notes: 1. Things may not work properly if macro INTERCEPT(...) {...} or\n+//           DECLARE_REAL(...) are located inside namespaces.\n+//        2. On Mac you can also use: \"OVERRIDE_FUNCTION(foo, zoo);\" to\n+//           effectively redirect calls from \"foo\" to \"zoo\". In this case\n+//           you aren't required to implement\n+//           INTERCEPTOR(int, foo, const char *bar, double baz) {...}\n+//           but instead you'll have to add\n+//           DEFINE_REAL(int, foo, const char *bar, double baz) in your\n+//           source file (to define a pointer to overriden function).\n+\n+// How it works:\n+// To replace system functions on Linux we just need to declare functions\n+// with same names in our library and then obtain the real function pointers\n+// using dlsym().\n+// There is one complication. A user may also intercept some of the functions\n+// we intercept. To resolve this we declare our interceptors with __interceptor_\n+// prefix, and then make actual interceptors weak aliases to __interceptor_\n+// functions.\n+// This is not so on Mac OS, where the two-level namespace makes\n+// our replacement functions invisible to other libraries. This may be overcomed\n+// using the DYLD_FORCE_FLAT_NAMESPACE, but some errors loading the shared\n+// libraries in Chromium were noticed when doing so. Instead we use\n+// mach_override, a handy framework for patching functions at runtime.\n+// To avoid possible name clashes, our replacement functions have\n+// the \"wrap_\" prefix on Mac.\n+// An alternative to function patching is to create a dylib containing a\n+// __DATA,__interpose section that associates library functions with their\n+// wrappers. When this dylib is preloaded before an executable using\n+// DYLD_INSERT_LIBRARIES, it routes all the calls to interposed functions done\n+// through stubs to the wrapper functions. Such a library is built with\n+// -DMAC_INTERPOSE_FUNCTIONS=1.\n+\n+#if !defined(MAC_INTERPOSE_FUNCTIONS) || !defined(__APPLE__)\n+# define MAC_INTERPOSE_FUNCTIONS 0\n+#endif\n+\n+#if defined(__APPLE__)\n+# define WRAP(x) wrap_##x\n+# define WRAPPER_NAME(x) \"wrap_\"#x\n+# define INTERCEPTOR_ATTRIBUTE\n+# define DECLARE_WRAPPER(ret_type, func, ...)\n+#elif defined(_WIN32)\n+# if defined(_DLL)  // DLL CRT\n+#  define WRAP(x) x\n+#  define WRAPPER_NAME(x) #x\n+#  define INTERCEPTOR_ATTRIBUTE\n+# else  // Static CRT\n+#  define WRAP(x) wrap_##x\n+#  define WRAPPER_NAME(x) \"wrap_\"#x\n+#  define INTERCEPTOR_ATTRIBUTE\n+# endif\n+# define DECLARE_WRAPPER(ret_type, func, ...)\n+#else\n+# define WRAP(x) __interceptor_ ## x\n+# define WRAPPER_NAME(x) \"__interceptor_\" #x\n+# define INTERCEPTOR_ATTRIBUTE __attribute__((visibility(\"default\")))\n+# define DECLARE_WRAPPER(ret_type, func, ...) \\\n+    extern \"C\" ret_type func(__VA_ARGS__) \\\n+    __attribute__((weak, alias(\"__interceptor_\" #func), visibility(\"default\")));\n+#endif\n+\n+#if !MAC_INTERPOSE_FUNCTIONS\n+# define PTR_TO_REAL(x) real_##x\n+# define REAL(x) __interception::PTR_TO_REAL(x)\n+# define FUNC_TYPE(x) x##_f\n+\n+# define DECLARE_REAL(ret_type, func, ...) \\\n+    typedef ret_type (*FUNC_TYPE(func))(__VA_ARGS__); \\\n+    namespace __interception { \\\n+      extern FUNC_TYPE(func) PTR_TO_REAL(func); \\\n+    }\n+#else  // MAC_INTERPOSE_FUNCTIONS\n+# define REAL(x) x\n+# define DECLARE_REAL(ret_type, func, ...) \\\n+    extern \"C\" ret_type func(__VA_ARGS__);\n+#endif  // MAC_INTERPOSE_FUNCTIONS\n+\n+#define DECLARE_REAL_AND_INTERCEPTOR(ret_type, func, ...) \\\n+  DECLARE_REAL(ret_type, func, __VA_ARGS__) \\\n+  extern \"C\" ret_type WRAP(func)(__VA_ARGS__);\n+\n+// Generally, you don't need to use DEFINE_REAL by itself, as INTERCEPTOR\n+// macros does its job. In exceptional cases you may need to call REAL(foo)\n+// without defining INTERCEPTOR(..., foo, ...). For example, if you override\n+// foo with an interceptor for other function.\n+#if !MAC_INTERPOSE_FUNCTIONS\n+# define DEFINE_REAL(ret_type, func, ...) \\\n+    typedef ret_type (*FUNC_TYPE(func))(__VA_ARGS__); \\\n+    namespace __interception { \\\n+      FUNC_TYPE(func) PTR_TO_REAL(func); \\\n+    }\n+#else\n+# define DEFINE_REAL(ret_type, func, ...)\n+#endif\n+\n+#define INTERCEPTOR(ret_type, func, ...) \\\n+  DEFINE_REAL(ret_type, func, __VA_ARGS__) \\\n+  DECLARE_WRAPPER(ret_type, func, __VA_ARGS__) \\\n+  extern \"C\" \\\n+  INTERCEPTOR_ATTRIBUTE \\\n+  ret_type WRAP(func)(__VA_ARGS__)\n+\n+#if defined(_WIN32)\n+# define INTERCEPTOR_WINAPI(ret_type, func, ...) \\\n+    typedef ret_type (__stdcall *FUNC_TYPE(func))(__VA_ARGS__); \\\n+    namespace __interception { \\\n+      FUNC_TYPE(func) PTR_TO_REAL(func); \\\n+    } \\\n+    DECLARE_WRAPPER(ret_type, func, __VA_ARGS__) \\\n+    extern \"C\" \\\n+    INTERCEPTOR_ATTRIBUTE \\\n+    ret_type __stdcall WRAP(func)(__VA_ARGS__)\n+#endif\n+\n+// ISO C++ forbids casting between pointer-to-function and pointer-to-object,\n+// so we use casting via an integral type __interception::uptr,\n+// assuming that system is POSIX-compliant. Using other hacks seem\n+// challenging, as we don't even pass function type to\n+// INTERCEPT_FUNCTION macro, only its name.\n+namespace __interception {\n+#if defined(_WIN64)\n+typedef unsigned long long uptr;  // NOLINT\n+#else\n+typedef unsigned long uptr;  // NOLINT\n+#endif  // _WIN64\n+}  // namespace __interception\n+\n+#define INCLUDED_FROM_INTERCEPTION_LIB\n+\n+#if defined(__linux__)\n+# include \"interception_linux.h\"\n+# define INTERCEPT_FUNCTION(func) INTERCEPT_FUNCTION_LINUX(func)\n+#elif defined(__APPLE__)\n+# include \"interception_mac.h\"\n+# define OVERRIDE_FUNCTION(old_func, new_func) \\\n+    OVERRIDE_FUNCTION_MAC(old_func, new_func)\n+# define INTERCEPT_FUNCTION(func) INTERCEPT_FUNCTION_MAC(func)\n+#else  // defined(_WIN32)\n+# include \"interception_win.h\"\n+# define INTERCEPT_FUNCTION(func) INTERCEPT_FUNCTION_WIN(func)\n+#endif\n+\n+#undef INCLUDED_FROM_INTERCEPTION_LIB\n+\n+#endif  // INTERCEPTION_H"}, {"sha": "4929a7fce49a9f145fab171cbe71365ad9e51b61", "filename": "libsanitizer/interception/interception_linux.cc", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Finterception%2Finterception_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Finterception%2Finterception_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_linux.cc?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,28 @@\n+//===-- interception_linux.cc -----------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// Linux-specific interception methods.\n+//===----------------------------------------------------------------------===//\n+\n+#ifdef __linux__\n+#include \"interception.h\"\n+\n+#include <stddef.h>  // for NULL\n+#include <dlfcn.h>   // for dlsym\n+\n+namespace __interception {\n+bool GetRealFunctionAddress(const char *func_name, uptr *func_addr,\n+    uptr real, uptr wrapper) {\n+  *func_addr = (uptr)dlsym(RTLD_NEXT, func_name);\n+  return real == wrapper;\n+}\n+}  // namespace __interception\n+\n+\n+#endif  // __linux__"}, {"sha": "7940ef257c87eb28040371dd264e245917667923", "filename": "libsanitizer/interception/interception_linux.h", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Finterception%2Finterception_linux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Finterception%2Finterception_linux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_linux.h?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,35 @@\n+//===-- interception_linux.h ------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// Linux-specific interception methods.\n+//===----------------------------------------------------------------------===//\n+\n+#ifdef __linux__\n+\n+#if !defined(INCLUDED_FROM_INTERCEPTION_LIB)\n+# error \"interception_linux.h should be included from interception library only\"\n+#endif\n+\n+#ifndef INTERCEPTION_LINUX_H\n+#define INTERCEPTION_LINUX_H\n+\n+namespace __interception {\n+// returns true if a function with the given name was found.\n+bool GetRealFunctionAddress(const char *func_name, uptr *func_addr,\n+    uptr real, uptr wrapper);\n+}  // namespace __interception\n+\n+#define INTERCEPT_FUNCTION_LINUX(func) \\\n+    ::__interception::GetRealFunctionAddress( \\\n+          #func, (::__interception::uptr*)&REAL(func), \\\n+          (::__interception::uptr)&(func), \\\n+          (::__interception::uptr)&WRAP(func))\n+\n+#endif  // INTERCEPTION_LINUX_H\n+#endif  // __linux__"}, {"sha": "c9b7dd32d0f6b592e961430e38e72173a2935c0a", "filename": "libsanitizer/interception/interception_mac.cc", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Finterception%2Finterception_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Finterception%2Finterception_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_mac.cc?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,29 @@\n+//===-- interception_mac.cc -------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// Mac-specific interception methods.\n+//===----------------------------------------------------------------------===//\n+\n+#ifdef __APPLE__\n+\n+#include \"interception.h\"\n+#include \"mach_override/mach_override.h\"\n+\n+namespace __interception {\n+bool OverrideFunction(uptr old_func, uptr new_func, uptr *orig_old_func) {\n+  *orig_old_func = 0;\n+  int res = __asan_mach_override_ptr_custom((void*)old_func, (void*)new_func,\n+                                            (void**)orig_old_func,\n+                                            __interception_allocate_island,\n+                                            __interception_deallocate_island);\n+  return (res == 0) && (*orig_old_func != 0);\n+}\n+}  // namespace __interception\n+\n+#endif  // __APPLE__"}, {"sha": "244b457d738c77bee26af9d6306eeede51f44a04", "filename": "libsanitizer/interception/interception_mac.h", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Finterception%2Finterception_mac.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Finterception%2Finterception_mac.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_mac.h?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,47 @@\n+//===-- interception_mac.h --------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// Mac-specific interception methods.\n+//===----------------------------------------------------------------------===//\n+\n+#ifdef __APPLE__\n+\n+#if !defined(INCLUDED_FROM_INTERCEPTION_LIB)\n+# error \"interception_mac.h should be included from interception.h only\"\n+#endif\n+\n+#ifndef INTERCEPTION_MAC_H\n+#define INTERCEPTION_MAC_H\n+\n+#include <mach/mach_error.h>\n+#include <stddef.h>\n+\n+// Allocate memory for the escape island. This cannot be moved to\n+// mach_override, because each user of interceptors may specify its\n+// own memory range for escape islands.\n+extern \"C\" {\n+mach_error_t __interception_allocate_island(void **ptr, size_t unused_size,\n+                                            void *unused_hint);\n+mach_error_t __interception_deallocate_island(void *ptr);\n+}  // extern \"C\"\n+\n+namespace __interception {\n+// returns true if the old function existed.\n+bool OverrideFunction(uptr old_func, uptr new_func, uptr *orig_old_func);\n+}  // namespace __interception\n+\n+# define OVERRIDE_FUNCTION_MAC(old_func, new_func) \\\n+    ::__interception::OverrideFunction( \\\n+          (::__interception::uptr)old_func, \\\n+          (::__interception::uptr)new_func, \\\n+          (::__interception::uptr*)((::__interception::uptr)&REAL(old_func)))\n+# define INTERCEPT_FUNCTION_MAC(func) OVERRIDE_FUNCTION_MAC(func, WRAP(func))\n+\n+#endif  // INTERCEPTION_MAC_H\n+#endif  // __APPLE__"}, {"sha": "443bdce1859abe6ab65b8154e800fde00ffed8db", "filename": "libsanitizer/interception/interception_win.cc", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Finterception%2Finterception_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Finterception%2Finterception_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_win.cc?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,149 @@\n+//===-- interception_linux.cc -----------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// Windows-specific interception methods.\n+//===----------------------------------------------------------------------===//\n+\n+#ifdef _WIN32\n+\n+#include \"interception.h\"\n+#include <windows.h>\n+\n+namespace __interception {\n+\n+bool GetRealFunctionAddress(const char *func_name, uptr *func_addr) {\n+  const char *DLLS[] = {\n+    \"msvcr80.dll\",\n+    \"msvcr90.dll\",\n+    \"kernel32.dll\",\n+    NULL\n+  };\n+  *func_addr = 0;\n+  for (size_t i = 0; *func_addr == 0 && DLLS[i]; ++i) {\n+    *func_addr = (uptr)GetProcAddress(GetModuleHandleA(DLLS[i]), func_name);\n+  }\n+  return (*func_addr != 0);\n+}\n+\n+// FIXME: internal_str* and internal_mem* functions should be moved from the\n+// ASan sources into interception/.\n+\n+static void _memset(void *p, int value, size_t sz) {\n+  for (size_t i = 0; i < sz; ++i)\n+    ((char*)p)[i] = (char)value;\n+}\n+\n+static void _memcpy(void *dst, void *src, size_t sz) {\n+  char *dst_c = (char*)dst,\n+       *src_c = (char*)src;\n+  for (size_t i = 0; i < sz; ++i)\n+    dst_c[i] = src_c[i];\n+}\n+\n+static void WriteJumpInstruction(char *jmp_from, char *to) {\n+  // jmp XXYYZZWW = E9 WW ZZ YY XX, where XXYYZZWW is an offset fromt jmp_from\n+  // to the next instruction to the destination.\n+  ptrdiff_t offset = to - jmp_from - 5;\n+  *jmp_from = '\\xE9';\n+  *(ptrdiff_t*)(jmp_from + 1) = offset;\n+}\n+\n+bool OverrideFunction(uptr old_func, uptr new_func, uptr *orig_old_func) {\n+#ifdef _WIN64\n+# error OverrideFunction was not tested on x64\n+#endif\n+  // Basic idea:\n+  // We write 5 bytes (jmp-to-new_func) at the beginning of the 'old_func'\n+  // to override it. We want to be able to execute the original 'old_func' from\n+  // the wrapper, so we need to keep the leading 5+ bytes ('head') of the\n+  // original instructions somewhere with a \"jmp old_func+head\".\n+  // We call these 'head'+5 bytes of instructions a \"trampoline\".\n+\n+  // Trampolines are allocated from a common pool.\n+  const int POOL_SIZE = 1024;\n+  static char *pool = NULL;\n+  static size_t pool_used = 0;\n+  if (pool == NULL) {\n+    pool = (char*)VirtualAlloc(NULL, POOL_SIZE,\n+                               MEM_RESERVE | MEM_COMMIT,\n+                               PAGE_EXECUTE_READWRITE);\n+    // FIXME: set PAGE_EXECUTE_READ access after setting all interceptors?\n+    if (pool == NULL)\n+      return false;\n+    _memset(pool, 0xCC /* int 3 */, POOL_SIZE);\n+  }\n+\n+  char* old_bytes = (char*)old_func;\n+  char* trampoline = pool + pool_used;\n+\n+  // Find out the number of bytes of the instructions we need to copy to the\n+  // island and store it in 'head'.\n+  size_t head = 0;\n+  while (head < 5) {\n+    switch (old_bytes[head]) {\n+      case '\\x55':  // push ebp\n+      case '\\x56':  // push esi\n+      case '\\x57':  // push edi\n+        head++;\n+        continue;\n+    }\n+    switch (*(unsigned short*)(old_bytes + head)) {  // NOLINT\n+      case 0xFF8B:  // 8B FF = mov edi, edi\n+      case 0xEC8B:  // 8B EC = mov ebp, esp\n+      case 0xC033:  // 33 C0 = xor eax, eax\n+        head += 2;\n+        continue;\n+      case 0xEC83:  // 83 EC XX = sub esp, XX\n+        head += 3;\n+        continue;\n+      case 0xC1F7:  // F7 C1 XX YY ZZ WW = test ecx, WWZZYYXX\n+        head += 6;\n+        continue;\n+    }\n+    switch (0x00FFFFFF & *(unsigned int*)(old_bytes + head)) {\n+      case 0x24448A:  // 8A 44 24 XX = mov eal, dword ptr [esp+XXh]\n+      case 0x244C8B:  // 8B 4C 24 XX = mov ecx, dword ptr [esp+XXh]\n+      case 0x24548B:  // 8B 54 24 XX = mov edx, dword ptr [esp+XXh]\n+      case 0x247C8B:  // 8B 7C 24 XX = mov edi, dword ptr [esp+XXh]\n+        head += 4;\n+        continue;\n+    }\n+\n+    // Unknown instruction!\n+    return false;\n+  }\n+\n+  if (pool_used + head + 5 > POOL_SIZE)\n+    return false;\n+\n+  // Now put the \"jump to trampoline\" instruction into the original code.\n+  DWORD old_prot, unused_prot;\n+  if (!VirtualProtect((void*)old_func, head, PAGE_EXECUTE_READWRITE,\n+                      &old_prot))\n+    return false;\n+\n+  // Put the needed instructions into the trampoline bytes.\n+  _memcpy(trampoline, old_bytes, head);\n+  WriteJumpInstruction(trampoline + head, old_bytes + head);\n+  *orig_old_func = (uptr)trampoline;\n+  pool_used += head + 5;\n+\n+  // Intercept the 'old_func'.\n+  WriteJumpInstruction(old_bytes, (char*)new_func);\n+  _memset(old_bytes + 5, 0xCC /* int 3 */, head - 5);\n+\n+  if (!VirtualProtect((void*)old_func, head, old_prot, &unused_prot))\n+    return false;  // not clear if this failure bothers us.\n+\n+  return true;\n+}\n+\n+}  // namespace __interception\n+\n+#endif  // _WIN32"}, {"sha": "ebac168d85aa17cc5d6f8aa1942720d4f6624f59", "filename": "libsanitizer/interception/interception_win.h", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Finterception%2Finterception_win.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Finterception%2Finterception_win.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_win.h?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,43 @@\n+//===-- interception_linux.h ------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// Windows-specific interception methods.\n+//===----------------------------------------------------------------------===//\n+\n+#ifdef _WIN32\n+\n+#if !defined(INCLUDED_FROM_INTERCEPTION_LIB)\n+# error \"interception_win.h should be included from interception library only\"\n+#endif\n+\n+#ifndef INTERCEPTION_WIN_H\n+#define INTERCEPTION_WIN_H\n+\n+namespace __interception {\n+// returns true if a function with the given name was found.\n+bool GetRealFunctionAddress(const char *func_name, uptr *func_addr);\n+\n+// returns true if the old function existed, false on failure.\n+bool OverrideFunction(uptr old_func, uptr new_func, uptr *orig_old_func);\n+}  // namespace __interception\n+\n+#if defined(_DLL)\n+# define INTERCEPT_FUNCTION_WIN(func) \\\n+    ::__interception::GetRealFunctionAddress( \\\n+        #func, (::__interception::uptr*)&REAL(func))\n+#else\n+# define INTERCEPT_FUNCTION_WIN(func) \\\n+    ::__interception::OverrideFunction( \\\n+        (::__interception::uptr)func, \\\n+        (::__interception::uptr)WRAP(func), \\\n+        (::__interception::uptr*)&REAL(func))\n+#endif\n+\n+#endif  // INTERCEPTION_WIN_H\n+#endif  // _WIN32"}, {"sha": "204fdd2d8e5fe21a5a9f9e23d6a6cf17d353362a", "filename": "libsanitizer/libtool-version", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Flibtool-version", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Flibtool-version", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flibtool-version?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,6 @@\n+# This file is used to maintain libtool version info for libmudflap.  See\n+# the libtool manual to understand the meaning of the fields.  This is\n+# a separate file so that version updates don't involve re-running\n+# automake.\n+# CURRENT:REVISION:AGE\n+0:0:0"}, {"sha": "c2852d856135458112c39b5f156145980860253a", "filename": "libsanitizer/ltmain.sh", "status": "added", "additions": 9661, "deletions": 0, "changes": 9661, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fltmain.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fltmain.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fltmain.sh?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932"}, {"sha": "28055d2ae6f2a2c584afcd769d7881e11f62ecd9", "filename": "libsanitizer/missing", "status": "added", "additions": 376, "deletions": 0, "changes": 376, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fmissing", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fmissing", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fmissing?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,376 @@\n+#! /bin/sh\n+# Common stub for a few missing GNU programs while installing.\n+\n+scriptversion=2009-04-28.21; # UTC\n+\n+# Copyright (C) 1996, 1997, 1999, 2000, 2002, 2003, 2004, 2005, 2006,\n+# 2008, 2009 Free Software Foundation, Inc.\n+# Originally by Fran,cois Pinard <pinard@iro.umontreal.ca>, 1996.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2, or (at your option)\n+# any later version.\n+\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+# As a special exception to the GNU General Public License, if you\n+# distribute this file as part of a program that contains a\n+# configuration script generated by Autoconf, you may include it under\n+# the same distribution terms that you use for the rest of that program.\n+\n+if test $# -eq 0; then\n+  echo 1>&2 \"Try \\`$0 --help' for more information\"\n+  exit 1\n+fi\n+\n+run=:\n+sed_output='s/.* --output[ =]\\([^ ]*\\).*/\\1/p'\n+sed_minuso='s/.* -o \\([^ ]*\\).*/\\1/p'\n+\n+# In the cases where this matters, `missing' is being run in the\n+# srcdir already.\n+if test -f configure.ac; then\n+  configure_ac=configure.ac\n+else\n+  configure_ac=configure.in\n+fi\n+\n+msg=\"missing on your system\"\n+\n+case $1 in\n+--run)\n+  # Try to run requested program, and just exit if it succeeds.\n+  run=\n+  shift\n+  \"$@\" && exit 0\n+  # Exit code 63 means version mismatch.  This often happens\n+  # when the user try to use an ancient version of a tool on\n+  # a file that requires a minimum version.  In this case we\n+  # we should proceed has if the program had been absent, or\n+  # if --run hadn't been passed.\n+  if test $? = 63; then\n+    run=:\n+    msg=\"probably too old\"\n+  fi\n+  ;;\n+\n+  -h|--h|--he|--hel|--help)\n+    echo \"\\\n+$0 [OPTION]... PROGRAM [ARGUMENT]...\n+\n+Handle \\`PROGRAM [ARGUMENT]...' for when PROGRAM is missing, or return an\n+error status if there is no known handling for PROGRAM.\n+\n+Options:\n+  -h, --help      display this help and exit\n+  -v, --version   output version information and exit\n+  --run           try to run the given command, and emulate it if it fails\n+\n+Supported PROGRAM values:\n+  aclocal      touch file \\`aclocal.m4'\n+  autoconf     touch file \\`configure'\n+  autoheader   touch file \\`config.h.in'\n+  autom4te     touch the output file, or create a stub one\n+  automake     touch all \\`Makefile.in' files\n+  bison        create \\`y.tab.[ch]', if possible, from existing .[ch]\n+  flex         create \\`lex.yy.c', if possible, from existing .c\n+  help2man     touch the output file\n+  lex          create \\`lex.yy.c', if possible, from existing .c\n+  makeinfo     touch the output file\n+  tar          try tar, gnutar, gtar, then tar without non-portable flags\n+  yacc         create \\`y.tab.[ch]', if possible, from existing .[ch]\n+\n+Version suffixes to PROGRAM as well as the prefixes \\`gnu-', \\`gnu', and\n+\\`g' are ignored when checking the name.\n+\n+Send bug reports to <bug-automake@gnu.org>.\"\n+    exit $?\n+    ;;\n+\n+  -v|--v|--ve|--ver|--vers|--versi|--versio|--version)\n+    echo \"missing $scriptversion (GNU Automake)\"\n+    exit $?\n+    ;;\n+\n+  -*)\n+    echo 1>&2 \"$0: Unknown \\`$1' option\"\n+    echo 1>&2 \"Try \\`$0 --help' for more information\"\n+    exit 1\n+    ;;\n+\n+esac\n+\n+# normalize program name to check for.\n+program=`echo \"$1\" | sed '\n+  s/^gnu-//; t\n+  s/^gnu//; t\n+  s/^g//; t'`\n+\n+# Now exit if we have it, but it failed.  Also exit now if we\n+# don't have it and --version was passed (most likely to detect\n+# the program).  This is about non-GNU programs, so use $1 not\n+# $program.\n+case $1 in\n+  lex*|yacc*)\n+    # Not GNU programs, they don't have --version.\n+    ;;\n+\n+  tar*)\n+    if test -n \"$run\"; then\n+       echo 1>&2 \"ERROR: \\`tar' requires --run\"\n+       exit 1\n+    elif test \"x$2\" = \"x--version\" || test \"x$2\" = \"x--help\"; then\n+       exit 1\n+    fi\n+    ;;\n+\n+  *)\n+    if test -z \"$run\" && ($1 --version) > /dev/null 2>&1; then\n+       # We have it, but it failed.\n+       exit 1\n+    elif test \"x$2\" = \"x--version\" || test \"x$2\" = \"x--help\"; then\n+       # Could not run --version or --help.  This is probably someone\n+       # running `$TOOL --version' or `$TOOL --help' to check whether\n+       # $TOOL exists and not knowing $TOOL uses missing.\n+       exit 1\n+    fi\n+    ;;\n+esac\n+\n+# If it does not exist, or fails to run (possibly an outdated version),\n+# try to emulate it.\n+case $program in\n+  aclocal*)\n+    echo 1>&2 \"\\\n+WARNING: \\`$1' is $msg.  You should only need it if\n+         you modified \\`acinclude.m4' or \\`${configure_ac}'.  You might want\n+         to install the \\`Automake' and \\`Perl' packages.  Grab them from\n+         any GNU archive site.\"\n+    touch aclocal.m4\n+    ;;\n+\n+  autoconf*)\n+    echo 1>&2 \"\\\n+WARNING: \\`$1' is $msg.  You should only need it if\n+         you modified \\`${configure_ac}'.  You might want to install the\n+         \\`Autoconf' and \\`GNU m4' packages.  Grab them from any GNU\n+         archive site.\"\n+    touch configure\n+    ;;\n+\n+  autoheader*)\n+    echo 1>&2 \"\\\n+WARNING: \\`$1' is $msg.  You should only need it if\n+         you modified \\`acconfig.h' or \\`${configure_ac}'.  You might want\n+         to install the \\`Autoconf' and \\`GNU m4' packages.  Grab them\n+         from any GNU archive site.\"\n+    files=`sed -n 's/^[ ]*A[CM]_CONFIG_HEADER(\\([^)]*\\)).*/\\1/p' ${configure_ac}`\n+    test -z \"$files\" && files=\"config.h\"\n+    touch_files=\n+    for f in $files; do\n+      case $f in\n+      *:*) touch_files=\"$touch_files \"`echo \"$f\" |\n+\t\t\t\t       sed -e 's/^[^:]*://' -e 's/:.*//'`;;\n+      *) touch_files=\"$touch_files $f.in\";;\n+      esac\n+    done\n+    touch $touch_files\n+    ;;\n+\n+  automake*)\n+    echo 1>&2 \"\\\n+WARNING: \\`$1' is $msg.  You should only need it if\n+         you modified \\`Makefile.am', \\`acinclude.m4' or \\`${configure_ac}'.\n+         You might want to install the \\`Automake' and \\`Perl' packages.\n+         Grab them from any GNU archive site.\"\n+    find . -type f -name Makefile.am -print |\n+\t   sed 's/\\.am$/.in/' |\n+\t   while read f; do touch \"$f\"; done\n+    ;;\n+\n+  autom4te*)\n+    echo 1>&2 \"\\\n+WARNING: \\`$1' is needed, but is $msg.\n+         You might have modified some files without having the\n+         proper tools for further handling them.\n+         You can get \\`$1' as part of \\`Autoconf' from any GNU\n+         archive site.\"\n+\n+    file=`echo \"$*\" | sed -n \"$sed_output\"`\n+    test -z \"$file\" && file=`echo \"$*\" | sed -n \"$sed_minuso\"`\n+    if test -f \"$file\"; then\n+\ttouch $file\n+    else\n+\ttest -z \"$file\" || exec >$file\n+\techo \"#! /bin/sh\"\n+\techo \"# Created by GNU Automake missing as a replacement of\"\n+\techo \"#  $ $@\"\n+\techo \"exit 0\"\n+\tchmod +x $file\n+\texit 1\n+    fi\n+    ;;\n+\n+  bison*|yacc*)\n+    echo 1>&2 \"\\\n+WARNING: \\`$1' $msg.  You should only need it if\n+         you modified a \\`.y' file.  You may need the \\`Bison' package\n+         in order for those modifications to take effect.  You can get\n+         \\`Bison' from any GNU archive site.\"\n+    rm -f y.tab.c y.tab.h\n+    if test $# -ne 1; then\n+        eval LASTARG=\"\\${$#}\"\n+\tcase $LASTARG in\n+\t*.y)\n+\t    SRCFILE=`echo \"$LASTARG\" | sed 's/y$/c/'`\n+\t    if test -f \"$SRCFILE\"; then\n+\t         cp \"$SRCFILE\" y.tab.c\n+\t    fi\n+\t    SRCFILE=`echo \"$LASTARG\" | sed 's/y$/h/'`\n+\t    if test -f \"$SRCFILE\"; then\n+\t         cp \"$SRCFILE\" y.tab.h\n+\t    fi\n+\t  ;;\n+\tesac\n+    fi\n+    if test ! -f y.tab.h; then\n+\techo >y.tab.h\n+    fi\n+    if test ! -f y.tab.c; then\n+\techo 'main() { return 0; }' >y.tab.c\n+    fi\n+    ;;\n+\n+  lex*|flex*)\n+    echo 1>&2 \"\\\n+WARNING: \\`$1' is $msg.  You should only need it if\n+         you modified a \\`.l' file.  You may need the \\`Flex' package\n+         in order for those modifications to take effect.  You can get\n+         \\`Flex' from any GNU archive site.\"\n+    rm -f lex.yy.c\n+    if test $# -ne 1; then\n+        eval LASTARG=\"\\${$#}\"\n+\tcase $LASTARG in\n+\t*.l)\n+\t    SRCFILE=`echo \"$LASTARG\" | sed 's/l$/c/'`\n+\t    if test -f \"$SRCFILE\"; then\n+\t         cp \"$SRCFILE\" lex.yy.c\n+\t    fi\n+\t  ;;\n+\tesac\n+    fi\n+    if test ! -f lex.yy.c; then\n+\techo 'main() { return 0; }' >lex.yy.c\n+    fi\n+    ;;\n+\n+  help2man*)\n+    echo 1>&2 \"\\\n+WARNING: \\`$1' is $msg.  You should only need it if\n+\t you modified a dependency of a manual page.  You may need the\n+\t \\`Help2man' package in order for those modifications to take\n+\t effect.  You can get \\`Help2man' from any GNU archive site.\"\n+\n+    file=`echo \"$*\" | sed -n \"$sed_output\"`\n+    test -z \"$file\" && file=`echo \"$*\" | sed -n \"$sed_minuso\"`\n+    if test -f \"$file\"; then\n+\ttouch $file\n+    else\n+\ttest -z \"$file\" || exec >$file\n+\techo \".ab help2man is required to generate this page\"\n+\texit $?\n+    fi\n+    ;;\n+\n+  makeinfo*)\n+    echo 1>&2 \"\\\n+WARNING: \\`$1' is $msg.  You should only need it if\n+         you modified a \\`.texi' or \\`.texinfo' file, or any other file\n+         indirectly affecting the aspect of the manual.  The spurious\n+         call might also be the consequence of using a buggy \\`make' (AIX,\n+         DU, IRIX).  You might want to install the \\`Texinfo' package or\n+         the \\`GNU make' package.  Grab either from any GNU archive site.\"\n+    # The file to touch is that specified with -o ...\n+    file=`echo \"$*\" | sed -n \"$sed_output\"`\n+    test -z \"$file\" && file=`echo \"$*\" | sed -n \"$sed_minuso\"`\n+    if test -z \"$file\"; then\n+      # ... or it is the one specified with @setfilename ...\n+      infile=`echo \"$*\" | sed 's/.* \\([^ ]*\\) *$/\\1/'`\n+      file=`sed -n '\n+\t/^@setfilename/{\n+\t  s/.* \\([^ ]*\\) *$/\\1/\n+\t  p\n+\t  q\n+\t}' $infile`\n+      # ... or it is derived from the source name (dir/f.texi becomes f.info)\n+      test -z \"$file\" && file=`echo \"$infile\" | sed 's,.*/,,;s,.[^.]*$,,'`.info\n+    fi\n+    # If the file does not exist, the user really needs makeinfo;\n+    # let's fail without touching anything.\n+    test -f $file || exit 1\n+    touch $file\n+    ;;\n+\n+  tar*)\n+    shift\n+\n+    # We have already tried tar in the generic part.\n+    # Look for gnutar/gtar before invocation to avoid ugly error\n+    # messages.\n+    if (gnutar --version > /dev/null 2>&1); then\n+       gnutar \"$@\" && exit 0\n+    fi\n+    if (gtar --version > /dev/null 2>&1); then\n+       gtar \"$@\" && exit 0\n+    fi\n+    firstarg=\"$1\"\n+    if shift; then\n+\tcase $firstarg in\n+\t*o*)\n+\t    firstarg=`echo \"$firstarg\" | sed s/o//`\n+\t    tar \"$firstarg\" \"$@\" && exit 0\n+\t    ;;\n+\tesac\n+\tcase $firstarg in\n+\t*h*)\n+\t    firstarg=`echo \"$firstarg\" | sed s/h//`\n+\t    tar \"$firstarg\" \"$@\" && exit 0\n+\t    ;;\n+\tesac\n+    fi\n+\n+    echo 1>&2 \"\\\n+WARNING: I can't seem to be able to run \\`tar' with the given arguments.\n+         You may want to install GNU tar or Free paxutils, or check the\n+         command line arguments.\"\n+    exit 1\n+    ;;\n+\n+  *)\n+    echo 1>&2 \"\\\n+WARNING: \\`$1' is needed, and is $msg.\n+         You might have modified some files without having the\n+         proper tools for further handling them.  Check the \\`README' file,\n+         it often tells you about the needed prerequisites for installing\n+         this package.  You may also peek at any GNU archive site, in case\n+         some other package would contain this missing \\`$1' program.\"\n+    exit 1\n+    ;;\n+esac\n+\n+exit 0\n+\n+# Local variables:\n+# eval: (add-hook 'write-file-hooks 'time-stamp)\n+# time-stamp-start: \"scriptversion=\"\n+# time-stamp-format: \"%:y-%02m-%02d.%02H\"\n+# time-stamp-time-zone: \"UTC\"\n+# time-stamp-end: \"; # UTC\"\n+# End:"}, {"sha": "70df1d927092eec423b092627e61125af50a222f", "filename": "libsanitizer/sanitizer_common/Makefile.am", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2FMakefile.am?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,71 @@\n+AM_CPPFLAGS = -I $(top_srcdir)/include \n+ \n+DEFS = -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS \n+AM_CXXFLAGS = -Wall -W -Wno-unused-parameter -Wwrite-strings -pedantic -Wno-long-long  -fPIC -fno-builtin -fno-exceptions -fomit-frame-pointer -funwind-tables -fvisibility=hidden -Wno-variadic-macros -Wno-c99-extensions \n+ACLOCAL_AMFLAGS = -I m4\n+\n+noinst_LTLIBRARIES = libsanitizer_common.la\n+\n+sanitizer_common_files = \\\n+        sanitizer_allocator.cc \\\n+        sanitizer_common.cc \\\n+        sanitizer_flags.cc \\\n+        sanitizer_libc.cc \\\n+        sanitizer_linux.cc \\\n+        sanitizer_mac.cc \\\n+        sanitizer_posix.cc \\\n+        sanitizer_printf.cc \\\n+        sanitizer_stackdepot.cc \\\n+        sanitizer_stacktrace.cc \\\n+        sanitizer_symbolizer.cc \\\n+        sanitizer_symbolizer_linux.cc \\\n+        sanitizer_symbolizer_mac.cc \\\n+        sanitizer_symbolizer_win.cc \\\n+        sanitizer_win.cc\n+\n+libsanitizer_common_la_SOURCES = $(sanitizer_common_files) \n+\n+# Work around what appears to be a GNU make bug handling MAKEFLAGS\n+# values defined in terms of make variables, as is the case for CC and\n+# friends when we are called from the top level Makefile.\n+AM_MAKEFLAGS = \\\n+\t\"AR_FLAGS=$(AR_FLAGS)\" \\\n+\t\"CC_FOR_BUILD=$(CC_FOR_BUILD)\" \\\n+\t\"CFLAGS=$(CFLAGS)\" \\\n+\t\"CXXFLAGS=$(CXXFLAGS)\" \\\n+\t\"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)\" \\\n+\t\"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)\" \\\n+\t\"INSTALL=$(INSTALL)\" \\\n+\t\"INSTALL_DATA=$(INSTALL_DATA)\" \\\n+\t\"INSTALL_PROGRAM=$(INSTALL_PROGRAM)\" \\\n+\t\"INSTALL_SCRIPT=$(INSTALL_SCRIPT)\" \\\n+\t\"JC1FLAGS=$(JC1FLAGS)\" \\\n+\t\"LDFLAGS=$(LDFLAGS)\" \\\n+\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+\t\"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\"MAKE=$(MAKE)\" \\\n+\t\"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)\" \\\n+\t\"PICFLAG=$(PICFLAG)\" \\\n+\t\"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)\" \\\n+\t\"SHELL=$(SHELL)\" \\\n+\t\"RUNTESTFLAGS=$(RUNTESTFLAGS)\" \\\n+\t\"exec_prefix=$(exec_prefix)\" \\\n+\t\"infodir=$(infodir)\" \\\n+\t\"libdir=$(libdir)\" \\\n+\t\"prefix=$(prefix)\" \\\n+\t\"includedir=$(includedir)\" \\\n+\t\"AR=$(AR)\" \\\n+\t\"AS=$(AS)\" \\\n+\t\"CC=$(CC)\" \\\n+\t\"CXX=$(CXX)\" \\\n+\t\"LD=$(LD)\" \\\n+\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+\t\"NM=$(NM)\" \\\n+\t\"PICFLAG=$(PICFLAG)\" \\\n+\t\"RANLIB=$(RANLIB)\" \\\n+\t\"DESTDIR=$(DESTDIR)\"\n+\n+MAKEOVERRIDES=\n+\n+## ################################################################\n+"}, {"sha": "75a83ab95b642240c6102165f4864ab05b2f361c", "filename": "libsanitizer/sanitizer_common/Makefile.in", "status": "added", "additions": 564, "deletions": 0, "changes": 564, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2FMakefile.in?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,564 @@\n+# Makefile.in generated by automake 1.11.3 from Makefile.am.\n+# @configure_input@\n+\n+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n+# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software\n+# Foundation, Inc.\n+# This Makefile.in is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+# PARTICULAR PURPOSE.\n+\n+@SET_MAKE@\n+\n+VPATH = @srcdir@\n+pkgdatadir = $(datadir)/@PACKAGE@\n+pkgincludedir = $(includedir)/@PACKAGE@\n+pkglibdir = $(libdir)/@PACKAGE@\n+pkglibexecdir = $(libexecdir)/@PACKAGE@\n+am__cd = CDPATH=\"$${ZSH_VERSION+.}$(PATH_SEPARATOR)\" && cd\n+install_sh_DATA = $(install_sh) -c -m 644\n+install_sh_PROGRAM = $(install_sh) -c\n+install_sh_SCRIPT = $(install_sh) -c\n+INSTALL_HEADER = $(INSTALL_DATA)\n+transform = $(program_transform_name)\n+NORMAL_INSTALL = :\n+PRE_INSTALL = :\n+POST_INSTALL = :\n+NORMAL_UNINSTALL = :\n+PRE_UNINSTALL = :\n+POST_UNINSTALL = :\n+build_triplet = @build@\n+host_triplet = @host@\n+subdir = sanitizer_common\n+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in\n+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n+am__aclocal_m4_deps = $(top_srcdir)/configure.ac\n+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n+\t$(ACLOCAL_M4)\n+mkinstalldirs = $(install_sh) -d\n+CONFIG_CLEAN_FILES =\n+CONFIG_CLEAN_VPATH_FILES =\n+LTLIBRARIES = $(noinst_LTLIBRARIES)\n+libsanitizer_common_la_LIBADD =\n+am__objects_1 = sanitizer_allocator.lo sanitizer_common.lo \\\n+\tsanitizer_flags.lo sanitizer_libc.lo sanitizer_linux.lo \\\n+\tsanitizer_mac.lo sanitizer_posix.lo sanitizer_printf.lo \\\n+\tsanitizer_stackdepot.lo sanitizer_stacktrace.lo \\\n+\tsanitizer_symbolizer.lo sanitizer_symbolizer_linux.lo \\\n+\tsanitizer_symbolizer_mac.lo sanitizer_symbolizer_win.lo \\\n+\tsanitizer_win.lo\n+am_libsanitizer_common_la_OBJECTS = $(am__objects_1)\n+libsanitizer_common_la_OBJECTS = $(am_libsanitizer_common_la_OBJECTS)\n+DEFAULT_INCLUDES = -I.@am__isrc@\n+depcomp = $(SHELL) $(top_srcdir)/depcomp\n+am__depfiles_maybe = depfiles\n+am__mv = mv -f\n+CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n+\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)\n+LTCXXCOMPILE = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n+\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)\n+CXXLD = $(CXX)\n+CXXLINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=link $(CXXLD) $(AM_CXXFLAGS) $(CXXFLAGS) $(AM_LDFLAGS) \\\n+\t$(LDFLAGS) -o $@\n+SOURCES = $(libsanitizer_common_la_SOURCES)\n+DIST_SOURCES = $(libsanitizer_common_la_SOURCES)\n+ETAGS = etags\n+CTAGS = ctags\n+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)\n+ACLOCAL = @ACLOCAL@\n+AMTAR = @AMTAR@\n+AR = @AR@\n+AUTOCONF = @AUTOCONF@\n+AUTOHEADER = @AUTOHEADER@\n+AUTOMAKE = @AUTOMAKE@\n+AWK = @AWK@\n+CC = @CC@\n+CCAS = @CCAS@\n+CCASDEPMODE = @CCASDEPMODE@\n+CCASFLAGS = @CCASFLAGS@\n+CCDEPMODE = @CCDEPMODE@\n+CFLAGS = @CFLAGS@\n+CPP = @CPP@\n+CPPFLAGS = @CPPFLAGS@\n+CXX = @CXX@\n+CXXCPP = @CXXCPP@\n+CXXDEPMODE = @CXXDEPMODE@\n+CXXFLAGS = @CXXFLAGS@\n+CYGPATH_W = @CYGPATH_W@\n+DEFS = -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS \n+DEPDIR = @DEPDIR@\n+DLLTOOL = @DLLTOOL@\n+DSYMUTIL = @DSYMUTIL@\n+DUMPBIN = @DUMPBIN@\n+ECHO_C = @ECHO_C@\n+ECHO_N = @ECHO_N@\n+ECHO_T = @ECHO_T@\n+EGREP = @EGREP@\n+EXEEXT = @EXEEXT@\n+FGREP = @FGREP@\n+GREP = @GREP@\n+INSTALL = @INSTALL@\n+INSTALL_DATA = @INSTALL_DATA@\n+INSTALL_PROGRAM = @INSTALL_PROGRAM@\n+INSTALL_SCRIPT = @INSTALL_SCRIPT@\n+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@\n+LD = @LD@\n+LDFLAGS = @LDFLAGS@\n+LIBOBJS = @LIBOBJS@\n+LIBS = @LIBS@\n+LIBTOOL = @LIBTOOL@\n+LIPO = @LIPO@\n+LN_S = @LN_S@\n+LTLIBOBJS = @LTLIBOBJS@\n+MAKEINFO = @MAKEINFO@\n+MANIFEST_TOOL = @MANIFEST_TOOL@\n+MKDIR_P = @MKDIR_P@\n+NM = @NM@\n+NMEDIT = @NMEDIT@\n+OBJDUMP = @OBJDUMP@\n+OBJEXT = @OBJEXT@\n+OTOOL = @OTOOL@\n+OTOOL64 = @OTOOL64@\n+PACKAGE = @PACKAGE@\n+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\n+PACKAGE_NAME = @PACKAGE_NAME@\n+PACKAGE_STRING = @PACKAGE_STRING@\n+PACKAGE_TARNAME = @PACKAGE_TARNAME@\n+PACKAGE_URL = @PACKAGE_URL@\n+PACKAGE_VERSION = @PACKAGE_VERSION@\n+PATH_SEPARATOR = @PATH_SEPARATOR@\n+RANLIB = @RANLIB@\n+SED = @SED@\n+SET_MAKE = @SET_MAKE@\n+SHELL = @SHELL@\n+STRIP = @STRIP@\n+VERSION = @VERSION@\n+abs_builddir = @abs_builddir@\n+abs_srcdir = @abs_srcdir@\n+abs_top_builddir = @abs_top_builddir@\n+abs_top_srcdir = @abs_top_srcdir@\n+ac_ct_AR = @ac_ct_AR@\n+ac_ct_CC = @ac_ct_CC@\n+ac_ct_CXX = @ac_ct_CXX@\n+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@\n+am__include = @am__include@\n+am__leading_dot = @am__leading_dot@\n+am__quote = @am__quote@\n+am__tar = @am__tar@\n+am__untar = @am__untar@\n+bindir = @bindir@\n+build = @build@\n+build_alias = @build_alias@\n+build_cpu = @build_cpu@\n+build_os = @build_os@\n+build_vendor = @build_vendor@\n+builddir = @builddir@\n+datadir = @datadir@\n+datarootdir = @datarootdir@\n+docdir = @docdir@\n+dvidir = @dvidir@\n+enable_shared = @enable_shared@\n+enable_static = @enable_static@\n+exec_prefix = @exec_prefix@\n+host = @host@\n+host_alias = @host_alias@\n+host_cpu = @host_cpu@\n+host_os = @host_os@\n+host_vendor = @host_vendor@\n+htmldir = @htmldir@\n+includedir = @includedir@\n+infodir = @infodir@\n+install_sh = @install_sh@\n+libdir = @libdir@\n+libexecdir = @libexecdir@\n+localedir = @localedir@\n+localstatedir = @localstatedir@\n+mandir = @mandir@\n+mkdir_p = @mkdir_p@\n+oldincludedir = @oldincludedir@\n+pdfdir = @pdfdir@\n+prefix = @prefix@\n+program_transform_name = @program_transform_name@\n+psdir = @psdir@\n+sbindir = @sbindir@\n+sharedstatedir = @sharedstatedir@\n+srcdir = @srcdir@\n+sysconfdir = @sysconfdir@\n+target_alias = @target_alias@\n+toolexecdir = @toolexecdir@\n+toolexeclibdir = @toolexeclibdir@\n+top_build_prefix = @top_build_prefix@\n+top_builddir = @top_builddir@\n+top_srcdir = @top_srcdir@\n+AM_CPPFLAGS = -I $(top_srcdir)/include \n+AM_CXXFLAGS = -Wall -W -Wno-unused-parameter -Wwrite-strings -pedantic -Wno-long-long  -fPIC -fno-builtin -fno-exceptions -fomit-frame-pointer -funwind-tables -fvisibility=hidden -Wno-variadic-macros -Wno-c99-extensions \n+ACLOCAL_AMFLAGS = -I m4\n+noinst_LTLIBRARIES = libsanitizer_common.la\n+sanitizer_common_files = \\\n+        sanitizer_allocator.cc \\\n+        sanitizer_common.cc \\\n+        sanitizer_flags.cc \\\n+        sanitizer_libc.cc \\\n+        sanitizer_linux.cc \\\n+        sanitizer_mac.cc \\\n+        sanitizer_posix.cc \\\n+        sanitizer_printf.cc \\\n+        sanitizer_stackdepot.cc \\\n+        sanitizer_stacktrace.cc \\\n+        sanitizer_symbolizer.cc \\\n+        sanitizer_symbolizer_linux.cc \\\n+        sanitizer_symbolizer_mac.cc \\\n+        sanitizer_symbolizer_win.cc \\\n+        sanitizer_win.cc\n+\n+libsanitizer_common_la_SOURCES = $(sanitizer_common_files) \n+\n+# Work around what appears to be a GNU make bug handling MAKEFLAGS\n+# values defined in terms of make variables, as is the case for CC and\n+# friends when we are called from the top level Makefile.\n+AM_MAKEFLAGS = \\\n+\t\"AR_FLAGS=$(AR_FLAGS)\" \\\n+\t\"CC_FOR_BUILD=$(CC_FOR_BUILD)\" \\\n+\t\"CFLAGS=$(CFLAGS)\" \\\n+\t\"CXXFLAGS=$(CXXFLAGS)\" \\\n+\t\"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)\" \\\n+\t\"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)\" \\\n+\t\"INSTALL=$(INSTALL)\" \\\n+\t\"INSTALL_DATA=$(INSTALL_DATA)\" \\\n+\t\"INSTALL_PROGRAM=$(INSTALL_PROGRAM)\" \\\n+\t\"INSTALL_SCRIPT=$(INSTALL_SCRIPT)\" \\\n+\t\"JC1FLAGS=$(JC1FLAGS)\" \\\n+\t\"LDFLAGS=$(LDFLAGS)\" \\\n+\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+\t\"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\"MAKE=$(MAKE)\" \\\n+\t\"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)\" \\\n+\t\"PICFLAG=$(PICFLAG)\" \\\n+\t\"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)\" \\\n+\t\"SHELL=$(SHELL)\" \\\n+\t\"RUNTESTFLAGS=$(RUNTESTFLAGS)\" \\\n+\t\"exec_prefix=$(exec_prefix)\" \\\n+\t\"infodir=$(infodir)\" \\\n+\t\"libdir=$(libdir)\" \\\n+\t\"prefix=$(prefix)\" \\\n+\t\"includedir=$(includedir)\" \\\n+\t\"AR=$(AR)\" \\\n+\t\"AS=$(AS)\" \\\n+\t\"CC=$(CC)\" \\\n+\t\"CXX=$(CXX)\" \\\n+\t\"LD=$(LD)\" \\\n+\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+\t\"NM=$(NM)\" \\\n+\t\"PICFLAG=$(PICFLAG)\" \\\n+\t\"RANLIB=$(RANLIB)\" \\\n+\t\"DESTDIR=$(DESTDIR)\"\n+\n+MAKEOVERRIDES = \n+all: all-am\n+\n+.SUFFIXES:\n+.SUFFIXES: .cc .lo .o .obj\n+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)\n+\t@for dep in $?; do \\\n+\t  case '$(am__configure_deps)' in \\\n+\t    *$$dep*) \\\n+\t      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \\\n+\t        && { if test -f $@; then exit 0; else break; fi; }; \\\n+\t      exit 1;; \\\n+\t  esac; \\\n+\tdone; \\\n+\techo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign sanitizer_common/Makefile'; \\\n+\t$(am__cd) $(top_srcdir) && \\\n+\t  $(AUTOMAKE) --foreign sanitizer_common/Makefile\n+.PRECIOUS: Makefile\n+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n+\t@case '$?' in \\\n+\t  *config.status*) \\\n+\t    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \\\n+\t  *) \\\n+\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \\\n+\t    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \\\n+\tesac;\n+\n+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)\n+\tcd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh\n+\n+$(top_srcdir)/configure:  $(am__configure_deps)\n+\tcd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh\n+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)\n+\tcd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh\n+$(am__aclocal_m4_deps):\n+\n+clean-noinstLTLIBRARIES:\n+\t-test -z \"$(noinst_LTLIBRARIES)\" || rm -f $(noinst_LTLIBRARIES)\n+\t@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \\\n+\t  dir=\"`echo $$p | sed -e 's|/[^/]*$$||'`\"; \\\n+\t  test \"$$dir\" != \"$$p\" || dir=.; \\\n+\t  echo \"rm -f \\\"$${dir}/so_locations\\\"\"; \\\n+\t  rm -f \"$${dir}/so_locations\"; \\\n+\tdone\n+libsanitizer_common.la: $(libsanitizer_common_la_OBJECTS) $(libsanitizer_common_la_DEPENDENCIES) $(EXTRA_libsanitizer_common_la_DEPENDENCIES) \n+\t$(CXXLINK)  $(libsanitizer_common_la_OBJECTS) $(libsanitizer_common_la_LIBADD) $(LIBS)\n+\n+mostlyclean-compile:\n+\t-rm -f *.$(OBJEXT)\n+\n+distclean-compile:\n+\t-rm -f *.tab.c\n+\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_allocator.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_common.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_flags.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_libc.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_linux.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_mac.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_posix.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_printf.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_stackdepot.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_stacktrace.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_symbolizer.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_symbolizer_linux.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_symbolizer_mac.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_symbolizer_win.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_win.Plo@am__quote@\n+\n+.cc.o:\n+@am__fastdepCXX_TRUE@\t$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(CXXCOMPILE) -c -o $@ $<\n+\n+.cc.obj:\n+@am__fastdepCXX_TRUE@\t$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`\n+\n+.cc.lo:\n+@am__fastdepCXX_TRUE@\t$(LTCXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='$<' object='$@' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(LTCXXCOMPILE) -c -o $@ $<\n+\n+mostlyclean-libtool:\n+\t-rm -f *.lo\n+\n+clean-libtool:\n+\t-rm -rf .libs _libs\n+\n+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)\n+\tlist='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\tmkid -fID $$unique\n+tags: TAGS\n+\n+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \\\n+\t\t$(TAGS_FILES) $(LISP)\n+\tset x; \\\n+\there=`pwd`; \\\n+\tlist='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\tshift; \\\n+\tif test -z \"$(ETAGS_ARGS)$$*$$unique\"; then :; else \\\n+\t  test -n \"$$unique\" || unique=$$empty_fix; \\\n+\t  if test $$# -gt 0; then \\\n+\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n+\t      \"$$@\" $$unique; \\\n+\t  else \\\n+\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n+\t      $$unique; \\\n+\t  fi; \\\n+\tfi\n+ctags: CTAGS\n+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \\\n+\t\t$(TAGS_FILES) $(LISP)\n+\tlist='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\ttest -z \"$(CTAGS_ARGS)$$unique\" \\\n+\t  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \\\n+\t     $$unique\n+\n+GTAGS:\n+\there=`$(am__cd) $(top_builddir) && pwd` \\\n+\t  && $(am__cd) $(top_srcdir) \\\n+\t  && gtags -i $(GTAGS_ARGS) \"$$here\"\n+\n+distclean-tags:\n+\t-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags\n+\n+distdir: $(DISTFILES)\n+\t@srcdirstrip=`echo \"$(srcdir)\" | sed 's/[].[^$$\\\\*]/\\\\\\\\&/g'`; \\\n+\ttopsrcdirstrip=`echo \"$(top_srcdir)\" | sed 's/[].[^$$\\\\*]/\\\\\\\\&/g'`; \\\n+\tlist='$(DISTFILES)'; \\\n+\t  dist_files=`for file in $$list; do echo $$file; done | \\\n+\t  sed -e \"s|^$$srcdirstrip/||;t\" \\\n+\t      -e \"s|^$$topsrcdirstrip/|$(top_builddir)/|;t\"`; \\\n+\tcase $$dist_files in \\\n+\t  */*) $(MKDIR_P) `echo \"$$dist_files\" | \\\n+\t\t\t   sed '/\\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \\\n+\t\t\t   sort -u` ;; \\\n+\tesac; \\\n+\tfor file in $$dist_files; do \\\n+\t  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \\\n+\t  if test -d $$d/$$file; then \\\n+\t    dir=`echo \"/$$file\" | sed -e 's,/[^/]*$$,,'`; \\\n+\t    if test -d \"$(distdir)/$$file\"; then \\\n+\t      find \"$(distdir)/$$file\" -type d ! -perm -700 -exec chmod u+rwx {} \\;; \\\n+\t    fi; \\\n+\t    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \\\n+\t      cp -fpR $(srcdir)/$$file \"$(distdir)$$dir\" || exit 1; \\\n+\t      find \"$(distdir)/$$file\" -type d ! -perm -700 -exec chmod u+rwx {} \\;; \\\n+\t    fi; \\\n+\t    cp -fpR $$d/$$file \"$(distdir)$$dir\" || exit 1; \\\n+\t  else \\\n+\t    test -f \"$(distdir)/$$file\" \\\n+\t    || cp -p $$d/$$file \"$(distdir)/$$file\" \\\n+\t    || exit 1; \\\n+\t  fi; \\\n+\tdone\n+check-am: all-am\n+check: check-am\n+all-am: Makefile $(LTLIBRARIES)\n+installdirs:\n+install: install-am\n+install-exec: install-exec-am\n+install-data: install-data-am\n+uninstall: uninstall-am\n+\n+install-am: all-am\n+\t@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am\n+\n+installcheck: installcheck-am\n+install-strip:\n+\tif test -z '$(STRIP)'; then \\\n+\t  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n+\t    install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n+\t      install; \\\n+\telse \\\n+\t  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n+\t    install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n+\t    \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\" install; \\\n+\tfi\n+mostlyclean-generic:\n+\n+clean-generic:\n+\n+distclean-generic:\n+\t-test -z \"$(CONFIG_CLEAN_FILES)\" || rm -f $(CONFIG_CLEAN_FILES)\n+\t-test . = \"$(srcdir)\" || test -z \"$(CONFIG_CLEAN_VPATH_FILES)\" || rm -f $(CONFIG_CLEAN_VPATH_FILES)\n+\n+maintainer-clean-generic:\n+\t@echo \"This command is intended for maintainers to use\"\n+\t@echo \"it deletes files that may require special tools to rebuild.\"\n+clean: clean-am\n+\n+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \\\n+\tmostlyclean-am\n+\n+distclean: distclean-am\n+\t-rm -rf ./$(DEPDIR)\n+\t-rm -f Makefile\n+distclean-am: clean-am distclean-compile distclean-generic \\\n+\tdistclean-tags\n+\n+dvi: dvi-am\n+\n+dvi-am:\n+\n+html: html-am\n+\n+html-am:\n+\n+info: info-am\n+\n+info-am:\n+\n+install-data-am:\n+\n+install-dvi: install-dvi-am\n+\n+install-dvi-am:\n+\n+install-exec-am:\n+\n+install-html: install-html-am\n+\n+install-html-am:\n+\n+install-info: install-info-am\n+\n+install-info-am:\n+\n+install-man:\n+\n+install-pdf: install-pdf-am\n+\n+install-pdf-am:\n+\n+install-ps: install-ps-am\n+\n+install-ps-am:\n+\n+installcheck-am:\n+\n+maintainer-clean: maintainer-clean-am\n+\t-rm -rf ./$(DEPDIR)\n+\t-rm -f Makefile\n+maintainer-clean-am: distclean-am maintainer-clean-generic\n+\n+mostlyclean: mostlyclean-am\n+\n+mostlyclean-am: mostlyclean-compile mostlyclean-generic \\\n+\tmostlyclean-libtool\n+\n+pdf: pdf-am\n+\n+pdf-am:\n+\n+ps: ps-am\n+\n+ps-am:\n+\n+uninstall-am:\n+\n+.MAKE: install-am install-strip\n+\n+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \\\n+\tclean-libtool clean-noinstLTLIBRARIES ctags distclean \\\n+\tdistclean-compile distclean-generic distclean-libtool \\\n+\tdistclean-tags distdir dvi dvi-am html html-am info info-am \\\n+\tinstall install-am install-data install-data-am install-dvi \\\n+\tinstall-dvi-am install-exec install-exec-am install-html \\\n+\tinstall-html-am install-info install-info-am install-man \\\n+\tinstall-pdf install-pdf-am install-ps install-ps-am \\\n+\tinstall-strip installcheck installcheck-am installdirs \\\n+\tmaintainer-clean maintainer-clean-generic mostlyclean \\\n+\tmostlyclean-compile mostlyclean-generic mostlyclean-libtool \\\n+\tpdf pdf-am ps ps-am tags uninstall uninstall-am\n+\n+\n+# Tell versions [3.59,3.63) of GNU make to not export all variables.\n+# Otherwise a system limit (for SysV at least) may be exceeded.\n+.NOEXPORT:"}, {"sha": "ff176a88d3a6932e542d7482bc2bfab58dce2dc1", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator.cc", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.cc?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,83 @@\n+//===-- sanitizer_allocator.cc --------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is shared between AddressSanitizer and ThreadSanitizer\n+// run-time libraries.\n+// This allocator that is used inside run-times.\n+//===----------------------------------------------------------------------===//\n+#include \"sanitizer_common.h\"\n+\n+// FIXME: We should probably use more low-level allocator that would\n+// mmap some pages and split them into chunks to fulfill requests.\n+#if defined(__linux__) && !defined(__ANDROID__)\n+extern \"C\" void *__libc_malloc(__sanitizer::uptr size);\n+extern \"C\" void __libc_free(void *ptr);\n+# define LIBC_MALLOC __libc_malloc\n+# define LIBC_FREE __libc_free\n+#else  // __linux__ && !ANDROID\n+# include <stdlib.h>\n+# define LIBC_MALLOC malloc\n+# define LIBC_FREE free\n+#endif  // __linux__ && !ANDROID\n+\n+namespace __sanitizer {\n+\n+const u64 kBlockMagic = 0x6A6CB03ABCEBC041ull;\n+\n+void *InternalAlloc(uptr size) {\n+  if (size + sizeof(u64) < size)\n+    return 0;\n+  void *p = LIBC_MALLOC(size + sizeof(u64));\n+  if (p == 0)\n+    return 0;\n+  ((u64*)p)[0] = kBlockMagic;\n+  return (char*)p + sizeof(u64);\n+}\n+\n+void InternalFree(void *addr) {\n+  if (addr == 0)\n+    return;\n+  addr = (char*)addr - sizeof(u64);\n+  CHECK_EQ(((u64*)addr)[0], kBlockMagic);\n+  ((u64*)addr)[0] = 0;\n+  LIBC_FREE(addr);\n+}\n+\n+void *InternalAllocBlock(void *p) {\n+  CHECK_NE(p, (void*)0);\n+  u64 *pp = (u64*)((uptr)p & ~0x7);\n+  for (; pp[0] != kBlockMagic; pp--) {}\n+  return pp + 1;\n+}\n+\n+// LowLevelAllocator\n+static LowLevelAllocateCallback low_level_alloc_callback;\n+\n+void *LowLevelAllocator::Allocate(uptr size) {\n+  // Align allocation size.\n+  size = RoundUpTo(size, 8);\n+  if (allocated_end_ - allocated_current_ < (sptr)size) {\n+    uptr size_to_allocate = Max(size, kPageSize);\n+    allocated_current_ =\n+        (char*)MmapOrDie(size_to_allocate, __FUNCTION__);\n+    allocated_end_ = allocated_current_ + size_to_allocate;\n+    if (low_level_alloc_callback) {\n+      low_level_alloc_callback((uptr)allocated_current_,\n+                               size_to_allocate);\n+    }\n+  }\n+  CHECK(allocated_end_ - allocated_current_ >= (sptr)size);\n+  void *res = allocated_current_;\n+  allocated_current_ += size;\n+  return res;\n+}\n+\n+void SetLowLevelAllocateCallback(LowLevelAllocateCallback callback) {\n+  low_level_alloc_callback = callback;\n+}\n+\n+}  // namespace __sanitizer"}, {"sha": "247719876aa759cf104289f5061c35b1d59b3d34", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator64.h", "status": "added", "additions": 573, "deletions": 0, "changes": 573, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator64.h?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,573 @@\n+//===-- sanitizer_allocator64.h ---------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+// Specialized allocator which works only in 64-bit address space.\n+// To be used by ThreadSanitizer, MemorySanitizer and possibly other tools.\n+// The main feature of this allocator is that the header is located far away\n+// from the user memory region, so that the tool does not use extra shadow\n+// for the header.\n+//\n+// Status: not yet ready.\n+//===----------------------------------------------------------------------===//\n+#ifndef SANITIZER_ALLOCATOR_H\n+#define SANITIZER_ALLOCATOR_H\n+\n+#include \"sanitizer_internal_defs.h\"\n+#if __WORDSIZE != 64\n+# error \"sanitizer_allocator64.h can only be used on 64-bit platforms\"\n+#endif\n+\n+#include \"sanitizer_common.h\"\n+#include \"sanitizer_libc.h\"\n+#include \"sanitizer_list.h\"\n+#include \"sanitizer_mutex.h\"\n+\n+namespace __sanitizer {\n+\n+// Maps size class id to size and back.\n+class DefaultSizeClassMap {\n+ private:\n+  // Here we use a spline composed of 5 polynomials of oder 1.\n+  // The first size class is l0, then the classes go with step s0\n+  // untill they reach l1, after which they go with step s1 and so on.\n+  // Steps should be powers of two for cheap division.\n+  // The size of the last size class should be a power of two.\n+  // There should be at most 256 size classes.\n+  static const uptr l0 = 1 << 4;\n+  static const uptr l1 = 1 << 9;\n+  static const uptr l2 = 1 << 12;\n+  static const uptr l3 = 1 << 15;\n+  static const uptr l4 = 1 << 18;\n+  static const uptr l5 = 1 << 21;\n+\n+  static const uptr s0 = 1 << 4;\n+  static const uptr s1 = 1 << 6;\n+  static const uptr s2 = 1 << 9;\n+  static const uptr s3 = 1 << 12;\n+  static const uptr s4 = 1 << 15;\n+\n+  static const uptr u0 = 0  + (l1 - l0) / s0;\n+  static const uptr u1 = u0 + (l2 - l1) / s1;\n+  static const uptr u2 = u1 + (l3 - l2) / s2;\n+  static const uptr u3 = u2 + (l4 - l3) / s3;\n+  static const uptr u4 = u3 + (l5 - l4) / s4;\n+\n+  // Max cached in local cache blocks.\n+  static const uptr c0 = 256;\n+  static const uptr c1 = 64;\n+  static const uptr c2 = 16;\n+  static const uptr c3 = 4;\n+  static const uptr c4 = 1;\n+\n+ public:\n+  static const uptr kNumClasses = u4 + 1;\n+  static const uptr kMaxSize = l5;\n+  static const uptr kMinSize = l0;\n+\n+  COMPILER_CHECK(kNumClasses <= 256);\n+  COMPILER_CHECK((kMaxSize & (kMaxSize - 1)) == 0);\n+\n+  static uptr Size(uptr class_id) {\n+    if (class_id <= u0) return l0 + s0 * (class_id - 0);\n+    if (class_id <= u1) return l1 + s1 * (class_id - u0);\n+    if (class_id <= u2) return l2 + s2 * (class_id - u1);\n+    if (class_id <= u3) return l3 + s3 * (class_id - u2);\n+    if (class_id <= u4) return l4 + s4 * (class_id - u3);\n+    return 0;\n+  }\n+  static uptr ClassID(uptr size) {\n+    if (size <= l1) return 0  + (size - l0 + s0 - 1) / s0;\n+    if (size <= l2) return u0 + (size - l1 + s1 - 1) / s1;\n+    if (size <= l3) return u1 + (size - l2 + s2 - 1) / s2;\n+    if (size <= l4) return u2 + (size - l3 + s3 - 1) / s3;\n+    if (size <= l5) return u3 + (size - l4 + s4 - 1) / s4;\n+    return 0;\n+  }\n+\n+  static uptr MaxCached(uptr class_id) {\n+    if (class_id <= u0) return c0;\n+    if (class_id <= u1) return c1;\n+    if (class_id <= u2) return c2;\n+    if (class_id <= u3) return c3;\n+    if (class_id <= u4) return c4;\n+    return 0;\n+  }\n+};\n+\n+struct AllocatorListNode {\n+  AllocatorListNode *next;\n+};\n+\n+typedef IntrusiveList<AllocatorListNode> AllocatorFreeList;\n+\n+\n+// Space: a portion of address space of kSpaceSize bytes starting at\n+// a fixed address (kSpaceBeg). Both constants are powers of two and\n+// kSpaceBeg is kSpaceSize-aligned.\n+//\n+// Region: a part of Space dedicated to a single size class.\n+// There are kNumClasses Regions of equal size.\n+//\n+// UserChunk: a piece of memory returned to user.\n+// MetaChunk: kMetadataSize bytes of metadata associated with a UserChunk.\n+//\n+// A Region looks like this:\n+// UserChunk1 ... UserChunkN <gap> MetaChunkN ... MetaChunk1\n+template <const uptr kSpaceBeg, const uptr kSpaceSize,\n+          const uptr kMetadataSize, class SizeClassMap>\n+class SizeClassAllocator64 {\n+ public:\n+  void Init() {\n+    CHECK_EQ(AllocBeg(), reinterpret_cast<uptr>(MmapFixedNoReserve(\n+             AllocBeg(), AllocSize())));\n+  }\n+\n+  bool CanAllocate(uptr size, uptr alignment) {\n+    return size <= SizeClassMap::kMaxSize &&\n+      alignment <= SizeClassMap::kMaxSize;\n+  }\n+\n+  void *Allocate(uptr size, uptr alignment) {\n+    CHECK(CanAllocate(size, alignment));\n+    return AllocateBySizeClass(SizeClassMap::ClassID(size));\n+  }\n+\n+  void Deallocate(void *p) {\n+    CHECK(PointerIsMine(p));\n+    DeallocateBySizeClass(p, GetSizeClass(p));\n+  }\n+\n+  // Allocate several chunks of the given class_id.\n+  void BulkAllocate(uptr class_id, AllocatorFreeList *free_list) {\n+    CHECK_LT(class_id, kNumClasses);\n+    RegionInfo *region = GetRegionInfo(class_id);\n+    SpinMutexLock l(&region->mutex);\n+    if (region->free_list.empty()) {\n+      PopulateFreeList(class_id, region);\n+    }\n+    CHECK(!region->free_list.empty());\n+    uptr count = SizeClassMap::MaxCached(class_id);\n+    if (region->free_list.size() <= count) {\n+      free_list->append_front(&region->free_list);\n+    } else {\n+      for (uptr i = 0; i < count; i++) {\n+        AllocatorListNode *node = region->free_list.front();\n+        region->free_list.pop_front();\n+        free_list->push_front(node);\n+      }\n+    }\n+    CHECK(!free_list->empty());\n+  }\n+\n+  // Swallow the entire free_list for the given class_id.\n+  void BulkDeallocate(uptr class_id, AllocatorFreeList *free_list) {\n+    CHECK_LT(class_id, kNumClasses);\n+    RegionInfo *region = GetRegionInfo(class_id);\n+    SpinMutexLock l(&region->mutex);\n+    region->free_list.append_front(free_list);\n+  }\n+\n+  static bool PointerIsMine(void *p) {\n+    return reinterpret_cast<uptr>(p) / kSpaceSize == kSpaceBeg / kSpaceSize;\n+  }\n+\n+  static uptr GetSizeClass(void *p) {\n+    return (reinterpret_cast<uptr>(p) / kRegionSize) % kNumClasses;\n+  }\n+\n+  static void *GetBlockBegin(void *p) {\n+    uptr class_id = GetSizeClass(p);\n+    uptr size = SizeClassMap::Size(class_id);\n+    uptr chunk_idx = GetChunkIdx((uptr)p, size);\n+    uptr reg_beg = (uptr)p & ~(kRegionSize - 1);\n+    uptr begin = reg_beg + chunk_idx * size;\n+    return (void*)begin;\n+  }\n+\n+  static uptr GetActuallyAllocatedSize(void *p) {\n+    CHECK(PointerIsMine(p));\n+    return SizeClassMap::Size(GetSizeClass(p));\n+  }\n+\n+  uptr ClassID(uptr size) { return SizeClassMap::ClassID(size); }\n+\n+  void *GetMetaData(void *p) {\n+    uptr class_id = GetSizeClass(p);\n+    uptr size = SizeClassMap::Size(class_id);\n+    uptr chunk_idx = GetChunkIdx(reinterpret_cast<uptr>(p), size);\n+    return reinterpret_cast<void*>(kSpaceBeg + (kRegionSize * (class_id + 1)) -\n+                                   (1 + chunk_idx) * kMetadataSize);\n+  }\n+\n+  uptr TotalMemoryUsed() {\n+    uptr res = 0;\n+    for (uptr i = 0; i < kNumClasses; i++)\n+      res += GetRegionInfo(i)->allocated_user;\n+    return res;\n+  }\n+\n+  // Test-only.\n+  void TestOnlyUnmap() {\n+    UnmapOrDie(reinterpret_cast<void*>(AllocBeg()), AllocSize());\n+  }\n+\n+  static uptr AllocBeg()  { return kSpaceBeg; }\n+  static uptr AllocEnd()  { return kSpaceBeg  + kSpaceSize + AdditionalSize(); }\n+  static uptr AllocSize() { return kSpaceSize + AdditionalSize(); }\n+\n+  static const uptr kNumClasses = 256;  // Power of two <= 256\n+  typedef SizeClassMap SizeClassMapT;\n+\n+ private:\n+  COMPILER_CHECK(kSpaceBeg % kSpaceSize == 0);\n+  COMPILER_CHECK(kNumClasses <= SizeClassMap::kNumClasses);\n+  static const uptr kRegionSize = kSpaceSize / kNumClasses;\n+  COMPILER_CHECK((kRegionSize >> 32) > 0);  // kRegionSize must be >= 2^32.\n+  // Populate the free list with at most this number of bytes at once\n+  // or with one element if its size is greater.\n+  static const uptr kPopulateSize = 1 << 18;\n+\n+  struct RegionInfo {\n+    SpinMutex mutex;\n+    AllocatorFreeList free_list;\n+    uptr allocated_user;  // Bytes allocated for user memory.\n+    uptr allocated_meta;  // Bytes allocated for metadata.\n+    char padding[kCacheLineSize - 3 * sizeof(uptr) - sizeof(AllocatorFreeList)];\n+  };\n+  COMPILER_CHECK(sizeof(RegionInfo) == kCacheLineSize);\n+\n+  static uptr AdditionalSize() {\n+    uptr res = sizeof(RegionInfo) * kNumClasses;\n+    CHECK_EQ(res % kPageSize, 0);\n+    return res;\n+  }\n+\n+  RegionInfo *GetRegionInfo(uptr class_id) {\n+    CHECK_LT(class_id, kNumClasses);\n+    RegionInfo *regions = reinterpret_cast<RegionInfo*>(kSpaceBeg + kSpaceSize);\n+    return &regions[class_id];\n+  }\n+\n+  static uptr GetChunkIdx(uptr chunk, uptr size) {\n+    u32 offset = chunk % kRegionSize;\n+    // Here we divide by a non-constant. This is costly.\n+    // We require that kRegionSize is at least 2^32 so that offset is 32-bit.\n+    // We save 2x by using 32-bit div, but may need to use a 256-way switch.\n+    return offset / (u32)size;\n+  }\n+\n+  void PopulateFreeList(uptr class_id, RegionInfo *region) {\n+    uptr size = SizeClassMap::Size(class_id);\n+    uptr beg_idx = region->allocated_user;\n+    uptr end_idx = beg_idx + kPopulateSize;\n+    region->free_list.clear();\n+    uptr region_beg = kSpaceBeg + kRegionSize * class_id;\n+    uptr idx = beg_idx;\n+    uptr i = 0;\n+    do {  // do-while loop because we need to put at least one item.\n+      uptr p = region_beg + idx;\n+      region->free_list.push_front(reinterpret_cast<AllocatorListNode*>(p));\n+      idx += size;\n+      i++;\n+    } while (idx < end_idx);\n+    region->allocated_user += idx - beg_idx;\n+    region->allocated_meta += i * kMetadataSize;\n+    CHECK_LT(region->allocated_user + region->allocated_meta, kRegionSize);\n+  }\n+\n+  void *AllocateBySizeClass(uptr class_id) {\n+    CHECK_LT(class_id, kNumClasses);\n+    RegionInfo *region = GetRegionInfo(class_id);\n+    SpinMutexLock l(&region->mutex);\n+    if (region->free_list.empty()) {\n+      PopulateFreeList(class_id, region);\n+    }\n+    CHECK(!region->free_list.empty());\n+    AllocatorListNode *node = region->free_list.front();\n+    region->free_list.pop_front();\n+    return reinterpret_cast<void*>(node);\n+  }\n+\n+  void DeallocateBySizeClass(void *p, uptr class_id) {\n+    RegionInfo *region = GetRegionInfo(class_id);\n+    SpinMutexLock l(&region->mutex);\n+    region->free_list.push_front(reinterpret_cast<AllocatorListNode*>(p));\n+  }\n+};\n+\n+// Objects of this type should be used as local caches for SizeClassAllocator64.\n+// Since the typical use of this class is to have one object per thread in TLS,\n+// is has to be POD.\n+template<const uptr kNumClasses, class SizeClassAllocator>\n+struct SizeClassAllocatorLocalCache {\n+  // Don't need to call Init if the object is a global (i.e. zero-initialized).\n+  void Init() {\n+    internal_memset(this, 0, sizeof(*this));\n+  }\n+\n+  void *Allocate(SizeClassAllocator *allocator, uptr class_id) {\n+    CHECK_LT(class_id, kNumClasses);\n+    AllocatorFreeList *free_list = &free_lists_[class_id];\n+    if (free_list->empty())\n+      allocator->BulkAllocate(class_id, free_list);\n+    CHECK(!free_list->empty());\n+    void *res = free_list->front();\n+    free_list->pop_front();\n+    return res;\n+  }\n+\n+  void Deallocate(SizeClassAllocator *allocator, uptr class_id, void *p) {\n+    CHECK_LT(class_id, kNumClasses);\n+    AllocatorFreeList *free_list = &free_lists_[class_id];\n+    free_list->push_front(reinterpret_cast<AllocatorListNode*>(p));\n+    if (free_list->size() >= 2 * SizeClassMap::MaxCached(class_id))\n+      DrainHalf(allocator, class_id);\n+  }\n+\n+  void Drain(SizeClassAllocator *allocator) {\n+    for (uptr i = 0; i < kNumClasses; i++) {\n+      allocator->BulkDeallocate(i, &free_lists_[i]);\n+      CHECK(free_lists_[i].empty());\n+    }\n+  }\n+\n+  // private:\n+  typedef typename SizeClassAllocator::SizeClassMapT SizeClassMap;\n+  AllocatorFreeList free_lists_[kNumClasses];\n+\n+  void DrainHalf(SizeClassAllocator *allocator, uptr class_id) {\n+    AllocatorFreeList *free_list = &free_lists_[class_id];\n+    AllocatorFreeList half;\n+    half.clear();\n+    const uptr count = free_list->size() / 2;\n+    for (uptr i = 0; i < count; i++) {\n+      AllocatorListNode *node = free_list->front();\n+      free_list->pop_front();\n+      half.push_front(node);\n+    }\n+    allocator->BulkDeallocate(class_id, &half);\n+  }\n+};\n+\n+// This class can (de)allocate only large chunks of memory using mmap/unmap.\n+// The main purpose of this allocator is to cover large and rare allocation\n+// sizes not covered by more efficient allocators (e.g. SizeClassAllocator64).\n+class LargeMmapAllocator {\n+ public:\n+  void Init() {\n+    internal_memset(this, 0, sizeof(*this));\n+  }\n+  void *Allocate(uptr size, uptr alignment) {\n+    CHECK(IsPowerOfTwo(alignment));\n+    uptr map_size = RoundUpMapSize(size);\n+    if (alignment > kPageSize)\n+      map_size += alignment;\n+    if (map_size < size) return 0;  // Overflow.\n+    uptr map_beg = reinterpret_cast<uptr>(\n+        MmapOrDie(map_size, \"LargeMmapAllocator\"));\n+    uptr map_end = map_beg + map_size;\n+    uptr res = map_beg + kPageSize;\n+    if (res & (alignment - 1))  // Align.\n+      res += alignment - (res & (alignment - 1));\n+    CHECK_EQ(0, res & (alignment - 1));\n+    CHECK_LE(res + size, map_end);\n+    Header *h = GetHeader(res);\n+    h->size = size;\n+    h->map_beg = map_beg;\n+    h->map_size = map_size;\n+    {\n+      SpinMutexLock l(&mutex_);\n+      h->next = list_;\n+      h->prev = 0;\n+      if (list_)\n+        list_->prev = h;\n+      list_ = h;\n+    }\n+    return reinterpret_cast<void*>(res);\n+  }\n+\n+  void Deallocate(void *p) {\n+    Header *h = GetHeader(p);\n+    {\n+      SpinMutexLock l(&mutex_);\n+      Header *prev = h->prev;\n+      Header *next = h->next;\n+      if (prev)\n+        prev->next = next;\n+      if (next)\n+        next->prev = prev;\n+      if (h == list_)\n+        list_ = next;\n+    }\n+    UnmapOrDie(reinterpret_cast<void*>(h->map_beg), h->map_size);\n+  }\n+\n+  uptr TotalMemoryUsed() {\n+    SpinMutexLock l(&mutex_);\n+    uptr res = 0;\n+    for (Header *l = list_; l; l = l->next) {\n+      res += RoundUpMapSize(l->size);\n+    }\n+    return res;\n+  }\n+\n+  bool PointerIsMine(void *p) {\n+    // Fast check.\n+    if ((reinterpret_cast<uptr>(p) % kPageSize) != 0) return false;\n+    SpinMutexLock l(&mutex_);\n+    for (Header *l = list_; l; l = l->next) {\n+      if (GetUser(l) == p) return true;\n+    }\n+    return false;\n+  }\n+\n+  uptr GetActuallyAllocatedSize(void *p) {\n+    return RoundUpMapSize(GetHeader(p)->size) - kPageSize;\n+  }\n+\n+  // At least kPageSize/2 metadata bytes is available.\n+  void *GetMetaData(void *p) {\n+    return GetHeader(p) + 1;\n+  }\n+\n+  void *GetBlockBegin(void *p) {\n+    SpinMutexLock l(&mutex_);\n+    for (Header *l = list_; l; l = l->next) {\n+      void *b = GetUser(l);\n+      if (p >= b && p < (u8*)b + l->size)\n+        return b;\n+    }\n+    return 0;\n+  }\n+\n+ private:\n+  struct Header {\n+    uptr map_beg;\n+    uptr map_size;\n+    uptr size;\n+    Header *next;\n+    Header *prev;\n+  };\n+\n+  Header *GetHeader(uptr p) { return reinterpret_cast<Header*>(p - kPageSize); }\n+  Header *GetHeader(void *p) { return GetHeader(reinterpret_cast<uptr>(p)); }\n+\n+  void *GetUser(Header *h) {\n+    return reinterpret_cast<void*>(reinterpret_cast<uptr>(h) + kPageSize);\n+  }\n+\n+  uptr RoundUpMapSize(uptr size) {\n+    return RoundUpTo(size, kPageSize) + kPageSize;\n+  }\n+\n+  Header *list_;\n+  SpinMutex mutex_;\n+};\n+\n+// This class implements a complete memory allocator by using two\n+// internal allocators:\n+// PrimaryAllocator is efficient, but may not allocate some sizes (alignments).\n+//  When allocating 2^x bytes it should return 2^x aligned chunk.\n+// PrimaryAllocator is used via a local AllocatorCache.\n+// SecondaryAllocator can allocate anything, but is not efficient.\n+template <class PrimaryAllocator, class AllocatorCache,\n+          class SecondaryAllocator>  // NOLINT\n+class CombinedAllocator {\n+ public:\n+  void Init() {\n+    primary_.Init();\n+    secondary_.Init();\n+  }\n+\n+  void *Allocate(AllocatorCache *cache, uptr size, uptr alignment,\n+                 bool cleared = false) {\n+    // Returning 0 on malloc(0) may break a lot of code.\n+    if (size == 0)\n+      size = 1;\n+    if (size + alignment < size)\n+      return 0;\n+    if (alignment > 8)\n+      size = RoundUpTo(size, alignment);\n+    void *res;\n+    if (primary_.CanAllocate(size, alignment))\n+      res = cache->Allocate(&primary_, primary_.ClassID(size));\n+    else\n+      res = secondary_.Allocate(size, alignment);\n+    if (alignment > 8)\n+      CHECK_EQ(reinterpret_cast<uptr>(res) & (alignment - 1), 0);\n+    if (cleared && res)\n+      internal_memset(res, 0, size);\n+    return res;\n+  }\n+\n+  void Deallocate(AllocatorCache *cache, void *p) {\n+    if (!p) return;\n+    if (primary_.PointerIsMine(p))\n+      cache->Deallocate(&primary_, primary_.GetSizeClass(p), p);\n+    else\n+      secondary_.Deallocate(p);\n+  }\n+\n+  void *Reallocate(AllocatorCache *cache, void *p, uptr new_size,\n+                   uptr alignment) {\n+    if (!p)\n+      return Allocate(cache, new_size, alignment);\n+    if (!new_size) {\n+      Deallocate(cache, p);\n+      return 0;\n+    }\n+    CHECK(PointerIsMine(p));\n+    uptr old_size = GetActuallyAllocatedSize(p);\n+    uptr memcpy_size = Min(new_size, old_size);\n+    void *new_p = Allocate(cache, new_size, alignment);\n+    if (new_p)\n+      internal_memcpy(new_p, p, memcpy_size);\n+    Deallocate(cache, p);\n+    return new_p;\n+  }\n+\n+  bool PointerIsMine(void *p) {\n+    if (primary_.PointerIsMine(p))\n+      return true;\n+    return secondary_.PointerIsMine(p);\n+  }\n+\n+  void *GetMetaData(void *p) {\n+    if (primary_.PointerIsMine(p))\n+      return primary_.GetMetaData(p);\n+    return secondary_.GetMetaData(p);\n+  }\n+\n+  void *GetBlockBegin(void *p) {\n+    if (primary_.PointerIsMine(p))\n+      return primary_.GetBlockBegin(p);\n+    return secondary_.GetBlockBegin(p);\n+  }\n+\n+  uptr GetActuallyAllocatedSize(void *p) {\n+    if (primary_.PointerIsMine(p))\n+      return primary_.GetActuallyAllocatedSize(p);\n+    return secondary_.GetActuallyAllocatedSize(p);\n+  }\n+\n+  uptr TotalMemoryUsed() {\n+    return primary_.TotalMemoryUsed() + secondary_.TotalMemoryUsed();\n+  }\n+\n+  void TestOnlyUnmap() { primary_.TestOnlyUnmap(); }\n+\n+  void SwallowCache(AllocatorCache *cache) {\n+    cache->Drain(&primary_);\n+  }\n+\n+ private:\n+  PrimaryAllocator primary_;\n+  SecondaryAllocator secondary_;\n+};\n+\n+}  // namespace __sanitizer\n+\n+#endif  // SANITIZER_ALLOCATOR_H"}, {"sha": "f2bf23588a448da04ab9cba2d164a8a59385d4fb", "filename": "libsanitizer/sanitizer_common/sanitizer_atomic.h", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic.h?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,63 @@\n+//===-- sanitizer_atomic.h --------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer/AddressSanitizer runtime.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef SANITIZER_ATOMIC_H\n+#define SANITIZER_ATOMIC_H\n+\n+#include \"sanitizer_internal_defs.h\"\n+\n+namespace __sanitizer {\n+\n+enum memory_order {\n+  memory_order_relaxed = 1 << 0,\n+  memory_order_consume = 1 << 1,\n+  memory_order_acquire = 1 << 2,\n+  memory_order_release = 1 << 3,\n+  memory_order_acq_rel = 1 << 4,\n+  memory_order_seq_cst = 1 << 5\n+};\n+\n+struct atomic_uint8_t {\n+  typedef u8 Type;\n+  volatile Type val_dont_use;\n+};\n+\n+struct atomic_uint16_t {\n+  typedef u16 Type;\n+  volatile Type val_dont_use;\n+};\n+\n+struct atomic_uint32_t {\n+  typedef u32 Type;\n+  volatile Type val_dont_use;\n+};\n+\n+struct atomic_uint64_t {\n+  typedef u64 Type;\n+  volatile Type val_dont_use;\n+};\n+\n+struct atomic_uintptr_t {\n+  typedef uptr Type;\n+  volatile Type val_dont_use;\n+};\n+\n+}  // namespace __sanitizer\n+\n+#if defined(__GNUC__)\n+# include \"sanitizer_atomic_clang.h\"\n+#elif defined(_MSC_VER)\n+# include \"sanitizer_atomic_msvc.h\"\n+#else\n+# error \"Unsupported compiler\"\n+#endif\n+\n+#endif  // SANITIZER_ATOMIC_H"}, {"sha": "68e79f6a2f1a90f8132a4572dc5644448cd2fb6f", "filename": "libsanitizer/sanitizer_common/sanitizer_atomic_clang.h", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang.h?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,120 @@\n+//===-- sanitizer_atomic_clang.h --------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer/AddressSanitizer runtime.\n+// Not intended for direct inclusion. Include sanitizer_atomic.h.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef SANITIZER_ATOMIC_CLANG_H\n+#define SANITIZER_ATOMIC_CLANG_H\n+\n+namespace __sanitizer {\n+\n+INLINE void atomic_signal_fence(memory_order) {\n+  __asm__ __volatile__(\"\" ::: \"memory\");\n+}\n+\n+INLINE void atomic_thread_fence(memory_order) {\n+  __sync_synchronize();\n+}\n+\n+INLINE void proc_yield(int cnt) {\n+  __asm__ __volatile__(\"\" ::: \"memory\");\n+#if defined(__i386__) || defined(__x86_64__)\n+  for (int i = 0; i < cnt; i++)\n+    __asm__ __volatile__(\"pause\");\n+#endif\n+  __asm__ __volatile__(\"\" ::: \"memory\");\n+}\n+\n+template<typename T>\n+INLINE typename T::Type atomic_load(\n+    const volatile T *a, memory_order mo) {\n+  DCHECK(mo & (memory_order_relaxed | memory_order_consume\n+      | memory_order_acquire | memory_order_seq_cst));\n+  DCHECK(!((uptr)a % sizeof(*a)));\n+  typename T::Type v;\n+  if (mo == memory_order_relaxed) {\n+    v = a->val_dont_use;\n+  } else {\n+    atomic_signal_fence(memory_order_seq_cst);\n+    v = a->val_dont_use;\n+    atomic_signal_fence(memory_order_seq_cst);\n+  }\n+  return v;\n+}\n+\n+template<typename T>\n+INLINE void atomic_store(volatile T *a, typename T::Type v, memory_order mo) {\n+  DCHECK(mo & (memory_order_relaxed | memory_order_release\n+      | memory_order_seq_cst));\n+  DCHECK(!((uptr)a % sizeof(*a)));\n+  if (mo == memory_order_relaxed) {\n+    a->val_dont_use = v;\n+  } else {\n+    atomic_signal_fence(memory_order_seq_cst);\n+    a->val_dont_use = v;\n+    atomic_signal_fence(memory_order_seq_cst);\n+  }\n+  if (mo == memory_order_seq_cst)\n+    atomic_thread_fence(memory_order_seq_cst);\n+}\n+\n+template<typename T>\n+INLINE typename T::Type atomic_fetch_add(volatile T *a,\n+    typename T::Type v, memory_order mo) {\n+  (void)mo;\n+  DCHECK(!((uptr)a % sizeof(*a)));\n+  return __sync_fetch_and_add(&a->val_dont_use, v);\n+}\n+\n+template<typename T>\n+INLINE typename T::Type atomic_fetch_sub(volatile T *a,\n+    typename T::Type v, memory_order mo) {\n+  (void)mo;\n+  DCHECK(!((uptr)a % sizeof(*a)));\n+  return __sync_fetch_and_add(&a->val_dont_use, -v);\n+}\n+\n+template<typename T>\n+INLINE typename T::Type atomic_exchange(volatile T *a,\n+    typename T::Type v, memory_order mo) {\n+  DCHECK(!((uptr)a % sizeof(*a)));\n+  if (mo & (memory_order_release | memory_order_acq_rel | memory_order_seq_cst))\n+    __sync_synchronize();\n+  v = __sync_lock_test_and_set(&a->val_dont_use, v);\n+  if (mo == memory_order_seq_cst)\n+    __sync_synchronize();\n+  return v;\n+}\n+\n+template<typename T>\n+INLINE bool atomic_compare_exchange_strong(volatile T *a,\n+                                           typename T::Type *cmp,\n+                                           typename T::Type xchg,\n+                                           memory_order mo) {\n+  typedef typename T::Type Type;\n+  Type cmpv = *cmp;\n+  Type prev = __sync_val_compare_and_swap(&a->val_dont_use, cmpv, xchg);\n+  if (prev == cmpv)\n+    return true;\n+  *cmp = prev;\n+  return false;\n+}\n+\n+template<typename T>\n+INLINE bool atomic_compare_exchange_weak(volatile T *a,\n+                                           typename T::Type *cmp,\n+                                           typename T::Type xchg,\n+                                           memory_order mo) {\n+  return atomic_compare_exchange_strong(a, cmp, xchg, mo);\n+}\n+\n+}  // namespace __sanitizer\n+\n+#endif  // SANITIZER_ATOMIC_CLANG_H"}, {"sha": "2c02baa954a41373168771e4701e2d5fadec93a5", "filename": "libsanitizer/sanitizer_common/sanitizer_atomic_msvc.h", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_msvc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_msvc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_msvc.h?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,134 @@\n+//===-- sanitizer_atomic_msvc.h ---------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer/AddressSanitizer runtime.\n+// Not intended for direct inclusion. Include sanitizer_atomic.h.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef SANITIZER_ATOMIC_MSVC_H\n+#define SANITIZER_ATOMIC_MSVC_H\n+\n+extern \"C\" void _ReadWriteBarrier();\n+#pragma intrinsic(_ReadWriteBarrier)\n+extern \"C\" void _mm_mfence();\n+#pragma intrinsic(_mm_mfence)\n+extern \"C\" void _mm_pause();\n+#pragma intrinsic(_mm_pause)\n+extern \"C\" long _InterlockedExchangeAdd(  // NOLINT\n+    long volatile * Addend, long Value);  // NOLINT\n+#pragma intrinsic(_InterlockedExchangeAdd)\n+extern \"C\" void *InterlockedCompareExchangePointer(\n+    void *volatile *Destination,\n+    void *Exchange, void *Comparand);\n+\n+namespace __sanitizer {\n+\n+INLINE void atomic_signal_fence(memory_order) {\n+  _ReadWriteBarrier();\n+}\n+\n+INLINE void atomic_thread_fence(memory_order) {\n+  _mm_mfence();\n+}\n+\n+INLINE void proc_yield(int cnt) {\n+  for (int i = 0; i < cnt; i++)\n+    _mm_pause();\n+}\n+\n+template<typename T>\n+INLINE typename T::Type atomic_load(\n+    const volatile T *a, memory_order mo) {\n+  DCHECK(mo & (memory_order_relaxed | memory_order_consume\n+      | memory_order_acquire | memory_order_seq_cst));\n+  DCHECK(!((uptr)a % sizeof(*a)));\n+  typename T::Type v;\n+  if (mo == memory_order_relaxed) {\n+    v = a->val_dont_use;\n+  } else {\n+    atomic_signal_fence(memory_order_seq_cst);\n+    v = a->val_dont_use;\n+    atomic_signal_fence(memory_order_seq_cst);\n+  }\n+  return v;\n+}\n+\n+template<typename T>\n+INLINE void atomic_store(volatile T *a, typename T::Type v, memory_order mo) {\n+  DCHECK(mo & (memory_order_relaxed | memory_order_release\n+      | memory_order_seq_cst));\n+  DCHECK(!((uptr)a % sizeof(*a)));\n+  if (mo == memory_order_relaxed) {\n+    a->val_dont_use = v;\n+  } else {\n+    atomic_signal_fence(memory_order_seq_cst);\n+    a->val_dont_use = v;\n+    atomic_signal_fence(memory_order_seq_cst);\n+  }\n+  if (mo == memory_order_seq_cst)\n+    atomic_thread_fence(memory_order_seq_cst);\n+}\n+\n+INLINE u32 atomic_fetch_add(volatile atomic_uint32_t *a,\n+    u32 v, memory_order mo) {\n+  (void)mo;\n+  DCHECK(!((uptr)a % sizeof(*a)));\n+  return (u32)_InterlockedExchangeAdd(\n+      (volatile long*)&a->val_dont_use, (long)v);  // NOLINT\n+}\n+\n+INLINE u8 atomic_exchange(volatile atomic_uint8_t *a,\n+    u8 v, memory_order mo) {\n+  (void)mo;\n+  DCHECK(!((uptr)a % sizeof(*a)));\n+  __asm {\n+    mov eax, a\n+    mov cl, v\n+    xchg [eax], cl  // NOLINT\n+    mov v, cl\n+  }\n+  return v;\n+}\n+\n+INLINE u16 atomic_exchange(volatile atomic_uint16_t *a,\n+    u16 v, memory_order mo) {\n+  (void)mo;\n+  DCHECK(!((uptr)a % sizeof(*a)));\n+  __asm {\n+    mov eax, a\n+    mov cx, v\n+    xchg [eax], cx  // NOLINT\n+    mov v, cx\n+  }\n+  return v;\n+}\n+\n+INLINE bool atomic_compare_exchange_strong(volatile atomic_uintptr_t *a,\n+                                           uptr *cmp,\n+                                           uptr xchg,\n+                                           memory_order mo) {\n+  uptr cmpv = *cmp;\n+  uptr prev = (uptr)InterlockedCompareExchangePointer(\n+      (void*volatile*)&a->val_dont_use, (void*)xchg, (void*)cmpv);\n+  if (prev == cmpv)\n+    return true;\n+  *cmp = prev;\n+  return false;\n+}\n+\n+template<typename T>\n+INLINE bool atomic_compare_exchange_weak(volatile T *a,\n+                                           typename T::Type *cmp,\n+                                           typename T::Type xchg,\n+                                           memory_order mo) {\n+  return atomic_compare_exchange_strong(a, cmp, xchg, mo);\n+}\n+\n+}  // namespace __sanitizer\n+\n+#endif  // SANITIZER_ATOMIC_CLANG_H"}, {"sha": "43ef980e846f74fd19eff32050da33cb78200133", "filename": "libsanitizer/sanitizer_common/sanitizer_common.cc", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cc?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,151 @@\n+//===-- sanitizer_common.cc -----------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is shared between AddressSanitizer and ThreadSanitizer\n+// run-time libraries.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_common.h\"\n+#include \"sanitizer_libc.h\"\n+\n+namespace __sanitizer {\n+\n+static fd_t report_fd = 2;  // By default, dump to stderr.\n+static char report_path[4096];  // Set via __sanitizer_set_report_path.\n+\n+static void (*DieCallback)(void);\n+void SetDieCallback(void (*callback)(void)) {\n+  DieCallback = callback;\n+}\n+\n+void NORETURN Die() {\n+  if (DieCallback) {\n+    DieCallback();\n+  }\n+  Exit(1);\n+}\n+\n+static CheckFailedCallbackType CheckFailedCallback;\n+void SetCheckFailedCallback(CheckFailedCallbackType callback) {\n+  CheckFailedCallback = callback;\n+}\n+\n+void NORETURN CheckFailed(const char *file, int line, const char *cond,\n+                          u64 v1, u64 v2) {\n+  if (CheckFailedCallback) {\n+    CheckFailedCallback(file, line, cond, v1, v2);\n+  }\n+  Report(\"Sanitizer CHECK failed: %s:%d %s (%zd, %zd)\\n\", file, line, cond,\n+                                                          v1, v2);\n+  Die();\n+}\n+\n+void RawWrite(const char *buffer) {\n+  static const char *kRawWriteError = \"RawWrite can't output requested buffer!\";\n+  uptr length = (uptr)internal_strlen(buffer);\n+  if (report_fd == kInvalidFd) {\n+    fd_t fd = internal_open(report_path, true);\n+    if (fd == kInvalidFd) {\n+      report_fd = 2;\n+      Report(\"ERROR: Can't open file: %s\\n\", report_path);\n+      Die();\n+    }\n+    report_fd = fd;\n+  }\n+  if (length != internal_write(report_fd, buffer, length)) {\n+    internal_write(report_fd, kRawWriteError, internal_strlen(kRawWriteError));\n+    Die();\n+  }\n+}\n+\n+uptr ReadFileToBuffer(const char *file_name, char **buff,\n+                      uptr *buff_size, uptr max_len) {\n+  const uptr kMinFileLen = kPageSize;\n+  uptr read_len = 0;\n+  *buff = 0;\n+  *buff_size = 0;\n+  // The files we usually open are not seekable, so try different buffer sizes.\n+  for (uptr size = kMinFileLen; size <= max_len; size *= 2) {\n+    fd_t fd = internal_open(file_name, /*write*/ false);\n+    if (fd == kInvalidFd) return 0;\n+    UnmapOrDie(*buff, *buff_size);\n+    *buff = (char*)MmapOrDie(size, __FUNCTION__);\n+    *buff_size = size;\n+    // Read up to one page at a time.\n+    read_len = 0;\n+    bool reached_eof = false;\n+    while (read_len + kPageSize <= size) {\n+      uptr just_read = internal_read(fd, *buff + read_len, kPageSize);\n+      if (just_read == 0) {\n+        reached_eof = true;\n+        break;\n+      }\n+      read_len += just_read;\n+    }\n+    internal_close(fd);\n+    if (reached_eof)  // We've read the whole file.\n+      break;\n+  }\n+  return read_len;\n+}\n+\n+// We don't want to use std::sort to avoid including <algorithm>, as\n+// we may end up with two implementation of std::sort - one in instrumented\n+// code, and the other in runtime.\n+// qsort() from stdlib won't work as it calls malloc(), which results\n+// in deadlock in ASan allocator.\n+// We re-implement in-place sorting w/o recursion as straightforward heapsort.\n+void SortArray(uptr *array, uptr size) {\n+  if (size < 2)\n+    return;\n+  // Stage 1: insert elements to the heap.\n+  for (uptr i = 1; i < size; i++) {\n+    uptr j, p;\n+    for (j = i; j > 0; j = p) {\n+      p = (j - 1) / 2;\n+      if (array[j] > array[p])\n+        Swap(array[j], array[p]);\n+      else\n+        break;\n+    }\n+  }\n+  // Stage 2: swap largest element with the last one,\n+  // and sink the new top.\n+  for (uptr i = size - 1; i > 0; i--) {\n+    Swap(array[0], array[i]);\n+    uptr j, max_ind;\n+    for (j = 0; j < i; j = max_ind) {\n+      uptr left = 2 * j + 1;\n+      uptr right = 2 * j + 2;\n+      max_ind = j;\n+      if (left < i && array[left] > array[max_ind])\n+        max_ind = left;\n+      if (right < i && array[right] > array[max_ind])\n+        max_ind = right;\n+      if (max_ind != j)\n+        Swap(array[j], array[max_ind]);\n+      else\n+        break;\n+    }\n+  }\n+}\n+\n+}  // namespace __sanitizer\n+\n+void __sanitizer_set_report_path(const char *path) {\n+  if (!path) return;\n+  uptr len = internal_strlen(path);\n+  if (len > sizeof(__sanitizer::report_path) - 100) {\n+    Report(\"ERROR: Path is too long: %c%c%c%c%c%c%c%c...\\n\",\n+           path[0], path[1], path[2], path[3],\n+           path[4], path[5], path[6], path[7]);\n+    Die();\n+  }\n+  internal_snprintf(__sanitizer::report_path,\n+                    sizeof(__sanitizer::report_path), \"%s.%d\", path, GetPid());\n+  __sanitizer::report_fd = kInvalidFd;\n+}"}, {"sha": "cddefd7ea090036e53539b134ace52081090df26", "filename": "libsanitizer/sanitizer_common/sanitizer_common.h", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,181 @@\n+//===-- sanitizer_common.h --------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is shared between AddressSanitizer and ThreadSanitizer\n+// run-time libraries.\n+// It declares common functions and classes that are used in both runtimes.\n+// Implementation of some functions are provided in sanitizer_common, while\n+// others must be defined by run-time library itself.\n+//===----------------------------------------------------------------------===//\n+#ifndef SANITIZER_COMMON_H\n+#define SANITIZER_COMMON_H\n+\n+#include \"sanitizer_internal_defs.h\"\n+\n+namespace __sanitizer {\n+\n+// Constants.\n+const uptr kWordSize = __WORDSIZE / 8;\n+const uptr kWordSizeInBits = 8 * kWordSize;\n+const uptr kPageSizeBits = 12;\n+const uptr kPageSize = 1UL << kPageSizeBits;\n+const uptr kCacheLineSize = 64;\n+#ifndef _WIN32\n+const uptr kMmapGranularity = kPageSize;\n+#else\n+const uptr kMmapGranularity = 1UL << 16;\n+#endif\n+\n+// Threads\n+int GetPid();\n+uptr GetTid();\n+uptr GetThreadSelf();\n+void GetThreadStackTopAndBottom(bool at_initialization, uptr *stack_top,\n+                                uptr *stack_bottom);\n+\n+// Memory management\n+void *MmapOrDie(uptr size, const char *mem_type);\n+void UnmapOrDie(void *addr, uptr size);\n+void *MmapFixedNoReserve(uptr fixed_addr, uptr size);\n+void *Mprotect(uptr fixed_addr, uptr size);\n+// Used to check if we can map shadow memory to a fixed location.\n+bool MemoryRangeIsAvailable(uptr range_start, uptr range_end);\n+\n+// Internal allocator\n+void *InternalAlloc(uptr size);\n+void InternalFree(void *p);\n+// Given the pointer p into a valid allocated block,\n+// returns a pointer to the beginning of the block.\n+void *InternalAllocBlock(void *p);\n+\n+// InternalScopedBuffer can be used instead of large stack arrays to\n+// keep frame size low.\n+// FIXME: use InternalAlloc instead of MmapOrDie once\n+// InternalAlloc is made libc-free.\n+template<typename T>\n+class InternalScopedBuffer {\n+ public:\n+  explicit InternalScopedBuffer(uptr cnt) {\n+    cnt_ = cnt;\n+    ptr_ = (T*)MmapOrDie(cnt * sizeof(T), \"InternalScopedBuffer\");\n+  }\n+  ~InternalScopedBuffer() {\n+    UnmapOrDie(ptr_, cnt_ * sizeof(T));\n+  }\n+  T &operator[](uptr i) { return ptr_[i]; }\n+  T *data() { return ptr_; }\n+  uptr size() { return cnt_ * sizeof(T); }\n+\n+ private:\n+  T *ptr_;\n+  uptr cnt_;\n+  // Disallow evil constructors.\n+  InternalScopedBuffer(const InternalScopedBuffer&);\n+  void operator=(const InternalScopedBuffer&);\n+};\n+\n+// Simple low-level (mmap-based) allocator for internal use. Doesn't have\n+// constructor, so all instances of LowLevelAllocator should be\n+// linker initialized.\n+class LowLevelAllocator {\n+ public:\n+  // Requires an external lock.\n+  void *Allocate(uptr size);\n+ private:\n+  char *allocated_end_;\n+  char *allocated_current_;\n+};\n+typedef void (*LowLevelAllocateCallback)(uptr ptr, uptr size);\n+// Allows to register tool-specific callbacks for LowLevelAllocator.\n+// Passing NULL removes the callback.\n+void SetLowLevelAllocateCallback(LowLevelAllocateCallback callback);\n+\n+// IO\n+void RawWrite(const char *buffer);\n+void Printf(const char *format, ...);\n+void Report(const char *format, ...);\n+void SetPrintfAndReportCallback(void (*callback)(const char *));\n+\n+// Opens the file 'file_name\" and reads up to 'max_len' bytes.\n+// The resulting buffer is mmaped and stored in '*buff'.\n+// The size of the mmaped region is stored in '*buff_size',\n+// Returns the number of read bytes or 0 if file can not be opened.\n+uptr ReadFileToBuffer(const char *file_name, char **buff,\n+                      uptr *buff_size, uptr max_len);\n+// Maps given file to virtual memory, and returns pointer to it\n+// (or NULL if the mapping failes). Stores the size of mmaped region\n+// in '*buff_size'.\n+void *MapFileToMemory(const char *file_name, uptr *buff_size);\n+\n+// OS\n+void DisableCoreDumper();\n+void DumpProcessMap();\n+const char *GetEnv(const char *name);\n+const char *GetPwd();\n+void ReExec();\n+bool StackSizeIsUnlimited();\n+void SetStackSizeLimitInBytes(uptr limit);\n+\n+// Other\n+void SleepForSeconds(int seconds);\n+void SleepForMillis(int millis);\n+int Atexit(void (*function)(void));\n+void SortArray(uptr *array, uptr size);\n+\n+// Exit\n+void NORETURN Abort();\n+void NORETURN Exit(int exitcode);\n+void NORETURN Die();\n+void NORETURN SANITIZER_INTERFACE_ATTRIBUTE\n+CheckFailed(const char *file, int line, const char *cond, u64 v1, u64 v2);\n+\n+// Specific tools may override behavior of \"Die\" and \"CheckFailed\" functions\n+// to do tool-specific job.\n+void SetDieCallback(void (*callback)(void));\n+typedef void (*CheckFailedCallbackType)(const char *, int, const char *,\n+                                       u64, u64);\n+void SetCheckFailedCallback(CheckFailedCallbackType callback);\n+\n+// Math\n+INLINE bool IsPowerOfTwo(uptr x) {\n+  return (x & (x - 1)) == 0;\n+}\n+INLINE uptr RoundUpTo(uptr size, uptr boundary) {\n+  CHECK(IsPowerOfTwo(boundary));\n+  return (size + boundary - 1) & ~(boundary - 1);\n+}\n+// Don't use std::min, std::max or std::swap, to minimize dependency\n+// on libstdc++.\n+template<class T> T Min(T a, T b) { return a < b ? a : b; }\n+template<class T> T Max(T a, T b) { return a > b ? a : b; }\n+template<class T> void Swap(T& a, T& b) {\n+  T tmp = a;\n+  a = b;\n+  b = tmp;\n+}\n+\n+// Char handling\n+INLINE bool IsSpace(int c) {\n+  return (c == ' ') || (c == '\\n') || (c == '\\t') ||\n+         (c == '\\f') || (c == '\\r') || (c == '\\v');\n+}\n+INLINE bool IsDigit(int c) {\n+  return (c >= '0') && (c <= '9');\n+}\n+INLINE int ToLower(int c) {\n+  return (c >= 'A' && c <= 'Z') ? (c + 'a' - 'A') : c;\n+}\n+\n+#if __WORDSIZE == 64\n+# define FIRST_32_SECOND_64(a, b) (b)\n+#else\n+# define FIRST_32_SECOND_64(a, b) (a)\n+#endif\n+\n+}  // namespace __sanitizer\n+\n+#endif  // SANITIZER_COMMON_H"}, {"sha": "837738ceb81cceab0adf54534fb22be5267eb1ea", "filename": "libsanitizer/sanitizer_common/sanitizer_flags.cc", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.cc?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,95 @@\n+//===-- sanitizer_flags.cc ------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer/AddressSanitizer runtime.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_flags.h\"\n+\n+#include \"sanitizer_common.h\"\n+#include \"sanitizer_libc.h\"\n+\n+namespace __sanitizer {\n+\n+static bool GetFlagValue(const char *env, const char *name,\n+                         const char **value, int *value_length) {\n+  if (env == 0)\n+    return false;\n+  const char *pos = internal_strstr(env, name);\n+  const char *end;\n+  if (pos == 0)\n+    return false;\n+  pos += internal_strlen(name);\n+  if (pos[0] != '=') {\n+    end = pos;\n+  } else {\n+    pos += 1;\n+    if (pos[0] == '\"') {\n+      pos += 1;\n+      end = internal_strchr(pos, '\"');\n+    } else if (pos[0] == '\\'') {\n+      pos += 1;\n+      end = internal_strchr(pos, '\\'');\n+    } else {\n+      end = internal_strchr(pos, ' ');\n+    }\n+    if (end == 0)\n+      end = pos + internal_strlen(pos);\n+  }\n+  *value = pos;\n+  *value_length = end - pos;\n+  return true;\n+}\n+\n+static bool StartsWith(const char *flag, int flag_length, const char *value) {\n+  if (!flag || !value)\n+    return false;\n+  int value_length = internal_strlen(value);\n+  return (flag_length >= value_length) &&\n+         (0 == internal_strncmp(flag, value, value_length));\n+}\n+\n+void ParseFlag(const char *env, bool *flag, const char *name) {\n+  const char *value;\n+  int value_length;\n+  if (!GetFlagValue(env, name, &value, &value_length))\n+    return;\n+  if (StartsWith(value, value_length, \"0\") ||\n+      StartsWith(value, value_length, \"no\") ||\n+      StartsWith(value, value_length, \"false\"))\n+    *flag = false;\n+  if (StartsWith(value, value_length, \"1\") ||\n+      StartsWith(value, value_length, \"yes\") ||\n+      StartsWith(value, value_length, \"true\"))\n+    *flag = true;\n+}\n+\n+void ParseFlag(const char *env, int *flag, const char *name) {\n+  const char *value;\n+  int value_length;\n+  if (!GetFlagValue(env, name, &value, &value_length))\n+    return;\n+  *flag = internal_atoll(value);\n+}\n+\n+static LowLevelAllocator allocator_for_flags;\n+\n+void ParseFlag(const char *env, const char **flag, const char *name) {\n+  const char *value;\n+  int value_length;\n+  if (!GetFlagValue(env, name, &value, &value_length))\n+    return;\n+  // Copy the flag value. Don't use locks here, as flags are parsed at\n+  // tool startup.\n+  char *value_copy = (char*)(allocator_for_flags.Allocate(value_length + 1));\n+  internal_memcpy(value_copy, value, value_length);\n+  value_copy[value_length] = '\\0';\n+  *flag = value_copy;\n+}\n+\n+}  // namespace __sanitizer"}, {"sha": "1b9bf5bffdb29a674136f8b29c6184dddf45bb95", "filename": "libsanitizer/sanitizer_common/sanitizer_flags.h", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.h?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,25 @@\n+//===-- sanitizer_flags.h ---------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer/AddressSanitizer runtime.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef SANITIZER_FLAGS_H\n+#define SANITIZER_FLAGS_H\n+\n+#include \"sanitizer_internal_defs.h\"\n+\n+namespace __sanitizer {\n+\n+void ParseFlag(const char *env, bool *flag, const char *name);\n+void ParseFlag(const char *env, int *flag, const char *name);\n+void ParseFlag(const char *env, const char **flag, const char *name);\n+\n+}  // namespace __sanitizer\n+\n+#endif  // SANITIZER_FLAGS_H"}, {"sha": "da4d049e2c69e61304e5f59263b2704eb2dc8ba8", "filename": "libsanitizer/sanitizer_common/sanitizer_internal_defs.h", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,186 @@\n+//===-- sanitizer_internal_defs.h -------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is shared between AddressSanitizer and ThreadSanitizer.\n+// It contains macro used in run-time libraries code.\n+//===----------------------------------------------------------------------===//\n+#ifndef SANITIZER_DEFS_H\n+#define SANITIZER_DEFS_H\n+\n+#include \"sanitizer/common_interface_defs.h\"\n+using namespace __sanitizer;  // NOLINT\n+// ----------- ATTENTION -------------\n+// This header should NOT include any other headers to avoid portability issues.\n+\n+// Common defs.\n+#define INLINE static inline\n+#define INTERFACE_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n+#define WEAK SANITIZER_WEAK_ATTRIBUTE\n+\n+// Platform-specific defs.\n+#if defined(_WIN32)\n+typedef unsigned long    DWORD;  // NOLINT\n+# define ALWAYS_INLINE __declspec(forceinline)\n+// FIXME(timurrrr): do we need this on Windows?\n+# define ALIAS(x)\n+# define ALIGNED(x) __declspec(align(x))\n+# define FORMAT(f, a)\n+# define NOINLINE __declspec(noinline)\n+# define NORETURN __declspec(noreturn)\n+# define THREADLOCAL   __declspec(thread)\n+# define NOTHROW\n+#else  // _WIN32\n+# define ALWAYS_INLINE __attribute__((always_inline))\n+# define ALIAS(x) __attribute__((alias(x)))\n+# define ALIGNED(x) __attribute__((aligned(x)))\n+# define FORMAT(f, a)  __attribute__((format(printf, f, a)))\n+# define NOINLINE __attribute__((noinline))\n+# define NORETURN  __attribute__((noreturn))\n+# define THREADLOCAL   __thread\n+# ifdef __cplusplus\n+#   define NOTHROW throw()\n+# else\n+#   define NOTHROW __attribute__((__nothrow__))\n+#endif\n+#endif  // _WIN32\n+\n+// We have no equivalent of these on Windows.\n+#ifndef _WIN32\n+# define LIKELY(x)     __builtin_expect(!!(x), 1)\n+# define UNLIKELY(x)   __builtin_expect(!!(x), 0)\n+# define UNUSED __attribute__((unused))\n+# define USED __attribute__((used))\n+#endif\n+\n+#if defined(_WIN32)\n+typedef DWORD thread_return_t;\n+# define THREAD_CALLING_CONV __stdcall\n+#else  // _WIN32\n+typedef void* thread_return_t;\n+# define THREAD_CALLING_CONV\n+#endif  // _WIN32\n+typedef thread_return_t (THREAD_CALLING_CONV *thread_callback_t)(void* arg);\n+\n+// If __WORDSIZE was undefined by the platform, define it in terms of the\n+// compiler built-ins __LP64__ and _WIN64.\n+#ifndef __WORDSIZE\n+# if __LP64__ || defined(_WIN64)\n+#  define __WORDSIZE 64\n+# else\n+#  define __WORDSIZE 32\n+#  endif\n+#endif  // __WORDSIZE\n+\n+// NOTE: Functions below must be defined in each run-time.\n+namespace __sanitizer {\n+void NORETURN Die();\n+void NORETURN CheckFailed(const char *file, int line, const char *cond,\n+                          u64 v1, u64 v2);\n+}  // namespace __sanitizer\n+\n+// Check macro\n+#define RAW_CHECK_MSG(expr, msg) do { \\\n+  if (!(expr)) { \\\n+    RawWrite(msg); \\\n+    Die(); \\\n+  } \\\n+} while (0)\n+\n+#define RAW_CHECK(expr) RAW_CHECK_MSG(expr, #expr)\n+\n+#define CHECK_IMPL(c1, op, c2) \\\n+  do { \\\n+    __sanitizer::u64 v1 = (u64)(c1); \\\n+    __sanitizer::u64 v2 = (u64)(c2); \\\n+    if (!(v1 op v2)) \\\n+      __sanitizer::CheckFailed(__FILE__, __LINE__, \\\n+        \"(\" #c1 \") \" #op \" (\" #c2 \")\", v1, v2); \\\n+  } while (false) \\\n+/**/\n+\n+#define CHECK(a)       CHECK_IMPL((a), !=, 0)\n+#define CHECK_EQ(a, b) CHECK_IMPL((a), ==, (b))\n+#define CHECK_NE(a, b) CHECK_IMPL((a), !=, (b))\n+#define CHECK_LT(a, b) CHECK_IMPL((a), <,  (b))\n+#define CHECK_LE(a, b) CHECK_IMPL((a), <=, (b))\n+#define CHECK_GT(a, b) CHECK_IMPL((a), >,  (b))\n+#define CHECK_GE(a, b) CHECK_IMPL((a), >=, (b))\n+\n+#if TSAN_DEBUG\n+#define DCHECK(a)       CHECK(a)\n+#define DCHECK_EQ(a, b) CHECK_EQ(a, b)\n+#define DCHECK_NE(a, b) CHECK_NE(a, b)\n+#define DCHECK_LT(a, b) CHECK_LT(a, b)\n+#define DCHECK_LE(a, b) CHECK_LE(a, b)\n+#define DCHECK_GT(a, b) CHECK_GT(a, b)\n+#define DCHECK_GE(a, b) CHECK_GE(a, b)\n+#else\n+#define DCHECK(a)\n+#define DCHECK_EQ(a, b)\n+#define DCHECK_NE(a, b)\n+#define DCHECK_LT(a, b)\n+#define DCHECK_LE(a, b)\n+#define DCHECK_GT(a, b)\n+#define DCHECK_GE(a, b)\n+#endif\n+\n+#define UNIMPLEMENTED() CHECK(\"unimplemented\" && 0)\n+\n+#define COMPILER_CHECK(pred) IMPL_COMPILER_ASSERT(pred, __LINE__)\n+\n+#define ARRAY_SIZE(a) (sizeof(a)/sizeof((a)[0]))\n+\n+#define IMPL_PASTE(a, b) a##b\n+#define IMPL_COMPILER_ASSERT(pred, line) \\\n+    typedef char IMPL_PASTE(assertion_failed_##_, line)[2*(int)(pred)-1]\n+\n+// Limits for integral types. We have to redefine it in case we don't\n+// have stdint.h (like in Visual Studio 9).\n+#undef __INT64_C\n+#undef __UINT64_C\n+#if __WORDSIZE == 64\n+# define __INT64_C(c)  c ## L\n+# define __UINT64_C(c) c ## UL\n+#else\n+# define __INT64_C(c)  c ## LL\n+# define __UINT64_C(c) c ## ULL\n+#endif  // __WORDSIZE == 64\n+#undef INT32_MIN\n+#define INT32_MIN              (-2147483647-1)\n+#undef INT32_MAX\n+#define INT32_MAX              (2147483647)\n+#undef UINT32_MAX\n+#define UINT32_MAX             (4294967295U)\n+#undef INT64_MIN\n+#define INT64_MIN              (-__INT64_C(9223372036854775807)-1)\n+#undef INT64_MAX\n+#define INT64_MAX              (__INT64_C(9223372036854775807))\n+#undef UINT64_MAX\n+#define UINT64_MAX             (__UINT64_C(18446744073709551615))\n+\n+enum LinkerInitialized { LINKER_INITIALIZED = 0 };\n+\n+#if !defined(_MSC_VER) || defined(__clang__)\n+# define GET_CALLER_PC() (uptr)__builtin_return_address(0)\n+# define GET_CURRENT_FRAME() (uptr)__builtin_frame_address(0)\n+#else\n+extern \"C\" void* _ReturnAddress(void);\n+# pragma intrinsic(_ReturnAddress)\n+# define GET_CALLER_PC() (uptr)_ReturnAddress()\n+// CaptureStackBackTrace doesn't need to know BP on Windows.\n+// FIXME: This macro is still used when printing error reports though it's not\n+// clear if the BP value is needed in the ASan reports on Windows.\n+# define GET_CURRENT_FRAME() (uptr)0xDEADBEEF\n+#endif\n+\n+#define HANDLE_EINTR(res, f) {                               \\\n+  do {                                                                  \\\n+    res = (f);                                                         \\\n+  } while (res == -1 && errno == EINTR); \\\n+  }\n+\n+#endif  // SANITIZER_DEFS_H"}, {"sha": "21869bc4846fbe7356a192f8d5ee72a0a8b92207", "filename": "libsanitizer/sanitizer_common/sanitizer_libc.cc", "status": "added", "additions": 189, "deletions": 0, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.cc?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,189 @@\n+//===-- sanitizer_libc.cc -------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is shared between AddressSanitizer and ThreadSanitizer\n+// run-time libraries. See sanitizer_libc.h for details.\n+//===----------------------------------------------------------------------===//\n+#include \"sanitizer_common.h\"\n+#include \"sanitizer_libc.h\"\n+\n+namespace __sanitizer {\n+\n+s64 internal_atoll(const char *nptr) {\n+  return internal_simple_strtoll(nptr, (char**)0, 10);\n+}\n+\n+void *internal_memchr(const void *s, int c, uptr n) {\n+  const char* t = (char*)s;\n+  for (uptr i = 0; i < n; ++i, ++t)\n+    if (*t == c)\n+      return (void*)t;\n+  return 0;\n+}\n+\n+int internal_memcmp(const void* s1, const void* s2, uptr n) {\n+  const char* t1 = (char*)s1;\n+  const char* t2 = (char*)s2;\n+  for (uptr i = 0; i < n; ++i, ++t1, ++t2)\n+    if (*t1 != *t2)\n+      return *t1 < *t2 ? -1 : 1;\n+  return 0;\n+}\n+\n+void *internal_memcpy(void *dest, const void *src, uptr n) {\n+  char *d = (char*)dest;\n+  char *s = (char*)src;\n+  for (uptr i = 0; i < n; ++i)\n+    d[i] = s[i];\n+  return dest;\n+}\n+\n+void *internal_memset(void* s, int c, uptr n) {\n+  // The next line prevents Clang from making a call to memset() instead of the\n+  // loop below.\n+  // FIXME: building the runtime with -ffreestanding is a better idea. However\n+  // there currently are linktime problems due to PR12396.\n+  char volatile *t = (char*)s;\n+  for (uptr i = 0; i < n; ++i, ++t) {\n+    *t = c;\n+  }\n+  return s;\n+}\n+\n+uptr internal_strcspn(const char *s, const char *reject) {\n+  uptr i;\n+  for (i = 0; s[i]; i++) {\n+    if (internal_strchr(reject, s[i]) != 0)\n+      return i;\n+  }\n+  return i;\n+}\n+\n+char* internal_strdup(const char *s) {\n+  uptr len = internal_strlen(s);\n+  char *s2 = (char*)InternalAlloc(len + 1);\n+  internal_memcpy(s2, s, len);\n+  s2[len] = 0;\n+  return s2;\n+}\n+\n+int internal_strcmp(const char *s1, const char *s2) {\n+  while (true) {\n+    unsigned c1 = *s1;\n+    unsigned c2 = *s2;\n+    if (c1 != c2) return (c1 < c2) ? -1 : 1;\n+    if (c1 == 0) break;\n+    s1++;\n+    s2++;\n+  }\n+  return 0;\n+}\n+\n+int internal_strncmp(const char *s1, const char *s2, uptr n) {\n+  for (uptr i = 0; i < n; i++) {\n+    unsigned c1 = *s1;\n+    unsigned c2 = *s2;\n+    if (c1 != c2) return (c1 < c2) ? -1 : 1;\n+    if (c1 == 0) break;\n+    s1++;\n+    s2++;\n+  }\n+  return 0;\n+}\n+\n+char* internal_strchr(const char *s, int c) {\n+  while (true) {\n+    if (*s == (char)c)\n+      return (char*)s;\n+    if (*s == 0)\n+      return 0;\n+    s++;\n+  }\n+}\n+\n+char *internal_strrchr(const char *s, int c) {\n+  const char *res = 0;\n+  for (uptr i = 0; s[i]; i++) {\n+    if (s[i] == c) res = s + i;\n+  }\n+  return (char*)res;\n+}\n+\n+uptr internal_strlen(const char *s) {\n+  uptr i = 0;\n+  while (s[i]) i++;\n+  return i;\n+}\n+\n+char *internal_strncat(char *dst, const char *src, uptr n) {\n+  uptr len = internal_strlen(dst);\n+  uptr i;\n+  for (i = 0; i < n && src[i]; i++)\n+    dst[len + i] = src[i];\n+  dst[len + i] = 0;\n+  return dst;\n+}\n+\n+char *internal_strncpy(char *dst, const char *src, uptr n) {\n+  uptr i;\n+  for (i = 0; i < n && src[i]; i++)\n+    dst[i] = src[i];\n+  for (; i < n; i++)\n+    dst[i] = '\\0';\n+  return dst;\n+}\n+\n+uptr internal_strnlen(const char *s, uptr maxlen) {\n+  uptr i = 0;\n+  while (i < maxlen && s[i]) i++;\n+  return i;\n+}\n+\n+char *internal_strstr(const char *haystack, const char *needle) {\n+  // This is O(N^2), but we are not using it in hot places.\n+  uptr len1 = internal_strlen(haystack);\n+  uptr len2 = internal_strlen(needle);\n+  if (len1 < len2) return 0;\n+  for (uptr pos = 0; pos <= len1 - len2; pos++) {\n+    if (internal_memcmp(haystack + pos, needle, len2) == 0)\n+      return (char*)haystack + pos;\n+  }\n+  return 0;\n+}\n+\n+s64 internal_simple_strtoll(const char *nptr, char **endptr, int base) {\n+  CHECK_EQ(base, 10);\n+  while (IsSpace(*nptr)) nptr++;\n+  int sgn = 1;\n+  u64 res = 0;\n+  bool have_digits = false;\n+  char *old_nptr = (char*)nptr;\n+  if (*nptr == '+') {\n+    sgn = 1;\n+    nptr++;\n+  } else if (*nptr == '-') {\n+    sgn = -1;\n+    nptr++;\n+  }\n+  while (IsDigit(*nptr)) {\n+    res = (res <= UINT64_MAX / 10) ? res * 10 : UINT64_MAX;\n+    int digit = ((*nptr) - '0');\n+    res = (res <= UINT64_MAX - digit) ? res + digit : UINT64_MAX;\n+    have_digits = true;\n+    nptr++;\n+  }\n+  if (endptr != 0) {\n+    *endptr = (have_digits) ? (char*)nptr : old_nptr;\n+  }\n+  if (sgn > 0) {\n+    return (s64)(Min((u64)INT64_MAX, res));\n+  } else {\n+    return (res > INT64_MAX) ? INT64_MIN : ((s64)res * -1);\n+  }\n+}\n+\n+}  // namespace __sanitizer"}, {"sha": "135285111905aebcf23417a116bd4dabc75d14d8", "filename": "libsanitizer/sanitizer_common/sanitizer_libc.h", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.h?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,69 @@\n+//===-- sanitizer_libc.h ----------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is shared between AddressSanitizer and ThreadSanitizer\n+// run-time libraries.\n+// These tools can not use some of the libc functions directly because those\n+// functions are intercepted. Instead, we implement a tiny subset of libc here.\n+// NOTE: This file may be included into user code.\n+//===----------------------------------------------------------------------===//\n+#ifndef SANITIZER_LIBC_H\n+#define SANITIZER_LIBC_H\n+\n+// ----------- ATTENTION -------------\n+// This header should NOT include any other headers from sanitizer runtime.\n+#include \"sanitizer/common_interface_defs.h\"\n+\n+namespace __sanitizer {\n+\n+// internal_X() is a custom implementation of X() for use in RTL.\n+\n+// String functions\n+s64 internal_atoll(const char *nptr);\n+void *internal_memchr(const void *s, int c, uptr n);\n+int internal_memcmp(const void* s1, const void* s2, uptr n);\n+void *internal_memcpy(void *dest, const void *src, uptr n);\n+// Should not be used in performance-critical places.\n+void *internal_memset(void *s, int c, uptr n);\n+char* internal_strchr(const char *s, int c);\n+int internal_strcmp(const char *s1, const char *s2);\n+uptr internal_strcspn(const char *s, const char *reject);\n+char *internal_strdup(const char *s);\n+uptr internal_strlen(const char *s);\n+char *internal_strncat(char *dst, const char *src, uptr n);\n+int internal_strncmp(const char *s1, const char *s2, uptr n);\n+char *internal_strncpy(char *dst, const char *src, uptr n);\n+uptr internal_strnlen(const char *s, uptr maxlen);\n+char *internal_strrchr(const char *s, int c);\n+// This is O(N^2), but we are not using it in hot places.\n+char *internal_strstr(const char *haystack, const char *needle);\n+// Works only for base=10 and doesn't set errno.\n+s64 internal_simple_strtoll(const char *nptr, char **endptr, int base);\n+\n+// Memory\n+void *internal_mmap(void *addr, uptr length, int prot, int flags,\n+                    int fd, u64 offset);\n+int internal_munmap(void *addr, uptr length);\n+\n+// I/O\n+typedef int fd_t;\n+const fd_t kInvalidFd = -1;\n+int internal_close(fd_t fd);\n+fd_t internal_open(const char *filename, bool write);\n+uptr internal_read(fd_t fd, void *buf, uptr count);\n+uptr internal_write(fd_t fd, const void *buf, uptr count);\n+uptr internal_filesize(fd_t fd);  // -1 on error.\n+int internal_dup2(int oldfd, int newfd);\n+uptr internal_readlink(const char *path, char *buf, uptr bufsize);\n+int internal_snprintf(char *buffer, uptr length, const char *format, ...);\n+\n+// Threading\n+int internal_sched_yield();\n+\n+}  // namespace __sanitizer\n+\n+#endif  // SANITIZER_LIBC_H"}, {"sha": "ab6c5a4b82c4fa1f785306e5d03516a9895e8188", "filename": "libsanitizer/sanitizer_common/sanitizer_linux.cc", "status": "added", "additions": 296, "deletions": 0, "changes": 296, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cc?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,296 @@\n+//===-- sanitizer_linux.cc ------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is shared between AddressSanitizer and ThreadSanitizer\n+// run-time libraries and implements linux-specific functions from\n+// sanitizer_libc.h.\n+//===----------------------------------------------------------------------===//\n+#ifdef __linux__\n+\n+#include \"sanitizer_common.h\"\n+#include \"sanitizer_internal_defs.h\"\n+#include \"sanitizer_libc.h\"\n+#include \"sanitizer_placement_new.h\"\n+#include \"sanitizer_procmaps.h\"\n+\n+#include <fcntl.h>\n+#include <pthread.h>\n+#include <sched.h>\n+#include <sys/mman.h>\n+#include <sys/resource.h>\n+#include <sys/stat.h>\n+#include <sys/syscall.h>\n+#include <sys/time.h>\n+#include <sys/types.h>\n+#include <unistd.h>\n+#include <errno.h>\n+\n+namespace __sanitizer {\n+\n+// --------------- sanitizer_libc.h\n+void *internal_mmap(void *addr, uptr length, int prot, int flags,\n+                    int fd, u64 offset) {\n+#if __WORDSIZE == 64\n+  return (void *)syscall(__NR_mmap, addr, length, prot, flags, fd, offset);\n+#else\n+  return (void *)syscall(__NR_mmap2, addr, length, prot, flags, fd, offset);\n+#endif\n+}\n+\n+int internal_munmap(void *addr, uptr length) {\n+  return syscall(__NR_munmap, addr, length);\n+}\n+\n+int internal_close(fd_t fd) {\n+  return syscall(__NR_close, fd);\n+}\n+\n+fd_t internal_open(const char *filename, bool write) {\n+  return syscall(__NR_open, filename,\n+      write ? O_WRONLY | O_CREAT /*| O_CLOEXEC*/ : O_RDONLY, 0660);\n+}\n+\n+uptr internal_read(fd_t fd, void *buf, uptr count) {\n+  sptr res;\n+  HANDLE_EINTR(res, (sptr)syscall(__NR_read, fd, buf, count));\n+  return res;\n+}\n+\n+uptr internal_write(fd_t fd, const void *buf, uptr count) {\n+  sptr res;\n+  HANDLE_EINTR(res, (sptr)syscall(__NR_write, fd, buf, count));\n+  return res;\n+}\n+\n+uptr internal_filesize(fd_t fd) {\n+#if __WORDSIZE == 64\n+  struct stat st;\n+  if (syscall(__NR_fstat, fd, &st))\n+    return -1;\n+#else\n+  struct stat64 st;\n+  if (syscall(__NR_fstat64, fd, &st))\n+    return -1;\n+#endif\n+  return (uptr)st.st_size;\n+}\n+\n+int internal_dup2(int oldfd, int newfd) {\n+  return syscall(__NR_dup2, oldfd, newfd);\n+}\n+\n+uptr internal_readlink(const char *path, char *buf, uptr bufsize) {\n+  return (uptr)syscall(__NR_readlink, path, buf, bufsize);\n+}\n+\n+int internal_sched_yield() {\n+  return syscall(__NR_sched_yield);\n+}\n+\n+// ----------------- sanitizer_common.h\n+uptr GetTid() {\n+  return syscall(__NR_gettid);\n+}\n+\n+void GetThreadStackTopAndBottom(bool at_initialization, uptr *stack_top,\n+                                uptr *stack_bottom) {\n+  static const uptr kMaxThreadStackSize = 256 * (1 << 20);  // 256M\n+  CHECK(stack_top);\n+  CHECK(stack_bottom);\n+  if (at_initialization) {\n+    // This is the main thread. Libpthread may not be initialized yet.\n+    struct rlimit rl;\n+    CHECK_EQ(getrlimit(RLIMIT_STACK, &rl), 0);\n+\n+    // Find the mapping that contains a stack variable.\n+    MemoryMappingLayout proc_maps;\n+    uptr start, end, offset;\n+    uptr prev_end = 0;\n+    while (proc_maps.Next(&start, &end, &offset, 0, 0)) {\n+      if ((uptr)&rl < end)\n+        break;\n+      prev_end = end;\n+    }\n+    CHECK((uptr)&rl >= start && (uptr)&rl < end);\n+\n+    // Get stacksize from rlimit, but clip it so that it does not overlap\n+    // with other mappings.\n+    uptr stacksize = rl.rlim_cur;\n+    if (stacksize > end - prev_end)\n+      stacksize = end - prev_end;\n+    // When running with unlimited stack size, we still want to set some limit.\n+    // The unlimited stack size is caused by 'ulimit -s unlimited'.\n+    // Also, for some reason, GNU make spawns subprocesses with unlimited stack.\n+    if (stacksize > kMaxThreadStackSize)\n+      stacksize = kMaxThreadStackSize;\n+    *stack_top = end;\n+    *stack_bottom = end - stacksize;\n+    return;\n+  }\n+  pthread_attr_t attr;\n+  CHECK_EQ(pthread_getattr_np(pthread_self(), &attr), 0);\n+  uptr stacksize = 0;\n+  void *stackaddr = 0;\n+  pthread_attr_getstack(&attr, &stackaddr, (size_t*)&stacksize);\n+  pthread_attr_destroy(&attr);\n+\n+  *stack_top = (uptr)stackaddr + stacksize;\n+  *stack_bottom = (uptr)stackaddr;\n+  CHECK(stacksize < kMaxThreadStackSize);  // Sanity check.\n+}\n+\n+// Like getenv, but reads env directly from /proc and does not use libc.\n+// This function should be called first inside __asan_init.\n+const char *GetEnv(const char *name) {\n+  static char *environ;\n+  static uptr len;\n+  static bool inited;\n+  if (!inited) {\n+    inited = true;\n+    uptr environ_size;\n+    len = ReadFileToBuffer(\"/proc/self/environ\",\n+                           &environ, &environ_size, 1 << 26);\n+  }\n+  if (!environ || len == 0) return 0;\n+  uptr namelen = internal_strlen(name);\n+  const char *p = environ;\n+  while (*p != '\\0') {  // will happen at the \\0\\0 that terminates the buffer\n+    // proc file has the format NAME=value\\0NAME=value\\0NAME=value\\0...\n+    const char* endp =\n+        (char*)internal_memchr(p, '\\0', len - (p - environ));\n+    if (endp == 0)  // this entry isn't NUL terminated\n+      return 0;\n+    else if (!internal_memcmp(p, name, namelen) && p[namelen] == '=')  // Match.\n+      return p + namelen + 1;  // point after =\n+    p = endp + 1;\n+  }\n+  return 0;  // Not found.\n+}\n+\n+void ReExec() {\n+  static const int kMaxArgv = 100;\n+  InternalScopedBuffer<char*> argv(kMaxArgv + 1);\n+  static char *buff;\n+  uptr buff_size = 0;\n+  ReadFileToBuffer(\"/proc/self/cmdline\", &buff, &buff_size, 1024 * 1024);\n+  argv[0] = buff;\n+  int argc, i;\n+  for (argc = 1, i = 1; ; i++) {\n+    if (buff[i] == 0) {\n+      if (buff[i+1] == 0) break;\n+      argv[argc] = &buff[i+1];\n+      CHECK_LE(argc, kMaxArgv);  // FIXME: make this more flexible.\n+      argc++;\n+    }\n+  }\n+  argv[argc] = 0;\n+  execv(argv[0], argv.data());\n+}\n+\n+// ----------------- sanitizer_procmaps.h\n+MemoryMappingLayout::MemoryMappingLayout() {\n+  proc_self_maps_buff_len_ =\n+      ReadFileToBuffer(\"/proc/self/maps\", &proc_self_maps_buff_,\n+                       &proc_self_maps_buff_mmaped_size_, 1 << 26);\n+  CHECK_GT(proc_self_maps_buff_len_, 0);\n+  // internal_write(2, proc_self_maps_buff_, proc_self_maps_buff_len_);\n+  Reset();\n+}\n+\n+MemoryMappingLayout::~MemoryMappingLayout() {\n+  UnmapOrDie(proc_self_maps_buff_, proc_self_maps_buff_mmaped_size_);\n+}\n+\n+void MemoryMappingLayout::Reset() {\n+  current_ = proc_self_maps_buff_;\n+}\n+\n+// Parse a hex value in str and update str.\n+static uptr ParseHex(char **str) {\n+  uptr x = 0;\n+  char *s;\n+  for (s = *str; ; s++) {\n+    char c = *s;\n+    uptr v = 0;\n+    if (c >= '0' && c <= '9')\n+      v = c - '0';\n+    else if (c >= 'a' && c <= 'f')\n+      v = c - 'a' + 10;\n+    else if (c >= 'A' && c <= 'F')\n+      v = c - 'A' + 10;\n+    else\n+      break;\n+    x = x * 16 + v;\n+  }\n+  *str = s;\n+  return x;\n+}\n+\n+static bool IsOnOf(char c, char c1, char c2) {\n+  return c == c1 || c == c2;\n+}\n+\n+static bool IsDecimal(char c) {\n+  return c >= '0' && c <= '9';\n+}\n+\n+bool MemoryMappingLayout::Next(uptr *start, uptr *end, uptr *offset,\n+                               char filename[], uptr filename_size) {\n+  char *last = proc_self_maps_buff_ + proc_self_maps_buff_len_;\n+  if (current_ >= last) return false;\n+  uptr dummy;\n+  if (!start) start = &dummy;\n+  if (!end) end = &dummy;\n+  if (!offset) offset = &dummy;\n+  char *next_line = (char*)internal_memchr(current_, '\\n', last - current_);\n+  if (next_line == 0)\n+    next_line = last;\n+  // Example: 08048000-08056000 r-xp 00000000 03:0c 64593   /foo/bar\n+  *start = ParseHex(&current_);\n+  CHECK_EQ(*current_++, '-');\n+  *end = ParseHex(&current_);\n+  CHECK_EQ(*current_++, ' ');\n+  CHECK(IsOnOf(*current_++, '-', 'r'));\n+  CHECK(IsOnOf(*current_++, '-', 'w'));\n+  CHECK(IsOnOf(*current_++, '-', 'x'));\n+  CHECK(IsOnOf(*current_++, 's', 'p'));\n+  CHECK_EQ(*current_++, ' ');\n+  *offset = ParseHex(&current_);\n+  CHECK_EQ(*current_++, ' ');\n+  ParseHex(&current_);\n+  CHECK_EQ(*current_++, ':');\n+  ParseHex(&current_);\n+  CHECK_EQ(*current_++, ' ');\n+  while (IsDecimal(*current_))\n+    current_++;\n+  CHECK_EQ(*current_++, ' ');\n+  // Skip spaces.\n+  while (current_ < next_line && *current_ == ' ')\n+    current_++;\n+  // Fill in the filename.\n+  uptr i = 0;\n+  while (current_ < next_line) {\n+    if (filename && i < filename_size - 1)\n+      filename[i++] = *current_;\n+    current_++;\n+  }\n+  if (filename && i < filename_size)\n+    filename[i] = 0;\n+  current_ = next_line + 1;\n+  return true;\n+}\n+\n+// Gets the object name and the offset by walking MemoryMappingLayout.\n+bool MemoryMappingLayout::GetObjectNameAndOffset(uptr addr, uptr *offset,\n+                                                 char filename[],\n+                                                 uptr filename_size) {\n+  return IterateForObjectNameAndOffset(addr, offset, filename, filename_size);\n+}\n+\n+}  // namespace __sanitizer\n+\n+#endif  // __linux__"}, {"sha": "3df12f550a0b4dfd25e61dd9d068483bf69f3461", "filename": "libsanitizer/sanitizer_common/sanitizer_list.h", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_list.h?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,118 @@\n+//===-- sanitizer_list.h ----------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file contains implementation of a list class to be used by\n+// ThreadSanitizer, etc run-times.\n+//\n+//===----------------------------------------------------------------------===//\n+#ifndef SANITIZER_LIST_H\n+#define SANITIZER_LIST_H\n+\n+#include \"sanitizer_internal_defs.h\"\n+\n+namespace __sanitizer {\n+\n+// Intrusive singly-linked list with size(), push_back(), push_front()\n+// pop_front(), append_front() and append_back().\n+// This class should be a POD (so that it can be put into TLS)\n+// and an object with all zero fields should represent a valid empty list.\n+// This class does not have a CTOR, so clear() should be called on all\n+// non-zero-initialized objects before using.\n+template<class Item>\n+struct IntrusiveList {\n+  void clear() {\n+    first_ = last_ = 0;\n+    size_ = 0;\n+  }\n+\n+  bool empty() const { return size_ == 0; }\n+  uptr size() const { return size_; }\n+\n+  void push_back(Item *x) {\n+    if (empty()) {\n+      x->next = 0;\n+      first_ = last_ = x;\n+      size_ = 1;\n+    } else {\n+      x->next = 0;\n+      last_->next = x;\n+      last_ = x;\n+      size_++;\n+    }\n+  }\n+\n+  void push_front(Item *x) {\n+    if (empty()) {\n+      x->next = 0;\n+      first_ = last_ = x;\n+      size_ = 1;\n+    } else {\n+      x->next = first_;\n+      first_ = x;\n+      size_++;\n+    }\n+  }\n+\n+  void pop_front() {\n+    CHECK(!empty());\n+    first_ = first_->next;\n+    if (first_ == 0)\n+      last_ = 0;\n+    size_--;\n+  }\n+\n+  Item *front() { return first_; }\n+  Item *back() { return last_; }\n+\n+  void append_front(IntrusiveList<Item> *l) {\n+    CHECK_NE(this, l);\n+    if (empty()) {\n+      *this = *l;\n+    } else if (!l->empty()) {\n+      l->last_->next = first_;\n+      first_ = l->first_;\n+      size_ += l->size();\n+    }\n+    l->clear();\n+  }\n+\n+  void append_back(IntrusiveList<Item> *l) {\n+    CHECK_NE(this, l);\n+    if (empty()) {\n+      *this = *l;\n+    } else {\n+      last_->next = l->first_;\n+      last_ = l->last_;\n+      size_ += l->size();\n+    }\n+    l->clear();\n+  }\n+\n+  void CheckConsistency() {\n+    if (size_ == 0) {\n+      CHECK_EQ(first_, 0);\n+      CHECK_EQ(last_, 0);\n+    } else {\n+      uptr count = 0;\n+      for (Item *i = first_; ; i = i->next) {\n+        count++;\n+        if (i == last_) break;\n+      }\n+      CHECK_EQ(size(), count);\n+      CHECK_EQ(last_->next, 0);\n+    }\n+  }\n+\n+// private, don't use directly.\n+  uptr size_;\n+  Item *first_;\n+  Item *last_;\n+};\n+\n+}  // namespace __sanitizer\n+\n+#endif  // SANITIZER_LIST_H"}, {"sha": "400cd21842b2bbe369c6bfe950a17af877d51c31", "filename": "libsanitizer/sanitizer_common/sanitizer_mac.cc", "status": "added", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cc?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,249 @@\n+//===-- sanitizer_mac.cc --------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is shared between AddressSanitizer and ThreadSanitizer\n+// run-time libraries and implements mac-specific functions from\n+// sanitizer_libc.h.\n+//===----------------------------------------------------------------------===//\n+\n+#ifdef __APPLE__\n+\n+#include \"sanitizer_common.h\"\n+#include \"sanitizer_internal_defs.h\"\n+#include \"sanitizer_libc.h\"\n+#include \"sanitizer_procmaps.h\"\n+\n+#include <crt_externs.h>  // for _NSGetEnviron\n+#include <fcntl.h>\n+#include <mach-o/dyld.h>\n+#include <mach-o/loader.h>\n+#include <pthread.h>\n+#include <sched.h>\n+#include <sys/mman.h>\n+#include <sys/resource.h>\n+#include <sys/stat.h>\n+#include <sys/types.h>\n+#include <unistd.h>\n+\n+namespace __sanitizer {\n+\n+// ---------------------- sanitizer_libc.h\n+void *internal_mmap(void *addr, size_t length, int prot, int flags,\n+                    int fd, u64 offset) {\n+  return mmap(addr, length, prot, flags, fd, offset);\n+}\n+\n+int internal_munmap(void *addr, uptr length) {\n+  return munmap(addr, length);\n+}\n+\n+int internal_close(fd_t fd) {\n+  return close(fd);\n+}\n+\n+fd_t internal_open(const char *filename, bool write) {\n+  return open(filename,\n+              write ? O_WRONLY | O_CREAT : O_RDONLY, 0660);\n+}\n+\n+uptr internal_read(fd_t fd, void *buf, uptr count) {\n+  return read(fd, buf, count);\n+}\n+\n+uptr internal_write(fd_t fd, const void *buf, uptr count) {\n+  return write(fd, buf, count);\n+}\n+\n+uptr internal_filesize(fd_t fd) {\n+  struct stat st;\n+  if (fstat(fd, &st))\n+    return -1;\n+  return (uptr)st.st_size;\n+}\n+\n+int internal_dup2(int oldfd, int newfd) {\n+  return dup2(oldfd, newfd);\n+}\n+\n+uptr internal_readlink(const char *path, char *buf, uptr bufsize) {\n+  return readlink(path, buf, bufsize);\n+}\n+\n+int internal_sched_yield() {\n+  return sched_yield();\n+}\n+\n+// ----------------- sanitizer_common.h\n+uptr GetTid() {\n+  return reinterpret_cast<uptr>(pthread_self());\n+}\n+\n+void GetThreadStackTopAndBottom(bool at_initialization, uptr *stack_top,\n+                                uptr *stack_bottom) {\n+  CHECK(stack_top);\n+  CHECK(stack_bottom);\n+  uptr stacksize = pthread_get_stacksize_np(pthread_self());\n+  void *stackaddr = pthread_get_stackaddr_np(pthread_self());\n+  *stack_top = (uptr)stackaddr;\n+  *stack_bottom = *stack_top - stacksize;\n+}\n+\n+const char *GetEnv(const char *name) {\n+  char ***env_ptr = _NSGetEnviron();\n+  CHECK(env_ptr);\n+  char **environ = *env_ptr;\n+  CHECK(environ);\n+  uptr name_len = internal_strlen(name);\n+  while (*environ != 0) {\n+    uptr len = internal_strlen(*environ);\n+    if (len > name_len) {\n+      const char *p = *environ;\n+      if (!internal_memcmp(p, name, name_len) &&\n+          p[name_len] == '=') {  // Match.\n+        return *environ + name_len + 1;  // String starting after =.\n+      }\n+    }\n+    environ++;\n+  }\n+  return 0;\n+}\n+\n+void ReExec() {\n+  UNIMPLEMENTED();\n+}\n+\n+// ----------------- sanitizer_procmaps.h\n+\n+MemoryMappingLayout::MemoryMappingLayout() {\n+  Reset();\n+}\n+\n+MemoryMappingLayout::~MemoryMappingLayout() {\n+}\n+\n+// More information about Mach-O headers can be found in mach-o/loader.h\n+// Each Mach-O image has a header (mach_header or mach_header_64) starting with\n+// a magic number, and a list of linker load commands directly following the\n+// header.\n+// A load command is at least two 32-bit words: the command type and the\n+// command size in bytes. We're interested only in segment load commands\n+// (LC_SEGMENT and LC_SEGMENT_64), which tell that a part of the file is mapped\n+// into the task's address space.\n+// The |vmaddr|, |vmsize| and |fileoff| fields of segment_command or\n+// segment_command_64 correspond to the memory address, memory size and the\n+// file offset of the current memory segment.\n+// Because these fields are taken from the images as is, one needs to add\n+// _dyld_get_image_vmaddr_slide() to get the actual addresses at runtime.\n+\n+void MemoryMappingLayout::Reset() {\n+  // Count down from the top.\n+  // TODO(glider): as per man 3 dyld, iterating over the headers with\n+  // _dyld_image_count is thread-unsafe. We need to register callbacks for\n+  // adding and removing images which will invalidate the MemoryMappingLayout\n+  // state.\n+  current_image_ = _dyld_image_count();\n+  current_load_cmd_count_ = -1;\n+  current_load_cmd_addr_ = 0;\n+  current_magic_ = 0;\n+  current_filetype_ = 0;\n+}\n+\n+// Next and NextSegmentLoad were inspired by base/sysinfo.cc in\n+// Google Perftools, http://code.google.com/p/google-perftools.\n+\n+// NextSegmentLoad scans the current image for the next segment load command\n+// and returns the start and end addresses and file offset of the corresponding\n+// segment.\n+// Note that the segment addresses are not necessarily sorted.\n+template<u32 kLCSegment, typename SegmentCommand>\n+bool MemoryMappingLayout::NextSegmentLoad(\n+    uptr *start, uptr *end, uptr *offset,\n+    char filename[], uptr filename_size) {\n+  const char* lc = current_load_cmd_addr_;\n+  current_load_cmd_addr_ += ((const load_command *)lc)->cmdsize;\n+  if (((const load_command *)lc)->cmd == kLCSegment) {\n+    const sptr dlloff = _dyld_get_image_vmaddr_slide(current_image_);\n+    const SegmentCommand* sc = (const SegmentCommand *)lc;\n+    if (start) *start = sc->vmaddr + dlloff;\n+    if (end) *end = sc->vmaddr + sc->vmsize + dlloff;\n+    if (offset) {\n+      if (current_filetype_ == /*MH_EXECUTE*/ 0x2) {\n+        *offset = sc->vmaddr;\n+      } else {\n+        *offset = sc->fileoff;\n+      }\n+    }\n+    if (filename) {\n+      internal_strncpy(filename, _dyld_get_image_name(current_image_),\n+                       filename_size);\n+    }\n+    return true;\n+  }\n+  return false;\n+}\n+\n+bool MemoryMappingLayout::Next(uptr *start, uptr *end, uptr *offset,\n+                               char filename[], uptr filename_size) {\n+  for (; current_image_ >= 0; current_image_--) {\n+    const mach_header* hdr = _dyld_get_image_header(current_image_);\n+    if (!hdr) continue;\n+    if (current_load_cmd_count_ < 0) {\n+      // Set up for this image;\n+      current_load_cmd_count_ = hdr->ncmds;\n+      current_magic_ = hdr->magic;\n+      current_filetype_ = hdr->filetype;\n+      switch (current_magic_) {\n+#ifdef MH_MAGIC_64\n+        case MH_MAGIC_64: {\n+          current_load_cmd_addr_ = (char*)hdr + sizeof(mach_header_64);\n+          break;\n+        }\n+#endif\n+        case MH_MAGIC: {\n+          current_load_cmd_addr_ = (char*)hdr + sizeof(mach_header);\n+          break;\n+        }\n+        default: {\n+          continue;\n+        }\n+      }\n+    }\n+\n+    for (; current_load_cmd_count_ >= 0; current_load_cmd_count_--) {\n+      switch (current_magic_) {\n+        // current_magic_ may be only one of MH_MAGIC, MH_MAGIC_64.\n+#ifdef MH_MAGIC_64\n+        case MH_MAGIC_64: {\n+          if (NextSegmentLoad<LC_SEGMENT_64, struct segment_command_64>(\n+                  start, end, offset, filename, filename_size))\n+            return true;\n+          break;\n+        }\n+#endif\n+        case MH_MAGIC: {\n+          if (NextSegmentLoad<LC_SEGMENT, struct segment_command>(\n+                  start, end, offset, filename, filename_size))\n+            return true;\n+          break;\n+        }\n+      }\n+    }\n+    // If we get here, no more load_cmd's in this image talk about\n+    // segments.  Go on to the next image.\n+  }\n+  return false;\n+}\n+\n+bool MemoryMappingLayout::GetObjectNameAndOffset(uptr addr, uptr *offset,\n+                                                 char filename[],\n+                                                 uptr filename_size) {\n+  return IterateForObjectNameAndOffset(addr, offset, filename, filename_size);\n+}\n+\n+}  // namespace __sanitizer\n+\n+#endif  // __APPLE__"}, {"sha": "a38a49ae24295de5b376da986ee5785468ed1000", "filename": "libsanitizer/sanitizer_common/sanitizer_mutex.h", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_mutex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_mutex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mutex.h?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,106 @@\n+//===-- sanitizer_mutex.h ---------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer/AddressSanitizer runtime.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef SANITIZER_MUTEX_H\n+#define SANITIZER_MUTEX_H\n+\n+#include \"sanitizer_atomic.h\"\n+#include \"sanitizer_internal_defs.h\"\n+#include \"sanitizer_libc.h\"\n+\n+namespace __sanitizer {\n+\n+class StaticSpinMutex {\n+ public:\n+  void Init() {\n+    atomic_store(&state_, 0, memory_order_relaxed);\n+  }\n+\n+  void Lock() {\n+    if (atomic_exchange(&state_, 1, memory_order_acquire) == 0)\n+      return;\n+    LockSlow();\n+  }\n+\n+  void Unlock() {\n+    atomic_store(&state_, 0, memory_order_release);\n+  }\n+\n+ private:\n+  atomic_uint8_t state_;\n+\n+  void NOINLINE LockSlow() {\n+    for (int i = 0;; i++) {\n+      if (i < 10)\n+        proc_yield(10);\n+      else\n+        internal_sched_yield();\n+      if (atomic_load(&state_, memory_order_relaxed) == 0\n+          && atomic_exchange(&state_, 1, memory_order_acquire) == 0)\n+        return;\n+    }\n+  }\n+};\n+\n+class SpinMutex : public StaticSpinMutex {\n+ public:\n+  SpinMutex() {\n+    Init();\n+  }\n+\n+ private:\n+  SpinMutex(const SpinMutex&);\n+  void operator=(const SpinMutex&);\n+};\n+\n+template<typename MutexType>\n+class GenericScopedLock {\n+ public:\n+  explicit GenericScopedLock(MutexType *mu)\n+      : mu_(mu) {\n+    mu_->Lock();\n+  }\n+\n+  ~GenericScopedLock() {\n+    mu_->Unlock();\n+  }\n+\n+ private:\n+  MutexType *mu_;\n+\n+  GenericScopedLock(const GenericScopedLock&);\n+  void operator=(const GenericScopedLock&);\n+};\n+\n+template<typename MutexType>\n+class GenericScopedReadLock {\n+ public:\n+  explicit GenericScopedReadLock(MutexType *mu)\n+      : mu_(mu) {\n+    mu_->ReadLock();\n+  }\n+\n+  ~GenericScopedReadLock() {\n+    mu_->ReadUnlock();\n+  }\n+\n+ private:\n+  MutexType *mu_;\n+\n+  GenericScopedReadLock(const GenericScopedReadLock&);\n+  void operator=(const GenericScopedReadLock&);\n+};\n+\n+typedef GenericScopedLock<StaticSpinMutex> SpinMutexLock;\n+\n+}  // namespace __sanitizer\n+\n+#endif  // SANITIZER_MUTEX_H"}, {"sha": "d149683b43de14a28d71ef6fd09c09bcffb45956", "filename": "libsanitizer/sanitizer_common/sanitizer_placement_new.h", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_placement_new.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_placement_new.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_placement_new.h?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,31 @@\n+//===-- sanitizer_placement_new.h -------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is shared between AddressSanitizer and ThreadSanitizer\n+// run-time libraries.\n+//\n+// The file provides 'placement new'.\n+// Do not include it into header files, only into source files.\n+//===----------------------------------------------------------------------===//\n+#ifndef SANITIZER_PLACEMENT_NEW_H\n+#define SANITIZER_PLACEMENT_NEW_H\n+\n+#include \"sanitizer_internal_defs.h\"\n+\n+namespace __sanitizer {\n+#if (__WORDSIZE == 64) || defined(__APPLE__)\n+typedef uptr operator_new_ptr_type;\n+#else\n+typedef u32 operator_new_ptr_type;\n+#endif\n+}  // namespace __sanitizer\n+\n+inline void *operator new(__sanitizer::operator_new_ptr_type sz, void *p) {\n+  return p;\n+}\n+\n+#endif  // SANITIZER_PLACEMENT_NEW_H"}, {"sha": "8f71cfc049dd7034a621f7213e2f7a401f600d7f", "filename": "libsanitizer/sanitizer_common/sanitizer_posix.cc", "status": "added", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cc?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,187 @@\n+//===-- sanitizer_posix.cc ------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is shared between AddressSanitizer and ThreadSanitizer\n+// run-time libraries and implements POSIX-specific functions from\n+// sanitizer_libc.h.\n+//===----------------------------------------------------------------------===//\n+#if defined(__linux__) || defined(__APPLE__)\n+\n+#include \"sanitizer_common.h\"\n+#include \"sanitizer_libc.h\"\n+#include \"sanitizer_procmaps.h\"\n+\n+#include <errno.h>\n+#include <pthread.h>\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <sys/mman.h>\n+#include <sys/resource.h>\n+#include <sys/time.h>\n+#include <sys/types.h>\n+#include <unistd.h>\n+\n+namespace __sanitizer {\n+\n+// ------------- sanitizer_common.h\n+\n+int GetPid() {\n+  return getpid();\n+}\n+\n+uptr GetThreadSelf() {\n+  return (uptr)pthread_self();\n+}\n+\n+void *MmapOrDie(uptr size, const char *mem_type) {\n+  size = RoundUpTo(size, kPageSize);\n+  void *res = internal_mmap(0, size,\n+                            PROT_READ | PROT_WRITE,\n+                            MAP_PRIVATE | MAP_ANON, -1, 0);\n+  if (res == (void*)-1) {\n+    static int recursion_count;\n+    if (recursion_count) {\n+      // The Report() and CHECK calls below may call mmap recursively and fail.\n+      // If we went into recursion, just die.\n+      RawWrite(\"AddressSanitizer is unable to mmap\\n\");\n+      Die();\n+    }\n+    recursion_count++;\n+    Report(\"ERROR: Failed to allocate 0x%zx (%zd) bytes of %s: %s\\n\",\n+           size, size, mem_type, strerror(errno));\n+    DumpProcessMap();\n+    CHECK(\"unable to mmap\" && 0);\n+  }\n+  return res;\n+}\n+\n+void UnmapOrDie(void *addr, uptr size) {\n+  if (!addr || !size) return;\n+  int res = internal_munmap(addr, size);\n+  if (res != 0) {\n+    Report(\"ERROR: Failed to deallocate 0x%zx (%zd) bytes at address %p\\n\",\n+           size, size, addr);\n+    CHECK(\"unable to unmap\" && 0);\n+  }\n+}\n+\n+void *MmapFixedNoReserve(uptr fixed_addr, uptr size) {\n+  return internal_mmap((void*)fixed_addr, size,\n+                      PROT_READ | PROT_WRITE,\n+                      MAP_PRIVATE | MAP_ANON | MAP_FIXED | MAP_NORESERVE,\n+                      -1, 0);\n+}\n+\n+void *Mprotect(uptr fixed_addr, uptr size) {\n+  return internal_mmap((void*)fixed_addr, size,\n+                       PROT_NONE,\n+                       MAP_PRIVATE | MAP_ANON | MAP_FIXED | MAP_NORESERVE,\n+                       -1, 0);\n+}\n+\n+void *MapFileToMemory(const char *file_name, uptr *buff_size) {\n+  fd_t fd = internal_open(file_name, false);\n+  CHECK_NE(fd, kInvalidFd);\n+  uptr fsize = internal_filesize(fd);\n+  CHECK_NE(fsize, (uptr)-1);\n+  CHECK_GT(fsize, 0);\n+  *buff_size = RoundUpTo(fsize, kPageSize);\n+  void *map = internal_mmap(0, *buff_size, PROT_READ, MAP_PRIVATE, fd, 0);\n+  return (map == MAP_FAILED) ? 0 : map;\n+}\n+\n+\n+static inline bool IntervalsAreSeparate(uptr start1, uptr end1,\n+                                        uptr start2, uptr end2) {\n+  CHECK(start1 <= end1);\n+  CHECK(start2 <= end2);\n+  return (end1 < start2) || (end2 < start1);\n+}\n+\n+// FIXME: this is thread-unsafe, but should not cause problems most of the time.\n+// When the shadow is mapped only a single thread usually exists (plus maybe\n+// several worker threads on Mac, which aren't expected to map big chunks of\n+// memory).\n+bool MemoryRangeIsAvailable(uptr range_start, uptr range_end) {\n+  MemoryMappingLayout procmaps;\n+  uptr start, end;\n+  while (procmaps.Next(&start, &end,\n+                       /*offset*/0, /*filename*/0, /*filename_size*/0)) {\n+    if (!IntervalsAreSeparate(start, end, range_start, range_end))\n+      return false;\n+  }\n+  return true;\n+}\n+\n+void DumpProcessMap() {\n+  MemoryMappingLayout proc_maps;\n+  uptr start, end;\n+  const sptr kBufSize = 4095;\n+  char *filename = (char*)MmapOrDie(kBufSize, __FUNCTION__);\n+  Report(\"Process memory map follows:\\n\");\n+  while (proc_maps.Next(&start, &end, /* file_offset */0,\n+                        filename, kBufSize)) {\n+    Printf(\"\\t%p-%p\\t%s\\n\", (void*)start, (void*)end, filename);\n+  }\n+  Report(\"End of process memory map.\\n\");\n+  UnmapOrDie(filename, kBufSize);\n+}\n+\n+const char *GetPwd() {\n+  return GetEnv(\"PWD\");\n+}\n+\n+void DisableCoreDumper() {\n+  struct rlimit nocore;\n+  nocore.rlim_cur = 0;\n+  nocore.rlim_max = 0;\n+  setrlimit(RLIMIT_CORE, &nocore);\n+}\n+\n+bool StackSizeIsUnlimited() {\n+  struct rlimit rlim;\n+  CHECK_EQ(0, getrlimit(RLIMIT_STACK, &rlim));\n+  return (rlim.rlim_cur == (uptr)-1);\n+}\n+\n+void SetStackSizeLimitInBytes(uptr limit) {\n+  struct rlimit rlim;\n+  rlim.rlim_cur = limit;\n+  rlim.rlim_max = limit;\n+  CHECK_EQ(0, setrlimit(RLIMIT_STACK, &rlim));\n+  CHECK(!StackSizeIsUnlimited());\n+}\n+\n+void SleepForSeconds(int seconds) {\n+  sleep(seconds);\n+}\n+\n+void SleepForMillis(int millis) {\n+  usleep(millis * 1000);\n+}\n+\n+void Exit(int exitcode) {\n+  _exit(exitcode);\n+}\n+\n+void Abort() {\n+  abort();\n+}\n+\n+int Atexit(void (*function)(void)) {\n+#ifndef SANITIZER_GO\n+  return atexit(function);\n+#else\n+  return 0;\n+#endif\n+}\n+\n+}  // namespace __sanitizer\n+\n+#endif  // __linux__ || __APPLE_"}, {"sha": "da4dc7f53a1860f1c0aa6d21d3ced0669218809d", "filename": "libsanitizer/sanitizer_common/sanitizer_printf.cc", "status": "added", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_printf.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_printf.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_printf.cc?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,196 @@\n+//===-- sanitizer_printf.cc -----------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is shared between AddressSanitizer and ThreadSanitizer.\n+//\n+// Internal printf function, used inside run-time libraries.\n+// We can't use libc printf because we intercept some of the functions used\n+// inside it.\n+//===----------------------------------------------------------------------===//\n+\n+\n+#include \"sanitizer_common.h\"\n+#include \"sanitizer_libc.h\"\n+\n+#include <stdio.h>\n+#include <stdarg.h>\n+\n+namespace __sanitizer {\n+\n+static int AppendChar(char **buff, const char *buff_end, char c) {\n+  if (*buff < buff_end) {\n+    **buff = c;\n+    (*buff)++;\n+  }\n+  return 1;\n+}\n+\n+// Appends number in a given base to buffer. If its length is less than\n+// \"minimal_num_length\", it is padded with leading zeroes.\n+static int AppendUnsigned(char **buff, const char *buff_end, u64 num,\n+                          u8 base, u8 minimal_num_length) {\n+  uptr const kMaxLen = 30;\n+  RAW_CHECK(base == 10 || base == 16);\n+  RAW_CHECK(minimal_num_length < kMaxLen);\n+  uptr num_buffer[kMaxLen];\n+  uptr pos = 0;\n+  do {\n+    RAW_CHECK_MSG(pos < kMaxLen, \"appendNumber buffer overflow\");\n+    num_buffer[pos++] = num % base;\n+    num /= base;\n+  } while (num > 0);\n+  while (pos < minimal_num_length) num_buffer[pos++] = 0;\n+  int result = 0;\n+  while (pos-- > 0) {\n+    uptr digit = num_buffer[pos];\n+    result += AppendChar(buff, buff_end, (digit < 10) ? '0' + digit\n+                                                      : 'a' + digit - 10);\n+  }\n+  return result;\n+}\n+\n+static int AppendSignedDecimal(char **buff, const char *buff_end, s64 num) {\n+  int result = 0;\n+  if (num < 0) {\n+    result += AppendChar(buff, buff_end, '-');\n+    num = -num;\n+  }\n+  result += AppendUnsigned(buff, buff_end, (u64)num, 10, 0);\n+  return result;\n+}\n+\n+static int AppendString(char **buff, const char *buff_end, const char *s) {\n+  if (s == 0)\n+    s = \"<null>\";\n+  int result = 0;\n+  for (; *s; s++) {\n+    result += AppendChar(buff, buff_end, *s);\n+  }\n+  return result;\n+}\n+\n+static int AppendPointer(char **buff, const char *buff_end, u64 ptr_value) {\n+  int result = 0;\n+  result += AppendString(buff, buff_end, \"0x\");\n+  result += AppendUnsigned(buff, buff_end, ptr_value, 16,\n+                           (__WORDSIZE == 64) ? 12 : 8);\n+  return result;\n+}\n+\n+int VSNPrintf(char *buff, int buff_length,\n+              const char *format, va_list args) {\n+  static const char *kPrintfFormatsHelp = \"Supported Printf formats: \"\n+                                          \"%%[z]{d,u,x}; %%p; %%s; %%c\\n\";\n+  RAW_CHECK(format);\n+  RAW_CHECK(buff_length > 0);\n+  const char *buff_end = &buff[buff_length - 1];\n+  const char *cur = format;\n+  int result = 0;\n+  for (; *cur; cur++) {\n+    if (*cur != '%') {\n+      result += AppendChar(&buff, buff_end, *cur);\n+      continue;\n+    }\n+    cur++;\n+    bool have_z = (*cur == 'z');\n+    cur += have_z;\n+    s64 dval;\n+    u64 uval;\n+    switch (*cur) {\n+      case 'd': {\n+        dval = have_z ? va_arg(args, sptr)\n+                      : va_arg(args, int);\n+        result += AppendSignedDecimal(&buff, buff_end, dval);\n+        break;\n+      }\n+      case 'u':\n+      case 'x': {\n+        uval = have_z ? va_arg(args, uptr)\n+                      : va_arg(args, unsigned);\n+        result += AppendUnsigned(&buff, buff_end, uval,\n+                                 (*cur == 'u') ? 10 : 16, 0);\n+        break;\n+      }\n+      case 'p': {\n+        RAW_CHECK_MSG(!have_z, kPrintfFormatsHelp);\n+        result += AppendPointer(&buff, buff_end, va_arg(args, uptr));\n+        break;\n+      }\n+      case 's': {\n+        RAW_CHECK_MSG(!have_z, kPrintfFormatsHelp);\n+        result += AppendString(&buff, buff_end, va_arg(args, char*));\n+        break;\n+      }\n+      case 'c': {\n+        RAW_CHECK_MSG(!have_z, kPrintfFormatsHelp);\n+        result += AppendChar(&buff, buff_end, va_arg(args, int));\n+        break;\n+      }\n+      case '%' : {\n+        RAW_CHECK_MSG(!have_z, kPrintfFormatsHelp);\n+        result += AppendChar(&buff, buff_end, '%');\n+        break;\n+      }\n+      default: {\n+        RAW_CHECK_MSG(false, kPrintfFormatsHelp);\n+      }\n+    }\n+  }\n+  RAW_CHECK(buff <= buff_end);\n+  AppendChar(&buff, buff_end + 1, '\\0');\n+  return result;\n+}\n+\n+static void (*PrintfAndReportCallback)(const char *);\n+void SetPrintfAndReportCallback(void (*callback)(const char *)) {\n+  PrintfAndReportCallback = callback;\n+}\n+\n+void Printf(const char *format, ...) {\n+  const int kLen = 1024 * 4;\n+  InternalScopedBuffer<char> buffer(kLen);\n+  va_list args;\n+  va_start(args, format);\n+  int needed_length = VSNPrintf(buffer.data(), kLen, format, args);\n+  va_end(args);\n+  RAW_CHECK_MSG(needed_length < kLen, \"Buffer in Printf is too short!\\n\");\n+  RawWrite(buffer.data());\n+  if (PrintfAndReportCallback)\n+    PrintfAndReportCallback(buffer.data());\n+}\n+\n+// Writes at most \"length\" symbols to \"buffer\" (including trailing '\\0').\n+// Returns the number of symbols that should have been written to buffer\n+// (not including trailing '\\0'). Thus, the string is truncated\n+// iff return value is not less than \"length\".\n+int internal_snprintf(char *buffer, uptr length, const char *format, ...) {\n+  va_list args;\n+  va_start(args, format);\n+  int needed_length = VSNPrintf(buffer, length, format, args);\n+  va_end(args);\n+  return needed_length;\n+}\n+\n+// Like Printf, but prints the current PID before the output string.\n+void Report(const char *format, ...) {\n+  const int kLen = 1024 * 4;\n+  InternalScopedBuffer<char> buffer(kLen);\n+  int needed_length = internal_snprintf(buffer.data(),\n+                                        kLen, \"==%d== \", GetPid());\n+  RAW_CHECK_MSG(needed_length < kLen, \"Buffer in Report is too short!\\n\");\n+  va_list args;\n+  va_start(args, format);\n+  needed_length += VSNPrintf(buffer.data() + needed_length,\n+                             kLen - needed_length, format, args);\n+  va_end(args);\n+  RAW_CHECK_MSG(needed_length < kLen, \"Buffer in Report is too short!\\n\");\n+  RawWrite(buffer.data());\n+  if (PrintfAndReportCallback)\n+    PrintfAndReportCallback(buffer.data());\n+}\n+\n+}  // namespace __sanitizer"}, {"sha": "5e5e5ce89be4f91090531b605a228329c2d8ab49", "filename": "libsanitizer/sanitizer_common/sanitizer_procmaps.h", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps.h?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,95 @@\n+//===-- sanitizer_procmaps.h ------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is shared between AddressSanitizer and ThreadSanitizer.\n+//\n+// Information about the process mappings.\n+//===----------------------------------------------------------------------===//\n+#ifndef SANITIZER_PROCMAPS_H\n+#define SANITIZER_PROCMAPS_H\n+\n+#include \"sanitizer_internal_defs.h\"\n+\n+namespace __sanitizer {\n+\n+#ifdef _WIN32\n+class MemoryMappingLayout {\n+ public:\n+  MemoryMappingLayout() {}\n+  bool GetObjectNameAndOffset(uptr addr, uptr *offset,\n+                              char filename[], uptr filename_size) {\n+    UNIMPLEMENTED();\n+    return false;\n+  }\n+};\n+\n+#else  // _WIN32\n+class MemoryMappingLayout {\n+ public:\n+  MemoryMappingLayout();\n+  bool Next(uptr *start, uptr *end, uptr *offset,\n+            char filename[], uptr filename_size);\n+  void Reset();\n+  // Gets the object file name and the offset in that object for a given\n+  // address 'addr'. Returns true on success.\n+  bool GetObjectNameAndOffset(uptr addr, uptr *offset,\n+                              char filename[], uptr filename_size);\n+  ~MemoryMappingLayout();\n+\n+ private:\n+  // Default implementation of GetObjectNameAndOffset.\n+  // Quite slow, because it iterates through the whole process map for each\n+  // lookup.\n+  bool IterateForObjectNameAndOffset(uptr addr, uptr *offset,\n+                                     char filename[], uptr filename_size) {\n+    Reset();\n+    uptr start, end, file_offset;\n+    for (int i = 0; Next(&start, &end, &file_offset, filename, filename_size);\n+         i++) {\n+      if (addr >= start && addr < end) {\n+        // Don't subtract 'start' for the first entry:\n+        // * If a binary is compiled w/o -pie, then the first entry in\n+        //   process maps is likely the binary itself (all dynamic libs\n+        //   are mapped higher in address space). For such a binary,\n+        //   instruction offset in binary coincides with the actual\n+        //   instruction address in virtual memory (as code section\n+        //   is mapped to a fixed memory range).\n+        // * If a binary is compiled with -pie, all the modules are\n+        //   mapped high at address space (in particular, higher than\n+        //   shadow memory of the tool), so the module can't be the\n+        //   first entry.\n+        *offset = (addr - (i ? start : 0)) + file_offset;\n+        return true;\n+      }\n+    }\n+    if (filename_size)\n+      filename[0] = '\\0';\n+    return false;\n+  }\n+\n+# if defined __linux__\n+  char *proc_self_maps_buff_;\n+  uptr proc_self_maps_buff_mmaped_size_;\n+  uptr proc_self_maps_buff_len_;\n+  char *current_;\n+# elif defined __APPLE__\n+  template<u32 kLCSegment, typename SegmentCommand>\n+  bool NextSegmentLoad(uptr *start, uptr *end, uptr *offset,\n+                       char filename[], uptr filename_size);\n+  int current_image_;\n+  u32 current_magic_;\n+  u32 current_filetype_;\n+  int current_load_cmd_count_;\n+  char *current_load_cmd_addr_;\n+# endif\n+};\n+\n+#endif  // _WIN32\n+\n+}  // namespace __sanitizer\n+\n+#endif  // SANITIZER_PROCMAPS_H"}, {"sha": "d9c5b69c7a2c373377f79a151796205ef1af1544", "filename": "libsanitizer/sanitizer_common/sanitizer_stackdepot.cc", "status": "added", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.cc?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,194 @@\n+//===-- sanitizer_stackdepot.cc -------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is shared between AddressSanitizer and ThreadSanitizer\n+// run-time libraries.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_stackdepot.h\"\n+#include \"sanitizer_common.h\"\n+#include \"sanitizer_internal_defs.h\"\n+#include \"sanitizer_mutex.h\"\n+#include \"sanitizer_atomic.h\"\n+\n+namespace __sanitizer {\n+\n+const int kTabSize = 1024 * 1024;  // Hash table size.\n+const int kPartBits = 8;\n+const int kPartShift = sizeof(u32) * 8 - kPartBits - 1;\n+const int kPartCount = 1 << kPartBits;  // Number of subparts in the table.\n+const int kPartSize = kTabSize / kPartCount;\n+const int kMaxId = 1 << kPartShift;\n+\n+struct StackDesc {\n+  StackDesc *link;\n+  u32 id;\n+  u32 hash;\n+  uptr size;\n+  uptr stack[1];  // [size]\n+};\n+\n+static struct {\n+  StaticSpinMutex mtx;  // Protects alloc of new blocks for region allocator.\n+  atomic_uintptr_t region_pos;  // Region allocator for StackDesc's.\n+  atomic_uintptr_t region_end;\n+  atomic_uintptr_t tab[kTabSize];  // Hash table of StackDesc's.\n+  atomic_uint32_t seq[kPartCount];  // Unique id generators.\n+} depot;\n+\n+static u32 hash(const uptr *stack, uptr size) {\n+  // murmur2\n+  const u32 m = 0x5bd1e995;\n+  const u32 seed = 0x9747b28c;\n+  const u32 r = 24;\n+  u32 h = seed ^ (size * sizeof(uptr));\n+  for (uptr i = 0; i < size; i++) {\n+    u32 k = stack[i];\n+    k *= m;\n+    k ^= k >> r;\n+    k *= m;\n+    h *= m;\n+    h ^= k;\n+  }\n+  h ^= h >> 13;\n+  h *= m;\n+  h ^= h >> 15;\n+  return h;\n+}\n+\n+static StackDesc *tryallocDesc(uptr memsz) {\n+  // Optimisic lock-free allocation, essentially try to bump the region ptr.\n+  for (;;) {\n+    uptr cmp = atomic_load(&depot.region_pos, memory_order_acquire);\n+    uptr end = atomic_load(&depot.region_end, memory_order_acquire);\n+    if (cmp == 0 || cmp + memsz > end)\n+      return 0;\n+    if (atomic_compare_exchange_weak(\n+        &depot.region_pos, &cmp, cmp + memsz,\n+        memory_order_acquire))\n+      return (StackDesc*)cmp;\n+  }\n+}\n+\n+static StackDesc *allocDesc(uptr size) {\n+  // Frist, try to allocate optimisitically.\n+  uptr memsz = sizeof(StackDesc) + (size - 1) * sizeof(uptr);\n+  StackDesc *s = tryallocDesc(memsz);\n+  if (s)\n+    return s;\n+  // If failed, lock, retry and alloc new superblock.\n+  SpinMutexLock l(&depot.mtx);\n+  for (;;) {\n+    s = tryallocDesc(memsz);\n+    if (s)\n+      return s;\n+    atomic_store(&depot.region_pos, 0, memory_order_relaxed);\n+    uptr allocsz = 64 * 1024;\n+    if (allocsz < memsz)\n+      allocsz = memsz;\n+    uptr mem = (uptr)MmapOrDie(allocsz, \"stack depot\");\n+    atomic_store(&depot.region_end, mem + allocsz, memory_order_release);\n+    atomic_store(&depot.region_pos, mem, memory_order_release);\n+  }\n+}\n+\n+static u32 find(StackDesc *s, const uptr *stack, uptr size, u32 hash) {\n+  // Searches linked list s for the stack, returns its id.\n+  for (; s; s = s->link) {\n+    if (s->hash == hash && s->size == size) {\n+      uptr i = 0;\n+      for (; i < size; i++) {\n+        if (stack[i] != s->stack[i])\n+          break;\n+      }\n+      if (i == size)\n+        return s->id;\n+    }\n+  }\n+  return 0;\n+}\n+\n+static StackDesc *lock(atomic_uintptr_t *p) {\n+  // Uses the pointer lsb as mutex.\n+  for (int i = 0;; i++) {\n+    uptr cmp = atomic_load(p, memory_order_relaxed);\n+    if ((cmp & 1) == 0\n+        && atomic_compare_exchange_weak(p, &cmp, cmp | 1,\n+                                        memory_order_acquire))\n+      return (StackDesc*)cmp;\n+    if (i < 10)\n+      proc_yield(10);\n+    else\n+      internal_sched_yield();\n+  }\n+}\n+\n+static void unlock(atomic_uintptr_t *p, StackDesc *s) {\n+  DCHECK_EQ((uptr)s & 1, 0);\n+  atomic_store(p, (uptr)s, memory_order_release);\n+}\n+\n+u32 StackDepotPut(const uptr *stack, uptr size) {\n+  if (stack == 0 || size == 0)\n+    return 0;\n+  uptr h = hash(stack, size);\n+  atomic_uintptr_t *p = &depot.tab[h % kTabSize];\n+  uptr v = atomic_load(p, memory_order_consume);\n+  StackDesc *s = (StackDesc*)(v & ~1);\n+  // First, try to find the existing stack.\n+  u32 id = find(s, stack, size, h);\n+  if (id)\n+    return id;\n+  // If failed, lock, retry and insert new.\n+  StackDesc *s2 = lock(p);\n+  if (s2 != s) {\n+    id = find(s2, stack, size, h);\n+    if (id) {\n+      unlock(p, s2);\n+      return id;\n+    }\n+  }\n+  uptr part = (h % kTabSize) / kPartSize;\n+  id = atomic_fetch_add(&depot.seq[part], 1, memory_order_relaxed) + 1;\n+  CHECK_LT(id, kMaxId);\n+  id |= part << kPartShift;\n+  CHECK_NE(id, 0);\n+  CHECK_EQ(id & (1u << 31), 0);\n+  s = allocDesc(size);\n+  s->id = id;\n+  s->hash = h;\n+  s->size = size;\n+  internal_memcpy(s->stack, stack, size * sizeof(uptr));\n+  s->link = s2;\n+  unlock(p, s);\n+  return id;\n+}\n+\n+const uptr *StackDepotGet(u32 id, uptr *size) {\n+  if (id == 0)\n+    return 0;\n+  CHECK_EQ(id & (1u << 31), 0);\n+  // High kPartBits contain part id, so we need to scan at most kPartSize lists.\n+  uptr part = id >> kPartShift;\n+  for (int i = 0; i != kPartSize; i++) {\n+    uptr idx = part * kPartSize + i;\n+    CHECK_LT(idx, kTabSize);\n+    atomic_uintptr_t *p = &depot.tab[idx];\n+    uptr v = atomic_load(p, memory_order_consume);\n+    StackDesc *s = (StackDesc*)(v & ~1);\n+    for (; s; s = s->link) {\n+      if (s->id == id) {\n+        *size = s->size;\n+        return s->stack;\n+      }\n+    }\n+  }\n+  *size = 0;\n+  return 0;\n+}\n+\n+}  // namespace __sanitizer"}, {"sha": "c4c388aa74d2fb634b7a96405918d0f844aec2d6", "filename": "libsanitizer/sanitizer_common/sanitizer_stackdepot.h", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.h?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,27 @@\n+//===-- sanitizer_stackdepot.h ----------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is shared between AddressSanitizer and ThreadSanitizer\n+// run-time libraries.\n+//===----------------------------------------------------------------------===//\n+#ifndef SANITIZER_STACKDEPOT_H\n+#define SANITIZER_STACKDEPOT_H\n+\n+#include \"sanitizer/common_interface_defs.h\"\n+\n+namespace __sanitizer {\n+\n+// StackDepot efficiently stores huge amounts of stack traces.\n+\n+// Maps stack trace to an unique id.\n+u32 StackDepotPut(const uptr *stack, uptr size);\n+// Retrieves a stored stack trace by the id.\n+const uptr *StackDepotGet(u32 id, uptr *size);\n+\n+}  // namespace __sanitizer\n+\n+#endif  // SANITIZER_STACKDEPOT_H"}, {"sha": "f6d7a0966c2a1d9464044d065f6eff9be5825c91", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace.cc", "status": "added", "additions": 245, "deletions": 0, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cc?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,245 @@\n+//===-- sanitizer_stacktrace.cc -------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is shared between AddressSanitizer and ThreadSanitizer\n+// run-time libraries.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_common.h\"\n+#include \"sanitizer_procmaps.h\"\n+#include \"sanitizer_stacktrace.h\"\n+#include \"sanitizer_symbolizer.h\"\n+\n+namespace __sanitizer {\n+static const char *StripPathPrefix(const char *filepath,\n+                                   const char *strip_file_prefix) {\n+  if (filepath == internal_strstr(filepath, strip_file_prefix))\n+    return filepath + internal_strlen(strip_file_prefix);\n+  return filepath;\n+}\n+\n+// ----------------------- StackTrace ----------------------------- {{{1\n+// PCs in stack traces are actually the return addresses, that is,\n+// addresses of the next instructions after the call. That's why we\n+// decrement them.\n+static uptr patch_pc(uptr pc) {\n+#ifdef __arm__\n+  // Cancel Thumb bit.\n+  pc = pc & (~1);\n+#endif\n+  return pc - 1;\n+}\n+\n+static void PrintStackFramePrefix(uptr frame_num, uptr pc) {\n+  Printf(\"    #%zu 0x%zx\", frame_num, pc);\n+}\n+\n+static void PrintSourceLocation(const char *file, int line, int column,\n+                                const char *strip_file_prefix) {\n+  CHECK(file);\n+  Printf(\" %s\", StripPathPrefix(file, strip_file_prefix));\n+  if (line > 0) {\n+    Printf(\":%d\", line);\n+    if (column > 0)\n+      Printf(\":%d\", column);\n+  }\n+}\n+\n+static void PrintModuleAndOffset(const char *module, uptr offset,\n+                                 const char *strip_file_prefix) {\n+  Printf(\" (%s+0x%zx)\", StripPathPrefix(module, strip_file_prefix), offset);\n+}\n+\n+void StackTrace::PrintStack(const uptr *addr, uptr size,\n+                            bool symbolize, const char *strip_file_prefix,\n+                            SymbolizeCallback symbolize_callback ) {\n+  MemoryMappingLayout proc_maps;\n+  InternalScopedBuffer<char> buff(kPageSize * 2);\n+  InternalScopedBuffer<AddressInfo> addr_frames(64);\n+  uptr frame_num = 0;\n+  for (uptr i = 0; i < size && addr[i]; i++) {\n+    uptr pc = patch_pc(addr[i]);\n+    uptr addr_frames_num = 0;  // The number of stack frames for current\n+                               // instruction address.\n+    if (symbolize_callback) {\n+      if (symbolize_callback((void*)pc, buff.data(), buff.size())) {\n+        addr_frames_num = 1;\n+        PrintStackFramePrefix(frame_num, pc);\n+        // We can't know anything about the string returned by external\n+        // symbolizer, but if it starts with filename, try to strip path prefix\n+        // from it.\n+        Printf(\" %s\\n\", StripPathPrefix(buff.data(), strip_file_prefix));\n+        frame_num++;\n+      }\n+    } else if (symbolize) {\n+      // Use our own (online) symbolizer, if necessary.\n+      addr_frames_num = SymbolizeCode(pc, addr_frames.data(),\n+                                      addr_frames.size());\n+      for (uptr j = 0; j < addr_frames_num; j++) {\n+        AddressInfo &info = addr_frames[j];\n+        PrintStackFramePrefix(frame_num, pc);\n+        if (info.function) {\n+          Printf(\" in %s\", info.function);\n+        }\n+        if (info.file) {\n+          PrintSourceLocation(info.file, info.line, info.column,\n+                              strip_file_prefix);\n+        } else if (info.module) {\n+          PrintModuleAndOffset(info.module, info.module_offset,\n+                               strip_file_prefix);\n+        }\n+        Printf(\"\\n\");\n+        info.Clear();\n+        frame_num++;\n+      }\n+    }\n+    if (addr_frames_num == 0) {\n+      // If online symbolization failed, try to output at least module and\n+      // offset for instruction.\n+      PrintStackFramePrefix(frame_num, pc);\n+      uptr offset;\n+      if (proc_maps.GetObjectNameAndOffset(pc, &offset,\n+                                           buff.data(), buff.size())) {\n+        PrintModuleAndOffset(buff.data(), offset, strip_file_prefix);\n+      }\n+      Printf(\"\\n\");\n+      frame_num++;\n+    }\n+  }\n+}\n+\n+uptr StackTrace::GetCurrentPc() {\n+  return GET_CALLER_PC();\n+}\n+\n+void StackTrace::FastUnwindStack(uptr pc, uptr bp,\n+                                 uptr stack_top, uptr stack_bottom) {\n+  CHECK(size == 0 && trace[0] == pc);\n+  size = 1;\n+  uptr *frame = (uptr*)bp;\n+  uptr *prev_frame = frame;\n+  while (frame >= prev_frame &&\n+         frame < (uptr*)stack_top - 2 &&\n+         frame > (uptr*)stack_bottom &&\n+         size < max_size) {\n+    uptr pc1 = frame[1];\n+    if (pc1 != pc) {\n+      trace[size++] = pc1;\n+    }\n+    prev_frame = frame;\n+    frame = (uptr*)frame[0];\n+  }\n+}\n+\n+// On 32-bits we don't compress stack traces.\n+// On 64-bits we compress stack traces: if a given pc differes slightly from\n+// the previous one, we record a 31-bit offset instead of the full pc.\n+SANITIZER_INTERFACE_ATTRIBUTE\n+uptr StackTrace::CompressStack(StackTrace *stack, u32 *compressed, uptr size) {\n+#if __WORDSIZE == 32\n+  // Don't compress, just copy.\n+  uptr res = 0;\n+  for (uptr i = 0; i < stack->size && i < size; i++) {\n+    compressed[i] = stack->trace[i];\n+    res++;\n+  }\n+  if (stack->size < size)\n+    compressed[stack->size] = 0;\n+#else  // 64 bits, compress.\n+  uptr prev_pc = 0;\n+  const uptr kMaxOffset = (1ULL << 30) - 1;\n+  uptr c_index = 0;\n+  uptr res = 0;\n+  for (uptr i = 0, n = stack->size; i < n; i++) {\n+    uptr pc = stack->trace[i];\n+    if (!pc) break;\n+    if ((s64)pc < 0) break;\n+    // Printf(\"C pc[%zu] %zx\\n\", i, pc);\n+    if (prev_pc - pc < kMaxOffset || pc - prev_pc < kMaxOffset) {\n+      uptr offset = (s64)(pc - prev_pc);\n+      offset |= (1U << 31);\n+      if (c_index >= size) break;\n+      // Printf(\"C co[%zu] offset %zx\\n\", i, offset);\n+      compressed[c_index++] = offset;\n+    } else {\n+      uptr hi = pc >> 32;\n+      uptr lo = (pc << 32) >> 32;\n+      CHECK_EQ((hi & (1 << 31)), 0);\n+      if (c_index + 1 >= size) break;\n+      // Printf(\"C co[%zu] hi/lo: %zx %zx\\n\", c_index, hi, lo);\n+      compressed[c_index++] = hi;\n+      compressed[c_index++] = lo;\n+    }\n+    res++;\n+    prev_pc = pc;\n+  }\n+  if (c_index < size)\n+    compressed[c_index] = 0;\n+  if (c_index + 1 < size)\n+    compressed[c_index + 1] = 0;\n+#endif  // __WORDSIZE\n+\n+  // debug-only code\n+#if 0\n+  StackTrace check_stack;\n+  UncompressStack(&check_stack, compressed, size);\n+  if (res < check_stack.size) {\n+    Printf(\"res %zu check_stack.size %zu; c_size %zu\\n\", res,\n+           check_stack.size, size);\n+  }\n+  // |res| may be greater than check_stack.size, because\n+  // UncompressStack(CompressStack(stack)) eliminates the 0x0 frames.\n+  CHECK(res >= check_stack.size);\n+  CHECK_EQ(0, REAL(memcmp)(check_stack.trace, stack->trace,\n+                          check_stack.size * sizeof(uptr)));\n+#endif\n+\n+  return res;\n+}\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void StackTrace::UncompressStack(StackTrace *stack,\n+                                 u32 *compressed, uptr size) {\n+#if __WORDSIZE == 32\n+  // Don't uncompress, just copy.\n+  stack->size = 0;\n+  for (uptr i = 0; i < size && i < kStackTraceMax; i++) {\n+    if (!compressed[i]) break;\n+    stack->size++;\n+    stack->trace[i] = compressed[i];\n+  }\n+#else  // 64 bits, uncompress\n+  uptr prev_pc = 0;\n+  stack->size = 0;\n+  for (uptr i = 0; i < size && stack->size < kStackTraceMax; i++) {\n+    u32 x = compressed[i];\n+    uptr pc = 0;\n+    if (x & (1U << 31)) {\n+      // Printf(\"U co[%zu] offset: %x\\n\", i, x);\n+      // this is an offset\n+      s32 offset = x;\n+      offset = (offset << 1) >> 1;  // remove the 31-byte and sign-extend.\n+      pc = prev_pc + offset;\n+      CHECK(pc);\n+    } else {\n+      // CHECK(i + 1 < size);\n+      if (i + 1 >= size) break;\n+      uptr hi = x;\n+      uptr lo = compressed[i+1];\n+      // Printf(\"U co[%zu] hi/lo: %zx %zx\\n\", i, hi, lo);\n+      i++;\n+      pc = (hi << 32) | lo;\n+      if (!pc) break;\n+    }\n+    // Printf(\"U pc[%zu] %zx\\n\", stack->size, pc);\n+    stack->trace[stack->size++] = pc;\n+    prev_pc = pc;\n+  }\n+#endif  // __WORDSIZE\n+}\n+\n+}  // namespace __sanitizer"}, {"sha": "a7934c65e1e0b35ca34c41abf82c862334b25cfe", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace.h", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,73 @@\n+//===-- sanitizer_stacktrace.h ----------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is shared between AddressSanitizer and ThreadSanitizer\n+// run-time libraries.\n+//===----------------------------------------------------------------------===//\n+#ifndef SANITIZER_STACKTRACE_H\n+#define SANITIZER_STACKTRACE_H\n+\n+#include \"sanitizer_internal_defs.h\"\n+\n+namespace __sanitizer {\n+\n+static const uptr kStackTraceMax = 256;\n+\n+struct StackTrace {\n+  typedef bool (*SymbolizeCallback)(const void *pc, char *out_buffer,\n+                                     int out_size);\n+  uptr size;\n+  uptr max_size;\n+  uptr trace[kStackTraceMax];\n+  static void PrintStack(const uptr *addr, uptr size,\n+                         bool symbolize, const char *strip_file_prefix,\n+                         SymbolizeCallback symbolize_callback);\n+  void CopyTo(uptr *dst, uptr dst_size) {\n+    for (uptr i = 0; i < size && i < dst_size; i++)\n+      dst[i] = trace[i];\n+    for (uptr i = size; i < dst_size; i++)\n+      dst[i] = 0;\n+  }\n+\n+  void CopyFrom(uptr *src, uptr src_size) {\n+    size = src_size;\n+    if (size > kStackTraceMax) size = kStackTraceMax;\n+    for (uptr i = 0; i < size; i++) {\n+      trace[i] = src[i];\n+    }\n+  }\n+\n+  void FastUnwindStack(uptr pc, uptr bp, uptr stack_top, uptr stack_bottom);\n+\n+  static uptr GetCurrentPc();\n+\n+  static uptr CompressStack(StackTrace *stack,\n+                            u32 *compressed, uptr size);\n+  static void UncompressStack(StackTrace *stack,\n+                              u32 *compressed, uptr size);\n+};\n+\n+}  // namespace __sanitizer\n+\n+// Use this macro if you want to print stack trace with the caller\n+// of the current function in the top frame.\n+#define GET_CALLER_PC_BP_SP \\\n+  uptr bp = GET_CURRENT_FRAME();              \\\n+  uptr pc = GET_CALLER_PC();                  \\\n+  uptr local_stack;                           \\\n+  uptr sp = (uptr)&local_stack\n+\n+// Use this macro if you want to print stack trace with the current\n+// function in the top frame.\n+#define GET_CURRENT_PC_BP_SP \\\n+  uptr bp = GET_CURRENT_FRAME();              \\\n+  uptr pc = StackTrace::GetCurrentPc();   \\\n+  uptr local_stack;                           \\\n+  uptr sp = (uptr)&local_stack\n+\n+\n+#endif  // SANITIZER_STACKTRACE_H"}, {"sha": "66ac3c8a24675d0154a2dfab8306cf411d882890", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer.cc", "status": "added", "additions": 311, "deletions": 0, "changes": 311, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.cc?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,311 @@\n+//===-- sanitizer_symbolizer.cc -------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is shared between AddressSanitizer and ThreadSanitizer\n+// run-time libraries. See sanitizer_symbolizer.h for details.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_common.h\"\n+#include \"sanitizer_placement_new.h\"\n+#include \"sanitizer_procmaps.h\"\n+#include \"sanitizer_symbolizer.h\"\n+\n+namespace __sanitizer {\n+\n+void AddressInfo::Clear() {\n+  InternalFree(module);\n+  InternalFree(function);\n+  InternalFree(file);\n+  internal_memset(this, 0, sizeof(AddressInfo));\n+}\n+\n+LoadedModule::LoadedModule(const char *module_name, uptr base_address) {\n+  full_name_ = internal_strdup(module_name);\n+  base_address_ = base_address;\n+  n_ranges_ = 0;\n+}\n+\n+void LoadedModule::addAddressRange(uptr beg, uptr end) {\n+  CHECK_LT(n_ranges_, kMaxNumberOfAddressRanges);\n+  ranges_[n_ranges_].beg = beg;\n+  ranges_[n_ranges_].end = end;\n+  n_ranges_++;\n+}\n+\n+bool LoadedModule::containsAddress(uptr address) const {\n+  for (uptr i = 0; i < n_ranges_; i++) {\n+    if (ranges_[i].beg <= address && address < ranges_[i].end)\n+      return true;\n+  }\n+  return false;\n+}\n+\n+// Extracts the prefix of \"str\" that consists of any characters not\n+// present in \"delims\" string, and copies this prefix to \"result\", allocating\n+// space for it.\n+// Returns a pointer to \"str\" after skipping extracted prefix and first\n+// delimiter char.\n+static const char *ExtractToken(const char *str, const char *delims,\n+                                char **result) {\n+  uptr prefix_len = internal_strcspn(str, delims);\n+  *result = (char*)InternalAlloc(prefix_len + 1);\n+  internal_memcpy(*result, str, prefix_len);\n+  (*result)[prefix_len] = '\\0';\n+  const char *prefix_end = str + prefix_len;\n+  if (*prefix_end != '\\0') prefix_end++;\n+  return prefix_end;\n+}\n+\n+// Same as ExtractToken, but converts extracted token to integer.\n+static const char *ExtractInt(const char *str, const char *delims,\n+                              int *result) {\n+  char *buff;\n+  const char *ret = ExtractToken(str, delims, &buff);\n+  if (buff != 0) {\n+    *result = internal_atoll(buff);\n+  }\n+  InternalFree(buff);\n+  return ret;\n+}\n+\n+// ExternalSymbolizer encapsulates communication between the tool and\n+// external symbolizer program, running in a different subprocess,\n+// For now we assume the following protocol:\n+// For each request of the form\n+//   <module_name> <module_offset>\n+// passed to STDIN, external symbolizer prints to STDOUT response:\n+//   <function_name>\n+//   <file_name>:<line_number>:<column_number>\n+//   <function_name>\n+//   <file_name>:<line_number>:<column_number>\n+//   ...\n+//   <empty line>\n+class ExternalSymbolizer {\n+ public:\n+  ExternalSymbolizer(const char *path, int input_fd, int output_fd)\n+      : path_(path),\n+        input_fd_(input_fd),\n+        output_fd_(output_fd),\n+        times_restarted_(0) {\n+    CHECK(path_);\n+    CHECK_NE(input_fd_, kInvalidFd);\n+    CHECK_NE(output_fd_, kInvalidFd);\n+  }\n+\n+  // Returns the number of frames for a given address, or zero if\n+  // symbolization failed.\n+  uptr SymbolizeCode(uptr addr, const char *module_name, uptr module_offset,\n+                     AddressInfo *frames, uptr max_frames) {\n+    CHECK(module_name);\n+    // FIXME: Make sure this buffer always has sufficient size to hold\n+    // large debug info.\n+    static const int kMaxBufferSize = 4096;\n+    InternalScopedBuffer<char> buffer(kMaxBufferSize);\n+    char *buffer_data = buffer.data();\n+    internal_snprintf(buffer_data, kMaxBufferSize, \"%s 0x%zx\\n\",\n+                      module_name, module_offset);\n+    if (!writeToSymbolizer(buffer_data, internal_strlen(buffer_data)))\n+      return 0;\n+\n+    if (!readFromSymbolizer(buffer_data, kMaxBufferSize))\n+      return 0;\n+    const char *str = buffer_data;\n+    uptr frame_id;\n+    CHECK_GT(max_frames, 0);\n+    for (frame_id = 0; frame_id < max_frames; frame_id++) {\n+      AddressInfo *info = &frames[frame_id];\n+      char *function_name = 0;\n+      str = ExtractToken(str, \"\\n\", &function_name);\n+      CHECK(function_name);\n+      if (function_name[0] == '\\0') {\n+        // There are no more frames.\n+        break;\n+      }\n+      info->Clear();\n+      info->FillAddressAndModuleInfo(addr, module_name, module_offset);\n+      info->function = function_name;\n+      // Parse <file>:<line>:<column> buffer.\n+      char *file_line_info = 0;\n+      str = ExtractToken(str, \"\\n\", &file_line_info);\n+      CHECK(file_line_info);\n+      const char *line_info = ExtractToken(file_line_info, \":\", &info->file);\n+      line_info = ExtractInt(line_info, \":\", &info->line);\n+      line_info = ExtractInt(line_info, \"\", &info->column);\n+      InternalFree(file_line_info);\n+\n+      // Functions and filenames can be \"??\", in which case we write 0\n+      // to address info to mark that names are unknown.\n+      if (0 == internal_strcmp(info->function, \"??\")) {\n+        InternalFree(info->function);\n+        info->function = 0;\n+      }\n+      if (0 == internal_strcmp(info->file, \"??\")) {\n+        InternalFree(info->file);\n+        info->file = 0;\n+      }\n+    }\n+    if (frame_id == 0) {\n+      // Make sure we return at least one frame.\n+      AddressInfo *info = &frames[0];\n+      info->Clear();\n+      info->FillAddressAndModuleInfo(addr, module_name, module_offset);\n+      frame_id = 1;\n+    }\n+    return frame_id;\n+  }\n+\n+  bool Restart() {\n+    if (times_restarted_ >= kMaxTimesRestarted) return false;\n+    times_restarted_++;\n+    internal_close(input_fd_);\n+    internal_close(output_fd_);\n+    return StartSymbolizerSubprocess(path_, &input_fd_, &output_fd_);\n+  }\n+\n+ private:\n+  bool readFromSymbolizer(char *buffer, uptr max_length) {\n+    if (max_length == 0)\n+      return true;\n+    uptr read_len = 0;\n+    while (true) {\n+      uptr just_read = internal_read(input_fd_, buffer + read_len,\n+                                     max_length - read_len);\n+      // We can't read 0 bytes, as we don't expect external symbolizer to close\n+      // its stdout.\n+      if (just_read == 0 || just_read == (uptr)-1) {\n+        Report(\"WARNING: Can't read from symbolizer at fd %d\\n\", input_fd_);\n+        return false;\n+      }\n+      read_len += just_read;\n+      // Empty line marks the end of symbolizer output.\n+      if (read_len >= 2 && buffer[read_len - 1] == '\\n' &&\n+                           buffer[read_len - 2] == '\\n') {\n+        break;\n+      }\n+    }\n+    return true;\n+  }\n+  bool writeToSymbolizer(const char *buffer, uptr length) {\n+    if (length == 0)\n+      return true;\n+    uptr write_len = internal_write(output_fd_, buffer, length);\n+    if (write_len == 0 || write_len == (uptr)-1) {\n+      Report(\"WARNING: Can't write to symbolizer at fd %d\\n\", output_fd_);\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  const char *path_;\n+  int input_fd_;\n+  int output_fd_;\n+\n+  static const uptr kMaxTimesRestarted = 5;\n+  uptr times_restarted_;\n+};\n+\n+static LowLevelAllocator symbolizer_allocator;  // Linker initialized.\n+\n+class Symbolizer {\n+ public:\n+  uptr SymbolizeCode(uptr addr, AddressInfo *frames, uptr max_frames) {\n+    if (max_frames == 0)\n+      return 0;\n+    LoadedModule *module = FindModuleForAddress(addr);\n+    if (module == 0)\n+      return 0;\n+    const char *module_name = module->full_name();\n+    uptr module_offset = addr - module->base_address();\n+    uptr actual_frames = 0;\n+    if (external_symbolizer_ == 0) {\n+      ReportExternalSymbolizerError(\n+          \"WARNING: Trying to symbolize code, but external \"\n+          \"symbolizer is not initialized!\\n\");\n+    } else {\n+      while (true) {\n+        actual_frames = external_symbolizer_->SymbolizeCode(\n+            addr, module_name, module_offset, frames, max_frames);\n+        if (actual_frames > 0) {\n+          // Symbolization was successful.\n+          break;\n+        }\n+        // Try to restart symbolizer subprocess. If we don't succeed, forget\n+        // about it and don't try to use it later.\n+        if (!external_symbolizer_->Restart()) {\n+          ReportExternalSymbolizerError(\n+              \"WARNING: Failed to use and restart external symbolizer!\\n\");\n+          external_symbolizer_ = 0;\n+          break;\n+        }\n+      }\n+    }\n+    if (external_symbolizer_ == 0) {\n+      // External symbolizer was not initialized or failed. Fill only data\n+      // about module name and offset.\n+      AddressInfo *info = &frames[0];\n+      info->Clear();\n+      info->FillAddressAndModuleInfo(addr, module_name, module_offset);\n+      return 1;\n+    }\n+    // Otherwise, the data was filled by external symbolizer.\n+    return actual_frames;\n+  }\n+  bool InitializeExternalSymbolizer(const char *path_to_symbolizer) {\n+    int input_fd, output_fd;\n+    if (!StartSymbolizerSubprocess(path_to_symbolizer, &input_fd, &output_fd))\n+      return false;\n+    void *mem = symbolizer_allocator.Allocate(sizeof(ExternalSymbolizer));\n+    external_symbolizer_ = new(mem) ExternalSymbolizer(path_to_symbolizer,\n+                                                       input_fd, output_fd);\n+    return true;\n+  }\n+\n+ private:\n+  LoadedModule *FindModuleForAddress(uptr address) {\n+    if (modules_ == 0) {\n+      modules_ = (LoadedModule*)(symbolizer_allocator.Allocate(\n+          kMaxNumberOfModuleContexts * sizeof(LoadedModule)));\n+      CHECK(modules_);\n+      n_modules_ = GetListOfModules(modules_, kMaxNumberOfModuleContexts);\n+      CHECK_GT(n_modules_, 0);\n+      CHECK_LT(n_modules_, kMaxNumberOfModuleContexts);\n+    }\n+    for (uptr i = 0; i < n_modules_; i++) {\n+      if (modules_[i].containsAddress(address)) {\n+        return &modules_[i];\n+      }\n+    }\n+    return 0;\n+  }\n+  void ReportExternalSymbolizerError(const char *msg) {\n+    // Don't use atomics here for now, as SymbolizeCode can't be called\n+    // from multiple threads anyway.\n+    static bool reported;\n+    if (!reported) {\n+      Report(msg);\n+      reported = true;\n+    }\n+  }\n+\n+  static const uptr kMaxNumberOfModuleContexts = 4096;\n+  LoadedModule *modules_;  // Array of module descriptions is leaked.\n+  uptr n_modules_;\n+\n+  ExternalSymbolizer *external_symbolizer_;  // Leaked.\n+};\n+\n+static Symbolizer symbolizer;  // Linker initialized.\n+\n+uptr SymbolizeCode(uptr address, AddressInfo *frames, uptr max_frames) {\n+  return symbolizer.SymbolizeCode(address, frames, max_frames);\n+}\n+\n+bool InitializeExternalSymbolizer(const char *path_to_symbolizer) {\n+  return symbolizer.InitializeExternalSymbolizer(path_to_symbolizer);\n+}\n+\n+}  // namespace __sanitizer"}, {"sha": "83adf02528262aedcb282aafefd6d2d2af5fb681", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer.h", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.h?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932", "patch": "@@ -0,0 +1,97 @@\n+//===-- sanitizer_symbolizer.h ----------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Symbolizer is intended to be used by both\n+// AddressSanitizer and ThreadSanitizer to symbolize a given\n+// address. It is an analogue of addr2line utility and allows to map\n+// instruction address to a location in source code at run-time.\n+//\n+// Symbolizer is planned to use debug information (in DWARF format)\n+// in a binary via interface defined in \"llvm/DebugInfo/DIContext.h\"\n+//\n+// Symbolizer code should be called from the run-time library of\n+// dynamic tools, and generally should not call memory allocation\n+// routines or other system library functions intercepted by those tools.\n+// Instead, Symbolizer code should use their replacements, defined in\n+// \"compiler-rt/lib/sanitizer_common/sanitizer_libc.h\".\n+//===----------------------------------------------------------------------===//\n+#ifndef SANITIZER_SYMBOLIZER_H\n+#define SANITIZER_SYMBOLIZER_H\n+\n+#include \"sanitizer_internal_defs.h\"\n+#include \"sanitizer_libc.h\"\n+// WARNING: Do not include system headers here. See details above.\n+\n+namespace __sanitizer {\n+\n+struct AddressInfo {\n+  uptr address;\n+  char *module;\n+  uptr module_offset;\n+  char *function;\n+  char *file;\n+  int line;\n+  int column;\n+\n+  AddressInfo() {\n+    internal_memset(this, 0, sizeof(AddressInfo));\n+  }\n+  // Deletes all strings and sets all fields to zero.\n+  void Clear();\n+\n+  void FillAddressAndModuleInfo(uptr addr, const char *mod_name,\n+                                uptr mod_offset) {\n+    address = addr;\n+    module = internal_strdup(mod_name);\n+    module_offset = mod_offset;\n+  }\n+};\n+\n+// Fills at most \"max_frames\" elements of \"frames\" with descriptions\n+// for a given address (in all inlined functions). Returns the number\n+// of descriptions actually filled.\n+// This function should NOT be called from two threads simultaneously.\n+uptr SymbolizeCode(uptr address, AddressInfo *frames, uptr max_frames);\n+\n+// Starts external symbolizer program in a subprocess. Sanitizer communicates\n+// with external symbolizer via pipes.\n+bool InitializeExternalSymbolizer(const char *path_to_symbolizer);\n+\n+class LoadedModule {\n+ public:\n+  LoadedModule(const char *module_name, uptr base_address);\n+  void addAddressRange(uptr beg, uptr end);\n+  bool containsAddress(uptr address) const;\n+\n+  const char *full_name() const { return full_name_; }\n+  uptr base_address() const { return base_address_; }\n+\n+ private:\n+  struct AddressRange {\n+    uptr beg;\n+    uptr end;\n+  };\n+  char *full_name_;\n+  uptr base_address_;\n+  static const uptr kMaxNumberOfAddressRanges = 8;\n+  AddressRange ranges_[kMaxNumberOfAddressRanges];\n+  uptr n_ranges_;\n+};\n+\n+// Creates external symbolizer connected via pipe, user should write\n+// to output_fd and read from input_fd.\n+bool StartSymbolizerSubprocess(const char *path_to_symbolizer,\n+                               int *input_fd, int *output_fd);\n+\n+// OS-dependent function that fills array with descriptions of at most\n+// \"max_modules\" currently loaded modules. Returns the number of\n+// initialized modules.\n+uptr GetListOfModules(LoadedModule *modules, uptr max_modules);\n+\n+}  // namespace __sanitizer\n+\n+#endif  // SANITIZER_SYMBOLIZER_H"}, {"sha": "50e39a75c3a4ea0962fd9921025c4133669d4c6a", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_linux.cc", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_linux.cc?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932"}, {"sha": "c5ca616d89d3b9fa9403310580ab70b9f5df861f", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_mac.cc", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_mac.cc?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932"}, {"sha": "7e6ba53e128a4c33f55f8c5a358ca976cc5478f5", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_win.cc", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_win.cc?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932"}, {"sha": "314852304d837279a4535b4773cb2b57fa887ddb", "filename": "libsanitizer/sanitizer_common/sanitizer_win.cc", "status": "added", "additions": 205, "deletions": 0, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35db108b96cac4fd3f2b62024ed93ac006ff932/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cc?ref=f35db108b96cac4fd3f2b62024ed93ac006ff932"}]}