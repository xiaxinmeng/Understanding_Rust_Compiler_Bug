{"sha": "396b535a72eb44422b3b8f0f1c220b11ab34b24d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzk2YjUzNWE3MmViNDQ0MjJiM2I4ZjBmMWMyMjBiMTFhYjM0YjI0ZA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2006-01-03T09:06:36Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2006-01-03T09:06:36Z"}, "message": "backport: sync.md: New file.\n\n\tMerge from gomp-branch.\n\t* config/sparc/sync.md: New file.\n\t* config/sparc/sparc.md (UNSPECV_MEMBAR, UNSPECV_CAS, UNSPECV_SWAP,\n\tUNSPECV_LDSTUB): New constants.\n\t* config/sparc/sparc.c (sparc_expand_compare_and_swap_12): New function.\n\t* config/sparc/predicates.md (memory_reg_operand): New predicate.\n\t* config/sparc/sparc-protos.h (sparc_expand_compare_and_swap_12): New\n\tprototype.\n\n\t* gcc.dg/ia64-sync-1.c: On sparc*-*-*, pass -mcpu=v9.\n\t* gcc.dg/ia64-sync-2.c: Likewise.\n\t* gcc.dg/ia64-sync-3.c: Likewise.\n\t* gcc.dg/ia64-sync-4.c: Likewise.\n\t* gcc.dg/sync-2.c: Likewise.\n\t* lib/target-supports.exp (sync_char_short, sync_int_long): Indicate\n\tthat sparc64-*-* and sparcv9-*-* supports sync builtins.\n\nFrom-SVN: r109271", "tree": {"sha": "dab8b9cb403c11fdc457493e3669ac22aeb9fb22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dab8b9cb403c11fdc457493e3669ac22aeb9fb22"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/396b535a72eb44422b3b8f0f1c220b11ab34b24d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/396b535a72eb44422b3b8f0f1c220b11ab34b24d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/396b535a72eb44422b3b8f0f1c220b11ab34b24d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/396b535a72eb44422b3b8f0f1c220b11ab34b24d/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "357d956ebd51983d4a15dcd4de6cb49dba7db9ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/357d956ebd51983d4a15dcd4de6cb49dba7db9ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/357d956ebd51983d4a15dcd4de6cb49dba7db9ca"}], "stats": {"total": 358, "additions": 356, "deletions": 2}, "files": [{"sha": "dd9feb59d05275eb497727bda7c79cb451cbf86b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/396b535a72eb44422b3b8f0f1c220b11ab34b24d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/396b535a72eb44422b3b8f0f1c220b11ab34b24d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=396b535a72eb44422b3b8f0f1c220b11ab34b24d", "patch": "@@ -1,3 +1,14 @@\n+2006-01-03  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tMerge from gomp-branch.\n+\t* config/sparc/sync.md: New file.\n+\t* config/sparc/sparc.md (UNSPECV_MEMBAR, UNSPECV_CAS, UNSPECV_SWAP,\n+\tUNSPECV_LDSTUB): New constants.\n+\t* config/sparc/sparc.c (sparc_expand_compare_and_swap_12): New function.\n+\t* config/sparc/predicates.md (memory_reg_operand): New predicate.\n+\t* config/sparc/sparc-protos.h (sparc_expand_compare_and_swap_12): New\n+\tprototype.\n+\n 2006-01-03  Roger Sayle  <roger@eyesopen.com>\n \n \t* combine.c (reg_subword_p): New predicate to test whether the"}, {"sha": "048d651c2e57a8fa6937a92997a3a0374e4408d0", "filename": "gcc/config/sparc/predicates.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/396b535a72eb44422b3b8f0f1c220b11ab34b24d/gcc%2Fconfig%2Fsparc%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/396b535a72eb44422b3b8f0f1c220b11ab34b24d/gcc%2Fconfig%2Fsparc%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fpredicates.md?ref=396b535a72eb44422b3b8f0f1c220b11ab34b24d", "patch": "@@ -470,3 +470,9 @@\n ;; and (xor ... (not ...)) to (not (xor ...)).  */\n (define_predicate \"cc_arith_not_operator\"\n   (match_code \"and,ior\"))\n+\n+;; Return true if OP is memory operand with just [%reg] addressing mode.\n+(define_predicate \"memory_reg_operand\"\n+  (and (match_code \"mem\")\n+       (and (match_operand 0 \"memory_operand\")\n+\t    (match_test \"REG_P (XEXP (op, 0))\"))))"}, {"sha": "4fb862cc9081cf462b3d215c3f1255fb53683cc9", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/396b535a72eb44422b3b8f0f1c220b11ab34b24d/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/396b535a72eb44422b3b8f0f1c220b11ab34b24d/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=396b535a72eb44422b3b8f0f1c220b11ab34b24d", "patch": "@@ -114,6 +114,7 @@ extern int v9_regcmp_p (enum rtx_code);\n extern int sparc_check_64 (rtx, rtx);\n extern rtx gen_df_reg (rtx, int);\n extern int sparc_extra_constraint_check (rtx, int, int);\n+extern void sparc_expand_compare_and_swap_12 (rtx, rtx, rtx, rtx);\n #endif /* RTX_CODE */\n \n #endif /* __SPARC_PROTOS_H__ */"}, {"sha": "59ff2e17b861a58f9eeb12d623165acc19011c91", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/396b535a72eb44422b3b8f0f1c220b11ab34b24d/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/396b535a72eb44422b3b8f0f1c220b11ab34b24d/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=396b535a72eb44422b3b8f0f1c220b11ab34b24d", "patch": "@@ -8710,4 +8710,106 @@ sparc_file_end (void)\n     file_end_indicate_exec_stack ();\n }\n \n+/* Expand code to perform a 8 or 16-bit compare and swap by doing 32-bit\n+   compare and swap on the word containing the byte or half-word.  */\n+\n+void\n+sparc_expand_compare_and_swap_12 (rtx result, rtx mem, rtx oldval, rtx newval)\n+{\n+  rtx addr1 = force_reg (Pmode, XEXP (mem, 0));\n+  rtx addr = gen_reg_rtx (Pmode);\n+  rtx off = gen_reg_rtx (SImode);\n+  rtx oldv = gen_reg_rtx (SImode);\n+  rtx newv = gen_reg_rtx (SImode);\n+  rtx oldvalue = gen_reg_rtx (SImode);\n+  rtx newvalue = gen_reg_rtx (SImode);\n+  rtx res = gen_reg_rtx (SImode);\n+  rtx resv = gen_reg_rtx (SImode);\n+  rtx memsi, val, mask, end_label, loop_label, cc;\n+\n+  emit_insn (gen_rtx_SET (VOIDmode, addr,\n+\t\t\t  gen_rtx_AND (Pmode, addr1, GEN_INT (-4))));\n+\n+  if (Pmode != SImode)\n+    addr1 = gen_lowpart (SImode, addr1);\n+  emit_insn (gen_rtx_SET (VOIDmode, off,\n+\t\t\t  gen_rtx_AND (SImode, addr1, GEN_INT (3))));\n+\n+  memsi = gen_rtx_MEM (SImode, addr);\n+  MEM_VOLATILE_P (memsi) = MEM_VOLATILE_P (mem);\n+\n+  val = force_reg (SImode, memsi);\n+\n+  emit_insn (gen_rtx_SET (VOIDmode, off,\n+\t\t\t  gen_rtx_XOR (SImode, off,\n+\t\t\t\t       GEN_INT (GET_MODE (mem) == QImode\n+\t\t\t\t\t\t? 3 : 2))));\n+\n+  emit_insn (gen_rtx_SET (VOIDmode, off,\n+\t\t\t  gen_rtx_ASHIFT (SImode, off, GEN_INT (3))));\n+\n+  if (GET_MODE (mem) == QImode)\n+    mask = force_reg (SImode, GEN_INT (0xff));\n+  else\n+    mask = force_reg (SImode, GEN_INT (0xffff));\n+\n+  emit_insn (gen_rtx_SET (VOIDmode, mask,\n+\t\t\t  gen_rtx_ASHIFT (SImode, mask, off)));\n+\n+  emit_insn (gen_rtx_SET (VOIDmode, val,\n+\t\t\t  gen_rtx_AND (SImode, gen_rtx_NOT (SImode, mask),\n+\t\t\t\t       val)));\n+\n+  oldval = gen_lowpart (SImode, oldval);\n+  emit_insn (gen_rtx_SET (VOIDmode, oldv,\n+\t\t\t  gen_rtx_ASHIFT (SImode, oldval, off)));\n+\n+  newval = gen_lowpart_common (SImode, newval);\n+  emit_insn (gen_rtx_SET (VOIDmode, newv,\n+\t\t\t  gen_rtx_ASHIFT (SImode, newval, off)));\n+\n+  emit_insn (gen_rtx_SET (VOIDmode, oldv,\n+\t\t\t  gen_rtx_AND (SImode, oldv, mask)));\n+\n+  emit_insn (gen_rtx_SET (VOIDmode, newv,\n+\t\t\t  gen_rtx_AND (SImode, newv, mask)));\n+\n+  end_label = gen_label_rtx ();\n+  loop_label = gen_label_rtx ();\n+  emit_label (loop_label);\n+\n+  emit_insn (gen_rtx_SET (VOIDmode, oldvalue,\n+\t\t\t  gen_rtx_IOR (SImode, oldv, val)));\n+\n+  emit_insn (gen_rtx_SET (VOIDmode, newvalue,\n+\t\t\t  gen_rtx_IOR (SImode, newv, val)));\n+\n+  emit_insn (gen_sync_compare_and_swapsi (res, memsi, oldvalue, newvalue));\n+\n+  emit_cmp_and_jump_insns (res, oldvalue, EQ, NULL, SImode, 0, end_label);\n+\n+  emit_insn (gen_rtx_SET (VOIDmode, resv,\n+\t\t\t  gen_rtx_AND (SImode, gen_rtx_NOT (SImode, mask),\n+\t\t\t\t       res)));\n+\n+  sparc_compare_op0 = resv;\n+  sparc_compare_op1 = val;\n+  cc = gen_compare_reg (NE);\n+\n+  emit_insn (gen_rtx_SET (VOIDmode, val, resv));\n+\n+  sparc_compare_emitted = cc;\n+  emit_jump_insn (gen_bne (loop_label));\n+\n+  emit_label (end_label);\n+\n+  emit_insn (gen_rtx_SET (VOIDmode, res,\n+\t\t\t  gen_rtx_AND (SImode, res, mask)));\n+\n+  emit_insn (gen_rtx_SET (VOIDmode, res,\n+\t\t\t  gen_rtx_LSHIFTRT (SImode, res, off)));\n+\n+  emit_move_insn (result, gen_lowpart (GET_MODE (result), res));\n+}\n+\n #include \"gt-sparc.h\""}, {"sha": "10727cb3416cc1e7dc84859a29867c32e044182a", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/396b535a72eb44422b3b8f0f1c220b11ab34b24d/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/396b535a72eb44422b3b8f0f1c220b11ab34b24d/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=396b535a72eb44422b3b8f0f1c220b11ab34b24d", "patch": "@@ -69,6 +69,10 @@\n    (UNSPECV_FLUSH\t\t4)\n    (UNSPECV_SETJMP\t\t5)\n    (UNSPECV_SAVEW\t\t6)\n+   (UNSPECV_MEMBAR\t\t7)\n+   (UNSPECV_CAS\t\t\t8)\n+   (UNSPECV_SWAP\t\t9)\n+   (UNSPECV_LDSTUB\t\t10)\n   ])\n \n ;; The upper 32 fp regs on the v9 can't hold SFmode values.  To deal with this\n@@ -8476,3 +8480,5 @@\n   \"pdist\\t%1, %2, %0\"\n   [(set_attr \"type\" \"fga\")\n    (set_attr \"fptype\" \"double\")])\n+\n+(include \"sync.md\")"}, {"sha": "133792127e5c55681de14f5efcc2aa8cb7ea8762", "filename": "gcc/config/sparc/sync.md", "status": "added", "additions": 208, "deletions": 0, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/396b535a72eb44422b3b8f0f1c220b11ab34b24d/gcc%2Fconfig%2Fsparc%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/396b535a72eb44422b3b8f0f1c220b11ab34b24d/gcc%2Fconfig%2Fsparc%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsync.md?ref=396b535a72eb44422b3b8f0f1c220b11ab34b24d", "patch": "@@ -0,0 +1,208 @@\n+;; GCC machine description for SPARC synchronization instructions.\n+;; Copyright (C) 2005\n+;; Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+;; Boston, MA 02110-1301, USA.\n+\n+(define_mode_macro I12MODE [QI HI])\n+(define_mode_macro I24MODE [HI SI])\n+(define_mode_macro I48MODE [SI (DI \"TARGET_ARCH64 || TARGET_V8PLUS\")])\n+(define_mode_attr modesuffix [(SI \"\") (DI \"x\")])\n+\n+(define_expand \"memory_barrier\"\n+  [(set (mem:BLK (match_dup 0))\n+\t(unspec_volatile:BLK [(mem:BLK (match_dup 0)) (match_dup 1)]\n+\t\t\t     UNSPECV_MEMBAR))]\n+  \"TARGET_V8 || TARGET_V9\"\n+{\n+  operands[0] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (DImode));\n+  MEM_VOLATILE_P (operands[0]) = 1;\n+  if (TARGET_V9)\n+    /* member #StoreStore | #LoadStore | #StoreLoad | #LoadLoad */\n+    operands[1] = GEN_INT (15);\n+  else\n+    /* stbar */\n+    operands[1] = GEN_INT (8);\n+})\n+\n+(define_insn \"*stbar\"\n+  [(set (match_operand:BLK 0 \"\" \"\")\n+\t(unspec_volatile:BLK [(match_operand:BLK 1 \"\" \"\")\n+\t\t\t      (const_int 8)] UNSPECV_MEMBAR))]\n+  \"TARGET_V8\"\n+  \"stbar\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_insn \"*membar\"\n+  [(set (match_operand:BLK 0 \"\" \"\")\n+\t(unspec_volatile:BLK [(match_operand:BLK 1 \"\" \"\")\n+\t\t\t      (match_operand:SI 2 \"immediate_operand\" \"I\")]\n+\t\t\t      UNSPECV_MEMBAR))]\n+  \"TARGET_V9\"\n+  \"membar\\t%2\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_expand \"sync_compare_and_swap<mode>\"\n+  [(match_operand:I12MODE 0 \"register_operand\" \"\")\n+   (match_operand:I12MODE 1 \"memory_operand\" \"\")\n+   (match_operand:I12MODE 2 \"register_operand\" \"\")\n+   (match_operand:I12MODE 3 \"register_operand\" \"\")]\n+  \"TARGET_V9\"\n+{\n+  sparc_expand_compare_and_swap_12 (operands[0], operands[1],\n+\t\t\t\t    operands[2], operands[3]);\n+  DONE;\n+})\n+\n+(define_expand \"sync_compare_and_swap<mode>\"\n+  [(parallel\n+     [(set (match_operand:I48MODE 0 \"register_operand\" \"=r\")\n+\t   (match_operand:I48MODE 1 \"memory_operand\" \"\"))\n+      (set (match_dup 1)\n+\t   (unspec_volatile:I48MODE\n+\t     [(match_operand:I48MODE 2 \"register_operand\" \"\")\n+\t      (match_operand:I48MODE 3 \"register_operand\" \"\")]\n+\t     UNSPECV_CAS))])]\n+  \"TARGET_V9\"\n+{\n+  if (! REG_P (XEXP (operands[1], 0)))\n+    {\n+      rtx addr = force_reg (Pmode, XEXP (operands[1], 0));\n+      operands[1] = replace_equiv_address (operands[1], addr);\n+    }\n+  emit_insn (gen_memory_barrier ());\n+})\n+\n+(define_insn \"*sync_compare_and_swap<mode>\"\n+  [(set (match_operand:I48MODE 0 \"register_operand\" \"=r\")\n+\t(match_operand:I48MODE 1 \"memory_reg_operand\" \"+m\"))\n+   (set (match_dup 1)\n+\t(unspec_volatile:I48MODE\n+\t  [(match_operand:I48MODE 2 \"register_operand\" \"r\")\n+\t   (match_operand:I48MODE 3 \"register_operand\" \"0\")]\n+\t  UNSPECV_CAS))]\n+  \"TARGET_V9 && (<MODE>mode == SImode || TARGET_ARCH64)\"\n+  \"cas<modesuffix>\\t%1, %2, %0\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_insn \"*sync_compare_and_swapdi_v8plus\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=h\")\n+\t(match_operand:DI 1 \"memory_reg_operand\" \"+m\"))\n+   (set (match_dup 1)\n+\t(unspec_volatile:DI\n+\t  [(match_operand:DI 2 \"register_operand\" \"h\")\n+\t   (match_operand:DI 3 \"register_operand\" \"0\")]\n+\t  UNSPECV_CAS))]\n+  \"TARGET_V8PLUS\"\n+{\n+  if (sparc_check_64 (operands[3], insn) <= 0)\n+    output_asm_insn (\"srl\\t%L3, 0, %L3\", operands);\n+  output_asm_insn (\"sllx\\t%H3, 32, %H3\", operands);\n+  output_asm_insn (\"or\\t%L3, %H3, %L3\", operands);\n+  if (sparc_check_64 (operands[2], insn) <= 0)\n+    output_asm_insn (\"srl\\t%L2, 0, %L2\", operands);\n+  output_asm_insn (\"sllx\\t%H2, 32, %H3\", operands);\n+  output_asm_insn (\"or\\t%L2, %H3, %H3\", operands);\n+  output_asm_insn (\"casx\\t%1, %H3, %L3\", operands);\n+  return \"srlx\\t%L3, 32, %H3\";\n+}\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_expand \"sync_lock_test_and_set<mode>\"\n+  [(match_operand:I12MODE 0 \"register_operand\" \"\")\n+   (match_operand:I12MODE 1 \"memory_operand\" \"\")\n+   (match_operand:I12MODE 2 \"arith_operand\" \"\")]\n+  \"!TARGET_V9\"\n+{\n+  if (operands[2] != const1_rtx)\n+    FAIL;\n+  if (TARGET_V8)\n+    emit_insn (gen_memory_barrier ());\n+  if (<MODE>mode != QImode)\n+    operands[1] = adjust_address (operands[1], QImode, 0);\n+  emit_insn (gen_ldstub<mode> (operands[0], operands[1]));\n+  DONE;\n+})\n+\n+(define_expand \"sync_lock_test_and_setsi\"\n+  [(parallel\n+     [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t   (unspec_volatile:SI [(match_operand:SI 1 \"memory_operand\" \"\")]\n+\t\t\t       UNSPECV_SWAP))\n+      (set (match_dup 1)\n+\t   (match_operand:SI 2 \"arith_operand\" \"\"))])]\n+  \"\"\n+{\n+  if (! TARGET_V8 && ! TARGET_V9)\n+    {\n+      if (operands[2] != const1_rtx)\n+\tFAIL;\n+      operands[1] = adjust_address (operands[1], QImode, 0);\n+      emit_insn (gen_ldstubsi (operands[0], operands[1]));\n+      DONE;\n+    }\n+  emit_insn (gen_memory_barrier ());\n+  operands[2] = force_reg (SImode, operands[2]);\n+})\n+\n+(define_insn \"*swapsi\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(unspec_volatile:SI [(match_operand:SI 1 \"memory_operand\" \"+m\")]\n+\t\t\t    UNSPECV_SWAP))\n+   (set (match_dup 1)\n+\t(match_operand:SI 2 \"register_operand\" \"0\"))]\n+  \"TARGET_V8 || TARGET_V9\"\n+  \"swap\\t%1, %0\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_expand \"ldstubqi\"\n+  [(parallel [(set (match_operand:QI 0 \"register_operand\" \"\")\n+\t\t   (unspec_volatile:QI [(match_operand:QI 1 \"memory_operand\" \"\")]\n+\t\t\t\t       UNSPECV_LDSTUB))\n+\t      (set (match_dup 1) (const_int -1))])]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"ldstub<mode>\"\n+  [(parallel [(set (match_operand:I24MODE 0 \"register_operand\" \"\")\n+\t\t   (zero_extend:I24MODE\n+\t\t      (unspec_volatile:QI [(match_operand:QI 1 \"memory_operand\" \"\")]\n+\t\t\t\t\t  UNSPECV_LDSTUB)))\n+\t      (set (match_dup 1) (const_int -1))])]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*ldstubqi\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(unspec_volatile:QI [(match_operand:QI 1 \"memory_operand\" \"+m\")]\n+\t\t\t    UNSPECV_LDSTUB))\n+   (set (match_dup 1) (const_int -1))]\n+  \"\"\n+  \"ldstub\\t%1, %0\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_insn \"*ldstub<mode>\"\n+  [(set (match_operand:I24MODE 0 \"register_operand\" \"=r\")\n+\t(zero_extend:I24MODE\n+\t  (unspec_volatile:QI [(match_operand:QI 1 \"memory_operand\" \"+m\")]\n+\t\t\t      UNSPECV_LDSTUB)))\n+   (set (match_dup 1) (const_int -1))]\n+  \"\"\n+  \"ldstub\\t%1, %0\"\n+  [(set_attr \"type\" \"multi\")])"}, {"sha": "1acf301b8de62baf93b1e281d6312830694fa056", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/396b535a72eb44422b3b8f0f1c220b11ab34b24d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/396b535a72eb44422b3b8f0f1c220b11ab34b24d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=396b535a72eb44422b3b8f0f1c220b11ab34b24d", "patch": "@@ -1,3 +1,14 @@\n+2006-01-03  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tMerge from gomp-branch.\n+\t* gcc.dg/ia64-sync-1.c: On sparc*-*-*, pass -mcpu=v9.\n+\t* gcc.dg/ia64-sync-2.c: Likewise.\n+\t* gcc.dg/ia64-sync-3.c: Likewise.\n+\t* gcc.dg/ia64-sync-4.c: Likewise.\n+\t* gcc.dg/sync-2.c: Likewise.\n+\t* lib/target-supports.exp (sync_char_short, sync_int_long): Indicate\n+\tthat sparc64-*-* and sparcv9-*-* supports sync builtins.\n+\n 2006-01-02  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/25635"}, {"sha": "8f4512e4fbfdf3f3938b81435af39d1371776384", "filename": "gcc/testsuite/gcc.dg/ia64-sync-1.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/396b535a72eb44422b3b8f0f1c220b11ab34b24d/gcc%2Ftestsuite%2Fgcc.dg%2Fia64-sync-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/396b535a72eb44422b3b8f0f1c220b11ab34b24d/gcc%2Ftestsuite%2Fgcc.dg%2Fia64-sync-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fia64-sync-1.c?ref=396b535a72eb44422b3b8f0f1c220b11ab34b24d", "patch": "@@ -2,6 +2,7 @@\n /* { dg-require-effective-target sync_int_long } */\n /* { dg-options } */\n /* { dg-options \"-march=i486\" { target { { i?86-*-* x86_64-*-* } && ilp32 } } } */\n+/* { dg-options \"-mcpu=v9\" { target sparc*-*-* } } */\n \n /* Test basic functionality of the intrinsics.  The operations should\n    not be optimized away if no one checks the return values.  */"}, {"sha": "bb8c728bea38d265a4d40dc7671c6e2334af4bcf", "filename": "gcc/testsuite/gcc.dg/ia64-sync-2.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/396b535a72eb44422b3b8f0f1c220b11ab34b24d/gcc%2Ftestsuite%2Fgcc.dg%2Fia64-sync-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/396b535a72eb44422b3b8f0f1c220b11ab34b24d/gcc%2Ftestsuite%2Fgcc.dg%2Fia64-sync-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fia64-sync-2.c?ref=396b535a72eb44422b3b8f0f1c220b11ab34b24d", "patch": "@@ -2,6 +2,7 @@\n /* { dg-require-effective-target sync_int_long } */\n /* { dg-options } */\n /* { dg-options \"-march=i486\" { target { { i?86-*-* x86_64-*-* } && ilp32 } } } */\n+/* { dg-options \"-mcpu=v9\" { target sparc*-*-* } } */\n \n /* Test basic functionality of the intrinsics.  */\n "}, {"sha": "d093cdd4cb19075947ef68703161d68f88a9ca38", "filename": "gcc/testsuite/gcc.dg/ia64-sync-3.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/396b535a72eb44422b3b8f0f1c220b11ab34b24d/gcc%2Ftestsuite%2Fgcc.dg%2Fia64-sync-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/396b535a72eb44422b3b8f0f1c220b11ab34b24d/gcc%2Ftestsuite%2Fgcc.dg%2Fia64-sync-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fia64-sync-3.c?ref=396b535a72eb44422b3b8f0f1c220b11ab34b24d", "patch": "@@ -2,6 +2,7 @@\n /* { dg-require-effective-target sync_int_long } */\n /* { dg-options } */\n /* { dg-options \"-march=i486\" { target { { i?86-*-* x86_64-*-* } && ilp32 } } } */\n+/* { dg-options \"-mcpu=v9\" { target sparc*-*-* } } */\n \n /* Test basic functionality of the intrinsics.  */\n "}, {"sha": "e78fb4cf82529f7139f04f458c1aa4818265b56d", "filename": "gcc/testsuite/gcc.dg/ia64-sync-4.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/396b535a72eb44422b3b8f0f1c220b11ab34b24d/gcc%2Ftestsuite%2Fgcc.dg%2Fia64-sync-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/396b535a72eb44422b3b8f0f1c220b11ab34b24d/gcc%2Ftestsuite%2Fgcc.dg%2Fia64-sync-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fia64-sync-4.c?ref=396b535a72eb44422b3b8f0f1c220b11ab34b24d", "patch": "@@ -2,6 +2,7 @@\n /* { dg-require-effective-target sync_int_long } */\n /* { dg-options \"-O2 -finline-functions\" } */\n /* { dg-options \"-march=i486\" { target { { i?86-*-* x86_64-*-* } && ilp32 } } } */\n+/* { dg-options \"-mcpu=v9\" { target sparc*-*-* } } */\n \n /* Test inlining __sync_bool_compare_and_swap.  */\n "}, {"sha": "c82d66521ca1edb2b3e67433e816e27ebbced76e", "filename": "gcc/testsuite/gcc.dg/sync-2.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/396b535a72eb44422b3b8f0f1c220b11ab34b24d/gcc%2Ftestsuite%2Fgcc.dg%2Fsync-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/396b535a72eb44422b3b8f0f1c220b11ab34b24d/gcc%2Ftestsuite%2Fgcc.dg%2Fsync-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsync-2.c?ref=396b535a72eb44422b3b8f0f1c220b11ab34b24d", "patch": "@@ -1,6 +1,7 @@\n /* { dg-do run } */\n /* { dg-require-effective-target sync_char_short } */\n /* { dg-options \"-march=i486\" { target { { i?86-*-* x86_64-*-* } && ilp32 } } } */\n+/* { dg-options \"-mcpu=v9\" { target sparc*-*-* } } */\n \n /* Test functionality of the intrinsics for 'short' and 'char'.  */\n "}, {"sha": "2e91a161eeb84772651e65fe3b82237d15217b7d", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/396b535a72eb44422b3b8f0f1c220b11ab34b24d/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/396b535a72eb44422b3b8f0f1c220b11ab34b24d/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=396b535a72eb44422b3b8f0f1c220b11ab34b24d", "patch": "@@ -1356,7 +1356,9 @@ proc check_effective_target_sync_int_long { } {\n \t     || [istarget x86_64-*-*]\n \t     || [istarget alpha*-*-*] \n \t     || [istarget s390*-*-*] \n-\t     || [istarget powerpc*-*-*] } {\n+\t     || [istarget powerpc*-*-*]\n+\t     || [istarget sparc64-*-*]\n+\t     || [istarget sparcv9-*-*] } {\n            set et_sync_int_long_saved 1\n         }\n     }\n@@ -1381,7 +1383,9 @@ proc check_effective_target_sync_char_short { } {\n \t     || [istarget x86_64-*-*]\n \t     || [istarget alpha*-*-*] \n \t     || [istarget s390*-*-*] \n-\t     || [istarget powerpc*-*-*] } {\n+\t     || [istarget powerpc*-*-*]\n+\t     || [istarget sparc64-*-*]\n+\t     || [istarget sparcv9-*-*] } {\n            set et_sync_char_short_saved 1\n         }\n     }"}]}