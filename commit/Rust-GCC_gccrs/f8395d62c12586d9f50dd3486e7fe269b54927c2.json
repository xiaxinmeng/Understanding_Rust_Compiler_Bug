{"sha": "f8395d62c12586d9f50dd3486e7fe269b54927c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjgzOTVkNjJjMTI1ODZkOWY1MGRkMzQ4NmU3ZmUyNjliNTQ5MjdjMg==", "commit": {"author": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2012-06-15T14:56:26Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2012-06-15T14:56:26Z"}, "message": "re PR middle-end/38474 (compile time explosion in dataflow_set_preserve_mem_locs at -O3)\n\n\tPR middle-end/38474\n\t* cfgexpand.c (add_alias_set_conflicts): Remove.\n\t(expand_used_vars): Don't call it.\n\t(aggregate_contains_union_type): Remove.\n\t* function.c (n_temp_slots_in_use): New static data.\n\t(make_slot_available, assign_stack_temp_for_type): Update it.\n\t(init_temp_slots): Zero it.\n\t(remove_unused_temp_slot_addresses): Use it for quicker removal.\n\t(remove_unused_temp_slot_addresses_1): Use htab_clear_slot.\n\nFrom-SVN: r188667", "tree": {"sha": "c2dc3b99a269da39a68e404629f95304e79da708", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c2dc3b99a269da39a68e404629f95304e79da708"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8395d62c12586d9f50dd3486e7fe269b54927c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8395d62c12586d9f50dd3486e7fe269b54927c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8395d62c12586d9f50dd3486e7fe269b54927c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8395d62c12586d9f50dd3486e7fe269b54927c2/comments", "author": null, "committer": null, "parents": [{"sha": "4c53d18336abbbc580fb0c6a51beed7d2776a209", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c53d18336abbbc580fb0c6a51beed7d2776a209", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c53d18336abbbc580fb0c6a51beed7d2776a209"}], "stats": {"total": 101, "additions": 26, "deletions": 75}, "files": [{"sha": "8db7b6c5a18d10d2e7f7e92fcf6049324b82a2a2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8395d62c12586d9f50dd3486e7fe269b54927c2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8395d62c12586d9f50dd3486e7fe269b54927c2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f8395d62c12586d9f50dd3486e7fe269b54927c2", "patch": "@@ -1,3 +1,15 @@\n+2012-06-15  Michael Matz  <matz@suse.de>\n+\n+\tPR middle-end/38474\n+\t* cfgexpand.c (add_alias_set_conflicts): Remove.\n+\t(expand_used_vars): Don't call it.\n+\t(aggregate_contains_union_type): Remove.\n+\t* function.c (n_temp_slots_in_use): New static data.\n+\t(make_slot_available, assign_stack_temp_for_type): Update it.\n+\t(init_temp_slots): Zero it.\n+\t(remove_unused_temp_slot_addresses): Use it for quicker removal.\n+\t(remove_unused_temp_slot_addresses_1): Use htab_clear_slot.\n+\n 2012-06-15  Michael Matz  <matz@suse.de>\n \n \t* gimplify.c (gimplify_compound_literal_expr): Take gimple_test_f\n@@ -190,9 +202,9 @@\n 2012-06-14  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* arm.opt (mfp=2, mfp=3, mfpe, mfpe=2, mfpe=3): Delete options.\n-        * arm-fpus.def (fpa, fpe2, fpe3, maverick): Delete FPU types.\n+\t* arm-fpus.def (fpa, fpe2, fpe3, maverick): Delete FPU types.\n \t* arm-tables.opt: Regenerated.\n-        * doc/invoke.texi: Remove references to deleted options.\n+\t* doc/invoke.texi: Remove references to deleted options.\n \n 2012-06-14  Sandeep Kumar Singh  <Sandeep.Singh2@kpitcummins.com>\n "}, {"sha": "a8397c69b039dc62f93dd8c317b7cae780b6b53a", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8395d62c12586d9f50dd3486e7fe269b54927c2/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8395d62c12586d9f50dd3486e7fe269b54927c2/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=f8395d62c12586d9f50dd3486e7fe269b54927c2", "patch": "@@ -329,70 +329,6 @@ stack_var_conflict_p (size_t x, size_t y)\n   return bitmap_bit_p (a->conflicts, y);\n }\n \n-/* Returns true if TYPE is or contains a union type.  */\n-\n-static bool\n-aggregate_contains_union_type (tree type)\n-{\n-  tree field;\n-\n-  if (TREE_CODE (type) == UNION_TYPE\n-      || TREE_CODE (type) == QUAL_UNION_TYPE)\n-    return true;\n-  if (TREE_CODE (type) == ARRAY_TYPE)\n-    return aggregate_contains_union_type (TREE_TYPE (type));\n-  if (TREE_CODE (type) != RECORD_TYPE)\n-    return false;\n-\n-  for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n-    if (TREE_CODE (field) == FIELD_DECL)\n-      if (aggregate_contains_union_type (TREE_TYPE (field)))\n-\treturn true;\n-\n-  return false;\n-}\n-\n-/* A subroutine of expand_used_vars.  If two variables X and Y have alias\n-   sets that do not conflict, then do add a conflict for these variables\n-   in the interference graph.  We also need to make sure to add conflicts\n-   for union containing structures.  Else RTL alias analysis comes along\n-   and due to type based aliasing rules decides that for two overlapping\n-   union temporaries { short s; int i; } accesses to the same mem through\n-   different types may not alias and happily reorders stores across\n-   life-time boundaries of the temporaries (See PR25654).  */\n-\n-static void\n-add_alias_set_conflicts (void)\n-{\n-  size_t i, j, n = stack_vars_num;\n-\n-  for (i = 0; i < n; ++i)\n-    {\n-      tree type_i = TREE_TYPE (stack_vars[i].decl);\n-      bool aggr_i = AGGREGATE_TYPE_P (type_i);\n-      bool contains_union;\n-\n-      contains_union = aggregate_contains_union_type (type_i);\n-      for (j = 0; j < i; ++j)\n-\t{\n-\t  tree type_j = TREE_TYPE (stack_vars[j].decl);\n-\t  bool aggr_j = AGGREGATE_TYPE_P (type_j);\n-\t  if (aggr_i != aggr_j\n-\t      /* Either the objects conflict by means of type based\n-\t\t aliasing rules, or we need to add a conflict.  */\n-\t      || !objects_must_conflict_p (type_i, type_j)\n-\t      /* In case the types do not conflict ensure that access\n-\t\t to elements will conflict.  In case of unions we have\n-\t\t to be careful as type based aliasing rules may say\n-\t\t access to the same memory does not conflict.  So play\n-\t\t safe and add a conflict in this case when\n-                 -fstrict-aliasing is used.  */\n-              || (contains_union && flag_strict_aliasing))\n-\t    add_stack_var_conflict (i, j);\n-\t}\n-    }\n-}\n-\n /* Callback for walk_stmt_ops.  If OP is a decl touched by add_stack_var\n    enter its partition number into bitmap DATA.  */\n \n@@ -1625,10 +1561,6 @@ expand_used_vars (void)\n   if (stack_vars_num > 0)\n     {\n       add_scope_conflicts ();\n-      /* Due to the way alias sets work, no variables with non-conflicting\n-\t alias sets may be assigned the same address.  Add conflicts to\n-\t reflect this.  */\n-      add_alias_set_conflicts ();\n \n       /* If stack protection is enabled, we don't share space between\n \t vulnerable data and non-vulnerable data.  */"}, {"sha": "5f510f0bfed68fae28e5289a2d6631f160500c8a", "filename": "gcc/function.c", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8395d62c12586d9f50dd3486e7fe269b54927c2/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8395d62c12586d9f50dd3486e7fe269b54927c2/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=f8395d62c12586d9f50dd3486e7fe269b54927c2", "patch": "@@ -571,6 +571,7 @@ struct GTY(()) temp_slot {\n /* A table of addresses that represent a stack slot.  The table is a mapping\n    from address RTXen to a temp slot.  */\n static GTY((param_is(struct temp_slot_address_entry))) htab_t temp_slot_address_table;\n+static size_t n_temp_slots_in_use;\n \n /* Entry for the above hash table.  */\n struct GTY(()) temp_slot_address_entry {\n@@ -647,6 +648,7 @@ make_slot_available (struct temp_slot *temp)\n   insert_slot_to_list (temp, &avail_temp_slots);\n   temp->in_use = 0;\n   temp->level = -1;\n+  n_temp_slots_in_use--;\n }\n \n /* Compute the hash value for an address -> temp slot mapping.\n@@ -699,17 +701,21 @@ remove_unused_temp_slot_addresses_1 (void **slot, void *data ATTRIBUTE_UNUSED)\n   const struct temp_slot_address_entry *t;\n   t = (const struct temp_slot_address_entry *) *slot;\n   if (! t->temp_slot->in_use)\n-    *slot = NULL;\n+    htab_clear_slot (temp_slot_address_table, slot);\n   return 1;\n }\n \n /* Remove all mappings of addresses to unused temp slots.  */\n static void\n remove_unused_temp_slot_addresses (void)\n {\n-  htab_traverse (temp_slot_address_table,\n-\t\t remove_unused_temp_slot_addresses_1,\n-\t\t NULL);\n+  /* Use quicker clearing if there aren't any active temp slots.  */\n+  if (n_temp_slots_in_use)\n+    htab_traverse (temp_slot_address_table,\n+\t\t   remove_unused_temp_slot_addresses_1,\n+\t\t   NULL);\n+  else\n+    htab_empty (temp_slot_address_table);\n }\n \n /* Find the temp slot corresponding to the object at address X.  */\n@@ -901,6 +907,7 @@ assign_stack_temp_for_type (enum machine_mode mode, HOST_WIDE_INT size,\n   p->in_use = 1;\n   p->type = type;\n   p->level = temp_slot_level;\n+  n_temp_slots_in_use++;\n \n   pp = temp_slots_at_level (p->level);\n   insert_slot_to_list (p, pp);\n@@ -1212,6 +1219,7 @@ init_temp_slots (void)\n   avail_temp_slots = 0;\n   used_temp_slots = 0;\n   temp_slot_level = 0;\n+  n_temp_slots_in_use = 0;\n \n   /* Set up the table to map addresses to temp slots.  */\n   if (! temp_slot_address_table)\n@@ -4496,7 +4504,6 @@ allocate_struct_function (tree fndecl, bool abstract_p)\n       /* ??? This could be set on a per-function basis by the front-end\n          but is this worth the hassle?  */\n       cfun->can_throw_non_call_exceptions = flag_non_call_exceptions;\n-      cfun->can_delete_dead_exceptions = flag_delete_dead_exceptions;\n     }\n }\n "}]}