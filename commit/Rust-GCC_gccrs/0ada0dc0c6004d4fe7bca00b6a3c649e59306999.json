{"sha": "0ada0dc0c6004d4fe7bca00b6a3c649e59306999", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGFkYTBkYzBjNjAwNGQ0ZmU3YmNhMDBiNmEzYzY0OWU1OTMwNjk5OQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2018-03-30T12:33:49Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2018-03-30T12:33:49Z"}, "message": "re PR fortran/84931 (Expansion of array constructor with constant implied-do-object goes sideways)\n\n2018-03-30  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/84931\n\t* simplify.c (gfc_convert_constant): Handle case of array\n\tconstructors within an array that has no iterator and improve\n\tthe conciseness of this section of code.\n\n2018-03-30  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/84931\n\t* gfortran.dg/array_constructor_53.f90: New test.\n\nFrom-SVN: r258977", "tree": {"sha": "26e89d7f9687938924003e945a7382a82d1c827a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/26e89d7f9687938924003e945a7382a82d1c827a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ada0dc0c6004d4fe7bca00b6a3c649e59306999", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ada0dc0c6004d4fe7bca00b6a3c649e59306999", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ada0dc0c6004d4fe7bca00b6a3c649e59306999", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ada0dc0c6004d4fe7bca00b6a3c649e59306999/comments", "author": null, "committer": null, "parents": [{"sha": "13b5a6bf00a5f472a9629fd6fc018765d8f3fd31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13b5a6bf00a5f472a9629fd6fc018765d8f3fd31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13b5a6bf00a5f472a9629fd6fc018765d8f3fd31"}], "stats": {"total": 90, "additions": 57, "deletions": 33}, "files": [{"sha": "e2765e1e73ad0d6fb44b2c50d70e8a52e2eddb5e", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ada0dc0c6004d4fe7bca00b6a3c649e59306999/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ada0dc0c6004d4fe7bca00b6a3c649e59306999/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=0ada0dc0c6004d4fe7bca00b6a3c649e59306999", "patch": "@@ -1,3 +1,10 @@\n+2018-03-30  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/84931\n+\t* simplify.c (gfc_convert_constant): Handle case of array\n+\tconstructors within an array that has no iterator and improve\n+\tthe conciseness of this section of code.\n+\n 2017-03-30  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/85111\n@@ -12,7 +19,7 @@\n \tPR fortran/69497\n \t* symbol.c (gfc_symbol_done_2): Start freeing namespaces\n \tfrom the root.\n-\t(gfc_free_namespace): Restore assert (revert r258839). \n+\t(gfc_free_namespace): Restore assert (revert r258839).\n \n 2018-03-28  Jakub Jelinek  <jakub@redhat.com>\n "}, {"sha": "a970e017c903acb458741206be8cb6c6a8528bb7", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 25, "deletions": 32, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ada0dc0c6004d4fe7bca00b6a3c649e59306999/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ada0dc0c6004d4fe7bca00b6a3c649e59306999/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=0ada0dc0c6004d4fe7bca00b6a3c649e59306999", "patch": "@@ -380,7 +380,7 @@ compute_dot_product (gfc_expr *matrix_a, int stride_a, int offset_a,\n {\n   gfc_expr *result, *a, *b, *c;\n \n-  /* Set result to an INTEGER(1) 0 for numeric types and .false. for \n+  /* Set result to an INTEGER(1) 0 for numeric types and .false. for\n      LOGICAL.  Mixed-mode math in the loop will promote result to the\n      correct type and kind.  */\n   if (matrix_a->ts.type == BT_LOGICAL)\n@@ -2086,7 +2086,7 @@ gfc_simplify_cshift (gfc_expr *array, gfc_expr *shift, gfc_expr *dim)\n     }\n   else\n     shiftvec = NULL;\n-  \n+\n   /* Shut up compiler */\n   len = 1;\n   rsoffset = 1;\n@@ -2296,7 +2296,7 @@ gfc_simplify_dim (gfc_expr *x, gfc_expr *y)\n gfc_expr*\n gfc_simplify_dot_product (gfc_expr *vector_a, gfc_expr *vector_b)\n {\n-  /* If vector_a is a zero-sized array, the result is 0 for INTEGER, \n+  /* If vector_a is a zero-sized array, the result is 0 for INTEGER,\n      REAL, and COMPLEX types and .false. for LOGICAL.  */\n   if (vector_a->shape && mpz_get_si (vector_a->shape[0]) == 0)\n     {\n@@ -2423,7 +2423,7 @@ gfc_simplify_eoshift (gfc_expr *array, gfc_expr *shift, gfc_expr *boundary,\n     {\n       if (boundary->rank > 0)\n \tgfc_simplify_expr (boundary, 1);\n-      \n+\n       if (!gfc_is_constant_expr (boundary))\n \t  return NULL;\n     }\n@@ -2443,7 +2443,7 @@ gfc_simplify_eoshift (gfc_expr *array, gfc_expr *shift, gfc_expr *boundary,\n       temp_boundary = true;\n       switch (array->ts.type)\n \t{\n-\t  \n+\n \tcase BT_INTEGER:\n \t  bnd = gfc_get_int_expr (array->ts.kind, NULL, 0);\n \t  break;\n@@ -2477,7 +2477,7 @@ gfc_simplify_eoshift (gfc_expr *array, gfc_expr *shift, gfc_expr *boundary,\n       temp_boundary = false;\n       bnd = boundary;\n     }\n-  \n+\n   gfc_array_size (array, &size);\n   arraysize = mpz_get_ui (size);\n   mpz_clear (size);\n@@ -2615,7 +2615,7 @@ gfc_simplify_eoshift (gfc_expr *array, gfc_expr *shift, gfc_expr *boundary,\n \n       if (bnd_ctor)\n \tbnd_ctor = gfc_constructor_next (bnd_ctor);\n-      \n+\n       count[0]++;\n       n = 0;\n       while (count[n] == extent[n])\n@@ -5316,7 +5316,7 @@ simplify_minmaxloc_to_array (gfc_expr *result, gfc_expr *array,\n \t  if (*src && min_max_choose (*src, ex, sign) > 0)\n \t    mpz_set_si ((*dest)->value.integer, n + 1);\n \t}\n- \n+\n       count[0]++;\n       base += sstride[0];\n       dest += dstride[0];\n@@ -5373,7 +5373,7 @@ gfc_simplify_minmaxloc (gfc_expr *array, gfc_expr *dim, gfc_expr *mask,\n   gfc_expr *extremum;\n   int ikind;\n   int init_val;\n-  \n+\n   if (!is_constant_array_expr (array)\n       || !gfc_is_constant_expr (dim))\n     return NULL;\n@@ -7879,8 +7879,8 @@ gfc_simplify_xor (gfc_expr *x, gfc_expr *y)\n gfc_expr *\n gfc_convert_constant (gfc_expr *e, bt type, int kind)\n {\n-  gfc_expr *g, *result, *(*f) (gfc_expr *, int);\n-  gfc_constructor *c;\n+  gfc_expr *result, *(*f) (gfc_expr *, int);\n+  gfc_constructor *c, *t;\n \n   switch (e->ts.type)\n     {\n@@ -8017,31 +8017,24 @@ gfc_convert_constant (gfc_expr *e, bt type, int kind)\n \t  gfc_expr *tmp;\n \t  if (c->iterator == NULL)\n \t    {\n-\t      tmp = f (c->expr, kind);\n-\t      if (tmp == NULL)\n-\t\t{\n-\t\t  gfc_free_expr (result);\n-\t\t  return NULL;\n-\t\t}\n-\n-\t      gfc_constructor_append_expr (&result->value.constructor,\n-\t\t\t\t\t   tmp, &c->where);\n+\t      if (c->expr->expr_type == EXPR_ARRAY)\n+\t\ttmp = gfc_convert_constant (c->expr, type, kind);\n+\t      else\n+\t\ttmp = f (c->expr, kind);\n \t    }\n \t  else\n+\t    tmp = gfc_convert_constant (c->expr, type, kind);\n+\n+\t  if (tmp == NULL || tmp == &gfc_bad_expr)\n \t    {\n-\t      gfc_constructor *n;\n-\t      g = gfc_convert_constant (c->expr, type, kind);\n-\t      if (g == NULL || g == &gfc_bad_expr)\n-\t        {\n-\t\t  gfc_free_expr (result);\n-\t\t  return g;\n-\t\t}\n-\t      n = gfc_constructor_get ();\n-\t      n->expr = g;\n-\t      n->iterator = gfc_copy_iterator (c->iterator);\n-\t      n->where = c->where;\n-\t      gfc_constructor_append (&result->value.constructor, n);\n+\t      gfc_free_expr (result);\n+\t      return NULL;\n \t    }\n+\n+\t  t = gfc_constructor_append_expr (&result->value.constructor,\n+\t\t\t\t\t   tmp, &c->where);\n+\t  if (c->iterator)\n+\t    t->iterator = gfc_copy_iterator (c->iterator);\n \t}\n \n       break;"}, {"sha": "e17846e9c488c9b411e2d9129c28adfff7c8a4f1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ada0dc0c6004d4fe7bca00b6a3c649e59306999/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ada0dc0c6004d4fe7bca00b6a3c649e59306999/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0ada0dc0c6004d4fe7bca00b6a3c649e59306999", "patch": "@@ -1,3 +1,8 @@\n+2018-03-30  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/84931\n+\t* gfortran.dg/array_constructor_53.f90: New test.\n+\n 2018-03-30  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/85130"}, {"sha": "8f7c87fe96cfaae8b93bf59b1ce5c5dfd43fa3dd", "filename": "gcc/testsuite/gfortran.dg/array_constructor_53.f90", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ada0dc0c6004d4fe7bca00b6a3c649e59306999/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_53.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ada0dc0c6004d4fe7bca00b6a3c649e59306999/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_53.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_53.f90?ref=0ada0dc0c6004d4fe7bca00b6a3c649e59306999", "patch": "@@ -0,0 +1,19 @@\n+! { dg-do  run }\n+! PR 84931 - long array constructors with type conversion were not\n+! handled correctly. array_constructor_52.f90 tests the original\n+! problem.\n+program test\n+   implicit none\n+   integer, parameter :: n = 2**16 + 1\n+   real, dimension(n) :: y\n+   real, dimension(2*n) :: z\n+   integer :: i\n+\n+   y = [33, (1, i=1, n-1) ]    ! Check that something more complicated works\n+   if (int(y(3)) /= 1) stop 1\n+\n+   z = [[(1, i=1, n) ],[(2, i=1, n) ]] ! Failed with first version of the fix\n+\n+   if (int(z(2)) /= 1) stop 2\n+   if (int(z(n+1)) /= 2) stop 3\n+end program test"}]}