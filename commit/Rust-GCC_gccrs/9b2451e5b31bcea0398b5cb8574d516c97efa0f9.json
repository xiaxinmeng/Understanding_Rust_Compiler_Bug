{"sha": "9b2451e5b31bcea0398b5cb8574d516c97efa0f9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWIyNDUxZTViMzFiY2VhMDM5OGI1Y2I4NTc0ZDUxNmM5N2VmYTBmOQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-10-14T13:33:48Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-10-14T13:33:48Z"}, "message": "[multiple changes]\n\n2013-10-14  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* aspects.adb: Add an entry in table Canonical_Aspect for\n\tInitial_Condition.\n\t* aspects.ads: Add entries in tables Aspect_Id, Aspect_Argument,\n\tAspect_Names and Aspect_Delay for Initial_Condition.\n\t* einfo.adb (Get_Pragma): Include pragma Initial_Condition to\n\tcategorization pragmas.\n\t* einfo.ads (Get_Pragma): Update comment on usage.\n\t* exp_ch7.adb (Expand_N_Package_Body): Add a runtime check to\n\tverify the assertion introduced by pragma Initial_Condition.\n\t(Expand_N_Package_Declaration): Add a runtime check to\n\tverify the assertion introduced by pragma Initial_Condition.\n\t(Expand_Pragma_Initial_Condition): New routine.\n\t* par-prag: Include pragma Initial_Condition to the list of\n\tpragmas that do not require special processing by the parser.\n\t* sem_ch3.adb (Analyze_Declarations): Analyze pragma\n\tInitial_Condition at the end of the visible declarations.\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): Add processing\n\tfor aspect Initial_Condition.\n\t(Check_Aspect_At_Freeze_Point):\n\tAspect Initial_Condition does not need inspection at freezing.\n\t* sem_prag.adb (Analyze_Initial_Condition_In_Decl_Part):\n\tNew routine.\n\t(Analyze_Pragma): Update all calls\n\tto Check_Declaration_Order. Add processing for pragma\n\tInitial_Condition. Initial_Condition is now a valid assertion\n\tkind.  Add an entry in table Sig_Flags for Initial_Condition.\n\t(Check_Declaration_Order): Reimplemented to handle arbitrary\n\tpragmas.\n\t(Is_Valid_Assertion_Kind): Add an entry for\n\tInitial_Condition.\n\t* sem_pag.ads (Analyze_Initial_Condition_In_Decl_Part):\n\tNew routine.\n\t* sem_util.adb (Add_Contract_Item): Pragma Initial_Condition\n\tcan now be associated with a package spec.\n\t* sem_util.ads (Add_Contract_Item): Update comment on usage.\n\t* sinfo.ads: Update the documentation of node N_Contract\n\t* snames.ads-tmpl: Add new predefined name Initial_Condition. Add\n\tnew pragma id for Initial_Condition.\n\n2013-10-14  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_pakd.adb: Minor reformatting.\n\nFrom-SVN: r203551", "tree": {"sha": "9250cc5ee8b25c293954bb1eb36974e3a8aea7f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9250cc5ee8b25c293954bb1eb36974e3a8aea7f4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b2451e5b31bcea0398b5cb8574d516c97efa0f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b2451e5b31bcea0398b5cb8574d516c97efa0f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b2451e5b31bcea0398b5cb8574d516c97efa0f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b2451e5b31bcea0398b5cb8574d516c97efa0f9/comments", "author": null, "committer": null, "parents": [{"sha": "1e7bc06555257c73282c7ca1678a74d2cc6c7e6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e7bc06555257c73282c7ca1678a74d2cc6c7e6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e7bc06555257c73282c7ca1678a74d2cc6c7e6c"}], "stats": {"total": 611, "additions": 544, "deletions": 67}, "files": [{"sha": "acb4f5881abaab8dbfa206003262936100f4de18", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b2451e5b31bcea0398b5cb8574d516c97efa0f9/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b2451e5b31bcea0398b5cb8574d516c97efa0f9/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=9b2451e5b31bcea0398b5cb8574d516c97efa0f9", "patch": "@@ -1,3 +1,48 @@\n+2013-10-14  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* aspects.adb: Add an entry in table Canonical_Aspect for\n+\tInitial_Condition.\n+\t* aspects.ads: Add entries in tables Aspect_Id, Aspect_Argument,\n+\tAspect_Names and Aspect_Delay for Initial_Condition.\n+\t* einfo.adb (Get_Pragma): Include pragma Initial_Condition to\n+\tcategorization pragmas.\n+\t* einfo.ads (Get_Pragma): Update comment on usage.\n+\t* exp_ch7.adb (Expand_N_Package_Body): Add a runtime check to\n+\tverify the assertion introduced by pragma Initial_Condition.\n+\t(Expand_N_Package_Declaration): Add a runtime check to\n+\tverify the assertion introduced by pragma Initial_Condition.\n+\t(Expand_Pragma_Initial_Condition): New routine.\n+\t* par-prag: Include pragma Initial_Condition to the list of\n+\tpragmas that do not require special processing by the parser.\n+\t* sem_ch3.adb (Analyze_Declarations): Analyze pragma\n+\tInitial_Condition at the end of the visible declarations.\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications): Add processing\n+\tfor aspect Initial_Condition.\n+\t(Check_Aspect_At_Freeze_Point):\n+\tAspect Initial_Condition does not need inspection at freezing.\n+\t* sem_prag.adb (Analyze_Initial_Condition_In_Decl_Part):\n+\tNew routine.\n+\t(Analyze_Pragma): Update all calls\n+\tto Check_Declaration_Order. Add processing for pragma\n+\tInitial_Condition. Initial_Condition is now a valid assertion\n+\tkind.  Add an entry in table Sig_Flags for Initial_Condition.\n+\t(Check_Declaration_Order): Reimplemented to handle arbitrary\n+\tpragmas.\n+\t(Is_Valid_Assertion_Kind): Add an entry for\n+\tInitial_Condition.\n+\t* sem_pag.ads (Analyze_Initial_Condition_In_Decl_Part):\n+\tNew routine.\n+\t* sem_util.adb (Add_Contract_Item): Pragma Initial_Condition\n+\tcan now be associated with a package spec.\n+\t* sem_util.ads (Add_Contract_Item): Update comment on usage.\n+\t* sinfo.ads: Update the documentation of node N_Contract\n+\t* snames.ads-tmpl: Add new predefined name Initial_Condition. Add\n+\tnew pragma id for Initial_Condition.\n+\n+2013-10-14  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* exp_pakd.adb: Minor reformatting.\n+\n 2013-10-14  Robert Dewar  <dewar@adacore.com>\n \n \t* exp_prag.adb: Minor reformatting."}, {"sha": "0d9d28c556d12af53a378978f5827675381ac172", "filename": "gcc/ada/aspects.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b2451e5b31bcea0398b5cb8574d516c97efa0f9/gcc%2Fada%2Faspects.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b2451e5b31bcea0398b5cb8574d516c97efa0f9/gcc%2Fada%2Faspects.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.adb?ref=9b2451e5b31bcea0398b5cb8574d516c97efa0f9", "patch": "@@ -440,6 +440,7 @@ package body Aspects is\n     Aspect_Independent_Components       => Aspect_Independent_Components,\n     Aspect_Inline                       => Aspect_Inline,\n     Aspect_Inline_Always                => Aspect_Inline,\n+    Aspect_Initial_Condition            => Aspect_Initial_Condition,\n     Aspect_Initializes                  => Aspect_Initializes,\n     Aspect_Input                        => Aspect_Input,\n     Aspect_Interrupt_Handler            => Aspect_Interrupt_Handler,"}, {"sha": "877a1af3b79c6d788196604fb979dca28454ea4e", "filename": "gcc/ada/aspects.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b2451e5b31bcea0398b5cb8574d516c97efa0f9/gcc%2Fada%2Faspects.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b2451e5b31bcea0398b5cb8574d516c97efa0f9/gcc%2Fada%2Faspects.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.ads?ref=9b2451e5b31bcea0398b5cb8574d516c97efa0f9", "patch": "@@ -96,6 +96,7 @@ package Aspects is\n       Aspect_External_Tag,\n       Aspect_Global,                        -- GNAT\n       Aspect_Implicit_Dereference,\n+      Aspect_Initial_Condition,             -- GNAT\n       Aspect_Initializes,                   -- GNAT\n       Aspect_Input,\n       Aspect_Interrupt_Priority,\n@@ -310,6 +311,7 @@ package Aspects is\n       Aspect_External_Tag            => Expression,\n       Aspect_Global                  => Expression,\n       Aspect_Implicit_Dereference    => Name,\n+      Aspect_Initial_Condition       => Expression,\n       Aspect_Initializes             => Expression,\n       Aspect_Input                   => Name,\n       Aspect_Interrupt_Priority      => Expression,\n@@ -400,6 +402,7 @@ package Aspects is\n       Aspect_Independent_Components       => Name_Independent_Components,\n       Aspect_Inline                       => Name_Inline,\n       Aspect_Inline_Always                => Name_Inline_Always,\n+      Aspect_Initial_Condition            => Name_Initial_Condition,\n       Aspect_Initializes                  => Name_Initializes,\n       Aspect_Input                        => Name_Input,\n       Aspect_Interrupt_Handler            => Name_Interrupt_Handler,\n@@ -600,6 +603,7 @@ package Aspects is\n       Aspect_Independent_Components       => Always_Delay,\n       Aspect_Inline                       => Always_Delay,\n       Aspect_Inline_Always                => Always_Delay,\n+      Aspect_Initial_Condition            => Always_Delay,\n       Aspect_Initializes                  => Always_Delay,\n       Aspect_Input                        => Always_Delay,\n       Aspect_Interrupt_Handler            => Always_Delay,"}, {"sha": "8636d8511cd077c9b0308d2f913369c8c849183d", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b2451e5b31bcea0398b5cb8574d516c97efa0f9/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b2451e5b31bcea0398b5cb8574d516c97efa0f9/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=9b2451e5b31bcea0398b5cb8574d516c97efa0f9", "patch": "@@ -6300,18 +6300,19 @@ package body Einfo is\n \n    function Get_Pragma (E : Entity_Id; Id : Pragma_Id) return Node_Id is\n       Is_CDG  : constant Boolean :=\n-                  Id = Pragma_Abstract_State  or else\n-                  Id = Pragma_Depends         or else\n-                  Id = Pragma_Global          or else\n-                  Id = Pragma_Initializes     or else\n-                  Id = Pragma_Refined_Depends or else\n-                  Id = Pragma_Refined_Global  or else\n+                  Id = Pragma_Abstract_State    or else\n+                  Id = Pragma_Depends           or else\n+                  Id = Pragma_Global            or else\n+                  Id = Pragma_Initial_Condition or else\n+                  Id = Pragma_Initializes       or else\n+                  Id = Pragma_Refined_Depends   or else\n+                  Id = Pragma_Refined_Global    or else\n                   Id = Pragma_Refined_State;\n       Is_CTC : constant Boolean :=\n-                  Id = Pragma_Contract_Cases  or else\n+                  Id = Pragma_Contract_Cases    or else\n                   Id = Pragma_Test_Case;\n       Is_PPC : constant Boolean :=\n-                  Id = Pragma_Precondition    or else\n+                  Id = Pragma_Precondition      or else\n                   Id = Pragma_Postcondition;\n \n       In_Contract : constant Boolean := Is_CDG or Is_CTC or Is_PPC;"}, {"sha": "0526d4406e813187dcc017671d4c2832f794ba4c", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b2451e5b31bcea0398b5cb8574d516c97efa0f9/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b2451e5b31bcea0398b5cb8574d516c97efa0f9/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=9b2451e5b31bcea0398b5cb8574d516c97efa0f9", "patch": "@@ -7442,6 +7442,8 @@ package Einfo is\n    --    Contract_Cases\n    --    Depends\n    --    Global\n+   --    Initial_Condition\n+   --    Initializes\n    --    Precondition\n    --    Postcondition\n    --    Refined_Depends"}, {"sha": "1b242cc46e9ade8229594dd5292df50df0749f43", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 108, "deletions": 5, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b2451e5b31bcea0398b5cb8574d516c97efa0f9/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b2451e5b31bcea0398b5cb8574d516c97efa0f9/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=9b2451e5b31bcea0398b5cb8574d516c97efa0f9", "patch": "@@ -368,6 +368,11 @@ package body Exp_Ch7 is\n    --  Given an arbitrary entity, traverse the scope chain looking for the\n    --  first enclosing function. Return Empty if no function was found.\n \n+   procedure Expand_Pragma_Initial_Condition (N : Node_Id);\n+   --  Subsidiary to the expansion of package specs and bodies. Generate a\n+   --  runtime check needed to verify the assumption introduced by pragma\n+   --  Initial_Condition. N denotes the package spec or body.\n+\n    function Make_Call\n      (Loc        : Source_Ptr;\n       Proc_Id    : Entity_Id;\n@@ -3959,6 +3964,15 @@ package body Exp_Ch7 is\n          end if;\n \n          Build_Task_Activation_Call (N);\n+\n+         --  When the package is subject to pragma Initial_Condition, the\n+         --  assertion expression must be verified at the end of the body\n+         --  statements.\n+\n+         if Present (Get_Pragma (Spec_Ent, Pragma_Initial_Condition)) then\n+            Expand_Pragma_Initial_Condition (N);\n+         end if;\n+\n          Pop_Scope;\n       end if;\n \n@@ -4053,10 +4067,9 @@ package body Exp_Ch7 is\n       if No_Body then\n          Push_Scope (Id);\n \n-         if Has_RACW (Id) then\n-\n-            --  Generate RACW subprogram bodies\n+         --  Generate RACW subprogram bodies\n \n+         if Has_RACW (Id) then\n             Decls := Private_Declarations (Spec);\n \n             if No (Decls) then\n@@ -4072,11 +4085,19 @@ package body Exp_Ch7 is\n             Analyze_List (Decls);\n          end if;\n \n+         --  Generate task activation call as last step of elaboration\n+\n          if Present (Activation_Chain_Entity (N)) then\n+            Build_Task_Activation_Call (N);\n+         end if;\n \n-            --  Generate task activation call as last step of elaboration\n+         --  When the package is subject to pragma Initial_Condition and lacks\n+         --  a body, the assertion expression must be verified at the end of\n+         --  the visible declarations. Otherwise the check is performed at the\n+         --  end of the body statements (see Expand_N_Package_Body).\n \n-            Build_Task_Activation_Call (N);\n+         if Present (Get_Pragma (Id, Pragma_Initial_Condition)) then\n+            Expand_Pragma_Initial_Condition (N);\n          end if;\n \n          Pop_Scope;\n@@ -4114,6 +4135,88 @@ package body Exp_Ch7 is\n       end if;\n    end Expand_N_Package_Declaration;\n \n+   -------------------------------------\n+   -- Expand_Pragma_Initial_Condition --\n+   -------------------------------------\n+\n+   procedure Expand_Pragma_Initial_Condition (N : Node_Id) is\n+      Loc       : constant Source_Ptr := Sloc (N);\n+      Check     : Node_Id;\n+      Expr      : Node_Id;\n+      Init_Cond : Node_Id;\n+      List      : List_Id;\n+      Pack_Id   : Entity_Id;\n+\n+   begin\n+      if Nkind (N) = N_Package_Body then\n+         Pack_Id := Corresponding_Spec (N);\n+\n+         if Present (Handled_Statement_Sequence (N)) then\n+            List := Statements (Handled_Statement_Sequence (N));\n+\n+         --  The package body lacks statements, create an empty list\n+\n+         else\n+            List := New_List;\n+\n+            Set_Handled_Statement_Sequence (N,\n+              Make_Handled_Sequence_Of_Statements (Loc, Statements => List));\n+         end if;\n+\n+      elsif Nkind (N) = N_Package_Declaration then\n+         Pack_Id := Defining_Entity (N);\n+\n+         if Present (Visible_Declarations (Specification (N))) then\n+            List := Visible_Declarations (Specification (N));\n+\n+         --  The package lacks visible declarations, create an empty list\n+\n+         else\n+            List := New_List;\n+\n+            Set_Visible_Declarations (Specification (N), List);\n+         end if;\n+\n+      --  This routine should not be used on anything other than packages\n+\n+      else\n+         raise Program_Error;\n+      end if;\n+\n+      Init_Cond := Get_Pragma (Pack_Id, Pragma_Initial_Condition);\n+\n+      --  The caller should check whether the package is subject to pragma\n+      --  Initial_Condition.\n+\n+      pragma Assert (Present (Init_Cond));\n+\n+      Expr :=\n+        Get_Pragma_Arg (First (Pragma_Argument_Associations (Init_Cond)));\n+\n+      --  The assertion expression was found to be illegal, do not generate the\n+      --  runtime check as it will repeat the illegality.\n+\n+      if Error_Posted (Init_Cond) or else Error_Posted (Expr) then\n+         return;\n+      end if;\n+\n+      --  Generate:\n+      --    pragma Check (Initial_Condition, <Expr>);\n+\n+      Check :=\n+        Make_Pragma (Loc,\n+          Chars                        => Name_Check,\n+          Pragma_Argument_Associations => New_List (\n+            Make_Pragma_Argument_Association (Loc,\n+              Expression => Make_Identifier (Loc, Name_Initial_Condition)),\n+\n+            Make_Pragma_Argument_Association (Loc,\n+              Expression => New_Copy_Tree (Expr))));\n+\n+      Append_To (List, Check);\n+      Analyze (Check);\n+   end Expand_Pragma_Initial_Condition;\n+\n    -----------------------------\n    -- Find_Node_To_Be_Wrapped --\n    -----------------------------"}, {"sha": "45aafadefeec29c3d314cce53ce55d746d727088", "filename": "gcc/ada/exp_pakd.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b2451e5b31bcea0398b5cb8574d516c97efa0f9/gcc%2Fada%2Fexp_pakd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b2451e5b31bcea0398b5cb8574d516c97efa0f9/gcc%2Fada%2Fexp_pakd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_pakd.adb?ref=9b2451e5b31bcea0398b5cb8574d516c97efa0f9", "patch": "@@ -1326,8 +1326,8 @@ package body Exp_Pakd is\n       --  The expression for the shift value that is required\n \n       Shift_Used : Boolean := False;\n-      --  Set True if Shift has been used in the generated code at least\n-      --  once, so that it must be duplicated if used again\n+      --  Set True if Shift has been used in the generated code at least once,\n+      --  so that it must be duplicated if used again.\n \n       New_Lhs : Node_Id;\n       New_Rhs : Node_Id;"}, {"sha": "53f4fe4652deed431d9e8253b1dea82771051968", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b2451e5b31bcea0398b5cb8574d516c97efa0f9/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b2451e5b31bcea0398b5cb8574d516c97efa0f9/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=9b2451e5b31bcea0398b5cb8574d516c97efa0f9", "patch": "@@ -1185,6 +1185,7 @@ begin\n            Pragma_Import_Valued_Procedure        |\n            Pragma_Independent                    |\n            Pragma_Independent_Components         |\n+           Pragma_Initial_Condition              |\n            Pragma_Initialize_Scalars             |\n            Pragma_Initializes                    |\n            Pragma_Inline                         |"}, {"sha": "6744484da38e8edd03f2e2cf239b1cd730f05ba9", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b2451e5b31bcea0398b5cb8574d516c97efa0f9/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b2451e5b31bcea0398b5cb8574d516c97efa0f9/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=9b2451e5b31bcea0398b5cb8574d516c97efa0f9", "patch": "@@ -2053,6 +2053,45 @@ package body Sem_Ch13 is\n                   Insert_Delayed_Pragma (Aitem);\n                   goto Continue;\n \n+               --  Initial_Condition\n+\n+               --  Aspect Initial_Condition covers the visible declarations of\n+               --  a package and all hidden states through functions. As such,\n+               --  it must be evaluated at the end of the said declarations.\n+\n+               when Aspect_Initial_Condition => Initial_Condition : declare\n+                  Decls : List_Id;\n+\n+               begin\n+                  if Nkind_In (N, N_Generic_Package_Declaration,\n+                                  N_Package_Declaration)\n+                  then\n+                     Decls := Visible_Declarations (Specification (N));\n+\n+                     Make_Aitem_Pragma\n+                       (Pragma_Argument_Associations => New_List (\n+                          Make_Pragma_Argument_Association (Loc,\n+                            Expression => Relocate_Node (Expr))),\n+                        Pragma_Name                  =>\n+                          Name_Initial_Condition);\n+                     Decorate_Delayed_Aspect_And_Pragma (Aspect, Aitem);\n+\n+                     if No (Decls) then\n+                        Decls := New_List;\n+                        Set_Visible_Declarations (N, Decls);\n+                     end if;\n+\n+                     Prepend_To (Decls, Aitem);\n+\n+                  else\n+                     Error_Msg_NE\n+                       (\"aspect & must apply to a package declaration\",\n+                        Aspect, Id);\n+                  end if;\n+\n+                  goto Continue;\n+               end Initial_Condition;\n+\n                --  Initializes\n \n                --  Aspect Initializes coverts the visible declarations of a\n@@ -7849,6 +7888,7 @@ package body Sem_Ch13 is\n               Aspect_Dimension            |\n               Aspect_Dimension_System     |\n               Aspect_Implicit_Dereference |\n+              Aspect_Initial_Condition    |\n               Aspect_Initializes          |\n               Aspect_Post                 |\n               Aspect_Postcondition        |"}, {"sha": "4440910ab69302ade56e921bbbd30267c9808f9b", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b2451e5b31bcea0398b5cb8574d516c97efa0f9/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b2451e5b31bcea0398b5cb8574d516c97efa0f9/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=9b2451e5b31bcea0398b5cb8574d516c97efa0f9", "patch": "@@ -2224,9 +2224,9 @@ package body Sem_Ch3 is\n       if Present (L) then\n          Context := Parent (L);\n \n-         --  Analyze aspect/pragma Initializes of a package at the end of the\n-         --  visible declarations as the aspect/pragma has visibility over the\n-         --  said region.\n+         --  Analyze pragmas Initializes and Initial_Condition of a package at\n+         --  the end of the visible declarations as the pragmas have visibility\n+         --  over the said region.\n \n          if Nkind (Context) = N_Package_Specification\n            and then L = Visible_Declarations (Context)\n@@ -2238,6 +2238,12 @@ package body Sem_Ch3 is\n                Analyze_Initializes_In_Decl_Part (Prag);\n             end if;\n \n+            Prag := Get_Pragma (Spec_Id, Pragma_Initial_Condition);\n+\n+            if Present (Prag) then\n+               Analyze_Initial_Condition_In_Decl_Part (Prag);\n+            end if;\n+\n          --  Analyze the state refinements within a package body now, after\n          --  all hidden states have been encountered and freely visible.\n          --  Refinements must be processed before pragmas Refined_Depends and"}, {"sha": "4734581b0e520597a8aef8dc7b226852615a8a84", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 311, "deletions": 48, "changes": 359, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b2451e5b31bcea0398b5cb8574d516c97efa0f9/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b2451e5b31bcea0398b5cb8574d516c97efa0f9/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=9b2451e5b31bcea0398b5cb8574d516c97efa0f9", "patch": "@@ -911,9 +911,9 @@ package body Sem_Prag is\n             --  as input. OUT parameters are valid inputs only when their type\n             --  is unconstrained or tagged as their discriminants, array bouns\n             --  or tags can be read. In general, states and variables are\n-            --  considered to have mode IN OUT unless they are moded by pragma\n-            --  [Refined_]Global. In that case, the item must appear in an\n-            --  input global list.\n+            --  considered to have mode IN OUT unless they are classified by\n+            --  pragma [Refined_]Global. In that case, the item must appear in\n+            --  an input global list.\n \n             if (Ekind (Item_Id) = E_Out_Parameter\n                  and then not Is_Unconstrained_Or_Tagged_Item (Item_Id))\n@@ -1964,6 +1964,194 @@ package body Sem_Prag is\n       end if;\n    end Analyze_Global_In_Decl_Part;\n \n+   --------------------------------------------\n+   -- Analyze_Initial_Condition_In_Decl_Part --\n+   --------------------------------------------\n+\n+   procedure Analyze_Initial_Condition_In_Decl_Part (N : Node_Id) is\n+      Pack_Id   : constant Entity_Id := Defining_Entity (Parent (Parent (N)));\n+      Prag_Init : constant Node_Id   :=\n+                    Get_Pragma (Pack_Id, Pragma_Initializes);\n+      --  The related pragma Initializes\n+\n+      Vars : Elist_Id := No_Elist;\n+      --  A list of all variables declared in pragma Initializes\n+\n+      procedure Collect_Variables;\n+      --  Inspect the initialization list of pragma Initializes and collect the\n+      --  entities of all variables declared within the related package.\n+\n+      function Match_Variable (N : Node_Id) return Traverse_Result;\n+      --  Determine whether arbitrary node N denotes a variable declared in the\n+      --  visible declarations of the related package.\n+\n+      procedure Report_Unused_Variables;\n+      --  Emit errors for all variables found in list Vars\n+\n+      -----------------------\n+      -- Collect_Variables --\n+      -----------------------\n+\n+      procedure Collect_Variables is\n+         procedure Collect_Variable (Item : Node_Id);\n+         --  Determine whether Item denotes a variable that appears in the\n+         --  related package and if it does, add it to list Vars.\n+\n+         ----------------------\n+         -- Collect_Variable --\n+         ----------------------\n+\n+         procedure Collect_Variable (Item : Node_Id) is\n+            Item_Id : Entity_Id;\n+\n+         begin\n+            if Is_Entity_Name (Item) and then Present (Entity (Item)) then\n+               Item_Id := Entity (Item);\n+\n+               --  The item is a variable declared in the related package\n+\n+               if Ekind (Item_Id) = E_Variable\n+                 and then Scope (Item_Id) = Pack_Id\n+               then\n+                  Add_Item (Item_Id, Vars);\n+               end if;\n+            end if;\n+         end Collect_Variable;\n+\n+         --  Local variables\n+\n+         Inits : constant Node_Id :=\n+                   Get_Pragma_Arg\n+                     (First (Pragma_Argument_Associations (Prag_Init)));\n+         Init  : Node_Id;\n+\n+      --  Start of processing for Collect_Variables\n+\n+      begin\n+         --  Multiple initialization items appear as an aggregate\n+\n+         if Nkind (Inits) = N_Aggregate\n+           and then Present (Expressions (Inits))\n+         then\n+            Init := First (Expressions (Inits));\n+            while Present (Init) loop\n+               Collect_Variable (Init);\n+\n+               Next (Init);\n+            end loop;\n+\n+         --  Single initialization item\n+\n+         else\n+            Collect_Variable (Inits);\n+         end if;\n+      end Collect_Variables;\n+\n+      --------------------\n+      -- Match_Variable --\n+      --------------------\n+\n+      function Match_Variable (N : Node_Id) return Traverse_Result is\n+         Var_Id : Entity_Id;\n+\n+      begin\n+         --  Find a variable declared within the related package and try to\n+         --  remove it from the list of collected variables found in pragma\n+         --  Initializes.\n+\n+         if Is_Entity_Name (N)\n+           and then Present (Entity (N))\n+         then\n+            Var_Id := Entity (N);\n+\n+            if Ekind (Var_Id) = E_Variable\n+              and then Scope (Var_Id) = Pack_Id\n+            then\n+               Remove (Vars, Var_Id);\n+            end if;\n+         end if;\n+\n+         return OK;\n+      end Match_Variable;\n+\n+      procedure Match_Variables is new Traverse_Proc (Match_Variable);\n+\n+      -----------------------------\n+      -- Report_Unused_Variables --\n+      -----------------------------\n+\n+      procedure Report_Unused_Variables is\n+         Posted   : Boolean := False;\n+         Var_Elmt : Elmt_Id;\n+         Var_Id   : Entity_Id;\n+\n+      begin\n+         if Present (Vars) then\n+            Var_Elmt := First_Elmt (Vars);\n+            while Present (Var_Elmt) loop\n+               Var_Id := Node (Var_Elmt);\n+\n+               if not Posted then\n+                  Posted := True;\n+                  Error_Msg_Name_1 := Name_Initial_Condition;\n+                  Error_Msg_N\n+                    (\"expression of % must mention the following variables\",\n+                     N);\n+               end if;\n+\n+               Error_Msg_Sloc := Sloc (Var_Id);\n+               Error_Msg_NE (\"\\  & declared #\", N, Var_Id);\n+\n+               Next_Elmt (Var_Elmt);\n+            end loop;\n+         end if;\n+      end Report_Unused_Variables;\n+\n+      Expr   : constant Node_Id :=\n+                 Get_Pragma_Arg (First (Pragma_Argument_Associations (N)));\n+      Errors : constant Nat     := Serious_Errors_Detected;\n+\n+   --  Start of processing for Analyze_Initial_Condition_In_Decl_Part\n+\n+   begin\n+      Set_Analyzed (N);\n+\n+      --  Pragma Initial_Condition depends on the names enumerated in pragma\n+      --  Initializes. Without those, the analysis cannot take place.\n+\n+      if No (Prag_Init) then\n+         Error_Msg_Name_1 := Name_Initial_Condition;\n+         Error_Msg_Name_2 := Name_Initializes;\n+\n+         Error_Msg_N (\"% requires the presence of aspect or pragma %\", N);\n+         return;\n+      end if;\n+\n+      --  The expression is preanalyzed because it has not been moved to its\n+      --  final place yet. A direct analysis may generate sife effects and this\n+      --  is not desired at this point.\n+\n+      Preanalyze_And_Resolve (Expr, Standard_Boolean);\n+\n+      --  Perform variable matching only when the expression is legal\n+\n+      if Serious_Errors_Detected = Errors then\n+         Collect_Variables;\n+\n+         --  Verify that all variables mentioned in pragma Initializes are used\n+         --  in the expression of pragma Initial_Condition.\n+\n+         Match_Variables (Expr);\n+      end if;\n+\n+      --  Emit errors for all variables that should participate in the\n+      --  expression of pragma Initial_Condition.\n+\n+      if Serious_Errors_Detected = Errors then\n+         Report_Unused_Variables;\n+      end if;\n+   end Analyze_Initial_Condition_In_Decl_Part;\n+\n    --------------------------------------\n    -- Analyze_Initializes_In_Decl_Part --\n    --------------------------------------\n@@ -2451,10 +2639,10 @@ package body Sem_Prag is\n       --  UU_Typ is the related Unchecked_Union type. Flag In_Variant_Part\n       --  should be set when Comp comes from a record variant.\n \n-      procedure Check_Declaration_Order (States : Node_Id; Inits : Node_Id);\n-      --  Subsidiary routine to the analysis of pragmas Abstract_State and\n-      --  Initializes. Determine whether pragma Abstract_State denoted by\n-      --  States is defined earlier than pragma Initializes denoted by Inits.\n+      procedure Check_Declaration_Order (First : Node_Id; Second : Node_Id);\n+      --  Subsidiary routine to the analysis of pragmas Abstract_State,\n+      --  Initial_Condition and Initializes. Determine whether pragma First\n+      --  appears before pragma Second. If this is not the case, emit an error.\n \n       procedure Check_Duplicate_Pragma (E : Entity_Id);\n       --  Check if a rep item of the same name as the current pragma is already\n@@ -3433,7 +3621,7 @@ package body Sem_Prag is\n       -- Check_Declaration_Order --\n       -----------------------------\n \n-      procedure Check_Declaration_Order (States : Node_Id; Inits : Node_Id) is\n+      procedure Check_Declaration_Order (First : Node_Id; Second : Node_Id) is\n          procedure Check_Aspect_Specification_Order;\n          --  Inspect the aspect specifications of the context to determine the\n          --  proper order.\n@@ -3443,33 +3631,34 @@ package body Sem_Prag is\n          --------------------------------------\n \n          procedure Check_Aspect_Specification_Order is\n-            Asp_I : constant Node_Id := Corresponding_Aspect (Inits);\n-            Asp_S : constant Node_Id := Corresponding_Aspect (States);\n-            Asp   : Node_Id;\n-\n-            States_Seen : Boolean := False;\n+            Asp_First  : constant Node_Id := Corresponding_Aspect (First);\n+            Asp_Second : constant Node_Id := Corresponding_Aspect (Second);\n+            Asp        : Node_Id;\n \n          begin\n             --  Both aspects must be part of the same aspect specification list\n \n-            pragma Assert (List_Containing (Asp_I) = List_Containing (Asp_S));\n+            pragma Assert\n+              (List_Containing (Asp_First) = List_Containing (Asp_Second));\n \n-            Asp := First (List_Containing (Asp_I));\n+            --  Try to reach Second starting from First in a left to right\n+            --  traversal of the aspect specifications.\n+\n+            Asp := Next (Asp_First);\n             while Present (Asp) loop\n-               if Get_Aspect_Id (Asp) = Aspect_Abstract_State then\n-                  States_Seen := True;\n \n-               elsif Get_Aspect_Id (Asp) = Aspect_Initializes then\n-                  if not States_Seen then\n-                     Error_Msg_N\n-                       (\"aspect % must come before aspect %\", States);\n-                  end if;\n+               --  The order is ok, First is followed by Second\n \n-                  exit;\n+               if Asp = Asp_Second then\n+                  return;\n                end if;\n \n                Next (Asp);\n             end loop;\n+\n+            --  If we get here, then the aspects are out of order\n+\n+            Error_Msg_N (\"aspect % cannot come after aspect %\", First);\n          end Check_Aspect_Specification_Order;\n \n          --  Local variables\n@@ -3481,44 +3670,41 @@ package body Sem_Prag is\n       begin\n          --  Cannot check the order if one of the pragmas is missing\n \n-         if No (States) or else No (Inits) then\n+         if No (First) or else No (Second) then\n             return;\n          end if;\n \n          --  Set up the error names in case the order is incorrect\n \n-         Error_Msg_Name_1 := Name_Abstract_State;\n-         Error_Msg_Name_2 := Name_Initializes;\n+         Error_Msg_Name_1 := Pragma_Name (First);\n+         Error_Msg_Name_2 := Pragma_Name (Second);\n \n-         if From_Aspect_Specification (States) then\n+         if From_Aspect_Specification (First) then\n \n             --  Both pragmas are actually aspects, check their declaration\n             --  order in the associated aspect specification list. Otherwise\n-            --  States is an aspect and Inits a source pragma.\n+            --  First is an aspect and Second a source pragma.\n \n-            if From_Aspect_Specification (Inits) then\n+            if From_Aspect_Specification (Second) then\n                Check_Aspect_Specification_Order;\n             end if;\n \n          --  Abstract_States is a source pragma\n \n          else\n-            if From_Aspect_Specification (Inits) then\n-               Error_Msg_N (\"pragma % cannot come after aspect %\", States);\n+            if From_Aspect_Specification (Second) then\n+               Error_Msg_N (\"pragma % cannot come after aspect %\", First);\n \n-            --  Both pragmas are source constructs. Try to reach States from\n-            --  Inits by traversing the declarations backwards.\n+            --  Both pragmas are source constructs. Try to reach First from\n+            --  Second by traversing the declarations backwards.\n \n             else\n-               Stmt := Prev (Inits);\n+               Stmt := Prev (Second);\n                while Present (Stmt) loop\n \n-                  --  The order is ok, Abstract_States is first followed by\n-                  --  Initializes.\n+                  --  The order is ok, First is followed by Second\n \n-                  if Nkind (Stmt) = N_Pragma\n-                    and then Pragma_Name (Stmt) = Name_Abstract_State\n-                  then\n+                  if Stmt = First then\n                      return;\n                   end if;\n \n@@ -3527,7 +3713,7 @@ package body Sem_Prag is\n \n                --  If we get here, then the pragmas are out of order\n \n-               Error_Msg_N (\"pragma % cannot come after pragma %\", States);\n+               Error_Msg_N (\"pragma % cannot come after pragma %\", First);\n             end if;\n          end if;\n       end Check_Declaration_Order;\n@@ -9318,8 +9504,8 @@ package body Sem_Prag is\n             --  Initializes.\n \n             Check_Declaration_Order\n-              (States => N,\n-               Inits  => Get_Pragma (Pack_Id, Pragma_Initializes));\n+              (First  => N,\n+               Second => Get_Pragma (Pack_Id, Pragma_Initializes));\n \n             State := Expression (Arg1);\n \n@@ -9732,6 +9918,7 @@ package body Sem_Prag is\n          --                        Assume               |\n          --                        Contract_Cases       |\n          --                        Debug                |\n+         --                        Initial_Condition    |\n          --                        Loop_Invariant       |\n          --                        Loop_Variant         |\n          --                        Postcondition        |\n@@ -13380,6 +13567,80 @@ package body Sem_Prag is\n             end if;\n          end Independent_Components;\n \n+         -----------------------\n+         -- Initial_Condition --\n+         -----------------------\n+\n+         --  pragma Initial_Condition (boolean_EXPRESSION);\n+\n+         when Pragma_Initial_Condition => Initial_Condition : declare\n+            Context : constant Node_Id := Parent (Parent (N));\n+            Pack_Id : Entity_Id;\n+            Stmt    : Node_Id;\n+\n+         begin\n+            GNAT_Pragma;\n+            S14_Pragma;\n+            Check_Arg_Count (1);\n+\n+            --  Ensure the proper placement of the pragma. Initial_Condition\n+            --  must be associated with a package declaration.\n+\n+            if not Nkind_In (Context, N_Generic_Package_Declaration,\n+                                      N_Package_Declaration)\n+            then\n+               Pragma_Misplaced;\n+               return;\n+            end if;\n+\n+            Stmt := Prev (N);\n+            while Present (Stmt) loop\n+\n+               --  Skip prior pragmas, but check for duplicates\n+\n+               if Nkind (Stmt) = N_Pragma then\n+                  if Pragma_Name (Stmt) = Pname then\n+                     Error_Msg_Name_1 := Pname;\n+                     Error_Msg_Sloc   := Sloc (Stmt);\n+                     Error_Msg_N (\"pragma % duplicates pragma declared #\", N);\n+                  end if;\n+\n+               --  Skip internally generated code\n+\n+               elsif not Comes_From_Source (Stmt) then\n+                  null;\n+\n+               --  The pragma does not apply to a legal construct, issue an\n+               --  error and stop the analysis.\n+\n+               else\n+                  Pragma_Misplaced;\n+                  return;\n+               end if;\n+\n+               Stmt := Prev (Stmt);\n+            end loop;\n+\n+            --  The pragma must be analyzed at the end of the visible\n+            --  declarations of the related package. Save the pragma for later\n+            --  (see Analyze_Initial_Condition_In_Decl_Part) by adding it to\n+            --  the contract of the package.\n+\n+            Pack_Id := Defining_Entity (Context);\n+            Add_Contract_Item (N, Pack_Id);\n+\n+            --  Verify the declaration order of pragma Initial_Condition with\n+            --  respect to pragmas Abstract_State and Initializes.\n+\n+            Check_Declaration_Order\n+              (First  => Get_Pragma (Pack_Id, Pragma_Abstract_State),\n+               Second => N);\n+\n+            Check_Declaration_Order\n+              (First  => Get_Pragma (Pack_Id, Pragma_Initializes),\n+               Second => N);\n+         end Initial_Condition;\n+\n          ------------------------\n          -- Initialize_Scalars --\n          ------------------------\n@@ -13461,8 +13722,8 @@ package body Sem_Prag is\n                elsif not Comes_From_Source (Stmt) then\n                   null;\n \n-                  --  The pragma does not apply to a legal construct, issue an\n-                  --  error and stop the analysis.\n+               --  The pragma does not apply to a legal construct, issue an\n+               --  error and stop the analysis.\n \n                else\n                   Pragma_Misplaced;\n@@ -13484,8 +13745,8 @@ package body Sem_Prag is\n             --  Initializes.\n \n             Check_Declaration_Order\n-              (States => Get_Pragma (Pack_Id, Pragma_Abstract_State),\n-               Inits  => N);\n+              (First  => Get_Pragma (Pack_Id, Pragma_Abstract_State),\n+               Second => N);\n          end Initializes;\n \n          ------------\n@@ -16979,8 +17240,8 @@ package body Sem_Prag is\n                elsif not Comes_From_Source (Stmt) then\n                   null;\n \n-                  --  The pragma does not apply to a legal construct, issue an\n-                  --  error and stop the analysis.\n+               --  The pragma does not apply to a legal construct, issue an\n+               --  error and stop the analysis.\n \n                else\n                   Pragma_Misplaced;\n@@ -22429,6 +22690,7 @@ package body Sem_Prag is\n       Pragma_Import_Valued_Procedure        =>  0,\n       Pragma_Independent                    =>  0,\n       Pragma_Independent_Components         =>  0,\n+      Pragma_Initial_Condition              => -1,\n       Pragma_Initialize_Scalars             => -1,\n       Pragma_Initializes                    => -1,\n       Pragma_Inline                         =>  0,\n@@ -22822,6 +23084,7 @@ package body Sem_Prag is\n             Name_Assume               |\n             Name_Contract_Cases       |\n             Name_Debug                |\n+            Name_Initial_Condition    |\n             Name_Invariant            |\n             Name_uInvariant           |\n             Name_Loop_Invariant       |"}, {"sha": "9f88638e921eb2f109c639f7fd0682d32690c9dc", "filename": "gcc/ada/sem_prag.ads", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b2451e5b31bcea0398b5cb8574d516c97efa0f9/gcc%2Fada%2Fsem_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b2451e5b31bcea0398b5cb8574d516c97efa0f9/gcc%2Fada%2Fsem_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.ads?ref=9b2451e5b31bcea0398b5cb8574d516c97efa0f9", "patch": "@@ -64,6 +64,9 @@ package Sem_Prag is\n    --  Perform full analysis of delayed pragma Global. This routine is also\n    --  capable of performing basic analysis of pragma Refind_Global.\n \n+   procedure Analyze_Initial_Condition_In_Decl_Part (N : Node_Id);\n+   --  Perform full analysis of delayed pragma Initial_Condition\n+\n    procedure Analyze_Initializes_In_Decl_Part (N : Node_Id);\n    --  Perform full analysis of delayed pragma Initializes\n "}, {"sha": "add58bf5aebb6d1cbcf8cd0f30a4f6448e7e6ea5", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b2451e5b31bcea0398b5cb8574d516c97efa0f9/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b2451e5b31bcea0398b5cb8574d516c97efa0f9/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=9b2451e5b31bcea0398b5cb8574d516c97efa0f9", "patch": "@@ -229,10 +229,14 @@ package body Sem_Util is\n       --  Contract items related to [generic] packages. The applicable pragmas\n       --  are:\n       --    Abstract_States\n+      --    Initial_Condition\n       --    Initializes\n \n       if Ekind_In (Id, E_Generic_Package, E_Package) then\n-         if Nam_In (Nam, Name_Abstract_State, Name_Initializes) then\n+         if Nam_In (Nam, Name_Abstract_State,\n+                         Name_Initial_Condition,\n+                         Name_Initializes)\n+         then\n             Set_Next_Pragma (Prag, Classifications (Items));\n             Set_Classifications (Items, Prag);\n "}, {"sha": "bf9987cb7b8241bfd0f9524b31c94924e10e6f75", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b2451e5b31bcea0398b5cb8574d516c97efa0f9/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b2451e5b31bcea0398b5cb8574d516c97efa0f9/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=9b2451e5b31bcea0398b5cb8574d516c97efa0f9", "patch": "@@ -50,6 +50,7 @@ package Sem_Util is\n    --    Contract_Cases\n    --    Depends\n    --    Global\n+   --    Initial_Condition\n    --    Initializes\n    --    Postcondition\n    --    Precondition"}, {"sha": "eecc2d49960532284e69c689bf678d7188b02908", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b2451e5b31bcea0398b5cb8574d516c97efa0f9/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b2451e5b31bcea0398b5cb8574d516c97efa0f9/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=9b2451e5b31bcea0398b5cb8574d516c97efa0f9", "patch": "@@ -7198,6 +7198,7 @@ package Sinfo is\n       --    Abstract_States\n       --    Depends\n       --    Global\n+      --    Initial_Condition\n       --    Initializes\n       --    Refined_Depends\n       --    Refined_Global"}, {"sha": "577e9ecadf0e493600069e07d3c0f23f2bc451fb", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b2451e5b31bcea0398b5cb8574d516c97efa0f9/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b2451e5b31bcea0398b5cb8574d516c97efa0f9/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=9b2451e5b31bcea0398b5cb8574d516c97efa0f9", "patch": "@@ -509,6 +509,7 @@ package Snames is\n    Name_Import_Valued_Procedure        : constant Name_Id := N + $; -- GNAT\n    Name_Independent                    : constant Name_Id := N + $; -- Ada 12\n    Name_Independent_Components         : constant Name_Id := N + $; -- Ada 12\n+   Name_Initial_Condition              : constant Name_Id := N + $; -- GNAT\n    Name_Initializes                    : constant Name_Id := N + $; -- GNAT\n    Name_Inline                         : constant Name_Id := N + $;\n    Name_Inline_Always                  : constant Name_Id := N + $; -- GNAT\n@@ -1829,6 +1830,7 @@ package Snames is\n       Pragma_Import_Valued_Procedure,\n       Pragma_Independent,\n       Pragma_Independent_Components,\n+      Pragma_Initial_Condition,\n       Pragma_Initializes,\n       Pragma_Inline,\n       Pragma_Inline_Always,"}]}