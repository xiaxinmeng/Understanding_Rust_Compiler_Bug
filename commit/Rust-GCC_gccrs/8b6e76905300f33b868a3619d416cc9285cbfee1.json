{"sha": "8b6e76905300f33b868a3619d416cc9285cbfee1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGI2ZTc2OTA1MzAwZjMzYjg2OGEzNjE5ZDQxNmNjOTI4NWNiZmVlMQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2005-04-05T22:26:26Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2005-04-05T22:26:26Z"}, "message": "jni.cc (_Jv_JNI_GetAnyFieldID): Throw ClassNotFoundException.\n\n\t* jni.cc (_Jv_JNI_GetAnyFieldID): Throw ClassNotFoundException.\n\t* java/lang/reflect/natMethod.cc (_Jv_GetTypesFromSignature):\n\tRewrote to use _Jv_FindClassFromSignature.\n\t* verify.cc (resolve): throw NoClassDefFoundError.\n\t* link.cc (resolve_field): Throw NoClassDefFoundError.\n\t(find_field): Likewise.\n\t* prims.cc (_Jv_FindClassFromSignature): Removed recursion.\n\tHandle error cases.  Added 'endp' argument.\n\t* include/jvm.h (_Jv_FindClassFromSignature): Updated prototype.\n\nFrom-SVN: r97660", "tree": {"sha": "2e7ab5655ae0f92acaf1825446f2fec39bb2a56e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e7ab5655ae0f92acaf1825446f2fec39bb2a56e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b6e76905300f33b868a3619d416cc9285cbfee1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b6e76905300f33b868a3619d416cc9285cbfee1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b6e76905300f33b868a3619d416cc9285cbfee1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b6e76905300f33b868a3619d416cc9285cbfee1/comments", "author": null, "committer": null, "parents": [{"sha": "13148dd26aafe25ef31d5303f6383d464cc8db61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13148dd26aafe25ef31d5303f6383d464cc8db61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13148dd26aafe25ef31d5303f6383d464cc8db61"}], "stats": {"total": 188, "additions": 117, "deletions": 71}, "files": [{"sha": "6411c2a9692dc11e341e675dae99958bf70ac1d5", "filename": "libjava/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b6e76905300f33b868a3619d416cc9285cbfee1/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b6e76905300f33b868a3619d416cc9285cbfee1/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=8b6e76905300f33b868a3619d416cc9285cbfee1", "patch": "@@ -1,3 +1,15 @@\n+2005-04-05  Tom Tromey  <tromey@redhat.com>\n+\n+\t* jni.cc (_Jv_JNI_GetAnyFieldID): Throw ClassNotFoundException.\n+\t* java/lang/reflect/natMethod.cc (_Jv_GetTypesFromSignature):\n+\tRewrote to use _Jv_FindClassFromSignature.\n+\t* verify.cc (resolve): throw NoClassDefFoundError.\n+\t* link.cc (resolve_field): Throw NoClassDefFoundError.\n+\t(find_field): Likewise.\n+\t* prims.cc (_Jv_FindClassFromSignature): Removed recursion.\n+\tHandle error cases.  Added 'endp' argument.\n+\t* include/jvm.h (_Jv_FindClassFromSignature): Updated prototype.\n+\n 2005-04-05  Tom Tromey  <tromey@redhat.com>\n \n \t* Makefile.in: Rebuilt."}, {"sha": "bbc809bc162253596945d382ec82e1cd6af230ae", "filename": "libjava/include/jvm.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b6e76905300f33b868a3619d416cc9285cbfee1/libjava%2Finclude%2Fjvm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b6e76905300f33b868a3619d416cc9285cbfee1/libjava%2Finclude%2Fjvm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjvm.h?ref=8b6e76905300f33b868a3619d416cc9285cbfee1", "patch": "@@ -448,7 +448,8 @@ extern void _Jv_UnregisterClass (_Jv_Utf8Const*, java::lang::ClassLoader*);\n extern jclass _Jv_FindClass (_Jv_Utf8Const *name,\n \t\t\t     java::lang::ClassLoader *loader);\n extern jclass _Jv_FindClassFromSignature (char *,\n-\t\t\t\t\t  java::lang::ClassLoader *loader);\n+\t\t\t\t\t  java::lang::ClassLoader *loader,\n+\t\t\t\t\t  char ** = NULL);\n extern void _Jv_GetTypesFromSignature (jmethodID method,\n \t\t\t\t       jclass declaringClass,\n \t\t\t\t       JArray<jclass> **arg_types_out,"}, {"sha": "b8d87c6062bc3cd4fda15b441be1678091554834", "filename": "libjava/java/lang/natClassLoader.cc", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b6e76905300f33b868a3619d416cc9285cbfee1/libjava%2Fjava%2Flang%2FnatClassLoader.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b6e76905300f33b868a3619d416cc9285cbfee1/libjava%2Fjava%2Flang%2FnatClassLoader.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClassLoader.cc?ref=8b6e76905300f33b868a3619d416cc9285cbfee1", "patch": "@@ -252,27 +252,30 @@ _Jv_FindClass (_Jv_Utf8Const *name, java::lang::ClassLoader *loader)\n \t  // Not even a bootstrap loader, try the built-in cache.\n \t  klass = _Jv_FindClassInCache (name);\n \n-\t  bool found = false;\n-\t  for (int i = 0; i < bootstrap_index; ++i)\n+\t  if (klass)\n \t    {\n-\t      if (bootstrap_class_list[i] == klass)\n+\t      bool found = false;\n+\t      for (int i = 0; i < bootstrap_index; ++i)\n \t\t{\n-\t\t  found = true;\n-\t\t  break;\n+\t\t  if (bootstrap_class_list[i] == klass)\n+\t\t    {\n+\t\t      found = true;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      if (! found)\n+\t\t{\n+\t\t  if (bootstrap_index == BOOTSTRAP_CLASS_LIST_SIZE)\n+\t\t    abort ();\n+\t\t  bootstrap_class_list[bootstrap_index++] = klass;\n \t\t}\n-\t    }\n-\t  if (! found)\n-\t    {\n-\t      if (bootstrap_index == BOOTSTRAP_CLASS_LIST_SIZE)\n-\t\tabort ();\n-\t      bootstrap_class_list[bootstrap_index++] = klass;\n \t    }\n \t}\n     }\n   else\n     {\n-      // we need classes to be in the hash while\n-      // we're loading, so that they can refer to themselves. \n+      // We need classes to be in the hash while we're loading, so\n+      // that they can refer to themselves.\n       _Jv_Linker::wait_for_state (klass, JV_STATE_LOADED);\n     }\n "}, {"sha": "182b8d72743b01a26e6ac1e31e4e3ffcacac4ccd", "filename": "libjava/java/lang/natVMClassLoader.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b6e76905300f33b868a3619d416cc9285cbfee1/libjava%2Fjava%2Flang%2FnatVMClassLoader.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b6e76905300f33b868a3619d416cc9285cbfee1/libjava%2Fjava%2Flang%2FnatVMClassLoader.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatVMClassLoader.cc?ref=8b6e76905300f33b868a3619d416cc9285cbfee1", "patch": "@@ -123,6 +123,7 @@ java::lang::VMClassLoader::getPrimitiveClass (jchar type)\n   char sig[2];\n   sig[0] = (char) type;\n   sig[1] = '\\0';\n+  // Note: this cannot return NULL, since the input is always correct.\n   return _Jv_FindClassFromSignature (sig, NULL);\n }\n "}, {"sha": "b616d1bab63508739254c29f1741ff66a1790a60", "filename": "libjava/java/lang/reflect/natMethod.cc", "status": "modified", "additions": 14, "deletions": 29, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b6e76905300f33b868a3619d416cc9285cbfee1/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b6e76905300f33b868a3619d416cc9285cbfee1/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc?ref=8b6e76905300f33b868a3619d416cc9285cbfee1", "patch": "@@ -38,6 +38,7 @@ details.  */\n #include <java/lang/Class.h>\n #include <gcj/method.h>\n #include <gnu/gcj/RawData.h>\n+#include <java/lang/NoClassDefFoundError.h>\n \n #include <stdlib.h>\n \n@@ -235,6 +236,8 @@ _Jv_GetTypesFromSignature (jmethodID method,\n   char *ptr = sig->chars();\n   int numArgs = 0;\n   /* First just count the number of parameters. */\n+  // FIXME: should do some validation here, e.g., that there is only\n+  // one return type.\n   for (; ; ptr++)\n     {\n       switch (*ptr)\n@@ -271,44 +274,26 @@ _Jv_GetTypesFromSignature (jmethodID method,\n   jclass* argPtr = elements (args);\n   for (ptr = sig->chars(); *ptr != '\\0'; ptr++)\n     {\n-      int num_arrays = 0;\n-      jclass type;\n-      for (; *ptr == '[';  ptr++)\n-\tnum_arrays++;\n-      switch (*ptr)\n+      if (*ptr == '(')\n+\tcontinue;\n+      if (*ptr == ')')\n \t{\n-\tdefault:\n-\t  return;\n-\tcase ')':\n \t  argPtr = return_type_out;\n \t  continue;\n-\tcase '(':\n-\t  continue;\n-\tcase 'V':\n-\tcase 'B':\n-\tcase 'C':\n-\tcase 'D':\n-\tcase 'F':\n-\tcase 'S':\n-\tcase 'I':\n-\tcase 'J':\n-\tcase 'Z':\n-\t  type = _Jv_FindClassFromSignature(ptr, loader);\n-\t  break;\n-\tcase 'L':\n-\t  type = _Jv_FindClassFromSignature(ptr, loader);\n-\t  do \n-\t    ptr++;\n-\t  while (*ptr != ';' && ptr[1] != '\\0');\n-\t  break;\n \t}\n \n-      while (--num_arrays >= 0)\n-\ttype = _Jv_GetArrayClass (type, loader);\n+      char *end_ptr;\n+      jclass type = _Jv_FindClassFromSignature (ptr, loader, &end_ptr);\n+      if (type == NULL)\n+\t// FIXME: This isn't ideal.\n+\tthrow new java::lang::NoClassDefFoundError (sig->toString());\n+\n       // ARGPTR can be NULL if we are processing the return value of a\n       // call from Constructor.\n       if (argPtr)\n \t*argPtr++ = type;\n+\n+      ptr = end_ptr;\n     }\n   *arg_types_out = args;\n }"}, {"sha": "b68c3bb887f0533511e37a62b0d63c6261163a10", "filename": "libjava/jni.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b6e76905300f33b868a3619d416cc9285cbfee1/libjava%2Fjni.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b6e76905300f33b868a3619d416cc9285cbfee1/libjava%2Fjni.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni.cc?ref=8b6e76905300f33b868a3619d416cc9285cbfee1", "patch": "@@ -46,6 +46,7 @@ details.  */\n #include <java/nio/DirectByteBufferImpl$ReadWrite.h>\n #include <java/util/IdentityHashMap.h>\n #include <gnu/gcj/RawData.h>\n+#include <java/lang/ClassNotFoundException.h>\n \n #include <gcj/method.h>\n #include <gcj/field.h>\n@@ -1200,8 +1201,8 @@ _Jv_JNI_GetAnyFieldID (JNIEnv *env, jclass clazz,\n       for (int i = 0; i <= len; ++i)\n \ts[i] = (sig[i] == '/') ? '.' : sig[i];\n       jclass field_class = _Jv_FindClassFromSignature ((char *) s, NULL);\n-\n-      // FIXME: what if field_class == NULL?\n+      if (! field_class)\n+\tthrow new java::lang::ClassNotFoundException(JvNewStringUTF(s));\n \n       java::lang::ClassLoader *loader = clazz->getClassLoaderInternal ();\n       while (clazz != NULL)"}, {"sha": "176b538d64a9db04b4c9d94bba22af82868d069f", "filename": "libjava/link.cc", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b6e76905300f33b868a3619d416cc9285cbfee1/libjava%2Flink.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b6e76905300f33b868a3619d416cc9285cbfee1/libjava%2Flink.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Flink.cc?ref=8b6e76905300f33b868a3619d416cc9285cbfee1", "patch": "@@ -90,8 +90,11 @@ _Jv_Linker::resolve_field (_Jv_Field *field, java::lang::ClassLoader *loader)\n {\n   if (! field->isResolved ())\n     {\n-      _Jv_Utf8Const *sig = (_Jv_Utf8Const*)field->type;\n-      field->type = _Jv_FindClassFromSignature (sig->chars(), loader);\n+      _Jv_Utf8Const *sig = (_Jv_Utf8Const *) field->type;\n+      jclass type = _Jv_FindClassFromSignature (sig->chars(), loader);\n+      if (type == NULL)\n+\tthrow new java::lang::NoClassDefFoundError(field->name->toString());\n+      field->type = type;\n       field->flags &= ~_Jv_FIELD_UNRESOLVED_FLAG;\n     }\n }\n@@ -174,6 +177,8 @@ _Jv_Linker::find_field (jclass klass, jclass owner,\n   // it cheaper.\n   jclass field_type = _Jv_FindClassFromSignature (field_type_name->chars(),\n \t\t\t\t\t\t  klass->loader);\n+  if (field_type == NULL)\n+    throw new java::lang::NoClassDefFoundError(field_name->toString());\n \n   jclass found_class = 0;\n   _Jv_Field *the_field = find_field_helper (owner, field_name,"}, {"sha": "fadc466bc0e9d3623e1ebbc6200a5990710b858d", "filename": "libjava/prims.cc", "status": "modified", "additions": 56, "deletions": 23, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b6e76905300f33b868a3619d416cc9285cbfee1/libjava%2Fprims.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b6e76905300f33b868a3619d416cc9285cbfee1/libjava%2Fprims.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fprims.cc?ref=8b6e76905300f33b868a3619d416cc9285cbfee1", "patch": "@@ -675,46 +675,79 @@ _Jv_InitPrimClass (jclass cl, char *cname, char sig, int len)\n }\n \n jclass\n-_Jv_FindClassFromSignature (char *sig, java::lang::ClassLoader *loader)\n+_Jv_FindClassFromSignature (char *sig, java::lang::ClassLoader *loader,\n+\t\t\t    char **endp)\n {\n+  // First count arrays.\n+  int array_count = 0;\n+  while (*sig == '[')\n+    {\n+      ++sig;\n+      ++array_count;\n+    }\n+\n+  jclass result = NULL;\n   switch (*sig)\n     {\n     case 'B':\n-      return JvPrimClass (byte);\n+      result = JvPrimClass (byte);\n+      break;\n     case 'S':\n-      return JvPrimClass (short);\n+      result = JvPrimClass (short);\n+      break;\n     case 'I':\n-      return JvPrimClass (int);\n+      result = JvPrimClass (int);\n+      break;\n     case 'J':\n-      return JvPrimClass (long);\n+      result = JvPrimClass (long);\n+      break;\n     case 'Z':\n-      return JvPrimClass (boolean);\n+      result = JvPrimClass (boolean);\n+      break;\n     case 'C':\n-      return JvPrimClass (char);\n+      result = JvPrimClass (char);\n+      break;\n     case 'F':\n-      return JvPrimClass (float);\n+      result = JvPrimClass (float);\n+      break;\n     case 'D':\n-      return JvPrimClass (double);\n+      result = JvPrimClass (double);\n+      break;\n     case 'V':\n-      return JvPrimClass (void);\n+      result = JvPrimClass (void);\n+      break;\n     case 'L':\n       {\n-\tint i;\n-\tfor (i = 1; sig[i] && sig[i] != ';'; ++i)\n-\t  ;\n-\t_Jv_Utf8Const *name = _Jv_makeUtf8Const (&sig[1], i - 1);\n-\treturn _Jv_FindClass (name, loader);\n-      }\n-    case '[':\n-      {\n-\tjclass klass = _Jv_FindClassFromSignature (&sig[1], loader);\n-\tif (! klass)\n-\t  return NULL;\n-\treturn _Jv_GetArrayClass (klass, loader);\n+\tchar *save = ++sig;\n+\twhile (*sig && *sig != ';')\n+\t  ++sig;\n+\t// Do nothing if signature appears to be malformed.\n+\tif (*sig == ';')\n+\t  {\n+\t    _Jv_Utf8Const *name = _Jv_makeUtf8Const (save, sig - save);\n+\t    result = _Jv_FindClass (name, loader);\n+\t  }\n+\tbreak;\n       }\n+    default:\n+      // Do nothing -- bad signature.\n+      break;\n     }\n \n-  return NULL;\t\t\t// Placate compiler.\n+  if (endp)\n+    {\n+      // Not really the \"end\", but the last valid character that we\n+      // looked at.\n+      *endp = sig;\n+    }\n+\n+  if (! result)\n+    return NULL;\n+\n+  // Find arrays.\n+  while (array_count-- > 0)\n+    result = _Jv_GetArrayClass (result, loader);\n+  return result;\n }\n \n \f"}, {"sha": "a47571bb809e9c8e5073473f4d1537250aa874f4", "filename": "libjava/verify.cc", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b6e76905300f33b868a3619d416cc9285cbfee1/libjava%2Fverify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b6e76905300f33b868a3619d416cc9285cbfee1/libjava%2Fverify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fverify.cc?ref=8b6e76905300f33b868a3619d416cc9285cbfee1", "patch": "@@ -31,6 +31,7 @@ details.  */\n #include <java/lang/Throwable.h>\n #include <java/lang/reflect/Modifier.h>\n #include <java/lang/StringBuffer.h>\n+#include <java/lang/NoClassDefFoundError.h>\n \n #ifdef VERIFY_DEBUG\n #include <stdio.h>\n@@ -368,7 +369,11 @@ class _Jv_BytecodeVerifier\n \t= verifier->current_class->getClassLoaderInternal();\n       // We might see either kind of name.  Sigh.\n       if (data.name->first() == 'L' && data.name->limit()[-1] == ';')\n-\tdata.klass = _Jv_FindClassFromSignature (data.name->chars(), loader);\n+\t{\n+\t  data.klass = _Jv_FindClassFromSignature (data.name->chars(), loader);\n+\t  if (data.klass == NULL)\n+\t    throw new java::lang::NoClassDefFoundError(data.name->toString());\n+\t}\n       else\n \tdata.klass = Class::forName (_Jv_NewStringUtf8Const (data.name),\n \t\t\t\t     false, loader);"}]}