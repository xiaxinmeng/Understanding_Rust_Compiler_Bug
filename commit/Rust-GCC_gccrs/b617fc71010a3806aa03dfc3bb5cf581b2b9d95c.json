{"sha": "b617fc71010a3806aa03dfc3bb5cf581b2b9d95c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjYxN2ZjNzEwMTBhMzgwNmFhMDNkZmMzYmI1Y2Y1ODFiMmI5ZDk1Yw==", "commit": {"author": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2007-07-26T13:59:57Z"}, "committer": {"name": "Julian Brown", "email": "jules@gcc.gnu.org", "date": "2007-07-26T13:59:57Z"}, "message": "gcc/\n\t* config/arm/arm-protos.h (neon_lane_bounds, neon_const_bounds)\n\t(neon_element_bits): Add prototypes.\n\t* config/arm/arm.c (bounds_check, neon_lane_bounds)\n\t(neon_const_bounds, neon_element_bits): New functions.\n\t* config/arm/neon.md (neon_vget_lane<mode>, neon_vget_lanedi)\n\t(neon_vget_lanev2di, neon_vset_lane<mode>, neon_vset_lanedi)\n\t(neon_vset_lanev2di, neon_vdup_lane<mode>, neon_vdup_lanedi)\n\t(neon_vdup_lanev2di, neon_vcvt_n<mode>, neon_vmul_lane<mode>)\n\t(neon_vmull_lane<mode>, neon_vqdmull_lane<mode>)\n\t(neon_vqdmulh_lane<mode>, neon_vmla_lane<mode>)\n\t(neon_vmlal_lane<mode>, neon_vqdmlal_lane<mode>)\n\t(neon_vmls_lane<mode>, neon_vmlsl_lane<mode>)\n\t(neon_vqdmlsl_lane<mode>, neon_vext<mode>, neon_vshr_n<mode>)\n\t(neon_vshrn_n<mode>, neon_vqshrn_n<mode>, neon_vqshrun_n<mode>)\n\t(neon_vshl_n<mode>, neon_vshl_n<mode>, neon_vqshl_n<mode>)\n\t(neon_vqshlu_n<mode>, neon_vshll_n<mode>, neon_vsra_n<mode>)\n\t(neon_vsri_n<mode>, neon_vsli_n<mode>): Add bounds checks.\n\nFrom-SVN: r126958", "tree": {"sha": "5308bdf94a50f14fcc7f4f684109645946f1fb1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5308bdf94a50f14fcc7f4f684109645946f1fb1c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b617fc71010a3806aa03dfc3bb5cf581b2b9d95c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b617fc71010a3806aa03dfc3bb5cf581b2b9d95c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b617fc71010a3806aa03dfc3bb5cf581b2b9d95c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b617fc71010a3806aa03dfc3bb5cf581b2b9d95c/comments", "author": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "69240fc2324a8e14d2ae14a875f43ec6c2dc1a0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69240fc2324a8e14d2ae14a875f43ec6c2dc1a0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69240fc2324a8e14d2ae14a875f43ec6c2dc1a0c"}], "stats": {"total": 250, "additions": 215, "deletions": 35}, "files": [{"sha": "017187c3b1873068ee6f93852127c4dc170875d6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b617fc71010a3806aa03dfc3bb5cf581b2b9d95c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b617fc71010a3806aa03dfc3bb5cf581b2b9d95c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b617fc71010a3806aa03dfc3bb5cf581b2b9d95c", "patch": "@@ -1,3 +1,23 @@\n+2007-07-26  Julian Brown  <julian@codesourcery.com>\n+\n+\t* config/arm/arm-protos.h (neon_lane_bounds, neon_const_bounds)\n+\t(neon_element_bits): Add prototypes.\n+\t* config/arm/arm.c (bounds_check, neon_lane_bounds)\n+\t(neon_const_bounds, neon_element_bits): New functions.\n+\t* config/arm/neon.md (neon_vget_lane<mode>, neon_vget_lanedi)\n+\t(neon_vget_lanev2di, neon_vset_lane<mode>, neon_vset_lanedi)\n+\t(neon_vset_lanev2di, neon_vdup_lane<mode>, neon_vdup_lanedi)\n+\t(neon_vdup_lanev2di, neon_vcvt_n<mode>, neon_vmul_lane<mode>)\n+\t(neon_vmull_lane<mode>, neon_vqdmull_lane<mode>)\n+\t(neon_vqdmulh_lane<mode>, neon_vmla_lane<mode>)\n+\t(neon_vmlal_lane<mode>, neon_vqdmlal_lane<mode>)\n+\t(neon_vmls_lane<mode>, neon_vmlsl_lane<mode>)\n+\t(neon_vqdmlsl_lane<mode>, neon_vext<mode>, neon_vshr_n<mode>)\n+\t(neon_vshrn_n<mode>, neon_vqshrn_n<mode>, neon_vqshrun_n<mode>)\n+\t(neon_vshl_n<mode>, neon_vshl_n<mode>, neon_vqshl_n<mode>)\n+\t(neon_vqshlu_n<mode>, neon_vshll_n<mode>, neon_vsra_n<mode>)\n+\t(neon_vsri_n<mode>, neon_vsli_n<mode>): Add bounds checks.\n+\n 2007-07-26  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* config/vxworks.h (VXWORKS_LINK_SPEC): Fix typo."}, {"sha": "f7439f24da6ac9b9ad3d2f06dd7023ff7e3646fe", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b617fc71010a3806aa03dfc3bb5cf581b2b9d95c/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b617fc71010a3806aa03dfc3bb5cf581b2b9d95c/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=b617fc71010a3806aa03dfc3bb5cf581b2b9d95c", "patch": "@@ -76,6 +76,9 @@ extern char *neon_output_logic_immediate (const char *, rtx *,\n extern void neon_pairwise_reduce (rtx, rtx, enum machine_mode,\n \t\t\t\t  rtx (*) (rtx, rtx, rtx));\n extern void neon_expand_vector_init (rtx, rtx);\n+extern void neon_lane_bounds (rtx, HOST_WIDE_INT, HOST_WIDE_INT);\n+extern void neon_const_bounds (rtx, HOST_WIDE_INT, HOST_WIDE_INT);\n+extern HOST_WIDE_INT neon_element_bits (enum machine_mode);\n extern void neon_reinterpret (rtx, rtx);\n extern void neon_emit_pair_result_insn (enum machine_mode,\n \t\t\t\t\trtx (*) (rtx, rtx, rtx, rtx),"}, {"sha": "47f33945036423c17b25cd2ca8136422666485e7", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b617fc71010a3806aa03dfc3bb5cf581b2b9d95c/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b617fc71010a3806aa03dfc3bb5cf581b2b9d95c/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=b617fc71010a3806aa03dfc3bb5cf581b2b9d95c", "patch": "@@ -6234,6 +6234,49 @@ neon_expand_vector_init (rtx target, rtx vals)\n   emit_move_insn (target, mem);\n }\n \n+/* Ensure OPERAND lies between LOW (inclusive) and HIGH (exclusive).  Raise\n+   ERR if it doesn't.  FIXME: NEON bounds checks occur late in compilation, so\n+   reported source locations are bogus.  */\n+\n+static void\n+bounds_check (rtx operand, HOST_WIDE_INT low, HOST_WIDE_INT high,\n+\t      const char *err)\n+{\n+  HOST_WIDE_INT lane;\n+\n+  gcc_assert (GET_CODE (operand) == CONST_INT);\n+\n+  lane = INTVAL (operand);\n+\n+  if (lane < low || lane >= high)\n+    error (err);\n+}\n+\n+/* Bounds-check lanes.  */\n+\n+void\n+neon_lane_bounds (rtx operand, HOST_WIDE_INT low, HOST_WIDE_INT high)\n+{\n+  bounds_check (operand, low, high, \"lane out of range\");\n+}\n+\n+/* Bounds-check constants.  */\n+\n+void\n+neon_const_bounds (rtx operand, HOST_WIDE_INT low, HOST_WIDE_INT high)\n+{\n+  bounds_check (operand, low, high, \"constant out of range\");\n+}\n+\n+HOST_WIDE_INT\n+neon_element_bits (enum machine_mode mode)\n+{\n+  if (mode == DImode)\n+    return GET_MODE_BITSIZE (mode);\n+  else\n+    return GET_MODE_BITSIZE (GET_MODE_INNER (mode));\n+}\n+\n \f\n /* Predicates for `match_operand' and `match_operator'.  */\n "}, {"sha": "06b9b3c762ea8776159534c34d15fa9926f56ef9", "filename": "gcc/config/arm/neon.md", "status": "modified", "additions": 149, "deletions": 35, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b617fc71010a3806aa03dfc3bb5cf581b2b9d95c/gcc%2Fconfig%2Farm%2Fneon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b617fc71010a3806aa03dfc3bb5cf581b2b9d95c/gcc%2Fconfig%2Farm%2Fneon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.md?ref=b617fc71010a3806aa03dfc3bb5cf581b2b9d95c", "patch": "@@ -2395,7 +2395,10 @@\n                           (match_operand:SI 3 \"immediate_operand\" \"i\")]\n                          UNSPEC_VGET_LANE))]\n   \"TARGET_NEON\"\n-  \"vmov%?.%t3%#<V_sz_elem>\\t%0, %P1[%c2]\"\n+{\n+  neon_lane_bounds (operands[2], 0, GET_MODE_NUNITS (<MODE>mode));\n+  return \"vmov%?.%t3%#<V_sz_elem>\\t%0, %P1[%c2]\";\n+}\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"neon_type\" \"neon_bp_simple\")]\n )\n@@ -2411,7 +2414,10 @@\n                    (match_operand:SI 3 \"immediate_operand\" \"i\")]\n                   UNSPEC_VGET_LANE))]\n   \"TARGET_NEON\"\n-  \"vmov%?\\t%Q0, %R0, %P1  @ di\"\n+{\n+  neon_lane_bounds (operands[2], 0, 1);\n+  return \"vmov%?\\t%Q0, %R0, %P1  @ di\";\n+}\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"neon_type\" \"neon_bp_simple\")]\n )\n@@ -2429,6 +2435,8 @@\n   unsigned int halfelts = GET_MODE_NUNITS (<MODE>mode) / 2;\n   unsigned int elt = INTVAL (operands[2]);\n \n+  neon_lane_bounds (operands[2], 0, halfelts * 2);\n+\n   ops[0] = operands[0];\n   ops[1] = gen_rtx_REG (<V_HALF>mode, regno + 2 * (elt / halfelts));\n   ops[2] = GEN_INT (elt % halfelts);\n@@ -2453,6 +2461,8 @@\n   unsigned int regno = REGNO (operands[1]);\n   unsigned int elt = INTVAL (operands[2]);\n \n+  neon_lane_bounds (operands[2], 0, 2);\n+\n   ops[0] = operands[0];\n   ops[1] = gen_rtx_REG (DImode, regno + 2 * elt);\n   output_asm_insn (\"vmov%?\\t%Q0, %R0, %P1  @ v2di\", ops);\n@@ -2470,7 +2480,10 @@\n                     (match_operand:SI 3 \"immediate_operand\" \"i\")]\n                    UNSPEC_VSET_LANE))]\n   \"TARGET_NEON\"\n-  \"vmov%?.<V_sz_elem>\\t%P0[%c3], %1\"\n+{\n+  neon_lane_bounds (operands[3], 0, GET_MODE_NUNITS (<MODE>mode));\n+  return \"vmov%?.<V_sz_elem>\\t%P0[%c3], %1\";\n+}\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"neon_type\" \"neon_bp_simple\")]\n )\n@@ -2484,7 +2497,10 @@\n                     (match_operand:SI 3 \"immediate_operand\" \"i\")]\n                    UNSPEC_VSET_LANE))]\n   \"TARGET_NEON\"\n-  \"vmov%?\\t%P0, %Q1, %R1  @ di\"\n+{\n+  neon_lane_bounds (operands[3], 0, 1);\n+  return \"vmov%?\\t%P0, %Q1, %R1  @ di\";\n+}\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"neon_type\" \"neon_bp_simple\")]\n )\n@@ -2502,6 +2518,8 @@\n   unsigned int halfelts = GET_MODE_NUNITS (<MODE>mode) / 2;\n   unsigned int elt = INTVAL (operands[3]);\n \n+  neon_lane_bounds (operands[3], 0, halfelts * 2);\n+\n   ops[0] = gen_rtx_REG (<V_HALF>mode, regno + 2 * (elt / halfelts));\n   ops[1] = operands[1];\n   ops[2] = GEN_INT (elt % halfelts);\n@@ -2525,6 +2543,8 @@\n   unsigned int regno = REGNO (operands[0]);\n   unsigned int elt = INTVAL (operands[3]);\n \n+  neon_lane_bounds (operands[3], 0, 2);\n+\n   ops[0] = gen_rtx_REG (DImode, regno + 2 * elt);\n   ops[1] = operands[1];\n   output_asm_insn (\"vmov%?\\t%P0, %Q1, %R1  @ v2di\", ops);\n@@ -2583,7 +2603,10 @@\n \t\t    (match_operand:SI 2 \"immediate_operand\" \"i\")]\n                    UNSPEC_VDUP_LANE))]\n   \"TARGET_NEON\"\n-  \"vdup.<V_sz_elem>\\t%P0, %P1[%c2]\"\n+{\n+  neon_lane_bounds (operands[2], 0, GET_MODE_NUNITS (<MODE>mode));\n+  return \"vdup.<V_sz_elem>\\t%P0, %P1[%c2]\";\n+}\n   ;; Assume this schedules like vmov.\n   [(set_attr \"neon_type\" \"neon_bp_simple\")]\n )\n@@ -2594,7 +2617,10 @@\n \t\t    (match_operand:SI 2 \"immediate_operand\" \"i\")]\n                    UNSPEC_VDUP_LANE))]\n   \"TARGET_NEON\"\n-  \"vdup.<V_sz_elem>\\t%q0, %P1[%c2]\"\n+{\n+  neon_lane_bounds (operands[2], 0, GET_MODE_NUNITS (<V_HALF>mode));\n+  return \"vdup.<V_sz_elem>\\t%q0, %P1[%c2]\";\n+}\n   ;; Assume this schedules like vmov.\n   [(set_attr \"neon_type\" \"neon_bp_simple\")]\n )\n@@ -2607,6 +2633,7 @@\n                    UNSPEC_VDUP_LANE))]\n   \"TARGET_NEON\"\n {\n+  neon_lane_bounds (operands[2], 0, 1);\n   emit_move_insn (operands[0], operands[1]);\n   DONE;\n })\n@@ -2618,7 +2645,10 @@\n \t\t      (match_operand:SI 2 \"immediate_operand\" \"i\")]\n                      UNSPEC_VDUP_LANE))]\n   \"TARGET_NEON\"\n-  \"vmov\\t%e0, %P1\\;vmov\\t%f0, %P1\"\n+{\n+  neon_lane_bounds (operands[2], 0, 1);\n+  return \"vmov\\t%e0, %P1\\;vmov\\t%f0, %P1\";\n+}\n   [(set_attr \"length\" \"8\")\n    (set_attr \"neon_type\" \"neon_bp_simple\")]\n )\n@@ -2741,7 +2771,10 @@\n                            (match_operand:SI 3 \"immediate_operand\" \"i\")]\n \t\t\t  UNSPEC_VCVT_N))]\n   \"TARGET_NEON\"\n-  \"vcvt.%T3%#32.f32\\t%<V_reg>0, %<V_reg>1, %2\"\n+{\n+  neon_const_bounds (operands[2], 1, 33);\n+  return \"vcvt.%T3%#32.f32\\t%<V_reg>0, %<V_reg>1, %2\";\n+}\n   [(set (attr \"neon_type\")\n      (if_then_else (ne (symbol_ref \"<Is_d_reg>\") (const_int 0))\n                    (const_string \"neon_fp_vadd_ddd_vabs_dd\")\n@@ -2755,7 +2788,10 @@\n                            (match_operand:SI 3 \"immediate_operand\" \"i\")]\n \t\t\t  UNSPEC_VCVT_N))]\n   \"TARGET_NEON\"\n-  \"vcvt.f32.%T3%#32\\t%<V_reg>0, %<V_reg>1, %2\"\n+{\n+  neon_const_bounds (operands[2], 1, 33);\n+  return \"vcvt.f32.%T3%#32\\t%<V_reg>0, %<V_reg>1, %2\";\n+}\n   [(set (attr \"neon_type\")\n      (if_then_else (ne (symbol_ref \"<Is_d_reg>\") (const_int 0))\n                    (const_string \"neon_fp_vadd_ddd_vabs_dd\")\n@@ -2811,7 +2847,10 @@\n                      (match_operand:SI 4 \"immediate_operand\" \"i\")]\n                     UNSPEC_VMUL_LANE))]\n   \"TARGET_NEON\"\n-  \"vmul.<V_if_elem>\\t%P0, %P1, %P2[%c3]\"\n+{\n+  neon_lane_bounds (operands[3], 0, GET_MODE_NUNITS (<MODE>mode));\n+  return \"vmul.<V_if_elem>\\t%P0, %P1, %P2[%c3]\";\n+}\n   [(set (attr \"neon_type\")\n      (if_then_else (ne (symbol_ref \"<Is_float_mode>\") (const_int 0))\n                    (const_string \"neon_fp_vmul_ddd\")\n@@ -2829,7 +2868,10 @@\n                      (match_operand:SI 4 \"immediate_operand\" \"i\")]\n                     UNSPEC_VMUL_LANE))]\n   \"TARGET_NEON\"\n-  \"vmul.<V_if_elem>\\t%q0, %q1, %P2[%c3]\"\n+{\n+  neon_lane_bounds (operands[3], 0, GET_MODE_NUNITS (<V_HALF>mode));\n+  return \"vmul.<V_if_elem>\\t%q0, %q1, %P2[%c3]\";\n+}\n   [(set (attr \"neon_type\")\n      (if_then_else (ne (symbol_ref \"<Is_float_mode>\") (const_int 0))\n                    (const_string \"neon_fp_vmul_qqd\")\n@@ -2847,7 +2889,10 @@\n                            (match_operand:SI 4 \"immediate_operand\" \"i\")]\n                           UNSPEC_VMULL_LANE))]\n   \"TARGET_NEON\"\n-  \"vmull.%T4%#<V_sz_elem>\\t%q0, %P1, %P2[%c3]\"\n+{\n+  neon_lane_bounds (operands[3], 0, GET_MODE_NUNITS (<MODE>mode));\n+  return \"vmull.%T4%#<V_sz_elem>\\t%q0, %P1, %P2[%c3]\";\n+}\n   [(set (attr \"neon_type\")\n      (if_then_else (ne (symbol_ref \"<Scalar_mul_8_16>\") (const_int 0))\n                    (const_string \"neon_mul_ddd_16_scalar_32_16_long_scalar\")\n@@ -2863,7 +2908,10 @@\n                            (match_operand:SI 4 \"immediate_operand\" \"i\")]\n                           UNSPEC_VQDMULL_LANE))]\n   \"TARGET_NEON\"\n-  \"vqdmull.<V_s_elem>\\t%q0, %P1, %P2[%c3]\"\n+{\n+  neon_lane_bounds (operands[3], 0, GET_MODE_NUNITS (<MODE>mode));\n+  return \"vqdmull.<V_s_elem>\\t%q0, %P1, %P2[%c3]\";\n+}\n   [(set (attr \"neon_type\")\n      (if_then_else (ne (symbol_ref \"<Scalar_mul_8_16>\") (const_int 0))\n                    (const_string \"neon_mul_ddd_16_scalar_32_16_long_scalar\")\n@@ -2879,7 +2927,10 @@\n                       (match_operand:SI 4 \"immediate_operand\" \"i\")]\n                       UNSPEC_VQDMULH_LANE))]\n   \"TARGET_NEON\"\n-  \"vq%O4dmulh.%T4%#<V_sz_elem>\\t%q0, %q1, %P2[%c3]\"\n+{\n+  neon_lane_bounds (operands[3], 0, GET_MODE_NUNITS (<MODE>mode));\n+  return \"vq%O4dmulh.%T4%#<V_sz_elem>\\t%q0, %q1, %P2[%c3]\";\n+}\n   [(set (attr \"neon_type\")\n      (if_then_else (ne (symbol_ref \"<Scalar_mul_8_16>\") (const_int 0))\n                    (const_string \"neon_mul_qdd_64_32_long_qqd_16_ddd_32_scalar_64_32_long_scalar\")\n@@ -2895,7 +2946,10 @@\n                       (match_operand:SI 4 \"immediate_operand\" \"i\")]\n                       UNSPEC_VQDMULH_LANE))]\n   \"TARGET_NEON\"\n-  \"vq%O4dmulh.%T4%#<V_sz_elem>\\t%P0, %P1, %P2[%c3]\"\n+{\n+  neon_lane_bounds (operands[3], 0, GET_MODE_NUNITS (<MODE>mode));\n+  return \"vq%O4dmulh.%T4%#<V_sz_elem>\\t%P0, %P1, %P2[%c3]\";\n+}\n   [(set (attr \"neon_type\")\n      (if_then_else (ne (symbol_ref \"<Scalar_mul_8_16>\") (const_int 0))\n                    (const_string \"neon_mul_ddd_16_scalar_32_16_long_scalar\")\n@@ -2912,7 +2966,10 @@\n                      (match_operand:SI 5 \"immediate_operand\" \"i\")]\n                      UNSPEC_VMLA_LANE))]\n   \"TARGET_NEON\"\n-  \"vmla.<V_if_elem>\\t%P0, %P2, %P3[%c4]\"\n+{\n+  neon_lane_bounds (operands[4], 0, GET_MODE_NUNITS (<MODE>mode));\n+  return \"vmla.<V_if_elem>\\t%P0, %P2, %P3[%c4]\";\n+}\n   [(set (attr \"neon_type\")\n      (if_then_else (ne (symbol_ref \"<Is_float_mode>\") (const_int 0))\n                    (const_string \"neon_fp_vmla_ddd_scalar\")\n@@ -2931,7 +2988,10 @@\n                      (match_operand:SI 5 \"immediate_operand\" \"i\")]\n                      UNSPEC_VMLA_LANE))]\n   \"TARGET_NEON\"\n-  \"vmla.<V_if_elem>\\t%q0, %q2, %P3[%c4]\"\n+{\n+  neon_lane_bounds (operands[4], 0, GET_MODE_NUNITS (<MODE>mode));\n+  return \"vmla.<V_if_elem>\\t%q0, %q2, %P3[%c4]\";\n+}\n   [(set (attr \"neon_type\")\n      (if_then_else (ne (symbol_ref \"<Is_float_mode>\") (const_int 0))\n                    (const_string \"neon_fp_vmla_qqq_scalar\")\n@@ -2950,7 +3010,10 @@\n                            (match_operand:SI 5 \"immediate_operand\" \"i\")]\n                           UNSPEC_VMLAL_LANE))]\n   \"TARGET_NEON\"\n-  \"vmlal.%T5%#<V_sz_elem>\\t%q0, %P2, %P3[%c4]\"\n+{\n+  neon_lane_bounds (operands[4], 0, GET_MODE_NUNITS (<MODE>mode));\n+  return \"vmlal.%T5%#<V_sz_elem>\\t%q0, %P2, %P3[%c4]\";\n+}\n   [(set (attr \"neon_type\")\n      (if_then_else (ne (symbol_ref \"<Scalar_mul_8_16>\") (const_int 0))\n                    (const_string \"neon_mla_ddd_16_scalar_qdd_32_16_long_scalar\")\n@@ -2967,7 +3030,10 @@\n                            (match_operand:SI 5 \"immediate_operand\" \"i\")]\n                           UNSPEC_VQDMLAL_LANE))]\n   \"TARGET_NEON\"\n-  \"vqdmlal.<V_s_elem>\\t%q0, %P2, %P3[%c4]\"\n+{\n+  neon_lane_bounds (operands[4], 0, GET_MODE_NUNITS (<MODE>mode));\n+  return \"vqdmlal.<V_s_elem>\\t%q0, %P2, %P3[%c4]\";\n+}\n   [(set (attr \"neon_type\")\n      (if_then_else (ne (symbol_ref \"<Scalar_mul_8_16>\") (const_int 0))\n                    (const_string \"neon_mla_ddd_16_scalar_qdd_32_16_long_scalar\")\n@@ -2984,7 +3050,10 @@\n                      (match_operand:SI 5 \"immediate_operand\" \"i\")]\n                     UNSPEC_VMLS_LANE))]\n   \"TARGET_NEON\"\n-  \"vmls.<V_if_elem>\\t%P0, %P2, %P3[%c4]\"\n+{\n+  neon_lane_bounds (operands[4], 0, GET_MODE_NUNITS (<MODE>mode));\n+  return \"vmls.<V_if_elem>\\t%P0, %P2, %P3[%c4]\";\n+}\n   [(set (attr \"neon_type\")\n      (if_then_else (ne (symbol_ref \"<Is_float_mode>\") (const_int 0))\n                    (const_string \"neon_fp_vmla_ddd_scalar\")\n@@ -3003,7 +3072,10 @@\n                      (match_operand:SI 5 \"immediate_operand\" \"i\")]\n                     UNSPEC_VMLS_LANE))]\n   \"TARGET_NEON\"\n-  \"vmls.<V_if_elem>\\t%q0, %q2, %P3[%c4]\"\n+{\n+  neon_lane_bounds (operands[4], 0, GET_MODE_NUNITS (<MODE>mode));\n+  return \"vmls.<V_if_elem>\\t%q0, %q2, %P3[%c4]\";\n+}\n   [(set (attr \"neon_type\")\n      (if_then_else (ne (symbol_ref \"<Is_float_mode>\") (const_int 0))\n                    (const_string \"neon_fp_vmla_qqq_scalar\")\n@@ -3022,7 +3094,10 @@\n                            (match_operand:SI 5 \"immediate_operand\" \"i\")]\n                           UNSPEC_VMLSL_LANE))]\n   \"TARGET_NEON\"\n-  \"vmlsl.%T5%#<V_sz_elem>\\t%q0, %P2, %P3[%c4]\"\n+{\n+  neon_lane_bounds (operands[4], 0, GET_MODE_NUNITS (<MODE>mode));\n+  return \"vmlsl.%T5%#<V_sz_elem>\\t%q0, %P2, %P3[%c4]\";\n+}\n   [(set (attr \"neon_type\")\n      (if_then_else (ne (symbol_ref \"<Scalar_mul_8_16>\") (const_int 0))\n                    (const_string \"neon_mla_ddd_16_scalar_qdd_32_16_long_scalar\")\n@@ -3039,7 +3114,10 @@\n                            (match_operand:SI 5 \"immediate_operand\" \"i\")]\n                           UNSPEC_VQDMLSL_LANE))]\n   \"TARGET_NEON\"\n-  \"vqdmlsl.<V_s_elem>\\t%q0, %P2, %P3[%c4]\"\n+{\n+  neon_lane_bounds (operands[4], 0, GET_MODE_NUNITS (<MODE>mode));\n+  return \"vqdmlsl.<V_s_elem>\\t%q0, %P2, %P3[%c4]\";\n+}\n   [(set (attr \"neon_type\")\n      (if_then_else (ne (symbol_ref \"<Scalar_mul_8_16>\") (const_int 0))\n                    (const_string \"neon_mla_ddd_16_scalar_qdd_32_16_long_scalar\")\n@@ -3264,7 +3342,10 @@\n                       (match_operand:SI 3 \"immediate_operand\" \"i\")]\n                      UNSPEC_VEXT))]\n   \"TARGET_NEON\"\n-  \"vext.<V_sz_elem>\\t%<V_reg>0, %<V_reg>1, %<V_reg>2, %3\"\n+{\n+  neon_const_bounds (operands[3], 0, GET_MODE_NUNITS (<MODE>mode));\n+  return \"vext.<V_sz_elem>\\t%<V_reg>0, %<V_reg>1, %<V_reg>2, %3\";\n+}\n   [(set (attr \"neon_type\")\n       (if_then_else (ne (symbol_ref \"<Is_d_reg>\") (const_int 0))\n                     (const_string \"neon_bp_simple\")\n@@ -3370,7 +3451,10 @@\n                        (match_operand:SI 3 \"immediate_operand\" \"i\")]\n                       UNSPEC_VSHR_N))]\n   \"TARGET_NEON\"\n-  \"v%O3shr.%T3%#<V_sz_elem>\\t%<V_reg>0, %<V_reg>1, %2\"\n+{\n+  neon_const_bounds (operands[2], 1, neon_element_bits (<MODE>mode) + 1);\n+  return \"v%O3shr.%T3%#<V_sz_elem>\\t%<V_reg>0, %<V_reg>1, %2\";\n+}\n   [(set_attr \"neon_type\" \"neon_shift_1\")]\n )\n \n@@ -3381,7 +3465,10 @@\n \t\t\t    (match_operand:SI 3 \"immediate_operand\" \"i\")]\n                            UNSPEC_VSHRN_N))]\n   \"TARGET_NEON\"\n-  \"v%O3shrn.<V_if_elem>\\t%P0, %q1, %2\"\n+{\n+  neon_const_bounds (operands[2], 1, neon_element_bits (<MODE>mode) / 2 + 1);\n+  return \"v%O3shrn.<V_if_elem>\\t%P0, %q1, %2\";\n+}\n   [(set_attr \"neon_type\" \"neon_shift_1\")]\n )\n \n@@ -3392,7 +3479,10 @@\n \t\t\t    (match_operand:SI 3 \"immediate_operand\" \"i\")]\n                            UNSPEC_VQSHRN_N))]\n   \"TARGET_NEON\"\n-  \"vq%O3shrn.%T3%#<V_sz_elem>\\t%P0, %q1, %2\"\n+{\n+  neon_const_bounds (operands[2], 1, neon_element_bits (<MODE>mode) / 2 + 1);\n+  return \"vq%O3shrn.%T3%#<V_sz_elem>\\t%P0, %q1, %2\";\n+}\n   [(set_attr \"neon_type\" \"neon_shift_2\")]\n )\n \n@@ -3403,7 +3493,10 @@\n \t\t\t    (match_operand:SI 3 \"immediate_operand\" \"i\")]\n                            UNSPEC_VQSHRUN_N))]\n   \"TARGET_NEON\"\n-  \"vq%O3shrun.%T3%#<V_sz_elem>\\t%P0, %q1, %2\"\n+{\n+  neon_const_bounds (operands[2], 1, neon_element_bits (<MODE>mode) / 2 + 1);\n+  return \"vq%O3shrun.%T3%#<V_sz_elem>\\t%P0, %q1, %2\";\n+}\n   [(set_attr \"neon_type\" \"neon_shift_2\")]\n )\n \n@@ -3414,7 +3507,10 @@\n                        (match_operand:SI 3 \"immediate_operand\" \"i\")]\n                       UNSPEC_VSHL_N))]\n   \"TARGET_NEON\"\n-  \"vshl.<V_if_elem>\\t%<V_reg>0, %<V_reg>1, %2\"\n+{\n+  neon_const_bounds (operands[2], 0, neon_element_bits (<MODE>mode));\n+  return \"vshl.<V_if_elem>\\t%<V_reg>0, %<V_reg>1, %2\";\n+}\n   [(set_attr \"neon_type\" \"neon_shift_1\")]\n )\n \n@@ -3425,7 +3521,10 @@\n                        (match_operand:SI 3 \"immediate_operand\" \"i\")]\n                       UNSPEC_VQSHL_N))]\n   \"TARGET_NEON\"\n-  \"vqshl.%T3%#<V_sz_elem>\\t%<V_reg>0, %<V_reg>1, %2\"\n+{\n+  neon_const_bounds (operands[2], 0, neon_element_bits (<MODE>mode));\n+  return \"vqshl.%T3%#<V_sz_elem>\\t%<V_reg>0, %<V_reg>1, %2\";\n+}\n   [(set_attr \"neon_type\" \"neon_shift_2\")]\n )\n \n@@ -3436,7 +3535,10 @@\n                        (match_operand:SI 3 \"immediate_operand\" \"i\")]\n                       UNSPEC_VQSHLU_N))]\n   \"TARGET_NEON\"\n-  \"vqshlu.%T3%#<V_sz_elem>\\t%<V_reg>0, %<V_reg>1, %2\"\n+{\n+  neon_const_bounds (operands[2], 0, neon_element_bits (<MODE>mode));\n+  return \"vqshlu.%T3%#<V_sz_elem>\\t%<V_reg>0, %<V_reg>1, %2\";\n+}\n   [(set_attr \"neon_type\" \"neon_shift_2\")]\n )\n \n@@ -3447,7 +3549,10 @@\n \t\t\t   (match_operand:SI 3 \"immediate_operand\" \"i\")]\n \t\t\t  UNSPEC_VSHLL_N))]\n   \"TARGET_NEON\"\n-  \"vshll.%T3%#<V_sz_elem>\\t%q0, %P1, %2\"\n+{\n+  neon_const_bounds (operands[2], 0, neon_element_bits (<MODE>mode));\n+  return \"vshll.%T3%#<V_sz_elem>\\t%q0, %P1, %2\";\n+}\n   [(set_attr \"neon_type\" \"neon_shift_1\")]\n )\n \n@@ -3459,7 +3564,10 @@\n                        (match_operand:SI 4 \"immediate_operand\" \"i\")]\n                       UNSPEC_VSRA_N))]\n   \"TARGET_NEON\"\n-  \"v%O4sra.%T4%#<V_sz_elem>\\t%<V_reg>0, %<V_reg>2, %3\"\n+{\n+  neon_const_bounds (operands[3], 1, neon_element_bits (<MODE>mode) + 1);\n+  return \"v%O4sra.%T4%#<V_sz_elem>\\t%<V_reg>0, %<V_reg>2, %3\";\n+}\n   [(set_attr \"neon_type\" \"neon_vsra_vrsra\")]\n )\n \n@@ -3470,7 +3578,10 @@\n                        (match_operand:SI 3 \"immediate_operand\" \"i\")]\n                       UNSPEC_VSRI))]\n   \"TARGET_NEON\"\n-  \"vsri.<V_sz_elem>\\t%<V_reg>0, %<V_reg>2, %3\"\n+{\n+  neon_const_bounds (operands[3], 1, neon_element_bits (<MODE>mode) + 1);\n+  return \"vsri.<V_sz_elem>\\t%<V_reg>0, %<V_reg>2, %3\";\n+}\n   [(set (attr \"neon_type\")\n       (if_then_else (ne (symbol_ref \"<Is_d_reg>\") (const_int 0))\n                     (const_string \"neon_shift_1\")\n@@ -3484,7 +3595,10 @@\n                        (match_operand:SI 3 \"immediate_operand\" \"i\")]\n                       UNSPEC_VSLI))]\n   \"TARGET_NEON\"\n-  \"vsli.<V_sz_elem>\\t%<V_reg>0, %<V_reg>2, %3\"\n+{\n+  neon_const_bounds (operands[3], 0, neon_element_bits (<MODE>mode));\n+  return \"vsli.<V_sz_elem>\\t%<V_reg>0, %<V_reg>2, %3\";\n+}\n   [(set (attr \"neon_type\")\n       (if_then_else (ne (symbol_ref \"<Is_d_reg>\") (const_int 0))\n                     (const_string \"neon_shift_1\")"}]}