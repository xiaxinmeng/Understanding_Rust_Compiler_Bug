{"sha": "b780db2ea327f51050d64237e71456b0eacf60e8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjc4MGRiMmVhMzI3ZjUxMDUwZDY0MjM3ZTcxNDU2YjBlYWNmNjBlOA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-05-20T23:59:55Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-05-20T23:59:55Z"}, "message": "libstdc++: Better requirements checking in Networking TS\n\nDefine concepts and traits for checking type requirements.\n\n\t* include/experimental/bits/net.h (__endpoint, __protocol)\n\t(__acceptable_protocol, __inet_protocol): New concepts.\n\t(__detail::__is_endpoint): Move trait from <experimental/socket>.\n\t(__is_protocol, __is_acceptable_protocol, __is_inet_protocol): New\n\ttraits.\n\t(__endpoint, __protocol, __acceptable_protocol): New variable\n\ttemplates.\n\t* include/experimental/socket (__is_endpoint): Move to net.h header.\n\t(basic_socket, basic_socket_acceptor): Check requirements.", "tree": {"sha": "b7ced8ca5f5066189d37413937e378ecfa55d83a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b7ced8ca5f5066189d37413937e378ecfa55d83a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b780db2ea327f51050d64237e71456b0eacf60e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b780db2ea327f51050d64237e71456b0eacf60e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b780db2ea327f51050d64237e71456b0eacf60e8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b780db2ea327f51050d64237e71456b0eacf60e8/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9d34449bbde21f6092153828d1b6ee73bd6c4c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9d34449bbde21f6092153828d1b6ee73bd6c4c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9d34449bbde21f6092153828d1b6ee73bd6c4c3"}], "stats": {"total": 196, "additions": 169, "deletions": 27}, "files": [{"sha": "975de44434bd4d3977ecceb4f506454f77bcb3bc", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b780db2ea327f51050d64237e71456b0eacf60e8/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b780db2ea327f51050d64237e71456b0eacf60e8/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=b780db2ea327f51050d64237e71456b0eacf60e8", "patch": "@@ -1,5 +1,15 @@\n 2020-05-21  Jonathan Wakely  <jwakely@redhat.com>\n \n+\t* include/experimental/bits/net.h (__endpoint, __protocol)\n+\t(__acceptable_protocol, __inet_protocol): New concepts.\n+\t(__detail::__is_endpoint): Move trait from <experimental/socket>.\n+\t(__is_protocol, __is_acceptable_protocol, __is_inet_protocol): New\n+\ttraits.\n+\t(__endpoint, __protocol, __acceptable_protocol): New variable\n+\ttemplates.\n+\t* include/experimental/socket (__is_endpoint): Move to net.h header.\n+\t(basic_socket, basic_socket_acceptor): Check requirements.\n+\n \t* include/experimental/executor (use_future_t::use_future_t()): Fix\n \tincorrect noexcept-specifier.\n \t* include/experimental/internet (basic_resolver_results): Adjust"}, {"sha": "cf7914d0acb7c6a33fbc9afeb82b7bf90234e71c", "filename": "libstdc++-v3/include/experimental/bits/net.h", "status": "modified", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b780db2ea327f51050d64237e71456b0eacf60e8/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Fnet.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b780db2ea327f51050d64237e71456b0eacf60e8/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Fnet.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Fnet.h?ref=b780db2ea327f51050d64237e71456b0eacf60e8", "patch": "@@ -38,6 +38,10 @@\n #include <system_error>\n #include <experimental/netfwd>\n \n+#if __cplusplus > 201703L\n+# include <concepts>\n+#endif\n+\n namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n@@ -164,6 +168,154 @@ inline namespace v1\n \t{ return _Derived::_S_name; }\n     };\n \n+namespace __detail\n+{\n+#if __cpp_lib_concepts\n+  template<typename _Tp>\n+    concept __protocol_like\n+      = copyable<_Tp> && requires { typename _Tp::endpoint; };\n+\n+  // Endpoint requirements for non-extensible implementations.\n+  template<typename _Tp>\n+    concept __endpoint_base = semiregular<_Tp>\n+      && requires  { typename _Tp::protocol_type; }\n+      && __protocol_like<typename _Tp::protocol_type>\n+      && requires(const _Tp __a) {\n+\t{ __a.protocol() } -> same_as<typename _Tp::protocol_type>;\n+      };\n+\n+  // Endpoint requirements for extensible implementations.\n+  template<typename _Tp>\n+    concept __endpoint = __endpoint_base<_Tp>\n+      && requires (const _Tp& __a, _Tp& __b, size_t __s)\n+      {\n+\t{ __a.data() } -> same_as<const void*>;\n+\t{ __b.data() } -> same_as<void*>;\n+\t{ __b.size() } -> same_as<size_t>;\n+\t__b.resize(__s);\n+\t{ __a.capacity() } -> same_as<size_t>;\n+      };\n+\n+  // Protocol requirements for non-extensible implementations.\n+  template<typename _Tp>\n+    concept __protocol_base = __protocol_like<_Tp>\n+      && __endpoint_base<typename _Tp::endpoint>\n+      && same_as<typename _Tp::endpoint::protocol_type, _Tp>;\n+\n+  // Protocol requirements for extensible implementations.\n+  template<typename _Tp>\n+    concept __protocol =  __protocol_base<_Tp>\n+      && __endpoint<typename _Tp::endpoint>\n+      && requires (const _Tp __a) {\n+\t{ __a.family() } -> same_as<int>;\n+\t{ __a.type() } -> same_as<int>;\n+\t{ __a.protocol() } -> same_as<int>;\n+      };\n+\n+  template<typename _Tp>\n+    concept __acceptable_protocol = __protocol<_Tp>\n+      && requires { typename _Tp::socket; }\n+      && move_constructible<typename _Tp::socket>\n+      && derived_from<typename _Tp::socket, basic_socket<_Tp>>;\n+\n+  template<typename _Tp>\n+    concept __inet_protocol = __acceptable_protocol<_Tp>\n+      && equality_comparable<_Tp> && requires {\n+\t{ _Tp::v4() } -> same_as<_Tp>;\n+\t{ _Tp::v6() } -> same_as<_Tp>;\n+\ttypename _Tp::resolver;\n+      }\n+      && same_as<typename _Tp::resolver, ip::basic_resolver<_Tp>>;\n+\n+#else\n+  // Check Endpoint requirements for extensible implementations\n+  template<typename _Tp, typename = void>\n+    struct __is_endpoint : false_type\n+    { };\n+\n+  template<typename _Tp>\n+    auto\n+    __endpoint_reqs(const _Tp* __a = nullptr, _Tp* __b = nullptr)\n+    -> enable_if_t<__and_<\n+      is_default_constructible<_Tp>, __is_value_constructible<_Tp>,\n+      is_same<decltype(__a->protocol()), typename _Tp::protocol_type>,\n+      is_same<decltype(__a->data()), const void*>,\n+      is_same<decltype(__b->data()), void*>,\n+      is_same<decltype(__a->size()), size_t>,\n+      is_same<decltype(__a->capacity()), size_t>\n+      >::value,\n+    __void_t< typename _Tp::protocol_type::endpoint,\n+\t      decltype(__b->resize(std::declval<size_t>())) >>;\n+\n+  template<typename _Tp>\n+    struct __is_endpoint<_Tp, decltype(__detail::__endpoint_reqs<_Tp>())>\n+    : true_type\n+    { };\n+\n+  // Check Protocol requirements for extensible implementations.\n+  template<typename _Tp, typename = void>\n+    struct __is_protocol\n+    : false_type { };\n+\n+  template<typename _Tp>\n+    auto\n+    __protocol_reqs(const _Tp* __a = nullptr)\n+    -> enable_if_t<__and_<\n+      is_copy_constructible<_Tp>, is_copy_assignable<_Tp>,\n+      __is_endpoint<typename _Tp::endpoint>,\n+      is_same<decltype(__a->family()), int>,\n+      is_same<decltype(__a->type()), int>,\n+      is_same<decltype(__a->protocol()), int>\n+      >::value>;\n+\n+  template<typename _Tp>\n+    struct __is_protocol<_Tp, decltype(__detail::__protocol_reqs<_Tp>())>\n+    : true_type\n+    { };\n+\n+  // Check AcceptableProtocol requirements\n+  template<typename _Tp, typename = void>\n+    struct __is_acceptable_protocol\n+    : false_type { };\n+\n+  template<typename _Tp>\n+    struct __is_acceptable_protocol<_Tp, __void_t<typename _Tp::socket>>\n+    : __and_<__is_protocol<_Tp>, is_move_constructible<typename _Tp::socket>,\n+\t     is_convertible<typename _Tp::socket*, basic_socket<_Tp>*>>::type\n+    { };\n+\n+  // Check InternetProtocol requirements\n+  template<typename _Tp, typename = void>\n+    struct __is_inet_protocol\n+    : false_type { };\n+\n+  template<typename _Tp>\n+    auto\n+    __inet_proto_reqs(const _Tp* __a = nullptr)\n+    -> enable_if_t<__and_<\n+      __is_acceptable_protocol<_Tp>,\n+      is_same<typename _Tp::resolver, ip::basic_resolver<_Tp>>,\n+      is_same<decltype(_Tp::v4()), _Tp>,\n+      is_same<decltype(_Tp::v6()), _Tp>,\n+      is_convertible<decltype(*__a == *__a), bool>,\n+      is_convertible<decltype(*__a != *__a), bool>\n+      >::value>;\n+\n+  template<typename _Tp>\n+    struct __is_inet_protocol<_Tp, decltype(__inet_proto_reqs<_Tp>())>\n+    : true_type { };\n+\n+  // Variable templates for requirements (with same names as concepts above).\n+\n+  template<typename _Tp>\n+    constexpr bool __endpoint = __is_endpoint<_Tp>::value;\n+  template<typename _Tp>\n+    constexpr bool __protocol = __is_protocol<_Tp>::value;\n+  template<typename _Tp>\n+    constexpr bool __acceptable_protocol = __is_acceptable_protocol<_Tp>::value;\n+#endif\n+} // namespace __detail\n+\n   /// @}\n \n } // namespace v1"}, {"sha": "84d23ebe37c16376a1d08daaaf2fdd417a728de4", "filename": "libstdc++-v3/include/experimental/socket", "status": "modified", "additions": 7, "deletions": 27, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b780db2ea327f51050d64237e71456b0eacf60e8/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fsocket", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b780db2ea327f51050d64237e71456b0eacf60e8/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fsocket", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fsocket?ref=b780db2ea327f51050d64237e71456b0eacf60e8", "patch": "@@ -122,33 +122,7 @@ inline namespace v1\n   make_error_condition(socket_errc __e) noexcept\n   { return error_condition(static_cast<int>(__e), socket_category()); }\n \n-  template<typename _Tp, typename = __void_t<>>\n-    struct __is_endpoint_impl : false_type\n-    { };\n-\n-  // Check Endpoint requirements.\n-  template<typename _Tp>\n-    auto\n-    __endpoint_reqs(const _Tp* __a = 0)\n-    -> enable_if_t<__and_<\n-      is_default_constructible<_Tp>,\n-      __is_value_constructible<_Tp>,\n-      is_same<decltype(__a->__protocol()), typename _Tp::protocol_type>\n-      >::value,\n-    __void_t< typename _Tp::protocol_type::endpoint >>;\n-\n-  template<typename _Tp>\n-    struct __is_endpoint_impl<_Tp, decltype(__endpoint_reqs<_Tp>())>\n-    : true_type\n-    { };\n-\n-  template<typename _Tp>\n-    struct __is_endpoint : __is_endpoint_impl<_Tp>\n-    { };\n-\n-  // TODO Endpoint reqs for extensible implementations\n-  // TODO _Protocol reqs\n-  // TODO AcceptableProtocol reqs\n+\n   // TODO GettableSocket reqs\n   // TODO SettableSocket reqs\n   // TODO BooleanSocketOption reqs\n@@ -713,6 +687,9 @@ inline namespace v1\n       using protocol_type = _Protocol;\n       using endpoint_type = typename protocol_type::endpoint;\n \n+      static_assert(__detail::__protocol<protocol_type>,\n+\t\t    \"protocol_type meets the Protocol requirements\");\n+\n       // basic_socket operations:\n \n       executor_type get_executor() noexcept { return __base::get_executor(); }\n@@ -1853,6 +1830,9 @@ inline namespace v1\n       using endpoint_type = typename protocol_type::endpoint;\n       using socket_type = typename protocol_type::socket;\n \n+      static_assert(__detail::__acceptable_protocol<protocol_type>,\n+\t\t    \"protocol_type meets the AcceptableProtocol requirements\");\n+\n       // construct / copy / destroy:\n \n       explicit"}]}