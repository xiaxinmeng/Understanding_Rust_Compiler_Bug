{"sha": "2b2c2fe51ac9b27af695b04d7058a6154fb5a644", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmIyYzJmZTUxYWM5YjI3YWY2OTViMDRkNzA1OGE2MTU0ZmI1YTY0NA==", "commit": {"author": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2007-05-16T08:30:10Z"}, "committer": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2007-05-16T08:30:10Z"}, "message": "rs6000.c (rs6000_emit_prologue): Move altivec register saving after stack push.\n\n2007-05-16  Eric Christopher  <echristo@apple.com>\n\n\t* config/rs6000/rs6000.c (rs6000_emit_prologue): Move altivec register\n        saving after stack push. Set sp_offset whenever we push.\n        (rs6000_emit_epilogue): Move altivec register restore before stack push.\n\nFrom-SVN: r124763", "tree": {"sha": "0e18b4d2af5da3b5159973069bbe0935e3e13347", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e18b4d2af5da3b5159973069bbe0935e3e13347"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b2c2fe51ac9b27af695b04d7058a6154fb5a644", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b2c2fe51ac9b27af695b04d7058a6154fb5a644", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b2c2fe51ac9b27af695b04d7058a6154fb5a644", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b2c2fe51ac9b27af695b04d7058a6154fb5a644/comments", "author": null, "committer": null, "parents": [{"sha": "748670c25bb0d41ecb89f110339a061ee8df2a1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/748670c25bb0d41ecb89f110339a061ee8df2a1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/748670c25bb0d41ecb89f110339a061ee8df2a1d"}], "stats": {"total": 247, "additions": 132, "deletions": 115}, "files": [{"sha": "dfa19ac6a6d9dce530c2d632193616bf3301e629", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b2c2fe51ac9b27af695b04d7058a6154fb5a644/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b2c2fe51ac9b27af695b04d7058a6154fb5a644/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2b2c2fe51ac9b27af695b04d7058a6154fb5a644", "patch": "@@ -1,3 +1,9 @@\n+2007-05-16  Eric Christopher  <echristo@apple.com>\n+\n+\t* config/rs6000/rs6000.c (rs6000_emit_prologue): Move altivec register\n+        saving after stack push. Set sp_offset whenever we push.\n+        (rs6000_emit_epilogue): Move altivec register restore before stack push.\n+\n 2007-05-16  Richard Sandiford  <richard@codesourcery.com>\n \n \t* configure.ac: Allow sysroots to be relocated under $prefix as\n@@ -274,7 +280,7 @@\n \t* tree-flow.h (strict_aliasing_warning_backend): Declare.\n \t* tree-ssa-alias-warnings.c: New file.\n \t* tree-ssa-alias.c (compute_may_aliases): Add call to\n-\tstrict_aliasing_warning_backend. \n+\tstrict_aliasing_warning_backend.\n \n 2007-05-11  Zdenek Dvorak  <dvorakz@suse.cz>\n \n@@ -383,9 +389,9 @@\n \temit_call_insn.\n \n 2007-05-09  Bob Wilson  <bob.wilson@acm.org>\n-\t\n+\n \t* config/xtensa/xtensa.c (xtensa_output_literal): Don't use #if.\n-\t\n+\n 2007-05-09  Bob Wilson  <bob.wilson@acm.org>\n \n \t* config/xtensa/xtensa.c (xtensa_output_literal): Mask out high bits\n@@ -468,7 +474,7 @@\n \tbfin_expand_epilogue accordingly.\n \t(sibcall_epilogue): Likewise.\n \t(eh_return_internal): Likewise.\n-\t\t\n+\n \t* config/bfin/bfin-protos.h (enum bfin_cpu): Add\n \tBFIN_CPU_BF534, BFIN_CPU_BF536 and BFIN_CPU_BF561.\n \t* config/bfin/bfin.c (bfin_handle_option): Handle\n@@ -482,7 +488,7 @@\n \tPR target/31854\n \t* config/i386/i386.c (ix86_function_regparm): Process local\n \tfunctions only when TREE_CODE (decl) equals FUNCTION_DECL.\n-\t\n+\n 2007-05-07  Mike Stump  <mrs@apple.com>\n \n \t* doc/invoke.texi (Warning Options): Document that -Wempty-body\n@@ -522,11 +528,11 @@\n \t(function_vector_handler): New\n \t(current_function_special_page_vector): New\n \t(m32c_special_page_vector_p): New.\n-\t* config/m32c/m32c-protos.h (m32c_special_page_vector_p): \n+\t* config/m32c/m32c-protos.h (m32c_special_page_vector_p):\n \tPrototype.\n-\t* config/m32c/jump.md: Added instruction JSRS for functions \n+\t* config/m32c/jump.md: Added instruction JSRS for functions\n \twith attribute \"function_vector\".\n-\t* doc/extend.texi (function_vector): Added description \n+\t* doc/extend.texi (function_vector): Added description\n \tfor M16C, M32C targets.\n \n 2007-05-07  DJ Delorie  <dj@redhat.com>\n@@ -575,11 +581,11 @@\n 2007-05-05  Aurelien Jarno  <aurelien@aurel32.net>\n \n \t* config/pa/pa.md: Split tgd_load, tld_load and tie_load\n-\tinto pic and non-pic versions. Mark r19 as used for \n-\ttgd_load_pic, tld_load_pic and tie_load_pic. Mark r27 as used \n+\tinto pic and non-pic versions. Mark r19 as used for\n+\ttgd_load_pic, tld_load_pic and tie_load_pic. Mark r27 as used\n \tfor tgd_load, tld_load and tie_load .\n \t* config/pa/pa.c (legitimize_tls_address): Emit pic or non-pic\n-\tversion of tgd_load, tld_load and tie_load depending on the \n+\tversion of tgd_load, tld_load and tie_load depending on the\n \tvalue of flag_pic.\n \n 2007-05-04  Ulrich Drepper  <drepper@redhat.com>\n@@ -651,10 +657,10 @@\n \t(\"fix_trunc<DSF:mode><GPR:mode>2\"): Expander added.\n \n 2007-05-04  Bob Wilson  <bob.wilson@acm.org>\n-\t\n+\n \t* config/xtensa/xtensa.md (adddi3, adddi_carry): Delete.\n \t(subdi3, subdi_carry): Delete.\n-\t\n+\n 2007-05-04  Jan Hubicka  <jh@suse.cz>\n \t    Richard Guenther  <rguenther@suse.de>\n \n@@ -712,7 +718,7 @@\n \twith changed signature and 'debug_rgn_dependencies ()'.\n \t(debug_rgn_dependencies): New static function.\n \t(init_ready_list): Use it.\n-\t\n+\n \t* sched-int.h (debug_dependencies): Declare.\n \n 2007-05-04  Andreas Krebbel  <krebbel1@de.ibm.com>\n@@ -788,8 +794,8 @@\n \tPR tree-optimization/31699\n \t* tree-vect-analyze.c (vect_update_misalignment_for_peel): Remove wrong\n \tcode.\n-\t(vect_enhance_data_refs_alignment): Compute peel amount using \n-\tTYPE_VECTOR_SUBPARTS instead of vf.\t\n+\t(vect_enhance_data_refs_alignment): Compute peel amount using\n+\tTYPE_VECTOR_SUBPARTS instead of vf.\n \t* tree-vect-transform.c (vect_gen_niters_for_prolog_loop): Likewise.\n \n 2007-05-02  Brooks Moses  <brooks.moses@codesourcery.com>"}, {"sha": "6447138773807d30891ccca80ce34db42271a9ad", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 110, "deletions": 99, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b2c2fe51ac9b27af695b04d7058a6154fb5a644/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b2c2fe51ac9b27af695b04d7058a6154fb5a644/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=2b2c2fe51ac9b27af695b04d7058a6154fb5a644", "patch": "@@ -14812,77 +14812,6 @@ rs6000_emit_prologue (void)\n       sp_offset = info->total_size;\n     }\n \n-  /* Save AltiVec registers if needed.  */\n-  if (!WORLD_SAVE_P (info) && TARGET_ALTIVEC_ABI && info->altivec_size != 0)\n-    {\n-      int i;\n-\n-      /* There should be a non inline version of this, for when we\n-\t are saving lots of vector registers.  */\n-      for (i = info->first_altivec_reg_save; i <= LAST_ALTIVEC_REGNO; ++i)\n-\tif (info->vrsave_mask & ALTIVEC_REG_BIT (i))\n-\t  {\n-\t    rtx areg, savereg, mem;\n-\t    int offset;\n-\n-\t    offset = info->altivec_save_offset + sp_offset\n-\t      + 16 * (i - info->first_altivec_reg_save);\n-\n-\t    savereg = gen_rtx_REG (V4SImode, i);\n-\n-\t    areg = gen_rtx_REG (Pmode, 0);\n-\t    emit_move_insn (areg, GEN_INT (offset));\n-\n-\t    /* AltiVec addressing mode is [reg+reg].  */\n-\t    mem = gen_frame_mem (V4SImode,\n-\t\t\t\t gen_rtx_PLUS (Pmode, frame_reg_rtx, areg));\n-\n-\t    insn = emit_move_insn (mem, savereg);\n-\n-\t    rs6000_frame_related (insn, frame_ptr_rtx, info->total_size,\n-\t\t\t\t  areg, GEN_INT (offset));\n-\t  }\n-    }\n-\n-  /* VRSAVE is a bit vector representing which AltiVec registers\n-     are used.  The OS uses this to determine which vector\n-     registers to save on a context switch.  We need to save\n-     VRSAVE on the stack frame, add whatever AltiVec registers we\n-     used in this function, and do the corresponding magic in the\n-     epilogue.  */\n-\n-  if (TARGET_ALTIVEC && TARGET_ALTIVEC_VRSAVE\n-      && info->vrsave_mask != 0)\n-    {\n-      rtx reg, mem, vrsave;\n-      int offset;\n-\n-      /* Get VRSAVE onto a GPR.  Note that ABI_V4 might be using r12\n-\t as frame_reg_rtx and r11 as the static chain pointer for\n-\t nested functions.  */\n-      reg = gen_rtx_REG (SImode, 0);\n-      vrsave = gen_rtx_REG (SImode, VRSAVE_REGNO);\n-      if (TARGET_MACHO)\n-\temit_insn (gen_get_vrsave_internal (reg));\n-      else\n-\temit_insn (gen_rtx_SET (VOIDmode, reg, vrsave));\n-\n-      if (!WORLD_SAVE_P (info))\n-\t{\n-          /* Save VRSAVE.  */\n-          offset = info->vrsave_save_offset + sp_offset;\n-          mem = gen_frame_mem (SImode,\n-\t\t\t       gen_rtx_PLUS (Pmode, frame_reg_rtx,\n-\t\t\t\t\t     GEN_INT (offset)));\n-          insn = emit_move_insn (mem, reg);\n-\t}\n-\n-      /* Include the registers in the mask.  */\n-      emit_insn (gen_iorsi3 (reg, reg, GEN_INT ((int) info->vrsave_mask)));\n-\n-      insn = emit_insn (generate_set_vrsave (reg, info, 0));\n-    }\n-\n   /* If we use the link register, get it into r0.  */\n   if (!WORLD_SAVE_P (info) && info->lr_save_p)\n     {\n@@ -15120,7 +15049,10 @@ rs6000_emit_prologue (void)\n      for which it was done previously.  */\n   if (!WORLD_SAVE_P (info) && info->push_p\n       && !(DEFAULT_ABI == ABI_V4 || current_function_calls_eh_return))\n-    rs6000_emit_allocate_stack (info->total_size, FALSE);\n+    {\n+      rs6000_emit_allocate_stack (info->total_size, FALSE);\n+      sp_offset = info->total_size;\n+    }\n \n   /* Set frame pointer, if needed.  */\n   if (frame_pointer_needed)\n@@ -15130,6 +15062,78 @@ rs6000_emit_prologue (void)\n       RTX_FRAME_RELATED_P (insn) = 1;\n     }\n \n+  /* Save AltiVec registers if needed.  Save here because the red zone does\n+     not include AltiVec registers.  */\n+  if (!WORLD_SAVE_P (info) && TARGET_ALTIVEC_ABI && info->altivec_size != 0)\n+    {\n+      int i;\n+\n+      /* There should be a non inline version of this, for when we\n+         are saving lots of vector registers.  */\n+      for (i = info->first_altivec_reg_save; i <= LAST_ALTIVEC_REGNO; ++i)\n+        if (info->vrsave_mask & ALTIVEC_REG_BIT (i))\n+          {\n+            rtx areg, savereg, mem;\n+            int offset;\n+\n+            offset = info->altivec_save_offset + sp_offset\n+              + 16 * (i - info->first_altivec_reg_save);\n+\n+            savereg = gen_rtx_REG (V4SImode, i);\n+\n+            areg = gen_rtx_REG (Pmode, 0);\n+            emit_move_insn (areg, GEN_INT (offset));\n+\n+            /* AltiVec addressing mode is [reg+reg].  */\n+            mem = gen_frame_mem (V4SImode,\n+                                 gen_rtx_PLUS (Pmode, frame_reg_rtx, areg));\n+\n+            insn = emit_move_insn (mem, savereg);\n+\n+            rs6000_frame_related (insn, frame_ptr_rtx, info->total_size,\n+                                  areg, GEN_INT (offset));\n+          }\n+    }\n+\n+  /* VRSAVE is a bit vector representing which AltiVec registers\n+     are used.  The OS uses this to determine which vector\n+     registers to save on a context switch.  We need to save\n+     VRSAVE on the stack frame, add whatever AltiVec registers we\n+     used in this function, and do the corresponding magic in the\n+     epilogue.  */\n+\n+  if (TARGET_ALTIVEC && TARGET_ALTIVEC_VRSAVE\n+      && info->vrsave_mask != 0)\n+    {\n+      rtx reg, mem, vrsave;\n+      int offset;\n+\n+      /* Get VRSAVE onto a GPR.  Note that ABI_V4 might be using r12\n+         as frame_reg_rtx and r11 as the static chain pointer for\n+         nested functions.  */\n+      reg = gen_rtx_REG (SImode, 0);\n+      vrsave = gen_rtx_REG (SImode, VRSAVE_REGNO);\n+      if (TARGET_MACHO)\n+        emit_insn (gen_get_vrsave_internal (reg));\n+      else\n+        emit_insn (gen_rtx_SET (VOIDmode, reg, vrsave));\n+\n+      if (!WORLD_SAVE_P (info))\n+        {\n+          /* Save VRSAVE.  */\n+          offset = info->vrsave_save_offset + sp_offset;\n+          mem = gen_frame_mem (SImode,\n+                               gen_rtx_PLUS (Pmode, frame_reg_rtx,\n+                                             GEN_INT (offset)));\n+          insn = emit_move_insn (mem, reg);\n+        }\n+\n+      /* Include the registers in the mask.  */\n+      emit_insn (gen_iorsi3 (reg, reg, GEN_INT ((int) info->vrsave_mask)));\n+\n+      insn = emit_insn (generate_set_vrsave (reg, info, 0));\n+    }\n+\n   /* If we are using RS6000_PIC_OFFSET_TABLE_REGNUM, we need to set it up.  */\n   if ((TARGET_TOC && TARGET_MINIMAL_TOC && get_pool_size () != 0)\n       || (DEFAULT_ABI == ABI_V4\n@@ -15387,33 +15391,10 @@ rs6000_emit_epilogue (int sibcall)\n       return;\n     }\n \n-  /* If we have a frame pointer, a call to alloca,  or a large stack\n-     frame, restore the old stack pointer using the backchain.  Otherwise,\n-     we know what size to update it with.  */\n-  if (use_backchain_to_restore_sp)\n-    {\n-      /* Under V.4, don't reset the stack pointer until after we're done\n-\t loading the saved registers.  */\n-      if (DEFAULT_ABI == ABI_V4)\n-\tframe_reg_rtx = gen_rtx_REG (Pmode, 11);\n-\n-      emit_move_insn (frame_reg_rtx,\n-\t\t      gen_rtx_MEM (Pmode, sp_reg_rtx));\n-    }\n-  else if (info->push_p)\n-    {\n-      if (DEFAULT_ABI == ABI_V4\n-\t  || current_function_calls_eh_return)\n-\tsp_offset = info->total_size;\n-      else\n-\t{\n-\t  emit_insn (TARGET_32BIT\n-\t\t     ? gen_addsi3 (sp_reg_rtx, sp_reg_rtx,\n-\t\t\t\t   GEN_INT (info->total_size))\n-\t\t     : gen_adddi3 (sp_reg_rtx, sp_reg_rtx,\n-\t\t\t\t   GEN_INT (info->total_size)));\n-\t}\n-    }\n+  /* Set sp_offset based on the stack push from the prologue.  */\n+  if ((DEFAULT_ABI == ABI_V4 || current_function_calls_eh_return)\n+      && info->total_size < 32767)\n+    sp_offset = info->total_size;\n \n   /* Restore AltiVec registers if needed.  */\n   if (TARGET_ALTIVEC_ABI && info->altivec_size != 0)\n@@ -15454,6 +15435,36 @@ rs6000_emit_epilogue (int sibcall)\n       emit_insn (generate_set_vrsave (reg, info, 1));\n     }\n \n+  sp_offset = 0;\n+\n+  /* If we have a frame pointer, a call to alloca,  or a large stack\n+     frame, restore the old stack pointer using the backchain.  Otherwise,\n+     we know what size to update it with.  */\n+  if (use_backchain_to_restore_sp)\n+    {\n+      /* Under V.4, don't reset the stack pointer until after we're done\n+\t loading the saved registers.  */\n+      if (DEFAULT_ABI == ABI_V4)\n+\tframe_reg_rtx = gen_rtx_REG (Pmode, 11);\n+\n+      emit_move_insn (frame_reg_rtx,\n+\t\t      gen_rtx_MEM (Pmode, sp_reg_rtx));\n+    }\n+  else if (info->push_p)\n+    {\n+      if (DEFAULT_ABI == ABI_V4\n+\t  || current_function_calls_eh_return)\n+\tsp_offset = info->total_size;\n+      else\n+\t{\n+\t  emit_insn (TARGET_32BIT\n+\t\t     ? gen_addsi3 (sp_reg_rtx, sp_reg_rtx,\n+\t\t\t\t   GEN_INT (info->total_size))\n+\t\t     : gen_adddi3 (sp_reg_rtx, sp_reg_rtx,\n+\t\t\t\t   GEN_INT (info->total_size)));\n+\t}\n+    }\n+\n   /* Get the old lr if we saved it.  */\n   if (info->lr_save_p)\n     {"}]}