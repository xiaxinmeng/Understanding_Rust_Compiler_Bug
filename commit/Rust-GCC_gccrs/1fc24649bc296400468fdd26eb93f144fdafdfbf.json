{"sha": "1fc24649bc296400468fdd26eb93f144fdafdfbf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWZjMjQ2NDliYzI5NjQwMDQ2OGZkZDI2ZWI5M2YxNDRmZGFmZGZiZg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-04-15T20:21:08Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-04-15T20:21:08Z"}, "message": "trans.c (gigi): Set DECL_IGNORED_P on EH functions.\n\n\t* gcc-interface/trans.c (gigi): Set DECL_IGNORED_P on EH functions.\n\t(gnat_to_gnu) <N_Op_Eq>: Restore the value of input_location\n\tbefore translating the top-level node.\n\t(lvalue_required_p) <N_Function_Call>: Return 1 if !constant.\n\t<N_Object_Declaration>: Likewise.\n\t<N_Assignment_Statement>: Likewise.\n\t<N_Unchecked_Type_Conversion>: Likewise.\n\t(call_to_gnu): Remove kludge.\n\t(gnat_to_gnu) <N_Return_Statement>: When not optimizing, force labels\n\tassociated with user returns to be preserved.\n\t(gnat_to_gnu): Add special code to deal with boolean rvalues.\n\t* gcc-interface/utils2.c (compare_arrays): Set input_location on all\n\tcomparisons.\n\t(build_unary_op) <ADDR_EXPR>: Call build_fold_addr_expr.\n\t<INDIRECT_REF>: Call build_fold_indirect_ref.\n\nFrom-SVN: r158388", "tree": {"sha": "df70b088f847795d72172c58ec00218b5b4a4460", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df70b088f847795d72172c58ec00218b5b4a4460"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1fc24649bc296400468fdd26eb93f144fdafdfbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fc24649bc296400468fdd26eb93f144fdafdfbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fc24649bc296400468fdd26eb93f144fdafdfbf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fc24649bc296400468fdd26eb93f144fdafdfbf/comments", "author": null, "committer": null, "parents": [{"sha": "bafaef55aaaf4f6431b2998cd0cd469c664a0211", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bafaef55aaaf4f6431b2998cd0cd469c664a0211", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bafaef55aaaf4f6431b2998cd0cd469c664a0211"}], "stats": {"total": 129, "additions": 96, "deletions": 33}, "files": [{"sha": "aaec1a4651dd7a204e33a884017e5cd36438e850", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fc24649bc296400468fdd26eb93f144fdafdfbf/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fc24649bc296400468fdd26eb93f144fdafdfbf/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=1fc24649bc296400468fdd26eb93f144fdafdfbf", "patch": "@@ -1,4 +1,22 @@\n-2010-04-15  Joel Sherrill <joel.sherrill@oarcorp.com>\n+2010-04-15  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/trans.c (gigi): Set DECL_IGNORED_P on EH functions.\n+\t(gnat_to_gnu) <N_Op_Eq>: Restore the value of input_location\n+\tbefore translating the top-level node.\n+\t(lvalue_required_p) <N_Function_Call>: Return 1 if !constant.\n+\t<N_Object_Declaration>: Likewise.\n+\t<N_Assignment_Statement>: Likewise.\n+\t<N_Unchecked_Type_Conversion>: Likewise.\n+\t(call_to_gnu): Remove kludge.\n+\t(gnat_to_gnu) <N_Return_Statement>: When not optimizing, force labels\n+\tassociated with user returns to be preserved.\n+\t(gnat_to_gnu): Add special code to deal with boolean rvalues.\n+\t* gcc-interface/utils2.c (compare_arrays): Set input_location on all\n+\tcomparisons.\n+\t(build_unary_op) <ADDR_EXPR>: Call build_fold_addr_expr.\n+\t<INDIRECT_REF>: Call build_fold_indirect_ref.\n+\n+2010-04-15  Joel Sherrill  <joel.sherrill@oarcorp.com>\n \n \t* g-socket.adb: A target can have multiple missing errno's.  This\n \twill result in multiple errno's being defined as -1.  Because of this\n@@ -74,7 +92,7 @@\n \tunless necessary.  Reuse the tree for an associated class-wide type\n \tonly if processing its root type.\n \n-2010-04-13  Joel Sherrill <joel.sherrill@oarcorp.com>\n+2010-04-13  Joel Sherrill  <joel.sherrill@oarcorp.com>\n \n \t* gsocket.h: Run-time can no longer be built without network\n \tOS headers available.  Changing RTEMS GNAT build procedure to"}, {"sha": "3d802c4340779617afb0104df1e741e619dc96db", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 44, "deletions": 16, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fc24649bc296400468fdd26eb93f144fdafdfbf/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fc24649bc296400468fdd26eb93f144fdafdfbf/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=1fc24649bc296400468fdd26eb93f144fdafdfbf", "patch": "@@ -413,6 +413,7 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n      NULL_TREE, false, true, true, NULL, Empty);\n   /* Avoid creating superfluous edges to __builtin_setjmp receivers.  */\n   DECL_PURE_P (get_jmpbuf_decl) = 1;\n+  DECL_IGNORED_P (get_jmpbuf_decl) = 1;\n \n   set_jmpbuf_decl\n     = create_subprog_decl\n@@ -421,6 +422,7 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n      build_function_type (void_type_node,\n \t\t\t  tree_cons (NULL_TREE, jmpbuf_ptr_type, t)),\n      NULL_TREE, false, true, true, NULL, Empty);\n+  DECL_IGNORED_P (set_jmpbuf_decl) = 1;\n \n   /* setjmp returns an integer and has one operand, which is a pointer to\n      a jmpbuf.  */\n@@ -430,7 +432,6 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n        build_function_type (integer_type_node,\n \t\t\t    tree_cons (NULL_TREE,  jmpbuf_ptr_type, t)),\n        NULL_TREE, false, true, true, NULL, Empty);\n-\n   DECL_BUILT_IN_CLASS (setjmp_decl) = BUILT_IN_NORMAL;\n   DECL_FUNCTION_CODE (setjmp_decl) = BUILT_IN_SETJMP;\n \n@@ -442,7 +443,6 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n        build_function_type (void_type_node,\n \t\t\t    tree_cons (NULL_TREE,  jmpbuf_ptr_type, t)),\n        NULL_TREE, false, true, true, NULL, Empty);\n-\n   DECL_BUILT_IN_CLASS (update_setjmp_buf_decl) = BUILT_IN_NORMAL;\n   DECL_FUNCTION_CODE (update_setjmp_buf_decl) = BUILT_IN_UPDATE_SETJMP_BUF;\n \n@@ -454,6 +454,7 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n \t\t\t\t\t\t\t   ptr_void_type_node,\n \t\t\t\t\t\t\t   t)),\n \t\t\t   NULL_TREE, false, true, true, NULL, Empty);\n+  DECL_IGNORED_P (begin_handler_decl) = 1;\n \n   end_handler_decl\n     = create_subprog_decl (get_identifier (\"__gnat_end_handler\"), NULL_TREE,\n@@ -462,6 +463,7 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n \t\t\t\t\t\t\t   ptr_void_type_node,\n \t\t\t\t\t\t\t   t)),\n \t\t\t   NULL_TREE, false, true, true, NULL, Empty);\n+  DECL_IGNORED_P (end_handler_decl) = 1;\n \n   /* If in no exception handlers mode, all raise statements are redirected to\n      __gnat_last_chance_handler.  No need to redefine raise_nodefer_decl since\n@@ -730,7 +732,10 @@ lvalue_required_p (Node_Id gnat_node, tree gnu_type, bool constant,\n     case N_Parameter_Association:\n     case N_Function_Call:\n     case N_Procedure_Call_Statement:\n-      return (must_pass_by_ref (gnu_type) || default_pass_by_ref (gnu_type));\n+      /* If the parameter is by reference, an lvalue is required.  */\n+      return (!constant\n+\t      || must_pass_by_ref (gnu_type)\n+\t      || default_pass_by_ref (gnu_type));\n \n     case N_Indexed_Component:\n       /* Only the array expression can require an lvalue.  */\n@@ -779,8 +784,9 @@ lvalue_required_p (Node_Id gnat_node, tree gnu_type, bool constant,\n     case N_Object_Declaration:\n       /* We cannot use a constructor if this is an atomic object because\n \t the actual assignment might end up being done component-wise.  */\n-      return ((Is_Composite_Type (Underlying_Type (Etype (gnat_node)))\n-\t       && Is_Atomic (Defining_Entity (gnat_parent)))\n+      return (!constant\n+\t      ||(Is_Composite_Type (Underlying_Type (Etype (gnat_node)))\n+\t\t && Is_Atomic (Defining_Entity (gnat_parent)))\n \t      /* We don't use a constructor if this is a class-wide object\n \t\t because the effective type of the object is the equivalent\n \t\t type of the class-wide subtype and it smashes most of the\n@@ -791,7 +797,8 @@ lvalue_required_p (Node_Id gnat_node, tree gnu_type, bool constant,\n     case N_Assignment_Statement:\n       /* We cannot use a constructor if the LHS is an atomic object because\n \t the actual assignment might end up being done component-wise.  */\n-      return (Name (gnat_parent) == gnat_node\n+      return (!constant\n+\t      || Name (gnat_parent) == gnat_node\n \t      || (Is_Composite_Type (Underlying_Type (Etype (gnat_node)))\n \t\t  && Is_Atomic (Entity (Name (gnat_parent)))));\n \n@@ -808,9 +815,10 @@ lvalue_required_p (Node_Id gnat_node, tree gnu_type, bool constant,\n       /* ... fall through ... */\n \n     case N_Unchecked_Type_Conversion:\n-      return lvalue_required_p (gnat_parent,\n-\t\t\t\tget_unpadded_type (Etype (gnat_parent)),\n-\t\t\t\tconstant, address_of_constant, aliased);\n+      return (!constant\n+\t      || lvalue_required_p (gnat_parent,\n+\t\t\t\t    get_unpadded_type (Etype (gnat_parent)),\n+\t\t\t\t    constant, address_of_constant, aliased));\n \n     case N_Allocator:\n       /* We should only reach here through the N_Qualified_Expression case\n@@ -3000,12 +3008,6 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t\t  gnu_result = convert (TREE_TYPE (gnu_actual), gnu_result);\n \t      }\n \n-\t    /* Undo wrapping of boolean rvalues.  */\n-\t    if (TREE_CODE (gnu_actual) == NE_EXPR\n-\t\t&& TREE_CODE (get_base_type (TREE_TYPE (gnu_actual)))\n-\t\t   == BOOLEAN_TYPE\n-\t\t&& integer_zerop (TREE_OPERAND (gnu_actual, 1)))\n-\t      gnu_actual = TREE_OPERAND (gnu_actual, 0);\n \t    gnu_result = build_binary_op (MODIFY_EXPR, NULL_TREE,\n \t\t\t\t\t  gnu_actual, gnu_result);\n \t    set_expr_location_from_node (gnu_result, gnat_node);\n@@ -4351,6 +4353,7 @@ gnat_to_gnu (Node_Id gnat_node)\n       {\n \tenum tree_code code = gnu_codes[kind];\n \tbool ignore_lhs_overflow = false;\n+\tlocation_t saved_location = input_location;\n \ttree gnu_type;\n \n \tgnu_lhs = gnat_to_gnu (Left_Opnd (gnat_node));\n@@ -4442,7 +4445,12 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  gnu_result = build_binary_op_trapv (code, gnu_type,\n \t\t\t\t\t      gnu_lhs, gnu_rhs, gnat_node);\n \telse\n-\t  gnu_result = build_binary_op (code, gnu_type, gnu_lhs, gnu_rhs);\n+\t  {\n+\t    /* Some operations, e.g. comparisons of arrays, generate complex\n+\t       trees that need to be annotated while they are being built.  */\n+\t    input_location = saved_location;\n+\t    gnu_result = build_binary_op (code, gnu_type, gnu_lhs, gnu_rhs);\n+\t  }\n \n \t/* If this is a logical shift with the shift count not verified,\n \t   we must return zero if it is too large.  We cannot compensate\n@@ -4723,6 +4731,9 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  {\n \t    gnu_result = build1 (GOTO_EXPR, void_type_node,\n \t\t\t\t TREE_VALUE (gnu_return_label_stack));\n+\t    /* When not optimizing, make sure the return is preserved.  */\n+\t    if (!optimize && Comes_From_Source (gnat_node))\n+\t      DECL_ARTIFICIAL (TREE_VALUE (gnu_return_label_stack)) = 0;\n \t    break;\n \t  }\n \n@@ -5360,6 +5371,23 @@ gnat_to_gnu (Node_Id gnat_node)\n   if (went_into_elab_proc)\n     current_function_decl = NULL_TREE;\n \n+  /* When not optimizing, turn boolean rvalues B into B != false tests\n+     so that the code just below can put the location information of the\n+     reference to B on the inequality operator for better debug info.  */\n+  if (!optimize\n+      && (kind == N_Identifier\n+\t  || kind == N_Expanded_Name\n+\t  || kind == N_Explicit_Dereference\n+\t  || kind == N_Function_Call\n+\t  || kind == N_Indexed_Component\n+\t  || kind == N_Selected_Component)\n+      && TREE_CODE (get_base_type (gnu_result_type)) == BOOLEAN_TYPE\n+      && !lvalue_required_p (gnat_node, gnu_result_type, false, false, false))\n+    gnu_result = build_binary_op (NE_EXPR, gnu_result_type,\n+\t\t\t\t  convert (gnu_result_type, gnu_result),\n+\t\t\t\t  convert (gnu_result_type,\n+\t\t\t\t\t   boolean_false_node));\n+\n   /* Set the location information on the result if it is a real expression.\n      References can be reused for multiple GNAT nodes and they would get\n      the location information of their last use.  Note that we may have"}, {"sha": "3a5b96205865dc7f6f6e98eb4ea33d02ff8610d7", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 32, "deletions": 15, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fc24649bc296400468fdd26eb93f144fdafdfbf/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fc24649bc296400468fdd26eb93f144fdafdfbf/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=1fc24649bc296400468fdd26eb93f144fdafdfbf", "patch": "@@ -303,6 +303,9 @@ compare_arrays (tree result_type, tree a1, tree a2)\n \n \t  comparison = build_binary_op (LT_EXPR, result_type, ub, lb);\n \t  comparison = SUBSTITUTE_PLACEHOLDER_IN_EXPR (comparison, a1);\n+\t  if (EXPR_P (comparison))\n+\t    SET_EXPR_LOCATION (comparison, input_location);\n+\n \t  length1 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (length1, a1);\n \n \t  length_zero_p = true;\n@@ -317,6 +320,8 @@ compare_arrays (tree result_type, tree a1, tree a2)\n \t{\n \t  ub1 = TYPE_MAX_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t1)));\n \t  lb1 = TYPE_MIN_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t1)));\n+\t  /* Note that we know that UB2 and LB2 are constant and hence\n+\t     cannot contain a PLACEHOLDER_EXPR.  */\n \t  ub2 = TYPE_MAX_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t2)));\n \t  lb2 = TYPE_MIN_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t2)));\n \t  nbt = get_base_type (TREE_TYPE (ub1));\n@@ -325,14 +330,15 @@ compare_arrays (tree result_type, tree a1, tree a2)\n \t    = build_binary_op (EQ_EXPR, result_type,\n \t\t\t       build_binary_op (MINUS_EXPR, nbt, ub1, lb1),\n \t\t\t       build_binary_op (MINUS_EXPR, nbt, ub2, lb2));\n-\n-\t  /* Note that we know that UB2 and LB2 are constant and hence\n-\t     cannot contain a PLACEHOLDER_EXPR.  */\n-\n \t  comparison = SUBSTITUTE_PLACEHOLDER_IN_EXPR (comparison, a1);\n+\t  if (EXPR_P (comparison))\n+\t    SET_EXPR_LOCATION (comparison, input_location);\n+\n \t  length1 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (length1, a1);\n \n \t  this_a1_is_null = build_binary_op (LT_EXPR, result_type, ub1, lb1);\n+\t  if (EXPR_P (this_a1_is_null))\n+\t    SET_EXPR_LOCATION (this_a1_is_null, input_location);\n \t  this_a2_is_null = convert (result_type, integer_zero_node);\n \t}\n \n@@ -344,13 +350,20 @@ compare_arrays (tree result_type, tree a1, tree a2)\n \n \t  comparison\n \t    = build_binary_op (EQ_EXPR, result_type, length1, length2);\n+\t  if (EXPR_P (comparison))\n+\t    SET_EXPR_LOCATION (comparison, input_location);\n \n \t  this_a1_is_null\n \t    = build_binary_op (LT_EXPR, result_type, length1,\n \t\t\t       convert (bt, integer_zero_node));\n+\t  if (EXPR_P (this_a1_is_null))\n+\t    SET_EXPR_LOCATION (this_a1_is_null, input_location);\n+\n \t  this_a2_is_null\n \t    = build_binary_op (LT_EXPR, result_type, length2,\n \t\t\t       convert (bt, integer_zero_node));\n+\t  if (EXPR_P (this_a2_is_null))\n+\t    SET_EXPR_LOCATION (this_a2_is_null, input_location);\n \t}\n \n       result = build_binary_op (TRUTH_ANDIF_EXPR, result_type,\n@@ -370,15 +383,20 @@ compare_arrays (tree result_type, tree a1, tree a2)\n   if (!length_zero_p)\n     {\n       tree type = find_common_type (TREE_TYPE (a1), TREE_TYPE (a2));\n+      tree comparison;\n \n       if (type)\n \t{\n \t  a1 = convert (type, a1),\n \t  a2 = convert (type, a2);\n \t}\n \n-      result = build_binary_op (TRUTH_ANDIF_EXPR, result_type, result,\n-\t\t\t\tfold_build2 (EQ_EXPR, result_type, a1, a2));\n+      comparison = fold_build2 (EQ_EXPR, result_type, a1, a2);\n+      if (EXPR_P (comparison))\n+\tSET_EXPR_LOCATION (comparison, input_location);\n+\n+      result\n+\t= build_binary_op (TRUTH_ANDIF_EXPR, result_type, result, comparison);\n     }\n \n   /* The result is also true if both sizes are zero.  */\n@@ -1153,21 +1171,17 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \t      operand = convert (type, operand);\n \t    }\n \n-\t  if (type != error_mark_node)\n-\t    operation_type = build_pointer_type (type);\n-\n \t  gnat_mark_addressable (operand);\n-\t  result = fold_build1 (ADDR_EXPR, operation_type, operand);\n+\t  result = build_fold_addr_expr (operand);\n \t}\n \n       TREE_CONSTANT (result) = staticp (operand) || TREE_CONSTANT (operand);\n       break;\n \n     case INDIRECT_REF:\n-      /* If we want to refer to an entire unconstrained array,\n-\t make up an expression to do so.  This will never survive to\n-\t the backend.  If TYPE is a thin pointer, first convert the\n-\t operand to a fat pointer.  */\n+      /* If we want to refer to an unconstrained array, use the appropriate\n+\t expression to do so.  This will never survive down to the back-end.\n+\t But if TYPE is a thin pointer, first convert to a fat pointer.  */\n       if (TYPE_IS_THIN_POINTER_P (type)\n \t  && TYPE_UNCONSTRAINED_ARRAY (TREE_TYPE (type)))\n \t{\n@@ -1184,12 +1198,15 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \t  TREE_READONLY (result)\n \t    = TYPE_READONLY (TYPE_UNCONSTRAINED_ARRAY (type));\n \t}\n+\n+      /* If we are dereferencing an ADDR_EXPR, return its operand.  */\n       else if (TREE_CODE (operand) == ADDR_EXPR)\n \tresult = TREE_OPERAND (operand, 0);\n \n+      /* Otherwise, build and fold the indirect reference.  */\n       else\n \t{\n-\t  result = fold_build1 (op_code, TREE_TYPE (type), operand);\n+\t  result = build_fold_indirect_ref (operand);\n \t  TREE_READONLY (result) = TYPE_READONLY (TREE_TYPE (type));\n \t}\n "}]}