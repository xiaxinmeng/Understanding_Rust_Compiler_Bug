{"sha": "3bec79c52e613995dd3b07b119a67cd7ad3d72a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2JlYzc5YzUyZTYxMzk5NWRkM2IwN2IxMTlhNjdjZDdhZDNkNzJhOA==", "commit": {"author": {"name": "Dave Korn", "email": "dave.korn.cygwin@gmail.com", "date": "2010-04-27T02:22:40Z"}, "committer": {"name": "Dave Korn", "email": "davek@gcc.gnu.org", "date": "2010-04-27T02:22:40Z"}, "message": "re PR lto/42776 (LTO doesn't work on non-ELF platforms.)\n\nChangeLog:\n\n\tPR lto/42776\n\t* configure.ac (--enable-lto): Refactor handling so libelf tests\n\tare only performed inside then-clause of ACX_ELF_TARGET_IFELSE,\n\tand allow LTO to be explicitly enabled on non-ELF platforms that\n\tare known to support it inside else-clause.\n\t* configure: Regenerate.\n\ngcc/ChangeLog:\n\n\tPR lto/42776\n\t* configure.ac (gcc_cv_as_section_has_align): Set if installed\n\tbinutils supports extended .section directive needed by LTO, or\n\twarn if older binutils found.\n\t(LTO_BINARY_READER): New AC_SUBST'd variable.\n\t(LTO_USE_LIBELF): Likewise.\n\t* gcc/config.gcc (lto_binary_reader): New target-specific configure\n\tvariable.\n\t* gcc/Makefile.in (LTO_BINARY_READER): Import AC_SUBST'd autoconf var.\n\t(LTO_USE_LIBELF): Likewise.\n\t* configure: Regenerate.\n\n\t* collect2.c (is_elf): Rename from this ...\n\t(is_elf_or_coff): ... to this, and recognize and allow i386 COFF\n\t object files in addition to ELF-formatted ones.\n\t(scan_prog_file): Caller updated.  Also allow for LTO info marker\n\tsymbol to be prefixed or not by an extra underscore.\n\n\t* config/i386/t-cygming (winnt.o): Also depend on LTO_STREAMER_H.\n\t* config/i386/winnt.c: Also #include lto-streamer.h\n\t(i386_pe_asm_named_section): Specify 1-byte section alignment for\n\tLTO named sections.\n\t(i386_pe_asm_output_aligned_decl_common): Add comment.\n\t(i386_pe_maybe_record_exported_symbol): Allow decl arg to be NULL.\n\ngcc/lto/ChangeLog:\n\n\tPR lto/42776\n\t* Make-lang.in (LTO_OBJS): Use LTO_BINARY_READER instead of\n\thardcoding 'lto-elf.o'.\n\t($(LTO_EXE)): Use LTO_USE_LIBELF instead of hardcoding '-lelf'.\n\n\t* lto-coff.h: New file.\n\t* lto-coff.c: Likewise.\n\ngcc/testsuite/ChangeLog:\n\n\tPR lto/42776\n\t* lib/lto.exp (lto_prune_vis_warns): New function.\n\t(lto-link-and-maybe-run): Call it.\n\nFrom-SVN: r158762", "tree": {"sha": "f1cd7b961ac18dc1a7983cdd108f5b91bbc0cb46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f1cd7b961ac18dc1a7983cdd108f5b91bbc0cb46"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3bec79c52e613995dd3b07b119a67cd7ad3d72a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bec79c52e613995dd3b07b119a67cd7ad3d72a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3bec79c52e613995dd3b07b119a67cd7ad3d72a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bec79c52e613995dd3b07b119a67cd7ad3d72a8/comments", "author": {"login": "davek-cygwin", "id": 530057, "node_id": "MDQ6VXNlcjUzMDA1Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/530057?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davek-cygwin", "html_url": "https://github.com/davek-cygwin", "followers_url": "https://api.github.com/users/davek-cygwin/followers", "following_url": "https://api.github.com/users/davek-cygwin/following{/other_user}", "gists_url": "https://api.github.com/users/davek-cygwin/gists{/gist_id}", "starred_url": "https://api.github.com/users/davek-cygwin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davek-cygwin/subscriptions", "organizations_url": "https://api.github.com/users/davek-cygwin/orgs", "repos_url": "https://api.github.com/users/davek-cygwin/repos", "events_url": "https://api.github.com/users/davek-cygwin/events{/privacy}", "received_events_url": "https://api.github.com/users/davek-cygwin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "45c384e375c0a05accdd60deaf54d0727dab9feb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45c384e375c0a05accdd60deaf54d0727dab9feb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45c384e375c0a05accdd60deaf54d0727dab9feb"}], "stats": {"total": 1456, "additions": 1431, "deletions": 25}, "files": [{"sha": "6105c41ffe8a2c6453d1afac7257d1614ffa9e61", "filename": "ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bec79c52e613995dd3b07b119a67cd7ad3d72a8/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bec79c52e613995dd3b07b119a67cd7ad3d72a8/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=3bec79c52e613995dd3b07b119a67cd7ad3d72a8", "patch": "@@ -1,3 +1,12 @@\n+2010-04-27  Dave Korn  <dave.korn.cygwin@gmail.com>\n+\n+\tPR lto/42776\n+\t* configure.ac (--enable-lto): Refactor handling so libelf tests\n+\tare only performed inside then-clause of ACX_ELF_TARGET_IFELSE,\n+\tand allow LTO to be explicitly enabled on non-ELF platforms that\n+\tare known to support it inside else-clause.\n+\t* configure: Regenerate.\n+\n 2010-04-20  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* configure.ac (BUILD_CONFIG): Redirect output to /dev/null."}, {"sha": "1ae21407cb8f68f5e2597ddb1c3feef3061b649c", "filename": "configure.ac", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bec79c52e613995dd3b07b119a67cd7ad3d72a8/configure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bec79c52e613995dd3b07b119a67cd7ad3d72a8/configure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure.ac?ref=3bec79c52e613995dd3b07b119a67cd7ad3d72a8", "patch": "@@ -1637,17 +1637,8 @@ AC_ARG_ENABLE(lto,\n enable_lto=$enableval,\n enable_lto=yes; default_enable_lto=yes)\n \n-ACX_ELF_TARGET_IFELSE([],\n-if test x\"$default_enable_lto\" = x\"yes\" ; then\n-  enable_lto=no\n-else\n-  if test x\"$enable_lto\" = x\"yes\"; then\n-    AC_MSG_ERROR([LTO support requires an ELF target.])\n-  fi\n-fi\n-default_enable_lto=no)\n \n-if test x\"$enable_lto\" = x\"yes\" ; then\n+ACX_ELF_TARGET_IFELSE([if test x\"$enable_lto\" = x\"yes\" ; then\n   # Make sure that libelf.h and gelf.h are available.\n   AC_ARG_WITH(libelf, [  --with-libelf=PATH       Specify prefix directory for the installed libelf package\n                           Equivalent to --with-libelf-include=PATH/include\n@@ -1783,7 +1774,24 @@ to specify its location.])\n   # Flags needed for libelf.\n   AC_SUBST(libelflibs)\n   AC_SUBST(libelfinc)\n-fi\n+fi],[if test x\"$default_enable_lto\" = x\"yes\" ; then\n+    # On non-ELF platforms, LTO must be explicitly enabled.\n+    enable_lto=no\n+  else\n+  # Apart from ELF platforms, only Windows supports LTO so far.  It\n+  # would also be nice to check the binutils support, but we don't\n+  # have gcc_GAS_CHECK_FEATURE available here.  For now, we'll just\n+  # warn during gcc/ subconfigure; unless you're bootstrapping with\n+  # -flto it won't be needed until after installation anyway.\n+    case $target in\n+      *-cygwin*|*-mingw*) ;;\n+      *) if test x\"$enable_lto\" = x\"yes\"; then\n+\tAC_MSG_ERROR([LTO support is not enabled for this target.])\n+        fi\n+      ;;\n+    esac\n+  fi\n+  default_enable_lto=no])\n \n \n # By default, C is the only stage 1 language."}, {"sha": "ca685700caaedc6966cc46a22e413a3d37a42e6f", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bec79c52e613995dd3b07b119a67cd7ad3d72a8/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bec79c52e613995dd3b07b119a67cd7ad3d72a8/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=3bec79c52e613995dd3b07b119a67cd7ad3d72a8", "patch": "@@ -326,6 +326,10 @@ LIBELFINC = @LIBELFINC@\n # Set to 'yes' if the LTO front end is enabled.\n enable_lto = @enable_lto@\n \n+# Set according to LTO object file format.\n+LTO_BINARY_READER = @LTO_BINARY_READER@\n+LTO_USE_LIBELF = @LTO_USE_LIBELF@\n+\n # Compiler needed for plugin support\n PLUGINCC = @CC@\n "}, {"sha": "ad66202642d43f39df22098c50e0bb7028f3fc30", "filename": "gcc/collect2.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bec79c52e613995dd3b07b119a67cd7ad3d72a8/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bec79c52e613995dd3b07b119a67cd7ad3d72a8/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=3bec79c52e613995dd3b07b119a67cd7ad3d72a8", "patch": "@@ -2548,19 +2548,21 @@ write_aix_file (FILE *stream, struct id *list)\n    be in ELF format.  */\n \n static bool\n-is_elf (const char *prog_name)\n+is_elf_or_coff (const char *prog_name)\n {\n   FILE *f;\n   char buf[4];\n   static char magic[4] = { 0x7f, 'E', 'L', 'F' };\n+  static char coffmag[2] = { 0x4c, 0x01 };\n \n-  f = fopen (prog_name, \"r\");\n+  f = fopen (prog_name, \"rb\");\n   if (f == NULL)\n     return false;\n   if (fread (buf, sizeof (buf), 1, f) != 1)\n     buf[0] = 0;\n   fclose (f);\n-  return memcmp (buf, magic, sizeof (magic)) == 0;\n+  return memcmp (buf, magic, sizeof (magic)) == 0\n+\t|| memcmp (buf, coffmag, sizeof (coffmag)) == 0;\n }\n \n /* Generic version to scan the name list of the loaded program for\n@@ -2587,10 +2589,10 @@ scan_prog_file (const char *prog_name, scanpass which_pass,\n   if (which_pass == PASS_SECOND)\n     return;\n \n-  /* LTO objects must be in ELF format.  This check prevents\n+  /* LTO objects must be in a known format.  This check prevents\n      us from accepting an archive containing LTO objects, which\n      gcc cannnot currently handle.  */\n-  if (which_pass == PASS_LTOINFO && !is_elf (prog_name))\n+  if (which_pass == PASS_LTOINFO && !is_elf_or_coff (prog_name))\n     return;\n \n   /* If we do not have an `nm', complain.  */\n@@ -2670,9 +2672,9 @@ scan_prog_file (const char *prog_name, scanpass which_pass,\n           /* Look for the LTO info marker symbol, and add filename to\n              the LTO objects list if found.  */\n           for (p = buf; (ch = *p) != '\\0' && ch != '\\n'; p++)\n-            if (ch == ' '\n-\t\t&& (strncmp (p + 1, \"__gnu_lto_v1\", 12) == 0)\n-\t\t&& ISSPACE (p[13]))\n+            if (ch == ' '  && p[1] == '_' && p[2] == '_'\n+\t\t&& (strncmp (p + (p[3] == '_' ? 2 : 1), \"__gnu_lto_v1\", 12) == 0)\n+\t\t&& ISSPACE (p[p[3] == '_' ? 14 : 13]))\n               {\n                 add_lto_object (&lto_objects, prog_name);\n "}, {"sha": "73be715203716ef97098cb148fe8dd9d07eb60e3", "filename": "gcc/config.gcc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bec79c52e613995dd3b07b119a67cd7ad3d72a8/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bec79c52e613995dd3b07b119a67cd7ad3d72a8/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=3bec79c52e613995dd3b07b119a67cd7ad3d72a8", "patch": "@@ -200,6 +200,8 @@ default_use_cxa_atexit=no\n target_gtfiles=\n need_64bit_hwint=\n need_64bit_isa=\n+# Selects the object file format reader/writer used by LTO.\n+lto_binary_reader=lto-elf\n \n # Don't carry these over build->host->target.  Please.\n xm_file=\n@@ -1324,6 +1326,7 @@ i[34567]86-*-pe | i[34567]86-*-cygwin*)\n \t\tthread_file='posix'\n \tfi\n \tuse_gcc_stdint=wrap\n+\tlto_binary_reader=lto-coff\n \t;;\n i[34567]86-*-mingw* | x86_64-*-mingw*)\n \ttm_file=\"${tm_file} i386/unix.h i386/bsd.h i386/gas.h dbxcoff.h i386/cygming.h i386/mingw32.h\"\n@@ -1391,6 +1394,7 @@ i[34567]86-*-mingw* | x86_64-*-mingw*)\n \tcxx_target_objs=\"${cxx_target_objs} winnt-cxx.o msformat-c.o\"\n \tdefault_use_cxa_atexit=yes\n \tuse_gcc_stdint=wrap\n+\tlto_binary_reader=lto-coff\n \tcase ${enable_threads} in\n \t  \"\" | yes | win32)\t  thread_file='win32'\n \t  tmake_file=\"${tmake_file} i386/t-gthr-win32\""}, {"sha": "e9f94a79b3cb5d29d50dd7c1074227bb501776c2", "filename": "gcc/config/i386/t-cygming", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bec79c52e613995dd3b07b119a67cd7ad3d72a8/gcc%2Fconfig%2Fi386%2Ft-cygming", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bec79c52e613995dd3b07b119a67cd7ad3d72a8/gcc%2Fconfig%2Fi386%2Ft-cygming", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Ft-cygming?ref=3bec79c52e613995dd3b07b119a67cd7ad3d72a8", "patch": "@@ -30,7 +30,7 @@ LIBGCC2_INCLUDES = -I$(srcdir)/../winsup/w32api/include\n \n winnt.o: $(srcdir)/config/i386/winnt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n   $(TM_H) $(RTL_H) $(REGS_H) hard-reg-set.h output.h $(TREE_H) flags.h \\\n-  $(TM_P_H) toplev.h $(HASHTAB_H) $(GGC_H)\n+  $(TM_P_H) toplev.h $(HASHTAB_H) $(GGC_H) $(LTO_STREAMER_H)\n \t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n \t$(srcdir)/config/i386/winnt.c\n "}, {"sha": "f7f4d2845ba2688a7c13e7c0e4e33330e275960c", "filename": "gcc/config/i386/winnt.c", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bec79c52e613995dd3b07b119a67cd7ad3d72a8/gcc%2Fconfig%2Fi386%2Fwinnt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bec79c52e613995dd3b07b119a67cd7ad3d72a8/gcc%2Fconfig%2Fi386%2Fwinnt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fwinnt.c?ref=3bec79c52e613995dd3b07b119a67cd7ad3d72a8", "patch": "@@ -35,6 +35,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"langhooks.h\"\n #include \"ggc.h\"\n #include \"target.h\"\n+#include \"lto-streamer.h\"\n \n /* i386/PE specific attribute support.\n \n@@ -465,6 +466,12 @@ i386_pe_asm_named_section (const char *name, unsigned int flags,\n         *f++ = 's';\n     }\n \n+  /* LTO sections need 1-byte alignment to avoid confusing the\n+     zlib decompression algorithm with trailing zero pad bytes.  */\n+  if (strncmp (name, LTO_SECTION_NAME_PREFIX,\n+\t\t\tstrlen (LTO_SECTION_NAME_PREFIX)) == 0)\n+    *f++ = '0';\n+\n   *f = '\\0';\n \n   fprintf (asm_out_file, \"\\t.section\\t%s,\\\"%s\\\"\\n\", name, flagchars);\n@@ -485,6 +492,8 @@ i386_pe_asm_named_section (const char *name, unsigned int flags,\n     }\n }\n \n+/* Beware, DECL may be NULL if compile_file() is emitting the LTO marker.  */\n+\n void\n i386_pe_asm_output_aligned_decl_common (FILE *stream, tree decl,\n \t\t\t\t\tconst char *name, HOST_WIDE_INT size,\n@@ -581,14 +590,18 @@ static GTY(()) struct export_list *export_head;\n    these, so that we can output the export list at the end of the\n    assembly.  We used to output these export symbols in each function,\n    but that causes problems with GNU ld when the sections are\n-   linkonce.  */\n+   linkonce.  Beware, DECL may be NULL if compile_file() is emitting\n+   the LTO marker.  */\n \n void\n i386_pe_maybe_record_exported_symbol (tree decl, const char *name, int is_data)\n {\n   rtx symbol;\n   struct export_list *p;\n \n+  if (!decl)\n+    return;\n+\n   symbol = XEXP (DECL_RTL (decl), 0);\n   gcc_assert (GET_CODE (symbol) == SYMBOL_REF);\n   if (!SYMBOL_REF_DLLEXPORT_P (symbol))"}, {"sha": "0515812873d665b40b0c9763094603a68ac0abbf", "filename": "gcc/configure", "status": "modified", "additions": 57, "deletions": 2, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bec79c52e613995dd3b07b119a67cd7ad3d72a8/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bec79c52e613995dd3b07b119a67cd7ad3d72a8/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=3bec79c52e613995dd3b07b119a67cd7ad3d72a8", "patch": "@@ -671,6 +671,8 @@ subdirs\n slibdir\n dollar\n gcc_tooldir\n+LTO_USE_LIBELF\n+LTO_BINARY_READER\n enable_lto\n MAINT\n zlibinc\n@@ -17092,7 +17094,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 17095 \"configure\"\n+#line 17097 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -17198,7 +17200,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 17201 \"configure\"\n+#line 17203 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -22942,6 +22944,48 @@ if test $gcc_cv_as_ix86_pe_secrel32 = yes; then\n $as_echo \"#define HAVE_GAS_PE_SECREL32_RELOC 1\" >>confdefs.h\n \n fi\n+\t# Test if the assembler supports the extended form of the .section\n+\t# directive that specifies section alignment.  LTO support uses this,\n+\t# but normally only after installation, so we warn but don't fail the\n+\t# configure if LTO is enabled but the assembler does not support it.\n+\t{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking assembler for .section with alignment\" >&5\n+$as_echo_n \"checking assembler for .section with alignment... \" >&6; }\n+if test \"${gcc_cv_as_section_has_align+set}\" = set; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  gcc_cv_as_section_has_align=no\n+    if test $in_tree_gas = yes; then\n+    if test $gcc_cv_gas_vers -ge `expr \\( \\( 2 \\* 1000 \\) + 20 \\) \\* 1000 + 1`\n+  then gcc_cv_as_section_has_align=yes\n+fi\n+  elif test x$gcc_cv_as != x; then\n+    echo '.section lto_test,\"dr0\"' > conftest.s\n+    if { ac_try='$gcc_cv_as $gcc_cv_as_flags -fatal-warnings -o conftest.o conftest.s >&5'\n+  { { eval echo \"\\\"\\$as_me\\\":${as_lineno-$LINENO}: \\\"$ac_try\\\"\"; } >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  $as_echo \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n+  test $ac_status = 0; }; }\n+    then\n+\tgcc_cv_as_section_has_align=yes\n+    else\n+      echo \"configure: failed program was\" >&5\n+      cat conftest.s >&5\n+    fi\n+    rm -f conftest.o conftest.s\n+  fi\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $gcc_cv_as_section_has_align\" >&5\n+$as_echo \"$gcc_cv_as_section_has_align\" >&6; }\n+\n+\tif test x$gcc_cv_as_section_has_align != xyes; then\n+\t  case \",$enable_languages,\" in\n+\t    *,lto,*)\n+\t      { $as_echo \"$as_me:${as_lineno-$LINENO}: WARNING: LTO for $target requires binutils >= 2.20.1, but version found appears insufficient; LTO will not work until binutils is upgraded.\" >&5\n+$as_echo \"$as_me: WARNING: LTO for $target requires binutils >= 2.20.1, but version found appears insufficient; LTO will not work until binutils is upgraded.\" >&2;}\n+\t      ;;\n+\t  esac\n+\tfi\n \t;;\n     esac\n \n@@ -25078,6 +25122,17 @@ $as_echo \"#define ENABLE_LTO 1\" >>confdefs.h\n \n \t\t    enable_lto=yes\n \n+\t\t    # LTO needs to speak the platform's object file format, and has a\n+\t\t    # number of implementations of the required binary file access APIs.\n+\t\t    # ELF is the most common, and default.  We only link libelf if ELF\n+\t\t    # is indeed the selected format.\n+\t\t    LTO_BINARY_READER=${lto_binary_reader}\n+\t\t    LTO_USE_LIBELF=-lelf\n+\t\t    if test \"x$lto_binary_reader\" != \"xlto-elf\" ; then\n+\t\t      LTO_USE_LIBELF=\n+\t\t    fi\n+\n+\n \t\t    ;;\n \t\t*) ;;\n \tesac"}, {"sha": "67973b1fec6f4935a52282888effb66c6d35212e", "filename": "gcc/configure.ac", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bec79c52e613995dd3b07b119a67cd7ad3d72a8/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bec79c52e613995dd3b07b119a67cd7ad3d72a8/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=3bec79c52e613995dd3b07b119a67cd7ad3d72a8", "patch": "@@ -3202,6 +3202,19 @@ foo:\tnop\n \t   rm -f conftest],\n \t  [AC_DEFINE(HAVE_GAS_PE_SECREL32_RELOC, 1,\n \t    [Define if your assembler and linker support 32-bit section relative relocs via '.secrel32 label'.])])\n+\t# Test if the assembler supports the extended form of the .section\n+\t# directive that specifies section alignment.  LTO support uses this,\n+\t# but normally only after installation, so we warn but don't fail the\n+\t# configure if LTO is enabled but the assembler does not support it.\n+\tgcc_GAS_CHECK_FEATURE([.section with alignment], gcc_cv_as_section_has_align,\n+\t  [2,20,1],-fatal-warnings,[.section lto_test,\"dr0\"])\n+\tif test x$gcc_cv_as_section_has_align != xyes; then\n+\t  case \",$enable_languages,\" in\n+\t    *,lto,*)\n+\t      AC_MSG_WARN([LTO for $target requires binutils >= 2.20.1, but version found appears insufficient; LTO will not work until binutils is upgraded.])\n+\t      ;;\n+\t  esac\n+\tfi\n \t;;\n     esac\n \n@@ -4270,6 +4283,17 @@ changequote([,])dnl\n \t\t    AC_DEFINE(ENABLE_LTO, 1, [Define to enable LTO support.])\n \t\t    enable_lto=yes\n \t\t    AC_SUBST(enable_lto)\n+\t\t    # LTO needs to speak the platform's object file format, and has a\n+\t\t    # number of implementations of the required binary file access APIs.\n+\t\t    # ELF is the most common, and default.  We only link libelf if ELF\n+\t\t    # is indeed the selected format.\n+\t\t    LTO_BINARY_READER=${lto_binary_reader}\n+\t\t    LTO_USE_LIBELF=-lelf\n+\t\t    if test \"x$lto_binary_reader\" != \"xlto-elf\" ; then\n+\t\t      LTO_USE_LIBELF=\n+\t\t    fi\n+\t\t    AC_SUBST(LTO_BINARY_READER)\n+\t\t    AC_SUBST(LTO_USE_LIBELF)\n \t\t    ;;\n \t\t*) ;;\n \tesac"}, {"sha": "b757655ee22b325f5ae0695d7d1f0c3cfebaa3a4", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bec79c52e613995dd3b07b119a67cd7ad3d72a8/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bec79c52e613995dd3b07b119a67cd7ad3d72a8/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=3bec79c52e613995dd3b07b119a67cd7ad3d72a8", "patch": "@@ -1,3 +1,13 @@\n+2010-04-27  Dave Korn  <dave.korn.cygwin@gmail.com>\n+\n+\tPR lto/42776\n+\t* Make-lang.in (LTO_OBJS): Use LTO_BINARY_READER instead of\n+\thardcoding 'lto-elf.o'.\n+\t($(LTO_EXE)): Use LTO_USE_LIBELF instead of hardcoding '-lelf'.\n+\n+\t* lto-coff.h: New file.\n+\t* lto-coff.c: Likewise.\n+\n 2010-04-26  Richard Guenther  <rguenther@suse.de>\n \n \t* lto.c (lto_fixup_type): Deal with non-type TYPE_CONTEXT."}, {"sha": "a06ab4a18a54c9b8e378cd9d578981ac71f6757b", "filename": "gcc/lto/Make-lang.in", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bec79c52e613995dd3b07b119a67cd7ad3d72a8/gcc%2Flto%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bec79c52e613995dd3b07b119a67cd7ad3d72a8/gcc%2Flto%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FMake-lang.in?ref=3bec79c52e613995dd3b07b119a67cd7ad3d72a8", "patch": "@@ -23,7 +23,7 @@\n # The name of the LTO compiler.\n LTO_EXE = lto1$(exeext)\n # The LTO-specific object files inclued in $(LTO_EXE).\n-LTO_OBJS = lto/lto-lang.o lto/lto.o lto/lto-elf.o attribs.o\n+LTO_OBJS = lto/lto-lang.o lto/lto.o lto/$(LTO_BINARY_READER).o attribs.o\n LTO_H = lto/lto.h $(HASHTAB_H)\n LINKER_PLUGIN_API_H = $(srcdir)/../include/plugin-api.h\n LTO_TREE_H = lto/lto-tree.h $(LINKER_PLUGIN_API_H)\n@@ -73,7 +73,7 @@ lto-warn = $(STRICT_WARN)\n \n $(LTO_EXE): $(LTO_OBJS) $(BACKEND) $(LIBDEPS)\n \t$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o $@ \\\n-\t\t$(LTO_OBJS) $(BACKEND) $(BACKENDLIBS) $(LIBS) -lelf\n+\t\t$(LTO_OBJS) $(BACKEND) $(BACKENDLIBS) $(LIBS) $(LTO_USE_LIBELF)\n \n # Dependencies\n lto/lto-lang.o: lto/lto-lang.c $(CONFIG_H) coretypes.h debug.h \\\n@@ -88,3 +88,6 @@ lto/lto.o: lto/lto.c $(CONFIG_H) $(SYSTEM_H) coretypes.h opts.h \\\n \t$(LTO_TAGS_H) $(LTO_STREAMER_H)\n lto/lto-elf.o: lto/lto-elf.c $(CONFIG_H) coretypes.h $(SYSTEM_H) \\\n \ttoplev.h $(LTO_H) $(TM_H) $(LIBIBERTY_H) $(GGC_H) $(LTO_STREAMER_H)\n+lto/lto-coff.o: lto/lto-coff.c $(CONFIG_H) coretypes.h $(SYSTEM_H) \\\n+\ttoplev.h $(LTO_H) $(TM_H) $(LIBIBERTY_H) $(GGC_H) $(LTO_STREAMER_H) \\\n+\tlto/lto-coff.h"}, {"sha": "1814cfdb82b9cb157098d73e9ba399e6ed9e0133", "filename": "gcc/lto/lto-coff.c", "status": "added", "additions": 845, "deletions": 0, "changes": 845, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bec79c52e613995dd3b07b119a67cd7ad3d72a8/gcc%2Flto%2Flto-coff.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bec79c52e613995dd3b07b119a67cd7ad3d72a8/gcc%2Flto%2Flto-coff.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-coff.c?ref=3bec79c52e613995dd3b07b119a67cd7ad3d72a8", "patch": "@@ -0,0 +1,845 @@\n+/* LTO routines for COFF object files.\n+   Copyright 2009 Free Software Foundation, Inc.\n+   Contributed by Dave Korn.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"toplev.h\"\n+#include \"lto.h\"\n+#include \"tm.h\"\n+#include \"libiberty.h\"\n+#include \"ggc.h\"\n+#include \"lto-streamer.h\"\n+#include \"lto/lto-coff.h\"\n+\n+\n+/* Rather than implementing a libcoff to match libelf, or attempting to\n+   integrate libbfd into GCC, this file is a self-contained (and very\n+   minimal) COFF format object file reader/writer.  The generated files\n+   will contain a COFF header, a number of COFF section headers, the \n+   section data itself, and a trailing string table for section names.  */\n+\n+/* Handle opening elf files on hosts, such as Windows, that may use \n+   text file handling that will break binary access.  */\n+\n+#ifndef O_BINARY\n+#define O_BINARY 0\n+#endif\n+\n+/* Known header magics for validation, as an array.  */\n+\n+static const unsigned int coff_machine_array[] = COFF_KNOWN_MACHINES;\n+\n+/* Number of valid entries (no sentinel) in array.  */\n+\n+#define NUM_COFF_KNOWN_MACHINES\t\\\n+\t(sizeof (coff_machine_array) / sizeof (coff_machine_array[0]))\n+\n+/* Cached object file header.  */\n+\n+static Coff_header cached_coff_hdr;\n+\n+/* Flag to indicate if we have read and cached any header yet.  */\n+\n+static bool cached_coff_hdr_valid = false;\n+\n+/* The current output file.  */\n+\n+static lto_file *current_out_file;\n+\n+\n+/* Sets the current output file to FILE.  Returns the old output file or\n+   NULL.  */\n+\n+lto_file *\n+lto_set_current_out_file (lto_file *file)\n+{\n+  lto_file *old_file = current_out_file;\n+  current_out_file = file;\n+  return old_file;\n+}\n+\n+\n+/* Returns the current output file.  */\n+\n+lto_file *\n+lto_get_current_out_file (void)\n+{\n+  return current_out_file;\n+}\n+\n+\n+/* COFF section structure constructor.  */\n+\n+static lto_coff_section *\n+coff_newsection (lto_coff_file *file, const char *name, size_t type)\n+{\n+  lto_coff_section *ptr, **chain_ptr_ptr;\n+\n+  ptr = XCNEW (lto_coff_section);\n+  ptr->name = name;\n+  ptr->type = type;\n+\n+  chain_ptr_ptr = &file->section_chain;\n+  while (*chain_ptr_ptr)\n+    chain_ptr_ptr = &(*chain_ptr_ptr)->next;\n+  *chain_ptr_ptr = ptr;\n+\n+  return ptr;\n+}\n+\n+\n+/* COFF section data block structure constructor.  */\n+\n+static lto_coff_data *\n+coff_newdata (lto_coff_section *sec)\n+{\n+  lto_coff_data *ptr, **chain_ptr_ptr;\n+\n+  ptr = XCNEW (lto_coff_data);\n+\n+  chain_ptr_ptr = &sec->data_chain;\n+  while (*chain_ptr_ptr)\n+    chain_ptr_ptr = &(*chain_ptr_ptr)->next;\n+  *chain_ptr_ptr = ptr;\n+\n+  return ptr;\n+}\n+\n+\n+/* Initialize FILE, an LTO file object for FILENAME.  */\n+\n+static void\n+lto_file_init (lto_file *file, const char *filename, off_t offset)\n+{\n+  file->filename = filename;\n+  file->offset = offset;\n+}\n+\n+/* Return an error string after an error, or a predetermined one\n+   if ERRCODE is not -1.  */\n+\n+static const char *\n+coff_errmsg (int errcode)\n+{\n+  return strerror (errcode == -1 ? errno : errcode);\n+}\n+\n+/* Returns a hash code for P.  */\n+\n+static hashval_t\n+hash_name (const void *p)\n+{\n+  const struct lto_section_slot *ds = (const struct lto_section_slot *) p;\n+  return (hashval_t) htab_hash_string (ds->name);\n+}\n+\n+/* Returns nonzero if P1 and P2 are equal.  */\n+\n+static int\n+eq_name (const void *p1, const void *p2)\n+{\n+  const struct lto_section_slot *s1 =\n+    (const struct lto_section_slot *) p1;\n+  const struct lto_section_slot *s2 =\n+    (const struct lto_section_slot *) p2;\n+\n+  return strcmp (s1->name, s2->name) == 0;\n+}\n+\n+\n+/* Build a hash table whose key is the section names and whose data is\n+   the start and size of each section in the .o file.  */\n+\n+htab_t\n+lto_obj_build_section_table (lto_file *lto_file) \n+{\n+  lto_coff_file *coff_file = (lto_coff_file *)lto_file;\n+  lto_coff_section *sec;\n+  htab_t section_hash_table;\n+  ssize_t strtab_size;\n+  char *strtab;\n+\n+  section_hash_table = htab_create (37, hash_name, eq_name, free);\n+\n+  /* Seek to start of string table.  */\n+  if (coff_file->strtab_offs != lseek (coff_file->fd,\n+\t\tcoff_file->base.offset + coff_file->strtab_offs, SEEK_SET))\n+    {\n+      error (\"altered or invalid COFF object file\");\n+      return section_hash_table;\n+    }\n+\n+  strtab_size = coff_file->file_size - coff_file->strtab_offs;\n+  strtab = XNEWVEC (char, strtab_size);\n+  if (read (coff_file->fd, strtab, strtab_size) != strtab_size)\n+    {\n+      error (\"invalid COFF object file string table\");\n+      return section_hash_table;\n+    }\n+\n+  /* Scan sections looking at names.  */\n+  COFF_FOR_ALL_SECTIONS(coff_file, sec)\n+    {\n+      struct lto_section_slot s_slot;\n+      void **slot;\n+      char *new_name;\n+      int stringoffset;\n+      char *name = (char *) &sec->coffsec.Name[0];\n+\n+      /* Skip dummy string section if by any chance we see it.  */\n+      if (sec->type == 1)\n+\tcontinue;\n+\n+      if (name[0] == '/')\n+\t{\n+\t  if (1 != sscanf (&name[1], \"%d\", &stringoffset)\n+\t\t|| stringoffset < 0 || stringoffset >= strtab_size)\n+\t    {\n+\t      error (\"invalid COFF section name string\");\n+\t      continue;\n+\t    }\n+\t  name = strtab + stringoffset;\n+\t}\n+      else\n+\t{\n+\t  /* If we cared about the VirtualSize field, we couldn't\n+\t     crudely trash it like this to guarantee nul-termination\n+\t     of the Name field.  But we don't, so we do.  */\n+\t  name[8] = 0;\n+\t}\n+      if (strncmp (name, LTO_SECTION_NAME_PREFIX,\n+\t\t\tstrlen (LTO_SECTION_NAME_PREFIX)) != 0)\n+\t  continue;\n+\n+      new_name = XNEWVEC (char, strlen (name) + 1);\n+      strcpy (new_name, name);\n+      s_slot.name = new_name;\n+      slot = htab_find_slot (section_hash_table, &s_slot, INSERT);\n+      if (*slot == NULL)\n+\t{\n+\t  struct lto_section_slot *new_slot = XNEW (struct lto_section_slot);\n+\n+\t  new_slot->name = new_name;\n+\t  /* The offset into the file for this section.  */\n+\t  new_slot->start = coff_file->base.offset\n+\t\t\t+ COFF_GET(&sec->coffsec,PointerToRawData);\n+\t  new_slot->len = COFF_GET(&sec->coffsec,SizeOfRawData);\n+\t  *slot = new_slot;\n+\t}\n+      else\n+\t{\n+\t  error (\"two or more sections for %s:\", new_name);\n+\t  return NULL;\n+\t}\n+    }\n+\n+  free (strtab);\n+  return section_hash_table;\n+}\n+\n+\n+/* Begin a new COFF section named NAME with type TYPE in the current output\n+   file.  TYPE is an SHT_* macro from the libelf headers.  */\n+\n+static void\n+lto_coff_begin_section_with_type (const char *name, size_t type)\n+{\n+  lto_coff_file *file;\n+  size_t sh_name;\n+\n+  /* Grab the current output file and do some basic assertion checking.  */\n+  file = (lto_coff_file *) lto_get_current_out_file (),\n+  gcc_assert (file);\n+  gcc_assert (!file->scn);\n+\n+  /* Create a new section.  */\n+  file->scn = coff_newsection (file, name, type);\n+  if (!file->scn)\n+    fatal_error (\"could not create a new COFF section: %s\", coff_errmsg (-1));\n+\n+  /* Add a string table entry and record the offset.  */\n+  gcc_assert (file->shstrtab_stream);\n+  sh_name = file->shstrtab_stream->total_size;\n+  lto_output_data_stream (file->shstrtab_stream, name, strlen (name) + 1);\n+\n+  /* Initialize the section header.  */\n+  file->scn->strtab_offs = sh_name;\n+}\n+\n+\n+/* Begin a new COFF section named NAME in the current output file.  */\n+\n+void\n+lto_obj_begin_section (const char *name)\n+{\n+  lto_coff_begin_section_with_type (name, 0);\n+}\n+\n+\n+/* Append DATA of length LEN to the current output section.  BASE is a pointer\n+   to the output page containing DATA.  It is freed once the output file has\n+   been written.  */\n+\n+void\n+lto_obj_append_data (const void *data, size_t len, void *block)\n+{\n+  lto_coff_file *file;\n+  lto_coff_data *coff_data;\n+  struct lto_char_ptr_base *base = (struct lto_char_ptr_base *) block;\n+\n+  /* Grab the current output file and do some basic assertion checking.  */\n+  file = (lto_coff_file *) lto_get_current_out_file ();\n+  gcc_assert (file);\n+  gcc_assert (file->scn);\n+\n+  coff_data = coff_newdata (file->scn);\n+  if (!coff_data)\n+    fatal_error (\"could not append data to COFF section: %s\", coff_errmsg (-1));\n+\n+  coff_data->d_buf = CONST_CAST (void *, data);\n+  coff_data->d_size = len;\n+\n+  /* Chain all data blocks (from all sections) on one singly-linked\n+     list for freeing en masse after the file is closed.  */\n+  base->ptr = (char *)file->data;\n+  file->data = base;\n+}\n+\n+\n+/* End the current output section.  This just does some assertion checking\n+   and sets the current output file's scn member to NULL.  */\n+\n+void\n+lto_obj_end_section (void)\n+{\n+  lto_coff_file *file;\n+\n+  /* Grab the current output file and validate some basic assertions.  */\n+  file = (lto_coff_file *) lto_get_current_out_file ();\n+  gcc_assert (file);\n+  gcc_assert (file->scn);\n+\n+  file->scn = NULL;\n+}\n+\n+\n+/* Validate's COFF_FILE's executable header and, if cached_coff_hdr is\n+   uninitialized, caches the results.  Also records the section header string\n+   table's section index.  Returns true on success or false on failure.  */\n+\n+static bool\n+validate_file (lto_coff_file *coff_file)\n+{\n+  size_t n, secnum;\n+  unsigned int numsections, secheaderssize, numsyms;\n+  off_t sectionsstart, symbolsstart, stringsstart;\n+  unsigned int mach, charact;\n+\n+  /* Read and sanity check the raw header.  */\n+  n = read (coff_file->fd, &coff_file->coffhdr, sizeof (coff_file->coffhdr));\n+  if (n != sizeof (coff_file->coffhdr))\n+    {\n+      error (\"not a COFF object file\");\n+      return false;\n+    }\n+\n+  mach = COFF_GET(&coff_file->coffhdr, Machine);\n+  for (n = 0; n < NUM_COFF_KNOWN_MACHINES; n++)\n+    if (mach == coff_machine_array[n])\n+      break;\n+  if (n == NUM_COFF_KNOWN_MACHINES)\n+    {\n+      error (\"not a recognized COFF object file\");\n+      return false;\n+    }\n+\n+  charact = COFF_GET(&coff_file->coffhdr, Characteristics);\n+  if (COFF_NOT_CHARACTERISTICS & charact)\n+    {\n+      /* DLL, EXE or SYS file.  */\n+      error (\"not a relocatable COFF object file\");\n+      return false;\n+    }\n+\n+  if (COFF_CHARACTERISTICS != (COFF_CHARACTERISTICS & charact))\n+    {\n+      /* ECOFF/XCOFF/PE+ support not implemented.  */\n+      error (\"not a 32-bit COFF object file\");\n+      return false;\n+    }\n+\n+  /* It validated OK, so cached it if we don't already have one.  */\n+  if (!cached_coff_hdr_valid)\n+    {\n+      cached_coff_hdr_valid = true;\n+      memcpy (&cached_coff_hdr, &coff_file->coffhdr, sizeof (cached_coff_hdr));\n+    }\n+\n+  if (mach != COFF_GET(&cached_coff_hdr, Machine))\n+    {\n+      error (\"inconsistent file architecture detected\");\n+      return false;\n+    }\n+\n+  /* Read section headers and string table? */\n+\n+  numsections = COFF_GET(&coff_file->coffhdr, NumberOfSections);\n+  secheaderssize = numsections * sizeof (Coff_section);\n+  sectionsstart = sizeof (Coff_header) + secheaderssize;\n+  symbolsstart = COFF_GET(&coff_file->coffhdr, PointerToSymbolTable);\n+  numsyms = COFF_GET(&coff_file->coffhdr, NumberOfSymbols);\n+  stringsstart = (symbolsstart + COFF_SYMBOL_SIZE * numsyms);\n+\n+#define CVOFFSETTTED(x) (coff_file->base.offset + (x))\n+\n+  if (numsections <= 0 || symbolsstart <= 0 || numsyms <= 0\n+\t|| (CVOFFSETTTED(sectionsstart) >= coff_file->file_size)\n+\t|| (CVOFFSETTTED(symbolsstart) >= coff_file->file_size)\n+\t|| (CVOFFSETTTED(stringsstart) >= coff_file->file_size))\n+    {\n+      error (\"not a valid COFF object file\");\n+      return false;\n+    }\n+\n+#undef CVOFFSETTTED\n+\n+  /* Record start of string table.  */\n+  coff_file->strtab_offs = stringsstart;\n+\n+  /* Validate section table entries.  */\n+  for (secnum = 0; secnum < numsections; secnum++)\n+    {\n+      Coff_section coffsec;\n+      lto_coff_section *ltosec;\n+      off_t size_raw, offs_raw, offs_relocs, offs_lines;\n+      off_t num_relocs, num_lines;\n+\n+      n = read (coff_file->fd, &coffsec, sizeof (coffsec));\n+      if (n != sizeof (coffsec))\n+\t{\n+\t  error (\"short/missing COFF section table\");\n+\t  return false;\n+\t}\n+\n+      size_raw = COFF_GET(&coffsec, SizeOfRawData);\n+      offs_raw = COFF_GET(&coffsec, PointerToRawData);\n+      offs_relocs = COFF_GET(&coffsec, PointerToRelocations);\n+      offs_lines = COFF_GET(&coffsec, PointerToLinenumbers);\n+      num_relocs = COFF_GET(&coffsec, NumberOfRelocations);\n+      num_lines = COFF_GET(&coffsec, NumberOfLinenumbers);\n+\n+      if (size_raw < 0 || num_relocs < 0 || num_lines < 0\n+\t|| (size_raw\n+\t  && ((COFF_GET(&coffsec, Characteristics)\n+\t      & IMAGE_SCN_CNT_UNINITIALIZED_DATA)\n+\t    ? (offs_raw != 0)\n+\t    : (offs_raw < sectionsstart || offs_raw >= coff_file->file_size)))\n+\t|| (num_relocs\n+\t  && (offs_relocs < sectionsstart\n+\t    || offs_relocs >= coff_file->file_size))\n+\t|| (num_lines\n+\t  && (offs_lines < sectionsstart\n+\t    || offs_lines >= coff_file->file_size)))\n+\t{\n+\t  error (\"invalid COFF section table\");\n+\t  return false;\n+\t}\n+\n+      /* Looks ok, so record its details.  We don't read the \n+         string table or set up names yet; we'll do that when\n+\t we build the hash table.  */\n+      ltosec = coff_newsection (coff_file, NULL, 0);\n+      memcpy (&ltosec->coffsec, &coffsec, sizeof (ltosec->coffsec));\n+    }\n+\n+  return true;\n+}\n+\n+/* Initialize COFF_FILE's executable header using cached data from previously\n+   read files.  */\n+\n+static void\n+init_coffhdr (lto_coff_file *coff_file)\n+{\n+  gcc_assert (cached_coff_hdr_valid);\n+  memset (&coff_file->coffhdr, 0, sizeof (coff_file->coffhdr));\n+  COFF_PUT(&coff_file->coffhdr, Machine, COFF_GET(&cached_coff_hdr, Machine));\n+  COFF_PUT(&coff_file->coffhdr, Characteristics, COFF_GET(&cached_coff_hdr, Characteristics));\n+}\n+\n+/* Open COFF file FILENAME.  If WRITABLE is true, the file is opened for write\n+   and, if necessary, created.  Otherwise, the file is opened for reading.\n+   Returns the opened file.  */\n+\n+lto_file *\n+lto_obj_file_open (const char *filename, bool writable)\n+{\n+  lto_coff_file *coff_file;\n+  lto_file *result = NULL;\n+  off_t offset;\n+  const char *offset_p;\n+  char *fname;\n+  struct stat statbuf;\n+\n+  offset_p = strchr (filename, '@');\n+  if (!offset_p)\n+    {\n+      fname = xstrdup (filename);\n+      offset = 0;\n+    }\n+  else\n+    {\n+      /* The file started with '@' is a file containing command line\n+\t options.  Stop if it doesn't exist.  */\n+      if (offset_p == filename)\n+\tfatal_error (\"command line option file '%s' does not exist\",\n+\t\t     filename);\n+\n+      fname = (char *) xmalloc (offset_p - filename + 1);\n+      memcpy (fname, filename, offset_p - filename);\n+      fname[offset_p - filename] = '\\0';\n+      offset_p += 3; /* skip the @0x */\n+      offset = lto_parse_hex (offset_p);\n+    }\n+\n+  /* Set up.  */\n+  coff_file = XCNEW (lto_coff_file);\n+  result = (lto_file *) coff_file;\n+  lto_file_init (result, fname, offset);\n+  coff_file->fd = -1;\n+\n+  /* Open the file.  */\n+  coff_file->fd = open (fname,\n+    O_BINARY | (writable ? O_WRONLY | O_CREAT | O_TRUNC : O_RDONLY), 0666);\n+\n+  if (coff_file->fd == -1)\n+    {\n+      error (\"could not open file %s\", fname);\n+      goto fail;\n+    }\n+\n+  if (stat (fname, &statbuf) < 0)\n+    {\n+      error (\"could not stat file %s\", fname);\n+      goto fail;\n+    }\n+\n+  coff_file->file_size = statbuf.st_size;\n+\n+  if (offset != 0)\n+    {\n+      char ar_tail[12];\n+      int size;\n+\n+      /* Surely not?  */\n+      gcc_assert (!writable);\n+\n+      /* Seek to offset, or error.  */\n+      if (lseek (coff_file->fd, offset, SEEK_SET) != (ssize_t) offset)\n+\t{\n+\t  error (\"could not find archive member @0x%lx\", (long) offset);\n+\t  goto fail;\n+\t}\n+\n+      /* Now seek back 12 chars and read the tail of the AR header to\n+         find the length of the member file.  */\n+      if (lseek (coff_file->fd, -12, SEEK_CUR) < 0\n+\t  || read (coff_file->fd, ar_tail, 12) != 12\n+\t  || lseek (coff_file->fd, 0, SEEK_CUR) != (ssize_t) offset\n+\t  || ar_tail[10] != '`' || ar_tail[11] != '\\n')\n+\t{\n+\t  error (\"could not find archive header @0x%lx\", (long) offset);\n+\t  goto fail;\n+\t}\n+\n+      ar_tail[11] = 0;\n+      if (sscanf (ar_tail, \"%d\", &size) != 1)\n+\t{\n+\t  error (\"invalid archive header @0x%lx\", (long) offset);\n+\t  goto fail;\n+\t}\n+      coff_file->file_size = size;\n+    }\n+\n+  if (writable)\n+    {\n+      init_coffhdr (coff_file);\n+      coff_file->shstrtab_stream = XCNEW (struct lto_output_stream);\n+    }\n+  else\n+    if (!validate_file (coff_file))\n+      goto fail;\n+\n+  return result;\n+\n+ fail:\n+  if (result)\n+    lto_obj_file_close (result);\n+  return NULL;\n+}\n+\n+\n+/* Close COFF file FILE and clean up any associated data structures.  If FILE\n+   was opened for writing, the file's COFF data is written at this time, and\n+   any cached data buffers are freed.  Return TRUE if there was an error.  */\n+\n+static bool\n+coff_write_object_file (lto_coff_file *coff_file)\n+{\n+  lto_coff_section *cursec, *stringsec;\n+  lto_coff_data *data;\n+  size_t fileoffset, numsections, totalsecsize, numsyms, stringssize;\n+  bool write_err = false;\n+  int secnum;\n+\n+  /* Infer whether this file was opened for reading or writing from the\n+     presence or absense of an initialised stream for the string table;\n+     do nothing if it was opened for reading.  */\n+  if (!coff_file->shstrtab_stream)\n+    return false;\n+  else\n+    {\n+      /* Write the COFF string table into a dummy new section that\n+\t we will not write a header for.  */\n+      lto_file *old_file = lto_set_current_out_file (&coff_file->base);\n+      /* This recursively feeds in the data to a new section.  */\n+      lto_coff_begin_section_with_type (\".strtab\", 1);\n+      lto_write_stream (coff_file->shstrtab_stream);\n+      lto_obj_end_section ();\n+      lto_set_current_out_file (old_file);\n+      free (coff_file->shstrtab_stream);\n+    }\n+\n+  /* Layout the file.  Count sections (not dummy string section) and calculate\n+     data size for all of them.  */\n+  numsections = 0;\n+  totalsecsize = 0;\n+  stringssize = 0;\n+  stringsec = NULL;\n+  COFF_FOR_ALL_SECTIONS(coff_file, cursec)\n+    {\n+      lto_coff_data *data;\n+      size_t cursecsize;\n+      cursecsize = 0;\n+      COFF_FOR_ALL_DATA(cursec,data)\n+\tcursecsize += data->d_size;\n+      if (cursec->type == 0)\n+\t{\n+\t  ++numsections;\n+\t  totalsecsize += COFF_ALIGN(cursecsize);\n+#if COFF_ALIGNMENT > 1\n+\t  cursec->pad_needed = COFF_ALIGN(cursecsize) - cursecsize;\n+#endif\n+\t}\n+      else\n+        {\n+\t  stringssize = cursecsize;\n+\t  stringsec = cursec;\n+\t}\n+      COFF_PUT(&cursec->coffsec, SizeOfRawData, cursecsize);\n+    }\n+\n+  /* There is a file symbol and a section symbol per section,\n+     and each of these has a single auxiliary symbol following.  */\n+  numsyms = 2 * (1 + numsections);\n+\n+  /* Great!  Now we have enough info to fill out the file header.  */\n+  COFF_PUT(&coff_file->coffhdr, NumberOfSections, numsections);\n+  COFF_PUT(&coff_file->coffhdr, NumberOfSymbols, numsyms);\n+  COFF_PUT(&coff_file->coffhdr, PointerToSymbolTable, sizeof (Coff_header)\n+\t\t+ numsections * sizeof (Coff_section) + totalsecsize);\n+  /* The remaining members were initialised to zero or copied from\n+     a cached header, so we leave them alone here.  */\n+\n+  /* Now position all the sections, and fill out their headers.  */\n+  fileoffset = sizeof (Coff_header) + numsections * sizeof (Coff_section);\n+  COFF_FOR_ALL_SECTIONS(coff_file, cursec)\n+    {\n+      /* Skip dummy string section.  */\n+      if (cursec->type == 1)\n+\tcontinue;\n+      COFF_PUT(&cursec->coffsec, PointerToRawData, fileoffset);\n+      fileoffset += COFF_ALIGN (COFF_GET(&cursec->coffsec, SizeOfRawData));\n+      COFF_PUT(&cursec->coffsec, Characteristics, COFF_SECTION_CHARACTERISTICS);\n+      snprintf ((char *)&cursec->coffsec.Name[0], 8, \"/%d\", cursec->strtab_offs + 4);\n+    }\n+\n+  /* We can write the data now.  As there's no way to indicate an error return\n+     from this hook, error handling is limited to not wasting our time doing\n+     any more writes in the event that any one fails.  */\n+\n+  /* Write the COFF header.  */\n+  write_err = (write (coff_file->fd, &coff_file->coffhdr,\n+\t\tsizeof (coff_file->coffhdr)) != sizeof (coff_file->coffhdr));\n+\n+  /* Write the COFF section headers.  */\n+  COFF_FOR_ALL_SECTIONS(coff_file, cursec)\n+    if (cursec->type == 1)\t/* Skip dummy string section.  */\n+\tcontinue;\n+    else if (!write_err)\n+      write_err = (write (coff_file->fd, &cursec->coffsec,\n+\t\tsizeof (cursec->coffsec)) != sizeof (cursec->coffsec));\n+    else\n+      break;\n+\n+  /* Write the COFF sections.  */\n+  COFF_FOR_ALL_SECTIONS(coff_file, cursec)\n+    {\n+#if COFF_ALIGNMENT > 1\n+      static const char padzeros[COFF_ALIGNMENT] = { 0 };\n+#endif\n+      /* Skip dummy string section.  */\n+      if (cursec->type == 1)\n+\tcontinue;\n+      COFF_FOR_ALL_DATA(cursec, data)\n+\tif (!write_err)\n+\t  write_err = (write (coff_file->fd, data->d_buf, data->d_size)\n+\t\t!= data->d_size);\n+\telse\n+\t  break;\n+#if COFF_ALIGNMENT > 1\n+      if (!write_err && cursec->pad_needed)\n+\twrite_err = (write (coff_file->fd, padzeros, cursec->pad_needed)\n+\t\t!= cursec->pad_needed);\n+#endif\n+    }\n+\n+  /* Write the COFF symbol table.  */\n+  if (!write_err)\n+    {\n+      union\n+\t{\n+\t  Coff_symbol sym;\n+\t  Coff_aux_sym_file file;\n+\t  Coff_aux_sym_section sec;\n+\t} symbols[2];\n+      memset (&symbols[0], 0, sizeof (symbols));\n+      strcpy ((char *) &symbols[0].sym.Name[0], \".file\");\n+      COFF_PUT(&symbols[0].sym, SectionNumber, IMAGE_SYM_DEBUG);\n+      COFF_PUT(&symbols[0].sym, Type, IMAGE_SYM_TYPE);\n+      symbols[0].sym.StorageClass[0] = IMAGE_SYM_CLASS_FILE;\n+      symbols[0].sym.NumberOfAuxSymbols[0] = 1;\n+      snprintf ((char *)symbols[1].file.FileName,\n+\t\tsizeof (symbols[1].file.FileName),\n+\t\t\"%s\", lbasename (coff_file->base.filename));\n+      write_err = (write (coff_file->fd, &symbols[0], sizeof (symbols))\n+\t\t!= (2 * COFF_SYMBOL_SIZE));\n+\n+      /* Set up constant parts for section sym loop.  */\n+      memset (&symbols[0], 0, sizeof (symbols));\n+      COFF_PUT(&symbols[0].sym, Type, IMAGE_SYM_TYPE);\n+      symbols[0].sym.StorageClass[0] = IMAGE_SYM_CLASS_STATIC;\n+      symbols[0].sym.NumberOfAuxSymbols[0] = 1;\n+\n+      secnum = 1;\n+      if (!write_err)\n+\tCOFF_FOR_ALL_SECTIONS(coff_file, cursec)\n+\t  {\n+\t    /* Skip dummy string section.  */\n+\t    if (cursec->type == 1)\n+\t      continue;\n+\t    /* Reuse section name string for section symbol name.  */\n+\t    COFF_PUT_NDXSZ(&symbols[0].sym, Name, 0, 0, 4);\n+\t    COFF_PUT_NDXSZ(&symbols[0].sym, Name, cursec->strtab_offs + 4, 4, 4);\n+\t    COFF_PUT(&symbols[0].sym, SectionNumber, secnum++);\n+\t    COFF_PUT(&symbols[1].sec, Length,\n+\t\t\tCOFF_GET(&cursec->coffsec, SizeOfRawData));\n+\t    if (!write_err)\n+\t      write_err = (write (coff_file->fd, &symbols[0], sizeof (symbols))\n+\t\t\t!= (2 * COFF_SYMBOL_SIZE));\n+\t    else\n+\t      break;\n+\t  }\n+    }\n+\n+  /* Write the COFF string table.  */\n+  if (!write_err)\n+    {\n+      unsigned char outlen[4];\n+      COFF_PUT4(outlen, stringssize + 4);\n+      if (!write_err)\n+\twrite_err = (write (coff_file->fd, outlen, 4) != 4);\n+      if (stringsec)\n+\tCOFF_FOR_ALL_DATA(stringsec, data)\n+\t  if (!write_err)\n+\twrite_err = (write (coff_file->fd, data->d_buf, data->d_size)\n+\t\t\t!= data->d_size);\n+\telse\n+\t  break;\n+    }\n+\n+  return write_err;\n+}\n+\n+/* Close COFF file FILE and clean up any associated data structures.  If FILE\n+   was opened for writing, the file's COFF data is written at this time, and\n+   any cached data buffers are freed.  */\n+\n+void\n+lto_obj_file_close (lto_file *file)\n+{\n+  lto_coff_file *coff_file = (lto_coff_file *) file;\n+  struct lto_char_ptr_base *cur, *tmp;\n+  lto_coff_section *cursec, *nextsec;\n+  bool write_err = false;\n+\n+  /* Write the COFF string table into a dummy new section that\n+     we will not write a header for.  */\n+  if (coff_file->shstrtab_stream)\n+    coff_write_object_file (coff_file);\n+\n+  /* Close the file, we're done.  */\n+  if (coff_file->fd != -1)\n+    close (coff_file->fd);\n+\n+  /* Free any data buffers.  */\n+  cur = coff_file->data;\n+  while (cur)\n+    {\n+      tmp = cur;\n+      cur = (struct lto_char_ptr_base *) cur->ptr;\n+      free (tmp);\n+    }\n+\n+  /* Free any sections and their data chains.  */\n+  cursec = coff_file->section_chain;\n+  while (cursec)\n+    {\n+      lto_coff_data *curdata, *nextdata;\n+      nextsec = cursec->next;\n+      curdata = cursec->data_chain;\n+      while (curdata)\n+\t{\n+\t  nextdata = curdata->next;\n+\t  free (curdata);\n+\t  curdata = nextdata;\n+\t}\n+      free (cursec);\n+      cursec = nextsec;\n+    }\n+\n+  free (file);\n+\n+  /* If there was an error, mention it.  */\n+  if (write_err)\n+    error (\"I/O error writing COFF output file\");\n+}\n+"}, {"sha": "f069d0cae46bfc4406eb5fd08c33d3266ac7a8cf", "filename": "gcc/lto/lto-coff.h", "status": "added", "additions": 406, "deletions": 0, "changes": 406, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bec79c52e613995dd3b07b119a67cd7ad3d72a8/gcc%2Flto%2Flto-coff.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bec79c52e613995dd3b07b119a67cd7ad3d72a8/gcc%2Flto%2Flto-coff.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-coff.h?ref=3bec79c52e613995dd3b07b119a67cd7ad3d72a8", "patch": "@@ -0,0 +1,406 @@\n+/* LTO routines for COFF object files.\n+   Copyright 2009 Free Software Foundation, Inc.\n+   Contributed by Dave Korn.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef LTO_COFF_H\n+#define LTO_COFF_H\n+\n+/* Rather than implementing a libcoff to match libelf, or attempting to\n+   integrate libbfd into GCC, this file is a self-contained (and very\n+   minimal) COFF format object file reader/writer.  The generated files\n+   will contain a COFF header, a number of COFF section headers, the \n+   section data itself, and a trailing string table for section names.  */\n+\n+/* Alignment of sections in a COFF object file.\n+\n+   The LTO writer uses zlib compression on the data that it streams into\n+   LTO sections in the output object file.  Because these streams don't\n+   have any embedded size information, the section in the object file must\n+   be exactly sized to the data emitted; any trailing padding bytes will\n+   be interpreted as partial and/or corrupt compressed data.\n+\n+   This is easy enough to do on COFF targets (with binutils 2.20.1 or\n+   above) because we can specify 1-byte alignment for the LTO sections.\n+   They are then emitted precisely-sized and byte-packed into the object\n+   and the reader is happy when it parses them later.  This is currently\n+   implemented in the x86/windows backed in i386_pe_asm_named_section()\n+   in config/i386/winnt.c by detecting the LTO section name prefix, \n+\n+   That would be sufficient, but for one thing.  At the start of the LTO\n+   data is a header struct with (currently) a couple of version numbers and\n+   some type info; see struct lto_header in lto-streamer.h.  If the sections\n+   are byte-packed, this header will not necessarily be correctly-aligned\n+   when it is read back into memory.\n+\n+   On x86 targets, which are currently the only LTO-COFF targets, misaligned\n+   memory accesses aren't problematic (okay, inefficient, but not worth\n+   worrying about two half-word memory reads per section in the context of\n+   everything else the compiler has to do at the time!), but RISC targets may\n+   fail on trying to access the header struct.  In this case, it will be\n+   necessary to enable (preferably in a target-dependent fashion, but a few\n+   bytes of padding are hardly an important issue if it comes down to it) the\n+   COFF_ALIGNMENT macros below.\n+\n+   As currently implemented, this will emit padding to the necessary number\n+   of bytes after each LTO section.  These bytes will constitute 'gaps' in\n+   the object file structure, as they won't be covered by any section header.\n+   This hasn't yet been tested, because no such RISC LTO-COFF target yet\n+   exists.  If it causes problems further down the toolchain, it will be\n+   necessary to adapt the code to emit additional section headers for these\n+   padding bytes, but the odds are that it will \"just work\".\n+\n+  */\n+\n+#if 0\n+#define COFF_ALIGNMENT\t (4)\n+#define COFF_ALIGNMENTM1 (COFF_ALIGNMENT - 1)\n+#define COFF_ALIGN(x)\t (((x) + COFF_ALIGNMENTM1) & ~COFF_ALIGNMENTM1)\n+#else\n+#define COFF_ALIGNMENT\t (1)\n+#define COFF_ALIGN(x)\t (x)\n+#endif\n+\n+/* COFF header machine codes.  */\n+\n+#define IMAGE_FILE_MACHINE_I386\t(0x014c)\n+\n+/* Known header magics for validation, as an array initialiser.  */\n+\n+#define COFF_KNOWN_MACHINES \\\n+  { IMAGE_FILE_MACHINE_I386/*, ... add more here when working.  */ }\n+\n+/* COFF object file header, section and symbol flags and types.  These are\n+   currently specific to PE-COFF, which is the only LTO-COFF format at the\n+   time of writing.  Maintainers adding support for new COFF formats will\n+   need to make these into target macros of some kind.  */\n+\n+/* COFF header characteristics.  */\n+\n+#define IMAGE_FILE_EXECUTABLE_IMAGE\t(1 << 1)\n+#define IMAGE_FILE_32BIT_MACHINE\t(1 << 8)\n+#define IMAGE_FILE_SYSTEM\t\t(1 << 12)\n+#define IMAGE_FILE_DLL\t\t\t(1 << 13)\n+\n+/* Desired characteristics (for validation).  */\n+\n+#define COFF_CHARACTERISTICS \\\n+  (IMAGE_FILE_32BIT_MACHINE)\n+\n+/* Unwanted characteristics (for validation).  */\n+\n+#define COFF_NOT_CHARACTERISTICS \\\n+  (IMAGE_FILE_EXECUTABLE_IMAGE | IMAGE_FILE_SYSTEM | IMAGE_FILE_DLL)\n+\n+/* Section flags.  LTO emits byte-aligned read-only loadable data sections.  */\n+\n+#define IMAGE_SCN_CNT_INITIALIZED_DATA\t (1 << 6)\n+#define IMAGE_SCN_CNT_UNINITIALIZED_DATA (1 << 7)\n+#define IMAGE_SCN_ALIGN_1BYTES\t\t (0x1 << 20)\n+#define IMAGE_SCN_MEM_DISCARDABLE\t (1 << 25)\n+#define\tIMAGE_SCN_MEM_SHARED\t\t (1 << 28)\n+#define IMAGE_SCN_MEM_READ\t\t (1 << 30)\n+\n+#define COFF_SECTION_CHARACTERISTICS \\\n+  (IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_ALIGN_1BYTES | \\\n+  IMAGE_SCN_MEM_DISCARDABLE | IMAGE_SCN_MEM_SHARED | IMAGE_SCN_MEM_READ)\n+\n+/* Symbol-related constants.  */\n+\n+#define IMAGE_SYM_DEBUG\t\t(-2)\n+#define IMAGE_SYM_TYPE_NULL\t(0)\n+#define IMAGE_SYM_DTYPE_NULL\t(0)\n+#define IMAGE_SYM_CLASS_STATIC\t(3)\n+#define IMAGE_SYM_CLASS_FILE\t(103)\n+\n+#define IMAGE_SYM_TYPE \\\n+  ((IMAGE_SYM_DTYPE_NULL << 4) | IMAGE_SYM_TYPE_NULL)\n+\n+/* Size of a COFF symbol in bytes.  */\n+\n+#define COFF_SYMBOL_SIZE\t(18)\n+\n+/* On-disk file structures.  */\n+\n+struct Coff_header\n+{\n+  unsigned char Machine[2];\n+  unsigned char NumberOfSections[2];\n+  unsigned char TimeDateStamp[4];\n+  unsigned char PointerToSymbolTable[4];\n+  unsigned char NumberOfSymbols[4];\n+  unsigned char SizeOfOptionalHeader[2];\n+  unsigned char Characteristics[2];\n+};\n+typedef struct Coff_header Coff_header;\n+\n+struct Coff_section\n+{\n+  unsigned char Name[8];\n+  unsigned char VirtualSize[4];\n+  unsigned char VirtualAddress[4];\n+  unsigned char SizeOfRawData[4];\n+  unsigned char PointerToRawData[4];\n+  unsigned char PointerToRelocations[4];\n+  unsigned char PointerToLinenumbers[4];\n+  unsigned char NumberOfRelocations[2];\n+  unsigned char NumberOfLinenumbers[2];\n+  unsigned char Characteristics[4];\n+};\n+typedef struct Coff_section Coff_section;\n+\n+struct Coff_symbol\n+{\n+  unsigned char Name[8];\n+  unsigned char Value[4];\n+  unsigned char SectionNumber[2];\n+  unsigned char Type[2];\n+  unsigned char StorageClass[1];\n+  unsigned char NumberOfAuxSymbols[1];\n+};\n+typedef struct Coff_symbol Coff_symbol;\n+\n+struct Coff_aux_sym_file\n+{\n+  unsigned char FileName[18];\n+};\n+typedef struct Coff_aux_sym_file Coff_aux_sym_file;\n+\n+struct Coff_aux_sym_section\n+{\n+  unsigned char Length[4];\n+  unsigned char NumberOfRelocations[2];\n+  unsigned char NumberOfLineNumbers[2];\n+  unsigned char Checksum[4];\n+  unsigned char Number[2];\n+  unsigned char Selection[1];\n+  unsigned char Unused[3];\n+};\n+typedef struct Coff_aux_sym_section Coff_aux_sym_section;\n+\n+/* Accessor macros for the above structures.  */\n+\n+#define COFF_GET(struc,memb) \\\n+  ((COFFENDIAN ? get_be : get_le) (&(struc)->memb[0], sizeof ((struc)->memb)))\n+\n+#define COFF_PUT(struc,memb,val) \\\n+  ((COFFENDIAN ? put_be : put_le) (&(struc)->memb[0], sizeof ((struc)->memb), val))\n+\n+#define COFF_PUT_NDXSZ(struc,memb,val,ndx,sz) \\\n+  ((COFFENDIAN ? put_be : put_le) (&(struc)->memb[ndx], sz, val))\n+\n+/* In-memory file structures.  */\n+\n+/* Forward declared structs.  */\n+\n+struct lto_coff_data;\n+struct lto_coff_section;\n+struct lto_coff_file;\n+\n+/* Section data in output files is made of these.  */\n+\n+struct lto_coff_data\n+{\n+  /* Pointer to data block.  */\n+  void *d_buf;\n+\n+  /* Size of data block.  */\n+  ssize_t d_size;\n+\n+  /* Next data block for this section.  */\n+  struct lto_coff_data *next;\n+};\n+typedef struct lto_coff_data lto_coff_data;\n+\n+/* This struct tracks the data for a section.  */\n+\n+struct lto_coff_section\n+{\n+  /* Singly-linked list of section's data blocks.  */\n+  lto_coff_data *data_chain;\n+\n+  /* Offset in string table of name.  */\n+  size_t strtab_offs;\n+\n+  /* Section type: 0 = real, 1 = dummy.  */\n+  size_t type;\n+\n+  /* Section name.  */\n+  const char *name;\n+\n+#if COFF_ALIGNMENT > 1\n+  /* Number of trailing padding bytes needed.  */\n+  ssize_t pad_needed;\n+#endif\n+\n+  /* Raw section header data.  */\n+  Coff_section coffsec;\n+\n+  /* Next section for this file.  */\n+  struct lto_coff_section *next;\n+};\n+typedef struct lto_coff_section lto_coff_section;\n+\n+/* A COFF file.  */\n+\n+struct lto_coff_file \n+{\n+  /* The base information.  */\n+  lto_file base;\n+\n+  /* Common file members:  */\n+\n+  /* The system file descriptor for the file.  */\n+  int fd;\n+\n+  /* The file's overall header.  */\n+  Coff_header coffhdr;\n+\n+  /* All sections in a singly-linked list.  */\n+  lto_coff_section *section_chain;\n+\n+  /* Readable file members:  */\n+\n+  /* File total size.  */\n+  off_t file_size;\n+\n+  /* String table file offset, relative to base.offset.  */\n+  off_t strtab_offs;\n+\n+  /* Writable file members:  */\n+\n+  /* The currently active section.  */\n+  lto_coff_section *scn;\n+\n+  /* The output stream for section header names.  */\n+  struct lto_output_stream *shstrtab_stream;\n+\n+  /* Linked list of data which must be freed *after* the file has been\n+     closed.  This is an annoying limitation of libelf.  Which has been\n+     faithfully reproduced here.  */\n+  struct lto_char_ptr_base *data;\n+};\n+typedef struct lto_coff_file lto_coff_file;\n+\n+/* Data hunk iterator.  */\n+\n+#define COFF_FOR_ALL_DATA(sec,var) \\\n+  for (var = sec->data_chain; var; var = var->next)\n+\n+/* Section list iterator.  */\n+\n+#define COFF_FOR_ALL_SECTIONS(file,var) \\\n+  for (var = file->section_chain; var; var = var->next)\n+\n+/* Very simple endian-ness layer.  */\n+\n+#ifndef COFFENDIAN\n+#define COFFENDIAN (BYTES_BIG_ENDIAN)\n+#endif\n+\n+static inline unsigned int\n+get_2_le (const unsigned char *ptr)\n+{\n+  return ptr[0] | (ptr[1] << 8);\n+}\n+\n+static inline unsigned int\n+get_4_le (const unsigned char *ptr)\n+{\n+  return ptr[0] | (ptr[1] << 8) | (ptr[2] << 16) | (ptr[3] << 24);\n+}\n+\n+static inline unsigned int\n+get_2_be (const unsigned char *ptr)\n+{\n+  return ptr[1] | (ptr[0] << 8);\n+}\n+\n+static inline unsigned int\n+get_4_be (const unsigned char *ptr)\n+{\n+  return ptr[3] | (ptr[2] << 8) | (ptr[1] << 16) | (ptr[0] << 24);\n+}\n+\n+static inline unsigned int\n+get_be (const unsigned char *ptr, size_t size)\n+{\n+  gcc_assert (size == 4 || size == 2);\n+  return (size == 2) ? get_2_be (ptr) : get_4_be (ptr);\n+}\n+\n+static inline unsigned int\n+get_le (const unsigned char *ptr, size_t size)\n+{\n+  gcc_assert (size == 4 || size == 2);\n+  return (size == 2) ? get_2_le (ptr) : get_4_le (ptr);\n+}\n+\n+static inline void\n+put_2_le (unsigned char *ptr, unsigned int data)\n+{\n+  ptr[0] = data & 0xff;\n+  ptr[1] = (data >> 8) & 0xff;\n+}\n+\n+static inline void\n+put_4_le (unsigned char *ptr, unsigned int data)\n+{\n+  ptr[0] = data & 0xff;\n+  ptr[1] = (data >> 8) & 0xff;\n+  ptr[2] = (data >> 16) & 0xff;\n+  ptr[3] = (data >> 24) & 0xff;\n+}\n+\n+static inline void\n+put_2_be (unsigned char *ptr, unsigned int data)\n+{\n+  ptr[1] = data & 0xff;\n+  ptr[0] = (data >> 8) & 0xff;\n+}\n+\n+static inline void\n+put_4_be (unsigned char *ptr, unsigned int data)\n+{\n+  ptr[3] = data & 0xff;\n+  ptr[2] = (data >> 8) & 0xff;\n+  ptr[1] = (data >> 16) & 0xff;\n+  ptr[0] = (data >> 24) & 0xff;\n+}\n+\n+static inline void\n+put_le (unsigned char *ptr, size_t size, unsigned int data)\n+{\n+  gcc_assert (size == 4 || size == 2);\n+  (void) (size == 2 ? put_2_le : put_4_le) (ptr, data);\n+}\n+\n+static inline void\n+put_be (unsigned char *ptr, size_t size, unsigned int data)\n+{\n+  gcc_assert (size == 4 || size == 2);\n+  (void) (size == 2 ? put_2_be : put_4_be) (ptr, data);\n+}\n+\n+/* We use this for putting the string table size.  */\n+\n+#define COFF_PUT4(ptr, data) \\\n+  ((COFFENDIAN ? put_4_be : put_4_le) (ptr, data))\n+\n+\n+#endif /* LTO_COFF_H */"}, {"sha": "a025895843b4604ab8843d9e983724df0b52bde0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bec79c52e613995dd3b07b119a67cd7ad3d72a8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bec79c52e613995dd3b07b119a67cd7ad3d72a8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3bec79c52e613995dd3b07b119a67cd7ad3d72a8", "patch": "@@ -1,3 +1,9 @@\n+2010-04-27  Dave Korn  <dave.korn.cygwin@gmail.com>\n+\n+\tPR lto/42776\n+\t* lib/lto.exp (lto_prune_vis_warns): New function.\n+\t(lto-link-and-maybe-run): Call it.\n+\n 2010-04-26  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR tree-optimization/43904"}, {"sha": "3d40efc32b906ecf09d235c43820015f3d4773d9", "filename": "gcc/testsuite/lib/lto.exp", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bec79c52e613995dd3b07b119a67cd7ad3d72a8/gcc%2Ftestsuite%2Flib%2Flto.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bec79c52e613995dd3b07b119a67cd7ad3d72a8/gcc%2Ftestsuite%2Flib%2Flto.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Flto.exp?ref=3bec79c52e613995dd3b07b119a67cd7ad3d72a8", "patch": "@@ -16,6 +16,19 @@\n \n # Contributed by Diego Novillo <dnovillo@google.com>\n \n+# Prune messages from gcc that aren't useful.\n+\n+proc lto_prune_vis_warns { text } {\n+\n+    # Many tests that use visibility will still pass on platforms that don't support it.\n+    regsub -all \"(^|\\n)\\[^\\n\\]*: warning: visibility attribute not supported in this configuration; ignored\\[^\\n\\]*\" $text \"\" text\n+\n+    # And any stray location lines.\n+    regsub -all \"(^|\\n)\\[^\\n\\]*: In function \\[^\\n\\]*\" $text \"\" text\n+    regsub -all \"(^|\\n)In file included from :\\[^\\n\\]*\" $text \"\" text\n+\n+    return $text\n+}\n \n # lto_init -- called at the start of each subdir of tests\n \n@@ -147,6 +160,10 @@ proc lto-link-and-maybe-run { testname objlist dest optall optfile optstr } {\n     # Link the objects into an executable.\n     set comp_output [${tool}_target_compile \"$objlist\" $dest executable \\\n \t\t     \"$options\"]\n+\n+    # Prune unimportant visibility warnings before checking output.\n+    set comp_output [lto_prune_vis_warns $comp_output]\n+\n     if ![${tool}_check_compile \"$testcase $testname link\" \"\" \\\n \t $dest $comp_output] then {\n \tunresolved \"$testcase $testname execute $optstr\""}]}