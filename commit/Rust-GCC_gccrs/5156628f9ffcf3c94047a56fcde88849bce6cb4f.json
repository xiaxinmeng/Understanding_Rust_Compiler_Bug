{"sha": "5156628f9ffcf3c94047a56fcde88849bce6cb4f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTE1NjYyOGY5ZmZjZjNjOTQwNDdhNTZmY2RlODg4NDliY2U2Y2I0Zg==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-09-30T21:34:04Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-09-30T21:34:04Z"}, "message": "89th Cygnus<->FSF quick merge\n\nFrom-SVN: r12883", "tree": {"sha": "7df90e2fe04ce0e37b684ebb2fa65e27a632aaa8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7df90e2fe04ce0e37b684ebb2fa65e27a632aaa8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5156628f9ffcf3c94047a56fcde88849bce6cb4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5156628f9ffcf3c94047a56fcde88849bce6cb4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5156628f9ffcf3c94047a56fcde88849bce6cb4f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5156628f9ffcf3c94047a56fcde88849bce6cb4f/comments", "author": null, "committer": null, "parents": [{"sha": "bf6103db43946957540b9153e988589ebdb23f63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf6103db43946957540b9153e988589ebdb23f63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf6103db43946957540b9153e988589ebdb23f63"}], "stats": {"total": 1706, "additions": 1417, "deletions": 289}, "files": [{"sha": "7a518d14f367b13ba726e43dc27b4a9f09a02320", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5156628f9ffcf3c94047a56fcde88849bce6cb4f", "patch": "@@ -1,3 +1,174 @@\n+Mon Sep 30 12:58:40 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* input.c (sub_getch): Handle 8-bit characters in string literals.\n+\n+Sun Sep 29 03:12:01 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* tree.c (mapcar): Handle CONSTRUCTORs.\n+\t(copy_to_permanent): Handle expression_obstack properly.\n+\n+\t* Make-lang.in (cplib2.txt): Also depend on the headers.\n+\n+\t* rtti.c (get_tinfo_var): Don't assume that POINTER_SIZE ==\n+ \tINT_TYPE_SIZE.\n+\t(expand_class_desc): Use USItype for offset field.\n+\t* tinfo.h (struct __class_type_info): Likewise.\n+\n+\t* method.c (build_overload_int): TYPE_PRECISION should be applied\n+ \tto types.\n+\n+Sat Sep 28 14:44:50 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* call.c (build_new_op): A COND_EXPR involving void must be a\n+\tbuiltin.\n+\n+Fri Sep 27 16:40:30 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* typeck.c (build_x_component_ref): New fn.\n+\t(build_object_ref): Use it.\n+\t* parse.y (primary): Use it.\n+\t* decl2.c (build_expr_from_tree): Use it.\n+\t* cp-tree.h: Declare it.\n+\n+\t* decl.c (start_decl): variable-sized arrays cannot be initialized.\n+\t* error.c (dump_type_suffix): Handle variable arrays.\n+\n+Fri Sep 27 13:14:05 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* Make-lang.in (exception.o): Put back compiling it with -fPIC.\n+\n+Fri Sep 27 03:00:09 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl.c (lookup_name_real): Don't try to look up anything in a\n+ \tTYPENAME_TYPE.\n+\n+\t* tinfo2.cc (__throw_type_match_rtti): Oops.\n+\n+Thu Sep 26 22:11:05 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* Make-lang.in (exception.o): Use -fno-PIC for now.\n+\n+Thu Sep 26 10:59:00 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* rtti.c (build_dynamic_cast): Pass tinfo fns rather than\n+ \tcalling them.\n+\t(get_tinfo_fn_dynamic): Extracted from build_typeid.\n+\t* tinfo2.cc (__dynamic_cast): Adjust.\n+\t\n+\t* rtti.c (build_typeid): Use resolves_to_fixed_type_p.\n+\t(build_x_typeid): Likewise.\n+\n+\t* parse.y: Call build_x_typeid instead of build_typeid.\n+\t* cp-tree.def: Add TYPEID_EXPR.\n+\t* pt.c (tsubst_copy): Handle typeid.\n+\t* decl2.c (build_expr_from_tree): Likewise.\n+\t* rtti.c (build_x_typeid): Throw bad_typeid from here.\n+\t(build_typeid): Not here.\n+\t* cp-tree.h: Declare build_x_typeid.\n+\n+Wed Sep 25 17:26:16 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* call.c (convert_like): Pull out constant values.\n+\n+\t* tree.c (mapcar): Use build_cplus_array_type, not build_array_type.\n+\n+Wed Sep 25 17:28:53 1996  Michael Meissner  <meissner@tiktok.cygnus.com>\n+\n+\t* decl.c (init_decl_processing): Create short int types before\n+\tcreating size_t in case a machine description needs to use\n+\tunsigned short for size_t.\n+\n+Tue Sep 24 18:18:44 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* Make-lang.in (exception.o): Turn off pic.\n+\n+\t* tinfo2.cc (__throw_type_match_rtti): Fix cv-variants of the same\n+\ttype, multi-level ptr conversions.\n+\n+\t* rtti.c (call_void_fn): Renamed and genericized from throw_bad_cast.\n+\t(throw_bad_cast): Use it.\n+\t(throw_bad_typeid): New fn.\n+\t(build_typeid): Throw bad_typeid as needed.\n+\tUse build_call.\n+\t(synthesize_tinfo_fn): Handle functions and arrays before checking\n+\tfor cv-quals.\n+\n+\t* Remove .h from standard C++ headers, add new.h, move into inc\n+ \tsubdirectory.\n+\n+\t* exception*: Remove pointer from object, constructors.  Add\n+ \tdefault exception::what that uses type_info::name.  Add\n+ \t__throw_bad_typeid.\n+\n+\t* init.c (build_new): Don't add a cookie to new (void *) T[2].\n+\n+Mon Sep 23 15:21:53 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* Make-lang.in: Building C++ code depends on cc1plus.\n+\n+Mon Sep 23 12:38:40 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* decl.c (struct saved_scope): Declare PROCESSING_TEMPLATE_DECL as\n+\ta HOST_WIDE_INT, not a tree.\n+\n+Mon Sep 23 12:36:02 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* exception.cc: Don't include <stdlib.h>.\n+\n+\t* Make-lang.in (c++.clean): Remove cplib2.*.\n+\n+Mon Sep 23 09:42:19 1996  Doug Evans  <dje@canuck.cygnus.com>\n+\n+\t* parse.y (component_decl_1, component_costructor_declarator case):\n+\tPass attributes/prefix_attributes in tree list.\n+\n+Mon Sep 23 01:18:50 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* tinfo{,2}.cc: #include <stddef.h> instead of <stdlib.h>.\n+\n+Sun Sep 22 05:31:22 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* lex.c (do_identifier): Don't do deferred lookup in a template\n+ \theader.\n+\n+\t* typeck2.c (store_init_value): Oops.\n+\n+\t* new.{h,cc}, exception.{h,cc}, typeinfo.h, tinfo{2.cc,.cc,.h}: \n+\tNew files for C++ lang-support library.\n+\t* Make-lang.in (CXX_EXTRA_HEADERS): Define.\n+\t(CXX_LIB2FUNCS): Define.\n+\tAnd rules for building the C++ lang-support code.\n+\t* config-lang.in (headers): Define.\n+\t(lib2funcs): Define.\n+\n+Sat Sep 21 19:17:28 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl2.c (build_expr_from_tree): If CONSTRUCTOR has a type, call\n+\tdigest_init.\n+\t* pt.c (tsubst_copy): Compute type for CONSTRUCTOR.\n+\t* typeck2.c (store_init_value): Check for initializing pmf with { }\n+\there.\n+\t(process_init_constructor): Not here.\n+\n+Thu Sep 19 16:41:07 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* pt.c (begin_template_parm_list): Increment\n+ \tprocessing_template_decl here.\n+\t(end_template_parm_list): Not here.\n+\t(process_template_parm): No need to add 1 to it now.\n+\t* *.c: Use processing_template_decl instead of current_template_parms\n+\tto check for being in a template.\n+\n+\t* pt.c (uses_template_parms): Handle SCOPE_REF.  Fix CONSTRUCTOR.\n+\t(tsubst_copy): Handle CONSTRUCTOR.\n+\t(instantiate_decl): Set up context properly for variables.\n+\t* decl2.c (build_expr_from_tree): Handle CONSTRUCTOR.\n+\t* class.c (finish_struct): Reverse CLASSTYPE_TAGS.\n+\n+Wed Sep 18 13:30:20 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* lex.c (enum tree_node_kind) [GATHER_STATISTICS]: Put the enum back.\n+\n Wed Sep 18 04:24:07 1996  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* method.c (make_thunk): Call comdat_linkage before setting the"}, {"sha": "f7265c961245fd041908e9fa4399125dcad998bf", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=5156628f9ffcf3c94047a56fcde88849bce6cb4f", "patch": "@@ -52,6 +52,15 @@ GXX_CROSS_NAME = `t='$(program_transform_cross_name)'; echo g++ | sed $$t`\n \n # The name to use for the demangler program.\n DEMANGLER_PROG = c++filt\n+\n+# Extra headers to install.\n+CXX_EXTRA_HEADERS = $(srcdir)/cp/inc/typeinfo $(srcdir)/cp/inc/exception \\\n+\t$(srcdir)/cp/inc/new $(srcdir)/cp/inc/new.h\n+\n+# Extra code to include in libgcc2.\n+CXX_LIB2FUNCS = tinfo.o tinfo2.o new.o exception.o\n+CXX_LIB2SRCS = $(srcdir)/cp/new.cc $(srcdir)/cp/exception.cc \\\n+\t$(srcdir)/cp/tinfo.cc $(srcdir)/cp/tinfo2.cc $(srcdir)/cp/tinfo.h\n \f\n # Define the names for selecting c++ in LANGUAGES.\n # Note that it would be nice to move the dependency on g++\n@@ -105,6 +114,46 @@ c++.rest.encap: $(DEMANGLER_PROG)\n \n c++.info:\n c++.dvi:\n+\n+# C++ language-support library pieces for libgcc.\n+tinfo.o: cc1plus $(srcdir)/cp/tinfo.cc\n+\t$(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) $(INCLUDES) \\\n+\t  -c $(srcdir)/cp/tinfo.cc\n+tinfo2.o: cc1plus $(srcdir)/cp/tinfo2.cc\n+\t$(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) $(INCLUDES) \\\n+\t  -c $(srcdir)/cp/tinfo2.cc\n+exception.o: cc1plus $(srcdir)/cp/exception.cc\n+\t$(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) $(INCLUDES) \\\n+\t  -c -O0 -fexceptions $(srcdir)/cp/exception.cc\n+new.o: cc1plus $(srcdir)/cp/new.cc\n+\t$(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) $(INCLUDES) \\\n+\t  -c $(srcdir)/cp/new.cc\n+\n+# We want to update cplib2.txt if any of the source files change...\n+cplib2.txt: $(CXX_LIB2SRCS) $(CXX_EXTRA_HEADERS) cplib2.ready\n+\tif [ -f cc1plus ]; then \\\n+\t  echo $(CXX_LIB2FUNCS) > cplib2.new; \\\n+\telse \\\n+\t  echo \"\" > cplib2.new; \\\n+\tfi\n+\tmv -f cplib2.new cplib2.txt \n+\n+# Or if it would be different.\n+cplib2.ready: $(GCC_PASSES) $(LIBGCC2_DEPS) stmp-int-hdrs\n+\t@if [ -r cplib2.txt ]; then \\\n+\t  if [ -f cc1plus ]; then \\\n+\t    echo $(CXX_LIB2FUNCS) > cplib2.new; \\\n+\t  else \\\n+\t    echo \"\" > cplib2.new; \\\n+\t  fi; \\\n+\t  if cmp -s cplib2.new cplib2.txt; then \\\n+\t    touch cplib2.ready; \\\n+\t  fi; \\\n+\t  rm -f cplib2.new; \\\n+\tfi\n+\t@if [ -f cplib2.ready ]; then true; else \\\n+\t  touch cplib2.ready; \\\n+\tfi\n \f\n # Install hooks:\n # cc1plus is installed elsewhere as part of $(COMPILERS).\n@@ -165,6 +214,7 @@ c++.uninstall:\n c++.mostlyclean:\n \t-rm -f cp/*$(objext) $(DEMANGLER_PROG)\n c++.clean:\n+\t-rm -f cplib2.txt cplib2.ready\n c++.distclean:\n \t-rm -f cp/config.status cp/Makefile\n \t-rm -f cp/parse.output"}, {"sha": "9ae201c93137ac7df299b2b80f2194d08fbe2532", "filename": "gcc/cp/call.c", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=5156628f9ffcf3c94047a56fcde88849bce6cb4f", "patch": "@@ -1410,7 +1410,7 @@ build_scoped_method_call (exp, basetype, name, parms)\n       || basetype == error_mark_node)\n     return error_mark_node;\n \n-  if (current_template_parms)\n+  if (processing_template_decl)\n     {\n       if (TREE_CODE (name) == BIT_NOT_EXPR)\n \t{\n@@ -1681,7 +1681,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n       || (instance != NULL_TREE && TREE_TYPE (instance) == error_mark_node))\n     return error_mark_node;\n \n-  if (current_template_parms)\n+  if (processing_template_decl)\n     {\n       if (TREE_CODE (name) == BIT_NOT_EXPR)\n \t{\n@@ -4545,9 +4545,16 @@ build_new_op (code, flags, arg1, arg2, arg3)\n   if (arg3 && TREE_CODE (arg3) == OFFSET_REF)\n     arg3 = resolve_offset_ref (arg3);\n \n-  if (! IS_OVERLOAD_TYPE (TREE_TYPE (arg1))\n-      && (! arg2 || ! IS_OVERLOAD_TYPE (TREE_TYPE (arg2)))\n-      && (! arg3 || ! IS_OVERLOAD_TYPE (TREE_TYPE (arg3))))\n+  if (code == COND_EXPR)\n+    {\n+      if (TREE_CODE (TREE_TYPE (arg2)) == VOID_TYPE\n+\t  || TREE_CODE (TREE_TYPE (arg3)) == VOID_TYPE\n+\t  || (! IS_OVERLOAD_TYPE (TREE_TYPE (arg2))\n+\t      && ! IS_OVERLOAD_TYPE (TREE_TYPE (arg3))))\n+\tgoto builtin;\n+    }\n+  else if (! IS_OVERLOAD_TYPE (TREE_TYPE (arg1))\n+\t   && (! arg2 || ! IS_OVERLOAD_TYPE (TREE_TYPE (arg2))))\n     goto builtin;\n \n   if (code == POSTINCREMENT_EXPR || code == POSTDECREMENT_EXPR)\n@@ -4871,6 +4878,8 @@ convert_like (convs, expr)\n     case IDENTITY_CONV:\n       if (type_unknown_p (expr))\n \texpr = instantiate_type (TREE_TYPE (convs), expr, 1);\n+      if (TREE_READONLY_DECL_P (expr))\n+\texpr = decl_constant_value (expr);\n       return expr;\n     case AMBIG_CONV:\n       /* Call build_user_type_conversion again for the error.  */"}, {"sha": "424c10cb87d1e5df472204c4c0ab50dde697a0f8", "filename": "gcc/cp/class.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=5156628f9ffcf3c94047a56fcde88849bce6cb4f", "patch": "@@ -4341,7 +4341,10 @@ finish_struct (t, list_of_fieldlists, attributes, warn_anon)\n      defined for this type.  */\n   if (CLASSTYPE_TAGS (t) || dummy)\n     {\n-      x = CLASSTYPE_TAGS (t);\n+      /* The list of tags was built up in pushtag in reverse order; we need\n+\t to fix that so that enumerators will be processed in forward order\n+\t in template instantiation.  */\n+      CLASSTYPE_TAGS (t) = x = nreverse (CLASSTYPE_TAGS (t));\n       while (x)\n \t{\n \t  tree tag = TYPE_NAME (TREE_VALUE (x));"}, {"sha": "66fe112519e51d6752c23d58de77123811cc6a2b", "filename": "gcc/cp/config-lang.in", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconfig-lang.in?ref=5156628f9ffcf3c94047a56fcde88849bce6cb4f", "patch": "@@ -33,3 +33,7 @@ compilers=\"cc1plus\\$(exeext)\"\n stagestuff=\"g++\\$(exeext) g++-cross\\$(exeext) cc1plus\\$(exeext)\"\n \n diff_excludes=\"-x cp/parse.c -x cp/parse.h\"\n+\n+headers='$(CXX_EXTRA_HEADERS)'\n+\n+lib2funcs=cplib2.txt"}, {"sha": "ab271ea63fde6c973d0e5276319985b0e4f86190", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=5156628f9ffcf3c94047a56fcde88849bce6cb4f", "patch": "@@ -120,6 +120,7 @@ DEFTREECODE (DYNAMIC_CAST_EXPR, \"dynamic_cast_expr\", \"1\", 1)\n DEFTREECODE (SIZEOF_EXPR, \"sizeof_expr\", \"1\", 1)\n DEFTREECODE (ARROW_EXPR, \"arrow_expr\", \"e\", 1)\n DEFTREECODE (DOTSTAR_EXPR, \"dotstar_expr\", \"e\", 2)\n+DEFTREECODE (TYPEID_EXPR, \"typeid_expr\", \"e\", 1)\n \n DEFTREECODE (EXPR_STMT, \"expr_stmt\", \"e\", 1)\n DEFTREECODE (COMPOUND_STMT, \"compound_stmt\", \"e\", 1)"}, {"sha": "0d5189f2139b7ac40430fb9e18b53325e26fba3c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=5156628f9ffcf3c94047a56fcde88849bce6cb4f", "patch": "@@ -2169,7 +2169,9 @@ extern void finish_repo\t\t\t\tPROTO((void));\n \n /* in rtti.c */\n extern tree get_tinfo_fn\t\t\tPROTO((tree));\n+extern tree get_tinfo_fn_dynamic\t\tPROTO((tree));\n extern tree build_typeid\t\t\tPROTO((tree));\n+extern tree build_x_typeid\t\t\tPROTO((tree));\n extern tree get_typeid\t\t\t\tPROTO((tree));\n extern tree build_dynamic_cast\t\t\tPROTO((tree, tree));\n \n@@ -2454,6 +2456,7 @@ extern tree default_conversion\t\t\tPROTO((tree));\n extern tree build_object_ref\t\t\tPROTO((tree, tree, tree));\n extern tree build_component_ref_1\t\tPROTO((tree, tree, int));\n extern tree build_component_ref\t\t\tPROTO((tree, tree, tree, int));\n+extern tree build_x_component_ref\t\tPROTO((tree, tree, tree, int));\n extern tree build_x_indirect_ref\t\tPROTO((tree, char *));\n extern tree build_indirect_ref\t\t\tPROTO((tree, char *));\n extern tree build_x_array_ref\t\t\tPROTO((tree, tree));"}, {"sha": "245d521cf6461e4aff8cc2f48b170aa1759b678b", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 73, "deletions": 52, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=5156628f9ffcf3c94047a56fcde88849bce6cb4f", "patch": "@@ -1773,6 +1773,7 @@ struct saved_scope {\n   int minimal_parse_mode;\n   tree last_function_parms;\n   tree template_parms;\n+  HOST_WIDE_INT processing_template_decl;\n   tree previous_class_type, previous_class_values;\n };\n static struct saved_scope *current_saved_scope;\n@@ -1869,6 +1870,7 @@ maybe_push_to_top_level (pseudo)\n   s->minimal_parse_mode = minimal_parse_mode;\n   s->last_function_parms = last_function_parms;\n   s->template_parms = current_template_parms;\n+  s->processing_template_decl = processing_template_decl;\n   s->previous_class_type = previous_class_type;\n   s->previous_class_values = previous_class_values;\n \n@@ -1884,7 +1886,10 @@ maybe_push_to_top_level (pseudo)\n   minimal_parse_mode = 0;\n   previous_class_type = previous_class_values = NULL_TREE;\n   if (!pseudo)\n-    current_template_parms = NULL_TREE;\n+    {\n+      current_template_parms = NULL_TREE;\n+      processing_template_decl = 0;\n+    }\n \n   s->prev = current_saved_scope;\n   s->old_bindings = old_bindings;\n@@ -1943,6 +1948,7 @@ pop_from_top_level ()\n   minimal_parse_mode = s->minimal_parse_mode;\n   last_function_parms = s->last_function_parms;\n   current_template_parms = s->template_parms;\n+  processing_template_decl = s->processing_template_decl;\n   previous_class_type = s->previous_class_type;\n   previous_class_values = s->previous_class_values;\n \n@@ -2078,7 +2084,7 @@ pushtag (name, type, globalize)\n \n \t      TYPE_NAME (type) = d;\n \t      DECL_CONTEXT (d) = context;\n-\t      if (! globalize && current_template_parms && IS_AGGR_TYPE (type))\n+\t      if (! globalize && processing_template_decl && IS_AGGR_TYPE (type))\n \t\tpush_template_decl (d);\n \n \t      /* If it is anonymous, then we are called from pushdecl,\n@@ -2110,7 +2116,7 @@ pushtag (name, type, globalize)\n \n \t      TYPE_MAIN_DECL (type) = d;\n \t      DECL_CONTEXT (d) = context;\n-\t      if (! globalize && current_template_parms && IS_AGGR_TYPE (type))\n+\t      if (! globalize && processing_template_decl && IS_AGGR_TYPE (type))\n \t\tpush_template_decl (d);\n \n \t      d = pushdecl_class_level (d);\n@@ -2723,15 +2729,15 @@ duplicate_decls (newdecl, olddecl)\n       /* Lay the type out, unless already done.  */\n       if (oldtype != TREE_TYPE (newdecl)\n \t  && TREE_TYPE (newdecl) != error_mark_node\n-\t  && !(current_template_parms && uses_template_parms (newdecl)))\n+\t  && !(processing_template_decl && uses_template_parms (newdecl)))\n \tlayout_type (TREE_TYPE (newdecl));\n \n       if ((TREE_CODE (newdecl) == VAR_DECL\n \t   || TREE_CODE (newdecl) == PARM_DECL\n \t   || TREE_CODE (newdecl) == RESULT_DECL\n \t   || TREE_CODE (newdecl) == FIELD_DECL\n \t   || TREE_CODE (newdecl) == TYPE_DECL)\n-\t  && !(current_template_parms && uses_template_parms (newdecl)))\n+\t  && !(processing_template_decl && uses_template_parms (newdecl)))\n \tlayout_decl (newdecl, 0);\n \n       /* Merge the type qualifiers.  */\n@@ -4312,7 +4318,7 @@ make_typename_type (context, name)\n   else if (TREE_CODE (name) != IDENTIFIER_NODE)\n     my_friendly_abort (2000);\n \n-  if (! current_template_parms\n+  if (! processing_template_decl\n       || ! uses_template_parms (context)\n       || context == current_class_type)\n     {\n@@ -4325,11 +4331,11 @@ make_typename_type (context, name)\n       return TREE_TYPE (t);\n     }\n \n-  if (current_template_parms)\n+  if (processing_template_decl)\n     push_obstacks (&permanent_obstack, &permanent_obstack);\n   t = make_lang_type (TYPENAME_TYPE);\n   d = build_decl (TYPE_DECL, name, t);\n-  if (current_template_parms)\n+  if (processing_template_decl)\n     pop_obstacks ();\n \n   TYPE_CONTEXT (t) = context;\n@@ -4389,7 +4395,8 @@ lookup_name_real (name, prefer_type, nonclass)\n \t      val = lookup_namespace_name (type, name);\n \t    }\n \t  else if (! IS_AGGR_TYPE (type)\n-\t\t   || TREE_CODE (type) == TEMPLATE_TYPE_PARM)\n+\t\t   || TREE_CODE (type) == TEMPLATE_TYPE_PARM\n+\t\t   || TREE_CODE (type) == TYPENAME_TYPE)\n \t    /* Someone else will give an error about this if needed.  */\n \t    val = NULL_TREE;\n \t  else if (TYPE_BEING_DEFINED (type))\n@@ -4421,7 +4428,7 @@ lookup_name_real (name, prefer_type, nonclass)\n \tval = NULL_TREE;\n \n #if 1\n-      if (got_scope && current_template_parms\n+      if (got_scope && processing_template_decl\n \t  && got_scope != current_class_type\n \t  && uses_template_parms (got_scope)\n \t  && val && TREE_CODE (val) == TYPE_DECL\n@@ -4805,6 +4812,12 @@ init_decl_processing ()\n   record_builtin_type (RID_MAX, \"long long unsigned\",\n \t\t       long_long_unsigned_type_node);\n \n+  short_integer_type_node = make_signed_type (SHORT_TYPE_SIZE);\n+  record_builtin_type (RID_SHORT, \"short int\", short_integer_type_node);\n+  short_unsigned_type_node = make_unsigned_type (SHORT_TYPE_SIZE);\n+  record_builtin_type (RID_MAX, \"short unsigned int\", short_unsigned_type_node);\n+  record_builtin_type (RID_MAX, \"unsigned short\", short_unsigned_type_node);\n+\n   /* `unsigned long' is the standard type for sizeof.\n      Traditionally, use a signed type.\n      Note that stddef.h uses `unsigned long',\n@@ -4824,12 +4837,8 @@ init_decl_processing ()\n   TREE_TYPE (TYPE_SIZE (long_integer_type_node)) = sizetype;\n   TREE_TYPE (TYPE_SIZE (long_long_integer_type_node)) = sizetype;\n   TREE_TYPE (TYPE_SIZE (long_long_unsigned_type_node)) = sizetype;\n-\n-  short_integer_type_node = make_signed_type (SHORT_TYPE_SIZE);\n-  record_builtin_type (RID_SHORT, \"short int\", short_integer_type_node);\n-  short_unsigned_type_node = make_unsigned_type (SHORT_TYPE_SIZE);\n-  record_builtin_type (RID_MAX, \"short unsigned int\", short_unsigned_type_node);\n-  record_builtin_type (RID_MAX, \"unsigned short\", short_unsigned_type_node);\n+  TREE_TYPE (TYPE_SIZE (short_integer_type_node)) = sizetype;\n+  TREE_TYPE (TYPE_SIZE (short_unsigned_type_node)) = sizetype;\n \n   /* Define both `signed char' and `unsigned char'.  */\n   signed_char_type_node = make_signed_type (CHAR_TYPE_SIZE);\n@@ -5646,7 +5655,7 @@ shadow_tag (declspecs)\n \t\t  && TYPE_SIZE (value) == NULL_TREE)\n \t\t{\n \t\t  SET_CLASSTYPE_TEMPLATE_SPECIALIZATION (value);\n-\t\t  if (current_template_parms)\n+\t\t  if (processing_template_decl)\n \t\t    push_template_decl (TYPE_MAIN_DECL (value));\n \t\t}\n \t      else if (CLASSTYPE_TEMPLATE_INSTANTIATION (value))\n@@ -5782,7 +5791,7 @@ start_decl (declarator, declspecs, initialized)\n   type = TREE_TYPE (decl);\n \n   /* Don't lose if destructors must be executed at file-level.  */\n-  if (! current_template_parms && TREE_STATIC (decl)\n+  if (! processing_template_decl && TREE_STATIC (decl)\n       && TYPE_NEEDS_DESTRUCTOR (complete_type (type))\n       && !TREE_PERMANENT (decl))\n     {\n@@ -5829,11 +5838,23 @@ start_decl (declarator, declspecs, initialized)\n \tbreak;\n \n       default:\n-\tif (TREE_CODE (type) == ARRAY_TYPE && ! current_template_parms\n-\t    && TYPE_SIZE (complete_type (TREE_TYPE (type))) == NULL_TREE)\n+\tif (! processing_template_decl)\n \t  {\n-\t    cp_error (\"elements of array `%#D' have incomplete type\", decl);\n-\t    initialized = 0;\n+\t    if (TYPE_SIZE (type) != NULL_TREE\n+\t\t&& ! TREE_CONSTANT (TYPE_SIZE (type)))\n+\t      {\n+\t\tcp_error\n+\t\t  (\"variable-sized object `%D' may not be initialized\", decl);\n+\t\tinitialized = 0;\n+\t      }\n+\n+\t    if (TREE_CODE (type) == ARRAY_TYPE\n+\t\t&& TYPE_SIZE (complete_type (TREE_TYPE (type))) == NULL_TREE)\n+\t      {\n+\t\tcp_error\n+\t\t  (\"elements of array `%#D' have incomplete type\", decl);\n+\t\tinitialized = 0;\n+\t      }\n \t  }\n       }\n \n@@ -5901,7 +5922,7 @@ start_decl (declarator, declspecs, initialized)\n   else\n     tem = pushdecl (decl);\n \n-  if (current_template_parms)\n+  if (processing_template_decl)\n     {\n       if (! current_function_decl)\n \tpush_template_decl (tem);\n@@ -5922,7 +5943,7 @@ start_decl (declarator, declspecs, initialized)\n   DECL_COMMON (tem) = flag_conserve_space || ! TREE_PUBLIC (tem);\n #endif\n \n-  if (! current_template_parms)\n+  if (! processing_template_decl)\n     start_decl_1 (tem);\n \n   /* Corresponding pop_obstacks is done in `cp_finish_decl'.  */\n@@ -5942,7 +5963,7 @@ start_decl (declarator, declspecs, initialized)\n \t use temporary storage.  Do this even if we will ignore the value.  */\n       if (toplevel_bindings_p () && debug_temp_inits)\n \t{\n-\t  if (current_template_parms\n+\t  if (processing_template_decl\n \t      || TYPE_NEEDS_CONSTRUCTING (type)\n \t      || TREE_CODE (type) == REFERENCE_TYPE)\n \t    /* In this case, the initializer must lay down in permanent\n@@ -6002,7 +6023,7 @@ start_decl_1 (decl)\n       && TREE_CODE (decl) != TEMPLATE_DECL\n       && IS_AGGR_TYPE (type) && ! DECL_EXTERNAL (decl))\n     {\n-      if ((! current_template_parms || ! uses_template_parms (type))\n+      if ((! processing_template_decl || ! uses_template_parms (type))\n \t  && TYPE_SIZE (complete_type (type)) == NULL_TREE)\n \t{\n \t  cp_error (\"aggregate `%#D' has incomplete type and cannot be initialized\",\n@@ -6228,7 +6249,7 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n       return;\n     }\n \n-  if (current_template_parms)\n+  if (processing_template_decl)\n     {\n       if (init && DECL_INITIAL (decl))\n \tDECL_INITIAL (decl) = init;\n@@ -6796,7 +6817,7 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n   /* If requested, warn about definitions of large data objects.  */\n \n   if (warn_larger_than\n-      && ! current_template_parms\n+      && ! processing_template_decl\n       && (TREE_CODE (decl) == VAR_DECL || TREE_CODE (decl) == PARM_DECL)\n       && !DECL_EXTERNAL (decl))\n     {\n@@ -8393,7 +8414,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \n \t\t/* If this involves a template parameter, it'll be\n \t\t   constant, but we don't know what the value is yet.  */\n-\t\tif (current_template_parms)\n+\t\tif (processing_template_decl)\n \t\t  {\n \t\t    itype = make_node (INTEGER_TYPE);\n \t\t    TYPE_MIN_VALUE (itype) = size_zero_node;\n@@ -9481,7 +9502,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t      }\n \n \t    if (current_lang_name == lang_name_cplusplus\n-\t\t&& ! current_template_parms\n+\t\t&& ! processing_template_decl\n \t\t&& ! (IDENTIFIER_LENGTH (original_name) == 4\n \t\t      && IDENTIFIER_POINTER (original_name)[0] == 'm'\n \t\t      && strcmp (IDENTIFIER_POINTER (original_name), \"main\") == 0)\n@@ -9873,7 +9894,7 @@ grokparms (first_parm, funcdef_flag)\n \t\t      any_init++;\n \t\t      if (TREE_CODE (init) == SAVE_EXPR)\n \t\t\tPARM_DECL_EXPR (init) = 1;\n-\t\t      else if (current_template_parms)\n+\t\t      else if (processing_template_decl)\n \t\t\t;\n \t\t      else if (TREE_CODE (init) == VAR_DECL\n \t\t\t       || TREE_CODE (init) == PARM_DECL)\n@@ -9893,7 +9914,7 @@ grokparms (first_parm, funcdef_flag)\n \t\t\t}\n \t\t      else\n \t\t\tinit = require_instantiated_type (type, init, integer_zero_node);\n-\t\t      if (! current_template_parms\n+\t\t      if (! processing_template_decl\n \t\t\t  && ! can_convert_arg (type, TREE_TYPE (init), init))\n \t\t\tcp_pedwarn (\"invalid type `%T' for default argument to `%#D'\",\n \t\t\t\t    TREE_TYPE (init), decl);\n@@ -10229,7 +10250,7 @@ grok_op_properties (decl, virtualp, friendp)\n \t    {\n \t      if ((name == ansi_opname[(int) POSTINCREMENT_EXPR]\n \t\t   || name == ansi_opname[(int) POSTDECREMENT_EXPR])\n-\t\t  && ! current_template_parms\n+\t\t  && ! processing_template_decl\n \t\t  && TREE_VALUE (TREE_CHAIN (argtypes)) != integer_type_node)\n \t\t{\n \t\t  if (methodp)\n@@ -10688,7 +10709,7 @@ finish_enum (enumtype, values)\n       register tree pair;\n       register tree value = DECL_INITIAL (TREE_VALUE (values));\n \n-      if (! current_template_parms)\n+      if (! processing_template_decl)\n \t{\n \t  /* Speed up the main loop by performing some precalculations */\n \t  TREE_TYPE (TREE_VALUE (values)) = enumtype;\n@@ -10700,7 +10721,7 @@ finish_enum (enumtype, values)\n       for (pair = TREE_CHAIN (values); pair; pair = TREE_CHAIN (pair))\n \t{\n \t  value = DECL_INITIAL (TREE_VALUE (pair));\n-\t  if (! current_template_parms)\n+\t  if (! processing_template_decl)\n \t    {\n \t      TREE_TYPE (TREE_VALUE (pair)) = enumtype;\n \t      TREE_TYPE (value) = enumtype;\n@@ -10717,7 +10738,7 @@ finish_enum (enumtype, values)\n \n   TYPE_VALUES (enumtype) = values;\n \n-  if (current_template_parms)\n+  if (processing_template_decl)\n     return enumtype;\n \n   {\n@@ -10786,7 +10807,7 @@ build_enumerator (name, value)\n   if (value)\n     STRIP_TYPE_NOPS (value);\n \n- if (! current_template_parms)\n+ if (! processing_template_decl)\n    {\n      /* Validate and default VALUE.  */\n      if (value != NULL_TREE)\n@@ -10807,7 +10828,7 @@ build_enumerator (name, value)\n        }\n \n      /* Default based on previous value.  */\n-     if (value == NULL_TREE && ! current_template_parms)\n+     if (value == NULL_TREE && ! processing_template_decl)\n        {\n \t value = enum_next_value;\n \t if (enum_overflow)\n@@ -10849,7 +10870,7 @@ build_enumerator (name, value)\n       GNU_xref_decl (current_function_decl, decl);\n     }\n \n- if (! current_template_parms)\n+ if (! processing_template_decl)\n    {\n      /* Set basis for default for next value.  */\n      enum_next_value = build_binary_op_nodefault (PLUS_EXPR, value,\n@@ -11059,7 +11080,7 @@ start_function (declspecs, declarator, attrs, pre_parsed_p)\n \n   announce_function (decl1);\n \n-  if (! current_template_parms)\n+  if (! processing_template_decl)\n     {\n       if (TYPE_SIZE (complete_type (TREE_TYPE (fntype))) == NULL_TREE)\n \t{\n@@ -11105,7 +11126,7 @@ start_function (declspecs, declarator, attrs, pre_parsed_p)\n      If we already have a decl for this name, and it is a FUNCTION_DECL,\n      use the old decl.  */\n \n-  if (current_template_parms)\n+  if (processing_template_decl)\n     push_template_decl (decl1);\n   else if (pre_parsed_p == 0)\n     {\n@@ -11129,7 +11150,7 @@ start_function (declspecs, declarator, attrs, pre_parsed_p)\n \t       || flag_alt_external_templates))\n     {\n       if (DECL_THIS_INLINE (decl1) || DECL_TEMPLATE_INSTANTIATION (decl1)\n-\t  || current_template_parms)\n+\t  || processing_template_decl)\n \tDECL_EXTERNAL (decl1)\n \t  = (interface_only\n \t     || (DECL_THIS_INLINE (decl1) && ! flag_implement_inlines));\n@@ -11246,7 +11267,7 @@ start_function (declspecs, declarator, attrs, pre_parsed_p)\n        of this function only.  Tiemann moved up here from bottom of fn.  */\n     temporary_allocation ();\n \n-  if (current_template_parms)\n+  if (processing_template_decl)\n     {\n       extern tree last_tree;\n       ++minimal_parse_mode;\n@@ -11395,7 +11416,7 @@ store_parm_decls ()\n \n \t\t  pushdecl (parm);\n \t\t}\n-\t      if (! current_template_parms\n+\t      if (! processing_template_decl\n \t\t  && (cleanup = maybe_build_cleanup (parm), cleanup))\n \t\t{\n \t\t  expand_decl (parm);\n@@ -11433,7 +11454,7 @@ store_parm_decls ()\n \n   /* Initialize the RTL code for the function.  */\n   DECL_SAVED_INSNS (fndecl) = NULL_RTX;\n-  if (! current_template_parms)\n+  if (! processing_template_decl)\n     expand_function_start (fndecl, parms_have_cleanups);\n \n   /* Create a binding contour which can be used to catch\n@@ -11458,7 +11479,7 @@ store_parm_decls ()\n     }\n \n   /* Take care of exception handling things. */\n-  if (! current_template_parms && flag_exceptions)\n+  if (! processing_template_decl && flag_exceptions)\n     {\n       rtx insns;\n       start_sequence ();\n@@ -11589,7 +11610,7 @@ finish_function (lineno, call_poplevel, nested)\n       store_parm_decls ();\n     }\n \n-  if (current_template_parms)\n+  if (processing_template_decl)\n     {\n       if (DECL_CONSTRUCTOR_P (fndecl) && call_poplevel)\n \t{\n@@ -12017,7 +12038,7 @@ finish_function (lineno, call_poplevel, nested)\n      to the FUNCTION_DECL node itself.  */\n   BLOCK_SUPERCONTEXT (DECL_INITIAL (fndecl)) = fndecl;\n \n-  if (! current_template_parms)\n+  if (! processing_template_decl)\n     {\n       /* So we can tell if jump_optimize sets it to 1.  */\n       can_reach_end = 0;\n@@ -12070,7 +12091,7 @@ finish_function (lineno, call_poplevel, nested)\n   /* Free all the tree nodes making up this function.  */\n   /* Switch back to allocating nodes permanently\n      until we start another function.  */\n-  if (current_template_parms)\n+  if (processing_template_decl)\n     {\n       --minimal_parse_mode;\n       DECL_SAVED_TREE (fndecl) = TREE_CHAIN (DECL_SAVED_TREE (fndecl));\n@@ -12086,7 +12107,7 @@ finish_function (lineno, call_poplevel, nested)\n \t was an actual function definition.  */\n       DECL_INITIAL (fndecl) = error_mark_node;\n       /* And we need the arguments for template instantiation.  */\n-      if (! current_template_parms)\n+      if (! processing_template_decl)\n \t{\n \t  if (! DECL_CONSTRUCTOR_P (fndecl)\n \t      || !(TYPE_USES_VIRTUAL_BASECLASSES\n@@ -12178,7 +12199,7 @@ start_method (declspecs, declarator)\n   if (flag_default_inline)\n     DECL_INLINE (fndecl) = 1;\n \n-  if (current_template_parms && ! current_function_decl)\n+  if (processing_template_decl && ! current_function_decl)\n     push_template_decl (fndecl);\n \n   /* We read in the parameters on the maybepermanent_obstack,\n@@ -12437,7 +12458,7 @@ cplus_expand_expr_stmt (exp)\n   push_temp_slots ();\n   target_temp_slot_level = temp_slot_level;\n \n-  if (current_template_parms)\n+  if (processing_template_decl)\n     {\n       add_tree (build_min_nt (EXPR_STMT, exp));\n       return;"}, {"sha": "2a26a59a8f5f958c2bf5b8f854502007f9a34a7f", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=5156628f9ffcf3c94047a56fcde88849bce6cb4f", "patch": "@@ -1053,7 +1053,7 @@ grok_array_decl (array_expr, index_exp)\n \n   if (type == error_mark_node || index_exp == error_mark_node)\n     return error_mark_node;\n-  if (current_template_parms)\n+  if (processing_template_decl)\n     return build_min (ARRAY_REF, type ? TREE_TYPE (type) : NULL_TREE,\n \t\t      array_expr, index_exp);\n \n@@ -1133,7 +1133,7 @@ delete_sanity (exp, size, doing_vec, use_global_delete)\n   if (exp == error_mark_node)\n     return exp;\n \n-  if (current_template_parms)\n+  if (processing_template_decl)\n     {\n       t = build_min (DELETE_EXPR, void_type_node, exp, size);\n       DELETE_EXPR_USE_GLOBAL (t) = use_global_delete;\n@@ -1455,7 +1455,7 @@ grokfield (declarator, declspecs, init, asmspec_tree, attrlist)\n \t       because `decl_const_value' would mis-interpret it\n \t       as only meaning that this VAR_DECL is defined.  */\n \t    init = build1 (NOP_EXPR, TREE_TYPE (value), init);\n-\t  else if (current_template_parms)\n+\t  else if (processing_template_decl)\n \t    ;\n \t  else if (! TREE_CONSTANT (init))\n \t    {\n@@ -1476,7 +1476,7 @@ grokfield (declarator, declspecs, init, asmspec_tree, attrlist)\n   /* The corresponding pop_obstacks is in cp_finish_decl.  */\n   push_obstacks_nochange ();\n \n-  if (current_template_parms && ! current_function_decl\n+  if (processing_template_decl && ! current_function_decl\n       && (TREE_CODE (value) == VAR_DECL || TREE_CODE (value) == FUNCTION_DECL))\n     push_template_decl (value);\n \n@@ -1500,7 +1500,7 @@ grokfield (declarator, declspecs, init, asmspec_tree, attrlist)\n \t      DECL_ASSEMBLER_NAME (value)\n \t\t= build_static_name (current_class_type, DECL_NAME (value));\n \t    }\n-\t  if (! current_template_parms)\n+\t  if (! processing_template_decl)\n \t    pending_statics = perm_tree_cons (NULL_TREE, value, pending_statics);\n \n \t  /* Static consts need not be initialized in the class definition.  */\n@@ -1839,7 +1839,7 @@ setup_vtbl_ptr ()\n   if (base_init_expr == 0\n       && DECL_CONSTRUCTOR_P (current_function_decl))\n     {\n-      if (current_template_parms)\n+      if (processing_template_decl)\n \tadd_tree (build_min_nt\n \t\t  (CTOR_INITIALIZER,\n \t\t   current_member_init_list, current_base_init_list));\n@@ -3412,13 +3412,26 @@ build_expr_from_tree (t)\n       }\n \n     case COMPONENT_REF:\n-      return build_component_ref\n+      return build_x_component_ref\n \t(build_expr_from_tree (TREE_OPERAND (t, 0)),\n \t TREE_OPERAND (t, 1), NULL_TREE, 1);\n \n     case THROW_EXPR:\n       return build_throw (build_expr_from_tree (TREE_OPERAND (t, 0)));\n \n+    case CONSTRUCTOR:\n+      {\n+\ttree r = build_nt (CONSTRUCTOR, NULL_TREE,\n+\t\t\t   build_expr_from_tree (CONSTRUCTOR_ELTS (t)));\n+\n+\tif (TREE_TYPE (t))\n+\t  return digest_init (TREE_TYPE (t), r, 0);\n+\treturn r;\n+      }\n+\n+    case TYPEID_EXPR:\n+      return build_x_typeid (build_expr_from_tree (TREE_OPERAND (t, 0)));\n+\n     default:\n       return t;\n     }\n@@ -3629,7 +3642,7 @@ mark_used (decl)\n      tree decl;\n {\n   TREE_USED (decl) = 1;\n-  if (current_template_parms)\n+  if (processing_template_decl)\n     return;\n   assemble_external (decl);\n   /* Is it a synthesized method that needs to be synthesized?  */"}, {"sha": "80eb8e9c33c8ba1313c41654bef796bf8893fc8d", "filename": "gcc/cp/error.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=5156628f9ffcf3c94047a56fcde88849bce6cb4f", "patch": "@@ -487,7 +487,16 @@ dump_type_suffix (t, v)\n     case ARRAY_TYPE:\n       OB_PUTC ('[');\n       if (TYPE_DOMAIN (t))\n-\tOB_PUTI (TREE_INT_CST_LOW (TYPE_MAX_VALUE (TYPE_DOMAIN (t))) + 1);\n+\t{\n+\t  if (TREE_CODE (TYPE_MAX_VALUE (TYPE_DOMAIN (t))) == INTEGER_CST)\n+\t    OB_PUTI (TREE_INT_CST_LOW (TYPE_MAX_VALUE (TYPE_DOMAIN (t))) + 1);\n+\t  else if (TREE_CODE (TYPE_MAX_VALUE (TYPE_DOMAIN (t))) == MINUS_EXPR)\n+\t    dump_expr (TREE_OPERAND (TYPE_MAX_VALUE (TYPE_DOMAIN (t)), 0), 0);\n+\t  else\n+\t    dump_expr (fold (build_binary_op\n+\t\t\t     (PLUS_EXPR, TYPE_MAX_VALUE (TYPE_DOMAIN (t)),\n+\t\t\t      integer_one_node, 1)), 0);\n+\t}\n       OB_PUTC (']');\n       dump_type_suffix (TREE_TYPE (t), v);\n       break;"}, {"sha": "fefcd021f6bf054abc94665709b09385f62f6e59", "filename": "gcc/cp/except.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=5156628f9ffcf3c94047a56fcde88849bce6cb4f", "patch": "@@ -1132,7 +1132,7 @@ build_throw (e)\n {\n   if (e != error_mark_node)\n     {\n-      if (current_template_parms)\n+      if (processing_template_decl)\n \treturn build_min (THROW_EXPR, void_type_node, e);\n       e = build1 (THROW_EXPR, void_type_node, e);\n       TREE_SIDE_EFFECTS (e) = 1;"}, {"sha": "8cf227a719a4be22e383d7bfd4bd8b7c31c8b687", "filename": "gcc/cp/exception.cc", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Fexception.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Fexception.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexception.cc?ref=5156628f9ffcf3c94047a56fcde88849bce6cb4f", "patch": "@@ -0,0 +1,111 @@\n+// Functions for Exception Support for -*- C++ -*-\n+// Copyright (C) 1994, 1995, 1996 Free Software Foundation\n+\n+// This file is part of GNU CC.\n+\n+// GNU CC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// GNU CC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GNU CC; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330,\n+// Boston, MA 02111-1307, USA. \n+\n+// As a special exception, if you link this library with other files,\n+// some of which are compiled with GCC, to produce an executable,\n+// this library does not by itself cause the resulting executable\n+// to be covered by the GNU General Public License.\n+// This exception does not however invalidate any other reasons why\n+// the executable file might be covered by the GNU General Public License.\n+\n+#pragma implementation \"exception\"\n+\n+#include \"typeinfo\"\n+#include \"exception\"\n+\n+/* terminate (), unexpected (), set_terminate (), set_unexpected () as\n+   well as the default terminate func and default unexpected func */\n+\n+void\n+__default_terminate ()\n+{\n+  abort ();\n+}\n+\n+void\n+__default_unexpected ()\n+{\n+  __default_terminate ();\n+}\n+\n+static terminate_handler __terminate_func = __default_terminate;\n+static unexpected_handler __unexpected_func = __default_unexpected;\n+\n+terminate_handler\n+set_terminate (terminate_handler func)\n+{\n+  terminate_handler old = __terminate_func;\n+\n+  __terminate_func = func;\n+  return old;\n+}\n+\n+unexpected_handler\n+set_unexpected (unexpected_handler func)\n+{\n+  unexpected_handler old = __unexpected_func;\n+\n+  __unexpected_func = func;\n+  return old;\n+}\n+\n+void\n+terminate ()\n+{\n+  __terminate_func ();\n+}\n+\n+void\n+unexpected ()\n+{\n+  __unexpected_func ();\n+}\n+\n+extern \"C\" void\n+__throw_bad_cast (void)\n+{\n+  throw bad_cast ();\n+}\n+\n+extern \"C\" void\n+__throw_bad_typeid (void)\n+{\n+  throw bad_typeid ();\n+}\n+\n+extern \"C\" void\n+__throw_bad_exception (void)\n+{\n+  throw bad_exception ();\n+}\n+\n+bool\n+uncaught_exception ()\n+{\n+  extern void *__eh_type;\n+  extern bool __eh_in_catch;\n+  return __eh_type && ! __eh_in_catch;\n+}\n+\n+const char * exception::\n+what () const\n+{\n+  return typeid (*this).name ();\n+}"}, {"sha": "506d64c72842dcda953574f91a788acf8a3d3e1f", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=5156628f9ffcf3c94047a56fcde88849bce6cb4f", "patch": "@@ -373,7 +373,7 @@ do_case (start, end)\n   if (end && pedantic)\n     pedwarn (\"ANSI C++ forbids range expressions in switch statement\");\n \n-  if (current_template_parms)\n+  if (processing_template_decl)\n     {\n       add_tree (build_min_nt (CASE_LABEL, start, end));\n       return;"}, {"sha": "dbfc2346883152b522e0bc6fc5bbf3bd978c3c91", "filename": "gcc/cp/gxxint.texi", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Fgxxint.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Fgxxint.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fgxxint.texi?ref=5156628f9ffcf3c94047a56fcde88849bce6cb4f", "patch": "@@ -1176,10 +1176,9 @@ thrown is used instead.  All code that originates exceptions, even code\n that throws exceptions as a side effect, like dynamic casting, and all\n code that catches exceptions must be compiled with either -frtti, or\n -fno-rtti.  It is not possible to mix rtti base exception handling\n-objects with code that doesn't use rtti.  Also, -frtti can alter the\n-binary layout of classes, so mixing -frtti code and -fno-rtti code can\n-be dangerous.  The exceptions to this, are code that doesn't catch or\n-throw exceptions, catch (...), and code that just rethrows an exception.\n+objects with code that doesn't use rtti.  The exceptions to this, are\n+code that doesn't catch or throw exceptions, catch (...), and code that\n+just rethrows an exception.\n \n Currently we use the normal mangling used in building functions names\n (int's are \"i\", const char * is PCc) to build the non-rtti base type"}, {"sha": "d38806b81c459afbb611ec46291794cc846af4d7", "filename": "gcc/cp/inc/exception", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Finc%2Fexception", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Finc%2Fexception", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finc%2Fexception?ref=5156628f9ffcf3c94047a56fcde88849bce6cb4f", "patch": "@@ -0,0 +1,42 @@\n+// Exception Handling support header for -*- C++ -*-\n+// Copyright (C) 1995, 1996 Free Software Foundation\n+\n+#ifndef __EXCEPTION__\n+#define __EXCEPTION__\n+\n+#pragma interface \"exception\"\n+\n+extern \"C++\" {\n+\n+#if 0\n+namespace std {\n+#endif\n+\n+class exception {\n+public:\n+  exception () { }\n+  virtual ~exception () { }\n+  virtual const char* what () const;\n+};\n+\n+class bad_exception : public exception {\n+public:\n+  bad_exception () { }\n+  virtual ~bad_exception () { }\n+};\n+\n+typedef void (*terminate_handler) ();\n+typedef void (*unexpected_handler) ();\n+\n+terminate_handler set_terminate (terminate_handler);\n+void terminate (void);\n+unexpected_handler set_unexpected (unexpected_handler);\n+void unexpected (void);\n+bool uncaught_exception ();\n+} // extern \"C++\"\n+\n+#if 0\n+} // namespace std\n+#endif\n+\n+#endif"}, {"sha": "4bfb960c8517ce55233ee4b18d3cee7e7d682c07", "filename": "gcc/cp/inc/new", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Finc%2Fnew", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Finc%2Fnew", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finc%2Fnew?ref=5156628f9ffcf3c94047a56fcde88849bce6cb4f", "patch": "@@ -0,0 +1,38 @@\n+// The -*- C++ -*- dynamic memory management header.\n+// Copyright (C) 1994, 1996 Free Software Foundation\n+\n+#ifndef __NEW__\n+#define __NEW__\n+\n+#pragma interface \"new\"\n+#include <stddef.h>\n+\n+extern \"C++\" {\n+\n+#if 0\n+namespace std {\n+#endif\n+\n+typedef void (*new_handler)();\n+extern \"C\" new_handler set_new_handler (new_handler);\n+\n+#if 0\n+} // namespace std\n+#endif\n+\n+// G++ implementation internals\n+extern new_handler __new_handler;\n+extern \"C\" void __default_new_handler (void);\n+\n+// replaceable signatures\n+void *operator new (size_t);\n+void *operator new[] (size_t);\n+void operator delete (void *);\n+void operator delete[] (void *);\n+\n+// default placement versions of operator new\n+inline void *operator new(size_t, void *place) { return place; }\n+inline void *operator new[](size_t, void *place) { return place; }\n+} // extern \"C++\"\n+\n+#endif"}, {"sha": "eed0910b6680833052418043a5f58a95fa44828e", "filename": "gcc/cp/inc/new.h", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Finc%2Fnew.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Finc%2Fnew.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finc%2Fnew.h?ref=5156628f9ffcf3c94047a56fcde88849bce6cb4f", "patch": "@@ -0,0 +1,13 @@\n+// -*- C++ -*- forwarding header.\n+\n+#ifndef __NEW_H__\n+#define __NEW_H__\n+\n+#include <new>\n+\n+#if 0\n+using std::new_handler;\n+using std::set_new_handler;\n+#endif\n+\n+#endif // __NEW_H__"}, {"sha": "bad3b66a8d12fe7878872e439eb282756cba77e1", "filename": "gcc/cp/inc/typeinfo", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Finc%2Ftypeinfo", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Finc%2Ftypeinfo", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finc%2Ftypeinfo?ref=5156628f9ffcf3c94047a56fcde88849bce6cb4f", "patch": "@@ -0,0 +1,71 @@\n+// RTTI support for -*- C++ -*-\n+// Copyright (C) 1994, 1995, 1996 Free Software Foundation\n+\n+#ifndef __TYPEINFO__\n+#define __TYPEINFO__\n+\n+#include <exception>\n+\n+extern \"C++\" {\n+\n+#if 0\n+namespace std {\n+#endif\n+\n+class type_info {\n+private:\n+  // assigning type_info is not supported.  made private.\n+  type_info& operator= (const type_info&);\n+  type_info (const type_info&);\n+\n+protected:\n+  type_info (const char *n): _name (n) { }\n+\n+  const char *_name;\n+\n+public:\n+  // destructor\n+  virtual ~type_info ();\n+    \n+  bool before (const type_info& arg);\n+  const char* name () const\n+    { return _name; }\n+  bool operator== (const type_info& arg) const;\n+  bool operator!= (const type_info& arg) const;\n+};\n+\n+// We can't rely on common symbols being shared between translation units\n+// under Windows.  Sigh.\n+\n+#ifndef _WIN32\n+inline bool type_info::\n+operator== (const type_info& arg) const\n+{\n+  return &arg == this;\n+}\n+\n+inline bool type_info::\n+operator!= (const type_info& arg) const\n+{\n+  return &arg != this;\n+}\n+#endif\n+\n+class bad_cast : public exception {\n+public:\n+  bad_cast() { }\n+  virtual ~bad_cast() { }\n+};\n+\n+class bad_typeid : public exception {\n+ public:\n+  bad_typeid () { }\n+  virtual ~bad_typeid () { }\n+};\n+\n+#if 0\n+} // namespace std\n+#endif\n+\n+} // extern \"C++\"\n+#endif"}, {"sha": "af629caf0510b46b588914372b290bd88782624a", "filename": "gcc/cp/init.c", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=5156628f9ffcf3c94047a56fcde88849bce6cb4f", "patch": "@@ -1803,7 +1803,7 @@ build_offset_ref (type, name)\n   tree basebinfo = NULL_TREE;\n   int dtor = 0;\n \n-  if (current_template_parms)\n+  if (processing_template_decl)\n     return build_min_nt (SCOPE_REF, type, name);\n \n   /* Handle namespace names fully here.  */\n@@ -2601,6 +2601,7 @@ build_new (placement, decl, init, use_global_new)\n   tree alloc_expr, alloc_temp;\n   int has_array = 0;\n   enum tree_code code = NEW_EXPR;\n+  int use_cookie;\n \n   tree pending_sizes = NULL_TREE;\n \n@@ -2648,7 +2649,7 @@ build_new (placement, decl, init, use_global_new)\n \t    {\n \t      if (this_nelts == NULL_TREE)\n \t\terror (\"new of array type fails to specify size\");\n-\t      else if (current_template_parms)\n+\t      else if (processing_template_decl)\n \t\t{\n \t\t  nelts = this_nelts;\n \t\t  absdcl = TREE_OPERAND (absdcl, 0);\n@@ -2718,7 +2719,7 @@ build_new (placement, decl, init, use_global_new)\n       decl = TYPE_NAME (type);\n     }\n \n-  if (current_template_parms)\n+  if (processing_template_decl)\n     {\n       tree t;\n       if (has_array)\n@@ -2801,9 +2802,25 @@ build_new (placement, decl, init, use_global_new)\n       return error_mark_node;\n     }\n \n+#if 1\n   /* Get a little extra space to store a couple of things before the new'ed\n-     array.  */\n-  if (has_array && TYPE_VEC_NEW_USES_COOKIE (true_type))\n+     array, if this isn't the default placement new.  */\n+\n+  use_cookie = (has_array && TYPE_VEC_NEW_USES_COOKIE (true_type)\n+\t\t&& ! (placement && ! TREE_CHAIN (placement)\n+\t\t      && TREE_TYPE (TREE_VALUE (placement)) == ptr_type_node));\n+#else\n+  /* Get a little extra space to store a couple of things before the new'ed\n+     array, if this is either non-placement new or new (nothrow).  */\n+  \n+  use_cookie = (has_array && TYPE_VEC_NEW_USES_COOKIE (true_type)\n+\t\t&& (! placement\n+\t\t    || (IS_AGGR_TYPE (TREE_TYPE (placement))\n+\t\t\t&& (TYPE_IDENTIFIER (TREE_TYPE (placement))\n+\t\t\t    == get_identifier (\"nothrow_t\")))));\n+#endif\n+\n+  if (use_cookie)\n     {\n       tree extra = BI_header_size;\n \n@@ -2857,7 +2874,7 @@ build_new (placement, decl, init, use_global_new)\n      sure we have some extra bytes in that case for the BI_header_size\n      cookies? And how does that interact with the code below? (mrs) */\n   /* Finish up some magic for new'ed arrays */\n-  if (has_array && TYPE_VEC_NEW_USES_COOKIE (true_type) && rval != NULL_TREE)\n+  if (use_cookie && rval != NULL_TREE)\n     {\n       tree extra = BI_header_size;\n       tree cookie, exp1;"}, {"sha": "e142bf4f99d285a33349bf45b2db451ed1ccc6b1", "filename": "gcc/cp/input.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Finput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Finput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finput.c?ref=5156628f9ffcf3c94047a56fcde88849bce6cb4f", "patch": "@@ -163,7 +163,7 @@ sub_getch ()\n \t  return getch ();\n \t}\n       if (input)\n-\treturn input->str[input->offset++];\n+\treturn (unsigned char)input->str[input->offset++];\n     }\n   return getc (finput);\n }"}, {"sha": "f91d939b2d93d405e86f96df1d83355c1af1a671", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=5156628f9ffcf3c94047a56fcde88849bce6cb4f", "patch": "@@ -2654,7 +2654,7 @@ do_identifier (token, parsing)\n \t    cp_error (\"enum `%D' is private\", id);\n \t  /* protected is OK, since it's an enum of `this'.  */\n \t}\n-      if (! current_template_parms\n+      if (! processing_template_decl\n \t  || (DECL_INITIAL (id)\n \t      && TREE_CODE (DECL_INITIAL (id)) == TEMPLATE_CONST_PARM))\n \tid = DECL_INITIAL (id);\n@@ -2691,7 +2691,7 @@ do_scoped_id (token, parsing)\n     yychar = yylex ();\n   if (! id)\n     {\n-      if (current_template_parms)\n+      if (processing_template_decl)\n \t{\n \t  id = build_min_nt (LOOKUP_EXPR, token, NULL_TREE);\n \t  LOOKUP_EXPR_GLOBAL (id) = 1;\n@@ -2716,7 +2716,7 @@ do_scoped_id (token, parsing)\n       else if (TREE_CODE (id) != TREE_LIST)\n \tmark_used (id);\n     }\n-  if (TREE_CODE (id) == CONST_DECL && ! current_template_parms)\n+  if (TREE_CODE (id) == CONST_DECL && ! processing_template_decl)\n     {\n       /* XXX CHS - should we set TREE_USED of the constant? */\n       id = DECL_INITIAL (id);\n@@ -2726,7 +2726,7 @@ do_scoped_id (token, parsing)\n       TREE_CONSTANT (id) = 1;\n     }\n \n-  if (current_template_parms)\n+  if (processing_template_decl)\n     {\n       if (is_overloaded_fn (id))\n \t{\n@@ -3796,19 +3796,19 @@ real_yylex ()\n \t      len = p - token_buffer - 1;\n \t    }\n #endif\n-\t    if (current_template_parms)\n+\t    if (processing_template_decl)\n \t      push_obstacks (&permanent_obstack, &permanent_obstack);\n \t    yylval.ttype = build_string ((len + 1) * WCHAR_BYTES, widep);\n-\t    if (current_template_parms)\n+\t    if (processing_template_decl)\n \t      pop_obstacks ();\n \t    TREE_TYPE (yylval.ttype) = wchar_array_type_node;\n \t  }\n \telse\n \t  {\n-\t    if (current_template_parms)\n+\t    if (processing_template_decl)\n \t      push_obstacks (&permanent_obstack, &permanent_obstack);\n \t    yylval.ttype = build_string (p - token_buffer, token_buffer + 1);\n-\t    if (current_template_parms)\n+\t    if (processing_template_decl)\n \t      pop_obstacks ();\n \t    TREE_TYPE (yylval.ttype) = char_array_type_node;\n \t  }\n@@ -4027,6 +4027,30 @@ is_rid (t)\n }\n \n #ifdef GATHER_STATISTICS\n+/* The original for tree_node_kind is in the toplevel tree.c; changes there\n+   need to be brought into here, unless this were actually put into a header\n+   instead.  */\n+/* Statistics-gathering stuff.  */\n+typedef enum\n+{\n+  d_kind,\n+  t_kind,\n+  b_kind,\n+  s_kind,\n+  r_kind,\n+  e_kind,\n+  c_kind,\n+  id_kind,\n+  op_id_kind,\n+  perm_list_kind,\n+  temp_list_kind,\n+  vec_kind,\n+  x_kind,\n+  lang_decl,\n+  lang_type,\n+  all_kinds\n+} tree_node_kind;\n+\n extern int tree_node_counts[];\n extern int tree_node_sizes[];\n #endif"}, {"sha": "b127002b0707b9acf866cd704389903220e020ca", "filename": "gcc/cp/method.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=5156628f9ffcf3c94047a56fcde88849bce6cb4f", "patch": "@@ -369,7 +369,7 @@ build_overload_int (value)\n \tOB_PUTC ('_');\n       return;\n     }\n-  else if (current_template_parms\n+  else if (processing_template_decl\n \t   && TREE_CODE (value) != INTEGER_CST)\n     /* We don't ever want this output, but it's inconvenient not to\n        be able to build the string.  This should cause assembler\n@@ -382,7 +382,7 @@ build_overload_int (value)\n     }\n \n   my_friendly_assert (TREE_CODE (value) == INTEGER_CST, 243);\n-  if (TYPE_PRECISION (value) == 2 * HOST_BITS_PER_WIDE_INT)\n+  if (TYPE_PRECISION (TREE_TYPE (value)) == 2 * HOST_BITS_PER_WIDE_INT)\n     {\n       if (tree_int_cst_lt (value, integer_zero_node))\n \t{\n@@ -1656,7 +1656,7 @@ hack_identifier (value, name)\n       return value;\n     }\n \n-  if (TREE_CODE (type) == REFERENCE_TYPE && ! current_template_parms)\n+  if (TREE_CODE (type) == REFERENCE_TYPE && ! processing_template_decl)\n     value = convert_from_reference (value);\n   return value;\n }"}, {"sha": "297b395e1dbdd76e3999c8460b38ac801023b5c0", "filename": "gcc/cp/new.cc", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Fnew.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Fnew.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fnew.cc?ref=5156628f9ffcf3c94047a56fcde88849bce6cb4f", "patch": "@@ -0,0 +1,6 @@\n+// Implementation file for the -*- C++ -*- dynamic memory management header.\n+// Copyright (C) 1996 Free Software Foundation\n+// This file is part of GNU CC.\n+\n+#pragma implementation \"new\"\n+#include \"new\""}, {"sha": "774bb04714284cd0139278686e5a53e85def6655", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 42, "deletions": 41, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=5156628f9ffcf3c94047a56fcde88849bce6cb4f", "patch": "@@ -990,7 +990,7 @@ compstmtend:\n already_scoped_stmt:\n \t  '{'\n \t\t{\n-\t\t  if (current_template_parms)\n+\t\t  if (processing_template_decl)\n \t\t    {\n \t\t      $<ttype>$ = build_min_nt (COMPOUND_STMT, NULL_TREE);\n \t\t      COMPOUND_STMT_NO_SCOPE ($<ttype>$) = 1;\n@@ -999,7 +999,7 @@ already_scoped_stmt:\n \t\t}\n \t  compstmtend\n \t\t{ \n-\t\t  if (current_template_parms)\n+\t\t  if (processing_template_decl)\n \t\t    {\n \t\t      TREE_OPERAND ($<ttype>2, 0) = TREE_CHAIN ($<ttype>2);\n \t\t      TREE_CHAIN ($<ttype>2) = NULL_TREE;\n@@ -1287,10 +1287,10 @@ primary:\n \t| boolean.literal\n \t| string\n \t\t{\n-\t\t  if (current_template_parms)\n+\t\t  if (processing_template_decl)\n \t\t    push_obstacks (&permanent_obstack, &permanent_obstack);\n \t\t  $$ = combine_strings ($$);\n-\t\t  if (current_template_parms)\n+\t\t  if (processing_template_decl)\n \t\t    pop_obstacks ();\n \t\t}\n \t| '(' expr ')'\n@@ -1455,7 +1455,7 @@ primary:\n \t\t  check_for_new_type (\"const_cast\", $3);\n \t\t  $$ = build_const_cast (type, $6); }\n \t| TYPEID '(' expr ')'\n-\t\t{ $$ = build_typeid ($3); }\n+\t\t{ $$ = build_x_typeid ($3); }\n \t| TYPEID '(' type_id ')'\n \t\t{ tree type = groktypename ($3.t);\n \t\t  check_for_new_type (\"typeid\", $3);\n@@ -1473,20 +1473,20 @@ primary:\n \t| overqualified_id  %prec HYPERUNARY\n \t\t{ $$ = build_offset_ref (OP0 ($$), OP1 ($$)); }\n \t| overqualified_id '(' nonnull_exprlist ')'\n-\t\t{ if (current_template_parms)\n+\t\t{ if (processing_template_decl)\n \t\t    $$ = build_min_nt (CALL_EXPR, copy_to_permanent ($1), $3, NULL_TREE);\n \t\t  else\n \t\t    $$ = build_member_call (OP0 ($$), OP1 ($$), $3); }\n \t| overqualified_id LEFT_RIGHT\n-\t\t{ if (current_template_parms)\n+\t\t{ if (processing_template_decl)\n \t\t    $$ = build_min_nt (CALL_EXPR, copy_to_permanent ($1), \n \t\t\t\t       NULL_TREE, NULL_TREE);\n \t\t  else\n \t\t    $$ = build_member_call (OP0 ($$), OP1 ($$), NULL_TREE); }\n \t| object unqualified_id  %prec UNARY\n-\t\t{ $$ = build_component_ref ($$, $2, NULL_TREE, 1); }\n+\t\t{ $$ = build_x_component_ref ($$, $2, NULL_TREE, 1); }\n \t| object overqualified_id  %prec UNARY\n-\t\t{ if (current_template_parms)\n+\t\t{ if (processing_template_decl)\n \t\t    $$ = build_min_nt (COMPONENT_REF, $1, copy_to_permanent ($2));\n \t\t  else\n \t\t    $$ = build_object_ref ($$, OP0 ($2), OP1 ($2)); }\n@@ -2294,7 +2294,7 @@ named_class_head:\n \t\t\t      && TYPE_SIZE ($$) == NULL_TREE)\n \t\t\t    {\n \t\t\t      SET_CLASSTYPE_TEMPLATE_SPECIALIZATION ($$);\n-\t\t\t      if (current_template_parms)\n+\t\t\t      if (processing_template_decl)\n \t\t\t\tpush_template_decl (TYPE_MAIN_DECL ($$));\n \t\t\t    }\n \t\t\t  else if (CLASSTYPE_TEMPLATE_INSTANTIATION ($$))\n@@ -2496,7 +2496,7 @@ left_curly:\n                       pushtag (TYPE_IDENTIFIER ($<ttype>0), t, 0);\n                       $<ttype>0 = t;\n                     }\n-\t\t  if (current_template_parms && TYPE_CONTEXT (t)\n+\t\t  if (processing_template_decl && TYPE_CONTEXT (t)\n \t\t      && ! current_class_type)\n \t\t    push_template_decl (TYPE_STUB_DECL (t));\n \t\t  pushclass (t, 0);\n@@ -2507,7 +2507,7 @@ left_curly:\n \t\t\t  && TYPE_SIZE (t) == NULL_TREE)\n \t\t\t{\n \t\t\t  SET_CLASSTYPE_TEMPLATE_SPECIALIZATION (t);\n-\t\t\t  if (current_template_parms)\n+\t\t\t  if (processing_template_decl)\n \t\t\t    push_template_decl (TYPE_MAIN_DECL (t));\n \t\t\t}\n \t\t      else if (CLASSTYPE_TEMPLATE_INSTANTIATION (t))\n@@ -2672,7 +2672,8 @@ component_decl_1:\n \t\t  $$ = grokfield ($2, specs, $5, $3,\n \t\t\t\t  build_tree_list ($4, attrs)); }\n \t| component_constructor_declarator maybeasm maybe_attribute maybe_init\n-\t\t{ $$ = grokfield ($$, NULL_TREE, $4, $2, $3); }\n+\t\t{ $$ = grokfield ($$, NULL_TREE, $4, $2,\n+\t\t\t\t  build_tree_list ($3, NULL_TREE)); }\n \t| using_decl\n \t\t{ $$ = do_class_using_decl ($1); }\n \t;\n@@ -3242,15 +3243,15 @@ compstmt_or_error:\n compstmt:\n \t  '{'\n \t\t{\n-\t\t  if (current_template_parms)\n+\t\t  if (processing_template_decl)\n \t\t    {\n \t\t      $<ttype>$ = build_min_nt (COMPOUND_STMT, NULL_TREE);\n \t\t      add_tree ($<ttype>$);\n \t\t    }\n \t\t}\n \t  .pushlevel compstmtend .poplevel\n \t\t{\n-\t\t  if (current_template_parms)\n+\t\t  if (processing_template_decl)\n \t\t    {\n \t\t      TREE_OPERAND ($<ttype>2, 0) = TREE_CHAIN ($<ttype>2);\n \t\t      TREE_CHAIN ($<ttype>2) = NULL_TREE;\n@@ -3263,7 +3264,7 @@ compstmt:\n simple_if:\n \t  IF\n \t\t{\n-\t\t  if (current_template_parms)\n+\t\t  if (processing_template_decl)\n \t\t    {\n \t\t      $<ttype>$ = build_min_nt (IF_STMT, NULL_TREE, NULL_TREE,\n \t\t\t\t\t        NULL_TREE);\n@@ -3273,7 +3274,7 @@ simple_if:\n \t\t}\n \t  .pushlevel paren_cond_or_null\n \t\t{\n-\t\t  if (current_template_parms)\n+\t\t  if (processing_template_decl)\n \t\t    {\n \t\t      if (last_tree != $<ttype>2)\n \t\t        {\n@@ -3292,7 +3293,7 @@ simple_if:\n \t\t}\n \t  implicitly_scoped_stmt\n \t\t{\n-\t\t  if (current_template_parms)\n+\t\t  if (processing_template_decl)\n \t\t    {\n \t\t      TREE_OPERAND ($<ttype>2, 1) = TREE_CHAIN ($<ttype>2);\n \t\t      TREE_CHAIN ($<ttype>2) = NULL_TREE;\n@@ -3306,15 +3307,15 @@ implicitly_scoped_stmt:\n \t\t{ finish_stmt (); }\n \t| .pushlevel\n \t\t{\n-\t\t  if (current_template_parms)\n+\t\t  if (processing_template_decl)\n \t\t    {\n \t\t      $<ttype>$ = build_min_nt (COMPOUND_STMT, NULL_TREE);\n \t\t      add_tree ($<ttype>$);\n \t\t    }\n \t\t}\n \t  simple_stmt .poplevel\n \t\t{\n-\t\t  if (current_template_parms)\n+\t\t  if (processing_template_decl)\n \t\t    {\n \t\t      TREE_OPERAND ($<ttype>2, 0) = TREE_CHAIN ($<ttype>2);\n \t\t      TREE_CHAIN ($<ttype>2) = NULL_TREE;\n@@ -3336,7 +3337,7 @@ simple_stmt:\n \t| expr ';'\n \t\t{\n \t\t  tree expr = $1;\n-\t\t  if (! current_template_parms)\n+\t\t  if (! processing_template_decl)\n \t\t    {\n \t\t      emit_line_note (input_filename, lineno);\n \t\t      /* Do default conversion if safe and possibly important,\n@@ -3350,10 +3351,10 @@ simple_stmt:\n \t\t  clear_momentary ();\n \t\t  finish_stmt (); }\n \t| simple_if ELSE\n-\t\t{ if (! current_template_parms) expand_start_else (); }\n+\t\t{ if (! processing_template_decl) expand_start_else (); }\n \t  implicitly_scoped_stmt\n \t\t{\n-\t\t  if (current_template_parms)\n+\t\t  if (processing_template_decl)\n \t\t    {\n \t\t      TREE_OPERAND ($<ttype>1, 2) = TREE_CHAIN ($<ttype>1);\n \t\t      TREE_CHAIN ($<ttype>1) = NULL_TREE;\n@@ -3365,12 +3366,12 @@ simple_stmt:\n \t  .poplevel\n \t\t{ finish_stmt (); }\n \t| simple_if  %prec IF\n-\t\t{ if (! current_template_parms) expand_end_cond ();\n+\t\t{ if (! processing_template_decl) expand_end_cond ();\n \t\t  do_poplevel ();\n \t\t  finish_stmt (); }\n \t| WHILE\n \t\t{\n-\t\t  if (current_template_parms)\n+\t\t  if (processing_template_decl)\n \t\t    {\n \t\t      $<ttype>$ = build_min_nt (WHILE_STMT, NULL_TREE, NULL_TREE);\n \t\t      add_tree ($<ttype>$);\n@@ -3385,7 +3386,7 @@ simple_stmt:\n \t\t}\n \t  .pushlevel paren_cond_or_null\n \t\t{\n-\t\t  if (current_template_parms)\n+\t\t  if (processing_template_decl)\n \t\t    {\n \t\t      if (last_tree != $<ttype>2)\n \t\t        {\n@@ -3404,7 +3405,7 @@ simple_stmt:\n \t\t}\n \t  already_scoped_stmt .poplevel\n \t\t{\n-\t\t  if (current_template_parms)\n+\t\t  if (processing_template_decl)\n \t\t    {\n \t\t      TREE_OPERAND ($<ttype>2, 1) = TREE_CHAIN ($<ttype>2);\n \t\t      TREE_CHAIN ($<ttype>2) = NULL_TREE;\n@@ -3416,7 +3417,7 @@ simple_stmt:\n \t\t}\n \t| DO\n \t\t{\n-\t\t  if (current_template_parms)\n+\t\t  if (processing_template_decl)\n \t\t    {\n \t\t      $<ttype>$ = build_min_nt (DO_STMT, NULL_TREE, NULL_TREE);\n \t\t      add_tree ($<ttype>$);\n@@ -3430,7 +3431,7 @@ simple_stmt:\n \t\t}\n \t  implicitly_scoped_stmt WHILE\n \t\t{\n-\t\t  if (current_template_parms)\n+\t\t  if (processing_template_decl)\n \t\t    {\n \t\t      TREE_OPERAND ($<ttype>2, 0) = TREE_CHAIN ($<ttype>2);\n \t\t      TREE_CHAIN ($<ttype>2) = NULL_TREE;\n@@ -3444,7 +3445,7 @@ simple_stmt:\n \t\t}\n \t  paren_expr_or_null ';'\n \t\t{\n-\t\t  if (current_template_parms)\n+\t\t  if (processing_template_decl)\n \t\t    TREE_OPERAND ($<ttype>2, 1) = $6;\n \t\t  else\n \t\t    {\n@@ -3456,7 +3457,7 @@ simple_stmt:\n \t\t  finish_stmt ();\n \t\t}\n \t| FOR\n-\t\t{ if (current_template_parms)\n+\t\t{ if (processing_template_decl)\n \t\t    {\n \t\t      $<ttype>$ = build_min_nt (FOR_STMT, NULL_TREE, NULL_TREE, \n \t\t\t\t\t        NULL_TREE, NULL_TREE);\n@@ -3476,7 +3477,7 @@ simple_stmt:\n \t\t}\n \t  '(' for.init.statement\n \t\t{\n-\t\t  if (current_template_parms)\n+\t\t  if (processing_template_decl)\n \t\t    {\n \t\t      if (last_tree != $<ttype>2)\n \t\t\t{\n@@ -3494,7 +3495,7 @@ simple_stmt:\n \t\t}\n \t  .pushlevel xcond ';'\n \t\t{\n-\t\t  if (current_template_parms)\n+\t\t  if (processing_template_decl)\n \t\t    {\n \t\t      if (last_tree != $<ttype>2)\n \t\t        {\n@@ -3515,13 +3516,13 @@ simple_stmt:\n \t\t/* Don't let the tree nodes for $10 be discarded\n \t\t   by clear_momentary during the parsing of the next stmt.  */\n \t\t{\n-\t\t  if (current_template_parms)\n+\t\t  if (processing_template_decl)\n \t\t    TREE_OPERAND ($<ttype>2, 2) = $10;\n \t\t  push_momentary ();\n \t\t}\n \t  already_scoped_stmt .poplevel\n \t\t{\n-\t\t  if (current_template_parms)\n+\t\t  if (processing_template_decl)\n \t\t    {\n \t\t      TREE_OPERAND ($<ttype>2, 3) = TREE_CHAIN ($<ttype>2);\n \t\t      TREE_CHAIN ($<ttype>2) = NULL_TREE;\n@@ -3542,7 +3543,7 @@ simple_stmt:\n \t\t  finish_stmt (); }\n \t| SWITCH .pushlevel '(' condition ')'\n \t\t{\n-\t\t  if (current_template_parms)\n+\t\t  if (processing_template_decl)\n \t\t    {\n \t\t      $<ttype>$ = build_min_nt (SWITCH_STMT, $4, NULL_TREE);\n \t\t      add_tree ($<ttype>$);\n@@ -3559,7 +3560,7 @@ simple_stmt:\n \t\t}\n \t  implicitly_scoped_stmt\n \t\t{\n-\t\t  if (current_template_parms)\n+\t\t  if (processing_template_decl)\n \t\t    {\n \t\t      TREE_OPERAND ($<ttype>6, 1) = TREE_CHAIN ($<ttype>6);\n \t\t      TREE_CHAIN ($<ttype>6) = NULL_TREE;\n@@ -3583,13 +3584,13 @@ simple_stmt:\n \t  stmt\n \t| BREAK ';'\n \t\t{ emit_line_note (input_filename, lineno);\n-\t\t  if (current_template_parms)\n+\t\t  if (processing_template_decl)\n \t\t    add_tree (build_min_nt (BREAK_STMT));\n \t\t  else if ( ! expand_exit_something ())\n \t\t    error (\"break statement not within loop or switch\"); }\n \t| CONTINUE ';'\n \t\t{ emit_line_note (input_filename, lineno);\n-\t\t  if (current_template_parms)\n+\t\t  if (processing_template_decl)\n \t\t    add_tree (build_min_nt (CONTINUE_STMT));\n \t\t  else if (! expand_continue_loop (0))\n \t\t    error (\"continue statement not within a loop\"); }\n@@ -3637,15 +3638,15 @@ simple_stmt:\n \t\t}\n \t| GOTO '*' expr ';'\n \t\t{\n-\t\t  if (current_template_parms)\n+\t\t  if (processing_template_decl)\n \t\t    add_tree (build_min_nt (GOTO_STMT, $3));\n \t\t  else\n \t\t    { emit_line_note (input_filename, lineno);\n \t\t      expand_computed_goto ($3); }\n \t\t}\n \t| GOTO identifier ';'\n \t\t{\n-\t\t  if (current_template_parms)\n+\t\t  if (processing_template_decl)\n \t\t    add_tree (build_min_nt (GOTO_STMT, $2));\n \t\t  else\n \t\t    {"}, {"sha": "5b7caf37fbe1426d6a039a97a2a427d51787517d", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 50, "deletions": 27, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=5156628f9ffcf3c94047a56fcde88849bce6cb4f", "patch": "@@ -80,6 +80,7 @@ begin_template_parm_list ()\n {\n   pushlevel (0);\n   declare_pseudo_global_level ();\n+  ++processing_template_decl;\n }\n \n /* Process information from new template parameter NEXT and append it to the\n@@ -141,7 +142,7 @@ process_template_parm (list, next)\n       decl = build_decl (CONST_DECL, DECL_NAME (parm), TREE_TYPE (parm));\n       DECL_INITIAL (decl) = tinfo;\n       DECL_INITIAL (parm) = tinfo;\n-      TEMPLATE_CONST_SET_INFO (tinfo, idx, processing_template_decl + 1);\n+      TEMPLATE_CONST_SET_INFO (tinfo, idx, processing_template_decl);\n     }\n   else\n     {\n@@ -150,7 +151,7 @@ process_template_parm (list, next)\n       decl = build_decl (TYPE_DECL, TREE_VALUE (parm), t);\n       TYPE_MAIN_DECL (t) = decl;\n       parm = decl;\n-      TEMPLATE_TYPE_SET_INFO (t, idx, processing_template_decl + 1);\n+      TEMPLATE_TYPE_SET_INFO (t, idx, processing_template_decl);\n     }\n   SET_DECL_ARTIFICIAL (decl);\n   pushdecl (decl);\n@@ -171,7 +172,6 @@ end_template_parm_list (parms)\n   tree parm;\n   tree saved_parmlist = make_tree_vec (list_length (parms));\n \n-  ++processing_template_decl;\n   current_template_parms\n     = tree_cons (build_int_2 (0, processing_template_decl),\n \t\t saved_parmlist, current_template_parms);\n@@ -187,7 +187,7 @@ end_template_parm_list (parms)\n void\n end_template_decl ()\n {\n-  if (! current_template_parms)\n+  if (! processing_template_decl)\n     return;\n \n   /* This matches the pushlevel in begin_template_parm_list.  */\n@@ -404,7 +404,7 @@ coerce_template_parms (parms, arglist, in_decl)\n       if (is_type)\n \t{\n \t  val = groktypename (arg);\n-\t  if (! current_template_parms)\n+\t  if (! processing_template_decl)\n \t    {\n \t      tree t = target_type (val);\n \t      if (IS_AGGR_TYPE (t)\n@@ -419,12 +419,12 @@ coerce_template_parms (parms, arglist, in_decl)\n \t{\n \t  tree t = tsubst (TREE_TYPE (parm), &TREE_VEC_ELT (vec, 0),\n \t\t\t   TREE_VEC_LENGTH (vec), in_decl);\n-\t  if (current_template_parms)\n+\t  if (processing_template_decl)\n \t    val = arg;\n \t  else\n \t    val = digest_init (t, arg, (tree *) 0);\n \n-\t  if (val == error_mark_node || current_template_parms)\n+\t  if (val == error_mark_node || processing_template_decl)\n \t    ;\n \n \t  /* 14.2: Other template-arguments must be constant-expressions,\n@@ -743,10 +743,10 @@ lookup_template_class (d1, arglist, in_decl)\n \n       if (TYPE_BEING_DEFINED (ctx) && ctx == current_class_type)\n \t{\n-\t  tree save_parms = current_template_parms;\n-\t  current_template_parms = NULL_TREE;\n+\t  int save_temp = processing_template_decl;\n+\t  processing_template_decl = 0;\n \t  t = xref_tag_from_type (TREE_TYPE (template), id, 0);\n-\t  current_template_parms = save_parms;\n+\t  processing_template_decl = save_temp;\n \t}\n       else\n \t{\n@@ -910,10 +910,13 @@ uses_template_parms (t)\n     case TYPENAME_TYPE:\n       return 1;\n \n+    case SCOPE_REF:\n+      return uses_template_parms (TREE_OPERAND (t, 0));\n+\n     case CONSTRUCTOR:\n       if (TREE_TYPE (t) && TYPE_PTRMEMFUNC_P (TREE_TYPE (t)))\n \treturn uses_template_parms (TYPE_PTRMEMFUNC_FN_TYPE (TREE_TYPE (t)));\n-      /* else fall through */\n+      return uses_template_parms (TREE_OPERAND (t, 1));\n \n     default:\n       switch (TREE_CODE_CLASS (TREE_CODE (t)))\n@@ -1384,7 +1387,7 @@ tsubst (t, args, nargs, in_decl)\n \n       {\n \ttree max = tsubst_expr (TYPE_MAX_VALUE (t), args, nargs, in_decl);\n-\tif (current_template_parms)\n+\tif (processing_template_decl)\n \t  {\n \t    tree itype = make_node (INTEGER_TYPE);\n \t    TYPE_MIN_VALUE (itype) = size_zero_node;\n@@ -1986,6 +1989,7 @@ tsubst_copy (t, args, nargs, in_decl)\n     case SIZEOF_EXPR:\n     case ARROW_EXPR:\n     case THROW_EXPR:\n+    case TYPEID_EXPR:\n       return build1\n \t(code, NULL_TREE,\n \t tsubst_copy (TREE_OPERAND (t, 0), args, nargs, in_decl));\n@@ -2139,6 +2143,11 @@ tsubst_copy (t, args, nargs, in_decl)\n       else\n \treturn t;\n \n+    case CONSTRUCTOR:\n+      return build\n+\t(CONSTRUCTOR, tsubst (TREE_TYPE (t), args, nargs, in_decl), NULL_TREE,\n+\t tsubst_copy (CONSTRUCTOR_ELTS (t), args, nargs, in_decl));\n+\n     default:\n       return t;\n     }\n@@ -2153,7 +2162,7 @@ tsubst_expr (t, args, nargs, in_decl)\n   if (t == NULL_TREE || t == error_mark_node)\n     return t;\n \n-  if (current_template_parms)\n+  if (processing_template_decl)\n     return tsubst_copy (t, args, nargs, in_decl);\n \n   switch (TREE_CODE (t))\n@@ -3255,6 +3264,8 @@ instantiate_decl (d)\n   int nested = in_function_p ();\n   int d_defined;\n   int pattern_defined;\n+  int line = lineno;\n+  char *file = input_filename;\n \n   if (TREE_CODE (d) == FUNCTION_DECL)\n     {\n@@ -3297,9 +3308,19 @@ instantiate_decl (d)\n      variable is a static const initialized in the class body.  */\n   if (TREE_CODE (d) == VAR_DECL\n       && ! DECL_INITIAL (d) && DECL_INITIAL (pattern))\n-    DECL_INITIAL (d) = tsubst_expr\n-      (DECL_INITIAL (pattern), &TREE_VEC_ELT (args, 0),\n-       TREE_VEC_LENGTH (args), tmpl);\n+    {\n+      lineno = DECL_SOURCE_LINE (d);\n+      input_filename = DECL_SOURCE_FILE (d);\n+\n+      pushclass (DECL_CONTEXT (d), 2);\n+      DECL_INITIAL (d) = tsubst_expr\n+\t(DECL_INITIAL (pattern), &TREE_VEC_ELT (args, 0),\n+\t TREE_VEC_LENGTH (args), tmpl);\n+      popclass (1);\n+\n+      lineno = line;\n+      input_filename = file;\n+    }\n \n   if (! pattern_defined\n       || (TREE_CODE (d) == FUNCTION_DECL && ! DECL_INLINE (d)\n@@ -3320,6 +3341,9 @@ instantiate_decl (d)\n \n   push_to_top_level ();\n \n+  lineno = DECL_SOURCE_LINE (d);\n+  input_filename = DECL_SOURCE_FILE (d);\n+\n   /* Trick tsubst into giving us a new decl in case the template changed.  */\n   save_ti = DECL_TEMPLATE_INFO (pattern);\n   DECL_TEMPLATE_INFO (pattern) = NULL_TREE;\n@@ -3328,9 +3352,13 @@ instantiate_decl (d)\n \n   /* And set up DECL_INITIAL, since tsubst doesn't.  */\n   if (TREE_CODE (td) == VAR_DECL)\n-    DECL_INITIAL (td) = tsubst_expr\n-      (DECL_INITIAL (pattern), &TREE_VEC_ELT (args, 0),\n-       TREE_VEC_LENGTH (args), tmpl);\n+    {\n+      pushclass (DECL_CONTEXT (d), 2);\n+      DECL_INITIAL (td) = tsubst_expr\n+\t(DECL_INITIAL (pattern), &TREE_VEC_ELT (args, 0),\n+\t TREE_VEC_LENGTH (args), tmpl);\n+      popclass (1);\n+    }\n \n   /* Convince duplicate_decls to use the DECL_ARGUMENTS from the new decl.  */\n   if (TREE_CODE (d) == FUNCTION_DECL)\n@@ -3354,11 +3382,6 @@ instantiate_decl (d)\n   else if (TREE_CODE (d) == FUNCTION_DECL)\n     {\n       tree t = DECL_SAVED_TREE (pattern);\n-      int line = lineno;\n-      char *file = input_filename;\n-\n-      lineno = DECL_SOURCE_LINE (d);\n-      input_filename = DECL_SOURCE_FILE (d);\n \n       start_function (NULL_TREE, d, NULL_TREE, 1);\n       store_parm_decls ();\n@@ -3392,11 +3415,11 @@ instantiate_decl (d)\n \t\t   TREE_VEC_LENGTH (args), tmpl);\n \n       finish_function (lineno, 0, nested);\n-\n-      lineno = line;\n-      input_filename = file;\n     }\n \n+  lineno = line;\n+  input_filename = file;\n+\n   pop_from_top_level ();\n   pop_tinst_level ();\n "}, {"sha": "f51ea644953bba26df06849777016ead4f26b689", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 138, "deletions": 97, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=5156628f9ffcf3c94047a56fcde88849bce6cb4f", "patch": "@@ -30,6 +30,10 @@ Boston, MA 02111-1307, USA.  */\n #undef NULL\n #define NULL 0\n \n+#ifndef INT_TYPE_SIZE\n+#define INT_TYPE_SIZE BITS_PER_WORD\n+#endif\n+\n extern tree define_function ();\n extern tree build_t_desc_overload ();\n extern struct obstack *permanent_obstack;\n@@ -111,13 +115,59 @@ build_headof (exp)\n   return build (PLUS_EXPR, type, exp,\n \t\tconvert (ptrdiff_type_node, offset));\n }\n+\n+/* Build a call to a generic entry point taking and returning void.  */\n+\n+static tree\n+call_void_fn (name)\n+     char *name;\n+{\n+  tree d = get_identifier (name);\n+  tree type;\n+  \n+  if (IDENTIFIER_GLOBAL_VALUE (d))\n+    d = IDENTIFIER_GLOBAL_VALUE (d);\n+  else\n+    {\n+      push_obstacks (&permanent_obstack, &permanent_obstack);\n+\n+      type = build_function_type (void_type_node, void_list_node);\n+      d = build_lang_decl (FUNCTION_DECL, d, type);\n+      DECL_EXTERNAL (d) = 1;\n+      TREE_PUBLIC (d) = 1;\n+      DECL_ARTIFICIAL (d) = 1;\n+      pushdecl_top_level (d);\n+      make_function_rtl (d);\n+      assemble_external (d);\n+\n+      pop_obstacks ();\n+    }\n+\n+  return build_call (d, void_type_node, NULL_TREE);\n+}\n+\n+/* Get a bad_cast node for the program to throw...\n+\n+   See libstdc++/exception.cc for __throw_bad_cast */\n+\n+static tree\n+throw_bad_cast ()\n+{\n+  return call_void_fn (\"__throw_bad_cast\");\n+}\n+\n+static tree\n+throw_bad_typeid ()\n+{\n+  return call_void_fn (\"__throw_bad_typeid\");\n+}\n \f\n-/* Return the type_info node associated with the expression EXP.  If EXP is\n-   a reference to a polymorphic class, return the dynamic type; otherwise\n-   return the static type of the expression.  */\n+/* Return the type_info function associated with the expression EXP.  If\n+   EXP is a reference to a polymorphic class, return the dynamic type;\n+   otherwise return the static type of the expression.  */\n \n tree\n-build_typeid (exp)\n+get_tinfo_fn_dynamic (exp)\n      tree exp;\n {\n   tree type;\n@@ -127,27 +177,15 @@ build_typeid (exp)\n \n   type = TREE_TYPE (exp);\n \n-  /* Strip top-level cv-qualifiers.  */\n-  type = TYPE_MAIN_VARIANT (type);\n-\n-  /* if b is an instance of B, typeid(b) == typeid(B).  Do this before\n-     reference trickiness.  */\n-  if (TREE_CODE (exp) == VAR_DECL && TREE_CODE (type) == RECORD_TYPE)\n-    return get_typeid (type);\n-\n   /* peel back references, so they match.  */\n   if (TREE_CODE (type) == REFERENCE_TYPE)\n     type = TREE_TYPE (type);\n \n   /* Peel off cv qualifiers.  */\n   type = TYPE_MAIN_VARIANT (type);\n \n-  /* Apply trivial conversion T -> T& for dereferenced ptrs.  */\n-  if (TREE_CODE (type) == RECORD_TYPE)\n-    type = build_reference_type (type);\n-\n   /* If exp is a reference to polymorphic type, get the real type_info.  */\n-  if (TREE_CODE (type) == REFERENCE_TYPE && TYPE_VIRTUAL_P (TREE_TYPE (type)))\n+  if (TYPE_VIRTUAL_P (type) && ! resolves_to_fixed_type_p (exp, 0))\n     {\n       /* build reference to type_info from vtable.  */\n       tree t;\n@@ -156,7 +194,7 @@ build_typeid (exp)\n \twarning (\"taking dynamic typeid of object without -frtti\");\n \n       /* If we don't have rtti stuff, get to a sub-object that does.  */\n-      if (!CLASSTYPE_VFIELDS (TREE_TYPE (type)))\n+      if (! CLASSTYPE_VFIELDS (type))\n \t{\n \t  exp = build_unary_op (ADDR_EXPR, exp, 0);\n \t  exp = build_headof_sub (exp);\n@@ -168,14 +206,57 @@ build_typeid (exp)\n       else\n \tt = build_vfn_ref ((tree *) 0, exp, integer_zero_node);\n       TREE_TYPE (t) = build_pointer_type (tinfo_fn_type);\n-\n-      t = build (CALL_EXPR, TREE_TYPE (tinfo_fn_type), t, NULL_TREE, NULL_TREE);\n-      TREE_SIDE_EFFECTS (t) = 1;\n-      return convert_from_reference (t);\n+      return t;\n     }\n \n   /* otherwise return the type_info for the static type of the expr.  */\n-  return get_typeid (type);\n+  return get_tinfo_fn (TYPE_MAIN_VARIANT (type));\n+}\n+\n+tree\n+build_typeid (exp)\n+     tree exp;\n+{\n+  exp = get_tinfo_fn_dynamic (exp);\n+  exp = build_call (exp, TREE_TYPE (tinfo_fn_type), NULL_TREE);\n+  return convert_from_reference (exp);\n+}  \n+\n+tree\n+build_x_typeid (exp)\n+     tree exp;\n+{\n+  tree cond = NULL_TREE;\n+  tree type = TREE_TYPE (tinfo_fn_type);\n+  int nonnull;\n+\n+  if (processing_template_decl)\n+    return build_min_nt (TYPEID_EXPR, exp);\n+\n+  if (TREE_CODE (exp) == INDIRECT_REF\n+      && TREE_CODE (TREE_TYPE (TREE_OPERAND (exp, 0))) == POINTER_TYPE\n+      && TYPE_VIRTUAL_P (TREE_TYPE (exp))\n+      && ! resolves_to_fixed_type_p (exp, &nonnull)\n+      && ! nonnull)\n+    {\n+      exp = stabilize_reference (exp);\n+      cond = convert (boolean_type_node, TREE_OPERAND (exp, 0));\n+    }\n+\n+  exp = get_tinfo_fn_dynamic (exp);\n+  exp = build_call (exp, type, NULL_TREE);\n+\n+  if (cond)\n+    {\n+      tree bad = throw_bad_typeid ();\n+\n+      bad = build_compound_expr\n+\t(tree_cons (NULL_TREE, bad, build_tree_list\n+\t\t    (NULL_TREE, convert (type, integer_zero_node))));\n+      exp = build (COND_EXPR, type, cond, exp, bad);\n+    }\n+\n+  return convert_from_reference (exp);\n }\n \n tree\n@@ -193,7 +274,7 @@ get_tinfo_var (type)\n      If our struct layout or the type_info classes are changed, this will\n      need to be modified.  */\n   if (TYPE_VOLATILE (type) || TYPE_READONLY (type))\n-    size = 4 * POINTER_SIZE;\n+    size = 3 * POINTER_SIZE + INT_TYPE_SIZE;\n   else if (TREE_CODE (type) == POINTER_TYPE\n \t   && ! (TREE_CODE (TREE_TYPE (type)) == OFFSET_TYPE\n \t\t || TREE_CODE (TREE_TYPE (type)) == METHOD_TYPE))\n@@ -207,7 +288,7 @@ get_tinfo_var (type)\n \t\t   (TREE_VEC_ELT (TYPE_BINFO_BASETYPES (type), 0))))\n \tsize = 3 * POINTER_SIZE;\n       else\n-\tsize = 4 * POINTER_SIZE;\n+\tsize = 3 * POINTER_SIZE + INT_TYPE_SIZE;\n     }\n   else\n     size = 2 * POINTER_SIZE;\n@@ -266,9 +347,8 @@ tree\n get_typeid_1 (type)\n      tree type;\n {\n-  tree t = build (CALL_EXPR, TREE_TYPE (tinfo_fn_type),\n-\t\t  default_conversion (get_tinfo_fn (type)), NULL_TREE, NULL_TREE);\n-  TREE_SIDE_EFFECTS (t) = 1;\n+  tree t = build_call\n+    (get_tinfo_fn (type), TREE_TYPE (tinfo_fn_type), NULL_TREE);\n   return convert_from_reference (t);\n }\n   \n@@ -296,37 +376,6 @@ get_typeid (type)\n   return get_typeid_1 (type);\n }\n \n-/* Get a bad_cast node for the program to throw...\n-\n-   See libstdc++/exception.cc for __throw_bad_cast */\n-\n-static tree\n-throw_bad_cast ()\n-{\n-  tree d = get_identifier (\"__throw_bad_cast\");\n-  tree type;\n-  \n-  if (IDENTIFIER_GLOBAL_VALUE (d))\n-    return IDENTIFIER_GLOBAL_VALUE (d);\n-\n-  push_obstacks (&permanent_obstack, &permanent_obstack);\n-\n-  type = build_function_type (void_type_node, void_list_node);\n-  d = build_lang_decl (FUNCTION_DECL, d, type);\n-  DECL_EXTERNAL (d) = 1;\n-  TREE_PUBLIC (d) = 1;\n-  DECL_ARTIFICIAL (d) = 1;\n-  pushdecl_top_level (d);\n-  make_function_rtl (d);\n-  assemble_external (d);\n-\n-  pop_obstacks ();\n-\n-  d = build (CALL_EXPR, void_type_node, default_conversion (d), NULL_TREE, NULL_TREE);\n-  TREE_SIDE_EFFECTS (d) = 1;\n-  return d;\n-}\n-\n /* Check whether TEST is null before returning RESULT.  If TEST is used in\n    RESULT, it must have previously had a save_expr applied to it.  */\n \n@@ -355,7 +404,7 @@ build_dynamic_cast (type, expr)\n   if (type == error_mark_node || expr == error_mark_node)\n     return error_mark_node;\n   \n-  if (current_template_parms)\n+  if (processing_template_decl)\n     {\n       tree t = build_min (DYNAMIC_CAST_EXPR, type, expr);\n       return t;\n@@ -497,19 +546,22 @@ build_dynamic_cast (type, expr)\n \t  expr2 = build_headof (expr1);\n \n \t  if (ec == POINTER_TYPE)\n-\t    td1 = build_typeid (build_indirect_ref (expr, NULL_PTR));\n+\t    td1 = get_tinfo_fn_dynamic (build_indirect_ref (expr, NULL_PTR));\n \t  else\n-\t    td1 = build_typeid (expr);\n+\t    td1 = get_tinfo_fn_dynamic (expr);\n+\t  td1 = decay_conversion (td1);\n \t  \n-\t  td2 = get_typeid (TREE_TYPE (type));\n-\t  td3 = get_typeid (TREE_TYPE (exprtype));\n+\t  td2 = decay_conversion\n+\t    (get_tinfo_fn (TYPE_MAIN_VARIANT (TREE_TYPE (type))));\n+\t  td3 = decay_conversion\n+\t    (get_tinfo_fn (TYPE_MAIN_VARIANT (TREE_TYPE (exprtype))));\n \n           elems = tree_cons\n-\t    (NULL_TREE, TREE_OPERAND (td1, 0), tree_cons\n-\t     (NULL_TREE, TREE_OPERAND (td2, 0), tree_cons\n+\t    (NULL_TREE, td1, tree_cons\n+\t     (NULL_TREE, td2, tree_cons\n \t      (NULL_TREE, build_int_2 (1, 0), tree_cons\n \t       (NULL_TREE, expr2, tree_cons\n-\t\t(NULL_TREE, TREE_OPERAND (td3, 0), tree_cons\n+\t\t(NULL_TREE, td3, tree_cons\n \t\t (NULL_TREE, expr1, NULL_TREE))))));\n \n \t  dcast_fn = get_identifier (\"__dynamic_cast\");\n@@ -520,14 +572,12 @@ build_dynamic_cast (type, expr)\n \t      tree tmp;\n \n \t      push_obstacks (&permanent_obstack, &permanent_obstack);\n-\t      tmp = build_reference_type\n-\t\t(build_type_variant (type_info_type_node, 1, 0));\n \t      tmp = tree_cons\n-\t\t(NULL_TREE, tmp, tree_cons\n-\t\t (NULL_TREE, tmp, tree_cons\n+\t\t(NULL_TREE, TREE_TYPE (td1), tree_cons\n+\t\t (NULL_TREE, TREE_TYPE (td1), tree_cons\n \t\t  (NULL_TREE, integer_type_node, tree_cons\n \t\t   (NULL_TREE, ptr_type_node, tree_cons\n-\t\t    (NULL_TREE, tmp, tree_cons\n+\t\t    (NULL_TREE, TREE_TYPE (td1), tree_cons\n \t\t     (NULL_TREE, ptr_type_node, void_list_node))))));\n \t      tmp = build_function_type (ptr_type_node, tmp);\n \t      dcast_fn = build_lang_decl (FUNCTION_DECL, dcast_fn, tmp);\n@@ -540,15 +590,16 @@ build_dynamic_cast (type, expr)\n \t      pop_obstacks ();\n \t    }\n \t  \n-          result = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (dcast_fn)),\n-\t\t\t  decay_conversion (dcast_fn), elems, NULL_TREE);\n-\t  TREE_SIDE_EFFECTS (result) = 1;\n+          result = build_call\n+\t    (dcast_fn, TREE_TYPE (TREE_TYPE (dcast_fn)), elems);\n \n \t  if (tc == REFERENCE_TYPE)\n \t    {\n \t      expr1 = throw_bad_cast ();\n-\t      expr1 = build_compound_expr (tree_cons (NULL_TREE, expr1,\n-\t\t\t\t\t\t      build_tree_list (NULL_TREE, convert (type, integer_zero_node))));\n+\t      expr1 = build_compound_expr\n+\t\t(tree_cons (NULL_TREE, expr1,\n+\t\t\t    build_tree_list (NULL_TREE, convert\n+\t\t\t\t\t     (type, integer_zero_node))));\n \t      TREE_TYPE (expr1) = type;\n \t      result = save_expr (result);\n \t      return build (COND_EXPR, type, result, result, expr1);\n@@ -625,9 +676,7 @@ expand_si_desc (tdecl, type)\n       pop_obstacks ();\n     }\n \n-  fn = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (fn)),\n-\t      decay_conversion (fn), elems, NULL_TREE);\n-  TREE_SIDE_EFFECTS (fn) = 1;\n+  fn = build_call (fn, TREE_TYPE (TREE_TYPE (fn)), elems);\n   expand_expr_stmt (fn);\n }\n \n@@ -668,7 +717,7 @@ expand_class_desc (tdecl, type)\n \t(FIELD_DECL, NULL_TREE,\n \t build_pointer_type (build_type_variant (type_info_type_node, 1, 0)));\n       fields [1] = build_lang_field_decl\n-\t(FIELD_DECL, NULL_TREE, sizetype);\n+\t(FIELD_DECL, NULL_TREE, unsigned_intSI_type_node);\n       DECL_BIT_FIELD (fields[1]) = 1;\n       DECL_FIELD_SIZE (fields[1]) = 29;\n \n@@ -805,9 +854,7 @@ expand_class_desc (tdecl, type)\n       pop_obstacks ();\n     }\n \n-  fn = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (fn)),\n-\t      decay_conversion (fn), elems, NULL_TREE);\n-  TREE_SIDE_EFFECTS (fn) = 1;\n+  fn = build_call (fn, TREE_TYPE (TREE_TYPE (fn)), elems);\n   expand_expr_stmt (fn);\n }\n \n@@ -854,9 +901,7 @@ expand_ptr_desc (tdecl, type)\n       pop_obstacks ();\n     }\n \n-  fn = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (fn)),\n-\t      decay_conversion (fn), elems, NULL_TREE);\n-  TREE_SIDE_EFFECTS (fn) = 1;\n+  fn = build_call (fn, TREE_TYPE (TREE_TYPE (fn)), elems);\n   expand_expr_stmt (fn);\n }\n \n@@ -905,9 +950,7 @@ expand_attr_desc (tdecl, type)\n       pop_obstacks ();\n     }\n \n-  fn = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (fn)),\n-\t      decay_conversion (fn), elems, NULL_TREE);\n-  TREE_SIDE_EFFECTS (fn) = 1;\n+  fn = build_call (fn, TREE_TYPE (TREE_TYPE (fn)), elems);\n   expand_expr_stmt (fn);\n }\n \n@@ -947,9 +990,7 @@ expand_generic_desc (tdecl, type, fnname)\n       pop_obstacks ();\n     }\n \n-  fn = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (fn)),\n-\t      decay_conversion (fn), elems, NULL_TREE);\n-  TREE_SIDE_EFFECTS (fn) = 1;\n+  fn = build_call (fn, TREE_TYPE (TREE_TYPE (fn)), elems);\n   expand_expr_stmt (fn);\n }\n \n@@ -994,10 +1035,12 @@ synthesize_tinfo_fn (fndecl)\n   tmp = build_binary_op (EQ_EXPR, tmp, integer_zero_node, 1);\n   expand_start_cond (tmp, 0);\n \n-  if (TYPE_VOLATILE (type) || TYPE_READONLY (type))\n-    expand_attr_desc (tdecl, type);\n+  if (TREE_CODE (type) == FUNCTION_TYPE)\n+    expand_generic_desc (tdecl, type, \"__rtti_func\");\n   else if (TREE_CODE (type) == ARRAY_TYPE)\n     expand_generic_desc (tdecl, type, \"__rtti_array\");\n+  else if (TYPE_VOLATILE (type) || TYPE_READONLY (type))\n+    expand_attr_desc (tdecl, type);\n   else if (TREE_CODE (type) == POINTER_TYPE)\n     {\n       if (TREE_CODE (TREE_TYPE (type)) == OFFSET_TYPE)\n@@ -1022,8 +1065,6 @@ synthesize_tinfo_fn (fndecl)\n     }\n   else if (TREE_CODE (type) == ENUMERAL_TYPE)\n     expand_generic_desc (tdecl, type, \"__rtti_user\");\n-  else if (TREE_CODE (type) == FUNCTION_TYPE)\n-    expand_generic_desc (tdecl, type, \"__rtti_func\");\n   else\n     my_friendly_abort (252);\n "}, {"sha": "d82aaaf04315dd35f00046c2289682d7e378c38c", "filename": "gcc/cp/tinfo.cc", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Ftinfo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Ftinfo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftinfo.cc?ref=5156628f9ffcf3c94047a56fcde88849bce6cb4f", "patch": "@@ -0,0 +1,125 @@\n+// Methods for type_info for -*- C++ -*- Run Time Type Identification.\n+// Copyright (C) 1994, 1996 Free Software Foundation\n+\n+// This file is part of GNU CC.\n+\n+// GNU CC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// GNU CC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GNU CC; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330,\n+// Boston, MA 02111-1307, USA. \n+\n+// As a special exception, if you link this library with other files,\n+// some of which are compiled with GCC, to produce an executable,\n+// this library does not by itself cause the resulting executable\n+// to be covered by the GNU General Public License.\n+// This exception does not however invalidate any other reasons why\n+// the executable file might be covered by the GNU General Public License.\n+\n+#include <stddef.h>\n+#include \"tinfo.h\"\n+#include \"new\"\t\t\t// for placement new\n+\n+// This file contains the minimal working set necessary to link with code\n+// that uses virtual functions and -frtti but does not actually use RTTI\n+// functionality.\n+\n+type_info::\n+~type_info ()\n+{ }\n+\n+extern \"C\" void\n+__rtti_class (void *addr, const char *name,\n+\t      const __class_type_info::base_info *bl, size_t bn)\n+{ new (addr) __class_type_info (name, bl, bn); }\n+\n+extern \"C\" void\n+__rtti_si (void *addr, const char *n, const type_info *ti)\n+{\n+  new (addr) __si_type_info\n+    (n, static_cast <const __user_type_info &> (*ti));\n+}\n+\n+extern \"C\" void\n+__rtti_user (void *addr, const char *name)\n+{ new (addr) __user_type_info (name); }\n+\n+// dynamic_cast helper methods.\n+// Returns a pointer to the desired sub-object or 0.\n+\n+void * __user_type_info::\n+dcast (const type_info& to, int, void *addr, const type_info *, void *) const\n+{ return (*this == to) ? addr : 0; }\n+\n+void * __si_type_info::\n+dcast (const type_info& to, int require_public, void *addr,\n+       const type_info *sub, void *subptr) const\n+{\n+  if (*this == to)\n+    return addr;\n+  return base.dcast (to, require_public, addr, sub, subptr);\n+}\n+\n+void* __class_type_info::\n+dcast (const type_info& desired, int is_public, void *objptr,\n+       const type_info *sub, void *subptr) const\n+{\n+  if (*this == desired)\n+    return objptr;\n+\n+  void *match_found = 0;\n+  for (int i = 0; i < n_bases; i++)\n+    {\n+      if (is_public && base_list[i].access != PUBLIC)\n+\tcontinue;\n+\n+      void *p = (char *)objptr + base_list[i].offset;\n+      if (base_list[i].is_virtual)\n+\tp = *(void **)p;\n+      p = base_list[i].base->dcast (desired, is_public, p, sub, subptr);\n+      if (p)\n+\t{\n+\t  if (match_found == 0)\n+\t    match_found = p;\n+\t  else if (match_found != p)\n+\t    {\n+\t      if (sub)\n+\t\t{\n+\t\t  // Perhaps we're downcasting from *sub to desired; see if\n+\t\t  // subptr is a subobject of exactly one of {match_found,p}.\n+\n+\t\t  const __user_type_info &d =\n+\t\t    static_cast <const __user_type_info &> (desired);\n+\n+\t\t  void *os = d.dcast (*sub, 1, match_found);\n+\t\t  void *ns = d.dcast (*sub, 1, p);\n+\n+\t\t  if (os == ns)\n+\t\t    /* ambiguous -- subptr is a virtual base */;\n+\t\t  else if (os == subptr)\n+\t\t    continue;\n+\t\t  else if (ns == subptr)\n+\t\t    {\n+\t\t      match_found = p;\n+\t\t      continue;\n+\t\t    }\n+\t\t}\n+\n+\t      // base found at two different pointers,\n+\t      // conversion is not unique\n+\t      return 0;\n+\t    }\n+\t}\n+    }\n+\n+  return match_found;\n+}"}, {"sha": "10290a8e52b5e43408605a03cf0b2174025d12e0", "filename": "gcc/cp/tinfo2.cc", "status": "added", "additions": 311, "deletions": 0, "changes": 311, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Ftinfo2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Ftinfo2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftinfo2.cc?ref=5156628f9ffcf3c94047a56fcde88849bce6cb4f", "patch": "@@ -0,0 +1,311 @@\n+// Methods for type_info for -*- C++ -*- Run Time Type Identification.\n+// Copyright (C) 1994, 1996 Free Software Foundation\n+\n+// This file is part of GNU CC.\n+\n+// GNU CC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// GNU CC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GNU CC; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330,\n+// Boston, MA 02111-1307, USA. \n+\n+// As a special exception, if you link this library with other files,\n+// some of which are compiled with GCC, to produce an executable,\n+// this library does not by itself cause the resulting executable\n+// to be covered by the GNU General Public License.\n+// This exception does not however invalidate any other reasons why\n+// the executable file might be covered by the GNU General Public License.\n+\n+#include <stddef.h>\n+#include \"tinfo.h\"\n+#include \"new\"\t\t\t// for placement new\n+\n+// service function for comparing types by name.\n+\n+static inline int\n+fast_compare (const char *n1, const char *n2) {\n+  int c;\n+  if (n1 == n2) return 0;\n+  if (n1 == 0) return *n2;\n+  else if (n2 == 0) return *n1;\n+\n+  c = (int)*n1++ - (int)*n2++;\n+  return c == 0 ? strcmp (n1, n2) : c;\n+};\n+\n+bool\n+type_info::before (const type_info &arg)\n+{\n+  return fast_compare (name (), arg.name ()) < 0;\n+}\n+\n+#ifdef _WIN32\n+bool type_info::\n+operator== (const type_info& arg) const\n+{\n+  return fast_compare (name (), arg.name ()) == 0;\n+}\n+\n+bool type_info::\n+operator!= (const type_info& arg) const\n+{\n+  return fast_compare (name (), arg.name ()) != 0;\n+}\n+#endif\n+\n+// type info for pointer type.\n+\n+struct __pointer_type_info : public type_info {\n+  const type_info& type;\n+\n+  __pointer_type_info (const char *n, const type_info& ti)\n+    : type_info (n), type (ti) {}\n+};\n+\n+// type info for attributes\n+\n+struct __attr_type_info : public type_info {\n+  enum cv { NONE = 0, CONST = 1, VOLATILE = 2, CONSTVOL = 1 | 2 };\n+\n+  const type_info& type;\n+  cv attr;\n+\n+  __attr_type_info (const char *n, cv a, const type_info& t)\n+    : type_info (n), type (t), attr (a) {}\n+};\n+\n+// type_info for builtin type\n+\n+struct __builtin_type_info : public type_info {\n+  __builtin_type_info (const char *n): type_info (n) {}\n+};\n+\n+// type info for function.\n+\n+struct __func_type_info : public type_info {\n+  __func_type_info (const char *n) : type_info (n) {}\n+};\n+\n+// type info for pointer to member function.\n+\n+struct __ptmf_type_info : public type_info {\n+  __ptmf_type_info (const char *n) : type_info (n) {}\n+};\n+\n+// type info for pointer to data member.\n+\n+struct __ptmd_type_info : public type_info {\n+  __ptmd_type_info (const char *n): type_info (n) {}\n+};\n+\n+// type info for array.\n+\n+struct __array_type_info : public type_info {\n+  __array_type_info (const char *n): type_info (n) {}\n+};\n+\n+// Entry points for the compiler.\n+\n+/* Low level match routine used by compiler to match types of catch\n+   variables and thrown objects.  */\n+\n+extern \"C\" void*\n+__throw_type_match_rtti (void *catch_type_r, void *throw_type_r, void *objptr)\n+{\n+  const type_info &catch_type = *(const type_info *)catch_type_r;\n+  const type_info &throw_type = *(const type_info *)throw_type_r;\n+  \n+  if (catch_type == throw_type)\n+    return objptr;\n+  \n+#if 0\n+  printf (\"We want to match a %s against a %s!\\n\",\n+\t  throw_type.name (), catch_type.name ());\n+#endif\n+\n+  void *new_objptr = 0;\n+\n+  if (const __user_type_info *p\n+      = dynamic_cast <const __user_type_info *> (&throw_type))\n+    {\n+      /* The 1 skips conversions to private bases. */\n+      new_objptr = p->dcast (catch_type, 1, objptr);\n+    }\n+  else if (const __pointer_type_info *fr =\n+\t   dynamic_cast <const __pointer_type_info *> (&throw_type))\n+    {\n+      const __pointer_type_info *to =\n+\t   dynamic_cast <const __pointer_type_info *> (&catch_type);\n+\n+      if (! to)\n+\tgoto fail;\n+\n+      const type_info *subfr = &fr->type, *subto = &to->type;\n+      __attr_type_info::cv cvfrom, cvto;\n+\n+      if (const __attr_type_info *at\n+\t  = dynamic_cast <const __attr_type_info *> (subfr))\n+\t{\n+\t  cvfrom = at->attr;\n+\t  subfr = &at->type;\n+\t}\n+      else\n+\tcvfrom = __attr_type_info::NONE;\n+      \n+      if (const __attr_type_info *at\n+\t  = dynamic_cast <const __attr_type_info *> (subto))\n+\t{\n+\t  cvto = at->attr;\n+\t  subto = &at->type;\n+\t}\n+      else\n+\tcvto = __attr_type_info::NONE;\n+\n+      if (((cvfrom & __attr_type_info::CONST)\n+\t   > (cvto & __attr_type_info::CONST))\n+\t  || ((cvfrom & __attr_type_info::VOLATILE)\n+\t      > (cvto & __attr_type_info::VOLATILE)))\n+\tgoto fail;\n+\n+      if (*subto == *subfr)\n+\tnew_objptr = objptr;\n+      else if (*subto == typeid (void)\n+\t       && dynamic_cast <const __func_type_info *> (subfr) == 0)\n+\tnew_objptr = objptr;\n+      else if (const __user_type_info *p\n+\t       = dynamic_cast <const __user_type_info *> (subfr))\n+\t{\n+\t  /* The 1 skips conversions to private bases. */\n+\t  new_objptr = p->dcast (*subto, 1, objptr);\n+\t}\n+      else if (const __pointer_type_info *pfr\n+\t       = dynamic_cast <const __pointer_type_info *> (subfr))\n+\t{\n+\t  // Multi-level pointer conversion.\n+\n+\t  const __pointer_type_info *pto\n+\t    = dynamic_cast <const __pointer_type_info *> (subto);\n+\n+\t  if (! pto)\n+\t    goto fail;\n+\t    \n+\t  bool constp = (cvto & __attr_type_info::CONST);\n+\t  for (subto = &pto->type, subfr = &pfr->type; ;\n+\t       subto = &pto->type, subfr = &pfr->type)\n+\t    {\n+\t      if (const __attr_type_info *at\n+\t\t  = dynamic_cast <const __attr_type_info *> (subfr))\n+\t\t{\n+\t\t  cvfrom = at->attr;\n+\t\t  subfr = &at->type;\n+\t\t}\n+\t      else\n+\t\tcvfrom = __attr_type_info::NONE;\n+      \n+\t      if (const __attr_type_info *at\n+\t\t  = dynamic_cast <const __attr_type_info *> (subto))\n+\t\t{\n+\t\t  cvto = at->attr;\n+\t\t  subto = &at->type;\n+\t\t}\n+\t      else\n+\t\tcvto = __attr_type_info::NONE;\n+\n+\t      if (((cvfrom & __attr_type_info::CONST)\n+\t\t   > (cvto & __attr_type_info::CONST))\n+\t\t  || ((cvfrom & __attr_type_info::VOLATILE)\n+\t\t      > (cvto & __attr_type_info::VOLATILE)))\n+\t\tgoto fail;\n+\n+\t      if (! constp\n+\t\t  && (((cvfrom & __attr_type_info::CONST)\n+\t\t       < (cvto & __attr_type_info::CONST))\n+\t\t      || ((cvfrom & __attr_type_info::VOLATILE)\n+\t\t\t  < (cvto & __attr_type_info::VOLATILE))))\n+\t\tgoto fail;\n+\n+\t      if (*subto == *subfr)\n+\t\t{\n+\t\t  new_objptr = objptr;\n+\t\t  break;\n+\t\t}\n+\n+\t      pto = dynamic_cast <const __pointer_type_info *> (subto);\n+\t      pfr = dynamic_cast <const __pointer_type_info *> (subfr);\n+\t      if (! pto || ! pfr)\n+\t\tgoto fail;\t\t\n+\n+\t      if (! (cvto & __attr_type_info::CONST))\n+\t\tconstp = false;\n+\t    }\n+\t}\n+    }\n+ fail:\n+\n+#if 0\n+  if (new_objptr)\n+    printf (\"It converts, delta is %d\\n\", new_objptr-objptr);\n+#endif\n+  return new_objptr;\n+}\n+\n+extern \"C\" void\n+__rtti_ptr (void *addr, const char *n, const type_info *ti)\n+{ new (addr) __pointer_type_info (n, *ti); }\n+\n+extern \"C\" void\n+__rtti_attr (void *addr, const char *n, int attrval, const type_info *ti)\n+{\n+  new (addr) __attr_type_info\n+    (n, static_cast <__attr_type_info::cv> (attrval), *ti);\n+}\n+\n+extern \"C\" void\n+__rtti_func (void *addr, const char *name)\n+{ new (addr) __func_type_info (name); }\n+\n+extern \"C\" void\n+__rtti_ptmf (void *addr, const char *name)\n+{ new (addr) __ptmf_type_info (name); }\n+\n+extern \"C\" void\n+__rtti_ptmd (void *addr, const char *name)\n+{ new (addr) __ptmd_type_info (name); }\n+\n+extern \"C\" void\n+__rtti_array (void *addr, const char *name)\n+{ new (addr) __array_type_info (name); }\n+\n+extern \"C\" void *\n+__dynamic_cast (const type_info& (*from)(void), const type_info& (*to)(void),\n+\t\tint require_public, void *address,\n+\t\tconst type_info & (*sub)(void), void *subptr)\n+{\n+  return static_cast <const __user_type_info &> (from ()).dcast\n+    (to (), require_public, address, &(sub ()), subptr);\n+}\n+\n+// type_info nodes and functions for the builtin types.  The mangling here\n+// must match the mangling in gcc/cp/rtti.c.\n+\n+#define BUILTIN(mangled)\t\t\t\t\t\\\n+unsigned char __ti##mangled [sizeof (__builtin_type_info)]\t\\\n+  __attribute__ ((aligned (__alignof__ (void *))));\t\t\\\n+extern \"C\" const type_info &__tf##mangled (void) {\t\t\\\n+  if ((*(void **) __ti##mangled) == 0)\t\t\t\t\\\n+    new (__ti##mangled) __builtin_type_info (#mangled);\t\t\\\n+  return *(type_info *)__ti##mangled;\t\t\t\t\\\n+}\n+\n+BUILTIN (v); BUILTIN (x); BUILTIN (l); BUILTIN (i); BUILTIN (s); BUILTIN (b);\n+BUILTIN (c); BUILTIN (w); BUILTIN (r); BUILTIN (d); BUILTIN (f);\n+BUILTIN (Ui); BUILTIN (Ul); BUILTIN (Ux); BUILTIN (Us); BUILTIN (Uc);"}, {"sha": "0d0dc05318eddebf077f6f6f2dffa783a30345aa", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=5156628f9ffcf3c94047a56fcde88849bce6cb4f", "patch": "@@ -356,6 +356,7 @@ break_out_calls (exp)\n extern struct obstack *current_obstack;\n extern struct obstack permanent_obstack, class_obstack;\n extern struct obstack *saveable_obstack;\n+extern struct obstack *expression_obstack;\n \n /* Here is how primitive or already-canonicalized types' hash\n    codes are made.  MUST BE CONSISTENT WITH tree.c !!! */\n@@ -421,7 +422,7 @@ build_cplus_array_type_1 (elt_type, index_type)\n       saveable_obstack = &permanent_obstack;\n     }\n \n-  if (current_template_parms)\n+  if (processing_template_decl)\n     {\n       t = make_node (ARRAY_TYPE);\n       TREE_TYPE (t) = elt_type;\n@@ -1615,8 +1616,8 @@ mapcar (t, func)\n \t\t\t\t mapcar (TYPE_ARG_TYPES (t), func));\n       return cp_build_type_variant (tmp, TYPE_READONLY (t), TYPE_VOLATILE (t));\n     case ARRAY_TYPE:\n-      tmp = build_array_type (mapcar (TREE_TYPE (t), func),\n-\t\t\t      mapcar (TYPE_DOMAIN (t), func));\n+      tmp = build_cplus_array_type (mapcar (TREE_TYPE (t), func),\n+\t\t\t\t    mapcar (TYPE_DOMAIN (t), func));\n       return cp_build_type_variant (tmp, TYPE_READONLY (t), TYPE_VOLATILE (t));\n     case INTEGER_TYPE:\n       tmp = build_index_type (mapcar (TYPE_MAX_VALUE (t), func));\n@@ -1632,6 +1633,11 @@ mapcar (t, func)\n \t mapcar (TREE_CHAIN (TYPE_ARG_TYPES (t)), func));\n       return cp_build_type_variant (tmp, TYPE_READONLY (t), TYPE_VOLATILE (t));\n \n+    case CONSTRUCTOR:\n+      t = copy_node (t);\n+      CONSTRUCTOR_ELTS (t) = mapcar (CONSTRUCTOR_ELTS (t), func);\n+      return t;\n+\n     case RECORD_TYPE:\n       if (TYPE_PTRMEMFUNC_P (t))\n \treturn build_ptrmemfunc_type\n@@ -1673,20 +1679,20 @@ copy_to_permanent (t)\n {\n   register struct obstack *ambient_obstack = current_obstack;\n   register struct obstack *ambient_saveable_obstack = saveable_obstack;\n-  int resume;\n+  register struct obstack *ambient_expression_obstack = expression_obstack;\n \n   if (t == NULL_TREE || TREE_PERMANENT (t))\n     return t;\n \n   saveable_obstack = &permanent_obstack;\n   current_obstack = saveable_obstack;\n-  resume = suspend_momentary ();\n+  expression_obstack = saveable_obstack;\n \n   t = mapcar (t, perm_manip);\n \n-  resume_momentary (resume);\n   current_obstack = ambient_obstack;\n   saveable_obstack = ambient_saveable_obstack;\n+  expression_obstack = ambient_expression_obstack;\n \n   return t;\n }"}, {"sha": "8d77956c0643d96a075d22b06f40c6d07e784695", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 36, "deletions": 21, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=5156628f9ffcf3c94047a56fcde88849bce6cb4f", "patch": "@@ -83,7 +83,7 @@ require_complete_type (value)\n {\n   tree type;\n \n-  if (current_template_parms)\n+  if (processing_template_decl)\n     return value;\n \n   type = TREE_TYPE (value);\n@@ -132,8 +132,7 @@ complete_type (type)\n   else if (TREE_CODE (type) == ARRAY_TYPE && TYPE_DOMAIN (type))\n     {\n       tree t = complete_type (TREE_TYPE (type));\n-      if (TYPE_SIZE (t) != NULL_TREE\n-\t  && current_template_parms == NULL_TREE)\n+      if (TYPE_SIZE (t) != NULL_TREE && ! processing_template_decl)\n \tlayout_type (type);\n       TYPE_NEEDS_CONSTRUCTING (type)\n \t= TYPE_NEEDS_CONSTRUCTING (TYPE_MAIN_VARIANT (t));\n@@ -1275,7 +1274,7 @@ c_sizeof (type)\n   enum tree_code code = TREE_CODE (type);\n   tree t;\n \n-  if (current_template_parms)\n+  if (processing_template_decl)\n     return build_min (SIZEOF_EXPR, sizetype, type);\n \n   if (code == FUNCTION_TYPE)\n@@ -1341,7 +1340,7 @@ tree\n expr_sizeof (e)\n      tree e;\n {\n-  if (current_template_parms)\n+  if (processing_template_decl)\n     return build_min (SIZEOF_EXPR, sizetype, e);\n \n   if (TREE_CODE (e) == COMPONENT_REF\n@@ -1623,8 +1622,8 @@ build_object_ref (datum, basetype, field)\n     {\n       tree binfo = binfo_or_else (basetype, dtype);\n       if (binfo)\n-\treturn build_component_ref (build_scoped_ref (datum, basetype),\n-\t\t\t\t    field, binfo, 1);\n+\treturn build_x_component_ref (build_scoped_ref (datum, basetype),\n+\t\t\t\t      field, binfo, 1);\n     }\n   return error_mark_node;\n }\n@@ -1709,7 +1708,7 @@ build_component_ref (datum, component, basetype_path, protect)\n   register tree field = NULL;\n   register tree ref;\n \n-  if (current_template_parms)\n+  if (processing_template_decl)\n     return build_min_nt (COMPONENT_REF, datum, component);\n \n   /* If DATUM is a COMPOUND_EXPR or COND_EXPR, move our reference\n@@ -1937,6 +1936,22 @@ build_component_ref (datum, component, basetype_path, protect)\n \n   return ref;\n }\n+\n+/* Variant of build_component_ref for use in expressions, which should\n+   never have REFERENCE_TYPE.  */\n+\n+tree\n+build_x_component_ref (datum, component, basetype_path, protect)\n+     tree datum, component, basetype_path;\n+     int protect;\n+{\n+  tree t = build_component_ref (datum, component, basetype_path, protect);\n+\n+  if (! processing_template_decl)\n+    t = convert_from_reference (t);\n+\n+  return t;\n+}\n \f\n /* Given an expression PTR for a pointer, return an expression\n    for the value pointed to.\n@@ -1952,7 +1967,7 @@ build_x_indirect_ref (ptr, errorstring)\n {\n   tree rval;\n \n-  if (current_template_parms)\n+  if (processing_template_decl)\n     return build_min_nt (INDIRECT_REF, ptr);\n \n   rval = build_opfncall (INDIRECT_REF, LOOKUP_NORMAL, ptr, NULL_TREE, NULL_TREE);\n@@ -2213,7 +2228,7 @@ build_x_function_call (function, params, decl)\n   if (function == error_mark_node)\n     return error_mark_node;\n \n-  if (current_template_parms)\n+  if (processing_template_decl)\n     return build_min_nt (CALL_EXPR, function, params, NULL_TREE);\n \n   type = TREE_TYPE (function);\n@@ -2908,7 +2923,7 @@ build_x_binary_op (code, arg1, arg2)\n {\n   tree rval;\n \n-  if (current_template_parms)\n+  if (processing_template_decl)\n     return build_min_nt (code, arg1, arg2);\n \n   if (flag_ansi_overloading)\n@@ -3958,7 +3973,7 @@ build_x_unary_op (code, xarg)\n      enum tree_code code;\n      tree xarg;\n {\n-  if (current_template_parms)\n+  if (processing_template_decl)\n     return build_min_nt (code, xarg, NULL_TREE);\n \n   /* & rec, on incomplete RECORD_TYPEs is the simple opr &, not an\n@@ -4005,7 +4020,7 @@ condition_conversion (expr)\n      tree expr;\n {\n   tree t;\n-  if (current_template_parms)\n+  if (processing_template_decl)\n     return expr;\n   t = convert (boolean_type_node, expr);\n   t = fold (build1 (CLEANUP_POINT_EXPR, boolean_type_node, t));\n@@ -4653,7 +4668,7 @@ build_x_conditional_expr (ifexp, op1, op2)\n {\n   tree rval = NULL_TREE;\n \n-  if (current_template_parms)\n+  if (processing_template_decl)\n     return build_min_nt (COND_EXPR, ifexp, op1, op2);\n \n   if (flag_ansi_overloading)\n@@ -4988,7 +5003,7 @@ build_x_compound_expr (list)\n   tree rest = TREE_CHAIN (list);\n   tree result;\n \n-  if (current_template_parms)\n+  if (processing_template_decl)\n     return build_min_nt (COMPOUND_EXPR, list, NULL_TREE);\n \n   if (rest == NULL_TREE)\n@@ -5068,7 +5083,7 @@ build_static_cast (type, expr)\n   if (TREE_CODE (expr) == OFFSET_REF)\n     expr = resolve_offset_ref (expr);\n \n-  if (current_template_parms)\n+  if (processing_template_decl)\n     {\n       tree t = build_min (STATIC_CAST_EXPR, type, expr);\n       return t;\n@@ -5160,7 +5175,7 @@ build_reinterpret_cast (type, expr)\n   if (TREE_CODE (expr) == OFFSET_REF)\n     expr = resolve_offset_ref (expr);\n \n-  if (current_template_parms)\n+  if (processing_template_decl)\n     {\n       tree t = build_min (REINTERPRET_CAST_EXPR, type, expr);\n       return t;\n@@ -5252,7 +5267,7 @@ build_const_cast (type, expr)\n   if (TREE_CODE (expr) == OFFSET_REF)\n     expr = resolve_offset_ref (expr);\n \n-  if (current_template_parms)\n+  if (processing_template_decl)\n     {\n       tree t = build_min (CONST_CAST_EXPR, type, expr);\n       return t;\n@@ -5361,7 +5376,7 @@ build_c_cast (type, expr, allow_nonconverting)\n       return error_mark_node;\n     }\n \n-  if (current_template_parms)\n+  if (processing_template_decl)\n     {\n       tree t = build_min (CAST_EXPR, type,\n \t\t\t  min_tree_cons (NULL_TREE, value, NULL_TREE));\n@@ -5993,7 +6008,7 @@ build_x_modify_expr (lhs, modifycode, rhs)\n      enum tree_code modifycode;\n      tree rhs;\n {\n-  if (current_template_parms)\n+  if (processing_template_decl)\n     return build_min_nt (MODOP_EXPR, lhs,\n \t\t\t build_min_nt (modifycode, NULL_TREE, NULL_TREE), rhs);\n \n@@ -7022,7 +7037,7 @@ c_expand_return (retval)\n       return;\n     }\n \n-  if (current_template_parms)\n+  if (processing_template_decl)\n     {\n       add_tree (build_min_nt (RETURN_STMT, retval));\n       return;"}, {"sha": "786ca79706ccd4cd258f5cde6c5283565ef0a854", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5156628f9ffcf3c94047a56fcde88849bce6cb4f/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=5156628f9ffcf3c94047a56fcde88849bce6cb4f", "patch": "@@ -607,6 +607,10 @@ store_init_value (decl, init)\n \t}\n     }\n \n+  if (TYPE_PTRMEMFUNC_P (type) && TREE_CODE (init) == CONSTRUCTOR\n+      && TREE_TYPE (init) == NULL_TREE)\n+    cp_pedwarn (\"initializer list for `%T'\", type);\n+\n   /* End of special C++ code.  */\n \n   /* Digest the specified initializer into an expression.  */\n@@ -1011,9 +1015,6 @@ process_init_constructor (type, init, elts)\n \t      sorry (\"initializer list for object using virtual functions\");\n \t      return error_mark_node;\n \t    }\n-\n-\t  if (TYPE_PTRMEMFUNC_P (type))\n-\t    cp_pedwarn (\"initializer list for `%T'\", type);\n \t}\n \n       for (field = TYPE_FIELDS (type); field && tail;\n@@ -1262,7 +1263,7 @@ build_x_arrow (datum)\n   if (type == error_mark_node)\n     return error_mark_node;\n \n-  if (current_template_parms)\n+  if (processing_template_decl)\n     return build_min_nt (ARROW_EXPR, rval);\n \n   if (TREE_CODE (rval) == OFFSET_REF)\n@@ -1338,7 +1339,7 @@ build_m_component_ref (datum, component)\n   tree rettype;\n   tree binfo;\n \n-  if (current_template_parms)\n+  if (processing_template_decl)\n     return build_min_nt (DOTSTAR_EXPR, datum, component);\n \n   if (TYPE_PTRMEMFUNC_P (TREE_TYPE (component)))\n@@ -1423,7 +1424,7 @@ build_functional_cast (exp, parms)\n   else\n     type = exp;\n \n-  if (current_template_parms)\n+  if (processing_template_decl)\n     return build_min (CAST_EXPR, type, parms);\n \n   if (IS_SIGNATURE (type))"}]}