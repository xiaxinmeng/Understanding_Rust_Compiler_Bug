{"sha": "6725c4029dc1436d1c8e734d67c6518c96556a4b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjcyNWM0MDI5ZGMxNDM2ZDFjOGU3MzRkNjdjNjUxOGM5NjU1NmE0Yg==", "commit": {"author": {"name": "Hans-Peter Nilsson", "email": "hp@gcc.gnu.org", "date": "2007-12-15T21:37:55Z"}, "committer": {"name": "Hans-Peter Nilsson", "email": "hp@gcc.gnu.org", "date": "2007-12-15T21:37:55Z"}, "message": "cris.h: Sanity-check TARGET_CPU_DEFAULT for contents.\n\n\t* config/cris/cris.h: Sanity-check TARGET_CPU_DEFAULT for contents.\n\t(CRIS_DEFAULT_TUNE, CRIS_ARCH_CPP_DEFAULT)\n\t(CRIS_DEFAULT_ASM_ARCH_OPTION): New macros.\n\t(CRIS_CC1_SUBTARGET_SPEC): Change default tuning to use\n\tCRIS_DEFAULT_TUNE. \n\t(CRIS_CPP_SUBTARGET_SPEC): Ditto.  Add CRIS_ARCH_CPP_DEFAULT.\n\t(ASM_SPEC): Add sanity-check erroring out when both -march= and\n\t-mcpu= are specified.  Pass on either as --march=v32.\n\t(CRIS_ASM_SUBTARGET_SPEC): When neither -march= or -mcpu= are\n\tspecified, pass on CRIS_DEFAULT_ASM_ARCH_OPTION.\n\t(CRIS_CPU_V32): New macro.\n\t[!TARGET_CPU_DEFAULT]: Default-define as CRIS_CPU_BASE.\n\t[!TARGET_DEFAULT, TARGET_CPU_DEFAULT == 32]: Move default\n\tTARGET_DEFAULT definition after new TARGET_CPU_DEFAULT definition.\n\tDefine v32-adjusted TARGET_DEFAULT.\n\t(CRIS_DEFAULT_CPU_VERSION): Change to TARGET_CPU_DEFAULT from\n\tCRIS_CPU_BASE.\n\t(TARGET_V32): New macro.\n\t(REG_ALLOC_ORDER_V32): New macro.\n\t(HARD_REGNO_MODE_OK): Do not allow larger-than-register-size modes\n\tinto CRIS_ACR_REGNUM.\n\t(enum reg_class): New classes ACR_REGS, SPEC_ACR_REGS,\n\tGENNONACR_REGS and SPEC_GENNONACR_REGS.\n\t(REG_CLASS_NAMES, REG_CLASS_CONTENTS): Adjust for new classes.\n\t(REGNO_REG_CLASS): Give ACR_REGS for CRIS_ACR_REGNUM.\n\t(MODE_CODE_BASE_REG_CLASS): Define, give for OCODE POST_INC\n\tGENNONACR_REGS, BASE_REG_CLASS otherwise.\n\t(REG_CLASS_FROM_LETTER): 'a' is for ACR_REGS.\n\t(REGNO_MODE_CODE_OK_FOR_BASE_P): Define, refusing OCODE POST_INC\n\tfor CRIS_ACR_REGNUM.\n\t(PREFERRED_RELOAD_CLASS): Keep ACR_REGS as preferred.\n\t(HARD_REGNO_RENAME_OK): Refuse CRIS_ACR_REGNUM as TO.\n\t(EXTRA_CONSTRAINT): New constraint 'U'.\n\t(TRAMPOLINE_TEMPLATE, TRAMPOLINE_SIZE, INITIALIZE_TRAMPOLINE)\n\t(ASM_OUTPUT_ADDR_DIFF_ELT): Adjust for CRIS v32.\n\t(BASE_OR_AUTOINCR_P): Refuse POST_INC for CRIS_ACR_REGNUM.\n\t(SIMPLE_ADDRESS_P): Remove.\n\t(GO_IF_LEGITIMATE_ADDRESS): Use BASE_OR_AUTOINCR_P, not redundant\n\tSIMPLE_ADDRESS_P.  Make one chained if-else, finishing as\n\tnon-match after BASE_OR_AUTOINCR_P for TARGET_V32.\n\t(REGISTER_MOVE_COST): Just call the new function\n\tcris_register_move_cost.\n\t(enum cris_pic_symbol_type): Rename cris_gotrel_symbol to\n\tcris_rel_symbol.  All users changed.\n\t(REGISTER_NAMES): Replace \"pc\" with \"acr\".\n\t(ADDITIONAL_REGISTER_NAMES): Add \"pc\" for 15.\n\t(ASM_OUTPUT_REG_PUSH): Change to v32-compatible sequence.\n\t(ASM_OUTPUT_REG_POP): Change to v32-compatible syntax.\n\t(ASM_OUTPUT_CASE_END): Just call the new function\n\tcris_asm_output_case_end.\n\nFrom-SVN: r130970", "tree": {"sha": "9740a1d14a05702f65be0f85ea29cc39df677abf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9740a1d14a05702f65be0f85ea29cc39df677abf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6725c4029dc1436d1c8e734d67c6518c96556a4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6725c4029dc1436d1c8e734d67c6518c96556a4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6725c4029dc1436d1c8e734d67c6518c96556a4b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6725c4029dc1436d1c8e734d67c6518c96556a4b/comments", "author": null, "committer": null, "parents": [{"sha": "39ecc4b530b5898afe646f82ec3a7bdbf2063afe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39ecc4b530b5898afe646f82ec3a7bdbf2063afe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39ecc4b530b5898afe646f82ec3a7bdbf2063afe"}], "stats": {"total": 345, "additions": 239, "deletions": 106}, "files": [{"sha": "1edd138cb8eb7feb96430dfab1aca41ce2f6882a", "filename": "gcc/config/cris/cris.h", "status": "modified", "additions": 239, "deletions": 106, "changes": 345, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6725c4029dc1436d1c8e734d67c6518c96556a4b/gcc%2Fconfig%2Fcris%2Fcris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6725c4029dc1436d1c8e734d67c6518c96556a4b/gcc%2Fconfig%2Fcris%2Fcris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.h?ref=6725c4029dc1436d1c8e734d67c6518c96556a4b", "patch": "@@ -131,10 +131,42 @@ extern int cris_cpu_version;\n   %(cpp_subtarget)\"\n \n /* For the cris-*-elf subtarget.  */\n+\n+#define CRIS_DEFAULT_TUNE \"10\"\n+#define CRIS_ARCH_CPP_DEFAULT\n+#define CRIS_DEFAULT_ASM_ARCH_OPTION \"\"\n+\n+#ifdef TARGET_CPU_DEFAULT\n+#if TARGET_CPU_DEFAULT != 32 && TARGET_CPU_DEFAULT != 10\n+ #error \"Due to '()'; e.g. '#define TARGET_CPU_DEFAULT (10)', stringize TARGET_CPU_DEFAULT isn't useful: update manually.\"\n+#endif\n+\n+#if TARGET_CPU_DEFAULT == 32\n+#undef CRIS_DEFAULT_TUNE\n+#define CRIS_DEFAULT_TUNE \"32\"\n+/* To enable use of \"generic\" cris-axis-elf binutils, always pass the\n+   architecture option to GAS.  (We don't do this for non-v32.)  */\n+#undef CRIS_DEFAULT_ASM_ARCH_OPTION\n+#define CRIS_DEFAULT_ASM_ARCH_OPTION \"--march=v32\"\n+#endif\n+\n+#undef CRIS_ARCH_CPP_DEFAULT\n+#define CRIS_ARCH_CPP_DEFAULT \\\n+ \"%{!march=*:\\\n+   %{!metrax*:\\\n+    %{!mcpu=*:\\\n+     %{!mtune=*:-D__tune_v\" CRIS_DEFAULT_TUNE \"}\\\n+     -D__arch_v\"CRIS_DEFAULT_TUNE\\\n+   \" -D__CRIS_arch_version=\" CRIS_DEFAULT_TUNE \"}}}\"\n+#endif\n+\n #define CRIS_CPP_SUBTARGET_SPEC \\\n  \"%{mbest-lib-options:\\\n    %{!moverride-best-lib-options:\\\n-    %{!march=*:%{!metrax*:%{!mcpu=*:-D__tune_v10 -D__CRIS_arch_tune=10}}}}}\"\n+   %{!march=*:%{!metrax*:%{!mcpu=*:\\\n+      -D__tune_v\" CRIS_DEFAULT_TUNE \\\n+    \" -D__CRIS_arch_tune=\" CRIS_DEFAULT_TUNE \"}}}}}\"\\\n+ CRIS_ARCH_CPP_DEFAULT\n \n /* Remove those Sun-make \"target\" switches.  */\n /* Override previous definitions (linux.h).  */\n@@ -150,7 +182,8 @@ extern int cris_cpu_version;\n  \"-melf\\\n   %{mbest-lib-options:\\\n    %{!moverride-best-lib-options:\\\n-    %{!march=*:%{!mcpu=*:-mtune=v10 -D__CRIS_arch_tune=10}}\\\n+   %{!march=*:%{!mcpu=*:-mtune=v\" CRIS_DEFAULT_TUNE\\\n+       \" -D__CRIS_arch_tune=\" CRIS_DEFAULT_TUNE \"}}\\\n     %{!finhibit-size-directive:\\\n       %{!fno-function-sections: -ffunction-sections}\\\n       %{!fno-data-sections: -fdata-sections}}}}\"\n@@ -174,10 +207,13 @@ extern int cris_cpu_version;\n #define ASM_SPEC \\\n  MAYBE_AS_NO_MUL_BUG_ABORT \\\n  \"%{v:-v}\\\n-  %(asm_subtarget)\"\n+ %(asm_subtarget)\\\n+ %{march=*:%{cpu=*:%eDo not specify both -march=... and -mcpu=...}}\\\n+ %{march=v32:--march=v32} %{mcpu=v32:--march=v32}\"\n \n /* For the cris-*-elf subtarget.  */\n-#define CRIS_ASM_SUBTARGET_SPEC \"--em=criself\"\n+#define CRIS_ASM_SUBTARGET_SPEC \\\n+ \"--em=criself %{!march=*:%{!cpu=*:\" CRIS_DEFAULT_ASM_ARCH_OPTION \"}}\"\n \n /* FIXME: We should propagate the -melf option to make the criself\n    \"emulation\" unless a linker script is provided (-T*), but I don't know\n@@ -258,28 +294,41 @@ extern int target_flags;\n    for -melinux.  */\n #define TARGET_LINUX 0\n \n-/* Default target_flags if no switches specified.  */\n-#ifndef TARGET_DEFAULT\n-# define TARGET_DEFAULT \\\n- (MASK_SIDE_EFFECT_PREFIXES + MASK_STACK_ALIGN \\\n-  + MASK_CONST_ALIGN + MASK_DATA_ALIGN \\\n-  + MASK_PROLOGUE_EPILOGUE + MASK_MUL_BUG)\n-#endif\n-\n /* For the cris-*-elf subtarget.  */\n #define CRIS_SUBTARGET_DEFAULT 0\n \n #define CRIS_CPU_BASE 0\n #define CRIS_CPU_ETRAX4 3\t/* Just lz added.  */\n #define CRIS_CPU_SVINTO 8\t/* Added swap, jsrc & Co., 32-bit accesses.  */\n #define CRIS_CPU_NG 10\t\t/* Added mul[su].  */\n+#define CRIS_CPU_V32 32\t\t/* Major changes.  */\n+\n+#ifndef TARGET_CPU_DEFAULT\n+#define TARGET_CPU_DEFAULT CRIS_CPU_BASE\n+#endif\n+\n+/* Default target_flags if no switches specified.  */\n+#ifndef TARGET_DEFAULT\n+# if TARGET_CPU_DEFAULT == 32\n+#  define TARGET_DEFAULT \\\n+ (MASK_STACK_ALIGN \\\n+  + MASK_CONST_ALIGN + MASK_DATA_ALIGN \\\n+  + MASK_PROLOGUE_EPILOGUE)\n+# else  /* 10 */\n+# define TARGET_DEFAULT \\\n+ (MASK_SIDE_EFFECT_PREFIXES + MASK_STACK_ALIGN \\\n+  + MASK_CONST_ALIGN + MASK_DATA_ALIGN \\\n+  + MASK_PROLOGUE_EPILOGUE + MASK_MUL_BUG)\n+# endif\n+#endif\n \n /* Local, providing a default for cris_cpu_version.  */\n-#define CRIS_DEFAULT_CPU_VERSION CRIS_CPU_BASE\n+#define CRIS_DEFAULT_CPU_VERSION TARGET_CPU_DEFAULT\n \n #define TARGET_HAS_MUL_INSNS (cris_cpu_version >= CRIS_CPU_NG)\n #define TARGET_HAS_LZ (cris_cpu_version >= CRIS_CPU_ETRAX4)\n #define TARGET_HAS_SWAP (cris_cpu_version >= CRIS_CPU_SVINTO)\n+#define TARGET_V32 (cris_cpu_version >= CRIS_CPU_V32)\n \n #define CRIS_SUBTARGET_HANDLE_OPTION(x, y, z)\n \n@@ -466,6 +515,13 @@ extern int target_flags;\n #define REG_ALLOC_ORDER \\\n  {9, 13, 12, 11, 10, 0, 1, 2, 3, 4, 5, 6, 7, 8, 14, 15, 17, 16, 18, 19}\n \n+/* Use MOF and ACR.  Prefer ACR before any other register.  Prefer MOF\n+   then SRP after saved registers.  The *after* is because they're only\n+   useful for storage, not for things being computed, which is\n+   apparently more common.  */\n+#define REG_ALLOC_ORDER_V32 \\\n+ {15, 9, 13, 12, 11, 10, 0, 1, 2, 3, 4, 5, 6, 7, 8, 17, 16, 14, 18, 19}\n+\n \n /* Node: Values in Registers */\n \n@@ -482,7 +538,7 @@ extern int target_flags;\n  (((MODE) == CCmode\t\t\t\t\\\n    || (REGNO) != CRIS_CC0_REGNUM)\t\t\\\n   && (GET_MODE_SIZE (MODE) <= UNITS_PER_WORD\t\\\n-      || (REGNO) != CRIS_MOF_REGNUM))\n+      || ((REGNO) != CRIS_MOF_REGNUM && (REGNO) != CRIS_ACR_REGNUM)))\n \n /* Because CCmode isn't covered by the \"narrower mode\" statement in\n    tm.texi, we can still say all modes are tieable despite not having an\n@@ -499,18 +555,30 @@ extern int target_flags;\n \n /* Node: Register Classes */\n \n-enum reg_class \n+/* FIXME: A separate class for the return register would make sense.\n+\n+   We need a separate register class to handle register allocation for\n+   ACR, since it can't be used for post-increment.\n+\n+   It's not obvious, but having subunions of all movable-between\n+   register classes does really help register allocation.  */\n+enum reg_class\n   {\n     NO_REGS,\n-    MOF_REGS, CC0_REGS, SPECIAL_REGS, GENERAL_REGS, ALL_REGS,\n+    ACR_REGS, MOF_REGS, CC0_REGS, SPECIAL_REGS,\n+    SPEC_ACR_REGS, GENNONACR_REGS,\n+    SPEC_GENNONACR_REGS, GENERAL_REGS,\n+    ALL_REGS,\n     LIM_REG_CLASSES\n   };\n \n #define N_REG_CLASSES (int) LIM_REG_CLASSES\n \n-#define REG_CLASS_NAMES\t\t\t\t\t\t\t\\\n-  {\"NO_REGS\",\t\t\t\t\t\t\t\t\\\n-   \"MOF_REGS\", \"CC0_REGS\", \"SPECIAL_REGS\", \"GENERAL_REGS\", \"ALL_REGS\"}\n+#define REG_CLASS_NAMES\t\t\t\t\t\t\\\n+  {\"NO_REGS\",\t\t\t\t\t\t\t\\\n+   \"ACR_REGS\", \"MOF_REGS\", \"CC0_REGS\", \"SPECIAL_REGS\",\t\t\\\n+   \"SPEC_ACR_REGS\", \"GENNONACR_REGS\", \"SPEC_GENNONACR_REGS\",\t\\\n+   \"GENERAL_REGS\", \"ALL_REGS\"}\n \n #define CRIS_SPECIAL_REGS_CONTENTS\t\t\t\t\t\\\n  ((1 << CRIS_SRP_REGNUM) | (1 << CRIS_MOF_REGNUM) | (1 << CRIS_CC0_REGNUM))\n@@ -519,26 +587,39 @@ enum reg_class\n #define REG_CLASS_CONTENTS\t\t\t\\\n   {\t\t\t\t\t\t\\\n    {0},\t\t\t\t\t\t\\\n+   {1 << CRIS_ACR_REGNUM},\t\t\t\\\n    {1 << CRIS_MOF_REGNUM},\t\t\t\\\n    {1 << CRIS_CC0_REGNUM},\t\t\t\\\n    {CRIS_SPECIAL_REGS_CONTENTS},\t\t\\\n+   {CRIS_SPECIAL_REGS_CONTENTS\t\t\t\\\n+    | (1 << CRIS_ACR_REGNUM)},\t\t\t\\\n+   {(0xffff | (1 << CRIS_AP_REGNUM))\t\t\\\n+    & ~(1 << CRIS_ACR_REGNUM)},\t\t\t\\\n+   {(0xffff | (1 << CRIS_AP_REGNUM)\t\t\\\n+    | CRIS_SPECIAL_REGS_CONTENTS)\t\t\\\n+    & ~(1 << CRIS_ACR_REGNUM)},\t\t\t\\\n    {0xffff | (1 << CRIS_AP_REGNUM)},\t\t\\\n    {0xffff | (1 << CRIS_AP_REGNUM)\t\t\\\n     | CRIS_SPECIAL_REGS_CONTENTS}\t\t\\\n   }\n \n #define REGNO_REG_CLASS(REGNO)\t\t\t\\\n-  ((REGNO) == CRIS_MOF_REGNUM ? MOF_REGS :\t\\\n+  ((REGNO) == CRIS_ACR_REGNUM ? ACR_REGS :\t\\\n+   (REGNO) == CRIS_MOF_REGNUM ? MOF_REGS :\t\\\n    (REGNO) == CRIS_CC0_REGNUM ? CC0_REGS :\t\\\n    (REGNO) == CRIS_SRP_REGNUM ? SPECIAL_REGS :\t\\\n    GENERAL_REGS)\n \n #define BASE_REG_CLASS GENERAL_REGS\n \n+#define MODE_CODE_BASE_REG_CLASS(MODE, OCODE, ICODE)\t\\\n+  ((OCODE) != POST_INC ? BASE_REG_CLASS : GENNONACR_REGS)\n+\n #define INDEX_REG_CLASS GENERAL_REGS\n \n #define REG_CLASS_FROM_LETTER(C)\t\t\\\n   (\t\t\t\t\t\t\\\n+   (C) == 'a' ? ACR_REGS :\t\t\t\\\n    (C) == 'h' ? MOF_REGS :\t\t\t\\\n    (C) == 'x' ? SPECIAL_REGS :\t\t\t\\\n    (C) == 'c' ? CC0_REGS :\t\t\t\\\n@@ -553,6 +634,14 @@ enum reg_class\n   || (unsigned) reg_renumber[REGNO] <= CRIS_LAST_GENERAL_REGISTER\t\\\n   || (unsigned) reg_renumber[REGNO] == ARG_POINTER_REGNUM)\n \n+/* REGNO_OK_FOR_BASE_P seems to be obsolete wrt. this one, but not yet\n+   documented as such.  */\n+#define REGNO_MODE_CODE_OK_FOR_BASE_P(REGNO, MODE, OCODE, ICODE)\t\\\n+ (REGNO_OK_FOR_BASE_P (REGNO)\t\t\t\t\t\t\\\n+  && ((OCODE) != POST_INC\t\t\t\t\t\t\\\n+      || !((REGNO) == CRIS_ACR_REGNUM\t\t\t\t\t\\\n+\t   || (unsigned) reg_renumber[REGNO] == CRIS_ACR_REGNUM)))\n+\n /* See REGNO_OK_FOR_BASE_P.  */\n #define REGNO_OK_FOR_INDEX_P(REGNO) REGNO_OK_FOR_BASE_P(REGNO)\n \n@@ -565,7 +654,8 @@ enum reg_class\n    they need to be reloaded.  FIXME: Investigate whether that constitutes\n    a bug.  */\n #define PREFERRED_RELOAD_CLASS(X, CLASS)\t\\\n- ((CLASS) != MOF_REGS\t\t\t\t\\\n+ ((CLASS) != ACR_REGS\t\t\t\t\\\n+  && (CLASS) != MOF_REGS\t\t\t\\\n   && (CLASS) != CC0_REGS\t\t\t\\\n   && (CLASS) != SPECIAL_REGS\t\t\t\\\n   ? GENERAL_REGS : (CLASS))\n@@ -578,6 +668,11 @@ enum reg_class\n    || !MEM_P (X)\t\t\t\t\t\\\n    ? NO_REGS : GENERAL_REGS)\n \n+/* FIXME: Fix regrename.c; it should check validity of replacements,\n+   not just with a silly pass-specific macro.  We may miss some\n+   opportunities, but we must stop regrename from creating acr++.  */\n+#define HARD_REGNO_RENAME_OK(FROM, TO) ((TO) != CRIS_ACR_REGNUM)\n+\n /* For CRIS, this is always the size of MODE in words,\n    since all registers are the same size.  To use omitted modes in\n    patterns with reload constraints, you must say the widest size\n@@ -632,6 +727,8 @@ enum reg_class\n   (C) == 'S' ? EXTRA_CONSTRAINT_S (X) :\t\t\\\n   /* A three-address addressing-mode?  */\t\\\n   (C) == 'T' ? EXTRA_CONSTRAINT_T (X) :\t\t\\\n+  /* A PLT symbol?  */\t\t\t\t\\\n+  (C) == 'U' ? EXTRA_CONSTRAINT_U (X) :\t\t\\\n   0)\n \n #define EXTRA_MEMORY_CONSTRAINT(X, STR) ((X) == 'Q')\n@@ -683,7 +780,12 @@ enum reg_class\n \n /* PIC-constructs for symbols.  */\n #define EXTRA_CONSTRAINT_S(X)\t\t\t\t\t\t\\\n- (flag_pic && GET_CODE (X) == CONST && cris_valid_pic_const (X))\n+ (flag_pic && GET_CODE (X) == CONST && cris_valid_pic_const (X, false))\n+\n+#define EXTRA_CONSTRAINT_U(X)\t\t\t\t\t\t\\\n+ (flag_pic\t\t\t\t\t\t\t\t\\\n+  && CONSTANT_P (X)\t\t\t\t\t\t\t\\\n+  && cris_nonmemory_operand_or_callable_symbol (X, VOIDmode))\n \n \n /* Node: Frame Layout */\n@@ -877,39 +979,95 @@ struct cum_args {int regs;};\n    somewhat lack of elegance.\n     (Do not be tempted to \"straighten up\" whitespace in the asms; the\n    assembler #NO_APP state mandates strict spacing).  */\n-#define TRAMPOLINE_TEMPLATE(FILE)\t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\tmove.d $%s,[$pc+20]\\n\",\t\\\n-\t       reg_names[STATIC_CHAIN_REGNUM]);\t\\\n-      fprintf (FILE, \"\\tmove $srp,[$pc+22]\\n\");\t\\\n-      fprintf (FILE, \"\\tmove.d 0,$%s\\n\",\t\\\n-\t       reg_names[STATIC_CHAIN_REGNUM]);\t\\\n-      fprintf (FILE, \"\\tjsr 0\\n\");\t\t\\\n-      fprintf (FILE, \"\\tmove.d 0,$%s\\n\",\t\\\n-\t       reg_names[STATIC_CHAIN_REGNUM]);\t\\\n-      fprintf (FILE, \"\\tjump 0\\n\");\t\t\\\n-    }\t\t\t\t\t\t\\\n+#define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\t       \\\n+  do\t\t\t\t\t\t\t\t       \\\n+    {\t\t\t\t\t\t\t\t       \\\n+      if (TARGET_V32)\t\t\t\t\t\t       \\\n+       {\t\t\t\t\t\t\t       \\\n+\t /* This normally-unused nop insn acts as an instruction to    \\\n+\t    the simulator to flush its instruction cache.  None of     \\\n+\t    the other instructions in the trampoline template suits    \\\n+\t    as a trigger for V32.  The pc-relative addressing mode     \\\n+\t    works nicely as a trigger for V10.\t\t\t       \\\n+\t    FIXME: Have specific V32 template (possibly avoiding the   \\\n+\t    use of a special instruction).  */\t\t\t       \\\n+\t fprintf (FILE, \"\\tclearf x\\n\");\t\t\t       \\\n+\t /* We have to use a register as an intermediate, choosing     \\\n+\t    semi-randomly R1 (which has to not be the\t\t       \\\n+\t    STATIC_CHAIN_REGNUM), so we can use it for address\t       \\\n+\t    indirection and jsr target.\t */\t\t\t       \\\n+\t fprintf (FILE, \"\\tmove $r1,$mof\\n\");\t\t\t       \\\n+\t /* +4 */\t\t\t\t\t\t       \\\n+\t fprintf (FILE, \"\\tmove.d 0,$r1\\n\");\t\t\t       \\\n+\t fprintf (FILE, \"\\tmove.d $%s,[$r1]\\n\",\t\t\t       \\\n+\t\t  reg_names[STATIC_CHAIN_REGNUM]);\t\t       \\\n+\t fprintf (FILE, \"\\taddq 6,$r1\\n\");\t\t\t       \\\n+\t fprintf (FILE, \"\\tmove $mof,[$r1]\\n\");\t\t\t       \\\n+\t fprintf (FILE, \"\\taddq 6,$r1\\n\");\t\t\t       \\\n+\t fprintf (FILE, \"\\tmove $srp,[$r1]\\n\");\t\t\t       \\\n+\t /* +20 */\t\t\t\t\t\t       \\\n+\t fprintf (FILE, \"\\tmove.d 0,$%s\\n\",\t\t\t       \\\n+\t\t  reg_names[STATIC_CHAIN_REGNUM]);\t\t       \\\n+\t /* +26 */\t\t\t\t\t\t       \\\n+\t fprintf (FILE, \"\\tmove.d 0,$r1\\n\");\t\t\t       \\\n+\t fprintf (FILE, \"\\tjsr $r1\\n\");\t\t\t\t       \\\n+\t fprintf (FILE, \"\\tsetf\\n\");\t\t\t\t       \\\n+\t /* +36 */\t\t\t\t\t\t       \\\n+\t fprintf (FILE, \"\\tmove.d 0,$%s\\n\",\t\t\t       \\\n+\t\t  reg_names[STATIC_CHAIN_REGNUM]);\t\t       \\\n+\t /* +42 */\t\t\t\t\t\t       \\\n+\t fprintf (FILE, \"\\tmove.d 0,$r1\\n\");\t\t\t       \\\n+\t /* +48 */\t\t\t\t\t\t       \\\n+\t fprintf (FILE, \"\\tmove.d 0,$r9\\n\");\t\t\t       \\\n+\t fprintf (FILE, \"\\tjump $r9\\n\");\t\t\t       \\\n+\t fprintf (FILE, \"\\tsetf\\n\");\t\t\t\t       \\\n+       }\t\t\t\t\t\t\t       \\\n+      else\t\t\t\t\t\t\t       \\\n+       {\t\t\t\t\t\t\t       \\\n+\t fprintf (FILE, \"\\tmove.d $%s,[$pc+20]\\n\",\t\t       \\\n+\t\t  reg_names[STATIC_CHAIN_REGNUM]);\t\t       \\\n+\t fprintf (FILE, \"\\tmove $srp,[$pc+22]\\n\");\t\t       \\\n+\t fprintf (FILE, \"\\tmove.d 0,$%s\\n\",\t\t\t       \\\n+\t\t  reg_names[STATIC_CHAIN_REGNUM]);\t\t       \\\n+\t fprintf (FILE, \"\\tjsr 0\\n\");\t\t\t\t       \\\n+\t fprintf (FILE, \"\\tmove.d 0,$%s\\n\",\t\t\t       \\\n+\t\t  reg_names[STATIC_CHAIN_REGNUM]);\t\t       \\\n+\t fprintf (FILE, \"\\tjump 0\\n\");\t\t\t\t       \\\n+       }\t\t\t\t\t\t\t       \\\n+    }\t\t\t\t\t\t\t\t       \\\n   while (0)\n \n-#define TRAMPOLINE_SIZE 32\n+#define TRAMPOLINE_SIZE (TARGET_V32 ? 58 : 32)\n \n /* CRIS wants instructions on word-boundary.\n    Note that due to a bug (reported) in 2.7.2 and earlier, this is\n    actually treated as alignment in _bytes_, not _bits_.  (Obviously\n    this is not fatal, only a slight waste of stack space).  */\n #define TRAMPOLINE_ALIGNMENT 16\n \n-#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\\\n-  do\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      emit_move_insn (gen_rtx_MEM (SImode,\t\t\t\\\n-\t\t\t       plus_constant (TRAMP, 10)),\t\\\n-\t\t      CXT);\t\t\t\t\t\\\n-      emit_move_insn (gen_rtx_MEM (SImode,\t\t\t\\\n-\t\t\t       plus_constant (TRAMP, 16)),\t\\\n-\t\t      FNADDR);\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n+#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    if (TARGET_V32)\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\temit_move_insn (gen_rtx_MEM (SImode,\t\t\t\t\\\n+\t\t\t\t     plus_constant (TRAMP, 6)),\t\t\\\n+\t\t \tplus_constant (TRAMP, 38));\t\t\t\\\n+\temit_move_insn (gen_rtx_MEM (SImode,\t\t\t\t\\\n+\t\t\t\t     plus_constant (TRAMP, 22)),\t\\\n+\t\t\tCXT);\t\t\t\t\t\t\\\n+\temit_move_insn (gen_rtx_MEM (SImode,\t\t\t\t\\\n+\t\t\t\t     plus_constant (TRAMP, 28)),\t\\\n+\t\t \tFNADDR);\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\temit_move_insn (gen_rtx_MEM (SImode,\t\t\t\t\\\n+\t\t\t\t     plus_constant (TRAMP, 10)),\t\\\n+\t\t\tCXT);\t\t\t\t\t\t\\\n+\temit_move_insn (gen_rtx_MEM (SImode,\t\t\t\t\\\n+\t\t\t\t     plus_constant (TRAMP, 16)),\t\\\n+\t\t \tFNADDR);\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n   while (0)\n \n /* Note that there is no need to do anything with the cache for sake of\n@@ -929,6 +1087,8 @@ struct cum_args {int regs;};\n \n #define CONSTANT_ADDRESS_P(X) CONSTANT_P (X)\n \n+/* Must be a compile-time constant, so we go with the highest value\n+   among all CRIS variants.  */\n #define MAX_REGS_PER_ADDRESS 2\n \n /* There are helper macros defined here which are used only in\n@@ -945,15 +1105,18 @@ struct cum_args {int regs;};\n /* No symbol can be used as an index (or more correct, as a base) together\n    with a register with PIC; the PIC register must be there.  */\n #define CONSTANT_INDEX_P(X) \\\n- (CONSTANT_P (X) && (!flag_pic || cris_valid_pic_const (X)))\n+ (CONSTANT_P (X) && (!flag_pic || cris_valid_pic_const (X, true)))\n \n /* True if X is a valid base register.  */\n #define BASE_P(X) \\\n  (REG_P (X) && REG_OK_FOR_BASE_P (X))\n \n /* True if X is a valid base register with or without autoincrement.  */\n-#define BASE_OR_AUTOINCR_P(X) \\\n- (BASE_P (X) || (GET_CODE (X) == POST_INC && BASE_P (XEXP (X, 0))))\n+#define BASE_OR_AUTOINCR_P(X)\t\t\t\t\\\n+ (BASE_P (X)\t\t\t\t\t\t\\\n+  || (GET_CODE (X) == POST_INC\t\t\t\t\\\n+      && BASE_P (XEXP (X, 0))\t\t\t\t\\\n+      && REGNO (XEXP (X, 0)) != CRIS_ACR_REGNUM))\n \n /* True if X is a valid (register) index for BDAP, i.e. [Rs].S or [Rs+].S.  */\n #define BDAP_INDEX_P(X)\t\t\t\t\t\\\n@@ -975,12 +1138,6 @@ struct cum_args {int regs;};\n       && (INTVAL (XEXP (X, 1)) == 2\t\t\\\n \t  || INTVAL (XEXP (X, 1)) == 4)))\n \n-/* True if X is an address that doesn't need a prefix i.e. [Rs] or [Rs+].  */\n-#define SIMPLE_ADDRESS_P(X)\t\\\n- (BASE_P (X)\t\t\t\\\n-  || (GET_CODE (X) == POST_INC\t\\\n-      && BASE_P (XEXP (X, 0))))\n-\n /* A PIC operand looks like a normal symbol here.  At output we dress it\n    in \"[rPIC+symbol:GOT]\" (global symbol) or \"rPIC+symbol:GOTOFF\" (local\n    symbol) so we exclude all addressing modes where we can't replace a\n@@ -990,12 +1147,15 @@ struct cum_args {int regs;};\n #define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\t\\\n  {\t\t\t\t\t\t\t\t\\\n    rtx x1, x2;\t\t\t\t\t\t\t\\\n-   if (SIMPLE_ADDRESS_P (X))\t\t\t\t\t\\\n+   if (BASE_OR_AUTOINCR_P (X))\t\t\t\t\t\\\n      goto ADDR;\t\t\t\t\t\t\t\\\n-   if (CONSTANT_INDEX_P (X))\t\t\t\t\t\\\n+   else if (TARGET_V32)\t\t\t\t\t\t\\\n+     /* Nothing else is valid then.  */\t\t\t\t\\\n+     ;\t\t\t\t\t\t\t\t\\\n+   else if (CONSTANT_INDEX_P (X))\t\t\t\t\\\n      goto ADDR;\t\t\t\t\t\t\t\\\n    /* Indexed?  */\t\t\t\t\t\t\\\n-   if (GET_CODE (X) == PLUS)\t\t\t\t\t\\\n+   else if (GET_CODE (X) == PLUS)\t\t\t\t\\\n      {\t\t\t\t\t\t\t\t\\\n        x1 = XEXP (X, 0);\t\t\t\t\t\\\n        x2 = XEXP (X, 1);\t\t\t\t\t\\\n@@ -1081,32 +1241,8 @@ struct cum_args {int regs;};\n \n /* Node: Costs */\n \n-/* Can't move to and from a SPECIAL_REGS register, so we have to say\n-   their move cost within that class is higher.  How about 7?  That's 3\n-   for a move to a GENERAL_REGS register, 3 for the move from the\n-   GENERAL_REGS register, and 1 for the increased register pressure.\n-   Also, it's higher than the memory move cost, which is in order.  \n-   We also do this for ALL_REGS, since we don't want that class to be\n-   preferred (even to memory) at all where GENERAL_REGS doesn't fit.\n-   Whenever it's about to be used, it's for SPECIAL_REGS.  If we don't\n-   present a higher cost for ALL_REGS than memory, a SPECIAL_REGS may be\n-   used when a GENERAL_REGS should be used, even if there are call-saved\n-   GENERAL_REGS left to allocate.  This is because the fall-back when\n-   the most preferred register class isn't available, isn't the next\n-   (or next good) wider register class, but the *most widest* register\n-   class.\n-   Give the cost 3 between a special register and a general register,\n-   because we want constraints verified.  */\n-\n-#define REGISTER_MOVE_COST(MODE, FROM, TO)\t\t\\\n- ((((FROM) == SPECIAL_REGS || (FROM) == MOF_REGS)\t\\\n-   && ((TO) == SPECIAL_REGS || (TO) == MOF_REGS))\t\\\n-  || (FROM) == ALL_REGS\t\t\t\t\t\\\n-  || (TO) == ALL_REGS\t\t\t\t\t\\\n-  ? 7 :\t\t\t\t\t\t\t\\\n-  ((FROM) == SPECIAL_REGS || (FROM) == MOF_REGS\t\t\\\n-   || (TO) == SPECIAL_REGS || (TO) == MOF_REGS)\t\t\\\n-  ? 3 : 2)\n+#define REGISTER_MOVE_COST(MODE, FROM, TO)\t\\\n+  cris_register_move_cost (MODE, FROM, TO)\n \n /* This isn't strictly correct for v0..3 in buswidth-8bit mode, but\n    should suffice.  */\n@@ -1146,7 +1282,7 @@ enum cris_pic_symbol_type\n   {\n     cris_no_symbol = 0,\n     cris_got_symbol = 1,\n-    cris_gotrel_symbol = 2,\n+    cris_rel_symbol = 2,\n     cris_got_symbol_needing_fixup = 3,\n     cris_invalid_pic_symbol = 4\n   };\n@@ -1264,10 +1400,10 @@ enum cris_pic_symbol_type\n \n #define REGISTER_NAMES\t\t\t\t\t\\\n  {\"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\", \"r8\",\t\\\n-  \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"sp\", \"pc\", \"srp\", \"mof\", \"faked_ap\", \"dccr\"}\n+  \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"sp\", \"acr\", \"srp\", \"mof\", \"faked_ap\", \"dccr\"}\n \n #define ADDITIONAL_REGISTER_NAMES \\\n- {{\"r14\", 14}, {\"r15\", 15}}\n+ {{\"r14\", 14}, {\"r15\", 15}, {\"pc\", 15}}\n \n #define PRINT_OPERAND(FILE, X, CODE)\t\t\\\n  cris_print_operand (FILE, X, CODE)\n@@ -1297,17 +1433,27 @@ enum cris_pic_symbol_type\n #undef USER_LABEL_PREFIX\n #define USER_LABEL_PREFIX \"_\"\n \n-#define ASM_OUTPUT_REG_PUSH(FILE, REGNO) \\\n-  fprintf (FILE, \"\\tpush $%s\\n\", reg_names[REGNO])\n+#define ASM_OUTPUT_REG_PUSH(FILE, REGNO)\t\t\t\t\\\n+  fprintf (FILE,\t\t\t\t\t\t\t\\\n+\t   TARGET_V32\t\t\t\t\t\t\t\\\n+\t   ? \"\\tsubq 4,$sp\\n\\tmove $%s,[$sp]\\n\" : \"\\tpush $%s\\n\",\t\\\n+\t   reg_names[REGNO])\n \n #define ASM_OUTPUT_REG_POP(FILE, REGNO) \\\n-  fprintf (FILE, \"\\tpop $%s\\n\", reg_names[REGNO])\n+  fprintf (FILE, \"\\tmove [$sp+],$%s\\n\", reg_names[REGNO])\n \n \n /* Node: Dispatch Tables */\n \n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)\t\\\n-  asm_fprintf (FILE, \"\\t.word %LL%d-%LL%d\\n\", VALUE, REL)\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (TARGET_V32)\t\t\t\t\t\t\t\\\n+       asm_fprintf (FILE, \"\\t.word %LL%d-.\\n\", VALUE);\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+       asm_fprintf (FILE, \"\\t.word %LL%d-%LL%d\\n\", VALUE, REL);\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n #define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n   asm_fprintf (FILE, \"\\t.dword %LL%d\\n\", VALUE)\n@@ -1322,20 +1468,7 @@ enum cris_pic_symbol_type\n    the expanded casesi core-insn.\n    FIXME: Check this construct when changing to new version of gcc.  */\n #define ASM_OUTPUT_CASE_END(STREAM, NUM, TABLE)\t\t\t\t\\\n-  do\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      asm_fprintf (STREAM, \"\\t.word %LL%d-%LL%d%s\\n\",\t\t\t\\\n-\t\t   CODE_LABEL_NUMBER\t\t\t\t\t\\\n-\t\t    (XEXP (XEXP (XEXP\t\t\t\t\t\\\n-\t\t\t\t  (XVECEXP\t\t\t\t\\\n-\t\t\t\t    (PATTERN\t\t\t\t\\\n-\t\t\t\t     (prev_nonnote_insn\t\t\t\\\n-\t\t\t\t      (PREV_INSN (TABLE))),\t\t\\\n-\t\t\t\t     0, 0), 1), 2), 0)),\t\t\\\n-\t\t   NUM,\t\t\t\t\t\t\t\\\n-\t\t   (TARGET_PDEBUG ? \"; default\" : \"\"));\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  while (0)\n+  cris_asm_output_case_end (STREAM, NUM, TABLE)\n \n \n /* Node: Exception Region Output */"}]}