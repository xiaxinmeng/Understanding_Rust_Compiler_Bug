{"sha": "ecc114f755ea1b4c3a218e8c936689d1d8f04188", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWNjMTE0Zjc1NWVhMWI0YzNhMjE4ZThjOTM2Njg5ZDFkOGYwNDE4OA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-04-04T23:13:36Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-04-04T23:13:36Z"}, "message": "re PR inline-asm/5099 (m68k-aout/3.0.2/cc1 aborts on asm(\"movw sr,%0\":\"=hd\"(a));)\n\n        PR middle-end/5099\n        * stmt.c (expand_asm_operands): Validate outputs vs asm_operand_ok.\n        Support copies into and out of memory.  Don't accept allows_reg\n        and allows_mem as gospel.\n\nFrom-SVN: r51884", "tree": {"sha": "b53b283a2044bb79d2f7decb3ed952fc266a2091", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b53b283a2044bb79d2f7decb3ed952fc266a2091"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ecc114f755ea1b4c3a218e8c936689d1d8f04188", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecc114f755ea1b4c3a218e8c936689d1d8f04188", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ecc114f755ea1b4c3a218e8c936689d1d8f04188", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecc114f755ea1b4c3a218e8c936689d1d8f04188/comments", "author": null, "committer": null, "parents": [{"sha": "c4484b8fe055db414048860502d480c63e7ee6b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4484b8fe055db414048860502d480c63e7ee6b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4484b8fe055db414048860502d480c63e7ee6b1"}], "stats": {"total": 54, "additions": 42, "deletions": 12}, "files": [{"sha": "6c4dc907035d3e6a444d9daa178f75526f631ba2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecc114f755ea1b4c3a218e8c936689d1d8f04188/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecc114f755ea1b4c3a218e8c936689d1d8f04188/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ecc114f755ea1b4c3a218e8c936689d1d8f04188", "patch": "@@ -1,3 +1,10 @@\n+2002-04-04  Richard Henderson  <rth@redhat.com>\n+\n+\tPR middle-end/5099\n+\t* stmt.c (expand_asm_operands): Validate outputs vs asm_operand_ok.\n+\tSupport copies into and out of memory.  Don't accept allows_reg\n+\tand allows_mem as gospel.\n+\n 2002-04-04  Richard Henderson  <rth@redhat.com>\n \n \tPR opt/6165"}, {"sha": "c5399bc293f063922900904ace741053eca242b3", "filename": "gcc/stmt.c", "status": "modified", "additions": 35, "deletions": 12, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecc114f755ea1b4c3a218e8c936689d1d8f04188/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecc114f755ea1b4c3a218e8c936689d1d8f04188/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=ecc114f755ea1b4c3a218e8c936689d1d8f04188", "patch": "@@ -1740,25 +1740,48 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \t      && (allows_mem || GET_CODE (DECL_RTL (val)) == REG)\n \t      && ! (GET_CODE (DECL_RTL (val)) == REG\n \t\t    && GET_MODE (DECL_RTL (val)) != TYPE_MODE (type)))\n-\t  || ! allows_reg\n \t  || is_inout)\n \t{\n-\t  output_rtx[i] = expand_expr (val, NULL_RTX, VOIDmode, EXPAND_WRITE);\n+\t  enum { do_not_copy, do_copy_reg, do_copy_mem } do_copy;\n+\t  rtx op;\n \n-\t  if (! allows_reg && GET_CODE (output_rtx[i]) != MEM)\n+\t  op = expand_expr (val, NULL_RTX, VOIDmode, EXPAND_WRITE);\n+\t  output_rtx[i] = op;\n+\n+\t  if (! allows_reg && GET_CODE (op) != MEM)\n \t    error (\"output number %d not directly addressable\", i);\n-\t  if ((! allows_mem && GET_CODE (output_rtx[i]) == MEM)\n-\t      || GET_CODE (output_rtx[i]) == CONCAT)\n+\n+\t  do_copy = do_not_copy;\n+\t  if (! allows_mem && GET_CODE (op) == MEM)\n+\t    do_copy = do_copy_reg;\n+\t  else if (GET_CODE (op) == CONCAT)\n+\t    do_copy = do_copy_reg;\n+\t  else if (asm_operand_ok (op, constraints[i]) <= 0)\n+\t    {\n+\t      if (allows_reg && !register_operand (op, VOIDmode))\n+\t\tdo_copy = do_copy_reg;\n+\t      else if (allows_mem && GET_CODE (op) != MEM)\n+\t\tdo_copy = do_copy_mem;\n+\t      else\n+\t\twarning (\"asm operand %d probably doesn't match constraints\", i);\n+\t    }\n+\n+\t  if (do_copy == do_copy_reg)\n+\t    {\n+    \t      real_output_rtx[i] = protect_from_queue (op, 1);\n+\t      output_rtx[i] = gen_reg_rtx (GET_MODE (op));\n+\t    }\n+\t  else if (do_copy == do_copy_mem)\n \t    {\n-    \t      real_output_rtx[i] = protect_from_queue (output_rtx[i], 1);\n-\t      output_rtx[i] = gen_reg_rtx (GET_MODE (output_rtx[i]));\n-\t      if (is_inout)\n-\t\temit_move_insn (output_rtx[i], real_output_rtx[i]);\n+\t      real_output_rtx[i] = op;\n+\t      output_rtx[i] = assign_temp (type, 0, 1, 1);\n \t    }\n+\t  if (do_copy && is_inout)\n+\t    emit_move_insn (output_rtx[i], real_output_rtx[i]);\n \t}\n       else\n \t{\n-\t  output_rtx[i] = assign_temp (type, 0, 0, 1);\n+\t  output_rtx[i] = assign_temp (type, 0, !allows_reg, 1);\n \t  TREE_VALUE (tail) = make_tree (type, output_rtx[i]);\n \t}\n \n@@ -1812,9 +1835,9 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \n       if (asm_operand_ok (op, constraint) <= 0)\n \t{\n-\t  if (allows_reg)\n+\t  if (allows_reg && !register_operand (op, VOIDmode))\n \t    op = force_reg (TYPE_MODE (type), op);\n-\t  else if (!allows_mem)\n+\t  else if (!allows_mem || GET_CODE (op) == MEM)\n \t    warning (\"asm operand %d probably doesn't match constraints\",\n \t\t     i + noutputs);\n \t  else if (CONSTANT_P (op))"}]}