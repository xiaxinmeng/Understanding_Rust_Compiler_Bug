{"sha": "129a37fc319db84e962397736a3030cb95471df2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTI5YTM3ZmMzMTlkYjg0ZTk2MjM5NzczNmEzMDMwY2I5NTQ3MWRmMg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2008-08-21T15:26:59Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2008-08-21T15:26:59Z"}, "message": "cgraph.c (first_cgraph_function_insertion_hook): New variable.\n\n\t* cgraph.c (first_cgraph_function_insertion_hook): New variable.\n\t(cgraph_add_function_insertion_hook, cgraph_remove_function_insertion_hook,\n\tcgraph_call_function_insertion_hooks): New functions.\n\t* cgraph.h (cgraph_add_function_insertion_hook, cgraph_remove_function_insertion_hook,\n\tcgraph_call_function_insertion_hooks): Declare.\n\t* ipa-reference.c (function_insertion_hook_holder): New variable.\n\t(check_operand, look_for_address_of): When checking late, do not care\n\tabout module bitmaps.\n\t(add_new_function): New function.\n\t(generate_summary): Register hooks; zero module bitmaps.\n\t(propagate): Unregister hooks.\n\t* ipa-pure-const.c (function_insertion_hook_holder): New variable.\n\t(add_new_function): New function.\n\t(generate_summary): Register hook.\n\t(propagate): Remove hook.\n\n\t* ipa-cp.c (ipcp_need_redirect_p): Fix to not be constant 0.\n\n\t* tree-pass.h (pass_ipa_cp): Make ipa_opt_pass.\n\t* ipa-cp.c (ipcp_update_cloned_node): New function.\n\t(build_const_val): Handle functions correctly; bring type logic\n\tinto sync with tree-inline.c\n\t(ipcp_init_stage):  Take care of computing stuff needed by\n\tindirect inlining; update clones.\n\t(ipcp_generate_summary): Break out of ipcp_driver.\n\t(ipcp_driver): Do only execution and transformation.\n\t(pass_ipa_cp): Make IPA_PASS.\n\t* tree-ssa-ccp.c (fold_stmt_r): Check type before trying to fold\n\toffset to address.\n\t* ipa-inline.c (inline_indirect_intraprocedural_analysis): When doing\n\tipcp, some info is already available.\n\t* ipa-prop.c (ipa_count_arguments): Grow edge lists as needed.\n\t* tree-inline.c (remap_ssa_name): Unshare expression.\n\nFrom-SVN: r139389", "tree": {"sha": "ea7b07c12837d74f7ef838851f5acf7f97cc0948", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea7b07c12837d74f7ef838851f5acf7f97cc0948"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/129a37fc319db84e962397736a3030cb95471df2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/129a37fc319db84e962397736a3030cb95471df2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/129a37fc319db84e962397736a3030cb95471df2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/129a37fc319db84e962397736a3030cb95471df2/comments", "author": null, "committer": null, "parents": [{"sha": "1e52075c544a9808b4b370ef974c198f3bb639b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e52075c544a9808b4b370ef974c198f3bb639b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e52075c544a9808b4b370ef974c198f3bb639b5"}], "stats": {"total": 264, "additions": 232, "deletions": 32}, "files": [{"sha": "d63db92b9acb359f07c5c188b9d739dd6ebb0845", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/129a37fc319db84e962397736a3030cb95471df2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/129a37fc319db84e962397736a3030cb95471df2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=129a37fc319db84e962397736a3030cb95471df2", "patch": "@@ -1,3 +1,39 @@\n+2008-08-21  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.c (first_cgraph_function_insertion_hook): New variable.\n+\t(cgraph_add_function_insertion_hook, cgraph_remove_function_insertion_hook,\n+\tcgraph_call_function_insertion_hooks): New functions.\n+\t* cgraph.h (cgraph_add_function_insertion_hook, cgraph_remove_function_insertion_hook,\n+\tcgraph_call_function_insertion_hooks): Declare.\n+\t* ipa-reference.c (function_insertion_hook_holder): New variable.\n+\t(check_operand, look_for_address_of): When checking late, do not care\n+\tabout module bitmaps.\n+\t(add_new_function): New function.\n+\t(generate_summary): Register hooks; zero module bitmaps.\n+\t(propagate): Unregister hooks.\n+\t* ipa-pure-const.c (function_insertion_hook_holder): New variable.\n+\t(add_new_function): New function.\n+\t(generate_summary): Register hook.\n+\t(propagate): Remove hook.\n+\n+\t* ipa-cp.c (ipcp_need_redirect_p): Fix to not be constant 0.\n+\n+\t* tree-pass.h (pass_ipa_cp): Make ipa_opt_pass.\n+\t* ipa-cp.c (ipcp_update_cloned_node): New function.\n+\t(build_const_val): Handle functions correctly; bring type logic\n+\tinto sync with tree-inline.c\n+\t(ipcp_init_stage):  Take care of computing stuff needed by\n+\tindirect inlining; update clones.\n+\t(ipcp_generate_summary): Break out of ipcp_driver.\n+\t(ipcp_driver): Do only execution and transformation.\n+\t(pass_ipa_cp): Make IPA_PASS.\n+\t* tree-ssa-ccp.c (fold_stmt_r): Check type before trying to fold\n+\toffset to address.\n+\t* ipa-inline.c (inline_indirect_intraprocedural_analysis): When doing\n+\tipcp, some info is already available.\n+\t* ipa-prop.c (ipa_count_arguments): Grow edge lists as needed.\n+\t* tree-inline.c (remap_ssa_name): Unshare expression.\n+\n 2008-08-21  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-ssa-pre.c (insert_into_preds_of_block): Before inserting"}, {"sha": "a0db5860f3926fcb4e04af205b7a5c70536ed3d5", "filename": "gcc/cgraph.c", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/129a37fc319db84e962397736a3030cb95471df2/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/129a37fc319db84e962397736a3030cb95471df2/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=129a37fc319db84e962397736a3030cb95471df2", "patch": "@@ -173,6 +173,8 @@ struct cgraph_node_hook_list *first_cgraph_node_removal_hook;\n struct cgraph_2edge_hook_list *first_cgraph_edge_duplicated_hook;\n /* List of hooks triggered when a node is duplicated.  */\n struct cgraph_2node_hook_list *first_cgraph_node_duplicated_hook;\n+/* List of hooks triggered when an function is inserted.  */\n+struct cgraph_node_hook_list *first_cgraph_function_insertion_hook;\n \n \n /* Register HOOK to be called with DATA on each removed edge.  */\n@@ -255,6 +257,46 @@ cgraph_call_node_removal_hooks (struct cgraph_node *node)\n   }\n }\n \n+/* Register HOOK to be called with DATA on each removed node.  */\n+struct cgraph_node_hook_list *\n+cgraph_add_function_insertion_hook (cgraph_node_hook hook, void *data)\n+{\n+  struct cgraph_node_hook_list *entry;\n+  struct cgraph_node_hook_list **ptr = &first_cgraph_function_insertion_hook;\n+\n+  entry = (struct cgraph_node_hook_list *) xmalloc (sizeof (*entry));\n+  entry->hook = hook;\n+  entry->data = data;\n+  entry->next = NULL;\n+  while (*ptr)\n+    ptr = &(*ptr)->next;\n+  *ptr = entry;\n+  return entry;\n+}\n+\n+/* Remove ENTRY from the list of hooks called on removing nodes.  */\n+void\n+cgraph_remove_function_insertion_hook (struct cgraph_node_hook_list *entry)\n+{\n+  struct cgraph_node_hook_list **ptr = &first_cgraph_function_insertion_hook;\n+\n+  while (*ptr != entry)\n+    ptr = &(*ptr)->next;\n+  *ptr = entry->next;\n+}\n+\n+/* Call all node removal hooks.  */\n+void\n+cgraph_call_function_insertion_hooks (struct cgraph_node *node)\n+{\n+  struct cgraph_node_hook_list *entry = first_cgraph_function_insertion_hook;\n+  while (entry)\n+  {\n+    entry->hook (node, entry->data);\n+    entry = entry->next;\n+  }\n+}\n+\n /* Register HOOK to be called with DATA on each duplicated edge.  */\n struct cgraph_2edge_hook_list *\n cgraph_add_edge_duplication_hook (cgraph_2edge_hook hook, void *data)"}, {"sha": "15cbf29956d1f2d369839a4a06e1c76e7692ccb5", "filename": "gcc/cgraph.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/129a37fc319db84e962397736a3030cb95471df2/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/129a37fc319db84e962397736a3030cb95471df2/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=129a37fc319db84e962397736a3030cb95471df2", "patch": "@@ -372,6 +372,10 @@ void cgraph_remove_edge_removal_hook (struct cgraph_edge_hook_list *);\n struct cgraph_node_hook_list *cgraph_add_node_removal_hook (cgraph_node_hook,\n \t\t\t\t\t\t\t    void *);\n void cgraph_remove_node_removal_hook (struct cgraph_node_hook_list *);\n+struct cgraph_node_hook_list *cgraph_add_function_insertion_hook (cgraph_node_hook,\n+\t\t\t\t\t\t\t          void *);\n+void cgraph_remove_function_insertion_hook (struct cgraph_node_hook_list *);\n+void cgraph_call_function_insertion_hooks (struct cgraph_node *node);\n struct cgraph_2edge_hook_list *cgraph_add_edge_duplication_hook (cgraph_2edge_hook, void *);\n void cgraph_remove_edge_duplication_hook (struct cgraph_2edge_hook_list *);\n struct cgraph_2node_hook_list *cgraph_add_node_duplication_hook (cgraph_2node_hook, void *);"}, {"sha": "371e17cc99fc7f3f34835ad285b1b798907f84a6", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/129a37fc319db84e962397736a3030cb95471df2/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/129a37fc319db84e962397736a3030cb95471df2/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=129a37fc319db84e962397736a3030cb95471df2", "patch": "@@ -434,6 +434,7 @@ cgraph_process_new_functions (void)\n \t  gcc_unreachable ();\n \t  break;\n \t}\n+      cgraph_call_function_insertion_hooks (node);\n     }\n   return output;\n }\n@@ -1535,6 +1536,7 @@ cgraph_function_versioning (struct cgraph_node *old_version_node,\n   new_version_node->local.externally_visible = 0;\n   new_version_node->local.local = 1;\n   new_version_node->lowered = true;\n+  cgraph_call_function_insertion_hooks (new_version_node);\n   return new_version_node;\n }\n "}, {"sha": "d534d198203f7f40e2d6f7b2e43df85f90355991", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 85, "deletions": 20, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/129a37fc319db84e962397736a3030cb95471df2/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/129a37fc319db84e962397736a3030cb95471df2/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=129a37fc319db84e962397736a3030cb95471df2", "patch": "@@ -159,6 +159,36 @@ ipcp_init_cloned_node (struct cgraph_node *orig_node,\n   ipa_create_param_decls_array (new_node);\n }\n \n+/* Recompute all local information since node might've got new\n+   direct calls after clonning.  */\n+static void\n+ipcp_update_cloned_node (struct cgraph_node *new_node)\n+{\n+  /* We might've introduced new direct calls.  */\n+  push_cfun (DECL_STRUCT_FUNCTION (new_node->decl));\n+  current_function_decl = new_node->decl;\n+  rebuild_cgraph_edges ();\n+\n+  if (flag_indirect_inlining)\n+    {\n+      struct cgraph_edge *cs;\n+\n+      ipa_check_create_node_params ();\n+      ipa_count_formal_params (new_node);\n+      ipa_create_param_decls_array (new_node);\n+      ipa_detect_param_modifications (new_node);\n+      ipa_analyze_params_uses (new_node);\n+\n+      for (cs = new_node->callees; cs; cs = cs->next_callee)\n+\t{\n+\t  ipa_count_arguments (cs);\n+\t  ipa_compute_jump_functions (cs);\n+\t}\n+    }\n+  pop_cfun ();\n+  current_function_decl = NULL;\n+}\n+\n /* Return scale for NODE.  */\n static inline gcov_type\n ipcp_get_node_scale (struct cgraph_node *node)\n@@ -377,11 +407,27 @@ constant_val_insert (tree parm1 ATTRIBUTE_UNUSED, tree val ATTRIBUTE_UNUSED)\n static tree\n build_const_val (struct ipcp_lattice *lat, tree tree_type)\n {\n-  tree const_val = NULL;\n+  tree val;\n \n   gcc_assert (ipcp_lat_is_const (lat));\n-  const_val = fold_convert (tree_type, lat->constant);\n-  return const_val;\n+  val = lat->constant;\n+\n+  /* compute_jump_functions inserts FUNCTION_DECL as value of parameter\n+     when address of function is taken.  It would make more sense to pass\n+     whole ADDR_EXPR, but for now compensate here.  */\n+  if ((lat->type == IPA_CONST_VALUE\n+        && TREE_CODE (val) == FUNCTION_DECL)\n+      || lat->type == IPA_CONST_VALUE_REF)\n+    return build_fold_addr_expr_with_type (val, tree_type);\n+\n+  if (!useless_type_conversion_p (tree_type, TREE_TYPE (val)))\n+    {\n+      if (fold_convertible_p (tree_type, val))\n+\treturn fold_build1 (NOP_EXPR, tree_type, val);\n+      else\n+\treturn fold_build1 (VIEW_CONVERT_EXPR, tree_type, val);\n+    }\n+  return val;\n }\n \n /* Build the tree representing the constant and call constant_val_insert().  */\n@@ -456,6 +502,8 @@ ipcp_init_stage (void)\n \t      /* Handle cases of functions with \n \t         a variable number of parameters.  */\n \t      ipa_set_called_with_variable_arg (IPA_NODE_REF (cs->callee));\n+\t      if (flag_indirect_inlining)\n+\t        ipa_compute_jump_functions (cs);\n \t    }\n \t  else\n \t    ipa_compute_jump_functions (cs);\n@@ -781,7 +829,8 @@ ipcp_need_redirect_p (struct cgraph_edge *cs)\n       if (ipcp_lat_is_const (lat))\n \t{\n \t  jump_func = ipa_get_ith_jump_func (IPA_EDGE_REF (cs), i);\n-\t  if (!ipcp_lat_is_const (lat))\n+\t  if (jump_func->type != IPA_CONST && jump_func->type != IPA_CONST_REF\n+\t      && jump_func->type != IPA_CONST_MEMBER_PTR)\n \t    return true;\n \t}\n     }\n@@ -966,7 +1015,10 @@ ipcp_insert_stage (void)\n \t  free_dominance_info (CDI_POST_DOMINATORS);\n \t  pop_cfun ();\n \t  current_function_decl = NULL;\n+\t  /* We've possibly introduced direct calls.  */\n+\t  ipcp_update_cloned_node (node1);\n \t}\n+\n       if (dump_file)\n \tdump_function_to_file (node1->decl, dump_file, dump_flags);\n     }\n@@ -978,19 +1030,6 @@ ipcp_insert_stage (void)\n static unsigned int\n ipcp_driver (void)\n {\n-  if (dump_file)\n-    fprintf (dump_file, \"\\nIPA constant propagation start:\\n\");\n-  ipa_check_create_node_params ();\n-  ipa_check_create_edge_args ();\n-  ipa_register_cgraph_hooks ();\n-  /* 1. Call the init stage to initialize \n-     the ipa_node_params and ipa_edge_args structures.  */\n-  ipcp_init_stage ();\n-  if (dump_file)\n-    {\n-      fprintf (dump_file, \"\\nIPA structures before propagation:\\n\");\n-      ipcp_print_all_structures (dump_file);\n-    }\n   /* 2. Do the interprocedural propagation.  */\n   ipcp_iterate_stage ();\n   if (dump_file)\n@@ -1015,17 +1054,36 @@ ipcp_driver (void)\n   return 0;\n }\n \n+/* Note function body size.  */\n+static void\n+ipcp_generate_summary (void)\n+{\n+  if (dump_file)\n+    fprintf (dump_file, \"\\nIPA constant propagation start:\\n\");\n+  ipa_check_create_node_params ();\n+  ipa_check_create_edge_args ();\n+  ipa_register_cgraph_hooks ();\n+  /* 1. Call the init stage to initialize \n+     the ipa_node_params and ipa_edge_args structures.  */\n+  ipcp_init_stage ();\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"\\nIPA structures before propagation:\\n\");\n+      ipcp_print_all_structures (dump_file);\n+    }\n+}\n+\n /* Gate for IPCP optimization.  */\n static bool\n cgraph_gate_cp (void)\n {\n   return flag_ipa_cp;\n }\n \n-struct simple_ipa_opt_pass pass_ipa_cp = \n+struct ipa_opt_pass pass_ipa_cp = \n {\n  {\n-  SIMPLE_IPA_PASS,\n+  IPA_PASS,\n   \"cp\",\t\t\t\t/* name */\n   cgraph_gate_cp,\t\t/* gate */\n   ipcp_driver,\t\t\t/* execute */\n@@ -1038,5 +1096,12 @@ struct simple_ipa_opt_pass pass_ipa_cp =\n   0,\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t/* todo_flags_start */\n   TODO_dump_cgraph | TODO_dump_func\t/* todo_flags_finish */\n- }\n+ },\n+ ipcp_generate_summary,\t\t\t/* generate_summary */\n+ NULL,\t\t\t\t\t/* write_summary */\n+ NULL,\t\t\t\t\t/* read_summary */\n+ NULL,\t\t\t\t\t/* function_read_summary */\n+ 0,\t\t\t\t\t/* TODOs */\n+ NULL,\t\t\t\t\t/* function_transform */\n+ NULL,\t\t\t\t\t/* variable_transform */\n };"}, {"sha": "d5f280fd8cb071ac59a8b4412e590618332038ec", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/129a37fc319db84e962397736a3030cb95471df2/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/129a37fc319db84e962397736a3030cb95471df2/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=129a37fc319db84e962397736a3030cb95471df2", "patch": "@@ -1633,19 +1633,23 @@ inline_indirect_intraprocedural_analysis (struct cgraph_node *node)\n {\n   struct cgraph_edge *cs;\n \n-  ipa_count_formal_params (node);\n-  ipa_create_param_decls_array (node);\n-  ipa_detect_param_modifications (node);\n+  if (!flag_ipa_cp)\n+    {\n+      ipa_count_formal_params (node);\n+      ipa_create_param_decls_array (node);\n+      ipa_detect_param_modifications (node);\n+    }\n   ipa_analyze_params_uses (node);\n \n   if (dump_file)\n     ipa_print_node_param_flags (dump_file, node);\n \n-  for (cs = node->callees; cs; cs = cs->next_callee)\n-    {\n-      ipa_count_arguments (cs);\n-      ipa_compute_jump_functions (cs);\n-    }\n+  if (!flag_ipa_cp)\n+    for (cs = node->callees; cs; cs = cs->next_callee)\n+      {\n+\tipa_count_arguments (cs);\n+\tipa_compute_jump_functions (cs);\n+      }\n \n   if (dump_file)\n     ipa_print_node_jump_functions (dump_file, node);"}, {"sha": "5a93a4a7311d6595960cd40ee5ed773f45d621f2", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/129a37fc319db84e962397736a3030cb95471df2/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/129a37fc319db84e962397736a3030cb95471df2/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=129a37fc319db84e962397736a3030cb95471df2", "patch": "@@ -238,6 +238,10 @@ ipa_count_arguments (struct cgraph_edge *cs)\n   stmt = cs->call_stmt;\n   gcc_assert (is_gimple_call (stmt));\n   arg_num = gimple_call_num_args (stmt);\n+  if (VEC_length (ipa_edge_args_t, ipa_edge_args_vector)\n+      <= (unsigned) cgraph_edge_max_uid)\n+    VEC_safe_grow_cleared (ipa_edge_args_t, heap,\n+\t\t\t   ipa_edge_args_vector, cgraph_edge_max_uid + 1);\n   ipa_set_cs_argument_count (IPA_EDGE_REF (cs), arg_num);\n }\n "}, {"sha": "20abdf3f4771c6e590f20bb6478cc49832418c30", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/129a37fc319db84e962397736a3030cb95471df2/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/129a37fc319db84e962397736a3030cb95471df2/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=129a37fc319db84e962397736a3030cb95471df2", "patch": "@@ -96,6 +96,8 @@ typedef struct funct_state_d * funct_state;\n \n static funct_state *funct_state_vec;\n \n+/* Holders of ipa cgraph hooks: */\n+static struct cgraph_node_hook_list *function_insertion_hook_holder;\n \n /* Init the function state.  */\n \n@@ -677,6 +679,21 @@ analyze_function (struct cgraph_node *fn)\n     }\n }\n \n+/* Called when new function is inserted to callgraph late.  */\n+static void\n+add_new_function (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n+{\n+  funct_state_vec = XRESIZEVEC (funct_state, funct_state_vec, cgraph_max_uid);\n+  /* There are some shared nodes, in particular the initializers on\n+     static declarations.  We do not need to scan them more than once\n+     since all we would be interested in are the addressof\n+     operations.  */\n+  visited_nodes = pointer_set_create ();\n+  analyze_function (node);\n+  pointer_set_destroy (visited_nodes);\n+  visited_nodes = NULL;\n+}\n+\n \f\n /* Analyze each function in the cgraph to see if it is locally PURE or\n    CONST.  */\n@@ -686,6 +703,8 @@ generate_summary (void)\n {\n   struct cgraph_node *node;\n \n+  function_insertion_hook_holder =\n+      cgraph_add_function_insertion_hook (&add_new_function, NULL);\n   init_state ();\n   /* There are some shared nodes, in particular the initializers on\n      static declarations.  We do not need to scan them more than once\n@@ -725,6 +744,7 @@ propagate (void)\n   int i;\n   struct ipa_dfs_info * w_info;\n \n+  cgraph_remove_function_insertion_hook (function_insertion_hook_holder);\n   order_pos = ipa_utils_reduced_inorder (order, true, false);\n   if (dump_file)\n     {"}, {"sha": "c8b23b6faef03af63eafc449010c4a8be6624915", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/129a37fc319db84e962397736a3030cb95471df2/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/129a37fc319db84e962397736a3030cb95471df2/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=129a37fc319db84e962397736a3030cb95471df2", "patch": "@@ -95,6 +95,9 @@ static struct pointer_set_t *visited_nodes;\n \n static bitmap_obstack ipa_obstack;\n \n+/* Holders of ipa cgraph hooks: */\n+static struct cgraph_node_hook_list *function_insertion_hook_holder;\n+\n enum initialization_status_t\n {\n   UNINITIALIZED,\n@@ -296,7 +299,8 @@ check_operand (ipa_reference_local_vars_info_t local,\n \t    bitmap_set_bit (local->statics_written, DECL_UID (t));\n \t  /* Mark the write so we can tell which statics are\n \t     readonly.  */\n-\t  bitmap_set_bit (module_statics_written, DECL_UID (t));\n+\t  if (module_statics_written)\n+\t    bitmap_set_bit (module_statics_written, DECL_UID (t));\n \t}\n       else if (local)\n \tbitmap_set_bit (local->statics_read, DECL_UID (t));\n@@ -345,7 +349,7 @@ look_for_address_of (tree t)\n     {\n       tree x = get_base_var (t);\n       if (TREE_CODE (x) == VAR_DECL || TREE_CODE (x) == FUNCTION_DECL) \n-\tif (has_proper_scope_for_analysis (x))\n+\tif (has_proper_scope_for_analysis (x) && module_statics_escape)\n \t  bitmap_set_bit (module_statics_escape, DECL_UID (x));\n     }\n }\n@@ -935,6 +939,19 @@ clean_function (struct cgraph_node *fn)\n   get_function_ann (fn->decl)->reference_vars_info = NULL;\n }\n \n+/* Called when new function is inserted to callgraph late.  */\n+static void\n+add_new_function (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n+{\n+  /* There are some shared nodes, in particular the initializers on\n+     static declarations.  We do not need to scan them more than once\n+     since all we would be interested in are the addressof\n+     operations.  */\n+  visited_nodes = pointer_set_create ();\n+  analyze_function (node);\n+  pointer_set_destroy (visited_nodes);\n+  visited_nodes = NULL;\n+}\n \n /* Analyze each function in the cgraph to see which global or statics\n    are read or written.  */\n@@ -949,6 +966,8 @@ generate_summary (void)\n   bitmap module_statics_readonly;\n   bitmap bm_temp;\n   \n+  function_insertion_hook_holder =\n+      cgraph_add_function_insertion_hook (&add_new_function, NULL);\n   ipa_init ();\n   module_statics_readonly = BITMAP_ALLOC (&ipa_obstack);\n   bm_temp = BITMAP_ALLOC (&ipa_obstack);\n@@ -1031,6 +1050,8 @@ generate_summary (void)\n   \n   BITMAP_FREE(module_statics_escape);\n   BITMAP_FREE(module_statics_written);\n+  module_statics_escape = NULL;\n+  module_statics_written = NULL;\n   \n   if (dump_file)\n     EXECUTE_IF_SET_IN_BITMAP (all_module_statics, 0, index, bi)\n@@ -1107,6 +1128,7 @@ propagate (void)\n   int order_pos = ipa_utils_reduced_inorder (order, false, true);\n   int i;\n \n+  cgraph_remove_function_insertion_hook (function_insertion_hook_holder);\n   if (dump_file) \n     dump_cgraph (dump_file);\n "}, {"sha": "622e6396723c47d56722235b7ff4d0720a602a5e", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/129a37fc319db84e962397736a3030cb95471df2/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/129a37fc319db84e962397736a3030cb95471df2/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=129a37fc319db84e962397736a3030cb95471df2", "patch": "@@ -161,7 +161,7 @@ remap_ssa_name (tree name, copy_body_data *id)\n \n   n = (tree *) pointer_map_contains (id->decl_map, name);\n   if (n)\n-    return *n;\n+    return unshare_expr (*n);\n \n   /* Do not set DEF_STMT yet as statement is not copied yet. We do that\n      in copy_bb.  */"}, {"sha": "acb05193b4b0104b724ffbd8c9b4bed6314634e7", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/129a37fc319db84e962397736a3030cb95471df2/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/129a37fc319db84e962397736a3030cb95471df2/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=129a37fc319db84e962397736a3030cb95471df2", "patch": "@@ -390,11 +390,11 @@ extern struct gimple_opt_pass pass_reset_cc_flags;\n \n /* IPA Passes */\n extern struct ipa_opt_pass pass_ipa_inline;\n+extern struct ipa_opt_pass pass_ipa_cp;\n extern struct ipa_opt_pass pass_ipa_reference;\n extern struct ipa_opt_pass pass_ipa_pure_const;\n \n extern struct simple_ipa_opt_pass pass_ipa_matrix_reorg;\n-extern struct simple_ipa_opt_pass pass_ipa_cp;\n extern struct simple_ipa_opt_pass pass_ipa_early_inline;\n extern struct simple_ipa_opt_pass pass_ipa_type_escape;\n extern struct simple_ipa_opt_pass pass_ipa_pta;"}, {"sha": "cd50ad45941ed320ff55faed4d47357dc9235b86", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/129a37fc319db84e962397736a3030cb95471df2/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/129a37fc319db84e962397736a3030cb95471df2/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=129a37fc319db84e962397736a3030cb95471df2", "patch": "@@ -2304,6 +2304,7 @@ fold_stmt_r (tree *expr_p, int *walk_subtrees, void *data)\n       *walk_subtrees = 0;\n \n       if (POINTER_TYPE_P (TREE_TYPE (expr))\n+          && POINTER_TYPE_P (TREE_TYPE (TREE_TYPE (expr)))\n \t  && POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (expr, 0)))\n \t  && (t = maybe_fold_offset_to_address (TREE_OPERAND (expr, 0),\n \t\t\t\t\t\tinteger_zero_node,"}]}