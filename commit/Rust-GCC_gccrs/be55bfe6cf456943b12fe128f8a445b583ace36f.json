{"sha": "be55bfe6cf456943b12fe128f8a445b583ace36f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmU1NWJmZTZjZjQ1Njk0M2IxMmZlMTI4ZjhhNDQ1YjU4M2FjZTM2Zg==", "commit": {"author": {"name": "Trevor Saunders", "email": "tsaunders@mozilla.com", "date": "2014-04-17T12:37:34Z"}, "committer": {"name": "Trevor Saunders", "email": "tbsaunde@gcc.gnu.org", "date": "2014-04-17T12:37:34Z"}, "message": "pass cfun to pass::execute\n\ngcc/\n\t* passes.c (opt_pass::execute): Adjust.\n\t(pass_manager::execute_pass_mode_switching): Likewise.\n\t(early_local_passes::execute): Likewise.\n\t(execute_one_pass): Pass cfun to the pass's execute method.\n\t* tree-pass.h (opt_pass::execute): Add function * argument.\n\t* asan.c, auto-inc-dec.c, bb-reorder.c, bt-load.c, cfgcleanup.c,\n\tcfgexpand.c, cfgrtl.c, cgraphbuild.c, combine-stack-adj.c, combine.c,\n\tcompare-elim.c, config/arc/arc.c, config/epiphany/mode-switch-use.c,\n\tconfig/epiphany/resolve-sw-modes.c, config/i386/i386.c,\n\tconfig/mips/mips.c, config/rl78/rl78.c, config/s390/s390.c,\n\tconfig/sparc/sparc.c, cprop.c, dce.c, df-core.c, dse.c, dwarf2cfi.c,\n\texcept.c, final.c, function.c, fwprop.c, gcse.c, gimple-low.c,\n\tgimple-ssa-isolate-paths.c, gimple-ssa-strength-reduction.c,\n\tgraphite.c, ifcvt.c, init-regs.c, ipa-cp.c, ipa-devirt.c,\n\tipa-inline-analysis.c, ipa-inline.c, ipa-profile.c, ipa-pure-const.c,\n\tipa-reference.c, ipa-split.c, ipa.c, ira.c, jump.c, loop-init.c,\n\tlower-subreg.c, mode-switching.c, omp-low.c, postreload-gcse.c,\n\tpostreload.c, predict.c, recog.c, ree.c, reg-stack.c, regcprop.c,\n\treginfo.c, regrename.c, reorg.c, sched-rgn.c, stack-ptr-mod.c,\n\tstore-motion.c, tracer.c, trans-mem.c, tree-call-cdce.c, tree-cfg.c,\n\ttree-cfgcleanup.c, tree-complex.c, tree-eh.c, tree-emutls.c,\n\ttree-if-conv.c, tree-into-ssa.c, tree-loop-distribution.c, tree-nrv.c,\n\ttree-object-size.c, tree-parloops.c, tree-predcom.c, tree-ssa-ccp.c,\n\ttree-ssa-copy.c, tree-ssa-copyrename.c, tree-ssa-dce.c,\n\ttree-ssa-dom.c, tree-ssa-dse.c, tree-ssa-forwprop.c,\n\ttree-ssa-ifcombine.c, tree-ssa-loop-ch.c, tree-ssa-loop-im.c,\n\ttree-ssa-loop-ivcanon.c, tree-ssa-loop-prefetch.c,\n\ttree-ssa-loop-unswitch.c, tree-ssa-loop.c, tree-ssa-math-opts.c,\n\ttree-ssa-phiopt.c, tree-ssa-phiprop.c, tree-ssa-pre.c,\n\ttree-ssa-reassoc.c, tree-ssa-sink.c, tree-ssa-strlen.c,\n\ttree-ssa-structalias.c, tree-ssa-uncprop.c, tree-ssa-uninit.c,\n\ttree-ssa.c, tree-ssanames.c, tree-stdarg.c, tree-switch-conversion.c,\n\ttree-tailcall.c, tree-vect-generic.c, tree-vectorizer.c, tree-vrp.c,\n\ttree.c, tsan.c, ubsan.c, var-tracking.c, vtable-verify.c, web.c:\n\tAdjust.\n\nFrom-SVN: r209482", "tree": {"sha": "2c7de59d1f6572c580defbe0ccac2d0b83cd1eb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c7de59d1f6572c580defbe0ccac2d0b83cd1eb3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be55bfe6cf456943b12fe128f8a445b583ace36f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be55bfe6cf456943b12fe128f8a445b583ace36f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be55bfe6cf456943b12fe128f8a445b583ace36f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be55bfe6cf456943b12fe128f8a445b583ace36f/comments", "author": null, "committer": null, "parents": [{"sha": "1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a3d085cf2a0caa5daef7c0443b1d280bcef295e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a3d085cf2a0caa5daef7c0443b1d280bcef295e"}], "stats": {"total": 6004, "additions": 3013, "deletions": 2991}, "files": [{"sha": "ea9bb14a40b8e288d9026aa3000f77d614a0651e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -1,3 +1,41 @@\n+2014-04-17  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* passes.c (opt_pass::execute): Adjust.\n+\t(pass_manager::execute_pass_mode_switching): Likewise.\n+\t(early_local_passes::execute): Likewise.\n+\t(execute_one_pass): Pass cfun to the pass's execute method.\n+\t* tree-pass.h (opt_pass::execute): Add function * argument.\n+\t* asan.c, auto-inc-dec.c, bb-reorder.c, bt-load.c, cfgcleanup.c,\n+\tcfgexpand.c, cfgrtl.c, cgraphbuild.c, combine-stack-adj.c, combine.c,\n+\tcompare-elim.c, config/arc/arc.c, config/epiphany/mode-switch-use.c,\n+\tconfig/epiphany/resolve-sw-modes.c, config/i386/i386.c,\n+\tconfig/mips/mips.c, config/rl78/rl78.c, config/s390/s390.c,\n+\tconfig/sparc/sparc.c, cprop.c, dce.c, df-core.c, dse.c, dwarf2cfi.c,\n+\texcept.c, final.c, function.c, fwprop.c, gcse.c, gimple-low.c,\n+\tgimple-ssa-isolate-paths.c, gimple-ssa-strength-reduction.c,\n+\tgraphite.c, ifcvt.c, init-regs.c, ipa-cp.c, ipa-devirt.c,\n+\tipa-inline-analysis.c, ipa-inline.c, ipa-profile.c, ipa-pure-const.c,\n+\tipa-reference.c, ipa-split.c, ipa.c, ira.c, jump.c, loop-init.c,\n+\tlower-subreg.c, mode-switching.c, omp-low.c, postreload-gcse.c,\n+\tpostreload.c, predict.c, recog.c, ree.c, reg-stack.c, regcprop.c,\n+\treginfo.c, regrename.c, reorg.c, sched-rgn.c, stack-ptr-mod.c,\n+\tstore-motion.c, tracer.c, trans-mem.c, tree-call-cdce.c, tree-cfg.c,\n+\ttree-cfgcleanup.c, tree-complex.c, tree-eh.c, tree-emutls.c,\n+\ttree-if-conv.c, tree-into-ssa.c, tree-loop-distribution.c, tree-nrv.c,\n+\ttree-object-size.c, tree-parloops.c, tree-predcom.c, tree-ssa-ccp.c,\n+\ttree-ssa-copy.c, tree-ssa-copyrename.c, tree-ssa-dce.c,\n+\ttree-ssa-dom.c, tree-ssa-dse.c, tree-ssa-forwprop.c,\n+\ttree-ssa-ifcombine.c, tree-ssa-loop-ch.c, tree-ssa-loop-im.c,\n+\ttree-ssa-loop-ivcanon.c, tree-ssa-loop-prefetch.c,\n+\ttree-ssa-loop-unswitch.c, tree-ssa-loop.c, tree-ssa-math-opts.c,\n+\ttree-ssa-phiopt.c, tree-ssa-phiprop.c, tree-ssa-pre.c,\n+\ttree-ssa-reassoc.c, tree-ssa-sink.c, tree-ssa-strlen.c,\n+\ttree-ssa-structalias.c, tree-ssa-uncprop.c, tree-ssa-uninit.c,\n+\ttree-ssa.c, tree-ssanames.c, tree-stdarg.c, tree-switch-conversion.c,\n+\ttree-tailcall.c, tree-vect-generic.c, tree-vectorizer.c, tree-vrp.c,\n+\ttree.c, tsan.c, ubsan.c, var-tracking.c, vtable-verify.c, web.c:\n+\tAdjust.\n+\n 2014-04-17  Trevor Saunders  <tsaunders@mozilla.com>\n \n \t* passes.c (opt_pass::gate): Take function * argument."}, {"sha": "9f298079d6b89a8ba1cd797c1ae7ef5e197a1361", "filename": "gcc/asan.c", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -2505,7 +2505,7 @@ class pass_asan : public gimple_opt_pass\n   /* opt_pass methods: */\n   opt_pass * clone () { return new pass_asan (m_ctxt); }\n   virtual bool gate (function *) { return gate_asan (); }\n-  unsigned int execute () { return asan_instrument (); }\n+  virtual unsigned int execute (function *) { return asan_instrument (); }\n \n }; // class pass_asan\n \n@@ -2543,7 +2543,7 @@ class pass_asan_O0 : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *) { return !optimize && gate_asan (); }\n-  unsigned int execute () { return asan_instrument (); }\n+  virtual unsigned int execute (function *) { return asan_instrument (); }\n \n }; // class pass_asan_O0\n \n@@ -2557,12 +2557,42 @@ make_pass_asan_O0 (gcc::context *ctxt)\n \n /* Perform optimization of sanitize functions.  */\n \n-static unsigned int\n-execute_sanopt (void)\n+namespace {\n+\n+const pass_data pass_data_sanopt =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"sanopt\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  ( PROP_ssa | PROP_cfg | PROP_gimple_leh ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_verify_flow | TODO_verify_stmts\n+    | TODO_update_ssa ), /* todo_flags_finish */\n+};\n+\n+class pass_sanopt : public gimple_opt_pass\n+{\n+public:\n+  pass_sanopt (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_sanopt, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *) { return flag_sanitize; }\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_sanopt\n+\n+unsigned int\n+pass_sanopt::execute (function *fun)\n {\n   basic_block bb;\n \n-  FOR_EACH_BB_FN (bb, cfun)\n+  FOR_EACH_BB_FN (bb, fun)\n     {\n       gimple_stmt_iterator gsi;\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n@@ -2593,36 +2623,6 @@ execute_sanopt (void)\n   return 0;\n }\n \n-namespace {\n-\n-const pass_data pass_data_sanopt =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"sanopt\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  true, /* has_execute */\n-  TV_NONE, /* tv_id */\n-  ( PROP_ssa | PROP_cfg | PROP_gimple_leh ), /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  ( TODO_verify_flow | TODO_verify_stmts\n-    | TODO_update_ssa ), /* todo_flags_finish */\n-};\n-\n-class pass_sanopt : public gimple_opt_pass\n-{\n-public:\n-  pass_sanopt (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_sanopt, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  virtual bool gate (function *) { return flag_sanitize; }\n-  unsigned int execute () { return execute_sanopt (); }\n-\n-}; // class pass_sanopt\n-\n } // anon namespace\n \n gimple_opt_pass *"}, {"sha": "0314d183a8343a32aff7a90f0be291534a26d835", "filename": "gcc/auto-inc-dec.c", "status": "modified", "additions": 31, "deletions": 32, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fauto-inc-dec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fauto-inc-dec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fauto-inc-dec.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -1462,37 +1462,6 @@ merge_in_block (int max_reg, basic_block bb)\n \n #endif\n \n-static unsigned int\n-rest_of_handle_auto_inc_dec (void)\n-{\n-#ifdef AUTO_INC_DEC\n-  basic_block bb;\n-  int max_reg = max_reg_num ();\n-\n-  if (!initialized)\n-    init_decision_table ();\n-\n-  mem_tmp = gen_rtx_MEM (Pmode, NULL_RTX);\n-\n-  df_note_add_problem ();\n-  df_analyze ();\n-\n-  reg_next_use = XCNEWVEC (rtx, max_reg);\n-  reg_next_inc_use = XCNEWVEC (rtx, max_reg);\n-  reg_next_def = XCNEWVEC (rtx, max_reg);\n-  FOR_EACH_BB_FN (bb, cfun)\n-    merge_in_block (max_reg, bb);\n-\n-  free (reg_next_use);\n-  free (reg_next_inc_use);\n-  free (reg_next_def);\n-\n-  mem_tmp = NULL;\n-#endif\n-  return 0;\n-}\n-\n-\n /* Discover auto-inc auto-dec instructions.  */\n \n namespace {\n@@ -1529,10 +1498,40 @@ class pass_inc_dec : public rtl_opt_pass\n     }\n \n \n-  unsigned int execute () { return rest_of_handle_auto_inc_dec (); }\n+  unsigned int execute (function *);\n \n }; // class pass_inc_dec\n \n+unsigned int\n+pass_inc_dec::execute (function *fun ATTRIBUTE_UNUSED)\n+{\n+#ifdef AUTO_INC_DEC\n+  basic_block bb;\n+  int max_reg = max_reg_num ();\n+\n+  if (!initialized)\n+    init_decision_table ();\n+\n+  mem_tmp = gen_rtx_MEM (Pmode, NULL_RTX);\n+\n+  df_note_add_problem ();\n+  df_analyze ();\n+\n+  reg_next_use = XCNEWVEC (rtx, max_reg);\n+  reg_next_inc_use = XCNEWVEC (rtx, max_reg);\n+  reg_next_def = XCNEWVEC (rtx, max_reg);\n+  FOR_EACH_BB_FN (bb, fun)\n+    merge_in_block (max_reg, bb);\n+\n+  free (reg_next_use);\n+  free (reg_next_inc_use);\n+  free (reg_next_def);\n+\n+  mem_tmp = NULL;\n+#endif\n+  return 0;\n+}\n+\n } // anon namespace\n \n rtl_opt_pass *"}, {"sha": "db490f1f876052187848258194d970a7ed426885", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 115, "deletions": 116, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -2302,26 +2302,6 @@ insert_section_boundary_note (void)\n     }\n }\n \n-static unsigned int\n-rest_of_handle_reorder_blocks (void)\n-{\n-  basic_block bb;\n-\n-  /* Last attempt to optimize CFG, as scheduling, peepholing and insn\n-     splitting possibly introduced more crossjumping opportunities.  */\n-  cfg_layout_initialize (CLEANUP_EXPENSIVE);\n-\n-  reorder_basic_blocks ();\n-  cleanup_cfg (CLEANUP_EXPENSIVE);\n-\n-  FOR_EACH_BB_FN (bb, cfun)\n-    if (bb->next_bb != EXIT_BLOCK_PTR_FOR_FN (cfun))\n-      bb->aux = bb->next_bb;\n-  cfg_layout_finalize ();\n-\n-  return 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_reorder_blocks =\n@@ -2354,10 +2334,30 @@ class pass_reorder_blocks : public rtl_opt_pass\n \t      && (flag_reorder_blocks || flag_reorder_blocks_and_partition));\n     }\n \n-  unsigned int execute () { return rest_of_handle_reorder_blocks (); }\n+  virtual unsigned int execute (function *);\n \n }; // class pass_reorder_blocks\n \n+unsigned int\n+pass_reorder_blocks::execute (function *fun)\n+{\n+  basic_block bb;\n+\n+  /* Last attempt to optimize CFG, as scheduling, peepholing and insn\n+     splitting possibly introduced more crossjumping opportunities.  */\n+  cfg_layout_initialize (CLEANUP_EXPENSIVE);\n+\n+  reorder_basic_blocks ();\n+  cleanup_cfg (CLEANUP_EXPENSIVE);\n+\n+  FOR_EACH_BB_FN (bb, fun)\n+    if (bb->next_bb != EXIT_BLOCK_PTR_FOR_FN (fun))\n+      bb->aux = bb->next_bb;\n+  cfg_layout_finalize ();\n+\n+  return 0;\n+}\n+\n } // anon namespace\n \n rtl_opt_pass *\n@@ -2372,16 +2372,54 @@ make_pass_reorder_blocks (gcc::context *ctxt)\n    which can seriously pessimize code with many computed jumps in the source\n    code, such as interpreters.  See e.g. PR15242.  */\n \n+namespace {\n \n-static unsigned int\n-duplicate_computed_gotos (void)\n+const pass_data pass_data_duplicate_computed_gotos =\n+{\n+  RTL_PASS, /* type */\n+  \"compgotos\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_execute */\n+  TV_REORDER_BLOCKS, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_rtl_sharing, /* todo_flags_finish */\n+};\n+\n+class pass_duplicate_computed_gotos : public rtl_opt_pass\n+{\n+public:\n+  pass_duplicate_computed_gotos (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_duplicate_computed_gotos, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *);\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_duplicate_computed_gotos\n+\n+bool\n+pass_duplicate_computed_gotos::gate (function *fun)\n+{\n+  if (targetm.cannot_modify_jumps_p ())\n+    return false;\n+  return (optimize > 0\n+\t  && flag_expensive_optimizations\n+\t  && ! optimize_function_for_size_p (fun));\n+}\n+\n+unsigned int\n+pass_duplicate_computed_gotos::execute (function *fun)\n {\n   basic_block bb, new_bb;\n   bitmap candidates;\n   int max_size;\n   bool changed = false;\n \n-  if (n_basic_blocks_for_fn (cfun) <= NUM_FIXED_BLOCKS + 1)\n+  if (n_basic_blocks_for_fn (fun) <= NUM_FIXED_BLOCKS + 1)\n     return 0;\n \n   clear_bb_flags ();\n@@ -2400,15 +2438,15 @@ duplicate_computed_gotos (void)\n   /* Look for blocks that end in a computed jump, and see if such blocks\n      are suitable for unfactoring.  If a block is a candidate for unfactoring,\n      mark it in the candidates.  */\n-  FOR_EACH_BB_FN (bb, cfun)\n+  FOR_EACH_BB_FN (bb, fun)\n     {\n       rtx insn;\n       edge e;\n       edge_iterator ei;\n       int size, all_flags;\n \n       /* Build the reorder chain for the original order of blocks.  */\n-      if (bb->next_bb != EXIT_BLOCK_PTR_FOR_FN (cfun))\n+      if (bb->next_bb != EXIT_BLOCK_PTR_FOR_FN (fun))\n \tbb->aux = bb->next_bb;\n \n       /* Obviously the block has to end in a computed jump.  */\n@@ -2447,7 +2485,7 @@ duplicate_computed_gotos (void)\n     goto done;\n \n   /* Duplicate computed gotos.  */\n-  FOR_EACH_BB_FN (bb, cfun)\n+  FOR_EACH_BB_FN (bb, fun)\n     {\n       if (bb->flags & BB_VISITED)\n \tcontinue;\n@@ -2458,7 +2496,7 @@ duplicate_computed_gotos (void)\n \t the exit block or the next block.\n \t The destination must have more than one predecessor.  */\n       if (!single_succ_p (bb)\n-\t  || single_succ (bb) == EXIT_BLOCK_PTR_FOR_FN (cfun)\n+\t  || single_succ (bb) == EXIT_BLOCK_PTR_FOR_FN (fun)\n \t  || single_succ (bb) == bb->next_bb\n \t  || single_pred_p (single_succ (bb)))\n \tcontinue;\n@@ -2491,45 +2529,6 @@ duplicate_computed_gotos (void)\n   return 0;\n }\n \n-namespace {\n-\n-const pass_data pass_data_duplicate_computed_gotos =\n-{\n-  RTL_PASS, /* type */\n-  \"compgotos\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  true, /* has_execute */\n-  TV_REORDER_BLOCKS, /* tv_id */\n-  0, /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  TODO_verify_rtl_sharing, /* todo_flags_finish */\n-};\n-\n-class pass_duplicate_computed_gotos : public rtl_opt_pass\n-{\n-public:\n-  pass_duplicate_computed_gotos (gcc::context *ctxt)\n-    : rtl_opt_pass (pass_data_duplicate_computed_gotos, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  virtual bool gate (function *);\n-  unsigned int execute () { return duplicate_computed_gotos (); }\n-\n-}; // class pass_duplicate_computed_gotos\n-\n-bool\n-pass_duplicate_computed_gotos::gate (function *fun)\n-{\n-  if (targetm.cannot_modify_jumps_p ())\n-    return false;\n-  return (optimize > 0\n-\t  && flag_expensive_optimizations\n-\t  && ! optimize_function_for_size_p (fun));\n-}\n-\n } // anon namespace\n \n rtl_opt_pass *\n@@ -2627,12 +2626,57 @@ make_pass_duplicate_computed_gotos (gcc::context *ctxt)\n    Unconditional branches are dealt with by converting them into\n    indirect jumps.  */\n \n-static unsigned\n-partition_hot_cold_basic_blocks (void)\n+namespace {\n+\n+const pass_data pass_data_partition_blocks =\n+{\n+  RTL_PASS, /* type */\n+  \"bbpart\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_execute */\n+  TV_REORDER_BLOCKS, /* tv_id */\n+  PROP_cfglayout, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_partition_blocks : public rtl_opt_pass\n+{\n+public:\n+  pass_partition_blocks (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_partition_blocks, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *);\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_partition_blocks\n+\n+bool\n+pass_partition_blocks::gate (function *fun)\n+{\n+  /* The optimization to partition hot/cold basic blocks into separate\n+     sections of the .o file does not work well with linkonce or with\n+     user defined section attributes.  Don't call it if either case\n+     arises.  */\n+  return (flag_reorder_blocks_and_partition\n+\t  && optimize\n+\t  /* See gate_handle_reorder_blocks.  We should not partition if\n+\t     we are going to omit the reordering.  */\n+\t  && optimize_function_for_speed_p (fun)\n+\t  && !DECL_ONE_ONLY (current_function_decl)\n+\t  && !user_defined_section_attribute);\n+}\n+\n+unsigned\n+pass_partition_blocks::execute (function *fun)\n {\n   vec<edge> crossing_edges;\n \n-  if (n_basic_blocks_for_fn (cfun) <= NUM_FIXED_BLOCKS + 1)\n+  if (n_basic_blocks_for_fn (fun) <= NUM_FIXED_BLOCKS + 1)\n     return 0;\n \n   df_set_flags (DF_DEFER_INSN_RESCAN);\n@@ -2693,7 +2737,7 @@ partition_hot_cold_basic_blocks (void)\n \n      In the meantime, we have no other option but to throw away all\n      of the DF data and recompute it all.  */\n-  if (cfun->eh->lp_array)\n+  if (fun->eh->lp_array)\n     {\n       df_finish_pass (true);\n       df_scan_alloc (NULL);\n@@ -2708,51 +2752,6 @@ partition_hot_cold_basic_blocks (void)\n   return TODO_verify_flow | TODO_verify_rtl_sharing;\n }\n \n-namespace {\n-\n-const pass_data pass_data_partition_blocks =\n-{\n-  RTL_PASS, /* type */\n-  \"bbpart\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  true, /* has_execute */\n-  TV_REORDER_BLOCKS, /* tv_id */\n-  PROP_cfglayout, /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  0, /* todo_flags_finish */\n-};\n-\n-class pass_partition_blocks : public rtl_opt_pass\n-{\n-public:\n-  pass_partition_blocks (gcc::context *ctxt)\n-    : rtl_opt_pass (pass_data_partition_blocks, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  virtual bool gate (function *);\n-  unsigned int execute () { return partition_hot_cold_basic_blocks (); }\n-\n-}; // class pass_partition_blocks\n-\n-bool\n-pass_partition_blocks::gate (function *fun)\n-{\n-  /* The optimization to partition hot/cold basic blocks into separate\n-     sections of the .o file does not work well with linkonce or with\n-     user defined section attributes.  Don't call it if either case\n-     arises.  */\n-  return (flag_reorder_blocks_and_partition\n-\t  && optimize\n-\t  /* See gate_handle_reorder_blocks.  We should not partition if\n-\t     we are going to omit the reordering.  */\n-\t  && optimize_function_for_speed_p (fun)\n-\t  && !DECL_ONE_ONLY (current_function_decl)\n-\t  && !user_defined_section_attribute);\n-}\n-\n } // anon namespace\n \n rtl_opt_pass *"}, {"sha": "53c5f58046174dea65424bae36d1134261a93808", "filename": "gcc/bt-load.c", "status": "modified", "additions": 28, "deletions": 36, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -1494,14 +1494,6 @@ branch_target_load_optimize (bool after_prologue_epilogue_gen)\n     }\n }\n \f\n-\n-static unsigned int\n-rest_of_handle_branch_target_load_optimize1 (void)\n-{\n-  branch_target_load_optimize (epilogue_completed);\n-  return 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_branch_target_load_optimize1 =\n@@ -1527,9 +1519,11 @@ class pass_branch_target_load_optimize1 : public rtl_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *) { return flag_branch_target_load_optimize; }\n-  unsigned int execute () {\n-    return rest_of_handle_branch_target_load_optimize1 ();\n-  }\n+  virtual unsigned int execute (function *)\n+    {\n+      branch_target_load_optimize (epilogue_completed);\n+      return 0;\n+    }\n \n }; // class pass_branch_target_load_optimize1\n \n@@ -1542,28 +1536,6 @@ make_pass_branch_target_load_optimize1 (gcc::context *ctxt)\n }\n \n \n-static unsigned int\n-rest_of_handle_branch_target_load_optimize2 (void)\n-{\n-  static int warned = 0;\n-\n-  /* Leave this a warning for now so that it is possible to experiment\n-     with running this pass twice.  In 3.6, we should either make this\n-     an error, or use separate dump files.  */\n-  if (flag_branch_target_load_optimize\n-      && flag_branch_target_load_optimize2\n-      && !warned)\n-    {\n-      warning (0, \"branch target register load optimization is not intended \"\n-\t\t  \"to be run twice\");\n-\n-      warned = 1;\n-    }\n-\n-  branch_target_load_optimize (epilogue_completed);\n-  return 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_branch_target_load_optimize2 =\n@@ -1593,12 +1565,32 @@ class pass_branch_target_load_optimize2 : public rtl_opt_pass\n       return (optimize > 0 && flag_branch_target_load_optimize2);\n     }\n \n-  unsigned int execute () {\n-    return rest_of_handle_branch_target_load_optimize2 ();\n-  }\n+  virtual unsigned int execute (function *);\n \n }; // class pass_branch_target_load_optimize2\n \n+unsigned int\n+pass_branch_target_load_optimize2::execute (function *)\n+{\n+  static int warned = 0;\n+\n+  /* Leave this a warning for now so that it is possible to experiment\n+     with running this pass twice.  In 3.6, we should either make this\n+     an error, or use separate dump files.  */\n+  if (flag_branch_target_load_optimize\n+      && flag_branch_target_load_optimize2\n+      && !warned)\n+    {\n+      warning (0, \"branch target register load optimization is not intended \"\n+\t       \"to be run twice\");\n+\n+      warned = 1;\n+    }\n+\n+  branch_target_load_optimize (epilogue_completed);\n+  return 0;\n+}\n+\n } // anon namespace\n \n rtl_opt_pass *"}, {"sha": "d793a70b4dbcb43a0c6728320c9824daec139385", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -3078,17 +3078,6 @@ cleanup_cfg (int mode)\n   return changed;\n }\n \f\n-static unsigned int\n-execute_jump (void)\n-{\n-  delete_trivially_dead_insns (get_insns (), max_reg_num ());\n-  if (dump_file)\n-    dump_flow_info (dump_file, dump_flags);\n-  cleanup_cfg ((optimize ? CLEANUP_EXPENSIVE : 0)\n-\t       | (flag_thread_jumps ? CLEANUP_THREADING : 0));\n-  return 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_jump =\n@@ -3113,10 +3102,21 @@ class pass_jump : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  unsigned int execute () { return execute_jump (); }\n+  virtual unsigned int execute (function *);\n \n }; // class pass_jump\n \n+unsigned int\n+pass_jump::execute (function *)\n+{\n+  delete_trivially_dead_insns (get_insns (), max_reg_num ());\n+  if (dump_file)\n+    dump_flow_info (dump_file, dump_flags);\n+  cleanup_cfg ((optimize ? CLEANUP_EXPENSIVE : 0)\n+\t       | (flag_thread_jumps ? CLEANUP_THREADING : 0));\n+  return 0;\n+}\n+\n } // anon namespace\n \n rtl_opt_pass *\n@@ -3125,13 +3125,6 @@ make_pass_jump (gcc::context *ctxt)\n   return new pass_jump (ctxt);\n }\n \f\n-static unsigned int\n-execute_jump2 (void)\n-{\n-  cleanup_cfg (flag_crossjumping ? CLEANUP_CROSSJUMP : 0);\n-  return 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_jump2 =\n@@ -3156,7 +3149,11 @@ class pass_jump2 : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  unsigned int execute () { return execute_jump2 (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      cleanup_cfg (flag_crossjumping ? CLEANUP_CROSSJUMP : 0);\n+      return 0;\n+    }\n \n }; // class pass_jump2\n "}, {"sha": "f2fd5fc92a9bce4958192a40be79efeadce036fd", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 68, "deletions": 68, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -5530,8 +5530,39 @@ stack_protect_prologue (void)\n    confuse the CFG hooks, so be careful to not manipulate CFG during\n    the expansion.  */\n \n-static unsigned int\n-gimple_expand_cfg (void)\n+namespace {\n+\n+const pass_data pass_data_expand =\n+{\n+  RTL_PASS, /* type */\n+  \"expand\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_execute */\n+  TV_EXPAND, /* tv_id */\n+  ( PROP_ssa | PROP_gimple_leh | PROP_cfg\n+    | PROP_gimple_lcx\n+    | PROP_gimple_lvec ), /* properties_required */\n+  PROP_rtl, /* properties_provided */\n+  ( PROP_ssa | PROP_trees ), /* properties_destroyed */\n+  ( TODO_verify_ssa | TODO_verify_flow\n+    | TODO_verify_stmts ), /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_expand : public rtl_opt_pass\n+{\n+public:\n+  pass_expand (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_expand, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_expand\n+\n+unsigned int\n+pass_expand::execute (function *fun)\n {\n   basic_block bb, init_block;\n   sbitmap blocks;\n@@ -5554,17 +5585,17 @@ gimple_expand_cfg (void)\n   /* Dominators are not kept up-to-date as we may create new basic-blocks.  */\n   free_dominance_info (CDI_DOMINATORS);\n \n-  rtl_profile_for_bb (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n+  rtl_profile_for_bb (ENTRY_BLOCK_PTR_FOR_FN (fun));\n \n   insn_locations_init ();\n   if (!DECL_IS_BUILTIN (current_function_decl))\n     {\n       /* Eventually, all FEs should explicitly set function_start_locus.  */\n-      if (LOCATION_LOCUS (cfun->function_start_locus) == UNKNOWN_LOCATION)\n-       set_curr_insn_location\n-         (DECL_SOURCE_LOCATION (current_function_decl));\n+      if (LOCATION_LOCUS (fun->function_start_locus) == UNKNOWN_LOCATION)\n+\tset_curr_insn_location\n+\t  (DECL_SOURCE_LOCATION (current_function_decl));\n       else\n-       set_curr_insn_location (cfun->function_start_locus);\n+\tset_curr_insn_location (fun->function_start_locus);\n     }\n   else\n     set_curr_insn_location (UNKNOWN_LOCATION);\n@@ -5587,7 +5618,7 @@ gimple_expand_cfg (void)\n   crtl->max_used_stack_slot_alignment = STACK_BOUNDARY;\n   crtl->stack_alignment_estimated = 0;\n   crtl->preferred_stack_boundary = STACK_BOUNDARY;\n-  cfun->cfg->max_jumptable_ents = 0;\n+  fun->cfg->max_jumptable_ents = 0;\n \n   /* Resovle the function section.  Some targets, like ARM EABI rely on knowledge\n      of the function section at exapnsion time to predict distance of calls.  */\n@@ -5606,14 +5637,14 @@ gimple_expand_cfg (void)\n   /* Honor stack protection warnings.  */\n   if (warn_stack_protect)\n     {\n-      if (cfun->calls_alloca)\n+      if (fun->calls_alloca)\n \twarning (OPT_Wstack_protector,\n \t\t \"stack protector not protecting local variables: \"\n-                 \"variable length buffer\");\n+\t\t \"variable length buffer\");\n       if (has_short_buffer && !crtl->stack_protect_guard)\n \twarning (OPT_Wstack_protector,\n \t\t \"stack protector not protecting function: \"\n-                 \"all local arrays are less than %d bytes long\",\n+\t\t \"all local arrays are less than %d bytes long\",\n \t\t (int) PARAM_VALUE (PARAM_SSP_BUFFER_SIZE));\n     }\n \n@@ -5644,12 +5675,12 @@ gimple_expand_cfg (void)\n       gcc_assert (SA.partition_to_pseudo[i]);\n \n       /* If this decl was marked as living in multiple places, reset\n-         this now to NULL.  */\n+\t this now to NULL.  */\n       if (DECL_RTL_IF_SET (var) == pc_rtx)\n \tSET_DECL_RTL (var, NULL);\n \n       /* Some RTL parts really want to look at DECL_RTL(x) when x\n-         was a decl marked in REG_ATTR or MEM_ATTR.  We could use\n+\t was a decl marked in REG_ATTR or MEM_ATTR.  We could use\n \t SET_DECL_RTL here making this available, but that would mean\n \t to select one of the potentially many RTLs for one DECL.  Instead\n \t of doing that we simply reset the MEM_EXPR of the RTL in question,\n@@ -5718,11 +5749,11 @@ gimple_expand_cfg (void)\n \n   /* Clear EDGE_EXECUTABLE on the entry edge(s).  It is cleaned from the\n      remaining edges later.  */\n-  FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR_FOR_FN (cfun)->succs)\n+  FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR_FOR_FN (fun)->succs)\n     e->flags &= ~EDGE_EXECUTABLE;\n \n   lab_rtx_for_bb = pointer_map_create ();\n-  FOR_BB_BETWEEN (bb, init_block->next_bb, EXIT_BLOCK_PTR_FOR_FN (cfun),\n+  FOR_BB_BETWEEN (bb, init_block->next_bb, EXIT_BLOCK_PTR_FOR_FN (fun),\n \t\t  next_bb)\n     bb = expand_gimple_basic_block (bb, var_ret_seq != NULL_RTX);\n \n@@ -5740,7 +5771,7 @@ gimple_expand_cfg (void)\n \n   timevar_push (TV_POST_EXPAND);\n   /* We are no longer in SSA form.  */\n-  cfun->gimple_df->in_ssa_p = false;\n+  fun->gimple_df->in_ssa_p = false;\n   if (current_loops)\n     loops_state_clear (LOOP_CLOSED_SSA);\n \n@@ -5762,14 +5793,14 @@ gimple_expand_cfg (void)\n     }\n \n   /* Zap the tree EH table.  */\n-  set_eh_throw_stmt_table (cfun, NULL);\n+  set_eh_throw_stmt_table (fun, NULL);\n \n   /* We need JUMP_LABEL be set in order to redirect jumps, and hence\n      split edges which edge insertions might do.  */\n   rebuild_jump_labels (get_insns ());\n \n-  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun),\n-\t\t  EXIT_BLOCK_PTR_FOR_FN (cfun), next_bb)\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (fun),\n+\t\t  EXIT_BLOCK_PTR_FOR_FN (fun), next_bb)\n     {\n       edge e;\n       edge_iterator ei;\n@@ -5780,8 +5811,8 @@ gimple_expand_cfg (void)\n \t      rebuild_jump_labels_chain (e->insns.r);\n \t      /* Put insns after parm birth, but before\n \t\t NOTE_INSNS_FUNCTION_BEG.  */\n-\t      if (e->src == ENTRY_BLOCK_PTR_FOR_FN (cfun)\n-\t\t  && single_succ_p (ENTRY_BLOCK_PTR_FOR_FN (cfun)))\n+\t      if (e->src == ENTRY_BLOCK_PTR_FOR_FN (fun)\n+\t\t  && single_succ_p (ENTRY_BLOCK_PTR_FOR_FN (fun)))\n \t\t{\n \t\t  rtx insns = e->insns.r;\n \t\t  e->insns.r = NULL_RTX;\n@@ -5802,8 +5833,8 @@ gimple_expand_cfg (void)\n   /* We're done expanding trees to RTL.  */\n   currently_expanding_to_rtl = 0;\n \n-  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb,\n-\t\t  EXIT_BLOCK_PTR_FOR_FN (cfun), next_bb)\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (fun)->next_bb,\n+\t\t  EXIT_BLOCK_PTR_FOR_FN (fun), next_bb)\n     {\n       edge e;\n       edge_iterator ei;\n@@ -5824,7 +5855,7 @@ gimple_expand_cfg (void)\n \t}\n     }\n \n-  blocks = sbitmap_alloc (last_basic_block_for_fn (cfun));\n+  blocks = sbitmap_alloc (last_basic_block_for_fn (fun));\n   bitmap_ones (blocks);\n   find_many_sub_basic_blocks (blocks);\n   sbitmap_free (blocks);\n@@ -5840,7 +5871,7 @@ gimple_expand_cfg (void)\n   /* After initial rtl generation, call back to finish generating\n      exception support code.  We need to do this before cleaning up\n      the CFG as the code does not expect dead landing pads.  */\n-  if (cfun->eh->region_tree != NULL)\n+  if (fun->eh->region_tree != NULL)\n     finish_eh_generation ();\n \n   /* Remove unreachable blocks, otherwise we cannot compute dominators\n@@ -5878,14 +5909,14 @@ gimple_expand_cfg (void)\n \n   /* If we're emitting a nested function, make sure its parent gets\n      emitted as well.  Doing otherwise confuses debug info.  */\n-  {\n-    tree parent;\n-    for (parent = DECL_CONTEXT (current_function_decl);\n-\t parent != NULL_TREE;\n-\t parent = get_containing_scope (parent))\n-      if (TREE_CODE (parent) == FUNCTION_DECL)\n-\tTREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (parent)) = 1;\n-  }\n+    {\n+      tree parent;\n+      for (parent = DECL_CONTEXT (current_function_decl);\n+\t   parent != NULL_TREE;\n+\t   parent = get_containing_scope (parent))\n+\tif (TREE_CODE (parent) == FUNCTION_DECL)\n+\t  TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (parent)) = 1;\n+    }\n \n   /* We are now committed to emitting code for this function.  Do any\n      preparation, such as emitting abstract debug info for the inline\n@@ -5900,53 +5931,22 @@ gimple_expand_cfg (void)\n   naked_return_label = NULL;\n \n   /* After expanding, the tm_restart map is no longer needed.  */\n-  if (cfun->gimple_df->tm_restart)\n+  if (fun->gimple_df->tm_restart)\n     {\n-      htab_delete (cfun->gimple_df->tm_restart);\n-      cfun->gimple_df->tm_restart = NULL;\n+      htab_delete (fun->gimple_df->tm_restart);\n+      fun->gimple_df->tm_restart = NULL;\n     }\n \n   /* Tag the blocks with a depth number so that change_scope can find\n      the common parent easily.  */\n-  set_block_levels (DECL_INITIAL (cfun->decl), 0);\n+  set_block_levels (DECL_INITIAL (fun->decl), 0);\n   default_rtl_profile ();\n \n   timevar_pop (TV_POST_EXPAND);\n \n   return 0;\n }\n \n-namespace {\n-\n-const pass_data pass_data_expand =\n-{\n-  RTL_PASS, /* type */\n-  \"expand\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  true, /* has_execute */\n-  TV_EXPAND, /* tv_id */\n-  ( PROP_ssa | PROP_gimple_leh | PROP_cfg\n-    | PROP_gimple_lcx\n-    | PROP_gimple_lvec ), /* properties_required */\n-  PROP_rtl, /* properties_provided */\n-  ( PROP_ssa | PROP_trees ), /* properties_destroyed */\n-  ( TODO_verify_ssa | TODO_verify_flow\n-    | TODO_verify_stmts ), /* todo_flags_start */\n-  0, /* todo_flags_finish */\n-};\n-\n-class pass_expand : public rtl_opt_pass\n-{\n-public:\n-  pass_expand (gcc::context *ctxt)\n-    : rtl_opt_pass (pass_data_expand, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  unsigned int execute () { return gimple_expand_cfg (); }\n-\n-}; // class pass_expand\n-\n } // anon namespace\n \n rtl_opt_pass *"}, {"sha": "5dd27d2795b58a0c29da8d87588d4414ed5de37b", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 41, "deletions": 44, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -442,26 +442,6 @@ free_bb_for_insn (void)\n   return 0;\n }\n \n-static unsigned int\n-rest_of_pass_free_cfg (void)\n-{\n-#ifdef DELAY_SLOTS\n-  /* The resource.c machinery uses DF but the CFG isn't guaranteed to be\n-     valid at that point so it would be too late to call df_analyze.  */\n-  if (optimize > 0 && flag_delayed_branch)\n-    {\n-      df_note_add_problem ();\n-      df_analyze ();\n-    }\n-#endif\n-\n-  if (crtl->has_bb_partition)\n-    insert_section_boundary_note ();\n-\n-  free_bb_for_insn ();\n-  return 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_free_cfg =\n@@ -486,10 +466,30 @@ class pass_free_cfg : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  unsigned int execute () { return rest_of_pass_free_cfg (); }\n+  virtual unsigned int execute (function *);\n \n }; // class pass_free_cfg\n \n+unsigned int\n+pass_free_cfg::execute (function *)\n+{\n+#ifdef DELAY_SLOTS\n+  /* The resource.c machinery uses DF but the CFG isn't guaranteed to be\n+     valid at that point so it would be too late to call df_analyze.  */\n+  if (optimize > 0 && flag_delayed_branch)\n+    {\n+      df_note_add_problem ();\n+      df_analyze ();\n+    }\n+#endif\n+\n+  if (crtl->has_bb_partition)\n+    insert_section_boundary_note ();\n+\n+  free_bb_for_insn ();\n+  return 0;\n+}\n+\n } // anon namespace\n \n rtl_opt_pass *\n@@ -3466,27 +3466,6 @@ record_effective_endpoints (void)\n     cfg_layout_function_footer = unlink_insn_chain (cfg_layout_function_footer, get_last_insn ());\n }\n \f\n-static unsigned int\n-into_cfg_layout_mode (void)\n-{\n-  cfg_layout_initialize (0);\n-  return 0;\n-}\n-\n-static unsigned int\n-outof_cfg_layout_mode (void)\n-{\n-  basic_block bb;\n-\n-  FOR_EACH_BB_FN (bb, cfun)\n-    if (bb->next_bb != EXIT_BLOCK_PTR_FOR_FN (cfun))\n-      bb->aux = bb->next_bb;\n-\n-  cfg_layout_finalize ();\n-\n-  return 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_into_cfg_layout_mode =\n@@ -3511,7 +3490,11 @@ class pass_into_cfg_layout_mode : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  unsigned int execute () { return into_cfg_layout_mode (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      cfg_layout_initialize (0);\n+      return 0;\n+    }\n \n }; // class pass_into_cfg_layout_mode\n \n@@ -3547,10 +3530,24 @@ class pass_outof_cfg_layout_mode : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  unsigned int execute () { return outof_cfg_layout_mode (); }\n+  virtual unsigned int execute (function *);\n \n }; // class pass_outof_cfg_layout_mode\n \n+unsigned int\n+pass_outof_cfg_layout_mode::execute (function *fun)\n+{\n+  basic_block bb;\n+\n+  FOR_EACH_BB_FN (bb, fun)\n+    if (bb->next_bb != EXIT_BLOCK_PTR_FOR_FN (fun))\n+      bb->aux = bb->next_bb;\n+\n+  cfg_layout_finalize ();\n+\n+  return 0;\n+}\n+\n } // anon namespace\n \n rtl_opt_pass *"}, {"sha": "6bdc8ca0eda9d73f64baa35d12ace0d8b59fd7ae", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -305,8 +305,36 @@ ipa_record_stmt_references (struct cgraph_node *node, gimple stmt)\n /* Create cgraph edges for function calls.\n    Also look for functions and variables having addresses taken.  */\n \n-static unsigned int\n-build_cgraph_edges (void)\n+namespace {\n+\n+const pass_data pass_data_build_cgraph_edges =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"*build_cgraph_edges\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  PROP_cfg, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_build_cgraph_edges : public gimple_opt_pass\n+{\n+public:\n+  pass_build_cgraph_edges (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_build_cgraph_edges, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_build_cgraph_edges\n+\n+unsigned int\n+pass_build_cgraph_edges::execute (function *fun)\n {\n   basic_block bb;\n   struct cgraph_node *node = cgraph_get_node (current_function_decl);\n@@ -317,7 +345,7 @@ build_cgraph_edges (void)\n \n   /* Create the callgraph edges and record the nodes referenced by the function.\n      body.  */\n-  FOR_EACH_BB_FN (bb, cfun)\n+  FOR_EACH_BB_FN (bb, fun)\n     {\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n@@ -370,45 +398,17 @@ build_cgraph_edges (void)\n    }\n \n   /* Look for initializers of constant variables and private statics.  */\n-  FOR_EACH_LOCAL_DECL (cfun, ix, decl)\n+  FOR_EACH_LOCAL_DECL (fun, ix, decl)\n     if (TREE_CODE (decl) == VAR_DECL\n \t&& (TREE_STATIC (decl) && !DECL_EXTERNAL (decl))\n \t&& !DECL_HAS_VALUE_EXPR_P (decl))\n       varpool_finalize_decl (decl);\n-  record_eh_tables (node, cfun);\n+  record_eh_tables (node, fun);\n \n   pointer_set_destroy (visited_nodes);\n   return 0;\n }\n \n-namespace {\n-\n-const pass_data pass_data_build_cgraph_edges =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"*build_cgraph_edges\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  true, /* has_execute */\n-  TV_NONE, /* tv_id */\n-  PROP_cfg, /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  0, /* todo_flags_finish */\n-};\n-\n-class pass_build_cgraph_edges : public gimple_opt_pass\n-{\n-public:\n-  pass_build_cgraph_edges (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_build_cgraph_edges, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  unsigned int execute () { return build_cgraph_edges (); }\n-\n-}; // class pass_build_cgraph_edges\n-\n } // anon namespace\n \n gimple_opt_pass *\n@@ -539,7 +539,7 @@ class pass_rebuild_cgraph_edges : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   opt_pass * clone () { return new pass_rebuild_cgraph_edges (m_ctxt); }\n-  unsigned int execute () { return rebuild_cgraph_edges (); }\n+  virtual unsigned int execute (function *) { return rebuild_cgraph_edges (); }\n \n }; // class pass_rebuild_cgraph_edges\n \n@@ -552,15 +552,6 @@ make_pass_rebuild_cgraph_edges (gcc::context *ctxt)\n }\n \n \n-static unsigned int\n-remove_cgraph_callee_edges (void)\n-{\n-  struct cgraph_node *node = cgraph_get_node (current_function_decl);\n-  cgraph_node_remove_callees (node);\n-  ipa_remove_all_references (&node->ref_list);\n-  return 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_remove_cgraph_callee_edges =\n@@ -588,10 +579,19 @@ class pass_remove_cgraph_callee_edges : public gimple_opt_pass\n   opt_pass * clone () {\n     return new pass_remove_cgraph_callee_edges (m_ctxt);\n   }\n-  unsigned int execute () { return remove_cgraph_callee_edges (); }\n+  virtual unsigned int execute (function *);\n \n }; // class pass_remove_cgraph_callee_edges\n \n+unsigned int\n+pass_remove_cgraph_callee_edges::execute (function *)\n+{\n+  struct cgraph_node *node = cgraph_get_node (current_function_decl);\n+  cgraph_node_remove_callees (node);\n+  ipa_remove_all_references (&node->ref_list);\n+  return 0;\n+}\n+\n } // anon namespace\n \n gimple_opt_pass *"}, {"sha": "399beb4c1bfd879405db65db18ab6e99370624a0", "filename": "gcc/combine-stack-adj.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fcombine-stack-adj.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fcombine-stack-adj.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine-stack-adj.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -653,7 +653,10 @@ class pass_stack_adjustments : public rtl_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *);\n-  unsigned int execute () { return rest_of_handle_stack_adjustments (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      return rest_of_handle_stack_adjustments ();\n+    }\n \n }; // class pass_stack_adjustments\n "}, {"sha": "9a78c064945c03ea095fe6c9e4b91fca9a0587cc", "filename": "gcc/combine.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -13909,7 +13909,10 @@ class pass_combine : public rtl_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *) { return (optimize > 0); }\n-  unsigned int execute () { return rest_of_handle_combine (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      return rest_of_handle_combine ();\n+    }\n \n }; // class pass_combine\n "}, {"sha": "7555d48c6132b6822692f0fe6af3b141bedadc7a", "filename": "gcc/compare-elim.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fcompare-elim.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fcompare-elim.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcompare-elim.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -676,7 +676,10 @@ class pass_compare_elim_after_reload : public rtl_opt_pass\n       return flag_compare_elim_after_reload;\n     }\n \n-  unsigned int execute () { return execute_compare_elim_after_reload (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      return execute_compare_elim_after_reload ();\n+    }\n \n }; // class pass_compare_elim_after_reload\n "}, {"sha": "64d1312bf654d45e41599e782bce013c6f8569b8", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -623,7 +623,7 @@ class pass_arc_ifcvt : public rtl_opt_pass\n \n   /* opt_pass methods: */\n   opt_pass * clone () { return new pass_arc_ifcvt (m_ctxt); }\n-  unsigned int execute () { return arc_ifcvt (); }\n+  virtual unsigned int execute (function *) { return arc_ifcvt (); }\n };\n \n } // anon namespace\n@@ -660,7 +660,10 @@ class pass_arc_predicate_delay_insns : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  unsigned int execute () { return arc_predicate_delay_insns (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      return arc_predicate_delay_insns ();\n+    }\n };\n \n } // anon namespace"}, {"sha": "9617041a3106e96cb279173a226c7e7a7a78c0f6", "filename": "gcc/config/epiphany/mode-switch-use.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fconfig%2Fepiphany%2Fmode-switch-use.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fconfig%2Fepiphany%2Fmode-switch-use.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fmode-switch-use.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -95,7 +95,7 @@ class pass_mode_switch_use : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  unsigned int execute () { return insert_uses (); }\n+  virtual unsigned int execute (function *) { return insert_uses (); }\n \n }; // class pass_mode_switch_use\n "}, {"sha": "fa8fea5097729b890cc7e275d1af054da1ceef05", "filename": "gcc/config/epiphany/resolve-sw-modes.c", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fconfig%2Fepiphany%2Fresolve-sw-modes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fconfig%2Fepiphany%2Fresolve-sw-modes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fresolve-sw-modes.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -38,15 +38,44 @@ along with GCC; see the file COPYING3.  If not see\n #include \"insn-attr-common.h\"\n #include \"tree-pass.h\"\n \n+namespace {\n+\n+const pass_data pass_data_resolve_sw_modes =\n+{\n+  RTL_PASS, /* type */\n+  \"resolve_sw_modes\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_execute */\n+  TV_MODE_SWITCH, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_df_finish | TODO_verify_rtl_sharing | 0 ), /* todo_flags_finish */\n+};\n+\n+class pass_resolve_sw_modes : public rtl_opt_pass\n+{\n+public:\n+  pass_resolve_sw_modes(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_resolve_sw_modes, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *) { return optimize; }\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_resolve_sw_modes\n+\n /* Clean-up after mode switching:\n    Check for mode setting insns that have FP_MODE_ROUND_UNKNOWN.\n    If only one rounding mode is required, select that one.\n    Else we have to choose one to use in this mode setting insn and\n    insert new mode setting insns on the edges where the other mode\n    becomes unambigous.  */\n \n-static unsigned\n-resolve_sw_modes (void)\n+unsigned\n+pass_resolve_sw_modes::execute (function *fun)\n {\n   basic_block bb;\n   rtx insn, src;\n@@ -55,15 +84,15 @@ resolve_sw_modes (void)\n   bool need_commit = false;\n   bool finalize_fp_sets = (MACHINE_FUNCTION (cfun)->unknown_mode_sets == 0);\n \n-  todo.create (last_basic_block_for_fn (cfun));\n-  pushed = sbitmap_alloc (last_basic_block_for_fn (cfun));\n+  todo.create (last_basic_block_for_fn (fun));\n+  pushed = sbitmap_alloc (last_basic_block_for_fn (fun));\n   bitmap_clear (pushed);\n   if (!finalize_fp_sets)\n     {\n       df_note_add_problem ();\n       df_analyze ();\n     }\n-  FOR_EACH_BB_FN (bb, cfun)\n+  FOR_EACH_BB_FN (bb, fun)\n     FOR_BB_INSNS (bb, insn)\n       {\n \tenum attr_fp_mode selected_mode;\n@@ -155,35 +184,6 @@ resolve_sw_modes (void)\n   return 0;\n }\n \n-namespace {\n-\n-const pass_data pass_data_resolve_sw_modes =\n-{\n-  RTL_PASS, /* type */\n-  \"resolve_sw_modes\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  true, /* has_execute */\n-  TV_MODE_SWITCH, /* tv_id */\n-  0, /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  ( TODO_df_finish | TODO_verify_rtl_sharing | 0 ), /* todo_flags_finish */\n-};\n-\n-class pass_resolve_sw_modes : public rtl_opt_pass\n-{\n-public:\n-  pass_resolve_sw_modes(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_resolve_sw_modes, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  virtual bool gate (function *) { return optimize; }\n-  unsigned int execute () { return resolve_sw_modes (); }\n-\n-}; // class pass_resolve_sw_modes\n-\n } // anon namespace\n \n rtl_opt_pass *"}, {"sha": "c2dcbce1dc015be4fe4d3c0f57293d8a88b9cf84", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -2542,7 +2542,10 @@ class pass_insert_vzeroupper : public rtl_opt_pass\n       return TARGET_AVX && !TARGET_AVX512F && TARGET_VZEROUPPER;\n     }\n \n-  unsigned int execute () { return rest_of_handle_insert_vzeroupper (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      return rest_of_handle_insert_vzeroupper ();\n+    }\n \n }; // class pass_insert_vzeroupper\n "}, {"sha": "45256e99250f2307e997a50dfb445dc55acab510", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -16550,7 +16550,7 @@ class pass_mips_machine_reorg2 : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  unsigned int execute () { return mips_machine_reorg2 (); }\n+  virtual unsigned int execute (function *) { return mips_machine_reorg2 (); }\n \n }; // class pass_mips_machine_reorg2\n "}, {"sha": "0731491a23f3d0ae021c7aa0dd95a8424782bbcc", "filename": "gcc/config/rl78/rl78.c", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fconfig%2Frl78%2Frl78.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fconfig%2Frl78%2Frl78.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -117,14 +117,6 @@ rl78_init_machine_status (void)\n   return m;\n }\n \n-/* Runs the devirtualization pass.  */\n-static unsigned int\n-devirt_pass (void)\n-{\n-  rl78_reorg ();\n-  return 0;\n-}\n-\n /* This pass converts virtual instructions using virtual registers, to\n    real instructions using real registers.  Rather than run it as\n    reorg, we reschedule it before vartrack to help with debugging.  */\n@@ -153,7 +145,12 @@ class pass_rl78_devirt : public rtl_opt_pass\n   }\n \n   /* opt_pass methods: */\n-  unsigned int execute () { return devirt_pass (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      rl78_reorg ();\n+      return 0;\n+    }\n+\n };\n \n } // anon namespace\n@@ -235,7 +232,7 @@ class pass_rl78_move_elim : public rtl_opt_pass\n   }\n \n   /* opt_pass methods: */\n-  unsigned int execute () { return move_elim_pass (); }\n+  virtual unsigned int execute (function *) { return move_elim_pass (); }\n };\n \n } // anon namespace"}, {"sha": "cc8f32e169c7dba9a86c5c188b3f824e84cd7f90", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -8631,33 +8631,6 @@ s390_restore_gprs_from_fprs (void)\n /* A pass run immediately before shrink-wrapping and prologue and epilogue\n    generation.  */\n \n-static unsigned int\n-s390_early_mach (void)\n-{\n-  rtx insn;\n-\n-  /* Try to get rid of the FPR clobbers.  */\n-  s390_optimize_nonescaping_tx ();\n-\n-  /* Re-compute register info.  */\n-  s390_register_info ();\n-\n-  /* If we're using a base register, ensure that it is always valid for\n-     the first non-prologue instruction.  */\n-  if (cfun->machine->base_reg)\n-    emit_insn_at_entry (gen_main_pool (cfun->machine->base_reg));\n-\n-  /* Annotate all constant pool references to let the scheduler know\n-     they implicitly use the base register.  */\n-  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-    if (INSN_P (insn))\n-      {\n-\tannotate_constant_pool_refs (&PATTERN (insn));\n-\tdf_insn_rescan (insn);\n-      }\n-  return 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_s390_early_mach =\n@@ -8683,10 +8656,37 @@ class pass_s390_early_mach : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  unsigned int execute () { return s390_early_mach (); }\n+  virtual unsigned int execute (function *);\n \n }; // class pass_s390_early_mach\n \n+unsigned int\n+pass_s390_early_mach::execute (function *fun)\n+{\n+  rtx insn;\n+\n+  /* Try to get rid of the FPR clobbers.  */\n+  s390_optimize_nonescaping_tx ();\n+\n+  /* Re-compute register info.  */\n+  s390_register_info ();\n+\n+  /* If we're using a base register, ensure that it is always valid for\n+     the first non-prologue instruction.  */\n+  if (fun->machine->base_reg)\n+    emit_insn_at_entry (gen_main_pool (fun->machine->base_reg));\n+\n+  /* Annotate all constant pool references to let the scheduler know\n+     they implicitly use the base register.  */\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    if (INSN_P (insn))\n+      {\n+\tannotate_constant_pool_refs (&PATTERN (insn));\n+\tdf_insn_rescan (insn);\n+      }\n+  return 0;\n+}\n+\n } // anon namespace\n \n /* Expand the prologue into a bunch of separate insns.  */"}, {"sha": "62354eed028f05adb6589a2291d227455889eff2", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -1145,7 +1145,10 @@ class pass_work_around_errata : public rtl_opt_pass\n       return sparc_fix_at697f != 0 || sparc_fix_ut699 != 0;\n     }\n \n-  unsigned int execute () { return sparc_do_work_around_errata (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      return sparc_do_work_around_errata ();\n+    }\n \n }; // class pass_work_around_errata\n "}, {"sha": "d29b6f68f271e3f1806369f63ecc895492697ac9", "filename": "gcc/cprop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcprop.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -1943,7 +1943,7 @@ class pass_rtl_cprop : public rtl_opt_pass\n \t&& dbg_cnt (cprop);\n     }\n \n-  unsigned int execute () { return execute_rtl_cprop (); }\n+  virtual unsigned int execute (function *) { return execute_rtl_cprop (); }\n \n }; // class pass_rtl_cprop\n "}, {"sha": "40bc2be6a018aa34f65f8c8c7f6499643118dab5", "filename": "gcc/cse.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -7510,7 +7510,7 @@ class pass_cse : public rtl_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *) { return optimize > 0; }\n-  unsigned int execute () { return rest_of_handle_cse (); }\n+  virtual unsigned int execute (function *) { return rest_of_handle_cse (); }\n \n }; // class pass_cse\n \n@@ -7587,7 +7587,7 @@ class pass_cse2 : public rtl_opt_pass\n       return optimize > 0 && flag_rerun_cse_after_loop;\n     }\n \n-  unsigned int execute () { return rest_of_handle_cse2 (); }\n+  virtual unsigned int execute (function *) { return rest_of_handle_cse2 (); }\n \n }; // class pass_cse2\n \n@@ -7662,9 +7662,10 @@ class pass_cse_after_global_opts : public rtl_opt_pass\n       return optimize > 0 && flag_rerun_cse_after_global_opts;\n     }\n \n-  unsigned int execute () {\n-    return rest_of_handle_cse_after_global_opts ();\n-  }\n+  virtual unsigned int execute (function *)\n+    {\n+      return rest_of_handle_cse_after_global_opts ();\n+    }\n \n }; // class pass_cse_after_global_opts\n "}, {"sha": "344e31af0746d515de50d281632194de110159cd", "filename": "gcc/dce.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdce.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -808,7 +808,10 @@ class pass_ud_rtl_dce : public rtl_opt_pass\n       return optimize > 1 && flag_dce && dbg_cnt (dce_ud);\n     }\n \n-  unsigned int execute () { return rest_of_handle_ud_dce (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      return rest_of_handle_ud_dce ();\n+    }\n \n }; // class pass_ud_rtl_dce\n \n@@ -1237,7 +1240,10 @@ class pass_fast_rtl_dce : public rtl_opt_pass\n       return optimize > 0 && flag_dce && dbg_cnt (dce_fast);\n     }\n \n-  unsigned int execute () { return rest_of_handle_fast_dce (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      return rest_of_handle_fast_dce ();\n+    }\n \n }; // class pass_fast_rtl_dce\n "}, {"sha": "9fdf601071c256b600ed5c3e5adf3abb03714c8a", "filename": "gcc/df-core.c", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -765,7 +765,10 @@ class pass_df_initialize_opt : public rtl_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *) { return optimize > 0; }\n-  unsigned int execute () { return rest_of_handle_df_initialize (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      return rest_of_handle_df_initialize ();\n+    }\n \n }; // class pass_df_initialize_opt\n \n@@ -803,7 +806,10 @@ class pass_df_initialize_no_opt : public rtl_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *) { return optimize == 0; }\n-  unsigned int execute () { return rest_of_handle_df_initialize (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      return rest_of_handle_df_initialize ();\n+    }\n \n }; // class pass_df_initialize_no_opt\n \n@@ -867,7 +873,10 @@ class pass_df_finish : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  unsigned int execute () { return rest_of_handle_df_finish (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      return rest_of_handle_df_finish ();\n+    }\n \n }; // class pass_df_finish\n "}, {"sha": "88b8c373bbf57abd299378d397bf934c578a5d80", "filename": "gcc/dse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -3736,7 +3736,7 @@ class pass_rtl_dse1 : public rtl_opt_pass\n       return optimize > 0 && flag_dse && dbg_cnt (dse1);\n     }\n \n-  unsigned int execute () { return rest_of_handle_dse (); }\n+  virtual unsigned int execute (function *) { return rest_of_handle_dse (); }\n \n }; // class pass_rtl_dse1\n \n@@ -3777,7 +3777,7 @@ class pass_rtl_dse2 : public rtl_opt_pass\n       return optimize > 0 && flag_dse && dbg_cnt (dse2);\n     }\n \n-  unsigned int execute () { return rest_of_handle_dse (); }\n+  virtual unsigned int execute (function *) { return rest_of_handle_dse (); }\n \n }; // class pass_rtl_dse2\n "}, {"sha": "41808905bc18858e64b4001ef3674dd2ae9af355", "filename": "gcc/dwarf2cfi.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fdwarf2cfi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fdwarf2cfi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2cfi.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -3402,7 +3402,7 @@ class pass_dwarf2_frame : public rtl_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *);\n-  unsigned int execute () { return execute_dwarf2_frame (); }\n+  virtual unsigned int execute (function *) { return execute_dwarf2_frame (); }\n \n }; // class pass_dwarf2_frame\n "}, {"sha": "5b33c9cc301f9a101fcece6102f08e1ae7f3bbc1", "filename": "gcc/except.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -2025,7 +2025,10 @@ class pass_set_nothrow_function_flags : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  unsigned int execute () { return set_nothrow_function_flags (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      return set_nothrow_function_flags ();\n+    }\n \n }; // class pass_set_nothrow_function_flags\n \n@@ -2645,7 +2648,10 @@ class pass_convert_to_eh_region_ranges : public rtl_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *);\n-  unsigned int execute () { return convert_to_eh_region_ranges (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      return convert_to_eh_region_ranges ();\n+    }\n \n }; // class pass_convert_to_eh_region_ranges\n "}, {"sha": "8c6f6ee682b5d074fe6571a6ff528042c3f7cbd7", "filename": "gcc/final.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -871,7 +871,7 @@ class pass_compute_alignments : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  unsigned int execute () { return compute_alignments (); }\n+  virtual unsigned int execute (function *) { return compute_alignments (); }\n \n }; // class pass_compute_alignments\n \n@@ -4499,7 +4499,7 @@ class pass_final : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  unsigned int execute () { return rest_of_handle_final (); }\n+  virtual unsigned int execute (function *) { return rest_of_handle_final (); }\n \n }; // class pass_final\n \n@@ -4544,7 +4544,10 @@ class pass_shorten_branches : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  unsigned int execute () { return rest_of_handle_shorten_branches (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      return rest_of_handle_shorten_branches ();\n+    }\n \n }; // class pass_shorten_branches\n \n@@ -4707,7 +4710,10 @@ class pass_clean_state : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  unsigned int execute () { return rest_of_clean_state (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      return rest_of_clean_state ();\n+    }\n \n }; // class pass_clean_state\n "}, {"sha": "383a52a8fc0bdfacda126f54dfae3277b1247f9a", "filename": "gcc/function.c", "status": "modified", "additions": 43, "deletions": 36, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -1967,7 +1967,10 @@ class pass_instantiate_virtual_regs : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  unsigned int execute () { return instantiate_virtual_regs (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      return instantiate_virtual_regs ();\n+    }\n \n }; // class pass_instantiate_virtual_regs\n \n@@ -6965,7 +6968,10 @@ class pass_leaf_regs : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  unsigned int execute () { return rest_of_handle_check_leaf_regs (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      return rest_of_handle_check_leaf_regs ();\n+    }\n \n }; // class pass_leaf_regs\n \n@@ -7025,9 +7031,10 @@ class pass_thread_prologue_and_epilogue : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  unsigned int execute () {\n-    return rest_of_handle_thread_prologue_and_epilogue ();\n-  }\n+  virtual unsigned int execute (function *)\n+    {\n+      return rest_of_handle_thread_prologue_and_epilogue ();\n+    }\n \n }; // class pass_thread_prologue_and_epilogue\n \n@@ -7184,8 +7191,36 @@ match_asm_constraints_1 (rtx insn, rtx *p_sets, int noutputs)\n     df_insn_rescan (insn);\n }\n \n-static unsigned\n-rest_of_match_asm_constraints (void)\n+namespace {\n+\n+const pass_data pass_data_match_asm_constraints =\n+{\n+  RTL_PASS, /* type */\n+  \"asmcons\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_match_asm_constraints : public rtl_opt_pass\n+{\n+public:\n+  pass_match_asm_constraints (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_match_asm_constraints, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_match_asm_constraints\n+\n+unsigned\n+pass_match_asm_constraints::execute (function *fun)\n {\n   basic_block bb;\n   rtx insn, pat, *p_sets;\n@@ -7195,7 +7230,7 @@ rest_of_match_asm_constraints (void)\n     return 0;\n \n   df_set_flags (DF_DEFER_INSN_RESCAN);\n-  FOR_EACH_BB_FN (bb, cfun)\n+  FOR_EACH_BB_FN (bb, fun)\n     {\n       FOR_BB_INSNS (bb, insn)\n \t{\n@@ -7219,34 +7254,6 @@ rest_of_match_asm_constraints (void)\n   return TODO_df_finish;\n }\n \n-namespace {\n-\n-const pass_data pass_data_match_asm_constraints =\n-{\n-  RTL_PASS, /* type */\n-  \"asmcons\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  true, /* has_execute */\n-  TV_NONE, /* tv_id */\n-  0, /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  0, /* todo_flags_finish */\n-};\n-\n-class pass_match_asm_constraints : public rtl_opt_pass\n-{\n-public:\n-  pass_match_asm_constraints (gcc::context *ctxt)\n-    : rtl_opt_pass (pass_data_match_asm_constraints, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  unsigned int execute () { return rest_of_match_asm_constraints (); }\n-\n-}; // class pass_match_asm_constraints\n-\n } // anon namespace\n \n rtl_opt_pass *"}, {"sha": "6960d62e250c5f9bff2aac35b7bb3a506f792652", "filename": "gcc/fwprop.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -1509,7 +1509,7 @@ class pass_rtl_fwprop : public rtl_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *) { return gate_fwprop (); }\n-  unsigned int execute () { return fwprop (); }\n+  virtual unsigned int execute (function *) { return fwprop (); }\n \n }; // class pass_rtl_fwprop\n \n@@ -1574,7 +1574,7 @@ class pass_rtl_fwprop_addr : public rtl_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *) { return gate_fwprop (); }\n-  unsigned int execute () { return fwprop_addr (); }\n+  virtual unsigned int execute (function *) { return fwprop_addr (); }\n \n }; // class pass_rtl_fwprop_addr\n "}, {"sha": "d88b2750d52b904a1991796a4bddc88e0878ff85", "filename": "gcc/gcse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -4209,7 +4209,7 @@ class pass_rtl_pre : public rtl_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *);\n-  unsigned int execute () { return execute_rtl_pre (); }\n+  virtual unsigned int execute (function *) { return execute_rtl_pre (); }\n \n }; // class pass_rtl_pre\n \n@@ -4261,7 +4261,7 @@ class pass_rtl_hoist : public rtl_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *);\n-  unsigned int execute () { return execute_rtl_hoist (); }\n+  virtual unsigned int execute (function *) { return execute_rtl_hoist (); }\n \n }; // class pass_rtl_hoist\n "}, {"sha": "eff4b4f84ba9f92f97a77a6cdd5e0372cccfcd05", "filename": "gcc/gimple-low.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -180,7 +180,7 @@ class pass_lower_cf : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  unsigned int execute () { return lower_function_body (); }\n+  virtual unsigned int execute (function *) { return lower_function_body (); }\n \n }; // class pass_lower_cf\n "}, {"sha": "b01417d09e593b19369254e36228064491619b3f", "filename": "gcc/gimple-ssa-isolate-paths.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fgimple-ssa-isolate-paths.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fgimple-ssa-isolate-paths.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-isolate-paths.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -446,7 +446,10 @@ class pass_isolate_erroneous_paths : public gimple_opt_pass\n \t      || flag_isolate_erroneous_paths_attribute != 0);\n     }\n \n-  unsigned int execute () { return gimple_ssa_isolate_erroneous_paths (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      return gimple_ssa_isolate_erroneous_paths ();\n+    }\n \n }; // class pass_isolate_erroneous_paths\n }"}, {"sha": "ff55d0eff67f1ae716dc6eff975a54ba6800033d", "filename": "gcc/gimple-ssa-strength-reduction.c", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fgimple-ssa-strength-reduction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fgimple-ssa-strength-reduction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-strength-reduction.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -3594,8 +3594,37 @@ analyze_candidates_and_replace (void)\n     }\n }\n \n-static unsigned\n-execute_strength_reduction (void)\n+namespace {\n+\n+const pass_data pass_data_strength_reduction =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"slsr\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_execute */\n+  TV_GIMPLE_SLSR, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_ssa, /* todo_flags_finish */\n+};\n+\n+class pass_strength_reduction : public gimple_opt_pass\n+{\n+public:\n+  pass_strength_reduction (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_strength_reduction, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *) { return flag_tree_slsr; }\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_strength_reduction\n+\n+unsigned\n+pass_strength_reduction::execute (function *fun)\n {\n   /* Create the obstack where candidates will reside.  */\n   gcc_obstack_init (&cand_obstack);\n@@ -3622,7 +3651,7 @@ execute_strength_reduction (void)\n   /* Walk the CFG in predominator order looking for strength reduction\n      candidates.  */\n   find_candidates_dom_walker (CDI_DOMINATORS)\n-    .walk (cfun->cfg->x_entry_block_ptr);\n+    .walk (fun->cfg->x_entry_block_ptr);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -3646,35 +3675,6 @@ execute_strength_reduction (void)\n   return 0;\n }\n \n-namespace {\n-\n-const pass_data pass_data_strength_reduction =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"slsr\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  true, /* has_execute */\n-  TV_GIMPLE_SLSR, /* tv_id */\n-  ( PROP_cfg | PROP_ssa ), /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  TODO_verify_ssa, /* todo_flags_finish */\n-};\n-\n-class pass_strength_reduction : public gimple_opt_pass\n-{\n-public:\n-  pass_strength_reduction (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_strength_reduction, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  virtual bool gate (function *) { return flag_tree_slsr; }\n-  unsigned int execute () { return execute_strength_reduction (); }\n-\n-}; // class pass_strength_reduction\n-\n } // anon namespace\n \n gimple_opt_pass *"}, {"sha": "2e1f439ef9e19dfa6b11aa9bc140889c8fbd297c", "filename": "gcc/graphite.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fgraphite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fgraphite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -411,7 +411,7 @@ class pass_graphite_transforms : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *) { return gate_graphite_transforms (); }\n-  unsigned int execute () { return graphite_transforms (); }\n+  virtual unsigned int execute (function *) { return graphite_transforms (); }\n \n }; // class pass_graphite_transforms\n "}, {"sha": "e8a9fec9d66c05dfadccd90ad6af4661ba9d9dcf", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -4560,7 +4560,10 @@ class pass_rtl_ifcvt : public rtl_opt_pass\n       return (optimize > 0) && dbg_cnt (if_conversion);\n     }\n \n-  unsigned int execute () { return rest_of_handle_if_conversion (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      return rest_of_handle_if_conversion ();\n+    }\n \n }; // class pass_rtl_ifcvt\n \n@@ -4575,12 +4578,6 @@ make_pass_rtl_ifcvt (gcc::context *ctxt)\n \n /* Rerun if-conversion, as combine may have simplified things enough\n    to now meet sequence length restrictions.  */\n-static unsigned int\n-rest_of_handle_if_after_combine (void)\n-{\n-  if_convert (true);\n-  return 0;\n-}\n \n namespace {\n \n@@ -4612,7 +4609,11 @@ class pass_if_after_combine : public rtl_opt_pass\n \t&& dbg_cnt (if_after_combine);\n     }\n \n-  unsigned int execute () { return rest_of_handle_if_after_combine (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      if_convert (true);\n+      return 0;\n+    }\n \n }; // class pass_if_after_combine\n \n@@ -4625,14 +4626,6 @@ make_pass_if_after_combine (gcc::context *ctxt)\n }\n \n \n-static unsigned int\n-rest_of_handle_if_after_reload (void)\n-{\n-  if_convert (true);\n-  return 0;\n-}\n-\n-\n namespace {\n \n const pass_data pass_data_if_after_reload =\n@@ -4663,7 +4656,11 @@ class pass_if_after_reload : public rtl_opt_pass\n \t&& dbg_cnt (if_after_reload);\n     }\n \n-  unsigned int execute () { return rest_of_handle_if_after_reload (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      if_convert (true);\n+      return 0;\n+    }\n \n }; // class pass_if_after_reload\n "}, {"sha": "59c5bc91004a42b16c968dcda3b74094afdda874", "filename": "gcc/init-regs.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Finit-regs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Finit-regs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finit-regs.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -125,13 +125,6 @@ initialize_uninitialized_regs (void)\n   BITMAP_FREE (already_genned);\n }\n \n-static unsigned int\n-rest_of_handle_initialize_regs (void)\n-{\n-  initialize_uninitialized_regs ();\n-  return 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_initialize_regs =\n@@ -157,7 +150,11 @@ class pass_initialize_regs : public rtl_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *) { return optimize > 0; }\n-  unsigned int execute () { return rest_of_handle_initialize_regs (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      initialize_uninitialized_regs ();\n+      return 0;\n+    }\n \n }; // class pass_initialize_regs\n "}, {"sha": "479963cdb6baebf237e502a3b051d68b55b0c559", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -3804,7 +3804,7 @@ class pass_ipa_cp : public ipa_opt_pass_d\n       return flag_ipa_cp && optimize;\n     }\n \n-  unsigned int execute () { return ipcp_driver (); }\n+  virtual unsigned int execute (function *) { return ipcp_driver (); }\n \n }; // class pass_ipa_cp\n "}, {"sha": "d484b20e48acd1bd37bea5bb83b63a4d6aa4a98b", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -2136,7 +2136,7 @@ class pass_ipa_devirt : public ipa_opt_pass_d\n \t      && optimize);\n     }\n \n-  unsigned int execute () { return ipa_devirt (); }\n+  virtual unsigned int execute (function *) { return ipa_devirt (); }\n \n }; // class pass_ipa_devirt\n "}, {"sha": "c471e0cd899dfb917b0a4f9102802a6b2464a126", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -2938,9 +2938,10 @@ class pass_inline_parameters : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   opt_pass * clone () { return new pass_inline_parameters (m_ctxt); }\n-  unsigned int execute () {\n-    return compute_inline_parameters_for_current ();\n-  }\n+  virtual unsigned int execute (function *)\n+    {\n+      return compute_inline_parameters_for_current ();\n+    }\n \n }; // class pass_inline_parameters\n "}, {"sha": "83a836a12116c40becfda3a48f2c461bb94dd564", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 33, "deletions": 32, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -2231,8 +2231,37 @@ early_inline_small_functions (struct cgraph_node *node)\n /* Do inlining of small functions.  Doing so early helps profiling and other\n    passes to be somewhat more effective and avoids some code duplication in\n    later real inlining pass for testcases with very many function calls.  */\n-static unsigned int\n-early_inliner (void)\n+\n+namespace {\n+\n+const pass_data pass_data_early_inline =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"einline\", /* name */\n+  OPTGROUP_INLINE, /* optinfo_flags */\n+  true, /* has_execute */\n+  TV_EARLY_INLINING, /* tv_id */\n+  PROP_ssa, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_early_inline : public gimple_opt_pass\n+{\n+public:\n+  pass_early_inline (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_early_inline, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_early_inline\n+\n+unsigned int\n+pass_early_inline::execute (function *fun)\n {\n   struct cgraph_node *node = cgraph_get_node (current_function_decl);\n   struct cgraph_edge *edge;\n@@ -2328,39 +2357,11 @@ early_inliner (void)\n       timevar_pop (TV_INTEGRATION);\n     }\n \n-  cfun->always_inline_functions_inlined = true;\n+  fun->always_inline_functions_inlined = true;\n \n   return todo;\n }\n \n-namespace {\n-\n-const pass_data pass_data_early_inline =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"einline\", /* name */\n-  OPTGROUP_INLINE, /* optinfo_flags */\n-  true, /* has_execute */\n-  TV_EARLY_INLINING, /* tv_id */\n-  PROP_ssa, /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  0, /* todo_flags_finish */\n-};\n-\n-class pass_early_inline : public gimple_opt_pass\n-{\n-public:\n-  pass_early_inline (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_early_inline, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  unsigned int execute () { return early_inliner (); }\n-\n-}; // class pass_early_inline\n-\n } // anon namespace\n \n gimple_opt_pass *\n@@ -2402,7 +2403,7 @@ class pass_ipa_inline : public ipa_opt_pass_d\n   {}\n \n   /* opt_pass methods: */\n-  unsigned int execute () { return ipa_inline (); }\n+  virtual unsigned int execute (function *) { return ipa_inline (); }\n \n }; // class pass_ipa_inline\n "}, {"sha": "71bd61b121209d596465b46572b26b4ae912d74e", "filename": "gcc/ipa-profile.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fipa-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fipa-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-profile.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -745,7 +745,7 @@ class pass_ipa_profile : public ipa_opt_pass_d\n \n   /* opt_pass methods: */\n   virtual bool gate (function *) { return flag_ipa_profile; }\n-  unsigned int execute () { return ipa_profile (); }\n+  virtual unsigned int execute (function *) { return ipa_profile (); }\n \n }; // class pass_ipa_profile\n "}, {"sha": "0ebfe5d5994a5b0ff631eb21fcb95eae03b883fb", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 45, "deletions": 48, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -1542,7 +1542,7 @@ class pass_ipa_pure_const : public ipa_opt_pass_d\n \n   /* opt_pass methods: */\n   virtual bool gate (function *) { return gate_pure_const (); }\n-  unsigned int execute () { return propagate (); }\n+  virtual unsigned int execute (function *) { return propagate (); }\n \n }; // class pass_ipa_pure_const\n \n@@ -1581,8 +1581,38 @@ skip_function_for_local_pure_const (struct cgraph_node *node)\n    ipa_pure_const.   This pass is effective when executed together with\n    other optimization passes in early optimization pass queue.  */\n \n-static unsigned int\n-local_pure_const (void)\n+namespace {\n+\n+const pass_data pass_data_local_pure_const =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"local-pure-const\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_execute */\n+  TV_IPA_PURE_CONST, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_local_pure_const : public gimple_opt_pass\n+{\n+public:\n+  pass_local_pure_const (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_local_pure_const, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_local_pure_const (m_ctxt); }\n+  virtual bool gate (function *) { return gate_pure_const (); }\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_local_pure_const\n+\n+unsigned int\n+pass_local_pure_const::execute (function *fun)\n {\n   bool changed = false;\n   funct_state l;\n@@ -1600,17 +1630,17 @@ local_pure_const (void)\n \n   /* Do NORETURN discovery.  */\n   if (!skip && !TREE_THIS_VOLATILE (current_function_decl)\n-      && EDGE_COUNT (EXIT_BLOCK_PTR_FOR_FN (cfun)->preds) == 0)\n+      && EDGE_COUNT (EXIT_BLOCK_PTR_FOR_FN (fun)->preds) == 0)\n     {\n-      warn_function_noreturn (cfun->decl);\n+      warn_function_noreturn (fun->decl);\n       if (dump_file)\n-        fprintf (dump_file, \"Function found to be noreturn: %s\\n\",\n-\t         current_function_name ());\n+\tfprintf (dump_file, \"Function found to be noreturn: %s\\n\",\n+\t\t current_function_name ());\n \n       /* Update declaration and reduce profile to executed once.  */\n       TREE_THIS_VOLATILE (current_function_decl) = 1;\n       if (node->frequency > NODE_FREQUENCY_EXECUTED_ONCE)\n-        node->frequency = NODE_FREQUENCY_EXECUTED_ONCE;\n+\tnode->frequency = NODE_FREQUENCY_EXECUTED_ONCE;\n \n       changed = true;\n     }\n@@ -1691,36 +1721,6 @@ local_pure_const (void)\n     return 0;\n }\n \n-namespace {\n-\n-const pass_data pass_data_local_pure_const =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"local-pure-const\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  true, /* has_execute */\n-  TV_IPA_PURE_CONST, /* tv_id */\n-  0, /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  0, /* todo_flags_finish */\n-};\n-\n-class pass_local_pure_const : public gimple_opt_pass\n-{\n-public:\n-  pass_local_pure_const (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_local_pure_const, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  opt_pass * clone () { return new pass_local_pure_const (m_ctxt); }\n-  virtual bool gate (function *) { return gate_pure_const (); }\n-  unsigned int execute () { return local_pure_const (); }\n-\n-}; // class pass_local_pure_const\n-\n } // anon namespace\n \n gimple_opt_pass *\n@@ -1731,15 +1731,6 @@ make_pass_local_pure_const (gcc::context *ctxt)\n \n /* Emit noreturn warnings.  */\n \n-static unsigned int\n-execute_warn_function_noreturn (void)\n-{\n-  if (!TREE_THIS_VOLATILE (current_function_decl)\n-      && EDGE_COUNT (EXIT_BLOCK_PTR_FOR_FN (cfun)->preds) == 0)\n-    warn_function_noreturn (current_function_decl);\n-  return 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_warn_function_noreturn =\n@@ -1765,7 +1756,13 @@ class pass_warn_function_noreturn : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *) { return warn_suggest_attribute_noreturn; }\n-  unsigned int execute () { return execute_warn_function_noreturn (); }\n+  virtual unsigned int execute (function *fun)\n+    {\n+      if (!TREE_THIS_VOLATILE (current_function_decl)\n+\t  && EDGE_COUNT (EXIT_BLOCK_PTR_FOR_FN (fun)->preds) == 0)\n+\twarn_function_noreturn (current_function_decl);\n+      return 0;\n+    }\n \n }; // class pass_warn_function_noreturn\n "}, {"sha": "dc1169da66db0586f3f569613418a90f0045eee8", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -1190,7 +1190,7 @@ class pass_ipa_reference : public ipa_opt_pass_d\n \t      && !seen_error ());\n     }\n \n-  unsigned int execute () { return propagate (); }\n+  virtual unsigned int execute (function *) { return propagate (); }\n \n }; // class pass_ipa_reference\n "}, {"sha": "eefa1954e302a1192878e662e37cd84d5b675e1f", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -1671,7 +1671,10 @@ class pass_split_functions : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *);\n-  unsigned int execute () { return execute_split_functions (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      return execute_split_functions ();\n+    }\n \n }; // class pass_split_functions\n \n@@ -1728,7 +1731,10 @@ class pass_feedback_split_functions : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *);\n-  unsigned int execute () { return execute_feedback_split_functions (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      return execute_feedback_split_functions ();\n+    }\n \n }; // class pass_feedback_split_functions\n "}, {"sha": "8b65abdb3496be25ec616a4f0be9c57a715d48f4", "filename": "gcc/ipa.c", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -1193,12 +1193,6 @@ function_and_variable_visibility (bool whole_program)\n /* Local function pass handling visibilities.  This happens before LTO streaming\n    so in particular -fwhole-program should be ignored at this level.  */\n \n-static unsigned int\n-local_function_and_variable_visibility (void)\n-{\n-  return function_and_variable_visibility (flag_whole_program && !flag_lto);\n-}\n-\n namespace {\n \n const pass_data pass_data_ipa_function_and_variable_visibility =\n@@ -1224,9 +1218,10 @@ class pass_ipa_function_and_variable_visibility : public simple_ipa_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  unsigned int execute () {\n-    return local_function_and_variable_visibility ();\n-  }\n+  virtual unsigned int execute (function *)\n+    {\n+      return function_and_variable_visibility (flag_whole_program && !flag_lto);\n+    }\n \n }; // class pass_ipa_function_and_variable_visibility\n \n@@ -1240,13 +1235,6 @@ make_pass_ipa_function_and_variable_visibility (gcc::context *ctxt)\n \n /* Free inline summary.  */\n \n-static unsigned\n-free_inline_summary (void)\n-{\n-  inline_free_summary ();\n-  return 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_ipa_free_inline_summary =\n@@ -1271,7 +1259,11 @@ class pass_ipa_free_inline_summary : public simple_ipa_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  unsigned int execute () { return free_inline_summary (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      inline_free_summary ();\n+      return 0;\n+    }\n \n }; // class pass_ipa_free_inline_summary\n \n@@ -1333,9 +1325,10 @@ class pass_ipa_whole_program_visibility : public ipa_opt_pass_d\n       /* Do not re-run on ltrans stage.  */\n       return !flag_ltrans;\n     }\n-  unsigned int execute () {\n-    return whole_program_function_and_variable_visibility ();\n-  }\n+  virtual unsigned int execute (function *)\n+    {\n+      return whole_program_function_and_variable_visibility ();\n+    }\n \n }; // class pass_ipa_whole_program_visibility\n \n@@ -1653,7 +1646,7 @@ class pass_ipa_cdtor_merge : public ipa_opt_pass_d\n \n   /* opt_pass methods: */\n   virtual bool gate (function *);\n-  unsigned int execute () { return ipa_cdtor_merge (); }\n+  virtual unsigned int execute (function *) { return ipa_cdtor_merge (); }\n \n }; // class pass_ipa_cdtor_merge\n "}, {"sha": "d9730011c0366e49eef8014d5866ee84865225b0", "filename": "gcc/ira.c", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -5548,12 +5548,6 @@ do_reload (void)\n }\n \f\n /* Run the integrated register allocator.  */\n-static unsigned int\n-rest_of_handle_ira (void)\n-{\n-  ira (dump_file);\n-  return 0;\n-}\n \n namespace {\n \n@@ -5579,7 +5573,11 @@ class pass_ira : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  unsigned int execute () { return rest_of_handle_ira (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      ira (dump_file);\n+      return 0;\n+    }\n \n }; // class pass_ira\n \n@@ -5591,13 +5589,6 @@ make_pass_ira (gcc::context *ctxt)\n   return new pass_ira (ctxt);\n }\n \n-static unsigned int\n-rest_of_handle_reload (void)\n-{\n-  do_reload ();\n-  return 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_reload =\n@@ -5622,7 +5613,11 @@ class pass_reload : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  unsigned int execute () { return rest_of_handle_reload (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      do_reload ();\n+      return 0;\n+    }\n \n }; // class pass_reload\n "}, {"sha": "cdea8d5b885f98b788c0a518279bb09f640a0bc0", "filename": "gcc/jump.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -163,7 +163,7 @@ class pass_cleanup_barriers : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  unsigned int execute () { return cleanup_barriers (); }\n+  virtual unsigned int execute (function *) { return cleanup_barriers (); }\n \n }; // class pass_cleanup_barriers\n "}, {"sha": "90453f67ecaf37a3c94bffe9ffc553bcb566ce60", "filename": "gcc/loop-init.c", "status": "modified", "additions": 65, "deletions": 70, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Floop-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Floop-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-init.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -390,7 +390,7 @@ class pass_rtl_loop_init : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  unsigned int execute () { return rtl_loop_init (); }\n+  virtual unsigned int execute (function *) { return rtl_loop_init (); }\n \n }; // class pass_rtl_loop_init\n \n@@ -405,24 +405,6 @@ make_pass_rtl_loop_init (gcc::context *ctxt)\n \f\n /* Finalization of the RTL loop passes.  */\n \n-static unsigned int\n-rtl_loop_done (void)\n-{\n-  /* No longer preserve loops, remove them now.  */\n-  cfun->curr_properties &= ~PROP_loops;\n-  loop_optimizer_finalize ();\n-  free_dominance_info (CDI_DOMINATORS);\n-\n-  cleanup_cfg (0);\n-  if (dump_file)\n-    {\n-      dump_reg_info (dump_file);\n-      dump_flow_info (dump_file, dump_flags);\n-    }\n-\n-  return 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_rtl_loop_done =\n@@ -447,10 +429,28 @@ class pass_rtl_loop_done : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  unsigned int execute () { return rtl_loop_done (); }\n+  virtual unsigned int execute (function *);\n \n }; // class pass_rtl_loop_done\n \n+unsigned int\n+pass_rtl_loop_done::execute (function *fun)\n+{\n+  /* No longer preserve loops, remove them now.  */\n+  fun->curr_properties &= ~PROP_loops;\n+  loop_optimizer_finalize ();\n+  free_dominance_info (CDI_DOMINATORS);\n+\n+  cleanup_cfg (0);\n+  if (dump_file)\n+    {\n+      dump_reg_info (dump_file);\n+      dump_flow_info (dump_file, dump_flags);\n+    }\n+\n+  return 0;\n+}\n+\n } // anon namespace\n \n rtl_opt_pass *\n@@ -461,13 +461,6 @@ make_pass_rtl_loop_done (gcc::context *ctxt)\n \n \f\n /* Loop invariant code motion.  */\n-static unsigned int\n-rtl_move_loop_invariants (void)\n-{\n-  if (number_of_loops (cfun) > 1)\n-    move_loop_invariants ();\n-  return 0;\n-}\n \n namespace {\n \n@@ -495,7 +488,12 @@ class pass_rtl_move_loop_invariants : public rtl_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *) { return flag_move_loop_invariants; }\n-  unsigned int execute () { return rtl_move_loop_invariants (); }\n+  virtual unsigned int execute (function *fun)\n+    {\n+      if (number_of_loops (fun) > 1)\n+\tmove_loop_invariants ();\n+      return 0;\n+    }\n \n }; // class pass_rtl_move_loop_invariants\n \n@@ -508,14 +506,6 @@ make_pass_rtl_move_loop_invariants (gcc::context *ctxt)\n }\n \n \f\n-static unsigned int\n-rtl_unswitch (void)\n-{\n-  if (number_of_loops (cfun) > 1)\n-    unswitch_loops ();\n-  return 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_rtl_unswitch =\n@@ -541,7 +531,12 @@ class pass_rtl_unswitch : public rtl_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *) { return flag_unswitch_loops; }\n-  unsigned int execute () { return rtl_unswitch (); }\n+  virtual unsigned int execute (function *fun)\n+    {\n+      if (number_of_loops (fun) > 1)\n+\tunswitch_loops ();\n+      return 0;\n+    }\n \n }; // class pass_rtl_unswitch\n \n@@ -554,27 +549,6 @@ make_pass_rtl_unswitch (gcc::context *ctxt)\n }\n \n \f\n-static unsigned int\n-rtl_unroll_and_peel_loops (void)\n-{\n-  if (number_of_loops (cfun) > 1)\n-    {\n-      int flags = 0;\n-      if (dump_file)\n-\tdf_dump (dump_file);\n-\n-      if (flag_peel_loops)\n-\tflags |= UAP_PEEL;\n-      if (flag_unroll_loops)\n-\tflags |= UAP_UNROLL;\n-      if (flag_unroll_all_loops)\n-\tflags |= UAP_UNROLL_ALL;\n-\n-      unroll_and_peel_loops (flags);\n-    }\n-  return 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_rtl_unroll_and_peel_loops =\n@@ -604,10 +578,31 @@ class pass_rtl_unroll_and_peel_loops : public rtl_opt_pass\n       return (flag_peel_loops || flag_unroll_loops || flag_unroll_all_loops);\n     }\n \n-  unsigned int execute () { return rtl_unroll_and_peel_loops (); }\n+  virtual unsigned int execute (function *);\n \n }; // class pass_rtl_unroll_and_peel_loops\n \n+unsigned int\n+pass_rtl_unroll_and_peel_loops::execute (function *fun)\n+{\n+  if (number_of_loops (fun) > 1)\n+    {\n+      int flags = 0;\n+      if (dump_file)\n+\tdf_dump (dump_file);\n+\n+      if (flag_peel_loops)\n+\tflags |= UAP_PEEL;\n+      if (flag_unroll_loops)\n+\tflags |= UAP_UNROLL;\n+      if (flag_unroll_all_loops)\n+\tflags |= UAP_UNROLL_ALL;\n+\n+      unroll_and_peel_loops (flags);\n+    }\n+  return 0;\n+}\n+\n } // anon namespace\n \n rtl_opt_pass *\n@@ -617,16 +612,6 @@ make_pass_rtl_unroll_and_peel_loops (gcc::context *ctxt)\n }\n \n \f\n-static unsigned int\n-rtl_doloop (void)\n-{\n-#ifdef HAVE_doloop_end\n-  if (number_of_loops (cfun) > 1)\n-    doloop_optimize_loops ();\n-#endif\n-  return 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_rtl_doloop =\n@@ -652,7 +637,7 @@ class pass_rtl_doloop : public rtl_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *);\n-  unsigned int execute () { return rtl_doloop (); }\n+  virtual unsigned int execute (function *);\n \n }; // class pass_rtl_doloop\n \n@@ -666,6 +651,16 @@ pass_rtl_doloop::gate (function *)\n #endif\n }\n \n+unsigned int\n+pass_rtl_doloop::execute (function *fun ATTRIBUTE_UNUSED)\n+{\n+#ifdef HAVE_doloop_end\n+  if (number_of_loops (fun) > 1)\n+    doloop_optimize_loops ();\n+#endif\n+  return 0;\n+}\n+\n } // anon namespace\n \n rtl_opt_pass *"}, {"sha": "bdad2a6aa9cbbc4b05e8bd7f4b82ecb78f4c9e93", "filename": "gcc/lower-subreg.c", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Flower-subreg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Flower-subreg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flower-subreg.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -1689,22 +1689,6 @@ decompose_multiword_subregs (bool decompose_copies)\n \f\n /* Implement first lower subreg pass.  */\n \n-static unsigned int\n-rest_of_handle_lower_subreg (void)\n-{\n-  decompose_multiword_subregs (false);\n-  return 0;\n-}\n-\n-/* Implement second lower subreg pass.  */\n-\n-static unsigned int\n-rest_of_handle_lower_subreg2 (void)\n-{\n-  decompose_multiword_subregs (true);\n-  return 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_lower_subreg =\n@@ -1730,7 +1714,11 @@ class pass_lower_subreg : public rtl_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *) { return flag_split_wide_types != 0; }\n-  unsigned int execute () { return rest_of_handle_lower_subreg (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      decompose_multiword_subregs (false);\n+      return 0;\n+    }\n \n }; // class pass_lower_subreg\n \n@@ -1742,6 +1730,8 @@ make_pass_lower_subreg (gcc::context *ctxt)\n   return new pass_lower_subreg (ctxt);\n }\n \n+/* Implement second lower subreg pass.  */\n+\n namespace {\n \n const pass_data pass_data_lower_subreg2 =\n@@ -1768,7 +1758,11 @@ class pass_lower_subreg2 : public rtl_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *) { return flag_split_wide_types != 0; }\n-  unsigned int execute () { return rest_of_handle_lower_subreg2 (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      decompose_multiword_subregs (true);\n+      return 0;\n+    }\n \n }; // class pass_lower_subreg2\n "}, {"sha": "b132cba4f2a619ad298665e481fb0bc5d6bd27c7", "filename": "gcc/mode-switching.c", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fmode-switching.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fmode-switching.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmode-switching.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -789,16 +789,6 @@ optimize_mode_switching (void)\n \n #endif /* OPTIMIZE_MODE_SWITCHING */\n \f\n-static unsigned int\n-rest_of_handle_mode_switching (void)\n-{\n-#ifdef OPTIMIZE_MODE_SWITCHING\n-  optimize_mode_switching ();\n-#endif /* OPTIMIZE_MODE_SWITCHING */\n-  return 0;\n-}\n-\n-\n namespace {\n \n const pass_data pass_data_mode_switching =\n@@ -835,7 +825,13 @@ class pass_mode_switching : public rtl_opt_pass\n #endif\n     }\n \n-  unsigned int execute () { return rest_of_handle_mode_switching (); }\n+  virtual unsigned int execute (function *)\n+    {\n+#ifdef OPTIMIZE_MODE_SWITCHING\n+      optimize_mode_switching ();\n+#endif /* OPTIMIZE_MODE_SWITCHING */\n+      return 0;\n+    }\n \n }; // class pass_mode_switching\n "}, {"sha": "2e454f553e7a0c3668050d198454ed4f18c892cc", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -3325,28 +3325,6 @@ rotate_partial_schedule (partial_schedule_ptr ps, int start_cycle)\n \f\n /* Run instruction scheduler.  */\n /* Perform SMS module scheduling.  */\n-static unsigned int\n-rest_of_handle_sms (void)\n-{\n-#ifdef INSN_SCHEDULING\n-  basic_block bb;\n-\n-  /* Collect loop information to be used in SMS.  */\n-  cfg_layout_initialize (0);\n-  sms_schedule ();\n-\n-  /* Update the life information, because we add pseudos.  */\n-  max_regno = max_reg_num ();\n-\n-  /* Finalize layout changes.  */\n-  FOR_EACH_BB_FN (bb, cfun)\n-    if (bb->next_bb != EXIT_BLOCK_PTR_FOR_FN (cfun))\n-      bb->aux = bb->next_bb;\n-  free_dominance_info (CDI_DOMINATORS);\n-  cfg_layout_finalize ();\n-#endif /* INSN_SCHEDULING */\n-  return 0;\n-}\n \n namespace {\n \n@@ -3378,10 +3356,33 @@ class pass_sms : public rtl_opt_pass\n   return (optimize > 0 && flag_modulo_sched);\n }\n \n-  unsigned int execute () { return rest_of_handle_sms (); }\n+  virtual unsigned int execute (function *);\n \n }; // class pass_sms\n \n+unsigned int\n+pass_sms::execute (function *fun ATTRIBUTE_UNUSED)\n+{\n+#ifdef INSN_SCHEDULING\n+  basic_block bb;\n+\n+  /* Collect loop information to be used in SMS.  */\n+  cfg_layout_initialize (0);\n+  sms_schedule ();\n+\n+  /* Update the life information, because we add pseudos.  */\n+  max_regno = max_reg_num ();\n+\n+  /* Finalize layout changes.  */\n+  FOR_EACH_BB_FN (bb, fun)\n+    if (bb->next_bb != EXIT_BLOCK_PTR_FOR_FN (fun))\n+      bb->aux = bb->next_bb;\n+  free_dominance_info (CDI_DOMINATORS);\n+  cfg_layout_finalize ();\n+#endif /* INSN_SCHEDULING */\n+  return 0;\n+}\n+\n } // anon namespace\n \n rtl_opt_pass *"}, {"sha": "0a46fb7fcfa5a0e6b7c319cb46d70410b5b0427e", "filename": "gcc/omp-low.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -8356,7 +8356,7 @@ class pass_expand_omp : public gimple_opt_pass\n \t       || flag_cilkplus != 0) && !seen_error ());\n     }\n \n-  unsigned int execute () { return execute_expand_omp (); }\n+  virtual unsigned int execute (function *) { return execute_expand_omp (); }\n \n }; // class pass_expand_omp\n \n@@ -10215,7 +10215,7 @@ class pass_lower_omp : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  unsigned int execute () { return execute_lower_omp (); }\n+  virtual unsigned int execute (function *) { return execute_lower_omp (); }\n \n }; // class pass_lower_omp\n \n@@ -10640,9 +10640,10 @@ class pass_diagnose_omp_blocks : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *) { return flag_openmp || flag_cilkplus; }\n-  unsigned int execute () {\n-    return diagnose_omp_structured_block_errors ();\n-  }\n+  virtual unsigned int execute (function *)\n+    {\n+      return diagnose_omp_structured_block_errors ();\n+    }\n \n }; // class pass_diagnose_omp_blocks\n \n@@ -11804,7 +11805,7 @@ class pass_omp_simd_clone : public simple_ipa_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *);\n-  unsigned int execute () { return ipa_omp_simd_clone (); }\n+  virtual unsigned int execute (function *) { return ipa_omp_simd_clone (); }\n };\n \n bool"}, {"sha": "2be7856f29b8dfd7f518d8f21ec6baadfb74af95", "filename": "gcc/passes.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -114,7 +114,7 @@ opt_pass::gate (function *)\n }\n \n unsigned int\n-opt_pass::execute ()\n+opt_pass::execute (function *)\n {\n   return 0;\n }\n@@ -138,7 +138,7 @@ pass_manager::execute_early_local_passes ()\n unsigned int\n pass_manager::execute_pass_mode_switching ()\n {\n-  return pass_mode_switching_1->execute ();\n+  return pass_mode_switching_1->execute (cfun);\n }\n \n \n@@ -367,7 +367,10 @@ class pass_early_local_passes : public simple_ipa_opt_pass\n       return (!seen_error () && !in_lto_p);\n     }\n \n-  unsigned int execute () { return execute_all_early_local_passes (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      return execute_all_early_local_passes ();\n+    }\n \n }; // class pass_early_local_passes\n \n@@ -2153,7 +2156,7 @@ execute_one_pass (opt_pass *pass)\n   /* Do it!  */\n   if (pass->has_execute)\n     {\n-      todo_after = pass->execute ();\n+      todo_after = pass->execute (cfun);\n       do_per_function (clear_last_verified, NULL);\n     }\n "}, {"sha": "f5d536335391e15b257bb191a4a0514a901a5bfe", "filename": "gcc/postreload-gcse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fpostreload-gcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fpostreload-gcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload-gcse.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -1347,7 +1347,7 @@ class pass_gcse2 : public rtl_opt_pass\n \t      && optimize_function_for_speed_p (fun));\n     }\n \n-  unsigned int execute () { return rest_of_handle_gcse2 (); }\n+  virtual unsigned int execute (function *) { return rest_of_handle_gcse2 (); }\n \n }; // class pass_gcse2\n "}, {"sha": "b093287d5a98dfe3689dc0e14f9fa367906f3d7b", "filename": "gcc/postreload.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -2315,23 +2315,6 @@ move2add_note_store (rtx dst, const_rtx set, void *data)\n     }\n }\n \f\n-static unsigned int\n-rest_of_handle_postreload (void)\n-{\n-  if (!dbg_cnt (postreload_cse))\n-    return 0;\n-\n-  /* Do a very simple CSE pass over just the hard registers.  */\n-  reload_cse_regs (get_insns ());\n-  /* Reload_cse_regs can eliminate potentially-trapping MEMs.\n-     Remove any EH edges associated with them.  */\n-  if (cfun->can_throw_non_call_exceptions\n-      && purge_all_dead_edges ())\n-    cleanup_cfg (0);\n-\n-  return 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_postreload_cse =\n@@ -2358,10 +2341,27 @@ class pass_postreload_cse : public rtl_opt_pass\n   /* opt_pass methods: */\n   virtual bool gate (function *) { return (optimize > 0 && reload_completed); }\n \n-  unsigned int execute () { return rest_of_handle_postreload (); }\n+  virtual unsigned int execute (function *);\n \n }; // class pass_postreload_cse\n \n+unsigned int\n+pass_postreload_cse::execute (function *fun)\n+{\n+  if (!dbg_cnt (postreload_cse))\n+    return 0;\n+\n+  /* Do a very simple CSE pass over just the hard registers.  */\n+  reload_cse_regs (get_insns ());\n+  /* Reload_cse_regs can eliminate potentially-trapping MEMs.\n+     Remove any EH edges associated with them.  */\n+  if (fun->can_throw_non_call_exceptions\n+      && purge_all_dead_edges ())\n+    cleanup_cfg (0);\n+\n+  return 0;\n+}\n+\n } // anon namespace\n \n rtl_opt_pass *"}, {"sha": "a847ec6f9d937b6182f79e5abcb63fc1ff8ac8a9", "filename": "gcc/predict.c", "status": "modified", "additions": 84, "deletions": 86, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -1986,59 +1986,6 @@ expr_expected_value (tree expr, bitmap visited,\n   return expr_expected_value_1 (TREE_TYPE (expr),\n \t\t\t\top0, code, op1, visited, predictor);\n }\n-\n-\f\n-/* Get rid of all builtin_expect calls and GIMPLE_PREDICT statements\n-   we no longer need.  */\n-static unsigned int\n-strip_predict_hints (void)\n-{\n-  basic_block bb;\n-  gimple ass_stmt;\n-  tree var;\n-\n-  FOR_EACH_BB_FN (bb, cfun)\n-    {\n-      gimple_stmt_iterator bi;\n-      for (bi = gsi_start_bb (bb); !gsi_end_p (bi);)\n-\t{\n-\t  gimple stmt = gsi_stmt (bi);\n-\n-\t  if (gimple_code (stmt) == GIMPLE_PREDICT)\n-\t    {\n-\t      gsi_remove (&bi, true);\n-\t      continue;\n-\t    }\n-\t  else if (is_gimple_call (stmt))\n-\t    {\n-\t      tree fndecl = gimple_call_fndecl (stmt);\n-\n-\t      if ((fndecl\n-\t\t   && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL\n-\t\t   && DECL_FUNCTION_CODE (fndecl) == BUILT_IN_EXPECT\n-\t\t   && gimple_call_num_args (stmt) == 2)\n-\t\t  || (gimple_call_internal_p (stmt)\n-\t\t      && gimple_call_internal_fn (stmt) == IFN_BUILTIN_EXPECT))\n-\t\t{\n-\t\t  var = gimple_call_lhs (stmt);\n-\t\t  if (var)\n-\t\t    {\n-\t\t      ass_stmt\n-\t\t\t= gimple_build_assign (var, gimple_call_arg (stmt, 0));\n-\t\t      gsi_replace (&bi, ass_stmt, true);\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      gsi_remove (&bi, true);\n-\t\t      continue;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t  gsi_next (&bi);\n-\t}\n-    }\n-  return 0;\n-}\n \f\n /* Predict using opcode of the last statement in basic block.  */\n static void\n@@ -2468,37 +2415,6 @@ tree_estimate_probability (void)\n   free_dominance_info (CDI_POST_DOMINATORS);\n   remove_fake_exit_edges ();\n }\n-\n-/* Predict branch probabilities and estimate profile of the tree CFG.\n-   This is the driver function for PASS_PROFILE.  */\n-\n-static unsigned int\n-tree_estimate_probability_driver (void)\n-{\n-  unsigned nb_loops;\n-\n-  loop_optimizer_init (LOOPS_NORMAL);\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    flow_loops_dump (dump_file, NULL, 0);\n-\n-  mark_irreducible_loops ();\n-\n-  nb_loops = number_of_loops (cfun);\n-  if (nb_loops > 1)\n-    scev_initialize ();\n-\n-  tree_estimate_probability ();\n-\n-  if (nb_loops > 1)\n-    scev_finalize ();\n-\n-  loop_optimizer_finalize ();\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    gimple_dump_cfg (dump_file, dump_flags);\n-  if (profile_status_for_fn (cfun) == PROFILE_ABSENT)\n-    profile_status_for_fn (cfun) = PROFILE_GUESSED;\n-  return 0;\n-}\n \f\n /* Predict edges to successors of CUR whose sources are not postdominated by\n    BB by PRED and recurse to all postdominators.  */\n@@ -3147,6 +3063,8 @@ predictor_name (enum br_predictor predictor)\n   return predictor_info[predictor].name;\n }\n \n+/* Predict branch probabilities and estimate profile of the tree CFG. */\n+\n namespace {\n \n const pass_data pass_data_profile =\n@@ -3172,10 +3090,38 @@ class pass_profile : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *) { return flag_guess_branch_prob; }\n-  unsigned int execute () { return tree_estimate_probability_driver (); }\n+  virtual unsigned int execute (function *);\n \n }; // class pass_profile\n \n+unsigned int\n+pass_profile::execute (function *fun)\n+{\n+  unsigned nb_loops;\n+\n+  loop_optimizer_init (LOOPS_NORMAL);\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    flow_loops_dump (dump_file, NULL, 0);\n+\n+  mark_irreducible_loops ();\n+\n+  nb_loops = number_of_loops (fun);\n+  if (nb_loops > 1)\n+    scev_initialize ();\n+\n+  tree_estimate_probability ();\n+\n+  if (nb_loops > 1)\n+    scev_finalize ();\n+\n+  loop_optimizer_finalize ();\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    gimple_dump_cfg (dump_file, dump_flags);\n+ if (profile_status_for_fn (fun) == PROFILE_ABSENT)\n+    profile_status_for_fn (fun) = PROFILE_GUESSED;\n+  return 0;\n+}\n+\n } // anon namespace\n \n gimple_opt_pass *\n@@ -3209,10 +3155,62 @@ class pass_strip_predict_hints : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   opt_pass * clone () { return new pass_strip_predict_hints (m_ctxt); }\n-  unsigned int execute () { return strip_predict_hints (); }\n+  virtual unsigned int execute (function *);\n \n }; // class pass_strip_predict_hints\n \n+/* Get rid of all builtin_expect calls and GIMPLE_PREDICT statements\n+   we no longer need.  */\n+unsigned int\n+pass_strip_predict_hints::execute (function *fun)\n+{\n+  basic_block bb;\n+  gimple ass_stmt;\n+  tree var;\n+\n+  FOR_EACH_BB_FN (bb, fun)\n+    {\n+      gimple_stmt_iterator bi;\n+      for (bi = gsi_start_bb (bb); !gsi_end_p (bi);)\n+\t{\n+\t  gimple stmt = gsi_stmt (bi);\n+\n+\t  if (gimple_code (stmt) == GIMPLE_PREDICT)\n+\t    {\n+\t      gsi_remove (&bi, true);\n+\t      continue;\n+\t    }\n+\t  else if (is_gimple_call (stmt))\n+\t    {\n+\t      tree fndecl = gimple_call_fndecl (stmt);\n+\n+\t      if ((fndecl\n+\t\t   && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL\n+\t\t   && DECL_FUNCTION_CODE (fndecl) == BUILT_IN_EXPECT\n+\t\t   && gimple_call_num_args (stmt) == 2)\n+\t\t  || (gimple_call_internal_p (stmt)\n+\t\t      && gimple_call_internal_fn (stmt) == IFN_BUILTIN_EXPECT))\n+\t\t{\n+\t\t  var = gimple_call_lhs (stmt);\n+\t\t  if (var)\n+\t\t    {\n+\t\t      ass_stmt\n+\t\t\t= gimple_build_assign (var, gimple_call_arg (stmt, 0));\n+\t\t      gsi_replace (&bi, ass_stmt, true);\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      gsi_remove (&bi, true);\n+\t\t      continue;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  gsi_next (&bi);\n+\t}\n+    }\n+  return 0;\n+}\n+\n } // anon namespace\n \n gimple_opt_pass *"}, {"sha": "057f41128a57533b9453b13b374b6fe8cca8e5c3", "filename": "gcc/recog.c", "status": "modified", "additions": 26, "deletions": 22, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -3847,7 +3847,10 @@ class pass_peephole2 : public rtl_opt_pass\n      a clone method.  */\n   opt_pass * clone () { return new pass_peephole2 (m_ctxt); }\n   virtual bool gate (function *) { return (optimize > 0 && flag_peephole2); }\n-  unsigned int execute () { return rest_of_handle_peephole2 (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      return rest_of_handle_peephole2 ();\n+    }\n \n }; // class pass_peephole2\n \n@@ -3859,13 +3862,6 @@ make_pass_peephole2 (gcc::context *ctxt)\n   return new pass_peephole2 (ctxt);\n }\n \n-static unsigned int\n-rest_of_handle_split_all_insns (void)\n-{\n-  split_all_insns ();\n-  return 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_split_all_insns =\n@@ -3893,7 +3889,11 @@ class pass_split_all_insns : public rtl_opt_pass\n   /* The epiphany backend creates a second instance of this pass, so\n      we need a clone method.  */\n   opt_pass * clone () { return new pass_split_all_insns (m_ctxt); }\n-  unsigned int execute () { return rest_of_handle_split_all_insns (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      split_all_insns ();\n+      return 0;\n+    }\n \n }; // class pass_split_all_insns\n \n@@ -3940,7 +3940,10 @@ class pass_split_after_reload : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  unsigned int execute () { return rest_of_handle_split_after_reload (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      return rest_of_handle_split_after_reload ();\n+    }\n \n }; // class pass_split_after_reload\n \n@@ -3952,13 +3955,6 @@ make_pass_split_after_reload (gcc::context *ctxt)\n   return new pass_split_after_reload (ctxt);\n }\n \n-static unsigned int\n-rest_of_handle_split_before_regstack (void)\n-{\n-  split_all_insns ();\n-  return 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_split_before_regstack =\n@@ -3984,9 +3980,11 @@ class pass_split_before_regstack : public rtl_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *);\n-  unsigned int execute () {\n-    return rest_of_handle_split_before_regstack ();\n-  }\n+  virtual unsigned int execute (function *)\n+    {\n+      split_all_insns ();\n+      return 0;\n+    }\n \n }; // class pass_split_before_regstack\n \n@@ -4058,7 +4056,10 @@ class pass_split_before_sched2 : public rtl_opt_pass\n #endif\n     }\n \n-  unsigned int execute () { return rest_of_handle_split_before_sched2 (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      return rest_of_handle_split_before_sched2 ();\n+    }\n \n }; // class pass_split_before_sched2\n \n@@ -4105,7 +4106,10 @@ class pass_split_for_shorten_branches : public rtl_opt_pass\n #endif\n     }\n \n-  unsigned int execute () { return split_all_insns_noflow (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      return split_all_insns_noflow ();\n+    }\n \n }; // class pass_split_for_shorten_branches\n "}, {"sha": "b4710333ba790b19eda9b12469548c2d8febf333", "filename": "gcc/ree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Free.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Free.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Free.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -1118,7 +1118,7 @@ class pass_ree : public rtl_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *) { return (optimize > 0 && flag_ree); }\n-  unsigned int execute () { return rest_of_handle_ree (); }\n+  virtual unsigned int execute (function *) { return rest_of_handle_ree (); }\n \n }; // class pass_ree\n "}, {"sha": "7aa8a6b800e9b9142c51df1c7b2db3174ee5d725", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -3364,7 +3364,10 @@ class pass_stack_regs_run : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  unsigned int execute () { return rest_of_handle_stack_regs (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      return rest_of_handle_stack_regs ();\n+    }\n \n }; // class pass_stack_regs_run\n "}, {"sha": "c1fbb65ca4f425f456c74fe610e323f1002ab105", "filename": "gcc/regcprop.c", "status": "modified", "additions": 86, "deletions": 88, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fregcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fregcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregcprop.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -1056,93 +1056,6 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n   return anything_changed;\n }\n \n-/* Main entry point for the forward copy propagation optimization.  */\n-\n-static unsigned int\n-copyprop_hardreg_forward (void)\n-{\n-  struct value_data *all_vd;\n-  basic_block bb;\n-  sbitmap visited;\n-  bool analyze_called = false;\n-\n-  all_vd = XNEWVEC (struct value_data, last_basic_block_for_fn (cfun));\n-\n-  visited = sbitmap_alloc (last_basic_block_for_fn (cfun));\n-  bitmap_clear (visited);\n-\n-  if (MAY_HAVE_DEBUG_INSNS)\n-    debug_insn_changes_pool\n-      = create_alloc_pool (\"debug insn changes pool\",\n-\t\t\t   sizeof (struct queued_debug_insn_change), 256);\n-\n-  FOR_EACH_BB_FN (bb, cfun)\n-    {\n-      bitmap_set_bit (visited, bb->index);\n-\n-      /* If a block has a single predecessor, that we've already\n-\t processed, begin with the value data that was live at\n-\t the end of the predecessor block.  */\n-      /* ??? Ought to use more intelligent queuing of blocks.  */\n-      if (single_pred_p (bb)\n-\t  && bitmap_bit_p (visited, single_pred (bb)->index)\n-\t  && ! (single_pred_edge (bb)->flags & (EDGE_ABNORMAL_CALL | EDGE_EH)))\n-\t{\n-\t  all_vd[bb->index] = all_vd[single_pred (bb)->index];\n-\t  if (all_vd[bb->index].n_debug_insn_changes)\n-\t    {\n-\t      unsigned int regno;\n-\n-\t      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-\t\t{\n-\t\t  if (all_vd[bb->index].e[regno].debug_insn_changes)\n-\t\t    {\n-\t\t      all_vd[bb->index].e[regno].debug_insn_changes = NULL;\n-\t\t      if (--all_vd[bb->index].n_debug_insn_changes == 0)\n-\t\t\tbreak;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n-      else\n-\tinit_value_data (all_vd + bb->index);\n-\n-      copyprop_hardreg_forward_1 (bb, all_vd + bb->index);\n-    }\n-\n-  if (MAY_HAVE_DEBUG_INSNS)\n-    {\n-      FOR_EACH_BB_FN (bb, cfun)\n-\tif (bitmap_bit_p (visited, bb->index)\n-\t    && all_vd[bb->index].n_debug_insn_changes)\n-\t  {\n-\t    unsigned int regno;\n-\t    bitmap live;\n-\n-\t    if (!analyze_called)\n-\t      {\n-\t\tdf_analyze ();\n-\t\tanalyze_called = true;\n-\t      }\n-\t    live = df_get_live_out (bb);\n-\t    for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-\t      if (all_vd[bb->index].e[regno].debug_insn_changes)\n-\t\t{\n-\t\t  if (REGNO_REG_SET_P (live, regno))\n-\t\t    apply_debug_insn_changes (all_vd + bb->index, regno);\n-\t\t  if (all_vd[bb->index].n_debug_insn_changes == 0)\n-\t\t    break;\n-\t\t}\n-\t  }\n-\n-      free_alloc_pool (debug_insn_changes_pool);\n-    }\n-\n-  sbitmap_free (visited);\n-  free (all_vd);\n-  return 0;\n-}\n-\n /* Dump the value chain data to stderr.  */\n \n DEBUG_FUNCTION void\n@@ -1276,10 +1189,95 @@ class pass_cprop_hardreg : public rtl_opt_pass\n       return (optimize > 0 && (flag_cprop_registers));\n     }\n \n-  unsigned int execute () { return copyprop_hardreg_forward (); }\n+  virtual unsigned int execute (function *);\n \n }; // class pass_cprop_hardreg\n \n+unsigned int\n+pass_cprop_hardreg::execute (function *fun)\n+{\n+  struct value_data *all_vd;\n+  basic_block bb;\n+  sbitmap visited;\n+  bool analyze_called = false;\n+\n+  all_vd = XNEWVEC (struct value_data, last_basic_block_for_fn (fun));\n+\n+  visited = sbitmap_alloc (last_basic_block_for_fn (fun));\n+  bitmap_clear (visited);\n+\n+  if (MAY_HAVE_DEBUG_INSNS)\n+    debug_insn_changes_pool\n+      = create_alloc_pool (\"debug insn changes pool\",\n+\t\t\t   sizeof (struct queued_debug_insn_change), 256);\n+\n+  FOR_EACH_BB_FN (bb, fun)\n+    {\n+      bitmap_set_bit (visited, bb->index);\n+\n+      /* If a block has a single predecessor, that we've already\n+\t processed, begin with the value data that was live at\n+\t the end of the predecessor block.  */\n+      /* ??? Ought to use more intelligent queuing of blocks.  */\n+      if (single_pred_p (bb)\n+\t  && bitmap_bit_p (visited, single_pred (bb)->index)\n+\t  && ! (single_pred_edge (bb)->flags & (EDGE_ABNORMAL_CALL | EDGE_EH)))\n+\t{\n+\t  all_vd[bb->index] = all_vd[single_pred (bb)->index];\n+\t  if (all_vd[bb->index].n_debug_insn_changes)\n+\t    {\n+\t      unsigned int regno;\n+\n+\t      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+\t\t{\n+\t\t  if (all_vd[bb->index].e[regno].debug_insn_changes)\n+\t\t    {\n+\t\t      all_vd[bb->index].e[regno].debug_insn_changes = NULL;\n+\t\t      if (--all_vd[bb->index].n_debug_insn_changes == 0)\n+\t\t\tbreak;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\tinit_value_data (all_vd + bb->index);\n+\n+      copyprop_hardreg_forward_1 (bb, all_vd + bb->index);\n+    }\n+\n+  if (MAY_HAVE_DEBUG_INSNS)\n+    {\n+      FOR_EACH_BB_FN (bb, fun)\n+\tif (bitmap_bit_p (visited, bb->index)\n+\t    && all_vd[bb->index].n_debug_insn_changes)\n+\t  {\n+\t    unsigned int regno;\n+\t    bitmap live;\n+\n+\t    if (!analyze_called)\n+\t      {\n+\t\tdf_analyze ();\n+\t\tanalyze_called = true;\n+\t      }\n+\t    live = df_get_live_out (bb);\n+\t    for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+\t      if (all_vd[bb->index].e[regno].debug_insn_changes)\n+\t\t{\n+\t\t  if (REGNO_REG_SET_P (live, regno))\n+\t\t    apply_debug_insn_changes (all_vd + bb->index, regno);\n+\t\t  if (all_vd[bb->index].n_debug_insn_changes == 0)\n+\t\t    break;\n+\t\t}\n+\t  }\n+\n+      free_alloc_pool (debug_insn_changes_pool);\n+    }\n+\n+  sbitmap_free (visited);\n+  free (all_vd);\n+  return 0;\n+}\n+\n } // anon namespace\n \n rtl_opt_pass *"}, {"sha": "42668a158eb7ae3815744a3a7710b36a18322b89", "filename": "gcc/reginfo.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Freginfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Freginfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freginfo.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -985,7 +985,7 @@ class pass_reginfo_init : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  unsigned int execute () { return reginfo_init (); }\n+  virtual unsigned int execute (function *) { return reginfo_init (); }\n \n }; // class pass_reginfo_init\n "}, {"sha": "68e8ad7301521685afe7b2d3e52b964d2a9a17af", "filename": "gcc/regrename.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -1865,7 +1865,7 @@ class pass_regrename : public rtl_opt_pass\n       return (optimize > 0 && (flag_rename_registers));\n     }\n \n-  unsigned int execute () { return regrename_optimize (); }\n+  virtual unsigned int execute (function *) { return regrename_optimize (); }\n \n }; // class pass_regrename\n "}, {"sha": "95e942f3eaf1eaea1ba6f9a88133b5c364714274", "filename": "gcc/reorg.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -3898,7 +3898,10 @@ class pass_delay_slots : public rtl_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *);\n-  unsigned int execute () { return rest_of_handle_delay_slots (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      return rest_of_handle_delay_slots ();\n+    }\n \n }; // class pass_delay_slots\n \n@@ -3923,13 +3926,6 @@ make_pass_delay_slots (gcc::context *ctxt)\n \n /* Machine dependent reorg pass.  */\n \n-static unsigned int\n-rest_of_handle_machine_reorg (void)\n-{\n-  targetm.machine_dependent_reorg ();\n-  return 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_machine_reorg =\n@@ -3959,7 +3955,11 @@ class pass_machine_reorg : public rtl_opt_pass\n       return targetm.machine_dependent_reorg != 0;\n     }\n \n-  unsigned int execute () { return rest_of_handle_machine_reorg (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      targetm.machine_dependent_reorg ();\n+      return 0;\n+    }\n \n }; // class pass_machine_reorg\n "}, {"sha": "ce3fe5df016337e9ce3596bce0a1d8d7e2ab806b", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -3677,7 +3677,10 @@ class pass_live_range_shrinkage : public rtl_opt_pass\n #endif\n     }\n \n-  unsigned int execute () { return rest_of_handle_live_range_shrinkage (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      return rest_of_handle_live_range_shrinkage ();\n+    }\n \n }; // class pass_live_range_shrinkage\n \n@@ -3715,7 +3718,7 @@ class pass_sched : public rtl_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *);\n-  unsigned int execute () { return rest_of_handle_sched (); }\n+  virtual unsigned int execute (function *) { return rest_of_handle_sched (); }\n \n }; // class pass_sched\n \n@@ -3763,7 +3766,10 @@ class pass_sched2 : public rtl_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *);\n-  unsigned int execute () { return rest_of_handle_sched2 (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      return rest_of_handle_sched2 ();\n+    }\n \n }; // class pass_sched2\n "}, {"sha": "75bec2fbdcdc043f0cc7c7d2fe1f3ded91db1492", "filename": "gcc/stack-ptr-mod.c", "status": "modified", "additions": 34, "deletions": 39, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fstack-ptr-mod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fstack-ptr-mod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstack-ptr-mod.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -48,48 +48,10 @@ notice_stack_pointer_modification_1 (rtx x, const_rtx pat ATTRIBUTE_UNUSED,\n     crtl->sp_is_unchanging = 0;\n }\n \n-static void\n-notice_stack_pointer_modification (void)\n-{\n-  basic_block bb;\n-  rtx insn;\n-\n-  /* Assume that the stack pointer is unchanging if alloca hasn't\n-     been used.  */\n-  crtl->sp_is_unchanging = !cfun->calls_alloca;\n-  if (crtl->sp_is_unchanging)\n-    FOR_EACH_BB_FN (bb, cfun)\n-      FOR_BB_INSNS (bb, insn)\n-        {\n-\t  if (INSN_P (insn))\n-\t    {\n-\t      /* Check if insn modifies the stack pointer.  */\n-\t      note_stores (PATTERN (insn),\n-\t\t\t   notice_stack_pointer_modification_1,\n-\t\t\t   NULL);\n-\t      if (! crtl->sp_is_unchanging)\n-\t\treturn;\n-\t    }\n-\t}\n-\n-  /* The value coming into this pass was 0, and the exit block uses\n-     are based on this.  If the value is now 1, we need to redo the\n-     exit block uses.  */\n-  if (df && crtl->sp_is_unchanging)\n-    df_update_exit_block_uses ();\n-}\n-\n   /* Some targets can emit simpler epilogues if they know that sp was\n      not ever modified during the function.  After reload, of course,\n      we've already emitted the epilogue so there's no sense searching.  */\n \n-static unsigned int\n-rest_of_handle_stack_ptr_mod (void)\n-{\n-  notice_stack_pointer_modification ();\n-  return 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_stack_ptr_mod =\n@@ -114,10 +76,43 @@ class pass_stack_ptr_mod : public rtl_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  unsigned int execute () { return rest_of_handle_stack_ptr_mod (); }\n+  virtual unsigned int execute (function *);\n \n }; // class pass_stack_ptr_mod\n \n+unsigned int\n+pass_stack_ptr_mod::execute (function *fun)\n+{\n+  basic_block bb;\n+  rtx insn;\n+\n+  /* Assume that the stack pointer is unchanging if alloca hasn't\n+     been used.  */\n+  crtl->sp_is_unchanging = !fun->calls_alloca;\n+  if (crtl->sp_is_unchanging)\n+    FOR_EACH_BB_FN (bb, fun)\n+      FOR_BB_INSNS (bb, insn)\n+        {\n+\t  if (INSN_P (insn))\n+\t    {\n+\t      /* Check if insn modifies the stack pointer.  */\n+\t      note_stores (PATTERN (insn),\n+\t\t\t   notice_stack_pointer_modification_1,\n+\t\t\t   NULL);\n+\t      if (! crtl->sp_is_unchanging)\n+\t\treturn 0;\n+\t    }\n+\t}\n+\n+  /* The value coming into this pass was 0, and the exit block uses\n+     are based on this.  If the value is now 1, we need to redo the\n+     exit block uses.  */\n+  if (df && crtl->sp_is_unchanging)\n+    df_update_exit_block_uses ();\n+\n+  return 0;\n+}\n+\n } // anon namespace\n \n rtl_opt_pass *"}, {"sha": "920da5312134db09ab019feab1513871d6f431cd", "filename": "gcc/store-motion.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fstore-motion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fstore-motion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstore-motion.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -1258,7 +1258,10 @@ class pass_rtl_store_motion : public rtl_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *);\n-  unsigned int execute () { return execute_rtl_store_motion (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      return execute_rtl_store_motion ();\n+    }\n \n }; // class pass_rtl_store_motion\n "}, {"sha": "35eae15ffe58bb486387d177e29618b85620304b", "filename": "gcc/testsuite/g++.dg/plugin/dumb_plugin.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fdumb_plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fdumb_plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fdumb_plugin.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -44,14 +44,6 @@ handle_end_of_compilation_unit (void *event_data, void *data)\n }\n \n \n-static unsigned int\n-execute_dumb_plugin_example (void)\n-{\n-  warning (0, G_(\"Analyze function %s\"),\n-           IDENTIFIER_POINTER (DECL_NAME (current_function_decl)));\n-  return 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_dumb_plugin_example =\n@@ -76,10 +68,18 @@ class pass_dumb_plugin_example : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  unsigned int execute () { return execute_dumb_plugin_example (); }\n+  virtual unsigned int execute (function *);\n \n }; // class pass_dumb_plugin_example\n \n+unsigned int\n+pass_dumb_plugin_example::execute (function *)\n+{\n+  warning (0, G_(\"Analyze function %s\"),\n+           IDENTIFIER_POINTER (DECL_NAME (current_function_decl)));\n+  return 0;\n+}\n+\n } // anon namespace\n \n static gimple_opt_pass *"}, {"sha": "59bb03ac2a795df4d2ab036e8f221c87d8440e34", "filename": "gcc/testsuite/g++.dg/plugin/selfassign.c", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fselfassign.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fselfassign.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fselfassign.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -253,23 +253,6 @@ warn_self_assign (gimple stmt)\n     }\n }\n \n-/* Entry point for the self-assignment detection pass.  */\n-\n-static unsigned int\n-execute_warn_self_assign (void)\n-{\n-  gimple_stmt_iterator gsi;\n-  basic_block bb;\n-\n-  FOR_EACH_BB_FN (bb, cfun)\n-    {\n-      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-        warn_self_assign (gsi_stmt (gsi));\n-    }\n-\n-  return 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_warn_self_assign =\n@@ -295,10 +278,25 @@ class pass_warn_self_assign : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   bool gate (function *) { return true; }\n-  unsigned int execute () { return execute_warn_self_assign (); }\n+  virtual unsigned int execute (function *);\n \n }; // class pass_warn_self_assign\n \n+unsigned int\n+pass_warn_self_assign::execute (function *fun)\n+{\n+  gimple_stmt_iterator gsi;\n+  basic_block bb;\n+\n+  FOR_EACH_BB_FN (bb, fun)\n+    {\n+      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+        warn_self_assign (gsi_stmt (gsi));\n+    }\n+\n+  return 0;\n+}\n+\n } // anon namespace\n \n static gimple_opt_pass *"}, {"sha": "d70f5584dc28725840fa1df12a3339bb42395642", "filename": "gcc/testsuite/gcc.dg/plugin/one_time_plugin.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fone_time_plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fone_time_plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fone_time_plugin.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -50,7 +50,7 @@ class one_pass : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *);\n-  unsigned int execute ();\n+  virtual unsigned int execute (function *);\n \n private:\n   int counter;\n@@ -63,7 +63,8 @@ bool one_pass::gate (function *)\n   return true;\n }\n \n-unsigned int one_pass::execute ()\n+unsigned int\n+one_pass::execute (function *)\n {\n   if (counter > 0) {\n     printf (\"Executed more than once \\n\");"}, {"sha": "4dad0c28817ab4899b51645bb447e2b9fdddf01f", "filename": "gcc/testsuite/gcc.dg/plugin/selfassign.c", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fselfassign.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fselfassign.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fselfassign.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -253,23 +253,6 @@ warn_self_assign (gimple stmt)\n     }\n }\n \n-/* Entry point for the self-assignment detection pass.  */\n-\n-static unsigned int\n-execute_warn_self_assign (void)\n-{\n-  gimple_stmt_iterator gsi;\n-  basic_block bb;\n-\n-  FOR_EACH_BB_FN (bb, cfun)\n-    {\n-      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-        warn_self_assign (gsi_stmt (gsi));\n-    }\n-\n-  return 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_warn_self_assign =\n@@ -294,10 +277,25 @@ class pass_warn_self_assign : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  unsigned int execute () { return execute_warn_self_assign (); }\n+  virtual unsigned int execute (function *);\n \n }; // class pass_warn_self_assign\n \n+unsigned int\n+pass_warn_self_assign::execute (function *fun)\n+{\n+  gimple_stmt_iterator gsi;\n+  basic_block bb;\n+\n+  FOR_EACH_BB_FN (bb, fun)\n+    {\n+      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+        warn_self_assign (gsi_stmt (gsi));\n+    }\n+\n+  return 0;\n+}\n+\n } // anon namespace\n \n static gimple_opt_pass *"}, {"sha": "09a8f40c7f53c7c2389062eaf01e7854a3358e99", "filename": "gcc/tracer.c", "status": "modified", "additions": 28, "deletions": 31, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftracer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftracer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftracer.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -367,36 +367,6 @@ tail_duplicate (void)\n \n   return changed;\n }\n-\n-/* Main entry point to this file.  */\n-\n-static unsigned int\n-tracer (void)\n-{\n-  bool changed;\n-\n-  if (n_basic_blocks_for_fn (cfun) <= NUM_FIXED_BLOCKS + 1)\n-    return 0;\n-\n-  mark_dfs_back_edges ();\n-  if (dump_file)\n-    brief_dump_cfg (dump_file, dump_flags);\n-\n-  /* Trace formation is done on the fly inside tail_duplicate */\n-  changed = tail_duplicate ();\n-  if (changed)\n-    {\n-      free_dominance_info (CDI_DOMINATORS);\n-      /* If we changed the CFG schedule loops for fixup by cleanup_cfg.  */\n-      if (current_loops)\n-\tloops_state_set (LOOPS_NEED_FIXUP);\n-    }\n-\n-  if (dump_file)\n-    brief_dump_cfg (dump_file, dump_flags);\n-\n-  return changed ? TODO_cleanup_cfg : 0;\n-}\n \f\n namespace {\n \n@@ -427,10 +397,37 @@ class pass_tracer : public gimple_opt_pass\n       return (optimize > 0 && flag_tracer && flag_reorder_blocks);\n     }\n \n-  unsigned int execute () { return tracer (); }\n+  virtual unsigned int execute (function *);\n \n }; // class pass_tracer\n \n+unsigned int\n+pass_tracer::execute (function *fun)\n+{\n+  bool changed;\n+\n+  if (n_basic_blocks_for_fn (fun) <= NUM_FIXED_BLOCKS + 1)\n+    return 0;\n+\n+  mark_dfs_back_edges ();\n+  if (dump_file)\n+    brief_dump_cfg (dump_file, dump_flags);\n+\n+  /* Trace formation is done on the fly inside tail_duplicate */\n+  changed = tail_duplicate ();\n+  if (changed)\n+    {\n+      free_dominance_info (CDI_DOMINATORS);\n+      /* If we changed the CFG schedule loops for fixup by cleanup_cfg.  */\n+      if (current_loops)\n+\tloops_state_set (LOOPS_NEED_FIXUP);\n+    }\n+\n+  if (dump_file)\n+    brief_dump_cfg (dump_file, dump_flags);\n+\n+  return changed ? TODO_cleanup_cfg : 0;\n+}\n } // anon namespace\n \n gimple_opt_pass *"}, {"sha": "417ca8a8fa27f21bd19fa3be9ba52b1a6500def5", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -856,7 +856,7 @@ class pass_diagnose_tm_blocks : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *) { return flag_tm; }\n-  unsigned int execute () { return diagnose_tm_blocks (); }\n+  virtual unsigned int execute (function *) { return diagnose_tm_blocks (); }\n \n }; // class pass_diagnose_tm_blocks\n \n@@ -1778,7 +1778,7 @@ class pass_lower_tm : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *) { return flag_tm; }\n-  unsigned int execute () { return execute_lower_tm (); }\n+  virtual unsigned int execute (function *) { return execute_lower_tm (); }\n \n }; // class pass_lower_tm\n \n@@ -3029,7 +3029,7 @@ class pass_tm_mark : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  unsigned int execute () { return execute_tm_mark (); }\n+  virtual unsigned int execute (function *) { return execute_tm_mark (); }\n \n }; // class pass_tm_mark\n \n@@ -3162,31 +3162,6 @@ expand_block_edges (struct tm_region *const region, basic_block bb)\n \n /* Entry point to the final expansion of transactional nodes. */\n \n-static unsigned int\n-execute_tm_edges (void)\n-{\n-  vec<tm_region_p> bb_regions\n-    = get_bb_regions_instrumented (/*traverse_clones=*/false,\n-\t\t\t\t   /*include_uninstrumented_p=*/true);\n-  struct tm_region *r;\n-  unsigned i;\n-\n-  FOR_EACH_VEC_ELT (bb_regions, i, r)\n-    if (r != NULL)\n-      expand_block_edges (r, BASIC_BLOCK_FOR_FN (cfun, i));\n-\n-  bb_regions.release ();\n-\n-  /* We've got to release the dominance info now, to indicate that it\n-     must be rebuilt completely.  Otherwise we'll crash trying to update\n-     the SSA web in the TODO section following this pass.  */\n-  free_dominance_info (CDI_DOMINATORS);\n-  bitmap_obstack_release (&tm_obstack);\n-  all_tm_regions = NULL;\n-\n-  return 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_tm_edges =\n@@ -3211,10 +3186,35 @@ class pass_tm_edges : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  unsigned int execute () { return execute_tm_edges (); }\n+  virtual unsigned int execute (function *);\n \n }; // class pass_tm_edges\n \n+unsigned int\n+pass_tm_edges::execute (function *fun)\n+{\n+  vec<tm_region_p> bb_regions\n+    = get_bb_regions_instrumented (/*traverse_clones=*/false,\n+\t\t\t\t   /*include_uninstrumented_p=*/true);\n+  struct tm_region *r;\n+  unsigned i;\n+\n+  FOR_EACH_VEC_ELT (bb_regions, i, r)\n+    if (r != NULL)\n+      expand_block_edges (r, BASIC_BLOCK_FOR_FN (fun, i));\n+\n+  bb_regions.release ();\n+\n+  /* We've got to release the dominance info now, to indicate that it\n+     must be rebuilt completely.  Otherwise we'll crash trying to update\n+     the SSA web in the TODO section following this pass.  */\n+  free_dominance_info (CDI_DOMINATORS);\n+  bitmap_obstack_release (&tm_obstack);\n+  all_tm_regions = NULL;\n+\n+  return 0;\n+}\n+\n } // anon namespace\n \n gimple_opt_pass *\n@@ -3946,7 +3946,7 @@ class pass_tm_memopt : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *) { return flag_tm && optimize > 0; }\n-  unsigned int execute () { return execute_tm_memopt (); }\n+  virtual unsigned int execute (function *) { return execute_tm_memopt (); }\n \n }; // class pass_tm_memopt\n \n@@ -5582,7 +5582,7 @@ class pass_ipa_tm : public simple_ipa_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *) { return flag_tm; }\n-  unsigned int execute () { return ipa_tm_execute (); }\n+  virtual unsigned int execute (function *) { return ipa_tm_execute (); }\n \n }; // class pass_ipa_tm\n "}, {"sha": "ea1df8b2210d986b1366e01d8c8e17d0fe5d0210", "filename": "gcc/tree-call-cdce.c", "status": "modified", "additions": 40, "deletions": 42, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-call-cdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-call-cdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-call-cdce.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -867,16 +867,51 @@ shrink_wrap_conditional_dead_built_in_calls (vec<gimple> calls)\n   return changed;\n }\n \n-/* Pass entry points.  */\n+namespace {\n+\n+const pass_data pass_data_call_cdce =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"cdce\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_execute */\n+  TV_TREE_CALL_CDCE, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_ssa, /* todo_flags_finish */\n+};\n+\n+class pass_call_cdce : public gimple_opt_pass\n+{\n+public:\n+  pass_call_cdce (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_call_cdce, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *fun)\n+    {\n+      /* The limit constants used in the implementation\n+\t assume IEEE floating point format.  Other formats\n+\t can be supported in the future if needed.  */\n+      return flag_tree_builtin_call_dce != 0\n+       \t&& optimize_function_for_speed_p (fun);\n+    }\n \n-static unsigned int\n-tree_call_cdce (void)\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_call_cdce\n+\n+unsigned int\n+pass_call_cdce::execute (function *fun)\n {\n   basic_block bb;\n   gimple_stmt_iterator i;\n   bool something_changed = false;\n   auto_vec<gimple> cond_dead_built_in_calls;\n-  FOR_EACH_BB_FN (bb, cfun)\n+  FOR_EACH_BB_FN (bb, fun)\n     {\n       /* Collect dead call candidates.  */\n       for (i = gsi_start_bb (bb); !gsi_end_p (i); gsi_next (&i))\n@@ -910,50 +945,13 @@ tree_call_cdce (void)\n       free_dominance_info (CDI_POST_DOMINATORS);\n       /* As we introduced new control-flow we need to insert PHI-nodes\n          for the call-clobbers of the remaining call.  */\n-      mark_virtual_operands_for_renaming (cfun);\n+      mark_virtual_operands_for_renaming (fun);\n       return TODO_update_ssa;\n     }\n \n   return 0;\n }\n \n-namespace {\n-\n-const pass_data pass_data_call_cdce =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"cdce\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  true, /* has_execute */\n-  TV_TREE_CALL_CDCE, /* tv_id */\n-  ( PROP_cfg | PROP_ssa ), /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  TODO_verify_ssa, /* todo_flags_finish */\n-};\n-\n-class pass_call_cdce : public gimple_opt_pass\n-{\n-public:\n-  pass_call_cdce (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_call_cdce, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  virtual bool gate (function *fun)\n-    {\n-      /* The limit constants used in the implementation\n-\t assume IEEE floating point format.  Other formats\n-\t can be supported in the future if needed.  */\n-      return flag_tree_builtin_call_dce != 0\n-       \t&& optimize_function_for_speed_p (fun);\n-    }\n-\n-  unsigned int execute () { return tree_call_cdce (); }\n-\n-}; // class pass_call_cdce\n-\n } // anon namespace\n \n gimple_opt_pass *"}, {"sha": "0fb2681c72368940ee3de5b156c48e12220ad9a9", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 66, "deletions": 70, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -368,7 +368,7 @@ class pass_build_cfg : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  unsigned int execute () { return execute_build_cfg (); }\n+  virtual unsigned int execute (function *) { return execute_build_cfg (); }\n \n }; // class pass_build_cfg\n \n@@ -8100,7 +8100,7 @@ class pass_split_crit_edges : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  unsigned int execute () { return split_critical_edges (); }\n+  virtual unsigned int execute (function *) { return split_critical_edges (); }\n \n   opt_pass * clone () { return new pass_split_crit_edges (m_ctxt); }\n }; // class pass_split_crit_edges\n@@ -8165,64 +8165,6 @@ gimplify_build1 (gimple_stmt_iterator *gsi, enum tree_code code, tree type,\n \n \n \f\n-/* Emit return warnings.  */\n-\n-static unsigned int\n-execute_warn_function_return (void)\n-{\n-  source_location location;\n-  gimple last;\n-  edge e;\n-  edge_iterator ei;\n-\n-  if (!targetm.warn_func_return (cfun->decl))\n-    return 0;\n-\n-  /* If we have a path to EXIT, then we do return.  */\n-  if (TREE_THIS_VOLATILE (cfun->decl)\n-      && EDGE_COUNT (EXIT_BLOCK_PTR_FOR_FN (cfun)->preds) > 0)\n-    {\n-      location = UNKNOWN_LOCATION;\n-      FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR_FOR_FN (cfun)->preds)\n-\t{\n-\t  last = last_stmt (e->src);\n-\t  if ((gimple_code (last) == GIMPLE_RETURN\n-\t       || gimple_call_builtin_p (last, BUILT_IN_RETURN))\n-\t      && (location = gimple_location (last)) != UNKNOWN_LOCATION)\n-\t    break;\n-\t}\n-      if (location == UNKNOWN_LOCATION)\n-\tlocation = cfun->function_end_locus;\n-      warning_at (location, 0, \"%<noreturn%> function does return\");\n-    }\n-\n-  /* If we see \"return;\" in some basic block, then we do reach the end\n-     without returning a value.  */\n-  else if (warn_return_type\n-\t   && !TREE_NO_WARNING (cfun->decl)\n-\t   && EDGE_COUNT (EXIT_BLOCK_PTR_FOR_FN (cfun)->preds) > 0\n-\t   && !VOID_TYPE_P (TREE_TYPE (TREE_TYPE (cfun->decl))))\n-    {\n-      FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR_FOR_FN (cfun)->preds)\n-\t{\n-\t  gimple last = last_stmt (e->src);\n-\t  if (gimple_code (last) == GIMPLE_RETURN\n-\t      && gimple_return_retval (last) == NULL\n-\t      && !gimple_no_warning_p (last))\n-\t    {\n-\t      location = gimple_location (last);\n-\t      if (location == UNKNOWN_LOCATION)\n-\t\t  location = cfun->function_end_locus;\n-\t      warning_at (location, OPT_Wreturn_type, \"control reaches end of non-void function\");\n-\t      TREE_NO_WARNING (cfun->decl) = 1;\n-\t      break;\n-\t    }\n-\t}\n-    }\n-  return 0;\n-}\n-\n-\n /* Given a basic block B which ends with a conditional and has\n    precisely two successors, determine which of the edges is taken if\n    the conditional is true and which is taken if the conditional is\n@@ -8247,6 +8189,8 @@ extract_true_false_edges_from_block (basic_block b,\n     }\n }\n \n+/* Emit return warnings.  */\n+\n namespace {\n \n const pass_data pass_data_warn_function_return =\n@@ -8271,10 +8215,65 @@ class pass_warn_function_return : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  unsigned int execute () { return execute_warn_function_return (); }\n+  virtual unsigned int execute (function *);\n \n }; // class pass_warn_function_return\n \n+unsigned int\n+pass_warn_function_return::execute (function *fun)\n+{\n+  source_location location;\n+  gimple last;\n+  edge e;\n+  edge_iterator ei;\n+\n+  if (!targetm.warn_func_return (fun->decl))\n+    return 0;\n+\n+  /* If we have a path to EXIT, then we do return.  */\n+  if (TREE_THIS_VOLATILE (fun->decl)\n+      && EDGE_COUNT (EXIT_BLOCK_PTR_FOR_FN (fun)->preds) > 0)\n+    {\n+      location = UNKNOWN_LOCATION;\n+      FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR_FOR_FN (fun)->preds)\n+\t{\n+\t  last = last_stmt (e->src);\n+\t  if ((gimple_code (last) == GIMPLE_RETURN\n+\t       || gimple_call_builtin_p (last, BUILT_IN_RETURN))\n+\t      && (location = gimple_location (last)) != UNKNOWN_LOCATION)\n+\t    break;\n+\t}\n+      if (location == UNKNOWN_LOCATION)\n+\tlocation = cfun->function_end_locus;\n+      warning_at (location, 0, \"%<noreturn%> function does return\");\n+    }\n+\n+  /* If we see \"return;\" in some basic block, then we do reach the end\n+     without returning a value.  */\n+  else if (warn_return_type\n+\t   && !TREE_NO_WARNING (fun->decl)\n+\t   && EDGE_COUNT (EXIT_BLOCK_PTR_FOR_FN (fun)->preds) > 0\n+\t   && !VOID_TYPE_P (TREE_TYPE (TREE_TYPE (fun->decl))))\n+    {\n+      FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR_FOR_FN (fun)->preds)\n+\t{\n+\t  gimple last = last_stmt (e->src);\n+\t  if (gimple_code (last) == GIMPLE_RETURN\n+\t      && gimple_return_retval (last) == NULL\n+\t      && !gimple_no_warning_p (last))\n+\t    {\n+\t      location = gimple_location (last);\n+\t      if (location == UNKNOWN_LOCATION)\n+\t\tlocation = fun->function_end_locus;\n+\t      warning_at (location, OPT_Wreturn_type, \"control reaches end of non-void function\");\n+\t      TREE_NO_WARNING (fun->decl) = 1;\n+\t      break;\n+\t    }\n+\t}\n+    }\n+  return 0;\n+}\n+\n } // anon namespace\n \n gimple_opt_pass *\n@@ -8348,13 +8347,6 @@ do_warn_unused_result (gimple_seq seq)\n     }\n }\n \n-static unsigned int\n-run_warn_unused_result (void)\n-{\n-  do_warn_unused_result (gimple_body (current_function_decl));\n-  return 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_warn_unused_result =\n@@ -8380,7 +8372,11 @@ class pass_warn_unused_result : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *) { return flag_warn_unused_result; }\n-  unsigned int execute () { return run_warn_unused_result (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      do_warn_unused_result (gimple_body (current_function_decl));\n+      return 0;\n+    }\n \n }; // class pass_warn_unused_result\n \n@@ -8522,7 +8518,7 @@ class pass_fixup_cfg : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   opt_pass * clone () { return new pass_fixup_cfg (m_ctxt); }\n-  unsigned int execute () { return execute_fixup_cfg (); }\n+  virtual unsigned int execute (function *) { return execute_fixup_cfg (); }\n \n }; // class pass_fixup_cfg\n "}, {"sha": "104620716ec0e95f7045417b97f87f655d994845", "filename": "gcc/tree-cfgcleanup.c", "status": "modified", "additions": 37, "deletions": 36, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-cfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-cfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -944,17 +944,46 @@ remove_forwarder_block_with_phi (basic_block bb)\n <L10>:;\n */\n \n-static unsigned int\n-merge_phi_nodes (void)\n+namespace {\n+\n+const pass_data pass_data_merge_phi =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"mergephi\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_execute */\n+  TV_TREE_MERGE_PHI, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_ssa, /* todo_flags_finish */\n+};\n+\n+class pass_merge_phi : public gimple_opt_pass\n {\n-  basic_block *worklist = XNEWVEC (basic_block, n_basic_blocks_for_fn (cfun));\n+public:\n+  pass_merge_phi (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_merge_phi, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_merge_phi (m_ctxt); }\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_merge_phi\n+\n+unsigned int\n+pass_merge_phi::execute (function *fun)\n+{\n+  basic_block *worklist = XNEWVEC (basic_block, n_basic_blocks_for_fn (fun));\n   basic_block *current = worklist;\n   basic_block bb;\n \n   calculate_dominance_info (CDI_DOMINATORS);\n \n   /* Find all PHI nodes that we may be able to merge.  */\n-  FOR_EACH_BB_FN (bb, cfun)\n+  FOR_EACH_BB_FN (bb, fun)\n     {\n       basic_block dest;\n \n@@ -1035,35 +1064,6 @@ merge_phi_nodes (void)\n   return 0;\n }\n \n-namespace {\n-\n-const pass_data pass_data_merge_phi =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"mergephi\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  true, /* has_execute */\n-  TV_TREE_MERGE_PHI, /* tv_id */\n-  ( PROP_cfg | PROP_ssa ), /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  TODO_verify_ssa, /* todo_flags_finish */\n-};\n-\n-class pass_merge_phi : public gimple_opt_pass\n-{\n-public:\n-  pass_merge_phi (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_merge_phi, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  opt_pass * clone () { return new pass_merge_phi (m_ctxt); }\n-  unsigned int execute () { return merge_phi_nodes (); }\n-\n-}; // class pass_merge_phi\n-\n } // anon namespace\n \n gimple_opt_pass *\n@@ -1142,9 +1142,10 @@ class pass_cleanup_cfg_post_optimizing : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  unsigned int execute () {\n-    return execute_cleanup_cfg_post_optimizing ();\n-  }\n+  virtual unsigned int execute (function *)\n+    {\n+      return execute_cleanup_cfg_post_optimizing ();\n+    }\n \n }; // class pass_cleanup_cfg_post_optimizing\n "}, {"sha": "a97aaf974ce79dd32cbafc6e945fba3fddfc9e23", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -1680,7 +1680,7 @@ class pass_lower_complex : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   opt_pass * clone () { return new pass_lower_complex (m_ctxt); }\n-  unsigned int execute () { return tree_lower_complex (); }\n+  virtual unsigned int execute (function *) { return tree_lower_complex (); }\n \n }; // class pass_lower_complex\n \n@@ -1724,7 +1724,7 @@ class pass_lower_complex_O0 : public gimple_opt_pass\n       return !(fun->curr_properties & PROP_gimple_lcx);\n     }\n \n-  unsigned int execute () { return tree_lower_complex (); }\n+  virtual unsigned int execute (function *) { return tree_lower_complex (); }\n \n }; // class pass_lower_complex_O0\n "}, {"sha": "960c04a14d0fa930eb2cf118fc8c540178fa8516", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 116, "deletions": 120, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -2121,8 +2121,36 @@ lower_eh_constructs_1 (struct leh_state *state, gimple_seq *pseq)\n     lower_eh_constructs_2 (state, &gsi);\n }\n \n-static unsigned int\n-lower_eh_constructs (void)\n+namespace {\n+\n+const pass_data pass_data_lower_eh =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"eh\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_execute */\n+  TV_TREE_EH, /* tv_id */\n+  PROP_gimple_lcf, /* properties_required */\n+  PROP_gimple_leh, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_lower_eh : public gimple_opt_pass\n+{\n+public:\n+  pass_lower_eh (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_lower_eh, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_lower_eh\n+\n+unsigned int\n+pass_lower_eh::execute (function *fun)\n {\n   struct leh_state null_state;\n   gimple_seq bodyp;\n@@ -2155,42 +2183,14 @@ lower_eh_constructs (void)\n \n   /* If this function needs a language specific EH personality routine\n      and the frontend didn't already set one do so now.  */\n-  if (function_needs_eh_personality (cfun) == eh_personality_lang\n+  if (function_needs_eh_personality (fun) == eh_personality_lang\n       && !DECL_FUNCTION_PERSONALITY (current_function_decl))\n     DECL_FUNCTION_PERSONALITY (current_function_decl)\n       = lang_hooks.eh_personality ();\n \n   return 0;\n }\n \n-namespace {\n-\n-const pass_data pass_data_lower_eh =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"eh\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  true, /* has_execute */\n-  TV_TREE_EH, /* tv_id */\n-  PROP_gimple_lcf, /* properties_required */\n-  PROP_gimple_leh, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  0, /* todo_flags_finish */\n-};\n-\n-class pass_lower_eh : public gimple_opt_pass\n-{\n-public:\n-  pass_lower_eh (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_lower_eh, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  unsigned int execute () { return lower_eh_constructs (); }\n-\n-}; // class pass_lower_eh\n-\n } // anon namespace\n \n gimple_opt_pass *\n@@ -3108,13 +3108,6 @@ refactor_eh_r (gimple_seq seq)\n     }\n }\n \n-static unsigned\n-refactor_eh (void)\n-{\n-  refactor_eh_r (gimple_body (current_function_decl));\n-  return 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_refactor_eh =\n@@ -3140,7 +3133,11 @@ class pass_refactor_eh : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *) { return flag_exceptions != 0; }\n-  unsigned int execute () { return refactor_eh (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      refactor_eh_r (gimple_body (current_function_decl));\n+      return 0;\n+    }\n \n }; // class pass_refactor_eh\n \n@@ -3304,37 +3301,6 @@ lower_resx (basic_block bb, gimple stmt, struct pointer_map_t *mnt_map)\n   return ret;\n }\n \n-static unsigned\n-execute_lower_resx (void)\n-{\n-  basic_block bb;\n-  struct pointer_map_t *mnt_map;\n-  bool dominance_invalidated = false;\n-  bool any_rewritten = false;\n-\n-  mnt_map = pointer_map_create ();\n-\n-  FOR_EACH_BB_FN (bb, cfun)\n-    {\n-      gimple last = last_stmt (bb);\n-      if (last && is_gimple_resx (last))\n-\t{\n-\t  dominance_invalidated |= lower_resx (bb, last, mnt_map);\n-\t  any_rewritten = true;\n-\t}\n-    }\n-\n-  pointer_map_destroy (mnt_map);\n-\n-  if (dominance_invalidated)\n-    {\n-      free_dominance_info (CDI_DOMINATORS);\n-      free_dominance_info (CDI_POST_DOMINATORS);\n-    }\n-\n-  return any_rewritten ? TODO_update_ssa_only_virtuals : 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_lower_resx =\n@@ -3360,10 +3326,41 @@ class pass_lower_resx : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *) { return flag_exceptions != 0; }\n-  unsigned int execute () { return execute_lower_resx (); }\n+  virtual unsigned int execute (function *);\n \n }; // class pass_lower_resx\n \n+unsigned\n+pass_lower_resx::execute (function *fun)\n+{\n+  basic_block bb;\n+  struct pointer_map_t *mnt_map;\n+  bool dominance_invalidated = false;\n+  bool any_rewritten = false;\n+\n+  mnt_map = pointer_map_create ();\n+\n+  FOR_EACH_BB_FN (bb, fun)\n+    {\n+      gimple last = last_stmt (bb);\n+      if (last && is_gimple_resx (last))\n+\t{\n+\t  dominance_invalidated |= lower_resx (bb, last, mnt_map);\n+\t  any_rewritten = true;\n+\t}\n+    }\n+\n+  pointer_map_destroy (mnt_map);\n+\n+  if (dominance_invalidated)\n+    {\n+      free_dominance_info (CDI_DOMINATORS);\n+      free_dominance_info (CDI_POST_DOMINATORS);\n+    }\n+\n+  return any_rewritten ? TODO_update_ssa_only_virtuals : 0;\n+}\n+\n } // anon namespace\n \n gimple_opt_pass *\n@@ -3704,16 +3701,45 @@ lower_eh_dispatch (basic_block src, gimple stmt)\n   return redirected;\n }\n \n-static unsigned\n-execute_lower_eh_dispatch (void)\n+namespace {\n+\n+const pass_data pass_data_lower_eh_dispatch =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"ehdisp\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_execute */\n+  TV_TREE_EH, /* tv_id */\n+  PROP_gimple_lcf, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_flow, /* todo_flags_finish */\n+};\n+\n+class pass_lower_eh_dispatch : public gimple_opt_pass\n+{\n+public:\n+  pass_lower_eh_dispatch (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_lower_eh_dispatch, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *fun) { return fun->eh->region_tree != NULL; }\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_lower_eh_dispatch\n+\n+unsigned\n+pass_lower_eh_dispatch::execute (function *fun)\n {\n   basic_block bb;\n   int flags = 0;\n   bool redirected = false;\n \n   assign_filter_values ();\n \n-  FOR_EACH_BB_FN (bb, cfun)\n+  FOR_EACH_BB_FN (bb, fun)\n     {\n       gimple last = last_stmt (bb);\n       if (last == NULL)\n@@ -3737,36 +3763,6 @@ execute_lower_eh_dispatch (void)\n   return flags;\n }\n \n-namespace {\n-\n-const pass_data pass_data_lower_eh_dispatch =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"ehdisp\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  true, /* has_execute */\n-  TV_TREE_EH, /* tv_id */\n-  PROP_gimple_lcf, /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  TODO_verify_flow, /* todo_flags_finish */\n-};\n-\n-class pass_lower_eh_dispatch : public gimple_opt_pass\n-{\n-public:\n-  pass_lower_eh_dispatch (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_lower_eh_dispatch, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  virtual bool gate (function *fun) { return fun->eh->region_tree != NULL; }\n-\n-  unsigned int execute () { return execute_lower_eh_dispatch (); }\n-\n-}; // class pass_lower_eh_dispatch\n-\n } // anon namespace\n \n gimple_opt_pass *\n@@ -4564,21 +4560,6 @@ execute_cleanup_eh_1 (void)\n   return 0;\n }\n \n-static unsigned int\n-execute_cleanup_eh (void)\n-{\n-  int ret = execute_cleanup_eh_1 ();\n-\n-  /* If the function no longer needs an EH personality routine\n-     clear it.  This exposes cross-language inlining opportunities\n-     and avoids references to a never defined personality routine.  */\n-  if (DECL_FUNCTION_PERSONALITY (current_function_decl)\n-      && function_needs_eh_personality (cfun) != eh_personality_lang)\n-    DECL_FUNCTION_PERSONALITY (current_function_decl) = NULL_TREE;\n-\n-  return ret;\n-}\n-\n namespace {\n \n const pass_data pass_data_cleanup_eh =\n@@ -4609,10 +4590,25 @@ class pass_cleanup_eh : public gimple_opt_pass\n       return fun->eh != NULL && fun->eh->region_tree != NULL;\n     }\n \n-  unsigned int execute () { return execute_cleanup_eh (); }\n+  virtual unsigned int execute (function *);\n \n }; // class pass_cleanup_eh\n \n+unsigned int\n+pass_cleanup_eh::execute (function *fun)\n+{\n+  int ret = execute_cleanup_eh_1 ();\n+\n+  /* If the function no longer needs an EH personality routine\n+     clear it.  This exposes cross-language inlining opportunities\n+     and avoids references to a never defined personality routine.  */\n+  if (DECL_FUNCTION_PERSONALITY (current_function_decl)\n+      && function_needs_eh_personality (fun) != eh_personality_lang)\n+    DECL_FUNCTION_PERSONALITY (current_function_decl) = NULL_TREE;\n+\n+  return ret;\n+}\n+\n } // anon namespace\n \n gimple_opt_pass *"}, {"sha": "0ed503aec3fa1e3e8abdf1da7a21a88d13225b84", "filename": "gcc/tree-emutls.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-emutls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-emutls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-emutls.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -846,7 +846,7 @@ class pass_ipa_lower_emutls : public simple_ipa_opt_pass\n       return !targetm.have_tls;\n     }\n \n-  unsigned int execute () { return ipa_lower_emutls (); }\n+  virtual unsigned int execute (function *) { return ipa_lower_emutls (); }\n \n }; // class pass_ipa_lower_emutls\n "}, {"sha": "21a9f05c78bfa0f62b0ca651addb7d27f715f627", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -1986,33 +1986,6 @@ tree_if_conversion (struct loop *loop)\n \n /* Tree if-conversion pass management.  */\n \n-static unsigned int\n-main_tree_if_conversion (void)\n-{\n-  struct loop *loop;\n-  unsigned todo = 0;\n-\n-  if (number_of_loops (cfun) <= 1)\n-    return 0;\n-\n-  FOR_EACH_LOOP (loop, 0)\n-    if (flag_tree_loop_if_convert == 1\n-\t|| flag_tree_loop_if_convert_stores == 1\n-\t|| ((flag_tree_loop_vectorize || loop->force_vectorize)\n-\t    && !loop->dont_vectorize))\n-      todo |= tree_if_conversion (loop);\n-\n-#ifdef ENABLE_CHECKING\n-  {\n-    basic_block bb;\n-    FOR_EACH_BB_FN (bb, cfun)\n-      gcc_assert (!bb->aux);\n-  }\n-#endif\n-\n-  return todo;\n-}\n-\n namespace {\n \n const pass_data pass_data_if_conversion =\n@@ -2039,7 +2012,7 @@ class pass_if_conversion : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *);\n-  unsigned int execute () { return main_tree_if_conversion (); }\n+  virtual unsigned int execute (function *);\n \n }; // class pass_if_conversion\n \n@@ -2052,6 +2025,33 @@ pass_if_conversion::gate (function *fun)\n \t  || flag_tree_loop_if_convert_stores == 1);\n }\n \n+unsigned int\n+pass_if_conversion::execute (function *fun)\n+{\n+  struct loop *loop;\n+  unsigned todo = 0;\n+\n+  if (number_of_loops (fun) <= 1)\n+    return 0;\n+\n+  FOR_EACH_LOOP (loop, 0)\n+    if (flag_tree_loop_if_convert == 1\n+\t|| flag_tree_loop_if_convert_stores == 1\n+\t|| ((flag_tree_loop_vectorize || loop->force_vectorize)\n+\t    && !loop->dont_vectorize))\n+      todo |= tree_if_conversion (loop);\n+\n+#ifdef ENABLE_CHECKING\n+  {\n+    basic_block bb;\n+    FOR_EACH_BB_FN (bb, fun)\n+      gcc_assert (!bb->aux);\n+  }\n+#endif\n+\n+  return todo;\n+}\n+\n } // anon namespace\n \n gimple_opt_pass *"}, {"sha": "8fc419344c77d1ea2fcd680ab4ecf8b9330ce077", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -2299,45 +2299,79 @@ fini_ssa_renamer (void)\n    Steps 3 and 4 are done using the dominator tree walker\n    (walk_dominator_tree).  */\n \n-static unsigned int\n-rewrite_into_ssa (void)\n+namespace {\n+\n+const pass_data pass_data_build_ssa =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"ssa\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_execute */\n+  TV_TREE_SSA_OTHER, /* tv_id */\n+  PROP_cfg, /* properties_required */\n+  PROP_ssa, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_verify_ssa | TODO_remove_unused_locals ), /* todo_flags_finish */\n+};\n+\n+class pass_build_ssa : public gimple_opt_pass\n+{\n+public:\n+  pass_build_ssa (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_build_ssa, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *fun)\n+    {\n+      /* Do nothing for funcions that was produced already in SSA form.  */\n+      return !(fun->curr_properties & PROP_ssa);\n+    }\n+\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_build_ssa\n+\n+unsigned int\n+pass_build_ssa::execute (function *fun)\n {\n   bitmap_head *dfs;\n   basic_block bb;\n   unsigned i;\n \n   /* Initialize operand data structures.  */\n-  init_ssa_operands (cfun);\n+  init_ssa_operands (fun);\n \n   /* Initialize internal data needed by the renamer.  */\n   init_ssa_renamer ();\n \n   /* Initialize the set of interesting blocks.  The callback\n      mark_def_sites will add to this set those blocks that the renamer\n      should process.  */\n-  interesting_blocks = sbitmap_alloc (last_basic_block_for_fn (cfun));\n+  interesting_blocks = sbitmap_alloc (last_basic_block_for_fn (fun));\n   bitmap_clear (interesting_blocks);\n \n   /* Initialize dominance frontier.  */\n-  dfs = XNEWVEC (bitmap_head, last_basic_block_for_fn (cfun));\n-  FOR_EACH_BB_FN (bb, cfun)\n+  dfs = XNEWVEC (bitmap_head, last_basic_block_for_fn (fun));\n+  FOR_EACH_BB_FN (bb, fun)\n     bitmap_initialize (&dfs[bb->index], &bitmap_default_obstack);\n \n   /* 1- Compute dominance frontiers.  */\n   calculate_dominance_info (CDI_DOMINATORS);\n   compute_dominance_frontiers (dfs);\n \n   /* 2- Find and mark definition sites.  */\n-  mark_def_dom_walker (CDI_DOMINATORS).walk (cfun->cfg->x_entry_block_ptr);\n+  mark_def_dom_walker (CDI_DOMINATORS).walk (fun->cfg->x_entry_block_ptr);\n \n   /* 3- Insert PHI nodes at dominance frontiers of definition blocks.  */\n   insert_phi_nodes (dfs);\n \n   /* 4- Rename all the blocks.  */\n-  rewrite_blocks (ENTRY_BLOCK_PTR_FOR_FN (cfun), REWRITE_ALL);\n+  rewrite_blocks (ENTRY_BLOCK_PTR_FOR_FN (fun), REWRITE_ALL);\n \n   /* Free allocated memory.  */\n-  FOR_EACH_BB_FN (bb, cfun)\n+  FOR_EACH_BB_FN (bb, fun)\n     bitmap_clear (&dfs[bb->index]);\n   free (dfs);\n \n@@ -2365,40 +2399,6 @@ rewrite_into_ssa (void)\n   return 0;\n }\n \n-namespace {\n-\n-const pass_data pass_data_build_ssa =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"ssa\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  true, /* has_execute */\n-  TV_TREE_SSA_OTHER, /* tv_id */\n-  PROP_cfg, /* properties_required */\n-  PROP_ssa, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  ( TODO_verify_ssa | TODO_remove_unused_locals ), /* todo_flags_finish */\n-};\n-\n-class pass_build_ssa : public gimple_opt_pass\n-{\n-public:\n-  pass_build_ssa (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_build_ssa, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  virtual bool gate (function *fun)\n-    {\n-      /* Do nothing for funcions that was produced already in SSA form.  */\n-      return !(fun->curr_properties & PROP_ssa);\n-    }\n-\n-  unsigned int execute () { return rewrite_into_ssa (); }\n-\n-}; // class pass_build_ssa\n-\n } // anon namespace\n \n gimple_opt_pass *"}, {"sha": "5fff7be5bd86efab4e543f4ab54fd48aeff04c37", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -1669,15 +1669,49 @@ distribute_loop (struct loop *loop, vec<gimple> stmts,\n \n /* Distribute all loops in the current function.  */\n \n-static unsigned int\n-tree_loop_distribution (void)\n+namespace {\n+\n+const pass_data pass_data_loop_distribution =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"ldist\", /* name */\n+  OPTGROUP_LOOP, /* optinfo_flags */\n+  true, /* has_execute */\n+  TV_TREE_LOOP_DISTRIBUTION, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_ssa, /* todo_flags_finish */\n+};\n+\n+class pass_loop_distribution : public gimple_opt_pass\n+{\n+public:\n+  pass_loop_distribution (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_loop_distribution, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *)\n+    {\n+      return flag_tree_loop_distribution\n+\t|| flag_tree_loop_distribute_patterns;\n+    }\n+\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_loop_distribution\n+\n+unsigned int\n+pass_loop_distribution::execute (function *fun)\n {\n   struct loop *loop;\n   bool changed = false;\n   basic_block bb;\n   control_dependences *cd = NULL;\n \n-  FOR_ALL_BB_FN (bb, cfun)\n+  FOR_ALL_BB_FN (bb, fun)\n     {\n       gimple_stmt_iterator gsi;\n       for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n@@ -1715,7 +1749,7 @@ tree_loop_distribution (void)\n \t      if (virtual_operand_p (gimple_phi_result (phi)))\n \t\tcontinue;\n \t      /* Distribute stmts which have defs that are used outside of\n-\t         the loop.  */\n+\t\t the loop.  */\n \t      if (!stmt_has_scalar_dependences_outside_loop (loop, phi))\n \t\tcontinue;\n \t      work_list.safe_push (phi);\n@@ -1725,15 +1759,15 @@ tree_loop_distribution (void)\n \t      gimple stmt = gsi_stmt (gsi);\n \n \t      /* If there is a stmt with side-effects bail out - we\n-\t         cannot and should not distribute this loop.  */\n+\t\t cannot and should not distribute this loop.  */\n \t      if (gimple_has_side_effects (stmt))\n \t\t{\n \t\t  work_list.truncate (0);\n \t\t  goto out;\n \t\t}\n \n \t      /* Distribute stmts which have defs that are used outside of\n-\t         the loop.  */\n+\t\t the loop.  */\n \t      if (stmt_has_scalar_dependences_outside_loop (loop, stmt))\n \t\t;\n \t      /* Otherwise only distribute stores for now.  */\n@@ -1779,7 +1813,7 @@ tree_loop_distribution (void)\n \n   if (changed)\n     {\n-      mark_virtual_operands_for_renaming (cfun);\n+      mark_virtual_operands_for_renaming (fun);\n       rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa);\n     }\n \n@@ -1790,40 +1824,6 @@ tree_loop_distribution (void)\n   return 0;\n }\n \n-namespace {\n-\n-const pass_data pass_data_loop_distribution =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"ldist\", /* name */\n-  OPTGROUP_LOOP, /* optinfo_flags */\n-  true, /* has_execute */\n-  TV_TREE_LOOP_DISTRIBUTION, /* tv_id */\n-  ( PROP_cfg | PROP_ssa ), /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  TODO_verify_ssa, /* todo_flags_finish */\n-};\n-\n-class pass_loop_distribution : public gimple_opt_pass\n-{\n-public:\n-  pass_loop_distribution (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_loop_distribution, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  virtual bool gate (function *)\n-    {\n-      return flag_tree_loop_distribution\n-\t|| flag_tree_loop_distribute_patterns;\n-    }\n-\n-  unsigned int execute () { return tree_loop_distribution (); }\n-\n-}; // class pass_loop_distribution\n-\n } // anon namespace\n \n gimple_opt_pass *"}, {"sha": "45b16f4f4018ee8493b12a2babedd8c9061d724e", "filename": "gcc/tree-nrv.c", "status": "modified", "additions": 64, "deletions": 64, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-nrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-nrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nrv.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -113,8 +113,38 @@ finalize_nrv_r (tree *tp, int *walk_subtrees, void *data)\n    then we could either have the languages register the optimization or\n    we could change the gating function to check the current language.  */\n \n-static unsigned int\n-tree_nrv (void)\n+namespace {\n+\n+const pass_data pass_data_nrv =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"nrv\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_execute */\n+  TV_TREE_NRV, /* tv_id */\n+  ( PROP_ssa | PROP_cfg ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_nrv : public gimple_opt_pass\n+{\n+public:\n+  pass_nrv (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_nrv, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *) { return optimize > 0; }\n+\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_nrv\n+\n+unsigned int\n+pass_nrv::execute (function *fun)\n {\n   tree result = DECL_RESULT (current_function_decl);\n   tree result_type = TREE_TYPE (result);\n@@ -144,7 +174,7 @@ tree_nrv (void)\n     return 0;\n \n   /* Look through each block for assignments to the RESULT_DECL.  */\n-  FOR_EACH_BB_FN (bb, cfun)\n+  FOR_EACH_BB_FN (bb, fun)\n     {\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n@@ -238,7 +268,7 @@ tree_nrv (void)\n      RESULT.  */\n   data.var = found;\n   data.result = result;\n-  FOR_EACH_BB_FN (bb, cfun)\n+  FOR_EACH_BB_FN (bb, fun)\n     {\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); )\n \t{\n@@ -272,36 +302,6 @@ tree_nrv (void)\n   return 0;\n }\n \n-namespace {\n-\n-const pass_data pass_data_nrv =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"nrv\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  true, /* has_execute */\n-  TV_TREE_NRV, /* tv_id */\n-  ( PROP_ssa | PROP_cfg ), /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  0, /* todo_flags_finish */\n-};\n-\n-class pass_nrv : public gimple_opt_pass\n-{\n-public:\n-  pass_nrv (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_nrv, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  virtual bool gate (function *) { return optimize > 0; }\n-\n-  unsigned int execute () { return tree_nrv (); }\n-\n-}; // class pass_nrv\n-\n } // anon namespace\n \n gimple_opt_pass *\n@@ -347,35 +347,6 @@ dest_safe_for_nrv_p (gimple call)\n    escaped prior to the call.  If it has, modifications to the local\n    variable will produce visible changes elsewhere, as in PR c++/19317.  */\n \n-static unsigned int\n-execute_return_slot_opt (void)\n-{\n-  basic_block bb;\n-\n-  FOR_EACH_BB_FN (bb, cfun)\n-    {\n-      gimple_stmt_iterator gsi;\n-      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-\t{\n-\t  gimple stmt = gsi_stmt (gsi);\n-\t  bool slot_opt_p;\n-\n-\t  if (is_gimple_call (stmt)\n-\t      && gimple_call_lhs (stmt)\n-\t      && !gimple_call_return_slot_opt_p (stmt)\n-\t      && aggregate_value_p (TREE_TYPE (gimple_call_lhs (stmt)),\n-\t\t\t\t    gimple_call_fndecl (stmt)))\n-\t    {\n-\t      /* Check if the location being assigned to is\n-\t         clobbered by the call.  */\n-\t      slot_opt_p = dest_safe_for_nrv_p (stmt);\n-\t      gimple_call_set_return_slot_opt (stmt, slot_opt_p);\n-\t    }\n-\t}\n-    }\n-  return 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_return_slot =\n@@ -400,10 +371,39 @@ class pass_return_slot : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  unsigned int execute () { return execute_return_slot_opt (); }\n+  virtual unsigned int execute (function *);\n \n }; // class pass_return_slot\n \n+unsigned int\n+pass_return_slot::execute (function *fun)\n+{\n+  basic_block bb;\n+\n+  FOR_EACH_BB_FN (bb, fun)\n+    {\n+      gimple_stmt_iterator gsi;\n+      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t{\n+\t  gimple stmt = gsi_stmt (gsi);\n+\t  bool slot_opt_p;\n+\n+\t  if (is_gimple_call (stmt)\n+\t      && gimple_call_lhs (stmt)\n+\t      && !gimple_call_return_slot_opt_p (stmt)\n+\t      && aggregate_value_p (TREE_TYPE (gimple_call_lhs (stmt)),\n+\t\t\t\t    gimple_call_fndecl (stmt)))\n+\t    {\n+\t      /* Check if the location being assigned to is\n+\t\t clobbered by the call.  */\n+\t      slot_opt_p = dest_safe_for_nrv_p (stmt);\n+\t      gimple_call_set_return_slot_opt (stmt, slot_opt_p);\n+\t    }\n+\t}\n+    }\n+  return 0;\n+}\n+\n } // anon namespace\n \n gimple_opt_pass *"}, {"sha": "ec50709e86e0f933a0e67b5a15b4b4ce500fd8db", "filename": "gcc/tree-object-size.c", "status": "modified", "additions": 32, "deletions": 33, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-object-size.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-object-size.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-object-size.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -66,7 +66,6 @@ static bool merge_object_sizes (struct object_size_info *, tree, tree,\n \t\t\t\tunsigned HOST_WIDE_INT);\n static bool plus_stmt_object_size (struct object_size_info *, tree, gimple);\n static bool cond_expr_object_size (struct object_size_info *, tree, gimple);\n-static unsigned int compute_object_sizes (void);\n static void init_offset_limit (void);\n static void check_for_plus_in_loops (struct object_size_info *, tree);\n static void check_for_plus_in_loops_1 (struct object_size_info *, tree,\n@@ -1207,11 +1206,40 @@ fini_object_sizes (void)\n \n /* Simple pass to optimize all __builtin_object_size () builtins.  */\n \n-static unsigned int\n-compute_object_sizes (void)\n+namespace {\n+\n+const pass_data pass_data_object_sizes =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"objsz\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_ssa, /* todo_flags_finish */\n+};\n+\n+class pass_object_sizes : public gimple_opt_pass\n+{\n+public:\n+  pass_object_sizes (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_object_sizes, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_object_sizes (m_ctxt); }\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_object_sizes\n+\n+unsigned int\n+pass_object_sizes::execute (function *fun)\n {\n   basic_block bb;\n-  FOR_EACH_BB_FN (bb, cfun)\n+  FOR_EACH_BB_FN (bb, fun)\n     {\n       gimple_stmt_iterator i;\n       for (i = gsi_start_bb (bb); !gsi_end_p (i); gsi_next (&i))\n@@ -1281,35 +1309,6 @@ compute_object_sizes (void)\n   return 0;\n }\n \n-namespace {\n-\n-const pass_data pass_data_object_sizes =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"objsz\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  true, /* has_execute */\n-  TV_NONE, /* tv_id */\n-  ( PROP_cfg | PROP_ssa ), /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  TODO_verify_ssa, /* todo_flags_finish */\n-};\n-\n-class pass_object_sizes : public gimple_opt_pass\n-{\n-public:\n-  pass_object_sizes (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_object_sizes, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  opt_pass * clone () { return new pass_object_sizes (m_ctxt); }\n-  unsigned int execute () { return compute_object_sizes (); }\n-\n-}; // class pass_object_sizes\n-\n } // anon namespace\n \n gimple_opt_pass *"}, {"sha": "79b327b02c0bbfe8e04c5e917da62d8bc365c372", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -2253,17 +2253,6 @@ parallelize_loops (void)\n \n /* Parallelization.  */\n \n-static unsigned\n-tree_parallelize_loops (void)\n-{\n-  if (number_of_loops (cfun) <= 1)\n-    return 0;\n-\n-  if (parallelize_loops ())\n-    return TODO_cleanup_cfg | TODO_rebuild_alias;\n-  return 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_parallelize_loops =\n@@ -2289,10 +2278,21 @@ class pass_parallelize_loops : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *) { return flag_tree_parallelize_loops > 1; }\n-  unsigned int execute () { return tree_parallelize_loops (); }\n+  virtual unsigned int execute (function *);\n \n }; // class pass_parallelize_loops\n \n+unsigned\n+pass_parallelize_loops::execute (function *fun)\n+{\n+  if (number_of_loops (fun) <= 1)\n+    return 0;\n+\n+  if (parallelize_loops ())\n+    return TODO_cleanup_cfg | TODO_rebuild_alias;\n+  return 0;\n+}\n+\n } // anon namespace\n \n gimple_opt_pass *"}, {"sha": "e63f3069068cb95d6a466453caeed2def50b036c", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -96,7 +96,7 @@ class opt_pass : public pass_data\n      be sub-passes otherwise this pass does nothing.\n      The return value contains TODOs to execute in addition to those in\n      TODO_flags_finish.   */\n-  virtual unsigned int execute ();\n+  virtual unsigned int execute (function *fun);\n \n protected:\n   opt_pass (const pass_data&, gcc::context *);"}, {"sha": "4d77401c706f6a36044d22dacdc7260311d2d131", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -2598,7 +2598,10 @@ class pass_predcom : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *) { return flag_predictive_commoning != 0; }\n-  unsigned int execute () { return run_tree_predictive_commoning (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      return run_tree_predictive_commoning ();\n+    }\n \n }; // class pass_predcom\n "}, {"sha": "deefa8b992aef109c9c0811d443cd173a2fa670f", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -688,7 +688,7 @@ class pass_ipa_tree_profile : public simple_ipa_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *);\n-  unsigned int execute () { return tree_profiling (); }\n+  virtual unsigned int execute (function *) { return tree_profiling (); }\n \n }; // class pass_ipa_tree_profile\n "}, {"sha": "890234ff23b04f5617a5f7e54529686ce9778243", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -3525,7 +3525,7 @@ class pass_sra_early : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *) { return gate_intra_sra (); }\n-  unsigned int execute () { return early_intra_sra (); }\n+  virtual unsigned int execute (function *) { return early_intra_sra (); }\n \n }; // class pass_sra_early\n \n@@ -3562,7 +3562,7 @@ class pass_sra : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *) { return gate_intra_sra (); }\n-  unsigned int execute () { return late_intra_sra (); }\n+  virtual unsigned int execute (function *) { return late_intra_sra (); }\n \n }; // class pass_sra\n \n@@ -5076,7 +5076,7 @@ class pass_early_ipa_sra : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *) { return flag_ipa_sra && dbg_cnt (eipa_sra); }\n-  unsigned int execute () { return ipa_early_sra (); }\n+  virtual unsigned int execute (function *) { return ipa_early_sra (); }\n \n }; // class pass_early_ipa_sra\n "}, {"sha": "257d108ec31a3c5fc4d0d0363fe447d9a2473abd", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 34, "deletions": 35, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -2314,7 +2314,7 @@ class pass_ccp : public gimple_opt_pass\n   /* opt_pass methods: */\n   opt_pass * clone () { return new pass_ccp (m_ctxt); }\n   virtual bool gate (function *) { return flag_tree_ccp != 0; }\n-  unsigned int execute () { return do_ssa_ccp (); }\n+  virtual unsigned int execute (function *) { return do_ssa_ccp (); }\n \n }; // class pass_ccp\n \n@@ -2559,14 +2559,43 @@ optimize_unreachable (gimple_stmt_iterator i)\n /* A simple pass that attempts to fold all builtin functions.  This pass\n    is run after we've propagated as many constants as we can.  */\n \n-static unsigned int\n-execute_fold_all_builtins (void)\n+namespace {\n+\n+const pass_data pass_data_fold_builtins =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"fab\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_verify_ssa | TODO_update_ssa ), /* todo_flags_finish */\n+};\n+\n+class pass_fold_builtins : public gimple_opt_pass\n+{\n+public:\n+  pass_fold_builtins (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_fold_builtins, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_fold_builtins (m_ctxt); }\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_fold_builtins\n+\n+unsigned int\n+pass_fold_builtins::execute (function *fun)\n {\n   bool cfg_changed = false;\n   basic_block bb;\n   unsigned int todoflags = 0;\n \n-  FOR_EACH_BB_FN (bb, cfun)\n+  FOR_EACH_BB_FN (bb, fun)\n     {\n       gimple_stmt_iterator i;\n       for (i = gsi_start_bb (bb); !gsi_end_p (i); )\n@@ -2608,7 +2637,7 @@ execute_fold_all_builtins (void)\n \t  result = gimple_fold_builtin (stmt);\n \n \t  if (result)\n-\t    gimple_remove_stmt_histograms (cfun, stmt);\n+\t    gimple_remove_stmt_histograms (fun, stmt);\n \n \t  if (!result)\n \t    switch (DECL_FUNCTION_CODE (callee))\n@@ -2703,36 +2732,6 @@ execute_fold_all_builtins (void)\n   return todoflags;\n }\n \n-\n-namespace {\n-\n-const pass_data pass_data_fold_builtins =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"fab\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  true, /* has_execute */\n-  TV_NONE, /* tv_id */\n-  ( PROP_cfg | PROP_ssa ), /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  ( TODO_verify_ssa | TODO_update_ssa ), /* todo_flags_finish */\n-};\n-\n-class pass_fold_builtins : public gimple_opt_pass\n-{\n-public:\n-  pass_fold_builtins (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_fold_builtins, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  opt_pass * clone () { return new pass_fold_builtins (m_ctxt); }\n-  unsigned int execute () { return execute_fold_all_builtins (); }\n-\n-}; // class pass_fold_builtins\n-\n } // anon namespace\n \n gimple_opt_pass *"}, {"sha": "6e3a5693aa77a3f366bc329f1cc1b207f693d728", "filename": "gcc/tree-ssa-copy.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssa-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssa-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copy.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -671,7 +671,7 @@ class pass_copy_prop : public gimple_opt_pass\n   /* opt_pass methods: */\n   opt_pass * clone () { return new pass_copy_prop (m_ctxt); }\n   virtual bool gate (function *) { return flag_tree_copy_prop != 0; }\n-  unsigned int execute () { return execute_copy_prop (); }\n+  virtual unsigned int execute (function *) { return execute_copy_prop (); }\n \n }; // class pass_copy_prop\n "}, {"sha": "b9c9ba399508ce7b9e35e3312a4d1c827a43d5a2", "filename": "gcc/tree-ssa-copyrename.c", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssa-copyrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssa-copyrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copyrename.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -299,14 +299,44 @@ copy_rename_partition_coalesce (var_map map, tree var1, tree var2, FILE *debug)\n }\n \n \n+namespace {\n+\n+const pass_data pass_data_rename_ssa_copies =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"copyrename\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_execute */\n+  TV_TREE_COPY_RENAME, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_ssa, /* todo_flags_finish */\n+};\n+\n+class pass_rename_ssa_copies : public gimple_opt_pass\n+{\n+public:\n+  pass_rename_ssa_copies (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_rename_ssa_copies, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_rename_ssa_copies (m_ctxt); }\n+  virtual bool gate (function *) { return flag_tree_copyrename != 0; }\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_rename_ssa_copies\n+\n /* This function will make a pass through the IL, and attempt to coalesce any\n    SSA versions which occur in PHI's or copies.  Coalescing is accomplished by\n    changing the underlying root variable of all coalesced version.  This will\n    then cause the SSA->normal pass to attempt to coalesce them all to the same\n    variable.  */\n \n-static unsigned int\n-rename_ssa_copies (void)\n+unsigned int\n+pass_rename_ssa_copies::execute (function *fun)\n {\n   var_map map;\n   basic_block bb;\n@@ -325,7 +355,7 @@ rename_ssa_copies (void)\n \n   map = init_var_map (num_ssa_names);\n \n-  FOR_EACH_BB_FN (bb, cfun)\n+  FOR_EACH_BB_FN (bb, fun)\n     {\n       /* Scan for real copies.  */\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n@@ -341,7 +371,7 @@ rename_ssa_copies (void)\n \t}\n     }\n \n-  FOR_EACH_BB_FN (bb, cfun)\n+  FOR_EACH_BB_FN (bb, fun)\n     {\n       /* Treat PHI nodes as copies between the result and each argument.  */\n       for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n@@ -429,42 +459,12 @@ rename_ssa_copies (void)\n       replace_ssa_name_symbol (var, SSA_NAME_VAR (part_var));\n     }\n \n-  statistics_counter_event (cfun, \"copies coalesced\",\n+  statistics_counter_event (fun, \"copies coalesced\",\n \t\t\t    stats.coalesced);\n   delete_var_map (map);\n   return 0;\n }\n \n-namespace {\n-\n-const pass_data pass_data_rename_ssa_copies =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"copyrename\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  true, /* has_execute */\n-  TV_TREE_COPY_RENAME, /* tv_id */\n-  ( PROP_cfg | PROP_ssa ), /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  TODO_verify_ssa, /* todo_flags_finish */\n-};\n-\n-class pass_rename_ssa_copies : public gimple_opt_pass\n-{\n-public:\n-  pass_rename_ssa_copies (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_rename_ssa_copies, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  opt_pass * clone () { return new pass_rename_ssa_copies (m_ctxt); }\n-  virtual bool gate (function *) { return flag_tree_copyrename != 0; }\n-  unsigned int execute () { return rename_ssa_copies (); }\n-\n-}; // class pass_rename_ssa_copies\n-\n } // anon namespace\n \n gimple_opt_pass *"}, {"sha": "6389f2386041f56a50d5ba48f144f24d4e5317db", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -1530,7 +1530,7 @@ class pass_dce : public gimple_opt_pass\n   /* opt_pass methods: */\n   opt_pass * clone () { return new pass_dce (m_ctxt); }\n   virtual bool gate (function *) { return flag_tree_dce != 0; }\n-  unsigned int execute () { return tree_ssa_dce (); }\n+  virtual unsigned int execute (function *) { return tree_ssa_dce (); }\n \n }; // class pass_dce\n \n@@ -1568,7 +1568,7 @@ class pass_dce_loop : public gimple_opt_pass\n   /* opt_pass methods: */\n   opt_pass * clone () { return new pass_dce_loop (m_ctxt); }\n   virtual bool gate (function *) { return flag_tree_dce != 0; }\n-  unsigned int execute () { return tree_ssa_dce_loop (); }\n+  virtual unsigned int execute (function *) { return tree_ssa_dce_loop (); }\n \n }; // class pass_dce_loop\n \n@@ -1606,7 +1606,7 @@ class pass_cd_dce : public gimple_opt_pass\n   /* opt_pass methods: */\n   opt_pass * clone () { return new pass_cd_dce (m_ctxt); }\n   virtual bool gate (function *) { return flag_tree_dce != 0; }\n-  unsigned int execute () { return tree_ssa_cd_dce (); }\n+  virtual unsigned int execute (function *) { return tree_ssa_cd_dce (); }\n \n }; // class pass_cd_dce\n "}, {"sha": "15c4fb07596adf90429aad4a1d26c814914f6e40", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 76, "deletions": 76, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -832,8 +832,40 @@ class dom_opt_dom_walker : public dom_walker\n    every new symbol exposed, its corresponding bit will be set in\n    VARS_TO_RENAME.  */\n \n-static unsigned int\n-tree_ssa_dominator_optimize (void)\n+namespace {\n+\n+const pass_data pass_data_dominator =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"dom\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_execute */\n+  TV_TREE_SSA_DOMINATOR_OPTS, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_cleanup_cfg | TODO_update_ssa\n+    | TODO_verify_ssa\n+    | TODO_verify_flow ), /* todo_flags_finish */\n+};\n+\n+class pass_dominator : public gimple_opt_pass\n+{\n+public:\n+  pass_dominator (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_dominator, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_dominator (m_ctxt); }\n+  virtual bool gate (function *) { return flag_tree_dom != 0; }\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_dominator\n+\n+unsigned int\n+pass_dominator::execute (function *fun)\n {\n   memset (&opt_stats, 0, sizeof (opt_stats));\n \n@@ -867,12 +899,12 @@ tree_ssa_dominator_optimize (void)\n   mark_dfs_back_edges ();\n \n   /* Recursively walk the dominator tree optimizing statements.  */\n-  dom_opt_dom_walker (CDI_DOMINATORS).walk (cfun->cfg->x_entry_block_ptr);\n+  dom_opt_dom_walker (CDI_DOMINATORS).walk (fun->cfg->x_entry_block_ptr);\n \n   {\n     gimple_stmt_iterator gsi;\n     basic_block bb;\n-    FOR_EACH_BB_FN (bb, cfun)\n+    FOR_EACH_BB_FN (bb, fun)\n       {\n \tfor (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t  update_stmt_if_modified (gsi_stmt (gsi));\n@@ -908,13 +940,13 @@ tree_ssa_dominator_optimize (void)\n \t iterator.  */\n       EXECUTE_IF_SET_IN_BITMAP (need_eh_cleanup, 0, i, bi)\n \t{\n-\t  basic_block bb = BASIC_BLOCK_FOR_FN (cfun, i);\n+\t  basic_block bb = BASIC_BLOCK_FOR_FN (fun, i);\n \t  if (bb == NULL)\n \t    continue;\n \t  while (single_succ_p (bb)\n \t\t && (single_succ_edge (bb)->flags & EDGE_EH) == 0)\n \t    bb = single_succ (bb);\n-\t  if (bb == EXIT_BLOCK_PTR_FOR_FN (cfun))\n+\t  if (bb == EXIT_BLOCK_PTR_FOR_FN (fun))\n \t    continue;\n \t  if ((unsigned) bb->index != i)\n \t    bitmap_set_bit (need_eh_cleanup, bb->index);\n@@ -924,11 +956,11 @@ tree_ssa_dominator_optimize (void)\n       bitmap_clear (need_eh_cleanup);\n     }\n \n-  statistics_counter_event (cfun, \"Redundant expressions eliminated\",\n+  statistics_counter_event (fun, \"Redundant expressions eliminated\",\n \t\t\t    opt_stats.num_re);\n-  statistics_counter_event (cfun, \"Constants propagated\",\n+  statistics_counter_event (fun, \"Constants propagated\",\n \t\t\t    opt_stats.num_const_prop);\n-  statistics_counter_event (cfun, \"Copies propagated\",\n+  statistics_counter_event (fun, \"Copies propagated\",\n \t\t\t    opt_stats.num_copy_prop);\n \n   /* Debugging dumps.  */\n@@ -952,38 +984,6 @@ tree_ssa_dominator_optimize (void)\n   return 0;\n }\n \n-namespace {\n-\n-const pass_data pass_data_dominator =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"dom\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  true, /* has_execute */\n-  TV_TREE_SSA_DOMINATOR_OPTS, /* tv_id */\n-  ( PROP_cfg | PROP_ssa ), /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  ( TODO_cleanup_cfg | TODO_update_ssa\n-    | TODO_verify_ssa\n-    | TODO_verify_flow ), /* todo_flags_finish */\n-};\n-\n-class pass_dominator : public gimple_opt_pass\n-{\n-public:\n-  pass_dominator (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_dominator, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  opt_pass * clone () { return new pass_dominator (m_ctxt); }\n-  virtual bool gate (function *) { return flag_tree_dom != 0; }\n-  unsigned int execute () { return tree_ssa_dominator_optimize (); }\n-\n-}; // class pass_dominator\n-\n } // anon namespace\n \n gimple_opt_pass *\n@@ -3025,8 +3025,40 @@ eliminate_degenerate_phis_1 (basic_block bb, bitmap interesting_names)\n    pick up the secondary optimization opportunities with minimal\n    cost.  */\n \n-static unsigned int\n-eliminate_degenerate_phis (void)\n+namespace {\n+\n+const pass_data pass_data_phi_only_cprop =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"phicprop\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_execute */\n+  TV_TREE_PHI_CPROP, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_cleanup_cfg | TODO_verify_ssa\n+    | TODO_verify_stmts\n+    | TODO_update_ssa ), /* todo_flags_finish */\n+};\n+\n+class pass_phi_only_cprop : public gimple_opt_pass\n+{\n+public:\n+  pass_phi_only_cprop (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_phi_only_cprop, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_phi_only_cprop (m_ctxt); }\n+  virtual bool gate (function *) { return flag_tree_dom != 0; }\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_phi_only_cprop\n+\n+unsigned int\n+pass_phi_only_cprop::execute (function *fun)\n {\n   bitmap interesting_names;\n   bitmap interesting_names1;\n@@ -3059,7 +3091,7 @@ eliminate_degenerate_phis (void)\n      phase in dominator order.  Presumably this is because walking\n      in dominator order leaves fewer PHIs for later examination\n      by the worklist phase.  */\n-  eliminate_degenerate_phis_1 (ENTRY_BLOCK_PTR_FOR_FN (cfun),\n+  eliminate_degenerate_phis_1 (ENTRY_BLOCK_PTR_FOR_FN (fun),\n \t\t\t       interesting_names);\n \n   /* Second phase.  Eliminate second order degenerate PHIs as well\n@@ -3109,38 +3141,6 @@ eliminate_degenerate_phis (void)\n   return 0;\n }\n \n-namespace {\n-\n-const pass_data pass_data_phi_only_cprop =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"phicprop\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  true, /* has_execute */\n-  TV_TREE_PHI_CPROP, /* tv_id */\n-  ( PROP_cfg | PROP_ssa ), /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  ( TODO_cleanup_cfg | TODO_verify_ssa\n-    | TODO_verify_stmts\n-    | TODO_update_ssa ), /* todo_flags_finish */\n-};\n-\n-class pass_phi_only_cprop : public gimple_opt_pass\n-{\n-public:\n-  pass_phi_only_cprop (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_phi_only_cprop, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  opt_pass * clone () { return new pass_phi_only_cprop (m_ctxt); }\n-  virtual bool gate (function *) { return flag_tree_dom != 0; }\n-  unsigned int execute () { return eliminate_degenerate_phis (); }\n-\n-}; // class pass_phi_only_cprop\n-\n } // anon namespace\n \n gimple_opt_pass *"}, {"sha": "af69063bd20560febc775733352bf8c71e5e35cf", "filename": "gcc/tree-ssa-dse.c", "status": "modified", "additions": 32, "deletions": 36, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssa-dse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssa-dse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dse.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -80,8 +80,6 @@ along with GCC; see the file COPYING3.  If not see\n    remove their dead edges eventually.  */\n static bitmap need_eh_cleanup;\n \n-static unsigned int tree_ssa_dse (void);\n-\n \n /* A helper of dse_optimize_stmt.\n    Given a GIMPLE_ASSIGN in STMT, find a candidate statement *USE_STMT that\n@@ -327,10 +325,38 @@ dse_dom_walker::before_dom_children (basic_block bb)\n     }\n }\n \n-/* Main entry point.  */\n+namespace {\n+\n+const pass_data pass_data_dse =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"dse\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_execute */\n+  TV_TREE_DSE, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_ssa, /* todo_flags_finish */\n+};\n+\n+class pass_dse : public gimple_opt_pass\n+{\n+public:\n+  pass_dse (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_dse, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_dse (m_ctxt); }\n+  virtual bool gate (function *) { return flag_tree_dse != 0; }\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_dse\n \n-static unsigned int\n-tree_ssa_dse (void)\n+unsigned int\n+pass_dse::execute (function *fun)\n {\n   need_eh_cleanup = BITMAP_ALLOC (NULL);\n \n@@ -345,7 +371,7 @@ tree_ssa_dse (void)\n \n   /* Dead store elimination is fundamentally a walk of the post-dominator\n      tree and a backwards walk of statements within each block.  */\n-  dse_dom_walker (CDI_POST_DOMINATORS).walk (cfun->cfg->x_exit_block_ptr);\n+  dse_dom_walker (CDI_POST_DOMINATORS).walk (fun->cfg->x_exit_block_ptr);\n \n   /* Removal of stores may make some EH edges dead.  Purge such edges from\n      the CFG as needed.  */\n@@ -362,36 +388,6 @@ tree_ssa_dse (void)\n   return 0;\n }\n \n-namespace {\n-\n-const pass_data pass_data_dse =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"dse\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  true, /* has_execute */\n-  TV_TREE_DSE, /* tv_id */\n-  ( PROP_cfg | PROP_ssa ), /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  TODO_verify_ssa, /* todo_flags_finish */\n-};\n-\n-class pass_dse : public gimple_opt_pass\n-{\n-public:\n-  pass_dse (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_dse, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  opt_pass * clone () { return new pass_dse (m_ctxt); }\n-  virtual bool gate (function *) { return flag_tree_dse != 0; }\n-  unsigned int execute () { return tree_ssa_dse (); }\n-\n-}; // class pass_dse\n-\n } // anon namespace\n \n gimple_opt_pass *"}, {"sha": "a623005318e2842ab575e3615bfb79512c8d43b9", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -3567,15 +3567,45 @@ simplify_mult (gimple_stmt_iterator *gsi)\n /* Main entry point for the forward propagation and statement combine\n    optimizer.  */\n \n-static unsigned int\n-ssa_forward_propagate_and_combine (void)\n+namespace {\n+\n+const pass_data pass_data_forwprop =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"forwprop\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_execute */\n+  TV_TREE_FORWPROP, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_update_ssa | TODO_verify_ssa ), /* todo_flags_finish */\n+};\n+\n+class pass_forwprop : public gimple_opt_pass\n+{\n+public:\n+  pass_forwprop (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_forwprop, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_forwprop (m_ctxt); }\n+  virtual bool gate (function *) { return flag_tree_forwprop; }\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_forwprop\n+\n+unsigned int\n+pass_forwprop::execute (function *fun)\n {\n   basic_block bb;\n   unsigned int todoflags = 0;\n \n   cfg_changed = false;\n \n-  FOR_EACH_BB_FN (bb, cfun)\n+  FOR_EACH_BB_FN (bb, fun)\n     {\n       gimple_stmt_iterator gsi;\n \n@@ -3660,7 +3690,7 @@ ssa_forward_propagate_and_combine (void)\n \t  else if (TREE_CODE_CLASS (code) == tcc_comparison)\n \t    {\n \t      if (forward_propagate_comparison (&gsi))\n-\t        cfg_changed = true;\n+\t\tcfg_changed = true;\n \t    }\n \t  else\n \t    gsi_next (&gsi);\n@@ -3831,36 +3861,6 @@ ssa_forward_propagate_and_combine (void)\n   return todoflags;\n }\n \n-namespace {\n-\n-const pass_data pass_data_forwprop =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"forwprop\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  true, /* has_execute */\n-  TV_TREE_FORWPROP, /* tv_id */\n-  ( PROP_cfg | PROP_ssa ), /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  ( TODO_update_ssa | TODO_verify_ssa ), /* todo_flags_finish */\n-};\n-\n-class pass_forwprop : public gimple_opt_pass\n-{\n-public:\n-  pass_forwprop (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_forwprop, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  opt_pass * clone () { return new pass_forwprop (m_ctxt); }\n-  virtual bool gate (function *) { return flag_tree_forwprop; }\n-  unsigned int execute () { return ssa_forward_propagate_and_combine (); }\n-\n-}; // class pass_forwprop\n-\n } // anon namespace\n \n gimple_opt_pass *"}, {"sha": "0ce02a04f08cf1b9125a44a3ca473f80cc588605", "filename": "gcc/tree-ssa-ifcombine.c", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssa-ifcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssa-ifcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ifcombine.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -723,8 +723,36 @@ tree_ssa_ifcombine_bb (basic_block inner_cond_bb)\n \n /* Main entry for the tree if-conversion pass.  */\n \n-static unsigned int\n-tree_ssa_ifcombine (void)\n+namespace {\n+\n+const pass_data pass_data_tree_ifcombine =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"ifcombine\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_execute */\n+  TV_TREE_IFCOMBINE, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_update_ssa | TODO_verify_ssa ), /* todo_flags_finish */\n+};\n+\n+class pass_tree_ifcombine : public gimple_opt_pass\n+{\n+public:\n+  pass_tree_ifcombine (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_tree_ifcombine, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_tree_ifcombine\n+\n+unsigned int\n+pass_tree_ifcombine::execute (function *fun)\n {\n   basic_block *bbs;\n   bool cfg_changed = false;\n@@ -741,7 +769,7 @@ tree_ssa_ifcombine (void)\n      inner ones, and also that we do not try to visit a removed\n      block.  This is opposite of PHI-OPT, because we cascade the\n      combining rather than cascading PHIs. */\n-  for (i = n_basic_blocks_for_fn (cfun) - NUM_FIXED_BLOCKS - 1; i >= 0; i--)\n+  for (i = n_basic_blocks_for_fn (fun) - NUM_FIXED_BLOCKS - 1; i >= 0; i--)\n     {\n       basic_block bb = bbs[i];\n       gimple stmt = last_stmt (bb);\n@@ -756,34 +784,6 @@ tree_ssa_ifcombine (void)\n   return cfg_changed ? TODO_cleanup_cfg : 0;\n }\n \n-namespace {\n-\n-const pass_data pass_data_tree_ifcombine =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"ifcombine\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  true, /* has_execute */\n-  TV_TREE_IFCOMBINE, /* tv_id */\n-  ( PROP_cfg | PROP_ssa ), /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  ( TODO_update_ssa | TODO_verify_ssa ), /* todo_flags_finish */\n-};\n-\n-class pass_tree_ifcombine : public gimple_opt_pass\n-{\n-public:\n-  pass_tree_ifcombine (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_tree_ifcombine, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  unsigned int execute () { return tree_ssa_ifcombine (); }\n-\n-}; // class pass_tree_ifcombine\n-\n } // anon namespace\n \n gimple_opt_pass *"}, {"sha": "fb86de4a7b0626268e477ab4a46a953b263fe809", "filename": "gcc/tree-ssa-loop-ch.c", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssa-loop-ch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssa-loop-ch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ch.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -131,8 +131,38 @@ do_while_loop_p (struct loop *loop)\n    of the loop.  This is beneficial since it increases efficiency of\n    code motion optimizations.  It also saves one jump on entry to the loop.  */\n \n-static unsigned int\n-copy_loop_headers (void)\n+namespace {\n+\n+const pass_data pass_data_ch =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"ch\", /* name */\n+  OPTGROUP_LOOP, /* optinfo_flags */\n+  true, /* has_execute */\n+  TV_TREE_CH, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_cleanup_cfg | TODO_verify_ssa\n+    | TODO_verify_flow ), /* todo_flags_finish */\n+};\n+\n+class pass_ch : public gimple_opt_pass\n+{\n+public:\n+  pass_ch (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_ch, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *) { return flag_tree_ch != 0; }\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_ch\n+\n+unsigned int\n+pass_ch::execute (function *fun)\n {\n   struct loop *loop;\n   basic_block header;\n@@ -143,15 +173,15 @@ copy_loop_headers (void)\n \n   loop_optimizer_init (LOOPS_HAVE_PREHEADERS\n \t\t       | LOOPS_HAVE_SIMPLE_LATCHES);\n-  if (number_of_loops (cfun) <= 1)\n+  if (number_of_loops (fun) <= 1)\n     {\n       loop_optimizer_finalize ();\n       return 0;\n     }\n \n-  bbs = XNEWVEC (basic_block, n_basic_blocks_for_fn (cfun));\n-  copied_bbs = XNEWVEC (basic_block, n_basic_blocks_for_fn (cfun));\n-  bbs_size = n_basic_blocks_for_fn (cfun);\n+  bbs = XNEWVEC (basic_block, n_basic_blocks_for_fn (fun));\n+  copied_bbs = XNEWVEC (basic_block, n_basic_blocks_for_fn (fun));\n+  bbs_size = n_basic_blocks_for_fn (fun);\n \n   FOR_EACH_LOOP (loop, 0)\n     {\n@@ -257,36 +287,6 @@ copy_loop_headers (void)\n   return 0;\n }\n \n-namespace {\n-\n-const pass_data pass_data_ch =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"ch\", /* name */\n-  OPTGROUP_LOOP, /* optinfo_flags */\n-  true, /* has_execute */\n-  TV_TREE_CH, /* tv_id */\n-  ( PROP_cfg | PROP_ssa ), /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  ( TODO_cleanup_cfg | TODO_verify_ssa\n-    | TODO_verify_flow ), /* todo_flags_finish */\n-};\n-\n-class pass_ch : public gimple_opt_pass\n-{\n-public:\n-  pass_ch (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_ch, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  virtual bool gate (function *) { return flag_tree_ch != 0; }\n-  unsigned int execute () { return copy_loop_headers (); }\n-\n-}; // class pass_ch\n-\n } // anon namespace\n \n gimple_opt_pass *"}, {"sha": "0b44c977fdd534909b6d409bd1bb422118eea00d", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -2529,15 +2529,6 @@ tree_ssa_lim (void)\n \n /* Loop invariant motion pass.  */\n \n-static unsigned int\n-tree_ssa_loop_im (void)\n-{\n-  if (number_of_loops (cfun) <= 1)\n-    return 0;\n-\n-  return tree_ssa_lim ();\n-}\n-\n namespace {\n \n const pass_data pass_data_lim =\n@@ -2564,10 +2555,19 @@ class pass_lim : public gimple_opt_pass\n   /* opt_pass methods: */\n   opt_pass * clone () { return new pass_lim (m_ctxt); }\n   virtual bool gate (function *) { return flag_tree_loop_im != 0; }\n-  unsigned int execute () { return tree_ssa_loop_im (); }\n+  virtual unsigned int execute (function *);\n \n }; // class pass_lim\n \n+unsigned int\n+pass_lim::execute (function *fun)\n+{\n+  if (number_of_loops (fun) <= 1)\n+    return 0;\n+\n+  return tree_ssa_lim ();\n+}\n+\n } // anon namespace\n \n gimple_opt_pass *"}, {"sha": "54ebe25c40ded2683bae67124e8122cb061ac240", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -1256,15 +1256,6 @@ tree_unroll_loops_completely (bool may_increase_size, bool unroll_outer)\n \n /* Canonical induction variable creation pass.  */\n \n-static unsigned int\n-tree_ssa_loop_ivcanon (void)\n-{\n-  if (number_of_loops (cfun) <= 1)\n-    return 0;\n-\n-  return canonicalize_induction_variables ();\n-}\n-\n namespace {\n \n const pass_data pass_data_iv_canon =\n@@ -1290,10 +1281,19 @@ class pass_iv_canon : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *) { return flag_tree_loop_ivcanon != 0; }\n-  unsigned int execute () { return tree_ssa_loop_ivcanon (); }\n+  virtual unsigned int execute (function *fun);\n \n }; // class pass_iv_canon\n \n+unsigned int\n+pass_iv_canon::execute (function *fun)\n+{\n+  if (number_of_loops (fun) <= 1)\n+    return 0;\n+\n+  return canonicalize_induction_variables ();\n+}\n+\n } // anon namespace\n \n gimple_opt_pass *\n@@ -1304,17 +1304,6 @@ make_pass_iv_canon (gcc::context *ctxt)\n \n /* Complete unrolling of loops.  */\n \n-static unsigned int\n-tree_complete_unroll (void)\n-{\n-  if (number_of_loops (cfun) <= 1)\n-    return 0;\n-\n-  return tree_unroll_loops_completely (flag_unroll_loops\n-\t\t\t\t       || flag_peel_loops\n-\t\t\t\t       || optimize >= 3, true);\n-}\n-\n namespace {\n \n const pass_data pass_data_complete_unroll =\n@@ -1339,10 +1328,21 @@ class pass_complete_unroll : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  unsigned int execute () { return tree_complete_unroll (); }\n+  virtual unsigned int execute (function *);\n \n }; // class pass_complete_unroll\n \n+unsigned int\n+pass_complete_unroll::execute (function *fun)\n+{\n+  if (number_of_loops (fun) <= 1)\n+    return 0;\n+\n+  return tree_unroll_loops_completely (flag_unroll_loops\n+\t\t\t\t       || flag_peel_loops\n+\t\t\t\t       || optimize >= 3, true);\n+}\n+\n } // anon namespace\n \n gimple_opt_pass *\n@@ -1353,25 +1353,6 @@ make_pass_complete_unroll (gcc::context *ctxt)\n \n /* Complete unrolling of inner loops.  */\n \n-static unsigned int\n-tree_complete_unroll_inner (void)\n-{\n-  unsigned ret = 0;\n-\n-  loop_optimizer_init (LOOPS_NORMAL\n-\t\t       | LOOPS_HAVE_RECORDED_EXITS);\n-  if (number_of_loops (cfun) > 1)\n-    {\n-      scev_initialize ();\n-      ret = tree_unroll_loops_completely (optimize >= 3, false);\n-      free_numbers_of_iterations_estimates ();\n-      scev_finalize ();\n-    }\n-  loop_optimizer_finalize ();\n-\n-  return ret;\n-}\n-\n namespace {\n \n const pass_data pass_data_complete_unrolli =\n@@ -1397,10 +1378,29 @@ class pass_complete_unrolli : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *) { return optimize >= 2; }\n-  unsigned int execute () { return tree_complete_unroll_inner (); }\n+  virtual unsigned int execute (function *);\n \n }; // class pass_complete_unrolli\n \n+unsigned int\n+pass_complete_unrolli::execute (function *fun)\n+{\n+  unsigned ret = 0;\n+\n+  loop_optimizer_init (LOOPS_NORMAL\n+\t\t       | LOOPS_HAVE_RECORDED_EXITS);\n+  if (number_of_loops (fun) > 1)\n+    {\n+      scev_initialize ();\n+      ret = tree_unroll_loops_completely (optimize >= 3, false);\n+      free_numbers_of_iterations_estimates ();\n+      scev_finalize ();\n+    }\n+  loop_optimizer_finalize ();\n+\n+  return ret;\n+}\n+\n } // anon namespace\n \n gimple_opt_pass *"}, {"sha": "1cf650a71e0b191a00c642dd9e0534ca40d6b818", "filename": "gcc/tree-ssa-loop-prefetch.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssa-loop-prefetch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssa-loop-prefetch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-prefetch.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -2004,15 +2004,6 @@ tree_ssa_prefetch_arrays (void)\n \n /* Prefetching.  */\n \n-static unsigned int\n-tree_ssa_loop_prefetch (void)\n-{\n-  if (number_of_loops (cfun) <= 1)\n-    return 0;\n-\n-  return tree_ssa_prefetch_arrays ();\n-}\n-\n namespace {\n \n const pass_data pass_data_loop_prefetch =\n@@ -2038,10 +2029,19 @@ class pass_loop_prefetch : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *) { return flag_prefetch_loop_arrays > 0; }\n-  unsigned int execute () { return tree_ssa_loop_prefetch (); }\n+  virtual unsigned int execute (function *);\n \n }; // class pass_loop_prefetch\n \n+unsigned int\n+pass_loop_prefetch::execute (function *fun)\n+{\n+  if (number_of_loops (fun) <= 1)\n+    return 0;\n+\n+  return tree_ssa_prefetch_arrays ();\n+}\n+\n } // anon namespace\n \n gimple_opt_pass *"}, {"sha": "a9a27d7e70837b01d16d2c1c3761d1567c86e55e", "filename": "gcc/tree-ssa-loop-unswitch.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssa-loop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssa-loop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-unswitch.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -402,15 +402,6 @@ tree_unswitch_loop (struct loop *loop,\n \n /* Loop unswitching pass.  */\n \n-static unsigned int\n-tree_ssa_loop_unswitch (void)\n-{\n-  if (number_of_loops (cfun) <= 1)\n-    return 0;\n-\n-  return tree_ssa_unswitch_loops ();\n-}\n-\n namespace {\n \n const pass_data pass_data_tree_unswitch =\n@@ -436,10 +427,19 @@ class pass_tree_unswitch : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *) { return flag_unswitch_loops != 0; }\n-  unsigned int execute () { return tree_ssa_loop_unswitch (); }\n+  virtual unsigned int execute (function *);\n \n }; // class pass_tree_unswitch\n \n+unsigned int\n+pass_tree_unswitch::execute (function *fun)\n+{\n+  if (number_of_loops (fun) <= 1)\n+    return 0;\n+\n+  return tree_ssa_unswitch_loops ();\n+}\n+\n } // anon namespace\n \n gimple_opt_pass *"}, {"sha": "ccc812152cfcb5b98c649a17a7d8e8f0aad5a8aa", "filename": "gcc/tree-ssa-loop.c", "status": "modified", "additions": 64, "deletions": 64, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssa-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssa-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -82,23 +82,6 @@ make_pass_tree_loop (gcc::context *ctxt)\n \n /* Loop optimizer initialization.  */\n \n-static unsigned int\n-tree_ssa_loop_init (void)\n-{\n-  loop_optimizer_init (LOOPS_NORMAL\n-\t\t       | LOOPS_HAVE_RECORDED_EXITS);\n-  rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa);\n-\n-  /* We might discover new loops, e.g. when turning irreducible\n-     regions into reducible.  */\n-  scev_initialize ();\n-\n-  if (number_of_loops (cfun) <= 1)\n-    return 0;\n-\n-  return 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_tree_loop_init =\n@@ -123,10 +106,27 @@ class pass_tree_loop_init : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  unsigned int execute () { return tree_ssa_loop_init (); }\n+  virtual unsigned int execute (function *);\n \n }; // class pass_tree_loop_init\n \n+unsigned int\n+pass_tree_loop_init::execute (function *fun)\n+{\n+  loop_optimizer_init (LOOPS_NORMAL\n+\t\t       | LOOPS_HAVE_RECORDED_EXITS);\n+  rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa);\n+\n+  /* We might discover new loops, e.g. when turning irreducible\n+     regions into reducible.  */\n+  scev_initialize ();\n+\n+  if (number_of_loops (fun) <= 1)\n+    return 0;\n+\n+  return 0;\n+}\n+\n } // anon namespace\n \n gimple_opt_pass *\n@@ -137,15 +137,6 @@ make_pass_tree_loop_init (gcc::context *ctxt)\n \n /* Loop autovectorization.  */\n \n-static unsigned int\n-tree_loop_vectorize (void)\n-{\n-  if (number_of_loops (cfun) <= 1)\n-    return 0;\n-\n-  return vectorize_loops ();\n-}\n-\n namespace {\n \n const pass_data pass_data_vectorize =\n@@ -175,10 +166,19 @@ class pass_vectorize : public gimple_opt_pass\n       return flag_tree_loop_vectorize || fun->has_force_vectorize_loops;\n     }\n \n-  unsigned int execute () { return tree_loop_vectorize (); }\n+  virtual unsigned int execute (function *);\n \n }; // class pass_vectorize\n \n+unsigned int\n+pass_vectorize::execute (function *fun)\n+{\n+  if (number_of_loops (fun) <= 1)\n+    return 0;\n+\n+  return vectorize_loops ();\n+}\n+\n } // anon namespace\n \n gimple_opt_pass *\n@@ -189,16 +189,6 @@ make_pass_vectorize (gcc::context *ctxt)\n \n /* Check the correctness of the data dependence analyzers.  */\n \n-static unsigned int\n-check_data_deps (void)\n-{\n-  if (number_of_loops (cfun) <= 1)\n-    return 0;\n-\n-  tree_check_data_deps ();\n-  return 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_check_data_deps =\n@@ -224,10 +214,20 @@ class pass_check_data_deps : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *) { return flag_check_data_deps != 0; }\n-  unsigned int execute () { return check_data_deps (); }\n+  virtual unsigned int execute (function *);\n \n }; // class pass_check_data_deps\n \n+unsigned int\n+pass_check_data_deps::execute (function *fun)\n+{\n+  if (number_of_loops (fun) <= 1)\n+    return 0;\n+\n+  tree_check_data_deps ();\n+  return 0;\n+}\n+\n } // anon namespace\n \n gimple_opt_pass *\n@@ -264,7 +264,7 @@ class pass_scev_cprop : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *) { return flag_tree_scev_cprop; }\n-  unsigned int execute () { return scev_const_prop (); }\n+  virtual unsigned int execute (function *) { return scev_const_prop (); }\n \n }; // class pass_scev_cprop\n \n@@ -278,17 +278,6 @@ make_pass_scev_cprop (gcc::context *ctxt)\n \n /* Record bounds on numbers of iterations of loops.  */\n \n-static unsigned int\n-tree_ssa_loop_bounds (void)\n-{\n-  if (number_of_loops (cfun) <= 1)\n-    return 0;\n-\n-  estimate_numbers_of_iterations ();\n-  scev_reset ();\n-  return 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_record_bounds =\n@@ -313,10 +302,21 @@ class pass_record_bounds : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  unsigned int execute () { return tree_ssa_loop_bounds (); }\n+  virtual unsigned int execute (function *);\n \n }; // class pass_record_bounds\n \n+unsigned int\n+pass_record_bounds::execute (function *fun)\n+{\n+  if (number_of_loops (fun) <= 1)\n+    return 0;\n+\n+  estimate_numbers_of_iterations ();\n+  scev_reset ();\n+  return 0;\n+}\n+\n } // anon namespace\n \n gimple_opt_pass *\n@@ -327,16 +327,6 @@ make_pass_record_bounds (gcc::context *ctxt)\n \n /* Induction variable optimizations.  */\n \n-static unsigned int\n-tree_ssa_loop_ivopts (void)\n-{\n-  if (number_of_loops (cfun) <= 1)\n-    return 0;\n-\n-  tree_ssa_iv_optimize ();\n-  return 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_iv_optimize =\n@@ -362,10 +352,20 @@ class pass_iv_optimize : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *) { return flag_ivopts != 0; }\n-  unsigned int execute () { return tree_ssa_loop_ivopts (); }\n+  virtual unsigned int execute (function *);\n \n }; // class pass_iv_optimize\n \n+unsigned int\n+pass_iv_optimize::execute (function *fun)\n+{\n+  if (number_of_loops (fun) <= 1)\n+    return 0;\n+\n+  tree_ssa_iv_optimize ();\n+  return 0;\n+}\n+\n } // anon namespace\n \n gimple_opt_pass *\n@@ -409,7 +409,7 @@ class pass_tree_loop_done : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  unsigned int execute () { return tree_ssa_loop_done (); }\n+  virtual unsigned int execute (function *) { return tree_ssa_loop_done (); }\n \n }; // class pass_tree_loop_done\n "}, {"sha": "b965ad1b7f36cf84275629a4b7bc1a2397ef11f2", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 158, "deletions": 158, "changes": 316, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -506,35 +506,65 @@ execute_cse_reciprocals_1 (gimple_stmt_iterator *def_gsi, tree def)\n \n /* Go through all the floating-point SSA_NAMEs, and call\n    execute_cse_reciprocals_1 on each of them.  */\n-static unsigned int\n-execute_cse_reciprocals (void)\n+namespace {\n+\n+const pass_data pass_data_cse_reciprocals =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"recip\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  PROP_ssa, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_update_ssa | TODO_verify_ssa\n+    | TODO_verify_stmts ), /* todo_flags_finish */\n+};\n+\n+class pass_cse_reciprocals : public gimple_opt_pass\n+{\n+public:\n+  pass_cse_reciprocals (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_cse_reciprocals, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *) { return optimize && flag_reciprocal_math; }\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_cse_reciprocals\n+\n+unsigned int\n+pass_cse_reciprocals::execute (function *fun)\n {\n   basic_block bb;\n   tree arg;\n \n   occ_pool = create_alloc_pool (\"dominators for recip\",\n \t\t\t\tsizeof (struct occurrence),\n-\t\t\t\tn_basic_blocks_for_fn (cfun) / 3 + 1);\n+\t\t\t\tn_basic_blocks_for_fn (fun) / 3 + 1);\n \n   memset (&reciprocal_stats, 0, sizeof (reciprocal_stats));\n   calculate_dominance_info (CDI_DOMINATORS);\n   calculate_dominance_info (CDI_POST_DOMINATORS);\n \n #ifdef ENABLE_CHECKING\n-  FOR_EACH_BB_FN (bb, cfun)\n+  FOR_EACH_BB_FN (bb, fun)\n     gcc_assert (!bb->aux);\n #endif\n \n-  for (arg = DECL_ARGUMENTS (cfun->decl); arg; arg = DECL_CHAIN (arg))\n+  for (arg = DECL_ARGUMENTS (fun->decl); arg; arg = DECL_CHAIN (arg))\n     if (FLOAT_TYPE_P (TREE_TYPE (arg))\n \t&& is_gimple_reg (arg))\n       {\n-\ttree name = ssa_default_def (cfun, arg);\n+\ttree name = ssa_default_def (fun, arg);\n \tif (name)\n \t  execute_cse_reciprocals_1 (NULL, name);\n       }\n \n-  FOR_EACH_BB_FN (bb, cfun)\n+  FOR_EACH_BB_FN (bb, fun)\n     {\n       gimple_stmt_iterator gsi;\n       gimple phi;\n@@ -636,9 +666,9 @@ execute_cse_reciprocals (void)\n \t}\n     }\n \n-  statistics_counter_event (cfun, \"reciprocal divs inserted\",\n+  statistics_counter_event (fun, \"reciprocal divs inserted\",\n \t\t\t    reciprocal_stats.rdivs_inserted);\n-  statistics_counter_event (cfun, \"reciprocal functions inserted\",\n+  statistics_counter_event (fun, \"reciprocal functions inserted\",\n \t\t\t    reciprocal_stats.rfuncs_inserted);\n \n   free_dominance_info (CDI_DOMINATORS);\n@@ -647,36 +677,6 @@ execute_cse_reciprocals (void)\n   return 0;\n }\n \n-namespace {\n-\n-const pass_data pass_data_cse_reciprocals =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"recip\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  true, /* has_execute */\n-  TV_NONE, /* tv_id */\n-  PROP_ssa, /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  ( TODO_update_ssa | TODO_verify_ssa\n-    | TODO_verify_stmts ), /* todo_flags_finish */\n-};\n-\n-class pass_cse_reciprocals : public gimple_opt_pass\n-{\n-public:\n-  pass_cse_reciprocals (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_cse_reciprocals, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  virtual bool gate (function *) { return optimize && flag_reciprocal_math; }\n-  unsigned int execute () { return execute_cse_reciprocals (); }\n-\n-}; // class pass_cse_reciprocals\n-\n } // anon namespace\n \n gimple_opt_pass *\n@@ -1403,16 +1403,52 @@ gimple_expand_builtin_cabs (gimple_stmt_iterator *gsi, location_t loc, tree arg)\n    on the SSA_NAME argument of each of them.  Also expand powi(x,n) into\n    an optimal number of multiplies, when n is a constant.  */\n \n-static unsigned int\n-execute_cse_sincos (void)\n+namespace {\n+\n+const pass_data pass_data_cse_sincos =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"sincos\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  PROP_ssa, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_update_ssa | TODO_verify_ssa\n+    | TODO_verify_stmts ), /* todo_flags_finish */\n+};\n+\n+class pass_cse_sincos : public gimple_opt_pass\n+{\n+public:\n+  pass_cse_sincos (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_cse_sincos, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *)\n+    {\n+      /* We no longer require either sincos or cexp, since powi expansion\n+\t piggybacks on this pass.  */\n+      return optimize;\n+    }\n+\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_cse_sincos\n+\n+unsigned int\n+pass_cse_sincos::execute (function *fun)\n {\n   basic_block bb;\n   bool cfg_changed = false;\n \n   calculate_dominance_info (CDI_DOMINATORS);\n   memset (&sincos_stats, 0, sizeof (sincos_stats));\n \n-  FOR_EACH_BB_FN (bb, cfun)\n+  FOR_EACH_BB_FN (bb, fun)\n     {\n       gimple_stmt_iterator gsi;\n       bool cleanup_eh = false;\n@@ -1549,49 +1585,13 @@ execute_cse_sincos (void)\n \tcfg_changed |= gimple_purge_dead_eh_edges (bb);\n     }\n \n-  statistics_counter_event (cfun, \"sincos statements inserted\",\n+  statistics_counter_event (fun, \"sincos statements inserted\",\n \t\t\t    sincos_stats.inserted);\n \n   free_dominance_info (CDI_DOMINATORS);\n   return cfg_changed ? TODO_cleanup_cfg : 0;\n }\n \n-namespace {\n-\n-const pass_data pass_data_cse_sincos =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"sincos\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  true, /* has_execute */\n-  TV_NONE, /* tv_id */\n-  PROP_ssa, /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  ( TODO_update_ssa | TODO_verify_ssa\n-    | TODO_verify_stmts ), /* todo_flags_finish */\n-};\n-\n-class pass_cse_sincos : public gimple_opt_pass\n-{\n-public:\n-  pass_cse_sincos (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_cse_sincos, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  virtual bool gate (function *)\n-    {\n-      /* We no longer require either sincos or cexp, since powi expansion\n-\t piggybacks on this pass.  */\n-      return optimize;\n-    }\n-\n-  unsigned int execute () { return execute_cse_sincos (); }\n-\n-}; // class pass_cse_sincos\n-\n } // anon namespace\n \n gimple_opt_pass *\n@@ -1893,8 +1893,41 @@ find_bswap (gimple stmt)\n /* Find manual byte swap implementations and turn them into a bswap\n    builtin invokation.  */\n \n-static unsigned int\n-execute_optimize_bswap (void)\n+namespace {\n+\n+const pass_data pass_data_optimize_bswap =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"bswap\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  PROP_ssa, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_optimize_bswap : public gimple_opt_pass\n+{\n+public:\n+  pass_optimize_bswap (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_optimize_bswap, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *)\n+    {\n+      return flag_expensive_optimizations && optimize;\n+    }\n+\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_optimize_bswap\n+\n+unsigned int\n+pass_optimize_bswap::execute (function *fun)\n {\n   basic_block bb;\n   bool bswap16_p, bswap32_p, bswap64_p;\n@@ -1940,7 +1973,7 @@ execute_optimize_bswap (void)\n \n   memset (&bswap_stats, 0, sizeof (bswap_stats));\n \n-  FOR_EACH_BB_FN (bb, cfun)\n+  FOR_EACH_BB_FN (bb, fun)\n     {\n       gimple_stmt_iterator gsi;\n \n@@ -2046,50 +2079,17 @@ execute_optimize_bswap (void)\n \t}\n     }\n \n-  statistics_counter_event (cfun, \"16-bit bswap implementations found\",\n+  statistics_counter_event (fun, \"16-bit bswap implementations found\",\n \t\t\t    bswap_stats.found_16bit);\n-  statistics_counter_event (cfun, \"32-bit bswap implementations found\",\n+  statistics_counter_event (fun, \"32-bit bswap implementations found\",\n \t\t\t    bswap_stats.found_32bit);\n-  statistics_counter_event (cfun, \"64-bit bswap implementations found\",\n+  statistics_counter_event (fun, \"64-bit bswap implementations found\",\n \t\t\t    bswap_stats.found_64bit);\n \n   return (changed ? TODO_update_ssa | TODO_verify_ssa\n \t  | TODO_verify_stmts : 0);\n }\n \n-namespace {\n-\n-const pass_data pass_data_optimize_bswap =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"bswap\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  true, /* has_execute */\n-  TV_NONE, /* tv_id */\n-  PROP_ssa, /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  0, /* todo_flags_finish */\n-};\n-\n-class pass_optimize_bswap : public gimple_opt_pass\n-{\n-public:\n-  pass_optimize_bswap (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_optimize_bswap, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  virtual bool gate (function *)\n-    {\n-      return flag_expensive_optimizations && optimize;\n-    }\n-\n-  unsigned int execute () { return execute_optimize_bswap (); }\n-\n-}; // class pass_optimize_bswap\n-\n } // anon namespace\n \n gimple_opt_pass *\n@@ -2775,15 +2775,49 @@ convert_mult_to_fma (gimple mul_stmt, tree op1, tree op2)\n    smaller types, and replace the MULT_EXPR with a WIDEN_MULT_EXPR\n    where appropriate.  */\n \n-static unsigned int\n-execute_optimize_widening_mul (void)\n+namespace {\n+\n+const pass_data pass_data_optimize_widening_mul =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"widening_mul\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  PROP_ssa, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_verify_ssa | TODO_verify_stmts\n+    | TODO_update_ssa ), /* todo_flags_finish */\n+};\n+\n+class pass_optimize_widening_mul : public gimple_opt_pass\n+{\n+public:\n+  pass_optimize_widening_mul (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_optimize_widening_mul, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *)\n+    {\n+      return flag_expensive_optimizations && optimize;\n+    }\n+\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_optimize_widening_mul\n+\n+unsigned int\n+pass_optimize_widening_mul::execute (function *fun)\n {\n   basic_block bb;\n   bool cfg_changed = false;\n \n   memset (&widen_mul_stats, 0, sizeof (widen_mul_stats));\n \n-  FOR_EACH_BB_FN (bb, cfun)\n+  FOR_EACH_BB_FN (bb, fun)\n     {\n       gimple_stmt_iterator gsi;\n \n@@ -2854,50 +2888,16 @@ execute_optimize_widening_mul (void)\n \t}\n     }\n \n-  statistics_counter_event (cfun, \"widening multiplications inserted\",\n+  statistics_counter_event (fun, \"widening multiplications inserted\",\n \t\t\t    widen_mul_stats.widen_mults_inserted);\n-  statistics_counter_event (cfun, \"widening maccs inserted\",\n+  statistics_counter_event (fun, \"widening maccs inserted\",\n \t\t\t    widen_mul_stats.maccs_inserted);\n-  statistics_counter_event (cfun, \"fused multiply-adds inserted\",\n+  statistics_counter_event (fun, \"fused multiply-adds inserted\",\n \t\t\t    widen_mul_stats.fmas_inserted);\n \n   return cfg_changed ? TODO_cleanup_cfg : 0;\n }\n \n-namespace {\n-\n-const pass_data pass_data_optimize_widening_mul =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"widening_mul\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  true, /* has_execute */\n-  TV_NONE, /* tv_id */\n-  PROP_ssa, /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  ( TODO_verify_ssa | TODO_verify_stmts\n-    | TODO_update_ssa ), /* todo_flags_finish */\n-};\n-\n-class pass_optimize_widening_mul : public gimple_opt_pass\n-{\n-public:\n-  pass_optimize_widening_mul (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_optimize_widening_mul, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  virtual bool gate (function *)\n-    {\n-      return flag_expensive_optimizations && optimize;\n-    }\n-\n-  unsigned int execute () { return execute_optimize_widening_mul (); }\n-\n-}; // class pass_optimize_widening_mul\n-\n } // anon namespace\n \n gimple_opt_pass *"}, {"sha": "9b5b563886dbde959fe978ad58bebb1d0ec24116", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 154, "deletions": 161, "changes": 315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -59,7 +59,6 @@ along with GCC; see the file COPYING3.  If not see\n #define HAVE_conditional_move (0)\n #endif\n \n-static unsigned int tree_ssa_phiopt (void);\n static unsigned int tree_ssa_phiopt_worker (bool, bool);\n static bool conditional_replacement (basic_block, basic_block,\n \t\t\t\t     edge, edge, gimple, tree, tree);\n@@ -80,162 +79,6 @@ static void hoist_adjacent_loads (basic_block, basic_block,\n \t\t\t\t  basic_block, basic_block);\n static bool gate_hoist_loads (void);\n \n-/* This pass tries to replaces an if-then-else block with an\n-   assignment.  We have four kinds of transformations.  Some of these\n-   transformations are also performed by the ifcvt RTL optimizer.\n-\n-   Conditional Replacement\n-   -----------------------\n-\n-   This transformation, implemented in conditional_replacement,\n-   replaces\n-\n-     bb0:\n-      if (cond) goto bb2; else goto bb1;\n-     bb1:\n-     bb2:\n-      x = PHI <0 (bb1), 1 (bb0), ...>;\n-\n-   with\n-\n-     bb0:\n-      x' = cond;\n-      goto bb2;\n-     bb2:\n-      x = PHI <x' (bb0), ...>;\n-\n-   We remove bb1 as it becomes unreachable.  This occurs often due to\n-   gimplification of conditionals.\n-\n-   Value Replacement\n-   -----------------\n-\n-   This transformation, implemented in value_replacement, replaces\n-\n-     bb0:\n-       if (a != b) goto bb2; else goto bb1;\n-     bb1:\n-     bb2:\n-       x = PHI <a (bb1), b (bb0), ...>;\n-\n-   with\n-\n-     bb0:\n-     bb2:\n-       x = PHI <b (bb0), ...>;\n-\n-   This opportunity can sometimes occur as a result of other\n-   optimizations.\n-\n-\n-   Another case caught by value replacement looks like this:\n-\n-     bb0:\n-       t1 = a == CONST;\n-       t2 = b > c;\n-       t3 = t1 & t2;\n-       if (t3 != 0) goto bb1; else goto bb2;\n-     bb1:\n-     bb2:\n-       x = PHI (CONST, a)\n-\n-   Gets replaced with:\n-     bb0:\n-     bb2:\n-       t1 = a == CONST;\n-       t2 = b > c;\n-       t3 = t1 & t2;\n-       x = a;\n-\n-   ABS Replacement\n-   ---------------\n-\n-   This transformation, implemented in abs_replacement, replaces\n-\n-     bb0:\n-       if (a >= 0) goto bb2; else goto bb1;\n-     bb1:\n-       x = -a;\n-     bb2:\n-       x = PHI <x (bb1), a (bb0), ...>;\n-\n-   with\n-\n-     bb0:\n-       x' = ABS_EXPR< a >;\n-     bb2:\n-       x = PHI <x' (bb0), ...>;\n-\n-   MIN/MAX Replacement\n-   -------------------\n-\n-   This transformation, minmax_replacement replaces\n-\n-     bb0:\n-       if (a <= b) goto bb2; else goto bb1;\n-     bb1:\n-     bb2:\n-       x = PHI <b (bb1), a (bb0), ...>;\n-\n-   with\n-\n-     bb0:\n-       x' = MIN_EXPR (a, b)\n-     bb2:\n-       x = PHI <x' (bb0), ...>;\n-\n-   A similar transformation is done for MAX_EXPR.\n-\n-\n-   This pass also performs a fifth transformation of a slightly different\n-   flavor.\n-\n-   Adjacent Load Hoisting\n-   ----------------------\n-\n-   This transformation replaces\n-\n-     bb0:\n-       if (...) goto bb2; else goto bb1;\n-     bb1:\n-       x1 = (<expr>).field1;\n-       goto bb3;\n-     bb2:\n-       x2 = (<expr>).field2;\n-     bb3:\n-       # x = PHI <x1, x2>;\n-\n-   with\n-\n-     bb0:\n-       x1 = (<expr>).field1;\n-       x2 = (<expr>).field2;\n-       if (...) goto bb2; else goto bb1;\n-     bb1:\n-       goto bb3;\n-     bb2:\n-     bb3:\n-       # x = PHI <x1, x2>;\n-\n-   The purpose of this transformation is to enable generation of conditional\n-   move instructions such as Intel CMOVE or PowerPC ISEL.  Because one of\n-   the loads is speculative, the transformation is restricted to very\n-   specific cases to avoid introducing a page fault.  We are looking for\n-   the common idiom:\n-\n-     if (...)\n-       x = y->left;\n-     else\n-       x = y->right;\n-\n-   where left and right are typically adjacent pointers in a tree structure.  */\n-\n-static unsigned int\n-tree_ssa_phiopt (void)\n-{\n-  return tree_ssa_phiopt_worker (false, gate_hoist_loads ());\n-}\n-\n /* This pass tries to transform conditional stores into unconditional\n    ones, enabling further simplifications with the simpler then and else\n    blocks.  In particular it replaces this:\n@@ -2200,8 +2043,155 @@ gate_hoist_loads (void)\n \t  && HAVE_conditional_move);\n }\n \n-/* Always do these optimizations if we have SSA\n-   trees to work on.  */\n+/* This pass tries to replaces an if-then-else block with an\n+   assignment.  We have four kinds of transformations.  Some of these\n+   transformations are also performed by the ifcvt RTL optimizer.\n+\n+   Conditional Replacement\n+   -----------------------\n+\n+   This transformation, implemented in conditional_replacement,\n+   replaces\n+\n+     bb0:\n+      if (cond) goto bb2; else goto bb1;\n+     bb1:\n+     bb2:\n+      x = PHI <0 (bb1), 1 (bb0), ...>;\n+\n+   with\n+\n+     bb0:\n+      x' = cond;\n+      goto bb2;\n+     bb2:\n+      x = PHI <x' (bb0), ...>;\n+\n+   We remove bb1 as it becomes unreachable.  This occurs often due to\n+   gimplification of conditionals.\n+\n+   Value Replacement\n+   -----------------\n+\n+   This transformation, implemented in value_replacement, replaces\n+\n+     bb0:\n+       if (a != b) goto bb2; else goto bb1;\n+     bb1:\n+     bb2:\n+       x = PHI <a (bb1), b (bb0), ...>;\n+\n+   with\n+\n+     bb0:\n+     bb2:\n+       x = PHI <b (bb0), ...>;\n+\n+   This opportunity can sometimes occur as a result of other\n+   optimizations.\n+\n+\n+   Another case caught by value replacement looks like this:\n+\n+     bb0:\n+       t1 = a == CONST;\n+       t2 = b > c;\n+       t3 = t1 & t2;\n+       if (t3 != 0) goto bb1; else goto bb2;\n+     bb1:\n+     bb2:\n+       x = PHI (CONST, a)\n+\n+   Gets replaced with:\n+     bb0:\n+     bb2:\n+       t1 = a == CONST;\n+       t2 = b > c;\n+       t3 = t1 & t2;\n+       x = a;\n+\n+   ABS Replacement\n+   ---------------\n+\n+   This transformation, implemented in abs_replacement, replaces\n+\n+     bb0:\n+       if (a >= 0) goto bb2; else goto bb1;\n+     bb1:\n+       x = -a;\n+     bb2:\n+       x = PHI <x (bb1), a (bb0), ...>;\n+\n+   with\n+\n+     bb0:\n+       x' = ABS_EXPR< a >;\n+     bb2:\n+       x = PHI <x' (bb0), ...>;\n+\n+   MIN/MAX Replacement\n+   -------------------\n+\n+   This transformation, minmax_replacement replaces\n+\n+     bb0:\n+       if (a <= b) goto bb2; else goto bb1;\n+     bb1:\n+     bb2:\n+       x = PHI <b (bb1), a (bb0), ...>;\n+\n+   with\n+\n+     bb0:\n+       x' = MIN_EXPR (a, b)\n+     bb2:\n+       x = PHI <x' (bb0), ...>;\n+\n+   A similar transformation is done for MAX_EXPR.\n+\n+\n+   This pass also performs a fifth transformation of a slightly different\n+   flavor.\n+\n+   Adjacent Load Hoisting\n+   ----------------------\n+\n+   This transformation replaces\n+\n+     bb0:\n+       if (...) goto bb2; else goto bb1;\n+     bb1:\n+       x1 = (<expr>).field1;\n+       goto bb3;\n+     bb2:\n+       x2 = (<expr>).field2;\n+     bb3:\n+       # x = PHI <x1, x2>;\n+\n+   with\n+\n+     bb0:\n+       x1 = (<expr>).field1;\n+       x2 = (<expr>).field2;\n+       if (...) goto bb2; else goto bb1;\n+     bb1:\n+       goto bb3;\n+     bb2:\n+     bb3:\n+       # x = PHI <x1, x2>;\n+\n+   The purpose of this transformation is to enable generation of conditional\n+   move instructions such as Intel CMOVE or PowerPC ISEL.  Because one of\n+   the loads is speculative, the transformation is restricted to very\n+   specific cases to avoid introducing a page fault.  We are looking for\n+   the common idiom:\n+\n+     if (...)\n+       x = y->left;\n+     else\n+       x = y->right;\n+\n+   where left and right are typically adjacent pointers in a tree structure.  */\n \n namespace {\n \n@@ -2229,7 +2219,10 @@ class pass_phiopt : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   opt_pass * clone () { return new pass_phiopt (m_ctxt); }\n-  unsigned int execute () { return tree_ssa_phiopt (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      return tree_ssa_phiopt_worker (false, gate_hoist_loads ());\n+    }\n \n }; // class pass_phiopt\n \n@@ -2267,7 +2260,7 @@ class pass_cselim : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *) { return flag_tree_cselim; }\n-  unsigned int execute () { return tree_ssa_cs_elim (); }\n+  virtual unsigned int execute (function *) { return tree_ssa_cs_elim (); }\n \n }; // class pass_cselim\n "}, {"sha": "0154b47af7424eacbe763bf9c99bdfc59be95605", "filename": "gcc/tree-ssa-phiprop.c", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssa-phiprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssa-phiprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiprop.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -374,8 +374,37 @@ next:;\n \n /* Main entry for phiprop pass.  */\n \n-static unsigned int\n-tree_ssa_phiprop (void)\n+namespace {\n+\n+const pass_data pass_data_phiprop =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"phiprop\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_execute */\n+  TV_TREE_PHIPROP, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_update_ssa | TODO_verify_ssa ), /* todo_flags_finish */\n+};\n+\n+class pass_phiprop : public gimple_opt_pass\n+{\n+public:\n+  pass_phiprop (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_phiprop, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *) { return flag_tree_phiprop; }\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_phiprop\n+\n+unsigned int\n+pass_phiprop::execute (function *fun)\n {\n   vec<basic_block> bbs;\n   struct phiprop_d *phivn;\n@@ -393,7 +422,7 @@ tree_ssa_phiprop (void)\n \n   /* Walk the dominator tree in preorder.  */\n   bbs = get_all_dominated_blocks (CDI_DOMINATORS,\n-\t\t\t\t  single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun)));\n+\t\t\t\t  single_succ (ENTRY_BLOCK_PTR_FOR_FN (fun)));\n   FOR_EACH_VEC_ELT (bbs, i, bb)\n     for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n       did_something |= propagate_with_phi (bb, gsi_stmt (gsi), phivn, n);\n@@ -409,35 +438,6 @@ tree_ssa_phiprop (void)\n   return 0;\n }\n \n-namespace {\n-\n-const pass_data pass_data_phiprop =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"phiprop\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  true, /* has_execute */\n-  TV_TREE_PHIPROP, /* tv_id */\n-  ( PROP_cfg | PROP_ssa ), /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  ( TODO_update_ssa | TODO_verify_ssa ), /* todo_flags_finish */\n-};\n-\n-class pass_phiprop : public gimple_opt_pass\n-{\n-public:\n-  pass_phiprop (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_phiprop, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  virtual bool gate (function *) { return flag_tree_phiprop; }\n-  unsigned int execute () { return tree_ssa_phiprop (); }\n-\n-}; // class pass_phiprop\n-\n } // anon namespace\n \n gimple_opt_pass *"}, {"sha": "b5785d88c5440f439cc77841394fd8f882814c72", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 62, "deletions": 67, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -4690,15 +4690,44 @@ fini_pre ()\n   free_dominance_info (CDI_POST_DOMINATORS);\n }\n \n-/* Gate and execute functions for PRE.  */\n+namespace {\n \n-static unsigned int\n-do_pre (void)\n+const pass_data pass_data_pre =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"pre\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_execute */\n+  TV_TREE_PRE, /* tv_id */\n+  /* PROP_no_crit_edges is ensured by placing pass_split_crit_edges before\n+     pass_pre.  */\n+  ( PROP_no_crit_edges | PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  PROP_no_crit_edges, /* properties_destroyed */\n+  TODO_rebuild_alias, /* todo_flags_start */\n+  TODO_verify_ssa, /* todo_flags_finish */\n+};\n+\n+class pass_pre : public gimple_opt_pass\n+{\n+public:\n+  pass_pre (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_pre, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *) { return flag_tree_pre != 0; }\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_pre\n+\n+unsigned int\n+pass_pre::execute (function *fun)\n {\n   unsigned int todo = 0;\n \n   do_partial_partial =\n-    flag_tree_partial_pre && optimize_function_for_speed_p (cfun);\n+    flag_tree_partial_pre && optimize_function_for_speed_p (fun);\n \n   /* This has to happen before SCCVN runs because\n      loop_optimizer_init may create new phis, etc.  */\n@@ -4721,7 +4750,7 @@ do_pre (void)\n      fixed, don't run it when he have an incredibly large number of\n      bb's.  If we aren't going to run insert, there is no point in\n      computing ANTIC, either, even though it's plenty fast.  */\n-  if (n_basic_blocks_for_fn (cfun) < 4000)\n+  if (n_basic_blocks_for_fn (fun) < 4000)\n     {\n       compute_antic ();\n       insert ();\n@@ -4736,10 +4765,10 @@ do_pre (void)\n   /* Remove all the redundant expressions.  */\n   todo |= eliminate ();\n \n-  statistics_counter_event (cfun, \"Insertions\", pre_stats.insertions);\n-  statistics_counter_event (cfun, \"PA inserted\", pre_stats.pa_insert);\n-  statistics_counter_event (cfun, \"New PHIs\", pre_stats.phis);\n-  statistics_counter_event (cfun, \"Eliminated\", pre_stats.eliminations);\n+  statistics_counter_event (fun, \"Insertions\", pre_stats.insertions);\n+  statistics_counter_event (fun, \"PA inserted\", pre_stats.pa_insert);\n+  statistics_counter_event (fun, \"New PHIs\", pre_stats.phis);\n+  statistics_counter_event (fun, \"Eliminated\", pre_stats.eliminations);\n \n   clear_expression_ids ();\n   remove_dead_inserted_code ();\n@@ -4771,37 +4800,6 @@ do_pre (void)\n   return todo;\n }\n \n-namespace {\n-\n-const pass_data pass_data_pre =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"pre\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  true, /* has_execute */\n-  TV_TREE_PRE, /* tv_id */\n-  /* PROP_no_crit_edges is ensured by placing pass_split_crit_edges before\n-     pass_pre.  */\n-  ( PROP_no_crit_edges | PROP_cfg | PROP_ssa ), /* properties_required */\n-  0, /* properties_provided */\n-  PROP_no_crit_edges, /* properties_destroyed */\n-  TODO_rebuild_alias, /* todo_flags_start */\n-  TODO_verify_ssa, /* todo_flags_finish */\n-};\n-\n-class pass_pre : public gimple_opt_pass\n-{\n-public:\n-  pass_pre (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_pre, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  virtual bool gate (function *) { return flag_tree_pre != 0; }\n-  unsigned int execute () { return do_pre (); }\n-\n-}; // class pass_pre\n-\n } // anon namespace\n \n gimple_opt_pass *\n@@ -4810,32 +4808,6 @@ make_pass_pre (gcc::context *ctxt)\n   return new pass_pre (ctxt);\n }\n \n-\n-/* Gate and execute functions for FRE.  */\n-\n-static unsigned int\n-execute_fre (void)\n-{\n-  unsigned int todo = 0;\n-\n-  if (!run_scc_vn (VN_WALKREWRITE))\n-    return 0;\n-\n-  memset (&pre_stats, 0, sizeof (pre_stats));\n-\n-  /* Remove all the redundant expressions.  */\n-  todo |= eliminate ();\n-\n-  todo |= fini_eliminate ();\n-\n-  free_scc_vn ();\n-\n-  statistics_counter_event (cfun, \"Insertions\", pre_stats.insertions);\n-  statistics_counter_event (cfun, \"Eliminated\", pre_stats.eliminations);\n-\n-  return todo;\n-}\n-\n namespace {\n \n const pass_data pass_data_fre =\n@@ -4862,10 +4834,33 @@ class pass_fre : public gimple_opt_pass\n   /* opt_pass methods: */\n   opt_pass * clone () { return new pass_fre (m_ctxt); }\n   virtual bool gate (function *) { return flag_tree_fre != 0; }\n-  unsigned int execute () { return execute_fre (); }\n+  virtual unsigned int execute (function *);\n \n }; // class pass_fre\n \n+unsigned int\n+pass_fre::execute (function *fun)\n+{\n+  unsigned int todo = 0;\n+\n+  if (!run_scc_vn (VN_WALKREWRITE))\n+    return 0;\n+\n+  memset (&pre_stats, 0, sizeof (pre_stats));\n+\n+  /* Remove all the redundant expressions.  */\n+  todo |= eliminate ();\n+\n+  todo |= fini_eliminate ();\n+\n+  free_scc_vn ();\n+\n+  statistics_counter_event (fun, \"Insertions\", pre_stats.insertions);\n+  statistics_counter_event (fun, \"Eliminated\", pre_stats.eliminations);\n+\n+  return todo;\n+}\n+\n } // anon namespace\n \n gimple_opt_pass *"}, {"sha": "0ea04a3bbbe974ca1eb41ddf0782b92afefa0f31", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -4722,7 +4722,7 @@ class pass_reassoc : public gimple_opt_pass\n   /* opt_pass methods: */\n   opt_pass * clone () { return new pass_reassoc (m_ctxt); }\n   virtual bool gate (function *) { return flag_tree_reassoc != 0; }\n-  unsigned int execute () { return execute_reassoc (); }\n+  virtual unsigned int execute (function *) { return execute_reassoc (); }\n \n }; // class pass_reassoc\n "}, {"sha": "7992ced11dc6c0a9f090df8eb732e19b7a8df1b8", "filename": "gcc/tree-ssa-sink.c", "status": "modified", "additions": 20, "deletions": 27, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssa-sink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssa-sink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sink.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -563,31 +563,6 @@ sink_code_in_bb (basic_block bb)\n    Note that this reduces the number of computations of a = b + c to 1\n    when we take the else edge, instead of 2.\n */\n-static void\n-execute_sink_code (void)\n-{\n-  loop_optimizer_init (LOOPS_NORMAL);\n-  split_critical_edges ();\n-  connect_infinite_loops_to_exit ();\n-  memset (&sink_stats, 0, sizeof (sink_stats));\n-  calculate_dominance_info (CDI_DOMINATORS);\n-  calculate_dominance_info (CDI_POST_DOMINATORS);\n-  sink_code_in_bb (EXIT_BLOCK_PTR_FOR_FN (cfun));\n-  statistics_counter_event (cfun, \"Sunk statements\", sink_stats.sunk);\n-  free_dominance_info (CDI_POST_DOMINATORS);\n-  remove_fake_exit_edges ();\n-  loop_optimizer_finalize ();\n-}\n-\n-/* Gate and execute functions for PRE.  */\n-\n-static unsigned int\n-do_sink (void)\n-{\n-  execute_sink_code ();\n-  return 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_sink_code =\n@@ -598,7 +573,7 @@ const pass_data pass_data_sink_code =\n   true, /* has_execute */\n   TV_TREE_SINK, /* tv_id */\n   /* PROP_no_crit_edges is ensured by running split_critical_edges in\n-     execute_sink_code.  */\n+     pass_data_sink_code::execute ().  */\n   ( PROP_cfg | PROP_ssa ), /* properties_required */\n   0, /* properties_provided */\n   0, /* properties_destroyed */\n@@ -616,10 +591,28 @@ class pass_sink_code : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *) { return flag_tree_sink != 0; }\n-  unsigned int execute () { return do_sink (); }\n+  virtual unsigned int execute (function *);\n \n }; // class pass_sink_code\n \n+unsigned int\n+pass_sink_code::execute (function *fun)\n+{\n+  loop_optimizer_init (LOOPS_NORMAL);\n+  split_critical_edges ();\n+  connect_infinite_loops_to_exit ();\n+  memset (&sink_stats, 0, sizeof (sink_stats));\n+  calculate_dominance_info (CDI_DOMINATORS);\n+  calculate_dominance_info (CDI_POST_DOMINATORS);\n+  sink_code_in_bb (EXIT_BLOCK_PTR_FOR_FN (fun));\n+  statistics_counter_event (fun, \"Sunk statements\", sink_stats.sunk);\n+  free_dominance_info (CDI_POST_DOMINATORS);\n+  remove_fake_exit_edges ();\n+  loop_optimizer_finalize ();\n+\n+  return 0;\n+}\n+\n } // anon namespace\n \n gimple_opt_pass *"}, {"sha": "1cc36d81e36275bf4334e7ca56dadbb32cd78d22", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -2061,34 +2061,6 @@ strlen_dom_walker::after_dom_children (basic_block bb)\n \n /* Main entry point.  */\n \n-static unsigned int\n-tree_ssa_strlen (void)\n-{\n-  ssa_ver_to_stridx.safe_grow_cleared (num_ssa_names);\n-  max_stridx = 1;\n-  strinfo_pool = create_alloc_pool (\"strinfo_struct pool\",\n-\t\t\t\t    sizeof (struct strinfo_struct), 64);\n-\n-  calculate_dominance_info (CDI_DOMINATORS);\n-\n-  /* String length optimization is implemented as a walk of the dominator\n-     tree and a forward walk of statements within each block.  */\n-  strlen_dom_walker (CDI_DOMINATORS).walk (cfun->cfg->x_entry_block_ptr);\n-\n-  ssa_ver_to_stridx.release ();\n-  free_alloc_pool (strinfo_pool);\n-  if (decl_to_stridxlist_htab.is_created ())\n-    {\n-      obstack_free (&stridx_obstack, NULL);\n-      decl_to_stridxlist_htab.dispose ();\n-    }\n-  laststmt.stmt = NULL;\n-  laststmt.len = NULL_TREE;\n-  laststmt.stridx = 0;\n-\n-  return 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_strlen =\n@@ -2114,10 +2086,38 @@ class pass_strlen : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *) { return flag_optimize_strlen != 0; }\n-  unsigned int execute () { return tree_ssa_strlen (); }\n+  virtual unsigned int execute (function *);\n \n }; // class pass_strlen\n \n+unsigned int\n+pass_strlen::execute (function *fun)\n+{\n+  ssa_ver_to_stridx.safe_grow_cleared (num_ssa_names);\n+  max_stridx = 1;\n+  strinfo_pool = create_alloc_pool (\"strinfo_struct pool\",\n+\t\t\t\t    sizeof (struct strinfo_struct), 64);\n+\n+  calculate_dominance_info (CDI_DOMINATORS);\n+\n+  /* String length optimization is implemented as a walk of the dominator\n+     tree and a forward walk of statements within each block.  */\n+  strlen_dom_walker (CDI_DOMINATORS).walk (fun->cfg->x_entry_block_ptr);\n+\n+  ssa_ver_to_stridx.release ();\n+  free_alloc_pool (strinfo_pool);\n+  if (decl_to_stridxlist_htab.is_created ())\n+    {\n+      obstack_free (&stridx_obstack, NULL);\n+      decl_to_stridxlist_htab.dispose ();\n+    }\n+  laststmt.stmt = NULL;\n+  laststmt.len = NULL_TREE;\n+  laststmt.stridx = 0;\n+\n+  return 0;\n+}\n+\n } // anon namespace\n \n gimple_opt_pass *"}, {"sha": "2686ba69ff426eefddd201d46db816d8648d1c6c", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -7444,7 +7444,7 @@ class pass_ipa_pta : public simple_ipa_opt_pass\n \t      && !seen_error ());\n     }\n \n-  unsigned int execute () { return ipa_pta_execute (); }\n+  virtual unsigned int execute (function *) { return ipa_pta_execute (); }\n \n }; // class pass_ipa_pta\n "}, {"sha": "52c568a749a2b39a4a0a351ba7c3f282afa8864a", "filename": "gcc/tree-ssa-uncprop.c", "status": "modified", "additions": 39, "deletions": 42, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssa-uncprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssa-uncprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uncprop.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -383,47 +383,6 @@ class uncprop_dom_walker : public dom_walker\n   auto_vec<tree, 2> m_equiv_stack;\n };\n \n-/* Main driver for un-cprop.  */\n-\n-static unsigned int\n-tree_ssa_uncprop (void)\n-{\n-  basic_block bb;\n-\n-  associate_equivalences_with_edges ();\n-\n-  /* Create our global data structures.  */\n-  val_ssa_equiv.create (1024);\n-\n-  /* We're going to do a dominator walk, so ensure that we have\n-     dominance information.  */\n-  calculate_dominance_info (CDI_DOMINATORS);\n-\n-  /* Recursively walk the dominator tree undoing unprofitable\n-     constant/copy propagations.  */\n-  uncprop_dom_walker (CDI_DOMINATORS).walk (cfun->cfg->x_entry_block_ptr);\n-\n-  /* we just need to empty elements out of the hash table, and cleanup the\n-    AUX field on the edges.  */\n-  val_ssa_equiv.dispose ();\n-  FOR_EACH_BB_FN (bb, cfun)\n-    {\n-      edge e;\n-      edge_iterator ei;\n-\n-      FOR_EACH_EDGE (e, ei, bb->succs)\n-\t{\n-\t  if (e->aux)\n-\t    {\n-\t      free (e->aux);\n-\t      e->aux = NULL;\n-\t    }\n-\t}\n-    }\n-  return 0;\n-}\n-\n-\n /* We have finished processing the dominator children of BB, perform\n    any finalization actions in preparation for leaving this node in\n    the dominator tree.  */\n@@ -607,10 +566,48 @@ class pass_uncprop : public gimple_opt_pass\n   /* opt_pass methods: */\n   opt_pass * clone () { return new pass_uncprop (m_ctxt); }\n   virtual bool gate (function *) { return flag_tree_dom != 0; }\n-  unsigned int execute () { return tree_ssa_uncprop (); }\n+  virtual unsigned int execute (function *);\n \n }; // class pass_uncprop\n \n+unsigned int\n+pass_uncprop::execute (function *fun)\n+{\n+  basic_block bb;\n+\n+  associate_equivalences_with_edges ();\n+\n+  /* Create our global data structures.  */\n+  val_ssa_equiv.create (1024);\n+\n+  /* We're going to do a dominator walk, so ensure that we have\n+     dominance information.  */\n+  calculate_dominance_info (CDI_DOMINATORS);\n+\n+  /* Recursively walk the dominator tree undoing unprofitable\n+     constant/copy propagations.  */\n+  uncprop_dom_walker (CDI_DOMINATORS).walk (fun->cfg->x_entry_block_ptr);\n+\n+  /* we just need to empty elements out of the hash table, and cleanup the\n+    AUX field on the edges.  */\n+  val_ssa_equiv.dispose ();\n+  FOR_EACH_BB_FN (bb, fun)\n+    {\n+      edge e;\n+      edge_iterator ei;\n+\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\t{\n+\t  if (e->aux)\n+\t    {\n+\t      free (e->aux);\n+\t      e->aux = NULL;\n+\t    }\n+\t}\n+    }\n+  return 0;\n+}\n+\n } // anon namespace\n \n gimple_opt_pass *"}, {"sha": "ae251ccd6ba8371c7a65326b11ce3431f35a8fb8", "filename": "gcc/tree-ssa-uninit.c", "status": "modified", "additions": 65, "deletions": 65, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssa-uninit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssa-uninit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uninit.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -2281,11 +2281,44 @@ warn_uninitialized_phi (gimple phi, vec<gimple> *worklist,\n \n }\n \n+static bool\n+gate_warn_uninitialized (void)\n+{\n+  return warn_uninitialized || warn_maybe_uninitialized;\n+}\n \n-/* Entry point to the late uninitialized warning pass.  */\n+namespace {\n \n-static unsigned int\n-execute_late_warn_uninitialized (void)\n+const pass_data pass_data_late_warn_uninitialized =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"uninit\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  PROP_ssa, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_late_warn_uninitialized : public gimple_opt_pass\n+{\n+public:\n+  pass_late_warn_uninitialized (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_late_warn_uninitialized, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_late_warn_uninitialized (m_ctxt); }\n+  virtual bool gate (function *) { return gate_warn_uninitialized (); }\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_late_warn_uninitialized\n+\n+unsigned int\n+pass_late_warn_uninitialized::execute (function *fun)\n {\n   basic_block bb;\n   gimple_stmt_iterator gsi;\n@@ -2305,34 +2338,34 @@ execute_late_warn_uninitialized (void)\n   added_to_worklist = pointer_set_create ();\n \n   /* Initialize worklist  */\n-  FOR_EACH_BB_FN (bb, cfun)\n+  FOR_EACH_BB_FN (bb, fun)\n     for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n       {\n-        gimple phi = gsi_stmt (gsi);\n-        size_t n, i;\n-\n-        n = gimple_phi_num_args (phi);\n-\n-        /* Don't look at virtual operands.  */\n-        if (virtual_operand_p (gimple_phi_result (phi)))\n-          continue;\n-\n-        for (i = 0; i < n; ++i)\n-          {\n-            tree op = gimple_phi_arg_def (phi, i);\n-            if (TREE_CODE (op) == SSA_NAME\n-                && uninit_undefined_value_p (op))\n-              {\n-                worklist.safe_push (phi);\n+\tgimple phi = gsi_stmt (gsi);\n+\tsize_t n, i;\n+\n+\tn = gimple_phi_num_args (phi);\n+\n+\t/* Don't look at virtual operands.  */\n+\tif (virtual_operand_p (gimple_phi_result (phi)))\n+\t  continue;\n+\n+\tfor (i = 0; i < n; ++i)\n+\t  {\n+\t    tree op = gimple_phi_arg_def (phi, i);\n+\t    if (TREE_CODE (op) == SSA_NAME\n+\t\t&& uninit_undefined_value_p (op))\n+\t      {\n+\t\tworklist.safe_push (phi);\n \t\tpointer_set_insert (added_to_worklist, phi);\n-                if (dump_file && (dump_flags & TDF_DETAILS))\n-                  {\n-                    fprintf (dump_file, \"[WORKLIST]: add to initial list: \");\n-                    print_gimple_stmt (dump_file, phi, 0, 0);\n-                  }\n-                break;\n-              }\n-          }\n+\t\tif (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t  {\n+\t\t    fprintf (dump_file, \"[WORKLIST]: add to initial list: \");\n+\t\t    print_gimple_stmt (dump_file, phi, 0, 0);\n+\t\t  }\n+\t\tbreak;\n+\t      }\n+\t  }\n       }\n \n   while (worklist.length () != 0)\n@@ -2351,42 +2384,6 @@ execute_late_warn_uninitialized (void)\n   return 0;\n }\n \n-static bool\n-gate_warn_uninitialized (void)\n-{\n-  return warn_uninitialized || warn_maybe_uninitialized;\n-}\n-\n-namespace {\n-\n-const pass_data pass_data_late_warn_uninitialized =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"uninit\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  true, /* has_execute */\n-  TV_NONE, /* tv_id */\n-  PROP_ssa, /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  0, /* todo_flags_finish */\n-};\n-\n-class pass_late_warn_uninitialized : public gimple_opt_pass\n-{\n-public:\n-  pass_late_warn_uninitialized (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_late_warn_uninitialized, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  opt_pass * clone () { return new pass_late_warn_uninitialized (m_ctxt); }\n-  virtual bool gate (function *) { return gate_warn_uninitialized (); }\n-  unsigned int execute () { return execute_late_warn_uninitialized (); }\n-\n-}; // class pass_late_warn_uninitialized\n-\n } // anon namespace\n \n gimple_opt_pass *\n@@ -2441,7 +2438,10 @@ class pass_early_warn_uninitialized : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *) { return gate_warn_uninitialized (); }\n-  unsigned int execute () { return execute_early_warn_uninitialized (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      return execute_early_warn_uninitialized ();\n+    }\n \n }; // class pass_early_warn_uninitialized\n "}, {"sha": "1ea639d9f42b3e4c4116cab12e6a142e2d99cab3", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -1169,7 +1169,10 @@ class pass_init_datastructures : public gimple_opt_pass\n       return !(fun->curr_properties & PROP_ssa);\n     }\n \n-  unsigned int execute () { return execute_init_datastructures (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      return execute_init_datastructures ();\n+    }\n \n }; // class pass_init_datastructures\n "}, {"sha": "02db6a5627d9f395a99cc539ab3cad2ca3099183", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 35, "deletions": 34, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -569,39 +569,6 @@ replace_ssa_name_symbol (tree ssa_name, tree sym)\n /* Return SSA names that are unused to GGC memory and compact the SSA\n    version namespace.  This is used to keep footprint of compiler during\n    interprocedural optimization.  */\n-static unsigned int\n-release_dead_ssa_names (void)\n-{\n-  unsigned i, j;\n-  int n = vec_safe_length (FREE_SSANAMES (cfun));\n-\n-  /* Now release the freelist.  */\n-  vec_free (FREE_SSANAMES (cfun));\n-\n-  /* And compact the SSA number space.  We make sure to not change the\n-     relative order of SSA versions.  */\n-  for (i = 1, j = 1; i < cfun->gimple_df->ssa_names->length (); ++i)\n-    {\n-      tree name = ssa_name (i);\n-      if (name)\n-\t{\n-\t  if (i != j)\n-\t    {\n-\t      SSA_NAME_VERSION (name) = j;\n-\t      (*cfun->gimple_df->ssa_names)[j] = name;\n-\t    }\n-\t  j++;\n-\t}\n-    }\n-  cfun->gimple_df->ssa_names->truncate (j);\n-\n-  statistics_counter_event (cfun, \"SSA names released\", n);\n-  statistics_counter_event (cfun, \"SSA name holes removed\", i - j);\n-  if (dump_file)\n-    fprintf (dump_file, \"Released %i names, %.2f%%, removed %i holes\\n\",\n-\t     n, n * 100.0 / num_ssa_names, i - j);\n-  return 0;\n-}\n \n namespace {\n \n@@ -627,10 +594,44 @@ class pass_release_ssa_names : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  unsigned int execute () { return release_dead_ssa_names (); }\n+  virtual unsigned int execute (function *);\n \n }; // class pass_release_ssa_names\n \n+unsigned int\n+pass_release_ssa_names::execute (function *fun)\n+{\n+  unsigned i, j;\n+  int n = vec_safe_length (FREE_SSANAMES (fun));\n+\n+  /* Now release the freelist.  */\n+  vec_free (FREE_SSANAMES (fun));\n+\n+  /* And compact the SSA number space.  We make sure to not change the\n+     relative order of SSA versions.  */\n+  for (i = 1, j = 1; i < fun->gimple_df->ssa_names->length (); ++i)\n+    {\n+      tree name = ssa_name (i);\n+      if (name)\n+\t{\n+\t  if (i != j)\n+\t    {\n+\t      SSA_NAME_VERSION (name) = j;\n+\t      (*fun->gimple_df->ssa_names)[j] = name;\n+\t    }\n+\t  j++;\n+\t}\n+    }\n+  fun->gimple_df->ssa_names->truncate (j);\n+\n+  statistics_counter_event (fun, \"SSA names released\", n);\n+  statistics_counter_event (fun, \"SSA name holes removed\", i - j);\n+  if (dump_file)\n+    fprintf (dump_file, \"Released %i names, %.2f%%, removed %i holes\\n\",\n+\t     n, n * 100.0 / num_ssa_names, i - j);\n+  return 0;\n+}\n+\n } // anon namespace\n \n gimple_opt_pass *"}, {"sha": "1cdf0edd82b2e0975704786fac339d8995ca168f", "filename": "gcc/tree-stdarg.c", "status": "modified", "additions": 47, "deletions": 49, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-stdarg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-stdarg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-stdarg.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -663,10 +663,43 @@ check_all_va_list_escapes (struct stdarg_info *si)\n   return false;\n }\n \n-/* Entry point to the stdarg optimization pass.  */\n \n-static unsigned int\n-execute_optimize_stdarg (void)\n+namespace {\n+\n+const pass_data pass_data_stdarg =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"stdarg\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_stdarg : public gimple_opt_pass\n+{\n+public:\n+  pass_stdarg (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_stdarg, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *fun)\n+    {\n+      /* This optimization is only for stdarg functions.  */\n+      return fun->stdarg != 0;\n+    }\n+\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_stdarg\n+\n+unsigned int\n+pass_stdarg::execute (function *fun)\n {\n   basic_block bb;\n   bool va_list_escapes = false;\n@@ -676,22 +709,22 @@ execute_optimize_stdarg (void)\n   const char *funcname = NULL;\n   tree cfun_va_list;\n \n-  cfun->va_list_gpr_size = 0;\n-  cfun->va_list_fpr_size = 0;\n+  fun->va_list_gpr_size = 0;\n+  fun->va_list_fpr_size = 0;\n   memset (&si, 0, sizeof (si));\n   si.va_list_vars = BITMAP_ALLOC (NULL);\n   si.va_list_escape_vars = BITMAP_ALLOC (NULL);\n \n   if (dump_file)\n     funcname = lang_hooks.decl_printable_name (current_function_decl, 2);\n \n-  cfun_va_list = targetm.fn_abi_va_list (cfun->decl);\n+  cfun_va_list = targetm.fn_abi_va_list (fun->decl);\n   va_list_simple_ptr = POINTER_TYPE_P (cfun_va_list)\n \t\t       && (TREE_TYPE (cfun_va_list) == void_type_node\n \t\t\t   || TREE_TYPE (cfun_va_list) == char_type_node);\n   gcc_assert (is_gimple_reg_type (cfun_va_list) == va_list_simple_ptr);\n \n-  FOR_EACH_BB_FN (bb, cfun)\n+  FOR_EACH_BB_FN (bb, fun)\n     {\n       gimple_stmt_iterator i;\n \n@@ -740,7 +773,7 @@ execute_optimize_stdarg (void)\n \t      ap = TREE_OPERAND (ap, 0);\n \t    }\n \t  if (TYPE_MAIN_VARIANT (TREE_TYPE (ap))\n-\t      != TYPE_MAIN_VARIANT (targetm.fn_abi_va_list (cfun->decl))\n+\t      != TYPE_MAIN_VARIANT (targetm.fn_abi_va_list (fun->decl))\n \t      || TREE_CODE (ap) != VAR_DECL)\n \t    {\n \t      va_list_escapes = true;\n@@ -795,13 +828,13 @@ execute_optimize_stdarg (void)\n   /* For void * or char * va_list there is just one counter\n      (va_list itself).  Use VA_LIST_GPR_SIZE for it.  */\n   if (va_list_simple_ptr)\n-    cfun->va_list_fpr_size = VA_LIST_MAX_FPR_SIZE;\n+    fun->va_list_fpr_size = VA_LIST_MAX_FPR_SIZE;\n \n   calculate_dominance_info (CDI_DOMINATORS);\n   memset (&wi, 0, sizeof (wi));\n   wi.info = si.va_list_vars;\n \n-  FOR_EACH_BB_FN (bb, cfun)\n+  FOR_EACH_BB_FN (bb, fun)\n     {\n       gimple_stmt_iterator i;\n \n@@ -962,8 +995,8 @@ execute_optimize_stdarg (void)\n finish:\n   if (va_list_escapes)\n     {\n-      cfun->va_list_gpr_size = VA_LIST_MAX_GPR_SIZE;\n-      cfun->va_list_fpr_size = VA_LIST_MAX_FPR_SIZE;\n+      fun->va_list_gpr_size = VA_LIST_MAX_GPR_SIZE;\n+      fun->va_list_fpr_size = VA_LIST_MAX_FPR_SIZE;\n     }\n   BITMAP_FREE (si.va_list_vars);\n   BITMAP_FREE (si.va_list_escape_vars);\n@@ -972,12 +1005,12 @@ execute_optimize_stdarg (void)\n     {\n       fprintf (dump_file, \"%s: va_list escapes %d, needs to save \",\n \t       funcname, (int) va_list_escapes);\n-      if (cfun->va_list_gpr_size >= VA_LIST_MAX_GPR_SIZE)\n+      if (fun->va_list_gpr_size >= VA_LIST_MAX_GPR_SIZE)\n \tfputs (\"all\", dump_file);\n       else\n \tfprintf (dump_file, \"%d\", cfun->va_list_gpr_size);\n       fputs (\" GPR units and \", dump_file);\n-      if (cfun->va_list_fpr_size >= VA_LIST_MAX_FPR_SIZE)\n+      if (fun->va_list_fpr_size >= VA_LIST_MAX_FPR_SIZE)\n \tfputs (\"all\", dump_file);\n       else\n \tfprintf (dump_file, \"%d\", cfun->va_list_fpr_size);\n@@ -986,41 +1019,6 @@ execute_optimize_stdarg (void)\n   return 0;\n }\n \n-\n-namespace {\n-\n-const pass_data pass_data_stdarg =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"stdarg\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  true, /* has_execute */\n-  TV_NONE, /* tv_id */\n-  ( PROP_cfg | PROP_ssa ), /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  0, /* todo_flags_finish */\n-};\n-\n-class pass_stdarg : public gimple_opt_pass\n-{\n-public:\n-  pass_stdarg (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_stdarg, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  virtual bool gate (function *fun)\n-    {\n-      /* This optimization is only for stdarg functions.  */\n-      return fun->stdarg != 0;\n-    }\n-\n-  unsigned int execute () { return execute_optimize_stdarg (); }\n-\n-}; // class pass_stdarg\n-\n } // anon namespace\n \n gimple_opt_pass *"}, {"sha": "34edc64baee871ebb643521cdfa66f2b1e327386", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -1414,12 +1414,43 @@ process_switch (gimple swtch)\n /* The main function of the pass scans statements for switches and invokes\n    process_switch on them.  */\n \n-static unsigned int\n-do_switchconv (void)\n+namespace {\n+\n+const pass_data pass_data_convert_switch =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"switchconv\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_execute */\n+  TV_TREE_SWITCH_CONVERSION, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_update_ssa | TODO_verify_ssa\n+    | TODO_verify_stmts\n+    | TODO_verify_flow ), /* todo_flags_finish */\n+};\n+\n+class pass_convert_switch : public gimple_opt_pass\n+{\n+public:\n+  pass_convert_switch (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_convert_switch, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *) { return flag_tree_switch_conversion != 0; }\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_convert_switch\n+\n+unsigned int\n+pass_convert_switch::execute (function *fun)\n {\n   basic_block bb;\n \n-  FOR_EACH_BB_FN (bb, cfun)\n+  FOR_EACH_BB_FN (bb, fun)\n   {\n     const char *failure_reason;\n     gimple stmt = last_stmt (bb);\n@@ -1465,37 +1496,6 @@ do_switchconv (void)\n   return 0;\n }\n \n-namespace {\n-\n-const pass_data pass_data_convert_switch =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"switchconv\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  true, /* has_execute */\n-  TV_TREE_SWITCH_CONVERSION, /* tv_id */\n-  ( PROP_cfg | PROP_ssa ), /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  ( TODO_update_ssa | TODO_verify_ssa\n-    | TODO_verify_stmts\n-    | TODO_verify_flow ), /* todo_flags_finish */\n-};\n-\n-class pass_convert_switch : public gimple_opt_pass\n-{\n-public:\n-  pass_convert_switch (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_convert_switch, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  virtual bool gate (function *) { return flag_tree_switch_conversion != 0; }\n-  unsigned int execute () { return do_switchconv (); }\n-\n-}; // class pass_convert_switch\n-\n } // anon namespace\n \n gimple_opt_pass *"}, {"sha": "11a29659bc5bc938190f3af28b9c732a855356a1", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -1065,12 +1065,6 @@ tree_optimize_tail_calls_1 (bool opt_tailcalls)\n   return 0;\n }\n \n-static unsigned int\n-execute_tail_recursion (void)\n-{\n-  return tree_optimize_tail_calls_1 (false);\n-}\n-\n static bool\n gate_tail_calls (void)\n {\n@@ -1109,7 +1103,10 @@ class pass_tail_recursion : public gimple_opt_pass\n   /* opt_pass methods: */\n   opt_pass * clone () { return new pass_tail_recursion (m_ctxt); }\n   virtual bool gate (function *) { return gate_tail_calls (); }\n-  unsigned int execute () { return execute_tail_recursion (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      return tree_optimize_tail_calls_1 (false);\n+    }\n \n }; // class pass_tail_recursion\n \n@@ -1146,7 +1143,7 @@ class pass_tail_calls : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *) { return gate_tail_calls (); }\n-  unsigned int execute () { return execute_tail_calls (); }\n+  virtual unsigned int execute (function *) { return execute_tail_calls (); }\n \n }; // class pass_tail_calls\n "}, {"sha": "d8b2200016612cff5370ad1acdfd099097b1f6ca", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -1585,7 +1585,10 @@ class pass_lower_vector : public gimple_opt_pass\n       return !(fun->curr_properties & PROP_gimple_lvec);\n     }\n \n-  unsigned int execute () { return expand_vector_operations (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      return expand_vector_operations ();\n+    }\n \n }; // class pass_lower_vector\n \n@@ -1625,7 +1628,10 @@ class pass_lower_vector_ssa : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   opt_pass * clone () { return new pass_lower_vector_ssa (m_ctxt); }\n-  unsigned int execute () { return expand_vector_operations (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      return expand_vector_operations ();\n+    }\n \n }; // class pass_lower_vector_ssa\n "}, {"sha": "d7de964fa3776bfe0d96f2e444d43a4ca0554aa5", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -586,33 +586,6 @@ vectorize_loops (void)\n \n /*  Entry point to basic block SLP phase.  */\n \n-static unsigned int\n-execute_vect_slp (void)\n-{\n-  basic_block bb;\n-\n-  init_stmt_vec_info_vec ();\n-\n-  FOR_EACH_BB_FN (bb, cfun)\n-    {\n-      vect_location = find_bb_location (bb);\n-\n-      if (vect_slp_analyze_bb (bb))\n-        {\n-          if (!dbg_cnt (vect_slp))\n-            break;\n-\n-          vect_slp_transform_bb (bb);\n-          if (dump_enabled_p ())\n-            dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n-\t\t\t     \"basic block vectorized\\n\");\n-        }\n-    }\n-\n-  free_stmt_vec_info_vec ();\n-  return 0;\n-}\n-\n namespace {\n \n const pass_data pass_data_slp_vectorize =\n@@ -639,10 +612,37 @@ class pass_slp_vectorize : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *) { return flag_tree_slp_vectorize != 0; }\n-  unsigned int execute () { return execute_vect_slp (); }\n+  virtual unsigned int execute (function *);\n \n }; // class pass_slp_vectorize\n \n+unsigned int\n+pass_slp_vectorize::execute (function *fun)\n+{\n+  basic_block bb;\n+\n+  init_stmt_vec_info_vec ();\n+\n+  FOR_EACH_BB_FN (bb, fun)\n+    {\n+      vect_location = find_bb_location (bb);\n+\n+      if (vect_slp_analyze_bb (bb))\n+        {\n+          if (!dbg_cnt (vect_slp))\n+            break;\n+\n+          vect_slp_transform_bb (bb);\n+          if (dump_enabled_p ())\n+            dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n+\t\t\t     \"basic block vectorized\\n\");\n+        }\n+    }\n+\n+  free_stmt_vec_info_vec ();\n+  return 0;\n+}\n+\n } // anon namespace\n \n gimple_opt_pass *\n@@ -725,7 +725,7 @@ class pass_ipa_increase_alignment : public simple_ipa_opt_pass\n       return flag_section_anchors && flag_tree_loop_vectorize;\n     }\n \n-  unsigned int execute () { return increase_alignment (); }\n+  virtual unsigned int execute (function *) { return increase_alignment (); }\n \n }; // class pass_ipa_increase_alignment\n "}, {"sha": "34255ced1b9cfaa1e26b8233b871e560defc702f", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -9922,7 +9922,7 @@ class pass_vrp : public gimple_opt_pass\n   /* opt_pass methods: */\n   opt_pass * clone () { return new pass_vrp (m_ctxt); }\n   virtual bool gate (function *) { return flag_tree_vrp != 0; }\n-  unsigned int execute () { return execute_vrp (); }\n+  virtual unsigned int execute (function *) { return execute_vrp (); }\n \n }; // class pass_vrp\n "}, {"sha": "8b44ecc70882c0f51ef51453221b25371b510e1b", "filename": "gcc/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -5642,7 +5642,7 @@ class pass_ipa_free_lang_data : public simple_ipa_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  unsigned int execute () { return free_lang_data (); }\n+  virtual unsigned int execute (function *) { return free_lang_data (); }\n \n }; // class pass_ipa_free_lang_data\n "}, {"sha": "d9f5718ee7ec711b4d8ea1377010b04ccc894a09", "filename": "gcc/tsan.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Ftsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftsan.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -762,7 +762,7 @@ class pass_tsan : public gimple_opt_pass\n   return (flag_sanitize & SANITIZE_THREAD) != 0;\n }\n \n-  unsigned int execute () { return tsan_pass (); }\n+  virtual unsigned int execute (function *) { return tsan_pass (); }\n \n }; // class pass_tsan\n \n@@ -803,7 +803,7 @@ class pass_tsan_O0 : public gimple_opt_pass\n       return (flag_sanitize & SANITIZE_THREAD) != 0 && !optimize;\n     }\n \n-  unsigned int execute () { return tsan_pass (); }\n+  virtual unsigned int execute (function *) { return tsan_pass (); }\n \n }; // class pass_tsan_O0\n "}, {"sha": "cf25aa3edf60476ec239642dd44ab530b4038dbd", "filename": "gcc/ubsan.c", "status": "modified", "additions": 36, "deletions": 38, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fubsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fubsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fubsan.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -859,17 +859,49 @@ instrument_bool_enum_load (gimple_stmt_iterator *gsi)\n   gsi_insert_before (&gsi2, g, GSI_SAME_STMT);\n }\n \n-/* Gate and execute functions for ubsan pass.  */\n+namespace {\n \n-static unsigned int\n-ubsan_pass (void)\n+const pass_data pass_data_ubsan =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"ubsan\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_execute */\n+  TV_TREE_UBSAN, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_update_ssa, /* todo_flags_finish */\n+};\n+\n+class pass_ubsan : public gimple_opt_pass\n+{\n+public:\n+  pass_ubsan (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_ubsan, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *)\n+    {\n+      return flag_sanitize & (SANITIZE_NULL | SANITIZE_SI_OVERFLOW\n+\t\t\t      | SANITIZE_BOOL | SANITIZE_ENUM);\n+    }\n+\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_ubsan\n+\n+unsigned int\n+pass_ubsan::execute (function *fun)\n {\n   basic_block bb;\n   gimple_stmt_iterator gsi;\n \n   initialize_sanitizer_builtins ();\n \n-  FOR_EACH_BB_FN (bb, cfun)\n+  FOR_EACH_BB_FN (bb, fun)\n     {\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi);)\n \t{\n@@ -902,40 +934,6 @@ ubsan_pass (void)\n   return 0;\n }\n \n-namespace {\n-\n-const pass_data pass_data_ubsan =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"ubsan\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  true, /* has_execute */\n-  TV_TREE_UBSAN, /* tv_id */\n-  ( PROP_cfg | PROP_ssa ), /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  TODO_update_ssa, /* todo_flags_finish */\n-};\n-\n-class pass_ubsan : public gimple_opt_pass\n-{\n-public:\n-  pass_ubsan (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_ubsan, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  virtual bool gate (function *)\n-    {\n-      return flag_sanitize & (SANITIZE_NULL | SANITIZE_SI_OVERFLOW\n-\t\t\t      | SANITIZE_BOOL | SANITIZE_ENUM);\n-    }\n-\n-  unsigned int execute () { return ubsan_pass (); }\n-\n-}; // class pass_ubsan\n-\n } // anon namespace\n \n gimple_opt_pass *"}, {"sha": "39373401d4b5a54b8f7b29236b9be6b499a5e60e", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -10373,7 +10373,10 @@ class pass_variable_tracking : public rtl_opt_pass\n       return (flag_var_tracking && !targetm.delay_vartrack);\n     }\n \n-  unsigned int execute () { return variable_tracking_main (); }\n+  virtual unsigned int execute (function *)\n+    {\n+      return variable_tracking_main ();\n+    }\n \n }; // class pass_variable_tracking\n "}, {"sha": "b99ff6cf8964f7bfab8d3dcfbdfb989b7f3ce149", "filename": "gcc/vtable-verify.c", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fvtable-verify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fvtable-verify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvtable-verify.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -723,23 +723,6 @@ verify_bb_vtables (basic_block bb)\n     }\n }\n \n-/* Main function, called from pass->excute().  Loop through all the\n-   basic blocks in the current function, passing them to\n-   verify_bb_vtables, which searches for virtual calls, and inserts\n-   calls to __VLTVerifyVtablePointer.  */\n-\n-unsigned int\n-vtable_verify_main (void)\n-{\n-  unsigned int ret = 1;\n-  basic_block bb;\n-\n-  FOR_ALL_BB_FN (bb, cfun)\n-      verify_bb_vtables (bb);\n-\n-  return ret;\n-}\n-\n /* Definition of this optimization pass.  */\n \n namespace {\n@@ -767,10 +750,26 @@ class pass_vtable_verify : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   virtual bool gate (function *) { return (flag_vtable_verify); }\n-  unsigned int execute () { return vtable_verify_main (); }\n+  virtual unsigned int execute (function *);\n \n }; // class pass_vtable_verify\n \n+/* Loop through all the basic blocks in the current function, passing them to\n+   verify_bb_vtables, which searches for virtual calls, and inserts\n+   calls to __VLTVerifyVtablePointer.  */\n+\n+unsigned int\n+pass_vtable_verify::execute (function *fun)\n+{\n+  unsigned int ret = 1;\n+  basic_block bb;\n+\n+  FOR_ALL_BB_FN (bb, fun)\n+      verify_bb_vtables (bb);\n+\n+  return ret;\n+}\n+\n } // anon namespace\n \n gimple_opt_pass *"}, {"sha": "46a6ff7448d3fbe8ae378eaab226a3681e93d6b6", "filename": "gcc/web.c", "status": "modified", "additions": 33, "deletions": 35, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fweb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be55bfe6cf456943b12fe128f8a445b583ace36f/gcc%2Fweb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fweb.c?ref=be55bfe6cf456943b12fe128f8a445b583ace36f", "patch": "@@ -325,10 +325,37 @@ replace_ref (df_ref ref, rtx reg)\n }\n \n \f\n-/* Main entry point.  */\n+namespace {\n+\n+const pass_data pass_data_web =\n+{\n+  RTL_PASS, /* type */\n+  \"web\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_execute */\n+  TV_WEB, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_df_finish | TODO_verify_rtl_sharing ), /* todo_flags_finish */\n+};\n+\n+class pass_web : public rtl_opt_pass\n+{\n+public:\n+  pass_web (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_web, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *) { return (optimize > 0 && flag_web); }\n+  virtual unsigned int execute (function *);\n \n-static unsigned int\n-web_main (void)\n+}; // class pass_web\n+\n+unsigned int\n+pass_web::execute (function *fun)\n {\n   struct web_entry *def_entry;\n   struct web_entry *use_entry;\n@@ -345,7 +372,7 @@ web_main (void)\n   df_set_flags (DF_DEFER_INSN_RESCAN);\n \n   /* Assign ids to the uses.  */\n-  FOR_ALL_BB_FN (bb, cfun)\n+  FOR_ALL_BB_FN (bb, fun)\n     FOR_BB_INSNS (bb, insn)\n     {\n       unsigned int uid = INSN_UID (insn);\n@@ -373,7 +400,7 @@ web_main (void)\n   use_entry = XCNEWVEC (struct web_entry, uses_num);\n \n   /* Produce the web.  */\n-  FOR_ALL_BB_FN (bb, cfun)\n+  FOR_ALL_BB_FN (bb, fun)\n     FOR_BB_INSNS (bb, insn)\n     {\n       unsigned int uid = INSN_UID (insn);\n@@ -398,7 +425,7 @@ web_main (void)\n \n   /* Update the instruction stream, allocating new registers for split pseudos\n      in progress.  */\n-  FOR_ALL_BB_FN (bb, cfun)\n+  FOR_ALL_BB_FN (bb, fun)\n     FOR_BB_INSNS (bb, insn)\n     {\n       unsigned int uid = INSN_UID (insn);\n@@ -443,35 +470,6 @@ web_main (void)\n   return 0;\n }\n \f\n-namespace {\n-\n-const pass_data pass_data_web =\n-{\n-  RTL_PASS, /* type */\n-  \"web\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  true, /* has_execute */\n-  TV_WEB, /* tv_id */\n-  0, /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  ( TODO_df_finish | TODO_verify_rtl_sharing ), /* todo_flags_finish */\n-};\n-\n-class pass_web : public rtl_opt_pass\n-{\n-public:\n-  pass_web (gcc::context *ctxt)\n-    : rtl_opt_pass (pass_data_web, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  virtual bool gate (function *) { return (optimize > 0 && flag_web); }\n-  unsigned int execute () { return web_main (); }\n-\n-}; // class pass_web\n-\n } // anon namespace\n \n rtl_opt_pass *"}]}