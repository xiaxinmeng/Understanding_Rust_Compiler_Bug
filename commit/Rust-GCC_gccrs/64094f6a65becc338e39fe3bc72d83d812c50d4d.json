{"sha": "64094f6a65becc338e39fe3bc72d83d812c50d4d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQwOTRmNmE2NWJlY2MzMzhlMzlmZTNiYzcyZDgzZDgxMmM1MGQ0ZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2000-12-20T18:18:24Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-12-20T18:18:24Z"}, "message": "c-typeck.c (build_asm_stmt): New, broken out from ...\n\n        * c-typeck.c (build_asm_stmt): New, broken out from ...\n        (c_expand_asm_operands): ... here.  Just do rtl expansion.\n        (c_expand_return): Return the new stmt node.\n        (c_start_case, do_case): Likewise.\n        * c-common.c (c_expand_expr_stmt): Likewise.\n        * c-common.h: Update declarations.\n        * c-tree.h: Likewise.\n        * c-semantics.c (build_stmt): Use STMT_LINENO not TREE_COMPLEXITY.\n        * c-parse.in (fndef): Set DECL_SOURCE_LINE to the open brace.\n        (nested_function, notype_nested_function): Likewise.\n        (compstmt): Return the compound statement not the binding level.\n        (lineno_labeled_stmt): Simplify.\n        (lineno_stmt, lineno_label): Set STMT_LINENO.\n        (stmt, label): Return the new stmt node.\n\nFrom-SVN: r38402", "tree": {"sha": "c348f2bb0cb4cb71bb3b6a678fa12eeac3682584", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c348f2bb0cb4cb71bb3b6a678fa12eeac3682584"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/64094f6a65becc338e39fe3bc72d83d812c50d4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64094f6a65becc338e39fe3bc72d83d812c50d4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64094f6a65becc338e39fe3bc72d83d812c50d4d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64094f6a65becc338e39fe3bc72d83d812c50d4d/comments", "author": null, "committer": null, "parents": [{"sha": "3e4d04a1bad107f85a9e48e2f9df9ed672b0ab16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e4d04a1bad107f85a9e48e2f9df9ed672b0ab16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e4d04a1bad107f85a9e48e2f9df9ed672b0ab16"}], "stats": {"total": 279, "additions": 179, "deletions": 100}, "files": [{"sha": "6eca585b1072867a39f8b6b5db6b66c690e79487", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64094f6a65becc338e39fe3bc72d83d812c50d4d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64094f6a65becc338e39fe3bc72d83d812c50d4d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=64094f6a65becc338e39fe3bc72d83d812c50d4d", "patch": "@@ -1,3 +1,20 @@\n+2000-12-20  Richard Henderson  <rth@redhat.com>\n+\n+        * c-typeck.c (build_asm_stmt): New, broken out from ...\n+        (c_expand_asm_operands): ... here.  Just do rtl expansion.\n+        (c_expand_return): Return the new stmt node.\n+        (c_start_case, do_case): Likewise.\n+        * c-common.c (c_expand_expr_stmt): Likewise.\n+        * c-common.h: Update declarations.\n+        * c-tree.h: Likewise.\n+        * c-semantics.c (build_stmt): Use STMT_LINENO not TREE_COMPLEXITY.\n+        * c-parse.in (fndef): Set DECL_SOURCE_LINE to the open brace.\n+        (nested_function, notype_nested_function): Likewise.\n+        (compstmt): Return the compound statement not the binding level.\n+        (lineno_labeled_stmt): Simplify.\n+        (lineno_stmt, lineno_label): Set STMT_LINENO.\n+        (stmt, label): Return the new stmt node.\n+\n 2000-12-20  Bernd Schmidt  <bernds@redhat.com>\n \n \t* Makefile.in (OBJS): Add sched-ebb.o."}, {"sha": "5d13345eda0257165651827a424dbf07522ba5cd", "filename": "gcc/c-common.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64094f6a65becc338e39fe3bc72d83d812c50d4d/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64094f6a65becc338e39fe3bc72d83d812c50d4d/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=64094f6a65becc338e39fe3bc72d83d812c50d4d", "patch": "@@ -3950,7 +3950,7 @@ verify_sequence_points (expr)\n   obstack_free (&tlist_obstack, tlist_firstobj);\n }\n \n-void\n+tree\n c_expand_expr_stmt (expr)\n      tree expr;\n {\n@@ -3969,7 +3969,7 @@ c_expand_expr_stmt (expr)\n     error (\"expression statement has incomplete type\");\n \n   last_expr_type = TREE_TYPE (expr); \n-  add_stmt (build_stmt (EXPR_STMT, expr));\n+  return add_stmt (build_stmt (EXPR_STMT, expr));\n }\n \f\n /* Validate the expression after `case' and apply default promotions.  */"}, {"sha": "a23b8715b35171c6e8a73df414d13971f843572a", "filename": "gcc/c-common.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64094f6a65becc338e39fe3bc72d83d812c50d4d/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64094f6a65becc338e39fe3bc72d83d812c50d4d/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=64094f6a65becc338e39fe3bc72d83d812c50d4d", "patch": "@@ -467,7 +467,7 @@ extern void c_apply_type_quals_to_decl\t\tPARAMS ((int, tree));\n /* Print an error message for invalid operands to arith operation CODE.\n    NOP_EXPR is used as a special case (see truthvalue_conversion).  */\n extern void binary_op_error\t\t\tPARAMS ((enum tree_code));\n-extern void c_expand_expr_stmt\t\t\tPARAMS ((tree));\n+extern tree c_expand_expr_stmt\t\t\tPARAMS ((tree));\n extern void c_expand_start_cond\t\t\tPARAMS ((tree, int));\n extern void c_finish_then                       PARAMS ((void));\n extern void c_expand_start_else\t\t\tPARAMS ((void));\n@@ -713,8 +713,8 @@ extern int anon_aggr_type_p                     PARAMS ((tree));\n extern void emit_local_var                      PARAMS ((tree));\n extern void make_rtl_for_local_static           PARAMS ((tree));\n extern tree expand_cond                         PARAMS ((tree));\n-extern void c_expand_return\t\t\tPARAMS ((tree));\n-extern void do_case\t\t\t\tPARAMS ((tree, tree));\n+extern tree c_expand_return\t\t\tPARAMS ((tree));\n+extern tree do_case\t\t\t\tPARAMS ((tree, tree));\n extern tree build_stmt                          PARAMS ((enum tree_code, ...));\n extern tree build_case_label                    PARAMS ((tree, tree, tree));\n extern tree build_continue_stmt                 PARAMS ((void));"}, {"sha": "8b211d1384ba5249c133cd805e5dc3b13d107230", "filename": "gcc/c-parse.in", "status": "modified", "additions": 69, "deletions": 45, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64094f6a65becc338e39fe3bc72d83d812c50d4d/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64094f6a65becc338e39fe3bc72d83d812c50d4d/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=64094f6a65becc338e39fe3bc72d83d812c50d4d", "patch": "@@ -177,7 +177,7 @@ end ifc\n %type <ttype> any_word extension\n \n %type <ttype> compstmt compstmt_start compstmt_nostart compstmt_primary_start\n-%type <ttype> do_stmt_start poplevel\n+%type <ttype> do_stmt_start poplevel stmt label\n \n %type <ttype> c99_block_start c99_block_end\n %type <ttype> declarator\n@@ -365,8 +365,10 @@ fndef:\n \t\t}\n \t  old_style_parm_decls\n \t\t{ store_parm_decls (); }\n-\t  compstmt_or_error\n-\t\t{ finish_function (0); \n+\t  save_filename save_lineno compstmt_or_error\n+\t\t{ DECL_SOURCE_FILE (current_function_decl) = $7;\n+\t\t  DECL_SOURCE_LINE (current_function_decl) = $8;\n+\t\t  finish_function (0); \n \t\t  current_declspecs = TREE_VALUE (declspec_stack);\n \t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n \t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n@@ -381,8 +383,10 @@ fndef:\n \t\t}\n \t  old_style_parm_decls\n \t\t{ store_parm_decls (); }\n-\t  compstmt_or_error\n-\t\t{ finish_function (0); \n+\t  save_filename save_lineno compstmt_or_error\n+\t\t{ DECL_SOURCE_FILE (current_function_decl) = $7;\n+\t\t  DECL_SOURCE_LINE (current_function_decl) = $8;\n+\t\t  finish_function (0); \n \t\t  current_declspecs = TREE_VALUE (declspec_stack);\n \t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n \t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n@@ -397,8 +401,10 @@ fndef:\n \t\t}\n \t  old_style_parm_decls\n \t\t{ store_parm_decls (); }\n-\t  compstmt_or_error\n-\t\t{ finish_function (0); \n+\t  save_filename save_lineno compstmt_or_error\n+\t\t{ DECL_SOURCE_FILE (current_function_decl) = $6;\n+\t\t  DECL_SOURCE_LINE (current_function_decl) = $7;\n+\t\t  finish_function (0); \n \t\t  current_declspecs = TREE_VALUE (declspec_stack);\n \t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n \t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n@@ -1192,8 +1198,10 @@ nested_function:\n    which then was handled by compstmt_or_error.\n    There followed a repeated execution of that same rule,\n    which called YYERROR1 again, and so on.  */\n-\t  compstmt\n+\t  save_filename save_lineno compstmt\n \t\t{ tree decl = current_function_decl;\n+\t\t  DECL_SOURCE_FILE (decl) = $5;\n+\t\t  DECL_SOURCE_LINE (decl) = $6;\n \t\t  finish_function (1);\n \t\t  pop_function_context (); \n \t\t  add_decl_stmt (decl); }\n@@ -1220,8 +1228,10 @@ notype_nested_function:\n    which then was handled by compstmt_or_error.\n    There followed a repeated execution of that same rule,\n    which called YYERROR1 again, and so on.  */\n-\t  compstmt\n+\t  save_filename save_lineno compstmt\n \t\t{ tree decl = current_function_decl;\n+\t\t  DECL_SOURCE_FILE (decl) = $5;\n+\t\t  DECL_SOURCE_LINE (decl) = $6;\n \t\t  finish_function (1);\n \t\t  pop_function_context (); \n \t\t  add_decl_stmt (decl); }\n@@ -1750,7 +1760,7 @@ compstmt_primary_start:\n \n compstmt: compstmt_start compstmt_nostart\n \t\t{ RECHAIN_STMTS ($1, COMPOUND_BODY ($1)); \n-                  $$ = $2; }\n+                  $$ = $1; }\n \t;\n \n /* Value is number of statements counted as of the closeparen.  */\n@@ -1808,13 +1818,8 @@ save_lineno:\n \t;\n \n lineno_labeled_stmt:\n-\t  save_filename save_lineno stmt\n-\t\t{ }\n-/*\t| save_filename save_lineno error\n-\t\t{ }\n-*/\n-\t| save_filename save_lineno label lineno_labeled_stmt\n-\t\t{ }\n+\t  lineno_stmt\n+\t| lineno_label lineno_labeled_stmt\n \t;\n \n /* Like lineno_labeled_stmt, but a block in C99.  */\n@@ -1826,12 +1831,25 @@ c99_block_lineno_labeled_stmt:\n \n lineno_stmt:\n \t  save_filename save_lineno stmt\n-\t\t{ }\n+\t\t{ if ($3)\n+\t\t    {\n+\t\t      STMT_LINENO ($3) = $2;\n+\t\t      /* ??? We currently have no way of recording\n+\t\t\t the filename for a statement.  This probably\n+\t\t\t matters little in practice at the moment,\n+\t\t\t but I suspect that problems will ocurr when\n+\t\t\t doing inlining at the tree level.  */\n+\t\t    }\n+\t\t}\n \t;\n \n lineno_label:\n \t  save_filename save_lineno label\n-\t\t{ }\n+\t\t{ if ($3)\n+\t\t    {\n+\t\t      STMT_LINENO ($3) = $2;\n+\t\t    }\n+\t\t}\n \t;\n \n select_or_iter_stmt:\n@@ -1900,25 +1918,26 @@ for_init_stmt:\n /* Parse a single real statement, not including any labels.  */\n stmt:\n \t  compstmt\n-\t\t{ stmt_count++; }\n+\t\t{ stmt_count++; $$ = $1; }\n \t| expr ';'\n \t\t{ stmt_count++;\n-\t\t  c_expand_expr_stmt ($1); }\n+\t\t  $$ = c_expand_expr_stmt ($1); }\n \t| c99_block_start select_or_iter_stmt c99_block_end\n \t\t{ if (flag_isoc99)\n-\t\t    RECHAIN_STMTS ($1, COMPOUND_BODY ($1)); }\n+\t\t    RECHAIN_STMTS ($1, COMPOUND_BODY ($1));\n+\t\t  $$ = NULL_TREE; }\n \t| BREAK ';'\n \t        { stmt_count++;\n-\t\t  add_stmt (build_break_stmt ()); }\n+\t\t  $$ = add_stmt (build_break_stmt ()); }\n \t| CONTINUE ';'\n                 { stmt_count++;\n-\t\t  add_stmt (build_continue_stmt ()); }\n+\t\t  $$ = add_stmt (build_continue_stmt ()); }\n \t| RETURN ';'\n                 { stmt_count++;\n-\t\t  c_expand_return (NULL_TREE); }\n+\t\t  $$ = c_expand_return (NULL_TREE); }\n \t| RETURN expr ';'\n                 { stmt_count++;\n-\t\t  c_expand_return ($2); }\n+\t\t  $$ = c_expand_return ($2); }\n \t| ASM_KEYWORD maybe_type_qual '(' expr ')' ';'\n \t\t{ stmt_count++;\n \t\t  STRIP_NOPS ($4);\n@@ -1930,47 +1949,50 @@ stmt:\n \t\t\t$4 = TREE_OPERAND ($4, 0);\n \t\t      if (TREE_CHAIN ($4))\n \t\t\t$4 = combine_strings ($4);\n-\t\t      add_stmt (build_stmt (ASM_STMT, NULL_TREE, $4,\n-\t\t\t\t\t    NULL_TREE, NULL_TREE, NULL_TREE));\n+\t\t      $$ = add_stmt (build_stmt (ASM_STMT, NULL_TREE, $4,\n+\t\t\t\t\t\t NULL_TREE, NULL_TREE,\n+\t\t\t\t\t\t NULL_TREE));\n \t\t    }\n \t\t  else\n-\t\t    error (\"argument of `asm' is not a constant string\"); }\n+\t\t    {\n+\t\t      error (\"argument of `asm' is not a constant string\");\n+\t\t      $$ = NULL_TREE;\n+\t\t    }\n+\t\t}\n \t/* This is the case with just output operands.  */\n \t| ASM_KEYWORD maybe_type_qual '(' expr ':' asm_operands ')' ';'\n \t\t{ stmt_count++;\n-\t\t  c_expand_asm_operands ($4, $6, NULL_TREE, NULL_TREE,\n-\t\t\t\t\t $2 == ridpointers[(int)RID_VOLATILE],\n-\t\t\t\t\t input_filename, lineno); }\n+\t\t  $$ = build_asm_stmt ($2, $4, $6, NULL_TREE, NULL_TREE); }\n \t/* This is the case with input operands as well.  */\n-\t| ASM_KEYWORD maybe_type_qual '(' expr ':' asm_operands ':' asm_operands ')' ';'\n+\t| ASM_KEYWORD maybe_type_qual '(' expr ':' asm_operands ':'\n+\t  asm_operands ')' ';'\n \t\t{ stmt_count++;\n-\t\t  c_expand_asm_operands ($4, $6, $8, NULL_TREE,\n-\t\t\t\t\t $2 == ridpointers[(int)RID_VOLATILE],\n-\t\t\t\t\t input_filename, lineno); }\n+\t\t  $$ = build_asm_stmt ($2, $4, $6, $8, NULL_TREE); }\n \t/* This is the case with clobbered registers as well.  */\n \t| ASM_KEYWORD maybe_type_qual '(' expr ':' asm_operands ':'\n   \t  asm_operands ':' asm_clobbers ')' ';'\n \t\t{ stmt_count++;\n-\t\t  c_expand_asm_operands ($4, $6, $8, $10,\n-\t\t\t\t\t $2 == ridpointers[(int)RID_VOLATILE],\n-\t\t\t\t\t input_filename, lineno); }\n+\t\t  $$ = build_asm_stmt ($2, $4, $6, $8, $10); }\n \t| GOTO identifier ';'\n \t\t{ tree decl;\n \t\t  stmt_count++;\n \t\t  decl = lookup_label ($2);\n \t\t  if (decl != 0)\n \t\t    {\n \t\t      TREE_USED (decl) = 1;\n-\t\t      add_stmt (build_stmt (GOTO_STMT, decl));\n+\t\t      $$ = add_stmt (build_stmt (GOTO_STMT, decl));\n \t\t    }\n+\t\t  else\n+\t\t    $$ = NULL_TREE;\n \t\t}\n \t| GOTO '*' expr ';'\n \t\t{ if (pedantic)\n \t\t    pedwarn (\"ISO C forbids `goto *expr;'\");\n \t\t  stmt_count++;\n \t\t  $3 = convert (ptr_type_node, $3);\n-\t\t  add_stmt (build_stmt (GOTO_STMT, $3)); }\n+\t\t  $$ = add_stmt (build_stmt (GOTO_STMT, $3)); }\n \t| ';'\n+\t\t{ $$ = NULL_TREE; }\n \t;\n \n /* Any kind of label, including jump labels and case labels.\n@@ -1979,21 +2001,23 @@ stmt:\n \n label:\t  CASE expr_no_commas ':'\n                 { stmt_count++;\n-\t\t  do_case ($2, NULL_TREE); }\n+\t\t  $$ = do_case ($2, NULL_TREE); }\n \t| CASE expr_no_commas ELLIPSIS expr_no_commas ':'\n                 { stmt_count++;\n-\t\t  do_case ($2, $4); }\n+\t\t  $$ = do_case ($2, $4); }\n \t| DEFAULT ':'\n                 { stmt_count++;\n-\t\t  do_case (NULL_TREE, NULL_TREE); }\n+\t\t  $$ = do_case (NULL_TREE, NULL_TREE); }\n \t| identifier save_filename save_lineno ':' maybe_attribute\n \t\t{ tree label = define_label ($2, $3, $1);\n \t\t  stmt_count++;\n \t\t  if (label)\n \t\t    {\n \t\t      decl_attributes (label, $5, NULL_TREE);\n-\t\t      add_stmt (build_stmt (LABEL_STMT, label));\n+\t\t      $$ = add_stmt (build_stmt (LABEL_STMT, label));\n \t\t    }\n+\t\t  else\n+\t\t    $$ = NULL_TREE;\n \t\t}\n \t;\n "}, {"sha": "4cf457279de2c99c8f31d604473138ba328773c7", "filename": "gcc/c-semantics.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64094f6a65becc338e39fe3bc72d83d812c50d4d/gcc%2Fc-semantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64094f6a65becc338e39fe3bc72d83d812c50d4d/gcc%2Fc-semantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-semantics.c?ref=64094f6a65becc338e39fe3bc72d83d812c50d4d", "patch": "@@ -220,7 +220,9 @@ finish_stmt_tree (t)\n \n /* Build a generic statement based on the given type of node and\n    arguments. Similar to `build_nt', except that we set\n-   TREE_COMPLEXITY to be the current line number.  */\n+   STMT_LINENO to be the current line number.  */\n+/* ??? This should be obsolete with the lineno_stmt productions\n+   in the grammar.  */\n \n tree\n build_stmt VPARAMS ((enum tree_code code, ...))\n@@ -241,7 +243,7 @@ build_stmt VPARAMS ((enum tree_code code, ...))\n \n   t = make_node (code);\n   length = TREE_CODE_LENGTH (code);\n-  TREE_COMPLEXITY (t) = lineno;\n+  STMT_LINENO (t) = lineno;\n \n   for (i = 0; i < length; i++)\n     TREE_OPERAND (t, i) = va_arg (p, tree);"}, {"sha": "939ca3fafed6ddc944d221fdcb2a8773b218dac2", "filename": "gcc/c-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64094f6a65becc338e39fe3bc72d83d812c50d4d/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64094f6a65becc338e39fe3bc72d83d812c50d4d/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=64094f6a65becc338e39fe3bc72d83d812c50d4d", "patch": "@@ -275,6 +275,8 @@ extern void pedwarn_c99\t\t\t\tPARAMS ((const char *, ...))\n \t\t\t\t\t\t\tATTRIBUTE_PRINTF_1;\n extern tree c_start_case                        PARAMS ((tree));\n extern void c_finish_case                       PARAMS ((void));\n+extern tree build_asm_stmt\t\t\tPARAMS ((tree, tree, tree,\n+\t\t\t\t\t\t\t tree, tree));\n \n /* Set to 0 at beginning of a function definition, set to 1 if\n    a return statement that specifies a return value is seen.  */"}, {"sha": "d7efc2d56f7e98e5fc447b771989e99090559f10", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 82, "deletions": 48, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64094f6a65becc338e39fe3bc72d83d812c50d4d/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64094f6a65becc338e39fe3bc72d83d812c50d4d/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=64094f6a65becc338e39fe3bc72d83d812c50d4d", "patch": "@@ -6303,41 +6303,43 @@ process_init_element (value)\n     }\n }\n \f\n-/* Expand an ASM statement with operands, handling output operands\n-   that are not variables or INDIRECT_REFS by transforming such\n-   cases into cases that expand_asm_operands can handle.\n-\n-   Arguments are same as for expand_asm_operands.  */\n+/* Build an asm-statement, whose components are a CV_QUALIFIER, a\n+   STRING, some OUTPUTS, some INPUTS, and some CLOBBERS.  */\n \n-void\n-c_expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n-     tree string, outputs, inputs, clobbers;\n-     int vol;\n-     const char *filename;\n-     int line;\n+tree\n+build_asm_stmt (cv_qualifier, string, outputs, inputs, clobbers)\n+     tree cv_qualifier;\n+     tree string;\n+     tree outputs;\n+     tree inputs;\n+     tree clobbers;\n {\n-  int noutputs = list_length (outputs);\n-  register int i;\n-  /* o[I] is the place that output number I should be written.  */\n-  register tree *o = (tree *) alloca (noutputs * sizeof (tree));\n-  register tree tail;\n+  tree tail;\n \n-  if (TREE_CODE (string) == ADDR_EXPR)\n-    string = TREE_OPERAND (string, 0);\n-  if (last_tree && TREE_CODE (string) != STRING_CST)\n+  if (TREE_CHAIN (string))\n+    string = combine_strings (string);\n+  if (TREE_CODE (string) != STRING_CST)\n     {\n       error (\"asm template is not a string constant\");\n-      return;\n+      return NULL_TREE;\n     }\n \n-  /* Record the contents of OUTPUTS before it is modified.  */\n-  for (i = 0, tail = outputs; tail; tail = TREE_CHAIN (tail), i++)\n+  if (cv_qualifier != NULL_TREE\n+      && cv_qualifier != ridpointers[(int) RID_VOLATILE])\n+    {\n+      warning (\"%s qualifier ignored on asm\",\n+\t       IDENTIFIER_POINTER (cv_qualifier));\n+      cv_qualifier = NULL_TREE;\n+    }\n+\n+  /* We can remove output conversions that change the type,\n+     but not the mode.  */\n+  for (tail = outputs; tail; tail = TREE_CHAIN (tail))\n     {\n       tree output = TREE_VALUE (tail);\n \n-      /* We can remove conversions that just change the type, not the mode.  */\n       STRIP_NOPS (output);\n-      o[i] = output;\n+      TREE_VALUE (tail) = output;\n \n       /* Allow conversions as LHS here.  build_modify_expr as called below\n \t will do the right thing with them.  */\n@@ -6350,29 +6352,54 @@ c_expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \t     || TREE_CODE (output) == FIX_CEIL_EXPR)\n \toutput = TREE_OPERAND (output, 0);\n \n-      if (last_tree)\n-\tlvalue_or_else (o[i], \"invalid lvalue in asm statement\");\n+      lvalue_or_else (TREE_VALUE (tail), \"invalid lvalue in asm statement\");\n+    }\n+\n+  /* Remove output conversions that change the type but not the mode.  */\n+  for (tail = outputs; tail; tail = TREE_CHAIN (tail))\n+    {\n+      tree output = TREE_VALUE (tail);\n+      STRIP_NOPS (output);\n+      TREE_VALUE (tail) = output;\n     }\n \n-  /* Perform default conversions on array and function inputs.  */\n-  /* Don't do this for other types--\n-     it would screw up operands expected to be in memory.  */\n-  for (i = 0, tail = inputs; tail; tail = TREE_CHAIN (tail), i++)\n+  /* Perform default conversions on array and function inputs. \n+     Don't do this for other types as it would screw up operands\n+     expected to be in memory.  */\n+  for (tail = inputs; tail; tail = TREE_CHAIN (tail))\n     if (TREE_CODE (TREE_TYPE (TREE_VALUE (tail))) == ARRAY_TYPE\n \t|| TREE_CODE (TREE_TYPE (TREE_VALUE (tail))) == FUNCTION_TYPE)\n       TREE_VALUE (tail) = default_conversion (TREE_VALUE (tail));\n \n-  if (last_tree)\n-    {\n-      add_stmt (build_stmt (ASM_STMT, \n-\t\t\t    vol ? ridpointers[(int) RID_VOLATILE] : NULL_TREE,\n-\t\t\t    string, outputs, inputs, clobbers));\n-      return;\n-    }\n+  return add_stmt (build_stmt (ASM_STMT, cv_qualifier, string,\n+\t\t\t       outputs, inputs, clobbers));\n+}\n+\n+/* Expand an ASM statement with operands, handling output operands\n+   that are not variables or INDIRECT_REFS by transforming such\n+   cases into cases that expand_asm_operands can handle.\n+\n+   Arguments are same as for expand_asm_operands.  */\n+\n+void\n+c_expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n+     tree string, outputs, inputs, clobbers;\n+     int vol;\n+     const char *filename;\n+     int line;\n+{\n+  int noutputs = list_length (outputs);\n+  register int i;\n+  /* o[I] is the place that output number I should be written.  */\n+  register tree *o = (tree *) alloca (noutputs * sizeof (tree));\n+  register tree tail;\n+\n+  /* Record the contents of OUTPUTS before it is modified.  */\n+  for (i = 0, tail = outputs; tail; tail = TREE_CHAIN (tail), i++)\n+    o[i] = TREE_VALUE (tail);\n \n-  /* Generate the ASM_OPERANDS insn;\n-     store into the TREE_VALUEs of OUTPUTS some trees for\n-     where the values were actually stored.  */\n+  /* Generate the ASM_OPERANDS insn; store into the TREE_VALUEs of\n+     OUTPUTS some trees for where the values were actually stored.  */\n   expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line);\n \n   /* Copy all the intermediate outputs into the specified outputs.  */\n@@ -6410,7 +6437,7 @@ c_expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n    RETVAL is the expression for what to return,\n    or a null pointer for `return;' with no value.  */\n \n-void\n+tree\n c_expand_return (retval)\n      tree retval;\n {\n@@ -6440,7 +6467,7 @@ c_expand_return (retval)\n       tree inner;\n \n       if (t == error_mark_node)\n-\treturn;\n+\treturn NULL_TREE;\n \n       inner = t = convert (TREE_TYPE (res), t);\n \n@@ -6499,7 +6526,7 @@ c_expand_return (retval)\n       current_function_returns_value = 1;\n     }\n \n- add_stmt (build_return_stmt (retval));\n+ return add_stmt (build_return_stmt (retval));\n }\n \f\n struct c_switch {\n@@ -6581,20 +6608,27 @@ c_start_case (exp)\n \n /* Process a case label.  */\n \n-void\n+tree\n do_case (low_value, high_value)\n      tree low_value;\n      tree high_value;\n {\n+  tree label = NULL_TREE;\n+\n   if (switch_stack)\n-    c_add_case_label (switch_stack->cases, \n-\t\t      SWITCH_COND (switch_stack->switch_stmt), \n-\t\t      low_value, \n-\t\t      high_value);\n+    {\n+      label = c_add_case_label (switch_stack->cases, \n+\t\t\t\tSWITCH_COND (switch_stack->switch_stmt), \n+\t\t\t\tlow_value, high_value);\n+      if (label == error_mark_node)\n+\tlabel = NULL_TREE;\n+    }\n   else if (low_value)\n     error (\"case label not within a switch statement\");\n   else\n     error (\"`default' label not within a switch statement\");\n+\n+  return label;\n }\n \n /* Finish the switch statement.  */"}]}