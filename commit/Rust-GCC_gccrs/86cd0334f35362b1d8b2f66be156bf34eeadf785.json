{"sha": "86cd0334f35362b1d8b2f66be156bf34eeadf785", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODZjZDAzMzRmMzUzNjJiMWQ4YjJmNjZiZTE1NmJmMzRlZWFkZjc4NQ==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2017-03-01T09:37:27Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2017-03-01T09:37:27Z"}, "message": "[PR 78140] Reuse same IPA bits and VR info\n\n2017-03-01  Martin Jambor  <mjambor@suse.cz>\n\n\tPR lto/78140\n\t* ipa-prop.h (ipa_bits): Removed field known.\n\t(ipa_jump_func): Removed field vr_known.  Changed fields bits and m_vr\n\tto pointers.  Adjusted their comments to warn about their sharing.\n\t(ipcp_transformation_summary): Change bits to a vector of pointers.\n\t(ipa_check_create_edge_args): Moved to ipa-prop.c, declare.\n\t(ipa_get_ipa_bits_for_value): Declare.\n\t* tree-vrp.h (value_range): Mark as GTY((for_user)).\n\t* ipa-prop.c (ipa_bit_ggc_hash_traits): New.\n\t(ipa_bits_hash_table): Likewise.\n\t(ipa_vr_ggc_hash_traits): Likewise.\n\t(ipa_vr_hash_table): Likewise.\n\t(ipa_print_node_jump_functions_for_edge): Adjust for bits and m_vr\n\tbeing pointers and vr_known being removed.\n\t(ipa_set_jf_unknown): Likewise.\n\t(ipa_get_ipa_bits_for_value): New function.\n\t(ipa_set_jfunc_bits): Likewise.\n\t(ipa_get_value_range): New overloaded functions.\n\t(ipa_set_jfunc_vr): Likewise.\n\t(ipa_compute_jump_functions_for_edge): Use the above functions to\n\tconstruct bits and vr parts of jump functions.\n\t(ipa_check_create_edge_args): Move here from ipa-prop.h, also allocate\n\tipa_bits_hash_table and ipa_vr_hash_table if they do not already\n\texist.\n\t(ipcp_grow_transformations_if_necessary): Also allocate\n\tipa_bits_hash_table and ipa_vr_hash_table if they do not already\n\texist.\n\t(ipa_node_params_t::duplicate): Do not copy bits, just pointers to\n\tthem.  Fix too long lines.\n\t(ipa_write_jump_function): Adjust for bits and m_vr being pointers and\n\tvr_known being removed.\n\t(ipa_read_jump_function): Use new setter functions to construct bits\n\tand vr parts of jump functions or set them to NULL.\n\t(write_ipcp_transformation_info): Adjust for bits being pointers.\n\t(read_ipcp_transformation_info): Likewise.\n\t(ipcp_update_bits): Likewise.  Fix excessively long lines a trailing\n\tspace.\n\tInclude gt-ipa-prop.h.\n\t* ipa-cp.c (propagate_bits_across_jump_function): Adjust for bits\n\tbeing pointers.\n\t(ipcp_store_bits_results): Likewise.\n\t(propagate_vr_across_jump_function): Adjust for m_vr being a pointer.\n\tDo not write to existing jump functions but use a temporary instead.\n\nFrom-SVN: r245805", "tree": {"sha": "4d7b87658339c1baa4b04b11f267feca63b33528", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d7b87658339c1baa4b04b11f267feca63b33528"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86cd0334f35362b1d8b2f66be156bf34eeadf785", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86cd0334f35362b1d8b2f66be156bf34eeadf785", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86cd0334f35362b1d8b2f66be156bf34eeadf785", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86cd0334f35362b1d8b2f66be156bf34eeadf785/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "42132674e5c9e7978a7d7d9283682f89639e236e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42132674e5c9e7978a7d7d9283682f89639e236e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42132674e5c9e7978a7d7d9283682f89639e236e"}], "stats": {"total": 510, "additions": 365, "deletions": 145}, "files": [{"sha": "087e4cf3b5458615549ff946f90cd0fbb7d3fa59", "filename": "gcc/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86cd0334f35362b1d8b2f66be156bf34eeadf785/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86cd0334f35362b1d8b2f66be156bf34eeadf785/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=86cd0334f35362b1d8b2f66be156bf34eeadf785", "patch": "@@ -1,3 +1,49 @@\n+2017-03-01  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR lto/78140\n+\t* ipa-prop.h (ipa_bits): Removed field known.\n+\t(ipa_jump_func): Removed field vr_known.  Changed fields bits and m_vr\n+\tto pointers.  Adjusted their comments to warn about their sharing.\n+\t(ipcp_transformation_summary): Change bits to a vector of pointers.\n+\t(ipa_check_create_edge_args): Moved to ipa-prop.c, declare.\n+\t(ipa_get_ipa_bits_for_value): Declare.\n+\t* tree-vrp.h (value_range): Mark as GTY((for_user)).\n+\t* ipa-prop.c (ipa_bit_ggc_hash_traits): New.\n+\t(ipa_bits_hash_table): Likewise.\n+\t(ipa_vr_ggc_hash_traits): Likewise.\n+\t(ipa_vr_hash_table): Likewise.\n+\t(ipa_print_node_jump_functions_for_edge): Adjust for bits and m_vr\n+\tbeing pointers and vr_known being removed.\n+\t(ipa_set_jf_unknown): Likewise.\n+\t(ipa_get_ipa_bits_for_value): New function.\n+\t(ipa_set_jfunc_bits): Likewise.\n+\t(ipa_get_value_range): New overloaded functions.\n+\t(ipa_set_jfunc_vr): Likewise.\n+\t(ipa_compute_jump_functions_for_edge): Use the above functions to\n+\tconstruct bits and vr parts of jump functions.\n+\t(ipa_check_create_edge_args): Move here from ipa-prop.h, also allocate\n+\tipa_bits_hash_table and ipa_vr_hash_table if they do not already\n+\texist.\n+\t(ipcp_grow_transformations_if_necessary): Also allocate\n+\tipa_bits_hash_table and ipa_vr_hash_table if they do not already\n+\texist.\n+\t(ipa_node_params_t::duplicate): Do not copy bits, just pointers to\n+\tthem.  Fix too long lines.\n+\t(ipa_write_jump_function): Adjust for bits and m_vr being pointers and\n+\tvr_known being removed.\n+\t(ipa_read_jump_function): Use new setter functions to construct bits\n+\tand vr parts of jump functions or set them to NULL.\n+\t(write_ipcp_transformation_info): Adjust for bits being pointers.\n+\t(read_ipcp_transformation_info): Likewise.\n+\t(ipcp_update_bits): Likewise.  Fix excessively long lines a trailing\n+\tspace.\n+\tInclude gt-ipa-prop.h.\n+\t* ipa-cp.c (propagate_bits_across_jump_function): Adjust for bits\n+\tbeing pointers.\n+\t(ipcp_store_bits_results): Likewise.\n+\t(propagate_vr_across_jump_function): Adjust for m_vr being a pointer.\n+\tDo not write to existing jump functions but use a temporary instead.\n+\n 2017-03-01  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/79681"}, {"sha": "16e7e2216ab96489a7985e0280cc637ff1954ea2", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86cd0334f35362b1d8b2f66be156bf34eeadf785/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86cd0334f35362b1d8b2f66be156bf34eeadf785/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=86cd0334f35362b1d8b2f66be156bf34eeadf785", "patch": "@@ -1819,8 +1819,8 @@ propagate_bits_across_jump_function (cgraph_edge *cs, int idx,\n \t and we store it in jump function during analysis stage.  */\n \n       if (src_lats->bits_lattice.bottom_p ()\n-\t  && jfunc->bits.known)\n-\treturn dest_lattice->meet_with (jfunc->bits.value, jfunc->bits.mask,\n+\t  && jfunc->bits)\n+\treturn dest_lattice->meet_with (jfunc->bits->value, jfunc->bits->mask,\n \t\t\t\t\tprecision);\n       else\n \treturn dest_lattice->meet_with (src_lats->bits_lattice, precision, sgn,\n@@ -1829,10 +1829,9 @@ propagate_bits_across_jump_function (cgraph_edge *cs, int idx,\n \n   else if (jfunc->type == IPA_JF_ANCESTOR)\n     return dest_lattice->set_to_bottom ();\n-\n-  else if (jfunc->bits.known)\n-    return dest_lattice->meet_with (jfunc->bits.value, jfunc->bits.mask, precision);\n-\n+  else if (jfunc->bits)\n+    return dest_lattice->meet_with (jfunc->bits->value, jfunc->bits->mask,\n+\t\t\t\t    precision);\n   else\n     return dest_lattice->set_to_bottom ();\n }\n@@ -1903,19 +1902,21 @@ propagate_vr_across_jump_function (cgraph_edge *cs, ipa_jump_func *jfunc,\n \t  val = fold_convert (param_type, val);\n \t  if (TREE_OVERFLOW_P (val))\n \t    val = drop_tree_overflow (val);\n-\t  jfunc->vr_known = true;\n-\t  jfunc->m_vr.type = VR_RANGE;\n-\t  jfunc->m_vr.min = val;\n-\t  jfunc->m_vr.max = val;\n-\t  return dest_lat->meet_with (&jfunc->m_vr);\n+\n+\t  value_range tmpvr;\n+\t  memset (&tmpvr, 0, sizeof (tmpvr));\n+\t  tmpvr.type = VR_RANGE;\n+\t  tmpvr.min = val;\n+\t  tmpvr.max = val;\n+\t  return dest_lat->meet_with (&tmpvr);\n \t}\n     }\n \n   value_range vr;\n-  if (jfunc->vr_known\n-      && ipa_vr_operation_and_type_effects (&vr, &jfunc->m_vr, NOP_EXPR,\n+  if (jfunc->m_vr\n+      && ipa_vr_operation_and_type_effects (&vr, jfunc->m_vr, NOP_EXPR,\n \t\t\t\t\t    param_type,\n-\t\t\t\t\t    TREE_TYPE (jfunc->m_vr.min)))\n+\t\t\t\t\t    TREE_TYPE (jfunc->m_vr->min)))\n     return dest_lat->meet_with (&vr);\n   else\n     return dest_lat->set_to_bottom ();\n@@ -4870,19 +4871,17 @@ ipcp_store_bits_results (void)\n       for (unsigned i = 0; i < count; i++)\n \t{\n \t  ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n-\t  ipa_bits bits_jfunc;\n+\t  ipa_bits *jfbits;\n \n \t  if (plats->bits_lattice.constant_p ())\n-\t    {\n-\t      bits_jfunc.known = true;\n-\t      bits_jfunc.value = plats->bits_lattice.get_value ();\n-\t      bits_jfunc.mask = plats->bits_lattice.get_mask ();\n-\t    }\n+\t    jfbits\n+\t      = ipa_get_ipa_bits_for_value (plats->bits_lattice.get_value (),\n+\t\t\t\t\t    plats->bits_lattice.get_mask ());\n \t  else\n-\t    bits_jfunc.known = false;\n+\t    jfbits = NULL;\n \n-\t  ts->bits->quick_push (bits_jfunc);\n-\t  if (!dump_file || !bits_jfunc.known)\n+\t  ts->bits->quick_push (jfbits);\n+\t  if (!dump_file || !jfbits)\n \t    continue;\n \t  if (!dumped_sth)\n \t    {\n@@ -4891,9 +4890,9 @@ ipcp_store_bits_results (void)\n \t      dumped_sth = true;\n \t    }\n \t  fprintf (dump_file, \" param %i: value = \", i);\n-\t  print_hex (bits_jfunc.value, dump_file);\n+\t  print_hex (jfbits->value, dump_file);\n \t  fprintf (dump_file, \", mask = \");\n-\t  print_hex (bits_jfunc.mask, dump_file);\n+\t  print_hex (jfbits->mask, dump_file);\n \t  fprintf (dump_file, \"\\n\");\n \t}\n     }"}, {"sha": "d519cdfcbabae3578ffa62caf870941a6be47fef", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 281, "deletions": 100, "changes": 381, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86cd0334f35362b1d8b2f66be156bf34eeadf785/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86cd0334f35362b1d8b2f66be156bf34eeadf785/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=86cd0334f35362b1d8b2f66be156bf34eeadf785", "patch": "@@ -60,6 +60,93 @@ vec<ipcp_transformation_summary, va_gc> *ipcp_transformations;\n /* Vector where the parameter infos are actually stored. */\n vec<ipa_edge_args, va_gc> *ipa_edge_args_vector;\n \n+/* Traits for a hash table for reusing already existing ipa_bits. */\n+\n+struct ipa_bit_ggc_hash_traits : public ggc_cache_remove <ipa_bits *>\n+{\n+  typedef ipa_bits *value_type;\n+  typedef ipa_bits *compare_type;\n+  static hashval_t\n+  hash (const ipa_bits *p)\n+  {\n+    hashval_t t = (hashval_t) p->value.to_shwi ();\n+    return iterative_hash_host_wide_int (p->mask.to_shwi (), t);\n+  }\n+  static bool\n+  equal (const ipa_bits *a, const ipa_bits *b)\n+    {\n+      return a->value == b->value && a->mask == b->mask;\n+    }\n+  static void\n+  mark_empty (ipa_bits *&p)\n+    {\n+      p = NULL;\n+    }\n+  static bool\n+  is_empty (const ipa_bits *p)\n+    {\n+      return p == NULL;\n+    }\n+  static bool\n+  is_deleted (const ipa_bits *p)\n+    {\n+      return p == reinterpret_cast<const ipa_bits *> (1);\n+    }\n+  static void\n+  mark_deleted (ipa_bits *&p)\n+    {\n+      p = reinterpret_cast<ipa_bits *> (1);\n+    }\n+};\n+\n+/* Hash table for avoid repeated allocations of equal ipa_bits.  */\n+static GTY ((cache)) hash_table<ipa_bit_ggc_hash_traits> *ipa_bits_hash_table;\n+\n+/* Traits for a hash table for reusing value_ranges used for IPA.  Note that\n+   the equiv bitmap is not hashed and is expected to be NULL.  */\n+\n+struct ipa_vr_ggc_hash_traits : public ggc_cache_remove <value_range *>\n+{\n+  typedef value_range *value_type;\n+  typedef value_range *compare_type;\n+  static hashval_t\n+  hash (const value_range *p)\n+  {\n+    gcc_checking_assert (!p->equiv);\n+    hashval_t t = (hashval_t) p->type;\n+    t = iterative_hash_expr (p->min, t);\n+    return iterative_hash_expr (p->max, t);\n+  }\n+  static bool\n+  equal (const value_range *a, const value_range *b)\n+    {\n+      return a->type == b->type && a->min == b->min && a->max == b->max;\n+    }\n+  static void\n+  mark_empty (value_range *&p)\n+    {\n+      p = NULL;\n+    }\n+  static bool\n+  is_empty (const value_range *p)\n+    {\n+      return p == NULL;\n+    }\n+  static bool\n+  is_deleted (const value_range *p)\n+    {\n+      return p == reinterpret_cast<const value_range *> (1);\n+    }\n+  static void\n+  mark_deleted (value_range *&p)\n+    {\n+      p = reinterpret_cast<value_range *> (1);\n+    }\n+};\n+\n+/* Hash table for avoid repeated allocations of equal value_ranges.  */\n+static GTY ((cache)) hash_table<ipa_vr_ggc_hash_traits> *ipa_vr_hash_table;\n+\n /* Holders of ipa cgraph hooks: */\n static struct cgraph_edge_hook_list *edge_removal_hook_holder;\n static struct cgraph_2edge_hook_list *edge_duplication_hook_holder;\n@@ -298,23 +385,25 @@ ipa_print_node_jump_functions_for_edge (FILE *f, struct cgraph_edge *cs)\n \t  ctx->dump (dump_file);\n \t}\n \n-      if (jump_func->bits.known)\n+      if (jump_func->bits)\n \t{\n-\t  fprintf (f, \"         value: \"); print_hex (jump_func->bits.value, f);\n-\t  fprintf (f, \", mask: \"); print_hex (jump_func->bits.mask, f);\n+\t  fprintf (f, \"         value: \");\n+\t  print_hex (jump_func->bits->value, f);\n+\t  fprintf (f, \", mask: \");\n+\t  print_hex (jump_func->bits->mask, f);\n \t  fprintf (f, \"\\n\");\n \t}\n       else\n \tfprintf (f, \"         Unknown bits\\n\");\n \n-      if (jump_func->vr_known)\n+      if (jump_func->m_vr)\n \t{\n \t  fprintf (f, \"         VR  \");\n \t  fprintf (f, \"%s[\",\n-\t\t   (jump_func->m_vr.type == VR_ANTI_RANGE) ? \"~\" : \"\");\n-\t  print_decs (jump_func->m_vr.min, f);\n+\t\t   (jump_func->m_vr->type == VR_ANTI_RANGE) ? \"~\" : \"\");\n+\t  print_decs (jump_func->m_vr->min, f);\n \t  fprintf (f, \", \");\n-\t  print_decs (jump_func->m_vr.max, f);\n+\t  print_decs (jump_func->m_vr->max, f);\n \t  fprintf (f, \"]\\n\");\n \t}\n       else\n@@ -397,8 +486,8 @@ static void\n ipa_set_jf_unknown (struct ipa_jump_func *jfunc)\n {\n   jfunc->type = IPA_JF_UNKNOWN;\n-  jfunc->bits.known = false;\n-  jfunc->vr_known = false;\n+  jfunc->bits = NULL;\n+  jfunc->m_vr = NULL;\n }\n \n /* Set JFUNC to be a copy of another jmp (to be used by jump function\n@@ -1658,6 +1747,91 @@ ipa_get_callee_param_type (struct cgraph_edge *e, int i)\n   return NULL;\n }\n \n+/* Return ipa_bits with VALUE and MASK values, which can be either a newly\n+   allocated structure or a previously existing one shared with other jump\n+   functions and/or transformation summaries.  */\n+\n+ipa_bits *\n+ipa_get_ipa_bits_for_value (const widest_int &value, const widest_int &mask)\n+{\n+  ipa_bits tmp;\n+  tmp.value = value;\n+  tmp.mask = mask;\n+\n+  ipa_bits **slot = ipa_bits_hash_table->find_slot (&tmp, INSERT);\n+  if (*slot)\n+    return *slot;\n+\n+  ipa_bits *res = ggc_alloc<ipa_bits> ();\n+  res->value = value;\n+  res->mask = mask;\n+  *slot = res;\n+\n+  return res;\n+}\n+\n+/* Assign to JF a pointer to ipa_bits structure with VALUE and MASK.  Use hash\n+   table in order to avoid creating multiple same ipa_bits structures.  */\n+\n+static void\n+ipa_set_jfunc_bits (ipa_jump_func *jf, const widest_int &value,\n+\t\t    const widest_int &mask)\n+{\n+  jf->bits = ipa_get_ipa_bits_for_value (value, mask);\n+}\n+\n+/* Return a pointer to a value_range just like *TMP, but either find it in\n+   ipa_vr_hash_table or allocate it in GC memory.  TMP->equiv must be NULL.  */\n+\n+static value_range *\n+ipa_get_value_range (value_range *tmp)\n+{\n+  value_range **slot = ipa_vr_hash_table->find_slot (tmp, INSERT);\n+  if (*slot)\n+    return *slot;\n+\n+  value_range *vr = ggc_alloc<value_range> ();\n+  *vr = *tmp;\n+  *slot = vr;\n+\n+  return vr;\n+}\n+\n+/* Return a pointer to a value range consisting of TYPE, MIN, MAX and an empty\n+   equiv set. Use hash table in order to avoid creating multiple same copies of\n+   value_ranges.  */\n+\n+static value_range *\n+ipa_get_value_range (enum value_range_type type, tree min, tree max)\n+{\n+  value_range tmp;\n+  tmp.type = type;\n+  tmp.min = min;\n+  tmp.max = max;\n+  tmp.equiv = NULL;\n+  return ipa_get_value_range (&tmp);\n+}\n+\n+/* Assign to JF a pointer to a value_range structure with TYPE, MIN and MAX and\n+   a NULL equiv bitmap.  Use hash table in order to avoid creating multiple\n+   same value_range structures.  */\n+\n+static void\n+ipa_set_jfunc_vr (ipa_jump_func *jf, enum value_range_type type,\n+\t\t  tree min, tree max)\n+{\n+  jf->m_vr = ipa_get_value_range (type, min, max);\n+}\n+\n+/* Assign to JF a pointer to a value_range just liek TMP but either fetch a\n+   copy from ipa_vr_hash_table or allocate a new on in GC memory.  */\n+\n+static void\n+ipa_set_jfunc_vr (ipa_jump_func *jf, value_range *tmp)\n+{\n+  jf->m_vr = ipa_get_value_range (tmp);\n+}\n+\n /* Compute jump function for all arguments of callsite CS and insert the\n    information in the jump_functions array in the ipa_edge_args corresponding\n    to this callsite.  */\n@@ -1714,14 +1888,11 @@ ipa_compute_jump_functions_for_edge (struct ipa_func_body_info *fbi,\n \n \t  if (addr_nonzero)\n \t    {\n-\t      jfunc->vr_known = true;\n-\t      jfunc->m_vr.type = VR_ANTI_RANGE;\n-\t      jfunc->m_vr.min = build_int_cst (TREE_TYPE (arg), 0);\n-\t      jfunc->m_vr.max = build_int_cst (TREE_TYPE (arg), 0);\n-\t      jfunc->m_vr.equiv = NULL;\n+\t      tree z = build_int_cst (TREE_TYPE (arg), 0);\n+\t      ipa_set_jfunc_vr (jfunc, VR_ANTI_RANGE, z, z);\n \t    }\n \t  else\n-\t    gcc_assert (!jfunc->vr_known);\n+\t    gcc_assert (!jfunc->m_vr);\n \t}\n       else\n \t{\n@@ -1732,56 +1903,48 @@ ipa_compute_jump_functions_for_edge (struct ipa_func_body_info *fbi,\n \t      && (type = get_range_info (arg, &min, &max))\n \t      && (type == VR_RANGE || type == VR_ANTI_RANGE))\n \t    {\n-\t      value_range vr;\n-\n-\t      vr.type = type;\n-\t      vr.min = wide_int_to_tree (TREE_TYPE (arg), min);\n-\t      vr.max = wide_int_to_tree (TREE_TYPE (arg), max);\n-\t      vr.equiv = NULL;\n-\t      extract_range_from_unary_expr (&jfunc->m_vr,\n-\t\t\t\t\t     NOP_EXPR,\n-\t\t\t\t\t     param_type,\n-\t\t\t\t\t     &vr, TREE_TYPE (arg));\n-\t      if (jfunc->m_vr.type == VR_RANGE\n-\t\t  || jfunc->m_vr.type == VR_ANTI_RANGE)\n-\t\tjfunc->vr_known = true;\n+\t      value_range tmpvr,resvr;\n+\n+\t      tmpvr.type = type;\n+\t      tmpvr.min = wide_int_to_tree (TREE_TYPE (arg), min);\n+\t      tmpvr.max = wide_int_to_tree (TREE_TYPE (arg), max);\n+\t      tmpvr.equiv = NULL;\n+\t      memset (&resvr, 0, sizeof (resvr));\n+\t      extract_range_from_unary_expr (&resvr, NOP_EXPR, param_type,\n+\t\t\t\t\t     &tmpvr, TREE_TYPE (arg));\n+\t      if (resvr.type == VR_RANGE || resvr.type == VR_ANTI_RANGE)\n+\t\tipa_set_jfunc_vr (jfunc, &resvr);\n \t      else\n-\t\tjfunc->vr_known = false;\n+\t\tgcc_assert (!jfunc->m_vr);\n \t    }\n \t  else\n-\t    gcc_assert (!jfunc->vr_known);\n+\t    gcc_assert (!jfunc->m_vr);\n \t}\n \n       if (INTEGRAL_TYPE_P (TREE_TYPE (arg))\n \t  && (TREE_CODE (arg) == SSA_NAME || TREE_CODE (arg) == INTEGER_CST))\n \t{\n-\t  jfunc->bits.known = true;\n-\t  \n \t  if (TREE_CODE (arg) == SSA_NAME)\n-\t    {\n-\t      jfunc->bits.value = 0;\n-\t      jfunc->bits.mask = widest_int::from (get_nonzero_bits (arg),\n-\t\t\t\t\t\t   TYPE_SIGN (TREE_TYPE (arg)));\n-\t    }\n+\t    ipa_set_jfunc_bits (jfunc, 0,\n+\t\t\t\twidest_int::from (get_nonzero_bits (arg),\n+\t\t\t\t\t\t  TYPE_SIGN (TREE_TYPE (arg))));\n \t  else\n-\t    {\n-\t      jfunc->bits.value = wi::to_widest (arg);\n-\t      jfunc->bits.mask = 0;\n-\t    }\n+\t    ipa_set_jfunc_bits (jfunc, wi::to_widest (arg), 0);\n \t}\n       else if (POINTER_TYPE_P (TREE_TYPE (arg)))\n \t{\n \t  unsigned HOST_WIDE_INT bitpos;\n \t  unsigned align;\n \n-\t  jfunc->bits.known = true;\n \t  get_pointer_alignment_1 (arg, &align, &bitpos);\n-\t  jfunc->bits.mask = wi::mask<widest_int>(TYPE_PRECISION (TREE_TYPE (arg)), false)\n-\t\t\t     .and_not (align / BITS_PER_UNIT - 1);\n-\t  jfunc->bits.value = bitpos / BITS_PER_UNIT;\n+\t  widest_int mask\n+\t    = wi::mask<widest_int>(TYPE_PRECISION (TREE_TYPE (arg)), false)\n+\t    .and_not (align / BITS_PER_UNIT - 1);\n+\t  widest_int value = bitpos / BITS_PER_UNIT;\n+\t  ipa_set_jfunc_bits (jfunc, value, mask);\n \t}\n       else\n-\tgcc_assert (!jfunc->bits.known);\n+\tgcc_assert (!jfunc->bits);\n \n       if (is_gimple_ip_invariant (arg)\n \t  || (VAR_P (arg)\n@@ -3545,6 +3708,22 @@ ipa_propagate_indirect_call_infos (struct cgraph_edge *cs,\n   return changed;\n }\n \n+/* Ensure that array of edge arguments infos is big enough to accommodate a\n+   structure for all edges and reallocates it if not.  Also, allocate\n+   associated hash tables is they do not already exist.  */\n+\n+void\n+ipa_check_create_edge_args (void)\n+{\n+  if (vec_safe_length (ipa_edge_args_vector)\n+      <= (unsigned) symtab->edges_max_uid)\n+    vec_safe_grow_cleared (ipa_edge_args_vector, symtab->edges_max_uid + 1);\n+  if (!ipa_bits_hash_table)\n+    ipa_bits_hash_table = hash_table<ipa_bit_ggc_hash_traits>::create_ggc (37);\n+  if (!ipa_vr_hash_table)\n+    ipa_vr_hash_table = hash_table<ipa_vr_ggc_hash_traits>::create_ggc (37);\n+}\n+\n /* Frees all dynamically allocated structures that the argument info points\n    to.  */\n \n@@ -3581,14 +3760,19 @@ ipa_free_all_node_params (void)\n   ipa_node_params_sum = NULL;\n }\n \n-/* Grow ipcp_transformations if necessary.  */\n+/* Grow ipcp_transformations if necessary.  Also allocate any necessary hash\n+   tables if they do not already exist.  */\n \n void\n ipcp_grow_transformations_if_necessary (void)\n {\n   if (vec_safe_length (ipcp_transformations)\n       <= (unsigned) symtab->cgraph_max_uid)\n     vec_safe_grow_cleared (ipcp_transformations, symtab->cgraph_max_uid + 1);\n+  if (!ipa_bits_hash_table)\n+    ipa_bits_hash_table = hash_table<ipa_bit_ggc_hash_traits>::create_ggc (37);\n+  if (!ipa_vr_hash_table)\n+    ipa_vr_hash_table = hash_table<ipa_vr_ggc_hash_traits>::create_ggc (37);\n }\n \n /* Set the aggregate replacements of NODE to be AGGVALS.  */\n@@ -3775,12 +3959,18 @@ ipa_node_params_t::duplicate(cgraph_node *src, cgraph_node *dst,\n       ipa_set_node_agg_value_chain (dst, new_av);\n     }\n \n-  ipcp_transformation_summary *src_trans = ipcp_get_transformation_summary (src);\n+  ipcp_transformation_summary *src_trans\n+    = ipcp_get_transformation_summary (src);\n \n   if (src_trans)\n     {\n       ipcp_grow_transformations_if_necessary ();\n       src_trans = ipcp_get_transformation_summary (src);\n+      ipcp_transformation_summary *dst_trans\n+\t= ipcp_get_transformation_summary (dst);\n+\n+      dst_trans->bits = vec_safe_copy (src_trans->bits);\n+\n       const vec<ipa_vr, va_gc> *src_vr = src_trans->m_vr;\n       vec<ipa_vr, va_gc> *&dst_vr\n \t= ipcp_get_transformation_summary (dst)->m_vr;\n@@ -3791,18 +3981,6 @@ ipa_node_params_t::duplicate(cgraph_node *src, cgraph_node *dst,\n \t    dst_vr->quick_push ((*src_vr)[i]);\n \t}\n     }\n-\n-  if (src_trans && vec_safe_length (src_trans->bits) > 0)\n-    {\n-      ipcp_grow_transformations_if_necessary ();\n-      src_trans = ipcp_get_transformation_summary (src);\n-      const vec<ipa_bits, va_gc> *src_bits = src_trans->bits;\n-      vec<ipa_bits, va_gc> *&dst_bits\n-\t= ipcp_get_transformation_summary (dst)->bits;\n-      vec_safe_reserve_exact (dst_bits, src_bits->length ());\n-      for (unsigned i = 0; i < src_bits->length (); ++i)\n-\tdst_bits->quick_push ((*src_bits)[i]);\n-    }\n }\n \n /* Register our cgraph hooks if they are not already there.  */\n@@ -4718,21 +4896,21 @@ ipa_write_jump_function (struct output_block *ob,\n     }\n \n   bp = bitpack_create (ob->main_stream);\n-  bp_pack_value (&bp, jump_func->bits.known, 1);\n+  bp_pack_value (&bp, !!jump_func->bits, 1);\n   streamer_write_bitpack (&bp);\n-  if (jump_func->bits.known)\n+  if (jump_func->bits)\n     {\n-      streamer_write_widest_int (ob, jump_func->bits.value);\n-      streamer_write_widest_int (ob, jump_func->bits.mask);\n+      streamer_write_widest_int (ob, jump_func->bits->value);\n+      streamer_write_widest_int (ob, jump_func->bits->mask);\n     }\n-  bp_pack_value (&bp, jump_func->vr_known, 1);\n+  bp_pack_value (&bp, !!jump_func->m_vr, 1);\n   streamer_write_bitpack (&bp);\n-  if (jump_func->vr_known)\n+  if (jump_func->m_vr)\n     {\n       streamer_write_enum (ob->main_stream, value_rang_type,\n-\t\t\t   VR_LAST, jump_func->m_vr.type);\n-      stream_write_tree (ob, jump_func->m_vr.min, true);\n-      stream_write_tree (ob, jump_func->m_vr.max, true);\n+\t\t\t   VR_LAST, jump_func->m_vr->type);\n+      stream_write_tree (ob, jump_func->m_vr->min, true);\n+      stream_write_tree (ob, jump_func->m_vr->max, true);\n     }\n }\n \n@@ -4809,26 +4987,25 @@ ipa_read_jump_function (struct lto_input_block *ib,\n   bool bits_known = bp_unpack_value (&bp, 1);\n   if (bits_known)\n     {\n-      jump_func->bits.known = true;\n-      jump_func->bits.value = streamer_read_widest_int (ib);\n-      jump_func->bits.mask = streamer_read_widest_int (ib);\n+      widest_int value = streamer_read_widest_int (ib);\n+      widest_int mask = streamer_read_widest_int (ib);\n+      ipa_set_jfunc_bits (jump_func, value, mask);\n     }\n   else\n-    jump_func->bits.known = false;\n+    jump_func->bits = NULL;\n \n   struct bitpack_d vr_bp = streamer_read_bitpack (ib);\n   bool vr_known = bp_unpack_value (&vr_bp, 1);\n   if (vr_known)\n     {\n-      jump_func->vr_known = true;\n-      jump_func->m_vr.type = streamer_read_enum (ib,\n-\t\t\t\t\t\t value_range_type,\n-\t\t\t\t\t\t VR_LAST);\n-      jump_func->m_vr.min = stream_read_tree (ib, data_in);\n-      jump_func->m_vr.max = stream_read_tree (ib, data_in);\n+      enum value_range_type type = streamer_read_enum (ib, value_range_type,\n+\t\t\t\t\t\t       VR_LAST);\n+      tree min = stream_read_tree (ib, data_in);\n+      tree max = stream_read_tree (ib, data_in);\n+      ipa_set_jfunc_vr (jump_func, type, min, max);\n     }\n   else\n-    jump_func->vr_known = false;\n+    jump_func->m_vr = NULL;\n }\n \n /* Stream out parts of cgraph_indirect_call_info corresponding to CS that are\n@@ -5207,14 +5384,14 @@ write_ipcp_transformation_info (output_block *ob, cgraph_node *node)\n \n       for (unsigned i = 0; i < count; ++i)\n \t{\n-\t  const ipa_bits& bits_jfunc = (*ts->bits)[i];\n+\t  const ipa_bits *bits_jfunc = (*ts->bits)[i];\n \t  struct bitpack_d bp = bitpack_create (ob->main_stream);\n-\t  bp_pack_value (&bp, bits_jfunc.known, 1);\n+\t  bp_pack_value (&bp, !!bits_jfunc, 1);\n \t  streamer_write_bitpack (&bp);\n-\t  if (bits_jfunc.known)\n+\t  if (bits_jfunc)\n \t    {\n-\t      streamer_write_widest_int (ob, bits_jfunc.value);\n-\t      streamer_write_widest_int (ob, bits_jfunc.mask);\n+\t      streamer_write_widest_int (ob, bits_jfunc->value);\n+\t      streamer_write_widest_int (ob, bits_jfunc->mask);\n \t    }\n \t}\n     }\n@@ -5281,13 +5458,14 @@ read_ipcp_transformation_info (lto_input_block *ib, cgraph_node *node,\n \n       for (i = 0; i < count; i++)\n \t{\n-\t  ipa_bits& bits_jfunc = (*ts->bits)[i];\n \t  struct bitpack_d bp = streamer_read_bitpack (ib);\n-\t  bits_jfunc.known = bp_unpack_value (&bp, 1);\n-\t  if (bits_jfunc.known)\n+\t  bool known = bp_unpack_value (&bp, 1);\n+\t  if (known)\n \t    {\n-\t      bits_jfunc.value = streamer_read_widest_int (ib);\n-\t      bits_jfunc.mask = streamer_read_widest_int (ib);\n+\t      ipa_bits *bits\n+\t\t= ipa_get_ipa_bits_for_value (streamer_read_widest_int (ib),\n+\t\t\t\t\t      streamer_read_widest_int (ib));\n+\t      (*ts->bits)[i] = bits;\n \t    }\n \t}\n     }\n@@ -5554,7 +5732,7 @@ ipcp_update_bits (struct cgraph_node *node)\n   if (!ts || vec_safe_length (ts->bits) == 0)\n     return;\n \n-  vec<ipa_bits, va_gc> &bits = *ts->bits;\n+  vec<ipa_bits *, va_gc> &bits = *ts->bits;\n   unsigned count = bits.length ();\n \n   for (unsigned i = 0; i < count; ++i, parm = next_parm)\n@@ -5566,19 +5744,20 @@ ipcp_update_bits (struct cgraph_node *node)\n       gcc_checking_assert (parm);\n       next_parm = DECL_CHAIN (parm);\n \n-      if (!bits[i].known\n-\t  || !(INTEGRAL_TYPE_P (TREE_TYPE (parm)) || POINTER_TYPE_P (TREE_TYPE (parm)))\n+      if (!bits[i]\n+\t  || !(INTEGRAL_TYPE_P (TREE_TYPE (parm))\n+\t       || POINTER_TYPE_P (TREE_TYPE (parm)))\n \t  || !is_gimple_reg (parm))\n-\tcontinue;       \n+\tcontinue;\n \n       tree ddef = ssa_default_def (DECL_STRUCT_FUNCTION (node->decl), parm);\n       if (!ddef)\n \tcontinue;\n \n       if (dump_file)\n \t{\n-\t  fprintf (dump_file, \"Adjusting mask for param %u to \", i); \n-\t  print_hex (bits[i].mask, dump_file);\n+\t  fprintf (dump_file, \"Adjusting mask for param %u to \", i);\n+\t  print_hex (bits[i]->mask, dump_file);\n \t  fprintf (dump_file, \"\\n\");\n \t}\n \n@@ -5587,14 +5766,14 @@ ipcp_update_bits (struct cgraph_node *node)\n \t  unsigned prec = TYPE_PRECISION (TREE_TYPE (ddef));\n \t  signop sgn = TYPE_SIGN (TREE_TYPE (ddef));\n \n-\t  wide_int nonzero_bits = wide_int::from (bits[i].mask, prec, UNSIGNED)\n-\t\t\t\t  | wide_int::from (bits[i].value, prec, sgn);\n+\t  wide_int nonzero_bits = wide_int::from (bits[i]->mask, prec, UNSIGNED)\n+\t\t\t\t  | wide_int::from (bits[i]->value, prec, sgn);\n \t  set_nonzero_bits (ddef, nonzero_bits);\n \t}\n       else\n \t{\n-\t  unsigned tem = bits[i].mask.to_uhwi ();\n-\t  unsigned HOST_WIDE_INT bitpos = bits[i].value.to_uhwi (); \n+\t  unsigned tem = bits[i]->mask.to_uhwi ();\n+\t  unsigned HOST_WIDE_INT bitpos = bits[i]->value.to_uhwi ();\n \t  unsigned align = tem & -tem;\n \t  unsigned misalign = bitpos & (align - 1);\n \n@@ -5757,3 +5936,5 @@ ipcp_transform_function (struct cgraph_node *node)\n   else\n     return TODO_update_ssa_only_virtuals;\n }\n+\n+#include \"gt-ipa-prop.h\""}, {"sha": "74234eb470debe001fb83195aec5a873ce73ff67", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86cd0334f35362b1d8b2f66be156bf34eeadf785/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86cd0334f35362b1d8b2f66be156bf34eeadf785/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=86cd0334f35362b1d8b2f66be156bf34eeadf785", "patch": "@@ -152,11 +152,10 @@ struct GTY(()) ipa_bits\n      Similar to ccp_lattice_t, if xth bit of mask is 0,\n      implies xth bit of value is constant.  */\n   widest_int mask;\n-  /* True if jump function is known.  */\n-  bool known;\n };\n \n /* Info about value ranges.  */\n+\n struct GTY(()) ipa_vr\n {\n   /* The data fields below are valid only if known is true.  */\n@@ -175,13 +174,15 @@ struct GTY (()) ipa_jump_func\n      description.  */\n   struct ipa_agg_jump_function agg;\n \n-  /* Information about zero/non-zero bits.  */\n-  struct ipa_bits bits;\n+  /* Information about zero/non-zero bits.  The pointed to structure is shared\n+     betweed different jump functions.  Use ipa_set_jfunc_bits to set this\n+     field.  */\n+  struct ipa_bits *bits;\n \n   /* Information about value range, containing valid data only when vr_known is\n-     true.  */\n-  value_range m_vr;\n-  bool vr_known;\n+     true.  The pointed to structure is shared betweed different jump\n+     functions.  Use ipa_set_jfunc_vr to set this field.  */\n+  struct value_range *m_vr;\n \n   enum jump_func_type type;\n   /* Represents a value of a jump function.  pass_through is used only in jump\n@@ -547,7 +548,7 @@ struct GTY(()) ipcp_transformation_summary\n   /* Linked list of known aggregate values.  */\n   ipa_agg_replacement_value *agg_values;\n   /* Known bits information.  */\n-  vec<ipa_bits, va_gc> *bits;\n+  vec<ipa_bits *, va_gc> *bits;\n   /* Value range information.  */\n   vec<ipa_vr, va_gc> *m_vr;\n };\n@@ -630,6 +631,7 @@ extern GTY(()) vec<ipa_edge_args, va_gc> *ipa_edge_args_vector;\n /* Creating and freeing ipa_node_params and ipa_edge_args.  */\n void ipa_create_all_node_params (void);\n void ipa_create_all_edge_args (void);\n+void ipa_check_create_edge_args (void);\n void ipa_free_edge_args_substructures (struct ipa_edge_args *);\n void ipa_free_all_node_params (void);\n void ipa_free_all_edge_args (void);\n@@ -651,17 +653,6 @@ ipa_check_create_node_params (void)\n \t ipa_node_params_t (symtab, true));\n }\n \n-/* This function ensures the array of edge arguments infos is big enough to\n-   accommodate a structure for all edges and reallocates it if not.  */\n-\n-static inline void\n-ipa_check_create_edge_args (void)\n-{\n-  if (vec_safe_length (ipa_edge_args_vector)\n-      <= (unsigned) symtab->edges_max_uid)\n-    vec_safe_grow_cleared (ipa_edge_args_vector, symtab->edges_max_uid + 1);\n-}\n-\n /* Returns true if the array of edge infos is large enough to accommodate an\n    info for EDGE.  The main purpose of this function is that debug dumping\n    function can check info availability without causing reallocations.  */\n@@ -703,6 +694,9 @@ tree ipa_get_indirect_edge_target (struct cgraph_edge *ie,\n struct cgraph_edge *ipa_make_edge_direct_to_target (struct cgraph_edge *, tree,\n \t\t\t\t\t\t    bool speculative = false);\n tree ipa_impossible_devirt_target (struct cgraph_edge *, tree);\n+ipa_bits *ipa_get_ipa_bits_for_value (const widest_int &value,\n+\t\t\t\t      const widest_int &mask);\n+\n \n /* Functions related to both.  */\n void ipa_analyze_node (struct cgraph_node *);"}, {"sha": "ef2c68a752beccaca91f58b0667060ad3df72c04", "filename": "gcc/tree-vrp.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86cd0334f35362b1d8b2f66be156bf34eeadf785/gcc%2Ftree-vrp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86cd0334f35362b1d8b2f66be156bf34eeadf785/gcc%2Ftree-vrp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.h?ref=86cd0334f35362b1d8b2f66be156bf34eeadf785", "patch": "@@ -24,7 +24,7 @@ enum value_range_type { VR_UNDEFINED, VR_RANGE,\n \n /* Range of values that can be associated with an SSA_NAME after VRP\n    has executed.  */\n-struct GTY(()) value_range\n+struct GTY((for_user)) value_range\n {\n   /* Lattice value represented by this range.  */\n   enum value_range_type type;"}]}