{"sha": "4324a55c06f5e18cbcf6b1a1180435187cfd9876", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDMyNGE1NWMwNmY1ZTE4Y2JjZjZiMWExMTgwNDM1MTg3Y2ZkOTg3Ng==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2011-06-01T20:27:22Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2011-06-01T20:27:22Z"}, "message": "re PR c++/44175 ([C++0x] decltype sometimes cannot recurse)\n\n\tPR c++/44175\n\t* pt.c (template_args_equal): Handle one arg being NULL_TREE.\n\t(deduction_tsubst_fntype): Handle excessive non-infinite recursion.\n\nFrom-SVN: r174543", "tree": {"sha": "8141a2826217dc73bcc5e04518dc3fe160a33565", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8141a2826217dc73bcc5e04518dc3fe160a33565"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4324a55c06f5e18cbcf6b1a1180435187cfd9876", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4324a55c06f5e18cbcf6b1a1180435187cfd9876", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4324a55c06f5e18cbcf6b1a1180435187cfd9876", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4324a55c06f5e18cbcf6b1a1180435187cfd9876/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4ee3537a6debc659c724e3fa04a7f704bc11ea80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ee3537a6debc659c724e3fa04a7f704bc11ea80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ee3537a6debc659c724e3fa04a7f704bc11ea80"}], "stats": {"total": 72, "additions": 71, "deletions": 1}, "files": [{"sha": "bf79bb6891713491159a612187389634f26b21e6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4324a55c06f5e18cbcf6b1a1180435187cfd9876/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4324a55c06f5e18cbcf6b1a1180435187cfd9876/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4324a55c06f5e18cbcf6b1a1180435187cfd9876", "patch": "@@ -1,5 +1,9 @@\n 2011-06-01  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/44175\n+\t* pt.c (template_args_equal): Handle one arg being NULL_TREE.\n+\t(deduction_tsubst_fntype): Handle excessive non-infinite recursion.\n+\n \tPR c++/49253\n \t* typeck2.c (build_x_arrow): Don't use build_min_nt.\n "}, {"sha": "c1bee3e05523c06a1bae9c9e464757b16562514c", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4324a55c06f5e18cbcf6b1a1180435187cfd9876/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4324a55c06f5e18cbcf6b1a1180435187cfd9876/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=4324a55c06f5e18cbcf6b1a1180435187cfd9876", "patch": "@@ -6476,6 +6476,8 @@ template_args_equal (tree ot, tree nt)\n {\n   if (nt == ot)\n     return 1;\n+  if (nt == NULL_TREE || ot == NULL_TREE)\n+    return false;\n \n   if (TREE_CODE (nt) == TREE_VEC)\n     /* For member templates */\n@@ -13598,7 +13600,14 @@ static GTY((param_is (spec_entry))) htab_t current_deduction_htab;\n /* In C++0x, it's possible to have a function template whose type depends\n    on itself recursively.  This is most obvious with decltype, but can also\n    occur with enumeration scope (c++/48969).  So we need to catch infinite\n-   recursion and reject the substitution at deduction time.\n+   recursion and reject the substitution at deduction time; this function\n+   will return error_mark_node for any repeated substitution.\n+\n+   This also catches excessive recursion such as when f<N> depends on\n+   f<N-1> across all integers, and returns error_mark_node for all the\n+   substitutions back up to the initial one.\n+\n+   This is, of course, not reentrant.\n \n    Use of a VEC here is O(n^2) in the depth of function template argument\n    deduction substitution, but using a hash table creates a lot of constant\n@@ -13611,6 +13620,8 @@ static GTY((param_is (spec_entry))) htab_t current_deduction_htab;\n static tree\n deduction_tsubst_fntype (tree fn, tree targs)\n {\n+  static bool excessive_deduction_depth;\n+\n   unsigned i;\n   spec_entry **slot;\n   spec_entry *p;\n@@ -13656,6 +13667,14 @@ deduction_tsubst_fntype (tree fn, tree targs)\n   /* If we've created a hash table, look there.  */\n   if (current_deduction_htab)\n     {\n+      if (htab_elements (current_deduction_htab)\n+\t  > (unsigned) max_tinst_depth)\n+\t{\n+\t  /* Trying to recurse across all integers or some such.  */\n+\t  excessive_deduction_depth = true;\n+\t  return error_mark_node;\n+\t}\n+\n       hash = hash_specialization (&elt);\n       slot = (spec_entry **)\n \thtab_find_slot_with_hash (current_deduction_htab, &elt, hash, INSERT);\n@@ -13701,6 +13720,13 @@ deduction_tsubst_fntype (tree fn, tree targs)\n \tr = error_mark_node;\n       VEC_pop (spec_entry, current_deduction_vec);\n     }\n+  if (excessive_deduction_depth)\n+    {\n+      r = error_mark_node;\n+      if (htab_elements (current_deduction_htab) == 0)\n+\t/* Reset once we're all the way out.  */\n+\texcessive_deduction_depth = false;\n+    }\n   return r;\n }\n "}, {"sha": "7639dffac69f9937980707dd0b25425677dcc23d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4324a55c06f5e18cbcf6b1a1180435187cfd9876/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4324a55c06f5e18cbcf6b1a1180435187cfd9876/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4324a55c06f5e18cbcf6b1a1180435187cfd9876", "patch": "@@ -1,3 +1,8 @@\n+2011-06-01  Jason Merrill  <jason@redhat.com>\n+\n+\t* g++.dg/cpp0x/decltype28.C: New.\n+\t* g++.dg/cpp0x/decltype29.C: New.\n+\n 2011-06-01  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \tPR target/45074"}, {"sha": "0ab8932d7f87eb0af817ca9092a8ede337990057", "filename": "gcc/testsuite/g++.dg/cpp0x/decltype28.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4324a55c06f5e18cbcf6b1a1180435187cfd9876/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype28.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4324a55c06f5e18cbcf6b1a1180435187cfd9876/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype28.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype28.C?ref=4324a55c06f5e18cbcf6b1a1180435187cfd9876", "patch": "@@ -0,0 +1,16 @@\n+// PR c++/44175\n+// { dg-options -std=c++0x }\n+\n+template <bool, class T> struct enable_if { };\n+template <class T> struct enable_if <true, T> { typedef T type; };\n+\n+template <class F, int N>\n+void ft (F f, typename enable_if<N!=0, int>::type) {}\n+\n+template< class F, int N >\n+decltype(ft<F, N-1> (F(), 0))\n+ft (F f, typename enable_if<N==0, int>::type) {}\n+\n+int main() {\n+  ft<struct a*, 2> (0, 0);\n+}"}, {"sha": "1dd5a5f9bf77a3b607dc2f1a7a3b9fbe9acc0742", "filename": "gcc/testsuite/g++.dg/cpp0x/decltype29.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4324a55c06f5e18cbcf6b1a1180435187cfd9876/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype29.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4324a55c06f5e18cbcf6b1a1180435187cfd9876/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype29.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype29.C?ref=4324a55c06f5e18cbcf6b1a1180435187cfd9876", "patch": "@@ -0,0 +1,19 @@\n+// PR c++/44175\n+// { dg-options -std=c++0x }\n+\n+template <bool, class T> struct enable_if { };\n+template <class T> struct enable_if <true, T> { typedef T type; };\n+\n+template <int x>\n+typename enable_if<x==0,int>::type\n+ft() {}\n+\n+template<class F, int N>\n+decltype (ft<F> (F()))\n+ft() {}\n+\n+int main() {\n+    ft<struct a*, 0>();\t\t// { dg-error \"no match\" }\n+}\n+\n+// { dg-prune-output \"note\" }"}]}