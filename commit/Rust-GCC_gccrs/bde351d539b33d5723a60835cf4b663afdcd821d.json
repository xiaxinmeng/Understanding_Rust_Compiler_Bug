{"sha": "bde351d539b33d5723a60835cf4b663afdcd821d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmRlMzUxZDUzOWIzM2Q1NzIzYTYwODM1Y2Y0YjY2M2FmZGNkODIxZA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-08-12T07:42:31Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-08-12T07:42:31Z"}, "message": "gimple.h (remove_pointer): New trait.\n\n2015-08-12  Richard Biener  <rguenther@suse.de>\n\n\t* gimple.h (remove_pointer): New trait.\n\t(GIMPLE_CHECK2): New inline template function.\n\t(gassign::code_): New constant static member.\n\t(is_a_helper<const gassign *>): Add.\n\t(gimple_assign_lhs): Use GIMPLE_CHECK2 in the gimple overload\n\tand forward to a new gassign overload with less checking and a\n\tcheaper way to access the operand.\n\t(gimple_assign_lhs_ptr): Likewise.\n\t(gimple_assign_set_lhs): Likewise.\n\t(gimple_assign_rhs1, gimple_assign_rhs1_ptr, gimple_assign_set_rhs1):\n\tLikewise.\n\t(gimple_assign_rhs2, gimple_assign_rhs2_ptr, gimple_assign_set_rhs2):\n\tLikewise.\n\t(gimple_assign_rhs3, gimple_assign_rhs3_ptr, gimple_assign_set_rhs3):\n\tLikewise.\n\t(gimple_assign_rhs_code): Likewise.\n\t* gimple.c (gassign::code_): Define.\n\nFrom-SVN: r226802", "tree": {"sha": "fd22296b386f2d75e390a2b202de287caaa900c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd22296b386f2d75e390a2b202de287caaa900c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bde351d539b33d5723a60835cf4b663afdcd821d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bde351d539b33d5723a60835cf4b663afdcd821d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bde351d539b33d5723a60835cf4b663afdcd821d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bde351d539b33d5723a60835cf4b663afdcd821d/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d27139850b789dbfc7c9c5604432c5d16114528d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d27139850b789dbfc7c9c5604432c5d16114528d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d27139850b789dbfc7c9c5604432c5d16114528d"}], "stats": {"total": 233, "additions": 195, "deletions": 38}, "files": [{"sha": "62b38279ab09a0260494c4a30d34d0f36c2c4aee", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bde351d539b33d5723a60835cf4b663afdcd821d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bde351d539b33d5723a60835cf4b663afdcd821d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bde351d539b33d5723a60835cf4b663afdcd821d", "patch": "@@ -1,3 +1,23 @@\n+2015-08-12  Richard Biener  <rguenther@suse.de>\n+\n+\t* gimple.h (remove_pointer): New trait.\n+\t(GIMPLE_CHECK2): New inline template function.\n+\t(gassign::code_): New constant static member.\n+\t(is_a_helper<const gassign *>): Add.\n+\t(gimple_assign_lhs): Use GIMPLE_CHECK2 in the gimple overload\n+\tand forward to a new gassign overload with less checking and a\n+\tcheaper way to access the operand.\n+\t(gimple_assign_lhs_ptr): Likewise.\n+\t(gimple_assign_set_lhs): Likewise.\n+\t(gimple_assign_rhs1, gimple_assign_rhs1_ptr, gimple_assign_set_rhs1):\n+\tLikewise.\n+\t(gimple_assign_rhs2, gimple_assign_rhs2_ptr, gimple_assign_set_rhs2):\n+\tLikewise.\n+\t(gimple_assign_rhs3, gimple_assign_rhs3_ptr, gimple_assign_set_rhs3):\n+\tLikewise.\n+\t(gimple_assign_rhs_code): Likewise.\n+\t* gimple.c (gassign::code_): Define.\n+\n 2015-08-12  Richard Biener  <rguenther@suse.de>\n \n \t* tree-ssa-pre.c (eliminate_dom_walker::before_dom_children):"}, {"sha": "e4866ac5803d22c6d0f785b7f14e0ac941a53732", "filename": "gcc/gimple.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bde351d539b33d5723a60835cf4b663afdcd821d/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bde351d539b33d5723a60835cf4b663afdcd821d/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=bde351d539b33d5723a60835cf4b663afdcd821d", "patch": "@@ -89,6 +89,10 @@ static const char * const gimple_alloc_kind_names[] = {\n     \"everything else\"\n };\n \n+/* Static gimple tuple members.  */\n+const enum gimple_code gassign::code_;\n+\n+\n /* Gimple tuple constructors.\n    Note: Any constructor taking a ``gimple_seq'' as a parameter, can\n    be passed a NULL to start with an empty sequence.  */"}, {"sha": "9e9be4ac62d17ab5f58cd1d6eafcbeeedf042236", "filename": "gcc/gimple.h", "status": "modified", "additions": 171, "deletions": 38, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bde351d539b33d5723a60835cf4b663afdcd821d/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bde351d539b33d5723a60835cf4b663afdcd821d/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=bde351d539b33d5723a60835cf4b663afdcd821d", "patch": "@@ -37,6 +37,10 @@ enum gimple_code {\n extern const char *const gimple_code_name[];\n extern const unsigned char gimple_rhs_class_table[];\n \n+/* Strip the outermost pointer, from tr1/type_traits.  */\n+template<typename T> struct remove_pointer { typedef T type; };\n+template<typename T> struct remove_pointer<T *> { typedef T type; };\n+\n /* Error out if a gimple tuple is addressed incorrectly.  */\n #if defined ENABLE_GIMPLE_CHECKING\n #define gcc_gimple_checking_assert(EXPR) gcc_assert (EXPR)\n@@ -51,9 +55,59 @@ extern void gimple_check_failed (const_gimple, const char *, int,          \\\n       gimple_check_failed (__gs, __FILE__, __LINE__, __FUNCTION__,\t\\\n \t  \t\t   (CODE), ERROR_MARK);\t\t\t\t\\\n   } while (0)\n+template <typename T>\n+static inline T\n+GIMPLE_CHECK2(const_gimple gs,\n+#if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)\n+\t      const char *file = __builtin_FILE (),\n+\t      int line = __builtin_LINE (),\n+\t      const char *fun = __builtin_FUNCTION ())\n+#else\n+\t      const char *file = __FILE__,\n+\t      int line = __LINE__,\n+\t      const char *fun = NULL)\n+#endif\n+{\n+  T ret = dyn_cast <T> (gs);\n+  if (!ret)\n+    gimple_check_failed (gs, file, line, fun,\n+\t\t\t remove_pointer<T>::type::code_, ERROR_MARK);\n+  return ret;\n+}\n+template <typename T>\n+static inline T\n+GIMPLE_CHECK2(gimple gs,\n+#if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)\n+\t      const char *file = __builtin_FILE (),\n+\t      int line = __builtin_LINE (),\n+\t      const char *fun = __builtin_FUNCTION ())\n+#else\n+\t      const char *file = __FILE__,\n+\t      int line = __LINE__,\n+\t      const char *fun = NULL)\n+#endif\n+{\n+  T ret = dyn_cast <T> (gs);\n+  if (!ret)\n+    gimple_check_failed (gs, file, line, fun,\n+\t\t\t remove_pointer<T>::type::code_, ERROR_MARK);\n+  return ret;\n+}\n #else  /* not ENABLE_GIMPLE_CHECKING  */\n #define gcc_gimple_checking_assert(EXPR) ((void)(0 && (EXPR)))\n #define GIMPLE_CHECK(GS, CODE)\t\t\t(void)0\n+template <typename T>\n+static inline T\n+GIMPLE_CHECK2(gimple gs)\n+{\n+  return as_a <T> (gs);\n+}\n+template <typename T>\n+static inline T\n+GIMPLE_CHECK2(const_gimple gs)\n+{\n+  return as_a <T> (gs);\n+}\n #endif\n \n /* Class of GIMPLE expressions suitable for the RHS of assignments.  See\n@@ -832,6 +886,7 @@ struct GTY((tag(\"GSS_WITH_OPS\")))\n struct GTY((tag(\"GSS_WITH_MEM_OPS\")))\n   gassign : public gimple_statement_with_memory_ops\n {\n+  static const enum gimple_code code_ = GIMPLE_ASSIGN;\n   /* no additional fields; this uses the layout for GSS_WITH_MEM_OPS. */\n };\n \n@@ -861,6 +916,14 @@ is_a_helper <gassign *>::test (gimple gs)\n   return gs->code == GIMPLE_ASSIGN;\n }\n \n+template <>\n+template <>\n+inline bool\n+is_a_helper <const gassign *>::test (const_gimple gs)\n+{\n+  return gs->code == GIMPLE_ASSIGN;\n+}\n+\n template <>\n template <>\n inline bool\n@@ -2325,139 +2388,205 @@ get_gimple_rhs_class (enum tree_code code)\n \n /* Return the LHS of assignment statement GS.  */\n \n+static inline tree\n+gimple_assign_lhs (const gassign *gs)\n+{\n+  return gs->op[0];\n+}\n+\n static inline tree\n gimple_assign_lhs (const_gimple gs)\n {\n-  GIMPLE_CHECK (gs, GIMPLE_ASSIGN);\n-  return gimple_op (gs, 0);\n+  const gassign *ass = GIMPLE_CHECK2<const gassign *> (gs);\n+  return gimple_assign_lhs (ass);\n }\n \n \n /* Return a pointer to the LHS of assignment statement GS.  */\n \n+static inline tree *\n+gimple_assign_lhs_ptr (const gassign *gs)\n+{\n+  return const_cast<tree *> (&gs->op[0]);\n+}\n+\n static inline tree *\n gimple_assign_lhs_ptr (const_gimple gs)\n {\n-  GIMPLE_CHECK (gs, GIMPLE_ASSIGN);\n-  return gimple_op_ptr (gs, 0);\n+  const gassign *ass = GIMPLE_CHECK2<const gassign *> (gs);\n+  return gimple_assign_lhs_ptr (ass);\n }\n \n \n /* Set LHS to be the LHS operand of assignment statement GS.  */\n \n static inline void\n-gimple_assign_set_lhs (gimple gs, tree lhs)\n+gimple_assign_set_lhs (gassign *gs, tree lhs)\n {\n-  GIMPLE_CHECK (gs, GIMPLE_ASSIGN);\n-  gimple_set_op (gs, 0, lhs);\n+  gs->op[0] = lhs;\n \n   if (lhs && TREE_CODE (lhs) == SSA_NAME)\n     SSA_NAME_DEF_STMT (lhs) = gs;\n }\n \n+static inline void\n+gimple_assign_set_lhs (gimple gs, tree lhs)\n+{\n+  gassign *ass = GIMPLE_CHECK2<gassign *> (gs);\n+  gimple_assign_set_lhs (ass, lhs);\n+}\n+\n \n /* Return the first operand on the RHS of assignment statement GS.  */\n \n+static inline tree\n+gimple_assign_rhs1 (const gassign *gs)\n+{\n+  return gs->op[1];\n+}\n+\n static inline tree\n gimple_assign_rhs1 (const_gimple gs)\n {\n-  GIMPLE_CHECK (gs, GIMPLE_ASSIGN);\n-  return gimple_op (gs, 1);\n+  const gassign *ass = GIMPLE_CHECK2<const gassign *> (gs);\n+  return gimple_assign_rhs1 (ass);\n }\n \n \n /* Return a pointer to the first operand on the RHS of assignment\n    statement GS.  */\n \n+static inline tree *\n+gimple_assign_rhs1_ptr (const gassign *gs)\n+{\n+  return const_cast<tree *> (&gs->op[1]);\n+}\n+\n static inline tree *\n gimple_assign_rhs1_ptr (const_gimple gs)\n {\n-  GIMPLE_CHECK (gs, GIMPLE_ASSIGN);\n-  return gimple_op_ptr (gs, 1);\n+  const gassign *ass = GIMPLE_CHECK2<const gassign *> (gs);\n+  return gimple_assign_rhs1_ptr (ass);\n }\n \n /* Set RHS to be the first operand on the RHS of assignment statement GS.  */\n \n static inline void\n-gimple_assign_set_rhs1 (gimple gs, tree rhs)\n+gimple_assign_set_rhs1 (gassign *gs, tree rhs)\n {\n-  GIMPLE_CHECK (gs, GIMPLE_ASSIGN);\n+  gs->op[1] = rhs;\n+}\n \n-  gimple_set_op (gs, 1, rhs);\n+static inline void\n+gimple_assign_set_rhs1 (gimple gs, tree rhs)\n+{\n+  gassign *ass = GIMPLE_CHECK2<gassign *> (gs);\n+  gimple_assign_set_rhs1 (ass, rhs);\n }\n \n \n /* Return the second operand on the RHS of assignment statement GS.\n    If GS does not have two operands, NULL is returned instead.  */\n \n static inline tree\n-gimple_assign_rhs2 (const_gimple gs)\n+gimple_assign_rhs2 (const gassign *gs)\n {\n-  GIMPLE_CHECK (gs, GIMPLE_ASSIGN);\n-\n   if (gimple_num_ops (gs) >= 3)\n-    return gimple_op (gs, 2);\n+    return gs->op[2];\n   else\n     return NULL_TREE;\n }\n \n+static inline tree\n+gimple_assign_rhs2 (const_gimple gs)\n+{\n+  const gassign *ass = GIMPLE_CHECK2<const gassign *> (gs);\n+  return gimple_assign_rhs2 (ass);\n+}\n+\n \n /* Return a pointer to the second operand on the RHS of assignment\n    statement GS.  */\n \n+static inline tree *\n+gimple_assign_rhs2_ptr (const gassign *gs)\n+{\n+  gcc_gimple_checking_assert (gimple_num_ops (gs) >= 3);\n+  return const_cast<tree *> (&gs->op[2]);\n+}\n+\n static inline tree *\n gimple_assign_rhs2_ptr (const_gimple gs)\n {\n-  GIMPLE_CHECK (gs, GIMPLE_ASSIGN);\n-  return gimple_op_ptr (gs, 2);\n+  const gassign *ass = GIMPLE_CHECK2<const gassign *> (gs);\n+  return gimple_assign_rhs2_ptr (ass);\n }\n \n \n /* Set RHS to be the second operand on the RHS of assignment statement GS.  */\n \n static inline void\n-gimple_assign_set_rhs2 (gimple gs, tree rhs)\n+gimple_assign_set_rhs2 (gassign *gs, tree rhs)\n {\n-  GIMPLE_CHECK (gs, GIMPLE_ASSIGN);\n+  gcc_gimple_checking_assert (gimple_num_ops (gs) >= 3);\n+  gs->op[2] = rhs;\n+}\n \n-  gimple_set_op (gs, 2, rhs);\n+static inline void\n+gimple_assign_set_rhs2 (gimple gs, tree rhs)\n+{\n+  gassign *ass = GIMPLE_CHECK2<gassign *> (gs);\n+  return gimple_assign_set_rhs2 (ass, rhs);\n }\n \n /* Return the third operand on the RHS of assignment statement GS.\n    If GS does not have two operands, NULL is returned instead.  */\n \n static inline tree\n-gimple_assign_rhs3 (const_gimple gs)\n+gimple_assign_rhs3 (const gassign *gs)\n {\n-  GIMPLE_CHECK (gs, GIMPLE_ASSIGN);\n-\n   if (gimple_num_ops (gs) >= 4)\n-    return gimple_op (gs, 3);\n+    return gs->op[3];\n   else\n     return NULL_TREE;\n }\n \n+static inline tree\n+gimple_assign_rhs3 (const_gimple gs)\n+{\n+  const gassign *ass = GIMPLE_CHECK2<const gassign *> (gs);\n+  return gimple_assign_rhs3 (ass);\n+}\n+\n /* Return a pointer to the third operand on the RHS of assignment\n    statement GS.  */\n \n static inline tree *\n gimple_assign_rhs3_ptr (const_gimple gs)\n {\n-  GIMPLE_CHECK (gs, GIMPLE_ASSIGN);\n-  return gimple_op_ptr (gs, 3);\n+  const gassign *ass = GIMPLE_CHECK2<const gassign *> (gs);\n+  gcc_gimple_checking_assert (gimple_num_ops (gs) >= 4);\n+  return const_cast<tree *> (&ass->op[3]);\n }\n \n \n /* Set RHS to be the third operand on the RHS of assignment statement GS.  */\n \n static inline void\n-gimple_assign_set_rhs3 (gimple gs, tree rhs)\n+gimple_assign_set_rhs3 (gassign *gs, tree rhs)\n {\n-  GIMPLE_CHECK (gs, GIMPLE_ASSIGN);\n+  gcc_gimple_checking_assert (gimple_num_ops (gs) >= 4);\n+  gs->op[3] = rhs;\n+}\n \n-  gimple_set_op (gs, 3, rhs);\n+static inline void\n+gimple_assign_set_rhs3 (gimple gs, tree rhs)\n+{\n+  gassign *ass = GIMPLE_CHECK2<gassign *> (gs);\n+  gimple_assign_set_rhs3 (ass, rhs);\n }\n \n+\n /* A wrapper around 3 operand gimple_assign_set_rhs_with_ops, for callers\n    which expect to see only two operands.  */\n \n@@ -2501,21 +2630,25 @@ gimple_assign_set_nontemporal_move (gimple gs, bool nontemporal)\n    tree code of the object.  */\n \n static inline enum tree_code\n-gimple_assign_rhs_code (const_gimple gs)\n+gimple_assign_rhs_code (const gassign *gs)\n {\n-  enum tree_code code;\n-  GIMPLE_CHECK (gs, GIMPLE_ASSIGN);\n-\n-  code = (enum tree_code) gs->subcode;\n+  enum tree_code code = (enum tree_code) gs->subcode;\n   /* While we initially set subcode to the TREE_CODE of the rhs for\n      GIMPLE_SINGLE_RHS assigns we do not update that subcode to stay\n      in sync when we rewrite stmts into SSA form or do SSA propagations.  */\n   if (get_gimple_rhs_class (code) == GIMPLE_SINGLE_RHS)\n-    code = TREE_CODE (gimple_assign_rhs1 (gs));\n+    code = TREE_CODE (gs->op[1]);\n \n   return code;\n }\n \n+static inline enum tree_code\n+gimple_assign_rhs_code (const_gimple gs)\n+{\n+  const gassign *ass = GIMPLE_CHECK2<const gassign *> (gs);\n+  return gimple_assign_rhs_code (ass);\n+}\n+\n \n /* Set CODE to be the code for the expression computed on the RHS of\n    assignment S.  */"}]}