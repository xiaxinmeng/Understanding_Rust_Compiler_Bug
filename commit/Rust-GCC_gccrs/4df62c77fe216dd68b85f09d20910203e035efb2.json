{"sha": "4df62c77fe216dd68b85f09d20910203e035efb2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGRmNjJjNzdmZTIxNmRkNjhiODVmMDlkMjA5MTAyMDNlMDM1ZWZiMg==", "commit": {"author": {"name": "Michael Matz", "email": "matz@suse.de", "date": "2009-08-25T13:35:39Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2009-08-25T13:35:39Z"}, "message": "expr.h (jumpifnot_1, [...]): Declare.\n\n        * expr.h (jumpifnot_1, jumpif_1, do_jump_1): Declare.\n        * dojump.c (do_jump_by_parts_greater): Take two operands instead of\n        full expression.\n        (do_jump_by_parts_equality, do_compare_and_jump): Ditto.\n        (jumpifnot_1, jumpif_1): New wrappers for do_jump_1.\n        (do_jump): Split out code for simple binary comparisons into ...\n        (do_jump_1): ... this, taking the individual operands and code.\n        Change callers to helper function above accordingly.\n        * expr.c (expand_expr_real_1): Use jumpifnot_1 for simple binary\n        comparisons.\n\nFrom-SVN: r151080", "tree": {"sha": "d43aba513d89c453e3953db977ef143d011fa0e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d43aba513d89c453e3953db977ef143d011fa0e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4df62c77fe216dd68b85f09d20910203e035efb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4df62c77fe216dd68b85f09d20910203e035efb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4df62c77fe216dd68b85f09d20910203e035efb2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4df62c77fe216dd68b85f09d20910203e035efb2/comments", "author": {"login": "susematz", "id": 4117296, "node_id": "MDQ6VXNlcjQxMTcyOTY=", "avatar_url": "https://avatars.githubusercontent.com/u/4117296?v=4", "gravatar_id": "", "url": "https://api.github.com/users/susematz", "html_url": "https://github.com/susematz", "followers_url": "https://api.github.com/users/susematz/followers", "following_url": "https://api.github.com/users/susematz/following{/other_user}", "gists_url": "https://api.github.com/users/susematz/gists{/gist_id}", "starred_url": "https://api.github.com/users/susematz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/susematz/subscriptions", "organizations_url": "https://api.github.com/users/susematz/orgs", "repos_url": "https://api.github.com/users/susematz/repos", "events_url": "https://api.github.com/users/susematz/events{/privacy}", "received_events_url": "https://api.github.com/users/susematz/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8e7aa1f9a319b100c721a7d83294a799a295407c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e7aa1f9a319b100c721a7d83294a799a295407c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e7aa1f9a319b100c721a7d83294a799a295407c"}], "stats": {"total": 380, "additions": 224, "deletions": 156}, "files": [{"sha": "cadeacee777c7f598837947343ccc6eac20d7b8d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4df62c77fe216dd68b85f09d20910203e035efb2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4df62c77fe216dd68b85f09d20910203e035efb2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4df62c77fe216dd68b85f09d20910203e035efb2", "patch": "@@ -1,3 +1,16 @@\n+2009-08-25  Michael Matz  <matz@suse.de>\n+\n+\t* expr.h (jumpifnot_1, jumpif_1, do_jump_1): Declare.\n+\t* dojump.c (do_jump_by_parts_greater): Take two operands instead of\n+\tfull expression.\n+\t(do_jump_by_parts_equality, do_compare_and_jump): Ditto.\n+\t(jumpifnot_1, jumpif_1): New wrappers for do_jump_1.\n+\t(do_jump): Split out code for simple binary comparisons into ...\n+\t(do_jump_1): ... this, taking the individual operands and code.\n+\tChange callers to helper function above accordingly.\n+\t* expr.c (expand_expr_real_1): Use jumpifnot_1 for simple binary\n+\tcomparisons.\n+\n 2009-08-25  Michael Matz  <matz@suse.de>\n \n \t* expr.h (struct separate_ops, sepops): New type for passing"}, {"sha": "de7a3ec8c7779641f8cebe6db877e8bfe5922c0f", "filename": "gcc/dojump.c", "status": "modified", "additions": 207, "deletions": 153, "changes": 360, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4df62c77fe216dd68b85f09d20910203e035efb2/gcc%2Fdojump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4df62c77fe216dd68b85f09d20910203e035efb2/gcc%2Fdojump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.c?ref=4df62c77fe216dd68b85f09d20910203e035efb2", "patch": "@@ -37,9 +37,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"basic-block.h\"\n \n static bool prefer_and_bit_test (enum machine_mode, int);\n-static void do_jump_by_parts_greater (tree, int, rtx, rtx);\n-static void do_jump_by_parts_equality (tree, rtx, rtx);\n-static void do_compare_and_jump\t(tree, enum rtx_code, enum rtx_code, rtx,\n+static void do_jump_by_parts_greater (tree, tree, int, rtx, rtx);\n+static void do_jump_by_parts_equality (tree, tree, rtx, rtx);\n+static void do_compare_and_jump\t(tree, tree, enum rtx_code, enum rtx_code, rtx,\n \t\t\t\t rtx);\n \n /* At the start of a function, record that we have no previously-pushed\n@@ -101,6 +101,12 @@ jumpifnot (tree exp, rtx label)\n   do_jump (exp, label, NULL_RTX);\n }\n \n+void\n+jumpifnot_1 (enum tree_code code, tree op0, tree op1, rtx label)\n+{\n+  do_jump_1 (code, op0, op1, label, NULL_RTX);\n+}\n+\n /* Generate code to evaluate EXP and jump to LABEL if the value is nonzero.  */\n \n void\n@@ -109,6 +115,12 @@ jumpif (tree exp, rtx label)\n   do_jump (exp, NULL_RTX, label);\n }\n \n+void\n+jumpif_1 (enum tree_code code, tree op0, tree op1, rtx label)\n+{\n+  do_jump_1 (code, op0, op1, NULL_RTX, label);\n+}\n+\n /* Used internally by prefer_and_bit_test.  */\n \n static GTY(()) rtx and_reg;\n@@ -149,6 +161,165 @@ prefer_and_bit_test (enum machine_mode mode, int bitnum)\n \t  <= rtx_cost (shift_test, IF_THEN_ELSE, optimize_insn_for_speed_p ()));\n }\n \n+/* Subroutine of do_jump, dealing with exploded comparisons of the type\n+   OP0 CODE OP1 .  IF_FALSE_LABEL and IF_TRUE_LABEL like in do_jump.  */\n+\n+void\n+do_jump_1 (enum tree_code code, tree op0, tree op1,\n+\t   rtx if_false_label, rtx if_true_label)\n+{\n+  enum machine_mode mode;\n+  rtx drop_through_label = 0;\n+\n+  switch (code)\n+    {\n+    case EQ_EXPR:\n+      {\n+        tree inner_type = TREE_TYPE (op0);\n+\n+        gcc_assert (GET_MODE_CLASS (TYPE_MODE (inner_type))\n+\t\t    != MODE_COMPLEX_FLOAT);\n+\tgcc_assert (GET_MODE_CLASS (TYPE_MODE (inner_type))\n+\t\t    != MODE_COMPLEX_INT);\n+\n+        if (integer_zerop (op1))\n+          do_jump (op0, if_true_label, if_false_label);\n+        else if (GET_MODE_CLASS (TYPE_MODE (inner_type)) == MODE_INT\n+                 && !can_compare_p (EQ, TYPE_MODE (inner_type), ccp_jump))\n+          do_jump_by_parts_equality (op0, op1, if_false_label, if_true_label);\n+        else\n+          do_compare_and_jump (op0, op1, EQ, EQ, if_false_label, if_true_label);\n+        break;\n+      }\n+\n+    case NE_EXPR:\n+      {\n+        tree inner_type = TREE_TYPE (op0);\n+\n+        gcc_assert (GET_MODE_CLASS (TYPE_MODE (inner_type))\n+\t\t    != MODE_COMPLEX_FLOAT);\n+\tgcc_assert (GET_MODE_CLASS (TYPE_MODE (inner_type))\n+\t\t    != MODE_COMPLEX_INT);\n+\n+        if (integer_zerop (op1))\n+          do_jump (op0, if_false_label, if_true_label);\n+        else if (GET_MODE_CLASS (TYPE_MODE (inner_type)) == MODE_INT\n+           && !can_compare_p (NE, TYPE_MODE (inner_type), ccp_jump))\n+          do_jump_by_parts_equality (op0, op1, if_true_label, if_false_label);\n+        else\n+          do_compare_and_jump (op0, op1, NE, NE, if_false_label, if_true_label);\n+        break;\n+      }\n+\n+    case LT_EXPR:\n+      mode = TYPE_MODE (TREE_TYPE (op0));\n+      if (GET_MODE_CLASS (mode) == MODE_INT\n+          && ! can_compare_p (LT, mode, ccp_jump))\n+        do_jump_by_parts_greater (op0, op1, 1, if_false_label, if_true_label);\n+      else\n+        do_compare_and_jump (op0, op1, LT, LTU, if_false_label, if_true_label);\n+      break;\n+\n+    case LE_EXPR:\n+      mode = TYPE_MODE (TREE_TYPE (op0));\n+      if (GET_MODE_CLASS (mode) == MODE_INT\n+          && ! can_compare_p (LE, mode, ccp_jump))\n+        do_jump_by_parts_greater (op0, op1, 0, if_true_label, if_false_label);\n+      else\n+        do_compare_and_jump (op0, op1, LE, LEU, if_false_label, if_true_label);\n+      break;\n+\n+    case GT_EXPR:\n+      mode = TYPE_MODE (TREE_TYPE (op0));\n+      if (GET_MODE_CLASS (mode) == MODE_INT\n+          && ! can_compare_p (GT, mode, ccp_jump))\n+        do_jump_by_parts_greater (op0, op1, 0, if_false_label, if_true_label);\n+      else\n+        do_compare_and_jump (op0, op1, GT, GTU, if_false_label, if_true_label);\n+      break;\n+\n+    case GE_EXPR:\n+      mode = TYPE_MODE (TREE_TYPE (op0));\n+      if (GET_MODE_CLASS (mode) == MODE_INT\n+          && ! can_compare_p (GE, mode, ccp_jump))\n+        do_jump_by_parts_greater (op0, op1, 1, if_true_label, if_false_label);\n+      else\n+        do_compare_and_jump (op0, op1, GE, GEU, if_false_label, if_true_label);\n+      break;\n+\n+    case ORDERED_EXPR:\n+      do_compare_and_jump (op0, op1, ORDERED, ORDERED,\n+\t\t\t   if_false_label, if_true_label);\n+      break;\n+\n+    case UNORDERED_EXPR:\n+      do_compare_and_jump (op0, op1, UNORDERED, UNORDERED,\n+\t\t\t   if_false_label, if_true_label);\n+      break;\n+\n+    case UNLT_EXPR:\n+      do_compare_and_jump (op0, op1, UNLT, UNLT, if_false_label, if_true_label);\n+      break;\n+\n+    case UNLE_EXPR:\n+      do_compare_and_jump (op0, op1, UNLE, UNLE, if_false_label, if_true_label);\n+      break;\n+\n+    case UNGT_EXPR:\n+      do_compare_and_jump (op0, op1, UNGT, UNGT, if_false_label, if_true_label);\n+      break;\n+\n+    case UNGE_EXPR:\n+      do_compare_and_jump (op0, op1, UNGE, UNGE, if_false_label, if_true_label);\n+      break;\n+\n+    case UNEQ_EXPR:\n+      do_compare_and_jump (op0, op1, UNEQ, UNEQ, if_false_label, if_true_label);\n+      break;\n+\n+    case LTGT_EXPR:\n+      do_compare_and_jump (op0, op1, LTGT, LTGT, if_false_label, if_true_label);\n+      break;\n+\n+    case TRUTH_ANDIF_EXPR:\n+      if (if_false_label == NULL_RTX)\n+        {\n+\t  drop_through_label = gen_label_rtx ();\n+          do_jump (op0, drop_through_label, NULL_RTX);\n+          do_jump (op1, NULL_RTX, if_true_label);\n+\t}\n+      else\n+\t{\n+\t  do_jump (op0, if_false_label, NULL_RTX);\n+          do_jump (op1, if_false_label, if_true_label);\n+\t}\n+      break;\n+\n+    case TRUTH_ORIF_EXPR:\n+      if (if_true_label == NULL_RTX)\n+\t{\n+          drop_through_label = gen_label_rtx ();\n+          do_jump (op0, NULL_RTX, drop_through_label);\n+          do_jump (op1, if_false_label, NULL_RTX);\n+\t}\n+      else\n+\t{\n+          do_jump (op0, NULL_RTX, if_true_label);\n+          do_jump (op1, if_false_label, if_true_label);\n+\t}\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  if (drop_through_label)\n+    {\n+      do_pending_stack_adjust ();\n+      emit_label (drop_through_label);\n+    }\n+}\n+\n /* Generate code to evaluate EXP and jump to IF_FALSE_LABEL if\n    the result is zero, or IF_TRUE_LABEL if the result is one.\n    Either of IF_FALSE_LABEL and IF_TRUE_LABEL may be zero,\n@@ -266,118 +437,29 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n         goto normal;\n       }\n \n-    case EQ_EXPR:\n-      {\n-        tree inner_type = TREE_TYPE (TREE_OPERAND (exp, 0));\n-\n-        gcc_assert (GET_MODE_CLASS (TYPE_MODE (inner_type))\n-\t\t    != MODE_COMPLEX_FLOAT);\n-\tgcc_assert (GET_MODE_CLASS (TYPE_MODE (inner_type))\n-\t\t    != MODE_COMPLEX_INT);\n-\t\n-        if (integer_zerop (TREE_OPERAND (exp, 1)))\n-          do_jump (TREE_OPERAND (exp, 0), if_true_label, if_false_label);\n-        else if (GET_MODE_CLASS (TYPE_MODE (inner_type)) == MODE_INT\n-                 && !can_compare_p (EQ, TYPE_MODE (inner_type), ccp_jump))\n-          do_jump_by_parts_equality (exp, if_false_label, if_true_label);\n-        else\n-          do_compare_and_jump (exp, EQ, EQ, if_false_label, if_true_label);\n-        break;\n-      }\n-\n     case MINUS_EXPR:\n       /* Nonzero iff operands of minus differ.  */\n-      exp = build2 (NE_EXPR, TREE_TYPE (exp),\n-\t\t    TREE_OPERAND (exp, 0),\n-\t\t    TREE_OPERAND (exp, 1));\n+      code = NE_EXPR;\n+\n       /* FALLTHRU */\n+    case EQ_EXPR:\n     case NE_EXPR:\n-      {\n-        tree inner_type = TREE_TYPE (TREE_OPERAND (exp, 0));\n-\n-        gcc_assert (GET_MODE_CLASS (TYPE_MODE (inner_type))\n-\t\t    != MODE_COMPLEX_FLOAT);\n-\tgcc_assert (GET_MODE_CLASS (TYPE_MODE (inner_type))\n-\t\t    != MODE_COMPLEX_INT);\n-\t\n-        if (integer_zerop (TREE_OPERAND (exp, 1)))\n-          do_jump (TREE_OPERAND (exp, 0), if_false_label, if_true_label);\n-        else if (GET_MODE_CLASS (TYPE_MODE (inner_type)) == MODE_INT\n-           && !can_compare_p (NE, TYPE_MODE (inner_type), ccp_jump))\n-          do_jump_by_parts_equality (exp, if_true_label, if_false_label);\n-        else\n-          do_compare_and_jump (exp, NE, NE, if_false_label, if_true_label);\n-        break;\n-      }\n-\n     case LT_EXPR:\n-      mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n-      if (GET_MODE_CLASS (mode) == MODE_INT\n-          && ! can_compare_p (LT, mode, ccp_jump))\n-        do_jump_by_parts_greater (exp, 1, if_false_label, if_true_label);\n-      else\n-        do_compare_and_jump (exp, LT, LTU, if_false_label, if_true_label);\n-      break;\n-\n     case LE_EXPR:\n-      mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n-      if (GET_MODE_CLASS (mode) == MODE_INT\n-          && ! can_compare_p (LE, mode, ccp_jump))\n-        do_jump_by_parts_greater (exp, 0, if_true_label, if_false_label);\n-      else\n-        do_compare_and_jump (exp, LE, LEU, if_false_label, if_true_label);\n-      break;\n-\n     case GT_EXPR:\n-      mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n-      if (GET_MODE_CLASS (mode) == MODE_INT\n-          && ! can_compare_p (GT, mode, ccp_jump))\n-        do_jump_by_parts_greater (exp, 0, if_false_label, if_true_label);\n-      else\n-        do_compare_and_jump (exp, GT, GTU, if_false_label, if_true_label);\n-      break;\n-\n     case GE_EXPR:\n-      mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n-      if (GET_MODE_CLASS (mode) == MODE_INT\n-          && ! can_compare_p (GE, mode, ccp_jump))\n-        do_jump_by_parts_greater (exp, 1, if_true_label, if_false_label);\n-      else\n-        do_compare_and_jump (exp, GE, GEU, if_false_label, if_true_label);\n-      break;\n-\n     case ORDERED_EXPR:\n-      do_compare_and_jump (exp, ORDERED, ORDERED,\n-\t\t\t   if_false_label, if_true_label);\n-      break;\n-\n     case UNORDERED_EXPR:\n-      do_compare_and_jump (exp, UNORDERED, UNORDERED,\n-\t\t\t   if_false_label, if_true_label);\n-      break;\n-\n     case UNLT_EXPR:\n-      do_compare_and_jump (exp, UNLT, UNLT, if_false_label, if_true_label);\n-      break;\n-\n     case UNLE_EXPR:\n-      do_compare_and_jump (exp, UNLE, UNLE, if_false_label, if_true_label);\n-      break;\n-\n     case UNGT_EXPR:\n-      do_compare_and_jump (exp, UNGT, UNGT, if_false_label, if_true_label);\n-      break;\n-\n     case UNGE_EXPR:\n-      do_compare_and_jump (exp, UNGE, UNGE, if_false_label, if_true_label);\n-      break;\n-\n     case UNEQ_EXPR:\n-      do_compare_and_jump (exp, UNEQ, UNEQ, if_false_label, if_true_label);\n-      break;\n-\n     case LTGT_EXPR:\n-      do_compare_and_jump (exp, LTGT, LTGT, if_false_label, if_true_label);\n+    case TRUTH_ANDIF_EXPR:\n+    case TRUTH_ORIF_EXPR:\n+      do_jump_1 (code, TREE_OPERAND (exp, 0), TREE_OPERAND (exp, 1),\n+\t\t if_false_label, if_true_label);\n       break;\n \n     case BIT_AND_EXPR:\n@@ -466,20 +548,6 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n \t  || TREE_SIDE_EFFECTS (TREE_OPERAND (exp, 1)))\n \tgoto normal;\n \n-    case TRUTH_ANDIF_EXPR:\n-      if (if_false_label == NULL_RTX)\n-        {\n-\t  drop_through_label = gen_label_rtx ();\n-          do_jump (TREE_OPERAND (exp, 0), drop_through_label, NULL_RTX);\n-          do_jump (TREE_OPERAND (exp, 1), NULL_RTX, if_true_label);\n-\t}\n-      else\n-\t{\n-\t  do_jump (TREE_OPERAND (exp, 0), if_false_label, NULL_RTX);\n-          do_jump (TREE_OPERAND (exp, 1), if_false_label, if_true_label);\n-\t}\n-      break;\n-\n     case BIT_IOR_EXPR:\n     case TRUTH_OR_EXPR:\n       /* High branch cost, expand as the bitwise OR of the conditions.\n@@ -489,20 +557,6 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n \t  || TREE_SIDE_EFFECTS (TREE_OPERAND (exp, 1)))\n \tgoto normal;\n \n-    case TRUTH_ORIF_EXPR:\n-      if (if_true_label == NULL_RTX)\n-\t{\n-          drop_through_label = gen_label_rtx ();\n-          do_jump (TREE_OPERAND (exp, 0), NULL_RTX, drop_through_label);\n-          do_jump (TREE_OPERAND (exp, 1), if_false_label, NULL_RTX);\n-\t}\n-      else\n-\t{\n-          do_jump (TREE_OPERAND (exp, 0), NULL_RTX, if_true_label);\n-          do_jump (TREE_OPERAND (exp, 1), if_false_label, if_true_label);\n-\t}\n-      break;\n-\n       /* Fall through and generate the normal code.  */\n     default:\n     normal:\n@@ -588,13 +642,13 @@ do_jump_by_parts_greater_rtx (enum machine_mode mode, int unsignedp, rtx op0,\n    and LT if SWAP is 1.  */\n \n static void\n-do_jump_by_parts_greater (tree exp, int swap, rtx if_false_label,\n-\t\t\t  rtx if_true_label)\n+do_jump_by_parts_greater (tree treeop0, tree treeop1, int swap,\n+\t\t\t  rtx if_false_label, rtx if_true_label)\n {\n-  rtx op0 = expand_normal (TREE_OPERAND (exp, swap));\n-  rtx op1 = expand_normal (TREE_OPERAND (exp, !swap));\n-  enum machine_mode mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n-  int unsignedp = TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 0)));\n+  rtx op0 = expand_normal (swap ? treeop1 : treeop0);\n+  rtx op1 = expand_normal (swap ? treeop0 : treeop1);\n+  enum machine_mode mode = TYPE_MODE (TREE_TYPE (treeop0));\n+  int unsignedp = TYPE_UNSIGNED (TREE_TYPE (treeop0));\n \n   do_jump_by_parts_greater_rtx (mode, unsignedp, op0, op1, if_false_label,\n \t\t\t\tif_true_label);\n@@ -693,11 +747,12 @@ do_jump_by_parts_equality_rtx (enum machine_mode mode, rtx op0, rtx op1,\n    with one insn, test the comparison and jump to the appropriate label.  */\n \n static void\n-do_jump_by_parts_equality (tree exp, rtx if_false_label, rtx if_true_label)\n+do_jump_by_parts_equality (tree treeop0, tree treeop1, rtx if_false_label,\n+\t\t\t   rtx if_true_label)\n {\n-  rtx op0 = expand_normal (TREE_OPERAND (exp, 0));\n-  rtx op1 = expand_normal (TREE_OPERAND (exp, 1));\n-  enum machine_mode mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n+  rtx op0 = expand_normal (treeop0);\n+  rtx op1 = expand_normal (treeop1);\n+  enum machine_mode mode = TYPE_MODE (TREE_TYPE (treeop0));\n   do_jump_by_parts_equality_rtx (mode, op0, op1, if_false_label,\n \t\t\t\t if_true_label);\n }\n@@ -994,7 +1049,7 @@ do_compare_rtx_and_jump (rtx op0, rtx op1, enum rtx_code code, int unsignedp,\n    things pushed on the stack that aren't yet used.  */\n \n static void\n-do_compare_and_jump (tree exp, enum rtx_code signed_code,\n+do_compare_and_jump (tree treeop0, tree treeop1, enum rtx_code signed_code,\n \t\t     enum rtx_code unsigned_code, rtx if_false_label,\n \t\t     rtx if_true_label)\n {\n@@ -1005,25 +1060,24 @@ do_compare_and_jump (tree exp, enum rtx_code signed_code,\n   enum rtx_code code;\n \n   /* Don't crash if the comparison was erroneous.  */\n-  op0 = expand_normal (TREE_OPERAND (exp, 0));\n-  if (TREE_CODE (TREE_OPERAND (exp, 0)) == ERROR_MARK)\n+  op0 = expand_normal (treeop0);\n+  if (TREE_CODE (treeop0) == ERROR_MARK)\n     return;\n \n-  op1 = expand_normal (TREE_OPERAND (exp, 1));\n-  if (TREE_CODE (TREE_OPERAND (exp, 1)) == ERROR_MARK)\n+  op1 = expand_normal (treeop1);\n+  if (TREE_CODE (treeop1) == ERROR_MARK)\n     return;\n \n-  type = TREE_TYPE (TREE_OPERAND (exp, 0));\n+  type = TREE_TYPE (treeop0);\n   mode = TYPE_MODE (type);\n-  if (TREE_CODE (TREE_OPERAND (exp, 0)) == INTEGER_CST\n-      && (TREE_CODE (TREE_OPERAND (exp, 1)) != INTEGER_CST\n+  if (TREE_CODE (treeop0) == INTEGER_CST\n+      && (TREE_CODE (treeop1) != INTEGER_CST\n           || (GET_MODE_BITSIZE (mode)\n-              > GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp,\n-                                                                      1)))))))\n+              > GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (treeop1))))))\n     {\n       /* op0 might have been replaced by promoted constant, in which\n          case the type of second argument should be used.  */\n-      type = TREE_TYPE (TREE_OPERAND (exp, 1));\n+      type = TREE_TYPE (treeop1);\n       mode = TYPE_MODE (type);\n     }\n   unsignedp = TYPE_UNSIGNED (type);\n@@ -1036,11 +1090,11 @@ do_compare_and_jump (tree exp, enum rtx_code signed_code,\n      If one side isn't, we want a noncanonicalized comparison.  See PR\n      middle-end/17564.  */\n   if (HAVE_canonicalize_funcptr_for_compare\n-      && TREE_CODE (TREE_TYPE (TREE_OPERAND (exp, 0))) == POINTER_TYPE\n-      && TREE_CODE (TREE_TYPE (TREE_TYPE (TREE_OPERAND (exp, 0))))\n+      && TREE_CODE (TREE_TYPE (treeop0)) == POINTER_TYPE\n+      && TREE_CODE (TREE_TYPE (TREE_TYPE (treeop0)))\n           == FUNCTION_TYPE\n-      && TREE_CODE (TREE_TYPE (TREE_OPERAND (exp, 1))) == POINTER_TYPE\n-      && TREE_CODE (TREE_TYPE (TREE_TYPE (TREE_OPERAND (exp, 1))))\n+      && TREE_CODE (TREE_TYPE (treeop1)) == POINTER_TYPE\n+      && TREE_CODE (TREE_TYPE (TREE_TYPE (treeop1)))\n           == FUNCTION_TYPE)\n     {\n       rtx new_op0 = gen_reg_rtx (mode);\n@@ -1056,7 +1110,7 @@ do_compare_and_jump (tree exp, enum rtx_code signed_code,\n \n   do_compare_rtx_and_jump (op0, op1, code, unsignedp, mode,\n                            ((mode == BLKmode)\n-                            ? expr_size (TREE_OPERAND (exp, 0)) : NULL_RTX),\n+                            ? expr_size (treeop0) : NULL_RTX),\n                            if_false_label, if_true_label);\n }\n "}, {"sha": "a753682a150a9d0b0770f6595bffcd1be618f1f8", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4df62c77fe216dd68b85f09d20910203e035efb2/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4df62c77fe216dd68b85f09d20910203e035efb2/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=4df62c77fe216dd68b85f09d20910203e035efb2", "patch": "@@ -8194,7 +8194,6 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t\t\t\tmodifier);\n \n \t      result = copy_rtx (result);\n-\t      /* BLA */\n \t      set_mem_attributes (result, exp, 0);\n \t      return result;\n \t    }\n@@ -9169,8 +9168,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \temit_move_insn (target, const0_rtx);\n \n       op1 = gen_label_rtx ();\n-      /* BLA */\n-      jumpifnot (exp, op1);\n+      jumpifnot_1 (code, treeop0, treeop1, op1);\n \n       if (target)\n \temit_move_insn (target, const1_rtx);"}, {"sha": "fbec387e30045f82b64d92d32217605a144f5ba3", "filename": "gcc/expr.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4df62c77fe216dd68b85f09d20910203e035efb2/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4df62c77fe216dd68b85f09d20910203e035efb2/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=4df62c77fe216dd68b85f09d20910203e035efb2", "patch": "@@ -579,13 +579,16 @@ extern tree string_constant (tree, tree *);\n \n /* Generate code to evaluate EXP and jump to LABEL if the value is zero.  */\n extern void jumpifnot (tree, rtx);\n+extern void jumpifnot_1 (enum tree_code, tree, tree, rtx);\n \n /* Generate code to evaluate EXP and jump to LABEL if the value is nonzero.  */\n extern void jumpif (tree, rtx);\n+extern void jumpif_1 (enum tree_code, tree, tree, rtx);\n \n /* Generate code to evaluate EXP and jump to IF_FALSE_LABEL if\n    the result is zero, or IF_TRUE_LABEL if the result is one.  */\n extern void do_jump (tree, rtx, rtx);\n+extern void do_jump_1 (enum tree_code, tree, tree, rtx, rtx);\n \n extern void do_compare_rtx_and_jump (rtx, rtx, enum rtx_code, int,\n \t\t\t\t     enum machine_mode, rtx, rtx, rtx);"}]}