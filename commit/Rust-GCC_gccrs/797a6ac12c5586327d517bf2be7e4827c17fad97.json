{"sha": "797a6ac12c5586327d517bf2be7e4827c17fad97", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzk3YTZhYzEyYzU1ODYzMjdkNTE3YmYyYmU3ZTQ4MjdjMTdmYWQ5Nw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2002-05-03T00:23:55Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-05-03T00:23:55Z"}, "message": "* function.c: Fix formatting.\n\nFrom-SVN: r53075", "tree": {"sha": "8c37de2dba2335f768f3adaaf0ba133b9ae14d06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c37de2dba2335f768f3adaaf0ba133b9ae14d06"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/797a6ac12c5586327d517bf2be7e4827c17fad97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/797a6ac12c5586327d517bf2be7e4827c17fad97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/797a6ac12c5586327d517bf2be7e4827c17fad97", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/797a6ac12c5586327d517bf2be7e4827c17fad97/comments", "author": null, "committer": null, "parents": [{"sha": "ce4b2ca6bc6cd0698402c3cc015b57d746b10946", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce4b2ca6bc6cd0698402c3cc015b57d746b10946", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce4b2ca6bc6cd0698402c3cc015b57d746b10946"}], "stats": {"total": 70, "additions": 37, "deletions": 33}, "files": [{"sha": "dacfe157242ab85f74dca5c35ad33e62889c2040", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/797a6ac12c5586327d517bf2be7e4827c17fad97/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/797a6ac12c5586327d517bf2be7e4827c17fad97/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=797a6ac12c5586327d517bf2be7e4827c17fad97", "patch": "@@ -1,3 +1,7 @@\n+2002-05-02  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* function.c: Fix formatting.\n+\n 2002-05-02  Jan Hubicka  <jh@suse.cz>\n \n \t* haifa-sched.c (schedule_insn): Print table of instructions and"}, {"sha": "d0ad459a97569cad7ef68b46bad66bd4544bfcfc", "filename": "gcc/function.c", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/797a6ac12c5586327d517bf2be7e4827c17fad97/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/797a6ac12c5586327d517bf2be7e4827c17fad97/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=797a6ac12c5586327d517bf2be7e4827c17fad97", "patch": "@@ -250,7 +250,7 @@ static void fixup_var_refs_insn PARAMS ((rtx, rtx, enum machine_mode,\n static void fixup_var_refs_1\tPARAMS ((rtx, enum machine_mode, rtx *, rtx,\n \t\t\t\t\t struct fixup_replacement **, rtx));\n static rtx fixup_memory_subreg\tPARAMS ((rtx, rtx, enum machine_mode, int));\n-static rtx walk_fixup_memory_subreg  PARAMS ((rtx, rtx, enum machine_mode, \n+static rtx walk_fixup_memory_subreg  PARAMS ((rtx, rtx, enum machine_mode,\n \t\t\t\t\t      int));\n static rtx fixup_stack_1\tPARAMS ((rtx, rtx));\n static void optimize_bit_field\tPARAMS ((rtx, rtx, rtx *));\n@@ -893,7 +893,7 @@ assign_temp (type_or_decl, keep, memory_required, dont_promote)\n \n       /* The size of the temporary may be too large to fit into an integer.  */\n       /* ??? Not sure this should happen except for user silliness, so limit\n-\t this to things that aren't compiler-generated temporaries.  The \n+\t this to things that aren't compiler-generated temporaries.  The\n \t rest of the time we'll abort in assign_stack_temp_for_type.  */\n       if (decl && size == -1\n \t  && TREE_CODE (TYPE_SIZE_UNIT (type)) == INTEGER_CST)\n@@ -1360,8 +1360,8 @@ put_var_into_stack (decl)\n   context = decl_function_context (decl);\n \n   /* Get the current rtl used for this object and its original mode.  */\n-  reg = (TREE_CODE (decl) == SAVE_EXPR \n-\t ? SAVE_EXPR_RTL (decl) \n+  reg = (TREE_CODE (decl) == SAVE_EXPR\n+\t ? SAVE_EXPR_RTL (decl)\n \t : DECL_RTL_IF_SET (decl));\n \n   /* No need to do anything if decl has no rtx yet\n@@ -1863,7 +1863,7 @@ fixup_var_refs_insn (insn, var, promoted_mode, unsignedp, toplevel, no_share)\n \t      /* OLD might be a (subreg (mem)).  */\n \t      if (GET_CODE (replacements->old) == SUBREG)\n \t\treplacements->old\n-\t\t  = fixup_memory_subreg (replacements->old, insn, \n+\t\t  = fixup_memory_subreg (replacements->old, insn,\n \t\t\t\t\t promoted_mode, 0);\n \t      else\n \t\treplacements->old\n@@ -2191,7 +2191,7 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements, no_share)\n \t      return;\n \t    }\n \n-\t  replacement->new = *loc = fixup_memory_subreg (x, insn, \n+\t  replacement->new = *loc = fixup_memory_subreg (x, insn,\n \t\t\t\t\t\t\t promoted_mode, 0);\n \n \t  INSN_CODE (insn) = -1;\n@@ -2439,7 +2439,7 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements, no_share)\n \t    rtx pat, last;\n \n \t    if (GET_CODE (SET_DEST (x)) == SUBREG)\n-\t      SET_DEST (x) = fixup_memory_subreg (SET_DEST (x), insn, \n+\t      SET_DEST (x) = fixup_memory_subreg (SET_DEST (x), insn,\n \t\t\t\t\t\t  promoted_mode, 0);\n \t    else\n \t      SET_DEST (x) = fixup_stack_1 (SET_DEST (x), insn);\n@@ -2493,7 +2493,7 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements, no_share)\n \t    /* Convert (SUBREG (MEM)) to a MEM in a changed mode.  */\n \t    if (GET_CODE (fixeddest) == SUBREG)\n \t      {\n-\t\tfixeddest = fixup_memory_subreg (fixeddest, insn, \n+\t\tfixeddest = fixup_memory_subreg (fixeddest, insn,\n \t\t\t\t\t\t promoted_mode, 0);\n \t\ttemp_mode = GET_MODE (fixeddest);\n \t      }\n@@ -2538,7 +2538,7 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements, no_share)\n \f\n /* Previously, X had the form (SUBREG:m1 (REG:PROMOTED_MODE ...)).\n    The REG  was placed on the stack, so X now has the form (SUBREG:m1\n-   (MEM:m2 ...)). \n+   (MEM:m2 ...)).\n \n    Return an rtx (MEM:m1 newaddr) which is equivalent.  If any insns\n    must be emitted to compute NEWADDR, put them before INSN.\n@@ -2587,7 +2587,7 @@ fixup_memory_subreg (x, insn, promoted_mode, uncritical)\n    If X itself is a (SUBREG (MEM ...) ...), return the replacement expression.\n    Otherwise return X, with its contents possibly altered.\n \n-   INSN, PROMOTED_MODE and UNCRITICAL are as for \n+   INSN, PROMOTED_MODE and UNCRITICAL are as for\n    fixup_memory_subreg.  */\n \n static rtx\n@@ -2615,14 +2615,14 @@ walk_fixup_memory_subreg (x, insn, promoted_mode, uncritical)\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     {\n       if (fmt[i] == 'e')\n-\tXEXP (x, i) = walk_fixup_memory_subreg (XEXP (x, i), insn, \n+\tXEXP (x, i) = walk_fixup_memory_subreg (XEXP (x, i), insn,\n \t\t\t\t\t\tpromoted_mode, uncritical);\n       else if (fmt[i] == 'E')\n \t{\n \t  int j;\n \t  for (j = 0; j < XVECLEN (x, i); j++)\n \t    XVECEXP (x, i, j)\n-\t      = walk_fixup_memory_subreg (XVECEXP (x, i, j), insn, \n+\t      = walk_fixup_memory_subreg (XVECEXP (x, i, j), insn,\n \t\t\t\t\t  promoted_mode, uncritical);\n \t}\n     }\n@@ -3066,7 +3066,7 @@ purge_addressof_1 (loc, insn, force, store, ht)\n \t  put_addressof_into_stack (x, ht);\n \t  return true;\n \t}\n-\t  \n+\n       /* We must create a copy of the rtx because it was created by\n \t overwriting a REG rtx which is always shared.  */\n       sub = copy_rtx (XEXP (XEXP (x, 0), 0));\n@@ -3508,7 +3508,7 @@ purge_single_hard_subreg_set (pattern)\n       reg = SUBREG_REG (reg);\n     }\n \n-\t\t  \n+\n   if (GET_CODE (reg) == REG && REGNO (reg) < FIRST_PSEUDO_REGISTER)\n     {\n       reg = gen_rtx_REG (mode, REGNO (reg) + offset);\n@@ -3537,7 +3537,7 @@ purge_hard_subreg_sets (insn)\n \t    case SET:\n \t      if (GET_CODE (SET_DEST (pattern)) == SUBREG)\n \t\tpurge_single_hard_subreg_set (pattern);\n-\t      break;\t      \n+\t      break;\n \t    case PARALLEL:\n \t      {\n \t\tint j;\n@@ -3658,7 +3658,7 @@ instantiate_decls_1 (let, valid_only)\n \n   for (t = BLOCK_VARS (let); t; t = TREE_CHAIN (t))\n     if (DECL_RTL_SET_P (t))\n-      instantiate_decl (DECL_RTL (t), \n+      instantiate_decl (DECL_RTL (t),\n \t\t\tint_size_in_bytes (TREE_TYPE (t)),\n \t\t\tvalid_only);\n \n@@ -4764,7 +4764,7 @@ assign_parms (fndecl)\n \t  if (passed_pointer)\n \t    {\n \t      rtx x = gen_rtx_MEM (TYPE_MODE (TREE_TYPE (passed_type)),\n-\t\t\t     \t   parmreg);\n+\t\t\t\t   parmreg);\n \t      set_mem_attributes (x, parm, 1);\n \t      SET_DECL_RTL (parm, x);\n \t    }\n@@ -4773,7 +4773,7 @@ assign_parms (fndecl)\n \t      SET_DECL_RTL (parm, parmreg);\n \t      maybe_set_unchanging (DECL_RTL (parm), parm);\n \t    }\n-\t      \n+\n \t  /* Copy the value into the register.  */\n \t  if (nominal_mode != passed_mode\n \t      || promoted_nominal_mode != promoted_mode)\n@@ -4855,7 +4855,7 @@ assign_parms (fndecl)\n \t\t  push_to_sequence (conversion_insns);\n \t\t  emit_move_insn (tempreg, DECL_RTL (parm));\n \t\t  SET_DECL_RTL (parm,\n-\t\t\t\tconvert_to_mode (GET_MODE (parmreg), \n+\t\t\t\tconvert_to_mode (GET_MODE (parmreg),\n \t\t\t\t\t\t tempreg,\n \t\t\t\t\t\t unsigned_p));\n \t\t  emit_move_insn (parmreg, DECL_RTL (parm));\n@@ -5491,7 +5491,7 @@ uninitialized_vars_warning (block)\n \twarning_with_decl (decl,\n \t\t\t   \"`%s' might be used uninitialized in this function\");\n       if (extra_warnings\n-          && TREE_CODE (decl) == VAR_DECL\n+\t  && TREE_CODE (decl) == VAR_DECL\n \t  && DECL_RTL (decl) != 0\n \t  && GET_CODE (DECL_RTL (decl)) == REG\n \t  && regno_clobbered_at_setjmp (REGNO (DECL_RTL (decl))))\n@@ -6025,7 +6025,7 @@ reorder_blocks_1 (insns, current_block, p_block_stack)\n \n static void\n reorder_fix_fragments (block)\n-    tree block;\n+     tree block;\n {\n   while (block)\n     {\n@@ -6037,7 +6037,7 @@ reorder_fix_fragments (block)\n \t  if (! TREE_ASM_WRITTEN (dup_origin))\n \t    {\n \t      new_origin = BLOCK_FRAGMENT_CHAIN (dup_origin);\n-\t      \n+\n \t      /* Find the first of the remaining fragments.  There must\n \t\t be at least one -- the current block.  */\n \t      while (! TREE_ASM_WRITTEN (new_origin))\n@@ -6437,7 +6437,7 @@ expand_main_function ()\n #endif\n       if (tmp != stack_pointer_rtx)\n \temit_move_insn (stack_pointer_rtx, tmp);\n-      \n+\n       /* Enlist allocate_dynamic_stack_space to pick up the pieces.  */\n       tmp = force_reg (Pmode, const0_rtx);\n       allocate_dynamic_stack_space (tmp, NULL_RTX, BIGGEST_ALIGNMENT);\n@@ -6613,8 +6613,8 @@ expand_function_start (subr, parms_have_cleanups)\n      avoid conflicts with the parameter passing registers.  */\n \n   if (SMALL_REGISTER_CLASSES && current_function_needs_context)\n-      if (GET_CODE (static_chain_incoming_rtx) != REG)\n-        emit_move_insn (last_ptr, static_chain_incoming_rtx);\n+    if (GET_CODE (static_chain_incoming_rtx) != REG)\n+      emit_move_insn (last_ptr, static_chain_incoming_rtx);\n \n   /* The following was moved from init_function_start.\n      The move is supposed to make sdb output more accurate.  */\n@@ -7014,13 +7014,13 @@ expand_function_end (filename, line, end_bindings)\n \n \t  /* If this is a BLKmode structure being returned in registers,\n \t     then use the mode computed in expand_return.  Note that if\n-\t     decl_rtl is memory, then its mode may have been changed, \n+\t     decl_rtl is memory, then its mode may have been changed,\n \t     but that current_function_return_rtx has not.  */\n \t  if (GET_MODE (real_decl_rtl) == BLKmode)\n \t    PUT_MODE (real_decl_rtl, GET_MODE (decl_rtl));\n \n \t  /* If a named return value dumped decl_return to memory, then\n-\t     we may need to re-do the PROMOTE_MODE signed/unsigned \n+\t     we may need to re-do the PROMOTE_MODE signed/unsigned\n \t     extension.  */\n \t  if (GET_MODE (real_decl_rtl) != GET_MODE (decl_rtl))\n \t    {\n@@ -7087,14 +7087,14 @@ expand_function_end (filename, line, end_bindings)\n   /* Emit the actual code to clobber return register.  */\n   {\n     rtx seq, after;\n-    \n+\n     start_sequence ();\n     clobber_return_register ();\n     seq = gen_sequence ();\n     end_sequence ();\n \n     after = emit_insn_after (seq, clobber_after);\n-    \n+\n     if (clobber_after != after)\n       cfun->x_clobber_return_insn = after;\n   }\n@@ -7131,7 +7131,7 @@ get_arg_pointer_save_area (f)\n     {\n       rtx seq;\n \n-      /* Save the arg pointer at the beginning of the function.  The \n+      /* Save the arg pointer at the beginning of the function.  The\n \t generated stack slot may not be a valid memory address, so we\n \t have to check it and fix it if necessary.  */\n       start_sequence ();\n@@ -7461,7 +7461,7 @@ keep_stack_depressed (seq)\n \n /* SET is a SET from an insn in the epilogue.  P is a pointer to the epi_info\n    structure that contains information about what we've seen so far.  We\n-   process this SET by either updating that data or by emitting one or \n+   process this SET by either updating that data or by emitting one or\n    more insns.  */\n \n static void\n@@ -7884,7 +7884,7 @@ reposition_prologue_and_epilogue_notes (f)\n \t\tbreak;\n \t    }\n \t}\n-\t\t\n+\n       if (last)\n \t{\n \t  rtx next;\n@@ -8000,7 +8000,7 @@ mark_function_status (p)\n     {\n       ggc_mark (q);\n       ggc_mark_rtx (q->modified);\n-      }\n+    }\n \n   ggc_mark_rtx (p->x_nonlocal_goto_handler_slots);\n   ggc_mark_rtx (p->x_nonlocal_goto_handler_labels);"}]}