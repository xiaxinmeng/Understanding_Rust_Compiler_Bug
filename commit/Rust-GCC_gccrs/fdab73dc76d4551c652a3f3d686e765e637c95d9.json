{"sha": "fdab73dc76d4551c652a3f3d686e765e637c95d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmRhYjczZGM3NmQ0NTUxYzY1MmEzZjNkNjg2ZTc2NWU2MzdjOTVkOQ==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2016-05-04T21:13:13Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2016-05-04T21:13:13Z"}, "message": "re PR target/70873 ([7 Regressio] 20% performance regression at 482.sphinx3 after r235442 with -O2 -m32 on Haswell.)\n\n\tPR target/70873\n\t* config/i386/i386.md\n\t(TARGET_SSE_PARTIAL_REG_DEPENDENCY float_extend sf->df peephole2):\n\tChange to post-epilogue_completed late splitter.  Use sse_reg_operand\n\tas operand 0 predicate.\n\t(TARGET_SSE_PARTIAL_REG_DEPENDENCY float_truncate df->sf peephole2):\n\tDitto.\n\t(TARGET_SSE_PARTIAL_REG_DEPENDENCY float {si,di}->{sf,df} peephole2):\n\tDitto.  Emit the pattern using RTX.\n\n\t(TARGET_USE_VECTOR_FP_CONVERTS float_extend sf->df splitter):\n\tUse sse_reg_opreand as operand 0 predicate.  Do not use true_regnum in\n\tthe post-reload splitter.  Use lowpart_subreg instead of gen_rtx_REG.\n\t(TARGET_USE_VECTOR_FP_CONVERTS float_truncate df->sf splitter):\n\tDitto.\n\t(TARGET_USE_VECTOR_CONVERTS float si->{sf,df} splitter): Use\n\tsse_reg_operand as operand 0 predicate.\n\n\t(TARGET_SPLIT_MEM_OPND_FOR_FP_CONVERTS float_extend sf->df peephole2):\n\tUse sse_reg_opreand as operand 0 predicate.  Use lowpart_subreg\n\tinstead of gen_rtx_REG.\n\t(TARGET_SPLIT_MEM_OPND_FOR_FP_CONVERTS float_truncate sf->df peephole2):\n\tDitto.\n\nFrom-SVN: r235906", "tree": {"sha": "41ea71f3e9ca26ed18e279f6cc0d0911c7ea9b98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/41ea71f3e9ca26ed18e279f6cc0d0911c7ea9b98"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fdab73dc76d4551c652a3f3d686e765e637c95d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdab73dc76d4551c652a3f3d686e765e637c95d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fdab73dc76d4551c652a3f3d686e765e637c95d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdab73dc76d4551c652a3f3d686e765e637c95d9/comments", "author": null, "committer": null, "parents": [{"sha": "d07d21777f637293ebf91bff6377f2621a1e7a0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d07d21777f637293ebf91bff6377f2621a1e7a0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d07d21777f637293ebf91bff6377f2621a1e7a0c"}], "stats": {"total": 133, "additions": 77, "deletions": 56}, "files": [{"sha": "772dd37c4ff9bd85a04d1968d8a1dc7422adbb2a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdab73dc76d4551c652a3f3d686e765e637c95d9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdab73dc76d4551c652a3f3d686e765e637c95d9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fdab73dc76d4551c652a3f3d686e765e637c95d9", "patch": "@@ -1,3 +1,29 @@\n+2016-05-04  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\tPR target/70873\n+\t* config/i386/i386.md\n+\t(TARGET_SSE_PARTIAL_REG_DEPENDENCY float_extend sf->df peephole2):\n+\tChange to post-epilogue_completed late splitter.  Use sse_reg_operand\n+\tas operand 0 predicate.\n+\t(TARGET_SSE_PARTIAL_REG_DEPENDENCY float_truncate df->sf peephole2):\n+\tDitto.\n+\t(TARGET_SSE_PARTIAL_REG_DEPENDENCY float {si,di}->{sf,df} peephole2):\n+\tDitto.  Emit the pattern using RTX.\n+\n+\t(TARGET_USE_VECTOR_FP_CONVERTS float_extend sf->df splitter):\n+\tUse sse_reg_opreand as operand 0 predicate.  Do not use true_regnum in\n+\tthe post-reload splitter.  Use lowpart_subreg instead of gen_rtx_REG.\n+\t(TARGET_USE_VECTOR_FP_CONVERTS float_truncate df->sf splitter):\n+\tDitto.\n+\t(TARGET_USE_VECTOR_CONVERTS float si->{sf,df} splitter): Use\n+\tsse_reg_operand as operand 0 predicate.\n+\n+\t(TARGET_SPLIT_MEM_OPND_FOR_FP_CONVERTS float_extend sf->df peephole2):\n+\tUse sse_reg_opreand as operand 0 predicate.  Use lowpart_subreg\n+\tinstead of gen_rtx_REG.\n+\t(TARGET_SPLIT_MEM_OPND_FOR_FP_CONVERTS float_truncate sf->df peephole2):\n+\tDitto.\n+\n 2016-05-04  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \t* function.c (emit_use_return_register_into_block): Delete.\n@@ -94,8 +120,7 @@\n \n \t* match.pd: Add BIT_FIELD_REF canonicalizations and vector\n \tconstructor simplifications.\n-\t* fold-const.c (fold_ternary_loc): Remove duplicate functionality\n-\there.\n+\t* fold-const.c (fold_ternary_loc): Remove duplicate functionality here.\n \n 2016-05-04  Oleg Endo  <olegendo@gcc.gnu.org>\n \n@@ -219,8 +244,7 @@\n 2016-05-03  Jakub Jelinek  <jakub@redhat.com>\n \n \t* config/i386/i386.md (*truncdfsf_mixed, *truncdfsf_i387,\n-\t*truncxfsf2_mixed, *truncxfdf2_mixed): Use v constraint instead\n-\tof x.\n+\t*truncxfsf2_mixed, *truncxfdf2_mixed): Use v constraint instead of x.\n \n 2016-05-03  Richard Biener  <rguenther@suse.de>\n "}, {"sha": "dd56b0523e80955f41e6fe901f93d2ac851ba206", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 49, "deletions": 52, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdab73dc76d4551c652a3f3d686e765e637c95d9/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdab73dc76d4551c652a3f3d686e765e637c95d9/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=fdab73dc76d4551c652a3f3d686e765e637c95d9", "patch": "@@ -4231,12 +4231,12 @@\n    that might lead to ICE on 32bit target.  The sequence unlikely combine\n    anyway.  */\n (define_split\n-  [(set (match_operand:DF 0 \"register_operand\")\n+  [(set (match_operand:DF 0 \"sse_reg_operand\")\n         (float_extend:DF\n \t  (match_operand:SF 1 \"nonimmediate_operand\")))]\n   \"TARGET_USE_VECTOR_FP_CONVERTS\n    && optimize_insn_for_speed_p ()\n-   && reload_completed && SSE_REG_P (operands[0])\n+   && reload_completed\n    && (!EXT_REX_SSE_REG_P (operands[0])\n        || TARGET_AVX512VL)\"\n    [(set (match_dup 2)\n@@ -4253,21 +4253,19 @@\n     {\n       /* If it is unsafe to overwrite upper half of source, we need\n \t to move to destination and unpack there.  */\n-      if (((ORIGINAL_REGNO (operands[1]) < FIRST_PSEUDO_REGISTER\n-\t    || PSEUDO_REGNO_BYTES (ORIGINAL_REGNO (operands[1])) > 4)\n-\t   && true_regnum (operands[0]) != true_regnum (operands[1]))\n+      if (REGNO (operands[0]) != REGNO (operands[1])\n \t  || (EXT_REX_SSE_REG_P (operands[1])\n \t      && !TARGET_AVX512VL))\n \t{\n-\t  rtx tmp = gen_rtx_REG (SFmode, true_regnum (operands[0]));\n+\t  rtx tmp = lowpart_subreg (SFmode, operands[0], DFmode);\n \t  emit_move_insn (tmp, operands[1]);\n \t}\n       else\n \toperands[3] = lowpart_subreg (V4SFmode, operands[1], SFmode);\n       /* FIXME: vec_interleave_lowv4sf for AVX512VL should allow\n \t =v, v, then vbroadcastss will be only needed for AVX512F without\n \t AVX512VL.  */\n-      if (!EXT_REX_SSE_REGNO_P (true_regnum (operands[3])))\n+      if (!EXT_REX_SSE_REGNO_P (REGNO (operands[3])))\n \temit_insn (gen_vec_interleave_lowv4sf (operands[3], operands[3],\n \t\t\t\t\t       operands[3]));\n       else\n@@ -4283,15 +4281,14 @@\n \n ;; It's more profitable to split and then extend in the same register.\n (define_peephole2\n-  [(set (match_operand:DF 0 \"register_operand\")\n+  [(set (match_operand:DF 0 \"sse_reg_operand\")\n \t(float_extend:DF\n \t  (match_operand:SF 1 \"memory_operand\")))]\n   \"TARGET_SPLIT_MEM_OPND_FOR_FP_CONVERTS\n-   && optimize_insn_for_speed_p ()\n-   && SSE_REG_P (operands[0])\"\n+   && optimize_insn_for_speed_p ()\"\n   [(set (match_dup 2) (match_dup 1))\n    (set (match_dup 0) (float_extend:DF (match_dup 2)))]\n-  \"operands[2] = gen_rtx_REG (SFmode, REGNO (operands[0]));\")\n+  \"operands[2] = lowpart_subreg (SFmode, operands[0], DFmode);\")\n \n (define_insn \"*extendsfdf2\"\n   [(set (match_operand:DF 0 \"nonimm_ssenomem_operand\" \"=f,m,v\")\n@@ -4390,12 +4387,12 @@\n    that might lead to ICE on 32bit target.  The sequence unlikely combine\n    anyway.  */\n (define_split\n-  [(set (match_operand:SF 0 \"register_operand\")\n+  [(set (match_operand:SF 0 \"sse_reg_operand\")\n         (float_truncate:SF\n \t  (match_operand:DF 1 \"nonimmediate_operand\")))]\n   \"TARGET_USE_VECTOR_FP_CONVERTS\n    && optimize_insn_for_speed_p ()\n-   && reload_completed && SSE_REG_P (operands[0])\n+   && reload_completed\n    && (!EXT_REX_SSE_REG_P (operands[0])\n        || TARGET_AVX512VL)\"\n    [(set (match_dup 2)\n@@ -4413,9 +4410,7 @@\n   if (REG_P (operands[1]))\n     {\n       if (!TARGET_SSE3\n-\t  && true_regnum (operands[0]) != true_regnum (operands[1])\n-\t  && (ORIGINAL_REGNO (operands[1]) < FIRST_PSEUDO_REGISTER\n-\t      || PSEUDO_REGNO_BYTES (ORIGINAL_REGNO (operands[1])) > 8))\n+\t  && REGNO (operands[0]) != REGNO (operands[1]))\n \t{\n \t  rtx tmp = lowpart_subreg (DFmode, operands[0], SFmode);\n \t  emit_move_insn (tmp, operands[1]);\n@@ -4432,15 +4427,14 @@\n \n ;; It's more profitable to split and then extend in the same register.\n (define_peephole2\n-  [(set (match_operand:SF 0 \"register_operand\")\n+  [(set (match_operand:SF 0 \"sse_reg_operand\")\n \t(float_truncate:SF\n \t  (match_operand:DF 1 \"memory_operand\")))]\n   \"TARGET_SPLIT_MEM_OPND_FOR_FP_CONVERTS\n-   && optimize_insn_for_speed_p ()\n-   && SSE_REG_P (operands[0])\"\n+   && optimize_insn_for_speed_p ()\"\n   [(set (match_dup 2) (match_dup 1))\n    (set (match_dup 0) (float_truncate:SF (match_dup 2)))]\n-  \"operands[2] = gen_rtx_REG (DFmode, REGNO (operands[0]));\")\n+  \"operands[2] = lowpart_subreg (DFmode, operands[0], SFmode);\")\n \n (define_expand \"truncdfsf2_with_temp\"\n   [(parallel [(set (match_operand:SF 0)\n@@ -4547,7 +4541,7 @@\n   \"reload_completed\"\n   [(set (match_dup 2) (match_dup 1))\n    (set (match_dup 0) (match_dup 2))]\n-  \"operands[1] = gen_rtx_REG (SFmode, true_regnum (operands[1]));\")\n+  \"operands[1] = gen_rtx_REG (SFmode, REGNO (operands[1]));\")\n \n ;; Conversion from XFmode to {SF,DF}mode\n \n@@ -5153,11 +5147,11 @@\n ;; slots when !TARGET_INTER_UNIT_MOVES_TO_VEC disables the general_regs\n ;; alternative in sse2_loadld.\n (define_split\n-  [(set (match_operand:MODEF 0 \"register_operand\")\n+  [(set (match_operand:MODEF 0 \"sse_reg_operand\")\n \t(float:MODEF (match_operand:SI 1 \"nonimmediate_operand\")))]\n-  \"TARGET_SSE2 && TARGET_SSE_MATH\n-   && TARGET_USE_VECTOR_CONVERTS && optimize_function_for_speed_p (cfun)\n-   && reload_completed && SSE_REG_P (operands[0])\n+  \"TARGET_USE_VECTOR_CONVERTS\n+   && optimize_function_for_speed_p (cfun)\n+   && reload_completed\n    && (MEM_P (operands[1]) || TARGET_INTER_UNIT_MOVES_TO_VEC)\n    && (!EXT_REX_SSE_REG_P (operands[0])\n        || TARGET_AVX512VL)\"\n@@ -5176,41 +5170,43 @@\n   DONE;\n })\n \n-;; Avoid partial SSE register dependency stalls\n+;; Avoid partial SSE register dependency stalls.  This splitter should split\n+;; late in the pass sequence (after register rename pass), so allocated\n+;; registers won't change anymore\n+\n (define_split\n-  [(set (match_operand:MODEF 0 \"register_operand\")\n+  [(set (match_operand:MODEF 0 \"sse_reg_operand\")\n \t(float:MODEF (match_operand:SWI48 1 \"nonimmediate_operand\")))]\n-  \"TARGET_SSE2 && TARGET_SSE_MATH\n-   && TARGET_SSE_PARTIAL_REG_DEPENDENCY\n+  \"TARGET_SSE_PARTIAL_REG_DEPENDENCY\n    && optimize_function_for_speed_p (cfun)\n-   && reload_completed && SSE_REG_P (operands[0])\n+   && epilogue_completed\n    && (!EXT_REX_SSE_REG_P (operands[0])\n        || TARGET_AVX512VL)\"\n-  [(const_int 0)]\n+  [(set (match_dup 0)\n+\t(vec_merge:<MODEF:ssevecmode>\n+\t  (vec_duplicate:<MODEF:ssevecmode>\n+\t    (float:MODEF\n+\t      (match_dup 1)))\n+\t  (match_dup 0)\n+\t  (const_int 1)))]\n {\n   const machine_mode vmode = <MODEF:ssevecmode>mode;\n-  const machine_mode mode = <MODEF:MODE>mode;\n-  rtx t, op0 = lowpart_subreg (vmode, operands[0], mode);\n-\n-  emit_move_insn (op0, CONST0_RTX (vmode));\n \n-  t = gen_rtx_FLOAT (mode, operands[1]);\n-  t = gen_rtx_VEC_DUPLICATE (vmode, t);\n-  t = gen_rtx_VEC_MERGE (vmode, t, op0, const1_rtx);\n-  emit_insn (gen_rtx_SET (op0, t));\n-  DONE;\n+  operands[0] = lowpart_subreg (vmode, operands[0], <MODEF:MODE>mode);\n+  emit_move_insn (operands[0], CONST0_RTX (vmode));\n })\n \n-;; Break partial reg stall for cvtsd2ss.\n+;; Break partial reg stall for cvtsd2ss.  This splitter should split\n+;; late in the pass sequence (after register rename pass),\n+;; so allocated registers won't change anymore.\n \n-(define_peephole2\n-  [(set (match_operand:SF 0 \"register_operand\")\n+(define_split\n+  [(set (match_operand:SF 0 \"sse_reg_operand\")\n         (float_truncate:SF\n \t  (match_operand:DF 1 \"nonimmediate_operand\")))]\n-  \"TARGET_SSE2 && TARGET_SSE_MATH\n-   && TARGET_SSE_PARTIAL_REG_DEPENDENCY\n+  \"TARGET_SSE_PARTIAL_REG_DEPENDENCY\n    && optimize_function_for_speed_p (cfun)\n-   && SSE_REG_P (operands[0])\n+   && epilogue_completed\n    && (!SSE_REG_P (operands[1])\n        || REGNO (operands[0]) != REGNO (operands[1]))\n    && (!EXT_REX_SSE_REG_P (operands[0])\n@@ -5228,16 +5224,17 @@\n   emit_move_insn (operands[0], CONST0_RTX (V4SFmode));\n })\n \n-;; Break partial reg stall for cvtss2sd.\n+;; Break partial reg stall for cvtss2sd.  This splitter should split\n+;; late in the pass sequence (after register rename pass),\n+;; so allocated registers won't change anymore.\n \n-(define_peephole2\n-  [(set (match_operand:DF 0 \"register_operand\")\n+(define_split\n+  [(set (match_operand:DF 0 \"sse_reg_operand\")\n         (float_extend:DF\n           (match_operand:SF 1 \"nonimmediate_operand\")))]\n-  \"TARGET_SSE2 && TARGET_SSE_MATH\n-   && TARGET_SSE_PARTIAL_REG_DEPENDENCY\n+  \"TARGET_SSE_PARTIAL_REG_DEPENDENCY\n    && optimize_function_for_speed_p (cfun)\n-   && SSE_REG_P (operands[0])\n+   && epilogue_completed\n    && (!SSE_REG_P (operands[1])\n        || REGNO (operands[0]) != REGNO (operands[1]))\n    && (!EXT_REX_SSE_REG_P (operands[0])"}]}