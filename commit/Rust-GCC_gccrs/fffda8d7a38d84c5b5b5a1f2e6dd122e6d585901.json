{"sha": "fffda8d7a38d84c5b5b5a1f2e6dd122e6d585901", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmZmZGE4ZDdhMzhkODRjNWI1YjVhMWYyZTZkZDEyMmU2ZDU4NTkwMQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-10-15T11:13:04Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-10-15T11:13:04Z"}, "message": "lto.c (hash_canonical_type): Split out from ...\n\n2013-10-15  Richard Biener  <rguenther@suse.de>\n\n\tlto/\n\t* lto.c (hash_canonical_type): Split out from ...\n\t(iterative_hash_canonical_type): ... here.  Register types\n\twe recurse to.\n\t(gimple_canonical_type_hash): Adjust.\n\t(gimple_register_canonical_type_1): Split out from ...\n\t(gimple_register_canonical_type): ... here.  Cache computed\n\thash value.\n\t(lto_register_canonical_types): Split into two modes,\n\tclearing and computing TYPE_CANONICAL.\n\t(lto_read_decls): Adjust.\n\t(read_cgraph_and_symbols): Do two passes over global trees,\n\tfirst clearing then computing TYPE_CANONICAL.\n\nFrom-SVN: r203600", "tree": {"sha": "0bc266957334d7f4625e0ead76ba145b6517a2eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0bc266957334d7f4625e0ead76ba145b6517a2eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fffda8d7a38d84c5b5b5a1f2e6dd122e6d585901", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fffda8d7a38d84c5b5b5a1f2e6dd122e6d585901", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fffda8d7a38d84c5b5b5a1f2e6dd122e6d585901", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fffda8d7a38d84c5b5b5a1f2e6dd122e6d585901/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7569f6972e44e6c1f00ca5e64d940a90e0bc3e24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7569f6972e44e6c1f00ca5e64d940a90e0bc3e24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7569f6972e44e6c1f00ca5e64d940a90e0bc3e24"}], "stats": {"total": 148, "additions": 103, "deletions": 45}, "files": [{"sha": "ab0b9a909deaab43f7a7c9a640b869519a0794fe", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fffda8d7a38d84c5b5b5a1f2e6dd122e6d585901/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fffda8d7a38d84c5b5b5a1f2e6dd122e6d585901/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=fffda8d7a38d84c5b5b5a1f2e6dd122e6d585901", "patch": "@@ -1,3 +1,18 @@\n+2013-10-15  Richard Biener  <rguenther@suse.de>\n+\n+\t* lto.c (hash_canonical_type): Split out from ...\n+\t(iterative_hash_canonical_type): ... here.  Register types\n+\twe recurse to.\n+\t(gimple_canonical_type_hash): Adjust.\n+\t(gimple_register_canonical_type_1): Split out from ...\n+\t(gimple_register_canonical_type): ... here.  Cache computed\n+\thash value.\n+\t(lto_register_canonical_types): Split into two modes,\n+\tclearing and computing TYPE_CANONICAL.\n+\t(lto_read_decls): Adjust.\n+\t(read_cgraph_and_symbols): Do two passes over global trees,\n+\tfirst clearing then computing TYPE_CANONICAL.\n+\n 2013-10-14  Richard Biener  <rguenther@suse.de>\n \n \t* lto.c (gimple_canonical_types): Move out-of GC space."}, {"sha": "d9c36dcc5d68628121bb552a1cce36541759c969", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 88, "deletions": 45, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fffda8d7a38d84c5b5b5a1f2e6dd122e6d585901/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fffda8d7a38d84c5b5b5a1f2e6dd122e6d585901/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=fffda8d7a38d84c5b5b5a1f2e6dd122e6d585901", "patch": "@@ -260,21 +260,19 @@ static pointer_map <hashval_t> *canonical_type_hash_cache;\n static unsigned long num_canonical_type_hash_entries;\n static unsigned long num_canonical_type_hash_queries;\n \n-/* Returning a hash value for gimple type TYPE combined with VAL.\n+static hashval_t iterative_hash_canonical_type (tree type, hashval_t val);\n+static hashval_t gimple_canonical_type_hash (const void *p);\n+static void gimple_register_canonical_type_1 (tree t, hashval_t hash);\n+\n+/* Returning a hash value for gimple type TYPE.\n \n    The hash value returned is equal for types considered compatible\n    by gimple_canonical_types_compatible_p.  */\n \n static hashval_t\n-iterative_hash_canonical_type (tree type, hashval_t val)\n+hash_canonical_type (tree type)\n {\n   hashval_t v;\n-  hashval_t *slot;\n-\n-  num_canonical_type_hash_queries++;\n-  slot = canonical_type_hash_cache->contains (type);\n-  if (slot)\n-    return iterative_hash_hashval_t (*slot, val);\n \n   /* Combine a few common features of types so that types are grouped into\n      smaller sets; when searching for existing matching types to merge,\n@@ -373,18 +371,43 @@ iterative_hash_canonical_type (tree type, hashval_t val)\n       v = iterative_hash_hashval_t (nf, v);\n     }\n \n-  /* Cache the just computed hash value.  */\n-  num_canonical_type_hash_entries++;\n-  slot = canonical_type_hash_cache->insert (type);\n-  *slot = v;\n+  return v;\n+}\n+\n+/* Returning a hash value for gimple type TYPE combined with VAL.  */\n \n+static hashval_t\n+iterative_hash_canonical_type (tree type, hashval_t val)\n+{\n+  hashval_t v;\n+  /* An already processed type.  */\n+  if (TYPE_CANONICAL (type))\n+    {\n+      type = TYPE_CANONICAL (type);\n+      v = gimple_canonical_type_hash (type);\n+    }\n+  else\n+    {\n+      /* Canonical types should not be able to form SCCs by design, this\n+\t recursion is just because we do not register canonical types in\n+\t optimal order.  To avoid quadratic behavior also register the\n+\t type here.  */\n+      v = hash_canonical_type (type);\n+      gimple_register_canonical_type_1 (type, v);\n+    }\n   return iterative_hash_hashval_t (v, val);\n }\n \n+/* Returns the hash for a canonical type P.  */\n+\n static hashval_t\n gimple_canonical_type_hash (const void *p)\n {\n-  return iterative_hash_canonical_type (CONST_CAST_TREE ((const_tree) p), 0);\n+  num_canonical_type_hash_queries++;\n+  hashval_t *slot\n+    = canonical_type_hash_cache->contains (CONST_CAST_TREE ((const_tree) p));\n+  gcc_assert (slot != NULL);\n+  return *slot;\n }\n \n \n@@ -614,60 +637,73 @@ gimple_canonical_type_eq (const void *p1, const void *p2)\n \t\t\t\t\t      CONST_CAST_TREE (t2));\n }\n \n-/* Register type T in the global type table gimple_types.\n-   If another type T', compatible with T, already existed in\n-   gimple_types then return T', otherwise return T.  This is used by\n-   LTO to merge identical types read from different TUs.\n-\n-   ???  This merging does not exactly match how the tree.c middle-end\n-   functions will assign TYPE_CANONICAL when new types are created\n-   during optimization (which at least happens for pointer and array\n-   types).  */\n+/* Main worker for gimple_register_canonical_type.  */\n \n-static tree\n-gimple_register_canonical_type (tree t)\n+static void\n+gimple_register_canonical_type_1 (tree t, hashval_t hash)\n {\n   void **slot;\n \n-  gcc_assert (TYPE_P (t));\n-\n-  if (TYPE_CANONICAL (t))\n-    return TYPE_CANONICAL (t);\n+  gcc_checking_assert (TYPE_P (t) && !TYPE_CANONICAL (t));\n \n-  slot = htab_find_slot (gimple_canonical_types, t, INSERT);\n-  if (*slot\n-      && *(tree *)slot != t)\n+  slot = htab_find_slot_with_hash (gimple_canonical_types, t, hash, INSERT);\n+  if (*slot)\n     {\n-      tree new_type = (tree) *((tree *) slot);\n-\n+      tree new_type = (tree)(*slot);\n+      gcc_checking_assert (new_type != t);\n       TYPE_CANONICAL (t) = new_type;\n-      t = new_type;\n     }\n   else\n     {\n       TYPE_CANONICAL (t) = t;\n       *slot = (void *) t;\n+      /* Cache the just computed hash value.  */\n+      num_canonical_type_hash_entries++;\n+      bool existed_p;\n+      hashval_t *hslot = canonical_type_hash_cache->insert (t, &existed_p);\n+      gcc_assert (!existed_p);\n+      *hslot = hash;\n     }\n+}\n+\n+/* Register type T in the global type table gimple_types and set\n+   TYPE_CANONICAL of T accordingly.\n+   This is used by LTO to merge structurally equivalent types for\n+   type-based aliasing purposes across different TUs and languages.\n+\n+   ???  This merging does not exactly match how the tree.c middle-end\n+   functions will assign TYPE_CANONICAL when new types are created\n+   during optimization (which at least happens for pointer and array\n+   types).  */\n \n-  return t;\n+static void\n+gimple_register_canonical_type (tree t)\n+{\n+  if (TYPE_CANONICAL (t))\n+    return;\n+\n+  gimple_register_canonical_type_1 (t, hash_canonical_type (t));\n }\n \n /* Re-compute TYPE_CANONICAL for NODE and related types.  */\n \n static void\n-lto_register_canonical_types (tree node)\n+lto_register_canonical_types (tree node, bool first_p)\n {\n   if (!node\n       || !TYPE_P (node))\n     return;\n \n-  TYPE_CANONICAL (node) = NULL_TREE;\n-  TYPE_CANONICAL (node) = gimple_register_canonical_type (node);\n+  if (first_p)\n+    TYPE_CANONICAL (node) = NULL_TREE;\n \n   if (POINTER_TYPE_P (node)\n       || TREE_CODE (node) == COMPLEX_TYPE\n       || TREE_CODE (node) == ARRAY_TYPE)\n-    lto_register_canonical_types (TREE_TYPE (node));\n+    lto_register_canonical_types (TREE_TYPE (node), first_p);\n+\n+ if (!first_p) \n+    gimple_register_canonical_type (node);\n }\n \n \n@@ -1845,7 +1881,7 @@ lto_read_decls (struct lto_file_decl_data *decl_data, const void *data,\n \t      /* Compute the canonical type of all types.\n \t\t ???  Should be able to assert that !TYPE_CANONICAL.  */\n \t      if (TYPE_P (t) && !TYPE_CANONICAL (t))\n-\t\tTYPE_CANONICAL (t) = gimple_register_canonical_type (t);\n+\t\tgimple_register_canonical_type (t);\n \t      /* Link shared INTEGER_CSTs into TYPE_CACHED_VALUEs of its\n \t\t type which is also member of this SCC.  */\n \t      if (TREE_CODE (t) == INTEGER_CST\n@@ -2753,13 +2789,20 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n   /* Register the common node types with the canonical type machinery so\n      we properly share alias-sets across languages and TUs.  Do not\n      expose the common nodes as type merge target - those that should be\n-     are already exposed so by pre-loading the LTO streamer caches.  */\n+     are already exposed so by pre-loading the LTO streamer caches.\n+     Do two passes - first clear TYPE_CANONICAL and then re-compute it.  */\n+  for (i = 0; i < itk_none; ++i)\n+    lto_register_canonical_types (integer_types[i], true);\n+  for (i = 0; i < stk_type_kind_last; ++i)\n+    lto_register_canonical_types (sizetype_tab[i], true);\n+  for (i = 0; i < TI_MAX; ++i)\n+    lto_register_canonical_types (global_trees[i], true);\n   for (i = 0; i < itk_none; ++i)\n-    lto_register_canonical_types (integer_types[i]);\n-  /* The sizetypes are not used to access data so we do not need to\n-     do anything about them.  */\n+    lto_register_canonical_types (integer_types[i], false);\n+  for (i = 0; i < stk_type_kind_last; ++i)\n+    lto_register_canonical_types (sizetype_tab[i], false);\n   for (i = 0; i < TI_MAX; ++i)\n-    lto_register_canonical_types (global_trees[i]);\n+    lto_register_canonical_types (global_trees[i], false);\n \n   if (!quiet_flag)\n     fprintf (stderr, \"Reading object files:\");"}]}