{"sha": "d3b0dc686c00bfe9e7f4fe0490def68e9b92157a", "node_id": "C_kwDOANBUbNoAKGQzYjBkYzY4NmMwMGJmZTllN2Y0ZmUwNDkwZGVmNjhlOWI5MjE1N2E", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-03-12T20:00:51Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-03-12T20:00:51Z"}, "message": "c++: naming a dependently-scoped template for CTAD [PR104641]\n\nIn order to be able to perform CTAD for a dependently-scoped template\n(such as A<T>::B in the testcase below), we need to permit a\ntypename-specifier to resolve to a template as per [dcl.type.simple]/3,\nat least when it appears in a CTAD-enabled context.\n\nThis patch implements this using a new tsubst flag tf_tst_ok to control\nwhen a TYPENAME_TYPE is allowed to name a template, and sets this flag\nwhen substituting into the type of a CAST_EXPR, CONSTRUCTOR or VAR_DECL\n(each of which is a CTAD-enabled context).\n\n\tPR c++/104641\n\ngcc/cp/ChangeLog:\n\n\t* cp-tree.h (tsubst_flags::tf_tst_ok): New flag.\n\t* decl.cc (make_typename_type): Allow a typename-specifier to\n\tresolve to a template when tf_tst_ok, in which case return\n\ta CTAD placeholder for the template.\n\t* pt.cc (tsubst_decl) <case VAR_DECL>: Set tf_tst_ok when\n\tsubstituting the type.\n\t(tsubst): Clear tf_tst_ok and remember if it was set.\n\t<case TYPENAME_TYPE>: Pass tf_tst_ok to make_typename_type\n\tappropriately.\n\t(tsubst_copy) <case CAST_EXPR>: Set tf_tst_ok when substituting\n\tthe type.\n\t(tsubst_copy_and_build) <case CAST_EXPR>: Likewise.\n\t<case CONSTRUCTOR>: Likewise.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp1z/class-deduction107.C: New test.", "tree": {"sha": "28075dfe71b0a509f6b46e681ec9971663da8b15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28075dfe71b0a509f6b46e681ec9971663da8b15"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d3b0dc686c00bfe9e7f4fe0490def68e9b92157a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3b0dc686c00bfe9e7f4fe0490def68e9b92157a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3b0dc686c00bfe9e7f4fe0490def68e9b92157a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3b0dc686c00bfe9e7f4fe0490def68e9b92157a/comments", "author": null, "committer": null, "parents": [{"sha": "03c83cf7aa1110e427beb00ea95767dfaf50d694", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03c83cf7aa1110e427beb00ea95767dfaf50d694", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03c83cf7aa1110e427beb00ea95767dfaf50d694"}], "stats": {"total": 73, "additions": 63, "deletions": 10}, "files": [{"sha": "a4bc48a4a20c28777be73575a5d88e5e6d64af1b", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3b0dc686c00bfe9e7f4fe0490def68e9b92157a/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3b0dc686c00bfe9e7f4fe0490def68e9b92157a/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=d3b0dc686c00bfe9e7f4fe0490def68e9b92157a", "patch": "@@ -5563,6 +5563,8 @@ enum tsubst_flags {\n \t\t\t\t(build_target_expr and friends) */\n   tf_norm = 1 << 11,\t\t /* Build diagnostic information during\n \t\t\t\t    constraint normalization.  */\n+  tf_tst_ok = 1 << 12,\t\t /* Allow a typename-specifier to name\n+\t\t\t\t    a template (C++17 or later).  */\n   /* Convenient substitution flags combinations.  */\n   tf_warning_or_error = tf_warning | tf_error\n };"}, {"sha": "8afda8264c4e3c198ee17e6a37a24100c3bea9f5", "filename": "gcc/cp/decl.cc", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3b0dc686c00bfe9e7f4fe0490def68e9b92157a/gcc%2Fcp%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3b0dc686c00bfe9e7f4fe0490def68e9b92157a/gcc%2Fcp%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.cc?ref=d3b0dc686c00bfe9e7f4fe0490def68e9b92157a", "patch": "@@ -4204,16 +4204,26 @@ make_typename_type (tree context, tree name, enum tag_types tag_type,\n     }\n   if (!want_template && TREE_CODE (t) != TYPE_DECL)\n     {\n-      if (complain & tf_error)\n-\terror (\"%<typename %T::%D%> names %q#T, which is not a type\",\n-\t       context, name, t);\n-      return error_mark_node;\n+      if ((complain & tf_tst_ok) && cxx_dialect >= cxx17\n+\t  && DECL_TYPE_TEMPLATE_P (t))\n+\t/* The caller permits this typename-specifier to name a template\n+\t   (because it appears in a CTAD-enabled context).  */;\n+      else\n+\t{\n+\t  if (complain & tf_error)\n+\t    error (\"%<typename %T::%D%> names %q#T, which is not a type\",\n+\t\t   context, name, t);\n+\t  return error_mark_node;\n+\t}\n     }\n \n   if (!check_accessibility_of_qualified_id (t, /*object_type=*/NULL_TREE,\n \t\t\t\t\t    context, complain))\n     return error_mark_node;\n \n+  if (!want_template && DECL_TYPE_TEMPLATE_P (t))\n+    return make_template_placeholder (t);\n+\n   if (want_template)\n     {\n       t = lookup_template_class (t, TREE_OPERAND (fullname, 1),"}, {"sha": "715eea275779b022d6a96afb172ed0b9aabfdbcb", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3b0dc686c00bfe9e7f4fe0490def68e9b92157a/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3b0dc686c00bfe9e7f4fe0490def68e9b92157a/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=d3b0dc686c00bfe9e7f4fe0490def68e9b92157a", "patch": "@@ -14896,7 +14896,10 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t\t&& VAR_HAD_UNKNOWN_BOUND (t)\n \t\t&& type != error_mark_node)\n \t      type = strip_array_domain (type);\n-\t    type = tsubst (type, args, complain, in_decl);\n+\t    tsubst_flags_t tcomplain = complain;\n+\t    if (VAR_P (t))\n+\t      tcomplain |= tf_tst_ok;\n+\t    type = tsubst (type, args, tcomplain, in_decl);\n \t    /* Substituting the type might have recursively instantiated this\n \t       same alias (c++/86171).  */\n \t    if (gen_tmpl && DECL_ALIAS_TEMPLATE_P (gen_tmpl)\n@@ -15582,6 +15585,9 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n   bool fndecl_type = (complain & tf_fndecl_type);\n   complain &= ~tf_fndecl_type;\n \n+  bool tst_ok = (complain & tf_tst_ok);\n+  complain &= ~tf_tst_ok;\n+\n   if (type\n       && code != TYPENAME_TYPE\n       && code != TEMPLATE_TYPE_PARM\n@@ -16169,8 +16175,10 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t      return error_mark_node;\n \t  }\n \n-\tf = make_typename_type (ctx, f, typename_type,\n-\t\t\t\tcomplain | tf_keep_type_decl);\n+\ttsubst_flags_t tcomplain = complain | tf_keep_type_decl;\n+\tif (tst_ok)\n+\t  tcomplain |= tf_tst_ok;\n+\tf = make_typename_type (ctx, f, typename_type, tcomplain);\n \tif (f == error_mark_node)\n \t  return f;\n \tif (TREE_CODE (f) == TYPE_DECL)\n@@ -17077,7 +17085,10 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n     case CONVERT_EXPR:\n     case NOP_EXPR:\n       {\n-\ttree type = tsubst (TREE_TYPE (t), args, complain, in_decl);\n+\ttsubst_flags_t tcomplain = complain;\n+\tif (code == CAST_EXPR)\n+\t  tcomplain |= tf_tst_ok;\n+\ttree type = tsubst (TREE_TYPE (t), args, tcomplain, in_decl);\n \ttree op0 = tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl);\n \treturn build1 (code, type, op0);\n       }\n@@ -20100,7 +20111,10 @@ tsubst_copy_and_build (tree t,\n \ttree type;\n \ttree op, r = NULL_TREE;\n \n-\ttype = tsubst (TREE_TYPE (t), args, complain, in_decl);\n+\ttsubst_flags_t tcomplain = complain;\n+\tif (TREE_CODE (t) == CAST_EXPR)\n+\t  tcomplain |= tf_tst_ok;\n+\ttype = tsubst (TREE_TYPE (t), args, tcomplain, in_decl);\n \tif (integral_constant_expression_p\n \t    && !cast_valid_in_integral_constant_expression_p (type))\n \t  {\n@@ -21060,12 +21074,15 @@ tsubst_copy_and_build (tree t,\n \tvec<constructor_elt, va_gc> *n;\n \tconstructor_elt *ce;\n \tunsigned HOST_WIDE_INT idx;\n-\ttree type = tsubst (TREE_TYPE (t), args, complain, in_decl);\n \tbool process_index_p;\n         int newlen;\n         bool need_copy_p = false;\n \ttree r;\n \n+\ttsubst_flags_t tcomplain = complain;\n+\tif (COMPOUND_LITERAL_P (t))\n+\t  tcomplain |= tf_tst_ok;\n+\ttree type = tsubst (TREE_TYPE (t), args, tcomplain, in_decl);\n \tif (type == error_mark_node)\n \t  RETURN (error_mark_node);\n "}, {"sha": "1492f391ec1216a6f37f6676b9ac17ea7e435b8a", "filename": "gcc/testsuite/g++.dg/cpp1z/class-deduction107.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3b0dc686c00bfe9e7f4fe0490def68e9b92157a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction107.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3b0dc686c00bfe9e7f4fe0490def68e9b92157a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction107.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction107.C?ref=d3b0dc686c00bfe9e7f4fe0490def68e9b92157a", "patch": "@@ -0,0 +1,24 @@\n+// PR c++/104641\n+// { dg-do compile { target c++11 } }\n+\n+template<class T>\n+struct A {\n+  template<class U> struct B { B(U); };\n+private:\n+  template<class U> struct C { C(U); };\n+};\n+\n+template<class T>\n+void f() {\n+  typename A<T>::B x = 0;\n+  auto y = typename A<T>::B(0);\n+  auto z = typename A<T>::B{0};\n+  typename A<T>::C w(0); // { dg-error \"private\" \"\" { target c++17 } }\n+}\n+\n+template void f<void>();\n+\n+// { dg-error \"not a type\" \"\" { target c++14_down } 13 }\n+// { dg-error \"not a type\" \"\" { target c++14_down } 14 }\n+// { dg-error \"not a type\" \"\" { target c++14_down } 15 }\n+// { dg-error \"not a type\" \"\" { target c++14_down } 16 }"}]}