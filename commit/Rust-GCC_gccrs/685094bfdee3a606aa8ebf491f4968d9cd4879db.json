{"sha": "685094bfdee3a606aa8ebf491f4968d9cd4879db", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njg1MDk0YmZkZWUzYTYwNmFhOGViZjQ5MWY0OTY4ZDljZDQ4NzlkYg==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2008-05-20T12:44:55Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-05-20T12:44:55Z"}, "message": "re PR ada/30740 (Improper semantics in gnat's compilation of certain expressions involving modular arithmetic)\n\n2008-05-20  Robert Dewar  <dewar@adacore.com>\n\n\tPR ada/30740\n\t* einfo.ads, einfo.adb (Non_Binary_Modulus): Applies to all types and\n\tsubtypes, always False for non-modular types.\n\tShared_Var_Assign_Proc (node22) and Shared_Var_Read_Proc (node 15)\n\tentry nodes have been replaced by Shared_Var_Procs_Instance (node22)\n\tfor Shared_Storage package.\n\t(Is_RACW_Stub_Type): New entity flag.\n\n\t* exp_ch4.adb\n\t(Expand_N_Op_Expon): Avoid incorrect optimization of a*(2**b) in the\n\tcase where we have a modular type with a non-binary modules.\n\tComments reformattings.\n\n\t* sem_intr.adb: Simplify code not that Non_Binary_Modulus applies to\n\tall types.\n\nFrom-SVN: r135619", "tree": {"sha": "07adf48529a7f93ac90b78c757b1211f4363f826", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/07adf48529a7f93ac90b78c757b1211f4363f826"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/685094bfdee3a606aa8ebf491f4968d9cd4879db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/685094bfdee3a606aa8ebf491f4968d9cd4879db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/685094bfdee3a606aa8ebf491f4968d9cd4879db", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/685094bfdee3a606aa8ebf491f4968d9cd4879db/comments", "author": null, "committer": null, "parents": [{"sha": "e7841bacf5a86bd2523a39abb8e6f6385297b6fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7841bacf5a86bd2523a39abb8e6f6385297b6fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7841bacf5a86bd2523a39abb8e6f6385297b6fd"}], "stats": {"total": 1060, "additions": 520, "deletions": 540}, "files": [{"sha": "7d3fbdf57d7510d5b6537105fe875b78ecd6e0ba", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 22, "deletions": 25, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/685094bfdee3a606aa8ebf491f4968d9cd4879db/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/685094bfdee3a606aa8ebf491f4968d9cd4879db/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=685094bfdee3a606aa8ebf491f4968d9cd4879db", "patch": "@@ -126,7 +126,6 @@ package body Einfo is\n    --    Scale_Value                     Uint15\n    --    Storage_Size_Variable           Node15\n    --    String_Literal_Low_Bound        Node15\n-   --    Shared_Var_Read_Proc            Node15\n \n    --    Access_Disp_Table               Elist16\n    --    Cloned_Subtype                  Node16\n@@ -193,7 +192,7 @@ package body Einfo is\n    --    Private_View                    Node22\n    --    Protected_Formal                Node22\n    --    Scope_Depth_Value               Uint22\n-   --    Shared_Var_Assign_Proc          Node22\n+   --    Shared_Var_Procs_Instance       Node22\n \n    --    Associated_Final_Chain          Node23\n    --    CR_Discriminant                 Node23\n@@ -505,8 +504,8 @@ package body Einfo is\n    --    Optimize_Alignment_Space        Flag241\n    --    Optimize_Alignment_Time         Flag242\n    --    Overlays_Constant               Flag243\n+   --    Is_RACW_Stub_Type               Flag244\n \n-   --    (unused)                        Flag244\n    --    (unused)                        Flag245\n    --    (unused)                        Flag246\n    --    (unused)                        Flag247\n@@ -1975,6 +1974,12 @@ package body Einfo is\n       return Flag189 (Id);\n    end Is_Pure_Unit_Access_Type;\n \n+   function Is_RACW_Stub_Type (Id : E) return B is\n+   begin\n+      pragma Assert (Is_Type (Id));\n+      return Flag244 (Id);\n+   end Is_RACW_Stub_Type;\n+\n    function Is_Raised (Id : E) return B is\n    begin\n       pragma Assert (Ekind (Id) = E_Exception);\n@@ -2239,7 +2244,7 @@ package body Einfo is\n \n    function Non_Binary_Modulus (Id : E) return B is\n    begin\n-      pragma Assert (Is_Modular_Integer_Type (Id));\n+      pragma Assert (Is_Type (Id));\n       return Flag58 (Base_Type (Id));\n    end Non_Binary_Modulus;\n \n@@ -2537,17 +2542,11 @@ package body Einfo is\n       return List14 (Id);\n    end Shadow_Entities;\n \n-   function Shared_Var_Assign_Proc (Id : E) return E is\n+   function Shared_Var_Procs_Instance (Id : E) return E is\n    begin\n       pragma Assert (Ekind (Id) = E_Variable);\n       return Node22 (Id);\n-   end Shared_Var_Assign_Proc;\n-\n-   function Shared_Var_Read_Proc (Id : E) return E is\n-   begin\n-      pragma Assert (Ekind (Id) = E_Variable);\n-      return Node15 (Id);\n-   end Shared_Var_Read_Proc;\n+   end Shared_Var_Procs_Instance;\n \n    function Size_Check_Code (Id : E) return N is\n    begin\n@@ -4424,6 +4423,12 @@ package body Einfo is\n       Set_Flag189 (Id, V);\n    end Set_Is_Pure_Unit_Access_Type;\n \n+   procedure Set_Is_RACW_Stub_Type (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Is_Type (Id));\n+      Set_Flag244 (Id, V);\n+   end Set_Is_RACW_Stub_Type;\n+\n    procedure Set_Is_Raised (Id : E; V : B := True) is\n    begin\n       pragma Assert (Ekind (Id) = E_Exception);\n@@ -4697,7 +4702,7 @@ package body Einfo is\n \n    procedure Set_Non_Binary_Modulus (Id : E; V : B := True) is\n    begin\n-      pragma Assert (Ekind (Id) = E_Modular_Integer_Type);\n+      pragma Assert (Is_Type (Id) and then Id = Base_Type (Id));\n       Set_Flag58 (Id, V);\n    end Set_Non_Binary_Modulus;\n \n@@ -5000,17 +5005,11 @@ package body Einfo is\n       Set_List14 (Id, V);\n    end Set_Shadow_Entities;\n \n-   procedure Set_Shared_Var_Assign_Proc (Id : E; V : E) is\n+   procedure Set_Shared_Var_Procs_Instance (Id : E; V : E) is\n    begin\n       pragma Assert (Ekind (Id) = E_Variable);\n       Set_Node22 (Id, V);\n-   end Set_Shared_Var_Assign_Proc;\n-\n-   procedure Set_Shared_Var_Read_Proc (Id : E; V : E) is\n-   begin\n-      pragma Assert (Ekind (Id) = E_Variable);\n-      Set_Node15 (Id, V);\n-   end Set_Shared_Var_Read_Proc;\n+   end Set_Shared_Var_Procs_Instance;\n \n    procedure Set_Size_Check_Code (Id : E; V : N) is\n    begin\n@@ -7621,6 +7620,7 @@ package body Einfo is\n       W (\"Is_Public\",                       Flag10  (Id));\n       W (\"Is_Pure\",                         Flag44  (Id));\n       W (\"Is_Pure_Unit_Access_Type\",        Flag189 (Id));\n+      W (\"Is_RACW_Stub_Type\",               Flag244 (Id));\n       W (\"Is_Raised\",                       Flag224 (Id));\n       W (\"Is_Remote_Call_Interface\",        Flag62  (Id));\n       W (\"Is_Remote_Types\",                 Flag61  (Id));\n@@ -8131,9 +8131,6 @@ package body Einfo is\n          when E_String_Literal_Subtype                     =>\n             Write_Str (\"String_Literal_Low_Bound\");\n \n-         when E_Variable                                   =>\n-            Write_Str (\"Shared_Var_Read_Proc\");\n-\n          when others                                       =>\n             Write_Str (\"Field15??\");\n       end case;\n@@ -8506,7 +8503,7 @@ package body Einfo is\n             Write_Str (\"Private_View\");\n \n          when E_Variable                                   =>\n-            Write_Str (\"Shared_Var_Assign_Proc\");\n+            Write_Str (\"Shared_Var_Procs_Instance\");\n \n          when others                                       =>\n             Write_Str (\"Field22??\");"}, {"sha": "e1623042b521f8e4f5fd7c54e1c8f358439122e4", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/685094bfdee3a606aa8ebf491f4968d9cd4879db/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/685094bfdee3a606aa8ebf491f4968d9cd4879db/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=685094bfdee3a606aa8ebf491f4968d9cd4879db", "patch": "@@ -2581,6 +2581,10 @@ package Einfo is\n --       subtype appears in a pure unit. Used to give an error message at\n --       freeze time if the access type has a storage pool.\n \n+--    Is_RACW_Stub_Type (Flag244)\n+--       Present in all types, true for the stub types generated for remote\n+--       access-to-class-wide types.\n+\n --    Is_Raised (Flag224)\n --       Present in exception entities. Set if the entity is referenced by a\n --       a raise statement.\n@@ -2595,12 +2599,12 @@ package Einfo is\n --    Is_Remote_Call_Interface (Flag62)\n --       Present in all entities. Set in E_Package and E_Generic_Package\n --       entities to which a pragma Remote_Call_Interace is applied, and\n---       also in all entities within such packages.\n+--       also on entities declared in the visible part of such a package.\n \n --    Is_Remote_Types (Flag61)\n --       Present in all entities. Set in E_Package and E_Generic_Package\n---       entities to which a pragma Remote_Types is applied, and also in\n---       all entities within such packages.\n+--       entities to which a pragma Remote_Types is applied, and also on\n+--       entities declared in the visible part of the spec of such a package.\n \n --    Is_Renaming_Of_Object (Flag112)\n --       Present in all entities, set only for a variable or constant for\n@@ -3044,8 +3048,8 @@ package Einfo is\n --       of a record, returns the next _Tag field in this record.\n \n --    Non_Binary_Modulus (Flag58) [base type only]\n---       Present in modular integer types. Set if the modulus for the type\n---       is other than a power of 2.\n+--       Present in all subtype and type entities. Set for modular integer\n+--       types if the modulus value is other than a power of 2.\n \n --    Non_Limited_View (Node17)\n --       Present in incomplete types that are the shadow entities created\n@@ -3479,15 +3483,10 @@ package Einfo is\n --       standard format list (i.e. First (Shadow_Entities) is the first\n --       entry and subsequent entries are obtained using Next.\n \n---    Shared_Var_Assign_Proc (Node22)\n---       Present in variables. Set non-Empty only if Is_Shared_Passive is\n---       set, in which case this is the entity for the shared memory assign\n---       routine. See Exp_Smem for full details.\n-\n---    Shared_Var_Read_Proc (Node15)\n+--    Shared_Var_Procs_Instance (Node22)\n --       Present in variables. Set non-Empty only if Is_Shared_Passive is\n---       set, in which case this is the entity for the shared memory read\n---       routine. See Exp_Smem for full details.\n+--       set, in which case this is the entity for the associated instance of\n+--       System.Shared_Storage.Shared_Var_Procs. See Exp_Smem for full details.\n \n --    Size_Check_Code (Node19)\n --       Present in constants and variables. Normally Empty. Set if code is\n@@ -4698,6 +4697,7 @@ package Einfo is\n    --    Is_Generic_Actual_Type              (Flag94)\n    --    Is_Generic_Type                     (Flag13)\n    --    Is_Protected_Interface              (Flag198)\n+   --    Is_RACW_Stub_Type                   (Flag244)\n    --    Is_Synchronized_Interface           (Flag199)\n    --    Is_Task_Interface                   (Flag200)\n    --    Is_Non_Static_Subtype               (Flag109)\n@@ -5490,14 +5490,13 @@ package Einfo is\n    --    Esize                               (Uint12)\n    --    Extra_Accessibility                 (Node13)\n    --    Alignment                           (Uint14)\n-   --    Shared_Var_Read_Proc                (Node15)\n    --    Unset_Reference                     (Node16)\n    --    Actual_Subtype                      (Node17)\n    --    Renamed_Object                      (Node18)\n    --    Size_Check_Code                     (Node19)\n    --    Prival_Link                         (Node20)\n    --    Interface_Name                      (Node21)\n-   --    Shared_Var_Assign_Proc              (Node22)\n+   --    Shared_Var_Procs_Instance           (Node22)\n    --    Extra_Constrained                   (Node23)\n    --    Debug_Renaming_Link                 (Node25)\n    --    Last_Assignment                     (Node26)\n@@ -5990,6 +5989,7 @@ package Einfo is\n    function Is_Public                           (Id : E) return B;\n    function Is_Pure                             (Id : E) return B;\n    function Is_Pure_Unit_Access_Type            (Id : E) return B;\n+   function Is_RACW_Stub_Type                   (Id : E) return B;\n    function Is_Raised                           (Id : E) return B;\n    function Is_Remote_Call_Interface            (Id : E) return B;\n    function Is_Remote_Types                     (Id : E) return B;\n@@ -6085,8 +6085,7 @@ package Einfo is\n    function Scope_Depth_Value                   (Id : E) return U;\n    function Sec_Stack_Needed_For_Return         (Id : E) return B;\n    function Shadow_Entities                     (Id : E) return S;\n-   function Shared_Var_Assign_Proc              (Id : E) return E;\n-   function Shared_Var_Read_Proc                (Id : E) return E;\n+   function Shared_Var_Procs_Instance           (Id : E) return E;\n    function Size_Check_Code                     (Id : E) return N;\n    function Size_Known_At_Compile_Time          (Id : E) return B;\n    function Size_Depends_On_Discriminant        (Id : E) return B;\n@@ -6555,6 +6554,7 @@ package Einfo is\n    procedure Set_Is_Public                       (Id : E; V : B := True);\n    procedure Set_Is_Pure                         (Id : E; V : B := True);\n    procedure Set_Is_Pure_Unit_Access_Type        (Id : E; V : B := True);\n+   procedure Set_Is_RACW_Stub_Type               (Id : E; V : B := True);\n    procedure Set_Is_Raised                       (Id : E; V : B := True);\n    procedure Set_Is_Remote_Call_Interface        (Id : E; V : B := True);\n    procedure Set_Is_Remote_Types                 (Id : E; V : B := True);\n@@ -6650,8 +6650,7 @@ package Einfo is\n    procedure Set_Scope_Depth_Value               (Id : E; V : U);\n    procedure Set_Sec_Stack_Needed_For_Return     (Id : E; V : B := True);\n    procedure Set_Shadow_Entities                 (Id : E; V : S);\n-   procedure Set_Shared_Var_Assign_Proc          (Id : E; V : E);\n-   procedure Set_Shared_Var_Read_Proc            (Id : E; V : E);\n+   procedure Set_Shared_Var_Procs_Instance       (Id : E; V : E);\n    procedure Set_Size_Check_Code                 (Id : E; V : N);\n    procedure Set_Size_Depends_On_Discriminant    (Id : E; V : B := True);\n    procedure Set_Size_Known_At_Compile_Time      (Id : E; V : B := True);\n@@ -7236,6 +7235,7 @@ package Einfo is\n    pragma Inline (Is_Public);\n    pragma Inline (Is_Pure);\n    pragma Inline (Is_Pure_Unit_Access_Type);\n+   pragma Inline (Is_RACW_Stub_Type);\n    pragma Inline (Is_Raised);\n    pragma Inline (Is_Real_Type);\n    pragma Inline (Is_Record_Type);\n@@ -7340,8 +7340,7 @@ package Einfo is\n    pragma Inline (Scope_Depth_Value);\n    pragma Inline (Sec_Stack_Needed_For_Return);\n    pragma Inline (Shadow_Entities);\n-   pragma Inline (Shared_Var_Assign_Proc);\n-   pragma Inline (Shared_Var_Read_Proc);\n+   pragma Inline (Shared_Var_Procs_Instance);\n    pragma Inline (Size_Check_Code);\n    pragma Inline (Size_Depends_On_Discriminant);\n    pragma Inline (Size_Known_At_Compile_Time);\n@@ -7628,6 +7627,7 @@ package Einfo is\n    pragma Inline (Set_Is_Public);\n    pragma Inline (Set_Is_Pure);\n    pragma Inline (Set_Is_Pure_Unit_Access_Type);\n+   pragma Inline (Set_Is_RACW_Stub_Type);\n    pragma Inline (Set_Is_Raised);\n    pragma Inline (Set_Is_Remote_Call_Interface);\n    pragma Inline (Set_Is_Remote_Types);\n@@ -7722,8 +7722,7 @@ package Einfo is\n    pragma Inline (Set_Scope_Depth_Value);\n    pragma Inline (Set_Sec_Stack_Needed_For_Return);\n    pragma Inline (Set_Shadow_Entities);\n-   pragma Inline (Set_Shared_Var_Assign_Proc);\n-   pragma Inline (Set_Shared_Var_Read_Proc);\n+   pragma Inline (Set_Shared_Var_Procs_Instance);\n    pragma Inline (Set_Size_Check_Code);\n    pragma Inline (Set_Size_Depends_On_Discriminant);\n    pragma Inline (Set_Size_Known_At_Compile_Time);"}, {"sha": "0246516fcbf5a9fc57fba546cbf14a30a918ce16", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 475, "deletions": 489, "changes": 964, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/685094bfdee3a606aa8ebf491f4968d9cd4879db/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/685094bfdee3a606aa8ebf491f4968d9cd4879db/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=685094bfdee3a606aa8ebf491f4968d9cd4879db", "patch": "@@ -110,40 +110,39 @@ package body Exp_Ch4 is\n       Bodies : List_Id;\n       Typ    : Entity_Id) return Node_Id;\n    --  Expand an array equality into a call to a function implementing this\n-   --  equality, and a call to it. Loc is the location for the generated\n-   --  nodes. Lhs and Rhs are the array expressions to be compared.\n-   --  Bodies is a list on which to attach bodies of local functions that\n-   --  are created in the process. It is the responsibility of the\n-   --  caller to insert those bodies at the right place. Nod provides\n-   --  the Sloc value for the generated code. Normally the types used\n-   --  for the generated equality routine are taken from Lhs and Rhs.\n-   --  However, in some situations of generated code, the Etype fields\n-   --  of Lhs and Rhs are not set yet. In such cases, Typ supplies the\n-   --  type to be used for the formal parameters.\n+   --  equality, and a call to it. Loc is the location for the generated nodes.\n+   --  Lhs and Rhs are the array expressions to be compared. Bodies is a list\n+   --  on which to attach bodies of local functions that are created in the\n+   --  process. It is the responsibility of the caller to insert those bodies\n+   --  at the right place. Nod provides the Sloc value for the generated code.\n+   --  Normally the types used for the generated equality routine are taken\n+   --  from Lhs and Rhs. However, in some situations of generated code, the\n+   --  Etype fields of Lhs and Rhs are not set yet. In such cases, Typ supplies\n+   --  the type to be used for the formal parameters.\n \n    procedure Expand_Boolean_Operator (N : Node_Id);\n-   --  Common expansion processing for Boolean operators (And, Or, Xor)\n-   --  for the case of array type arguments.\n+   --  Common expansion processing for Boolean operators (And, Or, Xor) for the\n+   --  case of array type arguments.\n \n    function Expand_Composite_Equality\n      (Nod    : Node_Id;\n       Typ    : Entity_Id;\n       Lhs    : Node_Id;\n       Rhs    : Node_Id;\n       Bodies : List_Id) return Node_Id;\n-   --  Local recursive function used to expand equality for nested\n-   --  composite types. Used by Expand_Record/Array_Equality, Bodies\n-   --  is a list on which to attach bodies of local functions that are\n-   --  created in the process. This is the responsibility of the caller\n-   --  to insert those bodies at the right place. Nod provides the Sloc\n-   --  value for generated code. Lhs and Rhs are the left and right sides\n-   --  for the comparison, and Typ is the type of the arrays to compare.\n+   --  Local recursive function used to expand equality for nested composite\n+   --  types. Used by Expand_Record/Array_Equality, Bodies is a list on which\n+   --  to attach bodies of local functions that are created in the process.\n+   --  This is the responsibility of the caller to insert those bodies at the\n+   --  right place. Nod provides the Sloc value for generated code. Lhs and Rhs\n+   --  are the left and right sides for the comparison, and Typ is the type of\n+   --  the arrays to compare.\n \n    procedure Expand_Concatenate_Other (Cnode : Node_Id; Opnds : List_Id);\n-   --  This routine handles expansion of concatenation operations, where\n-   --  N is the N_Op_Concat node being expanded and Operands is the list\n-   --  of operands (at least two are present). The caller has dealt with\n-   --  converting any singleton operands into singleton aggregates.\n+   --  This routine handles expansion of concatenation operations, where N is\n+   --  the N_Op_Concat node being expanded and Operands is the list of operands\n+   --  (at least two are present). The caller has dealt with converting any\n+   --  singleton operands into singleton aggregates.\n \n    procedure Expand_Concatenate_String (Cnode : Node_Id; Opnds : List_Id);\n    --  Routine to expand concatenation of 2-5 operands (in the list Operands)\n@@ -153,18 +152,18 @@ package body Exp_Ch4 is\n    --  already converted character operands to strings in this case).\n \n    procedure Fixup_Universal_Fixed_Operation (N : Node_Id);\n-   --  N is either an N_Op_Divide or N_Op_Multiply node whose result is\n-   --  universal fixed. We do not have such a type at runtime, so the\n-   --  purpose of this routine is to find the real type by looking up\n-   --  the tree. We also determine if the operation must be rounded.\n+   --  N is a N_Op_Divide or N_Op_Multiply node whose result is universal\n+   --  fixed. We do not have such a type at runtime, so the purpose of this\n+   --  routine is to find the real type by looking up the tree. We also\n+   --  determine if the operation must be rounded.\n \n    function Get_Allocator_Final_List\n      (N    : Node_Id;\n       T    : Entity_Id;\n       PtrT : Entity_Id) return Entity_Id;\n-   --  If the designated type is controlled, build final_list expression\n-   --  for created object. If context is an access parameter, create a\n-   --  local access type to have a usable finalization list.\n+   --  If the designated type is controlled, build final_list expression for\n+   --  created object. If context is an access parameter, create a local access\n+   --  type to have a usable finalization list.\n \n    function Has_Inferable_Discriminants (N : Node_Id) return Boolean;\n    --  Ada 2005 (AI-216): A view of an Unchecked_Union object has inferable\n@@ -185,22 +184,22 @@ package body Exp_Ch4 is\n    function Make_Array_Comparison_Op\n      (Typ : Entity_Id;\n       Nod : Node_Id) return Node_Id;\n-   --  Comparisons between arrays are expanded in line. This function\n-   --  produces the body of the implementation of (a > b), where a and b\n-   --  are one-dimensional arrays of some discrete type. The original\n-   --  node is then expanded into the appropriate call to this function.\n-   --  Nod provides the Sloc value for the generated code.\n+   --  Comparisons between arrays are expanded in line. This function produces\n+   --  the body of the implementation of (a > b), where a and b are one-\n+   --  dimensional arrays of some discrete type. The original node is then\n+   --  expanded into the appropriate call to this function. Nod provides the\n+   --  Sloc value for the generated code.\n \n    function Make_Boolean_Array_Op\n      (Typ : Entity_Id;\n       N   : Node_Id) return Node_Id;\n-   --  Boolean operations on boolean arrays are expanded in line. This\n-   --  function produce the body for the node N, which is (a and b),\n-   --  (a or b), or (a xor b). It is used only the normal case and not\n-   --  the packed case. The type involved, Typ, is the Boolean array type,\n-   --  and the logical operations in the body are simple boolean operations.\n-   --  Note that Typ is always a constrained type (the caller has ensured\n-   --  this by using Convert_To_Actual_Subtype if necessary).\n+   --  Boolean operations on boolean arrays are expanded in line. This function\n+   --  produce the body for the node N, which is (a and b), (a or b), or (a xor\n+   --  b). It is used only the normal case and not the packed case. The type\n+   --  involved, Typ, is the Boolean array type, and the logical operations in\n+   --  the body are simple boolean operations. Note that Typ is always a\n+   --  constrained type (the caller has ensured this by using\n+   --  Convert_To_Actual_Subtype if necessary).\n \n    procedure Rewrite_Comparison (N : Node_Id);\n    --  If N is the node for a comparison whose outcome can be determined at\n@@ -218,9 +217,8 @@ package body Exp_Ch4 is\n      (Lhs : Node_Id;\n       Op1 : Node_Id;\n       Op2 : Node_Id) return Boolean;\n-   --  In the context of an assignment, where the right-hand side is a\n-   --  boolean operation on arrays, check whether operation can be performed\n-   --  in place.\n+   --  In the context of an assignment, where the right-hand side is a boolean\n+   --  operation on arrays, check whether operation can be performed in place.\n \n    procedure Unary_Op_Validity_Checks (N : Node_Id);\n    pragma Inline (Unary_Op_Validity_Checks);\n@@ -478,28 +476,30 @@ package body Exp_Ch4 is\n         (Ref            : Node_Id;\n          Built_In_Place : Boolean := False);\n       --  Ada 2005 (AI-344): For an allocator with a class-wide designated\n-      --  type, generate an accessibility check to verify that the level of\n-      --  the type of the created object is not deeper than the level of the\n-      --  access type. If the type of the qualified expression is class-\n-      --  wide, then always generate the check (except in the case where it\n-      --  is known to be unnecessary, see comment below). Otherwise, only\n-      --  generate the check if the level of the qualified expression type\n-      --  is statically deeper than the access type. Although the static\n-      --  accessibility will generally have been performed as a legality\n-      --  check, it won't have been done in cases where the allocator\n-      --  appears in generic body, so a run-time check is needed in general.\n-      --  One special case is when the access type is declared in the same\n-      --  scope as the class-wide allocator, in which case the check can\n-      --  never fail, so it need not be generated. As an open issue, there\n-      --  seem to be cases where the static level associated with the\n-      --  class-wide object's underlying type is not sufficient to perform\n-      --  the proper accessibility check, such as for allocators in nested\n-      --  subprograms or accept statements initialized by class-wide formals\n-      --  when the actual originates outside at a deeper static level. The\n-      --  nested subprogram case might require passing accessibility levels\n-      --  along with class-wide parameters, and the task case seems to be\n-      --  an actual gap in the language rules that needs to be fixed by the\n-      --  ARG. ???\n+      --  type, generate an accessibility check to verify that the level of the\n+      --  type of the created object is not deeper than the level of the access\n+      --  type. If the type of the qualified expression is class- wide, then\n+      --  always generate the check (except in the case where it is known to be\n+      --  unnecessary, see comment below). Otherwise, only generate the check\n+      --  if the level of the qualified expression type is statically deeper\n+      --  than the access type.\n+      --\n+      --  Although the static accessibility will generally have been performed\n+      --  as a legality check, it won't have been done in cases where the\n+      --  allocator appears in generic body, so a run-time check is needed in\n+      --  general. One special case is when the access type is declared in the\n+      --  same scope as the class-wide allocator, in which case the check can\n+      --  never fail, so it need not be generated.\n+      --\n+      --  As an open issue, there seem to be cases where the static level\n+      --  associated with the class-wide object's underlying type is not\n+      --  sufficient to perform the proper accessibility check, such as for\n+      --  allocators in nested subprograms or accept statements initialized by\n+      --  class-wide formals when the actual originates outside at a deeper\n+      --  static level. The nested subprogram case might require passing\n+      --  accessibility levels along with class-wide parameters, and the task\n+      --  case seems to be an actual gap in the language rules that needs to\n+      --  be fixed by the ARG. ???\n \n       -------------------------------\n       -- Apply_Accessibility_Check --\n@@ -577,12 +577,12 @@ package body Exp_Ch4 is\n    begin\n       if Is_Tagged_Type (T) or else Controlled_Type (T) then\n \n-         --  Ada 2005 (AI-318-02): If the initialization expression is a\n-         --  call to a build-in-place function, then access to the allocated\n-         --  object must be passed to the function. Currently we limit such\n-         --  functions to those with constrained limited result subtypes,\n-         --  but eventually we plan to expand the allowed forms of functions\n-         --  that are treated as build-in-place.\n+         --  Ada 2005 (AI-318-02): If the initialization expression is a call\n+         --  to a build-in-place function, then access to the allocated object\n+         --  must be passed to the function. Currently we limit such functions\n+         --  to those with constrained limited result subtypes, but eventually\n+         --  we plan to expand the allowed forms of functions that are treated\n+         --  as build-in-place.\n \n          if Ada_Version >= Ada_05\n            and then Is_Build_In_Place_Function_Call (Exp)\n@@ -762,11 +762,10 @@ package body Exp_Ch4 is\n \n                --  Generate an additional object containing the address of the\n                --  returned object. The type of this second object declaration\n-               --  is the correct type required for the common processing\n-               --  that is still performed by this subprogram. The displacement\n-               --  of this pointer to reference the component associated with\n-               --  the interface type will be done at the end of the common\n-               --  processing.\n+               --  is the correct type required for the common processing that\n+               --  is still performed by this subprogram. The displacement of\n+               --  this pointer to reference the component associated with the\n+               --  interface type will be done at the end of common processing.\n \n                New_Decl :=\n                  Make_Object_Declaration (Loc,\n@@ -845,10 +844,10 @@ package body Exp_Ch4 is\n                           Associated_Storage_Pool (PtrT);\n \n             begin\n-               --  If it is an allocation on the secondary stack\n-               --  (i.e. a value returned from a function), the object\n-               --  is attached on the caller side as soon as the call\n-               --  is completed (see Expand_Ctrl_Function_Call)\n+               --  If it is an allocation on the secondary stack (i.e. a value\n+               --  returned from a function), the object is attached on the\n+               --  caller side as soon as the call is completed (see\n+               --  Expand_Ctrl_Function_Call)\n \n                if Is_RTE (Apool, RE_SS_Pool) then\n                   declare\n@@ -899,10 +898,9 @@ package body Exp_Ch4 is\n                     Make_Adjust_Call (\n                       Ref          =>\n \n-                     --  An unchecked conversion is needed in the\n-                     --  classwide case because the designated type\n-                     --  can be an ancestor of the subtype mark of\n-                     --  the allocator.\n+                     --  An unchecked conversion is needed in the classwide\n+                     --  case because the designated type can be an ancestor of\n+                     --  the subtype mark of the allocator.\n \n                       Unchecked_Convert_To (T,\n                         Make_Explicit_Dereference (Loc,\n@@ -919,9 +917,9 @@ package body Exp_Ch4 is\n          Rewrite (N, New_Reference_To (Temp, Loc));\n          Analyze_And_Resolve (N, PtrT);\n \n-         --  Ada 2005 (AI-251): Displace the pointer to reference the\n-         --  record component containing the secondary dispatch table\n-         --  of the interface type.\n+         --  Ada 2005 (AI-251): Displace the pointer to reference the record\n+         --  component containing the secondary dispatch table of the interface\n+         --  type.\n \n          if Is_Interface (Directly_Designated_Type (PtrT)) then\n             Displace_Allocator_Pointer (N);\n@@ -965,20 +963,18 @@ package body Exp_Ch4 is\n       else\n          --  First check against the type of the qualified expression\n          --\n-         --  NOTE: The commented call should be correct, but for\n-         --  some reason causes the compiler to bomb (sigsegv) on\n-         --  ACVC test c34007g, so for now we just perform the old\n-         --  (incorrect) test against the designated subtype with\n-         --  no sliding in the else part of the if statement below.\n-         --  ???\n+         --  NOTE: The commented call should be correct, but for some reason\n+         --  causes the compiler to bomb (sigsegv) on ACVC test c34007g, so for\n+         --  now we just perform the old (incorrect) test against the\n+         --  designated subtype with no sliding in the else part of the if\n+         --  statement below. ???\n          --\n          --  Apply_Constraint_Check (Exp, T, No_Sliding => True);\n \n-         --  A check is also needed in cases where the designated\n-         --  subtype is constrained and differs from the subtype\n-         --  given in the qualified expression. Note that the check\n-         --  on the qualified expression does not allow sliding,\n-         --  but this check does (a relaxation from Ada 83).\n+         --  A check is also needed in cases where the designated subtype is\n+         --  constrained and differs from the subtype given in the qualified\n+         --  expression. Note that the check on the qualified expression does\n+         --  not allow sliding, but this check does (a relaxation from Ada 83).\n \n          if Is_Constrained (DesigT)\n            and then not Subtypes_Statically_Match\n@@ -987,19 +983,18 @@ package body Exp_Ch4 is\n             Apply_Constraint_Check\n               (Exp, DesigT, No_Sliding => False);\n \n-         --  The nonsliding check should really be performed\n-         --  (unconditionally) against the subtype of the\n-         --  qualified expression, but that causes a problem\n-         --  with c34007g (see above), so for now we retain this.\n+         --  The nonsliding check should really be performed (unconditionally)\n+         --  against the subtype of the qualified expression, but that causes a\n+         --  problem with c34007g (see above), so for now we retain this.\n \n          else\n             Apply_Constraint_Check\n               (Exp, DesigT, No_Sliding => True);\n          end if;\n \n-         --  For an access to unconstrained packed array, GIGI needs\n-         --  to see an expression with a constrained subtype in order\n-         --  to compute the proper size for the allocator.\n+         --  For an access to unconstrained packed array, GIGI needs to see an\n+         --  expression with a constrained subtype in order to compute the\n+         --  proper size for the allocator.\n \n          if Is_Array_Type (T)\n            and then not Is_Constrained (T)\n@@ -1021,12 +1016,12 @@ package body Exp_Ch4 is\n             end;\n          end if;\n \n-         --  Ada 2005 (AI-318-02): If the initialization expression is a\n-         --  call to a build-in-place function, then access to the allocated\n-         --  object must be passed to the function. Currently we limit such\n-         --  functions to those with constrained limited result subtypes,\n-         --  but eventually we plan to expand the allowed forms of functions\n-         --  that are treated as build-in-place.\n+         --  Ada 2005 (AI-318-02): If the initialization expression is a call\n+         --  to a build-in-place function, then access to the allocated object\n+         --  must be passed to the function. Currently we limit such functions\n+         --  to those with constrained limited result subtypes, but eventually\n+         --  we plan to expand the allowed forms of functions that are treated\n+         --  as build-in-place.\n \n          if Ada_Version >= Ada_05\n            and then Is_Build_In_Place_Function_Call (Exp)\n@@ -1044,10 +1039,10 @@ package body Exp_Ch4 is\n    -- Expand_Array_Comparison --\n    -----------------------------\n \n-   --  Expansion is only required in the case of array types. For the\n-   --  unpacked case, an appropriate runtime routine is called. For\n-   --  packed cases, and also in some other cases where a runtime\n-   --  routine cannot be called, the form of the expansion is:\n+   --  Expansion is only required in the case of array types. For the unpacked\n+   --  case, an appropriate runtime routine is called. For packed cases, and\n+   --  also in some other cases where a runtime routine cannot be called, the\n+   --  form of the expansion is:\n \n    --     [body for greater_nn; boolean_expression]\n \n@@ -1071,9 +1066,9 @@ package body Exp_Ch4 is\n       --  True for byte addressable target\n \n       function Length_Less_Than_4 (Opnd : Node_Id) return Boolean;\n-      --  Returns True if the length of the given operand is known to be\n-      --  less than 4. Returns False if this length is known to be four\n-      --  or greater or is not known at compile time.\n+      --  Returns True if the length of the given operand is known to be less\n+      --  than 4. Returns False if this length is known to be four or greater\n+      --  or is not known at compile time.\n \n       ------------------------\n       -- Length_Less_Than_4 --\n@@ -1272,8 +1267,8 @@ package body Exp_Ch4 is\n    -- Expand_Array_Equality --\n    ---------------------------\n \n-   --  Expand an equality function for multi-dimensional arrays. Here is\n-   --  an example of such a function for Nb_Dimension = 2\n+   --  Expand an equality function for multi-dimensional arrays. Here is an\n+   --  example of such a function for Nb_Dimension = 2\n \n    --  function Enn (A : atyp; B : btyp) return boolean is\n    --  begin\n@@ -1320,15 +1315,15 @@ package body Exp_Ch4 is\n    --     return true;\n    --  end Enn;\n \n-   --  Note on the formal types used (atyp and btyp). If either of the\n-   --  arrays is of a private type, we use the underlying type, and\n-   --  do an unchecked conversion of the actual. If either of the arrays\n-   --  has a bound depending on a discriminant, then we use the base type\n-   --  since otherwise we have an escaped discriminant in the function.\n+   --  Note on the formal types used (atyp and btyp). If either of the arrays\n+   --  is of a private type, we use the underlying type, and do an unchecked\n+   --  conversion of the actual. If either of the arrays has a bound depending\n+   --  on a discriminant, then we use the base type since otherwise we have an\n+   --  escaped discriminant in the function.\n \n-   --  If both arrays are constrained and have the same bounds, we can\n-   --  generate a loop with an explicit iteration scheme using a 'Range\n-   --  attribute over the first array.\n+   --  If both arrays are constrained and have the same bounds, we can generate\n+   --  a loop with an explicit iteration scheme using a 'Range attribute over\n+   --  the first array.\n \n    function Expand_Array_Equality\n      (Nod    : Node_Id;\n@@ -1361,12 +1356,12 @@ package body Exp_Ch4 is\n       --  This builds the attribute reference Arr'Nam (Expr)\n \n       function Component_Equality (Typ : Entity_Id) return Node_Id;\n-      --  Create one statement to compare corresponding components,\n-      --  designated by a full set of indices.\n+      --  Create one statement to compare corresponding components, designated\n+      --  by a full set of indices.\n \n       function Get_Arg_Type (N : Node_Id) return Entity_Id;\n-      --  Given one of the arguments, computes the appropriate type to\n-      --  be used for that argument in the corresponding function formal\n+      --  Given one of the arguments, computes the appropriate type to be used\n+      --  for that argument in the corresponding function formal\n \n       function Handle_One_Dimension\n         (N     : Int;\n@@ -1392,13 +1387,13 @@ package body Exp_Ch4 is\n       --      end loop\n       --\n       --  N is the dimension for which we are generating a loop. Index is the\n-      --  N'th index node, whose Etype is Index_Type_n in the above code.\n-      --  The xxx statement is either the loop or declare for the next\n-      --  dimension or if this is the last dimension the comparison\n-      --  of corresponding components of the arrays.\n+      --  N'th index node, whose Etype is Index_Type_n in the above code. The\n+      --  xxx statement is either the loop or declare for the next dimension\n+      --  or if this is the last dimension the comparison of corresponding\n+      --  components of the arrays.\n       --\n-      --  The actual way the code works is to return the comparison\n-      --  of corresponding components for the N+1 call. That's neater!\n+      --  The actual way the code works is to return the comparison of\n+      --  corresponding components for the N+1 call. That's neater!\n \n       function Test_Empty_Arrays return Node_Id;\n       --  This function constructs the test for both arrays being empty\n@@ -1407,8 +1402,8 @@ package body Exp_Ch4 is\n       --    (B'length (1) = 0 or else B'length (2) = 0 or else ...)\n \n       function Test_Lengths_Correspond return Node_Id;\n-      --  This function constructs the test for arrays having different\n-      --  lengths in at least one index position, in which case resull\n+      --  This function constructs the test for arrays having different lengths\n+      --  in at least one index position, in which case the resulting code is:\n \n       --     A'length (1) /= B'length (1)\n       --       or else\n@@ -1463,8 +1458,8 @@ package body Exp_Ch4 is\n          if Nkind (Test) = N_Raise_Program_Error then\n \n             --  This node is going to be inserted at a location where a\n-            --  statement is expected: clear its Etype so analysis will\n-            --  set it to the expected Standard_Void_Type.\n+            --  statement is expected: clear its Etype so analysis will set\n+            --  it to the expected Standard_Void_Type.\n \n             Set_Etype (Test, Empty);\n             return Test;\n@@ -1525,8 +1520,8 @@ package body Exp_Ch4 is\n                                    Ltyp /= Rtyp\n                                      or else not Is_Constrained (Ltyp);\n          --  If the index types are identical, and we are working with\n-         --  constrained types, then we can use the same index for both of\n-         --  the arrays.\n+         --  constrained types, then we can use the same index for both\n+         --  of the arrays.\n \n          An : constant Entity_Id := Make_Defining_Identifier (Loc,\n                                       Chars => New_Internal_Name ('A'));\n@@ -1714,9 +1709,9 @@ package body Exp_Ch4 is\n       Ltyp := Get_Arg_Type (Lhs);\n       Rtyp := Get_Arg_Type (Rhs);\n \n-      --  For now, if the argument types are not the same, go to the\n-      --  base type, since the code assumes that the formals have the\n-      --  same type. This is fixable in future ???\n+      --  For now, if the argument types are not the same, go to the base type,\n+      --  since the code assumes that the formals have the same type. This is\n+      --  fixable in future ???\n \n       if Ltyp /= Rtyp then\n          Ltyp := Base_Type (Ltyp);\n@@ -1775,9 +1770,9 @@ package body Exp_Ch4 is\n          Set_Has_Completion (Func_Name, True);\n          Set_Is_Inlined (Func_Name);\n \n-         --  If the array type is distinct from the type of the arguments,\n-         --  it is the full view of a private type. Apply an unchecked\n-         --  conversion to insure that analysis of the call succeeds.\n+         --  If the array type is distinct from the type of the arguments, it\n+         --  is the full view of a private type. Apply an unchecked conversion\n+         --  to insure that analysis of the call succeeds.\n \n          declare\n             L, R : Node_Id;\n@@ -1813,16 +1808,16 @@ package body Exp_Ch4 is\n    -- Expand_Boolean_Operator --\n    -----------------------------\n \n-   --  Note that we first get the actual subtypes of the operands,\n-   --  since we always want to deal with types that have bounds.\n+   --  Note that we first get the actual subtypes of the operands, since we\n+   --  always want to deal with types that have bounds.\n \n    procedure Expand_Boolean_Operator (N : Node_Id) is\n       Typ : constant Entity_Id  := Etype (N);\n \n    begin\n-      --  Special case of bit packed array where both operands are known\n-      --  to be properly aligned. In this case we use an efficient run time\n-      --  routine to carry out the operation (see System.Bit_Ops).\n+      --  Special case of bit packed array where both operands are known to be\n+      --  properly aligned. In this case we use an efficient run time routine\n+      --  to carry out the operation (see System.Bit_Ops).\n \n       if Is_Bit_Packed_Array (Typ)\n         and then not Is_Possibly_Unaligned_Object (Left_Opnd (N))\n@@ -1916,8 +1911,8 @@ package body Exp_Ch4 is\n          Full_Type := Typ;\n       end if;\n \n-      --  Defense against malformed private types with no completion\n-      --  the error will be diagnosed later by check_completion\n+      --  Defense against malformed private types with no completion the error\n+      --  will be diagnosed later by check_completion\n \n       if No (Full_Type) then\n          return New_Reference_To (Standard_False, Loc);\n@@ -1937,11 +1932,11 @@ package body Exp_Ch4 is\n          then\n             return Make_Op_Eq (Loc, Left_Opnd  => Lhs, Right_Opnd => Rhs);\n \n-         --  For composite component types, and floating-point types, use\n-         --  the expansion. This deals with tagged component types (where\n-         --  we use the applicable equality routine) and floating-point,\n-         --  (where we need to worry about negative zeroes), and also the\n-         --  case of any composite type recursively containing such fields.\n+         --  For composite component types, and floating-point types, use the\n+         --  expansion. This deals with tagged component types (where we use\n+         --  the applicable equality routine) and floating-point, (where we\n+         --  need to worry about negative zeroes), and also the case of any\n+         --  composite type recursively containing such fields.\n \n          else\n             return Expand_Array_Equality (Nod, Lhs, Rhs, Bodies, Full_Type);\n@@ -1955,11 +1950,10 @@ package body Exp_Ch4 is\n             Full_Type := Root_Type (Full_Type);\n          end if;\n \n-         --  If this is derived from an untagged private type completed\n-         --  with a tagged type, it does not have a full view, so we\n-         --  use the primitive operations of the private type.\n-         --  This check should no longer be necessary when these\n-         --  types receive their full views ???\n+         --  If this is derived from an untagged private type completed with a\n+         --  tagged type, it does not have a full view, so we use the primitive\n+         --  operations of the private type. This check should no longer be\n+         --  necessary when these types receive their full views ???\n \n          if Is_Private_Type (Typ)\n            and then not Is_Tagged_Type (Typ)\n@@ -1998,8 +1992,8 @@ package body Exp_Ch4 is\n          if Present (Eq_Op) then\n             if Etype (First_Formal (Eq_Op)) /= Full_Type then\n \n-               --  Inherited equality from parent type. Convert the actuals\n-               --  to match signature of operation.\n+               --  Inherited equality from parent type. Convert the actuals to\n+               --  match signature of operation.\n \n                declare\n                   T : constant Entity_Id := Etype (First_Formal (Eq_Op));\n@@ -2040,7 +2034,7 @@ package body Exp_Ch4 is\n \n                      if Is_Constrained (Lhs_Type) then\n \n-                        --  Since the enclosing record can never be an\n+                        --  Since the enclosing record type can never be an\n                         --  Unchecked_Union (this code is executed for records\n                         --  that do not have variants), we may reference its\n                         --  discriminant(s).\n@@ -2121,8 +2115,8 @@ package body Exp_Ch4 is\n                   end;\n                end if;\n \n-               --  Shouldn't this be an else, we can't fall through\n-               --  the above IF, right???\n+               --  Shouldn't this be an else, we can't fall through the above\n+               --  IF, right???\n \n                return\n                  Make_Function_Call (Loc,\n@@ -2145,10 +2139,10 @@ package body Exp_Ch4 is\n    -- Expand_Concatenate_Other --\n    ------------------------------\n \n-   --  Let n be the number of array operands to be concatenated, Base_Typ\n-   --  their base type, Ind_Typ their index type, and Arr_Typ the original\n-   --  array type to which the concatenation operator applies, then the\n-   --  following subprogram is constructed:\n+   --  Let n be the number of array operands to be concatenated, Base_Typ their\n+   --  base type, Ind_Typ their index type, and Arr_Typ the original array type\n+   --  to which the concatenation operator applies, then the following\n+   --  subprogram is constructed:\n \n    --  [function Cnn (S1 : Base_Typ; ...; Sn : Base_Typ) return Base_Typ is\n    --      L : Ind_Typ;\n@@ -2425,9 +2419,9 @@ package body Exp_Ch4 is\n          Target_Type : Entity_Id;\n \n       begin\n-         --  If the index type is an enumeration type, the computation\n-         --  can be done in standard integer. Otherwise, choose a large\n-         --  enough integer type.\n+         --  If the index type is an enumeration type, the computation can be\n+         --  done in standard integer. Otherwise, choose a large enough integer\n+         --  type to accomodate the index type computation.\n \n          if Is_Enumeration_Type (Ind_Typ)\n            or else Root_Type (Ind_Typ) = Standard_Integer\n@@ -2937,12 +2931,12 @@ package body Exp_Ch4 is\n             --    typ! (coext.all)\n \n             if Nkind (Coext) = N_Identifier then\n-               Ref := Make_Unchecked_Type_Conversion (Loc,\n-                        Subtype_Mark =>\n-                          New_Reference_To (Etype (Coext), Loc),\n-                        Expression =>\n-                          Make_Explicit_Dereference (Loc,\n-                            New_Copy_Tree (Coext)));\n+               Ref :=\n+                 Make_Unchecked_Type_Conversion (Loc,\n+                   Subtype_Mark => New_Reference_To (Etype (Coext), Loc),\n+                   Expression   =>\n+                     Make_Explicit_Dereference (Loc,\n+                       Prefix => New_Copy_Tree (Coext)));\n             else\n                Ref := New_Copy_Tree (Coext);\n             end if;\n@@ -3056,9 +3050,9 @@ package body Exp_Ch4 is\n          end if;\n       end if;\n \n-      --  Under certain circumstances we can replace an allocator by an\n-      --  access to statically allocated storage. The conditions, as noted\n-      --  in AARM 3.10 (10c) are as follows:\n+      --  Under certain circumstances we can replace an allocator by an access\n+      --  to statically allocated storage. The conditions, as noted in AARM\n+      --  3.10 (10c) are as follows:\n \n       --    Size and initial value is known at compile time\n       --    Access type is access-to-constant\n@@ -3083,8 +3077,8 @@ package body Exp_Ch4 is\n \n          --    Tnn : aliased x := y;\n \n-         --  and replace the allocator by Tnn'Unrestricted_Access.\n-         --  Tnn is marked as requiring static allocation.\n+         --  and replace the allocator by Tnn'Unrestricted_Access. Tnn is\n+         --  marked as requiring static allocation.\n \n          Temp :=\n            Make_Defining_Identifier (Loc, New_Internal_Name ('T'));\n@@ -3114,8 +3108,8 @@ package body Exp_Ch4 is\n \n          Analyze_And_Resolve (N, PtrT);\n \n-         --  We set the variable as statically allocated, since we don't\n-         --  want it going on the stack of the current procedure!\n+         --  We set the variable as statically allocated, since we don't want\n+         --  it going on the stack of the current procedure!\n \n          Set_Is_Statically_Allocated (Temp);\n          return;\n@@ -3147,9 +3141,8 @@ package body Exp_Ch4 is\n \n       --  If the allocator is for a type which requires initialization, and\n       --  there is no initial value (i.e. operand is a subtype indication\n-      --  rather than a qualified expression), then we must generate a call\n-      --  to the initialization routine. This is done using an expression\n-      --  actions node:\n+      --  rather than a qualified expression), then we must generate a call to\n+      --  the initialization routine using an expressions action node:\n \n       --     [Pnnn : constant ptr_T := new (T); Init (Pnnn.all,...); Pnnn]\n \n@@ -3364,10 +3357,10 @@ package body Exp_Ch4 is\n                   if Dis then\n \n                      --  If the allocated object will be constrained by the\n-                     --  default values for discriminants, then build a\n-                     --  subtype with those defaults, and change the allocated\n-                     --  subtype to that. Note that this happens in fewer\n-                     --  cases in Ada 2005 (AI-363).\n+                     --  default values for discriminants, then build a subtype\n+                     --  with those defaults, and change the allocated subtype\n+                     --  to that. Note that this happens in fewer cases in Ada\n+                     --  2005 (AI-363).\n \n                      if not Is_Constrained (Typ)\n                        and then Present (Discriminant_Default_Value\n@@ -3600,15 +3593,15 @@ package body Exp_Ch4 is\n \n       if Nkind (Right) = N_Identifier then\n \n-         --  Change (Left and then True) to Left. Note that we know there\n-         --  are no actions associated with the True operand, since we\n-         --  just checked for this case above.\n+         --  Change (Left and then True) to Left. Note that we know there are\n+         --  no actions associated with the True operand, since we just checked\n+         --  for this case above.\n \n          if Entity (Right) = Standard_True then\n             Rewrite (N, Left);\n \n-         --  Change (Left and then False) to False, making sure to preserve\n-         --  any side effects associated with the Left operand.\n+         --  Change (Left and then False) to False, making sure to preserve any\n+         --  side effects associated with the Left operand.\n \n          elsif Entity (Right) = Standard_False then\n             Remove_Side_Effects (Left);\n@@ -3851,8 +3844,8 @@ package body Exp_Ch4 is\n \n                return;\n \n-            --  If both checks are known to succeed, replace result\n-            --  by True, since we know we are in range.\n+            --  If both checks are known to succeed, replace result by True,\n+            --  since we know we are in range.\n \n             elsif Lcheck in Compare_GE and then Ucheck in Compare_LE then\n                if Warn1 then\n@@ -3989,9 +3982,9 @@ package body Exp_Ch4 is\n                  New_Reference_To (Standard_True, Loc));\n                Analyze_And_Resolve (N, Rtyp);\n \n-            --  For the constrained array case, we have to check the\n-            --  subscripts for an exact match if the lengths are\n-            --  non-zero (the lengths must match in any case).\n+            --  For the constrained array case, we have to check the subscripts\n+            --  for an exact match if the lengths are non-zero (the lengths\n+            --  must match in any case).\n \n             elsif Is_Array_Type (Typ) then\n \n@@ -4059,13 +4052,13 @@ package body Exp_Ch4 is\n                   Analyze_And_Resolve (N, Rtyp);\n                end Check_Subscripts;\n \n-            --  These are the cases where constraint checks may be\n-            --  required, e.g. records with possible discriminants\n+            --  These are the cases where constraint checks may be required,\n+            --  e.g. records with possible discriminants\n \n             else\n                --  Expand the test into a series of discriminant comparisons.\n-               --  The expression that is built is the negation of the one\n-               --  that is used for checking discriminant constraints.\n+               --  The expression that is built is the negation of the one that\n+               --  is used for checking discriminant constraints.\n \n                Obj := Relocate_Node (Left_Opnd (N));\n \n@@ -4104,18 +4097,18 @@ package body Exp_Ch4 is\n       T   : constant Entity_Id  := Etype (P);\n \n    begin\n-      --  A special optimization, if we have an indexed component that\n-      --  is selecting from a slice, then we can eliminate the slice,\n-      --  since, for example, x (i .. j)(k) is identical to x(k). The\n-      --  only difference is the range check required by the slice. The\n-      --  range check for the slice itself has already been generated.\n-      --  The range check for the subscripting operation is ensured\n-      --  by converting the subject to the subtype of the slice.\n-\n-      --  This optimization not only generates better code, avoiding\n-      --  slice messing especially in the packed case, but more importantly\n-      --  bypasses some problems in handling this peculiar case, for\n-      --  example, the issue of dealing specially with object renamings.\n+      --  A special optimization, if we have an indexed component that is\n+      --  selecting from a slice, then we can eliminate the slice, since, for\n+      --  example, x (i .. j)(k) is identical to x(k). The only difference is\n+      --  the range check required by the slice. The range check for the slice\n+      --  itself has already been generated. The range check for the\n+      --  subscripting operation is ensured by converting the subject to\n+      --  the subtype of the slice.\n+\n+      --  This optimization not only generates better code, avoiding slice\n+      --  messing especially in the packed case, but more importantly bypasses\n+      --  some problems in handling this peculiar case, for example, the issue\n+      --  of dealing specially with object renamings.\n \n       if Nkind (P) = N_Slice then\n          Rewrite (N,\n@@ -4138,11 +4131,11 @@ package body Exp_Ch4 is\n          Make_Build_In_Place_Call_In_Anonymous_Context (P);\n       end if;\n \n-      --  If the prefix is an access type, then we unconditionally rewrite\n-      --  if as an explicit deference. This simplifies processing for several\n-      --  cases, including packed array cases and certain cases in which\n-      --  checks must be generated. We used to try to do this only when it\n-      --  was necessary, but it cleans up the code to do it all the time.\n+      --  If the prefix is an access type, then we unconditionally rewrite if\n+      --  as an explicit deference. This simplifies processing for several\n+      --  cases, including packed array cases and certain cases in which checks\n+      --  must be generated. We used to try to do this only when it was\n+      --  necessary, but it cleans up the code to do it all the time.\n \n       if Is_Access_Type (T) then\n          Insert_Explicit_Dereference (P);\n@@ -4176,8 +4169,8 @@ package body Exp_Ch4 is\n       --  convert it to a reference to the corresponding Packed_Array_Type.\n       --  We only want to do this for simple references, and not for:\n \n-      --    Left side of assignment, or prefix of left side of assignment,\n-      --    or prefix of the prefix, to handle packed arrays of packed arrays,\n+      --    Left side of assignment, or prefix of left side of assignment, or\n+      --    prefix of the prefix, to handle packed arrays of packed arrays,\n       --      This case is handled in Exp_Ch5.Expand_N_Assignment_Statement\n \n       --    Renaming objects in renaming associations\n@@ -4222,8 +4215,8 @@ package body Exp_Ch4 is\n             then\n                return;\n \n-            --  If the expression is an index of an indexed component,\n-            --  it must be expanded regardless of context.\n+            --  If the expression is an index of an indexed component, it must\n+            --  be expanded regardless of context.\n \n             elsif Nkind (Parnt) = N_Indexed_Component\n               and then Child /= Prefix (Parnt)\n@@ -4252,8 +4245,8 @@ package body Exp_Ch4 is\n                return;\n             end if;\n \n-            --  Keep looking up tree for unchecked expression, or if we are\n-            --  the prefix of a possible assignment left side.\n+            --  Keep looking up tree for unchecked expression, or if we are the\n+            --  prefix of a possible assignment left side.\n \n             Child := Parnt;\n             Parnt := Parent (Child);\n@@ -4296,11 +4289,11 @@ package body Exp_Ch4 is\n    -- Expand_N_Null --\n    -------------------\n \n-   --  The only replacement required is for the case of a null of type\n-   --  that is an access to protected subprogram. We represent such\n-   --  access values as a record, and so we must replace the occurrence\n-   --  of null by the equivalent record (with a null address and a null\n-   --  pointer in it), so that the backend creates the proper value.\n+   --  The only replacement required is for the case of a null of type that is\n+   --  an access to protected subprogram. We represent such access values as a\n+   --  record, and so we must replace the occurrence of null by the equivalent\n+   --  record (with a null address and a null pointer in it), so that the\n+   --  backend creates the proper value.\n \n    procedure Expand_N_Null (N : Node_Id) is\n       Loc : constant Source_Ptr := Sloc (N);\n@@ -4318,9 +4311,9 @@ package body Exp_Ch4 is\n          Rewrite (N, Agg);\n          Analyze_And_Resolve (N, Equivalent_Type (Typ));\n \n-         --  For subsequent semantic analysis, the node must retain its\n-         --  type. Gigi in any case replaces this type by the corresponding\n-         --  record type before processing the node.\n+         --  For subsequent semantic analysis, the node must retain its type.\n+         --  Gigi in any case replaces this type by the corresponding record\n+         --  type before processing the node.\n \n          Set_Etype (N, Typ);\n       end if;\n@@ -4347,9 +4340,8 @@ package body Exp_Ch4 is\n          and then Is_Signed_Integer_Type (Etype (N))\n          and then Do_Overflow_Check (N)\n       then\n-         --  The only case to worry about is when the argument is\n-         --  equal to the largest negative number, so what we do is\n-         --  to insert the check:\n+         --  The only case to worry about is when the argument is equal to the\n+         --  largest negative number, so what we do is to insert the check:\n \n          --     [constraint_error when Expr = typ'Base'First]\n \n@@ -4465,8 +4457,8 @@ package body Exp_Ch4 is\n       --  Single operand for concatenation\n \n       Cnode : Node_Id;\n-      --  Node which is to be replaced by the result of concatenating\n-      --  the nodes in the list Opnds.\n+      --  Node which is to be replaced by the result of concatenating the nodes\n+      --  in the list Opnds.\n \n       Atyp : Entity_Id;\n       --  Array type of concatenation result type\n@@ -4510,9 +4502,9 @@ package body Exp_Ch4 is\n \n       Binary_Op_Validity_Checks (N);\n \n-      --  If we are the left operand of a concatenation higher up the\n-      --  tree, then do nothing for now, since we want to deal with a\n-      --  series of concatenations as a unit.\n+      --  If we are the left operand of a concatenation higher up the tree,\n+      --  then do nothing for now, since we want to deal with a series of\n+      --  concatenations as a unit.\n \n       if Nkind (Parent (N)) = N_Op_Concat\n         and then N = Left_Opnd (Parent (N))\n@@ -4564,10 +4556,10 @@ package body Exp_Ch4 is\n             Append (Right_Opnd (Cnode), Opnds);\n          end loop Inner;\n \n-         --  Here we process the collected operands. First we convert\n-         --  singleton operands to singleton aggregates. This is skipped\n-         --  however for the case of two operands of type String, since\n-         --  we have special routines for these cases.\n+         --  Here we process the collected operands. First we convert singleton\n+         --  operands to singleton aggregates. This is skipped however for the\n+         --  case of two operands of type String since we have special routines\n+         --  for these cases.\n \n          Atyp := Base_Type (Etype (Cnode));\n          Ctyp := Base_Type (Component_Type (Etype (Cnode)));\n@@ -4668,9 +4660,9 @@ package body Exp_Ch4 is\n \n       if Is_Fixed_Point_Type (Typ) then\n \n-         --  No special processing if Treat_Fixed_As_Integer is set,\n-         --  since from a semantic point of view such operations are\n-         --  simply integer operations and will be treated that way.\n+         --  No special processing if Treat_Fixed_As_Integer is set, since\n+         --  from a semantic point of view such operations are simply integer\n+         --  operations and will be treated that way.\n \n          if not Treat_Fixed_As_Integer (N) then\n             if Is_Integer_Type (Rtyp) then\n@@ -4680,8 +4672,8 @@ package body Exp_Ch4 is\n             end if;\n          end if;\n \n-      --  Other cases of division of fixed-point operands. Again we\n-      --  exclude the case where Treat_Fixed_As_Integer is set.\n+      --  Other cases of division of fixed-point operands. Again we exclude the\n+      --  case where Treat_Fixed_As_Integer is set.\n \n       elsif (Is_Fixed_Point_Type (Ltyp) or else\n              Is_Fixed_Point_Type (Rtyp))\n@@ -4694,9 +4686,8 @@ package body Exp_Ch4 is\n             Expand_Divide_Fixed_By_Fixed_Giving_Float (N);\n          end if;\n \n-      --  Mixed-mode operations can appear in a non-static universal\n-      --  context, in  which case the integer argument must be converted\n-      --  explicitly.\n+      --  Mixed-mode operations can appear in a non-static universal context,\n+      --  in which case the integer argument must be converted explicitly.\n \n       elsif Typ = Universal_Real\n         and then Is_Integer_Type (Rtyp)\n@@ -5178,9 +5169,9 @@ package body Exp_Ch4 is\n          then\n             null;\n \n-         --  For composite and floating-point cases, expand equality loop\n-         --  to make sure of using proper comparisons for tagged types,\n-         --  and correctly handling the floating-point case.\n+         --  For composite and floating-point cases, expand equality loop to\n+         --  make sure of using proper comparisons for tagged types, and\n+         --  correctly handling the floating-point case.\n \n          else\n             Rewrite (N,\n@@ -5210,20 +5201,19 @@ package body Exp_Ch4 is\n                return;\n             end if;\n \n-            --  If this is derived from an untagged private type completed\n-            --  with a tagged type, it does not have a full view, so we\n-            --  use the primitive operations of the private type.\n-            --  This check should no longer be necessary when these\n-            --  types receive their full views ???\n+            --  If this is derived from an untagged private type completed with\n+            --  a tagged type, it does not have a full view, so we use the\n+            --  primitive operations of the private type. This check should no\n+            --  longer be necessary when these types get their full views???\n \n             if Is_Private_Type (A_Typ)\n               and then not Is_Tagged_Type (A_Typ)\n               and then Is_Derived_Type (A_Typ)\n               and then No (Full_View (A_Typ))\n             then\n-               --  Search for equality operation, checking that the\n-               --  operands have the same type. Note that we must find\n-               --  a matching entry, or something is very wrong!\n+               --  Search for equality operation, checking that the operands\n+               --  have the same type. Note that we must find a matching entry,\n+               --  or something is very wrong!\n \n                Prim := First_Elmt (Collect_Primitive_Operations (A_Typ));\n \n@@ -5241,11 +5231,11 @@ package body Exp_Ch4 is\n                Op_Name := Node (Prim);\n \n             --  Find the type's predefined equality or an overriding\n-            --  user-defined equality. The reason for not simply calling\n+            --  user- defined equality. The reason for not simply calling\n             --  Find_Prim_Op here is that there may be a user-defined\n-            --  overloaded equality op that precedes the equality that\n-            --  we want, so we have to explicitly search (e.g., there\n-            --  could be an equality with two different parameter types).\n+            --  overloaded equality op that precedes the equality that we want,\n+            --  so we have to explicitly search (e.g., there could be an\n+            --  equality with two different parameter types).\n \n             else\n                if Is_Class_Wide_Type (Typl) then\n@@ -5370,12 +5360,12 @@ package body Exp_Ch4 is\n    begin\n       Binary_Op_Validity_Checks (N);\n \n-      --  If either operand is of a private type, then we have the use of\n-      --  an intrinsic operator, and we get rid of the privateness, by using\n-      --  root types of underlying types for the actual operation. Otherwise\n-      --  the private types will cause trouble if we expand multiplications\n-      --  or shifts etc. We also do this transformation if the result type\n-      --  is different from the base type.\n+      --  If either operand is of a private type, then we have the use of an\n+      --  intrinsic operator, and we get rid of the privateness, by using root\n+      --  types of underlying types for the actual operation. Otherwise the\n+      --  private types will cause trouble if we expand multiplications or\n+      --  shifts etc. We also do this transformation if the result type is\n+      --  different from the base type.\n \n       if Is_Private_Type (Etype (Base))\n            or else\n@@ -5483,6 +5473,10 @@ package body Exp_Ch4 is\n       --  the flag Is_Natural_Power_Of_2_for_Shift set, then the expansion\n       --  of the higher level node converts it into a shift.\n \n+      --  Note: this transformation is not applicable for a modular type with\n+      --  a non-binary modulus in the multiplication case, since we get a wrong\n+      --  result if the shift causes an overflow before the modular reduction.\n+\n       if Nkind (Base) = N_Integer_Literal\n         and then Intval (Base) = 2\n         and then Is_Integer_Type (Root_Type (Exptyp))\n@@ -5498,6 +5492,7 @@ package body Exp_Ch4 is\n \n          begin\n             if (Nkind (P) = N_Op_Multiply\n+                 and then not Non_Binary_Modulus (Typ)\n                  and then\n                    ((Is_Integer_Type (Etype (L)) and then R = N)\n                        or else\n@@ -5538,9 +5533,9 @@ package body Exp_Ch4 is\n                     Make_Integer_Literal (Loc, Modulus (Rtyp)),\n                     Exp))));\n \n-         --  Binary case, in this case, we call one of two routines, either\n-         --  the unsigned integer case, or the unsigned long long integer\n-         --  case, with a final \"and\" operation to do the required mod.\n+         --  Binary case, in this case, we call one of two routines, either the\n+         --  unsigned integer case, or the unsigned long long integer case,\n+         --  with a final \"and\" operation to do the required mod.\n \n          else\n             if UI_To_Int (Esize (Rtyp)) <= Standard_Integer_Size then\n@@ -5859,9 +5854,9 @@ package body Exp_Ch4 is\n              Left_Opnd  => Left_Opnd (N),\n              Right_Opnd => Right_Opnd (N)));\n \n-         --  Instead of reanalyzing the node we do the analysis manually.\n-         --  This avoids anomalies when the replacement is done in an\n-         --  instance and is epsilon more efficient.\n+         --  Instead of reanalyzing the node we do the analysis manually. This\n+         --  avoids anomalies when the replacement is done in an instance and\n+         --  is epsilon more efficient.\n \n          Set_Entity            (N, Standard_Entity (S_Op_Rem));\n          Set_Etype             (N, Typ);\n@@ -5894,13 +5889,13 @@ package body Exp_Ch4 is\n          --  minus one. Gigi does not handle this case correctly, because\n          --  it generates a divide instruction which may trap in this case.\n \n-         --  In fact the check is quite easy, if the right operand is -1,\n-         --  then the mod value is always 0, and we can just ignore the\n-         --  left operand completely in this case.\n+         --  In fact the check is quite easy, if the right operand is -1, then\n+         --  the mod value is always 0, and we can just ignore the left operand\n+         --  completely in this case.\n \n-         --  The operand type may be private (e.g. in the expansion of an\n-         --  an intrinsic operation) so we must use the underlying type to\n-         --  get the bounds, and convert the literals explicitly.\n+         --  The operand type may be private (e.g. in the expansion of an an\n+         --  intrinsic operation) so we must use the underlying type to get the\n+         --  bounds, and convert the literals explicitly.\n \n          LLB :=\n            Expr_Value\n@@ -6042,9 +6037,9 @@ package body Exp_Ch4 is\n \n       if Is_Fixed_Point_Type (Typ) then\n \n-         --  No special processing if Treat_Fixed_As_Integer is set,\n-         --  since from a semantic point of view such operations are\n-         --  simply integer operations and will be treated that way.\n+         --  No special processing if Treat_Fixed_As_Integer is set, since from\n+         --  a semantic point of view such operations are simply integer\n+         --  operations and will be treated that way.\n \n          if not Treat_Fixed_As_Integer (N) then\n \n@@ -6065,8 +6060,8 @@ package body Exp_Ch4 is\n             end if;\n          end if;\n \n-      --  Other cases of multiplication of fixed-point operands. Again\n-      --  we exclude the cases where Treat_Fixed_As_Integer flag is set.\n+      --  Other cases of multiplication of fixed-point operands. Again we\n+      --  exclude the cases where Treat_Fixed_As_Integer flag is set.\n \n       elsif (Is_Fixed_Point_Type (Ltyp) or else Is_Fixed_Point_Type (Rtyp))\n         and then not Treat_Fixed_As_Integer (N)\n@@ -6078,9 +6073,8 @@ package body Exp_Ch4 is\n             Expand_Multiply_Fixed_By_Fixed_Giving_Float (N);\n          end if;\n \n-      --  Mixed-mode operations can appear in a non-static universal\n-      --  context, in  which case the integer argument must be converted\n-      --  explicitly.\n+      --  Mixed-mode operations can appear in a non-static universal context,\n+      --  in which case the integer argument must be converted explicitly.\n \n       elsif Typ = Universal_Real\n         and then Is_Integer_Type (Rtyp)\n@@ -6187,18 +6181,18 @@ package body Exp_Ch4 is\n    -- Expand_N_Op_Not --\n    ---------------------\n \n-   --  If the argument is other than a Boolean array type, there is no\n-   --  special expansion required.\n+   --  If the argument is other than a Boolean array type, there is no special\n+   --  expansion required.\n \n    --  For the packed case, we call the special routine in Exp_Pakd, except\n    --  that if the component size is greater than one, we use the standard\n    --  routine generating a gruesome loop (it is so peculiar to have packed\n-   --  arrays with non-standard Boolean representations anyway, so it does\n-   --  not matter that we do not handle this case efficiently).\n+   --  arrays with non-standard Boolean representations anyway, so it does not\n+   --  matter that we do not handle this case efficiently).\n \n-   --  For the unpacked case (and for the special packed case where we have\n-   --  non standard Booleans, as discussed above), we generate and insert\n-   --  into the tree the following function definition:\n+   --  For the unpacked case (and for the special packed case where we have non\n+   --  standard Booleans, as discussed above), we generate and insert into the\n+   --  tree the following function definition:\n \n    --     function Nnnn (A : arr) is\n    --       B : arr;\n@@ -6435,9 +6429,9 @@ package body Exp_Ch4 is\n          Apply_Divide_Check (N);\n       end if;\n \n-      --  Apply optimization x rem 1 = 0. We don't really need that with\n-      --  gcc, but it is useful with other back ends (e.g. AAMP), and is\n-      --  certainly harmless.\n+      --  Apply optimization x rem 1 = 0. We don't really need that with gcc,\n+      --  but it is useful with other back ends (e.g. AAMP), and is certainly\n+      --  harmless.\n \n       if Is_Integer_Type (Etype (N))\n         and then Compile_Time_Known_Value (Right)\n@@ -6448,20 +6442,20 @@ package body Exp_Ch4 is\n          return;\n       end if;\n \n-      --  Deal with annoying case of largest negative number remainder\n-      --  minus one. Gigi does not handle this case correctly, because\n-      --  it generates a divide instruction which may trap in this case.\n+      --  Deal with annoying case of largest negative number remainder minus\n+      --  one. Gigi does not handle this case correctly, because it generates\n+      --  a divide instruction which may trap in this case.\n \n-      --  In fact the check is quite easy, if the right operand is -1,\n-      --  then the remainder is always 0, and we can just ignore the\n-      --  left operand completely in this case.\n+      --  In fact the check is quite easy, if the right operand is -1, then\n+      --  the remainder is always 0, and we can just ignore the left operand\n+      --  completely in this case.\n \n       Determine_Range (Right, ROK, Rlo, Rhi);\n       Determine_Range (Left, LOK, Llo, Lhi);\n \n-      --  The operand type may be private (e.g. in the expansion of an\n-      --  an intrinsic operation) so we must use the underlying type to\n-      --  get the bounds, and convert the literals explicitly.\n+      --  The operand type may be private (e.g. in the expansion of an an\n+      --  intrinsic operation) so we must use the underlying type to get the\n+      --  bounds, and convert the literals explicitly.\n \n       LLB :=\n         Expr_Value\n@@ -6632,9 +6626,9 @@ package body Exp_Ch4 is\n             Adjust_Result_Type (N, Typ);\n             return;\n \n-         --  If left argument is True, change (True and then Right) to\n-         --  True. In this case we can forget the actions associated with\n-         --  Right, since they will never be executed.\n+         --  If left argument is True, change (True and then Right) to True. In\n+         --  this case we can forget the actions associated with Right, since\n+         --  they will never be executed.\n \n          elsif Entity (Left) = Standard_True then\n             Kill_Dead_Code (Right);\n@@ -6676,15 +6670,15 @@ package body Exp_Ch4 is\n \n       if Nkind (Right) = N_Identifier then\n \n-         --  Change (Left or else False) to Left. Note that we know there\n-         --  are no actions associated with the True operand, since we\n-         --  just checked for this case above.\n+         --  Change (Left or else False) to Left. Note that we know there are\n+         --  no actions associated with the True operand, since we just checked\n+         --  for this case above.\n \n          if Entity (Right) = Standard_False then\n             Rewrite (N, Left);\n \n-         --  Change (Left or else True) to True, making sure to preserve\n-         --  any side effects associated with the Left operand.\n+         --  Change (Left or else True) to True, making sure to preserve any\n+         --  side effects associated with the Left operand.\n \n          elsif Entity (Right) = Standard_True then\n             Remove_Side_Effects (Left);\n@@ -6774,8 +6768,8 @@ package body Exp_Ch4 is\n \n       if Do_Discriminant_Check (N) then\n \n-         --  Present the discriminant checking function to the backend,\n-         --  so that it can inline the call to the function.\n+         --  Present the discriminant checking function to the backend, so that\n+         --  it can inline the call to the function.\n \n          Add_Inlined_Body\n            (Discriminant_Checking_Func\n@@ -6837,9 +6831,9 @@ package body Exp_Ch4 is\n             then\n                null;\n \n-            --  Don't do this optimization for the prefix of an attribute\n-            --  or the operand of an object renaming declaration since these\n-            --  are contexts where we do not want the value anyway.\n+            --  Don't do this optimization for the prefix of an attribute or\n+            --  the operand of an object renaming declaration since these are\n+            --  contexts where we do not want the value anyway.\n \n             elsif (Nkind (Par) = N_Attribute_Reference\n                      and then Prefix (Par) = N)\n@@ -6855,12 +6849,12 @@ package body Exp_Ch4 is\n                null;\n \n             --  Green light to see if we can do the optimization. There is\n-            --  still one condition that inhibits the optimization below\n-            --  but now is the time to check the particular discriminant.\n+            --  still one condition that inhibits the optimization below but\n+            --  now is the time to check the particular discriminant.\n \n             else\n-               --  Loop through discriminants to find the matching\n-               --  discriminant constraint to see if we can copy it.\n+               --  Loop through discriminants to find the matching discriminant\n+               --  constraint to see if we can copy it.\n \n                Disc := First_Discriminant (Ptyp);\n                Dcon := First_Elmt (Discriminant_Constraint (Ptyp));\n@@ -6881,10 +6875,10 @@ package body Exp_Ch4 is\n                      then\n                         exit Discr_Loop;\n \n-                     --  In the context of a case statement, the expression\n-                     --  may have the base type of the discriminant, and we\n-                     --  need to preserve the constraint to avoid spurious\n-                     --  errors on missing cases.\n+                     --  In the context of a case statement, the expression may\n+                     --  have the base type of the discriminant, and we need to\n+                     --  preserve the constraint to avoid spurious errors on\n+                     --  missing cases.\n \n                      elsif Nkind (Parent (N)) = N_Case_Statement\n                        and then Etype (Node (Dcon)) /= Etype (Disc)\n@@ -6924,8 +6918,8 @@ package body Exp_Ch4 is\n \n                --  Note: the above loop should always find a matching\n                --  discriminant, but if it does not, we just missed an\n-               --  optimization due to some glitch (perhaps a previous\n-               --  error), so ignore.\n+               --  optimization due to some glitch (perhaps a previous error),\n+               --  so ignore.\n \n             end if;\n          end if;\n@@ -6971,21 +6965,21 @@ package body Exp_Ch4 is\n       Ptp  : Entity_Id           := Etype (Pfx);\n \n       function Is_Procedure_Actual (N : Node_Id) return Boolean;\n-      --  Check whether the argument is an actual for a procedure call,\n-      --  in which case the expansion of a bit-packed slice is deferred\n-      --  until the call itself is expanded. The reason this is required\n-      --  is that we might have an IN OUT or OUT parameter, and the copy out\n-      --  is essential, and that copy out would be missed if we created a\n-      --  temporary here in Expand_N_Slice. Note that we don't bother\n-      --  to test specifically for an IN OUT or OUT mode parameter, since it\n-      --  is a bit tricky to do, and it is harmless to defer expansion\n-      --  in the IN case, since the call processing will still generate the\n-      --  appropriate copy in operation, which will take care of the slice.\n+      --  Check whether the argument is an actual for a procedure call, in\n+      --  which case the expansion of a bit-packed slice is deferred until the\n+      --  call itself is expanded. The reason this is required is that we might\n+      --  have an IN OUT or OUT parameter, and the copy out is essential, and\n+      --  that copy out would be missed if we created a temporary here in\n+      --  Expand_N_Slice. Note that we don't bother to test specifically for an\n+      --  IN OUT or OUT mode parameter, since it is a bit tricky to do, and it\n+      --  is harmless to defer expansion in the IN case, since the call\n+      --  processing will still generate the appropriate copy in operation,\n+      --  which will take care of the slice.\n \n       procedure Make_Temporary;\n-      --  Create a named variable for the value of the slice, in\n-      --  cases where the back-end cannot handle it properly, e.g.\n-      --  when packed types or unaligned slices are involved.\n+      --  Create a named variable for the value of the slice, in cases where\n+      --  the back-end cannot handle it properly, e.g. when packed types or\n+      --  unaligned slices are involved.\n \n       -------------------------\n       -- Is_Procedure_Actual --\n@@ -7001,11 +6995,11 @@ package body Exp_Ch4 is\n             if Nkind (Par) = N_Procedure_Call_Statement then\n                return True;\n \n-            --  If our parent is a type conversion, keep climbing the\n-            --  tree, since a type conversion can be a procedure actual.\n-            --  Also keep climbing if parameter association or a qualified\n-            --  expression, since these are additional cases that do can\n-            --  appear on procedure actuals.\n+            --  If our parent is a type conversion, keep climbing the tree,\n+            --  since a type conversion can be a procedure actual. Also keep\n+            --  climbing if parameter association or a qualified expression,\n+            --  since these are additional cases that do can appear on\n+            --  procedure actuals.\n \n             elsif Nkind_In (Par, N_Type_Conversion,\n                                  N_Parameter_Association,\n@@ -7072,9 +7066,9 @@ package body Exp_Ch4 is\n          Make_Build_In_Place_Call_In_Anonymous_Context (Pfx);\n       end if;\n \n-      --  Range checks are potentially also needed for cases involving\n-      --  a slice indexed by a subtype indication, but Do_Range_Check\n-      --  can currently only be set for expressions ???\n+      --  Range checks are potentially also needed for cases involving a slice\n+      --  indexed by a subtype indication, but Do_Range_Check can currently\n+      --  only be set for expressions ???\n \n       if not Index_Checks_Suppressed (Ptp)\n         and then (not Is_Entity_Name (Pfx)\n@@ -7104,24 +7098,24 @@ package body Exp_Ch4 is\n       --    1. Right or left side of an assignment (we can handle this\n       --       situation correctly in the assignment statement expansion).\n \n-      --    2. Prefix of indexed component (the slide is optimized away\n-      --       in this case, see the start of Expand_N_Slice.)\n+      --    2. Prefix of indexed component (the slide is optimized away in this\n+      --       case, see the start of Expand_N_Slice.)\n \n-      --    3. Object renaming declaration, since we want the name of\n-      --       the slice, not the value.\n+      --    3. Object renaming declaration, since we want the name of the\n+      --       slice, not the value.\n \n-      --    4. Argument to procedure call, since copy-in/copy-out handling\n-      --       may be required, and this is handled in the expansion of\n-      --       call itself.\n+      --    4. Argument to procedure call, since copy-in/copy-out handling may\n+      --       be required, and this is handled in the expansion of call\n+      --       itself.\n \n-      --    5. Prefix of an address attribute (this is an error which\n-      --       is caught elsewhere, and the expansion would interfere\n-      --       with generating the error message).\n+      --    5. Prefix of an address attribute (this is an error which is caught\n+      --       elsewhere, and the expansion would interfere with generating the\n+      --       error message).\n \n       if not Is_Packed (Typ) then\n \n-         --  Apply transformation for actuals of a function call,\n-         --  where Expand_Actuals is not used.\n+         --  Apply transformation for actuals of a function call, where\n+         --  Expand_Actuals is not used.\n \n          if Nkind (Parent (N)) = N_Function_Call\n            and then Is_Possibly_Unaligned_Slice (N)\n@@ -7162,12 +7156,12 @@ package body Exp_Ch4 is\n       Operand_Type : Entity_Id           := Etype (Operand);\n \n       procedure Handle_Changed_Representation;\n-      --  This is called in the case of record and array type conversions\n-      --  to see if there is a change of representation to be handled.\n-      --  Change of representation is actually handled at the assignment\n-      --  statement level, and what this procedure does is rewrite node N\n-      --  conversion as an assignment to temporary. If there is no change\n-      --  of representation, then the conversion node is unchanged.\n+      --  This is called in the case of record and array type conversions to\n+      --  see if there is a change of representation to be handled. Change of\n+      --  representation is actually handled at the assignment statement level,\n+      --  and what this procedure does is rewrite node N conversion as an\n+      --  assignment to temporary. If there is no change of representation,\n+      --  then the conversion node is unchanged.\n \n       procedure Real_Range_Check;\n       --  Handles generation of range check for real target value\n@@ -7205,8 +7199,8 @@ package body Exp_Ch4 is\n          else\n             Cons := No_List;\n \n-            --  If type is unconstrained we have to add a constraint,\n-            --  copied from the actual value of the left hand side.\n+            --  If type is unconstrained we have to add a constraint, copied\n+            --  from the actual value of the left hand side.\n \n             if not Is_Constrained (Target_Type) then\n                if Has_Discriminants (Operand_Type) then\n@@ -7302,9 +7296,8 @@ package body Exp_Ch4 is\n       -- Real_Range_Check --\n       ----------------------\n \n-      --  Case of conversions to floating-point or fixed-point. If range\n-      --  checks are enabled and the target type has a range constraint,\n-      --  we convert:\n+      --  Case of conversions to floating-point or fixed-point. If range checks\n+      --  are enabled and the target type has a range constraint, we convert:\n \n       --     typ (x)\n \n@@ -7314,10 +7307,10 @@ package body Exp_Ch4 is\n       --     [constraint_error when Tnn < typ'First or else Tnn > typ'Last]\n       --     Tnn\n \n-      --  This is necessary when there is a conversion of integer to float\n-      --  or to fixed-point to ensure that the correct checks are made. It\n-      --  is not necessary for float to float where it is enough to simply\n-      --  set the Do_Range_Check flag.\n+      --  This is necessary when there is a conversion of integer to float or\n+      --  to fixed-point to ensure that the correct checks are made. It is not\n+      --  necessary for float to float where it is enough to simply set the\n+      --  Do_Range_Check flag.\n \n       procedure Real_Range_Check is\n          Btyp : constant Entity_Id := Base_Type (Target_Type);\n@@ -7334,8 +7327,8 @@ package body Exp_Ch4 is\n             return;\n          end if;\n \n-         --  Nothing to do if range checks suppressed, or target has the\n-         --  same range as the base type (or is the base type).\n+         --  Nothing to do if range checks suppressed, or target has the same\n+         --  range as the base type (or is the base type).\n \n          if Range_Checks_Suppressed (Target_Type)\n            or else (Lo = Type_Low_Bound (Btyp)\n@@ -7345,19 +7338,19 @@ package body Exp_Ch4 is\n             return;\n          end if;\n \n-         --  Nothing to do if expression is an entity on which checks\n-         --  have been suppressed.\n+         --  Nothing to do if expression is an entity on which checks have been\n+         --  suppressed.\n \n          if Is_Entity_Name (Operand)\n            and then Range_Checks_Suppressed (Entity (Operand))\n          then\n             return;\n          end if;\n \n-         --  Nothing to do if bounds are all static and we can tell that\n-         --  the expression is within the bounds of the target. Note that\n-         --  if the operand is of an unconstrained floating-point type,\n-         --  then we do not trust it to be in range (might be infinite)\n+         --  Nothing to do if bounds are all static and we can tell that the\n+         --  expression is within the bounds of the target. Note that if the\n+         --  operand is of an unconstrained floating-point type, then we do\n+         --  not trust it to be in range (might be infinite)\n \n          declare\n             S_Lo : constant Node_Id := Type_Low_Bound (Xtyp);\n@@ -7460,17 +7453,17 @@ package body Exp_Ch4 is\n    --  Start of processing for Expand_N_Type_Conversion\n \n    begin\n-      --  Nothing at all to do if conversion is to the identical type\n-      --  so remove the conversion completely, it is useless.\n+      --  Nothing at all to do if conversion is to the identical type so remove\n+      --  the conversion completely, it is useless.\n \n       if Operand_Type = Target_Type then\n          Rewrite (N, Relocate_Node (Operand));\n          return;\n       end if;\n \n-      --  Nothing to do if this is the second argument of read. This\n-      --  is a \"backwards\" conversion that will be handled by the\n-      --  specialized code in attribute processing.\n+      --  Nothing to do if this is the second argument of read. This is a\n+      --  \"backwards\" conversion that will be handled by the specialized code\n+      --  in attribute processing.\n \n       if Nkind (Parent (N)) = N_Attribute_Reference\n         and then Attribute_Name (Parent (N)) = Name_Read\n@@ -7523,13 +7516,12 @@ package body Exp_Ch4 is\n          then\n             Apply_Accessibility_Check (Operand, Target_Type);\n \n-         --  If the level of the operand type is statically deeper\n-         --  then the level of the target type, then force Program_Error.\n-         --  Note that this can only occur for cases where the attribute\n-         --  is within the body of an instantiation (otherwise the\n-         --  conversion will already have been rejected as illegal).\n-         --  Note: warnings are issued by the analyzer for the instance\n-         --  cases.\n+         --  If the level of the operand type is statically deeper then the\n+         --  level of the target type, then force Program_Error. Note that this\n+         --  can only occur for cases where the attribute is within the body of\n+         --  an instantiation (otherwise the conversion will already have been\n+         --  rejected as illegal). Note: warnings are issued by the analyzer\n+         --  for the instance cases.\n \n          elsif In_Instance_Body\n            and then Type_Access_Level (Operand_Type) >\n@@ -7540,12 +7532,11 @@ package body Exp_Ch4 is\n                 Reason => PE_Accessibility_Check_Failed));\n             Set_Etype (N, Target_Type);\n \n-         --  When the operand is a selected access discriminant\n-         --  the check needs to be made against the level of the\n-         --  object denoted by the prefix of the selected name.\n-         --  Force Program_Error for this case as well (this\n-         --  accessibility violation can only happen if within\n-         --  the body of an instantiation).\n+         --  When the operand is a selected access discriminant the check needs\n+         --  to be made against the level of the object denoted by the prefix\n+         --  of the selected name. Force Program_Error for this case as well\n+         --  (this accessibility violation can only happen if within the body\n+         --  of an instantiation).\n \n          elsif In_Instance_Body\n            and then Ekind (Operand_Type) = E_Anonymous_Access_Type\n@@ -7562,9 +7553,9 @@ package body Exp_Ch4 is\n \n       --  Case of conversions of tagged types and access to tagged types\n \n-      --  When needed, that is to say when the expression is class-wide,\n-      --  Add runtime a tag check for (strict) downward conversion by using\n-      --  the membership test, generating:\n+      --  When needed, that is to say when the expression is class-wide, Add\n+      --  runtime a tag check for (strict) downward conversion by using the\n+      --  membership test, generating:\n \n       --      [constraint_error when Operand not in Target_Type'Class]\n \n@@ -7579,10 +7570,9 @@ package body Exp_Ch4 is\n            and then Is_Tagged_Type (Designated_Type (Target_Type)))\n         or else Is_Tagged_Type (Target_Type)\n       then\n-         --  Do not do any expansion in the access type case if the\n-         --  parent is a renaming, since this is an error situation\n-         --  which will be caught by Sem_Ch8, and the expansion can\n-         --  interfere with this error check.\n+         --  Do not do any expansion in the access type case if the parent is a\n+         --  renaming, since this is an error situation which will be caught by\n+         --  Sem_Ch8, and the expansion can interfere with this error check.\n \n          if Is_Access_Type (Target_Type)\n            and then Is_Renamed_Object (N)\n@@ -7622,8 +7612,7 @@ package body Exp_Ch4 is\n                           Actual_Target_Type)\n               and then not Tag_Checks_Suppressed (Actual_Target_Type)\n             then\n-               --  The conversion is valid for any descendant of the\n-               --  target type\n+               --  Conversion is valid for any descendant of the target type\n \n                Actual_Target_Type := Class_Wide_Type (Actual_Target_Type);\n \n@@ -7677,9 +7666,9 @@ package body Exp_Ch4 is\n \n       --  Case of conversions from a fixed-point type\n \n-      --  These conversions require special expansion and processing, found\n-      --  in the Exp_Fixd package. We ignore cases where Conversion_OK is\n-      --  set, since from a semantic point of view, these are simple integer\n+      --  These conversions require special expansion and processing, found in\n+      --  the Exp_Fixd package. We ignore cases where Conversion_OK is set,\n+      --  since from a semantic point of view, these are simple integer\n       --  conversions, which do not need further processing.\n \n       elsif Is_Fixed_Point_Type (Operand_Type)\n@@ -7691,11 +7680,10 @@ package body Exp_Ch4 is\n \n          pragma Assert (Operand_Type /= Universal_Fixed);\n \n-         --  Check for special case of the conversion to universal real\n-         --  that occurs as a result of the use of a round attribute.\n-         --  In this case, the real type for the conversion is taken\n-         --  from the target type of the Round attribute and the\n-         --  result must be marked as rounded.\n+         --  Check for special case of the conversion to universal real that\n+         --  occurs as a result of the use of a round attribute. In this case,\n+         --  the real type for the conversion is taken from the target type of\n+         --  the Round attribute and the result must be marked as rounded.\n \n          if Target_Type = Universal_Real\n            and then Nkind (Parent (N)) = N_Attribute_Reference\n@@ -7727,10 +7715,10 @@ package body Exp_Ch4 is\n \n       --  Case of conversions to a fixed-point type\n \n-      --  These conversions require special expansion and processing, found\n-      --  in the Exp_Fixd package. Again, ignore cases where Conversion_OK\n-      --  is set, since from a semantic point of view, these are simple\n-      --  integer conversions, which do not need further processing.\n+      --  These conversions require special expansion and processing, found in\n+      --  the Exp_Fixd package. Again, ignore cases where Conversion_OK is set,\n+      --  since from a semantic point of view, these are simple integer\n+      --  conversions, which do not need further processing.\n \n       elsif Is_Fixed_Point_Type (Target_Type)\n         and then not Conversion_OK (N)\n@@ -7782,9 +7770,9 @@ package body Exp_Ch4 is\n \n       --  Case of array conversions\n \n-      --  Expansion of array conversions, add required length/range checks\n-      --  but only do this if there is no change of representation. For\n-      --  handling of this case, see Handle_Changed_Representation.\n+      --  Expansion of array conversions, add required length/range checks but\n+      --  only do this if there is no change of representation. For handling of\n+      --  this case, see Handle_Changed_Representation.\n \n       elsif Is_Array_Type (Target_Type) then\n \n@@ -7798,8 +7786,8 @@ package body Exp_Ch4 is\n \n       --  Case of conversions of discriminated types\n \n-      --  Add required discriminant checks if target is constrained. Again\n-      --  this change is skipped if we have a change of representation.\n+      --  Add required discriminant checks if target is constrained. Again this\n+      --  change is skipped if we have a change of representation.\n \n       elsif Has_Discriminants (Target_Type)\n         and then Is_Constrained (Target_Type)\n@@ -7814,16 +7802,16 @@ package body Exp_Ch4 is\n       elsif Is_Record_Type (Target_Type) then\n \n          --  Ada 2005 (AI-216): Program_Error is raised when converting from\n-         --  a derived Unchecked_Union type to an unconstrained non-Unchecked_\n-         --  Union type if the operand lacks inferable discriminants.\n+         --  a derived Unchecked_Union type to an unconstrained type that is\n+         --  not Unchecked_Union if the operand lacks inferable discriminants.\n \n          if Is_Derived_Type (Operand_Type)\n            and then Is_Unchecked_Union (Base_Type (Operand_Type))\n            and then not Is_Constrained (Target_Type)\n            and then not Is_Unchecked_Union (Base_Type (Target_Type))\n            and then not Has_Inferable_Discriminants (Operand)\n          then\n-            --  To prevent Gigi from generating illegal code, we make a\n+            --  To prevent Gigi from generating illegal code, we generate a\n             --  Program_Error node, but we give it the target type of the\n             --  conversion.\n \n@@ -7870,25 +7858,24 @@ package body Exp_Ch4 is\n          Real_Range_Check;\n       end if;\n \n-      --  At this stage, either the conversion node has been transformed\n-      --  into some other equivalent expression, or left as a conversion\n-      --  that can be handled by Gigi. The conversions that Gigi can handle\n-      --  are the following:\n+      --  At this stage, either the conversion node has been transformed into\n+      --  some other equivalent expression, or left as a conversion that can\n+      --  be handled by Gigi. The conversions that Gigi can handle are the\n+      --  following:\n \n       --    Conversions with no change of representation or type\n \n-      --    Numeric conversions involving integer values, floating-point\n-      --    values, and fixed-point values. Fixed-point values are allowed\n-      --    only if Conversion_OK is set, i.e. if the fixed-point values\n-      --    are to be treated as integers.\n+      --    Numeric conversions involving integer, floating- and fixed-point\n+      --    values. Fixed-point values are allowed only if Conversion_OK is\n+      --    set, i.e. if the fixed-point values are to be treated as integers.\n \n       --  No other conversions should be passed to Gigi\n \n       --  Check: are these rules stated in sinfo??? if so, why restate here???\n \n-      --  The only remaining step is to generate a range check if we still\n-      --  have a type conversion at this stage and Do_Range_Check is set.\n-      --  For now we do this only for conversions of discrete types.\n+      --  The only remaining step is to generate a range check if we still have\n+      --  a type conversion at this stage and Do_Range_Check is set. For now we\n+      --  do this only for conversions of discrete types.\n \n       if Nkind (N) = N_Type_Conversion\n         and then Is_Discrete_Type (Etype (N))\n@@ -7904,9 +7891,9 @@ package body Exp_Ch4 is\n             then\n                Set_Do_Range_Check (Expr, False);\n \n-               --  Before we do a range check, we have to deal with treating\n-               --  a fixed-point operand as an integer. The way we do this\n-               --  is simply to do an unchecked conversion to an appropriate\n+               --  Before we do a range check, we have to deal with treating a\n+               --  fixed-point operand as an integer. The way we do this is\n+               --  simply to do an unchecked conversion to an appropriate\n                --  integer type large enough to hold the result.\n \n                --  This code is not active yet, because we are only dealing\n@@ -7927,8 +7914,8 @@ package body Exp_Ch4 is\n                end if;\n \n                --  Reset overflow flag, since the range check will include\n-               --  dealing with possible overflow, and generate the check\n-               --  If Address is either source or target type, suppress\n+               --  dealing with possible overflow, and generate the check If\n+               --  Address is either a source type or target type, suppress\n                --  range check to avoid typing anomalies when it is a visible\n                --  integer type.\n \n@@ -7975,8 +7962,8 @@ package body Exp_Ch4 is\n    -- Expand_N_Unchecked_Type_Conversion --\n    ----------------------------------------\n \n-   --  If this cannot be handled by Gigi and we haven't already made\n-   --  a temporary for it, do it now.\n+   --  If this cannot be handled by Gigi and we haven't already made a\n+   --  temporary for it, do it now.\n \n    procedure Expand_N_Unchecked_Type_Conversion (N : Node_Id) is\n       Target_Type  : constant Entity_Id := Etype (N);\n@@ -8019,9 +8006,9 @@ package body Exp_Ch4 is\n             then\n                Rewrite (N, Make_Integer_Literal (Sloc (N), Val));\n \n-               --  If Address is the target type, just set the type\n-               --  to avoid a spurious type error on the literal when\n-               --  Address is a visible integer type.\n+               --  If Address is the target type, just set the type to avoid a\n+               --  spurious type error on the literal when Address is a visible\n+               --  integer type.\n \n                if Is_Descendent_Of_Address (Target_Type) then\n                   Set_Etype (N, Target_Type);\n@@ -8425,11 +8412,11 @@ package body Exp_Ch4 is\n \n              New_Reference_To (Pool, Loc),\n \n-            --  Storage_Address. We use the attribute Pool_Address,\n-            --  which uses the pointer itself to find the address of\n-            --  the object, and which handles unconstrained arrays\n-            --  properly by computing the address of the template.\n-            --  i.e. the correct address of the corresponding allocation.\n+            --  Storage_Address. We use the attribute Pool_Address, which uses\n+            --  the pointer itself to find the address of the object, and which\n+            --  handles unconstrained arrays properly by computing the address\n+            --  of the template. i.e. the correct address of the corresponding\n+            --  allocation.\n \n              Make_Attribute_Reference (Loc,\n                Prefix         => Duplicate_Subexpr_Move_Checks (N),\n@@ -8722,8 +8709,8 @@ package body Exp_Ch4 is\n    -- Make_Boolean_Array_Op --\n    ---------------------------\n \n-   --  For logical operations on boolean arrays, expand in line the\n-   --  following, replacing 'and' with 'or' or 'xor' where needed:\n+   --  For logical operations on boolean arrays, expand in line the following,\n+   --  replacing 'and' with 'or' or 'xor' where needed:\n \n    --    function Annn (A : typ; B: typ) return typ is\n    --       C : typ;\n@@ -9002,9 +8989,8 @@ package body Exp_Ch4 is\n       --  Start of processing for Is_Safe_In_Place_Array_Op\n \n    begin\n-      --  We skip this processing if the component size is not the\n-      --  same as a system storage unit (since at least for NOT\n-      --  this would cause problems).\n+      --  Skip this processing if the component size is different from system\n+      --  storage unit (since at least for NOT this would cause problems).\n \n       if Component_Size (Etype (Lhs)) /= System_Storage_Unit then\n          return False;\n@@ -9034,15 +9020,15 @@ package body Exp_Ch4 is\n    -- Tagged_Membership --\n    -----------------------\n \n-   --  There are two different cases to consider depending on whether\n-   --  the right operand is a class-wide type or not. If not we just\n-   --  compare the actual tag of the left expr to the target type tag:\n+   --  There are two different cases to consider depending on whether the right\n+   --  operand is a class-wide type or not. If not we just compare the actual\n+   --  tag of the left expr to the target type tag:\n    --\n    --     Left_Expr.Tag = Right_Type'Tag;\n    --\n-   --  If it is a class-wide type we use the RT function CW_Membership which\n-   --  is usually implemented by looking in the ancestor tables contained in\n-   --  the dispatch table pointed by Left_Expr.Tag for Typ'Tag\n+   --  If it is a class-wide type we use the RT function CW_Membership which is\n+   --  usually implemented by looking in the ancestor tables contained in the\n+   --  dispatch table pointed by Left_Expr.Tag for Typ'Tag\n \n    --  Ada 2005 (AI-251): If it is a class-wide interface type we use the RT\n    --  function IW_Membership which is usually implemented by looking in the"}, {"sha": "0b7adc45224c5c816e9098cc446b70ebd5c31247", "filename": "gcc/ada/sem_intr.adb", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/685094bfdee3a606aa8ebf491f4968d9cd4879db/gcc%2Fada%2Fsem_intr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/685094bfdee3a606aa8ebf491f4968d9cd4879db/gcc%2Fada%2Fsem_intr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_intr.adb?ref=685094bfdee3a606aa8ebf491f4968d9cd4879db", "patch": "@@ -418,9 +418,7 @@ package body Sem_Intr is\n              Ptyp1, N);\n          return;\n \n-      elsif Is_Modular_Integer_Type (Typ1)\n-        and then Non_Binary_Modulus (Typ1)\n-      then\n+      elsif Non_Binary_Modulus (Typ1) then\n          Errint\n            (\"shifts not allowed for non-binary modular types\",\n             Ptyp1, N);"}]}