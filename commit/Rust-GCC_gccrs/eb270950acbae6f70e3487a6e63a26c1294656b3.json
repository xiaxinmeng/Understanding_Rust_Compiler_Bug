{"sha": "eb270950acbae6f70e3487a6e63a26c1294656b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWIyNzA5NTBhY2JhZTZmNzBlMzQ4N2E2ZTYzYTI2YzEyOTQ2NTZiMw==", "commit": {"author": {"name": "Feng Xue", "email": "fxue@os.amperecomputing.com", "date": "2019-11-14T03:19:15Z"}, "committer": {"name": "Feng Xue", "email": "fxue@gcc.gnu.org", "date": "2019-11-14T03:19:15Z"}, "message": "Support extended aggregate jump function in ipa-cp\n\n2019-11-14  Feng Xue  <fxue@os.amperecomputing.com>\n\n\tPR ipa/91682\n\t* ipa-prop.h (jump_func_type): New value IPA_JF_LOAD_AGG.\n\t(ipa_load_agg_data, ipa_agg_value, ipa_agg_value_set): New structs.\n\t(ipa_agg_jf_item): Add new field jftype and type, redefine field value.\n\t(ipa_agg_jump_function): Remove member function equal_to.\n\t(ipa_agg_jump_function_p): Remove typedef.\n\t(ipa_copy_agg_values, ipa_release_agg_values): New functions.\n\t* ipa-prop.c (ipa_print_node_jump_functions_for_edge): Dump\n\tinformation for aggregate jump function.\n\t(get_ssa_def_if_simple_copy): Add new parameter rhs_stmt to\n\trecord last definition statement.\n\t(load_from_unmodified_param_or_agg): New function.\n\t(ipa_known_agg_contents_list): Add new field type and value, remove\n\tfield constant.\n\t(build_agg_jump_func_from_list): Rename parameter const_count to\n\tvalue_count, build aggregate jump function from ipa_load_agg_data.\n\t(analyze_agg_content_value): New function.\n\t(extract_mem_content): Analyze memory store assignment to prepare\n\tinformation for aggregate jump function generation.\n\t(determine_known_aggregate_parts): Add new parameter fbi, remove\n\tparameter aa_walk_budeget_p.\n\t(update_jump_functions_after_inlining): Update aggregate jump function.\n\t(ipa_find_agg_cst_for_param): Change type of parameter agg.\n\t(try_make_edge_direct_simple_call): Add new parameter new_root.\n\t(try_make_edge_direct_virtual_call): Add new parameter new_root and\n\tnew_root_info.\n\t(update_indirect_edges_after_inlining): Pass new argument to\n\ttry_make_edge_direct_simple_call and try_make_edge_direct_virtual_call.\n\t(ipa_write_jump_function): Write aggregate jump function to file.\n\t(ipa_read_jump_function): Read aggregate jump function from file.\n\t(ipa_agg_value::equal_to): Migrate from ipa_agg_jf_item::equal_to.\n\t* ipa-cp.c (ipa_get_jf_arith_result): New function.\n\t(ipa_agg_value_from_node): Likewise.\n\t(ipa_agg_value_set_from_jfunc): Likewise.\n\t(propagate_vals_across_arith_jfunc): Likewise.\n\t(propagate_aggregate_lattice): Likewise.\n\t(ipa_get_jf_pass_through_result): Call ipa_get_jf_arith_result.\n\t(propagate_vals_across_pass_through): Call\n\tpropagate_vals_across_arith_jfunc.\n\t(get_clone_agg_value): Move forward.\n\t(propagate_aggs_across_jump_function): Handle value propagation for\n\taggregate jump function.\n\t(agg_jmp_p_vec_for_t_vec): Remove.\n\t(context_independent_aggregate_values): Replace vec<ipa_agg_jf_item>\n\twith vec<ipa_agg_value>.\n\t(copy_plats_to_inter, intersect_with_plats): Likewise.\n\t(agg_replacements_to_vector, intersect_with_agg_replacements): Likewise.\n\t(intersect_aggregate_with_edge): Likewise.\n\t(find_aggregate_values_for_callers_subset): Likewise.\n\t(cgraph_edge_brings_all_agg_vals_for_node): Likewise.\n\t(estimate_local_effects): Replace vec<ipa_agg_jump_function> and\n\tvec<ipa_agg_jump_function_p> with vec<ipa_agg_value_set>.\n\t(gather_context_independent_values): Likewise.\n\t(perform_estimation_of_a_value, decide_whether_version_node): Likewise.\n\t* ipa-fnsummary.c (evaluate_conditions_for_known_args): Replace\n\tvec<ipa_agg_jump_function_p> with vec<ipa_agg_value_set>.\n\t(evaluate_properties_for_edge): Likewise.\n\t(estimate_edge_devirt_benefit): Likewise.\n\t(estimate_edge_size_and_time):  Likewise.\n\t(estimate_calls_size_and_time): Likewise.\n\t(ipa_call_context::ipa_call_context): Likewise.\n\t(estimate_ipcp_clone_size_and_time):  Likewise.\n\t* ipa-fnsummary.h (ipa_call_context): Replace\n\tvec<ipa_agg_jump_function_p> with vec<ipa_agg_value_set>.\n\t* ipa-inline-analysis.c (do_estimate_edge_time): Replace\n\tvec<ipa_agg_jump_function_p> with vec<ipa_agg_value_set>.\n\t(do_estimate_edge_size): Likewise.\n\t(do_estimate_edge_hints): Likewise.\n\n2019-11-14  Feng Xue  <fxue@os.amperecomputing.com>\n\n        PR ipa/91682\n        * gcc.dg/ipa/ipcp-agg-10.c: Change dg-scan string.\n        * gcc.dg/ipa/ipcp-agg-11.c: New test.\n\nFrom-SVN: r278193", "tree": {"sha": "d64f761c523baf3052aaaff96fd28ca6a47d6aaf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d64f761c523baf3052aaaff96fd28ca6a47d6aaf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eb270950acbae6f70e3487a6e63a26c1294656b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb270950acbae6f70e3487a6e63a26c1294656b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb270950acbae6f70e3487a6e63a26c1294656b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb270950acbae6f70e3487a6e63a26c1294656b3/comments", "author": {"login": "feng-xue-ampere", "id": 95893536, "node_id": "U_kgDOBbc4IA", "avatar_url": "https://avatars.githubusercontent.com/u/95893536?v=4", "gravatar_id": "", "url": "https://api.github.com/users/feng-xue-ampere", "html_url": "https://github.com/feng-xue-ampere", "followers_url": "https://api.github.com/users/feng-xue-ampere/followers", "following_url": "https://api.github.com/users/feng-xue-ampere/following{/other_user}", "gists_url": "https://api.github.com/users/feng-xue-ampere/gists{/gist_id}", "starred_url": "https://api.github.com/users/feng-xue-ampere/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/feng-xue-ampere/subscriptions", "organizations_url": "https://api.github.com/users/feng-xue-ampere/orgs", "repos_url": "https://api.github.com/users/feng-xue-ampere/repos", "events_url": "https://api.github.com/users/feng-xue-ampere/events{/privacy}", "received_events_url": "https://api.github.com/users/feng-xue-ampere/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3e7cf2e6c0ee30b83aa158b7bd2b2eb9a686c1c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e7cf2e6c0ee30b83aa158b7bd2b2eb9a686c1c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e7cf2e6c0ee30b83aa158b7bd2b2eb9a686c1c3"}], "stats": {"total": 1495, "additions": 1196, "deletions": 299}, "files": [{"sha": "d6080ece4d473eef7c91839aee450f45c1b255d4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb270950acbae6f70e3487a6e63a26c1294656b3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb270950acbae6f70e3487a6e63a26c1294656b3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eb270950acbae6f70e3487a6e63a26c1294656b3", "patch": "@@ -1,3 +1,74 @@\n+2019-11-14  Feng Xue  <fxue@os.amperecomputing.com>\n+\n+\tPR ipa/91682\n+\t* ipa-prop.h (jump_func_type): New value IPA_JF_LOAD_AGG.\n+\t(ipa_load_agg_data, ipa_agg_value, ipa_agg_value_set): New structs.\n+\t(ipa_agg_jf_item): Add new field jftype and type, redefine field value.\n+\t(ipa_agg_jump_function): Remove member function equal_to.\n+\t(ipa_agg_jump_function_p): Remove typedef.\n+\t(ipa_copy_agg_values, ipa_release_agg_values): New functions.\n+\t* ipa-prop.c (ipa_print_node_jump_functions_for_edge): Dump\n+\tinformation for aggregate jump function.\n+\t(get_ssa_def_if_simple_copy): Add new parameter rhs_stmt to\n+\trecord last definition statement.\n+\t(load_from_unmodified_param_or_agg): New function.\n+\t(ipa_known_agg_contents_list): Add new field type and value, remove\n+\tfield constant.\n+\t(build_agg_jump_func_from_list): Rename parameter const_count to\n+\tvalue_count, build aggregate jump function from ipa_load_agg_data.\n+\t(analyze_agg_content_value): New function.\n+\t(extract_mem_content): Analyze memory store assignment to prepare\n+\tinformation for aggregate jump function generation.\n+\t(determine_known_aggregate_parts): Add new parameter fbi, remove\n+\tparameter aa_walk_budeget_p.\n+\t(update_jump_functions_after_inlining): Update aggregate jump function.\n+\t(ipa_find_agg_cst_for_param): Change type of parameter agg.\n+\t(try_make_edge_direct_simple_call): Add new parameter new_root.\n+\t(try_make_edge_direct_virtual_call): Add new parameter new_root and\n+\tnew_root_info.\n+\t(update_indirect_edges_after_inlining): Pass new argument to\n+\ttry_make_edge_direct_simple_call and try_make_edge_direct_virtual_call.\n+\t(ipa_write_jump_function): Write aggregate jump function to file.\n+\t(ipa_read_jump_function): Read aggregate jump function from file.\n+\t(ipa_agg_value::equal_to): Migrate from ipa_agg_jf_item::equal_to.\n+\t* ipa-cp.c (ipa_get_jf_arith_result): New function.\n+\t(ipa_agg_value_from_node): Likewise.\n+\t(ipa_agg_value_set_from_jfunc): Likewise.\n+\t(propagate_vals_across_arith_jfunc): Likewise.\n+\t(propagate_aggregate_lattice): Likewise.\n+\t(ipa_get_jf_pass_through_result): Call ipa_get_jf_arith_result.\n+\t(propagate_vals_across_pass_through): Call\n+\tpropagate_vals_across_arith_jfunc.\n+\t(get_clone_agg_value): Move forward.\n+\t(propagate_aggs_across_jump_function): Handle value propagation for\n+\taggregate jump function.\n+\t(agg_jmp_p_vec_for_t_vec): Remove.\n+\t(context_independent_aggregate_values): Replace vec<ipa_agg_jf_item>\n+\twith vec<ipa_agg_value>.\n+\t(copy_plats_to_inter, intersect_with_plats): Likewise.\n+\t(agg_replacements_to_vector, intersect_with_agg_replacements): Likewise.\n+\t(intersect_aggregate_with_edge): Likewise.\n+\t(find_aggregate_values_for_callers_subset): Likewise.\n+\t(cgraph_edge_brings_all_agg_vals_for_node): Likewise.\n+\t(estimate_local_effects): Replace vec<ipa_agg_jump_function> and\n+\tvec<ipa_agg_jump_function_p> with vec<ipa_agg_value_set>.\n+\t(gather_context_independent_values): Likewise.\n+\t(perform_estimation_of_a_value, decide_whether_version_node): Likewise.\n+\t* ipa-fnsummary.c (evaluate_conditions_for_known_args): Replace\n+\tvec<ipa_agg_jump_function_p> with vec<ipa_agg_value_set>.\n+\t(evaluate_properties_for_edge): Likewise.\n+\t(estimate_edge_devirt_benefit): Likewise.\n+\t(estimate_edge_size_and_time):  Likewise.\n+\t(estimate_calls_size_and_time): Likewise.\n+\t(ipa_call_context::ipa_call_context): Likewise.\n+\t(estimate_ipcp_clone_size_and_time):  Likewise.\n+\t* ipa-fnsummary.h (ipa_call_context): Replace\n+\tvec<ipa_agg_jump_function_p> with vec<ipa_agg_value_set>.\n+\t* ipa-inline-analysis.c (do_estimate_edge_time): Replace\n+\tvec<ipa_agg_jump_function_p> with vec<ipa_agg_value_set>.\n+\t(do_estimate_edge_size): Likewise.\n+\t(do_estimate_edge_hints): Likewise.\n+\n 2019-11-13  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-cp.c (propagate_vr_across_jump_function): Propagate also across"}, {"sha": "f0d354b3704cbde3286ee0ab3d8cbeed2fc7b4e8", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 362, "deletions": 136, "changes": 498, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb270950acbae6f70e3487a6e63a26c1294656b3/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb270950acbae6f70e3487a6e63a26c1294656b3/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=eb270950acbae6f70e3487a6e63a26c1294656b3", "patch": "@@ -1287,23 +1287,23 @@ initialize_node_lattices (struct cgraph_node *node)\n       }\n }\n \n-/* Return the result of a (possibly arithmetic) pass through jump function\n-   JFUNC on the constant value INPUT.  RES_TYPE is the type of the parameter\n-   to which the result is passed.  Return NULL_TREE if that cannot be\n-   determined or be considered an interprocedural invariant.  */\n+/* Return the result of a (possibly arithmetic) operation on the constant\n+   value INPUT.  OPERAND is 2nd operand for binary operation.  RES_TYPE is\n+   the type of the parameter to which the result is passed.  Return\n+   NULL_TREE if that cannot be determined or be considered an\n+   interprocedural invariant.  */\n \n static tree\n-ipa_get_jf_pass_through_result (struct ipa_jump_func *jfunc, tree input,\n-\t\t\t\ttree res_type)\n+ipa_get_jf_arith_result (enum tree_code opcode, tree input, tree operand,\n+\t\t\t tree res_type)\n {\n   tree res;\n \n-  if (ipa_get_jf_pass_through_operation (jfunc) == NOP_EXPR)\n+  if (opcode == NOP_EXPR)\n     return input;\n   if (!is_gimple_ip_invariant (input))\n     return NULL_TREE;\n \n-  tree_code opcode = ipa_get_jf_pass_through_operation (jfunc);\n   if (!res_type)\n     {\n       if (TREE_CODE_CLASS (opcode) == tcc_comparison)\n@@ -1317,15 +1317,29 @@ ipa_get_jf_pass_through_result (struct ipa_jump_func *jfunc, tree input,\n   if (TREE_CODE_CLASS (opcode) == tcc_unary)\n     res = fold_unary (opcode, res_type, input);\n   else\n-    res = fold_binary (opcode, res_type, input,\n-\t\t       ipa_get_jf_pass_through_operand (jfunc));\n+    res = fold_binary (opcode, res_type, input, operand);\n \n   if (res && !is_gimple_ip_invariant (res))\n     return NULL_TREE;\n \n   return res;\n }\n \n+/* Return the result of a (possibly arithmetic) pass through jump function\n+   JFUNC on the constant value INPUT.  RES_TYPE is the type of the parameter\n+   to which the result is passed.  Return NULL_TREE if that cannot be\n+   determined or be considered an interprocedural invariant.  */\n+\n+static tree\n+ipa_get_jf_pass_through_result (struct ipa_jump_func *jfunc, tree input,\n+\t\t\t\ttree res_type)\n+{\n+  return ipa_get_jf_arith_result (ipa_get_jf_pass_through_operation (jfunc),\n+\t\t\t\t  input,\n+\t\t\t\t  ipa_get_jf_pass_through_operand (jfunc),\n+\t\t\t\t  res_type);\n+}\n+\n /* Return the result of an ancestor jump function JFUNC on the constant value\n    INPUT.  Return NULL_TREE if that cannot be determined.  */\n \n@@ -1459,6 +1473,146 @@ ipa_context_from_jfunc (ipa_node_params *info, cgraph_edge *cs, int csidx,\n   return ctx;\n }\n \n+/* See if NODE is a clone with a known aggregate value at a given OFFSET of a\n+   parameter with the given INDEX.  */\n+\n+static tree\n+get_clone_agg_value (struct cgraph_node *node, HOST_WIDE_INT offset,\n+\t\t     int index)\n+{\n+  struct ipa_agg_replacement_value *aggval;\n+\n+  aggval = ipa_get_agg_replacements_for_node (node);\n+  while (aggval)\n+    {\n+      if (aggval->offset == offset\n+\t  && aggval->index == index)\n+\treturn aggval->value;\n+      aggval = aggval->next;\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Determine whether ITEM, jump function for an aggregate part, evaluates to a\n+   single known constant value and if so, return it.  Otherwise return NULL.\n+   NODE and INFO describes the caller node or the one it is inlined to, and\n+   its related info.  */\n+\n+static tree\n+ipa_agg_value_from_node (class ipa_node_params *info,\n+\t\t\t struct cgraph_node *node,\n+\t\t\t struct ipa_agg_jf_item *item)\n+{\n+  tree value = NULL_TREE;\n+  int src_idx;\n+\n+  if (item->offset < 0 || item->jftype == IPA_JF_UNKNOWN)\n+    return NULL_TREE;\n+\n+  if (item->jftype == IPA_JF_CONST)\n+    return item->value.constant;\n+\n+  gcc_checking_assert (item->jftype == IPA_JF_PASS_THROUGH\n+\t\t       || item->jftype == IPA_JF_LOAD_AGG);\n+\n+  src_idx = item->value.pass_through.formal_id;\n+\n+  if (info->ipcp_orig_node)\n+    {\n+      if (item->jftype == IPA_JF_PASS_THROUGH)\n+\tvalue = info->known_csts[src_idx];\n+      else\n+\tvalue = get_clone_agg_value (node, item->value.load_agg.offset,\n+\t\t\t\t     src_idx);\n+    }\n+  else if (info->lattices)\n+    {\n+      class ipcp_param_lattices *src_plats\n+\t= ipa_get_parm_lattices (info, src_idx);\n+\n+      if (item->jftype == IPA_JF_PASS_THROUGH)\n+\t{\n+\t  struct ipcp_lattice<tree> *lat = &src_plats->itself;\n+\n+\t  if (!lat->is_single_const ())\n+\t    return NULL_TREE;\n+\n+\t  value = lat->values->value;\n+\t}\n+      else if (src_plats->aggs\n+\t       && !src_plats->aggs_bottom\n+\t       && !src_plats->aggs_contain_variable\n+\t       && src_plats->aggs_by_ref == item->value.load_agg.by_ref)\n+\t{\n+\t  struct ipcp_agg_lattice *aglat;\n+\n+\t  for (aglat = src_plats->aggs; aglat; aglat = aglat->next)\n+\t    {\n+\t      if (aglat->offset > item->value.load_agg.offset)\n+\t\tbreak;\n+\n+\t      if (aglat->offset == item->value.load_agg.offset)\n+\t\t{\n+\t\t  if (aglat->is_single_const ())\n+\t\t    value = aglat->values->value;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  if (!value)\n+    return NULL_TREE;\n+\n+  if (item->jftype == IPA_JF_LOAD_AGG)\n+    {\n+      tree load_type = item->value.load_agg.type;\n+      tree value_type = TREE_TYPE (value);\n+\n+      /* Ensure value type is compatible with load type.  */\n+      if (!useless_type_conversion_p (load_type, value_type))\n+\treturn NULL_TREE;\n+    }\n+\n+  return ipa_get_jf_arith_result (item->value.pass_through.operation,\n+\t\t\t\t  value,\n+\t\t\t\t  item->value.pass_through.operand,\n+\t\t\t\t  item->type);\n+}\n+\n+/* Determine whether AGG_JFUNC evaluates to a set of known constant value for\n+   an aggregate and if so, return it.  Otherwise return an empty set.  NODE\n+   and INFO describes the caller node or the one it is inlined to, and its\n+   related info.  */\n+\n+struct ipa_agg_value_set\n+ipa_agg_value_set_from_jfunc (class ipa_node_params *info, cgraph_node *node,\n+\t\t\t      struct ipa_agg_jump_function *agg_jfunc)\n+{\n+  struct ipa_agg_value_set agg;\n+  struct ipa_agg_jf_item *item;\n+  int i;\n+\n+  agg.items = vNULL;\n+  agg.by_ref = agg_jfunc->by_ref;\n+\n+  FOR_EACH_VEC_SAFE_ELT (agg_jfunc->items, i, item)\n+    {\n+      tree value = ipa_agg_value_from_node (info, node, item);\n+\n+      if (value)\n+\t{\n+\t  struct ipa_agg_value value_item;\n+\n+\t  value_item.offset = item->offset;\n+\t  value_item.value = value;\n+\n+\t  agg.items.safe_push (value_item);\n+\t}\n+    }\n+  return agg;\n+}\n+\n /* If checking is enabled, verify that no lattice is in the TOP state, i.e. not\n    bottom, not containing a variable component and without any known value at\n    the same time.  */\n@@ -1638,16 +1792,25 @@ ipcp_lattice<valtype>::add_value (valtype newval, cgraph_edge *cs,\n   return true;\n }\n \n-/* Propagate values through a pass-through jump function JFUNC associated with\n-   edge CS, taking values from SRC_LAT and putting them into DEST_LAT.  SRC_IDX\n-   is the index of the source parameter.  PARM_TYPE is the type of the\n-   parameter to which the result is passed.  */\n+/* Propagate values through an arithmetic transformation described by a jump\n+   function associated with edge CS, taking values from SRC_LAT and putting\n+   them into DEST_LAT.  OPND1_TYPE is expected type for the values in SRC_LAT.\n+   OPND2 is a constant value if transformation is a binary operation.\n+   SRC_OFFSET specifies offset in an aggregate if SRC_LAT describes lattice of\n+   a part of the aggregate.  SRC_IDX is the index of the source parameter.\n+   RES_TYPE is the value type of result being propagated into.  Return true if\n+   DEST_LAT changed.  */\n \n static bool\n-propagate_vals_across_pass_through (cgraph_edge *cs, ipa_jump_func *jfunc,\n-\t\t\t\t    ipcp_lattice<tree> *src_lat,\n-\t\t\t\t    ipcp_lattice<tree> *dest_lat, int src_idx,\n-\t\t\t\t    tree parm_type)\n+propagate_vals_across_arith_jfunc (cgraph_edge *cs,\n+\t\t\t\t   enum tree_code opcode,\n+\t\t\t\t   tree opnd1_type,\n+\t\t\t\t   tree opnd2,\n+\t\t\t\t   ipcp_lattice<tree> *src_lat,\n+\t\t\t\t   ipcp_lattice<tree> *dest_lat,\n+\t\t\t\t   HOST_WIDE_INT src_offset,\n+\t\t\t\t   int src_idx,\n+\t\t\t\t   tree res_type)\n {\n   ipcp_value<tree> *src_val;\n   bool ret = false;\n@@ -1657,24 +1820,47 @@ propagate_vals_across_pass_through (cgraph_edge *cs, ipa_jump_func *jfunc,\n      number of them and we would just make lattices bottom.  If this condition\n      is ever relaxed we have to detect self-feeding recursive calls in\n      cgraph_edge_brings_value_p in a smarter way.  */\n-  if ((ipa_get_jf_pass_through_operation (jfunc) != NOP_EXPR)\n-      && ipa_edge_within_scc (cs))\n+  if (opcode != NOP_EXPR && ipa_edge_within_scc (cs))\n     ret = dest_lat->set_contains_variable ();\n   else\n     for (src_val = src_lat->values; src_val; src_val = src_val->next)\n       {\n-\ttree cstval = ipa_get_jf_pass_through_result (jfunc, src_val->value,\n-\t\t\t\t\t\t      parm_type);\n+\ttree opnd1 = src_val->value;\n+\ttree cstval = NULL_TREE;\n+\n+\t/* Skip source values that is incompatible with specified type.  */\n+\tif (!opnd1_type\n+\t    || useless_type_conversion_p (opnd1_type, TREE_TYPE (opnd1)))\n+\t  cstval = ipa_get_jf_arith_result (opcode, opnd1, opnd2, res_type);\n \n \tif (cstval)\n-\t  ret |= dest_lat->add_value (cstval, cs, src_val, src_idx);\n+\t  ret |= dest_lat->add_value (cstval, cs, src_val, src_idx,\n+\t\t\t\t      src_offset);\n \telse\n \t  ret |= dest_lat->set_contains_variable ();\n       }\n \n   return ret;\n }\n \n+/* Propagate values through a pass-through jump function JFUNC associated with\n+   edge CS, taking values from SRC_LAT and putting them into DEST_LAT.  SRC_IDX\n+   is the index of the source parameter.  PARM_TYPE is the type of the\n+   parameter to which the result is passed.  */\n+\n+static bool\n+propagate_vals_across_pass_through (cgraph_edge *cs, ipa_jump_func *jfunc,\n+\t\t\t\t    ipcp_lattice<tree> *src_lat,\n+\t\t\t\t    ipcp_lattice<tree> *dest_lat, int src_idx,\n+\t\t\t\t    tree parm_type)\n+{\n+  return propagate_vals_across_arith_jfunc (cs,\n+\t\t\t\tipa_get_jf_pass_through_operation (jfunc),\n+\t\t\t\tNULL_TREE,\n+\t\t\t\tipa_get_jf_pass_through_operand (jfunc),\n+\t\t\t\tsrc_lat, dest_lat, -1, src_idx, parm_type);\n+}\n+\n /* Propagate values through an ancestor jump function JFUNC associated with\n    edge CS, taking values from SRC_LAT and putting them into DEST_LAT.  SRC_IDX\n    is the index of the source parameter.  */\n@@ -1835,7 +2021,6 @@ propagate_context_across_jump_function (cgraph_edge *cs,\n \t      added_sth = true;\n \t    }\n \t}\n-\n     }\n \n  prop_fail:\n@@ -2218,6 +2403,85 @@ agg_pass_through_permissible_p (class ipcp_param_lattices *src_plats,\n \t|| ipa_get_jf_pass_through_agg_preserved (jfunc));\n }\n \n+/* Propagate values through ITEM, jump function for a part of an aggregate,\n+   into corresponding aggregate lattice AGLAT.  CS is the call graph edge\n+   associated with the jump function.  Return true if AGLAT changed in any\n+   way.  */\n+\n+static bool\n+propagate_aggregate_lattice (struct cgraph_edge *cs,\n+\t\t\t     struct ipa_agg_jf_item *item,\n+\t\t\t     struct ipcp_agg_lattice *aglat)\n+{\n+  class ipa_node_params *caller_info;\n+  class ipcp_param_lattices *src_plats;\n+  struct ipcp_lattice<tree> *src_lat;\n+  HOST_WIDE_INT src_offset;\n+  int src_idx;\n+  tree load_type;\n+  bool ret;\n+\n+  if (item->jftype == IPA_JF_CONST)\n+    {\n+      tree value = item->value.constant;\n+\n+      gcc_checking_assert (is_gimple_ip_invariant (value));\n+      return aglat->add_value (value, cs, NULL, 0);\n+    }\n+\n+  gcc_checking_assert (item->jftype == IPA_JF_PASS_THROUGH\n+\t\t       || item->jftype == IPA_JF_LOAD_AGG);\n+\n+  caller_info = IPA_NODE_REF (cs->caller);\n+  src_idx = item->value.pass_through.formal_id;\n+  src_plats = ipa_get_parm_lattices (caller_info, src_idx);\n+\n+  if (item->jftype == IPA_JF_PASS_THROUGH)\n+    {\n+      load_type = NULL_TREE;\n+      src_lat = &src_plats->itself;\n+      src_offset = -1;\n+    }\n+  else\n+    {\n+      HOST_WIDE_INT load_offset = item->value.load_agg.offset;\n+      struct ipcp_agg_lattice *src_aglat;\n+\n+      for (src_aglat = src_plats->aggs; src_aglat; src_aglat = src_aglat->next)\n+\tif (src_aglat->offset >= load_offset)\n+\t  break;\n+\n+      load_type = item->value.load_agg.type;\n+      if (!src_aglat\n+\t  || src_aglat->offset > load_offset\n+\t  || src_aglat->size != tree_to_shwi (TYPE_SIZE (load_type))\n+\t  || src_plats->aggs_by_ref != item->value.load_agg.by_ref)\n+\treturn aglat->set_contains_variable ();\n+\n+      src_lat = src_aglat;\n+      src_offset = load_offset;\n+    }\n+\n+  if (src_lat->bottom\n+      || (!ipcp_versionable_function_p (cs->caller)\n+\t  && !src_lat->is_single_const ()))\n+    return aglat->set_contains_variable ();\n+\n+  ret = propagate_vals_across_arith_jfunc (cs,\n+\t\t\t\t\t   item->value.pass_through.operation,\n+\t\t\t\t\t   load_type,\n+\t\t\t\t\t   item->value.pass_through.operand,\n+\t\t\t\t\t   src_lat, aglat,\n+\t\t\t\t\t   src_offset,\n+\t\t\t\t\t   src_idx,\n+\t\t\t\t\t   item->type);\n+\n+  if (src_lat->contains_variable)\n+    ret |= aglat->set_contains_variable ();\n+\n+  return ret;\n+}\n+\n /* Propagate scalar values across jump function JFUNC that is associated with\n    edge CS and put the values into DEST_LAT.  */\n \n@@ -2285,15 +2549,14 @@ propagate_aggs_across_jump_function (struct cgraph_edge *cs,\n \t{\n \t  HOST_WIDE_INT val_size;\n \n-\t  if (item->offset < 0)\n+\t  if (item->offset < 0 || item->jftype == IPA_JF_UNKNOWN)\n \t    continue;\n-\t  gcc_checking_assert (is_gimple_ip_invariant (item->value));\n-\t  val_size = tree_to_uhwi (TYPE_SIZE (TREE_TYPE (item->value)));\n+\t  val_size = tree_to_shwi (TYPE_SIZE (item->type));\n \n \t  if (merge_agg_lats_step (dest_plats, item->offset, val_size,\n \t\t\t\t   &aglat, pre_existing, &ret))\n \t    {\n-\t      ret |= (*aglat)->add_value (item->value, cs, NULL, 0, 0);\n+\t      ret |= propagate_aggregate_lattice (cs, item, *aglat);\n \t      aglat = &(*aglat)->next;\n \t    }\n \t  else if (dest_plats->aggs_bottom)\n@@ -2410,7 +2673,7 @@ static tree\n ipa_get_indirect_edge_target_1 (struct cgraph_edge *ie,\n \t\t\t\tvec<tree> known_csts,\n \t\t\t\tvec<ipa_polymorphic_call_context> known_contexts,\n-\t\t\t\tvec<ipa_agg_jump_function_p> known_aggs,\n+\t\t\t\tvec<ipa_agg_value_set> known_aggs,\n \t\t\t\tstruct ipa_agg_replacement_value *agg_reps,\n \t\t\t\tbool *speculative)\n {\n@@ -2448,9 +2711,9 @@ ipa_get_indirect_edge_target_1 (struct cgraph_edge *ie,\n \t    }\n \t  if (!t)\n \t    {\n-\t      struct ipa_agg_jump_function *agg;\n+\t      struct ipa_agg_value_set *agg;\n \t      if (known_aggs.length () > (unsigned int) param_index)\n-\t\tagg = known_aggs[param_index];\n+\t\tagg = &known_aggs[param_index];\n \t      else\n \t\tagg = NULL;\n \t      bool from_global_constant;\n@@ -2504,8 +2767,7 @@ ipa_get_indirect_edge_target_1 (struct cgraph_edge *ie,\n   if (!t && known_aggs.length () > (unsigned int) param_index\n       && !ie->indirect_info->by_ref)\n     {\n-      struct ipa_agg_jump_function *agg;\n-      agg = known_aggs[param_index];\n+      struct ipa_agg_value_set *agg = &known_aggs[param_index];\n       t = ipa_find_agg_cst_for_param (agg, known_csts[param_index],\n \t\t\t\t      ie->indirect_info->offset, true);\n     }\n@@ -2627,7 +2889,7 @@ tree\n ipa_get_indirect_edge_target (struct cgraph_edge *ie,\n \t\t\t      vec<tree> known_csts,\n \t\t\t      vec<ipa_polymorphic_call_context> known_contexts,\n-\t\t\t      vec<ipa_agg_jump_function_p> known_aggs,\n+\t\t\t      vec<ipa_agg_value_set> known_aggs,\n \t\t\t      bool *speculative)\n {\n   return ipa_get_indirect_edge_target_1 (ie, known_csts, known_contexts,\n@@ -2641,7 +2903,7 @@ static int\n devirtualization_time_bonus (struct cgraph_node *node,\n \t\t\t     vec<tree> known_csts,\n \t\t\t     vec<ipa_polymorphic_call_context> known_contexts,\n-\t\t\t     vec<ipa_agg_jump_function_p> known_aggs)\n+\t\t\t     vec<ipa_agg_value_set> known_aggs)\n {\n   struct cgraph_edge *ie;\n   int res = 0;\n@@ -2776,25 +3038,25 @@ good_cloning_opportunity_p (struct cgraph_node *node, int time_benefit,\n /* Return all context independent values from aggregate lattices in PLATS in a\n    vector.  Return NULL if there are none.  */\n \n-static vec<ipa_agg_jf_item, va_gc> *\n+static vec<ipa_agg_value>\n context_independent_aggregate_values (class ipcp_param_lattices *plats)\n {\n-  vec<ipa_agg_jf_item, va_gc> *res = NULL;\n+  vec<ipa_agg_value> res = vNULL;\n \n   if (plats->aggs_bottom\n       || plats->aggs_contain_variable\n       || plats->aggs_count == 0)\n-    return NULL;\n+    return vNULL;\n \n   for (struct ipcp_agg_lattice *aglat = plats->aggs;\n        aglat;\n        aglat = aglat->next)\n     if (aglat->is_single_const ())\n       {\n-\tstruct ipa_agg_jf_item item;\n+\tstruct ipa_agg_value item;\n \titem.offset = aglat->offset;\n \titem.value = aglat->values->value;\n-\tvec_safe_push (res, item);\n+\tres.safe_push (item);\n       }\n   return res;\n }\n@@ -2810,7 +3072,7 @@ gather_context_independent_values (class ipa_node_params *info,\n \t\t\t\t   vec<tree> *known_csts,\n \t\t\t\t   vec<ipa_polymorphic_call_context>\n \t\t\t\t   *known_contexts,\n-\t\t\t\t   vec<ipa_agg_jump_function> *known_aggs,\n+\t\t\t\t   vec<ipa_agg_value_set> *known_aggs,\n \t\t\t\t   int *removable_params_cost)\n {\n   int i, count = ipa_get_param_count (info);\n@@ -2860,40 +3122,20 @@ gather_context_independent_values (class ipa_node_params *info,\n \n       if (known_aggs)\n \t{\n-\t  vec<ipa_agg_jf_item, va_gc> *agg_items;\n-\t  struct ipa_agg_jump_function *ajf;\n+\t  vec<ipa_agg_value> agg_items;\n+\t  struct ipa_agg_value_set *agg;\n \n \t  agg_items = context_independent_aggregate_values (plats);\n-\t  ajf = &(*known_aggs)[i];\n-\t  ajf->items = agg_items;\n-\t  ajf->by_ref = plats->aggs_by_ref;\n-\t  ret |= agg_items != NULL;\n+\t  agg = &(*known_aggs)[i];\n+\t  agg->items = agg_items;\n+\t  agg->by_ref = plats->aggs_by_ref;\n+\t  ret |= !agg_items.is_empty ();\n \t}\n     }\n \n   return ret;\n }\n \n-/* The current interface in ipa-inline-analysis requires a pointer vector.\n-   Create it.\n-\n-   FIXME: That interface should be re-worked, this is slightly silly.  Still,\n-   I'd like to discuss how to change it first and this demonstrates the\n-   issue.  */\n-\n-static vec<ipa_agg_jump_function_p>\n-agg_jmp_p_vec_for_t_vec (vec<ipa_agg_jump_function> known_aggs)\n-{\n-  vec<ipa_agg_jump_function_p> ret;\n-  struct ipa_agg_jump_function *ajf;\n-  int i;\n-\n-  ret.create (known_aggs.length ());\n-  FOR_EACH_VEC_ELT (known_aggs, i, ajf)\n-    ret.quick_push (ajf);\n-  return ret;\n-}\n-\n /* Perform time and size measurement of NODE with the context given in\n    KNOWN_CSTS, KNOWN_CONTEXTS and KNOWN_AGGS, calculate the benefit and cost\n    given BASE_TIME of the node without specialization, REMOVABLE_PARAMS_COST of\n@@ -2903,7 +3145,7 @@ agg_jmp_p_vec_for_t_vec (vec<ipa_agg_jump_function> known_aggs)\n static void\n perform_estimation_of_a_value (cgraph_node *node, vec<tree> known_csts,\n \t\t\t       vec<ipa_polymorphic_call_context> known_contexts,\n-\t\t\t       vec<ipa_agg_jump_function_p> known_aggs_ptrs,\n+\t\t\t       vec<ipa_agg_value_set> known_aggs,\n \t\t\t       int removable_params_cost,\n \t\t\t       int est_move_cost, ipcp_value_base *val)\n {\n@@ -2912,7 +3154,7 @@ perform_estimation_of_a_value (cgraph_node *node, vec<tree> known_csts,\n   ipa_hints hints;\n \n   estimate_ipcp_clone_size_and_time (node, known_csts, known_contexts,\n-\t\t\t\t     known_aggs_ptrs, &size, &time,\n+\t\t\t\t     known_aggs, &size, &time,\n \t\t\t\t     &base_time, &hints);\n   base_time -= time;\n   if (base_time > 65535)\n@@ -2926,7 +3168,7 @@ perform_estimation_of_a_value (cgraph_node *node, vec<tree> known_csts,\n   else\n     time_benefit = base_time.to_int ()\n       + devirtualization_time_bonus (node, known_csts, known_contexts,\n-\t\t\t\t     known_aggs_ptrs)\n+\t\t\t\t     known_aggs)\n       + hint_time_bonus (hints)\n       + removable_params_cost + est_move_cost;\n \n@@ -2952,8 +3194,7 @@ estimate_local_effects (struct cgraph_node *node)\n   int i, count = ipa_get_param_count (info);\n   vec<tree> known_csts;\n   vec<ipa_polymorphic_call_context> known_contexts;\n-  vec<ipa_agg_jump_function> known_aggs;\n-  vec<ipa_agg_jump_function_p> known_aggs_ptrs;\n+  vec<ipa_agg_value_set> known_aggs;\n   bool always_const;\n   int removable_params_cost;\n \n@@ -2966,9 +3207,8 @@ estimate_local_effects (struct cgraph_node *node)\n   always_const = gather_context_independent_values (info, &known_csts,\n \t\t\t\t\t\t    &known_contexts, &known_aggs,\n \t\t\t\t\t\t    &removable_params_cost);\n-  known_aggs_ptrs = agg_jmp_p_vec_for_t_vec (known_aggs);\n   int devirt_bonus = devirtualization_time_bonus (node, known_csts,\n-\t\t\t\t\t   known_contexts, known_aggs_ptrs);\n+\t\t\t\t\t   known_contexts, known_aggs);\n   if (always_const || devirt_bonus\n       || (removable_params_cost && node->can_change_signature))\n     {\n@@ -2981,7 +3221,7 @@ estimate_local_effects (struct cgraph_node *node)\n       node->call_for_symbol_thunks_and_aliases (gather_caller_stats, &stats,\n \t\t\t\t\t      false);\n       estimate_ipcp_clone_size_and_time (node, known_csts, known_contexts,\n-\t\t\t\t\t known_aggs_ptrs, &size, &time,\n+\t\t\t\t\t known_aggs, &size, &time,\n \t\t\t\t\t &base_time, &hints);\n       time -= devirt_bonus;\n       time -= hint_time_bonus (hints);\n@@ -3044,7 +3284,7 @@ estimate_local_effects (struct cgraph_node *node)\n \n \t  int emc = estimate_move_cost (TREE_TYPE (val->value), true);\n \t  perform_estimation_of_a_value (node, known_csts, known_contexts,\n-\t\t\t\t\t known_aggs_ptrs,\n+\t\t\t\t\t known_aggs,\n \t\t\t\t\t removable_params_cost, emc, val);\n \n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -3079,7 +3319,7 @@ estimate_local_effects (struct cgraph_node *node)\n \t{\n \t  known_contexts[i] = val->value;\n \t  perform_estimation_of_a_value (node, known_csts, known_contexts,\n-\t\t\t\t\t known_aggs_ptrs,\n+\t\t\t\t\t known_aggs,\n \t\t\t\t\t removable_params_cost, 0, val);\n \n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -3098,13 +3338,13 @@ estimate_local_effects (struct cgraph_node *node)\n   for (i = 0; i < count; i++)\n     {\n       class ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n-      struct ipa_agg_jump_function *ajf;\n+      struct ipa_agg_value_set *agg;\n       struct ipcp_agg_lattice *aglat;\n \n       if (plats->aggs_bottom || !plats->aggs)\n \tcontinue;\n \n-      ajf = &known_aggs[i];\n+      agg = &known_aggs[i];\n       for (aglat = plats->aggs; aglat; aglat = aglat->next)\n \t{\n \t  ipcp_value<tree> *val;\n@@ -3116,14 +3356,14 @@ estimate_local_effects (struct cgraph_node *node)\n \n \t  for (val = aglat->values; val; val = val->next)\n \t    {\n-\t      struct ipa_agg_jf_item item;\n+\t      struct ipa_agg_value item;\n \n \t      item.offset = aglat->offset;\n \t      item.value = val->value;\n-\t      vec_safe_push (ajf->items, item);\n+\t      agg->items.safe_push (item);\n \n \t      perform_estimation_of_a_value (node, known_csts, known_contexts,\n-\t\t\t\t\t     known_aggs_ptrs,\n+\t\t\t\t\t     known_aggs,\n \t\t\t\t\t     removable_params_cost, 0, val);\n \n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -3139,18 +3379,14 @@ estimate_local_effects (struct cgraph_node *node)\n \t\t\t   val->local_time_benefit, val->local_size_cost);\n \t\t}\n \n-\t      ajf->items->pop ();\n+\t      agg->items.pop ();\n \t    }\n \t}\n     }\n \n-  for (i = 0; i < count; i++)\n-    vec_free (known_aggs[i].items);\n-\n   known_csts.release ();\n   known_contexts.release ();\n-  known_aggs.release ();\n-  known_aggs_ptrs.release ();\n+  ipa_release_agg_values (known_aggs);\n }\n \n \n@@ -3532,26 +3768,6 @@ edge_clone_summary_t::duplicate (cgraph_edge *src_edge, cgraph_edge *dst_edge,\n   src_data->next_clone = dst_edge;\n }\n \n-/* See if NODE is a clone with a known aggregate value at a given OFFSET of a\n-   parameter with the given INDEX.  */\n-\n-static tree\n-get_clone_agg_value (struct cgraph_node *node, HOST_WIDE_INT offset,\n-\t\t     int index)\n-{\n-  struct ipa_agg_replacement_value *aggval;\n-\n-  aggval = ipa_get_agg_replacements_for_node (node);\n-  while (aggval)\n-    {\n-      if (aggval->offset == offset\n-\t  && aggval->index == index)\n-\treturn aggval->value;\n-      aggval = aggval->next;\n-    }\n-  return NULL_TREE;\n-}\n-\n /* Return true is NODE is DEST or its clone for all contexts.  */\n \n static bool\n@@ -4237,18 +4453,18 @@ find_more_contexts_for_caller_subset (cgraph_node *node,\n /* Go through PLATS and create a vector of values consisting of values and\n    offsets (minus OFFSET) of lattices that contain only a single value.  */\n \n-static vec<ipa_agg_jf_item>\n+static vec<ipa_agg_value>\n copy_plats_to_inter (class ipcp_param_lattices *plats, HOST_WIDE_INT offset)\n {\n-  vec<ipa_agg_jf_item> res = vNULL;\n+  vec<ipa_agg_value> res = vNULL;\n \n   if (!plats->aggs || plats->aggs_contain_variable || plats->aggs_bottom)\n     return vNULL;\n \n   for (struct ipcp_agg_lattice *aglat = plats->aggs; aglat; aglat = aglat->next)\n     if (aglat->is_single_const ())\n       {\n-\tstruct ipa_agg_jf_item ti;\n+\tstruct ipa_agg_value ti;\n \tti.offset = aglat->offset - offset;\n \tti.value = aglat->values->value;\n \tres.safe_push (ti);\n@@ -4261,11 +4477,11 @@ copy_plats_to_inter (class ipcp_param_lattices *plats, HOST_WIDE_INT offset)\n \n static void\n intersect_with_plats (class ipcp_param_lattices *plats,\n-\t\t      vec<ipa_agg_jf_item> *inter,\n+\t\t      vec<ipa_agg_value> *inter,\n \t\t      HOST_WIDE_INT offset)\n {\n   struct ipcp_agg_lattice *aglat;\n-  struct ipa_agg_jf_item *item;\n+  struct ipa_agg_value *item;\n   int k;\n \n   if (!plats->aggs || plats->aggs_contain_variable || plats->aggs_bottom)\n@@ -4303,18 +4519,18 @@ intersect_with_plats (class ipcp_param_lattices *plats,\n /* Copy aggregate replacement values of NODE (which is an IPA-CP clone) to the\n    vector result while subtracting OFFSET from the individual value offsets.  */\n \n-static vec<ipa_agg_jf_item>\n+static vec<ipa_agg_value>\n agg_replacements_to_vector (struct cgraph_node *node, int index,\n \t\t\t    HOST_WIDE_INT offset)\n {\n   struct ipa_agg_replacement_value *av;\n-  vec<ipa_agg_jf_item> res = vNULL;\n+  vec<ipa_agg_value> res = vNULL;\n \n   for (av = ipa_get_agg_replacements_for_node (node); av; av = av->next)\n     if (av->index == index\n \t&& (av->offset - offset) >= 0)\n     {\n-      struct ipa_agg_jf_item item;\n+      struct ipa_agg_value item;\n       gcc_checking_assert (av->value);\n       item.offset = av->offset - offset;\n       item.value = av->value;\n@@ -4330,11 +4546,11 @@ agg_replacements_to_vector (struct cgraph_node *node, int index,\n \n static void\n intersect_with_agg_replacements (struct cgraph_node *node, int index,\n-\t\t\t\t vec<ipa_agg_jf_item> *inter,\n+\t\t\t\t vec<ipa_agg_value> *inter,\n \t\t\t\t HOST_WIDE_INT offset)\n {\n   struct ipa_agg_replacement_value *srcvals;\n-  struct ipa_agg_jf_item *item;\n+  struct ipa_agg_value *item;\n   int i;\n \n   srcvals = ipa_get_agg_replacements_for_node (node);\n@@ -4371,9 +4587,9 @@ intersect_with_agg_replacements (struct cgraph_node *node, int index,\n    copy all incoming values to it.  If we determine we ended up with no values\n    whatsoever, return a released vector.  */\n \n-static vec<ipa_agg_jf_item>\n+static vec<ipa_agg_value>\n intersect_aggregates_with_edge (struct cgraph_edge *cs, int index,\n-\t\t\t\tvec<ipa_agg_jf_item> inter)\n+\t\t\t\tvec<ipa_agg_value> inter)\n {\n   struct ipa_jump_func *jfunc;\n   jfunc = ipa_get_ith_jump_func (IPA_EDGE_REF (cs), index);\n@@ -4454,12 +4670,26 @@ intersect_aggregates_with_edge (struct cgraph_edge *cs, int index,\n     }\n   else if (jfunc->agg.items)\n     {\n-      struct ipa_agg_jf_item *item;\n+      class ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n+      struct ipa_agg_value *item;\n       int k;\n \n       if (!inter.exists ())\n \tfor (unsigned i = 0; i < jfunc->agg.items->length (); i++)\n-\t  inter.safe_push ((*jfunc->agg.items)[i]);\n+\t  {\n+\t    struct ipa_agg_jf_item *agg_item = &(*jfunc->agg.items)[i];\n+\t    tree value = ipa_agg_value_from_node (caller_info, cs->caller,\n+\t\t\t\t\t\t  agg_item);\n+\t    if (value)\n+\t      {\n+\t\tstruct ipa_agg_value agg_value;\n+\n+\t\tagg_value.offset = agg_item->offset;\n+\t\tagg_value.value = value;\n+\n+\t\tinter.safe_push (agg_value);\n+\t      }\n+\t  }\n       else\n \tFOR_EACH_VEC_ELT (inter, k, item)\n \t  {\n@@ -4477,9 +4707,10 @@ intersect_aggregates_with_edge (struct cgraph_edge *cs, int index,\n \t\t  break;\n \t\tif (ti->offset == item->offset)\n \t\t  {\n-\t\t    gcc_checking_assert (ti->value);\n-\t\t    if (values_equal_for_ipcp_p (item->value,\n-\t\t\t\t\t\t ti->value))\n+\t\t    tree value = ipa_agg_value_from_node (caller_info,\n+\t\t\t\t\t\t\t  cs->caller, ti);\n+\t\t    if (value\n+\t\t\t&& values_equal_for_ipcp_p (item->value, value))\n \t\t      found = true;\n \t\t    break;\n \t\t  }\n@@ -4492,7 +4723,7 @@ intersect_aggregates_with_edge (struct cgraph_edge *cs, int index,\n   else\n     {\n       inter.release ();\n-      return vec<ipa_agg_jf_item>();\n+      return vNULL;\n     }\n   return inter;\n }\n@@ -4525,8 +4756,8 @@ find_aggregate_values_for_callers_subset (struct cgraph_node *node,\n   for (i = 0; i < count; i++)\n     {\n       struct cgraph_edge *cs;\n-      vec<ipa_agg_jf_item> inter = vNULL;\n-      struct ipa_agg_jf_item *item;\n+      vec<ipa_agg_value> inter = vNULL;\n+      struct ipa_agg_value *item;\n       class ipcp_param_lattices *plats = ipa_get_parm_lattices (dest_info, i);\n       int j;\n \n@@ -4633,7 +4864,7 @@ cgraph_edge_brings_all_agg_vals_for_node (struct cgraph_edge *cs,\n \n   for (i = 0; i < count; i++)\n     {\n-      static vec<ipa_agg_jf_item> values = vec<ipa_agg_jf_item>();\n+      static vec<ipa_agg_value> values = vNULL;\n       class ipcp_param_lattices *plats;\n       bool interesting = false;\n       for (struct ipa_agg_replacement_value *av = aggval; av; av = av->next)\n@@ -4656,7 +4887,7 @@ cgraph_edge_brings_all_agg_vals_for_node (struct cgraph_edge *cs,\n       for (struct ipa_agg_replacement_value *av = aggval; av; av = av->next)\n \tif (aggval->index == i)\n \t  {\n-\t    struct ipa_agg_jf_item *item;\n+\t    struct ipa_agg_value *item;\n \t    int j;\n \t    bool found = false;\n \t    FOR_EACH_VEC_ELT (values, j, item)\n@@ -4894,7 +5125,6 @@ decide_whether_version_node (struct cgraph_node *node)\n   int i, count = ipa_get_param_count (info);\n   vec<tree> known_csts;\n   vec<ipa_polymorphic_call_context> known_contexts;\n-  vec<ipa_agg_jump_function> known_aggs = vNULL;\n   bool ret = false;\n \n   if (count == 0)\n@@ -4905,8 +5135,7 @@ decide_whether_version_node (struct cgraph_node *node)\n \t     node->dump_name ());\n \n   gather_context_independent_values (info, &known_csts, &known_contexts,\n-\t\t\t\t  info->do_clone_for_all_contexts ? &known_aggs\n-\t\t\t\t  : NULL, NULL);\n+\t\t\t\t     NULL, NULL);\n \n   for (i = 0; i < count;i++)\n     {\n@@ -4975,9 +5204,6 @@ decide_whether_version_node (struct cgraph_node *node)\n       info = IPA_NODE_REF (node);\n       info->do_clone_for_all_contexts = false;\n       IPA_NODE_REF (clone)->is_all_contexts_clone = true;\n-      for (i = 0; i < count; i++)\n-\tvec_free (known_aggs[i].items);\n-      known_aggs.release ();\n       ret = true;\n     }\n   else"}, {"sha": "11879335990327696c4d6e7d4feca6a904c756c5", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 32, "deletions": 29, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb270950acbae6f70e3487a6e63a26c1294656b3/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb270950acbae6f70e3487a6e63a26c1294656b3/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=eb270950acbae6f70e3487a6e63a26c1294656b3", "patch": "@@ -306,18 +306,17 @@ set_hint_predicate (predicate **p, predicate new_predicate)\n    the fact that parameter is indeed a constant.\n \n    KNOWN_VALS is partial mapping of parameters of NODE to constant values.\n-   KNOWN_AGGS is a vector of aggreggate jump functions for each parameter.\n-   Return clause of possible truths. When INLINE_P is true, assume that we are\n-   inlining.\n+   KNOWN_AGGS is a vector of aggreggate known offset/value set for each\n+   parameter.  Return clause of possible truths.  When INLINE_P is true, assume\n+   that we are inlining.\n \n    ERROR_MARK means compile time invariant.  */\n \n static void\n evaluate_conditions_for_known_args (struct cgraph_node *node,\n \t\t\t\t    bool inline_p,\n \t\t\t\t    vec<tree> known_vals,\n-\t\t\t\t    vec<ipa_agg_jump_function_p>\n-\t\t\t\t    known_aggs,\n+\t\t\t\t    vec<ipa_agg_value_set> known_aggs,\n \t\t\t\t    clause_t *ret_clause,\n \t\t\t\t    clause_t *ret_nonspec_clause)\n {\n@@ -349,7 +348,7 @@ evaluate_conditions_for_known_args (struct cgraph_node *node,\n \n       if (c->agg_contents)\n \t{\n-\t  struct ipa_agg_jump_function *agg;\n+\t  struct ipa_agg_value_set *agg;\n \n \t  if (c->code == predicate::changed\n \t      && !c->by_ref\n@@ -358,7 +357,7 @@ evaluate_conditions_for_known_args (struct cgraph_node *node,\n \n \t  if (known_aggs.exists ())\n \t    {\n-\t      agg = known_aggs[c->operand_num];\n+\t      agg = &known_aggs[c->operand_num];\n \t      val = ipa_find_agg_cst_for_param (agg, known_vals[c->operand_num],\n \t\t\t\t\t\tc->offset, c->by_ref);\n \t    }\n@@ -445,12 +444,12 @@ evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n \t\t\t      vec<tree> *known_vals_ptr,\n \t\t\t      vec<ipa_polymorphic_call_context>\n \t\t\t      *known_contexts_ptr,\n-\t\t\t      vec<ipa_agg_jump_function_p> *known_aggs_ptr)\n+\t\t\t      vec<ipa_agg_value_set> *known_aggs_ptr)\n {\n   struct cgraph_node *callee = e->callee->ultimate_alias_target ();\n   class ipa_fn_summary *info = ipa_fn_summaries->get (callee);\n   vec<tree> known_vals = vNULL;\n-  vec<ipa_agg_jump_function_p> known_aggs = vNULL;\n+  vec<ipa_agg_value_set> known_aggs = vNULL;\n   class ipa_edge_args *args;\n \n   if (clause_ptr)\n@@ -465,14 +464,16 @@ evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n       && ((clause_ptr && info->conds) || known_vals_ptr || known_contexts_ptr)\n       && (args = IPA_EDGE_REF (e)) != NULL)\n     {\n+      struct cgraph_node *caller;\n       class ipa_node_params *caller_parms_info, *callee_pi;\n       class ipa_call_summary *es = ipa_call_summaries->get (e);\n       int i, count = ipa_get_cs_argument_count (args);\n \n       if (e->caller->inlined_to)\n-\tcaller_parms_info = IPA_NODE_REF (e->caller->inlined_to);\n+\tcaller = e->caller->inlined_to;\n       else\n-\tcaller_parms_info = IPA_NODE_REF (e->caller);\n+\tcaller = e->caller;\n+      caller_parms_info = IPA_NODE_REF (caller);\n       callee_pi = IPA_NODE_REF (callee);\n \n       if (count && (info->conds || known_vals_ptr))\n@@ -508,10 +509,9 @@ evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n \t    if (known_contexts_ptr)\n \t      (*known_contexts_ptr)[i]\n \t\t= ipa_context_from_jfunc (caller_parms_info, e, i, jf);\n-\t    /* TODO: When IPA-CP starts propagating and merging aggregate jump\n-\t       functions, use its knowledge of the caller too, just like the\n-\t       scalar case above.  */\n-\t    known_aggs[i] = &jf->agg;\n+\t\n+\t    known_aggs[i] = ipa_agg_value_set_from_jfunc (caller_parms_info,\n+\t\t\t\t\t\t\t  caller, &jf->agg);\n \t  }\n \telse\n \t  gcc_assert (callee->thunk.thunk_p);\n@@ -545,7 +545,7 @@ evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n   if (known_aggs_ptr)\n     *known_aggs_ptr = known_aggs;\n   else\n-    known_aggs.release ();\n+    ipa_release_agg_values (known_aggs);\n }\n \n \n@@ -2838,7 +2838,7 @@ estimate_edge_devirt_benefit (struct cgraph_edge *ie,\n \t\t\t      int *size, int *time,\n \t\t\t      vec<tree> known_vals,\n \t\t\t      vec<ipa_polymorphic_call_context> known_contexts,\n-\t\t\t      vec<ipa_agg_jump_function_p> known_aggs)\n+\t\t\t      vec<ipa_agg_value_set> known_aggs)\n {\n   tree target;\n   struct cgraph_node *callee;\n@@ -2887,7 +2887,7 @@ estimate_edge_size_and_time (struct cgraph_edge *e, int *size, int *min_size,\n \t\t\t     int prob,\n \t\t\t     vec<tree> known_vals,\n \t\t\t     vec<ipa_polymorphic_call_context> known_contexts,\n-\t\t\t     vec<ipa_agg_jump_function_p> known_aggs,\n+\t\t\t     vec<ipa_agg_value_set> known_aggs,\n \t\t\t     ipa_hints *hints)\n {\n   class ipa_call_summary *es = ipa_call_summaries->get (e);\n@@ -2923,7 +2923,7 @@ estimate_calls_size_and_time (struct cgraph_node *node, int *size,\n \t\t\t      clause_t possible_truths,\n \t\t\t      vec<tree> known_vals,\n \t\t\t      vec<ipa_polymorphic_call_context> known_contexts,\n-\t\t\t      vec<ipa_agg_jump_function_p> known_aggs)\n+\t\t\t      vec<ipa_agg_value_set> known_aggs)\n {\n   struct cgraph_edge *e;\n   for (e = node->callees; e; e = e->next_callee)\n@@ -2983,7 +2983,7 @@ ipa_call_context::ipa_call_context (cgraph_node *node,\n \t\t\t\t    vec<tree> known_vals,\n \t\t\t\t    vec<ipa_polymorphic_call_context>\n \t\t\t\t   \t known_contexts,\n-\t\t\t\t    vec<ipa_agg_jump_function_p> known_aggs,\n+\t\t\t\t    vec<ipa_agg_value_set> known_aggs,\n \t\t\t\t    vec<inline_param_summary>\n \t\t\t\t   \t inline_param_summary)\n : m_node (node), m_possible_truths (possible_truths),\n@@ -3057,9 +3057,9 @@ ipa_call_context::duplicate_from (const ipa_call_context &ctx)\n \n       for (unsigned int i = 0; i < n; i++)\n \tif (ipa_is_param_used_by_indirect_call (params_summary, i)\n-\t    && ctx.m_known_aggs[i])\n+\t    && !ctx.m_known_aggs[i].is_empty ())\n \t  {\n-\t    m_known_aggs = ctx.m_known_aggs.copy ();\n+\t    m_known_aggs = ipa_copy_agg_values (ctx.m_known_aggs);\n \t    break;\n \t  }\n     }\n@@ -3078,7 +3078,7 @@ ipa_call_context::release (bool all)\n     return;\n   m_known_vals.release ();\n   m_known_contexts.release ();\n-  m_known_aggs.release ();\n+  ipa_release_agg_values (m_known_aggs);\n   if (all)\n     m_inline_param_summary.release ();\n }\n@@ -3179,19 +3179,22 @@ ipa_call_context::equal_to (const ipa_call_context &ctx)\n \t{\n \t  if (!ipa_is_param_used_by_indirect_call (params_summary, i))\n \t    continue;\n-\t  if (i >= m_known_aggs.length () || !m_known_aggs[i])\n+\t  if (i >= m_known_aggs.length () || m_known_aggs[i].is_empty ())\n \t    {\n-\t      if (i < ctx.m_known_aggs.length () && ctx.m_known_aggs[i])\n+\t      if (i < ctx.m_known_aggs.length ()\n+\t\t  && !ctx.m_known_aggs[i].is_empty ())\n \t\treturn false;\n \t      continue;\n \t    }\n-\t  if (i >= ctx.m_known_aggs.length () || !ctx.m_known_aggs[i])\n+\t  if (i >= ctx.m_known_aggs.length ()\n+\t      || ctx.m_known_aggs[i].is_empty ())\n \t    {\n-\t      if (i < m_known_aggs.length () && m_known_aggs[i])\n+\t      if (i < m_known_aggs.length ()\n+\t\t  && !m_known_aggs[i].is_empty ())\n \t\treturn false;\n \t      continue;\n \t    }\n-\t  if (m_known_aggs[i] != ctx.m_known_aggs[i])\n+\t  if (!m_known_aggs[i].equal_to (ctx.m_known_aggs[i]))\n \t    return false;\n \t}\n     }\n@@ -3348,7 +3351,7 @@ estimate_ipcp_clone_size_and_time (struct cgraph_node *node,\n \t\t\t\t   vec<tree> known_vals,\n \t\t\t\t   vec<ipa_polymorphic_call_context>\n \t\t\t\t   known_contexts,\n-\t\t\t\t   vec<ipa_agg_jump_function_p> known_aggs,\n+\t\t\t\t   vec<ipa_agg_value_set> known_aggs,\n \t\t\t\t   int *ret_size, sreal *ret_time,\n \t\t\t\t   sreal *ret_nonspec_time,\n \t\t\t\t   ipa_hints *hints)"}, {"sha": "0d7467c01af051f49c19cc5040552999adde2e85", "filename": "gcc/ipa-fnsummary.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb270950acbae6f70e3487a6e63a26c1294656b3/gcc%2Fipa-fnsummary.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb270950acbae6f70e3487a6e63a26c1294656b3/gcc%2Fipa-fnsummary.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.h?ref=eb270950acbae6f70e3487a6e63a26c1294656b3", "patch": "@@ -293,7 +293,7 @@ class ipa_call_context\n \t\t    clause_t nonspec_possible_truths,\n \t\t    vec<tree> known_vals,\n \t\t    vec<ipa_polymorphic_call_context> known_contexts,\n-\t\t    vec<ipa_agg_jump_function_p> known_aggs,\n+\t\t    vec<ipa_agg_value_set> known_aggs,\n \t\t    vec<inline_param_summary> m_inline_param_summary);\n   ipa_call_context ()\n   : m_node(NULL)\n@@ -329,7 +329,7 @@ class ipa_call_context\n   /* Vector describing known polymorphic call contexts.  */\n   vec<ipa_polymorphic_call_context> m_known_contexts;\n   /* Vector describing known aggregate values.  */\n-  vec<ipa_agg_jump_function_p> m_known_aggs;\n+  vec<ipa_agg_value_set> m_known_aggs;\n };\n \n extern fast_call_summary <ipa_call_summary *, va_heap> *ipa_call_summaries;\n@@ -345,7 +345,7 @@ void inline_analyze_function (struct cgraph_node *node);\n void estimate_ipcp_clone_size_and_time (struct cgraph_node *,\n \t\t\t\t\tvec<tree>,\n \t\t\t\t\tvec<ipa_polymorphic_call_context>,\n-\t\t\t\t\tvec<ipa_agg_jump_function_p>,\n+\t\t\t\t\tvec<ipa_agg_value_set>,\n \t\t\t\t\tint *, sreal *, sreal *,\n \t\t\t\t        ipa_hints *);\n void ipa_merge_fn_summary_after_inlining (struct cgraph_edge *edge);\n@@ -360,7 +360,7 @@ void evaluate_properties_for_edge (struct cgraph_edge *e,\n \t\t\t\t   vec<tree> *known_vals_ptr,\n \t\t\t\t   vec<ipa_polymorphic_call_context>\n \t\t\t\t   *known_contexts_ptr,\n-\t\t\t\t   vec<ipa_agg_jump_function_p> *);\n+\t\t\t\t   vec<ipa_agg_value_set> *);\n \n void ipa_fnsummary_c_finalize (void);\n HOST_WIDE_INT ipa_get_stack_frame_offset (struct cgraph_node *node);"}, {"sha": "1e124fd6ca939c4f1a368fd015b2d6483107e0fd", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb270950acbae6f70e3487a6e63a26c1294656b3/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb270950acbae6f70e3487a6e63a26c1294656b3/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=eb270950acbae6f70e3487a6e63a26c1294656b3", "patch": "@@ -188,7 +188,7 @@ do_estimate_edge_time (struct cgraph_edge *edge)\n   clause_t clause, nonspec_clause;\n   vec<tree> known_vals;\n   vec<ipa_polymorphic_call_context> known_contexts;\n-  vec<ipa_agg_jump_function_p> known_aggs;\n+  vec<ipa_agg_value_set> known_aggs;\n   class ipa_call_summary *es = ipa_call_summaries->get (edge);\n   int min_size = -1;\n \n@@ -308,7 +308,7 @@ do_estimate_edge_size (struct cgraph_edge *edge)\n   clause_t clause, nonspec_clause;\n   vec<tree> known_vals;\n   vec<ipa_polymorphic_call_context> known_contexts;\n-  vec<ipa_agg_jump_function_p> known_aggs;\n+  vec<ipa_agg_value_set> known_aggs;\n \n   /* When we do caching, use do_estimate_edge_time to populate the entry.  */\n \n@@ -347,7 +347,7 @@ do_estimate_edge_hints (struct cgraph_edge *edge)\n   clause_t clause, nonspec_clause;\n   vec<tree> known_vals;\n   vec<ipa_polymorphic_call_context> known_contexts;\n-  vec<ipa_agg_jump_function_p> known_aggs;\n+  vec<ipa_agg_value_set> known_aggs;\n \n   /* When we do caching, use do_estimate_edge_time to populate the entry.  */\n "}, {"sha": "f56aa3240d296bf7cdffc1b9ad785161b3a39eef", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 489, "deletions": 89, "changes": 578, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb270950acbae6f70e3487a6e63a26c1294656b3/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb270950acbae6f70e3487a6e63a26c1294656b3/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=eb270950acbae6f70e3487a6e63a26c1294656b3", "patch": "@@ -360,18 +360,45 @@ ipa_print_node_jump_functions_for_edge (FILE *f, struct cgraph_edge *cs)\n \n \t  fprintf (f, \"         Aggregate passed by %s:\\n\",\n \t\t   jump_func->agg.by_ref ? \"reference\" : \"value\");\n-\t  FOR_EACH_VEC_SAFE_ELT (jump_func->agg.items, j, item)\n+\t  FOR_EACH_VEC_ELT (*jump_func->agg.items, j, item)\n \t    {\n \t      fprintf (f, \"           offset: \" HOST_WIDE_INT_PRINT_DEC \", \",\n \t\t       item->offset);\n-\t      if (TYPE_P (item->value))\n-\t\tfprintf (f, \"clobber of \" HOST_WIDE_INT_PRINT_DEC \" bits\",\n-\t\t\t tree_to_uhwi (TYPE_SIZE (item->value)));\n-\t      else\n+\t      fprintf (f, \"type: \");\n+\t      print_generic_expr (f, item->type);\n+\t      fprintf (f, \", \");\n+\t      if (item->jftype == IPA_JF_PASS_THROUGH)\n+\t\tfprintf (f, \"PASS THROUGH: %d,\",\n+\t\t\t item->value.pass_through.formal_id);\n+\t      else if (item->jftype == IPA_JF_LOAD_AGG)\n+\t\t{\n+\t\t  fprintf (f, \"LOAD AGG: %d\",\n+\t\t\t   item->value.pass_through.formal_id);\n+\t\t  fprintf (f, \" [offset: \" HOST_WIDE_INT_PRINT_DEC \", by %s],\",\n+\t\t\t   item->value.load_agg.offset,\n+\t\t\t   item->value.load_agg.by_ref ? \"reference\"\n+\t\t\t\t\t\t       : \"value\");\n+\t\t}\n+\n+\t      if (item->jftype == IPA_JF_PASS_THROUGH\n+\t\t  || item->jftype == IPA_JF_LOAD_AGG)\n+\t\t{\n+\t\t  fprintf (f, \" op %s\",\n+\t\t     get_tree_code_name (item->value.pass_through.operation));\n+\t\t  if (item->value.pass_through.operation != NOP_EXPR)\n+\t\t    {\n+\t\t      fprintf (f, \" \");\n+\t\t      print_generic_expr (f, item->value.pass_through.operand);\n+\t\t    }\n+\t\t}\n+\t      else if (item->jftype == IPA_JF_CONST)\n \t\t{\n-\t\t  fprintf (f, \"cst: \");\n-\t\t  print_generic_expr (f, item->value);\n+\t\t  fprintf (f, \"CONST: \");\n+\t\t  print_generic_expr (f, item->value.constant);\n \t\t}\n+\t      else if (item->jftype == IPA_JF_UNKNOWN)\n+\t\tfprintf (f, \"UNKNOWN: \" HOST_WIDE_INT_PRINT_DEC \" bits\",\n+\t\t\t tree_to_uhwi (TYPE_SIZE (item->type)));\n \t      fprintf (f, \"\\n\");\n \t    }\n \t}\n@@ -1138,6 +1165,67 @@ ipa_load_from_parm_agg (struct ipa_func_body_info *fbi,\n   return false;\n }\n \n+/* If STMT is an assignment that loads a value from a parameter declaration,\n+   or from an aggregate passed as the parameter either by value or reference,\n+   return the index of the parameter in ipa_node_params.  Otherwise return -1.\n+\n+   FBI holds gathered information about the function.  INFO describes\n+   parameters of the function, STMT is the assignment statement.  If it is a\n+   memory load from an aggregate, *OFFSET_P is filled with offset within the\n+   aggregate, and *BY_REF_P specifies whether the aggregate is passed by\n+   reference.  */\n+\n+static int\n+load_from_unmodified_param_or_agg (struct ipa_func_body_info *fbi,\n+\t\t\t\t   class ipa_node_params *info,\n+\t\t\t\t   gimple *stmt,\n+\t\t\t\t   HOST_WIDE_INT *offset_p,\n+\t\t\t\t   bool *by_ref_p)\n+{\n+  int index = load_from_unmodified_param (fbi, info->descriptors, stmt);\n+  poly_int64 size;\n+\n+  /* Load value from a parameter declaration.  */\n+  if (index >= 0)\n+    {\n+      *offset_p = -1;\n+      return index;\n+    }\n+\n+  if (!gimple_assign_load_p (stmt))\n+    return -1;\n+\n+  tree rhs = gimple_assign_rhs1 (stmt);\n+\n+  /* Skip memory reference containing VIEW_CONVERT_EXPR.  */\n+  for (tree t = rhs; handled_component_p (t); t = TREE_OPERAND (t, 0))\n+    if (TREE_CODE (t) == VIEW_CONVERT_EXPR)\n+      return -1;\n+\n+  /* Skip memory reference containing bit-field.  */\n+  if (TREE_CODE (rhs) == BIT_FIELD_REF\n+      || contains_bitfld_component_ref_p (rhs))\n+    return -1;\n+\n+  if (!ipa_load_from_parm_agg (fbi, info->descriptors, stmt, rhs, &index,\n+\t\t\t       offset_p, &size, by_ref_p))\n+    return -1;\n+\n+  gcc_assert (!maybe_ne (tree_to_poly_int64 (TYPE_SIZE (TREE_TYPE (rhs))),\n+\t\t\t size));\n+  if (!*by_ref_p)\n+    {\n+      tree param_type = ipa_get_type (info, index);\n+\n+      if (!param_type || !AGGREGATE_TYPE_P (param_type))\n+\treturn -1;\n+    }\n+  else if (TREE_THIS_VOLATILE (rhs))\n+    return -1;\n+\n+  return index;\n+}\n+\n /* Given that an actual argument is an SSA_NAME (given in NAME) and is a result\n    of an assignment statement STMT, try to determine whether we are actually\n    handling any of the following cases and construct an appropriate jump\n@@ -1441,11 +1529,11 @@ type_like_member_ptr_p (tree type, tree *method_ptr, tree *delta)\n }\n \n /* If RHS is an SSA_NAME and it is defined by a simple copy assign statement,\n-   return the rhs of its defining statement.  Otherwise return RHS as it\n-   is.  */\n+   return the rhs of its defining statement, and this statement is stored in\n+   *RHS_STMT.  Otherwise return RHS as it is.  */\n \n static inline tree\n-get_ssa_def_if_simple_copy (tree rhs)\n+get_ssa_def_if_simple_copy (tree rhs, gimple **rhs_stmt)\n {\n   while (TREE_CODE (rhs) == SSA_NAME && !SSA_NAME_IS_DEFAULT_DEF (rhs))\n     {\n@@ -1455,25 +1543,31 @@ get_ssa_def_if_simple_copy (tree rhs)\n \trhs = gimple_assign_rhs1 (def_stmt);\n       else\n \tbreak;\n+      *rhs_stmt = def_stmt;\n     }\n   return rhs;\n }\n \n-/* Simple linked list, describing known contents of an aggregate before\n-   call.  */\n+/* Simple linked list, describing contents of an aggregate before call.  */\n \n struct ipa_known_agg_contents_list\n {\n   /* Offset and size of the described part of the aggregate.  */\n   HOST_WIDE_INT offset, size;\n-  /* Known constant value or NULL if the contents is known to be unknown.  */\n-  tree constant;\n+\n+  /* Type of the described part of the aggregate.  */\n+  tree type;\n+\n+  /* Known constant value or jump function data describing contents.  */\n+  struct ipa_load_agg_data value;\n+\n   /* Pointer to the next structure in the list.  */\n   struct ipa_known_agg_contents_list *next;\n };\n \n-/* Add a known content item into a linked list of ipa_known_agg_contents_list\n-   structure, in which all elements are sorted ascendingly by offset.  */\n+/* Add an aggregate content item into a linked list of\n+   ipa_known_agg_contents_list structure, in which all elements\n+   are sorted ascendingly by offset.  */\n \n static inline void\n add_to_agg_contents_list (struct ipa_known_agg_contents_list **plist,\n@@ -1493,7 +1587,7 @@ add_to_agg_contents_list (struct ipa_known_agg_contents_list **plist,\n   *plist = item;\n }\n \n-/* Check whether a given known content is clobbered by certain element in\n+/* Check whether a given aggregate content is clobbered by certain element in\n    a linked list of ipa_known_agg_contents_list.  */\n \n static inline bool\n@@ -1513,27 +1607,193 @@ clobber_by_agg_contents_list_p (struct ipa_known_agg_contents_list *list,\n }\n \n /* Build aggregate jump function from LIST, assuming there are exactly\n-   CONST_COUNT constant entries there and that offset of the passed argument\n+   VALUE_COUNT entries there and that offset of the passed argument\n    is ARG_OFFSET and store it into JFUNC.  */\n \n static void\n build_agg_jump_func_from_list (struct ipa_known_agg_contents_list *list,\n-\t\t\t       int const_count, HOST_WIDE_INT arg_offset,\n+\t\t\t       int value_count, HOST_WIDE_INT arg_offset,\n \t\t\t       struct ipa_jump_func *jfunc)\n {\n-  vec_alloc (jfunc->agg.items, const_count);\n-  while (list)\n+  vec_alloc (jfunc->agg.items, value_count);\n+  for (; list; list = list->next)\n+    {\n+      struct ipa_agg_jf_item item;\n+      tree operand = list->value.pass_through.operand;\n+\n+      if (list->value.pass_through.formal_id >= 0)\n+\t{\n+\t  /* Content value is derived from some formal paramerter.  */\n+\t  if (list->value.offset >= 0)\n+\t    item.jftype = IPA_JF_LOAD_AGG;\n+\t  else\n+\t    item.jftype = IPA_JF_PASS_THROUGH;\n+\n+\t  item.value.load_agg = list->value;\n+\t  if (operand)\n+\t    item.value.pass_through.operand\n+\t      = unshare_expr_without_location (operand);\n+\t}\n+      else if (operand)\n+\t{\n+\t  /* Content value is known constant.  */\n+\t  item.jftype = IPA_JF_CONST;\n+\t  item.value.constant = unshare_expr_without_location (operand);\n+\t}\n+      else\n+\tcontinue;\n+\n+      item.type = list->type;\n+      gcc_assert (tree_to_shwi (TYPE_SIZE (list->type)) == list->size);\n+\n+      item.offset = list->offset - arg_offset;\n+      gcc_assert ((item.offset % BITS_PER_UNIT) == 0);\n+\n+      jfunc->agg.items->quick_push (item);\n+    }\n+}\n+\n+/* Given an assignment statement STMT, try to collect information into\n+   AGG_VALUE that will be used to construct jump function for RHS of the\n+   assignment, from which content value of an aggregate part comes.\n+\n+   Besides constant and simple pass-through jump functions, also try to\n+   identify whether it matches the following pattern that can be described by\n+   a load-value-from-aggregate jump function, which is a derivative of simple\n+   pass-through jump function.\n+\n+     foo (int *p)\n+     {\n+       ...\n+\n+       *(q_5 + 4) = *(p_3(D) + 28) op 1;\n+       bar (q_5);\n+     }\n+\n+   Here IPA_LOAD_AGG_DATA data structure is informative enough to describe\n+   constant, simple pass-through and load-vale-from-aggregate. If value\n+   is constant, it will be kept in field OPERAND, and field FORMAL_ID is\n+   set to -1. For simple pass-through and load-value-from-aggregate, field\n+   FORMAL_ID specifies the related formal parameter index, and field\n+   OFFSET can be used to distinguish them, -1 means simple pass-through,\n+   otherwise means load-value-from-aggregate.  */\n+\n+static void\n+analyze_agg_content_value (struct ipa_func_body_info *fbi,\n+\t\t\t   struct ipa_load_agg_data *agg_value,\n+\t\t\t   gimple *stmt)\n+{\n+  tree lhs = gimple_assign_lhs (stmt);\n+  tree rhs1 = gimple_assign_rhs1 (stmt);\n+  enum tree_code code;\n+  int index = -1;\n+\n+  /* Initialize jump function data for the aggregate part.  */\n+  memset (agg_value, 0, sizeof (*agg_value));\n+  agg_value->pass_through.operation = NOP_EXPR;\n+  agg_value->pass_through.formal_id = -1;\n+  agg_value->offset = -1;\n+\n+  if (AGGREGATE_TYPE_P (TREE_TYPE (lhs))  /* TODO: Support aggregate type.  */\n+      || TREE_THIS_VOLATILE (lhs)\n+      || TREE_CODE (lhs) == BIT_FIELD_REF\n+      || contains_bitfld_component_ref_p (lhs))\n+    return;\n+\n+  /* Skip SSA copies.  */\n+  while (gimple_assign_rhs_class (stmt) == GIMPLE_SINGLE_RHS)\n+    {\n+      if (TREE_CODE (rhs1) != SSA_NAME || SSA_NAME_IS_DEFAULT_DEF (rhs1))\n+\tbreak;\n+\n+      stmt = SSA_NAME_DEF_STMT (rhs1);\n+      if (!is_gimple_assign (stmt))\n+\treturn;\n+\n+      rhs1 = gimple_assign_rhs1 (stmt);\n+    }\n+\n+  code = gimple_assign_rhs_code (stmt);\n+  switch (gimple_assign_rhs_class (stmt))\n     {\n-      if (list->constant)\n+    case GIMPLE_SINGLE_RHS:\n+      if (is_gimple_ip_invariant (rhs1))\n \t{\n-\t  struct ipa_agg_jf_item item;\n-\t  item.offset = list->offset - arg_offset;\n-\t  gcc_assert ((item.offset % BITS_PER_UNIT) == 0);\n-\t  item.value = unshare_expr_without_location (list->constant);\n-\t  jfunc->agg.items->quick_push (item);\n+\t  agg_value->pass_through.operand = rhs1;\n+\t  return;\n \t}\n-      list = list->next;\n+      code = NOP_EXPR;\n+      break;\n+\n+    case GIMPLE_UNARY_RHS:\n+      /* NOTE: A GIMPLE_UNARY_RHS operation might not be tcc_unary\n+\t (truth_not_expr is example), GIMPLE_BINARY_RHS does not imply\n+\t tcc_binary, this subtleness is somewhat misleading.\n+\n+\t Since tcc_unary is widely used in IPA-CP code to check an operation\n+\t with one operand, here we only allow tc_unary operation to avoid\n+\t possible problem.  Then we can use (opclass == tc_unary) or not to\n+\t distinguish unary and binary.  */\n+      if (TREE_CODE_CLASS (code) != tcc_unary || CONVERT_EXPR_CODE_P (code))\n+\treturn;\n+\n+      rhs1 = get_ssa_def_if_simple_copy (rhs1, &stmt);\n+      break;\n+\n+    case GIMPLE_BINARY_RHS:\n+      {\n+\tgimple *rhs1_stmt = stmt;\n+\tgimple *rhs2_stmt = stmt;\n+\ttree rhs2 = gimple_assign_rhs2 (stmt);\n+\n+\trhs1 = get_ssa_def_if_simple_copy (rhs1, &rhs1_stmt);\n+\trhs2 = get_ssa_def_if_simple_copy (rhs2, &rhs2_stmt);\n+\n+\tif (is_gimple_ip_invariant (rhs2))\n+\t  {\n+\t    agg_value->pass_through.operand = rhs2;\n+\t    stmt = rhs1_stmt;\n+\t  }\n+\telse if (is_gimple_ip_invariant (rhs1))\n+\t  {\n+\t    if (TREE_CODE_CLASS (code) == tcc_comparison)\n+\t      code = swap_tree_comparison (code);\n+\t    else if (!commutative_tree_code (code))\n+\t      return;\n+\n+\t    agg_value->pass_through.operand = rhs1;\n+\t    stmt = rhs2_stmt;\n+\t    rhs1 = rhs2;\n+\t  }\n+\telse\n+\t  return;\n+\n+\tif (TREE_CODE_CLASS (code) != tcc_comparison\n+\t    && !useless_type_conversion_p (TREE_TYPE (lhs), TREE_TYPE (rhs1)))\n+\t  return;\n+      }\n+      break;\n+\n+    default:\n+      return;\n+  }\n+\n+  if (TREE_CODE (rhs1) != SSA_NAME)\n+    index = load_from_unmodified_param_or_agg (fbi, fbi->info, stmt,\n+\t\t\t\t\t       &agg_value->offset,\n+\t\t\t\t\t       &agg_value->by_ref);\n+  else if (SSA_NAME_IS_DEFAULT_DEF (rhs1))\n+    index = ipa_get_param_decl_index (fbi->info, SSA_NAME_VAR (rhs1));\n+\n+  if (index >= 0)\n+    {\n+      if (agg_value->offset >= 0)\n+\tagg_value->type = TREE_TYPE (rhs1);\n+      agg_value->pass_through.formal_id = index;\n+      agg_value->pass_through.operation = code;\n     }\n+  else\n+    agg_value->pass_through.operand = NULL_TREE;\n }\n \n /* If STMT is a memory store to the object whose address is BASE, extract\n@@ -1543,26 +1803,19 @@ build_agg_jump_func_from_list (struct ipa_known_agg_contents_list *list,\n    is expected to be in form of MEM_REF expression.  */\n \n static bool\n-extract_mem_content (gimple *stmt, tree base, bool check_ref,\n+extract_mem_content (struct ipa_func_body_info *fbi,\n+\t\t     gimple *stmt, tree base, bool check_ref,\n \t\t     struct ipa_known_agg_contents_list *content)\n {\n   HOST_WIDE_INT lhs_offset, lhs_size;\n-  tree lhs, rhs, lhs_base;\n   bool reverse;\n \n-  if (!gimple_assign_single_p (stmt))\n-    return false;\n-\n-  lhs = gimple_assign_lhs (stmt);\n-  rhs = gimple_assign_rhs1 (stmt);\n-\n-  if (!is_gimple_reg_type (TREE_TYPE (rhs))\n-      || TREE_CODE (lhs) == BIT_FIELD_REF\n-      || contains_bitfld_component_ref_p (lhs))\n+  if (!is_gimple_assign (stmt))\n     return false;\n \n-  lhs_base = get_ref_base_and_extent_hwi (lhs, &lhs_offset,\n-\t\t\t\t\t  &lhs_size, &reverse);\n+  tree lhs = gimple_assign_lhs (stmt);\n+  tree lhs_base = get_ref_base_and_extent_hwi (lhs, &lhs_offset, &lhs_size,\n+\t\t\t\t\t       &reverse);\n   if (!lhs_base)\n     return false;\n \n@@ -1576,39 +1829,37 @@ extract_mem_content (gimple *stmt, tree base, bool check_ref,\n   else if (lhs_base != base)\n     return false;\n \n-  rhs = get_ssa_def_if_simple_copy (rhs);\n-\n-  content->size = lhs_size;\n   content->offset = lhs_offset;\n-  content->constant = is_gimple_ip_invariant (rhs) ? rhs : NULL_TREE;\n+  content->size = lhs_size;\n+  content->type = TREE_TYPE (lhs);\n   content->next = NULL;\n \n+  analyze_agg_content_value (fbi, &content->value, stmt);\n   return true;\n }\n \n /* Traverse statements from CALL backwards, scanning whether an aggregate given\n-   in ARG is filled in with constant values.  ARG can either be an aggregate\n-   expression or a pointer to an aggregate.  ARG_TYPE is the type of the\n-   aggregate.  JFUNC is the jump function into which the constants are\n-   subsequently stored.  AA_WALK_BUDGET_P points to limit on number of\n-   statements we allow get_continuation_for_phi to examine.  */\n+   in ARG is filled in constants or values that are derived from caller's\n+   formal parameter in the way described by some kinds of jump functions.  FBI\n+   is the context of the caller function for interprocedural analysis.  ARG can\n+   either be an aggregate expression or a pointer to an aggregate.  ARG_TYPE is\n+   the type of the aggregate, JFUNC is the jump function for the aggregate.  */\n \n static void\n-determine_known_aggregate_parts (gcall *call, tree arg,\n+determine_known_aggregate_parts (struct ipa_func_body_info *fbi,\n+\t\t\t\t gcall *call, tree arg,\n \t\t\t\t tree arg_type,\n-\t\t\t\t struct ipa_jump_func *jfunc,\n-\t\t\t\t unsigned *aa_walk_budget_p)\n+\t\t\t\t struct ipa_jump_func *jfunc)\n {\n   struct ipa_known_agg_contents_list *list = NULL, *all_list = NULL;\n   bitmap visited = NULL;\n-  int item_count = 0, const_count = 0;\n-  int ipa_max_agg_items = param_ipa_max_agg_items;\n+  int item_count = 0, value_count = 0;\n   HOST_WIDE_INT arg_offset, arg_size;\n   tree arg_base;\n   bool check_ref, by_ref;\n   ao_ref r;\n \n-  if (ipa_max_agg_items == 0)\n+  if (param_ipa_max_agg_items == 0)\n     return;\n \n   /* The function operates in three stages.  First, we prepare check_ref, r,\n@@ -1680,7 +1931,7 @@ determine_known_aggregate_parts (gcall *call, tree arg,\n       if (gimple_code (stmt) == GIMPLE_PHI)\n \t{\n \t  dom_vuse = get_continuation_for_phi (stmt, &r, true,\n-\t\t\t\t\t       *aa_walk_budget_p,\n+\t\t\t\t\t       fbi->aa_walk_budget,\n \t\t\t\t\t       &visited, false, NULL, NULL);\n \t  continue;\n \t}\n@@ -1690,12 +1941,13 @@ determine_known_aggregate_parts (gcall *call, tree arg,\n \t  struct ipa_known_agg_contents_list *content\n \t\t\t= XALLOCA (struct ipa_known_agg_contents_list);\n \n-\t  if (!extract_mem_content (stmt, arg_base, check_ref, content))\n+\t  if (!extract_mem_content (fbi, stmt, arg_base, check_ref, content))\n \t    break;\n \n \t  /* Now we get a dominating virtual operand, and need to check\n \t     whether its value is clobbered any other dominating one.  */\n-\t  if (content->constant\n+\t  if ((content->value.pass_through.formal_id >= 0\n+\t       || content->value.pass_through.operand)\n \t      && !clobber_by_agg_contents_list_p (all_list, content))\n \t    {\n \t      struct ipa_known_agg_contents_list *copy\n@@ -1705,14 +1957,14 @@ determine_known_aggregate_parts (gcall *call, tree arg,\n \t\t operands, whose definitions can finally reach the call.  */\n \t      add_to_agg_contents_list (&list, (*copy = *content, copy));\n \n-\t      if (++const_count == ipa_max_agg_items)\n+\t      if (++value_count == param_ipa_max_agg_items)\n \t\tbreak;\n \t    }\n \n \t  /* Add to the list consisting of all dominating virtual operands.  */\n \t  add_to_agg_contents_list (&all_list, content);\n \n-\t  if (++item_count == 2 * ipa_max_agg_items)\n+\t  if (++item_count == 2 * param_ipa_max_agg_items)\n \t    break;\n \t}\n       dom_vuse = gimple_vuse (stmt);\n@@ -1723,12 +1975,12 @@ determine_known_aggregate_parts (gcall *call, tree arg,\n \n   /* Third stage just goes over the list and creates an appropriate vector of\n      ipa_agg_jf_item structures out of it, of course only if there are\n-     any known constants to begin with.  */\n+     any meaningful items to begin with.  */\n \n-  if (const_count)\n+  if (value_count)\n     {\n       jfunc->agg.by_ref = by_ref;\n-      build_agg_jump_func_from_list (list, const_count, arg_offset, jfunc);\n+      build_agg_jump_func_from_list (list, value_count, arg_offset, jfunc);\n     }\n }\n \n@@ -2020,8 +2272,7 @@ ipa_compute_jump_functions_for_edge (struct ipa_func_body_info *fbi,\n \t      || !ipa_get_jf_ancestor_agg_preserved (jfunc))\n \t  && (AGGREGATE_TYPE_P (TREE_TYPE (arg))\n \t      || POINTER_TYPE_P (param_type)))\n-\tdetermine_known_aggregate_parts (call, arg, param_type, jfunc,\n-\t\t\t\t\t &fbi->aa_walk_budget);\n+\tdetermine_known_aggregate_parts (fbi, call, arg, param_type, jfunc);\n     }\n   if (!useful_context)\n     vec_free (args->polymorphic_call_contexts);\n@@ -2680,6 +2931,72 @@ update_jump_functions_after_inlining (struct cgraph_edge *cs,\n       class ipa_polymorphic_call_context *dst_ctx\n \t= ipa_get_ith_polymorhic_call_context (args, i);\n \n+      if (dst->agg.items)\n+\t{\n+\t  struct ipa_agg_jf_item *item;\n+\t  int j;\n+\n+\t  FOR_EACH_VEC_ELT (*dst->agg.items, j, item)\n+\t    {\n+\t      int dst_fid;\n+\t      struct ipa_jump_func *src;\n+\n+\t      if (item->jftype != IPA_JF_PASS_THROUGH\n+\t\t  && item->jftype != IPA_JF_LOAD_AGG)\n+\t\tcontinue;\n+\n+\t      dst_fid = item->value.pass_through.formal_id;\n+\t      if (dst_fid >= ipa_get_cs_argument_count (top))\n+\t\t{\n+\t\t  item->jftype = IPA_JF_UNKNOWN;\n+\t\t  continue;\n+\t\t}\n+\n+\t      item->value.pass_through.formal_id = -1;\n+\t      src = ipa_get_ith_jump_func (top, dst_fid);\n+\t      if (src->type == IPA_JF_CONST)\n+\t\t{\n+\t\t  if (item->jftype == IPA_JF_PASS_THROUGH\n+\t\t      && item->value.pass_through.operation == NOP_EXPR)\n+\t\t    {\n+\t\t      item->jftype = IPA_JF_CONST;\n+\t\t      item->value.constant = src->value.constant.value;\n+\t\t      continue;\n+\t\t    }\n+\t\t}\n+\t      else if (src->type == IPA_JF_PASS_THROUGH\n+\t\t       && src->value.pass_through.operation == NOP_EXPR)\n+\t\t{\n+\t\t  if (item->jftype == IPA_JF_PASS_THROUGH\n+\t\t      || !item->value.load_agg.by_ref\n+\t\t      || src->value.pass_through.agg_preserved)\n+\t\t    item->value.pass_through.formal_id\n+\t\t\t\t= src->value.pass_through.formal_id;\n+\t\t}\n+\t      else if (src->type == IPA_JF_ANCESTOR)\n+\t\t{\n+\t\t  if (item->jftype == IPA_JF_PASS_THROUGH)\n+\t\t    {\n+\t\t      if (!src->value.ancestor.offset)\n+\t\t\titem->value.pass_through.formal_id\n+\t\t\t\t= src->value.ancestor.formal_id;\n+\t\t    }\n+\t\t  else if (src->value.ancestor.agg_preserved)\n+\t\t    {\n+\t\t      gcc_checking_assert (item->value.load_agg.by_ref);\n+\n+\t\t      item->value.pass_through.formal_id\n+\t\t\t\t = src->value.ancestor.formal_id;\n+\t\t      item->value.load_agg.offset\n+\t\t\t\t+= src->value.ancestor.offset;\n+\t\t    }\n+\t\t}\n+\n+\t      if (item->value.pass_through.formal_id < 0)\n+\t\titem->jftype = IPA_JF_UNKNOWN;\n+\t    }\n+\t}\n+\n       if (dst->type == IPA_JF_ANCESTOR)\n \t{\n \t  struct ipa_jump_func *src;\n@@ -2719,8 +3036,11 @@ update_jump_functions_after_inlining (struct cgraph_edge *cs,\n \t\t}\n \t    }\n \n-\t  if (src->agg.items\n-\t      && (dst->value.ancestor.agg_preserved || !src->agg.by_ref))\n+\t  /* Parameter and argument in ancestor jump function must be pointer\n+\t     type, which means access to aggregate must be by-reference.  */\n+\t  gcc_assert (!src->agg.items || src->agg.by_ref);\n+\n+\t  if (src->agg.items && dst->value.ancestor.agg_preserved)\n \t    {\n \t      struct ipa_agg_jf_item *item;\n \t      int j;\n@@ -3112,18 +3432,19 @@ ipa_find_agg_cst_from_init (tree scalar, HOST_WIDE_INT offset, bool by_ref)\n   return find_constructor_constant_at_offset (DECL_INITIAL (scalar), offset);\n }\n \n-/* Retrieve value from aggregate jump function AGG or static initializer of\n-   SCALAR (which can be NULL) for the given OFFSET or return NULL if there is\n-   none.  BY_REF specifies whether the value has to be passed by reference or\n-   by value.  If FROM_GLOBAL_CONSTANT is non-NULL, then the boolean it points\n-   to is set to true if the value comes from an initializer of a constant.  */\n+/* Retrieve value from AGG, a set of known offset/value for an aggregate or\n+   static initializer of SCALAR (which can be NULL) for the given OFFSET or\n+   return NULL if there is none.  BY_REF specifies whether the value has to be\n+   passed by reference or by value.  If FROM_GLOBAL_CONSTANT is non-NULL, then\n+   the boolean it points to is set to true if the value comes from an\n+   initializer of a constant.  */\n \n tree\n-ipa_find_agg_cst_for_param (struct ipa_agg_jump_function *agg, tree scalar,\n+ipa_find_agg_cst_for_param (struct ipa_agg_value_set *agg, tree scalar,\n \t\t\t    HOST_WIDE_INT offset, bool by_ref,\n \t\t\t    bool *from_global_constant)\n {\n-  struct ipa_agg_jf_item *item;\n+  struct ipa_agg_value *item;\n   int i;\n \n   if (scalar)\n@@ -3141,7 +3462,7 @@ ipa_find_agg_cst_for_param (struct ipa_agg_jump_function *agg, tree scalar,\n       || by_ref != agg->by_ref)\n     return NULL;\n \n-  FOR_EACH_VEC_SAFE_ELT (agg->items, i, item)\n+  FOR_EACH_VEC_ELT (agg->items, i, item)\n     if (item->offset == offset)\n       {\n \t/* Currently we do not have clobber values, return NULL for them once\n@@ -3237,11 +3558,13 @@ try_decrement_rdesc_refcount (struct ipa_jump_func *jfunc)\n    pointer formal parameter described by jump function JFUNC.  TARGET_TYPE is\n    the type of the parameter to which the result of JFUNC is passed.  If it can\n    be determined, return the newly direct edge, otherwise return NULL.\n-   NEW_ROOT_INFO is the node info that JFUNC lattices are relative to.  */\n+   NEW_ROOT and NEW_ROOT_INFO is the node and its info that JFUNC lattices are\n+   relative to.  */\n \n static struct cgraph_edge *\n try_make_edge_direct_simple_call (struct cgraph_edge *ie,\n \t\t\t\t  struct ipa_jump_func *jfunc, tree target_type,\n+\t\t\t\t  struct cgraph_node *new_root,\n \t\t\t\t  class ipa_node_params *new_root_info)\n {\n   struct cgraph_edge *cs;\n@@ -3251,10 +3574,14 @@ try_make_edge_direct_simple_call (struct cgraph_edge *ie,\n   if (agg_contents)\n     {\n       bool from_global_constant;\n-      target = ipa_find_agg_cst_for_param (&jfunc->agg, scalar,\n+      ipa_agg_value_set agg = ipa_agg_value_set_from_jfunc (new_root_info,\n+\t\t\t\t\t\t\t    new_root,\n+\t\t\t\t\t\t\t    &jfunc->agg);\n+      target = ipa_find_agg_cst_for_param (&agg, scalar,\n \t\t\t\t\t   ie->indirect_info->offset,\n \t\t\t\t\t   ie->indirect_info->by_ref,\n \t\t\t\t\t   &from_global_constant);\n+      agg.release ();\n       if (target\n \t  && !from_global_constant\n \t  && !ie->indirect_info->guaranteed_unmodified)\n@@ -3308,12 +3635,16 @@ ipa_impossible_devirt_target (struct cgraph_edge *ie, tree target)\n    call based on a formal parameter which is described by jump function JFUNC\n    and if it can be determined, make it direct and return the direct edge.\n    Otherwise, return NULL.  CTX describes the polymorphic context that the\n-   parameter the call is based on brings along with it.  */\n+   parameter the call is based on brings along with it.  NEW_ROOT and\n+   NEW_ROOT_INFO is the node and its info that JFUNC lattices are relative\n+   to.  */\n \n static struct cgraph_edge *\n try_make_edge_direct_virtual_call (struct cgraph_edge *ie,\n \t\t\t\t   struct ipa_jump_func *jfunc,\n-\t\t\t\t   class ipa_polymorphic_call_context ctx)\n+\t\t\t\t   class ipa_polymorphic_call_context ctx,\n+\t\t\t\t   struct cgraph_node *new_root,\n+\t\t\t\t   class ipa_node_params *new_root_info)\n {\n   tree target = NULL;\n   bool speculative = false;\n@@ -3331,9 +3662,13 @@ try_make_edge_direct_virtual_call (struct cgraph_edge *ie,\n       unsigned HOST_WIDE_INT offset;\n       tree scalar = (jfunc->type == IPA_JF_CONST) ? ipa_get_jf_constant (jfunc)\n \t: NULL;\n-      tree t = ipa_find_agg_cst_for_param (&jfunc->agg, scalar,\n+      ipa_agg_value_set agg = ipa_agg_value_set_from_jfunc (new_root_info,\n+\t\t\t\t\t\t\t    new_root,\n+\t\t\t\t\t\t\t    &jfunc->agg);\n+      tree t = ipa_find_agg_cst_for_param (&agg, scalar,\n \t\t\t\t\t   ie->indirect_info->offset,\n \t\t\t\t\t   true);\n+      agg.release ();\n       if (t && vtable_pointer_value_to_vtable (t, &vtable, &offset))\n \t{\n \t  bool can_refer;\n@@ -3424,14 +3759,15 @@ update_indirect_edges_after_inlining (struct cgraph_edge *cs,\n {\n   class ipa_edge_args *top;\n   struct cgraph_edge *ie, *next_ie, *new_direct_edge;\n+  struct cgraph_node *new_root;\n   class ipa_node_params *new_root_info, *inlined_node_info;\n   bool res = false;\n \n   ipa_check_create_edge_args ();\n   top = IPA_EDGE_REF (cs);\n-  new_root_info = IPA_NODE_REF (cs->caller->inlined_to\n-\t\t\t\t? cs->caller->inlined_to\n-\t\t\t\t: cs->caller);\n+  new_root = cs->caller->inlined_to\n+\t\t? cs->caller->inlined_to : cs->caller;\n+  new_root_info = IPA_NODE_REF (new_root);\n   inlined_node_info = IPA_NODE_REF (cs->callee->function_symbol ());\n \n   for (ie = node->indirect_calls; ie; ie = next_ie)\n@@ -3470,13 +3806,16 @@ update_indirect_edges_after_inlining (struct cgraph_edge *cs,\n \t{\n           ipa_polymorphic_call_context ctx;\n \t  ctx = ipa_context_from_jfunc (new_root_info, cs, param_index, jfunc);\n-\t  new_direct_edge = try_make_edge_direct_virtual_call (ie, jfunc, ctx);\n+\t  new_direct_edge = try_make_edge_direct_virtual_call (ie, jfunc, ctx,\n+\t\t\t\t\t\t\t       new_root,\n+\t\t\t\t\t\t\t       new_root_info);\n \t}\n       else\n \t{\n \t  tree target_type =  ipa_get_type (inlined_node_info, param_index);\n \t  new_direct_edge = try_make_edge_direct_simple_call (ie, jfunc,\n \t\t\t\t\t\t\t      target_type,\n+\t\t\t\t\t\t\t      new_root,\n \t\t\t\t\t\t\t      new_root_info);\n \t}\n \n@@ -4202,6 +4541,8 @@ ipa_write_jump_function (struct output_block *ob,\n       bp_pack_value (&bp, jump_func->value.ancestor.agg_preserved, 1);\n       streamer_write_bitpack (&bp);\n       break;\n+    default:\n+      fatal_error (UNKNOWN_LOCATION, \"invalid jump function in LTO stream\");\n     }\n \n   count = vec_safe_length (jump_func->agg.items);\n@@ -4215,8 +4556,36 @@ ipa_write_jump_function (struct output_block *ob,\n \n   FOR_EACH_VEC_SAFE_ELT (jump_func->agg.items, i, item)\n     {\n+      stream_write_tree (ob, item->type, true);\n       streamer_write_uhwi (ob, item->offset);\n-      stream_write_tree (ob, item->value, true);\n+      streamer_write_uhwi (ob, item->jftype);\n+      switch (item->jftype)\n+\t{\n+\tcase IPA_JF_UNKNOWN:\n+\t  break;\n+\tcase IPA_JF_CONST:\n+\t  stream_write_tree (ob, item->value.constant, true);\n+\t  break;\n+\tcase IPA_JF_PASS_THROUGH:\n+\tcase IPA_JF_LOAD_AGG:\n+\t  streamer_write_uhwi (ob, item->value.pass_through.operation);\n+\t  streamer_write_uhwi (ob, item->value.pass_through.formal_id);\n+\t  if (TREE_CODE_CLASS (item->value.pass_through.operation)\n+\t\t\t\t\t\t\t!= tcc_unary)\n+\t    stream_write_tree (ob, item->value.pass_through.operand, true);\n+\t  if (item->jftype == IPA_JF_LOAD_AGG)\n+\t    {\n+\t      stream_write_tree (ob, item->value.load_agg.type, true);\n+\t      streamer_write_uhwi (ob, item->value.load_agg.offset);\n+\t      bp = bitpack_create (ob->main_stream);\n+\t      bp_pack_value (&bp, item->value.load_agg.by_ref, 1);\n+\t      streamer_write_bitpack (&bp);\n+\t    }\n+\t  break;\n+\tdefault:\n+\t  fatal_error (UNKNOWN_LOCATION,\n+\t\t       \"invalid jump function in LTO stream\");\n+\t}\n     }\n \n   bp = bitpack_create (ob->main_stream);\n@@ -4313,8 +4682,39 @@ ipa_read_jump_function (class lto_input_block *ib,\n   for (i = 0; i < count; i++)\n     {\n       struct ipa_agg_jf_item item;\n+      item.type = stream_read_tree (ib, data_in);\n       item.offset = streamer_read_uhwi (ib);\n-      item.value = stream_read_tree (ib, data_in);\n+      item.jftype = (enum jump_func_type) streamer_read_uhwi (ib);\n+\n+      switch (item.jftype)\n+\t{\n+\tcase IPA_JF_UNKNOWN:\n+\t  break;\n+\tcase IPA_JF_CONST:\n+\t  item.value.constant = stream_read_tree (ib, data_in);\n+\t  break;\n+\tcase IPA_JF_PASS_THROUGH:\n+\tcase IPA_JF_LOAD_AGG:\n+\t  operation = (enum tree_code) streamer_read_uhwi (ib);\n+\t  item.value.pass_through.operation = operation;\n+\t  item.value.pass_through.formal_id = streamer_read_uhwi (ib);\n+\t  if (TREE_CODE_CLASS (operation) == tcc_unary)\n+\t    item.value.pass_through.operand = NULL_TREE;\n+\t  else\n+\t    item.value.pass_through.operand = stream_read_tree (ib, data_in);\n+\t  if (item.jftype == IPA_JF_LOAD_AGG)\n+\t    {\n+\t      struct bitpack_d bp;\n+\t      item.value.load_agg.type = stream_read_tree (ib, data_in);\n+\t      item.value.load_agg.offset = streamer_read_uhwi (ib);\n+\t      bp = streamer_read_bitpack (ib);\n+\t      item.value.load_agg.by_ref = bp_unpack_value (&bp, 1);\n+\t    }\n+\t  break;\n+\tdefault:\n+\t  fatal_error (UNKNOWN_LOCATION,\n+\t\t       \"invalid jump function in LTO stream\");\n+\t}\n       if (prevails)\n         jump_func->agg.items->quick_push (item);\n     }\n@@ -5357,9 +5757,9 @@ ipcp_transform_function (struct cgraph_node *node)\n }\n \n \n-/* Return true if OTHER describes same agg item.  */\n+/* Return true if OTHER describes same agg value.  */\n bool\n-ipa_agg_jf_item::equal_to (const ipa_agg_jf_item &other)\n+ipa_agg_value::equal_to (const ipa_agg_value &other)\n {\n   return offset == other.offset\n \t && operand_equal_p (value, other.value, 0);"}, {"sha": "7eb96a057fef1d69b24070bf575cf6066499b9d6", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 148, "deletions": 34, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb270950acbae6f70e3487a6e63a26c1294656b3/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb270950acbae6f70e3487a6e63a26c1294656b3/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=eb270950acbae6f70e3487a6e63a26c1294656b3", "patch": "@@ -39,6 +39,15 @@ along with GCC; see the file COPYING3.  If not see\n                   argument.\n    Unknown      - neither of the above.\n \n+   IPA_JF_LOAD_AGG is a compound pass-through jump function, in which primary\n+   operation on formal parameter is memory dereference that loads a value from\n+   a part of an aggregate, which is represented or pointed to by the formal\n+   parameter.  Moreover, an additional unary/binary operation can be applied on\n+   the loaded value, and final result is passed as actual argument of callee\n+   (e.g. *(param_1(D) + 4) op 24 ).  It is meant to describe usage of aggregate\n+   parameter or by-reference parameter referenced in argument passing, commonly\n+   found in C++ and Fortran.\n+\n    IPA_JF_ANCESTOR is a special pass-through jump function, which means that\n    the result is an address of a part of the object pointed to by the formal\n    parameter to which the function refers.  It is mainly intended to represent\n@@ -60,6 +69,7 @@ enum jump_func_type\n   IPA_JF_UNKNOWN = 0,  /* newly allocated and zeroed jump functions default */\n   IPA_JF_CONST,             /* represented by field costant */\n   IPA_JF_PASS_THROUGH,\t    /* represented by field pass_through */\n+  IPA_JF_LOAD_AGG,\t    /* represented by field load_agg */\n   IPA_JF_ANCESTOR\t    /* represented by field ancestor */\n };\n \n@@ -97,6 +107,26 @@ struct GTY(()) ipa_pass_through_data\n   unsigned agg_preserved : 1;\n };\n \n+/* Structure holding data required to describe a load-value-from-aggregate\n+   jump function.  */\n+\n+struct GTY(()) ipa_load_agg_data\n+{\n+  /* Inherit from pass through jump function, describing unary/binary\n+     operation on the value loaded from aggregate that is represented or\n+     pointed to by the formal parameter, specified by formal_id in this\n+     pass_through jump function data structure.  */\n+  struct ipa_pass_through_data pass_through;\n+  /* Type of the value loaded from the aggregate.  */\n+  tree type;\n+  /* Offset at which the value is located within the aggregate.  */\n+  HOST_WIDE_INT offset;\n+  /* True if loaded by reference (the aggregate is pointed to by the formal\n+     parameter) or false if loaded by value (the aggregate is represented\n+     by the formal parameter).  */\n+  bool by_ref;\n+};\n+\n /* Structure holding data required to describe an ancestor pass-through\n    jump function.  */\n \n@@ -110,58 +140,139 @@ struct GTY(()) ipa_ancestor_jf_data\n   unsigned agg_preserved : 1;\n };\n \n-/* An element in an aggegate part of a jump function describing a known value\n-   at a given offset.  When it is part of a pass-through jump function with\n-   agg_preserved set or an ancestor jump function with agg_preserved set, all\n-   unlisted positions are assumed to be preserved but the value can be a type\n-   node, which means that the particular piece (starting at offset and having\n-   the size of the type) is clobbered with an unknown value.  When\n-   agg_preserved is false or the type of the containing jump function is\n-   different, all unlisted parts are assumed to be unknown and all values must\n-   fulfill is_gimple_ip_invariant.  */\n+/* A jump function for an aggregate part at a given offset, which describes how\n+   it content value is generated.  All unlisted positions are assumed to have a\n+   value defined in an unknown way.  */\n \n struct GTY(()) ipa_agg_jf_item\n {\n-  /* The offset at which the known value is located within the aggregate.  */\n+  /* The offset for the aggregate part.  */\n   HOST_WIDE_INT offset;\n \n-  /* The known constant or type if this is a clobber.  */\n-  tree value;\n+  /* Data type of the aggregate part.  */\n+  tree type;\n \n-  /* Return true if OTHER describes same agg item.  */\n-  bool equal_to (const ipa_agg_jf_item &other);\n-};\n+  /* Jump function type.  */\n+  enum jump_func_type jftype;\n \n+  /* Represents a value of jump function. constant represents the actual constant\n+     in constant jump function content.  pass_through is used only in simple pass\n+     through jump function context.  load_agg is for load-value-from-aggregate\n+     jump function context.  */\n+  union jump_func_agg_value\n+  {\n+    tree GTY ((tag (\"IPA_JF_CONST\"))) constant;\n+    struct ipa_pass_through_data GTY ((tag (\"IPA_JF_PASS_THROUGH\"))) pass_through;\n+    struct ipa_load_agg_data GTY ((tag (\"IPA_JF_LOAD_AGG\"))) load_agg;\n+  } GTY ((desc (\"%1.jftype\"))) value;\n+};\n \n-/* Aggregate jump function - i.e. description of contents of aggregates passed\n-   either by reference or value.  */\n+/* Jump functions describing a set of aggregate contents.  */\n \n struct GTY(()) ipa_agg_jump_function\n {\n-  /* Description of the individual items.  */\n+  /* Description of the individual jump function item.  */\n   vec<ipa_agg_jf_item, va_gc> *items;\n-  /* True if the data was passed by reference (as opposed to by value). */\n+  /* True if the data was passed by reference (as opposed to by value).  */\n   bool by_ref;\n+};\n+\n+/* An element in an aggregate part describing a known value at a given offset.\n+   All unlisted positions are assumed to be unknown and all listed values must\n+   fulfill is_gimple_ip_invariant.  */\n+\n+struct ipa_agg_value\n+{\n+  /* The offset at which the known value is located within the aggregate.  */\n+  HOST_WIDE_INT offset;\n \n-  /* Return true if OTHER describes same agg items.  */\n-  bool equal_to (const ipa_agg_jump_function &other)\n+  /* The known constant.  */\n+  tree value;\n+\n+  /* Return true if OTHER describes same agg value.  */\n+  bool equal_to (const ipa_agg_value &other);\n+};\n+\n+/* Structure describing a set of known offset/value for aggregate.  */\n+\n+struct ipa_agg_value_set\n+{\n+  /* Description of the individual item.  */\n+  vec<ipa_agg_value> items;\n+  /* True if the data was passed by reference (as opposed to by value).  */\n+  bool by_ref;\n+\n+  /* Return true if OTHER describes same agg values.  */\n+  bool equal_to (const ipa_agg_value_set &other)\n   {\n     if (by_ref != other.by_ref)\n       return false;\n-    if (items != NULL && other.items == NULL)\n-      return false;\n-    if (!items)\n-      return other.items == NULL;\n-    if (items->length () != other.items->length ())\n+    if (items.length () != other.items.length ())\n       return false;\n-    for (unsigned int i = 0; i < items->length (); i++)\n-      if (!(*items)[i].equal_to ((*other.items)[i]))\n+    for (unsigned int i = 0; i < items.length (); i++)\n+      if (!items[i].equal_to (other.items[i]))\n \treturn false;\n     return true;\n   }\n+\n+  /* Return true if there is any value for aggregate.  */\n+  bool is_empty () const\n+  {\n+    return items.is_empty ();\n+  }\n+\n+  ipa_agg_value_set copy () const\n+  {\n+    ipa_agg_value_set new_copy;\n+\n+    new_copy.items = items.copy ();\n+    new_copy.by_ref = by_ref;\n+\n+    return new_copy;\n+  }\n+\n+  void release ()\n+  {\n+    items.release ();\n+  }\n };\n \n-typedef struct ipa_agg_jump_function *ipa_agg_jump_function_p;\n+/* Return copy of a vec<ipa_agg_value_set>.  */\n+\n+static inline vec<ipa_agg_value_set>\n+ipa_copy_agg_values (const vec<ipa_agg_value_set> &aggs)\n+{\n+  vec<ipa_agg_value_set> aggs_copy = vNULL;\n+\n+  if (!aggs.is_empty ())\n+    {\n+      ipa_agg_value_set *agg;\n+      int i;\n+\n+      aggs_copy.reserve_exact (aggs.length ());\n+\n+      FOR_EACH_VEC_ELT (aggs, i, agg)\n+\taggs_copy.quick_push (agg->copy ());\n+    }\n+\n+  return aggs_copy;\n+}\n+\n+/* For vec<ipa_agg_value_set>, DO NOT call release(), use below function\n+   instead.  Because ipa_agg_value_set contains a field of vector type, we\n+   should release this child vector in each element before reclaiming the\n+   whole vector.  */\n+\n+static inline void\n+ipa_release_agg_values (vec<ipa_agg_value_set> &aggs)\n+{\n+  ipa_agg_value_set *agg;\n+  int i;\n+\n+  FOR_EACH_VEC_ELT (aggs, i, agg)\n+    agg->release ();\n+  aggs.release ();\n+}\n \n /* Information about zero/non-zero bits.  */\n class GTY(()) ipa_bits\n@@ -193,8 +304,8 @@ class GTY(()) ipa_vr\n    types of jump functions supported.  */\n struct GTY (()) ipa_jump_func\n {\n-  /* Aggregate contants description.  See struct ipa_agg_jump_function and its\n-     description.  */\n+  /* Aggregate jump function description.  See struct ipa_agg_jump_function\n+     and its description.  */\n   struct ipa_agg_jump_function agg;\n \n   /* Information about zero/non-zero bits.  The pointed to structure is shared\n@@ -857,9 +968,9 @@ bool ipa_propagate_indirect_call_infos (struct cgraph_edge *cs,\n \n /* Indirect edge and binfo processing.  */\n tree ipa_get_indirect_edge_target (struct cgraph_edge *ie,\n-\t\t\t\t   vec<tree> ,\n+\t\t\t\t   vec<tree>,\n \t\t\t\t   vec<ipa_polymorphic_call_context>,\n-\t\t\t\t   vec<ipa_agg_jump_function_p>,\n+\t\t\t\t   vec<ipa_agg_value_set>,\n \t\t\t\t   bool *);\n struct cgraph_edge *ipa_make_edge_direct_to_target (struct cgraph_edge *, tree,\n \t\t\t\t\t\t    bool speculative = false);\n@@ -872,7 +983,7 @@ ipa_bits *ipa_get_ipa_bits_for_value (const widest_int &value,\n void ipa_analyze_node (struct cgraph_node *);\n \n /* Aggregate jump function related functions.  */\n-tree ipa_find_agg_cst_for_param (struct ipa_agg_jump_function *agg, tree scalar,\n+tree ipa_find_agg_cst_for_param (struct ipa_agg_value_set *agg, tree scalar,\n \t\t\t\t HOST_WIDE_INT offset, bool by_ref,\n \t\t\t\t bool *from_global_constant = NULL);\n bool ipa_load_from_parm_agg (struct ipa_func_body_info *fbi,\n@@ -918,6 +1029,9 @@ ipa_polymorphic_call_context ipa_context_from_jfunc (ipa_node_params *,\n \t\t\t\t\t\t     cgraph_edge *,\n \t\t\t\t\t\t     int,\n \t\t\t\t\t\t     ipa_jump_func *);\n+ipa_agg_value_set ipa_agg_value_set_from_jfunc (ipa_node_params *,\n+\t\t\t\t\t\tcgraph_node *,\n+\t\t\t\t\t\tipa_agg_jump_function *);\n void ipa_dump_param (FILE *, class ipa_node_params *info, int i);\n void ipa_release_body_info (struct ipa_func_body_info *);\n tree ipa_get_callee_param_type (struct cgraph_edge *e, int i);"}, {"sha": "5b42fc44019d7bb87538d5ab9f755f578418a8b3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb270950acbae6f70e3487a6e63a26c1294656b3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb270950acbae6f70e3487a6e63a26c1294656b3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=eb270950acbae6f70e3487a6e63a26c1294656b3", "patch": "@@ -1,3 +1,9 @@\n+2019-11-14  Feng Xue  <fxue@os.amperecomputing.com>\n+\n+\tPR ipa/91682\n+\t* gcc.dg/ipa/ipcp-agg-10.c: Change dg-scan string.\n+\t* gcc.dg/ipa/ipcp-agg-11.c: New test.\n+\n 2019-11-14  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR ipa/92421"}, {"sha": "c61e96a842bdf58d76926afcc20ea1220ad1d49f", "filename": "gcc/testsuite/gcc.dg/ipa/ipcp-agg-10.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb270950acbae6f70e3487a6e63a26c1294656b3/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-agg-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb270950acbae6f70e3487a6e63a26c1294656b3/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-agg-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-agg-10.c?ref=eb270950acbae6f70e3487a6e63a26c1294656b3", "patch": "@@ -72,7 +72,7 @@ int caller2(void)\n   return sum;\n }\n \n-/* { dg-final { scan-ipa-dump-times \"offset: 0, cst: 1\" 1 \"cp\" } } */\n-/* { dg-final { scan-ipa-dump-times \"offset: 0, cst: 2\" 1 \"cp\" } } */\n-/* { dg-final { scan-ipa-dump-times \"offset: 0, cst: 3\" 1 \"cp\" } } */\n-/* { dg-final { scan-ipa-dump-times \"offset: 64, cst: 4\" 1 \"cp\" } } */\n+/* { dg-final { scan-ipa-dump-times \"offset: 0, type: int, CONST: 1\" 1 \"cp\" } } */\n+/* { dg-final { scan-ipa-dump-times \"offset: 0, type: int, CONST: 2\" 1 \"cp\" } } */\n+/* { dg-final { scan-ipa-dump-times \"offset: 0, type: int, CONST: 3\" 1 \"cp\" } } */\n+/* { dg-final { scan-ipa-dump-times \"offset: 64, type: int, CONST: 4\" 1 \"cp\" } } */"}, {"sha": "3c496eeef39c59513c8cd4db3f7eb52253297580", "filename": "gcc/testsuite/gcc.dg/ipa/ipcp-agg-11.c", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb270950acbae6f70e3487a6e63a26c1294656b3/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-agg-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb270950acbae6f70e3487a6e63a26c1294656b3/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-agg-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-agg-11.c?ref=eb270950acbae6f70e3487a6e63a26c1294656b3", "patch": "@@ -0,0 +1,77 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fno-ipa-sra -fdump-ipa-cp-details -fno-early-inlining\" } */\n+/* { dg-add-options bind_pic_locally } */\n+\n+struct S\n+{\n+  int a, b, c;\n+};\n+\n+void *blah(int, void *);\n+\n+#define foo_body(p)\\\n+{ \\\n+  int i, c = (p)->c; \\\n+  int b = (p)->b; \\\n+  void *v = (void *) (p); \\\n+ \\\n+  for (i= 0; i< c; i++) \\\n+    v = blah(b + i, v); \\\n+}\n+\n+static void __attribute__ ((noinline))\n+foo_v (struct S s)\n+{\n+  foo_body (&s);\n+}\n+\n+static void __attribute__ ((noinline))\n+foo_r (struct S *p)\n+{\n+  foo_body (p);\n+}\n+\n+static void\n+goo_v (int a, int *p)\n+{\n+  struct S s;\n+  s.a = 101;\n+  s.b = a % 7;\n+  s.c = *p + 6;\n+  foo_v (s);\n+}\n+\n+static void\n+goo_r (int a, struct S n)\n+{\n+  struct S s;\n+  s.a = 1;\n+  s.b = a + 5;\n+  s.c = -n.b;\n+  foo_r (&s);\n+}\n+\n+void\n+entry ()\n+{\n+  int a;\n+  int v;\n+  struct S s;\n+\n+  a = 9;\n+  v = 3;\n+  goo_v (a, &v);\n+\n+  a = 100;\n+  s.b = 18;\n+  goo_r (a, s);\n+}\n+\n+/* { dg-final { scan-ipa-dump \"offset: 0, type: int, CONST: 1\" \"cp\" } } */\n+/* { dg-final { scan-ipa-dump \"offset: 32, type: int, PASS THROUGH: 0, op plus_expr 5\" \"cp\" } } */\n+/* { dg-final { scan-ipa-dump \"offset: 64, type: int, LOAD AGG: 1 \\\\\\[offset: 32, by value], op negate_expr\" \"cp\" } } */\n+/* { dg-final { scan-ipa-dump \"offset: 0, type: int, CONST: 101\" \"cp\" } } */\n+/* { dg-final { scan-ipa-dump \"offset: 32, type: int, PASS THROUGH: 0, op trunc_mod_expr 7\" \"cp\" } } */\n+/* { dg-final { scan-ipa-dump \"offset: 64, type: int, LOAD AGG: 1 \\\\\\[offset: 0, by reference], op plus_expr 6\" \"cp\" } } */\n+/* { dg-final { scan-ipa-dump \"Aggregate replacements: 0\\\\\\[0]=1, 0\\\\\\[32]=105, 0\\\\\\[64]=-18\" \"cp\" } } */\n+/* { dg-final { scan-ipa-dump \"Aggregate replacements: 0\\\\\\[0]=101, 0\\\\\\[32]=2, 0\\\\\\[64]=9\" \"cp\" } } */"}]}