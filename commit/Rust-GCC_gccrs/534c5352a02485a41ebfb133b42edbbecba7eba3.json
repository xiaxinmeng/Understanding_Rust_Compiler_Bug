{"sha": "534c5352a02485a41ebfb133b42edbbecba7eba3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTM0YzUzNTJhMDI0ODVhNDFlYmZiMTMzYjQyZWRiYmVjYmE3ZWJhMw==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-09-17T13:48:35Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-09-17T18:06:15Z"}, "message": "Provide a relation oracle for paths.\n\nThis provides a path_oracle class which can optionally be used in conjunction\nwith another oracle to track relations on a path as it is walked.\n\n\t* value-relation.cc (class equiv_chain): Move to header file.\n\t(path_oracle::path_oracle): New.\n\t(path_oracle::~path_oracle): New.\n\t(path_oracle::register_relation): New.\n\t(path_oracle::query_relation): New.\n\t(path_oracle::reset_path): New.\n\t(path_oracle::dump): New.\n\t* value-relation.h (class equiv_chain): Move to here.\n\t(class path_oracle): New.", "tree": {"sha": "ccb6e2e2a07b87cd0ddd33df9553e1eea6eab188", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ccb6e2e2a07b87cd0ddd33df9553e1eea6eab188"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/534c5352a02485a41ebfb133b42edbbecba7eba3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/534c5352a02485a41ebfb133b42edbbecba7eba3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/534c5352a02485a41ebfb133b42edbbecba7eba3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/534c5352a02485a41ebfb133b42edbbecba7eba3/comments", "author": null, "committer": null, "parents": [{"sha": "3674d8e6fc6305507ed50b501f049f25f868458a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3674d8e6fc6305507ed50b501f049f25f868458a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3674d8e6fc6305507ed50b501f049f25f868458a"}], "stats": {"total": 239, "additions": 224, "deletions": 15}, "files": [{"sha": "d370f93d1287abb861164ce874571523ece9d2e4", "filename": "gcc/value-relation.cc", "status": "modified", "additions": 175, "deletions": 13, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/534c5352a02485a41ebfb133b42edbbecba7eba3/gcc%2Fvalue-relation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/534c5352a02485a41ebfb133b42edbbecba7eba3/gcc%2Fvalue-relation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-relation.cc?ref=534c5352a02485a41ebfb133b42edbbecba7eba3", "patch": "@@ -190,9 +190,6 @@ relation_transitive (relation_kind r1, relation_kind r2)\n \n // -------------------------------------------------------------------------\n \n-// This class represents an equivalency set, and contains a link to the next\n-// one in the list to be searched.\n-\n // The very first element in the m_equiv chain is actually just a summary\n // element in which the m_names bitmap is used to indicate that an ssa_name\n // has an equivalence set in this block.\n@@ -201,16 +198,6 @@ relation_transitive (relation_kind r1, relation_kind r2)\n // which has the bit for SSA_NAME set. Then scan for the equivalency set in\n // that block.   No previous lists need be searched.\n \n-class equiv_chain\n-{\n-public:\n-  bitmap m_names;\t\t// ssa-names in equiv set.\n-  basic_block m_bb;\t\t// Block this belongs to\n-  equiv_chain *m_next;\t\t// Next in block list.\n-  void dump (FILE *f) const;\t// Show names in this list.\n-  equiv_chain *find (unsigned ssa);\n-};\n-\n // If SSA has an equivalence in this list, find and return it.\n // Otherwise return NULL.\n \n@@ -1172,3 +1159,178 @@ relation_oracle::debug () const\n {\n   dump (stderr);\n }\n+\n+path_oracle::path_oracle (relation_oracle *oracle)\n+{\n+  m_root = oracle;\n+  bitmap_obstack_initialize (&m_bitmaps);\n+  obstack_init (&m_chain_obstack);\n+\n+  // Initialize header records.\n+  m_equiv.m_names = BITMAP_ALLOC (&m_bitmaps);\n+  m_equiv.m_bb = NULL;\n+  m_equiv.m_next = NULL;\n+  m_relations.m_names = BITMAP_ALLOC (&m_bitmaps);\n+  m_relations.m_head = NULL;\n+}\n+\n+path_oracle::~path_oracle ()\n+{\n+  obstack_free (&m_chain_obstack, NULL);\n+  bitmap_obstack_release (&m_bitmaps);\n+}\n+\n+// Return the equiv set for SSA, and if there isn't one, check for equivs\n+// starting in block BB.\n+\n+const_bitmap\n+path_oracle::equiv_set (tree ssa, basic_block bb)\n+{\n+  // Check the list first.\n+  equiv_chain *ptr = m_equiv.find (SSA_NAME_VERSION (ssa));\n+  if (ptr)\n+    return ptr->m_names;\n+\n+  // Otherwise defer to the root oracle.\n+  if (m_root)\n+    return m_root->equiv_set (ssa, bb);\n+\n+  // Allocate a throw away bitmap if there isn't a root oracle.\n+  bitmap tmp = BITMAP_ALLOC (&m_bitmaps);\n+  bitmap_set_bit (tmp, SSA_NAME_VERSION (ssa));\n+  return tmp;\n+}\n+\n+// Register an equivalence between SSA1 and SSA2 resolving unkowns from\n+// block BB.\n+\n+void\n+path_oracle::register_equiv (basic_block bb, tree ssa1, tree ssa2)\n+{\n+  const_bitmap equiv_1 = equiv_set (ssa1, bb);\n+  const_bitmap equiv_2 = equiv_set (ssa2, bb);\n+\n+  // Check if they are the same set, if so, we're done.\n+  if (bitmap_equal_p (equiv_1, equiv_2))\n+    return;\n+\n+  // Don't mess around, simply create a new record and insert it first.\n+  bitmap b = BITMAP_ALLOC (&m_bitmaps);\n+  bitmap_copy (b, equiv_1);\n+  bitmap_ior_into (b, equiv_2);\n+\n+  equiv_chain *ptr = (equiv_chain *) obstack_alloc (&m_chain_obstack,\n+\t\t\t\t\t\t    sizeof (equiv_chain));\n+  ptr->m_names = b;\n+  ptr->m_bb = NULL;\n+  ptr->m_next = m_equiv.m_next;\n+  m_equiv.m_next = ptr;\n+  bitmap_ior_into (m_equiv.m_names, b);\n+}\n+\n+// Register relation K between SSA1 and SSA2, resolving unknowns by\n+// querying from BB.\n+\n+void\n+path_oracle::register_relation (basic_block bb, relation_kind k, tree ssa1,\n+\t\t\t\ttree ssa2)\n+{\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      value_relation vr (k, ssa1, ssa2);\n+      fprintf (dump_file, \" Registering value_relation (path_oracle) \");\n+      vr.dump (dump_file);\n+      fprintf (dump_file, \" (bb%d)\\n\", bb->index);\n+    }\n+\n+  if (k == EQ_EXPR)\n+    {\n+      register_equiv (bb, ssa1, ssa2);\n+      return;\n+    }\n+\n+  relation_kind curr = query_relation (bb, ssa1, ssa2);\n+  if (curr != VREL_NONE)\n+    k = relation_intersect (curr, k);\n+\n+  bitmap_set_bit (m_relations.m_names, SSA_NAME_VERSION (ssa1));\n+  bitmap_set_bit (m_relations.m_names, SSA_NAME_VERSION (ssa2));\n+  relation_chain *ptr = (relation_chain *) obstack_alloc (&m_chain_obstack,\n+\t\t\t\t\t\t      sizeof (relation_chain));\n+  ptr->set_relation (k, ssa1, ssa2);\n+  ptr->m_next = m_relations.m_head;\n+  m_relations.m_head = ptr;\n+}\n+\n+// Query for a relationship between equiv set B1 and B2, resolving unknowns\n+// starting at block BB.\n+\n+relation_kind\n+path_oracle::query_relation (basic_block bb, const_bitmap b1, const_bitmap b2)\n+{\n+  if (bitmap_equal_p (b1, b2))\n+    return EQ_EXPR;\n+\n+  relation_kind k = m_relations.find_relation (b1, b2);\n+\n+  if (k == VREL_NONE && m_root)\n+    k = m_root->query_relation (bb, b1, b2);\n+\n+  return k;\n+}\n+\n+// Query for a relationship between SSA1 and SSA2, resolving unknowns\n+// starting at block BB.\n+\n+relation_kind\n+path_oracle::query_relation (basic_block bb, tree ssa1, tree ssa2)\n+{\n+  unsigned v1 = SSA_NAME_VERSION (ssa1);\n+  unsigned v2 = SSA_NAME_VERSION (ssa2);\n+\n+  if (v1 == v2)\n+    return EQ_EXPR;\n+\n+  const_bitmap equiv_1 = equiv_set (ssa1, bb);\n+  const_bitmap equiv_2 = equiv_set (ssa2, bb);\n+  if (bitmap_bit_p (equiv_1, v2) && bitmap_bit_p (equiv_2, v1))\n+    return EQ_EXPR;\n+\n+  return query_relation (bb, equiv_1, equiv_2);\n+}\n+\n+// Reset any relations registered on this path.\n+\n+void\n+path_oracle::reset_path ()\n+{\n+  m_equiv.m_next = NULL;\n+  bitmap_clear (m_equiv.m_names);\n+  m_relations.m_head = NULL;\n+  bitmap_clear (m_relations.m_names);\n+}\n+\n+// Dump relation in basic block... Do nothing here.\n+\n+void\n+path_oracle::dump (FILE *, basic_block) const\n+{\n+}\n+\n+// Dump the relations and equivalencies found in the path.\n+\n+void\n+path_oracle::dump (FILE *f) const\n+{\n+  equiv_chain *ptr = m_equiv.m_next;\n+  for (; ptr; ptr = ptr->m_next)\n+    ptr->dump (f);\n+\n+  relation_chain *ptr2 = m_relations.m_head;\n+  for (; ptr2; ptr2 = ptr2->m_next)\n+    {\n+      fprintf (f, \"Relational : \");\n+      ptr2->dump (f);\n+      fprintf (f, \"\\n\");\n+    }\n+}"}, {"sha": "574fdc9efe8ef3668bbbe28914e99b9d3c8bf32c", "filename": "gcc/value-relation.h", "status": "modified", "additions": 49, "deletions": 2, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/534c5352a02485a41ebfb133b42edbbecba7eba3/gcc%2Fvalue-relation.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/534c5352a02485a41ebfb133b42edbbecba7eba3/gcc%2Fvalue-relation.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-relation.h?ref=534c5352a02485a41ebfb133b42edbbecba7eba3", "patch": "@@ -98,8 +98,18 @@ class relation_oracle\n   void debug () const;\n };\n \n-// Declared internally in value-relation.cc\n-class equiv_chain;\n+// This class represents an equivalency set, and contains a link to the next\n+// one in the list to be searched.\n+\n+class equiv_chain\n+{\n+public:\n+  bitmap m_names;\t\t// ssa-names in equiv set.\n+  basic_block m_bb;\t\t// Block this belongs to\n+  equiv_chain *m_next;\t\t// Next in block list.\n+  void dump (FILE *f) const;\t// Show names in this list.\n+  equiv_chain *find (unsigned ssa);\n+};\n \n // The equivalency oracle maintains equivalencies using the dominator tree.\n // Equivalencies apply to an entire basic block.  Equivalencies on edges\n@@ -188,4 +198,41 @@ class dom_oracle : public equiv_oracle\n \n };\n \n+// A path_oracle implements relations in a list.  The only sense of ordering\n+// is the latest registered relation is the first found during a search.\n+// It can be constructed with an optional \"root\" oracle which will be used\n+// to look up any relations not found in the list.\n+// This allows the client to walk paths starting at some block and register\n+// and query relations along that path, ignoring other edges.\n+//\n+// For registering a relation, a query if made of the root oracle if there is\n+// any known relationship at block BB, and it is combined with this new\n+// relation and entered in the list.\n+//\n+// Queries are resolved by looking first in the list, and only if nothing is\n+// found is the root oracle queried at block BB.\n+//\n+// reset_path is used to clear all locally registered paths to initial state.\n+\n+class path_oracle : public relation_oracle\n+{\n+public:\n+  path_oracle (relation_oracle *oracle = NULL);\n+  ~path_oracle ();\n+  const_bitmap equiv_set (tree, basic_block);\n+  void register_relation (basic_block, relation_kind, tree, tree);\n+  relation_kind query_relation (basic_block, tree, tree);\n+  relation_kind query_relation (basic_block, const_bitmap, const_bitmap);\n+  void reset_path ();\n+  void dump (FILE *, basic_block) const;\n+  void dump (FILE *) const;\n+private:\n+  void register_equiv (basic_block bb, tree ssa1, tree ssa2);\n+  equiv_chain m_equiv;\n+  relation_chain_head m_relations;\n+  relation_oracle *m_root;\n+\n+  bitmap_obstack m_bitmaps;\n+  struct obstack m_chain_obstack;\n+};\n #endif  /* GCC_VALUE_RELATION_H */"}]}