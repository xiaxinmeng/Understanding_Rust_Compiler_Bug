{"sha": "10d1986aee47c592f903527bb68546efc557735d", "node_id": "C_kwDOANBUbNoAKDEwZDE5ODZhZWU0N2M1OTJmOTAzNTI3YmI2ODU0NmVmYzU1NzczNWQ", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2022-05-24T22:01:12Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2022-05-24T22:05:50Z"}, "message": "PR middle-end/105604 - ICE: in tree_to_shwi with vla in struct and sprintf\n\ngcc/ChangeLog:\n\n\tPR middle-end/105604\n\t* gimple-ssa-sprintf.cc (set_aggregate_size_and_offset): Add comments.\n\t(get_origin_and_offset_r): Remove null handling.  Handle variable array\n\tsizes.\n\t(get_origin_and_offset): Handle null argument here.  Simplify.\n\t(alias_offset): Update comment.\n\t* pointer-query.cc (field_at_offset): Update comment.  Handle members\n\tof variable-length types.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/105604\n\t* gcc.dg/Wrestrict-24.c: New test.\n\t* gcc.dg/Wrestrict-25.c: New test.\n\t* gcc.dg/Wrestrict-26.c: New test.\n\nCo-authored-by: Richard Biener <rguenther@suse.de>", "tree": {"sha": "15f3867b7b4e5891c79a8c132f9d68bf949249d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/15f3867b7b4e5891c79a8c132f9d68bf949249d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10d1986aee47c592f903527bb68546efc557735d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10d1986aee47c592f903527bb68546efc557735d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10d1986aee47c592f903527bb68546efc557735d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10d1986aee47c592f903527bb68546efc557735d/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1189c03859cefef4fc4fd44d57eb3d4d3348b562", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1189c03859cefef4fc4fd44d57eb3d4d3348b562", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1189c03859cefef4fc4fd44d57eb3d4d3348b562"}], "stats": {"total": 403, "additions": 368, "deletions": 35}, "files": [{"sha": "6bd27302213be0248cf3f7d65c78f206829812a8", "filename": "gcc/gimple-ssa-sprintf.cc", "status": "modified", "additions": 44, "deletions": 33, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d1986aee47c592f903527bb68546efc557735d/gcc%2Fgimple-ssa-sprintf.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d1986aee47c592f903527bb68546efc557735d/gcc%2Fgimple-ssa-sprintf.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-sprintf.cc?ref=10d1986aee47c592f903527bb68546efc557735d", "patch": "@@ -2232,8 +2232,9 @@ format_character (const directive &dir, tree arg, pointer_query &ptr_qry)\n }\n \n /* If TYPE is an array or struct or union, increment *FLDOFF by the starting\n-   offset of the member that *OFF point into and set *FLDSIZE to its size\n-   in bytes and decrement *OFF by the same.  Otherwise do nothing.  */\n+   offset of the member that *OFF points into if one can be determined and\n+   set *FLDSIZE to its size in bytes and decrement *OFF by the same.\n+   Otherwise do nothing.  */\n \n static void\n set_aggregate_size_and_offset (tree type, HOST_WIDE_INT *fldoff,\n@@ -2249,9 +2250,9 @@ set_aggregate_size_and_offset (tree type, HOST_WIDE_INT *fldoff,\n       if (array_elt_at_offset (type, *off, &index, &arrsize))\n \t{\n \t  *fldoff += index;\n-\t  *off -= index;\n \t  *fldsize = arrsize;\n \t}\n+      /* Otherwise leave *FLDOFF et al. unchanged.  */\n     }\n   else if (RECORD_OR_UNION_TYPE_P (type))\n     {\n@@ -2269,11 +2270,12 @@ set_aggregate_size_and_offset (tree type, HOST_WIDE_INT *fldoff,\n \t  *fldoff += index;\n \t  *off -= index;\n \t}\n+      /* Otherwise leave *FLDOFF et al. unchanged.  */\n     }\n }\n \n-/* For an expression X of pointer type, recursively try to find the same\n-   origin (object or pointer) as Y it references and return such a Y.\n+/* For an expression X of pointer type, recursively try to find its origin\n+   (either object DECL or pointer such as PARM_DECL) Y and return such a Y.\n    When X refers to an array element or struct member, set *FLDOFF to\n    the offset of the element or member from the beginning of the \"most\n    derived\" object and *FLDSIZE to its size.  When nonnull, set *OFF to\n@@ -2284,9 +2286,6 @@ static tree\n get_origin_and_offset_r (tree x, HOST_WIDE_INT *fldoff, HOST_WIDE_INT *fldsize,\n \t\t\t HOST_WIDE_INT *off)\n {\n-  if (!x)\n-    return NULL_TREE;\n-\n   HOST_WIDE_INT sizebuf = -1;\n   if (!fldsize)\n     fldsize = &sizebuf;\n@@ -2308,23 +2307,33 @@ get_origin_and_offset_r (tree x, HOST_WIDE_INT *fldoff, HOST_WIDE_INT *fldsize,\n \n     case ARRAY_REF:\n       {\n-\ttree offset = TREE_OPERAND (x, 1);\n-\tHOST_WIDE_INT idx = (tree_fits_uhwi_p (offset)\n-\t\t\t     ? tree_to_uhwi (offset) : HOST_WIDE_INT_MAX);\n+\ttree sub = TREE_OPERAND (x, 1);\n+\tunsigned HOST_WIDE_INT idx =\n+\t  tree_fits_uhwi_p (sub) ? tree_to_uhwi (sub) : HOST_WIDE_INT_MAX;\n \n-\ttree eltype = TREE_TYPE (x);\n-\tif (TREE_CODE (eltype) == INTEGER_TYPE)\n+\ttree elsz = array_ref_element_size (x);\n+\tunsigned HOST_WIDE_INT elbytes =\n+\t  tree_fits_shwi_p (elsz) ? tree_to_shwi (elsz) : HOST_WIDE_INT_MAX;\n+\n+\tunsigned HOST_WIDE_INT byteoff = idx * elbytes;\n+\n+\tif (byteoff < HOST_WIDE_INT_MAX\n+\t    && elbytes < HOST_WIDE_INT_MAX\n+\t    && byteoff / elbytes == idx)\n \t  {\n+\t    /* For in-bounds constant offsets into constant-sized arrays\n+\t       bump up *OFF, and for what's likely arrays or structs of\n+\t       arrays, also *FLDOFF, as necessary.  */\n \t    if (off)\n-\t      *off = idx;\n+\t      *off += byteoff;\n+\t    if (elbytes > 1)\n+\t      *fldoff += byteoff;\n \t  }\n-\telse if (idx < HOST_WIDE_INT_MAX)\n-\t  *fldoff += idx * int_size_in_bytes (eltype);\n \telse\n-\t  *fldoff = idx;\n+\t  *fldoff = HOST_WIDE_INT_MAX;\n \n \tx = TREE_OPERAND (x, 0);\n-\treturn get_origin_and_offset_r (x, fldoff, fldsize, nullptr);\n+\treturn get_origin_and_offset_r (x, fldoff, fldsize, off);\n       }\n \n     case MEM_REF:\n@@ -2350,8 +2359,14 @@ get_origin_and_offset_r (tree x, HOST_WIDE_INT *fldoff, HOST_WIDE_INT *fldsize,\n \n     case COMPONENT_REF:\n       {\n+\ttree foff = component_ref_field_offset (x);\n \ttree fld = TREE_OPERAND (x, 1);\n-\t*fldoff += int_byte_position (fld);\n+\tif (!tree_fits_shwi_p (foff)\n+\t    || !tree_fits_shwi_p (DECL_FIELD_BIT_OFFSET (fld)))\n+\t  return x;\n+\t*fldoff += (tree_to_shwi (foff)\n+\t\t    + (tree_to_shwi (DECL_FIELD_BIT_OFFSET (fld))\n+\t\t       / BITS_PER_UNIT));\n \n \tget_origin_and_offset_r (fld, fldoff, fldsize, off);\n \tx = TREE_OPERAND (x, 0);\n@@ -2411,30 +2426,25 @@ get_origin_and_offset_r (tree x, HOST_WIDE_INT *fldoff, HOST_WIDE_INT *fldsize,\n   return x;\n }\n \n-/* Nonrecursive version of the above.  */\n+/* Nonrecursive version of the above.\n+   The function never returns null unless X is null to begin with.  */\n \n static tree\n get_origin_and_offset (tree x, HOST_WIDE_INT *fldoff, HOST_WIDE_INT *off,\n \t\t       HOST_WIDE_INT *fldsize = nullptr)\n {\n+  if (!x)\n+    return NULL_TREE;\n+\n   HOST_WIDE_INT sizebuf;\n   if (!fldsize)\n     fldsize = &sizebuf;\n \n+  /* Invalidate *FLDSIZE.  */\n   *fldsize = -1;\n+  *fldoff = *off = 0;\n \n-  *fldoff = *off = *fldsize = 0;\n-  tree orig = get_origin_and_offset_r (x, fldoff, fldsize, off);\n-  if (!orig)\n-    return NULL_TREE;\n-\n-  if (!*fldoff && *off == *fldsize)\n-    {\n-      *fldoff = *off;\n-      *off = 0;\n-    }\n-\n-  return orig;\n+  return get_origin_and_offset_r (x, fldoff, fldsize, off);\n }\n \n /* If ARG refers to the same (sub)object or array element as described\n@@ -2454,7 +2464,8 @@ alias_offset (tree arg, HOST_WIDE_INT *arg_size,\n     return HOST_WIDE_INT_MIN;\n \n   /* The two arguments may refer to the same object.  If they both refer\n-     to a struct member, see if the members are one and the same.  */\n+     to a struct member, see if the members are one and the same.  If so,\n+     return the offset into the member.  */\n   HOST_WIDE_INT arg_off = 0, arg_fld = 0;\n \n   tree arg_orig = get_origin_and_offset (arg, &arg_fld, &arg_off, arg_size);"}, {"sha": "ae561731216c0a6a96cb3c5791591e830fc90cde", "filename": "gcc/pointer-query.cc", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d1986aee47c592f903527bb68546efc557735d/gcc%2Fpointer-query.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d1986aee47c592f903527bb68546efc557735d/gcc%2Fpointer-query.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpointer-query.cc?ref=10d1986aee47c592f903527bb68546efc557735d", "patch": "@@ -2448,9 +2448,13 @@ field_at_offset (tree type, tree start_after, HOST_WIDE_INT off,\n       /* The offset of FLD within its immediately enclosing structure.  */\n       HOST_WIDE_INT fldpos = next_pos < 0 ? int_byte_position (fld) : next_pos;\n \n+      tree typesize = TYPE_SIZE_UNIT (fldtype);\n+      if (typesize && TREE_CODE (typesize) != INTEGER_CST)\n+\t/* Bail if FLD is a variable length member.  */\n+\treturn NULL_TREE;\n+\n       /* If the size is not available the field is a flexible array\n \t member.  Treat this case as success.  */\n-      tree typesize = TYPE_SIZE_UNIT (fldtype);\n       HOST_WIDE_INT fldsize = (tree_fits_uhwi_p (typesize)\n \t\t\t       ? tree_to_uhwi (typesize)\n \t\t\t       : off);\n@@ -2464,7 +2468,11 @@ field_at_offset (tree type, tree start_after, HOST_WIDE_INT off,\n \t{\n \t  /* If OFF is equal to the offset of the next field continue\n \t     to it and skip the array/struct business below.  */\n-\t  next_pos = int_byte_position (next_fld);\n+\t  tree pos = byte_position (next_fld);\n+\t  if (!tree_fits_shwi_p (pos))\n+\t    /* Bail if NEXT_FLD is a variable length member.  */\n+\t    return NULL_TREE;\n+\t  next_pos = tree_to_shwi (pos);\n \t  *nextoff = *fldoff + next_pos;\n \t  if (*nextoff == off && TREE_CODE (type) != UNION_TYPE)\n \t    continue;"}, {"sha": "d224d80f87ab0a3a0bde3bd241c26c4ef03b006f", "filename": "gcc/testsuite/gcc.dg/Wrestrict-24.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d1986aee47c592f903527bb68546efc557735d/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-24.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d1986aee47c592f903527bb68546efc557735d/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-24.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-24.c?ref=10d1986aee47c592f903527bb68546efc557735d", "patch": "@@ -0,0 +1,35 @@\n+/* PR tree-optimization/105604  - ICE: in tree_to_shwi with vla in struct\n+   and sprintf\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -Wrestrict\" } */\n+\n+extern int sprintf (char*, const char*, ...);\n+\n+extern void* sink (void*, ...);\n+\n+struct {\n+  long users;\n+  long size;\n+  char *data;\n+} * main_trans;\n+\n+void *main___trans_tmp_1;\n+\n+int users = 0;\n+\n+void test (void)\n+{\n+  struct {\n+    long users;\n+    long size;\n+    char *data;\n+    int links[users];\n+    char buf[];\n+  } *trans = sink (0);\n+\n+  trans->data = trans->buf;\n+  main___trans_tmp_1 = trans;\n+  main_trans = main___trans_tmp_1;\n+  sprintf (main_trans->data, \"test\");\n+  sink (main_trans->data);\n+}"}, {"sha": "a15f56d7424ccd0fd3393f3a08f2bbaaa54d6498", "filename": "gcc/testsuite/gcc.dg/Wrestrict-25.c", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d1986aee47c592f903527bb68546efc557735d/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-25.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d1986aee47c592f903527bb68546efc557735d/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-25.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-25.c?ref=10d1986aee47c592f903527bb68546efc557735d", "patch": "@@ -0,0 +1,165 @@\n+/* PR tree-optimization/105604  - ICE: in tree_to_shwi with vla in struct\n+   and sprintf\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -Wrestrict\" } */\n+\n+extern int sprintf (char*, const char*, ...);\n+\n+void* sink (void*);\n+\n+\n+void sprintf_S_a8_an_bn (int n, int i, int j)\n+{\n+  struct {\n+    char a8[8], an[n], bn[n];\n+  } *p = sink (0);\n+\n+  {\n+    char *d = p->a8 + i;\n+    char *s = p->a8;\n+    sprintf (d, \"%s\", s);       // { dg-warning \"argument 3 may overlap\" }\n+    sink (p);\n+  }\n+\n+  {\n+    char *d = p->a8;\n+    char *s = p->a8 + j;\n+    sprintf (d, \"%s\", s);       // { dg-warning \"argument 3 may overlap\" }\n+    sink (p);\n+  }\n+\n+  {\n+    char *d = p->a8 + i;\n+    char *s = p->a8 + j;\n+    sprintf (d, \"%s\", s);       // { dg-warning \"argument 3 may overlap\" }\n+    sink (p);\n+  }\n+\n+  {\n+    char *d = p->a8 + i;\n+    char *s = p->an;\n+    sprintf (d, \"%s\", s);\n+    sink (p);\n+  }\n+\n+  {\n+    char *d = p->a8;\n+    char *s = p->an + j;\n+    sprintf (d, \"%s\", s);\n+    sink (p);\n+  }\n+\n+  {\n+    char *d = p->a8 + i;\n+    char *s = p->an + j;\n+    sprintf (d, \"%s\", s);\n+    sink (p);\n+  }\n+\n+  {\n+    /* The IL makes it impossible to rule out an overlap between\n+       p->a8 + i and p->bn + i so the \"may overlap\" warning triggers.  */\n+    char *d = p->a8 + i;\n+    char *s = p->bn;\n+    sprintf (d, \"%s\", s);       // { dg-bogus \"-Wrestrict\" \"pr??????\" { xfail *-*-* } }\n+    sink (p);\n+  }\n+\n+  {\n+    char *d = p->a8;\n+    char *s = p->bn + j;\n+    sprintf (d, \"%s\", s);       // { dg-bogus \"-Wrestrict\" \"pr??????\" { xfail *-*-* } }\n+    sink (p);\n+  }\n+\n+  {\n+    char *d = p->a8 + i;\n+    char *s = p->bn + j;\n+    sprintf (d, \"%s\", s);       // { dg-bogus \"-Wrestrict\" \"pr??????\" { xfail *-*-* } }\n+    sink (p);\n+  }\n+\n+  {\n+    char *d = p->an + i;\n+    char *s = p->bn;\n+    sprintf (d, \"%s\", s);\n+    sink (p);\n+  }\n+\n+  {\n+    char *d = p->an;\n+    char *s = p->bn + j;\n+    sprintf (d, \"%s\", s);\n+    sink (p);\n+  }\n+\n+  {\n+    char *d = p->an + i;\n+    char *s = p->bn + j;\n+    sprintf (d, \"%s\", s);\n+    sink (p);\n+  }\n+\n+  {\n+    char *d = p->an + i;\n+    char *s = p->a8;\n+    sprintf (d, \"%s\", s);\n+    sink (p);\n+  }\n+\n+  {\n+    char *d = p->an;\n+    char *s = p->a8 + j;\n+    sprintf (d, \"%s\", s);\n+    sink (p);\n+  }\n+\n+  {\n+    char *d = p->an + i;\n+    char *s = p->a8 + j;\n+    sprintf (d, \"%s\", s);\n+    sink (p);\n+  }\n+\n+  {\n+    char *d = p->bn + i;\n+    char *s = p->a8;\n+    sprintf (d, \"%s\", s);       // { dg-bogus \"-Wrestrict\" \"pr??????\" { xfail *-*-* } }\n+    sink (p);\n+  }\n+\n+  {\n+    char *d = p->bn;\n+    char *s = p->a8 + j;\n+    sprintf (d, \"%s\", s);       // { dg-bogus \"-Wrestrict\" \"pr??????\" { xfail *-*-* } }\n+    sink (p);\n+  }\n+\n+  {\n+    char *d = p->bn + i;\n+    char *s = p->a8 + j;\n+    sprintf (d, \"%s\", s);       // { dg-bogus \"-Wrestrict\" \"pr??????\" { xfail *-*-* } }\n+    sink (p);\n+  }\n+\n+  {\n+    char *d = p->bn + i;\n+    char *s = p->bn;\n+    sprintf (d, \"%s\", s);       // { dg-warning \"may overlap\" }\n+    sink (p);\n+  }\n+\n+  {\n+    char *d = p->bn;\n+    char *s = p->bn + j;\n+    sprintf (d, \"%s\", s);       // { dg-warning \"may overlap\" }\n+    sink (p);\n+  }\n+\n+  {\n+    char *d = p->bn + i;\n+    char *s = p->bn + j;\n+    sprintf (d, \"%s\", s);       // { dg-warning \"may overlap\" }\n+    sink (p);\n+  }\n+}"}, {"sha": "a10c426a081af2dec2e26a6f744e9f91df4305a3", "filename": "gcc/testsuite/gcc.dg/Wrestrict-26.c", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d1986aee47c592f903527bb68546efc557735d/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-26.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d1986aee47c592f903527bb68546efc557735d/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-26.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-26.c?ref=10d1986aee47c592f903527bb68546efc557735d", "patch": "@@ -0,0 +1,114 @@\n+/* Verify that sprintf calls with arrays or struct of arrays don't\n+   cause -Wrestrict false positives.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -Wrestrict -ftrack-macro-expansion=0\" } */\n+\n+#define sprintf(d, f, ...) (sprintf (d, f, __VA_ARGS__), sink (d))\n+\n+extern void sink (void*, ...);\n+extern int (sprintf) (char*, const char*, ...);\n+\n+extern char ca[][2][8];\n+\n+void test_array_of_arrays (void)\n+{\n+  sprintf (ca[0][0], \"%s\", ca[0][0]);     // { dg-warning \"-Wrestrict\" }\n+  sprintf (ca[0][0], \"%s\", ca[0][1]);\n+  sprintf (ca[0][0], \"%s\", ca[1][0]);\n+  sprintf (ca[0][0], \"%s\", ca[1][1]);\n+\n+  sprintf (ca[0][1], \"%s\", ca[0][0]);\n+  sprintf (ca[0][1], \"%s\", ca[0][1]);     // { dg-warning \"-Wrestrict\" }\n+  sprintf (ca[0][1], \"%s\", ca[1][0]);\n+  sprintf (ca[0][1], \"%s\", ca[1][1]);\n+\n+  sprintf (ca[1][0], \"%s\", ca[0][0]);\n+  sprintf (ca[1][0], \"%s\", ca[0][1]);\n+  sprintf (ca[1][0], \"%s\", ca[1][0]);     // { dg-warning \"-Wrestrict\" }\n+  sprintf (ca[1][0], \"%s\", ca[1][1]);\n+\n+  sprintf (ca[1][1], \"%s\", ca[0][0]);\n+  sprintf (ca[1][1], \"%s\", ca[0][1]);\n+  sprintf (ca[1][1], \"%s\", ca[1][0]);\n+  sprintf (ca[1][1], \"%s\", ca[1][1]);     // { dg-warning \"-Wrestrict\" }\n+}\n+\n+\n+struct A\n+{\n+  char a[2][2][8];\n+  char b[2][2][8];\n+  char c[2][2][8];\n+};\n+\n+extern struct A aa[][2];\n+\n+void test_array_of_structs (void)\n+{\n+  // Verify that calls with the same elements of the same array trigger\n+  // warnings as expected.\n+  sprintf (aa[0][0].a[0][0], \"%s\", aa[0][0].a[0][0]);     // { dg-warning \"-Wrestrict\" }\n+  sprintf (aa[0][0].a[0][1], \"%s\", aa[0][0].a[0][1]);     // { dg-warning \"-Wrestrict\" }\n+  sprintf (aa[0][0].a[1][0], \"%s\", aa[0][0].a[1][0]);     // { dg-warning \"-Wrestrict\" }\n+  sprintf (aa[0][0].a[1][1], \"%s\", aa[0][0].a[1][1]);     // { dg-warning \"-Wrestrict\" }\n+  sprintf (aa[0][1].a[0][0], \"%s\", aa[0][1].a[0][0]);     // { dg-warning \"-Wrestrict\" }\n+  sprintf (aa[0][1].a[0][1], \"%s\", aa[0][1].a[0][1]);     // { dg-warning \"-Wrestrict\" }\n+  sprintf (aa[0][1].a[1][0], \"%s\", aa[0][1].a[1][0]);     // { dg-warning \"-Wrestrict\" }\n+  sprintf (aa[0][1].a[1][1], \"%s\", aa[0][1].a[1][1]);     // { dg-warning \"-Wrestrict\" }\n+  sprintf (aa[1][0].a[0][0], \"%s\", aa[1][0].a[0][0]);     // { dg-warning \"-Wrestrict\" }\n+  sprintf (aa[1][0].a[0][1], \"%s\", aa[1][0].a[0][1]);     // { dg-warning \"-Wrestrict\" }\n+  sprintf (aa[1][0].a[1][0], \"%s\", aa[1][0].a[1][0]);     // { dg-warning \"-Wrestrict\" }\n+  sprintf (aa[1][0].a[1][1], \"%s\", aa[1][0].a[1][1]);     // { dg-warning \"-Wrestrict\" }\n+  sprintf (aa[1][1].a[0][0], \"%s\", aa[1][1].a[0][0]);     // { dg-warning \"-Wrestrict\" }\n+  sprintf (aa[1][1].a[0][1], \"%s\", aa[1][1].a[0][1]);     // { dg-warning \"-Wrestrict\" }\n+  sprintf (aa[1][1].a[1][0], \"%s\", aa[1][1].a[1][0]);     // { dg-warning \"-Wrestrict\" }\n+  sprintf (aa[1][1].a[1][1], \"%s\", aa[1][1].a[1][1]);     // { dg-warning \"-Wrestrict\" }\n+\n+#define NOWARN()\n+\n+  // Exhaustively verify that calls with different elements of the same\n+  // array don't cause false positives.\n+#undef NOWARN\n+#define NOWARN(D, S)\t\t\t\t\\\n+  sprintf (D[0][0], \"%s\", S[0][0]);\t\t\\\n+  sprintf (D[0][0], \"%s\", S[0][1]);\t\t\\\n+  sprintf (D[0][0], \"%s\", S[1][0]);\t\t\\\n+  sprintf (D[0][0], \"%s\", S[1][1]);\t\t\\\n+  sprintf (D[0][1], \"%s\", S[0][0]);\t\t\\\n+  sprintf (D[0][1], \"%s\", S[0][1]);\t\t\\\n+  sprintf (D[0][1], \"%s\", S[1][0]);\t\t\\\n+  sprintf (D[0][1], \"%s\", S[1][1]);\t\t\\\n+  sprintf (D[1][0], \"%s\", S[0][0]);\t\t\\\n+  sprintf (D[1][0], \"%s\", S[0][1]);\t\t\\\n+  sprintf (D[1][0], \"%s\", S[1][0]);\t\t\\\n+  sprintf (D[1][0], \"%s\", S[1][1]);\t\t\\\n+  sprintf (D[1][1], \"%s\", S[0][0]);\t\t\\\n+  sprintf (D[1][1], \"%s\", S[0][1]);\t\t\\\n+  sprintf (D[1][1], \"%s\", S[1][0]);\t\t\\\n+  sprintf (D[1][1], \"%s\", S[1][1])\n+\n+  NOWARN (aa[0][0].a, aa[0][1].a);\n+  NOWARN (aa[0][0].a, aa[1][0].a);\n+  NOWARN (aa[0][0].a, aa[1][1].a);\n+\n+  NOWARN (aa[0][1].a, aa[0][0].a);\n+  NOWARN (aa[0][1].a, aa[1][0].a);\n+  NOWARN (aa[0][1].a, aa[1][1].a);\n+\n+  NOWARN (aa[1][0].a, aa[0][0].a);\n+  NOWARN (aa[1][0].a, aa[0][1].a);\n+  NOWARN (aa[1][0].a, aa[1][1].a);\n+\n+#define NOWARN_MEM(M1, M2)\t\t\t\\\n+  NOWARN (aa[0][0].M1, aa[0][0].M2);\t\t\\\n+  NOWARN (aa[0][0].M1, aa[0][1].M2);\t\t\\\n+  NOWARN (aa[0][0].M1, aa[1][0].M2);\t\t\\\n+  NOWARN (aa[0][0].M1, aa[1][1].M2)\n+\n+  NOWARN_MEM (a, b);\n+  NOWARN_MEM (a, c);\n+  NOWARN_MEM (b, a);\n+  NOWARN_MEM (b, c);\n+  NOWARN_MEM (c, a);\n+  NOWARN_MEM (c, b);\n+}"}]}