{"sha": "e01d41e553aae24572da3a067347a5f2c02cd620", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTAxZDQxZTU1M2FhZTI0NTcyZGEzYTA2NzM0N2E1ZjJjMDJjZDYyMA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2015-11-05T15:08:08Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2015-11-05T15:08:08Z"}, "message": "gcc/\n2015-11-05  Jakub Jelinek  <jakub@redhat.com>\n\t    Ilya Verbin  <ilya.verbin@intel.com>\n\n\t* builtin-types.def\n\t(BT_FN_VOID_INT_OMPFN_SIZE_PTR_PTR_PTR_UINT_PTR): Remove.\n\t(BT_FN_VOID_INT_OMPFN_SIZE_PTR_PTR_PTR_UINT_PTR_INT_INT): New.\n\t* cgraph.h (enum cgraph_simd_clone_arg_type): Add\n\tSIMD_CLONE_ARG_TYPE_LINEAR_REF_VARIABLE_STEP,\n\tSIMD_CLONE_ARG_TYPE_LINEAR_UVAL_VARIABLE_STEP and\n\tSIMD_CLONE_ARG_TYPE_LINEAR_VAL_VARIABLE_STEP.\n\t(struct cgraph_simd_clone_arg): Adjust comment.\n\t* omp-builtins.def (BUILT_IN_GOMP_TARGET): Rename GOMP_target_41\n\tto GOMP_target_ext.  Add num_teams and thread_limit arguments.\n\t(BUILT_IN_GOMP_TARGET_DATA): Rename GOMP_target_data_41\n\tto GOMP_target_data_ext.\n\t(BUILT_IN_GOMP_TARGET_UPDATE): Rename GOMP_target_update_41\n\tto GOMP_target_update_ext.\n\t(BUILT_IN_GOMP_LOOP_NONMONOTONIC_DYNAMIC_START,\n\tBUILT_IN_GOMP_LOOP_NONMONOTONIC_GUIDED_START,\n\tBUILT_IN_GOMP_LOOP_NONMONOTONIC_DYNAMIC_NEXT,\n\tBUILT_IN_GOMP_LOOP_NONMONOTONIC_GUIDED_NEXT,\n\tBUILT_IN_GOMP_LOOP_ULL_NONMONOTONIC_DYNAMIC_START,\n\tBUILT_IN_GOMP_LOOP_ULL_NONMONOTONIC_GUIDED_START,\n\tBUILT_IN_GOMP_LOOP_ULL_NONMONOTONIC_DYNAMIC_NEXT,\n\tBUILT_IN_GOMP_LOOP_ULL_NONMONOTONIC_GUIDED_NEXT,\n\tBUILT_IN_GOMP_PARALLEL_LOOP_NONMONOTONIC_DYNAMIC,\n\tBUILT_IN_GOMP_PARALLEL_LOOP_NONMONOTONIC_GUIDED): New built-ins.\n\t* tree-core.h (enum omp_clause_schedule_kind): Add\n\tOMP_CLAUSE_SCHEDULE_MASK, OMP_CLAUSE_SCHEDULE_MONOTONIC,\n\tOMP_CLAUSE_SCHEDULE_NONMONOTONIC and change\n\tOMP_CLAUSE_SCHEDULE_LAST value.\n\t* tree.def (OMP_SIMD, CILK_SIMD, CILK_FOR, OMP_DISTRIBUTE,\n\tOMP_TASKLOOP, OACC_LOOP): Add OMP_FOR_ORIG_DECLS argument.\n\t* tree.h (OMP_FOR_ORIG_DECLS): Use OMP_LOOP_CHECK instead of\n\tOMP_FOR_CHECK.  Remove comment.\n\t* tree-pretty-print.c (dump_omp_clause): Handle\n\tGOMP_MAP_FIRSTPRIVATE_REFERENCE and GOMP_MAP_ALWAYS_POINTER.\n\tSimplify.  Print schedule clause modifiers.\n\t* tree-vect-stmts.c (vectorizable_simd_clone_call): Add\n\tSIMD_CLONE_ARG_TYPE_LINEAR_{REF,VAL,UVAL}_VARIABLE_STEP\n\tcases.\n\t* gimplify.c (enum gimplify_omp_var_data): Add GOVD_MAP_ALWAYS_TO.\n\t(omp_default_clause): Tweak for\n\tprivate/firstprivate/is_device_ptr variables on target\n\tconstruct and use_device_ptr on target data.\n\t(omp_check_private): Likewise.\n\t(omp_notice_variable): For references check whether what it refers\n\tto has mappable type, rather than the reference itself.\n\t(omp_is_private): Diagnose linear iteration variables on non-simd\n\tconstructs.\n\t(omp_no_lastprivate): Return true only for Fortran.\n\t(gimplify_scan_omp_clauses): Or in GOVD_MAP_ALWAYS_TO for\n\tGOMP_MAP_ALWAYS_TO or GOMP_MAP_ALWAYS_TOFROM kinds.\n\tAdd support for GOMP_MAP_FIRSTPRIVATE_REFERENCE and\n\tGOMP_MAP_ALWAYS_POINTER, remove old handling of structure element\n\tbased array sections.  Use GOMP_MAP_ALWAYS_P.  Fix up handling of\n\tlastprivate and linear when combined with distribute.  Gimplify\n\tvariable low-bound for array reduction.  Look through\n\tPOINTER_PLUS_EXPR when looking for ADDR_EXPR for array section\n\treductions.\n\t(gimplify_adjust_omp_clauses_1): For implicit references to\n\tvariables with reference type and when not ref to scalar or\n\tref to pointer, map what they refer to using tofrom and\n\tuse GOMP_MAP_FIRSTPRIVATE_REFERENCE for the reference.\n\t(gimplify_adjust_omp_clauses): Remove GOMP_MAP_ALWAYS_POINTER\n\tfrom target exit data.  Handle GOMP_MAP_FIRSTPRIVATE_REFERENCE.\n\tDrop OMP_CLAUSE_MAP_PRIVATE support.  Use GOMP_MAP_ALWAYS_P.\n\tDiagnose the same var on both firstprivate and lastprivate on\n\tdistribute construct.\n\t(gimplify_omp_for): Fix up handling of predetermined\n\tlastprivate or linear iter vars when combined with distribute.\n\t(find_omp_teams, computable_teams_clause, optimize_target_teams): New\n\tfunctions.\n\t(gimplify_omp_workshare): Call optimize_target_teams.\n\t* omp-low.c (struct omp_region): Add sched_modifiers field.\n\t(struct omp_for_data): Likewise.\n\t(omp_any_child_fn_dumped): New variable.\n\t(extract_omp_for_data): Fill in sched_modifiers, and mask out\n\tOMP_CLAUSE_SCHEDULE_KIND bits outside of OMP_CLAUSE_SCHEDULE_MASK\n\tfrom sched_kind.\n\t(determine_parallel_type): Use only OMP_CLAUSE_SCHEDULE_MASK\n\tbits of OMP_CLAUSE_SCHED_KIND.\n\t(scan_sharing_clauses): Handle GOMP_MAP_FIRSTPRIVATE_REFERENCE,\n\tdrop OMP_CLAUSE_MAP_PRIVATE support.  Look through POINTER_PLUS_EXPR\n\tfor array section reductions.\n\t(add_taskreg_looptemp_clauses): Add one extra _looptemp_ clause even\n\tfor distribute parallel for, if there are lastprivate clauses on the\n\tfor.\n\t(lower_rec_input_clauses): Handle non-zero low-bound on array\n\tsection reductions.\n\t(lower_reduction_clauses): Likewise.\n\t(lower_send_clauses): Look through POINTER_PLUS_EXPR\n\tfor array section reductions.\n\t(expand_parallel_call): Use nonmonotonic entrypoints for\n\tnonmonotonic: dynamic/guided.\n\t(expand_omp_taskreg): Call assign_assembler_name_if_neeeded on\n\tchild_fn if current_function_decl has assembler name set, but child_fn\n\tdoes not.  Dump the header and IL of the child function when not in SSA\n\tform.\n\t(expand_omp_target): Likewise.  Pass num_teams and thread_limit\n\targuments to BUILT_IN_GOMP_TARGET.\n\t(expand_omp_for_static_nochunk, expand_omp_for_static_chunk):\n\tInitialize the extra _looptemp_ clause to fd->loop.n2.\n\t(expand_omp_for): Use nonmonotonic entrypoints for\n\tnonmonotonic: dynamic/guided.  Initialize region->sched_modifiers.\n\t(expand_omp): Clear omp_any_child_fn_dumped.  Dump function header\n\tagain if we have dumped any child functions.\n\t(lower_omp_for_lastprivate): Determine the right count variable\n\tfor distribute simd, or distribute parallel for{, simd}.\n\t(lower_omp_target): Handle GOMP_MAP_FIRSTPRIVATE_REFERENCE\n\tand GOMP_MAP_ALWAYS_POINTER.  Drop OMP_CLAUSE_MAP_PRIVATE\n\tsupport.\n\t(simd_clone_clauses_extract): Handle variable step\n\tfor references and arguments passed by reference.\n\t(simd_clone_mangle): Mangle ref/uval/val variable steps.\n\t(simd_clone_adjust_argument_types): Handle\n\tSIMD_CLONE_ARG_TYPE_LINEAR_UVAL_VARIABLE_STEP like\n\tSIMD_CLONE_ARG_TYPE_LINEAR_UVAL_CONSTANT_STEP and\n\tSIMD_CLONE_ARG_TYPE_LINEAR_VAL_VARIABLE_STEP like\n\tSIMD_CLONE_ARG_TYPE_LINEAR_VAL_CONSTANT_STEP.\n\t(simd_clone_linear_addend): New function.\n\t(simd_clone_adjust): Handle variable step like similarly\n\tto constant step, use simd_clone_linear_addend to determine\n\tthe actual step at runtime.\ngcc/c-family/\n2015-11-05  Jakub Jelinek  <jakub@redhat.com>\n\n\t* c-common.h (c_finish_omp_atomic): Add TEST argument.\n\t(c_omp_check_loop_iv, c_omp_check_loop_iv_exprs): New prototypes.\n\t* c-omp.c (c_finish_omp_atomic): Add TEST argument.  Don't call\n\tsave_expr or create_tmp_var* if TEST is true.\n\t(c_finish_omp_for): Store OMP_FOR_ORIG_DECLS always.\n\tDon't call add_stmt here.\n\t(struct c_omp_check_loop_iv_data): New type.\n\t(c_omp_check_loop_iv_r, c_omp_check_loop_iv,\n\tc_omp_check_loop_iv_exprs): New functions.\n\t(c_omp_split_clauses): Adjust for lastprivate being allowed on\n\tdistribute.\n\t(c_omp_declare_simd_clauses_to_numbers): Change\n\tOMP_CLAUSE_LINEAR_VARIABLE_STRIDE OMP_CLAUSE_LINEAR_STEP into numbers.\n\t(c_omp_declare_simd_clauses_to_decls): Similarly change those\n\tfrom numbers to PARM_DECLs.\ngcc/c/\n2015-11-05  Jakub Jelinek  <jakub@redhat.com>\n\t    Ilya Verbin  <ilya.verbin@intel.com>\n\n\t* c-parser.c: Include context.h and gimple-expr.h.\n\t(c_parser_omp_clause_schedule): Parse schedule modifiers, diagnose\n\tmonotonic together with nonmonotonic.\n\t(c_parser_omp_for_loop): Call c_omp_check_loop_iv.  Call add_stmt here.\n\t(OMP_DISTRIBUTE_CLAUSE_MASK): Add lastprivate clause.\n\t(c_parser_omp_target_data, c_parser_omp_target_enter_data,\n\tc_parser_omp_target_exit_data): Allow GOMP_MAP_ALWAYS_POINTER.\n\t(c_parser_omp_target): Likewise.  Evaluate num_teams and thread_limit\n\texpressions on combined target teams before the target.\n\t(c_parser_omp_declare_target): If decl has \"omp declare target\" or\n\t\"omp declare target link\" attribute, and cgraph or varpool node already\n\texists, then set corresponding flags.  Call c_finish_omp_clauses\n\tin the parenthesized extended-list syntax case.\n\t* c-decl.c (c_decl_attributes): Don't diagnose block scope vars inside\n\tdeclare target.\n\t* c-typeck.c (handle_omp_array_sections_1): Allow non-zero low-bound\n\ton OMP_CLAUSE_REDUCTION array sections.\n\t(handle_omp_array_sections): Encode low-bound into the MEM_REF, either\n\tinto the constant offset, or for variable low-bound using\n\tPOINTER_PLUS_EXPR.  For structure element based array sections use\n\tGOMP_MAP_ALWAYS_POINTER instead of GOMP_MAP_FIRSTPRIVATE_POINTER.\n\t(c_finish_omp_clauses): Drop generic_field_head, structure\n\telements are now always mapped even as array section bases,\n\tdiagnose same var in data sharing and mapping clauses.  Diagnose if\n\tlinear step on declare simd is neither a constant nor a uniform\n\tparameter.  Look through POINTER_PLUS_EXPR for array section\n\treductions.  Diagnose the same var or function appearing multiple\n\ttimes on the same directive.  Fix up wording for the to clause if t\n\tis neither a FUNCTION_DECL nor a VAR_DECL.  Diagnose nonmonotonic\n\tmodifier on kinds other than dynamic or guided or nonmonotonic\n\tmodifier together with ordered clause.\ngcc/cp/\n2015-11-05  Jakub Jelinek  <jakub@redhat.com>\n\t    Ilya Verbin  <ilya.verbin@intel.com>\n\n\t* cp-tree.h (finish_omp_for): Add ORIG_INITS argument.\n\t(omp_privatize_field): Add SHARED argument.\n\t* parser.c: Include context.h.\n\t(cp_parser_omp_clause_schedule): Parse schedule\n\tmodifiers, diagnose monotonic together with nonmonotonic.\n\t(cp_parser_omp_clause_linear): Add DECLARE_SIMD argument.  Parse\n\tparameter name as linear step as id-expression rather than expression.\n\t(cp_parser_omp_all_clauses): Adjust caller.\n\t(cp_parser_omp_for_loop_init): Add ORIG_INIT argument,\n\tinitialize it.  Adjust omp_privatize_field caller.\n\t(cp_parser_omp_for_loop): Compute orig_inits, pass it's address\n\tto finish_omp_for.\n\t(OMP_DISTRIBUTE_CLAUSE_MASK): Add lastprivate clause.\n\t(cp_parser_omp_target_data,\n\tcp_parser_omp_target_enter_data,\n\tcp_parser_omp_target_exit_data): Allow GOMP_MAP_ALWAYS_POINTER\n\tand GOMP_MAP_FIRSTPRIVATE_REFERENCE.\n\t(cp_parser_omp_target): Likewise.  Evaluate num_teams and\n\tthread_limit expressions on combined target teams before the target.\n\t(cp_parser_omp_declare_target): If decl has \"omp declare target\" or\n\t\"omp declare target link\" attribute, and cgraph or varpool node already\n\texists, then set corresponding flags.  Call finish_omp_clauses\n\tin the parenthesized extended-list syntax case.  Call\n\tcp_parser_require_pragma_eol instead of cp_parser_skip_to_pragma_eol.\n\t(cp_parser_omp_end_declare_target): Call cp_parser_require_pragma_eol\n\tinstead of cp_parser_skip_to_pragma_eol.\n\t* decl2.c (cplus_decl_attributes): Don't diagnose block scope vars inside\n\tdeclare target.\n\t* pt.c (tsubst_omp_clauses): If OMP_CLAUSE_LINEAR_VARIABLE_STRIDE,\n\tuse tsubst_omp_clause_decl instead of tsubst_expr on\n\tOMP_CLAUSE_LINEAR_STEP.  Handle non-static data members in shared\n\tclauses.\n\t(tsubst_omp_for_iterator): Adjust omp_privatize_field caller.\n\t(tsubst_find_omp_teams): New function.\n\t(tsubst_expr): Evaluate num_teams and thread_limit expressions on\n\tcombined target teams before the target.  Use OMP_FOR_ORIG_DECLS for\n\tall OpenMP/OpenACC/Cilk+ looping constructs.  Adjust finish_omp_for\n\tcaller.\n\t* semantics.c (omp_privatize_field): Add SHARED argument, if true,\n\talways create artificial var and never put it into the hash table\n\tor vector.\n\t(handle_omp_array_sections_1): Adjust omp_privatize_field caller.\n\tAllow non-zero low-bound on OMP_CLAUSE_REDUCTION array sections.\n\t(handle_omp_array_sections): For structure element\n\tbased array sections use GOMP_MAP_ALWAYS_POINTER instead of\n\tGOMP_MAP_FIRSTPRIVATE_POINTER.  Encode low-bound into the MEM_REF,\n\teither into the constant offset, or for variable low-bound using\n\tPOINTER_PLUS_EXPR.\n\t(finish_omp_clauses): Adjust omp_privatize_field caller.  Drop\n\tgeneric_field_head, structure elements are now always mapped even\n\tas array section bases, diagnose same var in data sharing and\n\tmapping clauses.  For references map what they refer to using\n\tGOMP_MAP_ALWAYS_POINTER for structure elements and\n\tGOMP_MAP_FIRSTPRIVATE_REFERENCE otherwise.  Diagnose if linear step\n\ton declare simd is neither a constant nor a uniform parameter.\n\tAllow non-static data members on shared clauses.  Look through\n\tPOINTER_PLUS_EXPR for array section reductions.  Diagnose nonmonotonic\n\tmodifier on kinds other than dynamic or guided or nonmonotonic\n\tmodifier together with ordered clause.  Diagnose the same var or\n\tfunction appearing multiple times on the same directive.  Fix up\n\twording for the to clause if t is neither a FUNCTION_DECL nor a\n\tVAR_DECL, use special wording for OVERLOADs and TEMPLATE_ID_EXPR.\n\t(handle_omp_for_class_iterator): Add ORIG_DECLS argument.  Call\n\tc_omp_check_loop_iv_exprs on cond.\n\t(finish_omp_for): Add ORIG_INITS argument.  Call\n\tc_omp_check_loop_iv_exprs on ORIG_INITS elements.  Adjust\n\thandle_omp_for_class_iterator caller.  Call c_omp_check_loop_iv.\n\tCall add_stmt.\n\t(finish_omp_atomic): Adjust c_finish_omp_atomic caller.\ngcc/fortran/\n2015-11-05  Jakub Jelinek  <jakub@redhat.com>\n\n\t* types.def (BT_FN_VOID_INT_OMPFN_SIZE_PTR_PTR_PTR_UINT_PTR): Remove.\n\t(BT_FN_VOID_INT_OMPFN_SIZE_PTR_PTR_PTR_UINT_PTR_INT_INT): New.\ngcc/testsuite/\n2015-11-05  Jakub Jelinek  <jakub@redhat.com>\n\n\t* c-c++-common/gomp/clauses-2.c (foo): Adjust for diagnostics\n\tof variables in both data sharing and mapping clauses and for\n\tstructure element based array sections being mapped rather than\n\tprivatized.\n\t* c-c++-common/gomp/declare-target-2.c: Add various new tests.  Adjust\n\texpected diagnostics wording in one case.\n\t* c-c++-common/gomp/distribute-1.c: New test.\n\t* c-c++-common/gomp/element-1.c: New test.\n\t* c-c++-common/gomp/pr61486-2.c: Add #pragma omp declare target\n\tand #pragma omp end declare target pair around the function.\n\tChange s from a parameter to a file scope variable.\n\t* c-c++-common/gomp/pr67521.c: Add dg-error directives.\n\t* c-c++-common/gomp/reduction-1.c (foo): Don't expect diagnostics\n\ton non-zero low-bound in reduction array sections.  Add further\n\ttests.\n\t* c-c++-common/gomp/schedule-modifiers-1.c: New test.\n\t* c-c++-common/gomp/target-teams-1.c: New test.\n\t* gcc.dg/gomp/declare-simd-1.c: Add scan-assembler-times directives\n\tfor expected mangling on x86_64/i?86.\n\t* gcc.dg/gomp/declare-simd-3.c: New test.\n\t* gcc.dg/gomp/declare-simd-4.c: New test.\n\t* gcc.dg/gomp/for-20.c: New test.\n\t* gcc.dg/gomp/for-21.c: New test.\n\t* gcc.dg/gomp/for-22.c: New test.\n\t* gcc.dg/gomp/for-23.c: New test.\n\t* gcc.dg/gomp/for-24.c: New test.\n\t* gcc.dg/gomp/linear-1.c: New test.\n\t* gcc.dg/gomp/loop-1.c: New test.\n\t* g++.dg/gomp/atomic-17.C: New test.\n\t* g++.dg/gomp/clause-1.C (T::test): Don't expect error on\n\tnon-static data member in shared clause.  Add single construct.\n\t* g++.dg/gomp/declare-simd-1.C: Add dg-options.  Add\n\tscan-assembler-times directives for expected mangling on x86_64/i?86.\n\t* g++.dg/gomp/declare-simd-3.C: Likewise.\n\t* g++.dg/gomp/declare-simd-4.C: New test.\n\t* g++.dg/gomp/declare-simd-5.C: New test.\n\t* g++.dg/gomp/declare-target-1.C: New test.\n\t* g++.dg/gomp/linear-2.C: New test.\n\t* g++.dg/gomp/loop-1.C: New test.\n\t* g++.dg/gomp/loop-2.C: New test.\n\t* g++.dg/gomp/loop-3.C: New test.\n\t* g++.dg/gomp/member-2.C (B::m2, B::m4): Don't expect error on\n\tnon-static data member in shared clause.\n\t* g++.dg/gomp/member-3.C: New test.\n\t* g++.dg/gomp/member-4.C: New test.\n\t* g++.dg/gomp/pr38639.C (foo): Adjust dg-error.\n\t(bar): Remove dg-message.\n\t* g++.dg/gomp/target-teams-1.C: New test.\ninclude/\n2015-11-05  Jakub Jelinek  <jakub@redhat.com>\n\t    Ilya Verbin  <ilya.verbin@intel.com>\n\n\t* gomp-constants.h (GOMP_MAP_FLAG_SPECIAL_2): Define.\n\t(GOMP_MAP_FLAG_ALWAYS): Remove.\n\t(enum gomp_map_kind): Use GOMP_MAP_FLAG_SPECIAL_2 instead of\n\tGOMP_MAP_FLAG_ALWAYS for GOMP_MAP_ALWAYS_TO, GOMP_MAP_ALWAYS_FROM,\n\tGOMP_MAP_ALWAYS_TOFROM, GOMP_MAP_STRUCT, GOMP_MAP_RELEASE.\n\tAdd GOMP_MAP_ALWAYS_POINTER and GOMP_MAP_FIRSTPRIVATE_REFERENCE.\n\t(GOMP_MAP_ALWAYS_P): Define.\n\t(GOMP_TARGET_FLAG_NOWAIT): Adjust comment.\nlibgomp/\n2015-11-05  Jakub Jelinek  <jakub@redhat.com>\n\t    Ilya Verbin  <ilya.verbin@intel.com>\n\n\t* libgomp_g.h (GOMP_loop_nonmonotonic_dynamic_next,\n\tGOMP_loop_nonmonotonic_dynamic_start,\n\tGOMP_loop_nonmonotonic_guided_next,\n\tGOMP_loop_nonmonotonic_guided_start,\n\tGOMP_loop_ull_nonmonotonic_dynamic_next,\n\tGOMP_loop_ull_nonmonotonic_dynamic_start,\n\tGOMP_loop_ull_nonmonotonic_guided_next,\n\tGOMP_loop_ull_nonmonotonic_guided_start,\n\tGOMP_parallel_loop_nonmonotonic_dynamic,\n\tGOMP_parallel_loop_nonmonotonic_guided): New prototypes.\n\t(GOMP_target_41): Renamed to ...\n\t(GOMP_target_ext): ... this.  Add num_teams and thread_limit\n\targuments.\n\t(GOMP_target_data_41): Renamed to ...\n\t(GOMP_target_data_ext): ... this.\n\t(GOMP_target_update_41): Renamed to ...\n\t(GOMP_target_update_ext): ... this.\n\t* libgomp.map (GOMP_4.5): Export GOMP_target_ext,\n\tGOMP_target_data_ext and GOMP_target_update_ext instead of\n\tGOMP_target_41, GOMP_target_data_41 and GOMP_target_update_41.\n\tExport GOMP_loop_nonmonotonic_dynamic_next,\n\tGOMP_loop_nonmonotonic_dynamic_start,\n\tGOMP_loop_nonmonotonic_guided_next,\n\tGOMP_loop_nonmonotonic_guided_start,\n\tGOMP_loop_ull_nonmonotonic_dynamic_next,\n\tGOMP_loop_ull_nonmonotonic_dynamic_start,\n\tGOMP_loop_ull_nonmonotonic_guided_next,\n\tGOMP_loop_ull_nonmonotonic_guided_start,\n\tGOMP_parallel_loop_nonmonotonic_dynamic and\n\tGOMP_parallel_loop_nonmonotonic_guided.\n\t* loop.c (GOMP_parallel_loop_nonmonotonic_dynamic,\n\tGOMP_parallel_loop_nonmonotonic_guided,\n\tGOMP_loop_nonmonotonic_dynamic_start,\n\tGOMP_loop_nonmonotonic_guided_start,\n\tGOMP_loop_nonmonotonic_dynamic_next,\n\tGOMP_loop_nonmonotonic_guided_next): New aliases or functions.\n\t* loop_ull.c (GOMP_loop_ull_nonmonotonic_dynamic_start,\n\tGOMP_loop_ull_nonmonotonic_guided_start,\n\tGOMP_loop_ull_nonmonotonic_dynamic_next,\n\tGOMP_loop_ull_nonmonotonic_guided_next): Likewise.\n\t* target.c (gomp_map_0len_lookup, gomp_map_val): New inline\n\tfunctions.\n\t(gomp_map_vars): Handle GOMP_MAP_ALWAYS_POINTER.  For\n\tGOMP_MAP_ZERO_LEN_ARRAY_SECTION use gomp_map_0len_lookup.\n\tUse gomp_map_val function.\n\t(gomp_target_fallback_firstprivate): New static function.\n\t(GOMP_target_41): Renamed to ...\n\t(GOMP_target_ext): ... this.  Add num_teams and thread_limit\n\targuments.  Move firstprivate fallback handling into a new\n\tfunction.\n\t(GOMP_target_data_41): Renamed to ...\n\t(GOMP_target_data_ext): ... this.\n\t(GOMP_target_update_41): Renamed to ...\n\t(GOMP_target_update_ext): ... this.\n\t(gomp_exit_data): For GOMP_MAP_*ZERO_LEN* use\n\tgomp_map_0len_lookup instead of gomp_map_lookup.\n\t(omp_target_is_present): Use gomp_map_0len_lookup instead of\n\tgomp_map_lookup.\n\t* testsuite/libgomp.c/target-28.c: Likewise.\n\t* testsuite/libgomp.c/monotonic-1.c: New test.\n\t* testsuite/libgomp.c/monotonic-2.c: New test.\n\t* testsuite/libgomp.c/nonmonotonic-1.c: New test.\n\t* testsuite/libgomp.c/nonmonotonic-2.c: New test.\n\t* testsuite/libgomp.c/pr66199-5.c: New test.\n\t* testsuite/libgomp.c/pr66199-6.c: New test.\n\t* testsuite/libgomp.c/pr66199-7.c: New test.\n\t* testsuite/libgomp.c/pr66199-8.c: New test.\n\t* testsuite/libgomp.c/pr66199-9.c: New test.\n\t* testsuite/libgomp.c/reduction-11.c: New test.\n\t* testsuite/libgomp.c/reduction-12.c: New test.\n\t* testsuite/libgomp.c/reduction-13.c: New test.\n\t* testsuite/libgomp.c/reduction-14.c: New test.\n\t* testsuite/libgomp.c/reduction-15.c: New test.\n\t* testsuite/libgomp.c/target-12.c (main): Adjust for\n\tomp_target_is_present change for one-past-last element.\n\t* testsuite/libgomp.c/target-17.c (foo): Drop tests where\n\tthe same var is both mapped and privatized.\n\t* testsuite/libgomp.c/target-19.c (foo): Adjust for different\n\thandling of zero-length array sections.\n\t* testsuite/libgomp.c/target-28.c: New test.\n\t* testsuite/libgomp.c/target-29.c: New test.\n\t* testsuite/libgomp.c/target-30.c: New test.\n\t* testsuite/libgomp.c/target-teams-1.c: New test.\n\t* testsuite/libgomp.c++/member-6.C: New test.\n\t* testsuite/libgomp.c++/member-7.C: New test.\n\t* testsuite/libgomp.c++/monotonic-1.C: New test.\n\t* testsuite/libgomp.c++/monotonic-2.C: New test.\n\t* testsuite/libgomp.c++/nonmonotonic-1.C: New test.\n\t* testsuite/libgomp.c++/nonmonotonic-2.C: New test.\n\t* testsuite/libgomp.c++/pr66199-3.C: New test.\n\t* testsuite/libgomp.c++/pr66199-4.C: New test.\n\t* testsuite/libgomp.c++/pr66199-5.C: New test.\n\t* testsuite/libgomp.c++/pr66199-6.C: New test.\n\t* testsuite/libgomp.c++/pr66199-7.C: New test.\n\t* testsuite/libgomp.c++/pr66199-8.C: New test.\n\t* testsuite/libgomp.c++/pr66199-9.C: New test.\n\t* testsuite/libgomp.c++/reduction-11.C: New test.\n\t* testsuite/libgomp.c++/reduction-12.C: New test.\n\t* testsuite/libgomp.c++/target-13.C: New test.\n\t* testsuite/libgomp.c++/target-14.C: New test.\n\t* testsuite/libgomp.c++/target-15.C: New test.\n\t* testsuite/libgomp.c++/target-16.C: New test.\n\t* testsuite/libgomp.c++/target-17.C: New test.\n\t* testsuite/libgomp.c++/target-18.C: New test.\n\t* testsuite/libgomp.c++/target-19.C: New test.\n\nCo-Authored-By: Ilya Verbin <ilya.verbin@intel.com>\n\nFrom-SVN: r229814", "tree": {"sha": "88a0767ea20a49ed4ad6baaa5116b7f228580c68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/88a0767ea20a49ed4ad6baaa5116b7f228580c68"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e01d41e553aae24572da3a067347a5f2c02cd620", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e01d41e553aae24572da3a067347a5f2c02cd620", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e01d41e553aae24572da3a067347a5f2c02cd620", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e01d41e553aae24572da3a067347a5f2c02cd620/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bd7519757549bb0f61433767be4587d1d287fbae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd7519757549bb0f61433767be4587d1d287fbae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd7519757549bb0f61433767be4587d1d287fbae"}], "stats": {"total": 8465, "additions": 7896, "deletions": 569}, "files": [{"sha": "81b94ead2fe772f3bc64ad97cb9e11037a3634c4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -1,3 +1,128 @@\n+2015-11-05  Jakub Jelinek  <jakub@redhat.com>\n+\t    Ilya Verbin  <ilya.verbin@intel.com>\n+\n+\t* builtin-types.def\n+\t(BT_FN_VOID_INT_OMPFN_SIZE_PTR_PTR_PTR_UINT_PTR): Remove.\n+\t(BT_FN_VOID_INT_OMPFN_SIZE_PTR_PTR_PTR_UINT_PTR_INT_INT): New.\n+\t* cgraph.h (enum cgraph_simd_clone_arg_type): Add\n+\tSIMD_CLONE_ARG_TYPE_LINEAR_REF_VARIABLE_STEP,\n+\tSIMD_CLONE_ARG_TYPE_LINEAR_UVAL_VARIABLE_STEP and\n+\tSIMD_CLONE_ARG_TYPE_LINEAR_VAL_VARIABLE_STEP.\n+\t(struct cgraph_simd_clone_arg): Adjust comment.\n+\t* omp-builtins.def (BUILT_IN_GOMP_TARGET): Rename GOMP_target_41\n+\tto GOMP_target_ext.  Add num_teams and thread_limit arguments.\n+\t(BUILT_IN_GOMP_TARGET_DATA): Rename GOMP_target_data_41\n+\tto GOMP_target_data_ext.\n+\t(BUILT_IN_GOMP_TARGET_UPDATE): Rename GOMP_target_update_41\n+\tto GOMP_target_update_ext.\n+\t(BUILT_IN_GOMP_LOOP_NONMONOTONIC_DYNAMIC_START,\n+\tBUILT_IN_GOMP_LOOP_NONMONOTONIC_GUIDED_START,\n+\tBUILT_IN_GOMP_LOOP_NONMONOTONIC_DYNAMIC_NEXT,\n+\tBUILT_IN_GOMP_LOOP_NONMONOTONIC_GUIDED_NEXT,\n+\tBUILT_IN_GOMP_LOOP_ULL_NONMONOTONIC_DYNAMIC_START,\n+\tBUILT_IN_GOMP_LOOP_ULL_NONMONOTONIC_GUIDED_START,\n+\tBUILT_IN_GOMP_LOOP_ULL_NONMONOTONIC_DYNAMIC_NEXT,\n+\tBUILT_IN_GOMP_LOOP_ULL_NONMONOTONIC_GUIDED_NEXT,\n+\tBUILT_IN_GOMP_PARALLEL_LOOP_NONMONOTONIC_DYNAMIC,\n+\tBUILT_IN_GOMP_PARALLEL_LOOP_NONMONOTONIC_GUIDED): New built-ins.\n+\t* tree-core.h (enum omp_clause_schedule_kind): Add\n+\tOMP_CLAUSE_SCHEDULE_MASK, OMP_CLAUSE_SCHEDULE_MONOTONIC,\n+\tOMP_CLAUSE_SCHEDULE_NONMONOTONIC and change\n+\tOMP_CLAUSE_SCHEDULE_LAST value.\n+\t* tree.def (OMP_SIMD, CILK_SIMD, CILK_FOR, OMP_DISTRIBUTE,\n+\tOMP_TASKLOOP, OACC_LOOP): Add OMP_FOR_ORIG_DECLS argument.\n+\t* tree.h (OMP_FOR_ORIG_DECLS): Use OMP_LOOP_CHECK instead of\n+\tOMP_FOR_CHECK.  Remove comment.\n+\t* tree-pretty-print.c (dump_omp_clause): Handle\n+\tGOMP_MAP_FIRSTPRIVATE_REFERENCE and GOMP_MAP_ALWAYS_POINTER.\n+\tSimplify.  Print schedule clause modifiers.\n+\t* tree-vect-stmts.c (vectorizable_simd_clone_call): Add\n+\tSIMD_CLONE_ARG_TYPE_LINEAR_{REF,VAL,UVAL}_VARIABLE_STEP\n+\tcases.\n+\t* gimplify.c (enum gimplify_omp_var_data): Add GOVD_MAP_ALWAYS_TO.\n+\t(omp_default_clause): Tweak for\n+\tprivate/firstprivate/is_device_ptr variables on target\n+\tconstruct and use_device_ptr on target data.\n+\t(omp_check_private): Likewise.\n+\t(omp_notice_variable): For references check whether what it refers\n+\tto has mappable type, rather than the reference itself.\n+\t(omp_is_private): Diagnose linear iteration variables on non-simd\n+\tconstructs.\n+\t(omp_no_lastprivate): Return true only for Fortran.\n+\t(gimplify_scan_omp_clauses): Or in GOVD_MAP_ALWAYS_TO for\n+\tGOMP_MAP_ALWAYS_TO or GOMP_MAP_ALWAYS_TOFROM kinds.\n+\tAdd support for GOMP_MAP_FIRSTPRIVATE_REFERENCE and\n+\tGOMP_MAP_ALWAYS_POINTER, remove old handling of structure element\n+\tbased array sections.  Use GOMP_MAP_ALWAYS_P.  Fix up handling of\n+\tlastprivate and linear when combined with distribute.  Gimplify\n+\tvariable low-bound for array reduction.  Look through\n+\tPOINTER_PLUS_EXPR when looking for ADDR_EXPR for array section\n+\treductions.\n+\t(gimplify_adjust_omp_clauses_1): For implicit references to\n+\tvariables with reference type and when not ref to scalar or\n+\tref to pointer, map what they refer to using tofrom and\n+\tuse GOMP_MAP_FIRSTPRIVATE_REFERENCE for the reference.\n+\t(gimplify_adjust_omp_clauses): Remove GOMP_MAP_ALWAYS_POINTER\n+\tfrom target exit data.  Handle GOMP_MAP_FIRSTPRIVATE_REFERENCE.\n+\tDrop OMP_CLAUSE_MAP_PRIVATE support.  Use GOMP_MAP_ALWAYS_P.\n+\tDiagnose the same var on both firstprivate and lastprivate on\n+\tdistribute construct.\n+\t(gimplify_omp_for): Fix up handling of predetermined\n+\tlastprivate or linear iter vars when combined with distribute.\n+\t(find_omp_teams, computable_teams_clause, optimize_target_teams): New\n+\tfunctions.\n+\t(gimplify_omp_workshare): Call optimize_target_teams.\n+\t* omp-low.c (struct omp_region): Add sched_modifiers field.\n+\t(struct omp_for_data): Likewise.\n+\t(omp_any_child_fn_dumped): New variable.\n+\t(extract_omp_for_data): Fill in sched_modifiers, and mask out\n+\tOMP_CLAUSE_SCHEDULE_KIND bits outside of OMP_CLAUSE_SCHEDULE_MASK\n+\tfrom sched_kind.\n+\t(determine_parallel_type): Use only OMP_CLAUSE_SCHEDULE_MASK\n+\tbits of OMP_CLAUSE_SCHED_KIND.\n+\t(scan_sharing_clauses): Handle GOMP_MAP_FIRSTPRIVATE_REFERENCE,\n+\tdrop OMP_CLAUSE_MAP_PRIVATE support.  Look through POINTER_PLUS_EXPR\n+\tfor array section reductions.\n+\t(add_taskreg_looptemp_clauses): Add one extra _looptemp_ clause even\n+\tfor distribute parallel for, if there are lastprivate clauses on the\n+\tfor.\n+\t(lower_rec_input_clauses): Handle non-zero low-bound on array\n+\tsection reductions.\n+\t(lower_reduction_clauses): Likewise.\n+\t(lower_send_clauses): Look through POINTER_PLUS_EXPR\n+\tfor array section reductions.\n+\t(expand_parallel_call): Use nonmonotonic entrypoints for\n+\tnonmonotonic: dynamic/guided.\n+\t(expand_omp_taskreg): Call assign_assembler_name_if_neeeded on\n+\tchild_fn if current_function_decl has assembler name set, but child_fn\n+\tdoes not.  Dump the header and IL of the child function when not in SSA\n+\tform.\n+\t(expand_omp_target): Likewise.  Pass num_teams and thread_limit\n+\targuments to BUILT_IN_GOMP_TARGET.\n+\t(expand_omp_for_static_nochunk, expand_omp_for_static_chunk):\n+\tInitialize the extra _looptemp_ clause to fd->loop.n2.\n+\t(expand_omp_for): Use nonmonotonic entrypoints for\n+\tnonmonotonic: dynamic/guided.  Initialize region->sched_modifiers.\n+\t(expand_omp): Clear omp_any_child_fn_dumped.  Dump function header\n+\tagain if we have dumped any child functions.\n+\t(lower_omp_for_lastprivate): Determine the right count variable\n+\tfor distribute simd, or distribute parallel for{, simd}.\n+\t(lower_omp_target): Handle GOMP_MAP_FIRSTPRIVATE_REFERENCE\n+\tand GOMP_MAP_ALWAYS_POINTER.  Drop OMP_CLAUSE_MAP_PRIVATE\n+\tsupport.\n+\t(simd_clone_clauses_extract): Handle variable step\n+\tfor references and arguments passed by reference.\n+\t(simd_clone_mangle): Mangle ref/uval/val variable steps.\n+\t(simd_clone_adjust_argument_types): Handle\n+\tSIMD_CLONE_ARG_TYPE_LINEAR_UVAL_VARIABLE_STEP like\n+\tSIMD_CLONE_ARG_TYPE_LINEAR_UVAL_CONSTANT_STEP and\n+\tSIMD_CLONE_ARG_TYPE_LINEAR_VAL_VARIABLE_STEP like\n+\tSIMD_CLONE_ARG_TYPE_LINEAR_VAL_CONSTANT_STEP.\n+\t(simd_clone_linear_addend): New function.\n+\t(simd_clone_adjust): Handle variable step like similarly\n+\tto constant step, use simd_clone_linear_addend to determine\n+\tthe actual step at runtime.\n+\n 2015-11-05  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* target.def (goacc.dim_limit): New hook."}, {"sha": "c68fb198c8586e4d61a0c0c63230b967b09f03c8", "filename": "gcc/builtin-types.def", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Fbuiltin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Fbuiltin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltin-types.def?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -547,9 +547,6 @@ DEF_FUNCTION_TYPE_7 (BT_FN_VOID_INT_SIZE_PTR_PTR_PTR_UINT_PTR,\n \t\t     BT_VOID, BT_INT, BT_SIZE, BT_PTR, BT_PTR, BT_PTR, BT_UINT,\n \t\t     BT_PTR)\n \n-DEF_FUNCTION_TYPE_8 (BT_FN_VOID_INT_OMPFN_SIZE_PTR_PTR_PTR_UINT_PTR,\n-\t\t     BT_VOID, BT_INT, BT_PTR_FN_VOID_PTR, BT_SIZE, BT_PTR,\n-\t\t     BT_PTR, BT_PTR, BT_UINT, BT_PTR)\n DEF_FUNCTION_TYPE_8 (BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_LONG_UINT,\n \t\t     BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR, BT_UINT,\n \t\t     BT_LONG, BT_LONG, BT_LONG, BT_LONG, BT_UINT)\n@@ -559,6 +556,10 @@ DEF_FUNCTION_TYPE_9 (BT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT_PTR_INT,\n \t\t     BT_PTR_FN_VOID_PTR_PTR, BT_LONG, BT_LONG,\n \t\t     BT_BOOL, BT_UINT, BT_PTR, BT_INT)\n \n+DEF_FUNCTION_TYPE_10 (BT_FN_VOID_INT_OMPFN_SIZE_PTR_PTR_PTR_UINT_PTR_INT_INT,\n+\t\t      BT_VOID, BT_INT, BT_PTR_FN_VOID_PTR, BT_SIZE, BT_PTR,\n+\t\t      BT_PTR, BT_PTR, BT_UINT, BT_PTR, BT_INT, BT_INT)\n+\n DEF_FUNCTION_TYPE_11 (BT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_UINT_LONG_INT_LONG_LONG_LONG,\n \t\t      BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR,\n \t\t      BT_PTR_FN_VOID_PTR_PTR, BT_LONG, BT_LONG,"}, {"sha": "ffb97c94dfd38ab49c8aa22e690e4ae213da68d7", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -1,3 +1,21 @@\n+2015-11-05  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-common.h (c_finish_omp_atomic): Add TEST argument.\n+\t(c_omp_check_loop_iv, c_omp_check_loop_iv_exprs): New prototypes.\n+\t* c-omp.c (c_finish_omp_atomic): Add TEST argument.  Don't call\n+\tsave_expr or create_tmp_var* if TEST is true.\n+\t(c_finish_omp_for): Store OMP_FOR_ORIG_DECLS always.\n+\tDon't call add_stmt here.\n+\t(struct c_omp_check_loop_iv_data): New type.\n+\t(c_omp_check_loop_iv_r, c_omp_check_loop_iv,\n+\tc_omp_check_loop_iv_exprs): New functions.\n+\t(c_omp_split_clauses): Adjust for lastprivate being allowed on\n+\tdistribute.\n+\t(c_omp_declare_simd_clauses_to_numbers): Change\n+\tOMP_CLAUSE_LINEAR_VARIABLE_STRIDE OMP_CLAUSE_LINEAR_STEP into numbers.\n+\t(c_omp_declare_simd_clauses_to_decls): Similarly change those\n+\tfrom numbers to PARM_DECLs.\n+\n 2015-11-04  Mikhail Maltsev  <maltsevm@gmail.com>\n \n \t* c-omp.c (c_omp_split_clauses): Remove conditional compilation. Use"}, {"sha": "de9768e921419f456bff7dd0f9b4e3a2e4540a7d", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -1262,12 +1262,16 @@ extern tree c_finish_omp_critical (location_t, tree, tree, tree);\n extern tree c_finish_omp_ordered (location_t, tree, tree);\n extern void c_finish_omp_barrier (location_t);\n extern tree c_finish_omp_atomic (location_t, enum tree_code, enum tree_code,\n-\t\t\t\t tree, tree, tree, tree, tree, bool, bool);\n+\t\t\t\t tree, tree, tree, tree, tree, bool, bool,\n+\t\t\t\t bool = false);\n extern void c_finish_omp_flush (location_t);\n extern void c_finish_omp_taskwait (location_t);\n extern void c_finish_omp_taskyield (location_t);\n extern tree c_finish_omp_for (location_t, enum tree_code, tree, tree, tree,\n \t\t\t      tree, tree, tree, tree);\n+extern bool c_omp_check_loop_iv (tree, tree, walk_tree_lh);\n+extern bool c_omp_check_loop_iv_exprs (location_t, tree, tree, tree, tree,\n+\t\t\t\t       walk_tree_lh);\n extern tree c_finish_oacc_wait (location_t, tree, tree);\n extern tree c_oacc_split_loop_clauses (tree, tree *);\n extern void c_omp_split_clauses (location_t, enum tree_code, omp_clause_mask,"}, {"sha": "a51611c88648c3b69413bad24361f3ac45363d06", "filename": "gcc/c-family/c-omp.c", "status": "modified", "additions": 225, "deletions": 16, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Fc-family%2Fc-omp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Fc-family%2Fc-omp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-omp.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -175,12 +175,14 @@ c_finish_omp_taskyield (location_t loc)\n    LOC is the location of the atomic statement.  The value returned\n    is either error_mark_node (if the construct was erroneous) or an\n    OMP_ATOMIC* node which should be added to the current statement\n-   tree with add_stmt.  */\n+   tree with add_stmt.  If TEST is set, avoid calling save_expr\n+   or create_tmp_var*.  */\n \n tree\n c_finish_omp_atomic (location_t loc, enum tree_code code,\n \t\t     enum tree_code opcode, tree lhs, tree rhs,\n-\t\t     tree v, tree lhs1, tree rhs1, bool swapped, bool seq_cst)\n+\t\t     tree v, tree lhs1, tree rhs1, bool swapped, bool seq_cst,\n+\t\t     bool test)\n {\n   tree x, type, addr, pre = NULL_TREE;\n \n@@ -212,8 +214,10 @@ c_finish_omp_atomic (location_t loc, enum tree_code code,\n   addr = build_unary_op (loc, ADDR_EXPR, lhs, 0);\n   if (addr == error_mark_node)\n     return error_mark_node;\n-  addr = save_expr (addr);\n-  if (TREE_CODE (addr) != SAVE_EXPR\n+  if (!test)\n+    addr = save_expr (addr);\n+  if (!test\n+      && TREE_CODE (addr) != SAVE_EXPR\n       && (TREE_CODE (addr) != ADDR_EXPR\n \t  || !VAR_P (TREE_OPERAND (addr, 0))))\n     {\n@@ -269,12 +273,15 @@ c_finish_omp_atomic (location_t loc, enum tree_code code,\n   if (rhs1\n       && VAR_P (rhs1)\n       && VAR_P (lhs)\n-      && rhs1 != lhs)\n+      && rhs1 != lhs\n+      && !test)\n     {\n       if (code == OMP_ATOMIC)\n-\terror_at (loc, \"%<#pragma omp atomic update%> uses two different variables for memory\");\n+\terror_at (loc, \"%<#pragma omp atomic update%> uses two different \"\n+\t\t       \"variables for memory\");\n       else\n-\terror_at (loc, \"%<#pragma omp atomic capture%> uses two different variables for memory\");\n+\terror_at (loc, \"%<#pragma omp atomic capture%> uses two different \"\n+\t\t       \"variables for memory\");\n       return error_mark_node;\n     }\n \n@@ -284,9 +291,10 @@ c_finish_omp_atomic (location_t loc, enum tree_code code,\n \t location, just diagnose different variables.  */\n       if (lhs1 && VAR_P (lhs1) && VAR_P (lhs))\n \t{\n-\t  if (lhs1 != lhs)\n+\t  if (lhs1 != lhs && !test)\n \t    {\n-\t      error_at (loc, \"%<#pragma omp atomic capture%> uses two different variables for memory\");\n+\t      error_at (loc, \"%<#pragma omp atomic capture%> uses two \"\n+\t\t\t     \"different variables for memory\");\n \t      return error_mark_node;\n \t    }\n \t}\n@@ -308,7 +316,8 @@ c_finish_omp_atomic (location_t loc, enum tree_code code,\n \t    x = omit_one_operand_loc (loc, type, x, lhs1addr);\n \t  else\n \t    {\n-\t      x = save_expr (x);\n+\t      if (!test)\n+\t\tx = save_expr (x);\n \t      x = omit_two_operands_loc (loc, type, x, x, lhs1addr);\n \t    }\n \t}\n@@ -683,19 +692,177 @@ c_finish_omp_for (location_t locus, enum tree_code code, tree declv,\n       OMP_FOR_INCR (t) = incrv;\n       OMP_FOR_BODY (t) = body;\n       OMP_FOR_PRE_BODY (t) = pre_body;\n-      if (code == OMP_FOR)\n-\tOMP_FOR_ORIG_DECLS (t) = orig_declv;\n+      OMP_FOR_ORIG_DECLS (t) = orig_declv;\n \n       SET_EXPR_LOCATION (t, locus);\n-      return add_stmt (t);\n+      return t;\n     }\n }\n \n+/* Type for passing data in between c_omp_check_loop_iv and\n+   c_omp_check_loop_iv_r.  */\n+\n+struct c_omp_check_loop_iv_data\n+{\n+  tree declv;\n+  bool fail;\n+  location_t stmt_loc;\n+  location_t expr_loc;\n+  int kind;\n+  walk_tree_lh lh;\n+  hash_set<tree> *ppset;\n+};\n+\n+/* Helper function called via walk_tree, to diagnose uses\n+   of associated loop IVs inside of lb, b and incr expressions\n+   of OpenMP loops.  */\n+   \n+static tree\n+c_omp_check_loop_iv_r (tree *tp, int *walk_subtrees, void *data)\n+{\n+  struct c_omp_check_loop_iv_data *d\n+    = (struct c_omp_check_loop_iv_data *) data;\n+  if (DECL_P (*tp))\n+    {\n+      int i;\n+      for (i = 0; i < TREE_VEC_LENGTH (d->declv); i++)\n+\tif (*tp == TREE_VEC_ELT (d->declv, i))\n+\t  {\n+\t    location_t loc = d->expr_loc;\n+\t    if (loc == UNKNOWN_LOCATION)\n+\t      loc = d->stmt_loc;\n+\t    switch (d->kind)\n+\t      {\n+\t      case 0:\n+\t\terror_at (loc, \"initializer expression refers to \"\n+\t\t\t       \"iteration variable %qD\", *tp);\n+\t\tbreak;\n+\t      case 1:\n+\t\terror_at (loc, \"condition expression refers to \"\n+\t\t\t       \"iteration variable %qD\", *tp);\n+\t\tbreak;\n+\t      case 2:\n+\t\terror_at (loc, \"increment expression refers to \"\n+\t\t\t       \"iteration variable %qD\", *tp);\n+\t\tbreak;\n+\t      }\n+\t    d->fail = true;\n+\t  }\n+    }\n+  /* Don't walk dtors added by C++ wrap_cleanups_r.  */\n+  else if (TREE_CODE (*tp) == TRY_CATCH_EXPR\n+\t   && TRY_CATCH_IS_CLEANUP (*tp))\n+    {\n+      *walk_subtrees = 0;\n+      return walk_tree_1 (&TREE_OPERAND (*tp, 0), c_omp_check_loop_iv_r, data,\n+\t\t\t  d->ppset, d->lh);\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Diagnose invalid references to loop iterators in lb, b and incr\n+   expressions.  */\n+\n+bool\n+c_omp_check_loop_iv (tree stmt, tree declv, walk_tree_lh lh)\n+{\n+  hash_set<tree> pset;\n+  struct c_omp_check_loop_iv_data data;\n+  int i;\n+\n+  data.declv = declv;\n+  data.fail = false;\n+  data.stmt_loc = EXPR_LOCATION (stmt);\n+  data.lh = lh;\n+  data.ppset = &pset;\n+  for (i = 0; i < TREE_VEC_LENGTH (OMP_FOR_INIT (stmt)); i++)\n+    {\n+      tree init = TREE_VEC_ELT (OMP_FOR_INIT (stmt), i);\n+      gcc_assert (TREE_CODE (init) == MODIFY_EXPR);\n+      tree decl = TREE_OPERAND (init, 0);\n+      tree cond = TREE_VEC_ELT (OMP_FOR_COND (stmt), i);\n+      gcc_assert (COMPARISON_CLASS_P (cond));\n+      gcc_assert (TREE_OPERAND (cond, 0) == decl);\n+      tree incr = TREE_VEC_ELT (OMP_FOR_INCR (stmt), i);\n+      data.expr_loc = EXPR_LOCATION (TREE_OPERAND (init, 1));\n+      data.kind = 0;\n+      walk_tree_1 (&TREE_OPERAND (init, 1),\n+\t\t   c_omp_check_loop_iv_r, &data, &pset, lh);\n+      /* Don't warn for C++ random access iterators here, the\n+\t expression then involves the subtraction and always refers\n+\t to the original value.  The C++ FE needs to warn on those\n+\t earlier.  */\n+      if (decl == TREE_VEC_ELT (declv, i))\n+\t{\n+\t  data.expr_loc = EXPR_LOCATION (cond);\n+\t  data.kind = 1;\n+\t  walk_tree_1 (&TREE_OPERAND (cond, 1),\n+\t\t       c_omp_check_loop_iv_r, &data, &pset, lh);\n+\t}\n+      if (TREE_CODE (incr) == MODIFY_EXPR)\n+\t{\n+\t  gcc_assert (TREE_OPERAND (incr, 0) == decl);\n+\t  incr = TREE_OPERAND (incr, 1);\n+\t  data.kind = 2;\n+\t  if (TREE_CODE (incr) == PLUS_EXPR\n+\t      && TREE_OPERAND (incr, 1) == decl)\n+\t    {\n+\t      data.expr_loc = EXPR_LOCATION (TREE_OPERAND (incr, 0));\n+\t      walk_tree_1 (&TREE_OPERAND (incr, 0),\n+\t\t\t   c_omp_check_loop_iv_r, &data, &pset, lh);\n+\t    }\n+\t  else\n+\t    {\n+\t      data.expr_loc = EXPR_LOCATION (TREE_OPERAND (incr, 1));\n+\t      walk_tree_1 (&TREE_OPERAND (incr, 1),\n+\t\t\t   c_omp_check_loop_iv_r, &data, &pset, lh);\n+\t    }\n+\t}\n+    }\n+  return !data.fail;\n+}\n+\n+/* Similar, but allows to check the init or cond expressions individually.  */\n+\n+bool\n+c_omp_check_loop_iv_exprs (location_t stmt_loc, tree declv, tree decl,\n+\t\t\t   tree init, tree cond, walk_tree_lh lh)\n+{\n+  hash_set<tree> pset;\n+  struct c_omp_check_loop_iv_data data;\n+\n+  data.declv = declv;\n+  data.fail = false;\n+  data.stmt_loc = stmt_loc;\n+  data.lh = lh;\n+  data.ppset = &pset;\n+  if (init)\n+    {\n+      data.expr_loc = EXPR_LOCATION (init);\n+      data.kind = 0;\n+      walk_tree_1 (&init,\n+\t\t   c_omp_check_loop_iv_r, &data, &pset, lh);\n+    }\n+  if (cond)\n+    {\n+      gcc_assert (COMPARISON_CLASS_P (cond));\n+      data.expr_loc = EXPR_LOCATION (init);\n+      data.kind = 1;\n+      if (TREE_OPERAND (cond, 0) == decl)\n+\twalk_tree_1 (&TREE_OPERAND (cond, 1),\n+\t\t     c_omp_check_loop_iv_r, &data, &pset, lh);\n+      else\n+\twalk_tree_1 (&TREE_OPERAND (cond, 0),\n+\t\t     c_omp_check_loop_iv_r, &data, &pset, lh);\n+    }\n+  return !data.fail;\n+}\n+\n /* This function splits clauses for OpenACC combined loop\n    constructs.  OpenACC combined loop constructs are:\n    #pragma acc kernels loop\n-   #pragma acc parallel loop\n-*/\n+   #pragma acc parallel loop  */\n \n tree\n c_oacc_split_loop_clauses (tree clauses, tree *not_loop_clauses)\n@@ -972,10 +1139,24 @@ c_omp_split_clauses (location_t loc, enum tree_code code,\n \t      s = C_OMP_CLAUSE_SPLIT_FOR;\n \t    }\n \t  break;\n-\t/* Lastprivate is allowed on for, sections and simd.  In\n+\t/* Lastprivate is allowed on distribute, for, sections and simd.  In\n \t   parallel {for{, simd},sections} we actually want to put it on\n \t   parallel rather than for or sections.  */\n \tcase OMP_CLAUSE_LASTPRIVATE:\n+\t  if (code == OMP_DISTRIBUTE)\n+\t    {\n+\t      s = C_OMP_CLAUSE_SPLIT_DISTRIBUTE;\n+\t      break;\n+\t    }\n+\t  if ((mask & (OMP_CLAUSE_MASK_1\n+\t\t       << PRAGMA_OMP_CLAUSE_DIST_SCHEDULE)) != 0)\n+\t    {\n+\t      c = build_omp_clause (OMP_CLAUSE_LOCATION (clauses),\n+\t\t\t\t    OMP_CLAUSE_LASTPRIVATE);\n+\t      OMP_CLAUSE_DECL (c) = OMP_CLAUSE_DECL (clauses);\n+\t      OMP_CLAUSE_CHAIN (c) = cclauses[C_OMP_CLAUSE_SPLIT_DISTRIBUTE];\n+\t      cclauses[C_OMP_CLAUSE_SPLIT_DISTRIBUTE] = c;\n+\t    }\n \t  if (code == OMP_FOR || code == OMP_SECTIONS)\n \t    {\n \t      if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NUM_THREADS))\n@@ -1212,6 +1393,23 @@ c_omp_declare_simd_clauses_to_numbers (tree parms, tree clauses)\n \t      continue;\n \t    }\n \t  OMP_CLAUSE_DECL (c) = build_int_cst (integer_type_node, idx);\n+\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LINEAR\n+\t      && OMP_CLAUSE_LINEAR_VARIABLE_STRIDE (c))\n+\t    {\n+\t      decl = OMP_CLAUSE_LINEAR_STEP (c);\n+\t      for (arg = parms, idx = 0; arg;\n+\t\t   arg = TREE_CHAIN (arg), idx++)\n+\t\tif (arg == decl)\n+\t\t  break;\n+\t      if (arg == NULL_TREE)\n+\t\t{\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"%qD is not an function argument\", decl);\n+\t\t  continue;\n+\t\t}\n+\t      OMP_CLAUSE_LINEAR_STEP (c)\n+\t\t= build_int_cst (integer_type_node, idx);\n+\t    }\n \t}\n       clvec.safe_push (c);\n     }\n@@ -1249,6 +1447,17 @@ c_omp_declare_simd_clauses_to_decls (tree fndecl, tree clauses)\n \t    break;\n \tgcc_assert (arg);\n \tOMP_CLAUSE_DECL (c) = arg;\n+\tif (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LINEAR\n+\t    && OMP_CLAUSE_LINEAR_VARIABLE_STRIDE (c))\n+\t  {\n+\t    idx = tree_to_shwi (OMP_CLAUSE_LINEAR_STEP (c));\n+\t    for (arg = DECL_ARGUMENTS (fndecl), i = 0; arg;\n+\t\t arg = TREE_CHAIN (arg), i++)\n+\t      if (i == idx)\n+\t\tbreak;\n+\t    gcc_assert (arg);\n+\t    OMP_CLAUSE_LINEAR_STEP (c) = arg;\n+\t  }\n       }\n }\n "}, {"sha": "9c39fd9d46dc1460a1f0a79dd0b3aa11ceab3023", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -1,3 +1,38 @@\n+2015-11-05  Jakub Jelinek  <jakub@redhat.com>\n+\t    Ilya Verbin  <ilya.verbin@intel.com>\n+\n+\t* c-parser.c: Include context.h and gimple-expr.h.\n+\t(c_parser_omp_clause_schedule): Parse schedule modifiers, diagnose\n+\tmonotonic together with nonmonotonic.\n+\t(c_parser_omp_for_loop): Call c_omp_check_loop_iv.  Call add_stmt here.\n+\t(OMP_DISTRIBUTE_CLAUSE_MASK): Add lastprivate clause.\n+\t(c_parser_omp_target_data, c_parser_omp_target_enter_data,\n+\tc_parser_omp_target_exit_data): Allow GOMP_MAP_ALWAYS_POINTER.\n+\t(c_parser_omp_target): Likewise.  Evaluate num_teams and thread_limit\n+\texpressions on combined target teams before the target.\n+\t(c_parser_omp_declare_target): If decl has \"omp declare target\" or\n+\t\"omp declare target link\" attribute, and cgraph or varpool node already\n+\texists, then set corresponding flags.  Call c_finish_omp_clauses\n+\tin the parenthesized extended-list syntax case.\n+\t* c-decl.c (c_decl_attributes): Don't diagnose block scope vars inside\n+\tdeclare target.\n+\t* c-typeck.c (handle_omp_array_sections_1): Allow non-zero low-bound\n+\ton OMP_CLAUSE_REDUCTION array sections.\n+\t(handle_omp_array_sections): Encode low-bound into the MEM_REF, either\n+\tinto the constant offset, or for variable low-bound using\n+\tPOINTER_PLUS_EXPR.  For structure element based array sections use\n+\tGOMP_MAP_ALWAYS_POINTER instead of GOMP_MAP_FIRSTPRIVATE_POINTER.\n+\t(c_finish_omp_clauses): Drop generic_field_head, structure\n+\telements are now always mapped even as array section bases,\n+\tdiagnose same var in data sharing and mapping clauses.  Diagnose if\n+\tlinear step on declare simd is neither a constant nor a uniform\n+\tparameter.  Look through POINTER_PLUS_EXPR for array section\n+\treductions.  Diagnose the same var or function appearing multiple\n+\ttimes on the same directive.  Fix up wording for the to clause if t\n+\tis neither a FUNCTION_DECL nor a VAR_DECL.  Diagnose nonmonotonic\n+\tmodifier on kinds other than dynamic or guided or nonmonotonic\n+\tmodifier together with ordered clause.\n+\n 2015-11-03  Thomas Schwinge  <thomas@codesourcery.com>\n \t    Chung-Lin Tang  <cltang@codesourcery.com>\n "}, {"sha": "8e355bae637e326b3dfcfea5feeadda508713cbf", "filename": "gcc/c/c-decl.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Fc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Fc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -4411,13 +4411,7 @@ c_decl_attributes (tree *node, tree attributes, int flags)\n \t  || TREE_CODE (*node) == FUNCTION_DECL))\n     {\n       if (VAR_P (*node)\n-\t  && ((DECL_CONTEXT (*node)\n-\t       && TREE_CODE (DECL_CONTEXT (*node)) == FUNCTION_DECL)\n-\t      || (current_function_decl && !DECL_EXTERNAL (*node))))\n-\terror (\"%q+D in block scope inside of declare target directive\",\n-\t       *node);\n-      else if (VAR_P (*node)\n-\t       && !lang_hooks.types.omp_mappable_type (TREE_TYPE (*node)))\n+\t  && !lang_hooks.types.omp_mappable_type (TREE_TYPE (*node)))\n \terror (\"%q+D in declare target directive does not have mappable type\",\n \t       *node);\n       else"}, {"sha": "ab324d349c104a2b69cb89aca8ddb8a2e0031e51", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 92, "deletions": 9, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -60,6 +60,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"builtins.h\"\n #include \"gomp-constants.h\"\n #include \"c-family/c-indentation.h\"\n+#include \"gimple-expr.h\"\n+#include \"context.h\"\n \n \f\n /* Initialization routine for this file.  */\n@@ -11574,35 +11576,58 @@ c_parser_omp_clause_reduction (c_parser *parser, tree list)\n \n    OpenMP 4.5:\n    schedule ( schedule-modifier : schedule-kind )\n-   schedule ( schedule-modifier : schedule-kind , expression )\n+   schedule ( schedule-modifier [ , schedule-modifier ] : schedule-kind , expression )\n \n    schedule-modifier:\n-     simd  */\n+     simd\n+     monotonic\n+     nonmonotonic  */\n \n static tree\n c_parser_omp_clause_schedule (c_parser *parser, tree list)\n {\n   tree c, t;\n   location_t loc = c_parser_peek_token (parser)->location;\n+  int modifiers = 0, nmodifiers = 0;\n \n   if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n     return list;\n \n   c = build_omp_clause (loc, OMP_CLAUSE_SCHEDULE);\n \n-  if (c_parser_next_token_is (parser, CPP_NAME))\n+  while (c_parser_next_token_is (parser, CPP_NAME))\n     {\n       tree kind = c_parser_peek_token (parser)->value;\n       const char *p = IDENTIFIER_POINTER (kind);\n-      if (strcmp (\"simd\", p) == 0\n-\t  && c_parser_peek_2nd_token (parser)->type == CPP_COLON)\n+      if (strcmp (\"simd\", p) == 0)\n+\tOMP_CLAUSE_SCHEDULE_SIMD (c) = 1;\n+      else if (strcmp (\"monotonic\", p) == 0)\n+\tmodifiers |= OMP_CLAUSE_SCHEDULE_MONOTONIC;\n+      else if (strcmp (\"nonmonotonic\", p) == 0)\n+\tmodifiers |= OMP_CLAUSE_SCHEDULE_NONMONOTONIC;\n+      else\n+\tbreak;\n+      c_parser_consume_token (parser);\n+      if (nmodifiers++ == 0\n+\t  && c_parser_next_token_is (parser, CPP_COMMA))\n+\tc_parser_consume_token (parser);\n+      else\n \t{\n-\t  OMP_CLAUSE_SCHEDULE_SIMD (c) = 1;\n-\t  c_parser_consume_token (parser);\n-\t  c_parser_consume_token (parser);\n+\t  c_parser_require (parser, CPP_COLON, \"expected %<:%>\");\n+\t  break;\n \t}\n     }\n \n+  if ((modifiers & (OMP_CLAUSE_SCHEDULE_MONOTONIC\n+\t\t    | OMP_CLAUSE_SCHEDULE_NONMONOTONIC))\n+      == (OMP_CLAUSE_SCHEDULE_MONOTONIC\n+\t  | OMP_CLAUSE_SCHEDULE_NONMONOTONIC))\n+    {\n+      error_at (loc, \"both %<monotonic%> and %<nonmonotonic%> modifiers \"\n+\t\t     \"specified\");\n+      modifiers = 0;\n+    }\n+\n   if (c_parser_next_token_is (parser, CPP_NAME))\n     {\n       tree kind = c_parser_peek_token (parser)->value;\n@@ -11668,6 +11693,10 @@ c_parser_omp_clause_schedule (c_parser *parser, tree list)\n     c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n \t\t\t       \"expected %<,%> or %<)%>\");\n \n+  OMP_CLAUSE_SCHEDULE_KIND (c)\n+    = (enum omp_clause_schedule_kind)\n+      (OMP_CLAUSE_SCHEDULE_KIND (c) | modifiers);\n+\n   check_no_duplicate_clause (list, OMP_CLAUSE_SCHEDULE, \"schedule\");\n   OMP_CLAUSE_CHAIN (c) = list;\n   return c;\n@@ -14139,8 +14168,15 @@ c_parser_omp_for_loop (location_t loc, c_parser *parser, enum tree_code code,\n     {\n       stmt = c_finish_omp_for (loc, code, declv, NULL, initv, condv,\n \t\t\t       incrv, body, pre_body);\n+\n+      /* Check for iterators appearing in lb, b or incr expressions.  */\n+      if (stmt && !c_omp_check_loop_iv (stmt, declv, NULL))\n+\tstmt = NULL_TREE;\n+\n       if (stmt)\n \t{\n+\t  add_stmt (stmt);\n+\n \t  if (cclauses != NULL\n \t      && cclauses[C_OMP_CLAUSE_SPLIT_PARALLEL] != NULL)\n \t    {\n@@ -14823,6 +14859,7 @@ c_parser_omp_cancellation_point (c_parser *parser)\n #define OMP_DISTRIBUTE_CLAUSE_MASK\t\t\t\t\\\n \t( (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_PRIVATE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_LASTPRIVATE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DIST_SCHEDULE)\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_COLLAPSE))\n \n@@ -14998,6 +15035,7 @@ c_parser_omp_target_data (location_t loc, c_parser *parser)\n \t    map_seen = 3;\n \t    break;\n \t  case GOMP_MAP_FIRSTPRIVATE_POINTER:\n+\t  case GOMP_MAP_ALWAYS_POINTER:\n \t    break;\n \t  default:\n \t    map_seen |= 1;\n@@ -15131,6 +15169,7 @@ c_parser_omp_target_enter_data (location_t loc, c_parser *parser,\n \t    map_seen = 3;\n \t    break;\n \t  case GOMP_MAP_FIRSTPRIVATE_POINTER:\n+\t  case GOMP_MAP_ALWAYS_POINTER:\n \t    break;\n \t  default:\n \t    map_seen |= 1;\n@@ -15217,6 +15256,7 @@ c_parser_omp_target_exit_data (location_t loc, c_parser *parser,\n \t    map_seen = 3;\n \t    break;\n \t  case GOMP_MAP_FIRSTPRIVATE_POINTER:\n+\t  case GOMP_MAP_ALWAYS_POINTER:\n \t    break;\n \t  default:\n \t    map_seen |= 1;\n@@ -15342,6 +15382,32 @@ c_parser_omp_target (c_parser *parser, enum pragma_context context)\n \t  block = c_end_compound_stmt (loc, block, true);\n \t  if (ret == NULL_TREE)\n \t    return false;\n+\t  if (ccode == OMP_TEAMS)\n+\t    {\n+\t      /* For combined target teams, ensure the num_teams and\n+\t\t thread_limit clause expressions are evaluated on the host,\n+\t\t before entering the target construct.  */\n+\t      tree c;\n+\t      for (c = cclauses[C_OMP_CLAUSE_SPLIT_TEAMS];\n+\t\t   c; c = OMP_CLAUSE_CHAIN (c))\n+\t\tif ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_NUM_TEAMS\n+\t\t     || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_THREAD_LIMIT)\n+\t\t    && TREE_CODE (OMP_CLAUSE_OPERAND (c, 0)) != INTEGER_CST)\n+\t\t  {\n+\t\t    tree expr = OMP_CLAUSE_OPERAND (c, 0);\n+\t\t    tree tmp = create_tmp_var_raw (TREE_TYPE (expr));\n+\t\t    expr = build4 (TARGET_EXPR, TREE_TYPE (expr), tmp,\n+\t\t\t\t   expr, NULL_TREE, NULL_TREE);\n+\t\t    add_stmt (expr);\n+\t\t    OMP_CLAUSE_OPERAND (c, 0) = expr;\n+\t\t    tree tc = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\t\tOMP_CLAUSE_FIRSTPRIVATE);\n+\t\t    OMP_CLAUSE_DECL (tc) = tmp;\n+\t\t    OMP_CLAUSE_CHAIN (tc)\n+\t\t      = cclauses[C_OMP_CLAUSE_SPLIT_TARGET];\n+\t\t    cclauses[C_OMP_CLAUSE_SPLIT_TARGET] = tc;\n+\t\t  }\n+\t    }\n \t  tree stmt = make_node (OMP_TARGET);\n \t  TREE_TYPE (stmt) = void_type_node;\n \t  OMP_TARGET_CLAUSES (stmt) = cclauses[C_OMP_CLAUSE_SPLIT_TARGET];\n@@ -15410,6 +15476,7 @@ c_parser_omp_target (c_parser *parser, enum pragma_context context)\n \t  case GOMP_MAP_ALWAYS_TOFROM:\n \t  case GOMP_MAP_ALLOC:\n \t  case GOMP_MAP_FIRSTPRIVATE_POINTER:\n+\t  case GOMP_MAP_ALWAYS_POINTER:\n \t    break;\n \t  default:\n \t    error_at (OMP_CLAUSE_LOCATION (*pc),\n@@ -15679,6 +15746,7 @@ c_parser_omp_declare_target (c_parser *parser)\n     {\n       clauses = c_parser_omp_var_list_parens (parser, OMP_CLAUSE_TO_DECLARE,\n \t\t\t\t\t      clauses);\n+      clauses = c_finish_omp_clauses (clauses, true);\n       c_parser_skip_to_pragma_eol (parser);\n     }\n   else\n@@ -15712,7 +15780,22 @@ c_parser_omp_declare_target (c_parser *parser)\n \t  continue;\n \t}\n       if (!at1)\n-\tDECL_ATTRIBUTES (t) = tree_cons (id, NULL_TREE, DECL_ATTRIBUTES (t));\n+\t{\n+\t  symtab_node *node = symtab_node::get (t);\n+\t  DECL_ATTRIBUTES (t) = tree_cons (id, NULL_TREE, DECL_ATTRIBUTES (t));\n+\t  if (node != NULL)\n+\t    {\n+\t      node->offloadable = 1;\n+#ifdef ENABLE_OFFLOADING\n+\t      g->have_offload = true;\n+\t      if (is_a <varpool_node *> (node))\n+\t\t{\n+\t\t  vec_safe_push (offload_vars, t);\n+\t\t  node->force_output = 1;\n+\t\t}\n+#endif\n+\t    }\n+\t}\n     }\n }\n "}, {"sha": "ba1a8d862a6be1c47d76f0fda07a0e59f9ca7f44", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 171, "deletions": 37, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -11783,13 +11783,6 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n \t  && (TREE_CODE (length) != INTEGER_CST || integer_onep (length)))\n \tfirst_non_one++;\n     }\n-  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n-      && !integer_zerop (low_bound))\n-    {\n-      error_at (OMP_CLAUSE_LOCATION (c),\n-\t\t\"%<reduction%> array section has to be zero-based\");\n-      return error_mark_node;\n-    }\n   if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n       if (length == NULL_TREE\n@@ -12130,7 +12123,24 @@ handle_omp_array_sections (tree c, bool is_omp)\n \t  tree ptype = build_pointer_type (eltype);\n \t  if (TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE)\n \t    t = build_fold_addr_expr (t);\n-\t  t = build2 (MEM_REF, type, t, build_int_cst (ptype, 0));\n+\t  tree t2 = build_fold_addr_expr (first);\n+\t  t2 = fold_convert_loc (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t ptrdiff_type_node, t2);\n+\t  t2 = fold_build2_loc (OMP_CLAUSE_LOCATION (c), MINUS_EXPR,\n+\t\t\t\tptrdiff_type_node, t2,\n+\t\t\t\tfold_convert_loc (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\t\t  ptrdiff_type_node, t));\n+\t  t2 = c_fully_fold (t2, false, NULL);\n+\t  if (tree_fits_shwi_p (t2))\n+\t    t = build2 (MEM_REF, type, t,\n+\t\t\tbuild_int_cst (ptype, tree_to_shwi (t2)));\n+\t  else\n+\t    {\n+\t      t2 = fold_convert_loc (OMP_CLAUSE_LOCATION (c), sizetype, t2);\n+\t      t = build2_loc (OMP_CLAUSE_LOCATION (c), POINTER_PLUS_EXPR,\n+\t\t\t      TREE_TYPE (t), t, t2);\n+\t      t = build2 (MEM_REF, type, t, build_int_cst (ptype, 0));\n+\t    }\n \t  OMP_CLAUSE_DECL (c) = t;\n \t  return false;\n \t}\n@@ -12162,10 +12172,14 @@ handle_omp_array_sections (tree c, bool is_omp)\n \t    break;\n \t  }\n       tree c2 = build_omp_clause (OMP_CLAUSE_LOCATION (c), OMP_CLAUSE_MAP);\n-      OMP_CLAUSE_SET_MAP_KIND (c2, is_omp\n-\t\t\t\t   ? GOMP_MAP_FIRSTPRIVATE_POINTER\n-\t\t\t\t   : GOMP_MAP_POINTER);\n-      if (!is_omp && !c_mark_addressable (t))\n+      if (!is_omp)\n+\tOMP_CLAUSE_SET_MAP_KIND (c2, GOMP_MAP_POINTER);\n+      else if (TREE_CODE (t) == COMPONENT_REF)\n+\tOMP_CLAUSE_SET_MAP_KIND (c2, GOMP_MAP_ALWAYS_POINTER);\n+      else\n+\tOMP_CLAUSE_SET_MAP_KIND (c2, GOMP_MAP_FIRSTPRIVATE_POINTER);\n+      if (OMP_CLAUSE_MAP_KIND (c2) != GOMP_MAP_FIRSTPRIVATE_POINTER\n+\t  && !c_mark_addressable (t))\n \treturn false;\n       OMP_CLAUSE_DECL (c2) = t;\n       t = build_fold_addr_expr (first);\n@@ -12233,12 +12247,15 @@ tree\n c_finish_omp_clauses (tree clauses, bool is_omp, bool declare_simd)\n {\n   bitmap_head generic_head, firstprivate_head, lastprivate_head;\n-  bitmap_head aligned_head, map_head, map_field_head, generic_field_head;\n+  bitmap_head aligned_head, map_head, map_field_head;\n   tree c, t, type, *pc;\n   tree simdlen = NULL_TREE, safelen = NULL_TREE;\n   bool branch_seen = false;\n   bool copyprivate_seen = false;\n+  bool linear_variable_step_check = false;\n   tree *nowait_clause = NULL;\n+  bool ordered_seen = false;\n+  tree schedule_clause = NULL_TREE;\n \n   bitmap_obstack_initialize (NULL);\n   bitmap_initialize (&generic_head, &bitmap_default_obstack);\n@@ -12247,7 +12264,6 @@ c_finish_omp_clauses (tree clauses, bool is_omp, bool declare_simd)\n   bitmap_initialize (&aligned_head, &bitmap_default_obstack);\n   bitmap_initialize (&map_head, &bitmap_default_obstack);\n   bitmap_initialize (&map_field_head, &bitmap_default_obstack);\n-  bitmap_initialize (&generic_field_head, &bitmap_default_obstack);\n \n   for (pc = &clauses, c = clauses; c ; c = *pc)\n     {\n@@ -12468,6 +12484,8 @@ c_finish_omp_clauses (tree clauses, bool is_omp, bool declare_simd)\n \t\t  break;\n \t\t}\n \t      t = TREE_OPERAND (t, 0);\n+\t      if (TREE_CODE (t) == POINTER_PLUS_EXPR)\n+\t\tt = TREE_OPERAND (t, 0);\n \t      if (TREE_CODE (t) == ADDR_EXPR)\n \t\tt = TREE_OPERAND (t, 0);\n \t    }\n@@ -12517,6 +12535,27 @@ c_finish_omp_clauses (tree clauses, bool is_omp, bool declare_simd)\n \t      remove = true;\n \t      break;\n \t    }\n+\t  if (declare_simd)\n+\t    {\n+\t      tree s = OMP_CLAUSE_LINEAR_STEP (c);\n+\t      if (TREE_CODE (s) == PARM_DECL)\n+\t\t{\n+\t\t  OMP_CLAUSE_LINEAR_VARIABLE_STRIDE (c) = 1;\n+\t\t  /* map_head bitmap is used as uniform_head if\n+\t\t     declare_simd.  */\n+\t\t  if (!bitmap_bit_p (&map_head, DECL_UID (s)))\n+\t\t    linear_variable_step_check = true;\n+\t\t  goto check_dup_generic;\n+\t\t}\n+\t      if (TREE_CODE (s) != INTEGER_CST)\n+\t\t{\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"%<linear%> clause step %qE is neither constant \"\n+\t\t\t    \"nor a parameter\", s);\n+\t\t  remove = true;\n+\t\t  break;\n+\t\t}\n+\t    }\n \t  if (TREE_CODE (TREE_TYPE (OMP_CLAUSE_DECL (c))) == POINTER_TYPE)\n \t    {\n \t      tree s = OMP_CLAUSE_LINEAR_STEP (c);\n@@ -12553,6 +12592,12 @@ c_finish_omp_clauses (tree clauses, bool is_omp, bool declare_simd)\n \t\t\t\"%qE appears more than once in data clauses\", t);\n \t      remove = true;\n \t    }\n+\t  else if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_PRIVATE\n+\t\t   && bitmap_bit_p (&map_head, DECL_UID (t)))\n+\t    {\n+\t      error (\"%qD appears both in data and map clauses\", t);\n+\t      remove = true;\n+\t    }\n \t  else\n \t    bitmap_set_bit (&generic_head, DECL_UID (t));\n \t  break;\n@@ -12574,6 +12619,11 @@ c_finish_omp_clauses (tree clauses, bool is_omp, bool declare_simd)\n \t\t\t\"%qE appears more than once in data clauses\", t);\n \t      remove = true;\n \t    }\n+\t  else if (bitmap_bit_p (&map_head, DECL_UID (t)))\n+\t    {\n+\t      error (\"%qD appears both in data and map clauses\", t);\n+\t      remove = true;\n+\t    }\n \t  else\n \t    bitmap_set_bit (&firstprivate_head, DECL_UID (t));\n \t  break;\n@@ -12767,14 +12817,7 @@ c_finish_omp_clauses (tree clauses, bool is_omp, bool declare_simd)\n \t\tbreak;\n \t      if (VAR_P (t) || TREE_CODE (t) == PARM_DECL)\n \t\t{\n-\t\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n-\t\t      && (OMP_CLAUSE_MAP_KIND (c)\n-\t\t\t  == GOMP_MAP_FIRSTPRIVATE_POINTER))\n-\t\t    {\n-\t\t      if (bitmap_bit_p (&generic_field_head, DECL_UID (t)))\n-\t\t\tbreak;\n-\t\t    }\n-\t\t  else if (bitmap_bit_p (&map_field_head, DECL_UID (t)))\n+\t\t  if (bitmap_bit_p (&map_field_head, DECL_UID (t)))\n \t\t    break;\n \t\t}\n \t    }\n@@ -12817,13 +12860,13 @@ c_finish_omp_clauses (tree clauses, bool is_omp, bool declare_simd)\n \t\t  error (\"%qD appears more than once in data clauses\", t);\n \t\t  remove = true;\n \t\t}\n-\t      else\n+\t      else if (bitmap_bit_p (&map_head, DECL_UID (t)))\n \t\t{\n-\t\t  bitmap_set_bit (&generic_head, DECL_UID (t));\n-\t\t  if (t != OMP_CLAUSE_DECL (c)\n-\t\t      && TREE_CODE (OMP_CLAUSE_DECL (c)) == COMPONENT_REF)\n-\t\t    bitmap_set_bit (&generic_field_head, DECL_UID (t));\n+\t\t  error (\"%qD appears both in data and map clauses\", t);\n+\t\t  remove = true;\n \t\t}\n+\t      else\n+\t\tbitmap_set_bit (&generic_head, DECL_UID (t));\n \t    }\n \t  else if (bitmap_bit_p (&map_head, DECL_UID (t)))\n \t    {\n@@ -12833,6 +12876,12 @@ c_finish_omp_clauses (tree clauses, bool is_omp, bool declare_simd)\n \t\terror (\"%qD appears more than once in map clauses\", t);\n \t      remove = true;\n \t    }\n+\t  else if (bitmap_bit_p (&generic_head, DECL_UID (t))\n+\t\t   || bitmap_bit_p (&firstprivate_head, DECL_UID (t)))\n+\t    {\n+\t      error (\"%qD appears both in data and map clauses\", t);\n+\t      remove = true;\n+\t    }\n \t  else\n \t    {\n \t      bitmap_set_bit (&map_head, DECL_UID (t));\n@@ -12843,17 +12892,22 @@ c_finish_omp_clauses (tree clauses, bool is_omp, bool declare_simd)\n \t  break;\n \n \tcase OMP_CLAUSE_TO_DECLARE:\n-\t  t = OMP_CLAUSE_DECL (c);\n-\t  if (TREE_CODE (t) == FUNCTION_DECL)\n-\t    break;\n-\t  /* FALLTHRU */\n \tcase OMP_CLAUSE_LINK:\n \t  t = OMP_CLAUSE_DECL (c);\n-\t  if (!VAR_P (t))\n+\t  if (TREE_CODE (t) == FUNCTION_DECL\n+\t      && OMP_CLAUSE_CODE (c) == OMP_CLAUSE_TO_DECLARE)\n+\t    ;\n+\t  else if (!VAR_P (t))\n \t    {\n-\t      error_at (OMP_CLAUSE_LOCATION (c),\n-\t\t\t\"%qE is not a variable in clause %qs\", t,\n-\t\t\tomp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_TO_DECLARE)\n+\t\terror_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t  \"%qE is neither a variable nor a function name in \"\n+\t\t\t  \"clause %qs\", t,\n+\t\t\t  omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t      else\n+\t\terror_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t  \"%qE is not a variable in clause %qs\", t,\n+\t\t\t  omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n \t      remove = true;\n \t    }\n \t  else if (DECL_THREAD_LOCAL_P (t))\n@@ -12870,6 +12924,17 @@ c_finish_omp_clauses (tree clauses, bool is_omp, bool declare_simd)\n \t\t\tomp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n \t      remove = true;\n \t    }\n+\t  if (remove)\n+\t    break;\n+\t  if (bitmap_bit_p (&generic_head, DECL_UID (t)))\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%qE appears more than once on the same \"\n+\t\t\t\"%<declare target%> directive\", t);\n+\t      remove = true;\n+\t    }\n+\t  else\n+\t    bitmap_set_bit (&generic_head, DECL_UID (t));\n \t  break;\n \n \tcase OMP_CLAUSE_UNIFORM:\n@@ -12885,6 +12950,8 @@ c_finish_omp_clauses (tree clauses, bool is_omp, bool declare_simd)\n \t      remove = true;\n \t      break;\n \t    }\n+\t  /* map_head bitmap is used as uniform_head if declare_simd.  */\n+\t  bitmap_set_bit (&map_head, DECL_UID (t));\n \t  goto check_dup_generic;\n \n \tcase OMP_CLAUSE_IS_DEVICE_PTR:\n@@ -12917,8 +12984,6 @@ c_finish_omp_clauses (tree clauses, bool is_omp, bool declare_simd)\n \tcase OMP_CLAUSE_NUM_THREADS:\n \tcase OMP_CLAUSE_NUM_TEAMS:\n \tcase OMP_CLAUSE_THREAD_LIMIT:\n-\tcase OMP_CLAUSE_SCHEDULE:\n-\tcase OMP_CLAUSE_ORDERED:\n \tcase OMP_CLAUSE_DEFAULT:\n \tcase OMP_CLAUSE_UNTIED:\n \tcase OMP_CLAUSE_COLLAPSE:\n@@ -12953,6 +13018,39 @@ c_finish_omp_clauses (tree clauses, bool is_omp, bool declare_simd)\n \t  pc = &OMP_CLAUSE_CHAIN (c);\n \t  continue;\n \n+\tcase OMP_CLAUSE_SCHEDULE:\n+\t  if (OMP_CLAUSE_SCHEDULE_KIND (c) & OMP_CLAUSE_SCHEDULE_NONMONOTONIC)\n+\t    {\n+\t      const char *p = NULL;\n+\t      switch (OMP_CLAUSE_SCHEDULE_KIND (c) & OMP_CLAUSE_SCHEDULE_MASK)\n+\t\t{\n+\t\tcase OMP_CLAUSE_SCHEDULE_STATIC: p = \"static\"; break;\n+\t\tcase OMP_CLAUSE_SCHEDULE_DYNAMIC: break;\n+\t\tcase OMP_CLAUSE_SCHEDULE_GUIDED: break;\n+\t\tcase OMP_CLAUSE_SCHEDULE_AUTO: p = \"auto\"; break;\n+\t\tcase OMP_CLAUSE_SCHEDULE_RUNTIME: p = \"runtime\"; break;\n+\t\tdefault: gcc_unreachable ();\n+\t\t}\n+\t      if (p)\n+\t\t{\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"%<nonmonotonic%> modifier specified for %qs \"\n+\t\t\t    \"schedule kind\", p);\n+\t\t  OMP_CLAUSE_SCHEDULE_KIND (c)\n+\t\t    = (enum omp_clause_schedule_kind)\n+\t\t      (OMP_CLAUSE_SCHEDULE_KIND (c)\n+\t\t       & ~OMP_CLAUSE_SCHEDULE_NONMONOTONIC);\n+\t\t}\n+\t    }\n+\t  schedule_clause = c;\n+\t  pc = &OMP_CLAUSE_CHAIN (c);\n+\t  continue;\n+\n+\tcase OMP_CLAUSE_ORDERED:\n+\t  ordered_seen = true;\n+\t  pc = &OMP_CLAUSE_CHAIN (c);\n+\t  continue;\n+\n \tcase OMP_CLAUSE_SAFELEN:\n \t  safelen = c;\n \t  pc = &OMP_CLAUSE_CHAIN (c);\n@@ -13043,6 +13141,42 @@ c_finish_omp_clauses (tree clauses, bool is_omp, bool declare_simd)\n \t= OMP_CLAUSE_SAFELEN_EXPR (safelen);\n     }\n \n+  if (ordered_seen\n+      && schedule_clause\n+      && (OMP_CLAUSE_SCHEDULE_KIND (schedule_clause)\n+\t  & OMP_CLAUSE_SCHEDULE_NONMONOTONIC))\n+    {\n+      error_at (OMP_CLAUSE_LOCATION (schedule_clause),\n+\t\t\"%<nonmonotonic%> schedule modifier specified together \"\n+\t\t\"with %<ordered%> clause\");\n+      OMP_CLAUSE_SCHEDULE_KIND (schedule_clause)\n+\t= (enum omp_clause_schedule_kind)\n+\t  (OMP_CLAUSE_SCHEDULE_KIND (schedule_clause)\n+\t   & ~OMP_CLAUSE_SCHEDULE_NONMONOTONIC);\n+    }\n+\n+  if (linear_variable_step_check)\n+    for (pc = &clauses, c = clauses; c ; c = *pc)\n+      {\n+\tbool remove = false;\n+\tif (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LINEAR\n+\t    && OMP_CLAUSE_LINEAR_VARIABLE_STRIDE (c)\n+\t    && !bitmap_bit_p (&map_head,\n+\t\t\t      DECL_UID (OMP_CLAUSE_LINEAR_STEP (c))))\n+\t  {\n+\t    error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t      \"%<linear%> clause step is a parameter %qD not \"\n+\t\t      \"specified in %<uniform%> clause\",\n+\t\t      OMP_CLAUSE_LINEAR_STEP (c));\n+\t    remove = true;\n+\t  }\n+\n+\tif (remove)\n+\t  *pc = OMP_CLAUSE_CHAIN (c);\n+\telse\n+\t  pc = &OMP_CLAUSE_CHAIN (c);\n+      }\n+\n   bitmap_obstack_release (NULL);\n   return clauses;\n }"}, {"sha": "b6390995ab939f530f805f9ceb2e388f9b43cd23", "filename": "gcc/cgraph.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -654,11 +654,14 @@ enum cgraph_simd_clone_arg_type\n   /* These are only for integer/pointer arguments passed by value.  */\n   SIMD_CLONE_ARG_TYPE_LINEAR_CONSTANT_STEP,\n   SIMD_CLONE_ARG_TYPE_LINEAR_VARIABLE_STEP,\n-  /* These 3 are only for reference type arguments or arguments passed\n+  /* These 6 are only for reference type arguments or arguments passed\n      by reference.  */\n   SIMD_CLONE_ARG_TYPE_LINEAR_REF_CONSTANT_STEP,\n+  SIMD_CLONE_ARG_TYPE_LINEAR_REF_VARIABLE_STEP,\n   SIMD_CLONE_ARG_TYPE_LINEAR_UVAL_CONSTANT_STEP,\n+  SIMD_CLONE_ARG_TYPE_LINEAR_UVAL_VARIABLE_STEP,\n   SIMD_CLONE_ARG_TYPE_LINEAR_VAL_CONSTANT_STEP,\n+  SIMD_CLONE_ARG_TYPE_LINEAR_VAL_VARIABLE_STEP,\n   SIMD_CLONE_ARG_TYPE_MASK\n };\n \n@@ -700,7 +703,7 @@ struct GTY(()) cgraph_simd_clone_arg {\n \n   /* For arg_type SIMD_CLONE_ARG_TYPE_LINEAR_*CONSTANT_STEP this is\n      the constant linear step, if arg_type is\n-     SIMD_CLONE_ARG_TYPE_LINEAR_VARIABLE_STEP, this is index of\n+     SIMD_CLONE_ARG_TYPE_LINEAR_*VARIABLE_STEP, this is index of\n      the uniform argument holding the step, otherwise 0.  */\n   HOST_WIDE_INT linear_step;\n "}, {"sha": "3312dae07ea6a22206e0993f5b9bc5ddba08bcae", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -1,3 +1,76 @@\n+2015-11-05  Jakub Jelinek  <jakub@redhat.com>\n+\t    Ilya Verbin  <ilya.verbin@intel.com>\n+\n+\t* cp-tree.h (finish_omp_for): Add ORIG_INITS argument.\n+\t(omp_privatize_field): Add SHARED argument.\n+\t* parser.c: Include context.h.\n+\t(cp_parser_omp_clause_schedule): Parse schedule\n+\tmodifiers, diagnose monotonic together with nonmonotonic.\n+\t(cp_parser_omp_clause_linear): Add DECLARE_SIMD argument.  Parse\n+\tparameter name as linear step as id-expression rather than expression.\n+\t(cp_parser_omp_all_clauses): Adjust caller.\n+\t(cp_parser_omp_for_loop_init): Add ORIG_INIT argument,\n+\tinitialize it.  Adjust omp_privatize_field caller.\n+\t(cp_parser_omp_for_loop): Compute orig_inits, pass it's address\n+\tto finish_omp_for.\n+\t(OMP_DISTRIBUTE_CLAUSE_MASK): Add lastprivate clause.\n+\t(cp_parser_omp_target_data,\n+\tcp_parser_omp_target_enter_data,\n+\tcp_parser_omp_target_exit_data): Allow GOMP_MAP_ALWAYS_POINTER\n+\tand GOMP_MAP_FIRSTPRIVATE_REFERENCE.\n+\t(cp_parser_omp_target): Likewise.  Evaluate num_teams and\n+\tthread_limit expressions on combined target teams before the target.\n+\t(cp_parser_omp_declare_target): If decl has \"omp declare target\" or\n+\t\"omp declare target link\" attribute, and cgraph or varpool node already\n+\texists, then set corresponding flags.  Call finish_omp_clauses\n+\tin the parenthesized extended-list syntax case.  Call\n+\tcp_parser_require_pragma_eol instead of cp_parser_skip_to_pragma_eol.\n+\t(cp_parser_omp_end_declare_target): Call cp_parser_require_pragma_eol\n+\tinstead of cp_parser_skip_to_pragma_eol.\n+\t* decl2.c (cplus_decl_attributes): Don't diagnose block scope vars inside\n+\tdeclare target.\n+\t* pt.c (tsubst_omp_clauses): If OMP_CLAUSE_LINEAR_VARIABLE_STRIDE,\n+\tuse tsubst_omp_clause_decl instead of tsubst_expr on\n+\tOMP_CLAUSE_LINEAR_STEP.  Handle non-static data members in shared\n+\tclauses.\n+\t(tsubst_omp_for_iterator): Adjust omp_privatize_field caller.\n+\t(tsubst_find_omp_teams): New function.\n+\t(tsubst_expr): Evaluate num_teams and thread_limit expressions on\n+\tcombined target teams before the target.  Use OMP_FOR_ORIG_DECLS for\n+\tall OpenMP/OpenACC/Cilk+ looping constructs.  Adjust finish_omp_for\n+\tcaller.\n+\t* semantics.c (omp_privatize_field): Add SHARED argument, if true,\n+\talways create artificial var and never put it into the hash table\n+\tor vector.\n+\t(handle_omp_array_sections_1): Adjust omp_privatize_field caller.\n+\tAllow non-zero low-bound on OMP_CLAUSE_REDUCTION array sections.\n+\t(handle_omp_array_sections): For structure element\n+\tbased array sections use GOMP_MAP_ALWAYS_POINTER instead of\n+\tGOMP_MAP_FIRSTPRIVATE_POINTER.  Encode low-bound into the MEM_REF,\n+\teither into the constant offset, or for variable low-bound using\n+\tPOINTER_PLUS_EXPR.\n+\t(finish_omp_clauses): Adjust omp_privatize_field caller.  Drop\n+\tgeneric_field_head, structure elements are now always mapped even\n+\tas array section bases, diagnose same var in data sharing and\n+\tmapping clauses.  For references map what they refer to using\n+\tGOMP_MAP_ALWAYS_POINTER for structure elements and\n+\tGOMP_MAP_FIRSTPRIVATE_REFERENCE otherwise.  Diagnose if linear step\n+\ton declare simd is neither a constant nor a uniform parameter.\n+\tAllow non-static data members on shared clauses.  Look through\n+\tPOINTER_PLUS_EXPR for array section reductions.  Diagnose nonmonotonic\n+\tmodifier on kinds other than dynamic or guided or nonmonotonic\n+\tmodifier together with ordered clause.  Diagnose the same var or\n+\tfunction appearing multiple times on the same directive.  Fix up\n+\twording for the to clause if t is neither a FUNCTION_DECL nor a\n+\tVAR_DECL, use special wording for OVERLOADs and TEMPLATE_ID_EXPR.\n+\t(handle_omp_for_class_iterator): Add ORIG_DECLS argument.  Call\n+\tc_omp_check_loop_iv_exprs on cond.\n+\t(finish_omp_for): Add ORIG_INITS argument.  Call\n+\tc_omp_check_loop_iv_exprs on ORIG_INITS elements.  Adjust\n+\thandle_omp_for_class_iterator caller.  Call c_omp_check_loop_iv.\n+\tCall add_stmt.\n+\t(finish_omp_atomic): Adjust c_finish_omp_atomic caller.\n+\n 2015-11-04  Cesar Philippidis  <cesar@codesourcery.com>\n \n \t* (cp_parser_oacc_single_int_clause): New function."}, {"sha": "828f2682fab97895d37860d8b343dfb5fcf1b9e9", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -6324,7 +6324,7 @@ extern tree begin_omp_task\t\t\t(void);\n extern tree finish_omp_task\t\t\t(tree, tree);\n extern tree finish_omp_for\t\t\t(location_t, enum tree_code,\n \t\t\t\t\t\t tree, tree, tree, tree, tree,\n-\t\t\t\t\t\t tree, tree, tree);\n+\t\t\t\t\t\t tree, tree, vec<tree> *, tree);\n extern void finish_omp_atomic\t\t\t(enum tree_code, enum tree_code,\n \t\t\t\t\t\t tree, tree, tree, tree, tree,\n \t\t\t\t\t\t bool);\n@@ -6334,7 +6334,7 @@ extern void finish_omp_taskwait\t\t\t(void);\n extern void finish_omp_taskyield\t\t(void);\n extern void finish_omp_cancel\t\t\t(tree);\n extern void finish_omp_cancellation_point\t(tree);\n-extern tree omp_privatize_field\t\t\t(tree);\n+extern tree omp_privatize_field\t\t\t(tree, bool);\n extern tree begin_transaction_stmt\t\t(location_t, tree *, int);\n extern void finish_transaction_stmt\t\t(tree, tree, int, tree);\n extern tree build_transaction_expr\t\t(location_t, tree, int, tree);"}, {"sha": "a2d31a32e0113307da51ebd3213d160b9e2862f7", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -1448,11 +1448,6 @@ cplus_decl_attributes (tree *decl, tree attributes, int flags)\n \t  && DECL_CLASS_SCOPE_P (*decl))\n \terror (\"%q+D static data member inside of declare target directive\",\n \t       *decl);\n-      else if (VAR_P (*decl)\n-\t       && (DECL_FUNCTION_SCOPE_P (*decl)\n-\t\t   || (current_function_decl && !DECL_EXTERNAL (*decl))))\n-\terror (\"%q+D in block scope inside of declare target directive\",\n-\t       *decl);\n       else if (!processing_template_decl\n \t       && VAR_P (*decl)\n \t       && !cp_omp_mappable_type (TREE_TYPE (*decl)))"}, {"sha": "f26c7c335ff56750eba42c589945c549de56b91e", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 140, "deletions": 23, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -43,6 +43,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"omp-low.h\"\n #include \"gomp-constants.h\"\n #include \"c-family/c-indentation.h\"\n+#include \"context.h\"\n \n \f\n /* The lexer.  */\n@@ -30498,31 +30499,44 @@ cp_parser_omp_clause_reduction (cp_parser *parser, tree list)\n \n    OpenMP 4.5:\n    schedule ( schedule-modifier : schedule-kind )\n-   schedule ( schedule-modifier : schedule-kind , expression )\n+   schedule ( schedule-modifier [ , schedule-modifier ] : schedule-kind , expression )\n \n    schedule-modifier:\n-     simd  */\n+     simd\n+     monotonic\n+     nonmonotonic  */\n \n static tree\n cp_parser_omp_clause_schedule (cp_parser *parser, tree list, location_t location)\n {\n   tree c, t;\n+  int modifiers = 0, nmodifiers = 0;\n \n   if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n     return list;\n \n   c = build_omp_clause (location, OMP_CLAUSE_SCHEDULE);\n \n-  if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+  while (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n     {\n       tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n       const char *p = IDENTIFIER_POINTER (id);\n-      if (strcmp (\"simd\", p) == 0\n-\t  && cp_lexer_nth_token_is (parser->lexer, 2, CPP_COLON))\n+      if (strcmp (\"simd\", p) == 0)\n+\tOMP_CLAUSE_SCHEDULE_SIMD (c) = 1;\n+      else if (strcmp (\"monotonic\", p) == 0)\n+\tmodifiers |= OMP_CLAUSE_SCHEDULE_MONOTONIC;\n+      else if (strcmp (\"nonmonotonic\", p) == 0)\n+\tmodifiers |= OMP_CLAUSE_SCHEDULE_NONMONOTONIC;\n+      else\n+\tbreak;\n+      cp_lexer_consume_token (parser->lexer);\n+      if (nmodifiers++ == 0\n+\t  && cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n+\tcp_lexer_consume_token (parser->lexer);\n+      else\n \t{\n-\t  OMP_CLAUSE_SCHEDULE_SIMD (c) = 1;\n-\t  cp_lexer_consume_token (parser->lexer);\n-\t  cp_lexer_consume_token (parser->lexer);\n+\t  cp_parser_require (parser, CPP_COLON, RT_COLON);\n+\t  break;\n \t}\n     }\n \n@@ -30563,6 +30577,16 @@ cp_parser_omp_clause_schedule (cp_parser *parser, tree list, location_t location\n     goto invalid_kind;\n   cp_lexer_consume_token (parser->lexer);\n \n+  if ((modifiers & (OMP_CLAUSE_SCHEDULE_MONOTONIC\n+\t\t    | OMP_CLAUSE_SCHEDULE_NONMONOTONIC))\n+      == (OMP_CLAUSE_SCHEDULE_MONOTONIC\n+\t  | OMP_CLAUSE_SCHEDULE_NONMONOTONIC))\n+    {\n+      error_at (location, \"both %<monotonic%> and %<nonmonotonic%> modifiers \"\n+\t\t\t  \"specified\");\n+      modifiers = 0;\n+    }\n+\n   if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n     {\n       cp_token *token;\n@@ -30588,6 +30612,10 @@ cp_parser_omp_clause_schedule (cp_parser *parser, tree list, location_t location\n   else if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_COMMA_CLOSE_PAREN))\n     goto resync_fail;\n \n+  OMP_CLAUSE_SCHEDULE_KIND (c)\n+    = (enum omp_clause_schedule_kind)\n+      (OMP_CLAUSE_SCHEDULE_KIND (c) | modifiers);\n+\n   check_no_duplicate_clause (list, OMP_CLAUSE_SCHEDULE, \"schedule\", location);\n   OMP_CLAUSE_CHAIN (c) = list;\n   return c;\n@@ -30780,7 +30808,7 @@ cp_parser_omp_clause_aligned (cp_parser *parser, tree list)\n \n static tree\n cp_parser_omp_clause_linear (cp_parser *parser, tree list, \n-\t\t\t     bool is_cilk_simd_fn)\n+\t\t\t     bool is_cilk_simd_fn, bool declare_simd)\n {\n   tree nlist, c, step = integer_one_node;\n   bool colon;\n@@ -30824,7 +30852,30 @@ cp_parser_omp_clause_linear (cp_parser *parser, tree list,\n \n   if (colon)\n     {\n-      step = cp_parser_expression (parser);\n+      step = NULL_TREE;\n+      if (declare_simd\n+\t  && cp_lexer_next_token_is (parser->lexer, CPP_NAME)\n+\t  && cp_lexer_nth_token_is (parser->lexer, 2, CPP_CLOSE_PAREN))\n+\t{\n+\t  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+\t  cp_parser_parse_tentatively (parser);\n+\t  step = cp_parser_id_expression (parser, /*template_p=*/false,\n+\t\t\t\t\t  /*check_dependency_p=*/true,\n+\t\t\t\t\t  /*template_p=*/NULL,\n+\t\t\t\t\t  /*declarator_p=*/false,\n+\t\t\t\t\t  /*optional_p=*/false);\n+\t  if (step != error_mark_node)\n+\t    step = cp_parser_lookup_name_simple (parser, step, token->location);\n+\t  if (step == error_mark_node)\n+\t    {\n+\t      step = NULL_TREE;\n+\t      cp_parser_abort_tentative_parse (parser);\n+\t    }\n+\t  else if (!cp_parser_parse_definitely (parser))\n+\t    step = NULL_TREE;\n+\t}\n+      if (!step)\n+\tstep = cp_parser_expression (parser);\n \n       if (is_cilk_simd_fn && TREE_CODE (step) == PARM_DECL)\n \t{\n@@ -31511,7 +31562,6 @@ cp_parser_omp_all_clauses (cp_parser *parser, omp_clause_mask mask,\n   tree clauses = NULL;\n   bool first = true;\n   cp_token *token = NULL;\n-  bool cilk_simd_fn = false;\n \n   while (cp_lexer_next_token_is_not (parser->lexer, CPP_PRAGMA_EOL))\n     {\n@@ -31725,9 +31775,15 @@ cp_parser_omp_all_clauses (cp_parser *parser, omp_clause_mask mask,\n \t  c_name = \"aligned\";\n \t  break;\n \tcase PRAGMA_OMP_CLAUSE_LINEAR:\n-\t  if (((mask >> PRAGMA_CILK_CLAUSE_VECTORLENGTH) & 1) != 0)\n-\t    cilk_simd_fn = true;\n-\t  clauses = cp_parser_omp_clause_linear (parser, clauses, cilk_simd_fn);\n+\t  {\n+\t    bool cilk_simd_fn = false, declare_simd = false;\n+\t    if (((mask >> PRAGMA_CILK_CLAUSE_VECTORLENGTH) & 1) != 0)\n+\t      cilk_simd_fn = true;\n+\t    else if (((mask >> PRAGMA_OMP_CLAUSE_UNIFORM) & 1) != 0)\n+\t      declare_simd = true;\n+\t    clauses = cp_parser_omp_clause_linear (parser, clauses,\n+\t\t\t\t\t\t   cilk_simd_fn, declare_simd);\n+\t  }\n \t  c_name = \"linear\";\n \t  break;\n \tcase PRAGMA_OMP_CLAUSE_DEPEND:\n@@ -32510,6 +32566,7 @@ cp_parser_omp_for_loop_init (cp_parser *parser,\n \t\t\t     tree &this_pre_body,\n \t\t\t     vec<tree, va_gc> *for_block,\n \t\t\t     tree &init,\n+\t\t\t     tree &orig_init,\n \t\t\t     tree &decl,\n \t\t\t     tree &real_decl)\n {\n@@ -32607,6 +32664,7 @@ cp_parser_omp_for_loop_init (cp_parser *parser,\n \t      cp_finish_decl (decl, init, !is_non_constant_init,\n \t\t\t      asm_specification,\n \t\t\t      LOOKUP_ONLYCONVERTING);\n+\t      orig_init = init;\n \t      if (CLASS_TYPE_P (TREE_TYPE (decl)))\n \t\t{\n \t\t  vec_safe_push (for_block, this_pre_body);\n@@ -32667,7 +32725,7 @@ cp_parser_omp_for_loop_init (cp_parser *parser,\n \t      decl = cp_parser_lookup_name_simple (parser, name,\n \t\t\t\t\t\t   token->location);\n \t      if (TREE_CODE (decl) == FIELD_DECL)\n-\t\tadd_private_clause = omp_privatize_field (decl);\n+\t\tadd_private_clause = omp_privatize_field (decl, false);\n \t    }\n \t  cp_parser_abort_tentative_parse (parser);\n \t  cp_parser_parse_tentatively (parser);\n@@ -32684,6 +32742,7 @@ cp_parser_omp_for_loop_init (cp_parser *parser,\n \t  cp_parser_parse_definitely (parser);\n \t  cp_parser_require (parser, CPP_EQ, RT_EQ);\n \t  rhs = cp_parser_assignment_expression (parser);\n+\t  orig_init = rhs;\n \t  finish_expr_stmt (build_x_modify_expr (EXPR_LOCATION (rhs),\n \t\t\t\t\t\t decl, NOP_EXPR,\n \t\t\t\t\t\t rhs,\n@@ -32713,13 +32772,14 @@ static tree\n cp_parser_omp_for_loop (cp_parser *parser, enum tree_code code, tree clauses,\n \t\t\ttree *cclauses)\n {\n-  tree init, cond, incr, body, decl, pre_body = NULL_TREE, ret;\n+  tree init, orig_init, cond, incr, body, decl, pre_body = NULL_TREE, ret;\n   tree real_decl, initv, condv, incrv, declv;\n   tree this_pre_body, cl, ordered_cl = NULL_TREE;\n   location_t loc_first;\n   bool collapse_err = false;\n   int i, collapse = 1, ordered = 0, count, nbraces = 0;\n   vec<tree, va_gc> *for_block = make_tree_vector ();\n+  auto_vec<tree, 4> orig_inits;\n \n   for (cl = clauses; cl; cl = OMP_CLAUSE_CHAIN (cl))\n     if (OMP_CLAUSE_CODE (cl) == OMP_CLAUSE_COLLAPSE)\n@@ -32786,13 +32846,13 @@ cp_parser_omp_for_loop (cp_parser *parser, enum tree_code code, tree clauses,\n       if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n \treturn NULL;\n \n-      init = decl = real_decl = NULL;\n+      init = orig_init = decl = real_decl = NULL;\n       this_pre_body = push_stmt_list ();\n \n       add_private_clause\n \t= cp_parser_omp_for_loop_init (parser, code,\n \t\t\t\t       this_pre_body, for_block,\n-\t\t\t\t       init, decl, real_decl);\n+\t\t\t\t       init, orig_init, decl, real_decl);\n \n       cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n       if (this_pre_body)\n@@ -32924,6 +32984,11 @@ cp_parser_omp_for_loop (cp_parser *parser, enum tree_code code, tree clauses,\n       TREE_VEC_ELT (initv, i) = init;\n       TREE_VEC_ELT (condv, i) = cond;\n       TREE_VEC_ELT (incrv, i) = incr;\n+      if (orig_init)\n+\t{\n+\t  orig_inits.safe_grow_cleared (i + 1);\n+\t  orig_inits[i] = orig_init;\n+\t}\n \n       if (i == count - 1)\n \tbreak;\n@@ -32981,7 +33046,7 @@ cp_parser_omp_for_loop (cp_parser *parser, enum tree_code code, tree clauses,\n     ret = NULL_TREE;\n   else\n     ret = finish_omp_for (loc_first, code, declv, NULL, initv, condv, incrv,\n-\t\t\t  body, pre_body, clauses);\n+\t\t\t  body, pre_body, &orig_inits, clauses);\n \n   while (nbraces)\n     {\n@@ -33626,6 +33691,7 @@ cp_parser_omp_cancellation_point (cp_parser *parser, cp_token *pragma_tok)\n #define OMP_DISTRIBUTE_CLAUSE_MASK\t\t\t\t\\\n \t( (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_PRIVATE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_LASTPRIVATE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DIST_SCHEDULE)\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_COLLAPSE))\n \n@@ -33821,6 +33887,8 @@ cp_parser_omp_target_data (cp_parser *parser, cp_token *pragma_tok)\n \t    map_seen = 3;\n \t    break;\n \t  case GOMP_MAP_FIRSTPRIVATE_POINTER:\n+\t  case GOMP_MAP_FIRSTPRIVATE_REFERENCE:\n+\t  case GOMP_MAP_ALWAYS_POINTER:\n \t    break;\n \t  default:\n \t    map_seen |= 1;\n@@ -33912,6 +33980,8 @@ cp_parser_omp_target_enter_data (cp_parser *parser, cp_token *pragma_tok,\n \t    map_seen = 3;\n \t    break;\n \t  case GOMP_MAP_FIRSTPRIVATE_POINTER:\n+\t  case GOMP_MAP_FIRSTPRIVATE_REFERENCE:\n+\t  case GOMP_MAP_ALWAYS_POINTER:\n \t    break;\n \t  default:\n \t    map_seen |= 1;\n@@ -33999,6 +34069,8 @@ cp_parser_omp_target_exit_data (cp_parser *parser, cp_token *pragma_tok,\n \t    map_seen = 3;\n \t    break;\n \t  case GOMP_MAP_FIRSTPRIVATE_POINTER:\n+\t  case GOMP_MAP_FIRSTPRIVATE_REFERENCE:\n+\t  case GOMP_MAP_ALWAYS_POINTER:\n \t    break;\n \t  default:\n \t    map_seen |= 1;\n@@ -34169,6 +34241,33 @@ cp_parser_omp_target (cp_parser *parser, cp_token *pragma_tok,\n \t  tree body = finish_omp_structured_block (sb);\n \t  if (ret == NULL_TREE)\n \t    return false;\n+\t  if (ccode == OMP_TEAMS && !processing_template_decl)\n+\t    {\n+\t      /* For combined target teams, ensure the num_teams and\n+\t\t thread_limit clause expressions are evaluated on the host,\n+\t\t before entering the target construct.  */\n+\t      tree c;\n+\t      for (c = cclauses[C_OMP_CLAUSE_SPLIT_TEAMS];\n+\t\t   c; c = OMP_CLAUSE_CHAIN (c))\n+\t\tif ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_NUM_TEAMS\n+\t\t     || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_THREAD_LIMIT)\n+\t\t    && TREE_CODE (OMP_CLAUSE_OPERAND (c, 0)) != INTEGER_CST)\n+\t\t  {\n+\t\t    tree expr = OMP_CLAUSE_OPERAND (c, 0);\n+\t\t    expr = force_target_expr (TREE_TYPE (expr), expr, tf_none);\n+\t\t    if (expr == error_mark_node)\n+\t\t      continue;\n+\t\t    tree tmp = TARGET_EXPR_SLOT (expr);\n+\t\t    add_stmt (expr);\n+\t\t    OMP_CLAUSE_OPERAND (c, 0) = expr;\n+\t\t    tree tc = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\t\tOMP_CLAUSE_FIRSTPRIVATE);\n+\t\t    OMP_CLAUSE_DECL (tc) = tmp;\n+\t\t    OMP_CLAUSE_CHAIN (tc)\n+\t\t      = cclauses[C_OMP_CLAUSE_SPLIT_TARGET];\n+\t\t    cclauses[C_OMP_CLAUSE_SPLIT_TARGET] = tc;\n+\t\t  }\n+\t    }\n \t  tree stmt = make_node (OMP_TARGET);\n \t  TREE_TYPE (stmt) = void_type_node;\n \t  OMP_TARGET_CLAUSES (stmt) = cclauses[C_OMP_CLAUSE_SPLIT_TARGET];\n@@ -34235,6 +34334,8 @@ cp_parser_omp_target (cp_parser *parser, cp_token *pragma_tok,\n \t  case GOMP_MAP_ALWAYS_TOFROM:\n \t  case GOMP_MAP_ALLOC:\n \t  case GOMP_MAP_FIRSTPRIVATE_POINTER:\n+\t  case GOMP_MAP_FIRSTPRIVATE_REFERENCE:\n+\t  case GOMP_MAP_ALWAYS_POINTER:\n \t    break;\n \t  default:\n \t    error_at (OMP_CLAUSE_LOCATION (*pc),\n@@ -34766,11 +34867,12 @@ cp_parser_omp_declare_target (cp_parser *parser, cp_token *pragma_tok)\n     {\n       clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_TO_DECLARE,\n \t\t\t\t\tclauses);\n-      cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n+      clauses = finish_omp_clauses (clauses, true);\n+      cp_parser_require_pragma_eol (parser, pragma_tok);\n     }\n   else\n     {\n-      cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n+      cp_parser_require_pragma_eol (parser, pragma_tok);\n       scope_chain->omp_declare_target_attribute++;\n       return;\n     }\n@@ -34800,7 +34902,22 @@ cp_parser_omp_declare_target (cp_parser *parser, cp_token *pragma_tok)\n \t  continue;\n \t}\n       if (!at1)\n-\tDECL_ATTRIBUTES (t) = tree_cons (id, NULL_TREE, DECL_ATTRIBUTES (t));\n+\t{\n+\t  symtab_node *node = symtab_node::get (t);\n+\t  DECL_ATTRIBUTES (t) = tree_cons (id, NULL_TREE, DECL_ATTRIBUTES (t));\n+\t  if (node != NULL)\n+\t    {\n+\t      node->offloadable = 1;\n+#ifdef ENABLE_OFFLOADING\n+\t      g->have_offload = true;\n+\t      if (is_a <varpool_node *> (node))\n+\t\t{\n+\t\t  vec_safe_push (offload_vars, t);\n+\t\t  node->force_output = 1;\n+\t\t}\n+#endif\n+\t    }\n+\t}\n     }\n }\n \n@@ -34837,7 +34954,7 @@ cp_parser_omp_end_declare_target (cp_parser *parser, cp_token *pragma_tok)\n       cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n       return;\n     }\n-  cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n+  cp_parser_require_pragma_eol (parser, pragma_tok);\n   if (!scope_chain->omp_declare_target_attribute)\n     error_at (pragma_tok->location,\n \t      \"%<#pragma omp end declare target%> without corresponding \""}, {"sha": "9e3bd2d261c6a0040d09e2ba203d7c72f700a3f4", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 70, "deletions": 6, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -14419,20 +14419,32 @@ tsubst_omp_clauses (tree clauses, bool declare_simd, bool allow_fields,\n \t    = tsubst_omp_clause_decl (OMP_CLAUSE_DECL (oc), args, complain,\n \t\t\t\t      in_decl);\n \t  break;\n-\tcase OMP_CLAUSE_LINEAR:\n \tcase OMP_CLAUSE_ALIGNED:\n \t  OMP_CLAUSE_DECL (nc)\n \t    = tsubst_omp_clause_decl (OMP_CLAUSE_DECL (oc), args, complain,\n \t\t\t\t      in_decl);\n \t  OMP_CLAUSE_OPERAND (nc, 1)\n \t    = tsubst_expr (OMP_CLAUSE_OPERAND (oc, 1), args, complain,\n \t\t\t   in_decl, /*integral_constant_expression_p=*/false);\n-\t  if (OMP_CLAUSE_CODE (oc) == OMP_CLAUSE_LINEAR\n-\t      && OMP_CLAUSE_LINEAR_STEP (oc) == NULL_TREE)\n+\t  break;\n+\tcase OMP_CLAUSE_LINEAR:\n+\t  OMP_CLAUSE_DECL (nc)\n+\t    = tsubst_omp_clause_decl (OMP_CLAUSE_DECL (oc), args, complain,\n+\t\t\t\t      in_decl);\n+\t  if (OMP_CLAUSE_LINEAR_STEP (oc) == NULL_TREE)\n \t    {\n \t      gcc_assert (!linear_no_step);\n \t      linear_no_step = nc;\n \t    }\n+\t  else if (OMP_CLAUSE_LINEAR_VARIABLE_STRIDE (oc))\n+\t    OMP_CLAUSE_LINEAR_STEP (nc)\n+\t      = tsubst_omp_clause_decl (OMP_CLAUSE_LINEAR_STEP (oc), args,\n+\t\t\t\t\tcomplain, in_decl);\n+\t  else\n+\t    OMP_CLAUSE_LINEAR_STEP (nc)\n+\t      = tsubst_expr (OMP_CLAUSE_LINEAR_STEP (oc), args, complain,\n+\t\t\t     in_decl,\n+\t\t\t     /*integral_constant_expression_p=*/false);\n \t  break;\n \tcase OMP_CLAUSE_NOWAIT:\n \tcase OMP_CLAUSE_DEFAULT:\n@@ -14456,6 +14468,7 @@ tsubst_omp_clauses (tree clauses, bool declare_simd, bool allow_fields,\n       if (allow_fields)\n \tswitch (OMP_CLAUSE_CODE (nc))\n \t  {\n+\t  case OMP_CLAUSE_SHARED:\n \t  case OMP_CLAUSE_PRIVATE:\n \t  case OMP_CLAUSE_FIRSTPRIVATE:\n \t  case OMP_CLAUSE_LASTPRIVATE:\n@@ -14635,7 +14648,7 @@ tsubst_omp_for_iterator (tree t, int i, tree declv, tree orig_declv,\n \t\t\t&& DECL_NAME (v) == this_identifier)\n \t\t      {\n \t\t\tdecl = TREE_OPERAND (decl, 1);\n-\t\t\tdecl = omp_privatize_field (decl);\n+\t\t\tdecl = omp_privatize_field (decl, false);\n \t\t      }\n \t\t    /* FALLTHRU */\n \t\t  default:\n@@ -14816,6 +14829,27 @@ tsubst_omp_for_iterator (tree t, int i, tree declv, tree orig_declv,\n #undef RECUR\n }\n \n+/* Helper function of tsubst_expr, find OMP_TEAMS inside\n+   of OMP_TARGET's body.  */\n+\n+static tree\n+tsubst_find_omp_teams (tree *tp, int *walk_subtrees, void *)\n+{\n+  *walk_subtrees = 0;\n+  switch (TREE_CODE (*tp))\n+    {\n+    case OMP_TEAMS:\n+      return *tp;\n+    case BIND_EXPR:\n+    case STATEMENT_LIST:\n+      *walk_subtrees = 1;\n+      break;\n+    default:\n+      break;\n+    }\n+  return NULL_TREE;\n+}\n+\n /* Like tsubst_copy for expressions, etc. but also does semantic\n    processing.  */\n \n@@ -15240,7 +15274,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \tif (OMP_FOR_INIT (t) != NULL_TREE)\n \t  {\n \t    declv = make_tree_vec (TREE_VEC_LENGTH (OMP_FOR_INIT (t)));\n-\t    if (TREE_CODE (t) == OMP_FOR && OMP_FOR_ORIG_DECLS (t))\n+\t    if (OMP_FOR_ORIG_DECLS (t))\n \t      orig_declv = make_tree_vec (TREE_VEC_LENGTH (OMP_FOR_INIT (t)));\n \t    initv = make_tree_vec (TREE_VEC_LENGTH (OMP_FOR_INIT (t)));\n \t    condv = make_tree_vec (TREE_VEC_LENGTH (OMP_FOR_INIT (t)));\n@@ -15267,7 +15301,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \tif (OMP_FOR_INIT (t) != NULL_TREE)\n \t  t = finish_omp_for (EXPR_LOCATION (t), TREE_CODE (t), declv,\n \t\t\t      orig_declv, initv, condv, incrv, body, pre_body,\n-\t\t\t      clauses);\n+\t\t\t      NULL, clauses);\n \telse\n \t  {\n \t    t = make_node (TREE_CODE (t));\n@@ -15318,6 +15352,36 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n       t = copy_node (t);\n       OMP_BODY (t) = stmt;\n       OMP_CLAUSES (t) = tmp;\n+      if (TREE_CODE (t) == OMP_TARGET && OMP_TARGET_COMBINED (t))\n+\t{\n+\t  tree teams = cp_walk_tree (&stmt, tsubst_find_omp_teams, NULL, NULL);\n+\t  if (teams)\n+\t    {\n+\t      /* For combined target teams, ensure the num_teams and\n+\t\t thread_limit clause expressions are evaluated on the host,\n+\t\t before entering the target construct.  */\n+\t      tree c;\n+\t      for (c = OMP_TEAMS_CLAUSES (teams);\n+\t\t   c; c = OMP_CLAUSE_CHAIN (c))\n+\t\tif ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_NUM_TEAMS\n+\t\t     || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_THREAD_LIMIT)\n+\t\t    && TREE_CODE (OMP_CLAUSE_OPERAND (c, 0)) != INTEGER_CST)\n+\t\t  {\n+\t\t    tree expr = OMP_CLAUSE_OPERAND (c, 0);\n+\t\t    expr = force_target_expr (TREE_TYPE (expr), expr, tf_none);\n+\t\t    if (expr == error_mark_node)\n+\t\t      continue;\n+\t\t    tmp = TARGET_EXPR_SLOT (expr);\n+\t\t    add_stmt (expr);\n+\t\t    OMP_CLAUSE_OPERAND (c, 0) = expr;\n+\t\t    tree tc = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\t\tOMP_CLAUSE_FIRSTPRIVATE);\n+\t\t    OMP_CLAUSE_DECL (tc) = tmp;\n+\t\t    OMP_CLAUSE_CHAIN (tc) = OMP_TARGET_CLAUSES (t);\n+\t\t    OMP_TARGET_CLAUSES (t) = tc;\n+\t\t  }\n+\t    }\n+\t}\n       add_stmt (t);\n       break;\n "}, {"sha": "fe18b273be58b7fa27d5df0934f51ffc93b4ed3f", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 280, "deletions": 64, "changes": 344, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -4323,19 +4323,20 @@ omp_note_field_privatization (tree f, tree t)\n    dummy VAR_DECL.  */\n \n tree\n-omp_privatize_field (tree t)\n+omp_privatize_field (tree t, bool shared)\n {\n   tree m = finish_non_static_data_member (t, NULL_TREE, NULL_TREE);\n   if (m == error_mark_node)\n     return error_mark_node;\n-  if (!omp_private_member_map)\n+  if (!omp_private_member_map && !shared)\n     omp_private_member_map = new hash_map<tree, tree>;\n   if (TREE_CODE (TREE_TYPE (t)) == REFERENCE_TYPE)\n     {\n       gcc_assert (TREE_CODE (m) == INDIRECT_REF);\n       m = TREE_OPERAND (m, 0);\n     }\n-  tree &v = omp_private_member_map->get_or_insert (t);\n+  tree vb = NULL_TREE;\n+  tree &v = shared ? vb : omp_private_member_map->get_or_insert (t);\n   if (v == NULL_TREE)\n     {\n       v = create_temporary_var (TREE_TYPE (m));\n@@ -4344,7 +4345,8 @@ omp_privatize_field (tree t)\n       DECL_OMP_PRIVATIZED_MEMBER (v) = 1;\n       SET_DECL_VALUE_EXPR (v, m);\n       DECL_HAS_VALUE_EXPR_P (v) = 1;\n-      omp_private_member_vec.safe_push (t);\n+      if (!shared)\n+\tomp_private_member_vec.safe_push (t);\n     }\n   return v;\n }\n@@ -4447,7 +4449,7 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n \n   if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n       && TREE_CODE (TREE_CHAIN (t)) == FIELD_DECL)\n-    TREE_CHAIN (t) = omp_privatize_field (TREE_CHAIN (t));\n+    TREE_CHAIN (t) = omp_privatize_field (TREE_CHAIN (t), false);\n   ret = handle_omp_array_sections_1 (c, TREE_CHAIN (t), types,\n \t\t\t\t     maybe_zero_len, first_non_one, is_omp);\n   if (ret == error_mark_node || ret == NULL_TREE)\n@@ -4516,13 +4518,6 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n \t  && (TREE_CODE (length) != INTEGER_CST || integer_onep (length)))\n \tfirst_non_one++;\n     }\n-  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n-      && !integer_zerop (low_bound))\n-    {\n-      error_at (OMP_CLAUSE_LOCATION (c),\n-\t\t\"%<reduction%> array section has to be zero-based\");\n-      return error_mark_node;\n-    }\n   if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n       if (length == NULL_TREE\n@@ -4863,7 +4858,24 @@ handle_omp_array_sections (tree c, bool is_omp)\n \t\tt = convert_from_reference (t);\n \t      else if (TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE)\n \t\tt = build_fold_addr_expr (t);\n-\t      t = build2 (MEM_REF, type, t, build_int_cst (ptype, 0));\n+\t      tree t2 = build_fold_addr_expr (first);\n+\t      t2 = fold_convert_loc (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t     ptrdiff_type_node, t2);\n+\t      t2 = fold_build2_loc (OMP_CLAUSE_LOCATION (c), MINUS_EXPR,\n+\t\t\t\t    ptrdiff_type_node, t2,\n+\t\t\t\t    fold_convert_loc (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\t\t      ptrdiff_type_node, t));\n+\t      if (tree_fits_shwi_p (t2))\n+\t\tt = build2 (MEM_REF, type, t,\n+\t\t\t    build_int_cst (ptype, tree_to_shwi (t2)));\n+\t      else\n+\t\t{\n+\t\t  t2 = fold_convert_loc (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\t sizetype, t2);\n+\t\t  t = build2_loc (OMP_CLAUSE_LOCATION (c), POINTER_PLUS_EXPR,\n+\t\t\t\t  TREE_TYPE (t), t, t2);\n+\t\t  t = build2 (MEM_REF, type, t, build_int_cst (ptype, 0));\n+\t\t}\n \t      OMP_CLAUSE_DECL (c) = t;\n \t      return false;\n \t    }\n@@ -4892,9 +4904,20 @@ handle_omp_array_sections (tree c, bool is_omp)\n \t      }\n \t  tree c2 = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n \t\t\t\t      OMP_CLAUSE_MAP);\n-\t  OMP_CLAUSE_SET_MAP_KIND (c2, is_omp ? GOMP_MAP_FIRSTPRIVATE_POINTER\n-\t\t\t\t\t      : GOMP_MAP_POINTER);\n-\t  if (!is_omp && !cxx_mark_addressable (t))\n+\t  if (!is_omp)\n+\t    OMP_CLAUSE_SET_MAP_KIND (c2, GOMP_MAP_POINTER);\n+\t  else if (TREE_CODE (t) == COMPONENT_REF)\n+\t    OMP_CLAUSE_SET_MAP_KIND (c2, GOMP_MAP_ALWAYS_POINTER);\n+\t  else if (REFERENCE_REF_P (t)\n+\t\t   && TREE_CODE (TREE_OPERAND (t, 0)) == COMPONENT_REF)\n+\t    {\n+\t      t = TREE_OPERAND (t, 0);\n+\t      OMP_CLAUSE_SET_MAP_KIND (c2, GOMP_MAP_ALWAYS_POINTER);\n+\t    }\n+\t  else\n+\t    OMP_CLAUSE_SET_MAP_KIND (c2, GOMP_MAP_FIRSTPRIVATE_POINTER);\n+\t  if (OMP_CLAUSE_MAP_KIND (c2) != GOMP_MAP_FIRSTPRIVATE_POINTER\n+\t      && !cxx_mark_addressable (t))\n \t    return false;\n \t  OMP_CLAUSE_DECL (c2) = t;\n \t  t = build_fold_addr_expr (first);\n@@ -4912,15 +4935,18 @@ handle_omp_array_sections (tree c, bool is_omp)\n \t  OMP_CLAUSE_CHAIN (c2) = OMP_CLAUSE_CHAIN (c);\n \t  OMP_CLAUSE_CHAIN (c) = c2;\n \t  ptr = OMP_CLAUSE_DECL (c2);\n-\t  if (!is_omp\n+\t  if (OMP_CLAUSE_MAP_KIND (c2) != GOMP_MAP_FIRSTPRIVATE_POINTER\n \t      && TREE_CODE (TREE_TYPE (ptr)) == REFERENCE_TYPE\n \t      && POINTER_TYPE_P (TREE_TYPE (TREE_TYPE (ptr))))\n \t    {\n \t      tree c3 = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n \t\t\t\t\t  OMP_CLAUSE_MAP);\n-\t      OMP_CLAUSE_SET_MAP_KIND (c3, GOMP_MAP_POINTER);\n+\t      OMP_CLAUSE_SET_MAP_KIND (c3, OMP_CLAUSE_MAP_KIND (c2));\n \t      OMP_CLAUSE_DECL (c3) = ptr;\n-\t      OMP_CLAUSE_DECL (c2) = convert_from_reference (ptr);\n+\t      if (OMP_CLAUSE_MAP_KIND (c2) == GOMP_MAP_ALWAYS_POINTER)\n+\t\tOMP_CLAUSE_DECL (c2) = build_simple_mem_ref (ptr);\n+\t      else\n+\t\tOMP_CLAUSE_DECL (c2) = convert_from_reference (ptr);\n \t      OMP_CLAUSE_SIZE (c3) = size_zero_node;\n \t      OMP_CLAUSE_CHAIN (c3) = OMP_CLAUSE_CHAIN (c2);\n \t      OMP_CLAUSE_CHAIN (c2) = c3;\n@@ -5645,11 +5671,12 @@ tree\n finish_omp_clauses (tree clauses, bool allow_fields, bool declare_simd)\n {\n   bitmap_head generic_head, firstprivate_head, lastprivate_head;\n-  bitmap_head aligned_head, map_head, map_field_head, generic_field_head;\n+  bitmap_head aligned_head, map_head, map_field_head;\n   tree c, t, *pc;\n   tree safelen = NULL_TREE;\n   bool branch_seen = false;\n   bool copyprivate_seen = false;\n+  bool ordered_seen = false;\n \n   bitmap_obstack_initialize (NULL);\n   bitmap_initialize (&generic_head, &bitmap_default_obstack);\n@@ -5658,7 +5685,6 @@ finish_omp_clauses (tree clauses, bool allow_fields, bool declare_simd)\n   bitmap_initialize (&aligned_head, &bitmap_default_obstack);\n   bitmap_initialize (&map_head, &bitmap_default_obstack);\n   bitmap_initialize (&map_field_head, &bitmap_default_obstack);\n-  bitmap_initialize (&generic_field_head, &bitmap_default_obstack);\n \n   for (pc = &clauses, c = clauses; c ; c = *pc)\n     {\n@@ -5668,6 +5694,7 @@ finish_omp_clauses (tree clauses, bool allow_fields, bool declare_simd)\n       switch (OMP_CLAUSE_CODE (c))\n \t{\n \tcase OMP_CLAUSE_SHARED:\n+\t  field_ok = allow_fields;\n \t  goto check_dup_generic;\n \tcase OMP_CLAUSE_PRIVATE:\n \t  field_ok = allow_fields;\n@@ -5691,6 +5718,8 @@ finish_omp_clauses (tree clauses, bool allow_fields, bool declare_simd)\n \t\t{\n \t\t  gcc_assert (TREE_CODE (t) == MEM_REF);\n \t\t  t = TREE_OPERAND (t, 0);\n+\t\t  if (TREE_CODE (t) == POINTER_PLUS_EXPR)\n+\t\t    t = TREE_OPERAND (t, 0);\n \t\t  if (TREE_CODE (t) == ADDR_EXPR\n \t\t      || TREE_CODE (t) == INDIRECT_REF)\n \t\t    t = TREE_OPERAND (t, 0);\n@@ -5753,7 +5782,11 @@ finish_omp_clauses (tree clauses, bool allow_fields, bool declare_simd)\n \t      break;\n \t    }\n \t  else if (!type_dependent_expression_p (t)\n-\t\t   && !INTEGRAL_TYPE_P (TREE_TYPE (t)))\n+\t\t   && !INTEGRAL_TYPE_P (TREE_TYPE (t))\n+\t\t   && (!declare_simd\n+\t\t       || TREE_CODE (t) != PARM_DECL\n+\t\t       || TREE_CODE (TREE_TYPE (t)) != REFERENCE_TYPE\n+\t\t       || !INTEGRAL_TYPE_P (TREE_TYPE (TREE_TYPE (t)))))\n \t    {\n \t      error (\"linear step expression must be integral\");\n \t      remove = true;\n@@ -5762,12 +5795,27 @@ finish_omp_clauses (tree clauses, bool allow_fields, bool declare_simd)\n \t  else\n \t    {\n \t      t = mark_rvalue_use (t);\n+\t      if (declare_simd && TREE_CODE (t) == PARM_DECL)\n+\t\t{\n+\t\t  OMP_CLAUSE_LINEAR_VARIABLE_STRIDE (c) = 1;\n+\t\t  goto check_dup_generic;\n+\t\t}\n \t      if (!processing_template_decl\n \t\t  && (VAR_P (OMP_CLAUSE_DECL (c))\n \t\t      || TREE_CODE (OMP_CLAUSE_DECL (c)) == PARM_DECL))\n \t\t{\n-\t\t  if (TREE_CODE (OMP_CLAUSE_DECL (c)) == PARM_DECL)\n-\t\t    t = maybe_constant_value (t);\n+\t\t  if (declare_simd)\n+\t\t    {\n+\t\t      t = maybe_constant_value (t);\n+\t\t      if (TREE_CODE (t) != INTEGER_CST)\n+\t\t\t{\n+\t\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t    \"%<linear%> clause step %qE is neither \"\n+\t\t\t\t     \"constant nor a parameter\", t);\n+\t\t\t  remove = true;\n+\t\t\t  break;\n+\t\t\t}\n+\t\t    }\n \t\t  t = fold_build_cleanup_point_expr (TREE_TYPE (t), t);\n \t\t  tree type = TREE_TYPE (OMP_CLAUSE_DECL (c));\n \t\t  if (TREE_CODE (type) == REFERENCE_TYPE)\n@@ -5821,7 +5869,7 @@ finish_omp_clauses (tree clauses, bool allow_fields, bool declare_simd)\n \t  t = omp_clause_decl_field (OMP_CLAUSE_DECL (c));\n \t  if (t)\n \t    {\n-\t      if (!remove)\n+\t      if (!remove && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_SHARED)\n \t\tomp_note_field_privatization (t, OMP_CLAUSE_DECL (c));\n \t    }\n \t  else\n@@ -5857,6 +5905,12 @@ finish_omp_clauses (tree clauses, bool allow_fields, bool declare_simd)\n \t      error (\"%qD appears more than once in data clauses\", t);\n \t      remove = true;\n \t    }\n+\t  else if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_PRIVATE\n+\t\t   && bitmap_bit_p (&map_head, DECL_UID (t)))\n+\t    {\n+\t      error (\"%qD appears both in data and map clauses\", t);\n+\t      remove = true;\n+\t    }\n \t  else\n \t    bitmap_set_bit (&generic_head, DECL_UID (t));\n \t  if (!field_ok)\n@@ -5866,7 +5920,9 @@ finish_omp_clauses (tree clauses, bool allow_fields, bool declare_simd)\n \t      && TREE_CODE (t) == FIELD_DECL\n \t      && t == OMP_CLAUSE_DECL (c))\n \t    {\n-\t      OMP_CLAUSE_DECL (c) = omp_privatize_field (t);\n+\t      OMP_CLAUSE_DECL (c)\n+\t\t= omp_privatize_field (t, (OMP_CLAUSE_CODE (c)\n+\t\t\t\t\t   == OMP_CLAUSE_SHARED));\n \t      if (OMP_CLAUSE_DECL (c) == error_mark_node)\n \t\tremove = true;\n \t    }\n@@ -5902,6 +5958,11 @@ finish_omp_clauses (tree clauses, bool allow_fields, bool declare_simd)\n \t      error (\"%qD appears more than once in data clauses\", t);\n \t      remove = true;\n \t    }\n+\t  else if (bitmap_bit_p (&map_head, DECL_UID (t)))\n+\t    {\n+\t      error (\"%qD appears both in data and map clauses\", t);\n+\t      remove = true;\n+\t    }\n \t  else\n \t    bitmap_set_bit (&firstprivate_head, DECL_UID (t));\n \t  goto handle_field_decl;\n@@ -6072,6 +6133,30 @@ finish_omp_clauses (tree clauses, bool allow_fields, bool declare_simd)\n \t  break;\n \n \tcase OMP_CLAUSE_SCHEDULE:\n+\t  if (OMP_CLAUSE_SCHEDULE_KIND (c) & OMP_CLAUSE_SCHEDULE_NONMONOTONIC)\n+\t    {\n+\t      const char *p = NULL;\n+\t      switch (OMP_CLAUSE_SCHEDULE_KIND (c) & OMP_CLAUSE_SCHEDULE_MASK)\n+\t\t{\n+\t\tcase OMP_CLAUSE_SCHEDULE_STATIC: p = \"static\"; break;\n+\t\tcase OMP_CLAUSE_SCHEDULE_DYNAMIC: break;\n+\t\tcase OMP_CLAUSE_SCHEDULE_GUIDED: break;\n+\t\tcase OMP_CLAUSE_SCHEDULE_AUTO: p = \"auto\"; break;\n+\t\tcase OMP_CLAUSE_SCHEDULE_RUNTIME: p = \"runtime\"; break;\n+\t\tdefault: gcc_unreachable ();\n+\t\t}\n+\t      if (p)\n+\t\t{\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"%<nonmonotonic%> modifier specified for %qs \"\n+\t\t\t    \"schedule kind\", p);\n+\t\t  OMP_CLAUSE_SCHEDULE_KIND (c)\n+\t\t    = (enum omp_clause_schedule_kind)\n+\t\t      (OMP_CLAUSE_SCHEDULE_KIND (c)\n+\t\t       & ~OMP_CLAUSE_SCHEDULE_NONMONOTONIC);\n+\t\t}\n+\t    }\n+\n \t  t = OMP_CLAUSE_SCHEDULE_CHUNK_EXPR (c);\n \t  if (t == NULL)\n \t    ;\n@@ -6406,7 +6491,10 @@ finish_omp_clauses (tree clauses, bool allow_fields, bool declare_simd)\n \t    }\n \t  if (REFERENCE_REF_P (t)\n \t      && TREE_CODE (TREE_OPERAND (t, 0)) == COMPONENT_REF)\n-\t    t = TREE_OPERAND (t, 0);\n+\t    {\n+\t      t = TREE_OPERAND (t, 0);\n+\t      OMP_CLAUSE_DECL (c) = t;\n+\t    }\n \t  if (TREE_CODE (t) == COMPONENT_REF\n \t      && allow_fields\n \t      && OMP_CLAUSE_CODE (c) != OMP_CLAUSE__CACHE_)\n@@ -6443,23 +6531,17 @@ finish_omp_clauses (tree clauses, bool allow_fields, bool declare_simd)\n \t\tbreak;\n \t      if (VAR_P (t) || TREE_CODE (t) == PARM_DECL)\n \t\t{\n-\t\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n-\t\t      && (OMP_CLAUSE_MAP_KIND (c)\n-\t\t\t  == GOMP_MAP_FIRSTPRIVATE_POINTER))\n-\t\t    {\n-\t\t      if (bitmap_bit_p (&generic_field_head, DECL_UID (t)))\n-\t\t\tbreak;\n-\t\t    }\n-\t\t  else if (bitmap_bit_p (&map_field_head, DECL_UID (t)))\n-\t\t    break;\n+\t\t  if (bitmap_bit_p (&map_field_head, DECL_UID (t)))\n+\t\t    goto handle_map_references;\n \t\t}\n \t    }\n \t  if (!VAR_P (t) && TREE_CODE (t) != PARM_DECL)\n \t    {\n \t      if (processing_template_decl)\n \t\tbreak;\n \t      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n-\t\t  && OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_POINTER)\n+\t\t  && (OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_POINTER\n+\t\t      || OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_ALWAYS_POINTER))\n \t\tbreak;\n \t      if (DECL_P (t))\n \t\terror (\"%qD is not a variable in %qs clause\", t,\n@@ -6511,17 +6593,13 @@ finish_omp_clauses (tree clauses, bool allow_fields, bool declare_simd)\n \t\t  error (\"%qD appears more than once in data clauses\", t);\n \t\t  remove = true;\n \t\t}\n-\t      else\n+\t      else if (bitmap_bit_p (&map_head, DECL_UID (t)))\n \t\t{\n-\t\t  bitmap_set_bit (&generic_head, DECL_UID (t));\n-\t\t  if (t != OMP_CLAUSE_DECL (c)\n-\t\t      && (TREE_CODE (OMP_CLAUSE_DECL (c)) == COMPONENT_REF\n-\t\t\t  || (REFERENCE_REF_P (OMP_CLAUSE_DECL (c))\n-\t\t\t      && (TREE_CODE (TREE_OPERAND (OMP_CLAUSE_DECL (c),\n-\t\t\t\t\t\t\t   0))\n-\t\t\t\t  == COMPONENT_REF))))\n-\t\t    bitmap_set_bit (&generic_field_head, DECL_UID (t));\n+\t\t  error (\"%qD appears both in data and map clauses\", t);\n+\t\t  remove = true;\n \t\t}\n+\t      else\n+\t\tbitmap_set_bit (&generic_head, DECL_UID (t));\n \t    }\n \t  else if (bitmap_bit_p (&map_head, DECL_UID (t)))\n \t    {\n@@ -6531,27 +6609,88 @@ finish_omp_clauses (tree clauses, bool allow_fields, bool declare_simd)\n \t\terror (\"%qD appears more than once in map clauses\", t);\n \t      remove = true;\n \t    }\n+\t  else if (bitmap_bit_p (&generic_head, DECL_UID (t))\n+\t\t   || bitmap_bit_p (&firstprivate_head, DECL_UID (t)))\n+\t    {\n+\t      error (\"%qD appears both in data and map clauses\", t);\n+\t      remove = true;\n+\t    }\n \t  else\n \t    {\n \t      bitmap_set_bit (&map_head, DECL_UID (t));\n \t      if (t != OMP_CLAUSE_DECL (c)\n \t\t  && TREE_CODE (OMP_CLAUSE_DECL (c)) == COMPONENT_REF)\n \t\tbitmap_set_bit (&map_field_head, DECL_UID (t));\n \t    }\n+\thandle_map_references:\n+\t  if (!remove\n+\t      && !processing_template_decl\n+\t      && allow_fields\n+\t      && TREE_CODE (TREE_TYPE (OMP_CLAUSE_DECL (c))) == REFERENCE_TYPE)\n+\t    {\n+\t      t = OMP_CLAUSE_DECL (c);\n+\t      if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_MAP)\n+\t\t{\n+\t\t  OMP_CLAUSE_DECL (c) = build_simple_mem_ref (t);\n+\t\t  if (OMP_CLAUSE_SIZE (c) == NULL_TREE)\n+\t\t    OMP_CLAUSE_SIZE (c)\n+\t\t      = TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (t)));\n+\t\t}\n+\t      else if (OMP_CLAUSE_MAP_KIND (c)\n+\t\t       != GOMP_MAP_FIRSTPRIVATE_POINTER\n+\t\t       && (OMP_CLAUSE_MAP_KIND (c)\n+\t\t\t   != GOMP_MAP_FIRSTPRIVATE_REFERENCE)\n+\t\t       && (OMP_CLAUSE_MAP_KIND (c)\n+\t\t\t   != GOMP_MAP_ALWAYS_POINTER))\n+\t\t{\n+\t\t  tree c2 = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\t      OMP_CLAUSE_MAP);\n+\t\t  if (TREE_CODE (t) == COMPONENT_REF)\n+\t\t    OMP_CLAUSE_SET_MAP_KIND (c2, GOMP_MAP_ALWAYS_POINTER);\n+\t\t  else\n+\t\t    OMP_CLAUSE_SET_MAP_KIND (c2,\n+\t\t\t\t\t     GOMP_MAP_FIRSTPRIVATE_REFERENCE);\n+\t\t  OMP_CLAUSE_DECL (c2) = t;\n+\t\t  OMP_CLAUSE_SIZE (c2) = size_zero_node;\n+\t\t  OMP_CLAUSE_CHAIN (c2) = OMP_CLAUSE_CHAIN (c);\n+\t\t  OMP_CLAUSE_CHAIN (c) = c2;\n+\t\t  OMP_CLAUSE_DECL (c) = build_simple_mem_ref (t);\n+\t\t  if (OMP_CLAUSE_SIZE (c) == NULL_TREE)\n+\t\t    OMP_CLAUSE_SIZE (c)\n+\t\t      = TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (t)));\n+\t\t  c = c2;\n+\t\t}\n+\t    }\n \t  break;\n \n \tcase OMP_CLAUSE_TO_DECLARE:\n-\t  t = OMP_CLAUSE_DECL (c);\n-\t  if (TREE_CODE (t) == FUNCTION_DECL)\n-\t    break;\n-\t  /* FALLTHRU */\n \tcase OMP_CLAUSE_LINK:\n \t  t = OMP_CLAUSE_DECL (c);\n-\t  if (!VAR_P (t))\n+\t  if (TREE_CODE (t) == FUNCTION_DECL\n+\t      && OMP_CLAUSE_CODE (c) == OMP_CLAUSE_TO_DECLARE)\n+\t    ;\n+\t  else if (!VAR_P (t))\n \t    {\n-\t      error_at (OMP_CLAUSE_LOCATION (c),\n-\t\t\t\"%qE is not a variable in clause %qs\", t,\n-\t\t\tomp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_TO_DECLARE)\n+\t\t{\n+\t\t  if (TREE_CODE (t) == OVERLOAD && OVL_CHAIN (t))\n+\t\t    error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t      \"overloaded function name %qE in clause %qs\", t,\n+\t\t\t      omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t\t  else if (TREE_CODE (t) == TEMPLATE_ID_EXPR)\n+\t\t    error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t      \"template %qE in clause %qs\", t,\n+\t\t\t      omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t\t  else\n+\t\t    error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t      \"%qE is neither a variable nor a function name \"\n+\t\t\t      \"in clause %qs\", t,\n+\t\t\t      omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t\t}\n+\t      else\n+\t\terror_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t  \"%qE is not a variable in clause %qs\", t,\n+\t\t\t  omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n \t      remove = true;\n \t    }\n \t  else if (DECL_THREAD_LOCAL_P (t))\n@@ -6568,6 +6707,17 @@ finish_omp_clauses (tree clauses, bool allow_fields, bool declare_simd)\n \t\t\tomp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n \t      remove = true;\n \t    }\n+\t  if (remove)\n+\t    break;\n+\t  if (bitmap_bit_p (&generic_head, DECL_UID (t)))\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%qE appears more than once on the same \"\n+\t\t\t\"%<declare target%> directive\", t);\n+\t      remove = true;\n+\t    }\n+\t  else\n+\t    bitmap_set_bit (&generic_head, DECL_UID (t));\n \t  break;\n \n \tcase OMP_CLAUSE_UNIFORM:\n@@ -6583,6 +6733,8 @@ finish_omp_clauses (tree clauses, bool allow_fields, bool declare_simd)\n \t      remove = true;\n \t      break;\n \t    }\n+\t  /* map_head bitmap is used as uniform_head if declare_simd.  */\n+\t  bitmap_set_bit (&map_head, DECL_UID (t));\n \t  goto check_dup_generic;\n \n \tcase OMP_CLAUSE_GRAINSIZE:\n@@ -6688,7 +6840,6 @@ finish_omp_clauses (tree clauses, bool allow_fields, bool declare_simd)\n \t  goto check_dup_generic;\n \n \tcase OMP_CLAUSE_NOWAIT:\n-\tcase OMP_CLAUSE_ORDERED:\n \tcase OMP_CLAUSE_DEFAULT:\n \tcase OMP_CLAUSE_UNTIED:\n \tcase OMP_CLAUSE_COLLAPSE:\n@@ -6707,6 +6858,10 @@ finish_omp_clauses (tree clauses, bool allow_fields, bool declare_simd)\n \tcase OMP_CLAUSE_SEQ:\n \t  break;\n \n+\tcase OMP_CLAUSE_ORDERED:\n+\t  ordered_seen = true;\n+\t  break;\n+\n \tcase OMP_CLAUSE_INBRANCH:\n \tcase OMP_CLAUSE_NOTINBRANCH:\n \t  if (branch_seen)\n@@ -6768,6 +6923,17 @@ finish_omp_clauses (tree clauses, bool allow_fields, bool declare_simd)\n \tcase OMP_CLAUSE_LINEAR:\n \t  if (!declare_simd)\n \t    need_implicitly_determined = true;\n+\t  else if (OMP_CLAUSE_LINEAR_VARIABLE_STRIDE (c)\n+\t\t   && !bitmap_bit_p (&map_head,\n+\t\t\t\t     DECL_UID (OMP_CLAUSE_LINEAR_STEP (c))))\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%<linear%> clause step is a parameter %qD not \"\n+\t\t\t\"specified in %<uniform%> clause\",\n+\t\t\tOMP_CLAUSE_LINEAR_STEP (c));\n+\t      *pc = OMP_CLAUSE_CHAIN (c);\n+\t      continue;\n+\t    }\n \t  break;\n \tcase OMP_CLAUSE_COPYPRIVATE:\n \t  need_copy_assignment = true;\n@@ -6789,6 +6955,21 @@ finish_omp_clauses (tree clauses, bool allow_fields, bool declare_simd)\n \t    }\n \t  pc = &OMP_CLAUSE_CHAIN (c);\n \t  continue;\n+\tcase OMP_CLAUSE_SCHEDULE:\n+\t  if (ordered_seen\n+\t      && (OMP_CLAUSE_SCHEDULE_KIND (c)\n+\t\t  & OMP_CLAUSE_SCHEDULE_NONMONOTONIC))\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%<nonmonotonic%> schedule modifier specified \"\n+\t\t\t\"together with %<ordered%> clause\");\n+\t      OMP_CLAUSE_SCHEDULE_KIND (c)\n+\t\t= (enum omp_clause_schedule_kind)\n+\t\t  (OMP_CLAUSE_SCHEDULE_KIND (c)\n+\t\t   & ~OMP_CLAUSE_SCHEDULE_NONMONOTONIC);\n+\t    }\n+\t  pc = &OMP_CLAUSE_CHAIN (c);\n+\t  continue;\n \tcase OMP_CLAUSE_NOWAIT:\n \t  if (copyprivate_seen)\n \t    {\n@@ -6906,6 +7087,15 @@ finish_omp_clauses (tree clauses, bool allow_fields, bool declare_simd)\n \t\t\t\t\t need_dtor))\n \tremove = true;\n \n+      if (!remove\n+\t  && c_kind == OMP_CLAUSE_SHARED\n+\t  && processing_template_decl)\n+\t{\n+\t  t = omp_clause_decl_field (OMP_CLAUSE_DECL (c));\n+\t  if (t)\n+\t    OMP_CLAUSE_DECL (c) = t;\n+\t}\n+\n       if (remove)\n \t*pc = OMP_CLAUSE_CHAIN (c);\n       else\n@@ -7202,9 +7392,10 @@ finish_omp_task (tree clauses, tree body)\n \n static bool\n handle_omp_for_class_iterator (int i, location_t locus, enum tree_code code,\n-\t\t\t       tree declv, tree initv, tree condv, tree incrv,\n-\t\t\t       tree *body, tree *pre_body, tree &clauses,\n-\t\t\t       tree *lastp, int collapse, int ordered)\n+\t\t\t       tree declv, tree orig_declv, tree initv,\n+\t\t\t       tree condv, tree incrv, tree *body,\n+\t\t\t       tree *pre_body, tree &clauses, tree *lastp,\n+\t\t\t       int collapse, int ordered)\n {\n   tree diff, iter_init, iter_incr = NULL, last;\n   tree incr_var = NULL, orig_pre_body, orig_body, c;\n@@ -7261,6 +7452,10 @@ handle_omp_for_class_iterator (int i, location_t locus, enum tree_code code,\n \t\tTREE_OPERAND (cond, 1), iter);\n       return true;\n     }\n+  if (!c_omp_check_loop_iv_exprs (locus, orig_declv,\n+\t\t\t\t  TREE_VEC_ELT (declv, i), NULL_TREE,\n+\t\t\t\t  cond, cp_walk_subtrees))\n+    return true;\n \n   switch (TREE_CODE (incr))\n     {\n@@ -7516,7 +7711,7 @@ handle_omp_for_class_iterator (int i, location_t locus, enum tree_code code,\n tree\n finish_omp_for (location_t locus, enum tree_code code, tree declv,\n \t\ttree orig_declv, tree initv, tree condv, tree incrv,\n-\t\ttree body, tree pre_body, tree clauses)\n+\t\ttree body, tree pre_body, vec<tree> *orig_inits, tree clauses)\n {\n   tree omp_for = NULL, orig_incr = NULL;\n   tree decl = NULL, init, cond, incr, orig_decl = NULL_TREE, block = NULL_TREE;\n@@ -7592,6 +7787,20 @@ finish_omp_for (location_t locus, enum tree_code code, tree declv,\n       TREE_VEC_ELT (initv, i) = init;\n     }\n \n+  if (orig_inits)\n+    {\n+      bool fail = false;\n+      tree orig_init;\n+      FOR_EACH_VEC_ELT (*orig_inits, i, orig_init)\n+\tif (orig_init\n+\t    && !c_omp_check_loop_iv_exprs (locus, declv,\n+\t\t\t\t\t   TREE_VEC_ELT (declv, i), orig_init,\n+\t\t\t\t\t   NULL_TREE, cp_walk_subtrees))\n+\t  fail = true;\n+      if (fail)\n+\treturn NULL;\n+    }\n+\n   if (dependent_omp_for_p (declv, initv, condv, incrv))\n     {\n       tree stmt;\n@@ -7665,10 +7874,10 @@ finish_omp_for (location_t locus, enum tree_code code, tree declv,\n \t    }\n \t  if (code == CILK_FOR && i == 0)\n \t    orig_decl = decl;\n-\t  if (handle_omp_for_class_iterator (i, locus, code, declv, initv,\n-\t\t\t\t\t     condv, incrv, &body, &pre_body,\n-\t\t\t\t\t     clauses, &last, collapse,\n-\t\t\t\t\t     ordered))\n+\t  if (handle_omp_for_class_iterator (i, locus, code, declv, orig_declv,\n+\t\t\t\t\t     initv, condv, incrv, &body,\n+\t\t\t\t\t     &pre_body, clauses, &last,\n+\t\t\t\t\t     collapse, ordered))\n \t    return NULL;\n \t  continue;\n \t}\n@@ -7727,13 +7936,19 @@ finish_omp_for (location_t locus, enum tree_code code, tree declv,\n   omp_for = c_finish_omp_for (locus, code, declv, orig_declv, initv, condv,\n \t\t\t      incrv, body, pre_body);\n \n+  /* Check for iterators appearing in lb, b or incr expressions.  */\n+  if (omp_for && !c_omp_check_loop_iv (omp_for, orig_declv, cp_walk_subtrees))\n+    omp_for = NULL_TREE;\n+\n   if (omp_for == NULL)\n     {\n       if (block)\n \tpop_stmt_list (block);\n       return NULL;\n     }\n \n+  add_stmt (omp_for);\n+\n   for (i = 0; i < TREE_VEC_LENGTH (OMP_FOR_INCR (omp_for)); i++)\n     {\n       decl = TREE_OPERAND (TREE_VEC_ELT (OMP_FOR_INIT (omp_for), i), 0);\n@@ -8013,7 +8228,8 @@ finish_omp_atomic (enum tree_code code, enum tree_code opcode, tree lhs,\n \t  return;\n \t}\n       stmt = c_finish_omp_atomic (input_location, code, opcode, lhs, rhs,\n-\t\t\t\t  v, lhs1, rhs1, swapped, seq_cst);\n+\t\t\t\t  v, lhs1, rhs1, swapped, seq_cst,\n+\t\t\t\t  processing_template_decl != 0);\n       if (stmt == error_mark_node)\n \treturn;\n     }"}, {"sha": "e2c8f715fd5deb8a58645f56022dc8d9ce3e159a", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -1,3 +1,8 @@\n+2015-11-05  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* types.def (BT_FN_VOID_INT_OMPFN_SIZE_PTR_PTR_PTR_UINT_PTR): Remove.\n+\t(BT_FN_VOID_INT_OMPFN_SIZE_PTR_PTR_PTR_UINT_PTR_INT_INT): New.\n+\n 2015-11-03  Thomas Schwinge  <thomas@codesourcery.com>\n \t    Chung-Lin Tang  <cltang@codesourcery.com>\n "}, {"sha": "a37e856708bdf7fa56c36824c01cf94a46e8c4a8", "filename": "gcc/fortran/types.def", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ffortran%2Ftypes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ffortran%2Ftypes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftypes.def?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -215,15 +215,16 @@ DEF_FUNCTION_TYPE_7 (BT_FN_VOID_INT_SIZE_PTR_PTR_PTR_UINT_PTR,\n DEF_FUNCTION_TYPE_8 (BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_LONG_UINT,\n \t\t     BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR, BT_UINT,\n \t\t     BT_LONG, BT_LONG, BT_LONG, BT_LONG, BT_UINT)\n-DEF_FUNCTION_TYPE_8 (BT_FN_VOID_INT_OMPFN_SIZE_PTR_PTR_PTR_UINT_PTR,\n-\t\t     BT_VOID, BT_INT, BT_PTR_FN_VOID_PTR, BT_SIZE, BT_PTR,\n-\t\t     BT_PTR, BT_PTR, BT_UINT, BT_PTR)\n \n DEF_FUNCTION_TYPE_9 (BT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT_PTR_INT,\n \t\t     BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR,\n \t\t     BT_PTR_FN_VOID_PTR_PTR, BT_LONG, BT_LONG,\n \t\t     BT_BOOL, BT_UINT, BT_PTR, BT_INT)\n \n+DEF_FUNCTION_TYPE_10 (BT_FN_VOID_INT_OMPFN_SIZE_PTR_PTR_PTR_UINT_PTR_INT_INT,\n+\t\t      BT_VOID, BT_INT, BT_PTR_FN_VOID_PTR, BT_SIZE, BT_PTR,\n+\t\t      BT_PTR, BT_PTR, BT_UINT, BT_PTR, BT_INT, BT_INT)\n+\n DEF_FUNCTION_TYPE_11 (BT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_UINT_LONG_INT_LONG_LONG_LONG,\n \t\t      BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR,\n \t\t      BT_PTR_FN_VOID_PTR_PTR, BT_LONG, BT_LONG,"}, {"sha": "319e200f34b76ce7f6a5f35b41ea9ba72152aeda", "filename": "gcc/gimplify.c", "status": "modified", "additions": 553, "deletions": 87, "changes": 640, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -84,6 +84,9 @@ enum gimplify_omp_var_data\n \n   GOVD_MAP_0LEN_ARRAY = 32768,\n \n+  /* Flag for GOVD_MAP, if it is always, to or always, tofrom mapping.  */\n+  GOVD_MAP_ALWAYS_TO = 65536,\n+\n   GOVD_DATA_SHARE_CLASS = (GOVD_SHARED | GOVD_PRIVATE | GOVD_FIRSTPRIVATE\n \t\t\t   | GOVD_LASTPRIVATE | GOVD_REDUCTION | GOVD_LINEAR\n \t\t\t   | GOVD_LOCAL)\n@@ -5847,9 +5850,10 @@ omp_default_clause (struct gimplify_omp_ctx *ctx, tree decl,\n \t    {\n \t      splay_tree_node n2;\n \n-\t      if ((octx->region_type & (ORT_TARGET_DATA | ORT_TARGET)) != 0)\n-\t\tcontinue;\n \t      n2 = splay_tree_lookup (octx->variables, (splay_tree_key) decl);\n+\t      if ((octx->region_type & (ORT_TARGET_DATA | ORT_TARGET)) != 0\n+\t\t  && (n2 == NULL || (n2->value & GOVD_DATA_SHARE_CLASS) == 0))\n+\t\tcontinue;\n \t      if (n2 && (n2->value & GOVD_DATA_SHARE_CLASS) != GOVD_SHARED)\n \t\t{\n \t\t  flags |= GOVD_FIRSTPRIVATE;\n@@ -5964,8 +5968,13 @@ omp_notice_variable (struct gimplify_omp_ctx *ctx, tree decl, bool in_code)\n \t      else if (is_scalar)\n \t\tnflags |= GOVD_FIRSTPRIVATE;\n \t    }\n+\t  tree type = TREE_TYPE (decl);\n \t  if (nflags == flags\n-\t      && !lang_hooks.types.omp_mappable_type (TREE_TYPE (decl)))\n+\t      && gimplify_omp_ctxp->target_firstprivatize_array_bases\n+\t      && lang_hooks.decls.omp_privatize_by_reference (decl))\n+\t    type = TREE_TYPE (type);\n+\t  if (nflags == flags\n+\t      && !lang_hooks.types.omp_mappable_type (type))\n \t    {\n \t      error (\"%qD referenced in target region does not have \"\n \t\t     \"a mappable type\", decl);\n@@ -6084,6 +6093,9 @@ omp_is_private (struct gimplify_omp_ctx *ctx, tree decl, int simd)\n \t  else if ((n->value & GOVD_REDUCTION) != 0)\n \t    error (\"iteration variable %qE should not be reduction\",\n \t\t   DECL_NAME (decl));\n+\t  else if (simd == 0 && (n->value & GOVD_LINEAR) != 0)\n+\t    error (\"iteration variable %qE should not be linear\",\n+\t\t   DECL_NAME (decl));\n \t  else if (simd == 1 && (n->value & GOVD_LASTPRIVATE) != 0)\n \t    error (\"iteration variable %qE should not be lastprivate\",\n \t\t   DECL_NAME (decl));\n@@ -6141,10 +6153,12 @@ omp_check_private (struct gimplify_omp_ctx *ctx, tree decl, bool copyprivate)\n \t  return true;\n \t}\n \n-      if ((ctx->region_type & (ORT_TARGET | ORT_TARGET_DATA)) != 0)\n+      n = splay_tree_lookup (ctx->variables, (splay_tree_key) decl);\n+\n+      if ((ctx->region_type & (ORT_TARGET | ORT_TARGET_DATA)) != 0\n+\t  && (n == NULL || (n->value & GOVD_DATA_SHARE_CLASS) == 0))\n \tcontinue;\n \n-      n = splay_tree_lookup (ctx->variables, (splay_tree_key) decl);\n       if (n != NULL)\n \t{\n \t  if ((n->value & GOVD_LOCAL) != 0\n@@ -6175,12 +6189,12 @@ omp_no_lastprivate (struct gimplify_omp_ctx *ctx)\n \t  if (!ctx->combined_loop)\n \t    return false;\n \t  if (ctx->distribute)\n-\t    return true;\n+\t    return lang_GNU_Fortran ();\n \t  break;\n \tcase ORT_COMBINED_PARALLEL:\n \t  break;\n \tcase ORT_COMBINED_TEAMS:\n-\t  return true;\n+\t  return lang_GNU_Fortran ();\n \tdefault:\n \t  return false;\n \t}\n@@ -6215,7 +6229,7 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n   struct gimplify_omp_ctx *ctx, *outer_ctx;\n   tree c;\n   hash_map<tree, tree> *struct_map_to_clause = NULL;\n-  tree *orig_list_p = list_p;\n+  tree *prev_list_p = NULL;\n \n   ctx = new_omp_context (region_type);\n   outer_ctx = ctx->outer_context;\n@@ -6277,16 +6291,25 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t  else if (error_operand_p (decl))\n \t    goto do_add;\n \t  else if (outer_ctx\n-\t\t   && outer_ctx->region_type == ORT_COMBINED_PARALLEL\n+\t\t   && (outer_ctx->region_type == ORT_COMBINED_PARALLEL\n+\t\t       || outer_ctx->region_type == ORT_COMBINED_TEAMS)\n \t\t   && splay_tree_lookup (outer_ctx->variables,\n \t\t\t\t\t (splay_tree_key) decl) == NULL)\n-\t    omp_add_variable (outer_ctx, decl, GOVD_SHARED | GOVD_SEEN);\n+\t    {\n+\t      omp_add_variable (outer_ctx, decl, GOVD_SHARED | GOVD_SEEN);\n+\t      if (outer_ctx->outer_context)\n+\t\tomp_notice_variable (outer_ctx->outer_context, decl, true);\n+\t    }\n \t  else if (outer_ctx\n \t\t   && (outer_ctx->region_type & ORT_TASK) != 0\n \t\t   && outer_ctx->combined_loop\n \t\t   && splay_tree_lookup (outer_ctx->variables,\n \t\t\t\t\t (splay_tree_key) decl) == NULL)\n-\t    omp_add_variable (outer_ctx, decl, GOVD_LASTPRIVATE | GOVD_SEEN);\n+\t    {\n+\t      omp_add_variable (outer_ctx, decl, GOVD_LASTPRIVATE | GOVD_SEEN);\n+\t      if (outer_ctx->outer_context)\n+\t\tomp_notice_variable (outer_ctx->outer_context, decl, true);\n+\t    }\n \t  else if (outer_ctx\n \t\t   && outer_ctx->region_type == ORT_WORKSHARE\n \t\t   && outer_ctx->combined_loop\n@@ -6300,8 +6323,14 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t      == ORT_COMBINED_PARALLEL)\n \t\t  && splay_tree_lookup (outer_ctx->outer_context->variables,\n \t\t\t\t\t(splay_tree_key) decl) == NULL)\n-\t\tomp_add_variable (outer_ctx->outer_context, decl,\n-\t\t\t\t  GOVD_SHARED | GOVD_SEEN);\n+\t\t{\n+\t\t  struct gimplify_omp_ctx *octx = outer_ctx->outer_context;\n+\t\t  omp_add_variable (octx, decl, GOVD_SHARED | GOVD_SEEN);\n+\t\t  if (octx->outer_context)\n+\t\t    omp_notice_variable (octx->outer_context, decl, true);\n+\t\t}\n+\t      else if (outer_ctx->outer_context)\n+\t\tomp_notice_variable (outer_ctx->outer_context, decl, true);\n \t    }\n \t  goto do_add;\n \tcase OMP_CLAUSE_REDUCTION:\n@@ -6324,6 +6353,23 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t  omp_notice_variable (ctx, v, true);\n \t\t}\n \t      decl = TREE_OPERAND (decl, 0);\n+\t      if (TREE_CODE (decl) == POINTER_PLUS_EXPR)\n+\t\t{\n+\t\t  if (gimplify_expr (&TREE_OPERAND (decl, 1), pre_p,\n+\t\t\t\t     NULL, is_gimple_val, fb_rvalue)\n+\t\t      == GS_ERROR)\n+\t\t    {\n+\t\t      remove = true;\n+\t\t      break;\n+\t\t    }\n+\t\t  v = TREE_OPERAND (decl, 1);\n+\t\t  if (DECL_P (v))\n+\t\t    {\n+\t\t      omp_firstprivatize_variable (ctx, v);\n+\t\t      omp_notice_variable (ctx, v, true);\n+\t\t    }\n+\t\t  decl = TREE_OPERAND (decl, 0);\n+\t\t}\n \t      if (TREE_CODE (decl) == ADDR_EXPR\n \t\t  || TREE_CODE (decl) == INDIRECT_REF)\n \t\tdecl = TREE_OPERAND (decl, 0);\n@@ -6397,9 +6443,7 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t    {\n \t\t      if (octx->outer_context\n \t\t\t  && (octx->outer_context->region_type\n-\t\t\t      == ORT_COMBINED_PARALLEL\n-\t\t\t      || (octx->outer_context->region_type\n-\t\t\t\t  == ORT_COMBINED_TEAMS)))\n+\t\t\t      == ORT_COMBINED_PARALLEL))\n \t\t\toctx = octx->outer_context;\n \t\t      else if (omp_check_private (octx, decl, false))\n \t\t\tbreak;\n@@ -6413,9 +6457,16 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t\t   && ctx->region_type == ORT_WORKSHARE\n \t\t\t   && octx == outer_ctx)\n \t\t    flags = GOVD_SEEN | GOVD_SHARED;\n+\t\t  else if (octx\n+\t\t\t   && octx->region_type == ORT_COMBINED_TEAMS)\n+\t\t    flags = GOVD_SEEN | GOVD_SHARED;\n \t\t  else if (octx\n \t\t\t   && octx->region_type == ORT_COMBINED_TARGET)\n-\t\t    flags &= ~GOVD_LASTPRIVATE;\n+\t\t    {\n+\t\t      flags &= ~GOVD_LASTPRIVATE;\n+\t\t      if (flags == GOVD_SEEN)\n+\t\t\tbreak;\n+\t\t    }\n \t\t  else\n \t\t    break;\n \t\t  splay_tree_node on\n@@ -6458,7 +6509,9 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t    case OMP_TARGET_DATA:\n \t    case OMP_TARGET_ENTER_DATA:\n \t    case OMP_TARGET_EXIT_DATA:\n-\t      if (OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_FIRSTPRIVATE_POINTER)\n+\t      if (OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_FIRSTPRIVATE_POINTER\n+\t\t  || (OMP_CLAUSE_MAP_KIND (c)\n+\t\t      == GOMP_MAP_FIRSTPRIVATE_REFERENCE))\n \t\t/* For target {,enter ,exit }data only the array slice is\n \t\t   mapped, but not the pointer to it.  */\n \t\tremove = true;\n@@ -6477,7 +6530,9 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t      remove = true;\n \t      break;\n \t    }\n-\t  else if (OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_FIRSTPRIVATE_POINTER\n+\t  else if ((OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_FIRSTPRIVATE_POINTER\n+\t\t    || (OMP_CLAUSE_MAP_KIND (c)\n+\t\t\t== GOMP_MAP_FIRSTPRIVATE_REFERENCE))\n \t\t   && TREE_CODE (OMP_CLAUSE_SIZE (c)) != INTEGER_CST)\n \t    {\n \t      OMP_CLAUSE_SIZE (c)\n@@ -6536,6 +6591,25 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t      break;\n \t\t    }\n \n+\t\t  if (OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_ALWAYS_POINTER)\n+\t\t    {\n+\t\t      /* Error recovery.  */\n+\t\t      if (prev_list_p == NULL)\n+\t\t\t{\n+\t\t\t  remove = true;\n+\t\t\t  break;\n+\t\t\t}\n+\t\t      if (OMP_CLAUSE_CHAIN (*prev_list_p) != c)\n+\t\t\t{\n+\t\t\t  tree ch = OMP_CLAUSE_CHAIN (*prev_list_p);\n+\t\t\t  if (ch == NULL_TREE || OMP_CLAUSE_CHAIN (ch) != c)\n+\t\t\t    {\n+\t\t\t      remove = true;\n+\t\t\t      break;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\n \t\t  tree offset;\n \t\t  HOST_WIDE_INT bitsize, bitpos;\n \t\t  machine_mode mode;\n@@ -6555,56 +6629,64 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t  splay_tree_node n\n \t\t    = splay_tree_lookup (ctx->variables, (splay_tree_key)decl);\n \t\t  bool ptr = (OMP_CLAUSE_MAP_KIND (c)\n-\t\t\t      == GOMP_MAP_FIRSTPRIVATE_POINTER);\n-\t\t  if (n == NULL || (n->value & (ptr ? GOVD_PRIVATE\n-\t\t\t\t\t\t    : GOVD_MAP)) == 0)\n+\t\t\t      == GOMP_MAP_ALWAYS_POINTER);\n+\t\t  if (n == NULL || (n->value & GOVD_MAP) == 0)\n \t\t    {\n+\t\t      tree l = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\t\t OMP_CLAUSE_MAP);\n+\t\t      OMP_CLAUSE_SET_MAP_KIND (l, GOMP_MAP_STRUCT);\n+\t\t      OMP_CLAUSE_DECL (l) = decl;\n+\t\t      OMP_CLAUSE_SIZE (l) = size_int (1);\n+\t\t      if (struct_map_to_clause == NULL)\n+\t\t\tstruct_map_to_clause = new hash_map<tree, tree>;\n+\t\t      struct_map_to_clause->put (decl, l);\n \t\t      if (ptr)\n \t\t\t{\n+\t\t\t  enum gomp_map_kind mkind\n+\t\t\t    = code == OMP_TARGET_EXIT_DATA\n+\t\t\t      ? GOMP_MAP_RELEASE : GOMP_MAP_ALLOC;\n \t\t\t  tree c2 = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n-\t\t\t\t\t\t      OMP_CLAUSE_PRIVATE);\n-\t\t\t  OMP_CLAUSE_DECL (c2) = decl;\n-\t\t\t  OMP_CLAUSE_CHAIN (c2) = *orig_list_p;\n-\t\t\t  *orig_list_p = c2;\n-\t\t\t  if (struct_map_to_clause == NULL)\n-\t\t\t    struct_map_to_clause = new hash_map<tree, tree>;\n-\t\t\t  tree *osc;\n-\t\t\t  if (n == NULL || (n->value & GOVD_MAP) == 0)\n-\t\t\t    osc = NULL;\n-\t\t\t  else\n-\t\t\t    osc = struct_map_to_clause->get (decl);\n-\t\t\t  if (osc == NULL)\n-\t\t\t    struct_map_to_clause->put (decl,\n-\t\t\t\t\t\t       tree_cons (NULL_TREE,\n-\t\t\t\t\t\t\t\t  c,\n-\t\t\t\t\t\t\t\t  NULL_TREE));\n-\t\t\t  else\n-\t\t\t    *osc = tree_cons (*osc, c, NULL_TREE);\n-\t\t\t  flags = GOVD_PRIVATE | GOVD_EXPLICIT;\n-\t\t\t  goto do_add_decl;\n+\t\t\t\t\t\t      OMP_CLAUSE_MAP);\n+\t\t\t  OMP_CLAUSE_SET_MAP_KIND (c2, mkind);\n+\t\t\t  OMP_CLAUSE_DECL (c2)\n+\t\t\t    = unshare_expr (OMP_CLAUSE_DECL (c));\n+\t\t\t  OMP_CLAUSE_CHAIN (c2) = *prev_list_p;\n+\t\t\t  OMP_CLAUSE_SIZE (c2)\n+\t\t\t    = TYPE_SIZE_UNIT (ptr_type_node);\n+\t\t\t  OMP_CLAUSE_CHAIN (l) = c2;\n+\t\t\t  if (OMP_CLAUSE_CHAIN (*prev_list_p) != c)\n+\t\t\t    {\n+\t\t\t      tree c4 = OMP_CLAUSE_CHAIN (*prev_list_p);\n+\t\t\t      tree c3\n+\t\t\t\t= build_omp_clause (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\t\t    OMP_CLAUSE_MAP);\n+\t\t\t      OMP_CLAUSE_SET_MAP_KIND (c3, mkind);\n+\t\t\t      OMP_CLAUSE_DECL (c3)\n+\t\t\t\t= unshare_expr (OMP_CLAUSE_DECL (c4));\n+\t\t\t      OMP_CLAUSE_SIZE (c3)\n+\t\t\t\t= TYPE_SIZE_UNIT (ptr_type_node);\n+\t\t\t      OMP_CLAUSE_CHAIN (c3) = *prev_list_p;\n+\t\t\t      OMP_CLAUSE_CHAIN (c2) = c3;\n+\t\t\t    }\n+\t\t\t  *prev_list_p = l;\n+\t\t\t  prev_list_p = NULL;\n+\t\t\t}\n+\t\t      else\n+\t\t\t{\n+\t\t\t  OMP_CLAUSE_CHAIN (l) = c;\n+\t\t\t  *list_p = l;\n+\t\t\t  list_p = &OMP_CLAUSE_CHAIN (l);\n \t\t\t}\n-\t\t      *list_p = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n-\t\t\t\t\t\t  OMP_CLAUSE_MAP);\n-\t\t      OMP_CLAUSE_SET_MAP_KIND (*list_p, GOMP_MAP_STRUCT);\n-\t\t      OMP_CLAUSE_DECL (*list_p) = decl;\n-\t\t      OMP_CLAUSE_SIZE (*list_p) = size_int (1);\n-\t\t      OMP_CLAUSE_CHAIN (*list_p) = c;\n-\t\t      if (struct_map_to_clause == NULL)\n-\t\t\tstruct_map_to_clause = new hash_map<tree, tree>;\n-\t\t      struct_map_to_clause->put (decl, *list_p);\n-\t\t      list_p = &OMP_CLAUSE_CHAIN (*list_p);\n \t\t      flags = GOVD_MAP | GOVD_EXPLICIT;\n-\t\t      if (OMP_CLAUSE_MAP_KIND (c) & GOMP_MAP_FLAG_ALWAYS)\n+\t\t      if (GOMP_MAP_ALWAYS_P (OMP_CLAUSE_MAP_KIND (c)) || ptr)\n \t\t\tflags |= GOVD_SEEN;\n \t\t      goto do_add_decl;\n \t\t    }\n \t\t  else\n \t\t    {\n \t\t      tree *osc = struct_map_to_clause->get (decl);\n-\t\t      tree *sc = NULL, *pt = NULL;\n-\t\t      if (!ptr && TREE_CODE (*osc) == TREE_LIST)\n-\t\t\tosc = &TREE_PURPOSE (*osc);\n-\t\t      if (OMP_CLAUSE_MAP_KIND (c) & GOMP_MAP_FLAG_ALWAYS)\n+\t\t      tree *sc = NULL, *scp = NULL;\n+\t\t      if (GOMP_MAP_ALWAYS_P (OMP_CLAUSE_MAP_KIND (c)) || ptr)\n \t\t\tn->value |= GOVD_SEEN;\n \t\t      offset_int o1, o2;\n \t\t      if (offset)\n@@ -6613,18 +6695,16 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t\to1 = 0;\n \t\t      if (bitpos)\n \t\t\to1 = o1 + bitpos / BITS_PER_UNIT;\n-\t\t      if (ptr)\n-\t\t\tpt = osc;\n-\t\t      else\n-\t\t\tsc = &OMP_CLAUSE_CHAIN (*osc);\n-\t\t      for (; ptr ? (*pt && (sc = &TREE_VALUE (*pt)))\n-\t\t\t\t : *sc != c;\n-\t\t\t   ptr ? (pt = &TREE_CHAIN (*pt))\n-\t\t\t       : (sc = &OMP_CLAUSE_CHAIN (*sc)))\n-\t\t\tif (TREE_CODE (OMP_CLAUSE_DECL (*sc)) != COMPONENT_REF\n-\t\t\t    && (TREE_CODE (OMP_CLAUSE_DECL (*sc))\n-\t\t\t\t!= INDIRECT_REF)\n-\t\t\t    && TREE_CODE (OMP_CLAUSE_DECL (*sc)) != ARRAY_REF)\n+\t\t      for (sc = &OMP_CLAUSE_CHAIN (*osc);\n+\t\t\t   *sc != c; sc = &OMP_CLAUSE_CHAIN (*sc))\n+\t\t\tif (ptr && sc == prev_list_p)\n+\t\t\t  break;\n+\t\t\telse if (TREE_CODE (OMP_CLAUSE_DECL (*sc))\n+\t\t\t\t != COMPONENT_REF\n+\t\t\t\t && (TREE_CODE (OMP_CLAUSE_DECL (*sc))\n+\t\t\t\t     != INDIRECT_REF)\n+\t\t\t\t && (TREE_CODE (OMP_CLAUSE_DECL (*sc))\n+\t\t\t\t     != ARRAY_REF))\n \t\t\t  break;\n \t\t\telse\n \t\t\t  {\n@@ -6653,6 +6733,8 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t\t\t\t\t\t&volatilep, false);\n \t\t\t    if (base != decl)\n \t\t\t      break;\n+\t\t\t    if (scp)\n+\t\t\t      continue;\n \t\t\t    gcc_assert (offset == NULL_TREE\n \t\t\t\t\t|| TREE_CODE (offset) == INTEGER_CST);\n \t\t\t    tree d1 = OMP_CLAUSE_DECL (*sc);\n@@ -6691,19 +6773,68 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t\t      o2 = o2 + bitpos2 / BITS_PER_UNIT;\n \t\t\t    if (wi::ltu_p (o1, o2)\n \t\t\t\t|| (wi::eq_p (o1, o2) && bitpos < bitpos2))\n-\t\t\t      break;\n+\t\t\t      {\n+\t\t\t\tif (ptr)\n+\t\t\t\t  scp = sc;\n+\t\t\t\telse\n+\t\t\t\t  break;\n+\t\t\t      }\n \t\t\t  }\n+\t\t      if (remove)\n+\t\t\tbreak;\n+\t\t      OMP_CLAUSE_SIZE (*osc)\n+\t\t\t= size_binop (PLUS_EXPR, OMP_CLAUSE_SIZE (*osc),\n+\t\t\t\t      size_one_node);\n \t\t      if (ptr)\n \t\t\t{\n-\t\t\t  if (!remove)\n-\t\t\t    *pt = tree_cons (TREE_PURPOSE (*osc), c, *pt);\n-\t\t\t  break;\n+\t\t\t  tree c2 = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\t\t      OMP_CLAUSE_MAP);\n+\t\t\t  tree cl = NULL_TREE;\n+\t\t\t  enum gomp_map_kind mkind\n+\t\t\t    = code == OMP_TARGET_EXIT_DATA\n+\t\t\t      ? GOMP_MAP_RELEASE : GOMP_MAP_ALLOC;\n+\t\t\t  OMP_CLAUSE_SET_MAP_KIND (c2, mkind);\n+\t\t\t  OMP_CLAUSE_DECL (c2)\n+\t\t\t    = unshare_expr (OMP_CLAUSE_DECL (c));\n+\t\t\t  OMP_CLAUSE_CHAIN (c2) = scp ? *scp : *prev_list_p;\n+\t\t\t  OMP_CLAUSE_SIZE (c2)\n+\t\t\t    = TYPE_SIZE_UNIT (ptr_type_node);\n+\t\t\t  cl = scp ? *prev_list_p : c2;\n+\t\t\t  if (OMP_CLAUSE_CHAIN (*prev_list_p) != c)\n+\t\t\t    {\n+\t\t\t      tree c4 = OMP_CLAUSE_CHAIN (*prev_list_p);\n+\t\t\t      tree c3\n+\t\t\t\t= build_omp_clause (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\t\t    OMP_CLAUSE_MAP);\n+\t\t\t      OMP_CLAUSE_SET_MAP_KIND (c3, mkind);\n+\t\t\t      OMP_CLAUSE_DECL (c3)\n+\t\t\t\t= unshare_expr (OMP_CLAUSE_DECL (c4));\n+\t\t\t      OMP_CLAUSE_SIZE (c3)\n+\t\t\t\t= TYPE_SIZE_UNIT (ptr_type_node);\n+\t\t\t      OMP_CLAUSE_CHAIN (c3) = *prev_list_p;\n+\t\t\t      if (!scp)\n+\t\t\t\tOMP_CLAUSE_CHAIN (c2) = c3;\n+\t\t\t      else\n+\t\t\t\tcl = c3;\n+\t\t\t    }\n+\t\t\t  if (scp)\n+\t\t\t    *scp = c2;\n+\t\t\t  if (sc == prev_list_p)\n+\t\t\t    {\n+\t\t\t      *sc = cl;\n+\t\t\t      prev_list_p = NULL;\n+\t\t\t    }\n+\t\t\t  else\n+\t\t\t    {\n+\t\t\t      *prev_list_p = OMP_CLAUSE_CHAIN (c);\n+\t\t\t      list_p = prev_list_p;\n+\t\t\t      prev_list_p = NULL;\n+\t\t\t      OMP_CLAUSE_CHAIN (c) = *sc;\n+\t\t\t      *sc = cl;\n+\t\t\t      continue;\n+\t\t\t    }\n \t\t\t}\n-\t\t      if (!remove)\n-\t\t\tOMP_CLAUSE_SIZE (*osc)\n-\t\t\t  = size_binop (PLUS_EXPR, OMP_CLAUSE_SIZE (*osc),\n-\t\t\t\t\tsize_one_node);\n-\t\t      if (!remove && *sc != c)\n+\t\t      else if (*sc != c)\n \t\t\t{\n \t\t\t  *list_p = OMP_CLAUSE_CHAIN (c);\n \t\t\t  OMP_CLAUSE_CHAIN (c) = *sc;\n@@ -6712,9 +6843,19 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t\t}\n \t\t    }\n \t\t}\n+\t      if (!remove\n+\t\t  && OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_ALWAYS_POINTER\n+\t\t  && OMP_CLAUSE_CHAIN (c)\n+\t\t  && OMP_CLAUSE_CODE (OMP_CLAUSE_CHAIN (c)) == OMP_CLAUSE_MAP\n+\t\t  && (OMP_CLAUSE_MAP_KIND (OMP_CLAUSE_CHAIN (c))\n+\t\t      == GOMP_MAP_ALWAYS_POINTER))\n+\t\tprev_list_p = list_p;\n \t      break;\n \t    }\n \t  flags = GOVD_MAP | GOVD_EXPLICIT;\n+\t  if (OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_ALWAYS_TO\n+\t      || OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_ALWAYS_TOFROM)\n+\t    flags |= GOVD_MAP_ALWAYS_TO;\n \t  goto do_add;\n \n \tcase OMP_CLAUSE_DEPEND:\n@@ -6923,7 +7064,12 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t  || decl == OMP_CLAUSE_DECL (c)\n \t\t  || (TREE_CODE (OMP_CLAUSE_DECL (c)) == MEM_REF\n \t\t      && (TREE_CODE (TREE_OPERAND (OMP_CLAUSE_DECL (c), 0))\n-\t\t\t  == ADDR_EXPR)))\n+\t\t\t  == ADDR_EXPR\n+\t\t\t  || (TREE_CODE (TREE_OPERAND (OMP_CLAUSE_DECL (c), 0))\n+\t\t\t      == POINTER_PLUS_EXPR\n+\t\t\t      && (TREE_CODE (TREE_OPERAND (TREE_OPERAND\n+\t\t\t\t\t\t(OMP_CLAUSE_DECL (c), 0), 0))\n+\t\t\t\t  == ADDR_EXPR)))))\n \t      && omp_check_private (ctx, decl, false))\n \t    {\n \t      error (\"%s variable %qE is private in outer context\",\n@@ -7192,6 +7338,25 @@ gimplify_adjust_omp_clauses_1 (splay_tree_node n, void *data)\n \t  OMP_CLAUSE_CHAIN (nc) = OMP_CLAUSE_CHAIN (clause);\n \t  OMP_CLAUSE_CHAIN (clause) = nc;\n \t}\n+      else if (gimplify_omp_ctxp->target_firstprivatize_array_bases\n+\t       && lang_hooks.decls.omp_privatize_by_reference (decl))\n+\t{\n+\t  OMP_CLAUSE_DECL (clause) = build_simple_mem_ref (decl);\n+\t  OMP_CLAUSE_SIZE (clause)\n+\t    = unshare_expr (TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (decl))));\n+\t  struct gimplify_omp_ctx *ctx = gimplify_omp_ctxp;\n+\t  gimplify_omp_ctxp = ctx->outer_context;\n+\t  gimplify_expr (&OMP_CLAUSE_SIZE (clause),\n+\t\t\t pre_p, NULL, is_gimple_val, fb_rvalue);\n+\t  gimplify_omp_ctxp = ctx;\n+\t  tree nc = build_omp_clause (OMP_CLAUSE_LOCATION (clause),\n+\t\t\t\t      OMP_CLAUSE_MAP);\n+\t  OMP_CLAUSE_DECL (nc) = decl;\n+\t  OMP_CLAUSE_SIZE (nc) = size_zero_node;\n+\t  OMP_CLAUSE_SET_MAP_KIND (nc, GOMP_MAP_FIRSTPRIVATE_REFERENCE);\n+\t  OMP_CLAUSE_CHAIN (nc) = OMP_CLAUSE_CHAIN (clause);\n+\t  OMP_CLAUSE_CHAIN (clause) = nc;\n+\t}\n       else\n \tOMP_CLAUSE_SIZE (clause) = DECL_SIZE_UNIT (decl);\n     }\n@@ -7265,6 +7430,15 @@ gimplify_adjust_omp_clauses (gimple_seq *pre_p, tree *list_p,\n \t      else\n \t\tOMP_CLAUSE_CODE (c) = OMP_CLAUSE_PRIVATE;\n \t    }\n+\t  else if (code == OMP_DISTRIBUTE\n+\t\t   && OMP_CLAUSE_LASTPRIVATE_FIRSTPRIVATE (c))\n+\t    {\n+\t      remove = true;\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"same variable used in %<firstprivate%> and \"\n+\t\t\t\"%<lastprivate%> clauses on %<distribute%> \"\n+\t\t\t\"construct\");\n+\t    }\n \t  break;\n \n \tcase OMP_CLAUSE_ALIGNED:\n@@ -7310,6 +7484,12 @@ gimplify_adjust_omp_clauses (gimple_seq *pre_p, tree *list_p,\n \t  break;\n \n \tcase OMP_CLAUSE_MAP:\n+\t  if (code == OMP_TARGET_EXIT_DATA\n+\t      && OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_ALWAYS_POINTER)\n+\t    {\n+\t      remove = true;\n+\t      break;\n+\t    }\n \t  decl = OMP_CLAUSE_DECL (c);\n \t  if (!DECL_P (decl))\n \t    {\n@@ -7339,8 +7519,7 @@ gimplify_adjust_omp_clauses (gimple_seq *pre_p, tree *list_p,\n \t  n = splay_tree_lookup (ctx->variables, (splay_tree_key) decl);\n \t  if ((ctx->region_type & ORT_TARGET) != 0\n \t      && !(n->value & GOVD_SEEN)\n-\t      && ((OMP_CLAUSE_MAP_KIND (c) & GOMP_MAP_FLAG_ALWAYS) == 0\n-\t\t  || OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_STRUCT))\n+\t      && GOMP_MAP_ALWAYS_P (OMP_CLAUSE_MAP_KIND (c)) == 0)\n \t    {\n \t      remove = true;\n \t      /* For struct element mapping, if struct is never referenced\n@@ -7361,7 +7540,9 @@ gimplify_adjust_omp_clauses (gimple_seq *pre_p, tree *list_p,\n \t  else if (DECL_SIZE (decl)\n \t\t   && TREE_CODE (DECL_SIZE (decl)) != INTEGER_CST\n \t\t   && OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_POINTER\n-\t\t   && OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_FIRSTPRIVATE_POINTER)\n+\t\t   && OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_FIRSTPRIVATE_POINTER\n+\t\t   && (OMP_CLAUSE_MAP_KIND (c)\n+\t\t       != GOMP_MAP_FIRSTPRIVATE_REFERENCE))\n \t    {\n \t      /* For GOMP_MAP_FORCE_DEVICEPTR, we'll never enter here, because\n \t\t for these, TREE_CODE (DECL_SIZE (decl)) will always be\n@@ -7404,9 +7585,9 @@ gimplify_adjust_omp_clauses (gimple_seq *pre_p, tree *list_p,\n \t    {\n \t      if (OMP_CLAUSE_SIZE (c) == NULL_TREE)\n \t\tOMP_CLAUSE_SIZE (c) = DECL_SIZE_UNIT (decl);\n-\t      if ((n->value & GOVD_SEEN)\n-\t\t  && (n->value & (GOVD_PRIVATE | GOVD_FIRSTPRIVATE)))\n-\t\tOMP_CLAUSE_MAP_PRIVATE (c) = 1;\n+\t      gcc_assert ((n->value & GOVD_SEEN) == 0\n+\t\t\t  || ((n->value & (GOVD_PRIVATE | GOVD_FIRSTPRIVATE))\n+\t\t\t      == 0));\n \t    }\n \t  break;\n \n@@ -7878,6 +8059,26 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t\t\t  OMP_CLAUSE_LINEAR_NO_COPYOUT (c) = 1;\n \t\t\t  flags |= GOVD_LINEAR_LASTPRIVATE_NO_OUTER;\n \t\t\t}\n+\t\t      else\n+\t\t\t{\n+\t\t\t  struct gimplify_omp_ctx *octx = outer->outer_context;\n+\t\t\t  if (octx\n+\t\t\t      && octx->region_type == ORT_COMBINED_PARALLEL\n+\t\t\t      && octx->outer_context\n+\t\t\t      && (octx->outer_context->region_type\n+\t\t\t\t  == ORT_WORKSHARE)\n+\t\t\t      && octx->outer_context->combined_loop)\n+\t\t\t    {\n+\t\t\t      octx = octx->outer_context;\n+\t\t\t      n = splay_tree_lookup (octx->variables,\n+\t\t\t\t\t\t     (splay_tree_key)decl);\n+\t\t\t      if (n != NULL && (n->value & GOVD_LOCAL) != 0)\n+\t\t\t\t{\n+\t\t\t\t  OMP_CLAUSE_LINEAR_NO_COPYOUT (c) = 1;\n+\t\t\t\t  flags |= GOVD_LINEAR_LASTPRIVATE_NO_OUTER;\n+\t\t\t\t}\n+\t\t\t    }\n+\t\t\t}\n \t\t    }\n \t\t}\n \n@@ -7912,7 +8113,41 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t\t\t{\n \t\t\t  omp_add_variable (outer, decl,\n \t\t\t\t\t    GOVD_LASTPRIVATE | GOVD_SEEN);\n-\t\t\t  if (outer->outer_context)\n+\t\t\t  if (outer->region_type == ORT_COMBINED_PARALLEL\n+\t\t\t      && outer->outer_context\n+\t\t\t      && (outer->outer_context->region_type\n+\t\t\t\t  == ORT_WORKSHARE)\n+\t\t\t      && outer->outer_context->combined_loop)\n+\t\t\t    {\n+\t\t\t      outer = outer->outer_context;\n+\t\t\t      n = splay_tree_lookup (outer->variables,\n+\t\t\t\t\t\t     (splay_tree_key)decl);\n+\t\t\t      if (omp_check_private (outer, decl, false))\n+\t\t\t\touter = NULL;\n+\t\t\t      else if (n == NULL\n+\t\t\t\t       || ((n->value & GOVD_DATA_SHARE_CLASS)\n+\t\t\t\t\t   == 0))\n+\t\t\t\tomp_add_variable (outer, decl,\n+\t\t\t\t\t\t  GOVD_LASTPRIVATE\n+\t\t\t\t\t\t  | GOVD_SEEN);\n+\t\t\t      else\n+\t\t\t\touter = NULL;\n+\t\t\t    }\n+\t\t\t  if (outer && outer->outer_context\n+\t\t\t      && (outer->outer_context->region_type\n+\t\t\t\t  == ORT_COMBINED_TEAMS))\n+\t\t\t    {\n+\t\t\t      outer = outer->outer_context;\n+\t\t\t      n = splay_tree_lookup (outer->variables,\n+\t\t\t\t\t\t     (splay_tree_key)decl);\n+\t\t\t      if (n == NULL\n+\t\t\t\t  || (n->value & GOVD_DATA_SHARE_CLASS) == 0)\n+\t\t\t\tomp_add_variable (outer, decl,\n+\t\t\t\t\t\t  GOVD_SHARED | GOVD_SEEN);\n+\t\t\t      else\n+\t\t\t\touter = NULL;\n+\t\t\t    }\n+\t\t\t  if (outer && outer->outer_context)\n \t\t\t    omp_notice_variable (outer->outer_context, decl,\n \t\t\t\t\t\t true);\n \t\t\t}\n@@ -7961,7 +8196,41 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t\t\t{\n \t\t\t  omp_add_variable (outer, decl,\n \t\t\t\t\t    GOVD_LASTPRIVATE | GOVD_SEEN);\n-\t\t\t  if (outer->outer_context)\n+\t\t\t  if (outer->region_type == ORT_COMBINED_PARALLEL\n+\t\t\t      && outer->outer_context\n+\t\t\t      && (outer->outer_context->region_type\n+\t\t\t\t  == ORT_WORKSHARE)\n+\t\t\t      && outer->outer_context->combined_loop)\n+\t\t\t    {\n+\t\t\t      outer = outer->outer_context;\n+\t\t\t      n = splay_tree_lookup (outer->variables,\n+\t\t\t\t\t\t     (splay_tree_key)decl);\n+\t\t\t      if (omp_check_private (outer, decl, false))\n+\t\t\t\touter = NULL;\n+\t\t\t      else if (n == NULL\n+\t\t\t\t       || ((n->value & GOVD_DATA_SHARE_CLASS)\n+\t\t\t\t\t   == 0))\n+\t\t\t\tomp_add_variable (outer, decl,\n+\t\t\t\t\t\t  GOVD_LASTPRIVATE\n+\t\t\t\t\t\t  | GOVD_SEEN);\n+\t\t\t      else\n+\t\t\t\touter = NULL;\n+\t\t\t    }\n+\t\t\t  if (outer && outer->outer_context\n+\t\t\t      && (outer->outer_context->region_type\n+\t\t\t\t  == ORT_COMBINED_TEAMS))\n+\t\t\t    {\n+\t\t\t      outer = outer->outer_context;\n+\t\t\t      n = splay_tree_lookup (outer->variables,\n+\t\t\t\t\t\t     (splay_tree_key)decl);\n+\t\t\t      if (n == NULL\n+\t\t\t\t  || (n->value & GOVD_DATA_SHARE_CLASS) == 0)\n+\t\t\t\tomp_add_variable (outer, decl,\n+\t\t\t\t\t\t  GOVD_SHARED | GOVD_SEEN);\n+\t\t\t      else\n+\t\t\t\touter = NULL;\n+\t\t\t    }\n+\t\t\t  if (outer && outer->outer_context)\n \t\t\t    omp_notice_variable (outer->outer_context, decl,\n \t\t\t\t\t\t true);\n \t\t\t}\n@@ -8399,6 +8668,201 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n   return GS_ALL_DONE;\n }\n \n+/* Helper function of optimize_target_teams, find OMP_TEAMS inside\n+   of OMP_TARGET's body.  */\n+\n+static tree\n+find_omp_teams (tree *tp, int *walk_subtrees, void *)\n+{\n+  *walk_subtrees = 0;\n+  switch (TREE_CODE (*tp))\n+    {\n+    case OMP_TEAMS:\n+      return *tp;\n+    case BIND_EXPR:\n+    case STATEMENT_LIST:\n+      *walk_subtrees = 1;\n+      break;\n+    default:\n+      break;\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Helper function of optimize_target_teams, determine if the expression\n+   can be computed safely before the target construct on the host.  */\n+\n+static tree\n+computable_teams_clause (tree *tp, int *walk_subtrees, void *)\n+{\n+  splay_tree_node n;\n+\n+  if (TYPE_P (*tp))\n+    {\n+      *walk_subtrees = 0;\n+      return NULL_TREE;\n+    }\n+  switch (TREE_CODE (*tp))\n+    {\n+    case VAR_DECL:\n+    case PARM_DECL:\n+    case RESULT_DECL:\n+      *walk_subtrees = 0;\n+      if (error_operand_p (*tp)\n+\t  || !INTEGRAL_TYPE_P (TREE_TYPE (*tp))\n+\t  || DECL_HAS_VALUE_EXPR_P (*tp)\n+\t  || DECL_THREAD_LOCAL_P (*tp)\n+\t  || TREE_SIDE_EFFECTS (*tp)\n+\t  || TREE_THIS_VOLATILE (*tp))\n+\treturn *tp;\n+      if (is_global_var (*tp)\n+\t  && (lookup_attribute (\"omp declare target\", DECL_ATTRIBUTES (*tp))\n+\t      || lookup_attribute (\"omp declare target link\",\n+\t\t\t\t   DECL_ATTRIBUTES (*tp))))\n+\treturn *tp;\n+      n = splay_tree_lookup (gimplify_omp_ctxp->variables,\n+\t\t\t     (splay_tree_key) *tp);\n+      if (n == NULL)\n+\t{\n+\t  if (gimplify_omp_ctxp->target_map_scalars_firstprivate)\n+\t    return NULL_TREE;\n+\t  return *tp;\n+\t}\n+      else if (n->value & GOVD_LOCAL)\n+\treturn *tp;\n+      else if (n->value & GOVD_FIRSTPRIVATE)\n+\treturn NULL_TREE;\n+      else if ((n->value & (GOVD_MAP | GOVD_MAP_ALWAYS_TO))\n+\t       == (GOVD_MAP | GOVD_MAP_ALWAYS_TO))\n+\treturn NULL_TREE;\n+      return *tp;\n+    case INTEGER_CST:\n+      if (!INTEGRAL_TYPE_P (TREE_TYPE (*tp)))\n+\treturn *tp;\n+      return NULL_TREE;\n+    case TARGET_EXPR:\n+      if (TARGET_EXPR_INITIAL (*tp)\n+\t  || TREE_CODE (TARGET_EXPR_SLOT (*tp)) != VAR_DECL)\n+\treturn *tp;\n+      return computable_teams_clause (&TARGET_EXPR_SLOT (*tp),\n+\t\t\t\t      walk_subtrees, NULL);\n+    /* Allow some reasonable subset of integral arithmetics.  */\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+    case MULT_EXPR:\n+    case TRUNC_DIV_EXPR:\n+    case CEIL_DIV_EXPR:\n+    case FLOOR_DIV_EXPR:\n+    case ROUND_DIV_EXPR:\n+    case TRUNC_MOD_EXPR:\n+    case CEIL_MOD_EXPR:\n+    case FLOOR_MOD_EXPR:\n+    case ROUND_MOD_EXPR:\n+    case RDIV_EXPR:\n+    case EXACT_DIV_EXPR:\n+    case MIN_EXPR:\n+    case MAX_EXPR:\n+    case LSHIFT_EXPR:\n+    case RSHIFT_EXPR:\n+    case BIT_IOR_EXPR:\n+    case BIT_XOR_EXPR:\n+    case BIT_AND_EXPR:\n+    case NEGATE_EXPR:\n+    case ABS_EXPR:\n+    case BIT_NOT_EXPR:\n+    case NON_LVALUE_EXPR:\n+    CASE_CONVERT:\n+      if (!INTEGRAL_TYPE_P (TREE_TYPE (*tp)))\n+\treturn *tp;\n+      return NULL_TREE;\n+    /* And disallow anything else, except for comparisons.  */\n+    default:\n+      if (COMPARISON_CLASS_P (*tp))\n+\treturn NULL_TREE;\n+      return *tp;\n+    }\n+}\n+\n+/* Try to determine if the num_teams and/or thread_limit expressions\n+   can have their values determined already before entering the\n+   target construct.\n+   INTEGER_CSTs trivially are,\n+   integral decls that are firstprivate (explicitly or implicitly)\n+   or explicitly map(always, to:) or map(always, tofrom:) on the target\n+   region too, and expressions involving simple arithmetics on those\n+   too, function calls are not ok, dereferencing something neither etc.\n+   Add NUM_TEAMS and THREAD_LIMIT clauses to the OMP_CLAUSES of\n+   EXPR based on what we find:\n+   0 stands for clause not specified at all, use implementation default\n+   -1 stands for value that can't be determined easily before entering\n+      the target construct.\n+   If teams construct is not present at all, use 1 for num_teams\n+   and 0 for thread_limit (only one team is involved, and the thread\n+   limit is implementation defined.  */\n+\n+static void\n+optimize_target_teams (tree target, gimple_seq *pre_p)\n+{\n+  tree body = OMP_BODY (target);\n+  tree teams = walk_tree (&body, find_omp_teams, NULL, NULL);\n+  tree num_teams = integer_zero_node;\n+  tree thread_limit = integer_zero_node;\n+  location_t num_teams_loc = EXPR_LOCATION (target);\n+  location_t thread_limit_loc = EXPR_LOCATION (target);\n+  tree c, *p, expr;\n+  struct gimplify_omp_ctx *target_ctx = gimplify_omp_ctxp;\n+\n+  if (teams == NULL_TREE)\n+    num_teams = integer_one_node;\n+  else\n+    for (c = OMP_TEAMS_CLAUSES (teams); c; c = OMP_CLAUSE_CHAIN (c))\n+      {\n+\tif (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_NUM_TEAMS)\n+\t  {\n+\t    p = &num_teams;\n+\t    num_teams_loc = OMP_CLAUSE_LOCATION (c);\n+\t  }\n+\telse if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_THREAD_LIMIT)\n+\t  {\n+\t    p = &thread_limit;\n+\t    thread_limit_loc = OMP_CLAUSE_LOCATION (c);\n+\t  }\n+\telse\n+\t  continue;\n+\texpr = OMP_CLAUSE_OPERAND (c, 0);\n+\tif (TREE_CODE (expr) == INTEGER_CST)\n+\t  {\n+\t    *p = expr;\n+\t    continue;\n+\t  }\n+\tif (walk_tree (&expr, computable_teams_clause, NULL, NULL))\n+\t  {\n+\t    *p = integer_minus_one_node;\n+\t    continue;\n+\t  }\n+\t*p = expr;\n+\tgimplify_omp_ctxp = gimplify_omp_ctxp->outer_context;\n+\tif (gimplify_expr (p, pre_p, NULL, is_gimple_val, fb_rvalue)\n+\t    == GS_ERROR)\n+\t  {\n+\t    gimplify_omp_ctxp = target_ctx;\n+\t    *p = integer_minus_one_node;\n+\t    continue;\n+\t  }\n+\tgimplify_omp_ctxp = target_ctx;\n+\tif (!DECL_P (expr) && TREE_CODE (expr) != TARGET_EXPR)\n+\t  OMP_CLAUSE_OPERAND (c, 0) = *p;\n+      }\n+  c = build_omp_clause (thread_limit_loc, OMP_CLAUSE_THREAD_LIMIT);\n+  OMP_CLAUSE_THREAD_LIMIT_EXPR (c) = thread_limit;\n+  OMP_CLAUSE_CHAIN (c) = OMP_TARGET_CLAUSES (target);\n+  OMP_TARGET_CLAUSES (target) = c;\n+  c = build_omp_clause (num_teams_loc, OMP_CLAUSE_NUM_TEAMS);\n+  OMP_CLAUSE_NUM_TEAMS_EXPR (c) = num_teams;\n+  OMP_CLAUSE_CHAIN (c) = OMP_TARGET_CLAUSES (target);\n+  OMP_TARGET_CLAUSES (target) = c;\n+}\n+\n /* Gimplify the gross structure of several OMP constructs.  */\n \n static void\n@@ -8434,6 +8898,8 @@ gimplify_omp_workshare (tree *expr_p, gimple_seq *pre_p)\n     }\n   gimplify_scan_omp_clauses (&OMP_CLAUSES (expr), pre_p, ort,\n \t\t\t     TREE_CODE (expr));\n+  if (TREE_CODE (expr) == OMP_TARGET)\n+    optimize_target_teams (expr, pre_p);\n   if ((ort & (ORT_TARGET | ORT_TARGET_DATA)) != 0)\n     {\n       push_gimplify_context ();"}, {"sha": "fc87a3f584e2d0e627522aa3810382cb0336eb1d", "filename": "gcc/omp-builtins.def", "status": "modified", "additions": 48, "deletions": 8, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Fomp-builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Fomp-builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-builtins.def?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -113,6 +113,14 @@ DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_RUNTIME_START,\n \t\t  \"GOMP_loop_runtime_start\",\n \t\t  BT_FN_BOOL_LONG_LONG_LONG_LONGPTR_LONGPTR,\n \t\t  ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_NONMONOTONIC_DYNAMIC_START,\n+\t\t  \"GOMP_loop_nonmonotonic_dynamic_start\",\n+\t\t  BT_FN_BOOL_LONG_LONG_LONG_LONG_LONGPTR_LONGPTR,\n+\t\t  ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_NONMONOTONIC_GUIDED_START,\n+\t\t  \"GOMP_loop_nonmonotonic_guided_start\",\n+\t\t  BT_FN_BOOL_LONG_LONG_LONG_LONG_LONGPTR_LONGPTR,\n+\t\t  ATTR_NOTHROW_LEAF_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ORDERED_STATIC_START,\n \t\t  \"GOMP_loop_ordered_static_start\",\n \t\t  BT_FN_BOOL_LONG_LONG_LONG_LONG_LONGPTR_LONGPTR,\n@@ -153,6 +161,12 @@ DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_GUIDED_NEXT, \"GOMP_loop_guided_next\",\n \t\t  BT_FN_BOOL_LONGPTR_LONGPTR, ATTR_NOTHROW_LEAF_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_RUNTIME_NEXT, \"GOMP_loop_runtime_next\",\n \t\t  BT_FN_BOOL_LONGPTR_LONGPTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_NONMONOTONIC_DYNAMIC_NEXT,\n+\t\t  \"GOMP_loop_nonmonotonic_dynamic_next\",\n+\t\t  BT_FN_BOOL_LONGPTR_LONGPTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_NONMONOTONIC_GUIDED_NEXT,\n+\t\t  \"GOMP_loop_nonmonotonic_guided_next\",\n+\t\t  BT_FN_BOOL_LONGPTR_LONGPTR, ATTR_NOTHROW_LEAF_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ORDERED_STATIC_NEXT,\n \t\t  \"GOMP_loop_ordered_static_next\",\n \t\t  BT_FN_BOOL_LONGPTR_LONGPTR, ATTR_NOTHROW_LEAF_LIST)\n@@ -181,6 +195,14 @@ DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_RUNTIME_START,\n \t\t  \"GOMP_loop_ull_runtime_start\",\n \t\t  BT_FN_BOOL_BOOL_ULL_ULL_ULL_ULLPTR_ULLPTR,\n \t\t  ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_NONMONOTONIC_DYNAMIC_START,\n+\t\t  \"GOMP_loop_ull_nonmonotonic_dynamic_start\",\n+\t\t  BT_FN_BOOL_BOOL_ULL_ULL_ULL_ULL_ULLPTR_ULLPTR,\n+\t\t  ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_NONMONOTONIC_GUIDED_START,\n+\t\t  \"GOMP_loop_ull_nonmonotonic_guided_start\",\n+\t\t  BT_FN_BOOL_BOOL_ULL_ULL_ULL_ULL_ULLPTR_ULLPTR,\n+\t\t  ATTR_NOTHROW_LEAF_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_ORDERED_STATIC_START,\n \t\t  \"GOMP_loop_ull_ordered_static_start\",\n \t\t  BT_FN_BOOL_BOOL_ULL_ULL_ULL_ULL_ULLPTR_ULLPTR,\n@@ -213,13 +235,23 @@ DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_DOACROSS_RUNTIME_START,\n \t\t  \"GOMP_loop_ull_doacross_runtime_start\",\n \t\t  BT_FN_BOOL_UINT_ULLPTR_ULLPTR_ULLPTR,\n \t\t  ATTR_NOTHROW_LEAF_LIST)\n-DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_STATIC_NEXT, \"GOMP_loop_ull_static_next\",\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_STATIC_NEXT,\n+\t\t  \"GOMP_loop_ull_static_next\",\n+\t\t  BT_FN_BOOL_ULONGLONGPTR_ULONGLONGPTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_DYNAMIC_NEXT,\n+\t\t  \"GOMP_loop_ull_dynamic_next\",\n+\t\t  BT_FN_BOOL_ULONGLONGPTR_ULONGLONGPTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_GUIDED_NEXT,\n+\t\t  \"GOMP_loop_ull_guided_next\",\n \t\t  BT_FN_BOOL_ULONGLONGPTR_ULONGLONGPTR, ATTR_NOTHROW_LEAF_LIST)\n-DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_DYNAMIC_NEXT, \"GOMP_loop_ull_dynamic_next\",\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_RUNTIME_NEXT,\n+\t\t  \"GOMP_loop_ull_runtime_next\",\n \t\t  BT_FN_BOOL_ULONGLONGPTR_ULONGLONGPTR, ATTR_NOTHROW_LEAF_LIST)\n-DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_GUIDED_NEXT, \"GOMP_loop_ull_guided_next\",\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_NONMONOTONIC_DYNAMIC_NEXT,\n+\t\t  \"GOMP_loop_ull_nonmonotonic_dynamic_next\",\n \t\t  BT_FN_BOOL_ULONGLONGPTR_ULONGLONGPTR, ATTR_NOTHROW_LEAF_LIST)\n-DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_RUNTIME_NEXT, \"GOMP_loop_ull_runtime_next\",\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_NONMONOTONIC_GUIDED_NEXT,\n+\t\t  \"GOMP_loop_ull_nonmonotonic_guided_next\",\n \t\t  BT_FN_BOOL_ULONGLONGPTR_ULONGLONGPTR, ATTR_NOTHROW_LEAF_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_ORDERED_STATIC_NEXT,\n \t\t  \"GOMP_loop_ull_ordered_static_next\",\n@@ -252,6 +284,14 @@ DEF_GOMP_BUILTIN (BUILT_IN_GOMP_PARALLEL_LOOP_RUNTIME,\n \t\t  \"GOMP_parallel_loop_runtime\",\n \t\t  BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_UINT,\n \t\t  ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_PARALLEL_LOOP_NONMONOTONIC_DYNAMIC,\n+\t\t  \"GOMP_parallel_loop_nonmonotonic_dynamic\",\n+\t\t  BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_LONG_UINT,\n+\t\t  ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_PARALLEL_LOOP_NONMONOTONIC_GUIDED,\n+\t\t  \"GOMP_parallel_loop_nonmonotonic_guided\",\n+\t\t  BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_LONG_UINT,\n+\t\t  ATTR_NOTHROW_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_END, \"GOMP_loop_end\",\n \t\t  BT_FN_VOID, ATTR_NOTHROW_LEAF_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_END_CANCEL, \"GOMP_loop_end_cancel\",\n@@ -302,14 +342,14 @@ DEF_GOMP_BUILTIN (BUILT_IN_GOMP_SINGLE_COPY_START, \"GOMP_single_copy_start\",\n \t\t  BT_FN_PTR, ATTR_NOTHROW_LEAF_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_SINGLE_COPY_END, \"GOMP_single_copy_end\",\n \t\t  BT_FN_VOID_PTR, ATTR_NOTHROW_LEAF_LIST)\n-DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TARGET, \"GOMP_target_41\",\n-\t\t  BT_FN_VOID_INT_OMPFN_SIZE_PTR_PTR_PTR_UINT_PTR,\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TARGET, \"GOMP_target_ext\",\n+\t\t  BT_FN_VOID_INT_OMPFN_SIZE_PTR_PTR_PTR_UINT_PTR_INT_INT,\n \t\t  ATTR_NOTHROW_LIST)\n-DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TARGET_DATA, \"GOMP_target_data_41\",\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TARGET_DATA, \"GOMP_target_data_ext\",\n \t\t  BT_FN_VOID_INT_SIZE_PTR_PTR_PTR, ATTR_NOTHROW_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TARGET_END_DATA, \"GOMP_target_end_data\",\n \t\t  BT_FN_VOID, ATTR_NOTHROW_LIST)\n-DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TARGET_UPDATE, \"GOMP_target_update_41\",\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TARGET_UPDATE, \"GOMP_target_update_ext\",\n \t\t  BT_FN_VOID_INT_SIZE_PTR_PTR_PTR_UINT_PTR,\n \t\t  ATTR_NOTHROW_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TARGET_ENTER_EXIT_DATA,"}, {"sha": "86cc65500af91c451ba37178b852f4c9f29d899a", "filename": "gcc/omp-low.c", "status": "modified", "additions": 417, "deletions": 79, "changes": 496, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -127,6 +127,9 @@ struct omp_region\n   /* Schedule kind, only used for GIMPLE_OMP_FOR type regions.  */\n   enum omp_clause_schedule_kind sched_kind;\n \n+  /* Schedule modifiers.  */\n+  unsigned char sched_modifiers;\n+\n   /* True if this is a combined parallel+workshare region.  */\n   bool is_combined_parallel;\n \n@@ -209,6 +212,7 @@ struct omp_for_data\n   int collapse;\n   int ordered;\n   bool have_nowait, have_ordered, simd_schedule;\n+  unsigned char sched_modifiers;\n   enum omp_clause_schedule_kind sched_kind;\n   struct omp_for_data_loop *loops;\n };\n@@ -263,6 +267,7 @@ static int target_nesting_level;\n static struct omp_region *root_omp_region;\n static bitmap task_shared_vars;\n static vec<omp_context *> taskreg_contexts;\n+static bool omp_any_child_fn_dumped;\n \n static void scan_omp (gimple_seq *, omp_context *);\n static tree scan_omp_1_op (tree *, int *, void *);\n@@ -478,6 +483,7 @@ extract_omp_for_data (gomp_for *for_stmt, struct omp_for_data *fd,\n   fd->collapse = 1;\n   fd->ordered = 0;\n   fd->sched_kind = OMP_CLAUSE_SCHEDULE_STATIC;\n+  fd->sched_modifiers = 0;\n   fd->chunk_size = NULL_TREE;\n   fd->simd_schedule = false;\n   if (gimple_omp_for_kind (fd->for_stmt) == GF_OMP_FOR_KIND_CILKFOR)\n@@ -498,7 +504,11 @@ extract_omp_for_data (gomp_for *for_stmt, struct omp_for_data *fd,\n \tbreak;\n       case OMP_CLAUSE_SCHEDULE:\n \tgcc_assert (!distribute && !taskloop);\n-\tfd->sched_kind = OMP_CLAUSE_SCHEDULE_KIND (t);\n+\tfd->sched_kind\n+\t  = (enum omp_clause_schedule_kind)\n+\t    (OMP_CLAUSE_SCHEDULE_KIND (t) & OMP_CLAUSE_SCHEDULE_MASK);\n+\tfd->sched_modifiers = (OMP_CLAUSE_SCHEDULE_KIND (t)\n+\t\t\t       & ~OMP_CLAUSE_SCHEDULE_MASK);\n \tfd->chunk_size = OMP_CLAUSE_SCHEDULE_CHUNK_EXPR (t);\n \tfd->simd_schedule = OMP_CLAUSE_SCHEDULE_SIMD (t);\n \tbreak;\n@@ -987,7 +997,8 @@ determine_parallel_type (struct omp_region *region)\n \t  tree clauses = gimple_omp_for_clauses (ws_stmt);\n \t  tree c = find_omp_clause (clauses, OMP_CLAUSE_SCHEDULE);\n \t  if (c == NULL\n-\t      || OMP_CLAUSE_SCHEDULE_KIND (c) == OMP_CLAUSE_SCHEDULE_STATIC\n+\t      || ((OMP_CLAUSE_SCHEDULE_KIND (c) & OMP_CLAUSE_SCHEDULE_MASK)\n+\t\t  == OMP_CLAUSE_SCHEDULE_STATIC)\n \t      || find_omp_clause (clauses, OMP_CLAUSE_ORDERED))\n \t    {\n \t      region->is_combined_parallel = false;\n@@ -1860,6 +1871,8 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \t      && TREE_CODE (decl) == MEM_REF)\n \t    {\n \t      tree t = TREE_OPERAND (decl, 0);\n+\t      if (TREE_CODE (t) == POINTER_PLUS_EXPR)\n+\t\tt = TREE_OPERAND (t, 0);\n \t      if (TREE_CODE (t) == INDIRECT_REF\n \t\t  || TREE_CODE (t) == ADDR_EXPR)\n \t\tt = TREE_OPERAND (t, 0);\n@@ -1999,7 +2012,9 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \t     directly.  */\n \t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n \t      && DECL_P (decl)\n-\t      && (OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_FIRSTPRIVATE_POINTER\n+\t      && ((OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_FIRSTPRIVATE_POINTER\n+\t\t   && (OMP_CLAUSE_MAP_KIND (c)\n+\t\t       != GOMP_MAP_FIRSTPRIVATE_REFERENCE))\n \t\t  || TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n \t      && is_global_var (maybe_lookup_decl_in_outer_ctx (decl, ctx))\n \t      && varpool_node::get_create (decl)->offloadable)\n@@ -2015,7 +2030,9 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \t\tbreak;\n \t    }\n \t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n-\t      && OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_FIRSTPRIVATE_POINTER)\n+\t      && (OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_FIRSTPRIVATE_POINTER\n+\t\t  || (OMP_CLAUSE_MAP_KIND (c)\n+\t\t      == GOMP_MAP_FIRSTPRIVATE_REFERENCE)))\n \t    {\n \t      if (TREE_CODE (decl) == COMPONENT_REF\n \t\t  || (TREE_CODE (decl) == INDIRECT_REF\n@@ -2044,11 +2061,7 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \t\t  gcc_assert (TREE_CODE (decl2) == INDIRECT_REF);\n \t\t  decl2 = TREE_OPERAND (decl2, 0);\n \t\t  gcc_assert (DECL_P (decl2));\n-\t\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n-\t\t      && OMP_CLAUSE_MAP_PRIVATE (c))\n-\t\t    install_var_field (decl2, true, 11, ctx);\n-\t\t  else\n-\t\t    install_var_field (decl2, true, 3, ctx);\n+\t\t  install_var_field (decl2, true, 3, ctx);\n \t\t  install_var_local (decl2, ctx);\n \t\t  install_var_local (decl, ctx);\n \t\t}\n@@ -2059,9 +2072,6 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \t\t      && !OMP_CLAUSE_MAP_ZERO_BIAS_ARRAY_SECTION (c)\n \t\t      && TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n \t\t    install_var_field (decl, true, 7, ctx);\n-\t\t  else if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n-\t\t\t   && OMP_CLAUSE_MAP_PRIVATE (c))\n-\t\t    install_var_field (decl, true, 11, ctx);\n \t\t  else\n \t\t    install_var_field (decl, true, 3, ctx);\n \t\t  if (is_gimple_omp_offloaded (ctx->stmt))\n@@ -2225,7 +2235,9 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \t    break;\n \t  decl = OMP_CLAUSE_DECL (c);\n \t  if (DECL_P (decl)\n-\t      && (OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_FIRSTPRIVATE_POINTER\n+\t      && ((OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_FIRSTPRIVATE_POINTER\n+\t\t   && (OMP_CLAUSE_MAP_KIND (c)\n+\t\t       != GOMP_MAP_FIRSTPRIVATE_REFERENCE))\n \t\t  || TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n \t      && is_global_var (maybe_lookup_decl_in_outer_ctx (decl, ctx))\n \t      && varpool_node::get_create (decl)->offloadable)\n@@ -2562,12 +2574,15 @@ add_taskreg_looptemp_clauses (enum gf_mask msk, gimple *stmt,\n \t  && TREE_CODE (fd.loop.n2) != INTEGER_CST)\n \t{\n \t  count += fd.collapse - 1;\n-\t  /* For taskloop, if there are lastprivate clauses on the inner\n+\t  /* If there are lastprivate clauses on the inner\n \t     GIMPLE_OMP_FOR, add one more temporaries for the total number\n \t     of iterations (product of count1 ... countN-1).  */\n-\t  if (msk == GF_OMP_FOR_KIND_TASKLOOP\n-\t      && find_omp_clause (gimple_omp_for_clauses (for_stmt),\n-\t\t\t\t  OMP_CLAUSE_LASTPRIVATE))\n+\t  if (find_omp_clause (gimple_omp_for_clauses (for_stmt),\n+\t\t\t       OMP_CLAUSE_LASTPRIVATE))\n+\t    count++;\n+\t  else if (msk == GF_OMP_FOR_KIND_FOR\n+\t\t   && find_omp_clause (gimple_omp_parallel_clauses (stmt),\n+\t\t\t\t       OMP_CLAUSE_LASTPRIVATE))\n \t    count++;\n \t}\n       for (i = 0; i < count; i++)\n@@ -4254,6 +4269,8 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t  if (c_kind == OMP_CLAUSE_REDUCTION && TREE_CODE (var) == MEM_REF)\n \t    {\n \t      var = TREE_OPERAND (var, 0);\n+\t      if (TREE_CODE (var) == POINTER_PLUS_EXPR)\n+\t\tvar = TREE_OPERAND (var, 0);\n \t      if (TREE_CODE (var) == INDIRECT_REF\n \t\t  || TREE_CODE (var) == ADDR_EXPR)\n \t\tvar = TREE_OPERAND (var, 0);\n@@ -4282,7 +4299,28 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t      if (pass == 0)\n \t\tcontinue;\n \n+\t      tree bias = TREE_OPERAND (OMP_CLAUSE_DECL (c), 1);\n \t      tree orig_var = TREE_OPERAND (OMP_CLAUSE_DECL (c), 0);\n+\t      if (TREE_CODE (orig_var) == POINTER_PLUS_EXPR)\n+\t\t{\n+\t\t  tree b = TREE_OPERAND (orig_var, 1);\n+\t\t  b = maybe_lookup_decl (b, ctx);\n+\t\t  if (b == NULL)\n+\t\t    {\n+\t\t      b = TREE_OPERAND (orig_var, 1);\n+\t\t      b = maybe_lookup_decl_in_outer_ctx (b, ctx);\n+\t\t    }\n+\t\t  if (integer_zerop (bias))\n+\t\t    bias = b;\n+\t\t  else\n+\t\t    {\n+\t\t      bias = fold_convert_loc (clause_loc,\n+\t\t\t\t\t       TREE_TYPE (b), bias);\n+\t\t      bias = fold_build2_loc (clause_loc, PLUS_EXPR,\n+\t\t\t\t\t      TREE_TYPE (b), b, bias);\n+\t\t    }\n+\t\t  orig_var = TREE_OPERAND (orig_var, 0);\n+\t\t}\n \t      if (TREE_CODE (orig_var) == INDIRECT_REF\n \t\t  || TREE_CODE (orig_var) == ADDR_EXPR)\n \t\torig_var = TREE_OPERAND (orig_var, 0);\n@@ -4323,7 +4361,24 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t      tree y = create_tmp_var (ptype, name);\n \t      gimplify_assign (y, x, ilist);\n \t      x = y;\n-\t      if (TREE_CODE (TREE_OPERAND (d, 0)) == ADDR_EXPR)\n+\t      tree yb = y;\n+\n+\t      if (!integer_zerop (bias))\n+\t\t{\n+\t\t  bias = fold_convert_loc (clause_loc, sizetype, bias);\n+\t\t  bias = fold_build1_loc (clause_loc, NEGATE_EXPR,\n+\t\t\t\t\t  sizetype, bias);\n+\t\t  x = fold_build2_loc (clause_loc, POINTER_PLUS_EXPR,\n+\t\t\t\t       TREE_TYPE (x), x, bias);\n+\t\t  yb = create_tmp_var (ptype, name);\n+\t\t  gimplify_assign (yb, x, ilist);\n+\t\t  x = yb;\n+\t\t}\n+\n+\t      d = TREE_OPERAND (d, 0);\n+\t      if (TREE_CODE (d) == POINTER_PLUS_EXPR)\n+\t\td = TREE_OPERAND (d, 0);\n+\t      if (TREE_CODE (d) == ADDR_EXPR)\n \t\t{\n \t\t  if (orig_var != var)\n \t\t    {\n@@ -4349,11 +4404,11 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t      else\n \t\t{\n \t\t  gcc_assert (orig_var == var);\n-\t\t  if (TREE_CODE (TREE_OPERAND (d, 0)) == INDIRECT_REF)\n+\t\t  if (TREE_CODE (d) == INDIRECT_REF)\n \t\t    {\n \t\t      x = create_tmp_var (ptype, name);\n \t\t      TREE_ADDRESSABLE (x) = 1;\n-\t\t      gimplify_assign (x, y, ilist);\n+\t\t      gimplify_assign (x, yb, ilist);\n \t\t      x = build_fold_addr_expr_loc (clause_loc, x);\n \t\t    }\n \t\t  x = fold_convert_loc (clause_loc, TREE_TYPE (new_var), x);\n@@ -4370,9 +4425,9 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t  gimplify_assign (y2, y, ilist);\n \t\t  tree ref = build_outer_var_ref (var, ctx);\n \t\t  /* For ref build_outer_var_ref already performs this.  */\n-\t\t  if (TREE_CODE (TREE_OPERAND (d, 0)) == INDIRECT_REF)\n+\t\t  if (TREE_CODE (d) == INDIRECT_REF)\n \t\t    gcc_assert (is_reference (var));\n-\t\t  else if (TREE_CODE (TREE_OPERAND (d, 0)) == ADDR_EXPR)\n+\t\t  else if (TREE_CODE (d) == ADDR_EXPR)\n \t\t    ref = build_fold_addr_expr (ref);\n \t\t  else if (is_reference (var))\n \t\t    ref = build_fold_addr_expr (ref);\n@@ -5467,6 +5522,8 @@ lower_reduction_clauses (tree clauses, gimple_seq *stmt_seqp, omp_context *ctx)\n       if (TREE_CODE (var) == MEM_REF)\n \t{\n \t  var = TREE_OPERAND (var, 0);\n+\t  if (TREE_CODE (var) == POINTER_PLUS_EXPR)\n+\t    var = TREE_OPERAND (var, 0);\n \t  if (TREE_CODE (var) == INDIRECT_REF\n \t      || TREE_CODE (var) == ADDR_EXPR)\n \t    var = TREE_OPERAND (var, 0);\n@@ -5509,14 +5566,35 @@ lower_reduction_clauses (tree clauses, gimple_seq *stmt_seqp, omp_context *ctx)\n \t  tree v = TYPE_MAX_VALUE (TYPE_DOMAIN (type));\n \t  tree i = create_tmp_var (TREE_TYPE (v), NULL);\n \t  tree ptype = build_pointer_type (TREE_TYPE (type));\n+\t  tree bias = TREE_OPERAND (d, 1);\n+\t  d = TREE_OPERAND (d, 0);\n+\t  if (TREE_CODE (d) == POINTER_PLUS_EXPR)\n+\t    {\n+\t      tree b = TREE_OPERAND (d, 1);\n+\t      b = maybe_lookup_decl (b, ctx);\n+\t      if (b == NULL)\n+\t\t{\n+\t\t  b = TREE_OPERAND (d, 1);\n+\t\t  b = maybe_lookup_decl_in_outer_ctx (b, ctx);\n+\t\t}\n+\t      if (integer_zerop (bias))\n+\t\tbias = b;\n+\t      else\n+\t\t{\n+\t\t  bias = fold_convert_loc (clause_loc, TREE_TYPE (b), bias);\n+\t\t  bias = fold_build2_loc (clause_loc, PLUS_EXPR,\n+\t\t\t\t\t  TREE_TYPE (b), b, bias);\n+\t\t}\n+\t      d = TREE_OPERAND (d, 0);\n+\t    }\n \t  /* For ref build_outer_var_ref already performs this, so\n \t     only new_var needs a dereference.  */\n-\t  if (TREE_CODE (TREE_OPERAND (d, 0)) == INDIRECT_REF)\n+\t  if (TREE_CODE (d) == INDIRECT_REF)\n \t    {\n \t      new_var = build_simple_mem_ref_loc (clause_loc, new_var);\n \t      gcc_assert (is_reference (var) && var == orig_var);\n \t    }\n-\t  else if (TREE_CODE (TREE_OPERAND (d, 0)) == ADDR_EXPR)\n+\t  else if (TREE_CODE (d) == ADDR_EXPR)\n \t    {\n \t      if (orig_var == var)\n \t\t{\n@@ -5539,6 +5617,15 @@ lower_reduction_clauses (tree clauses, gimple_seq *stmt_seqp, omp_context *ctx)\n \t\tv = maybe_lookup_decl_in_outer_ctx (v, ctx);\n \t      gimplify_expr (&v, stmt_seqp, NULL, is_gimple_val, fb_rvalue);\n \t    }\n+\t  if (!integer_zerop (bias))\n+\t    {\n+\t      bias = fold_convert_loc (clause_loc, sizetype, bias);\n+\t      new_var = fold_build2_loc (clause_loc, POINTER_PLUS_EXPR,\n+\t\t\t\t\t TREE_TYPE (new_var), new_var,\n+\t\t\t\t\t unshare_expr (bias));\n+\t      ref = fold_build2_loc (clause_loc, POINTER_PLUS_EXPR,\n+\t\t\t\t\t TREE_TYPE (ref), ref, bias);\n+\t    }\n \t  new_var = fold_convert_loc (clause_loc, ptype, new_var);\n \t  ref = fold_convert_loc (clause_loc, ptype, ref);\n \t  tree m = create_tmp_var (ptype, NULL);\n@@ -5731,6 +5818,8 @@ lower_send_clauses (tree clauses, gimple_seq *ilist, gimple_seq *olist,\n \t  && TREE_CODE (val) == MEM_REF)\n \t{\n \t  val = TREE_OPERAND (val, 0);\n+\t  if (TREE_CODE (val) == POINTER_PLUS_EXPR)\n+\t    val = TREE_OPERAND (val, 0);\n \t  if (TREE_CODE (val) == INDIRECT_REF\n \t      || TREE_CODE (val) == ADDR_EXPR)\n \t    val = TREE_OPERAND (val, 0);\n@@ -6120,11 +6209,26 @@ expand_parallel_call (struct omp_region *region, basic_block bb,\n \t{\n \tcase GIMPLE_OMP_FOR:\n \t  gcc_assert (region->inner->sched_kind != OMP_CLAUSE_SCHEDULE_AUTO);\n-\t  start_ix2 = ((int)BUILT_IN_GOMP_PARALLEL_LOOP_STATIC\n-\t\t       + (region->inner->sched_kind\n-\t\t\t  == OMP_CLAUSE_SCHEDULE_RUNTIME\n-\t\t\t  ? 3 : region->inner->sched_kind));\n-\t  start_ix = (enum built_in_function)start_ix2;\n+\t  switch (region->inner->sched_kind)\n+\t    {\n+\t    case OMP_CLAUSE_SCHEDULE_RUNTIME:\n+\t      start_ix2 = 3;\n+\t      break;\n+\t    case OMP_CLAUSE_SCHEDULE_DYNAMIC:\n+\t    case OMP_CLAUSE_SCHEDULE_GUIDED:\n+\t      if (region->inner->sched_modifiers\n+\t\t  & OMP_CLAUSE_SCHEDULE_NONMONOTONIC)\n+\t\t{\n+\t\t  start_ix2 = 3 + region->inner->sched_kind;\n+\t\t  break;\n+\t\t}\n+\t      /* FALLTHRU */\n+\t    default:\n+\t      start_ix2 = region->inner->sched_kind;\n+\t      break;\n+\t    }\n+\t  start_ix2 += (int) BUILT_IN_GOMP_PARALLEL_LOOP_STATIC;\n+\t  start_ix = (enum built_in_function) start_ix2;\n \t  break;\n \tcase GIMPLE_OMP_SECTIONS:\n \t  start_ix = BUILT_IN_GOMP_PARALLEL_SECTIONS;\n@@ -6941,9 +7045,15 @@ expand_omp_taskreg (struct omp_region *region)\n       node->parallelized_function = 1;\n       cgraph_node::add_new_function (child_fn, true);\n \n+      bool need_asm = DECL_ASSEMBLER_NAME_SET_P (current_function_decl)\n+\t\t      && !DECL_ASSEMBLER_NAME_SET_P (child_fn);\n+\n       /* Fix the callgraph edges for child_cfun.  Those for cfun will be\n \t fixed in a following pass.  */\n       push_cfun (child_cfun);\n+      if (need_asm)\n+\tassign_assembler_name_if_neeeded (child_fn);\n+\n       if (optimize)\n \toptimize_omp_library_calls (entry_stmt);\n       cgraph_edge::rebuild_edges ();\n@@ -6967,6 +7077,13 @@ expand_omp_taskreg (struct omp_region *region)\n       if (flag_checking && !loops_state_satisfies_p (LOOPS_NEED_FIXUP))\n \tverify_loop_structure ();\n       pop_cfun ();\n+\n+      if (dump_file && !gimple_in_ssa_p (cfun))\n+\t{\n+\t  omp_any_child_fn_dumped = true;\n+\t  dump_function_header (dump_file, child_fn, dump_flags);\n+\t  dump_function_to_file (child_fn, dump_file, dump_flags);\n+\t}\n     }\n \n   /* Emit a library call to launch the children threads.  */\n@@ -8968,6 +9085,30 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n \t\t\t\tOMP_CLAUSE__LOOPTEMP_);\n       gcc_assert (innerc);\n       endvar = OMP_CLAUSE_DECL (innerc);\n+      if (fd->collapse > 1 && TREE_CODE (fd->loop.n2) != INTEGER_CST\n+\t  && gimple_omp_for_kind (fd->for_stmt) == GF_OMP_FOR_KIND_DISTRIBUTE)\n+\t{\n+\t  int i;\n+\t  for (i = 1; i < fd->collapse; i++)\n+\t    {\n+\t      innerc = find_omp_clause (OMP_CLAUSE_CHAIN (innerc),\n+\t\t\t\t\tOMP_CLAUSE__LOOPTEMP_);\n+\t      gcc_assert (innerc);\n+\t    }\n+\t  innerc = find_omp_clause (OMP_CLAUSE_CHAIN (innerc),\n+\t\t\t\t    OMP_CLAUSE__LOOPTEMP_);\n+\t  if (innerc)\n+\t    {\n+\t      /* If needed (distribute parallel for with lastprivate),\n+\t\t propagate down the total number of iterations.  */\n+\t      tree t = fold_convert (TREE_TYPE (OMP_CLAUSE_DECL (innerc)),\n+\t\t\t\t     fd->loop.n2);\n+\t      t = force_gimple_operand_gsi (&gsi, t, false, NULL_TREE, false,\n+\t\t\t\t\t    GSI_CONTINUE_LINKING);\n+\t      assign_stmt = gimple_build_assign (OMP_CLAUSE_DECL (innerc), t);\n+\t      gsi_insert_after (&gsi, assign_stmt, GSI_CONTINUE_LINKING);\n+\t    }\n+\t}\n     }\n   t = fold_convert (itype, s0);\n   t = fold_build2 (MULT_EXPR, itype, t, step);\n@@ -9442,6 +9583,30 @@ expand_omp_for_static_chunk (struct omp_region *region,\n \t\t\t\tOMP_CLAUSE__LOOPTEMP_);\n       gcc_assert (innerc);\n       endvar = OMP_CLAUSE_DECL (innerc);\n+      if (fd->collapse > 1 && TREE_CODE (fd->loop.n2) != INTEGER_CST\n+\t  && gimple_omp_for_kind (fd->for_stmt) == GF_OMP_FOR_KIND_DISTRIBUTE)\n+\t{\n+\t  int i;\n+\t  for (i = 1; i < fd->collapse; i++)\n+\t    {\n+\t      innerc = find_omp_clause (OMP_CLAUSE_CHAIN (innerc),\n+\t\t\t\t\tOMP_CLAUSE__LOOPTEMP_);\n+\t      gcc_assert (innerc);\n+\t    }\n+\t  innerc = find_omp_clause (OMP_CLAUSE_CHAIN (innerc),\n+\t\t\t\t    OMP_CLAUSE__LOOPTEMP_);\n+\t  if (innerc)\n+\t    {\n+\t      /* If needed (distribute parallel for with lastprivate),\n+\t\t propagate down the total number of iterations.  */\n+\t      tree t = fold_convert (TREE_TYPE (OMP_CLAUSE_DECL (innerc)),\n+\t\t\t\t     fd->loop.n2);\n+\t      t = force_gimple_operand_gsi (&gsi, t, false, NULL_TREE, false,\n+\t\t\t\t\t    GSI_CONTINUE_LINKING);\n+\t      assign_stmt = gimple_build_assign (OMP_CLAUSE_DECL (innerc), t);\n+\t      gsi_insert_after (&gsi, assign_stmt, GSI_CONTINUE_LINKING);\n+\t    }\n+\t}\n     }\n \n   t = fold_convert (itype, s0);\n@@ -11051,6 +11216,7 @@ expand_omp_for (struct omp_region *region, gimple *inner_stmt)\n   extract_omp_for_data (as_a <gomp_for *> (last_stmt (region->entry)),\n \t\t\t&fd, loops);\n   region->sched_kind = fd.sched_kind;\n+  region->sched_modifiers = fd.sched_modifiers;\n \n   gcc_assert (EDGE_COUNT (region->entry->succs) == 2);\n   BRANCH_EDGE (region->entry)->flags &= ~EDGE_ABNORMAL;\n@@ -11101,10 +11267,27 @@ expand_omp_for (struct omp_region *region, gimple *inner_stmt)\n \t  && fd.sched_kind == OMP_CLAUSE_SCHEDULE_STATIC)\n \tfd.chunk_size = integer_zero_node;\n       gcc_assert (fd.sched_kind != OMP_CLAUSE_SCHEDULE_AUTO);\n-      fn_index = (fd.sched_kind == OMP_CLAUSE_SCHEDULE_RUNTIME)\n-\t\t  ? 3 : fd.sched_kind;\n+      switch (fd.sched_kind)\n+\t{\n+\tcase OMP_CLAUSE_SCHEDULE_RUNTIME:\n+\t  fn_index = 3;\n+\t  break;\n+\tcase OMP_CLAUSE_SCHEDULE_DYNAMIC:\n+\tcase OMP_CLAUSE_SCHEDULE_GUIDED:\n+\t  if ((fd.sched_modifiers & OMP_CLAUSE_SCHEDULE_NONMONOTONIC)\n+\t      && !fd.ordered\n+\t      && !fd.have_ordered)\n+\t    {\n+\t      fn_index = 3 + fd.sched_kind;\n+\t      break;\n+\t    }\n+\t  /* FALLTHRU */\n+\tdefault:\n+\t  fn_index = fd.sched_kind;\n+\t  break;\n+\t}\n       if (!fd.ordered)\n-\tfn_index += fd.have_ordered * 4;\n+\tfn_index += fd.have_ordered * 6;\n       if (fd.ordered)\n \tstart_ix = ((int)BUILT_IN_GOMP_LOOP_DOACROSS_STATIC_START) + fn_index;\n       else\n@@ -12322,9 +12505,14 @@ expand_omp_target (struct omp_region *region)\n       vec_safe_push (offload_funcs, child_fn);\n #endif\n \n+      bool need_asm = DECL_ASSEMBLER_NAME_SET_P (current_function_decl)\n+\t\t      && !DECL_ASSEMBLER_NAME_SET_P (child_fn);\n+\n       /* Fix the callgraph edges for child_cfun.  Those for cfun will be\n \t fixed in a following pass.  */\n       push_cfun (child_cfun);\n+      if (need_asm)\n+\tassign_assembler_name_if_neeeded (child_fn);\n       cgraph_edge::rebuild_edges ();\n \n #ifdef ENABLE_OFFLOADING\n@@ -12350,6 +12538,13 @@ expand_omp_target (struct omp_region *region)\n       if (flag_checking && !loops_state_satisfies_p (LOOPS_NEED_FIXUP))\n \tverify_loop_structure ();\n       pop_cfun ();\n+\n+      if (dump_file && !gimple_in_ssa_p (cfun))\n+\t{\n+\t  omp_any_child_fn_dumped = true;\n+\t  dump_function_header (dump_file, child_fn, dump_flags);\n+\t  dump_function_to_file (child_fn, dump_file, dump_flags);\n+\t}\n     }\n \n   /* Emit a library call to launch the offloading region, or do data\n@@ -12524,6 +12719,31 @@ expand_omp_target (struct omp_region *region)\n       else\n \tdepend = build_int_cst (ptr_type_node, 0);\n       args.quick_push (depend);\n+      if (start_ix == BUILT_IN_GOMP_TARGET)\n+\t{\n+\t  c = find_omp_clause (clauses, OMP_CLAUSE_NUM_TEAMS);\n+\t  if (c)\n+\t    {\n+\t      t = fold_convert (integer_type_node,\n+\t\t\t\tOMP_CLAUSE_NUM_TEAMS_EXPR (c));\n+\t      t = force_gimple_operand_gsi (&gsi, t, true, NULL,\n+\t\t\t\t\t    true, GSI_SAME_STMT);\n+\t    }\n+\t  else\n+\t    t = integer_minus_one_node;\n+\t  args.quick_push (t);\n+\t  c = find_omp_clause (clauses, OMP_CLAUSE_THREAD_LIMIT);\n+\t  if (c)\n+\t    {\n+\t      t = fold_convert (integer_type_node,\n+\t\t\t\tOMP_CLAUSE_THREAD_LIMIT_EXPR (c));\n+\t      t = force_gimple_operand_gsi (&gsi, t, true, NULL,\n+\t\t\t\t\t    true, GSI_SAME_STMT);\n+\t    }\n+\t  else\n+\t    t = integer_minus_one_node;\n+\t  args.quick_push (t);\n+\t}\n       break;\n     case BUILT_IN_GOACC_PARALLEL:\n       {\n@@ -12637,6 +12857,7 @@ expand_omp_target (struct omp_region *region)\n static void\n expand_omp (struct omp_region *region)\n {\n+  omp_any_child_fn_dumped = false;\n   while (region)\n     {\n       location_t saved_location;\n@@ -12720,6 +12941,12 @@ expand_omp (struct omp_region *region)\n       input_location = saved_location;\n       region = region->next;\n     }\n+  if (omp_any_child_fn_dumped)\n+    {\n+      if (dump_file)\n+\tdump_function_header (dump_file, current_function_decl, dump_flags);\n+      omp_any_child_fn_dumped = false;\n+    }\n }\n \n \n@@ -13796,26 +14023,36 @@ lower_omp_for_lastprivate (struct omp_for_data *fd, gimple_seq *body_p,\n       && TREE_CODE (n2) != INTEGER_CST\n       && gimple_omp_for_combined_into_p (fd->for_stmt))\n     {\n-      struct omp_context *task_ctx = NULL;\n+      struct omp_context *taskreg_ctx = NULL;\n       if (gimple_code (ctx->outer->stmt) == GIMPLE_OMP_FOR)\n \t{\n \t  gomp_for *gfor = as_a <gomp_for *> (ctx->outer->stmt);\n-\t  if (gimple_omp_for_kind (gfor) == GF_OMP_FOR_KIND_FOR)\n+\t  if (gimple_omp_for_kind (gfor) == GF_OMP_FOR_KIND_FOR\n+\t      || gimple_omp_for_kind (gfor) == GF_OMP_FOR_KIND_DISTRIBUTE)\n \t    {\n-\t      struct omp_for_data outer_fd;\n-\t      extract_omp_for_data (gfor, &outer_fd, NULL);\n-\t      n2 = fold_convert (TREE_TYPE (n2), outer_fd.loop.n2);\n+\t      if (gimple_omp_for_combined_into_p (gfor))\n+\t\t{\n+\t\t  gcc_assert (ctx->outer->outer\n+\t\t\t      && is_parallel_ctx (ctx->outer->outer));\n+\t\t  taskreg_ctx = ctx->outer->outer;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  struct omp_for_data outer_fd;\n+\t\t  extract_omp_for_data (gfor, &outer_fd, NULL);\n+\t\t  n2 = fold_convert (TREE_TYPE (n2), outer_fd.loop.n2);\n+\t\t}\n \t    }\n \t  else if (gimple_omp_for_kind (gfor) == GF_OMP_FOR_KIND_TASKLOOP)\n-\t    task_ctx = ctx->outer->outer;\n+\t    taskreg_ctx = ctx->outer->outer;\n \t}\n-      else if (is_task_ctx (ctx->outer))\n-\ttask_ctx = ctx->outer;\n-      if (task_ctx)\n+      else if (is_taskreg_ctx (ctx->outer))\n+\ttaskreg_ctx = ctx->outer;\n+      if (taskreg_ctx)\n \t{\n \t  int i;\n \t  tree innerc\n-\t    = find_omp_clause (gimple_omp_task_clauses (task_ctx->stmt),\n+\t    = find_omp_clause (gimple_omp_taskreg_clauses (taskreg_ctx->stmt),\n \t\t\t       OMP_CLAUSE__LOOPTEMP_);\n \t  gcc_assert (innerc);\n \t  for (i = 0; i < fd->collapse; i++)\n@@ -13829,7 +14066,7 @@ lower_omp_for_lastprivate (struct omp_for_data *fd, gimple_seq *body_p,\n \t  if (innerc)\n \t    n2 = fold_convert (TREE_TYPE (n2),\n \t\t\t       lookup_decl (OMP_CLAUSE_DECL (innerc),\n-\t\t\t\t\t    task_ctx));\n+\t\t\t\t\t    taskreg_ctx));\n \t}\n     }\n   cond = build2 (cond_code, boolean_type_node, fd->loop.v, n2);\n@@ -14627,7 +14864,9 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t  case GOMP_MAP_ALWAYS_FROM:\n \t  case GOMP_MAP_ALWAYS_TOFROM:\n \t  case GOMP_MAP_FIRSTPRIVATE_POINTER:\n+\t  case GOMP_MAP_FIRSTPRIVATE_REFERENCE:\n \t  case GOMP_MAP_STRUCT:\n+\t  case GOMP_MAP_ALWAYS_POINTER:\n \t    break;\n \t  case GOMP_MAP_FORCE_ALLOC:\n \t  case GOMP_MAP_FORCE_TO:\n@@ -14666,7 +14905,8 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t  }\n \n \tif (offloaded\n-\t    && OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_FIRSTPRIVATE_POINTER)\n+\t    && (OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_FIRSTPRIVATE_POINTER\n+\t\t|| OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_FIRSTPRIVATE_REFERENCE))\n \t  {\n \t    if (TREE_CODE (TREE_TYPE (var)) == ARRAY_TYPE)\n \t      {\n@@ -14685,12 +14925,6 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t    continue;\n \t  }\n \n-\tif (offloaded && OMP_CLAUSE_MAP_PRIVATE (c))\n-\t  {\n-\t    map_cnt++;\n-\t    continue;\n-\t  }\n-\n \tif (!maybe_lookup_field (var, ctx))\n \t  continue;\n \n@@ -14843,7 +15077,9 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t    nc = c;\n \t    ovar = OMP_CLAUSE_DECL (c);\n \t    if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n-\t\t&& OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_FIRSTPRIVATE_POINTER)\n+\t\t&& (OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_FIRSTPRIVATE_POINTER\n+\t\t    || (OMP_CLAUSE_MAP_KIND (c)\n+\t\t\t== GOMP_MAP_FIRSTPRIVATE_REFERENCE)))\n \t      break;\n \t    if (!DECL_P (ovar))\n \t      {\n@@ -14875,14 +15111,7 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\t    gcc_assert (DECL_P (ovar2));\n \t\t    ovar = ovar2;\n \t\t  }\n-\t\tif (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n-\t\t    && OMP_CLAUSE_MAP_PRIVATE (c))\n-\t\t  {\n-\t\t    if (!maybe_lookup_field ((splay_tree_key) &DECL_UID (ovar),\n-\t\t\t\t\t     ctx))\n-\t\t      continue;\n-\t\t  }\n-\t\telse if (!maybe_lookup_field (ovar, ctx))\n+\t\tif (!maybe_lookup_field (ovar, ctx))\n \t\t  continue;\n \t      }\n \n@@ -14892,12 +15121,7 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t    if (nc)\n \t      {\n \t\tvar = lookup_decl_in_outer_ctx (ovar, ctx);\n-\t\tif (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n-\t\t    && OMP_CLAUSE_MAP_PRIVATE (c))\n-\t\t  x = build_sender_ref ((splay_tree_key) &DECL_UID (ovar),\n-\t\t\t\t\tctx);\n-\t\telse\n-\t\t  x = build_sender_ref (ovar, ctx);\n+\t\tx = build_sender_ref (ovar, ctx);\n \n \t\tif (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n \t\t\t && OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_POINTER\n@@ -15376,7 +15600,7 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t      }\n \t    break;\n \t  }\n-      /* Handle GOMP_MAP_FIRSTPRIVATE_POINTER in second pass,\n+      /* Handle GOMP_MAP_FIRSTPRIVATE_{POINTER,REFERENCE} in second pass,\n \t so that firstprivate vars holding OMP_CLAUSE_SIZE if needed\n \t are already handled.  */\n       for (c = clauses; c ; c = OMP_CLAUSE_CHAIN (c))\n@@ -15386,7 +15610,8 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t  default:\n \t    break;\n \t  case OMP_CLAUSE_MAP:\n-\t    if (OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_FIRSTPRIVATE_POINTER)\n+\t    if (OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_FIRSTPRIVATE_POINTER\n+\t\t|| OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_FIRSTPRIVATE_REFERENCE)\n \t      {\n \t\tlocation_t clause_loc = OMP_CLAUSE_LOCATION (c);\n \t\tHOST_WIDE_INT offset = 0;\n@@ -15440,6 +15665,8 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\t  }\n \t\telse\n \t\t  is_ref = is_reference (var);\n+\t\tif (OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_FIRSTPRIVATE_REFERENCE)\n+\t\t  is_ref = false;\n \t\tbool ref_to_array = false;\n \t\tif (is_ref)\n \t\t  {\n@@ -15491,8 +15718,10 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t    else if (OMP_CLAUSE_CHAIN (c)\n \t\t     && OMP_CLAUSE_CODE (OMP_CLAUSE_CHAIN (c))\n \t\t\t== OMP_CLAUSE_MAP\n-\t\t     && OMP_CLAUSE_MAP_KIND (OMP_CLAUSE_CHAIN (c))\n-\t\t\t== GOMP_MAP_FIRSTPRIVATE_POINTER)\n+\t\t     && (OMP_CLAUSE_MAP_KIND (OMP_CLAUSE_CHAIN (c))\n+\t\t\t == GOMP_MAP_FIRSTPRIVATE_POINTER\n+\t\t\t || (OMP_CLAUSE_MAP_KIND (OMP_CLAUSE_CHAIN (c))\n+\t\t\t     == GOMP_MAP_FIRSTPRIVATE_REFERENCE)))\n \t      prev = c;\n \t    break;\n \t  case OMP_CLAUSE_PRIVATE:\n@@ -16588,8 +16817,29 @@ simd_clone_clauses_extract (struct cgraph_node *node, tree clauses,\n \t    int argno = TREE_INT_CST_LOW (decl);\n \t    if (OMP_CLAUSE_LINEAR_VARIABLE_STRIDE (t))\n \t      {\n-\t\tclone_info->args[argno].arg_type\n-\t\t  = SIMD_CLONE_ARG_TYPE_LINEAR_VARIABLE_STEP;\n+\t\tenum cgraph_simd_clone_arg_type arg_type;\n+\t\tif (TREE_CODE (args[argno]) == REFERENCE_TYPE)\n+\t\t  switch (OMP_CLAUSE_LINEAR_KIND (t))\n+\t\t    {\n+\t\t    case OMP_CLAUSE_LINEAR_REF:\n+\t\t      arg_type\n+\t\t\t= SIMD_CLONE_ARG_TYPE_LINEAR_REF_VARIABLE_STEP;\n+\t\t      break;\n+\t\t    case OMP_CLAUSE_LINEAR_UVAL:\n+\t\t      arg_type\n+\t\t\t= SIMD_CLONE_ARG_TYPE_LINEAR_UVAL_VARIABLE_STEP;\n+\t\t      break;\n+\t\t    case OMP_CLAUSE_LINEAR_VAL:\n+\t\t    case OMP_CLAUSE_LINEAR_DEFAULT:\n+\t\t      arg_type\n+\t\t\t= SIMD_CLONE_ARG_TYPE_LINEAR_VAL_VARIABLE_STEP;\n+\t\t      break;\n+\t\t    default:\n+\t\t      gcc_unreachable ();\n+\t\t    }\n+\t\telse\n+\t\t  arg_type = SIMD_CLONE_ARG_TYPE_LINEAR_VARIABLE_STEP;\n+\t\tclone_info->args[argno].arg_type = arg_type;\n \t\tclone_info->args[argno].linear_step = tree_to_shwi (step);\n \t\tgcc_assert (clone_info->args[argno].linear_step >= 0\n \t\t\t    && clone_info->args[argno].linear_step < n);\n@@ -16767,7 +17017,19 @@ simd_clone_mangle (struct cgraph_node *node,\n \t    }\n \t  break;\n \tcase SIMD_CLONE_ARG_TYPE_LINEAR_VARIABLE_STEP:\n-\t  pp_character (&pp, 's');\n+\t  pp_string (&pp, \"ls\");\n+\t  pp_unsigned_wide_integer (&pp, arg.linear_step);\n+\t  break;\n+\tcase SIMD_CLONE_ARG_TYPE_LINEAR_REF_VARIABLE_STEP:\n+\t  pp_string (&pp, \"Rs\");\n+\t  pp_unsigned_wide_integer (&pp, arg.linear_step);\n+\t  break;\n+\tcase SIMD_CLONE_ARG_TYPE_LINEAR_VAL_VARIABLE_STEP:\n+\t  pp_string (&pp, \"Ls\");\n+\t  pp_unsigned_wide_integer (&pp, arg.linear_step);\n+\t  break;\n+\tcase SIMD_CLONE_ARG_TYPE_LINEAR_UVAL_VARIABLE_STEP:\n+\t  pp_string (&pp, \"Us\");\n \t  pp_unsigned_wide_integer (&pp, arg.linear_step);\n \t  break;\n \tdefault:\n@@ -16959,6 +17221,7 @@ simd_clone_adjust_argument_types (struct cgraph_node *node)\n \t  adj.op = IPA_PARM_OP_COPY;\n \t  break;\n \tcase SIMD_CLONE_ARG_TYPE_LINEAR_UVAL_CONSTANT_STEP:\n+\tcase SIMD_CLONE_ARG_TYPE_LINEAR_UVAL_VARIABLE_STEP:\n \t  if (node->definition)\n \t    node->simdclone->args[i].simd_array\n \t      = create_tmp_simd_array (IDENTIFIER_POINTER (DECL_NAME (parm)),\n@@ -16967,6 +17230,7 @@ simd_clone_adjust_argument_types (struct cgraph_node *node)\n \t  adj.op = IPA_PARM_OP_COPY;\n \t  break;\n \tcase SIMD_CLONE_ARG_TYPE_LINEAR_VAL_CONSTANT_STEP:\n+\tcase SIMD_CLONE_ARG_TYPE_LINEAR_VAL_VARIABLE_STEP:\n \tcase SIMD_CLONE_ARG_TYPE_VECTOR:\n \t  if (INTEGRAL_TYPE_P (parm_type) || POINTER_TYPE_P (parm_type))\n \t    veclen = node->simdclone->vecsize_int;\n@@ -17354,6 +17618,74 @@ ipa_simd_modify_function_body (struct cgraph_node *node,\n     }\n }\n \n+/* Helper function of simd_clone_adjust, return linear step addend\n+   of Ith argument.  */\n+\n+static tree\n+simd_clone_linear_addend (struct cgraph_node *node, unsigned int i,\n+\t\t\t  tree addtype, basic_block entry_bb)\n+{\n+  tree ptype = NULL_TREE;\n+  switch (node->simdclone->args[i].arg_type)\n+    {\n+    case SIMD_CLONE_ARG_TYPE_LINEAR_CONSTANT_STEP:\n+    case SIMD_CLONE_ARG_TYPE_LINEAR_REF_CONSTANT_STEP:\n+    case SIMD_CLONE_ARG_TYPE_LINEAR_VAL_CONSTANT_STEP:\n+    case SIMD_CLONE_ARG_TYPE_LINEAR_UVAL_CONSTANT_STEP:\n+      return build_int_cst (addtype, node->simdclone->args[i].linear_step);\n+    case SIMD_CLONE_ARG_TYPE_LINEAR_VARIABLE_STEP:\n+    case SIMD_CLONE_ARG_TYPE_LINEAR_REF_VARIABLE_STEP:\n+      ptype = TREE_TYPE (node->simdclone->args[i].orig_arg);\n+      break;\n+    case SIMD_CLONE_ARG_TYPE_LINEAR_VAL_VARIABLE_STEP:\n+    case SIMD_CLONE_ARG_TYPE_LINEAR_UVAL_VARIABLE_STEP:\n+      ptype = TREE_TYPE (TREE_TYPE (node->simdclone->args[i].orig_arg));\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  unsigned int idx = node->simdclone->args[i].linear_step;\n+  tree arg = node->simdclone->args[idx].orig_arg;\n+  gcc_assert (is_gimple_reg_type (TREE_TYPE (arg)));\n+  gimple_stmt_iterator gsi = gsi_after_labels (entry_bb);\n+  gimple *g;\n+  tree ret;\n+  if (is_gimple_reg (arg))\n+    ret = get_or_create_ssa_default_def (cfun, arg);\n+  else\n+    {\n+      g = gimple_build_assign (make_ssa_name (TREE_TYPE (arg)), arg);\n+      gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+      ret = gimple_assign_lhs (g);\n+    }\n+  if (TREE_CODE (TREE_TYPE (arg)) == REFERENCE_TYPE)\n+    {\n+      g = gimple_build_assign (make_ssa_name (TREE_TYPE (TREE_TYPE (arg))),\n+\t\t\t       build_simple_mem_ref (ret));\n+      gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+      ret = gimple_assign_lhs (g);\n+    }\n+  if (!useless_type_conversion_p (addtype, TREE_TYPE (ret)))\n+    {\n+      g = gimple_build_assign (make_ssa_name (addtype), NOP_EXPR, ret);\n+      gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+      ret = gimple_assign_lhs (g);\n+    }\n+  if (POINTER_TYPE_P (ptype))\n+    {\n+      tree size = TYPE_SIZE_UNIT (TREE_TYPE (ptype));\n+      if (size && TREE_CODE (size) == INTEGER_CST)\n+\t{\n+\t  g = gimple_build_assign (make_ssa_name (addtype), MULT_EXPR,\n+\t\t\t\t   ret, fold_convert (addtype, size));\n+\t  gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+\t  ret = gimple_assign_lhs (g);\n+\t}\n+    }\n+  return ret;\n+}\n+\n /* Adjust the argument types in NODE to their appropriate vector\n    counterparts.  */\n \n@@ -17593,7 +17925,11 @@ simd_clone_adjust (struct cgraph_node *node)\n     else if ((node->simdclone->args[i].arg_type\n \t      == SIMD_CLONE_ARG_TYPE_LINEAR_CONSTANT_STEP)\n \t     || (node->simdclone->args[i].arg_type\n-\t\t == SIMD_CLONE_ARG_TYPE_LINEAR_REF_CONSTANT_STEP))\n+\t\t == SIMD_CLONE_ARG_TYPE_LINEAR_REF_CONSTANT_STEP)\n+\t     || (node->simdclone->args[i].arg_type\n+\t\t == SIMD_CLONE_ARG_TYPE_LINEAR_VARIABLE_STEP)\n+\t     || (node->simdclone->args[i].arg_type\n+\t\t == SIMD_CLONE_ARG_TYPE_LINEAR_REF_VARIABLE_STEP))\n       {\n \ttree orig_arg = node->simdclone->args[i].orig_arg;\n \tgcc_assert (INTEGRAL_TYPE_P (TREE_TYPE (orig_arg))\n@@ -17628,10 +17964,10 @@ simd_clone_adjust (struct cgraph_node *node)\n \t\t\t\t  ? PLUS_EXPR : POINTER_PLUS_EXPR;\n \t    tree addtype = INTEGRAL_TYPE_P (TREE_TYPE (orig_arg))\n \t\t\t   ? TREE_TYPE (orig_arg) : sizetype;\n-\t    tree addcst\n-\t      = build_int_cst (addtype, node->simdclone->args[i].linear_step);\n-\t    g = gimple_build_assign (iter2, code, iter1, addcst);\n+\t    tree addcst = simd_clone_linear_addend (node, i, addtype,\n+\t\t\t\t\t\t    entry_bb);\n \t    gsi = gsi_last_bb (incr_bb);\n+\t    g = gimple_build_assign (iter2, code, iter1, addcst);\n \t    gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n \n \t    imm_use_iterator iter;\n@@ -17653,7 +17989,9 @@ simd_clone_adjust (struct cgraph_node *node)\n \t  }\n       }\n     else if (node->simdclone->args[i].arg_type\n-\t     == SIMD_CLONE_ARG_TYPE_LINEAR_UVAL_CONSTANT_STEP)\n+\t     == SIMD_CLONE_ARG_TYPE_LINEAR_UVAL_CONSTANT_STEP\n+\t     || (node->simdclone->args[i].arg_type\n+\t\t == SIMD_CLONE_ARG_TYPE_LINEAR_UVAL_VARIABLE_STEP))\n       {\n \ttree orig_arg = node->simdclone->args[i].orig_arg;\n \ttree def = ssa_default_def (cfun, orig_arg);\n@@ -17690,8 +18028,8 @@ simd_clone_adjust (struct cgraph_node *node)\n \t\t\t\t  ? PLUS_EXPR : POINTER_PLUS_EXPR;\n \t    tree addtype = INTEGRAL_TYPE_P (TREE_TYPE (iter3))\n \t\t\t   ? TREE_TYPE (iter3) : sizetype;\n-\t    tree addcst\n-\t      = build_int_cst (addtype, node->simdclone->args[i].linear_step);\n+\t    tree addcst = simd_clone_linear_addend (node, i, addtype,\n+\t\t\t\t\t\t    entry_bb);\n \t    g = gimple_build_assign (iter5, code, iter4, addcst);\n \t    gsi = gsi_last_bb (incr_bb);\n \t    gsi_insert_before (&gsi, g, GSI_SAME_STMT);"}, {"sha": "6cf2f4f3afbe6852b441cc4f62a234844baf0e5d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -1,3 +1,54 @@\n+2015-11-05  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-c++-common/gomp/clauses-2.c (foo): Adjust for diagnostics\n+\tof variables in both data sharing and mapping clauses and for\n+\tstructure element based array sections being mapped rather than\n+\tprivatized.\n+\t* c-c++-common/gomp/declare-target-2.c: Add various new tests.  Adjust\n+\texpected diagnostics wording in one case.\n+\t* c-c++-common/gomp/distribute-1.c: New test.\n+\t* c-c++-common/gomp/element-1.c: New test.\n+\t* c-c++-common/gomp/pr61486-2.c: Add #pragma omp declare target\n+\tand #pragma omp end declare target pair around the function.\n+\tChange s from a parameter to a file scope variable.\n+\t* c-c++-common/gomp/pr67521.c: Add dg-error directives.\n+\t* c-c++-common/gomp/reduction-1.c (foo): Don't expect diagnostics\n+\ton non-zero low-bound in reduction array sections.  Add further\n+\ttests.\n+\t* c-c++-common/gomp/schedule-modifiers-1.c: New test.\n+\t* c-c++-common/gomp/target-teams-1.c: New test.\n+\t* gcc.dg/gomp/declare-simd-1.c: Add scan-assembler-times directives\n+\tfor expected mangling on x86_64/i?86.\n+\t* gcc.dg/gomp/declare-simd-3.c: New test.\n+\t* gcc.dg/gomp/declare-simd-4.c: New test.\n+\t* gcc.dg/gomp/for-20.c: New test.\n+\t* gcc.dg/gomp/for-21.c: New test.\n+\t* gcc.dg/gomp/for-22.c: New test.\n+\t* gcc.dg/gomp/for-23.c: New test.\n+\t* gcc.dg/gomp/for-24.c: New test.\n+\t* gcc.dg/gomp/linear-1.c: New test.\n+\t* gcc.dg/gomp/loop-1.c: New test.\n+\t* g++.dg/gomp/atomic-17.C: New test.\n+\t* g++.dg/gomp/clause-1.C (T::test): Don't expect error on\n+\tnon-static data member in shared clause.  Add single construct.\n+\t* g++.dg/gomp/declare-simd-1.C: Add dg-options.  Add\n+\tscan-assembler-times directives for expected mangling on x86_64/i?86.\n+\t* g++.dg/gomp/declare-simd-3.C: Likewise.\n+\t* g++.dg/gomp/declare-simd-4.C: New test.\n+\t* g++.dg/gomp/declare-simd-5.C: New test.\n+\t* g++.dg/gomp/declare-target-1.C: New test.\n+\t* g++.dg/gomp/linear-2.C: New test.\n+\t* g++.dg/gomp/loop-1.C: New test.\n+\t* g++.dg/gomp/loop-2.C: New test.\n+\t* g++.dg/gomp/loop-3.C: New test.\n+\t* g++.dg/gomp/member-2.C (B::m2, B::m4): Don't expect error on\n+\tnon-static data member in shared clause.\n+\t* g++.dg/gomp/member-3.C: New test.\n+\t* g++.dg/gomp/member-4.C: New test.\n+\t* g++.dg/gomp/pr38639.C (foo): Adjust dg-error.\n+\t(bar): Remove dg-message.\n+\t* g++.dg/gomp/target-teams-1.C: New test.\n+\n 2015-11-05  Richard Biener  <rguenther@suse.de>\n \n \t* gcc.dg/tree-ssa/loadpre2.c: Avoid undefined behavior due to"}, {"sha": "dff8bfebad5ad7e08ba7a362194513e4284857bf", "filename": "gcc/testsuite/c-c++-common/gomp/clauses-2.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fclauses-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fclauses-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fclauses-2.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -4,15 +4,15 @@ void bar (int *);\n void\n foo (int *p, int q, struct S t, int i, int j, int k, int l)\n {\n-  #pragma omp target map (q), firstprivate (q)\n+  #pragma omp target map (q), firstprivate (q) /* { dg-error \"appears both in data and map clauses\" } */\n     bar (&q);\n   #pragma omp target map (p[0]) firstprivate (p) /* { dg-error \"appears more than once in data clauses\" } */\n     bar (p);\n   #pragma omp target firstprivate (p), map (p[0]) /* { dg-error \"appears more than once in data clauses\" } */\n     bar (p);\n-  #pragma omp target map (p[0]) map (p)\n+  #pragma omp target map (p[0]) map (p) /* { dg-error \"appears both in data and map clauses\" } */\n     bar (p);\n-  #pragma omp target map (p) , map (p[0])\n+  #pragma omp target map (p) , map (p[0]) /* { dg-error \"appears both in data and map clauses\" } */\n     bar (p);\n   #pragma omp target map (q) map (q) /* { dg-error \"appears more than once in map clauses\" } */\n     bar (&q);\n@@ -24,17 +24,17 @@ foo (int *p, int q, struct S t, int i, int j, int k, int l)\n     bar (&t.r);\n   #pragma omp target map (t.r) map (t.r) /* { dg-error \"appears more than once in map clauses\" } */\n     bar (&t.r);\n-  #pragma omp target firstprivate (t), map (t.r)\n+  #pragma omp target firstprivate (t), map (t.r) /* { dg-error \"appears both in data and map clauses\" } */\n     bar (&t.r);\n-  #pragma omp target map (t.r) firstprivate (t)\n+  #pragma omp target map (t.r) firstprivate (t) /* { dg-error \"appears both in data and map clauses\" } */\n     bar (&t.r);\n-  #pragma omp target map (t.s[0]) map (t)\n+  #pragma omp target map (t.s[0]) map (t) /* { dg-error \"appears more than once in map clauses\" } */\n     bar (t.s);\n-  #pragma omp target map (t) map(t.s[0])\n+  #pragma omp target map (t) map(t.s[0]) /* { dg-error \"appears more than once in map clauses\" } */\n     bar (t.s);\n-  #pragma omp target firstprivate (t) map (t.s[0]) /* { dg-error \"appears more than once in data clauses\" } */\n+  #pragma omp target firstprivate (t) map (t.s[0]) /* { dg-error \"appears both in data and map clauses\" } */\n     bar (t.s);\n-  #pragma omp target map (t.s[0]) firstprivate (t) /* { dg-error \"appears more than once in data clauses\" } */\n+  #pragma omp target map (t.s[0]) firstprivate (t) /* { dg-error \"appears both in data and map clauses\" } */\n     bar (t.s);\n   #pragma omp target map (t.s[0]) map (t.s[2]) /* { dg-error \"appears more than once in map clauses\" } */\n     bar (t.s);\n@@ -46,8 +46,8 @@ foo (int *p, int q, struct S t, int i, int j, int k, int l)\n     bar (t.s);\n   #pragma omp target map (t.r) ,map (t.s[0])\n     bar (t.s);\n-  #pragma omp target map (t.r) map (t) map (t.s[0]) firstprivate (t) /* { dg-error \"appears more than once in map clauses\" } */\n-    bar (t.s); /* { dg-error \"appears more than once in data clauses\" \"\" { target *-*-* } 49 } */\n-  #pragma omp target map (t) map (t.r) firstprivate (t) map (t.s[0])  /* { dg-error \"appears more than once in map clauses\" } */\n-    bar (t.s); /* { dg-error \"appears more than once in data clauses\" \"\" { target *-*-* } 51 } */\n+  #pragma omp target map (t.r) map (t) map (t.s[0]) firstprivate (t) /* { dg-error \"appears both in data and map clauses\" } */\n+    bar (t.s);\n+  #pragma omp target map (t) map (t.r) firstprivate (t) map (t.s[0]) /* { dg-error \"appears both in data and map clauses\" } */\n+    bar (t.s); /* { dg-error \"appears more than once in map clauses\" \"\" { target *-*-* } 51 } */\n }"}, {"sha": "1135a1d00b4ee56623ee3dc2fcab7eea6990ac10", "filename": "gcc/testsuite/c-c++-common/gomp/declare-target-2.c", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-target-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-target-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-target-2.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -6,7 +6,7 @@ extern int a;\n #pragma omp declare target to (a)\t\t/* { dg-error \"with clauses in between\" } */\n #pragma omp end declare target\n int b;\n-#pragma omp declare target to (b) link (b)\t/* { dg-error \"specified both in declare target\" } */\n+#pragma omp declare target to (b) link (b)\t/* { dg-error \"appears more than once on the same .declare target. directive\" } */\n int c;\n #pragma omp declare target (c)\n #pragma omp declare target link (c)\t\t/* { dg-error \"specified both in declare target\" } */\n@@ -25,3 +25,21 @@ int g, h;\n #pragma omp declare target link (h)\t\t/* { dg-error \"is threadprivate variable in\" } */\n int j[10];\n #pragma omp declare target to (j[0:4])\t\t/* { dg-error \"expected\" } */\n+int k, l;\n+#pragma omp declare target\n+int m;\n+#pragma omp end declare target\n+#pragma omp declare target to (k)\n+#pragma omp declare target (k)\n+#pragma omp declare target to (k, m) link (l)\n+#pragma omp declare target link (l)\n+int n, o, s, t;\n+#pragma omp declare target to (n) to (n)\t/* { dg-error \"appears more than once on the same .declare target. directive\" } */\n+#pragma omp declare target link (o, o)\t\t/* { dg-error \"appears more than once on the same .declare target. directive\" } */\n+#pragma omp declare target (s, t, s)\t\t/* { dg-error \"appears more than once on the same .declare target. directive\" } */\n+int p, q, r;\n+#pragma omp declare target (p) to (q)\t\t/* { dg-error \"expected end of line before .to.\" } */\n+#pragma omp declare target to (p) (q) link (r)\t/* { dg-error \"expected .#pragma omp. clause before\" } */\n+#pragma omp declare target link (r) (p)\t\t/* { dg-error \"expected .#pragma omp. clause before\" } */\n+#pragma omp declare target\n+#pragma omp end declare target to (p)\t\t/* { dg-error \"expected end of line before .to.\" } */"}, {"sha": "e5e4bc2669d80cf2251c86567b3ffdbec2f91621", "filename": "gcc/testsuite/c-c++-common/gomp/distribute-1.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdistribute-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdistribute-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdistribute-1.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,56 @@\n+int s1, s2, s3, s4, s5, s6, s7, s8;\n+#pragma omp declare target (s1, s2, s3, s4, s5, s6, s7, s8)\n+\n+void\n+f1 (void)\n+{\n+  int i;\n+  #pragma omp distribute\n+  for (i = 0; i < 64; i++)\n+    ;\n+  #pragma omp distribute private (i)\n+  for (i = 0; i < 64; i++)\n+    ;\n+  #pragma omp distribute\n+  for (int j = 0; j < 64; j++)\n+    ;\n+  #pragma omp distribute lastprivate (s1)\n+  for (s1 = 0; s1 < 64; s1 += 2)\n+    ;\n+  #pragma omp distribute lastprivate (s2)\n+  for (i = 0; i < 64; i++)\n+    s2 = 2 * i;\n+  #pragma omp distribute simd\n+  for (i = 0; i < 64; i++)\n+    ;\n+  #pragma omp distribute simd lastprivate (s3, s4) collapse(2)\n+  for (s3 = 0; s3 < 64; s3++)\n+    for (s4 = 0; s4 < 3; s4++)\n+      ;\n+  #pragma omp distribute parallel for\n+  for (i = 0; i < 64; i++)\n+    ;\n+  #pragma omp distribute parallel for private (i)\n+  for (i = 0; i < 64; i++)\n+    ;\n+  #pragma omp distribute parallel for lastprivate (s5)\n+  for (s5 = 0; s5 < 64; s5++)\n+    ;\n+  #pragma omp distribute firstprivate (s7) private (s8)\n+  for (i = 0; i < 64; i++)\n+    s8 = s7++;\n+}\n+\n+void\n+f2 (void)\n+{\n+  int i;\n+  #pragma omp distribute lastprivate (i)\t/* { dg-error \"lastprivate variable .i. is private in outer context\" } */\n+  for (i = 0; i < 64; i++)\n+    ;\n+  #pragma omp distribute firstprivate (s6) lastprivate (s6) /* { dg-error \"same variable used in .firstprivate. and .lastprivate. clauses on .distribute. construct\" } */\n+  for (i = 0; i < 64; i++)\n+    s6 += i;\n+}\n+\n+#pragma omp declare target to(f1, f2)"}, {"sha": "fbd286c5b8798a5c3455e5b35ebbba612e36ba82", "filename": "gcc/testsuite/c-c++-common/gomp/element-1.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Felement-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Felement-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Felement-1.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+\n+struct S { int a; };\n+\n+void\n+foo (struct S *x)\n+{\n+  struct S b;\n+  #pragma omp parallel private (b.a)\t/* { dg-error \"expected .\\\\). before .\\\\.. token\" } */\n+  ;\n+  #pragma omp parallel private (x->a)\t/* { dg-error \"expected .\\\\). before .->. token\" } */\n+  ;\n+}"}, {"sha": "db97143e913e3490e86057d7a23e37e125b72f31", "filename": "gcc/testsuite/c-c++-common/gomp/pr61486-2.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr61486-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr61486-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr61486-2.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -355,8 +355,11 @@ test (int n, int o, int p, int q, int r, int s, int *pp)\n \n int q, i, j;\n \n+#pragma omp declare target\n+int s;\n+\n void\n-test2 (int n, int o, int p, int r, int s, int *pp)\n+test2 (int n, int o, int p, int r, int *pp)\n {\n   int a[o];\n     #pragma omp distribute collapse (2) dist_schedule (static, 4) firstprivate (q)\n@@ -449,3 +452,4 @@ test2 (int n, int o, int p, int r, int s, int *pp)\n \t  s = i * 10;\n \t}\n }\n+#pragma omp end declare target"}, {"sha": "5984fa9c3bbc34b52b4aa8fd00d2423ab6218f33", "filename": "gcc/testsuite/c-c++-common/gomp/pr67521.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr67521.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr67521.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr67521.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -7,14 +7,14 @@ foo (int x)\n {\n   int i = 0;\n   #pragma omp parallel for simd\n-  for (i = (i & x); i < 10; i = i + 2)\n+  for (i = (i & x); i < 10; i = i + 2) /* { dg-error \"initializer expression refers to iteration variable\" } */\n     ;\n   i = 0;\n   #pragma omp parallel for simd\n-  for (i = 0; i < (i & x) + 10; i = i + 2)\n+  for (i = 0; i < (i & x) + 10; i = i + 2) /* { dg-error \"condition expression refers to iteration variable\" } */\n     ;\n   i = 0;\n   #pragma omp parallel for simd\n-  for (i = 0; i < 10; i = i + ((i & x) + 2))\n+  for (i = 0; i < 10; i = i + ((i & x) + 2)) /* { dg-error \"increment expression refers to iteration variable\" } */\n     ;\n }"}, {"sha": "e8dd530b1a4ec9ae65008e43c812b1452e4e0d60", "filename": "gcc/testsuite/c-c++-common/gomp/reduction-1.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Freduction-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Freduction-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Freduction-1.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -26,9 +26,17 @@ foo (int a[10][10][10], int **b, int x)\n     bar (a);\n   #pragma omp parallel reduction(+: a[0:4])\n     bar (a);\n-  #pragma omp parallel reduction(+: a[2:4])\t\t/* { dg-error \"array section has to be zero-based\" } */\n+  #pragma omp parallel reduction(+: a[2:4])\n     bar (a);\n-  #pragma omp parallel reduction(+: e[2:4])\t\t/* { dg-error \"array section has to be zero-based\" } */\n+  #pragma omp parallel reduction(+: e[2:4])\n+    bar (a);\n+  #pragma omp parallel reduction(+: a[x:4])\n+    bar (a);\n+  #pragma omp parallel reduction(+: e[x:4])\n+    bar (a);\n+  #pragma omp parallel reduction(+: a[x:x])\n+    bar (a);\n+  #pragma omp parallel reduction(+: e[x:x])\n     bar (a);\n   #pragma omp parallel reduction(+: a[0.5:2])\t\t/* { dg-error \"low bound \\[^\\n\\r]* of array section does not have integral type\" } */\n     bar (a);"}, {"sha": "7edea1b147cca4fa83a63febc59975e85f2a2ccc", "filename": "gcc/testsuite/c-c++-common/gomp/schedule-modifiers-1.c", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fschedule-modifiers-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fschedule-modifiers-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fschedule-modifiers-1.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,109 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+\n+void\n+foo (void)\n+{\n+  int i;\n+  #pragma omp for simd schedule (simd, simd: static, 5)\n+  for (i = 0; i < 64; i++)\n+    ;\n+  #pragma omp for simd schedule (monotonic, simd: static)\n+  for (i = 0; i < 64; i++)\n+    ;\n+  #pragma omp for simd schedule (simd , monotonic : static, 6)\n+  for (i = 0; i < 64; i++)\n+    ;\n+  #pragma omp for schedule (monotonic, monotonic : static, 7)\n+  for (i = 0; i < 64; i++)\n+    ;\n+  #pragma omp for schedule (nonmonotonic, nonmonotonic : dynamic)\n+  for (i = 0; i < 64; i++)\n+    ;\n+  #pragma omp for simd schedule (nonmonotonic , simd : dynamic, 3)\n+  for (i = 0; i < 64; i++)\n+    ;\n+  #pragma omp for simd schedule (nonmonotonic,simd:guided,4)\n+  for (i = 0; i < 64; i++)\n+    ;\n+  #pragma omp for schedule (monotonic: static, 2)\n+  for (i = 0; i < 64; i++)\n+    ;\n+  #pragma omp for schedule (monotonic : static)\n+  for (i = 0; i < 64; i++)\n+    ;\n+  #pragma omp for schedule (monotonic : dynamic)\n+  for (i = 0; i < 64; i++)\n+    ;\n+  #pragma omp for schedule (monotonic : dynamic, 3)\n+  for (i = 0; i < 64; i++)\n+    ;\n+  #pragma omp for schedule (monotonic : guided)\n+  for (i = 0; i < 64; i++)\n+    ;\n+  #pragma omp for schedule (monotonic : guided, 7)\n+  for (i = 0; i < 64; i++)\n+    ;\n+  #pragma omp for schedule (monotonic : runtime)\n+  for (i = 0; i < 64; i++)\n+    ;\n+  #pragma omp for schedule (monotonic : auto)\n+  for (i = 0; i < 64; i++)\n+    ;\n+  #pragma omp for schedule (nonmonotonic : dynamic)\n+  for (i = 0; i < 64; i++)\n+    ;\n+  #pragma omp for schedule (nonmonotonic : dynamic, 3)\n+  for (i = 0; i < 64; i++)\n+    ;\n+  #pragma omp for schedule (nonmonotonic : guided)\n+  for (i = 0; i < 64; i++)\n+    ;\n+  #pragma omp for schedule (nonmonotonic : guided, 7)\n+  for (i = 0; i < 64; i++)\n+    ;\n+}\n+\n+void\n+bar (void)\n+{\n+  int i;\n+  #pragma omp for schedule (nonmonotonic: static, 2)\t/* { dg-error \".nonmonotonic. modifier specified for .static. schedule kind\" } */\n+  for (i = 0; i < 64; i++)\n+    ;\n+  #pragma omp for schedule (nonmonotonic : static)\t/* { dg-error \".nonmonotonic. modifier specified for .static. schedule kind\" } */\n+  for (i = 0; i < 64; i++)\n+    ;\n+  #pragma omp for schedule (nonmonotonic : runtime)\t/* { dg-error \".nonmonotonic. modifier specified for .runtime. schedule kind\" } */\n+  for (i = 0; i < 64; i++)\n+    ;\n+  #pragma omp for schedule (nonmonotonic : auto)\t/* { dg-error \".nonmonotonic. modifier specified for .auto. schedule kind\" } */\n+  for (i = 0; i < 64; i++)\n+    ;\n+  #pragma omp for schedule (nonmonotonic, dynamic) ordered\t/* { dg-error \".nonmonotonic. schedule modifier specified together with .ordered. clause\" } */\n+  for (i = 0; i < 64; i++)\n+    #pragma omp ordered\n+      ;\n+  #pragma omp for ordered schedule(nonmonotonic, dynamic, 5)\t/* { dg-error \".nonmonotonic. schedule modifier specified together with .ordered. clause\" } */\n+  for (i = 0; i < 64; i++)\n+    #pragma omp ordered\n+      ;\n+  #pragma omp for schedule (nonmonotonic, guided) ordered(1)\t/* { dg-error \".nonmonotonic. schedule modifier specified together with .ordered. clause\" } */\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp ordered depend(sink: i - 1)\n+      #pragma omp ordered depend(source)\n+    }\n+  #pragma omp for ordered(1) schedule(nonmonotonic, guided, 2)\t/* { dg-error \".nonmonotonic. schedule modifier specified together with .ordered. clause\" } */\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp ordered depend(source)\n+      #pragma omp ordered depend(sink: i - 1)\n+    }\n+  #pragma omp for schedule (nonmonotonic , monotonic : dynamic)\t/* { dg-error \"both .monotonic. and .nonmonotonic. modifiers specified\" } */\n+  for (i = 0; i < 64; i++)\n+    ;\n+  #pragma omp for schedule (monotonic,nonmonotonic:dynamic)\t/* { dg-error \"both .monotonic. and .nonmonotonic. modifiers specified\" } */\n+  for (i = 0; i < 64; i++)\n+    ;\n+}"}, {"sha": "0a707c2e49abe416b21c7cd6465ab806df244a8d", "filename": "gcc/testsuite/c-c++-common/gomp/target-teams-1.c", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-teams-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-teams-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-teams-1.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,85 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-gimple\" } */\n+\n+int v = 6;\n+void bar (int);\n+void bar2 (int, long *, long *);\n+int baz (void);\n+#pragma omp declare target to (bar, baz, v)\n+\n+void\n+foo (int a, int b, long c, long d)\n+{\n+  /* The OpenMP 4.5 spec says that these expressions are evaluated before\n+     target region on combined target teams, so those cases are always\n+     fine.  */\n+  #pragma omp target\n+  bar (0);\n+  #pragma omp target\n+  #pragma omp teams\n+  bar (1);\n+  #pragma omp target teams\n+  bar (2);\n+  #pragma omp target\n+  #pragma omp teams num_teams (4)\n+  bar (3);\n+  #pragma omp target teams num_teams (4)\n+  bar (4);\n+  #pragma omp target\n+  #pragma omp teams thread_limit (7)\n+  bar (5);\n+  #pragma omp target teams thread_limit (7)\n+  bar (6);\n+  #pragma omp target\n+  #pragma omp teams num_teams (4) thread_limit (8)\n+  {\n+    {\n+      bar (7);\n+    }\n+  }\n+  #pragma omp target teams num_teams (4) thread_limit (8)\n+  bar (8);\n+  #pragma omp target\n+  #pragma omp teams num_teams (a) thread_limit (b)\n+  bar (9);\n+  #pragma omp target teams num_teams (a) thread_limit (b)\n+  bar (10);\n+  #pragma omp target\n+  #pragma omp teams num_teams (c + 1) thread_limit (d - 1)\n+  bar (11);\n+  #pragma omp target teams num_teams (c + 1) thread_limit (d - 1)\n+  bar (12);\n+  #pragma omp target map (always, to: c, d)\n+  #pragma omp teams num_teams (c + 1) thread_limit (d - 1)\n+  bar (13);\n+  #pragma omp target data map (to: c, d)\n+  {\n+    #pragma omp target defaultmap (tofrom: scalar)\n+    bar2 (14, &c, &d);\n+    /* This is one of the cases which can't be generally optimized,\n+       the c and d are (or could be) already mapped and whether\n+       their device and original values match is unclear.  */\n+    #pragma omp target map (to: c, d)\n+    #pragma omp teams num_teams (c + 1) thread_limit (d - 1)\n+    bar (15);\n+  }\n+  /* This can't be optimized, there are function calls inside of\n+     target involved.  */\n+  #pragma omp target\n+  #pragma omp teams num_teams (baz () + 1) thread_limit (baz () - 1)\n+  bar (16);\n+  #pragma omp target teams num_teams (baz () + 1) thread_limit (baz () - 1)\n+  bar (17);\n+  /* This one can't be optimized, as v might have different value between\n+     host and target.  */\n+  #pragma omp target\n+  #pragma omp teams num_teams (v + 1) thread_limit (v - 1)\n+  bar (18);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"num_teams\\\\(-1\\\\)\" 3 \"gimple\" } } */\n+/* { dg-final { scan-tree-dump-times \"thread_limit\\\\(-1\\\\)\" 3 \"gimple\" } } */\n+/* { dg-final { scan-tree-dump-times \"num_teams\\\\(0\\\\)\" 4 \"gimple\" } } */\n+/* { dg-final { scan-tree-dump-times \"thread_limit\\\\(0\\\\)\" 6 \"gimple\" } } */\n+/* { dg-final { scan-tree-dump-times \"num_teams\\\\(1\\\\)\" 2 \"gimple\" } } */\n+/* { dg-final { scan-tree-dump-times \"thread_limit\\\\(1\\\\)\" 0 \"gimple\" } } */"}, {"sha": "91c479e78efed4c7de742a6053f6edb46d4cc283", "filename": "gcc/testsuite/g++.dg/gomp/atomic-17.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-17.C?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,12 @@\n+template <typename T>\n+struct A { int foo (); int c; };\n+\n+template <typename T>\n+int\n+A<T>::foo ()\n+{\n+  int j;\n+  #pragma omp atomic read\n+  j = A::c;\n+  return j;\n+}"}, {"sha": "68f42acfb40b1daeb66799906c92a7dc42fde080", "filename": "gcc/testsuite/g++.dg/gomp/clause-1.C", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fclause-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fclause-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fclause-1.C?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -12,7 +12,8 @@ void T::test()\n   #pragma omp parallel private(n)\n     n = 1;\n \n-  #pragma omp parallel shared(n)\t// { dg-error \"T::n\" }\n+  #pragma omp parallel shared(n)\n+  #pragma omp single\n     n = 1;\n \n   #pragma omp parallel firstprivate(n)"}, {"sha": "1462efd7a1d6d4bd72cae5de7a2fc4b02e80aec0", "filename": "gcc/testsuite/g++.dg/gomp/declare-simd-1.C", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdeclare-simd-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdeclare-simd-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdeclare-simd-1.C?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -1,5 +1,6 @@\n // Test parsing of #pragma omp declare simd\n // { dg-do compile }\n+// { dg-options \"-fopenmp -ffat-lto-objects\" }\n \n #pragma omp declare simd uniform (a) aligned (b : 8 * sizeof (int)) \\\n \t    linear (c : 4) simdlen (8) notinbranch\n@@ -13,6 +14,13 @@ int f2 (int a, int *b, int c)\n   return a + *b + c;\n }\n \n+// { dg-final { scan-assembler-times \"_ZGVbM8uva32l4__Z2f2iPii:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVbN8uva32l4__Z2f2iPii:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVcM8uva32l4__Z2f2iPii:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVcN8uva32l4__Z2f2iPii:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVdM8uva32l4__Z2f2iPii:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVdN8uva32l4__Z2f2iPii:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+\n #pragma omp declare simd uniform (c) aligned (b : 4 * sizeof (int)) linear (a : 4) simdlen (4)\n template <typename T>\n T f3 (int a, int *b, T c);\n@@ -71,6 +79,13 @@ namespace N1\n   }\n }\n \n+// { dg-final { scan-assembler-times \"_ZGVbM2va16__ZN2N12N23f10EPx:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVbN2va16__ZN2N12N23f10EPx:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVcM2va16__ZN2N12N23f10EPx:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVcN2va16__ZN2N12N23f10EPx:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVdM2va16__ZN2N12N23f10EPx:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVdN2va16__ZN2N12N23f10EPx:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+\n struct A\n {\n   #pragma omp declare simd uniform (a) aligned (b : 8 * sizeof (int)) linear (c : 4) simdlen (8)\n@@ -172,6 +187,13 @@ int B<int>::f25<7> (int a, int *b, int c)\n   return a + *b + c;\n }\n \n+// { dg-final { scan-assembler-times \"_ZGVbM8vuva32u__ZN1BIiE3f25ILi7EEEiiPii:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVbN8vuva32u__ZN1BIiE3f25ILi7EEEiiPii:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVcM8vuva32u__ZN1BIiE3f25ILi7EEEiiPii:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVcN8vuva32u__ZN1BIiE3f25ILi7EEEiiPii:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVdM8vuva32u__ZN1BIiE3f25ILi7EEEiiPii:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVdN8vuva32u__ZN1BIiE3f25ILi7EEEiiPii:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+\n #pragma omp declare simd simdlen (4) aligned (b : 8 * sizeof (int)) linear (a, c : 2)\n template <>\n template <>\n@@ -180,6 +202,13 @@ int B<int>::f26<-1> (int a, int *b, int c)\n   return a + *b + c;\n }\n \n+// { dg-final { scan-assembler-times \"_ZGVbM4vl2va32__ZN1BIiE3f26ILin1EEEiiPii:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVbN4vl2va32__ZN1BIiE3f26ILin1EEEiiPii:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVcM4vl2va32__ZN1BIiE3f26ILin1EEEiiPii:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVcN4vl2va32__ZN1BIiE3f26ILin1EEEiiPii:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVdM4vl2va32__ZN1BIiE3f26ILin1EEEiiPii:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVdN4vl2va32__ZN1BIiE3f26ILin1EEEiiPii:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+\n int\n f27 (int x)\n {\n@@ -202,6 +231,13 @@ f30 (int x)\n   return x;\n }\n \n+// { dg-final { scan-assembler-times \"_ZGVbM16v__Z3f30i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVbN16v__Z3f30i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVcM16v__Z3f30i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVcN16v__Z3f30i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVdM16v__Z3f30i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVdN16v__Z3f30i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+\n template <int N>\n struct C\n {"}, {"sha": "4ae4251487544605d765903316f206e1cf99ea3d", "filename": "gcc/testsuite/g++.dg/gomp/declare-simd-3.C", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdeclare-simd-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdeclare-simd-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdeclare-simd-3.C?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -1,4 +1,5 @@\n // { dg-do compile }\n+// { dg-options \"-fopenmp -ffat-lto-objects\" }\n \n #pragma omp declare simd uniform(b) linear(c, d) linear(uval(e)) linear(ref(f))\n int f1 (int a, int b, int c, int &d, int &e, int &f)\n@@ -12,6 +13,13 @@ int f1 (int a, int b, int c, int &d, int &e, int &f)\n   return a + b + c + d + e + f;\n }\n \n+// { dg-final { scan-assembler-times \"_ZGVbM4vulLUR4__Z2f1iiiRiS_S_:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVbN4vulLUR4__Z2f1iiiRiS_S_:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVcM4vulLUR4__Z2f1iiiRiS_S_:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVcN4vulLUR4__Z2f1iiiRiS_S_:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVdM8vulLUR4__Z2f1iiiRiS_S_:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVdN8vulLUR4__Z2f1iiiRiS_S_:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+\n #pragma omp declare simd uniform(b) linear(c, d) linear(uval(e)) linear(ref(f))\n int f2 (int a, int b, int c, int &d, int &e, int &f)\n {\n@@ -30,12 +38,26 @@ int f2 (int a, int b, int c, int &d, int &e, int &f)\n   return a + b + c + d + e + f;\n }\n \n+// { dg-final { scan-assembler-times \"_ZGVbM4vulLUR4__Z2f2iiiRiS_S_:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVbN4vulLUR4__Z2f2iiiRiS_S_:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVcM4vulLUR4__Z2f2iiiRiS_S_:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVcN4vulLUR4__Z2f2iiiRiS_S_:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVdM8vulLUR4__Z2f2iiiRiS_S_:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVdN8vulLUR4__Z2f2iiiRiS_S_:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+\n #pragma omp declare simd uniform(b) linear(c, d) linear(uval(e)) linear(ref(f))\n int f3 (const int a, const int b, const int c, const int &d, const int &e, const int &f)\n {\n   return a + b + c + d + e + f;\n }\n \n+// { dg-final { scan-assembler-times \"_ZGVbM4vulLUR4__Z2f3iiiRKiS0_S0_:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVbN4vulLUR4__Z2f3iiiRKiS0_S0_:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVcM4vulLUR4__Z2f3iiiRKiS0_S0_:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVcN4vulLUR4__Z2f3iiiRKiS0_S0_:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVdM8vulLUR4__Z2f3iiiRKiS0_S0_:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVdN8vulLUR4__Z2f3iiiRKiS0_S0_:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+\n #pragma omp declare simd uniform(b) linear(c, d) linear(uval(e)) linear(ref(f))\n int f4 (const int a, const int b, const int c, const int &d, const int &e, const int &f)\n {\n@@ -47,3 +69,10 @@ int f4 (const int a, const int b, const int c, const int &d, const int &e, const\n   asm volatile (\"\" : : \"r\" (&f));\n   return a + b + c + d + e + f;\n }\n+\n+// { dg-final { scan-assembler-times \"_ZGVbM4vulLUR4__Z2f4iiiRKiS0_S0_:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVbN4vulLUR4__Z2f4iiiRKiS0_S0_:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVcM4vulLUR4__Z2f4iiiRKiS0_S0_:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVcN4vulLUR4__Z2f4iiiRKiS0_S0_:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVdM8vulLUR4__Z2f4iiiRKiS0_S0_:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVdN8vulLUR4__Z2f4iiiRKiS0_S0_:\" 1 { target { i?86-*-* x86_64-*-* } } } }"}, {"sha": "51382bffe27bb705497ce3fd0e22f16abc929031", "filename": "gcc/testsuite/g++.dg/gomp/declare-simd-4.C", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdeclare-simd-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdeclare-simd-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdeclare-simd-4.C?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,35 @@\n+#pragma omp declare simd linear(p:1) linear(q:-1) linear(s:-3)\n+int\n+f1 (int *p, int *q, short *s)\n+{\n+  return *p + *q + *s;\n+}\n+\n+// { dg-final { scan-assembler-times \"_ZGVbM4l4ln4ln6__Z2f1PiS_Ps:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVbN4l4ln4ln6__Z2f1PiS_Ps:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVcM4l4ln4ln6__Z2f1PiS_Ps:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVcN4l4ln4ln6__Z2f1PiS_Ps:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVdM8l4ln4ln6__Z2f1PiS_Ps:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVdN8l4ln4ln6__Z2f1PiS_Ps:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+\n+#pragma omp declare simd linear(p:s) linear(q:t) uniform (s) linear(r:s) notinbranch simdlen(8) uniform(t)\n+int\n+f2 (int *p, short *q, int s, int r, int &t)\n+{\n+  return *p + *q + r;\n+}\n+\n+// { dg-final { scan-assembler-times \"_ZGVbN8ls2ls4uls2u__Z2f2PiPsiiRi:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVcN8ls2ls4uls2u__Z2f2PiPsiiRi:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVdN8ls2ls4uls2u__Z2f2PiPsiiRi:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+\n+#pragma omp declare simd linear(ref(p):s) linear(val(q):t) uniform (s) linear(uval(r):s) notinbranch simdlen(8) uniform(t)\n+int\n+f3 (int &p, short &q, int s, int &r, int &t)\n+{\n+  return p + q + r;\n+}\n+\n+// { dg-final { scan-assembler-times \"_ZGVbN8Rs2Ls4uUs2u__Z2f3RiRsiS_S_:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVcN8Rs2Ls4uUs2u__Z2f3RiRsiS_S_:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVdN8Rs2Ls4uUs2u__Z2f3RiRsiS_S_:\" 1 { target { i?86-*-* x86_64-*-* } } } }"}, {"sha": "cfa1e527a7cc967c1b9c5eb7d8b60fbfef7e648c", "filename": "gcc/testsuite/g++.dg/gomp/declare-simd-5.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdeclare-simd-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdeclare-simd-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdeclare-simd-5.C?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,22 @@\n+// { dg-do compile }\n+// { dg-options \"-fopenmp-simd\" }\n+\n+#pragma omp declare simd linear(a:1 + b) uniform(b)\t// { dg-error \"use of parameter outside function body before .\\\\). token\" }\n+int f1 (int a, int b);\n+#pragma omp declare simd linear(a:b + 1) uniform(b)\t// { dg-error \"use of parameter outside function body before .\\\\+. token\" }\n+int f2 (int a, int b);\n+#pragma omp declare simd linear(a:2 * b) uniform(b)\t// { dg-error \"use of parameter outside function body before .\\\\). token\" }\n+int f3 (int a, int b);\n+#pragma omp declare simd linear(a:b)\t\t\t// { dg-error \".linear. clause step is a parameter .b. not specified in .uniform. clause\" }\n+int f4 (int a, int b);\n+#pragma omp declare simd linear(a:b) linear(b:1)\t// { dg-error \".linear. clause step is a parameter .b. not specified in .uniform. clause\" }\n+int f5 (int a, int b);\n+#pragma omp declare simd linear(a:5 + 2 * 3)\n+int f6 (int a, int b);\n+const int c = 5;\n+#pragma omp declare simd linear(a:c)\n+int f7 (int a, int b);\n+#pragma omp declare simd linear(a:2 * c + 1)\n+int f8 (int a, int b);\n+#pragma omp declare simd linear(a:0.5)\t\t\t// { dg-error \"linear step expression must be integral\" }\n+int f9 (int a, int b);"}, {"sha": "9cc32f421a7da483c8cfaae5146a2e8773954a20", "filename": "gcc/testsuite/g++.dg/gomp/declare-target-1.C", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdeclare-target-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdeclare-target-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdeclare-target-1.C?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,37 @@\n+// { dg-do compile }\n+// { dg-options \"-fopenmp\" }\n+\n+#pragma omp declare target\n+void f1 (int);\n+void f1 (double);\n+template <typename T>\n+void f2 (T);\n+template<> void f2<int> (int);\n+#pragma omp end declare target\n+void f3 (int);\n+void f4 (int);\n+void f4 (short);\n+template <typename T>\n+void f5 (T);\n+#pragma omp declare target (f3)\n+#pragma omp declare target to (f4)\t// { dg-error \"overloaded function name .f4. in clause .to.\" }\n+#pragma omp declare target to (f5<int>)\t// { dg-error \"template .f5<int>. in clause .to.\" }\n+template <int N>\n+void f6 (int)\n+{\n+  static int s;\n+  #pragma omp declare target (s)\n+}\n+namespace N\n+{\n+  namespace M\n+  {\n+    void f7 (int);\n+  }\n+  void f8 (long);\n+}\n+void f9 (short);\n+int v;\n+#pragma omp declare target (N::M::f7)\n+#pragma omp declare target to (::N::f8)\n+#pragma omp declare target to (::f9) to (::v)"}, {"sha": "acb85d1a3aacd0d56c006da2e8acb8c958622f5c", "filename": "gcc/testsuite/g++.dg/gomp/linear-2.C", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Flinear-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Flinear-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Flinear-2.C?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,128 @@\n+// { dg-do compile }\n+// { dg-options \"-fopenmp\" }\n+\n+#pragma omp declare target\n+\n+int i, j;\n+\n+void\n+f1 ()\n+{\n+  #pragma omp for linear (i:1)\t// { dg-error \"iteration variable .i. should not be linear\" }\n+  for (i = 0; i < 32; i++)\n+    ;\n+}\n+\n+void\n+f2 ()\n+{\n+  #pragma omp distribute parallel for linear (i:1)\t// { dg-error \".linear. is not valid for .#pragma omp distribute parallel for.\" }\n+  for (i = 0; i < 32; i++)\n+    ;\n+}\n+\n+void\n+f3 ()\n+{\n+  #pragma omp parallel for linear (i:1) collapse(1)\n+  for (i = 0; i < 32; i++)\t\t\t\t// { dg-error \"iteration variable .i. should not be linear\" }\n+    ;\n+}\n+\n+void\n+f4 ()\n+{\n+  #pragma omp for linear (i:1) linear (j:2) collapse(2)\t// { dg-error \"iteration variable .i. should not be linear\" }\n+  for (i = 0; i < 32; i++)\t\t\t\t// { dg-error \"iteration variable .j. should not be linear\" \"\" { target *-*-* } 35 }\n+    for (j = 0; j < 32; j+=2)\n+      ;\n+}\n+\n+void\n+f5 ()\n+{\n+  #pragma omp target teams distribute parallel for linear (i:1) linear (j:2) collapse(2)\t// { dg-error \".linear. is not valid for .#pragma omp target teams distribute parallel for.\" }\n+  for (i = 0; i < 32; i++)\n+    for (j = 0; j < 32; j+=2)\n+      ;\n+}\n+\n+void\n+f6 ()\n+{\n+  #pragma omp parallel for linear (i:1) collapse(2) linear (j:2)\t// { dg-error \"iteration variable .i. should not be linear\" \"\" { target *-*-* } 54 }\n+  for (i = 0; i < 32; i++)\t\t\t\t\t\t// { dg-error \"iteration variable .j. should not be linear\" }\n+    for (j = 0; j < 32; j+=2)\n+      ;\n+}\n+\n+template <int N>\n+void\n+f7 ()\n+{\n+  #pragma omp for linear (i:1)\t// { dg-error \"iteration variable .i. should not be linear\" }\n+  for (i = 0; i < 32; i++)\n+    ;\n+}\n+\n+template <int N>\n+void\n+f8 ()\n+{\n+  #pragma omp distribute parallel for linear (i:1)\t// { dg-error \".linear. is not valid for .#pragma omp distribute parallel for.\" }\n+  for (i = 0; i < 32; i++)\n+    ;\n+}\n+\n+template <int N>\n+void\n+f9 ()\n+{\n+  #pragma omp parallel for linear (i:1) collapse(1)\n+  for (i = 0; i < 32; i++)\t\t\t\t// { dg-error \"iteration variable .i. should not be linear\" }\n+    ;\n+}\n+\n+template <int N>\n+void\n+f10 ()\n+{\n+  #pragma omp for linear (i:1) linear (j:2) collapse(2)\t// { dg-error \"iteration variable .i. should not be linear\" }\n+  for (i = 0; i < 32; i++)\t\t\t\t// { dg-error \"iteration variable .j. should not be linear\" \"\" { target *-*-* } 90 }\n+    for (j = 0; j < 32; j+=2)\n+      ;\n+}\n+\n+template <int N>\n+void\n+f11 ()\n+{\n+  #pragma omp target teams distribute parallel for linear (i:1) linear (j:2) collapse(2)\t// { dg-error \".linear. is not valid for .#pragma omp target teams distribute parallel for.\" }\n+  for (i = 0; i < 32; i++)\n+    for (j = 0; j < 32; j+=2)\n+      ;\n+}\n+\n+template <int N>\n+void\n+f12 ()\n+{\n+  #pragma omp parallel for linear (i:1) collapse(2) linear (j:2)\t// { dg-error \"iteration variable .i. should not be linear\" \"\" { target *-*-* } 111 }\n+  for (i = 0; i < 32; i++)\t\t\t\t\t\t// { dg-error \"iteration variable .j. should not be linear\" }\n+    for (j = 0; j < 32; j+=2)\n+      ;\n+}\n+\n+#pragma omp end declare target\n+\n+void\n+f13 ()\n+{\n+  f7 <0> ();\n+  #pragma omp target teams\n+  f8 <1> ();\n+  f9 <2> ();\n+  f10 <3> ();\n+  f11 <4> ();\n+  f12 <5> ();\n+}"}, {"sha": "46e707fc4c95e41e44eba3d00cb4a746ba322780", "filename": "gcc/testsuite/g++.dg/gomp/loop-1.C", "status": "added", "additions": 283, "deletions": 0, "changes": 283, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Floop-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Floop-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Floop-1.C?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,283 @@\n+int bar (int);\n+int baz (int *);\n+\n+void\n+f1 (int x)\n+{\n+  int i = 0, j = 0;\n+  #pragma omp for\n+  for (i = 0; i < 16; i++)\n+    ;\n+  #pragma omp for\n+  for (i = 0; 16 > i; i++)\n+    ;\n+  #pragma omp for\n+  for (i = 0; i < 16; i = i + 2)\n+    ;\n+  #pragma omp for\n+  for (i = 0; i < 16; i = 2 + i)\n+    ;\n+  #pragma omp for\n+  for (i = i; i < 16; i++) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (i = 2 * (i & x); i < 16; i++) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (i = bar (i); i < 16; i++) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (i = baz (&i); i < 16; i++) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (i = 5; i < 2 * i + 17; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (i = 5; 2 * i + 17 > i; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (i = 5; bar (i) > i; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (i = 5; i <= baz (&i); i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (i = 5; i <= i; i++) /* { dg-error \"invalid controlling predicate|condition expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (i = 5; i < 16; i += i) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (i = 5; i < 16; i = i + 2 * i) /* { dg-error \"invalid increment expression|increment expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (i = 5; i < 16; i = i + i) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (i = 5; i < 16; i = i + bar (i)) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (i = 5; i < 16; i = baz (&i) + i) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (i = 5; i < 16; i += bar (i)) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (i = 5; i < 16; i += baz (&i)) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < 16; i = i + 2)\n+    for (j = 0; j < 16; j += 2)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = j; i < 16; i = i + 2) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+    for (j = 0; j < 16; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < 16; i = i + 2) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+    for (j = i; j < 16; j += 2)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < 16; i = i + 2)\n+    for (j = i + 3; j < 16; j += 2) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < 16; i++) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+    for (j = baz (&i); j < 16; j += 2)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < 16; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    for (j = 16; j > (i & x); j--)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < 16; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    for (j = 0; j < i; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < 16; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    for (j = 0; j < i + 4; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < j + 4; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    for (j = 0; j < 16; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < j; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    for (j = 0; j < 16; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < bar (j); i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    for (j = 0; j < 16; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < 16; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    for (j = 0; j < baz (&i); j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < 16; i += j) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    for (j = 0; j < 16; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < 16; i++) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    for (j = 0; j < 16; j += i)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < 16; i = j + i) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    for (j = 0; j < 16; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < 16; i++) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    for (j = 0; j < 16; j = j + i)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < 16; i = bar (j) + i) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    for (j = 0; j < 16; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < 16; i++)\n+    for (j = 0; j < 16; j = j + baz (&i)) /* { dg-error \"increment expression refers to iteration variable\" } */\n+      ;\n+}\n+\n+void\n+f2 (int x)\n+{\n+  #pragma omp for\n+  for (int i = 0; i < 16; i++)\n+    ;\n+  #pragma omp for\n+  for (int i = 0; 16 > i; i++)\n+    ;\n+  #pragma omp for\n+  for (int i = 0; i < 16; i = i + 2)\n+    ;\n+  #pragma omp for\n+  for (int i = 0; i < 16; i = 2 + i)\n+    ;\n+  #pragma omp for\n+  for (int i = i; i < 16; i++) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (int i = 2 * (i & x); i < 16; i++) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (int i = bar (i); i < 16; i++) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (int i = baz (&i); i < 16; i++) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (int i = 5; i < 2 * i + 17; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (int i = 5; 2 * i + 17 > i; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (int i = 5; bar (i) > i; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (int i = 5; i <= baz (&i); i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (int i = 5; i <= i; i++) /* { dg-error \"invalid controlling predicate|condition expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (int i = 5; i < 16; i += i) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (int i = 5; i < 16; i = i + 2 * i) /* { dg-error \"invalid increment expression|increment expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (int i = 5; i < 16; i = i + i) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (int i = 5; i < 16; i = i + bar (i)) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (int i = 5; i < 16; i = baz (&i) + i) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (int i = 5; i < 16; i += bar (i)) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (int i = 5; i < 16; i += baz (&i)) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for collapse(2)\n+  for (int i = 0; i < 16; i = i + 2)\n+    for (int j = 0; j < 16; j += 2)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (int i = 0; i < 16; i = i + 2) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+    for (int j = i; j < 16; j += 2)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (int i = 0; i < 16; i = i + 2)\n+    for (int j = i + 3; j < 16; j += 2) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+      ;\n+  #pragma omp for collapse(2)\n+  for (int i = 0; i < 16; i++) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+    for (int j = baz (&i); j < 16; j += 2)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (int i = 0; i < 16; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    for (int j = 16; j > (i & x); j--)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (int i = 0; i < 16; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    for (int j = 0; j < i; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (int i = 0; i < 16; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    for (int j = 0; j < i + 4; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (int i = 0; i < 16; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    for (int j = 0; j < baz (&i); j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (int i = 0; i < 16; i++) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    for (int j = 0; j < 16; j += i)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (int i = 0; i < 16; i++) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    for (int j = 0; j < 16; j = j + i)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (int i = 0; i < 16; i++)\n+    for (int j = 0; j < 16; j = j + baz (&i)) /* { dg-error \"increment expression refers to iteration variable\" } */\n+      ;\n+}\n+\n+void\n+f3 (void)\n+{\n+  int j = 0;\n+  #pragma omp for collapse(2)\n+  for (int i = j; i < 16; i = i + 2)\n+    for (int j = 0; j < 16; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (int i = 0; i < j + 4; i++)\n+    for (int j = 0; j < 16; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (int i = 0; i < j; i++)\n+    for (int j = 0; j < 16; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (int i = 0; i < bar (j); i++)\n+    for (int j = 0; j < 16; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (int i = 0; i < 16; i += j)\n+    for (int j = 0; j < 16; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (int i = 0; i < 16; i = j + i)\n+    for (int j = 0; j < 16; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (int i = 0; i < 16; i = bar (j) + i)\n+    for (int j = 0; j < 16; j++)\n+      ;\n+}"}, {"sha": "f05a8cbdd4a34bbe38c6ac8c1e4a53e2e6155f48", "filename": "gcc/testsuite/g++.dg/gomp/loop-2.C", "status": "added", "additions": 294, "deletions": 0, "changes": 294, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Floop-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Floop-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Floop-2.C?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,294 @@\n+int bar (int);\n+int baz (int *);\n+\n+template <int N>\n+void\n+f1 (int x)\n+{\n+  int i = 0, j = 0;\n+  #pragma omp for\n+  for (i = 0; i < 16; i++)\n+    ;\n+  #pragma omp for\n+  for (i = 0; 16 > i; i++)\n+    ;\n+  #pragma omp for\n+  for (i = 0; i < 16; i = i + 2)\n+    ;\n+  #pragma omp for\n+  for (i = 0; i < 16; i = 2 + i)\n+    ;\n+  #pragma omp for\n+  for (i = i; i < 16; i++) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (i = 2 * (i & x); i < 16; i++) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (i = bar (i); i < 16; i++) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (i = baz (&i); i < 16; i++) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (i = 5; i < 2 * i + 17; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (i = 5; 2 * i + 17 > i; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (i = 5; bar (i) > i; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (i = 5; i <= baz (&i); i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (i = 5; i <= i; i++) /* { dg-error \"invalid controlling predicate|condition expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (i = 5; i < 16; i += i) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (i = 5; i < 16; i = i + 2 * i) /* { dg-error \"invalid increment expression|increment expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (i = 5; i < 16; i = i + i) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (i = 5; i < 16; i = i + bar (i)) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (i = 5; i < 16; i = baz (&i) + i) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (i = 5; i < 16; i += bar (i)) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (i = 5; i < 16; i += baz (&i)) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < 16; i = i + 2)\n+    for (j = 0; j < 16; j += 2)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = j; i < 16; i = i + 2) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+    for (j = 0; j < 16; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < 16; i = i + 2) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+    for (j = i; j < 16; j += 2)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < 16; i = i + 2)\n+    for (j = i + 3; j < 16; j += 2) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < 16; i++)\n+    for (j = baz (&i); j < 16; j += 2) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < 16; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    for (j = 16; j > (i & x); j--)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < 16; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    for (j = 0; j < i; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < 16; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    for (j = 0; j < i + 4; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < j + 4; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    for (j = 0; j < 16; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < j; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    for (j = 0; j < 16; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < bar (j); i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    for (j = 0; j < 16; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < 16; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    for (j = 0; j < baz (&i); j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < 16; i += j) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    for (j = 0; j < 16; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < 16; i++) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    for (j = 0; j < 16; j += i)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < 16; i = j + i) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    for (j = 0; j < 16; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < 16; i++) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    for (j = 0; j < 16; j = j + i)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < 16; i = bar (j) + i) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    for (j = 0; j < 16; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < 16; i++)\n+    for (j = 0; j < 16; j = j + baz (&i)) /* { dg-error \"increment expression refers to iteration variable\" } */\n+      ;\n+}\n+\n+template <int N>\n+void\n+f2 (int x)\n+{\n+  #pragma omp for\n+  for (int i = 0; i < 16; i++)\n+    ;\n+  #pragma omp for\n+  for (int i = 0; 16 > i; i++)\n+    ;\n+  #pragma omp for\n+  for (int i = 0; i < 16; i = i + 2)\n+    ;\n+  #pragma omp for\n+  for (int i = 0; i < 16; i = 2 + i)\n+    ;\n+  #pragma omp for\n+  for (int i = i; i < 16; i++) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (int i = 2 * (i & x); i < 16; i++) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (int i = bar (i); i < 16; i++) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (int i = baz (&i); i < 16; i++) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (int i = 5; i < 2 * i + 17; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (int i = 5; 2 * i + 17 > i; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (int i = 5; bar (i) > i; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (int i = 5; i <= baz (&i); i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (int i = 5; i <= i; i++) /* { dg-error \"invalid controlling predicate|condition expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (int i = 5; i < 16; i += i) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (int i = 5; i < 16; i = i + 2 * i) /* { dg-error \"invalid increment expression|increment expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (int i = 5; i < 16; i = i + i) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (int i = 5; i < 16; i = i + bar (i)) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (int i = 5; i < 16; i = baz (&i) + i) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (int i = 5; i < 16; i += bar (i)) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (int i = 5; i < 16; i += baz (&i)) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for collapse(2)\n+  for (int i = 0; i < 16; i = i + 2)\n+    for (int j = 0; j < 16; j += 2)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (int i = 0; i < 16; i = i + 2) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+    for (int j = i; j < 16; j += 2)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (int i = 0; i < 16; i = i + 2)\n+    for (int j = i + 3; j < 16; j += 2) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+      ;\n+  #pragma omp for collapse(2)\n+  for (int i = 0; i < 16; i++)\n+    for (int j = baz (&i); j < 16; j += 2) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+      ;\n+  #pragma omp for collapse(2)\n+  for (int i = 0; i < 16; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    for (int j = 16; j > (i & x); j--)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (int i = 0; i < 16; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    for (int j = 0; j < i; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (int i = 0; i < 16; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    for (int j = 0; j < i + 4; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (int i = 0; i < 16; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    for (int j = 0; j < baz (&i); j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (int i = 0; i < 16; i++) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    for (int j = 0; j < 16; j += i)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (int i = 0; i < 16; i++) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    for (int j = 0; j < 16; j = j + i)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (int i = 0; i < 16; i++)\n+    for (int j = 0; j < 16; j = j + baz (&i)) /* { dg-error \"increment expression refers to iteration variable\" } */\n+      ;\n+}\n+\n+template <int N>\n+void\n+f3 ()\n+{\n+  int j = 0;\n+  #pragma omp for collapse(2)\n+  for (int i = j; i < 16; i = i + 2)\n+    for (int j = 0; j < 16; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (int i = 0; i < j + 4; i++)\n+    for (int j = 0; j < 16; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (int i = 0; i < j; i++)\n+    for (int j = 0; j < 16; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (int i = 0; i < bar (j); i++)\n+    for (int j = 0; j < 16; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (int i = 0; i < 16; i += j)\n+    for (int j = 0; j < 16; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (int i = 0; i < 16; i = j + i)\n+    for (int j = 0; j < 16; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (int i = 0; i < 16; i = bar (j) + i)\n+    for (int j = 0; j < 16; j++)\n+      ;\n+}\n+\n+void\n+foo ()\n+{\n+  f1 <0> (0);\n+  f2 <0> (0);\n+  f3 <0> ();\n+}"}, {"sha": "3806e1f4e0478e9aa023f1ef7497dfde8f2587d3", "filename": "gcc/testsuite/g++.dg/gomp/loop-3.C", "status": "added", "additions": 306, "deletions": 0, "changes": 306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Floop-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Floop-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Floop-3.C?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,306 @@\n+typedef __PTRDIFF_TYPE__ ptrdiff_t;\n+\n+template <typename T>\n+class I\n+{\n+public:\n+  typedef ptrdiff_t difference_type;\n+  I ();\n+  ~I ();\n+  I (T *);\n+  I (const I &);\n+  T &operator * ();\n+  T *operator -> ();\n+  T &operator [] (const difference_type &) const;\n+  I &operator = (const I &);\n+  I &operator ++ ();\n+  I operator ++ (int);\n+  I &operator -- ();\n+  I operator -- (int);\n+  I &operator += (const difference_type &);\n+  I &operator -= (const difference_type &);\n+  I operator + (const difference_type &) const;\n+  I operator - (const difference_type &) const;\n+  template <typename S> friend bool operator == (I<S> &, I<S> &);\n+  template <typename S> friend bool operator == (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator < (I<S> &, I<S> &);\n+  template <typename S> friend bool operator < (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator <= (I<S> &, I<S> &);\n+  template <typename S> friend bool operator <= (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator > (I<S> &, I<S> &);\n+  template <typename S> friend bool operator > (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator >= (I<S> &, I<S> &);\n+  template <typename S> friend bool operator >= (const I<S> &, const I<S> &);\n+  template <typename S> friend typename I<S>::difference_type operator - (I<S> &, I<S> &);\n+  template <typename S> friend typename I<S>::difference_type operator - (const I<S> &, const I<S> &);\n+  template <typename S> friend I<S> operator + (typename I<S>::difference_type , const I<S> &);\n+private:\n+  T *p;\n+};\n+\n+template <typename T> bool operator == (I<T> &, I<T> &);\n+template <typename T> bool operator == (const I<T> &, const I<T> &);\n+template <typename T> bool operator != (I<T> &, I<T> &);\n+template <typename T> bool operator != (const I<T> &, const I<T> &);\n+template <typename T> bool operator < (I<T> &, I<T> &);\n+template <typename T> bool operator < (const I<T> &, const I<T> &);\n+template <typename T> bool operator <= (I<T> &, I<T> &);\n+template <typename T> bool operator <= (const I<T> &, const I<T> &);\n+template <typename T> bool operator > (I<T> &, I<T> &);\n+template <typename T> bool operator > (const I<T> &, const I<T> &);\n+template <typename T> bool operator >= (I<T> &, I<T> &);\n+template <typename T> bool operator >= (const I<T> &, const I<T> &);\n+template <typename T> typename I<T>::difference_type operator - (I<T> &, I<T> &);\n+template <typename T> typename I<T>::difference_type operator - (const I<T> &, const I<T> &);\n+template <typename T> I<T> operator + (typename I<T>::difference_type, const I<T> &);\n+\n+ptrdiff_t foo (I<int> &);\n+I<int> &bar (I<int> &);\n+I<int> &baz (I<int> *);\n+\n+void\n+f1 (I<int> &x, I<int> &y, I<int> &u, I<int> &v)\n+{\n+  I<int> i, j;\n+  #pragma omp for\n+  for (i = x; i < y; i++)\n+    ;\n+  #pragma omp for\n+  for (i = x; y > i; i++)\n+    ;\n+  #pragma omp for\n+  for (i = x; i < y; i = i + 2)\n+    ;\n+  #pragma omp for\n+  for (i = x; i < y; i = 2 + i)\n+    ;\n+  #pragma omp for\n+  for (i = i; i < y; i++) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (i = i + 3; i < y; i++) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (i = bar (i); i < y; i++) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (i = baz (&i); i < y; i++) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (i = x; i <= i + 5; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (i = x; i <= baz (&i); i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (i = x; baz (&i) > i; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (i = x; i <= i; i++) /* { dg-error \"invalid controlling predicate|condition expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (i = x; i < y; i += foo (i)) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (i = x; i < y; i = i + foo (i)) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (i = x; i < y; i = foo (i) + i) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for collapse(2)\n+  for (i = x; i < y; i = i + 2)\n+    for (j = u; j < y; j += 2)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = j; i < y; i = i + 2) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+    for (j = x; j < y; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = x; i < y; i = i + 2) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+    for (j = i; j < v; j += 2)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = x; i < y; i = i + 2)\n+    for (j = i + 3; j < v; j += 2) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = x; i < y; i++)\n+    for (j = baz (&i); j < v; j += 2) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = x; i < y; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    for (j = v; j > i; j--)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = x; i < y; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    for (j = x; j < i; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = x; i < y; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    for (j = u; j < i + 4; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = x; i < j + 4; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    for (j = u; j < v; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = x; i < j; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    for (j = u; j < v; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = x; i < bar (j); i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    for (j = u; j < v; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = x; i < y; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    for (j = u; j < baz (&i); j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = x; i < y; i += foo (j)) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    for (j = u; j < v; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = x; i < y; i++)\n+    for (j = u; j < v; j += foo (i)) /* { dg-error \"increment expression refers to iteration variable\" } */\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = x; i < y; i = foo (j) + i) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    for (j = u; j < v; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = x; i < y; i++)\n+    for (j = u; j < y; j = j + (i - v)) /* { dg-error \"increment expression refers to iteration variable\" } */\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = x; i < y; i = foo (j) + i) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    for (j = u; j < v; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = x; i < y; i++)\n+    for (j = u; j < v; j = j + foo (i)) /* { dg-error \"increment expression refers to iteration variable\" } */\n+      ;\n+}\n+\n+void\n+f2 (I<int> &x, I<int> &y, I<int> &u, I<int> &v)\n+{\n+  #pragma omp for\n+  for (I<int> i = x; i < y; i++)\n+    ;\n+  #pragma omp for\n+  for (I<int> i = x; y > i; i++)\n+    ;\n+  #pragma omp for\n+  for (I<int> i = x; i < y; i = i + 2)\n+    ;\n+  #pragma omp for\n+  for (I<int> i = x; i < y; i = 2 + i)\n+    ;\n+  #pragma omp for\n+  for (I<int> i = i; i < y; i++) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (I<int> i = i + 3; i < y; i++) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (I<int> i = bar (i); i < y; i++) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (I<int> i = baz (&i); i < y; i++) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (I<int> i = x; i <= i + 5; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (I<int> i = x; i <= baz (&i); i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (I<int> i = x; baz (&i) > i; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (I<int> i = x; i <= i; i++) /* { dg-error \"invalid controlling predicate|condition expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (I<int> i = x; i < y; i += foo (i)) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (I<int> i = x; i < y; i = i + foo (i)) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (I<int> i = x; i < y; i = foo (i) + i) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for collapse(2)\n+  for (I<int> i = x; i < y; i = i + 2)\n+    for (I<int> j = u; j < y; j += 2)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (I<int> i = x; i < y; i = i + 2) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+    for (I<int> j = i; j < v; j += 2)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (I<int> i = x; i < y; i = i + 2)\n+    for (I<int> j = i + 3; j < v; j += 2) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+      ;\n+  #pragma omp for collapse(2)\n+  for (I<int> i = x; i < y; i++)\n+    for (I<int> j = baz (&i); j < v; j += 2) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+      ;\n+  #pragma omp for collapse(2)\n+  for (I<int> i = x; i < y; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    for (I<int> j = v; j > i; j--)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (I<int> i = x; i < y; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    for (I<int> j = x; j < i; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (I<int> i = x; i < y; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    for (I<int> j = u; j < i + 4; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (I<int> i = x; i < y; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    for (I<int> j = u; j < baz (&i); j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (I<int> i = x; i < y; i++)\n+    for (I<int> j = u; j < v; j += foo (i)) /* { dg-error \"increment expression refers to iteration variable\" } */\n+      ;\n+  #pragma omp for collapse(2)\n+  for (I<int> i = x; i < y; i++)\n+    for (I<int> j = u; j < y; j = j + (i - v)) /* { dg-error \"increment expression refers to iteration variable\" } */\n+      ;\n+  #pragma omp for collapse(2)\n+  for (I<int> i = x; i < y; i++)\n+    for (I<int> j = u; j < v; j = j + foo (i)) /* { dg-error \"increment expression refers to iteration variable\" } */\n+      ;\n+}\n+\n+void\n+f3 (I<int> &x, I<int> &y, I<int> &u, I<int> &v)\n+{\n+  I<int> j;\n+  #pragma omp for collapse(2)\n+  for (I<int> i = j; i < y; i = i + 2)\n+    for (I<int> j = x; j < y; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (I<int> i = x; i < j + 4; i++)\n+    for (I<int> j = u; j < v; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (I<int> i = x; i < j; i++)\n+    for (I<int> j = u; j < v; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (I<int> i = x; i < bar (j); i++)\n+    for (I<int> j = u; j < v; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (I<int> i = x; i < y; i += foo (j))\n+    for (I<int> j = u; j < v; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (I<int> i = x; i < y; i = foo (j) + i)\n+    for (I<int> j = u; j < v; j++)\n+      ;\n+}"}, {"sha": "c51fa2063b2d4bbca0476fa5ab79b32303ae8678", "filename": "gcc/testsuite/g++.dg/gomp/member-2.C", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fmember-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fmember-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fmember-2.C?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -76,19 +76,19 @@ B::m2 ()\n   #pragma omp parallel for reduction (+:g)\t// { dg-error \"has const type for .reduction.\" }\n     for (int i = 0; i < 10; i++)\n       ;\n-  #pragma omp parallel shared (a)\t// { dg-error \"is not a variable in clause\" }\n+  #pragma omp parallel shared (a)\n     ;\n-  #pragma omp parallel shared (b)\t// { dg-error \"is not a variable in clause\" }\n+  #pragma omp parallel shared (b)\n     ;\n-  #pragma omp parallel shared (c)\t// { dg-error \"is not a variable in clause\" }\n+  #pragma omp parallel shared (c)\n     ;\n-  #pragma omp parallel shared (e)\t// { dg-error \"is not a variable in clause\" }\n+  #pragma omp parallel shared (e)\n     ;\n-  #pragma omp parallel shared (f)\t// { dg-error \"is not a variable in clause\" }\n+  #pragma omp parallel shared (f)\n     ;\n-  #pragma omp parallel shared (g)\t// { dg-error \"is not a variable in clause\" }\n+  #pragma omp parallel shared (g)\n     ;\n-  #pragma omp parallel shared (h)\t// { dg-error \"is not a variable in clause\" }\n+  #pragma omp parallel shared (h)\t// { dg-error \"is predetermined .shared. for .shared.\" }\n     ;\n   return 0;\n }\n@@ -150,19 +150,19 @@ B::m4 () const\n   #pragma omp parallel for reduction (+:g)\t// { dg-error \"has const type for .reduction.\" }\n     for (int i = 0; i < 10; i++)\n       ;\n-  #pragma omp parallel shared (a)\t// { dg-error \"is not a variable in clause\" }\n+  #pragma omp parallel shared (a)\t// { dg-error \"is predetermined .shared. for .shared.\" }\n     ;\n-  #pragma omp parallel shared (b)\t// { dg-error \"is not a variable in clause\" }\n+  #pragma omp parallel shared (b)\n     ;\n-  #pragma omp parallel shared (c)\t// { dg-error \"is not a variable in clause\" }\n+  #pragma omp parallel shared (c)\n     ;\n-  #pragma omp parallel shared (e)\t// { dg-error \"is not a variable in clause\" }\n+  #pragma omp parallel shared (e)\n     ;\n-  #pragma omp parallel shared (f)\t// { dg-error \"is not a variable in clause\" }\n+  #pragma omp parallel shared (f)\n     ;\n-  #pragma omp parallel shared (g)\t// { dg-error \"is not a variable in clause\" }\n+  #pragma omp parallel shared (g)\n     ;\n-  #pragma omp parallel shared (h)\t// { dg-error \"is not a variable in clause\" }\n+  #pragma omp parallel shared (h)\t// { dg-error \"is predetermined .shared. for .shared.\" }\n     ;\n   return 0;\n }"}, {"sha": "fef437161640eda30465e3db7f2bb5686c64fa04", "filename": "gcc/testsuite/g++.dg/gomp/member-3.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fmember-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fmember-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fmember-3.C?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,17 @@\n+// { dg-do compile }\n+// { dg-options \"-fopenmp\" }\n+\n+struct S { int a; void foo (S *); static S &bar (); };\n+\n+void\n+S::foo (S *x)\n+{\n+  S &b = bar ();\n+  S c;\n+  #pragma omp parallel private (b.a)\t// { dg-error \"expected .\\\\). before .\\\\.. token\" }\n+  ;\n+  #pragma omp parallel private (c.a)\t// { dg-error \"expected .\\\\). before .\\\\.. token\" }\n+  ;\n+  #pragma omp parallel private (x->a)\t// { dg-error \"expected .\\\\). before .->. token\" }\n+  ;\n+}"}, {"sha": "07b98db7214675df379fc915b19037dca1af2e46", "filename": "gcc/testsuite/g++.dg/gomp/member-4.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fmember-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fmember-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fmember-4.C?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,22 @@\n+// { dg-do compile }\n+\n+class C { int a; char b; void foo (); };\n+\n+void\n+C::foo ()\n+{\n+  #pragma omp parallel shared (a, a)\t// { dg-error \"appears more than once in data clauses\" }\n+  ;\n+  #pragma omp parallel shared (a) private (b) shared(C::a)\t// { dg-error \"appears more than once in data clauses\" }\n+  ;\n+  #pragma omp task private (a) private (b)\n+  ;\n+  #pragma omp task firstprivate (a) shared (C::a)\t// { dg-error \"appears more than once in data clauses\" }\n+  ;\n+  #pragma omp parallel for lastprivate (b) firstprivate (a) lastprivate (b)\t// { dg-error \"appears more than once in data clauses\" }\n+  for (int i = 0; i < 64; i++)\n+    ;\n+  #pragma omp parallel for lastprivate (b) firstprivate (b)\n+  for (int i = 0; i < 64; i++)\n+    ;\n+}"}, {"sha": "abc4c69420ee06d196e2db1f2d0b4372c2968ade", "filename": "gcc/testsuite/g++.dg/gomp/pr38639.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr38639.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr38639.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr38639.C?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -6,12 +6,12 @@ template<int> void\n foo ()\n {\n #pragma omp parallel for\n-  for (auto i = i = 0; i<4; ++i)\t// { dg-error \"incomplete|unable|invalid|auto\" }\n+  for (auto i = i = 0; i<4; ++i)\t// { dg-error \"initializer expression refers to iteration variable\" }\n     ;\n }\n \n void\n bar ()\n {\n-  foo<0> ();\t\t\t\t// { dg-message \"required from here\" }\n+  foo<0> ();\n }"}, {"sha": "0a97de0ec30e9c836341156eeeab3c3ddd2bf415", "filename": "gcc/testsuite/g++.dg/gomp/target-teams-1.C", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-teams-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-teams-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-teams-1.C?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,92 @@\n+// { dg-do compile }\n+// { dg-options \"-fopenmp -fdump-tree-gimple\" }\n+\n+int v = 6;\n+void bar (int);\n+void bar2 (int, long *, long *);\n+int baz (void);\n+#pragma omp declare target to (bar, baz, v)\n+\n+template <int N>\n+void\n+foo (int a, int b, long c, long d)\n+{\n+  /* The OpenMP 4.5 spec says that these expressions are evaluated before\n+     target region on combined target teams, so those cases are always\n+     fine.  */\n+  #pragma omp target\n+  bar (0);\n+  #pragma omp target\n+  #pragma omp teams\n+  bar (1);\n+  #pragma omp target teams\n+  bar (2);\n+  #pragma omp target\n+  #pragma omp teams num_teams (4)\n+  bar (3);\n+  #pragma omp target teams num_teams (4)\n+  bar (4);\n+  #pragma omp target\n+  #pragma omp teams thread_limit (7)\n+  bar (5);\n+  #pragma omp target teams thread_limit (7)\n+  bar (6);\n+  #pragma omp target\n+  #pragma omp teams num_teams (4) thread_limit (8)\n+  {\n+    {\n+      bar (7);\n+    }\n+  }\n+  #pragma omp target teams num_teams (4) thread_limit (8)\n+  bar (8);\n+  #pragma omp target\n+  #pragma omp teams num_teams (a) thread_limit (b)\n+  bar (9);\n+  #pragma omp target teams num_teams (a) thread_limit (b)\n+  bar (10);\n+  #pragma omp target\n+  #pragma omp teams num_teams (c + 1) thread_limit (d - 1)\n+  bar (11);\n+  #pragma omp target teams num_teams (c + 1) thread_limit (d - 1)\n+  bar (12);\n+  #pragma omp target map (always, to: c, d)\n+  #pragma omp teams num_teams (c + 1) thread_limit (d - 1)\n+  bar (13);\n+  #pragma omp target data map (to: c, d)\n+  {\n+    #pragma omp target defaultmap (tofrom: scalar)\n+    bar2 (14, &c, &d);\n+    /* This is one of the cases which can't be generally optimized,\n+       the c and d are (or could be) already mapped and whether\n+       their device and original values match is unclear.  */\n+    #pragma omp target map (to: c, d)\n+    #pragma omp teams num_teams (c + 1) thread_limit (d - 1)\n+    bar (15);\n+  }\n+  /* This can't be optimized, there are function calls inside of\n+     target involved.  */\n+  #pragma omp target\n+  #pragma omp teams num_teams (baz () + 1) thread_limit (baz () - 1)\n+  bar (16);\n+  #pragma omp target teams num_teams (baz () + 1) thread_limit (baz () - 1)\n+  bar (17);\n+  /* This one can't be optimized, as v might have different value between\n+     host and target.  */\n+  #pragma omp target\n+  #pragma omp teams num_teams (v + 1) thread_limit (v - 1)\n+  bar (18);\n+}\n+\n+void\n+foo (int a, int b, long c, long d)\n+{\n+  foo<0> (a, b, c, d);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"num_teams\\\\(-1\\\\)\" 3 \"gimple\" } } */\n+/* { dg-final { scan-tree-dump-times \"thread_limit\\\\(-1\\\\)\" 3 \"gimple\" } } */\n+/* { dg-final { scan-tree-dump-times \"num_teams\\\\(0\\\\)\" 4 \"gimple\" } } */\n+/* { dg-final { scan-tree-dump-times \"thread_limit\\\\(0\\\\)\" 6 \"gimple\" } } */\n+/* { dg-final { scan-tree-dump-times \"num_teams\\\\(1\\\\)\" 2 \"gimple\" } } */\n+/* { dg-final { scan-tree-dump-times \"thread_limit\\\\(1\\\\)\" 0 \"gimple\" } } */"}, {"sha": "027b24a5b60cfd56edd783d5eddea2ef39426934", "filename": "gcc/testsuite/gcc.dg/gomp/declare-simd-1.c", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fdeclare-simd-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fdeclare-simd-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fdeclare-simd-1.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -13,6 +13,13 @@ int f2 (int a, int *b, int c)\n   return a + *b + c;\n }\n \n+/* { dg-final { scan-assembler-times \"_ZGVbM8uva32l4_f2:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVbN8uva32l4_f2:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVcM8uva32l4_f2:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVcN8uva32l4_f2:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVdM8uva32l4_f2:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVdN8uva32l4_f2:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n+\n #pragma omp declare simd uniform (a) aligned (b : 8 * sizeof (long long)) linear (c : 4) simdlen (8)\n __extension__\n long long f3 (long long a, long long *b, long long c);\n@@ -40,6 +47,13 @@ f7 (int x)\n   return x;\n }\n \n+/* { dg-final { scan-assembler-times \"_ZGVbM16v_f7:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVbN16v_f7:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVcM16v_f7:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVcN16v_f7:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVdM16v_f7:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVdN16v_f7:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n+\n int\n f9 (int x)\n {\n@@ -62,6 +76,13 @@ f13 (int c; int *b; int a; int a, int *b, int c)\n   return a + *b + c;\n }\n \n+/* { dg-final { scan-assembler-times \"_ZGVbM8uva32l4_f13:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVbN8uva32l4_f13:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVcM8uva32l4_f13:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVcN8uva32l4_f13:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVdM8uva32l4_f13:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVdN8uva32l4_f13:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n+\n #pragma omp declare simd uniform (a) aligned (b : 8 * sizeof (int)) linear (c : 4) simdlen (8)\n int\n f14 (a, b, c)\n@@ -71,13 +92,27 @@ f14 (a, b, c)\n   return a + *b + c;\n }\n \n+/* { dg-final { scan-assembler-times \"_ZGVbM8uva32l4_f14:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVbN8uva32l4_f14:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVcM8uva32l4_f14:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVcN8uva32l4_f14:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVdM8uva32l4_f14:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVdN8uva32l4_f14:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n+\n #pragma omp declare simd uniform (a) aligned (b : 8 * sizeof (int)) linear (c : 4) simdlen (8)\n int\n f15 (int a, int *b, int c)\n {\n   return a + *b + c;\n }\n \n+/* { dg-final { scan-assembler-times \"_ZGVbM8uva32l4_f15:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVbN8uva32l4_f15:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVcM8uva32l4_f15:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVcN8uva32l4_f15:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVdM8uva32l4_f15:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVdN8uva32l4_f15:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n+\n #pragma omp declare simd uniform (d) aligned (e : 8 * sizeof (int)) linear (f : 4) simdlen (8)\n int f15 (int d, int *e, int f);\n \n@@ -90,6 +125,19 @@ int f17 (int g, long *h)\n   return g + h[0];\n }\n \n+/* { dg-final { scan-assembler-times \"_ZGVbM4l20va8_f17:\" 1 { target { { i?86-*-* x86_64-*-* } && lp64 } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVbN4l20va8_f17:\" 1 { target { { i?86-*-* x86_64-*-* } && lp64 } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVcM4l20va8_f17:\" 1 { target { { i?86-*-* x86_64-*-* } && lp64 } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVcN4l20va8_f17:\" 1 { target { { i?86-*-* x86_64-*-* } && lp64 } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVdM4l20va8_f17:\" 1 { target { { i?86-*-* x86_64-*-* } && lp64 } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVdN4l20va8_f17:\" 1 { target { { i?86-*-* x86_64-*-* } && lp64 } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVbM4l12va4_f17:\" 1 { target { { i?86-*-* x86_64-*-* } && ilp32 } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVbN4l12va4_f17:\" 1 { target { { i?86-*-* x86_64-*-* } && ilp32 } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVcM4l12va4_f17:\" 1 { target { { i?86-*-* x86_64-*-* } && ilp32 } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVcN4l12va4_f17:\" 1 { target { { i?86-*-* x86_64-*-* } && ilp32 } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVdM4l12va4_f17:\" 1 { target { { i?86-*-* x86_64-*-* } && ilp32 } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVdN4l12va4_f17:\" 1 { target { { i?86-*-* x86_64-*-* } && ilp32 } } } } */\n+\n #pragma omp declare simd aligned (i : sizeof (*i)) linear (j : 2 * sizeof (i[0]) + sizeof (j)) simdlen (4)\n int\n f18 (j, i)\n@@ -98,3 +146,16 @@ f18 (j, i)\n {\n   return j + i[0];\n }\n+\n+/* { dg-final { scan-assembler-times \"_ZGVbM4l20va8_f18:\" 1 { target { { i?86-*-* x86_64-*-* } && lp64 } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVbN4l20va8_f18:\" 1 { target { { i?86-*-* x86_64-*-* } && lp64 } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVcM4l20va8_f18:\" 1 { target { { i?86-*-* x86_64-*-* } && lp64 } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVcN4l20va8_f18:\" 1 { target { { i?86-*-* x86_64-*-* } && lp64 } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVdM4l20va8_f18:\" 1 { target { { i?86-*-* x86_64-*-* } && lp64 } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVdN4l20va8_f18:\" 1 { target { { i?86-*-* x86_64-*-* } && lp64 } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVbM4l12va4_f18:\" 1 { target { { i?86-*-* x86_64-*-* } && ilp32 } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVbN4l12va4_f18:\" 1 { target { { i?86-*-* x86_64-*-* } && ilp32 } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVcM4l12va4_f18:\" 1 { target { { i?86-*-* x86_64-*-* } && ilp32 } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVcN4l12va4_f18:\" 1 { target { { i?86-*-* x86_64-*-* } && ilp32 } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVdM4l12va4_f18:\" 1 { target { { i?86-*-* x86_64-*-* } && ilp32 } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVdN4l12va4_f18:\" 1 { target { { i?86-*-* x86_64-*-* } && ilp32 } } } } */"}, {"sha": "51f08be4f1b27be39af3078c47f2340b289d1cf9", "filename": "gcc/testsuite/gcc.dg/gomp/declare-simd-3.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fdeclare-simd-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fdeclare-simd-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fdeclare-simd-3.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,24 @@\n+#pragma omp declare simd linear(p:1) linear(val(q):-1) linear(s:-3)\n+int\n+f1 (int *p, int *q, short *s)\n+{\n+  return *p + *q + *s;\n+}\n+\n+/* { dg-final { scan-assembler-times \"_ZGVbM4l4ln4ln6_f1:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVbN4l4ln4ln6_f1:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVcM4l4ln4ln6_f1:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVcN4l4ln4ln6_f1:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVdM8l4ln4ln6_f1:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVdN8l4ln4ln6_f1:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n+\n+#pragma omp declare simd linear(p:s) linear(q:t) uniform (s) linear(r:s) notinbranch simdlen(8) uniform(t)\n+int\n+f2 (int *p, short *q, int s, int r, int t)\n+{\n+  return *p + *q + r;\n+}\n+\n+/* { dg-final { scan-assembler-times \"_ZGVbN8ls2ls4uls2u_f2:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVcN8ls2ls4uls2u_f2:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVdN8ls2ls4uls2u_f2:\" 1 { target { i?86-*-* x86_64-*-* } } } } */"}, {"sha": "1c60e02cee361fd2f12693c56d73d3cf64e89926", "filename": "gcc/testsuite/gcc.dg/gomp/declare-simd-4.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fdeclare-simd-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fdeclare-simd-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fdeclare-simd-4.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp-simd\" } */\n+\n+#pragma omp declare simd linear(a:1 + b) uniform(b)\t/* { dg-error \".linear. clause step .b \\\\+ 1. is neither constant nor a parameter\" } */\n+int f1 (int a, int b);\n+#pragma omp declare simd linear(a:b + 1) uniform(b)\t/* { dg-error \".linear. clause step .b \\\\+ 1. is neither constant nor a parameter\" } */\n+int f2 (int a, int b);\n+#pragma omp declare simd linear(a:2 * b) uniform(b)\t/* { dg-error \".linear. clause step .b \\\\* 2. is neither constant nor a parameter\" } */\n+int f3 (int a, int b);\n+#pragma omp declare simd linear(a:b)\t\t\t/* { dg-error \".linear. clause step is a parameter .b. not specified in .uniform. clause\" } */\n+int f4 (int a, int b);\n+#pragma omp declare simd linear(a:b) linear(b:1)\t/* { dg-error \".linear. clause step is a parameter .b. not specified in .uniform. clause\" } */\n+int f5 (int a, int b);\n+#pragma omp declare simd linear(a:5 + 2 * 3)\n+int f6 (int a, int b);\n+const int c = 5;\n+#pragma omp declare simd linear(a:c)\t\t\t/* { dg-error \".linear. clause step .c. is neither constant nor a parameter\" } */\n+int f7 (int a, int b);\n+#pragma omp declare simd linear(a:2 * c + 1)\t\t/* { dg-error \".linear. clause step .\\[^\\n\\r]*. is neither constant nor a parameter\" } */\n+int f8 (int a, int b);\n+#pragma omp declare simd linear(a:0.5)\t\t\t/* { dg-error \".linear. clause step expression must be integral\" } */\n+int f9 (int a, int b);"}, {"sha": "90a8f1e31ede33a7d7b12e00c19cf0df9d6b20b6", "filename": "gcc/testsuite/gcc.dg/gomp/for-20.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-20.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-ompexp\" } */\n+\n+extern void bar(int);\n+\n+void foo (int n)\n+{\n+  int i;\n+\n+  #pragma omp for schedule(nonmonotonic:guided)\n+  for (i = 0; i < n; ++i)\n+    bar(i);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_nonmonotonic_guided_start\" 1 \"ompexp\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_nonmonotonic_guided_next\" 1 \"ompexp\" } } */"}, {"sha": "17ce0177cc7bdaf5a019e4b9662daa65f1e6e9ac", "filename": "gcc/testsuite/gcc.dg/gomp/for-21.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-21.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-21.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-21.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-ompexp\" } */\n+\n+extern void bar(int);\n+\n+void foo (int n)\n+{\n+  int i;\n+\n+  #pragma omp for schedule(nonmonotonic:dynamic, 2)\n+  for (i = 0; i < n; ++i)\n+    bar(i);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_nonmonotonic_dynamic_start\" 1 \"ompexp\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_nonmonotonic_dynamic_next\" 1 \"ompexp\" } } */"}, {"sha": "090e0f191a6f271927f5c5e25cd781d63f6522b6", "filename": "gcc/testsuite/gcc.dg/gomp/for-22.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-22.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-22.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-22.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-ompexp\" } */\n+\n+extern void bar(unsigned long long);\n+\n+void foo (unsigned long long n)\n+{\n+  unsigned long long i;\n+\n+  #pragma omp for schedule(nonmonotonic:guided, 7)\n+  for (i = 0; i < n; ++i)\n+    bar(i);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_ull_nonmonotonic_guided_start\" 1 \"ompexp\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_ull_nonmonotonic_guided_next\" 1 \"ompexp\" } } */"}, {"sha": "6bb6efb0fdfd64ee9d6652fea720400b8c84fd1f", "filename": "gcc/testsuite/gcc.dg/gomp/for-23.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-23.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-23.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-23.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-ompexp\" } */\n+\n+extern void bar(unsigned long long);\n+\n+void foo (unsigned long long n)\n+{\n+  unsigned long long i;\n+\n+  #pragma omp for schedule (nonmonotonic : dynamic)\n+  for (i = 0; i < n; ++i)\n+    bar(i);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_ull_nonmonotonic_dynamic_start\" 1 \"ompexp\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_ull_nonmonotonic_dynamic_next\" 1 \"ompexp\" } } */"}, {"sha": "d04d82a6c008b5922d0748a5c04a27950c33d7a3", "filename": "gcc/testsuite/gcc.dg/gomp/for-24.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-24.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-24.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-24.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fopenmp -fdump-tree-ssa\" } */\n+\n+extern void bar(int);\n+\n+void foo (void)\n+{\n+  int i;\n+\n+  #pragma omp parallel for schedule (nonmonotonic : dynamic, 4)\n+  for (i = 0; i < 37; ++i)\n+    bar(i);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"GOMP_parallel_loop_nonmonotonic_dynamic\" 1 \"ssa\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_nonmonotonic_dynamic_start\" 0 \"ssa\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_nonmonotonic_dynamic_next\" 2 \"ssa\" } } */"}, {"sha": "cf294c2fc1879d3004ae66b85cc41790aca7bea4", "filename": "gcc/testsuite/gcc.dg/gomp/linear-1.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Flinear-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Flinear-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Flinear-1.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,57 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+\n+int i, j;\n+\n+void\n+f1 (void)\n+{\n+  #pragma omp for linear (i:1)\t/* { dg-error \"iteration variable .i. should not be linear\" } */\n+  for (i = 0; i < 32; i++)\n+    ;\n+}\n+\n+void\n+f2 (void)\n+{\n+  #pragma omp distribute parallel for linear (i:1)\t/* { dg-error \".linear. is not valid for .#pragma omp distribute parallel for.\" } */\n+  for (i = 0; i < 32; i++)\n+    ;\n+}\n+\n+void\n+f3 (void)\n+{\n+  #pragma omp parallel for linear (i:1) collapse(1)\t/* { dg-error \"iteration variable .i. should not be linear\" } */\n+  for (i = 0; i < 32; i++)\n+    ;\n+}\n+\n+void\n+f4 (void)\n+{\n+  #pragma omp for linear (i:1) linear (j:2) collapse(2)\t/* { dg-error \"iteration variable .i. should not be linear\" } */\n+  for (i = 0; i < 32; i++)\t\t\t\t/* { dg-error \"iteration variable .j. should not be linear\" \"\" { target *-*-* } 33 } */\n+    for (j = 0; j < 32; j+=2)\n+      ;\n+}\n+\n+void\n+f5 (void)\n+{\n+  #pragma omp target teams distribute parallel for linear (i:1) linear (j:2) collapse(2)\t/* { dg-error \".linear. is not valid for .#pragma omp target teams distribute parallel for.\" } */\n+  for (i = 0; i < 32; i++)\n+    for (j = 0; j < 32; j+=2)\n+      ;\n+}\n+\n+void\n+f6 (void)\n+{\n+  #pragma omp parallel for linear (i:1) collapse(2) linear (j:2)\t/* { dg-error \"iteration variable .i. should not be linear\" } */\n+  for (i = 0; i < 32; i++)\t\t\t\t\t\t/* { dg-error \"iteration variable .j. should not be linear\" \"\" { target *-*-* } 51 } */\n+    for (j = 0; j < 32; j+=2)\n+      ;\n+}\n+\n+#pragma omp declare target to (i, j, f2)"}, {"sha": "450a1ed9bea84867c9f2133bdae4445c7ea442e3", "filename": "gcc/testsuite/gcc.dg/gomp/loop-1.c", "status": "added", "additions": 283, "deletions": 0, "changes": 283, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Floop-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Floop-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Floop-1.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,283 @@\n+int bar (int);\n+int baz (int *);\n+\n+void\n+f1 (int x)\n+{\n+  int i = 0, j = 0;\n+  #pragma omp for\n+  for (i = 0; i < 16; i++)\n+    ;\n+  #pragma omp for\n+  for (i = 0; 16 > i; i++)\n+    ;\n+  #pragma omp for\n+  for (i = 0; i < 16; i = i + 2)\n+    ;\n+  #pragma omp for\n+  for (i = 0; i < 16; i = 2 + i)\n+    ;\n+  #pragma omp for /* { dg-error \"initializer expression refers to iteration variable\" } */\n+  for (i = i; i < 16; i++)\n+    ;\n+  #pragma omp for\n+  for (i = 2 * (i & x); i < 16; i++) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (i = bar (i); i < 16; i++) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (i = baz (&i); i < 16; i++) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (i = 5; i < 2 * i + 17; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (i = 5; 2 * i + 17 > i; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (i = 5; bar (i) > i; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (i = 5; i <= baz (&i); i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (i = 5; i <= i; i++) /* { dg-error \"invalid controlling predicate|condition expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for /* { dg-error \"increment expression refers to iteration variable\" } */\n+  for (i = 5; i < 16; i += i)\n+    ;\n+  #pragma omp for\n+  for (i = 5; i < 16; i = i + 2 * i) /* { dg-error \"invalid increment expression|increment expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for /* { dg-error \"increment expression refers to iteration variable\" } */\n+  for (i = 5; i < 16; i = i + i)\n+    ;\n+  #pragma omp for\n+  for (i = 5; i < 16; i = i + bar (i)) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (i = 5; i < 16; i = baz (&i) + i) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (i = 5; i < 16; i += bar (i)) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (i = 5; i < 16; i += baz (&i)) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < 16; i = i + 2)\n+    for (j = 0; j < 16; j += 2)\n+      ;\n+  #pragma omp for collapse(2) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+  for (i = j; i < 16; i = i + 2)\n+    for (j = 0; j < 16; j++)\n+      ;\n+  #pragma omp for collapse(2) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+  for (i = 0; i < 16; i = i + 2)\n+    for (j = i; j < 16; j += 2)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < 16; i = i + 2)\n+    for (j = i + 3; j < 16; j += 2) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < 16; i++)\n+    for (j = baz (&i); j < 16; j += 2) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < 16; i++)\n+    for (j = 16; j > (i & x); j--) /* { dg-error \"condition expression refers to iteration variable\" } */\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < 16; i++)\n+    for (j = 0; j < i; j++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < 16; i++)\n+    for (j = 0; j < i + 4; j++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < j + 4; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    for (j = 0; j < 16; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < j; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    for (j = 0; j < 16; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < bar (j); i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    for (j = 0; j < 16; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < 16; i++)\n+    for (j = 0; j < baz (&i); j++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+      ;\n+  #pragma omp for collapse(2) /* { dg-error \"increment expression refers to iteration variable\" } */\n+  for (i = 0; i < 16; i += j)\n+    for (j = 0; j < 16; j++)\n+      ;\n+  #pragma omp for collapse(2) /* { dg-error \"increment expression refers to iteration variable\" } */\n+  for (i = 0; i < 16; i++)\n+    for (j = 0; j < 16; j += i)\n+      ;\n+  #pragma omp for collapse(2) /* { dg-error \"increment expression refers to iteration variable\" } */\n+  for (i = 0; i < 16; i = j + i)\n+    for (j = 0; j < 16; j++)\n+      ;\n+  #pragma omp for collapse(2) /* { dg-error \"increment expression refers to iteration variable\" } */\n+  for (i = 0; i < 16; i++)\n+    for (j = 0; j < 16; j = j + i)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < 16; i = bar (j) + i) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    for (j = 0; j < 16; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < 16; i++)\n+    for (j = 0; j < 16; j = j + baz (&i)) /* { dg-error \"increment expression refers to iteration variable\" } */\n+      ;\n+}\n+\n+void\n+f2 (int x)\n+{\n+  #pragma omp for\n+  for (int i = 0; i < 16; i++)\n+    ;\n+  #pragma omp for\n+  for (int i = 0; 16 > i; i++)\n+    ;\n+  #pragma omp for\n+  for (int i = 0; i < 16; i = i + 2)\n+    ;\n+  #pragma omp for\n+  for (int i = 0; i < 16; i = 2 + i)\n+    ;\n+  #pragma omp for /* { dg-error \"initializer expression refers to iteration variable\" } */\n+  for (int i = i; i < 16; i++)\n+    ;\n+  #pragma omp for\n+  for (int i = 2 * (i & x); i < 16; i++) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (int i = bar (i); i < 16; i++) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (int i = baz (&i); i < 16; i++) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (int i = 5; i < 2 * i + 17; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (int i = 5; 2 * i + 17 > i; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (int i = 5; bar (i) > i; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (int i = 5; i <= baz (&i); i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (int i = 5; i <= i; i++) /* { dg-error \"invalid controlling predicate|condition expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for /* { dg-error \"increment expression refers to iteration variable\" } */\n+  for (int i = 5; i < 16; i += i)\n+    ;\n+  #pragma omp for\n+  for (int i = 5; i < 16; i = i + 2 * i) /* { dg-error \"invalid increment expression|increment expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for /* { dg-error \"increment expression refers to iteration variable\" } */\n+  for (int i = 5; i < 16; i = i + i)\n+    ;\n+  #pragma omp for\n+  for (int i = 5; i < 16; i = i + bar (i)) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (int i = 5; i < 16; i = baz (&i) + i) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (int i = 5; i < 16; i += bar (i)) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for\n+  for (int i = 5; i < 16; i += baz (&i)) /* { dg-error \"increment expression refers to iteration variable\" } */\n+    ;\n+  #pragma omp for collapse(2)\n+  for (int i = 0; i < 16; i = i + 2)\n+    for (int j = 0; j < 16; j += 2)\n+      ;\n+  #pragma omp for collapse(2) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+  for (int i = 0; i < 16; i = i + 2)\n+    for (int j = i; j < 16; j += 2)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (int i = 0; i < 16; i = i + 2)\n+    for (int j = i + 3; j < 16; j += 2) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+      ;\n+  #pragma omp for collapse(2)\n+  for (int i = 0; i < 16; i++)\n+    for (int j = baz (&i); j < 16; j += 2) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+      ;\n+  #pragma omp for collapse(2)\n+  for (int i = 0; i < 16; i++)\n+    for (int j = 16; j > (i & x); j--) /* { dg-error \"condition expression refers to iteration variable\" } */\n+      ;\n+  #pragma omp for collapse(2)\n+  for (int i = 0; i < 16; i++)\n+    for (int j = 0; j < i; j++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+      ;\n+  #pragma omp for collapse(2)\n+  for (int i = 0; i < 16; i++)\n+    for (int j = 0; j < i + 4; j++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+      ;\n+  #pragma omp for collapse(2)\n+  for (int i = 0; i < 16; i++)\n+    for (int j = 0; j < baz (&i); j++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+      ;\n+  #pragma omp for collapse(2) /* { dg-error \"increment expression refers to iteration variable\" } */\n+  for (int i = 0; i < 16; i++)\n+    for (int j = 0; j < 16; j += i)\n+      ;\n+  #pragma omp for collapse(2) /* { dg-error \"increment expression refers to iteration variable\" } */\n+  for (int i = 0; i < 16; i++)\n+    for (int j = 0; j < 16; j = j + i)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (int i = 0; i < 16; i++)\n+    for (int j = 0; j < 16; j = j + baz (&i)) /* { dg-error \"increment expression refers to iteration variable\" } */\n+      ;\n+}\n+\n+void\n+f3 (void)\n+{\n+  int j = 0;\n+  #pragma omp for collapse(2)\n+  for (int i = j; i < 16; i = i + 2)\n+    for (int j = 0; j < 16; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (int i = 0; i < j + 4; i++)\n+    for (int j = 0; j < 16; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (int i = 0; i < j; i++)\n+    for (int j = 0; j < 16; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (int i = 0; i < bar (j); i++)\n+    for (int j = 0; j < 16; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (int i = 0; i < 16; i += j)\n+    for (int j = 0; j < 16; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (int i = 0; i < 16; i = j + i)\n+    for (int j = 0; j < 16; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (int i = 0; i < 16; i = bar (j) + i)\n+    for (int j = 0; j < 16; j++)\n+      ;\n+}"}, {"sha": "d913e510b7d443f516c6e8f845fe5c139a233b93", "filename": "gcc/tree-core.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -450,7 +450,10 @@ enum omp_clause_schedule_kind {\n   OMP_CLAUSE_SCHEDULE_AUTO,\n   OMP_CLAUSE_SCHEDULE_RUNTIME,\n   OMP_CLAUSE_SCHEDULE_CILKFOR,\n-  OMP_CLAUSE_SCHEDULE_LAST\n+  OMP_CLAUSE_SCHEDULE_MASK = (1 << 3) - 1,\n+  OMP_CLAUSE_SCHEDULE_MONOTONIC = (1 << 3),\n+  OMP_CLAUSE_SCHEDULE_NONMONOTONIC = (1 << 4),\n+  OMP_CLAUSE_SCHEDULE_LAST = 2 * OMP_CLAUSE_SCHEDULE_NONMONOTONIC - 1\n };\n \n enum omp_clause_default_kind {"}, {"sha": "efae4c0dd5bce6cdd1083d7c3b44b7c4aa87ce49", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 38, "deletions": 11, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -432,9 +432,24 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, int flags)\n \n     case OMP_CLAUSE_SCHEDULE:\n       pp_string (pp, \"schedule(\");\n+      if (OMP_CLAUSE_SCHEDULE_KIND (clause)\n+\t  & (OMP_CLAUSE_SCHEDULE_MONOTONIC\n+\t     | OMP_CLAUSE_SCHEDULE_NONMONOTONIC))\n+\t{\n+\t  if (OMP_CLAUSE_SCHEDULE_KIND (clause)\n+\t      & OMP_CLAUSE_SCHEDULE_MONOTONIC)\n+\t    pp_string (pp, \"monotonic\");\n+\t  else\n+\t    pp_string (pp, \"nonmonotonic\");\n+\t  if (OMP_CLAUSE_SCHEDULE_SIMD (clause))\n+\t    pp_comma (pp);\n+\t  else\n+\t    pp_colon (pp);\n+\t}\n       if (OMP_CLAUSE_SCHEDULE_SIMD (clause))\n \tpp_string (pp, \"simd:\");\n-      switch (OMP_CLAUSE_SCHEDULE_KIND (clause))\n+\n+      switch (OMP_CLAUSE_SCHEDULE_KIND (clause) & OMP_CLAUSE_SCHEDULE_MASK)\n \t{\n \tcase OMP_CLAUSE_SCHEDULE_STATIC:\n \t  pp_string (pp, \"static\");\n@@ -630,9 +645,15 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, int flags)\n \tcase GOMP_MAP_FIRSTPRIVATE_POINTER:\n \t  pp_string (pp, \"firstprivate\");\n \t  break;\n+\tcase GOMP_MAP_FIRSTPRIVATE_REFERENCE:\n+\t  pp_string (pp, \"firstprivate ref\");\n+\t  break;\n \tcase GOMP_MAP_STRUCT:\n \t  pp_string (pp, \"struct\");\n \t  break;\n+\tcase GOMP_MAP_ALWAYS_POINTER:\n+\t  pp_string (pp, \"always_pointer\");\n+\t  break;\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -642,16 +663,22 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, int flags)\n      print_clause_size:\n       if (OMP_CLAUSE_SIZE (clause))\n \t{\n-\t  if (OMP_CLAUSE_CODE (clause) == OMP_CLAUSE_MAP\n-\t      && (OMP_CLAUSE_MAP_KIND (clause) == GOMP_MAP_POINTER\n-\t\t  || OMP_CLAUSE_MAP_KIND (clause)\n-\t\t     == GOMP_MAP_FIRSTPRIVATE_POINTER))\n-\t    pp_string (pp, \" [pointer assign, bias: \");\n-\t  else if (OMP_CLAUSE_CODE (clause) == OMP_CLAUSE_MAP\n-\t\t   && OMP_CLAUSE_MAP_KIND (clause) == GOMP_MAP_TO_PSET)\n-\t    pp_string (pp, \" [pointer set, len: \");\n-\t  else\n-\t    pp_string (pp, \" [len: \");\n+\t  switch (OMP_CLAUSE_CODE (clause) == OMP_CLAUSE_MAP\n+\t\t  ? OMP_CLAUSE_MAP_KIND (clause) : GOMP_MAP_TO)\n+\t    {\n+\t    case GOMP_MAP_POINTER:\n+\t    case GOMP_MAP_FIRSTPRIVATE_POINTER:\n+\t    case GOMP_MAP_FIRSTPRIVATE_REFERENCE:\n+\t    case GOMP_MAP_ALWAYS_POINTER:\n+\t      pp_string (pp, \" [pointer assign, bias: \");\n+\t      break;\n+\t    case GOMP_MAP_TO_PSET:\n+\t      pp_string (pp, \" [pointer set, len: \");\n+\t      break;\n+\t    default:\n+\t      pp_string (pp, \" [len: \");\n+\t      break;\n+\t    }\n \t  dump_generic_node (pp, OMP_CLAUSE_SIZE (clause),\n \t\t\t     spc, flags, false);\n \t  pp_right_bracket (pp);"}, {"sha": "378973bb8c565f08f3cc788e37ae5a76e86c44fb", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -2826,6 +2826,9 @@ vectorizable_simd_clone_call (gimple *stmt, gimple_stmt_iterator *gsi,\n \t      case SIMD_CLONE_ARG_TYPE_LINEAR_VARIABLE_STEP:\n \t      case SIMD_CLONE_ARG_TYPE_LINEAR_VAL_CONSTANT_STEP:\n \t      case SIMD_CLONE_ARG_TYPE_LINEAR_UVAL_CONSTANT_STEP:\n+\t      case SIMD_CLONE_ARG_TYPE_LINEAR_REF_VARIABLE_STEP:\n+\t      case SIMD_CLONE_ARG_TYPE_LINEAR_VAL_VARIABLE_STEP:\n+\t      case SIMD_CLONE_ARG_TYPE_LINEAR_UVAL_VARIABLE_STEP:\n \t\t/* FORNOW */\n \t\ti = -1;\n \t\tbreak;\n@@ -3098,6 +3101,9 @@ vectorizable_simd_clone_call (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t}\n \t      break;\n \t    case SIMD_CLONE_ARG_TYPE_LINEAR_VARIABLE_STEP:\n+\t    case SIMD_CLONE_ARG_TYPE_LINEAR_REF_VARIABLE_STEP:\n+\t    case SIMD_CLONE_ARG_TYPE_LINEAR_VAL_VARIABLE_STEP:\n+\t    case SIMD_CLONE_ARG_TYPE_LINEAR_UVAL_VARIABLE_STEP:\n \t    default:\n \t      gcc_unreachable ();\n \t    }"}, {"sha": "41064a8e657200c1431466ddb5d19bc8b7c35db7", "filename": "gcc/tree.def", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -1109,28 +1109,28 @@ DEFTREECODE (OMP_TASK, \"omp_task\", tcc_statement, 2)\n DEFTREECODE (OMP_FOR, \"omp_for\", tcc_statement, 7)\n \n /* OpenMP - #pragma omp simd [clause1 ... clauseN]\n-   Operands like operands 1-6 of OMP_FOR.  */\n-DEFTREECODE (OMP_SIMD, \"omp_simd\", tcc_statement, 6)\n+   Operands like for OMP_FOR.  */\n+DEFTREECODE (OMP_SIMD, \"omp_simd\", tcc_statement, 7)\n \n /* Cilk Plus - #pragma simd [clause1 ... clauseN]\n-   Operands like operands 1-6 of OMP_FOR.  */\n-DEFTREECODE (CILK_SIMD, \"cilk_simd\", tcc_statement, 6)\n+   Operands like for OMP_FOR.  */\n+DEFTREECODE (CILK_SIMD, \"cilk_simd\", tcc_statement, 7)\n \n /* Cilk Plus - _Cilk_for (..)\n-   Operands like operands 1-6 of OMP_FOR.  */\n-DEFTREECODE (CILK_FOR, \"cilk_for\", tcc_statement, 6)\n+   Operands like for OMP_FOR.  */\n+DEFTREECODE (CILK_FOR, \"cilk_for\", tcc_statement, 7)\n \n /* OpenMP - #pragma omp distribute [clause1 ... clauseN]\n-   Operands like operands 1-6 of OMP_FOR.  */\n-DEFTREECODE (OMP_DISTRIBUTE, \"omp_distribute\", tcc_statement, 6)\n+   Operands like for OMP_FOR.  */\n+DEFTREECODE (OMP_DISTRIBUTE, \"omp_distribute\", tcc_statement, 7)\n \n /* OpenMP - #pragma omp taskloop [clause1 ... clauseN]\n-   Operands like operands 1-6 of OMP_FOR.  */\n-DEFTREECODE (OMP_TASKLOOP, \"omp_taskloop\", tcc_statement, 6)\n+   Operands like for OMP_FOR.  */\n+DEFTREECODE (OMP_TASKLOOP, \"omp_taskloop\", tcc_statement, 7)\n \n /* OpenMP - #pragma acc loop [clause1 ... clauseN]\n-   Operands like operands 1-6 of OMP_FOR.  */\n-DEFTREECODE (OACC_LOOP, \"oacc_loop\", tcc_statement, 6)\n+   Operands like for OMP_FOR.  */\n+DEFTREECODE (OACC_LOOP, \"oacc_loop\", tcc_statement, 7)\n \n /* OpenMP - #pragma omp teams [clause1 ... clauseN]\n    Operand 0: OMP_TEAMS_BODY: Teams body."}, {"sha": "dc592d492e2f12a5c66aec5c37d413233c5ab859", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -1259,8 +1259,7 @@ extern void protected_set_expr_location (tree, location_t);\n #define OMP_FOR_COND(NODE)\t   TREE_OPERAND (OMP_LOOP_CHECK (NODE), 3)\n #define OMP_FOR_INCR(NODE)\t   TREE_OPERAND (OMP_LOOP_CHECK (NODE), 4)\n #define OMP_FOR_PRE_BODY(NODE)\t   TREE_OPERAND (OMP_LOOP_CHECK (NODE), 5)\n-/* Note that this is only available for OMP_FOR, hence OMP_FOR_CHECK.  */\n-#define OMP_FOR_ORIG_DECLS(NODE)   TREE_OPERAND (OMP_FOR_CHECK (NODE), 6)\n+#define OMP_FOR_ORIG_DECLS(NODE)   TREE_OPERAND (OMP_LOOP_CHECK (NODE), 6)\n \n #define OMP_SECTIONS_BODY(NODE)    TREE_OPERAND (OMP_SECTIONS_CHECK (NODE), 0)\n #define OMP_SECTIONS_CLAUSES(NODE) TREE_OPERAND (OMP_SECTIONS_CHECK (NODE), 1)\n@@ -1452,10 +1451,6 @@ extern void protected_set_expr_location (tree, location_t);\n    OMP_CLAUSE_MAP with GOMP_MAP_POINTER are marked with this flag.  */\n #define OMP_CLAUSE_MAP_ZERO_BIAS_ARRAY_SECTION(NODE) \\\n   (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_MAP)->base.public_flag)\n-/* Nonzero if the same decl appears both in OMP_CLAUSE_MAP and either\n-   OMP_CLAUSE_PRIVATE or OMP_CLAUSE_FIRSTPRIVATE.  */\n-#define OMP_CLAUSE_MAP_PRIVATE(NODE) \\\n-  TREE_PRIVATE (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_MAP))\n /* Nonzero if this is a mapped array section, that might need special\n    treatment if OMP_CLAUSE_SIZE is zero.  */\n #define OMP_CLAUSE_MAP_MAYBE_ZERO_LENGTH_ARRAY_SECTION(NODE) \\"}, {"sha": "136041cd24443c29131bf6dcb7ed7bd10b214304", "filename": "include/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -1,3 +1,15 @@\n+2015-11-05  Jakub Jelinek  <jakub@redhat.com>\n+\t    Ilya Verbin  <ilya.verbin@intel.com>\n+\n+\t* gomp-constants.h (GOMP_MAP_FLAG_SPECIAL_2): Define.\n+\t(GOMP_MAP_FLAG_ALWAYS): Remove.\n+\t(enum gomp_map_kind): Use GOMP_MAP_FLAG_SPECIAL_2 instead of\n+\tGOMP_MAP_FLAG_ALWAYS for GOMP_MAP_ALWAYS_TO, GOMP_MAP_ALWAYS_FROM,\n+\tGOMP_MAP_ALWAYS_TOFROM, GOMP_MAP_STRUCT, GOMP_MAP_RELEASE.\n+\tAdd GOMP_MAP_ALWAYS_POINTER and GOMP_MAP_FIRSTPRIVATE_REFERENCE.\n+\t(GOMP_MAP_ALWAYS_P): Define.\n+\t(GOMP_TARGET_FLAG_NOWAIT): Adjust comment.\n+\n 2015-10-27  Daniel Jacobowitz  <dan@codesourcery.com>\n \t    Joseph Myers  <joseph@codesourcery.com>\n \t    Mark Shinwell  <shinwell@codesourcery.com>"}, {"sha": "7671dd75fada132be7acb80a98981dffd07bb558", "filename": "include/gomp-constants.h", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/include%2Fgomp-constants.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/include%2Fgomp-constants.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fgomp-constants.h?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -39,10 +39,9 @@\n /* Special map kinds, enumerated starting here.  */\n #define GOMP_MAP_FLAG_SPECIAL_0\t\t(1 << 2)\n #define GOMP_MAP_FLAG_SPECIAL_1\t\t(1 << 3)\n+#define GOMP_MAP_FLAG_SPECIAL_2\t\t(1 << 4)\n #define GOMP_MAP_FLAG_SPECIAL\t\t(GOMP_MAP_FLAG_SPECIAL_1 \\\n \t\t\t\t\t | GOMP_MAP_FLAG_SPECIAL_0)\n-/* OpenMP always flag.  */\n-#define GOMP_MAP_FLAG_ALWAYS\t\t(1 << 6)\n /* Flag to force a specific behavior (or else, trigger a run-time error).  */\n #define GOMP_MAP_FLAG_FORCE\t\t(1 << 7)\n \n@@ -95,34 +94,43 @@ enum gomp_map_kind\n     GOMP_MAP_FORCE_TOFROM =\t\t(GOMP_MAP_FLAG_FORCE | GOMP_MAP_TOFROM),\n     /* If not already present, allocate.  And unconditionally copy to\n        device.  */\n-    GOMP_MAP_ALWAYS_TO =\t\t(GOMP_MAP_FLAG_ALWAYS | GOMP_MAP_TO),\n+    GOMP_MAP_ALWAYS_TO =\t\t(GOMP_MAP_FLAG_SPECIAL_2 | GOMP_MAP_TO),\n     /* If not already present, allocate.  And unconditionally copy from\n        device.  */\n-    GOMP_MAP_ALWAYS_FROM =\t\t(GOMP_MAP_FLAG_ALWAYS | GOMP_MAP_FROM),\n+    GOMP_MAP_ALWAYS_FROM =\t\t(GOMP_MAP_FLAG_SPECIAL_2\n+\t\t\t\t\t | GOMP_MAP_FROM),\n     /* If not already present, allocate.  And unconditionally copy to and from\n        device.  */\n-    GOMP_MAP_ALWAYS_TOFROM =\t\t(GOMP_MAP_FLAG_ALWAYS | GOMP_MAP_TOFROM),\n+    GOMP_MAP_ALWAYS_TOFROM =\t\t(GOMP_MAP_FLAG_SPECIAL_2\n+\t\t\t\t\t | GOMP_MAP_TOFROM),\n     /* Map a sparse struct; the address is the base of the structure, alignment\n        it's required alignment, and size is the number of adjacent entries\n        that belong to the struct.  The adjacent entries should be sorted by\n        increasing address, so it is easy to determine lowest needed address\n        (address of the first adjacent entry) and highest needed address\n        (address of the last adjacent entry plus its size).  */\n-    GOMP_MAP_STRUCT =\t\t\t(GOMP_MAP_FLAG_ALWAYS\n+    GOMP_MAP_STRUCT =\t\t\t(GOMP_MAP_FLAG_SPECIAL_2\n \t\t\t\t\t | GOMP_MAP_FLAG_SPECIAL | 0),\n+    /* On a location of a pointer/reference that is assumed to be already mapped\n+       earlier, store the translated address of the preceeding mapping.\n+       No refcount is bumped by this, and the store is done unconditionally.  */\n+    GOMP_MAP_ALWAYS_POINTER =\t\t(GOMP_MAP_FLAG_SPECIAL_2\n+\t\t\t\t\t | GOMP_MAP_FLAG_SPECIAL | 1),\n     /* Forced deallocation of zero length array section.  */\n     GOMP_MAP_DELETE_ZERO_LEN_ARRAY_SECTION\n-      =\t\t\t\t\t(GOMP_MAP_FLAG_ALWAYS\n+      =\t\t\t\t\t(GOMP_MAP_FLAG_SPECIAL_2\n \t\t\t\t\t | GOMP_MAP_FLAG_SPECIAL | 3),\n-    /* OpenMP 4.1 alias for forced deallocation.  */\n+    /* OpenMP 4.5 alias for forced deallocation.  */\n     GOMP_MAP_DELETE =\t\t\tGOMP_MAP_FORCE_DEALLOC,\n     /* Decrement usage count and deallocate if zero.  */\n-    GOMP_MAP_RELEASE =\t\t\t(GOMP_MAP_FLAG_ALWAYS\n+    GOMP_MAP_RELEASE =\t\t\t(GOMP_MAP_FLAG_SPECIAL_2\n \t\t\t\t\t | GOMP_MAP_FORCE_DEALLOC),\n \n     /* Internal to GCC, not used in libgomp.  */\n     /* Do not map, but pointer assign a pointer instead.  */\n-    GOMP_MAP_FIRSTPRIVATE_POINTER =\t(GOMP_MAP_LAST | 1)\n+    GOMP_MAP_FIRSTPRIVATE_POINTER =\t(GOMP_MAP_LAST | 1),\n+    /* Do not map, but pointer assign a reference instead.  */\n+    GOMP_MAP_FIRSTPRIVATE_REFERENCE =\t(GOMP_MAP_LAST | 2)\n   };\n \n #define GOMP_MAP_COPY_TO_P(X) \\\n@@ -142,6 +150,9 @@ enum gomp_map_kind\n #define GOMP_MAP_ALWAYS_FROM_P(X) \\\n   (((X) == GOMP_MAP_ALWAYS_FROM) || ((X) == GOMP_MAP_ALWAYS_TOFROM))\n \n+#define GOMP_MAP_ALWAYS_P(X) \\\n+  (GOMP_MAP_ALWAYS_TO_P (X) || ((X) == GOMP_MAP_ALWAYS_FROM))\n+\n \n /* Asynchronous behavior.  Keep in sync with\n    libgomp/{openacc.h,openacc.f90,openacc_lib.h}:acc_async_t.  */\n@@ -175,7 +186,7 @@ enum gomp_map_kind\n #define GOMP_TASK_FLAG_IF\t\t(1 << 10)\n #define GOMP_TASK_FLAG_NOGROUP\t\t(1 << 11)\n \n-/* GOMP_target{_41,update_41,enter_exit_data} flags argument.  */\n+/* GOMP_target{_ext,update_ext,enter_exit_data} flags argument.  */\n #define GOMP_TARGET_FLAG_NOWAIT\t\t(1 << 0)\n #define GOMP_TARGET_FLAG_EXIT_DATA\t(1 << 1)\n /* Internal to libgomp.  */"}, {"sha": "26377b64060becc61076c4483ddd4cc488a1f826", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -1,3 +1,112 @@\n+2015-11-05  Jakub Jelinek  <jakub@redhat.com>\n+\t    Ilya Verbin  <ilya.verbin@intel.com>\n+\n+\t* libgomp_g.h (GOMP_loop_nonmonotonic_dynamic_next,\n+\tGOMP_loop_nonmonotonic_dynamic_start,\n+\tGOMP_loop_nonmonotonic_guided_next,\n+\tGOMP_loop_nonmonotonic_guided_start,\n+\tGOMP_loop_ull_nonmonotonic_dynamic_next,\n+\tGOMP_loop_ull_nonmonotonic_dynamic_start,\n+\tGOMP_loop_ull_nonmonotonic_guided_next,\n+\tGOMP_loop_ull_nonmonotonic_guided_start,\n+\tGOMP_parallel_loop_nonmonotonic_dynamic,\n+\tGOMP_parallel_loop_nonmonotonic_guided): New prototypes.\n+\t(GOMP_target_41): Renamed to ...\n+\t(GOMP_target_ext): ... this.  Add num_teams and thread_limit\n+\targuments.\n+\t(GOMP_target_data_41): Renamed to ...\n+\t(GOMP_target_data_ext): ... this.\n+\t(GOMP_target_update_41): Renamed to ...\n+\t(GOMP_target_update_ext): ... this.\n+\t* libgomp.map (GOMP_4.5): Export GOMP_target_ext,\n+\tGOMP_target_data_ext and GOMP_target_update_ext instead of\n+\tGOMP_target_41, GOMP_target_data_41 and GOMP_target_update_41.\n+\tExport GOMP_loop_nonmonotonic_dynamic_next,\n+\tGOMP_loop_nonmonotonic_dynamic_start,\n+\tGOMP_loop_nonmonotonic_guided_next,\n+\tGOMP_loop_nonmonotonic_guided_start,\n+\tGOMP_loop_ull_nonmonotonic_dynamic_next,\n+\tGOMP_loop_ull_nonmonotonic_dynamic_start,\n+\tGOMP_loop_ull_nonmonotonic_guided_next,\n+\tGOMP_loop_ull_nonmonotonic_guided_start,\n+\tGOMP_parallel_loop_nonmonotonic_dynamic and\n+\tGOMP_parallel_loop_nonmonotonic_guided.\n+\t* loop.c (GOMP_parallel_loop_nonmonotonic_dynamic,\n+\tGOMP_parallel_loop_nonmonotonic_guided,\n+\tGOMP_loop_nonmonotonic_dynamic_start,\n+\tGOMP_loop_nonmonotonic_guided_start,\n+\tGOMP_loop_nonmonotonic_dynamic_next,\n+\tGOMP_loop_nonmonotonic_guided_next): New aliases or functions.\n+\t* loop_ull.c (GOMP_loop_ull_nonmonotonic_dynamic_start,\n+\tGOMP_loop_ull_nonmonotonic_guided_start,\n+\tGOMP_loop_ull_nonmonotonic_dynamic_next,\n+\tGOMP_loop_ull_nonmonotonic_guided_next): Likewise.\n+\t* target.c (gomp_map_0len_lookup, gomp_map_val): New inline\n+\tfunctions.\n+\t(gomp_map_vars): Handle GOMP_MAP_ALWAYS_POINTER.  For\n+\tGOMP_MAP_ZERO_LEN_ARRAY_SECTION use gomp_map_0len_lookup.\n+\tUse gomp_map_val function.\n+\t(gomp_target_fallback_firstprivate): New static function.\n+\t(GOMP_target_41): Renamed to ...\n+\t(GOMP_target_ext): ... this.  Add num_teams and thread_limit\n+\targuments.  Move firstprivate fallback handling into a new\n+\tfunction.\n+\t(GOMP_target_data_41): Renamed to ...\n+\t(GOMP_target_data_ext): ... this.\n+\t(GOMP_target_update_41): Renamed to ...\n+\t(GOMP_target_update_ext): ... this.\n+\t(gomp_exit_data): For GOMP_MAP_*ZERO_LEN* use\n+\tgomp_map_0len_lookup instead of gomp_map_lookup.\n+\t(omp_target_is_present): Use gomp_map_0len_lookup instead of\n+\tgomp_map_lookup.\n+\t* testsuite/libgomp.c/target-28.c: Likewise.\n+\t* testsuite/libgomp.c/monotonic-1.c: New test.\n+\t* testsuite/libgomp.c/monotonic-2.c: New test.\n+\t* testsuite/libgomp.c/nonmonotonic-1.c: New test.\n+\t* testsuite/libgomp.c/nonmonotonic-2.c: New test.\n+\t* testsuite/libgomp.c/pr66199-5.c: New test.\n+\t* testsuite/libgomp.c/pr66199-6.c: New test.\n+\t* testsuite/libgomp.c/pr66199-7.c: New test.\n+\t* testsuite/libgomp.c/pr66199-8.c: New test.\n+\t* testsuite/libgomp.c/pr66199-9.c: New test.\n+\t* testsuite/libgomp.c/reduction-11.c: New test.\n+\t* testsuite/libgomp.c/reduction-12.c: New test.\n+\t* testsuite/libgomp.c/reduction-13.c: New test.\n+\t* testsuite/libgomp.c/reduction-14.c: New test.\n+\t* testsuite/libgomp.c/reduction-15.c: New test.\n+\t* testsuite/libgomp.c/target-12.c (main): Adjust for\n+\tomp_target_is_present change for one-past-last element.\n+\t* testsuite/libgomp.c/target-17.c (foo): Drop tests where\n+\tthe same var is both mapped and privatized.\n+\t* testsuite/libgomp.c/target-19.c (foo): Adjust for different\n+\thandling of zero-length array sections.\n+\t* testsuite/libgomp.c/target-28.c: New test.\n+\t* testsuite/libgomp.c/target-29.c: New test.\n+\t* testsuite/libgomp.c/target-30.c: New test.\n+\t* testsuite/libgomp.c/target-teams-1.c: New test.\n+\t* testsuite/libgomp.c++/member-6.C: New test.\n+\t* testsuite/libgomp.c++/member-7.C: New test.\n+\t* testsuite/libgomp.c++/monotonic-1.C: New test.\n+\t* testsuite/libgomp.c++/monotonic-2.C: New test.\n+\t* testsuite/libgomp.c++/nonmonotonic-1.C: New test.\n+\t* testsuite/libgomp.c++/nonmonotonic-2.C: New test.\n+\t* testsuite/libgomp.c++/pr66199-3.C: New test.\n+\t* testsuite/libgomp.c++/pr66199-4.C: New test.\n+\t* testsuite/libgomp.c++/pr66199-5.C: New test.\n+\t* testsuite/libgomp.c++/pr66199-6.C: New test.\n+\t* testsuite/libgomp.c++/pr66199-7.C: New test.\n+\t* testsuite/libgomp.c++/pr66199-8.C: New test.\n+\t* testsuite/libgomp.c++/pr66199-9.C: New test.\n+\t* testsuite/libgomp.c++/reduction-11.C: New test.\n+\t* testsuite/libgomp.c++/reduction-12.C: New test.\n+\t* testsuite/libgomp.c++/target-13.C: New test.\n+\t* testsuite/libgomp.c++/target-14.C: New test.\n+\t* testsuite/libgomp.c++/target-15.C: New test.\n+\t* testsuite/libgomp.c++/target-16.C: New test.\n+\t* testsuite/libgomp.c++/target-17.C: New test.\n+\t* testsuite/libgomp.c++/target-18.C: New test.\n+\t* testsuite/libgomp.c++/target-19.C: New test.\n+\n 2015-11-04  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* testsuite/libgomp.oacc-fortran/reduction-1.f90: Fix dimensions"}, {"sha": "39faba95cbd7d63228ac5a5f4eaa3d1f12b3bc99", "filename": "libgomp/libgomp.map", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Flibgomp.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Flibgomp.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.map?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -266,9 +266,9 @@ GOMP_4.0.1 {\n \n GOMP_4.5 {\n   global:\n-\tGOMP_target_41;\n-\tGOMP_target_data_41;\n-\tGOMP_target_update_41;\n+\tGOMP_target_ext;\n+\tGOMP_target_data_ext;\n+\tGOMP_target_update_ext;\n \tGOMP_target_enter_exit_data;\n \tGOMP_taskloop;\n \tGOMP_taskloop_ull;\n@@ -286,6 +286,16 @@ GOMP_4.5 {\n \tGOMP_loop_ull_doacross_static_start;\n \tGOMP_doacross_ull_post;\n \tGOMP_doacross_ull_wait;\n+\tGOMP_loop_nonmonotonic_dynamic_next;\n+\tGOMP_loop_nonmonotonic_dynamic_start;\n+\tGOMP_loop_nonmonotonic_guided_next;\n+\tGOMP_loop_nonmonotonic_guided_start;\n+\tGOMP_loop_ull_nonmonotonic_dynamic_next;\n+\tGOMP_loop_ull_nonmonotonic_dynamic_start;\n+\tGOMP_loop_ull_nonmonotonic_guided_next;\n+\tGOMP_loop_ull_nonmonotonic_guided_start;\n+\tGOMP_parallel_loop_nonmonotonic_dynamic;\n+\tGOMP_parallel_loop_nonmonotonic_guided;\n } GOMP_4.0.1;\n \n OACC_2.0 {"}, {"sha": "c238e6a7556b554d67f3a7c75351e95c070bcf64", "filename": "libgomp/libgomp_g.h", "status": "modified", "additions": 35, "deletions": 6, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Flibgomp_g.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Flibgomp_g.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp_g.h?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -52,6 +52,10 @@ extern bool GOMP_loop_static_start (long, long, long, long, long *, long *);\n extern bool GOMP_loop_dynamic_start (long, long, long, long, long *, long *);\n extern bool GOMP_loop_guided_start (long, long, long, long, long *, long *);\n extern bool GOMP_loop_runtime_start (long, long, long, long *, long *);\n+extern bool GOMP_loop_nonmonotonic_dynamic_start (long, long, long, long,\n+\t\t\t\t\t\t  long *, long *);\n+extern bool GOMP_loop_nonmonotonic_guided_start (long, long, long, long,\n+\t\t\t\t\t\t long *, long *);\n \n extern bool GOMP_loop_ordered_static_start (long, long, long, long,\n \t\t\t\t\t    long *, long *);\n@@ -65,6 +69,8 @@ extern bool GOMP_loop_static_next (long *, long *);\n extern bool GOMP_loop_dynamic_next (long *, long *);\n extern bool GOMP_loop_guided_next (long *, long *);\n extern bool GOMP_loop_runtime_next (long *, long *);\n+extern bool GOMP_loop_nonmonotonic_dynamic_next (long *, long *);\n+extern bool GOMP_loop_nonmonotonic_guided_next (long *, long *);\n \n extern bool GOMP_loop_ordered_static_next (long *, long *);\n extern bool GOMP_loop_ordered_dynamic_next (long *, long *);\n@@ -100,6 +106,12 @@ extern void GOMP_parallel_loop_guided (void (*)(void *), void *,\n extern void GOMP_parallel_loop_runtime (void (*)(void *), void *,\n \t\t\t\t\tunsigned, long, long, long,\n \t\t\t\t\tunsigned);\n+extern void GOMP_parallel_loop_nonmonotonic_dynamic (void (*)(void *), void *,\n+\t\t\t\t\t\t     unsigned, long, long,\n+\t\t\t\t\t\t     long, long, unsigned);\n+extern void GOMP_parallel_loop_nonmonotonic_guided (void (*)(void *), void *,\n+\t\t\t\t\t\t    unsigned, long, long,\n+\t\t\t\t\t\t    long, long, unsigned);\n \n extern void GOMP_loop_end (void);\n extern void GOMP_loop_end_nowait (void);\n@@ -130,6 +142,18 @@ extern bool GOMP_loop_ull_runtime_start (bool, unsigned long long,\n \t\t\t\t\t unsigned long long,\n \t\t\t\t\t unsigned long long *,\n \t\t\t\t\t unsigned long long *);\n+extern bool GOMP_loop_ull_nonmonotonic_dynamic_start (bool, unsigned long long,\n+\t\t\t\t\t\t      unsigned long long,\n+\t\t\t\t\t\t      unsigned long long,\n+\t\t\t\t\t\t      unsigned long long,\n+\t\t\t\t\t\t      unsigned long long *,\n+\t\t\t\t\t\t      unsigned long long *);\n+extern bool GOMP_loop_ull_nonmonotonic_guided_start (bool, unsigned long long,\n+\t\t\t\t\t\t     unsigned long long,\n+\t\t\t\t\t\t     unsigned long long,\n+\t\t\t\t\t\t     unsigned long long,\n+\t\t\t\t\t\t     unsigned long long *,\n+\t\t\t\t\t\t     unsigned long long *);\n \n extern bool GOMP_loop_ull_ordered_static_start (bool, unsigned long long,\n \t\t\t\t\t\tunsigned long long,\n@@ -163,6 +187,10 @@ extern bool GOMP_loop_ull_guided_next (unsigned long long *,\n \t\t\t\t       unsigned long long *);\n extern bool GOMP_loop_ull_runtime_next (unsigned long long *,\n \t\t\t\t\tunsigned long long *);\n+extern bool GOMP_loop_ull_nonmonotonic_dynamic_next (unsigned long long *,\n+\t\t\t\t\t\t     unsigned long long *);\n+extern bool GOMP_loop_ull_nonmonotonic_guided_next (unsigned long long *,\n+\t\t\t\t\t\t    unsigned long long *);\n \n extern bool GOMP_loop_ull_ordered_static_next (unsigned long long *,\n \t\t\t\t\t       unsigned long long *);\n@@ -249,17 +277,18 @@ extern void GOMP_single_copy_end (void *);\n \n extern void GOMP_target (int, void (*) (void *), const void *,\n \t\t\t size_t, void **, size_t *, unsigned char *);\n-extern void GOMP_target_41 (int, void (*) (void *), size_t, void **, size_t *,\n-\t\t\t  unsigned short *, unsigned int, void **);\n+extern void GOMP_target_ext (int, void (*) (void *), size_t, void **, size_t *,\n+\t\t\t     unsigned short *, unsigned int, void **,\n+\t\t\t     int, int);\n extern void GOMP_target_data (int, const void *,\n \t\t\t      size_t, void **, size_t *, unsigned char *);\n-extern void GOMP_target_data_41 (int, size_t, void **, size_t *,\n-\t\t\t       unsigned short *);\n+extern void GOMP_target_data_ext (int, size_t, void **, size_t *,\n+\t\t\t\t  unsigned short *);\n extern void GOMP_target_end_data (void);\n extern void GOMP_target_update (int, const void *,\n \t\t\t\tsize_t, void **, size_t *, unsigned char *);\n-extern void GOMP_target_update_41 (int, size_t, void **, size_t *,\n-\t\t\t\t   unsigned short *, unsigned int, void **);\n+extern void GOMP_target_update_ext (int, size_t, void **, size_t *,\n+\t\t\t\t    unsigned short *, unsigned int, void **);\n extern void GOMP_target_enter_exit_data (int, size_t, void **, size_t *,\n \t\t\t\t\t unsigned short *, unsigned int,\n \t\t\t\t\t void **);"}, {"sha": "a7b539885fdf4427a5379b5b433e79bbe67b004c", "filename": "libgomp/loop.c", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Floop.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -111,6 +111,11 @@ gomp_loop_static_start (long start, long end, long incr, long chunk_size,\n   return !gomp_iter_static_next (istart, iend);\n }\n \n+/* The current dynamic implementation is always monotonic.  The\n+   entrypoints without nonmonotonic in them have to be always monotonic,\n+   but the nonmonotonic ones could be changed to use work-stealing for\n+   improved scalability.  */\n+\n static bool\n gomp_loop_dynamic_start (long start, long end, long incr, long chunk_size,\n \t\t\t long *istart, long *iend)\n@@ -136,6 +141,9 @@ gomp_loop_dynamic_start (long start, long end, long incr, long chunk_size,\n   return ret;\n }\n \n+/* Similarly as for dynamic, though the question is how can the chunk sizes\n+   be decreased without a central locking or atomics.  */\n+\n static bool\n gomp_loop_guided_start (long start, long end, long incr, long chunk_size,\n \t\t\tlong *istart, long *iend)\n@@ -630,6 +638,37 @@ GOMP_parallel_loop_guided (void (*fn) (void *), void *data,\n   GOMP_parallel_end ();\n }\n \n+#ifdef HAVE_ATTRIBUTE_ALIAS\n+extern __typeof(GOMP_parallel_loop_dynamic) GOMP_parallel_loop_nonmonotonic_dynamic\n+\t__attribute__((alias (\"GOMP_parallel_loop_dynamic\")));\n+extern __typeof(GOMP_parallel_loop_guided) GOMP_parallel_loop_nonmonotonic_guided\n+\t__attribute__((alias (\"GOMP_parallel_loop_guided\")));\n+#else\n+void\n+GOMP_parallel_loop_nonmonotonic_dynamic (void (*fn) (void *), void *data,\n+\t\t\t\t\t unsigned num_threads, long start,\n+\t\t\t\t\t long end, long incr, long chunk_size,\n+\t\t\t\t\t unsigned flags)\n+{\n+  gomp_parallel_loop_start (fn, data, num_threads, start, end, incr,\n+\t\t\t    GFS_DYNAMIC, chunk_size, flags);\n+  fn (data);\n+  GOMP_parallel_end ();\n+}\n+\n+void\n+GOMP_parallel_loop_nonmonotonic_guided (void (*fn) (void *), void *data,\n+\t\t\t\t\tunsigned num_threads, long start,\n+\t\t\t\t\tlong end, long incr, long chunk_size,\n+\t\t\t\t\tunsigned flags)\n+{\n+  gomp_parallel_loop_start (fn, data, num_threads, start, end, incr,\n+\t\t\t    GFS_GUIDED, chunk_size, flags);\n+  fn (data);\n+  GOMP_parallel_end ();\n+}\n+#endif\n+\n void\n GOMP_parallel_loop_runtime (void (*fn) (void *), void *data,\n \t\t\t    unsigned num_threads, long start, long end,\n@@ -678,6 +717,10 @@ extern __typeof(gomp_loop_dynamic_start) GOMP_loop_dynamic_start\n \t__attribute__((alias (\"gomp_loop_dynamic_start\")));\n extern __typeof(gomp_loop_guided_start) GOMP_loop_guided_start\n \t__attribute__((alias (\"gomp_loop_guided_start\")));\n+extern __typeof(gomp_loop_dynamic_start) GOMP_loop_nonmonotonic_dynamic_start\n+\t__attribute__((alias (\"gomp_loop_dynamic_start\")));\n+extern __typeof(gomp_loop_guided_start) GOMP_loop_nonmonotonic_guided_start\n+\t__attribute__((alias (\"gomp_loop_guided_start\")));\n \n extern __typeof(gomp_loop_ordered_static_start) GOMP_loop_ordered_static_start\n \t__attribute__((alias (\"gomp_loop_ordered_static_start\")));\n@@ -699,6 +742,10 @@ extern __typeof(gomp_loop_dynamic_next) GOMP_loop_dynamic_next\n \t__attribute__((alias (\"gomp_loop_dynamic_next\")));\n extern __typeof(gomp_loop_guided_next) GOMP_loop_guided_next\n \t__attribute__((alias (\"gomp_loop_guided_next\")));\n+extern __typeof(gomp_loop_dynamic_next) GOMP_loop_nonmonotonic_dynamic_next\n+\t__attribute__((alias (\"gomp_loop_dynamic_next\")));\n+extern __typeof(gomp_loop_guided_next) GOMP_loop_nonmonotonic_guided_next\n+\t__attribute__((alias (\"gomp_loop_guided_next\")));\n \n extern __typeof(gomp_loop_ordered_static_next) GOMP_loop_ordered_static_next\n \t__attribute__((alias (\"gomp_loop_ordered_static_next\")));\n@@ -728,6 +775,21 @@ GOMP_loop_guided_start (long start, long end, long incr, long chunk_size,\n   return gomp_loop_guided_start (start, end, incr, chunk_size, istart, iend);\n }\n \n+bool\n+GOMP_loop_nonmonotonic_dynamic_start (long start, long end, long incr,\n+\t\t\t\t      long chunk_size, long *istart,\n+\t\t\t\t      long *iend)\n+{\n+  return gomp_loop_dynamic_start (start, end, incr, chunk_size, istart, iend);\n+}\n+\n+bool\n+GOMP_loop_nonmonotonic_guided_start (long start, long end, long incr,\n+\t\t\t\t     long chunk_size, long *istart, long *iend)\n+{\n+  return gomp_loop_guided_start (start, end, incr, chunk_size, istart, iend);\n+}\n+\n bool\n GOMP_loop_ordered_static_start (long start, long end, long incr,\n \t\t\t\tlong chunk_size, long *istart, long *iend)\n@@ -794,6 +856,18 @@ GOMP_loop_guided_next (long *istart, long *iend)\n   return gomp_loop_guided_next (istart, iend);\n }\n \n+bool\n+GOMP_loop_nonmonotonic_dynamic_next (long *istart, long *iend)\n+{\n+  return gomp_loop_dynamic_next (istart, iend);\n+}\n+\n+bool\n+GOMP_loop_nonmonotonic_guided_next (long *istart, long *iend)\n+{\n+  return gomp_loop_guided_next (istart, iend);\n+}\n+\n bool\n GOMP_loop_ordered_static_next (long *istart, long *iend)\n {"}, {"sha": "b00fcd52bc7381ec9841c9eb053bf57e8bbb9b69", "filename": "libgomp/loop_ull.c", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Floop_ull.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Floop_ull.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Floop_ull.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -566,6 +566,10 @@ extern __typeof(gomp_loop_ull_dynamic_start) GOMP_loop_ull_dynamic_start\n \t__attribute__((alias (\"gomp_loop_ull_dynamic_start\")));\n extern __typeof(gomp_loop_ull_guided_start) GOMP_loop_ull_guided_start\n \t__attribute__((alias (\"gomp_loop_ull_guided_start\")));\n+extern __typeof(gomp_loop_ull_dynamic_start) GOMP_loop_ull_nonmonotonic_dynamic_start\n+\t__attribute__((alias (\"gomp_loop_ull_dynamic_start\")));\n+extern __typeof(gomp_loop_ull_guided_start) GOMP_loop_ull_nonmonotonic_guided_start\n+\t__attribute__((alias (\"gomp_loop_ull_guided_start\")));\n \n extern __typeof(gomp_loop_ull_ordered_static_start) GOMP_loop_ull_ordered_static_start\n \t__attribute__((alias (\"gomp_loop_ull_ordered_static_start\")));\n@@ -587,6 +591,10 @@ extern __typeof(gomp_loop_ull_dynamic_next) GOMP_loop_ull_dynamic_next\n \t__attribute__((alias (\"gomp_loop_ull_dynamic_next\")));\n extern __typeof(gomp_loop_ull_guided_next) GOMP_loop_ull_guided_next\n \t__attribute__((alias (\"gomp_loop_ull_guided_next\")));\n+extern __typeof(gomp_loop_ull_dynamic_next) GOMP_loop_ull_nonmonotonic_dynamic_next\n+\t__attribute__((alias (\"gomp_loop_ull_dynamic_next\")));\n+extern __typeof(gomp_loop_ull_guided_next) GOMP_loop_ull_nonmonotonic_guided_next\n+\t__attribute__((alias (\"gomp_loop_ull_guided_next\")));\n \n extern __typeof(gomp_loop_ull_ordered_static_next) GOMP_loop_ull_ordered_static_next\n \t__attribute__((alias (\"gomp_loop_ull_ordered_static_next\")));\n@@ -622,6 +630,25 @@ GOMP_loop_ull_guided_start (bool up, gomp_ull start, gomp_ull end,\n \t\t\t\t     iend);\n }\n \n+bool\n+GOMP_loop_ull_nonmonotonic_dynamic_start (bool up, gomp_ull start,\n+\t\t\t\t\t  gomp_ull end, gomp_ull incr,\n+\t\t\t\t\t  gomp_ull chunk_size,\n+\t\t\t\t\t  gomp_ull *istart, gomp_ull *iend)\n+{\n+  return gomp_loop_ull_dynamic_start (up, start, end, incr, chunk_size, istart,\n+\t\t\t\t      iend);\n+}\n+\n+bool\n+GOMP_loop_ull_nonmonotonic_guided_start (bool up, gomp_ull start, gomp_ull end,\n+\t\t\t\t\t gomp_ull incr, gomp_ull chunk_size,\n+\t\t\t\t\t gomp_ull *istart, gomp_ull *iend)\n+{\n+  return gomp_loop_ull_guided_start (up, start, end, incr, chunk_size, istart,\n+\t\t\t\t     iend);\n+}\n+\n bool\n GOMP_loop_ull_ordered_static_start (bool up, gomp_ull start, gomp_ull end,\n \t\t\t\t    gomp_ull incr, gomp_ull chunk_size,\n@@ -694,6 +721,18 @@ GOMP_loop_ull_guided_next (gomp_ull *istart, gomp_ull *iend)\n   return gomp_loop_ull_guided_next (istart, iend);\n }\n \n+bool\n+GOMP_loop_ull_nonmonotonic_dynamic_next (gomp_ull *istart, gomp_ull *iend)\n+{\n+  return gomp_loop_ull_dynamic_next (istart, iend);\n+}\n+\n+bool\n+GOMP_loop_ull_nonmonotonic_guided_next (gomp_ull *istart, gomp_ull *iend)\n+{\n+  return gomp_loop_ull_guided_next (istart, iend);\n+}\n+\n bool\n GOMP_loop_ull_ordered_static_next (gomp_ull *istart, gomp_ull *iend)\n {"}, {"sha": "1bddc6ffcee5fa72477c68844c8256af2764c75f", "filename": "libgomp/target.c", "status": "modified", "additions": 140, "deletions": 65, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftarget.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -162,7 +162,20 @@ gomp_map_lookup (splay_tree mem_map, splay_tree_key key)\n   return splay_tree_lookup (mem_map, key);\n }\n \n-/* Handle the case where gomp_map_lookup found oldn for newn.\n+static inline splay_tree_key\n+gomp_map_0len_lookup (splay_tree mem_map, splay_tree_key key)\n+{\n+  if (key->host_start != key->host_end)\n+    return splay_tree_lookup (mem_map, key);\n+\n+  key->host_end++;\n+  splay_tree_key n = splay_tree_lookup (mem_map, key);\n+  key->host_end--;\n+  return n;\n+}\n+\n+/* Handle the case where gomp_map_lookup, splay_tree_lookup or\n+   gomp_map_0len_lookup found oldn for newn.\n    Helper function of gomp_map_vars.  */\n \n static inline void\n@@ -306,6 +319,26 @@ gomp_map_fields_existing (struct target_mem_desc *tgt, splay_tree_key n,\n \t      (void *) cur_node.host_end);\n }\n \n+static inline uintptr_t\n+gomp_map_val (struct target_mem_desc *tgt, void **hostaddrs, size_t i)\n+{\n+  if (tgt->list[i].key != NULL)\n+    return tgt->list[i].key->tgt->tgt_start\n+\t   + tgt->list[i].key->tgt_offset\n+\t   + tgt->list[i].offset;\n+  if (tgt->list[i].offset == ~(uintptr_t) 0)\n+    return (uintptr_t) hostaddrs[i];\n+  if (tgt->list[i].offset == ~(uintptr_t) 1)\n+    return 0;\n+  if (tgt->list[i].offset == ~(uintptr_t) 2)\n+    return tgt->list[i + 1].key->tgt->tgt_start\n+\t   + tgt->list[i + 1].key->tgt_offset\n+\t   + tgt->list[i + 1].offset\n+\t   + (uintptr_t) hostaddrs[i]\n+\t   - (uintptr_t) hostaddrs[i + 1];\n+  return tgt->tgt_start + tgt->list[i].offset;\n+}\n+\n attribute_hidden struct target_mem_desc *\n gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n \t       void **hostaddrs, void **devaddrs, size_t *sizes, void *kinds,\n@@ -400,6 +433,13 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n \t  i--;\n \t  continue;\n \t}\n+      else if ((kind & typemask) == GOMP_MAP_ALWAYS_POINTER)\n+\t{\n+\t  tgt->list[i].key = NULL;\n+\t  tgt->list[i].offset = ~(uintptr_t) 1;\n+\t  has_firstprivate = true;\n+\t  continue;\n+\t}\n       cur_node.host_start = (uintptr_t) hostaddrs[i];\n       if (!GOMP_MAP_POINTER_P (kind & typemask))\n \tcur_node.host_end = cur_node.host_start + sizes[i];\n@@ -420,7 +460,7 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n       splay_tree_key n;\n       if ((kind & typemask) == GOMP_MAP_ZERO_LEN_ARRAY_SECTION)\n \t{\n-\t  n = gomp_map_lookup (mem_map, &cur_node);\n+\t  n = gomp_map_0len_lookup (mem_map, &cur_node);\n \t  if (!n)\n \t    {\n \t      tgt->list[i].key = NULL;\n@@ -558,6 +598,32 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n \t\t\t\t\t    sizes, kinds);\n \t\ti--;\n \t\tcontinue;\n+\t      case GOMP_MAP_ALWAYS_POINTER:\n+\t\tcur_node.host_start = (uintptr_t) hostaddrs[i];\n+\t\tcur_node.host_end = cur_node.host_start + sizeof (void *);\n+\t\tn = splay_tree_lookup (mem_map, &cur_node);\n+\t\tif (n == NULL\n+\t\t    || n->host_start > cur_node.host_start\n+\t\t    || n->host_end < cur_node.host_end)\n+\t\t  {\n+\t\t    gomp_mutex_unlock (&devicep->lock);\n+\t\t    gomp_fatal (\"always pointer not mapped\");\n+\t\t  }\n+\t\tif ((get_kind (short_mapkind, kinds, i - 1) & typemask)\n+\t\t    != GOMP_MAP_ALWAYS_POINTER)\n+\t\t  cur_node.tgt_offset = gomp_map_val (tgt, hostaddrs, i - 1);\n+\t\tif (cur_node.tgt_offset)\n+\t\t  cur_node.tgt_offset -= sizes[i];\n+\t\tdevicep->host2dev_func (devicep->target_id,\n+\t\t\t\t\t(void *) (n->tgt->tgt_start\n+\t\t\t\t\t\t  + n->tgt_offset\n+\t\t\t\t\t\t  + cur_node.host_start\n+\t\t\t\t\t\t  - n->host_start),\n+\t\t\t\t\t(void *) &cur_node.tgt_offset,\n+\t\t\t\t\tsizeof (void *));\n+\t\tcur_node.tgt_offset = n->tgt->tgt_start + n->tgt_offset\n+\t\t\t\t      + cur_node.host_start - n->host_start;\n+\t\tcontinue;\n \t      default:\n \t\tbreak;\n \t      }\n@@ -701,26 +767,7 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n     {\n       for (i = 0; i < mapnum; i++)\n \t{\n-\t  if (tgt->list[i].key == NULL)\n-\t    {\n-\t      if (tgt->list[i].offset == ~(uintptr_t) 0)\n-\t\tcur_node.tgt_offset = (uintptr_t) hostaddrs[i];\n-\t      else if (tgt->list[i].offset == ~(uintptr_t) 1)\n-\t\tcur_node.tgt_offset = 0;\n-\t      else if (tgt->list[i].offset == ~(uintptr_t) 2)\n-\t\tcur_node.tgt_offset = tgt->list[i + 1].key->tgt->tgt_start\n-\t\t\t\t      + tgt->list[i + 1].key->tgt_offset\n-\t\t\t\t      + tgt->list[i + 1].offset\n-\t\t\t\t      + (uintptr_t) hostaddrs[i]\n-\t\t\t\t      - (uintptr_t) hostaddrs[i + 1];\n-\t      else\n-\t\tcur_node.tgt_offset = tgt->tgt_start\n-\t\t\t\t      + tgt->list[i].offset;\n-\t    }\n-\t  else\n-\t    cur_node.tgt_offset = tgt->list[i].key->tgt->tgt_start\n-\t\t\t\t  + tgt->list[i].key->tgt_offset\n-\t\t\t\t  + tgt->list[i].offset;\n+\t  cur_node.tgt_offset = gomp_map_val (tgt, hostaddrs, i);\n \t  /* FIXME: see above FIXME comment.  */\n \t  devicep->host2dev_func (devicep->target_id,\n \t\t\t\t  (void *) (tgt->tgt_start\n@@ -1213,7 +1260,7 @@ gomp_fini_device (struct gomp_device_descr *devicep)\n   devicep->is_initialized = false;\n }\n \n-/* Host fallback for GOMP_target{,_41} routines.  */\n+/* Host fallback for GOMP_target{,_ext} routines.  */\n \n static void\n gomp_target_fallback (void (*fn) (void *), void **hostaddrs)\n@@ -1231,7 +1278,45 @@ gomp_target_fallback (void (*fn) (void *), void **hostaddrs)\n   *thr = old_thr;\n }\n \n-/* Helper function of GOMP_target{,_41} routines.  */\n+/* Host fallback with firstprivate map-type handling.  */\n+\n+static void\n+gomp_target_fallback_firstprivate (void (*fn) (void *), size_t mapnum,\n+\t\t\t\t   void **hostaddrs, size_t *sizes,\n+\t\t\t\t   unsigned short *kinds)\n+{\n+  size_t i, tgt_align = 0, tgt_size = 0;\n+  char *tgt = NULL;\n+  for (i = 0; i < mapnum; i++)\n+    if ((kinds[i] & 0xff) == GOMP_MAP_FIRSTPRIVATE)\n+      {\n+\tsize_t align = (size_t) 1 << (kinds[i] >> 8);\n+\tif (tgt_align < align)\n+\t  tgt_align = align;\n+\ttgt_size = (tgt_size + align - 1) & ~(align - 1);\n+\ttgt_size += sizes[i];\n+      }\n+  if (tgt_align)\n+    {\n+      tgt = gomp_alloca (tgt_size + tgt_align - 1);\n+      uintptr_t al = (uintptr_t) tgt & (tgt_align - 1);\n+      if (al)\n+\ttgt += tgt_align - al;\n+      tgt_size = 0;\n+      for (i = 0; i < mapnum; i++)\n+\tif ((kinds[i] & 0xff) == GOMP_MAP_FIRSTPRIVATE)\n+\t  {\n+\t    size_t align = (size_t) 1 << (kinds[i] >> 8);\n+\t    tgt_size = (tgt_size + align - 1) & ~(align - 1);\n+\t    memcpy (tgt + tgt_size, hostaddrs[i], sizes[i]);\n+\t    hostaddrs[i] = tgt + tgt_size;\n+\t    tgt_size = tgt_size + sizes[i];\n+\t  }\n+    }\n+  gomp_target_fallback (fn, hostaddrs);\n+}\n+\n+/* Helper function of GOMP_target{,_ext} routines.  */\n \n static void *\n gomp_get_target_fn_addr (struct gomp_device_descr *devicep,\n@@ -1294,13 +1379,31 @@ GOMP_target (int device, void (*fn) (void *), const void *unused,\n   gomp_unmap_vars (tgt_vars, true);\n }\n \n+/* Like GOMP_target, but KINDS is 16-bit, UNUSED is no longer present,\n+   and several arguments have been added:\n+   FLAGS is a bitmask, see GOMP_TARGET_FLAG_* in gomp-constants.h.\n+   DEPEND is array of dependencies, see GOMP_task for details.\n+   NUM_TEAMS is positive if GOMP_teams will be called in the body with\n+   that value, or 1 if teams construct is not present, or 0, if\n+   teams construct does not have num_teams clause and so the choice is\n+   implementation defined, and -1 if it can't be determined on the host\n+   what value will GOMP_teams have on the device.\n+   THREAD_LIMIT similarly is positive if GOMP_teams will be called in the\n+   body with that value, or 0, if teams construct does not have thread_limit\n+   clause or the teams construct is not present, or -1 if it can't be\n+   determined on the host what value will GOMP_teams have on the device.  */\n+\n void\n-GOMP_target_41 (int device, void (*fn) (void *), size_t mapnum,\n-\t\tvoid **hostaddrs, size_t *sizes, unsigned short *kinds,\n-\t\tunsigned int flags, void **depend)\n+GOMP_target_ext (int device, void (*fn) (void *), size_t mapnum,\n+\t\t void **hostaddrs, size_t *sizes, unsigned short *kinds,\n+\t\t unsigned int flags, void **depend, int num_teams,\n+\t\t int thread_limit)\n {\n   struct gomp_device_descr *devicep = resolve_device (device);\n \n+  (void) num_teams;\n+  (void) thread_limit;\n+\n   /* If there are depend clauses, but nowait is not present,\n      block the parent task until the dependencies are resolved\n      and then just continue with the rest of the function as if it\n@@ -1315,35 +1418,7 @@ GOMP_target_41 (int device, void (*fn) (void *), size_t mapnum,\n   if (devicep == NULL\n       || !(devicep->capabilities & GOMP_OFFLOAD_CAP_OPENMP_400))\n     {\n-      size_t i, tgt_align = 0, tgt_size = 0;\n-      char *tgt = NULL;\n-      for (i = 0; i < mapnum; i++)\n-\tif ((kinds[i] & 0xff) == GOMP_MAP_FIRSTPRIVATE)\n-\t  {\n-\t    size_t align = (size_t) 1 << (kinds[i] >> 8);\n-\t    if (tgt_align < align)\n-\t      tgt_align = align;\n-\t    tgt_size = (tgt_size + align - 1) & ~(align - 1);\n-\t    tgt_size += sizes[i];\n-\t  }\n-      if (tgt_align)\n-\t{\n-\t  tgt = gomp_alloca (tgt_size + tgt_align - 1);\n-\t  uintptr_t al = (uintptr_t) tgt & (tgt_align - 1);\n-\t  if (al)\n-\t    tgt += tgt_align - al;\n-\t  tgt_size = 0;\n-\t  for (i = 0; i < mapnum; i++)\n-\t    if ((kinds[i] & 0xff) == GOMP_MAP_FIRSTPRIVATE)\n-\t      {\n-\t\tsize_t align = (size_t) 1 << (kinds[i] >> 8);\n-\t\ttgt_size = (tgt_size + align - 1) & ~(align - 1);\n-\t\tmemcpy (tgt + tgt_size, hostaddrs[i], sizes[i]);\n-\t\thostaddrs[i] = tgt + tgt_size;\n-\t\ttgt_size = tgt_size + sizes[i];\n-\t      }\n-\t}\n-      gomp_target_fallback (fn, hostaddrs);\n+      gomp_target_fallback_firstprivate (fn, mapnum, hostaddrs, sizes, kinds);\n       return;\n     }\n \n@@ -1366,7 +1441,7 @@ GOMP_target_41 (int device, void (*fn) (void *), size_t mapnum,\n   gomp_unmap_vars (tgt_vars, true);\n }\n \n-/* Host fallback for GOMP_target_data{,_41} routines.  */\n+/* Host fallback for GOMP_target_data{,_ext} routines.  */\n \n static void\n gomp_target_data_fallback (void)\n@@ -1405,8 +1480,8 @@ GOMP_target_data (int device, const void *unused, size_t mapnum,\n }\n \n void\n-GOMP_target_data_41 (int device, size_t mapnum, void **hostaddrs, size_t *sizes,\n-\t\t     unsigned short *kinds)\n+GOMP_target_data_ext (int device, size_t mapnum, void **hostaddrs,\n+\t\t      size_t *sizes, unsigned short *kinds)\n {\n   struct gomp_device_descr *devicep = resolve_device (device);\n \n@@ -1448,9 +1523,9 @@ GOMP_target_update (int device, const void *unused, size_t mapnum,\n }\n \n void\n-GOMP_target_update_41 (int device, size_t mapnum, void **hostaddrs,\n-\t\t       size_t *sizes, unsigned short *kinds,\n-\t\t       unsigned int flags, void **depend)\n+GOMP_target_update_ext (int device, size_t mapnum, void **hostaddrs,\n+\t\t\tsize_t *sizes, unsigned short *kinds,\n+\t\t\tunsigned int flags, void **depend)\n {\n   struct gomp_device_descr *devicep = resolve_device (device);\n \n@@ -1527,7 +1602,7 @@ gomp_exit_data (struct gomp_device_descr *devicep, size_t mapnum,\n \t  cur_node.host_end = cur_node.host_start + sizes[i];\n \t  splay_tree_key k = (kind == GOMP_MAP_DELETE_ZERO_LEN_ARRAY_SECTION\n \t\t\t      || kind == GOMP_MAP_ZERO_LEN_ARRAY_SECTION)\n-\t    ? gomp_map_lookup (&devicep->mem_map, &cur_node)\n+\t    ? gomp_map_0len_lookup (&devicep->mem_map, &cur_node)\n \t    : splay_tree_lookup (&devicep->mem_map, &cur_node);\n \t  if (!k)\n \t    continue;\n@@ -1642,7 +1717,7 @@ gomp_target_task_fn (void *data)\n   struct gomp_target_task *ttask = (struct gomp_target_task *) data;\n   if (ttask->fn != NULL)\n     {\n-      /* GOMP_target_41 */\n+      /* GOMP_target_ext */\n     }\n   else if (ttask->devicep == NULL\n \t   || !(ttask->devicep->capabilities & GOMP_OFFLOAD_CAP_OPENMP_400))\n@@ -1759,7 +1834,7 @@ omp_target_is_present (void *ptr, int device_num)\n \n   cur_node.host_start = (uintptr_t) ptr;\n   cur_node.host_end = cur_node.host_start;\n-  splay_tree_key n = gomp_map_lookup (mem_map, &cur_node);\n+  splay_tree_key n = gomp_map_0len_lookup (mem_map, &cur_node);\n   int ret = n != NULL;\n   gomp_mutex_unlock (&devicep->lock);\n   return ret;"}, {"sha": "5c0c22bce378a27d16f3bb050f86edf3d30fc316", "filename": "libgomp/testsuite/libgomp.c++/member-6.C", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fmember-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fmember-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fmember-6.C?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,114 @@\n+// { dg-do run }\n+\n+#include <omp.h>\n+\n+struct R { R () {}; ~R () {}; int r; };\n+struct T { T () {}; virtual ~T () {}; int t; };\n+int c;\n+struct A : public R, virtual public T { A () : b(c) {} int a; int &b; void m1 (); };\n+\n+void\n+take (int &a, int &b, int &c, int &d)\n+{\n+  asm volatile (\"\" : : \"g\" (&a), \"g\" (&b), \"g\" (&c), \"g\" (&d) : \"memory\");\n+}\n+\n+void\n+A::m1 ()\n+{\n+  #pragma omp parallel private (a, T::t) shared (r, A::b) default(none)\n+  {\n+    int q = omp_get_thread_num (), q2;\n+    a = q;\n+    t = 3 * q;\n+    #pragma omp single copyprivate (q2)\n+    {\n+      r = 2 * q;\n+      b = 4 * q;\n+      q2 = q;\n+    }\n+    take (a, r, t, b);\n+    #pragma omp barrier\n+    if (A::a != q || R::r != 2 * q2 || T::t != 3 * q || A::b != 4 * q2)\n+      __builtin_abort ();\n+  }\n+  a = 7;\n+  r = 8;\n+  t = 9;\n+  b = 10;\n+  #pragma omp parallel shared (A::a) default (none) firstprivate (R::r, b) shared (t)\n+  {\n+    int q = omp_get_thread_num (), q2;\n+    take (A::a, R::r, T::t, A::b);\n+    if (a != 7 || r != 8 || t != 9 || b != 10)\n+      __builtin_abort ();\n+    R::r = 6 * q;\n+    #pragma omp barrier\n+    #pragma omp single copyprivate (q2)\n+    {\n+      A::a = 5 * q;\n+      T::t = 7 * q;\n+      q2 = q;\n+    }\n+    A::b = 8 * q;\n+    take (a, r, t, b);\n+    #pragma omp barrier\n+    if (a != 5 * q2 || r != 6 * q || t != 7 * q2 || b != 8 * q)\n+      __builtin_abort ();\n+  }\n+  a = 1;\n+  b = 2;\n+  R::r = 3;\n+  t = 4;\n+  bool f = false;\n+  #pragma omp parallel private (f)\n+    {\n+      f = false;\n+    #pragma omp single\n+    #pragma omp taskloop default(none) firstprivate (r, A::a, f) shared (T::t, b)\n+      for (int i = 0; i < 30; i++)\n+\t{\n+\t  int q = omp_get_thread_num ();\n+\t  int tv, bv;\n+\t  #pragma omp atomic read\n+\t  tv = t;\n+\t  #pragma omp atomic read\n+\t  bv = A::b;\n+\t  if (i == 16)\n+\t    {\n+\t      if (bv != 2 || tv != 4)\n+\t\t__builtin_abort ();\n+\t    }\n+\t  else\n+\t    {\n+\t      if ((bv != 2 && bv != 8) || (tv != 4 && tv != 9))\n+\t\t__builtin_abort ();\n+\t    }\n+\t  if (!f)\n+\t    {\n+\t      if (A::a != 1 || R::r != 3)\n+\t\t__builtin_abort ();\n+\t    }\n+\t  else if (a != 7 * q || r != 9 * q)\n+\t    __builtin_abort ();\n+\t  take (a, r, t, b);\n+\t  A::a = 7 * q;\n+\t  R::r = 9 * q;\n+\t  if (i == 16)\n+\t    {\n+\t      #pragma omp atomic write\n+\t      A::b = 8;\n+\t      #pragma omp atomic write\n+\t      T::t = 9;\n+\t    }\n+\t  f = true;\n+\t}\n+    }\n+}\n+\n+int\n+main ()\n+{\n+  A a;\n+  a.m1 ();\n+}"}, {"sha": "15848c5952e5fa637de7929b35e9babb0fb4fbc4", "filename": "libgomp/testsuite/libgomp.c++/member-7.C", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fmember-7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fmember-7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fmember-7.C?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,119 @@\n+// { dg-do run }\n+\n+#include <omp.h>\n+\n+int c, d, e;\n+struct R { R () {}; ~R () {}; int r; };\n+template <typename Q>\n+struct T { T () : t(d) {}; virtual ~T () {}; Q t; };\n+template <typename Q>\n+struct A : public R, virtual public T<Q> { A () : b(c), a(e) {} Q a; int &b; void m1 (); };\n+\n+void\n+take (int &a, int &b, int &c, int &d)\n+{\n+  asm volatile (\"\" : : \"g\" (&a), \"g\" (&b), \"g\" (&c), \"g\" (&d) : \"memory\");\n+}\n+\n+template <typename Q>\n+void\n+A<Q>::m1 ()\n+{\n+  #pragma omp parallel private (a, T<Q>::t) shared (r, A::b) default(none)\n+  {\n+    int q = omp_get_thread_num (), q2;\n+    a = q;\n+    T<Q>::t = 3 * q;\n+    #pragma omp single copyprivate (q2)\n+    {\n+      r = 2 * q;\n+      b = 4 * q;\n+      q2 = q;\n+    }\n+    take (a, r, T<Q>::t, b);\n+    #pragma omp barrier\n+    if (A::a != q || R::r != 2 * q2 || T<Q>::t != 3 * q || A::b != 4 * q2)\n+      __builtin_abort ();\n+  }\n+  a = 7;\n+  r = 8;\n+  T<Q>::t = 9;\n+  b = 10;\n+  #pragma omp parallel shared (A::a) default (none) firstprivate (R::r, b) shared (T<Q>::t)\n+  {\n+    int q = omp_get_thread_num (), q2;\n+    take (A::a, R::r, T<Q>::t, A::b);\n+    if (a != 7 || r != 8 || T<Q>::t != 9 || b != 10)\n+      __builtin_abort ();\n+    R::r = 6 * q;\n+    #pragma omp barrier\n+    #pragma omp single copyprivate (q2)\n+    {\n+      A::a = 5 * q;\n+      T<Q>::t = 7 * q;\n+      q2 = q;\n+    }\n+    A::b = 8 * q;\n+    take (a, r, T<Q>::t, b);\n+    #pragma omp barrier\n+    if (a != 5 * q2 || r != 6 * q || T<Q>::t != 7 * q2 || b != 8 * q)\n+      __builtin_abort ();\n+  }\n+  a = 1;\n+  b = 2;\n+  R::r = 3;\n+  T<Q>::t = 4;\n+  bool f = false;\n+  #pragma omp parallel private (f)\n+    {\n+      f = false;\n+    #pragma omp single\n+    #pragma omp taskloop default(none) firstprivate (r, A::a, f) shared (T<Q>::t, b)\n+      for (int i = 0; i < 30; i++)\n+\t{\n+\t  int q = omp_get_thread_num ();\n+\t  int tv, bv;\n+\t  #pragma omp atomic read\n+\t  tv = T<Q>::t;\n+\t  #pragma omp atomic read\n+\t  bv = A::b;\n+\t  if (i == 16)\n+\t    {\n+\t      if (bv != 2 || tv != 4)\n+\t\t__builtin_abort ();\n+\t    }\n+\t  else\n+\t    {\n+\t      if ((bv != 2 && bv != 8) || (tv != 4 && tv != 9))\n+\t\t__builtin_abort ();\n+\t    }\n+\t  if (!f)\n+\t    {\n+\t      if (A::a != 1 || R::r != 3)\n+\t\t__builtin_abort ();\n+\t    }\n+\t  else if (a != 7 * q || r != 9 * q)\n+\t    __builtin_abort ();\n+\t  take (a, r, T<Q>::t, b);\n+\t  A::a = 7 * q;\n+\t  R::r = 9 * q;\n+\t  if (i == 16)\n+\t    {\n+\t      #pragma omp atomic write\n+\t      A::b = 8;\n+\t      #pragma omp atomic write\n+\t      T<Q>::t = 9;\n+\t    }\n+\t  f = true;\n+\t}\n+    }\n+}\n+\n+int\n+main ()\n+{\n+  A<int> a;\n+  a.m1 ();\n+  A<int &> b;\n+  b.m1 ();\n+}"}, {"sha": "464bed6b6a54f4057459ee9c351fd673fe4b77a9", "filename": "libgomp/testsuite/libgomp.c++/monotonic-1.C", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fmonotonic-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fmonotonic-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fmonotonic-1.C?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,3 @@\n+// { dg-do run }\n+\n+#include \"../libgomp.c/monotonic-1.c\""}, {"sha": "41eef0318ea707d029c44661908fdaf2bcd6e955", "filename": "libgomp/testsuite/libgomp.c++/monotonic-2.C", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fmonotonic-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fmonotonic-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fmonotonic-2.C?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,3 @@\n+// { dg-do run }\n+\n+#include \"../libgomp.c/monotonic-2.c\""}, {"sha": "678e7654dfbda1be6c9b5a7682cac7618d56a71e", "filename": "libgomp/testsuite/libgomp.c++/nonmonotonic-1.C", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fnonmonotonic-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fnonmonotonic-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fnonmonotonic-1.C?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,3 @@\n+// { dg-do run }\n+\n+#include \"../libgomp.c/nonmonotonic-1.c\""}, {"sha": "e230875f3823a78fb7a65e5b9ff2271b7c6c97a1", "filename": "libgomp/testsuite/libgomp.c++/nonmonotonic-2.C", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fnonmonotonic-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fnonmonotonic-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fnonmonotonic-2.C?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,3 @@\n+// { dg-do run }\n+\n+#include \"../libgomp.c/nonmonotonic-2.c\""}, {"sha": "871dd44d4508d5c7a3f8e448d25290b3714dc38d", "filename": "libgomp/testsuite/libgomp.c++/pr66199-3.C", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fpr66199-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fpr66199-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fpr66199-3.C?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,4 @@\n+// PR middle-end/66199\n+// { dg-do run }\n+\n+#include \"../libgomp.c/pr66199-3.c\""}, {"sha": "bc71a6da043c31a2130fea2bedf037f002cf1ca3", "filename": "libgomp/testsuite/libgomp.c++/pr66199-4.C", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fpr66199-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fpr66199-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fpr66199-4.C?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,4 @@\n+// PR middle-end/66199\n+// { dg-do run }\n+\n+#include \"../libgomp.c/pr66199-4.c\""}, {"sha": "c7549e8f4247f80622fe0679a8824f059aeef531", "filename": "libgomp/testsuite/libgomp.c++/pr66199-5.C", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fpr66199-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fpr66199-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fpr66199-5.C?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,4 @@\n+// PR middle-end/66199\n+// { dg-do run }\n+\n+#include \"../libgomp.c/pr66199-5.c\""}, {"sha": "46adbd721b7d39172e43889558e554eae84b83bb", "filename": "libgomp/testsuite/libgomp.c++/pr66199-6.C", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fpr66199-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fpr66199-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fpr66199-6.C?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,4 @@\n+// PR middle-end/66199\n+// { dg-do run }\n+\n+#include \"../libgomp.c/pr66199-6.c\""}, {"sha": "b03d284ec3dc95b7b635af8f1f121bb21765f72f", "filename": "libgomp/testsuite/libgomp.c++/pr66199-7.C", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fpr66199-7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fpr66199-7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fpr66199-7.C?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,4 @@\n+// PR middle-end/66199\n+// { dg-do run }\n+\n+#include \"../libgomp.c/pr66199-7.c\""}, {"sha": "b998ef622c24e772b5ecbdaa2ddc38eac2001597", "filename": "libgomp/testsuite/libgomp.c++/pr66199-8.C", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fpr66199-8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fpr66199-8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fpr66199-8.C?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,4 @@\n+// PR middle-end/66199\n+// { dg-do run }\n+\n+#include \"../libgomp.c/pr66199-8.c\""}, {"sha": "1f8dfa302cff2b6ce3fb4246fe7cdd2d94ba9674", "filename": "libgomp/testsuite/libgomp.c++/pr66199-9.C", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fpr66199-9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fpr66199-9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fpr66199-9.C?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,4 @@\n+// PR middle-end/66199\n+// { dg-do run }\n+\n+#include \"../libgomp.c/pr66199-9.c\""}, {"sha": "588cc5fd3c395803e68be6230b25da28b8ce368e", "filename": "libgomp/testsuite/libgomp.c++/reduction-11.C", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Freduction-11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Freduction-11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Freduction-11.C?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,121 @@\n+// { dg-do run { xfail *-*-* } }\n+\n+char z[10] = { 0 };\n+\n+__attribute__((noinline, noclone)) void\n+foo (int (*&x)[3][2], int *y, long (&w)[1][2], int s, int t)\n+{\n+  unsigned long long a[9] = {};\n+  short b[5] = {};\n+  #pragma omp parallel for reduction(+:x[-1:2][:][0:2], z[t + 2:4]) \\\n+\t\t\t   reduction(*:y[-s:3]) reduction(|:a[s + 3:4]) \\\n+\t\t\t   reduction(&:w[s + 1:][t:2]) reduction(max:b[2:])\n+  for (int i = 0; i < 128; i++)\n+    {\n+      x[i / 64 - 1][i % 3][(i / 4) & 1] += i;\n+      if ((i & 15) == 1)\n+\ty[1] *= 3;\n+      if ((i & 31) == 2)\n+\ty[2] *= 7;\n+      if ((i & 63) == 3)\n+\ty[3] *= 17;\n+      z[i / 32 + 2] += (i & 3);\n+      if (i < 4)\n+\tz[i + 2] += i;\n+      a[i / 32 + 2] |= 1ULL << (i & 30);\n+      w[0][i & 1] &= ~(1L << (i / 17 * 3));\n+      if ((i % 23) > b[2])\n+\tb[2] = i % 23;\n+      if ((i % 85) > b[3])\n+\tb[3] = i % 85;\n+      if ((i % 192) > b[4])\n+\tb[4] = i % 192;\n+    }\n+  for (int i = 0; i < 9; i++)\n+    if (a[i] != ((i < 6 && i >= 2) ? 0x55555555ULL : 0))\n+      __builtin_abort ();\n+  if (b[0] != 0 || b[1] != 0 || b[2] != 22 || b[3] != 84 || b[4] != 127)\n+    __builtin_abort ();\n+}\n+\n+int a3[4][3][2];\n+int (*p3)[3][2] = &a3[2];\n+int y3[5] = { 0, 1, 1, 1, 0 };\n+long w3[1][2] = { ~0L, ~0L };\n+short bb[5];\n+\n+struct S\n+{\n+  int (*&x)[3][2];\n+  int *y;\n+  long (&w)[1][2];\n+  char z[10];\n+  short (&b)[5];\n+  unsigned long long a[9];\n+  S() : x(p3), y(y3), w(w3), z(), a(), b(bb) {}\n+  __attribute__((noinline, noclone)) void foo (int s, int t);\n+};\n+\n+void\n+S::foo (int s, int t)\n+{\n+  #pragma omp parallel for reduction(+:x[-1:2][:][0:2], z[t + 2:4]) \\\n+\t\t\t   reduction(*:y[-s:3]) reduction(|:a[s + 3:4]) \\\n+\t\t\t   reduction(&:w[s + 1:][t:2]) reduction(max:b[2:])\n+  for (int i = 0; i < 128; i++)\n+    {\n+      x[i / 64 - 1][i % 3][(i / 4) & 1] += i;\n+      if ((i & 15) == 1)\n+\ty[1] *= 3;\n+      if ((i & 31) == 2)\n+\ty[2] *= 7;\n+      if ((i & 63) == 3)\n+\ty[3] *= 17;\n+      z[i / 32 + 2] += (i & 3);\n+      if (i < 4)\n+\tz[i + 2] += i;\n+      a[i / 32 + 2] |= 1ULL << (i & 30);\n+      w[0][i & 1] &= ~(1L << (i / 17 * 3));\n+      if ((i % 23) > b[2])\n+\tb[2] = i % 23;\n+      if ((i % 85) > b[3])\n+\tb[3] = i % 85;\n+      if ((i % 192) > b[4])\n+\tb[4] = i % 192;\n+    }\n+}\n+\n+int\n+main ()\n+{\n+  int a[4][3][2] = {};\n+  static int a2[4][3][2] = {{{ 0, 0 }, { 0, 0 }, { 0, 0 }},\n+\t\t\t    {{ 312, 381 }, { 295, 356 }, { 337, 335 }},\n+\t\t\t    {{ 1041, 975 }, { 1016, 1085 }, { 935, 1060 }},\n+\t\t\t    {{ 0, 0 }, { 0, 0 }, { 0, 0 }}};\n+  int (*p)[3][2] = &a[2];\n+  int y[5] = { 0, 1, 1, 1, 0 };\n+  int y2[5] = { 0, 6561, 2401, 289, 0 };\n+  char z2[10] = { 0, 0, 48, 49, 50, 51, 0, 0, 0, 0 };\n+  long w[1][2] = { ~0L, ~0L };\n+  foo (p, y, w, -1, 0);\n+  if (__builtin_memcmp (a, a2, sizeof (a))\n+      || __builtin_memcmp (y, y2, sizeof (y))\n+      || __builtin_memcmp (z, z2, sizeof (z))\n+      || w[0][0] != ~0x249249L\n+      || w[0][1] != ~0x249249L)\n+    __builtin_abort ();\n+  S s;\n+  s.foo (-1, 0);\n+  for (int i = 0; i < 9; i++)\n+    if (s.a[i] != ((i < 6 && i >= 2) ? 0x55555555ULL : 0))\n+      __builtin_abort ();\n+  if (__builtin_memcmp (a3, a2, sizeof (a3))\n+      || __builtin_memcmp (y3, y2, sizeof (y3))\n+      || __builtin_memcmp (s.z, z2, sizeof (s.z))\n+      || w3[0][0] != ~0x249249L\n+      || w3[0][1] != ~0x249249L)\n+    __builtin_abort ();\n+  if (bb[0] != 0 || bb[1] != 0 || bb[2] != 22 || bb[3] != 84 || bb[4] != 127)\n+    __builtin_abort ();\n+}"}, {"sha": "744798a91e86db6eb8c1817419f0fd2df0be73ab", "filename": "libgomp/testsuite/libgomp.c++/reduction-12.C", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Freduction-12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Freduction-12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Freduction-12.C?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,195 @@\n+// { dg-do run { xfail *-*-* } }\n+\n+template <typename T>\n+struct A\n+{\n+  A () { t = 0; }\n+  A (T x) { t = x; }\n+  A (const A &x) { t = x.t; }\n+  ~A () {}\n+  T t;\n+};\n+template <typename T>\n+struct M\n+{\n+  M () { t = 1; }\n+  M (T x) { t = x; }\n+  M (const M &x) { t = x.t; }\n+  ~M () {}\n+  T t;\n+};\n+template <typename T>\n+struct B\n+{\n+  B () { t = ~(T) 0; }\n+  B (T x) { t = x; }\n+  B (const B &x) { t = x.t; }\n+  ~B () {}\n+  T t;\n+};\n+template <typename T>\n+void\n+add (T &x, T &y)\n+{\n+  x.t += y.t;\n+}\n+template <typename T>\n+void\n+zero (T &x)\n+{\n+  x.t = 0;\n+}\n+template <typename T>\n+void\n+orit (T *x, T *y)\n+{\n+  y->t |= x->t;\n+}\n+B<long> bb;\n+#pragma omp declare reduction(+:A<int>:omp_out.t += omp_in.t)\n+#pragma omp declare reduction(+:A<char>:add (omp_out, omp_in)) initializer(zero (omp_priv))\n+#pragma omp declare reduction(*:M<int>:omp_out.t *= omp_in.t) initializer(omp_priv = 1)\n+#pragma omp declare reduction(|:A<unsigned long long>:orit (&omp_in, &omp_out))\n+#pragma omp declare reduction(&:B<long>:omp_out.t = omp_out.t & omp_in.t) initializer(orit (&omp_priv, &omp_orig))\n+#pragma omp declare reduction(maxb:short:omp_out = omp_in > omp_out ? omp_in : omp_out) initializer(omp_priv = -6)\n+\n+A<char> z[10];\n+\n+template <int N>\n+__attribute__((noinline, noclone)) void\n+foo (A<int> (*&x)[3][N], M<int> *y, B<long> (&w)[1][N], int p1, long p2, long p3, int p4,\n+     int p5, long p6, short p7, int s, int t)\n+{\n+  A<unsigned long long> a[p7 + 4];\n+  short bb[p7];\n+  short (&b)[p7] = bb;\n+  for (int i = 0; i < p7; i++)\n+    bb[i] = -6;\n+  #pragma omp parallel for reduction(+:x[-1:p1 + 1][:p2 + N - 2], z[t + N:p3]) \\\n+\t\t\t   reduction(*:y[-s:p4]) reduction(|:a[s + 3:p5 - N + 2]) \\\n+\t\t\t   reduction(&:w[s + 1:p6 - 3 + N][t:p6]) reduction(maxb:b[N:])\n+  for (int i = 0; i < 128; i++)\n+    {\n+      x[i / 64 - 1][i % 3][(i / 4) & 1].t += i;\n+      if ((i & 15) == 1)\n+\ty[1].t *= 3;\n+      if ((i & 31) == N)\n+\ty[2].t *= 7;\n+      if ((i & 63) == 3)\n+\ty[N + 1].t *= 17;\n+      z[i / 32 + 2].t += (i & 3);\n+      if (i < 4)\n+\tz[i + N].t += i;\n+      a[i / 32 + 2].t |= 1ULL << (i & 30);\n+      w[0][i & 1].t &= ~(1L << (i / 17 * 3));\n+      if ((i % 23) > b[N])\n+\tb[N] = i % 23;\n+      if ((i % 85) > b[3])\n+\tb[3] = i % 85;\n+      if ((i % 192) > b[4])\n+\tb[4] = i % 192;\n+    }\n+  for (int i = 0; i < 9; i++)\n+    if (a[i].t != ((i < 6 && i >= 2) ? 0x55555555ULL : 0))\n+      __builtin_abort ();\n+  if (bb[0] != -6 || bb[1] != -6 || bb[N] != 22 || bb[3] != 84 || bb[4] != 127)\n+    __builtin_abort ();\n+}\n+\n+A<int> a3[4][3][2];\n+A<int> (*p3)[3][2] = &a3[2];\n+M<int> y3[5] = { 0, 1, 1, 1, 0 };\n+B<long> w3[1][2];\n+\n+template <int N>\n+struct S\n+{\n+  A<int> (*&x)[3][N];\n+  M<int> *y;\n+  B<long> (&w)[1][N];\n+  A<char> z[10];\n+  short b[5];\n+  A<unsigned long long> a[9];\n+  S() : x(p3), y(y3), w(w3), z(), a(), b() {}\n+  __attribute__((noinline, noclone)) void foo (int, long, long, int, int, long, short, int, int);\n+};\n+\n+template <int N>\n+void\n+S<N>::foo (int p1, long p2, long p3, int p4, int p5, long p6, short p7, int s, int t)\n+{\n+  #pragma omp parallel for reduction(+:x[-1:p1 + 1][:p2][0:N], z[t + N:p3 + N - 2]) \\\n+\t\t\t   reduction(*:y[-s:p4]) reduction(|:a[s + 3:p5]) \\\n+\t\t\t   reduction(&:w[s + 1:p6 - 3 + N][t:p6]) reduction(maxb:b[N:])\n+  for (int i = 0; i < 128; i++)\n+    {\n+      x[i / 64 - 1][i % 3][(i / 4) & 1].t += i;\n+      if ((i & 15) == 1)\n+\ty[1].t *= 3;\n+      if ((i & 31) == N)\n+\ty[2].t *= 7;\n+      if ((i & 63) == 3)\n+\ty[N + 1].t *= 17;\n+      z[i / 32 + 2].t += (i & 3);\n+      if (i < 4)\n+\tz[i + N].t += i;\n+      a[i / 32 + 2].t |= 1ULL << (i & 30);\n+      w[0][i & 1].t &= ~(1L << (i / 17 * 3));\n+      if ((i % 23) > b[N])\n+\tb[N] = i % 23;\n+      if ((i % 85) > b[3])\n+\tb[3] = i % 85;\n+      if ((i % 192) > b[4])\n+\tb[4] = i % 192;\n+    }\n+}\n+\n+int\n+main ()\n+{\n+  A<int> a[4][3][2];\n+  static int a2[4][3][2] = {{{ 0, 0 }, { 0, 0 }, { 0, 0 }},\n+\t\t\t    {{ 312, 381 }, { 295, 356 }, { 337, 335 }},\n+\t\t\t    {{ 1041, 975 }, { 1016, 1085 }, { 935, 1060 }},\n+\t\t\t    {{ 0, 0 }, { 0, 0 }, { 0, 0 }}};\n+  A<int> (*p)[3][2] = &a[2];\n+  M<int> y[5] = { 0, 1, 1, 1, 0 };\n+  int y2[5] = { 0, 6561, 2401, 289, 0 };\n+  char z2[10] = { 0, 0, 48, 49, 50, 51, 0, 0, 0, 0 };\n+  B<long> w[1][2];\n+  foo<2> (p, y, w, 1, 3L, 4L, 3, 4, 2L, 5, -1, 0);\n+  for (int i = 0; i < 4; i++)\n+    for (int j = 0; j < 3; j++)\n+      for (int k = 0; k < 2; k++)\n+\tif (a[i][j][k].t != a2[i][j][k])\n+\t  __builtin_abort ();\n+  for (int i = 0; i < 5; i++)\n+    if (y[i].t != y2[i])\n+      __builtin_abort ();\n+  for (int i = 0; i < 10; i++)\n+    if (z[i].t != z2[i])\n+      __builtin_abort ();\n+  if (w[0][0].t != ~0x249249L || w[0][1].t != ~0x249249L)\n+    __builtin_abort ();\n+  S<2> s;\n+  s.foo (1, 3L, 4L, 3, 4, 2L, 5, -1, 0);\n+  for (int i = 0; i < 9; i++)\n+    if (s.a[i].t != ((i < 6 && i >= 2) ? 0x55555555ULL : 0))\n+      __builtin_abort ();\n+  for (int i = 0; i < 4; i++)\n+    for (int j = 0; j < 3; j++)\n+      for (int k = 0; k < 2; k++)\n+\tif (a3[i][j][k].t != a2[i][j][k])\n+\t  __builtin_abort ();\n+  for (int i = 0; i < 5; i++)\n+    if (y3[i].t != y2[i])\n+      __builtin_abort ();\n+  for (int i = 0; i < 10; i++)\n+    if (s.z[i].t != z2[i])\n+      __builtin_abort ();\n+  if (w3[0][0].t != ~0x249249L || w3[0][1].t != ~0x249249L)\n+    __builtin_abort ();\n+  if (s.b[0] != 0 || s.b[1] != 0 || s.b[2] != 22\n+      || s.b[3] != 84 || s.b[4] != 127)\n+    __builtin_abort ();\n+}"}, {"sha": "5279ac026840098c23fa8d587f369a9b3c4934a9", "filename": "libgomp/testsuite/libgomp.c++/target-13.C", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-13.C?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,36 @@\n+extern \"C\" void abort (void);\n+\n+int g;\n+#pragma omp declare target (g)\n+\n+#pragma omp declare target\n+int\n+foo (void)\n+{\n+  static int s;\n+  return ++s + g;\n+}\n+#pragma omp end declare target\n+\n+int\n+bar (void)\n+{\n+  static int s;\n+  #pragma omp declare target to (s)\n+  return ++s;\n+}\n+#pragma omp declare target (bar)\n+\n+int\n+main ()\n+{\n+  int r;\n+  #pragma omp target map(from:r)\n+  {\n+    r = (foo () == 1) + (bar () == 1);\n+    r += (foo () == 2) + (bar () == 2);\n+  }\n+  if (r != 4)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "fa0695737e2ba558b741b62452b1279b201b5400", "filename": "libgomp/testsuite/libgomp.c++/target-14.C", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-14.C?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,110 @@\n+extern \"C\" void abort ();\n+int x;\n+\n+__attribute__((noinline, noclone)) void\n+foo (int &a, int (&b)[10], short &c, long (&d)[5], int n)\n+{\n+  int err;\n+  int &t = x;\n+  int y[n + 1];\n+  int (&z)[n + 1] = y;\n+  for (int i = 0; i < n + 1; i++)\n+    z[i] = i + 27;\n+  #pragma omp target enter data map (to: z, c) map (alloc: b, t)\n+  #pragma omp target update to (b, t)\n+  #pragma omp target map (tofrom: a, d) map (from: b, c) map (alloc: t, z) map (from: err)\n+  {\n+    err = a++ != 7;\n+    for (int i = 0; i < 10; i++)\n+      {\n+\terr |= b[i] != 10 - i;\n+\tb[i] = i - 16;\n+\tif (i >= 6) continue;\n+\terr |= z[i] != i + 27;\n+\tz[i] = 2 * i + 9;\n+\tif (i == 5) continue;\n+\terr |= d[i] != 12L + i;\n+\td[i] = i + 7;\n+      }\n+    err |= c != 25;\n+    c = 142;\n+    err |= t != 8;\n+    t = 19;\n+  }\n+  if (err) abort ();\n+  #pragma omp target update from (z, c)\n+  #pragma omp target exit data map (from: b, t) map (release: z, c)\n+  if (a != 8 || c != 142 || t != 19)\n+    abort ();\n+  a = 29;\n+  c = 149;\n+  t = 15;\n+  for (int i = 0; i < 10; i++)\n+    {\n+      if (b[i] != i - 16) abort ();\n+      b[i] = i ^ 1;\n+      if (i >= 6) continue;\n+      if (z[i] != 2 * i + 9) abort ();\n+      z[i]++;\n+      if (i == 5) continue;\n+      if (d[i] != i + 7) abort ();\n+      d[i] = 7 - i;\n+    }\n+  #pragma omp target defaultmap(tofrom: scalar)\n+  {\n+    err = a++ != 29;\n+    for (int i = 0; i < 10; i++)\n+      {\n+\terr |= b[i] != i ^ 1;\n+\tb[i] = i + 5;\n+\tif (i >= 6) continue;\n+\terr |= z[i] != 2 * i + 10;\n+\tz[i] = 9 - 3 * i;\n+\tif (i == 5) continue;\n+\terr |= d[i] != 7L - i;\n+\td[i] = i;\n+      }\n+    err |= c != 149;\n+    c = -2;\n+    err |= t != 15;\n+    t = 155;\n+  }\n+  if (err || a != 30 || c != -2 || t != 155)\n+    abort ();\n+  for (int i = 0; i < 10; i++)\n+    {\n+      if (b[i] != i + 5) abort ();\n+      if (i >= 6) continue;\n+      if (z[i] != 9 - 3 * i) abort ();\n+      z[i]++;\n+      if (i == 5) continue;\n+      if (d[i] != i) abort ();\n+    }\n+  #pragma omp target data map (alloc: z)\n+  {\n+    #pragma omp target update to (z)\n+    #pragma omp target map(from: err)\n+    {\n+      err = 0;\n+      for (int i = 0; i < 6; i++)\n+\tif (z[i] != 10 - 3 * i) err = 1;\n+\telse z[i] = i;\n+    }\n+    if (err) abort ();\n+    #pragma omp target update from (z)\n+  }\n+  for (int i = 0; i < 6; i++)\n+    if (z[i] != i)\n+      abort ();\n+}\n+\n+int\n+main ()\n+{\n+  int a = 7;\n+  int b[10] = { 10, 9, 8, 7, 6, 5, 4, 3, 2, 1 };\n+  short c = 25;\n+  long d[5] = { 12, 13, 14, 15, 16 };\n+  x = 8;\n+  foo (a, b, c, d, 5);\n+}"}, {"sha": "4b320c312296a9cf7dff5e8ba6473e8686b53e10", "filename": "libgomp/testsuite/libgomp.c++/target-15.C", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-15.C?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,168 @@\n+#include <omp.h>\n+#include <stdlib.h>\n+\n+struct S { char p[64]; int a; int b[2]; long c[4]; int *d; unsigned char &e; char (&f)[2]; short (&g)[4]; int *&h; char q[64]; };\n+\n+__attribute__((noinline, noclone)) void\n+foo (S s)\n+{\n+  int d = omp_get_default_device ();\n+  int id = omp_get_initial_device ();\n+  int sep = 1;\n+\n+  if (d < 0 || d >= omp_get_num_devices ())\n+    d = id;\n+\n+  int err;\n+  #pragma omp target map(tofrom: s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3]) map(to: sep) map(from: err)\n+  {\n+    err = s.a != 11 || s.b[0] != 12 || s.b[1] != 13;\n+    err |= s.c[1] != 15 || s.c[2] != 16 || s.d[-2] != 18 || s.d[-1] != 19 || s.d[0] != 20;\n+    err |= s.e != 21 || s.f[0] != 22 || s.f[1] != 23 || s.g[1] != 25 || s.g[2] != 26;\n+    err |= s.h[2] != 31 || s.h[3] != 32 || s.h[4] != 33;\n+    s.a = 35; s.b[0] = 36; s.b[1] = 37;\n+    s.c[1] = 38; s.c[2] = 39; s.d[-2] = 40; s.d[-1] = 41; s.d[0] = 42;\n+    s.e = 43; s.f[0] = 44; s.f[1] = 45; s.g[1] = 46; s.g[2] = 47;\n+    s.h[2] = 48; s.h[3] = 49; s.h[4] = 50;\n+    sep = 0;\n+  }\n+  if (err) abort ();\n+  err = s.a != 35 || s.b[0] != 36 || s.b[1] != 37;\n+  err |= s.c[1] != 38 || s.c[2] != 39 || s.d[-2] != 40 || s.d[-1] != 41 || s.d[0] != 42;\n+  err |= s.e != 43 || s.f[0] != 44 || s.f[1] != 45 || s.g[1] != 46 || s.g[2] != 47;\n+  err |= s.h[2] != 48 || s.h[3] != 49 || s.h[4] != 50;\n+  if (err) abort ();\n+  s.a = 50; s.b[0] = 49; s.b[1] = 48;\n+  s.c[1] = 47; s.c[2] = 46; s.d[-2] = 45; s.d[-1] = 44; s.d[0] = 43;\n+  s.e = 42; s.f[0] = 41; s.f[1] = 40; s.g[1] = 39; s.g[2] = 38;\n+  s.h[2] = 37; s.h[3] = 36; s.h[4] = 35;\n+  if (sep\n+      && (omp_target_is_present (&s.a, d)\n+\t  || omp_target_is_present (s.b, d)\n+\t  || omp_target_is_present (&s.c[1], d)\n+\t  || omp_target_is_present (s.d, d)\n+\t  || omp_target_is_present (&s.d[-2], d)\n+\t  || omp_target_is_present (&s.e, d)\n+\t  || omp_target_is_present (s.f, d)\n+\t  || omp_target_is_present (&s.g[1], d)\n+\t  || omp_target_is_present (&s.h, d)\n+\t  || omp_target_is_present (&s.h[2], d)))\n+    abort ();\n+  #pragma omp target data map(alloc: s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3])\n+  {\n+    if (!omp_target_is_present (&s.a, d)\n+\t|| !omp_target_is_present (s.b, d)\n+\t|| !omp_target_is_present (&s.c[1], d)\n+\t|| !omp_target_is_present (s.d, d)\n+\t|| !omp_target_is_present (&s.d[-2], d)\n+\t|| !omp_target_is_present (&s.e, d)\n+\t|| !omp_target_is_present (s.f, d)\n+\t|| !omp_target_is_present (&s.g[1], d)\n+\t|| !omp_target_is_present (&s.h, d)\n+\t|| !omp_target_is_present (&s.h[2], d))\n+      abort ();\n+    #pragma omp target update to(s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3])\n+    #pragma omp target map(alloc: s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3]) map(from: err)\n+    {\n+      err = s.a != 50 || s.b[0] != 49 || s.b[1] != 48;\n+      err |= s.c[1] != 47 || s.c[2] != 46 || s.d[-2] != 45 || s.d[-1] != 44 || s.d[0] != 43;\n+      err |= s.e != 42 || s.f[0] != 41 || s.f[1] != 40 || s.g[1] != 39 || s.g[2] != 38;\n+      err |= s.h[2] != 37 || s.h[3] != 36 || s.h[4] != 35;\n+      s.a = 17; s.b[0] = 18; s.b[1] = 19;\n+      s.c[1] = 20; s.c[2] = 21; s.d[-2] = 22; s.d[-1] = 23; s.d[0] = 24;\n+      s.e = 25; s.f[0] = 26; s.f[1] = 27; s.g[1] = 28; s.g[2] = 29;\n+      s.h[2] = 30; s.h[3] = 31; s.h[4] = 32;\n+    }\n+    #pragma omp target update from(s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3])\n+  }\n+  if (sep\n+      && (omp_target_is_present (&s.a, d)\n+\t  || omp_target_is_present (s.b, d)\n+\t  || omp_target_is_present (&s.c[1], d)\n+\t  || omp_target_is_present (s.d, d)\n+\t  || omp_target_is_present (&s.d[-2], d)\n+\t  || omp_target_is_present (&s.e, d)\n+\t  || omp_target_is_present (s.f, d)\n+\t  || omp_target_is_present (&s.g[1], d)\n+\t  || omp_target_is_present (&s.h, d)\n+\t  || omp_target_is_present (&s.h[2], d)))\n+    abort ();\n+  if (err) abort ();\n+  err = s.a != 17 || s.b[0] != 18 || s.b[1] != 19;\n+  err |= s.c[1] != 20 || s.c[2] != 21 || s.d[-2] != 22 || s.d[-1] != 23 || s.d[0] != 24;\n+  err |= s.e != 25 || s.f[0] != 26 || s.f[1] != 27 || s.g[1] != 28 || s.g[2] != 29;\n+  err |= s.h[2] != 30 || s.h[3] != 31 || s.h[4] != 32;\n+  if (err) abort ();\n+  s.a = 33; s.b[0] = 34; s.b[1] = 35;\n+  s.c[1] = 36; s.c[2] = 37; s.d[-2] = 38; s.d[-1] = 39; s.d[0] = 40;\n+  s.e = 41; s.f[0] = 42; s.f[1] = 43; s.g[1] = 44; s.g[2] = 45;\n+  s.h[2] = 46; s.h[3] = 47; s.h[4] = 48;\n+  #pragma omp target enter data map(alloc: s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3])\n+  if (!omp_target_is_present (&s.a, d)\n+      || !omp_target_is_present (s.b, d)\n+      || !omp_target_is_present (&s.c[1], d)\n+      || !omp_target_is_present (s.d, d)\n+      || !omp_target_is_present (&s.d[-2], d)\n+      || !omp_target_is_present (&s.e, d)\n+      || !omp_target_is_present (s.f, d)\n+      || !omp_target_is_present (&s.g[1], d)\n+      || !omp_target_is_present (&s.h, d)\n+      || !omp_target_is_present (&s.h[2], d))\n+    abort ();\n+  #pragma omp target enter data map(always, to: s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3])\n+  #pragma omp target map(alloc: s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3]) map(from: err)\n+  {\n+    err = s.a != 33 || s.b[0] != 34 || s.b[1] != 35;\n+    err |= s.c[1] != 36 || s.c[2] != 37 || s.d[-2] != 38 || s.d[-1] != 39 || s.d[0] != 40;\n+    err |= s.e != 41 || s.f[0] != 42 || s.f[1] != 43 || s.g[1] != 44 || s.g[2] != 45;\n+    err |= s.h[2] != 46 || s.h[3] != 47 || s.h[4] != 48;\n+    s.a = 49; s.b[0] = 48; s.b[1] = 47;\n+    s.c[1] = 46; s.c[2] = 45; s.d[-2] = 44; s.d[-1] = 43; s.d[0] = 42;\n+    s.e = 31; s.f[0] = 40; s.f[1] = 39; s.g[1] = 38; s.g[2] = 37;\n+    s.h[2] = 36; s.h[3] = 35; s.h[4] = 34;\n+  }\n+  #pragma omp target exit data map(always, from: s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3])\n+  if (!omp_target_is_present (&s.a, d)\n+      || !omp_target_is_present (s.b, d)\n+      || !omp_target_is_present (&s.c[1], d)\n+      || !omp_target_is_present (s.d, d)\n+      || !omp_target_is_present (&s.d[-2], d)\n+      || !omp_target_is_present (&s.e, d)\n+      || !omp_target_is_present (s.f, d)\n+      || !omp_target_is_present (&s.g[1], d)\n+      || !omp_target_is_present (&s.h, d)\n+      || !omp_target_is_present (&s.h[2], d))\n+    abort ();\n+  #pragma omp target exit data map(release: s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3])\n+  if (sep\n+      && (omp_target_is_present (&s.a, d)\n+\t  || omp_target_is_present (s.b, d)\n+\t  || omp_target_is_present (&s.c[1], d)\n+\t  || omp_target_is_present (s.d, d)\n+\t  || omp_target_is_present (&s.d[-2], d)\n+\t  || omp_target_is_present (&s.e, d)\n+\t  || omp_target_is_present (s.f, d)\n+\t  || omp_target_is_present (&s.g[1], d)\n+\t  || omp_target_is_present (&s.h, d)\n+\t  || omp_target_is_present (&s.h[2], d)))\n+    abort ();\n+  if (err) abort ();\n+  err = s.a != 49 || s.b[0] != 48 || s.b[1] != 47;\n+  err |= s.c[1] != 46 || s.c[2] != 45 || s.d[-2] != 44 || s.d[-1] != 43 || s.d[0] != 42;\n+  err |= s.e != 31 || s.f[0] != 40 || s.f[1] != 39 || s.g[1] != 38 || s.g[2] != 37;\n+  err |= s.h[2] != 36 || s.h[3] != 35 || s.h[4] != 34;\n+  if (err) abort ();\n+}\n+\n+int\n+main ()\n+{\n+  int d[3] = { 18, 19, 20 };\n+  unsigned char e = 21;\n+  char f[2] = { 22, 23 };\n+  short g[4] = { 24, 25, 26, 27 };\n+  int hb[7] = { 28, 29, 30, 31, 32, 33, 34 };\n+  int *h = hb + 1;\n+  S s = { {}, 11, { 12, 13 }, { 14, 15, 16, 17 }, d + 2, e, f, g, h, {} };\n+  foo (s);\n+}"}, {"sha": "cd102d9059438d85213f672a7d786b24e75dd249", "filename": "libgomp/testsuite/libgomp.c++/target-16.C", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-16.C?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,170 @@\n+#include <omp.h>\n+#include <stdlib.h>\n+\n+template <typename C, typename I, typename L, typename UC, typename SH>\n+struct S { C p[64]; I a; I b[2]; L c[4]; I *d; UC &e; C (&f)[2]; SH (&g)[4]; I *&h; C q[64]; };\n+\n+template <typename C, typename I, typename L, typename UC, typename SH>\n+__attribute__((noinline, noclone)) void\n+foo (S<C, I, L, UC, SH> s)\n+{\n+  int d = omp_get_default_device ();\n+  int id = omp_get_initial_device ();\n+  int sep = 1;\n+\n+  if (d < 0 || d >= omp_get_num_devices ())\n+    d = id;\n+\n+  int err;\n+  #pragma omp target map(tofrom: s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3]) map(to: sep) map(from: err)\n+  {\n+    err = s.a != 11 || s.b[0] != 12 || s.b[1] != 13;\n+    err |= s.c[1] != 15 || s.c[2] != 16 || s.d[-2] != 18 || s.d[-1] != 19 || s.d[0] != 20;\n+    err |= s.e != 21 || s.f[0] != 22 || s.f[1] != 23 || s.g[1] != 25 || s.g[2] != 26;\n+    err |= s.h[2] != 31 || s.h[3] != 32 || s.h[4] != 33;\n+    s.a = 35; s.b[0] = 36; s.b[1] = 37;\n+    s.c[1] = 38; s.c[2] = 39; s.d[-2] = 40; s.d[-1] = 41; s.d[0] = 42;\n+    s.e = 43; s.f[0] = 44; s.f[1] = 45; s.g[1] = 46; s.g[2] = 47;\n+    s.h[2] = 48; s.h[3] = 49; s.h[4] = 50;\n+    sep = 0;\n+  }\n+  if (err) abort ();\n+  err = s.a != 35 || s.b[0] != 36 || s.b[1] != 37;\n+  err |= s.c[1] != 38 || s.c[2] != 39 || s.d[-2] != 40 || s.d[-1] != 41 || s.d[0] != 42;\n+  err |= s.e != 43 || s.f[0] != 44 || s.f[1] != 45 || s.g[1] != 46 || s.g[2] != 47;\n+  err |= s.h[2] != 48 || s.h[3] != 49 || s.h[4] != 50;\n+  if (err) abort ();\n+  s.a = 50; s.b[0] = 49; s.b[1] = 48;\n+  s.c[1] = 47; s.c[2] = 46; s.d[-2] = 45; s.d[-1] = 44; s.d[0] = 43;\n+  s.e = 42; s.f[0] = 41; s.f[1] = 40; s.g[1] = 39; s.g[2] = 38;\n+  s.h[2] = 37; s.h[3] = 36; s.h[4] = 35;\n+  if (sep\n+      && (omp_target_is_present (&s.a, d)\n+\t  || omp_target_is_present (s.b, d)\n+\t  || omp_target_is_present (&s.c[1], d)\n+\t  || omp_target_is_present (s.d, d)\n+\t  || omp_target_is_present (&s.d[-2], d)\n+\t  || omp_target_is_present (&s.e, d)\n+\t  || omp_target_is_present (s.f, d)\n+\t  || omp_target_is_present (&s.g[1], d)\n+\t  || omp_target_is_present (&s.h, d)\n+\t  || omp_target_is_present (&s.h[2], d)))\n+    abort ();\n+  #pragma omp target data map(alloc: s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3])\n+  {\n+    if (!omp_target_is_present (&s.a, d)\n+\t|| !omp_target_is_present (s.b, d)\n+\t|| !omp_target_is_present (&s.c[1], d)\n+\t|| !omp_target_is_present (s.d, d)\n+\t|| !omp_target_is_present (&s.d[-2], d)\n+\t|| !omp_target_is_present (&s.e, d)\n+\t|| !omp_target_is_present (s.f, d)\n+\t|| !omp_target_is_present (&s.g[1], d)\n+\t|| !omp_target_is_present (&s.h, d)\n+\t|| !omp_target_is_present (&s.h[2], d))\n+      abort ();\n+    #pragma omp target update to(s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3])\n+    #pragma omp target map(alloc: s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3]) map(from: err)\n+    {\n+      err = s.a != 50 || s.b[0] != 49 || s.b[1] != 48;\n+      err |= s.c[1] != 47 || s.c[2] != 46 || s.d[-2] != 45 || s.d[-1] != 44 || s.d[0] != 43;\n+      err |= s.e != 42 || s.f[0] != 41 || s.f[1] != 40 || s.g[1] != 39 || s.g[2] != 38;\n+      err |= s.h[2] != 37 || s.h[3] != 36 || s.h[4] != 35;\n+      s.a = 17; s.b[0] = 18; s.b[1] = 19;\n+      s.c[1] = 20; s.c[2] = 21; s.d[-2] = 22; s.d[-1] = 23; s.d[0] = 24;\n+      s.e = 25; s.f[0] = 26; s.f[1] = 27; s.g[1] = 28; s.g[2] = 29;\n+      s.h[2] = 30; s.h[3] = 31; s.h[4] = 32;\n+    }\n+    #pragma omp target update from(s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3])\n+  }\n+  if (sep\n+      && (omp_target_is_present (&s.a, d)\n+\t  || omp_target_is_present (s.b, d)\n+\t  || omp_target_is_present (&s.c[1], d)\n+\t  || omp_target_is_present (s.d, d)\n+\t  || omp_target_is_present (&s.d[-2], d)\n+\t  || omp_target_is_present (&s.e, d)\n+\t  || omp_target_is_present (s.f, d)\n+\t  || omp_target_is_present (&s.g[1], d)\n+\t  || omp_target_is_present (&s.h, d)\n+\t  || omp_target_is_present (&s.h[2], d)))\n+    abort ();\n+  if (err) abort ();\n+  err = s.a != 17 || s.b[0] != 18 || s.b[1] != 19;\n+  err |= s.c[1] != 20 || s.c[2] != 21 || s.d[-2] != 22 || s.d[-1] != 23 || s.d[0] != 24;\n+  err |= s.e != 25 || s.f[0] != 26 || s.f[1] != 27 || s.g[1] != 28 || s.g[2] != 29;\n+  err |= s.h[2] != 30 || s.h[3] != 31 || s.h[4] != 32;\n+  if (err) abort ();\n+  s.a = 33; s.b[0] = 34; s.b[1] = 35;\n+  s.c[1] = 36; s.c[2] = 37; s.d[-2] = 38; s.d[-1] = 39; s.d[0] = 40;\n+  s.e = 41; s.f[0] = 42; s.f[1] = 43; s.g[1] = 44; s.g[2] = 45;\n+  s.h[2] = 46; s.h[3] = 47; s.h[4] = 48;\n+  #pragma omp target enter data map(alloc: s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3])\n+  if (!omp_target_is_present (&s.a, d)\n+      || !omp_target_is_present (s.b, d)\n+      || !omp_target_is_present (&s.c[1], d)\n+      || !omp_target_is_present (s.d, d)\n+      || !omp_target_is_present (&s.d[-2], d)\n+      || !omp_target_is_present (&s.e, d)\n+      || !omp_target_is_present (s.f, d)\n+      || !omp_target_is_present (&s.g[1], d)\n+      || !omp_target_is_present (&s.h, d)\n+      || !omp_target_is_present (&s.h[2], d))\n+    abort ();\n+  #pragma omp target enter data map(always, to: s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3])\n+  #pragma omp target map(alloc: s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3]) map(from: err)\n+  {\n+    err = s.a != 33 || s.b[0] != 34 || s.b[1] != 35;\n+    err |= s.c[1] != 36 || s.c[2] != 37 || s.d[-2] != 38 || s.d[-1] != 39 || s.d[0] != 40;\n+    err |= s.e != 41 || s.f[0] != 42 || s.f[1] != 43 || s.g[1] != 44 || s.g[2] != 45;\n+    err |= s.h[2] != 46 || s.h[3] != 47 || s.h[4] != 48;\n+    s.a = 49; s.b[0] = 48; s.b[1] = 47;\n+    s.c[1] = 46; s.c[2] = 45; s.d[-2] = 44; s.d[-1] = 43; s.d[0] = 42;\n+    s.e = 31; s.f[0] = 40; s.f[1] = 39; s.g[1] = 38; s.g[2] = 37;\n+    s.h[2] = 36; s.h[3] = 35; s.h[4] = 34;\n+  }\n+  #pragma omp target exit data map(always, from: s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3])\n+  if (!omp_target_is_present (&s.a, d)\n+      || !omp_target_is_present (s.b, d)\n+      || !omp_target_is_present (&s.c[1], d)\n+      || !omp_target_is_present (s.d, d)\n+      || !omp_target_is_present (&s.d[-2], d)\n+      || !omp_target_is_present (&s.e, d)\n+      || !omp_target_is_present (s.f, d)\n+      || !omp_target_is_present (&s.g[1], d)\n+      || !omp_target_is_present (&s.h, d)\n+      || !omp_target_is_present (&s.h[2], d))\n+    abort ();\n+  #pragma omp target exit data map(release: s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3])\n+  if (sep\n+      && (omp_target_is_present (&s.a, d)\n+\t  || omp_target_is_present (s.b, d)\n+\t  || omp_target_is_present (&s.c[1], d)\n+\t  || omp_target_is_present (s.d, d)\n+\t  || omp_target_is_present (&s.d[-2], d)\n+\t  || omp_target_is_present (&s.e, d)\n+\t  || omp_target_is_present (s.f, d)\n+\t  || omp_target_is_present (&s.g[1], d)\n+\t  || omp_target_is_present (&s.h, d)\n+\t  || omp_target_is_present (&s.h[2], d)))\n+    abort ();\n+  if (err) abort ();\n+  err = s.a != 49 || s.b[0] != 48 || s.b[1] != 47;\n+  err |= s.c[1] != 46 || s.c[2] != 45 || s.d[-2] != 44 || s.d[-1] != 43 || s.d[0] != 42;\n+  err |= s.e != 31 || s.f[0] != 40 || s.f[1] != 39 || s.g[1] != 38 || s.g[2] != 37;\n+  err |= s.h[2] != 36 || s.h[3] != 35 || s.h[4] != 34;\n+  if (err) abort ();\n+}\n+\n+int\n+main ()\n+{\n+  int d[3] = { 18, 19, 20 };\n+  unsigned char e = 21;\n+  char f[2] = { 22, 23 };\n+  short g[4] = { 24, 25, 26, 27 };\n+  int hb[7] = { 28, 29, 30, 31, 32, 33, 34 };\n+  int *h = hb + 1;\n+  S<char, int, long, unsigned char, short> s = { {}, 11, { 12, 13 }, { 14, 15, 16, 17 }, d + 2, e, f, g, h, {} };\n+  foo (s);\n+}"}, {"sha": "d81ff19a41110ba06ba5b88ea8b8476f30cde1cf", "filename": "libgomp/testsuite/libgomp.c++/target-17.C", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-17.C?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,173 @@\n+#include <omp.h>\n+#include <stdlib.h>\n+\n+template <typename C, typename I, typename L, typename UCR, typename CAR, typename SH, typename IPR>\n+struct S { C p[64]; I a; I b[2]; L c[4]; I *d; UCR e; CAR f; SH g; IPR h; C q[64]; };\n+\n+template <typename C, typename I, typename L, typename UCR, typename CAR, typename SH, typename IPR>\n+__attribute__((noinline, noclone)) void\n+foo (S<C, I, L, UCR, CAR, SH, IPR> s)\n+{\n+  int d = omp_get_default_device ();\n+  int id = omp_get_initial_device ();\n+  int sep = 1;\n+\n+  if (d < 0 || d >= omp_get_num_devices ())\n+    d = id;\n+\n+  int err;\n+  #pragma omp target map(tofrom: s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3]) map(to: sep) map(from: err)\n+  {\n+    err = s.a != 11 || s.b[0] != 12 || s.b[1] != 13;\n+    err |= s.c[1] != 15 || s.c[2] != 16 || s.d[-2] != 18 || s.d[-1] != 19 || s.d[0] != 20;\n+    err |= s.e != 21 || s.f[0] != 22 || s.f[1] != 23 || s.g[1] != 25 || s.g[2] != 26;\n+    err |= s.h[2] != 31 || s.h[3] != 32 || s.h[4] != 33;\n+    s.a = 35; s.b[0] = 36; s.b[1] = 37;\n+    s.c[1] = 38; s.c[2] = 39; s.d[-2] = 40; s.d[-1] = 41; s.d[0] = 42;\n+    s.e = 43; s.f[0] = 44; s.f[1] = 45; s.g[1] = 46; s.g[2] = 47;\n+    s.h[2] = 48; s.h[3] = 49; s.h[4] = 50;\n+    sep = 0;\n+  }\n+  if (err) abort ();\n+  err = s.a != 35 || s.b[0] != 36 || s.b[1] != 37;\n+  err |= s.c[1] != 38 || s.c[2] != 39 || s.d[-2] != 40 || s.d[-1] != 41 || s.d[0] != 42;\n+  err |= s.e != 43 || s.f[0] != 44 || s.f[1] != 45 || s.g[1] != 46 || s.g[2] != 47;\n+  err |= s.h[2] != 48 || s.h[3] != 49 || s.h[4] != 50;\n+  if (err) abort ();\n+  s.a = 50; s.b[0] = 49; s.b[1] = 48;\n+  s.c[1] = 47; s.c[2] = 46; s.d[-2] = 45; s.d[-1] = 44; s.d[0] = 43;\n+  s.e = 42; s.f[0] = 41; s.f[1] = 40; s.g[1] = 39; s.g[2] = 38;\n+  s.h[2] = 37; s.h[3] = 36; s.h[4] = 35;\n+  if (sep\n+      && (omp_target_is_present (&s.a, d)\n+\t  || omp_target_is_present (s.b, d)\n+\t  || omp_target_is_present (&s.c[1], d)\n+\t  || omp_target_is_present (s.d, d)\n+\t  || omp_target_is_present (&s.d[-2], d)\n+\t  || omp_target_is_present (&s.e, d)\n+\t  || omp_target_is_present (s.f, d)\n+\t  || omp_target_is_present (&s.g[1], d)\n+\t  || omp_target_is_present (&s.h, d)\n+\t  || omp_target_is_present (&s.h[2], d)))\n+    abort ();\n+  #pragma omp target data map(alloc: s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3])\n+  {\n+    if (!omp_target_is_present (&s.a, d)\n+\t|| !omp_target_is_present (s.b, d)\n+\t|| !omp_target_is_present (&s.c[1], d)\n+\t|| !omp_target_is_present (s.d, d)\n+\t|| !omp_target_is_present (&s.d[-2], d)\n+\t|| !omp_target_is_present (&s.e, d)\n+\t|| !omp_target_is_present (s.f, d)\n+\t|| !omp_target_is_present (&s.g[1], d)\n+\t|| !omp_target_is_present (&s.h, d)\n+\t|| !omp_target_is_present (&s.h[2], d))\n+      abort ();\n+    #pragma omp target update to(s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3])\n+    #pragma omp target map(alloc: s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3]) map(from: err)\n+    {\n+      err = s.a != 50 || s.b[0] != 49 || s.b[1] != 48;\n+      err |= s.c[1] != 47 || s.c[2] != 46 || s.d[-2] != 45 || s.d[-1] != 44 || s.d[0] != 43;\n+      err |= s.e != 42 || s.f[0] != 41 || s.f[1] != 40 || s.g[1] != 39 || s.g[2] != 38;\n+      err |= s.h[2] != 37 || s.h[3] != 36 || s.h[4] != 35;\n+      s.a = 17; s.b[0] = 18; s.b[1] = 19;\n+      s.c[1] = 20; s.c[2] = 21; s.d[-2] = 22; s.d[-1] = 23; s.d[0] = 24;\n+      s.e = 25; s.f[0] = 26; s.f[1] = 27; s.g[1] = 28; s.g[2] = 29;\n+      s.h[2] = 30; s.h[3] = 31; s.h[4] = 32;\n+    }\n+    #pragma omp target update from(s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3])\n+  }\n+  if (sep\n+      && (omp_target_is_present (&s.a, d)\n+\t  || omp_target_is_present (s.b, d)\n+\t  || omp_target_is_present (&s.c[1], d)\n+\t  || omp_target_is_present (s.d, d)\n+\t  || omp_target_is_present (&s.d[-2], d)\n+\t  || omp_target_is_present (&s.e, d)\n+\t  || omp_target_is_present (s.f, d)\n+\t  || omp_target_is_present (&s.g[1], d)\n+\t  || omp_target_is_present (&s.h, d)\n+\t  || omp_target_is_present (&s.h[2], d)))\n+    abort ();\n+  if (err) abort ();\n+  err = s.a != 17 || s.b[0] != 18 || s.b[1] != 19;\n+  err |= s.c[1] != 20 || s.c[2] != 21 || s.d[-2] != 22 || s.d[-1] != 23 || s.d[0] != 24;\n+  err |= s.e != 25 || s.f[0] != 26 || s.f[1] != 27 || s.g[1] != 28 || s.g[2] != 29;\n+  err |= s.h[2] != 30 || s.h[3] != 31 || s.h[4] != 32;\n+  if (err) abort ();\n+  s.a = 33; s.b[0] = 34; s.b[1] = 35;\n+  s.c[1] = 36; s.c[2] = 37; s.d[-2] = 38; s.d[-1] = 39; s.d[0] = 40;\n+  s.e = 41; s.f[0] = 42; s.f[1] = 43; s.g[1] = 44; s.g[2] = 45;\n+  s.h[2] = 46; s.h[3] = 47; s.h[4] = 48;\n+  #pragma omp target enter data map(alloc: s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3])\n+  if (!omp_target_is_present (&s.a, d)\n+      || !omp_target_is_present (s.b, d)\n+      || !omp_target_is_present (&s.c[1], d)\n+      || !omp_target_is_present (s.d, d)\n+      || !omp_target_is_present (&s.d[-2], d)\n+      || !omp_target_is_present (&s.e, d)\n+      || !omp_target_is_present (s.f, d)\n+      || !omp_target_is_present (&s.g[1], d)\n+      || !omp_target_is_present (&s.h, d)\n+      || !omp_target_is_present (&s.h[2], d))\n+    abort ();\n+  #pragma omp target enter data map(always, to: s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3])\n+  #pragma omp target map(alloc: s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3]) map(from: err)\n+  {\n+    err = s.a != 33 || s.b[0] != 34 || s.b[1] != 35;\n+    err |= s.c[1] != 36 || s.c[2] != 37 || s.d[-2] != 38 || s.d[-1] != 39 || s.d[0] != 40;\n+    err |= s.e != 41 || s.f[0] != 42 || s.f[1] != 43 || s.g[1] != 44 || s.g[2] != 45;\n+    err |= s.h[2] != 46 || s.h[3] != 47 || s.h[4] != 48;\n+    s.a = 49; s.b[0] = 48; s.b[1] = 47;\n+    s.c[1] = 46; s.c[2] = 45; s.d[-2] = 44; s.d[-1] = 43; s.d[0] = 42;\n+    s.e = 31; s.f[0] = 40; s.f[1] = 39; s.g[1] = 38; s.g[2] = 37;\n+    s.h[2] = 36; s.h[3] = 35; s.h[4] = 34;\n+  }\n+  #pragma omp target exit data map(always, from: s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3])\n+  if (!omp_target_is_present (&s.a, d)\n+      || !omp_target_is_present (s.b, d)\n+      || !omp_target_is_present (&s.c[1], d)\n+      || !omp_target_is_present (s.d, d)\n+      || !omp_target_is_present (&s.d[-2], d)\n+      || !omp_target_is_present (&s.e, d)\n+      || !omp_target_is_present (s.f, d)\n+      || !omp_target_is_present (&s.g[1], d)\n+      || !omp_target_is_present (&s.h, d)\n+      || !omp_target_is_present (&s.h[2], d))\n+    abort ();\n+  #pragma omp target exit data map(release: s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3])\n+  if (sep\n+      && (omp_target_is_present (&s.a, d)\n+\t  || omp_target_is_present (s.b, d)\n+\t  || omp_target_is_present (&s.c[1], d)\n+\t  || omp_target_is_present (s.d, d)\n+\t  || omp_target_is_present (&s.d[-2], d)\n+\t  || omp_target_is_present (&s.e, d)\n+\t  || omp_target_is_present (s.f, d)\n+\t  || omp_target_is_present (&s.g[1], d)\n+\t  || omp_target_is_present (&s.h, d)\n+\t  || omp_target_is_present (&s.h[2], d)))\n+    abort ();\n+  if (err) abort ();\n+  err = s.a != 49 || s.b[0] != 48 || s.b[1] != 47;\n+  err |= s.c[1] != 46 || s.c[2] != 45 || s.d[-2] != 44 || s.d[-1] != 43 || s.d[0] != 42;\n+  err |= s.e != 31 || s.f[0] != 40 || s.f[1] != 39 || s.g[1] != 38 || s.g[2] != 37;\n+  err |= s.h[2] != 36 || s.h[3] != 35 || s.h[4] != 34;\n+  if (err) abort ();\n+}\n+\n+int\n+main ()\n+{\n+  int d[3] = { 18, 19, 20 };\n+  unsigned char e = 21;\n+  char f[2] = { 22, 23 };\n+  short g[4] = { 24, 25, 26, 27 };\n+  int hb[7] = { 28, 29, 30, 31, 32, 33, 34 };\n+  int *h = hb + 1;\n+  typedef char (&CAR)[2];\n+  typedef short (&SH)[4];\n+  S<char, int, long, unsigned char &, CAR, SH, int *&> s\n+    = { {}, 11, { 12, 13 }, { 14, 15, 16, 17 }, d + 2, e, f, g, h, {} };\n+  foo (s);\n+}"}, {"sha": "f1085b14022933eca162f0268dd9e9a5b7007f62", "filename": "libgomp/testsuite/libgomp.c++/target-18.C", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-18.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-18.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-18.C?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,167 @@\n+extern \"C\" void abort ();\n+\n+__attribute__((noinline, noclone)) void\n+foo (int *&p, int *&q, int *&r, int n, int m)\n+{\n+  int i, err, *s = r;\n+  int sep = 1;\n+  #pragma omp target map(to:sep)\n+  sep = 0;\n+  #pragma omp target data map(to:p[0:8])\n+  {\n+    /* For zero length array sections, p points to the start of\n+       already mapped range, q to the end of it (with nothing mapped\n+       after it), and r does not point to an mapped range.  */\n+    #pragma omp target map(alloc:p[:0]) map(to:q[:0]) map(from:r[:0]) private(i) map(from:err) firstprivate (s)\n+    {\n+      err = 0;\n+      for (i = 0; i < 8; i++)\n+\tif (p[i] != i + 1)\n+\t  err = 1;\n+      if (sep)\n+\t{\n+\t  if (q != (int *) 0 || r != (int *) 0)\n+\t    err = 1;\n+\t}\n+      else if (p + 8 != q || r != s)\n+\terr = 1;\n+    }\n+    if (err)\n+      abort ();\n+    /* Implicit mapping of pointers behaves the same way.  */\n+    #pragma omp target private(i) map(from:err) firstprivate (s)\n+    {\n+      err = 0;\n+      for (i = 0; i < 8; i++)\n+\tif (p[i] != i + 1)\n+\t  err = 1;\n+      if (sep)\n+\t{\n+\t  if (q != (int *) 0 || r != (int *) 0)\n+\t    err = 1;\n+\t}\n+      else if (p + 8 != q || r != s)\n+\terr = 1;\n+    }\n+    if (err)\n+      abort ();\n+    /* And zero-length array sections, though not known at compile\n+       time, behave the same.  */\n+    #pragma omp target map(p[:n]) map(tofrom:q[:n]) map(alloc:r[:n]) private(i) map(from:err) firstprivate (s)\n+    {\n+      err = 0;\n+      for (i = 0; i < 8; i++)\n+\tif (p[i] != i + 1)\n+\t  err = 1;\n+      if (sep)\n+\t{\n+\t  if (q != (int *) 0 || r != (int *) 0)\n+\t    err = 1;\n+\t}\n+      else if (p + 8 != q || r != s)\n+\terr = 1;\n+    }\n+    if (err)\n+      abort ();\n+    /* Non-zero length array sections, though not known at compile,\n+       behave differently.  */\n+    #pragma omp target map(p[:m]) map(tofrom:q[:m]) map(to:r[:m]) private(i) map(from:err)\n+    {\n+      err = 0;\n+      for (i = 0; i < 8; i++)\n+\tif (p[i] != i + 1)\n+\t  err = 1;\n+      if (q[0] != 9 || r[0] != 10)\n+\terr = 1;\n+    }\n+    if (err)\n+      abort ();\n+    #pragma omp target data map(to:q[0:1])\n+    {\n+      /* For zero length array sections, p points to the start of\n+\t already mapped range, q points to the start of another one,\n+\t and r to the end of the second one.  */\n+      #pragma omp target map(to:p[:0]) map(from:q[:0]) map(tofrom:r[:0]) private(i) map(from:err)\n+      {\n+\terr = 0;\n+\tfor (i = 0; i < 8; i++)\n+\t  if (p[i] != i + 1)\n+\t    err = 1;\n+\tif (q[0] != 9)\n+\t  err = 1;\n+\telse if (sep)\n+\t  {\n+\t    if (r != (int *) 0)\n+\t      err = 1;\n+\t  }\n+\telse if (r != q + 1)\n+\t  err = 1;\n+      }\n+      if (err)\n+\tabort ();\n+      /* Implicit mapping of pointers behaves the same way.  */\n+      #pragma omp target private(i) map(from:err)\n+      {\n+\terr = 0;\n+\tfor (i = 0; i < 8; i++)\n+\t  if (p[i] != i + 1)\n+\t    err = 1;\n+\tif (q[0] != 9)\n+\t  err = 1;\n+\telse if (sep)\n+\t  {\n+\t    if (r != (int *) 0)\n+\t      err = 1;\n+\t  }\n+\telse if (r != q + 1)\n+\t  err = 1;\n+      }\n+      if (err)\n+\tabort ();\n+      /* And zero-length array sections, though not known at compile\n+\t time, behave the same.  */\n+      #pragma omp target map(p[:n]) map(alloc:q[:n]) map(from:r[:n]) private(i) map(from:err)\n+      {\n+\terr = 0;\n+\tfor (i = 0; i < 8; i++)\n+\t  if (p[i] != i + 1)\n+\t    err = 1;\n+\tif (q[0] != 9)\n+\t  err = 1;\n+\telse if (sep)\n+\t  {\n+\t    if (r != (int *) 0)\n+\t      err = 1;\n+\t  }\n+\telse if (r != q + 1)\n+\t  err = 1;\n+      }\n+      if (err)\n+\tabort ();\n+      /* Non-zero length array sections, though not known at compile,\n+\t behave differently.  */\n+      #pragma omp target map(p[:m]) map(alloc:q[:m]) map(tofrom:r[:m]) private(i) map(from:err)\n+      {\n+\terr = 0;\n+\tfor (i = 0; i < 8; i++)\n+\t  if (p[i] != i + 1)\n+\t    err = 1;\n+\tif (q[0] != 9 || r[0] != 10)\n+\t  err = 1;\n+      }\n+      if (err)\n+\tabort ();\n+    }\n+  }\n+}\n+\n+int\n+main ()\n+{\n+  int a[32], i;\n+  for (i = 0; i < 32; i++)\n+    a[i] = i;\n+  int *p = a + 1, *q = a + 9, *r = a + 10;\n+  foo (p, q, r, 0, 1);\n+  return 0;\n+}"}, {"sha": "afa6e68d5cce5c83c00df95edb0fba7285503ba7", "filename": "libgomp/testsuite/libgomp.c++/target-19.C", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-19.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-19.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-19.C?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,59 @@\n+extern \"C\" void abort ();\n+struct S { char a[64]; int (&r)[2]; char b[64]; };\n+\n+__attribute__((noinline, noclone)) void\n+foo (S s, int (&t)[3], int z)\n+{\n+  int err, sep = 1;\n+  // Test that implicit mapping of reference to array does NOT\n+  // behave like zero length array sections.  s.r can't be used\n+  // implicitly, as that means implicit mapping of the whole s\n+  // and trying to dereference the references in there is unspecified.\n+  #pragma omp target map(from: err) map(to: sep)\n+  {\n+    err = t[0] != 1 || t[1] != 2 || t[2] != 3;\n+    sep = 0;\n+  }\n+  if (err) abort ();\n+  // But explicit zero length array section mapping does.\n+  #pragma omp target map(from: err) map(tofrom: s.r[:0], t[:0])\n+  {\n+    if (sep)\n+      err = s.r != (int *) 0 || t != (int *) 0;\n+    else\n+      err = t[0] != 1 || t[1] != 2 || t[2] != 3 || s.r[0] != 6 || s.r[1] != 7;\n+  }\n+  if (err) abort ();\n+  // Similarly zero length array section, but unknown at compile time.\n+  #pragma omp target map(from: err) map(tofrom: s.r[:z], t[:z])\n+  {\n+    if (sep)\n+      err = s.r != (int *) 0 || t != (int *) 0;\n+    else\n+      err = t[0] != 1 || t[1] != 2 || t[2] != 3 || s.r[0] != 6 || s.r[1] != 7;\n+  }\n+  if (err) abort ();\n+  #pragma omp target enter data map (to: s.r, t)\n+  // But when already mapped, it binds to existing mappings.\n+  #pragma omp target map(from: err) map(tofrom: s.r[:0], t[:0])\n+  {\n+    err = t[0] != 1 || t[1] != 2 || t[2] != 3 || s.r[0] != 6 || s.r[1] != 7;\n+    sep = 0;\n+  }\n+  if (err) abort ();\n+  #pragma omp target map(from: err) map(tofrom: s.r[:z], t[:z])\n+  {\n+    err = t[0] != 1 || t[1] != 2 || t[2] != 3 || s.r[0] != 6 || s.r[1] != 7;\n+    sep = 0;\n+  }\n+  if (err) abort ();\n+}\n+\n+int\n+main ()\n+{\n+  int t[3] = { 1, 2, 3 };\n+  int r[2] = { 6, 7 };\n+  S s = { {}, r, {} };\n+  foo (s, t, 0);\n+}"}, {"sha": "c3c0100f052d1039095427ab043edc1bb9dac9f2", "filename": "libgomp/testsuite/libgomp.c/monotonic-1.c", "status": "added", "additions": 303, "deletions": 0, "changes": 303, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2Fmonotonic-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2Fmonotonic-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fmonotonic-1.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,303 @@\n+/* { dg-do run } */\n+\n+#ifndef MONOTONIC_TYPE\n+#include <omp.h>\n+#include <stdlib.h>\n+#define MONOTONIC_TYPE int\n+#define MONOTONIC_UNDEF -1\n+#define MONOTONIC_END(n) n\n+#endif\n+\n+int\n+main ()\n+{\n+  MONOTONIC_TYPE i;\n+  #pragma omp parallel\n+  {\n+    int cnt = omp_get_num_threads ();\n+    int thr = omp_get_thread_num ();\n+    MONOTONIC_TYPE l = MONOTONIC_UNDEF;\n+    int c = 0;\n+    int n = 0;\n+    #pragma omp for nowait schedule(static, 5)\n+    for (i = 0; i < MONOTONIC_END (73); i++)\n+      {\n+\tif (l == MONOTONIC_UNDEF)\n+\t  {\n+\t    n = 1;\n+\t    c++;\n+\t  }\n+\telse if (l == i - 1)\n+\t  n++;\n+\telse\n+\t  {\n+\t    if (l >= i)\n+\t      abort ();\n+\t    if (cnt == 1)\n+\t      abort ();\n+\t    if (n != 5)\n+\t      abort ();\n+\t    n = 1;\n+\t    c++;\n+\t  }\n+\tif (n == 1)\n+\t  {\n+\t    if ((i % 5) != 0)\n+\t      abort ();\n+\t    if ((i / 5) % cnt != thr)\n+\t      abort ();\n+\t  }\n+\tl = i;\n+      }\n+    if (cnt == 1)\n+      {\n+\tif (n != 73 || l != 73 - 1 || c != 1)\n+\t  abort ();\n+      }\n+    else if (thr > 73 / 5)\n+      {\n+\tif (l != MONOTONIC_UNDEF || c != 0 || n != 0)\n+\t  abort ();\n+      }\n+    else if (thr == 73 / 5)\n+      {\n+\tif (l != 73 - 1 || c != 1 || n != 73 % 5)\n+\t  abort ();\n+      }\n+    else if (c == 0)\n+      abort ();\n+    else if (l == 73 - 1)\n+      {\n+\tif (thr != (73 / 5) % cnt || n != 73 % 5)\n+\t  abort ();\n+      }\n+    else if ((n % 5) != 0)\n+      abort ();\n+    l = MONOTONIC_UNDEF;\n+    c = 0;\n+    n = 0;\n+    #pragma omp for schedule( monotonic: static, 7) nowait\n+    for (i = 0; i < MONOTONIC_END (73); i++)\n+      {\n+\tif (l == MONOTONIC_UNDEF)\n+\t  {\n+\t    n = 1;\n+\t    c++;\n+\t  }\n+\telse if (l == i - 1)\n+\t  n++;\n+\telse\n+\t  {\n+\t    if (l >= i)\n+\t      abort ();\n+\t    if (cnt == 1)\n+\t      abort ();\n+\t    if (n != 7)\n+\t      abort ();\n+\t    n = 1;\n+\t    c++;\n+\t  }\n+\tif (n == 1)\n+\t  {\n+\t    if ((i % 7) != 0)\n+\t      abort ();\n+\t    if ((i / 7) % cnt != thr)\n+\t      abort ();\n+\t  }\n+\tl = i;\n+      }\n+    if (cnt == 1)\n+      {\n+\tif (n != 73 || l != 73 - 1 || c != 1)\n+\t  abort ();\n+      }\n+    else if (thr > 73 / 7)\n+      {\n+\tif (l != MONOTONIC_UNDEF || c != 0 || n != 0)\n+\t  abort ();\n+      }\n+    else if (thr == 73 / 7)\n+      {\n+\tif (l != 73 - 1 || c != 1 || n != 73 % 7)\n+\t  abort ();\n+      }\n+    else if (c == 0)\n+      abort ();\n+    else if (l == 73 - 1)\n+      {\n+\tif (thr != (73 / 7) % cnt || n != 73 % 7)\n+\t  abort ();\n+      }\n+    else if ((n % 7) != 0)\n+      abort ();\n+    l = MONOTONIC_UNDEF;\n+    c = 0;\n+    n = 0;\n+    #pragma omp for nowait schedule(static)\n+    for (i = 0; i < MONOTONIC_END (73); i++)\n+      {\n+\tif (l == MONOTONIC_UNDEF)\n+\t  {\n+\t    n = 1;\n+\t    c++;\n+\t  }\n+\telse if (l == i - 1)\n+\t  n++;\n+\telse\n+\t  abort ();\n+\tl = i;\n+      }\n+    if (c > 1)\n+      abort ();\n+    l = MONOTONIC_UNDEF;\n+    c = 0;\n+    n = 0;\n+    #pragma omp for nowait schedule(monotonic,simd:static)\n+    for (i = 0; i < MONOTONIC_END (73); i++)\n+      {\n+\tif (l == MONOTONIC_UNDEF)\n+\t  {\n+\t    n = 1;\n+\t    c++;\n+\t  }\n+\telse if (l == i - 1)\n+\t  n++;\n+\telse\n+\t  abort ();\n+\tl = i;\n+      }\n+    if (c > 1)\n+      abort ();\n+    l = MONOTONIC_UNDEF;\n+    c = 0;\n+    n = 0;\n+    #pragma omp for schedule(monotonic : dynamic, 5) nowait\n+    for (i = 0; i < MONOTONIC_END (73); i++)\n+      {\n+\tif (l == MONOTONIC_UNDEF)\n+\t  {\n+\t    n = 1;\n+\t    c++;\n+\t  }\n+\telse if (l == i - 1)\n+\t  n++;\n+\telse\n+\t  {\n+\t    if (l >= i)\n+\t      abort ();\n+\t    if ((n % 5) != 0 || n == 0)\n+\t      abort ();\n+\t    n = 1;\n+\t    c++;\n+\t  }\n+\tl = i;\n+      }\n+    if (l == 73 - 1)\n+      {\n+\tif (n % 5 != 73 % 5)\n+\t  abort ();\n+      }\n+    else if (l == MONOTONIC_UNDEF)\n+      {\n+\tif (n != 0 || c != 0)\n+\t  abort ();\n+      }\n+    else if ((n % 5) != 0 || n == 0)\n+      abort ();\n+    l = MONOTONIC_UNDEF;\n+    c = 0;\n+    n = 0;\n+    #pragma omp for nowait schedule(dynamic, 7) ordered(1)\n+    for (i = 0; i < MONOTONIC_END (73); i++)\n+      {\n+\tif (l == MONOTONIC_UNDEF)\n+\t  {\n+\t    n = 1;\n+\t    c++;\n+\t  }\n+\telse if (l == i - 1)\n+\t  n++;\n+\telse\n+\t  {\n+\t    if (l >= i)\n+\t      abort ();\n+\t    if ((n % 7) != 0 || n == 0)\n+\t      abort ();\n+\t    n = 1;\n+\t    c++;\n+\t  }\n+\t#pragma omp ordered depend(source)\n+\tif (MONOTONIC_UNDEF > 0)\n+\t  {\n+\t    #pragma omp ordered depend(sink: i)\n+\t  }\n+\telse\n+\t  {\n+\t    #pragma omp ordered depend(sink: i - 1)\n+\t  }\n+\tl = i;\n+      }\n+    if (l == 73 - 1)\n+      {\n+\tif (n % 7 != 73 % 7)\n+\t  abort ();\n+      }\n+    else if (l == MONOTONIC_UNDEF)\n+      {\n+\tif (n != 0 || c != 0)\n+\t  abort ();\n+      }\n+    else if ((n % 7) != 0 || n == 0)\n+      abort ();\n+    l = MONOTONIC_UNDEF;\n+    c = 0;\n+    n = 0;\n+    #pragma omp for schedule (monotonic :guided , 7) nowait\n+    for (i = 0; i < MONOTONIC_END (73); i++)\n+      {\n+\tif (l == MONOTONIC_UNDEF)\n+\t  {\n+\t    n = 1;\n+\t    c++;\n+\t  }\n+\telse if (l == i - 1)\n+\t  n++;\n+\telse\n+\t  {\n+\t    if (l >= i)\n+\t      abort ();\n+\t    if (n < 7)\n+\t      abort ();\n+\t    n = 1;\n+\t    c++;\n+\t  }\n+\tl = i;\n+      }\n+    l = MONOTONIC_UNDEF;\n+    c = 0;\n+    n = 0;\n+    #pragma omp for nowait schedule(guided, 7) ordered\n+    for (i = 0; i < MONOTONIC_END (73); i++)\n+      {\n+\tif (l == MONOTONIC_UNDEF)\n+\t  {\n+\t    n = 1;\n+\t    c++;\n+\t  }\n+\telse if (l == i - 1)\n+\t  n++;\n+\telse\n+\t  {\n+\t    if (l >= i)\n+\t      abort ();\n+\t    if (n < 7)\n+\t      abort ();\n+\t    n = 1;\n+\t    c++;\n+\t  }\n+\t#pragma omp ordered\n+\t  l = i;\n+      }\n+  }\n+  return 0;\n+}"}, {"sha": "b886a24c99ade551d415708f04ebce4911375445", "filename": "libgomp/testsuite/libgomp.c/monotonic-2.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2Fmonotonic-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2Fmonotonic-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fmonotonic-2.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do run } */\n+\n+#include <omp.h>\n+#include <stdlib.h>\n+#define MONOTONIC_TYPE unsigned long long\n+#define MONOTONIC_UNDEF -1ULL\n+#define MONOTONIC_END(n) n + v\n+\n+volatile int v;\n+\n+#include \"monotonic-1.c\""}, {"sha": "fc5e93fe53a0a20024ea02b992c42492034e5c58", "filename": "libgomp/testsuite/libgomp.c/nonmonotonic-1.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2Fnonmonotonic-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2Fnonmonotonic-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fnonmonotonic-1.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-do run } */\n+\n+#ifndef NONMONOTONIC_TYPE\n+#include <omp.h>\n+#include <stdlib.h>\n+#define NONMONOTONIC_TYPE int\n+#define NONMONOTONIC_END(n) n\n+#endif\n+\n+int a[73];\n+\n+int\n+main ()\n+{\n+  NONMONOTONIC_TYPE i;\n+  #pragma omp parallel for schedule(nonmonotonic: dynamic)\n+  for (i = 0; i < NONMONOTONIC_END (73); i++)\n+    a[i]++;\n+  #pragma omp parallel for schedule(nonmonotonic: dynamic, 5)\n+  for (i = 0; i < NONMONOTONIC_END (73); i++)\n+    a[i]++;\n+  #pragma omp parallel for schedule(nonmonotonic: guided)\n+  for (i = 0; i < NONMONOTONIC_END (73); i++)\n+    a[i]++;\n+  #pragma omp parallel for schedule(nonmonotonic: guided, 7)\n+  for (i = 0; i < NONMONOTONIC_END (73); i++)\n+    a[i]++;\n+  #pragma omp parallel\n+  {\n+    int cnt = omp_get_num_threads ();\n+    int thr = omp_get_thread_num ();\n+    if (thr < 73)\n+      a[thr]++;\n+    #pragma omp barrier\n+    #pragma omp for schedule(nonmonotonic: dynamic)\n+    for (i = 0; i < NONMONOTONIC_END (73); i++)\n+      a[i]++;\n+    #pragma omp for schedule(nonmonotonic: dynamic, 7)\n+    for (i = 0; i < NONMONOTONIC_END (73); i++)\n+      a[i]++;\n+    #pragma omp for schedule(nonmonotonic: guided)\n+    for (i = 0; i < NONMONOTONIC_END (73); i++)\n+      a[i]++;\n+    #pragma omp for schedule(nonmonotonic: guided, 5)\n+    for (i = 0; i < NONMONOTONIC_END (73); i++)\n+      a[i]++;\n+    #pragma omp single private (i)\n+    for (i = 0; i < 73; i++)\n+      if (a[i] != 8 + (i < cnt))\n+\tabort ();\n+  }\n+  return 0;\n+}"}, {"sha": "c56fa1dc42a7323e141e22e0014bdbd5e3bdcd87", "filename": "libgomp/testsuite/libgomp.c/nonmonotonic-2.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2Fnonmonotonic-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2Fnonmonotonic-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fnonmonotonic-2.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do run } */\n+\n+#include <omp.h>\n+#include <stdlib.h>\n+#define NONMONOTONIC_TYPE unsigned long long\n+#define NONMONOTONIC_END(n) n + v\n+\n+volatile int v;\n+\n+#include \"nonmonotonic-1.c\""}, {"sha": "7ade43c4c9f10e0582cfdfe21ed501d91f4ee2ee", "filename": "libgomp/testsuite/libgomp.c/pr66199-5.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr66199-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr66199-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr66199-5.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,66 @@\n+/* PR middle-end/66199 */\n+/* { dg-do run } */\n+\n+#pragma omp declare target\n+int u[1024], v[1024], w[1024];\n+#pragma omp end declare target\n+\n+__attribute__((noinline, noclone)) long\n+f1 (long a, long b)\n+{\n+  long d;\n+  #pragma omp target map(from: d)\n+  #pragma omp teams distribute parallel for simd default(none) firstprivate (a, b) shared(u, v, w)\n+  for (d = a; d < b; d++)\n+    u[d] = v[d] + w[d];\n+  return d;\n+}\n+\n+__attribute__((noinline, noclone)) long\n+f2 (long a, long b, long c)\n+{\n+  long d, e;\n+  #pragma omp target map(from: d, e)\n+  #pragma omp teams distribute parallel for simd default(none) firstprivate (a, b, c) shared(u, v, w) linear(d) lastprivate(e)\n+  for (d = a; d < b; d++)\n+    {\n+      u[d] = v[d] + w[d];\n+      e = c + d * 5;\n+    }\n+  return d + e;\n+}\n+\n+__attribute__((noinline, noclone)) long\n+f3 (long a1, long b1, long a2, long b2)\n+{\n+  long d1, d2;\n+  #pragma omp target map(from: d1, d2)\n+  #pragma omp teams distribute parallel for simd default(none) firstprivate (a1, b1, a2, b2) shared(u, v, w) lastprivate(d1, d2) collapse(2)\n+  for (d1 = a1; d1 < b1; d1++)\n+    for (d2 = a2; d2 < b2; d2++)\n+      u[d1 * 32 + d2] = v[d1 * 32 + d2] + w[d1 * 32 + d2];\n+  return d1 + d2;\n+}\n+\n+__attribute__((noinline, noclone)) long\n+f4 (long a1, long b1, long a2, long b2)\n+{\n+  long d1, d2;\n+  #pragma omp target map(from: d1, d2)\n+  #pragma omp teams distribute parallel for simd default(none) firstprivate (a1, b1, a2, b2) shared(u, v, w) collapse(2)\n+  for (d1 = a1; d1 < b1; d1++)\n+    for (d2 = a2; d2 < b2; d2++)\n+      u[d1 * 32 + d2] = v[d1 * 32 + d2] + w[d1 * 32 + d2];\n+  return d1 + d2;\n+}\n+\n+int\n+main ()\n+{\n+  if (f1 (0, 1024) != 1024\n+      || f2 (0, 1024, 17) != 1024 + (17 + 5 * 1023)\n+      || f3 (0, 32, 0, 32) != 64\n+      || f4 (0, 32, 0, 32) != 64)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "6790f7dc270b4ae29f7a120470d26fd717fa1023", "filename": "libgomp/testsuite/libgomp.c/pr66199-6.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr66199-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr66199-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr66199-6.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,42 @@\n+/* PR middle-end/66199 */\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fopenmp\" } */\n+\n+#pragma omp declare target\n+int u[1024], v[1024], w[1024];\n+#pragma omp end declare target\n+\n+__attribute__((noinline, noclone)) long\n+f2 (long a, long b, long c)\n+{\n+  long d, e;\n+  #pragma omp target map(from: d, e)\n+  #pragma omp teams distribute parallel for default(none) firstprivate (a, b, c) shared(u, v, w) lastprivate(d, e)\n+  for (d = a; d < b; d++)\n+    {\n+      u[d] = v[d] + w[d];\n+      e = c + d * 5;\n+    }\n+  return d + e;\n+}\n+\n+__attribute__((noinline, noclone)) long\n+f3 (long a1, long b1, long a2, long b2)\n+{\n+  long d1, d2;\n+  #pragma omp target map(from: d1, d2)\n+  #pragma omp teams distribute parallel for default(none) firstprivate (a1, b1, a2, b2) shared(u, v, w) lastprivate(d1, d2) collapse(2)\n+  for (d1 = a1; d1 < b1; d1++)\n+    for (d2 = a2; d2 < b2; d2++)\n+      u[d1 * 32 + d2] = v[d1 * 32 + d2] + w[d1 * 32 + d2];\n+  return d1 + d2;\n+}\n+\n+int\n+main ()\n+{\n+  if (f2 (0, 1024, 17) != 1024 + (17 + 5 * 1023)\n+      || f3 (0, 32, 0, 32) != 64)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "752367e3ac5dbb9f83ac00186303a5dba7cc3e02", "filename": "libgomp/testsuite/libgomp.c/pr66199-7.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr66199-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr66199-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr66199-7.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,66 @@\n+/* PR middle-end/66199 */\n+/* { dg-do run } */\n+\n+#pragma omp declare target\n+int u[1024], v[1024], w[1024];\n+#pragma omp end declare target\n+\n+__attribute__((noinline, noclone)) long\n+f1 (long a, long b)\n+{\n+  long d;\n+  #pragma omp target map(from: d)\n+  #pragma omp teams distribute simd default(none) firstprivate (a, b) shared(u, v, w)\n+  for (d = a; d < b; d++)\n+    u[d] = v[d] + w[d];\n+  return d;\n+}\n+\n+__attribute__((noinline, noclone)) long\n+f2 (long a, long b, long c)\n+{\n+  long d, e;\n+  #pragma omp target map(from: d, e)\n+  #pragma omp teams distribute simd default(none) firstprivate (a, b, c) shared(u, v, w) linear(d) lastprivate(e)\n+  for (d = a; d < b; d++)\n+    {\n+      u[d] = v[d] + w[d];\n+      e = c + d * 5;\n+    }\n+  return d + e;\n+}\n+\n+__attribute__((noinline, noclone)) long\n+f3 (long a1, long b1, long a2, long b2)\n+{\n+  long d1, d2;\n+  #pragma omp target map(from: d1, d2)\n+  #pragma omp teams distribute simd default(none) firstprivate (a1, b1, a2, b2) shared(u, v, w) lastprivate(d1, d2) collapse(2)\n+  for (d1 = a1; d1 < b1; d1++)\n+    for (d2 = a2; d2 < b2; d2++)\n+      u[d1 * 32 + d2] = v[d1 * 32 + d2] + w[d1 * 32 + d2];\n+  return d1 + d2;\n+}\n+\n+__attribute__((noinline, noclone)) long\n+f4 (long a1, long b1, long a2, long b2)\n+{\n+  long d1, d2;\n+  #pragma omp target map(from: d1, d2)\n+  #pragma omp teams distribute simd default(none) firstprivate (a1, b1, a2, b2) shared(u, v, w) collapse(2)\n+  for (d1 = a1; d1 < b1; d1++)\n+    for (d2 = a2; d2 < b2; d2++)\n+      u[d1 * 32 + d2] = v[d1 * 32 + d2] + w[d1 * 32 + d2];\n+  return d1 + d2;\n+}\n+\n+int\n+main ()\n+{\n+  if (f1 (0, 1024) != 1024\n+      || f2 (0, 1024, 17) != 1024 + (17 + 5 * 1023)\n+      || f3 (0, 32, 0, 32) != 64\n+      || f4 (0, 32, 0, 32) != 64)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "102af0691ec8f72df4ac310b4cbe7f812af35a36", "filename": "libgomp/testsuite/libgomp.c/pr66199-8.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr66199-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr66199-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr66199-8.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,70 @@\n+/* PR middle-end/66199 */\n+/* { dg-do run } */\n+\n+#pragma omp declare target\n+int u[1024], v[1024], w[1024];\n+#pragma omp end declare target\n+\n+__attribute__((noinline, noclone)) long\n+f1 (long a, long b)\n+{\n+  long d;\n+  #pragma omp target map(from: d)\n+  #pragma omp teams default(none) shared(a, b, d, u, v, w)\n+  #pragma omp distribute simd firstprivate (a, b)\n+  for (d = a; d < b; d++)\n+    u[d] = v[d] + w[d];\n+  return d;\n+}\n+\n+__attribute__((noinline, noclone)) long\n+f2 (long a, long b, long c)\n+{\n+  long d, e;\n+  #pragma omp target map(from: d, e)\n+  #pragma omp teams default(none) firstprivate (a, b, c) shared(d, e, u, v, w)\n+  #pragma omp distribute simd linear(d) lastprivate(e)\n+  for (d = a; d < b; d++)\n+    {\n+      u[d] = v[d] + w[d];\n+      e = c + d * 5;\n+    }\n+  return d + e;\n+}\n+\n+__attribute__((noinline, noclone)) long\n+f3 (long a1, long b1, long a2, long b2)\n+{\n+  long d1, d2;\n+  #pragma omp target map(from: d1, d2)\n+  #pragma omp teams default(none) shared(a1, b1, a2, b2, d1, d2, u, v, w)\n+  #pragma omp distribute simd firstprivate (a1, b1, a2, b2) lastprivate(d1, d2) collapse(2)\n+  for (d1 = a1; d1 < b1; d1++)\n+    for (d2 = a2; d2 < b2; d2++)\n+      u[d1 * 32 + d2] = v[d1 * 32 + d2] + w[d1 * 32 + d2];\n+  return d1 + d2;\n+}\n+\n+__attribute__((noinline, noclone)) long\n+f4 (long a1, long b1, long a2, long b2)\n+{\n+  long d1, d2;\n+  #pragma omp target map(from: d1, d2)\n+  #pragma omp teams default(none) firstprivate (a1, b1, a2, b2) shared(d1, d2, u, v, w)\n+  #pragma omp distribute simd collapse(2)\n+  for (d1 = a1; d1 < b1; d1++)\n+    for (d2 = a2; d2 < b2; d2++)\n+      u[d1 * 32 + d2] = v[d1 * 32 + d2] + w[d1 * 32 + d2];\n+  return d1 + d2;\n+}\n+\n+int\n+main ()\n+{\n+  if (f1 (0, 1024) != 1024\n+      || f2 (0, 1024, 17) != 1024 + (17 + 5 * 1023)\n+      || f3 (0, 32, 0, 32) != 64\n+      || f4 (0, 32, 0, 32) != 64)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "554a4765b4e328ca551f8e6518778c6f43f6b50e", "filename": "libgomp/testsuite/libgomp.c/pr66199-9.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr66199-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr66199-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr66199-9.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,43 @@\n+/* PR middle-end/66199 */\n+/* { dg-do run } */\n+\n+#pragma omp declare target\n+int u[1024], v[1024], w[1024];\n+#pragma omp end declare target\n+\n+__attribute__((noinline, noclone)) long\n+f2 (long a, long b, long c)\n+{\n+  long d, e;\n+  #pragma omp target map(from: d, e)\n+  #pragma omp teams default(none) firstprivate (a, b, c) shared(d, e, u, v, w)\n+  #pragma omp distribute lastprivate(d, e)\n+  for (d = a; d < b; d++)\n+    {\n+      u[d] = v[d] + w[d];\n+      e = c + d * 5;\n+    }\n+  return d + e;\n+}\n+\n+__attribute__((noinline, noclone)) long\n+f3 (long a1, long b1, long a2, long b2)\n+{\n+  long d1, d2;\n+  #pragma omp target map(from: d1, d2)\n+  #pragma omp teams default(none) shared(a1, b1, a2, b2, d1, d2, u, v, w)\n+  #pragma omp distribute firstprivate (a1, b1, a2, b2) lastprivate(d1, d2) collapse(2)\n+  for (d1 = a1; d1 < b1; d1++)\n+    for (d2 = a2; d2 < b2; d2++)\n+      u[d1 * 32 + d2] = v[d1 * 32 + d2] + w[d1 * 32 + d2];\n+  return d1 + d2;\n+}\n+\n+int\n+main ()\n+{\n+  if (f2 (0, 1024, 17) != 1024 + (17 + 5 * 1023)\n+      || f3 (0, 32, 0, 32) != 64)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "594dc673e035119630f54f504e2ab47340da16cf", "filename": "libgomp/testsuite/libgomp.c/reduction-11.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2Freduction-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2Freduction-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Freduction-11.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,62 @@\n+/* { dg-do run { xfail *-*-* } } */\n+\n+char z[10] = { 0 };\n+\n+__attribute__((noinline, noclone)) void\n+foo (int (*x)[3][2], int *y, long w[1][2], int s, int t)\n+{\n+  unsigned long long a[9] = {};\n+  short b[5] = {};\n+  int i;\n+  #pragma omp parallel for reduction(+:x[-1:2][:][0:2], z[t + 2:4]) \\\n+\t\t\t   reduction(*:y[-s:3]) reduction(|:a[s + 3:4]) \\\n+\t\t\t   reduction(&:w[s + 1:1][t:2]) reduction(max:b[2:])\n+  for (i = 0; i < 128; i++)\n+    {\n+      x[i / 64 - 1][i % 3][(i / 4) & 1] += i;\n+      if ((i & 15) == 1)\n+\ty[1] *= 3;\n+      if ((i & 31) == 2)\n+\ty[2] *= 7;\n+      if ((i & 63) == 3)\n+\ty[3] *= 17;\n+      z[i / 32 + 2] += (i & 3);\n+      if (i < 4)\n+\tz[i + 2] += i;\n+      a[i / 32 + 2] |= 1ULL << (i & 30);\n+      w[0][i & 1] &= ~(1L << (i / 17 * 3));\n+      if ((i % 23) > b[2])\n+\tb[2] = i % 23;\n+      if ((i % 85) > b[3])\n+\tb[3] = i % 85;\n+      if ((i % 192) > b[4])\n+\tb[4] = i % 192;\n+    }\n+  for (i = 0; i < 9; i++)\n+    if (a[i] != ((i < 6 && i >= 2) ? 0x55555555ULL : 0))\n+      __builtin_abort ();\n+  if (b[0] != 0 || b[1] != 0 || b[2] != 22 || b[3] != 84 || b[4] != 127)\n+    __builtin_abort ();\n+}\n+\n+int\n+main ()\n+{\n+  int a[4][3][2] = {};\n+  static int a2[4][3][2] = {{{ 0, 0 }, { 0, 0 }, { 0, 0 }},\n+\t\t\t    {{ 312, 381 }, { 295, 356 }, { 337, 335 }},\n+\t\t\t    {{ 1041, 975 }, { 1016, 1085 }, { 935, 1060 }},\n+\t\t\t    {{ 0, 0 }, { 0, 0 }, { 0, 0 }}};\n+  int y[5] = { 0, 1, 1, 1, 0 };\n+  int y2[5] = { 0, 6561, 2401, 289, 0 };\n+  char z2[10] = { 0, 0, 48, 49, 50, 51, 0, 0, 0, 0 };\n+  long w[1][2] = { ~0L, ~0L };\n+  foo (&a[2], y, w, -1, 0);\n+  if (__builtin_memcmp (a, a2, sizeof (a))\n+      || __builtin_memcmp (y, y2, sizeof (y))\n+      || __builtin_memcmp (z, z2, sizeof (z))\n+      || w[0][0] != ~0x249249L\n+      || w[0][1] != ~0x249249L)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "1c9c4f3e3ddc37f6c1e22ac33f4d6654df1da276", "filename": "libgomp/testsuite/libgomp.c/reduction-12.c", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2Freduction-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2Freduction-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Freduction-12.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,96 @@\n+/* { dg-do run { xfail *-*-* } } */\n+\n+struct A { int t; };\n+struct B { char t; };\n+struct C { unsigned long long t; };\n+struct D { long t; };\n+void\n+add (struct B *x, struct B *y)\n+{\n+  x->t += y->t;\n+}\n+void\n+zero (struct B *x)\n+{\n+  x->t = 0;\n+}\n+void\n+orit (struct C *x, struct C *y)\n+{\n+  y->t |= x->t;\n+}\n+#pragma omp declare reduction(+:struct A:omp_out.t += omp_in.t)\n+#pragma omp declare reduction(+:struct B:add (&omp_out, &omp_in)) initializer(zero (&omp_priv))\n+#pragma omp declare reduction(*:struct A:omp_out.t *= omp_in.t) initializer(omp_priv = { 1 })\n+#pragma omp declare reduction(|:struct C:orit (&omp_in, &omp_out))\n+#pragma omp declare reduction(&:struct D:omp_out.t = omp_out.t & omp_in.t) initializer(omp_priv = { ~0L })\n+#pragma omp declare reduction(maxb:short:omp_out = omp_in > omp_out ? omp_in : omp_out) initializer(omp_priv = -6)\n+\n+struct B z[10];\n+\n+__attribute__((noinline, noclone)) void\n+foo (struct A (*x)[3][2], struct A *y, struct D w[1][2], int s, int t)\n+{\n+  struct C a[9] = {};\n+  short b[5] = {};\n+  int i;\n+  #pragma omp parallel for reduction(+:x[-1:2][:][0:2], z[t + 2:4]) \\\n+\t\t\t   reduction(*:y[-s:3]) reduction(|:a[s + 3:4]) \\\n+\t\t\t   reduction(&:w[s + 1:1][t:2]) reduction(maxb:b[2:])\n+  for (i = 0; i < 128; i++)\n+    {\n+      x[i / 64 - 1][i % 3][(i / 4) & 1].t += i;\n+      if ((i & 15) == 1)\n+\ty[1].t *= 3;\n+      if ((i & 31) == 2)\n+\ty[2].t *= 7;\n+      if ((i & 63) == 3)\n+\ty[3].t *= 17;\n+      z[i / 32 + 2].t += (i & 3);\n+      if (i < 4)\n+\tz[i + 2].t += i;\n+      a[i / 32 + 2].t |= 1ULL << (i & 30);\n+      w[0][i & 1].t &= ~(1L << (i / 17 * 3));\n+      if ((i % 23) > b[2])\n+\tb[2] = i % 23;\n+      if ((i % 85) > b[3])\n+\tb[3] = i % 85;\n+      if ((i % 192) > b[4])\n+\tb[4] = i % 192;\n+    }\n+  for (i = 0; i < 9; i++)\n+    if (a[i].t != ((i < 6 && i >= 2) ? 0x55555555ULL : 0))\n+      __builtin_abort ();\n+  if (b[0] != 0 || b[1] != 0 || b[2] != 22 || b[3] != 84 || b[4] != 127)\n+    __builtin_abort ();\n+}\n+\n+int\n+main ()\n+{\n+  struct A a[4][3][2] = {};\n+  static int a2[4][3][2] = {{{ 0, 0 }, { 0, 0 }, { 0, 0 }},\n+\t\t\t    {{ 312, 381 }, { 295, 356 }, { 337, 335 }},\n+\t\t\t    {{ 1041, 975 }, { 1016, 1085 }, { 935, 1060 }},\n+\t\t\t    {{ 0, 0 }, { 0, 0 }, { 0, 0 }}};\n+  struct A y[5] = { { 0 }, { 1 }, { 1 }, { 1 }, { 0 } };\n+  int y2[5] = { 0, 6561, 2401, 289, 0 };\n+  char z2[10] = { 0, 0, 48, 49, 50, 51, 0, 0, 0, 0 };\n+  struct D w[1][2] = { { { ~0L }, { ~0L } } };\n+  foo (&a[2], y, w, -1, 0);\n+  int i, j, k;\n+  for (i = 0; i < 4; i++)\n+    for (j = 0; j < 3; j++)\n+      for (k = 0; k < 2; k++)\n+\tif (a[i][j][k].t != a2[i][j][k])\n+\t  __builtin_abort ();\n+  for (i = 0; i < 5; i++)\n+    if (y[i].t != y2[i])\n+      __builtin_abort ();\n+  for (i = 0; i < 10; i++)\n+    if (z[i].t != z2[i])\n+      __builtin_abort ();\n+  if (w[0][0].t != ~0x249249L || w[0][1].t != ~0x249249L)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "99468b2e3440ac68426da622a27746028ef2d22c", "filename": "libgomp/testsuite/libgomp.c/reduction-13.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2Freduction-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2Freduction-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Freduction-13.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,67 @@\n+char z[10] = { 0 };\n+\n+__attribute__((noinline, noclone)) void\n+foo (int (*x)[3][2], int *y, long w[1][2], int p1, long p2, long p3, int p4,\n+     int p5, long p6, short p7, int s, int t)\n+{\n+  unsigned long long a[p7 + 4];\n+  short b[p7];\n+  int i;\n+  for (i = 0; i < p7 + 4; i++)\n+    {\n+      if (i < p7)\n+\tb[i] = -6;\n+      a[i] = 0;\n+    }\n+  #pragma omp parallel for reduction(+:x[-1:p1 + 1][:p2], z[t + 2:p3]) \\\n+\t\t\t   reduction(*:y[-s:p4]) reduction(|:a[s + 3:p5]) \\\n+\t\t\t   reduction(&:w[s + 1:p6 - 1][t:p6]) reduction(max:b[2:])\n+  for (i = 0; i < 128; i++)\n+    {\n+      x[i / 64 - 1][i % 3][(i / 4) & 1] += i;\n+      if ((i & 15) == 1)\n+\ty[1] *= 3;\n+      if ((i & 31) == 2)\n+\ty[2] *= 7;\n+      if ((i & 63) == 3)\n+\ty[3] *= 17;\n+      z[i / 32 + 2] += (i & 3);\n+      if (i < 4)\n+\tz[i + 2] += i;\n+      a[i / 32 + 2] |= 1ULL << (i & 30);\n+      w[0][i & 1] &= ~(1L << (i / 17 * 3));\n+      if ((i % 23) > b[2])\n+\tb[2] = i % 23;\n+      if ((i % 85) > b[3])\n+\tb[3] = i % 85;\n+      if ((i % 192) > b[4])\n+\tb[4] = i % 192;\n+    }\n+  for (i = 0; i < 9; i++)\n+    if (a[i] != ((i < 6 && i >= 2) ? 0x55555555ULL : 0))\n+      __builtin_abort ();\n+  if (b[0] != -6 || b[1] != -6 || b[2] != 22 || b[3] != 84 || b[4] != 127)\n+    __builtin_abort ();\n+}\n+\n+int\n+main ()\n+{\n+  int a[4][3][2] = {};\n+  static int a2[4][3][2] = {{{ 0, 0 }, { 0, 0 }, { 0, 0 }},\n+\t\t\t    {{ 312, 381 }, { 295, 356 }, { 337, 335 }},\n+\t\t\t    {{ 1041, 975 }, { 1016, 1085 }, { 935, 1060 }},\n+\t\t\t    {{ 0, 0 }, { 0, 0 }, { 0, 0 }}};\n+  int y[5] = { 0, 1, 1, 1, 0 };\n+  int y2[5] = { 0, 6561, 2401, 289, 0 };\n+  char z2[10] = { 0, 0, 48, 49, 50, 51, 0, 0, 0, 0 };\n+  long w[1][2] = { ~0L, ~0L };\n+  foo (&a[2], y, w, 1, 3L, 4L, 3, 4, 2L, 5, -1, 0);\n+  if (__builtin_memcmp (a, a2, sizeof (a))\n+      || __builtin_memcmp (y, y2, sizeof (y))\n+      || __builtin_memcmp (z, z2, sizeof (z))\n+      || w[0][0] != ~0x249249L\n+      || w[0][1] != ~0x249249L)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "4c92ff0fb6f156e9badcc6421f3141e4471495c3", "filename": "libgomp/testsuite/libgomp.c/reduction-14.c", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2Freduction-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2Freduction-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Freduction-14.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,101 @@\n+struct A { int t; };\n+struct B { char t; };\n+struct C { unsigned long long t; };\n+struct D { long t; };\n+void\n+add (struct B *x, struct B *y)\n+{\n+  x->t += y->t;\n+}\n+void\n+zero (struct B *x)\n+{\n+  x->t = 0;\n+}\n+void\n+orit (struct C *x, struct C *y)\n+{\n+  y->t |= x->t;\n+}\n+#pragma omp declare reduction(+:struct A:omp_out.t += omp_in.t)\n+#pragma omp declare reduction(+:struct B:add (&omp_out, &omp_in)) initializer(zero (&omp_priv))\n+#pragma omp declare reduction(*:struct A:omp_out.t *= omp_in.t) initializer(omp_priv = { 1 })\n+#pragma omp declare reduction(|:struct C:orit (&omp_in, &omp_out))\n+#pragma omp declare reduction(&:struct D:omp_out.t = omp_out.t & omp_in.t) initializer(omp_priv = { ~0L })\n+#pragma omp declare reduction(maxb:short:omp_out = omp_in > omp_out ? omp_in : omp_out) initializer(omp_priv = -6)\n+\n+struct B z[10];\n+\n+__attribute__((noinline, noclone)) void\n+foo (struct A (*x)[3][2], struct A *y, struct D w[1][2], int p1, long p2, long p3, int p4,\n+     int p5, long p6, short p7, int s, int t)\n+{\n+  struct C a[p7 + 4];\n+  short b[p7];\n+  int i;\n+  for (i = 0; i < p7 + 4; i++)\n+    {\n+      if (i < p7)\n+\tb[i] = -6;\n+      a[i].t = 0;\n+    }\n+  #pragma omp parallel for reduction(+:x[-1:p1 + 1][:p2], z[t + 2:p3]) \\\n+\t\t\t   reduction(*:y[-s:p4]) reduction(|:a[s + 3:p5]) \\\n+\t\t\t   reduction(&:w[s + 1:p6 - 1][t:p6]) reduction(maxb:b[2:])\n+  for (i = 0; i < 128; i++)\n+    {\n+      x[i / 64 - 1][i % 3][(i / 4) & 1].t += i;\n+      if ((i & 15) == 1)\n+\ty[1].t *= 3;\n+      if ((i & 31) == 2)\n+\ty[2].t *= 7;\n+      if ((i & 63) == 3)\n+\ty[3].t *= 17;\n+      z[i / 32 + 2].t += (i & 3);\n+      if (i < 4)\n+\tz[i + 2].t += i;\n+      a[i / 32 + 2].t |= 1ULL << (i & 30);\n+      w[0][i & 1].t &= ~(1L << (i / 17 * 3));\n+      if ((i % 23) > b[2])\n+\tb[2] = i % 23;\n+      if ((i % 85) > b[3])\n+\tb[3] = i % 85;\n+      if ((i % 192) > b[4])\n+\tb[4] = i % 192;\n+    }\n+  for (i = 0; i < 9; i++)\n+    if (a[i].t != ((i < 6 && i >= 2) ? 0x55555555ULL : 0))\n+      __builtin_abort ();\n+  if (b[0] != -6 || b[1] != -6 || b[2] != 22 || b[3] != 84 || b[4] != 127)\n+    __builtin_abort ();\n+}\n+\n+int\n+main ()\n+{\n+  struct A a[4][3][2] = {};\n+  static int a2[4][3][2] = {{{ 0, 0 }, { 0, 0 }, { 0, 0 }},\n+\t\t\t    {{ 312, 381 }, { 295, 356 }, { 337, 335 }},\n+\t\t\t    {{ 1041, 975 }, { 1016, 1085 }, { 935, 1060 }},\n+\t\t\t    {{ 0, 0 }, { 0, 0 }, { 0, 0 }}};\n+  struct A y[5] = { { 0 }, { 1 }, { 1 }, { 1 }, { 0 } };\n+  int y2[5] = { 0, 6561, 2401, 289, 0 };\n+  char z2[10] = { 0, 0, 48, 49, 50, 51, 0, 0, 0, 0 };\n+  struct D w[1][2] = { { { ~0L }, { ~0L } } };\n+  foo (&a[2], y, w, 1, 3L, 4L, 3, 4, 2L, 5, -1, 0);\n+  int i, j, k;\n+  for (i = 0; i < 4; i++)\n+    for (j = 0; j < 3; j++)\n+      for (k = 0; k < 2; k++)\n+\tif (a[i][j][k].t != a2[i][j][k])\n+\t  __builtin_abort ();\n+  for (i = 0; i < 5; i++)\n+    if (y[i].t != y2[i])\n+      __builtin_abort ();\n+  for (i = 0; i < 10; i++)\n+    if (z[i].t != z2[i])\n+      __builtin_abort ();\n+  if (w[0][0].t != ~0x249249L || w[0][1].t != ~0x249249L)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "50f7e2422cad74e9a0839dfaa13ba332cc07a446", "filename": "libgomp/testsuite/libgomp.c/reduction-15.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2Freduction-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2Freduction-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Freduction-15.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,56 @@\n+extern void abort (void);\n+int a[16], b[16], c[16], d[5][2];\n+\n+__attribute__((noinline, noclone)) void\n+foo (int x, int y)\n+{\n+  int i;\n+  #pragma omp for schedule (static, 1) reduction (+:a[:3])\n+  for (i = 0; i < 64; i++)\n+    {\n+      a[0] += i;\n+      a[1] += 2 * i;\n+      a[2] += 3 * i;\n+    }\n+  #pragma omp for schedule (guided) reduction (+:b[4:3])\n+  for (i = 0; i < 64; i++)\n+    {\n+      b[4] += i;\n+      b[5] += 2 * i;\n+      b[6] += 3 * i;\n+    }\n+  #pragma omp for schedule (static) reduction (+:c[x:4])\n+  for (i = 0; i < 64; i++)\n+    {\n+      c[9] += i;\n+      c[10] += 2 * i;\n+      c[11] += 3 * i;\n+      c[12] += 4 * i;\n+    }\n+  #pragma omp for reduction (+:d[x - 8:2][y:])\n+  for (i = 0; i < 64; i++)\n+    {\n+      d[1][0] += i;\n+      d[1][1] += 2 * i;\n+      d[2][0] += 3 * i;\n+      d[2][1] += 4 * i;\n+    }\n+}\n+\n+int\n+main ()\n+{\n+  int i;\n+  #pragma omp parallel\n+  foo (9, 0);\n+  for (i = 0; i < 16; i++)\n+    if (a[i] != (i < 3 ? 64 * 63 / 2 * (i + 1) : 0)\n+\t|| b[i] != ((i >= 4 && i < 7) ? 64 * 63 / 2 * (i - 3) : 0)\n+\t|| c[i] != ((i >= 9 && i < 13) ? 64 * 63 / 2 * (i - 8) : 0))\n+      abort ();\n+  for (i = 0; i < 5; i++)\n+    if (d[i][0] != ((i && i <= 2) ? 64 * 63 / 2 * (2 * i - 1) : 0)\n+\t|| d[i][1] != ((i && i <= 2) ? 64 * 63 / 2 * (2 * i) : 0))\n+      abort ();\n+  return 0;\n+}"}, {"sha": "b439e56577cfe4f96057ad3f1511d79e9b3c4ed3", "filename": "libgomp/testsuite/libgomp.c/target-12.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-12.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -41,7 +41,7 @@ main ()\n \n       if (omp_target_is_present (q, d) != 1\n \t  || omp_target_is_present (&q[32], d) != 1\n-\t  || omp_target_is_present (&q[128], d) != 1)\n+\t  || omp_target_is_present (&q[127], d) != 1)\n \tabort ();\n \n       if (omp_target_memcpy (p, q, 128 * sizeof (int), sizeof (int), 0,"}, {"sha": "4990826ab46d35772117d87b455e1028899d646f", "filename": "libgomp/testsuite/libgomp.c/target-17.c", "status": "modified", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-17.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -37,58 +37,6 @@ foo (int n)\n   }\n   if (err)\n     abort ();\n-  int on = n;\n-  #pragma omp target firstprivate (n) map(tofrom: n)\n-  {\n-    n++;\n-  }\n-  if (on != n)\n-    abort ();\n-  #pragma omp target map(tofrom: n) private (n)\n-  {\n-    n = 25;\n-  }\n-  if (on != n)\n-    abort ();\n-  for (i = 0; i < n; i++)\n-    a[i] += i;\n-  #pragma omp target map(to:a) firstprivate (a) map(from:err) private(i)\n-  {\n-    err = 0;\n-    for (i = 0; i < n; i++)\n-      if (a[i] != 8 * i)\n-\terr = 1;\n-  }\n-  if (err)\n-    abort ();\n-  for (i = 0; i < n; i++)\n-    a[i] += i;\n-  #pragma omp target firstprivate (a) map(to:a) map(from:err) private(i)\n-  {\n-    err = 0;\n-    for (i = 0; i < n; i++)\n-      if (a[i] != 9 * i)\n-\terr = 1;\n-  }\n-  if (err)\n-    abort ();\n-  for (i = 0; i < n; i++)\n-    a[i] += i;\n-  #pragma omp target map(tofrom:a) map(from:err) private(a, i)\n-  {\n-    err = 0;\n-    for (i = 0; i < n; i++)\n-      a[i] = 7;\n-    #pragma omp parallel for reduction(|:err)\n-    for (i = 0; i < n; i++)\n-      if (a[i] != 7)\n-\terr |= 1;\n-  }\n-  if (err)\n-    abort ();\n-  for (i = 0; i < n; i++)\n-    if (a[i] != 10 * i)\n-      abort ();\n }\n \n int"}, {"sha": "2505cafca9fb414e60f247da927daa81c3618876", "filename": "libgomp/testsuite/libgomp.c/target-19.c", "status": "modified", "additions": 51, "deletions": 12, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-19.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -1,21 +1,29 @@\n extern void abort (void);\n \n-void\n+__attribute__((noinline, noclone)) void\n foo (int *p, int *q, int *r, int n, int m)\n {\n   int i, err, *s = r;\n+  int sep = 1;\n+  #pragma omp target map(to:sep)\n+  sep = 0;\n   #pragma omp target data map(to:p[0:8])\n   {\n     /* For zero length array sections, p points to the start of\n-       already mapped range, q to the end of it, and r does not point\n-       to an mapped range.  */\n+       already mapped range, q to the end of it (with nothing mapped\n+       after it), and r does not point to an mapped range.  */\n     #pragma omp target map(alloc:p[:0]) map(to:q[:0]) map(from:r[:0]) private(i) map(from:err) firstprivate (s)\n     {\n       err = 0;\n       for (i = 0; i < 8; i++)\n-\tif (p[i] != i + 1 || q[i - 8] != i + 1)\n+\tif (p[i] != i + 1)\n \t  err = 1;\n-      if (p + 8 != q || (r != (int *) 0 && r != s))\n+      if (sep)\n+\t{\n+\t  if (q != (int *) 0 || r != (int *) 0)\n+\t    err = 1;\n+\t}\n+      else if (p + 8 != q || r != s)\n \terr = 1;\n     }\n     if (err)\n@@ -25,9 +33,14 @@ foo (int *p, int *q, int *r, int n, int m)\n     {\n       err = 0;\n       for (i = 0; i < 8; i++)\n-\tif (p[i] != i + 1 || q[i - 8] != i + 1)\n+\tif (p[i] != i + 1)\n \t  err = 1;\n-      if (p + 8 != q || (r != (int *) 0 && r != s))\n+      if (sep)\n+\t{\n+\t  if (q != (int *) 0 || r != (int *) 0)\n+\t    err = 1;\n+\t}\n+      else if (p + 8 != q || r != s)\n \terr = 1;\n     }\n     if (err)\n@@ -38,9 +51,14 @@ foo (int *p, int *q, int *r, int n, int m)\n     {\n       err = 0;\n       for (i = 0; i < 8; i++)\n-\tif (p[i] != i + 1 || q[i - 8] != i + 1)\n+\tif (p[i] != i + 1)\n \t  err = 1;\n-      if (p + 8 != q || (r != (int *) 0 && r != s))\n+      if (sep)\n+\t{\n+\t  if (q != (int *) 0 || r != (int *) 0)\n+\t    err = 1;\n+\t}\n+      else if (p + 8 != q || r != s)\n \terr = 1;\n     }\n     if (err)\n@@ -69,7 +87,14 @@ foo (int *p, int *q, int *r, int n, int m)\n \tfor (i = 0; i < 8; i++)\n \t  if (p[i] != i + 1)\n \t    err = 1;\n-\tif (q[0] != 9 || r != q + 1)\n+\tif (q[0] != 9)\n+\t  err = 1;\n+\telse if (sep)\n+\t  {\n+\t    if (r != (int *) 0)\n+\t      err = 1;\n+\t  }\n+\telse if (r != q + 1)\n \t  err = 1;\n       }\n       if (err)\n@@ -81,7 +106,14 @@ foo (int *p, int *q, int *r, int n, int m)\n \tfor (i = 0; i < 8; i++)\n \t  if (p[i] != i + 1)\n \t    err = 1;\n-\tif (q[0] != 9 || r != q + 1)\n+\tif (q[0] != 9)\n+\t  err = 1;\n+\telse if (sep)\n+\t  {\n+\t    if (r != (int *) 0)\n+\t      err = 1;\n+\t  }\n+\telse if (r != q + 1)\n \t  err = 1;\n       }\n       if (err)\n@@ -94,7 +126,14 @@ foo (int *p, int *q, int *r, int n, int m)\n \tfor (i = 0; i < 8; i++)\n \t  if (p[i] != i + 1)\n \t    err = 1;\n-\tif (q[0] != 9 || r != q + 1)\n+\tif (q[0] != 9)\n+\t  err = 1;\n+\telse if (sep)\n+\t  {\n+\t    if (r != (int *) 0)\n+\t      err = 1;\n+\t  }\n+\telse if (r != q + 1)\n \t  err = 1;\n       }\n       if (err)"}, {"sha": "96e9e058a2141c2d5999d30771233e0240165c91", "filename": "libgomp/testsuite/libgomp.c/target-28.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-28.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-28.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-28.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,36 @@\n+extern void abort (void);\n+\n+int g;\n+#pragma omp declare target (g)\n+\n+#pragma omp declare target\n+int\n+foo (void)\n+{\n+  static int s;\n+  return ++s + g;\n+}\n+#pragma omp end declare target\n+\n+int\n+bar (void)\n+{\n+  static int s;\n+  #pragma omp declare target to (s)\n+  return ++s;\n+}\n+#pragma omp declare target (bar)\n+\n+int\n+main ()\n+{\n+  int r;\n+  #pragma omp target map(from:r)\n+  {\n+    r = (foo () == 1) + (bar () == 1);\n+    r += (foo () == 2) + (bar () == 2);\n+  }\n+  if (r != 4)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "e5095a1b6b8b0657d11c8a63c4b4b1bd054bb6f8", "filename": "libgomp/testsuite/libgomp.c/target-29.c", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-29.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-29.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-29.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,112 @@\n+#include <omp.h>\n+#include <stdlib.h>\n+\n+struct S { char p[64]; int a; int b[2]; long c[4]; int *d; char q[64]; };\n+\n+__attribute__((noinline, noclone)) void\n+foo (struct S s)\n+{\n+  int d = omp_get_default_device ();\n+  int id = omp_get_initial_device ();\n+  int sep = 1;\n+\n+  if (d < 0 || d >= omp_get_num_devices ())\n+    d = id;\n+\n+  int err;\n+  #pragma omp target map(tofrom: s.a, s.b, s.c[1:2], s.d[-2:3]) map(to: sep) map(from: err)\n+  {\n+    err = s.a != 11 || s.b[0] != 12 || s.b[1] != 13;\n+    err |= s.c[1] != 15 || s.c[2] != 16 || s.d[-2] != 18 || s.d[-1] != 19 || s.d[0] != 20;\n+    s.a = 35; s.b[0] = 36; s.b[1] = 37;\n+    s.c[1] = 38; s.c[2] = 39; s.d[-2] = 40; s.d[-1] = 41; s.d[0] = 42;\n+    sep = 0;\n+  }\n+  if (err) abort ();\n+  err = s.a != 35 || s.b[0] != 36 || s.b[1] != 37;\n+  err |= s.c[1] != 38 || s.c[2] != 39 || s.d[-2] != 40 || s.d[-1] != 41 || s.d[0] != 42;\n+  if (err) abort ();\n+  s.a = 50; s.b[0] = 49; s.b[1] = 48;\n+  s.c[1] = 47; s.c[2] = 46; s.d[-2] = 45; s.d[-1] = 44; s.d[0] = 43;\n+  if (sep\n+      && (omp_target_is_present (&s.a, d)\n+\t  || omp_target_is_present (s.b, d)\n+\t  || omp_target_is_present (&s.c[1], d)\n+\t  || omp_target_is_present (s.d, d)\n+\t  || omp_target_is_present (&s.d[-2], d)))\n+    abort ();\n+  #pragma omp target data map(alloc: s.a, s.b, s.c[1:2], s.d[-2:3])\n+  {\n+    if (!omp_target_is_present (&s.a, d)\n+\t|| !omp_target_is_present (s.b, d)\n+\t|| !omp_target_is_present (&s.c[1], d)\n+\t|| !omp_target_is_present (s.d, d)\n+\t|| !omp_target_is_present (&s.d[-2], d))\n+      abort ();\n+    #pragma omp target update to(s.a, s.b, s.c[1:2], s.d[-2:3])\n+    #pragma omp target map(alloc: s.a, s.b, s.c[1:2], s.d[-2:3]) map(from: err)\n+    {\n+      err = s.a != 50 || s.b[0] != 49 || s.b[1] != 48;\n+      err |= s.c[1] != 47 || s.c[2] != 46 || s.d[-2] != 45 || s.d[-1] != 44 || s.d[0] != 43;\n+      s.a = 17; s.b[0] = 18; s.b[1] = 19;\n+      s.c[1] = 20; s.c[2] = 21; s.d[-2] = 22; s.d[-1] = 23; s.d[0] = 24;\n+    }\n+    #pragma omp target update from(s.a, s.b, s.c[1:2], s.d[-2:3])\n+  }\n+  if (sep\n+      && (omp_target_is_present (&s.a, d)\n+\t  || omp_target_is_present (s.b, d)\n+\t  || omp_target_is_present (&s.c[1], d)\n+\t  || omp_target_is_present (s.d, d)\n+\t  || omp_target_is_present (&s.d[-2], d)))\n+    abort ();\n+  if (err) abort ();\n+  err = s.a != 17 || s.b[0] != 18 || s.b[1] != 19;\n+  err |= s.c[1] != 20 || s.c[2] != 21 || s.d[-2] != 22 || s.d[-1] != 23 || s.d[0] != 24;\n+  if (err) abort ();\n+  s.a = 33; s.b[0] = 34; s.b[1] = 35;\n+  s.c[1] = 36; s.c[2] = 37; s.d[-2] = 38; s.d[-1] = 39; s.d[0] = 40;\n+  #pragma omp target enter data map(alloc: s.a, s.b, s.c[1:2], s.d[-2:3])\n+  if (!omp_target_is_present (&s.a, d)\n+      || !omp_target_is_present (s.b, d)\n+      || !omp_target_is_present (&s.c[1], d)\n+      || !omp_target_is_present (s.d, d)\n+      || !omp_target_is_present (&s.d[-2], d))\n+    abort ();\n+  #pragma omp target enter data map(always, to: s.a, s.b, s.c[1:2], s.d[-2:3])\n+  #pragma omp target map(alloc: s.a, s.b, s.c[1:2], s.d[-2:3]) map(from: err)\n+  {\n+    err = s.a != 33 || s.b[0] != 34 || s.b[1] != 35;\n+    err |= s.c[1] != 36 || s.c[2] != 37 || s.d[-2] != 38 || s.d[-1] != 39 || s.d[0] != 40;\n+    s.a = 49; s.b[0] = 48; s.b[1] = 47;\n+    s.c[1] = 46; s.c[2] = 45; s.d[-2] = 44; s.d[-1] = 43; s.d[0] = 42;\n+  }\n+  #pragma omp target exit data map(always, from: s.a, s.b, s.c[1:2], s.d[-2:3])\n+  if (!omp_target_is_present (&s.a, d)\n+      || !omp_target_is_present (s.b, d)\n+      || !omp_target_is_present (&s.c[1], d)\n+      || !omp_target_is_present (s.d, d)\n+      || !omp_target_is_present (&s.d[-2], d))\n+    abort ();\n+  #pragma omp target exit data map(release: s.a, s.b, s.c[1:2], s.d[-2:3])\n+  if (sep\n+      && (omp_target_is_present (&s.a, d)\n+\t  || omp_target_is_present (s.b, d)\n+\t  || omp_target_is_present (&s.c[1], d)\n+\t  || omp_target_is_present (s.d, d)\n+\t  || omp_target_is_present (&s.d[-2], d)))\n+    abort ();\n+  if (err) abort ();\n+  err = s.a != 49 || s.b[0] != 48 || s.b[1] != 47;\n+  err |= s.c[1] != 46 || s.c[2] != 45 || s.d[-2] != 44 || s.d[-1] != 43 || s.d[0] != 42;\n+  if (err) abort ();\n+}\n+\n+int\n+main ()\n+{\n+  int d[3] = { 18, 19, 20 };\n+  struct S s = { {}, 11, { 12, 13 }, { 14, 15, 16, 17 }, d + 2, {} };\n+  foo (s);\n+  return 0;\n+}"}, {"sha": "a309f7d1a21ba827a5c458af7087963c277e132f", "filename": "libgomp/testsuite/libgomp.c/target-30.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-30.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,24 @@\n+extern void abort (void);\n+\n+#pragma omp declare target\n+int v = 6;\n+#pragma omp end declare target\n+\n+int\n+main ()\n+{\n+  #pragma omp target /* predetermined map(tofrom: v) */\n+  v++;\n+  #pragma omp target update from (v)\n+  if (v != 7)\n+    abort ();\n+  #pragma omp parallel private (v) num_threads (1)\n+  {\n+    #pragma omp target /* predetermined firstprivate(v) */\n+    v++;\n+  }\n+  #pragma omp target update from (v)\n+  if (v != 7)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "8f591e02c48afbb54912c646510d0d7408eeee01", "filename": "libgomp/testsuite/libgomp.c/target-teams-1.c", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-teams-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01d41e553aae24572da3a067347a5f2c02cd620/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-teams-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-teams-1.c?ref=e01d41e553aae24572da3a067347a5f2c02cd620", "patch": "@@ -0,0 +1,152 @@\n+/* { dg-do run } */\n+\n+#include <omp.h>\n+#include <stdlib.h>\n+\n+int v = 6;\n+\n+void\n+bar (long *x, long *y)\n+{\n+  *x += 2;\n+  *y += 3;\n+}\n+\n+int\n+baz (void)\n+{\n+  return 5;\n+}\n+\n+#pragma omp declare target to (bar, baz, v)\n+\n+__attribute__((noinline, noclone)) void\n+foo (int a, int b, long c, long d)\n+{\n+  int err;\n+  if (omp_get_num_teams () != 1)\n+    abort ();\n+  /* The OpenMP 4.5 spec says that these expressions are evaluated before\n+     target region on combined target teams, so those cases are always\n+     fine.  */\n+  #pragma omp target map(from: err)\n+  err = omp_get_num_teams () != 1;\n+  if (err)\n+    abort ();\n+  #pragma omp target map(from: err)\n+  #pragma omp teams\n+  err = omp_get_num_teams () < 1 || omp_get_thread_limit () < 1;\n+  if (err)\n+    abort ();\n+  #pragma omp target teams map(from: err)\n+  err = omp_get_num_teams () < 1 || omp_get_thread_limit () < 1;\n+  if (err)\n+    abort ();\n+  #pragma omp target map(from: err)\n+  #pragma omp teams num_teams (4)\n+  err = omp_get_num_teams () < 1 || omp_get_thread_limit () < 1\n+\t|| omp_get_num_teams () > 4;\n+  if (err)\n+    abort ();\n+  #pragma omp target teams num_teams (4) map(from: err)\n+  err = omp_get_num_teams () < 1 || omp_get_thread_limit () < 1\n+\t|| omp_get_num_teams () > 4;\n+  if (err)\n+    abort ();\n+  #pragma omp target map(from: err)\n+  #pragma omp teams thread_limit (7)\n+  err = omp_get_num_teams () < 1 || omp_get_thread_limit () < 1\n+\t|| omp_get_thread_limit () > 7;\n+  if (err)\n+    abort ();\n+  #pragma omp target teams thread_limit (7) map(from: err)\n+  err = omp_get_num_teams () < 1 || omp_get_thread_limit () < 1\n+\t|| omp_get_thread_limit () > 7;\n+  if (err)\n+    abort ();\n+  #pragma omp target map(from: err)\n+  #pragma omp teams num_teams (4) thread_limit (8)\n+  {\n+    {\n+      err = omp_get_num_teams () < 1 || omp_get_thread_limit () < 1\n+\t    || omp_get_num_teams () > 4 || omp_get_thread_limit () > 8;\n+    }\n+  }\n+  if (err)\n+    abort ();\n+  #pragma omp target teams num_teams (4) thread_limit (8) map(from: err)\n+  err = omp_get_num_teams () < 1 || omp_get_thread_limit () < 1\n+\t|| omp_get_num_teams () > 4 || omp_get_thread_limit () > 8;\n+  if (err)\n+    abort ();\n+  #pragma omp target map(from: err)\n+  #pragma omp teams num_teams (a) thread_limit (b)\n+  err = omp_get_num_teams () < 1 || omp_get_thread_limit () < 1\n+\t|| omp_get_num_teams () > a || omp_get_thread_limit () > b;\n+  if (err)\n+    abort ();\n+  #pragma omp target teams num_teams (a) thread_limit (b) map(from: err)\n+  err = omp_get_num_teams () < 1 || omp_get_thread_limit () < 1\n+\t|| omp_get_num_teams () > a || omp_get_thread_limit () > b;\n+  if (err)\n+    abort ();\n+  #pragma omp target map(from: err)\n+  #pragma omp teams num_teams (c + 1) thread_limit (d - 1)\n+  err = omp_get_num_teams () < 1 || omp_get_thread_limit () < 1\n+\t|| omp_get_num_teams () > c + 1 || omp_get_thread_limit () > d - 1;\n+  if (err)\n+    abort ();\n+  #pragma omp target teams num_teams (c + 1) thread_limit (d - 1) map(from: err)\n+  err = omp_get_num_teams () < 1 || omp_get_thread_limit () < 1\n+\t|| omp_get_num_teams () > c + 1 || omp_get_thread_limit () > d - 1;\n+  if (err)\n+    abort ();\n+  #pragma omp target map (always, to: c, d) map(from: err)\n+  #pragma omp teams num_teams (c + 1) thread_limit (d - 1)\n+  err = omp_get_num_teams () < 1 || omp_get_thread_limit () < 1\n+\t|| omp_get_num_teams () > c + 1 || omp_get_thread_limit () > d - 1;\n+  if (err)\n+    abort ();\n+  #pragma omp target data map (to: c, d)\n+  {\n+    #pragma omp target defaultmap (tofrom: scalar)\n+    bar (&c, &d);\n+    /* This is one of the cases which can't be generally optimized,\n+       the c and d are (or could be) already mapped and whether\n+       their device and original values match is unclear.  */\n+    #pragma omp target map (to: c, d) map(from: err)\n+    #pragma omp teams num_teams (c + 1) thread_limit (d - 1)\n+    err = omp_get_num_teams () < 1 || omp_get_thread_limit () < 1\n+\t  || omp_get_num_teams () > c + 1 || omp_get_thread_limit () > d - 1;\n+    if (err)\n+      abort ();\n+  }\n+  /* This can't be optimized, there are function calls inside of\n+     target involved.  */\n+  #pragma omp target map(from: err)\n+  #pragma omp teams num_teams (baz () + 1) thread_limit (baz () - 1)\n+  err = omp_get_num_teams () < 1 || omp_get_thread_limit () < 1\n+\t|| omp_get_num_teams () > baz () + 1 || omp_get_thread_limit () > baz () - 1;\n+  if (err)\n+    abort ();\n+  #pragma omp target teams num_teams (baz () + 1) thread_limit (baz () - 1) map(from: err)\n+  err = omp_get_num_teams () < 1 || omp_get_thread_limit () < 1\n+\t|| omp_get_num_teams () > baz () + 1 || omp_get_thread_limit () > baz () - 1;\n+  if (err)\n+    abort ();\n+  /* This one can't be optimized, as v might have different value between\n+     host and target.  */\n+  #pragma omp target map(from: err)\n+  #pragma omp teams num_teams (v + 1) thread_limit (v - 1)\n+  err = omp_get_num_teams () < 1 || omp_get_thread_limit () < 1\n+\t|| omp_get_num_teams () > v + 1 || omp_get_thread_limit () > v - 1;\n+  if (err)\n+    abort ();\n+}\n+\n+int\n+main ()\n+{\n+  foo (3, 5, 7, 9);\n+  return 0;\n+}"}]}