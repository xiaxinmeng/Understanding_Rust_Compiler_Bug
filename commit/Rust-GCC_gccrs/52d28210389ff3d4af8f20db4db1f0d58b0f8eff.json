{"sha": "52d28210389ff3d4af8f20db4db1f0d58b0f8eff", "node_id": "C_kwDOANBUbNoAKDUyZDI4MjEwMzg5ZmYzZDRhZjhmMjBkYjRkYjFmMGQ1OGIwZjhlZmY", "commit": {"author": {"name": "Matthias Kretz", "email": "m.kretz@gsi.de", "date": "2021-02-01T09:58:03Z"}, "committer": {"name": "Matthias Kretz", "email": "m.kretz@gsi.de", "date": "2022-01-15T20:05:17Z"}, "message": "libstdc++: Fix ODR issues with different -m flags\n\nExplicitly support use of the stdx::simd implementation in situations\nwhere the user links TUs that were compiled with different -m flags. In\ngeneral, this is always a (quasi) ODR violation for inline functions\nbecause at least codegen may differ in important ways. However, in the\nresulting executable only one (unspecified which one) of them might be\nused. For simd we want to support users to compile code multiple times,\nwith different -m flags and have a runtime dispatch to the TU matching\nthe target CPU. But if internal functions are not inlined this may lead\nto unexpected performance loss or execution of illegal instructions.\nTherefore, inline functions that are not marked as always_inline must\nuse an additional template parameter somewhere in their name, to\ndisambiguate between the different -m translations.\n\nSigned-off-by: Matthias Kretz <m.kretz@gsi.de>\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/experimental/bits/simd.h: Move feature detection bools\n\tand add __have_avx512bitalg, __have_avx512vbmi2,\n\t__have_avx512vbmi, __have_avx512ifma, __have_avx512cd,\n\t__have_avx512vnni, __have_avx512vpopcntdq.\n\t(__detail::__machine_flags): New function which returns a unique\n\tuint64 depending on relevant -m and -f flags.\n\t(__detail::__odr_helper): New type alias for either an anonymous\n\ttype or a type specialized with the __machine_flags number.\n\t(_SimdIntOperators): Change template parameters from _Impl to\n\t_Tp, _Abi because _Impl now has an __odr_helper parameter which\n\tmay be _OdrEnforcer from the anonymous namespace, which makes\n\tfor a bad base class.\n\t(many): Either add __odr_helper template parameter or mark as\n\talways_inline.\n\t* include/experimental/bits/simd_detail.h: Add defines for\n\tAVX512BITALG, AVX512VBMI2, AVX512VBMI, AVX512IFMA, AVX512CD,\n\tAVX512VNNI, AVX512VPOPCNTDQ, and AVX512VP2INTERSECT.\n\t* include/experimental/bits/simd_builtin.h: Add __odr_helper\n\ttemplate parameter or mark as always_inline.\n\t* include/experimental/bits/simd_fixed_size.h: Ditto.\n\t* include/experimental/bits/simd_math.h: Ditto.\n\t* include/experimental/bits/simd_scalar.h: Ditto.\n\t* include/experimental/bits/simd_neon.h: Add __odr_helper\n\ttemplate parameter.\n\t* include/experimental/bits/simd_ppc.h: Ditto.\n\t* include/experimental/bits/simd_x86.h: Ditto.", "tree": {"sha": "a9f2b6d5f6a6ba4a73a04fc61c0321053e26d79e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a9f2b6d5f6a6ba4a73a04fc61c0321053e26d79e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/52d28210389ff3d4af8f20db4db1f0d58b0f8eff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52d28210389ff3d4af8f20db4db1f0d58b0f8eff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52d28210389ff3d4af8f20db4db1f0d58b0f8eff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52d28210389ff3d4af8f20db4db1f0d58b0f8eff/comments", "author": {"login": "mattkretz", "id": 3306474, "node_id": "MDQ6VXNlcjMzMDY0NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3306474?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mattkretz", "html_url": "https://github.com/mattkretz", "followers_url": "https://api.github.com/users/mattkretz/followers", "following_url": "https://api.github.com/users/mattkretz/following{/other_user}", "gists_url": "https://api.github.com/users/mattkretz/gists{/gist_id}", "starred_url": "https://api.github.com/users/mattkretz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mattkretz/subscriptions", "organizations_url": "https://api.github.com/users/mattkretz/orgs", "repos_url": "https://api.github.com/users/mattkretz/repos", "events_url": "https://api.github.com/users/mattkretz/events{/privacy}", "received_events_url": "https://api.github.com/users/mattkretz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mattkretz", "id": 3306474, "node_id": "MDQ6VXNlcjMzMDY0NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3306474?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mattkretz", "html_url": "https://github.com/mattkretz", "followers_url": "https://api.github.com/users/mattkretz/followers", "following_url": "https://api.github.com/users/mattkretz/following{/other_user}", "gists_url": "https://api.github.com/users/mattkretz/gists{/gist_id}", "starred_url": "https://api.github.com/users/mattkretz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mattkretz/subscriptions", "organizations_url": "https://api.github.com/users/mattkretz/orgs", "repos_url": "https://api.github.com/users/mattkretz/repos", "events_url": "https://api.github.com/users/mattkretz/events{/privacy}", "received_events_url": "https://api.github.com/users/mattkretz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f4a2cecd689c5dd805c86731f712ff20ca41a71d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4a2cecd689c5dd805c86731f712ff20ca41a71d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4a2cecd689c5dd805c86731f712ff20ca41a71d"}], "stats": {"total": 628, "additions": 440, "deletions": 188}, "files": [{"sha": "d837d0efb21e9c52bce437078046af273b14cc50", "filename": "libstdc++-v3/include/experimental/bits/simd.h", "status": "modified", "additions": 255, "deletions": 125, "changes": 380, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52d28210389ff3d4af8f20db4db1f0d58b0f8eff/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Fsimd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52d28210389ff3d4af8f20db4db1f0d58b0f8eff/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Fsimd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Fsimd.h?ref=52d28210389ff3d4af8f20db4db1f0d58b0f8eff", "patch": "@@ -35,6 +35,7 @@\n #include <cstdio> // for stderr\n #endif\n #include <cstring>\n+#include <cmath>\n #include <functional>\n #include <iosfwd>\n #include <utility>\n@@ -206,9 +207,170 @@ template <size_t _Np>\n // }}}\n template <size_t _Xp>\n   using _SizeConstant = integral_constant<size_t, _Xp>;\n+// constexpr feature detection{{{\n+constexpr inline bool __have_mmx = _GLIBCXX_SIMD_HAVE_MMX;\n+constexpr inline bool __have_sse = _GLIBCXX_SIMD_HAVE_SSE;\n+constexpr inline bool __have_sse2 = _GLIBCXX_SIMD_HAVE_SSE2;\n+constexpr inline bool __have_sse3 = _GLIBCXX_SIMD_HAVE_SSE3;\n+constexpr inline bool __have_ssse3 = _GLIBCXX_SIMD_HAVE_SSSE3;\n+constexpr inline bool __have_sse4_1 = _GLIBCXX_SIMD_HAVE_SSE4_1;\n+constexpr inline bool __have_sse4_2 = _GLIBCXX_SIMD_HAVE_SSE4_2;\n+constexpr inline bool __have_xop = _GLIBCXX_SIMD_HAVE_XOP;\n+constexpr inline bool __have_avx = _GLIBCXX_SIMD_HAVE_AVX;\n+constexpr inline bool __have_avx2 = _GLIBCXX_SIMD_HAVE_AVX2;\n+constexpr inline bool __have_bmi = _GLIBCXX_SIMD_HAVE_BMI1;\n+constexpr inline bool __have_bmi2 = _GLIBCXX_SIMD_HAVE_BMI2;\n+constexpr inline bool __have_lzcnt = _GLIBCXX_SIMD_HAVE_LZCNT;\n+constexpr inline bool __have_sse4a = _GLIBCXX_SIMD_HAVE_SSE4A;\n+constexpr inline bool __have_fma = _GLIBCXX_SIMD_HAVE_FMA;\n+constexpr inline bool __have_fma4 = _GLIBCXX_SIMD_HAVE_FMA4;\n+constexpr inline bool __have_f16c = _GLIBCXX_SIMD_HAVE_F16C;\n+constexpr inline bool __have_popcnt = _GLIBCXX_SIMD_HAVE_POPCNT;\n+constexpr inline bool __have_avx512f = _GLIBCXX_SIMD_HAVE_AVX512F;\n+constexpr inline bool __have_avx512dq = _GLIBCXX_SIMD_HAVE_AVX512DQ;\n+constexpr inline bool __have_avx512vl = _GLIBCXX_SIMD_HAVE_AVX512VL;\n+constexpr inline bool __have_avx512bw = _GLIBCXX_SIMD_HAVE_AVX512BW;\n+constexpr inline bool __have_avx512dq_vl = __have_avx512dq && __have_avx512vl;\n+constexpr inline bool __have_avx512bw_vl = __have_avx512bw && __have_avx512vl;\n+constexpr inline bool __have_avx512bitalg = _GLIBCXX_SIMD_HAVE_AVX512BITALG;\n+constexpr inline bool __have_avx512vbmi2 = _GLIBCXX_SIMD_HAVE_AVX512VBMI2;\n+constexpr inline bool __have_avx512vbmi = _GLIBCXX_SIMD_HAVE_AVX512VBMI;\n+constexpr inline bool __have_avx512ifma = _GLIBCXX_SIMD_HAVE_AVX512IFMA;\n+constexpr inline bool __have_avx512cd = _GLIBCXX_SIMD_HAVE_AVX512CD;\n+constexpr inline bool __have_avx512vnni = _GLIBCXX_SIMD_HAVE_AVX512VNNI;\n+constexpr inline bool __have_avx512vpopcntdq = _GLIBCXX_SIMD_HAVE_AVX512VPOPCNTDQ;\n+constexpr inline bool __have_avx512vp2intersect = _GLIBCXX_SIMD_HAVE_AVX512VP2INTERSECT;\n+\n+constexpr inline bool __have_neon = _GLIBCXX_SIMD_HAVE_NEON;\n+constexpr inline bool __have_neon_a32 = _GLIBCXX_SIMD_HAVE_NEON_A32;\n+constexpr inline bool __have_neon_a64 = _GLIBCXX_SIMD_HAVE_NEON_A64;\n+constexpr inline bool __support_neon_float =\n+#if defined __GCC_IEC_559\n+  __GCC_IEC_559 == 0;\n+#elif defined __FAST_MATH__\n+  true;\n+#else\n+  false;\n+#endif\n+\n+#ifdef _ARCH_PWR10\n+constexpr inline bool __have_power10vec = true;\n+#else\n+constexpr inline bool __have_power10vec = false;\n+#endif\n+#ifdef __POWER9_VECTOR__\n+constexpr inline bool __have_power9vec = true;\n+#else\n+constexpr inline bool __have_power9vec = false;\n+#endif\n+#if defined __POWER8_VECTOR__\n+constexpr inline bool __have_power8vec = true;\n+#else\n+constexpr inline bool __have_power8vec = __have_power9vec;\n+#endif\n+#if defined __VSX__\n+constexpr inline bool __have_power_vsx = true;\n+#else\n+constexpr inline bool __have_power_vsx = __have_power8vec;\n+#endif\n+#if defined __ALTIVEC__\n+constexpr inline bool __have_power_vmx = true;\n+#else\n+constexpr inline bool __have_power_vmx = __have_power_vsx;\n+#endif\n+\n+// }}}\n \n namespace __detail\n {\n+  constexpr std::uint_least64_t\n+  __floating_point_flags()\n+  {\n+    std::uint_least64_t __flags = 0;\n+    if constexpr (math_errhandling & MATH_ERREXCEPT)\n+      __flags |= 1;\n+#ifdef __FAST_MATH__\n+    __flags |= 1 << 1;\n+#elif __FINITE_MATH_ONLY__\n+    __flags |= 2 << 1;\n+#elif __GCC_IEC_559 < 2\n+    __flags |= 3 << 1;\n+#endif\n+    __flags |= (__FLT_EVAL_METHOD__ + 1) << 3;\n+    return __flags;\n+  }\n+\n+  constexpr std::uint_least64_t\n+  __machine_flags()\n+  {\n+    if constexpr (__have_mmx || __have_sse)\n+      return __have_mmx\n+\t\t | (__have_sse                << 1)\n+\t\t | (__have_sse2               << 2)\n+\t\t | (__have_sse3               << 3)\n+\t\t | (__have_ssse3              << 4)\n+\t\t | (__have_sse4_1             << 5)\n+\t\t | (__have_sse4_2             << 6)\n+\t\t | (__have_xop                << 7)\n+\t\t | (__have_avx                << 8)\n+\t\t | (__have_avx2               << 9)\n+\t\t | (__have_bmi                << 10)\n+\t\t | (__have_bmi2               << 11)\n+\t\t | (__have_lzcnt              << 12)\n+\t\t | (__have_sse4a              << 13)\n+\t\t | (__have_fma                << 14)\n+\t\t | (__have_fma4               << 15)\n+\t\t | (__have_f16c               << 16)\n+\t\t | (__have_popcnt             << 17)\n+\t\t | (__have_avx512f            << 18)\n+\t\t | (__have_avx512dq           << 19)\n+\t\t | (__have_avx512vl           << 20)\n+\t\t | (__have_avx512bw           << 21)\n+\t\t | (__have_avx512bitalg       << 22)\n+\t\t | (__have_avx512vbmi2        << 23)\n+\t\t | (__have_avx512vbmi         << 24)\n+\t\t | (__have_avx512ifma         << 25)\n+\t\t | (__have_avx512cd           << 26)\n+\t\t | (__have_avx512vnni         << 27)\n+\t\t | (__have_avx512vpopcntdq    << 28)\n+\t\t | (__have_avx512vp2intersect << 29);\n+    else if constexpr (__have_neon)\n+      return __have_neon\n+\t       | (__have_neon_a32 << 1)\n+\t       | (__have_neon_a64 << 2)\n+\t       | (__have_neon_a64 << 2)\n+\t       | (__support_neon_float << 3);\n+    else if constexpr (__have_power_vmx)\n+      return __have_power_vmx\n+\t       | (__have_power_vsx  << 1)\n+\t       | (__have_power8vec  << 2)\n+\t       | (__have_power9vec  << 3)\n+\t       | (__have_power10vec << 4);\n+    else\n+      return 0;\n+  }\n+\n+  namespace\n+  {\n+    struct _OdrEnforcer {};\n+  }\n+\n+  template <std::uint_least64_t...>\n+    struct _MachineFlagsTemplate {};\n+\n+  /**@internal\n+   * Use this type as default template argument to all function templates that\n+   * are not declared always_inline. It ensures, that a function\n+   * specialization, which the compiler decides not to inline, has a unique symbol\n+   * (_OdrEnforcer) or a symbol matching the machine/architecture flags\n+   * (_MachineFlagsTemplate). This helps to avoid ODR violations in cases where\n+   * users link TUs compiled with different flags. This is especially important\n+   * for using simd in libraries.\n+   */\n+  using __odr_helper\n+    = conditional_t<__machine_flags() == 0, _OdrEnforcer,\n+\t\t    _MachineFlagsTemplate<__machine_flags(), __floating_point_flags()>>;\n+\n   struct _Minimum\n   {\n     template <typename _Tp>\n@@ -472,71 +634,6 @@ template <int _Np>\n template <typename _Tp>\n   inline constexpr bool __is_fixed_size_abi_v = __is_fixed_size_abi<_Tp>::value;\n \n-// }}}\n-// constexpr feature detection{{{\n-constexpr inline bool __have_mmx = _GLIBCXX_SIMD_HAVE_MMX;\n-constexpr inline bool __have_sse = _GLIBCXX_SIMD_HAVE_SSE;\n-constexpr inline bool __have_sse2 = _GLIBCXX_SIMD_HAVE_SSE2;\n-constexpr inline bool __have_sse3 = _GLIBCXX_SIMD_HAVE_SSE3;\n-constexpr inline bool __have_ssse3 = _GLIBCXX_SIMD_HAVE_SSSE3;\n-constexpr inline bool __have_sse4_1 = _GLIBCXX_SIMD_HAVE_SSE4_1;\n-constexpr inline bool __have_sse4_2 = _GLIBCXX_SIMD_HAVE_SSE4_2;\n-constexpr inline bool __have_xop = _GLIBCXX_SIMD_HAVE_XOP;\n-constexpr inline bool __have_avx = _GLIBCXX_SIMD_HAVE_AVX;\n-constexpr inline bool __have_avx2 = _GLIBCXX_SIMD_HAVE_AVX2;\n-constexpr inline bool __have_bmi = _GLIBCXX_SIMD_HAVE_BMI1;\n-constexpr inline bool __have_bmi2 = _GLIBCXX_SIMD_HAVE_BMI2;\n-constexpr inline bool __have_lzcnt = _GLIBCXX_SIMD_HAVE_LZCNT;\n-constexpr inline bool __have_sse4a = _GLIBCXX_SIMD_HAVE_SSE4A;\n-constexpr inline bool __have_fma = _GLIBCXX_SIMD_HAVE_FMA;\n-constexpr inline bool __have_fma4 = _GLIBCXX_SIMD_HAVE_FMA4;\n-constexpr inline bool __have_f16c = _GLIBCXX_SIMD_HAVE_F16C;\n-constexpr inline bool __have_popcnt = _GLIBCXX_SIMD_HAVE_POPCNT;\n-constexpr inline bool __have_avx512f = _GLIBCXX_SIMD_HAVE_AVX512F;\n-constexpr inline bool __have_avx512dq = _GLIBCXX_SIMD_HAVE_AVX512DQ;\n-constexpr inline bool __have_avx512vl = _GLIBCXX_SIMD_HAVE_AVX512VL;\n-constexpr inline bool __have_avx512bw = _GLIBCXX_SIMD_HAVE_AVX512BW;\n-constexpr inline bool __have_avx512dq_vl = __have_avx512dq && __have_avx512vl;\n-constexpr inline bool __have_avx512bw_vl = __have_avx512bw && __have_avx512vl;\n-\n-constexpr inline bool __have_neon = _GLIBCXX_SIMD_HAVE_NEON;\n-constexpr inline bool __have_neon_a32 = _GLIBCXX_SIMD_HAVE_NEON_A32;\n-constexpr inline bool __have_neon_a64 = _GLIBCXX_SIMD_HAVE_NEON_A64;\n-constexpr inline bool __support_neon_float =\n-#if defined __GCC_IEC_559\n-  __GCC_IEC_559 == 0;\n-#elif defined __FAST_MATH__\n-  true;\n-#else\n-  false;\n-#endif\n-\n-#ifdef _ARCH_PWR10\n-constexpr inline bool __have_power10vec = true;\n-#else\n-constexpr inline bool __have_power10vec = false;\n-#endif\n-#ifdef __POWER9_VECTOR__\n-constexpr inline bool __have_power9vec = true;\n-#else\n-constexpr inline bool __have_power9vec = false;\n-#endif\n-#if defined __POWER8_VECTOR__\n-constexpr inline bool __have_power8vec = true;\n-#else\n-constexpr inline bool __have_power8vec = __have_power9vec;\n-#endif\n-#if defined __VSX__\n-constexpr inline bool __have_power_vsx = true;\n-#else\n-constexpr inline bool __have_power_vsx = __have_power8vec;\n-#endif\n-#if defined __ALTIVEC__\n-constexpr inline bool __have_power_vmx = true;\n-#else\n-constexpr inline bool __have_power_vmx = __have_power_vsx;\n-#endif\n-\n // }}}\n // __is_scalar_abi {{{\n template <typename _Abi>\n@@ -4004,7 +4101,7 @@ template <typename _Tp, typename _A0, typename... _As>\n \n // }}}\n // concat(simd...) {{{\n-template <typename _Tp, typename... _As>\n+template <typename _Tp, typename... _As, typename = __detail::__odr_helper>\n   inline _GLIBCXX_SIMD_CONSTEXPR\n   simd<_Tp, simd_abi::deduce_t<_Tp, (simd_size_v<_Tp, _As> + ...)>>\n   concat(const simd<_Tp, _As>&... __xs)\n@@ -4589,6 +4686,7 @@ template <typename _Tp, typename _Abi>\n       template <typename _Up, typename _A2,\n \t\ttypename\n \t\t= enable_if_t<simd_size_v<_Up, _A2> == simd_size_v<_Tp, _Abi>>>\n+\t_GLIBCXX_SIMD_ALWAYS_INLINE\n \toperator simd_mask<_Up, _A2>() &&\n \t{\n \t  using namespace std::experimental::__proposed;\n@@ -4826,121 +4924,153 @@ find_last_set(_ExactBool)\n \n /// @cond undocumented\n // _SimdIntOperators{{{1\n-template <typename _V, typename _Impl, bool>\n+template <typename _V, typename _Tp, typename _Abi, bool>\n   class _SimdIntOperators {};\n \n-template <typename _V, typename _Impl>\n-  class _SimdIntOperators<_V, _Impl, true>\n+template <typename _V, typename _Tp, typename _Abi>\n+  class _SimdIntOperators<_V, _Tp, _Abi, true>\n   {\n+    using _Impl = typename _SimdTraits<_Tp, _Abi>::_SimdImpl;\n+\n     _GLIBCXX_SIMD_INTRINSIC const _V& __derived() const\n     { return *static_cast<const _V*>(this); }\n \n-    template <typename _Tp>\n+    template <typename _Up>\n       _GLIBCXX_SIMD_INTRINSIC static _GLIBCXX_SIMD_CONSTEXPR _V\n-      _S_make_derived(_Tp&& __d)\n-      { return {__private_init, static_cast<_Tp&&>(__d)}; }\n+      _S_make_derived(_Up&& __d)\n+      { return {__private_init, static_cast<_Up&&>(__d)}; }\n \n   public:\n-    _GLIBCXX_SIMD_CONSTEXPR friend _V& operator%=(_V& __lhs, const _V& __x)\n+    _GLIBCXX_SIMD_ALWAYS_INLINE _GLIBCXX_SIMD_CONSTEXPR friend\n+    _V&\n+    operator%=(_V& __lhs, const _V& __x)\n     { return __lhs = __lhs % __x; }\n \n-    _GLIBCXX_SIMD_CONSTEXPR friend _V& operator&=(_V& __lhs, const _V& __x)\n+    _GLIBCXX_SIMD_ALWAYS_INLINE _GLIBCXX_SIMD_CONSTEXPR friend\n+    _V&\n+    operator&=(_V& __lhs, const _V& __x)\n     { return __lhs = __lhs & __x; }\n \n-    _GLIBCXX_SIMD_CONSTEXPR friend _V& operator|=(_V& __lhs, const _V& __x)\n+    _GLIBCXX_SIMD_ALWAYS_INLINE _GLIBCXX_SIMD_CONSTEXPR friend\n+    _V&\n+    operator|=(_V& __lhs, const _V& __x)\n     { return __lhs = __lhs | __x; }\n \n-    _GLIBCXX_SIMD_CONSTEXPR friend _V& operator^=(_V& __lhs, const _V& __x)\n+    _GLIBCXX_SIMD_ALWAYS_INLINE _GLIBCXX_SIMD_CONSTEXPR friend\n+    _V&\n+    operator^=(_V& __lhs, const _V& __x)\n     { return __lhs = __lhs ^ __x; }\n \n-    _GLIBCXX_SIMD_CONSTEXPR friend _V& operator<<=(_V& __lhs, const _V& __x)\n+    _GLIBCXX_SIMD_ALWAYS_INLINE _GLIBCXX_SIMD_CONSTEXPR friend\n+    _V&\n+    operator<<=(_V& __lhs, const _V& __x)\n     { return __lhs = __lhs << __x; }\n \n-    _GLIBCXX_SIMD_CONSTEXPR friend _V& operator>>=(_V& __lhs, const _V& __x)\n+    _GLIBCXX_SIMD_ALWAYS_INLINE _GLIBCXX_SIMD_CONSTEXPR friend\n+    _V&\n+    operator>>=(_V& __lhs, const _V& __x)\n     { return __lhs = __lhs >> __x; }\n \n-    _GLIBCXX_SIMD_CONSTEXPR friend _V& operator<<=(_V& __lhs, int __x)\n+    _GLIBCXX_SIMD_ALWAYS_INLINE _GLIBCXX_SIMD_CONSTEXPR friend\n+    _V&\n+    operator<<=(_V& __lhs, int __x)\n     { return __lhs = __lhs << __x; }\n \n-    _GLIBCXX_SIMD_CONSTEXPR friend _V& operator>>=(_V& __lhs, int __x)\n+    _GLIBCXX_SIMD_ALWAYS_INLINE _GLIBCXX_SIMD_CONSTEXPR friend\n+    _V&\n+    operator>>=(_V& __lhs, int __x)\n     { return __lhs = __lhs >> __x; }\n \n-    _GLIBCXX_SIMD_CONSTEXPR friend _V operator%(const _V& __x, const _V& __y)\n+    _GLIBCXX_SIMD_ALWAYS_INLINE _GLIBCXX_SIMD_CONSTEXPR friend\n+    _V\n+    operator%(const _V& __x, const _V& __y)\n     {\n       return _SimdIntOperators::_S_make_derived(\n \t_Impl::_S_modulus(__data(__x), __data(__y)));\n     }\n \n-    _GLIBCXX_SIMD_CONSTEXPR friend _V operator&(const _V& __x, const _V& __y)\n+    _GLIBCXX_SIMD_ALWAYS_INLINE _GLIBCXX_SIMD_CONSTEXPR friend\n+    _V\n+    operator&(const _V& __x, const _V& __y)\n     {\n       return _SimdIntOperators::_S_make_derived(\n \t_Impl::_S_bit_and(__data(__x), __data(__y)));\n     }\n \n-    _GLIBCXX_SIMD_CONSTEXPR friend _V operator|(const _V& __x, const _V& __y)\n+    _GLIBCXX_SIMD_ALWAYS_INLINE _GLIBCXX_SIMD_CONSTEXPR friend\n+    _V\n+    operator|(const _V& __x, const _V& __y)\n     {\n       return _SimdIntOperators::_S_make_derived(\n \t_Impl::_S_bit_or(__data(__x), __data(__y)));\n     }\n \n-    _GLIBCXX_SIMD_CONSTEXPR friend _V operator^(const _V& __x, const _V& __y)\n+    _GLIBCXX_SIMD_ALWAYS_INLINE _GLIBCXX_SIMD_CONSTEXPR friend\n+    _V\n+    operator^(const _V& __x, const _V& __y)\n     {\n       return _SimdIntOperators::_S_make_derived(\n \t_Impl::_S_bit_xor(__data(__x), __data(__y)));\n     }\n \n-    _GLIBCXX_SIMD_CONSTEXPR friend _V operator<<(const _V& __x, const _V& __y)\n+    _GLIBCXX_SIMD_ALWAYS_INLINE _GLIBCXX_SIMD_CONSTEXPR friend\n+    _V\n+    operator<<(const _V& __x, const _V& __y)\n     {\n       return _SimdIntOperators::_S_make_derived(\n \t_Impl::_S_bit_shift_left(__data(__x), __data(__y)));\n     }\n \n-    _GLIBCXX_SIMD_CONSTEXPR friend _V operator>>(const _V& __x, const _V& __y)\n+    _GLIBCXX_SIMD_ALWAYS_INLINE _GLIBCXX_SIMD_CONSTEXPR friend\n+    _V\n+    operator>>(const _V& __x, const _V& __y)\n     {\n       return _SimdIntOperators::_S_make_derived(\n \t_Impl::_S_bit_shift_right(__data(__x), __data(__y)));\n     }\n \n-    template <typename _VV = _V>\n-      _GLIBCXX_SIMD_CONSTEXPR friend _V operator<<(const _V& __x, int __y)\n-      {\n-\tusing _Tp = typename _VV::value_type;\n-\tif (__y < 0)\n-\t  __invoke_ub(\"The behavior is undefined if the right operand of a \"\n-\t\t      \"shift operation is negative. [expr.shift]\\nA shift by \"\n-\t\t      \"%d was requested\",\n-\t\t      __y);\n-\tif (size_t(__y) >= sizeof(declval<_Tp>() << __y) * __CHAR_BIT__)\n-\t  __invoke_ub(\n-\t    \"The behavior is undefined if the right operand of a \"\n-\t    \"shift operation is greater than or equal to the width of the \"\n-\t    \"promoted left operand. [expr.shift]\\nA shift by %d was requested\",\n-\t    __y);\n-\treturn _SimdIntOperators::_S_make_derived(\n-\t  _Impl::_S_bit_shift_left(__data(__x), __y));\n-      }\n+    _GLIBCXX_SIMD_ALWAYS_INLINE _GLIBCXX_SIMD_CONSTEXPR friend\n+    _V\n+    operator<<(const _V& __x, int __y)\n+    {\n+      if (__y < 0)\n+\t__invoke_ub(\"The behavior is undefined if the right operand of a \"\n+\t\t    \"shift operation is negative. [expr.shift]\\nA shift by \"\n+\t\t    \"%d was requested\",\n+\t\t    __y);\n+      if (size_t(__y) >= sizeof(declval<_Tp>() << __y) * __CHAR_BIT__)\n+\t__invoke_ub(\n+\t  \"The behavior is undefined if the right operand of a \"\n+\t  \"shift operation is greater than or equal to the width of the \"\n+\t  \"promoted left operand. [expr.shift]\\nA shift by %d was requested\",\n+\t  __y);\n+      return _SimdIntOperators::_S_make_derived(\n+\t_Impl::_S_bit_shift_left(__data(__x), __y));\n+    }\n \n-    template <typename _VV = _V>\n-      _GLIBCXX_SIMD_CONSTEXPR friend _V operator>>(const _V& __x, int __y)\n-      {\n-\tusing _Tp = typename _VV::value_type;\n-\tif (__y < 0)\n-\t  __invoke_ub(\n-\t    \"The behavior is undefined if the right operand of a shift \"\n-\t    \"operation is negative. [expr.shift]\\nA shift by %d was requested\",\n-\t    __y);\n-\tif (size_t(__y) >= sizeof(declval<_Tp>() << __y) * __CHAR_BIT__)\n-\t  __invoke_ub(\n-\t    \"The behavior is undefined if the right operand of a shift \"\n-\t    \"operation is greater than or equal to the width of the promoted \"\n-\t    \"left operand. [expr.shift]\\nA shift by %d was requested\",\n-\t    __y);\n-\treturn _SimdIntOperators::_S_make_derived(\n-\t  _Impl::_S_bit_shift_right(__data(__x), __y));\n-      }\n+    _GLIBCXX_SIMD_ALWAYS_INLINE _GLIBCXX_SIMD_CONSTEXPR friend\n+    _V\n+    operator>>(const _V& __x, int __y)\n+    {\n+      if (__y < 0)\n+\t__invoke_ub(\n+\t  \"The behavior is undefined if the right operand of a shift \"\n+\t  \"operation is negative. [expr.shift]\\nA shift by %d was requested\",\n+\t  __y);\n+      if (size_t(__y) >= sizeof(declval<_Tp>() << __y) * __CHAR_BIT__)\n+\t__invoke_ub(\n+\t  \"The behavior is undefined if the right operand of a shift \"\n+\t  \"operation is greater than or equal to the width of the promoted \"\n+\t  \"left operand. [expr.shift]\\nA shift by %d was requested\",\n+\t  __y);\n+      return _SimdIntOperators::_S_make_derived(\n+\t_Impl::_S_bit_shift_right(__data(__x), __y));\n+    }\n \n     // unary operators (for integral _Tp)\n-    _GLIBCXX_SIMD_CONSTEXPR _V operator~() const\n+    _GLIBCXX_SIMD_ALWAYS_INLINE _GLIBCXX_SIMD_CONSTEXPR\n+    _V\n+    operator~() const\n     { return {__private_init, _Impl::_S_complement(__derived()._M_data)}; }\n   };\n \n@@ -4950,7 +5080,7 @@ template <typename _V, typename _Impl>\n // simd {{{\n template <typename _Tp, typename _Abi>\n   class simd : public _SimdIntOperators<\n-\t\t simd<_Tp, _Abi>, typename _SimdTraits<_Tp, _Abi>::_SimdImpl,\n+\t\t simd<_Tp, _Abi>, _Tp, _Abi,\n \t\t conjunction<is_integral<_Tp>,\n \t\t\t     typename _SimdTraits<_Tp, _Abi>::_IsValid>::value>,\n \t       public _SimdTraits<_Tp, _Abi>::_SimdBase\n@@ -4964,7 +5094,7 @@ template <typename _Tp, typename _Abi>\n   public:\n     using _Impl = typename _Traits::_SimdImpl;\n     friend _Impl;\n-    friend _SimdIntOperators<simd, _Impl, true>;\n+    friend _SimdIntOperators<simd, _Tp, _Abi, true>;\n \n     using value_type = _Tp;\n     using reference = _SmartReference<_MemberType, _Impl, value_type>;"}, {"sha": "019b98e8c37551e6544914d54e8e3800b350d4ef", "filename": "libstdc++-v3/include/experimental/bits/simd_builtin.h", "status": "modified", "additions": 28, "deletions": 13, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52d28210389ff3d4af8f20db4db1f0d58b0f8eff/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Fsimd_builtin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52d28210389ff3d4af8f20db4db1f0d58b0f8eff/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Fsimd_builtin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Fsimd_builtin.h?ref=52d28210389ff3d4af8f20db4db1f0d58b0f8eff", "patch": "@@ -50,7 +50,8 @@ template <typename _V, typename = _VectorTraits<_V>>\n //}}}\n // __vector_permute<Indices...>{{{\n // Index == -1 requests zeroing of the output element\n-template <int... _Indices, typename _Tp, typename _TVT = _VectorTraits<_Tp>>\n+template <int... _Indices, typename _Tp, typename _TVT = _VectorTraits<_Tp>,\n+\t  typename = __detail::__odr_helper>\n   _Tp\n   __vector_permute(_Tp __x)\n   {\n@@ -62,7 +63,8 @@ template <int... _Indices, typename _Tp, typename _TVT = _VectorTraits<_Tp>>\n // }}}\n // __vector_shuffle<Indices...>{{{\n // Index == -1 requests zeroing of the output element\n-template <int... _Indices, typename _Tp, typename _TVT = _VectorTraits<_Tp>>\n+template <int... _Indices, typename _Tp, typename _TVT = _VectorTraits<_Tp>,\n+\t  typename = __detail::__odr_helper>\n   _Tp\n   __vector_shuffle(_Tp __x, _Tp __y)\n   {\n@@ -820,10 +822,12 @@ template <typename _Tp, typename _Mp, typename _Abi, size_t _Np>\n     // _SimdBase / base class for simd, providing extra conversions {{{\n     struct _SimdBase2\n     {\n+      _GLIBCXX_SIMD_ALWAYS_INLINE\n       explicit operator __intrinsic_type_t<_Tp, _Np>() const\n       {\n \treturn __to_intrin(static_cast<const simd<_Tp, _Abi>*>(this)->_M_data);\n       }\n+      _GLIBCXX_SIMD_ALWAYS_INLINE\n       explicit operator __vector_type_t<_Tp, _Np>() const\n       {\n \treturn static_cast<const simd<_Tp, _Abi>*>(this)->_M_data.__builtin();\n@@ -832,6 +836,7 @@ template <typename _Tp, typename _Mp, typename _Abi, size_t _Np>\n \n     struct _SimdBase1\n     {\n+      _GLIBCXX_SIMD_ALWAYS_INLINE\n       explicit operator __intrinsic_type_t<_Tp, _Np>() const\n       { return __data(*static_cast<const simd<_Tp, _Abi>*>(this)); }\n     };\n@@ -844,11 +849,13 @@ template <typename _Tp, typename _Mp, typename _Abi, size_t _Np>\n     // _MaskBase {{{\n     struct _MaskBase2\n     {\n+      _GLIBCXX_SIMD_ALWAYS_INLINE\n       explicit operator __intrinsic_type_t<_Tp, _Np>() const\n       {\n \treturn static_cast<const simd_mask<_Tp, _Abi>*>(this)\n \t  ->_M_data.__intrin();\n       }\n+      _GLIBCXX_SIMD_ALWAYS_INLINE\n       explicit operator __vector_type_t<_Tp, _Np>() const\n       {\n \treturn static_cast<const simd_mask<_Tp, _Abi>*>(this)->_M_data._M_data;\n@@ -857,6 +864,7 @@ template <typename _Tp, typename _Mp, typename _Abi, size_t _Np>\n \n     struct _MaskBase1\n     {\n+      _GLIBCXX_SIMD_ALWAYS_INLINE\n       explicit operator __intrinsic_type_t<_Tp, _Np>() const\n       { return __data(*static_cast<const simd_mask<_Tp, _Abi>*>(this)); }\n     };\n@@ -874,7 +882,9 @@ template <typename _Tp, typename _Mp, typename _Abi, size_t _Np>\n       _Up _M_data;\n \n     public:\n+      _GLIBCXX_SIMD_ALWAYS_INLINE\n       _MaskCastType(_Up __x) : _M_data(__x) {}\n+      _GLIBCXX_SIMD_ALWAYS_INLINE\n       operator _MaskMember() const { return _M_data; }\n     };\n \n@@ -887,7 +897,9 @@ template <typename _Tp, typename _Mp, typename _Abi, size_t _Np>\n       _SimdMember _M_data;\n \n     public:\n+      _GLIBCXX_SIMD_ALWAYS_INLINE\n       _SimdCastType1(_Ap __a) : _M_data(__vector_bitcast<_Tp>(__a)) {}\n+      _GLIBCXX_SIMD_ALWAYS_INLINE\n       operator _SimdMember() const { return _M_data; }\n     };\n \n@@ -898,8 +910,11 @@ template <typename _Tp, typename _Mp, typename _Abi, size_t _Np>\n       _SimdMember _M_data;\n \n     public:\n+      _GLIBCXX_SIMD_ALWAYS_INLINE\n       _SimdCastType2(_Ap __a) : _M_data(__vector_bitcast<_Tp>(__a)) {}\n+      _GLIBCXX_SIMD_ALWAYS_INLINE\n       _SimdCastType2(_Bp __b) : _M_data(__b) {}\n+      _GLIBCXX_SIMD_ALWAYS_INLINE\n       operator _SimdMember() const { return _M_data; }\n     };\n \n@@ -913,14 +928,14 @@ template <typename _Tp, typename _Mp, typename _Abi, size_t _Np>\n struct _CommonImplX86;\n struct _CommonImplNeon;\n struct _CommonImplBuiltin;\n-template <typename _Abi> struct _SimdImplBuiltin;\n-template <typename _Abi> struct _MaskImplBuiltin;\n-template <typename _Abi> struct _SimdImplX86;\n-template <typename _Abi> struct _MaskImplX86;\n-template <typename _Abi> struct _SimdImplNeon;\n-template <typename _Abi> struct _MaskImplNeon;\n-template <typename _Abi> struct _SimdImplPpc;\n-template <typename _Abi> struct _MaskImplPpc;\n+template <typename _Abi, typename = __detail::__odr_helper> struct _SimdImplBuiltin;\n+template <typename _Abi, typename = __detail::__odr_helper> struct _MaskImplBuiltin;\n+template <typename _Abi, typename = __detail::__odr_helper> struct _SimdImplX86;\n+template <typename _Abi, typename = __detail::__odr_helper> struct _MaskImplX86;\n+template <typename _Abi, typename = __detail::__odr_helper> struct _SimdImplNeon;\n+template <typename _Abi, typename = __detail::__odr_helper> struct _MaskImplNeon;\n+template <typename _Abi, typename = __detail::__odr_helper> struct _SimdImplPpc;\n+template <typename _Abi, typename = __detail::__odr_helper> struct _MaskImplPpc;\n \n // simd_abi::_VecBuiltin {{{\n template <int _UsedBytes>\n@@ -1369,7 +1384,7 @@ struct _CommonImplBuiltin\n \n // }}}\n // _SimdImplBuiltin {{{1\n-template <typename _Abi>\n+template <typename _Abi, typename>\n   struct _SimdImplBuiltin\n   {\n     // member types {{{2\n@@ -2618,7 +2633,7 @@ struct _MaskImplBuiltinMixin\n };\n \n // _MaskImplBuiltin {{{1\n-template <typename _Abi>\n+template <typename _Abi, typename>\n   struct _MaskImplBuiltin : _MaskImplBuiltinMixin\n   {\n     using _MaskImplBuiltinMixin::_S_to_bits;\n@@ -2953,4 +2968,4 @@ _GLIBCXX_SIMD_END_NAMESPACE\n #endif // __cplusplus >= 201703L\n #endif // _GLIBCXX_EXPERIMENTAL_SIMD_ABIS_H_\n \n-// vim: foldmethod=marker foldmarker={{{,}}} sw=2 noet ts=8 sts=2 tw=80\n+// vim: foldmethod=marker foldmarker={{{,}}} sw=2 noet ts=8 sts=2 tw=100"}, {"sha": "9135d3e75d346f3365e45218e59c4f1a228eff16", "filename": "libstdc++-v3/include/experimental/bits/simd_detail.h", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52d28210389ff3d4af8f20db4db1f0d58b0f8eff/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Fsimd_detail.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52d28210389ff3d4af8f20db4db1f0d58b0f8eff/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Fsimd_detail.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Fsimd_detail.h?ref=52d28210389ff3d4af8f20db4db1f0d58b0f8eff", "patch": "@@ -173,6 +173,46 @@\n #else\n #define _GLIBCXX_SIMD_HAVE_AVX512BW 0\n #endif\n+#ifdef __AVX512BITALG__\n+#define _GLIBCXX_SIMD_HAVE_AVX512BITALG 1\n+#else\n+#define _GLIBCXX_SIMD_HAVE_AVX512BITALG 0\n+#endif\n+#ifdef __AVX512VBMI2__\n+#define _GLIBCXX_SIMD_HAVE_AVX512VBMI2 1\n+#else\n+#define _GLIBCXX_SIMD_HAVE_AVX512VBMI2 0\n+#endif\n+#ifdef __AVX512VBMI__\n+#define _GLIBCXX_SIMD_HAVE_AVX512VBMI 1\n+#else\n+#define _GLIBCXX_SIMD_HAVE_AVX512VBMI 0\n+#endif\n+#ifdef __AVX512IFMA__\n+#define _GLIBCXX_SIMD_HAVE_AVX512IFMA 1\n+#else\n+#define _GLIBCXX_SIMD_HAVE_AVX512IFMA 0\n+#endif\n+#ifdef __AVX512CD__\n+#define _GLIBCXX_SIMD_HAVE_AVX512CD 1\n+#else\n+#define _GLIBCXX_SIMD_HAVE_AVX512CD 0\n+#endif\n+#ifdef __AVX512VNNI__\n+#define _GLIBCXX_SIMD_HAVE_AVX512VNNI 1\n+#else\n+#define _GLIBCXX_SIMD_HAVE_AVX512VNNI 0\n+#endif\n+#ifdef __AVX512VPOPCNTDQ__\n+#define _GLIBCXX_SIMD_HAVE_AVX512VPOPCNTDQ 1\n+#else\n+#define _GLIBCXX_SIMD_HAVE_AVX512VPOPCNTDQ 0\n+#endif\n+#ifdef __AVX512VP2INTERSECT__\n+#define _GLIBCXX_SIMD_HAVE_AVX512VP2INTERSECT 1\n+#else\n+#define _GLIBCXX_SIMD_HAVE_AVX512VP2INTERSECT 0\n+#endif\n \n #if _GLIBCXX_SIMD_HAVE_SSE\n #define _GLIBCXX_SIMD_HAVE_SSE_ABI 1"}, {"sha": "7bb248cf9d0a4acbbf43e5111db0ec32730ba3bd", "filename": "libstdc++-v3/include/experimental/bits/simd_fixed_size.h", "status": "modified", "additions": 33, "deletions": 6, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52d28210389ff3d4af8f20db4db1f0d58b0f8eff/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Fsimd_fixed_size.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52d28210389ff3d4af8f20db4db1f0d58b0f8eff/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Fsimd_fixed_size.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Fsimd_fixed_size.h?ref=52d28210389ff3d4af8f20db4db1f0d58b0f8eff", "patch": "@@ -201,6 +201,7 @@ template <typename _Tp, typename _Abi, size_t _Offset>\n   };\n \n template <size_t _Offset, typename _Tp, typename _Abi, typename... _As>\n+  _GLIBCXX_SIMD_INTRINSIC\n   __tuple_element_meta<_Tp, _Abi, _Offset>\n   __make_meta(const _SimdTuple<_Tp, _Abi, _As...>&)\n   { return {}; }\n@@ -230,11 +231,13 @@ template <size_t _O0, size_t _O1, typename _Base>\n   struct _WithOffset<_O0, _WithOffset<_O1, _Base>> {};\n \n template <size_t _Offset, typename _Tp>\n+  _GLIBCXX_SIMD_INTRINSIC\n   decltype(auto)\n   __add_offset(_Tp& __base)\n   { return static_cast<_WithOffset<_Offset, __remove_cvref_t<_Tp>>&>(__base); }\n \n template <size_t _Offset, typename _Tp>\n+  _GLIBCXX_SIMD_INTRINSIC\n   decltype(auto)\n   __add_offset(const _Tp& __base)\n   {\n@@ -243,6 +246,7 @@ template <size_t _Offset, typename _Tp>\n   }\n \n template <size_t _Offset, size_t _ExistingOffset, typename _Tp>\n+  _GLIBCXX_SIMD_INTRINSIC\n   decltype(auto)\n   __add_offset(_WithOffset<_ExistingOffset, _Tp>& __base)\n   {\n@@ -251,6 +255,7 @@ template <size_t _Offset, size_t _ExistingOffset, typename _Tp>\n   }\n \n template <size_t _Offset, size_t _ExistingOffset, typename _Tp>\n+  _GLIBCXX_SIMD_INTRINSIC\n   decltype(auto)\n   __add_offset(const _WithOffset<_ExistingOffset, _Tp>& __base)\n   {\n@@ -586,6 +591,7 @@ template <typename _Tp, typename _Abi0, typename... _Abis>\n \t  return second[integral_constant<_Up, _I - simd_size_v<_Tp, _Abi0>>()];\n       }\n \n+    _GLIBCXX_SIMD_INTRINSIC\n     _Tp operator[](size_t __i) const noexcept\n     {\n       if constexpr (_S_tuple_size == 1)\n@@ -608,6 +614,7 @@ template <typename _Tp, typename _Abi0, typename... _Abis>\n \t}\n     }\n \n+    _GLIBCXX_SIMD_INTRINSIC\n     void _M_set(size_t __i, _Tp __val) noexcept\n     {\n       if constexpr (_S_tuple_size == 1)\n@@ -627,6 +634,7 @@ template <typename _Tp, typename _Abi0, typename... _Abis>\n \n   private:\n     // _M_subscript_read/_write {{{\n+    _GLIBCXX_SIMD_INTRINSIC\n     _Tp _M_subscript_read([[maybe_unused]] size_t __i) const noexcept\n     {\n       if constexpr (__is_vectorizable_v<_FirstType>)\n@@ -635,6 +643,7 @@ template <typename _Tp, typename _Abi0, typename... _Abis>\n \treturn first[__i];\n     }\n \n+    _GLIBCXX_SIMD_INTRINSIC\n     void _M_subscript_write([[maybe_unused]] size_t __i, _Tp __y) noexcept\n     {\n       if constexpr (__is_vectorizable_v<_FirstType>)\n@@ -1033,37 +1042,44 @@ template <typename _Tp, bool = is_arithmetic_v<__remove_cvref_t<_Tp>>>\n     _Tp _M_data;\n     using _TT = __remove_cvref_t<_Tp>;\n \n+    _GLIBCXX_SIMD_INTRINSIC\n     operator _TT()\n     { return _M_data; }\n \n+    _GLIBCXX_SIMD_INTRINSIC\n     operator _TT&()\n     {\n       static_assert(is_lvalue_reference<_Tp>::value, \"\");\n       static_assert(!is_const<_Tp>::value, \"\");\n       return _M_data;\n     }\n \n+    _GLIBCXX_SIMD_INTRINSIC\n     operator _TT*()\n     {\n       static_assert(is_lvalue_reference<_Tp>::value, \"\");\n       static_assert(!is_const<_Tp>::value, \"\");\n       return &_M_data;\n     }\n \n-    constexpr inline __autocvt_to_simd(_Tp dd) : _M_data(dd) {}\n+    _GLIBCXX_SIMD_INTRINSIC\n+    constexpr __autocvt_to_simd(_Tp dd) : _M_data(dd) {}\n \n     template <typename _Abi>\n+      _GLIBCXX_SIMD_INTRINSIC\n       operator simd<typename _TT::value_type, _Abi>()\n       { return {__private_init, _M_data}; }\n \n     template <typename _Abi>\n+      _GLIBCXX_SIMD_INTRINSIC\n       operator simd<typename _TT::value_type, _Abi>&()\n       {\n \treturn *reinterpret_cast<simd<typename _TT::value_type, _Abi>*>(\n \t  &_M_data);\n       }\n \n     template <typename _Abi>\n+      _GLIBCXX_SIMD_INTRINSIC\n       operator simd<typename _TT::value_type, _Abi>*()\n       {\n \treturn reinterpret_cast<simd<typename _TT::value_type, _Abi>*>(\n@@ -1081,21 +1097,26 @@ template <typename _Tp>\n     _Tp _M_data;\n     fixed_size_simd<_TT, 1> _M_fd;\n \n-    constexpr inline __autocvt_to_simd(_Tp dd) : _M_data(dd), _M_fd(_M_data) {}\n+    _GLIBCXX_SIMD_INTRINSIC\n+    constexpr __autocvt_to_simd(_Tp dd) : _M_data(dd), _M_fd(_M_data) {}\n \n+    _GLIBCXX_SIMD_INTRINSIC\n     ~__autocvt_to_simd()\n     { _M_data = __data(_M_fd).first; }\n \n+    _GLIBCXX_SIMD_INTRINSIC\n     operator fixed_size_simd<_TT, 1>()\n     { return _M_fd; }\n \n+    _GLIBCXX_SIMD_INTRINSIC\n     operator fixed_size_simd<_TT, 1> &()\n     {\n       static_assert(is_lvalue_reference<_Tp>::value, \"\");\n       static_assert(!is_const<_Tp>::value, \"\");\n       return _M_fd;\n     }\n \n+    _GLIBCXX_SIMD_INTRINSIC\n     operator fixed_size_simd<_TT, 1> *()\n     {\n       static_assert(is_lvalue_reference<_Tp>::value, \"\");\n@@ -1107,8 +1128,8 @@ template <typename _Tp>\n // }}}\n \n struct _CommonImplFixedSize;\n-template <int _Np> struct _SimdImplFixedSize;\n-template <int _Np> struct _MaskImplFixedSize;\n+template <int _Np, typename = __detail::__odr_helper> struct _SimdImplFixedSize;\n+template <int _Np, typename = __detail::__odr_helper> struct _MaskImplFixedSize;\n // simd_abi::_Fixed {{{\n template <int _Np>\n   struct simd_abi::_Fixed\n@@ -1172,12 +1193,15 @@ template <int _Np>\n \t{\n \t  // The following ensures, function arguments are passed via the stack.\n \t  // This is important for ABI compatibility across TU boundaries\n+\t  _GLIBCXX_SIMD_ALWAYS_INLINE\n \t  _SimdBase(const _SimdBase&) {}\n \t  _SimdBase() = default;\n \n+\t  _GLIBCXX_SIMD_ALWAYS_INLINE\n \t  explicit operator const _SimdMember &() const\n \t  { return static_cast<const simd<_Tp, _Fixed>*>(this)->_M_data; }\n \n+\t  _GLIBCXX_SIMD_ALWAYS_INLINE\n \t  explicit operator array<_Tp, _Np>() const\n \t  {\n \t    array<_Tp, _Np> __r;\n@@ -1198,8 +1222,11 @@ template <int _Np>\n \t// _SimdCastType {{{\n \tstruct _SimdCastType\n \t{\n+\t  _GLIBCXX_SIMD_ALWAYS_INLINE\n \t  _SimdCastType(const array<_Tp, _Np>&);\n+\t  _GLIBCXX_SIMD_ALWAYS_INLINE\n \t  _SimdCastType(const _SimdMember& dd) : _M_data(dd) {}\n+\t  _GLIBCXX_SIMD_ALWAYS_INLINE\n \t  explicit operator const _SimdMember &() const { return _M_data; }\n \n \tprivate:\n@@ -1237,7 +1264,7 @@ struct _CommonImplFixedSize\n // _SimdImplFixedSize {{{1\n // fixed_size should not inherit from _SimdMathFallback in order for\n // specializations in the used _SimdTuple Abis to get used\n-template <int _Np>\n+template <int _Np, typename>\n   struct _SimdImplFixedSize\n   {\n     // member types {{{2\n@@ -1794,7 +1821,7 @@ template <int _Np>\n   };\n \n // _MaskImplFixedSize {{{1\n-template <int _Np>\n+template <int _Np, typename>\n   struct _MaskImplFixedSize\n   {\n     static_assert("}, {"sha": "5fe44adceb52e3f694dd7775a63dac2dc772fd85", "filename": "libstdc++-v3/include/experimental/bits/simd_math.h", "status": "modified", "additions": 28, "deletions": 17, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52d28210389ff3d4af8f20db4db1f0d58b0f8eff/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Fsimd_math.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52d28210389ff3d4af8f20db4db1f0d58b0f8eff/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Fsimd_math.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Fsimd_math.h?ref=52d28210389ff3d4af8f20db4db1f0d58b0f8eff", "patch": "@@ -60,6 +60,7 @@ template <typename _DoubleR, typename _Tp, typename _Abi>\n template <typename _Tp, typename _Abi, typename...,                            \\\n \t  typename _R = _Math_return_type_t<                                   \\\n \t    decltype(std::__name(declval<double>())), _Tp, _Abi>>              \\\n+  _GLIBCXX_SIMD_ALWAYS_INLINE                                                  \\\n   enable_if_t<is_floating_point_v<_Tp>, _R>                                    \\\n   __name(simd<_Tp, _Abi> __x)                                                  \\\n   { return {__private_init, _Abi::_SimdImpl::_S_##__name(__data(__x))}; }\n@@ -125,6 +126,7 @@ template <                                                                     \\\n   typename _Arg2 = _Extra_argument_type<__arg2, _Tp, _Abi>,                    \\\n   typename _R = _Math_return_type_t<                                           \\\n     decltype(std::__name(declval<double>(), _Arg2::declval())), _Tp, _Abi>>    \\\n+  _GLIBCXX_SIMD_ALWAYS_INLINE                                                  \\\n   enable_if_t<is_floating_point_v<_Tp>, _R>                                    \\\n   __name(const simd<_Tp, _Abi>& __x, const typename _Arg2::type& __y)          \\\n   {                                                                            \\\n@@ -155,6 +157,7 @@ template <typename _Tp, typename _Abi, typename...,                            \\\n \t    decltype(std::__name(declval<double>(), _Arg2::declval(),          \\\n \t\t\t\t _Arg3::declval())),                           \\\n \t    _Tp, _Abi>>                                                        \\\n+  _GLIBCXX_SIMD_ALWAYS_INLINE                                                  \\\n   enable_if_t<is_floating_point_v<_Tp>, _R>                                    \\\n   __name(const simd<_Tp, _Abi>& __x, const typename _Arg2::type& __y,          \\\n \t const typename _Arg3::type& __z)                                      \\\n@@ -399,6 +402,7 @@ template <typename _Abi>\n // }}}\n // __extract_exponent_as_int {{{\n template <typename _Tp, typename _Abi>\n+  _GLIBCXX_SIMD_INTRINSIC\n   rebind_simd_t<int, simd<_Tp, _Abi>>\n   __extract_exponent_as_int(const simd<_Tp, _Abi>& __v)\n   {\n@@ -422,7 +426,8 @@ template <typename ImplFun, typename FallbackFun, typename... _Args>\n     -> decltype(__impl_fun(static_cast<_Args&&>(__args)...))\n   { return __impl_fun(static_cast<_Args&&>(__args)...); }\n \n-template <typename ImplFun, typename FallbackFun, typename... _Args>\n+template <typename ImplFun, typename FallbackFun, typename... _Args,\n+\t  typename = __detail::__odr_helper>\n   inline auto\n   __impl_or_fallback_dispatch(float, ImplFun&&, FallbackFun&& __fallback_fun,\n \t\t\t      _Args&&... __args)\n@@ -458,7 +463,7 @@ _GLIBCXX_SIMD_MATH_CALL2_(atan2, _Tp)\n  * Fix sign.\n  */\n // cos{{{\n-template <typename _Tp, typename _Abi>\n+template <typename _Tp, typename _Abi, typename = __detail::__odr_helper>\n   enable_if_t<is_floating_point_v<_Tp>, simd<_Tp, _Abi>>\n   cos(const simd<_Tp, _Abi>& __x)\n   {\n@@ -504,7 +509,7 @@ template <typename _Tp>\n \n //}}}\n // sin{{{\n-template <typename _Tp, typename _Abi>\n+template <typename _Tp, typename _Abi, typename = __detail::__odr_helper>\n   enable_if_t<is_floating_point_v<_Tp>, simd<_Tp, _Abi>>\n   sin(const simd<_Tp, _Abi>& __x)\n   {\n@@ -566,6 +571,7 @@ _GLIBCXX_SIMD_MATH_CALL_(expm1)\n // frexp {{{\n #if _GLIBCXX_SIMD_X86INTRIN\n template <typename _Tp, size_t _Np>\n+  _GLIBCXX_SIMD_INTRINSIC\n   _SimdWrapper<_Tp, _Np>\n   __getexp(_SimdWrapper<_Tp, _Np> __x)\n   {\n@@ -594,6 +600,7 @@ template <typename _Tp, size_t _Np>\n   }\n \n template <typename _Tp, size_t _Np>\n+  _GLIBCXX_SIMD_INTRINSIC\n   _SimdWrapper<_Tp, _Np>\n   __getmant_avx512(_SimdWrapper<_Tp, _Np> __x)\n   {\n@@ -634,7 +641,7 @@ template <typename _Tp, size_t _Np>\n  * The return value will be in the range [0.5, 1.0[\n  * The @p __e value will be an integer defining the power-of-two exponent\n  */\n-template <typename _Tp, typename _Abi>\n+template <typename _Tp, typename _Abi, typename = __detail::__odr_helper>\n   enable_if_t<is_floating_point_v<_Tp>, simd<_Tp, _Abi>>\n   frexp(const simd<_Tp, _Abi>& __x, _Samesize<int, simd<_Tp, _Abi>>* __exp)\n   {\n@@ -739,7 +746,7 @@ _GLIBCXX_SIMD_MATH_CALL_(log2)\n \n //}}}\n // logb{{{\n-template <typename _Tp, typename _Abi>\n+template <typename _Tp, typename _Abi, typename = __detail::__odr_helper>\n   enable_if_t<is_floating_point<_Tp>::value, simd<_Tp, _Abi>>\n   logb(const simd<_Tp, _Abi>& __x)\n   {\n@@ -814,7 +821,7 @@ template <typename _Tp, typename _Abi>\n   }\n \n //}}}\n-template <typename _Tp, typename _Abi>\n+template <typename _Tp, typename _Abi, typename = __detail::__odr_helper>\n   enable_if_t<is_floating_point_v<_Tp>, simd<_Tp, _Abi>>\n   modf(const simd<_Tp, _Abi>& __x, simd<_Tp, _Abi>* __iptr)\n   {\n@@ -848,6 +855,7 @@ _GLIBCXX_SIMD_MATH_CALL_(fabs)\n // [parallel.simd.math] only asks for is_floating_point_v<_Tp> and forgot to\n // allow signed integral _Tp\n template <typename _Tp, typename _Abi>\n+  _GLIBCXX_SIMD_ALWAYS_INLINE\n   enable_if_t<!is_floating_point_v<_Tp> && is_signed_v<_Tp>, simd<_Tp, _Abi>>\n   abs(const simd<_Tp, _Abi>& __x)\n   { return {__private_init, _Abi::_SimdImpl::_S_abs(__data(__x))}; }\n@@ -930,7 +938,7 @@ template <typename _R, typename _ToApply, typename _Tp, typename... _Tps>\n \t      __data(__args)...)};\n   }\n \n-template <typename _VV>\n+template <typename _VV, typename = __detail::__odr_helper>\n   __remove_cvref_t<_VV>\n   __hypot(_VV __x, _VV __y)\n   {\n@@ -1069,7 +1077,7 @@ template <typename _Tp, typename _Abi>\n \n _GLIBCXX_SIMD_CVTING2(hypot)\n \n-  template <typename _VV>\n+  template <typename _VV, typename = __detail::__odr_helper>\n   __remove_cvref_t<_VV>\n   __hypot(_VV __x, _VV __y, _VV __z)\n   {\n@@ -1271,7 +1279,7 @@ _GLIBCXX_SIMD_MATH_CALL2_(fmod, _Tp)\n _GLIBCXX_SIMD_MATH_CALL2_(remainder, _Tp)\n _GLIBCXX_SIMD_MATH_CALL3_(remquo, _Tp, int*)\n \n-template <typename _Tp, typename _Abi>\n+template <typename _Tp, typename _Abi, typename = __detail::__odr_helper>\n   enable_if_t<is_floating_point_v<_Tp>, simd<_Tp, _Abi>>\n   copysign(const simd<_Tp, _Abi>& __x, const simd<_Tp, _Abi>& __y)\n   {\n@@ -1303,19 +1311,22 @@ _GLIBCXX_SIMD_MATH_CALL_(isfinite)\n // `int isinf(double)`.\n template <typename _Tp, typename _Abi, typename...,\n \t  typename _R = _Math_return_type_t<bool, _Tp, _Abi>>\n+  _GLIBCXX_SIMD_ALWAYS_INLINE\n   enable_if_t<is_floating_point_v<_Tp>, _R>\n   isinf(simd<_Tp, _Abi> __x)\n   { return {__private_init, _Abi::_SimdImpl::_S_isinf(__data(__x))}; }\n \n template <typename _Tp, typename _Abi, typename...,\n \t  typename _R = _Math_return_type_t<bool, _Tp, _Abi>>\n+  _GLIBCXX_SIMD_ALWAYS_INLINE\n   enable_if_t<is_floating_point_v<_Tp>, _R>\n   isnan(simd<_Tp, _Abi> __x)\n   { return {__private_init, _Abi::_SimdImpl::_S_isnan(__data(__x))}; }\n \n _GLIBCXX_SIMD_MATH_CALL_(isnormal)\n \n template <typename..., typename _Tp, typename _Abi>\n+  _GLIBCXX_SIMD_ALWAYS_INLINE\n   simd_mask<_Tp, _Abi>\n   signbit(simd<_Tp, _Abi> __x)\n   {\n@@ -1363,7 +1374,7 @@ simd_div_t<__llongv<_Abi>> div(__llongv<_Abi> numer,\n */\n \n // special math {{{\n-template <typename _Tp, typename _Abi>\n+template <typename _Tp, typename _Abi, typename = __detail::__odr_helper>\n   enable_if_t<is_floating_point_v<_Tp>, simd<_Tp, _Abi>>\n   assoc_laguerre(const fixed_size_simd<unsigned, simd_size_v<_Tp, _Abi>>& __n,\n \t\t const fixed_size_simd<unsigned, simd_size_v<_Tp, _Abi>>& __m,\n@@ -1374,7 +1385,7 @@ template <typename _Tp, typename _Abi>\n     });\n   }\n \n-template <typename _Tp, typename _Abi>\n+template <typename _Tp, typename _Abi, typename = __detail::__odr_helper>\n   enable_if_t<is_floating_point_v<_Tp>, simd<_Tp, _Abi>>\n   assoc_legendre(const fixed_size_simd<unsigned, simd_size_v<_Tp, _Abi>>& __n,\n \t\t const fixed_size_simd<unsigned, simd_size_v<_Tp, _Abi>>& __m,\n@@ -1398,7 +1409,7 @@ _GLIBCXX_SIMD_MATH_CALL2_(ellint_2, _Tp)\n _GLIBCXX_SIMD_MATH_CALL3_(ellint_3, _Tp, _Tp)\n _GLIBCXX_SIMD_MATH_CALL_(expint)\n \n-template <typename _Tp, typename _Abi>\n+template <typename _Tp, typename _Abi, typename = __detail::__odr_helper>\n   enable_if_t<is_floating_point_v<_Tp>, simd<_Tp, _Abi>>\n   hermite(const fixed_size_simd<unsigned, simd_size_v<_Tp, _Abi>>& __n,\n \t  const simd<_Tp, _Abi>& __x)\n@@ -1407,7 +1418,7 @@ template <typename _Tp, typename _Abi>\n       [&](auto __i) { return std::hermite(__n[__i], __x[__i]); });\n   }\n \n-template <typename _Tp, typename _Abi>\n+template <typename _Tp, typename _Abi, typename = __detail::__odr_helper>\n   enable_if_t<is_floating_point_v<_Tp>, simd<_Tp, _Abi>>\n   laguerre(const fixed_size_simd<unsigned, simd_size_v<_Tp, _Abi>>& __n,\n \t   const simd<_Tp, _Abi>& __x)\n@@ -1416,7 +1427,7 @@ template <typename _Tp, typename _Abi>\n       [&](auto __i) { return std::laguerre(__n[__i], __x[__i]); });\n   }\n \n-template <typename _Tp, typename _Abi>\n+template <typename _Tp, typename _Abi, typename = __detail::__odr_helper>\n   enable_if_t<is_floating_point_v<_Tp>, simd<_Tp, _Abi>>\n   legendre(const fixed_size_simd<unsigned, simd_size_v<_Tp, _Abi>>& __n,\n \t   const simd<_Tp, _Abi>& __x)\n@@ -1427,7 +1438,7 @@ template <typename _Tp, typename _Abi>\n \n _GLIBCXX_SIMD_MATH_CALL_(riemann_zeta)\n \n-template <typename _Tp, typename _Abi>\n+template <typename _Tp, typename _Abi, typename = __detail::__odr_helper>\n   enable_if_t<is_floating_point_v<_Tp>, simd<_Tp, _Abi>>\n   sph_bessel(const fixed_size_simd<unsigned, simd_size_v<_Tp, _Abi>>& __n,\n \t     const simd<_Tp, _Abi>& __x)\n@@ -1436,7 +1447,7 @@ template <typename _Tp, typename _Abi>\n       [&](auto __i) { return std::sph_bessel(__n[__i], __x[__i]); });\n   }\n \n-template <typename _Tp, typename _Abi>\n+template <typename _Tp, typename _Abi, typename = __detail::__odr_helper>\n   enable_if_t<is_floating_point_v<_Tp>, simd<_Tp, _Abi>>\n   sph_legendre(const fixed_size_simd<unsigned, simd_size_v<_Tp, _Abi>>& __l,\n \t       const fixed_size_simd<unsigned, simd_size_v<_Tp, _Abi>>& __m,\n@@ -1447,7 +1458,7 @@ template <typename _Tp, typename _Abi>\n     });\n   }\n \n-template <typename _Tp, typename _Abi>\n+template <typename _Tp, typename _Abi, typename = __detail::__odr_helper>\n   enable_if_t<is_floating_point_v<_Tp>, simd<_Tp, _Abi>>\n   sph_neumann(const fixed_size_simd<unsigned, simd_size_v<_Tp, _Abi>>& __n,\n \t      const simd<_Tp, _Abi>& __x)"}, {"sha": "0945092940a9c5a024d48f98f38b5294c0856810", "filename": "libstdc++-v3/include/experimental/bits/simd_neon.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52d28210389ff3d4af8f20db4db1f0d58b0f8eff/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Fsimd_neon.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52d28210389ff3d4af8f20db4db1f0d58b0f8eff/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Fsimd_neon.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Fsimd_neon.h?ref=52d28210389ff3d4af8f20db4db1f0d58b0f8eff", "patch": "@@ -44,7 +44,7 @@ struct _CommonImplNeon : _CommonImplBuiltin\n \n // }}}\n // _SimdImplNeon {{{\n-template <typename _Abi>\n+template <typename _Abi, typename>\n   struct _SimdImplNeon : _SimdImplBuiltin<_Abi>\n   {\n     using _Base = _SimdImplBuiltin<_Abi>;\n@@ -390,7 +390,7 @@ struct _MaskImplNeonMixin\n \n // }}}\n // _MaskImplNeon {{{\n-template <typename _Abi>\n+template <typename _Abi, typename>\n   struct _MaskImplNeon : _MaskImplNeonMixin, _MaskImplBuiltin<_Abi>\n   {\n     using _MaskImplBuiltinMixin::_S_to_maskvector;"}, {"sha": "a83d970a4575aa7f331bed06f1e19998e7eda22f", "filename": "libstdc++-v3/include/experimental/bits/simd_ppc.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52d28210389ff3d4af8f20db4db1f0d58b0f8eff/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Fsimd_ppc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52d28210389ff3d4af8f20db4db1f0d58b0f8eff/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Fsimd_ppc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Fsimd_ppc.h?ref=52d28210389ff3d4af8f20db4db1f0d58b0f8eff", "patch": "@@ -35,7 +35,7 @@\n _GLIBCXX_SIMD_BEGIN_NAMESPACE\n \n // _SimdImplPpc {{{\n-template <typename _Abi>\n+template <typename _Abi, typename>\n   struct _SimdImplPpc : _SimdImplBuiltin<_Abi>\n   {\n     using _Base = _SimdImplBuiltin<_Abi>;\n@@ -117,7 +117,7 @@ template <typename _Abi>\n \n // }}}\n // _MaskImplPpc {{{\n-template <typename _Abi>\n+template <typename _Abi, typename>\n   struct _MaskImplPpc : _MaskImplBuiltin<_Abi>\n   {\n     using _Base = _MaskImplBuiltin<_Abi>;"}, {"sha": "33c3cefc88dec9f0cdf0a0807b4318838137a17f", "filename": "libstdc++-v3/include/experimental/bits/simd_scalar.h", "status": "modified", "additions": 50, "deletions": 21, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52d28210389ff3d4af8f20db4db1f0d58b0f8eff/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Fsimd_scalar.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52d28210389ff3d4af8f20db4db1f0d58b0f8eff/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Fsimd_scalar.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Fsimd_scalar.h?ref=52d28210389ff3d4af8f20db4db1f0d58b0f8eff", "patch": "@@ -155,7 +155,8 @@ struct _SimdImplScalar\n \n   // _S_masked_load {{{2\n   template <typename _Tp, typename _Up>\n-    static inline _Tp _S_masked_load(_Tp __merge, bool __k,\n+    _GLIBCXX_SIMD_INTRINSIC\n+    static _Tp _S_masked_load(_Tp __merge, bool __k,\n \t\t\t\t     const _Up* __mem) noexcept\n     {\n       if (__k)\n@@ -165,83 +166,97 @@ struct _SimdImplScalar\n \n   // _S_store {{{2\n   template <typename _Tp, typename _Up>\n-    static inline void _S_store(_Tp __v, _Up* __mem, _TypeTag<_Tp>) noexcept\n+    _GLIBCXX_SIMD_INTRINSIC\n+    static void _S_store(_Tp __v, _Up* __mem, _TypeTag<_Tp>) noexcept\n     { __mem[0] = static_cast<_Up>(__v); }\n \n   // _S_masked_store {{{2\n   template <typename _Tp, typename _Up>\n-    static inline void _S_masked_store(const _Tp __v, _Up* __mem,\n+    _GLIBCXX_SIMD_INTRINSIC\n+    static void _S_masked_store(const _Tp __v, _Up* __mem,\n \t\t\t\t       const bool __k) noexcept\n     { if (__k) __mem[0] = __v; }\n \n   // _S_negate {{{2\n   template <typename _Tp>\n-    static constexpr inline bool _S_negate(_Tp __x) noexcept\n+    _GLIBCXX_SIMD_INTRINSIC\n+    static constexpr bool _S_negate(_Tp __x) noexcept\n     { return !__x; }\n \n   // _S_reduce {{{2\n   template <typename _Tp, typename _BinaryOperation>\n-    static constexpr inline _Tp\n+    _GLIBCXX_SIMD_INTRINSIC\n+    static constexpr _Tp\n     _S_reduce(const simd<_Tp, simd_abi::scalar>& __x, const _BinaryOperation&)\n     { return __x._M_data; }\n \n   // _S_min, _S_max {{{2\n   template <typename _Tp>\n-    static constexpr inline _Tp _S_min(const _Tp __a, const _Tp __b)\n+    _GLIBCXX_SIMD_INTRINSIC\n+    static constexpr _Tp _S_min(const _Tp __a, const _Tp __b)\n     { return std::min(__a, __b); }\n \n   template <typename _Tp>\n-    static constexpr inline _Tp _S_max(const _Tp __a, const _Tp __b)\n+    _GLIBCXX_SIMD_INTRINSIC\n+    static constexpr _Tp _S_max(const _Tp __a, const _Tp __b)\n     { return std::max(__a, __b); }\n \n   // _S_complement {{{2\n   template <typename _Tp>\n-    static constexpr inline _Tp _S_complement(_Tp __x) noexcept\n+    _GLIBCXX_SIMD_INTRINSIC\n+    static constexpr _Tp _S_complement(_Tp __x) noexcept\n     { return static_cast<_Tp>(~__x); }\n \n   // _S_unary_minus {{{2\n   template <typename _Tp>\n-    static constexpr inline _Tp _S_unary_minus(_Tp __x) noexcept\n+    _GLIBCXX_SIMD_INTRINSIC\n+    static constexpr _Tp _S_unary_minus(_Tp __x) noexcept\n     { return static_cast<_Tp>(-__x); }\n \n   // arithmetic operators {{{2\n   template <typename _Tp>\n-    static constexpr inline _Tp _S_plus(_Tp __x, _Tp __y)\n+    _GLIBCXX_SIMD_INTRINSIC\n+    static constexpr _Tp _S_plus(_Tp __x, _Tp __y)\n     {\n       return static_cast<_Tp>(__promote_preserving_unsigned(__x)\n \t\t\t      + __promote_preserving_unsigned(__y));\n     }\n \n   template <typename _Tp>\n-    static constexpr inline _Tp _S_minus(_Tp __x, _Tp __y)\n+    _GLIBCXX_SIMD_INTRINSIC\n+    static constexpr _Tp _S_minus(_Tp __x, _Tp __y)\n     {\n       return static_cast<_Tp>(__promote_preserving_unsigned(__x)\n \t\t\t      - __promote_preserving_unsigned(__y));\n     }\n \n   template <typename _Tp>\n-    static constexpr inline _Tp _S_multiplies(_Tp __x, _Tp __y)\n+    _GLIBCXX_SIMD_INTRINSIC\n+    static constexpr _Tp _S_multiplies(_Tp __x, _Tp __y)\n     {\n       return static_cast<_Tp>(__promote_preserving_unsigned(__x)\n \t\t\t      * __promote_preserving_unsigned(__y));\n     }\n \n   template <typename _Tp>\n-    static constexpr inline _Tp _S_divides(_Tp __x, _Tp __y)\n+    _GLIBCXX_SIMD_INTRINSIC\n+    static constexpr _Tp _S_divides(_Tp __x, _Tp __y)\n     {\n       return static_cast<_Tp>(__promote_preserving_unsigned(__x)\n \t\t\t      / __promote_preserving_unsigned(__y));\n     }\n \n   template <typename _Tp>\n-    static constexpr inline _Tp _S_modulus(_Tp __x, _Tp __y)\n+    _GLIBCXX_SIMD_INTRINSIC\n+    static constexpr _Tp _S_modulus(_Tp __x, _Tp __y)\n     {\n       return static_cast<_Tp>(__promote_preserving_unsigned(__x)\n \t\t\t      % __promote_preserving_unsigned(__y));\n     }\n \n   template <typename _Tp>\n-    static constexpr inline _Tp _S_bit_and(_Tp __x, _Tp __y)\n+    _GLIBCXX_SIMD_INTRINSIC\n+    static constexpr _Tp _S_bit_and(_Tp __x, _Tp __y)\n     {\n       if constexpr (is_floating_point_v<_Tp>)\n \t{\n@@ -254,7 +269,8 @@ struct _SimdImplScalar\n     }\n \n   template <typename _Tp>\n-    static constexpr inline _Tp _S_bit_or(_Tp __x, _Tp __y)\n+    _GLIBCXX_SIMD_INTRINSIC\n+    static constexpr _Tp _S_bit_or(_Tp __x, _Tp __y)\n     {\n       if constexpr (is_floating_point_v<_Tp>)\n \t{\n@@ -267,7 +283,8 @@ struct _SimdImplScalar\n     }\n \n   template <typename _Tp>\n-    static constexpr inline _Tp _S_bit_xor(_Tp __x, _Tp __y)\n+    _GLIBCXX_SIMD_INTRINSIC\n+    static constexpr _Tp _S_bit_xor(_Tp __x, _Tp __y)\n     {\n       if constexpr (is_floating_point_v<_Tp>)\n \t{\n@@ -280,11 +297,13 @@ struct _SimdImplScalar\n     }\n \n   template <typename _Tp>\n-    static constexpr inline _Tp _S_bit_shift_left(_Tp __x, int __y)\n+    _GLIBCXX_SIMD_INTRINSIC\n+    static constexpr _Tp _S_bit_shift_left(_Tp __x, int __y)\n     { return static_cast<_Tp>(__promote_preserving_unsigned(__x) << __y); }\n \n   template <typename _Tp>\n-    static constexpr inline _Tp _S_bit_shift_right(_Tp __x, int __y)\n+    _GLIBCXX_SIMD_INTRINSIC\n+    static constexpr _Tp _S_bit_shift_right(_Tp __x, int __y)\n     { return static_cast<_Tp>(__promote_preserving_unsigned(__x) >> __y); }\n \n   // math {{{2\n@@ -553,11 +572,13 @@ struct _SimdImplScalar\n \n   // _S_increment & _S_decrement{{{2\n   template <typename _Tp>\n-    constexpr static inline void _S_increment(_Tp& __x)\n+    _GLIBCXX_SIMD_INTRINSIC\n+    constexpr static void _S_increment(_Tp& __x)\n     { ++__x; }\n \n   template <typename _Tp>\n-    constexpr static inline void _S_decrement(_Tp& __x)\n+    _GLIBCXX_SIMD_INTRINSIC\n+    constexpr static void _S_decrement(_Tp& __x)\n     { --__x; }\n \n \n@@ -582,6 +603,7 @@ struct _SimdImplScalar\n \n   // smart_reference access {{{2\n   template <typename _Tp, typename _Up>\n+    _GLIBCXX_SIMD_INTRINSIC\n     constexpr static void _S_set(_Tp& __v, [[maybe_unused]] int __i,\n \t\t\t\t _Up&& __x) noexcept\n     {\n@@ -677,25 +699,32 @@ struct _MaskImplScalar\n   }\n \n   // logical and bitwise operators {{{2\n+  _GLIBCXX_SIMD_INTRINSIC\n   static constexpr bool _S_logical_and(bool __x, bool __y)\n   { return __x && __y; }\n \n+  _GLIBCXX_SIMD_INTRINSIC\n   static constexpr bool _S_logical_or(bool __x, bool __y)\n   { return __x || __y; }\n \n+  _GLIBCXX_SIMD_INTRINSIC\n   static constexpr bool _S_bit_not(bool __x)\n   { return !__x; }\n \n+  _GLIBCXX_SIMD_INTRINSIC\n   static constexpr bool _S_bit_and(bool __x, bool __y)\n   { return __x && __y; }\n \n+  _GLIBCXX_SIMD_INTRINSIC\n   static constexpr bool _S_bit_or(bool __x, bool __y)\n   { return __x || __y; }\n \n+  _GLIBCXX_SIMD_INTRINSIC\n   static constexpr bool _S_bit_xor(bool __x, bool __y)\n   { return __x != __y; }\n \n   // smart_reference access {{{2\n+  _GLIBCXX_SIMD_INTRINSIC\n   constexpr static void _S_set(bool& __k, [[maybe_unused]] int __i,\n \t\t\t       bool __x) noexcept\n   {"}, {"sha": "baa978bffdafc2d378365da979d177ef1a71825c", "filename": "libstdc++-v3/include/experimental/bits/simd_x86.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52d28210389ff3d4af8f20db4db1f0d58b0f8eff/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Fsimd_x86.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52d28210389ff3d4af8f20db4db1f0d58b0f8eff/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Fsimd_x86.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Fsimd_x86.h?ref=52d28210389ff3d4af8f20db4db1f0d58b0f8eff", "patch": "@@ -822,7 +822,7 @@ struct _CommonImplX86 : _CommonImplBuiltin\n \n // }}}\n // _SimdImplX86 {{{\n-template <typename _Abi>\n+template <typename _Abi, typename>\n   struct _SimdImplX86 : _SimdImplBuiltin<_Abi>\n   {\n     using _Base = _SimdImplBuiltin<_Abi>;\n@@ -4241,7 +4241,7 @@ struct _MaskImplX86Mixin\n \n // }}}\n // _MaskImplX86 {{{\n-template <typename _Abi>\n+template <typename _Abi, typename>\n   struct _MaskImplX86 : _MaskImplX86Mixin, _MaskImplBuiltin<_Abi>\n   {\n     using _MaskImplX86Mixin::_S_to_bits;"}]}