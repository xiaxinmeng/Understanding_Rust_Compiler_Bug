{"sha": "a6a2b532f9c4e92277e390febc8c07f773becb1b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTZhMmI1MzJmOWM0ZTkyMjc3ZTM5MGZlYmM4YzA3Zjc3M2JlY2IxYg==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel@linux.vnet.ibm.com", "date": "2016-12-02T08:21:43Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2016-12-02T08:21:43Z"}, "message": "S/390: Fix vector all/any cc modes.\n\nThis fixes a problem with the vector compares producing CC mode\nresults.\n\nThe instructions produce condition code modes which can be either\ninterpreted to check an ALL elements or an ANY element result.  As the\nmodes where used before they could not be inverted by the middle-end\nby inverting the comparison code (e.g. eq to ne).  The result usually\nwas just wrong.\n\nIn fact inverting a comparison code on an CCVALL mode would require to\nalso change the mode to CCVANY but this cannot be done easily in the\nmiddle-end.  With this patch the meaning of an ALL cc mode only refers\nto the not-inverted comparison code (e.g. eq, gt, ge).  With that\nchange inverting the comparison code matches a not operation on the\ncondition code mask again.\n\nBootstrapped and regression tested on s390 and s390x.\n\nBye,\n\n-Andreas-\n\ngcc/testsuite/ChangeLog:\n\n2016-12-02  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n\n\t* gcc.target/s390/vector/vec-scalar-cmp-1.c: Fix and harden the\n\tpattern checks.\n\t* gcc.target/s390/zvector/vec-cmp-1.c: New test.\n\ngcc/ChangeLog:\n\n2016-12-02  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n\n\t* config/s390/s390-modes.def (CCVEQANY, CCVH, CCVHANY, CCVHU)\n\t(CCVHUANY): Remove modes.\n\t(CCVIH, CCVIHU, CCVIALL, CCVIANY, CCVFALL, CCVFANY): Add modes and\n\tdocumentation.\n\t* config/s390/s390.c (s390_match_ccmode_set): Rename cc modes.\n\t(s390_expand_vec_compare_scalar): Pick one of the cc consumer\n\tmodes.\n\t(s390_branch_condition_mask): Adjust to use the new cc consumer\n\tmodes.  The new modes allow for proper reversal in the middle-end.\n\t(s390_expand_vec_compare_cc): Determine the proper cc producer and\n\tconsumer modes for a comparison.\n\t* config/s390/s390.md: Rename CCVH to CCVIH and CCVHU to CCVIHU\n\tthroughout the file.\n\t* config/s390/vx-builtins.md: Likewise.\n\nFrom-SVN: r243154", "tree": {"sha": "2e3f64dd5c86cd65f15b980ee817b89f5fd30cc9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e3f64dd5c86cd65f15b980ee817b89f5fd30cc9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6a2b532f9c4e92277e390febc8c07f773becb1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6a2b532f9c4e92277e390febc8c07f773becb1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6a2b532f9c4e92277e390febc8c07f773becb1b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6a2b532f9c4e92277e390febc8c07f773becb1b/comments", "author": null, "committer": null, "parents": [{"sha": "84b0769e335819050ecdd86301a5f5d41fa5df8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84b0769e335819050ecdd86301a5f5d41fa5df8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84b0769e335819050ecdd86301a5f5d41fa5df8b"}], "stats": {"total": 564, "additions": 388, "deletions": 176}, "files": [{"sha": "2d5540907009f9e82cb68710f4a6a69fd6ff9c43", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6a2b532f9c4e92277e390febc8c07f773becb1b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6a2b532f9c4e92277e390febc8c07f773becb1b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a6a2b532f9c4e92277e390febc8c07f773becb1b", "patch": "@@ -1,3 +1,20 @@\n+2016-12-02  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n+\n+\t* config/s390/s390-modes.def (CCVEQANY, CCVH, CCVHANY, CCVHU)\n+\t(CCVHUANY): Remove modes.\n+\t(CCVIH, CCVIHU, CCVIALL, CCVIANY, CCVFALL, CCVFANY): Add modes and\n+\tdocumentation.\n+\t* config/s390/s390.c (s390_match_ccmode_set): Rename cc modes.\n+\t(s390_expand_vec_compare_scalar): Pick one of the cc consumer\n+\tmodes.\n+\t(s390_branch_condition_mask): Adjust to use the new cc consumer\n+\tmodes.  The new modes allow for proper reversal in the middle-end.\n+\t(s390_expand_vec_compare_cc): Determine the proper cc producer and\n+\tconsumer modes for a comparison.\n+\t* config/s390/s390.md: Rename CCVH to CCVIH and CCVHU to CCVIHU\n+\tthroughout the file.\n+\t* config/s390/vx-builtins.md: Likewise.\n+\n 2016-12-02  Maxim Ostapenko  <m.ostapenko@samsung.com>\n \n \t* asan.c (asan_global_struct): Refactor."}, {"sha": "15ff9034a1b87f0af51c99dbc4990961930b00d2", "filename": "gcc/config/s390/s390-modes.def", "status": "modified", "additions": 41, "deletions": 31, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6a2b532f9c4e92277e390febc8c07f773becb1b/gcc%2Fconfig%2Fs390%2Fs390-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6a2b532f9c4e92277e390febc8c07f773becb1b/gcc%2Fconfig%2Fs390%2Fs390-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-modes.def?ref=a6a2b532f9c4e92277e390febc8c07f773becb1b", "patch": "@@ -84,22 +84,6 @@ Requested mode            -> Destination CC register mode\n CCS, CCU, CCT, CCSR, CCUR -> CCZ\n CCA                       -> CCAP, CCAN\n \n-Vector comparison modes\n-\n-CCVEQ  \t  EQ\t  - \t       - \t   NE\t      (VCEQ)\n-CCVEQANY  EQ\t  EQ\t       - \t   NE\t      (VCEQ)\n-\n-CCVH\t  GT\t  - \t       - \t   LE\t      (VCH)\n-CCVHANY\t  GT\t  GT\t       - \t   LE\t      (VCH)\n-CCVHU\t  GTU\t  -  \t       -  \t   LEU\t      (VCHL)\n-CCVHUANY  GTU\t  GTU\t       -  \t   LEU\t      (VCHL)\n-\n-CCVFH\t  GT\t  -   \t       -   \t   UNLE\t      (VFCH)\n-CCVFHANY  GT\t  GT\t       -   \t   UNLE\t      (VFCH)\n-CCVFHE\t  GE\t  -   \t       -   \t   UNLT\t      (VFCHE)\n-CCVFHEANY GE\t  GE\t       -   \t   UNLT\t      (VFCHE)\n-\n-\n \n \n *** Comments ***\n@@ -169,14 +153,40 @@ The compare and swap instructions sets the condition code to 0/1 if the\n operands were equal/unequal. The CCZ1 mode ensures the result can be\n effectively placed into a register.\n \n-\n-CCV*\n-\n-The variants with and without ANY are generated by the same\n-instructions and therefore are holding the same information.  However,\n-when generating a condition code mask they require checking different\n-bits of CC.  In that case the variants without ANY represent the\n-results for *all* elements.\n+CCVIH, CCVIHU, CCVFH, CCVFHE\n+\n+These are condition code modes used in instructions setting the\n+condition code.  The mode determines which comparison to perform (H -\n+high, HU - high unsigned, HE - high or equal) and whether it is a\n+floating point comparison or not (I - int, F - float).\n+\n+The comparison operation to be performed needs to be encoded into the\n+condition code mode since the comparison operator is not available in\n+compare style patterns (set cc (compare (op0) (op1))).  So the\n+condition code mode is the only information to determine the\n+instruction to be used.\n+\n+CCVIALL, CCVIANY, CCVFALL, CCVFANY\n+\n+These modes are used in instructions reading the condition code.\n+Opposed to the CC producer patterns the comparison operator is\n+available.  Hence the comparison operation does not need to be part of\n+the CC mode.  However, we still need to know whether CC has been\n+generated by a float or an integer comparison in order to be able to\n+invert the condition correctly (int: GT -> LE, float: GT -> UNLE).\n+\n+The ALL and ANY variants differ only in the usage of CC1 which\n+indicates a mixed result across the vector elements.  Be aware that\n+depending on the comparison code the ALL and ANY variants might\n+actually refer to their opposite meaning.  I.e. while inverting the\n+comparison in (EQ (reg:CCVIALL 33) (const_int 0)) results in (NE\n+(reg:CCVIALL 33) (const_int 0)) it in fact describes an ANY comparison\n+(inverting \"all equal\" should be \"any not equal\") However, the\n+middle-end does invert only the comparison operator without touching\n+the mode.\n+Hence, the ALL/ANY in the mode names refer to the meaning in the\n+context of EQ, GT, GE while for the inverted codes it actually means\n+ANY/ALL.\n \n CCRAW\n \n@@ -209,18 +219,18 @@ CC_MODE (CCT3);\n CC_MODE (CCRAW);\n \n CC_MODE (CCVEQ);\n-CC_MODE (CCVEQANY);\n \n-CC_MODE (CCVH);\n-CC_MODE (CCVHANY);\n-CC_MODE (CCVHU);\n-CC_MODE (CCVHUANY);\n+CC_MODE (CCVIH);\n+CC_MODE (CCVIHU);\n \n CC_MODE (CCVFH);\n-CC_MODE (CCVFHANY);\n CC_MODE (CCVFHE);\n-CC_MODE (CCVFHEANY);\n \n+CC_MODE (CCVIALL);\n+CC_MODE (CCVIANY);\n+\n+CC_MODE (CCVFALL);\n+CC_MODE (CCVFANY);\n \n /* Vector modes.  */\n "}, {"sha": "445c147f3dcdcade6f82102d3fe7d1e10ca37098", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 114, "deletions": 112, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6a2b532f9c4e92277e390febc8c07f773becb1b/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6a2b532f9c4e92277e390febc8c07f773becb1b/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=a6a2b532f9c4e92277e390febc8c07f773becb1b", "patch": "@@ -1275,6 +1275,11 @@ s390_match_ccmode_set (rtx set, machine_mode req_mode)\n \n   gcc_assert (GET_CODE (set) == SET);\n \n+  /* These modes are supposed to be used only in CC consumer\n+     patterns.  */\n+  gcc_assert (req_mode != CCVIALLmode && req_mode != CCVIANYmode\n+\t      && req_mode != CCVFALLmode && req_mode != CCVFANYmode);\n+\n   if (GET_CODE (SET_DEST (set)) != REG || !CC_REGNO_P (REGNO (SET_DEST (set))))\n     return 1;\n \n@@ -1293,8 +1298,8 @@ s390_match_ccmode_set (rtx set, machine_mode req_mode)\n     case CCT2mode:\n     case CCT3mode:\n     case CCVEQmode:\n-    case CCVHmode:\n-    case CCVHUmode:\n+    case CCVIHmode:\n+    case CCVIHUmode:\n     case CCVFHmode:\n     case CCVFHEmode:\n       if (req_mode != set_mode)\n@@ -1752,14 +1757,20 @@ s390_expand_vec_compare_scalar (enum rtx_code *code, rtx cmp1, rtx cmp2,\n       cmp2 = cmp1;\n       cmp1 = tmp;\n     }\n-  *cc = gen_rtx_REG (cmp_mode, CC_REGNUM);\n+\n   emit_insn (gen_rtx_PARALLEL (VOIDmode,\n \t       gen_rtvec (2,\n-\t\t\t  gen_rtx_SET (*cc,\n+\t\t\t  gen_rtx_SET (gen_rtx_REG (cmp_mode, CC_REGNUM),\n \t\t\t\t       gen_rtx_COMPARE (cmp_mode, cmp1,\n \t\t\t\t\t\t\tcmp2)),\n \t\t\t  gen_rtx_CLOBBER (VOIDmode,\n \t\t\t\t\t   gen_rtx_SCRATCH (V2DImode)))));\n+\n+  /* This is the cc reg how it will be used in the cc mode consumer.\n+     It either needs to be CCVFALL or CCVFANY.  However, CC1 will\n+     never be set by the scalar variants.  So it actually doesn't\n+     matter which one we choose here.  */\n+  *cc = gen_rtx_REG (CCVFALLmode, CC_REGNUM);\n   return true;\n }\n \n@@ -2021,92 +2032,63 @@ s390_branch_condition_mask (rtx code)\n       break;\n \n       /* Vector comparison modes.  */\n-\n-    case CCVEQmode:\n-      switch (GET_CODE (code))\n-\t{\n-\tcase EQ:        return CC0;\n-\tcase NE:        return CC3;\n-\tdefault:        return -1;\n-\t}\n-\n-    case CCVEQANYmode:\n-      switch (GET_CODE (code))\n-\t{\n-\tcase EQ:        return CC0 | CC1;\n-\tcase NE:        return CC3 | CC1;\n-\tdefault:        return -1;\n-\t}\n-\n-      /* Integer vector compare modes.  */\n-\n-    case CCVHmode:\n-      switch (GET_CODE (code))\n-\t{\n-\tcase GT:        return CC0;\n-\tcase LE:        return CC3;\n-\tdefault:        return -1;\n-\t}\n-\n-    case CCVHANYmode:\n-      switch (GET_CODE (code))\n-\t{\n-\tcase GT:        return CC0 | CC1;\n-\tcase LE:        return CC3 | CC1;\n-\tdefault:        return -1;\n-\t}\n-\n-    case CCVHUmode:\n-      switch (GET_CODE (code))\n-\t{\n-\tcase GTU:       return CC0;\n-\tcase LEU:       return CC3;\n-\tdefault:        return -1;\n-\t}\n-\n-    case CCVHUANYmode:\n-      switch (GET_CODE (code))\n-\t{\n-\tcase GTU:       return CC0 | CC1;\n-\tcase LEU:       return CC3 | CC1;\n-\tdefault:        return -1;\n-\t}\n-\n-      /* FP vector compare modes.  */\n-\n-    case CCVFHmode:\n+      /* CC2 will never be set.  It however is part of the negated\n+\t masks.  */\n+    case CCVIALLmode:\n       switch (GET_CODE (code))\n \t{\n-\tcase GT:        return CC0;\n-\tcase UNLE:      return CC3;\n+\tcase EQ:\n+\tcase GTU:\n+\tcase GT:\n+\tcase GE:        return CC0;\n+\t  /* The inverted modes are in fact *any* modes.  */\n+\tcase NE:\n+\tcase LEU:\n+\tcase LE:\n+\tcase LT:        return CC3 | CC1 | CC2;\n \tdefault:        return -1;\n \t}\n \n-    case CCVFHANYmode:\n+    case CCVIANYmode:\n       switch (GET_CODE (code))\n \t{\n-\tcase GT:        return CC0 | CC1;\n-\tcase UNLE:      return CC3 | CC1;\n+\tcase EQ:\n+\tcase GTU:\n+\tcase GT:\n+\tcase GE:        return CC0 | CC1;\n+\t  /* The inverted modes are in fact *all* modes.  */\n+\tcase NE:\n+\tcase LEU:\n+\tcase LE:\n+\tcase LT:        return CC3 | CC2;\n \tdefault:        return -1;\n \t}\n-\n-    case CCVFHEmode:\n+    case CCVFALLmode:\n       switch (GET_CODE (code))\n \t{\n+\tcase EQ:\n+\tcase GT:\n \tcase GE:        return CC0;\n-\tcase UNLT:      return CC3;\n+\t  /* The inverted modes are in fact *any* modes.  */\n+\tcase NE:\n+\tcase UNLE:\n+\tcase UNLT:      return CC3 | CC1 | CC2;\n \tdefault:        return -1;\n \t}\n \n-    case CCVFHEANYmode:\n+    case CCVFANYmode:\n       switch (GET_CODE (code))\n \t{\n+\tcase EQ:\n+\tcase GT:\n \tcase GE:        return CC0 | CC1;\n-\tcase UNLT:      return CC3 | CC1;\n+\t  /* The inverted modes are in fact *all* modes.  */\n+\tcase NE:\n+\tcase UNLE:\n+\tcase UNLT:      return CC3 | CC2;\n \tdefault:        return -1;\n \t}\n \n-\n     case CCRAWmode:\n       switch (GET_CODE (code))\n \t{\n@@ -6256,67 +6238,87 @@ s390_expand_vec_compare (rtx target, enum rtx_code cond,\n \n /* Expand the comparison CODE of CMP1 and CMP2 and copy 1 or 0 into\n    TARGET if either all (ALL_P is true) or any (ALL_P is false) of the\n-   elements in CMP1 and CMP2 fulfill the comparison.  */\n+   elements in CMP1 and CMP2 fulfill the comparison.\n+   This function is only used to emit patterns for the vx builtins and\n+   therefore only handles comparison codes required by the\n+   builtins.  */\n void\n s390_expand_vec_compare_cc (rtx target, enum rtx_code code,\n \t\t\t    rtx cmp1, rtx cmp2, bool all_p)\n {\n-  enum rtx_code new_code = code;\n-  machine_mode cmp_mode, full_cmp_mode, scratch_mode;\n+  machine_mode cc_producer_mode, cc_consumer_mode, scratch_mode;\n   rtx tmp_reg = gen_reg_rtx (SImode);\n   bool swap_p = false;\n \n   if (GET_MODE_CLASS (GET_MODE (cmp1)) == MODE_VECTOR_INT)\n     {\n       switch (code)\n \t{\n-\tcase EQ:  cmp_mode = CCVEQmode; break;\n-\tcase NE:  cmp_mode = CCVEQmode; break;\n-\tcase GT:  cmp_mode = CCVHmode;  break;\n-\tcase GE:  cmp_mode = CCVHmode;  new_code = LE; swap_p = true; break;\n-\tcase LT:  cmp_mode = CCVHmode;  new_code = GT; swap_p = true; break;\n-\tcase LE:  cmp_mode = CCVHmode;  new_code = LE; break;\n-\tcase GTU: cmp_mode = CCVHUmode; break;\n-\tcase GEU: cmp_mode = CCVHUmode; new_code = LEU; swap_p = true; break;\n-\tcase LTU: cmp_mode = CCVHUmode; new_code = GTU; swap_p = true; break;\n-\tcase LEU: cmp_mode = CCVHUmode; new_code = LEU; break;\n-\tdefault: gcc_unreachable ();\n+\tcase EQ:\n+\tcase NE:\n+\t  cc_producer_mode = CCVEQmode;\n+\t  break;\n+\tcase GE:\n+\tcase LT:\n+\t  code = swap_condition (code);\n+\t  swap_p = true;\n+\t  /* fallthrough */\n+\tcase GT:\n+\tcase LE:\n+\t  cc_producer_mode = CCVIHmode;\n+\t  break;\n+\tcase GEU:\n+\tcase LTU:\n+\t  code = swap_condition (code);\n+\t  swap_p = true;\n+\t  /* fallthrough */\n+\tcase GTU:\n+\tcase LEU:\n+\t  cc_producer_mode = CCVIHUmode;\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n+\n       scratch_mode = GET_MODE (cmp1);\n+      /* These codes represent inverted CC interpretations.  Inverting\n+\t an ALL CC mode results in an ANY CC mode and the other way\n+\t around.  Invert the all_p flag here to compensate for\n+\t that.  */\n+      if (code == NE || code == LE || code == LEU)\n+\tall_p = !all_p;\n+\n+      cc_consumer_mode = all_p ? CCVIALLmode : CCVIANYmode;\n     }\n-  else if (GET_MODE (cmp1) == V2DFmode)\n+  else if (GET_MODE_CLASS (GET_MODE (cmp1)) == MODE_VECTOR_FLOAT)\n     {\n+      bool inv_p = false;\n+\n       switch (code)\n \t{\n-\tcase EQ:   cmp_mode = CCVEQmode;  break;\n-\tcase NE:   cmp_mode = CCVEQmode;  break;\n-\tcase GT:   cmp_mode = CCVFHmode;  break;\n-\tcase GE:   cmp_mode = CCVFHEmode; break;\n-\tcase UNLE: cmp_mode = CCVFHmode;  break;\n-\tcase UNLT: cmp_mode = CCVFHEmode; break;\n-\tcase LT:   cmp_mode = CCVFHmode;  new_code = GT; swap_p = true; break;\n-\tcase LE:   cmp_mode = CCVFHEmode; new_code = GE; swap_p = true; break;\n+\tcase EQ:   cc_producer_mode = CCVEQmode;  break;\n+\tcase NE:   cc_producer_mode = CCVEQmode;  inv_p = true; break;\n+\tcase GT:   cc_producer_mode = CCVFHmode;  break;\n+\tcase GE:   cc_producer_mode = CCVFHEmode; break;\n+\tcase UNLE: cc_producer_mode = CCVFHmode;  inv_p = true; break;\n+\tcase UNLT: cc_producer_mode = CCVFHEmode; inv_p = true; break;\n+\tcase LT:   cc_producer_mode = CCVFHmode;  code = GT; swap_p = true; break;\n+\tcase LE:   cc_producer_mode = CCVFHEmode; code = GE; swap_p = true; break;\n \tdefault: gcc_unreachable ();\n \t}\n-      scratch_mode = V2DImode;\n+      scratch_mode = mode_for_vector (\n+\t\t       int_mode_for_mode (GET_MODE_INNER (GET_MODE (cmp1))),\n+\t\t       GET_MODE_NUNITS (GET_MODE (cmp1)));\n+      gcc_assert (scratch_mode != BLKmode);\n+\n+      if (inv_p)\n+\tall_p = !all_p;\n+\n+      cc_consumer_mode = all_p ? CCVFALLmode : CCVFANYmode;\n     }\n   else\n     gcc_unreachable ();\n \n-  if (!all_p)\n-    switch (cmp_mode)\n-      {\n-      case CCVEQmode:  full_cmp_mode = CCVEQANYmode;  break;\n-      case CCVHmode:   full_cmp_mode = CCVHANYmode;   break;\n-      case CCVHUmode:  full_cmp_mode = CCVHUANYmode;  break;\n-      case CCVFHmode:  full_cmp_mode = CCVFHANYmode;  break;\n-      case CCVFHEmode: full_cmp_mode = CCVFHEANYmode; break;\n-      default: gcc_unreachable ();\n-      }\n-  else\n-    /* The modes without ANY match the ALL modes.  */\n-    full_cmp_mode = cmp_mode;\n-\n   if (swap_p)\n     {\n       rtx tmp = cmp2;\n@@ -6326,19 +6328,19 @@ s390_expand_vec_compare_cc (rtx target, enum rtx_code code,\n \n   emit_insn (gen_rtx_PARALLEL (VOIDmode,\n \t       gen_rtvec (2, gen_rtx_SET (\n-\t\t\t       gen_rtx_REG (cmp_mode, CC_REGNUM),\n-\t\t\t       gen_rtx_COMPARE (cmp_mode, cmp1, cmp2)),\n+\t\t\t       gen_rtx_REG (cc_producer_mode, CC_REGNUM),\n+\t\t\t       gen_rtx_COMPARE (cc_producer_mode, cmp1, cmp2)),\n \t\t\t  gen_rtx_CLOBBER (VOIDmode,\n \t\t\t\t\t   gen_rtx_SCRATCH (scratch_mode)))));\n   emit_move_insn (target, const0_rtx);\n   emit_move_insn (tmp_reg, const1_rtx);\n \n   emit_move_insn (target,\n \t\t  gen_rtx_IF_THEN_ELSE (SImode,\n-\t\t    gen_rtx_fmt_ee (new_code, VOIDmode,\n-\t\t\t\t    gen_rtx_REG (full_cmp_mode, CC_REGNUM),\n+\t\t    gen_rtx_fmt_ee (code, VOIDmode,\n+\t\t\t\t    gen_rtx_REG (cc_consumer_mode, CC_REGNUM),\n \t\t\t\t    const0_rtx),\n-\t\t      target, tmp_reg));\n+\t\t\t\t\ttmp_reg, target));\n }\n \n /* Generate a vector comparison expression loading either elements of"}, {"sha": "5844e2847a5e3736197438611e24eab2614d98b6", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6a2b532f9c4e92277e390febc8c07f773becb1b/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6a2b532f9c4e92277e390febc8c07f773becb1b/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=a6a2b532f9c4e92277e390febc8c07f773becb1b", "patch": "@@ -782,7 +782,7 @@\n ; Used with VFCMP to expand part of the mnemonic\n ; For fp we have a mismatch: eq in the insn name - e in asm\n (define_mode_attr asm_fcmp [(CCVEQ \"e\") (CCVFH \"h\") (CCVFHE \"he\")])\n-(define_mode_attr insn_cmp [(CCVEQ \"eq\") (CCVH \"h\") (CCVHU \"hl\") (CCVFH \"h\") (CCVFHE \"he\")])\n+(define_mode_attr insn_cmp [(CCVEQ \"eq\") (CCVIH \"h\") (CCVIHU \"hl\") (CCVFH \"h\") (CCVFHE \"he\")])\n \n ;; Subst pattern definitions\n (include \"subst.md\")"}, {"sha": "51d022cf5ce9d575ffe4439b1c62922f1e505ef4", "filename": "gcc/config/s390/vx-builtins.md", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6a2b532f9c4e92277e390febc8c07f773becb1b/gcc%2Fconfig%2Fs390%2Fvx-builtins.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6a2b532f9c4e92277e390febc8c07f773becb1b/gcc%2Fconfig%2Fs390%2Fvx-builtins.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fvx-builtins.md?ref=a6a2b532f9c4e92277e390febc8c07f773becb1b", "patch": "@@ -36,7 +36,7 @@\n \t\t\t      (V1DF \"DI\") (V2DF \"DI\")])\n \n ; Condition code modes generated by int comparisons\n-(define_mode_iterator VICMP [CCVEQ CCVH CCVHU])\n+(define_mode_iterator VICMP [CCVEQ CCVIH CCVIHU])\n \n ; Comparisons supported by the vec_cmp* builtins\n (define_code_iterator intcmp [eq gt gtu ge geu lt ltu le leu])\n@@ -1900,24 +1900,24 @@\n \n (define_expand \"vec_cmph<VI_HW:mode>_cc\"\n   [(parallel\n-    [(set (reg:CCVH CC_REGNUM)\n-\t  (compare:CCVH (match_operand:VI_HW 1 \"register_operand\" \"v\")\n-\t\t\t(match_operand:VI_HW 2 \"register_operand\" \"v\")))\n+    [(set (reg:CCVIH CC_REGNUM)\n+\t  (compare:CCVIH (match_operand:VI_HW 1 \"register_operand\" \"v\")\n+\t\t\t (match_operand:VI_HW 2 \"register_operand\" \"v\")))\n      (set (match_operand:VI_HW 0 \"register_operand\" \"=v\")\n \t  (gt:VI_HW (match_dup 1) (match_dup 2)))])\n    (set (match_operand:SI 3 \"memory_operand\" \"\")\n-\t(unspec:SI [(reg:CCVH CC_REGNUM)] UNSPEC_CC_TO_INT))]\n+\t(unspec:SI [(reg:CCVIH CC_REGNUM)] UNSPEC_CC_TO_INT))]\n   \"TARGET_VX\")\n \n (define_expand \"vec_cmphl<VI_HW:mode>_cc\"\n   [(parallel\n-    [(set (reg:CCVHU CC_REGNUM)\n-\t  (compare:CCVHU (match_operand:VI_HW 1 \"register_operand\" \"v\")\n-\t\t\t (match_operand:VI_HW 2 \"register_operand\" \"v\")))\n+    [(set (reg:CCVIHU CC_REGNUM)\n+\t  (compare:CCVIHU (match_operand:VI_HW 1 \"register_operand\" \"v\")\n+\t\t\t  (match_operand:VI_HW 2 \"register_operand\" \"v\")))\n      (set (match_operand:VI_HW 0 \"register_operand\" \"=v\")\n \t  (gtu:VI_HW (match_dup 1) (match_dup 2)))])\n    (set (match_operand:SI 3 \"memory_operand\" \"\")\n-\t(unspec:SI [(reg:CCVHU CC_REGNUM)] UNSPEC_CC_TO_INT))]\n+\t(unspec:SI [(reg:CCVIHU CC_REGNUM)] UNSPEC_CC_TO_INT))]\n   \"TARGET_VX\")\n \n \n@@ -1932,19 +1932,19 @@\n   [(set_attr \"op_type\" \"VRR\")])\n \n (define_insn \"*vec_cmph<VI_HW:mode>_cc\"\n-  [(set (reg:CCVH CC_REGNUM)\n-\t(compare:CCVH (match_operand:VI_HW 0 \"register_operand\"  \"v\")\n-\t\t      (match_operand:VI_HW 1 \"register_operand\"  \"v\")))\n+  [(set (reg:CCVIH CC_REGNUM)\n+\t(compare:CCVIH (match_operand:VI_HW 0 \"register_operand\"  \"v\")\n+\t\t       (match_operand:VI_HW 1 \"register_operand\"  \"v\")))\n    (set (match_operand:VI_HW               2 \"register_operand\" \"=v\")\n \t(gt:VI_HW (match_dup 0) (match_dup 1)))]\n   \"TARGET_VX\"\n   \"vch<VI_HW:bhfgq>s\\t%v2,%v0,%v1\"\n   [(set_attr \"op_type\" \"VRR\")])\n \n (define_insn \"*vec_cmphl<VI_HW:mode>_cc\"\n-  [(set (reg:CCVHU CC_REGNUM)\n-\t(compare:CCVHU (match_operand:VI_HW 0 \"register_operand\"  \"v\")\n-\t\t       (match_operand:VI_HW 1 \"register_operand\"  \"v\")))\n+  [(set (reg:CCVIHU CC_REGNUM)\n+\t(compare:CCVIHU (match_operand:VI_HW 0 \"register_operand\"  \"v\")\n+\t\t\t(match_operand:VI_HW 1 \"register_operand\"  \"v\")))\n    (set (match_operand:VI_HW                2 \"register_operand\" \"=v\")\n \t(gtu:VI_HW (match_dup 0) (match_dup 1)))]\n   \"TARGET_VX\"\n@@ -1978,13 +1978,13 @@\n \n (define_expand \"vec_cmphv2df_cc\"\n   [(parallel\n-    [(set (reg:CCVH CC_REGNUM)\n-\t  (compare:CCVH (match_operand:V2DF 1 \"register_operand\"  \"v\")\n-\t\t\t(match_operand:V2DF 2 \"register_operand\"  \"v\")))\n+    [(set (reg:CCVIH CC_REGNUM)\n+\t  (compare:CCVIH (match_operand:V2DF 1 \"register_operand\"  \"v\")\n+\t\t\t (match_operand:V2DF 2 \"register_operand\"  \"v\")))\n      (set (match_operand:V2DI 0 \"register_operand\" \"=v\")\n \t  (gt:V2DI (match_dup 1) (match_dup 2)))])\n    (set (match_operand:SI 3 \"memory_operand\" \"\")\n-\t(unspec:SI [(reg:CCVH CC_REGNUM)] UNSPEC_CC_TO_INT))]\n+\t(unspec:SI [(reg:CCVIH CC_REGNUM)] UNSPEC_CC_TO_INT))]\n   \"TARGET_VX\")\n \n (define_expand \"vec_cmphev2df_cc\"\n@@ -2010,9 +2010,9 @@\n   [(set_attr \"op_type\" \"VRR\")])\n \n (define_insn \"*vec_cmphv2df_cc\"\n-  [(set (reg:CCVH CC_REGNUM)\n-\t(compare:CCVH (match_operand:V2DF 0 \"register_operand\"  \"v\")\n-\t\t      (match_operand:V2DF 1 \"register_operand\"  \"v\")))\n+  [(set (reg:CCVIH CC_REGNUM)\n+\t(compare:CCVIH (match_operand:V2DF 0 \"register_operand\"  \"v\")\n+\t\t       (match_operand:V2DF 1 \"register_operand\"  \"v\")))\n    (set (match_operand:V2DI               2 \"register_operand\" \"=v\")\n \t(gt:V2DI (match_dup 0) (match_dup 1)))]\n   \"TARGET_VX\""}, {"sha": "2ecf8f95de9bdb043b76d2d077c99521aff544c8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6a2b532f9c4e92277e390febc8c07f773becb1b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6a2b532f9c4e92277e390febc8c07f773becb1b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a6a2b532f9c4e92277e390febc8c07f773becb1b", "patch": "@@ -1,3 +1,9 @@\n+2016-12-02  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n+\n+\t* gcc.target/s390/vector/vec-scalar-cmp-1.c: Fix and harden the\n+\tpattern checks.\n+\t* gcc.target/s390/zvector/vec-cmp-1.c: New test.\n+\n 2016-12-02  Maxim Ostapenko  <m.ostapenko@samsung.com>\n \n \t* c-c++-common/asan/no-redundant-odr-indicators-1.c: New test."}, {"sha": "46a261ff25694839cf0a367acdcc09d73c64443f", "filename": "gcc/testsuite/gcc.target/s390/vector/vec-scalar-cmp-1.c", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6a2b532f9c4e92277e390febc8c07f773becb1b/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fvector%2Fvec-scalar-cmp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6a2b532f9c4e92277e390febc8c07f773becb1b/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fvector%2Fvec-scalar-cmp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fvector%2Fvec-scalar-cmp-1.c?ref=a6a2b532f9c4e92277e390febc8c07f773becb1b", "patch": "@@ -1,49 +1,53 @@\n /* Check that we use the scalar variants of vector compares.  */\n \n /* { dg-do compile { target { s390*-*-* } } } */\n-/* { dg-options \"-O3 -mzarch -march=z13\" } */\n-\n-/* { dg-final { scan-assembler-times \"wfcedbs\\t%v\\[0-9\\]*,%v0,%v2\" 2 } } */\n-/* { dg-final { scan-assembler-times \"wfchdbs\\t%v\\[0-9\\]*,%v0,%v2\" 1 } } */\n-/* { dg-final { scan-assembler-times \"wfchedbs\\t%v\\[0-9\\]*,%v2,%v0\" 1 } } */\n-/* { dg-final { scan-assembler-times \"wfchdbs\\t%v\\[0-9\\]*,%v2,%v0\" 1 } } */\n-/* { dg-final { scan-assembler-times \"wfchedbs\\t%v\\[0-9\\]*,%v2,%v0\" 1 } } */\n-/* { dg-final { scan-assembler-times \"lochine\" 5 } } */\n-/* { dg-final { scan-assembler-times \"lochino\" 1 } } */\n-\n+/* { dg-options \"-O3 -mzarch -march=z13 -fno-asynchronous-unwind-tables\" } */\n \n int\n eq (double a, double b)\n {\n   return a == b;\n }\n \n+/* { dg-final { scan-assembler \"eq:\\n\\twfcedbs\\t%v\\[0-9\\]*,%v0,%v2\\n\\tlhi\\t%r2,1\\n\\tlochine\\t%r2,0\" } } */\n+\n int\n ne (double a, double b)\n {\n   return a != b;\n }\n \n+/* { dg-final { scan-assembler \"ne:\\n\\twfcedbs\\t%v\\[0-9\\]*,%v0,%v2\\n\\tlhi\\t%r2,1\\n\\tlochie\\t%r2,0\" } } */\n+\n int\n gt (double a, double b)\n {\n   return a > b;\n }\n \n+/* { dg-final { scan-assembler \"gt:\\n\\twfchdbs\\t%v\\[0-9\\]*,%v0,%v2\\n\\tlhi\\t%r2,1\\n\\tlochine\\t%r2,0\" } } */\n+\n int\n ge (double a, double b)\n {\n   return a >= b;\n }\n \n+/* { dg-final { scan-assembler \"ge:\\n\\twfchedbs\\t%v\\[0-9\\]*,%v0,%v2\\n\\tlhi\\t%r2,1\\n\\tlochine\\t%r2,0\" } } */\n+\n int\n lt (double a, double b)\n {\n   return a < b;\n }\n \n+/* { dg-final { scan-assembler \"lt:\\n\\twfchdbs\\t%v\\[0-9\\]*,%v2,%v0\\n\\tlhi\\t%r2,1\\n\\tlochine\\t%r2,0\" } } */\n+\n int\n le (double a, double b)\n {\n   return a <= b;\n }\n+\n+/* { dg-final { scan-assembler \"le:\\n\\twfchedbs\\t%v\\[0-9\\]*,%v2,%v0\\n\\tlhi\\t%r2,1\\n\\tlochine\\t%r2,0\" } } */\n+"}, {"sha": "58bc39f238bec5559e53f29e95490aaf7aea7649", "filename": "gcc/testsuite/gcc.target/s390/zvector/vec-cmp-1.c", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6a2b532f9c4e92277e390febc8c07f773becb1b/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fzvector%2Fvec-cmp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6a2b532f9c4e92277e390febc8c07f773becb1b/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fzvector%2Fvec-cmp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fzvector%2Fvec-cmp-1.c?ref=a6a2b532f9c4e92277e390febc8c07f773becb1b", "patch": "@@ -0,0 +1,173 @@\n+/* { dg-do compile { target { s390*-*-* } } } */\n+/* { dg-options \"-O3 -mzarch -march=z13 -mzvector -fno-asynchronous-unwind-tables\" } */\n+\n+#include <vecintrin.h>\n+\n+int __attribute__((noinline,noclone))\n+all_eq_double (vector double a, vector double b)\n+{\n+\treturn vec_all_eq (a, b);\n+}\n+/* { dg-final { scan-assembler-times all_eq_double:\\n\\tvfcedbs\\t%v\\[0-9\\]*,%v24,%v26\\n\\tlhi\\t%r2,1\\n\\tlochine\\t%r2,0 1 } } */\n+\n+int __attribute__((noinline,noclone))\n+all_ne_double (vector double a, vector double b)\n+{\n+\treturn vec_all_ne (a, b);\n+}\n+/* { dg-final { scan-assembler-times all_ne_double:\\n\\tvfcedbs\\t%v\\[0-9\\]*,%v24,%v26\\n\\tlhi\\t%r2,1\\n\\tlochile\\t%r2,0 1 } } */\n+\n+int __attribute__((noinline,noclone))\n+all_gt_double (vector double a, vector double b)\n+{\n+\treturn vec_all_gt (a, b);\n+}\n+/* { dg-final { scan-assembler-times all_gt_double:\\n\\tvfchdbs\\t%v\\[0-9\\]*,%v24,%v26\\n\\tlhi\\t%r2,1\\n\\tlochine\\t%r2,0 1 } } */\n+\n+int __attribute__((noinline,noclone))\n+all_lt_double (vector double a, vector double b)\n+{\n+\treturn vec_all_lt (a, b);\n+}\n+/* { dg-final { scan-assembler-times all_lt_double:\\n\\tvfchdbs\\t%v\\[0-9\\]*,%v26,%v24\\n\\tlhi\\t%r2,1\\n\\tlochine\\t%r2,0 1 } } */\n+\n+int __attribute__((noinline,noclone))\n+all_ge_double (vector double a, vector double b)\n+{\n+\treturn vec_all_ge (a, b);\n+}\n+/* { dg-final { scan-assembler-times all_ge_double:\\n\\tvfchedbs\\t%v\\[0-9\\]*,%v24,%v26\\n\\tlhi\\t%r2,1\\n\\tlochine\\t%r2,0 1 } } */\n+\n+int __attribute__((noinline,noclone))\n+all_le_double (vector double a, vector double b)\n+{\n+\treturn vec_all_le (a, b);\n+}\n+/* { dg-final { scan-assembler-times all_le_double:\\n\\tvfchedbs\\t%v\\[0-9\\]*,%v26,%v24\\n\\tlhi\\t%r2,1\\n\\tlochine\\t%r2,0 1 } } */\n+\n+int __attribute__((noinline,noclone))\n+any_eq_double (vector double a, vector double b)\n+{\n+\treturn vec_any_eq (a, b);\n+}\n+/* { dg-final { scan-assembler-times any_eq_double:\\n\\tvfcedbs\\t%v\\[0-9\\]*,%v24,%v26\\n\\tlhi\\t%r2,1\\n\\tlochinle\\t%r2,0 1 } } */\n+\n+int __attribute__((noinline,noclone))\n+any_ne_double (vector double a, vector double b)\n+{\n+\treturn vec_any_ne (a, b);\n+}\n+/* { dg-final { scan-assembler-times any_ne_double:\\n\\tvfcedbs\\t%v\\[0-9\\]*,%v24,%v26\\n\\tlhi\\t%r2,1\\n\\tlochie\\t%r2,0 1 } } */\n+\n+int __attribute__((noinline,noclone))\n+any_gt_double (vector double a, vector double b)\n+{\n+\treturn vec_any_gt (a, b);\n+}\n+/* { dg-final { scan-assembler-times any_gt_double:\\n\\tvfchdbs\\t%v\\[0-9\\]*,%v24,%v26\\n\\tlhi\\t%r2,1\\n\\tlochinle\\t%r2,0 1 } } */\n+\n+int __attribute__((noinline,noclone))\n+any_lt_double (vector double a, vector double b)\n+{\n+\treturn vec_any_lt (a, b);\n+}\n+/* { dg-final { scan-assembler-times any_lt_double:\\n\\tvfchdbs\\t%v\\[0-9\\]*,%v26,%v24\\n\\tlhi\\t%r2,1\\n\\tlochinle\\t%r2,0 1 } } */\n+\n+int __attribute__((noinline,noclone))\n+any_ge_double (vector double a, vector double b)\n+{\n+\treturn vec_any_ge (a, b);\n+}\n+/* { dg-final { scan-assembler-times any_ge_double:\\n\\tvfchedbs\\t%v\\[0-9\\]*,%v24,%v26\\n\\tlhi\\t%r2,1\\n\\tlochinle\\t%r2,0 1 } } */\n+\n+int __attribute__((noinline,noclone))\n+any_le_double (vector double a, vector double b)\n+{\n+\treturn vec_any_le (a, b);\n+}\n+/* { dg-final { scan-assembler-times any_le_double:\\n\\tvfchedbs\\t%v\\[0-9\\]*,%v26,%v24\\n\\tlhi\\t%r2,1\\n\\tlochinle\\t%r2,0 1 } } */\n+\n+int __attribute__((noinline,noclone))\n+all_eq_int (vector int a, vector int b)\n+{\n+\treturn vec_all_eq (a, b);\n+}\n+/* { dg-final { scan-assembler-times all_eq_int:\\n\\tvceqfs\\t%v\\[0-9\\]*,%v24,%v26\\n\\tlhi\\t%r2,1\\n\\tlochine\\t%r2,0 1 } } */\n+\n+int __attribute__((noinline,noclone))\n+all_ne_int (vector int a, vector int b)\n+{\n+\treturn vec_all_ne (a, b);\n+}\n+/* { dg-final { scan-assembler-times all_ne_int:\\n\\tvceqfs\\t%v\\[0-9\\]*,%v24,%v26\\n\\tlhi\\t%r2,1\\n\\tlochile\\t%r2,0 1 } } */\n+\n+int __attribute__((noinline,noclone))\n+all_gt_int (vector int a, vector int b)\n+{\n+\treturn vec_all_gt (a, b);\n+}\n+/* { dg-final { scan-assembler-times all_gt_int:\\n\\tvchfs\\t%v\\[0-9\\]*,%v24,%v26\\n\\tlhi\\t%r2,1\\n\\tlochine\\t%r2,0 1 } } */\n+\n+int __attribute__((noinline,noclone))\n+all_lt_int (vector int a, vector int b)\n+{\n+\treturn vec_all_lt (a, b);\n+}\n+/* { dg-final { scan-assembler-times all_lt_int:\\n\\tvchfs\\t%v\\[0-9\\]*,%v26,%v24\\n\\tlhi\\t%r2,1\\n\\tlochine\\t%r2,0 1 } } */\n+\n+int __attribute__((noinline,noclone))\n+all_ge_int (vector int a, vector int b)\n+{\n+\treturn vec_all_ge (a, b);\n+}\n+/* { dg-final { scan-assembler-times all_ge_int:\\n\\tvchfs\\t%v\\[0-9\\]*,%v26,%v24\\n\\tlhi\\t%r2,1\\n\\tlochile\\t%r2,0 1 } } */\n+\n+int __attribute__((noinline,noclone))\n+all_le_int (vector int a, vector int b)\n+{\n+\treturn vec_all_le (a, b);\n+}\n+/* { dg-final { scan-assembler-times all_le_int:\\n\\tvchfs\\t%v\\[0-9\\]*,%v24,%v26\\n\\tlhi\\t%r2,1\\n\\tlochile\\t%r2,0 1 } } */\n+\n+int __attribute__((noinline,noclone))\n+any_eq_int (vector int a, vector int b)\n+{\n+\treturn vec_any_eq (a, b);\n+}\n+/* { dg-final { scan-assembler-times any_eq_int:\\n\\tvceqfs\\t%v\\[0-9\\]*,%v24,%v26\\n\\tlhi\\t%r2,1\\n\\tlochinle\\t%r2,0 1 } } */\n+\n+int __attribute__((noinline,noclone))\n+any_ne_int (vector int a, vector int b)\n+{\n+\treturn vec_any_ne (a, b);\n+}\n+/* { dg-final { scan-assembler-times any_ne_int:\\n\\tvceqfs\\t%v\\[0-9\\]*,%v24,%v26\\n\\tlhi\\t%r2,1\\n\\tlochie\\t%r2,0 1 } } */\n+\n+int __attribute__((noinline,noclone))\n+any_gt_int (vector int a, vector int b)\n+{\n+\treturn vec_any_gt (a, b);\n+}\n+/* { dg-final { scan-assembler-times any_gt_int:\\n\\tvchfs\\t%v\\[0-9\\]*,%v24,%v26\\n\\tlhi\\t%r2,1\\n\\tlochinle\\t%r2,0 1 } } */\n+\n+int __attribute__((noinline,noclone))\n+any_lt_int (vector int a, vector int b)\n+{\n+\treturn vec_any_lt (a, b);\n+}\n+/* { dg-final { scan-assembler-times any_lt_int:\\n\\tvchfs\\t%v\\[0-9\\]*,%v26,%v24\\n\\tlhi\\t%r2,1\\n\\tlochinle\\t%r2,0 1 } } */\n+\n+int __attribute__((noinline,noclone))\n+any_ge_int (vector int a, vector int b)\n+{\n+\treturn vec_any_ge (a, b);\n+}\n+/* { dg-final { scan-assembler-times any_ge_int:\\n\\tvchfs\\t%v\\[0-9\\]*,%v26,%v24\\n\\tlhi\\t%r2,1\\n\\tlochie\\t%r2,0 1 } } */\n+\n+int __attribute__((noinline,noclone))\n+any_le_int (vector int a, vector int b)\n+{\n+\treturn vec_any_le (a, b);\n+}\n+/* { dg-final { scan-assembler-times any_le_int:\\n\\tvchfs\\t%v\\[0-9\\]*,%v24,%v26\\n\\tlhi\\t%r2,1\\n\\tlochie\\t%r2,0 1 } } */\n+"}]}