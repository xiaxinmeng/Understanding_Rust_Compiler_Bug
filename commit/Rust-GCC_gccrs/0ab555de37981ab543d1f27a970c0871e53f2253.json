{"sha": "0ab555de37981ab543d1f27a970c0871e53f2253", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGFiNTU1ZGUzNzk4MWFiNTQzZDFmMjdhOTcwYzA4NzFlNTNmMjI1Mw==", "commit": {"author": {"name": "Michael Matz", "email": "matz@suse.de", "date": "2010-05-06T13:54:32Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2010-05-06T13:54:32Z"}, "message": "re PR tree-optimization/43984 (PRE misses full-redundancies, inserts into loops)\n\n\tPR tree-optimization/43984\n\n\t* tree-ssa-pre.c (inserted_phi_names): Remove.\n\t(inserted_exprs): Change to bitmap.\n\t(create_expression_by_pieces): Set bits, don't append to vector.\n\t(insert_into_preds_of_block): Don't handle inserted_phi_names.\n\t(eliminate): Don't look at inserted_phi_names, remove deleted\n\tinsns from inserted_exprs.\n\t(remove_dead_inserted_code): Adjust to use bitmaps instead of\n\tvectors.\n\t(init_pre, fini_pre): Allocate and free bitmaps.\n\t(execute_pre): Insert insns on edges before elimination.\n\ntestsuite/\n\t* gfortran.dg/pr43984.f90: New test.\n\nFrom-SVN: r159106", "tree": {"sha": "ecfcc5bd3b0b227ea4cda9961d63e1366bbf48fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ecfcc5bd3b0b227ea4cda9961d63e1366bbf48fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ab555de37981ab543d1f27a970c0871e53f2253", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ab555de37981ab543d1f27a970c0871e53f2253", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ab555de37981ab543d1f27a970c0871e53f2253", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ab555de37981ab543d1f27a970c0871e53f2253/comments", "author": {"login": "susematz", "id": 4117296, "node_id": "MDQ6VXNlcjQxMTcyOTY=", "avatar_url": "https://avatars.githubusercontent.com/u/4117296?v=4", "gravatar_id": "", "url": "https://api.github.com/users/susematz", "html_url": "https://github.com/susematz", "followers_url": "https://api.github.com/users/susematz/followers", "following_url": "https://api.github.com/users/susematz/following{/other_user}", "gists_url": "https://api.github.com/users/susematz/gists{/gist_id}", "starred_url": "https://api.github.com/users/susematz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/susematz/subscriptions", "organizations_url": "https://api.github.com/users/susematz/orgs", "repos_url": "https://api.github.com/users/susematz/repos", "events_url": "https://api.github.com/users/susematz/events{/privacy}", "received_events_url": "https://api.github.com/users/susematz/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "afa83c1559cb514cdb4e45e584f6e35b641b83a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afa83c1559cb514cdb4e45e584f6e35b641b83a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afa83c1559cb514cdb4e45e584f6e35b641b83a4"}], "stats": {"total": 155, "additions": 119, "deletions": 36}, "files": [{"sha": "c5288a9926c8aa6722378c7c7d41226512a95154", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ab555de37981ab543d1f27a970c0871e53f2253/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ab555de37981ab543d1f27a970c0871e53f2253/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0ab555de37981ab543d1f27a970c0871e53f2253", "patch": "@@ -1,3 +1,17 @@\n+2010-05-06  Michael Matz  <matz@suse.de>\n+\n+\tPR tree-optimization/43984\n+\t* tree-ssa-pre.c (inserted_phi_names): Remove.\n+\t(inserted_exprs): Change to bitmap.\n+\t(create_expression_by_pieces): Set bits, don't append to vector.\n+\t(insert_into_preds_of_block): Don't handle inserted_phi_names.\n+\t(eliminate): Don't look at inserted_phi_names, remove deleted\n+\tinsns from inserted_exprs.\n+\t(remove_dead_inserted_code): Adjust to use bitmaps instead of\n+\tvectors.\n+\t(init_pre, fini_pre): Allocate and free bitmaps.\n+\t(execute_pre): Insert insns on edges before elimination.\n+\n 2010-05-06  Maxim Kuvyrkov  <maxim@codesourcery.com>\n \n \t* tree.c (initializer_zerop): Handle STRING_CST."}, {"sha": "a51f4db560ebd58af8efdb950de8383f911780cd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ab555de37981ab543d1f27a970c0871e53f2253/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ab555de37981ab543d1f27a970c0871e53f2253/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0ab555de37981ab543d1f27a970c0871e53f2253", "patch": "@@ -1,3 +1,8 @@\n+2010-05-06  Michael Matz  <matz@suse.de>\n+\n+\tPR tree-optimization/43984\n+\t* gfortran.dg/pr43984.f90: New test.\n+\n 2010-05-06  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \tPR 40989"}, {"sha": "40c81b84c6c2f5cb19f23e4542d9257622bc609d", "filename": "gcc/testsuite/gfortran.dg/pr43984.f90", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ab555de37981ab543d1f27a970c0871e53f2253/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr43984.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ab555de37981ab543d1f27a970c0871e53f2253/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr43984.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr43984.f90?ref=0ab555de37981ab543d1f27a970c0871e53f2253", "patch": "@@ -0,0 +1,56 @@\n+! { dg-do compile }\n+! { dg-options \"-O2 -fno-tree-dominator-opts -fdump-tree-pre\" }\n+module test\n+\n+   type shell1quartet_type\n+\n+   integer(kind=kind(1)) :: ab_l_sum\n+   integer(kind=kind(1)), dimension(:), pointer :: ab_form_3dints_x_indices => NULL()\n+   integer(kind=kind(1)), dimension(:), pointer :: ab_form_3dints_yz_rms_indices => NULL()\n+\n+    end type\n+\n+contains\n+subroutine make_esss(self,esss)\n+  type(shell1quartet_type) :: self\n+  intent(in) :: self\n+  real(kind=kind(1.0d0)), dimension(:), intent(out) :: esss\n+  real(kind=kind(1.0d0)), dimension(:), pointer :: Izz\n+  real(kind=kind(1.0d0)), dimension(:,:), pointer :: Ix,Iy,Iz,Iyz\n+  integer(kind=kind(1)), dimension(:), pointer  :: e_x,ii_ivec\n+  integer(kind=kind(1)) :: dim, dim1, nroots, ii,z,y\n+\n+    dim = self%ab_l_sum+1\n+    dim1 = self%ab_l_sum+2\n+    nroots = (dim1) / 2\n+    call create_(Ix,nroots,dim)\n+    call create_(Iy,nroots,dim)\n+    call create_(Iz,nroots,dim)\n+    call create_(Iyz,nroots,dim*dim1/2)\n+\n+    e_x => self%ab_form_3dints_x_indices\n+    ii_ivec => self%ab_form_3dints_yz_rms_indices\n+\n+    call foo(Ix)\n+    call foo(Iy)\n+    call foo(Iz)\n+\n+    esss = ZERO\n+    ii = 0\n+    do z=1,dim\n+      Izz => Iz(:,z)\n+      do y=1,dim1-z\n+        ii = ii + 1\n+        Iyz(:,ii) = Izz * Iy(:,y)\n+      end do\n+    end do\n+    esss = esss + sum(Ix(:,e_x) * Iyz(:,ii_ivec),1)\n+\n+end subroutine\n+\n+end\n+\n+! There should be three loads from iyz.data, not four.\n+\n+! { dg-final { scan-tree-dump-times \"= iyz.data\" 3 \"pre\" } }\n+! { dg-final { cleanup-tree-dump \"pre\" } }"}, {"sha": "49dff65b37fd0c23195d0b02023d6f14e97f9316", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 44, "deletions": 36, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ab555de37981ab543d1f27a970c0871e53f2253/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ab555de37981ab543d1f27a970c0871e53f2253/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=0ab555de37981ab543d1f27a970c0871e53f2253", "patch": "@@ -2608,8 +2608,7 @@ can_PRE_operation (tree op)\n /* Inserted expressions are placed onto this worklist, which is used\n    for performing quick dead code elimination of insertions we made\n    that didn't turn out to be necessary.   */\n-static VEC(gimple,heap) *inserted_exprs;\n-static bitmap inserted_phi_names;\n+static bitmap inserted_exprs;\n \n /* Pool allocated fake store expressions are placed onto this\n    worklist, which, after performing dead code elimination, is walked\n@@ -3083,9 +3082,9 @@ create_expression_by_pieces (basic_block block, pre_expr expr,\n \t  tree forcedname = gimple_get_lhs (stmt);\n \t  pre_expr nameexpr;\n \n-\t  VEC_safe_push (gimple, heap, inserted_exprs, stmt);\n \t  if (TREE_CODE (forcedname) == SSA_NAME)\n \t    {\n+\t      bitmap_set_bit (inserted_exprs, SSA_NAME_VERSION (forcedname));\n \t      VN_INFO_GET (forcedname)->valnum = forcedname;\n \t      VN_INFO (forcedname)->value_id = get_next_value_id ();\n \t      nameexpr = get_or_alloc_expr_for_name (forcedname);\n@@ -3116,7 +3115,7 @@ create_expression_by_pieces (basic_block block, pre_expr expr,\n   gimple_set_plf (newstmt, NECESSARY, false);\n \n   gimple_seq_add_stmt (stmts, newstmt);\n-  VEC_safe_push (gimple, heap, inserted_exprs, newstmt);\n+  bitmap_set_bit (inserted_exprs, SSA_NAME_VERSION (name));\n \n   /* All the symbols in NEWEXPR should be put into SSA form.  */\n   mark_symbols_for_renaming (newstmt);\n@@ -3299,7 +3298,10 @@ insert_into_preds_of_block (basic_block block, unsigned int exprnum,\n \t\t\t  for (; !gsi_end_p (gsi); gsi_next (&gsi))\n \t\t\t    {\n \t\t\t      gimple stmt = gsi_stmt (gsi);\n-\t\t\t      VEC_safe_push (gimple, heap, inserted_exprs, stmt);\n+\t\t\t      tree lhs = gimple_get_lhs (stmt);\n+\t\t\t      if (TREE_CODE (lhs) == SSA_NAME)\n+\t\t\t\tbitmap_set_bit (inserted_exprs,\n+\t\t\t\t\t\tSSA_NAME_VERSION (lhs));\n \t\t\t      gimple_set_plf (stmt, NECESSARY, false);\n \t\t\t    }\n \t\t\t  gsi_insert_seq_on_edge (pred, stmts);\n@@ -3338,7 +3340,9 @@ insert_into_preds_of_block (basic_block block, unsigned int exprnum,\n \t\t  for (; !gsi_end_p (gsi); gsi_next (&gsi))\n \t\t    {\n \t\t      gimple stmt = gsi_stmt (gsi);\n-\t\t      VEC_safe_push (gimple, heap, inserted_exprs, stmt);\n+\t\t      tree lhs = gimple_get_lhs (stmt);\n+\t\t      if (TREE_CODE (lhs) == SSA_NAME)\n+\t\t\tbitmap_set_bit (inserted_exprs, SSA_NAME_VERSION (lhs));\n \t\t      gimple_set_plf (stmt, NECESSARY, false);\n \t\t    }\n \t\t  gsi_insert_seq_on_edge (pred, stmts);\n@@ -3374,9 +3378,7 @@ insert_into_preds_of_block (basic_block block, unsigned int exprnum,\n   gimple_set_plf (phi, NECESSARY, false);\n   VN_INFO_GET (gimple_phi_result (phi))->valnum = gimple_phi_result (phi);\n   VN_INFO (gimple_phi_result (phi))->value_id = val;\n-  VEC_safe_push (gimple, heap, inserted_exprs, phi);\n-  bitmap_set_bit (inserted_phi_names,\n-\t\t  SSA_NAME_VERSION (gimple_phi_result (phi)));\n+  bitmap_set_bit (inserted_exprs, SSA_NAME_VERSION (gimple_phi_result (phi)));\n   FOR_EACH_EDGE (pred, ei, block->preds)\n     {\n       pre_expr ae = avail[pred->src->index];\n@@ -4309,8 +4311,7 @@ eliminate (void)\n \t     replacing the PHI with a single copy if possible.\n \t     Do not touch inserted, single-argument or virtual PHIs.  */\n \t  if (gimple_phi_num_args (phi) == 1\n-\t      || !is_gimple_reg (res)\n-\t      || bitmap_bit_p (inserted_phi_names, SSA_NAME_VERSION (res)))\n+\t      || !is_gimple_reg (res))\n \t    {\n \t      gsi_next (&gsi);\n \t      continue;\n@@ -4350,14 +4351,16 @@ eliminate (void)\n \t    sprime = fold_convert (TREE_TYPE (res), sprime);\n \t  stmt = gimple_build_assign (res, sprime);\n \t  SSA_NAME_DEF_STMT (res) = stmt;\n-\t  if (TREE_CODE (sprime) == SSA_NAME)\n-\t    gimple_set_plf (SSA_NAME_DEF_STMT (sprime),\n-\t\t\t    NECESSARY, true);\n+\n \t  gsi2 = gsi_after_labels (b);\n \t  gsi_insert_before (&gsi2, stmt, GSI_NEW_STMT);\n \t  /* Queue the copy for eventual removal.  */\n \t  VEC_safe_push (gimple, heap, to_remove, stmt);\n-\t  pre_stats.eliminations++;\n+\t  /* If we inserted this PHI node ourself, it's not an elimination.  */\n+\t  if (bitmap_bit_p (inserted_exprs, SSA_NAME_VERSION (res)))\n+\t    pre_stats.phis--;\n+\t  else\n+\t    pre_stats.eliminations++;\n \t}\n     }\n \n@@ -4389,6 +4392,8 @@ eliminate (void)\n \t  gsi = gsi_for_stmt (stmt);\n \t  unlink_stmt_vdef (stmt);\n \t  gsi_remove (&gsi, true);\n+\t  if (TREE_CODE (lhs) == SSA_NAME)\n+\t    bitmap_clear_bit (inserted_exprs, SSA_NAME_VERSION (lhs));\n \t  release_defs (stmt);\n \t}\n     }\n@@ -4434,19 +4439,23 @@ mark_operand_necessary (tree op)\n static void\n remove_dead_inserted_code (void)\n {\n-  VEC(gimple,heap) *worklist = NULL;\n-  int i;\n+  bitmap worklist;\n+  unsigned i;\n+  bitmap_iterator bi;\n   gimple t;\n \n-  worklist = VEC_alloc (gimple, heap, VEC_length (gimple, inserted_exprs));\n-  for (i = 0; VEC_iterate (gimple, inserted_exprs, i, t); i++)\n+  worklist = BITMAP_ALLOC (NULL);\n+  EXECUTE_IF_SET_IN_BITMAP (inserted_exprs, 0, i, bi)\n     {\n+      t = SSA_NAME_DEF_STMT (ssa_name (i));\n       if (gimple_plf (t, NECESSARY))\n-\tVEC_quick_push (gimple, worklist, t);\n+\tbitmap_set_bit (worklist, i);\n     }\n-  while (VEC_length (gimple, worklist) > 0)\n+  while (!bitmap_empty_p (worklist))\n     {\n-      t = VEC_pop (gimple, worklist);\n+      i = bitmap_first_set_bit (worklist);\n+      bitmap_clear_bit (worklist, i);\n+      t = SSA_NAME_DEF_STMT (ssa_name (i));\n \n       /* PHI nodes are somewhat special in that each PHI alternative has\n \t data and control dependencies.  All the statements feeding the\n@@ -4455,15 +4464,14 @@ remove_dead_inserted_code (void)\n \t{\n \t  unsigned k;\n \n-\t  VEC_reserve (gimple, heap, worklist, gimple_phi_num_args (t));\n \t  for (k = 0; k < gimple_phi_num_args (t); k++)\n \t    {\n \t      tree arg = PHI_ARG_DEF (t, k);\n \t      if (TREE_CODE (arg) == SSA_NAME)\n \t\t{\n \t\t  gimple n = mark_operand_necessary (arg);\n \t\t  if (n)\n-\t\t    VEC_quick_push (gimple, worklist, n);\n+\t\t    bitmap_set_bit (worklist, SSA_NAME_VERSION (arg));\n \t\t}\n \t    }\n \t}\n@@ -4484,13 +4492,14 @@ remove_dead_inserted_code (void)\n \t    {\n \t      gimple n = mark_operand_necessary (use);\n \t      if (n)\n-\t\tVEC_safe_push (gimple, heap, worklist, n);\n+\t\tbitmap_set_bit (worklist, SSA_NAME_VERSION (use));\n \t    }\n \t}\n     }\n \n-  for (i = 0; VEC_iterate (gimple, inserted_exprs, i, t); i++)\n+  EXECUTE_IF_SET_IN_BITMAP (inserted_exprs, 0, i, bi)\n     {\n+      t = SSA_NAME_DEF_STMT (ssa_name (i));\n       if (!gimple_plf (t, NECESSARY))\n \t{\n \t  gimple_stmt_iterator gsi;\n@@ -4511,7 +4520,7 @@ remove_dead_inserted_code (void)\n \t    }\n \t}\n     }\n-  VEC_free (gimple, heap, worklist);\n+  BITMAP_FREE (worklist);\n }\n \n /* Compute a reverse post-order in *POST_ORDER.  If INCLUDE_ENTRY_EXIT is\n@@ -4604,7 +4613,7 @@ init_pre (bool do_fre)\n \n   in_fre = do_fre;\n \n-  inserted_exprs = NULL;\n+  inserted_exprs = BITMAP_ALLOC (NULL);\n   need_creation = NULL;\n   pretemp = NULL_TREE;\n   storetemp = NULL_TREE;\n@@ -4624,7 +4633,6 @@ init_pre (bool do_fre)\n   calculate_dominance_info (CDI_DOMINATORS);\n \n   bitmap_obstack_initialize (&grand_bitmap_obstack);\n-  inserted_phi_names = BITMAP_ALLOC (&grand_bitmap_obstack);\n   phi_translate_table = htab_create (5110, expr_pred_trans_hash,\n \t\t\t\t     expr_pred_trans_eq, free);\n   expression_to_id = htab_create (num_ssa_names * 3,\n@@ -4655,7 +4663,7 @@ fini_pre (bool do_fre)\n \n   free (postorder);\n   VEC_free (bitmap_set_t, heap, value_expressions);\n-  VEC_free (gimple, heap, inserted_exprs);\n+  BITMAP_FREE (inserted_exprs);\n   VEC_free (gimple, heap, need_creation);\n   bitmap_obstack_release (&grand_bitmap_obstack);\n   free_alloc_pool (bitmap_set_pool);\n@@ -4740,6 +4748,12 @@ execute_pre (bool do_fre)\n       insert ();\n     }\n \n+  /* Make sure to remove fake edges before committing our inserts.\n+     This makes sure we don't end up with extra critical edges that\n+     we would need to split.  */\n+  remove_fake_exit_edges ();\n+  gsi_commit_edge_inserts ();\n+\n   /* Remove all the redundant expressions.  */\n   todo |= eliminate ();\n \n@@ -4749,12 +4763,6 @@ execute_pre (bool do_fre)\n   statistics_counter_event (cfun, \"Eliminated\", pre_stats.eliminations);\n   statistics_counter_event (cfun, \"Constified\", pre_stats.constified);\n \n-  /* Make sure to remove fake edges before committing our inserts.\n-     This makes sure we don't end up with extra critical edges that\n-     we would need to split.  */\n-  remove_fake_exit_edges ();\n-  gsi_commit_edge_inserts ();\n-\n   clear_expression_ids ();\n   free_scc_vn ();\n   if (!do_fre)"}]}