{"sha": "f4b3ca7277845d4444997924301da6225ce19001", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjRiM2NhNzI3Nzg0NWQ0NDQ0OTk3OTI0MzAxZGE2MjI1Y2UxOTAwMQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2007-01-08T11:13:14Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2007-01-08T11:13:14Z"}, "message": "tree-pas.h (TODO_remove_function): New flag.\n\n\n\t* tree-pas.h (TODO_remove_function): New flag.\n\t(TODO_update*): Renumber.\n\t(pass_ipa_increase_alignment,\n\tpass_ipa_function_and_variable_visibility): New passes.\n\t* cgraphunit.c (cgraph_increase_alignment): Move to tree-vectorizer.c\n\t(cgraph_function_and_variable_visibility): Move to ipa.c\n\t(cgraph_optimize): Don't call cgraph_function_and_variable_visibility,\n\tcgraph_increase_alignment.\n\t* ipa-inline.c (cgraph_decide_inlining): Don't push timevar.\n\t(cgraph_decide_inlining_incrementally): Push TV_INTEGRATION before\n\tcalling tree-inline.\n\t(cgraph_early_inlining): Do not call cgraph_remove_unreachable_nodes.\n\t(pass_ipa_inline, pass_early_ipa_inlining): Set TODO_remove_functions\n\t* tree-vectorizer.c (increase_alignment): Move here from cgraphunit.c\n\t(gate_increase_alignment): New function.\n\t(pass_ipa_increase_alignment): New pass.\n\t* ipa.c: Inline tree-pass.h and timevar.h\n\t(function_and_variable_visibility): Move here from cgraphunit.c\n\t* tree-optimize.c (pass_early_local_passes): Add TODO_remove_functions.\n\t* passes.c (init_optimization_passes): Add the two new passes.\n\t(execute_todo): Handle cgraph_remove_functions.\n\nFrom-SVN: r120576", "tree": {"sha": "5658297c549eec3a1a45febe1d3d11e413cc482c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5658297c549eec3a1a45febe1d3d11e413cc482c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f4b3ca7277845d4444997924301da6225ce19001", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4b3ca7277845d4444997924301da6225ce19001", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4b3ca7277845d4444997924301da6225ce19001", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4b3ca7277845d4444997924301da6225ce19001/comments", "author": null, "committer": null, "parents": [{"sha": "2fe29729951cda1678804a3e681b145430cd068c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fe29729951cda1678804a3e681b145430cd068c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fe29729951cda1678804a3e681b145430cd068c"}], "stats": {"total": 344, "additions": 202, "deletions": 142}, "files": [{"sha": "eebee13f9ee5128306585672d935c2e039e666cf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b3ca7277845d4444997924301da6225ce19001/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b3ca7277845d4444997924301da6225ce19001/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f4b3ca7277845d4444997924301da6225ce19001", "patch": "@@ -1,3 +1,27 @@\n+2007-01-08  Jan Hubicka  <jh@suse.cz>\n+\n+\t* tree-pas.h (TODO_remove_function): New flag.\n+\t(TODO_update*): Renumber.\n+\t(pass_ipa_increase_alignment,\n+\tpass_ipa_function_and_variable_visibility): New passes.\n+\t* cgraphunit.c (cgraph_increase_alignment): Move to tree-vectorizer.c\n+\t(cgraph_function_and_variable_visibility): Move to ipa.c\n+\t(cgraph_optimize): Don't call cgraph_function_and_variable_visibility,\n+\tcgraph_increase_alignment.\n+\t* ipa-inline.c (cgraph_decide_inlining): Don't push timevar.\n+\t(cgraph_decide_inlining_incrementally): Push TV_INTEGRATION before\n+\tcalling tree-inline.\n+\t(cgraph_early_inlining): Do not call cgraph_remove_unreachable_nodes.\n+\t(pass_ipa_inline, pass_early_ipa_inlining): Set TODO_remove_functions\n+\t* tree-vectorizer.c (increase_alignment): Move here from cgraphunit.c\n+\t(gate_increase_alignment): New function.\n+\t(pass_ipa_increase_alignment): New pass.\n+\t* ipa.c: Inline tree-pass.h and timevar.h\n+\t(function_and_variable_visibility): Move here from cgraphunit.c\n+\t* tree-optimize.c (pass_early_local_passes): Add TODO_remove_functions.\n+\t* passes.c (init_optimization_passes): Add the two new passes.\n+\t(execute_todo): Handle cgraph_remove_functions.\n+\n 2007-01-08  Nick Clifton  <nickc@redhat.com>\n \n \t* config/frv/predicates.md (reg_or_0_operand): Accept"}, {"sha": "f75d7b82f9234c94e8366973efb83007d90c6ae2", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 0, "deletions": 127, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b3ca7277845d4444997924301da6225ce19001/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b3ca7277845d4444997924301da6225ce19001/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=f4b3ca7277845d4444997924301da6225ce19001", "patch": "@@ -165,7 +165,6 @@ static void cgraph_expand_all_functions (void);\n static void cgraph_mark_functions_to_output (void);\n static void cgraph_expand_function (struct cgraph_node *);\n static void cgraph_output_pending_asms (void);\n-static void cgraph_increase_alignment (void);\n \n static FILE *cgraph_dump_file;\n \n@@ -1138,78 +1137,6 @@ cgraph_output_in_order (void)\n   cgraph_asm_nodes = NULL;\n }\n \n-/* Mark visibility of all functions.\n-\n-   A local function is one whose calls can occur only in the current\n-   compilation unit and all its calls are explicit, so we can change\n-   its calling convention.  We simply mark all static functions whose\n-   address is not taken as local.\n-\n-   We also change the TREE_PUBLIC flag of all declarations that are public\n-   in language point of view but we want to overwrite this default\n-   via visibilities for the backend point of view.  */\n-\n-static void\n-cgraph_function_and_variable_visibility (void)\n-{\n-  struct cgraph_node *node;\n-  struct varpool_node *vnode;\n-\n-  for (node = cgraph_nodes; node; node = node->next)\n-    {\n-      if (node->reachable\n-\t  && (DECL_COMDAT (node->decl)\n-\t      || (!flag_whole_program\n-\t\t  && TREE_PUBLIC (node->decl) && !DECL_EXTERNAL (node->decl))))\n-\tnode->local.externally_visible = true;\n-      if (!node->local.externally_visible && node->analyzed\n-\t  && !DECL_EXTERNAL (node->decl))\n-\t{\n-\t  gcc_assert (flag_whole_program || !TREE_PUBLIC (node->decl));\n-\t  TREE_PUBLIC (node->decl) = 0;\n-\t}\n-      node->local.local = (!node->needed\n-\t\t\t   && node->analyzed\n-\t\t\t   && !DECL_EXTERNAL (node->decl)\n-\t\t\t   && !node->local.externally_visible);\n-    }\n-  for (vnode = varpool_nodes_queue; vnode; vnode = vnode->next_needed)\n-    {\n-      if (vnode->needed\n-\t  && !flag_whole_program\n-\t  && (DECL_COMDAT (vnode->decl) || TREE_PUBLIC (vnode->decl)))\n-\tvnode->externally_visible = 1;\n-      if (!vnode->externally_visible)\n-\t{\n-\t  gcc_assert (flag_whole_program || !TREE_PUBLIC (vnode->decl));\n-\t  TREE_PUBLIC (vnode->decl) = 0;\n-\t}\n-     gcc_assert (TREE_STATIC (vnode->decl));\n-    }\n-\n-  /* Because we have to be conservative on the boundaries of source\n-     level units, it is possible that we marked some functions in\n-     reachable just because they might be used later via external\n-     linkage, but after making them local they are really unreachable\n-     now.  */\n-  cgraph_remove_unreachable_nodes (true, cgraph_dump_file);\n-\n-  if (cgraph_dump_file)\n-    {\n-      fprintf (cgraph_dump_file, \"\\nMarking local functions:\");\n-      for (node = cgraph_nodes; node; node = node->next)\n-\tif (node->local.local)\n-\t  fprintf (cgraph_dump_file, \" %s\", cgraph_node_name (node));\n-      fprintf (cgraph_dump_file, \"\\n\\n\");\n-      fprintf (cgraph_dump_file, \"\\nMarking externally visible functions:\");\n-      for (node = cgraph_nodes; node; node = node->next)\n-\tif (node->local.externally_visible)\n-\t  fprintf (cgraph_dump_file, \" %s\", cgraph_node_name (node));\n-      fprintf (cgraph_dump_file, \"\\n\\n\");\n-    }\n-  cgraph_function_flags_ready = true;\n-}\n-\n /* Return true when function body of DECL still needs to be kept around\n    for later re-use.  */\n bool\n@@ -1273,13 +1200,6 @@ cgraph_optimize (void)\n     }\n   if (!quiet_flag)\n     fprintf (stderr, \"Performing interprocedural optimizations\\n\");\n-\n-  cgraph_function_and_variable_visibility ();\n-  if (cgraph_dump_file)\n-    {\n-      fprintf (cgraph_dump_file, \"Marked \");\n-      dump_cgraph (cgraph_dump_file);\n-    }\n   cgraph_state = CGRAPH_STATE_IPA;\n     \n   /* Don't run the IPA passes if there was any error or sorry messages.  */\n@@ -1289,7 +1209,6 @@ cgraph_optimize (void)\n   /* This pass remove bodies of extern inline functions we never inlined.\n      Do this later so other IPA passes see what is really going on.  */\n   cgraph_remove_unreachable_nodes (false, dump_file);\n-  cgraph_increase_alignment ();\n   cgraph_global_info_ready = true;\n   if (cgraph_dump_file)\n     {\n@@ -1357,52 +1276,6 @@ cgraph_optimize (void)\n     }\n #endif\n }\n-\n-/* Increase alignment of global arrays to improve vectorization potential.\n-   TODO:\n-   - Consider also structs that have an array field.\n-   - Use ipa analysis to prune arrays that can't be vectorized?\n-     This should involve global alignment analysis and in the future also\n-     array padding.  */\n-\n-static void\n-cgraph_increase_alignment (void)\n-{\n-  if (flag_section_anchors && flag_tree_vectorize)\n-    {\n-      struct varpool_node *vnode;\n-\n-      /* Increase the alignment of all global arrays for vectorization.  */\n-      for (vnode = varpool_nodes_queue;\n-           vnode;\n-           vnode = vnode->next_needed)\n-        {\n-          tree vectype, decl = vnode->decl;\n-          unsigned int alignment;\n-\n-          if (TREE_CODE (TREE_TYPE (decl)) != ARRAY_TYPE)\n-            continue;\n-          vectype = get_vectype_for_scalar_type (TREE_TYPE (TREE_TYPE (decl)));\n-          if (!vectype)\n-            continue;\n-          alignment = TYPE_ALIGN (vectype);\n-          if (DECL_ALIGN (decl) >= alignment)\n-            continue;\n-\n-          if (vect_can_force_dr_alignment_p (decl, alignment))\n-            { \n-              DECL_ALIGN (decl) = TYPE_ALIGN (vectype);\n-              DECL_USER_ALIGN (decl) = 1;\n-              if (cgraph_dump_file)\n-                { \n-                  fprintf (cgraph_dump_file, \"Increasing alignment of decl: \");\n-                  print_generic_expr (cgraph_dump_file, decl, TDF_SLIM);\n-                }\n-            }\n-        }\n-    }\n-}\n-\n /* Generate and emit a static constructor or destructor.  WHICH must be\n    one of 'I' or 'D'.  BODY should be a STATEMENT_LIST containing\n    GENERIC statements.  */"}, {"sha": "bf9790fd47d6822f8f0e3d40ee1208192af56017", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b3ca7277845d4444997924301da6225ce19001/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b3ca7277845d4444997924301da6225ce19001/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=f4b3ca7277845d4444997924301da6225ce19001", "patch": "@@ -925,7 +925,6 @@ cgraph_decide_inlining (void)\n   int old_insns = 0;\n   int i;\n \n-  timevar_push (TV_INLINE_HEURISTICS);\n   max_count = 0;\n   for (node = cgraph_nodes; node; node = node->next)\n     if (node->analyzed && (node->needed || node->reachable))\n@@ -1083,7 +1082,6 @@ cgraph_decide_inlining (void)\n \t     ncalls_inlined, nfunctions_inlined, initial_insns,\n \t     overall_insns);\n   free (order);\n-  timevar_pop (TV_INLINE_HEURISTICS);\n   return 0;\n }\n \n@@ -1146,13 +1144,15 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node, bool early)\n \t}\n   if (early && inlined)\n     {\n+      timevar_push (TV_INTEGRATION);\n       push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n       tree_register_cfg_hooks ();\n       current_function_decl = node->decl;\n       optimize_inline_calls (current_function_decl);\n       node->local.self_insns = node->global.insns;\n       current_function_decl = NULL;\n       pop_cfun ();\n+      timevar_pop (TV_INTEGRATION);\n     }\n   return inlined;\n }\n@@ -1172,12 +1172,13 @@ struct tree_opt_pass pass_ipa_inline =\n   NULL,\t\t\t\t\t/* sub */\n   NULL,\t\t\t\t\t/* next */\n   0,\t\t\t\t\t/* static_pass_number */\n-  TV_INTEGRATION,\t\t\t/* tv_id */\n+  TV_INLINE_HEURISTICS,\t\t\t/* tv_id */\n   0,\t                                /* properties_required */\n   PROP_cfg,\t\t\t\t/* properties_provided */\n   0,\t\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_dump_cgraph | TODO_dump_func,\t/* todo_flags_finish */\n+  TODO_dump_cgraph | TODO_dump_func\n+  | TODO_remove_functions,\t\t/* todo_flags_finish */\n   0\t\t\t\t\t/* letter */\n };\n \n@@ -1223,7 +1224,6 @@ cgraph_early_inlining (void)\n \t    ggc_collect ();\n \t}\n     }\n-  cgraph_remove_unreachable_nodes (true, dump_file);\n #ifdef ENABLE_CHECKING\n   for (node = cgraph_nodes; node; node = node->next)\n     gcc_assert (!node->global.inlined_to);\n@@ -1249,12 +1249,13 @@ struct tree_opt_pass pass_early_ipa_inline =\n   NULL,\t\t\t\t\t/* sub */\n   NULL,\t\t\t\t\t/* next */\n   0,\t\t\t\t\t/* static_pass_number */\n-  TV_INTEGRATION,\t\t\t/* tv_id */\n+  TV_INLINE_HEURISTICS,\t\t\t/* tv_id */\n   0,\t                                /* properties_required */\n   PROP_cfg,\t\t\t\t/* properties_provided */\n   0,\t\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_dump_cgraph | TODO_dump_func,\t/* todo_flags_finish */\n+  TODO_dump_cgraph | TODO_dump_func\n+  | TODO_remove_functions,\t\t/* todo_flags_finish */\n   0\t\t\t\t\t/* letter */\n };\n "}, {"sha": "68e65a9e80c705f2a47c6f82d97c5a884f924283", "filename": "gcc/ipa.c", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b3ca7277845d4444997924301da6225ce19001/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b3ca7277845d4444997924301da6225ce19001/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=f4b3ca7277845d4444997924301da6225ce19001", "patch": "@@ -23,6 +23,8 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"coretypes.h\"\n #include \"tm.h\"\n #include \"cgraph.h\"\n+#include \"tree-pass.h\"\n+#include \"timevar.h\"\n \n /* Fill array order with all nodes with output flag set in the reverse\n    topological order.  */\n@@ -206,3 +208,85 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n     fprintf (file, \"\\nReclaimed %i insns\", insns);\n   return changed;\n }\n+\n+/* Mark visibility of all functions.\n+\n+   A local function is one whose calls can occur only in the current\n+   compilation unit and all its calls are explicit, so we can change\n+   its calling convention.  We simply mark all static functions whose\n+   address is not taken as local.\n+\n+   We also change the TREE_PUBLIC flag of all declarations that are public\n+   in language point of view but we want to overwrite this default\n+   via visibilities for the backend point of view.  */\n+\n+static void\n+function_and_variable_visibility (void)\n+{\n+  struct cgraph_node *node;\n+  struct varpool_node *vnode;\n+\n+  for (node = cgraph_nodes; node; node = node->next)\n+    {\n+      if (node->reachable\n+\t  && (DECL_COMDAT (node->decl)\n+\t      || (!flag_whole_program\n+\t\t  && TREE_PUBLIC (node->decl) && !DECL_EXTERNAL (node->decl))))\n+\tnode->local.externally_visible = true;\n+      if (!node->local.externally_visible && node->analyzed\n+\t  && !DECL_EXTERNAL (node->decl))\n+\t{\n+\t  gcc_assert (flag_whole_program || !TREE_PUBLIC (node->decl));\n+\t  TREE_PUBLIC (node->decl) = 0;\n+\t}\n+      node->local.local = (!node->needed\n+\t\t\t   && node->analyzed\n+\t\t\t   && !DECL_EXTERNAL (node->decl)\n+\t\t\t   && !node->local.externally_visible);\n+    }\n+  for (vnode = varpool_nodes_queue; vnode; vnode = vnode->next_needed)\n+    {\n+      if (vnode->needed\n+\t  && !flag_whole_program\n+\t  && (DECL_COMDAT (vnode->decl) || TREE_PUBLIC (vnode->decl)))\n+\tvnode->externally_visible = 1;\n+      if (!vnode->externally_visible)\n+\t{\n+\t  gcc_assert (flag_whole_program || !TREE_PUBLIC (vnode->decl));\n+\t  TREE_PUBLIC (vnode->decl) = 0;\n+\t}\n+     gcc_assert (TREE_STATIC (vnode->decl));\n+    }\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"\\nMarking local functions:\");\n+      for (node = cgraph_nodes; node; node = node->next)\n+\tif (node->local.local)\n+\t  fprintf (dump_file, \" %s\", cgraph_node_name (node));\n+      fprintf (dump_file, \"\\n\\n\");\n+      fprintf (dump_file, \"\\nMarking externally visible functions:\");\n+      for (node = cgraph_nodes; node; node = node->next)\n+\tif (node->local.externally_visible)\n+\t  fprintf (dump_file, \" %s\", cgraph_node_name (node));\n+      fprintf (dump_file, \"\\n\\n\");\n+    }\n+  cgraph_function_flags_ready = true;\n+}\n+\n+struct tree_opt_pass pass_ipa_function_and_variable_visibility = \n+{\n+  \"visibility\",\t\t\t\t/* name */\n+  NULL,\t\t\t\t\t/* gate */\n+  function_and_variable_visibility,\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_CGRAPHOPT,\t\t\t\t/* tv_id */\n+  0,\t                                /* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_remove_functions | TODO_dump_cgraph,/* todo_flags_finish */\n+  0\t\t\t\t\t/* letter */\n+};"}, {"sha": "d8b7f110eac85f196e82518ce2f2c17486177b3f", "filename": "gcc/passes.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b3ca7277845d4444997924301da6225ce19001/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b3ca7277845d4444997924301da6225ce19001/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=f4b3ca7277845d4444997924301da6225ce19001", "patch": "@@ -439,8 +439,10 @@ init_optimization_passes (void)\n #define NEXT_PASS(PASS)  (p = next_pass_1 (p, &PASS))\n   /* Interprocedural optimization passes.  */\n   p = &all_ipa_passes;\n+  NEXT_PASS (pass_ipa_function_and_variable_visibility);\n   NEXT_PASS (pass_early_ipa_inline);\n   NEXT_PASS (pass_early_local_passes);\n+  NEXT_PASS (pass_ipa_increase_alignment);\n   NEXT_PASS (pass_ipa_cp);\n   NEXT_PASS (pass_ipa_inline);\n   NEXT_PASS (pass_ipa_reference);\n@@ -830,6 +832,13 @@ execute_todo (unsigned int flags)\n \n   do_per_function (execute_function_todo, (void *)(size_t) flags);\n \n+  /* Always remove functions just as before inlining: IPA passes might be\n+     interested to see bodies of extern inline functions that are not inlined\n+     to analyze side effects.  The full removal is done just at the end\n+     of IPA pass queue.  */\n+  if (flags & TODO_remove_functions)\n+    cgraph_remove_unreachable_nodes (true, dump_file);\n+\n   if ((flags & TODO_dump_cgraph)\n       && dump_file && !current_function_decl)\n     {"}, {"sha": "6c5fb550ff5d058819cc7a7ce6c19860476cc3f4", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b3ca7277845d4444997924301da6225ce19001/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b3ca7277845d4444997924301da6225ce19001/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=f4b3ca7277845d4444997924301da6225ce19001", "patch": "@@ -101,7 +101,7 @@ struct tree_opt_pass pass_early_local_passes =\n   0,\t\t\t\t\t/* properties_provided */\n   0,\t\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */\n-  0,\t\t\t\t\t/* todo_flags_finish */\n+  TODO_remove_functions,\t\t/* todo_flags_finish */\n   0\t\t\t\t\t/* letter */\n };\n "}, {"sha": "49fd58cc2e80edcc7e313b6e05e01e862400bad1", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b3ca7277845d4444997924301da6225ce19001/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b3ca7277845d4444997924301da6225ce19001/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=f4b3ca7277845d4444997924301da6225ce19001", "patch": "@@ -166,6 +166,7 @@ struct dump_file_info\n #define TODO_cleanup_cfg        \t(1 << 5)\n #define TODO_verify_loops\t\t(1 << 6)\n #define TODO_dump_cgraph\t\t(1 << 7)\n+#define TODO_remove_functions\t\t(1 << 8)\n \n /* To-do flags for calls to update_ssa.  */\n \n@@ -177,13 +178,13 @@ struct dump_file_info\n    in blocks that have one or more edges with no incoming definition\n    for O_j.  This would lead to uninitialized warnings for O_j's\n    symbol.  */\n-#define TODO_update_ssa\t\t\t(1 << 8)\n+#define TODO_update_ssa\t\t\t(1 << 9)\n \n /* Update the SSA form without inserting any new PHI nodes at all.\n    This is used by passes that have either inserted all the PHI nodes\n    themselves or passes that need only to patch use-def and def-def\n    chains for virtuals (e.g., DCE).  */\n-#define TODO_update_ssa_no_phi\t\t(1 << 9)\n+#define TODO_update_ssa_no_phi\t\t(1 << 10)\n \n /* Insert PHI nodes everywhere they are needed.  No pruning of the\n    IDF is done.  This is used by passes that need the PHI nodes for\n@@ -194,28 +195,28 @@ struct dump_file_info\n    may be doing something wrong.  Inserting PHI nodes for an old name\n    where not all edges carry a new replacement may lead to silent\n    codegen errors or spurious uninitialized warnings.  */\n-#define TODO_update_ssa_full_phi\t(1 << 10)\n+#define TODO_update_ssa_full_phi\t(1 << 11)\n \n /* Passes that update the SSA form on their own may want to delegate\n    the updating of virtual names to the generic updater.  Since FUD\n    chains are easier to maintain, this simplifies the work they need\n    to do.  NOTE: If this flag is used, any OLD->NEW mappings for real\n    names are explicitly destroyed and only the symbols marked for\n    renaming are processed.  */\n-#define TODO_update_ssa_only_virtuals\t(1 << 11)\n+#define TODO_update_ssa_only_virtuals\t(1 << 12)\n \n /* Some passes leave unused local variables that can be removed from\n    cfun->unexpanded_var_list.  This reduces the size of dump files and\n    the memory footprint for VAR_DECLs.  */\n-#define TODO_remove_unused_locals\t(1 << 12)\n+#define TODO_remove_unused_locals\t(1 << 13)\n \n /* Internally used for the first in a sequence of passes.  It is set\n    for the passes that are handed to register_dump_files.  */\n-#define TODO_set_props\t\t\t(1 << 13)\n+#define TODO_set_props\t\t\t(1 << 14)\n \n /* Set by passes that may make SMT's that were previously never used\n    in statements, used.  */\n-#define TODO_update_smt_usage           (1 << 14)\n+#define TODO_update_smt_usage           (1 << 15)\n \n #define TODO_update_ssa_any\t\t\\\n     (TODO_update_ssa\t\t\t\\\n@@ -316,6 +317,8 @@ extern struct tree_opt_pass pass_ipa_type_escape;\n extern struct tree_opt_pass pass_ipa_pta;\n extern struct tree_opt_pass pass_early_local_passes;\n extern struct tree_opt_pass pass_all_early_optimizations;\n+extern struct tree_opt_pass pass_ipa_increase_alignment;\n+extern struct tree_opt_pass pass_ipa_function_and_variable_visibility;\n \n extern struct tree_opt_pass pass_all_optimizations;\n extern struct tree_opt_pass pass_cleanup_cfg_post_optimizing;"}, {"sha": "aeda161cd9134d306f61078247fc6c826c52e6dc", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b3ca7277845d4444997924301da6225ce19001/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b3ca7277845d4444997924301da6225ce19001/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=f4b3ca7277845d4444997924301da6225ce19001", "patch": "@@ -2211,3 +2211,69 @@ vectorize_loops (void)\n \n   return num_vectorized_loops > 0 ? TODO_cleanup_cfg : 0;\n }\n+\n+/* Increase alignment of global arrays to improve vectorization potential.\n+   TODO:\n+   - Consider also structs that have an array field.\n+   - Use ipa analysis to prune arrays that can't be vectorized?\n+     This should involve global alignment analysis and in the future also\n+     array padding.  */\n+\n+static unsigned int\n+increase_alignment (void)\n+{\n+  struct varpool_node *vnode;\n+\n+  /* Increase the alignment of all global arrays for vectorization.  */\n+  for (vnode = varpool_nodes_queue;\n+       vnode;\n+       vnode = vnode->next_needed)\n+    {\n+      tree vectype, decl = vnode->decl;\n+      unsigned int alignment;\n+\n+      if (TREE_CODE (TREE_TYPE (decl)) != ARRAY_TYPE)\n+\tcontinue;\n+      vectype = get_vectype_for_scalar_type (TREE_TYPE (TREE_TYPE (decl)));\n+      if (!vectype)\n+\tcontinue;\n+      alignment = TYPE_ALIGN (vectype);\n+      if (DECL_ALIGN (decl) >= alignment)\n+\tcontinue;\n+\n+      if (vect_can_force_dr_alignment_p (decl, alignment))\n+\t{ \n+\t  DECL_ALIGN (decl) = TYPE_ALIGN (vectype);\n+\t  DECL_USER_ALIGN (decl) = 1;\n+\t  if (dump_file)\n+\t    { \n+\t      fprintf (dump_file, \"Increasing alignment of decl: \");\n+\t      print_generic_expr (dump_file, decl, TDF_SLIM);\n+\t    }\n+\t}\n+    }\n+  return 0;\n+}\n+\n+static int\n+gate_increase_alignment (void)\n+{\n+  return flag_section_anchors && flag_tree_vectorize;\n+}\n+\n+struct tree_opt_pass pass_ipa_increase_alignment = \n+{\n+  \"increase_alignment\",\t\t\t/* name */\n+  gate_increase_alignment,\t\t/* gate */\n+  increase_alignment,\t\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  0,\t\t\t\t\t/* tv_id */\n+  0,\t\t\t\t\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  0, \t\t\t\t\t/* todo_flags_finish */\n+  0\t\t\t\t\t/* letter */\n+};"}]}