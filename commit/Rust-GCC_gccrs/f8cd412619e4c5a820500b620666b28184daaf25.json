{"sha": "f8cd412619e4c5a820500b620666b28184daaf25", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjhjZDQxMjYxOWU0YzVhODIwNTAwYjYyMDY2NmIyODE4NGRhYWYyNQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2000-05-09T11:07:48Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2000-05-09T11:07:48Z"}, "message": "alias.c (nonlocal_reference_p): Minor reformatting.\n\n\t* alias.c (nonlocal_reference_p): Minor reformatting.\n\t* reload.c (find_equiv_reg): Simplify logic for\n\tCALL_INSN_FUNCTION_USAGE since can't have SUBREG or pseudos and\n\tsome some reformatting.\n\t* reload1.c (reload_combine): Don't assume everything in\n\tCALL_INSN_FUNCTION_USAGE is a REG and clean up code a bit.\n\nFrom-SVN: r33797", "tree": {"sha": "7fff4281075af411c0bb40feb51d8ea6d8072bc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7fff4281075af411c0bb40feb51d8ea6d8072bc2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8cd412619e4c5a820500b620666b28184daaf25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8cd412619e4c5a820500b620666b28184daaf25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8cd412619e4c5a820500b620666b28184daaf25", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8cd412619e4c5a820500b620666b28184daaf25/comments", "author": null, "committer": null, "parents": [{"sha": "cf7637a0838398cba4afa7e4eb68bcb587222d2d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf7637a0838398cba4afa7e4eb68bcb587222d2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf7637a0838398cba4afa7e4eb68bcb587222d2d"}], "stats": {"total": 180, "additions": 100, "deletions": 80}, "files": [{"sha": "45e9446bfd71357d56c502b36deb82d0baf293a8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cd412619e4c5a820500b620666b28184daaf25/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cd412619e4c5a820500b620666b28184daaf25/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f8cd412619e4c5a820500b620666b28184daaf25", "patch": "@@ -1,3 +1,12 @@\n+Tue May  9 06:30:20 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* alias.c (nonlocal_reference_p): Minor reformatting.\n+\t* reload.c (find_equiv_reg): Simplify logic for\n+\tCALL_INSN_FUNCTION_USAGE since can't have SUBREG or pseudos and\n+\tsome some reformatting.\n+\t* reload1.c (reload_combine): Don't assume everything in\n+\tCALL_INSN_FUNCTION_USAGE is a REG and clean up code a bit.\n+\n 2000-05-08  Richard Henderson  <rth@cygnus.com>\n \n \t* final.c (current_insn_predicate): New."}, {"sha": "0aab3625edbd490cfea399d5cf737538daffda94", "filename": "gcc/alias.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cd412619e4c5a820500b620666b28184daaf25/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cd412619e4c5a820500b620666b28184daaf25/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=f8cd412619e4c5a820500b620666b28184daaf25", "patch": "@@ -1427,7 +1427,8 @@ nonlocal_reference_p (x)\n       if (code == CALL_INSN && CONST_CALL_P (x))\n         {\n \t  x = CALL_INSN_FUNCTION_USAGE (x);\n-\t  if (!x) return 0;\n+\t  if (x == 0)\n+\t    return 0;\n         }\n       else\n         x = PATTERN (x);"}, {"sha": "e1f58387a0f15182bd7c531557d7ba6613919eff", "filename": "gcc/reload.c", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cd412619e4c5a820500b620666b28184daaf25/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cd412619e4c5a820500b620666b28184daaf25/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=f8cd412619e4c5a820500b620666b28184daaf25", "patch": "@@ -6300,30 +6300,25 @@ find_equiv_reg (goal, insn, class, other, reload_reg_p, goalreg, mode)\n \t\t  if (GET_CODE (pat) == CLOBBER)\n \t\t    {\n \t\t      register rtx dest = SET_DEST (pat);\n-\t\t      while (GET_CODE (dest) == SUBREG\n-\t\t\t     || GET_CODE (dest) == ZERO_EXTRACT\n-\t\t\t     || GET_CODE (dest) == SIGN_EXTRACT\n-\t\t\t     || GET_CODE (dest) == STRICT_LOW_PART)\n-\t\t\tdest = XEXP (dest, 0);\n+\n \t\t      if (GET_CODE (dest) == REG)\n \t\t\t{\n \t\t\t  register int xregno = REGNO (dest);\n-\t\t\t  int xnregs;\n-\t\t\t  if (REGNO (dest) < FIRST_PSEUDO_REGISTER)\n-\t\t\t    xnregs = HARD_REGNO_NREGS (xregno, GET_MODE (dest));\n-\t\t\t  else\n-\t\t\t    xnregs = 1;\n+\t\t\t  int xnregs\n+\t\t\t    = HARD_REGNO_NREGS (xregno, GET_MODE (dest));\n+\n \t\t\t  if (xregno < regno + nregs\n \t\t\t      && xregno + xnregs > regno)\n \t\t\t    return 0;\n-\t\t\t  if (xregno < valueno + valuenregs\n+\t\t\t  else if (xregno < valueno + valuenregs\n \t\t\t      && xregno + xnregs > valueno)\n \t\t\t    return 0;\n-\t\t\t  if (goal_mem_addr_varies\n-\t\t\t      && reg_overlap_mentioned_for_reload_p (dest,\n+\t\t\t  else if (goal_mem_addr_varies\n+\t\t\t\t   && reg_overlap_mentioned_for_reload_p (dest,\n \t\t\t\t\t\t\t\t     goal))\n \t\t\t    return 0;\n \t\t\t}\n+\n \t\t      else if (goal_mem && GET_CODE (dest) == MEM\n \t\t\t       && ! push_operand (dest, GET_MODE (dest)))\n \t\t\treturn 0;"}, {"sha": "4d657be69bad910267ee7d02ce638e45986f3f71", "filename": "gcc/reload1.c", "status": "modified", "additions": 81, "deletions": 66, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cd412619e4c5a820500b620666b28184daaf25/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cd412619e4c5a820500b620666b28184daaf25/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=f8cd412619e4c5a820500b620666b28184daaf25", "patch": "@@ -8377,6 +8377,7 @@ reload_combine ()\n   rtx insn, set;\n   int first_index_reg = 1, last_index_reg = 0;\n   int i;\n+  unsigned int r;\n   int last_label_ruid;\n   int min_labelno, n_labels;\n   HARD_REG_SET ever_live_at_start, *label_live;\n@@ -8389,15 +8390,14 @@ reload_combine ()\n \n   /* To avoid wasting too much time later searching for an index register,\n      determine the minimum and maximum index register numbers.  */\n-  for (i = FIRST_PSEUDO_REGISTER - 1; i >= 0; --i)\n-    {\n-      if (TEST_HARD_REG_BIT (reg_class_contents[INDEX_REG_CLASS], i))\n-\t{\n-\t  if (! last_index_reg)\n-\t    last_index_reg = i;\n-\t  first_index_reg = i;\n-\t}\n-    }\n+  for (r = 0; r < FIRST_PSEUDO_REGISTER; r++)\n+    if (TEST_HARD_REG_BIT (reg_class_contents[INDEX_REG_CLASS], r))\n+      {\n+\tif (! last_index_reg)\n+\t  last_index_reg = r;\n+\tfirst_index_reg = i;\n+      }\n+\n   /* If no index register is available, we can quit now.  */\n   if (first_index_reg > last_index_reg)\n     return;\n@@ -8410,29 +8410,32 @@ reload_combine ()\n   n_labels = max_label_num () - min_labelno;\n   label_live = (HARD_REG_SET *) xmalloc (n_labels * sizeof (HARD_REG_SET));\n   CLEAR_HARD_REG_SET (ever_live_at_start);\n+\n   for (i = n_basic_blocks - 1; i >= 0; i--)\n     {\n       insn = BLOCK_HEAD (i);\n       if (GET_CODE (insn) == CODE_LABEL)\n \t{\n \t  HARD_REG_SET live;\n \n-\t  REG_SET_TO_HARD_REG_SET (live, BASIC_BLOCK (i)->global_live_at_start);\n-\t  compute_use_by_pseudos (&live, BASIC_BLOCK (i)->global_live_at_start);\n+\t  REG_SET_TO_HARD_REG_SET (live,\n+\t\t\t\t   BASIC_BLOCK (i)->global_live_at_start);\n+\t  compute_use_by_pseudos (&live,\n+\t\t\t\t  BASIC_BLOCK (i)->global_live_at_start);\n \t  COPY_HARD_REG_SET (LABEL_LIVE (insn), live);\n \t  IOR_HARD_REG_SET (ever_live_at_start, live);\n \t}\n     }\n \n   /* Initialize last_label_ruid, reload_combine_ruid and reg_state.  */\n   last_label_ruid = reload_combine_ruid = 0;\n-  for (i = FIRST_PSEUDO_REGISTER - 1; i >= 0; --i)\n+  for (r = 0; r < FIRST_PSEUDO_REGISTER; r++)\n     {\n-      reg_state[i].store_ruid = reload_combine_ruid;\n-      if (fixed_regs[i])\n-\treg_state[i].use_index = -1;\n+      reg_state[r].store_ruid = reload_combine_ruid;\n+      if (fixed_regs[r])\n+\treg_state[r].use_index = -1;\n       else\n-\treg_state[i].use_index = RELOAD_COMBINE_MAX_USES;\n+\treg_state[r].use_index = RELOAD_COMBINE_MAX_USES;\n     }\n \n   for (insn = get_last_insn (); insn; insn = PREV_INSN (insn))\n@@ -8444,14 +8447,14 @@ reload_combine ()\n \t is and then later disable any optimization that would cross it.  */\n       if (GET_CODE (insn) == CODE_LABEL)\n \tlast_label_ruid = reload_combine_ruid;\n-      if (GET_CODE (insn) == BARRIER)\n-\t{\n-\t  for (i = FIRST_PSEUDO_REGISTER - 1; i >= 0; --i)\n-\t    if (! fixed_regs[i])\n-\t      reg_state[i].use_index = RELOAD_COMBINE_MAX_USES;\n-\t}\n+      else if (GET_CODE (insn) == BARRIER)\n+\tfor (r = 0; r < FIRST_PSEUDO_REGISTER; r++)\n+\t  if (! fixed_regs[r])\n+\t      reg_state[r].use_index = RELOAD_COMBINE_MAX_USES;\n+\n       if (GET_RTX_CLASS (GET_CODE (insn)) != 'i')\n \tcontinue;\n+\n       reload_combine_ruid++;\n \n       /* Look for (set (REGX) (CONST_INT))\n@@ -8481,7 +8484,7 @@ reload_combine ()\n \t  rtx base = XEXP (plus, 1);\n \t  rtx prev = prev_nonnote_insn (insn);\n \t  rtx prev_set = prev ? single_set (prev) : NULL_RTX;\n-\t  int regno = REGNO (reg);\n+\t  unsigned int regno = REGNO (reg);\n \t  rtx const_reg = NULL_RTX;\n \t  rtx reg_sum = NULL_RTX;\n \n@@ -8508,31 +8511,35 @@ reload_combine ()\n \t\t two registers.  */\n \t      for (i = first_index_reg; i <= last_index_reg; i++)\n \t\t{\n-\t\t  if (TEST_HARD_REG_BIT (reg_class_contents[INDEX_REG_CLASS], i)\n+\t\t  if (TEST_HARD_REG_BIT (reg_class_contents[INDEX_REG_CLASS],\n+\t\t\t\t\t i)\n \t\t      && reg_state[i].use_index == RELOAD_COMBINE_MAX_USES\n \t\t      && reg_state[i].store_ruid <= reg_state[regno].use_ruid\n \t\t      && HARD_REGNO_NREGS (i, GET_MODE (reg)) == 1)\n \t\t    {\n \t\t      rtx index_reg = gen_rtx_REG (GET_MODE (reg), i);\n+\n \t\t      const_reg = index_reg;\n \t\t      reg_sum = gen_rtx_PLUS (GET_MODE (reg), index_reg, base);\n \t\t      break;\n \t\t    }\n \t\t}\n \t    }\n+\n \t  /* Check that PREV_SET is indeed (set (REGX) (CONST_INT)) and that\n \t     (REGY), i.e. BASE, is not clobbered before the last use we'll\n \t     create.  */\n-\t  if (prev_set\n+\t  if (prev_set != 0\n \t      && GET_CODE (SET_SRC (prev_set)) == CONST_INT\n \t      && rtx_equal_p (SET_DEST (prev_set), reg)\n \t      && reg_state[regno].use_index >= 0\n-\t      && reg_state[REGNO (base)].store_ruid <= reg_state[regno].use_ruid\n-\t      && reg_sum)\n+\t      && (reg_state[REGNO (base)].store_ruid\n+\t\t  <= reg_state[regno].use_ruid)\n+\t      && reg_sum != 0)\n \t    {\n \t      int i;\n \n-\t      /* Change destination register and - if necessary - the\n+\t      /* Change destination register and, if necessary, the\n \t\t constant value in PREV, the constant loading instruction.  */\n \t      validate_change (prev, &SET_DEST (prev_set), const_reg, 1);\n \t      if (reg_state[regno].offset != const0_rtx)\n@@ -8541,6 +8548,7 @@ reload_combine ()\n \t\t\t\t GEN_INT (INTVAL (SET_SRC (prev_set))\n \t\t\t\t\t  + INTVAL (reg_state[regno].offset)),\n \t\t\t\t 1);\n+\n \t      /* Now for every use of REG that we have recorded, replace REG\n \t\t with REG_SUM.  */\n \t      for (i = reg_state[regno].use_index;\n@@ -8559,67 +8567,72 @@ reload_combine ()\n \t\t  NOTE_SOURCE_FILE (insn) = 0;\n \n \t\t  if (reg_state[regno].offset != const0_rtx)\n-\t\t    {\n-\t\t      /* Previous REG_EQUIV / REG_EQUAL notes for PREV\n-\t\t\t are now invalid.  */\n-\t\t      for (np = &REG_NOTES (prev); *np; )\n-\t\t\t{\n-\t\t\t  if (REG_NOTE_KIND (*np) == REG_EQUAL\n-\t\t\t      || REG_NOTE_KIND (*np) == REG_EQUIV)\n-\t\t\t    *np = XEXP (*np, 1);\n-\t\t\t  else\n-\t\t\t    np = &XEXP (*np, 1);\n-\t\t\t}\n-\t\t    }\n+\t\t    /* Previous REG_EQUIV / REG_EQUAL notes for PREV\n+\t\t       are now invalid.  */\n+\t\t    for (np = &REG_NOTES (prev); *np; )\n+\t\t      {\n+\t\t\tif (REG_NOTE_KIND (*np) == REG_EQUAL\n+\t\t\t    || REG_NOTE_KIND (*np) == REG_EQUIV)\n+\t\t\t  *np = XEXP (*np, 1);\n+\t\t\telse\n+\t\t\t  np = &XEXP (*np, 1);\n+\t\t      }\n+\n \t\t  reg_state[regno].use_index = RELOAD_COMBINE_MAX_USES;\n-\t\t  reg_state[REGNO (const_reg)].store_ruid = reload_combine_ruid;\n+\t\t  reg_state[REGNO (const_reg)].store_ruid\n+\t\t    = reload_combine_ruid;\n \t\t  continue;\n \t\t}\n \t    }\n \t}\n-      note_stores (PATTERN (insn), reload_combine_note_store, NULL);\n+\n+  note_stores (PATTERN (insn), reload_combine_note_store, NULL);\n+\n       if (GET_CODE (insn) == CALL_INSN)\n \t{\n \t  rtx link;\n \n-\t  for (i = FIRST_PSEUDO_REGISTER - 1; i >= 0; --i)\n-\t    {\n-\t      if (call_used_regs[i])\n-\t\t{\n-\t\t  reg_state[i].use_index = RELOAD_COMBINE_MAX_USES;\n-\t\t  reg_state[i].store_ruid = reload_combine_ruid;\n-\t\t}\n-\t    }\n+\t  for (r = 0; r < FIRST_PSEUDO_REGISTER; r++)\n+\t    if (call_used_regs[r])\n+\t      {\n+\t\treg_state[r].use_index = RELOAD_COMBINE_MAX_USES;\n+\t\treg_state[r].store_ruid = reload_combine_ruid;\n+\t      }\n+\n \t  for (link = CALL_INSN_FUNCTION_USAGE (insn); link;\n \t       link = XEXP (link, 1))\n-\t    {\n-\t      rtx use = XEXP (link, 0);\n-\t      int regno = REGNO (XEXP (use, 0));\n-\t      if (GET_CODE (use) == CLOBBER)\n-\t\t{\n-\t\t  reg_state[regno].use_index = RELOAD_COMBINE_MAX_USES;\n-\t\t  reg_state[regno].store_ruid = reload_combine_ruid;\n-\t\t}\n-\t      else\n-\t\treg_state[regno].use_index = -1;\n-\t    }\n+\t    if (GET_CODE (XEXP (XEXP (link, 0), 0)) == REG)\n+\t      {\n+\t\tunsigned int regno = REGNO (XEXP (XEXP (link, 0), 0));\n+\n+\t\tif (GET_CODE (XEXP (link, 0)) == CLOBBER)\n+\t\t  {\n+\t\t    reg_state[regno].use_index = RELOAD_COMBINE_MAX_USES;\n+\t\t    reg_state[regno].store_ruid = reload_combine_ruid;\n+\t\t  }\n+\t\telse\n+\t\t  reg_state[regno].use_index = -1;\n+\t      }\n \t}\n-      if (GET_CODE (insn) == JUMP_INSN && GET_CODE (PATTERN (insn)) != RETURN)\n+\n+      else if (GET_CODE (insn) == JUMP_INSN\n+\t       && GET_CODE (PATTERN (insn)) != RETURN)\n \t{\n \t  /* Non-spill registers might be used at the call destination in\n \t     some unknown fashion, so we have to mark the unknown use.  */\n \t  HARD_REG_SET *live;\n+\n \t  if ((condjump_p (insn) || condjump_in_parallel_p (insn))\n \t      && JUMP_LABEL (insn))\n \t    live = &LABEL_LIVE (JUMP_LABEL (insn));\n \t  else\n \t    live = &ever_live_at_start;\n+\n \t  for (i = FIRST_PSEUDO_REGISTER - 1; i >= 0; --i)\n-\t    {\n-\t      if (TEST_HARD_REG_BIT (*live, i))\n-\t\treg_state[i].use_index = -1;\n-\t    }\n+\t    if (TEST_HARD_REG_BIT (*live, i))\n+\t      reg_state[i].use_index = -1;\n \t}\n+\n       reload_combine_note_use (&PATTERN (insn), insn);\n       for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n \t{\n@@ -8633,12 +8646,14 @@ reload_combine ()\n \t    }\n \t}\n     }\n+\n   free (label_live);\n }\n \n /* Check if DST is a register or a subreg of a register; if it is,\n    update reg_state[regno].store_ruid and reg_state[regno].use_index\n    accordingly.  Called via note_stores from reload_combine.  */\n+\n static void\n reload_combine_note_store (dst, set, data)\n      rtx dst, set;"}]}