{"sha": "c0e5eb1602961b12e138911a6a61f0a84a3f42c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzBlNWViMTYwMjk2MWIxMmUxMzg5MTFhNmE2MWYwYTg0YTNmNDJjMg==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2001-10-16T22:00:32Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2001-10-16T22:00:32Z"}, "message": "javaprims.h: Updated class list.\n\n\t* gcj/javaprims.h: Updated class list.\n\t* java/util/Hashtable.java: Re-merged with Classpath.\n\nFrom-SVN: r46295", "tree": {"sha": "01a8a89afea6d03db8cad9c9e4480b37c2373867", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01a8a89afea6d03db8cad9c9e4480b37c2373867"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c0e5eb1602961b12e138911a6a61f0a84a3f42c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0e5eb1602961b12e138911a6a61f0a84a3f42c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0e5eb1602961b12e138911a6a61f0a84a3f42c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0e5eb1602961b12e138911a6a61f0a84a3f42c2/comments", "author": null, "committer": null, "parents": [{"sha": "dc8ad2989f80407b2ef1521756291a409079d615", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc8ad2989f80407b2ef1521756291a409079d615", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc8ad2989f80407b2ef1521756291a409079d615"}], "stats": {"total": 1017, "additions": 623, "deletions": 394}, "files": [{"sha": "e5aff7b2d8c1701b457dd51c748a8464f5f21016", "filename": "libjava/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0e5eb1602961b12e138911a6a61f0a84a3f42c2/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0e5eb1602961b12e138911a6a61f0a84a3f42c2/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=c0e5eb1602961b12e138911a6a61f0a84a3f42c2", "patch": "@@ -1,3 +1,8 @@\n+2001-10-16  Tom Tromey  <tromey@redhat.com>\n+\n+\t* gcj/javaprims.h: Updated class list.\n+\t* java/util/Hashtable.java: Re-merged with Classpath.\n+\n 2001-10-16  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>\n \n \t* name-finder.cc (_Jv_name_finder::lookup): Check for NULL dli_sname."}, {"sha": "1382e4a757e3d7e9a9c493d9fbfa3ebda91bf5fa", "filename": "libjava/gcj/javaprims.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0e5eb1602961b12e138911a6a61f0a84a3f42c2/libjava%2Fgcj%2Fjavaprims.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0e5eb1602961b12e138911a6a61f0a84a3f42c2/libjava%2Fgcj%2Fjavaprims.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2Fjavaprims.h?ref=c0e5eb1602961b12e138911a6a61f0a84a3f42c2", "patch": "@@ -279,16 +279,18 @@ extern \"Java\"\n       class EventObject;\n       class GregorianCalendar;\n       class HashMap;\n-      class HashMap$Entry;\n+      class HashMap$HashEntry;\n       class HashMap$HashIterator;\n       class HashSet;\n       class Hashtable;\n-      class Hashtable$Entry;\n       class Hashtable$Enumerator;\n+      class Hashtable$HashEntry;\n       class Hashtable$HashIterator;\n       class IdentityHashMap;\n       class IdentityHashMap$IdentityIterator;\n       class Iterator;\n+      class LinkedHashMap;\n+      class LinkedHashMap$LinkedHashEntry;\n       class LinkedList;\n       class LinkedList$Entry;\n       class LinkedList$LinkedListItr;\n@@ -298,6 +300,7 @@ extern \"Java\"\n       class Locale;\n       class Map;\n       class Map$Entry;\n+      class Map$Map;\n       class MissingResourceException;\n       class NoSuchElementException;\n       class Observable;\n@@ -306,6 +309,7 @@ extern \"Java\"\n       class PropertyPermission;\n       class PropertyResourceBundle;\n       class Random;\n+      class RandomAccess;\n       class ResourceBundle;\n       class Set;\n       class SimpleTimeZone;"}, {"sha": "2a90244a4d23a9279bdc32e10a9e2dc544d76cbd", "filename": "libjava/java/util/Hashtable.java", "status": "modified", "additions": 612, "deletions": 392, "changes": 1004, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0e5eb1602961b12e138911a6a61f0a84a3f42c2/libjava%2Fjava%2Futil%2FHashtable.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0e5eb1602961b12e138911a6a61f0a84a3f42c2/libjava%2Fjava%2Futil%2FHashtable.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FHashtable.java?ref=c0e5eb1602961b12e138911a6a61f0a84a3f42c2", "patch": "@@ -1,14 +1,14 @@\n /* Hashtable.java -- a class providing a basic hashtable data structure,\n    mapping Object --> Object\n-   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n GNU Classpath is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -37,85 +37,128 @@\n // code.\n \n /**\n- * a class which implements a Hashtable data structure\n+ * A class which implements a hashtable data structure.\n+ * <p>\n  *\n  * This implementation of Hashtable uses a hash-bucket approach. That is:\n  * linear probing and rehashing is avoided; instead, each hashed value maps\n  * to a simple linked-list which, in the best case, only has one node.\n  * Assuming a large enough table, low enough load factor, and / or well\n- * implemented hashCode() methods, Hashtable should provide O(1) \n+ * implemented hashCode() methods, Hashtable should provide O(1)\n  * insertion, deletion, and searching of keys.  Hashtable is O(n) in\n- * the worst case for all of these (if all keys has to the same bucket).\n+ * the worst case for all of these (if all keys hash to the same bucket).\n+ * <p>\n  *\n- * This is a JDK-1.2 compliant implementation of Hashtable.  As such, it \n+ * This is a JDK-1.2 compliant implementation of Hashtable.  As such, it\n  * belongs, partially, to the Collections framework (in that it implements\n- * Map).  For backwards compatibility, it inherits from the obsolete and \n+ * Map).  For backwards compatibility, it inherits from the obsolete and\n  * utterly useless Dictionary class.\n+ * <p>\n  *\n  * Being a hybrid of old and new, Hashtable has methods which provide redundant\n  * capability, but with subtle and even crucial differences.\n  * For example, one can iterate over various aspects of a Hashtable with\n  * either an Iterator (which is the JDK-1.2 way of doing things) or with an\n  * Enumeration.  The latter can end up in an undefined state if the Hashtable\n  * changes while the Enumeration is open.\n+ * <p>\n+ *\n+ * Unlike HashMap, Hashtable does not accept `null' as a key value. Also,\n+ * all accesses are synchronized: in a single thread environment, this is\n+ * expensive, but in a multi-thread environment, this saves you the effort\n+ * of extra synchronization.\n+ * <p>\n  *\n- * Unlike HashMap, Hashtable does not accept `null' as a key value.\n+ * The iterators are <i>fail-fast</i>, meaning that any structural\n+ * modification, except for <code>remove()</code> called on the iterator\n+ * itself, cause the iterator to throw a\n+ * <code>ConcurrentModificationException</code> rather than exhibit\n+ * non-deterministic behavior.\n  *\n- * @author      Jon Zeppieri\n- * @author\tWarren Levy\n- * @author      Bryce McKinlay\n+ * @author Jon Zeppieri\n+ * @author Warren Levy\n+ * @author Bryce McKinlay\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @see HashMap\n+ * @see TreeMap\n+ * @see IdentityHashMap\n+ * @see LinkedHashMap\n+ * @since 1.0\n  */\n-public class Hashtable extends Dictionary \n+public class Hashtable extends Dictionary\n   implements Map, Cloneable, Serializable\n {\n-  /** Default number of buckets. This is the value the JDK 1.3 uses. Some \n-    * early documentation specified this value as 101. That is incorrect. */\n-  private static final int DEFAULT_CAPACITY = 11;  \n-  /** The defaulty load factor; this is explicitly specified by the spec. */\n+  /** Default number of buckets. This is the value the JDK 1.3 uses. Some\n+   * early documentation specified this value as 101. That is incorrect.\n+   */\n+  private static final int DEFAULT_CAPACITY = 11;\n+\n+  /**\n+   * The default load factor; this is explicitly specified by the spec.\n+   */\n   private static final float DEFAULT_LOAD_FACTOR = 0.75f;\n \n+  /**\n+   * Compatible with JDK 1.0+.\n+   */\n   private static final long serialVersionUID = 1421746759512286392L;\n \n-  /** \n-   * The rounded product of the capacity and the load factor; when the number \n-   * of elements exceeds the threshold, the Hashtable calls <pre>rehash()</pre>.\n+  /**\n+   * The rounded product of the capacity and the load factor; when the number\n+   * of elements exceeds the threshold, the Hashtable calls\n+   * <pre>rehash()</pre>.\n    * @serial\n    */\n   int threshold;\n \n-  /** Load factor of this Hashtable:  used in computing the threshold.\n+  /**\n+   * Load factor of this Hashtable:  used in computing the threshold.\n    * @serial\n    */\n-  float loadFactor = DEFAULT_LOAD_FACTOR;\n+  final float loadFactor;\n \n-  /** \n-   * Array containing the actual key-value mappings\n+  /**\n+   * Array containing the actual key-value mappings.\n    */\n-  transient Entry[] buckets;\n+  transient HashEntry[] buckets;\n \n-  /** \n-   * counts the number of modifications this Hashtable has undergone, used \n-   * by Iterators to know when to throw ConcurrentModificationExceptions. \n+  /**\n+   * Counts the number of modifications this Hashtable has undergone, used\n+   * by Iterators to know when to throw ConcurrentModificationExceptions.\n    */\n   transient int modCount;\n \n-  /** the size of this Hashtable:  denotes the number of key-value pairs */\n+  /**\n+   * The size of this Hashtable:  denotes the number of key-value pairs.\n+   */\n   transient int size;\n \n   /**\n    * Class to represent an entry in the hash table. Holds a single key-value\n    * pair. A Hashtable Entry is identical to a HashMap Entry, except that\n-   * `null' is not allowed for keys and values. \n+   * `null' is not allowed for keys and values.\n    */\n-  static class Entry extends BasicMapEntry\n+  static class HashEntry extends BasicMapEntry\n   {\n-    Entry next;\n-      \n-    Entry(Object key, Object value)\n+    /** The next entry in the linked list. */\n+    HashEntry next;\n+\n+    /**\n+     * Simple constructor.\n+     * @param key the key, already guaranteed non-null\n+     * @param value the value, already guaranteed non-null\n+     */\n+    HashEntry(Object key, Object value)\n     {\n       super(key, value);\n     }\n \n+    /**\n+     * Resets the value.\n+     * @param newValue the new value\n+     * @return the prior value\n+     * @throws NullPointerException if <code>newVal</code> is null\n+     */\n     public final Object setValue(Object newVal)\n     {\n       if (newVal == null)\n@@ -125,7 +168,7 @@ public final Object setValue(Object newVal)\n   }\n \n   /**\n-   * construct a new Hashtable with the default capacity (11) and the default\n+   * Construct a new Hashtable with the default capacity (11) and the default\n    * load factor (0.75).\n    */\n   public Hashtable()\n@@ -134,271 +177,327 @@ public Hashtable()\n   }\n \n   /**\n-   * construct a new Hashtable from the given Map\n-   * \n-   * every element in Map t will be put into this new Hashtable\n+   * Construct a new Hashtable from the given Map, with initial capacity\n+   * the greater of the size of <code>m</code> or the default of 11.\n+   * <p>\n    *\n-   * @param     t        a Map whose key / value pairs will be put into\n-   *                     the new Hashtable.  <b>NOTE: key / value pairs\n-   *                     are not cloned in this constructor</b>\n+   * Every element in Map m will be put into this new Hashtable.\n+   *\n+   * @param m a Map whose key / value pairs will be put into\n+   *          the new Hashtable.  <b>NOTE: key / value pairs\n+   *          are not cloned in this constructor.</b>\n+   * @throws NullPointerException if m is null, or if m contains a mapping\n+   *         to or from `null'.\n+   * @since 1.2\n    */\n   public Hashtable(Map m)\n   {\n-    int size = Math.max(m.size() * 2, DEFAULT_CAPACITY);\n-    buckets = new Entry[size];\n-    threshold = (int) (size * loadFactor);\n+    this(Math.max(m.size() * 2, DEFAULT_CAPACITY), DEFAULT_LOAD_FACTOR);\n     putAll(m);\n   }\n \n   /**\n-   * construct a new Hashtable with a specific inital capacity \n-   *\n-   * @param   initialCapacity     the initial capacity of this Hashtable (>=0)\n+   * Construct a new Hashtable with a specific inital capacity and\n+   * default load factor of 0.75.\n    *\n-   * @throws   IllegalArgumentException    if (initialCapacity < 0)\n+   * @param initialCapacity the initial capacity of this Hashtable (>=0)\n+   * @throws IllegalArgumentException if (initialCapacity < 0)\n    */\n-  public Hashtable(int initialCapacity) throws IllegalArgumentException\n+  public Hashtable(int initialCapacity)\n   {\n     this(initialCapacity, DEFAULT_LOAD_FACTOR);\n   }\n \n   /**\n-   * construct a new Hashtable with a specific inital capacity and load factor\n+   * Construct a new Hashtable with a specific initial capacity and\n+   * load factor.\n    *\n-   * @param   initialCapacity  the initial capacity (>=0)\n-   * @param   loadFactor       the load factor\n-   * \n-   * @throws   IllegalArgumentException    if (initialCapacity < 0) ||\n-   *                                          (initialLoadFactor <= 0.0)\n+   * @param initialCapacity the initial capacity (>=0)\n+   * @param loadFactor the load factor (>0, not NaN)\n+   * @throws IllegalArgumentException if (initialCapacity < 0) ||\n+   *                                     ! (loadFactor > 0.0)\n    */\n   public Hashtable(int initialCapacity, float loadFactor)\n-    throws IllegalArgumentException\n   {\n     if (initialCapacity < 0)\n-      throw new IllegalArgumentException(\"Illegal Initial Capacity: \" \n-      \t\t\t\t\t + initialCapacity);    \n-    if (loadFactor <= 0)\n-      throw new IllegalArgumentException(\"Illegal Load Factor: \" + loadFactor);\n-    \n+      throw new IllegalArgumentException(\"Illegal Capacity: \"\n+                                         + initialCapacity);\n+    if (! (loadFactor > 0)) // check for NaN too\n+      throw new IllegalArgumentException(\"Illegal Load: \" + loadFactor);\n+\n     if (initialCapacity == 0)\n-      initialCapacity = 1;    \n-    buckets = new Entry[initialCapacity];\n+      initialCapacity = 1;\n+    buckets = new HashEntry[initialCapacity];\n     this.loadFactor = loadFactor;\n-    this.threshold = (int) (initialCapacity * loadFactor);\n+    threshold = (int) (initialCapacity * loadFactor);\n   }\n \n-  /** Returns the number of key-value mappings currently in this Map */\n-  public int size()\n+  /**\n+   * Returns the number of key-value mappings currently in this hashtable.\n+   * @return the size\n+   */\n+  public synchronized int size()\n   {\n     return size;\n   }\n \n-  /** returns true if there are no key-value mappings currently in this Map */\n-  public boolean isEmpty()\n+  /**\n+   * Returns true if there are no key-value mappings currently in this table.\n+   * @return <code>size() == 0</code>\n+   */\n+  public synchronized boolean isEmpty()\n   {\n     return size == 0;\n   }\n \n+  /**\n+   * Return an enumeration of the keys of this table.\n+   * @return the keys\n+   * @see #elements()\n+   * @see #keySet()\n+   */\n   public synchronized Enumeration keys()\n   {\n     return new Enumerator(Enumerator.KEYS);\n   }\n-  \n+\n+  /**\n+   * Return an enumeration of the values of this table.\n+   * @return the values\n+   * @see #keys()\n+   * @see #values()\n+   */\n   public synchronized Enumeration elements()\n   {\n     return new Enumerator(Enumerator.VALUES);\n   }\n \n   /**\n-   * returns true if this Hashtable contains a value <pre>o</pre>,\n-   * such that <pre>o.equals(value)</pre>.\n+   * Returns true if this Hashtable contains a value <pre>o</pre>,\n+   * such that <pre>o.equals(value)</pre>.  This is the same as\n+   * <code>containsValue()</code>, and is O(n).\n+   * <p>\n    *\n    * Note: this is one of the <i>old</i> Hashtable methods which does\n    * not like null values; it throws NullPointerException if the\n    * supplied parameter is null.\n    *\n-   * @param     value        the value to search for in this Hashtable\n-   *\n-   * @throws NullPointerException if <pre>value</pre> is null \n+   * @param value the value to search for in this Hashtable\n+   * @return true if at least one key maps to the value\n+   * @throws NullPointerException if <pre>value</pre> is null\n+   * @see #containsValue(Object)\n+   * @see #containsKey(Object)\n    */\n   public synchronized boolean contains(Object value)\n   {\n-    for (int i = 0; i < buckets.length; i++)\n+    // Check if value is null in case Hashtable is empty.\n+    if (value == null)\n+      throw new NullPointerException();\n+\n+    for (int i = buckets.length - 1; i >= 0; i--)\n       {\n-\tEntry e = buckets[i];\n-\twhile (e != null)\n-\t  {\n-\t    if (value.equals(e.value))\n-\t      return true;\n-\t    e = e.next;\n-\t  }\n+        HashEntry e = buckets[i];\n+        while (e != null)\n+          {\n+            if (value.equals(e.value))\n+              return true;\n+            e = e.next;\n+          }\n       }\n     return false;\n   }\n \n   /**\n-   * returns true if this Hashtable contains a value <pre>o</pre>, such that\n-   * <pre>o.equals(value)</pre>.\n+   * Returns true if this Hashtable contains a value <pre>o</pre>, such that\n+   * <pre>o.equals(value)</pre>. This is the new API for the old\n+   * <code>contains()</code>.\n    *\n-   * @param      value       the value to search for in this Hashtable\n-   *\n-   * @throws NullPointerException if <pre>value</pre> is null \n+   * @param value the value to search for in this Hashtable\n+   * @return true if at least one key maps to the value\n+   * @throws NullPointerException if <pre>value</pre> is null\n+   * @see #contains(Object)\n+   * @see #containsKey(Object)\n+   * @since 1.2\n    */\n   public boolean containsValue(Object value)\n   {\n     return contains(value);\n   }\n \n-  /** \n-   * returns true if the supplied object equals (<pre>equals()</pre>) a key\n-   * in this Hashtable \n+  /**\n+   * Returns true if the supplied object <pre>equals()</pre> a key\n+   * in this Hashtable.\n    *\n-   * @param       key        the key to search for in this Hashtable\n+   * @param key the key to search for in this Hashtable\n+   * @return true if the key is in the table\n+   * @throws NullPointerException if key is null\n+   * @see #containsValue(Object)\n    */\n   public synchronized boolean containsKey(Object key)\n   {\n     int idx = hash(key);\n-    Entry e = buckets[idx];\n+    HashEntry e = buckets[idx];\n     while (e != null)\n       {\n         if (key.equals(e.key))\n-\t  return true;\n-\te = e.next;\n+          return true;\n+        e = e.next;\n       }\n     return false;\n   }\n \n   /**\n-   * return the value in this Hashtable associated with the supplied key, or <pre>null</pre>\n-   * if the key maps to nothing\n+   * Return the value in this Hashtable associated with the supplied key,\n+   * or <pre>null</pre> if the key maps to nothing.\n    *\n-   * @param     key      the key for which to fetch an associated value\n+   * @param key the key for which to fetch an associated value\n+   * @return what the key maps to, if present\n+   * @throws NullPointerException if key is null\n+   * @see #put(Object, Object)\n+   * @see #containsKey(Object)\n    */\n   public synchronized Object get(Object key)\n   {\n     int idx = hash(key);\n-    Entry e = buckets[idx];\n+    HashEntry e = buckets[idx];\n     while (e != null)\n       {\n         if (key.equals(e.key))\n-\t  return e.value;\n-\te = e.next;\n+          return e.value;\n+        e = e.next;\n       }\n     return null;\n   }\n \n   /**\n-   * puts the supplied value into the Map, mapped by the supplied key\n+   * Puts the supplied value into the Map, mapped by the supplied key.\n+   * Neither parameter may be null.  The value may be retrieved by any\n+   * object which <code>equals()</code> this key.\n    *\n-   * @param       key        the key used to locate the value\n-   * @param       value      the value to be stored in the table\n+   * @param key the key used to locate the value\n+   * @param value the value to be stored in the table\n+   * @return the prior mapping of the key, or null if there was none\n+   * @throws NullPointerException if key or value is null\n+   * @see #get(Object)\n+   * @see Object#equals(Object)\n    */\n   public synchronized Object put(Object key, Object value)\n   {\n     modCount++;\n     int idx = hash(key);\n-    Entry e = buckets[idx];\n-    \n-    // Hashtable does not accept null values. This method doesn't dereference \n-    // `value' anywhere, so check for it explicitly.\n+    HashEntry e = buckets[idx];\n+\n+    // Check if value is null since it is not permitted.\n     if (value == null)\n       throw new NullPointerException();\n \n     while (e != null)\n       {\n         if (key.equals(e.key))\n-\t  {\n-\t    Object r = e.value;\n-\t    e.value = value;\n-\t    return r;\n-\t  }\n-\telse\n-\t  {\n-\t    e = e.next;\n-\t  }\n+          {\n+            // Bypass e.setValue, since we already know value is non-null.\n+            Object r = e.value;\n+            e.value = value;\n+            return r;\n+          }\n+        else\n+          {\n+            e = e.next;\n+          }\n       }\n-    \n+\n     // At this point, we know we need to add a new entry.\n     if (++size > threshold)\n       {\n-\trehash();\n-\t// Need a new hash value to suit the bigger table.\n-\tidx = hash(key);\n+        rehash();\n+        // Need a new hash value to suit the bigger table.\n+        idx = hash(key);\n       }\n \n-    e = new Entry(key, value);\n-    \n+    e = new HashEntry(key, value);\n+\n     e.next = buckets[idx];\n     buckets[idx] = e;\n-    \n+\n     return null;\n   }\n \n   /**\n-   * removes from the table and returns the value which is mapped by the \n-   * supplied key; if the key maps to nothing, then the table remains \n-   * unchanged, and <pre>null</pre> is returned\n+   * Removes from the table and returns the value which is mapped by the\n+   * supplied key. If the key maps to nothing, then the table remains\n+   * unchanged, and <pre>null</pre> is returned.\n    *\n-   * @param    key     the key used to locate the value to remove\n+   * @param key the key used to locate the value to remove\n+   * @return whatever the key mapped to, if present\n+   * @throws NullPointerException if key is null\n    */\n   public synchronized Object remove(Object key)\n   {\n     modCount++;\n     int idx = hash(key);\n-    Entry e = buckets[idx];\n-    Entry last = null;\n+    HashEntry e = buckets[idx];\n+    HashEntry last = null;\n \n     while (e != null)\n       {\n         if (key.equals(e.key))\n-\t  {\n-\t    if (last == null)\n-\t      buckets[idx] = e.next;\n-\t    else\n-\t      last.next = e.next;\n-\t    size--;\n-\t    return e.value;\n-\t  }\n-\tlast = e;\n-\te = e.next;\n+          {\n+            if (last == null)\n+              buckets[idx] = e.next;\n+            else\n+              last.next = e.next;\n+            size--;\n+            return e.value;\n+          }\n+        last = e;\n+        e = e.next;\n       }\n     return null;\n   }\n \n+  /**\n+   * Copies all elements of the given map into this hashtable.  However, no\n+   * mapping can contain null as key or value.  If this table already has\n+   * a mapping for a key, the new mapping replaces the current one.\n+   *\n+   * @param m the map to be hashed into this\n+   * @throws NullPointerException if m is null, or contains null keys or values\n+   */\n   public synchronized void putAll(Map m)\n   {\n-    int msize = m.size();\n     Iterator itr = m.entrySet().iterator();\n-    \n-    for (int i=0; i < msize; i++)\n+\n+    for (int msize = m.size(); msize > 0; msize--)\n       {\n         Map.Entry e = (Map.Entry) itr.next();\n-\t// Optimize in case the Entry is one of our own.\n-\tif (e instanceof BasicMapEntry)\n-\t  {\n-\t    BasicMapEntry entry = (BasicMapEntry) e;\n-\t    put(entry.key, entry.value);\n-\t  }\n-\telse\n-\t  {\n+        // Optimize in case the Entry is one of our own.\n+        if (e instanceof BasicMapEntry)\n+          {\n+            BasicMapEntry entry = (BasicMapEntry) e;\n+            put(entry.key, entry.value);\n+          }\n+        else\n+          {\n             put(e.getKey(), e.getValue());\n-\t  }\n+          }\n       }\n   }\n-  \n+\n+  /**\n+   * Clears the hashtable so it has no keys.  This is O(1).\n+   */\n   public synchronized void clear()\n   {\n     modCount++;\n-    for (int i=0; i < buckets.length; i++)\n-      {\n-        buckets[i] = null;\n-      }\n+    Arrays.fill(buckets, null);\n     size = 0;\n   }\n \n-  /** \n-   * returns a shallow clone of this Hashtable (i.e. the Map itself is cloned, \n-   * but its contents are not)\n+  /**\n+   * Returns a shallow clone of this Hashtable. The Map itself is cloned,\n+   * but its contents are not.  This is O(n).\n+   *\n+   * @return the clone\n    */\n   public synchronized Object clone()\n   {\n@@ -409,63 +508,91 @@ public synchronized Object clone()\n       }\n     catch (CloneNotSupportedException x)\n       {\n+        // This is impossible.\n       }\n-    copy.buckets = new Entry[buckets.length];\n-    \n-    for (int i=0; i < buckets.length; i++)\n+    copy.buckets = new HashEntry[buckets.length];\n+\n+    for (int i = buckets.length - 1; i >= 0; i--)\n       {\n-        Entry e = buckets[i];\n-\tEntry last = null;\n-\t\n-\twhile (e != null)\n-\t  {\n-\t    if (last == null)\n-\t      {\n-\t\tcopy.buckets[i] = new Entry(e.key, e.value);\n-\t\tlast = copy.buckets[i];\n+        HashEntry e = buckets[i];\n+        HashEntry last = null;\n+\n+        while (e != null)\n+          {\n+            if (last == null)\n+              {\n+                last = new HashEntry(e.key, e.value);\n+                copy.buckets[i] = last;\n               }\n-\t    else\t\t\n+            else\n               {\n-\t        last.next = new Entry(e.key, e.value);\n-\t\tlast = last.next;\n-\t      }\n-\t    e = e.next;\n-\t  }\n+                last.next = new HashEntry(e.key, e.value);\n+                last = last.next;\n+              }\n+            e = e.next;\n+          }\n       }\n     return copy;\n   }\n-  \n+\n+  /**\n+   * Converts this Hashtable to a String, surrounded by braces (<pre>'{'</pre>\n+   * and <pre>'}'</pre>), key/value pairs listed with an equals sign between,\n+   * (<pre>'='</pre>), and pairs separated by comma and space\n+   * (<pre>\", \"</pre>).\n+   * <p>\n+   *\n+   * NOTE: if the <code>toString()</code> method of any key or value\n+   * throws an exception, this will fail for the same reason.\n+   *\n+   * @return the string representation\n+   */\n   public synchronized String toString()\n   {\n-    Iterator entries = entrySet().iterator();\n+    // Since we are already synchronized, and entrySet().iterator()\n+    // would repeatedly re-lock/release the monitor, we directly use the\n+    // unsynchronized HashIterator instead.\n+    Iterator entries = new HashIterator(HashIterator.ENTRIES);\n     StringBuffer r = new StringBuffer(\"{\");\n-    for (int pos = 0; pos < size; pos++)\n+    for (int pos = size; pos > 0; pos--)\n       {\n         r.append(entries.next());\n-\tif (pos < size - 1)\n-\t  r.append(\", \");\n+        if (pos > 1)\n+          r.append(\", \");\n       }\n     r.append(\"}\");\n-    return r.toString();    \n+    return r.toString();\n   }\n \n-  /** returns a \"set view\" of this Hashtable's keys */\n+  /**\n+   * Returns a \"set view\" of this Hashtable's keys. The set is backed by\n+   * the hashtable, so changes in one show up in the other.  The set supports\n+   * element removal, but not element addition.  The set is properly\n+   * synchronized on the original hashtable.  The set will throw a\n+   * {@link NullPointerException} if null is passed to <code>contains</code>,\n+   * <code>remove</code>, or related methods.\n+   *\n+   * @return a set view of the keys\n+   * @see #values()\n+   * @see #entrySet()\n+   * @since 1.2\n+   */\n   public Set keySet()\n   {\n-    // Create a synchronized AbstractSet with custom implementations of those \n-    // methods that can be overriden easily and efficiently.\n+    // Create a synchronized AbstractSet with custom implementations of those\n+    // methods that can be overridden easily and efficiently.\n     Set r = new AbstractSet()\n     {\n       public int size()\n       {\n         return size;\n       }\n-      \n+\n       public Iterator iterator()\n       {\n         return new HashIterator(HashIterator.KEYS);\n       }\n-            \n+\n       public void clear()\n       {\n         Hashtable.this.clear();\n@@ -475,18 +602,33 @@ public boolean contains(Object o)\n       {\n         return Hashtable.this.containsKey(o);\n       }\n-      \n+\n       public boolean remove(Object o)\n       {\n         return (Hashtable.this.remove(o) != null);\n       }\n     };\n \n-    return Collections.synchronizedSet(r);\n+    // We must specify the correct object to synchronize upon, hence the\n+    // use of a non-public API\n+    return new Collections.SynchronizedSet(this, r);\n   }\n-  \n-  /** Returns a \"collection view\" (or \"bag view\") of this Hashtable's values. \n-    */\n+\n+\n+  /**\n+   * Returns a \"collection view\" (or \"bag view\") of this Hashtable's values.\n+   * The collection is backed by the hashtable, so changes in one show up\n+   * in the other.  The collection supports element removal, but not element\n+   * addition.  The collection is properly synchronized on the original\n+   * hashtable.  The collection will throw a {@link NullPointerException}\n+   * if null is passed to <code>contains</code> or related methods, but not\n+   * if passed to <code>remove</code> or related methods.\n+   *\n+   * @return a bag view of the values\n+   * @see #keySet()\n+   * @see #entrySet()\n+   * @since 1.2\n+   */\n   public Collection values()\n   {\n     // We don't bother overriding many of the optional methods, as doing so\n@@ -497,289 +639,350 @@ public int size()\n       {\n         return size;\n       }\n-      \n+\n       public Iterator iterator()\n       {\n         return new HashIterator(HashIterator.VALUES);\n       }\n-      \n+\n       public void clear()\n       {\n         Hashtable.this.clear();\n       }\n+\n+      // Override this so that we check for null\n+      public boolean contains(Object o)\n+      {\n+        return Hashtable.this.contains(o);\n+      }\n     };\n-    \n-    return Collections.synchronizedCollection(r);\n+\n+    // We must specify the correct object to synchronize upon, hence the\n+    // use of a non-public API\n+    return new Collections.SynchronizedCollection(this, r);\n   }\n \n-  /** Returns a \"set view\" of this Hashtable's entries. */\n+  /**\n+   * Returns a \"set view\" of this Hashtable's entries. The set is backed by\n+   * the hashtable, so changes in one show up in the other.  The set supports\n+   * element removal, but not element addition.  The set is properly\n+   * synchronized on the original hashtable.  The set will throw a\n+   * {@link NullPointerException} if the Map.Entry passed to\n+   * <code>contains</code>, <code>remove</code>, or related methods returns\n+   * null for <code>getKey</code>, but not if the Map.Entry is null or\n+   * returns null for <code>getValue</code>.\n+   * <p>\n+   *\n+   * Note that the iterators for all three views, from keySet(), entrySet(),\n+   * and values(), traverse the hashtable in the same sequence.\n+   *\n+   * @return a set view of the entries\n+   * @see #keySet()\n+   * @see #values()\n+   * @see Map.Entry\n+   * @since 1.2\n+   */\n   public Set entrySet()\n   {\n-    // Create an AbstractSet with custom implementations of those methods that \n-    // can be overriden easily and efficiently.\n+    // Create an AbstractSet with custom implementations of those methods that\n+    // can be overridden easily and efficiently.\n     Set r = new AbstractSet()\n     {\n       public int size()\n       {\n         return size;\n       }\n-      \n+\n       public Iterator iterator()\n       {\n         return new HashIterator(HashIterator.ENTRIES);\n       }\n-            \n+\n       public void clear()\n       {\n         Hashtable.this.clear();\n       }\n \n       public boolean contains(Object o)\n       {\n-        if (!(o instanceof Map.Entry))\n-\t  return false;\n-\tMap.Entry me = (Map.Entry) o;\n-\tEntry e = getEntry(me);\n-\treturn (e != null);\n+        return getEntry(o) != null;\n       }\n-      \n+\n       public boolean remove(Object o)\n       {\n-        if (!(o instanceof Map.Entry))\n-\t  return false;\n-\tMap.Entry me = (Map.Entry) o;\n-\tEntry e = getEntry(me);\n-\tif (e != null)\n-\t  {\n-\t    Hashtable.this.remove(e.key);\n-\t    return true;\n-\t  }\n-\treturn false;\n+        HashEntry e = getEntry(o);\n+        if (e != null)\n+          {\n+            Hashtable.this.remove(e.key);\n+            return true;\n+          }\n+        return false;\n       }\n     };\n-    \n-    return Collections.synchronizedSet(r);\n+\n+    // We must specify the correct object to synchronize upon, hence the\n+    // use of a non-public API\n+    return new Collections.SynchronizedSet(this, r);\n   }\n-  \n-  /** returns true if this Hashtable equals the supplied Object <pre>o</pre>;\n-   * that is:\n+\n+  /**\n+   * Returns true if this Hashtable equals the supplied Object <pre>o</pre>.\n+   * As specified by Map, this is:\n    * <pre>\n-   * if (o instanceof Map)\n-   * and\n-   * o.keySet().equals(keySet())\n-   * and\n-   * for each key in o.keySet(), o.get(key).equals(get(key))\n-   *</pre>\n+   * (o instanceof Map) && entrySet().equals(((Map) o).entrySet());\n+   * </pre>\n+   *\n+   * @param o the object to compare to\n+   * @return true if o is an equal map\n+   * @since 1.2\n    */\n   public boolean equals(Object o)\n   {\n+    // no need to synchronize, entrySet().equals() does that\n     if (o == this)\n       return true;\n     if (!(o instanceof Map))\n       return false;\n \n-    Map m = (Map) o;\n-    Set s = m.entrySet();\n-    Iterator itr = entrySet().iterator();\n-\n-    if (m.size() != size)\n-      return false;\n-\n-    for (int pos = 0; pos < size; pos++)\n-      {\n-\tif (!s.contains(itr.next()))\n-\t  return false;\n-      }\n-    return true;    \n+    return entrySet().equals(((Map) o).entrySet());\n   }\n-  \n-  /** a Map's hashCode is the sum of the hashCodes of all of its\n-      Map.Entry objects */\n-  public int hashCode()\n+\n+  /**\n+   * Returns the hashCode for this Hashtable.  As specified by Map, this is\n+   * the sum of the hashCodes of all of its Map.Entry objects\n+   *\n+   * @return the sum of the hashcodes of the entries\n+   * @since 1.2\n+   */\n+  public synchronized int hashCode()\n   {\n+    // Since we are already synchronized, and entrySet().iterator()\n+    // would repeatedly re-lock/release the monitor, we directly use the\n+    // unsynchronized HashIterator instead.\n+    Iterator itr = new HashIterator(HashIterator.ENTRIES);\n     int hashcode = 0;\n-    Iterator itr = entrySet().iterator();\n-    for (int pos = 0; pos < size; pos++)\n-      {\n-\thashcode += itr.next().hashCode();\n-      }\n-    return hashcode;  \n+    for (int pos = size; pos > 0; pos--)\n+      hashcode += itr.next().hashCode();\n+\n+    return hashcode;\n   }\n-  \n-  /** Return an index in the buckets array for `key' based on its hashCode() */\n+\n+  /**\n+   * Helper method that returns an index in the buckets array for `key'\n+   * based on its hashCode().\n+   *\n+   * @param key the key\n+   * @return the bucket number\n+   * @throws NullPointerException if key is null\n+   */\n   private int hash(Object key)\n   {\n     return Math.abs(key.hashCode() % buckets.length);\n   }\n \n-  private Entry getEntry(Map.Entry me)\n+  /**\n+   * Helper method for entrySet(), which matches both key and value\n+   * simultaneously.\n+   *\n+   * @param o the entry to match\n+   * @return the matching entry, if found, or null\n+   * @throws NullPointerException if me.getKey() returns null\n+   * @see #entrySet()\n+   */\n+  private HashEntry getEntry(Object o)\n   {\n+    if (!(o instanceof Map.Entry))\n+      return null;\n+    Map.Entry me = (Map.Entry) o;\n     int idx = hash(me.getKey());\n-    Entry e = buckets[idx];\n+    HashEntry e = buckets[idx];\n     while (e != null)\n       {\n         if (e.equals(me))\n-\t  return e;\n-\te = e.next;\n+          return e;\n+        e = e.next;\n       }\n     return null;\n   }\n-  \n-  /** \n-   * increases the size of the Hashtable and rehashes all keys to new array \n-   * indices; this is called when the addition of a new value would cause \n-   * size() > threshold. Note that the existing Entry objects are reused in \n+\n+  /**\n+   * Increases the size of the Hashtable and rehashes all keys to new array\n+   * indices; this is called when the addition of a new value would cause\n+   * size() > threshold. Note that the existing Entry objects are reused in\n    * the new hash table.\n+   * <p>\n+   *\n+   * This is not specified, but the new size is twice the current size plus\n+   * one; this number is not always prime, unfortunately.\n    */\n   protected void rehash()\n   {\n-    Entry[] oldBuckets = buckets;\n-    \n+    HashEntry[] oldBuckets = buckets;\n+\n     int newcapacity = (buckets.length * 2) + 1;\n     threshold = (int) (newcapacity * loadFactor);\n-    buckets = new Entry[newcapacity];\n-    \n-    for (int i = 0; i < oldBuckets.length; i++)\n+    buckets = new HashEntry[newcapacity];\n+\n+    for (int i = oldBuckets.length - 1; i >= 0; i--)\n       {\n-\tEntry e = oldBuckets[i];\n+        HashEntry e = oldBuckets[i];\n         while (e != null)\n-\t  {\n-\t    int idx = hash(e.key);\n-\t    Entry dest = buckets[idx];\n-\n-\t    if (dest != null)\n-\t      {\n-\t\twhile (dest.next != null)\n-        \t  dest = dest.next;\n-\t\tdest.next = e;\n-\t      }\n-\t    else\n-\t      {\n-        \tbuckets[idx] = e;\n-\t      }\n-\n-\t    Entry next = e.next;\n-\t    e.next = null;\n-\t    e = next;\n-\t  }\n+          {\n+            int idx = hash(e.key);\n+            HashEntry dest = buckets[idx];\n+\n+            if (dest != null)\n+              {\n+                while (dest.next != null)\n+                  dest = dest.next;\n+                dest.next = e;\n+              }\n+            else\n+              {\n+                buckets[idx] = e;\n+              }\n+\n+            HashEntry next = e.next;\n+            e.next = null;\n+            e = next;\n+          }\n       }\n   }\n \n   /**\n    * Serializes this object to the given stream.\n-   * @serialdata the <i>capacity</i>(int) that is the length of the\n-   * bucket array, the <i>size</i>(int) of the hash map are emitted\n-   * first.  They are followed by size entries, each consisting of\n-   * a key (Object) and a value (Object).\n+   *\n+   * @param s the stream to write to\n+   * @throws IOException if the underlying stream fails\n+   * @serialData the <i>capacity</i>(int) that is the length of the\n+   *             bucket array, the <i>size</i>(int) of the hash map\n+   *             are emitted first.  They are followed by size entries,\n+   *             each consisting of a key (Object) and a value (Object).\n    */\n-  private void writeObject(ObjectOutputStream s) throws IOException\n+  private synchronized void writeObject(ObjectOutputStream s)\n+    throws IOException\n   {\n-    // the threshold and loadFactor fields\n+    // Write the threshold and loadFactor fields.\n     s.defaultWriteObject();\n \n     s.writeInt(buckets.length);\n     s.writeInt(size);\n-    Iterator it = entrySet().iterator();\n+    // Since we are already synchronized, and entrySet().iterator()\n+    // would repeatedly re-lock/release the monitor, we directly use the\n+    // unsynchronized HashIterator instead.\n+    Iterator it = new HashIterator(HashIterator.ENTRIES);\n     while (it.hasNext())\n       {\n-\tMap.Entry entry = (Map.Entry) it.next();\n-\ts.writeObject(entry.getKey());\n-\ts.writeObject(entry.getValue());\n+        HashEntry entry = (HashEntry) it.next();\n+        s.writeObject(entry.key);\n+        s.writeObject(entry.value);\n       }\n   }\n \n   /**\n    * Deserializes this object from the given stream.\n-   * @serialdata the <i>capacity</i>(int) that is the length of the\n-   * bucket array, the <i>size</i>(int) of the hash map are emitted\n-   * first.  They are followed by size entries, each consisting of\n-   * a key (Object) and a value (Object).\n+   *\n+   * @param s the stream to read from\n+   * @throws ClassNotFoundException if the underlying stream fails\n+   * @throws IOException if the underlying stream fails\n+   * @serialData the <i>capacity</i>(int) that is the length of the\n+   *             bucket array, the <i>size</i>(int) of the hash map\n+   *             are emitted first.  They are followed by size entries,\n+   *             each consisting of a key (Object) and a value (Object).\n    */\n   private void readObject(ObjectInputStream s)\n     throws IOException, ClassNotFoundException\n   {\n-    // the threshold and loadFactor fields\n+    // Read the threshold and loadFactor fields.\n     s.defaultReadObject();\n \n-    int capacity = s.readInt();\n+    // Read and use capacity.\n+    buckets = new HashEntry[s.readInt()];\n     int len = s.readInt();\n-    size = 0;\n-    modCount = 0;\n-    buckets = new Entry[capacity];\n \n-    for (int i = 0; i < len; i++)\n-      {\n-\tObject key = s.readObject();\n-\tObject value = s.readObject();\n-\tput(key, value);\n-      }\n+    // Read and use key/value pairs.\n+    for ( ; len > 0; len--)\n+      put(s.readObject(), s.readObject());\n   }\n \n   /**\n-   * a class which implements the Iterator interface and is used for\n-   * iterating over Hashtables;\n-   * this implementation is parameterized to give a sequential view of\n-   * keys, values, or entries; it also allows the removal of elements, \n-   * as per the Javasoft spec.\n+   * A class which implements the Iterator interface and is used for\n+   * iterating over Hashtables.\n+   * This implementation is parameterized to give a sequential view of\n+   * keys, values, or entries; it also allows the removal of elements,\n+   * as per the Javasoft spec.  Note that it is not synchronized; this is\n+   * a performance enhancer since it is never exposed externally and is\n+   * only used within synchronized blocks above.\n    *\n-   * @author       Jon Zeppieri\n+   * @author Jon Zeppieri\n    */\n   class HashIterator implements Iterator\n   {\n+    /** \"enum\" of iterator types. */\n     static final int KEYS = 0,\n                      VALUES = 1,\n-\t\t     ENTRIES = 2;\n-\t\t    \n-    // The type of this Iterator: KEYS, VALUES, or ENTRIES.\n-    int type;\n-    // The number of modifications to the backing Hashtable that we know about.\n-    int knownMod;\n-    // The total number of elements returned by next(). Used to determine if\n-    // there are more elements remaining.\n-    int count;\n-    // Current index in the physical hash table.\n-    int idx;\n-    // The last Entry returned by a next() call.\n-    Entry last;\n-    // The next entry that should be returned by next(). It is set to something\n-    // if we're iterating through a bucket that contains multiple linked \n-    // entries. It is null if next() needs to find a new bucket.\n-    Entry next;\n-\n-    /* Construct a new HashIterator with the supplied type: \n-       KEYS, VALUES, or ENTRIES */\n+                     ENTRIES = 2;\n+\n+    /**\n+     * The type of this Iterator: {@link #KEYS}, {@link #VALUES},\n+     * or {@link #ENTRIES}.\n+     */\n+    final int type;\n+    /**\n+     * The number of modifications to the backing Hashtable that we know about.\n+     */\n+    int knownMod = modCount;\n+    /** The number of elements remaining to be returned by next(). */\n+    int count = size;\n+    /** Current index in the physical hash table. */\n+    int idx = buckets.length;\n+    /** The last Entry returned by a next() call. */\n+    HashEntry last;\n+    /**\n+     * The next entry that should be returned by next(). It is set to something\n+     * if we're iterating through a bucket that contains multiple linked\n+     * entries. It is null if next() needs to find a new bucket.\n+     */\n+    HashEntry next;\n+\n+    /**\n+     * Construct a new HashIterator with the supplied type.\n+     * @param type {@link #KEYS}, {@link #VALUES}, or {@link #ENTRIES}\n+     */\n     HashIterator(int type)\n     {\n       this.type = type;\n-      knownMod = Hashtable.this.modCount;\n-      count = 0;\n-      idx = buckets.length;\n     }\n \n-    /** returns true if the Iterator has more elements */\n+    /**\n+     * Returns true if the Iterator has more elements.\n+     * @return true if there are more elements\n+     * @throws ConcurrentModificationException if the hashtable was modified\n+     */\n     public boolean hasNext()\n     {\n-      if (knownMod != Hashtable.this.modCount)\n-\tthrow new ConcurrentModificationException();\n-      return count < size;\n+      if (knownMod != modCount)\n+        throw new ConcurrentModificationException();\n+      return count > 0;\n     }\n \n-    /** Returns the next element in the Iterator's sequential view. */\n+    /**\n+     * Returns the next element in the Iterator's sequential view.\n+     * @return the next element\n+     * @throws ConcurrentModificationException if the hashtable was modified\n+     * @throws NoSuchElementException if there is none\n+     */\n     public Object next()\n     {\n-      if (knownMod != Hashtable.this.modCount)\n-\tthrow new ConcurrentModificationException();\n-      if (count == size)\n+      if (knownMod != modCount)\n+        throw new ConcurrentModificationException();\n+      if (count == 0)\n         throw new NoSuchElementException();\n-      count++;\n-      Entry e = null;\n-      if (next != null)\n-        e = next;\n+      count--;\n+      HashEntry e = next;\n \n       while (e == null)\n-        {\n-\t  e = buckets[--idx];\n-\t}\n+        e = buckets[--idx];\n \n       next = e.next;\n       last = e;\n@@ -790,32 +993,29 @@ else if (type == KEYS)\n       return e;\n     }\n \n-    /** \n-     * Removes from the backing Hashtable the last element which was fetched \n+    /**\n+     * Removes from the backing Hashtable the last element which was fetched\n      * with the <pre>next()</pre> method.\n+     * @throws ConcurrentModificationException if the hashtable was modified\n+     * @throws IllegalStateException if called when there is no last element\n      */\n     public void remove()\n     {\n-      if (knownMod != Hashtable.this.modCount)\n-\tthrow new ConcurrentModificationException();\n+      if (knownMod != modCount)\n+        throw new ConcurrentModificationException();\n       if (last == null)\n-\t{\n-\t  throw new IllegalStateException();\n-\t}\n-      else\n-\t{\n-\t  Hashtable.this.remove(last.key);\n-\t  knownMod++;\n-\t  count--;\n-\t  last = null;\n-\t}\n+        throw new IllegalStateException();\n+\n+      Hashtable.this.remove(last.key);\n+      knownMod++;\n+      last = null;\n     }\n   }\n \n \n   /**\n-   * Enumeration view of this Hashtable, providing sequential access to its \n-   * elements; this implementation is parameterized to provide access either \n+   * Enumeration view of this Hashtable, providing sequential access to its\n+   * elements; this implementation is parameterized to provide access either\n    * to the keys or to the values in the Hashtable.\n    *\n    * <b>NOTE</b>: Enumeration is not safe if new elements are put in the table\n@@ -825,58 +1025,78 @@ public void remove()\n    * the \"Java Class Libraries\" book infers that modifications to the\n    * hashtable during enumeration causes indeterminate results.  Don't do it!\n    *\n-   * @author       Jon Zeppieri\n+   * @author Jon Zeppieri\n    */\n   class Enumerator implements Enumeration\n   {\n-    static final int KEYS = 0;\n-    static final int VALUES = 1;\n-    \n+    /** \"enum\" of iterator types. */\n+    static final int KEYS = 0,\n+                     VALUES = 1;\n+\n+    /**\n+     * The type of this Iterator: {@link #KEYS} or {@link #VALUES}.\n+     */\n     int type;\n-    // current index in the physical hash table.\n+    /** Current index in the physical hash table. */\n     int idx;\n-    // the last Entry returned by nextEntry().\n-    Entry last;\n-    // Entry which will be returned by the next nextElement() call.\n-    Entry next;\n-    \n+    /** The last Entry returned by nextEntry(). */\n+    HashEntry last;\n+    /** Entry which will be returned by the next nextElement() call. */\n+    HashEntry next;\n+\n+    /**\n+     * Construct the enumeration.\n+     * @param type either {@link #KEYS} or {@link #VALUES}.\n+     */\n     Enumerator(int type)\n     {\n       this.type = type;\n       this.idx = buckets.length;\n     }\n-    \n-    private Entry nextEntry()\n+\n+    /**\n+     * Helper method to find the next entry.\n+     * @return the next entry, or null\n+     */\n+    private HashEntry nextEntry()\n     {\n-      Entry e = null;\n+      HashEntry e = null;\n \n       if (last != null)\n         e = last.next;\n \n       while (e == null && idx > 0)\n-\t{\n-\t  e = buckets[--idx];\n-\t}\n+        e = buckets[--idx];\n+\n       last = e;\n       return e;\n     }\n \n+    /**\n+     * Checks whether more elements remain in the enumeration.\n+     * @return true if nextElement() will not fail.\n+     */\n     public boolean hasMoreElements()\n     {\n       if (next != null)\n         return true;\n       next = nextEntry();\n-      return (next != null);\n+      return next != null;\n     }\n \n+    /**\n+     * Returns the next element.\n+     * @return the next element\n+     * @throws NoSuchElementException if there is none.\n+     */\n     public Object nextElement()\n     {\n-      Entry e = null;\n+      HashEntry e;\n       if (next != null)\n         {\n           e = next;\n-\t  next = null;\n-\t}\n+          next = null;\n+        }\n       else\n         e = nextEntry();\n       if (e == null)"}]}