{"sha": "5cbdba642487ff5d1502727b039a1bcccca7d196", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWNiZGJhNjQyNDg3ZmY1ZDE1MDI3MjdiMDM5YTFiY2NjY2E3ZDE5Ng==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@cygnus.com", "date": "1999-08-19T00:53:20Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "1999-08-19T00:53:20Z"}, "message": "[multiple changes]\n\nWed Aug 18 13:17:15 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n\t* class.c (emit_register_class): Removed unnecessary call to\n \tstart_sequence.\n\t* parse.y (labeled_block_contains_loop_p): Removed unused local\n \tvariable.\n\nTue Aug 17 22:51:44 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n        * parse.y (java_refold): Added prototype.\n\nTue Aug 17 21:48:41 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n        * parse.y (BINOP_COMPOUND_CANDIDATES): New macro.\n        (java_stabilize_reference): Removed unnecessary `else'.\n        (java_complete_lhs): Set flag to remember boolean. Call\n        java_refold. Added comments.\n        (java_decl_equiv): New function.\n        (binop_compound_p): Likewise.\n        (java_refold): Likewise.\n        (patch_unaryop): Striped static field access assigned to decl and\n        op. Changed promotion scheme for ++/-- operators.\n        (search_loop): New function.\n        (labeled_block_contains_loop_p): Likewise.\n        (patch_loop_statement): Call labeled_block_contains_loop_p. Added\n        comment.\n        (patch_bc_statement): Call search_loop. Fixed comment.\n\nMostly bug fixes in some forms of compound expressions and\nbreak/continue target lookup.\n\nFrom-SVN: r28758", "tree": {"sha": "a799200db51a3bcae06c0d28c4ddc0ade0f053ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a799200db51a3bcae06c0d28c4ddc0ade0f053ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5cbdba642487ff5d1502727b039a1bcccca7d196", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cbdba642487ff5d1502727b039a1bcccca7d196", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5cbdba642487ff5d1502727b039a1bcccca7d196", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cbdba642487ff5d1502727b039a1bcccca7d196/comments", "author": null, "committer": null, "parents": [{"sha": "0aa487d53420557a37388ac275a5855fcc5ae089", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0aa487d53420557a37388ac275a5855fcc5ae089", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0aa487d53420557a37388ac275a5855fcc5ae089"}], "stats": {"total": 1301, "additions": 797, "deletions": 504}, "files": [{"sha": "6596be752da8f4f759269c0f0d8980cff0b0bac5", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cbdba642487ff5d1502727b039a1bcccca7d196/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cbdba642487ff5d1502727b039a1bcccca7d196/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=5cbdba642487ff5d1502727b039a1bcccca7d196", "patch": "@@ -1,3 +1,31 @@\n+Wed Aug 18 13:17:15 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* class.c (emit_register_class): Removed unnecessary call to\n+ \tstart_sequence.\n+\t* parse.y (labeled_block_contains_loop_p): Removed unused local\n+ \tvariable.\n+\n+Tue Aug 17 22:51:44 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+        * parse.y (java_refold): Added prototype.\n+\n+Tue Aug 17 21:48:41 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+        * parse.y (BINOP_COMPOUND_CANDIDATES): New macro.\n+        (java_stabilize_reference): Removed unnecessary `else'.\n+        (java_complete_lhs): Set flag to remember boolean. Call\n+        java_refold. Added comments.\n+        (java_decl_equiv): New function.\n+        (binop_compound_p): Likewise.\n+        (java_refold): Likewise.\n+        (patch_unaryop): Striped static field access assigned to decl and\n+        op. Changed promotion scheme for ++/-- operators.\n+        (search_loop): New function.\n+        (labeled_block_contains_loop_p): Likewise.\n+        (patch_loop_statement): Call labeled_block_contains_loop_p. Added\n+        comment.\n+        (patch_bc_statement): Call search_loop. Fixed comment.\n+\n 1999-08-14  Anthony Green  <green@cygnus.com>\n \n \t* expr.c (java_lang_expand_expr): Mark static array data as"}, {"sha": "5e345e0668ff10b5b2439f08a5ecd10e40a2a475", "filename": "gcc/java/class.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cbdba642487ff5d1502727b039a1bcccca7d196/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cbdba642487ff5d1502727b039a1bcccca7d196/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=5cbdba642487ff5d1502727b039a1bcccca7d196", "patch": "@@ -1728,7 +1728,6 @@ emit_register_classes ()\n   tree init_decl;\n   tree t;\n \n-  start_sequence ();\n   init_decl = build_decl (FUNCTION_DECL, init_name, init_type);\n   DECL_ASSEMBLER_NAME (init_decl) = init_name;\n   TREE_STATIC (init_decl) = 1;"}, {"sha": "6f900b44331023e1736e4f44bdf0d47f37884a51", "filename": "gcc/java/parse.c", "status": "modified", "additions": 599, "deletions": 466, "changes": 1065, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cbdba642487ff5d1502727b039a1bcccca7d196/gcc%2Fjava%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cbdba642487ff5d1502727b039a1bcccca7d196/gcc%2Fjava%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.c?ref=5cbdba642487ff5d1502727b039a1bcccca7d196", "patch": "@@ -333,6 +333,7 @@ static tree do_unary_numeric_promotion PROTO ((tree));\n static char * operator_string PROTO ((tree));\n static tree do_merge_string_cste PROTO ((tree, const char *, int, int));\n static tree merge_string_cste PROTO ((tree, tree, int));\n+static tree java_refold PROTO ((tree));\n \n /* Number of error found so far. */\n int java_error_count; \n@@ -364,6 +365,10 @@ static enum tree_code binop_lookup[19] =\n   binop_lookup [((VALUE) - PLUS_TK)%\t\t\t\t\t\\\n \t\t(sizeof (binop_lookup) / sizeof (binop_lookup[0]))]\n \n+/* This is the end index for binary operators that can also be used\n+   in compound assignements. */\n+#define BINOP_COMPOUND_CANDIDATES 11\n+\n /* Fake WFL used to report error message. It is initialized once if\n    needed and reused with it's location information is overriden.  */\n tree wfl_operator = NULL_TREE;\n@@ -390,7 +395,7 @@ static tree java_lang_cloneable = NULL_TREE;\n static tree current_static_block = NULL_TREE;\n \n \n-#line 318 \"./parse.y\"\n+#line 323 \"./parse.y\"\n typedef union {\n   tree node;\n   int sub_token;\n@@ -400,7 +405,7 @@ typedef union {\n   } operator;\n   int value;\n } YYSTYPE;\n-#line 328 \"./parse.y\"\n+#line 333 \"./parse.y\"\n \n #include \"lex.c\"\n #ifndef YYDEBUG\n@@ -698,57 +703,57 @@ static const short yyrhs[] = {   123,\n \n #if YYDEBUG != 0\n static const short yyrline[] = { 0,\n-   472,   478,   480,   481,   482,   483,   484,   488,   490,   493,\n-   495,   496,   499,   501,   504,   508,   512,   516,   522,   524,\n-   526,   528,   533,   535,   538,   542,   547,   552,   554,   555,\n-   556,   557,   558,   559,   560,   563,   568,   574,   576,   579,\n-   582,   584,   588,   590,   593,   620,   622,   626,   639,   641,\n-   645,   652,   657,   659,   669,   674,   689,   693,   696,   699,\n-   702,   704,   706,   711,   715,   717,   719,   721,   725,   727,\n-   729,   736,   742,   747,   751,   760,   770,   772,   775,   777,\n-   778,   779,   783,   785,   787,   788,   790,   795,   798,   808,\n-   811,   813,   817,   820,   827,   833,   841,   843,   845,   847,\n-   849,   853,   855,   859,   866,   867,   871,   874,   876,   878,\n-   880,   882,   884,   886,   888,   895,   898,   900,   909,   911,\n-   915,   920,   925,   929,   934,   939,   941,   948,   950,   952,\n-   956,   959,   961,   965,   967,   968,   973,   979,   986,   994,\n-  1001,  1004,  1007,  1011,  1014,  1018,  1027,  1029,  1031,  1035,\n-  1037,  1040,  1047,  1055,  1057,  1061,  1068,  1078,  1082,  1085,\n-  1088,  1091,  1094,  1097,  1100,  1103,  1105,  1109,  1115,  1120,\n-  1122,  1126,  1129,  1133,  1135,  1138,  1140,  1141,  1143,  1147,\n-  1151,  1157,  1162,  1165,  1167,  1171,  1177,  1181,  1186,  1195,\n-  1199,  1204,  1216,  1218,  1221,  1223,  1225,  1229,  1233,  1236,\n-  1240,  1242,  1243,  1244,  1245,  1246,  1250,  1252,  1253,  1254,\n-  1255,  1259,  1261,  1262,  1263,  1264,  1265,  1266,  1267,  1268,\n-  1269,  1270,  1273,  1278,  1289,  1292,  1296,  1303,  1313,  1319,\n-  1325,  1331,  1333,  1339,  1341,  1347,  1349,  1351,  1353,  1355,\n-  1359,  1361,  1362,  1363,  1364,  1365,  1366,  1369,  1375,  1377,\n-  1379,  1383,  1388,  1393,  1399,  1409,  1415,  1417,  1419,  1426,\n-  1429,  1431,  1433,  1437,  1439,  1442,  1446,  1448,  1451,  1458,\n-  1464,  1466,  1468,  1472,  1480,  1483,  1485,  1487,  1491,  1496,\n-  1505,  1510,  1513,  1520,  1522,  1524,  1528,  1531,  1540,  1547,\n-  1549,  1553,  1566,  1568,  1574,  1580,  1584,  1586,  1590,  1593,\n-  1595,  1599,  1602,  1604,  1606,  1610,  1613,  1615,  1617,  1621,\n-  1624,  1626,  1628,  1632,  1638,  1640,  1644,  1651,  1653,  1655,\n-  1657,  1661,  1669,  1672,  1674,  1679,  1683,  1685,  1692,  1700,\n-  1717,  1719,  1721,  1725,  1728,  1733,  1735,  1738,  1740,  1742,\n-  1744,  1745,  1746,  1747,  1751,  1753,  1755,  1760,  1762,  1764,\n-  1766,  1768,  1772,  1775,  1780,  1782,  1787,  1788,  1789,  1790,\n-  1791,  1793,  1795,  1797,  1799,  1801,  1805,  1807,  1810,  1816,\n-  1821,  1825,  1828,  1830,  1832,  1836,  1838,  1840,  1842,  1846,\n-  1849,  1853,  1859,  1861,  1869,  1896,  1898,  1902,  1907,  1914,\n-  1918,  1921,  1923,  1934,  1945,  1950,  1959,  1961,  1965,  1968,\n-  1970,  1975,  1980,  1985,  1992,  1994,  1995,  1996,  1999,  2004,\n-  2009,  2011,  2012,  2014,  2016,  2017,  2019,  2023,  2026,  2030,\n-  2033,  2037,  2039,  2041,  2043,  2044,  2046,  2050,  2059,  2061,\n-  2063,  2076,  2078,  2084,  2086,  2088,  2092,  2094,  2099,  2104,\n-  2109,  2111,  2113,  2117,  2119,  2124,  2129,  2131,  2135,  2137,\n-  2142,  2147,  2152,  2154,  2156,  2160,  2162,  2167,  2172,  2177,\n-  2182,  2184,  2186,  2188,  2190,  2192,  2196,  2198,  2203,  2208,\n-  2210,  2214,  2216,  2221,  2225,  2227,  2232,  2236,  2238,  2243,\n-  2247,  2249,  2254,  2258,  2260,  2265,  2269,  2271,  2276,  2282,\n-  2284,  2288,  2290,  2293,  2296,  2304,  2306,  2307,  2310,  2312,\n-  2315,  2319\n+   477,   483,   485,   486,   487,   488,   489,   493,   495,   498,\n+   500,   501,   504,   506,   509,   513,   517,   521,   527,   529,\n+   531,   533,   538,   540,   543,   547,   552,   557,   559,   560,\n+   561,   562,   563,   564,   565,   568,   573,   579,   581,   584,\n+   587,   589,   593,   595,   598,   625,   627,   631,   644,   646,\n+   650,   657,   662,   664,   674,   679,   694,   698,   701,   704,\n+   707,   709,   711,   716,   720,   722,   724,   726,   730,   732,\n+   734,   741,   747,   752,   756,   765,   775,   777,   780,   782,\n+   783,   784,   788,   790,   792,   793,   795,   800,   803,   813,\n+   816,   818,   822,   825,   832,   838,   846,   848,   850,   852,\n+   854,   858,   860,   864,   871,   872,   876,   879,   881,   883,\n+   885,   887,   889,   891,   893,   900,   903,   905,   914,   916,\n+   920,   925,   930,   934,   939,   944,   946,   953,   955,   957,\n+   961,   964,   966,   970,   972,   973,   978,   984,   991,   999,\n+  1006,  1009,  1012,  1016,  1019,  1023,  1032,  1034,  1036,  1040,\n+  1042,  1045,  1052,  1060,  1062,  1066,  1073,  1083,  1087,  1090,\n+  1093,  1096,  1099,  1102,  1105,  1108,  1110,  1114,  1120,  1125,\n+  1127,  1131,  1134,  1138,  1140,  1143,  1145,  1146,  1148,  1152,\n+  1156,  1162,  1167,  1170,  1172,  1176,  1182,  1186,  1191,  1200,\n+  1204,  1209,  1221,  1223,  1226,  1228,  1230,  1234,  1238,  1241,\n+  1245,  1247,  1248,  1249,  1250,  1251,  1255,  1257,  1258,  1259,\n+  1260,  1264,  1266,  1267,  1268,  1269,  1270,  1271,  1272,  1273,\n+  1274,  1275,  1278,  1283,  1294,  1297,  1301,  1308,  1318,  1324,\n+  1330,  1336,  1338,  1344,  1346,  1352,  1354,  1356,  1358,  1360,\n+  1364,  1366,  1367,  1368,  1369,  1370,  1371,  1374,  1380,  1382,\n+  1384,  1388,  1393,  1398,  1404,  1414,  1420,  1422,  1424,  1431,\n+  1434,  1436,  1438,  1442,  1444,  1447,  1451,  1453,  1456,  1463,\n+  1469,  1471,  1473,  1477,  1485,  1488,  1490,  1492,  1496,  1501,\n+  1510,  1515,  1518,  1525,  1527,  1529,  1533,  1536,  1545,  1552,\n+  1554,  1558,  1571,  1573,  1579,  1585,  1589,  1591,  1595,  1598,\n+  1600,  1604,  1607,  1609,  1611,  1615,  1618,  1620,  1622,  1626,\n+  1629,  1631,  1633,  1637,  1643,  1645,  1649,  1656,  1658,  1660,\n+  1662,  1666,  1674,  1677,  1679,  1684,  1688,  1690,  1697,  1705,\n+  1722,  1724,  1726,  1730,  1733,  1738,  1740,  1743,  1745,  1747,\n+  1749,  1750,  1751,  1752,  1756,  1758,  1760,  1765,  1767,  1769,\n+  1771,  1773,  1777,  1780,  1785,  1787,  1792,  1793,  1794,  1795,\n+  1796,  1798,  1800,  1802,  1804,  1806,  1810,  1812,  1815,  1821,\n+  1826,  1830,  1833,  1835,  1837,  1841,  1843,  1845,  1847,  1851,\n+  1854,  1858,  1864,  1866,  1874,  1901,  1903,  1907,  1912,  1919,\n+  1923,  1926,  1928,  1939,  1950,  1955,  1964,  1966,  1970,  1973,\n+  1975,  1980,  1985,  1990,  1997,  1999,  2000,  2001,  2004,  2009,\n+  2014,  2016,  2017,  2019,  2021,  2022,  2024,  2028,  2031,  2035,\n+  2038,  2042,  2044,  2046,  2048,  2049,  2051,  2055,  2064,  2066,\n+  2068,  2081,  2083,  2089,  2091,  2093,  2097,  2099,  2104,  2109,\n+  2114,  2116,  2118,  2122,  2124,  2129,  2134,  2136,  2140,  2142,\n+  2147,  2152,  2157,  2159,  2161,  2165,  2167,  2172,  2177,  2182,\n+  2187,  2189,  2191,  2193,  2195,  2197,  2201,  2203,  2208,  2213,\n+  2215,  2219,  2221,  2226,  2230,  2232,  2237,  2241,  2243,  2248,\n+  2252,  2254,  2259,  2263,  2265,  2270,  2274,  2276,  2281,  2287,\n+  2289,  2293,  2295,  2298,  2301,  2309,  2311,  2312,  2315,  2317,\n+  2320,  2324\n };\n #endif\n \n@@ -2226,7 +2231,7 @@ static const short yycheck[] = {     3,\n #define YYPURE 1\n \n /* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */\n-#line 3 \"/usr/local/gnu/share/bison.simple\"\n+#line 3 \"/usr/cygnus/gnupro-98r1/share/bison.simple\"\n \n /* Skeleton output parser for bison,\n    Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.\n@@ -2419,7 +2424,7 @@ __yy_memcpy (char *to, char *from, int count)\n #endif\n #endif\n \f\n-#line 196 \"/usr/local/gnu/share/bison.simple\"\n+#line 196 \"/usr/cygnus/gnupro-98r1/share/bison.simple\"\n \n /* The user can define YYPARSE_PARAM as the name of an argument to be passed\n    into yyparse.  The argument should have type void *.\n@@ -2724,66 +2729,66 @@ yyparse(YYPARSE_PARAM_ARG)\n   switch (yyn) {\n \n case 1:\n-#line 474 \"./parse.y\"\n+#line 479 \"./parse.y\"\n {;\n     break;}\n case 18:\n-#line 518 \"./parse.y\"\n+#line 523 \"./parse.y\"\n { \n \t\t  yyval.node = build_java_array_type (yyvsp[-2].node, -1);\n \t\t  CLASS_LOADED_P (yyval.node) = 1;\n \t\t;\n     break;}\n case 19:\n-#line 523 \"./parse.y\"\n+#line 528 \"./parse.y\"\n { yyval.node = build_unresolved_array_type (yyvsp[-2].node); ;\n     break;}\n case 20:\n-#line 525 \"./parse.y\"\n+#line 530 \"./parse.y\"\n { yyval.node = build_unresolved_array_type (yyvsp[-2].node); ;\n     break;}\n case 21:\n-#line 527 \"./parse.y\"\n+#line 532 \"./parse.y\"\n {RULE (\"']' expected\"); RECOVER;;\n     break;}\n case 22:\n-#line 529 \"./parse.y\"\n+#line 534 \"./parse.y\"\n {RULE (\"']' expected\"); RECOVER;;\n     break;}\n case 26:\n-#line 544 \"./parse.y\"\n+#line 549 \"./parse.y\"\n { yyval.node = make_qualified_name (yyvsp[-2].node, yyvsp[0].node, yyvsp[-1].operator.location); ;\n     break;}\n case 28:\n-#line 553 \"./parse.y\"\n+#line 558 \"./parse.y\"\n {yyval.node = NULL;;\n     break;}\n case 36:\n-#line 565 \"./parse.y\"\n+#line 570 \"./parse.y\"\n {\n \t\t  yyval.node = NULL;\n \t\t;\n     break;}\n case 37:\n-#line 569 \"./parse.y\"\n+#line 574 \"./parse.y\"\n {\n \t\t  yyval.node = NULL;\n \t\t;\n     break;}\n case 40:\n-#line 581 \"./parse.y\"\n+#line 586 \"./parse.y\"\n { ctxp->package = EXPR_WFL_NODE (yyvsp[-1].node); ;\n     break;}\n case 41:\n-#line 583 \"./parse.y\"\n+#line 588 \"./parse.y\"\n {yyerror (\"Missing name\"); RECOVER;;\n     break;}\n case 42:\n-#line 585 \"./parse.y\"\n+#line 590 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 45:\n-#line 595 \"./parse.y\"\n+#line 600 \"./parse.y\"\n {\n \t\t  tree name = EXPR_WFL_NODE (yyvsp[-1].node), node, last_name;\n \t\t  int   i = IDENTIFIER_LENGTH (name)-1;\n@@ -2811,15 +2816,15 @@ case 45:\n \t\t;\n     break;}\n case 46:\n-#line 621 \"./parse.y\"\n+#line 626 \"./parse.y\"\n {yyerror (\"Missing name\"); RECOVER;;\n     break;}\n case 47:\n-#line 623 \"./parse.y\"\n+#line 628 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 48:\n-#line 628 \"./parse.y\"\n+#line 633 \"./parse.y\"\n {\n \t\t  tree name = EXPR_WFL_NODE (yyvsp[-3].node);\n \t\t  /* Don't import java.lang.* twice. */\n@@ -2833,47 +2838,47 @@ case 48:\n \t\t;\n     break;}\n case 49:\n-#line 640 \"./parse.y\"\n+#line 645 \"./parse.y\"\n {yyerror (\"'*' expected\"); RECOVER;;\n     break;}\n case 50:\n-#line 642 \"./parse.y\"\n+#line 647 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 51:\n-#line 647 \"./parse.y\"\n+#line 652 \"./parse.y\"\n {\n \t\t  maybe_generate_finit ();\n \t\t  maybe_generate_clinit ();\n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n case 52:\n-#line 653 \"./parse.y\"\n+#line 658 \"./parse.y\"\n {\n \t\t  maybe_generate_clinit ();\n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n case 53:\n-#line 658 \"./parse.y\"\n+#line 663 \"./parse.y\"\n { yyval.node = NULL; ;\n     break;}\n case 54:\n-#line 660 \"./parse.y\"\n+#line 665 \"./parse.y\"\n {\n \t\t  YYERROR_NOW;\n \t\t  yyerror (\"Class or interface declaration expected\");\n \t\t;\n     break;}\n case 55:\n-#line 671 \"./parse.y\"\n+#line 676 \"./parse.y\"\n {\n \t\t  yyval.value = (1 << yyvsp[0].value);\n \t\t;\n     break;}\n case 56:\n-#line 675 \"./parse.y\"\n+#line 680 \"./parse.y\"\n {\n \t\t  int acc = (1 << yyvsp[0].value);\n \t\t  if (yyval.value & acc)\n@@ -2887,95 +2892,95 @@ case 56:\n \t\t;\n     break;}\n case 57:\n-#line 691 \"./parse.y\"\n+#line 696 \"./parse.y\"\n { create_class (yyvsp[-4].value, yyvsp[-2].node, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 58:\n-#line 693 \"./parse.y\"\n+#line 698 \"./parse.y\"\n { \n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n case 59:\n-#line 697 \"./parse.y\"\n+#line 702 \"./parse.y\"\n { create_class (0, yyvsp[-2].node, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 60:\n-#line 699 \"./parse.y\"\n+#line 704 \"./parse.y\"\n { \t\n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n case 61:\n-#line 703 \"./parse.y\"\n+#line 708 \"./parse.y\"\n {yyerror (\"Missing class name\"); RECOVER;;\n     break;}\n case 62:\n-#line 705 \"./parse.y\"\n+#line 710 \"./parse.y\"\n {yyerror (\"Missing class name\"); RECOVER;;\n     break;}\n case 63:\n-#line 707 \"./parse.y\"\n+#line 712 \"./parse.y\"\n {\n \t\t  if (!ctxp->class_err) yyerror (\"'{' expected\"); \n \t\t  DRECOVER(class1);\n \t\t;\n     break;}\n case 64:\n-#line 712 \"./parse.y\"\n+#line 717 \"./parse.y\"\n {if (!ctxp->class_err) yyerror (\"'{' expected\"); RECOVER;;\n     break;}\n case 65:\n-#line 716 \"./parse.y\"\n+#line 721 \"./parse.y\"\n { yyval.node = NULL; ;\n     break;}\n case 66:\n-#line 718 \"./parse.y\"\n+#line 723 \"./parse.y\"\n { yyval.node = yyvsp[0].node; ;\n     break;}\n case 67:\n-#line 720 \"./parse.y\"\n+#line 725 \"./parse.y\"\n {yyerror (\"'{' expected\"); ctxp->class_err=1;;\n     break;}\n case 68:\n-#line 722 \"./parse.y\"\n+#line 727 \"./parse.y\"\n {yyerror (\"Missing super class name\"); ctxp->class_err=1;;\n     break;}\n case 69:\n-#line 726 \"./parse.y\"\n+#line 731 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 70:\n-#line 728 \"./parse.y\"\n+#line 733 \"./parse.y\"\n { yyval.node = yyvsp[0].node; ;\n     break;}\n case 71:\n-#line 730 \"./parse.y\"\n+#line 735 \"./parse.y\"\n {\n \t\t  ctxp->class_err=1;\n \t\t  yyerror (\"Missing interface name\"); \n \t\t;\n     break;}\n case 72:\n-#line 738 \"./parse.y\"\n+#line 743 \"./parse.y\"\n { \n \t\t  ctxp->interface_number = 1;\n \t\t  yyval.node = build_tree_list (yyvsp[0].node, NULL_TREE);\n \t\t;\n     break;}\n case 73:\n-#line 743 \"./parse.y\"\n+#line 748 \"./parse.y\"\n { \n \t\t  ctxp->interface_number++;\n \t\t  yyval.node = chainon (yyvsp[-2].node, build_tree_list (yyvsp[0].node, NULL_TREE));\n \t\t;\n     break;}\n case 74:\n-#line 748 \"./parse.y\"\n+#line 753 \"./parse.y\"\n {yyerror (\"Missing interface name\"); RECOVER;;\n     break;}\n case 75:\n-#line 753 \"./parse.y\"\n+#line 758 \"./parse.y\"\n { \n \t\t  /* Store the location of the `}' when doing xrefs */\n \t\t  if (flag_emit_xref)\n@@ -2985,7 +2990,7 @@ case 75:\n \t\t;\n     break;}\n case 76:\n-#line 761 \"./parse.y\"\n+#line 766 \"./parse.y\"\n { \n \t\t  /* Store the location of the `}' when doing xrefs */\n \t\t  if (flag_emit_xref)\n@@ -2995,27 +3000,27 @@ case 76:\n \t\t;\n     break;}\n case 82:\n-#line 780 \"./parse.y\"\n+#line 785 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"instance initializer\"); ;\n     break;}\n case 84:\n-#line 786 \"./parse.y\"\n+#line 791 \"./parse.y\"\n { yyval.node = yyvsp[-1].node; ;\n     break;}\n case 86:\n-#line 789 \"./parse.y\"\n+#line 794 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"inner classe declaration\"); ;\n     break;}\n case 87:\n-#line 791 \"./parse.y\"\n+#line 796 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"inner interface declaration\"); ;\n     break;}\n case 88:\n-#line 797 \"./parse.y\"\n+#line 802 \"./parse.y\"\n { register_fields (0, yyvsp[-2].node, yyvsp[-1].node); ;\n     break;}\n case 89:\n-#line 799 \"./parse.y\"\n+#line 804 \"./parse.y\"\n {\n \t\t  check_modifiers \n \t\t    (\"Illegal modifier `%s' for field declaration\",\n@@ -3025,19 +3030,19 @@ case 89:\n \t\t;\n     break;}\n case 91:\n-#line 812 \"./parse.y\"\n+#line 817 \"./parse.y\"\n { yyval.node = chainon (yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 92:\n-#line 814 \"./parse.y\"\n+#line 819 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 93:\n-#line 819 \"./parse.y\"\n+#line 824 \"./parse.y\"\n { yyval.node = build_tree_list (yyvsp[0].node, NULL_TREE); ;\n     break;}\n case 94:\n-#line 821 \"./parse.y\"\n+#line 826 \"./parse.y\"\n { \n \t\t  if (java_error_count)\n \t\t    yyvsp[0].node = NULL_TREE;\n@@ -3046,101 +3051,101 @@ case 94:\n \t\t;\n     break;}\n case 95:\n-#line 828 \"./parse.y\"\n+#line 833 \"./parse.y\"\n {\n \t\t  yyerror (\"Missing variable initializer\");\n \t\t  yyval.node = build_tree_list (yyvsp[-2].node, NULL_TREE);\n \t\t  RECOVER;\n \t\t;\n     break;}\n case 96:\n-#line 834 \"./parse.y\"\n+#line 839 \"./parse.y\"\n {\n \t\t  yyerror (\"';' expected\");\n \t\t  yyval.node = build_tree_list (yyvsp[-3].node, NULL_TREE);\n \t\t  RECOVER;\n \t\t;\n     break;}\n case 98:\n-#line 844 \"./parse.y\"\n+#line 849 \"./parse.y\"\n { yyval.node = build_unresolved_array_type (yyvsp[-2].node); ;\n     break;}\n case 99:\n-#line 846 \"./parse.y\"\n+#line 851 \"./parse.y\"\n {yyerror (\"Invalid declaration\"); DRECOVER(vdi);;\n     break;}\n case 100:\n-#line 848 \"./parse.y\"\n+#line 853 \"./parse.y\"\n {yyerror (\"']' expected\"); DRECOVER(vdi);;\n     break;}\n case 101:\n-#line 850 \"./parse.y\"\n+#line 855 \"./parse.y\"\n {yyerror (\"Unbalanced ']'\"); DRECOVER(vdi);;\n     break;}\n case 104:\n-#line 861 \"./parse.y\"\n+#line 866 \"./parse.y\"\n {\n \t\t  current_function_decl = yyvsp[0].node;\n \t\t  source_start_java_method (current_function_decl);\n \t\t;\n     break;}\n case 105:\n-#line 866 \"./parse.y\"\n+#line 871 \"./parse.y\"\n { finish_method_declaration (yyvsp[0].node); ;\n     break;}\n case 106:\n-#line 868 \"./parse.y\"\n+#line 873 \"./parse.y\"\n {YYNOT_TWICE yyerror (\"'{' expected\"); RECOVER;;\n     break;}\n case 107:\n-#line 873 \"./parse.y\"\n+#line 878 \"./parse.y\"\n { yyval.node = method_header (0, yyvsp[-2].node, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 108:\n-#line 875 \"./parse.y\"\n+#line 880 \"./parse.y\"\n { yyval.node = method_header (0, void_type_node, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 109:\n-#line 877 \"./parse.y\"\n+#line 882 \"./parse.y\"\n { yyval.node = method_header (yyvsp[-3].value, yyvsp[-2].node, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 110:\n-#line 879 \"./parse.y\"\n+#line 884 \"./parse.y\"\n { yyval.node = method_header (yyvsp[-3].value, void_type_node, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 111:\n-#line 881 \"./parse.y\"\n+#line 886 \"./parse.y\"\n {RECOVER;;\n     break;}\n case 112:\n-#line 883 \"./parse.y\"\n+#line 888 \"./parse.y\"\n {RECOVER;;\n     break;}\n case 113:\n-#line 885 \"./parse.y\"\n+#line 890 \"./parse.y\"\n {yyerror (\"Identifier expected\"); RECOVER;;\n     break;}\n case 114:\n-#line 887 \"./parse.y\"\n+#line 892 \"./parse.y\"\n {yyerror (\"Identifier expected\"); RECOVER;;\n     break;}\n case 115:\n-#line 889 \"./parse.y\"\n+#line 894 \"./parse.y\"\n {\n \t\t  yyerror (\"Invalid method declaration, return type required\");\n \t\t  RECOVER;\n \t\t;\n     break;}\n case 116:\n-#line 897 \"./parse.y\"\n+#line 902 \"./parse.y\"\n { yyval.node = method_declarator (yyvsp[-2].node, NULL_TREE); ;\n     break;}\n case 117:\n-#line 899 \"./parse.y\"\n+#line 904 \"./parse.y\"\n { yyval.node = method_declarator (yyvsp[-3].node, yyvsp[-1].node); ;\n     break;}\n case 118:\n-#line 901 \"./parse.y\"\n+#line 906 \"./parse.y\"\n {\n \t\t  EXPR_WFL_LINECOL (wfl_operator) = yyvsp[-1].operator.location;\n \t\t  TREE_PURPOSE (yyvsp[-2].node) = \n@@ -3151,316 +3156,316 @@ case 118:\n \t\t;\n     break;}\n case 119:\n-#line 910 \"./parse.y\"\n+#line 915 \"./parse.y\"\n {yyerror (\"')' expected\"); DRECOVER(method_declarator);;\n     break;}\n case 120:\n-#line 912 \"./parse.y\"\n+#line 917 \"./parse.y\"\n {yyerror (\"']' expected\"); RECOVER;;\n     break;}\n case 121:\n-#line 917 \"./parse.y\"\n+#line 922 \"./parse.y\"\n {\n \t\t  ctxp->formal_parameter_number = 1;\n \t\t;\n     break;}\n case 122:\n-#line 921 \"./parse.y\"\n+#line 926 \"./parse.y\"\n {\n \t\t  ctxp->formal_parameter_number += 1;\n \t\t  yyval.node = chainon (yyvsp[-2].node, yyvsp[0].node);\n \t\t;\n     break;}\n case 123:\n-#line 926 \"./parse.y\"\n+#line 931 \"./parse.y\"\n {yyerror (\"Missing formal parameter term\"); RECOVER;;\n     break;}\n case 124:\n-#line 931 \"./parse.y\"\n+#line 936 \"./parse.y\"\n {\n \t\t  yyval.node = build_tree_list (yyvsp[0].node, yyvsp[-1].node);\n \t\t;\n     break;}\n case 125:\n-#line 935 \"./parse.y\"\n+#line 940 \"./parse.y\"\n { \n \t\t  parse_jdk1_1_error (\"final parameters\");\n \t\t  yyval.node = build_tree_list (yyvsp[0].node, yyvsp[-1].node);\n \t\t;\n     break;}\n case 126:\n-#line 940 \"./parse.y\"\n+#line 945 \"./parse.y\"\n {yyerror (\"Missing identifier\"); RECOVER;;\n     break;}\n case 127:\n-#line 942 \"./parse.y\"\n+#line 947 \"./parse.y\"\n {\n \t\t  SOURCE_FRONTEND_DEBUG ((\"Modifiers: %d\", yyvsp[-2].value));\n \t\t  yyerror (\"Missing identifier\"); RECOVER;\n \t\t;\n     break;}\n case 128:\n-#line 949 \"./parse.y\"\n+#line 954 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 129:\n-#line 951 \"./parse.y\"\n+#line 956 \"./parse.y\"\n { yyval.node = yyvsp[0].node; ;\n     break;}\n case 130:\n-#line 953 \"./parse.y\"\n+#line 958 \"./parse.y\"\n {yyerror (\"Missing class type term\"); RECOVER;;\n     break;}\n case 131:\n-#line 958 \"./parse.y\"\n+#line 963 \"./parse.y\"\n { yyval.node = build_tree_list (yyvsp[0].node, yyvsp[0].node); ;\n     break;}\n case 132:\n-#line 960 \"./parse.y\"\n+#line 965 \"./parse.y\"\n { yyval.node = tree_cons (yyvsp[0].node, yyvsp[0].node, yyvsp[-2].node); ;\n     break;}\n case 133:\n-#line 962 \"./parse.y\"\n+#line 967 \"./parse.y\"\n {yyerror (\"Missing class type term\"); RECOVER;;\n     break;}\n case 136:\n-#line 969 \"./parse.y\"\n+#line 974 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 137:\n-#line 975 \"./parse.y\"\n+#line 980 \"./parse.y\"\n {\n \t\t  TREE_CHAIN (yyvsp[0].node) = ctxp->static_initialized;\n \t\t  ctxp->static_initialized = yyvsp[0].node;\n \t\t;\n     break;}\n case 138:\n-#line 980 \"./parse.y\"\n+#line 985 \"./parse.y\"\n {\n \t\t  TREE_CHAIN (yyvsp[-1].node) = ctxp->static_initialized;\n \t\t  ctxp->static_initialized = yyvsp[-1].node;\n \t\t;\n     break;}\n case 139:\n-#line 988 \"./parse.y\"\n+#line 993 \"./parse.y\"\n {\n \t\t  SOURCE_FRONTEND_DEBUG ((\"Modifiers: %d\", yyvsp[0].value));\n \t\t;\n     break;}\n case 140:\n-#line 996 \"./parse.y\"\n+#line 1001 \"./parse.y\"\n {\n \t\t  current_function_decl = yyvsp[0].node;\n \t\t  source_start_java_method (current_function_decl);\n \t\t;\n     break;}\n case 141:\n-#line 1001 \"./parse.y\"\n+#line 1006 \"./parse.y\"\n { finish_method_declaration (yyvsp[0].node); ;\n     break;}\n case 142:\n-#line 1006 \"./parse.y\"\n+#line 1011 \"./parse.y\"\n { yyval.node = method_header (0, NULL_TREE, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 143:\n-#line 1008 \"./parse.y\"\n+#line 1013 \"./parse.y\"\n { yyval.node = method_header (yyvsp[-2].value, NULL_TREE, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 144:\n-#line 1013 \"./parse.y\"\n+#line 1018 \"./parse.y\"\n { yyval.node = method_declarator (yyvsp[-2].node, NULL_TREE); ;\n     break;}\n case 145:\n-#line 1015 \"./parse.y\"\n+#line 1020 \"./parse.y\"\n { yyval.node = method_declarator (yyvsp[-3].node, yyvsp[-1].node); ;\n     break;}\n case 146:\n-#line 1023 \"./parse.y\"\n+#line 1028 \"./parse.y\"\n { \n \t\t  BLOCK_EXPR_BODY (yyvsp[0].node) = empty_stmt_node;\n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n case 147:\n-#line 1028 \"./parse.y\"\n+#line 1033 \"./parse.y\"\n { yyval.node = yyvsp[0].node; ;\n     break;}\n case 148:\n-#line 1030 \"./parse.y\"\n+#line 1035 \"./parse.y\"\n { yyval.node = yyvsp[0].node; ;\n     break;}\n case 149:\n-#line 1032 \"./parse.y\"\n+#line 1037 \"./parse.y\"\n { yyval.node = yyvsp[0].node; ;\n     break;}\n case 152:\n-#line 1042 \"./parse.y\"\n+#line 1047 \"./parse.y\"\n { \n \t\t  yyval.node = build_method_invocation (yyvsp[-3].node, NULL_TREE); \n \t\t  yyval.node = build_debugable_stmt (EXPR_WFL_LINECOL (yyvsp[-3].node), yyval.node);\n \t\t  yyval.node = java_method_add_stmt (current_function_decl, yyval.node);\n \t\t;\n     break;}\n case 153:\n-#line 1048 \"./parse.y\"\n+#line 1053 \"./parse.y\"\n { \n \t\t  yyval.node = build_method_invocation (yyvsp[-4].node, yyvsp[-2].node); \n \t\t  yyval.node = build_debugable_stmt (EXPR_WFL_LINECOL (yyvsp[-4].node), yyval.node);\n \t\t  yyval.node = java_method_add_stmt (current_function_decl, yyval.node);\n \t\t;\n     break;}\n case 154:\n-#line 1056 \"./parse.y\"\n+#line 1061 \"./parse.y\"\n {yyval.node = parse_jdk1_1_error (\"explicit constructor invocation\"); ;\n     break;}\n case 155:\n-#line 1058 \"./parse.y\"\n+#line 1063 \"./parse.y\"\n {yyval.node = parse_jdk1_1_error (\"explicit constructor invocation\"); ;\n     break;}\n case 156:\n-#line 1063 \"./parse.y\"\n+#line 1068 \"./parse.y\"\n {\n \t\t  tree wfl = build_wfl_node (this_identifier_node);\n \t\t  EXPR_WFL_LINECOL (wfl) = yyvsp[0].operator.location;\n \t\t  yyval.node = wfl;\n \t\t;\n     break;}\n case 157:\n-#line 1069 \"./parse.y\"\n+#line 1074 \"./parse.y\"\n {\n \t\t  tree wfl = build_wfl_node (super_identifier_node);\n \t\t  EXPR_WFL_LINECOL (wfl) = yyvsp[0].operator.location;\n \t\t  yyval.node = wfl;\n \t\t;\n     break;}\n case 158:\n-#line 1080 \"./parse.y\"\n+#line 1085 \"./parse.y\"\n { create_interface (0, yyvsp[0].node, NULL_TREE); ;\n     break;}\n case 159:\n-#line 1082 \"./parse.y\"\n+#line 1087 \"./parse.y\"\n {\n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n case 160:\n-#line 1086 \"./parse.y\"\n+#line 1091 \"./parse.y\"\n { create_interface (yyvsp[-2].value, yyvsp[0].node, NULL_TREE); ;\n     break;}\n case 161:\n-#line 1088 \"./parse.y\"\n+#line 1093 \"./parse.y\"\n {\n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n case 162:\n-#line 1092 \"./parse.y\"\n+#line 1097 \"./parse.y\"\n { create_interface (0, yyvsp[-1].node, yyvsp[0].node);\t;\n     break;}\n case 163:\n-#line 1094 \"./parse.y\"\n+#line 1099 \"./parse.y\"\n {\n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n case 164:\n-#line 1098 \"./parse.y\"\n+#line 1103 \"./parse.y\"\n { create_interface (yyvsp[-3].value, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 165:\n-#line 1100 \"./parse.y\"\n+#line 1105 \"./parse.y\"\n {\n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n case 166:\n-#line 1104 \"./parse.y\"\n+#line 1109 \"./parse.y\"\n {yyerror (\"'{' expected\"); RECOVER;;\n     break;}\n case 167:\n-#line 1106 \"./parse.y\"\n+#line 1111 \"./parse.y\"\n {yyerror (\"'{' expected\"); RECOVER;;\n     break;}\n case 168:\n-#line 1111 \"./parse.y\"\n+#line 1116 \"./parse.y\"\n { \n \t\t  ctxp->interface_number = 1;\n \t\t  yyval.node = build_tree_list (yyvsp[0].node, NULL_TREE);\n \t\t;\n     break;}\n case 169:\n-#line 1116 \"./parse.y\"\n+#line 1121 \"./parse.y\"\n { \n \t\t  ctxp->interface_number++;\n \t\t  yyval.node = chainon (yyvsp[-2].node, build_tree_list (yyvsp[0].node, NULL_TREE));\n \t\t;\n     break;}\n case 170:\n-#line 1121 \"./parse.y\"\n+#line 1126 \"./parse.y\"\n {yyerror (\"Invalid interface type\"); RECOVER;;\n     break;}\n case 171:\n-#line 1123 \"./parse.y\"\n+#line 1128 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 172:\n-#line 1128 \"./parse.y\"\n+#line 1133 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 173:\n-#line 1130 \"./parse.y\"\n+#line 1135 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 178:\n-#line 1142 \"./parse.y\"\n+#line 1147 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"inner class declaration\"); ;\n     break;}\n case 179:\n-#line 1144 \"./parse.y\"\n+#line 1149 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"inner interface declaration\"); ;\n     break;}\n case 181:\n-#line 1153 \"./parse.y\"\n+#line 1158 \"./parse.y\"\n { \n \t\t  check_abstract_method_header (yyvsp[-1].node);\n \t\t  current_function_decl = NULL_TREE; /* FIXME ? */\n \t\t;\n     break;}\n case 182:\n-#line 1158 \"./parse.y\"\n+#line 1163 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 183:\n-#line 1164 \"./parse.y\"\n+#line 1169 \"./parse.y\"\n { yyval.node = build_new_array_init (yyvsp[-1].operator.location, NULL_TREE); ;\n     break;}\n case 184:\n-#line 1166 \"./parse.y\"\n+#line 1171 \"./parse.y\"\n { yyval.node = build_new_array_init (yyvsp[-2].operator.location, yyvsp[-1].node); ;\n     break;}\n case 185:\n-#line 1168 \"./parse.y\"\n+#line 1173 \"./parse.y\"\n { yyval.node = build_new_array_init (yyvsp[-3].operator.location, yyvsp[-2].node); ;\n     break;}\n case 186:\n-#line 1173 \"./parse.y\"\n+#line 1178 \"./parse.y\"\n { \n \t\t  yyval.node = tree_cons (maybe_build_array_element_wfl (yyvsp[0].node), \n \t\t\t\t  yyvsp[0].node, NULL_TREE);\n \t\t;\n     break;}\n case 187:\n-#line 1178 \"./parse.y\"\n+#line 1183 \"./parse.y\"\n {\n \t\t  yyval.node = tree_cons (maybe_build_array_element_wfl (yyvsp[0].node), yyvsp[0].node, yyvsp[-2].node);\n \t\t;\n     break;}\n case 188:\n-#line 1182 \"./parse.y\"\n+#line 1187 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 189:\n-#line 1188 \"./parse.y\"\n+#line 1193 \"./parse.y\"\n { \n \t\t  /* Store the location of the `}' when doing xrefs */\n \t\t  if (current_function_decl && flag_emit_xref)\n@@ -3470,15 +3475,15 @@ case 189:\n \t\t;\n     break;}\n case 190:\n-#line 1196 \"./parse.y\"\n+#line 1201 \"./parse.y\"\n { yyval.node = yyvsp[0].node; ;\n     break;}\n case 191:\n-#line 1201 \"./parse.y\"\n+#line 1206 \"./parse.y\"\n { enter_block (); ;\n     break;}\n case 192:\n-#line 1206 \"./parse.y\"\n+#line 1211 \"./parse.y\"\n { \n \t\t  maybe_absorb_scoping_blocks ();\n \t\t  /* Store the location of the `}' when doing xrefs */\n@@ -3489,35 +3494,35 @@ case 192:\n \t\t;\n     break;}\n case 196:\n-#line 1224 \"./parse.y\"\n+#line 1229 \"./parse.y\"\n { java_method_add_stmt (current_function_decl, yyvsp[0].node); ;\n     break;}\n case 197:\n-#line 1226 \"./parse.y\"\n+#line 1231 \"./parse.y\"\n { parse_jdk1_1_error (\"inner class declaration\"); ;\n     break;}\n case 199:\n-#line 1235 \"./parse.y\"\n+#line 1240 \"./parse.y\"\n { declare_local_variables (0, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 200:\n-#line 1237 \"./parse.y\"\n+#line 1242 \"./parse.y\"\n { declare_local_variables (yyvsp[-2].value, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 206:\n-#line 1247 \"./parse.y\"\n+#line 1252 \"./parse.y\"\n { yyval.node = exit_block (); ;\n     break;}\n case 211:\n-#line 1256 \"./parse.y\"\n+#line 1261 \"./parse.y\"\n { yyval.node = exit_block (); ;\n     break;}\n case 223:\n-#line 1275 \"./parse.y\"\n+#line 1280 \"./parse.y\"\n { yyval.node = empty_stmt_node; ;\n     break;}\n case 224:\n-#line 1280 \"./parse.y\"\n+#line 1285 \"./parse.y\"\n {\n \t\t  yyval.node = build_labeled_block (EXPR_WFL_LINECOL (yyvsp[-1].node), \n \t\t\t\t\t    EXPR_WFL_NODE (yyvsp[-1].node));\n@@ -3527,19 +3532,19 @@ case 224:\n \t\t;\n     break;}\n case 225:\n-#line 1291 \"./parse.y\"\n+#line 1296 \"./parse.y\"\n { yyval.node = finish_labeled_statement (yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 226:\n-#line 1293 \"./parse.y\"\n+#line 1298 \"./parse.y\"\n {yyerror (\"':' expected\"); RECOVER;;\n     break;}\n case 227:\n-#line 1298 \"./parse.y\"\n+#line 1303 \"./parse.y\"\n { yyval.node = finish_labeled_statement (yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 228:\n-#line 1305 \"./parse.y\"\n+#line 1310 \"./parse.y\"\n {\n \t\t  /* We have a statement. Generate a WFL around it so\n \t\t     we can debug it */\n@@ -3550,108 +3555,108 @@ case 228:\n \t\t;\n     break;}\n case 229:\n-#line 1314 \"./parse.y\"\n+#line 1319 \"./parse.y\"\n {\n \t\t  if (ctxp->prevent_ese != lineno)\n \t\t    yyerror (\"Invalid expression statement\");\n \t\t  DRECOVER (expr_stmt);\n \t\t;\n     break;}\n case 230:\n-#line 1320 \"./parse.y\"\n+#line 1325 \"./parse.y\"\n {\n \t\t  if (ctxp->prevent_ese != lineno)\n \t\t    yyerror (\"Invalid expression statement\");\n \t\t  DRECOVER (expr_stmt);\n \t\t;\n     break;}\n case 231:\n-#line 1326 \"./parse.y\"\n+#line 1331 \"./parse.y\"\n {\n \t\t  if (ctxp->prevent_ese != lineno)\n \t\t    yyerror (\"Invalid expression statement\");\n \t\t  DRECOVER (expr_stmt);\n \t\t;\n     break;}\n case 232:\n-#line 1332 \"./parse.y\"\n+#line 1337 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 233:\n-#line 1334 \"./parse.y\"\n+#line 1339 \"./parse.y\"\n {\n \t\t  yyerror (\"Constructor invocation must be first \"\n \t\t\t   \"thing in a constructor\"); \n \t\t  RECOVER;\n \t\t;\n     break;}\n case 234:\n-#line 1340 \"./parse.y\"\n+#line 1345 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 235:\n-#line 1342 \"./parse.y\"\n+#line 1347 \"./parse.y\"\n {\n \t\t  yyerror (\"Constructor invocation must be first \"\n \t\t\t   \"thing in a constructor\"); \n \t\t  RECOVER;\n \t\t;\n     break;}\n case 236:\n-#line 1348 \"./parse.y\"\n+#line 1353 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 237:\n-#line 1350 \"./parse.y\"\n+#line 1355 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 238:\n-#line 1352 \"./parse.y\"\n+#line 1357 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 239:\n-#line 1354 \"./parse.y\"\n+#line 1359 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 240:\n-#line 1356 \"./parse.y\"\n+#line 1361 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 248:\n-#line 1371 \"./parse.y\"\n+#line 1376 \"./parse.y\"\n { \n \t\t  yyval.node = build_if_else_statement (yyvsp[-3].operator.location, yyvsp[-2].node, \n \t\t\t\t\t\tyyvsp[0].node, NULL_TREE);\n \t\t;\n     break;}\n case 249:\n-#line 1376 \"./parse.y\"\n+#line 1381 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 250:\n-#line 1378 \"./parse.y\"\n+#line 1383 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 251:\n-#line 1380 \"./parse.y\"\n+#line 1385 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 252:\n-#line 1385 \"./parse.y\"\n+#line 1390 \"./parse.y\"\n { yyval.node = build_if_else_statement (yyvsp[-5].operator.location, yyvsp[-4].node, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 253:\n-#line 1390 \"./parse.y\"\n+#line 1395 \"./parse.y\"\n { yyval.node = build_if_else_statement (yyvsp[-5].operator.location, yyvsp[-4].node, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 254:\n-#line 1395 \"./parse.y\"\n+#line 1400 \"./parse.y\"\n {\n \t\t  enter_block ();\n \t\t;\n     break;}\n case 255:\n-#line 1399 \"./parse.y\"\n+#line 1404 \"./parse.y\"\n { \n \t\t  /* Make into \"proper list\" of COMPOUND_EXPRs.\n \t\t     I.e. make the last statment also have its own\n@@ -3662,112 +3667,112 @@ case 255:\n \t\t;\n     break;}\n case 256:\n-#line 1411 \"./parse.y\"\n+#line 1416 \"./parse.y\"\n { \n \t\t  yyval.node = build (SWITCH_EXPR, NULL_TREE, yyvsp[-1].node, NULL_TREE);\n \t\t  EXPR_WFL_LINECOL (yyval.node) = yyvsp[-2].operator.location;\n \t\t;\n     break;}\n case 257:\n-#line 1416 \"./parse.y\"\n+#line 1421 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 258:\n-#line 1418 \"./parse.y\"\n+#line 1423 \"./parse.y\"\n {yyerror (\"Missing term or ')'\"); DRECOVER(switch_statement);;\n     break;}\n case 259:\n-#line 1420 \"./parse.y\"\n+#line 1425 \"./parse.y\"\n {yyerror (\"'{' expected\"); RECOVER;;\n     break;}\n case 260:\n-#line 1428 \"./parse.y\"\n+#line 1433 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 261:\n-#line 1430 \"./parse.y\"\n+#line 1435 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 262:\n-#line 1432 \"./parse.y\"\n+#line 1437 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 263:\n-#line 1434 \"./parse.y\"\n+#line 1439 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 269:\n-#line 1453 \"./parse.y\"\n+#line 1458 \"./parse.y\"\n { \n \t\t  tree lab = build1 (CASE_EXPR, NULL_TREE, yyvsp[-1].node);\n \t\t  EXPR_WFL_LINECOL (lab) = yyvsp[-2].operator.location;\n \t\t  java_method_add_stmt (current_function_decl, lab);\n \t\t;\n     break;}\n case 270:\n-#line 1459 \"./parse.y\"\n+#line 1464 \"./parse.y\"\n { \n \t\t  tree lab = build1 (DEFAULT_EXPR, NULL_TREE, NULL_TREE);\n \t\t  EXPR_WFL_LINECOL (lab) = yyvsp[-1].operator.location;\n \t\t  java_method_add_stmt (current_function_decl, lab);\n \t\t;\n     break;}\n case 271:\n-#line 1465 \"./parse.y\"\n+#line 1470 \"./parse.y\"\n {yyerror (\"Missing or invalid constant expression\"); RECOVER;;\n     break;}\n case 272:\n-#line 1467 \"./parse.y\"\n+#line 1472 \"./parse.y\"\n {yyerror (\"':' expected\"); RECOVER;;\n     break;}\n case 273:\n-#line 1469 \"./parse.y\"\n+#line 1474 \"./parse.y\"\n {yyerror (\"':' expected\"); RECOVER;;\n     break;}\n case 274:\n-#line 1474 \"./parse.y\"\n+#line 1479 \"./parse.y\"\n { \n \t\t  tree body = build_loop_body (yyvsp[-2].operator.location, yyvsp[-1].node, 0);\n \t\t  yyval.node = build_new_loop (body);\n \t\t;\n     break;}\n case 275:\n-#line 1482 \"./parse.y\"\n+#line 1487 \"./parse.y\"\n { yyval.node = finish_loop_body (0, NULL_TREE, yyvsp[0].node, 0); ;\n     break;}\n case 276:\n-#line 1484 \"./parse.y\"\n+#line 1489 \"./parse.y\"\n {YYERROR_NOW; yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 277:\n-#line 1486 \"./parse.y\"\n+#line 1491 \"./parse.y\"\n {yyerror (\"Missing term and ')' expected\"); RECOVER;;\n     break;}\n case 278:\n-#line 1488 \"./parse.y\"\n+#line 1493 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 279:\n-#line 1493 \"./parse.y\"\n+#line 1498 \"./parse.y\"\n { yyval.node = finish_loop_body (0, NULL_TREE, yyvsp[0].node, 0); ;\n     break;}\n case 280:\n-#line 1498 \"./parse.y\"\n+#line 1503 \"./parse.y\"\n { \n \t\t  tree body = build_loop_body (0, NULL_TREE, 1);\n \t\t  yyval.node = build_new_loop (body);\n \t\t;\n     break;}\n case 281:\n-#line 1507 \"./parse.y\"\n+#line 1512 \"./parse.y\"\n { yyval.node = finish_loop_body (yyvsp[-3].operator.location, yyvsp[-2].node, yyvsp[-5].node, 1); ;\n     break;}\n case 282:\n-#line 1512 \"./parse.y\"\n+#line 1517 \"./parse.y\"\n { yyval.node = finish_for_loop (EXPR_WFL_LINECOL (yyvsp[-4].node), yyvsp[-4].node, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 283:\n-#line 1514 \"./parse.y\"\n+#line 1519 \"./parse.y\"\n { \n \t\t  yyval.node = finish_for_loop (0, NULL_TREE, yyvsp[-2].node, yyvsp[0].node);\n \t\t  /* We have not condition, so we get rid of the EXIT_EXPR */\n@@ -3776,23 +3781,23 @@ case 283:\n \t\t;\n     break;}\n case 284:\n-#line 1521 \"./parse.y\"\n+#line 1526 \"./parse.y\"\n {yyerror (\"Invalid control expression\"); RECOVER;;\n     break;}\n case 285:\n-#line 1523 \"./parse.y\"\n+#line 1528 \"./parse.y\"\n {yyerror (\"Invalid update expression\"); RECOVER;;\n     break;}\n case 286:\n-#line 1525 \"./parse.y\"\n+#line 1530 \"./parse.y\"\n {yyerror (\"Invalid update expression\"); RECOVER;;\n     break;}\n case 287:\n-#line 1530 \"./parse.y\"\n+#line 1535 \"./parse.y\"\n { yyval.node = finish_for_loop (EXPR_WFL_LINECOL (yyvsp[-4].node), yyvsp[-4].node, yyvsp[-2].node, yyvsp[0].node);;\n     break;}\n case 288:\n-#line 1532 \"./parse.y\"\n+#line 1537 \"./parse.y\"\n { \n \t\t  yyval.node = finish_for_loop (0, NULL_TREE, yyvsp[-2].node, yyvsp[0].node);\n \t\t  /* We have not condition, so we get rid of the EXIT_EXPR */\n@@ -3801,23 +3806,23 @@ case 288:\n \t\t;\n     break;}\n case 289:\n-#line 1542 \"./parse.y\"\n+#line 1547 \"./parse.y\"\n { \n \t\t  /* This scope defined for local variable that may be\n                      defined within the scope of the for loop */\n \t\t  enter_block (); \n \t\t;\n     break;}\n case 290:\n-#line 1548 \"./parse.y\"\n+#line 1553 \"./parse.y\"\n {yyerror (\"'(' expected\"); DRECOVER(for_1);;\n     break;}\n case 291:\n-#line 1550 \"./parse.y\"\n+#line 1555 \"./parse.y\"\n {yyerror (\"Invalid init statement\"); RECOVER;;\n     break;}\n case 292:\n-#line 1555 \"./parse.y\"\n+#line 1560 \"./parse.y\"\n { \n \t\t  /* We now declare the loop body. The loop is\n                      declared as a for loop. */\n@@ -3830,179 +3835,179 @@ case 292:\n \t\t;\n     break;}\n case 293:\n-#line 1567 \"./parse.y\"\n+#line 1572 \"./parse.y\"\n { yyval.node = empty_stmt_node; ;\n     break;}\n case 294:\n-#line 1569 \"./parse.y\"\n+#line 1574 \"./parse.y\"\n { \n \t\t  /* Init statement recorded within the previously\n                      defined block scope */\n \t\t  yyval.node = java_method_add_stmt (current_function_decl, yyvsp[0].node);\n \t\t;\n     break;}\n case 295:\n-#line 1575 \"./parse.y\"\n+#line 1580 \"./parse.y\"\n { \n \t\t  /* Local variable are recorded within the previously\n \t\t     defined block scope */\n \t\t  yyval.node = NULL_TREE;\n \t\t;\n     break;}\n case 296:\n-#line 1581 \"./parse.y\"\n+#line 1586 \"./parse.y\"\n {yyerror (\"';' expected\"); DRECOVER(for_init_1);;\n     break;}\n case 297:\n-#line 1585 \"./parse.y\"\n+#line 1590 \"./parse.y\"\n {yyval.node = empty_stmt_node;;\n     break;}\n case 298:\n-#line 1587 \"./parse.y\"\n+#line 1592 \"./parse.y\"\n { yyval.node = build_debugable_stmt (BUILD_LOCATION (), yyvsp[0].node); ;\n     break;}\n case 299:\n-#line 1592 \"./parse.y\"\n+#line 1597 \"./parse.y\"\n { yyval.node = add_stmt_to_compound (NULL_TREE, NULL_TREE, yyvsp[0].node); ;\n     break;}\n case 300:\n-#line 1594 \"./parse.y\"\n+#line 1599 \"./parse.y\"\n { yyval.node = add_stmt_to_compound (yyvsp[-2].node, NULL_TREE, yyvsp[0].node); ;\n     break;}\n case 301:\n-#line 1596 \"./parse.y\"\n+#line 1601 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 302:\n-#line 1601 \"./parse.y\"\n+#line 1606 \"./parse.y\"\n { yyval.node = build_bc_statement (yyvsp[-1].operator.location, 1, NULL_TREE); ;\n     break;}\n case 303:\n-#line 1603 \"./parse.y\"\n+#line 1608 \"./parse.y\"\n { yyval.node = build_bc_statement (yyvsp[-2].operator.location, 1, yyvsp[-1].node); ;\n     break;}\n case 304:\n-#line 1605 \"./parse.y\"\n+#line 1610 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 305:\n-#line 1607 \"./parse.y\"\n+#line 1612 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 306:\n-#line 1612 \"./parse.y\"\n+#line 1617 \"./parse.y\"\n { yyval.node = build_bc_statement (yyvsp[-1].operator.location, 0, NULL_TREE); ;\n     break;}\n case 307:\n-#line 1614 \"./parse.y\"\n+#line 1619 \"./parse.y\"\n { yyval.node = build_bc_statement (yyvsp[-2].operator.location, 0, yyvsp[-1].node); ;\n     break;}\n case 308:\n-#line 1616 \"./parse.y\"\n+#line 1621 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 309:\n-#line 1618 \"./parse.y\"\n+#line 1623 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 310:\n-#line 1623 \"./parse.y\"\n+#line 1628 \"./parse.y\"\n { yyval.node = build_return (yyvsp[-1].operator.location, NULL_TREE); ;\n     break;}\n case 311:\n-#line 1625 \"./parse.y\"\n+#line 1630 \"./parse.y\"\n { yyval.node = build_return (yyvsp[-2].operator.location, yyvsp[-1].node); ;\n     break;}\n case 312:\n-#line 1627 \"./parse.y\"\n+#line 1632 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 313:\n-#line 1629 \"./parse.y\"\n+#line 1634 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 314:\n-#line 1634 \"./parse.y\"\n+#line 1639 \"./parse.y\"\n { \n \t\t  yyval.node = build1 (THROW_EXPR, NULL_TREE, yyvsp[-1].node);\n \t\t  EXPR_WFL_LINECOL (yyval.node) = yyvsp[-2].operator.location;\n \t\t;\n     break;}\n case 315:\n-#line 1639 \"./parse.y\"\n+#line 1644 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 316:\n-#line 1641 \"./parse.y\"\n+#line 1646 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 317:\n-#line 1646 \"./parse.y\"\n+#line 1651 \"./parse.y\"\n { \n \t\t  yyval.node = build (SYNCHRONIZED_EXPR, NULL_TREE, yyvsp[-2].node, yyvsp[0].node);\n \t\t  EXPR_WFL_LINECOL (yyval.node) = \n \t\t    EXPR_WFL_LINECOL (MODIFIER_WFL (SYNCHRONIZED_TK));\n \t\t;\n     break;}\n case 318:\n-#line 1652 \"./parse.y\"\n+#line 1657 \"./parse.y\"\n {yyerror (\"'{' expected\"); RECOVER;;\n     break;}\n case 319:\n-#line 1654 \"./parse.y\"\n+#line 1659 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 320:\n-#line 1656 \"./parse.y\"\n+#line 1661 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 321:\n-#line 1658 \"./parse.y\"\n+#line 1663 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 322:\n-#line 1663 \"./parse.y\"\n+#line 1668 \"./parse.y\"\n {\n \t\t  if ((1 << yyvsp[0].value) != ACC_SYNCHRONIZED)\n \t\t    fatal (\"synchronized was '%d' - yyparse\", (1 << yyvsp[0].value));\n \t\t;\n     break;}\n case 323:\n-#line 1671 \"./parse.y\"\n+#line 1676 \"./parse.y\"\n { yyval.node = build_try_statement (yyvsp[-2].operator.location, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 324:\n-#line 1673 \"./parse.y\"\n+#line 1678 \"./parse.y\"\n { yyval.node = build_try_finally_statement (yyvsp[-2].operator.location, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 325:\n-#line 1675 \"./parse.y\"\n+#line 1680 \"./parse.y\"\n { yyval.node = build_try_finally_statement \n \t\t    (yyvsp[-3].operator.location, build_try_statement (yyvsp[-3].operator.location,\n \t\t\t\t\t\t       yyvsp[-2].node, yyvsp[-1].node), yyvsp[0].node);\n \t\t;\n     break;}\n case 326:\n-#line 1680 \"./parse.y\"\n+#line 1685 \"./parse.y\"\n {yyerror (\"'{' expected\"); DRECOVER (try_statement);;\n     break;}\n case 328:\n-#line 1686 \"./parse.y\"\n+#line 1691 \"./parse.y\"\n { \n \t\t  TREE_CHAIN (yyvsp[0].node) = yyvsp[-1].node;\n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n case 329:\n-#line 1694 \"./parse.y\"\n+#line 1699 \"./parse.y\"\n { \n \t\t  java_method_add_stmt (current_function_decl, yyvsp[0].node);\n \t\t  exit_block ();\n \t\t  yyval.node = yyvsp[-1].node;\n \t\t;\n     break;}\n case 330:\n-#line 1702 \"./parse.y\"\n+#line 1707 \"./parse.y\"\n { \n \t\t  /* We add a block to define a scope for\n \t\t     formal_parameter (CCBP). The formal parameter is\n@@ -4020,184 +4025,184 @@ case 330:\n \t\t;\n     break;}\n case 331:\n-#line 1718 \"./parse.y\"\n+#line 1723 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 332:\n-#line 1720 \"./parse.y\"\n+#line 1725 \"./parse.y\"\n {yyerror (\"Missing term or ')' expected\"); DRECOVER (2);;\n     break;}\n case 333:\n-#line 1722 \"./parse.y\"\n+#line 1727 \"./parse.y\"\n {yyerror (\"')' expected\"); DRECOVER (1);;\n     break;}\n case 334:\n-#line 1727 \"./parse.y\"\n+#line 1732 \"./parse.y\"\n { yyval.node = yyvsp[0].node; ;\n     break;}\n case 335:\n-#line 1729 \"./parse.y\"\n+#line 1734 \"./parse.y\"\n {yyerror (\"'{' expected\"); RECOVER; ;\n     break;}\n case 339:\n-#line 1741 \"./parse.y\"\n+#line 1746 \"./parse.y\"\n { yyval.node = build_this (yyvsp[0].operator.location); ;\n     break;}\n case 340:\n-#line 1743 \"./parse.y\"\n+#line 1748 \"./parse.y\"\n {yyval.node = yyvsp[-1].node;;\n     break;}\n case 345:\n-#line 1752 \"./parse.y\"\n+#line 1757 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"named class literals\"); ;\n     break;}\n case 346:\n-#line 1754 \"./parse.y\"\n+#line 1759 \"./parse.y\"\n { yyval.node = build_class_ref (yyvsp[-2].node); ;\n     break;}\n case 347:\n-#line 1756 \"./parse.y\"\n+#line 1761 \"./parse.y\"\n { yyval.node = build_class_ref (void_type_node); ;\n     break;}\n case 348:\n-#line 1761 \"./parse.y\"\n+#line 1766 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"class literals\"); ;\n     break;}\n case 349:\n-#line 1763 \"./parse.y\"\n+#line 1768 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 350:\n-#line 1765 \"./parse.y\"\n+#line 1770 \"./parse.y\"\n {yyerror (\"'class' or 'this' expected\" ); RECOVER;;\n     break;}\n case 351:\n-#line 1767 \"./parse.y\"\n+#line 1772 \"./parse.y\"\n {yyerror (\"'class' expected\" ); RECOVER;;\n     break;}\n case 352:\n-#line 1769 \"./parse.y\"\n+#line 1774 \"./parse.y\"\n {yyerror (\"'class' expected\" ); RECOVER;;\n     break;}\n case 353:\n-#line 1774 \"./parse.y\"\n+#line 1779 \"./parse.y\"\n { yyval.node = build_new_invocation (yyvsp[-3].node, yyvsp[-1].node); ;\n     break;}\n case 354:\n-#line 1776 \"./parse.y\"\n+#line 1781 \"./parse.y\"\n { yyval.node = build_new_invocation (yyvsp[-2].node, NULL_TREE); ;\n     break;}\n case 355:\n-#line 1781 \"./parse.y\"\n+#line 1786 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"inner class instance creation\"); ;\n     break;}\n case 356:\n-#line 1783 \"./parse.y\"\n+#line 1788 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"inner class instance creation\"); ;\n     break;}\n case 361:\n-#line 1792 \"./parse.y\"\n+#line 1797 \"./parse.y\"\n {yyerror (\"'(' expected\"); DRECOVER(new_1);;\n     break;}\n case 362:\n-#line 1794 \"./parse.y\"\n+#line 1799 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 363:\n-#line 1796 \"./parse.y\"\n+#line 1801 \"./parse.y\"\n {yyerror (\"')' or term expected\"); RECOVER;;\n     break;}\n case 364:\n-#line 1798 \"./parse.y\"\n+#line 1803 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 365:\n-#line 1800 \"./parse.y\"\n+#line 1805 \"./parse.y\"\n {YYERROR_NOW; yyerror (\"Identifier expected\"); RECOVER;;\n     break;}\n case 366:\n-#line 1802 \"./parse.y\"\n+#line 1807 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 369:\n-#line 1812 \"./parse.y\"\n+#line 1817 \"./parse.y\"\n { \n \t\t  yyval.node = tree_cons (NULL_TREE, yyvsp[0].node, NULL_TREE);\n \t\t  ctxp->formal_parameter_number = 1; \n \t\t;\n     break;}\n case 370:\n-#line 1817 \"./parse.y\"\n+#line 1822 \"./parse.y\"\n {\n \t\t  ctxp->formal_parameter_number += 1;\n \t\t  yyval.node = tree_cons (NULL_TREE, yyvsp[0].node, yyvsp[-2].node);\n \t\t;\n     break;}\n case 371:\n-#line 1822 \"./parse.y\"\n+#line 1827 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 372:\n-#line 1827 \"./parse.y\"\n+#line 1832 \"./parse.y\"\n { yyval.node = build_newarray_node (yyvsp[-1].node, yyvsp[0].node, 0); ;\n     break;}\n case 373:\n-#line 1829 \"./parse.y\"\n+#line 1834 \"./parse.y\"\n { yyval.node = build_newarray_node (yyvsp[-1].node, yyvsp[0].node, 0); ;\n     break;}\n case 374:\n-#line 1831 \"./parse.y\"\n+#line 1836 \"./parse.y\"\n { yyval.node = build_newarray_node (yyvsp[-2].node, yyvsp[-1].node, CURRENT_OSB (ctxp));;\n     break;}\n case 375:\n-#line 1833 \"./parse.y\"\n+#line 1838 \"./parse.y\"\n { yyval.node = build_newarray_node (yyvsp[-2].node, yyvsp[-1].node, CURRENT_OSB (ctxp));;\n     break;}\n case 376:\n-#line 1837 \"./parse.y\"\n+#line 1842 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"anonymous array\"); ;\n     break;}\n case 377:\n-#line 1839 \"./parse.y\"\n+#line 1844 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"anonymous array\"); ;\n     break;}\n case 378:\n-#line 1841 \"./parse.y\"\n+#line 1846 \"./parse.y\"\n {yyerror (\"'[' expected\"); DRECOVER (\"]\");;\n     break;}\n case 379:\n-#line 1843 \"./parse.y\"\n+#line 1848 \"./parse.y\"\n {yyerror (\"']' expected\"); RECOVER;;\n     break;}\n case 380:\n-#line 1848 \"./parse.y\"\n+#line 1853 \"./parse.y\"\n { yyval.node = build_tree_list (NULL_TREE, yyvsp[0].node); ;\n     break;}\n case 381:\n-#line 1850 \"./parse.y\"\n+#line 1855 \"./parse.y\"\n { yyval.node = tree_cons (NULL_TREE, yyvsp[0].node, yyval.node); ;\n     break;}\n case 382:\n-#line 1855 \"./parse.y\"\n+#line 1860 \"./parse.y\"\n { \n \t\t  EXPR_WFL_LINECOL (yyvsp[-1].node) = yyvsp[-2].operator.location;\n \t\t  yyval.node = yyvsp[-1].node;\n \t\t;\n     break;}\n case 383:\n-#line 1860 \"./parse.y\"\n+#line 1865 \"./parse.y\"\n {yyerror (\"']' expected\"); RECOVER;;\n     break;}\n case 384:\n-#line 1862 \"./parse.y\"\n+#line 1867 \"./parse.y\"\n {\n \t\t  yyerror (\"Missing term\");\n \t\t  yyerror (\"']' expected\");\n \t\t  RECOVER;\n \t\t;\n     break;}\n case 385:\n-#line 1871 \"./parse.y\"\n+#line 1876 \"./parse.y\"\n { \n \t\t  int allocate = 0;\n \t\t  /* If not initialized, allocate memory for the osb\n@@ -4225,19 +4230,19 @@ case 385:\n \t\t;\n     break;}\n case 386:\n-#line 1897 \"./parse.y\"\n+#line 1902 \"./parse.y\"\n { CURRENT_OSB (ctxp)++; ;\n     break;}\n case 387:\n-#line 1899 \"./parse.y\"\n+#line 1904 \"./parse.y\"\n { yyerror (\"']' expected\"); RECOVER;;\n     break;}\n case 388:\n-#line 1904 \"./parse.y\"\n+#line 1909 \"./parse.y\"\n { yyval.node = make_qualified_primary (yyvsp[-2].node, yyvsp[0].node, yyvsp[-1].operator.location); ;\n     break;}\n case 389:\n-#line 1908 \"./parse.y\"\n+#line 1913 \"./parse.y\"\n {\n \t\t  tree super_wfl = \n \t\t    build_wfl_node (super_identifier_node);\n@@ -4246,19 +4251,19 @@ case 389:\n \t\t;\n     break;}\n case 390:\n-#line 1915 \"./parse.y\"\n+#line 1920 \"./parse.y\"\n {yyerror (\"Field expected\"); DRECOVER (super_field_acces);;\n     break;}\n case 391:\n-#line 1920 \"./parse.y\"\n+#line 1925 \"./parse.y\"\n { yyval.node = build_method_invocation (yyvsp[-2].node, NULL_TREE); ;\n     break;}\n case 392:\n-#line 1922 \"./parse.y\"\n+#line 1927 \"./parse.y\"\n { yyval.node = build_method_invocation (yyvsp[-3].node, yyvsp[-1].node); ;\n     break;}\n case 393:\n-#line 1924 \"./parse.y\"\n+#line 1929 \"./parse.y\"\n { \n \t\t  if (TREE_CODE (yyvsp[-4].node) == THIS_EXPR)\n \t\t    yyval.node = build_this_super_qualified_invocation \n@@ -4271,7 +4276,7 @@ case 393:\n \t\t;\n     break;}\n case 394:\n-#line 1935 \"./parse.y\"\n+#line 1940 \"./parse.y\"\n { \n \t\t  if (TREE_CODE (yyvsp[-5].node) == THIS_EXPR)\n \t\t    yyval.node = build_this_super_qualified_invocation \n@@ -4284,121 +4289,121 @@ case 394:\n \t\t;\n     break;}\n case 395:\n-#line 1946 \"./parse.y\"\n+#line 1951 \"./parse.y\"\n { \n \t\t  yyval.node = build_this_super_qualified_invocation \n \t\t    (0, yyvsp[-2].node, NULL_TREE, yyvsp[-4].operator.location, yyvsp[-3].operator.location);\n \t\t;\n     break;}\n case 396:\n-#line 1951 \"./parse.y\"\n+#line 1956 \"./parse.y\"\n {\n \t\t  yyval.node = build_this_super_qualified_invocation \n \t\t    (0, yyvsp[-3].node, yyvsp[-1].node, yyvsp[-5].operator.location, yyvsp[-4].operator.location);\n \t\t;\n     break;}\n case 397:\n-#line 1960 \"./parse.y\"\n+#line 1965 \"./parse.y\"\n { yyerror (\"'(' expected\"); DRECOVER (method_invocation); ;\n     break;}\n case 398:\n-#line 1962 \"./parse.y\"\n+#line 1967 \"./parse.y\"\n { yyerror (\"'(' expected\"); DRECOVER (method_invocation); ;\n     break;}\n case 399:\n-#line 1967 \"./parse.y\"\n+#line 1972 \"./parse.y\"\n { yyval.node = build_array_ref (yyvsp[-2].operator.location, yyvsp[-3].node, yyvsp[-1].node); ;\n     break;}\n case 400:\n-#line 1969 \"./parse.y\"\n+#line 1974 \"./parse.y\"\n { yyval.node = build_array_ref (yyvsp[-2].operator.location, yyvsp[-3].node, yyvsp[-1].node); ;\n     break;}\n case 401:\n-#line 1971 \"./parse.y\"\n+#line 1976 \"./parse.y\"\n {\n \t\t  yyerror (\"Missing term and ']' expected\");\n \t\t  DRECOVER(array_access);\n \t\t;\n     break;}\n case 402:\n-#line 1976 \"./parse.y\"\n+#line 1981 \"./parse.y\"\n {\n \t\t  yyerror (\"']' expected\");\n \t\t  DRECOVER(array_access);\n \t\t;\n     break;}\n case 403:\n-#line 1981 \"./parse.y\"\n+#line 1986 \"./parse.y\"\n {\n \t\t  yyerror (\"Missing term and ']' expected\");\n \t\t  DRECOVER(array_access);\n \t\t;\n     break;}\n case 404:\n-#line 1986 \"./parse.y\"\n+#line 1991 \"./parse.y\"\n {\n \t\t  yyerror (\"']' expected\");\n \t\t  DRECOVER(array_access);\n \t\t;\n     break;}\n case 409:\n-#line 2001 \"./parse.y\"\n+#line 2006 \"./parse.y\"\n { yyval.node = build_incdec (yyvsp[0].operator.token, yyvsp[0].operator.location, yyvsp[-1].node, 1); ;\n     break;}\n case 410:\n-#line 2006 \"./parse.y\"\n+#line 2011 \"./parse.y\"\n { yyval.node = build_incdec (yyvsp[0].operator.token, yyvsp[0].operator.location, yyvsp[-1].node, 1); ;\n     break;}\n case 413:\n-#line 2013 \"./parse.y\"\n+#line 2018 \"./parse.y\"\n {yyval.node = build_unaryop (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node); ;\n     break;}\n case 414:\n-#line 2015 \"./parse.y\"\n+#line 2020 \"./parse.y\"\n {yyval.node = build_unaryop (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node); ;\n     break;}\n case 416:\n-#line 2018 \"./parse.y\"\n+#line 2023 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;\n     break;}\n case 417:\n-#line 2020 \"./parse.y\"\n+#line 2025 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;\n     break;}\n case 418:\n-#line 2025 \"./parse.y\"\n+#line 2030 \"./parse.y\"\n {yyval.node = build_incdec (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node, 0); ;\n     break;}\n case 419:\n-#line 2027 \"./parse.y\"\n+#line 2032 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;\n     break;}\n case 420:\n-#line 2032 \"./parse.y\"\n+#line 2037 \"./parse.y\"\n {yyval.node = build_incdec (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node, 0); ;\n     break;}\n case 421:\n-#line 2034 \"./parse.y\"\n+#line 2039 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;\n     break;}\n case 423:\n-#line 2040 \"./parse.y\"\n+#line 2045 \"./parse.y\"\n {yyval.node = build_unaryop (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node); ;\n     break;}\n case 424:\n-#line 2042 \"./parse.y\"\n+#line 2047 \"./parse.y\"\n {yyval.node = build_unaryop (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node); ;\n     break;}\n case 426:\n-#line 2045 \"./parse.y\"\n+#line 2050 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;\n     break;}\n case 427:\n-#line 2047 \"./parse.y\"\n+#line 2052 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;\n     break;}\n case 428:\n-#line 2052 \"./parse.y\"\n+#line 2057 \"./parse.y\"\n { \n \t\t  tree type = yyvsp[-3].node;\n \t\t  while (CURRENT_OSB (ctxp)--)\n@@ -4408,15 +4413,15 @@ case 428:\n \t\t;\n     break;}\n case 429:\n-#line 2060 \"./parse.y\"\n+#line 2065 \"./parse.y\"\n { yyval.node = build_cast (yyvsp[-3].operator.location, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 430:\n-#line 2062 \"./parse.y\"\n+#line 2067 \"./parse.y\"\n { yyval.node = build_cast (yyvsp[-3].operator.location, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 431:\n-#line 2064 \"./parse.y\"\n+#line 2069 \"./parse.y\"\n { \n \t\t  const char *ptr;\n \t\t  while (CURRENT_OSB (ctxp)--)\n@@ -4431,275 +4436,275 @@ case 431:\n \t\t;\n     break;}\n case 432:\n-#line 2077 \"./parse.y\"\n+#line 2082 \"./parse.y\"\n {yyerror (\"']' expected, invalid type expression\");;\n     break;}\n case 433:\n-#line 2079 \"./parse.y\"\n+#line 2084 \"./parse.y\"\n {\n \t          if (ctxp->prevent_ese != lineno)\n \t\t    yyerror (\"Invalid type expression\"); RECOVER;\n \t\t  RECOVER;\n \t\t;\n     break;}\n case 434:\n-#line 2085 \"./parse.y\"\n+#line 2090 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 435:\n-#line 2087 \"./parse.y\"\n+#line 2092 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 436:\n-#line 2089 \"./parse.y\"\n+#line 2094 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 438:\n-#line 2095 \"./parse.y\"\n+#line 2100 \"./parse.y\"\n { \n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), \n \t\t\t\t    yyvsp[-1].operator.location, yyvsp[-2].node, yyvsp[0].node);\n \t\t;\n     break;}\n case 439:\n-#line 2100 \"./parse.y\"\n+#line 2105 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 440:\n-#line 2105 \"./parse.y\"\n+#line 2110 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 441:\n-#line 2110 \"./parse.y\"\n+#line 2115 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 442:\n-#line 2112 \"./parse.y\"\n+#line 2117 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 443:\n-#line 2114 \"./parse.y\"\n+#line 2119 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 445:\n-#line 2120 \"./parse.y\"\n+#line 2125 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 446:\n-#line 2125 \"./parse.y\"\n+#line 2130 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 447:\n-#line 2130 \"./parse.y\"\n+#line 2135 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 448:\n-#line 2132 \"./parse.y\"\n+#line 2137 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 450:\n-#line 2138 \"./parse.y\"\n+#line 2143 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 451:\n-#line 2143 \"./parse.y\"\n+#line 2148 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 452:\n-#line 2148 \"./parse.y\"\n+#line 2153 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 453:\n-#line 2153 \"./parse.y\"\n+#line 2158 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 454:\n-#line 2155 \"./parse.y\"\n+#line 2160 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 455:\n-#line 2157 \"./parse.y\"\n+#line 2162 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 457:\n-#line 2163 \"./parse.y\"\n+#line 2168 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 458:\n-#line 2168 \"./parse.y\"\n+#line 2173 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 459:\n-#line 2173 \"./parse.y\"\n+#line 2178 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 460:\n-#line 2178 \"./parse.y\"\n+#line 2183 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 461:\n-#line 2183 \"./parse.y\"\n+#line 2188 \"./parse.y\"\n { yyval.node = build_binop (INSTANCEOF_EXPR, yyvsp[-1].operator.location, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 462:\n-#line 2185 \"./parse.y\"\n+#line 2190 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 463:\n-#line 2187 \"./parse.y\"\n+#line 2192 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 464:\n-#line 2189 \"./parse.y\"\n+#line 2194 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 465:\n-#line 2191 \"./parse.y\"\n+#line 2196 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 466:\n-#line 2193 \"./parse.y\"\n+#line 2198 \"./parse.y\"\n {yyerror (\"Invalid reference type\"); RECOVER;;\n     break;}\n case 468:\n-#line 2199 \"./parse.y\"\n+#line 2204 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 469:\n-#line 2204 \"./parse.y\"\n+#line 2209 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 470:\n-#line 2209 \"./parse.y\"\n+#line 2214 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 471:\n-#line 2211 \"./parse.y\"\n+#line 2216 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 473:\n-#line 2217 \"./parse.y\"\n+#line 2222 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 474:\n-#line 2222 \"./parse.y\"\n+#line 2227 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 476:\n-#line 2228 \"./parse.y\"\n+#line 2233 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 477:\n-#line 2233 \"./parse.y\"\n+#line 2238 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 479:\n-#line 2239 \"./parse.y\"\n+#line 2244 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 480:\n-#line 2244 \"./parse.y\"\n+#line 2249 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 482:\n-#line 2250 \"./parse.y\"\n+#line 2255 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 483:\n-#line 2255 \"./parse.y\"\n+#line 2260 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 485:\n-#line 2261 \"./parse.y\"\n+#line 2266 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 486:\n-#line 2266 \"./parse.y\"\n+#line 2271 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 488:\n-#line 2272 \"./parse.y\"\n+#line 2277 \"./parse.y\"\n {\n \t\t  yyval.node = build (CONDITIONAL_EXPR, NULL_TREE, yyvsp[-4].node, yyvsp[-2].node, yyvsp[0].node);\n \t\t  EXPR_WFL_LINECOL (yyval.node) = yyvsp[-3].operator.location;\n \t\t;\n     break;}\n case 489:\n-#line 2277 \"./parse.y\"\n+#line 2282 \"./parse.y\"\n {\n \t\t  YYERROR_NOW;\n \t\t  yyerror (\"Missing term\");\n \t\t  DRECOVER (1);\n \t\t;\n     break;}\n case 490:\n-#line 2283 \"./parse.y\"\n+#line 2288 \"./parse.y\"\n {yyerror (\"Missing term\"); DRECOVER (2);;\n     break;}\n case 491:\n-#line 2285 \"./parse.y\"\n+#line 2290 \"./parse.y\"\n {yyerror (\"Missing term\"); DRECOVER (3);;\n     break;}\n case 494:\n-#line 2295 \"./parse.y\"\n+#line 2300 \"./parse.y\"\n { yyval.node = build_assignment (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 495:\n-#line 2297 \"./parse.y\"\n+#line 2302 \"./parse.y\"\n {\n \t\t  if (ctxp->prevent_ese != lineno)\n \t\t    yyerror (\"Missing term\");\n@@ -4708,7 +4713,7 @@ case 495:\n     break;}\n }\n    /* the action file gets copied in in place of this dollarsign */\n-#line 498 \"/usr/local/gnu/share/bison.simple\"\n+#line 498 \"/usr/cygnus/gnupro-98r1/share/bison.simple\"\n \f\n   yyvsp -= yylen;\n   yyssp -= yylen;\n@@ -4904,7 +4909,7 @@ case 495:\n   yystate = yyn;\n   goto yynewstate;\n }\n-#line 2323 \"./parse.y\"\n+#line 2328 \"./parse.y\"\n \n \f\n \n@@ -10464,8 +10469,7 @@ java_stabilize_reference (node)\n       TREE_OPERAND (node, 1) = java_stabilize_reference (op1);\n       return node;\n     }\n-  else\n-    return stabilize_reference (node);\n+  return stabilize_reference (node);\n }\n \n /* Patch tree nodes in a function body. When a BLOCK is found, push\n@@ -10915,14 +10919,17 @@ java_complete_lhs (node)\n       if (TREE_OPERAND (node, 0) == error_mark_node)\n \treturn error_mark_node;\n \n-      if (COMPOUND_ASSIGN_P (wfl_op2))\n+      flag = COMPOUND_ASSIGN_P (wfl_op2);\n+      if (flag)\n \t{\n \t  tree lvalue = java_stabilize_reference (TREE_OPERAND (node, 0)); \n \n \t  /* Hand stablize the lhs on both places */\n \t  TREE_OPERAND (node, 0) = lvalue;\n-\t  TREE_OPERAND (TREE_OPERAND (node, 1), 0) = lvalue;\n+\t  TREE_OPERAND (TREE_OPERAND (node, 1), 0) = \n+\t    (flag_emit_class_files ? lvalue : save_expr (lvalue));\n \n+\t  /* 15.25.2.a: Left hand is not an array access. FIXME */\n \t  /* Now complete the RHS. We write it back later on. */\n \t  nn = java_complete_tree (TREE_OPERAND (node, 1));\n \n@@ -10933,6 +10940,8 @@ java_complete_lhs (node)\n \t     E1 = (T)(E1 op E2), with T being the type of E1. */\n \t  nn = java_complete_tree (build_cast (EXPR_WFL_LINECOL (wfl_op2), \n \t\t\t\t\t       TREE_TYPE (lvalue), nn));\n+\n+\t  /* 15.25.2.b: Left hand is an array access. FIXME */\n \t}\n \n       /* If we're about to patch a NEW_ARRAY_INIT, we call a special\n@@ -10956,6 +10965,10 @@ java_complete_lhs (node)\n       if ((nn = patch_string (TREE_OPERAND (node, 1))))\n \tTREE_OPERAND (node, 1) = nn;\n       node = patch_assignment (node, wfl_op1, wfl_op2);\n+      /* Reorganize the tree if necessary. */\n+      if (flag && (!JREFERENCE_TYPE_P (TREE_TYPE (node)) \n+\t\t   || JSTRING_P (TREE_TYPE (node))))\n+\tnode = java_refold (node);\n       CAN_COMPLETE_NORMALLY (node) = 1;\n       return node;\n \n@@ -11964,6 +11977,81 @@ operator_string (node)\n #undef BUILD_OPERATOR_STRING\n }\n \n+/* Return 1 if VAR_ACCESS1 is equivalent to VAR_ACCESS2.  */\n+\n+static int\n+java_decl_equiv (var_acc1, var_acc2)\n+     tree var_acc1, var_acc2;\n+{\n+  if (JDECL_P (var_acc1))\n+    return (var_acc1 == var_acc2);\n+  \n+  return (TREE_CODE (var_acc1) == COMPONENT_REF\n+\t  && TREE_CODE (var_acc2) == COMPONENT_REF\n+\t  && TREE_OPERAND (TREE_OPERAND (var_acc1, 0), 0)\n+\t     == TREE_OPERAND (TREE_OPERAND (var_acc2, 0), 0)\n+\t  && TREE_OPERAND (var_acc1, 1) == TREE_OPERAND (var_acc2, 1));\n+}\n+\n+/* Return a non zero value if CODE is one of the operators that can be\n+   used in conjunction with the `=' operator in a compound assignment.  */\n+\n+static int\n+binop_compound_p (code)\n+    enum tree_code code;\n+{\n+  int i;\n+  for (i = 0; i < BINOP_COMPOUND_CANDIDATES; i++)\n+    if (binop_lookup [i] == code)\n+      break;\n+\n+  return i < BINOP_COMPOUND_CANDIDATES;\n+}\n+\n+/* Reorganize after a fold to get SAVE_EXPR to generate what we want.  */\n+\n+static tree\n+java_refold (t)\n+     tree t;\n+{\n+  tree c, b, ns, decl;\n+\n+  if (TREE_CODE (t) != MODIFY_EXPR)\n+    return t;\n+\n+  c = TREE_OPERAND (t, 1);\n+  if (! (c && TREE_CODE (c) == COMPOUND_EXPR\n+\t && TREE_CODE (TREE_OPERAND (c, 0)) == MODIFY_EXPR\n+\t && binop_compound_p (TREE_CODE (TREE_OPERAND (c, 1)))))\n+    return t;\n+\n+  /* Now the left branch of the binary operator. */\n+  b = TREE_OPERAND (TREE_OPERAND (c, 1), 0);\n+  if (! (b && TREE_CODE (b) == NOP_EXPR \n+\t && TREE_CODE (TREE_OPERAND (b, 0)) == SAVE_EXPR))\n+    return t;\n+\n+  ns = TREE_OPERAND (TREE_OPERAND (b, 0), 0);\n+  if (! (ns && TREE_CODE (ns) == NOP_EXPR\n+\t && TREE_CODE (TREE_OPERAND (ns, 0)) == SAVE_EXPR))\n+    return t;\n+\n+  decl = TREE_OPERAND (TREE_OPERAND (ns, 0), 0);\n+  if ((JDECL_P (decl) || TREE_CODE (decl) == COMPONENT_REF)\n+      /* It's got to be the an equivalent decl */\n+      && java_decl_equiv (decl, TREE_OPERAND (TREE_OPERAND (c, 0), 0)))\n+    {\n+      /* Shorten the NOP_EXPR/SAVE_EXPR path. */\n+      TREE_OPERAND (TREE_OPERAND (c, 1), 0) = TREE_OPERAND (ns, 0);\n+      /* Substitute the COMPOUND_EXPR by the BINOP_EXPR */\n+      TREE_OPERAND (t, 1) = TREE_OPERAND (c, 1);\n+      /* Change the right part of the BINOP_EXPR */\n+      TREE_OPERAND (TREE_OPERAND (t, 1), 1) = TREE_OPERAND (c, 0);\n+    }\n+\n+  return t;\n+}\n+\n /* Binary operators (15.16 up to 15.18). We return error_mark_node on\n    errors but we modify NODE so that it contains the type computed\n    according to the expression, when it's fixed. Otherwise, we write\n@@ -12628,7 +12716,7 @@ patch_unaryop (node, wfl_op)\n     case PREINCREMENT_EXPR:\n       /* 15.14.2 Prefix Decrement Operator -- */\n     case PREDECREMENT_EXPR:\n-      decl = strip_out_static_field_access_decl (op);\n+      op = decl = strip_out_static_field_access_decl (op);\n       /* We really should have a JAVA_ARRAY_EXPR to avoid this */\n       if (!JDECL_P (decl) \n \t  && TREE_CODE (decl) != COMPONENT_REF\n@@ -12667,15 +12755,28 @@ patch_unaryop (node, wfl_op)\n       else\n \t{\n \t  /* Before the addition, binary numeric promotion is performed on\n-\t     both operands */\n-\t  value = build_int_2 (1, 0);\n-\t  TREE_TYPE (node) = \n-\t    binary_numeric_promotion (op_type, TREE_TYPE (value), &op, &value);\n-\t  /* And write the promoted incremented and increment */\n+\t     both operands, if really necessary */\n+\t  if (JINTEGRAL_TYPE_P (op_type))\n+\t    {\n+\t      value = build_int_2 (1, 0);\n+\t      TREE_TYPE (value) = TREE_TYPE (node) = op_type;\n+\t    }\n+\t  else\n+\t    {\n+\t      value = build_int_2 (1, 0);\n+\t      TREE_TYPE (node) = \n+\t\tbinary_numeric_promotion (op_type, \n+\t\t\t\t\t  TREE_TYPE (value), &op, &value);\n+\t    }\n+\t  /* And write back into the node. */\n \t  TREE_OPERAND (node, 0) = op;\n \t  TREE_OPERAND (node, 1) = value;\n-\t  /* Convert the overall back into its original type. */\n-\t  return fold (convert (op_type, node));\n+\t  /* Convert the overall back into its original type, if\n+             necessary, and return */\n+\t  if (JINTEGRAL_TYPE_P (op_type))\n+\t    return fold (node);\n+\t  else\n+\t    return fold (convert (op_type, node));\n \t}\n       break;\n \n@@ -13533,6 +13634,54 @@ finish_for_loop (location, condition, update, body)\n   return loop;\n }\n \n+/* Try to find the loop a block might be related to. This comprises\n+   the case where the LOOP_EXPR is found as the second operand of a\n+   COMPOUND_EXPR, because the loop happens to have an initialization\n+   part, then expressed as the first operand of the COMPOUND_EXPR. If\n+   the search finds something, 1 is returned. Otherwise, 0 is\n+   returned. The search is assumed to start from a\n+   LABELED_BLOCK_EXPR's block.  */\n+\n+static tree\n+search_loop (statement)\n+    tree statement;\n+{\n+  if (TREE_CODE (statement) == LOOP_EXPR)\n+    return statement;\n+\n+  if (TREE_CODE (statement) == BLOCK)\n+    statement = BLOCK_SUBBLOCKS (statement);\n+  else\n+    return NULL_TREE;\n+\n+  if (statement && TREE_CODE (statement) == COMPOUND_EXPR)\n+    while (statement && TREE_CODE (statement) == COMPOUND_EXPR)\n+      statement = TREE_OPERAND (statement, 1);\n+\n+  return (TREE_CODE (statement) == LOOP_EXPR\n+\t  && IS_FOR_LOOP_P (statement) ? statement : NULL_TREE);\n+}\n+\n+/* Return 1 if LOOP can be found in the labeled block BLOCK. 0 is\n+   returned otherwise.  */\n+\n+static int\n+labeled_block_contains_loop_p (block, loop)\n+    tree block, loop;\n+{\n+  if (!block)\n+    return 0;\n+\n+  if (LABELED_BLOCK_BODY (block) == loop)\n+    return 1;\n+\n+  if (IS_FOR_LOOP_P (loop) \n+      && search_loop (LABELED_BLOCK_BODY (block)) == loop)\n+    return 1;\n+\n+  return 0;\n+}\n+\n /* If the loop isn't surrounded by a labeled statement, create one and\n    insert LOOP as its body.  */\n \n@@ -13541,33 +13690,17 @@ patch_loop_statement (loop)\n      tree loop;\n {\n   tree loop_label;\n-  tree block = ctxp->current_labeled_block;\n+\n   TREE_TYPE (loop) = void_type_node;\n-  if (block != NULL_TREE)\n-    {\n-      tree block_body = LABELED_BLOCK_BODY (block);\n-      if (IS_FOR_LOOP_P (loop))\n-\t{\n-\t  if (TREE_CODE (block_body) == BLOCK)\n-\t    {\n-\t      block_body = BLOCK_EXPR_BODY (block_body);\n-\t      if (block_body == loop\n-\t\t  || (TREE_CODE (block_body) == COMPOUND_EXPR\n-\t\t      && TREE_OPERAND (block_body, 1) == loop))\n-\t\treturn loop;\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  if (block_body == loop)\n-\t    return loop;\n-\t}\n-    }\n+  if (labeled_block_contains_loop_p (ctxp->current_labeled_block, loop))\n+    return loop;\n+\n   loop_label = build_labeled_block (0, NULL_TREE);\n+  /* LOOP is an EXPR node, so it should have a valid EXPR_WFL_LINECOL\n+     that LOOP_LABEL could enquire about, for a better accuracy. FIXME */\n   LABELED_BLOCK_BODY (loop_label) = loop;\n   PUSH_LABELED_BLOCK (loop_label);\n-  loop = loop_label;\n-  return loop;\n+  return loop_label;\n }\n \n /* 14.13, 14.14: break and continue Statements */\n@@ -13659,7 +13792,7 @@ patch_bc_statement (node)\n \t    }\n \t  target_stmt = LABELED_BLOCK_BODY (labeled_block);\n \t  if (TREE_CODE (target_stmt) == SWITCH_EXPR\n-\t      || TREE_CODE (target_stmt) == LOOP_EXPR)\n+\t      || search_loop (target_stmt))\n \t    {\n \t      bc_label = labeled_block;\n \t      break;\n@@ -13673,7 +13806,7 @@ patch_bc_statement (node)\n   /* Our break/continue don't return values. */\n   TREE_TYPE (node) = void_type_node;\n   /* Encapsulate the break within a compound statement so that it's\n-     expanded all the times by expand_expr (and not clobered\n+     expanded all the times by expand_expr (and not clobbered\n      sometimes, like after a if statement) */\n   node = add_stmt_to_compound (NULL_TREE, void_type_node, node);\n   TREE_SIDE_EFFECTS (node) = 1;"}, {"sha": "1c63bfd193984256a12f6a3dcf4b60e5dd034241", "filename": "gcc/java/parse.y", "status": "modified", "additions": 170, "deletions": 37, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cbdba642487ff5d1502727b039a1bcccca7d196/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cbdba642487ff5d1502727b039a1bcccca7d196/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=5cbdba642487ff5d1502727b039a1bcccca7d196", "patch": "@@ -257,6 +257,7 @@ static tree do_unary_numeric_promotion PROTO ((tree));\n static char * operator_string PROTO ((tree));\n static tree do_merge_string_cste PROTO ((tree, const char *, int, int));\n static tree merge_string_cste PROTO ((tree, tree, int));\n+static tree java_refold PROTO ((tree));\n \n /* Number of error found so far. */\n int java_error_count; \n@@ -288,6 +289,10 @@ static enum tree_code binop_lookup[19] =\n   binop_lookup [((VALUE) - PLUS_TK)%\t\t\t\t\t\\\n \t\t(sizeof (binop_lookup) / sizeof (binop_lookup[0]))]\n \n+/* This is the end index for binary operators that can also be used\n+   in compound assignements. */\n+#define BINOP_COMPOUND_CANDIDATES 11\n+\n /* Fake WFL used to report error message. It is initialized once if\n    needed and reused with it's location information is overriden.  */\n tree wfl_operator = NULL_TREE;\n@@ -7879,8 +7884,7 @@ java_stabilize_reference (node)\n       TREE_OPERAND (node, 1) = java_stabilize_reference (op1);\n       return node;\n     }\n-  else\n-    return stabilize_reference (node);\n+  return stabilize_reference (node);\n }\n \n /* Patch tree nodes in a function body. When a BLOCK is found, push\n@@ -8330,14 +8334,17 @@ java_complete_lhs (node)\n       if (TREE_OPERAND (node, 0) == error_mark_node)\n \treturn error_mark_node;\n \n-      if (COMPOUND_ASSIGN_P (wfl_op2))\n+      flag = COMPOUND_ASSIGN_P (wfl_op2);\n+      if (flag)\n \t{\n \t  tree lvalue = java_stabilize_reference (TREE_OPERAND (node, 0)); \n \n \t  /* Hand stablize the lhs on both places */\n \t  TREE_OPERAND (node, 0) = lvalue;\n-\t  TREE_OPERAND (TREE_OPERAND (node, 1), 0) = lvalue;\n+\t  TREE_OPERAND (TREE_OPERAND (node, 1), 0) = \n+\t    (flag_emit_class_files ? lvalue : save_expr (lvalue));\n \n+\t  /* 15.25.2.a: Left hand is not an array access. FIXME */\n \t  /* Now complete the RHS. We write it back later on. */\n \t  nn = java_complete_tree (TREE_OPERAND (node, 1));\n \n@@ -8348,6 +8355,8 @@ java_complete_lhs (node)\n \t     E1 = (T)(E1 op E2), with T being the type of E1. */\n \t  nn = java_complete_tree (build_cast (EXPR_WFL_LINECOL (wfl_op2), \n \t\t\t\t\t       TREE_TYPE (lvalue), nn));\n+\n+\t  /* 15.25.2.b: Left hand is an array access. FIXME */\n \t}\n \n       /* If we're about to patch a NEW_ARRAY_INIT, we call a special\n@@ -8371,6 +8380,10 @@ java_complete_lhs (node)\n       if ((nn = patch_string (TREE_OPERAND (node, 1))))\n \tTREE_OPERAND (node, 1) = nn;\n       node = patch_assignment (node, wfl_op1, wfl_op2);\n+      /* Reorganize the tree if necessary. */\n+      if (flag && (!JREFERENCE_TYPE_P (TREE_TYPE (node)) \n+\t\t   || JSTRING_P (TREE_TYPE (node))))\n+\tnode = java_refold (node);\n       CAN_COMPLETE_NORMALLY (node) = 1;\n       return node;\n \n@@ -9379,6 +9392,81 @@ operator_string (node)\n #undef BUILD_OPERATOR_STRING\n }\n \n+/* Return 1 if VAR_ACCESS1 is equivalent to VAR_ACCESS2.  */\n+\n+static int\n+java_decl_equiv (var_acc1, var_acc2)\n+     tree var_acc1, var_acc2;\n+{\n+  if (JDECL_P (var_acc1))\n+    return (var_acc1 == var_acc2);\n+  \n+  return (TREE_CODE (var_acc1) == COMPONENT_REF\n+\t  && TREE_CODE (var_acc2) == COMPONENT_REF\n+\t  && TREE_OPERAND (TREE_OPERAND (var_acc1, 0), 0)\n+\t     == TREE_OPERAND (TREE_OPERAND (var_acc2, 0), 0)\n+\t  && TREE_OPERAND (var_acc1, 1) == TREE_OPERAND (var_acc2, 1));\n+}\n+\n+/* Return a non zero value if CODE is one of the operators that can be\n+   used in conjunction with the `=' operator in a compound assignment.  */\n+\n+static int\n+binop_compound_p (code)\n+    enum tree_code code;\n+{\n+  int i;\n+  for (i = 0; i < BINOP_COMPOUND_CANDIDATES; i++)\n+    if (binop_lookup [i] == code)\n+      break;\n+\n+  return i < BINOP_COMPOUND_CANDIDATES;\n+}\n+\n+/* Reorganize after a fold to get SAVE_EXPR to generate what we want.  */\n+\n+static tree\n+java_refold (t)\n+     tree t;\n+{\n+  tree c, b, ns, decl;\n+\n+  if (TREE_CODE (t) != MODIFY_EXPR)\n+    return t;\n+\n+  c = TREE_OPERAND (t, 1);\n+  if (! (c && TREE_CODE (c) == COMPOUND_EXPR\n+\t && TREE_CODE (TREE_OPERAND (c, 0)) == MODIFY_EXPR\n+\t && binop_compound_p (TREE_CODE (TREE_OPERAND (c, 1)))))\n+    return t;\n+\n+  /* Now the left branch of the binary operator. */\n+  b = TREE_OPERAND (TREE_OPERAND (c, 1), 0);\n+  if (! (b && TREE_CODE (b) == NOP_EXPR \n+\t && TREE_CODE (TREE_OPERAND (b, 0)) == SAVE_EXPR))\n+    return t;\n+\n+  ns = TREE_OPERAND (TREE_OPERAND (b, 0), 0);\n+  if (! (ns && TREE_CODE (ns) == NOP_EXPR\n+\t && TREE_CODE (TREE_OPERAND (ns, 0)) == SAVE_EXPR))\n+    return t;\n+\n+  decl = TREE_OPERAND (TREE_OPERAND (ns, 0), 0);\n+  if ((JDECL_P (decl) || TREE_CODE (decl) == COMPONENT_REF)\n+      /* It's got to be the an equivalent decl */\n+      && java_decl_equiv (decl, TREE_OPERAND (TREE_OPERAND (c, 0), 0)))\n+    {\n+      /* Shorten the NOP_EXPR/SAVE_EXPR path. */\n+      TREE_OPERAND (TREE_OPERAND (c, 1), 0) = TREE_OPERAND (ns, 0);\n+      /* Substitute the COMPOUND_EXPR by the BINOP_EXPR */\n+      TREE_OPERAND (t, 1) = TREE_OPERAND (c, 1);\n+      /* Change the right part of the BINOP_EXPR */\n+      TREE_OPERAND (TREE_OPERAND (t, 1), 1) = TREE_OPERAND (c, 0);\n+    }\n+\n+  return t;\n+}\n+\n /* Binary operators (15.16 up to 15.18). We return error_mark_node on\n    errors but we modify NODE so that it contains the type computed\n    according to the expression, when it's fixed. Otherwise, we write\n@@ -10043,7 +10131,7 @@ patch_unaryop (node, wfl_op)\n     case PREINCREMENT_EXPR:\n       /* 15.14.2 Prefix Decrement Operator -- */\n     case PREDECREMENT_EXPR:\n-      decl = strip_out_static_field_access_decl (op);\n+      op = decl = strip_out_static_field_access_decl (op);\n       /* We really should have a JAVA_ARRAY_EXPR to avoid this */\n       if (!JDECL_P (decl) \n \t  && TREE_CODE (decl) != COMPONENT_REF\n@@ -10082,15 +10170,28 @@ patch_unaryop (node, wfl_op)\n       else\n \t{\n \t  /* Before the addition, binary numeric promotion is performed on\n-\t     both operands */\n-\t  value = build_int_2 (1, 0);\n-\t  TREE_TYPE (node) = \n-\t    binary_numeric_promotion (op_type, TREE_TYPE (value), &op, &value);\n-\t  /* And write the promoted incremented and increment */\n+\t     both operands, if really necessary */\n+\t  if (JINTEGRAL_TYPE_P (op_type))\n+\t    {\n+\t      value = build_int_2 (1, 0);\n+\t      TREE_TYPE (value) = TREE_TYPE (node) = op_type;\n+\t    }\n+\t  else\n+\t    {\n+\t      value = build_int_2 (1, 0);\n+\t      TREE_TYPE (node) = \n+\t\tbinary_numeric_promotion (op_type, \n+\t\t\t\t\t  TREE_TYPE (value), &op, &value);\n+\t    }\n+\t  /* And write back into the node. */\n \t  TREE_OPERAND (node, 0) = op;\n \t  TREE_OPERAND (node, 1) = value;\n-\t  /* Convert the overall back into its original type. */\n-\t  return fold (convert (op_type, node));\n+\t  /* Convert the overall back into its original type, if\n+             necessary, and return */\n+\t  if (JINTEGRAL_TYPE_P (op_type))\n+\t    return fold (node);\n+\t  else\n+\t    return fold (convert (op_type, node));\n \t}\n       break;\n \n@@ -10948,6 +11049,54 @@ finish_for_loop (location, condition, update, body)\n   return loop;\n }\n \n+/* Try to find the loop a block might be related to. This comprises\n+   the case where the LOOP_EXPR is found as the second operand of a\n+   COMPOUND_EXPR, because the loop happens to have an initialization\n+   part, then expressed as the first operand of the COMPOUND_EXPR. If\n+   the search finds something, 1 is returned. Otherwise, 0 is\n+   returned. The search is assumed to start from a\n+   LABELED_BLOCK_EXPR's block.  */\n+\n+static tree\n+search_loop (statement)\n+    tree statement;\n+{\n+  if (TREE_CODE (statement) == LOOP_EXPR)\n+    return statement;\n+\n+  if (TREE_CODE (statement) == BLOCK)\n+    statement = BLOCK_SUBBLOCKS (statement);\n+  else\n+    return NULL_TREE;\n+\n+  if (statement && TREE_CODE (statement) == COMPOUND_EXPR)\n+    while (statement && TREE_CODE (statement) == COMPOUND_EXPR)\n+      statement = TREE_OPERAND (statement, 1);\n+\n+  return (TREE_CODE (statement) == LOOP_EXPR\n+\t  && IS_FOR_LOOP_P (statement) ? statement : NULL_TREE);\n+}\n+\n+/* Return 1 if LOOP can be found in the labeled block BLOCK. 0 is\n+   returned otherwise.  */\n+\n+static int\n+labeled_block_contains_loop_p (block, loop)\n+    tree block, loop;\n+{\n+  if (!block)\n+    return 0;\n+\n+  if (LABELED_BLOCK_BODY (block) == loop)\n+    return 1;\n+\n+  if (IS_FOR_LOOP_P (loop) \n+      && search_loop (LABELED_BLOCK_BODY (block)) == loop)\n+    return 1;\n+\n+  return 0;\n+}\n+\n /* If the loop isn't surrounded by a labeled statement, create one and\n    insert LOOP as its body.  */\n \n@@ -10956,33 +11105,17 @@ patch_loop_statement (loop)\n      tree loop;\n {\n   tree loop_label;\n-  tree block = ctxp->current_labeled_block;\n+\n   TREE_TYPE (loop) = void_type_node;\n-  if (block != NULL_TREE)\n-    {\n-      tree block_body = LABELED_BLOCK_BODY (block);\n-      if (IS_FOR_LOOP_P (loop))\n-\t{\n-\t  if (TREE_CODE (block_body) == BLOCK)\n-\t    {\n-\t      block_body = BLOCK_EXPR_BODY (block_body);\n-\t      if (block_body == loop\n-\t\t  || (TREE_CODE (block_body) == COMPOUND_EXPR\n-\t\t      && TREE_OPERAND (block_body, 1) == loop))\n-\t\treturn loop;\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  if (block_body == loop)\n-\t    return loop;\n-\t}\n-    }\n+  if (labeled_block_contains_loop_p (ctxp->current_labeled_block, loop))\n+    return loop;\n+\n   loop_label = build_labeled_block (0, NULL_TREE);\n+  /* LOOP is an EXPR node, so it should have a valid EXPR_WFL_LINECOL\n+     that LOOP_LABEL could enquire about, for a better accuracy. FIXME */\n   LABELED_BLOCK_BODY (loop_label) = loop;\n   PUSH_LABELED_BLOCK (loop_label);\n-  loop = loop_label;\n-  return loop;\n+  return loop_label;\n }\n \n /* 14.13, 14.14: break and continue Statements */\n@@ -11074,7 +11207,7 @@ patch_bc_statement (node)\n \t    }\n \t  target_stmt = LABELED_BLOCK_BODY (labeled_block);\n \t  if (TREE_CODE (target_stmt) == SWITCH_EXPR\n-\t      || TREE_CODE (target_stmt) == LOOP_EXPR)\n+\t      || search_loop (target_stmt))\n \t    {\n \t      bc_label = labeled_block;\n \t      break;\n@@ -11088,7 +11221,7 @@ patch_bc_statement (node)\n   /* Our break/continue don't return values. */\n   TREE_TYPE (node) = void_type_node;\n   /* Encapsulate the break within a compound statement so that it's\n-     expanded all the times by expand_expr (and not clobered\n+     expanded all the times by expand_expr (and not clobbered\n      sometimes, like after a if statement) */\n   node = add_stmt_to_compound (NULL_TREE, void_type_node, node);\n   TREE_SIDE_EFFECTS (node) = 1;"}]}