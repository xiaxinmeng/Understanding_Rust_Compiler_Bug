{"sha": "89fdaf5ad853c3d55060b9929027946833aee77a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODlmZGFmNWFkODUzYzNkNTUwNjBiOTkyOTAyNzk0NjgzM2FlZTc3YQ==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-06-03T13:26:25Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-06-16T21:31:24Z"}, "message": "d: Use new isTypeXxxx helpers where possible.\n\ngcc/d/ChangeLog:\n\n\t* d-builtins.cc (d_eval_constant_expression): Use isTypeXxxx helpers\n\tinstead of explicit casts.\n\t(d_build_builtins_module): Likewise.\n\t* d-codegen.cc (get_array_length): Likewise.\n\t(identity_compare_p): Likewise.\n\t(lower_struct_comparison): Likewise.\n\t(build_array_from_val): Likewise.\n\t(array_bounds_check): Likewise.\n\t(get_function_type): Likewise.\n\t(d_build_call): Likewise.\n\t* d-compiler.cc (Compiler::paintAsType): Likewise.\n\t* d-convert.cc (convert_expr): Likewise.\n\t(convert_for_assignment): Likewise.\n\t* d-lang.cc (d_classify_record): Likewise.\n\t(d_build_eh_runtime_type): Likewise.\n\t* decl.cc (DeclVisitor::visit): Likewise.\n\t* expr.cc (ExprVisitor::needs_postblit): Likewise.\n\t(ExprVisitor::needs_dtor): Likewise.\n\t(ExprVisitor::visit): Likewise.\n\t* imports.cc (ImportVisitor::visit): Likewise.\n\t* typeinfo.cc (get_typeinfo_kind): Likewise.\n\t(TypeInfoVisitor::visit): Likewise.\n\t(TypeDeclInfoVisitor::visit): Likewise.\n\t* types.cc (merge_aggregate_types): Likewise.\n\t(TypeVisitor::visit): Likewise.", "tree": {"sha": "bd31fe1405120ce155c606fb258d6944e6a6be6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd31fe1405120ce155c606fb258d6944e6a6be6b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89fdaf5ad853c3d55060b9929027946833aee77a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89fdaf5ad853c3d55060b9929027946833aee77a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89fdaf5ad853c3d55060b9929027946833aee77a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89fdaf5ad853c3d55060b9929027946833aee77a/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8fb4d1d58362b77da78c09740c6b5562124a369e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fb4d1d58362b77da78c09740c6b5562124a369e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8fb4d1d58362b77da78c09740c6b5562124a369e"}], "stats": {"total": 202, "additions": 82, "deletions": 120}, "files": [{"sha": "f1bdcb9fafd60af800d2a0732dae083ce682aef7", "filename": "gcc/d/d-builtins.cc", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89fdaf5ad853c3d55060b9929027946833aee77a/gcc%2Fd%2Fd-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89fdaf5ad853c3d55060b9929027946833aee77a/gcc%2Fd%2Fd-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-builtins.cc?ref=89fdaf5ad853c3d55060b9929027946833aee77a", "patch": "@@ -388,7 +388,7 @@ d_eval_constant_expression (tree cst)\n \t    }\n \n \t  Expression *e = ArrayLiteralExp::create (Loc (), elements);\n-\t  e->type = ((TypeVector *) type)->basetype;\n+\t  e->type = type->isTypeVector ()->basetype;\n \n \t  return VectorExp::create (Loc (), e, type);\n \t}\n@@ -517,8 +517,8 @@ d_build_builtins_module (Module *m)\n   for (size_t i = 0; vec_safe_iterate (gcc_builtins_functions, i, &decl); ++i)\n     {\n       const char *name = IDENTIFIER_POINTER (DECL_NAME (decl));\n-      TypeFunction *tf\n-\t= (TypeFunction *) build_frontend_type (TREE_TYPE (decl));\n+      Type *t = build_frontend_type (TREE_TYPE (decl));\n+      TypeFunction *tf = t ? t->isTypeFunction () : NULL;\n \n       /* Cannot create built-in function type for DECL.  */\n       if (!tf)\n@@ -601,14 +601,13 @@ d_build_builtins_module (Module *m)\n \n   /* Expose target-specific va_list type.  */\n   Type *tvalist = target.va_listType (Loc (), NULL);\n-  StructDeclaration *sd = (tvalist->ty == Tstruct)\n-    ? ((TypeStruct *) tvalist)->sym : NULL;\n-  if (sd == NULL || !sd->isAnonymous ())\n+  TypeStruct *ts = tvalist->isTypeStruct ();\n+  if (ts == NULL || !ts->sym->isAnonymous ())\n     members->push (build_alias_declaration (\"__builtin_va_list\", tvalist));\n   else\n     {\n-      sd->ident = Identifier::idPool (\"__builtin_va_list\");\n-      members->push (sd);\n+      ts->sym->ident = Identifier::idPool (\"__builtin_va_list\");\n+      members->push (ts->sym);\n     }\n \n   /* Expose target-specific integer types to the builtins module.  */"}, {"sha": "1bf74e1f223effa44997c7d53f8cb7678dc12225", "filename": "gcc/d/d-codegen.cc", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89fdaf5ad853c3d55060b9929027946833aee77a/gcc%2Fd%2Fd-codegen.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89fdaf5ad853c3d55060b9929027946833aee77a/gcc%2Fd%2Fd-codegen.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-codegen.cc?ref=89fdaf5ad853c3d55060b9929027946833aee77a", "patch": "@@ -319,7 +319,7 @@ get_array_length (tree exp, Type *type)\n   switch (tb->ty)\n     {\n     case Tsarray:\n-      return size_int (((TypeSArray *) tb)->dim->toUInteger ());\n+      return size_int (tb->isTypeSArray ()->dim->toUInteger ());\n \n     case Tarray:\n       return d_array_length (exp);\n@@ -812,9 +812,8 @@ identity_compare_p (StructDeclaration *sd)\n       Type *tb = vd->type->toBasetype ();\n \n       /* Check inner data structures.  */\n-      if (tb->ty == Tstruct)\n+      if (TypeStruct *ts = tb->isTypeStruct ())\n \t{\n-\t  TypeStruct *ts = (TypeStruct *) tb;\n \t  if (!identity_compare_p (ts->sym))\n \t    return false;\n \t}\n@@ -897,11 +896,10 @@ lower_struct_comparison (tree_code code, StructDeclaration *sd,\n       tree t2ref = component_ref (t2, sfield);\n       tree tcmp;\n \n-      if (type->ty == Tstruct)\n+      if (TypeStruct *ts = type->isTypeStruct ())\n \t{\n \t  /* Compare inner data structures.  */\n-\t  StructDeclaration *decl = ((TypeStruct *) type)->sym;\n-\t  tcmp = lower_struct_comparison (code, decl, t1ref, t2ref);\n+\t  tcmp = lower_struct_comparison (code, ts->sym, t1ref, t2ref);\n \t}\n       else if (type->ty != Tvector && type->isintegral ())\n \t{\n@@ -1680,15 +1678,13 @@ build_array_set (tree ptr, tree length, tree value)\n tree\n build_array_from_val (Type *type, tree val)\n {\n-  gcc_assert (type->ty == Tsarray);\n-\n   tree etype = build_ctype (type->nextOf ());\n \n   /* Initializing a multidimensional array.  */\n   if (TREE_CODE (etype) == ARRAY_TYPE && TREE_TYPE (val) != etype)\n     val = build_array_from_val (type->nextOf (), val);\n \n-  size_t dims = ((TypeSArray *) type)->dim->toInteger ();\n+  size_t dims = type->isTypeSArray ()->dim->toInteger ();\n   vec<constructor_elt, va_gc> *elms = NULL;\n   vec_safe_reserve (elms, dims);\n \n@@ -1762,8 +1758,7 @@ array_bounds_check (void)\n       fd = d_function_chain->function;\n       if (fd && fd->type->ty == Tfunction)\n \t{\n-\t  TypeFunction *tf = (TypeFunction *) fd->type;\n-\t  if (tf->trust == TRUSTsafe)\n+\t  if (fd->type->isTypeFunction ()->trust == TRUSTsafe)\n \t    return true;\n \t}\n       return false;\n@@ -1783,9 +1778,9 @@ get_function_type (Type *t)\n   if (t->ty == Tpointer)\n     t = t->nextOf ()->toBasetype ();\n   if (t->ty == Tfunction)\n-    tf = (TypeFunction *) t;\n+    tf = t->isTypeFunction ();\n   else if (t->ty == Tdelegate)\n-    tf = (TypeFunction *) ((TypeDelegate *) t)->next;\n+    tf = t->isTypeDelegate ()->next->isTypeFunction ();\n   return tf;\n }\n \n@@ -1916,8 +1911,7 @@ d_build_call (TypeFunction *tf, tree callable, tree object,\n \t  if (TREE_ADDRESSABLE (TREE_TYPE (targ)))\n \t    {\n \t      Type *t = arg->type->toBasetype ();\n-\t      gcc_assert (t->ty == Tstruct);\n-\t      StructDeclaration *sd = ((TypeStruct *) t)->sym;\n+\t      StructDeclaration *sd = t->isTypeStruct ()->sym;\n \n \t      /* Nested structs also have ADDRESSABLE set, but if the type has\n \t\t neither a copy constructor nor a destructor available, then we"}, {"sha": "75ca15737d94e18d90a6ab074db0dd24784425f9", "filename": "gcc/d/d-compiler.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89fdaf5ad853c3d55060b9929027946833aee77a/gcc%2Fd%2Fd-compiler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89fdaf5ad853c3d55060b9929027946833aee77a/gcc%2Fd%2Fd-compiler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-compiler.cc?ref=89fdaf5ad853c3d55060b9929027946833aee77a", "patch": "@@ -111,7 +111,7 @@ Compiler::paintAsType (UnionExp *, Expression *expr, Type *type)\n \t}\n \n       /* Build vector type.  */\n-      int nunits = ((TypeSArray *) expr->type)->dim->toUInteger ();\n+      int nunits = expr->type->isTypeSArray ()->dim->toUInteger ();\n       Type *telem = expr->type->nextOf ();\n       tree vectype = build_vector_type (build_ctype (telem), nunits);\n \n@@ -127,7 +127,7 @@ Compiler::paintAsType (UnionExp *, Expression *expr, Type *type)\n     {\n       /* Interpret value as a vector of the same size,\n \t then return the array literal.  */\n-      int nunits = ((TypeSArray *) type)->dim->toUInteger ();\n+      int nunits = type->isTypeSArray ()->dim->toUInteger ();\n       Type *elem = type->nextOf ();\n       tree vectype = build_vector_type (build_ctype (elem), nunits);\n "}, {"sha": "80101f17b1d71ce9d5a5421384eff9f8a723a020", "filename": "gcc/d/d-convert.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89fdaf5ad853c3d55060b9929027946833aee77a/gcc%2Fd%2Fd-convert.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89fdaf5ad853c3d55060b9929027946833aee77a/gcc%2Fd%2Fd-convert.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-convert.cc?ref=89fdaf5ad853c3d55060b9929027946833aee77a", "patch": "@@ -467,7 +467,7 @@ convert_expr (tree exp, Type *etype, Type *totype)\n \t}\n       else if (tbtype->ty == Tarray)\n \t{\n-\t  dinteger_t dim = ((TypeSArray *) ebtype)->dim->toInteger ();\n+\t  dinteger_t dim = ebtype->isTypeSArray ()->dim->toInteger ();\n \t  dinteger_t esize = ebtype->nextOf ()->size ();\n \t  dinteger_t tsize = tbtype->nextOf ()->size ();\n \n@@ -616,7 +616,7 @@ convert_for_assignment (tree expr, Type *etype, Type *totype)\n \n       if (same_type_p (telem, ebtype))\n \t{\n-\t  TypeSArray *sa_type = (TypeSArray *) tbtype;\n+\t  TypeSArray *sa_type = tbtype->isTypeSArray ();\n \t  uinteger_t count = sa_type->dim->toUInteger ();\n \n \t  tree ctor = build_constructor (build_ctype (totype), NULL);"}, {"sha": "5266a6550dc3315e69f6f86f79a14c399ea7905a", "filename": "gcc/d/d-lang.cc", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89fdaf5ad853c3d55060b9929027946833aee77a/gcc%2Fd%2Fd-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89fdaf5ad853c3d55060b9929027946833aee77a/gcc%2Fd%2Fd-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-lang.cc?ref=89fdaf5ad853c3d55060b9929027946833aee77a", "patch": "@@ -1672,11 +1672,10 @@ static classify_record\n d_classify_record (tree type)\n {\n   Type *t = TYPE_LANG_FRONTEND (type);\n+  TypeClass *tc = t ? t->isTypeClass () : NULL;\n \n-  if (t && t->ty == Tclass)\n+  if (tc != NULL)\n     {\n-      TypeClass *tc = (TypeClass *) t;\n-\n       /* extern(C++) interfaces get emitted as classes.  */\n       if (tc->sym->isInterfaceDeclaration ()\n \t  && !tc->sym->isCPPinterface ())\n@@ -1814,12 +1813,10 @@ static tree\n d_build_eh_runtime_type (tree type)\n {\n   Type *t = TYPE_LANG_FRONTEND (type);\n+  gcc_assert (t != NULL);\n+  t = t->toBasetype ();\n \n-  if (t != NULL)\n-    t = t->toBasetype ();\n-\n-  gcc_assert (t != NULL && t->ty == Tclass);\n-  ClassDeclaration *cd = ((TypeClass *) t)->sym;\n+  ClassDeclaration *cd = t->isTypeClass ()->sym;\n   tree decl;\n \n   if (cd->isCPPclass ())"}, {"sha": "05868631eedd663225023dcc99857848bb213030", "filename": "gcc/d/decl.cc", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89fdaf5ad853c3d55060b9929027946833aee77a/gcc%2Fd%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89fdaf5ad853c3d55060b9929027946833aee77a/gcc%2Fd%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdecl.cc?ref=89fdaf5ad853c3d55060b9929027946833aee77a", "patch": "@@ -313,9 +313,9 @@ class DeclVisitor : public Visitor\n     TemplateInstance *ti = NULL;\n \n     if (tb->ty == Tstruct)\n-      ti = ((TypeStruct *) tb)->sym->isInstantiated ();\n+      ti = tb->isTypeStruct ()->sym->isInstantiated ();\n     else if (tb->ty == Tclass)\n-      ti = ((TypeClass *) tb)->sym->isInstantiated ();\n+      ti = tb->isTypeClass ()->sym->isInstantiated ();\n \n     /* Return type is instantiated from this template declaration, walk over\n        all members of the instance.  */\n@@ -620,7 +620,7 @@ class DeclVisitor : public Visitor\n     if (have_typeinfo_p (Type::dtypeinfo))\n       create_typeinfo (d->type, NULL);\n \n-    TypeEnum *tc = (TypeEnum *) d->type;\n+    TypeEnum *tc = d->type->isTypeEnum ();\n     if (tc->sym->members && !d->type->isZeroInit ())\n       {\n \t/* Generate static initializer.  */\n@@ -717,11 +717,8 @@ class DeclVisitor : public Visitor\n \t  }\n \telse\n \t  {\n-\t    if (d->type->ty == Tstruct)\n-\t      {\n-\t\tStructDeclaration *sd = ((TypeStruct *) d->type)->sym;\n-\t\tDECL_INITIAL (decl) = layout_struct_initializer (sd);\n-\t      }\n+\t    if (TypeStruct *ts = d->type->isTypeStruct ())\n+\t      DECL_INITIAL (decl) = layout_struct_initializer (ts->sym);\n \t    else\n \t      {\n \t\tExpression *e = d->type->defaultInitLiteral (d->loc);\n@@ -813,9 +810,8 @@ class DeclVisitor : public Visitor\n       return;\n \n     /* Check if any errors occurred when running semantic.  */\n-    if (d->type->ty == Tfunction)\n+    if (TypeFunction *tf = d->type->isTypeFunction ())\n       {\n-\tTypeFunction *tf = (TypeFunction *) d->type;\n \tif (tf->next == NULL || tf->next->ty == Terror)\n \t  return;\n       }"}, {"sha": "9c80db15552ae94c16a99de20241804bb3d1bf06", "filename": "gcc/d/expr.cc", "status": "modified", "additions": 29, "deletions": 42, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89fdaf5ad853c3d55060b9929027946833aee77a/gcc%2Fd%2Fexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89fdaf5ad853c3d55060b9929027946833aee77a/gcc%2Fd%2Fexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fexpr.cc?ref=89fdaf5ad853c3d55060b9929027946833aee77a", "patch": "@@ -62,10 +62,9 @@ class ExprVisitor : public Visitor\n   {\n     t = t->baseElemOf ();\n \n-    if (t->ty == Tstruct)\n+    if (TypeStruct *ts = t->isTypeStruct ())\n       {\n-\tStructDeclaration *sd = ((TypeStruct *) t)->sym;\n-\tif (sd->postblit)\n+\tif (ts->sym->postblit)\n \t  return true;\n       }\n \n@@ -78,10 +77,9 @@ class ExprVisitor : public Visitor\n   {\n     t = t->baseElemOf ();\n \n-    if (t->ty == Tstruct)\n+    if (TypeStruct *ts = t->isTypeStruct ())\n       {\n-\tStructDeclaration *sd = ((TypeStruct *) t)->sym;\n-\tif (sd->dtor)\n+\tif (ts->sym->dtor)\n \t  return true;\n       }\n \n@@ -298,17 +296,16 @@ class ExprVisitor : public Visitor\n \t      this->result_ = build_boolop (TRUTH_ORIF_EXPR, req, ieq);\n \t  }\n       }\n-    else if (tb1->ty == Tstruct)\n+    else if (TypeStruct *ts = tb1->isTypeStruct ())\n       {\n \t/* For struct objects, identity is defined as bits in operands being\n \t   identical also.  Alignment holes in structs are ignored.  */\n-\tStructDeclaration *sd = ((TypeStruct *) tb1)->sym;\n \ttree t1 = build_expr (e->e1);\n \ttree t2 = build_expr (e->e2);\n \n \tgcc_assert (same_type_p (tb1, tb2));\n \n-\tthis->result_ = build_struct_comparison (code, sd, t1, t2);\n+\tthis->result_ = build_struct_comparison (code, ts->sym, t1, t2);\n       }\n     else\n       {\n@@ -345,7 +342,7 @@ class ExprVisitor : public Visitor\n \t    Or when generating a NE expression:\n \t\te1.length != e2.length || memcmp(e1.ptr, e2.ptr, size) != 0;  */\n \tif ((t1elem->isintegral () || t1elem->ty == Tvoid\n-\t     || (t1elem->ty == Tstruct && !((TypeStruct *)t1elem)->sym->xeq))\n+\t     || (t1elem->ty == Tstruct && !t1elem->isTypeStruct ()->sym->xeq))\n \t    && t1elem->ty == t2elem->ty)\n \t  {\n \t    tree t1 = d_array_convert (e->e1);\n@@ -367,7 +364,7 @@ class ExprVisitor : public Visitor\n \t    /* Compare arrays using memcmp if possible, otherwise for structs,\n \t       each field is compared inline.  */\n \t    if (t1elem->ty != Tstruct\n-\t\t|| identity_compare_p (((TypeStruct *) t1elem)->sym))\n+\t\t|| identity_compare_p (t1elem->isTypeStruct ()->sym))\n \t      {\n \t\ttree size = size_mult_expr (t1len, size_int (t1elem->size ()));\n \t\ttree tmemcmp = builtin_decl_explicit (BUILT_IN_MEMCMP);\n@@ -377,7 +374,7 @@ class ExprVisitor : public Visitor\n \t      }\n \t    else\n \t      {\n-\t\tStructDeclaration *sd = ((TypeStruct *) t1elem)->sym;\n+\t\tStructDeclaration *sd = t1elem->isTypeStruct ()->sym;\n \n \t\tresult = build_array_struct_comparison (code, sd, t1len,\n \t\t\t\t\t\t\tt1ptr, t2ptr);\n@@ -432,24 +429,22 @@ class ExprVisitor : public Visitor\n \t    this->result_ = result;\n \t  }\n       }\n-    else if (tb1->ty == Tstruct)\n+    else if (TypeStruct *ts = tb1->isTypeStruct ())\n       {\n \t/* Equality for struct objects means the logical product of all\n \t   equality results of the corresponding object fields.  */\n-\tStructDeclaration *sd = ((TypeStruct *) tb1)->sym;\n \ttree t1 = build_expr (e->e1);\n \ttree t2 = build_expr (e->e2);\n \n \tgcc_assert (same_type_p (tb1, tb2));\n \n-\tthis->result_ = build_struct_comparison (code, sd, t1, t2);\n+\tthis->result_ = build_struct_comparison (code, ts->sym, t1, t2);\n       }\n     else if (tb1->ty == Taarray && tb2->ty == Taarray)\n       {\n \t/* Use _aaEqual() for associative arrays.  */\n-\tTypeAArray *taa1 = (TypeAArray *) tb1;\n \ttree result = build_libcall (LIBCALL_AAEQUAL, e->type, 3,\n-\t\t\t\t     build_typeinfo (e->loc, taa1),\n+\t\t\t\t     build_typeinfo (e->loc, tb1),\n \t\t\t\t     build_expr (e->e1),\n \t\t\t\t     build_expr (e->e2));\n \n@@ -477,9 +472,7 @@ class ExprVisitor : public Visitor\n   void visit (InExp *e)\n   {\n     Type *tb2 = e->e2->type->toBasetype ();\n-    gcc_assert (tb2->ty == Taarray);\n-\n-    Type *tkey = ((TypeAArray *) tb2)->index->toBasetype ();\n+    Type *tkey = tb2->isTypeAArray ()->index->toBasetype ();\n     tree key = convert_expr (build_expr (e->e1), e->e1->type, tkey);\n \n     /* Build a call to _aaInX().  */\n@@ -1031,7 +1024,7 @@ class ExprVisitor : public Visitor\n \ttree t1 = build_expr (e->e1);\n \ttree t2 = convert_for_assignment (build_expr (e->e2),\n \t\t\t\t\t  e->e2->type, e->e1->type);\n-\tStructDeclaration *sd = ((TypeStruct *) tb1)->sym;\n+\tStructDeclaration *sd = tb1->isTypeStruct ()->sym;\n \n \t/* Look for struct = 0.  */\n \tif (e->e2->op == TOKint64)\n@@ -1193,7 +1186,7 @@ class ExprVisitor : public Visitor\n     if (tb1->ty == Taarray)\n       {\n \t/* Get the key for the associative array.  */\n-\tType *tkey = ((TypeAArray *) tb1)->index->toBasetype ();\n+\tType *tkey = tb1->isTypeAArray ()->index->toBasetype ();\n \ttree key = convert_expr (build_expr (e->e2), e->e2->type, tkey);\n \tlibcall_fn libcall;\n \ttree tinfo, ptr;\n@@ -1476,10 +1469,9 @@ class ExprVisitor : public Visitor\n \tType *telem = tb1->nextOf ()->baseElemOf ();\n \ttree ti = null_pointer_node;\n \n-\tif (telem->ty == Tstruct)\n+\tif (TypeStruct *ts = telem->isTypeStruct ())\n \t  {\n \t    /* Might need to run destructor on array contents.  */\n-\t    TypeStruct *ts = (TypeStruct *) telem;\n \t    if (ts->sym->dtor)\n \t      ti = build_typeinfo (e->loc, tb1->nextOf ());\n \t  }\n@@ -1493,11 +1485,10 @@ class ExprVisitor : public Visitor\n \t/* For pointers to a struct instance, if the struct has overloaded\n \t   operator delete, then that operator is called.  */\n \tt1 = build_address (t1);\n-\tType *tnext = ((TypePointer *)tb1)->next->toBasetype ();\n+\tType *tnext = tb1->isTypePointer ()->next->toBasetype ();\n \n-\tif (tnext->ty == Tstruct)\n+\tif (TypeStruct *ts = tnext->isTypeStruct ())\n \t  {\n-\t    TypeStruct *ts = (TypeStruct *)tnext;\n \t    if (ts->sym->dtor)\n \t      {\n \t\ttree ti = build_typeinfo (e->loc, tnext);\n@@ -1527,7 +1518,7 @@ class ExprVisitor : public Visitor\n     if (e->e1->type->toBasetype ()->ty == Taarray)\n       {\n \tType *tb = e->e1->type->toBasetype ();\n-\tType *tkey = ((TypeAArray *) tb)->index->toBasetype ();\n+\tType *tkey = tb->isTypeAArray ()->index->toBasetype ();\n \ttree index = convert_expr (build_expr (e->e2), e->e2->type, tkey);\n \n \tthis->result_ = build_libcall (LIBCALL_AADELX, Type::tbool, 3,\n@@ -1623,7 +1614,7 @@ class ExprVisitor : public Visitor\n        allocated in memory because its address is taken.  */\n     if (tnext && tnext->ty == Tstruct)\n       {\n-\tStructDeclaration *sd = ((TypeStruct *) tnext)->sym;\n+\tStructDeclaration *sd = tnext->isTypeStruct ()->sym;\n \n \tfor (size_t i = 0; i < sd->fields.length; i++)\n \t  {\n@@ -1998,7 +1989,7 @@ class ExprVisitor : public Visitor\n \t      }\n \t    else if (tb1->ty == Tpointer && tb1->nextOf ()->ty == Tstruct)\n \t      {\n-\t\tStructDeclaration *sd = ((TypeStruct *) tb1->nextOf ())->sym;\n+\t\tStructDeclaration *sd = tb1->nextOf ()->isTypeStruct ()->sym;\n \t\tif (sd->inv != NULL)\n \t\t  {\n \t\t    Expressions args;\n@@ -2089,7 +2080,7 @@ class ExprVisitor : public Visitor\n \tci = indirect_ref (ptr_type_node, ci);\n \n \t/* Add extra indirection for interfaces.  */\n-\tif (((TypeClass *) type)->sym->isInterfaceDeclaration ())\n+\tif (type->isTypeClass ()->sym->isInterfaceDeclaration ())\n \t  ci = indirect_ref (ptr_type_node, ci);\n \n \tthis->result_ = build_nop (build_ctype (e->type), ci);\n@@ -2288,9 +2279,8 @@ class ExprVisitor : public Visitor\n       {\n \t/* Allocating a new class.  */\n \ttb = e->newtype->toBasetype ();\n-\tgcc_assert (tb->ty == Tclass);\n \n-\tClassDeclaration *cd = ((TypeClass *) tb)->sym;\n+\tClassDeclaration *cd = tb->isTypeClass ()->sym;\n \ttree type = build_ctype (tb);\n \ttree setup_exp = NULL_TREE;\n \ttree new_call;\n@@ -2368,10 +2358,9 @@ class ExprVisitor : public Visitor\n       {\n \t/* Allocating memory for a new struct.  */\n \tType *htype = e->newtype->toBasetype ();\n-\tgcc_assert (htype->ty == Tstruct);\n \tgcc_assert (!e->onstack);\n \n-\tTypeStruct *stype = (TypeStruct *) htype;\n+\tTypeStruct *stype = htype->isTypeStruct ();\n \tStructDeclaration *sd = stype->sym;\n \ttree new_call;\n \n@@ -2443,8 +2432,7 @@ class ExprVisitor : public Visitor\n       {\n \t/* Allocating memory for a new D array.  */\n \ttb = e->newtype->toBasetype ();\n-\tgcc_assert (tb->ty == Tarray);\n-\tTypeDArray *tarray = (TypeDArray *) tb;\n+\tTypeDArray *tarray = tb->isTypeDArray ();\n \n \tgcc_assert (!e->allocator);\n \tgcc_assert (e->arguments && e->arguments->length >= 1);\n@@ -2511,7 +2499,7 @@ class ExprVisitor : public Visitor\n     else if (tb->ty == Tpointer)\n       {\n \t/* Allocating memory for a new pointer.  */\n-\tTypePointer *tpointer = (TypePointer *) tb;\n+\tTypePointer *tpointer = tb->isTypePointer ();\n \n \tif (tpointer->next->size () == 0)\n \t  {\n@@ -2666,7 +2654,7 @@ class ExprVisitor : public Visitor\n \n     /* Implicitly convert void[n] to ubyte[n].  */\n     if (tb->ty == Tsarray && tb->nextOf ()->toBasetype ()->ty == Tvoid)\n-      tb = Type::tuns8->sarrayOf (((TypeSArray *) tb)->dim->toUInteger ());\n+      tb = Type::tuns8->sarrayOf (tb->isTypeSArray ()->dim->toUInteger ());\n \n     gcc_assert (tb->ty == Tarray || tb->ty == Tsarray || tb->ty == Tpointer);\n \n@@ -2781,10 +2769,9 @@ class ExprVisitor : public Visitor\n   {\n     /* Want the mutable type for typeinfo reference.  */\n     Type *tb = e->type->toBasetype ()->mutableOf ();\n-    gcc_assert (tb->ty == Taarray);\n \n     /* Handle empty assoc array literals.  */\n-    TypeAArray *ta = (TypeAArray *) tb;\n+    TypeAArray *ta = tb->isTypeAArray ();\n     if (e->keys->length == 0)\n       {\n \tthis->result_ = build_constructor (build_ctype (ta), NULL);\n@@ -3018,7 +3005,7 @@ class ExprVisitor : public Visitor\n        interface offset to symbol.  */\n     if (this->constp_)\n       {\n-\tTypeClass *tc = (TypeClass *) e->type;\n+\tTypeClass *tc = e->type->toBasetype ()->isTypeClass ();\n \tInterfaceDeclaration *to = tc->sym->isInterfaceDeclaration ();\n \n \tif (to != NULL)"}, {"sha": "e6e696ab325c09448e146b721e7ec70fd745d269", "filename": "gcc/d/imports.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89fdaf5ad853c3d55060b9929027946833aee77a/gcc%2Fd%2Fimports.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89fdaf5ad853c3d55060b9929027946833aee77a/gcc%2Fd%2Fimports.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fimports.cc?ref=89fdaf5ad853c3d55060b9929027946833aee77a", "patch": "@@ -131,11 +131,11 @@ class ImportVisitor : public Visitor\n \tif (type != NULL)\n \t  {\n \t    if (type->ty == Tenum)\n-\t      dsym = ((TypeEnum *) type)->sym;\n+\t      dsym = type->isTypeEnum ()->sym;\n \t    else if (type->ty == Tstruct)\n-\t      dsym = ((TypeStruct *) type)->sym;\n+\t      dsym = type->isTypeStruct ()->sym;\n \t    else if (type->ty == Tclass)\n-\t      dsym = ((TypeClass *) type)->sym;\n+\t      dsym = type->isTypeClass ()->sym;\n \t  }\n       }\n "}, {"sha": "73443eaed505af89db821930864b02d6794b9962", "filename": "gcc/d/typeinfo.cc", "status": "modified", "additions": 16, "deletions": 27, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89fdaf5ad853c3d55060b9929027946833aee77a/gcc%2Fd%2Ftypeinfo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89fdaf5ad853c3d55060b9929027946833aee77a/gcc%2Fd%2Ftypeinfo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Ftypeinfo.cc?ref=89fdaf5ad853c3d55060b9929027946833aee77a", "patch": "@@ -140,7 +140,7 @@ get_typeinfo_kind (Type *type)\n       return TK_TYPELIST_TYPE;\n \n     case Tclass:\n-      if (((TypeClass *) type)->sym->isInterfaceDeclaration ())\n+      if (type->isTypeClass ()->sym->isInterfaceDeclaration ())\n \treturn TK_INTERFACE_TYPE;\n       else\n \treturn TK_CLASSINFO_TYPE;\n@@ -619,8 +619,7 @@ class TypeInfoVisitor : public Visitor\n \n   void visit (TypeInfoEnumDeclaration *d)\n   {\n-    gcc_assert (d->tinfo->ty == Tenum);\n-    TypeEnum *ti = (TypeEnum *) d->tinfo;\n+    TypeEnum *ti = d->tinfo->isTypeEnum ();\n     EnumDeclaration *ed = ti->sym;\n \n     /* The vtable for TypeInfo_Enum.  */\n@@ -652,8 +651,7 @@ class TypeInfoVisitor : public Visitor\n \n   void visit (TypeInfoPointerDeclaration *d)\n   {\n-    gcc_assert (d->tinfo->ty == Tpointer);\n-    TypePointer *ti = (TypePointer *) d->tinfo;\n+    TypePointer *ti = d->tinfo->isTypePointer ();\n \n     /* The vtable for TypeInfo_Pointer.  */\n     this->layout_base (Type::typeinfopointer);\n@@ -669,8 +667,7 @@ class TypeInfoVisitor : public Visitor\n \n   void visit (TypeInfoArrayDeclaration *d)\n   {\n-    gcc_assert (d->tinfo->ty == Tarray);\n-    TypeDArray *ti = (TypeDArray *) d->tinfo;\n+    TypeDArray *ti = d->tinfo->isTypeDArray ();\n \n     /* The vtable for TypeInfo_Array.  */\n     this->layout_base (Type::typeinfoarray);\n@@ -687,8 +684,7 @@ class TypeInfoVisitor : public Visitor\n \n   void visit (TypeInfoStaticArrayDeclaration *d)\n   {\n-    gcc_assert (d->tinfo->ty == Tsarray);\n-    TypeSArray *ti = (TypeSArray *) d->tinfo;\n+    TypeSArray *ti = d->tinfo->isTypeSArray ();\n \n     /* The vtable for TypeInfo_StaticArray.  */\n     this->layout_base (Type::typeinfostaticarray);\n@@ -708,8 +704,7 @@ class TypeInfoVisitor : public Visitor\n \n   void visit (TypeInfoAssociativeArrayDeclaration *d)\n   {\n-    gcc_assert (d->tinfo->ty == Taarray);\n-    TypeAArray *ti = (TypeAArray *) d->tinfo;\n+    TypeAArray *ti = d->tinfo->isTypeAArray ();\n \n     /* The vtable for TypeInfo_AssociativeArray.  */\n     this->layout_base (Type::typeinfoassociativearray);\n@@ -728,8 +723,7 @@ class TypeInfoVisitor : public Visitor\n \n   void visit (TypeInfoVectorDeclaration *d)\n   {\n-    gcc_assert (d->tinfo->ty == Tvector);\n-    TypeVector *ti = (TypeVector *) d->tinfo;\n+    TypeVector *ti = d->tinfo->isTypeVector ();\n \n     /* The vtable for TypeInfo_Vector.  */\n     this->layout_base (Type::typeinfovector);\n@@ -746,8 +740,8 @@ class TypeInfoVisitor : public Visitor\n \n   void visit (TypeInfoFunctionDeclaration *d)\n   {\n-    gcc_assert (d->tinfo->ty == Tfunction && d->tinfo->deco != NULL);\n-    TypeFunction *ti = (TypeFunction *) d->tinfo;\n+    TypeFunction *ti = d->tinfo->isTypeFunction ();\n+    gcc_assert (ti->deco != NULL);\n \n     /* The vtable for TypeInfo_Function.  */\n     this->layout_base (Type::typeinfofunction);\n@@ -767,8 +761,8 @@ class TypeInfoVisitor : public Visitor\n \n   void visit (TypeInfoDelegateDeclaration *d)\n   {\n-    gcc_assert (d->tinfo->ty == Tdelegate && d->tinfo->deco != NULL);\n-    TypeDelegate *ti = (TypeDelegate *) d->tinfo;\n+    TypeDelegate *ti = d->tinfo->isTypeDelegate ();\n+    gcc_assert (ti->deco != NULL);\n \n     /* The vtable for TypeInfo_Delegate.  */\n     this->layout_base (Type::typeinfodelegate);\n@@ -801,8 +795,7 @@ class TypeInfoVisitor : public Visitor\n \n   void visit (TypeInfoClassDeclaration *d)\n   {\n-    gcc_assert (d->tinfo->ty == Tclass);\n-    TypeClass *ti = (TypeClass *) d->tinfo;\n+    TypeClass *ti = d->tinfo->isTypeClass ();\n     ClassDeclaration *cd = ti->sym;\n \n     /* The vtable for ClassInfo.  */\n@@ -994,8 +987,7 @@ class TypeInfoVisitor : public Visitor\n \n   void visit (TypeInfoInterfaceDeclaration *d)\n   {\n-    gcc_assert (d->tinfo->ty == Tclass);\n-    TypeClass *ti = (TypeClass *) d->tinfo;\n+    TypeClass *ti = d->tinfo->isTypeClass ();\n \n     if (!ti->sym->vclassinfo)\n       ti->sym->vclassinfo = TypeInfoClassDeclaration::create (ti);\n@@ -1028,8 +1020,7 @@ class TypeInfoVisitor : public Visitor\n \n   void visit (TypeInfoStructDeclaration *d)\n   {\n-    gcc_assert (d->tinfo->ty == Tstruct);\n-    TypeStruct *ti = (TypeStruct *) d->tinfo;\n+    TypeStruct *ti = d->tinfo->isTypeStruct ();\n     StructDeclaration *sd = ti->sym;\n \n     /* The vtable for TypeInfo_Struct.  */\n@@ -1128,8 +1119,7 @@ class TypeInfoVisitor : public Visitor\n \n   void visit (TypeInfoTupleDeclaration *d)\n   {\n-    gcc_assert (d->tinfo->ty == Ttuple);\n-    TypeTuple *ti = (TypeTuple *) d->tinfo;\n+    TypeTuple *ti = d->tinfo->isTypeTuple ();\n \n     /* The vtable for TypeInfo_Tuple.  */\n     this->layout_base (Type::typeinfotypelist);\n@@ -1323,8 +1313,7 @@ class TypeInfoDeclVisitor : public Visitor\n \n   void visit (TypeInfoClassDeclaration *tid)\n   {\n-    gcc_assert (tid->tinfo->ty == Tclass);\n-    TypeClass *tc = (TypeClass *) tid->tinfo;\n+    TypeClass *tc = tid->tinfo->isTypeClass ();\n     tid->csym = get_classinfo_decl (tc->sym);\n   }\n };"}, {"sha": "cb9a6dec7e505fa13df20c75c3ac69e0d5881689", "filename": "gcc/d/types.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89fdaf5ad853c3d55060b9929027946833aee77a/gcc%2Fd%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89fdaf5ad853c3d55060b9929027946833aee77a/gcc%2Fd%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Ftypes.cc?ref=89fdaf5ad853c3d55060b9929027946833aee77a", "patch": "@@ -498,9 +498,9 @@ merge_aggregate_types (Type *type, tree deco)\n   AggregateDeclaration *sym;\n \n   if (type->ty == Tstruct)\n-    sym = ((TypeStruct *) type)->sym;\n+    sym = type->isTypeStruct ()->sym;\n   else if (type->ty == Tclass)\n-    sym = ((TypeClass *) type)->sym;\n+    sym = type->isTypeClass ()->sym;\n   else\n     gcc_unreachable ();\n \n@@ -671,7 +671,7 @@ class TypeVisitor : public Visitor\n \n   void visit (TypeVector *t)\n   {\n-    int nunits = ((TypeSArray *) t->basetype)->dim->toUInteger ();\n+    int nunits = t->basetype->isTypeSArray ()->dim->toUInteger ();\n     tree inner = build_ctype (t->elementType ());\n \n     /* Same rationale as void static arrays.  */"}]}