{"sha": "18e1fd7565cd40baf448858cb069d25b99338a08", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MThlMWZkNzU2NWNkNDBiYWY0NDg4NThjYjA2OWQyNWI5OTMzOGEwOA==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@google.com", "date": "2012-11-27T18:20:30Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2012-11-27T18:20:30Z"}, "message": "Fix bootstrap failure with --enable-gather-detailed-mem-stats.\n\nThis patch restores bootstrap when detailed memory stats are enabled.\nNo functional changes.\n\nTested on x86_64.  Committed to trunk.\n\n2012-11-27  Diego Novillo  <dnovillo@google.com>\n\n\t* vec.h: Replace 'class vec' with 'struct vec' everywhere.\n\t(ggc_internal_cleared_alloc_stat): Remove.\n\t(va_gc::reserve): Add PASS_MEM_STAT to ggc_realloc_stat call.\n\t(va_stack::reserve): Add PASS_MEM_STAT to va_heap::reserve call.\n\t(vec<T, A, vl_embed>::copy): Replace ALONE_MEM_STAT_DECL with\n\tALONE_CXX_MEM_STAT_INFO.\n\t(vec_safe_reserve): Replace MEM_STAT_DECL with CXX_MEM_STAT_INFO.\n\t(vec_safe_reserve_exact): Likewise.\n\t(vec_alloc): Likewise.\n\t(vec_safe_grow): Likewise.\n\t(vec_safe_grow_cleared): Likewise.\n\t(vec_safe_push): Likewise.\n\t(vec_safe_insert): Likewise.\n\t(vec_safe_splice): Likewise.\n\t(vec_alloc): Likewise.\n\t(vec_check_alloc): Likewise.\n\nFrom-SVN: r193864", "tree": {"sha": "462c1557becffd23ebfd7a7d0d8d499177490783", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/462c1557becffd23ebfd7a7d0d8d499177490783"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/18e1fd7565cd40baf448858cb069d25b99338a08", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18e1fd7565cd40baf448858cb069d25b99338a08", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18e1fd7565cd40baf448858cb069d25b99338a08", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18e1fd7565cd40baf448858cb069d25b99338a08/comments", "author": {"login": "dnovillo", "id": 7295335, "node_id": "MDQ6VXNlcjcyOTUzMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/7295335?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dnovillo", "html_url": "https://github.com/dnovillo", "followers_url": "https://api.github.com/users/dnovillo/followers", "following_url": "https://api.github.com/users/dnovillo/following{/other_user}", "gists_url": "https://api.github.com/users/dnovillo/gists{/gist_id}", "starred_url": "https://api.github.com/users/dnovillo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dnovillo/subscriptions", "organizations_url": "https://api.github.com/users/dnovillo/orgs", "repos_url": "https://api.github.com/users/dnovillo/repos", "events_url": "https://api.github.com/users/dnovillo/events{/privacy}", "received_events_url": "https://api.github.com/users/dnovillo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d8d638d9e24917b0d4e42c93fcac2b740a8f0eab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8d638d9e24917b0d4e42c93fcac2b740a8f0eab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8d638d9e24917b0d4e42c93fcac2b740a8f0eab"}], "stats": {"total": 76, "additions": 48, "deletions": 28}, "files": [{"sha": "03ed43a789d3c1e0b2fb86ccbce3bc8a0e359610", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18e1fd7565cd40baf448858cb069d25b99338a08/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18e1fd7565cd40baf448858cb069d25b99338a08/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=18e1fd7565cd40baf448858cb069d25b99338a08", "patch": "@@ -1,3 +1,22 @@\n+2012-11-27  Diego Novillo  <dnovillo@google.com>\n+\n+\t* vec.h: Replace 'class vec' with 'struct vec' everywhere.\n+\t(ggc_internal_cleared_alloc_stat): Remove.\n+\t(va_gc::reserve): Add PASS_MEM_STAT to ggc_realloc_stat call.\n+\t(va_stack::reserve): Add PASS_MEM_STAT to va_heap::reserve call.\n+\t(vec<T, A, vl_embed>::copy): Replace ALONE_MEM_STAT_DECL with\n+\tALONE_CXX_MEM_STAT_INFO.\n+\t(vec_safe_reserve): Replace MEM_STAT_DECL with CXX_MEM_STAT_INFO.\n+\t(vec_safe_reserve_exact): Likewise.\n+\t(vec_alloc): Likewise.\n+\t(vec_safe_grow): Likewise.\n+\t(vec_safe_grow_cleared): Likewise.\n+\t(vec_safe_push): Likewise.\n+\t(vec_safe_insert): Likewise.\n+\t(vec_safe_splice): Likewise.\n+\t(vec_alloc): Likewise.\n+\t(vec_check_alloc): Likewise.\n+\n 2012-11-27  Marc Glisse  <marc.glisse@inria.fr>\n \n \t* tree-cfg.c (verify_gimple_comparison): Verify that vector"}, {"sha": "a7b3b4cdc8237b630ebe1640672616c65228819f", "filename": "gcc/vec.h", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18e1fd7565cd40baf448858cb069d25b99338a08/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18e1fd7565cd40baf448858cb069d25b99338a08/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=18e1fd7565cd40baf448858cb069d25b99338a08", "patch": "@@ -51,8 +51,6 @@ along with GCC; see the file COPYING3.  If not see\n      has not been included.  Sigh.  */\n   extern void ggc_free (void *);\n   extern size_t ggc_round_alloc_size (size_t requested_size);\n-  extern void *ggc_internal_cleared_alloc_stat (size_t MEM_STAT_DECL)\n-    ATTRIBUTE_MALLOC;\n   extern void *ggc_realloc_stat (void *, size_t MEM_STAT_DECL);\n #  endif  // GCC_GGC_H\n #endif\t// VEC_GC_ENABLED\n@@ -230,7 +228,7 @@ struct vec_prefix\n \n      To compensate, we make vec_prefix a field inside vec and make\n      vec a friend class of vec_prefix so it can access its fields.  */\n-  template <typename, typename, typename> friend class vec;\n+  template <typename, typename, typename> friend struct vec;\n \n   /* The allocator types also need access to our internals.  */\n   friend struct va_gc;\n@@ -242,7 +240,7 @@ struct vec_prefix\n   unsigned num_;\n };\n \n-template<typename, typename, typename> class vec;\n+template<typename, typename, typename> struct vec;\n \n /* Valid vector layouts\n \n@@ -367,7 +365,7 @@ va_gc::reserve (vec<T, A, vl_embed> *&v, unsigned reserve, bool exact\n   size_t size = vec<T, A, vl_embed>::embedded_size (alloc);\n \n   /* Ask the allocator how much space it will really give us.  */\n-  size = ggc_round_alloc_size (size);\n+  size = ::ggc_round_alloc_size (size);\n \n   /* Adjust the number of slots accordingly.  */\n   size_t vec_offset = sizeof (vec_prefix);\n@@ -378,7 +376,8 @@ va_gc::reserve (vec<T, A, vl_embed> *&v, unsigned reserve, bool exact\n   size = vec_offset + alloc * elt_size;\n \n   unsigned nelem = v ? v->length () : 0;\n-  v = static_cast <vec<T, A, vl_embed> *> (ggc_realloc_stat (v, size));\n+  v = static_cast <vec<T, A, vl_embed> *> (::ggc_realloc_stat (v, size\n+\t\t\t\t\t\t\t       PASS_MEM_STAT));\n   v->embedded_init (alloc, nelem);\n }\n \n@@ -447,7 +446,7 @@ va_stack::reserve (vec<T, va_stack, vl_embed> *&v, unsigned nelems, bool exact\n     {\n       /* V is already on the heap.  */\n       va_heap::reserve (reinterpret_cast<vec<T, va_heap, vl_embed> *&> (v),\n-\t\t\tnelems, exact);\n+\t\t\tnelems, exact PASS_MEM_STAT);\n       return;\n     }\n \n@@ -456,7 +455,7 @@ va_stack::reserve (vec<T, va_stack, vl_embed> *&v, unsigned nelems, bool exact\n   vec<T, va_stack, vl_embed> *oldvec = v;\n   v = NULL;\n   va_heap::reserve (reinterpret_cast<vec<T, va_heap, vl_embed> *&>(v), nelems,\n-\t\t    exact);\n+\t\t    exact PASS_MEM_STAT);\n   if (v && oldvec)\n     {\n       v->vecpfx_.num_ = oldvec->length ();\n@@ -506,7 +505,7 @@ va_stack::release (vec<T, va_stack, vl_embed> *&v)\n template<typename T,\n          typename A = va_heap,\n          typename L = typename A::default_layout>\n-class GTY((user)) vec\n+struct GTY((user)) vec\n {\n };\n \n@@ -549,7 +548,7 @@ extern vnull vNULL;\n   \t- It requires 2 words of storage (prior to vector allocation).  */\n \n template<typename T, typename A>\n-class GTY((user)) vec<T, A, vl_embed>\n+struct GTY((user)) vec<T, A, vl_embed>\n {\n public:\n   unsigned allocated (void) const { return vecpfx_.alloc_; }\n@@ -563,7 +562,7 @@ class GTY((user)) vec<T, A, vl_embed>\n   bool space (unsigned) const;\n   bool iterate (unsigned, T *) const;\n   bool iterate (unsigned, T **) const;\n-  vec *copy (ALONE_MEM_STAT_DECL) const;\n+  vec *copy (ALONE_CXX_MEM_STAT_INFO) const;\n   void splice (vec &);\n   void splice (vec *src);\n   T *quick_push (const T &);\n@@ -581,7 +580,7 @@ class GTY((user)) vec<T, A, vl_embed>\n   void quick_grow_cleared (unsigned len);\n \n   /* vec class can access our internal data and functions.  */\n-  template <typename, typename, typename> friend class vec;\n+  template <typename, typename, typename> friend struct vec;\n \n   /* The allocator types also need access to our internals.  */\n   friend struct va_gc;\n@@ -651,7 +650,7 @@ vec_safe_is_empty (vec<T, A, vl_embed> *v)\n template<typename T, typename A>\n inline bool\n vec_safe_reserve (vec<T, A, vl_embed> *&v, unsigned nelems, bool exact = false\n-\t\t  MEM_STAT_DECL)\n+\t\t  CXX_MEM_STAT_INFO)\n {\n   bool extend = nelems ? !vec_safe_space (v, nelems) : false;\n   if (extend)\n@@ -661,7 +660,8 @@ vec_safe_reserve (vec<T, A, vl_embed> *&v, unsigned nelems, bool exact = false\n \n template<typename T, typename A>\n inline bool\n-vec_safe_reserve_exact (vec<T, A, vl_embed> *&v, unsigned nelems MEM_STAT_DECL)\n+vec_safe_reserve_exact (vec<T, A, vl_embed> *&v, unsigned nelems\n+\t\t\tCXX_MEM_STAT_INFO)\n {\n   return vec_safe_reserve (v, nelems, true PASS_MEM_STAT);\n }\n@@ -672,10 +672,10 @@ vec_safe_reserve_exact (vec<T, A, vl_embed> *&v, unsigned nelems MEM_STAT_DECL)\n \n template<typename T, typename A>\n inline void\n-vec_alloc (vec<T, A, vl_embed> *&v, unsigned nelems MEM_STAT_DECL)\n+vec_alloc (vec<T, A, vl_embed> *&v, unsigned nelems CXX_MEM_STAT_INFO)\n {\n   v = NULL;\n-  vec_safe_reserve (v, nelems);\n+  vec_safe_reserve (v, nelems, false PASS_MEM_STAT);\n }\n \n \n@@ -692,19 +692,19 @@ vec_free (vec<T, A, vl_embed> *&v)\n /* Grow V to length LEN.  Allocate it, if necessary.  */\n template<typename T, typename A>\n inline void\n-vec_safe_grow (vec<T, A, vl_embed> *&v, unsigned len MEM_STAT_DECL)\n+vec_safe_grow (vec<T, A, vl_embed> *&v, unsigned len CXX_MEM_STAT_INFO)\n {\n   unsigned oldlen = vec_safe_length (v);\n   gcc_checking_assert (len >= oldlen);\n   vec_safe_reserve_exact (v, len - oldlen PASS_MEM_STAT);\n-  v->quick_grow (len PASS_MEM_STAT);\n+  v->quick_grow (len);\n }\n \n \n /* If V is NULL, allocate it.  Call V->safe_grow_cleared(LEN).  */\n template<typename T, typename A>\n inline void\n-vec_safe_grow_cleared (vec<T, A, vl_embed> *&v, unsigned len MEM_STAT_DECL)\n+vec_safe_grow_cleared (vec<T, A, vl_embed> *&v, unsigned len CXX_MEM_STAT_INFO)\n {\n   unsigned oldlen = vec_safe_length (v);\n   vec_safe_grow (v, len PASS_MEM_STAT);\n@@ -744,10 +744,10 @@ vec_safe_iterate (const vec<T, A, vl_embed> *v, unsigned ix, T *ptr)\n    V->quick_push(OBJ).  */\n template<typename T, typename A>\n inline T *\n-vec_safe_push (vec<T, A, vl_embed> *&v, const T &obj MEM_STAT_DECL)\n+vec_safe_push (vec<T, A, vl_embed> *&v, const T &obj CXX_MEM_STAT_INFO)\n {\n   vec_safe_reserve (v, 1, false PASS_MEM_STAT);\n-  return v->quick_push (obj PASS_MEM_STAT);\n+  return v->quick_push (obj);\n }\n \n \n@@ -756,7 +756,7 @@ vec_safe_push (vec<T, A, vl_embed> *&v, const T &obj MEM_STAT_DECL)\n template<typename T, typename A>\n inline void\n vec_safe_insert (vec<T, A, vl_embed> *&v, unsigned ix, const T &obj\n-\t\t MEM_STAT_DECL)\n+\t\t CXX_MEM_STAT_INFO)\n {\n   vec_safe_reserve (v, 1, false PASS_MEM_STAT);\n   v->quick_insert (ix, obj);\n@@ -786,12 +786,13 @@ vec_safe_copy (vec<T, A, vl_embed> *src)\n template<typename T, typename A>\n inline void\n vec_safe_splice (vec<T, A, vl_embed> *&dst, vec<T, A, vl_embed> *src\n-\t\t MEM_STAT_DECL)\n+\t\t CXX_MEM_STAT_INFO)\n {\n   unsigned src_len = vec_safe_length (src);\n   if (src_len)\n     {\n-      vec_safe_reserve_exact (dst, vec_safe_length (dst) + src_len);\n+      vec_safe_reserve_exact (dst, vec_safe_length (dst) + src_len\n+\t\t\t      PASS_MEM_STAT);\n       dst->splice (*src);\n     }\n }\n@@ -1207,7 +1208,7 @@ gt_pch_nx (vec<T, A, vl_embed> *v, gt_pointer_operator op, void *cookie)\n    destructors in classes that are stored in unions.  */\n \n template<typename T, typename A>\n-class vec<T, A, vl_ptr>\n+struct vec<T, A, vl_ptr>\n {\n public:\n   /* Memory allocation and deallocation for the embedded vector.\n@@ -1287,7 +1288,7 @@ class vec<T, A, vl_ptr>\n    circumvent limitations in the GTY machinery.  */\n \n template<typename T>\n-class vec<T, va_gc, vl_ptr>\n+struct vec<T, va_gc, vl_ptr>\n {\n };\n \n@@ -1298,7 +1299,7 @@ class vec<T, va_gc, vl_ptr>\n \n template<typename T>\n inline void\n-vec_alloc (vec<T> *&v, unsigned nelems MEM_STAT_DECL)\n+vec_alloc (vec<T> *&v, unsigned nelems CXX_MEM_STAT_INFO)\n {\n   v = new vec<T>;\n   v->create (nelems PASS_MEM_STAT);\n@@ -1309,7 +1310,7 @@ vec_alloc (vec<T> *&v, unsigned nelems MEM_STAT_DECL)\n \n template<typename T>\n inline void\n-vec_check_alloc (vec<T, va_heap> *&vec, unsigned nelems MEM_STAT_DECL)\n+vec_check_alloc (vec<T, va_heap> *&vec, unsigned nelems CXX_MEM_STAT_INFO)\n {\n   if (!vec)\n     vec_alloc (vec, nelems PASS_MEM_STAT);"}]}