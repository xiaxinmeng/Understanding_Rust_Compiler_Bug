{"sha": "f57d17f1fc2f31047644ed6f18f1087f65f8f88b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjU3ZDE3ZjFmYzJmMzEwNDc2NDRlZDZmMThmMTA4N2Y2NWY4Zjg4Yg==", "commit": {"author": {"name": "Tehila Meyzels", "email": "tehila@il.ibm.com", "date": "2007-02-11T11:46:07Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2007-02-11T11:46:07Z"}, "message": "tm.texi (TARGET_VECTORIZE_BUILTIN_CONVERSION): New target hook.\n\n        * doc/tm.texi (TARGET_VECTORIZE_BUILTIN_CONVERSION): New target hook.\n        * targhooks.c (default_builtin_vectorized_conversion): New.\n        * targhooks.h (default_builtin_vectorized_function): New declaration.\n        * target.h (struct vectorize): Add builtin_conversion field.\n        * tree-vectorizer.h (type_conversion_vec_info_type): New enum\n        stmt_vec_info_type value.\n        (vectorizable_conversion): New declaration.\n        * tree-vect-analyze.c (vect_analyze_operations): Add\n        vectorizable_conversion call.\n        * target-def.h (TARGET_VECTORIZE_BUILTIN_CONVERSION): New.\n        * tree-vect-transform.c (vectorizable_conversion): New function.\n        (vect_transform_stmt): Add case for type_conversion_vec_info_type.\n        * tree-vect-generic.c (expand_vector_operations_1): Consider correct\n        mode.\n        * config/rs6000/rs6000.c (rs6000_builtin_conversion): New.\n        (TARGET_VECTORIZE_BUILTIN_CONVERSION): Defined.\n        (rs6000_expand_builtin): Add handling a case of ALTIVEC_BUILTIN_VCFUX or\n        ALTIVEC_BUILTIN_VCFSX.\n\n\nCo-Authored-By: Dorit Nuzman <dorit@il.ibm.com>\nCo-Authored-By: Ira Rosen <irar@il.ibm.com>\n\nFrom-SVN: r121818", "tree": {"sha": "e52f73a43ee97fe66d58356fa8f6c7468ab5a0c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e52f73a43ee97fe66d58356fa8f6c7468ab5a0c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f57d17f1fc2f31047644ed6f18f1087f65f8f88b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f57d17f1fc2f31047644ed6f18f1087f65f8f88b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f57d17f1fc2f31047644ed6f18f1087f65f8f88b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f57d17f1fc2f31047644ed6f18f1087f65f8f88b/comments", "author": null, "committer": null, "parents": [{"sha": "1c85c51a47ff6ce4433345fb768c89f7d8e047e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c85c51a47ff6ce4433345fb768c89f7d8e047e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c85c51a47ff6ce4433345fb768c89f7d8e047e6"}], "stats": {"total": 297, "additions": 288, "deletions": 9}, "files": [{"sha": "c7fce63c29888fd95beab01ca84b777aee991a09", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57d17f1fc2f31047644ed6f18f1087f65f8f88b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57d17f1fc2f31047644ed6f18f1087f65f8f88b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f57d17f1fc2f31047644ed6f18f1087f65f8f88b", "patch": "@@ -1,3 +1,26 @@\n+2007-02-11  Tehila Meyzels  <tehila@il.ibm.com>\n+\t    Ira Rosen  <irar@il.ibm.com>\n+\t    Dorit Nuzman  <dorit@il.ibm.com>\n+\n+\t* doc/tm.texi (TARGET_VECTORIZE_BUILTIN_CONVERSION): New target hook.\n+\t* targhooks.c (default_builtin_vectorized_conversion): New.\n+\t* targhooks.h (default_builtin_vectorized_function): New declaration.\n+\t* target.h (struct vectorize): Add builtin_conversion field.\n+\t* tree-vectorizer.h (type_conversion_vec_info_type): New enum\n+\tstmt_vec_info_type value.\n+\t(vectorizable_conversion): New declaration.\n+\t* tree-vect-analyze.c (vect_analyze_operations): Add\n+\tvectorizable_conversion call.\n+\t* target-def.h (TARGET_VECTORIZE_BUILTIN_CONVERSION): New.\n+\t* tree-vect-transform.c (vectorizable_conversion): New function.\n+\t(vect_transform_stmt): Add case for type_conversion_vec_info_type.\n+\t* tree-vect-generic.c (expand_vector_operations_1): Consider correct\n+\tmode.\n+\t* config/rs6000/rs6000.c (rs6000_builtin_conversion): New.\n+\t(TARGET_VECTORIZE_BUILTIN_CONVERSION): Defined.\n+\t(rs6000_expand_builtin): Add handling a case of ALTIVEC_BUILTIN_VCFUX or\n+\tALTIVEC_BUILTIN_VCFSX.\n+\n 2007-02-10  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \tPR target/30634"}, {"sha": "4ed383f31abf9d08eb393a66c7f5526d4e578286", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57d17f1fc2f31047644ed6f18f1087f65f8f88b/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57d17f1fc2f31047644ed6f18f1087f65f8f88b/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=f57d17f1fc2f31047644ed6f18f1087f65f8f88b", "patch": "@@ -716,6 +716,7 @@ static int rs6000_use_sched_lookahead_guard (rtx);\n static tree rs6000_builtin_mask_for_load (void);\n static tree rs6000_builtin_mul_widen_even (tree);\n static tree rs6000_builtin_mul_widen_odd (tree);\n+static tree rs6000_builtin_conversion (enum tree_code, tree);\n \n static void def_builtin (int, const char *, tree, int);\n static void rs6000_init_builtins (void);\n@@ -981,6 +982,8 @@ static const char alt_reg_names[][8] =\n #define TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_EVEN rs6000_builtin_mul_widen_even\n #undef TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_ODD\n #define TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_ODD rs6000_builtin_mul_widen_odd\n+#undef TARGET_VECTORIZE_BUILTIN_CONVERSION\n+#define TARGET_VECTORIZE_BUILTIN_CONVERSION rs6000_builtin_conversion\n \n #undef TARGET_INIT_BUILTINS\n #define TARGET_INIT_BUILTINS rs6000_init_builtins\n@@ -1677,6 +1680,30 @@ rs6000_builtin_mask_for_load (void)\n     return 0;\n }\n \n+/* Implement targetm.vectorize.builtin_conversion.  */\n+static tree\n+rs6000_builtin_conversion (enum tree_code code, tree type)\n+{\n+  if (!TARGET_ALTIVEC)\n+    return NULL_TREE;\n+  \n+  switch (code)\n+    {\n+    case FLOAT_EXPR:\n+      switch (TYPE_MODE (type))\n+\t{\n+\tcase V4SImode:\n+\t  return TYPE_UNSIGNED (type) ? \n+\t    rs6000_builtin_decls[ALTIVEC_BUILTIN_VCFUX] :\n+\t    rs6000_builtin_decls[ALTIVEC_BUILTIN_VCFSX];\n+\tdefault:\n+\t  return NULL_TREE;\n+\t}\n+    default:\n+      return NULL_TREE;\n+    }\n+}\n+\n /* Implement targetm.vectorize.builtin_mul_widen_even.  */\n static tree\n rs6000_builtin_mul_widen_even (tree type)\n@@ -8151,6 +8178,21 @@ rs6000_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n \n       return target;\n     }\n+  \n+  if (fcode == ALTIVEC_BUILTIN_VCFUX\n+      || fcode == ALTIVEC_BUILTIN_VCFSX)\n+    {\n+      if (!TREE_CHAIN (arglist)) \n+\t{\n+\t  tree t, arg0;\n+\t  t = NULL_TREE;\n+\t  t = tree_cons (NULL_TREE, integer_zero_node, t);\n+\t  arg0 = TREE_VALUE (arglist);\n+\t  t = tree_cons (NULL_TREE, arg0, t);\n+\t  arglist = t;\n+\t  TREE_OPERAND (exp, 1) = t;\n+\t}\n+    }   \n \n   if (TARGET_ALTIVEC)\n     {"}, {"sha": "ad17909986913461e968ded21d09989bc86db0e6", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57d17f1fc2f31047644ed6f18f1087f65f8f88b/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57d17f1fc2f31047644ed6f18f1087f65f8f88b/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=f57d17f1fc2f31047644ed6f18f1087f65f8f88b", "patch": "@@ -5384,6 +5384,21 @@ preserved (e.g. used only by a reduction computation). Otherwise, the\n @code{widen_mult_hi/lo} idioms will be used.\n @end deftypefn\n \n+@deftypefn {Target Hook} tree TARGET_VECTORIZE_BUILTIN_CONVERSION (enum tree_code @var{code}, tree @var{type})\n+This hook should return the DECL of a function that implements conversion of the\n+input vector of type @var{type}.\n+If @var{type} is an integral type, the result of the conversion is a vector of\n+floating-point type of the same size.\n+If @var{type} is a floating-point type, the result of the conversion is a vector\n+of integral type of the same size.\n+@var{code} specifies how the conversion is to be applied\n+(truncation, rounding, etc.).\n+\n+If this hook is defined, the autovectorizer will use the\n+@code{TARGET_VECTORIZE_BUILTIN_CONVERSION} target hook when vectorizing\n+conversion. Otherwise, it will return @code{NULL_TREE}.\n+@end deftypefn\n+\n @deftypefn {Target Hook} tree TARGET_VECTORIZE_BUILTIN_VECTORIZED_FUNCTION (enum built_in_function @var{code}, tree @var{vec_type_out}, tree @var{vec_type_in})\n This hook should return the decl of a function that implements the vectorized\n variant of the builtin function with builtin function code @var{code} or"}, {"sha": "27c58838f656c146465e6635ad0dadb7f1290c37", "filename": "gcc/target-def.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57d17f1fc2f31047644ed6f18f1087f65f8f88b/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57d17f1fc2f31047644ed6f18f1087f65f8f88b/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=f57d17f1fc2f31047644ed6f18f1087f65f8f88b", "patch": "@@ -345,13 +345,15 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n \n #define TARGET_VECTORIZE_BUILTIN_MASK_FOR_LOAD 0\n #define TARGET_VECTORIZE_BUILTIN_VECTORIZED_FUNCTION default_builtin_vectorized_function\n+#define TARGET_VECTORIZE_BUILTIN_CONVERSION default_builtin_vectorized_conversion\n #define TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_EVEN 0\n #define TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_ODD 0\n \n #define TARGET_VECTORIZE                                                \\\n   {\t\t\t\t\t\t\t\t\t\\\n     TARGET_VECTORIZE_BUILTIN_MASK_FOR_LOAD,\t\t\t\t\\\n     TARGET_VECTORIZE_BUILTIN_VECTORIZED_FUNCTION,\t\t\t\\\n+    TARGET_VECTORIZE_BUILTIN_CONVERSION,\t\t\t\t\\\n     TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_EVEN,                            \\\n     TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_ODD\t\t\t\t\\\n   }"}, {"sha": "e8694f2c56a9d1d5480cffe6dda802e448708c90", "filename": "gcc/target.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57d17f1fc2f31047644ed6f18f1087f65f8f88b/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57d17f1fc2f31047644ed6f18f1087f65f8f88b/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=f57d17f1fc2f31047644ed6f18f1087f65f8f88b", "patch": "@@ -397,6 +397,10 @@ struct gcc_target\n        function, or NULL_TREE if not available.  */\n     tree (* builtin_vectorized_function) (unsigned, tree, tree);\n \n+    /* Returns a code for builtin that realizes vectorized version of\n+       conversion, or NULL_TREE if not available.  */\n+    tree (* builtin_conversion) (unsigned, tree);\n+\n     /* Target builtin that implements vector widening multiplication.\n        builtin_mul_widen_eve computes the element-by-element products \n        for the even elements, and builtin_mul_widen_odd computes the"}, {"sha": "fe0007905bf712d2e428da03d87e7219777824fd", "filename": "gcc/targhooks.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57d17f1fc2f31047644ed6f18f1087f65f8f88b/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57d17f1fc2f31047644ed6f18f1087f65f8f88b/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=f57d17f1fc2f31047644ed6f18f1087f65f8f88b", "patch": "@@ -329,6 +329,15 @@ default_builtin_vectorized_function (enum built_in_function fn ATTRIBUTE_UNUSED,\n   return NULL_TREE;\n }\n \n+/* Vectorized conversion.  */\n+\n+tree\n+default_builtin_vectorized_conversion (enum tree_code code ATTRIBUTE_UNUSED,\n+\t\t\t\t       tree type ATTRIBUTE_UNUSED)\n+{\n+  return NULL_TREE;\n+}\n+\n bool\n hook_bool_CUMULATIVE_ARGS_mode_tree_bool_false (\n \tCUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED,"}, {"sha": "b6bd700009742ff53f8d32400e95e4fdaf2addf6", "filename": "gcc/targhooks.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57d17f1fc2f31047644ed6f18f1087f65f8f88b/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57d17f1fc2f31047644ed6f18f1087f65f8f88b/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=f57d17f1fc2f31047644ed6f18f1087f65f8f88b", "patch": "@@ -59,6 +59,8 @@ extern bool default_narrow_bitfield (void);\n \n extern tree default_builtin_vectorized_function (enum built_in_function, tree, tree);\n \n+extern tree default_builtin_vectorized_conversion (enum tree_code, tree);\n+\n /* These are here, and not in hooks.[ch], because not all users of\n    hooks.h include tm.h, and thus we don't have CUMULATIVE_ARGS.  */\n "}, {"sha": "8f912c291e6f7138e9172233af48e189cc9bf88b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57d17f1fc2f31047644ed6f18f1087f65f8f88b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57d17f1fc2f31047644ed6f18f1087f65f8f88b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f57d17f1fc2f31047644ed6f18f1087f65f8f88b", "patch": "@@ -1,3 +1,13 @@\n+2007-02-11  Tehila Meyzels <tehila@il.ibm.com>\n+\t    Dorit Nuzman  <dorit@il.ibm.com>\n+\n+\t* gcc.dg/vect/vect-intfloat-conversion.c-1:  New test.\n+\t* gcc.dg/vect/vect-intfloat-conversion.c-2:  New test.\n+\t* gcc.dg/vect/vect-93.c: Another loop gets vectorized  on powerpc.\n+\t* gcc.dg/vect/vect-113.c: Likewise.\n+\n+\t* gcc.dg/vect/vect-iv-11.c: A loop gets vectorized.\n+\n 2007-02-10  Richard Henderson  <rth@redhat.com>\n \n \t* lib/target-supports.exp (check_effective_target_tls): Redefine"}, {"sha": "3b3d1db0de66cbf698d10deb813d38d893f24c5a", "filename": "gcc/testsuite/gcc.dg/vect/vect-113.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57d17f1fc2f31047644ed6f18f1087f65f8f88b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-113.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57d17f1fc2f31047644ed6f18f1087f65f8f88b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-113.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-113.c?ref=f57d17f1fc2f31047644ed6f18f1087f65f8f88b", "patch": "@@ -11,7 +11,7 @@ main1 (void)\n   int i;\n   float a[N];\n \n-  /* Induction.  */\n+  /* Induction and type conversion.  */\n   for ( i = 0; i < N; i++) \n   {\n     a[i] = i;\n@@ -32,5 +32,5 @@ int main (void)\n   return main1 ();\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 0 loops\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target powerpc*-*-* } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "a084922e3493a01c2c79fb7e4b6e7a676198a9ca", "filename": "gcc/testsuite/gcc.dg/vect/vect-93.c", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57d17f1fc2f31047644ed6f18f1087f65f8f88b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-93.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57d17f1fc2f31047644ed6f18f1087f65f8f88b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-93.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-93.c?ref=f57d17f1fc2f31047644ed6f18f1087f65f8f88b", "patch": "@@ -65,12 +65,21 @@ int main (void)\n   return 0;\n }\n \n-/* in main1 */\n-/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" } } */\n+/* 2 loops vectorized in main1, 2 loops vectorized in main:\n+   the first loop in main requires vectorization of conversions,\n+   the second loop in main requires vectorization of misaliged load:  */\n+\n+/* main && main1 together: */\n+/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 2 \"vect\" { target powerpc*-*-* } } } */\n /* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 2 \"vect\" { target vect_no_align } } } */\n /* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 3 \"vect\" { xfail vect_no_align } } } */\n \n-/* in main */\n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail vect_no_align } } } */\n+/* in main1: */\n+/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" { target {! powerpc*-*-* } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" { target vect_no_align } } } */\n+\n+/* in main: */\n+/* { dg-final { scan-tree-dump-times \"vectorized 0 loops\" 1 \"vect\" { target vect_no_align } } } */\n /* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { xfail vect_no_align } } } */\n+\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "bcf2e36fc5a91c7d4f452d6c8d3a6d296dac33f6", "filename": "gcc/testsuite/gcc.dg/vect/vect-iv-11.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57d17f1fc2f31047644ed6f18f1087f65f8f88b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-iv-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57d17f1fc2f31047644ed6f18f1087f65f8f88b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-iv-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-iv-11.c?ref=f57d17f1fc2f31047644ed6f18f1087f65f8f88b", "patch": "@@ -28,5 +28,5 @@ int main (void)\n   return 0;\n } \n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "7ee07035db0de2c66da2177efd82d74c6f0e1a0f", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57d17f1fc2f31047644ed6f18f1087f65f8f88b/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57d17f1fc2f31047644ed6f18f1087f65f8f88b/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=f57d17f1fc2f31047644ed6f18f1087f65f8f88b", "patch": "@@ -315,6 +315,7 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n \n \t      ok = (vectorizable_type_promotion (stmt, NULL, NULL)\n \t\t    || vectorizable_type_demotion (stmt, NULL, NULL)\n+\t\t    || vectorizable_conversion (stmt, NULL, NULL)\n \t\t    || vectorizable_operation (stmt, NULL, NULL)\n \t\t    || vectorizable_assignment (stmt, NULL, NULL)\n \t\t    || vectorizable_load (stmt, NULL, NULL)"}, {"sha": "db7a0ce61b1d1fa7f4c3bf4b64d664904c00bcd8", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57d17f1fc2f31047644ed6f18f1087f65f8f88b/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57d17f1fc2f31047644ed6f18f1087f65f8f88b/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=f57d17f1fc2f31047644ed6f18f1087f65f8f88b", "patch": "@@ -405,7 +405,10 @@ expand_vector_operations_1 (block_stmt_iterator *bsi)\n       && TREE_CODE_CLASS (code) != tcc_binary)\n     return;\n \n-  if (code == NOP_EXPR || code == VIEW_CONVERT_EXPR)\n+  if (code == NOP_EXPR \n+      || code == FLOAT_EXPR\n+      || code == FIX_TRUNC_EXPR\n+      || code == VIEW_CONVERT_EXPR)\n     return;\n   \n   gcc_assert (code != CONVERT_EXPR);"}, {"sha": "e901d00dc9888f8ce0cf52c7c0b869aaf2e8737d", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57d17f1fc2f31047644ed6f18f1087f65f8f88b/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57d17f1fc2f31047644ed6f18f1087f65f8f88b/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=f57d17f1fc2f31047644ed6f18f1087f65f8f88b", "patch": "@@ -1951,6 +1951,157 @@ vectorizable_call (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n }\n \n \n+/* Function vectorizable_conversion.\n+\n+Check if STMT performs a conversion operation, that can be vectorized. \n+If VEC_STMT is also passed, vectorize the STMT: create a vectorized \n+stmt to replace it, put it in VEC_STMT, and insert it at BSI.\n+Return FALSE if not a vectorizable STMT, TRUE otherwise.  */\n+\n+bool\n+vectorizable_conversion (tree stmt, block_stmt_iterator * bsi,\n+\t\t\t\t   tree * vec_stmt)\n+{\n+  tree vec_dest;\n+  tree scalar_dest;\n+  tree operation;\n+  tree op0;\n+  tree vec_oprnd0 = NULL_TREE;\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  enum tree_code code;\n+  tree new_temp;\n+  tree def, def_stmt;\n+  enum vect_def_type dt0;\n+  tree new_stmt;\n+  int nunits_in;\n+  int nunits_out;\n+  int ncopies, j;\n+  tree vectype_out, vectype_in;\n+  tree rhs_type, lhs_type;\n+  tree builtin_decl, params;\n+  stmt_vec_info prev_stmt_info;\n+\n+  /* Is STMT a vectorizable conversion?   */\n+\n+  if (!STMT_VINFO_RELEVANT_P (stmt_info))\n+    return false;\n+\n+  gcc_assert (STMT_VINFO_DEF_TYPE (stmt_info) == vect_loop_def);\n+\n+  if (STMT_VINFO_LIVE_P (stmt_info))\n+    {\n+      /* FORNOW: not yet supported.  */\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+\tfprintf (vect_dump, \"value used after loop.\");\n+      return false;\n+    }\n+\n+  if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n+    return false;\n+\n+  if (TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 0)) != SSA_NAME)\n+    return false;\n+\n+  operation = GIMPLE_STMT_OPERAND (stmt, 1);\n+  code = TREE_CODE (operation);\n+  if (code != FIX_TRUNC_EXPR && code != FLOAT_EXPR)\n+    return false;\n+\n+  /* Check types of lhs and rhs */\n+  op0 = TREE_OPERAND (operation, 0);\n+  rhs_type = TREE_TYPE (op0);\n+  vectype_in = get_vectype_for_scalar_type (rhs_type);\n+  nunits_in = TYPE_VECTOR_SUBPARTS (vectype_in);\n+\n+  scalar_dest = GIMPLE_STMT_OPERAND (stmt, 0);\n+  lhs_type = TREE_TYPE (scalar_dest);\n+  vectype_out = get_vectype_for_scalar_type (lhs_type);\n+  gcc_assert (STMT_VINFO_VECTYPE (stmt_info) == vectype_out);\n+  nunits_out = TYPE_VECTOR_SUBPARTS (vectype_out);\n+\n+  /* FORNOW: need to extend to support short<->float conversions as well.  */\n+  if (nunits_out != nunits_in)\n+    return false;\n+\n+  /* Bail out if the types are both integral or non-integral */\n+  if ((INTEGRAL_TYPE_P (rhs_type) && INTEGRAL_TYPE_P (lhs_type))\n+      || (!INTEGRAL_TYPE_P (rhs_type) && !INTEGRAL_TYPE_P (lhs_type)))\n+    return false;\n+\n+  /* Sanity check: make sure that at least one copy of the vectorized stmt\n+     needs to be generated.  */\n+  ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits_in;\n+  gcc_assert (ncopies >= 1);\n+\n+  if (!vect_is_simple_use (op0, loop_vinfo, &def_stmt, &def, &dt0))\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+\tfprintf (vect_dump, \"use not simple.\");\n+      return false;\n+    }\n+\n+  /* Supportable by target?  */\n+  if (!targetm.vectorize.builtin_conversion (code, vectype_in))\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"op not supported by target.\");\n+      return false;\n+    }\n+\n+  if (!vec_stmt)\t\t/* transformation not required.  */\n+    {\n+      STMT_VINFO_TYPE (stmt_info) = type_conversion_vec_info_type;\n+      return true;\n+    }\n+\n+    /** Transform.  **/\n+\n+  if (vect_print_dump_info (REPORT_DETAILS))\n+    fprintf (vect_dump, \"transform conversion.\");\n+\n+  /* Handle def.  */\n+  vec_dest = vect_create_destination_var (scalar_dest, vectype_out);\n+\n+  prev_stmt_info = NULL;\n+  for (j = 0; j < ncopies; j++)\n+    {\n+      tree sym;\n+      ssa_op_iter iter;\n+\n+      if (j == 0)\n+\tvec_oprnd0 = vect_get_vec_def_for_operand (op0, stmt, NULL);\n+      else\n+\tvec_oprnd0 = vect_get_vec_def_for_stmt_copy (dt0, vec_oprnd0);\n+      params = build_tree_list (NULL_TREE, vec_oprnd0);\n+\n+      builtin_decl =\n+\ttargetm.vectorize.builtin_conversion (code, vectype_in);\n+      new_stmt = build_function_call_expr (builtin_decl, params);\n+\n+      /* Arguments are ready. create the new vector stmt.  */\n+      new_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, vec_dest,\n+\t\t\t new_stmt);\n+      new_temp = make_ssa_name (vec_dest, new_stmt);\n+      GIMPLE_STMT_OPERAND (new_stmt, 0) = new_temp;\n+      vect_finish_stmt_generation (stmt, new_stmt, bsi);\n+      FOR_EACH_SSA_TREE_OPERAND (sym, new_stmt, iter, SSA_OP_ALL_VIRTUALS)\n+        {\n+          if (TREE_CODE (sym) == SSA_NAME)\n+            sym = SSA_NAME_VAR (sym);\n+          mark_sym_for_renaming (sym);\n+        }\n+\n+      if (j == 0)\n+\tSTMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n+      else\n+\tSTMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n+      prev_stmt_info = vinfo_for_stmt (new_stmt);\n+    }\n+  return true;\n+}\n+\n+\n /* Function vectorizable_assignment.\n \n    Check if STMT performs an assignment (copy) that can be vectorized. \n@@ -4098,6 +4249,11 @@ vect_transform_stmt (tree stmt, block_stmt_iterator *bsi, bool *strided_store)\n \tgcc_assert (done);\n \tbreak;\n \n+      case type_conversion_vec_info_type:\n+\tdone = vectorizable_conversion (stmt, bsi, &vec_stmt);\n+\tgcc_assert (done);\n+\tbreak;\n+\n       case op_vec_info_type:\n \tdone = vectorizable_operation (stmt, bsi, &vec_stmt);\n \tgcc_assert (done);"}, {"sha": "dd41f2b2b1586e319288a8149f09717e6c055837", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57d17f1fc2f31047644ed6f18f1087f65f8f88b/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57d17f1fc2f31047644ed6f18f1087f65f8f88b/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=f57d17f1fc2f31047644ed6f18f1087f65f8f88b", "patch": "@@ -168,7 +168,8 @@ enum stmt_vec_info_type {\n   condition_vec_info_type,\n   reduc_vec_info_type,\n   type_promotion_vec_info_type,\n-  type_demotion_vec_info_type\n+  type_demotion_vec_info_type,\n+  type_conversion_vec_info_type\n };\n \n /* Indicates whether/how a variable is used in the loop.  */\n@@ -411,6 +412,8 @@ extern bool vectorizable_store (tree, block_stmt_iterator *, tree *);\n extern bool vectorizable_operation (tree, block_stmt_iterator *, tree *);\n extern bool vectorizable_type_promotion (tree, block_stmt_iterator *, tree *);\n extern bool vectorizable_type_demotion (tree, block_stmt_iterator *, tree *);\n+extern bool vectorizable_conversion (tree, block_stmt_iterator *, \n+\t\t\t\t     tree *);\n extern bool vectorizable_assignment (tree, block_stmt_iterator *, tree *);\n extern tree vectorizable_function (tree, tree, tree);\n extern bool vectorizable_call (tree, block_stmt_iterator *, tree *);"}]}