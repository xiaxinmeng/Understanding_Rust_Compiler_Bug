{"sha": "a6baafcac5308be1a5d92c0b2a179495b7a24b52", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTZiYWFmY2FjNTMwOGJlMWE1ZDkyYzBiMmExNzk0OTViN2EyNGI1Mg==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-02-25T00:55:40Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-02-25T00:55:40Z"}, "message": "analyzer: fix false positive on realloc [PR99193]\n\nPR analyzer/99193 describes various false positives from\n-Wanalyzer-mismatching-deallocation on realloc(3) calls\nof the form:\n\n    |   31 |   void *p = malloc (1024);\n    |      |             ^~~~~~~~~~~~~\n    |      |             |\n    |      |             (1) allocated here (expects deallocation with \u2018free\u2019)\n    |   32 |   void *q = realloc (p, 4096);\n    |      |             ~~~~~~~~~~~~~~~~~\n    |      |             |\n    |      |             (2) deallocated with \u2018realloc\u2019 here; allocation at (1) expects deallocation with \u2018free\u2019\n    |\n\nThe underlying issue is that the analyzer has no knowledge of\nrealloc(3), and realloc has awkward semantics.\n\nUnfortunately, the analyzer is currently structured so that each call\nstatement can only have at most one successor state; there is no\nway to \"bifurcate\" the state, or have N-way splits into multiple\noutcomes.  The existing \"on_stmt\" code works on a copy of the next\nstate, updating it in place, rather than copying it and making any\nnecessary changes.  I did this as an optimization to avoid unnecessary\ncopying of state objects, but it makes it hard to support multiple\noutcomes.  (ideally our state objects would be immutable and thus\nsupport trivial copying, alternatively, C++11 move semantics may\nhelp here)\n\nI attempted a few approaches to implementing bifurcation within the\nexisting state-update framework, but they were messy and thus likely\nbuggy; a proper implementation would rework state-updating to\ngenerate copies, but this would be a major change, and seems too\nlate for GCC 11.\n\nAs a workaround, this patch implements enough of realloc(3) to\nsuppress the false positives.\n\nThis fixes the false positives in PR analyzer/99193.\nI've filed PR analyzer/99260 to track \"properly\" implementing realloc(3).\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/99193\n\t* region-model-impl-calls.cc (region_model::impl_call_realloc): New.\n\t* region-model.cc (region_model::on_call_pre): Call it.\n\t* region-model.h (region_model::impl_call_realloc): New decl.\n\t* sm-malloc.cc (enum wording): Add WORDING_REALLOCATED.\n\t(malloc_state_machine::m_realloc): New field.\n\t(use_after_free::describe_state_change): Add case for\n\tWORDING_REALLOCATED.\n\t(use_after_free::describe_final_event): Likewise.\n\t(malloc_state_machine::malloc_state_machine): Initialize\n\tm_realloc.\n\t(malloc_state_machine::on_stmt): Handle realloc by calling...\n\t(malloc_state_machine::on_realloc_call): New.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/99193\n\t* gcc.dg/analyzer/pr99193-1.c: New test.\n\t* gcc.dg/analyzer/pr99193-2.c: New test.\n\t* gcc.dg/analyzer/pr99193-3.c: New test.\n\t* gcc.dg/analyzer/realloc-1.c: New test.", "tree": {"sha": "8aeb92daee4014e212555e84a55af310f2de4c00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8aeb92daee4014e212555e84a55af310f2de4c00"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6baafcac5308be1a5d92c0b2a179495b7a24b52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6baafcac5308be1a5d92c0b2a179495b7a24b52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6baafcac5308be1a5d92c0b2a179495b7a24b52", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6baafcac5308be1a5d92c0b2a179495b7a24b52/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4028d01a050b478f245aab08702000976b7add2d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4028d01a050b478f245aab08702000976b7add2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4028d01a050b478f245aab08702000976b7add2d"}], "stats": {"total": 326, "additions": 324, "deletions": 2}, "files": [{"sha": "f83c12b5cb70d4bfb8a57276776b8d1e68b4f0be", "filename": "gcc/analyzer/region-model-impl-calls.cc", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6baafcac5308be1a5d92c0b2a179495b7a24b52/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6baafcac5308be1a5d92c0b2a179495b7a24b52/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc?ref=a6baafcac5308be1a5d92c0b2a179495b7a24b52", "patch": "@@ -428,6 +428,17 @@ region_model::impl_call_operator_delete (const call_details &cd)\n   return false;\n }\n \n+/* Handle the on_call_pre part of \"realloc\".  */\n+\n+void\n+region_model::impl_call_realloc (const call_details &)\n+{\n+  /* Currently we don't support bifurcating state, so there's no good\n+     way to implement realloc(3).\n+     For now, malloc_state_machine::on_realloc_call has a minimal\n+     implementation to suppress false positives.  */\n+}\n+\n /* Handle the on_call_pre part of \"strcpy\" and \"__builtin_strcpy_chk\".  */\n \n void"}, {"sha": "96ed549adf63f58f2cc7502e1d6d9147434c2f4d", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6baafcac5308be1a5d92c0b2a179495b7a24b52/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6baafcac5308be1a5d92c0b2a179495b7a24b52/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=a6baafcac5308be1a5d92c0b2a179495b7a24b52", "patch": "@@ -791,6 +791,9 @@ region_model::on_call_pre (const gcall *call, region_model_context *ctxt,\n \t    impl_call_memset (cd);\n \t    return false;\n \t    break;\n+\t  case BUILT_IN_REALLOC:\n+\t    impl_call_realloc (cd);\n+\t    return false;\n \t  case BUILT_IN_STRCPY:\n \t  case BUILT_IN_STRCPY_CHK:\n \t    impl_call_strcpy (cd);\n@@ -840,6 +843,11 @@ region_model::on_call_pre (const gcall *call, region_model_context *ctxt,\n \treturn impl_call_calloc (cd);\n       else if (is_named_call_p (callee_fndecl, \"alloca\", call, 1))\n \treturn impl_call_alloca (cd);\n+      else if (is_named_call_p (callee_fndecl, \"realloc\", call, 2))\n+\t{\n+\t  impl_call_realloc (cd);\n+\t  return false;\n+\t}\n       else if (is_named_call_p (callee_fndecl, \"error\"))\n \t{\n \t  if (impl_call_error (cd, 3, out_terminate_path))"}, {"sha": "54977f947eed1e4a076b3f1ecffcd232a448ca1d", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6baafcac5308be1a5d92c0b2a179495b7a24b52/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6baafcac5308be1a5d92c0b2a179495b7a24b52/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=a6baafcac5308be1a5d92c0b2a179495b7a24b52", "patch": "@@ -464,6 +464,7 @@ class region_model\n   bool impl_call_malloc (const call_details &cd);\n   void impl_call_memcpy (const call_details &cd);\n   bool impl_call_memset (const call_details &cd);\n+  void impl_call_realloc (const call_details &cd);\n   void impl_call_strcpy (const call_details &cd);\n   bool impl_call_strlen (const call_details &cd);\n   bool impl_call_operator_new (const call_details &cd);"}, {"sha": "ef250c80915d221b11ce80760e540554ccc77a19", "filename": "gcc/analyzer/sm-malloc.cc", "status": "modified", "additions": 68, "deletions": 2, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6baafcac5308be1a5d92c0b2a179495b7a24b52/gcc%2Fanalyzer%2Fsm-malloc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6baafcac5308be1a5d92c0b2a179495b7a24b52/gcc%2Fanalyzer%2Fsm-malloc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-malloc.cc?ref=a6baafcac5308be1a5d92c0b2a179495b7a24b52", "patch": "@@ -142,7 +142,8 @@ enum wording\n {\n   WORDING_FREED,\n   WORDING_DELETED,\n-  WORDING_DEALLOCATED\n+  WORDING_DEALLOCATED,\n+  WORDING_REALLOCATED\n };\n \n /* Base class representing a deallocation function,\n@@ -387,6 +388,8 @@ class malloc_state_machine : public state_machine\n   standard_deallocator_set m_scalar_delete;\n   standard_deallocator_set m_vector_delete;\n \n+  standard_deallocator m_realloc;\n+\n   /* States that are independent of api.  */\n \n   /* State for a pointer that's known to be NULL.  */\n@@ -417,6 +420,9 @@ class malloc_state_machine : public state_machine\n \t\t\t    const gcall *call,\n \t\t\t    const deallocator *d,\n \t\t\t    unsigned argno) const;\n+  void on_realloc_call (sm_context *sm_ctxt,\n+\t\t\tconst supernode *node,\n+\t\t\tconst gcall *call) const;\n   void on_zero_assignment (sm_context *sm_ctxt,\n \t\t\t   const gimple *stmt,\n \t\t\t   tree lhs) const;\n@@ -1151,6 +1157,7 @@ class use_after_free : public malloc_diagnostic\n \tswitch (m_deallocator->m_wording)\n \t  {\n \t  default:\n+\t  case WORDING_REALLOCATED:\n \t    gcc_unreachable ();\n \t  case WORDING_FREED:\n \t    return label_text::borrow (\"freed here\");\n@@ -1170,6 +1177,7 @@ class use_after_free : public malloc_diagnostic\n       switch (m_deallocator->m_wording)\n \t{\n \tdefault:\n+\tcase WORDING_REALLOCATED:\n \t  gcc_unreachable ();\n \tcase WORDING_FREED:\n \t  return ev.formatted_print (\"use after %<%s%> of %qE; freed at %@\",\n@@ -1361,7 +1369,8 @@ malloc_state_machine::malloc_state_machine (logger *logger)\n : state_machine (\"malloc\", logger),\n   m_free (this, \"free\", WORDING_FREED),\n   m_scalar_delete (this, \"delete\", WORDING_DELETED),\n-  m_vector_delete (this, \"delete[]\", WORDING_DELETED)\n+  m_vector_delete (this, \"delete[]\", WORDING_DELETED),\n+  m_realloc (this, \"realloc\", WORDING_REALLOCATED)\n {\n   gcc_assert (m_start->get_id () == 0);\n   m_null = add_state (\"null\", RS_FREED, NULL, NULL);\n@@ -1553,6 +1562,13 @@ malloc_state_machine::on_stmt (sm_context *sm_ctxt,\n \t    return true;\n \t  }\n \n+\tif (is_named_call_p (callee_fndecl, \"realloc\", call, 2)\n+\t    || is_named_call_p (callee_fndecl, \"__builtin_realloc\", call, 2))\n+\t  {\n+\t    on_realloc_call (sm_ctxt, node, call);\n+\t    return true;\n+\t  }\n+\n \t/* Cast away const-ness for cache-like operations.  */\n \tmalloc_state_machine *mutable_this\n \t  = const_cast <malloc_state_machine *> (this);\n@@ -1764,6 +1780,56 @@ malloc_state_machine::on_deallocator_call (sm_context *sm_ctxt,\n     }\n }\n \n+/* Implementation of realloc(3):\n+\n+     void *realloc(void *ptr, size_t size);\n+\n+   realloc(3) is awkward.\n+\n+   We currently don't have a way to express multiple possible outcomes\n+   from a function call, \"bifurcating\" the state such as:\n+   - success: non-NULL is returned\n+   - failure: NULL is returned, existing buffer is not freed.\n+   or even an N-way state split e.g.:\n+   - buffer grew successfully in-place\n+   - buffer was successfully moved to a larger allocation\n+   - buffer was successfully contracted\n+   - realloc failed, returning NULL, without freeing existing buffer.\n+   (PR analyzer/99260 tracks this)\n+\n+   Given that we can currently only express one outcome, eliminate\n+   false positives by dropping state from the buffer.  */\n+\n+void\n+malloc_state_machine::on_realloc_call (sm_context *sm_ctxt,\n+\t\t\t\t       const supernode *node ATTRIBUTE_UNUSED,\n+\t\t\t\t       const gcall *call) const\n+{\n+  tree ptr = gimple_call_arg (call, 0);\n+  tree diag_ptr = sm_ctxt->get_diagnostic_tree (ptr);\n+\n+  state_t state = sm_ctxt->get_state (call, ptr);\n+\n+  /* Detect mismatches.  */\n+  if (unchecked_p (state) || nonnull_p (state))\n+    {\n+      const allocation_state *astate = as_a_allocation_state (state);\n+      gcc_assert (astate->m_deallocators);\n+      if (astate->m_deallocators != &m_free)\n+\t{\n+\t  /* Wrong allocator.  */\n+\t  pending_diagnostic *pd\n+\t    = new mismatching_deallocation (*this, diag_ptr,\n+\t\t\t\t\t    astate->m_deallocators,\n+\t\t\t\t\t    &m_realloc);\n+\t  sm_ctxt->warn (node, call, ptr, pd);\n+\t}\n+    }\n+\n+  /* Transition ptr to \"stop\" state.  */\n+  sm_ctxt->set_next_state (call, ptr, m_stop);\n+}\n+\n /* Implementation of state_machine::on_phi vfunc for malloc_state_machine.  */\n \n void"}, {"sha": "c6179e9894884f47dc0fe61c881e269d687e4291", "filename": "gcc/testsuite/gcc.dg/analyzer/pr99193-1.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6baafcac5308be1a5d92c0b2a179495b7a24b52/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr99193-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6baafcac5308be1a5d92c0b2a179495b7a24b52/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr99193-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr99193-1.c?ref=a6baafcac5308be1a5d92c0b2a179495b7a24b52", "patch": "@@ -0,0 +1,65 @@\n+/* Verify absence of false positive from -Wanalyzer-mismatching-deallocation\n+   on realloc(3).\n+   Based on https://github.com/libguestfs/libguestfs/blob/f19fd566f6387ce7e4d82409528c9dde374d25e0/daemon/command.c#L115\n+   which is GPLv2 or later.  */\n+\n+typedef __SIZE_TYPE__ size_t;\n+typedef __builtin_va_list va_list;\n+\n+#define NULL ((void *)0)\n+\n+extern void *malloc (size_t __size)\n+  __attribute__ ((__nothrow__ , __leaf__))\n+  __attribute__ ((__malloc__))\n+  __attribute__ ((__alloc_size__ (1)));\n+extern void perror (const char *__s);\n+extern void *realloc (void *__ptr, size_t __size)\n+  __attribute__ ((__nothrow__ , __leaf__))\n+  __attribute__ ((__warn_unused_result__))\n+  __attribute__ ((__alloc_size__ (2)));\n+\n+extern void guestfs_int_cleanup_free (void *ptr);\n+extern int commandrvf (char **stdoutput, char **stderror, unsigned flags,\n+                       char const* const *argv);\n+#define CLEANUP_FREE __attribute__((cleanup(guestfs_int_cleanup_free))) \n+\n+int\n+commandrf (char **stdoutput, char **stderror, unsigned flags,\n+           const char *name, ...)\n+{\n+  va_list args;\n+  CLEANUP_FREE const char **argv = NULL;\n+  char *s;\n+  int i, r;\n+\n+  /* Collect the command line arguments into an array. */\n+  i = 2;\n+  argv = malloc (sizeof (char *) * i);\n+\n+ if (argv == NULL) {\n+    perror (\"malloc\");\n+    return -1;\n+  }\n+  argv[0] = (char *) name;\n+  argv[1] = NULL;\n+\n+  __builtin_va_start (args, name);\n+\n+  while ((s = __builtin_va_arg (args, char *)) != NULL) {\n+    const char **p = realloc (argv, sizeof (char *) * (++i)); /* { dg-bogus \"'free'\" } */\n+    if (p == NULL) {\n+      perror (\"realloc\");\n+      __builtin_va_end (args);\n+      return -1;\n+    }\n+    argv = p;\n+    argv[i-2] = s;\n+    argv[i-1] = NULL;\n+  }\n+\n+  __builtin_va_end (args);\n+\n+  r = commandrvf (stdoutput, stderror, flags, argv);\n+\n+  return r;\n+}"}, {"sha": "40e61817503f1550b47ba9de8113bc363ff3efd8", "filename": "gcc/testsuite/gcc.dg/analyzer/pr99193-2.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6baafcac5308be1a5d92c0b2a179495b7a24b52/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr99193-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6baafcac5308be1a5d92c0b2a179495b7a24b52/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr99193-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr99193-2.c?ref=a6baafcac5308be1a5d92c0b2a179495b7a24b52", "patch": "@@ -0,0 +1,68 @@\n+/* Verify absence of false positive from -Wanalyzer-mismatching-deallocation\n+   on realloc(3).\n+   Based on https://github.com/libguestfs/libguestfs/blob/f19fd566f6387ce7e4d82409528c9dde374d25e0/df/main.c#L404\n+   which is GPLv2 or later.  */\n+\n+typedef __SIZE_TYPE__ size_t;\n+typedef __builtin_va_list va_list;\n+\n+#define NULL ((void *)0)\n+\n+extern void free (void *);\n+extern void *realloc (void *__ptr, size_t __size)\n+  __attribute__ ((__nothrow__ , __leaf__))\n+  __attribute__ ((__warn_unused_result__))\n+  __attribute__ ((__alloc_size__ (2)));\n+char *strdup (const char *)\n+  __attribute__((malloc (free)));\n+\n+extern void error (int __status, int __errnum, const char *__format, ...)\n+     __attribute__ ((__format__ (__printf__, 3, 4)));\n+\n+extern int errno;\n+\n+struct drv\n+{\n+  struct drv *next;\n+};\n+\n+#define EXIT_FAILURE 1\n+\n+static char *\n+single_drive_display_name (struct drv *)\n+{\n+  char *result = strdup (\"placeholder\");\n+  if (!result)\n+    __builtin_abort ();\n+  return result;\n+}\n+\n+char *\n+make_display_name (struct drv *drvs)\n+{\n+  char *ret;\n+\n+  if (drvs->next == NULL)\n+    ret = single_drive_display_name (drvs);\n+  else {\n+    size_t pluses = 0;\n+    size_t i, len;\n+\n+    while (drvs->next != NULL) {\n+      drvs = drvs->next;\n+      pluses++;\n+    }\n+\n+    ret = single_drive_display_name (drvs);\n+    len = __builtin_strlen (ret);\n+\n+    ret = realloc (ret, len + pluses + 1); /* { dg-bogus \"'free'\" } */\n+    if (ret == NULL)\n+      error (EXIT_FAILURE, errno, \"realloc\");\n+    for (i = len; i < len + pluses; ++i)\n+      ret[i] = '+';\n+    ret[i] = '\\0';\n+  }\n+\n+  return ret;\n+}"}, {"sha": "3e7ffd652120c6f79cc2d07238e790a3414530a1", "filename": "gcc/testsuite/gcc.dg/analyzer/pr99193-3.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6baafcac5308be1a5d92c0b2a179495b7a24b52/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr99193-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6baafcac5308be1a5d92c0b2a179495b7a24b52/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr99193-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr99193-3.c?ref=a6baafcac5308be1a5d92c0b2a179495b7a24b52", "patch": "@@ -0,0 +1,48 @@\n+/* Verify absence of false positive from -Wanalyzer-mismatching-deallocation\n+   on realloc(3).\n+   Based on https://github.com/libguestfs/libguestfs/blob/f19fd566f6387ce7e4d82409528c9dde374d25e0/daemon/debug.c#L115\n+   which is GPLv2 or later.  */\n+\n+typedef __SIZE_TYPE__ size_t;\n+typedef __builtin_va_list va_list;\n+\n+#define NULL ((void *)0)\n+\n+extern void free (void *);\n+extern void *realloc (void *__ptr, size_t __size)\n+  __attribute__ ((__nothrow__ , __leaf__))\n+  __attribute__ ((__warn_unused_result__))\n+  __attribute__ ((__alloc_size__ (2)));\n+extern char *strdup (const char *)\n+  __attribute__((malloc (free)));\n+extern char *strcat (char *__restrict __dest, const char *__restrict __src)\n+  __attribute__ ((__nothrow__ , __leaf__))\n+  __attribute__ ((__nonnull__ (1, 2)));\n+\n+static char *\n+debug_help (const char **cmds, size_t argc, char *const *const argv)\n+{\n+  size_t len, i;\n+  char *r, *p;\n+\n+  r = strdup (\"Commands supported:\");\n+  if (!r) {\n+    return NULL;\n+  }\n+\n+  len = __builtin_strlen (r);\n+  for (i = 0; cmds[i] != NULL; ++i) {\n+    len += __builtin_strlen (cmds[i]) + 1;\n+    p = realloc (r, len + 1); /* { dg-bogus \"'free'\" } */\n+    if (p == NULL) {\n+      free (r);\n+      return NULL;\n+    }\n+    r = p;\n+\n+    strcat (r, \" \");\n+    strcat (r, cmds[i]);\n+  }\n+\n+  return r;\n+}"}, {"sha": "a6c6bfc3b224f4cea1644f4f2ee29b0956febe98", "filename": "gcc/testsuite/gcc.dg/analyzer/realloc-1.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6baafcac5308be1a5d92c0b2a179495b7a24b52/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Frealloc-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6baafcac5308be1a5d92c0b2a179495b7a24b52/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Frealloc-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Frealloc-1.c?ref=a6baafcac5308be1a5d92c0b2a179495b7a24b52", "patch": "@@ -0,0 +1,55 @@\n+typedef __SIZE_TYPE__ size_t;\n+\n+#define NULL ((void *)0)\n+\n+extern void *malloc (size_t __size)\n+  __attribute__ ((__nothrow__ , __leaf__))\n+  __attribute__ ((__malloc__))\n+  __attribute__ ((__alloc_size__ (1)));\n+extern void *realloc (void *__ptr, size_t __size)\n+  __attribute__ ((__nothrow__ , __leaf__))\n+  __attribute__ ((__warn_unused_result__))\n+  __attribute__ ((__alloc_size__ (2)));\n+extern void free (void *__ptr)\n+  __attribute__ ((__nothrow__ , __leaf__));\n+\n+void *test_1 (void *ptr)\n+{\n+  return realloc (ptr, 1024);\n+}\n+\n+void *test_2 (void *ptr)\n+{\n+  void *p = malloc (1024);\n+  p = realloc (p, 4096);\n+  /* TODO: should warn about the leak when the above call fails (PR analyzer/99260).  */\n+  free (p);\n+}\n+\n+void *test_3 (void *ptr)\n+{\n+  void *p = malloc (1024);\n+  void *q = realloc (p, 4096);\n+  if (q)\n+    free (q);\n+  else\n+    free (p);\n+}\n+\n+void *test_4 (void)\n+{\n+  return realloc (NULL, 1024);\n+}\n+\n+int *test_5 (int *p)\n+{\n+  *p = 42;\n+  int *q = realloc (p, sizeof(int) * 4);\n+  *q = 43; /* { dg-warning \"possibly-NULL 'q'\" \"PR analyzer/99260\" { xfail *-*-* } } */\n+  return q;\n+}\n+\n+void test_6 (size_t sz)\n+{\n+  void *p = realloc (NULL, sz);\n+} /* { dg-warning \"leak of 'p'\" } */"}]}