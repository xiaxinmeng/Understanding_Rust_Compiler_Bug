{"sha": "b3df2256e7526fc21a65332b7b72502758d27a7b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjNkZjIyNTZlNzUyNmZjMjFhNjUzMzJiN2I3MjUwMjc1OGQyN2E3Yg==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2010-09-16T21:07:00Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2010-09-16T21:07:00Z"}, "message": "* config/i386/i386.md: Rearrange divmod patterns a bit.\n\nFrom-SVN: r164347", "tree": {"sha": "3abe57f8584f56260d8127447a47acf98c826867", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3abe57f8584f56260d8127447a47acf98c826867"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3df2256e7526fc21a65332b7b72502758d27a7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3df2256e7526fc21a65332b7b72502758d27a7b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3df2256e7526fc21a65332b7b72502758d27a7b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3df2256e7526fc21a65332b7b72502758d27a7b/comments", "author": null, "committer": null, "parents": [{"sha": "26ec93086a8792dc68ffe89f4f464af72757ef90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26ec93086a8792dc68ffe89f4f464af72757ef90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26ec93086a8792dc68ffe89f4f464af72757ef90"}], "stats": {"total": 350, "additions": 175, "deletions": 175}, "files": [{"sha": "ec43793b951a49658d2008754c8c67d1af552b7a", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 175, "deletions": 175, "changes": 350, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3df2256e7526fc21a65332b7b72502758d27a7b/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3df2256e7526fc21a65332b7b72502758d27a7b/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=b3df2256e7526fc21a65332b7b72502758d27a7b", "patch": "@@ -7154,125 +7154,6 @@\n \f\n ;; Divmod instructions.\n \n-(define_expand \"divmodqi4\"\n-  [(parallel [(set (match_operand:QI 0 \"register_operand\" \"\")\n-\t\t   (div:QI\n-\t\t     (match_operand:QI 1 \"register_operand\" \"\")\n-\t\t     (match_operand:QI 2 \"nonimmediate_operand\" \"\")))\n-\t      (set (match_operand:QI 3 \"register_operand\" \"\")\n-\t\t   (mod:QI (match_dup 1) (match_dup 2)))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"TARGET_QIMODE_MATH\"\n-{\n-  rtx div, mod, insn;\n-  rtx tmp0, tmp1;\n-  \n-  tmp0 = gen_reg_rtx (HImode);\n-  tmp1 = gen_reg_rtx (HImode);\n-\n-  /* Extend operands[1] to HImode.  Generate 8bit divide.  Result is\n-     in AX.  */\n-  emit_insn (gen_extendqihi2 (tmp1, operands[1]));\n-  emit_insn (gen_divmodhiqi3 (tmp0, tmp1, operands[2]));\n-\n-  /* Extract remainder from AH.  */\n-  tmp1 = gen_rtx_SIGN_EXTRACT (QImode, tmp0, GEN_INT (8), GEN_INT (8));\n-  insn = emit_move_insn (operands[3], tmp1);\n-\n-  mod = gen_rtx_MOD (QImode, operands[1], operands[2]);\n-  set_unique_reg_note (insn, REG_EQUAL, mod);\n-\n-  /* Extract quotient from AL.  */\n-  insn = emit_move_insn (operands[0], gen_lowpart (QImode, tmp0));\n-\n-  div = gen_rtx_DIV (QImode, operands[1], operands[2]);\n-  set_unique_reg_note (insn, REG_EQUAL, div);\n-\n-  DONE;\n-})\n-\n-(define_expand \"udivmodqi4\"\n-  [(parallel [(set (match_operand:QI 0 \"register_operand\" \"\")\n-\t\t   (udiv:QI\n-\t\t     (match_operand:QI 1 \"register_operand\" \"\")\n-\t\t     (match_operand:QI 2 \"nonimmediate_operand\" \"\")))\n-\t      (set (match_operand:QI 3 \"register_operand\" \"\")\n-\t\t   (umod:QI (match_dup 1) (match_dup 2)))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"TARGET_QIMODE_MATH\"\n-{\n-  rtx div, mod, insn;\n-  rtx tmp0, tmp1;\n-  \n-  tmp0 = gen_reg_rtx (HImode);\n-  tmp1 = gen_reg_rtx (HImode);\n-\n-  /* Extend operands[1] to HImode.  Generate 8bit divide.  Result is\n-     in AX.  */\n-  emit_insn (gen_zero_extendqihi2 (tmp1, operands[1]));\n-  emit_insn (gen_udivmodhiqi3 (tmp0, tmp1, operands[2]));\n-\n-  /* Extract remainder from AH.  */\n-  tmp1 = gen_rtx_ZERO_EXTRACT (SImode, tmp0, GEN_INT (8), GEN_INT (8));\n-  tmp1 = simplify_gen_subreg (QImode, tmp1, SImode, 0);\n-  insn = emit_move_insn (operands[3], tmp1);\n-\n-  mod = gen_rtx_UMOD (QImode, operands[1], operands[2]);\n-  set_unique_reg_note (insn, REG_EQUAL, mod);\n-\n-  /* Extract quotient from AL.  */\n-  insn = emit_move_insn (operands[0], gen_lowpart (QImode, tmp0));\n-\n-  div = gen_rtx_UDIV (QImode, operands[1], operands[2]);\n-  set_unique_reg_note (insn, REG_EQUAL, div);\n-\n-  DONE;\n-})\n-\n-;; Divide AX by r/m8, with result stored in\n-;; AL <- Quotient\n-;; AH <- Remainder\n-;; Change div/mod to HImode and extend the second argument to HImode\n-;; so that mode of div/mod matches with mode of arguments.  Otherwise\n-;; combine may fail.\n-(define_insn \"divmodhiqi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=a\")\n-\t(ior:HI\n-\t  (ashift:HI\n-\t    (zero_extend:HI\n-\t      (truncate:QI\n-\t\t(mod:HI (match_operand:HI 1 \"register_operand\" \"0\")\n-\t\t\t(sign_extend:HI\n-\t\t\t  (match_operand:QI 2 \"nonimmediate_operand\" \"qm\")))))\n-\t    (const_int 8))\n-\t  (zero_extend:HI\n-\t    (truncate:QI\n-\t      (div:HI (match_dup 1) (sign_extend:HI (match_dup 2)))))))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_QIMODE_MATH\"\n-  \"idiv{b}\\t%2\"\n-  [(set_attr \"type\" \"idiv\")\n-   (set_attr \"mode\" \"QI\")])\n-\n-(define_insn \"udivmodhiqi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=a\")\n-\t(ior:HI\n-\t  (ashift:HI\n-\t    (zero_extend:HI\n-\t      (truncate:QI\n-\t\t(mod:HI (match_operand:HI 1 \"register_operand\" \"0\")\n-\t\t\t(zero_extend:HI\n-\t\t\t  (match_operand:QI 2 \"nonimmediate_operand\" \"qm\")))))\n-\t    (const_int 8))\n-\t  (zero_extend:HI\n-\t    (truncate:QI\n-\t      (div:HI (match_dup 1) (zero_extend:HI (match_dup 2)))))))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_QIMODE_MATH\"\n-  \"div{b}\\t%2\"\n-  [(set_attr \"type\" \"idiv\")\n-   (set_attr \"mode\" \"QI\")])\n-\n (define_expand \"divmod<mode>4\"\n   [(parallel [(set (match_operand:SWIM248 0 \"register_operand\" \"\")\n \t\t   (div:SWIM248\n@@ -7282,41 +7163,6 @@\n \t\t   (mod:SWIM248 (match_dup 1) (match_dup 2)))\n \t      (clobber (reg:CC FLAGS_REG))])])\n \n-(define_insn_and_split \"*divmod<mode>4\"\n-  [(set (match_operand:SWIM248 0 \"register_operand\" \"=a\")\n-\t(div:SWIM248 (match_operand:SWIM248 2 \"register_operand\" \"0\")\n-\t\t    (match_operand:SWIM248 3 \"nonimmediate_operand\" \"rm\")))\n-   (set (match_operand:SWIM248 1 \"register_operand\" \"=&d\")\n-\t(mod:SWIM248 (match_dup 2) (match_dup 3)))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"\"\n-  \"#\"\n-  \"reload_completed\"\n-  [(parallel [(set (match_dup 1)\n-\t\t   (ashiftrt:SWIM248 (match_dup 4) (match_dup 5)))\n-\t      (clobber (reg:CC FLAGS_REG))])\n-   (parallel [(set (match_dup 0)\n-\t           (div:SWIM248 (match_dup 2) (match_dup 3)))\n-\t      (set (match_dup 1)\n-\t\t   (mod:SWIM248 (match_dup 2) (match_dup 3)))\n-\t      (use (match_dup 1))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-{\n-  operands[5] = GEN_INT (GET_MODE_BITSIZE (<MODE>mode)-1);\n-\n-  if (<MODE>mode != HImode\n-      && (optimize_function_for_size_p (cfun) || TARGET_USE_CLTD))\n-    operands[4] = operands[2];\n-  else\n-    {\n-      /* Avoid use of cltd in favor of a mov+shift.  */\n-      emit_move_insn (operands[1], operands[2]);\n-      operands[4] = operands[1];\n-    }\n-}\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"mode\" \"<MODE>\")])\n-\n ;; Split with 8bit unsigned divide:\n ;; \tif (dividend an divisor are in [0-255])\n ;;\t   use 8bit unsigned integer divide\n@@ -7371,6 +7217,41 @@\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n+(define_insn_and_split \"*divmod<mode>4\"\n+  [(set (match_operand:SWIM248 0 \"register_operand\" \"=a\")\n+\t(div:SWIM248 (match_operand:SWIM248 2 \"register_operand\" \"0\")\n+\t\t    (match_operand:SWIM248 3 \"nonimmediate_operand\" \"rm\")))\n+   (set (match_operand:SWIM248 1 \"register_operand\" \"=&d\")\n+\t(mod:SWIM248 (match_dup 2) (match_dup 3)))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 1)\n+\t\t   (ashiftrt:SWIM248 (match_dup 4) (match_dup 5)))\n+\t      (clobber (reg:CC FLAGS_REG))])\n+   (parallel [(set (match_dup 0)\n+\t           (div:SWIM248 (match_dup 2) (match_dup 3)))\n+\t      (set (match_dup 1)\n+\t\t   (mod:SWIM248 (match_dup 2) (match_dup 3)))\n+\t      (use (match_dup 1))\n+\t      (clobber (reg:CC FLAGS_REG))])]\n+{\n+  operands[5] = GEN_INT (GET_MODE_BITSIZE (<MODE>mode)-1);\n+\n+  if (<MODE>mode != HImode\n+      && (optimize_function_for_size_p (cfun) || TARGET_USE_CLTD))\n+    operands[4] = operands[2];\n+  else\n+    {\n+      /* Avoid use of cltd in favor of a mov+shift.  */\n+      emit_move_insn (operands[1], operands[2]);\n+      operands[4] = operands[1];\n+    }\n+}\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n (define_insn \"*divmod<mode>4_noext\"\n   [(set (match_operand:SWIM248 0 \"register_operand\" \"=a\")\n \t(div:SWIM248 (match_operand:SWIM248 2 \"register_operand\" \"0\")\n@@ -7384,6 +7265,68 @@\n   [(set_attr \"type\" \"idiv\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n+(define_expand \"divmodqi4\"\n+  [(parallel [(set (match_operand:QI 0 \"register_operand\" \"\")\n+\t\t   (div:QI\n+\t\t     (match_operand:QI 1 \"register_operand\" \"\")\n+\t\t     (match_operand:QI 2 \"nonimmediate_operand\" \"\")))\n+\t      (set (match_operand:QI 3 \"register_operand\" \"\")\n+\t\t   (mod:QI (match_dup 1) (match_dup 2)))\n+\t      (clobber (reg:CC FLAGS_REG))])]\n+  \"TARGET_QIMODE_MATH\"\n+{\n+  rtx div, mod, insn;\n+  rtx tmp0, tmp1;\n+  \n+  tmp0 = gen_reg_rtx (HImode);\n+  tmp1 = gen_reg_rtx (HImode);\n+\n+  /* Extend operands[1] to HImode.  Generate 8bit divide.  Result is\n+     in AX.  */\n+  emit_insn (gen_extendqihi2 (tmp1, operands[1]));\n+  emit_insn (gen_divmodhiqi3 (tmp0, tmp1, operands[2]));\n+\n+  /* Extract remainder from AH.  */\n+  tmp1 = gen_rtx_SIGN_EXTRACT (QImode, tmp0, GEN_INT (8), GEN_INT (8));\n+  insn = emit_move_insn (operands[3], tmp1);\n+\n+  mod = gen_rtx_MOD (QImode, operands[1], operands[2]);\n+  set_unique_reg_note (insn, REG_EQUAL, mod);\n+\n+  /* Extract quotient from AL.  */\n+  insn = emit_move_insn (operands[0], gen_lowpart (QImode, tmp0));\n+\n+  div = gen_rtx_DIV (QImode, operands[1], operands[2]);\n+  set_unique_reg_note (insn, REG_EQUAL, div);\n+\n+  DONE;\n+})\n+\n+;; Divide AX by r/m8, with result stored in\n+;; AL <- Quotient\n+;; AH <- Remainder\n+;; Change div/mod to HImode and extend the second argument to HImode\n+;; so that mode of div/mod matches with mode of arguments.  Otherwise\n+;; combine may fail.\n+(define_insn \"divmodhiqi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=a\")\n+\t(ior:HI\n+\t  (ashift:HI\n+\t    (zero_extend:HI\n+\t      (truncate:QI\n+\t\t(mod:HI (match_operand:HI 1 \"register_operand\" \"0\")\n+\t\t\t(sign_extend:HI\n+\t\t\t  (match_operand:QI 2 \"nonimmediate_operand\" \"qm\")))))\n+\t    (const_int 8))\n+\t  (zero_extend:HI\n+\t    (truncate:QI\n+\t      (div:HI (match_dup 1) (sign_extend:HI (match_dup 2)))))))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_QIMODE_MATH\"\n+  \"idiv{b}\\t%2\"\n+  [(set_attr \"type\" \"idiv\")\n+   (set_attr \"mode\" \"QI\")])\n+\n (define_expand \"udivmod<mode>4\"\n   [(parallel [(set (match_operand:SWIM248 0 \"register_operand\" \"\")\n \t\t   (udiv:SWIM248\n@@ -7393,27 +7336,6 @@\n \t\t   (umod:SWIM248 (match_dup 1) (match_dup 2)))\n \t      (clobber (reg:CC FLAGS_REG))])])\n \n-(define_insn_and_split \"*udivmod<mode>4\"\n-  [(set (match_operand:SWIM248 0 \"register_operand\" \"=a\")\n-\t(udiv:SWIM248 (match_operand:SWIM248 2 \"register_operand\" \"0\")\n-\t\t      (match_operand:SWIM248 3 \"nonimmediate_operand\" \"rm\")))\n-   (set (match_operand:SWIM248 1 \"register_operand\" \"=&d\")\n-\t(umod:SWIM248 (match_dup 2) (match_dup 3)))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"\"\n-  \"#\"\n-  \"reload_completed\"\n-  [(set (match_dup 1) (const_int 0))\n-   (parallel [(set (match_dup 0)\n-\t\t   (udiv:SWIM248 (match_dup 2) (match_dup 3)))\n-\t      (set (match_dup 1)\n-\t\t   (umod:SWIM248 (match_dup 2) (match_dup 3)))\n-\t      (use (match_dup 1))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"\"\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"mode\" \"<MODE>\")])\n-\n ;; Split with 8bit unsigned divide:\n ;; \tif (dividend an divisor are in [0-255])\n ;;\t   use 8bit unsigned integer divide\n@@ -7455,6 +7377,27 @@\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n+(define_insn_and_split \"*udivmod<mode>4\"\n+  [(set (match_operand:SWIM248 0 \"register_operand\" \"=a\")\n+\t(udiv:SWIM248 (match_operand:SWIM248 2 \"register_operand\" \"0\")\n+\t\t      (match_operand:SWIM248 3 \"nonimmediate_operand\" \"rm\")))\n+   (set (match_operand:SWIM248 1 \"register_operand\" \"=&d\")\n+\t(umod:SWIM248 (match_dup 2) (match_dup 3)))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (match_dup 1) (const_int 0))\n+   (parallel [(set (match_dup 0)\n+\t\t   (udiv:SWIM248 (match_dup 2) (match_dup 3)))\n+\t      (set (match_dup 1)\n+\t\t   (umod:SWIM248 (match_dup 2) (match_dup 3)))\n+\t      (use (match_dup 1))\n+\t      (clobber (reg:CC FLAGS_REG))])]\n+  \"\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n (define_insn \"*udivmod<mode>4_noext\"\n   [(set (match_operand:SWIM248 0 \"register_operand\" \"=a\")\n \t(udiv:SWIM248 (match_operand:SWIM248 2 \"register_operand\" \"0\")\n@@ -7468,6 +7411,63 @@\n   [(set_attr \"type\" \"idiv\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n+(define_expand \"udivmodqi4\"\n+  [(parallel [(set (match_operand:QI 0 \"register_operand\" \"\")\n+\t\t   (udiv:QI\n+\t\t     (match_operand:QI 1 \"register_operand\" \"\")\n+\t\t     (match_operand:QI 2 \"nonimmediate_operand\" \"\")))\n+\t      (set (match_operand:QI 3 \"register_operand\" \"\")\n+\t\t   (umod:QI (match_dup 1) (match_dup 2)))\n+\t      (clobber (reg:CC FLAGS_REG))])]\n+  \"TARGET_QIMODE_MATH\"\n+{\n+  rtx div, mod, insn;\n+  rtx tmp0, tmp1;\n+  \n+  tmp0 = gen_reg_rtx (HImode);\n+  tmp1 = gen_reg_rtx (HImode);\n+\n+  /* Extend operands[1] to HImode.  Generate 8bit divide.  Result is\n+     in AX.  */\n+  emit_insn (gen_zero_extendqihi2 (tmp1, operands[1]));\n+  emit_insn (gen_udivmodhiqi3 (tmp0, tmp1, operands[2]));\n+\n+  /* Extract remainder from AH.  */\n+  tmp1 = gen_rtx_ZERO_EXTRACT (SImode, tmp0, GEN_INT (8), GEN_INT (8));\n+  tmp1 = simplify_gen_subreg (QImode, tmp1, SImode, 0);\n+  insn = emit_move_insn (operands[3], tmp1);\n+\n+  mod = gen_rtx_UMOD (QImode, operands[1], operands[2]);\n+  set_unique_reg_note (insn, REG_EQUAL, mod);\n+\n+  /* Extract quotient from AL.  */\n+  insn = emit_move_insn (operands[0], gen_lowpart (QImode, tmp0));\n+\n+  div = gen_rtx_UDIV (QImode, operands[1], operands[2]);\n+  set_unique_reg_note (insn, REG_EQUAL, div);\n+\n+  DONE;\n+})\n+\n+(define_insn \"udivmodhiqi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=a\")\n+\t(ior:HI\n+\t  (ashift:HI\n+\t    (zero_extend:HI\n+\t      (truncate:QI\n+\t\t(mod:HI (match_operand:HI 1 \"register_operand\" \"0\")\n+\t\t\t(zero_extend:HI\n+\t\t\t  (match_operand:QI 2 \"nonimmediate_operand\" \"qm\")))))\n+\t    (const_int 8))\n+\t  (zero_extend:HI\n+\t    (truncate:QI\n+\t      (div:HI (match_dup 1) (zero_extend:HI (match_dup 2)))))))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_QIMODE_MATH\"\n+  \"div{b}\\t%2\"\n+  [(set_attr \"type\" \"idiv\")\n+   (set_attr \"mode\" \"QI\")])\n+\n ;; We cannot use div/idiv for double division, because it causes\n ;; \"division by zero\" on the overflow and that's not what we expect\n ;; from truncate.  Because true (non truncating) double division is"}]}