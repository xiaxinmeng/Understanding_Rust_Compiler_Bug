{"sha": "c94974caeddd0561408261d5c2a37331edc8a52e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzk0OTc0Y2FlZGRkMDU2MTQwODI2MWQ1YzJhMzczMzFlZGM4YTUyZQ==", "commit": {"author": {"name": "Bo Thorsen", "email": "bo@suse.de", "date": "2002-07-18T23:08:31Z"}, "committer": {"name": "Bo Thorsen", "email": "bo@gcc.gnu.org", "date": "2002-07-18T23:08:31Z"}, "message": "[multiple changes]\n\n2002-07-16  Bo Thorsen  <bo@suse.de>\n\n\t* src/x86/ffi64.c: New file that adds x86-64 support.\n\t* src/x86/unix64.S: New file that handles argument setup for\n\tx86-64.\n\t* src/x86/sysv.S: Don't use this on x86-64.\n\t* src/x86/ffi.c: Don't use this on x86-64.\n\tRemove unused vars.\n\t* src/prep_cif.c (ffi_prep_cif): Don't do stack size calculation\n\tfor x86-64.\n\t* src/ffitest.c (struct6): New test that tests a special case in\n\tthe x86-64 ABI.\n\t(struct7): Likewise.\n\t(struct8): Likewise.\n\t(struct9): Likewise.\n\t(closure_test_fn): Silence warning about this when it's not used.\n\t(main): Add the new tests.\n\t(main): Fix a couple of wrong casts and silence some compiler warnings.\n\t* include/ffi.h.in: Add x86-64 ABI definition.\n\t* fficonfig.h.in: Regenerate.\n\t* Makefile.am: Add x86-64 support.\n\t* configure.in: Likewise.\n\t* Makefile.in: Regenerate.\n\t* configure: Likewise.\n\n2002-06-24  Bo Thorsen  <bo@suse.de>\n\n\t* src/types.c: Merge settings for similar architectures.\n\tAdd x86-64 sizes and alignments.\n\n2002-06-23  Bo Thorsen  <bo@suse.de>\n\n\t* src/arm/ffi.c (ffi_prep_args): Remove unused vars.\n\t* src/sparc/ffi.c (ffi_prep_args_v8): Likewise.\n\t* src/mips/ffi.c (ffi_prep_args): Likewise.\n\t* src/m68k/ffi.c (ffi_prep_args): Likewise.\n\nFrom-SVN: r55571", "tree": {"sha": "31860a62cf64b5a75a76259340d1e0a1ac48ef45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/31860a62cf64b5a75a76259340d1e0a1ac48ef45"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c94974caeddd0561408261d5c2a37331edc8a52e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c94974caeddd0561408261d5c2a37331edc8a52e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c94974caeddd0561408261d5c2a37331edc8a52e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c94974caeddd0561408261d5c2a37331edc8a52e/comments", "author": null, "committer": null, "parents": [{"sha": "ad28cff7c180b612f54512fd7f7ed7b11f09fc05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad28cff7c180b612f54512fd7f7ed7b11f09fc05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad28cff7c180b612f54512fd7f7ed7b11f09fc05"}], "stats": {"total": 1334, "additions": 1174, "deletions": 160}, "files": [{"sha": "bee21111372ef6cb76b3d000d789150f4f4b240d", "filename": "libffi/ChangeLog", "status": "modified", "additions": 37, "deletions": 5, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94974caeddd0561408261d5c2a37331edc8a52e/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94974caeddd0561408261d5c2a37331edc8a52e/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=c94974caeddd0561408261d5c2a37331edc8a52e", "patch": "@@ -1,3 +1,40 @@\n+2002-07-16  Bo Thorsen  <bo@suse.de>\n+\n+\t* src/x86/ffi64.c: New file that adds x86-64 support.\n+\t* src/x86/unix64.S: New file that handles argument setup for\n+\tx86-64.\n+\t* src/x86/sysv.S: Don't use this on x86-64.\n+\t* src/x86/ffi.c: Don't use this on x86-64.\n+\tRemove unused vars.\n+\t* src/prep_cif.c (ffi_prep_cif): Don't do stack size calculation\n+\tfor x86-64.\n+\t* src/ffitest.c (struct6): New test that tests a special case in\n+\tthe x86-64 ABI.\n+\t(struct7): Likewise.\n+\t(struct8): Likewise.\n+\t(struct9): Likewise.\n+\t(closure_test_fn): Silence warning about this when it's not used.\n+\t(main): Add the new tests.\n+\t(main): Fix a couple of wrong casts and silence some compiler warnings.\n+\t* include/ffi.h.in: Add x86-64 ABI definition.\n+\t* fficonfig.h.in: Regenerate.\n+\t* Makefile.am: Add x86-64 support.\n+\t* configure.in: Likewise.\n+\t* Makefile.in: Regenerate.\n+\t* configure: Likewise.\n+\n+2002-06-24  Bo Thorsen  <bo@suse.de>\n+\n+\t* src/types.c: Merge settings for similar architectures.\n+\tAdd x86-64 sizes and alignments.\n+\n+2002-06-23  Bo Thorsen  <bo@suse.de>\n+\n+\t* src/arm/ffi.c (ffi_prep_args): Remove unused vars.\n+\t* src/sparc/ffi.c (ffi_prep_args_v8): Likewise.\n+\t* src/mips/ffi.c (ffi_prep_args): Likewise.\n+\t* src/m68k/ffi.c (ffi_prep_args): Likewise.\n+\n 2002-07-18  H.J. Lu  (hjl@gnu.org)\n \n \t* Makefile.am (TARGET_SRC_MIPS_LINUX): New.\n@@ -15,11 +52,6 @@\n \n \t* src/s390/sysv.S: Save/restore %r6.  Add DWARF-2 unwind info.\n \n-2002-05-28  Bo Thorsen  <bo@suse.de>\n-\n-\t* src/x86/ffi.c (ffi_prep_incoming_args_SYSV): Remove\n-\tthe same unused avn var from this one too.\n-\n 2002-05-27  Roger Sayle  <roger@eyesopen.com>\n \n \t* src/x86/ffi.c (ffi_prep_args): Remove reference to avn."}, {"sha": "d21c9334556edcc0c7108696ff95a2e16f9bf615", "filename": "libffi/Makefile.am", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94974caeddd0561408261d5c2a37331edc8a52e/libffi%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94974caeddd0561408261d5c2a37331edc8a52e/libffi%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FMakefile.am?ref=c94974caeddd0561408261d5c2a37331edc8a52e", "patch": "@@ -8,6 +8,7 @@ EXTRA_DIST = LICENSE ChangeLog.v1 src/mips/ffi.c src/mips/n32.S \\\n \t\tsrc/mips/n32.s src/mips/o32.S src/mips/o32.s \\\n \t\tsrc/sparc/ffi.c src/sparc/v8.S src/sparc/v9.S \\\n \t\tsrc/x86/ffi.c src/x86/sysv.S src/x86/win32.S \\\n+\t\tsrc/x86/ffi64.c src/x86/unix64.S \\\n \t\tsrc/alpha/ffi.c src/alpha/osf.S \\\n \t\tsrc/m68k/ffi.c src/m68k/sysv.S \\\n \t\tsrc/powerpc/ffi.c src/powerpc/sysv.S \\\n@@ -106,6 +107,7 @@ TARGET_SRC_POWERPC_AIX = src/powerpc/ffi_darwin.c src/powerpc/aix.S src/powerpc/\n TARGET_SRC_POWERPC_DARWIN = src/powerpc/ffi_darwin.c src/powerpc/darwin.S src/powerpc/darwin_closure.S\n TARGET_SRC_ARM =  src/arm/sysv.S src/arm/ffi.c\n TARGET_SRC_S390 =  src/s390/sysv.S src/s390/ffi.c\n+TARGET_SRC_X86_64 = src/x86/ffi64.c src/x86/unix64.S src/x86/ffi.c src/x86/sysv.S\n \n ##libffi_la_SOURCES = src/debug.c src/prep_cif.c src/types.c $(TARGET_SRC_@TARGET@)\n ## Work around automake deficiency\n@@ -167,6 +169,10 @@ if S390\n libffi_la_SOURCES = $(libffi_la_common_SOURCES) $(TARGET_SRC_S390)\n libffi_convenience_la_SOURCES = $(libffi_la_common_SOURCES) $(TARGET_SRC_S390)\n endif\n+if X86_64\n+libffi_la_SOURCES = $(libffi_la_common_SOURCES) $(TARGET_SRC_X86_64)\n+libffi_convenience_la_SOURCES = $(libffi_la_common_SOURCES) $(TARGET_SRC_X86_64)\n+endif\n \n AM_CFLAGS = -fexceptions\n "}, {"sha": "793c3aaf86c43fc78d74ba1c754c9d12496caacd", "filename": "libffi/Makefile.in", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94974caeddd0561408261d5c2a37331edc8a52e/libffi%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94974caeddd0561408261d5c2a37331edc8a52e/libffi%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FMakefile.in?ref=c94974caeddd0561408261d5c2a37331edc8a52e", "patch": "@@ -89,6 +89,7 @@ EXTRA_DIST = LICENSE ChangeLog.v1 src/mips/ffi.c src/mips/n32.S \\\n \t\tsrc/mips/n32.s src/mips/o32.S src/mips/o32.s \\\n \t\tsrc/sparc/ffi.c src/sparc/v8.S src/sparc/v9.S \\\n \t\tsrc/x86/ffi.c src/x86/sysv.S src/x86/win32.S \\\n+\t\tsrc/x86/ffi64.c src/x86/unix64.S \\\n \t\tsrc/alpha/ffi.c src/alpha/osf.S \\\n \t\tsrc/m68k/ffi.c src/m68k/sysv.S \\\n \t\tsrc/powerpc/ffi.c src/powerpc/sysv.S \\\n@@ -177,6 +178,7 @@ TARGET_SRC_POWERPC_AIX = src/powerpc/ffi_darwin.c src/powerpc/aix.S src/powerpc/\n TARGET_SRC_POWERPC_DARWIN = src/powerpc/ffi_darwin.c src/powerpc/darwin.S src/powerpc/darwin_closure.S\n TARGET_SRC_ARM = src/arm/sysv.S src/arm/ffi.c\n TARGET_SRC_S390 = src/s390/sysv.S src/s390/ffi.c\n+TARGET_SRC_X86_64 = src/x86/ffi64.c src/x86/unix64.S src/x86/ffi.c src/x86/sysv.S\n \n libffi_la_common_SOURCES = src/debug.c src/prep_cif.c src/types.c \\\n \t\tsrc/raw_api.c src/java_raw_api.c\n@@ -195,6 +197,7 @@ libffi_la_common_SOURCES = src/debug.c src/prep_cif.c src/types.c \\\n @POWERPC_DARWIN_TRUE@libffi_la_SOURCES = @POWERPC_DARWIN_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_POWERPC_DARWIN)\n @ARM_TRUE@libffi_la_SOURCES = @ARM_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_ARM)\n @S390_TRUE@libffi_la_SOURCES = @S390_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_S390)\n+@X86_64_TRUE@libffi_la_SOURCES = @X86_64_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_X86_64)\n @MIPS_GCC_TRUE@libffi_convenience_la_SOURCES = @MIPS_GCC_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_MIPS_GCC)\n @MIPS_LINUX_TRUE@libffi_convenience_la_SOURCES = @MIPS_LINUX_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_MIPS_LINUX)\n @MIPS_SGI_TRUE@libffi_convenience_la_SOURCES = @MIPS_SGI_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_MIPS_SGI)\n@@ -209,6 +212,7 @@ libffi_la_common_SOURCES = src/debug.c src/prep_cif.c src/types.c \\\n @POWERPC_DARWIN_TRUE@libffi_convenience_la_SOURCES = @POWERPC_DARWIN_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_POWERPC_DARWIN)\n @ARM_TRUE@libffi_convenience_la_SOURCES = @ARM_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_ARM)\n @S390_TRUE@libffi_convenience_la_SOURCES = @S390_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_S390)\n+@X86_64_TRUE@libffi_convenience_la_SOURCES = @X86_64_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_X86_64)\n \n AM_CFLAGS = -fexceptions\n \n@@ -304,6 +308,9 @@ libffi_la_LIBADD =\n @S390_TRUE@libffi_la_OBJECTS =  src/debug.lo src/prep_cif.lo \\\n @S390_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \\\n @S390_TRUE@src/s390/sysv.lo src/s390/ffi.lo\n+@X86_64_TRUE@libffi_convenience_la_OBJECTS =  src/debug.lo src/prep_cif.lo \\\n+@X86_64_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \\\n+@X86_64_TRUE@src/x86/ffi.lo src/x86/sysv.lo src/x86/unix64.lo src/x86/ffi64.lo\n @X86_TRUE@libffi_la_OBJECTS =  src/debug.lo src/prep_cif.lo src/types.lo \\\n @X86_TRUE@src/raw_api.lo src/java_raw_api.lo src/x86/ffi.lo \\\n @X86_TRUE@src/x86/sysv.lo\n@@ -323,6 +330,9 @@ libffi_la_LIBADD =\n @M68K_TRUE@libffi_la_OBJECTS =  src/debug.lo src/prep_cif.lo \\\n @M68K_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \\\n @M68K_TRUE@src/m68k/ffi.lo src/m68k/sysv.lo\n+@X86_64_TRUE@libffi_la_OBJECTS =  src/debug.lo src/prep_cif.lo src/types.lo \\\n+@X86_64_TRUE@src/raw_api.lo src/java_raw_api.lo src/x86/ffi.lo \\\n+@X86_64_TRUE@src/x86/sysv.lo src/x86/unix64.lo src/x86/ffi64.lo\n noinst_PROGRAMS =  ffitest$(EXEEXT)\n PROGRAMS =  $(noinst_PROGRAMS)\n "}, {"sha": "d18f6dd5bc5a3932b6bfee5ee42ecc59a32d9fcf", "filename": "libffi/configure", "status": "modified", "additions": 78, "deletions": 66, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94974caeddd0561408261d5c2a37331edc8a52e/libffi%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94974caeddd0561408261d5c2a37331edc8a52e/libffi%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fconfigure?ref=c94974caeddd0561408261d5c2a37331edc8a52e", "patch": "@@ -2395,6 +2395,7 @@ powerpc-*-aix*) TARGET=POWERPC_AIX; TARGETDIR=powerpc;;\n rs6000-*-aix*) TARGET=POWERPC_AIX; TARGETDIR=powerpc;;\n arm*-*-linux-*) TARGET=ARM; TARGETDIR=arm;;\n s390-*-linux-*) TARGET=S390; TARGETDIR=s390;;\n+x86_64-*-linux*) TARGET=X86_64; TARGETDIR=x86;;\n esac\n \n if test $TARGETDIR = unknown; then\n@@ -2528,12 +2529,21 @@ else\n   S390_FALSE=\n fi\n \n+\n+if test x$TARGET = xX86_64; then\n+  X86_64_TRUE=\n+  X86_64_FALSE='#'\n+else\n+  X86_64_TRUE='#'\n+  X86_64_FALSE=\n+fi\n+\n if test x$TARGET = xMIPS_LINUX; then\n   TARGET=MIPS\n fi\n \n echo $ac_n \"checking how to run the C preprocessor\"\"... $ac_c\" 1>&6\n-echo \"configure:2537: checking how to run the C preprocessor\" >&5\n+echo \"configure:2547: checking how to run the C preprocessor\" >&5\n # On Suns, sometimes $CPP names a directory.\n if test -n \"$CPP\" && test -d \"$CPP\"; then\n   CPP=\n@@ -2548,13 +2558,13 @@ else\n   # On the NeXT, cc -E runs the code through the compiler's parser,\n   # not just through cpp.\n   cat > conftest.$ac_ext <<EOF\n-#line 2552 \"configure\"\n+#line 2562 \"configure\"\n #include \"confdefs.h\"\n #include <assert.h>\n Syntax Error\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:2558: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:2568: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n if test -z \"$ac_err\"; then\n   :\n@@ -2565,13 +2575,13 @@ else\n   rm -rf conftest*\n   CPP=\"${CC-cc} -E -traditional-cpp\"\n   cat > conftest.$ac_ext <<EOF\n-#line 2569 \"configure\"\n+#line 2579 \"configure\"\n #include \"confdefs.h\"\n #include <assert.h>\n Syntax Error\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:2575: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:2585: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n if test -z \"$ac_err\"; then\n   :\n@@ -2582,13 +2592,13 @@ else\n   rm -rf conftest*\n   CPP=\"${CC-cc} -nologo -E\"\n   cat > conftest.$ac_ext <<EOF\n-#line 2586 \"configure\"\n+#line 2596 \"configure\"\n #include \"confdefs.h\"\n #include <assert.h>\n Syntax Error\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:2592: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:2602: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n if test -z \"$ac_err\"; then\n   :\n@@ -2613,20 +2623,20 @@ fi\n echo \"$ac_t\"\"$CPP\" 1>&6\n \n echo $ac_n \"checking for ANSI C header files\"\"... $ac_c\" 1>&6\n-echo \"configure:2617: checking for ANSI C header files\" >&5\n+echo \"configure:2627: checking for ANSI C header files\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_header_stdc'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2622 \"configure\"\n+#line 2632 \"configure\"\n #include \"confdefs.h\"\n #include <stdlib.h>\n #include <stdarg.h>\n #include <string.h>\n #include <float.h>\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:2630: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:2640: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n if test -z \"$ac_err\"; then\n   rm -rf conftest*\n@@ -2643,7 +2653,7 @@ rm -f conftest*\n if test $ac_cv_header_stdc = yes; then\n   # SunOS 4.x string.h does not declare mem*, contrary to ANSI.\n cat > conftest.$ac_ext <<EOF\n-#line 2647 \"configure\"\n+#line 2657 \"configure\"\n #include \"confdefs.h\"\n #include <string.h>\n EOF\n@@ -2661,7 +2671,7 @@ fi\n if test $ac_cv_header_stdc = yes; then\n   # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.\n cat > conftest.$ac_ext <<EOF\n-#line 2665 \"configure\"\n+#line 2675 \"configure\"\n #include \"confdefs.h\"\n #include <stdlib.h>\n EOF\n@@ -2682,7 +2692,7 @@ if test \"$cross_compiling\" = yes; then\n   :\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2686 \"configure\"\n+#line 2696 \"configure\"\n #include \"confdefs.h\"\n #include <ctype.h>\n #define ISLOWER(c) ('a' <= (c) && (c) <= 'z')\n@@ -2693,7 +2703,7 @@ if (XOR (islower (i), ISLOWER (i)) || toupper (i) != TOUPPER (i)) exit(2);\n exit (0); }\n \n EOF\n-if { (eval echo configure:2697: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n+if { (eval echo configure:2707: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n then\n   :\n else\n@@ -2719,12 +2729,12 @@ fi\n for ac_func in memcpy\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:2723: checking for $ac_func\" >&5\n+echo \"configure:2733: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2728 \"configure\"\n+#line 2738 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -2747,7 +2757,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:2751: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:2761: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -2774,19 +2784,19 @@ done\n # The Ultrix 4.2 mips builtin alloca declared by alloca.h only works\n # for constant arguments.  Useless!\n echo $ac_n \"checking for working alloca.h\"\"... $ac_c\" 1>&6\n-echo \"configure:2778: checking for working alloca.h\" >&5\n+echo \"configure:2788: checking for working alloca.h\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_header_alloca_h'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2783 \"configure\"\n+#line 2793 \"configure\"\n #include \"confdefs.h\"\n #include <alloca.h>\n int main() {\n char *p = alloca(2 * sizeof(int));\n ; return 0; }\n EOF\n-if { (eval echo configure:2790: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:2800: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   ac_cv_header_alloca_h=yes\n else\n@@ -2807,12 +2817,12 @@ EOF\n fi\n \n echo $ac_n \"checking for alloca\"\"... $ac_c\" 1>&6\n-echo \"configure:2811: checking for alloca\" >&5\n+echo \"configure:2821: checking for alloca\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_alloca_works'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2816 \"configure\"\n+#line 2826 \"configure\"\n #include \"confdefs.h\"\n \n #ifdef __GNUC__\n@@ -2840,7 +2850,7 @@ int main() {\n char *p = (char *) alloca(1);\n ; return 0; }\n EOF\n-if { (eval echo configure:2844: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:2854: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   ac_cv_func_alloca_works=yes\n else\n@@ -2872,12 +2882,12 @@ EOF\n \n \n echo $ac_n \"checking whether alloca needs Cray hooks\"\"... $ac_c\" 1>&6\n-echo \"configure:2876: checking whether alloca needs Cray hooks\" >&5\n+echo \"configure:2886: checking whether alloca needs Cray hooks\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_os_cray'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2881 \"configure\"\n+#line 2891 \"configure\"\n #include \"confdefs.h\"\n #if defined(CRAY) && ! defined(CRAY2)\n webecray\n@@ -2902,12 +2912,12 @@ echo \"$ac_t\"\"$ac_cv_os_cray\" 1>&6\n if test $ac_cv_os_cray = yes; then\n for ac_func in _getb67 GETB67 getb67; do\n   echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:2906: checking for $ac_func\" >&5\n+echo \"configure:2916: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2911 \"configure\"\n+#line 2921 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -2930,7 +2940,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:2934: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:2944: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -2957,15 +2967,15 @@ done\n fi\n \n echo $ac_n \"checking stack direction for C alloca\"\"... $ac_c\" 1>&6\n-echo \"configure:2961: checking stack direction for C alloca\" >&5\n+echo \"configure:2971: checking stack direction for C alloca\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_c_stack_direction'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   if test \"$cross_compiling\" = yes; then\n   ac_cv_c_stack_direction=0\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2969 \"configure\"\n+#line 2979 \"configure\"\n #include \"confdefs.h\"\n find_stack_direction ()\n {\n@@ -2984,7 +2994,7 @@ main ()\n   exit (find_stack_direction() < 0);\n }\n EOF\n-if { (eval echo configure:2988: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n+if { (eval echo configure:2998: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n then\n   ac_cv_c_stack_direction=1\n else\n@@ -3007,13 +3017,13 @@ fi\n \n \n echo $ac_n \"checking size of short\"\"... $ac_c\" 1>&6\n-echo \"configure:3011: checking size of short\" >&5\n+echo \"configure:3021: checking size of short\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_sizeof_short'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   for ac_size in 4 8 1 2 16 12  ; do # List sizes in rough order of prevalence.\n   cat > conftest.$ac_ext <<EOF\n-#line 3017 \"configure\"\n+#line 3027 \"configure\"\n #include \"confdefs.h\"\n #include \"confdefs.h\"\n #include <sys/types.h>\n@@ -3023,7 +3033,7 @@ int main() {\n switch (0) case 0: case (sizeof (short) == $ac_size):;\n ; return 0; }\n EOF\n-if { (eval echo configure:3027: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:3037: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_sizeof_short=$ac_size\n else\n@@ -3046,13 +3056,13 @@ EOF\n \n \n echo $ac_n \"checking size of int\"\"... $ac_c\" 1>&6\n-echo \"configure:3050: checking size of int\" >&5\n+echo \"configure:3060: checking size of int\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_sizeof_int'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   for ac_size in 4 8 1 2 16 12  ; do # List sizes in rough order of prevalence.\n   cat > conftest.$ac_ext <<EOF\n-#line 3056 \"configure\"\n+#line 3066 \"configure\"\n #include \"confdefs.h\"\n #include \"confdefs.h\"\n #include <sys/types.h>\n@@ -3062,7 +3072,7 @@ int main() {\n switch (0) case 0: case (sizeof (int) == $ac_size):;\n ; return 0; }\n EOF\n-if { (eval echo configure:3066: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:3076: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_sizeof_int=$ac_size\n else\n@@ -3085,13 +3095,13 @@ EOF\n \n \n echo $ac_n \"checking size of long\"\"... $ac_c\" 1>&6\n-echo \"configure:3089: checking size of long\" >&5\n+echo \"configure:3099: checking size of long\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_sizeof_long'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   for ac_size in 4 8 1 2 16 12  ; do # List sizes in rough order of prevalence.\n   cat > conftest.$ac_ext <<EOF\n-#line 3095 \"configure\"\n+#line 3105 \"configure\"\n #include \"confdefs.h\"\n #include \"confdefs.h\"\n #include <sys/types.h>\n@@ -3101,7 +3111,7 @@ int main() {\n switch (0) case 0: case (sizeof (long) == $ac_size):;\n ; return 0; }\n EOF\n-if { (eval echo configure:3105: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:3115: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_sizeof_long=$ac_size\n else\n@@ -3124,13 +3134,13 @@ EOF\n \n \n echo $ac_n \"checking size of long long\"\"... $ac_c\" 1>&6\n-echo \"configure:3128: checking size of long long\" >&5\n+echo \"configure:3138: checking size of long long\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_sizeof_long_long'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   for ac_size in 4 8 1 2 16 12  ; do # List sizes in rough order of prevalence.\n   cat > conftest.$ac_ext <<EOF\n-#line 3134 \"configure\"\n+#line 3144 \"configure\"\n #include \"confdefs.h\"\n #include \"confdefs.h\"\n #include <sys/types.h>\n@@ -3140,7 +3150,7 @@ int main() {\n switch (0) case 0: case (sizeof (long long) == $ac_size):;\n ; return 0; }\n EOF\n-if { (eval echo configure:3144: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:3154: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_sizeof_long_long=$ac_size\n else\n@@ -3163,13 +3173,13 @@ EOF\n \n \n echo $ac_n \"checking size of float\"\"... $ac_c\" 1>&6\n-echo \"configure:3167: checking size of float\" >&5\n+echo \"configure:3177: checking size of float\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_sizeof_float'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   for ac_size in 4 8 1 2 16 12  ; do # List sizes in rough order of prevalence.\n   cat > conftest.$ac_ext <<EOF\n-#line 3173 \"configure\"\n+#line 3183 \"configure\"\n #include \"confdefs.h\"\n #include \"confdefs.h\"\n #include <sys/types.h>\n@@ -3179,7 +3189,7 @@ int main() {\n switch (0) case 0: case (sizeof (float) == $ac_size):;\n ; return 0; }\n EOF\n-if { (eval echo configure:3183: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:3193: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_sizeof_float=$ac_size\n else\n@@ -3202,13 +3212,13 @@ EOF\n \n \n echo $ac_n \"checking size of double\"\"... $ac_c\" 1>&6\n-echo \"configure:3206: checking size of double\" >&5\n+echo \"configure:3216: checking size of double\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_sizeof_double'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   for ac_size in 4 8 1 2 16 12  ; do # List sizes in rough order of prevalence.\n   cat > conftest.$ac_ext <<EOF\n-#line 3212 \"configure\"\n+#line 3222 \"configure\"\n #include \"confdefs.h\"\n #include \"confdefs.h\"\n #include <sys/types.h>\n@@ -3218,7 +3228,7 @@ int main() {\n switch (0) case 0: case (sizeof (double) == $ac_size):;\n ; return 0; }\n EOF\n-if { (eval echo configure:3222: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:3232: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_sizeof_double=$ac_size\n else\n@@ -3241,13 +3251,13 @@ EOF\n \n \n echo $ac_n \"checking size of long double\"\"... $ac_c\" 1>&6\n-echo \"configure:3245: checking size of long double\" >&5\n+echo \"configure:3255: checking size of long double\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_sizeof_long_double'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   for ac_size in 4 8 1 2 16 12  ; do # List sizes in rough order of prevalence.\n   cat > conftest.$ac_ext <<EOF\n-#line 3251 \"configure\"\n+#line 3261 \"configure\"\n #include \"confdefs.h\"\n #include \"confdefs.h\"\n #include <sys/types.h>\n@@ -3257,7 +3267,7 @@ int main() {\n switch (0) case 0: case (sizeof (long double) == $ac_size):;\n ; return 0; }\n EOF\n-if { (eval echo configure:3261: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:3271: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_sizeof_long_double=$ac_size\n else\n@@ -3281,13 +3291,13 @@ EOF\n \n \n echo $ac_n \"checking size of void *\"\"... $ac_c\" 1>&6\n-echo \"configure:3285: checking size of void *\" >&5\n+echo \"configure:3295: checking size of void *\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_sizeof_void_p'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   for ac_size in 4 8 1 2 16 12  ; do # List sizes in rough order of prevalence.\n   cat > conftest.$ac_ext <<EOF\n-#line 3291 \"configure\"\n+#line 3301 \"configure\"\n #include \"confdefs.h\"\n #include \"confdefs.h\"\n #include <sys/types.h>\n@@ -3297,7 +3307,7 @@ int main() {\n switch (0) case 0: case (sizeof (void *) == $ac_size):;\n ; return 0; }\n EOF\n-if { (eval echo configure:3301: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:3311: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_sizeof_void_p=$ac_size\n else\n@@ -3320,14 +3330,14 @@ EOF\n \n \n echo $ac_n \"checking whether byte ordering is bigendian\"\"... $ac_c\" 1>&6\n-echo \"configure:3324: checking whether byte ordering is bigendian\" >&5\n+echo \"configure:3334: checking whether byte ordering is bigendian\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_c_bigendian'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   ac_cv_c_bigendian=unknown\n # See if sys/param.h defines the BYTE_ORDER macro.\n cat > conftest.$ac_ext <<EOF\n-#line 3331 \"configure\"\n+#line 3341 \"configure\"\n #include \"confdefs.h\"\n #include <sys/types.h>\n #include <sys/param.h>\n@@ -3338,11 +3348,11 @@ int main() {\n #endif\n ; return 0; }\n EOF\n-if { (eval echo configure:3342: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:3352: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   # It does; now see whether it defined to BIG_ENDIAN or not.\n cat > conftest.$ac_ext <<EOF\n-#line 3346 \"configure\"\n+#line 3356 \"configure\"\n #include \"confdefs.h\"\n #include <sys/types.h>\n #include <sys/param.h>\n@@ -3353,7 +3363,7 @@ int main() {\n #endif\n ; return 0; }\n EOF\n-if { (eval echo configure:3357: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:3367: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_c_bigendian=yes\n else\n@@ -3373,7 +3383,7 @@ if test \"$cross_compiling\" = yes; then\n    echo $ac_n \"cross-compiling... \" 2>&6 \n else\n   cat > conftest.$ac_ext <<EOF\n-#line 3377 \"configure\"\n+#line 3387 \"configure\"\n #include \"confdefs.h\"\n main () {\n   /* Are we little or big endian?  From Harbison&Steele.  */\n@@ -3386,7 +3396,7 @@ main () {\n   exit (u.c[sizeof (long) - 1] == 1);\n }\n EOF\n-if { (eval echo configure:3390: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n+if { (eval echo configure:3400: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n then\n   ac_cv_c_bigendian=no\n else\n@@ -3404,7 +3414,7 @@ fi\n echo \"$ac_t\"\"$ac_cv_c_bigendian\" 1>&6\n if test $ac_cv_c_bigendian = unknown; then\n echo $ac_n \"checking to probe for byte ordering\"\"... $ac_c\" 1>&6\n-echo \"configure:3408: checking to probe for byte ordering\" >&5\n+echo \"configure:3418: checking to probe for byte ordering\" >&5\n \n cat >conftest.c <<EOF\n short ascii_mm[] = { 0x4249, 0x4765, 0x6E44, 0x6961, 0x6E53, 0x7953, 0 };\n@@ -3454,7 +3464,7 @@ fi\n \n if test x$TARGET = xSPARC; then\n     echo $ac_n \"checking assembler and linker support unaligned pc related relocs\"\"... $ac_c\" 1>&6\n-echo \"configure:3458: checking assembler and linker support unaligned pc related relocs\" >&5\n+echo \"configure:3468: checking assembler and linker support unaligned pc related relocs\" >&5\n if eval \"test \\\"`echo '$''{'libffi_cv_as_sparc_ua_pcrel'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3464,14 +3474,14 @@ else\n \tCFLAGS=\"$CFLAGS -fpic\"\n \tLDFLAGS=\"$LDFLAGS -shared\"\n \tcat > conftest.$ac_ext <<EOF\n-#line 3468 \"configure\"\n+#line 3478 \"configure\"\n #include \"confdefs.h\"\n asm (\".text; foo: nop; .data; .align 4; .byte 0; .uaword %r_disp32(foo); .text\");\n int main() {\n \n ; return 0; }\n EOF\n-if { (eval echo configure:3475: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:3485: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   libffi_cv_as_sparc_ua_pcrel=yes\n else\n@@ -3756,6 +3766,8 @@ s%@ARM_TRUE@%$ARM_TRUE%g\n s%@ARM_FALSE@%$ARM_FALSE%g\n s%@S390_TRUE@%$S390_TRUE%g\n s%@S390_FALSE@%$S390_FALSE%g\n+s%@X86_64_TRUE@%$X86_64_TRUE%g\n+s%@X86_64_FALSE@%$X86_64_FALSE%g\n s%@CPP@%$CPP%g\n s%@ALLOCA@%$ALLOCA%g\n s%@TARGET@%$TARGET%g"}, {"sha": "7852a981cace71d865e333c810c16a85e48867ea", "filename": "libffi/configure.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94974caeddd0561408261d5c2a37331edc8a52e/libffi%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94974caeddd0561408261d5c2a37331edc8a52e/libffi%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fconfigure.in?ref=c94974caeddd0561408261d5c2a37331edc8a52e", "patch": "@@ -70,6 +70,7 @@ powerpc-*-aix*) TARGET=POWERPC_AIX; TARGETDIR=powerpc;;\n rs6000-*-aix*) TARGET=POWERPC_AIX; TARGETDIR=powerpc;;\n arm*-*-linux-*) TARGET=ARM; TARGETDIR=arm;;\n s390-*-linux-*) TARGET=S390; TARGETDIR=s390;;\n+x86_64-*-linux*) TARGET=X86_64; TARGETDIR=x86;;\n esac\n \n if test $TARGETDIR = unknown; then\n@@ -90,6 +91,7 @@ AM_CONDITIONAL(POWERPC_AIX, test x$TARGET = xPOWERPC_AIX)\n AM_CONDITIONAL(POWERPC_DARWIN, test x$TARGET = xPOWERPC_DARWIN)\n AM_CONDITIONAL(ARM, test x$TARGET = xARM)\n AM_CONDITIONAL(S390, test x$TARGET = xS390)\n+AM_CONDITIONAL(X86_64, test x$TARGET = xX86_64)\n \n if test x$TARGET = xMIPS_LINUX; then\n   TARGET=MIPS"}, {"sha": "49e45706615f219e0bb248b1d0ffa75c451404fe", "filename": "libffi/include/ffi.h.in", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94974caeddd0561408261d5c2a37331edc8a52e/libffi%2Finclude%2Fffi.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94974caeddd0561408261d5c2a37331edc8a52e/libffi%2Finclude%2Fffi.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Finclude%2Fffi.h.in?ref=c94974caeddd0561408261d5c2a37331edc8a52e", "patch": "@@ -189,10 +189,15 @@ typedef enum ffi_abi {\n #endif\n #endif\n \n-  /* ---- Intel x86 ---------------- */\n-#ifdef X86\n+  /* ---- Intel x86 and AMD x86-64 - */\n+#if defined(X86) || defined(X86_64)\n   FFI_SYSV,\n+  FFI_UNIX64,   /* Unix variants all use the same ABI for x86-64  */\n+#ifdef X86\n   FFI_DEFAULT_ABI = FFI_SYSV,\n+#else\n+  FFI_DEFAULT_ABI = FFI_UNIX64,\n+#endif\n #endif\n \n   /* ---- Intel x86 Win32 ---------- */"}, {"sha": "dcd9891dcc2fd1717c2a1b4ce136f9a7183a1ef5", "filename": "libffi/src/arm/ffi.c", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94974caeddd0561408261d5c2a37331edc8a52e/libffi%2Fsrc%2Farm%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94974caeddd0561408261d5c2a37331edc8a52e/libffi%2Fsrc%2Farm%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Farm%2Fffi.c?ref=c94974caeddd0561408261d5c2a37331edc8a52e", "patch": "@@ -36,25 +36,21 @@ void ffi_prep_args(char *stack, extended_cif *ecif)\n /*@=exportheader@*/\n {\n   register unsigned int i;\n-  register int tmp;\n-  register unsigned int avn;\n   register void **p_argv;\n   register char *argp;\n   register ffi_type **p_arg;\n \n-  tmp = 0;\n   argp = stack;\n \n   if ( ecif->cif->rtype->type == FFI_TYPE_STRUCT ) {\n     *(void **) argp = ecif->rvalue;\n     argp += 4;\n   }\n \n-  avn = ecif->cif->nargs;\n   p_argv = ecif->avalue;\n \n   for (i = ecif->cif->nargs, p_arg = ecif->cif->arg_types;\n-       (i != 0) && (avn != 0);\n+       (i != 0);\n        i--, p_arg++)\n     {\n       size_t z;\n@@ -64,9 +60,6 @@ void ffi_prep_args(char *stack, extended_cif *ecif)\n \targp = (char *) ALIGN(argp, (*p_arg)->alignment);\n       }\n \n-      if (avn != 0) \n-\t{\n-\t  avn--;\n \t  z = (*p_arg)->size;\n \t  if (z < sizeof(int))\n \t    {\n@@ -107,7 +100,6 @@ void ffi_prep_args(char *stack, extended_cif *ecif)\n \t    }\n \t  p_argv++;\n \t  argp += z;\n-\t}\n     }\n   \n   return;"}, {"sha": "8d72df1cc031c2e95740733392e629bc9d5a75fe", "filename": "libffi/src/ffitest.c", "status": "modified", "additions": 266, "deletions": 13, "changes": 279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94974caeddd0561408261d5c2a37331edc8a52e/libffi%2Fsrc%2Fffitest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94974caeddd0561408261d5c2a37331edc8a52e/libffi%2Fsrc%2Fffitest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fffitest.c?ref=c94974caeddd0561408261d5c2a37331edc8a52e", "patch": "@@ -153,6 +153,33 @@ typedef struct\n   char c2;\n } test_structure_5;\n \n+typedef struct\n+{\n+  float f;\n+  double d;\n+} test_structure_6;\n+\n+typedef struct\n+{\n+  float f1;\n+  float f2;\n+  double d;\n+} test_structure_7;\n+\n+typedef struct\n+{\n+  float f1;\n+  float f2;\n+  float f3;\n+  float f4;\n+} test_structure_8;\n+\n+typedef struct\n+{\n+  float f;\n+  int i;\n+} test_structure_9;\n+\n static test_structure_1 struct1(test_structure_1 ts)\n {\n   /*@-type@*/\n@@ -194,15 +221,52 @@ static test_structure_5 struct5(test_structure_5 ts1, test_structure_5 ts2)\n   return ts1;\n }\n \n+static test_structure_6 struct6 (test_structure_6 ts)\n+{\n+  ts.f += 1;\n+  ts.d += 1;\n+\n+  return ts;\n+}\n+\n+static test_structure_7 struct7 (test_structure_7 ts)\n+{\n+  ts.f1 += 1;\n+  ts.f2 += 1;\n+  ts.d += 1;\n+\n+  return ts;\n+}\n+\n+static test_structure_8 struct8 (test_structure_8 ts)\n+{\n+  ts.f1 += 1;\n+  ts.f2 += 1;\n+  ts.f3 += 1;\n+  ts.f4 += 1;\n+\n+  return ts;\n+}\n+\n+static test_structure_9 struct9 (test_structure_9 ts)\n+{\n+  ts.f += 1;\n+  ts.i += 1;\n+\n+  return ts;\n+}\n+\n /* Take an int and a float argument, together with int userdata, and \t*/\n /* return the sum.\t\t\t\t\t\t\t*/\n-static void closure_test_fn(ffi_cif* cif,void* resp,void** args, void* userdata)\n+#if FFI_CLOSURES\n+static void\n+closure_test_fn(ffi_cif* cif,void* resp,void** args, void* userdata)\n {\n-    *(int*)resp =\n-\t *(int *)args[0] + (int)(*(float *)args[1]) + (int)(long)userdata;\n+  *(int*)resp = *(int*)args[0] + (int)(*(float*)args[1]) + (int)(long)userdata;\n }\n \n typedef int (*closure_test_type)(int, float);\n+#endif\n \n int main(/*@unused@*/ int argc, /*@unused@*/ char *argv[])\n {\n@@ -230,11 +294,19 @@ int main(/*@unused@*/ int argc, /*@unused@*/ char *argv[])\n   ffi_type ts3_type;\n   ffi_type ts4_type;  \n   ffi_type ts5_type;\n+  ffi_type ts6_type;\n+  ffi_type ts7_type;\n+  ffi_type ts8_type;\n+  ffi_type ts9_type;\n   ffi_type *ts1_type_elements[4];\n   ffi_type *ts2_type_elements[3];\n   ffi_type *ts3_type_elements[2];\n   ffi_type *ts4_type_elements[4];\n   ffi_type *ts5_type_elements[3];\n+  ffi_type *ts6_type_elements[3];\n+  ffi_type *ts7_type_elements[4];\n+  ffi_type *ts8_type_elements[5];\n+  ffi_type *ts9_type_elements[3];\n \n   ts1_type.size = 0;\n   ts1_type.alignment = 0;\n@@ -256,12 +328,32 @@ int main(/*@unused@*/ int argc, /*@unused@*/ char *argv[])\n   ts5_type.alignment = 0;\n   ts5_type.type = FFI_TYPE_STRUCT;\n \n+  ts6_type.size = 0;\n+  ts6_type.alignment = 0;\n+  ts6_type.type = FFI_TYPE_STRUCT;\n+\n+  ts7_type.size = 0;\n+  ts7_type.alignment = 0;\n+  ts7_type.type = FFI_TYPE_STRUCT;\n+\n+  ts8_type.size = 0;\n+  ts8_type.alignment = 0;\n+  ts8_type.type = FFI_TYPE_STRUCT;\n+\n+  ts9_type.size = 0;\n+  ts9_type.alignment = 0;\n+  ts9_type.type = FFI_TYPE_STRUCT;\n+\n   /*@-immediatetrans@*/\n   ts1_type.elements = ts1_type_elements;\n   ts2_type.elements = ts2_type_elements;\n   ts3_type.elements = ts3_type_elements;\n   ts4_type.elements = ts4_type_elements;\n   ts5_type.elements = ts5_type_elements;\n+  ts6_type.elements = ts6_type_elements;\n+  ts7_type.elements = ts7_type_elements;\n+  ts8_type.elements = ts8_type_elements;\n+  ts9_type.elements = ts9_type_elements;\n   /*@=immediatetrans@*/\n   \n   ts1_type_elements[0] = &ffi_type_uchar;\n@@ -285,6 +377,25 @@ int main(/*@unused@*/ int argc, /*@unused@*/ char *argv[])\n   ts5_type_elements[1] = &ffi_type_schar;\n   ts5_type_elements[2] = NULL;\n \n+  ts6_type_elements[0] = &ffi_type_float;\n+  ts6_type_elements[1] = &ffi_type_double;\n+  ts6_type_elements[2] = NULL;\n+\n+  ts7_type_elements[0] = &ffi_type_float;\n+  ts7_type_elements[1] = &ffi_type_float;\n+  ts7_type_elements[2] = &ffi_type_double;\n+  ts7_type_elements[3] = NULL;\n+\n+  ts8_type_elements[0] = &ffi_type_float;\n+  ts8_type_elements[1] = &ffi_type_float;\n+  ts8_type_elements[2] = &ffi_type_float;\n+  ts8_type_elements[3] = &ffi_type_float;\n+  ts8_type_elements[4] = NULL;\n+\n+  ts9_type_elements[0] = &ffi_type_float;\n+  ts9_type_elements[1] = &ffi_type_sint;\n+  ts9_type_elements[2] = NULL;\n+\n   ul = 0;\n \n   /* return value tests */\n@@ -326,7 +437,7 @@ int main(/*@unused@*/ int argc, /*@unused@*/ char *argv[])\n       {\n \tul++;\n \tffi_call(&cif, FFI_FN(return_sc), &rint, values);\n-\tCHECK(rint == (int) sc);\n+\tCHECK(rint == (ffi_arg) sc);\n       }\n \n     args[0] = &ffi_type_uchar;\n@@ -413,7 +524,7 @@ int main(/*@unused@*/ int argc, /*@unused@*/ char *argv[])\n \n     ffi_call(&cif, FFI_FN(floating), &rint, values);\n \n-    printf (\"%d vs %d\\n\", rint, floating (si1, f, d, ld, si2));\n+    printf (\"%d vs %d\\n\", (int)rint, floating (si1, f, d, ld, si2));\n \n     CHECK(rint == floating(si1, f, d, ld, si2));\n \n@@ -483,7 +594,7 @@ int main(/*@unused@*/ int argc, /*@unused@*/ char *argv[])\n \t\t       &ffi_type_float, args) == FFI_OK);\n \n     /*@-usedef@*/\n-    ff =  many(fa[0], fa[1],\n+    ff = many (fa[0], fa[1],\n \t       fa[2], fa[3],\n \t       fa[4], fa[5],\n \t       fa[6], fa[7],\n@@ -532,7 +643,8 @@ int main(/*@unused@*/ int argc, /*@unused@*/ char *argv[])\n \t    {\n \t      ul++;\n \t      ffi_call(&cif, FFI_FN(promotion), &rint, values);\n-\t      CHECK(rint == (int) sc + (int) ss + (int) uc + (int) us);\n+\t      CHECK((int)rint == (signed char) sc + (signed short) ss +\n+\t\t    (unsigned char) uc + (unsigned short) us);\n \t    }\n     printf(\"%lu promotion tests run\\n\", ul);\n   }\n@@ -579,8 +691,7 @@ int main(/*@unused@*/ int argc, /*@unused@*/ char *argv[])\n     values[0] = &ts2_arg;\n     \n     /* Initialize the cif */\n-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, \n-\t\t       &ts2_type, args) == FFI_OK);\n+    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, &ts2_type, args) == FFI_OK);\n \n     ts2_arg.d1 = 5.55;\n     ts2_arg.d2 = 6.66;\n@@ -647,8 +758,7 @@ int main(/*@unused@*/ int argc, /*@unused@*/ char *argv[])\n     values[0] = &ts4_arg;\n     \n     /* Initialize the cif */\n-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, \n-\t\t       &ts4_type, args) == FFI_OK);\n+    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, &ts4_type, args) == FFI_OK);\n \n     ts4_arg.ui1 = 2;\n     ts4_arg.ui2 = 3;\n@@ -678,8 +788,7 @@ int main(/*@unused@*/ int argc, /*@unused@*/ char *argv[])\n     values[1] = &ts5_arg2;\n     \n     /* Initialize the cif */\n-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, \n-\t\t       &ts5_type, args) == FFI_OK);\n+    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &ts5_type, args) == FFI_OK);\n \n     ts5_arg1.c1 = 2;\n     ts5_arg1.c2 = 6;\n@@ -697,6 +806,150 @@ int main(/*@unused@*/ int argc, /*@unused@*/ char *argv[])\n     free (ts5_result);\n   }\n \n+  /* struct tests */\n+  {\n+    test_structure_6 ts6_arg;\n+\n+    /* This is a hack to get a properly aligned result buffer */\n+    test_structure_6 *ts6_result = \n+      (test_structure_6 *) malloc (sizeof(test_structure_6));\n+\n+    args[0] = &ts6_type;\n+    values[0] = &ts6_arg;\n+\n+    /* Initialize the cif */\n+    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, &ts6_type, args) == FFI_OK);\n+\n+    ts6_arg.f = 5.55f;\n+    ts6_arg.d = 6.66;\n+\n+    printf (\"%g\\n\", ts6_arg.f);\n+    printf (\"%g\\n\", ts6_arg.d);\n+\n+    ffi_call(&cif, FFI_FN(struct6), ts6_result, values);\n+\n+    printf (\"%g\\n\", ts6_result->f);\n+    printf (\"%g\\n\", ts6_result->d);\n+\n+    CHECK(ts6_result->f == 5.55f + 1);\n+    CHECK(ts6_result->d == 6.66 + 1);\n+\n+    printf(\"structure test 6 ok!\\n\");\n+\n+    free (ts6_result);\n+  }\n+\n+  /* struct tests */\n+  {\n+    test_structure_7 ts7_arg;\n+\n+    /* This is a hack to get a properly aligned result buffer */\n+    test_structure_7 *ts7_result = \n+      (test_structure_7 *) malloc (sizeof(test_structure_7));\n+\n+    args[0] = &ts7_type;\n+    values[0] = &ts7_arg;\n+\n+    /* Initialize the cif */\n+    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, &ts7_type, args) == FFI_OK);\n+\n+    ts7_arg.f1 = 5.55f;\n+    ts7_arg.f2 = 55.5f;\n+    ts7_arg.d = 6.66;\n+\n+    printf (\"%g\\n\", ts7_arg.f1);\n+    printf (\"%g\\n\", ts7_arg.f2);\n+    printf (\"%g\\n\", ts7_arg.d);\n+\n+    ffi_call(&cif, FFI_FN(struct7), ts7_result, values);\n+\n+    printf (\"%g\\n\", ts7_result->f1);\n+    printf (\"%g\\n\", ts7_result->f2);\n+    printf (\"%g\\n\", ts7_result->d);\n+\n+    CHECK(ts7_result->f1 == 5.55f + 1);\n+    CHECK(ts7_result->f2 == 55.5f + 1);\n+    CHECK(ts7_result->d == 6.66 + 1);\n+\n+    printf(\"structure test 7 ok!\\n\");\n+\n+    free (ts7_result);\n+  }\n+\n+  /* struct tests */\n+  {\n+    test_structure_8 ts8_arg;\n+\n+    /* This is a hack to get a properly aligned result buffer */\n+    test_structure_8 *ts8_result = \n+      (test_structure_8 *) malloc (sizeof(test_structure_8));\n+\n+    args[0] = &ts8_type;\n+    values[0] = &ts8_arg;\n+\n+    /* Initialize the cif */\n+    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, &ts8_type, args) == FFI_OK);\n+\n+    ts8_arg.f1 = 5.55f;\n+    ts8_arg.f2 = 55.5f;\n+    ts8_arg.f3 = -5.55f;\n+    ts8_arg.f4 = -55.5f;\n+\n+    printf (\"%g\\n\", ts8_arg.f1);\n+    printf (\"%g\\n\", ts8_arg.f2);\n+    printf (\"%g\\n\", ts8_arg.f3);\n+    printf (\"%g\\n\", ts8_arg.f4);\n+\n+    ffi_call(&cif, FFI_FN(struct8), ts8_result, values);\n+\n+    printf (\"%g\\n\", ts8_result->f1);\n+    printf (\"%g\\n\", ts8_result->f2);\n+    printf (\"%g\\n\", ts8_result->f3);\n+    printf (\"%g\\n\", ts8_result->f4);\n+\n+    CHECK(ts8_result->f1 == 5.55f + 1);\n+    CHECK(ts8_result->f2 == 55.5f + 1);\n+    CHECK(ts8_result->f3 == -5.55f + 1);\n+    CHECK(ts8_result->f4 == -55.5f + 1);\n+\n+    printf(\"structure test 8 ok!\\n\");\n+\n+    free (ts8_result);\n+  }\n+\n+  /* struct tests */\n+  {\n+    test_structure_9 ts9_arg;\n+\n+    /* This is a hack to get a properly aligned result buffer */\n+    test_structure_9 *ts9_result = \n+      (test_structure_9 *) malloc (sizeof(test_structure_9));\n+\n+    args[0] = &ts9_type;\n+    values[0] = &ts9_arg;\n+\n+    /* Initialize the cif */\n+    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, &ts9_type, args) == FFI_OK);\n+\n+    ts9_arg.f = 5.55f;\n+    ts9_arg.i = 5;\n+\n+    printf (\"%g\\n\", ts9_arg.f);\n+    printf (\"%d\\n\", ts9_arg.i);\n+\n+    ffi_call(&cif, FFI_FN(struct9), ts9_result, values);\n+\n+    printf (\"%g\\n\", ts9_result->f);\n+    printf (\"%d\\n\", ts9_result->i);\n+\n+    CHECK(ts9_result->f == 5.55f + 1);\n+    CHECK(ts9_result->i == 5 + 1);\n+\n+    printf(\"structure test 9 ok!\\n\");\n+\n+    free (ts9_result);\n+  }\n+\n #else\n   printf(\"Structure passing doesn't work on Win32.\\n\");\n #endif /* X86_WIN32 */"}, {"sha": "55f3a988bc485ed5824b09a7d009f74b0a112010", "filename": "libffi/src/m68k/ffi.c", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94974caeddd0561408261d5c2a37331edc8a52e/libffi%2Fsrc%2Fm68k%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94974caeddd0561408261d5c2a37331edc8a52e/libffi%2Fsrc%2Fm68k%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fm68k%2Fffi.c?ref=c94974caeddd0561408261d5c2a37331edc8a52e", "patch": "@@ -16,14 +16,11 @@ static void *\n ffi_prep_args (void *stack, extended_cif *ecif)\n {\n   unsigned int i;\n-  int tmp;\n-  unsigned int avn;\n   void **p_argv;\n   char *argp;\n   ffi_type **p_arg;\n   void *struct_value_ptr;\n \n-  tmp = 0;\n   argp = stack;\n \n   if (ecif->cif->rtype->type == FFI_TYPE_STRUCT\n@@ -32,11 +29,10 @@ ffi_prep_args (void *stack, extended_cif *ecif)\n   else\n     struct_value_ptr = NULL;\n \n-  avn = ecif->cif->nargs;\n   p_argv = ecif->avalue;\n \n   for (i = ecif->cif->nargs, p_arg = ecif->cif->arg_types;\n-       i != 0 && avn != 0;\n+       i != 0;\n        i--, p_arg++)\n     {\n       size_t z;\n@@ -45,9 +41,6 @@ ffi_prep_args (void *stack, extended_cif *ecif)\n       if (((*p_arg)->alignment - 1) & (unsigned) argp)\n \targp = (char *) ALIGN (argp, (*p_arg)->alignment);\n \n-      if (avn != 0) \n-\t{\n-\t  avn--;\n \t  z = (*p_arg)->size;\n \t  if (z < sizeof (int))\n \t    {\n@@ -82,7 +75,6 @@ ffi_prep_args (void *stack, extended_cif *ecif)\n \t    memcpy (argp, *p_argv, z);\n \t  p_argv++;\n \t  argp += z;\n-\t}\n     }\n \n   return struct_value_ptr;"}, {"sha": "93f79239dfc0b6bcc9647a3639f8868a9908570f", "filename": "libffi/src/mips/ffi.c", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94974caeddd0561408261d5c2a37331edc8a52e/libffi%2Fsrc%2Fmips%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94974caeddd0561408261d5c2a37331edc8a52e/libffi%2Fsrc%2Fmips%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fmips%2Fffi.c?ref=c94974caeddd0561408261d5c2a37331edc8a52e", "patch": "@@ -51,7 +51,6 @@ static void ffi_prep_args(char *stack,\n \t\t\t  int flags)\n {\n   register int i;\n-  register int avn;\n   register void **p_argv;\n   register char *argp;\n   register ffi_type **p_arg;\n@@ -81,12 +80,9 @@ static void ffi_prep_args(char *stack,\n       FIX_ARGP;\n     }\n \n-  avn = ecif->cif->nargs;\n   p_argv = ecif->avalue;\n \n-  for (i = ecif->cif->nargs, p_arg = ecif->cif->arg_types;\n-       i && avn;\n-       i--, p_arg++)\n+  for (i = ecif->cif->nargs, p_arg = ecif->cif->arg_types; i; i--, p_arg++)\n     {\n       size_t z;\n \n@@ -102,9 +98,6 @@ static void ffi_prep_args(char *stack,\n #define OFFSET sizeof(int)\n #endif      \n \n-      if (avn) \n-\t{\n-\t  avn--;\n \t  z = (*p_arg)->size;\n \t  if (z < sizeof(SLOT_TYPE_UNSIGNED))\n \t    {\n@@ -180,7 +173,6 @@ static void ffi_prep_args(char *stack,\n \t  p_argv++;\n \t  argp += z;\n \t  FIX_ARGP;\n-\t}\n     }\n   \n   return;"}, {"sha": "985136490ceea04f23ac729516b4623b862f19dd", "filename": "libffi/src/prep_cif.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94974caeddd0561408261d5c2a37331edc8a52e/libffi%2Fsrc%2Fprep_cif.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94974caeddd0561408261d5c2a37331edc8a52e/libffi%2Fsrc%2Fprep_cif.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fprep_cif.c?ref=c94974caeddd0561408261d5c2a37331edc8a52e", "patch": "@@ -103,7 +103,9 @@ ffi_status ffi_prep_cif(/*@out@*/ /*@partial@*/ ffi_cif *cif,\n   /* Perform a sanity check on the return type */\n   FFI_ASSERT(ffi_type_test(cif->rtype));\n \n-#ifndef M68K\n+  /* x86-64 and s390 stack space allocation is handled in prep_machdep.\n+     TODO: Disable this for s390 too?  */\n+#if !defined M68K && !defined __x86_64__\n   /* Make space for the return structure pointer */\n   if (cif->rtype->type == FFI_TYPE_STRUCT\n #ifdef SPARC\n@@ -122,6 +124,8 @@ ffi_status ffi_prep_cif(/*@out@*/ /*@partial@*/ ffi_cif *cif,\n       if (((*ptr)->size == 0) && (initialize_aggregate((*ptr)) != FFI_OK))\n \treturn FFI_BAD_TYPEDEF;\n \n+      /* TODO: Disable this calculation for s390 too?  */\n+#ifndef __x86_64__\n #ifdef SPARC\n       if (((*ptr)->type == FFI_TYPE_STRUCT\n \t   && ((*ptr)->size > 16 || cif->abi != FFI_V9))\n@@ -137,6 +141,7 @@ ffi_status ffi_prep_cif(/*@out@*/ /*@partial@*/ ffi_cif *cif,\n \t  \n \t  bytes += STACK_ARG_SIZE((*ptr)->size);\n \t}\n+#endif\n     }\n \n   cif->bytes = bytes;"}, {"sha": "dc975356b4b70b7f757b4922be7ea6ccee8265e5", "filename": "libffi/src/sparc/ffi.c", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94974caeddd0561408261d5c2a37331edc8a52e/libffi%2Fsrc%2Fsparc%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94974caeddd0561408261d5c2a37331edc8a52e/libffi%2Fsrc%2Fsparc%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fsparc%2Fffi.c?ref=c94974caeddd0561408261d5c2a37331edc8a52e", "patch": "@@ -34,14 +34,10 @@\n void ffi_prep_args_v8(char *stack, extended_cif *ecif)\n {\n   int i;\n-  int tmp;\n-  int avn;\n   void **p_argv;\n   char *argp;\n   ffi_type **p_arg;\n \n-  tmp = 0;\n-\n   /* Skip 16 words for the window save area */\n   argp = stack + 16*sizeof(int);\n \n@@ -66,18 +62,12 @@ void ffi_prep_args_v8(char *stack, extended_cif *ecif)\n   ((int*)argp)[5] = 0;\n #endif\n \n-  avn = ecif->cif->nargs;\n   p_argv = ecif->avalue;\n \n-  for (i = ecif->cif->nargs, p_arg = ecif->cif->arg_types;\n-       i && avn;\n-       i--, p_arg++)\n+  for (i = ecif->cif->nargs, p_arg = ecif->cif->arg_types; i; i--, p_arg++)\n     {\n       size_t z;\n \n-      if (avn) \n-\t{\n-\t  avn--;\n \t  if ((*p_arg)->type == FFI_TYPE_STRUCT\n #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n \t      || (*p_arg)->type == FFI_TYPE_LONGDOUBLE\n@@ -122,7 +112,6 @@ void ffi_prep_args_v8(char *stack, extended_cif *ecif)\n \t    }\n \t  p_argv++;\n \t  argp += z;\n-\t}\n     }\n   \n   return;"}, {"sha": "a4a2d06cf49c06b64e415b14810042fba5dc146f", "filename": "libffi/src/types.c", "status": "modified", "additions": 8, "deletions": 33, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94974caeddd0561408261d5c2a37331edc8a52e/libffi%2Fsrc%2Ftypes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94974caeddd0561408261d5c2a37331edc8a52e/libffi%2Fsrc%2Ftypes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Ftypes.c?ref=c94974caeddd0561408261d5c2a37331edc8a52e", "patch": "@@ -42,7 +42,7 @@ FFI_INTEGRAL_TYPEDEF(uint32, 4, 4, FFI_TYPE_UINT32);\n FFI_INTEGRAL_TYPEDEF(sint32, 4, 4, FFI_TYPE_SINT32);\n FFI_INTEGRAL_TYPEDEF(float, 4, 4, FFI_TYPE_FLOAT);\n \n-#if defined ALPHA || defined SPARC64\n+#if defined ALPHA || defined SPARC64 || defined X86_64\n \n FFI_INTEGRAL_TYPEDEF(pointer, 8, 8, FFI_TYPE_POINTER);\n \n@@ -52,22 +52,7 @@ FFI_INTEGRAL_TYPEDEF(pointer, 4, 4, FFI_TYPE_POINTER);\n \n #endif\n \n-#ifdef X86\n-\n-FFI_INTEGRAL_TYPEDEF(uint64, 8, 4, FFI_TYPE_UINT64);\n-FFI_INTEGRAL_TYPEDEF(sint64, 8, 4, FFI_TYPE_SINT64);\n-\n-#elif defined X86_WIN32\n-\n-FFI_INTEGRAL_TYPEDEF(uint64, 8, 4, FFI_TYPE_UINT64);\n-FFI_INTEGRAL_TYPEDEF(sint64, 8, 4, FFI_TYPE_SINT64);\n-\n-#elif defined ARM\n-\n-FFI_INTEGRAL_TYPEDEF(uint64, 8, 4, FFI_TYPE_UINT64);\n-FFI_INTEGRAL_TYPEDEF(sint64, 8, 4, FFI_TYPE_SINT64);\n-\n-#elif defined M68K\n+#if defined X86 || defined X86_WIN32 || defined ARM || defined M68K\n \n FFI_INTEGRAL_TYPEDEF(uint64, 8, 4, FFI_TYPE_UINT64);\n FFI_INTEGRAL_TYPEDEF(sint64, 8, 4, FFI_TYPE_SINT64);\n@@ -80,12 +65,7 @@ FFI_INTEGRAL_TYPEDEF(sint64, 8, 8, FFI_TYPE_SINT64);\n #endif\n \n \n-#ifdef X86\n-\n-FFI_INTEGRAL_TYPEDEF(double, 8, 4, FFI_TYPE_DOUBLE);\n-FFI_INTEGRAL_TYPEDEF(longdouble, 12, 4, FFI_TYPE_LONGDOUBLE);\n-\n-#elif defined X86_WIN32\n+#if defined X86 || defined X86_WIN32 || defined M68K\n \n FFI_INTEGRAL_TYPEDEF(double, 8, 4, FFI_TYPE_DOUBLE);\n FFI_INTEGRAL_TYPEDEF(longdouble, 12, 4, FFI_TYPE_LONGDOUBLE);\n@@ -95,25 +75,20 @@ FFI_INTEGRAL_TYPEDEF(longdouble, 12, 4, FFI_TYPE_LONGDOUBLE);\n FFI_INTEGRAL_TYPEDEF(double, 8, 4, FFI_TYPE_DOUBLE);\n FFI_INTEGRAL_TYPEDEF(longdouble, 8, 4, FFI_TYPE_LONGDOUBLE);\n \n-#elif defined M68K\n-\n-FFI_INTEGRAL_TYPEDEF(double, 8, 4, FFI_TYPE_DOUBLE);\n-FFI_INTEGRAL_TYPEDEF(longdouble, 12, 4, FFI_TYPE_LONGDOUBLE);\n-\n #elif defined SPARC\n \n FFI_INTEGRAL_TYPEDEF(double, 8, 8, FFI_TYPE_DOUBLE);\n-\n #ifdef SPARC64\n-\n FFI_INTEGRAL_TYPEDEF(longdouble, 16, 16, FFI_TYPE_LONGDOUBLE);\n-\n #else\n-\n FFI_INTEGRAL_TYPEDEF(longdouble, 16, 8, FFI_TYPE_LONGDOUBLE);\n-\n #endif\n \n+#elif defined X86_64\n+\n+FFI_INTEGRAL_TYPEDEF(double, 8, 8, FFI_TYPE_DOUBLE);\n+FFI_INTEGRAL_TYPEDEF(longdouble, 16, 16, FFI_TYPE_LONGDOUBLE);\n+\n #else\n \n FFI_INTEGRAL_TYPEDEF(double, 8, 8, FFI_TYPE_DOUBLE);"}, {"sha": "2e47c5dc7bfc6b4e57976c3388af79bee4433d5c", "filename": "libffi/src/x86/ffi.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94974caeddd0561408261d5c2a37331edc8a52e/libffi%2Fsrc%2Fx86%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94974caeddd0561408261d5c2a37331edc8a52e/libffi%2Fsrc%2Fx86%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fffi.c?ref=c94974caeddd0561408261d5c2a37331edc8a52e", "patch": "@@ -23,6 +23,8 @@\n    OTHER DEALINGS IN THE SOFTWARE.\n    ----------------------------------------------------------------------- */\n \n+#ifndef __x86_64__\n+\n #include <ffi.h>\n #include <ffi_common.h>\n \n@@ -491,3 +493,5 @@ ffi_raw_call(/*@dependent@*/ ffi_cif *cif,\n }\n \n #endif\n+\n+#endif /* __x86_64__  */"}, {"sha": "3dd8cbbf315c3ae125b3dc3a263d72200203a204", "filename": "libffi/src/x86/ffi64.c", "status": "added", "additions": 575, "deletions": 0, "changes": 575, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94974caeddd0561408261d5c2a37331edc8a52e/libffi%2Fsrc%2Fx86%2Fffi64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94974caeddd0561408261d5c2a37331edc8a52e/libffi%2Fsrc%2Fx86%2Fffi64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fffi64.c?ref=c94974caeddd0561408261d5c2a37331edc8a52e", "patch": "@@ -0,0 +1,575 @@\n+/* -----------------------------------------------------------------------\n+   ffi.c - Copyright (c) 2002  Bo Thorsen <bo@suse.de>\n+   \n+   x86-64 Foreign Function Interface \n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+   IN NO EVENT SHALL CYGNUS SOLUTIONS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+   OTHER DEALINGS IN THE SOFTWARE.\n+   ----------------------------------------------------------------------- */\n+\n+#include <ffi.h>\n+#include <ffi_common.h>\n+\n+#include <stdlib.h>\n+\n+/* ffi_prep_args is called by the assembly routine once stack space\n+   has been allocated for the function's arguments */\n+\n+#ifdef __x86_64__\n+\n+#define MAX_GPR_REGS 6\n+#define MAX_SSE_REGS 8\n+typedef struct\n+{\n+  /* Registers for argument passing.  */\n+  long gpr[MAX_GPR_REGS];\n+  __int128_t sse[MAX_SSE_REGS];\n+\n+  /* Stack space for arguments.  */\n+  char argspace[0];\n+} stackLayout;\n+\n+/* All reference to register classes here is identical to the code in\n+   gcc/config/i386/i386.c. Do *not* change one without the other.  */\n+\n+/* Register class used for passing given 64bit part of the argument.\n+   These represent classes as documented by the PS ABI, with the exception\n+   of SSESF, SSEDF classes, that are basically SSE class, just gcc will\n+   use SF or DFmode move instead of DImode to avoid reformating penalties.\n+\n+   Similary we play games with INTEGERSI_CLASS to use cheaper SImode moves\n+   whenever possible (upper half does contain padding).\n+ */\n+enum x86_64_reg_class\n+  {\n+    X86_64_NO_CLASS,\n+    X86_64_INTEGER_CLASS,\n+    X86_64_INTEGERSI_CLASS,\n+    X86_64_SSE_CLASS,\n+    X86_64_SSESF_CLASS,\n+    X86_64_SSEDF_CLASS,\n+    X86_64_SSEUP_CLASS,\n+    X86_64_X87_CLASS,\n+    X86_64_X87UP_CLASS,\n+    X86_64_MEMORY_CLASS\n+  };\n+\n+#define MAX_CLASSES 4\n+\n+/* x86-64 register passing implementation.  See x86-64 ABI for details.  Goal\n+   of this code is to classify each 8bytes of incoming argument by the register\n+   class and assign registers accordingly.  */\n+\n+/* Return the union class of CLASS1 and CLASS2.\n+   See the x86-64 PS ABI for details.  */\n+\n+static enum x86_64_reg_class\n+merge_classes (enum x86_64_reg_class class1, enum x86_64_reg_class class2)\n+{\n+  /* Rule #1: If both classes are equal, this is the resulting class.  */\n+  if (class1 == class2)\n+    return class1;\n+\n+  /* Rule #2: If one of the classes is NO_CLASS, the resulting class is\n+     the other class.  */\n+  if (class1 == X86_64_NO_CLASS)\n+    return class2;\n+  if (class2 == X86_64_NO_CLASS)\n+    return class1;\n+\n+  /* Rule #3: If one of the classes is MEMORY, the result is MEMORY.  */\n+  if (class1 == X86_64_MEMORY_CLASS || class2 == X86_64_MEMORY_CLASS)\n+    return X86_64_MEMORY_CLASS;\n+\n+  /* Rule #4: If one of the classes is INTEGER, the result is INTEGER.  */\n+  if ((class1 == X86_64_INTEGERSI_CLASS && class2 == X86_64_SSESF_CLASS)\n+      || (class2 == X86_64_INTEGERSI_CLASS && class1 == X86_64_SSESF_CLASS))\n+    return X86_64_INTEGERSI_CLASS;\n+  if (class1 == X86_64_INTEGER_CLASS || class1 == X86_64_INTEGERSI_CLASS\n+      || class2 == X86_64_INTEGER_CLASS || class2 == X86_64_INTEGERSI_CLASS)\n+    return X86_64_INTEGER_CLASS;\n+\n+  /* Rule #5: If one of the classes is X87 or X87UP class, MEMORY is used.  */\n+  if (class1 == X86_64_X87_CLASS || class1 == X86_64_X87UP_CLASS\n+      || class2 == X86_64_X87_CLASS || class2 == X86_64_X87UP_CLASS)\n+    return X86_64_MEMORY_CLASS;\n+\n+  /* Rule #6: Otherwise class SSE is used.  */\n+  return X86_64_SSE_CLASS;\n+}\n+\n+/* Classify the argument of type TYPE and mode MODE.\n+   CLASSES will be filled by the register class used to pass each word\n+   of the operand.  The number of words is returned.  In case the parameter\n+   should be passed in memory, 0 is returned. As a special case for zero\n+   sized containers, classes[0] will be NO_CLASS and 1 is returned.\n+\n+   See the x86-64 PS ABI for details.\n+*/\n+static int\n+classify_argument (ffi_type *type, enum x86_64_reg_class classes[],\n+\t\t   int *byte_offset)\n+{\n+  /* First, align to the right place.  */\n+  *byte_offset = ALIGN(*byte_offset, type->alignment);\n+\n+  switch (type->type)\n+    {\n+    case FFI_TYPE_UINT8:\n+    case FFI_TYPE_SINT8:\n+    case FFI_TYPE_UINT16:\n+    case FFI_TYPE_SINT16:\n+    case FFI_TYPE_UINT32:\n+    case FFI_TYPE_SINT32:\n+    case FFI_TYPE_UINT64:\n+    case FFI_TYPE_SINT64:\n+    case FFI_TYPE_POINTER:\n+      if (((*byte_offset) % 8 + type->size) <= 4)\n+\tclasses[0] = X86_64_INTEGERSI_CLASS;\n+      else\n+\tclasses[0] = X86_64_INTEGER_CLASS;\n+      return 1;\n+    case FFI_TYPE_FLOAT:\n+      if (((*byte_offset) % 8) == 0)\n+\tclasses[0] = X86_64_SSESF_CLASS;\n+      else\n+\tclasses[0] = X86_64_SSE_CLASS;\n+      return 1;\n+    case FFI_TYPE_DOUBLE:\n+      classes[0] = X86_64_SSEDF_CLASS;\n+      return 1;\n+    case FFI_TYPE_LONGDOUBLE:\n+      classes[0] = X86_64_X87_CLASS;\n+      classes[1] = X86_64_X87UP_CLASS;\n+      return 2;\n+    case FFI_TYPE_STRUCT:\n+      {\n+\tconst int UNITS_PER_WORD = 8;\n+\tint words = (type->size + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+\tffi_type **ptr; \n+\tint i;\n+\tenum x86_64_reg_class subclasses[MAX_CLASSES];\n+\n+\t/* If the struct is larger than 16 bytes, pass it on the stack.  */\n+\tif (type->size > 16)\n+\t  return 0;\n+\n+\tfor (i = 0; i < words; i++)\n+\t  classes[i] = X86_64_NO_CLASS;\n+\n+\t/* Merge the fields of structure.  */\n+\tfor (ptr=type->elements; (*ptr)!=NULL; ptr++)\n+\t  {\n+\t    int num;\n+\n+\t    num = classify_argument (*ptr, subclasses, byte_offset);\n+\t    if (num == 0)\n+\t      return 0;\n+\t    for (i = 0; i < num; i++)\n+\t      {\n+\t\tint pos = *byte_offset / 8;\n+\t\tclasses[i + pos] =\n+\t\t  merge_classes (subclasses[i], classes[i + pos]);\n+\t      }\n+\n+\t    if ((*ptr)->type != FFI_TYPE_STRUCT)\n+\t      *byte_offset += (*ptr)->size;\n+\t  }\n+\n+\t/* Final merger cleanup.  */\n+\tfor (i = 0; i < words; i++)\n+\t  {\n+\t    /* If one class is MEMORY, everything should be passed in\n+\t       memory.  */\n+\t    if (classes[i] == X86_64_MEMORY_CLASS)\n+\t      return 0;\n+\n+\t    /* The X86_64_SSEUP_CLASS should be always preceded by\n+\t       X86_64_SSE_CLASS.  */\n+\t    if (classes[i] == X86_64_SSEUP_CLASS\n+\t\t&& (i == 0 || classes[i - 1] != X86_64_SSE_CLASS))\n+\t      classes[i] = X86_64_SSE_CLASS;\n+\n+\t    /*  X86_64_X87UP_CLASS should be preceded by X86_64_X87_CLASS.  */\n+\t    if (classes[i] == X86_64_X87UP_CLASS\n+\t\t&& (i == 0 || classes[i - 1] != X86_64_X87_CLASS))\n+\t      classes[i] = X86_64_SSE_CLASS;\n+\t  }\n+\treturn words;\n+      }\n+\n+    default:\n+      FFI_ASSERT(0);\n+    }\n+  return 0; /* Never reached.  */\n+}\n+\n+/* Examine the argument and return set number of register required in each\n+   class.  Return 0 iff parameter should be passed in memory.  */\n+static int\n+examine_argument (ffi_type *type, int in_return, int *int_nregs,int *sse_nregs)\n+{\n+  enum x86_64_reg_class class[MAX_CLASSES];\n+  int offset = 0;\n+  int n;\n+\n+  n = classify_argument (type, class, &offset);\n+\n+  if (n == 0)\n+    return 0;\n+\n+  *int_nregs = 0;\n+  *sse_nregs = 0;\n+  for (n--; n>=0; n--)\n+    switch (class[n])\n+      {\n+      case X86_64_INTEGER_CLASS:\n+      case X86_64_INTEGERSI_CLASS:\n+\t(*int_nregs)++;\n+\tbreak;\n+      case X86_64_SSE_CLASS:\n+      case X86_64_SSESF_CLASS:\n+      case X86_64_SSEDF_CLASS:\n+\t(*sse_nregs)++;\n+\tbreak;\n+      case X86_64_NO_CLASS:\n+      case X86_64_SSEUP_CLASS:\n+\tbreak;\n+      case X86_64_X87_CLASS:\n+      case X86_64_X87UP_CLASS:\n+\tif (!in_return)\n+\t  return 0;\n+\tbreak;\n+      default:\n+\tabort ();\n+      }\n+  return 1;\n+}\n+\n+/* Functions to load floats and double to an SSE register placeholder.  */\n+extern void float2sse (float, __int128_t *);\n+extern void double2sse (double, __int128_t *);\n+extern void floatfloat2sse (void *, __int128_t *);\n+\n+/* Functions to put the floats and doubles back.  */\n+extern float sse2float (__int128_t *);\n+extern double sse2double (__int128_t *);\n+extern void sse2floatfloat(__int128_t *, void *);\n+\n+/*@-exportheader@*/\n+void\n+ffi_prep_args (stackLayout *stack, extended_cif *ecif)\n+/*@=exportheader@*/\n+{\n+  int gprcount, ssecount, i, g, s;\n+  void **p_argv;\n+  void *argp = &stack->argspace;\n+  ffi_type **p_arg;\n+\n+  /* First check if the return value should be passed in memory. If so,\n+     pass the pointer as the first argument.  */\n+  gprcount = ssecount = 0;\n+  if (examine_argument (ecif->cif->rtype, 1, &g, &s) == 0)\n+    (void *)stack->gpr[gprcount++] = ecif->rvalue;\n+\n+  for (i=ecif->cif->nargs, p_arg=ecif->cif->arg_types, p_argv = ecif->avalue;\n+       i!=0; i--, p_arg++, p_argv++)\n+    {\n+      int in_register = 0;\n+\n+      switch ((*p_arg)->type)\n+\t{\n+\tcase FFI_TYPE_SINT8:\n+\tcase FFI_TYPE_SINT16:\n+\tcase FFI_TYPE_SINT32:\n+\tcase FFI_TYPE_SINT64:\n+\tcase FFI_TYPE_UINT8:\n+\tcase FFI_TYPE_UINT16:\n+\tcase FFI_TYPE_UINT32:\n+\tcase FFI_TYPE_UINT64:\n+\tcase FFI_TYPE_POINTER:\n+\t  if (gprcount < MAX_GPR_REGS)\n+\t    {\n+\t      stack->gpr[gprcount] = 0;\n+\t      stack->gpr[gprcount++] = *(long long *)(*p_argv);\n+\t      in_register = 1;\n+\t    }\n+\t  break;\n+\n+\tcase FFI_TYPE_FLOAT:\n+\t  if (ssecount < MAX_SSE_REGS)\n+\t    {\n+\t      float2sse (*(float *)(*p_argv), &stack->sse[ssecount++]);\n+\t      in_register = 1;\n+\t    }\n+\t  break;\n+\n+\tcase FFI_TYPE_DOUBLE:\n+\t  if (ssecount < MAX_SSE_REGS)\n+\t    {\n+\t      double2sse (*(double *)(*p_argv), &stack->sse[ssecount++]);\n+\t      in_register = 1;\n+\t    }\n+\t  break;\n+\t}\n+\n+      if (in_register)\n+\tcontinue;\n+\n+      /* Either all places in registers where filled, or this is a\n+\t type that potentially goes into a memory slot.  */\n+      if (examine_argument (*p_arg, 0, &g, &s) == 0\n+\t  || gprcount + g > MAX_GPR_REGS || ssecount + s > MAX_SSE_REGS)\n+\t{\n+\t  /* Pass this argument in memory.  */\n+\t  argp = (void *)ALIGN(argp, (*p_arg)->alignment);\n+\t  memcpy (argp, *p_argv, (*p_arg)->size);\n+\t  argp += (*p_arg)->size;\n+\t}\n+      else\n+\t{\n+\t  /* All easy cases are eliminated. Now fire the big guns.  */\n+\n+\t  enum x86_64_reg_class classes[MAX_CLASSES];\n+\t  int offset = 0, j, num;\n+\t  void *a;\n+\n+\t  num = classify_argument (*p_arg, classes, &offset);\n+\t  for (j=0, a=*p_argv; j<num; j++, a+=8)\n+\t    {\n+\t      switch (classes[j])\n+\t\t{\n+\t\tcase X86_64_INTEGER_CLASS:\n+\t\tcase X86_64_INTEGERSI_CLASS:\n+\t\t  stack->gpr[gprcount++] = *(long long *)a;\n+\t\t  break;\n+\t\tcase X86_64_SSE_CLASS:\n+\t\t  floatfloat2sse (a, &stack->sse[ssecount++]);\n+\t\t  break;\n+\t\tcase X86_64_SSESF_CLASS:\n+\t\t  float2sse (*(float *)a, &stack->sse[ssecount++]);\n+\t\t  break;\n+\t\tcase X86_64_SSEDF_CLASS:\n+\t\t  double2sse (*(double *)a, &stack->sse[ssecount++]);\n+\t\t  break;\n+\t\tdefault:\n+\t\t  abort();\n+\t\t}\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Perform machine dependent cif processing.  */\n+ffi_status\n+ffi_prep_cif_machdep (ffi_cif *cif)\n+{\n+  int gprcount, ssecount, i, g, s;\n+\n+  gprcount = ssecount = 0;\n+\n+  /* Reset the byte count. We handle this size estimation here.  */\n+  cif->bytes = 0;\n+\n+  /* If the return value should be passed in memory, pass the pointer\n+     as the first argument. The actual memory isn't allocated here.  */\n+\n+  if (examine_argument (cif->rtype, 1, &g, &s) == 0)\n+    gprcount = 1;\n+\n+  /* Go over all arguments and determine the way they should be passed.\n+     If it's in a register and there is space for it, let that be so. If\n+     not, add it's size to the stack byte count.  */\n+  for (i=0; i<cif->nargs; i++)\n+    {\n+      if (examine_argument (cif->arg_types[i], 0, &g, &s) == 0\n+\t  || gprcount + g > MAX_GPR_REGS || ssecount + s > MAX_SSE_REGS)\n+\t{\n+\t  /* This is passed in memory. First align to the basic type.  */\n+\t  cif->bytes = ALIGN(cif->bytes, cif->arg_types[i]->alignment);\n+\n+\t  /* Stack arguments are *always* at least 8 byte aligned.  */\n+\t  cif->bytes = ALIGN(cif->bytes, 8);\n+\n+\t  /* Now add the size of this argument.  */\n+\t  cif->bytes += cif->arg_types[i]->size;\n+\t}\n+      else\n+\t{\n+\t  gprcount += g;\n+\t  ssecount += s;\n+\t}\n+    }\n+\n+  /* Set the flag for the closures return.  */\n+    switch (cif->rtype->type)\n+    {\n+    case FFI_TYPE_VOID:\n+    case FFI_TYPE_STRUCT:\n+    case FFI_TYPE_SINT64:\n+    case FFI_TYPE_FLOAT:\n+    case FFI_TYPE_DOUBLE:\n+    case FFI_TYPE_LONGDOUBLE:\n+      cif->flags = (unsigned) cif->rtype->type;\n+      break;\n+\n+    case FFI_TYPE_UINT64:\n+      cif->flags = FFI_TYPE_SINT64;\n+      break;\n+\n+    default:\n+      cif->flags = FFI_TYPE_INT;\n+      break;\n+    }\n+\n+  puts (\"prep_machdep\\n\");\n+\n+  return FFI_OK;\n+}\n+\n+typedef struct\n+{\n+  long gpr[2];\n+  __int128_t sse[2];\n+  long double st0;\n+} return_value;\n+\n+void\n+ffi_fill_return_value (return_value *rv, extended_cif *ecif)\n+{\n+  enum x86_64_reg_class classes[MAX_CLASSES];\n+  int i = 0, num;\n+  long *gpr = rv->gpr;\n+  __int128_t *sse = rv->sse;\n+  signed char sc;\n+  signed short ss;\n+\n+  /* This is needed because of the way x86-64 handles signed short\n+     integers.  */\n+  switch (ecif->cif->rtype->type)\n+    {\n+    case FFI_TYPE_SINT8:\n+      sc = *(signed char *)gpr;\n+      *(long long *)ecif->rvalue = (long long)sc;\n+      return;\n+    case FFI_TYPE_SINT16:\n+      ss = *(signed short *)gpr;\n+      *(long long *)ecif->rvalue = (long long)ss;\n+      return;\n+    default:\n+      /* Just continue.  */\n+      ;\n+    }\n+\n+  num = classify_argument (ecif->cif->rtype, classes, &i);\n+\n+  if (num == 0)\n+    /* Return in memory.  */\n+    ecif->rvalue = (void *) rv->gpr[0];\n+  else if (num == 2 && classes[0] == X86_64_X87_CLASS &&\n+\tclasses[1] == X86_64_X87UP_CLASS)\n+    /* This is a long double (this is easiest to handle this way instead\n+       of an eightbyte at a time as in the loop below.  */\n+    *((long double *)ecif->rvalue) = rv->st0;\n+  else\n+    {\n+      void *a;\n+\n+      for (i=0, a=ecif->rvalue; i<num; i++, a+=8)\n+\t{\n+\t  switch (classes[i])\n+\t    {\n+\t    case X86_64_INTEGER_CLASS:\n+\t    case X86_64_INTEGERSI_CLASS:\n+\t      *(long long *)a = *gpr;\n+\t      gpr++;\n+\t      break;\n+\t    case X86_64_SSE_CLASS:\n+\t      sse2floatfloat (sse++, a);\n+\t      break;\n+\t    case X86_64_SSESF_CLASS:\n+\t      *(float *)a = sse2float (sse++);\n+\t      break;\n+\t    case X86_64_SSEDF_CLASS:\n+\t      *(double *)a = sse2double (sse++);\n+\t      break;\n+\t    default:\n+\t      abort();\n+\t    }\n+\t}\n+    }\n+}\n+\n+/*@-declundef@*/\n+/*@-exportheader@*/\n+extern void ffi_call_UNIX64(void (*)(stackLayout *, extended_cif *),\n+\t\t\t    void (*) (return_value *, extended_cif *),\n+\t\t\t    /*@out@*/ extended_cif *, \n+\t\t\t    unsigned, /*@out@*/ unsigned *, void (*fn)());\n+/*@=declundef@*/\n+/*@=exportheader@*/\n+\n+void ffi_call(/*@dependent@*/ ffi_cif *cif, \n+\t      void (*fn)(), \n+\t      /*@out@*/ void *rvalue, \n+\t      /*@dependent@*/ void **avalue)\n+{\n+  extended_cif ecif;\n+  int dummy;\n+\n+  ecif.cif = cif;\n+  ecif.avalue = avalue;\n+  \n+  /* If the return value is a struct and we don't have a return\t*/\n+  /* value address then we need to make one\t\t        */\n+\n+  if ((rvalue == NULL) && \n+      (examine_argument (cif->rtype, 1, &dummy, &dummy) == 0))\n+    {\n+      /*@-sysunrecog@*/\n+      ecif.rvalue = alloca(cif->rtype->size);\n+      /*@=sysunrecog@*/\n+    }\n+  else\n+    ecif.rvalue = rvalue;\n+    \n+  /* Stack must always be 16byte aligned. Make it so.  */\n+  cif->bytes = ALIGN(cif->bytes, 16);\n+  \n+  switch (cif->abi) \n+    {\n+    case FFI_SYSV:\n+      /* Calling 32bit code from 64bit is not possible  */\n+      FFI_ASSERT(0);\n+      break;\n+\n+    case FFI_UNIX64:\n+      /*@-usedef@*/\n+      ffi_call_UNIX64 (ffi_prep_args, ffi_fill_return_value, &ecif,\n+\t\t       cif->bytes, ecif.rvalue, fn);\n+      /*@=usedef@*/\n+      break;\n+\n+    default:\n+      FFI_ASSERT(0);\n+      break;\n+    }\n+}\n+\n+#endif /* ifndef __x86_64__ */"}, {"sha": "ad898ad1a979fbb9625ed204b4cc60f8efb2096e", "filename": "libffi/src/x86/sysv.S", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94974caeddd0561408261d5c2a37331edc8a52e/libffi%2Fsrc%2Fx86%2Fsysv.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94974caeddd0561408261d5c2a37331edc8a52e/libffi%2Fsrc%2Fx86%2Fsysv.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fsysv.S?ref=c94974caeddd0561408261d5c2a37331edc8a52e", "patch": "@@ -1,5 +1,5 @@\n /* -----------------------------------------------------------------------\n-   sysv.S - Copyright (c) 1996, 1998, 2001  Cygnus Solutions\n+   sysv.S - Copyright (c) 1996, 1998, 2001, 2002  Cygnus Solutions\n    \n    X86 Foreign Function Interface \n \n@@ -23,6 +23,8 @@\n    OTHER DEALINGS IN THE SOFTWARE.\n    ----------------------------------------------------------------------- */\n \n+#ifndef __x86_64__\n+\n #define LIBFFI_ASM\t\n #include <ffi.h>\n \n@@ -163,3 +165,5 @@ __FRAME_BEGIN__:\n \t.align 4\n .LEFDE1:\n \t.set\t.LLFDE1,.LEFDE1-.LSFDE1\n+\n+#endif /* ifndef __x86_64__ */"}, {"sha": "2e64b4195bfb3c055817ca20a469ad03db96bbbb", "filename": "libffi/src/x86/unix64.S", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94974caeddd0561408261d5c2a37331edc8a52e/libffi%2Fsrc%2Fx86%2Funix64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94974caeddd0561408261d5c2a37331edc8a52e/libffi%2Fsrc%2Fx86%2Funix64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Funix64.S?ref=c94974caeddd0561408261d5c2a37331edc8a52e", "patch": "@@ -0,0 +1,166 @@\n+/* -----------------------------------------------------------------------\n+   unix64.S - Copyright (c) 2002  Bo Thorsen <bo@suse.de>\n+\n+   x86-64 Foreign Function Interface \n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+   IN NO EVENT SHALL CYGNUS SOLUTIONS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+   OTHER DEALINGS IN THE SOFTWARE.\n+   ----------------------------------------------------------------------- */\n+\n+#ifdef __x86_64__\n+#define LIBFFI_ASM\t\n+#include <ffi.h>\n+\n+\t.section\t.rodata\n+.LC0:\n+\t.string\t\"asm in progress %lld\\n\"\n+.LC1:\n+\t.string\t\"asm in progress\\n\"\n+.text\n+\t.align\t2\n+.globl ffi_call_UNIX64\n+        .type\tffi_call_UNIX64,@function\n+\n+ffi_call_UNIX64:\n+.LFB1:\n+        pushq\t%rbp\n+.LCFI0:\n+        movq\t%rsp, %rbp\n+.LCFI1:\n+\t/* Save all arguments */\n+\tsubq\t$48, %rsp\n+.LCFI2:\n+\tmovq\t%rdi, -8(%rbp)\t\t/* ffi_prep_args\t */\n+\tmovq\t%rsi, -16(%rbp)\t\t/* ffi_fill_return_value */\n+\tmovq\t%rdx, -24(%rbp)\t\t/* ecif\t\t\t */\n+\tmovq\t%rcx, -32(%rbp)\t\t/* cif->bytes\t\t */\n+\tmovq\t%r8, -40(%rbp)\t\t/* ecif.rvalue\t\t */\n+\tmovq\t%r9, -48(%rbp)\t\t/* fn\t\t\t */\n+\n+\t/* Make room for all of the new args and the register args */\n+\taddl\t$176, %ecx\n+.LCFI3:\n+\tsubq\t%rcx, %rsp\n+.LCFI4:\n+\t/* Setup the call to ffi_prep_args.  */\n+\tmovq\t%rdi, %rax\t\t/* &ffi_prep_args\t*/\n+\tmovq\t%rsp, %rdi\t\t/* stackLayout\t\t*/\n+\tmovq\t%rdx, %rsi\t\t/* ecif\t\t\t*/\n+\tcall\t*%rax\t\t\t/* ffi_prep_args(stackLayout, ecif);*/ \n+\n+\t/* ffi_prep_args have put all the register contents into the  */\n+\t/* stackLayout struct. Now put the register values in place.  */\n+\tmovq\t(%rsp), %rdi\n+\tmovq\t8(%rsp), %rsi\n+\tmovq\t16(%rsp), %rdx\n+\tmovq\t24(%rsp), %rcx\n+\tmovq\t32(%rsp), %r8\n+\tmovq\t40(%rsp), %r9\n+\tmovaps\t48(%rsp), %xmm0\n+\tmovaps\t64(%rsp), %xmm1\n+\tmovaps\t80(%rsp), %xmm2\n+\tmovaps\t96(%rsp), %xmm3\n+\tmovaps\t112(%rsp), %xmm4\n+\tmovaps\t128(%rsp), %xmm5\n+\tmovaps\t144(%rsp), %xmm6\n+\tmovaps\t160(%rsp), %xmm7\n+\n+\t/* Remove space for stackLayout so stack arguments are placed\n+\t   correctly for the call.  */\n+.LCFI5:\n+\taddq\t$176, %rsp\n+.LCFI6:\n+\t/* Call the user function.  */\n+\tcall\t*-48(%rbp)\n+\n+\t/* Make stack space for the return_value struct.  */\n+\tsubq\t$64, %rsp\n+\n+\t/* Fill in all potential return values to this struct.  */\n+\tmovq\t%rax, (%rsp)\n+\tmovq\t%rdx, 8(%rsp)\n+\tmovaps\t%xmm0, 16(%rsp)\n+\tmovaps\t%xmm1, 32(%rsp)\n+\tfstpt\t48(%rsp)\n+\n+\t/* Now call ffi_fill_return_value.  */\n+\tmovq\t%rsp, %rdi\t\t/* struct return_value\t  */\n+\tmovq\t-24(%rbp), %rsi\t\t/* ecif\t\t\t  */\n+\tmovq\t-16(%rbp), %rax\t\t/* &ffi_fill_return_value */\n+\tcall\t*%rax\t\t\t/* call it\t\t  */\n+\n+\t/* And the work is done.  */\n+        leave\n+        ret\n+.LFE1:\n+.ffi_call_UNIX64_end:\n+        .size    ffi_call_UNIX64,.ffi_call_UNIX64_end-ffi_call_UNIX64\n+\n+.text\n+\t.align\t2\n+.globl float2sse\n+        .type\tfloat2sse,@function\n+float2sse:\n+\t/* Save the contents of this sse-float in a pointer.  */\n+\tmovaps\t%xmm0, (%rdi)\n+\tret\n+\n+\t.align\t2\n+.globl floatfloat2sse\n+        .type\tfloatfloat2sse,@function\n+floatfloat2sse:\n+\t/* Save the contents of these two sse-floats in a pointer.  */\n+\tmovq\t(%rdi), %xmm0\n+\tmovaps\t%xmm0, (%rsi)\n+\tret\n+\n+\t.align\t2\n+.globl double2sse\n+        .type\tdouble2sse,@function\n+double2sse:\n+\t/* Save the contents of this sse-double in a pointer.  */\n+\tmovaps\t%xmm0, (%rdi)\n+\tret\n+\n+\t.align\t2\n+.globl sse2float\n+        .type\tsse2float,@function\n+sse2float:\n+\t/* Save the contents of this sse-float in a pointer.  */\n+\tmovaps\t(%rdi), %xmm0\n+\tret\n+\n+\t.align\t2\n+.globl sse2double\n+        .type\tsse2double,@function\n+sse2double:\n+\t/* Save the contents of this pointer in a sse-double.  */\n+\tmovaps\t(%rdi), %xmm0\n+\tret\n+\n+\t.align\t2\n+.globl sse2floatfloat\n+        .type\tsse2floatfloat,@function\n+sse2floatfloat:\n+\t/* Save the contents of this pointer in two sse-floats.  */\n+\tmovaps\t(%rdi), %xmm0\n+\tmovq\t%xmm0, (%rsi)\n+\tret\n+\t\n+#endif /* __x86_64__  */"}]}