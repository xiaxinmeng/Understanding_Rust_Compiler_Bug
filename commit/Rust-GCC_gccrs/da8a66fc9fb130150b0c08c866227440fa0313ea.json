{"sha": "da8a66fc9fb130150b0c08c866227440fa0313ea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGE4YTY2ZmM5ZmIxMzAxNTBiMGMwOGM4NjYyMjc0NDBmYTAzMTNlYQ==", "commit": {"author": {"name": "Martin v. L\u00f6wis", "email": "loewis@informatik.hu-berlin.de", "date": "1999-09-23T22:20:08Z"}, "committer": {"name": "Martin v. L\u00f6wis", "email": "loewis@gcc.gnu.org", "date": "1999-09-23T22:20:08Z"}, "message": "cp-tree.h (VAR_OR_FUNCTION_DECL_CHECK): New macro.\n\n\t* cp-tree.h (VAR_OR_FUNCTION_DECL_CHECK): New macro.\n\t(RECORD_OR_UNION_TYPE_CHECK, LANG_IDENTIFIER_CAST): Likewise.\n\t(DEFARG_NODE_CHECK): Remove; replace with DEFAULT_ARG_CHECK.\n\t* cp-tree.h: Add tree checking macros to various tree access\n\tmacros.\n\t* ptree.c (print_lang_decl): Test for function or variable\n\tbefore accessing template info.\n\nFrom-SVN: r29642", "tree": {"sha": "292010c5b05c2ec278045555e6ffa31ba22289a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/292010c5b05c2ec278045555e6ffa31ba22289a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/da8a66fc9fb130150b0c08c866227440fa0313ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da8a66fc9fb130150b0c08c866227440fa0313ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da8a66fc9fb130150b0c08c866227440fa0313ea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da8a66fc9fb130150b0c08c866227440fa0313ea/comments", "author": null, "committer": null, "parents": [{"sha": "48f45f57fc04ac76a5699c71e2dec606992b9f9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48f45f57fc04ac76a5699c71e2dec606992b9f9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48f45f57fc04ac76a5699c71e2dec606992b9f9a"}], "stats": {"total": 238, "additions": 145, "deletions": 93}, "files": [{"sha": "5f27676ca010c723fed1754dc7de59132d612cd4", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da8a66fc9fb130150b0c08c866227440fa0313ea/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da8a66fc9fb130150b0c08c866227440fa0313ea/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=da8a66fc9fb130150b0c08c866227440fa0313ea", "patch": "@@ -1,3 +1,13 @@\n+1999-09-23  Martin v. L\ufffdwis  <loewis@informatik.hu-berlin.de>\n+\n+\t* cp-tree.h (VAR_OR_FUNCTION_DECL_CHECK): New macro.\n+\t(RECORD_OR_UNION_TYPE_CHECK, LANG_IDENTIFIER_CAST): Likewise.\n+\t(DEFARG_NODE_CHECK): Remove; replace with DEFAULT_ARG_CHECK.\n+\t* cp-tree.h: Add tree checking macros to various tree access\n+\tmacros.\t\n+\t* ptree.c (print_lang_decl): Test for function or variable\n+\tbefore accessing template info.\n+\n 1999-09-23  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* lex.c: Get WCHAR_TYPE_SIZE from wchar_type_node."}, {"sha": "f4e993f979a4d0b61098c3e295efe833214f09bc", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 133, "deletions": 92, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da8a66fc9fb130150b0c08c866227440fa0313ea/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da8a66fc9fb130150b0c08c866227440fa0313ea/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=da8a66fc9fb130150b0c08c866227440fa0313ea", "patch": "@@ -118,6 +118,33 @@ Boston, MA 02111-1307, USA.  */\n      hold, the first entry does not have a TREE_VALUE; it is just an\n      offset.  */ \n \n+/* Language-specific tree checkers. */\n+\n+#if defined ENABLE_CHECKING && (__GNUC__ > 2 || __GNUC_MINOR__ > 6)\n+\n+#define VAR_OR_FUNCTION_DECL_CHECK(NODE)\t\t\t\\\n+({  const tree __t = NODE;\t\t\t\t\t\\\n+    enum tree_code __c = TREE_CODE(__t);\t\t\t\\\n+    if (__c != VAR_DECL && __c != FUNCTION_DECL)\t\t\\\n+      tree_check_failed (__t, VAR_DECL, __FILE__,\t\t\\\n+\t\t\t __LINE__, __PRETTY_FUNCTION__);\t\\\n+    __t; })\n+\n+#define RECORD_OR_UNION_TYPE_CHECK(NODE)\t\t\t\\\n+({  const tree __t = NODE;\t\t\t\t\t\\\n+    enum tree_code __c = TREE_CODE(__t);\t\t\t\\\n+    if (__c != RECORD_TYPE && __c != UNION_TYPE)\t\t\\\n+      tree_check_failed (__t, RECORD_TYPE, __FILE__,\t\t\\\n+\t\t\t __LINE__, __PRETTY_FUNCTION__);\t\\\n+    __t; })\n+\n+#else /* not ENABLE_CHECKING, or not gcc */\n+\n+#define VAR_OR_FUNCTION_DECL_CHECK(NODE)\tNODE\n+#define RECORD_OR_UNION_TYPE_CHECK(NODE)\tNODE\n+\n+#endif\n+\n /* Language-dependent contents of an identifier.  */\n \n struct lang_identifier\n@@ -130,6 +157,9 @@ struct lang_identifier\n   struct lang_id2 *x;\n };\n \n+#define LANG_IDENTIFIER_CAST(NODE) \\\n+\t((struct lang_identifier*)IDENTIFIER_NODE_CHECK (NODE))\n+\n struct lang_id2\n {\n   tree label_value, implicit_decl;\n@@ -173,14 +203,14 @@ typedef struct ptrmem_cst\n    _TYPE node, or a NAMESPACE_DECL.)  This macro should be used only\n    for namespace-level bindings; on the IDENTIFIER_BINDING list\n    BINDING_LEVEL is used instead.  */\n-#define BINDING_SCOPE(NODE) (((struct tree_binding*)NODE)->scope.scope)\n+#define BINDING_SCOPE(NODE) (((struct tree_binding*)CPLUS_BINDING_CHECK (NODE))->scope.scope)\n \n /* Nonzero if NODE has BINDING_LEVEL, rather than BINDING_SCOPE.  */\n #define BINDING_HAS_LEVEL_P(NODE) TREE_LANG_FLAG_2 ((NODE))\n \n /* This is the declaration bound to the name. Possible values:\n    variable, overloaded function, namespace, template, enumerator.  */\n-#define BINDING_VALUE(NODE)    (((struct tree_binding*)NODE)->value)\n+#define BINDING_VALUE(NODE)    (((struct tree_binding*)CPLUS_BINDING_CHECK (NODE))->value)\n \n /* If name is bound to a type, this is the type (struct, union, enum).  */\n #define BINDING_TYPE(NODE)     TREE_TYPE(NODE)\n@@ -205,7 +235,7 @@ struct tree_binding\n };\n \n /* The overloaded FUNCTION_DECL. */\n-#define OVL_FUNCTION(NODE)   (((struct tree_overload*)NODE)->function)\n+#define OVL_FUNCTION(NODE)   (((struct tree_overload*)OVERLOAD_CHECK (NODE))->function)\n #define OVL_CHAIN(NODE)      TREE_CHAIN(NODE)\n /* Polymorphic access to FUNCTION and CHAIN. */\n #define OVL_CURRENT(NODE)     \\\n@@ -231,8 +261,8 @@ struct tree_overload\n #define SET_BASELINK_P(NODE) \\\n   (TREE_LANG_FLAG_1 (NODE) = 1)\n \n-#define WRAPPER_PTR(NODE) (((struct tree_wrapper*)(NODE))->u.ptr)\n-#define WRAPPER_INT(NODE) (((struct tree_wrapper*)(NODE))->u.i)\n+#define WRAPPER_PTR(NODE) (((struct tree_wrapper*)WRAPPER_CHECK (NODE))->u.ptr)\n+#define WRAPPER_INT(NODE) (((struct tree_wrapper*)WRAPPER_CHECK (NODE))->u.i)\n \n struct tree_wrapper\n {\n@@ -243,8 +273,8 @@ struct tree_wrapper\n   } u;\n };\n \n-#define SRCLOC_FILE(NODE) (((struct tree_srcloc*)NODE)->filename)\n-#define SRCLOC_LINE(NODE) (((struct tree_srcloc*)NODE)->linenum)\n+#define SRCLOC_FILE(NODE) (((struct tree_srcloc*)SRCLOC_CHECK (NODE))->filename)\n+#define SRCLOC_LINE(NODE) (((struct tree_srcloc*)SRCLOC_CHECK (NODE))->linenum)\n struct tree_srcloc\n {\n   char common[sizeof (struct tree_common)];\n@@ -259,9 +289,9 @@ struct tree_srcloc\n /* Macros for access to language-specific slots in an identifier.  */\n \n #define IDENTIFIER_NAMESPACE_BINDINGS(NODE)\t\\\n-  (((struct lang_identifier *)(NODE))->namespace_bindings)\n+  (LANG_IDENTIFIER_CAST (NODE)->namespace_bindings)\n #define IDENTIFIER_TEMPLATE(NODE)\t\\\n-  (((struct lang_identifier *)(NODE))->class_template_info)\n+  (LANG_IDENTIFIER_CAST (NODE)->class_template_info)\n \n /* The IDENTIFIER_BINDING is the innermost CPLUS_BINDING for the\n     identifier.  It's TREE_CHAIN is the next outermost binding.  Each\n@@ -271,7 +301,7 @@ struct tree_srcloc\n     and such.)  You can use BINDING_SCOPE or BINDING_LEVEL to\n     determine the scope that bound the name.  */\n #define IDENTIFIER_BINDING(NODE) \\\n-  (((struct lang_identifier*) (NODE))->bindings)\n+  (LANG_IDENTIFIER_CAST (NODE)->bindings)\n \n /* The IDENTIFIER_VALUE is the value of the IDENTIFIER_BINDING, or\n    NULL_TREE if there is no binding.  */\n@@ -286,7 +316,7 @@ struct tree_srcloc\n    IDENTIFIER_BINDINGs list, so any time that this is non-NULL so is\n    IDENTIFIER_BINDING.  */\n #define IDENTIFIER_CLASS_VALUE(NODE) \\\n-  (((struct lang_identifier *) (NODE))->class_value)\n+  (LANG_IDENTIFIER_CAST (NODE)->class_value)\n \n /* The amount of time used by the file whose special \"time identifier\"\n    is NODE, represented as an INTEGER_CST.  See get_time_identifier.  */\n@@ -306,14 +336,15 @@ struct tree_srcloc\n #define SET_IDENTIFIER_TYPE_VALUE(NODE,TYPE) (TREE_TYPE (NODE) = TYPE)\n #define IDENTIFIER_HAS_TYPE_VALUE(NODE) (IDENTIFIER_TYPE_VALUE (NODE) ? 1 : 0)\n \n-#define LANG_ID_FIELD(NAME,NODE) \\\n-  (((struct lang_identifier *)(NODE))->x \\\n-   ? ((struct lang_identifier *)(NODE))->x->NAME : 0)\n-#define SET_LANG_ID(NODE,VALUE,NAME) \\\n-  (((struct lang_identifier *)(NODE))->x == 0\t\t\t\t    \\\n-   ? ((struct lang_identifier *)(NODE))->x\t\t\t\t    \\\n-      = (struct lang_id2 *)perm_calloc (1, sizeof (struct lang_id2)) : 0,   \\\n-   ((struct lang_identifier *)(NODE))->x->NAME = (VALUE))\n+#define LANG_ID_FIELD(NAME,NODE)\t\t\t\\\n+  (LANG_IDENTIFIER_CAST (NODE)->x\t\t\t\\\n+   ? LANG_IDENTIFIER_CAST (NODE)->x->NAME : 0)\t \n+\n+#define SET_LANG_ID(NODE,VALUE,NAME)\t\t\t\t\t  \\\n+  (LANG_IDENTIFIER_CAST (NODE)->x == 0\t\t\t\t  \\\n+   ? LANG_IDENTIFIER_CAST (NODE)->x\t\t\t\t\t  \\\n+      = (struct lang_id2 *)perm_calloc (1, sizeof (struct lang_id2)) : 0, \\\n+   LANG_IDENTIFIER_CAST (NODE)->x->NAME = (VALUE))\n \n #define IDENTIFIER_LABEL_VALUE(NODE)\t    LANG_ID_FIELD(label_value, NODE)\n #define SET_IDENTIFIER_LABEL_VALUE(NODE,VALUE)   \\\n@@ -1726,30 +1757,31 @@ struct lang_decl\n /* For a NAMESPACE_DECL: the list of using namespace directives\n    The PURPOSE is the used namespace, the value is the namespace\n    that is the common ancestor. */\n-#define DECL_NAMESPACE_USING(NODE) DECL_VINDEX(NODE)\n+#define DECL_NAMESPACE_USING(NODE) DECL_VINDEX (NAMESPACE_DECL_CHECK (NODE))\n \n /* In a NAMESPACE_DECL, the DECL_INITIAL is used to record all users\n    of a namespace, to record the transitive closure of using namespace. */\n-#define DECL_NAMESPACE_USERS(NODE) DECL_INITIAL (NODE)\n+#define DECL_NAMESPACE_USERS(NODE) DECL_INITIAL (NAMESPACE_DECL_CHECK (NODE))\n \n /* In a NAMESPACE_DECL, points to the original namespace if this is\n    a namespace alias.  */\n-#define DECL_NAMESPACE_ALIAS(NODE) DECL_ABSTRACT_ORIGIN (NODE)\n+#define DECL_NAMESPACE_ALIAS(NODE) \\\n+\tDECL_ABSTRACT_ORIGIN (NAMESPACE_DECL_CHECK (NODE))\n #define ORIGINAL_NAMESPACE(NODE)  \\\n   (DECL_NAMESPACE_ALIAS (NODE) ? DECL_NAMESPACE_ALIAS (NODE) : (NODE))\n \n /* In a non-local VAR_DECL with static storage duration, this is the\n    initialization priority.  If this value is zero, the NODE will be\n    initialized at the DEFAULT_INIT_PRIORITY.  */\n-#define DECL_INIT_PRIORITY(NODE) (DECL_FIELD_SIZE ((NODE)))\n+#define DECL_INIT_PRIORITY(NODE) (DECL_FIELD_SIZE (VAR_DECL_CHECK (NODE)))\n \n /* In a TREE_LIST concatenating using directives, indicate indirekt\n    directives  */\n-#define TREE_INDIRECT_USING(NODE) ((NODE)->common.lang_flag_0)\n+#define TREE_INDIRECT_USING(NODE) (TREE_LIST_CHECK (NODE)->common.lang_flag_0)\n \n /* In a VAR_DECL for a variable declared in a for statement,\n    this is the shadowed (local) variable.  */\n-#define DECL_SHADOWED_FOR_VAR(NODE) DECL_RESULT(NODE)\n+#define DECL_SHADOWED_FOR_VAR(NODE) DECL_RESULT(VAR_DECL_CHECK (NODE))\n \n /* Points back to the decl which caused this lang_decl to be allocated.  */\n #define DECL_MAIN_VARIANT(NODE) (DECL_LANG_SPECIFIC(NODE)->main_decl_variant)\n@@ -1758,7 +1790,7 @@ struct lang_decl\n    the class definition.  We have saved away the text of the function,\n    but have not yet processed it.  */\n #define DECL_PENDING_INLINE_P(NODE) \\\n-  (DECL_LANG_SPECIFIC (NODE)->decl_flags.pending_inline_p)\n+  (DECL_LANG_SPECIFIC (FUNCTION_DECL_CHECK (NODE))->decl_flags.pending_inline_p)\n    \n /* If DECL_PENDING_INLINE_P holds, this is the saved text of the\n    function.  */\n@@ -1767,24 +1799,26 @@ struct lang_decl\n \n /* For a TYPE_DECL: if this function has many fields, we'll sort them\n    and put them into a TREE_VEC. */\n-#define DECL_SORTED_FIELDS(NODE) (DECL_LANG_SPECIFIC(NODE)->u.sorted_fields)\n+#define DECL_SORTED_FIELDS(NODE) \\\n+\t(DECL_LANG_SPECIFIC (TYPE_DECL_CHECK (NODE))->u.sorted_fields)\n \n /* True if on the saved_inlines (see decl2.c) list.  */\n #define DECL_SAVED_INLINE(DECL) \\\n   (DECL_LANG_SPECIFIC(DECL)->decl_flags.saved_inline)\n \n /* For a VAR_DECL or FUNCTION_DECL: template-specific information.  */\n #define DECL_TEMPLATE_INFO(NODE) \\\n-  (DECL_LANG_SPECIFIC(NODE)->decl_flags.u.template_info)\n+  (DECL_LANG_SPECIFIC(VAR_OR_FUNCTION_DECL_CHECK (NODE))->decl_flags.u.template_info)\n \n /* Template information for a RECORD_TYPE or UNION_TYPE.  */\n-#define CLASSTYPE_TEMPLATE_INFO(NODE) (TYPE_LANG_SPECIFIC(NODE)->template_info)\n+#define CLASSTYPE_TEMPLATE_INFO(NODE) \\\n+  (TYPE_LANG_SPECIFIC(RECORD_OR_UNION_TYPE_CHECK (NODE))->template_info)\n \n /* Template information for an ENUMERAL_TYPE.  Although an enumeration may\n    not be a primary template, it may be declared within the scope of a\n    primary template and the enumeration constants may depend on\n    non-type template parameters.  */\n-#define ENUM_TEMPLATE_INFO(NODE) (TYPE_BINFO (NODE))\n+#define ENUM_TEMPLATE_INFO(NODE) (TYPE_BINFO (ENUMERAL_TYPE_CHECK (NODE)))\n \n /* Template information for a template template parameter.  */\n #define TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO(NODE) (TYPE_BINFO (NODE))\n@@ -1862,11 +1896,11 @@ struct lang_decl\n    entire function.  Usually a COMPOUND_STMT, but this may also be a\n    RETURN_INIT, CTOR_INITIALIZER, or TRY_BLOCK.  */\n #define DECL_SAVED_TREE(NODE) \\\n-  (DECL_LANG_SPECIFIC ((NODE))->saved_tree)\n+  (DECL_LANG_SPECIFIC (FUNCTION_DECL_CHECK (NODE))->saved_tree)\n \n /* In a FUNCTION_DECL, the saved language-specific per-function data.  */\n #define DECL_SAVED_FUNCTION_DATA(NODE) \\\n-  (DECL_LANG_SPECIFIC ((NODE))->u.saved_language_function)\n+  (DECL_LANG_SPECIFIC (FUNCTION_DECL_CHECK (NODE))->u.saved_language_function)\n \n #define COMPOUND_STMT_NO_SCOPE(NODE)\tTREE_LANG_FLAG_0 (NODE)\n #define NEW_EXPR_USE_GLOBAL(NODE)\tTREE_LANG_FLAG_0 (NODE)\n@@ -1876,7 +1910,8 @@ struct lang_decl\n \n /* Nonzero if this AGGR_INIT_EXPR provides for initialization via a\n    constructor call, rather than an ordinary function call.  */\n-#define AGGR_INIT_VIA_CTOR_P(NODE) TREE_LANG_FLAG_0 (NODE)\n+#define AGGR_INIT_VIA_CTOR_P(NODE) \\\n+  TREE_LANG_FLAG_0 (AGGR_INIT_EXPR_CHECK (NODE))\n \n /* Nonzero if this statement should be considered a full-expression.  */\n #define STMT_IS_FULL_EXPR_P(NODE) TREE_LANG_FLAG_1 ((NODE))\n@@ -1909,7 +1944,7 @@ struct lang_decl\n \n /* Nonzero in INTEGER_CST means that this int is negative by dint of\n    using a twos-complement negated operand.  */\n-#define TREE_NEGATED_INT(NODE) (TREE_LANG_FLAG_0 (NODE))\n+#define TREE_NEGATED_INT(NODE) TREE_LANG_FLAG_0 (INTEGER_CST_CHECK (NODE))\n \n #if 0\t\t\t\t/* UNUSED */\n /* Nonzero in any kind of _EXPR or _REF node means that it is a call\n@@ -1950,11 +1985,11 @@ extern int flag_new_for_scope;\n \n /* This flag is true of a local VAR_DECL if it was declared in a for\n    statement, but we are no longer in the scope of the for.  */\n-#define DECL_DEAD_FOR_LOCAL(NODE) DECL_LANG_FLAG_7 (NODE)\n+#define DECL_DEAD_FOR_LOCAL(NODE) DECL_LANG_FLAG_7 (VAR_DECL_CHECK (NODE))\n \n /* This flag is set on a VAR_DECL that is a DECL_DEAD_FOR_LOCAL\n    if we already emitted a warning about using it.  */\n-#define DECL_ERROR_REPORTED(NODE) DECL_LANG_FLAG_0 (NODE)\n+#define DECL_ERROR_REPORTED(NODE) DECL_LANG_FLAG_0 (VAR_DECL_CHECK (NODE))\n \n /* This _DECL represents a compiler-generated entity.  */\n #define SET_DECL_ARTIFICIAL(NODE) (DECL_ARTIFICIAL (NODE) = 1)\n@@ -1964,9 +1999,10 @@ extern int flag_new_for_scope;\n \n /* In a FIELD_DECL, nonzero if the decl was originally a bitfield.  */\n #define DECL_C_BIT_FIELD(NODE) \\\n-  (DECL_LANG_SPECIFIC (NODE) && DECL_LANG_SPECIFIC (NODE)->decl_flags.bitfield)\n+  (DECL_LANG_SPECIFIC (FIELD_DECL_CHECK (NODE))\\\n+   && DECL_LANG_SPECIFIC (NODE)->decl_flags.bitfield)\n #define SET_DECL_C_BIT_FIELD(NODE) \\\n-  (DECL_LANG_SPECIFIC (NODE)->decl_flags.bitfield = 1)\n+  (DECL_LANG_SPECIFIC (FIELD_DECL_CHECK (NODE))->decl_flags.bitfield = 1)\n \n #define INTEGRAL_CODE_P(CODE) \\\n   (CODE == INTEGER_TYPE || CODE == ENUMERAL_TYPE || CODE == BOOLEAN_TYPE)\n@@ -2164,23 +2200,26 @@ extern int flag_new_for_scope;\n /* For a pointer-to-member constant `X::Y' this is the RECORD_TYPE for\n    `X'.  */\n #define PTRMEM_CST_CLASS(NODE) \\\n-  TYPE_PTRMEM_CLASS_TYPE (TREE_TYPE (NODE))\n+  TYPE_PTRMEM_CLASS_TYPE (TREE_TYPE (PTRMEM_CST_CHECK (NODE)))\n \n /* For a pointer-to-member constant `X::Y' this is the _DECL for \n    `Y'.  */\n-#define PTRMEM_CST_MEMBER(NODE) (((ptrmem_cst_t) NODE)->member)\n+#define PTRMEM_CST_MEMBER(NODE) (((ptrmem_cst_t)PTRMEM_CST_CHECK (NODE))->member)\n \n /* Nonzero for VAR_DECL and FUNCTION_DECL node means that `extern' was\n    specified in its declaration.  */\n-#define DECL_THIS_EXTERN(NODE) (DECL_LANG_FLAG_2(NODE))\n+#define DECL_THIS_EXTERN(NODE) \\\n+  DECL_LANG_FLAG_2 (VAR_OR_FUNCTION_DECL_CHECK (NODE))\n \n /* Nonzero for VAR_DECL and FUNCTION_DECL node means that `static' was\n    specified in its declaration.  */\n-#define DECL_THIS_STATIC(NODE) (DECL_LANG_FLAG_6(NODE))\n+#define DECL_THIS_STATIC(NODE) \\\n+  DECL_LANG_FLAG_6 (VAR_OR_FUNCTION_DECL_CHECK (NODE))\n \n /* Nonzero in FUNCTION_DECL means it is really an operator.\n    Just used to communicate formatting information to dbxout.c.  */\n-#define DECL_OPERATOR(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.operator_attr)\n+#define DECL_OPERATOR(NODE) \\\n+  (DECL_LANG_SPECIFIC(FUNCTION_DECL_CHECK (NODE))->decl_flags.operator_attr)\n \n /* Nonzero if TYPE is an anonymous union or struct type.  We have to use a\n    flag for this because \"A union for which objects or pointers are\n@@ -2419,7 +2458,8 @@ extern int flag_new_for_scope;\n /* Nonzero if this VAR_DECL or FUNCTION_DECL has already been\n    instantiated, i.e. its definition has been generated from the\n    pattern given in the the template.  */\n-#define DECL_TEMPLATE_INSTANTIATED(NODE) DECL_LANG_FLAG_1(NODE)\n+#define DECL_TEMPLATE_INSTANTIATED(NODE) \\\n+  DECL_LANG_FLAG_1 (VAR_OR_FUNCTION_DECL_CHECK (NODE))\n \n /* We know what we're doing with this decl now.  */\n #define DECL_INTERFACE_KNOWN(NODE) DECL_LANG_FLAG_5 (NODE)\n@@ -2446,66 +2486,65 @@ extern int flag_new_for_scope;\n #define UPT_PARMS(NODE)         TREE_VALUE(TYPE_VALUES(NODE))\n \n /* An un-parsed default argument looks like an identifier.  */\n-#define DEFARG_NODE_CHECK(t)\tTREE_CHECK(t, DEFAULT_ARG) \n-#define DEFARG_LENGTH(NODE)\t(DEFARG_NODE_CHECK(NODE)->identifier.length)\n-#define DEFARG_POINTER(NODE)\t(DEFARG_NODE_CHECK(NODE)->identifier.pointer)\n+#define DEFARG_LENGTH(NODE)  (DEFAULT_ARG_CHECK(NODE)->identifier.length)\n+#define DEFARG_POINTER(NODE) (DEFAULT_ARG_CHECK(NODE)->identifier.pointer)\n \n /* These macros provide convenient access to the various _STMT nodes\n    created when parsing template declarations.  */\n-#define IF_COND(NODE)           TREE_OPERAND (NODE, 0)\n-#define THEN_CLAUSE(NODE)       TREE_OPERAND (NODE, 1)\n-#define ELSE_CLAUSE(NODE)       TREE_OPERAND (NODE, 2)\n-#define WHILE_COND(NODE)        TREE_OPERAND (NODE, 0)\n-#define WHILE_BODY(NODE)        TREE_OPERAND (NODE, 1)\n-#define DO_COND(NODE)           TREE_OPERAND (NODE, 0)\n-#define DO_BODY(NODE)           TREE_OPERAND (NODE, 1)\n-#define RETURN_EXPR(NODE)       TREE_OPERAND (NODE, 0)\n-#define EXPR_STMT_EXPR(NODE)    TREE_OPERAND (NODE, 0)\n-#define FOR_INIT_STMT(NODE)     TREE_OPERAND (NODE, 0)\n-#define FOR_COND(NODE)          TREE_OPERAND (NODE, 1)\n-#define FOR_EXPR(NODE)          TREE_OPERAND (NODE, 2)\n-#define FOR_BODY(NODE)          TREE_OPERAND (NODE, 3)\n-#define SWITCH_COND(NODE)       TREE_OPERAND (NODE, 0)\n-#define SWITCH_BODY(NODE)       TREE_OPERAND (NODE, 1)\n-#define CASE_LOW(NODE)          TREE_OPERAND (NODE, 0)\n-#define CASE_HIGH(NODE)         TREE_OPERAND (NODE, 1)\n-#define GOTO_DESTINATION(NODE)  TREE_OPERAND (NODE, 0)\n-#define TRY_STMTS(NODE)         TREE_OPERAND (NODE, 0)\n-#define TRY_HANDLERS(NODE)      TREE_OPERAND (NODE, 1)\n-#define CLEANUP_P(NODE)         TREE_LANG_FLAG_0 (NODE)\n+#define IF_COND(NODE)           TREE_OPERAND (IF_STMT_CHECK (NODE), 0)\n+#define THEN_CLAUSE(NODE)       TREE_OPERAND (IF_STMT_CHECK (NODE), 1)\n+#define ELSE_CLAUSE(NODE)       TREE_OPERAND (IF_STMT_CHECK (NODE), 2)\n+#define WHILE_COND(NODE)        TREE_OPERAND (WHILE_STMT_CHECK (NODE), 0)\n+#define WHILE_BODY(NODE)        TREE_OPERAND (WHILE_STMT_CHECK (NODE), 1)\n+#define DO_COND(NODE)           TREE_OPERAND (DO_STMT_CHECK (NODE), 0)\n+#define DO_BODY(NODE)           TREE_OPERAND (DO_STMT_CHECK (NODE), 1)\n+#define RETURN_EXPR(NODE)       TREE_OPERAND (RETURN_STMT_CHECK (NODE), 0)\n+#define EXPR_STMT_EXPR(NODE)    TREE_OPERAND (EXPR_STMT_CHECK (NODE), 0)\n+#define FOR_INIT_STMT(NODE)     TREE_OPERAND (FOR_STMT_CHECK (NODE), 0)\n+#define FOR_COND(NODE)          TREE_OPERAND (FOR_STMT_CHECK (NODE), 1)\n+#define FOR_EXPR(NODE)          TREE_OPERAND (FOR_STMT_CHECK (NODE), 2)\n+#define FOR_BODY(NODE)          TREE_OPERAND (FOR_STMT_CHECK (NODE), 3)\n+#define SWITCH_COND(NODE)       TREE_OPERAND (SWITCH_STMT_CHECK (NODE), 0)\n+#define SWITCH_BODY(NODE)       TREE_OPERAND (SWITCH_STMT_CHECK (NODE), 1)\n+#define CASE_LOW(NODE)          TREE_OPERAND (CASE_LABEL_CHECK (NODE), 0)\n+#define CASE_HIGH(NODE)         TREE_OPERAND (CASE_LABEL_CHECK (NODE), 1)\n+#define GOTO_DESTINATION(NODE)  TREE_OPERAND (GOTO_STMT_CHECK (NODE), 0)\n+#define TRY_STMTS(NODE)         TREE_OPERAND (TRY_BLOCK_CHECK (NODE), 0)\n+#define TRY_HANDLERS(NODE)      TREE_OPERAND (TRY_BLOCK_CHECK (NODE), 1)\n+#define CLEANUP_P(NODE)         TREE_LANG_FLAG_0 (TRY_BLOCK_CHECK (NODE))\n /* Nonzero if this try block is a function try block.  */\n-#define FN_TRY_BLOCK_P(NODE)    TREE_LANG_FLAG_3 (NODE)\n-#define HANDLER_PARMS(NODE)     TREE_OPERAND (NODE, 0)\n-#define HANDLER_BODY(NODE)      TREE_OPERAND (NODE, 1)\n-#define COMPOUND_BODY(NODE)     TREE_OPERAND (NODE, 0)\n-#define ASM_CV_QUAL(NODE)       TREE_OPERAND (NODE, 0)\n-#define ASM_STRING(NODE)        TREE_OPERAND (NODE, 1)\n-#define ASM_OUTPUTS(NODE)       TREE_OPERAND (NODE, 2)\n-#define ASM_INPUTS(NODE)        TREE_OPERAND (NODE, 3)\n-#define ASM_CLOBBERS(NODE)      TREE_OPERAND (NODE, 4)\n-#define DECL_STMT_DECL(NODE)    TREE_OPERAND (NODE, 0)\n-#define STMT_EXPR_STMT(NODE)    TREE_OPERAND (NODE, 0)\n-#define SUBOBJECT_CLEANUP(NODE) TREE_OPERAND (NODE, 0)\n-#define CLEANUP_DECL(NODE)      TREE_OPERAND (NODE, 0)\n-#define CLEANUP_EXPR(NODE)      TREE_OPERAND (NODE, 1)\n-#define START_CATCH_TYPE(NODE)  TREE_TYPE (NODE)\n-#define LABEL_STMT_LABEL(NODE)  TREE_OPERAND (NODE, 0)\n+#define FN_TRY_BLOCK_P(NODE)    TREE_LANG_FLAG_3 (TRY_BLOCK_CHECK (NODE))\n+#define HANDLER_PARMS(NODE)     TREE_OPERAND (HANDLER_CHECK (NODE), 0)\n+#define HANDLER_BODY(NODE)      TREE_OPERAND (HANDLER_CHECK (NODE), 1)\n+#define COMPOUND_BODY(NODE)     TREE_OPERAND (COMPOUND_STMT_CHECK (NODE), 0)\n+#define ASM_CV_QUAL(NODE)       TREE_OPERAND (ASM_STMT_CHECK (NODE), 0)\n+#define ASM_STRING(NODE)        TREE_OPERAND (ASM_STMT_CHECK (NODE), 1)\n+#define ASM_OUTPUTS(NODE)       TREE_OPERAND (ASM_STMT_CHECK (NODE), 2)\n+#define ASM_INPUTS(NODE)        TREE_OPERAND (ASM_STMT_CHECK (NODE), 3)\n+#define ASM_CLOBBERS(NODE)      TREE_OPERAND (ASM_STMT_CHECK (NODE), 4)\n+#define DECL_STMT_DECL(NODE)    TREE_OPERAND (DECL_STMT_CHECK (NODE), 0)\n+#define STMT_EXPR_STMT(NODE)    TREE_OPERAND (STMT_EXPR_CHECK (NODE), 0)\n+#define SUBOBJECT_CLEANUP(NODE) TREE_OPERAND (SUBOBJECT_CHECK (NODE), 0)\n+#define CLEANUP_DECL(NODE)      TREE_OPERAND (CLEANUP_STMT_CHECK (NODE), 0)\n+#define CLEANUP_EXPR(NODE)      TREE_OPERAND (CLEANUP_STMT_CHECK (NODE), 1)\n+#define START_CATCH_TYPE(NODE)  TREE_TYPE (START_CATCH_STMT_CHECK (NODE))\n+#define LABEL_STMT_LABEL(NODE)  TREE_OPERAND (LABEL_STMT_CHECK (NODE), 0)\n \n /* Nonzero if this SCOPE_STMT is for the beginning of a scope.  */\n #define SCOPE_BEGIN_P(NODE) \\\n-  (TREE_LANG_FLAG_0 ((NODE))) \n+  (TREE_LANG_FLAG_0 (SCOPE_STMT_CHECK (NODE))) \n \n /* Nonzero if this SCOPE_STMT is for the end of a scope.  */\n #define SCOPE_END_P(NODE) \\\n-  (!SCOPE_BEGIN_P ((NODE)))\n+  (!SCOPE_BEGIN_P (SCOPE_STMT_CHECK (NODE)))\n \n /* Nonzero for a SCOPE_STMT if there were no variables in this scope.  */\n #define SCOPE_NULLIFIED_P(NODE) \\\n-  (TREE_LANG_FLAG_3 ((NODE)))\n+  (TREE_LANG_FLAG_3 (SCOPE_STMT_CHECK (NODE)))\n \n /* Nonzero for an ASM_STMT if the assembly statement is volatile.  */\n #define ASM_VOLATILE_P(NODE)\t\t\t\\\n-  (ASM_CV_QUAL ((NODE)) != NULL_TREE)\n+  (ASM_CV_QUAL (ASM_STMT_CHECK (NODE)) != NULL_TREE)\n \n /* The line-number at which a statement began.  But if\n    STMT_LINENO_FOR_FN_P does holds, then this macro gives the\n@@ -3050,11 +3089,13 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, OP_FLAG, TYPENAME_FLAG };\n   comptypes ((type1), (type2), COMPARE_BASE)\n \n /* These macros are used to access a TEMPLATE_PARM_INDEX.  */\n-#define TEMPLATE_PARM_IDX(NODE) (((template_parm_index*) NODE)->index)\n-#define TEMPLATE_PARM_LEVEL(NODE) (((template_parm_index*) NODE)->level)\n+#define TEMPLATE_PARM_INDEX_CAST(NODE) \\\n+\t((template_parm_index*)TEMPLATE_PARM_INDEX_CHECK (NODE))\n+#define TEMPLATE_PARM_IDX(NODE) (TEMPLATE_PARM_INDEX_CAST (NODE)->index)\n+#define TEMPLATE_PARM_LEVEL(NODE) (TEMPLATE_PARM_INDEX_CAST (NODE)->level)\n #define TEMPLATE_PARM_DESCENDANTS(NODE) (TREE_CHAIN (NODE))\n-#define TEMPLATE_PARM_ORIG_LEVEL(NODE) (((template_parm_index*) NODE)->orig_level)\n-#define TEMPLATE_PARM_DECL(NODE) (((template_parm_index*) NODE)->decl)\n+#define TEMPLATE_PARM_ORIG_LEVEL(NODE) (TEMPLATE_PARM_INDEX_CAST (NODE)->orig_level)\n+#define TEMPLATE_PARM_DECL(NODE) (TEMPLATE_PARM_INDEX_CAST (NODE)->decl)\n \n /* These macros are for accessing the fields of TEMPLATE_TYPE_PARM \n    and TEMPLATE_TEMPLATE_PARM nodes.  */"}, {"sha": "bbd0f996444919d9db37099d155545e6c4182374", "filename": "gcc/cp/ptree.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da8a66fc9fb130150b0c08c866227440fa0313ea/gcc%2Fcp%2Fptree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da8a66fc9fb130150b0c08c866227440fa0313ea/gcc%2Fcp%2Fptree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fptree.c?ref=da8a66fc9fb130150b0c08c866227440fa0313ea", "patch": "@@ -60,7 +60,8 @@ print_lang_decl (file, node, indent)\n       fprintf (file, \" sorted-fields \");\n       fprintf (file, HOST_PTR_PRINTF, DECL_SORTED_FIELDS (node));\n     }\n-  if (DECL_TEMPLATE_INFO (node))\n+  if ((TREE_CODE (node) == FUNCTION_DECL || TREE_CODE (node) == VAR_DECL)\n+      && DECL_TEMPLATE_INFO (node))\n     {\n       fprintf (file, \" template-info \");\n       fprintf (file, HOST_PTR_PRINTF,  DECL_TEMPLATE_INFO (node));"}]}