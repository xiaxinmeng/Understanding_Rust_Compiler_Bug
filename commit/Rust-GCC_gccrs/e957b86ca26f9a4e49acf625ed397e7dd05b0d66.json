{"sha": "e957b86ca26f9a4e49acf625ed397e7dd05b0d66", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTk1N2I4NmNhMjZmOWE0ZTQ5YWNmNjI1ZWQzOTdlN2RkMDViMGQ2Ng==", "commit": {"author": {"name": "Thomas Rodgers", "email": "trodgers@redhat.com", "date": "2020-10-21T13:11:28Z"}, "committer": {"name": "Thomas Rodgers", "email": "trodgers@redhat.com", "date": "2020-10-21T13:11:28Z"}, "message": "libstdc++: Rebase include/pstl to current upstream\n\nFrom llvm-project/pstl @ 0b2e0e80d96\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/pstl/algorithm_impl.h: Update file.\n\t* include/pstl/execution_impl.h: Likewise.\n\t* include/pstl/glue_algorithm_impl.h: Likewise.\n\t* include/pstl/glue_memory_impl.h: Likewise.\n\t* include/pstl/glue_numeric_impl.h: Likewise.\n\t* include/pstl/memory_impl.h: Likewise.\n\t* include/pstl/numeric_impl.h: Likewise.\n\t* include/pstl/parallel_backend.h: Likewise.\n\t* include/pstl/parallel_backend_serial.h: Likewise.\n\t* include/pstl/parallel_backend_tbb.h: Likewise.\n\t* include/pstl/parallel_backend_utils.h: Likewise.\n\t* include/pstl/pstl_config.h: Likewise.\n\t* include/pstl/unseq_backend_simd.h: Likewise.", "tree": {"sha": "ad920f6eb736aff03a090e0f384430f2f08b5d9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad920f6eb736aff03a090e0f384430f2f08b5d9a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e957b86ca26f9a4e49acf625ed397e7dd05b0d66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e957b86ca26f9a4e49acf625ed397e7dd05b0d66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e957b86ca26f9a4e49acf625ed397e7dd05b0d66", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e957b86ca26f9a4e49acf625ed397e7dd05b0d66/comments", "author": {"login": "rodgert", "id": 120839, "node_id": "MDQ6VXNlcjEyMDgzOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/120839?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rodgert", "html_url": "https://github.com/rodgert", "followers_url": "https://api.github.com/users/rodgert/followers", "following_url": "https://api.github.com/users/rodgert/following{/other_user}", "gists_url": "https://api.github.com/users/rodgert/gists{/gist_id}", "starred_url": "https://api.github.com/users/rodgert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rodgert/subscriptions", "organizations_url": "https://api.github.com/users/rodgert/orgs", "repos_url": "https://api.github.com/users/rodgert/repos", "events_url": "https://api.github.com/users/rodgert/events{/privacy}", "received_events_url": "https://api.github.com/users/rodgert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rodgert", "id": 120839, "node_id": "MDQ6VXNlcjEyMDgzOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/120839?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rodgert", "html_url": "https://github.com/rodgert", "followers_url": "https://api.github.com/users/rodgert/followers", "following_url": "https://api.github.com/users/rodgert/following{/other_user}", "gists_url": "https://api.github.com/users/rodgert/gists{/gist_id}", "starred_url": "https://api.github.com/users/rodgert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rodgert/subscriptions", "organizations_url": "https://api.github.com/users/rodgert/orgs", "repos_url": "https://api.github.com/users/rodgert/repos", "events_url": "https://api.github.com/users/rodgert/events{/privacy}", "received_events_url": "https://api.github.com/users/rodgert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "310fe80babe04ccb7d2e15c8fca7dc98180701a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/310fe80babe04ccb7d2e15c8fca7dc98180701a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/310fe80babe04ccb7d2e15c8fca7dc98180701a8"}], "stats": {"total": 2365, "additions": 1586, "deletions": 779}, "files": [{"sha": "8e127b5ba22453b4ad930651c8f07b137f1f30d2", "filename": "libstdc++-v3/include/pstl/algorithm_impl.h", "status": "modified", "additions": 118, "deletions": 63, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e957b86ca26f9a4e49acf625ed397e7dd05b0d66/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Falgorithm_impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e957b86ca26f9a4e49acf625ed397e7dd05b0d66/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Falgorithm_impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Falgorithm_impl.h?ref=e957b86ca26f9a4e49acf625ed397e7dd05b0d66", "patch": "@@ -402,9 +402,7 @@ __brick_equal(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1, _\n     if (__last1 - __first1 != __last2 - __first2)\n         return false;\n \n-    return __unseq_backend::__simd_first(__first1, __last1 - __first1, __first2,\n-                                         __internal::__not_pred<_BinaryPredicate>(__p))\n-               .first == __last1;\n+    return __unseq_backend::__simd_first(__first1, __last1 - __first1, __first2, std::not_fn(__p)).first == __last1;\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate,\n@@ -454,8 +452,7 @@ bool\n __brick_equal(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1, _RandomAccessIterator2 __first2,\n               _BinaryPredicate __p, /* is_vector = */ std::true_type) noexcept\n {\n-    return __unseq_backend::__simd_first(__first1, __last1 - __first1, __first2, __not_pred<_BinaryPredicate>(__p))\n-               .first == __last1;\n+    return __unseq_backend::__simd_first(__first1, __last1 - __first1, __first2, std::not_fn(__p)).first == __last1;\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate,\n@@ -599,21 +596,19 @@ _RandomAccessIterator\n __find_subrange(_RandomAccessIterator __first, _RandomAccessIterator __last, _RandomAccessIterator __global_last,\n                 _Size __count, const _Tp& __value, _BinaryPredicate __pred, _IsVector __is_vector) noexcept\n {\n-    if (__global_last - __first < __count || __count < 1)\n+    if (static_cast<_Size>(__global_last - __first) < __count || __count < 1)\n     {\n         return __last; // According to the standard last shall be returned when count < 1\n     }\n \n-    auto __n = __global_last - __first;\n     auto __unary_pred = __equal_value_by_pred<_Tp, _BinaryPredicate>(__value, __pred);\n-    while (__first != __last && (__global_last - __first >= __count))\n+    while (__first != __last && (static_cast<_Size>(__global_last - __first) >= __count))\n     {\n         __first = __internal::__brick_find_if(__first, __last, __unary_pred, __is_vector);\n \n         // check that all of elements in [first+1, first+count) equal to value\n-        if (__first != __last && (__global_last - __first >= __count) &&\n-            !__internal::__brick_any_of(__first + 1, __first + __count,\n-                                        __not_pred<decltype(__unary_pred)>(__unary_pred), __is_vector))\n+        if (__first != __last && (static_cast<_Size>(__global_last - __first) >= __count) &&\n+            !__internal::__brick_any_of(__first + 1, __first + __count, std::not_fn(__unary_pred), __is_vector))\n         {\n             return __first;\n         }\n@@ -821,7 +816,7 @@ __pattern_search_n(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _Ra\n                    _Size __count, const _Tp& __value, _BinaryPredicate __pred, _IsVector __is_vector,\n                    /*is_parallel=*/std::true_type) noexcept\n {\n-    if (__last - __first == __count)\n+    if (static_cast<_Size>(__last - __first) == __count)\n     {\n         const bool __result = !__internal::__pattern_any_of(\n             std::forward<_ExecutionPolicy>(__exec), __first, __last,\n@@ -903,6 +898,36 @@ __brick_move(_RandomAccessIterator __first, _RandomAccessIterator __last, _Outpu\n         [](_RandomAccessIterator __first, _OutputIterator __result) { *__result = std::move(*__first); });\n }\n \n+struct __brick_move_destroy\n+{\n+    template <typename _Iterator, typename _OutputIterator>\n+    _OutputIterator\n+    operator()(_Iterator __first, _Iterator __last, _OutputIterator __result, /*vec*/ std::true_type) const\n+    {\n+        using _IteratorValueType = typename std::iterator_traits<_Iterator>::value_type;\n+\n+        return __unseq_backend::__simd_assign(__first, __last - __first, __result,\n+                                              [](_Iterator __first, _OutputIterator __result) {\n+                                                  *__result = std::move(*__first);\n+                                                  (*__first).~_IteratorValueType();\n+                                              });\n+    }\n+\n+    template <typename _Iterator, typename _OutputIterator>\n+    _OutputIterator\n+    operator()(_Iterator __first, _Iterator __last, _OutputIterator __result, /*vec*/ std::false_type) const\n+    {\n+        using _IteratorValueType = typename std::iterator_traits<_Iterator>::value_type;\n+\n+        for (; __first != __last; ++__first, ++__result)\n+        {\n+            *__result = std::move(*__first);\n+            (*__first).~_IteratorValueType();\n+        }\n+        return __result;\n+    }\n+};\n+\n //------------------------------------------------------------------------\n // swap_ranges\n //------------------------------------------------------------------------\n@@ -1224,10 +1249,16 @@ __remove_elements(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardI\n             [&__m](_DifferenceType __total) { __m = __total; });\n \n         // 3. Elements from result are moved to [first, last)\n-        __par_backend::__parallel_for(std::forward<_ExecutionPolicy>(__exec), __result, __result + __m,\n-                                      [__result, __first, __is_vector](_Tp* __i, _Tp* __j) {\n-                                          __internal::__brick_move(__i, __j, __first + (__i - __result), __is_vector);\n-                                      });\n+        __par_backend::__parallel_for(\n+            std::forward<_ExecutionPolicy>(__exec), __result, __result + __m,\n+            [__result, __first, __is_vector](_Tp* __i, _Tp* __j) {\n+                __invoke_if_else(\n+                    std::is_trivial<_Tp>(),\n+                    [&]() { __brick_move(__i, __j, __first + (__i - __result), __is_vector); },\n+                    [&]() {\n+                        __brick_move_destroy()(__i, __j, __first + (__i - __result), __is_vector);\n+                    });\n+            });\n         return __first + __m;\n     });\n }\n@@ -1576,8 +1607,8 @@ __pattern_rotate(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIt\n \n             __par_backend::__parallel_for(std::forward<_ExecutionPolicy>(__exec), __result, __result + (__n - __m),\n                                           [__first, __result, __is_vector](_Tp* __b, _Tp* __e) {\n-                                              __internal::__brick_move(__b, __e, __first + (__b - __result),\n-                                                                       __is_vector);\n+                                              __brick_move_destroy()(\n+                                                  __b, __e, __first + (__b - __result), __is_vector);\n                                           });\n \n             return __first + (__last - __middle);\n@@ -1602,7 +1633,7 @@ __pattern_rotate(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIt\n \n             __par_backend::__parallel_for(std::forward<_ExecutionPolicy>(__exec), __result, __result + __m,\n                                           [__n, __m, __first, __result, __is_vector](_Tp* __b, _Tp* __e) {\n-                                              __internal::__brick_move(\n+                                              __brick_move_destroy()(\n                                                   __b, __e, __first + ((__n - __m) + (__b - __result)), __is_vector);\n                                           });\n \n@@ -1764,7 +1795,7 @@ __pattern_is_partitioned(_ExecutionPolicy&& __exec, _ForwardIterator __first, _F\n                     {\n                         // find first element that don't satisfy pred\n                         _ForwardIterator __x =\n-                            __internal::__brick_find_if(__i + 1, __j, __not_pred<_UnaryPredicate>(__pred), __is_vector);\n+                            __internal::__brick_find_if(__i + 1, __j, std::not_fn(__pred), __is_vector);\n                         if (__x != __j)\n                         {\n                             // find first element after \"x\" that satisfy pred\n@@ -2087,8 +2118,7 @@ __pattern_sort(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _Random\n     __internal::__except_handler([&]() {\n         __par_backend::__parallel_stable_sort(std::forward<_ExecutionPolicy>(__exec), __first, __last, __comp,\n                                               [](_RandomAccessIterator __first, _RandomAccessIterator __last,\n-                                                 _Compare __comp) { std::sort(__first, __last, __comp); },\n-                                              __last - __first);\n+                                                 _Compare __comp) { std::sort(__first, __last, __comp); });\n     });\n }\n \n@@ -2135,6 +2165,9 @@ __pattern_partial_sort(_ExecutionPolicy&& __exec, _RandomAccessIterator __first,\n                        _RandomAccessIterator __last, _Compare __comp, _IsVector, /*is_parallel=*/std::true_type)\n {\n     const auto __n = __middle - __first;\n+    if (__n == 0)\n+        return;\n+\n     __internal::__except_handler([&]() {\n         __par_backend::__parallel_stable_sort(\n             std::forward<_ExecutionPolicy>(__exec), __first, __last, __comp,\n@@ -2223,8 +2256,13 @@ __pattern_partial_sort_copy(_ExecutionPolicy&& __exec, _ForwardIterator __first,\n             // 3. Move elements from temporary __buffer to output\n             __par_backend::__parallel_for(std::forward<_ExecutionPolicy>(__exec), __r, __r + __n2,\n                                           [__r, __d_first, __is_vector](_T1* __i, _T1* __j) {\n-                                              __internal::__brick_move(__i, __j, __d_first + (__i - __r), __is_vector);\n+                                              __brick_move_destroy()(\n+                                                  __i, __j, __d_first + (__i - __r), __is_vector);\n                                           });\n+            __par_backend::__parallel_for(\n+                std::forward<_ExecutionPolicy>(__exec), __r + __n2, __r + __n1,\n+                [__is_vector](_T1* __i, _T1* __j) { __brick_destroy(__i, __j, __is_vector); });\n+\n             return __d_first + __n2;\n         }\n     });\n@@ -2244,7 +2282,7 @@ __brick_adjacent_find(_ForwardIterator __first, _ForwardIterator __last, _Binary\n template <class _ForwardIterator, class _BinaryPredicate>\n _ForwardIterator\n __brick_adjacent_find(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred,\n-                      /* IsVector = */ std::false_type, bool __or_semantic) noexcept\n+                      /* IsVector = */ std::false_type, bool) noexcept\n {\n     return std::adjacent_find(__first, __last, __pred);\n }\n@@ -2670,16 +2708,14 @@ __pattern_inplace_merge(_ExecutionPolicy&& __exec, _BidirectionalIterator __firs\n             [__n, __move_values, __move_sequences](_BidirectionalIterator __f1, _BidirectionalIterator __l1,\n                                                    _BidirectionalIterator __f2, _BidirectionalIterator __l2, _Tp* __f3,\n                                                    _Compare __comp) {\n-                auto __func = __par_backend::__serial_move_merge<decltype(__move_values), decltype(__move_sequences)>(\n-                    __n, __move_values, __move_sequences);\n-                __func(__f1, __l1, __f2, __l2, __f3, __comp);\n+                (__utils::__serial_move_merge(__n))(__f1, __l1, __f2, __l2, __f3, __comp, __move_values, __move_values,\n+                                                    __move_sequences, __move_sequences);\n                 return __f3 + (__l1 - __f1) + (__l2 - __f2);\n             });\n-\n-        __par_backend::__parallel_for(std::forward<_ExecutionPolicy>(__exec), __r, __r + __n,\n-                                      [__r, __first, __is_vector](_Tp* __i, _Tp* __j) {\n-                                          __internal::__brick_move(__i, __j, __first + (__i - __r), __is_vector);\n-                                      });\n+        __par_backend::__parallel_for(\n+            std::forward<_ExecutionPolicy>(__exec), __r, __r + __n, [__r, __first, __is_vector](_Tp* __i, _Tp* __j) {\n+                __brick_move_destroy()(__i, __j, __first + (__i - __r), __is_vector);\n+            });\n     });\n }\n \n@@ -2689,7 +2725,7 @@ __pattern_inplace_merge(_ExecutionPolicy&& __exec, _BidirectionalIterator __firs\n \n template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Compare, class _IsVector>\n bool\n-__pattern_includes(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1,\n+__pattern_includes(_ExecutionPolicy&&, _ForwardIterator1 __first1, _ForwardIterator1 __last1,\n                    _ForwardIterator2 __first2, _ForwardIterator2 __last2, _Compare __comp, _IsVector,\n                    /*is_parallel=*/std::false_type) noexcept\n {\n@@ -2699,7 +2735,7 @@ __pattern_includes(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _Forwa\n template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Compare, class _IsVector>\n bool\n __pattern_includes(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1,\n-                   _ForwardIterator2 __first2, _ForwardIterator2 __last2, _Compare __comp, _IsVector __is_vector,\n+                   _ForwardIterator2 __first2, _ForwardIterator2 __last2, _Compare __comp, _IsVector,\n                    /*is_parallel=*/std::true_type)\n {\n     if (__first2 >= __last2)\n@@ -2761,7 +2797,7 @@ __parallel_set_op(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _Forwar\n                   _SizeFunction __size_func, _SetOP __set_op, _IsVector __is_vector)\n {\n     typedef typename std::iterator_traits<_ForwardIterator1>::difference_type _DifferenceType;\n-    typedef typename std::iterator_traits<_OutputIterator>::value_type _T;\n+    typedef typename std::iterator_traits<_OutputIterator>::value_type _Tp;\n \n     struct _SetRange\n     {\n@@ -2776,16 +2812,17 @@ __parallel_set_op(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _Forwar\n     const _DifferenceType __n1 = __last1 - __first1;\n     const _DifferenceType __n2 = __last2 - __first2;\n \n-    __par_backend::__buffer<_T> __buf(__size_func(__n1, __n2));\n+    __par_backend::__buffer<_Tp> __buf(__size_func(__n1, __n2));\n \n     return __internal::__except_handler([&__exec, __n1, __first1, __last1, __first2, __last2, __result, __is_vector,\n                                          __comp, __size_func, __set_op, &__buf]() {\n         auto __buffer = __buf.get();\n         _DifferenceType __m{};\n         auto __scan = [=](_DifferenceType, _DifferenceType, const _SetRange& __s) { // Scan\n             if (!__s.empty())\n-                __internal::__brick_move(__buffer + __s.__buf_pos, __buffer + (__s.__buf_pos + __s.__len),\n-                                         __result + __s.__pos, __is_vector);\n+                __brick_move_destroy()(__buffer + __s.__buf_pos,\n+                                                         __buffer + (__s.__buf_pos + __s.__len), __result + __s.__pos,\n+                                                         __is_vector);\n         };\n         __par_backend::__parallel_strict_scan(\n             std::forward<_ExecutionPolicy>(__exec), __n1, _SetRange{0, 0, 0}, //-1, 0},\n@@ -2971,6 +3008,17 @@ __brick_set_union(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _Forwar\n     return std::set_union(__first1, __last1, __first2, __last2, __result, __comp);\n }\n \n+template <typename _IsVector>\n+struct __BrickCopyConstruct\n+{\n+    template <typename _ForwardIterator, typename _OutputIterator>\n+    _OutputIterator\n+    operator()(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result)\n+    {\n+        return __brick_uninitialized_copy(__first, __last, __result, _IsVector());\n+    }\n+};\n+\n template <class _ForwardIterator1, class _ForwardIterator2, class _OutputIterator, class _Compare>\n _OutputIterator\n __brick_set_union(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n@@ -3007,12 +3055,14 @@ __pattern_set_union(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _Forw\n     if (__n1 + __n2 <= __set_algo_cut_off)\n         return std::set_union(__first1, __last1, __first2, __last2, __result, __comp);\n \n-    typedef typename std::iterator_traits<_OutputIterator>::value_type _T;\n-    return __internal::__parallel_set_union_op(\n+    typedef typename std::iterator_traits<_OutputIterator>::value_type _Tp;\n+    return __parallel_set_union_op(\n         std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __last2, __result, __comp,\n         [](_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2,\n-           _T* __result,\n-           _Compare __comp) { return std::set_union(__first1, __last1, __first2, __last2, __result, __comp); },\n+           _Tp* __result, _Compare __comp) {\n+            return __pstl::__utils::__set_union_construct(__first1, __last1, __first2, __last2, __result, __comp,\n+                                                          __BrickCopyConstruct<_IsVector>());\n+        },\n         __is_vector);\n }\n \n@@ -3056,7 +3106,7 @@ __pattern_set_intersection(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1\n                            _ForwardIterator2 __first2, _ForwardIterator2 __last2, _OutputIterator __result,\n                            _Compare __comp, _IsVector __is_vector, /*is_parallel=*/std::true_type)\n {\n-    typedef typename std::iterator_traits<_OutputIterator>::value_type _T;\n+    typedef typename std::iterator_traits<_OutputIterator>::value_type _Tp;\n     typedef typename std::iterator_traits<_ForwardIterator1>::difference_type _DifferenceType;\n \n     const auto __n1 = __last1 - __first1;\n@@ -3086,8 +3136,9 @@ __pattern_set_intersection(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1\n             std::forward<_ExecutionPolicy>(__exec), __left_bound_seq_1, __last1, __first2, __last2, __result, __comp,\n             [](_DifferenceType __n, _DifferenceType __m) { return std::min(__n, __m); },\n             [](_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n-               _ForwardIterator2 __last2, _T* __result, _Compare __comp) {\n-                return std::set_intersection(__first1, __last1, __first2, __last2, __result, __comp);\n+               _ForwardIterator2 __last2, _Tp* __result, _Compare __comp) {\n+                return __pstl::__utils::__set_intersection_construct(__first1, __last1, __first2, __last2, __result,\n+                                                                     __comp);\n             },\n             __is_vector);\n     }\n@@ -3100,8 +3151,9 @@ __pattern_set_intersection(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1\n             std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __left_bound_seq_2, __last2, __result, __comp,\n             [](_DifferenceType __n, _DifferenceType __m) { return std::min(__n, __m); },\n             [](_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n-               _ForwardIterator2 __last2, _T* __result, _Compare __comp) {\n-                return std::set_intersection(__first2, __last2, __first1, __last1, __result, __comp);\n+               _ForwardIterator2 __last2, _Tp* __result, _Compare __comp) {\n+                return __pstl::__utils::__set_intersection_construct(__first2, __last2, __first1, __last1, __result,\n+                                                                     __comp);\n             },\n             __is_vector);\n         return __result;\n@@ -3151,7 +3203,7 @@ __pattern_set_difference(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1,\n                          _ForwardIterator2 __first2, _ForwardIterator2 __last2, _OutputIterator __result,\n                          _Compare __comp, _IsVector __is_vector, /*is_parallel=*/std::true_type)\n {\n-    typedef typename std::iterator_traits<_OutputIterator>::value_type _T;\n+    typedef typename std::iterator_traits<_OutputIterator>::value_type _Tp;\n     typedef typename std::iterator_traits<_ForwardIterator1>::difference_type _DifferenceType;\n \n     const auto __n1 = __last1 - __first1;\n@@ -3193,13 +3245,15 @@ __pattern_set_difference(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1,\n             std::true_type());\n \n     if (__n1 + __n2 > __set_algo_cut_off)\n-        return __internal::__parallel_set_op(\n-            std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __last2, __result, __comp,\n-            [](_DifferenceType __n, _DifferenceType __m) { return __n; },\n-            [](_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n-               _ForwardIterator2 __last2, _T* __result,\n-               _Compare __comp) { return std::set_difference(__first1, __last1, __first2, __last2, __result, __comp); },\n-            __is_vector);\n+        return __parallel_set_op(std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __last2, __result,\n+                                 __comp, [](_DifferenceType __n, _DifferenceType) { return __n; },\n+                                 [](_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n+                                    _ForwardIterator2 __last2, _Tp* __result, _Compare __comp) {\n+                                     return __pstl::__utils::__set_difference_construct(\n+                                         __first1, __last1, __first2, __last2, __result, __comp,\n+                                         __BrickCopyConstruct<_IsVector>());\n+                                 },\n+                                 __is_vector);\n \n     // use serial algorithm\n     return std::set_difference(__first1, __last1, __first2, __last2, __result, __comp);\n@@ -3254,12 +3308,13 @@ __pattern_set_symmetric_difference(_ExecutionPolicy&& __exec, _ForwardIterator1\n     if (__n1 + __n2 <= __set_algo_cut_off)\n         return std::set_symmetric_difference(__first1, __last1, __first2, __last2, __result, __comp);\n \n-    typedef typename std::iterator_traits<_OutputIterator>::value_type _T;\n+    typedef typename std::iterator_traits<_OutputIterator>::value_type _Tp;\n     return __internal::__parallel_set_union_op(\n         std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __last2, __result, __comp,\n         [](_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2,\n-           _T* __result, _Compare __comp) {\n-            return std::set_symmetric_difference(__first1, __last1, __first2, __last2, __result, __comp);\n+           _Tp* __result, _Compare __comp) {\n+            return __pstl::__utils::__set_symmetric_difference_construct(__first1, __last1, __first2, __last2, __result,\n+                                                                         __comp, __BrickCopyConstruct<_IsVector>());\n         },\n         __is_vector);\n }\n@@ -3443,14 +3498,14 @@ __pattern_minmax_element(_ExecutionPolicy&& __exec, _ForwardIterator __first, _F\n             std::forward<_ExecutionPolicy>(__exec), __first + 1, __last, std::make_pair(__first, __first),\n             [=](_ForwardIterator __begin, _ForwardIterator __end, _Result __init) -> _Result {\n                 const _Result __subresult = __internal::__brick_minmax_element(__begin, __end, __comp, __is_vector);\n-                return std::make_pair(__internal::__cmp_iterators_by_values(__subresult.first, __init.first, __comp),\n-                                      __internal::__cmp_iterators_by_values(__init.second, __subresult.second,\n-                                                                            __not_pred<_Compare>(__comp)));\n+                return std::make_pair(\n+                    __internal::__cmp_iterators_by_values(__subresult.first, __init.first, __comp),\n+                    __internal::__cmp_iterators_by_values(__init.second, __subresult.second, std::not_fn(__comp)));\n             },\n             [=](_Result __p1, _Result __p2) -> _Result {\n                 return std::make_pair(\n                     __internal::__cmp_iterators_by_values(__p1.first, __p2.first, __comp),\n-                    __internal::__cmp_iterators_by_values(__p2.second, __p1.second, __not_pred<_Compare>(__comp)));\n+                    __internal::__cmp_iterators_by_values(__p2.second, __p1.second, std::not_fn(__comp)));\n             });\n     });\n }\n@@ -3487,7 +3542,7 @@ __brick_mismatch(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _Forward\n                  _ForwardIterator2 __last2, _Predicate __pred, /* __is_vector = */ std::true_type) noexcept\n {\n     auto __n = std::min(__last1 - __first1, __last2 - __first2);\n-    return __unseq_backend::__simd_first(__first1, __n, __first2, __not_pred<_Predicate>(__pred));\n+    return __unseq_backend::__simd_first(__first1, __n, __first2, std::not_fn(__pred));\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Predicate, class _IsVector>"}, {"sha": "53ff11fca46ed2433d8098fe97d854ce04b8ad5c", "filename": "libstdc++-v3/include/pstl/execution_impl.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e957b86ca26f9a4e49acf625ed397e7dd05b0d66/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fexecution_impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e957b86ca26f9a4e49acf625ed397e7dd05b0d66/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fexecution_impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fexecution_impl.h?ref=e957b86ca26f9a4e49acf625ed397e7dd05b0d66", "patch": "@@ -28,7 +28,7 @@ template <typename _Tp>\n std::false_type __lazy_and(_Tp, std::false_type)\n {\n     return std::false_type{};\n-};\n+}\n \n template <typename _Tp>\n inline _Tp\n@@ -41,7 +41,7 @@ template <typename _Tp>\n std::true_type __lazy_or(_Tp, std::true_type)\n {\n     return std::true_type{};\n-};\n+}\n \n template <typename _Tp>\n inline _Tp"}, {"sha": "d2e30529f785d5bb2b1e6f161b1d2fcfc9d91b1a", "filename": "libstdc++-v3/include/pstl/glue_algorithm_impl.h", "status": "modified", "additions": 260, "deletions": 283, "changes": 543, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e957b86ca26f9a4e49acf625ed397e7dd05b0d66/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fglue_algorithm_impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e957b86ca26f9a4e49acf625ed397e7dd05b0d66/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fglue_algorithm_impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fglue_algorithm_impl.h?ref=e957b86ca26f9a4e49acf625ed397e7dd05b0d66", "patch": "@@ -26,11 +26,10 @@ template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate>\n __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>\n any_of(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n {\n-    using namespace __pstl;\n-    return __internal::__pattern_any_of(\n+    return __pstl::__internal::__pattern_any_of(\n         std::forward<_ExecutionPolicy>(__exec), __first, __last, __pred,\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n }\n \n // [alg.all_of]\n@@ -39,8 +38,7 @@ template <class _ExecutionPolicy, class _ForwardIterator, class _Pred>\n __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>\n all_of(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Pred __pred)\n {\n-    return !std::any_of(std::forward<_ExecutionPolicy>(__exec), __first, __last,\n-                        __pstl::__internal::__not_pred<_Pred>(__pred));\n+    return !std::any_of(std::forward<_ExecutionPolicy>(__exec), __first, __last, std::not_fn(__pred));\n }\n \n // [alg.none_of]\n@@ -58,21 +56,20 @@ template <class _ExecutionPolicy, class _ForwardIterator, class _Function>\n __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n for_each(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Function __f)\n {\n-    using namespace __pstl;\n-    __internal::__pattern_walk1(std::forward<_ExecutionPolicy>(__exec), __first, __last, __f,\n-                                __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n-                                __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n+    __pstl::__internal::__pattern_walk1(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __last, __f,\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator, class _Size, class _Function>\n __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n for_each_n(_ExecutionPolicy&& __exec, _ForwardIterator __first, _Size __n, _Function __f)\n {\n-    using namespace __pstl;\n-    return __internal::__pattern_walk1_n(\n+    return __pstl::__internal::__pattern_walk1_n(\n         std::forward<_ExecutionPolicy>(__exec), __first, __n, __f,\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n }\n \n // [alg.find]\n@@ -81,19 +78,17 @@ template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate>\n __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n find_if(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n {\n-    using namespace __pstl;\n-    return __internal::__pattern_find_if(\n+    return __pstl::__internal::__pattern_find_if(\n         std::forward<_ExecutionPolicy>(__exec), __first, __last, __pred,\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate>\n __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n find_if_not(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n {\n-    return std::find_if(std::forward<_ExecutionPolicy>(__exec), __first, __last,\n-                        __pstl::__internal::__not_pred<_Predicate>(__pred));\n+    return std::find_if(std::forward<_ExecutionPolicy>(__exec), __first, __last, std::not_fn(__pred));\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>\n@@ -110,11 +105,12 @@ __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardItera\n find_end(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __s_first,\n          _ForwardIterator2 __s_last, _BinaryPredicate __pred)\n {\n-    using namespace __pstl;\n-    return __internal::__pattern_find_end(\n+    return __pstl::__internal::__pattern_find_end(\n         std::forward<_ExecutionPolicy>(__exec), __first, __last, __s_first, __s_last, __pred,\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(\n+            __exec),\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(\n+            __exec));\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>\n@@ -123,7 +119,7 @@ find_end(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1\n          _ForwardIterator2 __s_last)\n {\n     return std::find_end(std::forward<_ExecutionPolicy>(__exec), __first, __last, __s_first, __s_last,\n-                         __pstl::__internal::__pstl_equal());\n+                         std::equal_to<>());\n }\n \n // [alg.find_first_of]\n@@ -132,11 +128,12 @@ __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardItera\n find_first_of(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last,\n               _ForwardIterator2 __s_first, _ForwardIterator2 __s_last, _BinaryPredicate __pred)\n {\n-    using namespace __pstl;\n-    return __internal::__pattern_find_first_of(\n+    return __pstl::__internal::__pattern_find_first_of(\n         std::forward<_ExecutionPolicy>(__exec), __first, __last, __s_first, __s_last, __pred,\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(\n+            __exec),\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(\n+            __exec));\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>\n@@ -145,7 +142,7 @@ find_first_of(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIter\n               _ForwardIterator2 __s_first, _ForwardIterator2 __s_last)\n {\n     return std::find_first_of(std::forward<_ExecutionPolicy>(__exec), __first, __last, __s_first, __s_last,\n-                              __pstl::__internal::__pstl_equal());\n+                              std::equal_to<>());\n }\n \n // [alg.adjacent_find]\n@@ -154,22 +151,22 @@ __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardItera\n adjacent_find(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last)\n {\n     typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;\n-    using namespace __pstl;\n-    return __internal::__pattern_adjacent_find(\n+    return __pstl::__internal::__pattern_adjacent_find(\n         std::forward<_ExecutionPolicy>(__exec), __first, __last, std::equal_to<_ValueType>(),\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec), /*first_semantic*/ false);\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+        /*first_semantic*/ false);\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator, class _BinaryPredicate>\n __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n adjacent_find(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)\n {\n-    using namespace __pstl;\n-    return __internal::__pattern_adjacent_find(\n+    return __pstl::__internal::__pattern_adjacent_find(\n         std::forward<_ExecutionPolicy>(__exec), __first, __last, __pred,\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec), /*first_semantic*/ false);\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+        /*first_semantic*/ false);\n }\n \n // [alg.count]\n@@ -183,24 +180,22 @@ __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,\n count(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)\n {\n     typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;\n-    using namespace __pstl;\n-    return __internal::__pattern_count(\n+    return __pstl::__internal::__pattern_count(\n         std::forward<_ExecutionPolicy>(__exec), __first, __last,\n         [&__value](const _ValueType& __x) { return __value == __x; },\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate>\n __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,\n                                                  typename iterator_traits<_ForwardIterator>::difference_type>\n count_if(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n {\n-    using namespace __pstl;\n-    return __internal::__pattern_count(\n+    return __pstl::__internal::__pattern_count(\n         std::forward<_ExecutionPolicy>(__exec), __first, __last, __pred,\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n }\n \n // [alg.search]\n@@ -210,32 +205,31 @@ __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardItera\n search(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __s_first,\n        _ForwardIterator2 __s_last, _BinaryPredicate __pred)\n {\n-    using namespace __pstl;\n-    return __internal::__pattern_search(\n+    return __pstl::__internal::__pattern_search(\n         std::forward<_ExecutionPolicy>(__exec), __first, __last, __s_first, __s_last, __pred,\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(\n+            __exec),\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(\n+            __exec));\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>\n __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator1>\n search(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __s_first,\n        _ForwardIterator2 __s_last)\n {\n-    return std::search(std::forward<_ExecutionPolicy>(__exec), __first, __last, __s_first, __s_last,\n-                       __pstl::__internal::__pstl_equal());\n+    return std::search(std::forward<_ExecutionPolicy>(__exec), __first, __last, __s_first, __s_last, std::equal_to<>());\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator, class _Size, class _Tp, class _BinaryPredicate>\n __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n search_n(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Size __count,\n          const _Tp& __value, _BinaryPredicate __pred)\n {\n-    using namespace __pstl;\n-    return __internal::__pattern_search_n(\n+    return __pstl::__internal::__pattern_search_n(\n         std::forward<_ExecutionPolicy>(__exec), __first, __last, __count, __value, __pred,\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator, class _Size, class _Tp>\n@@ -253,44 +247,47 @@ template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterato\n __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n copy(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __result)\n {\n-    using namespace __pstl;\n     const auto __is_vector =\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec);\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(\n+            __exec);\n \n-    return __internal::__pattern_walk2_brick(\n+    return __pstl::__internal::__pattern_walk2_brick(\n         std::forward<_ExecutionPolicy>(__exec), __first, __last, __result,\n         [__is_vector](_ForwardIterator1 __begin, _ForwardIterator1 __end, _ForwardIterator2 __res) {\n-            return __internal::__brick_copy(__begin, __end, __res, __is_vector);\n+            return __pstl::__internal::__brick_copy(__begin, __end, __res, __is_vector);\n         },\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(\n+            __exec));\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator1, class _Size, class _ForwardIterator2>\n __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n copy_n(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _Size __n, _ForwardIterator2 __result)\n {\n-    using namespace __pstl;\n     const auto __is_vector =\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec);\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(\n+            __exec);\n \n-    return __internal::__pattern_walk2_brick_n(\n+    return __pstl::__internal::__pattern_walk2_brick_n(\n         std::forward<_ExecutionPolicy>(__exec), __first, __n, __result,\n         [__is_vector](_ForwardIterator1 __begin, _Size __sz, _ForwardIterator2 __res) {\n-            return __internal::__brick_copy_n(__begin, __sz, __res, __is_vector);\n+            return __pstl::__internal::__brick_copy_n(__begin, __sz, __res, __is_vector);\n         },\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(\n+            __exec));\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Predicate>\n __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n copy_if(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __result,\n         _Predicate __pred)\n {\n-    using namespace __pstl;\n-    return __internal::__pattern_copy_if(\n+    return __pstl::__internal::__pattern_copy_if(\n         std::forward<_ExecutionPolicy>(__exec), __first, __last, __result, __pred,\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(\n+            __exec),\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(\n+            __exec));\n }\n \n // [alg.swap]\n@@ -300,17 +297,18 @@ __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardItera\n swap_ranges(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1,\n             _ForwardIterator2 __first2)\n {\n-    using namespace __pstl;\n     typedef typename iterator_traits<_ForwardIterator1>::reference _ReferenceType1;\n     typedef typename iterator_traits<_ForwardIterator2>::reference _ReferenceType2;\n-    return __internal::__pattern_walk2(\n+    return __pstl::__internal::__pattern_walk2(\n         std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2,\n         [](_ReferenceType1 __x, _ReferenceType2 __y) {\n             using std::swap;\n             swap(__x, __y);\n         },\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(\n+            __exec),\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(\n+            __exec));\n }\n \n // [alg.transform]\n@@ -322,12 +320,13 @@ transform(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator\n {\n     typedef typename iterator_traits<_ForwardIterator1>::reference _InputType;\n     typedef typename iterator_traits<_ForwardIterator2>::reference _OutputType;\n-    using namespace __pstl;\n-    return __internal::__pattern_walk2(\n+    return __pstl::__internal::__pattern_walk2(\n         std::forward<_ExecutionPolicy>(__exec), __first, __last, __result,\n         [__op](_InputType __x, _OutputType __y) mutable { __y = __op(__x); },\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(\n+            __exec),\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(\n+            __exec));\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator,\n@@ -339,14 +338,13 @@ transform(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterato\n     typedef typename iterator_traits<_ForwardIterator1>::reference _Input1Type;\n     typedef typename iterator_traits<_ForwardIterator2>::reference _Input2Type;\n     typedef typename iterator_traits<_ForwardIterator>::reference _OutputType;\n-    using namespace __pstl;\n-    return __internal::__pattern_walk3(\n+    return __pstl::__internal::__pattern_walk3(\n         std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __result,\n         [__op](_Input1Type x, _Input2Type y, _OutputType z) mutable { z = __op(x, y); },\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2,\n-                                                 _ForwardIterator>(__exec),\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2,\n-                                                   _ForwardIterator>(__exec));\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2,\n+                                                         _ForwardIterator>(__exec),\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2,\n+                                                           _ForwardIterator>(__exec));\n }\n \n // [alg.replace]\n@@ -356,17 +354,17 @@ __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n replace_if(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _UnaryPredicate __pred,\n            const _Tp& __new_value)\n {\n-    using namespace __pstl;\n     typedef typename iterator_traits<_ForwardIterator>::reference _ElementType;\n-    __internal::__pattern_walk1(std::forward<_ExecutionPolicy>(__exec), __first, __last,\n-                                [&__pred, &__new_value](_ElementType __elem) {\n-                                    if (__pred(__elem))\n-                                    {\n-                                        __elem = __new_value;\n-                                    }\n-                                },\n-                                __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n-                                __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n+    __pstl::__internal::__pattern_walk1(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __last,\n+        [&__pred, &__new_value](_ElementType __elem) {\n+            if (__pred(__elem))\n+            {\n+                __elem = __new_value;\n+            }\n+        },\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>\n@@ -385,12 +383,13 @@ replace_copy_if(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIt\n {\n     typedef typename iterator_traits<_ForwardIterator1>::reference _InputType;\n     typedef typename iterator_traits<_ForwardIterator2>::reference _OutputType;\n-    using namespace __pstl;\n-    return __internal::__pattern_walk2(\n+    return __pstl::__internal::__pattern_walk2(\n         std::forward<_ExecutionPolicy>(__exec), __first, __last, __result,\n         [__pred, &__new_value](_InputType __x, _OutputType __y) mutable { __y = __pred(__x) ? __new_value : __x; },\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(\n+            __exec),\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(\n+            __exec));\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Tp>\n@@ -408,10 +407,10 @@ template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>\n __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n fill(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)\n {\n-    using namespace __pstl;\n-    __internal::__pattern_fill(std::forward<_ExecutionPolicy>(__exec), __first, __last, __value,\n-                               __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n-                               __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n+    __pstl::__internal::__pattern_fill(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __last, __value,\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator, class _Size, class _Tp>\n@@ -421,23 +420,21 @@ fill_n(_ExecutionPolicy&& __exec, _ForwardIterator __first, _Size __count, const\n     if (__count <= 0)\n         return __first;\n \n-    using namespace __pstl;\n-    return __internal::__pattern_fill_n(\n+    return __pstl::__internal::__pattern_fill_n(\n         std::forward<_ExecutionPolicy>(__exec), __first, __count, __value,\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n }\n \n // [alg.generate]\n template <class _ExecutionPolicy, class _ForwardIterator, class _Generator>\n __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n generate(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Generator __g)\n {\n-    using namespace __pstl;\n-    __internal::__pattern_generate(\n+    __pstl::__internal::__pattern_generate(\n         std::forward<_ExecutionPolicy>(__exec), __first, __last, __g,\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator, class _Size, class _Generator>\n@@ -447,11 +444,10 @@ generate_n(_ExecutionPolicy&& __exec, _ForwardIterator __first, _Size __count, _\n     if (__count <= 0)\n         return __first;\n \n-    using namespace __pstl;\n-    return __internal::__pattern_generate_n(\n+    return __pstl::__internal::__pattern_generate_n(\n         std::forward<_ExecutionPolicy>(__exec), __first, __count, __g,\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n }\n \n // [alg.remove]\n@@ -461,8 +457,7 @@ __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardItera\n remove_copy_if(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last,\n                _ForwardIterator2 __result, _Predicate __pred)\n {\n-    return std::copy_if(std::forward<_ExecutionPolicy>(__exec), __first, __last, __result,\n-                        __pstl::__internal::__not_pred<_Predicate>(__pred));\n+    return std::copy_if(std::forward<_ExecutionPolicy>(__exec), __first, __last, __result, std::not_fn(__pred));\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Tp>\n@@ -478,11 +473,10 @@ template <class _ExecutionPolicy, class _ForwardIterator, class _UnaryPredicate>\n __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n remove_if(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _UnaryPredicate __pred)\n {\n-    using namespace __pstl;\n-    return __internal::__pattern_remove_if(\n+    return __pstl::__internal::__pattern_remove_if(\n         std::forward<_ExecutionPolicy>(__exec), __first, __last, __pred,\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>\n@@ -499,37 +493,37 @@ template <class _ExecutionPolicy, class _ForwardIterator, class _BinaryPredicate\n __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n unique(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)\n {\n-    using namespace __pstl;\n-    return __internal::__pattern_unique(\n+    return __pstl::__internal::__pattern_unique(\n         std::forward<_ExecutionPolicy>(__exec), __first, __last, __pred,\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator>\n __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n unique(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last)\n {\n-    return std::unique(std::forward<_ExecutionPolicy>(__exec), __first, __last, __pstl::__internal::__pstl_equal());\n+    return std::unique(std::forward<_ExecutionPolicy>(__exec), __first, __last, std::equal_to<>());\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\n __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n unique_copy(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __result,\n             _BinaryPredicate __pred)\n {\n-    using namespace __pstl;\n-    return __internal::__pattern_unique_copy(\n+    return __pstl::__internal::__pattern_unique_copy(\n         std::forward<_ExecutionPolicy>(__exec), __first, __last, __result, __pred,\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(\n+            __exec),\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(\n+            __exec));\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>\n __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n unique_copy(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __result)\n {\n-    return std::unique_copy(__exec, __first, __last, __result, __pstl::__internal::__pstl_equal());\n+    return std::unique_copy(__exec, __first, __last, __result, std::equal_to<>());\n }\n \n // [alg.reverse]\n@@ -538,23 +532,23 @@ template <class _ExecutionPolicy, class _BidirectionalIterator>\n __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n reverse(_ExecutionPolicy&& __exec, _BidirectionalIterator __first, _BidirectionalIterator __last)\n {\n-    using namespace __pstl;\n-    __internal::__pattern_reverse(\n+    __pstl::__internal::__pattern_reverse(\n         std::forward<_ExecutionPolicy>(__exec), __first, __last,\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _BidirectionalIterator>(__exec),\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _BidirectionalIterator>(__exec));\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _BidirectionalIterator>(__exec),\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _BidirectionalIterator>(__exec));\n }\n \n template <class _ExecutionPolicy, class _BidirectionalIterator, class _ForwardIterator>\n __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n reverse_copy(_ExecutionPolicy&& __exec, _BidirectionalIterator __first, _BidirectionalIterator __last,\n              _ForwardIterator __d_first)\n {\n-    using namespace __pstl;\n-    return __internal::__pattern_reverse_copy(\n+    return __pstl::__internal::__pattern_reverse_copy(\n         std::forward<_ExecutionPolicy>(__exec), __first, __last, __d_first,\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _BidirectionalIterator, _ForwardIterator>(__exec),\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _BidirectionalIterator, _ForwardIterator>(__exec));\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _BidirectionalIterator, _ForwardIterator>(\n+            __exec),\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _BidirectionalIterator, _ForwardIterator>(\n+            __exec));\n }\n \n // [alg.rotate]\n@@ -563,23 +557,23 @@ template <class _ExecutionPolicy, class _ForwardIterator>\n __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n rotate(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)\n {\n-    using namespace __pstl;\n-    return __internal::__pattern_rotate(\n+    return __pstl::__internal::__pattern_rotate(\n         std::forward<_ExecutionPolicy>(__exec), __first, __middle, __last,\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>\n __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n rotate_copy(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __middle, _ForwardIterator1 __last,\n             _ForwardIterator2 __result)\n {\n-    using namespace __pstl;\n-    return __internal::__pattern_rotate_copy(\n+    return __pstl::__internal::__pattern_rotate_copy(\n         std::forward<_ExecutionPolicy>(__exec), __first, __middle, __last, __result,\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(\n+            __exec),\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(\n+            __exec));\n }\n \n // [alg.partitions]\n@@ -588,34 +582,31 @@ template <class _ExecutionPolicy, class _ForwardIterator, class _UnaryPredicate>\n __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>\n is_partitioned(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _UnaryPredicate __pred)\n {\n-    using namespace __pstl;\n-    return __internal::__pattern_is_partitioned(\n+    return __pstl::__internal::__pattern_is_partitioned(\n         std::forward<_ExecutionPolicy>(__exec), __first, __last, __pred,\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator, class _UnaryPredicate>\n __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n partition(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _UnaryPredicate __pred)\n {\n-    using namespace __pstl;\n-    return __internal::__pattern_partition(\n+    return __pstl::__internal::__pattern_partition(\n         std::forward<_ExecutionPolicy>(__exec), __first, __last, __pred,\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n }\n \n template <class _ExecutionPolicy, class _BidirectionalIterator, class _UnaryPredicate>\n __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _BidirectionalIterator>\n stable_partition(_ExecutionPolicy&& __exec, _BidirectionalIterator __first, _BidirectionalIterator __last,\n                  _UnaryPredicate __pred)\n {\n-    using namespace __pstl;\n-    return __internal::__pattern_stable_partition(\n+    return __pstl::__internal::__pattern_stable_partition(\n         std::forward<_ExecutionPolicy>(__exec), __first, __last, __pred,\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _BidirectionalIterator>(__exec),\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _BidirectionalIterator>(__exec));\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _BidirectionalIterator>(__exec),\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _BidirectionalIterator>(__exec));\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator, class _ForwardIterator1, class _ForwardIterator2,\n@@ -624,13 +615,12 @@ __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, std::pair<_Fo\n partition_copy(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last,\n                _ForwardIterator1 __out_true, _ForwardIterator2 __out_false, _UnaryPredicate __pred)\n {\n-    using namespace __pstl;\n-    return __internal::__pattern_partition_copy(\n+    return __pstl::__internal::__pattern_partition_copy(\n         std::forward<_ExecutionPolicy>(__exec), __first, __last, __out_true, __out_false, __pred,\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator, _ForwardIterator1,\n-                                                 _ForwardIterator2>(__exec),\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator, _ForwardIterator1,\n-                                                   _ForwardIterator2>(__exec));\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator, _ForwardIterator1,\n+                                                         _ForwardIterator2>(__exec),\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator, _ForwardIterator1,\n+                                                           _ForwardIterator2>(__exec));\n }\n \n // [alg.sort]\n@@ -640,11 +630,10 @@ __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n sort(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n {\n     typedef typename iterator_traits<_RandomAccessIterator>::value_type _InputType;\n-    using namespace __pstl;\n-    return __internal::__pattern_sort(\n+    return __pstl::__internal::__pattern_sort(\n         std::forward<_ExecutionPolicy>(__exec), __first, __last, __comp,\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _RandomAccessIterator>(__exec),\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _RandomAccessIterator>(__exec),\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _RandomAccessIterator>(__exec),\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _RandomAccessIterator>(__exec),\n         typename std::is_move_constructible<_InputType>::type());\n }\n \n@@ -662,19 +651,18 @@ template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare>\n __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n stable_sort(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n {\n-    using namespace __pstl;\n-    return __internal::__pattern_stable_sort(\n+    return __pstl::__internal::__pattern_stable_sort(\n         std::forward<_ExecutionPolicy>(__exec), __first, __last, __comp,\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _RandomAccessIterator>(__exec),\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _RandomAccessIterator>(__exec));\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _RandomAccessIterator>(__exec),\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _RandomAccessIterator>(__exec));\n }\n \n template <class _ExecutionPolicy, class _RandomAccessIterator>\n __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n stable_sort(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __last)\n {\n     typedef typename std::iterator_traits<_RandomAccessIterator>::value_type _InputType;\n-    std::stable_sort(std::forward<_ExecutionPolicy>(__exec), __first, __last, std::less<_InputType>());\n+    std::stable_sort(__exec, __first, __last, std::less<_InputType>());\n }\n \n // [mismatch]\n@@ -684,20 +672,21 @@ __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, std::pair<_Fo\n mismatch(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n          _ForwardIterator2 __last2, _BinaryPredicate __pred)\n {\n-    using namespace __pstl;\n-    return __internal::__pattern_mismatch(\n+    return __pstl::__internal::__pattern_mismatch(\n         std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __last2, __pred,\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(\n+            __exec),\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(\n+            __exec));\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\n __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, std::pair<_ForwardIterator1, _ForwardIterator2>>\n mismatch(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n          _BinaryPredicate __pred)\n {\n-    return std::mismatch(std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2,\n-\t\t\t std::next(__first2, std::distance(__first1, __last1)), __pred);\n+    return std::mismatch(__exec, __first1, __last1, __first2, std::next(__first2, std::distance(__first1, __last1)),\n+                         __pred);\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>\n@@ -706,7 +695,7 @@ mismatch(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator\n          _ForwardIterator2 __last2)\n {\n     return std::mismatch(std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __last2,\n-                         __pstl::__internal::__pstl_equal());\n+                         std::equal_to<>());\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>\n@@ -725,57 +714,54 @@ __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>\n equal(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n       _BinaryPredicate __p)\n {\n-    using namespace __pstl;\n-    return __internal::__pattern_equal(\n+    return __pstl::__internal::__pattern_equal(\n         std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __p,\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1>(__exec),\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1>(__exec));\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1>(__exec),\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1>(__exec));\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>\n __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>\n equal(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)\n {\n-    return std::equal(std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2,\n-                      __pstl::__internal::__pstl_equal());\n+    return std::equal(std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, std::equal_to<>());\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\n __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>\n equal(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n       _ForwardIterator2 __last2, _BinaryPredicate __p)\n {\n-    using namespace __pstl;\n-    return __internal::__pattern_equal(\n+    return __pstl::__internal::__pattern_equal(\n         std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __last2, __p,\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1>(__exec),\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1>(__exec));\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1>(__exec),\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1>(__exec));\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>\n __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>\n equal(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n       _ForwardIterator2 __last2)\n {\n-    return std::equal(std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __last2,\n-                      __pstl::__internal::__pstl_equal());\n+    return equal(std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __last2, std::equal_to<>());\n }\n \n // [alg.move]\n template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>\n __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n move(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __d_first)\n {\n-    using namespace __pstl;\n     const auto __is_vector =\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec);\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(\n+            __exec);\n \n-    return __internal::__pattern_walk2_brick(\n+    return __pstl::__internal::__pattern_walk2_brick(\n         std::forward<_ExecutionPolicy>(__exec), __first, __last, __d_first,\n         [__is_vector](_ForwardIterator1 __begin, _ForwardIterator1 __end, _ForwardIterator2 __res) {\n-            return __internal::__brick_move(__begin, __end, __res, __is_vector);\n+            return __pstl::__internal::__brick_move(__begin, __end, __res, __is_vector);\n         },\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(\n+            __exec));\n }\n \n // [partial.sort]\n@@ -785,11 +771,10 @@ __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n partial_sort(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __middle,\n              _RandomAccessIterator __last, _Compare __comp)\n {\n-    using namespace __pstl;\n-    __internal::__pattern_partial_sort(\n+    __pstl::__internal::__pattern_partial_sort(\n         std::forward<_ExecutionPolicy>(__exec), __first, __middle, __last, __comp,\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _RandomAccessIterator>(__exec),\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _RandomAccessIterator>(__exec));\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _RandomAccessIterator>(__exec),\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _RandomAccessIterator>(__exec));\n }\n \n template <class _ExecutionPolicy, class _RandomAccessIterator>\n@@ -798,7 +783,7 @@ partial_sort(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAc\n              _RandomAccessIterator __last)\n {\n     typedef typename iterator_traits<_RandomAccessIterator>::value_type _InputType;\n-    std::partial_sort(std::forward<_ExecutionPolicy>(__exec), __first, __middle, __last, std::less<_InputType>());\n+    std::partial_sort(__exec, __first, __middle, __last, std::less<_InputType>());\n }\n \n // [partial.sort.copy]\n@@ -808,11 +793,12 @@ __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _RandomAccess\n partial_sort_copy(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last,\n                   _RandomAccessIterator __d_first, _RandomAccessIterator __d_last, _Compare __comp)\n {\n-    using namespace __pstl;\n-    return __internal::__pattern_partial_sort_copy(\n+    return __pstl::__internal::__pattern_partial_sort_copy(\n         std::forward<_ExecutionPolicy>(__exec), __first, __last, __d_first, __d_last, __comp,\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator, _RandomAccessIterator>(__exec),\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator, _RandomAccessIterator>(__exec));\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator, _RandomAccessIterator>(\n+            __exec),\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator, _RandomAccessIterator>(\n+            __exec));\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator, class _RandomAccessIterator>\n@@ -821,19 +807,19 @@ partial_sort_copy(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardI\n                   _RandomAccessIterator __d_first, _RandomAccessIterator __d_last)\n {\n     return std::partial_sort_copy(std::forward<_ExecutionPolicy>(__exec), __first, __last, __d_first, __d_last,\n-                                  __pstl::__internal::__pstl_less());\n+                                  std::less<>());\n }\n \n // [is.sorted]\n template <class _ExecutionPolicy, class _ForwardIterator, class _Compare>\n __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n is_sorted_until(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n {\n-    using namespace __pstl;\n-    const _ForwardIterator __res = __internal::__pattern_adjacent_find(\n+    const _ForwardIterator __res = __pstl::__internal::__pattern_adjacent_find(\n         std::forward<_ExecutionPolicy>(__exec), __first, __last, __pstl::__internal::__reorder_pred<_Compare>(__comp),\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec), /*first_semantic*/ false);\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+        /*first_semantic*/ false);\n     return __res == __last ? __last : std::next(__res);\n }\n \n@@ -849,11 +835,11 @@ template <class _ExecutionPolicy, class _ForwardIterator, class _Compare>\n __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>\n is_sorted(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n {\n-    using namespace __pstl;\n-    return __internal::__pattern_adjacent_find(\n-               std::forward<_ExecutionPolicy>(__exec), __first, __last, __internal::__reorder_pred<_Compare>(__comp),\n-               __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n-               __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+    return __pstl::__internal::__pattern_adjacent_find(\n+               std::forward<_ExecutionPolicy>(__exec), __first, __last,\n+               __pstl::__internal::__reorder_pred<_Compare>(__comp),\n+               __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+               __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n                /*or_semantic*/ true) == __last;\n }\n \n@@ -872,13 +858,12 @@ __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardItera\n merge(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n       _ForwardIterator2 __last2, _ForwardIterator __d_first, _Compare __comp)\n {\n-    using namespace __pstl;\n-    return __internal::__pattern_merge(\n+    return __pstl::__internal::__pattern_merge(\n         std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __last2, __d_first, __comp,\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2,\n-                                                 _ForwardIterator>(__exec),\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2,\n-                                                   _ForwardIterator>(__exec));\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2,\n+                                                         _ForwardIterator>(__exec),\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2,\n+                                                           _ForwardIterator>(__exec));\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator>\n@@ -887,19 +872,18 @@ merge(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 _\n       _ForwardIterator2 __last2, _ForwardIterator __d_first)\n {\n     return std::merge(std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __last2, __d_first,\n-                      __pstl::__internal::__pstl_less());\n+                      std::less<>());\n }\n \n template <class _ExecutionPolicy, class _BidirectionalIterator, class _Compare>\n __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n inplace_merge(_ExecutionPolicy&& __exec, _BidirectionalIterator __first, _BidirectionalIterator __middle,\n               _BidirectionalIterator __last, _Compare __comp)\n {\n-    using namespace __pstl;\n-    __internal::__pattern_inplace_merge(\n+    __pstl::__internal::__pattern_inplace_merge(\n         std::forward<_ExecutionPolicy>(__exec), __first, __middle, __last, __comp,\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _BidirectionalIterator>(__exec),\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _BidirectionalIterator>(__exec));\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _BidirectionalIterator>(__exec),\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _BidirectionalIterator>(__exec));\n }\n \n template <class _ExecutionPolicy, class _BidirectionalIterator>\n@@ -908,7 +892,7 @@ inplace_merge(_ExecutionPolicy&& __exec, _BidirectionalIterator __first, _Bidire\n               _BidirectionalIterator __last)\n {\n     typedef typename std::iterator_traits<_BidirectionalIterator>::value_type _InputType;\n-    std::inplace_merge(std::forward<_ExecutionPolicy>(__exec), __first, __middle, __last, std::less<_InputType>());\n+    std::inplace_merge(__exec, __first, __middle, __last, std::less<_InputType>());\n }\n \n // [includes]\n@@ -918,20 +902,20 @@ __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>\n includes(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n          _ForwardIterator2 __last2, _Compare __comp)\n {\n-    using namespace __pstl;\n-    return __internal::__pattern_includes(\n+    return __pstl::__internal::__pattern_includes(\n         std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __last2, __comp,\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(\n+            __exec),\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(\n+            __exec));\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>\n __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>\n includes(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n          _ForwardIterator2 __last2)\n {\n-    return std::includes(std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __last2,\n-                         __pstl::__internal::__pstl_less());\n+    return std::includes(std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __last2, std::less<>());\n }\n \n // [set.union]\n@@ -942,13 +926,12 @@ __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardItera\n set_union(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n           _ForwardIterator2 __last2, _ForwardIterator __result, _Compare __comp)\n {\n-    using namespace __pstl;\n-    return __internal::__pattern_set_union(\n+    return __pstl::__internal::__pattern_set_union(\n         std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __last2, __result, __comp,\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2,\n-                                                 _ForwardIterator>(__exec),\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2,\n-                                                   _ForwardIterator>(__exec));\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2,\n+                                                         _ForwardIterator>(__exec),\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2,\n+                                                           _ForwardIterator>(__exec));\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator>\n@@ -957,7 +940,7 @@ set_union(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterato\n           _ForwardIterator2 __last2, _ForwardIterator __result)\n {\n     return std::set_union(std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __last2, __result,\n-                          __pstl::__internal::__pstl_less());\n+                          std::less<>());\n }\n \n // [set.intersection]\n@@ -968,13 +951,12 @@ __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardItera\n set_intersection(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1,\n                  _ForwardIterator2 __first2, _ForwardIterator2 __last2, _ForwardIterator __result, _Compare __comp)\n {\n-    using namespace __pstl;\n-    return __internal::__pattern_set_intersection(\n+    return __pstl::__internal::__pattern_set_intersection(\n         std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __last2, __result, __comp,\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2,\n-                                                 _ForwardIterator>(__exec),\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2,\n-                                                   _ForwardIterator>(__exec));\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2,\n+                                                         _ForwardIterator>(__exec),\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2,\n+                                                           _ForwardIterator>(__exec));\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator>\n@@ -983,7 +965,7 @@ set_intersection(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _Forward\n                  _ForwardIterator2 __first2, _ForwardIterator2 __last2, _ForwardIterator __result)\n {\n     return std::set_intersection(std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __last2, __result,\n-                                 __pstl::__internal::__pstl_less());\n+                                 std::less<>());\n }\n \n // [set.difference]\n@@ -994,13 +976,12 @@ __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardItera\n set_difference(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1,\n                _ForwardIterator2 __first2, _ForwardIterator2 __last2, _ForwardIterator __result, _Compare __comp)\n {\n-    using namespace __pstl;\n-    return __internal::__pattern_set_difference(\n+    return __pstl::__internal::__pattern_set_difference(\n         std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __last2, __result, __comp,\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2,\n-                                                 _ForwardIterator>(__exec),\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2,\n-                                                   _ForwardIterator>(__exec));\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2,\n+                                                         _ForwardIterator>(__exec),\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2,\n+                                                           _ForwardIterator>(__exec));\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator>\n@@ -1009,7 +990,7 @@ set_difference(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIt\n                _ForwardIterator2 __first2, _ForwardIterator2 __last2, _ForwardIterator __result)\n {\n     return std::set_difference(std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __last2, __result,\n-                               __pstl::__internal::__pstl_less());\n+                               std::less<>());\n }\n \n // [set.symmetric.difference]\n@@ -1021,13 +1002,12 @@ set_symmetric_difference(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1,\n                          _ForwardIterator2 __first2, _ForwardIterator2 __last2, _ForwardIterator __result,\n                          _Compare __comp)\n {\n-    using namespace __pstl;\n-    return __internal::__pattern_set_symmetric_difference(\n+    return __pstl::__internal::__pattern_set_symmetric_difference(\n         std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __last2, __result, __comp,\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2,\n-                                                 _ForwardIterator>(__exec),\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2,\n-                                                   _ForwardIterator>(__exec));\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2,\n+                                                         _ForwardIterator>(__exec),\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2,\n+                                                           _ForwardIterator>(__exec));\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator>\n@@ -1036,19 +1016,18 @@ set_symmetric_difference(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1,\n                          _ForwardIterator2 __first2, _ForwardIterator2 __last2, _ForwardIterator __result)\n {\n     return std::set_symmetric_difference(std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __last2,\n-                                         __result, __pstl::__internal::__pstl_less());\n+                                         __result, std::less<>());\n }\n \n // [is.heap]\n template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare>\n __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _RandomAccessIterator>\n is_heap_until(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n {\n-    using namespace __pstl;\n-    return __internal::__pattern_is_heap_until(\n+    return __pstl::__internal::__pattern_is_heap_until(\n         std::forward<_ExecutionPolicy>(__exec), __first, __last, __comp,\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _RandomAccessIterator>(__exec),\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _RandomAccessIterator>(__exec));\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _RandomAccessIterator>(__exec),\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _RandomAccessIterator>(__exec));\n }\n \n template <class _ExecutionPolicy, class _RandomAccessIterator>\n@@ -1080,11 +1059,10 @@ template <class _ExecutionPolicy, class _ForwardIterator, class _Compare>\n __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n min_element(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n {\n-    using namespace __pstl;\n-    return __internal::__pattern_min_element(\n+    return __pstl::__internal::__pattern_min_element(\n         std::forward<_ExecutionPolicy>(__exec), __first, __last, __comp,\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator>\n@@ -1116,11 +1094,10 @@ template <class _ExecutionPolicy, class _ForwardIterator, class _Compare>\n __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, std::pair<_ForwardIterator, _ForwardIterator>>\n minmax_element(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n {\n-    using namespace __pstl;\n-    return __internal::__pattern_minmax_element(\n+    return __pstl::__internal::__pattern_minmax_element(\n         std::forward<_ExecutionPolicy>(__exec), __first, __last, __comp,\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator>\n@@ -1138,11 +1115,10 @@ __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n nth_element(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __nth,\n             _RandomAccessIterator __last, _Compare __comp)\n {\n-    using namespace __pstl;\n-    __internal::__pattern_nth_element(\n+    __pstl::__internal::__pattern_nth_element(\n         std::forward<_ExecutionPolicy>(__exec), __first, __nth, __last, __comp,\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _RandomAccessIterator>(__exec),\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _RandomAccessIterator>(__exec));\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _RandomAccessIterator>(__exec),\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _RandomAccessIterator>(__exec));\n }\n \n template <class _ExecutionPolicy, class _RandomAccessIterator>\n@@ -1161,11 +1137,12 @@ __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>\n lexicographical_compare(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1,\n                         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _Compare __comp)\n {\n-    using namespace __pstl;\n-    return __internal::__pattern_lexicographical_compare(\n+    return __pstl::__internal::__pattern_lexicographical_compare(\n         std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __last2, __comp,\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(\n+            __exec),\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(\n+            __exec));\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>\n@@ -1174,7 +1151,7 @@ lexicographical_compare(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _\n                         _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n {\n     return std::lexicographical_compare(std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __last2,\n-                                        __pstl::__internal::__pstl_less());\n+                                        std::less<>());\n }\n \n } // namespace std"}, {"sha": "ea462e9ccddcf3a35ce949112946cfcda5419ec9", "filename": "libstdc++-v3/include/pstl/glue_memory_impl.h", "status": "modified", "additions": 136, "deletions": 128, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e957b86ca26f9a4e49acf625ed397e7dd05b0d66/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fglue_memory_impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e957b86ca26f9a4e49acf625ed397e7dd05b0d66/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fglue_memory_impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fglue_memory_impl.h?ref=e957b86ca26f9a4e49acf625ed397e7dd05b0d66", "patch": "@@ -26,29 +26,29 @@ uninitialized_copy(_ExecutionPolicy&& __exec, _InputIterator __first, _InputIter\n     typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType2;\n     typedef typename iterator_traits<_InputIterator>::reference _ReferenceType1;\n     typedef typename iterator_traits<_ForwardIterator>::reference _ReferenceType2;\n-    using namespace __pstl;\n \n     const auto __is_parallel =\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _InputIterator, _ForwardIterator>(__exec);\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _InputIterator, _ForwardIterator>(__exec);\n     const auto __is_vector =\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _InputIterator, _ForwardIterator>(__exec);\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _InputIterator, _ForwardIterator>(__exec);\n \n-    return __internal::__invoke_if_else(\n+    return __pstl::__internal::__invoke_if_else(\n         std::integral_constant < bool, std::is_trivial<_ValueType1>::value&& std::is_trivial<_ValueType2>::value > (),\n         [&]() {\n-            return __internal::__pattern_walk2_brick(\n+            return __pstl::__internal::__pattern_walk2_brick(\n                 std::forward<_ExecutionPolicy>(__exec), __first, __last, __result,\n                 [__is_vector](_InputIterator __begin, _InputIterator __end, _ForwardIterator __res) {\n-                    return __internal::__brick_copy(__begin, __end, __res, __is_vector);\n+                    return __pstl::__internal::__brick_copy(__begin, __end, __res, __is_vector);\n                 },\n                 __is_parallel);\n         },\n         [&]() {\n-            return __internal::__pattern_walk2(std::forward<_ExecutionPolicy>(__exec), __first, __last, __result,\n-                                               [](_ReferenceType1 __val1, _ReferenceType2 __val2) {\n-                                                   ::new (std::addressof(__val2)) _ValueType2(__val1);\n-                                               },\n-                                               __is_vector, __is_parallel);\n+            return __pstl::__internal::__pattern_walk2(std::forward<_ExecutionPolicy>(__exec), __first, __last,\n+                                                       __result,\n+                                                       [](_ReferenceType1 __val1, _ReferenceType2 __val2) {\n+                                                           ::new (std::addressof(__val2)) _ValueType2(__val1);\n+                                                       },\n+                                                       __is_vector, __is_parallel);\n         });\n }\n \n@@ -60,29 +60,28 @@ uninitialized_copy_n(_ExecutionPolicy&& __exec, _InputIterator __first, _Size __\n     typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType2;\n     typedef typename iterator_traits<_InputIterator>::reference _ReferenceType1;\n     typedef typename iterator_traits<_ForwardIterator>::reference _ReferenceType2;\n-    using namespace __pstl;\n \n     const auto __is_parallel =\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _InputIterator, _ForwardIterator>(__exec);\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _InputIterator, _ForwardIterator>(__exec);\n     const auto __is_vector =\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _InputIterator, _ForwardIterator>(__exec);\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _InputIterator, _ForwardIterator>(__exec);\n \n-    return __internal::__invoke_if_else(\n+    return __pstl::__internal::__invoke_if_else(\n         std::integral_constant < bool, std::is_trivial<_ValueType1>::value&& std::is_trivial<_ValueType2>::value > (),\n         [&]() {\n-            return __internal::__pattern_walk2_brick_n(\n+            return __pstl::__internal::__pattern_walk2_brick_n(\n                 std::forward<_ExecutionPolicy>(__exec), __first, __n, __result,\n                 [__is_vector](_InputIterator __begin, _Size __sz, _ForwardIterator __res) {\n-                    return __internal::__brick_copy_n(__begin, __sz, __res, __is_vector);\n+                    return __pstl::__internal::__brick_copy_n(__begin, __sz, __res, __is_vector);\n                 },\n                 __is_parallel);\n         },\n         [&]() {\n-            return __internal::__pattern_walk2_n(std::forward<_ExecutionPolicy>(__exec), __first, __n, __result,\n-                                                 [](_ReferenceType1 __val1, _ReferenceType2 __val2) {\n-                                                     ::new (std::addressof(__val2)) _ValueType2(__val1);\n-                                                 },\n-                                                 __is_vector, __is_parallel);\n+            return __pstl::__internal::__pattern_walk2_n(std::forward<_ExecutionPolicy>(__exec), __first, __n, __result,\n+                                                         [](_ReferenceType1 __val1, _ReferenceType2 __val2) {\n+                                                             ::new (std::addressof(__val2)) _ValueType2(__val1);\n+                                                         },\n+                                                         __is_vector, __is_parallel);\n         });\n }\n \n@@ -96,29 +95,29 @@ uninitialized_move(_ExecutionPolicy&& __exec, _InputIterator __first, _InputIter\n     typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType2;\n     typedef typename iterator_traits<_InputIterator>::reference _ReferenceType1;\n     typedef typename iterator_traits<_ForwardIterator>::reference _ReferenceType2;\n-    using namespace __pstl;\n \n     const auto __is_parallel =\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _InputIterator, _ForwardIterator>(__exec);\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _InputIterator, _ForwardIterator>(__exec);\n     const auto __is_vector =\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _InputIterator, _ForwardIterator>(__exec);\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _InputIterator, _ForwardIterator>(__exec);\n \n-    return __internal::__invoke_if_else(\n+    return __pstl::__internal::__invoke_if_else(\n         std::integral_constant < bool, std::is_trivial<_ValueType1>::value&& std::is_trivial<_ValueType2>::value > (),\n         [&]() {\n-            return __internal::__pattern_walk2_brick(\n+            return __pstl::__internal::__pattern_walk2_brick(\n                 std::forward<_ExecutionPolicy>(__exec), __first, __last, __result,\n                 [__is_vector](_InputIterator __begin, _InputIterator __end, _ForwardIterator __res) {\n-                    return __internal::__brick_copy(__begin, __end, __res, __is_vector);\n+                    return __pstl::__internal::__brick_copy(__begin, __end, __res, __is_vector);\n                 },\n                 __is_parallel);\n         },\n         [&]() {\n-            return __internal::__pattern_walk2(std::forward<_ExecutionPolicy>(__exec), __first, __last, __result,\n-                                               [](_ReferenceType1 __val1, _ReferenceType2 __val2) {\n-                                                   ::new (std::addressof(__val2)) _ValueType2(std::move(__val1));\n-                                               },\n-                                               __is_vector, __is_parallel);\n+            return __pstl::__internal::__pattern_walk2(\n+                std::forward<_ExecutionPolicy>(__exec), __first, __last, __result,\n+                [](_ReferenceType1 __val1, _ReferenceType2 __val2) {\n+                    ::new (std::addressof(__val2)) _ValueType2(std::move(__val1));\n+                },\n+                __is_vector, __is_parallel);\n         });\n }\n \n@@ -130,29 +129,29 @@ uninitialized_move_n(_ExecutionPolicy&& __exec, _InputIterator __first, _Size __\n     typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType2;\n     typedef typename iterator_traits<_InputIterator>::reference _ReferenceType1;\n     typedef typename iterator_traits<_ForwardIterator>::reference _ReferenceType2;\n-    using namespace __pstl;\n \n     const auto __is_parallel =\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _InputIterator, _ForwardIterator>(__exec);\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _InputIterator, _ForwardIterator>(__exec);\n     const auto __is_vector =\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _InputIterator, _ForwardIterator>(__exec);\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _InputIterator, _ForwardIterator>(__exec);\n \n-    return __internal::__invoke_if_else(\n+    return __pstl::__internal::__invoke_if_else(\n         std::integral_constant < bool, std::is_trivial<_ValueType1>::value&& std::is_trivial<_ValueType2>::value > (),\n         [&]() {\n-            return __internal::__pattern_walk2_brick_n(\n+            return __pstl::__internal::__pattern_walk2_brick_n(\n                 std::forward<_ExecutionPolicy>(__exec), __first, __n, __result,\n                 [__is_vector](_InputIterator __begin, _Size __sz, _ForwardIterator __res) {\n-                    return __internal::__brick_copy_n(__begin, __sz, __res, __is_vector);\n+                    return __pstl::__internal::__brick_copy_n(__begin, __sz, __res, __is_vector);\n                 },\n                 __is_parallel);\n         },\n         [&]() {\n-            return __internal::__pattern_walk2_n(std::forward<_ExecutionPolicy>(__exec), __first, __n, __result,\n-                                                 [](_ReferenceType1 __val1, _ReferenceType2 __val2) {\n-                                                     ::new (std::addressof(__val2)) _ValueType2(std::move(__val1));\n-                                                 },\n-                                                 __is_vector, __is_parallel);\n+            return __pstl::__internal::__pattern_walk2_n(std::forward<_ExecutionPolicy>(__exec), __first, __n, __result,\n+                                                         [](_ReferenceType1 __val1, _ReferenceType2 __val2) {\n+                                                             ::new (std::addressof(__val2))\n+                                                                 _ValueType2(std::move(__val1));\n+                                                         },\n+                                                         __is_vector, __is_parallel);\n         });\n }\n \n@@ -164,28 +163,28 @@ uninitialized_fill(_ExecutionPolicy&& __exec, _ForwardIterator __first, _Forward\n {\n     typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;\n     typedef typename iterator_traits<_ForwardIterator>::reference _ReferenceType;\n-    using namespace __pstl;\n-\n-    const auto __is_parallel = __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec);\n-    const auto __is_vector = __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec);\n-\n-    __internal::__invoke_if_else(std::is_arithmetic<_ValueType>(),\n-                                 [&]() {\n-                                     __internal::__pattern_walk_brick(\n-                                         std::forward<_ExecutionPolicy>(__exec), __first, __last,\n-                                         [&__value, &__is_vector](_ForwardIterator __begin, _ForwardIterator __end) {\n-                                             __internal::__brick_fill(__begin, __end, _ValueType(__value), __is_vector);\n-                                         },\n-                                         __is_parallel);\n-                                 },\n-                                 [&]() {\n-                                     __internal::__pattern_walk1(std::forward<_ExecutionPolicy>(__exec), __first,\n-                                                                 __last,\n-                                                                 [&__value](_ReferenceType __val) {\n-                                                                     ::new (std::addressof(__val)) _ValueType(__value);\n-                                                                 },\n-                                                                 __is_vector, __is_parallel);\n-                                 });\n+\n+    const auto __is_parallel =\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec);\n+    const auto __is_vector =\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec);\n+\n+    __pstl::__internal::__invoke_if_else(\n+        std::is_arithmetic<_ValueType>(),\n+        [&]() {\n+            __pstl::__internal::__pattern_walk_brick(\n+                std::forward<_ExecutionPolicy>(__exec), __first, __last,\n+                [&__value, &__is_vector](_ForwardIterator __begin, _ForwardIterator __end) {\n+                    __pstl::__internal::__brick_fill(__begin, __end, _ValueType(__value), __is_vector);\n+                },\n+                __is_parallel);\n+        },\n+        [&]() {\n+            __pstl::__internal::__pattern_walk1(\n+                std::forward<_ExecutionPolicy>(__exec), __first, __last,\n+                [&__value](_ReferenceType __val) { ::new (std::addressof(__val)) _ValueType(__value); }, __is_vector,\n+                __is_parallel);\n+        });\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator, class _Size, class _Tp>\n@@ -194,23 +193,24 @@ uninitialized_fill_n(_ExecutionPolicy&& __exec, _ForwardIterator __first, _Size\n {\n     typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;\n     typedef typename iterator_traits<_ForwardIterator>::reference _ReferenceType;\n-    using namespace __pstl;\n \n-    const auto __is_parallel = __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec);\n-    const auto __is_vector = __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec);\n+    const auto __is_parallel =\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec);\n+    const auto __is_vector =\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec);\n \n-    return __internal::__invoke_if_else(\n+    return __pstl::__internal::__invoke_if_else(\n         std::is_arithmetic<_ValueType>(),\n         [&]() {\n-            return __internal::__pattern_walk_brick_n(\n+            return __pstl::__internal::__pattern_walk_brick_n(\n                 std::forward<_ExecutionPolicy>(__exec), __first, __n,\n                 [&__value, &__is_vector](_ForwardIterator __begin, _Size __count) {\n-                    return __internal::__brick_fill_n(__begin, __count, _ValueType(__value), __is_vector);\n+                    return __pstl::__internal::__brick_fill_n(__begin, __count, _ValueType(__value), __is_vector);\n                 },\n                 __is_parallel);\n         },\n         [&]() {\n-            return __internal::__pattern_walk1_n(\n+            return __pstl::__internal::__pattern_walk1_n(\n                 std::forward<_ExecutionPolicy>(__exec), __first, __n,\n                 [&__value](_ReferenceType __val) { ::new (std::addressof(__val)) _ValueType(__value); }, __is_vector,\n                 __is_parallel);\n@@ -225,14 +225,16 @@ destroy(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __\n {\n     typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;\n     typedef typename iterator_traits<_ForwardIterator>::reference _ReferenceType;\n-    using namespace __pstl;\n \n-    const auto __is_parallel = __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec);\n-    const auto __is_vector = __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec);\n+    const auto __is_parallel =\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec);\n+    const auto __is_vector =\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec);\n \n-    __internal::__invoke_if_not(std::is_trivially_destructible<_ValueType>(), [&]() {\n-        __internal::__pattern_walk1(std::forward<_ExecutionPolicy>(__exec), __first, __last,\n-                                    [](_ReferenceType __val) { __val.~_ValueType(); }, __is_vector, __is_parallel);\n+    __pstl::__internal::__invoke_if_not(std::is_trivially_destructible<_ValueType>(), [&]() {\n+        __pstl::__internal::__pattern_walk1(std::forward<_ExecutionPolicy>(__exec), __first, __last,\n+                                            [](_ReferenceType __val) { __val.~_ValueType(); }, __is_vector,\n+                                            __is_parallel);\n     });\n }\n \n@@ -242,17 +244,18 @@ destroy_n(_ExecutionPolicy&& __exec, _ForwardIterator __first, _Size __n)\n {\n     typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;\n     typedef typename iterator_traits<_ForwardIterator>::reference _ReferenceType;\n-    using namespace __pstl;\n \n-    const auto __is_parallel = __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec);\n-    const auto __is_vector = __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec);\n+    const auto __is_parallel =\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec);\n+    const auto __is_vector =\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec);\n \n-    return __internal::__invoke_if_else(\n+    return __pstl::__internal::__invoke_if_else(\n         std::is_trivially_destructible<_ValueType>(), [&]() { return std::next(__first, __n); },\n         [&]() {\n-            return __internal::__pattern_walk1_n(std::forward<_ExecutionPolicy>(__exec), __first, __n,\n-                                                 [](_ReferenceType __val) { __val.~_ValueType(); }, __is_vector,\n-                                                 __is_parallel);\n+            return __pstl::__internal::__pattern_walk1_n(std::forward<_ExecutionPolicy>(__exec), __first, __n,\n+                                                         [](_ReferenceType __val) { __val.~_ValueType(); }, __is_vector,\n+                                                         __is_parallel);\n         });\n }\n \n@@ -264,15 +267,16 @@ uninitialized_default_construct(_ExecutionPolicy&& __exec, _ForwardIterator __fi\n {\n     typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;\n     typedef typename iterator_traits<_ForwardIterator>::reference _ReferenceType;\n-    using namespace __pstl;\n \n-    const auto __is_parallel = __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec);\n-    const auto __is_vector = __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec);\n+    const auto __is_parallel =\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec);\n+    const auto __is_vector =\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec);\n \n-    __internal::__invoke_if_not(std::is_trivial<_ValueType>(), [&]() {\n-        __internal::__pattern_walk1(std::forward<_ExecutionPolicy>(__exec), __first, __last,\n-                                    [](_ReferenceType __val) { ::new (std::addressof(__val)) _ValueType; }, __is_vector,\n-                                    __is_parallel);\n+    __pstl::__internal::__invoke_if_not(std::is_trivial<_ValueType>(), [&]() {\n+        __pstl::__internal::__pattern_walk1(std::forward<_ExecutionPolicy>(__exec), __first, __last,\n+                                            [](_ReferenceType __val) { ::new (std::addressof(__val)) _ValueType; },\n+                                            __is_vector, __is_parallel);\n     });\n }\n \n@@ -282,18 +286,19 @@ uninitialized_default_construct_n(_ExecutionPolicy&& __exec, _ForwardIterator __\n {\n     typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;\n     typedef typename iterator_traits<_ForwardIterator>::reference _ReferenceType;\n-    using namespace __pstl;\n-\n-    const auto __is_parallel = __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec);\n-    const auto __is_vector = __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec);\n-\n-    return __internal::__invoke_if_else(std::is_trivial<_ValueType>(), [&]() { return std::next(__first, __n); },\n-                                        [&]() {\n-                                            return __internal::__pattern_walk1_n(\n-                                                std::forward<_ExecutionPolicy>(__exec), __first, __n,\n-                                                [](_ReferenceType __val) { ::new (std::addressof(__val)) _ValueType; },\n-                                                __is_vector, __is_parallel);\n-                                        });\n+\n+    const auto __is_parallel =\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec);\n+    const auto __is_vector =\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec);\n+\n+    return __pstl::__internal::__invoke_if_else(\n+        std::is_trivial<_ValueType>(), [&]() { return std::next(__first, __n); },\n+        [&]() {\n+            return __pstl::__internal::__pattern_walk1_n(\n+                std::forward<_ExecutionPolicy>(__exec), __first, __n,\n+                [](_ReferenceType __val) { ::new (std::addressof(__val)) _ValueType; }, __is_vector, __is_parallel);\n+        });\n }\n \n // [uninitialized.construct.value]\n@@ -304,24 +309,26 @@ uninitialized_value_construct(_ExecutionPolicy&& __exec, _ForwardIterator __firs\n {\n     typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;\n     typedef typename iterator_traits<_ForwardIterator>::reference _ReferenceType;\n-    using namespace __pstl;\n \n-    const auto __is_parallel = __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec);\n-    const auto __is_vector = __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec);\n+    const auto __is_parallel =\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec);\n+    const auto __is_vector =\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec);\n \n-    __internal::__invoke_if_else(\n+    __pstl::__internal::__invoke_if_else(\n         std::is_trivial<_ValueType>(),\n         [&]() {\n-            __internal::__pattern_walk_brick(std::forward<_ExecutionPolicy>(__exec), __first, __last,\n-                                             [__is_vector](_ForwardIterator __begin, _ForwardIterator __end) {\n-                                                 __internal::__brick_fill(__begin, __end, _ValueType(), __is_vector);\n-                                             },\n-                                             __is_parallel);\n+            __pstl::__internal::__pattern_walk_brick(std::forward<_ExecutionPolicy>(__exec), __first, __last,\n+                                                     [__is_vector](_ForwardIterator __begin, _ForwardIterator __end) {\n+                                                         __pstl::__internal::__brick_fill(__begin, __end, _ValueType(),\n+                                                                                          __is_vector);\n+                                                     },\n+                                                     __is_parallel);\n         },\n         [&]() {\n-            __internal::__pattern_walk1(std::forward<_ExecutionPolicy>(__exec), __first, __last,\n-                                        [](_ReferenceType __val) { ::new (std::addressof(__val)) _ValueType(); },\n-                                        __is_vector, __is_parallel);\n+            __pstl::__internal::__pattern_walk1(\n+                std::forward<_ExecutionPolicy>(__exec), __first, __last,\n+                [](_ReferenceType __val) { ::new (std::addressof(__val)) _ValueType(); }, __is_vector, __is_parallel);\n         });\n }\n \n@@ -331,23 +338,24 @@ uninitialized_value_construct_n(_ExecutionPolicy&& __exec, _ForwardIterator __fi\n {\n     typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;\n     typedef typename iterator_traits<_ForwardIterator>::reference _ReferenceType;\n-    using namespace __pstl;\n \n-    const auto __is_parallel = __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec);\n-    const auto __is_vector = __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec);\n+    const auto __is_parallel =\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec);\n+    const auto __is_vector =\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec);\n \n-    return __internal::__invoke_if_else(\n+    return __pstl::__internal::__invoke_if_else(\n         std::is_trivial<_ValueType>(),\n         [&]() {\n-            return __internal::__pattern_walk_brick_n(std::forward<_ExecutionPolicy>(__exec), __first, __n,\n-                                                      [__is_vector](_ForwardIterator __begin, _Size __count) {\n-                                                          return __internal::__brick_fill_n(__begin, __count,\n-                                                                                            _ValueType(), __is_vector);\n-                                                      },\n-                                                      __is_parallel);\n+            return __pstl::__internal::__pattern_walk_brick_n(std::forward<_ExecutionPolicy>(__exec), __first, __n,\n+                                                              [__is_vector](_ForwardIterator __begin, _Size __count) {\n+                                                                  return __pstl::__internal::__brick_fill_n(\n+                                                                      __begin, __count, _ValueType(), __is_vector);\n+                                                              },\n+                                                              __is_parallel);\n         },\n         [&]() {\n-            return __internal::__pattern_walk1_n(\n+            return __pstl::__internal::__pattern_walk1_n(\n                 std::forward<_ExecutionPolicy>(__exec), __first, __n,\n                 [](_ReferenceType __val) { ::new (std::addressof(__val)) _ValueType(); }, __is_vector, __is_parallel);\n         });"}, {"sha": "9db64b513a47e1d9a58c298d229f121dcd6e81b2", "filename": "libstdc++-v3/include/pstl/glue_numeric_impl.h", "status": "modified", "additions": 40, "deletions": 28, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e957b86ca26f9a4e49acf625ed397e7dd05b0d66/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fglue_numeric_impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e957b86ca26f9a4e49acf625ed397e7dd05b0d66/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fglue_numeric_impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fglue_numeric_impl.h?ref=e957b86ca26f9a4e49acf625ed397e7dd05b0d66", "patch": "@@ -55,12 +55,13 @@ transform_reduce(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _Forward\n                  _ForwardIterator2 __first2, _Tp __init)\n {\n     typedef typename iterator_traits<_ForwardIterator1>::value_type _InputType;\n-    using namespace __pstl;\n-    return __internal::__pattern_transform_reduce(\n+    return __pstl::__internal::__pattern_transform_reduce(\n         std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __init, std::plus<_InputType>(),\n         std::multiplies<_InputType>(),\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(\n+            __exec),\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(\n+            __exec));\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Tp, class _BinaryOperation1,\n@@ -69,23 +70,23 @@ __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _Tp>\n transform_reduce(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1,\n                  _ForwardIterator2 __first2, _Tp __init, _BinaryOperation1 __binary_op1, _BinaryOperation2 __binary_op2)\n {\n-    using namespace __pstl;\n-    return __internal::__pattern_transform_reduce(\n+    return __pstl::__internal::__pattern_transform_reduce(\n         std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __init, __binary_op1, __binary_op2,\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(\n+            __exec),\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(\n+            __exec));\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator, class _Tp, class _BinaryOperation, class _UnaryOperation>\n __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _Tp>\n transform_reduce(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Tp __init,\n                  _BinaryOperation __binary_op, _UnaryOperation __unary_op)\n {\n-    using namespace __pstl;\n-    return __internal::__pattern_transform_reduce(\n+    return __pstl::__internal::__pattern_transform_reduce(\n         std::forward<_ExecutionPolicy>(__exec), __first, __last, __init, __binary_op, __unary_op,\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n }\n \n // [exclusive.scan]\n@@ -95,17 +96,25 @@ __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardItera\n exclusive_scan(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last,\n                _ForwardIterator2 __result, _Tp __init)\n {\n-    return transform_exclusive_scan(std::forward<_ExecutionPolicy>(__exec), __first, __last, __result, __init,\n-                                    std::plus<_Tp>(), __pstl::__internal::__no_op());\n+    using namespace __pstl;\n+    return __internal::__pattern_transform_scan(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __last, __result, __pstl::__internal::__no_op(), __init,\n+        std::plus<_Tp>(), /*inclusive=*/std::false_type(),\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Tp, class _BinaryOperation>\n __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n exclusive_scan(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last,\n                _ForwardIterator2 __result, _Tp __init, _BinaryOperation __binary_op)\n {\n-    return transform_exclusive_scan(std::forward<_ExecutionPolicy>(__exec), __first, __last, __result, __init,\n-                                    __binary_op, __pstl::__internal::__no_op());\n+    using namespace __pstl;\n+    return __internal::__pattern_transform_scan(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __last, __result, __pstl::__internal::__no_op(), __init,\n+        __binary_op, /*inclusive=*/std::false_type(),\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));\n }\n \n // [inclusive.scan]\n@@ -147,12 +156,13 @@ transform_exclusive_scan(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _\n                          _ForwardIterator2 __result, _Tp __init, _BinaryOperation __binary_op,\n                          _UnaryOperation __unary_op)\n {\n-    using namespace __pstl;\n-    return __internal::__pattern_transform_scan(\n+    return __pstl::__internal::__pattern_transform_scan(\n         std::forward<_ExecutionPolicy>(__exec), __first, __last, __result, __unary_op, __init, __binary_op,\n         /*inclusive=*/std::false_type(),\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(\n+            __exec),\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(\n+            __exec));\n }\n \n // [transform.inclusive.scan]\n@@ -164,12 +174,13 @@ transform_inclusive_scan(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _\n                          _ForwardIterator2 __result, _BinaryOperation __binary_op, _UnaryOperation __unary_op,\n                          _Tp __init)\n {\n-    using namespace __pstl;\n-    return __internal::__pattern_transform_scan(\n+    return __pstl::__internal::__pattern_transform_scan(\n         std::forward<_ExecutionPolicy>(__exec), __first, __last, __result, __unary_op, __init, __binary_op,\n         /*inclusive=*/std::true_type(),\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(\n+            __exec),\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(\n+            __exec));\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _UnaryOperation,\n@@ -202,11 +213,12 @@ adjacent_difference(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _Forwa\n     if (__first == __last)\n         return __d_first;\n \n-    using namespace __pstl;\n-    return __internal::__pattern_adjacent_difference(\n+    return __pstl::__internal::__pattern_adjacent_difference(\n         std::forward<_ExecutionPolicy>(__exec), __first, __last, __d_first, __op,\n-        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),\n-        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));\n+        __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(\n+            __exec),\n+        __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(\n+            __exec));\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>"}, {"sha": "be5a103f93bf984a3db6e720b2d0633cbdf9114b", "filename": "libstdc++-v3/include/pstl/memory_impl.h", "status": "modified", "additions": 59, "deletions": 8, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e957b86ca26f9a4e49acf625ed397e7dd05b0d66/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fmemory_impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e957b86ca26f9a4e49acf625ed397e7dd05b0d66/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fmemory_impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fmemory_impl.h?ref=e957b86ca26f9a4e49acf625ed397e7dd05b0d66", "patch": "@@ -23,31 +23,82 @@ namespace __internal\n // uninitialized_move\n //------------------------------------------------------------------------\n \n-template <class _ForwardIterator, class _OutputIterator>\n+template <typename _ForwardIterator, typename _OutputIterator>\n _OutputIterator\n __brick_uninitialized_move(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result,\n                            /*vector=*/std::false_type) noexcept\n {\n-    typedef typename std::iterator_traits<_OutputIterator>::value_type _ValueType2;\n+    using _ValueType = typename std::iterator_traits<_OutputIterator>::value_type;\n     for (; __first != __last; ++__first, ++__result)\n     {\n-        ::new (std::addressof(*__result)) _ValueType2(std::move(*__first));\n+        ::new (std::addressof(*__result)) _ValueType(std::move(*__first));\n     }\n     return __result;\n }\n \n-template <class _ForwardIterator, class _OutputIterator>\n+template <typename _ForwardIterator, typename _OutputIterator>\n _OutputIterator\n __brick_uninitialized_move(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result,\n                            /*vector=*/std::true_type) noexcept\n {\n-    typedef typename std::iterator_traits<_OutputIterator>::value_type __ValueType2;\n-    typedef typename std::iterator_traits<_ForwardIterator>::reference _ReferenceType1;\n-    typedef typename std::iterator_traits<_OutputIterator>::reference _ReferenceType2;\n+    using __ValueType = typename std::iterator_traits<_OutputIterator>::value_type;\n+    using _ReferenceType1 = typename std::iterator_traits<_ForwardIterator>::reference;\n+    using _ReferenceType2 = typename std::iterator_traits<_OutputIterator>::reference;\n \n     return __unseq_backend::__simd_walk_2(\n         __first, __last - __first, __result,\n-        [](_ReferenceType1 __x, _ReferenceType2 __y) { ::new (std::addressof(__y)) __ValueType2(std::move(__x)); });\n+        [](_ReferenceType1 __x, _ReferenceType2 __y) { ::new (std::addressof(__y)) __ValueType(std::move(__x)); });\n+}\n+\n+template <typename _Iterator>\n+void\n+__brick_destroy(_Iterator __first, _Iterator __last, /*vector*/ std::false_type) noexcept\n+{\n+    using _ValueType = typename std::iterator_traits<_Iterator>::value_type;\n+\n+    for (; __first != __last; ++__first)\n+        __first->~_ValueType();\n+}\n+\n+template <typename _Iterator>\n+void\n+__brick_destroy(_Iterator __first, _Iterator __last, /*vector*/ std::true_type) noexcept\n+{\n+    using _ValueType = typename std::iterator_traits<_Iterator>::value_type;\n+    using _ReferenceType = typename std::iterator_traits<_Iterator>::reference;\n+\n+    __unseq_backend::__simd_walk_1(__first, __last - __first, [](_ReferenceType __x) { __x.~_ValueType(); });\n+}\n+\n+//------------------------------------------------------------------------\n+// uninitialized copy\n+//------------------------------------------------------------------------\n+\n+template <typename _ForwardIterator, typename _OutputIterator>\n+_OutputIterator\n+__brick_uninitialized_copy(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result,\n+                           /*vector=*/std::false_type) noexcept\n+{\n+    using _ValueType = typename std::iterator_traits<_OutputIterator>::value_type;\n+    for (; __first != __last; ++__first, ++__result)\n+    {\n+        ::new (std::addressof(*__result)) _ValueType(*__first);\n+    }\n+    return __result;\n+}\n+\n+template <typename _ForwardIterator, typename _OutputIterator>\n+_OutputIterator\n+__brick_uninitialized_copy(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result,\n+                           /*vector=*/std::true_type) noexcept\n+{\n+    using __ValueType = typename std::iterator_traits<_OutputIterator>::value_type;\n+    using _ReferenceType1 = typename std::iterator_traits<_ForwardIterator>::reference;\n+    using _ReferenceType2 = typename std::iterator_traits<_OutputIterator>::reference;\n+\n+    return __unseq_backend::__simd_walk_2(\n+        __first, __last - __first, __result,\n+        [](_ReferenceType1 __x, _ReferenceType2 __y) { ::new (std::addressof(__y)) __ValueType(__x); });\n }\n \n } // namespace __internal"}, {"sha": "75d96411b3d0f92da2cf27dddfa8ec03012ec583", "filename": "libstdc++-v3/include/pstl/numeric_impl.h", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e957b86ca26f9a4e49acf625ed397e7dd05b0d66/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fnumeric_impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e957b86ca26f9a4e49acf625ed397e7dd05b0d66/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fnumeric_impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fnumeric_impl.h?ref=e957b86ca26f9a4e49acf625ed397e7dd05b0d66", "patch": "@@ -93,11 +93,7 @@ _Tp\n __brick_transform_reduce(_ForwardIterator __first, _ForwardIterator __last, _Tp __init, _BinaryOperation __binary_op,\n                          _UnaryOperation __unary_op, /*is_vector=*/std::false_type) noexcept\n {\n-    for (; __first != __last; ++__first)\n-    {\n-        __init = __binary_op(__init, __unary_op(*__first));\n-    }\n-    return __init;\n+    return std::transform_reduce(__first, __last, __init, __binary_op, __unary_op);\n }\n \n template <class _ForwardIterator, class _Tp, class _UnaryOperation, class _BinaryOperation>\n@@ -284,7 +280,7 @@ __pattern_transform_scan(_ExecutionPolicy&& __exec, _RandomAccessIterator __firs\n                                         }) -\n                          1);\n             },\n-            [](_Tp __res) {});\n+            [](_Tp) {});\n         return __result + (__last - __first);\n     });\n }"}, {"sha": "4caa4a8e412b98117865bee08dbf25073e32717e", "filename": "libstdc++-v3/include/pstl/parallel_backend.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e957b86ca26f9a4e49acf625ed397e7dd05b0d66/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fparallel_backend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e957b86ca26f9a4e49acf625ed397e7dd05b0d66/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fparallel_backend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fparallel_backend.h?ref=e957b86ca26f9a4e49acf625ed397e7dd05b0d66", "patch": "@@ -12,8 +12,16 @@\n \n #if defined(_PSTL_PAR_BACKEND_SERIAL)\n #    include \"parallel_backend_serial.h\"\n+namespace __pstl\n+{\n+namespace __par_backend = __serial_backend;\n+}\n #elif defined(_PSTL_PAR_BACKEND_TBB)\n #    include \"parallel_backend_tbb.h\"\n+namespace __pstl\n+{\n+namespace __par_backend = __tbb_backend;\n+}\n #else\n _PSTL_PRAGMA_MESSAGE(\"Parallel backend was not specified\");\n #endif"}, {"sha": "32abe77321ecc4e5c054cf5dd3187b7b561e7db9", "filename": "libstdc++-v3/include/pstl/parallel_backend_serial.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e957b86ca26f9a4e49acf625ed397e7dd05b0d66/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fparallel_backend_serial.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e957b86ca26f9a4e49acf625ed397e7dd05b0d66/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fparallel_backend_serial.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fparallel_backend_serial.h?ref=e957b86ca26f9a4e49acf625ed397e7dd05b0d66", "patch": "@@ -18,7 +18,7 @@\n \n namespace __pstl\n {\n-namespace __serial\n+namespace __serial_backend\n {\n \n template <typename _Tp>\n@@ -110,10 +110,10 @@ template <class _ExecutionPolicy, typename _RandomAccessIterator1, typename _Ran\n           typename _RandomAccessIterator3, typename _Compare, typename _LeafMerge>\n void\n __parallel_merge(_ExecutionPolicy&&, _RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,\n-                 _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _RandomAccessIterator3 __out,\n+                 _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _RandomAccessIterator3 __outit,\n                  _Compare __comp, _LeafMerge __leaf_merge)\n {\n-    __leaf_merge(__first1, __last1, __first2, __last2, __out, __comp);\n+    __leaf_merge(__first1, __last1, __first2, __last2, __outit, __comp);\n }\n \n template <class _ExecutionPolicy, typename _F1, typename _F2>\n@@ -124,7 +124,7 @@ __parallel_invoke(_ExecutionPolicy&&, _F1&& __f1, _F2&& __f2)\n     std::forward<_F2>(__f2)();\n }\n \n-} // namespace __serial\n+} // namespace __serial_backend\n } // namespace __pstl\n \n namespace __pstl"}, {"sha": "4476486d5488a288261d6ebcac7c746336057c51", "filename": "libstdc++-v3/include/pstl/parallel_backend_tbb.h", "status": "modified", "additions": 767, "deletions": 136, "changes": 903, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e957b86ca26f9a4e49acf625ed397e7dd05b0d66/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fparallel_backend_tbb.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e957b86ca26f9a4e49acf625ed397e7dd05b0d66/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fparallel_backend_tbb.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fparallel_backend_tbb.h?ref=e957b86ca26f9a4e49acf625ed397e7dd05b0d66", "patch": "@@ -23,14 +23,15 @@\n #include <tbb/parallel_invoke.h>\n #include <tbb/task_arena.h>\n #include <tbb/tbb_allocator.h>\n+#include <tbb/task.h>\n \n #if TBB_INTERFACE_VERSION < 10000\n #    error Intel(R) Threading Building Blocks 2018 is required; older versions are not supported.\n #endif\n \n namespace __pstl\n {\n-namespace __par_backend\n+namespace __tbb_backend\n {\n \n //! Raw memory buffer with automatic freeing and no exceptions.\n@@ -67,7 +68,11 @@ class __buffer\n inline void\n __cancel_execution()\n {\n+#if TBB_INTERFACE_VERSION <= 12000\n     tbb::task::self().group()->cancel_group_execution();\n+#else\n+    tbb::task::current_context()->cancel_group_execution();\n+#endif\n }\n \n //------------------------------------------------------------------------\n@@ -189,7 +194,7 @@ _Tp\n __parallel_transform_reduce(_ExecutionPolicy&&, _Index __first, _Index __last, _Up __u, _Tp __init, _Cp __combine,\n                             _Rp __brick_reduce)\n {\n-    __par_backend::__par_trans_red_body<_Index, _Up, _Tp, _Cp, _Rp> __body(__u, __init, __combine, __brick_reduce);\n+    __tbb_backend::__par_trans_red_body<_Index, _Up, _Tp, _Cp, _Rp> __body(__u, __init, __combine, __brick_reduce);\n     // The grain size of 3 is used in order to provide mininum 2 elements for each body\n     tbb::this_task_arena::isolate(\n         [__first, __last, &__body]() { tbb::parallel_reduce(tbb::blocked_range<_Index>(__first, __last, 3), __body); });\n@@ -303,9 +308,9 @@ __upsweep(_Index __i, _Index __m, _Index __tilesize, _Tp* __r, _Index __lastsize\n     {\n         _Index __k = __split(__m);\n         tbb::parallel_invoke(\n-            [=] { __par_backend::__upsweep(__i, __k, __tilesize, __r, __tilesize, __reduce, __combine); },\n+            [=] { __tbb_backend::__upsweep(__i, __k, __tilesize, __r, __tilesize, __reduce, __combine); },\n             [=] {\n-                __par_backend::__upsweep(__i + __k, __m - __k, __tilesize, __r + __k, __lastsize, __reduce, __combine);\n+                __tbb_backend::__upsweep(__i + __k, __m - __k, __tilesize, __r + __k, __lastsize, __reduce, __combine);\n             });\n         if (__m == 2 * __k)\n             __r[__m - 1] = __combine(__r[__k - 1], __r[__m - 1]);\n@@ -323,11 +328,11 @@ __downsweep(_Index __i, _Index __m, _Index __tilesize, _Tp* __r, _Index __lastsi\n     {\n         const _Index __k = __split(__m);\n         tbb::parallel_invoke(\n-            [=] { __par_backend::__downsweep(__i, __k, __tilesize, __r, __tilesize, __initial, __combine, __scan); },\n+            [=] { __tbb_backend::__downsweep(__i, __k, __tilesize, __r, __tilesize, __initial, __combine, __scan); },\n             // Assumes that __combine never throws.\n             //TODO: Consider adding a requirement for user functors to be constant.\n             [=, &__combine] {\n-                __par_backend::__downsweep(__i + __k, __m - __k, __tilesize, __r + __k, __lastsize,\n+                __tbb_backend::__downsweep(__i + __k, __m - __k, __tilesize, __r + __k, __lastsize,\n                                            __combine(__initial, __r[__k - 1]), __combine, __scan);\n             });\n     }\n@@ -361,7 +366,7 @@ __parallel_strict_scan(_ExecutionPolicy&&, _Index __n, _Tp __initial, _Rp __redu\n             _Index __m = (__n - 1) / __tilesize;\n             __buffer<_Tp> __buf(__m + 1);\n             _Tp* __r = __buf.get();\n-            __par_backend::__upsweep(_Index(0), _Index(__m + 1), __tilesize, __r, __n - __m * __tilesize, __reduce,\n+            __tbb_backend::__upsweep(_Index(0), _Index(__m + 1), __tilesize, __r, __n - __m * __tilesize, __reduce,\n                                      __combine);\n \n             // When __apex is a no-op and __combine has no side effects, a good optimizer\n@@ -373,7 +378,7 @@ __parallel_strict_scan(_ExecutionPolicy&&, _Index __n, _Tp __initial, _Rp __redu\n             while ((__k &= __k - 1))\n                 __t = __combine(__r[__k - 1], __t);\n             __apex(__combine(__initial, __t));\n-            __par_backend::__downsweep(_Index(0), _Index(__m + 1), __tilesize, __r, __n - __m * __tilesize, __initial,\n+            __tbb_backend::__downsweep(_Index(0), _Index(__m + 1), __tilesize, __r, __n - __m * __tilesize, __initial,\n                                        __combine, __scan);\n             return;\n         }\n@@ -407,178 +412,744 @@ __parallel_transform_scan(_ExecutionPolicy&&, _Index __n, _Up __u, _Tp __init, _\n //\n // These are used by parallel implementations but do not depend on them.\n //------------------------------------------------------------------------\n+#define _PSTL_MERGE_CUT_OFF 2000\n \n-template <typename _RandomAccessIterator1, typename _RandomAccessIterator2, typename _RandomAccessIterator3,\n-          typename _Compare, typename _Cleanup, typename _LeafMerge>\n-class __merge_task : public tbb::task\n+template <typename _Func>\n+class __func_task;\n+template <typename _Func>\n+class __root_task;\n+\n+#if TBB_INTERFACE_VERSION <= 12000\n+class __task : public tbb::task\n {\n-    /*override*/ tbb::task*\n-    execute();\n-    _RandomAccessIterator1 _M_xs, _M_xe;\n-    _RandomAccessIterator2 _M_ys, _M_ye;\n-    _RandomAccessIterator3 _M_zs;\n-    _Compare _M_comp;\n-    _Cleanup _M_cleanup;\n-    _LeafMerge _M_leaf_merge;\n+  public:\n+    template <typename _Fn>\n+    __task*\n+    make_continuation(_Fn&& __f)\n+    {\n+        return new (allocate_continuation()) __func_task<typename std::decay<_Fn>::type>(std::forward<_Fn>(__f));\n+    }\n+\n+    template <typename _Fn>\n+    __task*\n+    make_child_of(__task* parent, _Fn&& __f)\n+    {\n+        return new (parent->allocate_child()) __func_task<typename std::decay<_Fn>::type>(std::forward<_Fn>(__f));\n+    }\n+\n+    template <typename _Fn>\n+    __task*\n+    make_additional_child_of(tbb::task* parent, _Fn&& __f)\n+    {\n+        return new (tbb::task::allocate_additional_child_of(*parent))\n+            __func_task<typename std::decay<_Fn>::type>(std::forward<_Fn>(__f));\n+    }\n+\n+    inline void\n+    recycle_as_continuation()\n+    {\n+        tbb::task::recycle_as_continuation();\n+    }\n+\n+    inline void\n+    recycle_as_child_of(__task* parent)\n+    {\n+        tbb::task::recycle_as_child_of(*parent);\n+    }\n+\n+    inline void\n+    spawn(__task* __t)\n+    {\n+        tbb::task::spawn(*__t);\n+    }\n+\n+    template <typename _Fn>\n+    static inline void\n+    spawn_root_and_wait(__root_task<_Fn>& __root)\n+    {\n+        tbb::task::spawn_root_and_wait(*__root._M_task);\n+    }\n+};\n+\n+template <typename _Func>\n+class __func_task : public __task\n+{\n+    _Func _M_func;\n+\n+    tbb::task*\n+    execute()\n+    {\n+        return _M_func(this);\n+    };\n \n   public:\n-    __merge_task(_RandomAccessIterator1 __xs, _RandomAccessIterator1 __xe, _RandomAccessIterator2 __ys,\n-                 _RandomAccessIterator2 __ye, _RandomAccessIterator3 __zs, _Compare __comp, _Cleanup __cleanup,\n-                 _LeafMerge __leaf_merge)\n-        : _M_xs(__xs), _M_xe(__xe), _M_ys(__ys), _M_ye(__ye), _M_zs(__zs), _M_comp(__comp), _M_cleanup(__cleanup),\n-          _M_leaf_merge(__leaf_merge)\n+    template <typename _Fn>\n+    __func_task(_Fn&& __f) : _M_func{std::forward<_Fn>(__f)}\n     {\n     }\n+\n+    _Func&\n+    body()\n+    {\n+        return _M_func;\n+    }\n };\n \n-#define _PSTL_MERGE_CUT_OFF 2000\n+template <typename _Func>\n+class __root_task\n+{\n+    tbb::task* _M_task;\n \n-template <typename _RandomAccessIterator1, typename _RandomAccessIterator2, typename _RandomAccessIterator3,\n-          typename __M_Compare, typename _Cleanup, typename _LeafMerge>\n-tbb::task*\n-__merge_task<_RandomAccessIterator1, _RandomAccessIterator2, _RandomAccessIterator3, __M_Compare, _Cleanup,\n-             _LeafMerge>::execute()\n+  public:\n+    template <typename... Args>\n+    __root_task(Args&&... args)\n+        : _M_task{new (tbb::task::allocate_root()) __func_task<_Func>{_Func(std::forward<Args>(args)...)}}\n+    {\n+    }\n+\n+    friend class __task;\n+    friend class __func_task<_Func>;\n+};\n+\n+#else  // TBB_INTERFACE_VERSION <= 12000\n+class __task : public tbb::detail::d1::task\n+{\n+  protected:\n+    tbb::detail::d1::small_object_allocator _M_allocator{};\n+    tbb::detail::d1::execution_data* _M_execute_data{};\n+    __task* _M_parent{};\n+    std::atomic<int> _M_refcount{};\n+    bool _M_recycle{};\n+\n+    template <typename _Fn>\n+    __task*\n+    allocate_func_task(_Fn&& __f)\n+    {\n+        _PSTL_ASSERT(_M_execute_data != nullptr);\n+        tbb::detail::d1::small_object_allocator __alloc{};\n+        auto __t =\n+            __alloc.new_object<__func_task<typename std::decay<_Fn>::type>>(*_M_execute_data, std::forward<_Fn>(__f));\n+        __t->_M_allocator = __alloc;\n+        return __t;\n+    }\n+\n+  public:\n+    __task*\n+    parent()\n+    {\n+        return _M_parent;\n+    }\n+\n+    void\n+    set_ref_count(int __n)\n+    {\n+        _M_refcount.store(__n, std::memory_order_release);\n+    }\n+\n+    template <typename _Fn>\n+    __task*\n+    make_continuation(_Fn&& __f)\n+    {\n+        auto __t = allocate_func_task(std::forward<_Fn&&>(__f));\n+        __t->_M_parent = _M_parent;\n+        _M_parent = nullptr;\n+        return __t;\n+    }\n+\n+    template <typename _Fn>\n+    __task*\n+    make_child_of(__task* __parent, _Fn&& __f)\n+    {\n+        auto __t = allocate_func_task(std::forward<_Fn&&>(__f));\n+        __t->_M_parent = __parent;\n+        return __t;\n+    }\n+\n+    template <typename _Fn>\n+    __task*\n+    make_additional_child_of(__task* __parent, _Fn&& __f)\n+    {\n+        auto __t = make_child_of(__parent, std::forward<_Fn>(__f));\n+        _PSTL_ASSERT(__parent->_M_refcount.load(std::memory_order_relaxed) > 0);\n+        ++__parent->_M_refcount;\n+        return __t;\n+    }\n+\n+    inline void\n+    recycle_as_continuation()\n+    {\n+        _M_recycle = true;\n+    }\n+\n+    inline void\n+    recycle_as_child_of(__task* parent)\n+    {\n+        _M_recycle = true;\n+        _M_parent = parent;\n+    }\n+\n+    inline void\n+    spawn(__task* __t)\n+    {\n+        _PSTL_ASSERT(_M_execute_data != nullptr);\n+        tbb::detail::d1::spawn(*__t, *_M_execute_data->context);\n+    }\n+\n+    template <typename _Fn>\n+    static inline void\n+    spawn_root_and_wait(__root_task<_Fn>& __root)\n+    {\n+        tbb::detail::d1::execute_and_wait(*__root._M_func_task, __root._M_context, __root._M_wait_object,\n+                                          __root._M_context);\n+    }\n+\n+    template <typename _Func>\n+    friend class __func_task;\n+};\n+\n+template <typename _Func>\n+class __func_task : public __task\n+{\n+    _Func _M_func;\n+\n+    __task*\n+    execute(tbb::detail::d1::execution_data& __ed) override\n+    {\n+        _M_execute_data = &__ed;\n+        _M_recycle = false;\n+        __task* __next = _M_func(this);\n+        return finalize(__next);\n+    };\n+\n+    __task*\n+    cancel(tbb::detail::d1::execution_data& __ed) override\n+    {\n+        return finalize(nullptr);\n+    }\n+\n+    __task*\n+    finalize(__task* __next)\n+    {\n+        bool __recycle = _M_recycle;\n+        _M_recycle = false;\n+\n+        if (__recycle)\n+        {\n+            return __next;\n+        }\n+\n+        auto __parent = _M_parent;\n+        auto __alloc = _M_allocator;\n+        auto __ed = _M_execute_data;\n+\n+        this->~__func_task();\n+\n+        _PSTL_ASSERT(__parent != nullptr);\n+        _PSTL_ASSERT(__parent->_M_refcount.load(std::memory_order_relaxed) > 0);\n+        if (--__parent->_M_refcount == 0)\n+        {\n+            _PSTL_ASSERT(__next == nullptr);\n+            __alloc.deallocate(this, *__ed);\n+            return __parent;\n+        }\n+\n+        return __next;\n+    }\n+\n+    friend class __root_task<_Func>;\n+\n+  public:\n+    template <typename _Fn>\n+    __func_task(_Fn&& __f) : _M_func(std::forward<_Fn>(__f))\n+    {\n+    }\n+\n+    _Func&\n+    body()\n+    {\n+        return _M_func;\n+    }\n+};\n+\n+template <typename _Func>\n+class __root_task : public __task\n+{\n+    __task*\n+    execute(tbb::detail::d1::execution_data& __ed) override\n+    {\n+        _M_wait_object.release();\n+        return nullptr;\n+    };\n+\n+    __task*\n+    cancel(tbb::detail::d1::execution_data& __ed) override\n+    {\n+        _M_wait_object.release();\n+        return nullptr;\n+    }\n+\n+    __func_task<_Func>* _M_func_task{};\n+    tbb::detail::d1::wait_context _M_wait_object{0};\n+    tbb::task_group_context _M_context{};\n+\n+  public:\n+    template <typename... Args>\n+    __root_task(Args&&... args) : _M_wait_object{1}\n+    {\n+        tbb::detail::d1::small_object_allocator __alloc{};\n+        _M_func_task = __alloc.new_object<__func_task<_Func>>(_Func(std::forward<Args>(args)...));\n+        _M_func_task->_M_allocator = __alloc;\n+        _M_func_task->_M_parent = this;\n+        _M_refcount.store(1, std::memory_order_relaxed);\n+    }\n+\n+    friend class __task;\n+};\n+#endif // TBB_INTERFACE_VERSION <= 12000\n+\n+template <typename _RandomAccessIterator1, typename _RandomAccessIterator2, typename _Compare, typename _Cleanup,\n+          typename _LeafMerge>\n+class __merge_func\n {\n     typedef typename std::iterator_traits<_RandomAccessIterator1>::difference_type _DifferenceType1;\n     typedef typename std::iterator_traits<_RandomAccessIterator2>::difference_type _DifferenceType2;\n     typedef typename std::common_type<_DifferenceType1, _DifferenceType2>::type _SizeType;\n-    const _SizeType __n = (_M_xe - _M_xs) + (_M_ye - _M_ys);\n-    const _SizeType __merge_cut_off = _PSTL_MERGE_CUT_OFF;\n-    if (__n <= __merge_cut_off)\n+    typedef typename std::iterator_traits<_RandomAccessIterator1>::value_type _ValueType;\n+\n+    _RandomAccessIterator1 _M_x_beg;\n+    _RandomAccessIterator2 _M_z_beg;\n+\n+    _SizeType _M_xs, _M_xe;\n+    _SizeType _M_ys, _M_ye;\n+    _SizeType _M_zs;\n+    _Compare _M_comp;\n+    _LeafMerge _M_leaf_merge;\n+    _SizeType _M_nsort; //number of elements to be sorted for partial_sort alforithm\n+\n+    static const _SizeType __merge_cut_off = _PSTL_MERGE_CUT_OFF;\n+\n+    bool _root;   //means a task is merging root task\n+    bool _x_orig; //\"true\" means X(or left ) subrange is in the original container; false - in the buffer\n+    bool _y_orig; //\"true\" means Y(or right) subrange is in the original container; false - in the buffer\n+    bool _split; //\"true\" means a merge task is a split task for parallel merging, the execution logic differs\n+\n+    bool\n+    is_partial() const\n     {\n-        _M_leaf_merge(_M_xs, _M_xe, _M_ys, _M_ye, _M_zs, _M_comp);\n+        return _M_nsort > 0;\n+    }\n+\n+    struct __move_value\n+    {\n+        template <typename Iterator1, typename Iterator2>\n+        void\n+        operator()(Iterator1 __x, Iterator2 __z)\n+        {\n+            *__z = std::move(*__x);\n+        }\n+    };\n \n-        //we clean the buffer one time on last step of the sort\n-        _M_cleanup(_M_xs, _M_xe);\n-        _M_cleanup(_M_ys, _M_ye);\n+    struct __move_value_construct\n+    {\n+        template <typename Iterator1, typename Iterator2>\n+        void\n+        operator()(Iterator1 __x, Iterator2 __z)\n+        {\n+            ::new (std::addressof(*__z)) _ValueType(std::move(*__x));\n+        }\n+    };\n+\n+    struct __move_range\n+    {\n+        template <typename Iterator1, typename Iterator2>\n+        Iterator2\n+        operator()(Iterator1 __first1, Iterator1 __last1, Iterator2 __first2)\n+        {\n+            if (__last1 - __first1 < __merge_cut_off)\n+                return std::move(__first1, __last1, __first2);\n+\n+            auto __n = __last1 - __first1;\n+            tbb::parallel_for(tbb::blocked_range<_SizeType>(0, __n, __merge_cut_off),\n+                              [__first1, __first2](const tbb::blocked_range<_SizeType>& __range) {\n+                                  std::move(__first1 + __range.begin(), __first1 + __range.end(),\n+                                            __first2 + __range.begin());\n+                              });\n+            return __first2 + __n;\n+        }\n+    };\n+\n+    struct __move_range_construct\n+    {\n+        template <typename Iterator1, typename Iterator2>\n+        Iterator2\n+        operator()(Iterator1 __first1, Iterator1 __last1, Iterator2 __first2)\n+        {\n+            if (__last1 - __first1 < __merge_cut_off)\n+            {\n+                for (; __first1 != __last1; ++__first1, ++__first2)\n+                    __move_value_construct()(__first1, __first2);\n+                return __first2;\n+            }\n+\n+            auto __n = __last1 - __first1;\n+            tbb::parallel_for(tbb::blocked_range<_SizeType>(0, __n, __merge_cut_off),\n+                              [__first1, __first2](const tbb::blocked_range<_SizeType>& __range) {\n+                                  for (auto i = __range.begin(); i != __range.end(); ++i)\n+                                      __move_value_construct()(__first1 + i, __first2 + i);\n+                              });\n+            return __first2 + __n;\n+        }\n+    };\n+\n+    struct __cleanup_range\n+    {\n+        template <typename Iterator>\n+        void\n+        operator()(Iterator __first, Iterator __last)\n+        {\n+            if (__last - __first < __merge_cut_off)\n+                _Cleanup()(__first, __last);\n+            else\n+            {\n+                auto __n = __last - __first;\n+                tbb::parallel_for(tbb::blocked_range<_SizeType>(0, __n, __merge_cut_off),\n+                                  [__first](const tbb::blocked_range<_SizeType>& __range) {\n+                                      _Cleanup()(__first + __range.begin(), __first + __range.end());\n+                                  });\n+            }\n+        }\n+    };\n+\n+  public:\n+    __merge_func(_SizeType __xs, _SizeType __xe, _SizeType __ys, _SizeType __ye, _SizeType __zs, _Compare __comp,\n+                 _Cleanup, _LeafMerge __leaf_merge, _SizeType __nsort, _RandomAccessIterator1 __x_beg,\n+                 _RandomAccessIterator2 __z_beg, bool __x_orig, bool __y_orig, bool __root)\n+        : _M_xs(__xs), _M_xe(__xe), _M_ys(__ys), _M_ye(__ye), _M_zs(__zs), _M_x_beg(__x_beg), _M_z_beg(__z_beg),\n+          _M_comp(__comp), _M_leaf_merge(__leaf_merge), _M_nsort(__nsort), _root(__root),\n+          _x_orig(__x_orig), _y_orig(__y_orig), _split(false)\n+    {\n+    }\n+\n+    bool\n+    is_left(_SizeType __idx) const\n+    {\n+        return _M_xs == __idx;\n+    }\n+\n+    template <typename IndexType>\n+    void\n+    set_odd(IndexType __idx, bool __on_off)\n+    {\n+        if (is_left(__idx))\n+            _x_orig = __on_off;\n+        else\n+            _y_orig = __on_off;\n+    }\n+\n+    __task*\n+    operator()(__task* __self);\n+\n+  private:\n+    __merge_func*\n+    parent_merge(__task* __self) const\n+    {\n+        return _root ? nullptr : &static_cast<__func_task<__merge_func>*>(__self->parent())->body();\n+    }\n+    bool\n+    x_less_y()\n+    {\n+        const auto __nx = (_M_xe - _M_xs);\n+        const auto __ny = (_M_ye - _M_ys);\n+        _PSTL_ASSERT(__nx > 0 && __ny > 0);\n+\n+        _PSTL_ASSERT(_x_orig == _y_orig);\n+        _PSTL_ASSERT(!is_partial());\n+\n+        if (_x_orig)\n+        {\n+            _PSTL_ASSERT(std::is_sorted(_M_x_beg + _M_xs, _M_x_beg + _M_xe, _M_comp));\n+            _PSTL_ASSERT(std::is_sorted(_M_x_beg + _M_ys, _M_x_beg + _M_ye, _M_comp));\n+            return !_M_comp(*(_M_x_beg + _M_ys), *(_M_x_beg + _M_xe - 1));\n+        }\n+\n+        _PSTL_ASSERT(std::is_sorted(_M_z_beg + _M_xs, _M_z_beg + _M_xe, _M_comp));\n+        _PSTL_ASSERT(std::is_sorted(_M_z_beg + _M_ys, _M_z_beg + _M_ye, _M_comp));\n+        return !_M_comp(*(_M_z_beg + _M_zs + __nx), *(_M_z_beg + _M_zs + __nx - 1));\n+    }\n+    void\n+    move_x_range()\n+    {\n+        const auto __nx = (_M_xe - _M_xs);\n+        const auto __ny = (_M_ye - _M_ys);\n+        _PSTL_ASSERT(__nx > 0 && __ny > 0);\n+\n+        if (_x_orig)\n+            __move_range_construct()(_M_x_beg + _M_xs, _M_x_beg + _M_xe, _M_z_beg + _M_zs);\n+        else\n+        {\n+            __move_range()(_M_z_beg + _M_zs, _M_z_beg + _M_zs + __nx, _M_x_beg + _M_xs);\n+            __cleanup_range()(_M_z_beg + _M_zs, _M_z_beg + _M_zs + __nx);\n+        }\n+\n+        _x_orig = !_x_orig;\n+    }\n+    void\n+    move_y_range()\n+    {\n+        const auto __nx = (_M_xe - _M_xs);\n+        const auto __ny = (_M_ye - _M_ys);\n+\n+        if (_y_orig)\n+            __move_range_construct()(_M_x_beg + _M_ys, _M_x_beg + _M_ye, _M_z_beg + _M_zs + __nx);\n+        else\n+        {\n+            __move_range()(_M_z_beg + _M_zs + __nx, _M_z_beg + _M_zs + __nx + __ny, _M_x_beg + _M_ys);\n+            __cleanup_range()(_M_z_beg + _M_zs + __nx, _M_z_beg + _M_zs + __nx + __ny);\n+        }\n+\n+        _y_orig = !_y_orig;\n+    }\n+    __task*\n+    merge_ranges(__task* __self)\n+    {\n+        _PSTL_ASSERT(_x_orig == _y_orig); //two merged subrange must be lie into the same buffer\n+\n+        const auto __nx = (_M_xe - _M_xs);\n+        const auto __ny = (_M_ye - _M_ys);\n+        const auto __n = __nx + __ny;\n+\n+        // need to merge {x} and {y}\n+        if (__n > __merge_cut_off)\n+            return split_merging(__self);\n+\n+        //merge to buffer\n+        if (_x_orig)\n+        {\n+            _M_leaf_merge(_M_x_beg + _M_xs, _M_x_beg + _M_xe, _M_x_beg + _M_ys, _M_x_beg + _M_ye, _M_z_beg + _M_zs,\n+                          _M_comp, __move_value_construct(), __move_value_construct(), __move_range_construct(),\n+                          __move_range_construct());\n+            _PSTL_ASSERT(parent_merge(__self)); //not root merging task\n+        }\n+        //merge to \"origin\"\n+        else\n+        {\n+            _PSTL_ASSERT(_x_orig == _y_orig);\n+\n+            _PSTL_ASSERT(is_partial() || std::is_sorted(_M_z_beg + _M_xs, _M_z_beg + _M_xe, _M_comp));\n+            _PSTL_ASSERT(is_partial() || std::is_sorted(_M_z_beg + _M_ys, _M_z_beg + _M_ye, _M_comp));\n+\n+            const auto __nx = (_M_xe - _M_xs);\n+            const auto __ny = (_M_ye - _M_ys);\n+\n+            _M_leaf_merge(_M_z_beg + _M_xs, _M_z_beg + _M_xe, _M_z_beg + _M_ys, _M_z_beg + _M_ye, _M_x_beg + _M_zs,\n+                          _M_comp, __move_value(), __move_value(), __move_range(), __move_range());\n+\n+            __cleanup_range()(_M_z_beg + _M_xs, _M_z_beg + _M_xe);\n+            __cleanup_range()(_M_z_beg + _M_ys, _M_z_beg + _M_ye);\n+        }\n         return nullptr;\n     }\n-    else\n+\n+    __task*\n+    process_ranges(__task* __self)\n     {\n-        _RandomAccessIterator1 __xm;\n-        _RandomAccessIterator2 __ym;\n-        if (_M_xe - _M_xs < _M_ye - _M_ys)\n+        _PSTL_ASSERT(_x_orig == _y_orig);\n+        _PSTL_ASSERT(!_split);\n+\n+        auto p = parent_merge(__self);\n+\n+        if (!p)\n+        { //root merging task\n+\n+            //optimization, just for sort algorithm, //{x} <= {y}\n+            if (!is_partial() && x_less_y()) //we have a solution\n+            {\n+                if (!_x_orig)\n+                {                   //we have to move the solution to the origin\n+                    move_x_range(); //parallel moving\n+                    move_y_range(); //parallel moving\n+                }\n+                return nullptr;\n+            }\n+            //else: if we have data in the origin,\n+            //we have to move data to the buffer for final merging into the origin.\n+            if (_x_orig)\n+            {\n+                move_x_range(); //parallel moving\n+                move_y_range(); //parallel moving\n+            }\n+            // need to merge {x} and {y}.\n+            return merge_ranges(__self);\n+        }\n+        //else: not root merging task (parent_merge() == NULL)\n+        //optimization, just for sort algorithm, //{x} <= {y}\n+        if (!is_partial() && x_less_y())\n         {\n-            __ym = _M_ys + (_M_ye - _M_ys) / 2;\n-            __xm = std::upper_bound(_M_xs, _M_xe, *__ym, _M_comp);\n+            const auto id_range = _M_zs;\n+            p->set_odd(id_range, _x_orig);\n+            return nullptr;\n+        }\n+        //else: we have to revert \"_x(y)_orig\" flag of the parent merging task\n+        const auto id_range = _M_zs;\n+        p->set_odd(id_range, !_x_orig);\n+\n+        return merge_ranges(__self);\n+    }\n+\n+    //splitting as merge task into 2 of the same level\n+    __task*\n+    split_merging(__task* __self)\n+    {\n+        _PSTL_ASSERT(_x_orig == _y_orig);\n+        const auto __nx = (_M_xe - _M_xs);\n+        const auto __ny = (_M_ye - _M_ys);\n+\n+        _SizeType __xm{};\n+        _SizeType __ym{};\n+        if (__nx < __ny)\n+        {\n+            __ym = _M_ys + __ny / 2;\n+\n+            if (_x_orig)\n+                __xm = std::upper_bound(_M_x_beg + _M_xs, _M_x_beg + _M_xe, *(_M_x_beg + __ym), _M_comp) - _M_x_beg;\n+            else\n+                __xm = std::upper_bound(_M_z_beg + _M_xs, _M_z_beg + _M_xe, *(_M_z_beg + __ym), _M_comp) - _M_z_beg;\n         }\n         else\n         {\n-            __xm = _M_xs + (_M_xe - _M_xs) / 2;\n-            __ym = std::lower_bound(_M_ys, _M_ye, *__xm, _M_comp);\n+            __xm = _M_xs + __nx / 2;\n+\n+            if (_y_orig)\n+                __ym = std::lower_bound(_M_x_beg + _M_ys, _M_x_beg + _M_ye, *(_M_x_beg + __xm), _M_comp) - _M_x_beg;\n+            else\n+                __ym = std::lower_bound(_M_z_beg + _M_ys, _M_z_beg + _M_ye, *(_M_z_beg + __xm), _M_comp) - _M_z_beg;\n         }\n-        const _RandomAccessIterator3 __zm = _M_zs + ((__xm - _M_xs) + (__ym - _M_ys));\n-        tbb::task* __right = new (tbb::task::allocate_additional_child_of(*parent()))\n-            __merge_task(__xm, _M_xe, __ym, _M_ye, __zm, _M_comp, _M_cleanup, _M_leaf_merge);\n-        tbb::task::spawn(*__right);\n-        tbb::task::recycle_as_continuation();\n+\n+        auto __zm = _M_zs + ((__xm - _M_xs) + (__ym - _M_ys));\n+        __merge_func __right_func(__xm, _M_xe, __ym, _M_ye, __zm, _M_comp, _Cleanup(), _M_leaf_merge, _M_nsort,\n+                                  _M_x_beg, _M_z_beg, _x_orig, _y_orig, _root);\n+        __right_func._split = true;\n+        auto __merge_task = __self->make_additional_child_of(__self->parent(), std::move(__right_func));\n+        __self->spawn(__merge_task);\n+        __self->recycle_as_continuation();\n+\n         _M_xe = __xm;\n         _M_ye = __ym;\n+        _split = true;\n+\n+        return __self;\n     }\n-    return this;\n+};\n+\n+template <typename _RandomAccessIterator1, typename _RandomAccessIterator2, typename __M_Compare, typename _Cleanup,\n+          typename _LeafMerge>\n+__task*\n+__merge_func<_RandomAccessIterator1, _RandomAccessIterator2, __M_Compare, _Cleanup, _LeafMerge>::\n+operator()(__task* __self)\n+{\n+    //a. split merge task into 2 of the same level; the special logic,\n+    //without processing(process_ranges) adjacent sub-ranges x and y\n+    if (_split)\n+        return merge_ranges(__self);\n+\n+    //b. General merging of adjacent sub-ranges x and y (with optimization in case of {x} <= {y} )\n+\n+    //1. x and y are in the even buffer\n+    //2. x and y are in the odd buffer\n+    if (_x_orig == _y_orig)\n+        return process_ranges(__self);\n+\n+    //3. x is in even buffer, y is in the odd buffer\n+    //4. x is in odd buffer, y is in the even buffer\n+    if (!parent_merge(__self))\n+    { //root merge task\n+        if (_x_orig)\n+            move_x_range();\n+        else\n+            move_y_range();\n+    }\n+    else\n+    {\n+        const _SizeType __nx = (_M_xe - _M_xs);\n+        const _SizeType __ny = (_M_ye - _M_ys);\n+        _PSTL_ASSERT(__nx > 0);\n+        _PSTL_ASSERT(__nx > 0);\n+\n+        if (__nx < __ny)\n+            move_x_range();\n+        else\n+            move_y_range();\n+    }\n+\n+    return process_ranges(__self);\n }\n \n template <typename _RandomAccessIterator1, typename _RandomAccessIterator2, typename _Compare, typename _LeafSort>\n-class __stable_sort_task : public tbb::task\n+class __stable_sort_func\n {\n   public:\n     typedef typename std::iterator_traits<_RandomAccessIterator1>::difference_type _DifferenceType1;\n     typedef typename std::iterator_traits<_RandomAccessIterator2>::difference_type _DifferenceType2;\n     typedef typename std::common_type<_DifferenceType1, _DifferenceType2>::type _SizeType;\n \n   private:\n-    /*override*/ tbb::task*\n-    execute();\n-    _RandomAccessIterator1 _M_xs, _M_xe;\n-    _RandomAccessIterator2 _M_zs;\n+    _RandomAccessIterator1 _M_xs, _M_xe, _M_x_beg;\n+    _RandomAccessIterator2 _M_zs, _M_z_beg;\n     _Compare _M_comp;\n     _LeafSort _M_leaf_sort;\n-    int32_t _M_inplace;\n-    _SizeType _M_nsort;\n+    bool _M_root;\n+    _SizeType _M_nsort; //zero or number of elements to be sorted for partial_sort alforithm\n \n   public:\n-    __stable_sort_task(_RandomAccessIterator1 __xs, _RandomAccessIterator1 __xe, _RandomAccessIterator2 __zs,\n-                       int32_t __inplace, _Compare __comp, _LeafSort __leaf_sort, _SizeType __n)\n-        : _M_xs(__xs), _M_xe(__xe), _M_zs(__zs), _M_comp(__comp), _M_leaf_sort(__leaf_sort), _M_inplace(__inplace),\n-          _M_nsort(__n)\n+    __stable_sort_func(_RandomAccessIterator1 __xs, _RandomAccessIterator1 __xe, _RandomAccessIterator2 __zs,\n+                       bool __root, _Compare __comp, _LeafSort __leaf_sort, _SizeType __nsort,\n+                       _RandomAccessIterator1 __x_beg, _RandomAccessIterator2 __z_beg)\n+        : _M_xs(__xs), _M_xe(__xe), _M_x_beg(__x_beg), _M_zs(__zs), _M_z_beg(__z_beg), _M_comp(__comp),\n+          _M_leaf_sort(__leaf_sort), _M_root(__root), _M_nsort(__nsort)\n     {\n     }\n-};\n \n-//! Binary operator that does nothing\n-struct __binary_no_op\n-{\n-    template <typename _Tp>\n-    void operator()(_Tp, _Tp)\n-    {\n-    }\n+    __task*\n+    operator()(__task* __self);\n };\n \n #define _PSTL_STABLE_SORT_CUT_OFF 500\n \n template <typename _RandomAccessIterator1, typename _RandomAccessIterator2, typename _Compare, typename _LeafSort>\n-tbb::task*\n-__stable_sort_task<_RandomAccessIterator1, _RandomAccessIterator2, _Compare, _LeafSort>::execute()\n+__task*\n+__stable_sort_func<_RandomAccessIterator1, _RandomAccessIterator2, _Compare, _LeafSort>::operator()(__task* __self)\n {\n+    typedef __merge_func<_RandomAccessIterator1, _RandomAccessIterator2, _Compare, __utils::__serial_destroy,\n+                         __utils::__serial_move_merge>\n+        _MergeTaskType;\n+\n     const _SizeType __n = _M_xe - _M_xs;\n     const _SizeType __nmerge = _M_nsort > 0 ? _M_nsort : __n;\n     const _SizeType __sort_cut_off = _PSTL_STABLE_SORT_CUT_OFF;\n     if (__n <= __sort_cut_off)\n     {\n         _M_leaf_sort(_M_xs, _M_xe, _M_comp);\n-        if (_M_inplace != 2)\n-            __par_backend::__init_buf(_M_xs, _M_xe, _M_zs, _M_inplace == 0);\n-        return NULL;\n-    }\n-    else\n-    {\n-        const _RandomAccessIterator1 __xm = _M_xs + __n / 2;\n-        const _RandomAccessIterator2 __zm = _M_zs + (__xm - _M_xs);\n-        const _RandomAccessIterator2 __ze = _M_zs + __n;\n-        task* __m;\n-        auto __move_values = [](_RandomAccessIterator2 __x, _RandomAccessIterator1 __z) { *__z = std::move(*__x); };\n-        auto __move_sequences = [](_RandomAccessIterator2 __first1, _RandomAccessIterator2 __last1,\n-                                   _RandomAccessIterator1 __first2) { return std::move(__first1, __last1, __first2); };\n-        if (_M_inplace == 2)\n-            __m = new (tbb::task::allocate_continuation())\n-                __merge_task<_RandomAccessIterator2, _RandomAccessIterator2, _RandomAccessIterator1, _Compare,\n-                             __serial_destroy,\n-                             __par_backend::__serial_move_merge<decltype(__move_values), decltype(__move_sequences)>>(\n-                    _M_zs, __zm, __zm, __ze, _M_xs, _M_comp, __serial_destroy(),\n-                    __par_backend::__serial_move_merge<decltype(__move_values), decltype(__move_sequences)>(\n-                        __nmerge, __move_values, __move_sequences));\n-        else if (_M_inplace)\n-            __m = new (tbb::task::allocate_continuation())\n-                __merge_task<_RandomAccessIterator2, _RandomAccessIterator2, _RandomAccessIterator1, _Compare,\n-                             __par_backend::__binary_no_op,\n-                             __par_backend::__serial_move_merge<decltype(__move_values), decltype(__move_sequences)>>(\n-                    _M_zs, __zm, __zm, __ze, _M_xs, _M_comp, __par_backend::__binary_no_op(),\n-                    __par_backend::__serial_move_merge<decltype(__move_values), decltype(__move_sequences)>(\n-                        __nmerge, __move_values, __move_sequences));\n-        else\n-        {\n-            auto __move_values = [](_RandomAccessIterator1 __x, _RandomAccessIterator2 __z) { *__z = std::move(*__x); };\n-            auto __move_sequences = [](_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,\n-                                       _RandomAccessIterator2 __first2) {\n-                return std::move(__first1, __last1, __first2);\n-            };\n-            __m = new (tbb::task::allocate_continuation())\n-                __merge_task<_RandomAccessIterator1, _RandomAccessIterator1, _RandomAccessIterator2, _Compare,\n-                             __par_backend::__binary_no_op,\n-                             __par_backend::__serial_move_merge<decltype(__move_values), decltype(__move_sequences)>>(\n-                    _M_xs, __xm, __xm, _M_xe, _M_zs, _M_comp, __par_backend::__binary_no_op(),\n-                    __par_backend::__serial_move_merge<decltype(__move_values), decltype(__move_sequences)>(\n-                        __nmerge, __move_values, __move_sequences));\n-        }\n-        __m->set_ref_count(2);\n-        task* __right = new (__m->allocate_child())\n-            __stable_sort_task(__xm, _M_xe, __zm, !_M_inplace, _M_comp, _M_leaf_sort, __nmerge);\n-        tbb::task::spawn(*__right);\n-        tbb::task::recycle_as_child_of(*__m);\n-        _M_xe = __xm;\n-        _M_inplace = !_M_inplace;\n+        _PSTL_ASSERT(!_M_root);\n+        return nullptr;\n     }\n-    return this;\n+\n+    const _RandomAccessIterator1 __xm = _M_xs + __n / 2;\n+    const _RandomAccessIterator2 __zm = _M_zs + (__xm - _M_xs);\n+    const _RandomAccessIterator2 __ze = _M_zs + __n;\n+    _MergeTaskType __m(_MergeTaskType(_M_xs - _M_x_beg, __xm - _M_x_beg, __xm - _M_x_beg, _M_xe - _M_x_beg,\n+                                      _M_zs - _M_z_beg, _M_comp, __utils::__serial_destroy(),\n+                                      __utils::__serial_move_merge(__nmerge), _M_nsort, _M_x_beg, _M_z_beg,\n+                                      /*x_orig*/ true, /*y_orig*/ true, /*root*/ _M_root));\n+    auto __parent = __self->make_continuation(std::move(__m));\n+    __parent->set_ref_count(2);\n+    auto __right = __self->make_child_of(\n+        __parent, __stable_sort_func(__xm, _M_xe, __zm, false, _M_comp, _M_leaf_sort, _M_nsort, _M_x_beg, _M_z_beg));\n+    __self->spawn(__right);\n+    __self->recycle_as_child_of(__parent);\n+    _M_root = false;\n+    _M_xe = __xm;\n+\n+    return __self;\n }\n \n template <class _ExecutionPolicy, typename _RandomAccessIterator, typename _Compare, typename _LeafSort>\n@@ -591,18 +1162,16 @@ __parallel_stable_sort(_ExecutionPolicy&&, _RandomAccessIterator __xs, _RandomAc\n         typedef typename std::iterator_traits<_RandomAccessIterator>::value_type _ValueType;\n         typedef typename std::iterator_traits<_RandomAccessIterator>::difference_type _DifferenceType;\n         const _DifferenceType __n = __xe - __xs;\n-        if (__nsort == 0)\n-            __nsort = __n;\n+        if (__nsort == __n)\n+            __nsort = 0; // 'partial_sort' becames 'sort'\n \n         const _DifferenceType __sort_cut_off = _PSTL_STABLE_SORT_CUT_OFF;\n         if (__n > __sort_cut_off)\n         {\n-            _PSTL_ASSERT(__nsort > 0 && __nsort <= __n);\n             __buffer<_ValueType> __buf(__n);\n-            using tbb::task;\n-            task::spawn_root_and_wait(*new (task::allocate_root())\n-                                          __stable_sort_task<_RandomAccessIterator, _ValueType*, _Compare, _LeafSort>(\n-                                              __xs, __xe, (_ValueType*)__buf.get(), 2, __comp, __leaf_sort, __nsort));\n+            __root_task<__stable_sort_func<_RandomAccessIterator, _ValueType*, _Compare, _LeafSort>> __root{\n+                __xs, __xe, __buf.get(), true, __comp, __leaf_sort, __nsort, __xs, __buf.get()};\n+            __task::spawn_root_and_wait(__root);\n             return;\n         }\n         //serial sort\n@@ -613,6 +1182,68 @@ __parallel_stable_sort(_ExecutionPolicy&&, _RandomAccessIterator __xs, _RandomAc\n //------------------------------------------------------------------------\n // parallel_merge\n //------------------------------------------------------------------------\n+template <typename _RandomAccessIterator1, typename _RandomAccessIterator2, typename _RandomAccessIterator3,\n+          typename _Compare, typename _LeafMerge>\n+class __merge_func_static\n+{\n+    _RandomAccessIterator1 _M_xs, _M_xe;\n+    _RandomAccessIterator2 _M_ys, _M_ye;\n+    _RandomAccessIterator3 _M_zs;\n+    _Compare _M_comp;\n+    _LeafMerge _M_leaf_merge;\n+\n+  public:\n+    __merge_func_static(_RandomAccessIterator1 __xs, _RandomAccessIterator1 __xe, _RandomAccessIterator2 __ys,\n+                        _RandomAccessIterator2 __ye, _RandomAccessIterator3 __zs, _Compare __comp,\n+                        _LeafMerge __leaf_merge)\n+        : _M_xs(__xs), _M_xe(__xe), _M_ys(__ys), _M_ye(__ye), _M_zs(__zs), _M_comp(__comp), _M_leaf_merge(__leaf_merge)\n+    {\n+    }\n+\n+    __task*\n+    operator()(__task* __self);\n+};\n+\n+//TODO: consider usage of parallel_for with a custom blocked_range\n+template <typename _RandomAccessIterator1, typename _RandomAccessIterator2, typename _RandomAccessIterator3,\n+          typename __M_Compare, typename _LeafMerge>\n+__task*\n+__merge_func_static<_RandomAccessIterator1, _RandomAccessIterator2, _RandomAccessIterator3, __M_Compare, _LeafMerge>::\n+operator()(__task* __self)\n+{\n+    typedef typename std::iterator_traits<_RandomAccessIterator1>::difference_type _DifferenceType1;\n+    typedef typename std::iterator_traits<_RandomAccessIterator2>::difference_type _DifferenceType2;\n+    typedef typename std::common_type<_DifferenceType1, _DifferenceType2>::type _SizeType;\n+    const _SizeType __n = (_M_xe - _M_xs) + (_M_ye - _M_ys);\n+    const _SizeType __merge_cut_off = _PSTL_MERGE_CUT_OFF;\n+    if (__n <= __merge_cut_off)\n+    {\n+        _M_leaf_merge(_M_xs, _M_xe, _M_ys, _M_ye, _M_zs, _M_comp);\n+        return nullptr;\n+    }\n+\n+    _RandomAccessIterator1 __xm;\n+    _RandomAccessIterator2 __ym;\n+    if (_M_xe - _M_xs < _M_ye - _M_ys)\n+    {\n+        __ym = _M_ys + (_M_ye - _M_ys) / 2;\n+        __xm = std::upper_bound(_M_xs, _M_xe, *__ym, _M_comp);\n+    }\n+    else\n+    {\n+        __xm = _M_xs + (_M_xe - _M_xs) / 2;\n+        __ym = std::lower_bound(_M_ys, _M_ye, *__xm, _M_comp);\n+    }\n+    const _RandomAccessIterator3 __zm = _M_zs + ((__xm - _M_xs) + (__ym - _M_ys));\n+    auto __right = __self->make_additional_child_of(\n+        __self->parent(), __merge_func_static(__xm, _M_xe, __ym, _M_ye, __zm, _M_comp, _M_leaf_merge));\n+    __self->spawn(__right);\n+    __self->recycle_as_continuation();\n+    _M_xe = __xm;\n+    _M_ye = __ym;\n+\n+    return __self;\n+}\n \n template <class _ExecutionPolicy, typename _RandomAccessIterator1, typename _RandomAccessIterator2,\n           typename _RandomAccessIterator3, typename _Compare, typename _LeafMerge>\n@@ -634,11 +1265,11 @@ __parallel_merge(_ExecutionPolicy&&, _RandomAccessIterator1 __xs, _RandomAccessI\n     else\n     {\n         tbb::this_task_arena::isolate([=]() {\n-            typedef __merge_task<_RandomAccessIterator1, _RandomAccessIterator2, _RandomAccessIterator3, _Compare,\n-                                 __par_backend::__binary_no_op, _LeafMerge>\n+            typedef __merge_func_static<_RandomAccessIterator1, _RandomAccessIterator2, _RandomAccessIterator3,\n+                                        _Compare, _LeafMerge>\n                 _TaskType;\n-            tbb::task::spawn_root_and_wait(*new (tbb::task::allocate_root()) _TaskType(\n-                __xs, __xe, __ys, __ye, __zs, __comp, __par_backend::__binary_no_op(), __leaf_merge));\n+            __root_task<_TaskType> __root{__xs, __xe, __ys, __ye, __zs, __comp, __leaf_merge};\n+            __task::spawn_root_and_wait(__root);\n         });\n     }\n }\n@@ -654,7 +1285,7 @@ __parallel_invoke(_ExecutionPolicy&&, _F1&& __f1, _F2&& __f2)\n     tbb::this_task_arena::isolate([&]() { tbb::parallel_invoke(std::forward<_F1>(__f1), std::forward<_F2>(__f2)); });\n }\n \n-} // namespace __par_backend\n+} // namespace __tbb_backend\n } // namespace __pstl\n \n #endif /* _PSTL_PARALLEL_BACKEND_TBB_H */"}, {"sha": "39eafad2fd181a5de0f0214515e9711781db5c02", "filename": "libstdc++-v3/include/pstl/parallel_backend_utils.h", "status": "modified", "additions": 155, "deletions": 93, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e957b86ca26f9a4e49acf625ed397e7dd05b0d66/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fparallel_backend_utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e957b86ca26f9a4e49acf625ed397e7dd05b0d66/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fparallel_backend_utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fparallel_backend_utils.h?ref=e957b86ca26f9a4e49acf625ed397e7dd05b0d66", "patch": "@@ -16,7 +16,8 @@\n \n namespace __pstl\n {\n-namespace __par_backend\n+\n+namespace __utils\n {\n \n //! Destroy sequence [xs,xe)\n@@ -36,24 +37,28 @@ struct __serial_destroy\n };\n \n //! Merge sequences [__xs,__xe) and [__ys,__ye) to output sequence [__zs,(__xe-__xs)+(__ye-__ys)), using std::move\n-template <class _MoveValues, class _MoveSequences>\n struct __serial_move_merge\n {\n     const std::size_t _M_nmerge;\n-    _MoveValues _M_move_values;\n-    _MoveSequences _M_move_sequences;\n \n-    explicit __serial_move_merge(std::size_t __nmerge, _MoveValues __move_values, _MoveSequences __move_sequences)\n-        : _M_nmerge(__nmerge), _M_move_values(__move_values), _M_move_sequences(__move_sequences)\n-    {\n-    }\n-    template <class _RandomAccessIterator1, class _RandomAccessIterator2, class _RandomAccessIterator3, class _Compare>\n+    explicit __serial_move_merge(std::size_t __nmerge) : _M_nmerge(__nmerge) {}\n+    template <class _RandomAccessIterator1, class _RandomAccessIterator2, class _RandomAccessIterator3, class _Compare,\n+              class _MoveValueX, class _MoveValueY, class _MoveSequenceX, class _MoveSequenceY>\n     void\n     operator()(_RandomAccessIterator1 __xs, _RandomAccessIterator1 __xe, _RandomAccessIterator2 __ys,\n-               _RandomAccessIterator2 __ye, _RandomAccessIterator3 __zs, _Compare __comp)\n+               _RandomAccessIterator2 __ye, _RandomAccessIterator3 __zs, _Compare __comp, _MoveValueX __move_value_x,\n+               _MoveValueY __move_value_y, _MoveSequenceX __move_sequence_x, _MoveSequenceY __move_sequence_y)\n     {\n+        constexpr bool __same_move_val = std::is_same<_MoveValueX, _MoveValueY>::value;\n+        constexpr bool __same_move_seq = std::is_same<_MoveSequenceX, _MoveSequenceY>::value;\n+\n         auto __n = _M_nmerge;\n         _PSTL_ASSERT(__n > 0);\n+\n+        auto __nx = __xe - __xs;\n+        //auto __ny = __ye - __ys;\n+        _RandomAccessIterator3 __zs_beg = __zs;\n+\n         if (__xs != __xe)\n         {\n             if (__ys != __ye)\n@@ -62,134 +67,191 @@ struct __serial_move_merge\n                 {\n                     if (__comp(*__ys, *__xs))\n                     {\n-                        _M_move_values(__ys, __zs);\n+                        const auto __i = __zs - __zs_beg;\n+                        if (__i < __nx)\n+                            __move_value_x(__ys, __zs);\n+                        else\n+                            __move_value_y(__ys, __zs);\n                         ++__zs, --__n;\n                         if (++__ys == __ye)\n                         {\n                             break;\n                         }\n                         else if (__n == 0)\n                         {\n-                            __zs = _M_move_sequences(__ys, __ye, __zs);\n+                            const auto __j = __zs - __zs_beg;\n+                            if (__same_move_seq || __j < __nx)\n+                                __zs = __move_sequence_x(__ys, __ye, __zs);\n+                            else\n+                                __zs = __move_sequence_y(__ys, __ye, __zs);\n                             break;\n                         }\n-                        else\n-                        {\n-                        }\n                     }\n                     else\n                     {\n-                        _M_move_values(__xs, __zs);\n+                        const auto __i = __zs - __zs_beg;\n+                        if (__same_move_val || __i < __nx)\n+                            __move_value_x(__xs, __zs);\n+                        else\n+                            __move_value_y(__xs, __zs);\n                         ++__zs, --__n;\n                         if (++__xs == __xe)\n                         {\n-                            _M_move_sequences(__ys, __ye, __zs);\n+                            const auto __j = __zs - __zs_beg;\n+                            if (__same_move_seq || __j < __nx)\n+                                __move_sequence_x(__ys, __ye, __zs);\n+                            else\n+                                __move_sequence_y(__ys, __ye, __zs);\n                             return;\n                         }\n                         else if (__n == 0)\n                         {\n-                            __zs = _M_move_sequences(__xs, __xe, __zs);\n-                            _M_move_sequences(__ys, __ye, __zs);\n+                            const auto __j = __zs - __zs_beg;\n+                            if (__same_move_seq || __j < __nx)\n+                            {\n+                                __zs = __move_sequence_x(__xs, __xe, __zs);\n+                                __move_sequence_x(__ys, __ye, __zs);\n+                            }\n+                            else\n+                            {\n+                                __zs = __move_sequence_y(__xs, __xe, __zs);\n+                                __move_sequence_y(__ys, __ye, __zs);\n+                            }\n                             return;\n                         }\n-                        else\n-                        {\n-                        }\n                     }\n                 }\n             }\n             __ys = __xs;\n             __ye = __xe;\n         }\n-        _M_move_sequences(__ys, __ye, __zs);\n+        const auto __i = __zs - __zs_beg;\n+        if (__same_move_seq || __i < __nx)\n+            __move_sequence_x(__ys, __ye, __zs);\n+        else\n+            __move_sequence_y(__ys, __ye, __zs);\n     }\n };\n \n-template <typename _RandomAccessIterator1, typename _OutputIterator>\n-void\n-__init_buf(_RandomAccessIterator1 __xs, _RandomAccessIterator1 __xe, _OutputIterator __zs, bool __bMove)\n+template <typename _ForwardIterator1, typename _ForwardIterator2, typename _OutputIterator, typename _Compare,\n+          typename _CopyConstructRange>\n+_OutputIterator\n+__set_union_construct(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n+                      _ForwardIterator2 __last2, _OutputIterator __result, _Compare __comp,\n+                      _CopyConstructRange __cc_range)\n {\n-    const _OutputIterator __ze = __zs + (__xe - __xs);\n-    typedef typename std::iterator_traits<_OutputIterator>::value_type _ValueType;\n-    if (__bMove)\n-    {\n-        // Initialize the temporary buffer and move keys to it.\n-        for (; __zs != __ze; ++__xs, ++__zs)\n-            new (&*__zs) _ValueType(std::move(*__xs));\n-    }\n-    else\n+    using _Tp = typename std::iterator_traits<_OutputIterator>::value_type;\n+\n+    for (; __first1 != __last1; ++__result)\n     {\n-        // Initialize the temporary buffer\n-        for (; __zs != __ze; ++__zs)\n-            new (&*__zs) _ValueType;\n+        if (__first2 == __last2)\n+            return __cc_range(__first1, __last1, __result);\n+        if (__comp(*__first2, *__first1))\n+        {\n+            ::new (std::addressof(*__result)) _Tp(*__first2);\n+            ++__first2;\n+        }\n+        else\n+        {\n+            ::new (std::addressof(*__result)) _Tp(*__first1);\n+            if (!__comp(*__first1, *__first2))\n+                ++__first2;\n+            ++__first1;\n+        }\n     }\n+    return __cc_range(__first2, __last2, __result);\n }\n \n-// TODO is this actually used anywhere?\n-template <typename _Buf>\n-class __stack\n+template <typename _ForwardIterator1, typename _ForwardIterator2, typename _OutputIterator, typename _Compare>\n+_OutputIterator\n+__set_intersection_construct(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n+                             _ForwardIterator2 __last2, _OutputIterator __result, _Compare __comp)\n {\n-    typedef typename std::iterator_traits<decltype(_Buf(0).get())>::value_type _ValueType;\n-    typedef typename std::iterator_traits<_ValueType*>::difference_type _DifferenceType;\n+    using _Tp = typename std::iterator_traits<_OutputIterator>::value_type;\n \n-    _Buf _M_buf;\n-    _ValueType* _M_ptr;\n-    _DifferenceType _M_maxsize;\n-\n-    __stack(const __stack&) = delete;\n-    void\n-    operator=(const __stack&) = delete;\n-\n-  public:\n-    __stack(_DifferenceType __max_size) : _M_buf(__max_size), _M_maxsize(__max_size) { _M_ptr = _M_buf.get(); }\n-\n-    ~__stack()\n+    for (; __first1 != __last1 && __first2 != __last2;)\n     {\n-        _PSTL_ASSERT(size() <= _M_maxsize);\n-        while (!empty())\n-            pop();\n+        if (__comp(*__first1, *__first2))\n+            ++__first1;\n+        else\n+        {\n+            if (!__comp(*__first2, *__first1))\n+            {\n+                ::new (std::addressof(*__result)) _Tp(*__first1);\n+                ++__result;\n+                ++__first1;\n+            }\n+            ++__first2;\n+        }\n     }\n+    return __result;\n+}\n \n-    const _Buf&\n-    buffer() const\n-    {\n-        return _M_buf;\n-    }\n-    size_t\n-    size() const\n-    {\n-        _PSTL_ASSERT(_M_ptr - _M_buf.get() <= _M_maxsize);\n-        _PSTL_ASSERT(_M_ptr - _M_buf.get() >= 0);\n-        return _M_ptr - _M_buf.get();\n-    }\n-    bool\n-    empty() const\n-    {\n-        _PSTL_ASSERT(_M_ptr >= _M_buf.get());\n-        return _M_ptr == _M_buf.get();\n-    }\n-    void\n-    push(const _ValueType& __v)\n-    {\n-        _PSTL_ASSERT(size() < _M_maxsize);\n-        new (_M_ptr) _ValueType(__v);\n-        ++_M_ptr;\n-    }\n-    const _ValueType&\n-    top() const\n+template <typename _ForwardIterator1, typename _ForwardIterator2, typename _OutputIterator, typename _Compare,\n+          typename _CopyConstructRange>\n+_OutputIterator\n+__set_difference_construct(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n+                           _ForwardIterator2 __last2, _OutputIterator __result, _Compare __comp,\n+                           _CopyConstructRange __cc_range)\n+{\n+    using _Tp = typename std::iterator_traits<_OutputIterator>::value_type;\n+\n+    for (; __first1 != __last1;)\n     {\n-        return *(_M_ptr - 1);\n+        if (__first2 == __last2)\n+            return __cc_range(__first1, __last1, __result);\n+\n+        if (__comp(*__first1, *__first2))\n+        {\n+            ::new (std::addressof(*__result)) _Tp(*__first1);\n+            ++__result;\n+            ++__first1;\n+        }\n+        else\n+        {\n+            if (!__comp(*__first2, *__first1))\n+                ++__first1;\n+            ++__first2;\n+        }\n     }\n-    void\n-    pop()\n+    return __result;\n+}\n+template <typename _ForwardIterator1, typename _ForwardIterator2, typename _OutputIterator, typename _Compare,\n+          typename _CopyConstructRange>\n+_OutputIterator\n+__set_symmetric_difference_construct(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n+                                     _ForwardIterator2 __last2, _OutputIterator __result, _Compare __comp,\n+                                     _CopyConstructRange __cc_range)\n+{\n+    using _Tp = typename std::iterator_traits<_OutputIterator>::value_type;\n+\n+    for (; __first1 != __last1;)\n     {\n-        _PSTL_ASSERT(_M_ptr > _M_buf.get());\n-        --_M_ptr;\n-        (*_M_ptr).~_ValueType();\n+        if (__first2 == __last2)\n+            return __cc_range(__first1, __last1, __result);\n+\n+        if (__comp(*__first1, *__first2))\n+        {\n+            ::new (std::addressof(*__result)) _Tp(*__first1);\n+            ++__result;\n+            ++__first1;\n+        }\n+        else\n+        {\n+            if (__comp(*__first2, *__first1))\n+            {\n+                ::new (std::addressof(*__result)) _Tp(*__first2);\n+                ++__result;\n+            }\n+            else\n+                ++__first1;\n+            ++__first2;\n+        }\n     }\n-};\n+    return __cc_range(__first2, __last2, __result);\n+}\n \n-} // namespace __par_backend\n+} // namespace __utils\n } // namespace __pstl\n \n #endif /* _PSTL_PARALLEL_BACKEND_UTILS_H */"}, {"sha": "d1bf08e5f3b31104bf7360af802307c83742ca2f", "filename": "libstdc++-v3/include/pstl/pstl_config.h", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e957b86ca26f9a4e49acf625ed397e7dd05b0d66/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fpstl_config.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e957b86ca26f9a4e49acf625ed397e7dd05b0d66/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fpstl_config.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fpstl_config.h?ref=e957b86ca26f9a4e49acf625ed397e7dd05b0d66", "patch": "@@ -11,13 +11,13 @@\n #define _PSTL_CONFIG_H\n \n // The version is XYYZ, where X is major, YY is minor, and Z is patch (i.e. X.YY.Z)\n-#define _PSTL_VERSION 9000\n+#define _PSTL_VERSION 12000\n #define _PSTL_VERSION_MAJOR (_PSTL_VERSION / 1000)\n #define _PSTL_VERSION_MINOR ((_PSTL_VERSION % 1000) / 10)\n #define _PSTL_VERSION_PATCH (_PSTL_VERSION % 10)\n \n #if !defined(_PSTL_PAR_BACKEND_SERIAL) && !defined(_PSTL_PAR_BACKEND_TBB)\n-#    error \"The parallel backend is neither serial nor TBB\"\n+#    error \"A parallel backend must be specified\"\n #endif\n \n // Check the user-defined macro for warnings\n@@ -40,6 +40,15 @@\n #define _PSTL_STRING(x) _PSTL_STRING_AUX(x)\n #define _PSTL_STRING_CONCAT(x, y) x #y\n \n+#ifdef _PSTL_HIDE_FROM_ABI_PER_TU\n+#    define _PSTL_HIDE_FROM_ABI_PUSH                                                                                   \\\n+        _Pragma(\"clang attribute push(__attribute__((internal_linkage)), apply_to=any(function,record))\")\n+#    define _PSTL_HIDE_FROM_ABI_POP _Pragma(\"clang attribute pop\")\n+#else\n+#    define _PSTL_HIDE_FROM_ABI_PUSH /* nothing */\n+#    define _PSTL_HIDE_FROM_ABI_POP  /* nothing */\n+#endif\n+\n // note that when ICC or Clang is in use, _PSTL_GCC_VERSION might not fully match\n // the actual GCC version on the system.\n #define _PSTL_GCC_VERSION (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__)\n@@ -50,7 +59,8 @@\n #endif\n \n // Enable SIMD for compilers that support OpenMP 4.0\n-#if (_OPENMP >= 201307) || (__INTEL_COMPILER >= 1600) || (!defined(__INTEL_COMPILER) && _PSTL_GCC_VERSION >= 40900)\n+#if (_OPENMP >= 201307) || (__INTEL_COMPILER >= 1600) || (!defined(__INTEL_COMPILER) && _PSTL_GCC_VERSION >= 40900) || \\\n+    defined(__clang__)\n #    define _PSTL_PRAGMA_SIMD _PSTL_PRAGMA(omp simd)\n #    define _PSTL_PRAGMA_DECLARE_SIMD _PSTL_PRAGMA(omp declare simd)\n #    define _PSTL_PRAGMA_SIMD_REDUCTION(PRM) _PSTL_PRAGMA(omp simd reduction(PRM))\n@@ -70,7 +80,7 @@\n #    define _PSTL_PRAGMA_FORCEINLINE\n #endif\n \n-#if (__INTEL_COMPILER >= 1900) || (_PSTL_GCC_VERSION >= 100000)\n+#if (__INTEL_COMPILER >= 1900)\n #    define _PSTL_PRAGMA_SIMD_SCAN(PRM) _PSTL_PRAGMA(omp simd reduction(inscan, PRM))\n #    define _PSTL_PRAGMA_SIMD_INCLUSIVE_SCAN(PRM) _PSTL_PRAGMA(omp scan inclusive(PRM))\n #    define _PSTL_PRAGMA_SIMD_EXCLUSIVE_SCAN(PRM) _PSTL_PRAGMA(omp scan exclusive(PRM))\n@@ -100,11 +110,7 @@\n #    define _PSTL_UDR_PRESENT 0\n #endif\n \n-#if ((__INTEL_COMPILER >= 1900 && __INTEL_COMPILER_BUILD_DATE >= 20180626) || _PSTL_GCC_VERSION >= 100000)\n-#    define _PSTL_UDS_PRESENT 1\n-#else\n-#    define _PSTL_UDS_PRESENT 0\n-#endif\n+#define _PSTL_UDS_PRESENT (__INTEL_COMPILER >= 1900 && __INTEL_COMPILER_BUILD_DATE >= 20180626)\n \n #if _PSTL_EARLYEXIT_PRESENT\n #    define _PSTL_PRAGMA_SIMD_EARLYEXIT _PSTL_PRAGMA(omp simd early_exit)"}, {"sha": "a05de39f7576f8eaee7c9c889e4170144ad16368", "filename": "libstdc++-v3/include/pstl/unseq_backend_simd.h", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e957b86ca26f9a4e49acf625ed397e7dd05b0d66/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Funseq_backend_simd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e957b86ca26f9a4e49acf625ed397e7dd05b0d66/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Funseq_backend_simd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Funseq_backend_simd.h?ref=e957b86ca26f9a4e49acf625ed397e7dd05b0d66", "patch": "@@ -181,22 +181,22 @@ __simd_first(_Index1 __first1, _DifferenceType __n, _Index2 __first2, _Pred __pr\n         _DifferenceType __i;\n         _PSTL_PRAGMA_VECTOR_UNALIGNED // Do not generate peel loop part\n             _PSTL_PRAGMA_SIMD_REDUCTION(|\n-                                         : __found) for (__i = 0; __i < __block_size; ++__i)\n+                                        : __found) for (__i = 0; __i < __block_size; ++__i)\n         {\n             const _DifferenceType __t = __pred(__first1[__i], __first2[__i]);\n             __lane[__i] = __t;\n             __found |= __t;\n         }\n         if (__found)\n         {\n-            _DifferenceType __i;\n+            _DifferenceType __i2;\n             // This will vectorize\n-            for (__i = 0; __i < __block_size; ++__i)\n+            for (__i2 = 0; __i2 < __block_size; ++__i2)\n             {\n-                if (__lane[__i])\n+                if (__lane[__i2])\n                     break;\n             }\n-            return std::make_pair(__first1 + __i, __first2 + __i);\n+            return std::make_pair(__first1 + __i2, __first2 + __i2);\n         }\n         __first1 += __block_size;\n         __first2 += __block_size;\n@@ -403,7 +403,7 @@ __simd_adjacent_find(_Index __first, _Index __last, _BinaryPredicate __pred, boo\n         _DifferenceType __found = 0;\n         _PSTL_PRAGMA_VECTOR_UNALIGNED // Do not generate peel loop part\n             _PSTL_PRAGMA_SIMD_REDUCTION(|\n-                                         : __found) for (__i = 0; __i < __block_size - 1; ++__i)\n+                                        : __found) for (__i = 0; __i < __block_size - 1; ++__i)\n         {\n             //TODO: to improve SIMD vectorization\n             const _DifferenceType __t = __pred(*(__first + __i), *(__first + __i + 1));\n@@ -486,15 +486,15 @@ __simd_transform_reduce(_Size __n, _Tp __init, _BinaryOperation __binary_op, _Un\n             __lane[__j] = __binary_op(__lane[__j], __f(last_iteration + __j));\n         }\n         // combiner\n-        for (_Size __i = 0; __i < __block_size; ++__i)\n+        for (_Size __j = 0; __j < __block_size; ++__j)\n         {\n-            __init = __binary_op(__init, __lane[__i]);\n+            __init = __binary_op(__init, __lane[__j]);\n         }\n         // destroyer\n         _PSTL_PRAGMA_SIMD\n-        for (_Size __i = 0; __i < __block_size; ++__i)\n+        for (_Size __j = 0; __j < __block_size; ++__j)\n         {\n-            __lane[__i].~_Tp();\n+            __lane[__j].~_Tp();\n         }\n     }\n     else\n@@ -796,8 +796,9 @@ __simd_find_first_of(_ForwardIterator1 __first, _ForwardIterator1 __last, _Forwa\n     {\n         for (; __first != __last; ++__first)\n         {\n-  \t    if (__unseq_backend::__simd_or(__s_first, __n2,\n-                          __internal::__equal_value_by_pred<decltype(*__first), _BinaryPredicate>(*__first, __pred)))\n+            if (__unseq_backend::__simd_or(\n+                    __s_first, __n2,\n+                    __internal::__equal_value_by_pred<decltype(*__first), _BinaryPredicate>(*__first, __pred)))\n             {\n                 return __first;\n             }\n@@ -807,10 +808,10 @@ __simd_find_first_of(_ForwardIterator1 __first, _ForwardIterator1 __last, _Forwa\n     {\n         for (; __s_first != __s_last; ++__s_first)\n         {\n-  \t    const auto __result = __unseq_backend::__simd_first(__first, _DifferencType(0), __n1,\n-                                               [__s_first, &__pred](_ForwardIterator1 __it, _DifferencType __i) {\n-                                                   return __pred(__it[__i], *__s_first);\n-                                               });\n+            const auto __result = __unseq_backend::__simd_first(\n+                __first, _DifferencType(0), __n1, [__s_first, &__pred](_ForwardIterator1 __it, _DifferencType __i) {\n+                    return __pred(__it[__i], *__s_first);\n+                });\n             if (__result != __last)\n             {\n                 return __result;\n@@ -825,9 +826,9 @@ _RandomAccessIterator\n __simd_remove_if(_RandomAccessIterator __first, _DifferenceType __n, _UnaryPredicate __pred) noexcept\n {\n     // find first element we need to remove\n-    auto __current =\n-        __unseq_backend::__simd_first(__first, _DifferenceType(0), __n,\n-                     [&__pred](_RandomAccessIterator __it, _DifferenceType __i) { return __pred(__it[__i]); });\n+    auto __current = __unseq_backend::__simd_first(\n+        __first, _DifferenceType(0), __n,\n+        [&__pred](_RandomAccessIterator __it, _DifferenceType __i) { return __pred(__it[__i]); });\n     __n -= __current - __first;\n \n     // if we have in sequence only one element that pred(__current[1]) != false we can exit the function"}]}