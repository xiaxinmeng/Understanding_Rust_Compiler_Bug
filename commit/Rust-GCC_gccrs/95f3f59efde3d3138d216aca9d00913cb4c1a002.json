{"sha": "95f3f59efde3d3138d216aca9d00913cb4c1a002", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTVmM2Y1OWVmZGUzZDMxMzhkMjE2YWNhOWQwMDkxM2NiNGMxYTAwMg==", "commit": {"author": {"name": "John David Anglin", "email": "dave.anglin@nrc-cnrc.gc.ca", "date": "2003-03-04T06:20:17Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2003-03-04T06:20:17Z"}, "message": "function.c (STACK_ALIGNMENT_NEEDED): New macro.\n\n\t* function.c (STACK_ALIGNMENT_NEEDED): New macro.  Default to 1.\n\t(assign_stack_local_1): Perform overall stack alignment only when\n\tSTACK_ALIGNMENT_NEEDED is non-zero.\n\t* doc/tm.texi (STACK_ALIGNMENT_NEEDED): Document.\n\n\t* pa.c (compute_frame_size): Rename fsize to size.  Account for\n\talignment to a word boundary before general register save block.  Only\n\taccount for double-word alignment before floating point register save\n\tblock if one or more are saved.  Don't allocate space for %r3 when\n\tframe pointer is needed.\n\t(hppa_expand_prologue): Include alignment to word boundary in local\n\tframe size.\n\t* pa.h (STARTING_FRAME_OFFSET): Define to 8 on both 32 and 64-bit ports.\n\t(STACK_ALIGNMENT_NEEDED): Define.\n\nFrom-SVN: r63771", "tree": {"sha": "e9ac290e5315d76e0df2d32ccb321c9164e8fd9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e9ac290e5315d76e0df2d32ccb321c9164e8fd9a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/95f3f59efde3d3138d216aca9d00913cb4c1a002", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95f3f59efde3d3138d216aca9d00913cb4c1a002", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95f3f59efde3d3138d216aca9d00913cb4c1a002", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95f3f59efde3d3138d216aca9d00913cb4c1a002/comments", "author": null, "committer": null, "parents": [{"sha": "9b23f09dc11c0a21ef0b4affb50a2c2fc7c69147", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b23f09dc11c0a21ef0b4affb50a2c2fc7c69147", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b23f09dc11c0a21ef0b4affb50a2c2fc7c69147"}], "stats": {"total": 151, "additions": 108, "deletions": 43}, "files": [{"sha": "adc47bfa310b63593f892d26fd9e08945cbd9e22", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95f3f59efde3d3138d216aca9d00913cb4c1a002/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95f3f59efde3d3138d216aca9d00913cb4c1a002/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=95f3f59efde3d3138d216aca9d00913cb4c1a002", "patch": "@@ -1,3 +1,20 @@\n+2003-03-04  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n+\n+\t* function.c (STACK_ALIGNMENT_NEEDED): New macro.  Default to 1.\n+\t(assign_stack_local_1): Perform overall stack alignment only when\n+\tSTACK_ALIGNMENT_NEEDED is non-zero.\n+\t* doc/tm.texi (STACK_ALIGNMENT_NEEDED): Document.\n+\n+\t* pa.c (compute_frame_size): Rename fsize to size.  Account for\n+\talignment to a word boundary before general register save block.  Only\n+\taccount for double-word alignment before floating point register save\n+\tblock if one or more are saved.  Don't allocate space for %r3 when\n+\tframe pointer is needed.\n+\t(hppa_expand_prologue): Include alignment to word boundary in local\n+\tframe size.\n+\t* pa.h (STARTING_FRAME_OFFSET): Define to 8 on both 32 and 64-bit ports.\n+\t(STACK_ALIGNMENT_NEEDED): Define.\n+\n 2003-03-04  Kevin Buettner  <kevinb@redhat.com>\n \n \t* dwarf2out.c (rtl_for_decl_location): Don't return NULL_RTX for"}, {"sha": "0f1b894f89564f4b238bd26dd62020edd9a850e2", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 48, "deletions": 32, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95f3f59efde3d3138d216aca9d00913cb4c1a002/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95f3f59efde3d3138d216aca9d00913cb4c1a002/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=95f3f59efde3d3138d216aca9d00913cb4c1a002", "patch": "@@ -3195,15 +3195,24 @@ compute_frame_size (size, fregs_live)\n      int size;\n      int *fregs_live;\n {\n-  int i, fsize;\n-\n-  /* Space for frame pointer + filler. If any frame is allocated\n-     we need to add this in because of STARTING_FRAME_OFFSET.\n-\n-     Similar code also appears in hppa_expand_prologue.  Change both\n-     of them at the same time.  */\n-  fsize = size + (size || frame_pointer_needed ? STARTING_FRAME_OFFSET : 0);\n-\n+  int freg_saved = 0;\n+  int i, j;\n+\n+  /* The code in hppa_expand_prologue and hppa_expand_epilogue must\n+     be consistent with the rounding and size calculation done here.\n+     Change them at the same time.  */\n+\n+  /* We do our own stack alignment.  First, round the size of the\n+     stack locals up to a word boundary.  */\n+  size = (size + UNITS_PER_WORD - 1) & ~(UNITS_PER_WORD - 1);\n+\n+  /* Space for previous frame pointer + filler.  If any frame is\n+     allocated, we need to add in the STARTING_FRAME_OFFSET.  We\n+     waste some space here for the sake of HP compatibility.  The\n+     first slot is only used when the frame pointer is needed.  */\n+  if (size || frame_pointer_needed)\n+    size += STARTING_FRAME_OFFSET;\n+  \n   /* If the current function calls __builtin_eh_return, then we need\n      to allocate stack space for registers that will hold data for\n      the exception handler.  */\n@@ -3213,41 +3222,49 @@ compute_frame_size (size, fregs_live)\n \n       for (i = 0; EH_RETURN_DATA_REGNO (i) != INVALID_REGNUM; ++i)\n \tcontinue;\n-      fsize += i * UNITS_PER_WORD;\n+      size += i * UNITS_PER_WORD;\n     }\n \n   /* Account for space used by the callee general register saves.  */\n-  for (i = 18; i >= 3; i--)\n+  for (i = 18, j = frame_pointer_needed ? 4 : 3; i >= j; i--)\n     if (regs_ever_live[i])\n-      fsize += UNITS_PER_WORD;\n-\n-  /* Round the stack.  */\n-  fsize = (fsize + 7) & ~7;\n+      size += UNITS_PER_WORD;\n \n   /* Account for space used by the callee floating point register saves.  */\n   for (i = FP_SAVED_REG_LAST; i >= FP_SAVED_REG_FIRST; i -= FP_REG_STEP)\n     if (regs_ever_live[i]\n-\t|| (! TARGET_64BIT && regs_ever_live[i + 1]))\n+\t|| (!TARGET_64BIT && regs_ever_live[i + 1]))\n       {\n-\tif (fregs_live)\n-\t  *fregs_live = 1;\n+\tfreg_saved = 1;\n \n \t/* We always save both halves of the FP register, so always\n \t   increment the frame size by 8 bytes.  */\n-\tfsize += 8;\n+\tsize += 8;\n       }\n \n+  /* If any of the floating registers are saved, account for the\n+     alignment needed for the floating point register save block.  */\n+  if (freg_saved)\n+    {\n+      size = (size + 7) & ~7;\n+      if (fregs_live)\n+\t*fregs_live = 1;\n+    }\n+\n   /* The various ABIs include space for the outgoing parameters in the\n-     size of the current function's stack frame.  */\n-  fsize += current_function_outgoing_args_size;\n+     size of the current function's stack frame.  We don't need to align\n+     for the outgoing arguments as their alignment is set by the final\n+     rounding for the frame as a whole.  */\n+  size += current_function_outgoing_args_size;\n \n   /* Allocate space for the fixed frame marker.  This space must be\n      allocated for any function that makes calls or otherwise allocates\n      stack space.  */\n-  if (!current_function_is_leaf || fsize)\n-    fsize += TARGET_64BIT ? 16 : 32;\n+  if (!current_function_is_leaf || size)\n+    size += TARGET_64BIT ? 16 : 32;\n \n-  return ((fsize + PREFERRED_STACK_BOUNDARY / 8 - 1)\n+  /* Finally, round to the preferred stack boundary.  */\n+  return ((size + PREFERRED_STACK_BOUNDARY / 8 - 1)\n \t  & ~(PREFERRED_STACK_BOUNDARY / 8 - 1));\n }\n \n@@ -3313,22 +3330,21 @@ pa_output_function_prologue (file, size)\n void\n hppa_expand_prologue ()\n {\n-  int size = get_frame_size ();\n   int merge_sp_adjust_with_store = 0;\n+  int size = get_frame_size ();\n   int i, offset;\n   rtx insn, tmpreg;\n \n   gr_saved = 0;\n   fr_saved = 0;\n   save_fregs = 0;\n \n-  /* Allocate space for frame pointer + filler. If any frame is allocated\n-     we need to add this in because of STARTING_FRAME_OFFSET.\n-\n-     Similar code also appears in compute_frame_size.  Change both\n-     of them at the same time.  */\n-  local_fsize = size + (size || frame_pointer_needed\n-\t\t\t? STARTING_FRAME_OFFSET : 0);\n+  /* Compute total size for frame pointer, filler, locals and rounding to\n+     the next word boundary.  Similar code appears in compute_frame_size\n+     and must be changed in tandem with this code.  */\n+  local_fsize = (size + UNITS_PER_WORD - 1) & ~(UNITS_PER_WORD - 1);\n+  if (local_fsize || frame_pointer_needed)\n+    local_fsize += STARTING_FRAME_OFFSET;\n \n   actual_fsize = compute_frame_size (size, &save_fregs);\n "}, {"sha": "ba533ff0d4d6b876a4ebde8fe38870a63dd704d7", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95f3f59efde3d3138d216aca9d00913cb4c1a002/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95f3f59efde3d3138d216aca9d00913cb4c1a002/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=95f3f59efde3d3138d216aca9d00913cb4c1a002", "patch": "@@ -676,10 +676,17 @@ extern struct rtx_def *hppa_pic_save_rtx PARAMS ((void));\n /* Offset within stack frame to start allocating local variables at.\n    If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n    first local allocated.  Otherwise, it is the offset to the BEGINNING\n-   of the first local allocated.  The start of the locals must lie on\n-   a STACK_BOUNDARY or else the frame size of leaf functions will not\n-   be zero.  */\n-#define STARTING_FRAME_OFFSET (TARGET_64BIT ? 16 : 8)\n+   of the first local allocated.\n+\n+   On the 32-bit ports, we reserve one slot for the previous frame\n+   pointer and one fill slot.  The fill slot is for compatibility\n+   with HP compiled programs.  On the 64-bit ports, we reserve one\n+   slot for the previous frame pointer.  */\n+#define STARTING_FRAME_OFFSET 8\n+\n+/* Define STACK_ALIGNMENT_NEEDED to zero to disable final alignment\n+   of the stack.  The default is to align it to STACK_BOUNDARY.  */\n+#define STACK_ALIGNMENT_NEEDED 0\n \n /* If we generate an insn to push BYTES bytes,\n    this says how many the stack pointer really advances by."}, {"sha": "2d20c4f568cd471289bf7ff9fdb2c9e9dd88a5ca", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95f3f59efde3d3138d216aca9d00913cb4c1a002/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95f3f59efde3d3138d216aca9d00913cb4c1a002/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=95f3f59efde3d3138d216aca9d00913cb4c1a002", "patch": "@@ -2816,6 +2816,16 @@ value @code{STARTING_FRAME_OFFSET}.\n @c i'm not sure if the above is still correct.. had to change it to get\n @c rid of an overfull.  --mew 2feb93\n \n+@findex STACK_ALIGNMENT_NEEDED\n+@item STACK_ALIGNMENT_NEEDED\n+Define to zero to disable final alignment of the stack during reload.\n+The non-zero default for this macro is suitable for most ports.\n+\n+On ports where @code{STARTING_FRAME_OFFSET} is non-zero or where there\n+is a register save block following the local block that doesn't require\n+alignment to @code{STACK_BOUNDARY}, it may be beneficial to disable\n+stack alignment and do it in the backend.\n+\n @findex STACK_POINTER_OFFSET\n @item STACK_POINTER_OFFSET\n Offset from the stack pointer register to the first location at which"}, {"sha": "73527bc037e453981bf59144b33ba7969987d55d", "filename": "gcc/function.c", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95f3f59efde3d3138d216aca9d00913cb4c1a002/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95f3f59efde3d3138d216aca9d00913cb4c1a002/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=95f3f59efde3d3138d216aca9d00913cb4c1a002", "patch": "@@ -70,6 +70,10 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define LOCAL_ALIGNMENT(TYPE, ALIGNMENT) ALIGNMENT\n #endif\n \n+#ifndef STACK_ALIGNMENT_NEEDED\n+#define STACK_ALIGNMENT_NEEDED 1\n+#endif\n+\n /* Some systems use __main in a way incompatible with its use in gcc, in these\n    cases use the macros NAME__MAIN to give a quoted symbol and SYMBOL__MAIN to\n    give the same symbol without quotes for an alternative entry point.  You\n@@ -566,16 +570,27 @@ assign_stack_local_1 (mode, size, align, function)\n   frame_off = STARTING_FRAME_OFFSET % frame_alignment;\n   frame_phase = frame_off ? frame_alignment - frame_off : 0;\n \n-  /* Round frame offset to that alignment.\n-     We must be careful here, since FRAME_OFFSET might be negative and\n-     division with a negative dividend isn't as well defined as we might\n-     like.  So we instead assume that ALIGNMENT is a power of two and\n-     use logical operations which are unambiguous.  */\n+  /* Round the frame offset to the specified alignment.  The default is\n+     to always honor requests to align the stack but a port may choose to\n+     do its own stack alignment by defining STACK_ALIGNMENT_NEEDED.  */\n+  if (STACK_ALIGNMENT_NEEDED\n+      || mode != BLKmode\n+      || size != 0)\n+    {\n+      /*  We must be careful here, since FRAME_OFFSET might be negative and\n+\t  division with a negative dividend isn't as well defined as we might\n+\t  like.  So we instead assume that ALIGNMENT is a power of two and\n+\t  use logical operations which are unambiguous.  */\n #ifdef FRAME_GROWS_DOWNWARD\n-  function->x_frame_offset = FLOOR_ROUND (function->x_frame_offset - frame_phase, alignment) + frame_phase;\n+      function->x_frame_offset\n+\t= (FLOOR_ROUND (function->x_frame_offset - frame_phase, alignment)\n+\t   + frame_phase);\n #else\n-  function->x_frame_offset = CEIL_ROUND (function->x_frame_offset - frame_phase, alignment) + frame_phase;\n+      function->x_frame_offset\n+\t= (CEIL_ROUND (function->x_frame_offset - frame_phase, alignment)\n+\t   + frame_phase);\n #endif\n+    }\n \n   /* On a big-endian machine, if we are allocating more space than we will use,\n      use the least significant bytes of those that are allocated.  */"}]}