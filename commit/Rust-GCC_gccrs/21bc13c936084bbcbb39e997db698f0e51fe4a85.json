{"sha": "21bc13c936084bbcbb39e997db698f0e51fe4a85", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjFiYzEzYzkzNjA4NGJiY2JiMzllOTk3ZGI2OThmMGU1MWZlNGE4NQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2000-11-20T21:40:30Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-11-20T21:40:30Z"}, "message": "dwarf.h (FMT_CODE): Adjust argument order; fix mapping to dwarf_subscr_data_formats bits.\n\n        * dwarf.h (FMT_CODE): Adjust argument order; fix mapping to\n        dwarf_subscr_data_formats bits.\n        * dwarfout.c (simple_type_size_in_bits): Handle a type with\n        no computed size as size zero.\n        (field_byte_offset): Likewise.\n        (subscript_data_attribute): Handle a range with no upper bound.\n\nFrom-SVN: r37592", "tree": {"sha": "0cfb9ab98ee807bf855b7a54fccfd68f71ac76c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0cfb9ab98ee807bf855b7a54fccfd68f71ac76c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/21bc13c936084bbcbb39e997db698f0e51fe4a85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21bc13c936084bbcbb39e997db698f0e51fe4a85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21bc13c936084bbcbb39e997db698f0e51fe4a85", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21bc13c936084bbcbb39e997db698f0e51fe4a85/comments", "author": null, "committer": null, "parents": [{"sha": "5e90dd7193a80566748d8681500984b53d9b957c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e90dd7193a80566748d8681500984b53d9b957c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e90dd7193a80566748d8681500984b53d9b957c"}], "stats": {"total": 53, "additions": 28, "deletions": 25}, "files": [{"sha": "1eda6663b8ea466e220df3d969d81139ff6af10b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21bc13c936084bbcbb39e997db698f0e51fe4a85/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21bc13c936084bbcbb39e997db698f0e51fe4a85/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=21bc13c936084bbcbb39e997db698f0e51fe4a85", "patch": "@@ -1,3 +1,12 @@\n+2000-11-20  Richard Henderson  <rth@redhat.com>\n+\n+\t* dwarf.h (FMT_CODE): Adjust argument order; fix mapping to\n+\tdwarf_subscr_data_formats bits.\n+\t* dwarfout.c (simple_type_size_in_bits): Handle a type with\n+\tno computed size as size zero.\n+\t(field_byte_offset): Likewise.\n+\t(subscript_data_attribute): Handle a range with no upper bound.\n+\n 2000-11-20  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* gansidecl.h (const): Check __STDC__ before undef'ing `const'."}, {"sha": "876bdc0abe5776c1f0f960b33853a4b1a1013b83", "filename": "gcc/dwarf.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21bc13c936084bbcbb39e997db698f0e51fe4a85/gcc%2Fdwarf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21bc13c936084bbcbb39e997db698f0e51fe4a85/gcc%2Fdwarf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf.h?ref=21bc13c936084bbcbb39e997db698f0e51fe4a85", "patch": "@@ -285,10 +285,10 @@ enum dwarf_subscr_data_formats {\n \n /* Derived from above for ease of use.  */\n \n-#define FMT_CODE(_FUNDAMENTAL_TYPE_P, _UB_CONST_P, _LB_CONST_P) \\\n+#define FMT_CODE(_FUNDAMENTAL_TYPE_P, _LB_CONST_P, _UB_CONST_P) \\\n  (((_FUNDAMENTAL_TYPE_P) ? 0 : 4)\t\\\n-  | ((_UB_CONST_P) ? 0 : 2)\t\t\\\n-  | ((_LB_CONST_P) ? 0 : 1))\n+  | ((_LB_CONST_P) ? 0 : 2)\t\t\\\n+  | ((_UB_CONST_P) ? 0 : 1))\n \n /* Source language names and codes.  */\n "}, {"sha": "e339820e87dac211c1cb592ffcf284bd374c11ad", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21bc13c936084bbcbb39e997db698f0e51fe4a85/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21bc13c936084bbcbb39e997db698f0e51fe4a85/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=21bc13c936084bbcbb39e997db698f0e51fe4a85", "patch": "@@ -1886,17 +1886,17 @@ static inline unsigned HOST_WIDE_INT\n simple_type_size_in_bits (type)\n      register tree type;\n {\n+  tree type_size_tree;\n+\n   if (TREE_CODE (type) == ERROR_MARK)\n     return BITS_PER_WORD;\n-  else\n-    {\n-      register tree type_size_tree = TYPE_SIZE (type);\n+  type_size_tree = TYPE_SIZE (type);\n \n-      if (! host_integerp (type_size_tree, 1))\n-\treturn TYPE_ALIGN (type);\n-\n-      return tree_low_cst (type_size_tree, 1);\n-    }\n+  if (type_size_tree == NULL_TREE)\n+    return 0;\n+  if (! host_integerp (type_size_tree, 1))\n+    return TYPE_ALIGN (type);\n+  return tree_low_cst (type_size_tree, 1);\n }\n \n /* Given a pointer to what is assumed to be a FIELD_DECL node, compute and\n@@ -1931,15 +1931,11 @@ field_byte_offset (decl)\n   type = field_type (decl);\n   field_size_tree = DECL_SIZE (decl);\n \n-  /* If there was an error, the size could be zero.  */\n+  /* The size could be unspecified if there was an error, or for\n+     a flexible array member.  */\n   if (! field_size_tree)\n-    {\n-      if (errorcount)\n-\treturn 0;\n+    field_size_tree = bitsize_zero_node;\n \n-      abort ();\n-    }\n-    \n   /* We cannot yet cope with fields whose positions or sizes are variable,\n      so for now, when we see such things, we simply return 0.  Someday,\n      we may be able to handle such cases, but it will be damn difficult.  */\n@@ -2533,28 +2529,26 @@ subscript_data_attribute (type)\n \t  register tree upper = TYPE_MAX_VALUE (domain);\n \n \t  /* Handle only fundamental types as index types for now.  */\n-\n \t  if (! type_is_fundamental (domain))\n \t    abort ();\n \n \t  /* Output the representation format byte for this dimension.  */\n-\n \t  ASM_OUTPUT_DWARF_FMT_BYTE (asm_out_file,\n \t\t  FMT_CODE (1, TREE_CODE (lower) == INTEGER_CST,\n-\t\t\t    (upper && TREE_CODE (upper) == INTEGER_CST)));\n+\t\t\t    upper && TREE_CODE (upper) == INTEGER_CST));\n \n \t  /* Output the index type for this dimension.\t*/\n-\n \t  ASM_OUTPUT_DWARF_FUND_TYPE (asm_out_file,\n \t\t\t\t      fundamental_type_code (domain));\n \n \t  /* Output the representation for the lower bound.  */\n-\n \t  output_bound_representation (lower, dimension_number, 'l');\n \n \t  /* Output the representation for the upper bound.  */\n-\n-\t  output_bound_representation (upper, dimension_number, 'u');\n+\t  if (upper)\n+\t    output_bound_representation (upper, dimension_number, 'u');\n+\t  else\n+\t    ASM_OUTPUT_DWARF_DATA2 (asm_out_file, 0);\n \t}\n       else\n \t{"}]}