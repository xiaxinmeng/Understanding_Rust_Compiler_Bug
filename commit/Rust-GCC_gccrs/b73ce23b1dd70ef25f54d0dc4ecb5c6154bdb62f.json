{"sha": "b73ce23b1dd70ef25f54d0dc4ecb5c6154bdb62f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjczY2UyM2IxZGQ3MGVmMjVmNTRkMGRjNGVjYjVjNjE1NGJkYjYyZg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2004-08-01T11:17:36Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2004-08-01T11:17:36Z"}, "message": "mips-protos.h (mips_gp_save_slot): Remove.\n\n\t* config/mips/mips-protos.h (mips_gp_save_slot): Remove.\n\t(mips_restore_gp): Declare.\n\t* config/mips/mips.c (mips_add_offset): Add a scratch register\n\targument.  Reimplement in rtl only, reusing MIPS16 logic from\n\tmips_output_mi_thunk.\n\t(mips_legitimize_address, mips_legitimize_const_move): Adjust calls\n\tto mips_add_offset.\n\t(mips_gp_save_slot): Delete.\n\t(mips_restore_gp): New function.\n\t(mips_set_return_address, mips_output_mi_thunk): Use mips_add_offset.\n\t* config/mips/mips.md (exception_receiver): Turn into a\n\tdefine_insn_and_split.  Use mips_restore_gp to do the split.\n\t(call_internal, call_value_internal, call_value_multiple_internal): Use\n\tmips_restore_gp to restore $gp.\n\nFrom-SVN: r85404", "tree": {"sha": "c251433a454204a66345776cefcca7e8724630a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c251433a454204a66345776cefcca7e8724630a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b73ce23b1dd70ef25f54d0dc4ecb5c6154bdb62f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b73ce23b1dd70ef25f54d0dc4ecb5c6154bdb62f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b73ce23b1dd70ef25f54d0dc4ecb5c6154bdb62f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b73ce23b1dd70ef25f54d0dc4ecb5c6154bdb62f/comments", "author": null, "committer": null, "parents": [{"sha": "b828123e23c9a8fb42b98a54b34141fe4dace764", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b828123e23c9a8fb42b98a54b34141fe4dace764", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b828123e23c9a8fb42b98a54b34141fe4dace764"}], "stats": {"total": 142, "additions": 75, "deletions": 67}, "files": [{"sha": "c47eb67d5862967d881ea1e3cd28ec56d733be6e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b73ce23b1dd70ef25f54d0dc4ecb5c6154bdb62f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b73ce23b1dd70ef25f54d0dc4ecb5c6154bdb62f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b73ce23b1dd70ef25f54d0dc4ecb5c6154bdb62f", "patch": "@@ -1,3 +1,20 @@\n+2004-08-01  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/mips/mips-protos.h (mips_gp_save_slot): Remove.\n+\t(mips_restore_gp): Declare.\n+\t* config/mips/mips.c (mips_add_offset): Add a scratch register\n+\targument.  Reimplement in rtl only, reusing MIPS16 logic from\n+\tmips_output_mi_thunk.\n+\t(mips_legitimize_address, mips_legitimize_const_move): Adjust calls\n+\tto mips_add_offset.\n+\t(mips_gp_save_slot): Delete.\n+\t(mips_restore_gp): New function.\n+\t(mips_set_return_address, mips_output_mi_thunk): Use mips_add_offset.\n+\t* config/mips/mips.md (exception_receiver): Turn into a\n+\tdefine_insn_and_split.  Use mips_restore_gp to do the split.\n+\t(call_internal, call_value_internal, call_value_multiple_internal): Use\n+\tmips_restore_gp to restore $gp.\n+\n 2004-07-31  Andrew Pinski  <apinski@apple.com>\n \n \tPR other/16842"}, {"sha": "f09d704b86202054c66c9ebf3c4f3f1b77d1ebf0", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b73ce23b1dd70ef25f54d0dc4ecb5c6154bdb62f/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b73ce23b1dd70ef25f54d0dc4ecb5c6154bdb62f/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=b73ce23b1dd70ef25f54d0dc4ecb5c6154bdb62f", "patch": "@@ -121,7 +121,7 @@ extern rtx mips_subword (rtx, int);\n extern bool mips_split_64bit_move_p (rtx, rtx);\n extern void mips_split_64bit_move (rtx, rtx);\n extern const char *mips_output_move (rtx, rtx);\n-extern rtx mips_gp_save_slot (void);\n+extern void mips_restore_gp (void);\n #ifdef RTX_CODE\n extern bool mips_emit_scc (enum rtx_code, rtx);\n extern void gen_conditional_branch (rtx *, enum rtx_code);"}, {"sha": "825172b005888007786843971741588d4418e97f", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 47, "deletions": 58, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b73ce23b1dd70ef25f54d0dc4ecb5c6154bdb62f/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b73ce23b1dd70ef25f54d0dc4ecb5c6154bdb62f/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=b73ce23b1dd70ef25f54d0dc4ecb5c6154bdb62f", "patch": "@@ -164,7 +164,7 @@ static bool mips16_unextended_reference_p (enum machine_mode mode, rtx, rtx);\n static rtx mips_force_temporary (rtx, rtx);\n static rtx mips_split_symbol (rtx, rtx);\n static rtx mips_unspec_offset_high (rtx, rtx, rtx, enum mips_symbol_type);\n-static rtx mips_add_offset (rtx, HOST_WIDE_INT);\n+static rtx mips_add_offset (rtx, rtx, HOST_WIDE_INT);\n static unsigned int mips_build_shift (struct mips_integer_op *, HOST_WIDE_INT);\n static unsigned int mips_build_lower (struct mips_integer_op *,\n \t\t\t\t      unsigned HOST_WIDE_INT);\n@@ -1742,18 +1742,33 @@ mips_unspec_offset_high (rtx temp, rtx base, rtx addr,\n }\n \n \n-/* Return a legitimate address for REG + OFFSET.  This function will\n-   create a temporary register if OFFSET is not a SMALL_OPERAND.  */\n+/* Return a legitimate address for REG + OFFSET.  TEMP is as for\n+   mips_force_temporary; it is only needed when OFFSET is not a\n+   SMALL_OPERAND.  */\n \n static rtx\n-mips_add_offset (rtx reg, HOST_WIDE_INT offset)\n+mips_add_offset (rtx temp, rtx reg, HOST_WIDE_INT offset)\n {\n   if (!SMALL_OPERAND (offset))\n-    reg = expand_simple_binop (GET_MODE (reg), PLUS,\n-\t\t\t       GEN_INT (CONST_HIGH_PART (offset)),\n-\t\t\t       reg, NULL, 0, OPTAB_WIDEN);\n-\n-  return plus_constant (reg, CONST_LOW_PART (offset));\n+    {\n+      rtx high;\n+      if (TARGET_MIPS16)\n+\t{\n+\t  /* Load the full offset into a register so that we can use\n+\t     an unextended instruction for the address itself.  */\n+\t  high = GEN_INT (offset);\n+\t  offset = 0;\n+\t}\n+      else\n+\t{\n+\t  /* Leave OFFSET as a 16-bit offset and put the excess in HIGH.  */\n+\t  high = GEN_INT (CONST_HIGH_PART (offset));\n+\t  offset = CONST_LOW_PART (offset);\n+\t}\n+      high = mips_force_temporary (temp, high);\n+      reg = mips_force_temporary (temp, gen_rtx_PLUS (Pmode, high, reg));\n+    }\n+  return plus_constant (reg, offset);\n }\n \n \n@@ -1784,7 +1799,7 @@ mips_legitimize_address (rtx *xloc, enum machine_mode mode)\n       reg = XEXP (*xloc, 0);\n       if (!mips_valid_base_register_p (reg, mode, 0))\n \treg = copy_to_mode_reg (Pmode, reg);\n-      *xloc = mips_add_offset (reg, INTVAL (XEXP (*xloc, 1)));\n+      *xloc = mips_add_offset (0, reg, INTVAL (XEXP (*xloc, 1)));\n       return true;\n     }\n \n@@ -1962,7 +1977,7 @@ mips_legitimize_const_move (enum machine_mode mode, rtx dest, rtx src)\n       && (!no_new_pseudos || SMALL_OPERAND (offset)))\n     {\n       base = mips_force_temporary (dest, base);\n-      emit_move_insn (dest, mips_add_offset (base, offset));\n+      emit_move_insn (dest, mips_add_offset (0, base, offset));\n       return;\n     }\n \n@@ -2666,25 +2681,28 @@ mips_output_move (rtx dest, rtx src)\n   abort ();\n }\n \f\n-/* Return an rtx for the gp save slot.  Valid only when using o32 or\n+/* Restore $gp from its save slot.  Valid only when using o32 or\n    o64 abicalls.  */\n \n-rtx\n-mips_gp_save_slot (void)\n+void\n+mips_restore_gp (void)\n {\n-  rtx loc;\n+  rtx address, slot;\n \n-  if (!TARGET_ABICALLS || TARGET_NEWABI)\n+  if (!TARGET_ABICALLS || !TARGET_OLDABI)\n     abort ();\n \n-  if (frame_pointer_needed)\n-    loc = hard_frame_pointer_rtx;\n-  else\n-    loc = stack_pointer_rtx;\n-  loc = plus_constant (loc, current_function_outgoing_args_size);\n-  loc = gen_rtx_MEM (Pmode, loc);\n-  RTX_UNCHANGING_P (loc) = 1;\n-  return loc;\n+  address = mips_add_offset (pic_offset_table_rtx,\n+\t\t\t     frame_pointer_needed\n+\t\t\t     ? hard_frame_pointer_rtx\n+\t\t\t     : stack_pointer_rtx,\n+\t\t\t     current_function_outgoing_args_size);\n+  slot = gen_rtx_MEM (Pmode, address);\n+  RTX_UNCHANGING_P (slot) = 1;\n+\n+  emit_move_insn (pic_offset_table_rtx, slot);\n+  if (!TARGET_EXPLICIT_RELOCS)\n+    emit_insn (gen_blockage ());\n }\n \f\n /* Emit an instruction of the form (set TARGET (CODE OP0 OP1)).  */\n@@ -3101,26 +3119,15 @@ mips_emit_fcc_reload (rtx dest, rtx src, rtx scratch)\n void\n mips_set_return_address (rtx address, rtx scratch)\n {\n-  HOST_WIDE_INT gp_offset;\n+  rtx slot_address;\n \n   compute_frame_size (get_frame_size ());\n   if (((cfun->machine->frame.mask >> 31) & 1) == 0)\n     abort ();\n-  gp_offset = cfun->machine->frame.gp_sp_offset;\n-\n-  /* Reduce SP + GP_OFSET to a legitimate address and put it in SCRATCH.  */\n-  if (gp_offset < 32768)\n-    scratch = plus_constant (stack_pointer_rtx, gp_offset);\n-  else\n-    {\n-      emit_move_insn (scratch, GEN_INT (gp_offset));\n-      if (Pmode == DImode)\n-\temit_insn (gen_adddi3 (scratch, scratch, stack_pointer_rtx));\n-      else\n-\temit_insn (gen_addsi3 (scratch, scratch, stack_pointer_rtx));\n-    }\n+  slot_address = mips_add_offset (scratch, stack_pointer_rtx,\n+\t\t\t\t  cfun->machine->frame.gp_sp_offset);\n \n-  emit_move_insn (gen_rtx_MEM (GET_MODE (address), scratch), address);\n+  emit_move_insn (gen_rtx_MEM (GET_MODE (address), slot_address), address);\n }\n \f\n /* Emit straight-line code to move LENGTH bytes from SRC to DEST.\n@@ -6773,25 +6780,7 @@ mips_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n       emit_move_insn (temp1, gen_rtx_MEM (Pmode, this));\n \n       /* Set ADDR to a legitimate address for *THIS + VCALL_OFFSET.  */\n-      if (SMALL_OPERAND (vcall_offset))\n-\taddr = gen_rtx_PLUS (Pmode, temp1, GEN_INT (vcall_offset));\n-      else if (TARGET_MIPS16)\n-\t{\n-\t  /* Load the full offset into a register so that we can use\n-\t     an unextended instruction for the load itself.  */\n-\t  emit_move_insn (temp2, GEN_INT (vcall_offset));\n-\t  emit_insn (gen_add3_insn (temp1, temp1, temp2));\n-\t  addr = temp1;\n-\t}\n-      else\n-\t{\n-\t  /* Load the high part of the offset into a register and\n-\t     leave the low part for the address.  */\n-\t  emit_move_insn (temp2, GEN_INT (CONST_HIGH_PART (vcall_offset)));\n-\t  emit_insn (gen_add3_insn (temp1, temp1, temp2));\n-\t  addr = gen_rtx_PLUS (Pmode, temp1,\n-\t\t\t       GEN_INT (CONST_LOW_PART (vcall_offset)));\n-\t}\n+      addr = mips_add_offset (temp2, temp1, vcall_offset);\n \n       /* Load the offset and add it to THIS.  */\n       emit_move_insn (temp1, gen_rtx_MEM (Pmode, addr));"}, {"sha": "586f12df1770de15a0a893304ab630540d59e1b2", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b73ce23b1dd70ef25f54d0dc4ecb5c6154bdb62f/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b73ce23b1dd70ef25f54d0dc4ecb5c6154bdb62f/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=b73ce23b1dd70ef25f54d0dc4ecb5c6154bdb62f", "patch": "@@ -6860,17 +6860,19 @@ dsrl\\t%3,%3,1\\n\\\n   DONE;\n })\n \n-(define_insn \"exception_receiver\"\n+(define_insn_and_split \"exception_receiver\"\n   [(set (reg:SI 28)\n \t(unspec_volatile:SI [(const_int 0)] UNSPEC_EH_RECEIVER))]\n   \"TARGET_ABICALLS && TARGET_OLDABI\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n {\n-  operands[0] = pic_offset_table_rtx;\n-  operands[1] = mips_gp_save_slot ();\n-  return mips_output_move (operands[0], operands[1]);\n+  mips_restore_gp ();\n+  DONE;\n }\n   [(set_attr \"type\"   \"load\")\n-   (set_attr \"length\" \"8\")])\n+   (set_attr \"length\" \"12\")])\n \f\n ;;\n ;;  ....................\n@@ -7041,7 +7043,7 @@ dsrl\\t%3,%3,1\\n\\\n {\n   emit_call_insn (gen_call_split (operands[0], operands[1]));\n   if (!find_reg_note (operands[2], REG_NORETURN, 0))\n-    emit_move_insn (pic_offset_table_rtx, mips_gp_save_slot ());\n+    mips_restore_gp ();\n   DONE;\n }\n   [(set_attr \"jal\" \"indirect,direct\")\n@@ -7082,7 +7084,7 @@ dsrl\\t%3,%3,1\\n\\\n   emit_call_insn (gen_call_value_split (operands[0], operands[1],\n \t\t\t\t\toperands[2]));\n   if (!find_reg_note (operands[3], REG_NORETURN, 0))\n-    emit_move_insn (pic_offset_table_rtx, mips_gp_save_slot ());\n+    mips_restore_gp ();\n   DONE;\n }\n   [(set_attr \"jal\" \"indirect,direct\")\n@@ -7115,7 +7117,7 @@ dsrl\\t%3,%3,1\\n\\\n   emit_call_insn (gen_call_value_multiple_split (operands[0], operands[1],\n \t\t\t\t\t\t operands[2], operands[3]));\n   if (!find_reg_note (operands[4], REG_NORETURN, 0))\n-    emit_move_insn (pic_offset_table_rtx, mips_gp_save_slot ());\n+    mips_restore_gp ();\n   DONE;\n }\n   [(set_attr \"jal\" \"indirect,direct\")"}]}