{"sha": "f6d984843095c520ceb89cf374c7a13bb6a06a99", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjZkOTg0ODQzMDk1YzUyMGNlYjg5Y2YzNzRjN2ExM2JiNmEwNmE5OQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2012-11-12T15:51:53Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2012-11-12T15:51:53Z"}, "message": "Emit GIMPLE directly instead of gimplifying GENERIC.\n\nThis patch cleanups the instrumentation code generation by emitting\nGIMPLE directly, as opposed to emitting GENERIC tree and then\ngimplifying them.  It also does some cleanups here and there\n\n\t* Makefile.in (GTFILES): Add $(srcdir)/asan.c.\n\t(asan.o): Update the dependencies of asan.o.\n\t* asan.c (tm.h, tree.h, tm_p.h, basic-block.h, flags.h\n\tfunction.h, tree-inline.h, tree-dump.h, diagnostic.h, demangle.h,\n\tlanghooks.h, ggc.h, cgraph.h, gimple.h): Remove these unused but\n\tincluded headers.\n\t(shadow_ptr_types): New variable.\n\t(report_error_func): Change is_store argument to bool, don't append\n\tnewline to function name.\n\t(PROB_VERY_UNLIKELY, PROB_ALWAYS): Define.\n\t(build_check_stmt): Change is_store argument to bool.  Emit GIMPLE\n\tdirectly instead of creating trees and gimplifying them.  Mark\n\tthe error reporting function as very unlikely.\n\t(instrument_derefs): Change is_store argument to bool.  Use\n\tint_size_in_bytes to compute size_in_bytes, simplify size check.\n\tUse build_fold_addr_expr instead of build_addr.\n\t(transform_statements): Adjust instrument_derefs caller.\n\tUse gimple_assign_single_p as stmt test.  Don't look at MEM refs\n\tin rhs2.\n\t(asan_init_shadow_ptr_types): New function.\n\t(asan_instrument): Don't push/pop gimplify context.\n\tCall asan_init_shadow_ptr_types if not yet initialized.\n\t* asan.h (ASAN_SHADOW_SHIFT): Adjust comment.\n\nCo-Authored-By: Dodji Seketeli <dodji@redhat.com>\nCo-Authored-By: Xinliang David Li <davidxl@google.com>\n\nFrom-SVN: r193434", "tree": {"sha": "b173d56b8e20edfc4ce9cd2ad77776335bac544e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b173d56b8e20edfc4ce9cd2ad77776335bac544e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f6d984843095c520ceb89cf374c7a13bb6a06a99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6d984843095c520ceb89cf374c7a13bb6a06a99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6d984843095c520ceb89cf374c7a13bb6a06a99", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6d984843095c520ceb89cf374c7a13bb6a06a99/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dfe06d3e7f7719d2fc8ef7b7c7ca88e7277e7593", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfe06d3e7f7719d2fc8ef7b7c7ca88e7277e7593", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfe06d3e7f7719d2fc8ef7b7c7ca88e7277e7593"}], "stats": {"total": 323, "additions": 200, "deletions": 123}, "files": [{"sha": "e31d6bad9dd7f6cb074d7f50fd882de8199097d0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d984843095c520ceb89cf374c7a13bb6a06a99/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d984843095c520ceb89cf374c7a13bb6a06a99/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f6d984843095c520ceb89cf374c7a13bb6a06a99", "patch": "@@ -1,3 +1,31 @@\n+2012-11-12  Jakub Jelinek  <jakub@redhat.com>\n+\t    Xinliang David Li  <davidxl@google.com>\n+\t    Dodji Seketeli <dodji@redhat.com>\n+\n+\t* Makefile.in (GTFILES): Add $(srcdir)/asan.c.\n+\t(asan.o): Update the dependencies of asan.o.\n+\t* asan.c (tm.h, tree.h, tm_p.h, basic-block.h, flags.h\n+\tfunction.h, tree-inline.h, tree-dump.h, diagnostic.h, demangle.h,\n+\tlanghooks.h, ggc.h, cgraph.h, gimple.h): Remove these unused but\n+\tincluded headers.\n+\t(shadow_ptr_types): New variable.\n+\t(report_error_func): Change is_store argument to bool, don't append\n+\tnewline to function name.\n+\t(PROB_VERY_UNLIKELY, PROB_ALWAYS): Define.\n+\t(build_check_stmt): Change is_store argument to bool.  Emit GIMPLE\n+\tdirectly instead of creating trees and gimplifying them.  Mark\n+\tthe error reporting function as very unlikely.\n+\t(instrument_derefs): Change is_store argument to bool.  Use\n+\tint_size_in_bytes to compute size_in_bytes, simplify size check.\n+\tUse build_fold_addr_expr instead of build_addr.\n+\t(transform_statements): Adjust instrument_derefs caller.\n+\tUse gimple_assign_single_p as stmt test.  Don't look at MEM refs\n+\tin rhs2.\n+\t(asan_init_shadow_ptr_types): New function.\n+\t(asan_instrument): Don't push/pop gimplify context.\n+\tCall asan_init_shadow_ptr_types if not yet initialized.\n+\t* asan.h (ASAN_SHADOW_SHIFT): Adjust comment.\n+\n 2012-11-12  Jakub Jelinek  <jakub@redhat.com>\n \n \t* toplev.c (process_options): Warn and turn off"}, {"sha": "b9a1e7477fdaac989a4b336268388d070aeab57f", "filename": "gcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d984843095c520ceb89cf374c7a13bb6a06a99/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d984843095c520ceb89cf374c7a13bb6a06a99/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=f6d984843095c520ceb89cf374c7a13bb6a06a99", "patch": "@@ -2208,10 +2208,10 @@ stor-layout.o : stor-layout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) $(PARAMS_H) $(FLAGS_H) $(FUNCTION_H) $(EXPR_H) $(RTL_H) \\\n    $(GGC_H) $(TM_P_H) $(TARGET_H) langhooks.h $(REGS_H) gt-stor-layout.h \\\n    $(DIAGNOSTIC_CORE_H) $(CGRAPH_H) $(TREE_INLINE_H) $(TREE_DUMP_H) $(GIMPLE_H)\n-asan.o : asan.c asan.h $(CONFIG_H) pointer-set.h \\\n-   $(SYSTEM_H) $(TREE_H) $(GIMPLE_H) \\\n-   output.h $(DIAGNOSTIC_H) coretypes.h $(TREE_DUMP_H) $(FLAGS_H) \\\n-   tree-pretty-print.h $(TARGET_H)\n+asan.o : asan.c asan.h $(CONFIG_H) $(SYSTEM_H) $(GIMPLE_H) \\\n+   output.h coretypes.h $(GIMPLE_PRETTY_PRINT_H) \\\n+   tree-iterator.h $(TREE_FLOW_H) $(TREE_PASS_H) \\\n+   $(TARGET_H)\n tree-ssa-tail-merge.o: tree-ssa-tail-merge.c \\\n    $(SYSTEM_H) $(CONFIG_H) coretypes.h $(TM_H) $(BITMAP_H) \\\n    $(FLAGS_H) $(TM_P_H) $(BASIC_BLOCK_H) \\\n@@ -3725,6 +3725,7 @@ GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/lto-streamer.h \\\n   $(srcdir)/target-globals.h \\\n   $(srcdir)/ipa-inline.h \\\n+  $(srcdir)/asan.c \\\n   @all_gtfiles@\n \n # Compute the list of GT header files from the corresponding C sources,"}, {"sha": "04b11e579ac85f698b8ab0d50c041715adbd8bc1", "filename": "gcc/asan.c", "status": "modified", "additions": 166, "deletions": 118, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d984843095c520ceb89cf374c7a13bb6a06a99/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d984843095c520ceb89cf374c7a13bb6a06a99/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=f6d984843095c520ceb89cf374c7a13bb6a06a99", "patch": "@@ -22,24 +22,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"tree.h\"\n-#include \"tm_p.h\"\n-#include \"basic-block.h\"\n-#include \"flags.h\"\n-#include \"function.h\"\n-#include \"tree-inline.h\"\n #include \"gimple.h\"\n #include \"tree-iterator.h\"\n #include \"tree-flow.h\"\n-#include \"tree-dump.h\"\n #include \"tree-pass.h\"\n-#include \"diagnostic.h\"\n-#include \"demangle.h\"\n-#include \"langhooks.h\"\n-#include \"ggc.h\"\n-#include \"cgraph.h\"\n-#include \"gimple.h\"\n #include \"asan.h\"\n #include \"gimple-pretty-print.h\"\n #include \"target.h\"\n@@ -79,18 +65,22 @@ along with GCC; see the file COPYING3.  If not see\n  to create redzones for stack and global object and poison them.\n */\n \n+/* Pointer types to 1 resp. 2 byte integers in shadow memory.  A separate\n+   alias set is used for all shadow memory accesses.  */\n+static GTY(()) tree shadow_ptr_types[2];\n+\n /* Construct a function tree for __asan_report_{load,store}{1,2,4,8,16}.\n    IS_STORE is either 1 (for a store) or 0 (for a load).\n    SIZE_IN_BYTES is one of 1, 2, 4, 8, 16.  */\n \n static tree\n-report_error_func (int is_store, int size_in_bytes)\n+report_error_func (bool is_store, int size_in_bytes)\n {\n   tree fn_type;\n   tree def;\n   char name[100];\n \n-  sprintf (name, \"__asan_report_%s%d\\n\",\n+  sprintf (name, \"__asan_report_%s%d\",\n            is_store ? \"store\" : \"load\", size_in_bytes);\n   fn_type = build_function_type_list (void_type_node, ptr_type_node, NULL_TREE);\n   def = build_fn_decl (name, fn_type);\n@@ -118,6 +108,9 @@ asan_init_func (void)\n }\n \n \n+#define PROB_VERY_UNLIKELY\t(REG_BR_PROB_BASE / 2000 - 1)\n+#define PROB_ALWAYS\t\t(REG_BR_PROB_BASE)\n+\n /* Instrument the memory access instruction BASE.\n    Insert new statements before ITER.\n    LOCATION is source code location.\n@@ -127,21 +120,17 @@ asan_init_func (void)\n static void\n build_check_stmt (tree base,\n                   gimple_stmt_iterator *iter,\n-                  location_t location, int is_store, int size_in_bytes)\n+                  location_t location, bool is_store, int size_in_bytes)\n {\n   gimple_stmt_iterator gsi;\n   basic_block cond_bb, then_bb, join_bb;\n   edge e;\n-  tree cond, t, u;\n-  tree base_addr;\n-  tree shadow_value;\n+  tree t, base_addr, shadow;\n   gimple g;\n-  gimple_seq seq, stmts;\n-  tree shadow_type = size_in_bytes == 16 ?\n-      short_integer_type_node : char_type_node;\n-  tree shadow_ptr_type = build_pointer_type (shadow_type);\n-  tree uintptr_type = lang_hooks.types.type_for_mode (ptr_mode,\n-                                                      /*unsignedp=*/true);\n+  tree shadow_ptr_type = shadow_ptr_types[size_in_bytes == 16 ? 1 : 0];\n+  tree shadow_type = TREE_TYPE (shadow_ptr_type);\n+  tree uintptr_type\n+    = build_nonstandard_integer_type (TYPE_PRECISION (TREE_TYPE (base)), 1);\n \n   /* We first need to split the current basic block, and start altering\n      the CFG.  This allows us to insert the statements we're about to\n@@ -166,14 +155,15 @@ build_check_stmt (tree base,\n \n   /* Create the bb that contains the crash block.  */\n   then_bb = create_empty_bb (cond_bb);\n-  make_edge (cond_bb, then_bb, EDGE_TRUE_VALUE);\n+  e = make_edge (cond_bb, then_bb, EDGE_TRUE_VALUE);\n+  e->probability = PROB_VERY_UNLIKELY;\n   make_single_succ_edge (then_bb, join_bb, EDGE_FALLTHRU);\n \n   /* Mark the pseudo-fallthrough edge from cond_bb to join_bb.  */\n   e = find_edge (cond_bb, join_bb);\n   e->flags = EDGE_FALSE_VALUE;\n   e->count = cond_bb->count;\n-  e->probability = REG_BR_PROB_BASE;\n+  e->probability = PROB_ALWAYS - PROB_VERY_UNLIKELY;\n \n   /* Update dominance info.  Note that bb_join's data was\n      updated by split_block.  */\n@@ -183,75 +173,125 @@ build_check_stmt (tree base,\n       set_immediate_dominator (CDI_DOMINATORS, join_bb, cond_bb);\n     }\n \n-  base_addr = create_tmp_reg (uintptr_type, \"__asan_base_addr\");\n+  base = unshare_expr (base);\n \n-  seq = NULL; \n-  t = fold_convert_loc (location, uintptr_type,\n-                        unshare_expr (base));\n-  t = force_gimple_operand (t, &stmts, false, NULL_TREE);\n-  gimple_seq_add_seq (&seq, stmts);\n-  g = gimple_build_assign (base_addr, t);\n+  gsi = gsi_last_bb (cond_bb);\n+  g = gimple_build_assign_with_ops (TREE_CODE (base),\n+\t\t\t\t    make_ssa_name (TREE_TYPE (base), NULL),\n+\t\t\t\t    base, NULL_TREE);\n   gimple_set_location (g, location);\n-  gimple_seq_add_stmt (&seq, g);\n+  gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n \n-  /* Build\n-     (base_addr >> ASAN_SHADOW_SHIFT) | targetm.asan_shadow_offset ().  */\n-\n-  t = build2 (RSHIFT_EXPR, uintptr_type, base_addr,\n-\t      build_int_cst (uintptr_type, ASAN_SHADOW_SHIFT));\n-  t = build2 (PLUS_EXPR, uintptr_type, t,\n-\t      build_int_cst (uintptr_type, targetm.asan_shadow_offset ()));\n-  t = build1 (INDIRECT_REF, shadow_type,\n-              build1 (VIEW_CONVERT_EXPR, shadow_ptr_type, t));\n-  t = force_gimple_operand (t, &stmts, false, NULL_TREE);\n-  gimple_seq_add_seq (&seq, stmts);\n-  shadow_value = create_tmp_reg (shadow_type, \"__asan_shadow\");\n-  g = gimple_build_assign (shadow_value, t);\n+  g = gimple_build_assign_with_ops (NOP_EXPR,\n+\t\t\t\t    make_ssa_name (uintptr_type, NULL),\n+\t\t\t\t    gimple_assign_lhs (g), NULL_TREE);\n   gimple_set_location (g, location);\n-  gimple_seq_add_stmt (&seq, g);\n-  t = build2 (NE_EXPR, boolean_type_node, shadow_value,\n-              build_int_cst (shadow_type, 0));\n-  if (size_in_bytes < 8)\n-    {\n+  gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n+  base_addr = gimple_assign_lhs (g);\n \n-      /* Slow path for 1-, 2- and 4- byte accesses.\n-         Build ((base_addr & 7) + (size_in_bytes - 1)) >= shadow_value.  */\n+  /* Build\n+     (base_addr >> ASAN_SHADOW_SHIFT) + targetm.asan_shadow_offset ().  */\n \n-      u = build2 (BIT_AND_EXPR, uintptr_type,\n-                  base_addr,\n-                  build_int_cst (uintptr_type, 7));\n-      u = build1 (CONVERT_EXPR, shadow_type, u);\n-      u = build2 (PLUS_EXPR, shadow_type, u,\n-                  build_int_cst (shadow_type, size_in_bytes - 1));\n-      u = build2 (GE_EXPR, uintptr_type, u, shadow_value);\n-    }\n-  else\n-      u = build_int_cst (boolean_type_node, 1);\n-  t = build2 (TRUTH_AND_EXPR, boolean_type_node, t, u);\n-  t = force_gimple_operand (t, &stmts, false, NULL_TREE);\n-  gimple_seq_add_seq (&seq, stmts);\n-  cond = create_tmp_reg (boolean_type_node, \"__asan_crash_cond\");\n-  g = gimple_build_assign  (cond, t);\n+  t = build_int_cst (uintptr_type, ASAN_SHADOW_SHIFT);\n+  g = gimple_build_assign_with_ops (RSHIFT_EXPR,\n+\t\t\t\t    make_ssa_name (uintptr_type, NULL),\n+\t\t\t\t    base_addr, t);\n   gimple_set_location (g, location);\n-  gimple_seq_add_stmt (&seq, g);\n-  g = gimple_build_cond (NE_EXPR, cond, boolean_false_node, NULL_TREE,\n-                         NULL_TREE);\n+  gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n+\n+  t = build_int_cst (uintptr_type, targetm.asan_shadow_offset ());\n+  g = gimple_build_assign_with_ops (PLUS_EXPR,\n+\t\t\t\t    make_ssa_name (uintptr_type, NULL),\n+\t\t\t\t    gimple_assign_lhs (g), t);\n   gimple_set_location (g, location);\n-  gimple_seq_add_stmt (&seq, g);\n+  gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n \n-  /* Generate call to the run-time library (e.g. __asan_report_load8).  */\n+  g = gimple_build_assign_with_ops (NOP_EXPR,\n+\t\t\t\t    make_ssa_name (shadow_ptr_type, NULL),\n+\t\t\t\t    gimple_assign_lhs (g), NULL_TREE);\n+  gimple_set_location (g, location);\n+  gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n \n-  gsi = gsi_last_bb (cond_bb);\n-  gsi_insert_seq_after (&gsi, seq, GSI_CONTINUE_LINKING);\n-  seq = NULL; \n-  g = gimple_build_call (report_error_func (is_store, size_in_bytes),\n-                         1, base_addr);\n-  gimple_seq_add_stmt (&seq, g);\n+  t = build2 (MEM_REF, shadow_type, gimple_assign_lhs (g),\n+\t      build_int_cst (shadow_ptr_type, 0));\n+  g = gimple_build_assign_with_ops (MEM_REF,\n+\t\t\t\t    make_ssa_name (shadow_type, NULL),\n+\t\t\t\t    t, NULL_TREE);\n+  gimple_set_location (g, location);\n+  gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n+  shadow = gimple_assign_lhs (g);\n+\n+  if (size_in_bytes < 8)\n+    {\n+      /* Slow path for 1, 2 and 4 byte accesses.\n+\t Test (shadow != 0)\n+\t      & ((base_addr & 7) + (size_in_bytes - 1)) >= shadow).  */\n+      g = gimple_build_assign_with_ops (NE_EXPR,\n+\t\t\t\t\tmake_ssa_name (boolean_type_node,\n+\t\t\t\t\t\t       NULL),\n+\t\t\t\t\tshadow,\n+\t\t\t\t\tbuild_int_cst (shadow_type, 0));\n+      gimple_set_location (g, location);\n+      gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n+      t = gimple_assign_lhs (g);\n+\n+      g = gimple_build_assign_with_ops (BIT_AND_EXPR,\n+\t\t\t\t\tmake_ssa_name (uintptr_type,\n+\t\t\t\t\t\t       NULL),\n+\t\t\t\t\tbase_addr,\n+\t\t\t\t\tbuild_int_cst (uintptr_type, 7));\n+      gimple_set_location (g, location);\n+      gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n+\n+      g = gimple_build_assign_with_ops (NOP_EXPR,\n+\t\t\t\t\tmake_ssa_name (shadow_type,\n+\t\t\t\t\t\t       NULL),\n+\t\t\t\t\tgimple_assign_lhs (g), NULL_TREE);\n+      gimple_set_location (g, location);\n+      gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n+\n+      if (size_in_bytes > 1)\n+\t{\n+\t  g = gimple_build_assign_with_ops (PLUS_EXPR,\n+\t\t\t\t\t    make_ssa_name (shadow_type,\n+\t\t\t\t\t\t\t   NULL),\n+\t\t\t\t\t    gimple_assign_lhs (g),\n+\t\t\t\t\t    build_int_cst (shadow_type,\n+\t\t\t\t\t\t\t   size_in_bytes - 1));\n+\t  gimple_set_location (g, location);\n+\t  gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n+\t}\n+\n+      g = gimple_build_assign_with_ops (GE_EXPR,\n+\t\t\t\t\tmake_ssa_name (boolean_type_node,\n+\t\t\t\t\t\t       NULL),\n+\t\t\t\t\tgimple_assign_lhs (g),\n+\t\t\t\t\tshadow);\n+      gimple_set_location (g, location);\n+      gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n+\n+      g = gimple_build_assign_with_ops (BIT_AND_EXPR,\n+\t\t\t\t\tmake_ssa_name (boolean_type_node,\n+\t\t\t\t\t\t       NULL),\n+\t\t\t\t\tt, gimple_assign_lhs (g));\n+      gimple_set_location (g, location);\n+      gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n+      t = gimple_assign_lhs (g);\n+    }\n+  else\n+    t = shadow;\n \n-  /* Insert the check code in the THEN block.  */\n+  g = gimple_build_cond (NE_EXPR, t, build_int_cst (TREE_TYPE (t), 0),\n+\t\t\t NULL_TREE, NULL_TREE);\n+  gimple_set_location (g, location);\n+  gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n \n+  /* Generate call to the run-time library (e.g. __asan_report_load8).  */\n   gsi = gsi_start_bb (then_bb);\n-  gsi_insert_seq_after (&gsi, seq, GSI_CONTINUE_LINKING);\n+  g = gimple_build_call (report_error_func (is_store, size_in_bytes),\n+\t\t\t 1, base_addr);\n+  gimple_set_location (g, location);\n+  gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n \n   *iter = gsi_start_bb (join_bb);\n }\n@@ -262,14 +302,12 @@ build_check_stmt (tree base,\n \n static void\n instrument_derefs (gimple_stmt_iterator *iter, tree t,\n-                  location_t location, int is_store)\n+                  location_t location, bool is_store)\n {\n   tree type, base;\n-  int size_in_bytes;\n+  HOST_WIDE_INT size_in_bytes;\n \n   type = TREE_TYPE (t);\n-  if (type == error_mark_node)\n-    return;\n   switch (TREE_CODE (t))\n     {\n     case ARRAY_REF:\n@@ -280,25 +318,25 @@ instrument_derefs (gimple_stmt_iterator *iter, tree t,\n     default:\n       return;\n     }\n-  size_in_bytes = tree_low_cst (TYPE_SIZE (type), 0) / BITS_PER_UNIT;\n-  if (size_in_bytes != 1 && size_in_bytes != 2 &&\n-      size_in_bytes != 4 && size_in_bytes != 8 && size_in_bytes != 16)\n-      return;\n-  {\n-    /* For now just avoid instrumenting bit field acceses.\n+\n+  size_in_bytes = int_size_in_bytes (type);\n+  if ((size_in_bytes & (size_in_bytes - 1)) != 0\n+      || (unsigned HOST_WIDE_INT) size_in_bytes - 1 >= 16)\n+    return;\n+\n+  /* For now just avoid instrumenting bit field acceses.\n      Fixing it is doable, but expected to be messy.  */\n \n-    HOST_WIDE_INT bitsize, bitpos;\n-    tree offset;\n-    enum machine_mode mode;\n-    int volatilep = 0, unsignedp = 0;\n-    get_inner_reference (t, &bitsize, &bitpos, &offset,\n-                         &mode, &unsignedp, &volatilep, false);\n-    if (bitpos != 0 || bitsize != size_in_bytes * BITS_PER_UNIT)\n-        return;\n-  }\n-\n-  base = build_addr (t, current_function_decl);\n+  HOST_WIDE_INT bitsize, bitpos;\n+  tree offset;\n+  enum machine_mode mode;\n+  int volatilep = 0, unsignedp = 0;\n+  get_inner_reference (t, &bitsize, &bitpos, &offset,\n+\t\t       &mode, &unsignedp, &volatilep, false);\n+  if (bitpos != 0 || bitsize != size_in_bytes * BITS_PER_UNIT)\n+    return;\n+\n+  base = build_fold_addr_expr (t);\n   build_check_stmt (base, iter, location, is_store, size_in_bytes);\n }\n \n@@ -314,24 +352,19 @@ transform_statements (void)\n   basic_block bb;\n   gimple_stmt_iterator i;\n   int saved_last_basic_block = last_basic_block;\n-  enum gimple_rhs_class grhs_class;\n \n   FOR_EACH_BB (bb)\n     {\n       if (bb->index >= saved_last_basic_block) continue;\n       for (i = gsi_start_bb (bb); !gsi_end_p (i); gsi_next (&i))\n         {\n           gimple s = gsi_stmt (i);\n-          if (gimple_code (s) != GIMPLE_ASSIGN)\n-              continue;\n+          if (!gimple_assign_single_p (s))\n+\t    continue;\n           instrument_derefs (&i, gimple_assign_lhs (s),\n-                             gimple_location (s), 1);\n+                             gimple_location (s), true);\n           instrument_derefs (&i, gimple_assign_rhs1 (s),\n-                             gimple_location (s), 0);\n-          grhs_class = get_gimple_rhs_class (gimple_assign_rhs_code (s));\n-          if (grhs_class == GIMPLE_BINARY_RHS)\n-            instrument_derefs (&i, gimple_assign_rhs2 (s),\n-                               gimple_location (s), 0);\n+                             gimple_location (s), false);\n         }\n     }\n }\n@@ -351,15 +384,28 @@ asan_finish_file (void)\n                              MAX_RESERVED_INIT_PRIORITY - 1);\n }\n \n+/* Initialize shadow_ptr_types array.  */\n+\n+static void\n+asan_init_shadow_ptr_types (void)\n+{\n+  alias_set_type set = new_alias_set ();\n+  shadow_ptr_types[0] = build_distinct_type_copy (signed_char_type_node);\n+  TYPE_ALIAS_SET (shadow_ptr_types[0]) = set;\n+  shadow_ptr_types[0] = build_pointer_type (shadow_ptr_types[0]);\n+  shadow_ptr_types[1] = build_distinct_type_copy (short_integer_type_node);\n+  TYPE_ALIAS_SET (shadow_ptr_types[1]) = set;\n+  shadow_ptr_types[1] = build_pointer_type (shadow_ptr_types[1]);\n+}\n+\n /* Instrument the current function.  */\n \n static unsigned int\n asan_instrument (void)\n {\n-  struct gimplify_ctx gctx;\n-  push_gimplify_context (&gctx);\n+  if (shadow_ptr_types[0] == NULL_TREE)\n+    asan_init_shadow_ptr_types ();\n   transform_statements ();\n-  pop_gimplify_context (NULL);\n   return 0;\n }\n \n@@ -386,6 +432,8 @@ struct gimple_opt_pass pass_asan =\n   0,                                    /* properties_destroyed  */\n   0,                                    /* todo_flags_start  */\n   TODO_verify_flow | TODO_verify_stmts\n-  | TODO_update_ssa    /* todo_flags_finish  */\n+  | TODO_update_ssa\t\t\t/* todo_flags_finish  */\n  }\n };\n+\n+#include \"gt-asan.h\""}, {"sha": "0d9ab8b77a68c820200553c5c62a8ef47c6dde93", "filename": "gcc/asan.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d984843095c520ceb89cf374c7a13bb6a06a99/gcc%2Fasan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d984843095c520ceb89cf374c7a13bb6a06a99/gcc%2Fasan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.h?ref=f6d984843095c520ceb89cf374c7a13bb6a06a99", "patch": "@@ -24,7 +24,7 @@ along with GCC; see the file COPYING3.  If not see\n extern void asan_finish_file(void);\n \n /* Shadow memory is found at\n-   (address >> ASAN_SHADOW_SHIFT) | targetm.asan_shadow_offset ().  */\n+   (address >> ASAN_SHADOW_SHIFT) + targetm.asan_shadow_offset ().  */\n #define ASAN_SHADOW_SHIFT\t3\n \n #endif /* TREE_ASAN */"}]}