{"sha": "1a4450c78ff2b55ef5af7749ac56ef13b5c8dd0c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWE0NDUwYzc4ZmYyYjU1ZWY1YWY3NzQ5YWM1NmVmMTNiNWM4ZGQwYw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-09-15T23:05:05Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-09-15T23:05:05Z"}, "message": "rtl.h (NOTE_BLOCK_NUMBER): Replace with ...\n\n\t* rtl.h (NOTE_BLOCK_NUMBER): Replace with ...\n\t(NOTE_BLOCK): New macro.\n\t(NOTE_BLOCK_LIVE_RANGE_BLOCK): Remove.\n\t* function.h (identify_blocks): CHange prototype.\n\t* function.c (identify_blocks): Simplify.\n\t(reorder_blocks): Likewise.\n\t* ggc-common.c (ggc_mark_rtx): Mark the BLOCK associated with a\n\tNOTE_INSN_BLOCK_{BEG,END}.\n\t* haifa-sched.c (sched_analyze): Don't put NOTE_BLOCK_NUMBER on\n\tthe list of saved notes if the note isn't a\n\tNOTE_INSN_BLOCK_{BEG,END}.\n\t(move_insn1): Use NOTE_EH_HANDLER in comment, rather than\n\tNOTE_BLOCK_NUMBER.\n\t(reemit_notes): Adjust recreation of notes to reflect new saved\n\tnote structure.\n\t* print-rtl.c (print_rtx): Print the address of the BLOCK when\n\tprinting a block note.\n\t* stmt.c (block_vector): Remove.\n\t(find_loop_tree_blocks): Simplify.\n\t(unroll_block_trees): Likewise.\n\nFrom-SVN: r29441", "tree": {"sha": "3d508285418ae3e6e9fa770aac8efa585f50fce9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d508285418ae3e6e9fa770aac8efa585f50fce9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a4450c78ff2b55ef5af7749ac56ef13b5c8dd0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a4450c78ff2b55ef5af7749ac56ef13b5c8dd0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a4450c78ff2b55ef5af7749ac56ef13b5c8dd0c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a4450c78ff2b55ef5af7749ac56ef13b5c8dd0c/comments", "author": null, "committer": null, "parents": [{"sha": "371534a917ce5751c5d05e2b7428a86374a73376", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/371534a917ce5751c5d05e2b7428a86374a73376", "html_url": "https://github.com/Rust-GCC/gccrs/commit/371534a917ce5751c5d05e2b7428a86374a73376"}], "stats": {"total": 128, "additions": 72, "deletions": 56}, "files": [{"sha": "870705219a2c4dd09b3d674840f5e772b8e0e010", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4450c78ff2b55ef5af7749ac56ef13b5c8dd0c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4450c78ff2b55ef5af7749ac56ef13b5c8dd0c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1a4450c78ff2b55ef5af7749ac56ef13b5c8dd0c", "patch": "@@ -1,3 +1,26 @@\n+Wed Sep 15 15:51:52 1999  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* rtl.h (NOTE_BLOCK_NUMBER): Replace with ...\n+\t(NOTE_BLOCK): New macro.\n+\t(NOTE_BLOCK_LIVE_RANGE_BLOCK): Remove.\n+\t* function.h (identify_blocks): CHange prototype.\n+\t* function.c (identify_blocks): Simplify.\n+\t(reorder_blocks): Likewise.\n+\t* ggc-common.c (ggc_mark_rtx): Mark the BLOCK associated with a \n+\tNOTE_INSN_BLOCK_{BEG,END}.\n+\t* haifa-sched.c (sched_analyze): Don't put NOTE_BLOCK_NUMBER on\n+\tthe list of saved notes if the note isn't a\n+\tNOTE_INSN_BLOCK_{BEG,END}.\n+\t(move_insn1): Use NOTE_EH_HANDLER in comment, rather than\n+\tNOTE_BLOCK_NUMBER.\n+\t(reemit_notes): Adjust recreation of notes to reflect new saved\n+\tnote structure.\n+\t* print-rtl.c (print_rtx): Print the address of the BLOCK when\n+\tprinting a block note.\n+\t* stmt.c (block_vector): Remove.\n+\t(find_loop_tree_blocks): Simplify.\n+\t(unroll_block_trees): Likewise.\n+\t\n Wed Sep 15 14:39:35 1999  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* gbl-ctors.h: Lose HAVE_ATEXIT.  Don't define ON_EXIT."}, {"sha": "c2d585e0cb5b83e8dad7cb4bfe703157dcad3a20", "filename": "gcc/function.c", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4450c78ff2b55ef5af7749ac56ef13b5c8dd0c/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4450c78ff2b55ef5af7749ac56ef13b5c8dd0c/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=1a4450c78ff2b55ef5af7749ac56ef13b5c8dd0c", "patch": "@@ -5348,67 +5348,65 @@ round_trampoline_addr (tramp)\n    The arguments are BLOCK, the chain of top-level blocks of the function,\n    and INSNS, the insn chain of the function.  */\n \n-tree *\n+void\n identify_blocks (block, insns)\n      tree block;\n      rtx insns;\n {\n   int n_blocks;\n   tree *block_vector;\n-  int *block_stack;\n+  tree *block_stack;\n   int depth = 0;\n-  int next_block_number = 1;\n   int current_block_number = 1;\n   rtx insn;\n \n   if (block == 0)\n-    return 0;\n+    return;\n \n+  /* Fill the BLOCK_VECTOR with all of the BLOCKs in this function, in\n+     depth-first order.  */\n   n_blocks = all_blocks (block, 0);\n   block_vector = (tree *) xmalloc (n_blocks * sizeof (tree));\n-  block_stack = (int *) alloca (n_blocks * sizeof (int));\n-\n   all_blocks (block, block_vector);\n \n+  block_stack = (tree *) alloca (n_blocks * sizeof (tree));\n+\n   for (insn = insns; insn; insn = NEXT_INSN (insn))\n     if (GET_CODE (insn) == NOTE)\n       {\n \tif (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_BEG)\n \t  {\n-\t    block_stack[depth++] = current_block_number;\n-\t    current_block_number = next_block_number;\n-\t    NOTE_BLOCK_NUMBER (insn) =  next_block_number++;\n+\t    tree block;\n+\n+\t    block = block_vector[current_block_number++];\n+\t    NOTE_BLOCK (insn) = block;\n+\t    block_stack[depth++] = block;\n \t  }\n \tif (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END)\n-\t  {\n-\t    NOTE_BLOCK_NUMBER (insn) = current_block_number;\n-\t    current_block_number = block_stack[--depth];\n-\t  }\n+\t  NOTE_BLOCK (insn) = block_stack[--depth];\n       }\n \n-  if (n_blocks != next_block_number)\n+  if (n_blocks != current_block_number)\n     abort ();\n \n-  return block_vector;\n+  free (block_vector);\n }\n \n-/* Given BLOCK_VECTOR which was returned by identify_blocks,\n-   and a revised instruction chain, rebuild the tree structure\n-   of BLOCK nodes to correspond to the new order of RTL.\n-   The new block tree is inserted below TOP_BLOCK.\n-   Returns the current top-level block.  */\n+/* Given a revised instruction chain, rebuild the tree structure of\n+   BLOCK nodes to correspond to the new order of RTL.  The new block\n+   tree is inserted below TOP_BLOCK.  Returns the current top-level\n+   block.  */\n \n tree\n-reorder_blocks (block_vector, block, insns)\n-     tree *block_vector;\n+reorder_blocks (block, insns)\n      tree block;\n      rtx insns;\n {\n   tree current_block = block;\n   rtx insn;\n \n-  if (block_vector == 0)\n-    return block;\n+  if (block == NULL_TREE)\n+    return NULL_TREE;\n \n   /* Prune the old trees away, so that it doesn't get in the way.  */\n   BLOCK_SUBBLOCKS (current_block) = 0;\n@@ -5419,7 +5417,7 @@ reorder_blocks (block_vector, block, insns)\n       {\n \tif (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_BEG)\n \t  {\n-\t    tree block = block_vector[NOTE_BLOCK_NUMBER (insn)];\n+\t    tree block = NOTE_BLOCK (insn);\n \t    /* If we have seen this block before, copy it.  */\n \t    if (TREE_ASM_WRITTEN (block))\n \t      block = copy_node (block);"}, {"sha": "a574b67ca4b4a9db16fe3548323911bfbd16b0bd", "filename": "gcc/function.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4450c78ff2b55ef5af7749ac56ef13b5c8dd0c/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4450c78ff2b55ef5af7749ac56ef13b5c8dd0c/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=1a4450c78ff2b55ef5af7749ac56ef13b5c8dd0c", "patch": "@@ -523,7 +523,7 @@ extern struct function *outer_function_chain;\n /* Put all this function's BLOCK nodes into a vector and return it.\n    Also store in each NOTE for the beginning or end of a block\n    the index of that block in the vector.  */\n-extern tree *identify_blocks PROTO((tree, rtx));\n+extern void identify_blocks PROTO((tree, rtx));\n \n /* Return size needed for stack frame based on slots so far allocated.\n    This size counts from zero.  It is not rounded to STACK_BOUNDARY;"}, {"sha": "30725a28c867048a3f620498ac5e2a8f5cd2b8fe", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4450c78ff2b55ef5af7749ac56ef13b5c8dd0c/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4450c78ff2b55ef5af7749ac56ef13b5c8dd0c/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=1a4450c78ff2b55ef5af7749ac56ef13b5c8dd0c", "patch": "@@ -208,6 +208,11 @@ ggc_mark_rtx (r)\n \t  ggc_mark_rtx (NOTE_RANGE_INFO (r));\n \t  break;\n \n+\tcase NOTE_INSN_BLOCK_BEG:\n+\tcase NOTE_INSN_BLOCK_END:\n+\t  ggc_mark_tree (NOTE_BLOCK (r));\n+\t  break;\n+\n \tdefault:\n \t  if (NOTE_LINE_NUMBER (r) >= 0)\n \t    ggc_mark_string (NOTE_SOURCE_FILE (r));"}, {"sha": "9d070f0fc0ff9645282937979ff9c7d87f3943d0", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4450c78ff2b55ef5af7749ac56ef13b5c8dd0c/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4450c78ff2b55ef5af7749ac56ef13b5c8dd0c/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=1a4450c78ff2b55ef5af7749ac56ef13b5c8dd0c", "patch": "@@ -3939,9 +3939,12 @@ sched_analyze (head, tail)\n \t\t   || (NOTE_LINE_NUMBER (insn) == NOTE_INSN_SETJMP\n \t\t       && GET_CODE (PREV_INSN (insn)) != CALL_INSN)))\n \t{\n-\t  loop_notes = alloc_EXPR_LIST (REG_DEAD,\n-\t\t\t\t\tGEN_INT (NOTE_BLOCK_NUMBER (insn)),\n-\t\t\t\t\tloop_notes);\n+\t  if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_BEG\n+\t      || NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_END)\n+\t    loop_notes = alloc_EXPR_LIST (REG_DEAD,\n+\t\t\t\t\t  GEN_INT (NOTE_EH_HANDLER (insn)),\n+\t\t\t\t\t  loop_notes);\n+\n \t  loop_notes = alloc_EXPR_LIST (REG_DEAD,\n \t\t\t\t\tGEN_INT (NOTE_LINE_NUMBER (insn)),\n \t\t\t\t\tloop_notes);\n@@ -6494,7 +6497,7 @@ move_insn1 (insn, last)\n /* Search INSN for fake REG_DEAD note pairs for NOTE_INSN_SETJMP,\n    NOTE_INSN_{LOOP,EHREGION}_{BEG,END}; and convert them back into\n    NOTEs.  The REG_DEAD note following first one is contains the saved\n-   value for NOTE_BLOCK_NUMBER which is useful for\n+   value for NOTE_EH_HANDLER which is useful for\n    NOTE_INSN_EH_REGION_{BEG,END} NOTEs.  LAST is the last instruction\n    output by the instruction scheduler.  Return the new value of LAST.  */\n \n@@ -6516,8 +6519,6 @@ reemit_notes (insn, last)\n \t    {\n \t      retval = emit_note_after (NOTE_INSN_SETJMP, insn);\n \t      CONST_CALL_P (retval) = CONST_CALL_P (note);\n-\t      remove_note (insn, note);\n-\t      note = XEXP (note, 1);\n \t    }\n \t  else if (note_type == NOTE_INSN_RANGE_START\n                    || note_type == NOTE_INSN_RANGE_END)\n@@ -6530,9 +6531,13 @@ reemit_notes (insn, last)\n \t  else\n \t    {\n \t      last = emit_note_before (note_type, last);\n-\t      remove_note (insn, note);\n-\t      note = XEXP (note, 1);\n-\t      NOTE_BLOCK_NUMBER (last) = INTVAL (XEXP (note, 0));\n+\t      if (note_type == NOTE_INSN_EH_REGION_BEG\n+\t\t  || note_type == NOTE_INSN_EH_REGION_END)\n+\t\t{\n+\t\t  remove_note (insn, note);\n+\t\t  note = XEXP (note, 1);\n+\t\t  NOTE_EH_HANDLER (last) = INTVAL (XEXP (note, 0));\n+\t\t}\n \t    }\n \t  remove_note (insn, note);\n \t}"}, {"sha": "d32ed18c3634395fc1fa5b2cee1bb32a8f65daae", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4450c78ff2b55ef5af7749ac56ef13b5c8dd0c/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4450c78ff2b55ef5af7749ac56ef13b5c8dd0c/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=1a4450c78ff2b55ef5af7749ac56ef13b5c8dd0c", "patch": "@@ -166,7 +166,9 @@ print_rtx (in_rtx)\n \t    else if (NOTE_LINE_NUMBER (in_rtx) == NOTE_INSN_BLOCK_BEG\n \t\t     || NOTE_LINE_NUMBER (in_rtx) == NOTE_INSN_BLOCK_END)\n \t      {\n-\t\tfprintf (outfile, \" %d\", NOTE_BLOCK_NUMBER (in_rtx));\n+\t\tfprintf (outfile, \" \");\n+\t\tfprintf (outfile, HOST_PTR_PRINTF, \n+\t\t\t (char *) NOTE_BLOCK (in_rtx));\n \t\tsawclose = 1;\n \t      }\n \t    else if (NOTE_LINE_NUMBER (in_rtx) == NOTE_INSN_RANGE_START"}, {"sha": "b31a98b202730bd837e32e92662bae907d6fce3b", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4450c78ff2b55ef5af7749ac56ef13b5c8dd0c/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4450c78ff2b55ef5af7749ac56ef13b5c8dd0c/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=1a4450c78ff2b55ef5af7749ac56ef13b5c8dd0c", "patch": "@@ -517,16 +517,12 @@ extern const char * const reg_note_name[];\n    information as a rtx in the field.  */\n \n #define NOTE_SOURCE_FILE(INSN) \tXCSTR(INSN, 3, NOTE)\n-#define NOTE_BLOCK_NUMBER(INSN)\tXCINT(INSN, 3, NOTE)\n+#define NOTE_BLOCK(INSN)\tXCTREE(INSN, 3, NOTE)\n #define NOTE_EH_HANDLER(INSN)\tXCINT(INSN, 3, NOTE)\n #define NOTE_RANGE_INFO(INSN)  \tXCEXP(INSN, 3, NOTE)\n #define NOTE_LIVE_INFO(INSN)   \tXCEXP(INSN, 3, NOTE)\n #define NOTE_BASIC_BLOCK(INSN)\tXCBBDEF(INSN, 3, NOTE)\n \n-/* If the NOTE_BLOCK_NUMBER field gets a -1, it means create a new\n-   block node for a live range block.  */\n-#define NOTE_BLOCK_LIVE_RANGE_BLOCK -1\n-\n /* In a NOTE that is a line number, this is the line number.\n    Other kinds of NOTEs are identified by negative numbers here.  */\n #define NOTE_LINE_NUMBER(INSN) XCINT(INSN, 4, NOTE)"}, {"sha": "068803cd4d44fe80f0ae560bfc6ba72000bab666", "filename": "gcc/stmt.c", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4450c78ff2b55ef5af7749ac56ef13b5c8dd0c/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4450c78ff2b55ef5af7749ac56ef13b5c8dd0c/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=1a4450c78ff2b55ef5af7749ac56ef13b5c8dd0c", "patch": "@@ -6278,29 +6278,16 @@ emit_case_nodes (index, node, default_label, index_type)\n /* These routines are used by the loop unrolling code.  They copy BLOCK trees\n    so that the debugging info will be correct for the unrolled loop.  */\n \n-/* Indexed by block number, contains a pointer to the N'th block node.\n-\n-  Allocated by the call to identify_blocks, then released after the call\n-  to reorder_blocks in the function unroll_block_trees.  */\n-\n-static tree *block_vector;\n-\n void\n find_loop_tree_blocks ()\n {\n-  tree block = DECL_INITIAL (current_function_decl);\n-\n-  block_vector = identify_blocks (block, get_insns ());\n+  identify_blocks (DECL_INITIAL (current_function_decl), get_insns ());\n }\n \n void\n unroll_block_trees ()\n {\n   tree block = DECL_INITIAL (current_function_decl);\n \n-  reorder_blocks (block_vector, block, get_insns ());\n-\n-  /* Release any memory allocated by identify_blocks.  */\n-  if (block_vector)\n-    free (block_vector);\n+  reorder_blocks (block, get_insns ());\n }"}]}