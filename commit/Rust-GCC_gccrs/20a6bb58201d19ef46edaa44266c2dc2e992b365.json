{"sha": "20a6bb58201d19ef46edaa44266c2dc2e992b365", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjBhNmJiNTgyMDFkMTllZjQ2ZWRhYTQ0MjY2YzJkYzJlOTkyYjM2NQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-06-29T14:26:00Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-06-29T14:26:00Z"}, "message": "* tree-inline.c: Replace incomming by incomin and clonning by cloning.\n\nFrom-SVN: r161537", "tree": {"sha": "64f1a0aec40351761c417d957d734c8fdf7b3f4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/64f1a0aec40351761c417d957d734c8fdf7b3f4a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/20a6bb58201d19ef46edaa44266c2dc2e992b365", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20a6bb58201d19ef46edaa44266c2dc2e992b365", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20a6bb58201d19ef46edaa44266c2dc2e992b365", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20a6bb58201d19ef46edaa44266c2dc2e992b365/comments", "author": null, "committer": null, "parents": [{"sha": "b35366ce42d0cc1218679337be0a779c20af35e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b35366ce42d0cc1218679337be0a779c20af35e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b35366ce42d0cc1218679337be0a779c20af35e0"}], "stats": {"total": 32, "additions": 18, "deletions": 14}, "files": [{"sha": "5f84221b063d80d4601eecfe454db53b81e626f6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a6bb58201d19ef46edaa44266c2dc2e992b365/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a6bb58201d19ef46edaa44266c2dc2e992b365/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=20a6bb58201d19ef46edaa44266c2dc2e992b365", "patch": "@@ -1,3 +1,7 @@\n+2010-06-29  Jan Hubicka  <jh@suse.cz>\n+\n+\t* tree-inline.c: Replace incomming by incomin and clonning by cloning.\n+\n 2010-06-29  Jan Hubicka  <jh@suse.cz>\n \n \t* predict.c (propagate_freq): Clear EXIT_BLOCK_PTR frequency if it is"}, {"sha": "3aa5f7c5baab660e98472e509a737c6879f76ad5", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a6bb58201d19ef46edaa44266c2dc2e992b365/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a6bb58201d19ef46edaa44266c2dc2e992b365/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=20a6bb58201d19ef46edaa44266c2dc2e992b365", "patch": "@@ -1712,7 +1712,7 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t\t  /* We have missing edge in the callgraph.  This can happen\n \t\t     when previous inlining turned an indirect call into a\n \t\t     direct call by constant propagating arguments or we are\n-\t\t     producing dead clone (for further clonning).  In all\n+\t\t     producing dead clone (for further cloning).  In all\n \t\t     other cases we hit a bug (incorrect node sharing is the\n \t\t     most common reason for missing edges).  */\n \t\t  gcc_assert (dest->needed || !dest->analyzed\n@@ -1975,7 +1975,7 @@ copy_phis_for_bb (basic_block bb, copy_body_data *id)\n \t      tree block = id->block;\n \t      edge_iterator ei2;\n \n-\t      /* When doing partial clonning, we allow PHIs on the entry block\n+\t      /* When doing partial cloning, we allow PHIs on the entry block\n \t\t as long as all the arguments are the same.  Find any input\n \t\t edge to see argument to copy.  */\n \t      if (!old_edge)\n@@ -2042,7 +2042,7 @@ initialize_cfun (tree new_fndecl, tree callee_fndecl, gcov_type count)\n   gcc_assert (cfun->cfg == NULL);\n   gcc_assert (cfun->decl == new_fndecl);\n \n-  /* Copy items we preserve during clonning.  */\n+  /* Copy items we preserve during cloning.  */\n   cfun->static_chain_decl = src_cfun->static_chain_decl;\n   cfun->nonlocal_goto_save_area = src_cfun->nonlocal_goto_save_area;\n   cfun->function_end_locus = src_cfun->function_end_locus;\n@@ -2159,8 +2159,8 @@ copy_cfg_body (copy_body_data * id, gcov_type count, int frequency_scale,\n   bool need_debug_cleanup = false;\n   gcov_type count_scale;\n   int last;\n-  int incomming_frequency = 0;\n-  gcov_type incomming_count = 0;\n+  int incoming_frequency = 0;\n+  gcov_type incoming_count = 0;\n \n   if (ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->count)\n     count_scale = (REG_BR_PROB_BASE * count\n@@ -2174,7 +2174,7 @@ copy_cfg_body (copy_body_data * id, gcov_type count, int frequency_scale,\n   /* If we are inlining just region of the function, make sure to connect new entry\n      to ENTRY_BLOCK_PTR.  Since new entry can be part of loop, we must compute\n      frequency and probability of ENTRY_BLOCK_PTR based on the frequencies and\n-     probabilities of edges incomming from nonduplicated region.  */\n+     probabilities of edges incoming from nonduplicated region.  */\n   if (new_entry)\n     {\n       edge e;\n@@ -2183,14 +2183,14 @@ copy_cfg_body (copy_body_data * id, gcov_type count, int frequency_scale,\n       FOR_EACH_EDGE (e, ei, new_entry->preds)\n \tif (!e->src->aux)\n \t  {\n-\t    incomming_frequency += EDGE_FREQUENCY (e);\n-\t    incomming_count += e->count;\n+\t    incoming_frequency += EDGE_FREQUENCY (e);\n+\t    incoming_count += e->count;\n \t  }\n-      incomming_count = incomming_count * count_scale / REG_BR_PROB_BASE;\n-      incomming_frequency\n-\t= incomming_frequency * frequency_scale / REG_BR_PROB_BASE;\n-      ENTRY_BLOCK_PTR->count = incomming_count;\n-      ENTRY_BLOCK_PTR->frequency = incomming_frequency;\n+      incoming_count = incoming_count * count_scale / REG_BR_PROB_BASE;\n+      incoming_frequency\n+\t= incoming_frequency * frequency_scale / REG_BR_PROB_BASE;\n+      ENTRY_BLOCK_PTR->count = incoming_count;\n+      ENTRY_BLOCK_PTR->frequency = incoming_frequency;\n     }\n \n   /* Must have a CFG here at this point.  */\n@@ -2230,7 +2230,7 @@ copy_cfg_body (copy_body_data * id, gcov_type count, int frequency_scale,\n     {\n       edge e = make_edge (entry_block_map, (basic_block)new_entry->aux, EDGE_FALLTHRU);\n       e->probability = REG_BR_PROB_BASE;\n-      e->count = incomming_count;\n+      e->count = incoming_count;\n     }\n \n   if (gimple_in_ssa_p (cfun))"}]}