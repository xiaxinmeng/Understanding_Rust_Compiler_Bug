{"sha": "d2348bd59174b5f3c5c492da6190f80c3f6d745b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDIzNDhiZDU5MTc0YjVmM2M1YzQ5MmRhNjE5MGY4MGMzZjZkNzQ1Yg==", "commit": {"author": {"name": "DJ Delorie", "email": "dj@redhat.com", "date": "2005-06-01T00:20:13Z"}, "committer": {"name": "DJ Delorie", "email": "dj@gcc.gnu.org", "date": "2005-06-01T00:20:13Z"}, "message": "expr.c (convert_move): When a partial_int requires multiple conversion steps...\n\n* expr.c (convert_move): When a partial_int requires multiple\nconversion steps, make sure successive steps convert the\nintermediate value, not the original value.\n\n* expmed.c (expand_mult): Convert partial_int multiplies to\nshift/add combinations too.\n\n* genmodes.c (mode_data): Add wider_2x.\n(calc_wider_mode): Calculate twice-wider mode too.\n(emit_mode_wider): Emit twice-wider mode too.\n* machmode.h (mode_2xwider, GET_MODE_2XWIDER_MODE): New.\n* expr.c (expand_expr_real_1): Use it for expanding\nmultiplies.\n\nFrom-SVN: r100414", "tree": {"sha": "ad8920def875a4093b66cd5ff53f14ecb758f32a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad8920def875a4093b66cd5ff53f14ecb758f32a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2348bd59174b5f3c5c492da6190f80c3f6d745b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2348bd59174b5f3c5c492da6190f80c3f6d745b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2348bd59174b5f3c5c492da6190f80c3f6d745b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2348bd59174b5f3c5c492da6190f80c3f6d745b/comments", "author": null, "committer": null, "parents": [{"sha": "cc2f3fa620d43b024f4cc1ea800e5246798e1f00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc2f3fa620d43b024f4cc1ea800e5246798e1f00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc2f3fa620d43b024f4cc1ea800e5246798e1f00"}], "stats": {"total": 74, "additions": 68, "deletions": 6}, "files": [{"sha": "2400635e0bfcff6200e3155474587c71e4a57deb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2348bd59174b5f3c5c492da6190f80c3f6d745b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2348bd59174b5f3c5c492da6190f80c3f6d745b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d2348bd59174b5f3c5c492da6190f80c3f6d745b", "patch": "@@ -1,3 +1,19 @@\n+2005-05-31  DJ Delorie  <dj@redhat.com>\n+\n+\t* expr.c (convert_move): When a partial_int requires multiple\n+\tconversion steps, make sure successive steps convert the\n+\tintermediate value, not the original value.\n+\n+\t* expmed.c (expand_mult): Convert partial_int multiplies to\n+\tshift/add combinations too.\n+\n+\t* genmodes.c (mode_data): Add wider_2x.\n+\t(calc_wider_mode): Calculate twice-wider mode too.\n+\t(emit_mode_wider): Emit twice-wider mode too.\n+\t* machmode.h (mode_2xwider, GET_MODE_2XWIDER_MODE): New.\n+\t* expr.c (expand_expr_real_1): Use it for expanding\n+\tmultiplies.\n+\n 2005-05-31  Zdenek Dvorak  <dvorakz@suse.cz>\n \n \tPR tree-optimization/21817"}, {"sha": "ff8c278ced3537ad0a3f30097bd3feb2e713fe0b", "filename": "gcc/expmed.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2348bd59174b5f3c5c492da6190f80c3f6d745b/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2348bd59174b5f3c5c492da6190f80c3f6d745b/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=d2348bd59174b5f3c5c492da6190f80c3f6d745b", "patch": "@@ -3030,7 +3030,7 @@ expand_mult (enum machine_mode mode, rtx op0, rtx op1, rtx target,\n \n   /* These are the operations that are potentially turned into a sequence\n      of shifts and additions.  */\n-  if (GET_MODE_CLASS (mode) == MODE_INT\n+  if (SCALAR_INT_MODE_P (mode)\n       && (unsignedp || !flag_trapv))\n     {\n       HOST_WIDE_INT coeff = 0;"}, {"sha": "5cb883a7ef08cb4cede9aa4f8453b53c7aef31bd", "filename": "gcc/expr.c", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2348bd59174b5f3c5c492da6190f80c3f6d745b/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2348bd59174b5f3c5c492da6190f80c3f6d745b/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=d2348bd59174b5f3c5c492da6190f80c3f6d745b", "patch": "@@ -466,19 +466,27 @@ convert_move (rtx to, rtx from, int unsignedp)\n     }\n   if (GET_MODE_CLASS (from_mode) == MODE_PARTIAL_INT)\n     {\n+      rtx new_from;\n       enum machine_mode full_mode\n \t= smallest_mode_for_size (GET_MODE_BITSIZE (from_mode), MODE_INT);\n \n       gcc_assert (sext_optab->handlers[full_mode][from_mode].insn_code\n \t\t  != CODE_FOR_nothing);\n \n-      emit_unop_insn (sext_optab->handlers[full_mode][from_mode].insn_code,\n-\t\t      to, from, UNKNOWN);\n       if (to_mode == full_mode)\n-\treturn;\n+\t{\n+\t  emit_unop_insn (sext_optab->handlers[full_mode][from_mode].insn_code,\n+\t\t\t  to, from, UNKNOWN);\n+\t  return;\n+\t}\n+\n+      new_from = gen_reg_rtx (full_mode);\n+      emit_unop_insn (sext_optab->handlers[full_mode][from_mode].insn_code,\n+\t\t      new_from, from, UNKNOWN);\n \n       /* else proceed to integer conversions below.  */\n       from_mode = full_mode;\n+      from = new_from;\n     }\n \n   /* Now both modes are integers.  */\n@@ -7747,7 +7755,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t  optab other_optab = zextend_p ? smul_widen_optab : umul_widen_optab;\n \t  this_optab = zextend_p ? umul_widen_optab : smul_widen_optab;\n \n-\t  if (mode == GET_MODE_WIDER_MODE (innermode))\n+\t  if (mode == GET_MODE_2XWIDER_MODE (innermode))\n \t    {\n \t      if (this_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n \t\t{"}, {"sha": "74c71c9465859bfbd4a588ac22748fb087d9bd61", "filename": "gcc/genmodes.c", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2348bd59174b5f3c5c492da6190f80c3f6d745b/gcc%2Fgenmodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2348bd59174b5f3c5c492da6190f80c3f6d745b/gcc%2Fgenmodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmodes.c?ref=d2348bd59174b5f3c5c492da6190f80c3f6d745b", "patch": "@@ -64,6 +64,7 @@ struct mode_data\n \n   struct mode_data *component;\t/* mode of components */\n   struct mode_data *wider;\t/* next wider mode */\n+  struct mode_data *wider_2x;\t/* 2x wider mode */\n \n   struct mode_data *contained;  /* Pointer to list of modes that have\n \t\t\t\t   this mode as a component.  */\n@@ -80,7 +81,7 @@ static struct mode_data *void_mode;\n static const struct mode_data blank_mode = {\n   0, \"<unknown>\", MAX_MODE_CLASS,\n   -1U, -1U, -1U, -1U,\n-  0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0,\n   \"<unknown>\", 0\n };\n \n@@ -717,6 +718,7 @@ calc_wider_mode (void)\n \t  for (prev = 0, m = modes[c]; m; m = next)\n \t    {\n \t      m->wider = void_mode;\n+\t      m->wider_2x = void_mode;\n \n \t      /* this is nreverse */\n \t      next = m->next;\n@@ -951,6 +953,39 @@ emit_mode_wider (void)\n \t\t   m->name);\n \n   print_closer ();\n+  print_decl (\"unsigned char\", \"mode_2xwider\", \"NUM_MACHINE_MODES\");\n+\n+  for_all_modes (c, m)\n+    {\n+      struct mode_data * m2;\n+\n+      for (m2 = m;\n+\t   m2 && m2 != void_mode;\n+\t   m2 = m2->wider)\n+\t{\n+\t  if (m2->bytesize < 2 * m->bytesize)\n+\t    continue;\n+\t  if (m->precision != (unsigned int) -1)\n+\t    {\n+\t      if (m2->precision != 2 * m->precision)\n+\t\tcontinue;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (m2->precision != (unsigned int) -1)\n+\t\tcontinue;\n+\t    }\n+\n+\t  break;\n+\t}\n+      if (m2 == void_mode)\n+\tm2 = 0;\n+      tagged_printf (\"%smode\",\n+\t\t     m2 ? m2->name : void_mode->name,\n+\t\t     m->name);\n+    }\n+\n+  print_closer ();\n }\n \n static void"}, {"sha": "10016f86ac7089f116ef2af6e2556350239d1dda", "filename": "gcc/machmode.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2348bd59174b5f3c5c492da6190f80c3f6d745b/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2348bd59174b5f3c5c492da6190f80c3f6d745b/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=d2348bd59174b5f3c5c492da6190f80c3f6d745b", "patch": "@@ -115,6 +115,9 @@ extern const unsigned char mode_nunits[NUM_MACHINE_MODES];\n extern const unsigned char mode_wider[NUM_MACHINE_MODES];\n #define GET_MODE_WIDER_MODE(MODE) mode_wider[MODE]\n \n+extern const unsigned char mode_2xwider[NUM_MACHINE_MODES];\n+#define GET_MODE_2XWIDER_MODE(MODE) mode_2xwider[MODE]\n+\n /* Return the mode for data of a given size SIZE and mode class CLASS.\n    If LIMIT is nonzero, then don't use modes bigger than MAX_FIXED_MODE_SIZE.\n    The value is BLKmode if no other mode is found.  */"}]}