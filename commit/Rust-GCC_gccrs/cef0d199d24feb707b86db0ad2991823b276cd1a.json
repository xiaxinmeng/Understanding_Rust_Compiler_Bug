{"sha": "cef0d199d24feb707b86db0ad2991823b276cd1a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2VmMGQxOTlkMjRmZWI3MDdiODZkYjBhZDI5OTE4MjNiMjc2Y2QxYQ==", "commit": {"author": {"name": "Neil Booth", "email": "neil@cat.daikokuya.demon.co.uk", "date": "2001-07-26T06:02:47Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-07-26T06:02:47Z"}, "message": "cpphash.h (struct_lexer_state): Delete was_skipping.\n\n\t* cpphash.h (struct_lexer_state): Delete was_skipping.\n\tMove skipping here from struct cpp_reader.\n\t* cpplex.c (parse_identifier): Update.\n\t(_cpp_lex_token): Don't skip tokens in a directive.\n\t* cpplib.c (struct if_stack): Update.\n\t(start_directive, end_directive): Don't change skipping state.\n\t(_cpp_handle_directive): Update.\n\t(do_ifdef, do_ifndef, do_if, do_elif): Similarly.\n\t(do_else, do_endif): Update; only check for excess tokens if not\n\tin a skipped conditional block.\n\t(push_conditional): Update for new struct if_stack.\n\n\t* gcc.dg/cpp/extratokens.c: Fix.\n\t* gcc.dg/cpp/skipping2.c: New tests.\n\nFrom-SVN: r44380", "tree": {"sha": "caee9edc9501482aa583e1040604f6f2a4d52aba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/caee9edc9501482aa583e1040604f6f2a4d52aba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cef0d199d24feb707b86db0ad2991823b276cd1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cef0d199d24feb707b86db0ad2991823b276cd1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cef0d199d24feb707b86db0ad2991823b276cd1a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cef0d199d24feb707b86db0ad2991823b276cd1a/comments", "author": null, "committer": null, "parents": [{"sha": "2e824adbe44a946c91c1ff94815963fd2bec93be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e824adbe44a946c91c1ff94815963fd2bec93be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e824adbe44a946c91c1ff94815963fd2bec93be"}], "stats": {"total": 136, "additions": 79, "deletions": 57}, "files": [{"sha": "35835ab68173532f25619cb88450baa9d0243977", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cef0d199d24feb707b86db0ad2991823b276cd1a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cef0d199d24feb707b86db0ad2991823b276cd1a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cef0d199d24feb707b86db0ad2991823b276cd1a", "patch": "@@ -1,3 +1,17 @@\n+2001-07-26  Neil Booth  <neil@cat.daikokuya.demon.co.uk>\n+\n+\t* cpphash.h (struct_lexer_state): Delete was_skipping.\n+\tMove skipping here from struct cpp_reader.\n+\t* cpplex.c (parse_identifier): Update.\n+\t(_cpp_lex_token): Don't skip tokens in a directive.\n+\t* cpplib.c (struct if_stack): Update.\n+\t(start_directive, end_directive): Don't change skipping state.\n+\t(_cpp_handle_directive): Update.\n+\t(do_ifdef, do_ifndef, do_if, do_elif): Similarly.\n+\t(do_else, do_endif): Update; only check for excess tokens if not\n+\tin a skipped conditional block.\n+\t(push_conditional): Update for new struct if_stack.\n+\n 2001-07-26  Graham Stott  <grahams@redhat.com>\n \n \t* function.c (locate_and_pad_parm): Also pad initial offset"}, {"sha": "a8221d98a25600b36ece04ca1c62b175e1b91880", "filename": "gcc/cpphash.h", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cef0d199d24feb707b86db0ad2991823b276cd1a/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cef0d199d24feb707b86db0ad2991823b276cd1a/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=cef0d199d24feb707b86db0ad2991823b276cd1a", "patch": "@@ -126,6 +126,9 @@ struct lexer_state\n   /* Nonzero if first token on line is CPP_HASH.  */\n   unsigned char in_directive;\n \n+  /* True if we are skipping a failed conditional group.  */\n+  unsigned char skipping;\n+\n   /* Nonzero if in a directive that takes angle-bracketed headers.  */\n   unsigned char angled_headers;\n \n@@ -216,9 +219,6 @@ struct cpp_buffer\n      buffers.  */\n   unsigned char from_stage3;\n \n-  /* Temporary storage for pfile->skipping whilst in a directive.  */\n-  unsigned char was_skipping;\n-\n   /* 1 = system header file, 2 = C system header file used for C++.  */\n   unsigned char sysp;\n \n@@ -342,9 +342,6 @@ struct cpp_reader\n   /* We're printed a warning recommending against using #import.  */\n   unsigned char import_warning;\n \n-  /* True if we are skipping a failed conditional group.  */\n-  unsigned char skipping;\n-\n   /* Whether to print our version number.  Done this way so\n      we don't get it twice for -v -version.  */\n   unsigned char print_version;"}, {"sha": "482174515231a910717a301a8c5ea58165c0c389", "filename": "gcc/cpplex.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cef0d199d24feb707b86db0ad2991823b276cd1a/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cef0d199d24feb707b86db0ad2991823b276cd1a/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=cef0d199d24feb707b86db0ad2991823b276cd1a", "patch": "@@ -509,7 +509,7 @@ parse_identifier (pfile, c)\n   /* $ is not a identifier character in the standard, but is commonly\n      accepted as an extension.  Don't warn about it in skipped\n      conditional blocks.  */\n-  if (saw_dollar && CPP_PEDANTIC (pfile) && ! pfile->skipping)\n+  if (saw_dollar && CPP_PEDANTIC (pfile) && ! pfile->state.skipping)\n     cpp_pedwarn (pfile, \"'$' character(s) in identifier\");\n \n   /* Identifiers are null-terminated.  */\n@@ -521,7 +521,7 @@ parse_identifier (pfile, c)\n     ht_lookup (pfile->hash_table, obstack_finish (stack), len, HT_ALLOCED);\n \n   /* Some identifiers require diagnostics when lexed.  */\n-  if (result->flags & NODE_DIAGNOSTIC && !pfile->skipping)\n+  if (result->flags & NODE_DIAGNOSTIC && !pfile->state.skipping)\n     {\n       /* It is allowed to poison the same identifier twice.  */\n       if ((result->flags & NODE_POISONED) && !pfile->state.poisoned_ok)\n@@ -888,7 +888,7 @@ _cpp_lex_token (pfile, result)\n       if (pfile->lexer_pos.col != 0 && !bol && !buffer->from_stage3)\n \tcpp_pedwarn (pfile, \"no newline at end of file\");\n       pfile->state.next_bol = 1;\n-      pfile->skipping = 0;\t/* In case missing #endif.  */\n+      pfile->state.skipping = 0;\t/* In case missing #endif.  */\n       result->type = CPP_EOF;\n       /* Don't do MI optimisation.  */\n       return;\n@@ -915,7 +915,7 @@ _cpp_lex_token (pfile, result)\n       buffer->read_ahead = c;\n       pfile->state.next_bol = 1;\n       result->type = CPP_EOF;\n-      /* Don't break; pfile->skipping might be true.  */\n+      /* Don't break; pfile->state.skipping might be true.  */\n       return;\n \n     case '?':\n@@ -1261,7 +1261,7 @@ _cpp_lex_token (pfile, result)\n       break;\n     }\n \n-  if (pfile->skipping)\n+  if (!pfile->state.in_directive && pfile->state.skipping)\n     goto skip;\n \n   /* If not in a directive, this token invalidates controlling macros.  */"}, {"sha": "c196c1f9c96cfe66a678a673e95f2db86ef91b05", "filename": "gcc/cpplib.c", "status": "modified", "additions": 37, "deletions": 45, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cef0d199d24feb707b86db0ad2991823b276cd1a/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cef0d199d24feb707b86db0ad2991823b276cd1a/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=cef0d199d24feb707b86db0ad2991823b276cd1a", "patch": "@@ -43,8 +43,9 @@ struct if_stack\n   struct if_stack *next;\n   cpp_lexer_pos pos;\t\t/* line and column where condition started */\n   const cpp_hashnode *mi_cmacro;/* macro name for #ifndef around entire file */\n-  unsigned char was_skipping;\t/* Value of pfile->skipping before this if.  */\n-  int type;\t\t\t/* type of last directive seen in this group */\n+  bool skip_elses;\t\t/* Can future #else / #elif be skipped?  */\n+  bool was_skipping;\t\t/* If were skipping on entry.  */\n+  int type;\t\t\t/* Most recent conditional, for diagnostics.  */\n };\n \n /* Values for the origin field of struct directive.  KANDR directives\n@@ -220,8 +221,6 @@ static void\n start_directive (pfile)\n      cpp_reader *pfile;\n {\n-  cpp_buffer *buffer = pfile->buffer;\n-\n   /* Setup in-directive state.  */\n   pfile->state.in_directive = 1;\n   pfile->state.save_comments = 0;\n@@ -232,10 +231,6 @@ start_directive (pfile)\n   /* Don't save directive tokens for external clients.  */\n   pfile->la_saved = pfile->la_write;\n   pfile->la_write = 0;\n-\n-  /* Turn off skipping.  */\n-  buffer->was_skipping = pfile->skipping;\n-  pfile->skipping = 0;\n }\n \n /* Called when leaving a directive, _Pragma or command-line directive.  */\n@@ -244,12 +239,6 @@ end_directive (pfile, skip_line)\n      cpp_reader *pfile;\n      int skip_line;\n {\n-  cpp_buffer *buffer = pfile->buffer;\n-\n-  /* Restore pfile->skipping before skip_rest_of_line, so that e.g.\n-     __VA_ARGS__ in the rest of the directive doesn't warn.  */\n-  pfile->skipping = buffer->was_skipping;\n-\n   /* We don't skip for an assembler #.  */\n   if (skip_line)\n     skip_rest_of_line (pfile);\n@@ -270,7 +259,6 @@ _cpp_handle_directive (pfile, indented)\n      cpp_reader *pfile;\n      int indented;\n {\n-  cpp_buffer *buffer = pfile->buffer;\n   const directive *dir = 0;\n   cpp_token dname;\n   int skip = 1;\n@@ -293,7 +281,7 @@ _cpp_handle_directive (pfile, indented)\n \t skipped conditional groups.  Complain about this form if\n \t we're being pedantic, but not if this is regurgitated input\n \t (preprocessed or fed back in by the C++ frontend).  */\n-      if (! buffer->was_skipping && CPP_OPTION (pfile, lang) != CLK_ASM)\n+      if (! pfile->state.skipping && CPP_OPTION (pfile, lang) != CLK_ASM)\n \t{\n \t  dir = &dtable[T_LINE];\n \t  pfile->state.line_extension = 1;\n@@ -361,7 +349,7 @@ _cpp_handle_directive (pfile, indented)\n \n \t  /* If we are skipping a failed conditional group, all\n \t     non-conditional directives are ignored.  */\n-\t  if (! buffer->was_skipping || (dir->flags & COND))\n+\t  if (! pfile->state.skipping || (dir->flags & COND))\n \t    {\n \t      /* Issue -pedantic warnings for extensions.   */\n \t      if (CPP_PEDANTIC (pfile) && dir->origin == EXTENSION)\n@@ -376,7 +364,7 @@ _cpp_handle_directive (pfile, indented)\n \t    }\n \t}\n     }\n-  else if (dname.type != CPP_EOF && ! buffer->was_skipping)\n+  else if (dname.type != CPP_EOF && ! pfile->state.skipping)\n     {\n       /* An unknown directive.  Don't complain about it in assembly\n \t source: we don't know where the comments are, and # may\n@@ -1256,7 +1244,7 @@ do_ifdef (pfile)\n {\n   int skip = 1;\n \n-  if (! pfile->buffer->was_skipping)\n+  if (! pfile->state.skipping)\n     {\n       const cpp_hashnode *node = lex_macro_node (pfile);\n \n@@ -1277,7 +1265,7 @@ do_ifndef (pfile)\n   int skip = 1;\n   const cpp_hashnode *node = 0;\n \n-  if (! pfile->buffer->was_skipping)\n+  if (! pfile->state.skipping)\n     {\n       node = lex_macro_node (pfile);\n       if (node)\n@@ -1302,7 +1290,7 @@ do_if (pfile)\n   int skip = 1;\n   const cpp_hashnode *cmacro = 0;\n \n-  if (! pfile->buffer->was_skipping)\n+  if (! pfile->state.skipping)\n     {\n       /* Controlling macro of #if ! defined ()  */\n       pfile->mi_ind_cmacro = 0;\n@@ -1336,16 +1324,17 @@ do_else (pfile)\n \t}\n       ifs->type = T_ELSE;\n \n-      /* Buffer->was_skipping is 1 if all conditionals in this chain\n-\t have been false, 2 if a conditional has been true.  */\n-      if (! ifs->was_skipping && buffer->was_skipping != 2)\n-\tbuffer->was_skipping = ! buffer->was_skipping;\n+      /* Skip any future (erroneous) #elses or #elifs.  */\n+      pfile->state.skipping = ifs->skip_elses;\n+      ifs->skip_elses = true;\n \n       /* Invalidate any controlling macro.  */\n       ifs->mi_cmacro = 0;\n-    }\n \n-  check_eol (pfile);\n+      /* Only check EOL if was not originally skipping.  */\n+      if (!ifs->was_skipping)\n+\tcheck_eol (pfile);\n+    }\n }\n \n /* handle a #elif directive by not changing if_stack either.  see the\n@@ -1370,23 +1359,23 @@ do_elif (pfile)\n \t}\n       ifs->type = T_ELIF;\n \n-      /* Don't evaluate #elif if our higher level is skipping.  */\n-      if (! ifs->was_skipping)\n+      /* Only evaluate this if we aren't skipping elses.  During\n+\t evaluation, set skipping to false to get lexer warnings.  */\n+      if (ifs->skip_elses)\n+\tpfile->state.skipping = 1;\n+      else\n \t{\n-\t  /* Buffer->was_skipping is 1 if all conditionals in this\n-\t     chain have been false, 2 if a conditional has been true.  */\n-\t  if (buffer->was_skipping == 1)\n-\t    buffer->was_skipping = ! _cpp_parse_expr (pfile);\n-\t  else\n-\t    buffer->was_skipping = 2;\n-\n-\t  /* Invalidate any controlling macro.  */\n-\t  ifs->mi_cmacro = 0;\n+\t  pfile->state.skipping = 0;\n+\t  pfile->state.skipping = ! _cpp_parse_expr (pfile);\n+\t  ifs->skip_elses = ! pfile->state.skipping;\n \t}\n+\n+      /* Invalidate any controlling macro.  */\n+      ifs->mi_cmacro = 0;\n     }\n }\n \n-/* #endif pops the if stack and resets pfile->skipping.  */\n+/* #endif pops the if stack and resets pfile->state.skipping.  */\n \n static void\n do_endif (pfile)\n@@ -1399,6 +1388,10 @@ do_endif (pfile)\n     cpp_error (pfile, \"#endif without #if\");\n   else\n     {\n+      /* Only check EOL if was not originally skipping.  */\n+      if (!ifs->was_skipping)\n+\tcheck_eol (pfile);\n+\n       /* If potential control macro, we go back outside again.  */\n       if (ifs->next == 0 && ifs->mi_cmacro)\n \t{\n@@ -1407,14 +1400,12 @@ do_endif (pfile)\n \t}\n \n       buffer->if_stack = ifs->next;\n-      buffer->was_skipping = ifs->was_skipping;\n+      pfile->state.skipping = ifs->was_skipping;\n       obstack_free (&pfile->buffer_ob, ifs);\n     }\n-\n-  check_eol (pfile);\n }\n \n-/* Push an if_stack entry and set pfile->skipping accordingly.\n+/* Push an if_stack entry and set pfile->state.skipping accordingly.\n    If this is a #ifndef starting at the beginning of a file,\n    CMACRO is the macro name tested by the #ifndef.  */\n \n@@ -1431,14 +1422,15 @@ push_conditional (pfile, skip, type, cmacro)\n   ifs = xobnew (&pfile->buffer_ob, struct if_stack);\n   ifs->pos = pfile->directive_pos;\n   ifs->next = buffer->if_stack;\n-  ifs->was_skipping = buffer->was_skipping;\n+  ifs->skip_elses = pfile->state.skipping || !skip;\n+  ifs->was_skipping = pfile->state.skipping;\n   ifs->type = type;\n   if (pfile->mi_state == MI_OUTSIDE && pfile->mi_cmacro == 0)\n     ifs->mi_cmacro = cmacro;\n   else\n     ifs->mi_cmacro = 0;\n \n-  buffer->was_skipping = skip;\n+  pfile->state.skipping = skip;\n   buffer->if_stack = ifs;\n }\n "}, {"sha": "805bbb5ebe66486476e4bba00f3e2668abbc9661", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cef0d199d24feb707b86db0ad2991823b276cd1a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cef0d199d24feb707b86db0ad2991823b276cd1a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cef0d199d24feb707b86db0ad2991823b276cd1a", "patch": "@@ -1,3 +1,8 @@\n+2001-07-26  Neil Booth  <neil@cat.daikokuya.demon.co.uk>\n+\n+\t* gcc.dg/cpp/extratokens.c: Fix.\n+\t* gcc.dg/cpp/skipping2.c: New tests.\n+\n 2001-07-25  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>\n \n \t* gcc.c-torture/execute/20010724-1.c: New file."}, {"sha": "c06a41d4c2b130e8449b75a283ebe3887357230c", "filename": "gcc/testsuite/gcc.dg/cpp/extratokens.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cef0d199d24feb707b86db0ad2991823b276cd1a/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fextratokens.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cef0d199d24feb707b86db0ad2991823b276cd1a/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fextratokens.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fextratokens.c?ref=cef0d199d24feb707b86db0ad2991823b276cd1a", "patch": "@@ -15,7 +15,7 @@\n #ifndef foo bar  /* { dg-error \"extra tokens\" \"tokens after #ifndef\" } */\n #endif\n \n-#if 0\n+#if 1 \n #if 0\n #else foo\t/* { dg-warning \"extra tokens\" \"tokens after #else\" } */\n #endif /\t/* { dg-warning \"extra tokens\" \"tokens after #endif\" } */"}, {"sha": "3b0d0f32c8ea8063b8ae9970fab99337d363e639", "filename": "gcc/testsuite/gcc.dg/cpp/skipping2.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cef0d199d24feb707b86db0ad2991823b276cd1a/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fskipping2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cef0d199d24feb707b86db0ad2991823b276cd1a/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fskipping2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fskipping2.c?ref=cef0d199d24feb707b86db0ad2991823b276cd1a", "patch": "@@ -0,0 +1,14 @@\n+/* Copyright (C) 2001 Free Software Foundation, Inc.  */\n+\n+/* { dg-do preprocess } */\n+\n+/* Tests that excess tokens in skipped conditional blocks don't warn.  */\n+\n+/* Source: Neil Booth, 25 Jul 2001.  */\n+\n+#if 0\n+#if foo\n+#else foo   /* { dg-bogus \"extra tokens\" \"extra tokens in skipped block\" } */\n+#endif foo  /* { dg-bogus \"extra tokens\" \"extra tokens in skipped block\" } */\n+#endif bar  /* { dg-warning \"extra tokens\" \"tokens after #endif\" } */\n+"}]}