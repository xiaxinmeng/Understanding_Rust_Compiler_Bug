{"sha": "82a2669ea738ba4bec4112408a16082e7356e7e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODJhMjY2OWVhNzM4YmE0YmVjNDExMjQwOGExNjA4MmU3MzU2ZTdlMQ==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@integrable-solutions.net", "date": "2003-05-31T12:53:41Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2003-05-31T12:53:41Z"}, "message": "decl.c (cp_binding_level::this_entity): Rename from this_class.\n\n\t* decl.c (cp_binding_level::this_entity): Rename from this_class.\n\t(cxx_scope_descriptor): New function.\n\t(cxx_scope_debug): Likewise.\n\t(push_binding_level): Use it.\n\t(pop_binding_level): Likewise.\n\t(suspend_binding_level): Likewise.\n\t(resume_binding_level): Likewise.\n\t(pushlevel_class): Adjust use of this_class.\n\t(pushtag): Likewise.\n\t(lookup_name_real): Likewise.\n\t(global_scope_name): New variable.\n\t(initialize_predefined_identifiers): Initialize it.\n\t(push_namespace): Use it.\n\t(make_cxx_scope): New function.\n\t(pushlevel): Use it.\n\t(pushlevel_class): Likewise.\n\t(push_binding_level): Simplify.  Loose the last two arguments.\n\t(make_binding_level): Remove.\n\t(initial_push__namespace_scope): New function.\n\t(push_namespace): Use it.  Simplify.\n\t(cxx_init_decl_processing): Likewise.\n\t(declare_namespace_level): Remove.\n\nFrom-SVN: r67269", "tree": {"sha": "ba6c2cfc95069e84c2bb826a49ec60521f7c8e40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba6c2cfc95069e84c2bb826a49ec60521f7c8e40"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/82a2669ea738ba4bec4112408a16082e7356e7e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82a2669ea738ba4bec4112408a16082e7356e7e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82a2669ea738ba4bec4112408a16082e7356e7e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82a2669ea738ba4bec4112408a16082e7356e7e1/comments", "author": {"login": "cxx-undef", "id": 5528103, "node_id": "MDQ6VXNlcjU1MjgxMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/5528103?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cxx-undef", "html_url": "https://github.com/cxx-undef", "followers_url": "https://api.github.com/users/cxx-undef/followers", "following_url": "https://api.github.com/users/cxx-undef/following{/other_user}", "gists_url": "https://api.github.com/users/cxx-undef/gists{/gist_id}", "starred_url": "https://api.github.com/users/cxx-undef/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cxx-undef/subscriptions", "organizations_url": "https://api.github.com/users/cxx-undef/orgs", "repos_url": "https://api.github.com/users/cxx-undef/repos", "events_url": "https://api.github.com/users/cxx-undef/events{/privacy}", "received_events_url": "https://api.github.com/users/cxx-undef/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "76d3baad59795d627f537ea623b0f0e654c3865a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76d3baad59795d627f537ea623b0f0e654c3865a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76d3baad59795d627f537ea623b0f0e654c3865a"}], "stats": {"total": 259, "additions": 150, "deletions": 109}, "files": [{"sha": "ec071aeb5590680c9c7a54f00fa90ad05f6afb29", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82a2669ea738ba4bec4112408a16082e7356e7e1/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82a2669ea738ba4bec4112408a16082e7356e7e1/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=82a2669ea738ba4bec4112408a16082e7356e7e1", "patch": "@@ -1,3 +1,28 @@\n+2003-05-31  Gabriel Dos Reis <gdr@integrable-solutions.net>\n+\n+\t* decl.c (cp_binding_level::this_entity): Rename from this_class.\n+\t(cxx_scope_descriptor): New function.\n+\t(cxx_scope_debug): Likewise.\n+\t(push_binding_level): Use it.\n+\t(pop_binding_level): Likewise.\n+\t(suspend_binding_level): Likewise.\n+\t(resume_binding_level): Likewise.\n+\t(pushlevel_class): Adjust use of this_class.\n+\t(pushtag): Likewise.\n+\t(lookup_name_real): Likewise.\n+\t(global_scope_name): New variable.\n+\t(initialize_predefined_identifiers): Initialize it.\n+\t(push_namespace): Use it.\n+\t(make_cxx_scope): New function.\n+\t(pushlevel): Use it.\n+\t(pushlevel_class): Likewise.\n+\t(push_binding_level): Simplify.  Loose the last two arguments.\n+\t(make_binding_level): Remove.\n+\t(initial_push__namespace_scope): New function.\n+\t(push_namespace): Use it.  Simplify.\n+\t(cxx_init_decl_processing): Likewise. \n+\t(declare_namespace_level): Remove.\n+\n 2003-05-31  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n \n \tPR c++/10956"}, {"sha": "4355df5b6bed638783a51b084911f3424665f2ce", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 125, "deletions": 109, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82a2669ea738ba4bec4112408a16082e7356e7e1/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82a2669ea738ba4bec4112408a16082e7356e7e1/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=82a2669ea738ba4bec4112408a16082e7356e7e1", "patch": "@@ -55,13 +55,10 @@ Boston, MA 02111-1307, USA.  */\n static tree grokparms (tree);\n static const char *redeclaration_error_message (tree, tree);\n \n-static void push_binding_level (struct cp_binding_level *, int,\n-\t\t\t\tint);\n+static void push_binding_level (cxx_scope *);\n static void pop_binding_level (void);\n static void suspend_binding_level (void);\n static void resume_binding_level (struct cp_binding_level *);\n-static struct cp_binding_level *make_binding_level (void);\n-static void declare_namespace_level (void);\n static int decl_jump_unsafe (tree);\n static void storedecls (tree);\n static void require_complete_types_for_parms (tree);\n@@ -203,6 +200,9 @@ tree cp_global_trees[CPTI_MAX];\n \n static GTY(()) tree global_type_node;\n \n+/* The node that holds the \"name\" of the global scope.  */\n+static GTY(()) tree global_scope_name;\n+\n /* Used only for jumps to as-yet undefined labels, since jumps to\n    defined labels can have their validity checked immediately.  */\n \n@@ -358,8 +358,9 @@ struct cp_binding_level GTY(())\n        that were entered and exited one level down.  */\n     tree blocks;\n \n-    /* The _TYPE node for this level, if parm_flag == 2.  */\n-    tree this_class;\n+    /* The entity (namespace, class, function) the scope of which this\n+       binding contour corresponds to.  Otherwise NULL.  */\n+    tree this_entity;\n \n     /* The binding level which this one is contained in (inherits from).  */\n     struct cp_binding_level *level_chain;\n@@ -464,27 +465,84 @@ indent (int depth)\n \n static tree pushdecl_with_scope\t(tree, struct cp_binding_level *);\n \n+/* Return a string describing the kind of SCOPE we have.  */\n+static const char *\n+cxx_scope_descriptor (cxx_scope *scope)\n+{\n+  const char *desc;\n+\n+  if (scope->namespace_p)\n+    desc = \"namespace-scope\";\n+  else if (scope->parm_flag == 1)\n+    desc = \"function-prototype-scope\";\n+  else if (scope->parm_flag == 2)\n+    desc = \"class-scope\";\n+  else if (scope->is_for_scope)\n+    desc = \"for-scope\";\n+  else if (scope->is_try_scope)\n+    desc = \"try-scope\";\n+  else if (scope->is_catch_scope)\n+    desc = \"catch-scope\";\n+  else if (scope->template_spec_p)\n+    desc = \"template-explicit-spec-scope\";\n+  else if (scope->template_parms_p)\n+    desc = \"template-prototype-scope\";\n+  else\n+    desc = \"block-scope\";\n+\n+  return desc;\n+}\n+\n+/* Output a debugging information about SCOPE when performning\n+   ACTION at LINE.  */\n static void\n-push_binding_level (struct cp_binding_level *newlevel, \n-                    int tag_transparent, \n-                    int keep)\n+cxx_scope_debug (cxx_scope *scope, int line, const char *action)\n+{\n+  const char *desc = cxx_scope_descriptor (scope);\n+  if (scope->this_entity)\n+    verbatim (\"%s %s(%E) %p %d\\n\", action, desc,\n+              scope->this_entity, (void *) scope, line);\n+  else\n+    verbatim (\"%s %s %p %d\\n\", action, desc, (void *) scope, line);\n+}\n+\n+/* Construct a scope that may be TAG-TRANSPARENT, the sub-blocks of\n+   which may be KEPT.  */\n+static inline cxx_scope *\n+make_cxx_scope (bool tag_transparent, int keep)\n+{\n+  cxx_scope *scope;\n+  \n+  /* Reuse or create a struct for this binding level.  */\n+  if (!ENABLE_SCOPE_CHECKING && free_binding_level)\n+    {\n+      scope = free_binding_level;\n+      free_binding_level = scope->level_chain;\n+    }\n+  else\n+    scope = ggc_alloc (sizeof (cxx_scope));\n+\n+  memset (scope, 0, sizeof (cxx_scope));\n+  scope->tag_transparent = tag_transparent;\n+  scope->keep = keep;\n+  scope->more_cleanups_ok = true;\n+\n+  return scope;\n+}\n+\n+static void\n+push_binding_level (cxx_scope *newlevel)\n {\n   /* Add this level to the front of the chain (stack) of levels that\n      are active.  */\n-  memset ((char*) newlevel, 0, sizeof (struct cp_binding_level));\n   newlevel->level_chain = current_binding_level;\n   current_binding_level = newlevel;\n-  newlevel->tag_transparent = tag_transparent;\n-  newlevel->more_cleanups_ok = 1;\n \n-  newlevel->keep = keep;\n   if (ENABLE_SCOPE_CHECKING)\n     {\n       newlevel->binding_depth = binding_depth;\n       indent (binding_depth);\n-      verbatim (\"push %s level %p line %d\\n\",\n-                (is_class_level) ? \"class\" : \"block\",\n-                (void *) newlevel, input_line);\n+      cxx_scope_debug (newlevel, input_location.line, \"push\");\n       is_class_level = 0;\n       binding_depth++;\n     }\n@@ -516,9 +574,7 @@ pop_binding_level (void)\n   if (ENABLE_SCOPE_CHECKING)\n     {\n       indent (--binding_depth);\n-      verbatim (\"pop  %s level %p line %d\\n\",\n-                (is_class_level) ? \"class\" : \"block\",\n-                (void*) current_binding_level, input_line);\n+      cxx_scope_debug (current_binding_level, input_location.line, \"pop\");\n       if (is_class_level != (current_binding_level == class_binding_level))\n         {\n           indent (binding_depth);\n@@ -556,9 +612,7 @@ suspend_binding_level (void)\n   if (ENABLE_SCOPE_CHECKING)\n     {\n       indent (--binding_depth);\n-      verbatim (\"suspend  %s level %p line %d\\n\",\n-                (is_class_level) ? \"class\" : \"block\",\n-                (void *) current_binding_level, input_line);\n+      cxx_scope_debug (current_binding_level, input_location.line, \"suspend\");\n       if (is_class_level != (current_binding_level == class_binding_level))\n         {\n           indent (binding_depth);\n@@ -584,23 +638,12 @@ resume_binding_level (struct cp_binding_level* b)\n     {\n       b->binding_depth = binding_depth;\n       indent (binding_depth);\n-      verbatim (\"resume %s level %p line %d\\n\",\n-                (is_class_level) ? \"class\" : \"block\", b, input_line);\n+      cxx_scope_debug (b, input_location.line, \"resume\");\n       is_class_level = 0;\n       binding_depth++;\n     }\n }\n \f\n-/* Create a new `struct cp_binding_level'.  */\n-\n-static\n-struct cp_binding_level *\n-make_binding_level (void)\n-{\n-  /* NOSTRICT */\n-  return (struct cp_binding_level *) ggc_alloc (sizeof (struct cp_binding_level));\n-}\n-\n /* Nonzero if we are currently in the global binding level.  */\n \n int\n@@ -671,12 +714,6 @@ kept_level_p (void)\n \t      && !current_binding_level->tag_transparent));\n }\n \n-static void\n-declare_namespace_level (void)\n-{\n-  current_binding_level->namespace_p = 1;\n-}\n-\n /* Returns nonzero if this scope was created to store template\n    parameters.  */\n \n@@ -787,21 +824,10 @@ set_class_shadows (tree shadows)\n void\n pushlevel (int tag_transparent)\n {\n-  struct cp_binding_level *newlevel;\n-\n   if (cfun && !doing_semantic_analysis_p ())\n     return;\n \n-  /* Reuse or create a struct for this binding level.  */\n-  if (!ENABLE_SCOPE_CHECKING && free_binding_level)\n-    {\n-      newlevel = free_binding_level;\n-      free_binding_level = free_binding_level->level_chain;\n-    }\n-  else\n-    newlevel = make_binding_level ();\n-\n-  push_binding_level (newlevel, tag_transparent, keep_next_level_flag);\n+  push_binding_level (make_cxx_scope (tag_transparent, keep_next_level_flag));\n   keep_next_level_flag = 0;\n }\n \n@@ -1550,25 +1576,14 @@ set_block (tree block ATTRIBUTE_UNUSED )\n void\n pushlevel_class (void)\n {\n-  register struct cp_binding_level *newlevel;\n-\n-  /* Reuse or create a struct for this binding level.  */\n-  if (!ENABLE_SCOPE_CHECKING && free_binding_level)\n-    {\n-      newlevel = free_binding_level;\n-      free_binding_level = free_binding_level->level_chain;\n-    }\n-  else\n-    newlevel = make_binding_level ();\n-\n   if (ENABLE_SCOPE_CHECKING)\n     is_class_level = 1;\n \n-  push_binding_level (newlevel, 0, 0);\n+  push_binding_level (make_cxx_scope (false, 0));\n \n   class_binding_level = current_binding_level;\n   class_binding_level->parm_flag = 2;\n-  class_binding_level->this_class = current_class_type;\n+  class_binding_level->this_entity = current_class_type;\n }\n \n /* ...and a poplevel for class declarations.  */\n@@ -1988,6 +2003,31 @@ print_binding_stack (void)\n    the identifier is polymorphic, with three possible values:\n    NULL_TREE, a list of \"cxx_binding\"s.  */\n \n+\n+/* Push the initial binding contour of NAMESPACE-scope.  Any subsequent\n+   push of NS is actually a resume.  */\n+static void\n+initial_push_namespace_scope (tree ns)\n+{\n+  tree name = DECL_NAME (ns);\n+  cxx_scope *scope;\n+\n+  pushlevel (0);\n+  scope = current_binding_level;\n+  scope->namespace_p = true;\n+  scope->type_decls = binding_table_new (name == std_identifier\n+                                         ? NAMESPACE_STD_HT_SIZE\n+                                         : (name == global_scope_name\n+                                            ? GLOBAL_SCOPE_HT_SIZE\n+                                            : NAMESPACE_ORDINARY_HT_SIZE));\n+  VARRAY_TREE_INIT (scope->static_decls,\n+                    name == std_identifier || name == global_scope_name\n+                    ? 200 : 10,\n+                    \"Static declarations\");\n+  scope->this_entity = ns;\n+  NAMESPACE_LEVEL (ns) = scope;\n+}\n+\n /* Push into the scope of the NAME namespace.  If NAME is NULL_TREE, then we\n    select a name that is unique to this compilation unit.  */\n \n@@ -1997,17 +2037,16 @@ push_namespace (tree name)\n   tree d = NULL_TREE;\n   int need_new = 1;\n   int implicit_use = 0;\n-  int global = 0;\n \n   timevar_push (TV_NAME_LOOKUP);\n   \n-  if (!global_namespace)\n-    {\n-      /* This must be ::.  */\n-      my_friendly_assert (name == get_identifier (\"::\"), 377);\n-      global = 1;\n-    }\n-  else if (!name)\n+  /* We should not get here if the global_namespace is not yet constructed\n+     nor if NAME designates the global namespace:  The global scope is\n+     constructed elsewhere.  */\n+  my_friendly_assert (global_namespace != NULL && name != global_scope_name,\n+                      20030531);\n+\n+  if (!name)\n     {\n       /* The name of anonymous namespace is unique for the translation\n          unit.  */\n@@ -2040,23 +2079,9 @@ push_namespace (tree name)\n     {\n       /* Make a new namespace, binding the name to it.  */\n       d = build_lang_decl (NAMESPACE_DECL, name, void_type_node);\n-      /* The global namespace is not pushed, and the global binding\n-\t level is set elsewhere.  */\n-      if (!global)\n-\t{\n-\t  DECL_CONTEXT (d) = FROB_CONTEXT (current_namespace);\n-\t  d = pushdecl (d);\n-\t  pushlevel (0);\n-\t  declare_namespace_level ();\n-\t  NAMESPACE_LEVEL (d) = current_binding_level;\n-          current_binding_level->type_decls =\n-            binding_table_new (name == std_identifier\n-                               ? NAMESPACE_STD_HT_SIZE\n-                               : NAMESPACE_ORDINARY_HT_SIZE);\n-\t  VARRAY_TREE_INIT (current_binding_level->static_decls,\n-\t\t\t    name != std_identifier ? 10 : 200,\n-\t\t\t    \"Static declarations\");\n-\t}\n+      DECL_CONTEXT (d) = FROB_CONTEXT (current_namespace);\n+      d = pushdecl (d);\n+      initial_push_namespace_scope (d);\n     }\n   else\n     resume_binding_level (NAMESPACE_LEVEL (d));\n@@ -2518,7 +2543,7 @@ pushtag (tree name, tree type, int globalize)\n \t\t    of a static member variable. We allow this when\n \t\t    not pedantic, and it is particularly useful for\n \t\t    type punning via an anonymous union.  */\n-\t\t || COMPLETE_TYPE_P (b->this_class))))\n+\t\t || COMPLETE_TYPE_P (b->this_entity))))\n     b = b->level_chain;\n \n   if (b->type_decls == NULL)\n@@ -5829,7 +5854,7 @@ lookup_name_real (tree name, int prefer_type, int nonclass,\n \t    continue;\n \t  \n \t  /* Lookup the conversion operator in the class.  */\n-\t  class_type = level->this_class;\n+\t  class_type = level->this_entity;\n \t  operators = lookup_fnfields (class_type, name, /*protect=*/0);\n \t  if (operators)\n \t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, operators);\n@@ -6104,6 +6129,7 @@ initialize_predefined_identifiers (void)\n     { VTABLE_PFN_NAME, &pfn_identifier, 0 },\n     { \"_vptr\", &vptr_identifier, 0 },\n     { \"__vtt_parm\", &vtt_parm_identifier, 0 },\n+    { \"::\", &global_scope_name, 0 },\n     { \"std\", &std_identifier, 0 },\n     { NULL, NULL, 0 }\n   };\n@@ -6136,10 +6162,15 @@ cxx_init_decl_processing (void)\n   /* Create the global variables.  */\n   push_to_top_level ();\n \n+  current_function_decl = NULL_TREE;\n+  current_binding_level = NULL_BINDING_LEVEL;\n+  free_binding_level = NULL_BINDING_LEVEL;\n   /* Enter the global namespace.  */\n   my_friendly_assert (global_namespace == NULL_TREE, 375);\n-  push_namespace (get_identifier (\"::\"));\n-  global_namespace = current_namespace;\n+  global_namespace = build_lang_decl (NAMESPACE_DECL, global_scope_name,\n+                                      void_type_node);\n+  initial_push_namespace_scope (global_namespace);\n+\n   current_lang_name = NULL_TREE;\n \n   /* Adjust various flags based on command-line settings.  */\n@@ -6165,26 +6196,11 @@ cxx_init_decl_processing (void)\n   /* Initially, C.  */\n   current_lang_name = lang_name_c;\n \n-  current_function_decl = NULL_TREE;\n-  current_binding_level = NULL_BINDING_LEVEL;\n-  free_binding_level = NULL_BINDING_LEVEL;\n-\n   build_common_tree_nodes (flag_signed_char);\n \n   error_mark_list = build_tree_list (error_mark_node, error_mark_node);\n   TREE_TYPE (error_mark_list) = error_mark_node;\n \n-  /* Make the binding_level structure for global names.  */\n-  pushlevel (0);\n-  current_binding_level->type_decls = binding_table_new (GLOBAL_SCOPE_HT_SIZE);\n-  /* The global level is the namespace level of ::.  */\n-  NAMESPACE_LEVEL (global_namespace) = current_binding_level;\n-  declare_namespace_level ();\n-\n-  VARRAY_TREE_INIT (current_binding_level->static_decls,\n-\t\t    200,\n-\t\t    \"Static declarations\");\n-\n   /* Create the `std' namespace.  */\n   push_namespace (std_identifier);\n   std_node = current_namespace;"}]}