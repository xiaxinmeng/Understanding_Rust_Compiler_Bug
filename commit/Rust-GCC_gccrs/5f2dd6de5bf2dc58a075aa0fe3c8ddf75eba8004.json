{"sha": "5f2dd6de5bf2dc58a075aa0fe3c8ddf75eba8004", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWYyZGQ2ZGU1YmYyZGM1OGEwNzVhYTBmZTNjOGRkZjc1ZWJhODAwNA==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2020-12-10T17:56:09Z"}, "committer": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2020-12-17T17:23:46Z"}, "message": "Add in HIR Tree\n\nThis is an IR based off the AST its almost a copy but with NodeMappings\non the parent Tree Types. This should ideally have all macro tree's\nremoved during the lowering process.", "tree": {"sha": "3f88a1ef7aa06d14f14d8fadc1251fc3cae07ddf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f88a1ef7aa06d14f14d8fadc1251fc3cae07ddf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f2dd6de5bf2dc58a075aa0fe3c8ddf75eba8004", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f2dd6de5bf2dc58a075aa0fe3c8ddf75eba8004", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f2dd6de5bf2dc58a075aa0fe3c8ddf75eba8004", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f2dd6de5bf2dc58a075aa0fe3c8ddf75eba8004/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "97d2003e8c0027601648364c3561b6aa479c842e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97d2003e8c0027601648364c3561b6aa479c842e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97d2003e8c0027601648364c3561b6aa479c842e"}], "stats": {"total": 19882, "additions": 19882, "deletions": 0}, "files": [{"sha": "dd42b1dbb6548f192012846514f21bd0743e8e00", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f2dd6de5bf2dc58a075aa0fe3c8ddf75eba8004/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f2dd6de5bf2dc58a075aa0fe3c8ddf75eba8004/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=5f2dd6de5bf2dc58a075aa0fe3c8ddf75eba8004", "patch": "@@ -75,6 +75,7 @@ GRS_OBJS = \\\n     rust/rust-compile.o \\\n     rust/rust-macro-expand.o \\\n     rust/rust-hir-map.o \\\n+    rust/rust-hir-full-test.o \\\n     $(END)\n # removed object files from here\n \n@@ -274,3 +275,8 @@ rust/%.o: rust/util/%.cc\n \t$(COMPILE) $(RUST_CXXFLAGS) $(RUST_INCLUDES) $<\n \t$(POSTCOMPILE)\n \n+# build rust/hir/tree files in rust folder\n+rust/%.o: rust/hir/tree/%.cc\n+\t$(COMPILE) $(RUST_CXXFLAGS) $(RUST_INCLUDES) $<\n+\t$(POSTCOMPILE)\n+"}, {"sha": "3a1ddf2aca4572e4245bd1a9a5dc86a8fd528f11", "filename": "gcc/rust/hir/tree/rust-hir-cond-compilation.h", "status": "added", "additions": 248, "deletions": 0, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f2dd6de5bf2dc58a075aa0fe3c8ddf75eba8004/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-cond-compilation.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f2dd6de5bf2dc58a075aa0fe3c8ddf75eba8004/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-cond-compilation.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-cond-compilation.h?ref=5f2dd6de5bf2dc58a075aa0fe3c8ddf75eba8004", "patch": "@@ -0,0 +1,248 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_CONDCOMPILATION\n+#define RUST_AST_CONDCOMPILATION\n+\n+#include \"rust-hir.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+// Base conditional compilation configuration predicate thing - abstract\n+class ConfigurationPredicate\n+{\n+public:\n+  virtual ~ConfigurationPredicate () {}\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<ConfigurationPredicate> clone_configuration_predicate () const\n+  {\n+    return std::unique_ptr<ConfigurationPredicate> (\n+      clone_configuration_predicate_impl ());\n+  }\n+\n+  // not sure if I'll use this but here anyway\n+  virtual void accept_vis (HIRVisitor &vis) = 0;\n+\n+protected:\n+  // Clone function impl to be overriden in base classes\n+  virtual ConfigurationPredicate *\n+  clone_configuration_predicate_impl () const = 0;\n+};\n+\n+// A configuration option - true if option is set, false if option is not set.\n+class ConfigurationOption : public ConfigurationPredicate\n+{\n+  Identifier option_name;\n+\n+  // bool has_string_literal_option_body;\n+  std::string option_value; // technically a string or raw string literal\n+\n+public:\n+  /* Returns whether the configuration option has a \"value\" part of the\n+   * key-value pair. */\n+  bool has_option_value () const { return !option_value.empty (); }\n+\n+  // Key-value pair constructor\n+  ConfigurationOption (Identifier option_name, std::string option_value)\n+    : option_name (option_name), option_value (option_value)\n+  {}\n+\n+  // Name-only constructor\n+  ConfigurationOption (Identifier option_name) : option_name (option_name) {}\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ConfigurationOption *clone_configuration_predicate_impl () const override\n+  {\n+    return new ConfigurationOption (*this);\n+  }\n+};\n+\n+// TODO: inline\n+struct ConfigurationPredicateList\n+{\n+  std::vector<std::unique_ptr<ConfigurationPredicate> > predicate_list;\n+};\n+\n+// Predicate that returns true if all of the supplied predicates return true.\n+class ConfigurationAll : public ConfigurationPredicate\n+{\n+  std::vector<std::unique_ptr<ConfigurationPredicate> >\n+    predicate_list; // inlined form\n+\n+public:\n+  ConfigurationAll (\n+    std::vector<std::unique_ptr<ConfigurationPredicate> > predicate_list)\n+    : predicate_list (predicate_list)\n+  {}\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ConfigurationAll *clone_configuration_predicate_impl () const override\n+  {\n+    return new ConfigurationAll (*this);\n+  }\n+};\n+\n+// Predicate that returns true if any of the supplied predicates are true.\n+class ConfigurationAny : public ConfigurationPredicate\n+{\n+  std::vector<std::unique_ptr<ConfigurationPredicate> >\n+    predicate_list; // inlined form\n+\n+public:\n+  ConfigurationAny (\n+    std::vector<std::unique_ptr<ConfigurationPredicate> > predicate_list)\n+    : predicate_list (predicate_list)\n+  {}\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ConfigurationAny *clone_configuration_predicate_impl () const override\n+  {\n+    return new ConfigurationAny (*this);\n+  }\n+};\n+\n+/* Predicate that produces the negation of a supplied other configuration\n+ * predicate. */\n+class ConfigurationNot : public ConfigurationPredicate\n+{\n+  std::unique_ptr<ConfigurationPredicate> config_to_negate;\n+\n+public:\n+  ConfigurationNot (ConfigurationPredicate *config_to_negate)\n+    : config_to_negate (config_to_negate)\n+  {}\n+\n+  // Copy constructor with clone\n+  ConfigurationNot (ConfigurationNot const &other)\n+    : config_to_negate (\n+      other.config_to_negate->clone_configuration_predicate ())\n+  {}\n+\n+  // Overloaded assignment operator to clone\n+  ConfigurationNot &operator= (ConfigurationNot const &other)\n+  {\n+    config_to_negate = other.config_to_negate->clone_configuration_predicate ();\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  ConfigurationNot (ConfigurationNot &&other) = default;\n+  ConfigurationNot &operator= (ConfigurationNot &&other) = default;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ConfigurationNot *clone_configuration_predicate_impl () const override\n+  {\n+    return new ConfigurationNot (*this);\n+  }\n+};\n+\n+// TODO: relationship to other attributes?\n+class CfgAttribute\n+{\n+  std::unique_ptr<ConfigurationPredicate> config_to_include;\n+\n+public:\n+  CfgAttribute (ConfigurationPredicate *config_to_include)\n+    : config_to_include (config_to_include)\n+  {}\n+\n+  // Copy constructor with clone\n+  CfgAttribute (CfgAttribute const &other)\n+    : config_to_include (\n+      other.config_to_include->clone_configuration_predicate ())\n+  {}\n+\n+  // Overloaded assignment operator to clone\n+  CfgAttribute &operator= (CfgAttribute const &other)\n+  {\n+    config_to_include\n+      = other.config_to_include->clone_configuration_predicate ();\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  CfgAttribute (CfgAttribute &&other) = default;\n+  CfgAttribute &operator= (CfgAttribute &&other) = default;\n+};\n+/* TODO: ok, best thing to do would be eliminating this class, making Attribute\n+ * has a \"is_cfg()\" method, and having attribute path as \"cfg\" and AttrInput as\n+ * ConfigurationPredicate (so make ConfigurationPredicate a subclass of\n+ * AttrInput?). Would need special handling in parser, however. */\n+\n+// TODO: inline\n+struct CfgAttrs\n+{\n+  std::vector<Attribute> cfg_attrs;\n+};\n+\n+// TODO: relationship to other attributes?\n+class CfgAttrAttribute\n+{\n+  std::unique_ptr<ConfigurationPredicate> config_to_include;\n+  std::vector<Attribute> cfg_attrs;\n+\n+public:\n+  CfgAttrAttribute (ConfigurationPredicate *config_to_include,\n+\t\t    std::vector<Attribute> cfg_attrs)\n+    : config_to_include (config_to_include), cfg_attrs (cfg_attrs)\n+  {}\n+\n+  // Copy constructor with clone\n+  CfgAttrAttribute (CfgAttrAttribute const &other)\n+    : config_to_include (\n+      other.config_to_include->clone_configuration_predicate ()),\n+      cfg_attrs (cfg_attrs)\n+  {}\n+\n+  // Overloaded assignment operator to clone\n+  CfgAttrAttribute &operator= (CfgAttrAttribute const &other)\n+  {\n+    config_to_include\n+      = other.config_to_include->clone_configuration_predicate ();\n+    cfg_attrs = other.cfg_attrs;\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  CfgAttrAttribute (CfgAttrAttribute &&other) = default;\n+  CfgAttrAttribute &operator= (CfgAttrAttribute &&other) = default;\n+};\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif"}, {"sha": "5f5bbf983983fa1949c8c5df669c8d42c4f26589", "filename": "gcc/rust/hir/tree/rust-hir-expr.h", "status": "added", "additions": 4480, "deletions": 0, "changes": 4480, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f2dd6de5bf2dc58a075aa0fe3c8ddf75eba8004/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f2dd6de5bf2dc58a075aa0fe3c8ddf75eba8004/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h?ref=5f2dd6de5bf2dc58a075aa0fe3c8ddf75eba8004"}, {"sha": "02b9f035fa9446681bcb09aa475fe048ae9f2d1e", "filename": "gcc/rust/hir/tree/rust-hir-full-decls.h", "status": "added", "additions": 285, "deletions": 0, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f2dd6de5bf2dc58a075aa0fe3c8ddf75eba8004/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-decls.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f2dd6de5bf2dc58a075aa0fe3c8ddf75eba8004/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-decls.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-decls.h?ref=5f2dd6de5bf2dc58a075aa0fe3c8ddf75eba8004", "patch": "@@ -0,0 +1,285 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_FULL_DECLS_H\n+#define RUST_HIR_FULL_DECLS_H\n+// Forward declarations for all HIR classes. Useful for not having to include\n+// all definitions.\n+\n+namespace Rust {\n+namespace HIR {\n+// rust-ast.h\n+class AttrInput;\n+class TokenTree;\n+class MacroMatch;\n+class Token;\n+struct Literal;\n+class DelimTokenTree;\n+class PathSegment;\n+class SimplePathSegment;\n+class SimplePath;\n+struct Attribute;\n+class MetaItemInner;\n+class AttrInputMetaItemContainer;\n+class MetaItem;\n+class Stmt;\n+class Item;\n+class Expr;\n+class ExprWithoutBlock;\n+class IdentifierExpr;\n+class Pattern;\n+class Type;\n+class TypeNoBounds;\n+class TypeParamBound;\n+class Lifetime;\n+class GenericParam;\n+class LifetimeParam;\n+class MacroItem;\n+class TraitItem;\n+class InherentImplItem;\n+class TraitImplItem;\n+class MacroInvocationSemi;\n+struct Crate;\n+class PathExpr;\n+\n+// rust-path.h\n+class PathIdentSegment;\n+struct GenericArgsBinding;\n+struct GenericArgs;\n+class PathExprSegment;\n+class PathPattern;\n+class PathInExpression;\n+class TypePathSegment;\n+class TypePathSegmentGeneric;\n+struct TypePathFunction;\n+class TypePathSegmentFunction;\n+class TypePath;\n+struct QualifiedPathType;\n+class QualifiedPathInExpression;\n+class QualifiedPathInType;\n+\n+// rust-expr.h\n+class ExprWithBlock;\n+class LiteralExpr;\n+class AttrInputLiteral;\n+class MetaItemLitExpr;\n+class MetaItemPathLit;\n+class OperatorExpr;\n+class BorrowExpr;\n+class DereferenceExpr;\n+class ErrorPropagationExpr;\n+class NegationExpr;\n+class ArithmeticOrLogicalExpr;\n+class ComparisonExpr;\n+class LazyBooleanExpr;\n+class TypeCastExpr;\n+class AssignmentExpr;\n+class CompoundAssignmentExpr;\n+class GroupedExpr;\n+class ArrayElems;\n+class ArrayElemsValues;\n+class ArrayElemsCopied;\n+class ArrayExpr;\n+class ArrayIndexExpr;\n+class TupleExpr;\n+class TupleIndexExpr;\n+class StructExpr;\n+class StructExprStruct;\n+struct StructBase;\n+class StructExprField;\n+class StructExprFieldIdentifier;\n+class StructExprFieldWithVal;\n+class StructExprFieldIdentifierValue;\n+class StructExprFieldIndexValue;\n+class StructExprStructFields;\n+class StructExprStructBase;\n+class StructExprTuple;\n+class StructExprUnit;\n+class EnumVariantExpr;\n+class EnumExprField;\n+class EnumExprFieldIdentifier;\n+class EnumExprFieldWithVal;\n+class EnumExprFieldIdentifierValue;\n+class EnumExprFieldIndexValue;\n+class EnumExprStruct;\n+class EnumExprTuple;\n+class EnumExprFieldless;\n+class CallExpr;\n+class MethodCallExpr;\n+class FieldAccessExpr;\n+struct ClosureParam;\n+class ClosureExpr;\n+class ClosureExprInner;\n+class BlockExpr;\n+class ClosureExprInnerTyped;\n+class ContinueExpr;\n+class BreakExpr;\n+class RangeExpr;\n+class RangeFromToExpr;\n+class RangeFromExpr;\n+class RangeToExpr;\n+class RangeFullExpr;\n+class RangeFromToInclExpr;\n+class RangeToInclExpr;\n+class ReturnExpr;\n+class UnsafeBlockExpr;\n+class LoopLabel;\n+class BaseLoopExpr;\n+class LoopExpr;\n+class WhileLoopExpr;\n+class WhileLetLoopExpr;\n+class ForLoopExpr;\n+class IfExpr;\n+class IfExprConseqElse;\n+class IfExprConseqIf;\n+class IfLetExpr;\n+class IfExprConseqIfLet;\n+class IfLetExprConseqElse;\n+class IfLetExprConseqIf;\n+class IfLetExprConseqIfLet;\n+struct MatchArm;\n+// class MatchCase;\n+// class MatchCaseBlockExpr;\n+// class MatchCaseExpr;\n+struct MatchCase;\n+class MatchExpr;\n+class AwaitExpr;\n+class AsyncBlockExpr;\n+\n+// rust-stmt.h\n+class EmptyStmt;\n+class LetStmt;\n+class ExprStmt;\n+class ExprStmtWithoutBlock;\n+class ExprStmtWithBlock;\n+\n+// rust-item.h\n+class TypeParam;\n+class WhereClauseItem;\n+class LifetimeWhereClauseItem;\n+class TypeBoundWhereClauseItem;\n+struct WhereClause;\n+struct SelfParam;\n+struct FunctionQualifiers;\n+struct FunctionParam;\n+struct Visibility;\n+class Method;\n+class VisItem;\n+class Module;\n+class ModuleBodied;\n+class ModuleNoBody;\n+class ExternCrate;\n+class UseTree;\n+class UseTreeGlob;\n+class UseTreeList;\n+class UseTreeRebind;\n+class UseDeclaration;\n+class Function;\n+class TypeAlias;\n+class Struct;\n+struct StructField;\n+class StructStruct;\n+struct TupleField;\n+class TupleStruct;\n+class EnumItem;\n+class EnumItemTuple;\n+class EnumItemStruct;\n+class EnumItemDiscriminant;\n+class Enum;\n+class Union;\n+class ConstantItem;\n+class StaticItem;\n+struct TraitFunctionDecl;\n+class TraitItemFunc;\n+struct TraitMethodDecl;\n+class TraitItemMethod;\n+class TraitItemConst;\n+class TraitItemType;\n+class Trait;\n+class Impl;\n+class InherentImpl;\n+class TraitImpl;\n+class ExternalItem;\n+class ExternalStaticItem;\n+struct NamedFunctionParam;\n+class ExternalFunctionItem;\n+class ExternBlock;\n+\n+// rust-macro.h\n+class MacroMatchFragment;\n+class MacroMatchRepetition;\n+class MacroMatcher;\n+struct MacroTranscriber;\n+struct MacroRule;\n+class MacroRulesDefinition;\n+class MacroInvocation;\n+class MetaItemPath;\n+class MetaItemSeq;\n+class MetaWord;\n+class MetaNameValueStr;\n+class MetaListPaths;\n+class MetaListNameValueStr;\n+\n+// rust-pattern.h\n+class LiteralPattern;\n+class IdentifierPattern;\n+class WildcardPattern;\n+class RangePatternBound;\n+class RangePatternBoundLiteral;\n+class RangePatternBoundPath;\n+class RangePatternBoundQualPath;\n+class RangePattern;\n+class ReferencePattern;\n+struct StructPatternEtc;\n+class StructPatternField;\n+class StructPatternFieldTuplePat;\n+class StructPatternFieldIdentPat;\n+class StructPatternFieldIdent;\n+struct StructPatternElements;\n+class StructPattern;\n+class TupleStructItems;\n+class TupleStructItemsNoRange;\n+class TupleStructItemsRange;\n+class TupleStructPattern;\n+class TuplePatternItems;\n+class TuplePatternItemsMultiple;\n+class TuplePatternItemsRanged;\n+class TuplePattern;\n+class GroupedPattern;\n+class SlicePattern;\n+\n+// rust-type.h\n+class TraitBound;\n+class ImplTraitType;\n+class TraitObjectType;\n+class ParenthesisedType;\n+class ImplTraitTypeOneBound;\n+class TraitObjectTypeOneBound;\n+class TupleType;\n+class NeverType;\n+class RawPointerType;\n+class ReferenceType;\n+class ArrayType;\n+class SliceType;\n+class InferredType;\n+struct MaybeNamedParam;\n+class BareFunctionType;\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif"}, {"sha": "0a87d259b1943ae36dca5e9e582e59aab539652c", "filename": "gcc/rust/hir/tree/rust-hir-full-test.cc", "status": "added", "additions": 6100, "deletions": 0, "changes": 6100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f2dd6de5bf2dc58a075aa0fe3c8ddf75eba8004/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f2dd6de5bf2dc58a075aa0fe3c8ddf75eba8004/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc?ref=5f2dd6de5bf2dc58a075aa0fe3c8ddf75eba8004"}, {"sha": "82525cd9b47b2327551e1a399154d0facc7cc90e", "filename": "gcc/rust/hir/tree/rust-hir-full.h", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f2dd6de5bf2dc58a075aa0fe3c8ddf75eba8004/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f2dd6de5bf2dc58a075aa0fe3c8ddf75eba8004/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full.h?ref=5f2dd6de5bf2dc58a075aa0fe3c8ddf75eba8004", "patch": "@@ -0,0 +1,32 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_FULL_H\n+#define RUST_HIR_FULL_H\n+\n+// Use as a fast way of including all aspects of the HIR (i.e. all headers)\n+#include \"rust-hir.h\"\n+#include \"rust-hir-expr.h\"\n+#include \"rust-hir-item.h\"\n+#include \"rust-hir-path.h\"\n+#include \"rust-hir-pattern.h\"\n+#include \"rust-hir-stmt.h\"\n+#include \"rust-hir-type.h\"\n+#include \"rust-hir-macro.h\"\n+\n+#endif // RUST_HIR_FULL_H"}, {"sha": "774e407ceabddd16a882e15859f615dd27126f58", "filename": "gcc/rust/hir/tree/rust-hir-item.h", "status": "added", "additions": 3293, "deletions": 0, "changes": 3293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f2dd6de5bf2dc58a075aa0fe3c8ddf75eba8004/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f2dd6de5bf2dc58a075aa0fe3c8ddf75eba8004/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h?ref=5f2dd6de5bf2dc58a075aa0fe3c8ddf75eba8004"}, {"sha": "0a38134b9e1a2f24975aafaa3143af78e8ea368d", "filename": "gcc/rust/hir/tree/rust-hir-macro.h", "status": "added", "additions": 627, "deletions": 0, "changes": 627, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f2dd6de5bf2dc58a075aa0fe3c8ddf75eba8004/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f2dd6de5bf2dc58a075aa0fe3c8ddf75eba8004/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-macro.h?ref=5f2dd6de5bf2dc58a075aa0fe3c8ddf75eba8004", "patch": "@@ -0,0 +1,627 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_MACRO_H\n+#define RUST_HIR_MACRO_H\n+\n+#include \"rust-hir.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+// Decls as definitions moved to rust-ast.h\n+class MacroItem;\n+class MacroInvocationSemi;\n+\n+enum MacroFragSpec\n+{\n+  BLOCK,\n+  EXPR,\n+  IDENT,\n+  ITEM,\n+  LIFETIME,\n+  LITERAL,\n+  META,\n+  PAT,\n+  PATH,\n+  STMT,\n+  TT,\n+  TY,\n+  VIS,\n+  INVALID // not really a specifier, but used to mark invalid one passed in\n+};\n+\n+inline MacroFragSpec\n+get_frag_spec_from_str (std::string str)\n+{\n+  if (str == \"block\")\n+    return BLOCK;\n+  else if (str == \"expr\")\n+    return EXPR;\n+  else if (str == \"ident\")\n+    return IDENT;\n+  else if (str == \"item\")\n+    return ITEM;\n+  else if (str == \"lifetime\")\n+    return LIFETIME;\n+  else if (str == \"literal\")\n+    return LITERAL;\n+  else if (str == \"meta\")\n+    return META;\n+  else if (str == \"pat\")\n+    return PAT;\n+  else if (str == \"path\")\n+    return PATH;\n+  else if (str == \"stmt\")\n+    return STMT;\n+  else if (str == \"tt\")\n+    return TT;\n+  else if (str == \"ty\")\n+    return TY;\n+  else if (str == \"vis\")\n+    return VIS;\n+  else\n+    {\n+      // error_at(\"invalid string '%s' used as fragment specifier\",\n+      // str->c_str());\n+      return INVALID;\n+    }\n+}\n+\n+// A macro match that has an identifier and fragment spec\n+class MacroMatchFragment : public MacroMatch\n+{\n+  Identifier ident;\n+  MacroFragSpec frag_spec;\n+\n+  // TODO: should store location information?\n+\n+public:\n+  MacroMatchFragment (Identifier ident, MacroFragSpec frag_spec)\n+    : ident (std::move (ident)), frag_spec (frag_spec)\n+  {}\n+\n+  // Returns whether macro match fragment is in an error state.\n+  bool is_error () const { return frag_spec == INVALID; }\n+\n+  // Creates an error state macro match fragment.\n+  static MacroMatchFragment create_error ()\n+  {\n+    return MacroMatchFragment (std::string (\"\"), INVALID);\n+  }\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  MacroMatchFragment *clone_macro_match_impl () const override\n+  {\n+    return new MacroMatchFragment (*this);\n+  }\n+};\n+\n+// A repetition macro match\n+class MacroMatchRepetition : public MacroMatch\n+{\n+public:\n+  enum MacroRepOp\n+  {\n+    NONE,\n+    ASTERISK,\n+    PLUS,\n+    QUESTION_MARK\n+  };\n+\n+private:\n+  std::vector<std::unique_ptr<MacroMatch> > matches;\n+  MacroRepOp op;\n+\n+  // bool has_sep;\n+  typedef Token MacroRepSep;\n+  // any token except delimiters and repetition operators\n+  std::unique_ptr<MacroRepSep> sep;\n+\n+  // TODO: should store location information?\n+\n+public:\n+  // Returns whether macro match repetition has separator token.\n+  bool has_sep () const { return sep != NULL; }\n+\n+  MacroMatchRepetition (std::vector<std::unique_ptr<MacroMatch> > matches,\n+\t\t\tMacroRepOp op, std::unique_ptr<MacroRepSep> sep)\n+    : matches (std::move (matches)), op (op), sep (std::move (sep))\n+  {}\n+\n+  // Copy constructor with clone\n+  MacroMatchRepetition (MacroMatchRepetition const &other)\n+    : op (other.op), sep (other.sep->clone_token ())\n+  {\n+    matches.reserve (other.matches.size ());\n+    for (const auto &e : other.matches)\n+      matches.push_back (e->clone_macro_match ());\n+  }\n+\n+  // Overloaded assignment operator to clone\n+  MacroMatchRepetition &operator= (MacroMatchRepetition const &other)\n+  {\n+    op = other.op;\n+    sep = other.sep->clone_token ();\n+\n+    matches.reserve (other.matches.size ());\n+    for (const auto &e : other.matches)\n+      matches.push_back (e->clone_macro_match ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  MacroMatchRepetition (MacroMatchRepetition &&other) = default;\n+  MacroMatchRepetition &operator= (MacroMatchRepetition &&other) = default;\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  MacroMatchRepetition *clone_macro_match_impl () const override\n+  {\n+    return new MacroMatchRepetition (*this);\n+  }\n+};\n+\n+// can't inline due to polymorphism\n+class MacroMatcher : public MacroMatch\n+{\n+  DelimType delim_type;\n+  std::vector<std::unique_ptr<MacroMatch> > matches;\n+\n+  // TODO: think of way to mark invalid that doesn't take up more space\n+  bool is_invalid;\n+\n+  // TODO: should store location information?\n+\n+public:\n+  MacroMatcher (DelimType delim_type,\n+\t\tstd::vector<std::unique_ptr<MacroMatch> > matches)\n+    : delim_type (delim_type), matches (std::move (matches)), is_invalid (false)\n+  {}\n+\n+  // copy constructor with vector clone\n+  MacroMatcher (MacroMatcher const &other) : delim_type (other.delim_type)\n+  {\n+    matches.reserve (other.matches.size ());\n+    for (const auto &e : other.matches)\n+      matches.push_back (e->clone_macro_match ());\n+  }\n+\n+  // overloaded assignment operator with vector clone\n+  MacroMatcher &operator= (MacroMatcher const &other)\n+  {\n+    delim_type = other.delim_type;\n+\n+    matches.reserve (other.matches.size ());\n+    for (const auto &e : other.matches)\n+      matches.push_back (e->clone_macro_match ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  MacroMatcher (MacroMatcher &&other) = default;\n+  MacroMatcher &operator= (MacroMatcher &&other) = default;\n+\n+  // Creates an error state macro matcher.\n+  static MacroMatcher create_error () { return MacroMatcher (true); }\n+\n+  // Returns whether MacroMatcher is in an error state.\n+  bool is_error () const { return is_invalid; }\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  MacroMatcher *clone_macro_match_impl () const override\n+  {\n+    return new MacroMatcher (*this);\n+  }\n+\n+  // constructor only used to create error matcher\n+  MacroMatcher (bool is_invalid) : delim_type (PARENS), is_invalid (is_invalid)\n+  {}\n+};\n+\n+// TODO: inline?\n+struct MacroTranscriber\n+{\n+private:\n+  DelimTokenTree token_tree;\n+\n+  // TODO: should store location information?\n+\n+public:\n+  MacroTranscriber (DelimTokenTree token_tree)\n+    : token_tree (std::move (token_tree))\n+  {}\n+\n+  std::string as_string () const { return token_tree.as_string (); }\n+};\n+\n+// A macro rule? Matcher and transcriber pair?\n+struct MacroRule\n+{\n+private:\n+  MacroMatcher matcher;\n+  MacroTranscriber transcriber;\n+\n+  // TODO: should store location information?\n+\n+public:\n+  MacroRule (MacroMatcher matcher, MacroTranscriber transcriber)\n+    : matcher (std::move (matcher)), transcriber (std::move (transcriber))\n+  {}\n+\n+  // Returns whether macro rule is in error state.\n+  bool is_error () const { return matcher.is_error (); }\n+\n+  // Creates an error state macro rule.\n+  static MacroRule create_error ()\n+  {\n+    return MacroRule (MacroMatcher::create_error (),\n+\t\t      MacroTranscriber (DelimTokenTree::create_empty ()));\n+  }\n+\n+  std::string as_string () const;\n+};\n+\n+// A macro rules definition item HIR node\n+class MacroRulesDefinition : public MacroItem\n+{\n+  Identifier rule_name;\n+  // MacroRulesDef rules_def; // TODO: inline\n+  // only curly without required semicolon at end\n+  DelimType delim_type;\n+  // MacroRules rules;\n+  std::vector<MacroRule> rules; // inlined form\n+\n+  Location locus;\n+\n+public:\n+  std::string as_string () const override;\n+\n+  MacroRulesDefinition (Analysis::NodeMapping mappings, Identifier rule_name,\n+\t\t\tDelimType delim_type, std::vector<MacroRule> rules,\n+\t\t\tstd::vector<Attribute> outer_attrs, Location locus)\n+    : MacroItem (std::move (mappings), std::move (outer_attrs)),\n+      rule_name (std::move (rule_name)), delim_type (delim_type),\n+      rules (std::move (rules)), locus (locus)\n+  {}\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  MacroRulesDefinition *clone_item_impl () const override\n+  {\n+    return new MacroRulesDefinition (*this);\n+  }\n+};\n+\n+/* HIR node of a macro invocation, which is replaced by the macro result at\n+ * compile time */\n+class MacroInvocation : public TypeNoBounds,\n+\t\t\tpublic Pattern,\n+\t\t\tpublic ExprWithoutBlock\n+{\n+  SimplePath path;\n+  DelimTokenTree token_tree;\n+  Location locus;\n+\n+public:\n+  std::string as_string () const override;\n+\n+  MacroInvocation (Analysis::NodeMapping mappings, SimplePath path,\n+\t\t   DelimTokenTree token_tree,\n+\t\t   std::vector<Attribute> outer_attrs, Location locus)\n+    : ExprWithoutBlock (std::move (mappings), std::move (outer_attrs)),\n+      path (std::move (path)), token_tree (std::move (token_tree)),\n+      locus (locus)\n+  {}\n+\n+  Location get_locus () const { return locus; }\n+  Location get_locus_slow () const override { return get_locus (); }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  MacroInvocation *clone_pattern_impl () const override\n+  {\n+    return new MacroInvocation (*this);\n+  }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  MacroInvocation *clone_expr_impl () const override\n+  {\n+    return new MacroInvocation (*this);\n+  }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  MacroInvocation *clone_expr_without_block_impl () const override\n+  {\n+    return new MacroInvocation (*this);\n+  }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  MacroInvocation *clone_type_impl () const override\n+  {\n+    return new MacroInvocation (*this);\n+  }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  MacroInvocation *clone_type_no_bounds_impl () const override\n+  {\n+    return new MacroInvocation (*this);\n+  }\n+};\n+\n+// more generic meta item path-only form\n+class MetaItemPath : public MetaItem\n+{\n+  SimplePath path;\n+\n+public:\n+  MetaItemPath (SimplePath path) : path (std::move (path)) {}\n+\n+  std::string as_string () const override { return path.as_string (); }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+  // HACK: used to simplify parsing - returns non-empty only in this case\n+  SimplePath to_path_item () const override\n+  {\n+    // this should copy construct - TODO ensure it does\n+    return path;\n+  }\n+\n+  Attribute to_attribute () const override;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this type\n+  MetaItemPath *clone_meta_item_inner_impl () const override\n+  {\n+    return new MetaItemPath (*this);\n+  }\n+};\n+\n+// more generic meta item sequence form\n+class MetaItemSeq : public MetaItem\n+{\n+  SimplePath path;\n+  std::vector<std::unique_ptr<MetaItemInner> > seq;\n+\n+public:\n+  MetaItemSeq (SimplePath path,\n+\t       std::vector<std::unique_ptr<MetaItemInner> > seq)\n+    : path (std::move (path)), seq (std::move (seq))\n+  {}\n+\n+  // copy constructor with vector clone\n+  MetaItemSeq (const MetaItemSeq &other) : path (other.path)\n+  {\n+    seq.reserve (other.seq.size ());\n+    for (const auto &e : other.seq)\n+      seq.push_back (e->clone_meta_item_inner ());\n+  }\n+\n+  // overloaded assignment operator with vector clone\n+  MetaItemSeq &operator= (const MetaItemSeq &other)\n+  {\n+    MetaItem::operator= (other);\n+    path = other.path;\n+\n+    seq.reserve (other.seq.size ());\n+    for (const auto &e : other.seq)\n+      seq.push_back (e->clone_meta_item_inner ());\n+\n+    return *this;\n+  }\n+\n+  // default move constructors\n+  MetaItemSeq (MetaItemSeq &&other) = default;\n+  MetaItemSeq &operator= (MetaItemSeq &&other) = default;\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+  Attribute to_attribute () const override;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this type\n+  MetaItemSeq *clone_meta_item_inner_impl () const override\n+  {\n+    return new MetaItemSeq (*this);\n+  }\n+};\n+\n+// Preferred specialisation for single-identifier meta items.\n+class MetaWord : public MetaItem\n+{\n+  Identifier ident;\n+\n+public:\n+  MetaWord (Identifier ident) : ident (std::move (ident)) {}\n+\n+  std::string as_string () const override { return ident; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+  Attribute to_attribute () const override;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this type\n+  MetaWord *clone_meta_item_inner_impl () const override\n+  {\n+    return new MetaWord (*this);\n+  }\n+};\n+\n+// Preferred specialisation for \"identifier '=' string literal\" meta items.\n+class MetaNameValueStr : public MetaItem\n+{\n+  Identifier ident;\n+  std::string str;\n+\n+public:\n+  MetaNameValueStr (Identifier ident, std::string str)\n+    : ident (std::move (ident)), str (std::move (str))\n+  {}\n+\n+  std::string as_string () const override { return ident + \" = \" + str; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+  // HACK: used to simplify parsing - creates a copy of this\n+  std::unique_ptr<MetaNameValueStr> to_meta_name_value_str () const override\n+  {\n+    return std::unique_ptr<MetaNameValueStr> (clone_meta_item_inner_impl ());\n+  }\n+\n+  Attribute to_attribute () const override;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this type\n+  MetaNameValueStr *clone_meta_item_inner_impl () const override\n+  {\n+    return new MetaNameValueStr (*this);\n+  }\n+};\n+\n+// doubles up as MetaListIdents - determine via iterating through each path?\n+// Preferred specialisation for \"identifier '(' SimplePath, SimplePath, ... ')'\"\n+class MetaListPaths : public MetaItem\n+{\n+  Identifier ident;\n+  std::vector<SimplePath> paths;\n+\n+public:\n+  MetaListPaths (Identifier ident, std::vector<SimplePath> paths)\n+    : ident (std::move (ident)), paths (std::move (paths))\n+  {}\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+  Attribute to_attribute () const override;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this type\n+  MetaListPaths *clone_meta_item_inner_impl () const override\n+  {\n+    return new MetaListPaths (*this);\n+  }\n+};\n+\n+// Preferred specialisation for \"identifier '(' MetaNameValueStr, ... ')'\"\n+class MetaListNameValueStr : public MetaItem\n+{\n+  Identifier ident;\n+  std::vector<MetaNameValueStr> strs;\n+\n+public:\n+  MetaListNameValueStr (Identifier ident, std::vector<MetaNameValueStr> strs)\n+    : ident (std::move (ident)), strs (std::move (strs))\n+  {}\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+  Attribute to_attribute () const override;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this type\n+  MetaListNameValueStr *clone_meta_item_inner_impl () const override\n+  {\n+    return new MetaListNameValueStr (*this);\n+  }\n+};\n+\n+// Object that parses macros from a token stream.\n+struct MacroParser\n+{\n+private:\n+  std::vector<std::unique_ptr<Token> > token_stream;\n+  /* probably have to make this mutable (mutable int stream_pos) otherwise const\n+   * has to be removed up to DelimTokenTree or further ok since this changing\n+   * would have an effect on the results of the methods run (i.e. not logically\n+   * const), the parsing methods shouldn't be const */\n+  int stream_pos;\n+\n+public:\n+  MacroParser (std::vector<std::unique_ptr<Token> > token_stream,\n+\t       int stream_start_pos = 0)\n+    : token_stream (std::move (token_stream)), stream_pos (stream_start_pos)\n+  {}\n+\n+  ~MacroParser () = default;\n+\n+  std::vector<std::unique_ptr<MetaItemInner> > parse_meta_item_seq ();\n+\n+private:\n+  // Parses a MetaItemInner.\n+  std::unique_ptr<MetaItemInner> parse_meta_item_inner ();\n+  // Returns whether token can end a meta item.\n+  bool is_end_meta_item_tok (TokenId id) const;\n+  // Parses a simple path.\n+  SimplePath parse_simple_path ();\n+  // Parses a segment of a simple path (but not scope resolution operator).\n+  SimplePathSegment parse_simple_path_segment ();\n+  // Parses a MetaItemLitExpr.\n+  std::unique_ptr<MetaItemLitExpr> parse_meta_item_lit ();\n+  // Parses a literal.\n+  Literal parse_literal ();\n+  // Parses a meta item that begins with a simple path.\n+  std::unique_ptr<MetaItem> parse_path_meta_item ();\n+\n+  // TODO: should this be const?\n+  std::unique_ptr<Token> &peek_token (int i = 0)\n+  {\n+    return token_stream[stream_pos + i];\n+  }\n+\n+  void skip_token (int i = 0) { stream_pos += 1 + i; }\n+};\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif"}, {"sha": "06d31aa5cf1d4072a6dfa5eb1f0f5882eb634128", "filename": "gcc/rust/hir/tree/rust-hir-path.h", "status": "added", "additions": 850, "deletions": 0, "changes": 850, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f2dd6de5bf2dc58a075aa0fe3c8ddf75eba8004/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f2dd6de5bf2dc58a075aa0fe3c8ddf75eba8004/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h?ref=5f2dd6de5bf2dc58a075aa0fe3c8ddf75eba8004", "patch": "@@ -0,0 +1,850 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_PATH_H\n+#define RUST_HIR_PATH_H\n+\n+#include \"rust-hir.h\"\n+\n+#include <string>\n+#include <vector>\n+\n+namespace Rust {\n+namespace HIR {\n+\n+// The \"identifier\" (not generic args) aspect of each path expression segment\n+class PathIdentSegment\n+{\n+  std::string segment_name;\n+\n+  // TODO: should this have location info stored?\n+\n+  // only allow identifiers, \"super\", \"self\", \"Self\", \"crate\", or \"$crate\"\n+public:\n+  PathIdentSegment (std::string segment_name)\n+    : segment_name (std::move (segment_name))\n+  {}\n+\n+  /* TODO: insert check in constructor for this? Or is this a semantic error\n+   * best handled then? */\n+\n+  /* TODO: does this require visitor? pretty sure this isn't polymorphic, but\n+   * not entirely sure */\n+\n+  // Creates an error PathIdentSegment.\n+  static PathIdentSegment create_error () { return PathIdentSegment (\"\"); }\n+\n+  // Returns whether PathIdentSegment is in an error state.\n+  bool is_error () const { return segment_name.empty (); }\n+\n+  std::string as_string () const { return segment_name; }\n+};\n+\n+// A binding of an identifier to a type used in generic arguments in paths\n+struct GenericArgsBinding\n+{\n+private:\n+  Identifier identifier;\n+  std::unique_ptr<Type> type;\n+\n+  Location locus;\n+\n+public:\n+  // Returns whether binding is in an error state.\n+  bool is_error () const\n+  {\n+    return type == nullptr;\n+    // and also identifier is empty, but cheaper computation\n+  }\n+\n+  // Creates an error state generic args binding.\n+  static GenericArgsBinding create_error ()\n+  {\n+    return GenericArgsBinding (\"\", nullptr);\n+  }\n+\n+  // Pointer type for type in constructor to enable polymorphism\n+  GenericArgsBinding (Identifier ident, std::unique_ptr<Type> type_ptr,\n+\t\t      Location locus = Location ())\n+    : identifier (std::move (ident)), type (std::move (type_ptr)), locus (locus)\n+  {}\n+\n+  // Copy constructor has to deep copy the type as it is a unique pointer\n+  GenericArgsBinding (GenericArgsBinding const &other)\n+    : identifier (other.identifier), type (other.type->clone_type ()),\n+      locus (other.locus)\n+  {}\n+\n+  // default destructor\n+  ~GenericArgsBinding () = default;\n+\n+  // Overload assignment operator to deep copy the pointed-to type\n+  GenericArgsBinding &operator= (GenericArgsBinding const &other)\n+  {\n+    identifier = other.identifier;\n+    type = other.type->clone_type ();\n+    locus = other.locus;\n+    return *this;\n+  }\n+\n+  // move constructors\n+  GenericArgsBinding (GenericArgsBinding &&other) = default;\n+  GenericArgsBinding &operator= (GenericArgsBinding &&other) = default;\n+\n+  std::string as_string () const;\n+};\n+\n+// Generic arguments allowed in each path expression segment - inline?\n+struct GenericArgs\n+{\n+  std::vector<Lifetime> lifetime_args;\n+  std::vector<std::unique_ptr<Type> > type_args;\n+  std::vector<GenericArgsBinding> binding_args;\n+  Location locus;\n+\n+public:\n+  // Returns true if there are any generic arguments\n+  bool has_generic_args () const\n+  {\n+    return !(lifetime_args.empty () && type_args.empty ()\n+\t     && binding_args.empty ());\n+  }\n+\n+  GenericArgs (std::vector<Lifetime> lifetime_args,\n+\t       std::vector<std::unique_ptr<Type> > type_args,\n+\t       std::vector<GenericArgsBinding> binding_args,\n+\t       Location locus = Location ())\n+    : lifetime_args (std::move (lifetime_args)),\n+      type_args (std::move (type_args)),\n+      binding_args (std::move (binding_args)), locus (locus)\n+  {}\n+\n+  // copy constructor with vector clone\n+  GenericArgs (GenericArgs const &other)\n+    : lifetime_args (other.lifetime_args), binding_args (other.binding_args),\n+      locus (other.locus)\n+  {\n+    type_args.reserve (other.type_args.size ());\n+    for (const auto &e : other.type_args)\n+      type_args.push_back (e->clone_type ());\n+  }\n+\n+  ~GenericArgs () = default;\n+\n+  // overloaded assignment operator to vector clone\n+  GenericArgs &operator= (GenericArgs const &other)\n+  {\n+    lifetime_args = other.lifetime_args;\n+    binding_args = other.binding_args;\n+    locus = other.locus;\n+\n+    type_args.reserve (other.type_args.size ());\n+    for (const auto &e : other.type_args)\n+      type_args.push_back (e->clone_type ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  GenericArgs (GenericArgs &&other) = default;\n+  GenericArgs &operator= (GenericArgs &&other) = default;\n+\n+  // Creates an empty GenericArgs (no arguments)\n+  static GenericArgs create_empty ()\n+  {\n+    return GenericArgs (std::vector<Lifetime> (),\n+\t\t\tstd::vector<std::unique_ptr<Type> > (),\n+\t\t\tstd::vector<GenericArgsBinding> ());\n+  }\n+\n+  std::string as_string () const;\n+};\n+\n+/* A segment of a path in expression, including an identifier aspect and maybe\n+ * generic args */\n+class PathExprSegment\n+{ // or should this extend PathIdentSegment?\n+private:\n+  PathIdentSegment segment_name;\n+\n+  // bool has_generic_args;\n+  GenericArgs generic_args;\n+\n+  Location locus;\n+\n+  // TODO: does this require visitor? pretty sure not polymorphic\n+\n+public:\n+  // Returns true if there are any generic arguments\n+  bool has_generic_args () const { return generic_args.has_generic_args (); }\n+\n+  // Constructor for segment (from IdentSegment and GenericArgs)\n+  PathExprSegment (PathIdentSegment segment_name, Location locus = Location (),\n+\t\t   GenericArgs generic_args = GenericArgs::create_empty ())\n+    : segment_name (std::move (segment_name)),\n+      generic_args (std::move (generic_args)), locus (locus)\n+  {}\n+\n+  /* Constructor for segment with generic arguments (from segment name and all\n+   * args) */\n+  PathExprSegment (std::string segment_name, Location locus,\n+\t\t   std::vector<Lifetime> lifetime_args\n+\t\t   = std::vector<Lifetime> (),\n+\t\t   std::vector<std::unique_ptr<Type> > type_args\n+\t\t   = std::vector<std::unique_ptr<Type> > (),\n+\t\t   std::vector<GenericArgsBinding> binding_args\n+\t\t   = std::vector<GenericArgsBinding> ())\n+    : segment_name (PathIdentSegment (std::move (segment_name))),\n+      generic_args (GenericArgs (std::move (lifetime_args),\n+\t\t\t\t std::move (type_args),\n+\t\t\t\t std::move (binding_args))),\n+      locus (locus)\n+  {}\n+\n+  // Returns whether path expression segment is in an error state.\n+  bool is_error () const { return segment_name.is_error (); }\n+\n+  // Creates an error-state path expression segment.\n+  static PathExprSegment create_error ()\n+  {\n+    return PathExprSegment (PathIdentSegment::create_error ());\n+  }\n+\n+  std::string as_string () const;\n+\n+  Location get_locus () const { return locus; }\n+};\n+\n+// HIR node representing a pattern that involves a \"path\" - abstract base class\n+class PathPattern : public Pattern\n+{\n+  std::vector<PathExprSegment> segments;\n+\n+protected:\n+  PathPattern (std::vector<PathExprSegment> segments)\n+    : segments (std::move (segments))\n+  {}\n+\n+  // Returns whether path has segments.\n+  bool has_segments () const { return !segments.empty (); }\n+\n+  /* Converts path segments to their equivalent SimplePath segments if possible,\n+   * and creates a SimplePath from them. */\n+  SimplePath convert_to_simple_path (bool with_opening_scope_resolution) const;\n+\n+public:\n+  /* Returns whether the path is a single segment (excluding qualified path\n+   * initial as segment). */\n+  bool is_single_segment () const { return segments.size () == 1; }\n+\n+  std::string as_string () const override;\n+\n+  void iterate_path_segments (std::function<bool (PathExprSegment &)> cb)\n+  {\n+    for (auto it = segments.begin (); it != segments.end (); it++)\n+      {\n+\tif (!cb (*it))\n+\t  return;\n+      }\n+  }\n+};\n+\n+/* HIR node representing a path-in-expression pattern (path that allows generic\n+ * arguments) */\n+class PathInExpression : public PathPattern, public PathExpr\n+{\n+  bool has_opening_scope_resolution;\n+  Location locus;\n+\n+public:\n+  std::string as_string () const override;\n+\n+  // Constructor\n+  PathInExpression (Analysis::NodeMapping mappings,\n+\t\t    std::vector<PathExprSegment> path_segments,\n+\t\t    Location locus = Location (),\n+\t\t    bool has_opening_scope_resolution = false,\n+\t\t    std::vector<Attribute> outer_attrs\n+\t\t    = std::vector<Attribute> ())\n+    : PathPattern (std::move (path_segments)),\n+      PathExpr (std::move (mappings), std::move (outer_attrs)),\n+      has_opening_scope_resolution (has_opening_scope_resolution), locus (locus)\n+  {}\n+\n+  // Creates an error state path in expression.\n+  static PathInExpression create_error ()\n+  {\n+    return PathInExpression (Analysis::NodeMapping::get_error (),\n+\t\t\t     std::vector<PathExprSegment> ());\n+  }\n+\n+  // Returns whether path in expression is in an error state.\n+  bool is_error () const { return !has_segments (); }\n+\n+  /* Converts PathInExpression to SimplePath if possible (i.e. no generic\n+   * arguments). Otherwise returns an empty SimplePath. */\n+  SimplePath as_simple_path () const\n+  {\n+    /* delegate to parent class as can't access segments. however,\n+     * QualifiedPathInExpression conversion to simple path wouldn't make sense,\n+     * so the method in the parent class should be protected, not public. Have\n+     * to pass in opening scope resolution as parent class has no access to it.\n+     */\n+    return convert_to_simple_path (has_opening_scope_resolution);\n+  }\n+\n+  Location get_locus () const { return locus; }\n+  Location get_locus_slow () const override { return get_locus (); }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+  bool opening_scope_resolution () { return has_opening_scope_resolution; }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  PathInExpression *clone_pattern_impl () const override\n+  {\n+    return new PathInExpression (*this);\n+  }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  PathInExpression *clone_expr_without_block_impl () const override\n+  {\n+    return new PathInExpression (*this);\n+  }\n+};\n+\n+/* Base class for segments used in type paths - not abstract (represents an\n+ * ident-only segment) */\n+class TypePathSegment\n+{\n+  /* TODO: may have to unify TypePathSegment and PathExprSegment (which are\n+   * mostly the same anyway) in order to resolve goddamn syntax ambiguities. One\n+   * difference is that function on TypePathSegment is not allowed if\n+   * GenericArgs are, so could disallow that in constructor, which won't give\n+   * that much size overhead. */\n+  PathIdentSegment ident_segment;\n+\n+  Location locus;\n+\n+protected:\n+  /* This is protected because it is only really used by derived classes, not\n+   * the base. */\n+  bool has_separating_scope_resolution;\n+\n+  // Clone function implementation - not pure virtual as overrided by subclasses\n+  virtual TypePathSegment *clone_type_path_segment_impl () const\n+  {\n+    return new TypePathSegment (*this);\n+  }\n+\n+public:\n+  virtual ~TypePathSegment () {}\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<TypePathSegment> clone_type_path_segment () const\n+  {\n+    return std::unique_ptr<TypePathSegment> (clone_type_path_segment_impl ());\n+  }\n+\n+  TypePathSegment (PathIdentSegment ident_segment,\n+\t\t   bool has_separating_scope_resolution, Location locus)\n+    : ident_segment (std::move (ident_segment)), locus (locus),\n+      has_separating_scope_resolution (has_separating_scope_resolution)\n+  {}\n+\n+  TypePathSegment (std::string segment_name,\n+\t\t   bool has_separating_scope_resolution, Location locus)\n+    : ident_segment (PathIdentSegment (std::move (segment_name))),\n+      locus (locus),\n+      has_separating_scope_resolution (has_separating_scope_resolution)\n+  {}\n+\n+  virtual std::string as_string () const { return ident_segment.as_string (); }\n+\n+  /* Returns whether the type path segment is in an error state. May be virtual\n+   * in future. */\n+  bool is_error () const { return ident_segment.is_error (); }\n+\n+  /* Returns whether segment is identifier only (as opposed to generic args or\n+   * function). Overriden in derived classes with other segments. */\n+  virtual bool is_ident_only () const { return true; }\n+\n+  Location get_locus () const { return locus; }\n+\n+  // not pure virtual as class not abstract\n+  virtual void accept_vis (HIRVisitor &vis);\n+};\n+\n+// Segment used in type path with generic args\n+class TypePathSegmentGeneric : public TypePathSegment\n+{\n+  GenericArgs generic_args;\n+\n+public:\n+  bool has_generic_args () const { return generic_args.has_generic_args (); }\n+\n+  bool is_ident_only () const override { return false; }\n+\n+  // Constructor with PathIdentSegment and GenericArgs\n+  TypePathSegmentGeneric (PathIdentSegment ident_segment,\n+\t\t\t  bool has_separating_scope_resolution,\n+\t\t\t  GenericArgs generic_args, Location locus)\n+    : TypePathSegment (std::move (ident_segment),\n+\t\t       has_separating_scope_resolution, locus),\n+      generic_args (std::move (generic_args))\n+  {}\n+\n+  // Constructor from segment name and all args\n+  TypePathSegmentGeneric (std::string segment_name,\n+\t\t\t  bool has_separating_scope_resolution,\n+\t\t\t  std::vector<Lifetime> lifetime_args,\n+\t\t\t  std::vector<std::unique_ptr<Type> > type_args,\n+\t\t\t  std::vector<GenericArgsBinding> binding_args,\n+\t\t\t  Location locus)\n+    : TypePathSegment (std::move (segment_name),\n+\t\t       has_separating_scope_resolution, locus),\n+      generic_args (GenericArgs (std::move (lifetime_args),\n+\t\t\t\t std::move (type_args),\n+\t\t\t\t std::move (binding_args)))\n+  {}\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  // Use covariance to override base class method\n+  TypePathSegmentGeneric *clone_type_path_segment_impl () const override\n+  {\n+    return new TypePathSegmentGeneric (*this);\n+  }\n+};\n+\n+// A function as represented in a type path\n+struct TypePathFunction\n+{\n+private:\n+  // TODO: remove\n+  /*bool has_inputs;\n+  TypePathFnInputs inputs;*/\n+  // inlined from TypePathFnInputs\n+  std::vector<std::unique_ptr<Type> > inputs;\n+\n+  // bool has_type;\n+  std::unique_ptr<Type> return_type;\n+\n+  // FIXME: think of better way to mark as invalid than taking up storage\n+  bool is_invalid;\n+\n+  // TODO: should this have location info?\n+\n+protected:\n+  // Constructor only used to create invalid type path functions.\n+  TypePathFunction (bool is_invalid) : is_invalid (is_invalid) {}\n+\n+public:\n+  // Returns whether the return type of the function has been specified.\n+  bool has_return_type () const { return return_type != nullptr; }\n+\n+  // Returns whether the function has inputs.\n+  bool has_inputs () const { return !inputs.empty (); }\n+\n+  // Returns whether function is in an error state.\n+  bool is_error () const { return is_invalid; }\n+\n+  // Creates an error state function.\n+  static TypePathFunction create_error () { return TypePathFunction (true); }\n+\n+  // Constructor\n+  TypePathFunction (std::vector<std::unique_ptr<Type> > inputs,\n+\t\t    Type *type = nullptr)\n+    : inputs (std::move (inputs)), return_type (type), is_invalid (false)\n+  {}\n+  // FIXME: deprecated\n+\n+  // Constructor\n+  TypePathFunction (std::vector<std::unique_ptr<Type> > inputs,\n+\t\t    std::unique_ptr<Type> type = nullptr)\n+    : inputs (std::move (inputs)), return_type (std::move (type)),\n+      is_invalid (false)\n+  {}\n+\n+  // Copy constructor with clone\n+  TypePathFunction (TypePathFunction const &other)\n+    : return_type (other.return_type->clone_type ()),\n+      is_invalid (other.is_invalid)\n+  {\n+    inputs.reserve (other.inputs.size ());\n+    for (const auto &e : other.inputs)\n+      inputs.push_back (e->clone_type ());\n+  }\n+\n+  ~TypePathFunction () = default;\n+\n+  // Overloaded assignment operator to clone type\n+  TypePathFunction &operator= (TypePathFunction const &other)\n+  {\n+    return_type = other.return_type->clone_type ();\n+    is_invalid = other.is_invalid;\n+\n+    inputs.reserve (other.inputs.size ());\n+    for (const auto &e : other.inputs)\n+      inputs.push_back (e->clone_type ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  TypePathFunction (TypePathFunction &&other) = default;\n+  TypePathFunction &operator= (TypePathFunction &&other) = default;\n+\n+  std::string as_string () const;\n+};\n+\n+// Segment used in type path with a function argument\n+class TypePathSegmentFunction : public TypePathSegment\n+{\n+  TypePathFunction function_path;\n+\n+public:\n+  // Constructor with PathIdentSegment and TypePathFn\n+  TypePathSegmentFunction (PathIdentSegment ident_segment,\n+\t\t\t   bool has_separating_scope_resolution,\n+\t\t\t   TypePathFunction function_path, Location locus)\n+    : TypePathSegment (std::move (ident_segment),\n+\t\t       has_separating_scope_resolution, locus),\n+      function_path (std::move (function_path))\n+  {}\n+\n+  // Constructor with segment name and TypePathFn\n+  TypePathSegmentFunction (std::string segment_name,\n+\t\t\t   bool has_separating_scope_resolution,\n+\t\t\t   TypePathFunction function_path, Location locus)\n+    : TypePathSegment (std::move (segment_name),\n+\t\t       has_separating_scope_resolution, locus),\n+      function_path (std::move (function_path))\n+  {}\n+\n+  std::string as_string () const override;\n+\n+  bool is_ident_only () const override { return false; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  // Use covariance to override base class method\n+  TypePathSegmentFunction *clone_type_path_segment_impl () const override\n+  {\n+    return new TypePathSegmentFunction (*this);\n+  }\n+};\n+\n+// Path used inside types\n+class TypePath : public TypeNoBounds\n+{\n+public:\n+  bool has_opening_scope_resolution;\n+  std::vector<std::unique_ptr<TypePathSegment> > segments;\n+  Location locus;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TypePath *clone_type_impl () const override { return new TypePath (*this); }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TypePath *clone_type_no_bounds_impl () const override\n+  {\n+    return new TypePath (*this);\n+  }\n+\n+public:\n+  /* Returns whether the TypePath has an opening scope resolution operator (i.e.\n+   * is global path or crate-relative path, not module-relative) */\n+  bool has_opening_scope_resolution_op () const\n+  {\n+    return has_opening_scope_resolution;\n+  }\n+\n+  // Returns whether the TypePath is in an invalid state.\n+  bool is_error () const { return segments.empty (); }\n+\n+  // Creates an error state TypePath.\n+  static TypePath create_error ()\n+  {\n+    return TypePath (std::vector<std::unique_ptr<TypePathSegment> > (),\n+\t\t     Location ());\n+  }\n+\n+  // Constructor\n+  TypePath (std::vector<std::unique_ptr<TypePathSegment> > segments,\n+\t    Location locus, bool has_opening_scope_resolution = false)\n+    : has_opening_scope_resolution (has_opening_scope_resolution),\n+      segments (std::move (segments)), locus (locus)\n+  {}\n+\n+  // Copy constructor with vector clone\n+  TypePath (TypePath const &other)\n+    : has_opening_scope_resolution (other.has_opening_scope_resolution),\n+      locus (other.locus)\n+  {\n+    segments.reserve (other.segments.size ());\n+    for (const auto &e : other.segments)\n+      segments.push_back (e->clone_type_path_segment ());\n+  }\n+\n+  // Overloaded assignment operator with clone\n+  TypePath &operator= (TypePath const &other)\n+  {\n+    has_opening_scope_resolution = other.has_opening_scope_resolution;\n+    locus = other.locus;\n+\n+    segments.reserve (other.segments.size ());\n+    for (const auto &e : other.segments)\n+      segments.push_back (e->clone_type_path_segment ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  TypePath (TypePath &&other) = default;\n+  TypePath &operator= (TypePath &&other) = default;\n+\n+  std::string as_string () const override;\n+\n+  /* Converts TypePath to SimplePath if possible (i.e. no generic or function\n+   * arguments). Otherwise returns an empty SimplePath. */\n+  SimplePath as_simple_path () const;\n+\n+  // Creates a trait bound with a clone of this type path as its only element.\n+  TraitBound *to_trait_bound (bool in_parens) const override;\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+  size_t get_num_segments () const { return segments.size (); }\n+\n+  void iterate_segments (std::function<bool (TypePathSegment *)> cb)\n+  {\n+    for (auto it = segments.begin (); it != segments.end (); it++)\n+      {\n+\tif (!cb ((*it).get ()))\n+\t  return;\n+      }\n+  }\n+};\n+\n+struct QualifiedPathType\n+{\n+private:\n+  std::unique_ptr<Type> type_to_invoke_on;\n+\n+  // bool has_as_clause;\n+  TypePath trait_path;\n+\n+  Location locus;\n+\n+public:\n+  // Constructor\n+  QualifiedPathType (std::unique_ptr<Type> invoke_on_type,\n+\t\t     Location locus = Location (),\n+\t\t     TypePath trait_path = TypePath::create_error ())\n+    : type_to_invoke_on (std::move (invoke_on_type)),\n+      trait_path (std::move (trait_path)), locus (locus)\n+  {}\n+\n+  // Copy constructor uses custom deep copy for Type to preserve polymorphism\n+  QualifiedPathType (QualifiedPathType const &other)\n+    : type_to_invoke_on (other.type_to_invoke_on->clone_type ()),\n+      trait_path (other.trait_path), locus (other.locus)\n+  {}\n+\n+  // default destructor\n+  ~QualifiedPathType () = default;\n+\n+  // overload assignment operator to use custom clone method\n+  QualifiedPathType &operator= (QualifiedPathType const &other)\n+  {\n+    type_to_invoke_on = other.type_to_invoke_on->clone_type ();\n+    trait_path = other.trait_path;\n+    locus = other.locus;\n+    return *this;\n+  }\n+\n+  // move constructor\n+  QualifiedPathType (QualifiedPathType &&other) = default;\n+  QualifiedPathType &operator= (QualifiedPathType &&other) = default;\n+\n+  // Returns whether the qualified path type has a rebind as clause.\n+  bool has_as_clause () const { return !trait_path.is_error (); }\n+\n+  // Returns whether the qualified path type is in an error state.\n+  bool is_error () const { return type_to_invoke_on == nullptr; }\n+\n+  // Creates an error state qualified path type.\n+  static QualifiedPathType create_error ()\n+  {\n+    return QualifiedPathType (nullptr);\n+  }\n+\n+  std::string as_string () const;\n+\n+  Location get_locus () const { return locus; }\n+};\n+\n+/* HIR node representing a qualified path-in-expression pattern (path that\n+ * allows specifying trait functions) */\n+class QualifiedPathInExpression : public PathPattern, public PathExpr\n+{\n+  QualifiedPathType path_type;\n+  Location locus;\n+\n+public:\n+  std::string as_string () const override;\n+\n+  QualifiedPathInExpression (Analysis::NodeMapping mappings,\n+\t\t\t     QualifiedPathType qual_path_type,\n+\t\t\t     std::vector<PathExprSegment> path_segments,\n+\t\t\t     Location locus = Location (),\n+\t\t\t     std::vector<Attribute> outer_attrs\n+\t\t\t     = std::vector<Attribute> ())\n+    : PathPattern (std::move (path_segments)),\n+      PathExpr (std::move (mappings), std::move (outer_attrs)),\n+      path_type (std::move (qual_path_type)), locus (locus)\n+  {}\n+\n+  /* TODO: maybe make a shortcut constructor that has QualifiedPathType elements\n+   * as params */\n+\n+  // Returns whether qualified path in expression is in an error state.\n+  bool is_error () const { return path_type.is_error (); }\n+\n+  // Creates an error qualified path in expression.\n+  static QualifiedPathInExpression create_error ()\n+  {\n+    return QualifiedPathInExpression (Analysis::NodeMapping::get_error (),\n+\t\t\t\t      QualifiedPathType::create_error (),\n+\t\t\t\t      std::vector<PathExprSegment> ());\n+  }\n+\n+  Location get_locus () const { return locus; }\n+  Location get_locus_slow () const override { return get_locus (); }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  QualifiedPathInExpression *clone_pattern_impl () const override\n+  {\n+    return new QualifiedPathInExpression (*this);\n+  }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  QualifiedPathInExpression *clone_expr_without_block_impl () const override\n+  {\n+    return new QualifiedPathInExpression (*this);\n+  }\n+};\n+\n+/* Represents a qualified path in a type; used for disambiguating trait function\n+ * calls */\n+class QualifiedPathInType : public TypeNoBounds\n+{\n+  QualifiedPathType path_type;\n+  std::vector<std::unique_ptr<TypePathSegment> > segments;\n+  Location locus;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  QualifiedPathInType *clone_type_impl () const override\n+  {\n+    return new QualifiedPathInType (*this);\n+  }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  QualifiedPathInType *clone_type_no_bounds_impl () const override\n+  {\n+    return new QualifiedPathInType (*this);\n+  }\n+\n+public:\n+  QualifiedPathInType (\n+    QualifiedPathType qual_path_type,\n+    std::vector<std::unique_ptr<TypePathSegment> > path_segments,\n+    Location locus = Location ())\n+    : path_type (std::move (qual_path_type)),\n+      segments (std::move (path_segments)), locus (locus)\n+  {}\n+\n+  /* TODO: maybe make a shortcut constructor that has QualifiedPathType elements\n+   * as params */\n+\n+  // Copy constructor with vector clone\n+  QualifiedPathInType (QualifiedPathInType const &other)\n+    : path_type (other.path_type), locus (other.locus)\n+  {\n+    segments.reserve (other.segments.size ());\n+    for (const auto &e : other.segments)\n+      segments.push_back (e->clone_type_path_segment ());\n+  }\n+\n+  // Overloaded assignment operator with vector clone\n+  QualifiedPathInType &operator= (QualifiedPathInType const &other)\n+  {\n+    path_type = other.path_type;\n+    locus = other.locus;\n+\n+    segments.reserve (other.segments.size ());\n+    for (const auto &e : other.segments)\n+      segments.push_back (e->clone_type_path_segment ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  QualifiedPathInType (QualifiedPathInType &&other) = default;\n+  QualifiedPathInType &operator= (QualifiedPathInType &&other) = default;\n+\n+  // Returns whether qualified path in type is in an error state.\n+  bool is_error () const { return path_type.is_error (); }\n+\n+  // Creates an error state qualified path in type.\n+  static QualifiedPathInType create_error ()\n+  {\n+    return QualifiedPathInType (\n+      QualifiedPathType::create_error (),\n+      std::vector<std::unique_ptr<TypePathSegment> > ());\n+  }\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+};\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif"}, {"sha": "3ff13d27c3d0c76c47db0a45b49a937d955122b3", "filename": "gcc/rust/hir/tree/rust-hir-pattern.h", "status": "added", "additions": 1162, "deletions": 0, "changes": 1162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f2dd6de5bf2dc58a075aa0fe3c8ddf75eba8004/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f2dd6de5bf2dc58a075aa0fe3c8ddf75eba8004/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-pattern.h?ref=5f2dd6de5bf2dc58a075aa0fe3c8ddf75eba8004", "patch": "@@ -0,0 +1,1162 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_PATTERN_H\n+#define RUST_HIR_PATTERN_H\n+\n+#include \"rust-hir.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+// Literal pattern HIR node (comparing to a literal)\n+class LiteralPattern : public Pattern\n+{\n+  Literal lit;\n+  /* make literal have a type given by enum, etc. rustc uses an extended form of\n+   * its literal token implementation */\n+  // TODO: literal representation - use LiteralExpr? or another thing?\n+\n+  // Minus prefixed to literal (if integer or floating-point)\n+  bool has_minus;\n+  // Actually, this might be a good place to use a template.\n+\n+  Location locus;\n+\n+public:\n+  std::string as_string () const override;\n+\n+  // Constructor for a literal pattern\n+  LiteralPattern (Literal lit, Location locus, bool has_minus = false)\n+    : lit (std::move (lit)), has_minus (has_minus), locus (locus)\n+  {}\n+\n+  LiteralPattern (std::string val, Literal::LitType type, Location locus,\n+\t\t  bool has_minus = false)\n+    : lit (Literal (std::move (val), type)), has_minus (has_minus),\n+      locus (locus)\n+  {}\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  virtual LiteralPattern *clone_pattern_impl () const override\n+  {\n+    return new LiteralPattern (*this);\n+  }\n+};\n+\n+// Identifier pattern HIR node (bind value matched to a variable)\n+class IdentifierPattern : public Pattern\n+{\n+public:\n+  Identifier variable_ident;\n+  bool is_ref;\n+  bool is_mut;\n+\n+  // bool has_pattern;\n+  std::unique_ptr<Pattern> to_bind;\n+\n+  Location locus;\n+\n+  std::string as_string () const;\n+\n+  // Returns whether the IdentifierPattern has a pattern to bind.\n+  bool has_pattern_to_bind () const { return to_bind != nullptr; }\n+\n+  // Constructor\n+  IdentifierPattern (Identifier ident, Location locus, bool is_ref = false,\n+\t\t     bool is_mut = false,\n+\t\t     std::unique_ptr<Pattern> to_bind = nullptr)\n+    : variable_ident (std::move (ident)), is_ref (is_ref), is_mut (is_mut),\n+      to_bind (std::move (to_bind)), locus (locus)\n+  {}\n+\n+  // Copy constructor with clone\n+  IdentifierPattern (IdentifierPattern const &other)\n+    : variable_ident (other.variable_ident), is_ref (other.is_ref),\n+      is_mut (other.is_mut), locus (other.locus)\n+  {\n+    // fix to get prevent null pointer dereference\n+    if (other.to_bind != nullptr)\n+      to_bind = other.to_bind->clone_pattern ();\n+  }\n+\n+  // Overload assignment operator to use clone\n+  IdentifierPattern &operator= (IdentifierPattern const &other)\n+  {\n+    variable_ident = other.variable_ident;\n+    is_ref = other.is_ref;\n+    is_mut = other.is_mut;\n+    locus = other.locus;\n+\n+    // fix to get prevent null pointer dereference\n+    if (other.to_bind != nullptr)\n+      to_bind = other.to_bind->clone_pattern ();\n+\n+    return *this;\n+  }\n+\n+  // default move semantics\n+  IdentifierPattern (IdentifierPattern &&other) = default;\n+  IdentifierPattern &operator= (IdentifierPattern &&other) = default;\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  IdentifierPattern *clone_pattern_impl () const override\n+  {\n+    return new IdentifierPattern (*this);\n+  }\n+};\n+\n+// HIR node for using the '_' wildcard \"match any value\" pattern\n+class WildcardPattern : public Pattern\n+{\n+  Location locus;\n+\n+public:\n+  std::string as_string () const override { return std::string (1, '_'); }\n+\n+  WildcardPattern (Location locus) : locus (locus) {}\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  WildcardPattern *clone_pattern_impl () const override\n+  {\n+    return new WildcardPattern (*this);\n+  }\n+};\n+\n+// Base range pattern bound (lower or upper limit) - abstract\n+class RangePatternBound\n+{\n+public:\n+  virtual ~RangePatternBound () {}\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<RangePatternBound> clone_range_pattern_bound () const\n+  {\n+    return std::unique_ptr<RangePatternBound> (\n+      clone_range_pattern_bound_impl ());\n+  }\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (HIRVisitor &vis) = 0;\n+\n+protected:\n+  // pure virtual as RangePatternBound is abstract\n+  virtual RangePatternBound *clone_range_pattern_bound_impl () const = 0;\n+};\n+\n+// Literal-based pattern bound\n+class RangePatternBoundLiteral : public RangePatternBound\n+{\n+  Literal literal;\n+  /* Can only be a char, byte, int, or float literal - same impl here as\n+   * previously */\n+\n+  // Minus prefixed to literal (if integer or floating-point)\n+  bool has_minus;\n+\n+  Location locus;\n+\n+public:\n+  // Constructor\n+  RangePatternBoundLiteral (Literal literal, Location locus,\n+\t\t\t    bool has_minus = false)\n+    : literal (literal), has_minus (has_minus), locus (locus)\n+  {}\n+\n+  std::string as_string () const override;\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  RangePatternBoundLiteral *clone_range_pattern_bound_impl () const override\n+  {\n+    return new RangePatternBoundLiteral (*this);\n+  }\n+};\n+\n+// Path-based pattern bound\n+class RangePatternBoundPath : public RangePatternBound\n+{\n+  PathInExpression path;\n+\n+  /* TODO: should this be refactored so that PathInExpression is a subclass of\n+   * RangePatternBound? */\n+\n+public:\n+  RangePatternBoundPath (PathInExpression path) : path (std::move (path)) {}\n+\n+  std::string as_string () const override { return path.as_string (); }\n+\n+  Location get_locus () const { return path.get_locus (); }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  RangePatternBoundPath *clone_range_pattern_bound_impl () const override\n+  {\n+    return new RangePatternBoundPath (*this);\n+  }\n+};\n+\n+// Qualified path-based pattern bound\n+class RangePatternBoundQualPath : public RangePatternBound\n+{\n+  QualifiedPathInExpression path;\n+\n+  /* TODO: should this be refactored so that QualifiedPathInExpression is a\n+   * subclass of RangePatternBound? */\n+\n+public:\n+  RangePatternBoundQualPath (QualifiedPathInExpression path)\n+    : path (std::move (path))\n+  {}\n+\n+  std::string as_string () const override { return path.as_string (); }\n+\n+  Location get_locus () const { return path.get_locus (); }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  RangePatternBoundQualPath *clone_range_pattern_bound_impl () const override\n+  {\n+    return new RangePatternBoundQualPath (*this);\n+  }\n+};\n+\n+// HIR node for matching within a certain range (range pattern)\n+class RangePattern : public Pattern\n+{\n+  std::unique_ptr<RangePatternBound> lower;\n+  std::unique_ptr<RangePatternBound> upper;\n+\n+  bool has_ellipsis_syntax;\n+\n+  /* location only stored to avoid a dereference - lower pattern should give\n+   * correct location so maybe change in future */\n+  Location locus;\n+\n+public:\n+  std::string as_string () const override;\n+\n+  // Constructor\n+  RangePattern (std::unique_ptr<RangePatternBound> lower,\n+\t\tstd::unique_ptr<RangePatternBound> upper, Location locus,\n+\t\tbool has_ellipsis_syntax = false)\n+    : lower (std::move (lower)), upper (std::move (upper)),\n+      has_ellipsis_syntax (has_ellipsis_syntax), locus (locus)\n+  {}\n+\n+  // Copy constructor with clone\n+  RangePattern (RangePattern const &other)\n+    : lower (other.lower->clone_range_pattern_bound ()),\n+      upper (other.upper->clone_range_pattern_bound ()),\n+      has_ellipsis_syntax (other.has_ellipsis_syntax), locus (other.locus)\n+  {}\n+\n+  // Overloaded assignment operator to clone\n+  RangePattern &operator= (RangePattern const &other)\n+  {\n+    lower = other.lower->clone_range_pattern_bound ();\n+    upper = other.upper->clone_range_pattern_bound ();\n+    has_ellipsis_syntax = other.has_ellipsis_syntax;\n+    locus = other.locus;\n+\n+    return *this;\n+  }\n+\n+  // default move semantics\n+  RangePattern (RangePattern &&other) = default;\n+  RangePattern &operator= (RangePattern &&other) = default;\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  RangePattern *clone_pattern_impl () const override\n+  {\n+    return new RangePattern (*this);\n+  }\n+};\n+\n+// HIR node for pattern based on dereferencing the pointers given\n+class ReferencePattern : public Pattern\n+{\n+  bool has_two_amps;\n+  bool is_mut;\n+  std::unique_ptr<Pattern> pattern;\n+  Location locus;\n+\n+public:\n+  std::string as_string () const override;\n+\n+  ReferencePattern (std::unique_ptr<Pattern> pattern, bool is_mut_reference,\n+\t\t    bool ref_has_two_amps, Location locus)\n+    : has_two_amps (ref_has_two_amps), is_mut (is_mut_reference),\n+      pattern (std::move (pattern)), locus (locus)\n+  {}\n+\n+  // Copy constructor requires clone\n+  ReferencePattern (ReferencePattern const &other)\n+    : has_two_amps (other.has_two_amps), is_mut (other.is_mut),\n+      pattern (other.pattern->clone_pattern ()), locus (other.locus)\n+  {}\n+\n+  // Overload assignment operator to clone\n+  ReferencePattern &operator= (ReferencePattern const &other)\n+  {\n+    pattern = other.pattern->clone_pattern ();\n+    is_mut = other.is_mut;\n+    has_two_amps = other.has_two_amps;\n+    locus = other.locus;\n+\n+    return *this;\n+  }\n+\n+  // default move semantics\n+  ReferencePattern (ReferencePattern &&other) = default;\n+  ReferencePattern &operator= (ReferencePattern &&other) = default;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ReferencePattern *clone_pattern_impl () const override\n+  {\n+    return new ReferencePattern (*this);\n+  }\n+};\n+\n+// aka StructPatternEtCetera; potential element in struct pattern\n+struct StructPatternEtc\n+{\n+private:\n+  std::vector<Attribute> outer_attrs;\n+\n+  // should this store location data?\n+\n+public:\n+  StructPatternEtc (std::vector<Attribute> outer_attribs)\n+    : outer_attrs (std::move (outer_attribs))\n+  {}\n+\n+  // Creates an empty StructPatternEtc\n+  static StructPatternEtc create_empty ()\n+  {\n+    return StructPatternEtc (std::vector<Attribute> ());\n+  }\n+};\n+\n+// Base class for a single field in a struct pattern - abstract\n+class StructPatternField\n+{\n+  std::vector<Attribute> outer_attrs;\n+  Location locus;\n+\n+public:\n+  virtual ~StructPatternField () {}\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<StructPatternField> clone_struct_pattern_field () const\n+  {\n+    return std::unique_ptr<StructPatternField> (\n+      clone_struct_pattern_field_impl ());\n+  }\n+\n+  virtual std::string as_string () const;\n+\n+  Location get_locus () const { return locus; }\n+\n+  virtual void accept_vis (HIRVisitor &vis) = 0;\n+\n+protected:\n+  StructPatternField (std::vector<Attribute> outer_attribs, Location locus)\n+    : outer_attrs (std::move (outer_attribs)), locus (locus)\n+  {}\n+\n+  // Clone function implementation as pure virtual method\n+  virtual StructPatternField *clone_struct_pattern_field_impl () const = 0;\n+};\n+\n+// Tuple pattern single field in a struct pattern\n+class StructPatternFieldTuplePat : public StructPatternField\n+{\n+  TupleIndex index;\n+  std::unique_ptr<Pattern> tuple_pattern;\n+\n+public:\n+  StructPatternFieldTuplePat (TupleIndex index,\n+\t\t\t      std::unique_ptr<Pattern> tuple_pattern,\n+\t\t\t      std::vector<Attribute> outer_attribs,\n+\t\t\t      Location locus)\n+    : StructPatternField (std::move (outer_attribs), locus), index (index),\n+      tuple_pattern (std::move (tuple_pattern))\n+  {}\n+\n+  // Copy constructor requires clone\n+  StructPatternFieldTuplePat (StructPatternFieldTuplePat const &other)\n+    : StructPatternField (other), index (other.index),\n+      tuple_pattern (other.tuple_pattern->clone_pattern ())\n+  {}\n+\n+  // Overload assignment operator to perform clone\n+  StructPatternFieldTuplePat &\n+  operator= (StructPatternFieldTuplePat const &other)\n+  {\n+    StructPatternField::operator= (other);\n+    tuple_pattern = other.tuple_pattern->clone_pattern ();\n+    index = other.index;\n+    // outer_attrs = other.outer_attrs;\n+\n+    return *this;\n+  }\n+\n+  // default move semantics\n+  StructPatternFieldTuplePat (StructPatternFieldTuplePat &&other) = default;\n+  StructPatternFieldTuplePat &operator= (StructPatternFieldTuplePat &&other)\n+    = default;\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  StructPatternFieldTuplePat *clone_struct_pattern_field_impl () const override\n+  {\n+    return new StructPatternFieldTuplePat (*this);\n+  }\n+};\n+\n+// Identifier pattern single field in a struct pattern\n+class StructPatternFieldIdentPat : public StructPatternField\n+{\n+  Identifier ident;\n+  std::unique_ptr<Pattern> ident_pattern;\n+\n+public:\n+  StructPatternFieldIdentPat (Identifier ident,\n+\t\t\t      std::unique_ptr<Pattern> ident_pattern,\n+\t\t\t      std::vector<Attribute> outer_attrs,\n+\t\t\t      Location locus)\n+    : StructPatternField (std::move (outer_attrs), locus),\n+      ident (std::move (ident)), ident_pattern (std::move (ident_pattern))\n+  {}\n+\n+  // Copy constructor requires clone\n+  StructPatternFieldIdentPat (StructPatternFieldIdentPat const &other)\n+    : StructPatternField (other), ident (other.ident),\n+      ident_pattern (other.ident_pattern->clone_pattern ())\n+  {}\n+\n+  // Overload assignment operator to clone\n+  StructPatternFieldIdentPat &\n+  operator= (StructPatternFieldIdentPat const &other)\n+  {\n+    StructPatternField::operator= (other);\n+    ident = other.ident;\n+    ident_pattern = other.ident_pattern->clone_pattern ();\n+    // outer_attrs = other.outer_attrs;\n+\n+    return *this;\n+  }\n+\n+  // default move semantics\n+  StructPatternFieldIdentPat (StructPatternFieldIdentPat &&other) = default;\n+  StructPatternFieldIdentPat &operator= (StructPatternFieldIdentPat &&other)\n+    = default;\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  StructPatternFieldIdentPat *clone_struct_pattern_field_impl () const override\n+  {\n+    return new StructPatternFieldIdentPat (*this);\n+  }\n+};\n+\n+// Identifier only (with no pattern) single field in a struct pattern\n+class StructPatternFieldIdent : public StructPatternField\n+{\n+  bool has_ref;\n+  bool has_mut;\n+  Identifier ident;\n+\n+public:\n+  StructPatternFieldIdent (Identifier ident, bool is_ref, bool is_mut,\n+\t\t\t   std::vector<Attribute> outer_attrs, Location locus)\n+    : StructPatternField (std::move (outer_attrs), locus), has_ref (is_ref),\n+      has_mut (is_mut), ident (std::move (ident))\n+  {}\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  StructPatternFieldIdent *clone_struct_pattern_field_impl () const override\n+  {\n+    return new StructPatternFieldIdent (*this);\n+  }\n+};\n+\n+// Elements of a struct pattern\n+struct StructPatternElements\n+{\n+private:\n+  // bool has_struct_pattern_fields;\n+  std::vector<std::unique_ptr<StructPatternField> > fields;\n+\n+  bool has_struct_pattern_etc;\n+  StructPatternEtc etc;\n+\n+  // must have at least one of the two and maybe both\n+\n+  // should this store location data?\n+\n+public:\n+  // Returns whether there are any struct pattern fields\n+  bool has_struct_pattern_fields () const { return !fields.empty (); }\n+\n+  /* Returns whether the struct pattern elements is entirely empty (no fields,\n+   * no etc). */\n+  bool is_empty () const\n+  {\n+    return !has_struct_pattern_fields () && !has_struct_pattern_etc;\n+  }\n+\n+  // Constructor for StructPatternElements with both (potentially)\n+  StructPatternElements (\n+    std::vector<std::unique_ptr<StructPatternField> > fields,\n+    StructPatternEtc etc)\n+    : fields (std::move (fields)), has_struct_pattern_etc (true),\n+      etc (std::move (etc))\n+  {}\n+\n+  // Constructor for StructPatternElements with no StructPatternEtc\n+  StructPatternElements (\n+    std::vector<std::unique_ptr<StructPatternField> > fields)\n+    : fields (std::move (fields)), has_struct_pattern_etc (false),\n+      etc (StructPatternEtc::create_empty ())\n+  {}\n+\n+  // Copy constructor with vector clone\n+  StructPatternElements (StructPatternElements const &other)\n+    : has_struct_pattern_etc (other.has_struct_pattern_etc), etc (other.etc)\n+  {\n+    fields.reserve (other.fields.size ());\n+    for (const auto &e : other.fields)\n+      fields.push_back (e->clone_struct_pattern_field ());\n+  }\n+\n+  // Overloaded assignment operator with vector clone\n+  StructPatternElements &operator= (StructPatternElements const &other)\n+  {\n+    etc = other.etc;\n+    has_struct_pattern_etc = other.has_struct_pattern_etc;\n+\n+    fields.reserve (other.fields.size ());\n+    for (const auto &e : other.fields)\n+      fields.push_back (e->clone_struct_pattern_field ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  StructPatternElements (StructPatternElements &&other) = default;\n+  StructPatternElements &operator= (StructPatternElements &&other) = default;\n+\n+  // Creates an empty StructPatternElements\n+  static StructPatternElements create_empty ()\n+  {\n+    return StructPatternElements (\n+      std::vector<std::unique_ptr<StructPatternField> > ());\n+  }\n+\n+  std::string as_string () const;\n+};\n+\n+// Struct pattern HIR node representation\n+class StructPattern : public Pattern\n+{\n+  PathInExpression path;\n+\n+  // bool has_struct_pattern_elements;\n+  StructPatternElements elems;\n+\n+  // TODO: should this store location data? Accessor uses path location data.\n+\n+public:\n+  std::string as_string () const override;\n+\n+  // Constructs a struct pattern from specified StructPatternElements\n+  StructPattern (PathInExpression struct_path,\n+\t\t StructPatternElements elems\n+\t\t = StructPatternElements::create_empty ())\n+    : path (std::move (struct_path)), elems (std::move (elems))\n+  {}\n+\n+  /* TODO: constructor to construct via elements included in\n+   * StructPatternElements */\n+\n+  /* Returns whether struct pattern has any struct pattern elements (if not, it\n+   * is empty). */\n+  bool has_struct_pattern_elems () const { return !elems.is_empty (); }\n+\n+  Location get_locus () const { return path.get_locus (); }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  StructPattern *clone_pattern_impl () const override\n+  {\n+    return new StructPattern (*this);\n+  }\n+};\n+\n+// Base abstract class for patterns used in TupleStructPattern\n+class TupleStructItems\n+{\n+public:\n+  virtual ~TupleStructItems () {}\n+\n+  // TODO: should this store location data?\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<TupleStructItems> clone_tuple_struct_items () const\n+  {\n+    return std::unique_ptr<TupleStructItems> (clone_tuple_struct_items_impl ());\n+  }\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (HIRVisitor &vis) = 0;\n+\n+protected:\n+  // pure virtual clone implementation\n+  virtual TupleStructItems *clone_tuple_struct_items_impl () const = 0;\n+};\n+\n+// Class for non-ranged tuple struct pattern patterns\n+class TupleStructItemsNoRange : public TupleStructItems\n+{\n+  std::vector<std::unique_ptr<Pattern> > patterns;\n+\n+public:\n+  TupleStructItemsNoRange (std::vector<std::unique_ptr<Pattern> > patterns)\n+    : patterns (std::move (patterns))\n+  {}\n+\n+  // Copy constructor with vector clone\n+  TupleStructItemsNoRange (TupleStructItemsNoRange const &other)\n+  {\n+    patterns.reserve (other.patterns.size ());\n+    for (const auto &e : other.patterns)\n+      patterns.push_back (e->clone_pattern ());\n+  }\n+\n+  // Overloaded assignment operator with vector clone\n+  TupleStructItemsNoRange &operator= (TupleStructItemsNoRange const &other)\n+  {\n+    patterns.reserve (other.patterns.size ());\n+    for (const auto &e : other.patterns)\n+      patterns.push_back (e->clone_pattern ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  TupleStructItemsNoRange (TupleStructItemsNoRange &&other) = default;\n+  TupleStructItemsNoRange &operator= (TupleStructItemsNoRange &&other)\n+    = default;\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TupleStructItemsNoRange *clone_tuple_struct_items_impl () const override\n+  {\n+    return new TupleStructItemsNoRange (*this);\n+  }\n+};\n+\n+// Class for ranged tuple struct pattern patterns\n+class TupleStructItemsRange : public TupleStructItems\n+{\n+  std::vector<std::unique_ptr<Pattern> > lower_patterns;\n+  std::vector<std::unique_ptr<Pattern> > upper_patterns;\n+\n+public:\n+  TupleStructItemsRange (std::vector<std::unique_ptr<Pattern> > lower_patterns,\n+\t\t\t std::vector<std::unique_ptr<Pattern> > upper_patterns)\n+    : lower_patterns (std::move (lower_patterns)),\n+      upper_patterns (std::move (upper_patterns))\n+  {}\n+\n+  // Copy constructor with vector clone\n+  TupleStructItemsRange (TupleStructItemsRange const &other)\n+  {\n+    lower_patterns.reserve (other.lower_patterns.size ());\n+    for (const auto &e : other.lower_patterns)\n+      lower_patterns.push_back (e->clone_pattern ());\n+\n+    upper_patterns.reserve (other.upper_patterns.size ());\n+    for (const auto &e : other.upper_patterns)\n+      upper_patterns.push_back (e->clone_pattern ());\n+  }\n+\n+  // Overloaded assignment operator to clone\n+  TupleStructItemsRange &operator= (TupleStructItemsRange const &other)\n+  {\n+    lower_patterns.reserve (other.lower_patterns.size ());\n+    for (const auto &e : other.lower_patterns)\n+      lower_patterns.push_back (e->clone_pattern ());\n+\n+    upper_patterns.reserve (other.upper_patterns.size ());\n+    for (const auto &e : other.upper_patterns)\n+      upper_patterns.push_back (e->clone_pattern ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  TupleStructItemsRange (TupleStructItemsRange &&other) = default;\n+  TupleStructItemsRange &operator= (TupleStructItemsRange &&other) = default;\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TupleStructItemsRange *clone_tuple_struct_items_impl () const override\n+  {\n+    return new TupleStructItemsRange (*this);\n+  }\n+};\n+\n+// HIR node representing a tuple struct pattern\n+class TupleStructPattern : public Pattern\n+{\n+  PathInExpression path;\n+  std::unique_ptr<TupleStructItems> items;\n+\n+  /* TOOD: should this store location data? current accessor uses path location\n+   * data */\n+\n+public:\n+  std::string as_string () const override;\n+\n+  TupleStructPattern (PathInExpression tuple_struct_path,\n+\t\t      std::unique_ptr<TupleStructItems> items)\n+    : path (std::move (tuple_struct_path)), items (std::move (items))\n+  {}\n+\n+  // Copy constructor required to clone\n+  TupleStructPattern (TupleStructPattern const &other)\n+    : path (other.path), items (other.items->clone_tuple_struct_items ())\n+  {}\n+\n+  // Operator overload assignment operator to clone\n+  TupleStructPattern &operator= (TupleStructPattern const &other)\n+  {\n+    path = other.path;\n+    items = other.items->clone_tuple_struct_items ();\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  TupleStructPattern (TupleStructPattern &&other) = default;\n+  TupleStructPattern &operator= (TupleStructPattern &&other) = default;\n+\n+  Location get_locus () const { return path.get_locus (); }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TupleStructPattern *clone_pattern_impl () const override\n+  {\n+    return new TupleStructPattern (*this);\n+  }\n+};\n+\n+// Base abstract class representing TuplePattern patterns\n+class TuplePatternItems\n+{\n+public:\n+  virtual ~TuplePatternItems () {}\n+\n+  // TODO: should this store location data?\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<TuplePatternItems> clone_tuple_pattern_items () const\n+  {\n+    return std::unique_ptr<TuplePatternItems> (\n+      clone_tuple_pattern_items_impl ());\n+  }\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (HIRVisitor &vis) = 0;\n+\n+protected:\n+  // pure virtual clone implementation\n+  virtual TuplePatternItems *clone_tuple_pattern_items_impl () const = 0;\n+};\n+\n+// Class representing TuplePattern patterns where there is only a single pattern\n+/*class TuplePatternItemsSingle : public TuplePatternItems {\n+    // Pattern pattern;\n+    std::unique_ptr<Pattern> pattern;\n+\n+  public:\n+    TuplePatternItemsSingle(Pattern* pattern) : pattern(pattern) {}\n+\n+    // Copy constructor uses clone\n+    TuplePatternItemsSingle(TuplePatternItemsSingle const& other) :\n+      pattern(other.pattern->clone_pattern()) {}\n+\n+    // Destructor - define here if required\n+\n+    // Overload assignment operator to clone\n+    TuplePatternItemsSingle& operator=(TuplePatternItemsSingle const& other) {\n+\tpattern = other.pattern->clone_pattern();\n+\n+\treturn *this;\n+    }\n+\n+    // move constructors\n+    TuplePatternItemsSingle(TuplePatternItemsSingle&& other) = default;\n+    TuplePatternItemsSingle& operator=(TuplePatternItemsSingle&& other) =\n+default;\n+\n+  protected:\n+    // Use covariance to implement clone function as returning this object\n+rather than base virtual TuplePatternItemsSingle*\n+clone_tuple_pattern_items_impl() const override { return new\n+TuplePatternItemsSingle(*this);\n+    }\n+};*/\n+// removed in favour of single-element TuplePatternItemsMultiple\n+\n+// Class representing TuplePattern patterns where there are multiple patterns\n+class TuplePatternItemsMultiple : public TuplePatternItems\n+{\n+  std::vector<std::unique_ptr<Pattern> > patterns;\n+\n+public:\n+  TuplePatternItemsMultiple (std::vector<std::unique_ptr<Pattern> > patterns)\n+    : patterns (std::move (patterns))\n+  {}\n+\n+  // Copy constructor with vector clone\n+  TuplePatternItemsMultiple (TuplePatternItemsMultiple const &other)\n+  {\n+    patterns.reserve (other.patterns.size ());\n+    for (const auto &e : other.patterns)\n+      patterns.push_back (e->clone_pattern ());\n+  }\n+\n+  // Overloaded assignment operator to vector clone\n+  TuplePatternItemsMultiple &operator= (TuplePatternItemsMultiple const &other)\n+  {\n+    patterns.reserve (other.patterns.size ());\n+    for (const auto &e : other.patterns)\n+      patterns.push_back (e->clone_pattern ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  TuplePatternItemsMultiple (TuplePatternItemsMultiple &&other) = default;\n+  TuplePatternItemsMultiple &operator= (TuplePatternItemsMultiple &&other)\n+    = default;\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TuplePatternItemsMultiple *clone_tuple_pattern_items_impl () const override\n+  {\n+    return new TuplePatternItemsMultiple (*this);\n+  }\n+};\n+\n+// Class representing TuplePattern patterns where there are a range of patterns\n+class TuplePatternItemsRanged : public TuplePatternItems\n+{\n+  std::vector<std::unique_ptr<Pattern> > lower_patterns;\n+  std::vector<std::unique_ptr<Pattern> > upper_patterns;\n+\n+public:\n+  TuplePatternItemsRanged (\n+    std::vector<std::unique_ptr<Pattern> > lower_patterns,\n+    std::vector<std::unique_ptr<Pattern> > upper_patterns)\n+    : lower_patterns (std::move (lower_patterns)),\n+      upper_patterns (std::move (upper_patterns))\n+  {}\n+\n+  // Copy constructor with vector clone\n+  TuplePatternItemsRanged (TuplePatternItemsRanged const &other)\n+  {\n+    lower_patterns.reserve (other.lower_patterns.size ());\n+    for (const auto &e : other.lower_patterns)\n+      lower_patterns.push_back (e->clone_pattern ());\n+\n+    upper_patterns.reserve (other.upper_patterns.size ());\n+    for (const auto &e : other.upper_patterns)\n+      upper_patterns.push_back (e->clone_pattern ());\n+  }\n+\n+  // Overloaded assignment operator to clone\n+  TuplePatternItemsRanged &operator= (TuplePatternItemsRanged const &other)\n+  {\n+    lower_patterns.reserve (other.lower_patterns.size ());\n+    for (const auto &e : other.lower_patterns)\n+      lower_patterns.push_back (e->clone_pattern ());\n+\n+    upper_patterns.reserve (other.upper_patterns.size ());\n+    for (const auto &e : other.upper_patterns)\n+      upper_patterns.push_back (e->clone_pattern ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  TuplePatternItemsRanged (TuplePatternItemsRanged &&other) = default;\n+  TuplePatternItemsRanged &operator= (TuplePatternItemsRanged &&other)\n+    = default;\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TuplePatternItemsRanged *clone_tuple_pattern_items_impl () const override\n+  {\n+    return new TuplePatternItemsRanged (*this);\n+  }\n+};\n+\n+// HIR node representing a tuple pattern\n+class TuplePattern : public Pattern\n+{\n+  // bool has_tuple_pattern_items;\n+  std::unique_ptr<TuplePatternItems> items;\n+\n+  Location locus;\n+\n+public:\n+  std::string as_string () const override;\n+\n+  // Returns true if the tuple pattern has items\n+  bool has_tuple_pattern_items () const { return items != nullptr; }\n+\n+  TuplePattern (std::unique_ptr<TuplePatternItems> items, Location locus)\n+    : items (std::move (items)), locus (locus)\n+  {}\n+\n+  // Copy constructor requires clone\n+  TuplePattern (TuplePattern const &other)\n+    : items (other.items->clone_tuple_pattern_items ()), locus (other.locus)\n+  {}\n+\n+  // Overload assignment operator to clone\n+  TuplePattern &operator= (TuplePattern const &other)\n+  {\n+    items = other.items->clone_tuple_pattern_items ();\n+    locus = other.locus;\n+\n+    return *this;\n+  }\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TuplePattern *clone_pattern_impl () const override\n+  {\n+    return new TuplePattern (*this);\n+  }\n+};\n+\n+// HIR node representing a pattern in parentheses, used to control precedence\n+class GroupedPattern : public Pattern\n+{\n+  std::unique_ptr<Pattern> pattern_in_parens;\n+  Location locus;\n+\n+public:\n+  std::string as_string () const override\n+  {\n+    return \"(\" + pattern_in_parens->as_string () + \")\";\n+  }\n+\n+  GroupedPattern (std::unique_ptr<Pattern> pattern_in_parens, Location locus)\n+    : pattern_in_parens (std::move (pattern_in_parens)), locus (locus)\n+  {}\n+\n+  // Copy constructor uses clone\n+  GroupedPattern (GroupedPattern const &other)\n+    : pattern_in_parens (other.pattern_in_parens->clone_pattern ()),\n+      locus (other.locus)\n+  {}\n+\n+  // Overload assignment operator to clone\n+  GroupedPattern &operator= (GroupedPattern const &other)\n+  {\n+    pattern_in_parens = other.pattern_in_parens->clone_pattern ();\n+    locus = other.locus;\n+\n+    return *this;\n+  }\n+\n+  // default move semantics\n+  GroupedPattern (GroupedPattern &&other) = default;\n+  GroupedPattern &operator= (GroupedPattern &&other) = default;\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  GroupedPattern *clone_pattern_impl () const override\n+  {\n+    return new GroupedPattern (*this);\n+  }\n+};\n+\n+// HIR node representing patterns that can match slices and arrays\n+class SlicePattern : public Pattern\n+{\n+  std::vector<std::unique_ptr<Pattern> > items;\n+  Location locus;\n+\n+public:\n+  std::string as_string () const override;\n+\n+  SlicePattern (std::vector<std::unique_ptr<Pattern> > items, Location locus)\n+    : items (std::move (items)), locus (locus)\n+  {}\n+\n+  // Copy constructor with vector clone\n+  SlicePattern (SlicePattern const &other) : locus (other.locus)\n+  {\n+    items.reserve (other.items.size ());\n+    for (const auto &e : other.items)\n+      items.push_back (e->clone_pattern ());\n+  }\n+\n+  // Overloaded assignment operator to vector clone\n+  SlicePattern &operator= (SlicePattern const &other)\n+  {\n+    locus = other.locus;\n+\n+    items.reserve (other.items.size ());\n+    for (const auto &e : other.items)\n+      items.push_back (e->clone_pattern ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  SlicePattern (SlicePattern &&other) = default;\n+  SlicePattern &operator= (SlicePattern &&other) = default;\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  SlicePattern *clone_pattern_impl () const override\n+  {\n+    return new SlicePattern (*this);\n+  }\n+};\n+\n+// Moved definition to rust-path.h\n+class PathPattern;\n+\n+// Forward decls for paths (defined in rust-path.h)\n+class PathInExpression;\n+class QualifiedPathInExpression;\n+\n+// Replaced with forward decl - defined in rust-macro.h\n+class MacroInvocation;\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif"}, {"sha": "61d9dcb010a2d8e25ee54eece4b31db86d8f5fb4", "filename": "gcc/rust/hir/tree/rust-hir-stmt.h", "status": "added", "additions": 232, "deletions": 0, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f2dd6de5bf2dc58a075aa0fe3c8ddf75eba8004/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f2dd6de5bf2dc58a075aa0fe3c8ddf75eba8004/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-stmt.h?ref=5f2dd6de5bf2dc58a075aa0fe3c8ddf75eba8004", "patch": "@@ -0,0 +1,232 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_STATEMENT_H\n+#define RUST_HIR_STATEMENT_H\n+\n+#include \"rust-hir.h\"\n+#include \"rust-hir-path.h\"\n+#include \"rust-hir-expr.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+// Just a semi-colon, which apparently is a statement.\n+class EmptyStmt : public Stmt\n+{\n+  Location locus;\n+\n+public:\n+  std::string as_string () const override { return std::string (1, ';'); }\n+\n+  EmptyStmt (Analysis::NodeMapping mappings, Location locus)\n+    : Stmt (std::move (mappings)), locus (locus)\n+  {}\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  EmptyStmt *clone_stmt_impl () const override { return new EmptyStmt (*this); }\n+};\n+\n+/* Variable assignment let statement - type of \"declaration statement\" as it\n+ * introduces new name into scope */\n+class LetStmt : public Stmt\n+{\n+  // bool has_outer_attrs;\n+  std::vector<Attribute> outer_attrs;\n+\n+  std::unique_ptr<Pattern> variables_pattern;\n+\n+  // bool has_type;\n+  std::unique_ptr<Type> type;\n+\n+  // bool has_init_expr;\n+  std::unique_ptr<Expr> init_expr;\n+\n+  Location locus;\n+\n+public:\n+  // Returns whether let statement has outer attributes.\n+  bool has_outer_attrs () const { return !outer_attrs.empty (); }\n+\n+  // Returns whether let statement has a given return type.\n+  bool has_type () const { return type != nullptr; }\n+\n+  // Returns whether let statement has an initialisation expression.\n+  bool has_init_expr () const { return init_expr != nullptr; }\n+\n+  std::string as_string () const override;\n+\n+  LetStmt (Analysis::NodeMapping mappings,\n+\t   std::unique_ptr<Pattern> variables_pattern,\n+\t   std::unique_ptr<Expr> init_expr, std::unique_ptr<Type> type,\n+\t   std::vector<Attribute> outer_attrs, Location locus)\n+    : Stmt (std::move (mappings)), outer_attrs (std::move (outer_attrs)),\n+      variables_pattern (std::move (variables_pattern)),\n+      type (std::move (type)), init_expr (std::move (init_expr)), locus (locus)\n+  {}\n+\n+  // Copy constructor with clone\n+  LetStmt (LetStmt const &other)\n+    : Stmt (other.mappings), outer_attrs (other.outer_attrs),\n+      variables_pattern (other.variables_pattern->clone_pattern ()),\n+      type (other.type->clone_type ()),\n+      init_expr (other.init_expr->clone_expr ()), locus (other.locus)\n+  {}\n+\n+  // Overloaded assignment operator to clone\n+  LetStmt &operator= (LetStmt const &other)\n+  {\n+    variables_pattern = other.variables_pattern->clone_pattern ();\n+    init_expr = other.init_expr->clone_expr ();\n+    type = other.type->clone_type ();\n+    outer_attrs = other.outer_attrs;\n+    locus = other.locus;\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  LetStmt (LetStmt &&other) = default;\n+  LetStmt &operator= (LetStmt &&other) = default;\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  LetStmt *clone_stmt_impl () const override { return new LetStmt (*this); }\n+};\n+\n+/* Abstract base class for expression statements (statements containing an\n+ * expression) */\n+class ExprStmt : public Stmt\n+{\n+  // TODO: add any useful virtual functions\n+\n+  Location locus;\n+\n+public:\n+  Location get_locus () const { return locus; }\n+\n+protected:\n+  ExprStmt (Analysis::NodeMapping mappings, Location locus)\n+    : Stmt (std::move (mappings)), locus (locus)\n+  {}\n+};\n+\n+/* Statement containing an expression without a block (or, due to technical\n+ * difficulties, can only be guaranteed to hold an expression). */\n+class ExprStmtWithoutBlock : public ExprStmt\n+{\n+  std::unique_ptr<Expr> expr;\n+\n+public:\n+  std::string as_string () const override;\n+\n+  ExprStmtWithoutBlock (Analysis::NodeMapping mappings,\n+\t\t\tstd::unique_ptr<Expr> expr, Location locus)\n+    : ExprStmt (std::move (mappings), locus), expr (std::move (expr))\n+  {}\n+\n+  // Copy constructor with clone\n+  ExprStmtWithoutBlock (ExprStmtWithoutBlock const &other)\n+    : ExprStmt (other), expr (other.expr->clone_expr ())\n+  {}\n+\n+  // Overloaded assignment operator to clone\n+  ExprStmtWithoutBlock &operator= (ExprStmtWithoutBlock const &other)\n+  {\n+    ExprStmt::operator= (other);\n+    expr = other.expr->clone_expr ();\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  ExprStmtWithoutBlock (ExprStmtWithoutBlock &&other) = default;\n+  ExprStmtWithoutBlock &operator= (ExprStmtWithoutBlock &&other) = default;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ExprStmtWithoutBlock *clone_stmt_impl () const override\n+  {\n+    return new ExprStmtWithoutBlock (*this);\n+  }\n+};\n+\n+// Statement containing an expression with a block\n+class ExprStmtWithBlock : public ExprStmt\n+{\n+public:\n+  std::unique_ptr<ExprWithBlock> expr;\n+\n+  std::string as_string () const override;\n+\n+  std::vector<LetStmt *> locals;\n+\n+  ExprStmtWithBlock (Analysis::NodeMapping mappings,\n+\t\t     std::unique_ptr<ExprWithBlock> expr, Location locus)\n+    : ExprStmt (std::move (mappings), locus), expr (std::move (expr))\n+  {}\n+\n+  // Copy constructor with clone\n+  ExprStmtWithBlock (ExprStmtWithBlock const &other)\n+    : ExprStmt (other), expr (other.expr->clone_expr_with_block ())\n+  {}\n+\n+  // Overloaded assignment operator to clone\n+  ExprStmtWithBlock &operator= (ExprStmtWithBlock const &other)\n+  {\n+    ExprStmt::operator= (other);\n+    expr = other.expr->clone_expr_with_block ();\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  ExprStmtWithBlock (ExprStmtWithBlock &&other) = default;\n+  ExprStmtWithBlock &operator= (ExprStmtWithBlock &&other) = default;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ExprStmtWithBlock *clone_stmt_impl () const override\n+  {\n+    return new ExprStmtWithBlock (*this);\n+  }\n+};\n+\n+/* Replaced definition of MacroInvocationSemi with forward decl - defined in\n+ * rust-macro.h */\n+class MacroInvocationSemi;\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif"}, {"sha": "0a446bd8a1d776aeccc89051a30f3401cc0bd3c5", "filename": "gcc/rust/hir/tree/rust-hir-type.h", "status": "added", "additions": 864, "deletions": 0, "changes": 864, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f2dd6de5bf2dc58a075aa0fe3c8ddf75eba8004/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f2dd6de5bf2dc58a075aa0fe3c8ddf75eba8004/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-type.h?ref=5f2dd6de5bf2dc58a075aa0fe3c8ddf75eba8004", "patch": "@@ -0,0 +1,864 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_TYPE_H\n+#define RUST_HIR_TYPE_H\n+\n+#include \"rust-hir.h\"\n+#include \"rust-hir-path.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+// definitions moved to rust-ast.h\n+class TypeParamBound;\n+class Lifetime;\n+\n+// A trait bound\n+class TraitBound : public TypeParamBound\n+{\n+  bool in_parens;\n+  bool opening_question_mark;\n+\n+  // bool has_for_lifetimes;\n+  // LifetimeParams for_lifetimes;\n+  std::vector<LifetimeParam> for_lifetimes; // inlined LifetimeParams\n+\n+  TypePath type_path;\n+\n+  Location locus;\n+\n+public:\n+  // Returns whether trait bound has \"for\" lifetimes\n+  bool has_for_lifetimes () const { return !for_lifetimes.empty (); }\n+\n+  TraitBound (TypePath type_path, Location locus, bool in_parens = false,\n+\t      bool opening_question_mark = false,\n+\t      std::vector<LifetimeParam> for_lifetimes\n+\t      = std::vector<LifetimeParam> ())\n+    : in_parens (in_parens), opening_question_mark (opening_question_mark),\n+      for_lifetimes (std::move (for_lifetimes)),\n+      type_path (std::move (type_path)), locus (locus)\n+  {}\n+\n+  std::string as_string () const override;\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TraitBound *clone_type_param_bound_impl () const override\n+  {\n+    return new TraitBound (*this);\n+  }\n+};\n+\n+// definition moved to rust-ast.h\n+class TypeNoBounds;\n+\n+// An impl trait? Poor reference material here.\n+class ImplTraitType : public Type\n+{\n+  // TypeParamBounds type_param_bounds;\n+  // inlined form\n+  std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds;\n+\n+  Location locus;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ImplTraitType *clone_type_impl () const override\n+  {\n+    return new ImplTraitType (*this);\n+  }\n+\n+public:\n+  ImplTraitType (\n+    std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds,\n+    Location locus)\n+    : type_param_bounds (std::move (type_param_bounds)), locus (locus)\n+  {}\n+\n+  // copy constructor with vector clone\n+  ImplTraitType (ImplTraitType const &other) : locus (other.locus)\n+  {\n+    type_param_bounds.reserve (other.type_param_bounds.size ());\n+    for (const auto &e : other.type_param_bounds)\n+      type_param_bounds.push_back (e->clone_type_param_bound ());\n+  }\n+\n+  // overloaded assignment operator to clone\n+  ImplTraitType &operator= (ImplTraitType const &other)\n+  {\n+    locus = other.locus;\n+\n+    type_param_bounds.reserve (other.type_param_bounds.size ());\n+    for (const auto &e : other.type_param_bounds)\n+      type_param_bounds.push_back (e->clone_type_param_bound ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  ImplTraitType (ImplTraitType &&other) = default;\n+  ImplTraitType &operator= (ImplTraitType &&other) = default;\n+\n+  std::string as_string () const override;\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+};\n+\n+// An opaque value of another type that implements a set of traits\n+class TraitObjectType : public Type\n+{\n+  bool has_dyn;\n+  // TypeParamBounds type_param_bounds;\n+  std::vector<std::unique_ptr<TypeParamBound> >\n+    type_param_bounds; // inlined form\n+\n+  Location locus;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TraitObjectType *clone_type_impl () const override\n+  {\n+    return new TraitObjectType (*this);\n+  }\n+\n+public:\n+  TraitObjectType (\n+    std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds,\n+    Location locus, bool is_dyn_dispatch = false)\n+    : has_dyn (is_dyn_dispatch),\n+      type_param_bounds (std::move (type_param_bounds)), locus (locus)\n+  {}\n+\n+  // copy constructor with vector clone\n+  TraitObjectType (TraitObjectType const &other)\n+    : has_dyn (other.has_dyn), locus (other.locus)\n+  {\n+    type_param_bounds.reserve (other.type_param_bounds.size ());\n+    for (const auto &e : other.type_param_bounds)\n+      type_param_bounds.push_back (e->clone_type_param_bound ());\n+  }\n+\n+  // overloaded assignment operator to clone\n+  TraitObjectType &operator= (TraitObjectType const &other)\n+  {\n+    has_dyn = other.has_dyn;\n+    locus = other.locus;\n+    type_param_bounds.reserve (other.type_param_bounds.size ());\n+    for (const auto &e : other.type_param_bounds)\n+      type_param_bounds.push_back (e->clone_type_param_bound ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  TraitObjectType (TraitObjectType &&other) = default;\n+  TraitObjectType &operator= (TraitObjectType &&other) = default;\n+\n+  std::string as_string () const override;\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+};\n+\n+// A type with parentheses around it, used to avoid ambiguity.\n+class ParenthesisedType : public TypeNoBounds\n+{\n+  std::unique_ptr<Type> type_in_parens;\n+  Location locus;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ParenthesisedType *clone_type_impl () const override\n+  {\n+    return new ParenthesisedType (*this);\n+  }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ParenthesisedType *clone_type_no_bounds_impl () const override\n+  {\n+    return new ParenthesisedType (*this);\n+  }\n+\n+public:\n+  // Constructor uses Type pointer for polymorphism\n+  ParenthesisedType (std::unique_ptr<Type> type_inside_parens, Location locus)\n+    : type_in_parens (std::move (type_inside_parens)), locus (locus)\n+  {}\n+\n+  /* Copy constructor uses custom deep copy method for type to preserve\n+   * polymorphism */\n+  ParenthesisedType (ParenthesisedType const &other)\n+    : type_in_parens (other.type_in_parens->clone_type ()), locus (other.locus)\n+  {}\n+\n+  // overload assignment operator to use custom clone method\n+  ParenthesisedType &operator= (ParenthesisedType const &other)\n+  {\n+    type_in_parens = other.type_in_parens->clone_type ();\n+    locus = other.locus;\n+    return *this;\n+  }\n+\n+  // default move semantics\n+  ParenthesisedType (ParenthesisedType &&other) = default;\n+  ParenthesisedType &operator= (ParenthesisedType &&other) = default;\n+\n+  std::string as_string () const override\n+  {\n+    return \"(\" + type_in_parens->as_string () + \")\";\n+  }\n+\n+  // Creates a trait bound (clone of this one's trait bound) - HACK\n+  TraitBound *to_trait_bound (bool in_parens ATTRIBUTE_UNUSED) const override\n+  {\n+    /* NOTE: obviously it is unknown whether the internal type is a trait bound\n+     * due to polymorphism, so just let the internal type handle it. As\n+     * parenthesised type, it must be in parentheses. */\n+    return type_in_parens->to_trait_bound (true);\n+  }\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+};\n+\n+// Impl trait with a single bound? Poor reference material here.\n+class ImplTraitTypeOneBound : public TypeNoBounds\n+{\n+  TraitBound trait_bound;\n+\n+  Location locus;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ImplTraitTypeOneBound *clone_type_impl () const override\n+  {\n+    return new ImplTraitTypeOneBound (*this);\n+  }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ImplTraitTypeOneBound *clone_type_no_bounds_impl () const override\n+  {\n+    return new ImplTraitTypeOneBound (*this);\n+  }\n+\n+public:\n+  ImplTraitTypeOneBound (TraitBound trait_bound, Location locus)\n+    : trait_bound (std::move (trait_bound)), locus (locus)\n+  {}\n+\n+  std::string as_string () const override;\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+};\n+\n+/* A trait object with a single trait bound. The \"trait bound\" is really just\n+ * the trait. Basically like using an interface as a type in an OOP language. */\n+class TraitObjectTypeOneBound : public TypeNoBounds\n+{\n+  bool has_dyn;\n+  TraitBound trait_bound;\n+\n+  Location locus;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TraitObjectTypeOneBound *clone_type_impl () const override\n+  {\n+    return new TraitObjectTypeOneBound (*this);\n+  }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TraitObjectTypeOneBound *clone_type_no_bounds_impl () const override\n+  {\n+    return new TraitObjectTypeOneBound (*this);\n+  }\n+\n+public:\n+  TraitObjectTypeOneBound (TraitBound trait_bound, Location locus,\n+\t\t\t   bool is_dyn_dispatch = false)\n+    : has_dyn (is_dyn_dispatch), trait_bound (std::move (trait_bound)),\n+      locus (locus)\n+  {}\n+\n+  std::string as_string () const override;\n+\n+  // Creates a trait bound (clone of this one's trait bound) - HACK\n+  TraitBound *to_trait_bound (bool in_parens ATTRIBUTE_UNUSED) const override\n+  {\n+    /* NOTE: this assumes there is no dynamic dispatch specified- if there was,\n+     * this cloning would not be required as parsing is unambiguous. */\n+    return new HIR::TraitBound (trait_bound);\n+  }\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+};\n+\n+class TypePath; // definition moved to \"rust-path.h\"\n+\n+/* A type consisting of the \"product\" of others (the tuple's elements) in a\n+ * specific order */\n+class TupleType : public TypeNoBounds\n+{\n+  std::vector<std::unique_ptr<Type> > elems;\n+  Location locus;\n+\n+public:\n+  // Returns whether the tuple type is the unit type, i.e. has no elements.\n+  bool is_unit_type () const { return elems.empty (); }\n+\n+  TupleType (std::vector<std::unique_ptr<Type> > elems, Location locus)\n+    : elems (std::move (elems)), locus (locus)\n+  {}\n+\n+  // copy constructor with vector clone\n+  TupleType (TupleType const &other) : locus (other.locus)\n+  {\n+    elems.reserve (other.elems.size ());\n+    for (const auto &e : other.elems)\n+      elems.push_back (e->clone_type ());\n+  }\n+\n+  // overloaded assignment operator to clone\n+  TupleType &operator= (TupleType const &other)\n+  {\n+    locus = other.locus;\n+\n+    elems.reserve (other.elems.size ());\n+    for (const auto &e : other.elems)\n+      elems.push_back (e->clone_type ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  TupleType (TupleType &&other) = default;\n+  TupleType &operator= (TupleType &&other) = default;\n+\n+  std::string as_string () const override;\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TupleType *clone_type_impl () const override { return new TupleType (*this); }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TupleType *clone_type_no_bounds_impl () const override\n+  {\n+    return new TupleType (*this);\n+  }\n+};\n+\n+/* A type with no values, representing the result of computations that never\n+ * complete. Expressions of NeverType can be coerced into any other types.\n+ * Represented as \"!\". */\n+class NeverType : public TypeNoBounds\n+{\n+  Location locus;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  NeverType *clone_type_impl () const override { return new NeverType (*this); }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  NeverType *clone_type_no_bounds_impl () const override\n+  {\n+    return new NeverType (*this);\n+  }\n+\n+public:\n+  NeverType (Location locus) : locus (locus) {}\n+\n+  std::string as_string () const override { return \"! (never type)\"; }\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+};\n+\n+// A type consisting of a pointer without safety or liveness guarantees\n+class RawPointerType : public TypeNoBounds\n+{\n+public:\n+  enum PointerType\n+  {\n+    MUT,\n+    CONST\n+  };\n+\n+private:\n+  PointerType pointer_type;\n+  std::unique_ptr<TypeNoBounds> type;\n+  Location locus;\n+\n+public:\n+  // Returns whether the pointer is mutable or constant.\n+  PointerType get_pointer_type () const { return pointer_type; }\n+\n+  // Constructor requires pointer for polymorphism reasons\n+  RawPointerType (PointerType pointer_type,\n+\t\t  std::unique_ptr<TypeNoBounds> type_no_bounds, Location locus)\n+    : pointer_type (pointer_type), type (std::move (type_no_bounds)),\n+      locus (locus)\n+  {}\n+\n+  // Copy constructor calls custom polymorphic clone function\n+  RawPointerType (RawPointerType const &other)\n+    : pointer_type (other.pointer_type),\n+      type (other.type->clone_type_no_bounds ()), locus (other.locus)\n+  {}\n+\n+  // overload assignment operator to use custom clone method\n+  RawPointerType &operator= (RawPointerType const &other)\n+  {\n+    pointer_type = other.pointer_type;\n+    type = other.type->clone_type_no_bounds ();\n+    locus = other.locus;\n+    return *this;\n+  }\n+\n+  // default move semantics\n+  RawPointerType (RawPointerType &&other) = default;\n+  RawPointerType &operator= (RawPointerType &&other) = default;\n+\n+  std::string as_string () const override;\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  RawPointerType *clone_type_impl () const override\n+  {\n+    return new RawPointerType (*this);\n+  }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  RawPointerType *clone_type_no_bounds_impl () const override\n+  {\n+    return new RawPointerType (*this);\n+  }\n+};\n+\n+// A type pointing to memory owned by another value\n+class ReferenceType : public TypeNoBounds\n+{\n+  // bool has_lifetime; // TODO: handle in lifetime or something?\n+  Lifetime lifetime;\n+\n+  bool has_mut;\n+  std::unique_ptr<TypeNoBounds> type;\n+  Location locus;\n+\n+public:\n+  // Returns whether the reference is mutable or immutable.\n+  bool is_mut () const { return has_mut; }\n+\n+  // Returns whether the reference has a lifetime.\n+  bool has_lifetime () const { return !lifetime.is_error (); }\n+\n+  // Constructor\n+  ReferenceType (bool is_mut, std::unique_ptr<TypeNoBounds> type_no_bounds,\n+\t\t Location locus, Lifetime lifetime = Lifetime::error ())\n+    : lifetime (std::move (lifetime)), has_mut (is_mut),\n+      type (std::move (type_no_bounds)), locus (locus)\n+  {}\n+\n+  // Copy constructor with custom clone method\n+  ReferenceType (ReferenceType const &other)\n+    : lifetime (other.lifetime), has_mut (other.has_mut),\n+      type (other.type->clone_type_no_bounds ()), locus (other.locus)\n+  {}\n+\n+  // Operator overload assignment operator to custom clone the unique pointer\n+  ReferenceType &operator= (ReferenceType const &other)\n+  {\n+    lifetime = other.lifetime;\n+    has_mut = other.has_mut;\n+    type = other.type->clone_type_no_bounds ();\n+    locus = other.locus;\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  ReferenceType (ReferenceType &&other) = default;\n+  ReferenceType &operator= (ReferenceType &&other) = default;\n+\n+  std::string as_string () const override;\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ReferenceType *clone_type_impl () const override\n+  {\n+    return new ReferenceType (*this);\n+  }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ReferenceType *clone_type_no_bounds_impl () const override\n+  {\n+    return new ReferenceType (*this);\n+  }\n+};\n+\n+// A fixed-size sequence of elements of a specified type\n+class ArrayType : public TypeNoBounds\n+{\n+  std::unique_ptr<Type> elem_type;\n+  std::unique_ptr<Expr> size;\n+  Location locus;\n+\n+public:\n+  // Constructor requires pointers for polymorphism\n+  ArrayType (std::unique_ptr<Type> type, std::unique_ptr<Expr> array_size,\n+\t     Location locus)\n+    : elem_type (std::move (type)), size (std::move (array_size)), locus (locus)\n+  {}\n+\n+  // Copy constructor requires deep copies of both unique pointers\n+  ArrayType (ArrayType const &other)\n+    : elem_type (other.elem_type->clone_type ()),\n+      size (other.size->clone_expr ()), locus (other.locus)\n+  {}\n+\n+  // Overload assignment operator to deep copy pointers\n+  ArrayType &operator= (ArrayType const &other)\n+  {\n+    elem_type = other.elem_type->clone_type ();\n+    size = other.size->clone_expr ();\n+    locus = other.locus;\n+    return *this;\n+  }\n+\n+  // move constructors\n+  ArrayType (ArrayType &&other) = default;\n+  ArrayType &operator= (ArrayType &&other) = default;\n+\n+  std::string as_string () const override;\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+  Type *get_element_type () { return elem_type.get (); }\n+\n+  Expr *get_size_expr () { return size.get (); }\n+\n+  Location &get_locus () { return locus; }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ArrayType *clone_type_impl () const override { return new ArrayType (*this); }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ArrayType *clone_type_no_bounds_impl () const override\n+  {\n+    return new ArrayType (*this);\n+  }\n+};\n+\n+/* A dynamically-sized type representing a \"view\" into a sequence of elements of\n+ * a type */\n+class SliceType : public TypeNoBounds\n+{\n+  std::unique_ptr<Type> elem_type;\n+  Location locus;\n+\n+public:\n+  // Constructor requires pointer for polymorphism\n+  SliceType (std::unique_ptr<Type> type, Location locus)\n+    : elem_type (std::move (type)), locus (locus)\n+  {}\n+\n+  // Copy constructor requires deep copy of Type smart pointer\n+  SliceType (SliceType const &other)\n+    : elem_type (other.elem_type->clone_type ()), locus (other.locus)\n+  {}\n+\n+  // Overload assignment operator to deep copy\n+  SliceType &operator= (SliceType const &other)\n+  {\n+    elem_type = other.elem_type->clone_type ();\n+    locus = other.locus;\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  SliceType (SliceType &&other) = default;\n+  SliceType &operator= (SliceType &&other) = default;\n+\n+  std::string as_string () const override;\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  SliceType *clone_type_impl () const override { return new SliceType (*this); }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  SliceType *clone_type_no_bounds_impl () const override\n+  {\n+    return new SliceType (*this);\n+  }\n+};\n+\n+/* Type used in generic arguments to explicitly request type inference (wildcard\n+ * pattern) */\n+class InferredType : public TypeNoBounds\n+{\n+  Location locus;\n+\n+  // e.g. Vec<_> = whatever\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  InferredType *clone_type_impl () const override\n+  {\n+    return new InferredType (*this);\n+  }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  InferredType *clone_type_no_bounds_impl () const override\n+  {\n+    return new InferredType (*this);\n+  }\n+\n+public:\n+  InferredType (Location locus) : locus (locus) {}\n+\n+  std::string as_string () const override;\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+};\n+\n+class QualifiedPathInType; // definition moved to \"rust-path.h\"\n+\n+// A possibly named param used in a BaseFunctionType\n+struct MaybeNamedParam\n+{\n+public:\n+  enum ParamKind\n+  {\n+    UNNAMED,\n+    IDENTIFIER,\n+    WILDCARD\n+  };\n+\n+private:\n+  std::unique_ptr<Type> param_type;\n+\n+  ParamKind param_kind;\n+  Identifier name; // technically, can be an identifier or '_'\n+\n+  Location locus;\n+\n+public:\n+  MaybeNamedParam (Identifier name, ParamKind param_kind,\n+\t\t   std::unique_ptr<Type> param_type, Location locus)\n+    : param_type (std::move (param_type)), param_kind (param_kind),\n+      name (std::move (name)), locus (locus)\n+  {}\n+\n+  // Copy constructor with clone\n+  MaybeNamedParam (MaybeNamedParam const &other)\n+    : param_type (other.param_type->clone_type ()),\n+      param_kind (other.param_kind), name (other.name), locus (other.locus)\n+  {}\n+\n+  ~MaybeNamedParam () = default;\n+\n+  // Overloaded assignment operator with clone\n+  MaybeNamedParam &operator= (MaybeNamedParam const &other)\n+  {\n+    name = other.name;\n+    param_kind = other.param_kind;\n+    param_type = other.param_type->clone_type ();\n+    locus = other.locus;\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  MaybeNamedParam (MaybeNamedParam &&other) = default;\n+  MaybeNamedParam &operator= (MaybeNamedParam &&other) = default;\n+\n+  std::string as_string () const;\n+\n+  // Returns whether the param is in an error state.\n+  bool is_error () const { return param_type == nullptr; }\n+\n+  // Creates an error state param.\n+  static MaybeNamedParam create_error ()\n+  {\n+    return MaybeNamedParam (\"\", UNNAMED, nullptr, Location ());\n+  }\n+\n+  Location get_locus () const { return locus; }\n+};\n+\n+/* A function pointer type - can be created via coercion from function items and\n+ * non- capturing closures. */\n+class BareFunctionType : public TypeNoBounds\n+{\n+  // bool has_for_lifetimes;\n+  // ForLifetimes for_lifetimes;\n+  std::vector<LifetimeParam> for_lifetimes; // inlined version\n+\n+  FunctionQualifiers function_qualifiers;\n+  std::vector<MaybeNamedParam> params;\n+  bool is_variadic;\n+\n+  // bool has_return_type;\n+  // BareFunctionReturnType return_type;\n+  std::unique_ptr<TypeNoBounds> return_type; // inlined version\n+\n+  Location locus;\n+\n+public:\n+  // Whether a return type is defined with the function.\n+  bool has_return_type () const { return return_type != nullptr; }\n+\n+  // Whether the function has ForLifetimes.\n+  bool has_for_lifetimes () const { return !for_lifetimes.empty (); }\n+\n+  BareFunctionType (std::vector<LifetimeParam> lifetime_params,\n+\t\t    FunctionQualifiers qualifiers,\n+\t\t    std::vector<MaybeNamedParam> named_params, bool is_variadic,\n+\t\t    std::unique_ptr<TypeNoBounds> type, Location locus)\n+    : for_lifetimes (std::move (lifetime_params)),\n+      function_qualifiers (std::move (qualifiers)),\n+      params (std::move (named_params)), is_variadic (is_variadic),\n+      return_type (std::move (type)), locus (locus)\n+  {}\n+\n+  // Copy constructor with clone\n+  BareFunctionType (BareFunctionType const &other)\n+    : for_lifetimes (other.for_lifetimes),\n+      function_qualifiers (other.function_qualifiers), params (other.params),\n+      is_variadic (other.is_variadic),\n+      return_type (other.return_type->clone_type_no_bounds ()),\n+      locus (other.locus)\n+  {}\n+\n+  // Overload assignment operator to deep copy\n+  BareFunctionType &operator= (BareFunctionType const &other)\n+  {\n+    for_lifetimes = other.for_lifetimes;\n+    function_qualifiers = other.function_qualifiers;\n+    params = other.params;\n+    is_variadic = other.is_variadic;\n+    return_type = other.return_type->clone_type_no_bounds ();\n+    locus = other.locus;\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  BareFunctionType (BareFunctionType &&other) = default;\n+  BareFunctionType &operator= (BareFunctionType &&other) = default;\n+\n+  std::string as_string () const override;\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  BareFunctionType *clone_type_impl () const override\n+  {\n+    return new BareFunctionType (*this);\n+  }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  BareFunctionType *clone_type_no_bounds_impl () const override\n+  {\n+    return new BareFunctionType (*this);\n+  }\n+};\n+\n+// Forward decl - defined in rust-macro.h\n+class MacroInvocation;\n+\n+/* TODO: possible types\n+ * struct type?\n+ * \"enum\" (tagged union) type?\n+ * C-like union type?\n+ * function item type?\n+ * closure expression types?\n+ * primitive types (bool, int, float, char, str (the slice))\n+ * Although supposedly TypePaths are used to reference these types (including\n+ * primitives) */\n+\n+/* FIXME: Incomplete spec references:\n+ *  anonymous type parameters, aka \"impl Trait in argument position\" - impl then\n+ * trait bounds abstract return types, aka \"impl Trait in return position\" -\n+ * impl then trait bounds */\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif"}, {"sha": "abb84f595bcb21573468201187023c132ad388e6", "filename": "gcc/rust/hir/tree/rust-hir-visitor.h", "status": "added", "additions": 244, "deletions": 0, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f2dd6de5bf2dc58a075aa0fe3c8ddf75eba8004/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f2dd6de5bf2dc58a075aa0fe3c8ddf75eba8004/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-visitor.h?ref=5f2dd6de5bf2dc58a075aa0fe3c8ddf75eba8004", "patch": "@@ -0,0 +1,244 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_VISITOR_H\n+#define RUST_HIR_VISITOR_H\n+// Visitor base for HIR\n+\n+// full include not required - only forward decls\n+#include \"rust-hir-full-decls.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+/* Pure abstract class that provides an interface for accessing different\n+ * classes of the HIR. */\n+class HIRVisitor\n+{\n+public:\n+  // only concrete class overloads are required\n+\n+  // rust-ast.h\n+  // virtual void visit(AttrInput& attr_input) = 0;\n+  // virtual void visit(TokenTree& token_tree) = 0;\n+  // virtual void visit(MacroMatch& macro_match) = 0;\n+  virtual void visit (Token &tok) = 0;\n+  virtual void visit (DelimTokenTree &delim_tok_tree) = 0;\n+  virtual void visit (AttrInputMetaItemContainer &input) = 0;\n+  // virtual void visit(MetaItem& meta_item) = 0;\n+  // virtual void visit(Stmt& stmt) = 0;\n+  // virtual void visit(Expr& expr) = 0;\n+  virtual void visit (IdentifierExpr &ident_expr) = 0;\n+  // virtual void visit(Pattern& pattern) = 0;\n+  // virtual void visit(Type& type) = 0;\n+  // virtual void visit(TypeParamBound& type_param_bound) = 0;\n+  virtual void visit (Lifetime &lifetime) = 0;\n+  // virtual void visit(GenericParam& generic_param) = 0;\n+  virtual void visit (LifetimeParam &lifetime_param) = 0;\n+  // virtual void visit(TraitItem& trait_item) = 0;\n+  // virtual void visit(InherentImplItem& inherent_impl_item) = 0;\n+  // virtual void visit(TraitImplItem& trait_impl_item) = 0;\n+  virtual void visit (MacroInvocationSemi &macro) = 0;\n+\n+  // rust-path.h\n+  virtual void visit (PathInExpression &path) = 0;\n+  virtual void visit (TypePathSegment &segment) = 0;\n+  virtual void visit (TypePathSegmentGeneric &segment) = 0;\n+  virtual void visit (TypePathSegmentFunction &segment) = 0;\n+  virtual void visit (TypePath &path) = 0;\n+  virtual void visit (QualifiedPathInExpression &path) = 0;\n+  virtual void visit (QualifiedPathInType &path) = 0;\n+\n+  // rust-expr.h\n+  virtual void visit (LiteralExpr &expr) = 0;\n+  virtual void visit (AttrInputLiteral &attr_input) = 0;\n+  virtual void visit (MetaItemLitExpr &meta_item) = 0;\n+  virtual void visit (MetaItemPathLit &meta_item) = 0;\n+  virtual void visit (BorrowExpr &expr) = 0;\n+  virtual void visit (DereferenceExpr &expr) = 0;\n+  virtual void visit (ErrorPropagationExpr &expr) = 0;\n+  virtual void visit (NegationExpr &expr) = 0;\n+  virtual void visit (ArithmeticOrLogicalExpr &expr) = 0;\n+  virtual void visit (ComparisonExpr &expr) = 0;\n+  virtual void visit (LazyBooleanExpr &expr) = 0;\n+  virtual void visit (TypeCastExpr &expr) = 0;\n+  virtual void visit (AssignmentExpr &expr) = 0;\n+  virtual void visit (CompoundAssignmentExpr &expr) = 0;\n+  virtual void visit (GroupedExpr &expr) = 0;\n+  // virtual void visit(ArrayElems& elems) = 0;\n+  virtual void visit (ArrayElemsValues &elems) = 0;\n+  virtual void visit (ArrayElemsCopied &elems) = 0;\n+  virtual void visit (ArrayExpr &expr) = 0;\n+  virtual void visit (ArrayIndexExpr &expr) = 0;\n+  virtual void visit (TupleExpr &expr) = 0;\n+  virtual void visit (TupleIndexExpr &expr) = 0;\n+  virtual void visit (StructExprStruct &expr) = 0;\n+  // virtual void visit(StructExprField& field) = 0;\n+  virtual void visit (StructExprFieldIdentifier &field) = 0;\n+  virtual void visit (StructExprFieldIdentifierValue &field) = 0;\n+  virtual void visit (StructExprFieldIndexValue &field) = 0;\n+  virtual void visit (StructExprStructFields &expr) = 0;\n+  virtual void visit (StructExprStructBase &expr) = 0;\n+  virtual void visit (StructExprTuple &expr) = 0;\n+  virtual void visit (StructExprUnit &expr) = 0;\n+  // virtual void visit(EnumExprField& field) = 0;\n+  virtual void visit (EnumExprFieldIdentifier &field) = 0;\n+  virtual void visit (EnumExprFieldIdentifierValue &field) = 0;\n+  virtual void visit (EnumExprFieldIndexValue &field) = 0;\n+  virtual void visit (EnumExprStruct &expr) = 0;\n+  virtual void visit (EnumExprTuple &expr) = 0;\n+  virtual void visit (EnumExprFieldless &expr) = 0;\n+  virtual void visit (CallExpr &expr) = 0;\n+  virtual void visit (MethodCallExpr &expr) = 0;\n+  virtual void visit (FieldAccessExpr &expr) = 0;\n+  virtual void visit (ClosureExprInner &expr) = 0;\n+  virtual void visit (BlockExpr &expr) = 0;\n+  virtual void visit (ClosureExprInnerTyped &expr) = 0;\n+  virtual void visit (ContinueExpr &expr) = 0;\n+  virtual void visit (BreakExpr &expr) = 0;\n+  virtual void visit (RangeFromToExpr &expr) = 0;\n+  virtual void visit (RangeFromExpr &expr) = 0;\n+  virtual void visit (RangeToExpr &expr) = 0;\n+  virtual void visit (RangeFullExpr &expr) = 0;\n+  virtual void visit (RangeFromToInclExpr &expr) = 0;\n+  virtual void visit (RangeToInclExpr &expr) = 0;\n+  virtual void visit (ReturnExpr &expr) = 0;\n+  virtual void visit (UnsafeBlockExpr &expr) = 0;\n+  virtual void visit (LoopExpr &expr) = 0;\n+  virtual void visit (WhileLoopExpr &expr) = 0;\n+  virtual void visit (WhileLetLoopExpr &expr) = 0;\n+  virtual void visit (ForLoopExpr &expr) = 0;\n+  virtual void visit (IfExpr &expr) = 0;\n+  virtual void visit (IfExprConseqElse &expr) = 0;\n+  virtual void visit (IfExprConseqIf &expr) = 0;\n+  virtual void visit (IfExprConseqIfLet &expr) = 0;\n+  virtual void visit (IfLetExpr &expr) = 0;\n+  virtual void visit (IfLetExprConseqElse &expr) = 0;\n+  virtual void visit (IfLetExprConseqIf &expr) = 0;\n+  virtual void visit (IfLetExprConseqIfLet &expr) = 0;\n+  // virtual void visit(MatchCase& match_case) = 0;\n+  // virtual void visit (MatchCaseBlockExpr &match_case) = 0;\n+  // virtual void visit (MatchCaseExpr &match_case) = 0;\n+  virtual void visit (MatchExpr &expr) = 0;\n+  virtual void visit (AwaitExpr &expr) = 0;\n+  virtual void visit (AsyncBlockExpr &expr) = 0;\n+\n+  // rust-item.h\n+  virtual void visit (TypeParam &param) = 0;\n+  // virtual void visit(WhereClauseItem& item) = 0;\n+  virtual void visit (LifetimeWhereClauseItem &item) = 0;\n+  virtual void visit (TypeBoundWhereClauseItem &item) = 0;\n+  virtual void visit (Method &method) = 0;\n+  virtual void visit (ModuleBodied &module) = 0;\n+  virtual void visit (ModuleNoBody &module) = 0;\n+  virtual void visit (ExternCrate &crate) = 0;\n+  // virtual void visit(UseTree& use_tree) = 0;\n+  virtual void visit (UseTreeGlob &use_tree) = 0;\n+  virtual void visit (UseTreeList &use_tree) = 0;\n+  virtual void visit (UseTreeRebind &use_tree) = 0;\n+  virtual void visit (UseDeclaration &use_decl) = 0;\n+  virtual void visit (Function &function) = 0;\n+  virtual void visit (TypeAlias &type_alias) = 0;\n+  virtual void visit (StructStruct &struct_item) = 0;\n+  virtual void visit (TupleStruct &tuple_struct) = 0;\n+  virtual void visit (EnumItem &item) = 0;\n+  virtual void visit (EnumItemTuple &item) = 0;\n+  virtual void visit (EnumItemStruct &item) = 0;\n+  virtual void visit (EnumItemDiscriminant &item) = 0;\n+  virtual void visit (Enum &enum_item) = 0;\n+  virtual void visit (Union &union_item) = 0;\n+  virtual void visit (ConstantItem &const_item) = 0;\n+  virtual void visit (StaticItem &static_item) = 0;\n+  virtual void visit (TraitItemFunc &item) = 0;\n+  virtual void visit (TraitItemMethod &item) = 0;\n+  virtual void visit (TraitItemConst &item) = 0;\n+  virtual void visit (TraitItemType &item) = 0;\n+  virtual void visit (Trait &trait) = 0;\n+  virtual void visit (InherentImpl &impl) = 0;\n+  virtual void visit (TraitImpl &impl) = 0;\n+  // virtual void visit(ExternalItem& item) = 0;\n+  virtual void visit (ExternalStaticItem &item) = 0;\n+  virtual void visit (ExternalFunctionItem &item) = 0;\n+  virtual void visit (ExternBlock &block) = 0;\n+\n+  // rust-macro.h\n+  virtual void visit (MacroMatchFragment &match) = 0;\n+  virtual void visit (MacroMatchRepetition &match) = 0;\n+  virtual void visit (MacroMatcher &matcher) = 0;\n+  virtual void visit (MacroRulesDefinition &rules_def) = 0;\n+  virtual void visit (MacroInvocation &macro_invoc) = 0;\n+  virtual void visit (MetaItemPath &meta_item) = 0;\n+  virtual void visit (MetaItemSeq &meta_item) = 0;\n+  virtual void visit (MetaWord &meta_item) = 0;\n+  virtual void visit (MetaNameValueStr &meta_item) = 0;\n+  virtual void visit (MetaListPaths &meta_item) = 0;\n+  virtual void visit (MetaListNameValueStr &meta_item) = 0;\n+\n+  // rust-pattern.h\n+  virtual void visit (LiteralPattern &pattern) = 0;\n+  virtual void visit (IdentifierPattern &pattern) = 0;\n+  virtual void visit (WildcardPattern &pattern) = 0;\n+  // virtual void visit(RangePatternBound& bound) = 0;\n+  virtual void visit (RangePatternBoundLiteral &bound) = 0;\n+  virtual void visit (RangePatternBoundPath &bound) = 0;\n+  virtual void visit (RangePatternBoundQualPath &bound) = 0;\n+  virtual void visit (RangePattern &pattern) = 0;\n+  virtual void visit (ReferencePattern &pattern) = 0;\n+  // virtual void visit(StructPatternField& field) = 0;\n+  virtual void visit (StructPatternFieldTuplePat &field) = 0;\n+  virtual void visit (StructPatternFieldIdentPat &field) = 0;\n+  virtual void visit (StructPatternFieldIdent &field) = 0;\n+  virtual void visit (StructPattern &pattern) = 0;\n+  // virtual void visit(TupleStructItems& tuple_items) = 0;\n+  virtual void visit (TupleStructItemsNoRange &tuple_items) = 0;\n+  virtual void visit (TupleStructItemsRange &tuple_items) = 0;\n+  virtual void visit (TupleStructPattern &pattern) = 0;\n+  // virtual void visit(TuplePatternItems& tuple_items) = 0;\n+  virtual void visit (TuplePatternItemsMultiple &tuple_items) = 0;\n+  virtual void visit (TuplePatternItemsRanged &tuple_items) = 0;\n+  virtual void visit (TuplePattern &pattern) = 0;\n+  virtual void visit (GroupedPattern &pattern) = 0;\n+  virtual void visit (SlicePattern &pattern) = 0;\n+\n+  // rust-stmt.h\n+  virtual void visit (EmptyStmt &stmt) = 0;\n+  virtual void visit (LetStmt &stmt) = 0;\n+  virtual void visit (ExprStmtWithoutBlock &stmt) = 0;\n+  virtual void visit (ExprStmtWithBlock &stmt) = 0;\n+\n+  // rust-type.h\n+  virtual void visit (TraitBound &bound) = 0;\n+  virtual void visit (ImplTraitType &type) = 0;\n+  virtual void visit (TraitObjectType &type) = 0;\n+  virtual void visit (ParenthesisedType &type) = 0;\n+  virtual void visit (ImplTraitTypeOneBound &type) = 0;\n+  virtual void visit (TraitObjectTypeOneBound &type) = 0;\n+  virtual void visit (TupleType &type) = 0;\n+  virtual void visit (NeverType &type) = 0;\n+  virtual void visit (RawPointerType &type) = 0;\n+  virtual void visit (ReferenceType &type) = 0;\n+  virtual void visit (ArrayType &type) = 0;\n+  virtual void visit (SliceType &type) = 0;\n+  virtual void visit (InferredType &type) = 0;\n+  virtual void visit (BareFunctionType &type) = 0;\n+\n+  // TODO: rust-cond-compilation.h visiting? not currently used\n+};\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif"}, {"sha": "b7feb5983879151fc1be3b49035ebcd650110b9f", "filename": "gcc/rust/hir/tree/rust-hir.h", "status": "added", "additions": 1459, "deletions": 0, "changes": 1459, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f2dd6de5bf2dc58a075aa0fe3c8ddf75eba8004/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f2dd6de5bf2dc58a075aa0fe3c8ddf75eba8004/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h?ref=5f2dd6de5bf2dc58a075aa0fe3c8ddf75eba8004", "patch": "@@ -0,0 +1,1459 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_BASE_H\n+#define RUST_HIR_BASE_H\n+\n+#include \"rust-system.h\"\n+#include \"rust-token.h\"\n+#include \"rust-location.h\"\n+#include \"rust-hir-map.h\"\n+\n+namespace Rust {\n+typedef std::string Identifier;\n+typedef int TupleIndex;\n+\n+namespace HIR {\n+// foward decl: ast visitor\n+class HIRVisitor;\n+\n+// Delimiter types - used in macros and whatever.\n+enum DelimType\n+{\n+  PARENS,\n+  SQUARE,\n+  CURLY\n+};\n+\n+// Attribute body - abstract base class\n+class AttrInput\n+{\n+public:\n+  virtual ~AttrInput () {}\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<AttrInput> clone_attr_input () const\n+  {\n+    return std::unique_ptr<AttrInput> (clone_attr_input_impl ());\n+  }\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (HIRVisitor &vis) = 0;\n+\n+  // Parse attribute input to meta item, if possible\n+  virtual AttrInput *parse_to_meta_item () const { return nullptr; }\n+\n+protected:\n+  // pure virtual clone implementation\n+  virtual AttrInput *clone_attr_input_impl () const = 0;\n+};\n+\n+// forward decl for use in token tree method\n+class Token;\n+\n+// A tree of tokens (or a single token) - abstract base class\n+class TokenTree\n+{\n+public:\n+  virtual ~TokenTree () {}\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<TokenTree> clone_token_tree () const\n+  {\n+    return std::unique_ptr<TokenTree> (clone_token_tree_impl ());\n+  }\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (HIRVisitor &vis) = 0;\n+\n+  /* Converts token tree to a flat token stream. Tokens must be pointer to avoid\n+   * mutual dependency with Token. */\n+  virtual std::vector<std::unique_ptr<Token> > to_token_stream () const = 0;\n+\n+protected:\n+  // pure virtual clone implementation\n+  virtual TokenTree *clone_token_tree_impl () const = 0;\n+};\n+\n+// Abstract base class for a macro match\n+class MacroMatch\n+{\n+public:\n+  virtual ~MacroMatch () {}\n+\n+  virtual std::string as_string () const = 0;\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<MacroMatch> clone_macro_match () const\n+  {\n+    return std::unique_ptr<MacroMatch> (clone_macro_match_impl ());\n+  }\n+\n+  virtual void accept_vis (HIRVisitor &vis) = 0;\n+\n+protected:\n+  // pure virtual clone implementation\n+  virtual MacroMatch *clone_macro_match_impl () const = 0;\n+};\n+\n+// A token is a kind of token tree (except delimiter tokens)\n+class Token : public TokenTree, public MacroMatch\n+{\n+  // A token is a kind of token tree (except delimiter tokens)\n+  // A token is a kind of MacroMatch (except $ and delimiter tokens)\n+  // TODO: improve member variables - current ones are the same as lexer token\n+  // Token kind.\n+  TokenId token_id;\n+  // Token location.\n+  Location locus;\n+  // Associated text (if any) of token.\n+  std::string str;\n+  // Token type hint (if any).\n+  PrimitiveCoreType type_hint;\n+\n+public:\n+  // Unique pointer custom clone function\n+  std::unique_ptr<Token> clone_token () const\n+  {\n+    return std::unique_ptr<Token> (clone_token_impl ());\n+  }\n+\n+  /* constructor from general text - avoid using if lexer const_TokenPtr is\n+   * available */\n+  Token (TokenId token_id, Location locus, std::string str,\n+\t PrimitiveCoreType type_hint)\n+    : token_id (token_id), locus (locus), str (std::move (str)),\n+      type_hint (type_hint)\n+  {}\n+\n+  // Constructor from lexer const_TokenPtr\n+  /* TODO: find workaround for std::string being nullptr - probably have to\n+   * introduce new method in lexer Token, or maybe make conversion method\n+   * there */\n+  Token (const_TokenPtr lexer_token_ptr)\n+    : token_id (lexer_token_ptr->get_id ()),\n+      locus (lexer_token_ptr->get_locus ()), str (\"\"),\n+      type_hint (lexer_token_ptr->get_type_hint ())\n+  {\n+    // FIXME: change to \"should have str\" later?\n+    if (lexer_token_ptr->has_str ())\n+      {\n+\tstr = lexer_token_ptr->get_str ();\n+\n+\t// DEBUG\n+\tfprintf (stderr, \"ast token created with str '%s'\\n\", str.c_str ());\n+      }\n+    else\n+      {\n+\t// FIXME: is this returning correct thing?\n+\tstr = lexer_token_ptr->get_token_description ();\n+\n+\t// DEBUG\n+\tfprintf (stderr, \"ast token created with string '%s'\\n\", str.c_str ());\n+      }\n+\n+    // DEBUG\n+    if (lexer_token_ptr->should_have_str () && !lexer_token_ptr->has_str ())\n+      {\n+\tfprintf (stderr,\n+\t\t \"BAD: for token '%s', should have string but does not!\\n\",\n+\t\t lexer_token_ptr->get_token_description ());\n+      }\n+  }\n+\n+  bool is_string_lit () const\n+  {\n+    switch (token_id)\n+      {\n+      case STRING_LITERAL:\n+      case BYTE_STRING_LITERAL:\n+\treturn true;\n+      default:\n+\treturn false;\n+      }\n+  }\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+  // Return copy of itself but in token stream form.\n+  std::vector<std::unique_ptr<Token> > to_token_stream () const override;\n+\n+  TokenId get_id () const { return token_id; }\n+\n+  Location get_locus () const { return locus; }\n+\n+protected:\n+  // No virtual for now as not polymorphic but can be in future\n+  /*virtual*/ Token *clone_token_impl () const { return new Token (*this); }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  Token *clone_token_tree_impl () const override { return clone_token_impl (); }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  Token *clone_macro_match_impl () const override\n+  {\n+    return clone_token_impl ();\n+  }\n+};\n+\n+// A literal - value with a type. Used in LiteralExpr and LiteralPattern.\n+struct Literal\n+{\n+public:\n+  enum LitType\n+  {\n+    CHAR,\n+    STRING,\n+    RAW_STRING,\n+    BYTE,\n+    BYTE_STRING,\n+    RAW_BYTE_STRING,\n+    INT,\n+    FLOAT,\n+    BOOL\n+  };\n+\n+private:\n+  /* TODO: maybe make subclasses of each type of literal with their typed values\n+   * (or generics) */\n+  std::string value_as_string;\n+  LitType type;\n+\n+public:\n+  std::string as_string () const { return value_as_string; }\n+\n+  LitType get_lit_type () const { return type; }\n+\n+  Literal (std::string value_as_string, LitType type)\n+    : value_as_string (std::move (value_as_string)), type (type)\n+  {}\n+\n+  static Literal create_error () { return Literal (\"\", CHAR); }\n+\n+  // Returns whether literal is in an invalid state.\n+  bool is_error () const { return value_as_string == \"\"; }\n+};\n+\n+// A token tree with delimiters\n+class DelimTokenTree : public TokenTree, public AttrInput\n+{\n+  DelimType delim_type;\n+  std::vector<std::unique_ptr<TokenTree> > token_trees;\n+  Location locus;\n+\n+protected:\n+  DelimTokenTree *clone_delim_tok_tree_impl () const\n+  {\n+    return new DelimTokenTree (*this);\n+  }\n+\n+  /* Use covariance to implement clone function as returning a DelimTokenTree\n+   * object */\n+  DelimTokenTree *clone_attr_input_impl () const override\n+  {\n+    return clone_delim_tok_tree_impl ();\n+  }\n+\n+  /* Use covariance to implement clone function as returning a DelimTokenTree\n+   * object */\n+  DelimTokenTree *clone_token_tree_impl () const override\n+  {\n+    return clone_delim_tok_tree_impl ();\n+  }\n+\n+public:\n+  DelimTokenTree (DelimType delim_type,\n+\t\t  std::vector<std::unique_ptr<TokenTree> > token_trees\n+\t\t  = std::vector<std::unique_ptr<TokenTree> > (),\n+\t\t  Location locus = Location ())\n+    : delim_type (delim_type), token_trees (std::move (token_trees)),\n+      locus (locus)\n+  {}\n+\n+  // Copy constructor with vector clone\n+  DelimTokenTree (DelimTokenTree const &other)\n+    : delim_type (other.delim_type), locus (other.locus)\n+  {\n+    token_trees.reserve (other.token_trees.size ());\n+    for (const auto &e : other.token_trees)\n+      token_trees.push_back (e->clone_token_tree ());\n+  }\n+\n+  // overloaded assignment operator with vector clone\n+  DelimTokenTree &operator= (DelimTokenTree const &other)\n+  {\n+    delim_type = other.delim_type;\n+    locus = other.locus;\n+\n+    token_trees.reserve (other.token_trees.size ());\n+    for (const auto &e : other.token_trees)\n+      token_trees.push_back (e->clone_token_tree ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  DelimTokenTree (DelimTokenTree &&other) = default;\n+  DelimTokenTree &operator= (DelimTokenTree &&other) = default;\n+\n+  static DelimTokenTree create_empty () { return DelimTokenTree (PARENS); }\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+  AttrInput *parse_to_meta_item () const override;\n+\n+  std::vector<std::unique_ptr<Token> > to_token_stream () const override;\n+\n+  std::unique_ptr<DelimTokenTree> clone_delim_token_tree () const\n+  {\n+    return std::unique_ptr<DelimTokenTree> (clone_delim_tok_tree_impl ());\n+  }\n+};\n+\n+/* Forward decl - definition moved to rust-expr.h as it requires LiteralExpr to\n+ * be defined */\n+class AttrInputLiteral;\n+\n+/* TODO: move applicable stuff into here or just don't include it because\n+ * nothing uses it A segment of a path (maybe) */\n+class PathSegment\n+{\n+public:\n+  virtual ~PathSegment () {}\n+\n+  virtual std::string as_string () const = 0;\n+\n+  // TODO: add visitor here?\n+};\n+\n+// A segment of a simple path without generic or type arguments\n+class SimplePathSegment : public PathSegment\n+{\n+  std::string segment_name;\n+  Location locus;\n+\n+  // only allow identifiers, \"super\", \"self\", \"crate\", or \"$crate\"\n+public:\n+  // TODO: put checks in constructor to enforce this rule?\n+  SimplePathSegment (std::string segment_name, Location locus = Location ())\n+    : segment_name (std::move (segment_name)), locus (locus)\n+  {}\n+\n+  /* Returns whether simple path segment is in an invalid state (currently, if\n+   * empty). */\n+  bool is_error () const { return segment_name.empty (); }\n+\n+  // Creates an error SimplePathSegment\n+  static SimplePathSegment create_error ()\n+  {\n+    return SimplePathSegment (std::string (\"\"));\n+  }\n+\n+  std::string as_string () const override;\n+\n+  Location get_locus () const { return locus; }\n+\n+  // TODO: visitor pattern?\n+};\n+\n+// A simple path without generic or type arguments\n+class SimplePath\n+{\n+  bool has_opening_scope_resolution;\n+  std::vector<SimplePathSegment> segments;\n+  Location locus;\n+\n+public:\n+  // Constructor\n+  SimplePath (std::vector<SimplePathSegment> path_segments,\n+\t      bool has_opening_scope_resolution = false,\n+\t      Location locus = Location ())\n+    : has_opening_scope_resolution (has_opening_scope_resolution),\n+      segments (std::move (path_segments)), locus (locus)\n+  {}\n+\n+  // Creates an empty SimplePath.\n+  static SimplePath create_empty ()\n+  {\n+    return SimplePath (std::vector<SimplePathSegment> ());\n+  }\n+\n+  // Returns whether the SimplePath is empty, i.e. has path segments.\n+  bool is_empty () const { return segments.empty (); }\n+\n+  std::string as_string () const;\n+\n+  Location get_locus () const { return locus; }\n+\n+  // does this need visitor if not polymorphic? probably not\n+\n+  // path-to-string comparison operator\n+  bool operator== (const std::string &rhs)\n+  {\n+    return !has_opening_scope_resolution && segments.size () == 1\n+\t   && segments[0].as_string () == rhs;\n+  }\n+\n+  /* Creates a single-segment SimplePath from a string. This will not check to\n+   * ensure that this is a valid identifier in path, so be careful. Also, this\n+   * will have no location data.\n+   * TODO have checks? */\n+  static SimplePath from_str (std::string str)\n+  {\n+    std::vector<HIR::SimplePathSegment> single_segments\n+      = {HIR::SimplePathSegment (std::move (str))};\n+    return SimplePath (std::move (single_segments));\n+  }\n+};\n+\n+// aka Attr\n+// Attribute HIR representation\n+struct Attribute\n+{\n+private:\n+  SimplePath path;\n+\n+  // bool has_attr_input;\n+  std::unique_ptr<AttrInput> attr_input;\n+\n+  Location locus;\n+\n+  // TODO: maybe a variable storing whether attr input is parsed or not\n+\n+public:\n+  // Returns whether Attribute has AttrInput\n+  bool has_attr_input () const { return attr_input != nullptr; }\n+\n+  // Constructor has pointer AttrInput for polymorphism reasons\n+  Attribute (SimplePath path, std::unique_ptr<AttrInput> input,\n+\t     Location locus = Location ())\n+    : path (std::move (path)), attr_input (std::move (input)), locus (locus)\n+  {}\n+\n+  // default destructor\n+  ~Attribute () = default;\n+\n+  // Copy constructor must deep copy attr_input as unique pointer\n+  Attribute (Attribute const &other) : path (other.path), locus (other.locus)\n+  {\n+    // guard to protect from null pointer dereference\n+    if (other.attr_input != nullptr)\n+      attr_input = other.attr_input->clone_attr_input ();\n+  }\n+\n+  // overload assignment operator to use custom clone method\n+  Attribute &operator= (Attribute const &other)\n+  {\n+    path = other.path;\n+    locus = other.locus;\n+    // guard to protect from null pointer dereference\n+    if (other.attr_input != nullptr)\n+      attr_input = other.attr_input->clone_attr_input ();\n+\n+    return *this;\n+  }\n+\n+  // default move semantics\n+  Attribute (Attribute &&other) = default;\n+  Attribute &operator= (Attribute &&other) = default;\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<Attribute> clone_attribute () const\n+  {\n+    return std::unique_ptr<Attribute> (clone_attribute_impl ());\n+  }\n+\n+  // Creates an empty attribute (which is invalid)\n+  static Attribute create_empty ()\n+  {\n+    return Attribute (SimplePath::create_empty (), nullptr);\n+  }\n+\n+  // Returns whether the attribute is considered an \"empty\" attribute.\n+  bool is_empty () const { return attr_input == nullptr && path.is_empty (); }\n+\n+  /* e.g.:\n+      #![crate_type = \"lib\"]\n+      #[test]\n+      #[cfg(target_os = \"linux\")]\n+      #[allow(non_camel_case_types)]\n+      #![allow(unused_variables)]\n+  */\n+\n+  // Full built-in attribute list:\n+  /*   cfg\n+   *   cfg_attr\n+   *   test\n+   *   ignore\n+   *   should_panic\n+   *   derive\n+   *   macro_export\n+   *   macro_use\n+   *   proc_macro\n+   *   proc_macro_derive\n+   *   proc_macro_attribute\n+   *   allow\n+   *   warn\n+   *   deny\n+   *   forbid\n+   *   deprecated\n+   *   must_use\n+   *   link\n+   *   link_name\n+   *   no_link\n+   *   repr\n+   *   crate_type\n+   *   no_main\n+   *   export_name\n+   *   link_section\n+   *   no_mangle\n+   *   used\n+   *   crate_name\n+   *   inline\n+   *   cold\n+   *   no_builtins\n+   *   target_feature\n+   *   doc\n+   *   no_std\n+   *   no_implicit_prelude\n+   *   path\n+   *   recursion_limit\n+   *   type_length_limit\n+   *   panic_handler\n+   *   global_allocator\n+   *   windows_subsystem\n+   *   feature     */\n+\n+  std::string as_string () const;\n+\n+  // TODO: does this require visitor pattern as not polymorphic?\n+\n+  // Maybe change to const-reference in future\n+  SimplePath get_path () const { return path; }\n+\n+  // Call to parse attribute body to meta item syntax.\n+  void parse_attr_to_meta_item ();\n+\n+protected:\n+  // not virtual as currently no subclasses of Attribute, but could be in future\n+  /*virtual*/ Attribute *clone_attribute_impl () const\n+  {\n+    return new Attribute (*this);\n+  }\n+};\n+\n+// Forward decl - defined in rust-macro.h\n+class MetaNameValueStr;\n+\n+// abstract base meta item inner class\n+class MetaItemInner\n+{\n+protected:\n+  // pure virtual as MetaItemInner\n+  virtual MetaItemInner *clone_meta_item_inner_impl () const = 0;\n+\n+public:\n+  // Unique pointer custom clone function\n+  std::unique_ptr<MetaItemInner> clone_meta_item_inner () const\n+  {\n+    return std::unique_ptr<MetaItemInner> (clone_meta_item_inner_impl ());\n+  }\n+\n+  virtual ~MetaItemInner () {}\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (HIRVisitor &vis) = 0;\n+\n+  /* HACK: used to simplify parsing - creates a copy of that type, or returns\n+   * null */\n+  virtual std::unique_ptr<MetaNameValueStr> to_meta_name_value_str () const\n+  {\n+    return nullptr;\n+  }\n+\n+  // HACK: used to simplify parsing - same thing\n+  virtual SimplePath to_path_item () const\n+  {\n+    return SimplePath::create_empty ();\n+  }\n+\n+  virtual Attribute to_attribute () const { return Attribute::create_empty (); }\n+};\n+\n+// Container used to store MetaItems as AttrInput (bridge-ish kinda thing)\n+class AttrInputMetaItemContainer : public AttrInput\n+{\n+  std::vector<std::unique_ptr<MetaItemInner> > items;\n+\n+public:\n+  AttrInputMetaItemContainer (\n+    std::vector<std::unique_ptr<MetaItemInner> > items)\n+    : items (std::move (items))\n+  {}\n+\n+  // no destructor definition required\n+\n+  // default move constructors\n+  AttrInputMetaItemContainer (AttrInputMetaItemContainer &&other) = default;\n+  AttrInputMetaItemContainer &operator= (AttrInputMetaItemContainer &&other)\n+    = default;\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+  // Clones this object.\n+  std::unique_ptr<AttrInputMetaItemContainer>\n+  clone_attr_input_meta_item_container () const\n+  {\n+    return std::unique_ptr<AttrInputMetaItemContainer> (\n+      clone_attr_input_meta_item_container_impl ());\n+  }\n+\n+protected:\n+  // Use covariance to implement clone function as returning this type\n+  AttrInputMetaItemContainer *clone_attr_input_impl () const override\n+  {\n+    return clone_attr_input_meta_item_container_impl ();\n+  }\n+\n+  AttrInputMetaItemContainer *clone_attr_input_meta_item_container_impl () const\n+  {\n+    return new AttrInputMetaItemContainer (*this);\n+  }\n+\n+  // copy constructor with vector clone\n+  AttrInputMetaItemContainer (const AttrInputMetaItemContainer &other)\n+  {\n+    items.reserve (other.items.size ());\n+    for (const auto &e : other.items)\n+      items.push_back (e->clone_meta_item_inner ());\n+  }\n+\n+  // copy assignment operator with vector clone\n+  AttrInputMetaItemContainer &\n+  operator= (const AttrInputMetaItemContainer &other)\n+  {\n+    AttrInput::operator= (other);\n+\n+    items.reserve (other.items.size ());\n+    for (const auto &e : other.items)\n+      items.push_back (e->clone_meta_item_inner ());\n+\n+    return *this;\n+  }\n+};\n+\n+// abstract base meta item class\n+class MetaItem : public MetaItemInner\n+{\n+};\n+\n+// Forward decl - defined in rust-expr.h\n+class MetaItemLitExpr;\n+\n+// Forward decl - defined in rust-expr.h\n+class MetaItemPathLit;\n+\n+// Forward decl - defined in rust-macro.h\n+class MetaItemPath;\n+\n+// Forward decl - defined in rust-macro.h\n+class MetaItemSeq;\n+\n+// Forward decl - defined in rust-macro.h\n+class MetaWord;\n+\n+// Forward decl - defined in rust-macro.h\n+class MetaListPaths;\n+\n+// Forward decl - defined in rust-macro.h\n+struct MetaListNameValueStr;\n+\n+/* Base statement abstract class. Note that most \"statements\" are not allowed in\n+ * top-level module scope - only a subclass of statements called \"items\" are. */\n+class Stmt\n+{\n+public:\n+  // Unique pointer custom clone function\n+  std::unique_ptr<Stmt> clone_stmt () const\n+  {\n+    return std::unique_ptr<Stmt> (clone_stmt_impl ());\n+  }\n+\n+  virtual ~Stmt () {}\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (HIRVisitor &vis) = 0;\n+\n+  /* HACK: slow way of getting location from base expression through virtual\n+   * methods. */\n+  virtual Location get_locus_slow () const { return Location (); }\n+\n+  const Analysis::NodeMapping &get_mappings () const { return mappings; }\n+\n+protected:\n+  Stmt (Analysis::NodeMapping mappings) : mappings (std::move (mappings)) {}\n+\n+  // Clone function implementation as pure virtual method\n+  virtual Stmt *clone_stmt_impl () const = 0;\n+\n+  Analysis::NodeMapping mappings;\n+};\n+\n+// Rust \"item\" HIR node (declaration of top-level/module-level allowed stuff)\n+class Item : public Stmt\n+{\n+  std::vector<Attribute> outer_attrs;\n+\n+  // TODO: should outer attrs be defined here or in each derived class?\n+\n+public:\n+  // Unique pointer custom clone function\n+  std::unique_ptr<Item> clone_item () const\n+  {\n+    return std::unique_ptr<Item> (clone_item_impl ());\n+  }\n+\n+  std::string as_string () const;\n+\n+  /* Adds crate names to the vector passed by reference, if it can\n+   * (polymorphism). */\n+  virtual void\n+  add_crate_name (std::vector<std::string> &names ATTRIBUTE_UNUSED) const\n+  {}\n+\n+  virtual void accept_vis (HIRVisitor &vis ATTRIBUTE_UNUSED) {}\n+\n+protected:\n+  // Constructor\n+  Item (Analysis::NodeMapping mappings,\n+\tstd::vector<Attribute> outer_attribs = std::vector<Attribute> ())\n+    : Stmt (std::move (mappings)), outer_attrs (std::move (outer_attribs))\n+  {}\n+\n+  // Clone function implementation as pure virtual method\n+  virtual Item *clone_item_impl () const = 0;\n+\n+  /* Save having to specify two clone methods in derived classes by making\n+   * statement clone return item clone. Hopefully won't affect performance too\n+   * much. */\n+  Item *clone_stmt_impl () const override { return clone_item_impl (); }\n+};\n+\n+// forward decl of ExprWithoutBlock\n+class ExprWithoutBlock;\n+\n+// Base expression HIR node - abstract\n+class Expr\n+{\n+  // TODO: move outer attribute data to derived classes?\n+  std::vector<Attribute> outer_attrs;\n+\n+  Analysis::NodeMapping mappings;\n+\n+public:\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<Expr> clone_expr () const\n+  {\n+    return std::unique_ptr<Expr> (clone_expr_impl ());\n+  }\n+\n+  /* TODO: public methods that could be useful:\n+   *  - get_type() - returns type of expression. set_type() may also be useful\n+   * for some?\n+   *  - evaluate() - evaluates expression if constant? can_evaluate()? */\n+\n+  /* HACK: downcasting without dynamic_cast (if possible) via polymorphism -\n+   * overrided in subclasses of ExprWithoutBlock */\n+  virtual ExprWithoutBlock *as_expr_without_block () const { return nullptr; }\n+\n+  // TODO: make pure virtual if move out outer attributes to derived classes\n+  virtual std::string as_string () const;\n+\n+  virtual ~Expr () {}\n+\n+  /* HACK: slow way of getting location from base expression through virtual\n+   * methods. */\n+  virtual Location get_locus_slow () const { return Location (); }\n+\n+  // HACK: strictly not needed, but faster than full downcast clone\n+  virtual bool is_expr_without_block () const = 0;\n+\n+  virtual void accept_vis (HIRVisitor &vis) = 0;\n+\n+  const Analysis::NodeMapping &get_mappings () const { return mappings; }\n+\n+protected:\n+  // Constructor\n+  Expr (Analysis::NodeMapping mappings,\n+\tstd::vector<Attribute> outer_attribs = std::vector<Attribute> ())\n+    : outer_attrs (std::move (outer_attribs)), mappings (std::move (mappings))\n+  {}\n+\n+  // Clone function implementation as pure virtual method\n+  virtual Expr *clone_expr_impl () const = 0;\n+\n+  // TODO: think of less hacky way to implement this kind of thing\n+  // Sets outer attributes.\n+  void set_outer_attrs (std::vector<Attribute> outer_attrs_to_set)\n+  {\n+    outer_attrs = std::move (outer_attrs_to_set);\n+  }\n+};\n+\n+// HIR node for an expression without an accompanying block - abstract\n+class ExprWithoutBlock : public Expr\n+{\n+protected:\n+  // Constructor\n+  ExprWithoutBlock (Analysis::NodeMapping mappings,\n+\t\t    std::vector<Attribute> outer_attribs\n+\t\t    = std::vector<Attribute> ())\n+    : Expr (std::move (mappings), std::move (outer_attribs))\n+  {}\n+\n+  // pure virtual clone implementation\n+  virtual ExprWithoutBlock *clone_expr_without_block_impl () const = 0;\n+\n+  /* Save having to specify two clone methods in derived classes by making expr\n+   * clone return exprwithoutblock clone. Hopefully won't affect performance too\n+   * much. */\n+  ExprWithoutBlock *clone_expr_impl () const override\n+  {\n+    return clone_expr_without_block_impl ();\n+  }\n+\n+  bool is_expr_without_block () const final override { return true; };\n+\n+public:\n+  // Unique pointer custom clone function\n+  std::unique_ptr<ExprWithoutBlock> clone_expr_without_block () const\n+  {\n+    return std::unique_ptr<ExprWithoutBlock> (clone_expr_without_block_impl ());\n+  }\n+\n+  /* downcasting hack from expr to use pratt parsing with\n+   * parse_expr_without_block */\n+  ExprWithoutBlock *as_expr_without_block () const override\n+  {\n+    return clone_expr_without_block_impl ();\n+  }\n+};\n+\n+/* HACK: IdentifierExpr, delete when figure out identifier vs expr problem in\n+ * Pratt parser */\n+/* Alternatively, identifiers could just be represented as single-segment paths\n+ */\n+class IdentifierExpr : public ExprWithoutBlock\n+{\n+  Identifier ident;\n+\n+public:\n+  Location locus;\n+\n+  IdentifierExpr (Analysis::NodeMapping mappings, Identifier ident,\n+\t\t  Location locus = Location (),\n+\t\t  std::vector<Attribute> outer_attrs\n+\t\t  = std::vector<Attribute> ())\n+    : ExprWithoutBlock (std::move (mappings), std::move (outer_attrs)),\n+      ident (std::move (ident)), locus (locus)\n+  {}\n+\n+  std::string as_string () const override { return ident; }\n+\n+  Location get_locus () const { return locus; }\n+  Location get_locus_slow () const override { return get_locus (); }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+  // Clones this object.\n+  std::unique_ptr<IdentifierExpr> clone_identifier_expr () const\n+  {\n+    return std::unique_ptr<IdentifierExpr> (clone_identifier_expr_impl ());\n+  }\n+\n+protected:\n+  // Clone method implementation\n+  IdentifierExpr *clone_expr_without_block_impl () const override\n+  {\n+    return clone_identifier_expr_impl ();\n+  }\n+\n+  IdentifierExpr *clone_identifier_expr_impl () const\n+  {\n+    return new IdentifierExpr (*this);\n+  }\n+\n+  IdentifierExpr (IdentifierExpr const &other) = default;\n+  IdentifierExpr &operator= (IdentifierExpr const &other) = default;\n+};\n+\n+// Pattern base HIR node\n+class Pattern\n+{\n+public:\n+  // Unique pointer custom clone function\n+  std::unique_ptr<Pattern> clone_pattern () const\n+  {\n+    return std::unique_ptr<Pattern> (clone_pattern_impl ());\n+  }\n+\n+  // possible virtual methods: is_refutable()\n+\n+  virtual ~Pattern () {}\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (HIRVisitor &vis) = 0;\n+\n+protected:\n+  // Clone pattern implementation as pure virtual method\n+  virtual Pattern *clone_pattern_impl () const = 0;\n+};\n+\n+// forward decl for Type\n+class TraitBound;\n+\n+// Base class for types as represented in HIR - abstract\n+class Type\n+{\n+public:\n+  // Unique pointer custom clone function\n+  std::unique_ptr<Type> clone_type () const\n+  {\n+    return std::unique_ptr<Type> (clone_type_impl ());\n+  }\n+\n+  // virtual destructor\n+  virtual ~Type () {}\n+\n+  virtual std::string as_string () const = 0;\n+\n+  /* HACK: convert to trait bound. Virtual method overriden by classes that\n+   * enable this. */\n+  virtual TraitBound *to_trait_bound (bool in_parens ATTRIBUTE_UNUSED) const\n+  {\n+    return nullptr;\n+  }\n+  /* as pointer, shouldn't require definition beforehand, only forward\n+   * declaration. */\n+\n+  virtual void accept_vis (HIRVisitor &vis) = 0;\n+\n+protected:\n+  // Clone function implementation as pure virtual method\n+  virtual Type *clone_type_impl () const = 0;\n+};\n+\n+// A type without parentheses? - abstract\n+class TypeNoBounds : public Type\n+{\n+public:\n+  // Unique pointer custom clone function\n+  std::unique_ptr<TypeNoBounds> clone_type_no_bounds () const\n+  {\n+    return std::unique_ptr<TypeNoBounds> (clone_type_no_bounds_impl ());\n+  }\n+\n+protected:\n+  // Clone function implementation as pure virtual method\n+  virtual TypeNoBounds *clone_type_no_bounds_impl () const = 0;\n+\n+  /* Save having to specify two clone methods in derived classes by making type\n+   * clone return typenobounds clone. Hopefully won't affect performance too\n+   * much. */\n+  TypeNoBounds *clone_type_impl () const override\n+  {\n+    return clone_type_no_bounds_impl ();\n+  }\n+};\n+\n+/* Abstract base class representing a type param bound - Lifetime and TraitBound\n+ * extends it */\n+class TypeParamBound\n+{\n+public:\n+  virtual ~TypeParamBound () {}\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<TypeParamBound> clone_type_param_bound () const\n+  {\n+    return std::unique_ptr<TypeParamBound> (clone_type_param_bound_impl ());\n+  }\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (HIRVisitor &vis) = 0;\n+\n+protected:\n+  // Clone function implementation as pure virtual method\n+  virtual TypeParamBound *clone_type_param_bound_impl () const = 0;\n+};\n+\n+// Represents a lifetime (and is also a kind of type param bound)\n+class Lifetime : public TypeParamBound\n+{\n+public:\n+  enum LifetimeType\n+  {\n+    NAMED,   // corresponds to LIFETIME_OR_LABEL\n+    STATIC,  // corresponds to 'static\n+    WILDCARD // corresponds to '_\n+  };\n+\n+private:\n+  LifetimeType lifetime_type;\n+\n+  // TODO: LIFETIME_OR_LABEL (aka lifetime token) is only field\n+  // find way of enclosing token or something\n+  std::string lifetime_name;\n+  // only applies for NAMED lifetime_type\n+\n+  Location locus;\n+\n+public:\n+  // Constructor\n+  Lifetime (LifetimeType type, std::string name = std::string (),\n+\t    Location locus = Location ())\n+    : lifetime_type (type), lifetime_name (std::move (name)), locus (locus)\n+  {}\n+\n+  // Creates an \"error\" lifetime.\n+  static Lifetime error () { return Lifetime (NAMED, std::string (\"\")); }\n+\n+  // Returns true if the lifetime is in an error state.\n+  bool is_error () const\n+  {\n+    return lifetime_type == NAMED && lifetime_name.empty ();\n+  }\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  Lifetime *clone_type_param_bound_impl () const override\n+  {\n+    return new Lifetime (*this);\n+  }\n+};\n+\n+/* Base generic parameter in HIR. Abstract - can be represented by a Lifetime or\n+ * Type param */\n+class GenericParam\n+{\n+public:\n+  virtual ~GenericParam () {}\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<GenericParam> clone_generic_param () const\n+  {\n+    return std::unique_ptr<GenericParam> (clone_generic_param_impl ());\n+  }\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (HIRVisitor &vis) = 0;\n+\n+protected:\n+  // Clone function implementation as pure virtual method\n+  virtual GenericParam *clone_generic_param_impl () const = 0;\n+};\n+\n+// A lifetime generic parameter (as opposed to a type generic parameter)\n+class LifetimeParam : public GenericParam\n+{\n+  Lifetime lifetime;\n+\n+  // bool has_lifetime_bounds;\n+  // LifetimeBounds lifetime_bounds;\n+  std::vector<Lifetime> lifetime_bounds; // inlined LifetimeBounds\n+\n+  // bool has_outer_attribute;\n+  // std::unique_ptr<Attribute> outer_attr;\n+  Attribute outer_attr;\n+\n+  Location locus;\n+\n+public:\n+  // Returns whether the lifetime param has any lifetime bounds.\n+  bool has_lifetime_bounds () const { return !lifetime_bounds.empty (); }\n+\n+  // Returns whether the lifetime param has an outer attribute.\n+  bool has_outer_attribute () const { return !outer_attr.is_empty (); }\n+\n+  // Creates an error state lifetime param.\n+  static LifetimeParam create_error ()\n+  {\n+    return LifetimeParam (Lifetime::error ());\n+  }\n+\n+  // Returns whether the lifetime param is in an error state.\n+  bool is_error () const { return lifetime.is_error (); }\n+\n+  // Constructor\n+  LifetimeParam (Lifetime lifetime, Location locus = Location (),\n+\t\t std::vector<Lifetime> lifetime_bounds\n+\t\t = std::vector<Lifetime> (),\n+\t\t Attribute outer_attr = Attribute::create_empty ())\n+    : lifetime (std::move (lifetime)),\n+      lifetime_bounds (std::move (lifetime_bounds)),\n+      outer_attr (std::move (outer_attr)), locus (locus)\n+  {}\n+\n+  // TODO: remove copy and assignment operator definitions - not required\n+\n+  // Copy constructor with clone\n+  LifetimeParam (LifetimeParam const &other)\n+    : lifetime (other.lifetime), lifetime_bounds (other.lifetime_bounds),\n+      outer_attr (other.outer_attr), locus (other.locus)\n+  {}\n+\n+  // Overloaded assignment operator to clone attribute\n+  LifetimeParam &operator= (LifetimeParam const &other)\n+  {\n+    lifetime = other.lifetime;\n+    lifetime_bounds = other.lifetime_bounds;\n+    outer_attr = other.outer_attr;\n+    locus = other.locus;\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  LifetimeParam (LifetimeParam &&other) = default;\n+  LifetimeParam &operator= (LifetimeParam &&other) = default;\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  LifetimeParam *clone_generic_param_impl () const override\n+  {\n+    return new LifetimeParam (*this);\n+  }\n+};\n+\n+// A macro item HIR node - potentially abstract base class\n+class MacroItem : public Item\n+{\n+  /*public:\n+  std::string as_string() const;*/\n+protected:\n+  MacroItem (Analysis::NodeMapping mappings,\n+\t     std::vector<Attribute> outer_attribs)\n+    : Item (std::move (mappings), std::move (outer_attribs))\n+  {}\n+};\n+\n+// Item used in trait declarations - abstract base class\n+class TraitItem\n+{\n+  // bool has_outer_attrs;\n+  // TODO: remove and rely on virtual functions and VisItem-derived attributes?\n+  // std::vector<Attribute> outer_attrs;\n+\n+  // NOTE: all children should have outer attributes\n+\n+protected:\n+  // Constructor\n+  /*TraitItem(std::vector<Attribute> outer_attrs = std::vector<Attribute>())\n+    : outer_attrs(std::move(outer_attrs)) {}*/\n+\n+  // Clone function implementation as pure virtual method\n+  virtual TraitItem *clone_trait_item_impl () const = 0;\n+\n+public:\n+  virtual ~TraitItem () {}\n+\n+  // Returns whether TraitItem has outer attributes.\n+  /*bool has_outer_attrs() const {\n+      return !outer_attrs.empty();\n+  }*/\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<TraitItem> clone_trait_item () const\n+  {\n+    return std::unique_ptr<TraitItem> (clone_trait_item_impl ());\n+  }\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (HIRVisitor &vis) = 0;\n+};\n+\n+/* Abstract base class for items used within an inherent impl block (the impl\n+ * name {} one) */\n+class InherentImplItem\n+{\n+protected:\n+  // Clone function implementation as pure virtual method\n+  virtual InherentImplItem *clone_inherent_impl_item_impl () const = 0;\n+\n+public:\n+  virtual ~InherentImplItem () {}\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<InherentImplItem> clone_inherent_impl_item () const\n+  {\n+    return std::unique_ptr<InherentImplItem> (clone_inherent_impl_item_impl ());\n+  }\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (HIRVisitor &vis) = 0;\n+};\n+\n+// Abstract base class for items used in a trait impl\n+class TraitImplItem\n+{\n+protected:\n+  virtual TraitImplItem *clone_trait_impl_item_impl () const = 0;\n+\n+public:\n+  virtual ~TraitImplItem (){};\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<TraitImplItem> clone_trait_impl_item () const\n+  {\n+    return std::unique_ptr<TraitImplItem> (clone_trait_impl_item_impl ());\n+  }\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (HIRVisitor &vis) = 0;\n+};\n+\n+/* A macro invocation item (or statement) HIR node (i.e. semi-coloned macro\n+ * invocation) */\n+class MacroInvocationSemi : public MacroItem,\n+\t\t\t    public TraitItem,\n+\t\t\t    public InherentImplItem,\n+\t\t\t    public TraitImplItem\n+{\n+  SimplePath path;\n+  // all delim types except curly must have invocation end with a semicolon\n+  DelimType delim_type;\n+  std::vector<std::unique_ptr<TokenTree> > token_trees;\n+  Location locus;\n+\n+public:\n+  std::string as_string () const override;\n+\n+  MacroInvocationSemi (Analysis::NodeMapping mappings, SimplePath macro_path,\n+\t\t       DelimType delim_type,\n+\t\t       std::vector<std::unique_ptr<TokenTree> > token_trees,\n+\t\t       std::vector<Attribute> outer_attribs, Location locus)\n+    : MacroItem (std::move (mappings), std::move (outer_attribs)),\n+      path (std::move (macro_path)), delim_type (delim_type),\n+      token_trees (std::move (token_trees)), locus (locus)\n+  {}\n+  /* TODO: possible issue with Item and TraitItem hierarchies both having outer\n+   * attributes\n+   * - storage inefficiency at least.\n+   * Best current idea is to make Item preferred and have TraitItem get virtual\n+   * functions for attributes or something. Or just redo the \"composition\"\n+   * approach, but then this prevents polymorphism and would entail redoing\n+   * quite a bit of the parser. */\n+\n+  // Move constructors\n+  MacroInvocationSemi (MacroInvocationSemi &&other) = default;\n+  MacroInvocationSemi &operator= (MacroInvocationSemi &&other) = default;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+  // Clones this macro invocation semi.\n+  std::unique_ptr<MacroInvocationSemi> clone_macro_invocation_semi () const\n+  {\n+    return std::unique_ptr<MacroInvocationSemi> (\n+      clone_macro_invocation_semi_impl ());\n+  }\n+\n+protected:\n+  // Copy constructor with vector clone\n+  MacroInvocationSemi (MacroInvocationSemi const &other)\n+    : MacroItem (other), TraitItem (other), InherentImplItem (other),\n+      TraitImplItem (other), path (other.path), delim_type (other.delim_type),\n+      locus (other.locus)\n+  {\n+    token_trees.reserve (other.token_trees.size ());\n+    for (const auto &e : other.token_trees)\n+      token_trees.push_back (e->clone_token_tree ());\n+  }\n+\n+  // Overloaded assignment operator to vector clone\n+  MacroInvocationSemi &operator= (MacroInvocationSemi const &other)\n+  {\n+    MacroItem::operator= (other);\n+    TraitItem::operator= (other);\n+    InherentImplItem::operator= (other);\n+    TraitImplItem::operator= (other);\n+    path = other.path;\n+    delim_type = other.delim_type;\n+    locus = other.locus;\n+\n+    token_trees.reserve (other.token_trees.size ());\n+    for (const auto &e : other.token_trees)\n+      token_trees.push_back (e->clone_token_tree ());\n+\n+    return *this;\n+  }\n+\n+  MacroInvocationSemi *clone_macro_invocation_semi_impl () const\n+  {\n+    return new MacroInvocationSemi (*this);\n+  }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  MacroInvocationSemi *clone_item_impl () const override\n+  {\n+    return clone_macro_invocation_semi_impl ();\n+  }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  MacroInvocationSemi *clone_inherent_impl_item_impl () const override\n+  {\n+    return clone_macro_invocation_semi_impl ();\n+  }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  MacroInvocationSemi *clone_trait_impl_item_impl () const override\n+  {\n+    return clone_macro_invocation_semi_impl ();\n+  }\n+\n+  // FIXME: remove if item impl virtual override works properly\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  /*MacroInvocationSemi* clone_statement_impl() const override {\n+      return clone_macro_invocation_semi_impl ();\n+  }*/\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  MacroInvocationSemi *clone_trait_item_impl () const override\n+  {\n+    return clone_macro_invocation_semi_impl ();\n+  }\n+};\n+\n+// A crate HIR object - holds all the data for a single compilation unit\n+struct Crate\n+{\n+  bool has_utf8bom;\n+  bool has_shebang;\n+\n+  std::vector<Attribute> inner_attrs;\n+  // dodgy spacing required here\n+  /* TODO: is it better to have a vector of items here or a module (implicit\n+   * top-level one)? */\n+  std::vector<std::unique_ptr<Item> > items;\n+\n+  Analysis::NodeMapping mappings;\n+\n+public:\n+  // Constructor\n+  Crate (std::vector<std::unique_ptr<Item> > items,\n+\t std::vector<Attribute> inner_attrs, Analysis::NodeMapping mappings,\n+\t bool has_utf8bom = false, bool has_shebang = false)\n+    : has_utf8bom (has_utf8bom), has_shebang (has_shebang),\n+      inner_attrs (std::move (inner_attrs)), items (std::move (items)),\n+      mappings (mappings)\n+  {}\n+\n+  // Copy constructor with vector clone\n+  Crate (Crate const &other)\n+    : has_utf8bom (other.has_utf8bom), has_shebang (other.has_shebang),\n+      inner_attrs (other.inner_attrs), mappings (other.mappings)\n+  {\n+    items.reserve (other.items.size ());\n+    for (const auto &e : other.items)\n+      items.push_back (e->clone_item ());\n+  }\n+\n+  ~Crate () = default;\n+\n+  // Overloaded assignment operator with vector clone\n+  Crate &operator= (Crate const &other)\n+  {\n+    inner_attrs = other.inner_attrs;\n+    has_shebang = other.has_shebang;\n+    has_utf8bom = other.has_utf8bom;\n+    mappings = other.mappings;\n+\n+    items.reserve (other.items.size ());\n+    for (const auto &e : other.items)\n+      items.push_back (e->clone_item ());\n+\n+    return *this;\n+  }\n+\n+  // Move constructors\n+  Crate (Crate &&other) = default;\n+  Crate &operator= (Crate &&other) = default;\n+\n+  // Get crate representation as string (e.g. for debugging).\n+  std::string as_string () const;\n+\n+  const Analysis::NodeMapping &get_mappings () const { return mappings; }\n+};\n+\n+// Base path expression HIR node - abstract\n+class PathExpr : public ExprWithoutBlock\n+{\n+protected:\n+  PathExpr (Analysis::NodeMapping mappings,\n+\t    std::vector<Attribute> outer_attribs)\n+    : ExprWithoutBlock (std::move (mappings), std::move (outer_attribs))\n+  {}\n+\n+public:\n+  // TODO: think of a better and less hacky way to allow this\n+\n+  /* Replaces the outer attributes of this path expression with the given outer\n+   * attributes. */\n+  void replace_outer_attrs (std::vector<Attribute> outer_attrs)\n+  {\n+    set_outer_attrs (std::move (outer_attrs));\n+  }\n+};\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif"}]}