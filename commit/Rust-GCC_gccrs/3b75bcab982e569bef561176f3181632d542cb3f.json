{"sha": "3b75bcab982e569bef561176f3181632d542cb3f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2I3NWJjYWI5ODJlNTY5YmVmNTYxMTc2ZjMxODE2MzJkNTQyY2IzZg==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2006-10-31T18:08:12Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-10-31T18:08:12Z"}, "message": "sem_ch7.adb (Check_Anonymous_Access_Types): New procedure...\n\n2006-10-31  Ed Schonberg  <schonberg@adacore.com>\n\t    Javier Miranda  <miranda@adacore.com>\n\n\t* sem_ch7.adb (Check_Anonymous_Access_Types): New procedure, subsidiary\n\tof Analyze_Package_Body, to create Itype references for anonymous\n\taccess types created in the package declaration, whose designated types\n\tmay have only a limited view.\n\t(Analyze_Package_Specification): For the private part of a nested\n\tpackage, install private_with_clauses of enclosing compilation unit if\n\twe are in its visible part.\n\t(Declare_Inherited_Private_Subprograms): Complete barrier\n\tto ensure that the primitive operation has an alias to some parent\n\tprimitive. This is now required because, after the changes done for the\n\timplementation of abstract interfaces, the contents of the list of\n\tprimitives has entities whose alias attribute references entities of\n\tsuch list of primitives.\n\t(Analyze_Package_Specification): Simplify code that handles parent units\n\tof instances and formal packages.\n\t(Uninstall_Declarations): Check the convention consistency among\n\tprimitive overriding operations of a tagged record type.\n\nFrom-SVN: r118305", "tree": {"sha": "2b346c909e05c205088349521c5da0ae23f9b1dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b346c909e05c205088349521c5da0ae23f9b1dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b75bcab982e569bef561176f3181632d542cb3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b75bcab982e569bef561176f3181632d542cb3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b75bcab982e569bef561176f3181632d542cb3f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b75bcab982e569bef561176f3181632d542cb3f/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ec4867fab9418c5b8ab6917e6accd3a9822e96c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec4867fab9418c5b8ab6917e6accd3a9822e96c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec4867fab9418c5b8ab6917e6accd3a9822e96c6"}], "stats": {"total": 254, "additions": 170, "deletions": 84}, "files": [{"sha": "2e03e1f7a451ad825d9dc6d3a603584f9f0f45cb", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 170, "deletions": 84, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b75bcab982e569bef561176f3181632d542cb3f/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b75bcab982e569bef561176f3181632d542cb3f/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=3b75bcab982e569bef561176f3181632d542cb3f", "patch": "@@ -50,6 +50,7 @@ with Sem_Ch6;  use Sem_Ch6;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Ch10; use Sem_Ch10;\n with Sem_Ch12; use Sem_Ch12;\n+with Sem_Disp; use Sem_Disp;\n with Sem_Util; use Sem_Util;\n with Sem_Warn; use Sem_Warn;\n with Snames;   use Snames;\n@@ -86,6 +87,17 @@ package body Sem_Ch7 is\n    -- Local Subprograms --\n    -----------------------\n \n+   procedure Check_Anonymous_Access_Types\n+     (Spec_Id : Entity_Id;\n+      P_Body  :  Node_Id);\n+   --  If the spec of a package has a limited_with_clause, it may declare\n+   --  anonymous access types whose designated type is a limited view, such\n+   --  an anonymous access return type for a function. This access type\n+   --  cannot be elaborated in the spec itself, but it may need an itype\n+   --  reference if it is used within a nested scope. In that case the itype\n+   --  reference is created at the beginning of the corresponding package body\n+   --  and inserted before other body declarations.\n+\n    procedure Install_Package_Entity (Id : Entity_Id);\n    --  Basic procedure for the previous two. Places one entity on its\n    --  visibility chain, and recurses on the visible part if the entity\n@@ -95,26 +107,25 @@ package body Sem_Ch7 is\n    --  True for a private type that is not a subtype\n \n    function Is_Visible_Dependent (Dep : Entity_Id) return Boolean;\n-   --  If the private dependent is a private type whose full view is\n-   --  derived from the parent type, its full properties are revealed\n-   --  only if we are in the immediate scope of the private dependent.\n-   --  Should this predicate be tightened further???\n+   --  If the private dependent is a private type whose full view is derived\n+   --  from the parent type, its full properties are revealed only if we are in\n+   --  the immediate scope of the private dependent. Should this predicate be\n+   --  tightened further???\n \n    procedure Declare_Inherited_Private_Subprograms (Id : Entity_Id);\n-   --  Called upon entering the private part of a public child package\n-   --  and the body of a nested package, to potentially declare certain\n-   --  inherited subprograms that were inherited by types in the visible\n-   --  part, but whose declaration was deferred because the parent\n-   --  operation was private and not visible at that point. These\n-   --  subprograms are located by traversing the visible part declarations\n-   --  looking for non-private type extensions and then examining each of\n-   --  the primitive operations of such types to find those that were\n-   --  inherited but declared with a special internal name. Each such\n-   --  operation is now declared as an operation with a normal name (using\n-   --  the name of the parent operation) and replaces the previous implicit\n-   --  operation in the primitive operations list of the type. If the\n-   --  inherited private operation has been overridden, then it's\n-   --  replaced by the overriding operation.\n+   --  Called upon entering the private part of a public child package and the\n+   --  body of a nested package, to potentially declare certain inherited\n+   --  subprograms that were inherited by types in the visible part, but whose\n+   --  declaration was deferred because the parent operation was private and\n+   --  not visible at that point. These subprograms are located by traversing\n+   --  the visible part declarations looking for non-private type extensions\n+   --  and then examining each of the primitive operations of such types to\n+   --  find those that were inherited but declared with a special internal\n+   --  name. Each such operation is now declared as an operation with a normal\n+   --  name (using the name of the parent operation) and replaces the previous\n+   --  implicit operation in the primitive operations list of the type. If the\n+   --  inherited private operation has been overridden, then it's replaced by\n+   --  the overriding operation.\n \n    --------------------------\n    -- Analyze_Package_Body --\n@@ -144,9 +155,7 @@ package body Sem_Ch7 is\n \n       begin\n          Id := First_Entity (P);\n-\n          while Present (Id) loop\n-\n             if Is_Type (Id)\n               and then (Is_Limited_Composite (Id)\n                          or else Is_Private_Composite (Id))\n@@ -251,6 +260,7 @@ package body Sem_Ch7 is\n          Body_Id := Defining_Entity (N);\n          Set_Ekind (Body_Id, E_Package_Body);\n          Set_Scope (Body_Id, Scope (Spec_Id));\n+         Set_Is_Obsolescent (Body_Id, Is_Obsolescent (Spec_Id));\n          Set_Body_Entity (Spec_Id, Body_Id);\n          Set_Spec_Entity (Body_Id, Spec_Id);\n \n@@ -303,6 +313,8 @@ package body Sem_Ch7 is\n       Install_Private_With_Clauses (Spec_Id);\n       Install_Composite_Operations (Spec_Id);\n \n+      Check_Anonymous_Access_Types (Spec_Id, N);\n+\n       if Ekind (Spec_Id) = E_Generic_Package then\n          Set_Use (Generic_Formal_Declarations (Pack_Decl));\n       end if;\n@@ -345,22 +357,22 @@ package body Sem_Ch7 is\n \n       Generate_Reference (Spec_Id, Body_Id, 'b', Set_Ref => False);\n \n-      --  For a generic package, collect global references and mark\n-      --  them on the original body so that they are not resolved\n-      --  again at the point of instantiation.\n+      --  For a generic package, collect global references and mark them on\n+      --  the original body so that they are not resolved again at the point\n+      --  of instantiation.\n \n       if Ekind (Spec_Id) /= E_Package then\n          Save_Global_References (Original_Node (N));\n          End_Generic;\n       end if;\n \n-      --  The entities of the package body have so far been chained onto\n-      --  the declaration chain for the spec. That's been fine while we\n-      --  were in the body, since we wanted them to be visible, but now\n-      --  that we are leaving the package body, they are no longer visible,\n-      --  so we remove them from the entity chain of the package spec entity,\n-      --  and copy them to the entity chain of the package body entity, where\n-      --  they will never again be visible.\n+      --  The entities of the package body have so far been chained onto the\n+      --  declaration chain for the spec. That's been fine while we were in the\n+      --  body, since we wanted them to be visible, but now that we are leaving\n+      --  the package body, they are no longer visible, so we remove them from\n+      --  the entity chain of the package spec entity, and copy them to the\n+      --  entity chain of the package body entity, where they will never again\n+      --  be visible.\n \n       if Present (Last_Spec_Entity) then\n          Set_First_Entity (Body_Id, Next_Entity (Last_Spec_Entity));\n@@ -384,7 +396,6 @@ package body Sem_Ch7 is\n \n       begin\n          E := First_Entity (Body_Id);\n-\n          while Present (E) loop\n             Set_Is_Immediately_Visible (E, False);\n             Set_Is_Potentially_Use_Visible (E, False);\n@@ -470,7 +481,6 @@ package body Sem_Ch7 is\n                end if;\n \n                D := Last (L);\n-\n                while Present (D) loop\n                   K := Nkind (D);\n \n@@ -688,6 +698,13 @@ package body Sem_Ch7 is\n       L            : Entity_Id;\n       Public_Child : Boolean;\n \n+      Private_With_Clauses_Installed : Boolean := False;\n+      --  In Ada 2005, private with_clauses are visible in the private part\n+      --  of a nested package, even if it appears in the public part of the\n+      --  enclosing package. This requires a separate step to install these\n+      --  private_with_clauses, and remove them at the end of the nested\n+      --  package.\n+\n       procedure Clear_Constants (Id : Entity_Id; FE : Entity_Id);\n       --  Clears constant indications (Never_Set_In_Source, Constant_Value,\n       --  and Is_True_Constant) on all variables that are entities of Id,\n@@ -737,8 +754,10 @@ package body Sem_Ch7 is\n          end if;\n \n          --  Note: in the loop below, the check for Next_Entity pointing\n-         --  back to the package entity seems very odd, but it is needed,\n-         --  because this kind of unexpected circularity does occur ???\n+         --  back to the package entity may seem odd, but it is needed,\n+         --  because a package can contain a renaming declaration to itself,\n+         --  and such renamings are generated automatically within package\n+         --  instances.\n \n          E := FE;\n          while Present (E) and then E /= Id loop\n@@ -747,6 +766,7 @@ package body Sem_Ch7 is\n                Set_Is_True_Constant    (E, False);\n                Set_Current_Value       (E, Empty);\n                Set_Is_Known_Null       (E, False);\n+               Set_Last_Assignment     (E, Empty);\n \n                if not Can_Never_Be_Null (E) then\n                   Set_Is_Known_Non_Null (E, False);\n@@ -867,9 +887,10 @@ package body Sem_Ch7 is\n       ----------------------------------------\n \n       procedure Inspect_Unchecked_Union_Completion (Decls : List_Id) is\n-         Decl : Node_Id := First (Decls);\n+         Decl : Node_Id;\n \n       begin\n+         Decl := First (Decls);\n          while Present (Decl) loop\n \n             --  We are looking at an incomplete or private type declaration\n@@ -898,11 +919,12 @@ package body Sem_Ch7 is\n       -----------------------------------------\n \n       procedure Install_Parent_Private_Declarations (Inst_Id : Entity_Id) is\n-         Inst_Par  : Entity_Id := Inst_Id;\n+         Inst_Par  : Entity_Id;\n          Gen_Par   : Entity_Id;\n          Inst_Node : Node_Id;\n \n       begin\n+         Inst_Par := Inst_Id;\n          Gen_Par :=\n            Generic_Parent (Specification (Unit_Declaration_Node (Inst_Par)));\n          while Present (Gen_Par) and then Is_Child_Unit (Gen_Par) loop\n@@ -923,13 +945,25 @@ package body Sem_Ch7 is\n                    (Specification (Unit_Declaration_Node (Inst_Par)));\n \n                --  Install the private declarations and private use clauses\n-               --  of a parent instance of the child instance.\n+               --  of a parent instance of the child instance, unless the\n+               --  parent instance private declarations have already been\n+               --  installed earlier in Analyze_Package_Specification, which\n+               --  happens when a generic child is instantiated, and the\n+               --  instance is a child of the parent instance.\n+\n+               --  Installing the use clauses of the parent instance twice is\n+               --  both unnecessary and wrong, because it would cause the\n+               --  clauses to be chained to themselves in the use clauses list\n+               --  of the scope stack entry. That in turn would cause\n+               --  End_Use_Clauses to get into an endless look upon scope exit.\n \n                if Present (Gen_Par) then\n-                  Install_Private_Declarations (Inst_Par);\n-                  Set_Use (Private_Declarations\n-                             (Specification\n-                                (Unit_Declaration_Node (Inst_Par))));\n+                  if not In_Private_Part (Inst_Par) then\n+                     Install_Private_Declarations (Inst_Par);\n+                     Set_Use (Private_Declarations\n+                                (Specification\n+                                   (Unit_Declaration_Node (Inst_Par))));\n+                  end if;\n \n                --  If we've reached the end of the generic instance parents,\n                --  then finish off by looping through the nongeneric parents\n@@ -1003,8 +1037,8 @@ package body Sem_Ch7 is\n          end;\n       end if;\n \n-      --  If package is a public child unit, then make the private\n-      --  declarations of the parent visible.\n+      --  If package is a public child unit, then make the private declarations\n+      --  of the parent visible.\n \n       Public_Child := False;\n \n@@ -1017,7 +1051,7 @@ package body Sem_Ch7 is\n          Par := Id;\n          Par_Spec := Parent_Spec (Parent (N));\n \n-         --  If the package is formal package of an enclosing generic, is is\n+         --  If the package is formal package of an enclosing generic, it is\n          --  transformed into a local generic declaration, and compiled to make\n          --  its spec available. We need to retrieve the original generic to\n          --  determine whether it is a child unit, and install its parents.\n@@ -1035,6 +1069,7 @@ package body Sem_Ch7 is\n \n             while Scope (Par) /= Standard_Standard\n               and then Is_Public_Child (Id, Par)\n+              and then In_Open_Scopes (Par)\n             loop\n                Public_Child := True;\n                Par := Scope (Par);\n@@ -1048,33 +1083,44 @@ package body Sem_Ch7 is\n \n       if Is_Compilation_Unit (Id) then\n          Install_Private_With_Clauses (Id);\n+      else\n+\n+         --  The current compilation unit may include private with_clauses,\n+         --  which are visible in the private part of the current nested\n+         --  package, and have to be installed now.\n+\n+         declare\n+            Comp_Unit : constant Entity_Id := Cunit_Entity (Current_Sem_Unit);\n+         begin\n+            if (Ekind (Comp_Unit) = E_Package\n+                 or else Ekind (Comp_Unit) = E_Generic_Package)\n+              and then not In_Private_Part (Comp_Unit)\n+            then\n+               Install_Private_With_Clauses (Comp_Unit);\n+               Private_With_Clauses_Installed := True;\n+            end if;\n+         end;\n       end if;\n \n       --  If this is a package associated with a generic instance or formal\n       --  package, then the private declarations of each of the generic's\n       --  parents must be installed at this point.\n \n-      if Is_Generic_Instance (Id)\n-        or else\n-          (Nkind (Unit_Declaration_Node (Id)) = N_Generic_Package_Declaration\n-             and then\n-           Nkind (Original_Node (Unit_Declaration_Node (Id)))\n-             = N_Formal_Package_Declaration)\n-      then\n+      if Is_Generic_Instance (Id) then\n          Install_Parent_Private_Declarations (Id);\n       end if;\n \n-      --  Analyze private part if present. The flag In_Private_Part is\n-      --  reset in End_Package_Scope.\n+      --  Analyze private part if present. The flag In_Private_Part is reset\n+      --  in End_Package_Scope.\n \n       L := Last_Entity (Id);\n \n       if Present (Priv_Decls) then\n          Set_In_Private_Part (Id);\n \n-         --  Upon entering a public child's private part, it may be\n-         --  necessary to declare subprograms that were derived in\n-         --  the package visible part but not yet made visible.\n+         --  Upon entering a public child's private part, it may be necessary\n+         --  to declare subprograms that were derived in the package's visible\n+         --  part but not yet made visible.\n \n          if Public_Child then\n             Declare_Inherited_Private_Subprograms (Id);\n@@ -1095,20 +1141,19 @@ package body Sem_Ch7 is\n             Set_First_Private_Entity (Id, First_Entity (Id));\n          end if;\n \n-      --  There may be inherited private subprograms that need to be\n-      --  declared, even in the absence of an explicit private part.\n-      --  If there are any public declarations in the package and\n-      --  the package is a public child unit, then an implicit private\n-      --  part is assumed.\n+      --  There may be inherited private subprograms that need to be declared,\n+      --  even in the absence of an explicit private part.  If there are any\n+      --  public declarations in the package and the package is a public child\n+      --  unit, then an implicit private part is assumed.\n \n       elsif Present (L) and then Public_Child then\n          Set_In_Private_Part (Id);\n          Declare_Inherited_Private_Subprograms (Id);\n          Set_First_Private_Entity (Id, Next_Entity (L));\n       end if;\n \n-      --  Check rule of 3.6(11), which in general requires\n-      --  waiting till all full types have been seen.\n+      --  Check rule of 3.6(11), which in general requires waiting till all\n+      --  full types have been seen.\n \n       E := First_Entity (Id);\n       while Present (E) loop\n@@ -1155,18 +1200,25 @@ package body Sem_Ch7 is\n \n       Process_End_Label (N, 'e', Id);\n \n-      --  For the case of a library level package, we must go through all\n-      --  the entities clearing the indications that the value may be\n-      --  constant and not modified. Why? Because any client of this\n-      --  package may modify these values freely from anywhere. This\n-      --  also applies to any nested packages or generic packages.\n+      --  Remove private_with_clauses of enclosing compilation unit, if they\n+      --  were installed.\n+\n+      if Private_With_Clauses_Installed then\n+         Remove_Private_With_Clauses (Cunit (Current_Sem_Unit));\n+      end if;\n+\n+      --  For the case of a library level package, we must go through all the\n+      --  entities clearing the indications that the value may be constant and\n+      --  not modified. Why? Because any client of this package may modify\n+      --  these values freely from anywhere. This also applies to any nested\n+      --  packages or generic packages.\n \n-      --  For now we unconditionally clear constants for packages that\n-      --  are instances of generic packages. The reason is that we do not\n-      --  have the body yet, and we otherwise think things are unreferenced\n-      --  when they are not. This should be fixed sometime (the effect is\n-      --  not terrible, we just lose some warnings, and also some cases\n-      --  of value propagation) ???\n+      --  For now we unconditionally clear constants for packages that are\n+      --  instances of generic packages. The reason is that we do not have the\n+      --  body yet, and we otherwise think things are unreferenced when they\n+      --  are not. This should be fixed sometime (the effect is not terrible,\n+      --  we just lose some warnings, and also some cases of value propagation)\n+      --  ???\n \n       if Is_Library_Level_Entity (Id)\n         or else Is_Generic_Instance (Id)\n@@ -1200,6 +1252,44 @@ package body Sem_Ch7 is\n       Set_Depends_On_Private (Id);\n    end Analyze_Private_Type_Declaration;\n \n+   ----------------------------------\n+   -- Check_Anonymous_Access_Types --\n+   ----------------------------------\n+\n+   procedure Check_Anonymous_Access_Types\n+     (Spec_Id : Entity_Id;\n+      P_Body  : Node_Id)\n+   is\n+      E  : Entity_Id;\n+      IR : Node_Id;\n+\n+   begin\n+      --  Itype references are only needed by gigi, to force elaboration of\n+      --  itypes. In the absence of code generation, they are not needed.\n+\n+      if not Expander_Active then\n+         return;\n+      end if;\n+\n+      E := First_Entity (Spec_Id);\n+      while Present (E) loop\n+         if Ekind (E) = E_Anonymous_Access_Type\n+           and then From_With_Type (E)\n+         then\n+            IR := Make_Itype_Reference (Sloc (P_Body));\n+            Set_Itype (IR, E);\n+\n+            if No (Declarations (P_Body)) then\n+               Set_Declarations (P_Body, New_List);\n+            end if;\n+\n+            Insert_Before (First (Declarations (P_Body)), IR);\n+         end if;\n+\n+         Next_Entity (E);\n+      end loop;\n+   end Check_Anonymous_Access_Types;\n+\n    -------------------------------------------\n    -- Declare_Inherited_Private_Subprograms --\n    -------------------------------------------\n@@ -1232,7 +1322,6 @@ package body Sem_Ch7 is\n \n          else\n             Formal := First_Formal (S);\n-\n             while Present (Formal) loop\n                if Etype (Formal) = T then\n                   return True;\n@@ -1279,6 +1368,7 @@ package body Sem_Ch7 is\n                   --  by an overriding operation if one exists.\n \n                   if Present (Alias (Prim_Op))\n+                    and then Find_Dispatching_Type (Alias (Prim_Op)) /= E\n                     and then not Comes_From_Source (Prim_Op)\n                     and then Is_Internal_Name (Chars (Prim_Op))\n                     and then not Is_Internal_Name (Chars (Alias (Prim_Op)))\n@@ -1358,7 +1448,6 @@ package body Sem_Ch7 is\n                --   inherited hidden operations.\n \n                Prim_Op := Next_Entity (E);\n-\n                while Present (Prim_Op) loop\n                   if Is_Subprogram (Prim_Op)\n                     and then Present (Alias (Prim_Op))\n@@ -1466,7 +1555,6 @@ package body Sem_Ch7 is\n \n       Id := First_Entity (P);\n       while Present (Id) and then Id /= First_Private_Entity (P) loop\n-\n          if Is_Private_Base_Type (Id)\n            and then Comes_From_Source (Full_View (Id))\n            and then Present (Full_View (Id))\n@@ -1540,7 +1628,6 @@ package body Sem_Ch7 is\n       --  Next make other declarations in the private part visible as well\n \n       Id := First_Private_Entity (P);\n-\n       while Present (Id) loop\n          Install_Package_Entity (Id);\n          Set_Is_Hidden (Id, False);\n@@ -1572,7 +1659,6 @@ package body Sem_Ch7 is\n       end if;\n \n       Id := First_Entity (P);\n-\n       while Present (Id) and then Id /= Last_Entity loop\n          Install_Package_Entity (Id);\n          Next_Entity (Id);\n@@ -1747,7 +1833,7 @@ package body Sem_Ch7 is\n                                                                       (Full));\n          Set_Is_Volatile        (Priv, Is_Volatile        (Full));\n          Set_Treat_As_Volatile  (Priv, Treat_As_Volatile  (Full));\n-         Set_Is_Ada_2005        (Priv, Is_Ada_2005        (Full));\n+         Set_Is_Ada_2005_Only   (Priv, Is_Ada_2005_Only   (Full));\n \n          if Is_Unchecked_Union (Full) then\n             Set_Is_Unchecked_Union (Base_Type (Priv));\n@@ -1826,7 +1912,6 @@ package body Sem_Ch7 is\n \n    begin\n       Id := First_Entity (P);\n-\n       while Present (Id) and then Id /= First_Private_Entity (P) loop\n          if Debug_Flag_E then\n             Write_Str (\"unlinking visible entity \");\n@@ -1880,6 +1965,7 @@ package body Sem_Ch7 is\n \n          if Is_Tagged_Type (Id) and then Ekind (Id) = E_Record_Type then\n             Check_Abstract_Overriding (Id);\n+            Check_Conventions (Id);\n          end if;\n \n          if (Ekind (Id) = E_Private_Type\n@@ -1919,7 +2005,7 @@ package body Sem_Ch7 is\n \n                if Is_Limited_Type (Etype (Id)) then\n                   Error_Msg_N\n-                    (\"\\else remove keyword CONSTANT from declaration\",\n+                    (\"\\if variable intended, remove CONSTANT from declaration\",\n                     Parent (Id));\n                end if;\n \n@@ -1930,7 +2016,7 @@ package body Sem_Ch7 is\n \n                if Is_Limited_Type (Etype (Id)) then\n                   Error_Msg_N\n-                    (\"\\else remove keyword CONSTANT from declaration\",\n+                    (\"\\if variable intended, remove CONSTANT from declaration\",\n                     Parent (Id));\n                end if;\n             end if;\n@@ -1961,6 +2047,7 @@ package body Sem_Ch7 is\n \n          if Is_Tagged_Type (Id) and then Ekind (Id) = E_Record_Type then\n             Check_Abstract_Overriding (Id);\n+            Check_Conventions (Id);\n          end if;\n \n          Set_Is_Immediately_Visible (Id, False);\n@@ -2092,7 +2179,6 @@ package body Sem_Ch7 is\n       then\n          declare\n             G_P : constant Entity_Id := Generic_Parent (Parent (P));\n-\n          begin\n             if Has_Pragma_Elaborate_Body (G_P) then\n                return True;"}]}