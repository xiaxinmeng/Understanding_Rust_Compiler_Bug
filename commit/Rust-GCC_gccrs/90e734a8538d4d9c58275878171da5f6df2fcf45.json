{"sha": "90e734a8538d4d9c58275878171da5f6df2fcf45", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTBlNzM0YTg1MzhkNGQ5YzU4Mjc1ODc4MTcxZGE1ZjZkZjJmY2Y0NQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1999-03-27T01:14:32Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1999-03-27T01:14:32Z"}, "message": "call.c (build_field_call): Unify 'this' and non-'this' cases.\n\n\t* call.c (build_field_call): Unify 'this' and non-'this' cases.\n\t* typeck.c (build_indirect_ref): Check for 'this' sooner.\n\nFrom-SVN: r26012", "tree": {"sha": "4086e96a602efdf3a10ed4ec0732e7e00e382c80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4086e96a602efdf3a10ed4ec0732e7e00e382c80"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90e734a8538d4d9c58275878171da5f6df2fcf45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90e734a8538d4d9c58275878171da5f6df2fcf45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90e734a8538d4d9c58275878171da5f6df2fcf45", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90e734a8538d4d9c58275878171da5f6df2fcf45/comments", "author": null, "committer": null, "parents": [{"sha": "92a217ad7421218d9dcebac9bbb8b9782bea5eb9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92a217ad7421218d9dcebac9bbb8b9782bea5eb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92a217ad7421218d9dcebac9bbb8b9782bea5eb9"}], "stats": {"total": 112, "additions": 33, "deletions": 79}, "files": [{"sha": "0138c8461b47fc6c40db32aaad5fa19533c70456", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e734a8538d4d9c58275878171da5f6df2fcf45/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e734a8538d4d9c58275878171da5f6df2fcf45/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=90e734a8538d4d9c58275878171da5f6df2fcf45", "patch": "@@ -1,3 +1,9 @@\n+1999-03-27  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* call.c (build_field_call): Unify 'this' and non-'this' cases.\n+\n+\t* typeck.c (build_indirect_ref): Check for 'this' sooner.\n+\n Fri Mar 26 10:20:34 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* call.c (op_error): Const-ify a char*."}, {"sha": "9bc349e7999ffb62847071a32c27df95ab50d5c7", "filename": "gcc/cp/call.c", "status": "modified", "additions": 24, "deletions": 76, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e734a8538d4d9c58275878171da5f6df2fcf45/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e734a8538d4d9c58275878171da5f6df2fcf45/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=90e734a8538d4d9c58275878171da5f6df2fcf45", "patch": "@@ -128,92 +128,40 @@ build_field_call (basetype_path, instance_ptr, name, parms)\n   if (name == ctor_identifier || name == dtor_identifier)\n     return NULL_TREE;\n \n-  if (instance_ptr == current_class_ptr)\n-    {\n-      /* Check to see if we really have a reference to an instance variable\n-\t with `operator()()' overloaded.  */\n-      field = IDENTIFIER_CLASS_VALUE (name);\n-\n-      if (field == NULL_TREE)\n-\t{\n-\t  cp_error (\"`this' has no member named `%D'\", name);\n-\t  return error_mark_node;\n-\t}\n-\n-      if (TREE_CODE (field) == FIELD_DECL || TREE_CODE (field) == VAR_DECL)\n-\t{\n-\t  /* If it's a field, try overloading operator (),\n-\t     or calling if the field is a pointer-to-function.  */\n-\t  instance = build_component_ref_1 (current_class_ref, field, 0);\n-\t  if (instance == error_mark_node)\n-\t    return error_mark_node;\n-\n-\t  if (TYPE_LANG_SPECIFIC (TREE_TYPE (instance)))\n-\t    return build_opfncall (CALL_EXPR, LOOKUP_NORMAL, instance, parms, NULL_TREE);\n-\n-\t  if (TREE_CODE (TREE_TYPE (instance)) == POINTER_TYPE)\n-\t    {\n-\t      if (TREE_CODE (TREE_TYPE (TREE_TYPE (instance))) == FUNCTION_TYPE)\n-\t\treturn build_function_call (instance, parms);\n-\t      else if (TREE_CODE (TREE_TYPE (TREE_TYPE (instance))) == METHOD_TYPE)\n-\t\treturn build_function_call (instance, expr_tree_cons (NULL_TREE, current_class_ptr, parms));\n-\t    }\n-\t}\n-      return NULL_TREE;\n-    }\n+  /* Speed up the common case.  */\n+  if (instance_ptr == current_class_ptr\n+      && IDENTIFIER_CLASS_VALUE (name) == NULL_TREE)\n+    return NULL_TREE;\n \n-  /* Check to see if this is not really a reference to an instance variable\n-     with `operator()()' overloaded.  */\n   field = lookup_field (basetype_path, name, 1, 0);\n \n-  /* This can happen if the reference was ambiguous or for access\n-     violations.  */\n-  if (field == error_mark_node)\n-    return error_mark_node;\n+  if (field == error_mark_node || field == NULL_TREE)\n+    return field;\n \n-  if (field && (TREE_CODE (field) == FIELD_DECL ||\n-\t\tTREE_CODE (field) == VAR_DECL))\n+  if (TREE_CODE (field) == FIELD_DECL || TREE_CODE (field) == VAR_DECL)\n     {\n-      tree basetype;\n-      tree ftype = TREE_TYPE (field);\n+      /* If it's a field, try overloading operator (),\n+\t or calling if the field is a pointer-to-function.  */\n+      instance = build_indirect_ref (instance_ptr, NULL_PTR);\n+      instance = build_component_ref_1 (instance, field, 0);\n \n-      if (TREE_CODE (ftype) == REFERENCE_TYPE)\n-\tftype = TREE_TYPE (ftype);\n+      if (instance == error_mark_node)\n+\treturn error_mark_node;\n \n-      if (TYPE_LANG_SPECIFIC (ftype))\n-\t{\n-\t  /* Make the next search for this field very short.  */\n-\t  basetype = DECL_FIELD_CONTEXT (field);\n-\t  instance_ptr = convert_pointer_to (basetype, instance_ptr);\n-\n-\t  instance = build_indirect_ref (instance_ptr, NULL_PTR);\n-\t  return build_opfncall (CALL_EXPR, LOOKUP_NORMAL,\n-\t\t\t\t build_component_ref_1 (instance, field, 0),\n-\t\t\t\t parms, NULL_TREE);\n-\t}\n-      if (TREE_CODE (ftype) == POINTER_TYPE)\n-\t{\n-\t  if (TREE_CODE (TREE_TYPE (ftype)) == FUNCTION_TYPE\n-\t      || TREE_CODE (TREE_TYPE (ftype)) == METHOD_TYPE)\n-\t    {\n-\t      /* This is a member which is a pointer to function.  */\n-\t      tree ref\n-\t\t= build_component_ref_1 (build_indirect_ref (instance_ptr,\n-\t\t\t\t\t\t\t     NULL_PTR),\n-\t\t\t\t\t field, LOOKUP_COMPLAIN);\n-\t      if (ref == error_mark_node)\n-\t\treturn error_mark_node;\n-\t      return build_function_call (ref, parms);\n-\t    }\n-\t}\n-      else if (TREE_CODE (ftype) == METHOD_TYPE)\n+      if (IS_AGGR_TYPE (TREE_TYPE (instance)))\n+\treturn build_opfncall (CALL_EXPR, LOOKUP_NORMAL,\n+\t\t\t       instance, parms, NULL_TREE);\n+      else if (TREE_CODE (TREE_TYPE (instance)) == POINTER_TYPE)\n \t{\n-\t  error (\"invalid call via pointer-to-member function\");\n-\t  return error_mark_node;\n+\t  if (TREE_CODE (TREE_TYPE (TREE_TYPE (instance))) == FUNCTION_TYPE)\n+\t    return build_function_call (instance, parms);\n+\t  else if (TREE_CODE (TREE_TYPE (TREE_TYPE (instance)))\n+\t\t   == METHOD_TYPE)\n+\t    return build_function_call\n+\t      (instance, expr_tree_cons (NULL_TREE, instance_ptr, parms));\n \t}\n-      else\n-\treturn NULL_TREE;\n     }\n+\n   return NULL_TREE;\n }\n "}, {"sha": "2012546f6f4cdcb79ddd4b536e710bfb7eab7997", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e734a8538d4d9c58275878171da5f6df2fcf45/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e734a8538d4d9c58275878171da5f6df2fcf45/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=90e734a8538d4d9c58275878171da5f6df2fcf45", "patch": "@@ -2345,13 +2345,13 @@ build_indirect_ref (ptr, errorstring)\n   if (ptr == error_mark_node)\n     return error_mark_node;\n \n+  if (ptr == current_class_ptr)\n+    return current_class_ref;\n+\n   pointer = (TREE_CODE (TREE_TYPE (ptr)) == REFERENCE_TYPE\n \t     ? ptr : default_conversion (ptr));\n   type = TREE_TYPE (pointer);\n \n-  if (ptr == current_class_ptr)\n-    return current_class_ref;\n-\n   if (TYPE_PTR_P (type) || TREE_CODE (type) == REFERENCE_TYPE)\n     {\n       /* [expr.unary.op]"}]}