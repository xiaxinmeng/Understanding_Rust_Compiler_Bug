{"sha": "40b86e5f2cf069832e23043992dedb0bf8e0dcd6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDBiODZlNWYyY2YwNjk4MzJlMjMwNDM5OTJkZWRiMGJmOGUwZGNkNg==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2007-02-12T23:52:39Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2007-02-12T23:52:39Z"}, "message": "Collections.java (UnmodifiableMap.toArray): Imported changes from Classpath.\n\nlibjava/classpath\n\t* java/util/Collections.java (UnmodifiableMap.toArray): Imported\n\tchanges from Classpath.\nlibjava\n\t* sources.am, Makefile.in: Rebuilt.\n\t* java/lang/Socket.java: Removed override.\n\t* java/lang/DatagramSocket.java: Removed override.\n\t* gnu/java/net/PlainSocketImpl.java (localSocketAddress): New\n\tfield.\n\t(getLocalAddress): New method.\n\t* gnu/java/net/PlainDatagramSocketImpl.java\n\t(PlainDatagramSocketImpl): Throws IOException.\n\t* gnu/java/net/natPlainSocketImplPosix.cc (write): Remove\n\t'sizeof'.\n\t(read): Likewise.\n\nFrom-SVN: r121866", "tree": {"sha": "e330b8e9a136b5340488dc4c338504cc6b870e5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e330b8e9a136b5340488dc4c338504cc6b870e5b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40b86e5f2cf069832e23043992dedb0bf8e0dcd6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40b86e5f2cf069832e23043992dedb0bf8e0dcd6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40b86e5f2cf069832e23043992dedb0bf8e0dcd6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40b86e5f2cf069832e23043992dedb0bf8e0dcd6/comments", "author": null, "committer": null, "parents": [{"sha": "e8c30b5f9a11fed775dddf8c15706ae251fdd2d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8c30b5f9a11fed775dddf8c15706ae251fdd2d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8c30b5f9a11fed775dddf8c15706ae251fdd2d5"}], "stats": {"total": 2336, "additions": 84, "deletions": 2252}, "files": [{"sha": "b76d6e7c21463f115d9fcaf7868a046078dfd929", "filename": "libjava/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40b86e5f2cf069832e23043992dedb0bf8e0dcd6/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40b86e5f2cf069832e23043992dedb0bf8e0dcd6/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=40b86e5f2cf069832e23043992dedb0bf8e0dcd6", "patch": "@@ -1,3 +1,17 @@\n+2007-02-12  Tom Tromey  <tromey@redhat.com>\n+\n+\t* sources.am, Makefile.in: Rebuilt.\n+\t* java/lang/Socket.java: Removed override.\n+\t* java/lang/DatagramSocket.java: Removed override.\n+\t* gnu/java/net/PlainSocketImpl.java (localSocketAddress): New\n+\tfield.\n+\t(getLocalAddress): New method.\n+\t* gnu/java/net/PlainDatagramSocketImpl.java\n+\t(PlainDatagramSocketImpl): Throws IOException.\n+\t* gnu/java/net/natPlainSocketImplPosix.cc (write): Remove\n+\t'sizeof'.\n+\t(read): Likewise.\n+\n 2007-02-09  Jakub Jelinek  <jakub@redhat.com>\n \n \t* java/util/VMTimeZone.java: Rewrite to handle both the old"}, {"sha": "5411f07d6cc541f56c59b22502d2f888f0ae2df9", "filename": "libjava/Makefile.in", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40b86e5f2cf069832e23043992dedb0bf8e0dcd6/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40b86e5f2cf069832e23043992dedb0bf8e0dcd6/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=40b86e5f2cf069832e23043992dedb0bf8e0dcd6", "patch": "@@ -1209,6 +1209,7 @@ classpath/gnu/classpath/jdwp/exception/InvalidClassLoaderException.java \\\n classpath/gnu/classpath/jdwp/exception/InvalidCountException.java \\\n classpath/gnu/classpath/jdwp/exception/InvalidEventTypeException.java \\\n classpath/gnu/classpath/jdwp/exception/InvalidFieldException.java \\\n+classpath/gnu/classpath/jdwp/exception/InvalidFrameException.java \\\n classpath/gnu/classpath/jdwp/exception/InvalidLocationException.java \\\n classpath/gnu/classpath/jdwp/exception/InvalidMethodException.java \\\n classpath/gnu/classpath/jdwp/exception/InvalidObjectException.java \\\n@@ -4392,7 +4393,7 @@ classpath/java/net/ConnectException.java \\\n classpath/java/net/ContentHandler.java \\\n classpath/java/net/ContentHandlerFactory.java \\\n classpath/java/net/DatagramPacket.java \\\n-java/net/DatagramSocket.java \\\n+classpath/java/net/DatagramSocket.java \\\n classpath/java/net/DatagramSocketImpl.java \\\n classpath/java/net/DatagramSocketImplFactory.java \\\n classpath/java/net/FileNameMap.java \\\n@@ -4415,7 +4416,7 @@ classpath/java/net/Proxy.java \\\n classpath/java/net/ProxySelector.java \\\n classpath/java/net/ResolverCache.java \\\n classpath/java/net/ServerSocket.java \\\n-java/net/Socket.java \\\n+classpath/java/net/Socket.java \\\n classpath/java/net/SocketAddress.java \\\n classpath/java/net/SocketException.java \\\n classpath/java/net/SocketImpl.java \\\n@@ -9973,7 +9974,7 @@ java/lang/Class.lo: classpath/lib/java/lang/Class.class\n \n gnu-CORBA.lo: $(gnu_CORBA_source_files)\n \t@find $(srcdir)/classpath/lib/gnu/CORBA -name '*.class' > gnu-CORBA.list\n-\t$(LTGCJCOMPILE) -fjni -findirect-dispatch -fno-indirect-classes -c -o gnu-CORBA.lo @gnu-CORBA.list\n+\t$(LTGCJCOMPILE) -fsource-filename=$(here)/classpath/lib/classes -fjni -findirect-dispatch -fno-indirect-classes -c -o gnu-CORBA.lo @gnu-CORBA.list\n \t@rm -f gnu-CORBA.list\n \n gnu/awt.list: $(gnu_awt_source_files)\n@@ -10122,7 +10123,7 @@ gnu/java/awt/dnd.list: $(gnu_java_awt_dnd_source_files)\n \n gnu-java-awt-dnd-peer-gtk.lo: $(gnu_java_awt_dnd_peer_gtk_source_files)\n \t@find $(srcdir)/classpath/lib/gnu/java/awt/dnd/peer/gtk -name '*.class' > gnu-java-awt-dnd-peer-gtk.list\n-\t$(LTGCJCOMPILE) -fjni -findirect-dispatch -fno-indirect-classes -c -o gnu-java-awt-dnd-peer-gtk.lo @gnu-java-awt-dnd-peer-gtk.list\n+\t$(LTGCJCOMPILE) -fsource-filename=$(here)/classpath/lib/classes -fjni -findirect-dispatch -fno-indirect-classes -c -o gnu-java-awt-dnd-peer-gtk.lo @gnu-java-awt-dnd-peer-gtk.list\n \t@rm -f gnu-java-awt-dnd-peer-gtk.list\n \n gnu/java/awt/font.list: $(gnu_java_awt_font_source_files)\n@@ -10169,7 +10170,7 @@ gnu/java/awt/peer.list: $(gnu_java_awt_peer_source_files)\n \n gnu-java-awt-peer-gtk.lo: $(gnu_java_awt_peer_gtk_source_files)\n \t@find $(srcdir)/classpath/lib/gnu/java/awt/peer/gtk -name '*.class' > gnu-java-awt-peer-gtk.list\n-\t$(LTGCJCOMPILE) -fjni -findirect-dispatch -fno-indirect-classes -c -o gnu-java-awt-peer-gtk.lo @gnu-java-awt-peer-gtk.list\n+\t$(LTGCJCOMPILE) -fsource-filename=$(here)/classpath/lib/classes -fjni -findirect-dispatch -fno-indirect-classes -c -o gnu-java-awt-peer-gtk.lo @gnu-java-awt-peer-gtk.list\n \t@rm -f gnu-java-awt-peer-gtk.list\n \n gnu/java/awt/peer/headless.list: $(gnu_java_awt_peer_headless_source_files)\n@@ -10180,17 +10181,17 @@ gnu/java/awt/peer/headless.list: $(gnu_java_awt_peer_headless_source_files)\n \n gnu-java-awt-peer-qt.lo: $(gnu_java_awt_peer_qt_source_files)\n \t@find $(srcdir)/classpath/lib/gnu/java/awt/peer/qt -name '*.class' > gnu-java-awt-peer-qt.list\n-\t$(LTGCJCOMPILE) -fjni -findirect-dispatch -fno-indirect-classes -c -o gnu-java-awt-peer-qt.lo @gnu-java-awt-peer-qt.list\n+\t$(LTGCJCOMPILE) -fsource-filename=$(here)/classpath/lib/classes -fjni -findirect-dispatch -fno-indirect-classes -c -o gnu-java-awt-peer-qt.lo @gnu-java-awt-peer-qt.list\n \t@rm -f gnu-java-awt-peer-qt.list\n \n gnu-java-awt-peer-swing.lo: $(gnu_java_awt_peer_swing_source_files)\n \t@find $(srcdir)/classpath/lib/gnu/java/awt/peer/swing -name '*.class' > gnu-java-awt-peer-swing.list\n-\t$(LTGCJCOMPILE) -fjni -findirect-dispatch -fno-indirect-classes -c -o gnu-java-awt-peer-swing.lo @gnu-java-awt-peer-swing.list\n+\t$(LTGCJCOMPILE) -fsource-filename=$(here)/classpath/lib/classes -fjni -findirect-dispatch -fno-indirect-classes -c -o gnu-java-awt-peer-swing.lo @gnu-java-awt-peer-swing.list\n \t@rm -f gnu-java-awt-peer-swing.list\n \n gnu-java-awt-peer-x.lo: $(gnu_java_awt_peer_x_source_files)\n \t@find $(srcdir)/classpath/lib/gnu/java/awt/peer/x -name '*.class' > gnu-java-awt-peer-x.list\n-\t$(LTGCJCOMPILE) -fjni -findirect-dispatch -fno-indirect-classes -c -o gnu-java-awt-peer-x.lo @gnu-java-awt-peer-x.list\n+\t$(LTGCJCOMPILE) -fsource-filename=$(here)/classpath/lib/classes -fjni -findirect-dispatch -fno-indirect-classes -c -o gnu-java-awt-peer-x.lo @gnu-java-awt-peer-x.list\n \t@rm -f gnu-java-awt-peer-x.list\n \n gnu/java/awt/print.list: $(gnu_java_awt_print_source_files)\n@@ -10201,7 +10202,7 @@ gnu/java/awt/print.list: $(gnu_java_awt_print_source_files)\n \n gnu-java-beans.lo: $(gnu_java_beans_source_files)\n \t@find $(srcdir)/classpath/lib/gnu/java/beans -name '*.class' > gnu-java-beans.list\n-\t$(LTGCJCOMPILE) -fjni -findirect-dispatch -fno-indirect-classes -c -o gnu-java-beans.lo @gnu-java-beans.list\n+\t$(LTGCJCOMPILE) -fsource-filename=$(here)/classpath/lib/classes -fjni -findirect-dispatch -fno-indirect-classes -c -o gnu-java-beans.lo @gnu-java-beans.list\n \t@rm -f gnu-java-beans.list\n \n gnu/java/io.list: $(gnu_java_io_source_files)\n@@ -10494,7 +10495,7 @@ gnu/java/util/prefs.list: $(gnu_java_util_prefs_source_files)\n \n gnu-java-util-prefs-gconf.lo: $(gnu_java_util_prefs_gconf_source_files)\n \t@find $(srcdir)/classpath/lib/gnu/java/util/prefs/gconf -name '*.class' > gnu-java-util-prefs-gconf.list\n-\t$(LTGCJCOMPILE) -fjni -findirect-dispatch -fno-indirect-classes -c -o gnu-java-util-prefs-gconf.lo @gnu-java-util-prefs-gconf.list\n+\t$(LTGCJCOMPILE) -fsource-filename=$(here)/classpath/lib/classes -fjni -findirect-dispatch -fno-indirect-classes -c -o gnu-java-util-prefs-gconf.lo @gnu-java-util-prefs-gconf.list\n \t@rm -f gnu-java-util-prefs-gconf.list\n \n gnu/java/util/regex.list: $(gnu_java_util_regex_source_files)\n@@ -10775,7 +10776,7 @@ gnu/javax/print/ipp/attribute/supported.list: $(gnu_javax_print_ipp_attribute_su\n \n gnu-javax-rmi.lo: $(gnu_javax_rmi_source_files)\n \t@find $(srcdir)/classpath/lib/gnu/javax/rmi -name '*.class' > gnu-javax-rmi.list\n-\t$(LTGCJCOMPILE) -fjni -findirect-dispatch -fno-indirect-classes -c -o gnu-javax-rmi.lo @gnu-javax-rmi.list\n+\t$(LTGCJCOMPILE) -fsource-filename=$(here)/classpath/lib/classes -fjni -findirect-dispatch -fno-indirect-classes -c -o gnu-javax-rmi.lo @gnu-javax-rmi.list\n \t@rm -f gnu-javax-rmi.list\n \n gnu/javax/security/auth.list: $(gnu_javax_security_auth_source_files)\n@@ -10798,7 +10799,7 @@ gnu/javax/security/auth/login.list: $(gnu_javax_security_auth_login_source_files\n \n gnu-javax-sound-midi.lo: $(gnu_javax_sound_midi_source_files)\n \t@find $(srcdir)/classpath/lib/gnu/javax/sound/midi -name '*.class' > gnu-javax-sound-midi.list\n-\t$(LTGCJCOMPILE) -fjni -findirect-dispatch -fno-indirect-classes -c -o gnu-javax-sound-midi.lo @gnu-javax-sound-midi.list\n+\t$(LTGCJCOMPILE) -fsource-filename=$(here)/classpath/lib/classes -fjni -findirect-dispatch -fno-indirect-classes -c -o gnu-javax-sound-midi.lo @gnu-javax-sound-midi.list\n \t@rm -f gnu-javax-sound-midi.list\n \n gnu/javax/sound/sampled/AU.list: $(gnu_javax_sound_sampled_AU_source_files)\n@@ -10899,47 +10900,47 @@ gnu/javax/swing/tree.list: $(gnu_javax_swing_tree_source_files)\n \n gnu-xml-aelfred2.lo: $(gnu_xml_aelfred2_source_files)\n \t@find $(srcdir)/classpath/lib/gnu/xml/aelfred2 -name '*.class' > gnu-xml-aelfred2.list\n-\t$(LTGCJCOMPILE) -fjni -findirect-dispatch -fno-indirect-classes -c -o gnu-xml-aelfred2.lo @gnu-xml-aelfred2.list\n+\t$(LTGCJCOMPILE) -fsource-filename=$(here)/classpath/lib/classes -fjni -findirect-dispatch -fno-indirect-classes -c -o gnu-xml-aelfred2.lo @gnu-xml-aelfred2.list\n \t@rm -f gnu-xml-aelfred2.list\n \n gnu-xml-dom.lo: $(gnu_xml_dom_source_files)\n \t@find $(srcdir)/classpath/lib/gnu/xml/dom -name '*.class' > gnu-xml-dom.list\n-\t$(LTGCJCOMPILE) -fjni -findirect-dispatch -fno-indirect-classes -c -o gnu-xml-dom.lo @gnu-xml-dom.list\n+\t$(LTGCJCOMPILE) -fsource-filename=$(here)/classpath/lib/classes -fjni -findirect-dispatch -fno-indirect-classes -c -o gnu-xml-dom.lo @gnu-xml-dom.list\n \t@rm -f gnu-xml-dom.list\n \n gnu-xml-libxmlj.lo: $(gnu_xml_libxmlj_source_files)\n \t@find $(srcdir)/classpath/lib/gnu/xml/libxmlj -name '*.class' > gnu-xml-libxmlj.list\n-\t$(LTGCJCOMPILE) -fjni -findirect-dispatch -fno-indirect-classes -c -o gnu-xml-libxmlj.lo @gnu-xml-libxmlj.list\n+\t$(LTGCJCOMPILE) -fsource-filename=$(here)/classpath/lib/classes -fjni -findirect-dispatch -fno-indirect-classes -c -o gnu-xml-libxmlj.lo @gnu-xml-libxmlj.list\n \t@rm -f gnu-xml-libxmlj.list\n \n gnu-xml-pipeline.lo: $(gnu_xml_pipeline_source_files)\n \t@find $(srcdir)/classpath/lib/gnu/xml/pipeline -name '*.class' > gnu-xml-pipeline.list\n-\t$(LTGCJCOMPILE) -fjni -findirect-dispatch -fno-indirect-classes -c -o gnu-xml-pipeline.lo @gnu-xml-pipeline.list\n+\t$(LTGCJCOMPILE) -fsource-filename=$(here)/classpath/lib/classes -fjni -findirect-dispatch -fno-indirect-classes -c -o gnu-xml-pipeline.lo @gnu-xml-pipeline.list\n \t@rm -f gnu-xml-pipeline.list\n \n gnu-xml-stream.lo: $(gnu_xml_stream_source_files)\n \t@find $(srcdir)/classpath/lib/gnu/xml/stream -name '*.class' > gnu-xml-stream.list\n-\t$(LTGCJCOMPILE) -fjni -findirect-dispatch -fno-indirect-classes -c -o gnu-xml-stream.lo @gnu-xml-stream.list\n+\t$(LTGCJCOMPILE) -fsource-filename=$(here)/classpath/lib/classes -fjni -findirect-dispatch -fno-indirect-classes -c -o gnu-xml-stream.lo @gnu-xml-stream.list\n \t@rm -f gnu-xml-stream.list\n \n gnu-xml-transform.lo: $(gnu_xml_transform_source_files)\n \t@find $(srcdir)/classpath/lib/gnu/xml/transform -name '*.class' > gnu-xml-transform.list\n-\t$(LTGCJCOMPILE) -fjni -findirect-dispatch -fno-indirect-classes -c -o gnu-xml-transform.lo @gnu-xml-transform.list\n+\t$(LTGCJCOMPILE) -fsource-filename=$(here)/classpath/lib/classes -fjni -findirect-dispatch -fno-indirect-classes -c -o gnu-xml-transform.lo @gnu-xml-transform.list\n \t@rm -f gnu-xml-transform.list\n \n gnu-xml-util.lo: $(gnu_xml_util_source_files)\n \t@find $(srcdir)/classpath/lib/gnu/xml/util -name '*.class' > gnu-xml-util.list\n-\t$(LTGCJCOMPILE) -fjni -findirect-dispatch -fno-indirect-classes -c -o gnu-xml-util.lo @gnu-xml-util.list\n+\t$(LTGCJCOMPILE) -fsource-filename=$(here)/classpath/lib/classes -fjni -findirect-dispatch -fno-indirect-classes -c -o gnu-xml-util.lo @gnu-xml-util.list\n \t@rm -f gnu-xml-util.list\n \n gnu-xml-validation.lo: $(gnu_xml_validation_source_files)\n \t@find $(srcdir)/classpath/lib/gnu/xml/validation -name '*.class' > gnu-xml-validation.list\n-\t$(LTGCJCOMPILE) -fjni -findirect-dispatch -fno-indirect-classes -c -o gnu-xml-validation.lo @gnu-xml-validation.list\n+\t$(LTGCJCOMPILE) -fsource-filename=$(here)/classpath/lib/classes -fjni -findirect-dispatch -fno-indirect-classes -c -o gnu-xml-validation.lo @gnu-xml-validation.list\n \t@rm -f gnu-xml-validation.list\n \n gnu-xml-xpath.lo: $(gnu_xml_xpath_source_files)\n \t@find $(srcdir)/classpath/lib/gnu/xml/xpath -name '*.class' > gnu-xml-xpath.list\n-\t$(LTGCJCOMPILE) -fjni -findirect-dispatch -fno-indirect-classes -c -o gnu-xml-xpath.lo @gnu-xml-xpath.list\n+\t$(LTGCJCOMPILE) -fsource-filename=$(here)/classpath/lib/classes -fjni -findirect-dispatch -fno-indirect-classes -c -o gnu-xml-xpath.lo @gnu-xml-xpath.list\n \t@rm -f gnu-xml-xpath.list\n \n java/applet.list: $(java_applet_source_files)\n@@ -11280,7 +11281,7 @@ javax/crypto/spec.list: $(javax_crypto_spec_source_files)\n \n javax-imageio.lo: $(javax_imageio_source_files)\n \t@find $(srcdir)/classpath/lib/javax/imageio -name '*.class' > javax-imageio.list\n-\t$(LTGCJCOMPILE) -fjni -findirect-dispatch -fno-indirect-classes -c -o javax-imageio.lo @javax-imageio.list\n+\t$(LTGCJCOMPILE) -fsource-filename=$(here)/classpath/lib/classes -fjni -findirect-dispatch -fno-indirect-classes -c -o javax-imageio.lo @javax-imageio.list\n \t@rm -f javax-imageio.list\n \n javax/management.list: $(javax_management_source_files)\n@@ -11369,7 +11370,7 @@ javax/print/event.list: $(javax_print_event_source_files)\n \n javax-rmi.lo: $(javax_rmi_source_files)\n \t@find $(srcdir)/classpath/lib/javax/rmi -name '*.class' > javax-rmi.list\n-\t$(LTGCJCOMPILE) -fjni -findirect-dispatch -fno-indirect-classes -c -o javax-rmi.lo @javax-rmi.list\n+\t$(LTGCJCOMPILE) -fsource-filename=$(here)/classpath/lib/classes -fjni -findirect-dispatch -fno-indirect-classes -c -o javax-rmi.lo @javax-rmi.list\n \t@rm -f javax-rmi.list\n \n javax/security/auth.list: $(javax_security_auth_source_files)\n@@ -11566,7 +11567,7 @@ javax/transaction/xa.list: $(javax_transaction_xa_source_files)\n \n javax-xml.lo: $(javax_xml_source_files)\n \t@find $(srcdir)/classpath/lib/javax/xml -name '*.class' > javax-xml.list\n-\t$(LTGCJCOMPILE) -fjni -findirect-dispatch -fno-indirect-classes -c -o javax-xml.lo @javax-xml.list\n+\t$(LTGCJCOMPILE) -fsource-filename=$(here)/classpath/lib/classes -fjni -findirect-dispatch -fno-indirect-classes -c -o javax-xml.lo @javax-xml.list\n \t@rm -f javax-xml.list\n \n org/ietf/jgss.list: $(org_ietf_jgss_source_files)\n@@ -11577,22 +11578,22 @@ org/ietf/jgss.list: $(org_ietf_jgss_source_files)\n \n org-omg.lo: $(org_omg_source_files)\n \t@find $(srcdir)/classpath/lib/org/omg -name '*.class' > org-omg.list\n-\t$(LTGCJCOMPILE) -fjni -findirect-dispatch -fno-indirect-classes -c -o org-omg.lo @org-omg.list\n+\t$(LTGCJCOMPILE) -fsource-filename=$(here)/classpath/lib/classes -fjni -findirect-dispatch -fno-indirect-classes -c -o org-omg.lo @org-omg.list\n \t@rm -f org-omg.list\n \n org-relaxng.lo: $(org_relaxng_source_files)\n \t@find $(srcdir)/classpath/lib/org/relaxng -name '*.class' > org-relaxng.list\n-\t$(LTGCJCOMPILE) -fjni -findirect-dispatch -fno-indirect-classes -c -o org-relaxng.lo @org-relaxng.list\n+\t$(LTGCJCOMPILE) -fsource-filename=$(here)/classpath/lib/classes -fjni -findirect-dispatch -fno-indirect-classes -c -o org-relaxng.lo @org-relaxng.list\n \t@rm -f org-relaxng.list\n \n org-w3c.lo: $(org_w3c_source_files)\n \t@find $(srcdir)/classpath/lib/org/w3c -name '*.class' > org-w3c.list\n-\t$(LTGCJCOMPILE) -fjni -findirect-dispatch -fno-indirect-classes -c -o org-w3c.lo @org-w3c.list\n+\t$(LTGCJCOMPILE) -fsource-filename=$(here)/classpath/lib/classes -fjni -findirect-dispatch -fno-indirect-classes -c -o org-w3c.lo @org-w3c.list\n \t@rm -f org-w3c.list\n \n org-xml.lo: $(org_xml_source_files)\n \t@find $(srcdir)/classpath/lib/org/xml -name '*.class' > org-xml.list\n-\t$(LTGCJCOMPILE) -fjni -findirect-dispatch -fno-indirect-classes -c -o org-xml.lo @org-xml.list\n+\t$(LTGCJCOMPILE) -fsource-filename=$(here)/classpath/lib/classes -fjni -findirect-dispatch -fno-indirect-classes -c -o org-xml.lo @org-xml.list\n \t@rm -f org-xml.list\n \n sun/misc.list: $(sun_misc_source_files)"}, {"sha": "e50d8f7974753cf48b11b031a078aa2ceb7d86a5", "filename": "libjava/classpath/ChangeLog.gcj", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40b86e5f2cf069832e23043992dedb0bf8e0dcd6/libjava%2Fclasspath%2FChangeLog.gcj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40b86e5f2cf069832e23043992dedb0bf8e0dcd6/libjava%2Fclasspath%2FChangeLog.gcj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2FChangeLog.gcj?ref=40b86e5f2cf069832e23043992dedb0bf8e0dcd6", "patch": "@@ -1,3 +1,8 @@\n+2007-02-12  Tom Tromey  <tromey@redhat.com>\n+\n+\t* java/util/Collections.java (UnmodifiableMap.toArray): Imported\n+\tchanges from Classpath.\n+\n 2007-02-09  Gary Benson  <gbenson@redhat.com>\n \n \t* javax/management/ObjectName.java"}, {"sha": "77ff6ed8fa039bccf58b6e6bee68005f828e8d37", "filename": "libjava/classpath/java/util/Collections.java", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40b86e5f2cf069832e23043992dedb0bf8e0dcd6/libjava%2Fclasspath%2Fjava%2Futil%2FCollections.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40b86e5f2cf069832e23043992dedb0bf8e0dcd6/libjava%2Fclasspath%2Fjava%2Futil%2FCollections.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Futil%2FCollections.java?ref=40b86e5f2cf069832e23043992dedb0bf8e0dcd6", "patch": "@@ -5115,29 +5115,29 @@ public Map.Entry<K,V> next()\n       // Map.Entry\n       public Map.Entry<K,V>[] toArray()\n       {\n-        Map.Entry<K,V>[] mapEntryResult = (Map.Entry<K,V>[]) super.toArray();\n+        Object[] mapEntryResult = super.toArray();\n         UnmodifiableMapEntry<K,V> result[] = null;\n   \n         if (mapEntryResult != null)\n           {\n             result = (UnmodifiableMapEntry<K,V>[])\n \t      new UnmodifiableMapEntry[mapEntryResult.length];\n             for (int i = 0; i < mapEntryResult.length; ++i)\n-\t      result[i] = new UnmodifiableMapEntry(mapEntryResult[i]);\n+\t      result[i] = new UnmodifiableMapEntry<K,V>((Map.Entry<K,V>)mapEntryResult[i]);\n \t  }\n         return result;\n       }\n   \n       // The array returned is an array of UnmodifiableMapEntry instead of\n       // Map.Entry\n-      public Map.Entry<K,V>[] toArray(Map.Entry<K,V>[] array)\n+      public <S> S[] toArray(S[] array)\n       {\n-        super.toArray(array);\n+        S[] result = super.toArray(array);\n   \n-        if (array != null)\n-\t  for (int i = 0; i < array.length; i++)\n+        if (result != null)\n+\t  for (int i = 0; i < result.length; i++)\n \t    array[i] =\n-\t      new UnmodifiableMapEntry<K,V>(array[i]);\n+\t      (S) new UnmodifiableMapEntry<K,V>((Map.Entry<K,V>) result[i]);\n         return array;\n       }\n       "}, {"sha": "7ff9c0ca8399a28505b615204091a9828ea5d8cd", "filename": "libjava/classpath/lib/gnu/java/net/PlainDatagramSocketImpl.class", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40b86e5f2cf069832e23043992dedb0bf8e0dcd6/libjava%2Fclasspath%2Flib%2Fgnu%2Fjava%2Fnet%2FPlainDatagramSocketImpl.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40b86e5f2cf069832e23043992dedb0bf8e0dcd6/libjava%2Fclasspath%2Flib%2Fgnu%2Fjava%2Fnet%2FPlainDatagramSocketImpl.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fgnu%2Fjava%2Fnet%2FPlainDatagramSocketImpl.class?ref=40b86e5f2cf069832e23043992dedb0bf8e0dcd6"}, {"sha": "5c42da8e08aa8f72436f393a06eec5dd5d010f91", "filename": "libjava/classpath/lib/gnu/java/net/PlainSocketImpl$SocketInputStream.class", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40b86e5f2cf069832e23043992dedb0bf8e0dcd6/libjava%2Fclasspath%2Flib%2Fgnu%2Fjava%2Fnet%2FPlainSocketImpl%24SocketInputStream.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40b86e5f2cf069832e23043992dedb0bf8e0dcd6/libjava%2Fclasspath%2Flib%2Fgnu%2Fjava%2Fnet%2FPlainSocketImpl%24SocketInputStream.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fgnu%2Fjava%2Fnet%2FPlainSocketImpl%24SocketInputStream.class?ref=40b86e5f2cf069832e23043992dedb0bf8e0dcd6"}, {"sha": "739340fd585bbcfc8c94ce5934ec10a0432b14ed", "filename": "libjava/classpath/lib/gnu/java/net/PlainSocketImpl$SocketOutputStream.class", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40b86e5f2cf069832e23043992dedb0bf8e0dcd6/libjava%2Fclasspath%2Flib%2Fgnu%2Fjava%2Fnet%2FPlainSocketImpl%24SocketOutputStream.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40b86e5f2cf069832e23043992dedb0bf8e0dcd6/libjava%2Fclasspath%2Flib%2Fgnu%2Fjava%2Fnet%2FPlainSocketImpl%24SocketOutputStream.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fgnu%2Fjava%2Fnet%2FPlainSocketImpl%24SocketOutputStream.class?ref=40b86e5f2cf069832e23043992dedb0bf8e0dcd6"}, {"sha": "1e26dd573b3c588f51fd99a2781a3d949016053f", "filename": "libjava/classpath/lib/gnu/java/net/PlainSocketImpl.class", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40b86e5f2cf069832e23043992dedb0bf8e0dcd6/libjava%2Fclasspath%2Flib%2Fgnu%2Fjava%2Fnet%2FPlainSocketImpl.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40b86e5f2cf069832e23043992dedb0bf8e0dcd6/libjava%2Fclasspath%2Flib%2Fgnu%2Fjava%2Fnet%2FPlainSocketImpl.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fgnu%2Fjava%2Fnet%2FPlainSocketImpl.class?ref=40b86e5f2cf069832e23043992dedb0bf8e0dcd6"}, {"sha": "d80af7d40055880d4659ead04dca8e8bbd47dfd2", "filename": "libjava/classpath/lib/java/net/DatagramSocket.class", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40b86e5f2cf069832e23043992dedb0bf8e0dcd6/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FDatagramSocket.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40b86e5f2cf069832e23043992dedb0bf8e0dcd6/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FDatagramSocket.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FDatagramSocket.class?ref=40b86e5f2cf069832e23043992dedb0bf8e0dcd6"}, {"sha": "b4bb5c0c8b2c4923d621cfe0bd7d14c9420b4afa", "filename": "libjava/classpath/lib/java/net/Socket.class", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40b86e5f2cf069832e23043992dedb0bf8e0dcd6/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FSocket.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40b86e5f2cf069832e23043992dedb0bf8e0dcd6/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FSocket.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FSocket.class?ref=40b86e5f2cf069832e23043992dedb0bf8e0dcd6"}, {"sha": "70357f7569b4dc87c9a06cd7f48f900f5216972e", "filename": "libjava/classpath/lib/java/util/Collections$UnmodifiableMap$UnmodifiableEntrySet.class", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40b86e5f2cf069832e23043992dedb0bf8e0dcd6/libjava%2Fclasspath%2Flib%2Fjava%2Futil%2FCollections%24UnmodifiableMap%24UnmodifiableEntrySet.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40b86e5f2cf069832e23043992dedb0bf8e0dcd6/libjava%2Fclasspath%2Flib%2Fjava%2Futil%2FCollections%24UnmodifiableMap%24UnmodifiableEntrySet.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fjava%2Futil%2FCollections%24UnmodifiableMap%24UnmodifiableEntrySet.class?ref=40b86e5f2cf069832e23043992dedb0bf8e0dcd6"}, {"sha": "08c1cb3f6ee20349884421577aa9673375c0f04b", "filename": "libjava/gnu/java/net/PlainDatagramSocketImpl.java", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40b86e5f2cf069832e23043992dedb0bf8e0dcd6/libjava%2Fgnu%2Fjava%2Fnet%2FPlainDatagramSocketImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40b86e5f2cf069832e23043992dedb0bf8e0dcd6/libjava%2Fgnu%2Fjava%2Fnet%2FPlainDatagramSocketImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2FPlainDatagramSocketImpl.java?ref=40b86e5f2cf069832e23043992dedb0bf8e0dcd6", "patch": "@@ -1,5 +1,5 @@\n /* PlainDatagramSocketImpl.java -- Default DatagramSocket implementation\n-   Copyright (C) 1998, 1999, 2001, 2003, 2004, 2005  Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2001, 2003, 2004, 2005, 2007  Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -119,7 +119,7 @@ public final class PlainDatagramSocketImpl extends DatagramSocketImpl\n   /**\n    * Default do nothing constructor\n    */\n-  public PlainDatagramSocketImpl()\n+  public PlainDatagramSocketImpl() throws IOException\n   {\n   }\n "}, {"sha": "dad1724d6b10efd402731e99976c83fe385d7c2d", "filename": "libjava/gnu/java/net/PlainSocketImpl.java", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40b86e5f2cf069832e23043992dedb0bf8e0dcd6/libjava%2Fgnu%2Fjava%2Fnet%2FPlainSocketImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40b86e5f2cf069832e23043992dedb0bf8e0dcd6/libjava%2Fgnu%2Fjava%2Fnet%2FPlainSocketImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2FPlainSocketImpl.java?ref=40b86e5f2cf069832e23043992dedb0bf8e0dcd6", "patch": "@@ -1,5 +1,5 @@\n /* PlainSocketImpl.java -- Default socket implementation\n-   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007\n    Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -110,6 +110,9 @@ public final class PlainSocketImpl extends SocketImpl\n   // localAddress cache\n   InetAddress localAddress;\n \n+  // Local address as an InetSocketAddress.\n+  InetSocketAddress localSocketAddress;\n+\n   /**\n    * A cached copy of the in stream for reading from the socket.\n    */\n@@ -325,6 +328,24 @@ private native void accept(PlainSocketImpl impl)\n \n   protected native void sendUrgentData(int data) throws IOException;\n \n+  public synchronized InetSocketAddress getLocalAddress()\n+  {\n+    if (localSocketAddress == null)\n+      {\n+\ttry\n+\t  {\n+\t    localSocketAddress\n+\t      = new InetSocketAddress ((InetAddress) getOption(SocketOptions.SO_BINDADDR),\n+\t\t\t\t       localport);\n+\t  }\n+\tcatch (SocketException _)\n+\t  {\n+\t    return null;\n+\t  }\n+      }\n+    return localSocketAddress;\n+  }\n+\n   /**\n    * Returns an InputStream object for reading from this socket.  This will\n    * be an instance of SocketInputStream."}, {"sha": "9fc619649d3c4c0a283a6ac91df8c417849a7858", "filename": "libjava/gnu/java/net/natPlainSocketImplPosix.cc", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40b86e5f2cf069832e23043992dedb0bf8e0dcd6/libjava%2Fgnu%2Fjava%2Fnet%2FnatPlainSocketImplPosix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40b86e5f2cf069832e23043992dedb0bf8e0dcd6/libjava%2Fgnu%2Fjava%2Fnet%2FnatPlainSocketImplPosix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2FnatPlainSocketImplPosix.cc?ref=40b86e5f2cf069832e23043992dedb0bf8e0dcd6", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2003, 2004, 2005, 2006  Free Software Foundation\n+/* Copyright (C) 2003, 2004, 2005, 2006, 2007  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -364,7 +364,7 @@ gnu::java::net::PlainSocketImpl$SocketOutputStream::write(jbyteArray b, jint off\n   if (offset < 0 || len < 0 || offset + len > JvGetArrayLength (b))\n     throw new ::java::lang::ArrayIndexOutOfBoundsException;\n \n-  write_helper (this$0->native_fd, elements (b) + offset * sizeof (jbyte), len);\n+  write_helper (this$0->native_fd, elements (b) + offset, len);\n }\n \n static void\n@@ -435,8 +435,7 @@ gnu::java::net::PlainSocketImpl$SocketInputStream::read(jbyteArray buffer,\n   if (offset < 0 || count < 0 || offset + count > bsize)\n     throw new ::java::lang::ArrayIndexOutOfBoundsException;\n \n-  return read_helper (this$0,\n-\t\t      elements (buffer) + offset * sizeof (jbyte), count);\n+  return read_helper (this$0, elements (buffer) + offset, count);\n }\n \n static jint"}, {"sha": "d8837c006b5d82c281bd64f5cafa078b3682a5a0", "filename": "libjava/java/net/DatagramSocket.java", "status": "removed", "additions": 0, "deletions": 939, "changes": 939, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8c30b5f9a11fed775dddf8c15706ae251fdd2d5/libjava%2Fjava%2Fnet%2FDatagramSocket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8c30b5f9a11fed775dddf8c15706ae251fdd2d5/libjava%2Fjava%2Fnet%2FDatagramSocket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FDatagramSocket.java?ref=e8c30b5f9a11fed775dddf8c15706ae251fdd2d5", "patch": "@@ -1,939 +0,0 @@\n-/* DatagramSocket.java -- A class to model UDP sockets\n-   Copyright (C) 1998, 1999, 2000, 2002, 2003, 2004, 2005\n-   Free Software Foundation, Inc.\n-\n-This file is part of GNU Classpath.\n-\n-GNU Classpath is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Classpath is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Classpath; see the file COPYING.  If not, write to the\n-Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n-02110-1301 USA.\n-\n-Linking this library statically or dynamically with other modules is\n-making a combined work based on this library.  Thus, the terms and\n-conditions of the GNU General Public License cover the whole\n-combination.\n-\n-As a special exception, the copyright holders of this library give you\n-permission to link this library with independent modules to produce an\n-executable, regardless of the license terms of these independent\n-modules, and to copy and distribute the resulting executable under\n-terms of your choice, provided that you also meet, for each linked\n-independent module, the terms and conditions of the license of that\n-module.  An independent module is a module which is not derived from\n-or based on this library.  If you modify this library, you may extend\n-this exception to your version of the library, but you are not\n-obligated to do so.  If you do not wish to do so, delete this\n-exception statement from your version. */\n-\n-package java.net;\n-\n-import gnu.classpath.SystemProperties;\n-\n-import gnu.java.net.PlainDatagramSocketImpl;\n-import gnu.java.nio.DatagramChannelImpl;\n-\n-import java.io.IOException;\n-import java.nio.channels.DatagramChannel;\n-import java.nio.channels.IllegalBlockingModeException;\n-\n-\n-/**\n- * Written using on-line Java Platform 1.2 API Specification, as well\n- * as \"The Java Class Libraries\", 2nd edition (Addison-Wesley, 1998).\n- * Status:  Believed complete and correct.\n- */\n-/**\n- * This class models a connectionless datagram socket that sends\n- * individual packets of data across the network.  In the TCP/IP world,\n- * this means UDP.  Datagram packets do not have guaranteed delivery,\n- * or any guarantee about the order the data will be received on the\n- * remote host.\n- *\n- * @author Aaron M. Renn (arenn@urbanophile.com)\n- * @author Warren Levy (warrenl@cygnus.com)\n- * @date May 3, 1999.\n- */\n-public class DatagramSocket\n-{\n-  /**\n-   * This is the user DatagramSocketImplFactory for this class.  If this\n-   * variable is null, a default factory is used.\n-   */\n-  private static DatagramSocketImplFactory factory;\n-\n-  /**\n-   * This is the implementation object used by this socket.\n-   */\n-  private DatagramSocketImpl impl;\n-\n-  /**\n-   * True if socket implementation was created.\n-   */\n-  private boolean implCreated;\n-\n-  /**\n-   * This is the address we are \"connected\" to\n-   */\n-  private InetAddress remoteAddress;\n-\n-  /**\n-   * This is the port we are \"connected\" to\n-   */\n-  private int remotePort = -1;\n-\n-  /**\n-   * True if socket is bound.\n-   */\n-  private boolean bound;\n-\n-  /**\n-   * Creates a <code>DatagramSocket</code> from a specified\n-   * <code>DatagramSocketImpl</code> instance\n-   *\n-   * @param impl The <code>DatagramSocketImpl</code> the socket will be\n-   * created from\n-   *\n-   * @since 1.4\n-   */\n-  protected DatagramSocket(DatagramSocketImpl impl)\n-  {\n-    if (impl == null)\n-      throw new NullPointerException(\"impl may not be null\");\n-\n-    this.impl = impl;\n-    this.remoteAddress = null;\n-    this.remotePort = -1;\n-  }\n-\n-  /**\n-   * Initializes a new instance of <code>DatagramSocket</code> that binds to\n-   * a random port and every address on the local machine.\n-   *\n-   * @exception SocketException If an error occurs.\n-   * @exception SecurityException If a security manager exists and\n-   * its <code>checkListen</code> method doesn't allow the operation.\n-   */\n-  public DatagramSocket() throws SocketException\n-  {\n-    this(new InetSocketAddress(0));\n-  }\n-\n-  /**\n-   * Initializes a new instance of <code>DatagramSocket</code> that binds to\n-   * the specified port and every address on the local machine.\n-   *\n-   * @param port The local port number to bind to.\n-   *\n-   * @exception SecurityException If a security manager exists and its\n-   * <code>checkListen</code> method doesn't allow the operation.\n-   * @exception SocketException If an error occurs.\n-   */\n-  public DatagramSocket(int port) throws SocketException\n-  {\n-    this(new InetSocketAddress(port));\n-  }\n-\n-  /**\n-   * Initializes a new instance of <code>DatagramSocket</code> that binds to\n-   * the specified local port and address.\n-   *\n-   * @param port The local port number to bind to.\n-   * @param addr The local address to bind to.\n-   *\n-   * @exception SecurityException If a security manager exists and its\n-   * checkListen method doesn't allow the operation.\n-   * @exception SocketException If an error occurs.\n-   */\n-  public DatagramSocket(int port, InetAddress addr) throws SocketException\n-  {\n-    this(new InetSocketAddress(addr, port));\n-  }\n-\n-  /**\n-   * Initializes a new instance of <code>DatagramSocket</code> that binds to\n-   * the specified local port and address.\n-   *\n-   * @param address The local address and port number to bind to.\n-   *\n-   * @exception SecurityException If a security manager exists and its\n-   * <code>checkListen</code> method doesn't allow the operation.\n-   * @exception SocketException If an error occurs.\n-   *\n-   * @since 1.4\n-   */\n-  public DatagramSocket(SocketAddress address) throws SocketException\n-  {\n-    String propVal = SystemProperties.getProperty(\"impl.prefix\");\n-    if (propVal == null || propVal.equals(\"\"))\n-      {\n-        if (factory != null)\n-          impl = factory.createDatagramSocketImpl();\n-        else\n-          impl = new PlainDatagramSocketImpl();\n-      }\n-    else\n-      try\n-        {\n-\t  impl =\n-\t    (DatagramSocketImpl) Class.forName(\"java.net.\" + propVal\n-\t                                       + \"DatagramSocketImpl\")\n-\t                              .newInstance();\n-        }\n-      catch (Exception e)\n-        {\n-\t  System.err.println(\"Could not instantiate class: java.net.\"\n-\t                     + propVal + \"DatagramSocketImpl\");\n-\t  impl = new PlainDatagramSocketImpl();\n-        }\n-\n-    if (address != null)\n-      bind(address);\n-  }\n-\n-  // This needs to be accessible from java.net.MulticastSocket\n-  DatagramSocketImpl getImpl() throws SocketException\n-  {\n-    try\n-      {\n-\tif (! implCreated)\n-\t  {\n-\t    impl.create();\n-\t    implCreated = true;\n-\t  }\n-\n-\treturn impl;\n-      }\n-    catch (IOException e)\n-      {\n-\tSocketException se = new SocketException();\n-\tse.initCause(e);\n-\tthrow se;\n-      }\n-  }\n-\n-  /**\n-   * Closes this datagram socket.\n-   */\n-  public void close()\n-  {\n-    if (isClosed())\n-      return;\n-\n-    try\n-      {\n-\tgetImpl().close();\n-      }\n-    catch (SocketException e)\n-      {\n-\t// Ignore this case, just close the socket in finally clause.\n-      }\n-    finally\n-      {\n-\tremoteAddress = null;\n-\tremotePort = -1;\n-\timpl = null;\n-      }\n-\n-    try\n-      {\n-\tif (getChannel() != null)\n-\t  getChannel().close();\n-      }\n-    catch (IOException e)\n-      {\n-\t// Do nothing.\n-      }\n-  }\n-\n-  /**\n-   * This method returns the remote address to which this socket is\n-   * connected.  If this socket is not connected, then this method will\n-   * return <code>null</code>.\n-   *\n-   * @return The remote address.\n-   *\n-   * @since 1.2\n-   */\n-  public InetAddress getInetAddress()\n-  {\n-    return remoteAddress;\n-  }\n-\n-  /**\n-   * This method returns the remote port to which this socket is\n-   * connected.  If this socket is not connected, then this method will\n-   * return -1.\n-   *\n-   * @return The remote port.\n-   *\n-   * @since 1.2\n-   */\n-  public int getPort()\n-  {\n-    return remotePort;\n-  }\n-\n-  /**\n-   * Returns the local address this datagram socket is bound to.\n-   *\n-   * @return The local address is the socket is bound or null\n-   *\n-   * @since 1.1\n-   */\n-  public InetAddress getLocalAddress()\n-  {\n-    if (! isBound())\n-      return null;\n-\n-    InetAddress localAddr;\n-\n-    try\n-      {\n-\tlocalAddr =\n-\t  (InetAddress) getImpl().getOption(SocketOptions.SO_BINDADDR);\n-\n-\tSecurityManager s = System.getSecurityManager();\n-\tif (s != null)\n-\t  s.checkConnect(localAddr.getHostName(), -1);\n-      }\n-    catch (SecurityException e)\n-      {\n-\tlocalAddr = InetAddress.ANY_IF;\n-      }\n-    catch (SocketException e)\n-      {\n-\t// This cannot happen as we are bound.\n-\treturn null;\n-      }\n-\n-    return localAddr;\n-  }\n-\n-  /**\n-   * Returns the local port this socket is bound to.\n-   *\n-   * @return The local port number.\n-   */\n-  public int getLocalPort()\n-  {\n-    if (isClosed())\n-      return -1;\n-\n-    try\n-      {\n-\treturn getImpl().getLocalPort();\n-      }\n-    catch (SocketException e)\n-      {\n-\t// This cannot happen as we are bound.\n-\treturn 0;\n-      }\n-  }\n-\n-  /**\n-   * Returns the value of the socket's SO_TIMEOUT setting.  If this method\n-   * returns 0 then SO_TIMEOUT is disabled.\n-   *\n-   * @return The current timeout in milliseconds.\n-   *\n-   * @exception SocketException If an error occurs.\n-   *\n-   * @since 1.1\n-   */\n-  public synchronized int getSoTimeout() throws SocketException\n-  {\n-    if (isClosed())\n-      throw new SocketException(\"socket is closed\");\n-\n-    Object buf = getImpl().getOption(SocketOptions.SO_TIMEOUT);\n-\n-    if (buf instanceof Integer)\n-      return ((Integer) buf).intValue();\n-\n-    throw new SocketException(\"unexpected type\");\n-  }\n-\n-  /**\n-   * Sets the value of the socket's SO_TIMEOUT value.  A value of 0 will\n-   * disable SO_TIMEOUT.  Any other value is the number of milliseconds\n-   * a socket read/write will block before timing out.\n-   *\n-   * @param timeout The new SO_TIMEOUT value in milliseconds.\n-   *\n-   * @exception SocketException If an error occurs.\n-   *\n-   * @since 1.1\n-   */\n-  public synchronized void setSoTimeout(int timeout) throws SocketException\n-  {\n-    if (isClosed())\n-      throw new SocketException(\"socket is closed\");\n-\n-    if (timeout < 0)\n-      throw new IllegalArgumentException(\"Invalid timeout: \" + timeout);\n-\n-    getImpl().setOption(SocketOptions.SO_TIMEOUT, new Integer(timeout));\n-  }\n-\n-  /**\n-   * This method returns the value of the system level socket option\n-   * SO_SNDBUF, which is used by the operating system to tune buffer\n-   * sizes for data transfers.\n-   *\n-   * @return The send buffer size.\n-   *\n-   * @exception SocketException If an error occurs.\n-   *\n-   * @since 1.2\n-   */\n-  public int getSendBufferSize() throws SocketException\n-  {\n-    if (isClosed())\n-      throw new SocketException(\"socket is closed\");\n-\n-    Object buf = getImpl().getOption(SocketOptions.SO_SNDBUF);\n-\n-    if (buf instanceof Integer)\n-      return ((Integer) buf).intValue();\n-\n-    throw new SocketException(\"unexpected type\");\n-  }\n-\n-  /**\n-   * This method sets the value for the system level socket option\n-   * SO_SNDBUF to the specified value.  Note that valid values for this\n-   * option are specific to a given operating system.\n-   *\n-   * @param size The new send buffer size.\n-   *\n-   * @exception SocketException If an error occurs.\n-   * @exception IllegalArgumentException If size is 0 or negative.\n-   *\n-   * @since 1.2\n-   */\n-  public void setSendBufferSize(int size) throws SocketException\n-  {\n-    if (isClosed())\n-      throw new SocketException(\"socket is closed\");\n-\n-    if (size < 0)\n-      throw new IllegalArgumentException(\"Buffer size is less than 0\");\n-\n-    getImpl().setOption(SocketOptions.SO_SNDBUF, new Integer(size));\n-  }\n-\n-  /**\n-   * This method returns the value of the system level socket option\n-   * SO_RCVBUF, which is used by the operating system to tune buffer\n-   * sizes for data transfers.\n-   *\n-   * @return The receive buffer size.\n-   *\n-   * @exception SocketException If an error occurs.\n-   *\n-   * @since 1.2\n-   */\n-  public int getReceiveBufferSize() throws SocketException\n-  {\n-    if (isClosed())\n-      throw new SocketException(\"socket is closed\");\n-\n-    Object buf = getImpl().getOption(SocketOptions.SO_RCVBUF);\n-\n-    if (buf instanceof Integer)\n-      return ((Integer) buf).intValue();\n-\n-    throw new SocketException(\"unexpected type\");\n-  }\n-\n-  /**\n-   * This method sets the value for the system level socket option\n-   * SO_RCVBUF to the specified value.  Note that valid values for this\n-   * option are specific to a given operating system.\n-   *\n-   * @param size The new receive buffer size.\n-   *\n-   * @exception SocketException If an error occurs.\n-   * @exception IllegalArgumentException If size is 0 or negative.\n-   *\n-   * @since 1.2\n-   */\n-  public void setReceiveBufferSize(int size) throws SocketException\n-  {\n-    if (isClosed())\n-      throw new SocketException(\"socket is closed\");\n-\n-    if (size < 0)\n-      throw new IllegalArgumentException(\"Buffer size is less than 0\");\n-\n-    getImpl().setOption(SocketOptions.SO_RCVBUF, new Integer(size));\n-  }\n-\n-  /**\n-   * This method connects this socket to the specified address and port.\n-   * When a datagram socket is connected, it will only send or receive\n-   * packets to and from the host to which it is connected. A multicast\n-   * socket that is connected may only send and not receive packets.\n-   *\n-   * @param address The address to connect this socket to.\n-   * @param port The port to connect this socket to.\n-   *\n-   * @exception IllegalArgumentException If address or port are invalid.\n-   * @exception SecurityException If the caller is not allowed to send\n-   * datagrams to or receive from this address and port.\n-   *\n-   * @since 1.2\n-   */\n-  public void connect(InetAddress address, int port)\n-  {\n-    if (address == null)\n-      throw new IllegalArgumentException(\"Connect address may not be null\");\n-\n-    if ((port < 1) || (port > 65535))\n-      throw new IllegalArgumentException(\"Port number is illegal: \" + port);\n-\n-    SecurityManager sm = System.getSecurityManager();\n-    if (sm != null)\n-      sm.checkConnect(address.getHostName(), port);\n-\n-    try\n-      {\n-\tgetImpl().connect(address, port);\n-\tremoteAddress = address;\n-\tremotePort = port;\n-      }\n-    catch (SocketException e)\n-      {\n-\t// This means simply not connected or connect not implemented.\n-      }\n-  }\n-\n-  /**\n-   * This method disconnects this socket from the address/port it was\n-   * connected to.  If the socket was not connected in the first place,\n-   * this method does nothing.\n-   *\n-   * @since 1.2\n-   */\n-  public void disconnect()\n-  {\n-    if (! isConnected())\n-      return;\n-\n-    try\n-      {\n-\tgetImpl().disconnect();\n-      }\n-    catch (SocketException e)\n-      {\n-\t// This cannot happen as we are connected.\n-      }\n-    finally\n-      {\n-\tremoteAddress = null;\n-\tremotePort = -1;\n-      }\n-  }\n-\n-  /**\n-   * Reads a datagram packet from the socket.  Note that this method\n-   * will block until a packet is received from the network.  On return,\n-   * the passed in <code>DatagramPacket</code> is populated with the data\n-   * received and all the other information about the packet.\n-   *\n-   * @param p A <code>DatagramPacket</code> for storing the data\n-   *\n-   * @exception IOException If an error occurs.\n-   * @exception SocketTimeoutException If setSoTimeout was previously called\n-   * and the timeout has expired.\n-   * @exception PortUnreachableException If the socket is connected to a\n-   * currently unreachable destination. Note, there is no guarantee that the\n-   * exception will be thrown.\n-   * @exception IllegalBlockingModeException If this socket has an associated\n-   * channel, and the channel is in non-blocking mode.\n-   * @exception SecurityException If a security manager exists and its\n-   * checkAccept method doesn't allow the receive.\n-   */\n-  public synchronized void receive(DatagramPacket p) throws IOException\n-  {\n-    if (isClosed())\n-      throw new SocketException(\"socket is closed\");\n-\n-    if (remoteAddress != null && remoteAddress.isMulticastAddress())\n-      throw new IOException\n-\t(\"Socket connected to a multicast address my not receive\");\n-\n-    if (getChannel() != null && ! getChannel().isBlocking()\n-        && ! ((DatagramChannelImpl) getChannel()).isInChannelOperation())\n-      throw new IllegalBlockingModeException();\n-\n-    getImpl().receive(p);\n-\n-    SecurityManager s = System.getSecurityManager();\n-    if (s != null && isConnected())\n-      s.checkAccept(p.getAddress().getHostName(), p.getPort());\n-  }\n-\n-  /**\n-   * Sends the specified packet.  The host and port to which the packet\n-   * are to be sent should be set inside the packet.\n-   *\n-   * @param p The datagram packet to send.\n-   *\n-   * @exception IOException If an error occurs.\n-   * @exception SecurityException If a security manager exists and its\n-   * checkMulticast or checkConnect method doesn't allow the send.\n-   * @exception PortUnreachableException If the socket is connected to a\n-   * currently unreachable destination. Note, there is no guarantee that the\n-   * exception will be thrown.\n-   * @exception IllegalBlockingModeException If this socket has an associated\n-   * channel, and the channel is in non-blocking mode.\n-   */\n-  public void send(DatagramPacket p) throws IOException\n-  {\n-    if (isClosed())\n-      throw new SocketException(\"socket is closed\");\n-\n-    // JDK1.2: Don't do security checks if socket is connected; see jdk1.2 api.\n-    SecurityManager s = System.getSecurityManager();\n-    if (s != null && ! isConnected())\n-      {\n-\tInetAddress addr = p.getAddress();\n-\tif (addr.isMulticastAddress())\n-\t  s.checkMulticast(addr);\n-\telse\n-\t  s.checkConnect(addr.getHostAddress(), p.getPort());\n-      }\n-\n-    if (isConnected())\n-      {\n-\tif (p.getAddress() != null\n-\t    && (remoteAddress != p.getAddress() || remotePort != p.getPort()))\n-\t  throw new IllegalArgumentException\n-\t    (\"DatagramPacket address does not match remote address\");\n-      }\n-\n-    // FIXME: if this is a subclass of MulticastSocket,\n-    // use getTimeToLive for TTL val.\n-    if (getChannel() != null && ! getChannel().isBlocking()\n-        && ! ((DatagramChannelImpl) getChannel()).isInChannelOperation())\n-      throw new IllegalBlockingModeException();\n-\n-    getImpl().send(p);\n-  }\n-\n-  /**\n-   * Binds the socket to the given socket address.\n-   *\n-   * @param address The socket address to bind to.\n-   *\n-   * @exception SocketException If an error occurs.\n-   * @exception SecurityException If a security manager exists and\n-   * its checkListen method doesn't allow the operation.\n-   * @exception IllegalArgumentException If address type is not supported.\n-   *\n-   * @since 1.4\n-   */\n-  public void bind(SocketAddress address) throws SocketException\n-  {\n-    if (isClosed())\n-      throw new SocketException(\"socket is closed\");\n-\n-    if (! (address instanceof InetSocketAddress))\n-      throw new IllegalArgumentException(\"unsupported address type\");\n-\n-    InetAddress addr = ((InetSocketAddress) address).getAddress();\n-    int port = ((InetSocketAddress) address).getPort();\n-\n-    if (port < 0 || port > 65535)\n-      throw new IllegalArgumentException(\"Invalid port: \" + port);\n-\n-    SecurityManager s = System.getSecurityManager();\n-    if (s != null)\n-      s.checkListen(port);\n-\n-    if (addr == null)\n-      addr = InetAddress.ANY_IF;\n-\n-    try\n-      {\n-\tgetImpl().bind(port, addr);\n-\tbound = true;\n-      }\n-    catch (SocketException exception)\n-      {\n-\tgetImpl().close();\n-\tthrow exception;\n-      }\n-    catch (RuntimeException exception)\n-      {\n-\tgetImpl().close();\n-\tthrow exception;\n-      }\n-    catch (Error error)\n-      {\n-\tgetImpl().close();\n-\tthrow error;\n-      }\n-  }\n-\n-  /**\n-   * Checks if the datagram socket is closed.\n-   *\n-   * @return True if socket is closed, false otherwise.\n-   *\n-   * @since 1.4\n-   */\n-  public boolean isClosed()\n-  {\n-    return impl == null;\n-  }\n-\n-  /**\n-   * Returns the datagram channel assoziated with this datagram socket.\n-   *\n-   * @return The associated <code>DatagramChannel</code> object or null\n-   *\n-   * @since 1.4\n-   */\n-  public DatagramChannel getChannel()\n-  {\n-    return null;\n-  }\n-\n-  /**\n-   * Connects the datagram socket to a specified socket address.\n-   *\n-   * @param address The socket address to connect to.\n-   *\n-   * @exception SocketException If an error occurs.\n-   * @exception IllegalArgumentException If address type is not supported.\n-   *\n-   * @since 1.4\n-   */\n-  public void connect(SocketAddress address) throws SocketException\n-  {\n-    if (isClosed())\n-      throw new SocketException(\"socket is closed\");\n-\n-    if (! (address instanceof InetSocketAddress))\n-      throw new IllegalArgumentException(\"unsupported address type\");\n-\n-    InetSocketAddress tmp = (InetSocketAddress) address;\n-    connect(tmp.getAddress(), tmp.getPort());\n-  }\n-\n-  /**\n-   * Returns the binding state of the socket.\n-   *\n-   * @return True if socket bound, false otherwise.\n-   *\n-   * @since 1.4\n-   */\n-  public boolean isBound()\n-  {\n-    return bound;\n-  }\n-\n-  /**\n-   * Returns the connection state of the socket.\n-   *\n-   * @return True if socket is connected, false otherwise.\n-   *\n-   * @since 1.4\n-   */\n-  public boolean isConnected()\n-  {\n-    return remoteAddress != null;\n-  }\n-\n-  /**\n-   * Returns the SocketAddress of the host this socket is conneted to\n-   * or null if this socket is not connected.\n-   *\n-   * @return The socket address of the remote host if connected or null\n-   *\n-   * @since 1.4\n-   */\n-  public SocketAddress getRemoteSocketAddress()\n-  {\n-    if (! isConnected())\n-      return null;\n-\n-    return new InetSocketAddress(remoteAddress, remotePort);\n-  }\n-\n-  /**\n-   * Returns the local SocketAddress this socket is bound to.\n-   *\n-   * @return The local SocketAddress or null if the socket is not bound.\n-   *\n-   * @since 1.4\n-   */\n-  public SocketAddress getLocalSocketAddress()\n-  {\n-    if (! isBound())\n-      return null;\n-\n-    return new InetSocketAddress(getLocalAddress(), getLocalPort());\n-  }\n-\n-  /**\n-   * Enables/Disables SO_REUSEADDR.\n-   *\n-   * @param on Whether or not to have SO_REUSEADDR turned on.\n-   *\n-   * @exception SocketException If an error occurs.\n-   *\n-   * @since 1.4\n-   */\n-  public void setReuseAddress(boolean on) throws SocketException\n-  {\n-    if (isClosed())\n-      throw new SocketException(\"socket is closed\");\n-\n-    getImpl().setOption(SocketOptions.SO_REUSEADDR, Boolean.valueOf(on));\n-  }\n-\n-  /**\n-   * Checks if SO_REUSEADDR is enabled.\n-   *\n-   * @return True if SO_REUSEADDR is set on the socket, false otherwise.\n-   *\n-   * @exception SocketException If an error occurs.\n-   *\n-   * @since 1.4\n-   */\n-  public boolean getReuseAddress() throws SocketException\n-  {\n-    if (isClosed())\n-      throw new SocketException(\"socket is closed\");\n-\n-    Object buf = getImpl().getOption(SocketOptions.SO_REUSEADDR);\n-\n-    if (buf instanceof Boolean)\n-      return ((Boolean) buf).booleanValue();\n-\n-    throw new SocketException(\"unexpected type\");\n-  }\n-\n-  /**\n-   * Enables/Disables SO_BROADCAST\n-   *\n-   * @param enable True if SO_BROADCAST should be enabled, false otherwise.\n-   *\n-   * @exception SocketException If an error occurs\n-   *\n-   * @since 1.4\n-   */\n-  public void setBroadcast(boolean enable) throws SocketException\n-  {\n-    if (isClosed())\n-      throw new SocketException(\"socket is closed\");\n-\n-    getImpl().setOption(SocketOptions.SO_BROADCAST, Boolean.valueOf(enable));\n-  }\n-\n-  /**\n-   * Checks if SO_BROADCAST is enabled\n-   *\n-   * @return Whether SO_BROADCAST is set\n-   *\n-   * @exception SocketException If an error occurs\n-   *\n-   * @since 1.4\n-   */\n-  public boolean getBroadcast() throws SocketException\n-  {\n-    if (isClosed())\n-      throw new SocketException(\"socket is closed\");\n-\n-    Object buf = getImpl().getOption(SocketOptions.SO_BROADCAST);\n-\n-    if (buf instanceof Boolean)\n-      return ((Boolean) buf).booleanValue();\n-\n-    throw new SocketException(\"unexpected type\");\n-  }\n-\n-  /**\n-   * Sets the traffic class value\n-   *\n-   * @param tc The traffic class\n-   *\n-   * @exception SocketException If an error occurs\n-   * @exception IllegalArgumentException If tc value is illegal\n-   *\n-   * @see DatagramSocket#getTrafficClass()\n-   *\n-   * @since 1.4\n-   */\n-  public void setTrafficClass(int tc) throws SocketException\n-  {\n-    if (isClosed())\n-      throw new SocketException(\"socket is closed\");\n-\n-    if (tc < 0 || tc > 255)\n-      throw new IllegalArgumentException();\n-\n-    getImpl().setOption(SocketOptions.IP_TOS, new Integer(tc));\n-  }\n-\n-  /**\n-   * Returns the current traffic class\n-   *\n-   * @return The current traffic class.\n-   *\n-   * @see DatagramSocket#setTrafficClass(int tc)\n-   *\n-   * @exception SocketException If an error occurs\n-   *\n-   * @since 1.4\n-   */\n-  public int getTrafficClass() throws SocketException\n-  {\n-    if (isClosed())\n-      throw new SocketException(\"socket is closed\");\n-\n-    Object buf = getImpl().getOption(SocketOptions.IP_TOS);\n-\n-    if (buf instanceof Integer)\n-      return ((Integer) buf).intValue();\n-\n-    throw new SocketException(\"unexpected type\");\n-  }\n-\n-  /**\n-   * Sets the datagram socket implementation factory for the application\n-   *\n-   * @param fac The factory to set\n-   *\n-   * @exception IOException If an error occurs\n-   * @exception SocketException If the factory is already defined\n-   * @exception SecurityException If a security manager exists and its\n-   * checkSetFactory method doesn't allow the operation\n-   */\n-  public static void setDatagramSocketImplFactory(DatagramSocketImplFactory fac)\n-    throws IOException\n-  {\n-    if (factory != null)\n-      throw new SocketException(\"DatagramSocketImplFactory already defined\");\n-\n-    SecurityManager sm = System.getSecurityManager();\n-    if (sm != null)\n-      sm.checkSetFactory();\n-\n-    factory = fac;\n-  }\n-}"}, {"sha": "b2249ffaa0dded08b9dbbf42b112fec7157a5e37", "filename": "libjava/java/net/Socket.java", "status": "removed", "additions": 0, "deletions": 1269, "changes": 1269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8c30b5f9a11fed775dddf8c15706ae251fdd2d5/libjava%2Fjava%2Fnet%2FSocket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8c30b5f9a11fed775dddf8c15706ae251fdd2d5/libjava%2Fjava%2Fnet%2FSocket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FSocket.java?ref=e8c30b5f9a11fed775dddf8c15706ae251fdd2d5", "patch": "@@ -1,1269 +0,0 @@\n-/* Socket.java -- Client socket implementation\n-   Copyright (C) 1998, 1999, 2000, 2002, 2003, 2004\n-   Free Software Foundation, Inc.\n-\n-This file is part of GNU Classpath.\n-\n-GNU Classpath is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Classpath is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Classpath; see the file COPYING.  If not, write to the\n-Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n-02110-1301 USA.\n-\n-Linking this library statically or dynamically with other modules is\n-making a combined work based on this library.  Thus, the terms and\n-conditions of the GNU General Public License cover the whole\n-combination.\n-\n-As a special exception, the copyright holders of this library give you\n-permission to link this library with independent modules to produce an\n-executable, regardless of the license terms of these independent\n-modules, and to copy and distribute the resulting executable under\n-terms of your choice, provided that you also meet, for each linked\n-independent module, the terms and conditions of the license of that\n-module.  An independent module is a module which is not derived from\n-or based on this library.  If you modify this library, you may extend\n-this exception to your version of the library, but you are not\n-obligated to do so.  If you do not wish to do so, delete this\n-exception statement from your version. */\n-\n-package java.net;\n-\n-import gnu.java.net.PlainSocketImpl;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n-import java.nio.channels.IllegalBlockingModeException;\n-import java.nio.channels.SocketChannel;\n-\n-\n-/* Written using on-line Java Platform 1.2 API Specification.\n- * Status:  I believe all methods are implemented.\n- */\n-\n-/**\n- * This class models a client site socket.  A socket is a TCP/IP endpoint\n- * for network communications conceptually similar to a file handle.\n- * <p>\n- * This class does not actually do any work.  Instead, it redirects all of\n- * its calls to a socket implementation object which implements the\n- * <code>SocketImpl</code> interface.  The implementation class is\n- * instantiated by factory class that implements the\n- * <code>SocketImplFactory interface</code>.  A default\n- * factory is provided, however the factory may be set by a call to\n- * the <code>setSocketImplFactory</code> method.  Note that this may only be\n- * done once per virtual machine.  If a subsequent attempt is made to set the\n- * factory, a <code>SocketException</code> will be thrown.\n- *\n- * @author Aaron M. Renn (arenn@urbanophile.com)\n- * @author Per Bothner (bothner@cygnus.com)\n- */\n-public class Socket\n-{\n-  /**\n-   * This is the user SocketImplFactory for this class.  If this variable is\n-   * null, a default factory is used.\n-   */\n-  static SocketImplFactory factory;\n-\n-  /**\n-   * The implementation object to which calls are redirected\n-   */\n-  // package-private because ServerSocket.implAccept() needs to access it.\n-  SocketImpl impl;\n-\n-  /**\n-   * True if socket implementation was created by calling their\n-   * create() method.\n-   */\n-  // package-private because ServerSocket.implAccept() needs to access it.\n-  boolean implCreated;\n-\n-  /**\n-   * True if the socket is bound.\n-   * Package private so it can be set from ServerSocket when accept is called.\n-   */\n-  boolean bound;\n-\n-  /**\n-   * True if input is shutdown.\n-   */\n-  private boolean inputShutdown;\n-\n-  /**\n-   * True if output is shutdown.\n-   */\n-  private boolean outputShutdown;\n-\n-  /**\n-   * Initializes a new instance of <code>Socket</code> object without\n-   * connecting to a remote host.  This useful for subclasses of socket that\n-   * might want this behavior.\n-   *\n-   * @specnote This constructor is public since JDK 1.4\n-   * @since 1.1\n-   */\n-  public Socket()\n-  {\n-    if (factory != null)\n-      impl = factory.createSocketImpl();\n-    else\n-      impl = new PlainSocketImpl();\n-  }\n-\n-  /**\n-   * Initializes a new instance of <code>Socket</code> object without\n-   * connecting to a remote host.  This is useful for subclasses of socket\n-   * that might want this behavior.\n-   * <p>\n-   * Additionally, this socket will be created using the supplied\n-   * implementation class instead the default class or one returned by a\n-   * factory.  If this value is <code>null</code>, the default Socket\n-   * implementation is used.\n-   *\n-   * @param impl The <code>SocketImpl</code> to use for this\n-   *             <code>Socket</code>\n-   *\n-   * @exception SocketException If an error occurs\n-   *\n-   * @since 1.1\n-   */\n-  protected Socket(SocketImpl impl) throws SocketException\n-  {\n-    if (impl == null)\n-      this.impl = new PlainSocketImpl();\n-    else\n-      this.impl = impl;\n-  }\n-\n-  /**\n-   * Initializes a new instance of <code>Socket</code> and connects to the\n-   * hostname and port specified as arguments.\n-   *\n-   * @param host The name of the host to connect to\n-   * @param port The port number to connect to\n-   *\n-   * @exception UnknownHostException If the hostname cannot be resolved to a\n-   * network address.\n-   * @exception IOException If an error occurs\n-   * @exception SecurityException If a security manager exists and its\n-   * checkConnect method doesn't allow the operation\n-   */\n-  public Socket(String host, int port)\n-    throws UnknownHostException, IOException\n-  {\n-    this(InetAddress.getByName(host), port, null, 0, true);\n-  }\n-\n-  /**\n-   * Initializes a new instance of <code>Socket</code> and connects to the\n-   * address and port number specified as arguments.\n-   *\n-   * @param address The address to connect to\n-   * @param port The port number to connect to\n-   *\n-   * @exception IOException If an error occurs\n-   * @exception SecurityException If a security manager exists and its\n-   * checkConnect method doesn't allow the operation\n-   */\n-  public Socket(InetAddress address, int port) throws IOException\n-  {\n-    this(address, port, null, 0, true);\n-  }\n-\n-  /**\n-   * Initializes a new instance of <code>Socket</code> that connects to the\n-   * named host on the specified port and binds to the specified local address\n-   * and port.\n-   *\n-   * @param host The name of the remote host to connect to.\n-   * @param port The remote port to connect to.\n-   * @param localAddr The local address to bind to.\n-   * @param localPort The local port to bind to.\n-   *\n-   * @exception SecurityException If the <code>SecurityManager</code>\n-   * exists and does not allow a connection to the specified host/port or\n-   * binding to the specified local host/port.\n-   * @exception IOException If a connection error occurs.\n-   *\n-   * @since 1.1\n-   */\n-  public Socket(String host, int port, InetAddress localAddr, int localPort)\n-    throws IOException\n-  {\n-    this(InetAddress.getByName(host), port, localAddr, localPort, true);\n-  }\n-\n-  /**\n-   * Initializes a new instance of <code>Socket</code> and connects to the\n-   * address and port number specified as arguments, plus binds to the\n-   * specified local address and port.\n-   *\n-   * @param address The remote address to connect to\n-   * @param port The remote port to connect to\n-   * @param localAddr The local address to connect to\n-   * @param localPort The local port to connect to\n-   *\n-   * @exception IOException If an error occurs\n-   * @exception SecurityException If a security manager exists and its\n-   * checkConnect method doesn't allow the operation\n-   *\n-   * @since 1.1\n-   */\n-  public Socket(InetAddress address, int port, InetAddress localAddr,\n-                int localPort) throws IOException\n-  {\n-    this(address, port, localAddr, localPort, true);\n-  }\n-\n-  /**\n-   * Initializes a new instance of <code>Socket</code> and connects to the\n-   * hostname and port specified as arguments.  If the stream argument is set\n-   * to <code>true</code>, then a stream socket is created.  If it is\n-   * <code>false</code>, a datagram socket is created.\n-   *\n-   * @param host The name of the host to connect to\n-   * @param port The port to connect to\n-   * @param stream <code>true</code> for a stream socket, <code>false</code>\n-   * for a datagram socket\n-   *\n-   * @exception IOException If an error occurs\n-   * @exception SecurityException If a security manager exists and its\n-   * checkConnect method doesn't allow the operation\n-   *\n-   * @deprecated Use the <code>DatagramSocket</code> class to create\n-   * datagram oriented sockets.\n-   */\n-  public Socket(String host, int port, boolean stream)\n-    throws IOException\n-  {\n-    this(InetAddress.getByName(host), port, null, 0, stream);\n-  }\n-\n-  /**\n-   * Initializes a new instance of <code>Socket</code> and connects to the\n-   * address and port number specified as arguments.  If the stream param is\n-   * <code>true</code>, a stream socket will be created, otherwise a datagram\n-   * socket is created.\n-   *\n-   * @param host The address to connect to\n-   * @param port The port number to connect to\n-   * @param stream <code>true</code> to create a stream socket,\n-   * <code>false</code> to create a datagram socket.\n-   *\n-   * @exception IOException If an error occurs\n-   * @exception SecurityException If a security manager exists and its\n-   * checkConnect method doesn't allow the operation\n-   *\n-   * @deprecated Use the <code>DatagramSocket</code> class to create\n-   * datagram oriented sockets.\n-   */\n-  public Socket(InetAddress host, int port, boolean stream)\n-    throws IOException\n-  {\n-    this(host, port, null, 0, stream);\n-  }\n-\n-  /**\n-   * This constructor is where the real work takes place.  Connect to the\n-   * specified address and port.  Use default local values if not specified,\n-   * otherwise use the local host and port passed in.  Create as stream or\n-   * datagram based on \"stream\" argument.\n-   * <p>\n-   *\n-   * @param raddr The remote address to connect to\n-   * @param rport The remote port to connect to\n-   * @param laddr The local address to connect to\n-   * @param lport The local port to connect to\n-   * @param stream true for a stream socket, false for a datagram socket\n-   *\n-   * @exception IOException If an error occurs\n-   * @exception SecurityException If a security manager exists and its\n-   * checkConnect method doesn't allow the operation\n-   */\n-  private Socket(InetAddress raddr, int rport, InetAddress laddr, int lport,\n-                 boolean stream) throws IOException\n-  {\n-    this();\n-\n-    SecurityManager sm = System.getSecurityManager();\n-    if (sm != null)\n-      sm.checkConnect(raddr.getHostName(), rport);\n-\n-    // bind socket\n-    SocketAddress bindaddr =\n-      laddr == null ? null : new InetSocketAddress(laddr, lport);\n-    bind(bindaddr);\n-\n-    // connect socket\n-    connect(new InetSocketAddress(raddr, rport));\n-\n-    // FIXME: JCL p. 1586 says if localPort is unspecified, bind to any port,\n-    // i.e. '0' and if localAddr is unspecified, use getLocalAddress() as\n-    // that default.  JDK 1.2 doc infers not to do a bind.\n-  }\n-\n-  private SocketImpl getImpl() throws SocketException\n-  {\n-    try\n-      {\n-\tif (! implCreated)\n-\t  {\n-\t    impl.create(true);\n-\t    implCreated = true;\n-\t  }\n-      }\n-    catch (IOException e)\n-      {\n-\tSocketException se = new SocketException(e.toString());\n-\tse.initCause(e);\n-\tthrow se;\n-      }\n-\n-    return impl;\n-  }\n-\n-  /**\n-   * Binds the socket to the givent local address/port\n-   *\n-   * @param bindpoint The address/port to bind to\n-   *\n-   * @exception IOException If an error occurs\n-   * @exception SecurityException If a security manager exists and its\n-   * checkConnect method doesn't allow the operation\n-   * @exception IllegalArgumentException If the address type is not supported\n-   *\n-   * @since 1.4\n-   */\n-  public void bind(SocketAddress bindpoint) throws IOException\n-  {\n-    if (isClosed())\n-      throw new SocketException(\"socket is closed\");\n-\n-    // XXX: JDK 1.4.1 API documentation says that if bindpoint is null the\n-    // socket will be bound to an ephemeral port and a valid local address.\n-    if (bindpoint == null)\n-      bindpoint = new InetSocketAddress(InetAddress.ANY_IF, 0);\n-\n-    if (! (bindpoint instanceof InetSocketAddress))\n-      throw new IllegalArgumentException();\n-\n-    InetSocketAddress tmp = (InetSocketAddress) bindpoint;\n-\n-    // bind to address/port\n-    try\n-      {\n-\tgetImpl().bind(tmp.getAddress(), tmp.getPort());\n-\tbound = true;\n-      }\n-    catch (IOException exception)\n-      {\n-\tclose();\n-\tthrow exception;\n-      }\n-    catch (RuntimeException exception)\n-      {\n-\tclose();\n-\tthrow exception;\n-      }\n-    catch (Error error)\n-      {\n-\tclose();\n-\tthrow error;\n-      }\n-  }\n-\n-  /**\n-   * Connects the socket with a remote address.\n-   *\n-   * @param endpoint The address to connect to\n-   *\n-   * @exception IOException If an error occurs\n-   * @exception IllegalArgumentException If the addess type is not supported\n-   * @exception IllegalBlockingModeException If this socket has an associated\n-   * channel, and the channel is in non-blocking mode\n-   *\n-   * @since 1.4\n-   */\n-  public void connect(SocketAddress endpoint) throws IOException\n-  {\n-    connect(endpoint, 0);\n-  }\n-\n-  /**\n-   * Connects the socket with a remote address. A timeout of zero is\n-   * interpreted as an infinite timeout. The connection will then block\n-   * until established or an error occurs.\n-   *\n-   * @param endpoint The address to connect to\n-   * @param timeout The length of the timeout in milliseconds, or\n-   * 0 to indicate no timeout.\n-   *\n-   * @exception IOException If an error occurs\n-   * @exception IllegalArgumentException If the address type is not supported\n-   * @exception IllegalBlockingModeException If this socket has an associated\n-   * channel, and the channel is in non-blocking mode\n-   * @exception SocketTimeoutException If the timeout is reached\n-   *\n-   * @since 1.4\n-   */\n-  public void connect(SocketAddress endpoint, int timeout)\n-    throws IOException\n-  {\n-    if (isClosed())\n-      throw new SocketException(\"socket is closed\");\n-\n-    if (! (endpoint instanceof InetSocketAddress))\n-      throw new IllegalArgumentException(\"unsupported address type\");\n-\n-    // The Sun spec says that if we have an associated channel and\n-    // it is in non-blocking mode, we throw an IllegalBlockingModeException.\n-    // However, in our implementation if the channel itself initiated this\n-    // operation, then we must honor it regardless of its blocking mode.\n-    if (getChannel() != null && ! getChannel().isBlocking()\n-        && ! ((PlainSocketImpl) getImpl()).isInChannelOperation())\n-      throw new IllegalBlockingModeException();\n-\n-    if (! isBound())\n-      bind(null);\n-\n-    getImpl().connect(endpoint, timeout);\n-  }\n-\n-  /**\n-   * Returns the address of the remote end of the socket.  If this socket\n-   * is not connected, then <code>null</code> is returned.\n-   *\n-   * @return The remote address this socket is connected to\n-   */\n-  public InetAddress getInetAddress()\n-  {\n-    if (! isConnected())\n-      return null;\n-\n-    try\n-      {\n-\treturn getImpl().getInetAddress();\n-      }\n-    catch (SocketException e)\n-      {\n-\t// This cannot happen as we are connected.\n-      }\n-\n-    return null;\n-  }\n-\n-  /**\n-   * Returns the local address to which this socket is bound.  If this socket\n-   * is not connected, then a wildcard address, for which\n-   * @see InetAddress#isAnyLocalAddress() is <code>true</code>, is returned.\n-   *\n-   * @return The local address\n-   *\n-   * @since 1.1\n-   */\n-  public InetAddress getLocalAddress()\n-  {\n-    if (! isBound())\n-      return InetAddress.ANY_IF;\n-\n-    InetAddress addr = null;\n-\n-    try\n-      {\n-\taddr = (InetAddress) getImpl().getOption(SocketOptions.SO_BINDADDR);\n-      }\n-    catch (SocketException e)\n-      {\n-\t// (hopefully) shouldn't happen\n-\t// throw new java.lang.InternalError\n-\t//      (\"Error in PlainSocketImpl.getOption\");\n-\treturn null;\n-      }\n-\n-    // FIXME: According to libgcj, checkConnect() is supposed to be called\n-    // before performing this operation.  Problems: 1) We don't have the\n-    // addr until after we do it, so we do a post check.  2). The docs I\n-    // see don't require this in the Socket case, only DatagramSocket, but\n-    // we'll assume they mean both.\n-    SecurityManager sm = System.getSecurityManager();\n-    if (sm != null)\n-      sm.checkConnect(addr.getHostName(), getLocalPort());\n-\n-    return addr;\n-  }\n-\n-  /**\n-   * Returns the port number of the remote end of the socket connection.  If\n-   * this socket is not connected, then 0 is returned.\n-   *\n-   * @return The remote port this socket is connected to\n-   */\n-  public int getPort()\n-  {\n-    if (! isConnected())\n-      return 0;\n-\n-    try\n-      {\n-\treturn getImpl().getPort();\n-      }\n-    catch (SocketException e)\n-      {\n-\t// This cannot happen as we are connected.\n-      }\n-\n-    return 0;\n-  }\n-\n-  /**\n-   * Returns the local port number to which this socket is bound.  If this\n-   * socket is not connected, then -1 is returned.\n-   *\n-   * @return The local port\n-   */\n-  public int getLocalPort()\n-  {\n-    if (! isBound())\n-      return -1;\n-\n-    try\n-      {\n-\tif (getImpl() != null)\n-\t  return getImpl().getLocalPort();\n-      }\n-    catch (SocketException e)\n-      {\n-\t// This cannot happen as we are bound.\n-      }\n-\n-    return -1;\n-  }\n-\n-  /**\n-   * Returns local socket address.\n-   *\n-   * @return the local socket address, null if not bound\n-   *\n-   * @since 1.4\n-   */\n-  public SocketAddress getLocalSocketAddress()\n-  {\n-    if (! isBound())\n-      return null;\n-\n-    InetAddress addr = getLocalAddress();\n-\n-    try\n-      {\n-\treturn new InetSocketAddress(addr, getImpl().getLocalPort());\n-      }\n-    catch (SocketException e)\n-      {\n-\t// This cannot happen as we are bound.\n-\treturn null;\n-      }\n-  }\n-\n-  /**\n-   * Returns the remote socket address.\n-   *\n-   * @return the remote socket address, null of not connected\n-   *\n-   * @since 1.4\n-   */\n-  public SocketAddress getRemoteSocketAddress()\n-  {\n-    if (! isConnected())\n-      return null;\n-\n-    try\n-      {\n-\treturn new InetSocketAddress(getImpl().getInetAddress(),\n-\t                             getImpl().getPort());\n-      }\n-    catch (SocketException e)\n-      {\n-\t// This cannot happen as we are connected.\n-\treturn null;\n-      }\n-  }\n-\n-  /**\n-   * Returns an InputStream for reading from this socket.\n-   *\n-   * @return The InputStream object\n-   *\n-   * @exception IOException If an error occurs or Socket is not connected\n-   */\n-  public InputStream getInputStream() throws IOException\n-  {\n-    if (isClosed())\n-      throw new SocketException(\"socket is closed\");\n-\n-    if (! isConnected())\n-      throw new IOException(\"not connected\");\n-\n-    return getImpl().getInputStream();\n-  }\n-\n-  /**\n-   * Returns an OutputStream for writing to this socket.\n-   *\n-   * @return The OutputStream object\n-   *\n-   * @exception IOException If an error occurs or Socket is not connected\n-   */\n-  public OutputStream getOutputStream() throws IOException\n-  {\n-    if (isClosed())\n-      throw new SocketException(\"socket is closed\");\n-\n-    if (! isConnected())\n-      throw new IOException(\"not connected\");\n-\n-    return getImpl().getOutputStream();\n-  }\n-\n-  /**\n-   * Sets the TCP_NODELAY option on the socket.\n-   *\n-   * @param on true to enable, false to disable\n-   *\n-   * @exception SocketException If an error occurs or Socket is not connected\n-   *\n-   * @since 1.1\n-   */\n-  public void setTcpNoDelay(boolean on) throws SocketException\n-  {\n-    if (isClosed())\n-      throw new SocketException(\"socket is closed\");\n-\n-    getImpl().setOption(SocketOptions.TCP_NODELAY, Boolean.valueOf(on));\n-  }\n-\n-  /**\n-   * Tests whether or not the TCP_NODELAY option is set on the socket.\n-   * Returns true if enabled, false if disabled. When on it disables the\n-   * Nagle algorithm which means that packets are always send immediatly and\n-   * never merged together to reduce network trafic.\n-   *\n-   * @return Whether or not TCP_NODELAY is set\n-   *\n-   * @exception SocketException If an error occurs or Socket not connected\n-   *\n-   * @since 1.1\n-   */\n-  public boolean getTcpNoDelay() throws SocketException\n-  {\n-    if (isClosed())\n-      throw new SocketException(\"socket is closed\");\n-\n-    Object on = getImpl().getOption(SocketOptions.TCP_NODELAY);\n-\n-    if (on instanceof Boolean)\n-      return (((Boolean) on).booleanValue());\n-    else\n-      throw new SocketException(\"Internal Error\");\n-  }\n-\n-  /**\n-   * Sets the value of the SO_LINGER option on the socket.  If the\n-   * SO_LINGER option is set on a socket and there is still data waiting to\n-   * be sent when the socket is closed, then the close operation will block\n-   * until either that data is delivered or until the timeout period\n-   * expires.  The linger interval is specified in hundreths of a second\n-   * (platform specific?)\n-   *\n-   * @param on true to enable SO_LINGER, false to disable\n-   * @param linger The SO_LINGER timeout in hundreths of a second or -1 if\n-   * SO_LINGER not set.\n-   *\n-   * @exception SocketException If an error occurs or Socket not connected\n-   * @exception IllegalArgumentException If linger is negative\n-   *\n-   * @since 1.1\n-   */\n-  public void setSoLinger(boolean on, int linger) throws SocketException\n-  {\n-    if (isClosed())\n-      throw new SocketException(\"socket is closed\");\n-\n-    if (on)\n-      {\n-\tif (linger < 0)\n-\t  throw new IllegalArgumentException(\"SO_LINGER must be >= 0\");\n-\n-\tif (linger > 65535)\n-\t  linger = 65535;\n-\n-\tgetImpl().setOption(SocketOptions.SO_LINGER, new Integer(linger));\n-      }\n-    else\n-      getImpl().setOption(SocketOptions.SO_LINGER, Boolean.valueOf(false));\n-  }\n-\n-  /**\n-   * Returns the value of the SO_LINGER option on the socket.  If the\n-   * SO_LINGER option is set on a socket and there is still data waiting to\n-   * be sent when the socket is closed, then the close operation will block\n-   * until either that data is delivered or until the timeout period\n-   * expires.  This method either returns the timeouts (in hundredths of\n-   * of a second (platform specific?)) if SO_LINGER is set, or -1 if\n-   * SO_LINGER is not set.\n-   *\n-   * @return The SO_LINGER timeout in hundreths of a second or -1\n-   * if SO_LINGER not set\n-   *\n-   * @exception SocketException If an error occurs or Socket is not connected\n-   *\n-   * @since 1.1\n-   */\n-  public int getSoLinger() throws SocketException\n-  {\n-    if (isClosed())\n-      throw new SocketException(\"socket is closed\");\n-\n-    Object linger = getImpl().getOption(SocketOptions.SO_LINGER);\n-\n-    if (linger instanceof Integer)\n-      return (((Integer) linger).intValue());\n-    else\n-      return -1;\n-  }\n-\n-  /**\n-   * Sends urgent data through the socket\n-   *\n-   * @param data The data to send.\n-   * Only the lowest eight bits of data are sent\n-   *\n-   * @exception IOException If an error occurs\n-   *\n-   * @since 1.4\n-   */\n-  public void sendUrgentData(int data) throws IOException\n-  {\n-    if (isClosed())\n-      throw new SocketException(\"socket is closed\");\n-\n-    getImpl().sendUrgentData(data);\n-  }\n-\n-  /**\n-   * Enables/disables the SO_OOBINLINE option\n-   *\n-   * @param on True if SO_OOBLINE should be enabled\n-   *\n-   * @exception SocketException If an error occurs\n-   *\n-   * @since 1.4\n-   */\n-  public void setOOBInline(boolean on) throws SocketException\n-  {\n-    if (isClosed())\n-      throw new SocketException(\"socket is closed\");\n-\n-    getImpl().setOption(SocketOptions.SO_OOBINLINE, Boolean.valueOf(on));\n-  }\n-\n-  /**\n-   * Returns the current setting of the SO_OOBINLINE option for this socket\n-   *\n-   * @return True if SO_OOBINLINE is set, false otherwise.\n-   *\n-   * @exception SocketException If an error occurs\n-   *\n-   * @since 1.4\n-   */\n-  public boolean getOOBInline() throws SocketException\n-  {\n-    if (isClosed())\n-      throw new SocketException(\"socket is closed\");\n-\n-    Object buf = getImpl().getOption(SocketOptions.SO_OOBINLINE);\n-\n-    if (buf instanceof Boolean)\n-      return (((Boolean) buf).booleanValue());\n-    else\n-      throw new SocketException(\"Internal Error: Unexpected type\");\n-  }\n-\n-  /**\n-   * Sets the value of the SO_TIMEOUT option on the socket.  If this value\n-   * is set, and an read/write is performed that does not complete within\n-   * the timeout period, a short count is returned (or an EWOULDBLOCK signal\n-   * would be sent in Unix if no data had been read).  A value of 0 for\n-   * this option implies that there is no timeout (ie, operations will\n-   * block forever).  On systems that have separate read and write timeout\n-   * values, this method returns the read timeout.  This\n-   * value is in milliseconds.\n-   *\n-   * @param timeout The length of the timeout in milliseconds, or\n-   * 0 to indicate no timeout.\n-   *\n-   * @exception SocketException If an error occurs or Socket not connected\n-   *\n-   * @since 1.1\n-   */\n-  public synchronized void setSoTimeout(int timeout) throws SocketException\n-  {\n-    if (isClosed())\n-      throw new SocketException(\"socket is closed\");\n-\n-    if (timeout < 0)\n-      throw new IllegalArgumentException(\"SO_TIMEOUT value must be >= 0\");\n-\n-    getImpl().setOption(SocketOptions.SO_TIMEOUT, new Integer(timeout));\n-  }\n-\n-  /**\n-   * Returns the value of the SO_TIMEOUT option on the socket.  If this value\n-   * is set, and an read/write is performed that does not complete within\n-   * the timeout period, a short count is returned (or an EWOULDBLOCK signal\n-   * would be sent in Unix if no data had been read).  A value of 0 for\n-   * this option implies that there is no timeout (ie, operations will\n-   * block forever).  On systems that have separate read and write timeout\n-   * values, this method returns the read timeout.  This\n-   * value is in thousandths of a second (implementation specific?).\n-   *\n-   * @return The length of the timeout in thousandth's of a second or 0\n-   * if not set\n-   *\n-   * @exception SocketException If an error occurs or Socket not connected\n-   *\n-   * @since 1.1\n-   */\n-  public synchronized int getSoTimeout() throws SocketException\n-  {\n-    if (isClosed())\n-      throw new SocketException(\"socket is closed\");\n-\n-    Object timeout = getImpl().getOption(SocketOptions.SO_TIMEOUT);\n-    if (timeout instanceof Integer)\n-      return (((Integer) timeout).intValue());\n-    else\n-      return 0;\n-  }\n-\n-  /**\n-   * This method sets the value for the system level socket option\n-   * SO_SNDBUF to the specified value.  Note that valid values for this\n-   * option are specific to a given operating system.\n-   *\n-   * @param size The new send buffer size.\n-   *\n-   * @exception SocketException If an error occurs or Socket not connected\n-   * @exception IllegalArgumentException If size is 0 or negative\n-   *\n-   * @since 1.2\n-   */\n-  public void setSendBufferSize(int size) throws SocketException\n-  {\n-    if (isClosed())\n-      throw new SocketException(\"socket is closed\");\n-\n-    if (size <= 0)\n-      throw new IllegalArgumentException(\"SO_SNDBUF value must be > 0\");\n-\n-    getImpl().setOption(SocketOptions.SO_SNDBUF, new Integer(size));\n-  }\n-\n-  /**\n-   * This method returns the value of the system level socket option\n-   * SO_SNDBUF, which is used by the operating system to tune buffer\n-   * sizes for data transfers.\n-   *\n-   * @return The send buffer size.\n-   *\n-   * @exception SocketException If an error occurs or socket not connected\n-   *\n-   * @since 1.2\n-   */\n-  public int getSendBufferSize() throws SocketException\n-  {\n-    if (isClosed())\n-      throw new SocketException(\"socket is closed\");\n-\n-    Object buf = getImpl().getOption(SocketOptions.SO_SNDBUF);\n-\n-    if (buf instanceof Integer)\n-      return (((Integer) buf).intValue());\n-    else\n-      throw new SocketException(\"Internal Error: Unexpected type\");\n-  }\n-\n-  /**\n-   * This method sets the value for the system level socket option\n-   * SO_RCVBUF to the specified value.  Note that valid values for this\n-   * option are specific to a given operating system.\n-   *\n-   * @param size The new receive buffer size.\n-   *\n-   * @exception SocketException If an error occurs or Socket is not connected\n-   * @exception IllegalArgumentException If size is 0 or negative\n-   *\n-   * @since 1.2\n-   */\n-  public void setReceiveBufferSize(int size) throws SocketException\n-  {\n-    if (isClosed())\n-      throw new SocketException(\"socket is closed\");\n-\n-    if (size <= 0)\n-      throw new IllegalArgumentException(\"SO_RCVBUF value must be > 0\");\n-\n-    getImpl().setOption(SocketOptions.SO_RCVBUF, new Integer(size));\n-  }\n-\n-  /**\n-   * This method returns the value of the system level socket option\n-   * SO_RCVBUF, which is used by the operating system to tune buffer\n-   * sizes for data transfers.\n-   *\n-   * @return The receive buffer size.\n-   *\n-   * @exception SocketException If an error occurs or Socket is not connected\n-   *\n-   * @since 1.2\n-   */\n-  public int getReceiveBufferSize() throws SocketException\n-  {\n-    if (isClosed())\n-      throw new SocketException(\"socket is closed\");\n-\n-    Object buf = getImpl().getOption(SocketOptions.SO_RCVBUF);\n-\n-    if (buf instanceof Integer)\n-      return (((Integer) buf).intValue());\n-    else\n-      throw new SocketException(\"Internal Error: Unexpected type\");\n-  }\n-\n-  /**\n-   * This method sets the value for the socket level socket option\n-   * SO_KEEPALIVE.\n-   *\n-   * @param on True if SO_KEEPALIVE should be enabled\n-   *\n-   * @exception SocketException If an error occurs or Socket is not connected\n-   *\n-   * @since 1.3\n-   */\n-  public void setKeepAlive(boolean on) throws SocketException\n-  {\n-    if (isClosed())\n-      throw new SocketException(\"socket is closed\");\n-\n-    getImpl().setOption(SocketOptions.SO_KEEPALIVE, Boolean.valueOf(on));\n-  }\n-\n-  /**\n-   * This method returns the value of the socket level socket option\n-   * SO_KEEPALIVE.\n-   *\n-   * @return The setting\n-   *\n-   * @exception SocketException If an error occurs or Socket is not connected\n-   *\n-   * @since 1.3\n-   */\n-  public boolean getKeepAlive() throws SocketException\n-  {\n-    if (isClosed())\n-      throw new SocketException(\"socket is closed\");\n-\n-    Object buf = getImpl().getOption(SocketOptions.SO_KEEPALIVE);\n-\n-    if (buf instanceof Boolean)\n-      return (((Boolean) buf).booleanValue());\n-    else\n-      throw new SocketException(\"Internal Error: Unexpected type\");\n-  }\n-\n-  /**\n-   * Closes the socket.\n-   *\n-   * @exception IOException If an error occurs\n-   */\n-  public synchronized void close() throws IOException\n-  {\n-    if (isClosed())\n-      return;\n-\n-    getImpl().close();\n-    impl = null;\n-    bound = false;\n-\n-    if (getChannel() != null)\n-      getChannel().close();\n-  }\n-\n-  /**\n-   * Converts this <code>Socket</code> to a <code>String</code>.\n-   *\n-   * @return The <code>String</code> representation of this <code>Socket</code>\n-   */\n-  public String toString()\n-  {\n-    try\n-      {\n-\tif (isConnected())\n-\t  return (\"Socket[addr=\" + getImpl().getInetAddress() + \",port=\"\n-\t         + getImpl().getPort() + \",localport=\"\n-\t         + getImpl().getLocalPort() + \"]\");\n-      }\n-    catch (SocketException e)\n-      {\n-\t// This cannot happen as we are connected.\n-      }\n-\n-    return \"Socket[unconnected]\";\n-  }\n-\n-  /**\n-   * Sets the <code>SocketImplFactory</code>.  This may be done only once per\n-   * virtual machine.  Subsequent attempts will generate a\n-   * <code>SocketException</code>.  Note that a <code>SecurityManager</code>\n-   * check is made prior to setting the factory.  If\n-   * insufficient privileges exist to set the factory, then an\n-   * <code>IOException</code> will be thrown.\n-   *\n-   * @param fac the factory to set\n-   *\n-   * @exception SecurityException If the <code>SecurityManager</code> does\n-   * not allow this operation.\n-   * @exception SocketException If the SocketImplFactory is already defined\n-   * @exception IOException If any other error occurs\n-   */\n-  public static synchronized void setSocketImplFactory(SocketImplFactory fac)\n-    throws IOException\n-  {\n-    // See if already set\n-    if (factory != null)\n-      throw new SocketException(\"SocketImplFactory already defined\");\n-\n-    // Check permissions\n-    SecurityManager sm = System.getSecurityManager();\n-    if (sm != null)\n-      sm.checkSetFactory();\n-\n-    if (fac == null)\n-      throw new SocketException(\"SocketImplFactory cannot be null\");\n-\n-    factory = fac;\n-  }\n-\n-  /**\n-   * Closes the input side of the socket stream.\n-   *\n-   * @exception IOException If an error occurs.\n-   *\n-   * @since 1.3\n-   */\n-  public void shutdownInput() throws IOException\n-  {\n-    if (isClosed())\n-      throw new SocketException(\"socket is closed\");\n-\n-    getImpl().shutdownInput();\n-    inputShutdown = true;\n-  }\n-\n-  /**\n-   * Closes the output side of the socket stream.\n-   *\n-   * @exception IOException If an error occurs.\n-   *\n-   * @since 1.3\n-   */\n-  public void shutdownOutput() throws IOException\n-  {\n-    if (isClosed())\n-      throw new SocketException(\"socket is closed\");\n-\n-    getImpl().shutdownOutput();\n-    outputShutdown = true;\n-  }\n-\n-  /**\n-   * Returns the socket channel associated with this socket.\n-   *\n-   * @return the associated socket channel,\n-   * null if no associated channel exists\n-   *\n-   * @since 1.4\n-   */\n-  public SocketChannel getChannel()\n-  {\n-    return null;\n-  }\n-\n-  /**\n-   * Checks if the SO_REUSEADDR option is enabled\n-   *\n-   * @return True if SO_REUSEADDR is set, false otherwise.\n-   *\n-   * @exception SocketException If an error occurs\n-   *\n-   * @since 1.4\n-   */\n-  public boolean getReuseAddress() throws SocketException\n-  {\n-    if (isClosed())\n-      throw new SocketException(\"socket is closed\");\n-\n-    Object reuseaddr = getImpl().getOption(SocketOptions.SO_REUSEADDR);\n-\n-    if (! (reuseaddr instanceof Boolean))\n-      throw new SocketException(\"Internal Error\");\n-\n-    return ((Boolean) reuseaddr).booleanValue();\n-  }\n-\n-  /**\n-   * Enables/Disables the SO_REUSEADDR option\n-   *\n-   * @param reuseAddress true if SO_REUSEADDR should be enabled,\n-   * false otherwise\n-   *\n-   * @exception SocketException If an error occurs\n-   *\n-   * @since 1.4\n-   */\n-  public void setReuseAddress(boolean reuseAddress) throws SocketException\n-  {\n-    if (isClosed())\n-      throw new SocketException(\"socket is closed\");\n-\n-    getImpl().setOption(SocketOptions.SO_REUSEADDR,\n-                        Boolean.valueOf(reuseAddress));\n-  }\n-\n-  /**\n-   * Returns the current traffic class\n-   *\n-   * @return The current traffic class.\n-   *\n-   * @exception SocketException If an error occurs\n-   *\n-   * @see Socket#setTrafficClass(int tc)\n-   *\n-   * @since 1.4\n-   */\n-  public int getTrafficClass() throws SocketException\n-  {\n-    if (isClosed())\n-      throw new SocketException(\"socket is closed\");\n-\n-    Object obj = getImpl().getOption(SocketOptions.IP_TOS);\n-\n-    if (obj instanceof Integer)\n-      return ((Integer) obj).intValue();\n-    else\n-      throw new SocketException(\"Unexpected type\");\n-  }\n-\n-  /**\n-   * Sets the traffic class value\n-   *\n-   * @param tc The traffic class\n-   *\n-   * @exception SocketException If an error occurs\n-   * @exception IllegalArgumentException If tc value is illegal\n-   *\n-   * @see Socket#getTrafficClass()\n-   *\n-   * @since 1.4\n-   */\n-  public void setTrafficClass(int tc) throws SocketException\n-  {\n-    if (isClosed())\n-      throw new SocketException(\"socket is closed\");\n-\n-    if (tc < 0 || tc > 255)\n-      throw new IllegalArgumentException();\n-\n-    getImpl().setOption(SocketOptions.IP_TOS, new Integer(tc));\n-  }\n-\n-  /**\n-   * Checks if the socket is connected\n-   *\n-   * @return True if socket is connected, false otherwise.\n-   *\n-   * @since 1.4\n-   */\n-  public boolean isConnected()\n-  {\n-    try\n-      {\n-\tif (getImpl() == null)\n-\t  return false;\n-\n-\treturn getImpl().getInetAddress() != null;\n-      }\n-    catch (SocketException e)\n-      {\n-\treturn false;\n-      }\n-  }\n-\n-  /**\n-   * Checks if the socket is already bound.\n-   *\n-   * @return True if socket is bound, false otherwise.\n-   *\n-   * @since 1.4\n-   */\n-  public boolean isBound()\n-  {\n-    return bound;\n-  }\n-\n-  /**\n-   * Checks if the socket is closed.\n-   *\n-   * @return True if socket is closed, false otherwise.\n-   *\n-   * @since 1.4\n-   */\n-  public boolean isClosed()\n-  {\n-    return impl == null;\n-  }\n-\n-  /**\n-   * Checks if the socket's input stream is shutdown\n-   *\n-   * @return True if input is shut down.\n-   *\n-   * @since 1.4\n-   */\n-  public boolean isInputShutdown()\n-  {\n-    return inputShutdown;\n-  }\n-\n-  /**\n-   * Checks if the socket's output stream is shutdown\n-   *\n-   * @return True if output is shut down.\n-   *\n-   * @since 1.4\n-   */\n-  public boolean isOutputShutdown()\n-  {\n-    return outputShutdown;\n-  }\n-}"}, {"sha": "0c9953f33b9af2178440dd2d4058e2b2aba8f6dd", "filename": "libjava/sources.am", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40b86e5f2cf069832e23043992dedb0bf8e0dcd6/libjava%2Fsources.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40b86e5f2cf069832e23043992dedb0bf8e0dcd6/libjava%2Fsources.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fsources.am?ref=40b86e5f2cf069832e23043992dedb0bf8e0dcd6", "patch": "@@ -4905,7 +4905,7 @@ classpath/java/net/ConnectException.java \\\n classpath/java/net/ContentHandler.java \\\n classpath/java/net/ContentHandlerFactory.java \\\n classpath/java/net/DatagramPacket.java \\\n-java/net/DatagramSocket.java \\\n+classpath/java/net/DatagramSocket.java \\\n classpath/java/net/DatagramSocketImpl.java \\\n classpath/java/net/DatagramSocketImplFactory.java \\\n classpath/java/net/FileNameMap.java \\\n@@ -4928,7 +4928,7 @@ classpath/java/net/Proxy.java \\\n classpath/java/net/ProxySelector.java \\\n classpath/java/net/ResolverCache.java \\\n classpath/java/net/ServerSocket.java \\\n-java/net/Socket.java \\\n+classpath/java/net/Socket.java \\\n classpath/java/net/SocketAddress.java \\\n classpath/java/net/SocketException.java \\\n classpath/java/net/SocketImpl.java \\"}]}