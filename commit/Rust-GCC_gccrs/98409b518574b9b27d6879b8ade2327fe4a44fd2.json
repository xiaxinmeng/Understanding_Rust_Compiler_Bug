{"sha": "98409b518574b9b27d6879b8ade2327fe4a44fd2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTg0MDliNTE4NTc0YjliMjdkNjg3OWI4YWRlMjMyN2ZlNGE0NGZkMg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@linux.vnet.ibm.com", "date": "2013-05-22T09:21:25Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2013-05-22T09:21:25Z"}, "message": "recog.c (offsettable_address_addr_space_p): Fix calculation of address mode.\n\ngcc/\n\t* recog.c (offsettable_address_addr_space_p): Fix calculation of\n\taddress mode.  Move pointer mode initialization to the same place.\n\nFrom-SVN: r199188", "tree": {"sha": "0b4a5011bb6106a2adaa12a48980ed7061ca6006", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b4a5011bb6106a2adaa12a48980ed7061ca6006"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/98409b518574b9b27d6879b8ade2327fe4a44fd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98409b518574b9b27d6879b8ade2327fe4a44fd2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98409b518574b9b27d6879b8ade2327fe4a44fd2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98409b518574b9b27d6879b8ade2327fe4a44fd2/comments", "author": null, "committer": null, "parents": [{"sha": "5951f9dfd2f76609cd8f95177d2740416d753245", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5951f9dfd2f76609cd8f95177d2740416d753245", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5951f9dfd2f76609cd8f95177d2740416d753245"}], "stats": {"total": 25, "additions": 17, "deletions": 8}, "files": [{"sha": "16cd2d97a3a83f571a7d9869fc454eddbe50ba0a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98409b518574b9b27d6879b8ade2327fe4a44fd2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98409b518574b9b27d6879b8ade2327fe4a44fd2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=98409b518574b9b27d6879b8ade2327fe4a44fd2", "patch": "@@ -1,3 +1,8 @@\n+2013-05-22  Richard Sandiford  <rsandifo@linux.vnet.ibm.com>\n+\n+\t* recog.c (offsettable_address_addr_space_p): Fix calculation of\n+\taddress mode.  Move pointer mode initialization to the same place.\n+\n 2013-05-22  Michael Zolotukhin  <michael.v.zolotukhin@intel.com>\n \n \t* read-rtl.c (copy_rtx_for_iterators): Continue applying iterators"}, {"sha": "0e6277d0424498d9ba7cdc9cdfccc8568cb76b33", "filename": "gcc/recog.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98409b518574b9b27d6879b8ade2327fe4a44fd2/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98409b518574b9b27d6879b8ade2327fe4a44fd2/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=98409b518574b9b27d6879b8ade2327fe4a44fd2", "patch": "@@ -1953,9 +1953,6 @@ offsettable_address_addr_space_p (int strictp, enum machine_mode mode, rtx y,\n     (strictp ? strict_memory_address_addr_space_p\n \t     : memory_address_addr_space_p);\n   unsigned int mode_sz = GET_MODE_SIZE (mode);\n-#ifdef POINTERS_EXTEND_UNSIGNED\n-  enum machine_mode pointer_mode = targetm.addr_space.pointer_mode (as);\n-#endif\n \n   if (CONSTANT_ADDRESS_P (y))\n     return 1;\n@@ -1966,6 +1963,13 @@ offsettable_address_addr_space_p (int strictp, enum machine_mode mode, rtx y,\n   if (mode_dependent_address_p (y, as))\n     return 0;\n \n+  enum machine_mode address_mode = GET_MODE (y);\n+  if (address_mode == VOIDmode)\n+    address_mode = targetm.addr_space.address_mode (as);\n+#ifdef POINTERS_EXTEND_UNSIGNED\n+  enum machine_mode pointer_mode = targetm.addr_space.pointer_mode (as);\n+#endif\n+\n   /* ??? How much offset does an offsettable BLKmode reference need?\n      Clearly that depends on the situation in which it's being used.\n      However, the current situation in which we test 0xffffffff is\n@@ -1981,7 +1985,7 @@ offsettable_address_addr_space_p (int strictp, enum machine_mode mode, rtx y,\n       int good;\n \n       y1 = *y2;\n-      *y2 = plus_constant (GET_MODE (y), *y2, mode_sz - 1);\n+      *y2 = plus_constant (address_mode, *y2, mode_sz - 1);\n       /* Use QImode because an odd displacement may be automatically invalid\n \t for any wider mode.  But it should be valid for a single byte.  */\n       good = (*addressp) (QImode, y, as);\n@@ -2002,20 +2006,20 @@ offsettable_address_addr_space_p (int strictp, enum machine_mode mode, rtx y,\n   if (GET_CODE (y) == LO_SUM\n       && mode != BLKmode\n       && mode_sz <= GET_MODE_ALIGNMENT (mode) / BITS_PER_UNIT)\n-    z = gen_rtx_LO_SUM (GET_MODE (y), XEXP (y, 0),\n-\t\t\tplus_constant (GET_MODE (y), XEXP (y, 1),\n+    z = gen_rtx_LO_SUM (address_mode, XEXP (y, 0),\n+\t\t\tplus_constant (address_mode, XEXP (y, 1),\n \t\t\t\t       mode_sz - 1));\n #ifdef POINTERS_EXTEND_UNSIGNED\n   /* Likewise for a ZERO_EXTEND from pointer_mode.  */\n   else if (POINTERS_EXTEND_UNSIGNED > 0\n \t   && GET_CODE (y) == ZERO_EXTEND\n \t   && GET_MODE (XEXP (y, 0)) == pointer_mode)\n-    z = gen_rtx_ZERO_EXTEND (GET_MODE (y),\n+    z = gen_rtx_ZERO_EXTEND (address_mode,\n \t\t\t     plus_constant (pointer_mode, XEXP (y, 0),\n \t\t\t\t\t    mode_sz - 1));\n #endif\n   else\n-    z = plus_constant (GET_MODE (y), y, mode_sz - 1);\n+    z = plus_constant (address_mode, y, mode_sz - 1);\n \n   /* Use QImode because an odd displacement may be automatically invalid\n      for any wider mode.  But it should be valid for a single byte.  */"}]}