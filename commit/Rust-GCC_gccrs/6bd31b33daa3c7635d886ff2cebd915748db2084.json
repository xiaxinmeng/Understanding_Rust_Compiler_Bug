{"sha": "6bd31b33daa3c7635d886ff2cebd915748db2084", "node_id": "C_kwDOANBUbNoAKDZiZDMxYjMzZGFhM2M3NjM1ZDg4NmZmMmNlYmQ5MTU3NDhkYjIwODQ", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-11-22T22:29:21Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-11-22T22:29:21Z"}, "message": "analyzer: eliminate region_model::impl_call_* special cases\n\nEliminate all of the remaining special cases in class region_model that\nhandle various specific functions, replacing them with uses of\nknown_function subclasses.\n\nAdd various type-checks that ought to prevent ICEs for cases where\nfunctions match the name of a standard C library or POSIX function, but\nhave incompatible arguments.\n\ngcc/analyzer/ChangeLog:\n\t* analyzer.h (class internal_known_function): New.\n\t(register_varargs_builtins): New decl.\n\t* engine.cc (exploded_node::on_stmt_pre): Remove\n\t\"out_terminate_path\" param from call to region_model::on_stmt_pre.\n\t(feasibility_state::maybe_update_for_edge): Likewise.\n\t* known-function-manager.cc: Include \"basic-block.h\", \"gimple.h\",\n\tand \"analyzer/region-model.h\".\n\t(known_function_manager::known_function_manager): Initialize\n\tm_combined_fns_arr.\n\t(known_function_manager::~known_function_manager): Clean up\n\tm_combined_fns_arr.\n\t(known_function_manager::get_by_identifier): Make const.\n\t(known_function_manager::add): New overloaded definitions for\n\tenum built_in_function and enum internal_fn.\n\t(known_function_manager::get_by_fndecl): Delete.\n\t(known_function_manager::get_match): New.\n\t(known_function_manager::get_internal_fn): New.\n\t(known_function_manager::get_normal_builtin): New.\n\t* known-function-manager.h\n\t(known_function_manager::get_by_identifier): Make private and\n\tadd const qualifier.\n\t(known_function_manager::get_by_fndecl): Delete.\n\t(known_function_manager::add): Add overloaded decls for\n\tenum built_in_function name and enum internal_fn.\n\t(known_function_manager::get_match): New decl.\n\t(known_function_manager::get_internal_fn): New decl.\n\t(known_function_manager::get_normal_builtin): New decl.\n\t(known_function_manager::m_combined_fns_arr): New field.\n\t* region-model-impl-calls.cc (call_details::arg_is_size_p): New.\n\t(class kf_alloca): New.\n\t(region_model::impl_call_alloca): Convert to...\n\t(kf_alloca::impl_call_pre): ...this.\n\t(kf_analyzer_dump_capacity::matches_call_types_p): Rewrite check\n\tto use call_details::arg_is_pointer_p.\n\t(region_model::impl_call_builtin_expect): Convert to...\n\t(class kf_expect): ...this.\n\t(class kf_calloc): New, adding check that both arguments are\n\tsize_t.\n\t(region_model::impl_call_calloc): Convert to...\n\t(kf_calloc::impl_call_pre): ...this.\n\t(kf_connect::matches_call_types_p): Rewrite check to use\n\tcall_details::arg_is_pointer_p.\n\t(region_model::impl_call_error): Convert to...\n\t(class kf_error): ...this, and...\n\t(kf_error::impl_call_pre): ...this.\n\t(class kf_fgets): New, adding checks that args 0 and 2 are\n\tpointers.\n\t(region_model::impl_call_fgets): Convert to...\n\t(kf_fgets::impl_call_pre): ...this.\n\t(class kf_fread): New, adding checks on the argument types.\n\t(region_model::impl_call_fread): Convert to...\n\t(kf_fread::impl_call_pre): ...this.\n\t(class kf_free): New, adding check that the argument is a pointer.\n\t(region_model::impl_call_free): Convert to...\n\t(kf_free::impl_call_post): ...this.\n\t(class kf_getchar): New.\n\t(class kf_malloc): New, adding check that the argument is a\n\tsize_t.\n\t(region_model::impl_call_malloc): Convert to...\n\t(kf_malloc::impl_call_pre): ...this.\n\t(class kf_memcpy): New, adding checks on arguments.\n\t(region_model::impl_call_memcpy): Convert to...\n\t(kf_memcpy::impl_call_pre): ...this.\n\t(class kf_memset): New.\n\t(region_model::impl_call_memset): Convert to...\n\t(kf_memset::impl_call_pre): ...this.\n\t(kf_pipe::matches_call_types_p): Rewrite check to use\n\tcall_details::arg_is_pointer_p.\n\t(kf_putenv::matches_call_types_p): Likewise.\n\t(class kf_realloc): New, adding checks on the argument types.\n\t(region_model::impl_call_realloc): Convert to...\n\t(kf_realloc::impl_call_post): ...this.\n\t(class kf_strchr): New.\n\t(region_model::impl_call_strchr): Convert to...\n\t(kf_strchr::impl_call_post): ...this.\n\t(class kf_stack_restore): New.\n\t(class kf_stack_save): New.\n\t(class kf_stdio_output_fn): New.\n\t(class kf_strcpy): New,\n\t(region_model::impl_call_strcpy): Convert to...\n\t(kf_strcpy::impl_call_pre): ...this.\n\t(class kf_strlen): New.\n\t(region_model::impl_call_strlen): Convert to...\n\t(kf_strlen::impl_call_pre): ...this.\n\t(class kf_ubsan_bounds): New.\n\t(region_model::impl_deallocation_call): Reimplement to avoid call\n\tto impl_call_free.\n\t(register_known_functions): Add handlers for IFN_BUILTIN_EXPECT\n\tand IFN_UBSAN_BOUNDS.  Add handlers for BUILT_IN_ALLOCA,\n\tBUILT_IN_ALLOCA_WITH_ALIGN, BUILT_IN_CALLOC, BUILT_IN_EXPECT,\n\tBUILT_IN_EXPECT_WITH_PROBABILITY, BUILT_IN_FPRINTF,\n\tBUILT_IN_FPRINTF_UNLOCKED, BUILT_IN_FPUTC,\n\tBUILT_IN_FPUTC_UNLOCKED, BUILT_IN_FPUTS, BUILT_IN_FPUTS_UNLOCKED,\n\tBUILT_IN_FREE, BUILT_IN_FWRITE, BUILT_IN_FWRITE_UNLOCKED,\n\tBUILT_IN_MALLOC, BUILT_IN_MEMCPY, BUILT_IN_MEMCPY_CHK,\n\tBUILT_IN_MEMSET, BUILT_IN_MEMSET_CHK, BUILT_IN_PRINTF,\n\tBUILT_IN_PRINTF_UNLOCKED, BUILT_IN_PUTC, BUILT_IN_PUTCHAR,\n\tBUILT_IN_PUTCHAR_UNLOCKED, BUILT_IN_PUTC_UNLOCKED, BUILT_IN_PUTS,\n\tBUILT_IN_PUTS_UNLOCKED, BUILT_IN_REALLOC, BUILT_IN_STACK_RESTORE,\n\tBUILT_IN_STACK_SAVE, BUILT_IN_STRCHR, BUILT_IN_STRCPY,\n\tBUILT_IN_STRCPY_CHK, BUILT_IN_STRLEN, BUILT_IN_VFPRINTF, and\n\tBUILT_IN_VPRINTF. Call register_varargs_builtins.  Add handlers\n\tfor \"getchar\", \"memset\", \"fgets\", \"fgets_unlocked\", \"fread\",\n\t\"error\", and \"error_at_line\".\n\t* region-model.cc (region_model::on_stmt_pre): Drop\n\t\"out_terminate_path\" param.\n\t(region_model::get_known_function): Reimplement by calling\n\tknown_function_manager::get_match, passing new \"cd\" param.\n\tAdd overload taking enum internal_fn.\n\t(region_model::on_call_pre): Drop \"out_terminate_path\" param.\n\tRemove special-case handling of internal fns IFN_BUILTIN_EXPECT,\n\tIFN_UBSAN_BOUNDS, and IFN_VA_ARG, of built-in fns BUILT_IN_ALLOCA,\n\tBUILT_IN_ALLOCA_WITH_ALIGN, BUILT_IN_CALLOC, BUILT_IN_EXPECT,\n\tBUILT_IN_EXPECT_WITH_PROBABILITY, BUILT_IN_FREE, BUILT_IN_MALLOC,\n\tBUILT_IN_MEMCPY, BUILT_IN_MEMCPY_CHK, BUILT_IN_MEMSET,\n\tBUILT_IN_MEMSET_CHK, BUILT_IN_REALLOC, BUILT_IN_STRCHR,\n\tBUILT_IN_STRCPY, BUILT_IN_STRCPY_CHK, BUILT_IN_STRLEN,\n\tBUILT_IN_STACK_SAVE, BUILT_IN_STACK_RESTORE, BUILT_IN_FPRINTF,\n\tBUILT_IN_FPRINTF_UNLOCKED, BUILT_IN_PUTC, BUILT_IN_PUTC_UNLOCKED,\n\tBUILT_IN_FPUTC, BUILT_IN_FPUTC_UNLOCKED, BUILT_IN_FPUTS,\n\tBUILT_IN_FPUTS_UNLOCKED, BUILT_IN_FWRITE,\n\tBUILT_IN_FWRITE_UNLOCKED, BUILT_IN_PRINTF,\n\tBUILT_IN_PRINTF_UNLOCKED, BUILT_IN_PUTCHAR,\n\tBUILT_IN_PUTCHAR_UNLOCKED, BUILT_IN_PUTS, BUILT_IN_PUTS_UNLOCKED,\n\tBUILT_IN_VFPRINTF, BUILT_IN_VPRINTF, BUILT_IN_VA_START, and\n\tBUILT_IN_VA_COPY, and of named functions \"malloc\", \"calloc\",\n\t\"alloca\", \"realloc\", \"error\", \"error_at_line\", \"fgets\",\n\t\"fgets_unlocked\", \"fread\", \"getchar\", \"memset\", \"strchr\", and\n\t\"strlen\".  Replace all this special-casing with calls to\n\tget_known_function for internal fns and for fn decls.\n\t(region_model::on_call_post): Remove special-casing handling for\n\t\"free\" and \"strchr\", and for BUILT_IN_REALLOC, BUILT_IN_STRCHR,\n\tand BUILT_IN_VA_END.  Replace by consolidating on usage of\n\tget_known_function.\n\t* region-model.h (call_details::arg_is_size_p): New.\n\t(region_model::on_stmt_pre): Drop \"out_terminate_path\" param.\n\t(region_model::on_call_pre): Likewise.\n\t(region_model::impl_call_alloca): Delete.\n\t(region_model::impl_call_builtin_expect): Delete.\n\t(region_model::impl_call_calloc): Delete.\n\t(region_model::impl_call_error): Delete.\n\t(region_model::impl_call_fgets): Delete.\n\t(region_model::impl_call_fread): Delete.\n\t(region_model::impl_call_free): Delete.\n\t(region_model::impl_call_malloc): Delete.\n\t(region_model::impl_call_memcpy): Delete.\n\t(region_model::impl_call_memset): Delete.\n\t(region_model::impl_call_realloc): Delete.\n\t(region_model::impl_call_strchr): Delete.\n\t(region_model::impl_call_strcpy): Delete.\n\t(region_model::impl_call_strlen): Delete.\n\t(region_model::impl_call_va_start): Delete.\n\t(region_model::impl_call_va_copy): Delete.\n\t(region_model::impl_call_va_arg): Delete.\n\t(region_model::impl_call_va_end): Delete.\n\t(region_model::check_region_for_write): Public.\n\t(region_model::get_known_function): Add \"cd\" param.  Add\n\toverloaded decl taking enum internal_fn.\n\t* sm-malloc.cc: Update comments.\n\t* varargs.cc (class kf_va_start): New.\n\t(region_model::impl_call_va_start): Convert to...\n\t(kf_va_start::impl_call_pre): ...this.\n\t(class kf_va_copy): New.\n\t(region_model::impl_call_va_copy): Convert to...\n\t(kf_va_copy::impl_call_pre): ...this.\n\t(class kf_va_arg): New.\n\t(region_model::impl_call_va_arg): Convert to...\n\t(kf_va_arg::impl_call_pre): ...this.\n\t(class kf_va_end): New.\n\t(region_model::impl_call_va_end): Delete.\n\t(register_varargs_builtins): New.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "11cc6160bae24de4c8be221257bf9743ed65aca4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/11cc6160bae24de4c8be221257bf9743ed65aca4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6bd31b33daa3c7635d886ff2cebd915748db2084", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bd31b33daa3c7635d886ff2cebd915748db2084", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bd31b33daa3c7635d886ff2cebd915748db2084", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bd31b33daa3c7635d886ff2cebd915748db2084/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "936d40b9ba9cdf8571bc5c366f3d3237cabc30c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/936d40b9ba9cdf8571bc5c366f3d3237cabc30c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/936d40b9ba9cdf8571bc5c366f3d3237cabc30c2"}], "stats": {"total": 1063, "additions": 648, "deletions": 415}, "files": [{"sha": "d424b43f2de2cf5f099437acd7884d4e77aa787c", "filename": "gcc/analyzer/analyzer.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bd31b33daa3c7635d886ff2cebd915748db2084/gcc%2Fanalyzer%2Fanalyzer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bd31b33daa3c7635d886ff2cebd915748db2084/gcc%2Fanalyzer%2Fanalyzer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.h?ref=6bd31b33daa3c7635d886ff2cebd915748db2084", "patch": "@@ -245,7 +245,20 @@ class known_function\n   }\n };\n \n+/* Subclass of known_function for IFN_* functions.  */\n+\n+class internal_known_function : public known_function\n+{\n+public:\n+  bool matches_call_types_p (const call_details &) const final override\n+  {\n+    /* Types are assumed to be correct.  */\n+    return true;\n+  }\n+};\n+\n extern void register_known_functions (known_function_manager &mgr);\n+extern void register_varargs_builtins (known_function_manager &kfm);\n \n /* Passed by pointer to PLUGIN_ANALYZER_INIT callbacks.  */\n "}, {"sha": "0c49bb2687270566f977c9f5b6872c92ecd3c717", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bd31b33daa3c7635d886ff2cebd915748db2084/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bd31b33daa3c7635d886ff2cebd915748db2084/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=6bd31b33daa3c7635d886ff2cebd915748db2084", "patch": "@@ -1538,7 +1538,6 @@ exploded_node::on_stmt_pre (exploded_graph &eg,\n \n   /* Otherwise, defer to m_region_model.  */\n   state->m_region_model->on_stmt_pre (stmt,\n-\t\t\t\t      out_terminate_path,\n \t\t\t\t      out_unknown_side_effects,\n \t\t\t\t      ctxt);\n }\n@@ -4839,9 +4838,7 @@ feasibility_state::maybe_update_for_edge (logger *logger,\n \tm_model.on_asm_stmt (asm_stmt, NULL);\n       else if (const gcall *call = dyn_cast <const gcall *> (stmt))\n \t{\n-\t  bool terminate_path;\n-\t  bool unknown_side_effects\n-\t    = m_model.on_call_pre (call, NULL, &terminate_path);\n+\t  bool unknown_side_effects = m_model.on_call_pre (call, NULL);\n \t  m_model.on_call_post (call, unknown_side_effects, NULL);\n \t}\n       else if (const greturn *return_ = dyn_cast <const greturn *> (stmt))"}, {"sha": "e17350da5ec3c25c9f977fd4b74c9580c4dc288b", "filename": "gcc/analyzer/known-function-manager.cc", "status": "modified", "additions": 76, "deletions": 9, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bd31b33daa3c7635d886ff2cebd915748db2084/gcc%2Fanalyzer%2Fknown-function-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bd31b33daa3c7635d886ff2cebd915748db2084/gcc%2Fanalyzer%2Fknown-function-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fknown-function-manager.cc?ref=6bd31b33daa3c7635d886ff2cebd915748db2084", "patch": "@@ -27,7 +27,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic-core.h\"\n #include \"analyzer/analyzer-logging.h\"\n #include \"stringpool.h\"\n+#include \"basic-block.h\"\n+#include \"gimple.h\"\n #include \"analyzer/known-function-manager.h\"\n+#include \"analyzer/region-model.h\"\n \n #if ENABLE_ANALYZER\n \n@@ -38,13 +41,16 @@ namespace ana {\n known_function_manager::known_function_manager (logger *logger)\n : log_user (logger)\n {\n+  memset (m_combined_fns_arr, 0, sizeof (m_combined_fns_arr));\n }\n \n known_function_manager::~known_function_manager ()\n {\n   /* Delete all owned kfs.  */\n   for (auto iter : m_map_id_to_kf)\n     delete iter.second;\n+  for (auto iter : m_combined_fns_arr)\n+    delete iter;\n }\n \n void\n@@ -56,24 +62,85 @@ known_function_manager::add (const char *name,\n   m_map_id_to_kf.put (id, kf.release ());\n }\n \n-const known_function *\n-known_function_manager::get_by_identifier (tree identifier)\n+void\n+known_function_manager::add (enum built_in_function name,\n+\t\t\t     std::unique_ptr<known_function> kf)\n {\n-  known_function **slot = m_map_id_to_kf.get (identifier);\n-  if (slot)\n-    return *slot;\n-  else\n-    return NULL;\n+  gcc_assert (name < END_BUILTINS);\n+  delete m_combined_fns_arr[name];\n+  m_combined_fns_arr[name] = kf.release ();\n }\n \n+void\n+known_function_manager::add (enum internal_fn ifn,\n+\t\t\t     std::unique_ptr<known_function> kf)\n+{\n+  gcc_assert (ifn < IFN_LAST);\n+  delete m_combined_fns_arr[ifn + END_BUILTINS];\n+  m_combined_fns_arr[ifn + END_BUILTINS] = kf.release ();\n+}\n+\n+/* Get any known_function for FNDECL for call CD.\n+\n+   The call must match all assumptions made by the known_function (such as\n+   e.g. \"argument 1's type must be a pointer type\").\n+\n+   Return NULL if no known_function is found, or it does not match the\n+   assumption(s).  */\n+\n const known_function *\n-known_function_manager::get_by_fndecl (tree fndecl)\n+known_function_manager::get_match (tree fndecl, const call_details &cd) const\n {\n+  if (fndecl_built_in_p (fndecl, BUILT_IN_NORMAL))\n+    {\n+      if (const known_function *candidate\n+\t  = get_normal_builtin (DECL_FUNCTION_CODE (fndecl)))\n+\tif (gimple_builtin_call_types_compatible_p (cd.get_call_stmt (),\n+\t\t\t\t\t\t    fndecl))\n+\t  return candidate;\n+    }\n   if (tree identifier = DECL_NAME (fndecl))\n-    return get_by_identifier (identifier);\n+      if (const known_function *candidate = get_by_identifier (identifier))\n+\tif (candidate->matches_call_types_p (cd))\n+\t  return candidate;\n   return NULL;\n }\n \n+/* Get any known_function for IFN, or NULL.  */\n+\n+const known_function *\n+known_function_manager::get_internal_fn (enum internal_fn ifn) const\n+{\n+  gcc_assert (ifn < IFN_LAST);\n+  return m_combined_fns_arr[ifn + END_BUILTINS];\n+}\n+\n+/* Get any known_function for NAME, without type-checking.\n+   Return NULL if there isn't one.  */\n+\n+const known_function *\n+known_function_manager::get_normal_builtin (enum built_in_function name) const\n+{\n+  /* The numbers for built-in functions in enum combined_fn are the same as\n+     for the built_in_function enum.  */\n+  gcc_assert (name < END_BUILTINS);\n+  return m_combined_fns_arr[name];\n+}\n+\n+/* Get any known_function matching IDENTIFIER, without type-checking.\n+   Return NULL if there isn't one.  */\n+\n+const known_function *\n+known_function_manager::get_by_identifier (tree identifier) const\n+{\n+  known_function_manager *mut_this = const_cast<known_function_manager *>(this);\n+  known_function **slot = mut_this->m_map_id_to_kf.get (identifier);\n+  if (slot)\n+    return *slot;\n+  else\n+    return NULL;\n+}\n+\n } // namespace ana\n \n #endif /* #if ENABLE_ANALYZER */"}, {"sha": "188cb8e034a8abf5444a4777224b17ffb8172635", "filename": "gcc/analyzer/known-function-manager.h", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bd31b33daa3c7635d886ff2cebd915748db2084/gcc%2Fanalyzer%2Fknown-function-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bd31b33daa3c7635d886ff2cebd915748db2084/gcc%2Fanalyzer%2Fknown-function-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fknown-function-manager.h?ref=6bd31b33daa3c7635d886ff2cebd915748db2084", "patch": "@@ -30,16 +30,26 @@ class known_function_manager : public log_user\n public:\n   known_function_manager (logger *logger);\n   ~known_function_manager ();\n+\n   void add (const char *name, std::unique_ptr<known_function> kf);\n-  const known_function *get_by_identifier (tree identifier);\n-  const known_function *get_by_fndecl (tree fndecl);\n+  void add (enum built_in_function name, std::unique_ptr<known_function> kf);\n+  void add (enum internal_fn ifn, std::unique_ptr<known_function> kf);\n+\n+  const known_function *get_match (tree fndecl, const call_details &cd) const;\n+  const known_function *get_internal_fn (enum internal_fn) const;\n \n private:\n   DISABLE_COPY_AND_ASSIGN (known_function_manager);\n \n+  const known_function *get_normal_builtin (enum built_in_function name) const;\n+  const known_function *get_by_identifier (tree identifier) const;\n+\n   /* Map from identifier to known_function instance.\n      Has ownership of the latter.  */\n   hash_map<tree, known_function *> m_map_id_to_kf;\n+\n+  /* Array of known builtins.  */\n+  known_function *m_combined_fns_arr[CFN_LAST];\n };\n \n } // namespace ana"}, {"sha": "6962ffd400f8e20dc607ff7ccf92517c9120e96e", "filename": "gcc/analyzer/region-model-impl-calls.cc", "status": "modified", "additions": 413, "deletions": 110, "changes": 523, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bd31b33daa3c7635d886ff2cebd915748db2084/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bd31b33daa3c7635d886ff2cebd915748db2084/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc?ref=6bd31b33daa3c7635d886ff2cebd915748db2084", "patch": "@@ -133,6 +133,14 @@ call_details::num_args () const\n   return gimple_call_num_args (m_call);\n }\n \n+/* Return true if argument IDX is a size_t (or compatible with it).  */\n+\n+bool\n+call_details::arg_is_size_p (unsigned idx) const\n+{\n+  return types_compatible_p (get_arg_type (idx), size_type_node);\n+}\n+\n /* Get the location of the call statement.  */\n \n location_t\n@@ -242,15 +250,30 @@ call_details::get_or_create_conjured_svalue (const region *reg) const\n \n /* Implementations of specific functions.  */\n \n-/* Handle the on_call_pre part of \"alloca\".  */\n+/* Handler for \"alloca\".  */\n+\n+class kf_alloca : public known_function\n+{\n+public:\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return cd.num_args () == 1;\n+  }\n+  void impl_call_pre (const call_details &cd) const final override;\n+};\n \n void\n-region_model::impl_call_alloca (const call_details &cd)\n+kf_alloca::impl_call_pre (const call_details &cd) const\n {\n   const svalue *size_sval = cd.get_arg_svalue (0);\n-  const region *new_reg = create_region_for_alloca (size_sval, cd.get_ctxt ());\n+\n+  region_model *model = cd.get_model ();\n+  region_model_manager *mgr = cd.get_manager ();\n+\n+  const region *new_reg\n+    = model->create_region_for_alloca (size_sval, cd.get_ctxt ());\n   const svalue *ptr_sval\n-    = m_mgr->get_ptr_svalue (cd.get_lhs_type (), new_reg);\n+    = mgr->get_ptr_svalue (cd.get_lhs_type (), new_reg);\n   cd.maybe_set_lhs (ptr_sval);\n }\n \n@@ -308,7 +331,7 @@ class kf_analyzer_dump_capacity : public known_function\n   bool matches_call_types_p (const call_details &cd) const final override\n   {\n     return (cd.num_args () == 1\n-\t    && POINTER_TYPE_P (cd.get_arg_type (0)));\n+\t    && cd.arg_is_pointer_p (0));\n   }\n \n   void impl_call_pre (const call_details &cd) const final override\n@@ -649,36 +672,53 @@ class kf_bind : public known_function\n   }\n };\n \n-/* Handle the on_call_pre part of \"__builtin_expect\" etc.  */\n+/* Handler for \"__builtin_expect\" etc.  */\n \n-void\n-region_model::impl_call_builtin_expect (const call_details &cd)\n+class kf_expect : public internal_known_function\n {\n-  /* __builtin_expect's return value is its initial argument.  */\n-  const svalue *sval = cd.get_arg_svalue (0);\n-  cd.maybe_set_lhs (sval);\n-}\n+public:\n+  void impl_call_pre (const call_details &cd) const final override\n+  {\n+    /* __builtin_expect's return value is its initial argument.  */\n+    const svalue *sval = cd.get_arg_svalue (0);\n+    cd.maybe_set_lhs (sval);\n+  }\n+};\n \n-/* Handle the on_call_pre part of \"calloc\".  */\n+/* Handler for \"calloc\".  */\n+\n+class kf_calloc : public known_function\n+{\n+public:\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return (cd.num_args () == 2\n+\t    && cd.arg_is_size_p (0)\n+\t    && cd.arg_is_size_p (1));\n+  }\n+  void impl_call_pre (const call_details &cd) const final override;\n+};\n \n void\n-region_model::impl_call_calloc (const call_details &cd)\n+kf_calloc::impl_call_pre (const call_details &cd) const\n {\n+  region_model *model = cd.get_model ();\n+  region_model_manager *mgr = cd.get_manager ();\n   const svalue *nmemb_sval = cd.get_arg_svalue (0);\n   const svalue *size_sval = cd.get_arg_svalue (1);\n   /* TODO: check for overflow here?  */\n   const svalue *prod_sval\n-    = m_mgr->get_or_create_binop (size_type_node, MULT_EXPR,\n-\t\t\t\t  nmemb_sval, size_sval);\n+    = mgr->get_or_create_binop (size_type_node, MULT_EXPR,\n+\t\t\t\tnmemb_sval, size_sval);\n   const region *new_reg\n-    = create_region_for_heap_alloc (prod_sval, cd.get_ctxt ());\n+    = model->create_region_for_heap_alloc (prod_sval, cd.get_ctxt ());\n   const region *sized_reg\n-    = m_mgr->get_sized_region (new_reg, NULL_TREE, prod_sval);\n-  zero_fill_region (sized_reg);\n+    = mgr->get_sized_region (new_reg, NULL_TREE, prod_sval);\n+  model->zero_fill_region (sized_reg);\n   if (cd.get_lhs_type ())\n     {\n       const svalue *ptr_sval\n-\t= m_mgr->get_ptr_svalue (cd.get_lhs_type (), new_reg);\n+\t= mgr->get_ptr_svalue (cd.get_lhs_type (), new_reg);\n       cd.maybe_set_lhs (ptr_sval);\n     }\n }\n@@ -708,7 +748,7 @@ class kf_connect : public known_function\n   bool matches_call_types_p (const call_details &cd) const final override\n   {\n     return (cd.num_args () == 3\n-\t    && POINTER_TYPE_P (cd.get_arg_type (1)));\n+\t    && cd.arg_is_pointer_p (1));\n   }\n \n   void impl_call_post (const call_details &cd) const final override\n@@ -745,67 +785,102 @@ class kf_errno_location : public known_function\n   }\n };\n \n-/* Handle the on_call_pre part of \"error\" and \"error_at_line\" from\n-   GNU's non-standard <error.h>.\n+/* Handler for \"error\" and \"error_at_line\" from GNU's non-standard <error.h>.\n    MIN_ARGS identifies the minimum number of expected arguments\n-   to be consistent with such a call (3 and 5 respectively).\n-   Return true if handling it as one of these functions.\n-   Write true to *OUT_TERMINATE_PATH if this execution path should be\n-   terminated (e.g. the function call terminates the process).  */\n+   to be consistent with such a call (3 and 5 respectively).  */\n \n-bool\n-region_model::impl_call_error (const call_details &cd, unsigned min_args,\n-\t\t\t       bool *out_terminate_path)\n+class kf_error : public known_function\n {\n-  /* Bail if not enough args.  */\n-  if (cd.num_args () < min_args)\n-    return false;\n+public:\n+  kf_error (unsigned min_args) : m_min_args (min_args) {}\n \n-  /* Initial argument ought to be of type \"int\".  */\n-  if (cd.get_arg_type (0) != integer_type_node)\n-    return false;\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return (cd.num_args () >= m_min_args\n+\t    && cd.get_arg_type (0) == integer_type_node);\n+  }\n+\n+  void impl_call_pre (const call_details &cd) const final override;\n+\n+private:\n+  unsigned m_min_args;\n+};\n \n+void\n+kf_error::impl_call_pre (const call_details &cd) const\n+{\n   /* The process exits if status != 0, so it only continues\n      for the case where status == 0.\n      Add that constraint, or terminate this analysis path.  */\n   tree status = cd.get_arg_tree (0);\n-  if (!add_constraint (status, EQ_EXPR, integer_zero_node, cd.get_ctxt ()))\n-    *out_terminate_path = true;\n-\n-  return true;\n+  region_model_context *ctxt = cd.get_ctxt ();\n+  region_model *model = cd.get_model ();\n+  if (!model->add_constraint (status, EQ_EXPR, integer_zero_node, ctxt))\n+    if (ctxt)\n+      ctxt->terminate_path ();\n }\n \n-/* Handle the on_call_pre part of \"fgets\" and \"fgets_unlocked\".  */\n+/* Handler for \"fgets\" and \"fgets_unlocked\".  */\n+\n+class kf_fgets : public known_function\n+{\n+public:\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return (cd.num_args () == 3\n+\t    && cd.arg_is_pointer_p (0)\n+\t    && cd.arg_is_pointer_p (2));\n+  }\n+\n+  void impl_call_pre (const call_details &cd) const final override;\n+};\n \n void\n-region_model::impl_call_fgets (const call_details &cd)\n+kf_fgets::impl_call_pre (const call_details &cd) const\n {\n   /* Ideally we would bifurcate state here between the\n      error vs no error cases.  */\n+  region_model *model = cd.get_model ();\n   const svalue *ptr_sval = cd.get_arg_svalue (0);\n   if (const region *reg = ptr_sval->maybe_get_region ())\n     {\n       const region *base_reg = reg->get_base_region ();\n       const svalue *new_sval = cd.get_or_create_conjured_svalue (base_reg);\n-      set_value (base_reg, new_sval, cd.get_ctxt ());\n+      model->set_value (base_reg, new_sval, cd.get_ctxt ());\n     }\n }\n \n-/* Handle the on_call_pre part of \"fread\".  */\n+/* Handler for \"fread\"\".  */\n+\n+class kf_fread : public known_function\n+{\n+public:\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return (cd.num_args () == 4\n+\t    && cd.arg_is_pointer_p (0)\n+\t    && cd.arg_is_size_p (1)\n+\t    && cd.arg_is_size_p (2)\n+\t    && cd.arg_is_pointer_p (3));\n+  }\n+\n+  void impl_call_pre (const call_details &cd) const final override;\n+};\n \n void\n-region_model::impl_call_fread (const call_details &cd)\n+kf_fread::impl_call_pre (const call_details &cd) const\n {\n+  region_model *model = cd.get_model ();\n   const svalue *ptr_sval = cd.get_arg_svalue (0);\n   if (const region *reg = ptr_sval->maybe_get_region ())\n     {\n       const region *base_reg = reg->get_base_region ();\n       const svalue *new_sval = cd.get_or_create_conjured_svalue (base_reg);\n-      set_value (base_reg, new_sval, cd.get_ctxt ());\n+      model->set_value (base_reg, new_sval, cd.get_ctxt ());\n     }\n }\n \n-/* Handle the on_call_post part of \"free\", after sm-handling.\n+/* Handler for \"free\", after sm-handling.\n \n    If the ptr points to an underlying heap region, delete the region,\n    poisoning pointers to it and regions within it.\n@@ -820,19 +895,44 @@ region_model::impl_call_fread (const call_details &cd)\n    all pointers to the region to the \"freed\" state together, regardless\n    of casts.  */\n \n+class kf_free : public known_function\n+{\n+public:\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return (cd.num_args () == 0 && cd.arg_is_pointer_p (0));\n+  }\n+  void impl_call_post (const call_details &cd) const final override;\n+};\n+\n void\n-region_model::impl_call_free (const call_details &cd)\n+kf_free::impl_call_post (const call_details &cd) const\n {\n   const svalue *ptr_sval = cd.get_arg_svalue (0);\n   if (const region *freed_reg = ptr_sval->maybe_get_region ())\n     {\n       /* If the ptr points to an underlying heap region, delete it,\n \t poisoning pointers.  */\n-      unbind_region_and_descendents (freed_reg, POISON_KIND_FREED);\n-      m_dynamic_extents.remove (freed_reg);\n+      region_model *model = cd.get_model ();\n+      model->unbind_region_and_descendents (freed_reg, POISON_KIND_FREED);\n+      model->unset_dynamic_extents (freed_reg);\n     }\n }\n \n+/* Handler for \"getchar\"\".  */\n+\n+class kf_getchar : public known_function\n+{\n+public:\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return cd.num_args () == 0;\n+  }\n+\n+  /* Empty.  No side-effects (tracking stream state is out-of-scope\n+     for the analyzer).  */\n+};\n+\n /* Handle calls to \"listen\".\n    See e.g. https://man7.org/linux/man-pages/man3/listen.3p.html  */\n \n@@ -872,66 +972,109 @@ class kf_listen : public known_function\n \n /* Handle the on_call_pre part of \"malloc\".  */\n \n+class kf_malloc : public known_function\n+{\n+public:\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return (cd.num_args () == 1\n+\t    && cd.arg_is_size_p (0));\n+  }\n+  void impl_call_pre (const call_details &cd) const final override;\n+};\n+\n void\n-region_model::impl_call_malloc (const call_details &cd)\n+kf_malloc::impl_call_pre (const call_details &cd) const\n {\n+  region_model *model = cd.get_model ();\n+  region_model_manager *mgr = cd.get_manager ();\n   const svalue *size_sval = cd.get_arg_svalue (0);\n   const region *new_reg\n-    = create_region_for_heap_alloc (size_sval, cd.get_ctxt ());\n+    = model->create_region_for_heap_alloc (size_sval, cd.get_ctxt ());\n   if (cd.get_lhs_type ())\n     {\n       const svalue *ptr_sval\n-\t= m_mgr->get_ptr_svalue (cd.get_lhs_type (), new_reg);\n+\t= mgr->get_ptr_svalue (cd.get_lhs_type (), new_reg);\n       cd.maybe_set_lhs (ptr_sval);\n     }\n }\n \n-/* Handle the on_call_pre part of \"memcpy\" and \"__builtin_memcpy\".  */\n+/* Handler for \"memcpy\" and \"__builtin_memcpy\".  */\n // TODO: complain about overlapping src and dest.\n \n+class kf_memcpy : public known_function\n+{\n+public:\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return (cd.num_args () == 3\n+\t    && cd.arg_is_pointer_p (0)\n+\t    && cd.arg_is_pointer_p (1)\n+\t    && cd.arg_is_size_p (2));\n+  }\n+  void impl_call_pre (const call_details &cd) const final override;\n+};\n+\n void\n-region_model::impl_call_memcpy (const call_details &cd)\n+kf_memcpy::impl_call_pre (const call_details &cd) const\n {\n   const svalue *dest_ptr_sval = cd.get_arg_svalue (0);\n   const svalue *src_ptr_sval = cd.get_arg_svalue (1);\n   const svalue *num_bytes_sval = cd.get_arg_svalue (2);\n \n-  const region *dest_reg = deref_rvalue (dest_ptr_sval, cd.get_arg_tree (0),\n-\t\t\t\t\t cd.get_ctxt ());\n-  const region *src_reg = deref_rvalue (src_ptr_sval, cd.get_arg_tree (1),\n-\t\t\t\t\tcd.get_ctxt ());\n+  region_model *model = cd.get_model ();\n+  region_model_manager *mgr = cd.get_manager ();\n+\n+  const region *dest_reg\n+    = model->deref_rvalue (dest_ptr_sval, cd.get_arg_tree (0), cd.get_ctxt ());\n+  const region *src_reg\n+    = model->deref_rvalue (src_ptr_sval, cd.get_arg_tree (1), cd.get_ctxt ());\n \n   cd.maybe_set_lhs (dest_ptr_sval);\n \n   const region *sized_src_reg\n-    = m_mgr->get_sized_region (src_reg, NULL_TREE, num_bytes_sval);\n+    = mgr->get_sized_region (src_reg, NULL_TREE, num_bytes_sval);\n   const region *sized_dest_reg\n-    = m_mgr->get_sized_region (dest_reg, NULL_TREE, num_bytes_sval);\n+    = mgr->get_sized_region (dest_reg, NULL_TREE, num_bytes_sval);\n   const svalue *src_contents_sval\n-    = get_store_value (sized_src_reg, cd.get_ctxt ());\n-  set_value (sized_dest_reg, src_contents_sval, cd.get_ctxt ());\n+    = model->get_store_value (sized_src_reg, cd.get_ctxt ());\n+  model->set_value (sized_dest_reg, src_contents_sval, cd.get_ctxt ());\n }\n \n-/* Handle the on_call_pre part of \"memset\" and \"__builtin_memset\".  */\n+/* Handler for \"memset\" and \"__builtin_memset\".  */\n+\n+class kf_memset : public known_function\n+{\n+public:\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return (cd.num_args () == 3 && cd.arg_is_pointer_p (0));\n+  }\n+\n+  void impl_call_pre (const call_details &cd) const final override;\n+};\n \n void\n-region_model::impl_call_memset (const call_details &cd)\n+kf_memset::impl_call_pre (const call_details &cd) const\n {\n   const svalue *dest_sval = cd.get_arg_svalue (0);\n   const svalue *fill_value_sval = cd.get_arg_svalue (1);\n   const svalue *num_bytes_sval = cd.get_arg_svalue (2);\n \n-  const region *dest_reg = deref_rvalue (dest_sval, cd.get_arg_tree (0),\n-\t\t\t\t\t  cd.get_ctxt ());\n+  region_model *model = cd.get_model ();\n+  region_model_manager *mgr = cd.get_manager ();\n+\n+  const region *dest_reg\n+    = model->deref_rvalue (dest_sval, cd.get_arg_tree (0), cd.get_ctxt ());\n \n   const svalue *fill_value_u8\n-    = m_mgr->get_or_create_cast (unsigned_char_type_node, fill_value_sval);\n+    = mgr->get_or_create_cast (unsigned_char_type_node, fill_value_sval);\n \n-  const region *sized_dest_reg = m_mgr->get_sized_region (dest_reg,\n-\t\t\t\t\t\t\t  NULL_TREE,\n-\t\t\t\t\t\t\t  num_bytes_sval);\n-  check_region_for_write (sized_dest_reg, cd.get_ctxt ());\n-  fill_region (sized_dest_reg, fill_value_u8);\n+  const region *sized_dest_reg = mgr->get_sized_region (dest_reg,\n+\t\t\t\t\t\t\tNULL_TREE,\n+\t\t\t\t\t\t\tnum_bytes_sval);\n+  model->check_region_for_write (sized_dest_reg, cd.get_ctxt ());\n+  model->fill_region (sized_dest_reg, fill_value_u8);\n }\n \n /* Handler for calls to \"pipe\" and \"pipe2\".\n@@ -989,7 +1132,6 @@ class kf_pipe : public known_function\n \t\t\t\t\t\t  p);\n \t  model->set_value (element_reg, fd_sval, cd.get_ctxt ());\n \t  model->mark_as_valid_fd (fd_sval, cd.get_ctxt ());\n-\n \t}\n       return true;\n     }\n@@ -1004,8 +1146,7 @@ class kf_pipe : public known_function\n \n   bool matches_call_types_p (const call_details &cd) const final override\n   {\n-    return (cd.num_args () == m_num_args\n-\t    && POINTER_TYPE_P (cd.get_arg_type (0)));\n+    return (cd.num_args () == m_num_args && cd.arg_is_pointer_p (0));\n   }\n \n   void impl_call_post (const call_details &cd) const final override\n@@ -1117,8 +1258,7 @@ class kf_putenv : public known_function\n public:\n   bool matches_call_types_p (const call_details &cd) const final override\n   {\n-    return (cd.num_args () == 1\n-\t    && POINTER_TYPE_P (cd.get_arg_type (0)));\n+    return (cd.num_args () == 1 && cd.arg_is_pointer_p (0));\n   }\n \n   void impl_call_pre (const call_details &cd) const final override\n@@ -1205,7 +1345,7 @@ class kf_operator_delete : public known_function\n   unsigned m_num_args;\n };\n \n-/* Handle the on_call_post part of \"realloc\":\n+/* Handler for \"realloc\":\n \n      void *realloc(void *ptr, size_t size);\n \n@@ -1228,8 +1368,20 @@ class kf_operator_delete : public known_function\n    Each of these has a custom_edge_info subclass, which updates\n    the region_model and sm-state of the destination state.  */\n \n+class kf_realloc : public known_function\n+{\n+public:\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return (cd.num_args () == 2\n+\t    && cd.arg_is_pointer_p (0)\n+\t    && cd.arg_is_size_p (1));\n+  }\n+  void impl_call_post (const call_details &cd) const final override;\n+};\n+\n void\n-region_model::impl_call_realloc (const call_details &cd)\n+kf_realloc::impl_call_post (const call_details &cd) const\n {\n   /* Three custom subclasses of custom_edge_info, for handling the various\n      outcomes of \"realloc\".  */\n@@ -1249,10 +1401,11 @@ region_model::impl_call_realloc (const call_details &cd)\n     {\n       /* Return NULL; everything else is unchanged.  */\n       const call_details cd (get_call_details (model, ctxt));\n+      region_model_manager *mgr = cd.get_manager ();\n       if (cd.get_lhs_type ())\n \t{\n \t  const svalue *zero\n-\t    = model->m_mgr->get_or_create_int_cst (cd.get_lhs_type (), 0);\n+\t    = mgr->get_or_create_int_cst (cd.get_lhs_type (), 0);\n \t  model->set_value (cd.get_lhs_region (),\n \t\t\t    zero,\n \t\t\t    cd.get_ctxt ());\n@@ -1284,13 +1437,14 @@ region_model::impl_call_realloc (const call_details &cd)\n     {\n       /* Update size of buffer and return the ptr unchanged.  */\n       const call_details cd (get_call_details (model, ctxt));\n+      region_model_manager *mgr = cd.get_manager ();\n       const svalue *ptr_sval = cd.get_arg_svalue (0);\n       const svalue *size_sval = cd.get_arg_svalue (1);\n \n       /* We can only grow in place with a non-NULL pointer.  */\n       {\n \tconst svalue *null_ptr\n-\t  = model->m_mgr->get_or_create_int_cst (ptr_sval->get_type (), 0);\n+\t  = mgr->get_or_create_int_cst (ptr_sval->get_type (), 0);\n \tif (!model->add_constraint (ptr_sval, NE_EXPR, null_ptr,\n \t\t\t\t    cd.get_ctxt ()))\n \t  return false;\n@@ -1304,8 +1458,8 @@ region_model::impl_call_realloc (const call_details &cd)\n \t{\n \t  model->set_value (cd.get_lhs_region (), ptr_sval, cd.get_ctxt ());\n \t  const svalue *zero\n-\t    = model->m_mgr->get_or_create_int_cst (cd.get_lhs_type (), 0);\n-\t  return model->add_constraint (ptr_sval, NE_EXPR, zero, cd.get_ctxt ());\n+\t    = mgr->get_or_create_int_cst (cd.get_lhs_type (), 0);\n+\t  return model->add_constraint (ptr_sval, NE_EXPR, zero, ctxt);\n \t}\n       else\n \treturn true;\n@@ -1334,14 +1488,15 @@ region_model::impl_call_realloc (const call_details &cd)\n \t\t       region_model_context *ctxt) const final override\n     {\n       const call_details cd (get_call_details (model, ctxt));\n+      region_model_manager *mgr = cd.get_manager ();\n       const svalue *old_ptr_sval = cd.get_arg_svalue (0);\n       const svalue *new_size_sval = cd.get_arg_svalue (1);\n \n       /* Create the new region.  */\n       const region *new_reg\n \t= model->create_region_for_heap_alloc (new_size_sval, ctxt);\n       const svalue *new_ptr_sval\n-\t= model->m_mgr->get_ptr_svalue (cd.get_lhs_type (), new_reg);\n+\t= mgr->get_ptr_svalue (cd.get_lhs_type (), new_reg);\n       if (!model->add_constraint (new_ptr_sval, NE_EXPR, old_ptr_sval,\n \t\t\t\t  cd.get_ctxt ()))\n \treturn false;\n@@ -1359,13 +1514,11 @@ region_model::impl_call_realloc (const call_details &cd)\n \t      const svalue *copied_size_sval\n \t\t= get_copied_size (model, old_size_sval, new_size_sval);\n \t      const region *copied_old_reg\n-\t\t= model->m_mgr->get_sized_region (freed_reg, NULL,\n-\t\t\t\t\t\t  copied_size_sval);\n+\t\t= mgr->get_sized_region (freed_reg, NULL, copied_size_sval);\n \t      const svalue *buffer_content_sval\n \t\t= model->get_store_value (copied_old_reg, cd.get_ctxt ());\n \t      const region *copied_new_reg\n-\t\t= model->m_mgr->get_sized_region (new_reg, NULL,\n-\t\t\t\t\t\t  copied_size_sval);\n+\t\t= mgr->get_sized_region (new_reg, NULL, copied_size_sval);\n \t      model->set_value (copied_new_reg, buffer_content_sval,\n \t\t\t\tcd.get_ctxt ());\n \t    }\n@@ -1383,7 +1536,7 @@ region_model::impl_call_realloc (const call_details &cd)\n \t  /* If the ptr points to an underlying heap region, delete it,\n \t     poisoning pointers.  */\n \t  model->unbind_region_and_descendents (freed_reg, POISON_KIND_FREED);\n-\t  model->m_dynamic_extents.remove (freed_reg);\n+\t  model->unset_dynamic_extents (freed_reg);\n \t}\n \n       /* Update the sm-state: mark the old_ptr_sval as \"freed\",\n@@ -1393,7 +1546,7 @@ region_model::impl_call_realloc (const call_details &cd)\n       if (cd.get_lhs_type ())\n \t{\n \t  const svalue *zero\n-\t    = model->m_mgr->get_or_create_int_cst (cd.get_lhs_type (), 0);\n+\t    = mgr->get_or_create_int_cst (cd.get_lhs_type (), 0);\n \t  return model->add_constraint (new_ptr_sval, NE_EXPR, zero,\n \t\t\t\t\tcd.get_ctxt ());\n \t}\n@@ -1423,7 +1576,7 @@ region_model::impl_call_realloc (const call_details &cd)\n     }\n   };\n \n-  /* Body of region_model::impl_call_realloc.  */\n+  /* Body of kf_realloc::impl_call_post.  */\n \n   if (cd.get_ctxt ())\n     {\n@@ -1472,10 +1625,20 @@ class kf_socket : public known_function\n   }\n };\n \n-/* Handle the on_call_post part of \"strchr\" and \"__builtin_strchr\".  */\n+/* Handler for \"strchr\" and \"__builtin_strchr\".  */\n+\n+class kf_strchr : public known_function\n+{\n+public:\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return (cd.num_args () == 2 && cd.arg_is_pointer_p (0));\n+  }\n+  void impl_call_post (const call_details &cd) const final override;\n+};\n \n void\n-region_model::impl_call_strchr (const call_details &cd)\n+kf_strchr::impl_call_post (const call_details &cd) const\n {\n   class strchr_call_info : public call_info\n   {\n@@ -1534,7 +1697,7 @@ region_model::impl_call_strchr (const call_details &cd)\n     bool m_found;\n   };\n \n-  /* Body of region_model::impl_call_strchr.  */\n+  /* Body of kf_strchr::impl_call_post.  */\n   if (cd.get_ctxt ())\n     {\n       cd.get_ctxt ()->bifurcate (make_unique<strchr_call_info> (cd, false));\n@@ -1543,41 +1706,116 @@ region_model::impl_call_strchr (const call_details &cd)\n     }\n }\n \n-/* Handle the on_call_pre part of \"strcpy\" and \"__builtin_strcpy_chk\".  */\n+/* Handler for \"__builtin_stack_restore\".  */\n+\n+class kf_stack_restore : public known_function\n+{\n+public:\n+  bool matches_call_types_p (const call_details &) const final override\n+  {\n+    return true;\n+  }\n+\n+  /* Currently a no-op.  */\n+};\n+\n+/* Handler for \"__builtin_stack_save\".  */\n+\n+class kf_stack_save : public known_function\n+{\n+public:\n+  bool matches_call_types_p (const call_details &) const final override\n+  {\n+    return true;\n+  }\n+\n+  /* Currently a no-op.  */\n+};\n+\n+/* Handler for various stdio-related builtins that merely have external\n+   effects that are out of scope for the analyzer: we only want to model\n+   the effects on the return value.  */\n+\n+class kf_stdio_output_fn : public known_function\n+{\n+public:\n+  bool matches_call_types_p (const call_details &) const final override\n+  {\n+    return true;\n+  }\n+\n+  /* A no-op; we just want the conjured return value.  */\n+};\n+\n+/* Handler for \"strcpy\" and \"__builtin_strcpy_chk\".  */\n+\n+class kf_strcpy : public known_function\n+{\n+public:\n+  kf_strcpy (unsigned int num_args) : m_num_args (num_args) {}\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return (cd.num_args () == m_num_args\n+\t    && cd.arg_is_pointer_p (0)\n+\t    && cd.arg_is_pointer_p (1));\n+  }\n+\n+  void impl_call_pre (const call_details &cd) const final override;\n+\n+private:\n+  unsigned int m_num_args;\n+};\n \n void\n-region_model::impl_call_strcpy (const call_details &cd)\n+kf_strcpy::impl_call_pre (const call_details &cd) const\n {\n+  region_model *model = cd.get_model ();\n+  region_model_manager *mgr = cd.get_manager ();\n+\n   const svalue *dest_sval = cd.get_arg_svalue (0);\n-  const region *dest_reg = deref_rvalue (dest_sval, cd.get_arg_tree (0),\n+  const region *dest_reg = model->deref_rvalue (dest_sval, cd.get_arg_tree (0),\n \t\t\t\t\t cd.get_ctxt ());\n   const svalue *src_sval = cd.get_arg_svalue (1);\n-  const region *src_reg = deref_rvalue (src_sval, cd.get_arg_tree (1),\n+  const region *src_reg = model->deref_rvalue (src_sval, cd.get_arg_tree (1),\n \t\t\t\t\tcd.get_ctxt ());\n-  const svalue *src_contents_sval = get_store_value (src_reg,\n-\t\t\t\t\t\t     cd.get_ctxt ());\n+  const svalue *src_contents_sval = model->get_store_value (src_reg,\n+\t\t\t\t\t\t\t    cd.get_ctxt ());\n \n   cd.maybe_set_lhs (dest_sval);\n \n   /* Try to get the string size if SRC_REG is a string_region.  */\n-  const svalue *copied_bytes_sval = get_string_size (src_reg);\n+  const svalue *copied_bytes_sval = model->get_string_size (src_reg);\n   /* Otherwise, check if the contents of SRC_REG is a string.  */\n   if (copied_bytes_sval->get_kind () == SK_UNKNOWN)\n-    copied_bytes_sval = get_string_size (src_contents_sval);\n+    copied_bytes_sval = model->get_string_size (src_contents_sval);\n \n   const region *sized_dest_reg\n-    = m_mgr->get_sized_region (dest_reg, NULL_TREE, copied_bytes_sval);\n-  set_value (sized_dest_reg, src_contents_sval, cd.get_ctxt ());\n+    = mgr->get_sized_region (dest_reg, NULL_TREE, copied_bytes_sval);\n+  model->set_value (sized_dest_reg, src_contents_sval, cd.get_ctxt ());\n }\n \n /* Handle the on_call_pre part of \"strlen\".  */\n \n+class kf_strlen : public known_function\n+{\n+public:\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return (cd.num_args () == 1 && cd.arg_is_pointer_p (0));\n+  }\n+  void impl_call_pre (const call_details &cd) const final override;\n+};\n+\n void\n-region_model::impl_call_strlen (const call_details &cd)\n+kf_strlen::impl_call_pre (const call_details &cd) const\n {\n   region_model_context *ctxt = cd.get_ctxt ();\n+  region_model *model = cd.get_model ();\n+  region_model_manager *mgr = cd.get_manager ();\n+\n   const svalue *arg_sval = cd.get_arg_svalue (0);\n-  const region *buf_reg = deref_rvalue (arg_sval, cd.get_arg_tree (0), ctxt);\n+  const region *buf_reg\n+    = model->deref_rvalue (arg_sval, cd.get_arg_tree (0), ctxt);\n   if (const string_region *str_reg\n       = buf_reg->dyn_cast_string_region ())\n     {\n@@ -1589,21 +1827,27 @@ region_model::impl_call_strlen (const call_details &cd)\n \t{\n \t  tree t_cst = build_int_cst (cd.get_lhs_type (), strlen_cst);\n \t  const svalue *result_sval\n-\t    = m_mgr->get_or_create_constant_svalue (t_cst);\n+\t    = mgr->get_or_create_constant_svalue (t_cst);\n \t  cd.maybe_set_lhs (result_sval);\n \t  return;\n \t}\n     }\n   /* Otherwise a conjured value.  */\n }\n \n+class kf_ubsan_bounds : public internal_known_function\n+{\n+  /* Empty.  */\n+};\n+\n /* Handle calls to functions referenced by\n    __attribute__((malloc(FOO))).  */\n \n void\n region_model::impl_deallocation_call (const call_details &cd)\n {\n-  impl_call_free (cd);\n+  kf_free kf;\n+  kf.impl_call_post (cd);\n }\n \n /* Populate KFM with instances of known functions supported by the core of the\n@@ -1612,6 +1856,54 @@ region_model::impl_deallocation_call (const call_details &cd)\n void\n register_known_functions (known_function_manager &kfm)\n {\n+  /* Internal fns the analyzer has known_functions for.  */\n+  {\n+    kfm.add (IFN_BUILTIN_EXPECT, make_unique<kf_expect> ());\n+    kfm.add (IFN_UBSAN_BOUNDS, make_unique<kf_ubsan_bounds> ());\n+  }\n+\n+  /* Built-ins the analyzer has known_functions for.  */\n+  {\n+    kfm.add (BUILT_IN_ALLOCA, make_unique<kf_alloca> ());\n+    kfm.add (BUILT_IN_ALLOCA_WITH_ALIGN, make_unique<kf_alloca> ());\n+    kfm.add (BUILT_IN_CALLOC, make_unique<kf_calloc> ());\n+    kfm.add (BUILT_IN_EXPECT, make_unique<kf_expect> ());\n+    kfm.add (BUILT_IN_EXPECT_WITH_PROBABILITY, make_unique<kf_expect> ());\n+    kfm.add (BUILT_IN_FPRINTF, make_unique<kf_stdio_output_fn> ());\n+    kfm.add (BUILT_IN_FPRINTF_UNLOCKED, make_unique<kf_stdio_output_fn> ());\n+    kfm.add (BUILT_IN_FPUTC, make_unique<kf_stdio_output_fn> ());\n+    kfm.add (BUILT_IN_FPUTC_UNLOCKED, make_unique<kf_stdio_output_fn> ());\n+    kfm.add (BUILT_IN_FPUTS, make_unique<kf_stdio_output_fn> ());\n+    kfm.add (BUILT_IN_FPUTS_UNLOCKED, make_unique<kf_stdio_output_fn> ());\n+    kfm.add (BUILT_IN_FREE, make_unique<kf_free> ());\n+    kfm.add (BUILT_IN_FWRITE, make_unique<kf_stdio_output_fn> ());\n+    kfm.add (BUILT_IN_FWRITE_UNLOCKED, make_unique<kf_stdio_output_fn> ());\n+    kfm.add (BUILT_IN_MALLOC, make_unique<kf_malloc> ());\n+    kfm.add (BUILT_IN_MEMCPY, make_unique<kf_memcpy> ());\n+    kfm.add (BUILT_IN_MEMCPY_CHK, make_unique<kf_memcpy> ());\n+    kfm.add (BUILT_IN_MEMSET, make_unique<kf_memset> ());\n+    kfm.add (BUILT_IN_MEMSET_CHK, make_unique<kf_memset> ());\n+    kfm.add (BUILT_IN_PRINTF, make_unique<kf_stdio_output_fn> ());\n+    kfm.add (BUILT_IN_PRINTF_UNLOCKED, make_unique<kf_stdio_output_fn> ());\n+    kfm.add (BUILT_IN_PUTC, make_unique<kf_stdio_output_fn> ());\n+    kfm.add (BUILT_IN_PUTCHAR, make_unique<kf_stdio_output_fn> ());\n+    kfm.add (BUILT_IN_PUTCHAR_UNLOCKED, make_unique<kf_stdio_output_fn> ());\n+    kfm.add (BUILT_IN_PUTC_UNLOCKED, make_unique<kf_stdio_output_fn> ());\n+    kfm.add (BUILT_IN_PUTS, make_unique<kf_stdio_output_fn> ());\n+    kfm.add (BUILT_IN_PUTS_UNLOCKED, make_unique<kf_stdio_output_fn> ());\n+    kfm.add (BUILT_IN_REALLOC, make_unique<kf_realloc> ());\n+    kfm.add (BUILT_IN_STACK_RESTORE, make_unique<kf_stack_restore> ());\n+    kfm.add (BUILT_IN_STACK_SAVE, make_unique<kf_stack_save> ());\n+    kfm.add (BUILT_IN_STRCHR, make_unique<kf_strchr> ());\n+    kfm.add (BUILT_IN_STRCPY, make_unique<kf_strcpy> (2));\n+    kfm.add (BUILT_IN_STRCPY_CHK, make_unique<kf_strcpy> (3));\n+    kfm.add (BUILT_IN_STRLEN, make_unique<kf_strlen> ());\n+    kfm.add (BUILT_IN_VFPRINTF, make_unique<kf_stdio_output_fn> ());\n+    kfm.add (BUILT_IN_VPRINTF, make_unique<kf_stdio_output_fn> ());\n+\n+    register_varargs_builtins (kfm);\n+  }\n+\n   /* Debugging/test support functions, all  with a \"__analyzer_\" prefix.  */\n   {\n     kfm.add (\"__analyzer_break\", make_unique<kf_analyzer_break> ());\n@@ -1633,11 +1925,20 @@ register_known_functions (known_function_manager &kfm)\n \t     make_unique<kf_analyzer_get_unknown_ptr> ());\n   }\n \n-  /* Known POSIX functions.  */\n+  /* Known builtins and C standard library functions.  */\n+  {\n+    kfm.add (\"getchar\", make_unique<kf_getchar> ());\n+    kfm.add (\"memset\", make_unique<kf_memset> ());\n+  }\n+\n+  /* Known POSIX functions, and some non-standard extensions.  */\n   {\n     kfm.add (\"accept\", make_unique<kf_accept> ());\n     kfm.add (\"bind\", make_unique<kf_bind> ());\n     kfm.add (\"connect\", make_unique<kf_connect> ());\n+    kfm.add (\"fgets\", make_unique<kf_fgets> ());\n+    kfm.add (\"fgets_unlocked\", make_unique<kf_fgets> ()); // non-standard\n+    kfm.add (\"fread\", make_unique<kf_fread> ());\n     kfm.add (\"listen\", make_unique<kf_listen> ());\n     kfm.add (\"pipe\", make_unique<kf_pipe> (1));\n     kfm.add (\"pipe2\", make_unique<kf_pipe> (2));\n@@ -1648,6 +1949,8 @@ register_known_functions (known_function_manager &kfm)\n   /* glibc functions.  */\n   {\n     kfm.add (\"__errno_location\", make_unique<kf_errno_location> ());\n+    kfm.add (\"error\", make_unique<kf_error> (3));\n+    kfm.add (\"error_at_line\", make_unique<kf_error> (5));\n   }\n \n   /* C++ support functions.  */"}, {"sha": "92f8b94b3f09ef180b1aa0ab2a01c0d3a0264713", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 34, "deletions": 218, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bd31b33daa3c7635d886ff2cebd915748db2084/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bd31b33daa3c7635d886ff2cebd915748db2084/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=6bd31b33daa3c7635d886ff2cebd915748db2084", "patch": "@@ -1160,13 +1160,11 @@ region_model::on_assignment (const gassign *assign, region_model_context *ctxt)\n }\n \n /* Handle the pre-sm-state part of STMT, modifying this object in-place.\n-   Write true to *OUT_TERMINATE_PATH if the path should be terminated.\n    Write true to *OUT_UNKNOWN_SIDE_EFFECTS if the stmt has unknown\n    side effects.  */\n \n void\n region_model::on_stmt_pre (const gimple *stmt,\n-\t\t\t   bool *out_terminate_path,\n \t\t\t   bool *out_unknown_side_effects,\n \t\t\t   region_model_context *ctxt)\n {\n@@ -1196,8 +1194,7 @@ region_model::on_stmt_pre (const gimple *stmt,\n \t   anything, for which we don't have a function body, or for which we\n \t   don't know the fndecl.  */\n \tconst gcall *call = as_a <const gcall *> (stmt);\n-\t*out_unknown_side_effects\n-\t  = on_call_pre (call, ctxt, out_terminate_path);\n+\t*out_unknown_side_effects = on_call_pre (call, ctxt);\n       }\n       break;\n \n@@ -2030,13 +2027,28 @@ region_model::maybe_get_copy_bounds (const region *src_reg,\n   return NULL;\n }\n \n-/* Get any known_function for FNDECL, or NULL if there is none.  */\n+/* Get any known_function for FNDECL for call CD.\n+\n+   The call must match all assumptions made by the known_function (such as\n+   e.g. \"argument 1's type must be a pointer type\").\n+\n+   Return NULL if no known_function is found, or it does not match the\n+   assumption(s).  */\n+\n+const known_function *\n+region_model::get_known_function (tree fndecl, const call_details &cd) const\n+{\n+  known_function_manager *known_fn_mgr = m_mgr->get_known_function_manager ();\n+  return known_fn_mgr->get_match (fndecl, cd);\n+}\n+\n+/* Get any known_function for IFN, or NULL.  */\n \n const known_function *\n-region_model::get_known_function (tree fndecl) const\n+region_model::get_known_function (enum internal_fn ifn) const\n {\n   known_function_manager *known_fn_mgr = m_mgr->get_known_function_manager ();\n-  return known_fn_mgr->get_by_fndecl (fndecl);\n+  return known_fn_mgr->get_internal_fn (ifn);\n }\n \n /* Update this model for the CALL stmt, using CTXT to report any\n@@ -2048,14 +2060,10 @@ region_model::get_known_function (tree fndecl) const\n \n    Return true if the function call has unknown side effects (it wasn't\n    recognized and we don't have a body for it, or are unable to tell which\n-   fndecl it is).\n-\n-   Write true to *OUT_TERMINATE_PATH if this execution path should be\n-   terminated (e.g. the function call terminates the process).  */\n+   fndecl it is).  */\n \n bool\n-region_model::on_call_pre (const gcall *call, region_model_context *ctxt,\n-\t\t\t   bool *out_terminate_path)\n+region_model::on_call_pre (const gcall *call, region_model_context *ctxt)\n {\n   call_details cd (call, this, ctxt);\n \n@@ -2099,188 +2107,28 @@ region_model::on_call_pre (const gcall *call, region_model_context *ctxt,\n     }\n \n   if (gimple_call_internal_p (call))\n-    {\n-      switch (gimple_call_internal_fn (call))\n-       {\n-       default:\n-\t break;\n-       case IFN_BUILTIN_EXPECT:\n-\t impl_call_builtin_expect (cd);\n-\t return false;\n-       case IFN_UBSAN_BOUNDS:\n-\t return false;\n-       case IFN_VA_ARG:\n-\t impl_call_va_arg (cd);\n-\t return false;\n-       }\n-    }\n+    if (const known_function *kf\n+\t  = get_known_function (gimple_call_internal_fn (call)))\n+      {\n+\tkf->impl_call_pre (cd);\n+\treturn false;\n+      }\n \n   if (tree callee_fndecl = get_fndecl_for_call (call, ctxt))\n     {\n-      /* The various impl_call_* member functions are implemented\n-\t in region-model-impl-calls.cc.\n-\t Having them split out into separate functions makes it easier\n-\t to put breakpoints on the handling of specific functions.  */\n       int callee_fndecl_flags = flags_from_decl_or_type (callee_fndecl);\n \n-      if (fndecl_built_in_p (callee_fndecl, BUILT_IN_NORMAL)\n-\t  && gimple_builtin_call_types_compatible_p (call, callee_fndecl))\n-\tswitch (DECL_UNCHECKED_FUNCTION_CODE (callee_fndecl))\n-\t  {\n-\t  default:\n-\t    if (!(callee_fndecl_flags & (ECF_CONST | ECF_PURE)))\n-\t      unknown_side_effects = true;\n-\t    break;\n-\t  case BUILT_IN_ALLOCA:\n-\t  case BUILT_IN_ALLOCA_WITH_ALIGN:\n-\t    impl_call_alloca (cd);\n-\t    return false;\n-\t  case BUILT_IN_CALLOC:\n-\t    impl_call_calloc (cd);\n-\t    return false;\n-\t  case BUILT_IN_EXPECT:\n-\t  case BUILT_IN_EXPECT_WITH_PROBABILITY:\n-\t    impl_call_builtin_expect (cd);\n-\t    return false;\n-\t  case BUILT_IN_FREE:\n-\t    /* Handle in \"on_call_post\".  */\n-\t    break;\n-\t  case BUILT_IN_MALLOC:\n-\t    impl_call_malloc (cd);\n-\t    return false;\n-\t  case BUILT_IN_MEMCPY:\n-\t  case BUILT_IN_MEMCPY_CHK:\n-\t    impl_call_memcpy (cd);\n-\t    return false;\n-\t  case BUILT_IN_MEMSET:\n-\t  case BUILT_IN_MEMSET_CHK:\n-\t    impl_call_memset (cd);\n-\t    return false;\n-\t    break;\n-\t  case BUILT_IN_REALLOC:\n-\t    return false;\n-\t  case BUILT_IN_STRCHR:\n-\t    /* Handle in \"on_call_post\".  */\n-\t    return false;\n-\t  case BUILT_IN_STRCPY:\n-\t  case BUILT_IN_STRCPY_CHK:\n-\t    impl_call_strcpy (cd);\n-\t    return false;\n-\t  case BUILT_IN_STRLEN:\n-\t    impl_call_strlen (cd);\n-\t    return false;\n-\n-\t  case BUILT_IN_STACK_SAVE:\n-\t  case BUILT_IN_STACK_RESTORE:\n-\t    return false;\n-\n-\t  /* Stdio builtins.  */\n-\t  case BUILT_IN_FPRINTF:\n-\t  case BUILT_IN_FPRINTF_UNLOCKED:\n-\t  case BUILT_IN_PUTC:\n-\t  case BUILT_IN_PUTC_UNLOCKED:\n-\t  case BUILT_IN_FPUTC:\n-\t  case BUILT_IN_FPUTC_UNLOCKED:\n-\t  case BUILT_IN_FPUTS:\n-\t  case BUILT_IN_FPUTS_UNLOCKED:\n-\t  case BUILT_IN_FWRITE:\n-\t  case BUILT_IN_FWRITE_UNLOCKED:\n-\t  case BUILT_IN_PRINTF:\n-\t  case BUILT_IN_PRINTF_UNLOCKED:\n-\t  case BUILT_IN_PUTCHAR:\n-\t  case BUILT_IN_PUTCHAR_UNLOCKED:\n-\t  case BUILT_IN_PUTS:\n-\t  case BUILT_IN_PUTS_UNLOCKED:\n-\t  case BUILT_IN_VFPRINTF:\n-\t  case BUILT_IN_VPRINTF:\n-\t    /* These stdio builtins have external effects that are out\n-\t       of scope for the analyzer: we only want to model the effects\n-\t       on the return value.  */\n-\t    break;\n-\n-\t  case BUILT_IN_VA_START:\n-\t    impl_call_va_start (cd);\n-\t    return false;\n-\t  case BUILT_IN_VA_COPY:\n-\t    impl_call_va_copy (cd);\n-\t    return false;\n-\t  }\n-      else if (is_named_call_p (callee_fndecl, \"malloc\", call, 1))\n-\t{\n-\t  impl_call_malloc (cd);\n-\t  return false;\n-\t}\n-      else if (is_named_call_p (callee_fndecl, \"calloc\", call, 2))\n-\t{\n-\t  impl_call_calloc (cd);\n-\t  return false;\n-\t}\n-      else if (is_named_call_p (callee_fndecl, \"alloca\", call, 1))\n+      if (const known_function *kf = get_known_function (callee_fndecl, cd))\n \t{\n-\t  impl_call_alloca (cd);\n+\t  kf->impl_call_pre (cd);\n \t  return false;\n \t}\n-      else if (is_named_call_p (callee_fndecl, \"realloc\", call, 2))\n-\t{\n-\t  impl_call_realloc (cd);\n-\t  return false;\n-\t}\n-      else if (is_named_call_p (callee_fndecl, \"error\"))\n+      else if (fndecl_built_in_p (callee_fndecl, BUILT_IN_NORMAL)\n+\t  && gimple_builtin_call_types_compatible_p (call, callee_fndecl))\n \t{\n-\t  if (impl_call_error (cd, 3, out_terminate_path))\n-\t    return false;\n-\t  else\n+\t  if (!(callee_fndecl_flags & (ECF_CONST | ECF_PURE)))\n \t    unknown_side_effects = true;\n \t}\n-      else if (is_named_call_p (callee_fndecl, \"error_at_line\"))\n-\t{\n-\t  if (impl_call_error (cd, 5, out_terminate_path))\n-\t    return false;\n-\t  else\n-\t    unknown_side_effects = true;\n-\t}\n-      else if (is_named_call_p (callee_fndecl, \"fgets\", call, 3)\n-\t       || is_named_call_p (callee_fndecl, \"fgets_unlocked\", call, 3))\n-\t{\n-\t  impl_call_fgets (cd);\n-\t  return false;\n-\t}\n-      else if (is_named_call_p (callee_fndecl, \"fread\", call, 4))\n-\t{\n-\t  impl_call_fread (cd);\n-\t  return false;\n-\t}\n-      else if (is_named_call_p (callee_fndecl, \"getchar\", call, 0))\n-\t{\n-\t  /* No side-effects (tracking stream state is out-of-scope\n-\t     for the analyzer).  */\n-\t}\n-      else if (is_named_call_p (callee_fndecl, \"memset\", call, 3)\n-\t       && POINTER_TYPE_P (cd.get_arg_type (0)))\n-\t{\n-\t  impl_call_memset (cd);\n-\t  return false;\n-\t}\n-      else if (is_named_call_p (callee_fndecl, \"strchr\", call, 2)\n-\t       && POINTER_TYPE_P (cd.get_arg_type (0)))\n-\t{\n-\t  /* Handle in \"on_call_post\".  */\n-\t  return false;\n-\t}\n-      else if (is_named_call_p (callee_fndecl, \"strlen\", call, 1)\n-\t       && POINTER_TYPE_P (cd.get_arg_type (0)))\n-\t{\n-\t  impl_call_strlen (cd);\n-\t  return false;\n-\t}\n-      else if (const known_function *kf = get_known_function (callee_fndecl))\n-\t{\n-\t  if (kf->matches_call_types_p (cd))\n-\t    {\n-\t      kf->impl_call_pre (cd);\n-\t      return false;\n-\t    }\n-\t}\n       else if (!fndecl_has_gimple_body_p (callee_fndecl)\n \t       && (!(callee_fndecl_flags & (ECF_CONST | ECF_PURE)))\n \t       && !fndecl_built_in_p (callee_fndecl))\n@@ -2310,50 +2158,18 @@ region_model::on_call_post (const gcall *call,\n   if (tree callee_fndecl = get_fndecl_for_call (call, ctxt))\n     {\n       call_details cd (call, this, ctxt);\n-      if (is_named_call_p (callee_fndecl, \"free\", call, 1))\n+      if (const known_function *kf = get_known_function (callee_fndecl, cd))\n \t{\n-\t  impl_call_free (cd);\n+\t  kf->impl_call_post (cd);\n \t  return;\n \t}\n-      else if (is_named_call_p (callee_fndecl, \"strchr\", call, 2)\n-\t       && POINTER_TYPE_P (cd.get_arg_type (0)))\n-\t{\n-\t  impl_call_strchr (cd);\n-\t  return;\n-\t}\n-      else if (const known_function *kf = get_known_function (callee_fndecl))\n-\t{\n-\t  if (kf->matches_call_types_p (cd))\n-\t    {\n-\t      kf->impl_call_post (cd);\n-\t      return;\n-\t    }\n-\t}\n       /* Was this fndecl referenced by\n \t __attribute__((malloc(FOO)))?  */\n       if (lookup_attribute (\"*dealloc\", DECL_ATTRIBUTES (callee_fndecl)))\n \t{\n \t  impl_deallocation_call (cd);\n \t  return;\n \t}\n-      if (fndecl_built_in_p (callee_fndecl, BUILT_IN_NORMAL)\n-\t  && gimple_builtin_call_types_compatible_p (call, callee_fndecl))\n-\tswitch (DECL_UNCHECKED_FUNCTION_CODE (callee_fndecl))\n-\t  {\n-\t  default:\n-\t    break;\n-\t  case BUILT_IN_REALLOC:\n-\t    impl_call_realloc (cd);\n-\t    return;\n-\n-\t  case BUILT_IN_STRCHR:\n-\t    impl_call_strchr (cd);\n-\t    return;\n-\n-\t  case BUILT_IN_VA_END:\n-\t    impl_call_va_end (cd);\n-\t    return;\n-\t  }\n     }\n \n   if (unknown_side_effects)"}, {"sha": "8e4616c28dedccf4bf213169477df8c5a015b79f", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 8, "deletions": 28, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bd31b33daa3c7635d886ff2cebd915748db2084/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bd31b33daa3c7635d886ff2cebd915748db2084/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=6bd31b33daa3c7635d886ff2cebd915748db2084", "patch": "@@ -260,6 +260,7 @@ class call_details\n   {\n     return POINTER_TYPE_P (get_arg_type (idx));\n   }\n+  bool arg_is_size_p (unsigned idx) const;\n \n   const gcall *get_call_stmt () const { return m_call; }\n   location_t get_location () const;\n@@ -326,46 +327,22 @@ class region_model\n \n   void\n   on_stmt_pre (const gimple *stmt,\n-\t       bool *out_terminate_path,\n \t       bool *out_unknown_side_effects,\n \t       region_model_context *ctxt);\n \n   void on_assignment (const gassign *stmt, region_model_context *ctxt);\n   const svalue *get_gassign_result (const gassign *assign,\n \t\t\t\t    region_model_context *ctxt);\n   void on_asm_stmt (const gasm *asm_stmt, region_model_context *ctxt);\n-  bool on_call_pre (const gcall *stmt, region_model_context *ctxt,\n-\t\t    bool *out_terminate_path);\n+  bool on_call_pre (const gcall *stmt, region_model_context *ctxt);\n   void on_call_post (const gcall *stmt,\n \t\t     bool unknown_side_effects,\n \t\t     region_model_context *ctxt);\n \n   void purge_state_involving (const svalue *sval, region_model_context *ctxt);\n \n-  /* Specific handling for on_call_pre.  */\n-  void impl_call_alloca (const call_details &cd);\n-  void impl_call_builtin_expect (const call_details &cd);\n-  void impl_call_calloc (const call_details &cd);\n-  bool impl_call_error (const call_details &cd, unsigned min_args,\n-\t\t\tbool *out_terminate_path);\n-  void impl_call_fgets (const call_details &cd);\n-  void impl_call_fread (const call_details &cd);\n-  void impl_call_free (const call_details &cd);\n-  void impl_call_malloc (const call_details &cd);\n-  void impl_call_memcpy (const call_details &cd);\n-  void impl_call_memset (const call_details &cd);\n-  void impl_call_realloc (const call_details &cd);\n-  void impl_call_strchr (const call_details &cd);\n-  void impl_call_strcpy (const call_details &cd);\n-  void impl_call_strlen (const call_details &cd);\n   void impl_deallocation_call (const call_details &cd);\n \n-  /* Implemented in varargs.cc.  */\n-  void impl_call_va_start (const call_details &cd);\n-  void impl_call_va_copy (const call_details &cd);\n-  void impl_call_va_arg (const call_details &cd);\n-  void impl_call_va_end (const call_details &cd);\n-\n   const svalue *maybe_get_copy_bounds (const region *src_reg,\n \t\t\t\t       const svalue *num_bytes_sval);\n   void update_for_int_cst_return (const call_details &cd,\n@@ -562,6 +539,9 @@ class region_model\n \t\t\t\t  tree expr,\n \t\t\t\t  region_model_context *ctxt) const;\n \n+  void check_region_for_write (const region *dest_reg,\n+\t\t\t       region_model_context *ctxt) const;\n+\n private:\n   const region *get_lvalue_1 (path_var pv, region_model_context *ctxt) const;\n   const svalue *get_rvalue_1 (path_var pv, region_model_context *ctxt) const;\n@@ -573,7 +553,9 @@ class region_model\n   get_representative_path_var_1 (const region *reg,\n \t\t\t\t svalue_set *visited) const;\n \n-  const known_function *get_known_function (tree fndecl) const;\n+  const known_function *get_known_function (tree fndecl,\n+\t\t\t\t\t    const call_details &cd) const;\n+  const known_function *get_known_function (enum internal_fn) const;\n \n   bool add_constraints_from_binop (const svalue *outer_lhs,\n \t\t\t\t   enum tree_code outer_op,\n@@ -622,8 +604,6 @@ class region_model\n   void check_region_access (const region *reg,\n \t\t\t    enum access_direction dir,\n \t\t\t    region_model_context *ctxt) const;\n-  void check_region_for_write (const region *dest_reg,\n-\t\t\t       region_model_context *ctxt) const;\n   void check_region_for_read (const region *src_reg,\n \t\t\t      region_model_context *ctxt) const;\n   void check_region_size (const region *lhs_reg, const svalue *rhs_sval,"}, {"sha": "94ca295fae8f6441bda67c2d287688d1950ecb00", "filename": "gcc/analyzer/sm-malloc.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bd31b33daa3c7635d886ff2cebd915748db2084/gcc%2Fanalyzer%2Fsm-malloc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bd31b33daa3c7635d886ff2cebd915748db2084/gcc%2Fanalyzer%2Fsm-malloc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-malloc.cc?ref=6bd31b33daa3c7635d886ff2cebd915748db2084", "patch": "@@ -2175,7 +2175,7 @@ malloc_state_machine::on_deallocator_call (sm_context *sm_ctxt,\n    Check for free of non-heap or mismatching allocators,\n    transitioning to the \"stop\" state for such cases.\n \n-   Otherwise, region_model::impl_call_realloc will later\n+   Otherwise, kf_realloc::impl_call_post will later\n    get called (which will handle other sm-state transitions\n    when the state is bifurcated).  */\n \n@@ -2432,7 +2432,7 @@ make_malloc_state_machine (logger *logger)\n }\n \n /* Specialcase hook for handling realloc, for use by\n-   region_model::impl_call_realloc::success_with_move::update_model.  */\n+   kf_realloc::impl_call_post::success_with_move::update_model.  */\n \n void\n region_model::on_realloc_with_move (const call_details &cd,"}, {"sha": "1da5a46f67774da72b448e6bd36a92a7e12c9821", "filename": "gcc/analyzer/varargs.cc", "status": "modified", "additions": 89, "deletions": 42, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bd31b33daa3c7635d886ff2cebd915748db2084/gcc%2Fanalyzer%2Fvarargs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bd31b33daa3c7635d886ff2cebd915748db2084/gcc%2Fanalyzer%2Fvarargs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fvarargs.cc?ref=6bd31b33daa3c7635d886ff2cebd915748db2084", "patch": "@@ -647,33 +647,45 @@ make_va_list_state_machine (logger *logger)\n   return new va_list_state_machine (logger);\n }\n \n-/* Handle the on_call_pre part of \"__builtin_va_start\".  */\n+/* Handler for \"__builtin_va_start\".  */\n+\n+class kf_va_start : public known_function\n+{\n+public:\n+  bool matches_call_types_p (const call_details &) const\n+  {\n+    return true;\n+  }\n+  void impl_call_pre (const call_details &cd) const final override;\n+};\n \n void\n-region_model::impl_call_va_start (const call_details &cd)\n+kf_va_start::impl_call_pre (const call_details &cd) const\n {\n+  region_model *model = cd.get_model ();\n+  region_model_manager *mgr = cd.get_manager ();\n   const svalue *out_ptr = cd.get_arg_svalue (0);\n   const region *out_reg\n-    = deref_rvalue (out_ptr, cd.get_arg_tree (0), cd.get_ctxt ());\n+    = model->deref_rvalue (out_ptr, cd.get_arg_tree (0), cd.get_ctxt ());\n+  const frame_region *frame = model->get_current_frame ();\n \n   /* \"*out_ptr = &IMPL_REGION;\".  */\n-  const region *impl_reg = m_mgr->create_region_for_alloca (m_current_frame);\n+  const region *impl_reg = mgr->create_region_for_alloca (frame);\n \n   /* We abuse the types here, since va_list_type isn't\n      necessarily anything to do with a pointer.  */\n-  const svalue *ptr_to_impl_reg = m_mgr->get_ptr_svalue (NULL_TREE, impl_reg);\n-  set_value (out_reg, ptr_to_impl_reg, cd.get_ctxt ());\n+  const svalue *ptr_to_impl_reg = mgr->get_ptr_svalue (NULL_TREE, impl_reg);\n+  model->set_value (out_reg, ptr_to_impl_reg, cd.get_ctxt ());\n \n-  if (get_stack_depth () > 1)\n+  if (model->get_stack_depth () > 1)\n     {\n       /* The interprocedural case: the frame containing the va_start call\n \t will have been populated with any variadic aruguments.\n \t Initialize IMPL_REGION with a ptr to var_arg_region 0.  */\n-      const region *init_var_arg_reg\n-\t= m_mgr->get_var_arg_region (get_current_frame (), 0);\n+      const region *init_var_arg_reg = mgr->get_var_arg_region (frame, 0);\n       const svalue *ap_sval\n-\t= m_mgr->get_ptr_svalue (NULL_TREE, init_var_arg_reg);\n-      set_value (impl_reg, ap_sval, cd.get_ctxt ());\n+\t= mgr->get_ptr_svalue (NULL_TREE, init_var_arg_reg);\n+      model->set_value (impl_reg, ap_sval, cd.get_ctxt ());\n     }\n   else\n     {\n@@ -682,40 +694,52 @@ region_model::impl_call_va_start (const call_details &cd)\n \t Initialize IMPL_REGION as the UNKNOWN_SVALUE to avoid state\n \t explosions on repeated calls to va_arg.  */\n       const svalue *unknown_sval\n-\t= m_mgr->get_or_create_unknown_svalue (NULL_TREE);\n-      set_value (impl_reg, unknown_sval, cd.get_ctxt ());\n+\t= mgr->get_or_create_unknown_svalue (NULL_TREE);\n+      model->set_value (impl_reg, unknown_sval, cd.get_ctxt ());\n     }\n }\n \n-/* Handle the on_call_pre part of \"__builtin_va_copy\".  */\n+/* Handler for \"__builtin_va_copy\".  */\n+\n+class kf_va_copy : public known_function\n+{\n+public:\n+  bool matches_call_types_p (const call_details &cd) const\n+  {\n+    return true;\n+  }\n+  void impl_call_pre (const call_details &cd) const final override;\n+};\n \n void\n-region_model::impl_call_va_copy (const call_details &cd)\n+kf_va_copy::impl_call_pre (const call_details &cd) const\n {\n+  region_model *model = cd.get_model ();\n+  region_model_manager *mgr = cd.get_manager ();\n   const svalue *out_dst_ptr = cd.get_arg_svalue (0);\n   const svalue *in_va_list\n-    = get_va_copy_arg (this, cd.get_ctxt (), cd.get_call_stmt (), 1);\n-  in_va_list = check_for_poison (in_va_list,\n-\t\t\t\t get_va_list_diag_arg (cd.get_arg_tree (1)),\n-\t\t\t\t cd.get_ctxt ());\n+    = get_va_copy_arg (model, cd.get_ctxt (), cd.get_call_stmt (), 1);\n+  in_va_list\n+    = model->check_for_poison (in_va_list,\n+\t\t\t       get_va_list_diag_arg (cd.get_arg_tree (1)),\n+\t\t\t       cd.get_ctxt ());\n \n   const region *out_dst_reg\n-    = deref_rvalue (out_dst_ptr, cd.get_arg_tree (0), cd.get_ctxt ());\n+    = model->deref_rvalue (out_dst_ptr, cd.get_arg_tree (0), cd.get_ctxt ());\n \n   /* \"*out_dst_ptr = &NEW_IMPL_REGION;\".  */\n   const region *new_impl_reg\n-    = m_mgr->create_region_for_alloca (m_current_frame);\n+    = mgr->create_region_for_alloca (model->get_current_frame ());\n   const svalue *ptr_to_new_impl_reg\n-    = m_mgr->get_ptr_svalue (NULL_TREE, new_impl_reg);\n-  set_value (out_dst_reg, ptr_to_new_impl_reg, cd.get_ctxt ());\n+    = mgr->get_ptr_svalue (NULL_TREE, new_impl_reg);\n+  model->set_value (out_dst_reg, ptr_to_new_impl_reg, cd.get_ctxt ());\n \n   if (const region *old_impl_reg = in_va_list->maybe_get_region ())\n     {\n-\n       /* \"(NEW_IMPL_REGION) = (OLD_IMPL_REGION);\".  */\n       const svalue *existing_sval\n-\t= get_store_value (old_impl_reg, cd.get_ctxt ());\n-      set_value (new_impl_reg, existing_sval, cd.get_ctxt ());\n+\t= model->get_store_value (old_impl_reg, cd.get_ctxt ());\n+      model->set_value (new_impl_reg, existing_sval, cd.get_ctxt ());\n     }\n }\n \n@@ -956,26 +980,35 @@ maybe_get_var_arg_region (const svalue *ap_sval)\n   return NULL;\n }\n \n-/* Handle the on_call_pre part of \"__builtin_va_arg\".  */\n+/* Handler for \"__builtin_va_arg\".  */\n+\n+class kf_va_arg : public internal_known_function\n+{\n+public:\n+  void impl_call_pre (const call_details &cd) const final override;\n+};\n \n void\n-region_model::impl_call_va_arg (const call_details &cd)\n+kf_va_arg::impl_call_pre (const call_details &cd) const\n {\n   region_model_context *ctxt = cd.get_ctxt ();\n+  region_model *model = cd.get_model ();\n+  region_model_manager *mgr = cd.get_manager ();\n \n   const svalue *in_ptr = cd.get_arg_svalue (0);\n-  const region *ap_reg = deref_rvalue (in_ptr, cd.get_arg_tree (0), ctxt);\n+  const region *ap_reg\n+    = model->deref_rvalue (in_ptr, cd.get_arg_tree (0), ctxt);\n \n-  const svalue *ap_sval = get_store_value (ap_reg, ctxt);\n+  const svalue *ap_sval = model->get_store_value (ap_reg, ctxt);\n   if (const svalue *cast = ap_sval->maybe_undo_cast ())\n     ap_sval = cast;\n \n   tree va_list_tree = get_va_list_diag_arg (cd.get_arg_tree (0));\n-  ap_sval = check_for_poison (ap_sval, va_list_tree, ctxt);\n+  ap_sval = model->check_for_poison (ap_sval, va_list_tree, ctxt);\n \n   if (const region *impl_reg = ap_sval->maybe_get_region ())\n     {\n-      const svalue *old_impl_sval = get_store_value (impl_reg, ctxt);\n+      const svalue *old_impl_sval = model->get_store_value (impl_reg, ctxt);\n       if (const var_arg_region *arg_reg\n \t  = maybe_get_var_arg_region (old_impl_sval))\n \t{\n@@ -992,8 +1025,8 @@ region_model::impl_call_va_arg (const call_details &cd)\n \t\t has a conjured_svalue), or warn if there's a problem\n \t\t (incompatible types, or if we've run out of args).  */\n \t      if (const svalue *arg_sval\n-\t\t  = m_store.get_any_binding (m_mgr->get_store_manager (),\n-\t\t\t\t\t     arg_reg))\n+\t\t  = model->get_store ()->get_any_binding\n+\t\t      (mgr->get_store_manager (), arg_reg))\n \t\t{\n \t\t  tree lhs_type = cd.get_lhs_type ();\n \t\t  tree arg_type = arg_sval->get_type ();\n@@ -1031,28 +1064,42 @@ region_model::impl_call_va_arg (const call_details &cd)\n \t    {\n \t      /* Set impl_reg to UNKNOWN to suppress further warnings.  */\n \t      const svalue *new_ap_sval\n-\t\t= m_mgr->get_or_create_unknown_svalue (impl_reg->get_type ());\n-\t      set_value (impl_reg, new_ap_sval, ctxt);\n+\t\t= mgr->get_or_create_unknown_svalue (impl_reg->get_type ());\n+\t      model->set_value (impl_reg, new_ap_sval, ctxt);\n \t    }\n \t  else\n \t    {\n \t      /* Update impl_reg to advance to the next arg.  */\n \t      const region *next_var_arg_region\n-\t\t= m_mgr->get_var_arg_region (frame_reg, next_arg_idx + 1);\n+\t\t= mgr->get_var_arg_region (frame_reg, next_arg_idx + 1);\n \t      const svalue *new_ap_sval\n-\t\t= m_mgr->get_ptr_svalue (NULL_TREE, next_var_arg_region);\n-\t      set_value (impl_reg, new_ap_sval, ctxt);\n+\t\t= mgr->get_ptr_svalue (NULL_TREE, next_var_arg_region);\n+\t      model->set_value (impl_reg, new_ap_sval, ctxt);\n \t    }\n \t}\n     }\n }\n \n-/* Handle the on_call_post part of \"__builtin_va_end\".  */\n+/* Handler for \"__builtin_va_end\".  */\n+\n+class kf_va_end : public known_function\n+{\n+public:\n+  bool matches_call_types_p (const call_details &) const\n+  {\n+    return true;\n+  }\n+};\n+\n+/* Populate KFM with instances of known functions relating to varargs.  */\n \n void\n-region_model::impl_call_va_end (const call_details &)\n+register_varargs_builtins (known_function_manager &kfm)\n {\n-  /* No-op.  */\n+  kfm.add (BUILT_IN_VA_START, make_unique<kf_va_start> ());\n+  kfm.add (BUILT_IN_VA_COPY, make_unique<kf_va_copy> ());\n+  kfm.add (IFN_VA_ARG, make_unique<kf_va_arg> ());\n+  kfm.add (BUILT_IN_VA_END, make_unique<kf_va_end> ());\n }\n \n } // namespace ana"}]}