{"sha": "b978758186fa187d52d2c4a02cdc8474d361a0dd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjk3ODc1ODE4NmZhMTg3ZDUyZDJjNGEwMmNkYzg0NzRkMzYxYTBkZA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2018-07-31T14:23:20Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-07-31T14:23:20Z"}, "message": "[18/46] Make SLP_TREE_SCALAR_STMTS a vec<stmt_vec_info>\n\nThis patch changes SLP_TREE_SCALAR_STMTS from a vec<gimple *> to\na vec<stmt_vec_info>.  It's longer than the previous conversions\nbut mostly mechanical.\n\n2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-vectorizer.h (_slp_tree::stmts): Change from a vec<gimple *>\n\tto a vec<stmt_vec_info>.\n\t* tree-vect-slp.c (vect_free_slp_tree): Update accordingly.\n\t(vect_create_new_slp_node): Take a vec<gimple *> instead of a\n\tvec<stmt_vec_info>.\n\t(_slp_oprnd_info::def_stmts): Change from a vec<gimple *>\n\tto a vec<stmt_vec_info>.\n\t(bst_traits::value_type, bst_traits::value_type): Likewise.\n\t(bst_traits::hash): Update accordingly.\n\t(vect_get_and_check_slp_defs): Change the stmts parameter from\n\ta vec<gimple *> to a vec<stmt_vec_info>.\n\t(vect_two_operations_perm_ok_p, vect_build_slp_tree_1): Likewise.\n\t(vect_build_slp_tree): Likewise.\n\t(vect_build_slp_tree_2): Likewise.  Update uses of\n\tSLP_TREE_SCALAR_STMTS.\n\t(vect_print_slp_tree): Update uses of SLP_TREE_SCALAR_STMTS.\n\t(vect_mark_slp_stmts, vect_mark_slp_stmts_relevant)\n\t(vect_slp_rearrange_stmts, vect_attempt_slp_rearrange_stmts)\n\t(vect_supported_load_permutation_p, vect_find_last_scalar_stmt_in_slp)\n\t(vect_detect_hybrid_slp_stmts, vect_slp_analyze_node_operations_1)\n\t(vect_slp_analyze_node_operations, vect_slp_analyze_operations)\n\t(vect_bb_slp_scalar_cost, vect_slp_analyze_bb_1)\n\t(vect_get_constant_vectors, vect_get_slp_defs)\n\t(vect_transform_slp_perm_load, vect_schedule_slp_instance)\n\t(vect_remove_slp_scalar_calls, vect_schedule_slp): Likewise.\n\t(vect_analyze_slp_instance): Build up a vec of stmt_vec_infos\n\tinstead of gimple stmts.\n\t* tree-vect-data-refs.c (vect_slp_analyze_node_dependences): Change\n\tthe stores parameter for a vec<gimple *> to a vec<stmt_vec_info>.\n\t(vect_slp_analyze_instance_dependence): Update uses of\n\tSLP_TREE_SCALAR_STMTS.\n\t(vect_slp_analyze_and_verify_node_alignment): Likewise.\n\t(vect_slp_analyze_and_verify_instance_alignment): Likewise.\n\t* tree-vect-loop.c (neutral_op_for_slp_reduction): Likewise.\n\t(get_initial_defs_for_reduction): Likewise.\n\t(vect_create_epilog_for_reduction): Likewise.\n\t(vectorize_fold_left_reduction): Likewise.\n\t* tree-vect-stmts.c (vect_prologue_cost_for_slp_op): Likewise.\n\t(vect_model_simple_cost, vectorizable_shift, vectorizable_load)\n\t(can_vectorize_live_stmts): Likewise.\n\nFrom-SVN: r263133", "tree": {"sha": "ffd0069f5215da13cfcd5b0714557a2ec74a076a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ffd0069f5215da13cfcd5b0714557a2ec74a076a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b978758186fa187d52d2c4a02cdc8474d361a0dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b978758186fa187d52d2c4a02cdc8474d361a0dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b978758186fa187d52d2c4a02cdc8474d361a0dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b978758186fa187d52d2c4a02cdc8474d361a0dd/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "32c91dfcfddc4f3c594aa24e803ee605a259f2a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32c91dfcfddc4f3c594aa24e803ee605a259f2a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32c91dfcfddc4f3c594aa24e803ee605a259f2a9"}], "stats": {"total": 668, "additions": 361, "deletions": 307}, "files": [{"sha": "d09829b14e4ecd099fba8cfbd349a7b4cd2c0cf1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b978758186fa187d52d2c4a02cdc8474d361a0dd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b978758186fa187d52d2c4a02cdc8474d361a0dd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b978758186fa187d52d2c4a02cdc8474d361a0dd", "patch": "@@ -1,3 +1,46 @@\n+2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vectorizer.h (_slp_tree::stmts): Change from a vec<gimple *>\n+\tto a vec<stmt_vec_info>.\n+\t* tree-vect-slp.c (vect_free_slp_tree): Update accordingly.\n+\t(vect_create_new_slp_node): Take a vec<gimple *> instead of a\n+\tvec<stmt_vec_info>.\n+\t(_slp_oprnd_info::def_stmts): Change from a vec<gimple *>\n+\tto a vec<stmt_vec_info>.\n+\t(bst_traits::value_type, bst_traits::value_type): Likewise.\n+\t(bst_traits::hash): Update accordingly.\n+\t(vect_get_and_check_slp_defs): Change the stmts parameter from\n+\ta vec<gimple *> to a vec<stmt_vec_info>.\n+\t(vect_two_operations_perm_ok_p, vect_build_slp_tree_1): Likewise.\n+\t(vect_build_slp_tree): Likewise.\n+\t(vect_build_slp_tree_2): Likewise.  Update uses of\n+\tSLP_TREE_SCALAR_STMTS.\n+\t(vect_print_slp_tree): Update uses of SLP_TREE_SCALAR_STMTS.\n+\t(vect_mark_slp_stmts, vect_mark_slp_stmts_relevant)\n+\t(vect_slp_rearrange_stmts, vect_attempt_slp_rearrange_stmts)\n+\t(vect_supported_load_permutation_p, vect_find_last_scalar_stmt_in_slp)\n+\t(vect_detect_hybrid_slp_stmts, vect_slp_analyze_node_operations_1)\n+\t(vect_slp_analyze_node_operations, vect_slp_analyze_operations)\n+\t(vect_bb_slp_scalar_cost, vect_slp_analyze_bb_1)\n+\t(vect_get_constant_vectors, vect_get_slp_defs)\n+\t(vect_transform_slp_perm_load, vect_schedule_slp_instance)\n+\t(vect_remove_slp_scalar_calls, vect_schedule_slp): Likewise.\n+\t(vect_analyze_slp_instance): Build up a vec of stmt_vec_infos\n+\tinstead of gimple stmts.\n+\t* tree-vect-data-refs.c (vect_slp_analyze_node_dependences): Change\n+\tthe stores parameter for a vec<gimple *> to a vec<stmt_vec_info>.\n+\t(vect_slp_analyze_instance_dependence): Update uses of\n+\tSLP_TREE_SCALAR_STMTS.\n+\t(vect_slp_analyze_and_verify_node_alignment): Likewise.\n+\t(vect_slp_analyze_and_verify_instance_alignment): Likewise.\n+\t* tree-vect-loop.c (neutral_op_for_slp_reduction): Likewise.\n+\t(get_initial_defs_for_reduction): Likewise.\n+\t(vect_create_epilog_for_reduction): Likewise.\n+\t(vectorize_fold_left_reduction): Likewise.\n+\t* tree-vect-stmts.c (vect_prologue_cost_for_slp_op): Likewise.\n+\t(vect_model_simple_cost, vectorizable_shift, vectorizable_load)\n+\t(can_vectorize_live_stmts): Likewise.\n+\n 2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-vectorizer.h (_loop_vec_info::reductions): Change from an"}, {"sha": "b4ad2129f3ff93248d3aa2909cbdbf81fcb99014", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b978758186fa187d52d2c4a02cdc8474d361a0dd/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b978758186fa187d52d2c4a02cdc8474d361a0dd/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=b978758186fa187d52d2c4a02cdc8474d361a0dd", "patch": "@@ -665,21 +665,22 @@ vect_slp_analyze_data_ref_dependence (struct data_dependence_relation *ddr)\n \n static bool\n vect_slp_analyze_node_dependences (slp_instance instance, slp_tree node,\n-\t\t\t\t   vec<gimple *> stores, gimple *last_store)\n+\t\t\t\t   vec<stmt_vec_info> stores,\n+\t\t\t\t   gimple *last_store)\n {\n   /* This walks over all stmts involved in the SLP load/store done\n      in NODE verifying we can sink them up to the last stmt in the\n      group.  */\n   gimple *last_access = vect_find_last_scalar_stmt_in_slp (node);\n   for (unsigned k = 0; k < SLP_INSTANCE_GROUP_SIZE (instance); ++k)\n     {\n-      gimple *access = SLP_TREE_SCALAR_STMTS (node)[k];\n-      if (access == last_access)\n+      stmt_vec_info access_info = SLP_TREE_SCALAR_STMTS (node)[k];\n+      if (access_info == last_access)\n \tcontinue;\n-      data_reference *dr_a = STMT_VINFO_DATA_REF (vinfo_for_stmt (access));\n+      data_reference *dr_a = STMT_VINFO_DATA_REF (access_info);\n       ao_ref ref;\n       bool ref_initialized_p = false;\n-      for (gimple_stmt_iterator gsi = gsi_for_stmt (access);\n+      for (gimple_stmt_iterator gsi = gsi_for_stmt (access_info->stmt);\n \t   gsi_stmt (gsi) != last_access; gsi_next (&gsi))\n \t{\n \t  gimple *stmt = gsi_stmt (gsi);\n@@ -712,11 +713,10 @@ vect_slp_analyze_node_dependences (slp_instance instance, slp_tree node,\n \t      if (stmt != last_store)\n \t\tcontinue;\n \t      unsigned i;\n-\t      gimple *store;\n-\t      FOR_EACH_VEC_ELT (stores, i, store)\n+\t      stmt_vec_info store_info;\n+\t      FOR_EACH_VEC_ELT (stores, i, store_info)\n \t\t{\n-\t\t  data_reference *store_dr\n-\t\t    = STMT_VINFO_DATA_REF (vinfo_for_stmt (store));\n+\t\t  data_reference *store_dr = STMT_VINFO_DATA_REF (store_info);\n \t\t  ddr_p ddr = initialize_data_dependence_relation\n \t\t\t\t(dr_a, store_dr, vNULL);\n \t\t  dependent = vect_slp_analyze_data_ref_dependence (ddr);\n@@ -753,7 +753,7 @@ vect_slp_analyze_instance_dependence (slp_instance instance)\n \n   /* The stores of this instance are at the root of the SLP tree.  */\n   slp_tree store = SLP_INSTANCE_TREE (instance);\n-  if (! STMT_VINFO_DATA_REF (vinfo_for_stmt (SLP_TREE_SCALAR_STMTS (store)[0])))\n+  if (! STMT_VINFO_DATA_REF (SLP_TREE_SCALAR_STMTS (store)[0]))\n     store = NULL;\n \n   /* Verify we can sink stores to the vectorized stmt insert location.  */\n@@ -766,7 +766,7 @@ vect_slp_analyze_instance_dependence (slp_instance instance)\n       /* Mark stores in this instance and remember the last one.  */\n       last_store = vect_find_last_scalar_stmt_in_slp (store);\n       for (unsigned k = 0; k < SLP_INSTANCE_GROUP_SIZE (instance); ++k)\n-\tgimple_set_visited (SLP_TREE_SCALAR_STMTS (store)[k], true);\n+\tgimple_set_visited (SLP_TREE_SCALAR_STMTS (store)[k]->stmt, true);\n     }\n \n   bool res = true;\n@@ -788,7 +788,7 @@ vect_slp_analyze_instance_dependence (slp_instance instance)\n   /* Unset the visited flag.  */\n   if (store)\n     for (unsigned k = 0; k < SLP_INSTANCE_GROUP_SIZE (instance); ++k)\n-      gimple_set_visited (SLP_TREE_SCALAR_STMTS (store)[k], false);\n+      gimple_set_visited (SLP_TREE_SCALAR_STMTS (store)[k]->stmt, false);\n \n   return res;\n }\n@@ -2389,10 +2389,11 @@ vect_slp_analyze_and_verify_node_alignment (slp_tree node)\n   /* We vectorize from the first scalar stmt in the node unless\n      the node is permuted in which case we start from the first\n      element in the group.  */\n-  gimple *first_stmt = SLP_TREE_SCALAR_STMTS (node)[0];\n-  data_reference_p first_dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt));\n+  stmt_vec_info first_stmt_info = SLP_TREE_SCALAR_STMTS (node)[0];\n+  gimple *first_stmt = first_stmt_info->stmt;\n+  data_reference_p first_dr = STMT_VINFO_DATA_REF (first_stmt_info);\n   if (SLP_TREE_LOAD_PERMUTATION (node).exists ())\n-    first_stmt = DR_GROUP_FIRST_ELEMENT (vinfo_for_stmt (first_stmt));\n+    first_stmt = DR_GROUP_FIRST_ELEMENT (first_stmt_info);\n \n   data_reference_p dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt));\n   vect_compute_data_ref_alignment (dr);\n@@ -2429,7 +2430,7 @@ vect_slp_analyze_and_verify_instance_alignment (slp_instance instance)\n       return false;\n \n   node = SLP_INSTANCE_TREE (instance);\n-  if (STMT_VINFO_DATA_REF (vinfo_for_stmt (SLP_TREE_SCALAR_STMTS (node)[0]))\n+  if (STMT_VINFO_DATA_REF (SLP_TREE_SCALAR_STMTS (node)[0])\n       && ! vect_slp_analyze_and_verify_node_alignment\n \t     (SLP_INSTANCE_TREE (instance)))\n     return false;"}, {"sha": "a542487ebe120429815848642cea911fc145b4da", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b978758186fa187d52d2c4a02cdc8474d361a0dd/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b978758186fa187d52d2c4a02cdc8474d361a0dd/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=b978758186fa187d52d2c4a02cdc8474d361a0dd", "patch": "@@ -2186,8 +2186,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n   FOR_EACH_VEC_ELT (LOOP_VINFO_SLP_INSTANCES (loop_vinfo), i, instance)\n     {\n       stmt_vec_info vinfo;\n-      vinfo = vinfo_for_stmt\n-\t  (SLP_TREE_SCALAR_STMTS (SLP_INSTANCE_TREE (instance))[0]);\n+      vinfo = SLP_TREE_SCALAR_STMTS (SLP_INSTANCE_TREE (instance))[0];\n       if (! STMT_VINFO_GROUPED_ACCESS (vinfo))\n \tcontinue;\n       vinfo = vinfo_for_stmt (DR_GROUP_FIRST_ELEMENT (vinfo));\n@@ -2199,7 +2198,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n        return false;\n       FOR_EACH_VEC_ELT (SLP_INSTANCE_LOADS (instance), j, node)\n \t{\n-\t  vinfo = vinfo_for_stmt (SLP_TREE_SCALAR_STMTS (node)[0]);\n+\t  vinfo = SLP_TREE_SCALAR_STMTS (node)[0];\n \t  vinfo = vinfo_for_stmt (DR_GROUP_FIRST_ELEMENT (vinfo));\n \t  bool single_element_p = !DR_GROUP_NEXT_ELEMENT (vinfo);\n \t  size = DR_GROUP_SIZE (vinfo);\n@@ -2442,12 +2441,11 @@ static tree\n neutral_op_for_slp_reduction (slp_tree slp_node, tree_code code,\n \t\t\t      bool reduc_chain)\n {\n-  vec<gimple *> stmts = SLP_TREE_SCALAR_STMTS (slp_node);\n-  gimple *stmt = stmts[0];\n-  stmt_vec_info stmt_vinfo = vinfo_for_stmt (stmt);\n+  vec<stmt_vec_info> stmts = SLP_TREE_SCALAR_STMTS (slp_node);\n+  stmt_vec_info stmt_vinfo = stmts[0];\n   tree vector_type = STMT_VINFO_VECTYPE (stmt_vinfo);\n   tree scalar_type = TREE_TYPE (vector_type);\n-  struct loop *loop = gimple_bb (stmt)->loop_father;\n+  struct loop *loop = gimple_bb (stmt_vinfo->stmt)->loop_father;\n   gcc_assert (loop);\n \n   switch (code)\n@@ -2473,7 +2471,8 @@ neutral_op_for_slp_reduction (slp_tree slp_node, tree_code code,\n \t has only a single initial value, so that value is neutral for\n \t all statements.  */\n       if (reduc_chain)\n-\treturn PHI_ARG_DEF_FROM_EDGE (stmt, loop_preheader_edge (loop));\n+\treturn PHI_ARG_DEF_FROM_EDGE (stmt_vinfo->stmt,\n+\t\t\t\t      loop_preheader_edge (loop));\n       return NULL_TREE;\n \n     default:\n@@ -4182,9 +4181,8 @@ get_initial_defs_for_reduction (slp_tree slp_node,\n \t\t\t\tunsigned int number_of_vectors,\n \t\t\t\tbool reduc_chain, tree neutral_op)\n {\n-  vec<gimple *> stmts = SLP_TREE_SCALAR_STMTS (slp_node);\n-  gimple *stmt = stmts[0];\n-  stmt_vec_info stmt_vinfo = vinfo_for_stmt (stmt);\n+  vec<stmt_vec_info> stmts = SLP_TREE_SCALAR_STMTS (slp_node);\n+  stmt_vec_info stmt_vinfo = stmts[0];\n   unsigned HOST_WIDE_INT nunits;\n   unsigned j, number_of_places_left_in_vector;\n   tree vector_type;\n@@ -4201,7 +4199,7 @@ get_initial_defs_for_reduction (slp_tree slp_node,\n \n   gcc_assert (STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_reduction_def);\n \n-  loop = (gimple_bb (stmt))->loop_father;\n+  loop = (gimple_bb (stmt_vinfo->stmt))->loop_father;\n   gcc_assert (loop);\n   edge pe = loop_preheader_edge (loop);\n \n@@ -4234,7 +4232,7 @@ get_initial_defs_for_reduction (slp_tree slp_node,\n   elts.quick_grow (nunits);\n   for (j = 0; j < number_of_copies; j++)\n     {\n-      for (i = group_size - 1; stmts.iterate (i, &stmt); i--)\n+      for (i = group_size - 1; stmts.iterate (i, &stmt_vinfo); i--)\n         {\n \t  tree op;\n \t  /* Get the def before the loop.  In reduction chain we have only\n@@ -4244,7 +4242,7 @@ get_initial_defs_for_reduction (slp_tree slp_node,\n \t      && neutral_op)\n \t    op = neutral_op;\n \t  else\n-\t    op = PHI_ARG_DEF_FROM_EDGE (stmt, pe);\n+\t    op = PHI_ARG_DEF_FROM_EDGE (stmt_vinfo->stmt, pe);\n \n           /* Create 'vect_ = {op0,op1,...,opn}'.  */\n           number_of_places_left_in_vector--;\n@@ -5128,7 +5126,8 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n       gcc_assert (pow2p_hwi (group_size));\n \n       slp_tree orig_phis_slp_node = slp_node_instance->reduc_phis;\n-      vec<gimple *> orig_phis = SLP_TREE_SCALAR_STMTS (orig_phis_slp_node);\n+      vec<stmt_vec_info> orig_phis\n+\t= SLP_TREE_SCALAR_STMTS (orig_phis_slp_node);\n       gimple_seq seq = NULL;\n \n       /* Build a vector {0, 1, 2, ...}, with the same number of elements\n@@ -5159,7 +5158,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n \t  if (!neutral_op)\n \t    {\n \t      tree scalar_value\n-\t\t= PHI_ARG_DEF_FROM_EDGE (orig_phis[i],\n+\t\t= PHI_ARG_DEF_FROM_EDGE (orig_phis[i]->stmt,\n \t\t\t\t\t loop_preheader_edge (loop));\n \t      vector_identity = gimple_build_vector_from_val (&seq, vectype,\n \t\t\t\t\t\t\t      scalar_value);\n@@ -5572,12 +5571,13 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n      the loop exit phi node.  */\n   if (REDUC_GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)))\n     {\n-      gimple *dest_stmt = SLP_TREE_SCALAR_STMTS (slp_node)[group_size - 1];\n+      stmt_vec_info dest_stmt_info\n+\t= SLP_TREE_SCALAR_STMTS (slp_node)[group_size - 1];\n       /* Handle reduction patterns.  */\n-      if (STMT_VINFO_RELATED_STMT (vinfo_for_stmt (dest_stmt)))\n-\tdest_stmt = STMT_VINFO_RELATED_STMT (vinfo_for_stmt (dest_stmt));\n+      if (STMT_VINFO_RELATED_STMT (dest_stmt_info))\n+\tdest_stmt_info = STMT_VINFO_RELATED_STMT (dest_stmt_info);\n \n-      scalar_dest = gimple_assign_lhs (dest_stmt);\n+      scalar_dest = gimple_assign_lhs (dest_stmt_info->stmt);\n       group_size = 1;\n     }\n \n@@ -5607,13 +5607,12 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n \n       if (slp_reduc)\n         {\n-\t  gimple *current_stmt = SLP_TREE_SCALAR_STMTS (slp_node)[k];\n+\t  stmt_vec_info scalar_stmt_info = SLP_TREE_SCALAR_STMTS (slp_node)[k];\n \n-\t  orig_stmt_info\n-\t    = STMT_VINFO_RELATED_STMT (vinfo_for_stmt (current_stmt));\n+\t  orig_stmt_info = STMT_VINFO_RELATED_STMT (scalar_stmt_info);\n \t  /* SLP statements can't participate in patterns.  */\n \t  gcc_assert (!orig_stmt_info);\n-\t  scalar_dest = gimple_assign_lhs (current_stmt);\n+\t  scalar_dest = gimple_assign_lhs (scalar_stmt_info->stmt);\n         }\n \n       phis.create (3);\n@@ -5881,23 +5880,23 @@ vectorize_fold_left_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n   tree op0 = ops[1 - reduc_index];\n \n   int group_size = 1;\n-  gimple *scalar_dest_def;\n+  stmt_vec_info scalar_dest_def_info;\n   auto_vec<tree> vec_oprnds0;\n   if (slp_node)\n     {\n       vect_get_vec_defs (op0, NULL_TREE, stmt, &vec_oprnds0, NULL, slp_node);\n       group_size = SLP_TREE_SCALAR_STMTS (slp_node).length ();\n-      scalar_dest_def = SLP_TREE_SCALAR_STMTS (slp_node)[group_size - 1];\n+      scalar_dest_def_info = SLP_TREE_SCALAR_STMTS (slp_node)[group_size - 1];\n     }\n   else\n     {\n       tree loop_vec_def0 = vect_get_vec_def_for_operand (op0, stmt);\n       vec_oprnds0.create (1);\n       vec_oprnds0.quick_push (loop_vec_def0);\n-      scalar_dest_def = stmt;\n+      scalar_dest_def_info = stmt_info;\n     }\n \n-  tree scalar_dest = gimple_assign_lhs (scalar_dest_def);\n+  tree scalar_dest = gimple_assign_lhs (scalar_dest_def_info->stmt);\n   tree scalar_type = TREE_TYPE (scalar_dest);\n   tree reduc_var = gimple_phi_result (reduc_def_stmt);\n \n@@ -5964,10 +5963,11 @@ vectorize_fold_left_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n       if (i == vec_num - 1)\n \t{\n \t  gimple_set_lhs (new_stmt, scalar_dest);\n-\t  new_stmt_info = vect_finish_replace_stmt (scalar_dest_def, new_stmt);\n+\t  new_stmt_info = vect_finish_replace_stmt (scalar_dest_def_info,\n+\t\t\t\t\t\t    new_stmt);\n \t}\n       else\n-\tnew_stmt_info = vect_finish_stmt_generation (scalar_dest_def,\n+\tnew_stmt_info = vect_finish_stmt_generation (scalar_dest_def_info,\n \t\t\t\t\t\t     new_stmt, gsi);\n \n       if (slp_node)"}, {"sha": "6f530fe61995ff412caaec47835b140d10fd88e5", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 247, "deletions": 239, "changes": 486, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b978758186fa187d52d2c4a02cdc8474d361a0dd/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b978758186fa187d52d2c4a02cdc8474d361a0dd/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=b978758186fa187d52d2c4a02cdc8474d361a0dd", "patch": "@@ -66,11 +66,11 @@ vect_free_slp_tree (slp_tree node, bool final_p)\n      statements would be redundant.  */\n   if (!final_p)\n     {\n-      gimple *stmt;\n-      FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, stmt)\n+      stmt_vec_info stmt_info;\n+      FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, stmt_info)\n \t{\n-\t  gcc_assert (STMT_VINFO_NUM_SLP_USES (vinfo_for_stmt (stmt)) > 0);\n-\t  STMT_VINFO_NUM_SLP_USES (vinfo_for_stmt (stmt))--;\n+\t  gcc_assert (STMT_VINFO_NUM_SLP_USES (stmt_info) > 0);\n+\t  STMT_VINFO_NUM_SLP_USES (stmt_info)--;\n \t}\n     }\n \n@@ -99,21 +99,21 @@ vect_free_slp_instance (slp_instance instance, bool final_p)\n /* Create an SLP node for SCALAR_STMTS.  */\n \n static slp_tree\n-vect_create_new_slp_node (vec<gimple *> scalar_stmts)\n+vect_create_new_slp_node (vec<stmt_vec_info> scalar_stmts)\n {\n   slp_tree node;\n-  gimple *stmt = scalar_stmts[0];\n+  stmt_vec_info stmt_info = scalar_stmts[0];\n   unsigned int nops;\n \n-  if (is_gimple_call (stmt))\n+  if (gcall *stmt = dyn_cast <gcall *> (stmt_info->stmt))\n     nops = gimple_call_num_args (stmt);\n-  else if (is_gimple_assign (stmt))\n+  else if (gassign *stmt = dyn_cast <gassign *> (stmt_info->stmt))\n     {\n       nops = gimple_num_ops (stmt) - 1;\n       if (gimple_assign_rhs_code (stmt) == COND_EXPR)\n \tnops++;\n     }\n-  else if (gimple_code (stmt) == GIMPLE_PHI)\n+  else if (is_a <gphi *> (stmt_info->stmt))\n     nops = 0;\n   else\n     return NULL;\n@@ -128,8 +128,8 @@ vect_create_new_slp_node (vec<gimple *> scalar_stmts)\n   SLP_TREE_DEF_TYPE (node) = vect_internal_def;\n \n   unsigned i;\n-  FOR_EACH_VEC_ELT (scalar_stmts, i, stmt)\n-    STMT_VINFO_NUM_SLP_USES (vinfo_for_stmt (stmt))++;\n+  FOR_EACH_VEC_ELT (scalar_stmts, i, stmt_info)\n+    STMT_VINFO_NUM_SLP_USES (stmt_info)++;\n \n   return node;\n }\n@@ -141,7 +141,7 @@ vect_create_new_slp_node (vec<gimple *> scalar_stmts)\n typedef struct _slp_oprnd_info\n {\n   /* Def-stmts for the operands.  */\n-  vec<gimple *> def_stmts;\n+  vec<stmt_vec_info> def_stmts;\n   /* Information about the first statement, its vector def-type, type, the\n      operand itself in case it's constant, and an indication if it's a pattern\n      stmt.  */\n@@ -297,10 +297,10 @@ can_duplicate_and_interleave_p (unsigned int count, machine_mode elt_mode,\n    ok return 0.  */\n static int\n vect_get_and_check_slp_defs (vec_info *vinfo, unsigned char *swap,\n-\t\t\t     vec<gimple *> stmts, unsigned stmt_num,\n+\t\t\t     vec<stmt_vec_info> stmts, unsigned stmt_num,\n \t\t\t     vec<slp_oprnd_info> *oprnds_info)\n {\n-  gimple *stmt = stmts[stmt_num];\n+  stmt_vec_info stmt_info = stmts[stmt_num];\n   tree oprnd;\n   unsigned int i, number_of_oprnds;\n   enum vect_def_type dt = vect_uninitialized_def;\n@@ -312,12 +312,12 @@ vect_get_and_check_slp_defs (vec_info *vinfo, unsigned char *swap,\n   bool first = stmt_num == 0;\n   bool second = stmt_num == 1;\n \n-  if (is_gimple_call (stmt))\n+  if (gcall *stmt = dyn_cast <gcall *> (stmt_info->stmt))\n     {\n       number_of_oprnds = gimple_call_num_args (stmt);\n       first_op_idx = 3;\n     }\n-  else if (is_gimple_assign (stmt))\n+  else if (gassign *stmt = dyn_cast <gassign *> (stmt_info->stmt))\n     {\n       enum tree_code code = gimple_assign_rhs_code (stmt);\n       number_of_oprnds = gimple_num_ops (stmt) - 1;\n@@ -347,12 +347,13 @@ vect_get_and_check_slp_defs (vec_info *vinfo, unsigned char *swap,\n \t  int *map = maps[*swap];\n \n \t  if (i < 2)\n-\t    oprnd = TREE_OPERAND (gimple_op (stmt, first_op_idx), map[i]);\n+\t    oprnd = TREE_OPERAND (gimple_op (stmt_info->stmt,\n+\t\t\t\t\t     first_op_idx), map[i]);\n \t  else\n-\t    oprnd = gimple_op (stmt, map[i]);\n+\t    oprnd = gimple_op (stmt_info->stmt, map[i]);\n \t}\n       else\n-\toprnd = gimple_op (stmt, first_op_idx + (swapped ? !i : i));\n+\toprnd = gimple_op (stmt_info->stmt, first_op_idx + (swapped ? !i : i));\n \n       oprnd_info = (*oprnds_info)[i];\n \n@@ -518,18 +519,20 @@ vect_get_and_check_slp_defs (vec_info *vinfo, unsigned char *swap,\n     {\n       /* If there are already uses of this stmt in a SLP instance then\n          we've committed to the operand order and can't swap it.  */\n-      if (STMT_VINFO_NUM_SLP_USES (vinfo_for_stmt (stmt)) != 0)\n+      if (STMT_VINFO_NUM_SLP_USES (stmt_info) != 0)\n \t{\n \t  if (dump_enabled_p ())\n \t    {\n \t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t       \"Build SLP failed: cannot swap operands of \"\n \t\t\t       \"shared stmt \");\n-\t      dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n+\t      dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n+\t\t\t\tstmt_info->stmt, 0);\n \t    }\n \t  return -1;\n \t}\n \n+      gassign *stmt = as_a <gassign *> (stmt_info->stmt);\n       if (first_op_cond)\n \t{\n \t  tree cond = gimple_assign_rhs1 (stmt);\n@@ -655,8 +658,9 @@ vect_record_max_nunits (vec_info *vinfo, gimple *stmt, unsigned int group_size,\n    would be permuted.  */\n \n static bool\n-vect_two_operations_perm_ok_p (vec<gimple *> stmts, unsigned int group_size,\n-\t\t\t       tree vectype, tree_code alt_stmt_code)\n+vect_two_operations_perm_ok_p (vec<stmt_vec_info> stmts,\n+\t\t\t       unsigned int group_size, tree vectype,\n+\t\t\t       tree_code alt_stmt_code)\n {\n   unsigned HOST_WIDE_INT count;\n   if (!TYPE_VECTOR_SUBPARTS (vectype).is_constant (&count))\n@@ -666,7 +670,8 @@ vect_two_operations_perm_ok_p (vec<gimple *> stmts, unsigned int group_size,\n   for (unsigned int i = 0; i < count; ++i)\n     {\n       unsigned int elt = i;\n-      if (gimple_assign_rhs_code (stmts[i % group_size]) == alt_stmt_code)\n+      gassign *stmt = as_a <gassign *> (stmts[i % group_size]->stmt);\n+      if (gimple_assign_rhs_code (stmt) == alt_stmt_code)\n \telt += count;\n       sel.quick_push (elt);\n     }\n@@ -690,12 +695,12 @@ vect_two_operations_perm_ok_p (vec<gimple *> stmts, unsigned int group_size,\n \n static bool\n vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n-\t\t       vec<gimple *> stmts, unsigned int group_size,\n+\t\t       vec<stmt_vec_info> stmts, unsigned int group_size,\n \t\t       poly_uint64 *max_nunits, bool *matches,\n \t\t       bool *two_operators)\n {\n   unsigned int i;\n-  gimple *first_stmt = stmts[0], *stmt = stmts[0];\n+  stmt_vec_info first_stmt_info = stmts[0];\n   enum tree_code first_stmt_code = ERROR_MARK;\n   enum tree_code alt_stmt_code = ERROR_MARK;\n   enum tree_code rhs_code = ERROR_MARK;\n@@ -710,9 +715,10 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n   gimple *first_load = NULL, *prev_first_load = NULL;\n \n   /* For every stmt in NODE find its def stmt/s.  */\n-  FOR_EACH_VEC_ELT (stmts, i, stmt)\n+  stmt_vec_info stmt_info;\n+  FOR_EACH_VEC_ELT (stmts, i, stmt_info)\n     {\n-      stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+      gimple *stmt = stmt_info->stmt;\n       swap[i] = 0;\n       matches[i] = false;\n \n@@ -723,7 +729,7 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n \t}\n \n       /* Fail to vectorize statements marked as unvectorizable.  */\n-      if (!STMT_VINFO_VECTORIZABLE (vinfo_for_stmt (stmt)))\n+      if (!STMT_VINFO_VECTORIZABLE (stmt_info))\n         {\n           if (dump_enabled_p ())\n             {\n@@ -755,7 +761,7 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n       if (!vect_get_vector_types_for_stmt (stmt_info, &vectype,\n \t\t\t\t\t   &nunits_vectype)\n \t  || (nunits_vectype\n-\t      && !vect_record_max_nunits (vinfo, stmt, group_size,\n+\t      && !vect_record_max_nunits (vinfo, stmt_info, group_size,\n \t\t\t\t\t  nunits_vectype, max_nunits)))\n \t{\n \t  /* Fatal mismatch.  */\n@@ -877,7 +883,7 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n \t\t   && (alt_stmt_code == PLUS_EXPR\n \t\t       || alt_stmt_code == MINUS_EXPR)\n \t\t   && rhs_code == alt_stmt_code)\n-              && !(STMT_VINFO_GROUPED_ACCESS (vinfo_for_stmt (stmt))\n+\t      && !(STMT_VINFO_GROUPED_ACCESS (stmt_info)\n                    && (first_stmt_code == ARRAY_REF\n                        || first_stmt_code == BIT_FIELD_REF\n                        || first_stmt_code == INDIRECT_REF\n@@ -893,7 +899,7 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n \t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t\t   \"original stmt \");\n \t\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-\t\t\t\t    first_stmt, 0);\n+\t\t\t\t    first_stmt_info->stmt, 0);\n \t\t}\n \t      /* Mismatch.  */\n \t      continue;\n@@ -915,8 +921,7 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n \n \t  if (rhs_code == CALL_EXPR)\n \t    {\n-\t      gimple *first_stmt = stmts[0];\n-\t      if (!compatible_calls_p (as_a <gcall *> (first_stmt),\n+\t      if (!compatible_calls_p (as_a <gcall *> (stmts[0]->stmt),\n \t\t\t\t       as_a <gcall *> (stmt)))\n \t\t{\n \t\t  if (dump_enabled_p ())\n@@ -933,7 +938,7 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n \t}\n \n       /* Grouped store or load.  */\n-      if (STMT_VINFO_GROUPED_ACCESS (vinfo_for_stmt (stmt)))\n+      if (STMT_VINFO_GROUPED_ACCESS (stmt_info))\n \t{\n \t  if (REFERENCE_CLASS_P (lhs))\n \t    {\n@@ -943,7 +948,7 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n \t  else\n \t    {\n \t      /* Load.  */\n-              first_load = DR_GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt));\n+\t      first_load = DR_GROUP_FIRST_ELEMENT (stmt_info);\n               if (prev_first_load)\n                 {\n                   /* Check that there are no loads from different interleaving\n@@ -1061,7 +1066,7 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n \t\t\t\t\t     vectype, alt_stmt_code))\n \t{\n \t  for (i = 0; i < group_size; ++i)\n-\t    if (gimple_assign_rhs_code (stmts[i]) == alt_stmt_code)\n+\t    if (gimple_assign_rhs_code (stmts[i]->stmt) == alt_stmt_code)\n \t      {\n \t\tmatches[i] = false;\n \t\tif (dump_enabled_p ())\n@@ -1070,11 +1075,11 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n \t\t\t\t     \"Build SLP failed: different operation \"\n \t\t\t\t     \"in stmt \");\n \t\t    dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-\t\t\t\t      stmts[i], 0);\n+\t\t\t\t      stmts[i]->stmt, 0);\n \t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t\t     \"original stmt \");\n \t\t    dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-\t\t\t\t      first_stmt, 0);\n+\t\t\t\t      first_stmt_info->stmt, 0);\n \t\t  }\n \t      }\n \t  return false;\n@@ -1090,8 +1095,8 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n    need a special value for deleted that differs from empty.  */\n struct bst_traits\n {\n-  typedef vec <gimple *> value_type;\n-  typedef vec <gimple *> compare_type;\n+  typedef vec <stmt_vec_info> value_type;\n+  typedef vec <stmt_vec_info> compare_type;\n   static inline hashval_t hash (value_type);\n   static inline bool equal (value_type existing, value_type candidate);\n   static inline bool is_empty (value_type x) { return !x.exists (); }\n@@ -1105,7 +1110,7 @@ bst_traits::hash (value_type x)\n {\n   inchash::hash h;\n   for (unsigned i = 0; i < x.length (); ++i)\n-    h.add_int (gimple_uid (x[i]));\n+    h.add_int (gimple_uid (x[i]->stmt));\n   return h.end ();\n }\n inline bool\n@@ -1128,15 +1133,15 @@ typedef hash_map <vec <gimple *>, slp_tree,\n \n static slp_tree\n vect_build_slp_tree_2 (vec_info *vinfo,\n-\t\t       vec<gimple *> stmts, unsigned int group_size,\n+\t\t       vec<stmt_vec_info> stmts, unsigned int group_size,\n \t\t       poly_uint64 *max_nunits,\n \t\t       vec<slp_tree> *loads,\n \t\t       bool *matches, unsigned *npermutes, unsigned *tree_size,\n \t\t       unsigned max_tree_size);\n \n static slp_tree\n vect_build_slp_tree (vec_info *vinfo,\n-\t\t     vec<gimple *> stmts, unsigned int group_size,\n+\t\t     vec<stmt_vec_info> stmts, unsigned int group_size,\n \t\t     poly_uint64 *max_nunits, vec<slp_tree> *loads,\n \t\t     bool *matches, unsigned *npermutes, unsigned *tree_size,\n \t\t     unsigned max_tree_size)\n@@ -1151,7 +1156,7 @@ vect_build_slp_tree (vec_info *vinfo,\n      scalars, see PR81723.  */\n   if (! res)\n     {\n-      vec <gimple *> x;\n+      vec <stmt_vec_info> x;\n       x.create (stmts.length ());\n       x.splice (stmts);\n       bst_fail->add (x);\n@@ -1168,61 +1173,62 @@ vect_build_slp_tree (vec_info *vinfo,\n \n static slp_tree\n vect_build_slp_tree_2 (vec_info *vinfo,\n-\t\t       vec<gimple *> stmts, unsigned int group_size,\n+\t\t       vec<stmt_vec_info> stmts, unsigned int group_size,\n \t\t       poly_uint64 *max_nunits,\n \t\t       vec<slp_tree> *loads,\n \t\t       bool *matches, unsigned *npermutes, unsigned *tree_size,\n \t\t       unsigned max_tree_size)\n {\n   unsigned nops, i, this_tree_size = 0;\n   poly_uint64 this_max_nunits = *max_nunits;\n-  gimple *stmt;\n   slp_tree node;\n \n   matches[0] = false;\n \n-  stmt = stmts[0];\n-  if (is_gimple_call (stmt))\n+  stmt_vec_info stmt_info = stmts[0];\n+  if (gcall *stmt = dyn_cast <gcall *> (stmt_info->stmt))\n     nops = gimple_call_num_args (stmt);\n-  else if (is_gimple_assign (stmt))\n+  else if (gassign *stmt = dyn_cast <gassign *> (stmt_info->stmt))\n     {\n       nops = gimple_num_ops (stmt) - 1;\n       if (gimple_assign_rhs_code (stmt) == COND_EXPR)\n \tnops++;\n     }\n-  else if (gimple_code (stmt) == GIMPLE_PHI)\n+  else if (is_a <gphi *> (stmt_info->stmt))\n     nops = 0;\n   else\n     return NULL;\n \n   /* If the SLP node is a PHI (induction or reduction), terminate\n      the recursion.  */\n-  if (gimple_code (stmt) == GIMPLE_PHI)\n+  if (gphi *stmt = dyn_cast <gphi *> (stmt_info->stmt))\n     {\n       tree scalar_type = TREE_TYPE (PHI_RESULT (stmt));\n       tree vectype = get_vectype_for_scalar_type (scalar_type);\n-      if (!vect_record_max_nunits (vinfo, stmt, group_size, vectype,\n+      if (!vect_record_max_nunits (vinfo, stmt_info, group_size, vectype,\n \t\t\t\t   max_nunits))\n \treturn NULL;\n \n-      vect_def_type def_type = STMT_VINFO_DEF_TYPE (vinfo_for_stmt (stmt));\n+      vect_def_type def_type = STMT_VINFO_DEF_TYPE (stmt_info);\n       /* Induction from different IVs is not supported.  */\n       if (def_type == vect_induction_def)\n \t{\n-\t  FOR_EACH_VEC_ELT (stmts, i, stmt)\n-\t    if (stmt != stmts[0])\n+\t  stmt_vec_info other_info;\n+\t  FOR_EACH_VEC_ELT (stmts, i, other_info)\n+\t    if (stmt_info != other_info)\n \t      return NULL;\n \t}\n       else\n \t{\n \t  /* Else def types have to match.  */\n-\t  FOR_EACH_VEC_ELT (stmts, i, stmt)\n+\t  stmt_vec_info other_info;\n+\t  FOR_EACH_VEC_ELT (stmts, i, other_info)\n \t    {\n \t      /* But for reduction chains only check on the first stmt.  */\n-\t      if (REDUC_GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt))\n-\t\t  && REDUC_GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)) != stmt)\n+\t      if (REDUC_GROUP_FIRST_ELEMENT (other_info)\n+\t\t  && REDUC_GROUP_FIRST_ELEMENT (other_info) != stmt_info)\n \t\tcontinue;\n-\t      if (STMT_VINFO_DEF_TYPE (vinfo_for_stmt (stmt)) != def_type)\n+\t      if (STMT_VINFO_DEF_TYPE (other_info) != def_type)\n \t\treturn NULL;\n \t    }\n \t}\n@@ -1238,8 +1244,8 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n     return NULL;\n \n   /* If the SLP node is a load, terminate the recursion.  */\n-  if (STMT_VINFO_GROUPED_ACCESS (vinfo_for_stmt (stmt))\n-      && DR_IS_READ (STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt))))\n+  if (STMT_VINFO_GROUPED_ACCESS (stmt_info)\n+      && DR_IS_READ (STMT_VINFO_DATA_REF (stmt_info)))\n     {\n       *max_nunits = this_max_nunits;\n       node = vect_create_new_slp_node (stmts);\n@@ -1250,7 +1256,7 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n   /* Get at the operands, verifying they are compatible.  */\n   vec<slp_oprnd_info> oprnds_info = vect_create_oprnd_info (nops, group_size);\n   slp_oprnd_info oprnd_info;\n-  FOR_EACH_VEC_ELT (stmts, i, stmt)\n+  FOR_EACH_VEC_ELT (stmts, i, stmt_info)\n     {\n       int res = vect_get_and_check_slp_defs (vinfo, &swap[i],\n \t\t\t\t\t     stmts, i, &oprnds_info);\n@@ -1269,7 +1275,7 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n   auto_vec<slp_tree, 4> children;\n   auto_vec<slp_tree> this_loads;\n \n-  stmt = stmts[0];\n+  stmt_info = stmts[0];\n \n   if (tree_size)\n     max_tree_size -= *tree_size;\n@@ -1307,8 +1313,7 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \t      /* ???  Rejecting patterns this way doesn't work.  We'd have to\n \t\t do extra work to cancel the pattern so the uses see the\n \t\t scalar version.  */\n-\t      && !is_pattern_stmt_p\n-\t            (vinfo_for_stmt (SLP_TREE_SCALAR_STMTS (child)[0])))\n+\t      && !is_pattern_stmt_p (SLP_TREE_SCALAR_STMTS (child)[0]))\n \t    {\n \t      slp_tree grandchild;\n \n@@ -1352,7 +1357,7 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \t  /* ???  Rejecting patterns this way doesn't work.  We'd have to\n \t     do extra work to cancel the pattern so the uses see the\n \t     scalar version.  */\n-\t  && !is_pattern_stmt_p (vinfo_for_stmt (stmt)))\n+\t  && !is_pattern_stmt_p (stmt_info))\n \t{\n \t  dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t   \"Building vector operands from scalars\\n\");\n@@ -1373,7 +1378,7 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \t     as well as the arms under some constraints.  */\n \t  && nops == 2\n \t  && oprnds_info[1]->first_dt == vect_internal_def\n-\t  && is_gimple_assign (stmt)\n+\t  && is_gimple_assign (stmt_info->stmt)\n \t  /* Do so only if the number of not successful permutes was nor more\n \t     than a cut-ff as re-trying the recursive match on\n \t     possibly each level of the tree would expose exponential\n@@ -1389,9 +1394,10 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \t\t{\n \t\t  if (matches[j] != !swap_not_matching)\n \t\t    continue;\n-\t\t  gimple *stmt = stmts[j];\n+\t\t  stmt_vec_info stmt_info = stmts[j];\n \t\t  /* Verify if we can swap operands of this stmt.  */\n-\t\t  if (!is_gimple_assign (stmt)\n+\t\t  gassign *stmt = dyn_cast <gassign *> (stmt_info->stmt);\n+\t\t  if (!stmt\n \t\t      || !commutative_tree_code (gimple_assign_rhs_code (stmt)))\n \t\t    {\n \t\t      if (!swap_not_matching)\n@@ -1406,7 +1412,7 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \t\t     node and temporarily do that when processing it\n \t\t     (or wrap operand accessors in a helper).  */\n \t\t  else if (swap[j] != 0\n-\t\t\t   || STMT_VINFO_NUM_SLP_USES (vinfo_for_stmt (stmt)))\n+\t\t\t   || STMT_VINFO_NUM_SLP_USES (stmt_info))\n \t\t    {\n \t\t      if (!swap_not_matching)\n \t\t\t{\n@@ -1417,7 +1423,7 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \t\t\t\t\t       \"Build SLP failed: cannot swap \"\n \t\t\t\t\t       \"operands of shared stmt \");\n \t\t\t      dump_gimple_stmt (MSG_MISSED_OPTIMIZATION,\n-\t\t\t\t\t\tTDF_SLIM, stmts[j], 0);\n+\t\t\t\t\t\tTDF_SLIM, stmts[j]->stmt, 0);\n \t\t\t    }\n \t\t\t  goto fail;\n \t\t\t}\n@@ -1454,40 +1460,31 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \t\t if we end up building the operand from scalars as\n \t\t we'll continue to process swapped operand two.  */\n \t      for (j = 0; j < group_size; ++j)\n-\t\t{\n-\t\t  gimple *stmt = stmts[j];\n-\t\t  gimple_set_plf (stmt, GF_PLF_1, false);\n-\t\t}\n+\t\tgimple_set_plf (stmts[j]->stmt, GF_PLF_1, false);\n \t      for (j = 0; j < group_size; ++j)\n-\t\t{\n-\t\t  gimple *stmt = stmts[j];\n-\t\t  if (matches[j] == !swap_not_matching)\n-\t\t    {\n-\t\t      /* Avoid swapping operands twice.  */\n-\t\t      if (gimple_plf (stmt, GF_PLF_1))\n-\t\t\tcontinue;\n-\t\t      swap_ssa_operands (stmt, gimple_assign_rhs1_ptr (stmt),\n-\t\t\t\t\t gimple_assign_rhs2_ptr (stmt));\n-\t\t      gimple_set_plf (stmt, GF_PLF_1, true);\n-\t\t    }\n-\t\t}\n+\t\tif (matches[j] == !swap_not_matching)\n+\t\t  {\n+\t\t    gassign *stmt = as_a <gassign *> (stmts[j]->stmt);\n+\t\t    /* Avoid swapping operands twice.  */\n+\t\t    if (gimple_plf (stmt, GF_PLF_1))\n+\t\t      continue;\n+\t\t    swap_ssa_operands (stmt, gimple_assign_rhs1_ptr (stmt),\n+\t\t\t\t       gimple_assign_rhs2_ptr (stmt));\n+\t\t    gimple_set_plf (stmt, GF_PLF_1, true);\n+\t\t  }\n \t      /* Verify we swap all duplicates or none.  */\n \t      if (flag_checking)\n \t\tfor (j = 0; j < group_size; ++j)\n-\t\t  {\n-\t\t    gimple *stmt = stmts[j];\n-\t\t    gcc_assert (gimple_plf (stmt, GF_PLF_1)\n-\t\t\t\t== (matches[j] == !swap_not_matching));\n-\t\t  }\n+\t\t  gcc_assert (gimple_plf (stmts[j]->stmt, GF_PLF_1)\n+\t\t\t      == (matches[j] == !swap_not_matching));\n \n \t      /* If we have all children of child built up from scalars then\n \t\t just throw that away and build it up this node from scalars.  */\n \t      if (!SLP_TREE_CHILDREN (child).is_empty ()\n \t\t  /* ???  Rejecting patterns this way doesn't work.  We'd have\n \t\t     to do extra work to cancel the pattern so the uses see the\n \t\t     scalar version.  */\n-\t\t  && !is_pattern_stmt_p\n-\t\t\t(vinfo_for_stmt (SLP_TREE_SCALAR_STMTS (child)[0])))\n+\t\t  && !is_pattern_stmt_p (SLP_TREE_SCALAR_STMTS (child)[0]))\n \t\t{\n \t\t  unsigned int j;\n \t\t  slp_tree grandchild;\n@@ -1550,16 +1547,16 @@ vect_print_slp_tree (dump_flags_t dump_kind, dump_location_t loc,\n \t\t     slp_tree node)\n {\n   int i;\n-  gimple *stmt;\n+  stmt_vec_info stmt_info;\n   slp_tree child;\n \n   dump_printf_loc (dump_kind, loc, \"node%s\\n\",\n \t\t   SLP_TREE_DEF_TYPE (node) != vect_internal_def\n \t\t   ? \" (external)\" : \"\");\n-  FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, stmt)\n+  FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, stmt_info)\n     {\n       dump_printf_loc (dump_kind, loc, \"\\tstmt %d \", i);\n-      dump_gimple_stmt (dump_kind, TDF_SLIM, stmt, 0);\n+      dump_gimple_stmt (dump_kind, TDF_SLIM, stmt_info->stmt, 0);\n     }\n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n     vect_print_slp_tree (dump_kind, loc, child);\n@@ -1575,15 +1572,15 @@ static void\n vect_mark_slp_stmts (slp_tree node, enum slp_vect_type mark, int j)\n {\n   int i;\n-  gimple *stmt;\n+  stmt_vec_info stmt_info;\n   slp_tree child;\n \n   if (SLP_TREE_DEF_TYPE (node) != vect_internal_def)\n     return;\n \n-  FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, stmt)\n+  FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, stmt_info)\n     if (j < 0 || i == j)\n-      STMT_SLP_TYPE (vinfo_for_stmt (stmt)) = mark;\n+      STMT_SLP_TYPE (stmt_info) = mark;\n \n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n     vect_mark_slp_stmts (child, mark, j);\n@@ -1596,16 +1593,14 @@ static void\n vect_mark_slp_stmts_relevant (slp_tree node)\n {\n   int i;\n-  gimple *stmt;\n   stmt_vec_info stmt_info;\n   slp_tree child;\n \n   if (SLP_TREE_DEF_TYPE (node) != vect_internal_def)\n     return;\n \n-  FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, stmt)\n+  FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, stmt_info)\n     {\n-      stmt_info = vinfo_for_stmt (stmt);\n       gcc_assert (!STMT_VINFO_RELEVANT (stmt_info)\n                   || STMT_VINFO_RELEVANT (stmt_info) == vect_used_in_scope);\n       STMT_VINFO_RELEVANT (stmt_info) = vect_used_in_scope;\n@@ -1622,8 +1617,8 @@ static void\n vect_slp_rearrange_stmts (slp_tree node, unsigned int group_size,\n                           vec<unsigned> permutation)\n {\n-  gimple *stmt;\n-  vec<gimple *> tmp_stmts;\n+  stmt_vec_info stmt_info;\n+  vec<stmt_vec_info> tmp_stmts;\n   unsigned int i;\n   slp_tree child;\n \n@@ -1634,8 +1629,8 @@ vect_slp_rearrange_stmts (slp_tree node, unsigned int group_size,\n   tmp_stmts.create (group_size);\n   tmp_stmts.quick_grow_cleared (group_size);\n \n-  FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, stmt)\n-    tmp_stmts[permutation[i]] = stmt;\n+  FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, stmt_info)\n+    tmp_stmts[permutation[i]] = stmt_info;\n \n   SLP_TREE_SCALAR_STMTS (node).release ();\n   SLP_TREE_SCALAR_STMTS (node) = tmp_stmts;\n@@ -1696,13 +1691,14 @@ vect_attempt_slp_rearrange_stmts (slp_instance slp_instn)\n   poly_uint64 unrolling_factor = SLP_INSTANCE_UNROLLING_FACTOR (slp_instn);\n   FOR_EACH_VEC_ELT (SLP_INSTANCE_LOADS (slp_instn), i, node)\n     {\n-      gimple *first_stmt = SLP_TREE_SCALAR_STMTS (node)[0];\n-      first_stmt = DR_GROUP_FIRST_ELEMENT (vinfo_for_stmt (first_stmt));\n+      stmt_vec_info first_stmt_info = SLP_TREE_SCALAR_STMTS (node)[0];\n+      first_stmt_info\n+\t= vinfo_for_stmt (DR_GROUP_FIRST_ELEMENT (first_stmt_info));\n       /* But we have to keep those permutations that are required because\n          of handling of gaps.  */\n       if (known_eq (unrolling_factor, 1U)\n-\t  || (group_size == DR_GROUP_SIZE (vinfo_for_stmt (first_stmt))\n-\t      && DR_GROUP_GAP (vinfo_for_stmt (first_stmt)) == 0))\n+\t  || (group_size == DR_GROUP_SIZE (first_stmt_info)\n+\t      && DR_GROUP_GAP (first_stmt_info) == 0))\n \tSLP_TREE_LOAD_PERMUTATION (node).release ();\n       else\n \tfor (j = 0; j < SLP_TREE_LOAD_PERMUTATION (node).length (); ++j)\n@@ -1721,7 +1717,7 @@ vect_supported_load_permutation_p (slp_instance slp_instn)\n   unsigned int group_size = SLP_INSTANCE_GROUP_SIZE (slp_instn);\n   unsigned int i, j, k, next;\n   slp_tree node;\n-  gimple *stmt, *load, *next_load;\n+  gimple *next_load;\n \n   if (dump_enabled_p ())\n     {\n@@ -1750,18 +1746,18 @@ vect_supported_load_permutation_p (slp_instance slp_instn)\n       return false;\n \n   node = SLP_INSTANCE_TREE (slp_instn);\n-  stmt = SLP_TREE_SCALAR_STMTS (node)[0];\n+  stmt_vec_info stmt_info = SLP_TREE_SCALAR_STMTS (node)[0];\n \n   /* Reduction (there are no data-refs in the root).\n      In reduction chain the order of the loads is not important.  */\n-  if (!STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt))\n-      && !REDUC_GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)))\n+  if (!STMT_VINFO_DATA_REF (stmt_info)\n+      && !REDUC_GROUP_FIRST_ELEMENT (stmt_info))\n     vect_attempt_slp_rearrange_stmts (slp_instn);\n \n   /* In basic block vectorization we allow any subchain of an interleaving\n      chain.\n      FORNOW: not supported in loop SLP because of realignment compications.  */\n-  if (STMT_VINFO_BB_VINFO (vinfo_for_stmt (stmt)))\n+  if (STMT_VINFO_BB_VINFO (stmt_info))\n     {\n       /* Check whether the loads in an instance form a subchain and thus\n          no permutation is necessary.  */\n@@ -1771,24 +1767,25 @@ vect_supported_load_permutation_p (slp_instance slp_instn)\n \t    continue;\n \t  bool subchain_p = true;\n           next_load = NULL;\n-          FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), j, load)\n-            {\n-              if (j != 0\n-\t\t  && (next_load != load\n-\t\t      || DR_GROUP_GAP (vinfo_for_stmt (load)) != 1))\n+\t  stmt_vec_info load_info;\n+\t  FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), j, load_info)\n+\t    {\n+\t      if (j != 0\n+\t\t  && (next_load != load_info\n+\t\t      || DR_GROUP_GAP (load_info) != 1))\n \t\t{\n \t\t  subchain_p = false;\n \t\t  break;\n \t\t}\n-              next_load = DR_GROUP_NEXT_ELEMENT (vinfo_for_stmt (load));\n-            }\n+\t      next_load = DR_GROUP_NEXT_ELEMENT (load_info);\n+\t    }\n \t  if (subchain_p)\n \t    SLP_TREE_LOAD_PERMUTATION (node).release ();\n \t  else\n \t    {\n-\t      stmt_vec_info group_info\n-\t\t= vinfo_for_stmt (SLP_TREE_SCALAR_STMTS (node)[0]);\n-\t      group_info = vinfo_for_stmt (DR_GROUP_FIRST_ELEMENT (group_info));\n+\t      stmt_vec_info group_info = SLP_TREE_SCALAR_STMTS (node)[0];\n+\t      group_info\n+\t\t= vinfo_for_stmt (DR_GROUP_FIRST_ELEMENT (group_info));\n \t      unsigned HOST_WIDE_INT nunits;\n \t      unsigned k, maxk = 0;\n \t      FOR_EACH_VEC_ELT (SLP_TREE_LOAD_PERMUTATION (node), j, k)\n@@ -1831,7 +1828,7 @@ vect_supported_load_permutation_p (slp_instance slp_instn)\n   poly_uint64 test_vf\n     = force_common_multiple (SLP_INSTANCE_UNROLLING_FACTOR (slp_instn),\n \t\t\t     LOOP_VINFO_VECT_FACTOR\n-\t\t\t     (STMT_VINFO_LOOP_VINFO (vinfo_for_stmt (stmt))));\n+\t\t\t     (STMT_VINFO_LOOP_VINFO (stmt_info)));\n   FOR_EACH_VEC_ELT (SLP_INSTANCE_LOADS (slp_instn), i, node)\n     if (node->load_permutation.exists ()\n \t&& !vect_transform_slp_perm_load (node, vNULL, NULL, test_vf,\n@@ -1847,15 +1844,15 @@ vect_supported_load_permutation_p (slp_instance slp_instn)\n gimple *\n vect_find_last_scalar_stmt_in_slp (slp_tree node)\n {\n-  gimple *last = NULL, *stmt;\n+  gimple *last = NULL;\n+  stmt_vec_info stmt_vinfo;\n \n-  for (int i = 0; SLP_TREE_SCALAR_STMTS (node).iterate (i, &stmt); i++)\n+  for (int i = 0; SLP_TREE_SCALAR_STMTS (node).iterate (i, &stmt_vinfo); i++)\n     {\n-      stmt_vec_info stmt_vinfo = vinfo_for_stmt (stmt);\n       if (is_pattern_stmt_p (stmt_vinfo))\n \tlast = get_later_stmt (STMT_VINFO_RELATED_STMT (stmt_vinfo), last);\n       else\n-\tlast = get_later_stmt (stmt, last);\n+\tlast = get_later_stmt (stmt_vinfo, last);\n     }\n \n   return last;\n@@ -1926,6 +1923,7 @@ static bool\n vect_analyze_slp_instance (vec_info *vinfo,\n \t\t\t   gimple *stmt, unsigned max_tree_size)\n {\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   slp_instance new_instance;\n   slp_tree node;\n   unsigned int group_size;\n@@ -1934,25 +1932,25 @@ vect_analyze_slp_instance (vec_info *vinfo,\n   stmt_vec_info next_info;\n   unsigned int i;\n   vec<slp_tree> loads;\n-  struct data_reference *dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt));\n-  vec<gimple *> scalar_stmts;\n+  struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n+  vec<stmt_vec_info> scalar_stmts;\n \n-  if (STMT_VINFO_GROUPED_ACCESS (vinfo_for_stmt (stmt)))\n+  if (STMT_VINFO_GROUPED_ACCESS (stmt_info))\n     {\n       scalar_type = TREE_TYPE (DR_REF (dr));\n       vectype = get_vectype_for_scalar_type (scalar_type);\n-      group_size = DR_GROUP_SIZE (vinfo_for_stmt (stmt));\n+      group_size = DR_GROUP_SIZE (stmt_info);\n     }\n-  else if (!dr && REDUC_GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)))\n+  else if (!dr && REDUC_GROUP_FIRST_ELEMENT (stmt_info))\n     {\n       gcc_assert (is_a <loop_vec_info> (vinfo));\n-      vectype = STMT_VINFO_VECTYPE (vinfo_for_stmt (stmt));\n-      group_size = REDUC_GROUP_SIZE (vinfo_for_stmt (stmt));\n+      vectype = STMT_VINFO_VECTYPE (stmt_info);\n+      group_size = REDUC_GROUP_SIZE (stmt_info);\n     }\n   else\n     {\n       gcc_assert (is_a <loop_vec_info> (vinfo));\n-      vectype = STMT_VINFO_VECTYPE (vinfo_for_stmt (stmt));\n+      vectype = STMT_VINFO_VECTYPE (stmt_info);\n       group_size = as_a <loop_vec_info> (vinfo)->reductions.length ();\n     }\n \n@@ -1973,38 +1971,38 @@ vect_analyze_slp_instance (vec_info *vinfo,\n   /* Create a node (a root of the SLP tree) for the packed grouped stores.  */\n   scalar_stmts.create (group_size);\n   next = stmt;\n-  if (STMT_VINFO_GROUPED_ACCESS (vinfo_for_stmt (stmt)))\n+  if (STMT_VINFO_GROUPED_ACCESS (stmt_info))\n     {\n       /* Collect the stores and store them in SLP_TREE_SCALAR_STMTS.  */\n       while (next)\n         {\n-\t  if (STMT_VINFO_IN_PATTERN_P (vinfo_for_stmt (next))\n-\t      && STMT_VINFO_RELATED_STMT (vinfo_for_stmt (next)))\n-\t    scalar_stmts.safe_push (\n-\t\t  STMT_VINFO_RELATED_STMT (vinfo_for_stmt (next)));\n+\t  next_info = vinfo_for_stmt (next);\n+\t  if (STMT_VINFO_IN_PATTERN_P (next_info)\n+\t      && STMT_VINFO_RELATED_STMT (next_info))\n+\t    scalar_stmts.safe_push (STMT_VINFO_RELATED_STMT (next_info));\n \t  else\n-            scalar_stmts.safe_push (next);\n+\t    scalar_stmts.safe_push (next_info);\n           next = DR_GROUP_NEXT_ELEMENT (vinfo_for_stmt (next));\n         }\n     }\n-  else if (!dr && REDUC_GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)))\n+  else if (!dr && REDUC_GROUP_FIRST_ELEMENT (stmt_info))\n     {\n       /* Collect the reduction stmts and store them in\n \t SLP_TREE_SCALAR_STMTS.  */\n       while (next)\n         {\n-\t  if (STMT_VINFO_IN_PATTERN_P (vinfo_for_stmt (next))\n-\t      && STMT_VINFO_RELATED_STMT (vinfo_for_stmt (next)))\n-\t    scalar_stmts.safe_push (\n-\t\t  STMT_VINFO_RELATED_STMT (vinfo_for_stmt (next)));\n+\t  next_info = vinfo_for_stmt (next);\n+\t  if (STMT_VINFO_IN_PATTERN_P (next_info)\n+\t      && STMT_VINFO_RELATED_STMT (next_info))\n+\t    scalar_stmts.safe_push (STMT_VINFO_RELATED_STMT (next_info));\n \t  else\n-            scalar_stmts.safe_push (next);\n+\t    scalar_stmts.safe_push (next_info);\n           next = REDUC_GROUP_NEXT_ELEMENT (vinfo_for_stmt (next));\n         }\n       /* Mark the first element of the reduction chain as reduction to properly\n \t transform the node.  In the reduction analysis phase only the last\n \t element of the chain is marked as reduction.  */\n-      STMT_VINFO_DEF_TYPE (vinfo_for_stmt (stmt)) = vect_reduction_def;\n+      STMT_VINFO_DEF_TYPE (stmt_info) = vect_reduction_def;\n     }\n   else\n     {\n@@ -2068,15 +2066,16 @@ vect_analyze_slp_instance (vec_info *vinfo,\n \t{\n \t  vec<unsigned> load_permutation;\n \t  int j;\n-\t  gimple *load, *first_stmt;\n+\t  stmt_vec_info load_info;\n+\t  gimple *first_stmt;\n \t  bool this_load_permuted = false;\n \t  load_permutation.create (group_size);\n \t  first_stmt = DR_GROUP_FIRST_ELEMENT\n-\t      (vinfo_for_stmt (SLP_TREE_SCALAR_STMTS (load_node)[0]));\n-\t  FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (load_node), j, load)\n+\t    (SLP_TREE_SCALAR_STMTS (load_node)[0]);\n+\t  FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (load_node), j, load_info)\n \t    {\n-\t\t  int load_place = vect_get_place_in_interleaving_chain\n-\t\t\t\t     (load, first_stmt);\n+\t      int load_place = vect_get_place_in_interleaving_chain\n+\t\t(load_info, first_stmt);\n \t      gcc_assert (load_place != -1);\n \t      if (load_place != j)\n \t\tthis_load_permuted = true;\n@@ -2124,7 +2123,7 @@ vect_analyze_slp_instance (vec_info *vinfo,\n \t  FOR_EACH_VEC_ELT (loads, i, load_node)\n \t    {\n \t      gimple *first_stmt = DR_GROUP_FIRST_ELEMENT\n-\t\t  (vinfo_for_stmt (SLP_TREE_SCALAR_STMTS (load_node)[0]));\n+\t\t(SLP_TREE_SCALAR_STMTS (load_node)[0]);\n \t      stmt_vec_info stmt_vinfo = vinfo_for_stmt (first_stmt);\n \t\t  /* Use SLP for strided accesses (or if we\n \t\t     can't load-lanes).  */\n@@ -2307,10 +2306,10 @@ vect_make_slp_decision (loop_vec_info loop_vinfo)\n static void\n vect_detect_hybrid_slp_stmts (slp_tree node, unsigned i, slp_vect_type stype)\n {\n-  gimple *stmt = SLP_TREE_SCALAR_STMTS (node)[i];\n+  stmt_vec_info stmt_vinfo = SLP_TREE_SCALAR_STMTS (node)[i];\n   imm_use_iterator imm_iter;\n   gimple *use_stmt;\n-  stmt_vec_info use_vinfo, stmt_vinfo = vinfo_for_stmt (stmt);\n+  stmt_vec_info use_vinfo;\n   slp_tree child;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n   int j;\n@@ -2326,6 +2325,7 @@ vect_detect_hybrid_slp_stmts (slp_tree node, unsigned i, slp_vect_type stype)\n       gcc_checking_assert (PURE_SLP_STMT (stmt_vinfo));\n       /* If we get a pattern stmt here we have to use the LHS of the\n          original stmt for immediate uses.  */\n+      gimple *stmt = stmt_vinfo->stmt;\n       if (! STMT_VINFO_IN_PATTERN_P (stmt_vinfo)\n \t  && STMT_VINFO_RELATED_STMT (stmt_vinfo))\n \tstmt = STMT_VINFO_RELATED_STMT (stmt_vinfo)->stmt;\n@@ -2366,7 +2366,7 @@ vect_detect_hybrid_slp_stmts (slp_tree node, unsigned i, slp_vect_type stype)\n       if (dump_enabled_p ())\n \t{\n \t  dump_printf_loc (MSG_NOTE, vect_location, \"marking hybrid: \");\n-\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n+\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt_vinfo->stmt, 0);\n \t}\n       STMT_SLP_TYPE (stmt_vinfo) = hybrid;\n     }\n@@ -2525,9 +2525,8 @@ vect_slp_analyze_node_operations_1 (vec_info *vinfo, slp_tree node,\n \t\t\t\t    slp_instance node_instance,\n \t\t\t\t    stmt_vector_for_cost *cost_vec)\n {\n-  gimple *stmt = SLP_TREE_SCALAR_STMTS (node)[0];\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-  gcc_assert (stmt_info);\n+  stmt_vec_info stmt_info = SLP_TREE_SCALAR_STMTS (node)[0];\n+  gimple *stmt = stmt_info->stmt;\n   gcc_assert (STMT_SLP_TYPE (stmt_info) != loop_vect);\n \n   /* For BB vectorization vector types are assigned here.\n@@ -2551,10 +2550,10 @@ vect_slp_analyze_node_operations_1 (vec_info *vinfo, slp_tree node,\n \t    return false;\n \t}\n \n-      gimple *sstmt;\n+      stmt_vec_info sstmt_info;\n       unsigned int i;\n-      FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, sstmt)\n-\tSTMT_VINFO_VECTYPE (vinfo_for_stmt (sstmt)) = vectype;\n+      FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, sstmt_info)\n+\tSTMT_VINFO_VECTYPE (sstmt_info) = vectype;\n     }\n \n   /* Calculate the number of vector statements to be created for the\n@@ -2626,14 +2625,14 @@ vect_slp_analyze_node_operations (vec_info *vinfo, slp_tree node,\n   /* Push SLP node def-type to stmt operands.  */\n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), j, child)\n     if (SLP_TREE_DEF_TYPE (child) != vect_internal_def)\n-      STMT_VINFO_DEF_TYPE (vinfo_for_stmt (SLP_TREE_SCALAR_STMTS (child)[0]))\n+      STMT_VINFO_DEF_TYPE (SLP_TREE_SCALAR_STMTS (child)[0])\n \t= SLP_TREE_DEF_TYPE (child);\n   bool res = vect_slp_analyze_node_operations_1 (vinfo, node, node_instance,\n \t\t\t\t\t\t cost_vec);\n   /* Restore def-types.  */\n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), j, child)\n     if (SLP_TREE_DEF_TYPE (child) != vect_internal_def)\n-      STMT_VINFO_DEF_TYPE (vinfo_for_stmt (SLP_TREE_SCALAR_STMTS (child)[0]))\n+      STMT_VINFO_DEF_TYPE (SLP_TREE_SCALAR_STMTS (child)[0])\n \t= vect_internal_def;\n   if (! res)\n     return false;\n@@ -2665,11 +2664,11 @@ vect_slp_analyze_operations (vec_info *vinfo)\n \t\t\t\t\t     instance, visited, &lvisited,\n \t\t\t\t\t     &cost_vec))\n         {\n+\t  slp_tree node = SLP_INSTANCE_TREE (instance);\n+\t  stmt_vec_info stmt_info = SLP_TREE_SCALAR_STMTS (node)[0];\n \t  dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t   \"removing SLP instance operations starting from: \");\n-\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM,\n-\t\t\t    SLP_TREE_SCALAR_STMTS\n-\t\t\t      (SLP_INSTANCE_TREE (instance))[0], 0);\n+\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt_info->stmt, 0);\n \t  vect_free_slp_instance (instance, false);\n           vinfo->slp_instances.ordered_remove (i);\n \t  cost_vec.release ();\n@@ -2701,14 +2700,14 @@ vect_bb_slp_scalar_cost (basic_block bb,\n \t\t\t stmt_vector_for_cost *cost_vec)\n {\n   unsigned i;\n-  gimple *stmt;\n+  stmt_vec_info stmt_info;\n   slp_tree child;\n \n-  FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, stmt)\n+  FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, stmt_info)\n     {\n+      gimple *stmt = stmt_info->stmt;\n       ssa_op_iter op_iter;\n       def_operand_p def_p;\n-      stmt_vec_info stmt_info;\n \n       if ((*life)[i])\n \tcontinue;\n@@ -2724,8 +2723,7 @@ vect_bb_slp_scalar_cost (basic_block bb,\n \t  gimple *use_stmt;\n \t  FOR_EACH_IMM_USE_STMT (use_stmt, use_iter, DEF_FROM_PTR (def_p))\n \t    if (!is_gimple_debug (use_stmt)\n-\t\t&& (! vect_stmt_in_region_p (vinfo_for_stmt (stmt)->vinfo,\n-\t\t\t\t\t     use_stmt)\n+\t\t&& (! vect_stmt_in_region_p (stmt_info->vinfo, use_stmt)\n \t\t    || ! PURE_SLP_STMT (vinfo_for_stmt (use_stmt))))\n \t      {\n \t\t(*life)[i] = true;\n@@ -2740,7 +2738,6 @@ vect_bb_slp_scalar_cost (basic_block bb,\n \tcontinue;\n       gimple_set_visited (stmt, true);\n \n-      stmt_info = vinfo_for_stmt (stmt);\n       vect_cost_for_stmt kind;\n       if (STMT_VINFO_DATA_REF (stmt_info))\n         {\n@@ -2944,11 +2941,11 @@ vect_slp_analyze_bb_1 (gimple_stmt_iterator region_begin,\n       if (! vect_slp_analyze_and_verify_instance_alignment (instance)\n \t  || ! vect_slp_analyze_instance_dependence (instance))\n \t{\n+\t  slp_tree node = SLP_INSTANCE_TREE (instance);\n+\t  stmt_vec_info stmt_info = SLP_TREE_SCALAR_STMTS (node)[0];\n \t  dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t   \"removing SLP instance operations starting from: \");\n-\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM,\n-\t\t\t    SLP_TREE_SCALAR_STMTS\n-\t\t\t      (SLP_INSTANCE_TREE (instance))[0], 0);\n+\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt_info->stmt, 0);\n \t  vect_free_slp_instance (instance, false);\n \t  BB_VINFO_SLP_INSTANCES (bb_vinfo).ordered_remove (i);\n \t  continue;\n@@ -3299,9 +3296,9 @@ vect_get_constant_vectors (tree op, slp_tree slp_node,\n                            vec<tree> *vec_oprnds,\n \t\t\t   unsigned int op_num, unsigned int number_of_vectors)\n {\n-  vec<gimple *> stmts = SLP_TREE_SCALAR_STMTS (slp_node);\n-  gimple *stmt = stmts[0];\n-  stmt_vec_info stmt_vinfo = vinfo_for_stmt (stmt);\n+  vec<stmt_vec_info> stmts = SLP_TREE_SCALAR_STMTS (slp_node);\n+  stmt_vec_info stmt_vinfo = stmts[0];\n+  gimple *stmt = stmt_vinfo->stmt;\n   unsigned HOST_WIDE_INT nunits;\n   tree vec_cst;\n   unsigned j, number_of_places_left_in_vector;\n@@ -3320,7 +3317,7 @@ vect_get_constant_vectors (tree op, slp_tree slp_node,\n \n   /* Check if vector type is a boolean vector.  */\n   if (VECT_SCALAR_BOOLEAN_TYPE_P (TREE_TYPE (op))\n-      && vect_mask_constant_operand_p (stmt, op_num))\n+      && vect_mask_constant_operand_p (stmt_vinfo, op_num))\n     vector_type\n       = build_same_sized_truth_vector_type (STMT_VINFO_VECTYPE (stmt_vinfo));\n   else\n@@ -3366,8 +3363,9 @@ vect_get_constant_vectors (tree op, slp_tree slp_node,\n   bool place_after_defs = false;\n   for (j = 0; j < number_of_copies; j++)\n     {\n-      for (i = group_size - 1; stmts.iterate (i, &stmt); i--)\n+      for (i = group_size - 1; stmts.iterate (i, &stmt_vinfo); i--)\n         {\n+\t  stmt = stmt_vinfo->stmt;\n           if (is_store)\n             op = gimple_assign_rhs1 (stmt);\n           else\n@@ -3496,10 +3494,12 @@ vect_get_constant_vectors (tree op, slp_tree slp_node,\n \t\t{\n \t\t  gsi = gsi_for_stmt\n \t\t          (vect_find_last_scalar_stmt_in_slp (slp_node));\n-\t\t  init = vect_init_vector (stmt, vec_cst, vector_type, &gsi);\n+\t\t  init = vect_init_vector (stmt_vinfo, vec_cst, vector_type,\n+\t\t\t\t\t   &gsi);\n \t\t}\n \t      else\n-\t\tinit = vect_init_vector (stmt, vec_cst, vector_type, NULL);\n+\t\tinit = vect_init_vector (stmt_vinfo, vec_cst, vector_type,\n+\t\t\t\t\t NULL);\n \t      if (ctor_seq != NULL)\n \t\t{\n \t\t  gsi = gsi_for_stmt (SSA_NAME_DEF_STMT (init));\n@@ -3612,15 +3612,14 @@ vect_get_slp_defs (vec<tree> ops, slp_tree slp_node,\n \t  /* We have to check both pattern and original def, if available.  */\n \t  if (SLP_TREE_DEF_TYPE (child) == vect_internal_def)\n \t    {\n-\t      gimple *first_def = SLP_TREE_SCALAR_STMTS (child)[0];\n-\t      stmt_vec_info related\n-\t\t= STMT_VINFO_RELATED_STMT (vinfo_for_stmt (first_def));\n+\t      stmt_vec_info first_def_info = SLP_TREE_SCALAR_STMTS (child)[0];\n+\t      stmt_vec_info related = STMT_VINFO_RELATED_STMT (first_def_info);\n \t      tree first_def_op;\n \n-\t      if (gimple_code (first_def) == GIMPLE_PHI)\n+\t      if (gphi *first_def = dyn_cast <gphi *> (first_def_info->stmt))\n \t\tfirst_def_op = gimple_phi_result (first_def);\n \t      else\n-\t\tfirst_def_op = gimple_get_lhs (first_def);\n+\t\tfirst_def_op = gimple_get_lhs (first_def_info->stmt);\n \t      if (operand_equal_p (oprnd, first_def_op, 0)\n \t\t  || (related\n \t\t      && operand_equal_p (oprnd,\n@@ -3686,8 +3685,7 @@ vect_transform_slp_perm_load (slp_tree node, vec<tree> dr_chain,\n \t\t\t      slp_instance slp_node_instance, bool analyze_only,\n \t\t\t      unsigned *n_perms)\n {\n-  gimple *stmt = SLP_TREE_SCALAR_STMTS (node)[0];\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  stmt_vec_info stmt_info = SLP_TREE_SCALAR_STMTS (node)[0];\n   vec_info *vinfo = stmt_info->vinfo;\n   tree mask_element_type = NULL_TREE, mask_type;\n   int vec_index = 0;\n@@ -3779,7 +3777,7 @@ vect_transform_slp_perm_load (slp_tree node, vec<tree> dr_chain,\n \t\t\t\t   \"permutation requires at \"\n \t\t\t\t   \"least three vectors \");\n \t\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-\t\t\t\t    stmt, 0);\n+\t\t\t\t    stmt_info->stmt, 0);\n \t\t}\n \t      gcc_assert (analyze_only);\n \t      return false;\n@@ -3832,6 +3830,7 @@ vect_transform_slp_perm_load (slp_tree node, vec<tree> dr_chain,\n \t\t  stmt_vec_info perm_stmt_info;\n \t\t  if (! noop_p)\n \t\t    {\n+\t\t      gassign *stmt = as_a <gassign *> (stmt_info->stmt);\n \t\t      tree perm_dest\n \t\t\t= vect_create_destination_var (gimple_assign_lhs (stmt),\n \t\t\t\t\t\t       vectype);\n@@ -3841,7 +3840,8 @@ vect_transform_slp_perm_load (slp_tree node, vec<tree> dr_chain,\n \t\t\t\t\t       first_vec, second_vec,\n \t\t\t\t\t       mask_vec);\n \t\t      perm_stmt_info\n-\t\t\t= vect_finish_stmt_generation (stmt, perm_stmt, gsi);\n+\t\t\t= vect_finish_stmt_generation (stmt_info, perm_stmt,\n+\t\t\t\t\t\t       gsi);\n \t\t    }\n \t\t  else\n \t\t    /* If mask was NULL_TREE generate the requested\n@@ -3870,7 +3870,6 @@ static bool\n vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n \t\t\t    scalar_stmts_to_slp_tree_map_t *bst_map)\n {\n-  gimple *stmt;\n   bool grouped_store, is_store;\n   gimple_stmt_iterator si;\n   stmt_vec_info stmt_info;\n@@ -3897,11 +3896,13 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n   /* Push SLP node def-type to stmts.  */\n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n     if (SLP_TREE_DEF_TYPE (child) != vect_internal_def)\n-      FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (child), j, stmt)\n-\tSTMT_VINFO_DEF_TYPE (vinfo_for_stmt (stmt)) = SLP_TREE_DEF_TYPE (child);\n+      {\n+\tstmt_vec_info child_stmt_info;\n+\tFOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (child), j, child_stmt_info)\n+\t  STMT_VINFO_DEF_TYPE (child_stmt_info) = SLP_TREE_DEF_TYPE (child);\n+      }\n \n-  stmt = SLP_TREE_SCALAR_STMTS (node)[0];\n-  stmt_info = vinfo_for_stmt (stmt);\n+  stmt_info = SLP_TREE_SCALAR_STMTS (node)[0];\n \n   /* VECTYPE is the type of the destination.  */\n   vectype = STMT_VINFO_VECTYPE (stmt_info);\n@@ -3916,7 +3917,7 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n     {\n       dump_printf_loc (MSG_NOTE,vect_location,\n \t\t       \"------>vectorizing SLP node starting from: \");\n-      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n+      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt_info->stmt, 0);\n     }\n \n   /* Vectorized stmts go before the last scalar stmt which is where\n@@ -3928,7 +3929,7 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n      chain is marked as reduction.  */\n   if (!STMT_VINFO_GROUPED_ACCESS (stmt_info)\n       && REDUC_GROUP_FIRST_ELEMENT (stmt_info)\n-      && REDUC_GROUP_FIRST_ELEMENT (stmt_info) == stmt)\n+      && REDUC_GROUP_FIRST_ELEMENT (stmt_info) == stmt_info)\n     {\n       STMT_VINFO_DEF_TYPE (stmt_info) = vect_reduction_def;\n       STMT_VINFO_TYPE (stmt_info) = reduc_vec_info_type;\n@@ -3938,29 +3939,33 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n      both operations and then performing a merge.  */\n   if (SLP_TREE_TWO_OPERATORS (node))\n     {\n+      gassign *stmt = as_a <gassign *> (stmt_info->stmt);\n       enum tree_code code0 = gimple_assign_rhs_code (stmt);\n       enum tree_code ocode = ERROR_MARK;\n-      gimple *ostmt;\n+      stmt_vec_info ostmt_info;\n       vec_perm_builder mask (group_size, group_size, 1);\n-      FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, ostmt)\n-\tif (gimple_assign_rhs_code (ostmt) != code0)\n-\t  {\n-\t    mask.quick_push (1);\n-\t    ocode = gimple_assign_rhs_code (ostmt);\n-\t  }\n-\telse\n-\t  mask.quick_push (0);\n+      FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, ostmt_info)\n+\t{\n+\t  gassign *ostmt = as_a <gassign *> (ostmt_info->stmt);\n+\t  if (gimple_assign_rhs_code (ostmt) != code0)\n+\t    {\n+\t      mask.quick_push (1);\n+\t      ocode = gimple_assign_rhs_code (ostmt);\n+\t    }\n+\t  else\n+\t    mask.quick_push (0);\n+\t}\n       if (ocode != ERROR_MARK)\n \t{\n \t  vec<stmt_vec_info> v0;\n \t  vec<stmt_vec_info> v1;\n \t  unsigned j;\n \t  tree tmask = NULL_TREE;\n-\t  vect_transform_stmt (stmt, &si, &grouped_store, node, instance);\n+\t  vect_transform_stmt (stmt_info, &si, &grouped_store, node, instance);\n \t  v0 = SLP_TREE_VEC_STMTS (node).copy ();\n \t  SLP_TREE_VEC_STMTS (node).truncate (0);\n \t  gimple_assign_set_rhs_code (stmt, ocode);\n-\t  vect_transform_stmt (stmt, &si, &grouped_store, node, instance);\n+\t  vect_transform_stmt (stmt_info, &si, &grouped_store, node, instance);\n \t  gimple_assign_set_rhs_code (stmt, code0);\n \t  v1 = SLP_TREE_VEC_STMTS (node).copy ();\n \t  SLP_TREE_VEC_STMTS (node).truncate (0);\n@@ -3998,20 +4003,24 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n \t\t\t\t\t   gimple_assign_lhs (v1[j]->stmt),\n \t\t\t\t\t   tmask);\n \t      SLP_TREE_VEC_STMTS (node).quick_push\n-\t\t(vect_finish_stmt_generation (stmt, vstmt, &si));\n+\t\t(vect_finish_stmt_generation (stmt_info, vstmt, &si));\n \t    }\n \t  v0.release ();\n \t  v1.release ();\n \t  return false;\n \t}\n     }\n-  is_store = vect_transform_stmt (stmt, &si, &grouped_store, node, instance);\n+  is_store = vect_transform_stmt (stmt_info, &si, &grouped_store, node,\n+\t\t\t\t  instance);\n \n   /* Restore stmt def-types.  */\n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n     if (SLP_TREE_DEF_TYPE (child) != vect_internal_def)\n-      FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (child), j, stmt)\n-\tSTMT_VINFO_DEF_TYPE (vinfo_for_stmt (stmt)) = vect_internal_def;\n+      {\n+\tstmt_vec_info child_stmt_info;\n+\tFOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (child), j, child_stmt_info)\n+\t  STMT_VINFO_DEF_TYPE (child_stmt_info) = vect_internal_def;\n+      }\n \n   return is_store;\n }\n@@ -4024,7 +4033,7 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n static void\n vect_remove_slp_scalar_calls (slp_tree node)\n {\n-  gimple *stmt, *new_stmt;\n+  gimple *new_stmt;\n   gimple_stmt_iterator gsi;\n   int i;\n   slp_tree child;\n@@ -4037,13 +4046,12 @@ vect_remove_slp_scalar_calls (slp_tree node)\n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n     vect_remove_slp_scalar_calls (child);\n \n-  FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, stmt)\n+  FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, stmt_info)\n     {\n-      if (!is_gimple_call (stmt) || gimple_bb (stmt) == NULL)\n+      gcall *stmt = dyn_cast <gcall *> (stmt_info->stmt);\n+      if (!stmt || gimple_bb (stmt) == NULL)\n \tcontinue;\n-      stmt_info = vinfo_for_stmt (stmt);\n-      if (stmt_info == NULL_STMT_VEC_INFO\n-\t  || is_pattern_stmt_p (stmt_info)\n+      if (is_pattern_stmt_p (stmt_info)\n \t  || !PURE_SLP_STMT (stmt_info))\n \tcontinue;\n       lhs = gimple_call_lhs (stmt);\n@@ -4085,7 +4093,7 @@ vect_schedule_slp (vec_info *vinfo)\n   FOR_EACH_VEC_ELT (slp_instances, i, instance)\n     {\n       slp_tree root = SLP_INSTANCE_TREE (instance);\n-      gimple *store;\n+      stmt_vec_info store_info;\n       unsigned int j;\n       gimple_stmt_iterator gsi;\n \n@@ -4099,20 +4107,20 @@ vect_schedule_slp (vec_info *vinfo)\n       if (is_a <loop_vec_info> (vinfo))\n \tvect_remove_slp_scalar_calls (root);\n \n-      for (j = 0; SLP_TREE_SCALAR_STMTS (root).iterate (j, &store)\n+      for (j = 0; SLP_TREE_SCALAR_STMTS (root).iterate (j, &store_info)\n                   && j < SLP_INSTANCE_GROUP_SIZE (instance); j++)\n         {\n-          if (!STMT_VINFO_DATA_REF (vinfo_for_stmt (store)))\n-            break;\n-\n-         if (is_pattern_stmt_p (vinfo_for_stmt (store)))\n-           store = STMT_VINFO_RELATED_STMT (vinfo_for_stmt (store));\n-          /* Free the attached stmt_vec_info and remove the stmt.  */\n-          gsi = gsi_for_stmt (store);\n-\t  unlink_stmt_vdef (store);\n-          gsi_remove (&gsi, true);\n-\t  release_defs (store);\n-          free_stmt_vec_info (store);\n+\t  if (!STMT_VINFO_DATA_REF (store_info))\n+\t    break;\n+\n+\t  if (is_pattern_stmt_p (store_info))\n+\t    store_info = STMT_VINFO_RELATED_STMT (store_info);\n+\t  /* Free the attached stmt_vec_info and remove the stmt.  */\n+\t  gsi = gsi_for_stmt (store_info);\n+\t  unlink_stmt_vdef (store_info);\n+\t  gsi_remove (&gsi, true);\n+\t  release_defs (store_info);\n+\t  free_stmt_vec_info (store_info);\n         }\n     }\n "}, {"sha": "dec6ea29b7bcafc2d752d3e9dfbc6b0b12efe7d0", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b978758186fa187d52d2c4a02cdc8474d361a0dd/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b978758186fa187d52d2c4a02cdc8474d361a0dd/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=b978758186fa187d52d2c4a02cdc8474d361a0dd", "patch": "@@ -806,7 +806,7 @@ vect_prologue_cost_for_slp_op (slp_tree node, stmt_vec_info stmt_info,\n \t\t\t       unsigned opno, enum vect_def_type dt,\n \t\t\t       stmt_vector_for_cost *cost_vec)\n {\n-  gimple *stmt = SLP_TREE_SCALAR_STMTS (node)[0];\n+  gimple *stmt = SLP_TREE_SCALAR_STMTS (node)[0]->stmt;\n   tree op = gimple_op (stmt, opno);\n   unsigned prologue_cost = 0;\n \n@@ -838,11 +838,11 @@ vect_prologue_cost_for_slp_op (slp_tree node, stmt_vec_info stmt_info,\n     {\n       unsigned si = j % group_size;\n       if (nelt == 0)\n-\telt = gimple_op (SLP_TREE_SCALAR_STMTS (node)[si], opno);\n+\telt = gimple_op (SLP_TREE_SCALAR_STMTS (node)[si]->stmt, opno);\n       /* ???  We're just tracking whether all operands of a single\n \t vector initializer are the same, ideally we'd check if\n \t we emitted the same one already.  */\n-      else if (elt != gimple_op (SLP_TREE_SCALAR_STMTS (node)[si],\n+      else if (elt != gimple_op (SLP_TREE_SCALAR_STMTS (node)[si]->stmt,\n \t\t\t\t opno))\n \telt = NULL_TREE;\n       nelt++;\n@@ -889,7 +889,7 @@ vect_model_simple_cost (stmt_vec_info stmt_info, int ncopies,\n       /* Scan operands and account for prologue cost of constants/externals.\n \t ???  This over-estimates cost for multiple uses and should be\n \t re-engineered.  */\n-      gimple *stmt = SLP_TREE_SCALAR_STMTS (node)[0];\n+      gimple *stmt = SLP_TREE_SCALAR_STMTS (node)[0]->stmt;\n       tree lhs = gimple_get_lhs (stmt);\n       for (unsigned i = 0; i < gimple_num_ops (stmt); ++i)\n \t{\n@@ -5532,12 +5532,15 @@ vectorizable_shift (gimple *stmt, gimple_stmt_iterator *gsi,\n \t a scalar shift.  */\n       if (slp_node)\n \t{\n-\t  vec<gimple *> stmts = SLP_TREE_SCALAR_STMTS (slp_node);\n-\t  gimple *slpstmt;\n+\t  vec<stmt_vec_info> stmts = SLP_TREE_SCALAR_STMTS (slp_node);\n+\t  stmt_vec_info slpstmt_info;\n \n-\t  FOR_EACH_VEC_ELT (stmts, k, slpstmt)\n-\t    if (!operand_equal_p (gimple_assign_rhs2 (slpstmt), op1, 0))\n-\t      scalar_shift_arg = false;\n+\t  FOR_EACH_VEC_ELT (stmts, k, slpstmt_info)\n+\t    {\n+\t      gassign *slpstmt = as_a <gassign *> (slpstmt_info->stmt);\n+\t      if (!operand_equal_p (gimple_assign_rhs2 (slpstmt), op1, 0))\n+\t\tscalar_shift_arg = false;\n+\t    }\n \t}\n \n       /* If the shift amount is computed by a pattern stmt we cannot\n@@ -7421,7 +7424,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi,\n   vec<tree> dr_chain = vNULL;\n   bool grouped_load = false;\n   gimple *first_stmt;\n-  gimple *first_stmt_for_drptr = NULL;\n+  stmt_vec_info first_stmt_info_for_drptr = NULL;\n   bool inv_p;\n   bool compute_in_loop = false;\n   struct loop *at_loop;\n@@ -7930,7 +7933,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi,\n       /* For BB vectorization always use the first stmt to base\n \t the data ref pointer on.  */\n       if (bb_vinfo)\n-\tfirst_stmt_for_drptr = SLP_TREE_SCALAR_STMTS (slp_node)[0];\n+\tfirst_stmt_info_for_drptr = SLP_TREE_SCALAR_STMTS (slp_node)[0];\n \n       /* Check if the chain of loads is already vectorized.  */\n       if (STMT_VINFO_VEC_STMT (vinfo_for_stmt (first_stmt))\n@@ -8180,17 +8183,17 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi,\n \t      dataref_offset = build_int_cst (ref_type, 0);\n \t      inv_p = false;\n \t    }\n-\t  else if (first_stmt_for_drptr\n-\t\t   && first_stmt != first_stmt_for_drptr)\n+\t  else if (first_stmt_info_for_drptr\n+\t\t   && first_stmt != first_stmt_info_for_drptr)\n \t    {\n \t      dataref_ptr\n-\t\t= vect_create_data_ref_ptr (first_stmt_for_drptr, aggr_type,\n-\t\t\t\t\t    at_loop, offset, &dummy, gsi,\n-\t\t\t\t\t    &ptr_incr, simd_lane_access_p,\n+\t\t= vect_create_data_ref_ptr (first_stmt_info_for_drptr,\n+\t\t\t\t\t    aggr_type, at_loop, offset, &dummy,\n+\t\t\t\t\t    gsi, &ptr_incr, simd_lane_access_p,\n \t\t\t\t\t    &inv_p, byte_offset, bump);\n \t      /* Adjust the pointer by the difference to first_stmt.  */\n \t      data_reference_p ptrdr\n-\t\t= STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt_for_drptr));\n+\t\t= STMT_VINFO_DATA_REF (first_stmt_info_for_drptr);\n \t      tree diff = fold_convert (sizetype,\n \t\t\t\t\tsize_binop (MINUS_EXPR,\n \t\t\t\t\t\t    DR_INIT (first_dr),\n@@ -9391,13 +9394,12 @@ can_vectorize_live_stmts (gimple *stmt, gimple_stmt_iterator *gsi,\n {\n   if (slp_node)\n     {\n-      gimple *slp_stmt;\n+      stmt_vec_info slp_stmt_info;\n       unsigned int i;\n-      FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (slp_node), i, slp_stmt)\n+      FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (slp_node), i, slp_stmt_info)\n \t{\n-\t  stmt_vec_info slp_stmt_info = vinfo_for_stmt (slp_stmt);\n \t  if (STMT_VINFO_LIVE_P (slp_stmt_info)\n-\t      && !vectorizable_live_operation (slp_stmt, gsi, slp_node, i,\n+\t      && !vectorizable_live_operation (slp_stmt_info, gsi, slp_node, i,\n \t\t\t\t\t       vec_stmt, cost_vec))\n \t    return false;\n \t}"}, {"sha": "4b88a5c7401bedfb4bf97afd18a95003ae40cdac", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b978758186fa187d52d2c4a02cdc8474d361a0dd/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b978758186fa187d52d2c4a02cdc8474d361a0dd/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=b978758186fa187d52d2c4a02cdc8474d361a0dd", "patch": "@@ -138,7 +138,7 @@ struct _slp_tree {\n   /* Nodes that contain def-stmts of this node statements operands.  */\n   vec<slp_tree> children;\n   /* A group of scalar stmts to be vectorized together.  */\n-  vec<gimple *> stmts;\n+  vec<stmt_vec_info> stmts;\n   /* Load permutation relative to the stores, NULL if there is no\n      permutation.  */\n   vec<unsigned> load_permutation;"}]}