{"sha": "e90cd8543a2684ec9757e47b52d9a4905a7b0874", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTkwY2Q4NTQzYTI2ODRlYzk3NTdlNDdiNTJkOWE0OTA1YTdiMDg3NA==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel1@de.ibm.com", "date": "2006-04-19T11:45:41Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2006-04-19T11:45:41Z"}, "message": "ifcvt.c (noce_emit_move_insn): Call store_bit_field if the resulting move would be an INSV insn.\n\n2006-04-19  Andreas Krebbel  <krebbel1@de.ibm.com>\n\n\t* ifcvt.c (noce_emit_move_insn): Call store_bit_field if the resulting\n\tmove would be an INSV insn.\n\t(noce_process_if_block): Don't optimize if the destination is a \n\tZERO_EXTRACT which can't be handled by noce_emit_move_insn.\n\n2006-04-19  Andreas Krebbel  <krebbel1@de.ibm.com>\n\n\t* gcc.c-torture/compile/20060419-1.c: Added.\n\nFrom-SVN: r113072", "tree": {"sha": "2260174418b14113abb50883007c90cf82b10d68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2260174418b14113abb50883007c90cf82b10d68"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e90cd8543a2684ec9757e47b52d9a4905a7b0874", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e90cd8543a2684ec9757e47b52d9a4905a7b0874", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e90cd8543a2684ec9757e47b52d9a4905a7b0874", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e90cd8543a2684ec9757e47b52d9a4905a7b0874/comments", "author": null, "committer": null, "parents": [{"sha": "43a09b63d42a5a1de8c4870b4a208cb84fa127d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43a09b63d42a5a1de8c4870b4a208cb84fa127d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43a09b63d42a5a1de8c4870b4a208cb84fa127d8"}], "stats": {"total": 145, "additions": 106, "deletions": 39}, "files": [{"sha": "c80626aef5e8032a985955457ea7681efaaf86ec", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e90cd8543a2684ec9757e47b52d9a4905a7b0874/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e90cd8543a2684ec9757e47b52d9a4905a7b0874/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e90cd8543a2684ec9757e47b52d9a4905a7b0874", "patch": "@@ -1,3 +1,10 @@\n+2006-04-19  Andreas Krebbel  <krebbel1@de.ibm.com>\n+\n+\t* ifcvt.c (noce_emit_move_insn): Call store_bit_field if the resulting\n+\tmove would be an INSV insn.\n+\t(noce_process_if_block): Don't optimize if the destination is a \n+\tZERO_EXTRACT which can't be handled by noce_emit_move_insn.\n+\n 2006-04-19  Andreas Krebbel  <krebbel1@de.ibm.com>\n \n \t* config/s390/s390.md: Add comments with the instructions emitted"}, {"sha": "4787a246b0558ef55fdcb1507e6049d3751f895f", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 74, "deletions": 39, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e90cd8543a2684ec9757e47b52d9a4905a7b0874/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e90cd8543a2684ec9757e47b52d9a4905a7b0874/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=e90cd8543a2684ec9757e47b52d9a4905a7b0874", "patch": "@@ -702,47 +702,76 @@ noce_emit_move_insn (rtx x, rtx y)\n       end_sequence();\n \n       if (recog_memoized (insn) <= 0)\n-\tswitch (GET_RTX_CLASS (GET_CODE (y)))\n-\t  {\n-\t  case RTX_UNARY:\n-\t    ot = code_to_optab[GET_CODE (y)];\n-\t    if (ot)\n-\t      {\n-\t\tstart_sequence ();\n-\t\ttarget = expand_unop (GET_MODE (y), ot, XEXP (y, 0), x, 0);\n-\t\tif (target != NULL_RTX)\n-\t\t  {\n-\t\t    if (target != x)\n-\t\t      emit_move_insn (x, target);\n-\t\t    seq = get_insns ();\n-\t\t  }\n-\t\tend_sequence ();\n-\t      }\n-\t    break;\n-\n-\t  case RTX_BIN_ARITH:\n-\t  case RTX_COMM_ARITH:\n-\t    ot = code_to_optab[GET_CODE (y)];\n-\t    if (ot)\n-\t      {\n-\t\tstart_sequence ();\n-\t\ttarget = expand_binop (GET_MODE (y), ot,\n-\t\t\t\t       XEXP (y, 0), XEXP (y, 1),\n-\t\t\t\t       x, 0, OPTAB_DIRECT);\n-\t\tif (target != NULL_RTX)\n-\t\t  {\n-\t\t    if (target != x)\n-\t\t      emit_move_insn (x, target);\n-\t\t    seq = get_insns ();\n-\t\t  }\n-\t\tend_sequence ();\n-\t      }\n-\t    break;\n+\t{\n+\t  if (GET_CODE (x) == ZERO_EXTRACT)\n+\t    {\n+\t      rtx op = XEXP (x, 0);\n+\t      unsigned HOST_WIDE_INT size = INTVAL (XEXP (x, 1));\n+\t      unsigned HOST_WIDE_INT start = INTVAL (XEXP (x, 2));\n+\n+\t      /* store_bit_field expects START to be relative to \n+\t\t BYTES_BIG_ENDIAN and adjusts this value for machines with \n+\t\t BITS_BIG_ENDIAN != BYTES_BIG_ENDIAN.  In order to be able to \n+\t\t invoke store_bit_field again it is necessary to have the START\n+\t\t value from the first call.  */\n+\t      if (BITS_BIG_ENDIAN != BYTES_BIG_ENDIAN)\n+\t\t{\n+\t\t  if (MEM_P (op))\n+\t\t    start = BITS_PER_UNIT - start - size;\n+\t\t  else\n+\t\t    {\n+\t\t      gcc_assert (REG_P (op));\n+\t\t      start = BITS_PER_WORD - start - size;\n+\t\t    }\n+\t\t}\n \n-\t  default:\n-\t    break;\n-\t  }\n+\t      gcc_assert (start < (MEM_P (op) ? BITS_PER_UNIT : BITS_PER_WORD));\n+\t      store_bit_field (op, size, start, GET_MODE (x), y);\n+\t      return;\n+\t    }\n \n+\t  switch (GET_RTX_CLASS (GET_CODE (y)))\n+\t    {\n+\t    case RTX_UNARY:\n+\t      ot = code_to_optab[GET_CODE (y)];\n+\t      if (ot)\n+\t\t{\n+\t\t  start_sequence ();\n+\t\t  target = expand_unop (GET_MODE (y), ot, XEXP (y, 0), x, 0);\n+\t\t  if (target != NULL_RTX)\n+\t\t    {\n+\t\t      if (target != x)\n+\t\t\temit_move_insn (x, target);\n+\t\t      seq = get_insns ();\n+\t\t    }\n+\t\t  end_sequence ();\n+\t\t}\n+\t      break;\n+\t      \n+\t    case RTX_BIN_ARITH:\n+\t    case RTX_COMM_ARITH:\n+\t      ot = code_to_optab[GET_CODE (y)];\n+\t      if (ot)\n+\t\t{\n+\t\t  start_sequence ();\n+\t\t  target = expand_binop (GET_MODE (y), ot,\n+\t\t\t\t\t XEXP (y, 0), XEXP (y, 1),\n+\t\t\t\t\t x, 0, OPTAB_DIRECT);\n+\t\t  if (target != NULL_RTX)\n+\t\t    {\n+\t\t      if (target != x)\n+\t\t\t  emit_move_insn (x, target);\n+\t\t      seq = get_insns ();\n+\t\t    }\n+\t\t  end_sequence ();\n+\t\t}\n+\t      break;\n+\t      \n+\t    default:\n+\t      break;\n+\t    }\n+\t}\n+      \n       emit_insn (seq);\n       return;\n     }\n@@ -2231,6 +2260,12 @@ noce_process_if_block (struct ce_if_block * ce_info)\n     {\n       if (no_new_pseudos || GET_MODE (x) == BLKmode)\n \treturn FALSE;\n+\n+      if (GET_MODE (x) == ZERO_EXTRACT \n+\t  && (GET_CODE (XEXP (x, 1)) != CONST_INT \n+\t      || GET_CODE (XEXP (x, 2)) != CONST_INT))\n+\treturn FALSE;\n+\t  \n       x = gen_reg_rtx (GET_MODE (GET_CODE (x) == STRICT_LOW_PART\n \t\t\t\t ? XEXP (x, 0) : x));\n     }"}, {"sha": "49fa80c9c9f15d5bba0b6ac8d5bdbb61cad67a59", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e90cd8543a2684ec9757e47b52d9a4905a7b0874/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e90cd8543a2684ec9757e47b52d9a4905a7b0874/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e90cd8543a2684ec9757e47b52d9a4905a7b0874", "patch": "@@ -1,3 +1,7 @@\n+2006-04-19  Andreas Krebbel  <krebbel1@de.ibm.com>\n+\n+\t* gcc.c-torture/compile/20060419-1.c: Added.\n+\n 2006-04-18  Bernhard Fischer  <aldot@gcc.gnu.org>\n \n \t* gfortran.dg/label_1.f90: Adjust dg-error."}, {"sha": "dc346ae02a1a8097a897a28acd7939e2cbce9558", "filename": "gcc/testsuite/gcc.c-torture/compile/20060419-1.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e90cd8543a2684ec9757e47b52d9a4905a7b0874/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20060419-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e90cd8543a2684ec9757e47b52d9a4905a7b0874/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20060419-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20060419-1.c?ref=e90cd8543a2684ec9757e47b52d9a4905a7b0874", "patch": "@@ -0,0 +1,21 @@\n+/* This failed because if conversion didn't handle insv patterns properly.  */\n+\n+union y\n+{\n+  int a;\n+  unsigned short b;\n+};\n+\n+extern void bar (unsigned short u, union y v);\n+\n+void\n+foo (int check)\n+{\n+  union y x;\n+\n+  if (check != 0)\n+    x.b = 1;\n+  else\n+    x.b = 2;\n+  bar (x.b, x);\n+}"}]}