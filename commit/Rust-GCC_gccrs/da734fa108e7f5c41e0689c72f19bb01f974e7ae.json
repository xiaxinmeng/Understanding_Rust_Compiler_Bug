{"sha": "da734fa108e7f5c41e0689c72f19bb01f974e7ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGE3MzRmYTEwOGU3ZjVjNDFlMDY4OWM3MmYxOWJiMDFmOTc0ZTdhZQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2013-05-19T10:16:29Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2013-05-19T10:16:29Z"}, "message": "mips.h (BASE_INSN_LENGTH, [...]): New macros.\n\ngcc/\n\t* config/mips/mips.h (BASE_INSN_LENGTH, NOP_INSN_LENGTH): New macros.\n\t* config/mips/mips.c (mips_symbol_insns, mips_address_insns)\n\t(mips_const_insns, mips_split_const_insns, mips_load_store_insns)\n\t(mips_idiv_insns): Update the comments to say that the returned\n\tinstruction counts are in units of BASE_INSN_LENGTH.\n\t(mips_adjust_insn_length): Multiply the mips_load_label_num_insns\n\tby BASE_INSN_LENGTH rather than 4.  Add the jump separately,\n\tusing 2 rather than 4 as the length of indirect MIPS16 and\n\tmicroMIPS jumps.  Use NOP_INSN_LENGTH rather than 4 as the\n\tlength of a NOP.  Don't divide MIPS16 lengths by 2.\n\t(mips16_split_long_branches): Assume a branch is long if the\n\tlength is greater than 4 rather than 8.\n\t* config/mips/mips.md (length): Give MIPS16 lengths directly,\n\trather than multiplying them by 2.  Multiply instruction counts\n\tby BASE_INSN_LENGTH rather than 4.\n\t(*jump_mips16, tls_get_tp_mips16_<mode>)\n\t(*tls_get_tp_mips16_call_<mode>): Divide lengths by 2.\n\nFrom-SVN: r199080", "tree": {"sha": "a36fca24436628172211560d2ac81f2b454b46fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a36fca24436628172211560d2ac81f2b454b46fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/da734fa108e7f5c41e0689c72f19bb01f974e7ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da734fa108e7f5c41e0689c72f19bb01f974e7ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da734fa108e7f5c41e0689c72f19bb01f974e7ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da734fa108e7f5c41e0689c72f19bb01f974e7ae/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e242068731a13571c1a0099c06a0b7820f34c0c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e242068731a13571c1a0099c06a0b7820f34c0c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e242068731a13571c1a0099c06a0b7820f34c0c4"}], "stats": {"total": 145, "additions": 88, "deletions": 57}, "files": [{"sha": "310c14d97fd9db792bab559e183b95f84141229e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da734fa108e7f5c41e0689c72f19bb01f974e7ae/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da734fa108e7f5c41e0689c72f19bb01f974e7ae/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=da734fa108e7f5c41e0689c72f19bb01f974e7ae", "patch": "@@ -1,3 +1,23 @@\n+2013-05-19  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* config/mips/mips.h (BASE_INSN_LENGTH, NOP_INSN_LENGTH): New macros.\n+\t* config/mips/mips.c (mips_symbol_insns, mips_address_insns)\n+\t(mips_const_insns, mips_split_const_insns, mips_load_store_insns)\n+\t(mips_idiv_insns): Update the comments to say that the returned\n+\tinstruction counts are in units of BASE_INSN_LENGTH.\n+\t(mips_adjust_insn_length): Multiply the mips_load_label_num_insns\n+\tby BASE_INSN_LENGTH rather than 4.  Add the jump separately,\n+\tusing 2 rather than 4 as the length of indirect MIPS16 and\n+\tmicroMIPS jumps.  Use NOP_INSN_LENGTH rather than 4 as the\n+\tlength of a NOP.  Don't divide MIPS16 lengths by 2.\n+\t(mips16_split_long_branches): Assume a branch is long if the\n+\tlength is greater than 4 rather than 8.\n+\t* config/mips/mips.md (length): Give MIPS16 lengths directly,\n+\trather than multiplying them by 2.  Multiply instruction counts\n+\tby BASE_INSN_LENGTH rather than 4.\n+\t(*jump_mips16, tls_get_tp_mips16_<mode>)\n+\t(*tls_get_tp_mips16_call_<mode>): Divide lengths by 2.\n+\n 2013-05-19  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* config/mips/mips.md (extended_mips16): Remove branch case."}, {"sha": "1f2774638fc2f7750dda2685bb2c20c6bc51ec73", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da734fa108e7f5c41e0689c72f19bb01f974e7ae/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da734fa108e7f5c41e0689c72f19bb01f974e7ae/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=da734fa108e7f5c41e0689c72f19bb01f974e7ae", "patch": "@@ -2007,7 +2007,7 @@ mips_symbol_insns_1 (enum mips_symbol_type type, enum machine_mode mode)\n    values of mode MODE to or from addresses of type TYPE.  Return 0 if\n    the given type of symbol is not valid in addresses.\n \n-   In both cases, treat extended MIPS16 instructions as two instructions.  */\n+   In both cases, instruction counts are based off BASE_INSN_LENGTH.  */\n \n static int\n mips_symbol_insns (enum mips_symbol_type type, enum machine_mode mode)\n@@ -2334,12 +2334,11 @@ mips16_unextended_reference_p (enum machine_mode mode, rtx base,\n }\n \n /* Return the number of instructions needed to load or store a value\n-   of mode MODE at address X.  Return 0 if X isn't valid for MODE.\n+   of mode MODE at address X, assuming that BASE_INSN_LENGTH is the\n+   length of one instruction.  Return 0 if X isn't valid for MODE.\n    Assume that multiword moves may need to be split into word moves\n    if MIGHT_SPLIT_P, otherwise assume that a single load or store is\n-   enough.\n-\n-   For MIPS16 code, count extended instructions as two instructions.  */\n+   enough.  */\n \n int\n mips_address_insns (rtx x, enum machine_mode mode, bool might_split_p)\n@@ -2441,7 +2440,8 @@ umips_12bit_offset_address_p (rtx x, enum machine_mode mode)\n \t  && UMIPS_12BIT_OFFSET_P (INTVAL (addr.offset)));\n }\n \n-/* Return the number of instructions needed to load constant X.\n+/* Return the number of instructions needed to load constant X,\n+   assuming that BASE_INSN_LENGTH is the length of one instruction.\n    Return 0 if X isn't a valid constant.  */\n \n int\n@@ -2524,7 +2524,8 @@ mips_const_insns (rtx x)\n \n /* X is a doubleword constant that can be handled by splitting it into\n    two words and loading each word separately.  Return the number of\n-   instructions required to do this.  */\n+   instructions required to do this, assuming that BASE_INSN_LENGTH\n+   is the length of one instruction.  */\n \n int\n mips_split_const_insns (rtx x)\n@@ -2538,8 +2539,8 @@ mips_split_const_insns (rtx x)\n }\n \n /* Return the number of instructions needed to implement INSN,\n-   given that it loads from or stores to MEM.  Count extended\n-   MIPS16 instructions as two instructions.  */\n+   given that it loads from or stores to MEM.  Assume that\n+   BASE_INSN_LENGTH is the length of one instruction.  */\n \n int\n mips_load_store_insns (rtx mem, rtx insn)\n@@ -2563,7 +2564,8 @@ mips_load_store_insns (rtx mem, rtx insn)\n   return mips_address_insns (XEXP (mem, 0), mode, might_split_p);\n }\n \n-/* Return the number of instructions needed for an integer division.  */\n+/* Return the number of instructions needed for an integer division,\n+   assuming that BASE_INSN_LENGTH is the length of one instruction.  */\n \n int\n mips_idiv_insns (void)\n@@ -12273,16 +12275,18 @@ mips_adjust_insn_length (rtx insn, int length)\n \t is a conditional branch.  */\n       length = simplejump_p (insn) ? 0 : 8;\n \n-      /* Load the label into $AT and jump to it.  Ignore the delay\n-\t slot of the jump.  */\n-      length += 4 * mips_load_label_num_insns() + 4;\n+      /* Add the size of a load into $AT.  */\n+      length += BASE_INSN_LENGTH * mips_load_label_num_insns ();\n+\n+      /* Add the length of an indirect jump, ignoring the delay slot.  */\n+      length += TARGET_COMPRESSION ? 2 : 4;\n     }\n \n   /* A unconditional jump has an unfilled delay slot if it is not part\n      of a sequence.  A conditional jump normally has a delay slot, but\n      does not on MIPS16.  */\n   if (CALL_P (insn) || (TARGET_MIPS16 ? simplejump_p (insn) : JUMP_P (insn)))\n-    length += 4;\n+    length += TARGET_MIPS16 ? 2 : 4;\n \n   /* See how many nops might be needed to avoid hardware hazards.  */\n   if (!cfun->machine->ignore_hazard_length_p && INSN_CODE (insn) >= 0)\n@@ -12292,20 +12296,14 @@ mips_adjust_insn_length (rtx insn, int length)\n \tbreak;\n \n       case HAZARD_DELAY:\n-\tlength += 4;\n+\tlength += NOP_INSN_LENGTH;\n \tbreak;\n \n       case HAZARD_HILO:\n-\tlength += 8;\n+\tlength += NOP_INSN_LENGTH * 2;\n \tbreak;\n       }\n \n-  /* In order to make it easier to share MIPS16 and non-MIPS16 patterns,\n-     the .md file length attributes are 4-based for both modes.\n-     Adjust the MIPS16 ones here.  */\n-  if (TARGET_MIPS16)\n-    length /= 2;\n-\n   return length;\n }\n \n@@ -16201,7 +16199,7 @@ mips16_split_long_branches (void)\n       something_changed = false;\n       for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n \tif (JUMP_P (insn)\n-\t    && get_attr_length (insn) > 8\n+\t    && get_attr_length (insn) > 4\n \t    && (any_condjump_p (insn) || any_uncondjump_p (insn)))\n \t  {\n \t    rtx old_label, new_label, temp, saved_temp;"}, {"sha": "50a030f7f2c90f7d1a32faae6fdf51feb5665c31", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da734fa108e7f5c41e0689c72f19bb01f974e7ae/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da734fa108e7f5c41e0689c72f19bb01f974e7ae/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=da734fa108e7f5c41e0689c72f19bb01f974e7ae", "patch": "@@ -2439,6 +2439,14 @@ typedef struct mips_args {\n #define BRANCH_COST(speed_p, predictable_p) mips_branch_cost\n #define LOGICAL_OP_NON_SHORT_CIRCUIT 0\n \n+/* The MIPS port has several functions that return an instruction count.\n+   Multiplying the count by this value gives the number of bytes that\n+   the instructions occupy.  */\n+#define BASE_INSN_LENGTH (TARGET_MIPS16 ? 2 : 4)\n+\n+/* The length of a NOP in bytes.  */\n+#define NOP_INSN_LENGTH (TARGET_COMPRESSION ? 2 : 4)\n+\n /* If defined, modifies the length assigned to instruction INSN as a\n    function of the context in which it is used.  LENGTH is an lvalue\n    that contains the initially computed length of the insn and should"}, {"sha": "7284e5f33848d8d4d9683ed436b2aee1f33c1bf8", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 39, "deletions": 34, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da734fa108e7f5c41e0689c72f19bb01f974e7ae/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da734fa108e7f5c41e0689c72f19bb01f974e7ae/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=da734fa108e7f5c41e0689c72f19bb01f974e7ae", "patch": "@@ -425,7 +425,7 @@\n (define_attr \"length\" \"\"\n    (cond [(and (eq_attr \"extended_mips16\" \"yes\")\n \t       (match_test \"TARGET_MIPS16\"))\n-\t  (const_int 8)\n+\t  (const_int 4)\n \n \t  (and (eq_attr \"compression\" \"micromips,all\")\n \t       (eq_attr \"dword_mode\" \"no\")\n@@ -567,68 +567,69 @@\n \t  ;;\t move $2,$1\t\t2 bytes\n \t  ;; foo:\n \t  ;;\t\t\t\t(20 bytes in the worst case)\n-\t  ;;\n-\t  ;; Note that the conditions test adjusted lengths, whereas the\n-\t  ;; result is an unadjusted length, and is thus twice the true value.\n \t  (and (eq_attr \"type\" \"branch\")\n \t       (match_test \"TARGET_MIPS16\"))\n \t  (cond [(and (le (minus (match_dup 0) (pc)) (const_int 254))\n \t\t      (le (minus (pc) (match_dup 0)) (const_int 254)))\n-\t\t (const_int 4)\n+\t\t (const_int 2)\n \t\t (and (le (minus (match_dup 0) (pc)) (const_int 65534))\n \t\t      (le (minus (pc) (match_dup 0)) (const_int 65532)))\n-\t\t (const_int 8)\n+\t\t (const_int 4)\n \t\t (and (match_test \"TARGET_ABICALLS\")\n \t\t      (not (match_test \"TARGET_ABSOLUTE_ABICALLS\")))\n-\t\t (const_int 40)\n+\t\t (const_int 20)\n \t\t (match_test \"Pmode == SImode\")\n-\t\t (const_int 32)\n-\t\t ] (const_int 48))\n+\t\t (const_int 16)\n+\t\t ] (const_int 24))\n \n \t  ;; \"Ghost\" instructions occupy no space.\n \t  (eq_attr \"type\" \"ghost\")\n \t  (const_int 0)\n \n+\t  ;; GOT loads are extended MIPS16 instructions and 4-byte\n+\t  ;; microMIPS instructions.\n \t  (eq_attr \"got\" \"load\")\n-\t  (if_then_else (match_test \"TARGET_MIPS16\")\n-\t\t\t(const_int 8)\n-\t\t\t(const_int 4))\n+\t  (const_int 4)\n+\n+\t  ;; A GOT load followed by an add of $gp.\n \t  (eq_attr \"got\" \"xgot_high\")\n \t  (const_int 8)\n \n \t  ;; In general, constant-pool loads are extended instructions.\n \t  (eq_attr \"move_type\" \"loadpool\")\n-\t  (const_int 8)\n+\t  (const_int 4)\n \n \t  ;; SHIFT_SHIFTs are decomposed into two separate instructions.\n \t  ;; They are extended instructions on MIPS16 targets.\n \t  (eq_attr \"move_type\" \"shift_shift\")\n-\t  (if_then_else (match_test \"TARGET_MIPS16\")\n-\t\t\t(const_int 16)\n-\t\t\t(const_int 8))\n+\t  (const_int 8)\n \n \t  ;; Check for doubleword moves that are decomposed into two\n-\t  ;; instructions.\n+\t  ;; instructions.  The individual instructions are unextended\n+\t  ;; MIPS16 ones or 2-byte microMIPS ones.\n \t  (and (eq_attr \"move_type\" \"mtc,mfc,mtlo,mflo,move\")\n \t       (eq_attr \"dword_mode\" \"yes\"))\n-\t  (const_int 8)\n+\t  (if_then_else (match_test \"TARGET_COMPRESSION\")\n+\t  \t\t(const_int 4)\n+\t  \t\t(const_int 8))\n \n \t  ;; Doubleword CONST{,N} moves are split into two word\n \t  ;; CONST{,N} moves.\n \t  (and (eq_attr \"move_type\" \"const,constN\")\n \t       (eq_attr \"dword_mode\" \"yes\"))\n-\t  (symbol_ref \"mips_split_const_insns (operands[1]) * 4\")\n+\t  (symbol_ref \"mips_split_const_insns (operands[1]) * BASE_INSN_LENGTH\")\n \n \t  ;; Otherwise, constants, loads and stores are handled by external\n \t  ;; routines.\n \t  (eq_attr \"move_type\" \"const,constN\")\n-\t  (symbol_ref \"mips_const_insns (operands[1]) * 4\")\n+\t  (symbol_ref \"mips_const_insns (operands[1]) * BASE_INSN_LENGTH\")\n \t  (eq_attr \"move_type\" \"load,fpload\")\n-\t  (symbol_ref \"mips_load_store_insns (operands[1], insn) * 4\")\n+\t  (symbol_ref \"mips_load_store_insns (operands[1], insn)\n+\t  \t       * BASE_INSN_LENGTH\")\n \t  (eq_attr \"move_type\" \"store,fpstore\")\n-\t  (cond [(not (match_test \"TARGET_FIX_24K\"))\n-\t         (symbol_ref \"mips_load_store_insns (operands[0], insn) * 4\")]\n-\t         (symbol_ref \"mips_load_store_insns (operands[0], insn) * 4 + 4\"))\n+\t  (symbol_ref \"mips_load_store_insns (operands[0], insn)\n+\t\t       * BASE_INSN_LENGTH\n+\t\t       + (TARGET_FIX_24K ? NOP_INSN_LENGTH : 0)\")\n \n \t  ;; In the worst case, a call macro will take 8 instructions:\n \t  ;;\n@@ -659,10 +660,14 @@\n \t  (const_int 8)\n \n \t  (eq_attr \"type\" \"idiv,idiv3\")\n-\t  (symbol_ref \"mips_idiv_insns () * 4\")\n+\t  (symbol_ref \"mips_idiv_insns () * BASE_INSN_LENGTH\")\n \n \t  (not (eq_attr \"sync_mem\" \"none\"))\n-\t  (symbol_ref \"mips_sync_loop_insns (insn, operands) * 4\")\n+\t  (symbol_ref \"mips_sync_loop_insns (insn, operands)\n+\t  \t       * BASE_INSN_LENGTH\")\n+\n+\t  (match_test \"TARGET_MIPS16\")\n+\t  (const_int 2)\n \t  ] (const_int 4)))\n \n ;; Attribute describing the processor.\n@@ -5373,7 +5378,7 @@\n   \"\"\n   [(set_attr \"type\"\t\"load\")\n    (set_attr \"mode\"\t\"SI\")\n-   (set_attr \"length\"\t\"16\")])\n+   (set_attr \"length\"\t\"8\")])\n \n (define_insn \"rotr<mode>3\"\n   [(set (match_operand:GPR 0 \"register_operand\" \"=d\")\n@@ -5845,16 +5850,16 @@\n \t;; is one instruction shorter than for conditional branches.\n \t(cond [(and (le (minus (match_dup 0) (pc)) (const_int 2046))\n \t\t    (le (minus (pc) (match_dup 0)) (const_int 2046)))\n-\t       (const_int 4)\n+\t       (const_int 2)\n \t       (and (le (minus (match_dup 0) (pc)) (const_int 65534))\n \t\t    (le (minus (pc) (match_dup 0)) (const_int 65532)))\n-\t       (const_int 8)\n+\t       (const_int 4)\n \t       (and (match_test \"TARGET_ABICALLS\")\n \t\t    (not (match_test \"TARGET_ABSOLUTE_ABICALLS\")))\n-\t       (const_int 36)\n+\t       (const_int 18)\n \t       (match_test \"Pmode == SImode\")\n-\t       (const_int 28)\n-\t       ] (const_int 44)))])\n+\t       (const_int 14)\n+\t       ] (const_int 22)))])\n \n (define_expand \"indirect_jump\"\n   [(set (pc) (match_operand 0 \"register_operand\"))]\n@@ -6947,7 +6952,7 @@\n    (set (match_dup 0) (reg:P TLS_GET_TP_REGNUM))]\n   \"\"\n   [(set_attr \"type\" \"multi\")\n-   (set_attr \"length\" \"16\")\n+   (set_attr \"length\" \"8\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n (define_insn \"*tls_get_tp_mips16_call_<mode>\"\n@@ -6959,7 +6964,7 @@\n   \"HAVE_AS_TLS && TARGET_MIPS16\"\n   { return MIPS_CALL (\"jal\", operands, 0, -1); }\n   [(set_attr \"type\" \"call\")\n-   (set_attr \"length\" \"12\")\n+   (set_attr \"length\" \"6\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n ;; Named pattern for expanding thread pointer reference."}]}