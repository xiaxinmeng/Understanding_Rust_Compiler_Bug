{"sha": "c2cffdc88017fa85b044db5d35f9e1a42877eef9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzJjZmZkYzg4MDE3ZmE4NWIwNDRkYjVkMzVmOWUxYTQyODc3ZWVmOQ==", "commit": {"author": {"name": "Douglas B Rupp", "email": "rupp@gnat.com", "date": "2009-07-29T17:35:32Z"}, "committer": {"name": "Douglas Rupp", "email": "rupp@gcc.gnu.org", "date": "2009-07-29T17:35:32Z"}, "message": "dwarf2out.c (output_file_names): Output VMS style file name, size, date, version info if VMS_DEBUGGING_INFO defined.\n\n\n\t* dwarf2out.c (output_file_names): Output VMS style file name, size,\n\tdate, version info if VMS_DEBUGGING_INFO defined.\n\t* vmsdgbout.c (vms_file_stats_name): New functon. VMS style file name,\n\tsize, date calculating code moved here.\n\nFrom-SVN: r150219", "tree": {"sha": "1d89fc9b2c81940cff19eef19fa55e5bd9d3c26b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d89fc9b2c81940cff19eef19fa55e5bd9d3c26b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c2cffdc88017fa85b044db5d35f9e1a42877eef9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2cffdc88017fa85b044db5d35f9e1a42877eef9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2cffdc88017fa85b044db5d35f9e1a42877eef9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2cffdc88017fa85b044db5d35f9e1a42877eef9/comments", "author": null, "committer": null, "parents": [{"sha": "33215bb37f598adbbde2a90e301d37165072dcc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33215bb37f598adbbde2a90e301d37165072dcc2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33215bb37f598adbbde2a90e301d37165072dcc2"}], "stats": {"total": 338, "additions": 297, "deletions": 41}, "files": [{"sha": "0e3a8d0897107a4d682ed7aae41a31d72d6c4b9b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2cffdc88017fa85b044db5d35f9e1a42877eef9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2cffdc88017fa85b044db5d35f9e1a42877eef9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c2cffdc88017fa85b044db5d35f9e1a42877eef9", "patch": "@@ -1,3 +1,10 @@\n+2009-07-29  Douglas B Rupp  <rupp@gnat.com>\n+\n+\t* dwarf2out.c (output_file_names): Output VMS style file name, size,\n+\tdate, version info if VMS_DEBUGGING_INFO defined.\n+\t* vmsdgbout.c (vms_file_stats_name): New functon. VMS style file name,\n+\tsize, date calculating code moved here.\n+\n 2009-07-29  Paul Brook  <paul@codesourcery.com>\n \n \t* config/arm/lib1funcs.asm (clear_cache): Use ARM_FUNC_START and"}, {"sha": "58a257d3b71d5be743c8da484e13c18206965c4a", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2cffdc88017fa85b044db5d35f9e1a42877eef9/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2cffdc88017fa85b044db5d35f9e1a42877eef9/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=c2cffdc88017fa85b044db5d35f9e1a42877eef9", "patch": "@@ -97,6 +97,8 @@ static rtx last_var_location_insn;\n #endif\n \n #ifdef VMS_DEBUGGING_INFO\n+int vms_file_stats_name (const char *, long long *, long *, char *, int *);\n+\n /* Define this macro to be a nonzero value if the directory specifications\n     which are output in the debug info should end with a separator.  */\n #define DWARF2_DIR_SHOULD_END_WITH_SEPARATOR 1\n@@ -9636,6 +9638,42 @@ output_file_names (void)\n       int file_idx = backmap[i];\n       int dir_idx = dirs[files[file_idx].dir_idx].dir_idx;\n \n+#ifdef VMS_DEBUGGING_INFO\n+#define MAX_VMS_VERSION_LEN 6 /* \";32768\" */\n+\n+      /* Setting these fields can lead to debugger miscomparisons,\n+         but VMS Debug requires them to be set correctly.  */\n+\n+      int ver;\n+      long long cdt;\n+      long siz;\n+      int maxfilelen = strlen (files[file_idx].path)\n+\t\t\t       + dirs[dir_idx].length\n+\t\t\t       + MAX_VMS_VERSION_LEN + 1;\n+      char *filebuf = XALLOCAVEC (char, maxfilelen);\n+\n+      vms_file_stats_name (files[file_idx].path, 0, 0, 0, &ver);\n+      snprintf (filebuf, maxfilelen, \"%s;%d\",\n+\t        files[file_idx].path + dirs[dir_idx].length, ver);\n+\n+      dw2_asm_output_nstring\n+\t(filebuf, -1, \"File Entry: 0x%x\", (unsigned) i + 1);\n+\n+      /* Include directory index.  */\n+      dw2_asm_output_data_uleb128 (dir_idx + idx_offset, NULL);\n+\n+      /* Modification time.  */\n+      dw2_asm_output_data_uleb128\n+        ((vms_file_stats_name (files[file_idx].path, &cdt, 0, 0, 0) == 0)\n+\t  ? cdt : 0,\n+\t NULL);\n+\n+      /* File length in bytes.  */\n+      dw2_asm_output_data_uleb128\n+        ((vms_file_stats_name (files[file_idx].path, 0, &siz, 0, 0) == 0)\n+      \t  ? siz : 0,\n+\t NULL);\n+#else\n       dw2_asm_output_nstring (files[file_idx].path + dirs[dir_idx].length, -1,\n \t\t\t      \"File Entry: 0x%x\", (unsigned) i + 1);\n \n@@ -9647,6 +9685,7 @@ output_file_names (void)\n \n       /* File length in bytes.  */\n       dw2_asm_output_data_uleb128 (0, NULL);\n+#endif\n     }\n \n   dw2_asm_output_data (1, 0, \"End file name table\");"}, {"sha": "f7cca03d05179d46b51335974c995e029425bfb7", "filename": "gcc/vmsdbgout.c", "status": "modified", "additions": 251, "deletions": 41, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2cffdc88017fa85b044db5d35f9e1a42877eef9/gcc%2Fvmsdbgout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2cffdc88017fa85b044db5d35f9e1a42877eef9/gcc%2Fvmsdbgout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvmsdbgout.c?ref=c2cffdc88017fa85b044db5d35f9e1a42877eef9", "patch": "@@ -1,6 +1,6 @@\n /* Output VMS debug format symbol table information from GCC.\n    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009\n    Free Software Foundation, Inc.\n    Contributed by Douglas B. Rupp (rupp@gnat.com).\n    Updated by Bernard W. Giroud (bgiroud@users.sourceforge.net).\n@@ -41,6 +41,8 @@ along with GCC; see the file COPYING3.  If not see\n /* Difference in seconds between the VMS Epoch and the Unix Epoch */\n static const long long vms_epoch_offset = 3506716800ll;\n \n+int vms_file_stats_name (const char *, long long *, long *, char *, int *);\n+\n /* NOTE: In the comments in this file, many references are made to \"Debug\n    Symbol Table\".  This term is abbreviated as `DST' throughout the remainder\n    of this file.  */\n@@ -1443,47 +1445,16 @@ lookup_filename (const char *file_name)\n   register char *fn;\n   register unsigned i;\n   const char *fnam;\n-  long long cdt;\n-  long ebk;\n-  short ffb;\n-  char rfo;\n   char flen;\n-  struct stat statbuf;\n+  long long cdt = 0;\n+  long ebk = 0;\n+  short ffb = 0;\n+  char rfo = 0;\n+  long siz = 0;\n+  int ver = 0;\n \n-  if (stat (file_name, &statbuf) == 0)\n-    {\n-      long gmtoff;\n-#ifdef VMS\n-      struct tm *ts;\n-\n-      /* Adjust for GMT.  */\n-      ts = (struct tm *) localtime (&statbuf.st_ctime);\n-      gmtoff = ts->tm_gmtoff;\n-\n-      /* VMS has multiple file format types.  */\n-      rfo = statbuf.st_fab_rfm;\n-#else\n-      /* Is GMT adjustment an issue with a cross-compiler? */\n-      gmtoff = 0;\n-\n-      /* Assume stream LF type file.  */\n-      rfo = 2;\n-#endif\n-      cdt = 10000000 * (statbuf.st_ctime + gmtoff + vms_epoch_offset);\n-      ebk = statbuf.st_size / 512 + 1;\n-      ffb = statbuf.st_size - ((statbuf.st_size / 512) * 512);\n-      fnam = full_name (file_name);\n-      flen = strlen (fnam);\n-    }\n-  else\n-    {\n-      cdt = 0;\n-      ebk = 0;\n-      ffb = 0;\n-      rfo = 0;\n-      fnam = \"\";\n-      flen = 0;\n-    }\n+  fnam = full_name (file_name);\n+  flen = strlen (fnam);\n \n   /* Check to see if the file name that was searched on the previous call\n      matches this file name. If so, return the index.  */\n@@ -1515,6 +1486,12 @@ lookup_filename (const char *file_name)\n \t\t\t\t    file_info_table_allocated);\n     }\n \n+  if (vms_file_stats_name (file_name, &cdt, &siz, &rfo, &ver) == 0)\n+    {\n+      ebk = siz / 512 + 1;\n+      ffb = siz - ((siz / 512) * 512);\n+    }\n+\n   /* Add the new entry to the end of the filename table.  */\n   file_info_table[file_info_table_in_use].file_name = xstrdup (fnam);\n   file_info_table[file_info_table_in_use].max_line = 0;\n@@ -1730,4 +1707,237 @@ vmsdbgout_finish (const char *main_input_filename ATTRIBUTE_UNUSED)\n   totsize = write_modend (1);\n   write_modend (0);\n }\n-#endif /* VMS_DEBUGGING_INFO */\n+\n+/* Need for both Dwarf2 on IVMS and VMS Debug on AVMS */\n+\n+#ifdef VMS\n+#define __NEW_STARLET 1\n+#include <vms/rms.h>\n+#include <vms/atrdef.h>\n+#include <vms/fibdef.h>\n+#include <vms/stsdef.h>\n+#include <vms/iodef.h>\n+#include <vms/fatdef.h>\n+#include <errno.h>\n+#include <vms/descrip.h>\n+#include <string.h>\n+#include <unixlib.h>\n+\n+#define MAXPATH 256\n+\n+/* descrip.h doesn't have everything ...  */\n+typedef struct fibdef* __fibdef_ptr32 __attribute__ (( mode (SI) )); \n+struct dsc$descriptor_fib\n+{\n+  unsigned int fib$l_len;\n+  __fibdef_ptr32 fib$l_addr;\n+};\n+\n+/* I/O Status Block.  */\n+struct IOSB\n+{\n+  unsigned short status, count;\n+  unsigned int devdep;\n+};\n+\n+static char *tryfile;\n+\n+/* Variable length string.  */\n+struct vstring\n+{\n+  short length;\n+  char string[NAM$C_MAXRSS+1];\n+};\n+\n+static char filename_buff [MAXPATH];\n+static char vms_filespec [MAXPATH];\n+\n+/* Callback function for filespec style conversion.  */\n+\n+static int\n+translate_unix (char *name, int type ATTRIBUTE_UNUSED)\n+{\n+  strncpy (filename_buff, name, MAXPATH);\n+  filename_buff [MAXPATH - 1] = (char) 0;\n+  return 0;\n+}\n+\n+/* Wrapper for DECC function that converts a Unix filespec\n+   to VMS style filespec.  */\n+\n+static char *\n+to_vms_file_spec (char *filespec)\n+{\n+  strncpy (vms_filespec, \"\", MAXPATH);\n+  decc$to_vms (filespec, translate_unix, 1, 1);\n+  strncpy (vms_filespec, filename_buff, MAXPATH);\n+\n+  vms_filespec [MAXPATH - 1] = (char) 0;\n+\n+  return vms_filespec;\n+}\n+\n+#else\n+#define VMS_EPOCH_OFFSET 35067168000000000\n+#define VMS_GRANULARITY_FACTOR 10000000\n+#endif\n+\n+/* Return VMS file date, size, format, version given a name.  */\n+\n+int\n+vms_file_stats_name (const char *filename, long long *cdt, long *siz, char *rfo,\n+\t\t     int *ver)\n+{\n+#ifdef VMS\n+  struct FAB fab;\n+  struct NAM nam;\n+\n+  unsigned long long create;\n+  FAT recattr;\n+  char ascnamebuff [256];\n+\n+  ATRDEF atrlst[]\n+    = {\n+      { ATR$S_CREDATE,  ATR$C_CREDATE,  &create },\n+      { ATR$S_RECATTR,  ATR$C_RECATTR,  &recattr },\n+      { ATR$S_ASCNAME,  ATR$C_ASCNAME,  &ascnamebuff },\n+      { 0, 0, 0}\n+    };\n+\n+  FIBDEF fib;\n+  struct dsc$descriptor_fib fibdsc = {sizeof (fib), (void *) &fib};\n+\n+  struct IOSB iosb;\n+\n+  long status;\n+  unsigned short chan;\n+\n+  struct vstring file;\n+  struct dsc$descriptor_s filedsc\n+    = {NAM$C_MAXRSS, DSC$K_DTYPE_T, DSC$K_CLASS_S, (void *) file.string};\n+  struct vstring device;\n+  struct dsc$descriptor_s devicedsc\n+    = {NAM$C_MAXRSS, DSC$K_DTYPE_T, DSC$K_CLASS_S, (void *) device.string};\n+  struct vstring result;\n+  struct dsc$descriptor_s resultdsc\n+    = {NAM$C_MAXRSS, DSC$K_DTYPE_VT, DSC$K_CLASS_VS, (void *) result.string};\n+\n+  if (strcmp (filename, \"<internal>\") == 0\n+      || strcmp (filename, \"<built-in>\") == 0)\n+    {\n+      if (cdt)\n+\t*cdt = 0;\n+\n+      if (siz)\n+\t*siz = 0;\n+\n+      if (rfo)\n+\t*rfo = 0;\n+\n+      if (ver)\n+        *ver = 0;\n+\n+      return 0;\n+    }\n+\n+  tryfile = to_vms_file_spec (filename);\n+\n+  /* Allocate and initialize a FAB and NAM structures.  */\n+  fab = cc$rms_fab;\n+  nam = cc$rms_nam;\n+\n+  nam.nam$l_esa = file.string;\n+  nam.nam$b_ess = NAM$C_MAXRSS;\n+  nam.nam$l_rsa = result.string;\n+  nam.nam$b_rss = NAM$C_MAXRSS;\n+  fab.fab$l_fna = tryfile;\n+  fab.fab$b_fns = strlen (tryfile);\n+  fab.fab$l_nam = &nam;\n+\n+  /* Validate filespec syntax and device existence.  */\n+  status = SYS$PARSE (&fab, 0, 0);\n+  if ((status & 1) != 1)\n+    return 1;\n+\n+  file.string[nam.nam$b_esl] = 0;\n+\n+  /* Find matching filespec.  */\n+  status = SYS$SEARCH (&fab, 0, 0);\n+  if ((status & 1) != 1)\n+    return 1;\n+\n+  file.string[nam.nam$b_esl] = 0;\n+  result.string[result.length=nam.nam$b_rsl] = 0;\n+\n+  /* Get the device name and assign an IO channel.  */\n+  strncpy (device.string, nam.nam$l_dev, nam.nam$b_dev);\n+  devicedsc.dsc$w_length  = nam.nam$b_dev;\n+  chan = 0;\n+  status = SYS$ASSIGN (&devicedsc, &chan, 0, 0, 0);\n+  if ((status & 1) != 1)\n+    return 1;\n+\n+  /* Initialize the FIB and fill in the directory id field.  */\n+  memset (&fib, 0, sizeof (fib));\n+  fib.fib$w_did[0]  = nam.nam$w_did[0];\n+  fib.fib$w_did[1]  = nam.nam$w_did[1];\n+  fib.fib$w_did[2]  = nam.nam$w_did[2];\n+  fib.fib$l_acctl = 0;\n+  fib.fib$l_wcc = 0;\n+  strcpy (file.string, (strrchr (result.string, ']') + 1));\n+  filedsc.dsc$w_length = strlen (file.string);\n+  result.string[result.length = 0] = 0;\n+\n+  /* Open and close the file to fill in the attributes.  */\n+  status\n+    = SYS$QIOW (0, chan, IO$_ACCESS|IO$M_ACCESS, &iosb, 0, 0,\n+\t\t&fibdsc, &filedsc, &result.length, &resultdsc, &atrlst, 0);\n+  if ((status & 1) != 1)\n+    return 1;\n+  if ((iosb.status & 1) != 1)\n+    return 1;\n+\n+  result.string[result.length] = 0;\n+  status = SYS$QIOW (0, chan, IO$_DEACCESS, &iosb, 0, 0, &fibdsc, 0, 0, 0,\n+\t\t     &atrlst, 0);\n+  if ((status & 1) != 1)\n+    return 1;\n+  if ((iosb.status & 1) != 1)\n+    return 1;\n+\n+  /* Deassign the channel and exit.  */\n+  status = SYS$DASSGN (chan);\n+  if ((status & 1) != 1)\n+    return 1;\n+\n+  if (cdt) *cdt = create;\n+  if (siz) *siz = (512 * 65536 * recattr.fat$w_efblkh) +\n+                  (512 * (recattr.fat$w_efblkl - 1)) +\n+                  recattr.fat$w_ffbyte;\n+  if (rfo) *rfo = recattr.fat$v_rtype;\n+  if (ver) *ver = strtol (strrchr (ascnamebuff, ';')+1, 0, 10);\n+\n+  return 0;\n+#else\n+  struct stat buff;\n+\n+  if ((stat (filename, &buff)) != 0)\n+     return 1;\n+\n+  if (cdt)\n+    *cdt = (long long) (buff.st_mtime * VMS_GRANULARITY_FACTOR)\n+                        + VMS_EPOCH_OFFSET;\n+\n+  if (siz)\n+    *siz = buff.st_size;\n+\n+  if (rfo)\n+    *rfo = 2; /* Stream LF format */\n+\n+  if (ver)\n+    *ver = 1;\n+\n+  return 0;\n+#endif\n+}\n+#endif"}]}