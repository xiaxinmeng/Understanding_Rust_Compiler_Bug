{"sha": "7e691189ca9c04fdba71ceada1faba62afbc1463", "node_id": "C_kwDOANBUbNoAKDdlNjkxMTg5Y2E5YzA0ZmRiYTcxY2VhZGExZmFiYTYyYWZiYzE0NjM", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-02-22T09:38:37Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-02-22T09:38:37Z"}, "message": "i386: Fix up copysign/xorsign expansion [PR104612]\n\nWe ICE on the following testcase for -m32 since r12-3435. because\noperands[2] is (subreg:SF (reg:DI ...) 0) and\nlowpart_subreg (V4SFmode, operands[2], SFmode)\nreturns NULL, and that is what we use in AND etc. insns we emit.\n\nMy earlier version of the patch fixes that by calling force_reg for the\ninput operands, to make sure they are really REGs and so lowpart_subreg\nwill succeed on them - even for theoretical MEMs using REGs there seems\ndesirable, we don't want to read following memory slots for the paradoxical\nsubreg.  For the outputs, I thought we'd get better code by always computing\nresult into a new pseudo and them move lowpart of that pseudo into dest.\n\nUnfortunately it regressed\nFAIL: gcc.target/i386/pr89984-2.c scan-assembler-not vmovaps\non which the patch changes:\n        vandps  .LC0(%rip), %xmm1, %xmm1\n-       vxorps  %xmm0, %xmm1, %xmm0\n+       vxorps  %xmm0, %xmm1, %xmm1\n+       vmovaps %xmm1, %xmm0\n        ret\nThe RA sees:\n(insn 8 4 9 2 (set (reg:V4SF 85)\n        (and:V4SF (subreg:V4SF (reg:SF 90) 0)\n            (mem/u/c:V4SF (symbol_ref/u:DI (\"*.LC0\") [flags 0x2]) [0  S16 A128]))) \"pr89984-2.c\":7:12 2838 {*andv4sf3}\n     (expr_list:REG_DEAD (reg:SF 90)\n        (nil)))\n(insn 9 8 10 2 (set (reg:V4SF 87)\n        (xor:V4SF (reg:V4SF 85)\n            (subreg:V4SF (reg:SF 89) 0))) \"pr89984-2.c\":7:12 2842 {*xorv4sf3}\n     (expr_list:REG_DEAD (reg:SF 89)\n        (expr_list:REG_DEAD (reg:V4SF 85)\n            (nil))))\n(insn 10 9 14 2 (set (reg:SF 82 [ <retval> ])\n        (subreg:SF (reg:V4SF 87) 0)) \"pr89984-2.c\":7:12 142 {*movsf_internal}\n     (expr_list:REG_DEAD (reg:V4SF 87)\n        (nil)))\n(insn 14 10 15 2 (set (reg/i:SF 20 xmm0)\n        (reg:SF 82 [ <retval> ])) \"pr89984-2.c\":8:1 142 {*movsf_internal}\n     (expr_list:REG_DEAD (reg:SF 82 [ <retval> ])\n        (nil)))\n(insn 15 14 0 2 (use (reg/i:SF 20 xmm0)) \"pr89984-2.c\":8:1 -1\n     (nil))\nand doesn't know that if it would use xmm0 not just for pseudo 82\nbut also for pseudo 87, it could create a noop move in insn 10 and\nso could avoid an extra register copy and nothing later on is able\nto figure that out either.  I don't know how the RA should know\nthat though.\n\nSo that we don't regress, this version of the patch\nwill do this stuff (i.e. use fresh vector pseudo as destination and\nthen move lowpart of that to dest) over what it used before (i.e.\nuse paradoxical subreg of the dest) only if lowpart_subreg returns NULL.\n\n2022-02-22  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR target/104612\n\t* config/i386/i386-expand.cc (ix86_expand_copysign): Call force_reg\n\ton input operands before calling lowpart_subreg on it.  For output\n\toperand, use a vmode pseudo as destination and then move its lowpart\n\tsubreg into operands[0] if lowpart_subreg fails on dest.\n\t(ix86_expand_xorsign): Likewise.\n\n\t* gcc.dg/pr104612.c: New test.", "tree": {"sha": "7f377868ab47b50f5768da786a06d5c170c87d49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7f377868ab47b50f5768da786a06d5c170c87d49"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e691189ca9c04fdba71ceada1faba62afbc1463", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e691189ca9c04fdba71ceada1faba62afbc1463", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e691189ca9c04fdba71ceada1faba62afbc1463", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e691189ca9c04fdba71ceada1faba62afbc1463/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6263b656c8fcfc6d7e1d2af55a88bc0429a4b352", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6263b656c8fcfc6d7e1d2af55a88bc0429a4b352", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6263b656c8fcfc6d7e1d2af55a88bc0429a4b352"}], "stats": {"total": 65, "additions": 54, "deletions": 11}, "files": [{"sha": "7f7055bcb43b88828663c1326db7c8209149c4b2", "filename": "gcc/config/i386/i386-expand.cc", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e691189ca9c04fdba71ceada1faba62afbc1463/gcc%2Fconfig%2Fi386%2Fi386-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e691189ca9c04fdba71ceada1faba62afbc1463/gcc%2Fconfig%2Fi386%2Fi386-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-expand.cc?ref=7e691189ca9c04fdba71ceada1faba62afbc1463", "patch": "@@ -2153,7 +2153,7 @@ void\n ix86_expand_copysign (rtx operands[])\n {\n   machine_mode mode, vmode;\n-  rtx dest, op0, op1, mask, op2, op3;\n+  rtx dest, vdest, op0, op1, mask, op2, op3;\n \n   mode = GET_MODE (operands[0]);\n \n@@ -2174,8 +2174,13 @@ ix86_expand_copysign (rtx operands[])\n       return;\n     }\n \n-  dest = lowpart_subreg (vmode, operands[0], mode);\n-  op1 = lowpart_subreg (vmode, operands[2], mode);\n+  dest = operands[0];\n+  vdest = lowpart_subreg (vmode, dest, mode);\n+  if (vdest == NULL_RTX)\n+    vdest = gen_reg_rtx (vmode);\n+  else\n+    dest = NULL_RTX;\n+  op1 = lowpart_subreg (vmode, force_reg (mode, operands[2]), mode);\n   mask = ix86_build_signbit_mask (vmode, 0, 0);\n \n   if (CONST_DOUBLE_P (operands[1]))\n@@ -2184,7 +2189,9 @@ ix86_expand_copysign (rtx operands[])\n       /* Optimize for 0, simplify b = copy_signf (0.0f, a) to b = mask & a.  */\n       if (op0 == CONST0_RTX (mode))\n \t{\n-\t  emit_move_insn (dest, gen_rtx_AND (vmode, mask, op1));\n+\t  emit_move_insn (vdest, gen_rtx_AND (vmode, mask, op1));\n+\t  if (dest)\n+\t    emit_move_insn (dest, lowpart_subreg (mode, vdest, vmode));\n \t  return;\n \t}\n \n@@ -2193,15 +2200,17 @@ ix86_expand_copysign (rtx operands[])\n       op0 = force_reg (vmode, op0);\n     }\n   else\n-    op0 = lowpart_subreg (vmode, operands[1], mode);\n+    op0 = lowpart_subreg (vmode, force_reg (mode, operands[1]), mode);\n \n   op2 = gen_reg_rtx (vmode);\n   op3 = gen_reg_rtx (vmode);\n   emit_move_insn (op2, gen_rtx_AND (vmode,\n \t\t\t\t    gen_rtx_NOT (vmode, mask),\n \t\t\t\t    op0));\n   emit_move_insn (op3, gen_rtx_AND (vmode, mask, op1));\n-  emit_move_insn (dest, gen_rtx_IOR (vmode, op2, op3));\n+  emit_move_insn (vdest, gen_rtx_IOR (vmode, op2, op3));\n+  if (dest)\n+    emit_move_insn (dest, lowpart_subreg (mode, vdest, vmode));\n }\n \n /* Expand an xorsign operation.  */\n@@ -2210,7 +2219,7 @@ void\n ix86_expand_xorsign (rtx operands[])\n {\n   machine_mode mode, vmode;\n-  rtx dest, op0, op1, mask, x, temp;\n+  rtx dest, vdest, op0, op1, mask, x, temp;\n \n   dest = operands[0];\n   op0 = operands[1];\n@@ -2230,15 +2239,22 @@ ix86_expand_xorsign (rtx operands[])\n   temp = gen_reg_rtx (vmode);\n   mask = ix86_build_signbit_mask (vmode, 0, 0);\n \n-  op1 = lowpart_subreg (vmode, op1, mode);\n+  op1 = lowpart_subreg (vmode, force_reg (mode, op1), mode);\n   x = gen_rtx_AND (vmode, op1, mask);\n   emit_insn (gen_rtx_SET (temp, x));\n \n-  op0 = lowpart_subreg (vmode, op0, mode);\n+  op0 = lowpart_subreg (vmode, force_reg (mode, op0), mode);\n   x = gen_rtx_XOR (vmode, temp, op0);\n \n-  dest = lowpart_subreg (vmode, dest, mode);\n-  emit_insn (gen_rtx_SET (dest, x));\n+  vdest = lowpart_subreg (vmode, dest, mode);\n+  if (vdest == NULL_RTX)\n+    vdest = gen_reg_rtx (vmode);\n+  else\n+    dest = NULL_RTX;\n+  emit_insn (gen_rtx_SET (vdest, x));\n+\n+  if (dest)\n+    emit_move_insn (dest, lowpart_subreg (mode, vdest, vmode));\n }\n \n static rtx ix86_expand_compare (enum rtx_code code, rtx op0, rtx op1);"}, {"sha": "7d055ed871b84f1f458b0a2f8e7ce9cca4deae8b", "filename": "gcc/testsuite/gcc.dg/pr104612.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e691189ca9c04fdba71ceada1faba62afbc1463/gcc%2Ftestsuite%2Fgcc.dg%2Fpr104612.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e691189ca9c04fdba71ceada1faba62afbc1463/gcc%2Ftestsuite%2Fgcc.dg%2Fpr104612.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr104612.c?ref=7e691189ca9c04fdba71ceada1faba62afbc1463", "patch": "@@ -0,0 +1,27 @@\n+/* PR target/104612 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-additional-options \"-msse2 -mfpmath=sse\" { target i?86-*-* x86_64-*-* } } */\n+\n+struct V { float x, y; };\n+\n+struct V\n+foo (struct V v)\n+{\n+  struct V ret;\n+  ret.x = __builtin_copysignf (1.0e+0, v.x);\n+  ret.y = __builtin_copysignf (1.0e+0, v.y);\n+  return ret;\n+}\n+\n+float\n+bar (struct V v)\n+{\n+  return __builtin_copysignf (v.x, v.y);\n+}\n+\n+float\n+baz (struct V v)\n+{\n+  return v.x * __builtin_copysignf (1.0f, v.y);\n+}"}]}