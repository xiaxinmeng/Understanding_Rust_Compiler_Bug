{"sha": "84935c9822183ce403bb361c5f405711b9a808c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQ5MzVjOTgyMjE4M2NlNDAzYmIzNjFjNWY0MDU3MTFiOWE4MDhjNg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-04-15T10:09:01Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-05-15T06:56:08Z"}, "message": "tree-optimization/33315 - common stores during sinking\n\nThis implements commoning of stores to a common successor in\na simple ad-hoc way.  I've decided to put it into the code sinking\npass since, well, it sinks stores.  It's still separate since\nit does not really sink code into less executed places.\n\nIt's ad-hoc since it does not perform any dataflow or alias analysis\nbut simply only considers trailing stores in a block, iteratively\nthough.  If the stores are from different values a PHI node is\ninserted to merge them.  gcc.dg/tree-ssa/split-path-7.c shows\nthat path splitting will eventually undo this very transform,\nI've decided to not bother with it and simply disable sinking for\nthe particular testcase.\n\nDoing this transform is good for code size when the stores are\nfrom constants, once we have to insert PHIs the situation becomes\nless clear but it's a transform we do elsewhere as well\n(cselim for one), and reversing the transform should be easy.\n\n2020-05-15  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/33315\n\t* tree-ssa-sink.c: Include tree-eh.h.\n\t(sink_stats): Add commoned member.\n\t(sink_common_stores_to_bb): New function implementing store\n\tcommoning by sinking to the successor.\n\t(sink_code_in_bb): Call it, pass down TODO_cleanup_cfg returned.\n\t(pass_sink_code::execute): Likewise.  Record commoned stores\n\tin statistics.\n\n\t* gcc.dg/tree-ssa/ssa-sink-13.c: New testcase.\n\t* gcc.dg/tree-ssa/ssa-sink-14.c: Likewise.\n\t* gcc.dg/tree-ssa/split-path-7.c: Disable sinking.", "tree": {"sha": "fbf59f25c432dc6445e1146d4af0446026d6ab11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fbf59f25c432dc6445e1146d4af0446026d6ab11"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/84935c9822183ce403bb361c5f405711b9a808c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84935c9822183ce403bb361c5f405711b9a808c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84935c9822183ce403bb361c5f405711b9a808c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84935c9822183ce403bb361c5f405711b9a808c6/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a15faa730f99100f6f3ed12663563356ec5a2c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a15faa730f99100f6f3ed12663563356ec5a2c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a15faa730f99100f6f3ed12663563356ec5a2c0"}], "stats": {"total": 247, "additions": 242, "deletions": 5}, "files": [{"sha": "7daad3c214ecb5adce7c8dc064a300489c03f04b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84935c9822183ce403bb361c5f405711b9a808c6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84935c9822183ce403bb361c5f405711b9a808c6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=84935c9822183ce403bb361c5f405711b9a808c6", "patch": "@@ -1,3 +1,14 @@\n+2020-05-15  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/33315\n+\t* tree-ssa-sink.c: Include tree-eh.h.\n+\t(sink_stats): Add commoned member.\n+\t(sink_common_stores_to_bb): New function implementing store\n+\tcommoning by sinking to the successor.\n+\t(sink_code_in_bb): Call it, pass down TODO_cleanup_cfg returned.\n+\t(pass_sink_code::execute): Likewise.  Record commoned stores\n+\tin statistics.\n+\n 2020-05-14  Xiong Hu Luo  <luoxhu@linux.ibm.com>\n \n \tPR rtl-optimization/37451, part of PR target/61837"}, {"sha": "0bf5dcdbe06a638127c8f20a5b2c6afebf281d32", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84935c9822183ce403bb361c5f405711b9a808c6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84935c9822183ce403bb361c5f405711b9a808c6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=84935c9822183ce403bb361c5f405711b9a808c6", "patch": "@@ -1,3 +1,10 @@\n+2020-05-15  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/33315\n+\t* gcc.dg/tree-ssa/ssa-sink-13.c: New testcase.\n+\t* gcc.dg/tree-ssa/ssa-sink-14.c: Likewise.\n+\t* gcc.dg/tree-ssa/split-path-7.c: Disable sinking.\n+\n 2020-05-14  Xiong Hu Luo  <luoxhu@linux.ibm.com>\n \n \tPR rtl-optimization/37451, part of PR target/61837"}, {"sha": "a5df75c9b72fdfe253e4bd6fb2d32de12f46f732", "filename": "gcc/testsuite/gcc.dg/tree-ssa/split-path-7.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84935c9822183ce403bb361c5f405711b9a808c6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsplit-path-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84935c9822183ce403bb361c5f405711b9a808c6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsplit-path-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsplit-path-7.c?ref=84935c9822183ce403bb361c5f405711b9a808c6", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fsplit-paths -fno-tree-cselim -fdump-tree-split-paths-details -w\" } */\n+/* { dg-options \"-O2 -fsplit-paths -fno-tree-cselim -fno-tree-sink -fdump-tree-split-paths-details -w\" } */\n \n \n struct _reent"}, {"sha": "a65ba35d4ba9d8a11f57934c2e576b8a88fd4084", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-sink-13.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84935c9822183ce403bb361c5f405711b9a808c6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-sink-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84935c9822183ce403bb361c5f405711b9a808c6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-sink-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-sink-13.c?ref=84935c9822183ce403bb361c5f405711b9a808c6", "patch": "@@ -0,0 +1,25 @@\n+/* PR33315 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-sink\" } */\n+\n+int num;\n+int a[20];\n+\n+void test ()\n+{\n+  int i;\n+  int *ptr;\n+  ptr = & a[0];\n+  i = num;\n+  if ( i == 1) *(ptr+0) = 0;\n+  if ( i != 1) *(ptr+0) = 0;\n+  if ( i == 2) *(ptr+1) = 0;\n+  if ( i != 2) *(ptr+1) = 0;\n+  if ( i == 3) *(ptr+2) = 0;\n+  if ( i != 3) *(ptr+2) = 0;\n+}\n+\n+/* We should sink/merge all stores and end up with a single BB.  */\n+\n+/* { dg-final { scan-tree-dump-times \"MEM\\[^\\n\\r\\]* = 0;\" 3 \"sink\" } } */\n+/* { dg-final { scan-tree-dump-times \"<bb \" 1 \"sink\" } } */"}, {"sha": "771cd4420c4d71956c1cf183e5115e6d9d7bf3fa", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-sink-14.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84935c9822183ce403bb361c5f405711b9a808c6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-sink-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84935c9822183ce403bb361c5f405711b9a808c6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-sink-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-sink-14.c?ref=84935c9822183ce403bb361c5f405711b9a808c6", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-sink\" } */\n+\n+int x;\n+void foo (int b)\n+{\n+  if (b)\n+    x = b;\n+  else\n+    x = 2;\n+}\n+\n+/* We should have sunk the store and inserted a PHI to merge the\n+   stored values.  */\n+\n+/* { dg-final { scan-tree-dump-times \" = PHI\" 1 \"sink\" } } */\n+/* { dg-final { scan-tree-dump-times \"x = \" 1 \"sink\" } } */"}, {"sha": "c5b535bed4d198bb72e05a01762e130a6fb79c47", "filename": "gcc/tree-ssa-sink.c", "status": "modified", "additions": 181, "deletions": 4, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84935c9822183ce403bb361c5f405711b9a808c6/gcc%2Ftree-ssa-sink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84935c9822183ce403bb361c5f405711b9a808c6/gcc%2Ftree-ssa-sink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sink.c?ref=84935c9822183ce403bb361c5f405711b9a808c6", "patch": "@@ -34,6 +34,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-iterator.h\"\n #include \"tree-cfg.h\"\n #include \"cfgloop.h\"\n+#include \"tree-eh.h\"\n \n /* TODO:\n    1. Sinking store only using scalar promotion (IE without moving the RHS):\n@@ -67,6 +68,8 @@ static struct\n   /* The number of statements sunk down the flowgraph by code sinking.  */\n   int sunk;\n \n+  /* The number of stores commoned and sunk down by store commoning.  */\n+  int commoned;\n } sink_stats;\n \n \n@@ -467,16 +470,187 @@ statement_sink_location (gimple *stmt, basic_block frombb,\n   return true;\n }\n \n+/* Very simplistic code to sink common stores from the predecessor through\n+   our virtual PHI.  We do this before sinking stmts from BB as it might\n+   expose sinking opportunities of the merged stores.\n+   Once we have partial dead code elimination through sth like SSU-PRE this\n+   should be moved there.  */\n+\n+static unsigned\n+sink_common_stores_to_bb (basic_block bb)\n+{\n+  unsigned todo = 0;\n+  gphi *phi;\n+\n+  if (EDGE_COUNT (bb->preds) > 1\n+      && (phi = get_virtual_phi (bb)))\n+    {\n+      /* Repeat until no more common stores are found.  */\n+      while (1)\n+\t{\n+\t  gimple *first_store = NULL;\n+\t  auto_vec <tree, 5> vdefs;\n+\t  gimple_stmt_iterator gsi;\n+\n+\t  /* Search for common stores defined by all virtual PHI args.\n+\t     ???  Common stores not present in all predecessors could\n+\t     be handled by inserting a forwarder to sink to.  Generally\n+\t     this involves deciding which stores to do this for if\n+\t     multiple common stores are present for different sets of\n+\t     predecessors.  See PR11832 for an interesting case.  */\n+\t  for (unsigned i = 0; i < gimple_phi_num_args (phi); ++i)\n+\t    {\n+\t      tree arg = gimple_phi_arg_def (phi, i);\n+\t      gimple *def = SSA_NAME_DEF_STMT (arg);\n+\t      if (! is_gimple_assign (def)\n+\t\t  || stmt_can_throw_internal (cfun, def))\n+\t\t{\n+\t\t  /* ???  We could handle some cascading with the def being\n+\t\t     another PHI.  We'd have to insert multiple PHIs for\n+\t\t     the rhs then though (if they are not all equal).  */\n+\t\t  first_store = NULL;\n+\t\t  break;\n+\t\t}\n+\t      /* ???  Do not try to do anything fancy with aliasing, thus\n+\t\t do not sink across non-aliased loads (or even stores,\n+\t\t so different store order will make the sinking fail).  */\n+\t      bool all_uses_on_phi = true;\n+\t      imm_use_iterator iter;\n+\t      use_operand_p use_p;\n+\t      FOR_EACH_IMM_USE_FAST (use_p, iter, arg)\n+\t\tif (USE_STMT (use_p) != phi)\n+\t\t  {\n+\t\t    all_uses_on_phi = false;\n+\t\t    break;\n+\t\t  }\n+\t      if (! all_uses_on_phi)\n+\t\t{\n+\t\t  first_store = NULL;\n+\t\t  break;\n+\t\t}\n+\t      /* Check all stores are to the same LHS.  */\n+\t      if (! first_store)\n+\t\tfirst_store = def;\n+\t      /* ??? We could handle differing SSA uses in the LHS by inserting\n+\t\t PHIs for them.  */\n+\t      else if (! operand_equal_p (gimple_assign_lhs (first_store),\n+\t\t\t\t\t  gimple_assign_lhs (def), 0))\n+\t\t{\n+\t\t  first_store = NULL;\n+\t\t  break;\n+\t\t}\n+\t      vdefs.safe_push (arg);\n+\t    }\n+\t  if (! first_store)\n+\t    break;\n+\n+\t  /* Check if we need a PHI node to merge the stored values.  */\n+\t  bool allsame = true;\n+\t  for (unsigned i = 1; i < vdefs.length (); ++i)\n+\t    {\n+\t      gimple *def = SSA_NAME_DEF_STMT (vdefs[i]);\n+\t      if (! operand_equal_p (gimple_assign_rhs1 (first_store),\n+\t\t\t\t     gimple_assign_rhs1 (def), 0))\n+\t\t{\n+\t\t  allsame = false;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\n+\t  /* We cannot handle aggregate values if we need to merge them.  */\n+\t  tree type = TREE_TYPE (gimple_assign_lhs (first_store));\n+\t  if (! allsame\n+\t      && ! is_gimple_reg_type (type))\n+\t    break;\n+\n+\t  if (dump_enabled_p ())\n+\t    {\n+\t      dump_printf_loc (MSG_OPTIMIZED_LOCATIONS,\n+\t\t\t       first_store,\n+\t\t\t       \"sinking common stores %sto \",\n+\t\t\t       allsame ? \"with same value \" : \"\");\n+\t      dump_generic_expr (MSG_OPTIMIZED_LOCATIONS, TDF_SLIM,\n+\t\t\t\t gimple_assign_lhs (first_store));\n+\t      dump_printf (MSG_OPTIMIZED_LOCATIONS, \"\\n\");\n+\t    }\n+\n+\t  /* Insert a PHI to merge differing stored values if necessary.\n+\t     Note that in general inserting PHIs isn't a very good idea as\n+\t     it makes the job of coalescing and register allocation harder.\n+\t     Even common SSA uses on the rhs/lhs might extend their lifetime\n+\t     across multiple edges by this code motion which makes\n+\t     register allocation harder.  */\n+\t  tree from;\n+\t  if (! allsame)\n+\t    {\n+\t      from = make_ssa_name (type);\n+\t      gphi *newphi = create_phi_node (from, bb);\n+\t      for (unsigned i = 0; i < vdefs.length (); ++i)\n+\t\t{\n+\t\t  gimple *def = SSA_NAME_DEF_STMT (vdefs[i]);\n+\t\t  add_phi_arg (newphi, gimple_assign_rhs1 (def),\n+\t\t\t       EDGE_PRED (bb, i), UNKNOWN_LOCATION);\n+\t\t}\n+\t    }\n+\t  else\n+\t    from = gimple_assign_rhs1 (first_store);\n+\n+\t  /* Remove all stores.  */\n+\t  for (unsigned i = 0; i < vdefs.length (); ++i)\n+\t    TREE_VISITED (vdefs[i]) = 1;\n+\t  for (unsigned i = 0; i < vdefs.length (); ++i)\n+\t    /* If we have more than one use of a VDEF on the PHI make sure\n+\t       we remove the defining stmt only once.  */\n+\t    if (TREE_VISITED (vdefs[i]))\n+\t      {\n+\t\tTREE_VISITED (vdefs[i]) = 0;\n+\t\tgimple *def = SSA_NAME_DEF_STMT (vdefs[i]);\n+\t\tgsi = gsi_for_stmt (def);\n+\t\tunlink_stmt_vdef (def);\n+\t\tgsi_remove (&gsi, true);\n+\t\trelease_defs (def);\n+\t      }\n+\n+\t  /* Insert the first store at the beginning of the merge BB.  */\n+\t  gimple_set_vdef (first_store, gimple_phi_result (phi));\n+\t  SSA_NAME_DEF_STMT (gimple_vdef (first_store)) = first_store;\n+\t  gimple_phi_set_result (phi, make_ssa_name (gimple_vop (cfun)));\n+\t  gimple_set_vuse (first_store, gimple_phi_result (phi));\n+\t  gimple_assign_set_rhs1 (first_store, from);\n+\t  /* ???  Should we reset first_stores location?  */\n+\t  gsi = gsi_after_labels (bb);\n+\t  gsi_insert_before (&gsi, first_store, GSI_SAME_STMT);\n+\t  sink_stats.commoned++;\n+\n+\t  todo |= TODO_cleanup_cfg;\n+\t}\n+\n+      /* We could now have empty predecessors that we could remove,\n+\t forming a proper CFG for further sinking.  Note that even\n+\t CFG cleanup doesn't do this fully at the moment and it\n+\t doesn't preserve post-dominators in the process either.\n+\t The mergephi pass might do it though.  gcc.dg/tree-ssa/ssa-sink-13.c\n+\t shows this nicely if you disable tail merging or (same effect)\n+\t make the stored values unequal.  */\n+    }\n+\n+  return todo;\n+}\n+\n /* Perform code sinking on BB */\n \n-static void\n+static unsigned\n sink_code_in_bb (basic_block bb)\n {\n   basic_block son;\n   gimple_stmt_iterator gsi;\n   edge_iterator ei;\n   edge e;\n   bool last = true;\n+  unsigned todo = 0;\n+\n+  /* Sink common stores from the predecessor through our virtual PHI.  */\n+  todo |= sink_common_stores_to_bb (bb);\n \n   /* If this block doesn't dominate anything, there can't be any place to sink\n      the statements to.  */\n@@ -563,8 +737,10 @@ sink_code_in_bb (basic_block bb)\n        son;\n        son = next_dom_son (CDI_POST_DOMINATORS, son))\n     {\n-      sink_code_in_bb (son);\n+      todo |= sink_code_in_bb (son);\n     }\n+\n+  return todo;\n }\n \n /* Perform code sinking.\n@@ -642,13 +818,14 @@ pass_sink_code::execute (function *fun)\n   memset (&sink_stats, 0, sizeof (sink_stats));\n   calculate_dominance_info (CDI_DOMINATORS);\n   calculate_dominance_info (CDI_POST_DOMINATORS);\n-  sink_code_in_bb (EXIT_BLOCK_PTR_FOR_FN (fun));\n+  unsigned todo = sink_code_in_bb (EXIT_BLOCK_PTR_FOR_FN (fun));\n   statistics_counter_event (fun, \"Sunk statements\", sink_stats.sunk);\n+  statistics_counter_event (fun, \"Commoned stores\", sink_stats.commoned);\n   free_dominance_info (CDI_POST_DOMINATORS);\n   remove_fake_exit_edges ();\n   loop_optimizer_finalize ();\n \n-  return 0;\n+  return todo;\n }\n \n } // anon namespace"}]}