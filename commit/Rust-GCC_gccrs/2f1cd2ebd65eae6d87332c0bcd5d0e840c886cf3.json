{"sha": "2f1cd2ebd65eae6d87332c0bcd5d0e840c886cf3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmYxY2QyZWJkNjVlYWU2ZDg3MzMyYzBiY2Q1ZDBlODQwYzg4NmNmMw==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2013-09-09T13:06:53Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2013-09-09T13:06:53Z"}, "message": "asan.c (asan_clear_shadow): Use gen_int_mode with the mode of the associated expand_* call.\n\ngcc/\n\t* asan.c (asan_clear_shadow): Use gen_int_mode with the mode\n\tof the associated expand_* call.\n\t(asan_emit_stack_protection): Likewise.\n\t* builtins.c (round_trampoline_addr): Likewise.\n\t* explow.c (allocate_dynamic_stack_space, probe_stack_range): Likewise.\n\t* expmed.c (expand_smod_pow2, expand_sdiv_pow2, expand_divmod)\n\t(emit_store_flag): Likewise.\n\t* expr.c (emit_move_resolve_push, push_block, emit_single_push_insn_1)\n\t(emit_push_insn, optimize_bitfield_assignment_op, expand_expr_real_1):\n\tLikewise.\n\t* function.c (instantiate_virtual_regs_in_insn): Likewise.\n\t* ifcvt.c (noce_try_store_flag_constants): Likewise.\n\t* loop-unroll.c (unroll_loop_runtime_iterations): Likewise.\n\t* modulo-sched.c (generate_prolog_epilog): Likewise.\n\t* optabs.c (expand_binop, widen_leading, expand_doubleword_clz)\n\t(expand_ctz, expand_ffs, expand_unop): Likewise.\n\nFrom-SVN: r202392", "tree": {"sha": "8a0c069c9c8784f5d1a4f0ad98b31f8275795896", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a0c069c9c8784f5d1a4f0ad98b31f8275795896"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f1cd2ebd65eae6d87332c0bcd5d0e840c886cf3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f1cd2ebd65eae6d87332c0bcd5d0e840c886cf3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f1cd2ebd65eae6d87332c0bcd5d0e840c886cf3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f1cd2ebd65eae6d87332c0bcd5d0e840c886cf3/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4789c0cef392722e1c084eba900c0c469fba3bc1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4789c0cef392722e1c084eba900c0c469fba3bc1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4789c0cef392722e1c084eba900c0c469fba3bc1"}], "stats": {"total": 193, "additions": 118, "deletions": 75}, "files": [{"sha": "dd83c9e9c962d15c8d80edbf232b859a8c45d9ce", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f1cd2ebd65eae6d87332c0bcd5d0e840c886cf3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f1cd2ebd65eae6d87332c0bcd5d0e840c886cf3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2f1cd2ebd65eae6d87332c0bcd5d0e840c886cf3", "patch": "@@ -1,3 +1,22 @@\n+2013-09-09  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* asan.c (asan_clear_shadow): Use gen_int_mode with the mode\n+\tof the associated expand_* call.\n+\t(asan_emit_stack_protection): Likewise.\n+\t* builtins.c (round_trampoline_addr): Likewise.\n+\t* explow.c (allocate_dynamic_stack_space, probe_stack_range): Likewise.\n+\t* expmed.c (expand_smod_pow2, expand_sdiv_pow2, expand_divmod)\n+\t(emit_store_flag): Likewise.\n+\t* expr.c (emit_move_resolve_push, push_block, emit_single_push_insn_1)\n+\t(emit_push_insn, optimize_bitfield_assignment_op, expand_expr_real_1):\n+\tLikewise.\n+\t* function.c (instantiate_virtual_regs_in_insn): Likewise.\n+\t* ifcvt.c (noce_try_store_flag_constants): Likewise.\n+\t* loop-unroll.c (unroll_loop_runtime_iterations): Likewise.\n+\t* modulo-sched.c (generate_prolog_epilog): Likewise.\n+\t* optabs.c (expand_binop, widen_leading, expand_doubleword_clz)\n+\t(expand_ctz, expand_ffs, expand_unop): Likewise.\n+\n 2013-09-09  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* alias.c (addr_side_effect_eval): Use gen_int_mode with the mode"}, {"sha": "844d53e598b849effc6c04c0489a88b93d92aabe", "filename": "gcc/asan.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f1cd2ebd65eae6d87332c0bcd5d0e840c886cf3/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f1cd2ebd65eae6d87332c0bcd5d0e840c886cf3/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=2f1cd2ebd65eae6d87332c0bcd5d0e840c886cf3", "patch": "@@ -901,7 +901,7 @@ asan_clear_shadow (rtx shadow_mem, HOST_WIDE_INT len)\n   emit_label (top_label);\n \n   emit_move_insn (shadow_mem, const0_rtx);\n-  tmp = expand_simple_binop (Pmode, PLUS, addr, GEN_INT (4), addr,\n+  tmp = expand_simple_binop (Pmode, PLUS, addr, gen_int_mode (4, Pmode), addr,\n                              true, OPTAB_LIB_WIDEN);\n   if (tmp != addr)\n     emit_move_insn (addr, tmp);\n@@ -966,7 +966,8 @@ asan_emit_stack_protection (rtx base, HOST_WIDE_INT *offsets, tree *decls,\n   str_cst = asan_pp_string (&asan_pp);\n \n   /* Emit the prologue sequence.  */\n-  base = expand_binop (Pmode, add_optab, base, GEN_INT (base_offset),\n+  base = expand_binop (Pmode, add_optab, base,\n+\t\t       gen_int_mode (base_offset, Pmode),\n \t\t       NULL_RTX, 1, OPTAB_DIRECT);\n   mem = gen_rtx_MEM (ptr_mode, base);\n   emit_move_insn (mem, GEN_INT (ASAN_STACK_FRAME_MAGIC));\n@@ -976,7 +977,8 @@ asan_emit_stack_protection (rtx base, HOST_WIDE_INT *offsets, tree *decls,\n \t\t\t      GEN_INT (ASAN_SHADOW_SHIFT),\n \t\t\t      NULL_RTX, 1, OPTAB_DIRECT);\n   shadow_base = expand_binop (Pmode, add_optab, shadow_base,\n-\t\t\t      GEN_INT (targetm.asan_shadow_offset ()),\n+\t\t\t      gen_int_mode (targetm.asan_shadow_offset (),\n+\t\t\t\t\t    Pmode),\n \t\t\t      NULL_RTX, 1, OPTAB_DIRECT);\n   gcc_assert (asan_shadow_set != -1\n \t      && (ASAN_RED_ZONE_SIZE >> ASAN_SHADOW_SHIFT) == 4);"}, {"sha": "6f690c76ed9e617a312fddacb41c5fbbcdc171a2", "filename": "gcc/builtins.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f1cd2ebd65eae6d87332c0bcd5d0e840c886cf3/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f1cd2ebd65eae6d87332c0bcd5d0e840c886cf3/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=2f1cd2ebd65eae6d87332c0bcd5d0e840c886cf3", "patch": "@@ -4862,8 +4862,8 @@ round_trampoline_addr (rtx tramp)\n \n   /* Round address up to desired boundary.  */\n   temp = gen_reg_rtx (Pmode);\n-  addend = GEN_INT (TRAMPOLINE_ALIGNMENT / BITS_PER_UNIT - 1);\n-  mask = GEN_INT (-TRAMPOLINE_ALIGNMENT / BITS_PER_UNIT);\n+  addend = gen_int_mode (TRAMPOLINE_ALIGNMENT / BITS_PER_UNIT - 1, Pmode);\n+  mask = gen_int_mode (-TRAMPOLINE_ALIGNMENT / BITS_PER_UNIT, Pmode);\n \n   temp  = expand_simple_binop (Pmode, PLUS, tramp, addend,\n \t\t\t       temp, 0, OPTAB_LIB_WIDEN);"}, {"sha": "0ae5ee05da45fb867b36ad06ebaf5c71a7630967", "filename": "gcc/explow.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f1cd2ebd65eae6d87332c0bcd5d0e840c886cf3/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f1cd2ebd65eae6d87332c0bcd5d0e840c886cf3/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=2f1cd2ebd65eae6d87332c0bcd5d0e840c886cf3", "patch": "@@ -1355,7 +1355,8 @@ allocate_dynamic_stack_space (rtx size, unsigned size_align,\n       else\n \t{\n \t  ask = expand_binop (Pmode, add_optab, size,\n-\t\t\t      GEN_INT (required_align / BITS_PER_UNIT - 1),\n+\t\t\t      gen_int_mode (required_align / BITS_PER_UNIT - 1,\n+\t\t\t\t\t    Pmode),\n \t\t\t      NULL_RTX, 1, OPTAB_LIB_WIDEN);\n \t  must_align = true;\n \t}\n@@ -1481,13 +1482,16 @@ allocate_dynamic_stack_space (rtx size, unsigned size_align,\n \t but we know it can't.  So add ourselves and then do\n \t TRUNC_DIV_EXPR.  */\n       target = expand_binop (Pmode, add_optab, target,\n-\t\t\t     GEN_INT (required_align / BITS_PER_UNIT - 1),\n+\t\t\t     gen_int_mode (required_align / BITS_PER_UNIT - 1,\n+\t\t\t\t\t   Pmode),\n \t\t\t     NULL_RTX, 1, OPTAB_LIB_WIDEN);\n       target = expand_divmod (0, TRUNC_DIV_EXPR, Pmode, target,\n-\t\t\t      GEN_INT (required_align / BITS_PER_UNIT),\n+\t\t\t      gen_int_mode (required_align / BITS_PER_UNIT,\n+\t\t\t\t\t    Pmode),\n \t\t\t      NULL_RTX, 1);\n       target = expand_mult (Pmode, target,\n-\t\t\t    GEN_INT (required_align / BITS_PER_UNIT),\n+\t\t\t    gen_int_mode (required_align / BITS_PER_UNIT,\n+\t\t\t\t\t  Pmode),\n \t\t\t    NULL_RTX, 1);\n     }\n \n@@ -1669,7 +1673,7 @@ probe_stack_range (HOST_WIDE_INT first, rtx size)\n \n       /* TEST_ADDR = TEST_ADDR + PROBE_INTERVAL.  */\n       temp = expand_binop (Pmode, STACK_GROW_OPTAB, test_addr,\n-\t\t\t   GEN_INT (PROBE_INTERVAL), test_addr,\n+\t\t\t   gen_int_mode (PROBE_INTERVAL, Pmode), test_addr,\n \t\t\t   1, OPTAB_WIDEN);\n \n       gcc_assert (temp == test_addr);"}, {"sha": "f0a483741eb8460291a9c73a6d327540f43a16e9", "filename": "gcc/expmed.c", "status": "modified", "additions": 35, "deletions": 27, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f1cd2ebd65eae6d87332c0bcd5d0e840c886cf3/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f1cd2ebd65eae6d87332c0bcd5d0e840c886cf3/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=2f1cd2ebd65eae6d87332c0bcd5d0e840c886cf3", "patch": "@@ -3666,7 +3666,8 @@ expand_smod_pow2 (enum machine_mode mode, rtx op0, HOST_WIDE_INT d)\n \t\t\t\t   NULL_RTX, 1, OPTAB_LIB_WIDEN);\n \t      temp = expand_binop (mode, sub_optab, temp, signmask,\n \t\t\t\t   NULL_RTX, 1, OPTAB_LIB_WIDEN);\n-\t      temp = expand_binop (mode, and_optab, temp, GEN_INT (masklow),\n+\t      temp = expand_binop (mode, and_optab, temp,\n+\t\t\t\t   gen_int_mode (masklow, mode),\n \t\t\t\t   NULL_RTX, 1, OPTAB_LIB_WIDEN);\n \t      temp = expand_binop (mode, xor_optab, temp, signmask,\n \t\t\t\t   NULL_RTX, 1, OPTAB_LIB_WIDEN);\n@@ -3681,7 +3682,8 @@ expand_smod_pow2 (enum machine_mode mode, rtx op0, HOST_WIDE_INT d)\n \n \t      temp = expand_binop (mode, add_optab, op0, signmask,\n \t\t\t\t   NULL_RTX, 1, OPTAB_LIB_WIDEN);\n-\t      temp = expand_binop (mode, and_optab, temp, GEN_INT (masklow),\n+\t      temp = expand_binop (mode, and_optab, temp,\n+\t\t\t\t   gen_int_mode (masklow, mode),\n \t\t\t\t   NULL_RTX, 1, OPTAB_LIB_WIDEN);\n \t      temp = expand_binop (mode, sub_optab, temp, signmask,\n \t\t\t\t   NULL_RTX, 1, OPTAB_LIB_WIDEN);\n@@ -3764,7 +3766,7 @@ expand_sdiv_pow2 (enum machine_mode mode, rtx op0, HOST_WIDE_INT d)\n \n       start_sequence ();\n       temp2 = copy_to_mode_reg (mode, op0);\n-      temp = expand_binop (mode, add_optab, temp2, GEN_INT (d-1),\n+      temp = expand_binop (mode, add_optab, temp2, gen_int_mode (d - 1, mode),\n \t\t\t   NULL_RTX, 0, OPTAB_LIB_WIDEN);\n       temp = force_reg (mode, temp);\n \n@@ -3791,7 +3793,7 @@ expand_sdiv_pow2 (enum machine_mode mode, rtx op0, HOST_WIDE_INT d)\n       temp = emit_store_flag (temp, LT, op0, const0_rtx, mode, 0, -1);\n       if (shift_cost (optimize_insn_for_speed_p (), mode, ushift)\n \t  > COSTS_N_INSNS (1))\n-\ttemp = expand_binop (mode, and_optab, temp, GEN_INT (d - 1),\n+\ttemp = expand_binop (mode, and_optab, temp, gen_int_mode (d - 1, mode),\n \t\t\t     NULL_RTX, 0, OPTAB_LIB_WIDEN);\n       else\n \ttemp = expand_shift (RSHIFT_EXPR, mode, temp,\n@@ -3804,7 +3806,7 @@ expand_sdiv_pow2 (enum machine_mode mode, rtx op0, HOST_WIDE_INT d)\n   label = gen_label_rtx ();\n   temp = copy_to_mode_reg (mode, op0);\n   do_cmp_and_jump (temp, const0_rtx, GE, mode, label);\n-  expand_inc (temp, GEN_INT (d - 1));\n+  expand_inc (temp, gen_int_mode (d - 1, mode));\n   emit_label (label);\n   return expand_shift (RSHIFT_EXPR, mode, temp, logd, NULL_RTX, 0);\n }\n@@ -4062,9 +4064,11 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t    pre_shift = floor_log2 (d);\n \t\t    if (rem_flag)\n \t\t      {\n+\t\t\tunsigned HOST_WIDE_INT mask\n+\t\t\t  = ((unsigned HOST_WIDE_INT) 1 << pre_shift) - 1;\n \t\t\tremainder\n \t\t\t  = expand_binop (compute_mode, and_optab, op0,\n-\t\t\t\t\t  GEN_INT (((HOST_WIDE_INT) 1 << pre_shift) - 1),\n+\t\t\t\t\t  gen_int_mode (mask, compute_mode),\n \t\t\t\t\t  remainder, 1,\n \t\t\t\t\t  OPTAB_LIB_WIDEN);\n \t\t\tif (remainder)\n@@ -4115,10 +4119,10 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\t      = (shift_cost (speed, compute_mode, post_shift - 1)\n \t\t\t\t + shift_cost (speed, compute_mode, 1)\n \t\t\t\t + 2 * add_cost (speed, compute_mode));\n-\t\t\t    t1 = expmed_mult_highpart (compute_mode, op0,\n-\t\t\t\t\t\t       GEN_INT (ml),\n-\t\t\t\t\t\t       NULL_RTX, 1,\n-\t\t\t\t\t\t       max_cost - extra_cost);\n+\t\t\t    t1 = expmed_mult_highpart\n+\t\t\t      (compute_mode, op0,\n+\t\t\t       gen_int_mode (ml, compute_mode),\n+\t\t\t       NULL_RTX, 1, max_cost - extra_cost);\n \t\t\t    if (t1 == 0)\n \t\t\t      goto fail1;\n \t\t\t    t2 = force_operand (gen_rtx_MINUS (compute_mode,\n@@ -4147,10 +4151,10 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\t    extra_cost\n \t\t\t      = (shift_cost (speed, compute_mode, pre_shift)\n \t\t\t\t + shift_cost (speed, compute_mode, post_shift));\n-\t\t\t    t2 = expmed_mult_highpart (compute_mode, t1,\n-\t\t\t\t\t\t       GEN_INT (ml),\n-\t\t\t\t\t\t       NULL_RTX, 1,\n-\t\t\t\t\t\t       max_cost - extra_cost);\n+\t\t\t    t2 = expmed_mult_highpart\n+\t\t\t      (compute_mode, t1,\n+\t\t\t       gen_int_mode (ml, compute_mode),\n+\t\t\t       NULL_RTX, 1, max_cost - extra_cost);\n \t\t\t    if (t2 == 0)\n \t\t\t      goto fail1;\n \t\t\t    quotient = expand_shift\n@@ -4274,9 +4278,9 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\textra_cost = (shift_cost (speed, compute_mode, post_shift)\n \t\t\t\t      + shift_cost (speed, compute_mode, size - 1)\n \t\t\t\t      + add_cost (speed, compute_mode));\n-\t\t\tt1 = expmed_mult_highpart (compute_mode, op0,\n-\t\t\t\t\t\t   GEN_INT (ml), NULL_RTX, 0,\n-\t\t\t\t\t\t   max_cost - extra_cost);\n+\t\t\tt1 = expmed_mult_highpart\n+\t\t\t  (compute_mode, op0, gen_int_mode (ml, compute_mode),\n+\t\t\t   NULL_RTX, 0, max_cost - extra_cost);\n \t\t\tif (t1 == 0)\n \t\t\t  goto fail1;\n \t\t\tt2 = expand_shift\n@@ -4368,9 +4372,12 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t    pre_shift = floor_log2 (d);\n \t\t    if (rem_flag)\n \t\t      {\n-\t\t\tremainder = expand_binop (compute_mode, and_optab, op0,\n-\t\t\t\t\t\t  GEN_INT (((HOST_WIDE_INT) 1 << pre_shift) - 1),\n-\t\t\t\t\t\t  remainder, 0, OPTAB_LIB_WIDEN);\n+\t\t\tunsigned HOST_WIDE_INT mask\n+\t\t\t  = ((unsigned HOST_WIDE_INT) 1 << pre_shift) - 1;\n+\t\t\tremainder = expand_binop\n+\t\t\t  (compute_mode, and_optab, op0,\n+\t\t\t   gen_int_mode (mask, compute_mode),\n+\t\t\t   remainder, 0, OPTAB_LIB_WIDEN);\n \t\t\tif (remainder)\n \t\t\t  return gen_lowpart (mode, remainder);\n \t\t      }\n@@ -4397,9 +4404,9 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\textra_cost = (shift_cost (speed, compute_mode, post_shift)\n \t\t\t\t      + shift_cost (speed, compute_mode, size - 1)\n \t\t\t\t      + 2 * add_cost (speed, compute_mode));\n-\t\t\tt3 = expmed_mult_highpart (compute_mode, t2,\n-\t\t\t\t\t\t   GEN_INT (ml), NULL_RTX, 1,\n-\t\t\t\t\t\t   max_cost - extra_cost);\n+\t\t\tt3 = expmed_mult_highpart\n+\t\t\t  (compute_mode, t2, gen_int_mode (ml, compute_mode),\n+\t\t\t   NULL_RTX, 1, max_cost - extra_cost);\n \t\t\tif (t3 != 0)\n \t\t\t  {\n \t\t\t    t4 = expand_shift\n@@ -4537,7 +4544,7 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\tt1 = expand_shift (RSHIFT_EXPR, compute_mode, op0,\n \t\t\t\t   floor_log2 (d), tquotient, 1);\n \t\tt2 = expand_binop (compute_mode, and_optab, op0,\n-\t\t\t\t   GEN_INT (d - 1),\n+\t\t\t\t   gen_int_mode (d - 1, compute_mode),\n \t\t\t\t   NULL_RTX, 1, OPTAB_LIB_WIDEN);\n \t\tt3 = gen_reg_rtx (compute_mode);\n \t\tt3 = emit_store_flag (t3, NE, t2, const0_rtx,\n@@ -4634,7 +4641,7 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\tt1 = expand_shift (RSHIFT_EXPR, compute_mode, op0,\n \t\t\t\t   floor_log2 (d), tquotient, 0);\n \t\tt2 = expand_binop (compute_mode, and_optab, op0,\n-\t\t\t\t   GEN_INT (d - 1),\n+\t\t\t\t   gen_int_mode (d - 1, compute_mode),\n \t\t\t\t   NULL_RTX, 1, OPTAB_LIB_WIDEN);\n \t\tt3 = gen_reg_rtx (compute_mode);\n \t\tt3 = emit_store_flag (t3, NE, t2, const0_rtx,\n@@ -5477,7 +5484,7 @@ emit_store_flag (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \t\t\t\t       STORE_FLAG_VALUE, target_mode);\n \t      if (tem)\n                 return expand_binop (target_mode, add_optab, tem,\n-\t\t\t\t     GEN_INT (normalizep),\n+\t\t\t\t     gen_int_mode (normalizep, target_mode),\n \t\t\t\t     target, 0, OPTAB_WIDEN);\n \t    }\n           else if (!want_add\n@@ -5581,7 +5588,8 @@ emit_store_flag (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \t\t\t\t   STORE_FLAG_VALUE, target_mode);\n \t  if (tem != 0)\n             tem = expand_binop (target_mode, add_optab, tem,\n-\t\t\t\tGEN_INT (normalizep), target, 0, OPTAB_WIDEN);\n+\t\t\t\tgen_int_mode (normalizep, target_mode),\n+\t\t\t\ttarget, 0, OPTAB_WIDEN);\n \t}\n       else if (!want_add\n \t       && rtx_cost (trueval, XOR, 1,"}, {"sha": "89bd49afefb134f42168b02998e90c63e1400a01", "filename": "gcc/expr.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f1cd2ebd65eae6d87332c0bcd5d0e840c886cf3/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f1cd2ebd65eae6d87332c0bcd5d0e840c886cf3/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=2f1cd2ebd65eae6d87332c0bcd5d0e840c886cf3", "patch": "@@ -3132,7 +3132,7 @@ emit_move_resolve_push (enum machine_mode mode, rtx x)\n   /* Do not use anti_adjust_stack, since we don't want to update\n      stack_pointer_delta.  */\n   temp = expand_simple_binop (Pmode, PLUS, stack_pointer_rtx,\n-\t\t\t      GEN_INT (adjust), stack_pointer_rtx,\n+\t\t\t      gen_int_mode (adjust, Pmode), stack_pointer_rtx,\n \t\t\t      0, OPTAB_LIB_WIDEN);\n   if (temp != stack_pointer_rtx)\n     emit_move_insn (stack_pointer_rtx, temp);\n@@ -3643,7 +3643,8 @@ push_block (rtx size, int extra, int below)\n     {\n       temp = copy_to_mode_reg (Pmode, size);\n       if (extra != 0)\n-\ttemp = expand_binop (Pmode, add_optab, temp, GEN_INT (extra),\n+\ttemp = expand_binop (Pmode, add_optab, temp,\n+\t\t\t     gen_int_mode (extra, Pmode),\n \t\t\t     temp, 0, OPTAB_LIB_WIDEN);\n       anti_adjust_stack (temp);\n     }\n@@ -3911,7 +3912,7 @@ emit_single_push_insn_1 (enum machine_mode mode, rtx x, tree type)\n \t\t\t\t    add_optab,\n #endif\n \t\t\t\t    stack_pointer_rtx,\n-\t\t\t\t    GEN_INT (rounded_size),\n+\t\t\t\t    gen_int_mode (rounded_size, Pmode),\n \t\t\t\t    NULL_RTX, 0, OPTAB_LIB_WIDEN));\n \n       offset = (HOST_WIDE_INT) padding_size;\n@@ -4127,8 +4128,8 @@ emit_push_insn (rtx x, enum machine_mode mode, tree type, rtx size,\n \t\tsize = GEN_INT (INTVAL (size) - used);\n \t      else\n \t\tsize = expand_binop (GET_MODE (size), sub_optab, size,\n-\t\t\t\t     GEN_INT (used), NULL_RTX, 0,\n-\t\t\t\t     OPTAB_LIB_WIDEN);\n+\t\t\t\t     gen_int_mode (used, GET_MODE (size)),\n+\t\t\t\t     NULL_RTX, 0, OPTAB_LIB_WIDEN);\n \t    }\n \n \t  /* Get the address of the stack space.\n@@ -4475,7 +4476,8 @@ optimize_bitfield_assignment_op (unsigned HOST_WIDE_INT bitsize,\n       binop = code == BIT_IOR_EXPR ? ior_optab : xor_optab;\n       if (bitpos + bitsize != str_bitsize)\n \t{\n-\t  rtx mask = GEN_INT (((unsigned HOST_WIDE_INT) 1 << bitsize) - 1);\n+\t  rtx mask = gen_int_mode (((unsigned HOST_WIDE_INT) 1 << bitsize) - 1,\n+\t\t\t\t   str_mode);\n \t  value = expand_and (str_mode, value, mask, NULL_RTX);\n \t}\n       value = expand_shift (LSHIFT_EXPR, str_mode, value, bitpos, NULL_RTX, 1);\n@@ -9857,7 +9859,8 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \n \t\t    if (TYPE_UNSIGNED (TREE_TYPE (field)))\n \t\t      {\n-\t\t\top1 = GEN_INT (((HOST_WIDE_INT) 1 << bitsize) - 1);\n+\t\t\top1 = gen_int_mode (((HOST_WIDE_INT) 1 << bitsize) - 1,\n+\t\t\t\t\t    imode);\n \t\t\top0 = expand_and (imode, op0, op1, target);\n \t\t      }\n \t\t    else"}, {"sha": "d6434e81e8ad07f0ad4d544f46581d6099953728", "filename": "gcc/function.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f1cd2ebd65eae6d87332c0bcd5d0e840c886cf3/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f1cd2ebd65eae6d87332c0bcd5d0e840c886cf3/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=2f1cd2ebd65eae6d87332c0bcd5d0e840c886cf3", "patch": "@@ -1544,9 +1544,10 @@ instantiate_virtual_regs_in_insn (rtx insn)\n \t{\n \t  start_sequence ();\n \n-\t  x = expand_simple_binop (GET_MODE (SET_DEST (set)), PLUS,\n-\t\t\t\t   new_rtx, GEN_INT (offset), SET_DEST (set),\n-\t\t\t\t   1, OPTAB_LIB_WIDEN);\n+\t  x = expand_simple_binop (GET_MODE (SET_DEST (set)), PLUS, new_rtx,\n+\t\t\t\t   gen_int_mode (offset,\n+\t\t\t\t\t\t GET_MODE (SET_DEST (set))),\n+\t\t\t\t   SET_DEST (set), 1, OPTAB_LIB_WIDEN);\n \t  if (x != SET_DEST (set))\n \t    emit_move_insn (SET_DEST (set), x);\n \n@@ -1666,8 +1667,8 @@ instantiate_virtual_regs_in_insn (rtx insn)\n \t\t to see if (plus new offset) is a valid before we put\n \t\t this through expand_simple_binop.  */\n \t      x = expand_simple_binop (GET_MODE (x), PLUS, new_rtx,\n-\t\t\t\t       GEN_INT (offset), NULL_RTX,\n-\t\t\t\t       1, OPTAB_LIB_WIDEN);\n+\t\t\t\t       gen_int_mode (offset, GET_MODE (x)),\n+\t\t\t\t       NULL_RTX, 1, OPTAB_LIB_WIDEN);\n \t      seq = get_insns ();\n \t      end_sequence ();\n \t      emit_insn_before (seq, insn);\n@@ -1681,9 +1682,10 @@ instantiate_virtual_regs_in_insn (rtx insn)\n \t  if (offset != 0)\n \t    {\n \t      start_sequence ();\n-\t      new_rtx = expand_simple_binop (GET_MODE (new_rtx), PLUS, new_rtx,\n-\t\t\t\t\t GEN_INT (offset), NULL_RTX,\n-\t\t\t\t\t 1, OPTAB_LIB_WIDEN);\n+\t      new_rtx = expand_simple_binop\n+\t\t(GET_MODE (new_rtx), PLUS, new_rtx,\n+\t\t gen_int_mode (offset, GET_MODE (new_rtx)),\n+\t\t NULL_RTX, 1, OPTAB_LIB_WIDEN);\n \t      seq = get_insns ();\n \t      end_sequence ();\n \t      emit_insn_before (seq, insn);"}, {"sha": "ebc4f1c3e54702f5dd4c4116d61623e35bd93ffd", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f1cd2ebd65eae6d87332c0bcd5d0e840c886cf3/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f1cd2ebd65eae6d87332c0bcd5d0e840c886cf3/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=2f1cd2ebd65eae6d87332c0bcd5d0e840c886cf3", "patch": "@@ -1162,8 +1162,8 @@ noce_try_store_flag_constants (struct noce_if_info *if_info)\n \t  target = expand_simple_binop (mode,\n \t\t\t\t\t(diff == STORE_FLAG_VALUE\n \t\t\t\t\t ? PLUS : MINUS),\n-\t\t\t\t\tGEN_INT (ifalse), target, if_info->x, 0,\n-\t\t\t\t\tOPTAB_WIDEN);\n+\t\t\t\t\tgen_int_mode (ifalse, mode), target,\n+\t\t\t\t\tif_info->x, 0, OPTAB_WIDEN);\n \t}\n \n       /* if (test) x = 8; else x = 0;\n@@ -1180,20 +1180,20 @@ noce_try_store_flag_constants (struct noce_if_info *if_info)\n       else if (itrue == -1)\n \t{\n \t  target = expand_simple_binop (mode, IOR,\n-\t\t\t\t\ttarget, GEN_INT (ifalse), if_info->x, 0,\n-\t\t\t\t\tOPTAB_WIDEN);\n+\t\t\t\t\ttarget, gen_int_mode (ifalse, mode),\n+\t\t\t\t\tif_info->x, 0, OPTAB_WIDEN);\n \t}\n \n       /* if (test) x = a; else x = b;\n \t =>   x = (-(test != 0) & (b - a)) + a;  */\n       else\n \t{\n \t  target = expand_simple_binop (mode, AND,\n-\t\t\t\t\ttarget, GEN_INT (diff), if_info->x, 0,\n-\t\t\t\t\tOPTAB_WIDEN);\n+\t\t\t\t\ttarget, gen_int_mode (diff, mode),\n+\t\t\t\t\tif_info->x, 0, OPTAB_WIDEN);\n \t  if (target)\n \t    target = expand_simple_binop (mode, PLUS,\n-\t\t\t\t\t  target, GEN_INT (ifalse),\n+\t\t\t\t\t  target, gen_int_mode (ifalse, mode),\n \t\t\t\t\t  if_info->x, 0, OPTAB_WIDEN);\n \t}\n "}, {"sha": "84902bfe5dd8410c7a36e0c8a9a7721d54e60300", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f1cd2ebd65eae6d87332c0bcd5d0e840c886cf3/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f1cd2ebd65eae6d87332c0bcd5d0e840c886cf3/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=2f1cd2ebd65eae6d87332c0bcd5d0e840c886cf3", "patch": "@@ -1166,8 +1166,7 @@ unroll_loop_runtime_iterations (struct loop *loop)\n      the number of unrollings is a power of two, and thus this is correct\n      even if there is overflow in the computation.  */\n   niter = expand_simple_binop (desc->mode, AND,\n-\t\t\t       niter,\n-\t\t\t       GEN_INT (max_unroll),\n+\t\t\t       niter, gen_int_mode (max_unroll, desc->mode),\n \t\t\t       NULL_RTX, 0, OPTAB_LIB_WIDEN);\n \n   init_code = get_insns ();"}, {"sha": "3ad2ec77f1e5bb96c484545411ba1476296c3a94", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f1cd2ebd65eae6d87332c0bcd5d0e840c886cf3/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f1cd2ebd65eae6d87332c0bcd5d0e840c886cf3/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=2f1cd2ebd65eae6d87332c0bcd5d0e840c886cf3", "patch": "@@ -1148,8 +1148,9 @@ generate_prolog_epilog (partial_schedule_ptr ps, struct loop *loop,\n          generate_prolog_epilog function.  */\n       rtx sub_reg = NULL_RTX;\n \n-      sub_reg = expand_simple_binop (GET_MODE (count_reg), MINUS,\n-                                     count_reg, GEN_INT (last_stage),\n+      sub_reg = expand_simple_binop (GET_MODE (count_reg), MINUS, count_reg,\n+\t\t\t\t     gen_int_mode (last_stage,\n+\t\t\t\t\t\t   GET_MODE (count_reg)),\n                                      count_reg, 1, OPTAB_DIRECT);\n       gcc_assert (REG_P (sub_reg));\n       if (REGNO (sub_reg) != REGNO (count_reg))"}, {"sha": "1d0659e1361bca12d94cb6df3c17f97c65b6afbc", "filename": "gcc/optabs.c", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f1cd2ebd65eae6d87332c0bcd5d0e840c886cf3/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f1cd2ebd65eae6d87332c0bcd5d0e840c886cf3/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=2f1cd2ebd65eae6d87332c0bcd5d0e840c886cf3", "patch": "@@ -1563,7 +1563,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n         newop1 = negate_rtx (GET_MODE (op1), op1);\n       else\n         newop1 = expand_binop (GET_MODE (op1), sub_optab,\n-\t\t\t       GEN_INT (bits), op1,\n+\t\t\t       gen_int_mode (bits, GET_MODE (op1)), op1,\n \t\t\t       NULL_RTX, unsignedp, OPTAB_DIRECT);\n \n       temp = expand_binop_directly (mode, otheroptab, op0, newop1,\n@@ -2539,10 +2539,12 @@ widen_leading (enum machine_mode mode, rtx op0, rtx target, optab unoptab)\n \t      temp = expand_unop (wider_mode, unoptab, xop0, NULL_RTX,\n \t\t\t\t  unoptab != clrsb_optab);\n \t      if (temp != 0)\n-\t\ttemp = expand_binop (wider_mode, sub_optab, temp,\n-\t\t\t\t     GEN_INT (GET_MODE_PRECISION (wider_mode)\n-\t\t\t\t\t      - GET_MODE_PRECISION (mode)),\n-\t\t\t\t     target, true, OPTAB_DIRECT);\n+\t\ttemp = expand_binop\n+\t\t  (wider_mode, sub_optab, temp,\n+\t\t   gen_int_mode (GET_MODE_PRECISION (wider_mode)\n+\t\t\t\t - GET_MODE_PRECISION (mode),\n+\t\t\t\t wider_mode),\n+\t\t   target, true, OPTAB_DIRECT);\n \t      if (temp == 0)\n \t\tdelete_insns_since (last);\n \n@@ -2601,7 +2603,7 @@ expand_doubleword_clz (enum machine_mode mode, rtx op0, rtx target)\n   if (!temp)\n     goto fail;\n   temp = expand_binop (word_mode, add_optab, temp,\n-\t\t       GEN_INT (GET_MODE_BITSIZE (word_mode)),\n+\t\t       gen_int_mode (GET_MODE_BITSIZE (word_mode), word_mode),\n \t\t       result, true, OPTAB_DIRECT);\n   if (!temp)\n     goto fail;\n@@ -2757,7 +2759,8 @@ expand_ctz (enum machine_mode mode, rtx op0, rtx target)\n   if (temp)\n     temp = expand_unop_direct (mode, clz_optab, temp, NULL_RTX, true);\n   if (temp)\n-    temp = expand_binop (mode, sub_optab, GEN_INT (GET_MODE_PRECISION (mode) - 1),\n+    temp = expand_binop (mode, sub_optab,\n+\t\t\t gen_int_mode (GET_MODE_PRECISION (mode) - 1, mode),\n \t\t\t temp, target,\n \t\t\t true, OPTAB_DIRECT);\n   if (temp == 0)\n@@ -2838,7 +2841,7 @@ expand_ffs (enum machine_mode mode, rtx op0, rtx target)\n \n   /* temp now has a value in the range -1..bitsize-1.  ffs is supposed\n      to produce a value in the range 0..bitsize.  */\n-  temp = expand_binop (mode, add_optab, temp, GEN_INT (1),\n+  temp = expand_binop (mode, add_optab, temp, gen_int_mode (1, mode),\n \t\t       target, false, OPTAB_DIRECT);\n   if (!temp)\n     goto fail;\n@@ -3308,10 +3311,12 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n \t\t result.  Similarly for clrsb.  */\n \t      if ((unoptab == clz_optab || unoptab == clrsb_optab)\n \t\t  && temp != 0)\n-\t\ttemp = expand_binop (wider_mode, sub_optab, temp,\n-\t\t\t\t     GEN_INT (GET_MODE_PRECISION (wider_mode)\n-\t\t\t\t\t      - GET_MODE_PRECISION (mode)),\n-\t\t\t\t     target, true, OPTAB_DIRECT);\n+\t\ttemp = expand_binop\n+\t\t  (wider_mode, sub_optab, temp,\n+\t\t   gen_int_mode (GET_MODE_PRECISION (wider_mode)\n+\t\t\t\t - GET_MODE_PRECISION (mode),\n+\t\t\t\t wider_mode),\n+\t\t   target, true, OPTAB_DIRECT);\n \n \t      /* Likewise for bswap.  */\n \t      if (unoptab == bswap_optab && temp != 0)"}]}