{"sha": "c7e266a6b735aed2fb29ae3bca4732cb7827ddcd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzdlMjY2YTZiNzM1YWVkMmZiMjlhZTNiY2E0NzMyY2I3ODI3ZGRjZA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-02-22T02:30:54Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-02-22T02:30:54Z"}, "message": "cp-tree.h (CPTI_VTABLE_INDEX_TYPE): New macro.\n\n\t* cp-tree.h (CPTI_VTABLE_INDEX_TYPE): New macro.\n\t(CPTI_CLASS_STAR_TYPE): Remove.\n\t(vtable_index_type): Likewise.\n\t(class_star_type_node): Remove.\n\t(TYPE_PTRMEMFUNC_FN_TYPE): Adjust for the new ABI.\n\t(build_binary_op_nodefault): Remove.\n\t* call.c (build_new_op): Use build_binary_op instead of\n\tbuild_binary_op_nodefault.\n\t* decl.c (init_decl_processing): Remove class_star_type_node\n\tinitialization.  Make delta_type_node ptrdiff_type_node under the\n\tnew ABI.  Initialize vtable_index_type.\n\t(build_ptrmemfunc_type): Build different structures for the new\n\tABI.\n\t(build_enumerator): Use build_binary_op instead of\n\tbuild_binary_op_nodefault.\n\t* method.c (build_overload_value): Mangle pointers-to-members\n\tappropriately under the new ABI.\n\t* typeck.c (build_array_ref): Use build_binary_op instead of\n\tbuild_binary_op_nodefault.\n\t(get_member_function_from_ptrfunc): Adjust for the new ABI.\n\t(build_binary_op_nodefault): Rename to ...\n\t(build_binary_op): ... this.  Remove old version.  Adjust for\n\tpointer-to-member comparisons under the new ABI.\n\t(build_ptrmemfunc1): Remove dead code.  Adjust for the new ABI.\n\t(build_ptrmemfunc): Adjust for the new ABI.\n\t(expand_ptrmemfunc_cst): Likewise.\n\t(delta2_from_ptrmemfunc): Assert that we're not using the new ABI.\n\t(pfn_from_ptrmemfunc): Adjust for the new ABI.\n\nFrom-SVN: r32099", "tree": {"sha": "073086885a3ae8578816a0593fad162674b1d76d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/073086885a3ae8578816a0593fad162674b1d76d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7e266a6b735aed2fb29ae3bca4732cb7827ddcd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7e266a6b735aed2fb29ae3bca4732cb7827ddcd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7e266a6b735aed2fb29ae3bca4732cb7827ddcd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7e266a6b735aed2fb29ae3bca4732cb7827ddcd/comments", "author": null, "committer": null, "parents": [{"sha": "2323b28bb68dd20e76ef263b72a485660a69102b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2323b28bb68dd20e76ef263b72a485660a69102b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2323b28bb68dd20e76ef263b72a485660a69102b"}], "stats": {"total": 567, "additions": 345, "deletions": 222}, "files": [{"sha": "346123d7de8488864d899bd6e0a267ae51cc6a36", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7e266a6b735aed2fb29ae3bca4732cb7827ddcd/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7e266a6b735aed2fb29ae3bca4732cb7827ddcd/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c7e266a6b735aed2fb29ae3bca4732cb7827ddcd", "patch": "@@ -1,3 +1,34 @@\n+2000-02-21  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (CPTI_VTABLE_INDEX_TYPE): New macro.\n+\t(CPTI_CLASS_STAR_TYPE): Remove.\n+\t(vtable_index_type): Likewise.\n+\t(class_star_type_node): Remove.\n+\t(TYPE_PTRMEMFUNC_FN_TYPE): Adjust for the new ABI.\n+\t(build_binary_op_nodefault): Remove.\n+\t* call.c (build_new_op): Use build_binary_op instead of\n+\tbuild_binary_op_nodefault.\n+\t* decl.c (init_decl_processing): Remove class_star_type_node\n+\tinitialization.  Make delta_type_node ptrdiff_type_node under the\n+\tnew ABI.  Initialize vtable_index_type.\n+\t(build_ptrmemfunc_type): Build different structures for the new\n+\tABI.\n+\t(build_enumerator): Use build_binary_op instead of\n+\tbuild_binary_op_nodefault.\n+\t* method.c (build_overload_value): Mangle pointers-to-members\n+\tappropriately under the new ABI.\n+\t* typeck.c (build_array_ref): Use build_binary_op instead of\n+\tbuild_binary_op_nodefault.\n+\t(get_member_function_from_ptrfunc): Adjust for the new ABI.\n+\t(build_binary_op_nodefault): Rename to ...\n+\t(build_binary_op): ... this.  Remove old version.  Adjust for\n+\tpointer-to-member comparisons under the new ABI.\n+\t(build_ptrmemfunc1): Remove dead code.  Adjust for the new ABI.\n+\t(build_ptrmemfunc): Adjust for the new ABI.\n+\t(expand_ptrmemfunc_cst): Likewise.\n+\t(delta2_from_ptrmemfunc): Assert that we're not using the new ABI.\n+\t(pfn_from_ptrmemfunc): Adjust for the new ABI.\n+\t\n 2000-02-21  Gabriel Dos Reis  <gdr@codesourcery.com>\n \n \t* call.c (build_object_call): Compress consecutive calls to"}, {"sha": "887e2dfd4cb32b0372e0b61c89cb31872707c0fe", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7e266a6b735aed2fb29ae3bca4732cb7827ddcd/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7e266a6b735aed2fb29ae3bca4732cb7827ddcd/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=c7e266a6b735aed2fb29ae3bca4732cb7827ddcd", "patch": "@@ -3407,7 +3407,7 @@ build_new_op (code, flags, arg1, arg2, arg3)\n     case BIT_XOR_EXPR:\n     case TRUTH_ANDIF_EXPR:\n     case TRUTH_ORIF_EXPR:\n-      return build_binary_op_nodefault (code, arg1, arg2, code);\n+      return build_binary_op (code, arg1, arg2);\n \n     case CONVERT_EXPR:\n     case NEGATE_EXPR:"}, {"sha": "5337ed3dc08c43e245902f2951b20362e34e47a7", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7e266a6b735aed2fb29ae3bca4732cb7827ddcd/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7e266a6b735aed2fb29ae3bca4732cb7827ddcd/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=c7e266a6b735aed2fb29ae3bca4732cb7827ddcd", "patch": "@@ -517,6 +517,7 @@ enum cp_tree_index\n     CPTI_WCHAR_DECL,\n     CPTI_VTABLE_ENTRY_TYPE,\n     CPTI_DELTA_TYPE,\n+    CPTI_VTABLE_INDEX_TYPE,\n     CPTI_CLEANUP_TYPE,\n \n     CPTI_TI_DESC_TYPE,\n@@ -532,7 +533,6 @@ enum cp_tree_index\n     CPTI_PTMD_DESC_TYPE,\n     CPTI_BASE_DESC_TYPE,\n     \n-    CPTI_CLASS_STAR_TYPE,\n     CPTI_CLASS_TYPE,\n     CPTI_RECORD_TYPE,\n     CPTI_UNION_TYPE,\n@@ -601,7 +601,12 @@ extern tree cp_global_trees[CPTI_MAX];\n #define void_zero_node\t\t\tcp_global_trees[CPTI_VOID_ZERO]\n #define wchar_decl_node\t\t\tcp_global_trees[CPTI_WCHAR_DECL]\n #define vtable_entry_type\t\tcp_global_trees[CPTI_VTABLE_ENTRY_TYPE]\n+/* The type used to represent an offset by which to adjust the `this'\n+   pointer in pointer-to-member types and, when not using vtable\n+   thunks, in vtables.  */\n #define delta_type_node\t\t\tcp_global_trees[CPTI_DELTA_TYPE]\n+/* The type used to represent an index into the vtable.  */\n+#define vtable_index_type               cp_global_trees[CPTI_VTABLE_INDEX_TYPE]\n \n #define ti_desc_type_node\t\tcp_global_trees[CPTI_TI_DESC_TYPE]\n #define bltn_desc_type_node\t\tcp_global_trees[CPTI_BLTN_DESC_TYPE]\n@@ -616,7 +621,6 @@ extern tree cp_global_trees[CPTI_MAX];\n #define ptmd_desc_type_node\t\tcp_global_trees[CPTI_PTMD_DESC_TYPE]\n #define base_desc_type_node\t\tcp_global_trees[CPTI_BASE_DESC_TYPE]\n \n-#define class_star_type_node\t\tcp_global_trees[CPTI_CLASS_STAR_TYPE]\n #define class_type_node\t\t\tcp_global_trees[CPTI_CLASS_TYPE]\n #define record_type_node\t\tcp_global_trees[CPTI_RECORD_TYPE]\n #define union_type_node\t\t\tcp_global_trees[CPTI_UNION_TYPE]\n@@ -2498,12 +2502,27 @@ extern int flag_new_for_scope;\n    function.\n \n    (Of course, the exact values may differ depending on the mangling\n-   scheme, sizes of types, and such.).  */\n+   scheme, sizes of types, and such.).  \n+\n+   Under the new ABI, we do:\n+\n+     struct {\n+       __P __pfn;\n+       ptrdiff_t __delta;\n+     };\n+\n+   (We don't need DELTA2, because the vtable is always the first thing\n+   in the object.)  If the function is virtual, then PFN is one plus\n+   twice the index into the vtable; otherwise, it is just a pointer to\n+   the function.  */\n      \n /* Get the POINTER_TYPE to the METHOD_TYPE associated with this\n    pointer to member function.  TYPE_PTRMEMFUNC_P _must_ be true,\n    before using this macro.  */\n-#define TYPE_PTRMEMFUNC_FN_TYPE(NODE) (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (TREE_CHAIN (TREE_CHAIN (TYPE_FIELDS (NODE)))))))\n+#define TYPE_PTRMEMFUNC_FN_TYPE(NODE) \\\n+  (flag_new_abi                       \\\n+   ? (TREE_TYPE (TYPE_FIELDS (NODE))) \\\n+   : (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (TREE_CHAIN (TREE_CHAIN (TYPE_FIELDS (NODE))))))))\n \n /* Returns `A' for a type like `int (A::*)(double)' */\n #define TYPE_PTRMEMFUNC_OBJECT_TYPE(NODE) \\\n@@ -4341,7 +4360,6 @@ extern tree build_function_call_maybe\t\tPARAMS ((tree, tree));\n extern tree convert_arguments\t\t\tPARAMS ((tree, tree, tree, int));\n extern tree build_x_binary_op\t\t\tPARAMS ((enum tree_code, tree, tree));\n extern tree build_binary_op\t\t\tPARAMS ((enum tree_code, tree, tree));\n-extern tree build_binary_op_nodefault\t\tPARAMS ((enum tree_code, tree, tree, enum tree_code));\n extern tree build_x_unary_op\t\t\tPARAMS ((enum tree_code, tree));\n extern tree build_unary_op\t\t\tPARAMS ((enum tree_code, tree, int));\n extern tree unary_complex_lvalue\t\tPARAMS ((enum tree_code, tree));"}, {"sha": "cb9ec294ce178072c11bd70a43090dba2f7a7998", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 35, "deletions": 25, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7e266a6b735aed2fb29ae3bca4732cb7827ddcd/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7e266a6b735aed2fb29ae3bca4732cb7827ddcd/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=c7e266a6b735aed2fb29ae3bca4732cb7827ddcd", "patch": "@@ -222,7 +222,6 @@ tree error_mark_list;\n \ttree __ptmf_desc_array_type, __ptmd_desc_array_type;\n #endif\n \n-\ttree class_star_type_node;\n \ttree class_type_node, record_type_node, union_type_node, enum_type_node;\n \ttree unknown_type_node;\n \n@@ -6207,15 +6206,18 @@ init_decl_processing ()\n   int_array_type_node\n     = build_array_type (integer_type_node, array_domain_type);\n \n-  /* This is just some anonymous class type.  Nobody should ever\n-     need to look inside this envelope.  */\n-  class_star_type_node = build_pointer_type (make_aggr_type (RECORD_TYPE));\n-\n-  if (flag_huge_objects)\n+  if (flag_new_abi)\n+    delta_type_node = ptrdiff_type_node;\n+  else if (flag_huge_objects)\n     delta_type_node = long_integer_type_node;\n   else\n     delta_type_node = short_integer_type_node;\n \n+  if (flag_new_abi)\n+    vtable_index_type = ptrdiff_type_node;\n+  else\n+    vtable_index_type = delta_type_node;\n+\n   default_function_type\n     = build_function_type (integer_type_node, NULL_TREE);\n \n@@ -8804,27 +8806,36 @@ build_ptrmemfunc_type (type)\n     unqualified_variant\n       = build_ptrmemfunc_type (TYPE_MAIN_VARIANT (type));\n \n-  u = make_aggr_type (UNION_TYPE);\n-  SET_IS_AGGR_TYPE (u, 0);\n-  fields[0] = build_lang_decl (FIELD_DECL, pfn_identifier, type);\n-  fields[1] = build_lang_decl (FIELD_DECL, delta2_identifier,\n-\t\t\t       delta_type_node);\n-  finish_builtin_type (u, \"__ptrmemfunc_type\", fields, 1, ptr_type_node);\n-  TYPE_NAME (u) = NULL_TREE;\n-\n   t = make_aggr_type (RECORD_TYPE);\n-\n   /* Let the front-end know this is a pointer to member function...  */\n   TYPE_PTRMEMFUNC_FLAG (t) = 1;\n   /* ... and not really an aggregate.  */\n   SET_IS_AGGR_TYPE (t, 0);\n \n-  fields[0] = build_lang_decl (FIELD_DECL, delta_identifier,\n-\t\t\t       delta_type_node);\n-  fields[1] = build_lang_decl (FIELD_DECL, index_identifier,\n-\t\t\t       delta_type_node);\n-  fields[2] = build_lang_decl (FIELD_DECL, pfn_or_delta2_identifier, u);\n-  finish_builtin_type (t, \"__ptrmemfunc_type\", fields, 2, ptr_type_node);\n+  if (!flag_new_abi)\n+    {\n+      u = make_aggr_type (UNION_TYPE);\n+      SET_IS_AGGR_TYPE (u, 0);\n+      fields[0] = build_lang_decl (FIELD_DECL, pfn_identifier, type);\n+      fields[1] = build_lang_decl (FIELD_DECL, delta2_identifier,\n+\t\t\t\t   delta_type_node);\n+      finish_builtin_type (u, \"__ptrmemfunc_type\", fields, 1, ptr_type_node);\n+      TYPE_NAME (u) = NULL_TREE;\n+\n+      fields[0] = build_lang_decl (FIELD_DECL, delta_identifier,\n+\t\t\t\t   delta_type_node);\n+      fields[1] = build_lang_decl (FIELD_DECL, index_identifier,\n+\t\t\t\t   delta_type_node);\n+      fields[2] = build_lang_decl (FIELD_DECL, pfn_or_delta2_identifier, u);\n+      finish_builtin_type (t, \"__ptrmemfunc_type\", fields, 2, ptr_type_node);\n+    }\n+  else\n+    {\n+      fields[0] = build_lang_decl (FIELD_DECL, pfn_identifier, type);\n+      fields[1] = build_lang_decl (FIELD_DECL, delta_identifier,\n+\t\t\t\t   delta_type_node);\n+      finish_builtin_type (t, \"__ptrmemfunc_type\", fields, 1, ptr_type_node);\n+    }\n \n   /* Zap out the name so that the back-end will give us the debugging\n      information for this anonymous RECORD_TYPE.  */\n@@ -12777,10 +12788,9 @@ build_enumerator (name, value, enumtype)\n \t      /* The next value is the previous value ... */\n \t      prev_value = DECL_INITIAL (TREE_VALUE (TYPE_VALUES (enumtype)));\n \t      /* ... plus one.  */\n-\t      value = build_binary_op_nodefault (PLUS_EXPR,\n-\t\t\t\t\t\t prev_value,\n-\t\t\t\t\t\t integer_one_node,\n-\t\t\t\t\t\t PLUS_EXPR);\n+\t      value = build_binary_op (PLUS_EXPR,\n+\t\t\t\t       prev_value,\n+\t\t\t\t       integer_one_node);\n \n \t      if (tree_int_cst_lt (value, prev_value))\n \t\tcp_error (\"overflow in enumeration values at `%D'\", name);"}, {"sha": "6a12868d989e17e332ac6b3b6e1ffc91fa5189db", "filename": "gcc/cp/method.c", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7e266a6b735aed2fb29ae3bca4732cb7827ddcd/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7e266a6b735aed2fb29ae3bca4732cb7827ddcd/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=c7e266a6b735aed2fb29ae3bca4732cb7827ddcd", "patch": "@@ -851,6 +851,7 @@ build_overload_value (type, value, flags)\n \ttree idx;\n \ttree pfn;\n \ttree delta2;\n+\ttree fn;\n \n \tmy_friendly_assert (TYPE_PTRMEMFUNC_P (type), 0);\n \n@@ -872,17 +873,26 @@ build_overload_value (type, value, flags)\n \tmy_friendly_assert (TREE_CODE (value) == PTRMEM_CST, 0);\n \n \texpand_ptrmemfunc_cst (value, &delta, &idx, &pfn, &delta2);\n+\tfn = PTRMEM_CST_MEMBER (value);\n \tbuild_overload_int (delta, flags);\n \tOB_PUTC ('_');\n-\tbuild_overload_int (idx, flags);\n-\tOB_PUTC ('_');\n-\tif (pfn)\n+\tif (!flag_new_abi)\n+\t  {\n+\t    build_overload_int (idx, flags);\n+\t    OB_PUTC ('_');\n+\t  }\n+\telse if (DECL_VIRTUAL_P (fn))\n+\t  {\n+\t    build_overload_int (DECL_VINDEX (fn), flags);\n+\t    OB_PUTC ('_');\n+\t  }\n+\n+\tif (!DECL_VIRTUAL_P (fn))\n \t  {\n \t    numeric_output_need_bar = 0;\n-\t    build_overload_identifier (DECL_ASSEMBLER_NAME\n-\t\t\t\t       (PTRMEM_CST_MEMBER (value)));\n+\t    build_overload_identifier (DECL_ASSEMBLER_NAME (fn));\n \t  }\n-\telse\n+\telse if (!flag_new_abi)\n \t  {\n \t    OB_PUTC ('i');\n \t    build_overload_int (delta2, flags);"}, {"sha": "346eb83312305074d7090585396eccce4237fecc", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 239, "deletions": 185, "changes": 424, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7e266a6b735aed2fb29ae3bca4732cb7827ddcd/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7e266a6b735aed2fb29ae3bca4732cb7827ddcd/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=c7e266a6b735aed2fb29ae3bca4732cb7827ddcd", "patch": "@@ -2509,8 +2509,7 @@ build_array_ref (array, idx)\n \treturn error_mark_node;\n       }\n \n-    return build_indirect_ref (build_binary_op_nodefault (PLUS_EXPR, ar,\n-\t\t\t\t\t\t\t  ind, PLUS_EXPR),\n+    return build_indirect_ref (build_binary_op (PLUS_EXPR, ar, ind),\n \t\t\t       \"array indexing\");\n   }\n }\n@@ -2836,9 +2835,11 @@ get_member_function_from_ptrfunc (instance_ptrptr, function)\n       fntype = TYPE_PTRMEMFUNC_FN_TYPE (TREE_TYPE (function));\n       basetype = TYPE_METHOD_BASETYPE (TREE_TYPE (fntype));\n \n-      delta = cp_convert (ptrdiff_type_node,\n-\t\t\t  build_component_ref (function, delta_identifier,\n-\t\t\t\t\t       NULL_TREE, 0));\n+      /* Convert down to the right base, before using the instance.  */\n+      instance = convert_pointer_to_real (basetype, instance_ptr);\n+      if (instance == error_mark_node && instance_ptr != error_mark_node)\n+\treturn instance;\n+\n       e3 = PFN_FROM_PTRMEMFUNC (function);\n \n       /* This used to avoid checking for virtual functions if basetype\n@@ -2853,27 +2854,42 @@ get_member_function_from_ptrfunc (instance_ptrptr, function)\n \t load-with-sign-extend, while the second used normal load then\n \t shift to sign-extend.  An optimizer flaw, perhaps, but it's\n \t easier to make this change.  */\n-      idx = save_expr (default_conversion\n+      if (flag_new_abi)\n+\t{\n+\t  idx = build_binary_op (TRUNC_DIV_EXPR, \n+\t\t\t\t build1 (NOP_EXPR, vtable_index_type, e3),\n+\t\t\t\t integer_two_node);\n+\t  e1 = build_binary_op (BIT_AND_EXPR,\n+\t\t\t\tbuild1 (NOP_EXPR, vtable_index_type, e3),\n+\t\t\t\tinteger_one_node);\n+\t}\n+      else\n+\t{\n+\t  idx = save_expr (default_conversion\n \t\t       (build_component_ref (function,\n \t\t\t\t\t     index_identifier,\n \t\t\t\t\t     NULL_TREE, 0)));\n-      e1 = build_binary_op (GE_EXPR, idx, integer_zero_node);\n-\n-      /* Convert down to the right base, before using the instance.  */\n-      instance = convert_pointer_to_real (basetype, instance_ptr);\n-      if (instance == error_mark_node && instance_ptr != error_mark_node)\n-\treturn instance;\n+\t  e1 = build_binary_op (GE_EXPR, idx, integer_zero_node);\n+\t  idx = build_binary_op (MINUS_EXPR, idx, integer_one_node);\n+\t}\n \n       vtbl = convert_pointer_to (ptr_type_node, instance);\n-      delta2 = DELTA2_FROM_PTRMEMFUNC (function);\n+      delta = cp_convert (ptrdiff_type_node,\n+\t\t\t  build_component_ref (function, delta_identifier,\n+\t\t\t\t\t       NULL_TREE, 0));\n+      if (flag_new_abi)\n+\t/* DELTA2 is the amount by which to adjust the `this' pointer\n+\t   to find the vtbl.  */\n+\tdelta2 = delta;\n+      else\n+\tdelta2 = DELTA2_FROM_PTRMEMFUNC (function);\n       vtbl = build\n \t(PLUS_EXPR,\n \t build_pointer_type (build_pointer_type (vtable_entry_type)),\n \t vtbl, cp_convert (ptrdiff_type_node, delta2));\n       vtbl = build_indirect_ref (vtbl, NULL_PTR);\n-      aref = build_array_ref (vtbl, build_binary_op (MINUS_EXPR,\n-\t\t\t\t\t\t     idx,\n-\t\t\t\t\t\t     integer_one_node));\n+      aref = build_array_ref (vtbl, idx);\n+\n       if (! flag_vtable_thunks)\n \t{\n \t  aref = save_expr (aref);\n@@ -3237,14 +3253,6 @@ build_x_binary_op (code, arg1, arg2)\n   return build_new_op (code, LOOKUP_NORMAL, arg1, arg2, NULL_TREE);\n }\n \n-tree\n-build_binary_op (code, arg1, arg2)\n-     enum tree_code code;\n-     tree arg1, arg2;\n-{\n-  return build_binary_op_nodefault (code, arg1, arg2, code);\n-}\n-\n /* Build a binary-operation expression without default conversions.\n    CODE is the kind of expression to build.\n    This function differs from `build' in several ways:\n@@ -3255,9 +3263,6 @@ build_binary_op (code, arg1, arg2)\n    are done in the narrower type when that gives the same result).\n    Constant folding is also done before the result is returned.\n \n-   ERROR_CODE is the code that determines what to say in error messages.\n-   It is usually, but not always, the same as CODE.\n-\n    Note that the operands will never have enumeral types\n    because either they have just had the default conversions performed\n    or they have both just been converted to some other type in which\n@@ -3267,10 +3272,9 @@ build_binary_op (code, arg1, arg2)\n    multiple inheritance, and deal with pointer to member functions.  */\n \n tree\n-build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n+build_binary_op (code, orig_op0, orig_op1)\n      enum tree_code code;\n      tree orig_op0, orig_op1;\n-     enum tree_code error_code;\n {\n   tree op0, op1;\n   register enum tree_code code0, code1;\n@@ -3626,102 +3630,98 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t}\n       else if (TYPE_PTRMEMFUNC_P (type0) && null_ptr_cst_p (op1))\n \t{\n-\t  op0 = build_component_ref (op0, index_identifier, NULL_TREE, 0);\n-\t  op1 = integer_zero_node;\n+\t  if (flag_new_abi)\n+\t    {\n+\t      op0 = build_component_ref (op0, pfn_identifier, NULL_TREE, 0);\n+\t      op1 = cp_convert (TREE_TYPE (op0), integer_zero_node);\n+\t    }\n+\t  else\n+\t    {\n+\t      op0 = build_component_ref (op0, index_identifier, NULL_TREE, 0);\n+\t      op1 = integer_zero_node;\n+\t    }\n \t  result_type = TREE_TYPE (op0);\n \t}\n       else if (TYPE_PTRMEMFUNC_P (type1) && null_ptr_cst_p (op0))\n-\t{\n-\t  op0 = build_component_ref (op1, index_identifier, NULL_TREE, 0);\n-\t  op1 = integer_zero_node;\n-\t  result_type = TREE_TYPE (op0);\n-\t}\n+\treturn build_binary_op (code, op1, op0);\n       else if (TYPE_PTRMEMFUNC_P (type0) && TYPE_PTRMEMFUNC_P (type1)\n \t       && same_type_p (type0, type1))\n \t{\n-\t  /* The code we generate for the test is:\n-\n-\t  (op0.index == op1.index\n-\t   && ((op1.index != -1 && op0.delta2 == op1.delta2)\n-\t       || op0.pfn == op1.pfn)) */\n-\n-\t  tree index0 = build_component_ref (op0, index_identifier,\n-\t\t\t\t\t     NULL_TREE, 0);\n-\t  tree index1 = save_expr (build_component_ref (op1, index_identifier,\n-\t\t\t\t\t\t\tNULL_TREE, 0));\n-\t  tree pfn0 = PFN_FROM_PTRMEMFUNC (op0);\n-\t  tree pfn1 = PFN_FROM_PTRMEMFUNC (op1);\n-\t  tree delta20 = DELTA2_FROM_PTRMEMFUNC (op0);\n-\t  tree delta21 = DELTA2_FROM_PTRMEMFUNC (op1);\n-\t  tree e1, e2, e3;\n-\t  tree integer_neg_one_node\n-\t    = build_binary_op (MINUS_EXPR, integer_zero_node,\n-\t\t\t       integer_one_node);\n-\t  e1 = build_binary_op (EQ_EXPR, index0, index1);\n-\t  e2 = build_binary_op (NE_EXPR, index1, integer_neg_one_node);\n-\t  e2 = build_binary_op (TRUTH_ANDIF_EXPR, e2,\n-\t\t\t\tbuild_binary_op (EQ_EXPR, delta20, delta21));\n-\t  /* We can't use build_binary_op for this cmp because it would get\n-\t     confused by the ptr to method types and think we want pmfs.  */\n-\t  e3 = build (EQ_EXPR, boolean_type_node, pfn0, pfn1);\n-\t  e2 = build_binary_op (TRUTH_ORIF_EXPR, e2, e3);\n-\t  e2 = build_binary_op (TRUTH_ANDIF_EXPR, e1, e2);\n-\t  if (code == EQ_EXPR)\n-\t    return e2;\n-\t  return build_binary_op (EQ_EXPR, e2, integer_zero_node);\n-\t}\n-      else if (TYPE_PTRMEMFUNC_P (type0)\n-\t       && same_type_p (TYPE_PTRMEMFUNC_FN_TYPE (type0), type1))\n-\t{\n-\t  tree index0 = build_component_ref (op0, index_identifier,\n-\t\t\t\t\t     NULL_TREE, 0);\n-\t  tree index1;\n-\t  tree pfn0 = PFN_FROM_PTRMEMFUNC (op0);\n-\t  tree delta20 = DELTA2_FROM_PTRMEMFUNC (op0);\n-\t  tree delta21 = integer_zero_node;\n-\t  tree e1, e2, e3;\n-\t  tree integer_neg_one_node\n-\t    = build_binary_op (MINUS_EXPR, integer_zero_node, integer_one_node);\n-\t  if (TREE_CODE (TREE_OPERAND (op1, 0)) == FUNCTION_DECL\n-\t      && DECL_VINDEX (TREE_OPERAND (op1, 0)))\n+\t  /* E will be the final comparison.  */\n+\t  tree e;\n+\t  /* E1 and E2 are for scratch.  */\n+\t  tree e1;\n+\t  tree e2;\n+\n+\t  if (flag_new_abi)\n \t    {\n-\t      /* Map everything down one to make room for\n-\t\t the null pointer to member.  */\n-\t      index1 = size_binop (PLUS_EXPR,\n-\t\t\t\t   DECL_VINDEX (TREE_OPERAND (op1, 0)),\n-\t\t\t\t   integer_one_node);\n-\t      op1 = integer_zero_node;\n-\t      delta21 = TYPE_VFIELD (TYPE_METHOD_BASETYPE\n-\t\t\t\t     (TREE_TYPE (type1)));\n-\t      delta21 = DECL_FIELD_BITPOS (delta21);\n-\t      delta21 = size_binop (FLOOR_DIV_EXPR, delta21,\n-\t\t\t\t    size_int (BITS_PER_UNIT));\n-\t      delta21 = convert (sizetype, delta21);\n+\t      /* We generate:\n+\n+\t\t   (op0.pfn == op1.pfn \n+                    && (!op0.pfn || op0.delta == op1.delta))\n+\t\t    \n+\t\t The reason for the `!op0.pfn' bit is that a NULL\n+\t\t pointer-to-member is any member with a zero PFN; the\n+\t\t DELTA field is unspecified.  */\n+\t      tree pfn0;\n+\t      tree pfn1;\n+\t      tree delta0;\n+\t      tree delta1;\n+\n+\t      pfn0 = pfn_from_ptrmemfunc (op0);\n+\t      pfn1 = pfn_from_ptrmemfunc (op1);\n+\t      delta0 = build_component_ref (op0, delta_identifier,\n+\t\t\t\t\t    NULL_TREE, 0);\n+\t      delta1 = build_component_ref (op1, delta_identifier,\n+\t\t\t\t\t    NULL_TREE, 0);\n+\t      e1 = build_binary_op (EQ_EXPR, delta0, delta1);\n+\t      e2 = build_binary_op (NE_EXPR, \n+\t\t\t\t    pfn0,\n+\t\t\t\t    cp_convert (TREE_TYPE (pfn0),\n+\t\t\t\t\t\tinteger_zero_node));\n+\t      e1 = build_binary_op (TRUTH_ORIF_EXPR, e1, e2);\n+\t      e2 = build (EQ_EXPR, boolean_type_node, pfn0, pfn1);\n+\t      e = build_binary_op (TRUTH_ANDIF_EXPR, e2, e1);\n \t    }\n \t  else\n-\t    index1 = integer_neg_one_node;\n-\t  {\n-\t    tree nop1 = build1 (NOP_EXPR, TYPE_PTRMEMFUNC_FN_TYPE (type0),\n-\t\t\t\top1);\n-\t    TREE_CONSTANT (nop1) = TREE_CONSTANT (op1);\n-\t    op1 = nop1;\n-\t  }\n-\t  e1 = build_binary_op (EQ_EXPR, index0, index1);\n-\t  e2 = build_binary_op (NE_EXPR, index1, integer_neg_one_node);\n-\t  e2 = build_binary_op (TRUTH_ANDIF_EXPR, e2,\n-\t\t\t\tbuild_binary_op (EQ_EXPR, delta20, delta21));\n-\t  /* We can't use build_binary_op for this cmp because it would get\n+\t    {\n+\t      /* The code we generate for the test is:\n+\n+\t\t (op0.index == op1.index\n+\t\t  && ((op1.index != -1 && op0.delta2 == op1.delta2)\n+\t\t      || op0.pfn == op1.pfn)) */\n+\n+\t      tree index0 = build_component_ref (op0, index_identifier,\n+\t\t\t\t\t\t NULL_TREE, 0);\n+\t      tree index1 = save_expr (build_component_ref (op1, index_identifier,\n+\t\t\t\t\t\t\t    NULL_TREE, 0));\n+\t      tree pfn0 = PFN_FROM_PTRMEMFUNC (op0);\n+\t      tree pfn1 = PFN_FROM_PTRMEMFUNC (op1);\n+\t      tree delta20 = DELTA2_FROM_PTRMEMFUNC (op0);\n+\t      tree delta21 = DELTA2_FROM_PTRMEMFUNC (op1);\n+\t      tree e3;\n+\t      tree integer_neg_one_node\n+\t\t= build_binary_op (MINUS_EXPR, integer_zero_node,\n+\t\t\t\t   integer_one_node);\n+\t      e1 = build_binary_op (EQ_EXPR, index0, index1);\n+\t      e2 = build_binary_op (NE_EXPR, index1, integer_neg_one_node);\n+\t      e2 = build_binary_op (TRUTH_ANDIF_EXPR, e2,\n+\t\t\t\t    build_binary_op (EQ_EXPR, delta20, delta21));\n+\t      /* We can't use build_binary_op for this cmp because it would get\n \t     confused by the ptr to method types and think we want pmfs.  */\n-\t  e3 = build (EQ_EXPR, boolean_type_node, pfn0, op1);\n-\t  e2 = build_binary_op (TRUTH_ORIF_EXPR, e2, e3);\n-\t  e2 = build_binary_op (TRUTH_ANDIF_EXPR, e1, e2);\n+\t      e3 = build (EQ_EXPR, boolean_type_node, pfn0, pfn1);\n+\t      e2 = build_binary_op (TRUTH_ORIF_EXPR, e2, e3);\n+\t      e = build_binary_op (TRUTH_ANDIF_EXPR, e1, e2);\n+\t    }\n \t  if (code == EQ_EXPR)\n-\t    return e2;\n-\t  return build_binary_op (EQ_EXPR, e2, integer_zero_node);\n-\t}\n-      else if (TYPE_PTRMEMFUNC_P (type1)\n-\t       && same_type_p (TYPE_PTRMEMFUNC_FN_TYPE (type1), type0))\n-\treturn build_binary_op (code, op1, op0);\n+\t    return e;\n+\t  return build_binary_op (EQ_EXPR, e, integer_zero_node);\n+\t}\n+      else if ((TYPE_PTRMEMFUNC_P (type0)\n+\t\t&& same_type_p (TYPE_PTRMEMFUNC_FN_TYPE (type0), type1))\n+\t       || (TYPE_PTRMEMFUNC_P (type1)\n+\t\t   && same_type_p (TYPE_PTRMEMFUNC_FN_TYPE (type1), type0)))\n+\tmy_friendly_abort (20000221);\n       break;\n \n     case MAX_EXPR:\n@@ -4059,7 +4059,7 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n   if (!result_type)\n     {\n       cp_error (\"invalid operands of types `%T' and `%T' to binary `%O'\",\n-\t\tTREE_TYPE (orig_op0), TREE_TYPE (orig_op1), error_code);\n+\t\tTREE_TYPE (orig_op0), TREE_TYPE (orig_op1), code);\n       return error_mark_node;\n     }\n \n@@ -6071,77 +6071,101 @@ get_delta_difference (from, to, force)\n   return BINFO_OFFSET (binfo);\n }\n \n+/* Return a constructor for the pointer-to-member-function TYPE using\n+   the other components as specified.  */\n+\n tree\n build_ptrmemfunc1 (type, delta, idx, pfn, delta2)\n      tree type, delta, idx, pfn, delta2;\n {\n   tree u;\n+  tree delta_field;\n+  tree idx_field;\n+  tree pfn_or_delta2_field;\n+  tree pfn_field;\n+  tree delta2_field;\n+  tree subtype;\n+  int allconstant, allsimple;\n \n-#if 0\n-  /* This is the old way we did it.  We want to avoid calling\n-     digest_init, so that it can give an error if we use { } when\n-     initializing a pointer to member function.  */\n-\n-  if (pfn)\n+  /* Pull the FIELD_DECLs out of the type.  */\n+  if (flag_new_abi)\n     {\n-      u = build_nt (CONSTRUCTOR, NULL_TREE,\n-\t\t    tree_cons (pfn_identifier, pfn, NULL_TREE));\n+      pfn_field = TYPE_FIELDS (type);\n+      delta_field = TREE_CHAIN (pfn_field);\n+      idx_field = NULL_TREE;\n+      pfn_or_delta2_field = NULL_TREE;\n+      delta2_field = NULL_TREE;\n+      subtype = NULL_TREE;\n     }\n   else\n     {\n-      u = build_nt (CONSTRUCTOR, NULL_TREE,\n-\t\t    tree_cons (delta2_identifier, delta2, NULL_TREE));\n+      delta_field = TYPE_FIELDS (type);\n+      idx_field = TREE_CHAIN (delta_field);\n+      pfn_or_delta2_field = TREE_CHAIN (idx_field);\n+      subtype = TREE_TYPE (pfn_or_delta2_field);\n+      pfn_field = TYPE_FIELDS (subtype);\n+      delta2_field = TREE_CHAIN (pfn_field);\n     }\n \n-  u = build_nt (CONSTRUCTOR, NULL_TREE,\n-\t\ttree_cons (NULL_TREE, delta,\n-\t\t\t   tree_cons (NULL_TREE, idx,\n-\t\t\t\t      tree_cons (NULL_TREE, u, NULL_TREE))));\n-\n-  return digest_init (type, u, (tree*)0);\n-#else\n-  tree delta_field, idx_field, pfn_or_delta2_field, pfn_field, delta2_field;\n-  tree subtype;\n-  int allconstant, allsimple;\n+  /* Make sure DELTA has the type we want.  */\n+  delta = convert_and_check (delta_type_node, delta);\n \n-  delta_field = TYPE_FIELDS (type);\n-  idx_field = TREE_CHAIN (delta_field);\n-  pfn_or_delta2_field = TREE_CHAIN (idx_field);\n-  subtype = TREE_TYPE (pfn_or_delta2_field);\n-  pfn_field = TYPE_FIELDS (subtype);\n-  delta2_field = TREE_CHAIN (pfn_field);\n+  /* Keep track of whether the initializer is a) constant, and b) can\n+     be done statically.  */\n+  allconstant = TREE_CONSTANT (delta);\n+  allsimple = (initializer_constant_valid_p (delta, TREE_TYPE (delta)) \n+\t       != NULL_TREE);\n \n   if (pfn)\n     {\n-      allconstant = TREE_CONSTANT (pfn);\n-      allsimple = !! initializer_constant_valid_p (pfn, TREE_TYPE (pfn));\n-      u = tree_cons (pfn_field, pfn, NULL_TREE);\n+      /* A non-virtual function.  */\n+      if (!flag_new_abi)\n+\tu = build_tree_list (pfn_field, pfn);\n+\n+      allconstant &= TREE_CONSTANT (pfn);\n+      allsimple &= (initializer_constant_valid_p (pfn, TREE_TYPE (pfn)) \n+\t\t    != NULL_TREE);\n     }\n   else\n     {\n-      delta2 = convert_and_check (delta_type_node, delta2);\n-      allconstant = TREE_CONSTANT (delta2);\n-      allsimple = !! initializer_constant_valid_p (delta2, TREE_TYPE (delta2));\n-      u = tree_cons (delta2_field, delta2, NULL_TREE);\n-    }\n-\n-  delta = convert_and_check (delta_type_node, delta);\n-  idx = convert_and_check (delta_type_node, idx);\n+      /* A virtual function.  */\n+      if (flag_new_abi)\n+\t{\n+\t  allconstant &= TREE_CONSTANT (pfn);\n+\t  allsimple &= (initializer_constant_valid_p (pfn, TREE_TYPE (pfn)) \n+\t\t\t!= NULL_TREE);\n+\t}\n+      else\n+\t{\n+\t  idx = convert_and_check (delta_type_node, idx);\n+\t  u = build_tree_list (delta2_field, delta2);\n \n-  allconstant = allconstant && TREE_CONSTANT (delta) && TREE_CONSTANT (idx);\n-  allsimple = allsimple\n-    && initializer_constant_valid_p (delta, TREE_TYPE (delta))\n-      && initializer_constant_valid_p (idx, TREE_TYPE (idx));\n+\t  allconstant &= TREE_CONSTANT (idx) && TREE_CONSTANT (delta2);\n+\t  allsimple &= ((initializer_constant_valid_p (idx, TREE_TYPE (idx)) \n+\t\t\t != NULL_TREE)\n+\t\t\t&& (initializer_constant_valid_p (delta2,\n+\t\t\t\t\t\t\t  TREE_TYPE (delta2))\n+\t\t\t    != NULL_TREE));\n+\t}\n+    }\n \n-  u = build (CONSTRUCTOR, subtype, NULL_TREE, u);\n-  u = tree_cons (delta_field, delta,\n-\t\t tree_cons (idx_field, idx,\n-\t\t\t    tree_cons (pfn_or_delta2_field, u, NULL_TREE)));\n+  /* Finish creating the initializer.  */\n+  if (flag_new_abi)\n+    u = tree_cons (pfn_field, pfn,\n+\t\t   build_tree_list (delta_field, delta));\n+  else\n+    {\n+      u = build (CONSTRUCTOR, subtype, NULL_TREE, u);\n+      u = tree_cons (delta_field, delta,\n+\t\t     tree_cons (idx_field, \n+\t\t\t\tidx,\n+\t\t\t\tbuild_tree_list (pfn_or_delta2_field,\n+\t\t\t\t\t\t u)));\n+    }\n   u = build (CONSTRUCTOR, type, NULL_TREE, u);\n   TREE_CONSTANT (u) = allconstant;\n   TREE_STATIC (u) = allconstant && allsimple;\n   return u;\n-#endif\n }\n \n /* Build a constructor for a pointer to member function.  It can be\n@@ -6179,28 +6203,40 @@ build_ptrmemfunc (type, pfn, force)\n \tcp_error (\"invalid conversion to type `%T' from type `%T'\", \n \t\t  to_type, pfn_type);\n \n+      /* We don't have to do any conversion to convert a\n+\t pointer-to-member to its own type.  But, we don't want to\n+\t just return a PTRMEM_CST if there's an explicit cast; that\n+\t cast should make the expression an invalid template argument.  */\n+      if (TREE_CODE (pfn) != PTRMEM_CST && same_type_p (to_type, pfn_type))\n+\treturn pfn;\n+\n+      if (flag_new_abi)\n+\t{\n+\t  /* Under the new ABI, the conversion is easy.  Just adjust\n+\t     the DELTA field.  */\n+\t  npfn = build_component_ref (pfn, pfn_identifier, NULL_TREE, 0);\n+\t  delta = build_component_ref (pfn, delta_identifier, NULL_TREE, 0);\n+\t  delta = cp_convert (ptrdiff_type_node, delta);\n+\t  n = get_delta_difference (TYPE_PTRMEMFUNC_OBJECT_TYPE (pfn_type),\n+\t\t\t\t    TYPE_PTRMEMFUNC_OBJECT_TYPE (to_type),\n+\t\t\t\t    force);\n+\t  delta = build_binary_op (PLUS_EXPR, delta, n);\n+\t  return build_ptrmemfunc1 (to_type, delta, NULL_TREE, npfn,\n+\t\t\t\t    NULL_TREE);\n+\t}\n+\n       if (TREE_CODE (pfn) == PTRMEM_CST)\n \t{\n \t  /* We could just build the resulting CONSTRUCTOR now, but we\n \t     don't, relying on the general machinery below, together\n-\t     with constant-folding, to do the right thing.  We don't\n-\t     want to return a PTRMEM_CST here, since a\n-\t     pointer-to-member constant is no longer a valid template\n-\t     argument once it is cast to any type, including its\n-\t     original type.  */\n+\t     with constant-folding, to do the right thing.  */\n \t  expand_ptrmemfunc_cst (pfn, &ndelta, &idx, &npfn, &ndelta2);\n \t  if (npfn)\n \t    /* This constant points to a non-virtual function.\n \t       NDELTA2 will be NULL, but it's value doesn't really\n \t       matter since we won't use it anyhow.  */\n \t    ndelta2 = integer_zero_node;\n \t}\n-      else if (same_type_p (to_type, pfn_type))\n-\t/* We don't have to do any conversion.  Note that we do this\n-\t   after checking for a PTRMEM_CST so that a PTRMEM_CST, cast\n-\t   to its own type, will not be considered a legal non-type\n-\t   template argument.  */\n-\treturn pfn;\n       else\n \t{\n \t  ndelta = cp_convert (ptrdiff_type_node, \n@@ -6220,17 +6256,15 @@ build_ptrmemfunc (type, pfn, force)\n       e1 = fold (build (GT_EXPR, boolean_type_node, idx, integer_zero_node));\n \t  \n       /* If it's a virtual function, this is what we want.  */\n-      e2 = build_ptrmemfunc1 (to_type, delta, idx,\n-\t\t\t      NULL_TREE, delta2);\n+      e2 = build_ptrmemfunc1 (to_type, delta, idx, NULL_TREE, delta2);\n \n       pfn = PFN_FROM_PTRMEMFUNC (pfn);\n       npfn = build1 (NOP_EXPR, type, pfn);\n       TREE_CONSTANT (npfn) = TREE_CONSTANT (pfn);\n \n       /* But if it's a non-virtual function, or NULL, we use this\n \t instead.  */\n-      e3 = build_ptrmemfunc1 (to_type, delta,\n-\t\t\t      idx, npfn, NULL_TREE);\n+      e3 = build_ptrmemfunc1 (to_type, delta, idx, npfn, NULL_TREE);\n       return build_conditional_expr (e1, e2, e3);\n     }\n \n@@ -6279,7 +6313,10 @@ expand_ptrmemfunc_cst (cst, delta, idx, pfn, delta2)\n \n   if (!DECL_VIRTUAL_P (fn))\n     {\n-      *idx = size_binop (MINUS_EXPR, integer_zero_node, integer_one_node);\n+      if (!flag_new_abi)\n+\t*idx = size_binop (MINUS_EXPR, integer_zero_node, integer_one_node);\n+      else\n+\t*idx = NULL_TREE;\n       *pfn = convert (TYPE_PTRMEMFUNC_FN_TYPE (type), build_addr_func (fn));\n       *delta2 = NULL_TREE;\n     }\n@@ -6292,9 +6329,21 @@ expand_ptrmemfunc_cst (cst, delta, idx, pfn, delta2)\n       tree binfo = binfo_or_else (orig_class, fn_class);\n       *delta = size_binop (PLUS_EXPR, *delta, BINFO_OFFSET (binfo));\n \n-      /* Map everything down one to make room for the null PMF.  */\n-      *idx = size_binop (PLUS_EXPR, DECL_VINDEX (fn), integer_one_node);\n-      *pfn = NULL_TREE;\n+      if (!flag_new_abi)\n+\t{\n+\t  /* Map everything down one to make room for the null PMF.  */\n+\t  *idx = size_binop (PLUS_EXPR, DECL_VINDEX (fn), integer_one_node);\n+\t  *pfn = NULL_TREE;\n+\t}\n+      else\n+\t{\n+\t  /* Under the new ABI, we set PFN to twice the index, plus\n+\t     one.  */\n+\t  *idx = NULL_TREE;\n+\t  *pfn = size_binop (MULT_EXPR, DECL_VINDEX (fn), integer_two_node);\n+\t  *pfn = size_binop (PLUS_EXPR, *pfn, integer_one_node);\n+\t  *pfn = build1 (NOP_EXPR, TYPE_PTRMEMFUNC_FN_TYPE (type), *pfn);\n+\t}\n \n       /* Offset from an object of PTR_CLASS to the vptr for ORIG_CLASS.  */\n       *delta2 = size_binop (PLUS_EXPR, *delta,\n@@ -6309,6 +6358,8 @@ tree\n delta2_from_ptrmemfunc (t)\n      tree t;\n {\n+  my_friendly_assert (!flag_new_abi, 20000221);\n+\n   if (TREE_CODE (t) == PTRMEM_CST)\n     {\n       tree delta;\n@@ -6347,11 +6398,14 @@ pfn_from_ptrmemfunc (t)\n \treturn pfn;\n     }\n \n-  return (build_component_ref \n-\t  (build_component_ref (t,\n-\t\t\t\tpfn_or_delta2_identifier, NULL_TREE,\n-\t\t\t\t0), \n-\t   pfn_identifier, NULL_TREE, 0)); \n+  if (flag_new_abi)\n+    return build_component_ref (t, pfn_identifier, NULL_TREE, 0);\n+  else\n+    return (build_component_ref \n+\t    (build_component_ref (t,\n+\t\t\t\t  pfn_or_delta2_identifier, NULL_TREE,\n+\t\t\t\t  0), \n+\t     pfn_identifier, NULL_TREE, 0)); \n }\n \n /* Convert value RHS to type TYPE as preparation for an assignment to"}]}