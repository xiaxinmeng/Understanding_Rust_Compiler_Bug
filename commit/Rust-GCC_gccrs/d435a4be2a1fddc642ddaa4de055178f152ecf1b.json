{"sha": "d435a4be2a1fddc642ddaa4de055178f152ecf1b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDQzNWE0YmUyYTFmZGRjNjQyZGRhYTRkZTA1NTE3OGYxNTJlY2YxYg==", "commit": {"author": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2012-09-06T17:11:18Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2012-09-06T17:11:18Z"}, "message": "arm.c: Use CONST_INT_P...\n\n2012-09-06  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n\n\t* config/arm/arm.c: Use CONST_INT_P, CONST_DOUBLE_P, REG_P, MEM_P,\n\tLABEL_P, JUMP_P, CALL_P, NOTE_P, BARRIER_P consistently.\n\t* config/arm/arm.h: Use REG_P, MEM_P consistently.\n\t* config/arm/arm.md: Use CONST_INT_P, REG_P, MEM_P, CONST_DOUBLE_P\n\tconsistently.\n\t* config/arm/neon.md: Use REG_P consistently.\n\t* config/arm/predicates.md: Use CONST_INT_P, REG_P, MEM_P\n\tconsistently.\n\t* config/arm/thumb2.md: Use CONST_INT_P, REG_P consistently.\n\t* config/arm/vec-common.md: Use REG_P consistently.\n\nFrom-SVN: r191034", "tree": {"sha": "6bdf5592e3e7c4a4684807cf87f0e45e6f2fa3ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6bdf5592e3e7c4a4684807cf87f0e45e6f2fa3ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d435a4be2a1fddc642ddaa4de055178f152ecf1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d435a4be2a1fddc642ddaa4de055178f152ecf1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d435a4be2a1fddc642ddaa4de055178f152ecf1b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d435a4be2a1fddc642ddaa4de055178f152ecf1b/comments", "author": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c2b3ec18a494e33e5b3d4704adea633de728dd26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2b3ec18a494e33e5b3d4704adea633de728dd26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2b3ec18a494e33e5b3d4704adea633de728dd26"}], "stats": {"total": 774, "additions": 392, "deletions": 382}, "files": [{"sha": "804f16b54c118fd6ec59f773a75101923d75d638", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d435a4be2a1fddc642ddaa4de055178f152ecf1b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d435a4be2a1fddc642ddaa4de055178f152ecf1b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d435a4be2a1fddc642ddaa4de055178f152ecf1b", "patch": "@@ -1,3 +1,16 @@\n+2012-09-06  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\n+\t* config/arm/arm.c: Use CONST_INT_P, CONST_DOUBLE_P, REG_P, MEM_P,\n+\tLABEL_P, JUMP_P, CALL_P, NOTE_P, BARRIER_P consistently.\n+\t* config/arm/arm.h: Use REG_P, MEM_P consistently.\n+\t* config/arm/arm.md: Use CONST_INT_P, REG_P, MEM_P, CONST_DOUBLE_P\n+\tconsistently.\n+\t* config/arm/neon.md: Use REG_P consistently.\n+\t* config/arm/predicates.md: Use CONST_INT_P, REG_P, MEM_P\n+\tconsistently.\n+\t* config/arm/thumb2.md: Use CONST_INT_P, REG_P consistently.\n+\t* config/arm/vec-common.md: Use REG_P consistently.\n+\n 2012-09-06  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/54498"}, {"sha": "dd073daf235824a5393b460ec0df1bc9c0acc89e", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 248, "deletions": 250, "changes": 498, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d435a4be2a1fddc642ddaa4de055178f152ecf1b/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d435a4be2a1fddc642ddaa4de055178f152ecf1b/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=d435a4be2a1fddc642ddaa4de055178f152ecf1b", "patch": "@@ -2337,7 +2337,7 @@ use_return_insn (int iscond, rtx sibling)\n       /* ... or for a tail-call argument ...  */\n       if (sibling)\n \t{\n-\t  gcc_assert (GET_CODE (sibling) == CALL_INSN);\n+\t  gcc_assert (CALL_P (sibling));\n \n \t  if (find_regno_fusage (sibling, USE, 3))\n \t    return 0;\n@@ -2558,7 +2558,7 @@ arm_split_constant (enum rtx_code code, enum machine_mode mode, rtx insn,\n     cond = NULL_RTX;\n \n   if (subtargets || code == SET\n-      || (GET_CODE (target) == REG && GET_CODE (source) == REG\n+      || (REG_P (target) && REG_P (source)\n \t  && REGNO (target) != REGNO (source)))\n     {\n       /* After arm_reorg has been called, we can't fix up expensive\n@@ -2990,7 +2990,7 @@ arm_gen_constant (enum rtx_code code, enum machine_mode mode, rtx cond,\n       if (generate)\n \t{\n \t  if (mode == SImode && i == 16)\n-\t    /* Use UXTH in preference to UBFX, since on Thumb2 it's a \n+\t    /* Use UXTH in preference to UBFX, since on Thumb2 it's a\n \t       smaller insn.  */\n \t    emit_constant_insn (cond,\n \t\t\t\tgen_zero_extendhisi2\n@@ -3530,7 +3530,7 @@ arm_canonicalize_comparison (enum rtx_code code, rtx *op0, rtx *op1)\n \t{\n \t  /* Missing comparison.  First try to use an available\n \t     comparison.  */\n-\t  if (GET_CODE (*op1) == CONST_INT)\n+\t  if (CONST_INT_P (*op1))\n \t    {\n \t      i = INTVAL (*op1);\n \t      switch (code)\n@@ -3583,7 +3583,7 @@ arm_canonicalize_comparison (enum rtx_code code, rtx *op0, rtx *op1)\n \n   /* Comparisons smaller than DImode.  Only adjust comparisons against\n      an out-of-range constant.  */\n-  if (GET_CODE (*op1) != CONST_INT\n+  if (!CONST_INT_P (*op1)\n       || const_ok_for_arm (INTVAL (*op1))\n       || const_ok_for_arm (- INTVAL (*op1)))\n     return code;\n@@ -4160,7 +4160,7 @@ aapcs_vfp_sub_candidate (const_tree type, enum machine_mode *modep)\n \ttree index = TYPE_DOMAIN (type);\n \n \t/* Can't handle incomplete types.  */\n-\tif (!COMPLETE_TYPE_P(type))\n+\tif (!COMPLETE_TYPE_P (type))\n \t  return -1;\n \n \tcount = aapcs_vfp_sub_candidate (TREE_TYPE (type), modep);\n@@ -4192,7 +4192,7 @@ aapcs_vfp_sub_candidate (const_tree type, enum machine_mode *modep)\n \ttree field;\n \n \t/* Can't handle incomplete types.  */\n-\tif (!COMPLETE_TYPE_P(type))\n+\tif (!COMPLETE_TYPE_P (type))\n \t  return -1;\n \n \tfor (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n@@ -4224,7 +4224,7 @@ aapcs_vfp_sub_candidate (const_tree type, enum machine_mode *modep)\n \ttree field;\n \n \t/* Can't handle incomplete types.  */\n-\tif (!COMPLETE_TYPE_P(type))\n+\tif (!COMPLETE_TYPE_P (type))\n \t  return -1;\n \n \tfor (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n@@ -5442,7 +5442,7 @@ legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n           && GET_CODE (XEXP (XEXP (orig, 0), 0)) == UNSPEC\n           && XINT (XEXP (XEXP (orig, 0), 0), 1) == UNSPEC_TLS)\n         {\n-\t  gcc_assert (GET_CODE (XEXP (XEXP (orig, 0), 1)) == CONST_INT);\n+\t  gcc_assert (CONST_INT_P (XEXP (XEXP (orig, 0), 1)));\n \t  return orig;\n \t}\n \n@@ -5458,7 +5458,7 @@ legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n       offset = legitimize_pic_address (XEXP (XEXP (orig, 0), 1), Pmode,\n \t\t\t\t       base == reg ? 0 : reg);\n \n-      if (GET_CODE (offset) == CONST_INT)\n+      if (CONST_INT_P (offset))\n \t{\n \t  /* The base register doesn't really matter, we only want to\n \t     test the index for the appropriate mode.  */\n@@ -5468,7 +5468,7 @@ legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n \t      offset = force_reg (Pmode, offset);\n \t    }\n \n-\t  if (GET_CODE (offset) == CONST_INT)\n+\t  if (CONST_INT_P (offset))\n \t    return plus_constant (Pmode, base, INTVAL (offset));\n \t}\n \n@@ -5649,7 +5649,7 @@ arm_address_register_rtx_p (rtx x, int strict_p)\n {\n   int regno;\n \n-  if (GET_CODE (x) != REG)\n+  if (!REG_P (x))\n     return 0;\n \n   regno = REGNO (x);\n@@ -5716,7 +5716,7 @@ arm_legitimate_address_outer_p (enum machine_mode mode, rtx x, RTX_CODE outer,\n \t to fixup invalid register choices.  */\n       if (use_ldrd\n \t  && GET_CODE (x) == POST_MODIFY\n-\t  && GET_CODE (addend) == REG)\n+\t  && REG_P (addend))\n \treturn 0;\n \n       return ((use_ldrd || GET_MODE_SIZE (mode) <= 4)\n@@ -5730,7 +5730,7 @@ arm_legitimate_address_outer_p (enum machine_mode mode, rtx x, RTX_CODE outer,\n \t       || (code == CONST\n \t\t   && GET_CODE (XEXP (x, 0)) == PLUS\n \t\t   && GET_CODE (XEXP (XEXP (x, 0), 0)) == LABEL_REF\n-\t\t   && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT)))\n+\t\t   && CONST_INT_P (XEXP (XEXP (x, 0), 1)))))\n     return 1;\n \n   else if (mode == TImode || (TARGET_NEON && VALID_NEON_STRUCT_MODE (mode)))\n@@ -5742,7 +5742,7 @@ arm_legitimate_address_outer_p (enum machine_mode mode, rtx x, RTX_CODE outer,\n       rtx xop1 = XEXP (x, 1);\n \n       return ((arm_address_register_rtx_p (xop0, strict_p)\n-\t       && ((GET_CODE(xop1) == CONST_INT\n+\t       && ((CONST_INT_P (xop1)\n \t\t    && arm_legitimate_index_p (mode, xop1, outer, strict_p))\n \t\t   || (!strict_p && will_be_in_index_register (xop1))))\n \t      || (arm_address_register_rtx_p (xop1, strict_p)\n@@ -5800,7 +5800,7 @@ thumb2_legitimate_address_p (enum machine_mode mode, rtx x, int strict_p)\n       rtx addend = XEXP (XEXP (x, 1), 1);\n       HOST_WIDE_INT offset;\n \n-      if (GET_CODE (addend) != CONST_INT)\n+      if (!CONST_INT_P (addend))\n \treturn 0;\n \n       offset = INTVAL(addend);\n@@ -5818,7 +5818,7 @@ thumb2_legitimate_address_p (enum machine_mode mode, rtx x, int strict_p)\n \t       || (code == CONST\n \t\t   && GET_CODE (XEXP (x, 0)) == PLUS\n \t\t   && GET_CODE (XEXP (XEXP (x, 0), 0)) == LABEL_REF\n-\t\t   && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT)))\n+\t\t   && CONST_INT_P (XEXP (XEXP (x, 0), 1)))))\n     return 1;\n \n   else if (mode == TImode || (TARGET_NEON && VALID_NEON_STRUCT_MODE (mode)))\n@@ -5930,7 +5930,7 @@ arm_legitimate_index_p (enum machine_mode mode, rtx index, RTX_CODE outer,\n \t  rtx op = XEXP (index, 1);\n \n \t  return (arm_address_register_rtx_p (XEXP (index, 0), strict_p)\n-\t\t  && GET_CODE (op) == CONST_INT\n+\t\t  && CONST_INT_P (op)\n \t\t  && INTVAL (op) > 0\n \t\t  && INTVAL (op) <= 31);\n \t}\n@@ -5962,7 +5962,7 @@ thumb2_index_mul_operand (rtx op)\n {\n   HOST_WIDE_INT val;\n \n-  if (GET_CODE(op) != CONST_INT)\n+  if (!CONST_INT_P (op))\n     return false;\n \n   val = INTVAL(op);\n@@ -6052,7 +6052,7 @@ thumb2_legitimate_index_p (enum machine_mode mode, rtx index, int strict_p)\n       rtx op = XEXP (index, 1);\n \n       return (arm_address_register_rtx_p (XEXP (index, 0), strict_p)\n-\t      && GET_CODE (op) == CONST_INT\n+\t      && CONST_INT_P (op)\n \t      && INTVAL (op) > 0\n \t      && INTVAL (op) <= 3);\n     }\n@@ -6068,7 +6068,7 @@ thumb1_base_register_rtx_p (rtx x, enum machine_mode mode, int strict_p)\n {\n   int regno;\n \n-  if (GET_CODE (x) != REG)\n+  if (!REG_P (x))\n     return 0;\n \n   regno = REGNO (x);\n@@ -6142,7 +6142,7 @@ thumb1_legitimate_address_p (enum machine_mode mode, rtx x, int strict_p)\n \t       || (GET_CODE (x) == CONST\n \t\t   && GET_CODE (XEXP (x, 0)) == PLUS\n \t\t   && GET_CODE (XEXP (XEXP (x, 0), 0)) == LABEL_REF\n-\t\t   && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT)))\n+\t\t   && CONST_INT_P (XEXP (XEXP (x, 0), 1)))))\n     return 1;\n \n   /* Post-inc indexing only supported for SImode and larger.  */\n@@ -6167,31 +6167,31 @@ thumb1_legitimate_address_p (enum machine_mode mode, rtx x, int strict_p)\n       /* REG+const has 5-7 bit offset for non-SP registers.  */\n       else if ((thumb1_index_register_rtx_p (XEXP (x, 0), strict_p)\n \t\t|| XEXP (x, 0) == arg_pointer_rtx)\n-\t       && GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t       && CONST_INT_P (XEXP (x, 1))\n \t       && thumb_legitimate_offset_p (mode, INTVAL (XEXP (x, 1))))\n \treturn 1;\n \n       /* REG+const has 10-bit offset for SP, but only SImode and\n \t larger is supported.  */\n       /* ??? Should probably check for DI/DFmode overflow here\n \t just like GO_IF_LEGITIMATE_OFFSET does.  */\n-      else if (GET_CODE (XEXP (x, 0)) == REG\n+      else if (REG_P (XEXP (x, 0))\n \t       && REGNO (XEXP (x, 0)) == STACK_POINTER_REGNUM\n \t       && GET_MODE_SIZE (mode) >= 4\n-\t       && GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t       && CONST_INT_P (XEXP (x, 1))\n \t       && INTVAL (XEXP (x, 1)) >= 0\n \t       && INTVAL (XEXP (x, 1)) + GET_MODE_SIZE (mode) <= 1024\n \t       && (INTVAL (XEXP (x, 1)) & 3) == 0)\n \treturn 1;\n \n-      else if (GET_CODE (XEXP (x, 0)) == REG\n+      else if (REG_P (XEXP (x, 0))\n \t       && (REGNO (XEXP (x, 0)) == FRAME_POINTER_REGNUM\n \t\t   || REGNO (XEXP (x, 0)) == ARG_POINTER_REGNUM\n \t\t   || (REGNO (XEXP (x, 0)) >= FIRST_VIRTUAL_REGISTER\n \t\t       && REGNO (XEXP (x, 0))\n \t\t\t  <= LAST_VIRTUAL_POINTER_REGISTER))\n \t       && GET_MODE_SIZE (mode) >= 4\n-\t       && GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t       && CONST_INT_P (XEXP (x, 1))\n \t       && (INTVAL (XEXP (x, 1)) & 3) == 0)\n \treturn 1;\n     }\n@@ -6495,7 +6495,7 @@ arm_legitimize_address (rtx x, rtx orig_x, enum machine_mode mode)\n \txop1 = force_reg (SImode, xop1);\n \n       if (ARM_BASE_REGISTER_RTX_P (xop0)\n-\t  && GET_CODE (xop1) == CONST_INT)\n+\t  && CONST_INT_P (xop1))\n \t{\n \t  HOST_WIDE_INT n, low_n;\n \t  rtx base_reg, val;\n@@ -6551,7 +6551,7 @@ arm_legitimize_address (rtx x, rtx orig_x, enum machine_mode mode)\n      with absolute addresses which often allows for the base register to\n      be factorized for multiple adjacent memory references, and it might\n      even allows for the mini pool to be avoided entirely. */\n-  else if (GET_CODE (x) == CONST_INT && optimize > 0)\n+  else if (CONST_INT_P (x) && optimize > 0)\n     {\n       unsigned int bits;\n       HOST_WIDE_INT mask, base, index;\n@@ -6598,7 +6598,7 @@ thumb_legitimize_address (rtx x, rtx orig_x, enum machine_mode mode)\n     return legitimize_tls_address (x, NULL_RTX);\n \n   if (GET_CODE (x) == PLUS\n-      && GET_CODE (XEXP (x, 1)) == CONST_INT\n+      && CONST_INT_P (XEXP (x, 1))\n       && (INTVAL (XEXP (x, 1)) >= 32 * GET_MODE_SIZE (mode)\n \t  || INTVAL (XEXP (x, 1)) < 0))\n     {\n@@ -6668,9 +6668,9 @@ arm_legitimize_reload_address (rtx *p,\n   /* We must recognize output that we have already generated ourselves.  */\n   if (GET_CODE (*p) == PLUS\n       && GET_CODE (XEXP (*p, 0)) == PLUS\n-      && GET_CODE (XEXP (XEXP (*p, 0), 0)) == REG\n-      && GET_CODE (XEXP (XEXP (*p, 0), 1)) == CONST_INT\n-      && GET_CODE (XEXP (*p, 1)) == CONST_INT)\n+      && REG_P (XEXP (XEXP (*p, 0), 0))\n+      && CONST_INT_P (XEXP (XEXP (*p, 0), 1))\n+      && CONST_INT_P (XEXP (*p, 1)))\n     {\n       push_reload (XEXP (*p, 0), NULL_RTX, &XEXP (*p, 0), NULL,\n \t\t   MODE_BASE_REG_CLASS (mode), GET_MODE (*p),\n@@ -6679,13 +6679,13 @@ arm_legitimize_reload_address (rtx *p,\n     }\n \n   if (GET_CODE (*p) == PLUS\n-      && GET_CODE (XEXP (*p, 0)) == REG\n+      && REG_P (XEXP (*p, 0))\n       && ARM_REGNO_OK_FOR_BASE_P (REGNO (XEXP (*p, 0)))\n       /* If the base register is equivalent to a constant, let the generic\n \t code handle it.  Otherwise we will run into problems if a future\n \t reload pass decides to rematerialize the constant.  */\n       && !reg_equiv_constant (ORIGINAL_REGNO (XEXP (*p, 0)))\n-      && GET_CODE (XEXP (*p, 1)) == CONST_INT)\n+      && CONST_INT_P (XEXP (*p, 1)))\n     {\n       HOST_WIDE_INT val = INTVAL (XEXP (*p, 1));\n       HOST_WIDE_INT low, high;\n@@ -6854,7 +6854,7 @@ thumb_legitimize_reload_address (rtx *x_p,\n       && GET_MODE_SIZE (mode) < 4\n       && REG_P (XEXP (x, 0))\n       && XEXP (x, 0) == stack_pointer_rtx\n-      && GET_CODE (XEXP (x, 1)) == CONST_INT\n+      && CONST_INT_P (XEXP (x, 1))\n       && !thumb_legitimate_offset_p (mode, INTVAL (XEXP (x, 1))))\n     {\n       rtx orig_x = x;\n@@ -6952,8 +6952,8 @@ arm_legitimate_constant_p_1 (enum machine_mode mode, rtx x)\n static bool\n thumb_legitimate_constant_p (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n {\n-  return (GET_CODE (x) == CONST_INT\n-\t  || GET_CODE (x) == CONST_DOUBLE\n+  return (CONST_INT_P (x)\n+\t  || CONST_DOUBLE_P (x)\n \t  || CONSTANT_ADDRESS_P (x)\n \t  || flag_pic);\n }\n@@ -6985,11 +6985,11 @@ arm_cannot_force_const_mem (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n }\n \f\n #define REG_OR_SUBREG_REG(X)\t\t\t\t\t\t\\\n-  (GET_CODE (X) == REG\t\t\t\t\t\t\t\\\n-   || (GET_CODE (X) == SUBREG && GET_CODE (SUBREG_REG (X)) == REG))\n+  (REG_P (X)\t\t\t\t\t\t\t\\\n+   || (GET_CODE (X) == SUBREG && REG_P (SUBREG_REG (X))))\n \n #define REG_OR_SUBREG_RTX(X)\t\t\t\\\n-   (GET_CODE (X) == REG ? (X) : SUBREG_REG (X))\n+   (REG_P (X) ? (X) : SUBREG_REG (X))\n \n static inline int\n thumb1_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer)\n@@ -7011,7 +7011,7 @@ thumb1_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer)\n       return COSTS_N_INSNS (1);\n \n     case MULT:\n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n+      if (CONST_INT_P (XEXP (x, 1)))\n \t{\n \t  int cycles = 0;\n \t  unsigned HOST_WIDE_INT i = INTVAL (XEXP (x, 1));\n@@ -7027,8 +7027,8 @@ thumb1_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer)\n \n     case SET:\n       return (COSTS_N_INSNS (1)\n-\t      + 4 * ((GET_CODE (SET_SRC (x)) == MEM)\n-\t\t     + GET_CODE (SET_DEST (x)) == MEM));\n+\t      + 4 * ((MEM_P (SET_SRC (x)))\n+\t\t     + MEM_P (SET_DEST (x))));\n \n     case CONST_INT:\n       if (outer == SET)\n@@ -7144,9 +7144,9 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n       return false;\n \n     case ROTATE:\n-      if (GET_CODE (XEXP (x, 1)) == REG)\n+      if (REG_P (XEXP (x, 1)))\n \t*total = COSTS_N_INSNS (1); /* Need to subtract from 32 */\n-      else if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n+      else if (!CONST_INT_P (XEXP (x, 1)))\n \t*total = rtx_cost (XEXP (x, 1), code, 1, speed);\n \n       /* Fall through */\n@@ -7170,7 +7170,7 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n       /* Increase the cost of complex shifts because they aren't any faster,\n          and reduce dual issue opportunities.  */\n       if (arm_tune_cortex_a9\n-\t  && outer != SET && GET_CODE (XEXP (x, 1)) != CONST_INT)\n+\t  && outer != SET && !CONST_INT_P (XEXP (x, 1)))\n \t++*total;\n \n       return true;\n@@ -7179,14 +7179,14 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n       if (mode == DImode)\n \t{\n \t  *total = COSTS_N_INSNS (ARM_NUM_REGS (mode));\n-\t  if (GET_CODE (XEXP (x, 0)) == CONST_INT\n+\t  if (CONST_INT_P (XEXP (x, 0))\n \t      && const_ok_for_arm (INTVAL (XEXP (x, 0))))\n \t    {\n \t      *total += rtx_cost (XEXP (x, 1), code, 1, speed);\n \t      return true;\n \t    }\n \n-\t  if (GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t  if (CONST_INT_P (XEXP (x, 1))\n \t      && const_ok_for_arm (INTVAL (XEXP (x, 1))))\n \t    {\n \t      *total += rtx_cost (XEXP (x, 0), code, 0, speed);\n@@ -7203,14 +7203,14 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n \t\t  || (mode == DFmode && !TARGET_VFP_SINGLE)))\n \t    {\n \t      *total = COSTS_N_INSNS (1);\n-\t      if (GET_CODE (XEXP (x, 0)) == CONST_DOUBLE\n+\t      if (CONST_DOUBLE_P (XEXP (x, 0))\n \t\t  && arm_const_double_rtx (XEXP (x, 0)))\n \t\t{\n \t\t  *total += rtx_cost (XEXP (x, 1), code, 1, speed);\n \t\t  return true;\n \t\t}\n \n-\t      if (GET_CODE (XEXP (x, 1)) == CONST_DOUBLE\n+\t      if (CONST_DOUBLE_P (XEXP (x, 1))\n \t\t  && arm_const_double_rtx (XEXP (x, 1)))\n \t\t{\n \t\t  *total += rtx_cost (XEXP (x, 0), code, 0, speed);\n@@ -7224,7 +7224,7 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n \t}\n \n       *total = COSTS_N_INSNS (1);\n-      if (GET_CODE (XEXP (x, 0)) == CONST_INT\n+      if (CONST_INT_P (XEXP (x, 0))\n \t  && const_ok_for_arm (INTVAL (XEXP (x, 0))))\n \t{\n \t  *total += rtx_cost (XEXP (x, 1), code, 1, speed);\n@@ -7262,7 +7262,7 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n \t  || GET_RTX_CLASS (GET_CODE (XEXP (x, 1))) == RTX_COMM_COMPARE)\n \t{\n \t  *total = COSTS_N_INSNS (1) + rtx_cost (XEXP (x, 0), code, 0, speed);\n-\t  if (GET_CODE (XEXP (XEXP (x, 1), 0)) == REG\n+\t  if (REG_P (XEXP (XEXP (x, 1), 0))\n \t      && REGNO (XEXP (XEXP (x, 1), 0)) != CC_REGNUM)\n \t    *total += COSTS_N_INSNS (1);\n \n@@ -7300,7 +7300,7 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n \t\t  || (mode == DFmode && !TARGET_VFP_SINGLE)))\n \t    {\n \t      *total = COSTS_N_INSNS (1);\n-\t      if (GET_CODE (XEXP (x, 1)) == CONST_DOUBLE\n+\t      if (CONST_DOUBLE_P (XEXP (x, 1))\n \t\t  && arm_const_double_rtx (XEXP (x, 1)))\n \t\t{\n \t\t  *total += rtx_cost (XEXP (x, 0), code, 0, speed);\n@@ -7318,7 +7318,7 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n \t  || GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == RTX_COMM_COMPARE)\n \t{\n \t  *total = COSTS_N_INSNS (1) + rtx_cost (XEXP (x, 1), code, 1, speed);\n-\t  if (GET_CODE (XEXP (XEXP (x, 0), 0)) == REG\n+\t  if (REG_P (XEXP (XEXP (x, 0), 0))\n \t      && REGNO (XEXP (XEXP (x, 0), 0)) != CC_REGNUM)\n \t    *total += COSTS_N_INSNS (1);\n \t  return true;\n@@ -7335,13 +7335,13 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n \t operand.  */\n       if (REG_OR_SUBREG_REG (XEXP (x, 0))\n \t  && ARM_FRAME_RTX (REG_OR_SUBREG_RTX (XEXP (x, 0)))\n-\t  && GET_CODE (XEXP (x, 1)) != CONST_INT)\n+\t  && !CONST_INT_P (XEXP (x, 1)))\n \t*total = COSTS_N_INSNS (1);\n \n       if (mode == DImode)\n \t{\n \t  *total += COSTS_N_INSNS (2);\n-\t  if (GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t  if (CONST_INT_P (XEXP (x, 1))\n \t      && const_ok_for_op (INTVAL (XEXP (x, 1)), code))\n \t    {\n \t      *total += rtx_cost (XEXP (x, 0), code, 0, speed);\n@@ -7352,7 +7352,7 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n \t}\n \n       *total += COSTS_N_INSNS (1);\n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT\n+      if (CONST_INT_P (XEXP (x, 1))\n \t  && const_ok_for_op (INTVAL (XEXP (x, 1)), code))\n \t{\n \t  *total += rtx_cost (XEXP (x, 0), code, 0, speed);\n@@ -7432,7 +7432,7 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n \t    {\n \t      *total += rtx_cost (XEXP (XEXP (x, 0), 0), subcode, 0, speed);\n \t      /* Register shifts cost an extra cycle.  */\n-\t      if (GET_CODE (XEXP (XEXP (x, 0), 1)) != CONST_INT)\n+\t      if (!CONST_INT_P (XEXP (XEXP (x, 0), 1)))\n \t\t*total += COSTS_N_INSNS (1) + rtx_cost (XEXP (XEXP (x, 0), 1),\n \t\t\t\t\t\t\tsubcode, 1, speed);\n \t      return true;\n@@ -7452,7 +7452,7 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n \n       if (!((GET_RTX_CLASS (GET_CODE (operand)) == RTX_COMPARE\n \t     || GET_RTX_CLASS (GET_CODE (operand)) == RTX_COMM_COMPARE)\n-\t    && GET_CODE (XEXP (operand, 0)) == REG\n+\t    && REG_P (XEXP (operand, 0))\n \t    && REGNO (XEXP (operand, 0)) == CC_REGNUM))\n \t*total += COSTS_N_INSNS (1);\n       *total += (rtx_cost (XEXP (x, 1), code, 1, speed)\n@@ -7468,7 +7468,7 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n       goto scc_insn;\n \n     case GE:\n-      if ((GET_CODE (XEXP (x, 0)) != REG || REGNO (XEXP (x, 0)) != CC_REGNUM)\n+      if ((!REG_P (XEXP (x, 0)) || REGNO (XEXP (x, 0)) != CC_REGNUM)\n \t  && mode == SImode && XEXP (x, 1) == const0_rtx)\n \t{\n \t  *total = COSTS_N_INSNS (2) + rtx_cost (XEXP (x, 0), code, 0, speed);\n@@ -7477,7 +7477,7 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n       goto scc_insn;\n \n     case LT:\n-      if ((GET_CODE (XEXP (x, 0)) != REG || REGNO (XEXP (x, 0)) != CC_REGNUM)\n+      if ((!REG_P (XEXP (x, 0)) || REGNO (XEXP (x, 0)) != CC_REGNUM)\n \t  && mode == SImode && XEXP (x, 1) == const0_rtx)\n \t{\n \t  *total = COSTS_N_INSNS (1) + rtx_cost (XEXP (x, 0), code, 0, speed);\n@@ -7504,21 +7504,21 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n \t performed, then they cost 2 instructions.  Otherwise they need\n \t an additional comparison before them.  */\n       *total = COSTS_N_INSNS (2);\n-      if (GET_CODE (XEXP (x, 0)) == REG && REGNO (XEXP (x, 0)) == CC_REGNUM)\n+      if (REG_P (XEXP (x, 0)) && REGNO (XEXP (x, 0)) == CC_REGNUM)\n \t{\n \t  return true;\n \t}\n \n       /* Fall through */\n     case COMPARE:\n-      if (GET_CODE (XEXP (x, 0)) == REG && REGNO (XEXP (x, 0)) == CC_REGNUM)\n+      if (REG_P (XEXP (x, 0)) && REGNO (XEXP (x, 0)) == CC_REGNUM)\n \t{\n \t  *total = 0;\n \t  return true;\n \t}\n \n       *total += COSTS_N_INSNS (1);\n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT\n+      if (CONST_INT_P (XEXP (x, 1))\n \t  && const_ok_for_op (INTVAL (XEXP (x, 1)), code))\n \t{\n \t  *total += rtx_cost (XEXP (x, 0), code, 0, speed);\n@@ -7550,7 +7550,7 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n     case SMIN:\n     case SMAX:\n       *total = COSTS_N_INSNS (2) + rtx_cost (XEXP (x, 0), code, 0, speed);\n-      if (GET_CODE (XEXP (x, 1)) != CONST_INT\n+      if (!CONST_INT_P (XEXP (x, 1))\n \t  || !const_ok_for_arm (INTVAL (XEXP (x, 1))))\n \t*total += rtx_cost (XEXP (x, 1), code, 1, speed);\n       return true;\n@@ -7667,7 +7667,7 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n \n     case SET:\n       return false;\n-      \n+\n     case UNSPEC:\n       /* We cost this as high as our memory costs to allow this to\n \t be hoisted from loops.  */\n@@ -7716,7 +7716,7 @@ thumb1_size_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer)\n       return COSTS_N_INSNS (1);\n \n     case MULT:\n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n+      if (CONST_INT_P (XEXP (x, 1)))\n         {\n           /* Thumb1 mul instruction can't operate on const. We must Load it\n              into a register first.  */\n@@ -7727,8 +7727,8 @@ thumb1_size_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer)\n \n     case SET:\n       return (COSTS_N_INSNS (1)\n-              + 4 * ((GET_CODE (SET_SRC (x)) == MEM)\n-                     + GET_CODE (SET_DEST (x)) == MEM));\n+              + 4 * ((MEM_P (SET_SRC (x)))\n+                     + MEM_P (SET_DEST (x))));\n \n     case CONST_INT:\n       if (outer == SET)\n@@ -7804,14 +7804,14 @@ thumb1_size_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer)\n         {\n           case QImode:\n             return (1 + (mode == DImode ? 4 : 0)\n-                    + (GET_CODE (XEXP (x, 0)) == MEM ? 10 : 0));\n+                    + (MEM_P (XEXP (x, 0)) ? 10 : 0));\n \n           case HImode:\n             return (4 + (mode == DImode ? 4 : 0)\n-                    + (GET_CODE (XEXP (x, 0)) == MEM ? 10 : 0));\n+                    + (MEM_P (XEXP (x, 0)) ? 10 : 0));\n \n           case SImode:\n-            return (1 + (GET_CODE (XEXP (x, 0)) == MEM ? 10 : 0));\n+            return (1 + (MEM_P (XEXP (x, 0)) ? 10 : 0));\n \n           default:\n             return 99;\n@@ -7861,7 +7861,7 @@ arm_size_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n       return false;\n \n     case ROTATE:\n-      if (mode == SImode && GET_CODE (XEXP (x, 1)) == REG)\n+      if (mode == SImode && REG_P (XEXP (x, 1)))\n \t{\n \t  *total = COSTS_N_INSNS (2) + rtx_cost (XEXP (x, 0), code, 0, false);\n \t  return true;\n@@ -7871,7 +7871,7 @@ arm_size_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n     case ASHIFT:\n     case LSHIFTRT:\n     case ASHIFTRT:\n-      if (mode == DImode && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+      if (mode == DImode && CONST_INT_P (XEXP (x, 1)))\n \t{\n \t  *total = COSTS_N_INSNS (3) + rtx_cost (XEXP (x, 0), code, 0, false);\n \t  return true;\n@@ -7880,7 +7880,7 @@ arm_size_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t{\n \t  *total = COSTS_N_INSNS (1) + rtx_cost (XEXP (x, 0), code, 0, false);\n \t  /* Slightly disparage register shifts, but not by much.  */\n-\t  if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n+\t  if (!CONST_INT_P (XEXP (x, 1)))\n \t    *total += 1 + rtx_cost (XEXP (x, 1), code, 1, false);\n \t  return true;\n \t}\n@@ -8097,7 +8097,7 @@ arm_slowmul_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t  return false;\n \t}\n \n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n+      if (CONST_INT_P (XEXP (x, 1)))\n \t{\n \t  unsigned HOST_WIDE_INT i = (INTVAL (XEXP (x, 1))\n \t\t\t\t      & (unsigned HOST_WIDE_INT) 0xffffffff);\n@@ -8163,7 +8163,7 @@ arm_fastmul_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t  return false;\n \t}\n \n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n+      if (CONST_INT_P (XEXP (x, 1)))\n \t{\n \t  unsigned HOST_WIDE_INT i = (INTVAL (XEXP (x, 1))\n \t\t\t\t      & (unsigned HOST_WIDE_INT) 0xffffffff);\n@@ -8255,7 +8255,7 @@ arm_xscale_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t  return false;\n \t}\n \n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n+      if (CONST_INT_P (XEXP (x, 1)))\n \t{\n \t  /* If operand 1 is a constant we can more accurately\n \t     calculate the cost of the multiply.  The multiplier can\n@@ -8383,7 +8383,7 @@ arm_arm_address_cost (rtx x)\n \n   if (c == PLUS)\n     {\n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n+      if (CONST_INT_P (XEXP (x, 1)))\n \treturn 2;\n \n       if (ARITHMETIC_P (XEXP (x, 0)) || ARITHMETIC_P (XEXP (x, 1)))\n@@ -8403,8 +8403,8 @@ arm_thumb_address_cost (rtx x)\n   if (c == REG)\n     return 1;\n   if (c == PLUS\n-      && GET_CODE (XEXP (x, 0)) == REG\n-      && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+      && REG_P (XEXP (x, 0))\n+      && CONST_INT_P (XEXP (x, 1)))\n     return 1;\n \n   return 2;\n@@ -8655,13 +8655,13 @@ arm_adjust_cost (rtx insn, rtx link, rtx dep, int cost)\n \n   /* Call insns don't incur a stall, even if they follow a load.  */\n   if (REG_NOTE_KIND (link) == 0\n-      && GET_CODE (insn) == CALL_INSN)\n+      && CALL_P (insn))\n     return 1;\n \n   if ((i_pat = single_set (insn)) != NULL\n-      && GET_CODE (SET_SRC (i_pat)) == MEM\n+      && MEM_P (SET_SRC (i_pat))\n       && (d_pat = single_set (dep)) != NULL\n-      && GET_CODE (SET_DEST (d_pat)) == MEM)\n+      && MEM_P (SET_DEST (d_pat)))\n     {\n       rtx src_mem = XEXP (SET_SRC (i_pat), 0);\n       /* This is a load after a store, there is no conflict if the load reads\n@@ -8756,7 +8756,7 @@ vfp3_const_double_index (rtx x)\n   HOST_WIDE_INT m1, m2;\n   int point_pos = 2 * HOST_BITS_PER_WIDE_INT - 1;\n \n-  if (!TARGET_VFP3 || GET_CODE (x) != CONST_DOUBLE)\n+  if (!TARGET_VFP3 || !CONST_DOUBLE_P (x))\n     return -1;\n \n   REAL_VALUE_FROM_CONST_DOUBLE (r, x);\n@@ -8959,12 +8959,12 @@ neon_valid_immediate (rtx op, enum machine_mode mode, int inverse,\n       unsigned HOST_WIDE_INT elpart;\n       unsigned int part, parts;\n \n-      if (GET_CODE (el) == CONST_INT)\n+      if (CONST_INT_P (el))\n         {\n           elpart = INTVAL (el);\n           parts = 1;\n         }\n-      else if (GET_CODE (el) == CONST_DOUBLE)\n+      else if (CONST_DOUBLE_P (el))\n         {\n           elpart = CONST_DOUBLE_LOW (el);\n           parts = 2;\n@@ -8980,7 +8980,7 @@ neon_valid_immediate (rtx op, enum machine_mode mode, int inverse,\n               bytes[idx++] = (elpart & 0xff) ^ invmask;\n               elpart >>= BITS_PER_UNIT;\n             }\n-          if (GET_CODE (el) == CONST_DOUBLE)\n+          if (CONST_DOUBLE_P (el))\n             elpart = CONST_DOUBLE_HIGH (el);\n         }\n     }\n@@ -9154,9 +9154,9 @@ neon_immediate_valid_for_shift (rtx op, enum machine_mode mode,\n       rtx el = CONST_VECTOR_ELT (op, i);\n       unsigned HOST_WIDE_INT elpart;\n \n-      if (GET_CODE (el) == CONST_INT)\n+      if (CONST_INT_P (el))\n         elpart = INTVAL (el);\n-      else if (GET_CODE (el) == CONST_DOUBLE)\n+      else if (CONST_DOUBLE_P (el))\n         return 0;\n       else\n         gcc_unreachable ();\n@@ -9326,7 +9326,7 @@ neon_make_constant (rtx vals)\n       for (i = 0; i < n_elts; ++i)\n \t{\n \t  rtx x = XVECEXP (vals, 0, i);\n-\t  if (GET_CODE (x) == CONST_INT || GET_CODE (x) == CONST_DOUBLE)\n+\t  if (CONST_INT_P (x) || CONST_DOUBLE_P (x))\n \t    n_const++;\n \t}\n       if (n_const == n_elts)\n@@ -9467,7 +9467,7 @@ bounds_check (rtx operand, HOST_WIDE_INT low, HOST_WIDE_INT high,\n {\n   HOST_WIDE_INT lane;\n \n-  gcc_assert (GET_CODE (operand) == CONST_INT);\n+  gcc_assert (CONST_INT_P (operand));\n \n   lane = INTVAL (operand);\n \n@@ -9524,7 +9524,7 @@ arm_coproc_mem_operand (rtx op, bool wb)\n     return FALSE;\n \n   /* Constants are converted into offsets from labels.  */\n-  if (GET_CODE (op) != MEM)\n+  if (!MEM_P (op))\n     return FALSE;\n \n   ind = XEXP (op, 0);\n@@ -9534,11 +9534,11 @@ arm_coproc_mem_operand (rtx op, bool wb)\n \t  || (GET_CODE (ind) == CONST\n \t      && GET_CODE (XEXP (ind, 0)) == PLUS\n \t      && GET_CODE (XEXP (XEXP (ind, 0), 0)) == LABEL_REF\n-\t      && GET_CODE (XEXP (XEXP (ind, 0), 1)) == CONST_INT)))\n+\t      && CONST_INT_P (XEXP (XEXP (ind, 0), 1)))))\n     return TRUE;\n \n   /* Match: (mem (reg)).  */\n-  if (GET_CODE (ind) == REG)\n+  if (REG_P (ind))\n     return arm_address_register_rtx_p (ind, 0);\n \n   /* Autoincremment addressing modes.  POST_INC and PRE_DEC are\n@@ -9563,9 +9563,9 @@ arm_coproc_mem_operand (rtx op, bool wb)\n      (plus (reg)\n \t   (const)).  */\n   if (GET_CODE (ind) == PLUS\n-      && GET_CODE (XEXP (ind, 0)) == REG\n+      && REG_P (XEXP (ind, 0))\n       && REG_MODE_OK_FOR_BASE_P (XEXP (ind, 0), VOIDmode)\n-      && GET_CODE (XEXP (ind, 1)) == CONST_INT\n+      && CONST_INT_P (XEXP (ind, 1))\n       && INTVAL (XEXP (ind, 1)) > -1024\n       && INTVAL (XEXP (ind, 1)) <  1024\n       && (INTVAL (XEXP (ind, 1)) & 3) == 0)\n@@ -9596,7 +9596,7 @@ neon_vector_mem_operand (rtx op, int type)\n     return FALSE;\n \n   /* Constants are converted into offsets from labels.  */\n-  if (GET_CODE (op) != MEM)\n+  if (!MEM_P (op))\n     return FALSE;\n \n   ind = XEXP (op, 0);\n@@ -9606,11 +9606,11 @@ neon_vector_mem_operand (rtx op, int type)\n \t  || (GET_CODE (ind) == CONST\n \t      && GET_CODE (XEXP (ind, 0)) == PLUS\n \t      && GET_CODE (XEXP (XEXP (ind, 0), 0)) == LABEL_REF\n-\t      && GET_CODE (XEXP (XEXP (ind, 0), 1)) == CONST_INT)))\n+\t      && CONST_INT_P (XEXP (XEXP (ind, 0), 1)))))\n     return TRUE;\n \n   /* Match: (mem (reg)).  */\n-  if (GET_CODE (ind) == REG)\n+  if (REG_P (ind))\n     return arm_address_register_rtx_p (ind, 0);\n \n   /* Allow post-increment with Neon registers.  */\n@@ -9625,9 +9625,9 @@ neon_vector_mem_operand (rtx op, int type)\n           (const)).  */\n   if (type == 0\n       && GET_CODE (ind) == PLUS\n-      && GET_CODE (XEXP (ind, 0)) == REG\n+      && REG_P (XEXP (ind, 0))\n       && REG_MODE_OK_FOR_BASE_P (XEXP (ind, 0), VOIDmode)\n-      && GET_CODE (XEXP (ind, 1)) == CONST_INT\n+      && CONST_INT_P (XEXP (ind, 1))\n       && INTVAL (XEXP (ind, 1)) > -1024\n       && INTVAL (XEXP (ind, 1)) < 1016\n       && (INTVAL (XEXP (ind, 1)) & 3) == 0)\n@@ -9654,7 +9654,7 @@ neon_struct_mem_operand (rtx op)\n     return FALSE;\n \n   /* Constants are converted into offsets from labels.  */\n-  if (GET_CODE (op) != MEM)\n+  if (!MEM_P (op))\n     return FALSE;\n \n   ind = XEXP (op, 0);\n@@ -9664,11 +9664,11 @@ neon_struct_mem_operand (rtx op)\n \t  || (GET_CODE (ind) == CONST\n \t      && GET_CODE (XEXP (ind, 0)) == PLUS\n \t      && GET_CODE (XEXP (XEXP (ind, 0), 0)) == LABEL_REF\n-\t      && GET_CODE (XEXP (XEXP (ind, 0), 1)) == CONST_INT)))\n+\t      && CONST_INT_P (XEXP (XEXP (ind, 0), 1)))))\n     return TRUE;\n \n   /* Match: (mem (reg)).  */\n-  if (GET_CODE (ind) == REG)\n+  if (REG_P (ind))\n     return arm_address_register_rtx_p (ind, 0);\n \n   /* vldm/vstm allows POST_INC (ia) and PRE_DEC (db).  */\n@@ -9903,12 +9903,12 @@ adjacent_mem_locations (rtx a, rtx b)\n   if (volatile_refs_p (a) || volatile_refs_p (b))\n     return 0;\n \n-  if ((GET_CODE (XEXP (a, 0)) == REG\n+  if ((REG_P (XEXP (a, 0))\n        || (GET_CODE (XEXP (a, 0)) == PLUS\n-\t   && GET_CODE (XEXP (XEXP (a, 0), 1)) == CONST_INT))\n-      && (GET_CODE (XEXP (b, 0)) == REG\n+\t   && CONST_INT_P (XEXP (XEXP (a, 0), 1))))\n+      && (REG_P (XEXP (b, 0))\n \t  || (GET_CODE (XEXP (b, 0)) == PLUS\n-\t      && GET_CODE (XEXP (XEXP (b, 0), 1)) == CONST_INT)))\n+\t      && CONST_INT_P (XEXP (XEXP (b, 0), 1)))))\n     {\n       HOST_WIDE_INT val0 = 0, val1 = 0;\n       rtx reg0, reg1;\n@@ -10292,7 +10292,7 @@ load_multiple_sequence (rtx *operands, int nops, int *regs, int *saved_order,\n       if (GET_CODE (operands[nops + i]) == SUBREG)\n \toperands[nops + i] = alter_subreg (operands + (nops + i));\n \n-      gcc_assert (GET_CODE (operands[nops + i]) == MEM);\n+      gcc_assert (MEM_P (operands[nops + i]));\n \n       /* Don't reorder volatile memory references; it doesn't seem worth\n \t looking for the case where the order is ok anyway.  */\n@@ -10301,16 +10301,15 @@ load_multiple_sequence (rtx *operands, int nops, int *regs, int *saved_order,\n \n       offset = const0_rtx;\n \n-      if ((GET_CODE (reg = XEXP (operands[nops + i], 0)) == REG\n+      if ((REG_P (reg = XEXP (operands[nops + i], 0))\n \t   || (GET_CODE (reg) == SUBREG\n-\t       && GET_CODE (reg = SUBREG_REG (reg)) == REG))\n+\t       && REG_P (reg = SUBREG_REG (reg))))\n \t  || (GET_CODE (XEXP (operands[nops + i], 0)) == PLUS\n-\t      && ((GET_CODE (reg = XEXP (XEXP (operands[nops + i], 0), 0))\n-\t\t   == REG)\n+\t      && ((REG_P (reg = XEXP (XEXP (operands[nops + i], 0), 0)))\n \t\t  || (GET_CODE (reg) == SUBREG\n-\t\t      && GET_CODE (reg = SUBREG_REG (reg)) == REG))\n-\t      && (GET_CODE (offset = XEXP (XEXP (operands[nops + i], 0), 1))\n-\t\t  == CONST_INT)))\n+\t\t      && REG_P (reg = SUBREG_REG (reg))))\n+\t      && (CONST_INT_P (offset\n+\t\t  = XEXP (XEXP (operands[nops + i], 0), 1)))))\n \t{\n \t  if (i == 0)\n \t    {\n@@ -10323,7 +10322,7 @@ load_multiple_sequence (rtx *operands, int nops, int *regs, int *saved_order,\n \t    /* Not addressed from the same base register.  */\n \t    return 0;\n \n-\t  unsorted_regs[i] = (GET_CODE (operands[i]) == REG\n+\t  unsorted_regs[i] = (REG_P (operands[i])\n \t\t\t      ? REGNO (operands[i])\n \t\t\t      : REGNO (SUBREG_REG (operands[i])));\n \n@@ -10445,7 +10444,7 @@ store_multiple_sequence (rtx *operands, int nops, int nops_total,\n       if (GET_CODE (operands[nops + i]) == SUBREG)\n \toperands[nops + i] = alter_subreg (operands + (nops + i));\n \n-      gcc_assert (GET_CODE (operands[nops + i]) == MEM);\n+      gcc_assert (MEM_P (operands[nops + i]));\n \n       /* Don't reorder volatile memory references; it doesn't seem worth\n \t looking for the case where the order is ok anyway.  */\n@@ -10454,18 +10453,17 @@ store_multiple_sequence (rtx *operands, int nops, int nops_total,\n \n       offset = const0_rtx;\n \n-      if ((GET_CODE (reg = XEXP (operands[nops + i], 0)) == REG\n+      if ((REG_P (reg = XEXP (operands[nops + i], 0))\n \t   || (GET_CODE (reg) == SUBREG\n-\t       && GET_CODE (reg = SUBREG_REG (reg)) == REG))\n+\t       && REG_P (reg = SUBREG_REG (reg))))\n \t  || (GET_CODE (XEXP (operands[nops + i], 0)) == PLUS\n-\t      && ((GET_CODE (reg = XEXP (XEXP (operands[nops + i], 0), 0))\n-\t\t   == REG)\n+\t      && ((REG_P (reg = XEXP (XEXP (operands[nops + i], 0), 0)))\n \t\t  || (GET_CODE (reg) == SUBREG\n-\t\t      && GET_CODE (reg = SUBREG_REG (reg)) == REG))\n-\t      && (GET_CODE (offset = XEXP (XEXP (operands[nops + i], 0), 1))\n-\t\t  == CONST_INT)))\n+\t\t      && REG_P (reg = SUBREG_REG (reg))))\n+\t      && (CONST_INT_P (offset\n+\t\t  = XEXP (XEXP (operands[nops + i], 0), 1)))))\n \t{\n-\t  unsorted_reg_rtxs[i] = (GET_CODE (operands[i]) == REG\n+\t  unsorted_reg_rtxs[i] = (REG_P (operands[i])\n \t\t\t\t  ? operands[i] : SUBREG_REG (operands[i]));\n \t  unsorted_regs[i] = REGNO (unsorted_reg_rtxs[i]);\n \n@@ -10951,7 +10949,7 @@ gen_const_stm_seq (rtx *operands, int nops)\n    unaligned copies on processors which support unaligned semantics for those\n    instructions.  INTERLEAVE_FACTOR can be used to attempt to hide load latency\n    (using more registers) by doing e.g. load/load/store/store for a factor of 2.\n-   An interleave factor of 1 (the minimum) will perform no interleaving. \n+   An interleave factor of 1 (the minimum) will perform no interleaving.\n    Load/store multiple are used for aligned addresses where possible.  */\n \n static void\n@@ -11286,8 +11284,8 @@ arm_gen_movmemqi (rtx *operands)\n   rtx part_bytes_reg = NULL;\n   rtx mem;\n \n-  if (GET_CODE (operands[2]) != CONST_INT\n-      || GET_CODE (operands[3]) != CONST_INT\n+  if (!CONST_INT_P (operands[2])\n+      || !CONST_INT_P (operands[3])\n       || INTVAL (operands[2]) > 64)\n     return 0;\n \n@@ -11632,13 +11630,13 @@ arm_select_cc_mode (enum rtx_code op, rtx x, rtx y)\n      equalities and unsigned inequalities).  */\n   if (GET_MODE (x) == SImode\n       && GET_CODE (x) == ASHIFT\n-      && GET_CODE (XEXP (x, 1)) == CONST_INT && INTVAL (XEXP (x, 1)) == 24\n+      && CONST_INT_P (XEXP (x, 1)) && INTVAL (XEXP (x, 1)) == 24\n       && GET_CODE (XEXP (x, 0)) == SUBREG\n-      && GET_CODE (SUBREG_REG (XEXP (x, 0))) == MEM\n+      && MEM_P (SUBREG_REG (XEXP (x, 0)))\n       && GET_MODE (SUBREG_REG (XEXP (x, 0))) == QImode\n       && (op == EQ || op == NE\n \t  || op == GEU || op == GTU || op == LTU || op == LEU)\n-      && GET_CODE (y) == CONST_INT)\n+      && CONST_INT_P (y))\n     return CC_Zmode;\n \n   /* A construct for a conditional compare, if the false arm contains\n@@ -11828,7 +11826,7 @@ arm_reload_in_hi (rtx *operands)\n       ref = SUBREG_REG (ref);\n     }\n \n-  if (GET_CODE (ref) == REG)\n+  if (REG_P (ref))\n     {\n       /* We have a pseudo which has been spilt onto the stack; there\n \t are two cases here: the first where there is a simple\n@@ -11848,7 +11846,7 @@ arm_reload_in_hi (rtx *operands)\n \n   /* Handle the case where the address is too complex to be offset by 1.  */\n   if (GET_CODE (base) == MINUS\n-      || (GET_CODE (base) == PLUS && GET_CODE (XEXP (base, 1)) != CONST_INT))\n+      || (GET_CODE (base) == PLUS && !CONST_INT_P (XEXP (base, 1))))\n     {\n       rtx base_plus = gen_rtx_REG (SImode, REGNO (operands[2]) + 1);\n \n@@ -11945,7 +11943,7 @@ arm_reload_out_hi (rtx *operands)\n       ref = SUBREG_REG (ref);\n     }\n \n-  if (GET_CODE (ref) == REG)\n+  if (REG_P (ref))\n     {\n       /* We have a pseudo which has been spilt onto the stack; there\n \t are two cases here: the first where there is a simple\n@@ -11967,7 +11965,7 @@ arm_reload_out_hi (rtx *operands)\n \n   /* Handle the case where the address is too complex to be offset by 1.  */\n   if (GET_CODE (base) == MINUS\n-      || (GET_CODE (base) == PLUS && GET_CODE (XEXP (base, 1)) != CONST_INT))\n+      || (GET_CODE (base) == PLUS && !CONST_INT_P (XEXP (base, 1))))\n     {\n       rtx base_plus = gen_rtx_REG (SImode, REGNO (operands[2]) + 1);\n \n@@ -12352,7 +12350,7 @@ is_jump_table (rtx insn)\n       && ((table = next_real_insn (JUMP_LABEL (insn)))\n \t  == next_real_insn (insn))\n       && table != NULL\n-      && GET_CODE (table) == JUMP_INSN\n+      && JUMP_P (table)\n       && (GET_CODE (PATTERN (table)) == ADDR_VEC\n \t  || GET_CODE (PATTERN (table)) == ADDR_DIFF_VEC))\n     return table;\n@@ -12498,7 +12496,7 @@ add_minipool_forward_ref (Mfix *fix)\n     {\n       if (GET_CODE (fix->value) == GET_CODE (mp->value)\n \t  && fix->mode == mp->mode\n-\t  && (GET_CODE (fix->value) != CODE_LABEL\n+\t  && (!LABEL_P (fix->value)\n \t      || (CODE_LABEL_NUMBER (fix->value)\n \t\t  == CODE_LABEL_NUMBER (mp->value)))\n \t  && rtx_equal_p (fix->value, mp->value))\n@@ -12675,7 +12673,7 @@ add_minipool_backward_ref (Mfix *fix)\n     {\n       if (GET_CODE (fix->value) == GET_CODE (mp->value)\n \t  && fix->mode == mp->mode\n-\t  && (GET_CODE (fix->value) != CODE_LABEL\n+\t  && (!LABEL_P (fix->value)\n \t      || (CODE_LABEL_NUMBER (fix->value)\n \t\t  == CODE_LABEL_NUMBER (mp->value)))\n \t  && rtx_equal_p (fix->value, mp->value)\n@@ -12907,7 +12905,7 @@ arm_barrier_cost (rtx insn)\n   int base_cost = 50;\n   rtx next = next_nonnote_insn (insn);\n \n-  if (next != NULL && GET_CODE (next) == CODE_LABEL)\n+  if (next != NULL && LABEL_P (next))\n     base_cost -= 20;\n \n   switch (GET_CODE (insn))\n@@ -12958,7 +12956,7 @@ create_fix_barrier (Mfix *fix, HOST_WIDE_INT max_address)\n \n       /* This code shouldn't have been called if there was a natural barrier\n \t within range.  */\n-      gcc_assert (GET_CODE (from) != BARRIER);\n+      gcc_assert (!BARRIER_P (from));\n \n       /* Count the length of this insn.  This must stay in sync with the\n \t code that pushes minipool fixes.  */\n@@ -13125,8 +13123,8 @@ arm_const_double_inline_cost (rtx val)\n   lowpart = gen_lowpart (SImode, val);\n   highpart = gen_highpart_mode (SImode, mode, val);\n \n-  gcc_assert (GET_CODE (lowpart) == CONST_INT);\n-  gcc_assert (GET_CODE (highpart) == CONST_INT);\n+  gcc_assert (CONST_INT_P (lowpart));\n+  gcc_assert (CONST_INT_P (highpart));\n \n   return (arm_gen_constant (SET, SImode, NULL_RTX, INTVAL (lowpart),\n \t\t\t    NULL_RTX, NULL_RTX, 0, 0)\n@@ -13152,15 +13150,15 @@ arm_const_double_by_parts (rtx val)\n \n   part = gen_highpart_mode (SImode, mode, val);\n \n-  gcc_assert (GET_CODE (part) == CONST_INT);\n+  gcc_assert (CONST_INT_P (part));\n \n   if (const_ok_for_arm (INTVAL (part))\n       || const_ok_for_arm (~INTVAL (part)))\n     return true;\n \n   part = gen_lowpart (SImode, val);\n \n-  gcc_assert (GET_CODE (part) == CONST_INT);\n+  gcc_assert (CONST_INT_P (part));\n \n   if (const_ok_for_arm (INTVAL (part))\n       || const_ok_for_arm (~INTVAL (part)))\n@@ -13182,14 +13180,14 @@ arm_const_double_by_immediates (rtx val)\n \n   part = gen_highpart_mode (SImode, mode, val);\n \n-  gcc_assert (GET_CODE (part) == CONST_INT);\n+  gcc_assert (CONST_INT_P (part));\n \n   if (!const_ok_for_arm (INTVAL (part)))\n     return false;\n \n   part = gen_lowpart (SImode, val);\n \n-  gcc_assert (GET_CODE (part) == CONST_INT);\n+  gcc_assert (CONST_INT_P (part));\n \n   if (!const_ok_for_arm (INTVAL (part)))\n     return false;\n@@ -13237,7 +13235,7 @@ note_invalid_constants (rtx insn, HOST_WIDE_INT address, int do_pushes)\n \t\tpush_minipool_fix (insn, address, recog_data.operand_loc[opno],\n \t\t\t\t   recog_data.operand_mode[opno], op);\n \t    }\n-\t  else if (GET_CODE (op) == MEM\n+\t  else if (MEM_P (op)\n \t\t   && GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n \t\t   && CONSTANT_POOL_ADDRESS_P (XEXP (op, 0)))\n \t    {\n@@ -13337,7 +13335,7 @@ thumb2_reorg (void)\n \t\t      break;\n \n \t\t    case MINUS:\n-\t\t      /* RSBS <Rd>,<Rn>,#0  \n+\t\t      /* RSBS <Rd>,<Rn>,#0\n \t\t\t Not handled here: see NEG below.  */\n \t\t      /* SUBS <Rd>,<Rn>,#<imm3>\n \t\t\t SUBS <Rdn>,#<imm8>\n@@ -13476,13 +13474,13 @@ arm_reorg (void)\n   /* The first insn must always be a note, or the code below won't\n      scan it properly.  */\n   insn = get_insns ();\n-  gcc_assert (GET_CODE (insn) == NOTE);\n+  gcc_assert (NOTE_P (insn));\n   minipool_pad = 0;\n \n   /* Scan all the insns and record the operands that will need fixing.  */\n   for (insn = next_nonnote_insn (insn); insn; insn = next_nonnote_insn (insn))\n     {\n-      if (GET_CODE (insn) == BARRIER)\n+      if (BARRIER_P (insn))\n \tpush_minipool_barrier (insn, address);\n       else if (INSN_P (insn))\n \t{\n@@ -13518,7 +13516,7 @@ arm_reorg (void)\n       Mfix * this_fix;\n \n       /* Skip any further barriers before the next fix.  */\n-      while (fix && GET_CODE (fix->insn) == BARRIER)\n+      while (fix && BARRIER_P (fix->insn))\n \tfix = fix->next;\n \n       /* No more fixes.  */\n@@ -13529,7 +13527,7 @@ arm_reorg (void)\n \n       for (ftmp = fix; ftmp; ftmp = ftmp->next)\n \t{\n-\t  if (GET_CODE (ftmp->insn) == BARRIER)\n+\t  if (BARRIER_P (ftmp->insn))\n \t    {\n \t      if (ftmp->address >= minipool_vector_head->max_address)\n \t\tbreak;\n@@ -13589,7 +13587,7 @@ arm_reorg (void)\n \n       while (ftmp)\n \t{\n-\t  if (GET_CODE (ftmp->insn) != BARRIER\n+\t  if (!BARRIER_P (ftmp->insn)\n \t      && ((ftmp->minipool = add_minipool_backward_ref (ftmp))\n \t\t  == NULL))\n \t    break;\n@@ -13601,7 +13599,7 @@ arm_reorg (void)\n \t up and adding the constants to the pool itself.  */\n       for (this_fix = fix; this_fix && ftmp != this_fix;\n \t   this_fix = this_fix->next)\n-\tif (GET_CODE (this_fix->insn) != BARRIER)\n+\tif (!BARRIER_P (this_fix->insn))\n \t  {\n \t    rtx addr\n \t      = plus_constant (Pmode,\n@@ -13744,7 +13742,7 @@ vfp_output_fstmd (rtx * operands)\n   strcpy (pattern, \"fstmfdd%?\\t%m0!, {%P1\");\n   p = strlen (pattern);\n \n-  gcc_assert (GET_CODE (operands[1]) == REG);\n+  gcc_assert (REG_P (operands[1]));\n \n   base = (REGNO (operands[1]) - FIRST_VFP_REGNUM) / 2;\n   for (i = 1; i < XVECLEN (operands[2], 0); i++)\n@@ -14085,7 +14083,7 @@ output_move_double (rtx *operands, bool emit, int *count)\n \t\t     FIXME: IWMMXT allows offsets larger than ldrd can\n \t\t     handle, fix these up with a pair of ldr.  */\n \t\t  if (TARGET_THUMB2\n-\t\t      || GET_CODE (otherops[2]) != CONST_INT\n+\t\t      || !CONST_INT_P (otherops[2])\n \t\t      || (INTVAL (otherops[2]) > -256\n \t\t\t  && INTVAL (otherops[2]) < 256))\n \t\t    {\n@@ -14111,7 +14109,7 @@ output_move_double (rtx *operands, bool emit, int *count)\n \t\t FIXME: IWMMXT allows offsets larger than ldrd can handle,\n \t\t fix these up with a pair of ldr.  */\n \t      if (TARGET_THUMB2\n-\t\t  || GET_CODE (otherops[2]) != CONST_INT\n+\t\t  || !CONST_INT_P (otherops[2])\n \t\t  || (INTVAL (otherops[2]) > -256\n \t\t      && INTVAL (otherops[2]) < 256))\n \t\t{\n@@ -14165,7 +14163,7 @@ output_move_double (rtx *operands, bool emit, int *count)\n \n \t      if (GET_CODE (XEXP (operands[1], 0)) == PLUS)\n \t\t{\n-\t\t  if (GET_CODE (otherops[2]) == CONST_INT && !TARGET_LDRD)\n+\t\t  if (CONST_INT_P (otherops[2]) && !TARGET_LDRD)\n \t\t    {\n \t\t      switch ((int) INTVAL (otherops[2]))\n \t\t\t{\n@@ -14190,9 +14188,9 @@ output_move_double (rtx *operands, bool emit, int *count)\n \t\t  otherops[0] = gen_rtx_REG(SImode, REGNO(operands[0]) + 1);\n \t\t  operands[1] = otherops[0];\n \t\t  if (TARGET_LDRD\n-\t\t      && (GET_CODE (otherops[2]) == REG\n+\t\t      && (REG_P (otherops[2])\n \t\t\t  || TARGET_THUMB2\n-\t\t\t  || (GET_CODE (otherops[2]) == CONST_INT\n+\t\t\t  || (CONST_INT_P (otherops[2])\n \t\t\t      && INTVAL (otherops[2]) > -256\n \t\t\t      && INTVAL (otherops[2]) < 256)))\n \t\t    {\n@@ -14228,7 +14226,7 @@ output_move_double (rtx *operands, bool emit, int *count)\n \t\t      return \"\";\n \t\t    }\n \n-\t\t  if (GET_CODE (otherops[2]) == CONST_INT)\n+\t\t  if (CONST_INT_P (otherops[2]))\n \t\t    {\n \t\t      if (emit)\n \t\t\t{\n@@ -14345,7 +14343,7 @@ output_move_double (rtx *operands, bool emit, int *count)\n \t  /* IWMMXT allows offsets larger than ldrd can handle,\n \t     fix these up with a pair of ldr.  */\n \t  if (!TARGET_THUMB2\n-\t      && GET_CODE (otherops[2]) == CONST_INT\n+\t      && CONST_INT_P (otherops[2])\n \t      && (INTVAL(otherops[2]) <= -256\n \t\t  || INTVAL(otherops[2]) >= 256))\n \t    {\n@@ -14384,7 +14382,7 @@ output_move_double (rtx *operands, bool emit, int *count)\n \n \tcase PLUS:\n \t  otherops[2] = XEXP (XEXP (operands[0], 0), 1);\n-\t  if (GET_CODE (otherops[2]) == CONST_INT && !TARGET_LDRD)\n+\t  if (CONST_INT_P (otherops[2]) && !TARGET_LDRD)\n \t    {\n \t      switch ((int) INTVAL (XEXP (XEXP (operands[0], 0), 1)))\n \t\t{\n@@ -14409,9 +14407,9 @@ output_move_double (rtx *operands, bool emit, int *count)\n \t\t}\n \t    }\n \t  if (TARGET_LDRD\n-\t      && (GET_CODE (otherops[2]) == REG\n+\t      && (REG_P (otherops[2])\n \t\t  || TARGET_THUMB2\n-\t\t  || (GET_CODE (otherops[2]) == CONST_INT\n+\t\t  || (CONST_INT_P (otherops[2])\n \t\t      && INTVAL (otherops[2]) > -256\n \t\t      && INTVAL (otherops[2]) < 256)))\n \t    {\n@@ -14761,10 +14759,10 @@ arm_address_offset_is_imm (rtx insn)\n \n   addr = XEXP (mem, 0);\n \n-  if (GET_CODE (addr) == REG\n+  if (REG_P (addr)\n       || (GET_CODE (addr) == PLUS\n-\t  && GET_CODE (XEXP (addr, 0)) == REG\n-\t  && GET_CODE (XEXP (addr, 1)) == CONST_INT))\n+\t  && REG_P (XEXP (addr, 0))\n+\t  && CONST_INT_P (XEXP (addr, 1))))\n     return 1;\n   else\n     return 0;\n@@ -16910,7 +16908,7 @@ arm_print_operand (FILE *stream, rtx x, int code)\n       return;\n \n     case 'B':\n-      if (GET_CODE (x) == CONST_INT)\n+      if (CONST_INT_P (x))\n \t{\n \t  HOST_WIDE_INT val;\n \t  val = ARM_SIGN_EXTEND (~INTVAL (x));\n@@ -16991,14 +16989,14 @@ arm_print_operand (FILE *stream, rtx x, int code)\n \t The 'Q' and 'R' constraints are also available for 64-bit\n \t constants.  */\n     case 'Q':\n-      if (GET_CODE (x) == CONST_INT || GET_CODE (x) == CONST_DOUBLE)\n+      if (CONST_INT_P (x) || CONST_DOUBLE_P (x))\n \t{\n \t  rtx part = gen_lowpart (SImode, x);\n \t  fprintf (stream, \"#\" HOST_WIDE_INT_PRINT_DEC, INTVAL (part));\n \t  return;\n \t}\n \n-      if (GET_CODE (x) != REG || REGNO (x) > LAST_ARM_REGNUM)\n+      if (!REG_P (x) || REGNO (x) > LAST_ARM_REGNUM)\n \t{\n \t  output_operand_lossage (\"invalid operand for code '%c'\", code);\n \t  return;\n@@ -17008,7 +17006,7 @@ arm_print_operand (FILE *stream, rtx x, int code)\n       return;\n \n     case 'R':\n-      if (GET_CODE (x) == CONST_INT || GET_CODE (x) == CONST_DOUBLE)\n+      if (CONST_INT_P (x) || CONST_DOUBLE_P (x))\n \t{\n \t  enum machine_mode mode = GET_MODE (x);\n \t  rtx part;\n@@ -17020,7 +17018,7 @@ arm_print_operand (FILE *stream, rtx x, int code)\n \t  return;\n \t}\n \n-      if (GET_CODE (x) != REG || REGNO (x) > LAST_ARM_REGNUM)\n+      if (!REG_P (x) || REGNO (x) > LAST_ARM_REGNUM)\n \t{\n \t  output_operand_lossage (\"invalid operand for code '%c'\", code);\n \t  return;\n@@ -17030,7 +17028,7 @@ arm_print_operand (FILE *stream, rtx x, int code)\n       return;\n \n     case 'H':\n-      if (GET_CODE (x) != REG || REGNO (x) > LAST_ARM_REGNUM)\n+      if (!REG_P (x) || REGNO (x) > LAST_ARM_REGNUM)\n \t{\n \t  output_operand_lossage (\"invalid operand for code '%c'\", code);\n \t  return;\n@@ -17040,7 +17038,7 @@ arm_print_operand (FILE *stream, rtx x, int code)\n       return;\n \n     case 'J':\n-      if (GET_CODE (x) != REG || REGNO (x) > LAST_ARM_REGNUM)\n+      if (!REG_P (x) || REGNO (x) > LAST_ARM_REGNUM)\n \t{\n \t  output_operand_lossage (\"invalid operand for code '%c'\", code);\n \t  return;\n@@ -17050,7 +17048,7 @@ arm_print_operand (FILE *stream, rtx x, int code)\n       return;\n \n     case 'K':\n-      if (GET_CODE (x) != REG || REGNO (x) > LAST_ARM_REGNUM)\n+      if (!REG_P (x) || REGNO (x) > LAST_ARM_REGNUM)\n \t{\n \t  output_operand_lossage (\"invalid operand for code '%c'\", code);\n \t  return;\n@@ -17061,7 +17059,7 @@ arm_print_operand (FILE *stream, rtx x, int code)\n \n     case 'm':\n       asm_fprintf (stream, \"%r\",\n-\t\t   GET_CODE (XEXP (x, 0)) == REG\n+\t\t   REG_P (XEXP (x, 0))\n \t\t   ? REGNO (XEXP (x, 0)) : REGNO (XEXP (XEXP (x, 0), 0)));\n       return;\n \n@@ -17129,7 +17127,7 @@ arm_print_operand (FILE *stream, rtx x, int code)\n       return;\n \n     case 'U':\n-      if (GET_CODE (x) != REG\n+      if (!REG_P (x)\n \t  || REGNO (x) < FIRST_IWMMXT_GR_REGNUM\n \t  || REGNO (x) > LAST_IWMMXT_GR_REGNUM)\n \t/* Bad value for wCG register number.  */\n@@ -17144,7 +17142,7 @@ arm_print_operand (FILE *stream, rtx x, int code)\n \n       /* Print an iWMMXt control register name.  */\n     case 'w':\n-      if (GET_CODE (x) != CONST_INT\n+      if (!CONST_INT_P (x)\n \t  || INTVAL (x) < 0\n \t  || INTVAL (x) >= 16)\n \t/* Bad value for wC register number.  */\n@@ -17174,7 +17172,7 @@ arm_print_operand (FILE *stream, rtx x, int code)\n         int mode = GET_MODE (x);\n         int regno;\n \n-        if (GET_MODE_SIZE (mode) != 8 || GET_CODE (x) != REG)\n+        if (GET_MODE_SIZE (mode) != 8 || !REG_P (x))\n           {\n \t    output_operand_lossage (\"invalid operand for code '%c'\", code);\n \t    return;\n@@ -17205,7 +17203,7 @@ arm_print_operand (FILE *stream, rtx x, int code)\n \t    return;\n \t  }\n \n-\tif (GET_CODE (x) != REG\n+\tif (!REG_P (x)\n \t    || !IS_VFP_REGNUM (REGNO (x)))\n \t  {\n \t    output_operand_lossage (\"invalid operand for code '%c'\", code);\n@@ -17235,7 +17233,7 @@ arm_print_operand (FILE *stream, rtx x, int code)\n         int regno;\n \n         if ((GET_MODE_SIZE (mode) != 16\n-\t     && GET_MODE_SIZE (mode) != 32) || GET_CODE (x) != REG)\n+\t     && GET_MODE_SIZE (mode) != 32) || !REG_P (x))\n           {\n \t    output_operand_lossage (\"invalid operand for code '%c'\", code);\n \t    return;\n@@ -17315,7 +17313,7 @@ arm_print_operand (FILE *stream, rtx x, int code)\n \tbool postinc = FALSE;\n \tunsigned align, memsize, align_bits;\n \n-\tgcc_assert (GET_CODE (x) == MEM);\n+\tgcc_assert (MEM_P (x));\n \taddr = XEXP (x, 0);\n \tif (GET_CODE (addr) == POST_INC)\n \t  {\n@@ -17354,9 +17352,9 @@ arm_print_operand (FILE *stream, rtx x, int code)\n       {\n \trtx addr;\n \n-\tgcc_assert (GET_CODE (x) == MEM);\n+\tgcc_assert (MEM_P (x));\n \taddr = XEXP (x, 0);\n-\tgcc_assert (GET_CODE (addr) == REG);\n+\tgcc_assert (REG_P (addr));\n \tasm_fprintf (stream, \"[%r]\", REGNO (addr));\n       }\n       return;\n@@ -17367,7 +17365,7 @@ arm_print_operand (FILE *stream, rtx x, int code)\n         int mode = GET_MODE (x);\n         int regno;\n \n-        if (GET_MODE_SIZE (mode) != 4 || GET_CODE (x) != REG)\n+        if (GET_MODE_SIZE (mode) != 4 || !REG_P (x))\n           {\n \t    output_operand_lossage (\"invalid operand for code '%c'\", code);\n \t    return;\n@@ -17386,7 +17384,7 @@ arm_print_operand (FILE *stream, rtx x, int code)\n       return;\n \n     case 'v':\n-\tgcc_assert (GET_CODE (x) == CONST_DOUBLE);\n+\tgcc_assert (CONST_DOUBLE_P (x));\n \tfprintf (stream, \"#%d\", vfp3_const_double_for_fract_bits (x));\n \treturn;\n \n@@ -17397,7 +17395,7 @@ arm_print_operand (FILE *stream, rtx x, int code)\n         int mode = GET_MODE (x);\n         int regno;\n \n-        if (GET_MODE_SIZE (mode) != 2 || GET_CODE (x) != REG)\n+        if (GET_MODE_SIZE (mode) != 2 || !REG_P (x))\n           {\n \t    output_operand_lossage (\"invalid operand for code '%c'\", code);\n \t    return;\n@@ -17468,15 +17466,15 @@ arm_print_operand_address (FILE *stream, rtx x)\n     {\n       int is_minus = GET_CODE (x) == MINUS;\n \n-      if (GET_CODE (x) == REG)\n+      if (REG_P (x))\n \tasm_fprintf (stream, \"[%r]\", REGNO (x));\n       else if (GET_CODE (x) == PLUS || is_minus)\n \t{\n \t  rtx base = XEXP (x, 0);\n \t  rtx index = XEXP (x, 1);\n \t  HOST_WIDE_INT offset = 0;\n-\t  if (GET_CODE (base) != REG\n-\t      || (GET_CODE (index) == REG && REGNO (index) == SP_REGNUM))\n+\t  if (!REG_P (base)\n+\t      || (REG_P (index) && REGNO (index) == SP_REGNUM))\n \t    {\n \t      /* Ensure that BASE is a register.  */\n \t      /* (one of them must be).  */\n@@ -17524,7 +17522,7 @@ arm_print_operand_address (FILE *stream, rtx x)\n \t{\n \t  extern enum machine_mode output_memory_reference_mode;\n \n-\t  gcc_assert (GET_CODE (XEXP (x, 0)) == REG);\n+\t  gcc_assert (REG_P (XEXP (x, 0)));\n \n \t  if (GET_CODE (x) == PRE_DEC || GET_CODE (x) == PRE_INC)\n \t    asm_fprintf (stream, \"[%r, #%s%d]!\",\n@@ -17540,7 +17538,7 @@ arm_print_operand_address (FILE *stream, rtx x)\n       else if (GET_CODE (x) == PRE_MODIFY)\n \t{\n \t  asm_fprintf (stream, \"[%r, \", REGNO (XEXP (x, 0)));\n-\t  if (GET_CODE (XEXP (XEXP (x, 1), 1)) == CONST_INT)\n+\t  if (CONST_INT_P (XEXP (XEXP (x, 1), 1)))\n \t    asm_fprintf (stream, \"#%wd]!\",\n \t\t\t INTVAL (XEXP (XEXP (x, 1), 1)));\n \t  else\n@@ -17550,7 +17548,7 @@ arm_print_operand_address (FILE *stream, rtx x)\n       else if (GET_CODE (x) == POST_MODIFY)\n \t{\n \t  asm_fprintf (stream, \"[%r], \", REGNO (XEXP (x, 0)));\n-\t  if (GET_CODE (XEXP (XEXP (x, 1), 1)) == CONST_INT)\n+\t  if (CONST_INT_P (XEXP (XEXP (x, 1), 1)))\n \t    asm_fprintf (stream, \"#%wd\",\n \t\t\t INTVAL (XEXP (XEXP (x, 1), 1)));\n \t  else\n@@ -17561,14 +17559,14 @@ arm_print_operand_address (FILE *stream, rtx x)\n     }\n   else\n     {\n-      if (GET_CODE (x) == REG)\n+      if (REG_P (x))\n \tasm_fprintf (stream, \"[%r]\", REGNO (x));\n       else if (GET_CODE (x) == POST_INC)\n \tasm_fprintf (stream, \"%r!\", REGNO (XEXP (x, 0)));\n       else if (GET_CODE (x) == PLUS)\n \t{\n-\t  gcc_assert (GET_CODE (XEXP (x, 0)) == REG);\n-\t  if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n+\t  gcc_assert (REG_P (XEXP (x, 0)));\n+\t  if (CONST_INT_P (XEXP (x, 1)))\n \t    asm_fprintf (stream, \"[%r, #%wd]\",\n \t\t\t REGNO (XEXP (x, 0)),\n \t\t\t INTVAL (XEXP (x, 1)));\n@@ -17931,7 +17929,7 @@ thumb2_final_prescan_insn (rtx insn)\n     return;\n \n   /* Conditional jumps are implemented directly.  */\n-  if (GET_CODE (insn) == JUMP_INSN)\n+  if (JUMP_P (insn))\n     return;\n \n   predicate = COND_EXEC_TEST (body);\n@@ -17948,7 +17946,7 @@ thumb2_final_prescan_insn (rtx insn)\n \n       /* Jumping into the middle of an IT block is illegal, so a label or\n          barrier terminates the block.  */\n-      if (GET_CODE (insn) != INSN && GET_CODE(insn) != JUMP_INSN)\n+      if (!NONJUMP_INSN_P (insn) && !JUMP_P (insn))\n \tbreak;\n \n       body = PATTERN (insn);\n@@ -17977,7 +17975,7 @@ thumb2_final_prescan_insn (rtx insn)\n       arm_condexec_masklen += n;\n \n       /* A jump must be the last instruction in a conditional block.  */\n-      if (GET_CODE(insn) == JUMP_INSN)\n+      if (JUMP_P (insn))\n \tbreak;\n     }\n   /* Restore recog_data (getting the attributes of other insns can\n@@ -18025,12 +18023,12 @@ arm_final_prescan_insn (rtx insn)\n       if (simplejump_p (insn))\n \t{\n \t  start_insn = next_nonnote_insn (start_insn);\n-\t  if (GET_CODE (start_insn) == BARRIER)\n+\t  if (BARRIER_P (start_insn))\n \t    {\n \t      /* XXX Isn't this always a barrier?  */\n \t      start_insn = next_nonnote_insn (start_insn);\n \t    }\n-\t  if (GET_CODE (start_insn) == CODE_LABEL\n+\t  if (LABEL_P (start_insn)\n \t      && CODE_LABEL_NUMBER (start_insn) == arm_target_label\n \t      && LABEL_NUSES (start_insn) == 1)\n \t    reverse = TRUE;\n@@ -18040,9 +18038,9 @@ arm_final_prescan_insn (rtx insn)\n       else if (ANY_RETURN_P (body))\n         {\n \t  start_insn = next_nonnote_insn (start_insn);\n-\t  if (GET_CODE (start_insn) == BARRIER)\n+\t  if (BARRIER_P (start_insn))\n \t    start_insn = next_nonnote_insn (start_insn);\n-\t  if (GET_CODE (start_insn) == CODE_LABEL\n+\t  if (LABEL_P (start_insn)\n \t      && CODE_LABEL_NUMBER (start_insn) == arm_target_label\n \t      && LABEL_NUSES (start_insn) == 1)\n \t    {\n@@ -18058,7 +18056,7 @@ arm_final_prescan_insn (rtx insn)\n     }\n \n   gcc_assert (!arm_ccfsm_state || reverse);\n-  if (GET_CODE (insn) != JUMP_INSN)\n+  if (!JUMP_P (insn))\n     return;\n \n   /* This jump might be paralleled with a clobber of the condition codes\n@@ -18159,7 +18157,7 @@ arm_final_prescan_insn (rtx insn)\n \t\t if the following two insns are a barrier and the\n \t\t target label.  */\n \t      this_insn = next_nonnote_insn (this_insn);\n-\t      if (this_insn && GET_CODE (this_insn) == BARRIER)\n+\t      if (this_insn && BARRIER_P (this_insn))\n \t\tthis_insn = next_nonnote_insn (this_insn);\n \n \t      if (this_insn && this_insn == label\n@@ -18245,8 +18243,8 @@ arm_final_prescan_insn (rtx insn)\n \t        {\n \t\t  this_insn = next_nonnote_insn (this_insn);\n \t\t  gcc_assert (!this_insn\n-\t\t\t      || (GET_CODE (this_insn) != BARRIER\n-\t\t\t\t  && GET_CODE (this_insn) != CODE_LABEL));\n+\t\t\t      || (!BARRIER_P (this_insn)\n+\t\t\t\t  && !LABEL_P (this_insn)));\n \t        }\n \t      if (!this_insn)\n \t        {\n@@ -18445,7 +18443,7 @@ arm_debugger_arg_offset (int value, rtx addr)\n     return 0;\n \n   /* We can only cope with the case where the address is held in a register.  */\n-  if (GET_CODE (addr) != REG)\n+  if (!REG_P (addr))\n     return 0;\n \n   /* If we are using the frame pointer to point at the argument, then\n@@ -18492,13 +18490,13 @@ arm_debugger_arg_offset (int value, rtx addr)\n \n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n-      if (   GET_CODE (insn) == INSN\n+      if (   NONJUMP_INSN_P (insn)\n \t  && GET_CODE (PATTERN (insn)) == SET\n \t  && REGNO    (XEXP (PATTERN (insn), 0)) == REGNO (addr)\n \t  && GET_CODE (XEXP (PATTERN (insn), 1)) == PLUS\n-\t  && GET_CODE (XEXP (XEXP (PATTERN (insn), 1), 0)) == REG\n+\t  && REG_P (XEXP (XEXP (PATTERN (insn), 1), 0))\n \t  && REGNO    (XEXP (XEXP (PATTERN (insn), 1), 0)) == (unsigned) HARD_FRAME_POINTER_REGNUM\n-\t  && GET_CODE (XEXP (XEXP (PATTERN (insn), 1), 1)) == CONST_INT\n+\t  && CONST_INT_P (XEXP (XEXP (PATTERN (insn), 1), 1))\n \t     )\n \t{\n \t  value = INTVAL (XEXP (XEXP (PATTERN (insn), 1), 1));\n@@ -20873,7 +20871,7 @@ arm_expand_builtin (tree exp,\n       op0 = expand_normal (arg0);\n       op1 = expand_normal (arg1);\n       op2 = expand_normal (arg2);\n-      if (GET_CODE (op2) == CONST_INT)\n+      if (CONST_INT_P (op2))\n         {\n \t  icode = CODE_FOR_iwmmxt_waligni;\n           tmode = insn_data[icode].operand[0].mode;\n@@ -21815,7 +21813,7 @@ thumb_far_jump_used_p (void)\n      insn with the far jump attribute set.  */\n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n-      if (GET_CODE (insn) == JUMP_INSN\n+      if (JUMP_P (insn)\n \t  /* Ignore tablejump patterns.  */\n \t  && GET_CODE (PATTERN (insn)) != ADDR_VEC\n \t  && GET_CODE (PATTERN (insn)) != ADDR_DIFF_VEC\n@@ -22983,7 +22981,7 @@ thumb1_output_interwork (void)\n   const char * name;\n   FILE *f = asm_out_file;\n \n-  gcc_assert (GET_CODE (DECL_RTL (current_function_decl)) == MEM);\n+  gcc_assert (MEM_P (DECL_RTL (current_function_decl)));\n   gcc_assert (GET_CODE (XEXP (DECL_RTL (current_function_decl), 0))\n \t      == SYMBOL_REF);\n   name = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);\n@@ -23027,8 +23025,8 @@ thumb_load_double_from_address (rtx *operands)\n   rtx arg1;\n   rtx arg2;\n \n-  gcc_assert (GET_CODE (operands[0]) == REG);\n-  gcc_assert (GET_CODE (operands[1]) == MEM);\n+  gcc_assert (REG_P (operands[0]));\n+  gcc_assert (MEM_P (operands[1]));\n \n   /* Get the memory address.  */\n   addr = XEXP (operands[1], 0);\n@@ -23068,10 +23066,10 @@ thumb_load_double_from_address (rtx *operands)\n       else\n \tbase = arg1, offset = arg2;\n \n-      gcc_assert (GET_CODE (base) == REG);\n+      gcc_assert (REG_P (base));\n \n       /* Catch the case of <address> = <reg> + <reg> */\n-      if (GET_CODE (offset) == REG)\n+      if (REG_P (offset))\n \t{\n \t  int reg_offset = REGNO (offset);\n \t  int reg_base   = REGNO (base);\n@@ -23671,10 +23669,10 @@ arm_output_load_gr (rtx *operands)\n   rtx wcgr;\n   rtx sum;\n \n-  if (GET_CODE (operands [1]) != MEM\n+  if (!MEM_P (operands [1])\n       || GET_CODE (sum = XEXP (operands [1], 0)) != PLUS\n-      || GET_CODE (reg = XEXP (sum, 0)) != REG\n-      || GET_CODE (offset = XEXP (sum, 1)) != CONST_INT\n+      || !REG_P (reg = XEXP (sum, 0))\n+      || !CONST_INT_P (offset = XEXP (sum, 1))\n       || ((INTVAL (offset) < 1024) && (INTVAL (offset) > -1024)))\n     return \"wldrw%?\\t%0, %1\";\n \n@@ -23809,7 +23807,7 @@ arm_no_early_alu_shift_dep (rtx producer, rtx consumer)\n   /* This is either an actual independent shift, or a shift applied to\n      the first operand of another operation.  We want the whole shift\n      operation.  */\n-  if (GET_CODE (early_op) == REG)\n+  if (REG_P (early_op))\n     early_op = op;\n \n   return !reg_overlap_mentioned_p (value, early_op);\n@@ -23842,7 +23840,7 @@ arm_no_early_alu_shift_value_dep (rtx producer, rtx consumer)\n   /* This is either an actual independent shift, or a shift applied to\n      the first operand of another operation.  We want the value being\n      shifted, in either case.  */\n-  if (GET_CODE (early_op) != REG)\n+  if (!REG_P (early_op))\n     early_op = XEXP (early_op, 0);\n \n   return !reg_overlap_mentioned_p (value, early_op);\n@@ -24342,7 +24340,7 @@ arm_unwind_emit_sequence (FILE * asm_out_file, rtx p)\n \n   /* First insn will adjust the stack pointer.  */\n   if (GET_CODE (e) != SET\n-      || GET_CODE (XEXP (e, 0)) != REG\n+      || !REG_P (XEXP (e, 0))\n       || REGNO (XEXP (e, 0)) != SP_REGNUM\n       || GET_CODE (XEXP (e, 1)) != PLUS)\n     abort ();\n@@ -24386,8 +24384,8 @@ arm_unwind_emit_sequence (FILE * asm_out_file, rtx p)\n          Where <addr> is (reg:SP) or (plus (reg:SP) (const_int)).  */\n       e = XVECEXP (p, 0, i);\n       if (GET_CODE (e) != SET\n-\t  || GET_CODE (XEXP (e, 0)) != MEM\n-\t  || GET_CODE (XEXP (e, 1)) != REG)\n+\t  || !MEM_P (XEXP (e, 0))\n+\t  || !REG_P (XEXP (e, 1)))\n \tabort ();\n \n       reg = REGNO (XEXP (e, 1));\n@@ -24409,14 +24407,14 @@ arm_unwind_emit_sequence (FILE * asm_out_file, rtx p)\n       if (GET_CODE (e) == PLUS)\n \t{\n \t  offset += reg_size;\n-\t  if (GET_CODE (XEXP (e, 0)) != REG\n+\t  if (!REG_P (XEXP (e, 0))\n \t      || REGNO (XEXP (e, 0)) != SP_REGNUM\n-\t      || GET_CODE (XEXP (e, 1)) != CONST_INT\n+\t      || !CONST_INT_P (XEXP (e, 1))\n \t      || offset != INTVAL (XEXP (e, 1)))\n \t    abort ();\n \t}\n       else if (i != 1\n-\t       || GET_CODE (e) != REG\n+\t       || !REG_P (e)\n \t       || REGNO (e) != SP_REGNUM)\n \tabort ();\n #endif\n@@ -24440,7 +24438,7 @@ arm_unwind_emit_set (FILE * asm_out_file, rtx p)\n     case MEM:\n       /* Pushing a single register.  */\n       if (GET_CODE (XEXP (e0, 0)) != PRE_DEC\n-\t  || GET_CODE (XEXP (XEXP (e0, 0), 0)) != REG\n+\t  || !REG_P (XEXP (XEXP (e0, 0), 0))\n \t  || REGNO (XEXP (XEXP (e0, 0), 0)) != SP_REGNUM)\n \tabort ();\n \n@@ -24457,9 +24455,9 @@ arm_unwind_emit_set (FILE * asm_out_file, rtx p)\n \t{\n \t  /* A stack increment.  */\n \t  if (GET_CODE (e1) != PLUS\n-\t      || GET_CODE (XEXP (e1, 0)) != REG\n+\t      || !REG_P (XEXP (e1, 0))\n \t      || REGNO (XEXP (e1, 0)) != SP_REGNUM\n-\t      || GET_CODE (XEXP (e1, 1)) != CONST_INT)\n+\t      || !CONST_INT_P (XEXP (e1, 1)))\n \t    abort ();\n \n \t  asm_fprintf (asm_out_file, \"\\t.pad #%wd\\n\",\n@@ -24471,16 +24469,16 @@ arm_unwind_emit_set (FILE * asm_out_file, rtx p)\n \n \t  if (GET_CODE (e1) == PLUS)\n \t    {\n-\t      if (GET_CODE (XEXP (e1, 0)) != REG\n-\t\t  || GET_CODE (XEXP (e1, 1)) != CONST_INT)\n+\t      if (!REG_P (XEXP (e1, 0))\n+\t\t  || !CONST_INT_P (XEXP (e1, 1)))\n \t\tabort ();\n \t      reg = REGNO (XEXP (e1, 0));\n \t      offset = INTVAL (XEXP (e1, 1));\n \t      asm_fprintf (asm_out_file, \"\\t.setfp %r, %r, #%wd\\n\",\n \t\t\t   HARD_FRAME_POINTER_REGNUM, reg,\n \t\t\t   offset);\n \t    }\n-\t  else if (GET_CODE (e1) == REG)\n+\t  else if (REG_P (e1))\n \t    {\n \t      reg = REGNO (e1);\n \t      asm_fprintf (asm_out_file, \"\\t.setfp %r, %r\\n\",\n@@ -24489,15 +24487,15 @@ arm_unwind_emit_set (FILE * asm_out_file, rtx p)\n \t  else\n \t    abort ();\n \t}\n-      else if (GET_CODE (e1) == REG && REGNO (e1) == SP_REGNUM)\n+      else if (REG_P (e1) && REGNO (e1) == SP_REGNUM)\n \t{\n \t  /* Move from sp to reg.  */\n \t  asm_fprintf (asm_out_file, \"\\t.movsp %r\\n\", REGNO (e0));\n \t}\n      else if (GET_CODE (e1) == PLUS\n-\t      && GET_CODE (XEXP (e1, 0)) == REG\n+\t      && REG_P (XEXP (e1, 0))\n \t      && REGNO (XEXP (e1, 0)) == SP_REGNUM\n-\t      && GET_CODE (XEXP (e1, 1)) == CONST_INT)\n+\t      && CONST_INT_P (XEXP (e1, 1)))\n \t{\n \t  /* Set reg to offset from sp.  */\n \t  asm_fprintf (asm_out_file, \"\\t.movsp %r, #%d\\n\",\n@@ -24607,7 +24605,7 @@ arm_output_ttype (rtx x)\n   fputs (\"\\t.word\\t\", asm_out_file);\n   output_addr_const (asm_out_file, x);\n   /* Use special relocations for symbol references.  */\n-  if (GET_CODE (x) != CONST_INT)\n+  if (!CONST_INT_P (x))\n     fputs (\"(TARGET2)\", asm_out_file);\n   fputc ('\\n', asm_out_file);\n \n@@ -25294,7 +25292,7 @@ vfp3_const_double_for_fract_bits (rtx operand)\n {\n   REAL_VALUE_TYPE r0;\n   \n-  if (GET_CODE (operand) != CONST_DOUBLE)\n+  if (!CONST_DOUBLE_P (operand))\n     return 0;\n   \n   REAL_VALUE_FROM_CONST_DOUBLE (r0, operand);\n@@ -26182,7 +26180,7 @@ arm_vectorize_vec_perm_const_ok (enum machine_mode vmode,\n bool\n arm_autoinc_modes_ok_p (enum machine_mode mode, enum arm_auto_incmodes code)\n {\n-  /* If we are soft float and we do not have ldrd \n+  /* If we are soft float and we do not have ldrd\n      then all auto increment forms are ok.  */\n   if (TARGET_SOFT_FLOAT && (TARGET_LDRD || GET_MODE_SIZE (mode) <= 4))\n     return true;\n@@ -26197,15 +26195,15 @@ arm_autoinc_modes_ok_p (enum machine_mode mode, enum arm_auto_incmodes code)\n \t{\n \t  if (code != ARM_PRE_DEC)\n \t    return true;\n-\t  else \n+\t  else\n \t    return false;\n \t}\n       \n       return true;\n \n     case ARM_POST_DEC:\n     case ARM_PRE_INC:\n-      /* Without LDRD and mode size greater than \n+      /* Without LDRD and mode size greater than\n \t word size, there is no point in auto-incrementing\n          because ldm and stm will not have these forms.  */\n       if (!TARGET_LDRD && GET_MODE_SIZE (mode) > 4)\n@@ -26478,7 +26476,7 @@ arm_emit_coreregs_64bit_shift (enum rtx_code code, rtx out, rtx in,\n }\n \n \n-/* Returns true if a valid comparison operation and makes \n+/* Returns true if a valid comparison operation and makes\n    the operands in a form that is valid.  */\n bool\n arm_validize_comparison (rtx *comparison, rtx * op1, rtx * op2)\n@@ -26511,7 +26509,7 @@ arm_validize_comparison (rtx *comparison, rtx * op1, rtx * op2)\n       if (!cmpdi_operand (*op2, mode))\n \t*op2 = force_reg (mode, *op2);\n       return true;\n-      \n+\n     case SFmode:\n     case DFmode:\n       if (!arm_float_compare_operand (*op1, mode))\n@@ -26522,7 +26520,7 @@ arm_validize_comparison (rtx *comparison, rtx * op1, rtx * op2)\n     default:\n       break;\n     }\n-  \n+\n   return false;\n \n }"}, {"sha": "5f34f2a8100ecff2964b0576edb361518c1d30c1", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d435a4be2a1fddc642ddaa4de055178f152ecf1b/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d435a4be2a1fddc642ddaa4de055178f152ecf1b/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=d435a4be2a1fddc642ddaa4de055178f152ecf1b", "patch": "@@ -1262,8 +1262,8 @@ enum reg_class\n      && CONSTANT_P (X))\t\t\t\t\t\t\\\n     ? GENERAL_REGS :\t\t\t\t\t\t\\\n     (((MODE) == HImode && ! arm_arch4\t\t\t\t\\\n-      && (GET_CODE (X) == MEM\t\t\t\t\t\\\n-\t  || ((GET_CODE (X) == REG || GET_CODE (X) == SUBREG)\t\\\n+      && (MEM_P (X)\t\t\t\t\t\\\n+\t  || ((REG_P (X) || GET_CODE (X) == SUBREG)\t\\\n \t      && true_regnum (X) == -1)))\t\t\t\\\n      ? GENERAL_REGS : NO_REGS)\t\t\t\t\t\\\n     : THUMB_SECONDARY_INPUT_RELOAD_CLASS (CLASS, MODE, X)))\n@@ -1909,10 +1909,10 @@ enum arm_auto_incmodes\n   REG_OK_FOR_INDEX_P (X)\n \f\n #define ARM_BASE_REGISTER_RTX_P(X)  \\\n-  (GET_CODE (X) == REG && ARM_REG_OK_FOR_BASE_P (X))\n+  (REG_P (X) && ARM_REG_OK_FOR_BASE_P (X))\n \n #define ARM_INDEX_REGISTER_RTX_P(X)  \\\n-  (GET_CODE (X) == REG && ARM_REG_OK_FOR_INDEX_P (X))\n+  (REG_P (X) && ARM_REG_OK_FOR_INDEX_P (X))\n \f\n /* Specify the machine mode that this machine uses\n    for the index in the tablejump instruction.  */"}, {"sha": "a60e659bf68be80a1325e8093647874f7a0de7e3", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 103, "deletions": 104, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d435a4be2a1fddc642ddaa4de055178f152ecf1b/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d435a4be2a1fddc642ddaa4de055178f152ecf1b/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=d435a4be2a1fddc642ddaa4de055178f152ecf1b", "patch": "@@ -607,9 +607,9 @@\n   \"\n   if (TARGET_THUMB1)\n     {\n-      if (GET_CODE (operands[1]) != REG)\n+      if (!REG_P (operands[1]))\n         operands[1] = force_reg (DImode, operands[1]);\n-      if (GET_CODE (operands[2]) != REG)\n+      if (!REG_P (operands[2]))\n         operands[2] = force_reg (DImode, operands[2]);\n      }\n   \"\n@@ -716,7 +716,7 @@\n \t\t (match_operand:SI 2 \"reg_or_int_operand\" \"\")))]\n   \"TARGET_EITHER\"\n   \"\n-  if (TARGET_32BIT && GET_CODE (operands[2]) == CONST_INT)\n+  if (TARGET_32BIT && CONST_INT_P (operands[2]))\n     {\n       arm_split_constant (PLUS, SImode, NULL_RTX,\n \t                  INTVAL (operands[2]), operands[0], operands[1],\n@@ -764,7 +764,7 @@\n    subw%?\\\\t%0, %1, #%n2\n    #\"\n   \"TARGET_32BIT\n-   && GET_CODE (operands[2]) == CONST_INT\n+   && CONST_INT_P (operands[2])\n    && !const_ok_for_op (INTVAL (operands[2]), PLUS)\n    && (reload_completed || !arm_eliminable_register (operands[1]))\"\n   [(clobber (const_int 0))]\n@@ -799,7 +799,7 @@\n      \\\"#\\\"\n    };\n    if ((which_alternative == 2 || which_alternative == 6)\n-       && GET_CODE (operands[2]) == CONST_INT\n+       && CONST_INT_P (operands[2])\n        && INTVAL (operands[2]) < 0)\n      return \\\"sub\\\\t%0, %1, #%n2\\\";\n    return asms[which_alternative];\n@@ -1111,9 +1111,9 @@\n   \"\n   if (TARGET_THUMB1)\n     {\n-      if (GET_CODE (operands[1]) != REG)\n+      if (!REG_P (operands[1]))\n         operands[1] = force_reg (DImode, operands[1]);\n-      if (GET_CODE (operands[2]) != REG)\n+      if (!REG_P (operands[2]))\n         operands[2] = force_reg (DImode, operands[2]);\n      }\t\n   \"\n@@ -1207,7 +1207,7 @@\n \t\t  (match_operand:SI 2 \"s_register_operand\" \"\")))]\n   \"TARGET_EITHER\"\n   \"\n-  if (GET_CODE (operands[1]) == CONST_INT)\n+  if (CONST_INT_P (operands[1]))\n     {\n       if (TARGET_32BIT)\n         {\n@@ -1242,7 +1242,7 @@\n    sub%?\\\\t%0, %1, %2\n    sub%?\\\\t%0, %1, %2\n    #\"\n-  \"&& (GET_CODE (operands[1]) == CONST_INT\n+  \"&& (CONST_INT_P (operands[1])\n        && !const_ok_for_arm (INTVAL (operands[1])))\"\n   [(clobber (const_int 0))]\n   \"\n@@ -2097,7 +2097,7 @@\n   \"\n   if (TARGET_32BIT)\n     {\n-      if (GET_CODE (operands[2]) == CONST_INT)\n+      if (CONST_INT_P (operands[2]))\n         {\n \t  if (INTVAL (operands[2]) == 255 && arm_arch6)\n \t    {\n@@ -2116,7 +2116,7 @@\n     }\n   else /* TARGET_THUMB1 */\n     {\n-      if (GET_CODE (operands[2]) != CONST_INT)\n+      if (!CONST_INT_P (operands[2]))\n         {\n           rtx tmp = force_reg (SImode, operands[2]);\n \t  if (rtx_equal_p (operands[0], operands[1]))\n@@ -2179,7 +2179,7 @@\n    bic%?\\\\t%0, %1, #%B2\n    #\"\n   \"TARGET_32BIT\n-   && GET_CODE (operands[2]) == CONST_INT\n+   && CONST_INT_P (operands[2])\n    && !(const_ok_for_arm (INTVAL (operands[2]))\n \t|| const_ok_for_arm (~INTVAL (operands[2])))\"\n   [(clobber (const_int 0))]\n@@ -2512,7 +2512,7 @@\n \t  {\n \t    bool use_bfi = TRUE;\n \n-\t    if (GET_CODE (operands[3]) == CONST_INT)\n+\t    if (CONST_INT_P (operands[3]))\n \t      {\n \t\tHOST_WIDE_INT val = INTVAL (operands[3]) & mask;\n \n@@ -2530,7 +2530,7 @@\n \n \t    if (use_bfi)\n \t      {\n-\t\tif (GET_CODE (operands[3]) != REG)\n+\t\tif (!REG_P (operands[3]))\n \t\t  operands[3] = force_reg (SImode, operands[3]);\n \n \t\temit_insn (gen_insv_t2 (operands[0], operands[1], operands[2],\n@@ -2558,7 +2558,7 @@\n     else\n       subtarget = target;    \n \n-    if (GET_CODE (operands[3]) == CONST_INT)\n+    if (CONST_INT_P (operands[3]))\n       {\n \t/* Since we are inserting a known constant, we may be able to\n \t   reduce the number of bits that we have to clear so that\n@@ -2625,7 +2625,7 @@\n \t/* Mask out any bits in operand[3] that are not needed.  */\n \t   emit_insn (gen_andsi3 (op1, operands[3], op0));\n \n-\tif (GET_CODE (op0) == CONST_INT\n+\tif (CONST_INT_P (op0)\n \t    && (const_ok_for_arm (mask << start_bit)\n \t\t|| const_ok_for_arm (~(mask << start_bit))))\n \t  {\n@@ -2634,7 +2634,7 @@\n \t  }\n \telse\n \t  {\n-\t    if (GET_CODE (op0) == CONST_INT)\n+\t    if (CONST_INT_P (op0))\n \t      {\n \t\trtx tmp = gen_reg_rtx (SImode);\n \n@@ -2871,7 +2871,7 @@\n \t\t(match_operand:SI 2 \"reg_or_int_operand\" \"\")))]\n   \"TARGET_EITHER\"\n   \"\n-  if (GET_CODE (operands[2]) == CONST_INT)\n+  if (CONST_INT_P (operands[2]))\n     {\n       if (TARGET_32BIT)\n         {\n@@ -2905,7 +2905,7 @@\n    orn%?\\\\t%0, %1, #%B2\n    #\"\n   \"TARGET_32BIT\n-   && GET_CODE (operands[2]) == CONST_INT\n+   && CONST_INT_P (operands[2])\n    && !(const_ok_for_arm (INTVAL (operands[2]))\n         || (TARGET_THUMB2 && const_ok_for_arm (~INTVAL (operands[2]))))\"\n   [(clobber (const_int 0))]\n@@ -3010,7 +3010,7 @@\n \t(xor:SI (match_operand:SI 1 \"s_register_operand\" \"\")\n \t\t(match_operand:SI 2 \"reg_or_int_operand\" \"\")))]\n   \"TARGET_EITHER\"\n-  \"if (GET_CODE (operands[2]) == CONST_INT)\n+  \"if (CONST_INT_P (operands[2]))\n     {\n       if (TARGET_32BIT)\n         {\n@@ -3042,7 +3042,7 @@\n    eor%?\\\\t%0, %1, %2\n    #\"\n   \"TARGET_32BIT\n-   && GET_CODE (operands[2]) == CONST_INT\n+   && CONST_INT_P (operands[2])\n    && !const_ok_for_arm (INTVAL (operands[2]))\"\n   [(clobber (const_int 0))]\n {\n@@ -3542,7 +3542,7 @@\n \t\t   (match_operand:SI 2 \"arm_rhs_operand\" \"\")))]\n   \"TARGET_EITHER\"\n   \"\n-  if (GET_CODE (operands[2]) == CONST_INT\n+  if (CONST_INT_P (operands[2])\n       && ((unsigned HOST_WIDE_INT) INTVAL (operands[2])) > 31)\n     {\n       emit_insn (gen_movsi (operands[0], const0_rtx));\n@@ -3617,7 +3617,7 @@\n \t\t     (match_operand:SI 2 \"arm_rhs_operand\" \"\")))]\n   \"TARGET_EITHER\"\n   \"\n-  if (GET_CODE (operands[2]) == CONST_INT\n+  if (CONST_INT_P (operands[2])\n       && ((unsigned HOST_WIDE_INT) INTVAL (operands[2])) > 31)\n     operands[2] = GEN_INT (31);\n   \"\n@@ -3689,7 +3689,7 @@\n \t\t     (match_operand:SI 2 \"arm_rhs_operand\" \"\")))]\n   \"TARGET_EITHER\"\n   \"\n-  if (GET_CODE (operands[2]) == CONST_INT\n+  if (CONST_INT_P (operands[2])\n       && ((unsigned HOST_WIDE_INT) INTVAL (operands[2])) > 31)\n     {\n       emit_insn (gen_movsi (operands[0], const0_rtx));\n@@ -3713,7 +3713,7 @@\n \t\t     (match_operand:SI 2 \"reg_or_int_operand\" \"\")))]\n   \"TARGET_32BIT\"\n   \"\n-  if (GET_CODE (operands[2]) == CONST_INT)\n+  if (CONST_INT_P (operands[2]))\n     operands[2] = GEN_INT ((32 - INTVAL (operands[2])) % 32);\n   else\n     {\n@@ -3732,13 +3732,13 @@\n   \"\n   if (TARGET_32BIT)\n     {\n-      if (GET_CODE (operands[2]) == CONST_INT\n+      if (CONST_INT_P (operands[2])\n           && ((unsigned HOST_WIDE_INT) INTVAL (operands[2])) > 31)\n         operands[2] = GEN_INT (INTVAL (operands[2]) % 32);\n     }\n   else /* TARGET_THUMB1 */\n     {\n-      if (GET_CODE (operands [2]) == CONST_INT)\n+      if (CONST_INT_P (operands [2]))\n         operands [2] = force_reg (SImode, operands[2]);\n     }\n   \"\n@@ -4595,7 +4595,7 @@\n       rtx a = XEXP (mem, 0);\n \n       /* This can happen due to bugs in reload.  */\n-      if (GET_CODE (a) == REG && REGNO (a) == SP_REGNUM)\n+      if (REG_P (a) && REGNO (a) == SP_REGNUM)\n         {\n           rtx ops[2];\n           ops[0] = operands[0];\n@@ -4653,7 +4653,7 @@\n \t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"\")))]\n   \"TARGET_EITHER\"\n {\n-  if (TARGET_ARM && !arm_arch6 && GET_CODE (operands[1]) != MEM)\n+  if (TARGET_ARM && !arm_arch6 && !MEM_P (operands[1]))\n     {\n       emit_insn (gen_andsi3 (operands[0],\n \t\t\t     gen_lowpart (SImode, operands[1]),\n@@ -4746,7 +4746,7 @@\n   [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n \t(zero_extend:SI (subreg:QI (match_operand:SI 1 \"\" \"\") 0)))\n    (clobber (match_operand:SI 2 \"s_register_operand\" \"\"))]\n-  \"TARGET_32BIT && (GET_CODE (operands[1]) != MEM) && ! BYTES_BIG_ENDIAN\"\n+  \"TARGET_32BIT && (!MEM_P (operands[1])) && ! BYTES_BIG_ENDIAN\"\n   [(set (match_dup 2) (match_dup 1))\n    (set (match_dup 0) (and:SI (match_dup 2) (const_int 255)))]\n   \"\"\n@@ -4756,7 +4756,7 @@\n   [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n \t(zero_extend:SI (subreg:QI (match_operand:SI 1 \"\" \"\") 3)))\n    (clobber (match_operand:SI 2 \"s_register_operand\" \"\"))]\n-  \"TARGET_32BIT && (GET_CODE (operands[1]) != MEM) && BYTES_BIG_ENDIAN\"\n+  \"TARGET_32BIT && (!MEM_P (operands[1])) && BYTES_BIG_ENDIAN\"\n   [(set (match_dup 2) (match_dup 1))\n    (set (match_dup 0) (and:SI (match_dup 2) (const_int 255)))]\n   \"\"\n@@ -4872,10 +4872,10 @@\n         rtx b = XEXP (mem, 1);\n \n         if (GET_CODE (a) == LABEL_REF\n-\t    && GET_CODE (b) == CONST_INT)\n+\t    && CONST_INT_P (b))\n           return \\\"ldr\\\\t%0, %1\\\";\n \n-        if (GET_CODE (b) == REG)\n+        if (REG_P (b))\n           return \\\"ldrsh\\\\t%0, %1\\\";\n \t  \n         ops[1] = a;\n@@ -4887,7 +4887,7 @@\n         ops[2] = const0_rtx;\n       }\n       \n-    gcc_assert (GET_CODE (ops[1]) == REG);\n+    gcc_assert (REG_P (ops[1]));\n \n     ops[0] = operands[0];\n     if (reg_mentioned_p (operands[2], ops[1]))\n@@ -4998,7 +4998,7 @@\n   \"TARGET_ARM\"\n   \"\n   {\n-    if (arm_arch4 && GET_CODE (operands[1]) == MEM)\n+    if (arm_arch4 && MEM_P (operands[1]))\n       {\n \temit_insn (gen_rtx_SET (VOIDmode,\n \t\t\t\toperands[0],\n@@ -5235,11 +5235,11 @@\n ;;{\n ;;  rtx insn;\n ;;\n-;;  if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[1]) == MEM)\n+;;  if (MEM_P (operands[0]) && MEM_P (operands[1]))\n ;;    operands[1] = copy_to_reg (operands[1]);\n-;;  if (GET_CODE (operands[0]) == MEM)\n+;;  if (MEM_P (operands[0]))\n ;;    insn = gen_storeti (XEXP (operands[0], 0), operands[1]);\n-;;  else if (GET_CODE (operands[1]) == MEM)\n+;;  else if (MEM_P (operands[1]))\n ;;    insn = gen_loadti (operands[0], XEXP (operands[1], 0));\n ;;  else\n ;;    FAIL;\n@@ -5280,7 +5280,7 @@\n   \"\n   if (can_create_pseudo_p ())\n     {\n-      if (GET_CODE (operands[0]) != REG)\n+      if (!REG_P (operands[0]))\n \toperands[1] = force_reg (DImode, operands[1]);\n     }\n   \"\n@@ -5462,10 +5462,10 @@\n   if (TARGET_32BIT)\n     {\n       /* Everything except mem = const or mem = mem can be done easily.  */\n-      if (GET_CODE (operands[0]) == MEM)\n+      if (MEM_P (operands[0]))\n         operands[1] = force_reg (SImode, operands[1]);\n       if (arm_general_register_operand (operands[0], SImode)\n-\t  && GET_CODE (operands[1]) == CONST_INT\n+\t  && CONST_INT_P (operands[1])\n           && !(const_ok_for_arm (INTVAL (operands[1]))\n                || const_ok_for_arm (~INTVAL (operands[1]))))\n         {\n@@ -5479,7 +5479,7 @@\n     {\n       if (can_create_pseudo_p ())\n         {\n-          if (GET_CODE (operands[0]) != REG)\n+          if (!REG_P (operands[0]))\n \t    operands[1] = force_reg (SImode, operands[1]);\n         }\n     }\n@@ -5886,7 +5886,7 @@\n     rtx addr = XEXP (op1, 0);\n     enum rtx_code code = GET_CODE (addr);\n \n-    if ((code == PLUS && GET_CODE (XEXP (addr, 1)) != CONST_INT)\n+    if ((code == PLUS && !CONST_INT_P (XEXP (addr, 1)))\n \t|| code == MINUS)\n       op1 = replace_equiv_address (operands[1], force_reg (SImode, addr));\n \n@@ -5911,7 +5911,7 @@\n     rtx addr = XEXP (op1, 0);\n     enum rtx_code code = GET_CODE (addr);\n \n-    if ((code == PLUS && GET_CODE (XEXP (addr, 1)) != CONST_INT)\n+    if ((code == PLUS && !CONST_INT_P (XEXP (addr, 1)))\n \t|| code == MINUS)\n       op1 = replace_equiv_address (op1, force_reg (SImode, addr));\n \n@@ -5937,7 +5937,7 @@\n     rtx op0 = operands[0];\n     enum rtx_code code = GET_CODE (addr);\n \n-    if ((code == PLUS && GET_CODE (XEXP (addr, 1)) != CONST_INT)\n+    if ((code == PLUS && !CONST_INT_P (XEXP (addr, 1)))\n \t|| code == MINUS)\n       op0 = replace_equiv_address (op0, force_reg (SImode, addr));\n \n@@ -5991,18 +5991,18 @@\n     {\n       if (can_create_pseudo_p ())\n         {\n-          if (GET_CODE (operands[0]) == MEM)\n+          if (MEM_P (operands[0]))\n \t    {\n \t      if (arm_arch4)\n \t        {\n \t          emit_insn (gen_storehi_single_op (operands[0], operands[1]));\n \t          DONE;\n \t        }\n-\t      if (GET_CODE (operands[1]) == CONST_INT)\n+\t      if (CONST_INT_P (operands[1]))\n \t        emit_insn (gen_storeinthi (operands[0], operands[1]));\n \t      else\n \t        {\n-\t          if (GET_CODE (operands[1]) == MEM)\n+\t          if (MEM_P (operands[1]))\n \t\t    operands[1] = force_reg (HImode, operands[1]);\n \t          if (BYTES_BIG_ENDIAN)\n \t\t    emit_insn (gen_storehi_bigend (operands[1], operands[0]));\n@@ -6012,7 +6012,7 @@\n \t      DONE;\n \t    }\n           /* Sign extend a constant, and keep it in an SImode reg.  */\n-          else if (GET_CODE (operands[1]) == CONST_INT)\n+          else if (CONST_INT_P (operands[1]))\n \t    {\n \t      rtx reg = gen_reg_rtx (SImode);\n \t      HOST_WIDE_INT val = INTVAL (operands[1]) & 0xffff;\n@@ -6034,7 +6034,7 @@\n \t      operands[1] = gen_lowpart (HImode, reg);\n \t    }\n \t  else if (arm_arch4 && optimize && can_create_pseudo_p ()\n-\t\t   && GET_CODE (operands[1]) == MEM)\n+\t\t   && MEM_P (operands[1]))\n \t    {\n \t      rtx reg = gen_reg_rtx (SImode);\n \n@@ -6043,18 +6043,17 @@\n \t    }\n           else if (!arm_arch4)\n \t    {\n-\t      if (GET_CODE (operands[1]) == MEM)\n+\t      if (MEM_P (operands[1]))\n \t        {\n \t\t  rtx base;\n \t\t  rtx offset = const0_rtx;\n \t\t  rtx reg = gen_reg_rtx (SImode);\n \n-\t\t  if ((GET_CODE (base = XEXP (operands[1], 0)) == REG\n+\t\t  if ((REG_P (base = XEXP (operands[1], 0))\n \t\t       || (GET_CODE (base) == PLUS\n-\t\t\t   && (GET_CODE (offset = XEXP (base, 1))\n-\t\t\t       == CONST_INT)\n+\t\t\t   && (CONST_INT_P (offset = XEXP (base, 1)))\n                            && ((INTVAL(offset) & 1) != 1)\n-\t\t\t   && GET_CODE (base = XEXP (base, 0)) == REG))\n+\t\t\t   && REG_P (base = XEXP (base, 0))))\n \t\t      && REGNO_POINTER_ALIGN (REGNO (base)) >= 32)\n \t\t    {\n \t\t      rtx new_rtx;\n@@ -6080,13 +6079,13 @@\n \t   }\n         }\n       /* Handle loading a large integer during reload.  */\n-      else if (GET_CODE (operands[1]) == CONST_INT\n+      else if (CONST_INT_P (operands[1])\n \t       && !const_ok_for_arm (INTVAL (operands[1]))\n \t       && !const_ok_for_arm (~INTVAL (operands[1])))\n         {\n           /* Writing a constant to memory needs a scratch, which should\n \t     be handled with SECONDARY_RELOADs.  */\n-          gcc_assert (GET_CODE (operands[0]) == REG);\n+          gcc_assert (REG_P (operands[0]));\n \n           operands[0] = gen_rtx_SUBREG (SImode, operands[0], 0);\n           emit_insn (gen_movsi (operands[0], operands[1]));\n@@ -6098,10 +6097,10 @@\n       /* Thumb-2 can do everything except mem=mem and mem=const easily.  */\n       if (can_create_pseudo_p ())\n \t{\n-\t  if (GET_CODE (operands[0]) != REG)\n+\t  if (!REG_P (operands[0]))\n \t    operands[1] = force_reg (HImode, operands[1]);\n           /* Zero extend a constant, and keep it in an SImode reg.  */\n-          else if (GET_CODE (operands[1]) == CONST_INT)\n+          else if (CONST_INT_P (operands[1]))\n \t    {\n \t      rtx reg = gen_reg_rtx (SImode);\n \t      HOST_WIDE_INT val = INTVAL (operands[1]) & 0xffff;\n@@ -6115,7 +6114,7 @@\n     {\n       if (can_create_pseudo_p ())\n         {\n-\t  if (GET_CODE (operands[1]) == CONST_INT)\n+\t  if (CONST_INT_P (operands[1]))\n \t    {\n \t      rtx reg = gen_reg_rtx (SImode);\n \n@@ -6131,39 +6130,39 @@\n \t     fixup_stack_1, by checking for other kinds of invalid addresses,\n \t     e.g. a bare reference to a virtual register.  This may confuse the\n \t     alpha though, which must handle this case differently.  */\n-          if (GET_CODE (operands[0]) == MEM\n+          if (MEM_P (operands[0])\n \t      && !memory_address_p (GET_MODE (operands[0]),\n \t\t\t\t    XEXP (operands[0], 0)))\n \t    operands[0]\n \t      = replace_equiv_address (operands[0],\n \t\t\t\t       copy_to_reg (XEXP (operands[0], 0)));\n    \n-          if (GET_CODE (operands[1]) == MEM\n+          if (MEM_P (operands[1])\n \t      && !memory_address_p (GET_MODE (operands[1]),\n \t\t\t\t    XEXP (operands[1], 0)))\n \t    operands[1]\n \t      = replace_equiv_address (operands[1],\n \t\t\t\t       copy_to_reg (XEXP (operands[1], 0)));\n \n-\t  if (GET_CODE (operands[1]) == MEM && optimize > 0)\n+\t  if (MEM_P (operands[1]) && optimize > 0)\n \t    {\n \t      rtx reg = gen_reg_rtx (SImode);\n \n \t      emit_insn (gen_zero_extendhisi2 (reg, operands[1]));\n \t      operands[1] = gen_lowpart (HImode, reg);\n \t    }\n \n-          if (GET_CODE (operands[0]) == MEM)\n+          if (MEM_P (operands[0]))\n \t    operands[1] = force_reg (HImode, operands[1]);\n         }\n-      else if (GET_CODE (operands[1]) == CONST_INT\n+      else if (CONST_INT_P (operands[1])\n \t        && !satisfies_constraint_I (operands[1]))\n         {\n \t  /* Handle loading a large integer during reload.  */\n \n           /* Writing a constant to memory needs a scratch, which should\n \t     be handled with SECONDARY_RELOADs.  */\n-          gcc_assert (GET_CODE (operands[0]) == REG);\n+          gcc_assert (REG_P (operands[0]));\n \n           operands[0] = gen_rtx_SUBREG (SImode, operands[0], 0);\n           emit_insn (gen_movsi (operands[0], operands[1]));\n@@ -6192,7 +6191,7 @@\n       /* The stack pointer can end up being taken as an index register.\n           Catch this case here and deal with it.  */\n       if (GET_CODE (XEXP (operands[1], 0)) == PLUS\n-\t  && GET_CODE (XEXP (XEXP (operands[1], 0), 0)) == REG\n+\t  && REG_P (XEXP (XEXP (operands[1], 0), 0))\n \t  && REGNO    (XEXP (XEXP (operands[1], 0), 0)) == SP_REGNUM)\n         {\n \t  rtx ops[2];\n@@ -6347,7 +6346,7 @@\n \n   if (can_create_pseudo_p ())\n     {\n-      if (GET_CODE (operands[1]) == CONST_INT)\n+      if (CONST_INT_P (operands[1]))\n \t{\n \t  rtx reg = gen_reg_rtx (SImode);\n \n@@ -6370,40 +6369,40 @@\n \t     fixup_stack_1, by checking for other kinds of invalid addresses,\n \t     e.g. a bare reference to a virtual register.  This may confuse the\n \t     alpha though, which must handle this case differently.  */\n-          if (GET_CODE (operands[0]) == MEM\n+          if (MEM_P (operands[0])\n \t      && !memory_address_p (GET_MODE (operands[0]),\n \t\t  \t\t     XEXP (operands[0], 0)))\n \t    operands[0]\n \t      = replace_equiv_address (operands[0],\n \t\t\t\t       copy_to_reg (XEXP (operands[0], 0)));\n-          if (GET_CODE (operands[1]) == MEM\n+          if (MEM_P (operands[1])\n \t      && !memory_address_p (GET_MODE (operands[1]),\n \t\t\t\t    XEXP (operands[1], 0)))\n \t     operands[1]\n \t       = replace_equiv_address (operands[1],\n \t\t\t\t\tcopy_to_reg (XEXP (operands[1], 0)));\n \t}\n \n-      if (GET_CODE (operands[1]) == MEM && optimize > 0)\n+      if (MEM_P (operands[1]) && optimize > 0)\n \t{\n \t  rtx reg = gen_reg_rtx (SImode);\n \n \t  emit_insn (gen_zero_extendqisi2 (reg, operands[1]));\n \t  operands[1] = gen_lowpart (QImode, reg);\n \t}\n \n-      if (GET_CODE (operands[0]) == MEM)\n+      if (MEM_P (operands[0]))\n \toperands[1] = force_reg (QImode, operands[1]);\n     }\n   else if (TARGET_THUMB\n-\t   && GET_CODE (operands[1]) == CONST_INT\n+\t   && CONST_INT_P (operands[1])\n \t   && !satisfies_constraint_I (operands[1]))\n     {\n       /* Handle loading a large integer during reload.  */\n \n       /* Writing a constant to memory needs a scratch, which should\n \t be handled with SECONDARY_RELOADs.  */\n-      gcc_assert (GET_CODE (operands[0]) == REG);\n+      gcc_assert (REG_P (operands[0]));\n \n       operands[0] = gen_rtx_SUBREG (SImode, operands[0], 0);\n       emit_insn (gen_movsi (operands[0], operands[1]));\n@@ -6460,14 +6459,14 @@\n   \"\n   if (TARGET_32BIT)\n     {\n-      if (GET_CODE (operands[0]) == MEM)\n+      if (MEM_P (operands[0]))\n         operands[1] = force_reg (HFmode, operands[1]);\n     }\n   else /* TARGET_THUMB1 */\n     {\n       if (can_create_pseudo_p ())\n         {\n-           if (GET_CODE (operands[0]) != REG)\n+           if (!REG_P (operands[0]))\n \t     operands[1] = force_reg (HFmode, operands[1]);\n         }\n     }\n@@ -6531,13 +6530,13 @@\n     case 1:\n       {\n \trtx addr;\n-\tgcc_assert (GET_CODE(operands[1]) == MEM);\n+\tgcc_assert (MEM_P (operands[1]));\n \taddr = XEXP (operands[1], 0);\n \tif (GET_CODE (addr) == LABEL_REF\n \t    || (GET_CODE (addr) == CONST\n \t\t&& GET_CODE (XEXP (addr, 0)) == PLUS\n \t\t&& GET_CODE (XEXP (XEXP (addr, 0), 0)) == LABEL_REF\n-\t\t&& GET_CODE (XEXP (XEXP (addr, 0), 1)) == CONST_INT))\n+\t\t&& CONST_INT_P (XEXP (XEXP (addr, 0), 1))))\n \t  {\n \t    /* Constant pool entry.  */\n \t    return \\\"ldr\\\\t%0, %1\\\";\n@@ -6561,14 +6560,14 @@\n   \"\n   if (TARGET_32BIT)\n     {\n-      if (GET_CODE (operands[0]) == MEM)\n+      if (MEM_P (operands[0]))\n         operands[1] = force_reg (SFmode, operands[1]);\n     }\n   else /* TARGET_THUMB1 */\n     {\n       if (can_create_pseudo_p ())\n         {\n-           if (GET_CODE (operands[0]) != REG)\n+           if (!REG_P (operands[0]))\n \t     operands[1] = force_reg (SFmode, operands[1]);\n         }\n     }\n@@ -6582,7 +6581,7 @@\n \t(match_operand:SF 1 \"immediate_operand\" \"\"))]\n   \"TARGET_EITHER\n    && reload_completed\n-   && GET_CODE (operands[1]) == CONST_DOUBLE\"\n+   && CONST_DOUBLE_P (operands[1])\"\n   [(set (match_dup 2) (match_dup 3))]\n   \"\n   operands[2] = gen_lowpart (SImode, operands[0]);\n@@ -6597,7 +6596,7 @@\n \t(match_operand:SF 1 \"general_operand\"  \"r,mE,r\"))]\n   \"TARGET_32BIT\n    && TARGET_SOFT_FLOAT\n-   && (GET_CODE (operands[0]) != MEM\n+   && (!MEM_P (operands[0])\n        || register_operand (operands[1], SFmode))\"\n   \"@\n    mov%?\\\\t%0, %1\n@@ -6640,14 +6639,14 @@\n   \"\n   if (TARGET_32BIT)\n     {\n-      if (GET_CODE (operands[0]) == MEM)\n+      if (MEM_P (operands[0]))\n         operands[1] = force_reg (DFmode, operands[1]);\n     }\n   else /* TARGET_THUMB */\n     {\n       if (can_create_pseudo_p ())\n         {\n-          if (GET_CODE (operands[0]) != REG)\n+          if (!REG_P (operands[0]))\n \t    operands[1] = force_reg (DFmode, operands[1]);\n         }\n     }\n@@ -6778,11 +6777,11 @@\n   HOST_WIDE_INT offset = 0;\n \n   /* Support only fixed point registers.  */\n-  if (GET_CODE (operands[2]) != CONST_INT\n+  if (!CONST_INT_P (operands[2])\n       || INTVAL (operands[2]) > 14\n       || INTVAL (operands[2]) < 2\n-      || GET_CODE (operands[1]) != MEM\n-      || GET_CODE (operands[0]) != REG\n+      || !MEM_P (operands[1])\n+      || !REG_P (operands[0])\n       || REGNO (operands[0]) > (LAST_ARM_REGNUM - 1)\n       || REGNO (operands[0]) + INTVAL (operands[2]) > LAST_ARM_REGNUM)\n     FAIL;\n@@ -6803,11 +6802,11 @@\n   HOST_WIDE_INT offset = 0;\n \n   /* Support only fixed point registers.  */\n-  if (GET_CODE (operands[2]) != CONST_INT\n+  if (!CONST_INT_P (operands[2])\n       || INTVAL (operands[2]) > 14\n       || INTVAL (operands[2]) < 2\n-      || GET_CODE (operands[1]) != REG\n-      || GET_CODE (operands[0]) != MEM\n+      || !REG_P (operands[1])\n+      || !MEM_P (operands[0])\n       || REGNO (operands[1]) > (LAST_ARM_REGNUM - 1)\n       || REGNO (operands[1]) + INTVAL (operands[2]) > LAST_ARM_REGNUM)\n     FAIL;\n@@ -6999,7 +6998,7 @@\n      gcc_assert (GET_MODE (operands[1]) == DImode\n \t\t || GET_MODE (operands[2]) == DImode);\n \n-     if (!arm_validize_comparison (&operands[0], &operands[1], &operands[2]))\t\t \n+     if (!arm_validize_comparison (&operands[0], &operands[1], &operands[2]))\n        FAIL;\n      emit_jump_insn (gen_cbranch_cc (operands[0], operands[1], operands[2],\n \t\t\t\t       operands[3]));\n@@ -7430,7 +7429,7 @@\n      cond[1] = operands[2];\n      cond[2] = operands[3];\n \n-     if (GET_CODE (cond[2]) == CONST_INT && INTVAL (cond[2]) < 0)\n+     if (CONST_INT_P (cond[2]) && INTVAL (cond[2]) < 0)\n        output_asm_insn (\\\"sub\\\\t%0, %1, #%n2\\\", cond);\n      else\n        output_asm_insn (\\\"add\\\\t%0, %1, %2\\\", cond);\n@@ -9849,13 +9848,13 @@\n   if (GET_CODE (operands[5]) == LT\n       && (operands[4] == const0_rtx))\n     {\n-      if (which_alternative != 1 && GET_CODE (operands[1]) == REG)\n+      if (which_alternative != 1 && REG_P (operands[1]))\n \t{\n \t  if (operands[2] == const0_rtx)\n \t    return \\\"and\\\\t%0, %1, %3, asr #31\\\";\n \t  return \\\"ands\\\\t%0, %1, %3, asr #32\\;movcc\\\\t%0, %2\\\";\n \t}\n-      else if (which_alternative != 0 && GET_CODE (operands[2]) == REG)\n+      else if (which_alternative != 0 && REG_P (operands[2]))\n \t{\n \t  if (operands[1] == const0_rtx)\n \t    return \\\"bic\\\\t%0, %2, %3, asr #31\\\";\n@@ -9868,13 +9867,13 @@\n   if (GET_CODE (operands[5]) == GE\n       && (operands[4] == const0_rtx))\n     {\n-      if (which_alternative != 1 && GET_CODE (operands[1]) == REG)\n+      if (which_alternative != 1 && REG_P (operands[1]))\n \t{\n \t  if (operands[2] == const0_rtx)\n \t    return \\\"bic\\\\t%0, %1, %3, asr #31\\\";\n \t  return \\\"bics\\\\t%0, %1, %3, asr #32\\;movcs\\\\t%0, %2\\\";\n \t}\n-      else if (which_alternative != 0 && GET_CODE (operands[2]) == REG)\n+      else if (which_alternative != 0 && REG_P (operands[2]))\n \t{\n \t  if (operands[1] == const0_rtx)\n \t    return \\\"and\\\\t%0, %2, %3, asr #31\\\";\n@@ -9883,7 +9882,7 @@\n       /* The only case that falls through to here is when both ops 1 & 2\n \t are constants.  */\n     }\n-  if (GET_CODE (operands[4]) == CONST_INT\n+  if (CONST_INT_P (operands[4])\n       && !const_ok_for_arm (INTVAL (operands[4])))\n     output_asm_insn (\\\"cmn\\\\t%3, #%n4\\\", operands);\n   else\n@@ -10023,8 +10022,8 @@\n      everything is in registers then we can do this in two instructions.  */\n   if (operands[3] == const0_rtx\n       && GET_CODE (operands[7]) != AND\n-      && GET_CODE (operands[5]) == REG\n-      && GET_CODE (operands[1]) == REG \n+      && REG_P (operands[5])\n+      && REG_P (operands[1])\n       && REGNO (operands[1]) == REGNO (operands[4])\n       && REGNO (operands[4]) != REGNO (operands[0]))\n     {\n@@ -10033,7 +10032,7 @@\n       else if (GET_CODE (operands[6]) == GE)\n \treturn \\\"bic\\\\t%0, %5, %2, asr #31\\;%I7\\\\t%0, %4, %0\\\";\n     }\n-  if (GET_CODE (operands[3]) == CONST_INT\n+  if (CONST_INT_P (operands[3])\n       && !const_ok_for_arm (INTVAL (operands[3])))\n     output_asm_insn (\\\"cmn\\\\t%2, #%n3\\\", operands);\n   else\n@@ -10081,8 +10080,8 @@\n      everything is in registers then we can do this in two instructions */\n   if (operands[5] == const0_rtx\n       && GET_CODE (operands[7]) != AND\n-      && GET_CODE (operands[3]) == REG\n-      && GET_CODE (operands[1]) == REG \n+      && REG_P (operands[3])\n+      && REG_P (operands[1])\n       && REGNO (operands[1]) == REGNO (operands[2])\n       && REGNO (operands[2]) != REGNO (operands[0]))\n     {\n@@ -10092,7 +10091,7 @@\n \treturn \\\"bic\\\\t%0, %3, %4, asr #31\\;%I7\\\\t%0, %2, %0\\\";\n     }\n \n-  if (GET_CODE (operands[5]) == CONST_INT\n+  if (CONST_INT_P (operands[5])\n       && !const_ok_for_arm (INTVAL (operands[5])))\n     output_asm_insn (\\\"cmn\\\\t%4, #%n5\\\", operands);\n   else\n@@ -10677,7 +10676,7 @@\n   \"\n   {\n     cfun->machine->eh_epilogue_sp_ofs = operands[1];\n-    if (GET_CODE (operands[2]) != REG || REGNO (operands[2]) != 2)\n+    if (!REG_P (operands[2]) || REGNO (operands[2]) != 2)\n       {\n \trtx ra = gen_rtx_REG (Pmode, 2);\n "}, {"sha": "faf909078b44999b4f6b8cb93f9a42e7f9bd2010", "filename": "gcc/config/arm/neon.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d435a4be2a1fddc642ddaa4de055178f152ecf1b/gcc%2Fconfig%2Farm%2Fneon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d435a4be2a1fddc642ddaa4de055178f152ecf1b/gcc%2Fconfig%2Farm%2Fneon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.md?ref=d435a4be2a1fddc642ddaa4de055178f152ecf1b", "patch": "@@ -255,7 +255,7 @@\n {\n   if (can_create_pseudo_p ())\n     {\n-      if (GET_CODE (operands[0]) != REG)\n+      if (!REG_P (operands[0]))\n \toperands[1] = force_reg (TImode, operands[1]);\n     }\n })\n@@ -267,7 +267,7 @@\n {\n   if (can_create_pseudo_p ())\n     {\n-      if (GET_CODE (operands[0]) != REG)\n+      if (!REG_P (operands[0]))\n \toperands[1] = force_reg (<MODE>mode, operands[1]);\n     }\n })"}, {"sha": "e7eb7b3cd4453f72218e641b673a1e5f0179eaa3", "filename": "gcc/config/arm/predicates.md", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d435a4be2a1fddc642ddaa4de055178f152ecf1b/gcc%2Fconfig%2Farm%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d435a4be2a1fddc642ddaa4de055178f152ecf1b/gcc%2Fconfig%2Farm%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fpredicates.md?ref=d435a4be2a1fddc642ddaa4de055178f152ecf1b", "patch": "@@ -26,7 +26,7 @@\n   /* We don't consider registers whose class is NO_REGS\n      to be a register operand.  */\n   /* XXX might have to check for lo regs only for thumb ??? */\n-  return (GET_CODE (op) == REG\n+  return (REG_P (op)\n \t  && (REGNO (op) >= FIRST_PSEUDO_REGISTER\n \t      || REGNO_REG_CLASS (REGNO (op)) != NO_REGS));\n })\n@@ -55,7 +55,7 @@\n   if (GET_CODE (op) == SUBREG)\n     op = SUBREG_REG (op);\n \n-  return (GET_CODE (op) == REG\n+  return (REG_P (op)\n \t  && (REGNO (op) <= LAST_ARM_REGNUM\n \t      || REGNO (op) >= FIRST_PSEUDO_REGISTER));\n })\n@@ -68,7 +68,7 @@\n \n   /* We don't consider registers whose class is NO_REGS\n      to be a register operand.  */\n-  return (GET_CODE (op) == REG\n+  return (REG_P (op)\n \t  && (REGNO (op) >= FIRST_PSEUDO_REGISTER\n \t      || REGNO_REG_CLASS (REGNO (op)) == VFP_D0_D7_REGS\n \t      || REGNO_REG_CLASS (REGNO (op)) == VFP_LO_REGS\n@@ -178,7 +178,7 @@\n   (and (match_code \"mem,reg,subreg\")\n        (match_test \"(!CONSTANT_P (op)\n \t\t     && (true_regnum(op) == -1\n-\t\t\t || (GET_CODE (op) == REG\n+\t\t\t || (REG_P (op)\n \t\t\t     && REGNO (op) >= FIRST_PSEUDO_REGISTER)))\")))\n \n (define_predicate \"vfp_compare_operand\"\n@@ -195,7 +195,7 @@\n (define_predicate \"index_operand\"\n   (ior (match_operand 0 \"s_register_operand\")\n        (and (match_operand 0 \"immediate_operand\")\n-\t    (match_test \"(GET_CODE (op) != CONST_INT\n+\t    (match_test \"(!CONST_INT_P (op)\n \t\t\t  || (INTVAL (op) < 4096 && INTVAL (op) > -4096))\"))))\n \n ;; True for operators that can be combined with a shift in ARM state.\n@@ -223,10 +223,10 @@\n   (and (ior (ior (and (match_code \"mult\")\n \t\t      (match_test \"power_of_two_operand (XEXP (op, 1), mode)\"))\n \t\t (and (match_code \"rotate\")\n-\t\t      (match_test \"GET_CODE (XEXP (op, 1)) == CONST_INT\n+\t\t      (match_test \"CONST_INT_P (XEXP (op, 1))\n \t\t\t\t   && ((unsigned HOST_WIDE_INT) INTVAL (XEXP (op, 1))) < 32\")))\n \t    (and (match_code \"ashift,ashiftrt,lshiftrt,rotatert\")\n-\t\t (match_test \"GET_CODE (XEXP (op, 1)) != CONST_INT\n+\t\t (match_test \"!CONST_INT_P (XEXP (op, 1))\n \t\t\t      || ((unsigned HOST_WIDE_INT) INTVAL (XEXP (op, 1))) < 32\")))\n        (match_test \"mode == GET_MODE (op)\")))\n \n@@ -235,7 +235,7 @@\n   (and (ior (and (match_code \"mult\")\n                  (match_test \"power_of_two_operand (XEXP (op, 1), mode)\"))\n             (and (match_code \"ashift,ashiftrt\")\n-                 (match_test \"GET_CODE (XEXP (op, 1)) == CONST_INT\n+                 (match_test \"CONST_INT_P (XEXP (op, 1))\n \t\t              && ((unsigned HOST_WIDE_INT) INTVAL (XEXP (op, 1)) < 32)\")))\n        (match_test \"mode == GET_MODE (op)\")))\n \n@@ -332,7 +332,7 @@\n    if (GET_CODE (op) == SUBREG)\n      op = SUBREG_REG (op);\n \n-   return GET_CODE (op) == MEM && memory_address_p (DImode, XEXP (op, 0));\n+   return MEM_P (op) && memory_address_p (DImode, XEXP (op, 0));\n })\n \n (define_predicate \"di_operand\"\n@@ -349,7 +349,7 @@\n   if (GET_CODE (op) == SUBREG)\n     op = SUBREG_REG (op);\n \n-  return GET_CODE (op) == MEM && memory_address_p (DFmode, XEXP (op, 0));\n+  return MEM_P (op) && memory_address_p (DFmode, XEXP (op, 0));\n })\n \n (define_predicate \"soft_df_operand\"\n@@ -559,7 +559,7 @@\n      rtx elt = XVECEXP (op, 0, i);\n      int val;\n \n-     if (GET_CODE (elt) != CONST_INT)\n+     if (!CONST_INT_P (elt))\n        return false;\n \n      val = INTVAL (elt);\n@@ -588,7 +588,7 @@\n      rtx elt = XVECEXP (op, 0, i);\n      int val;\n \n-     if (GET_CODE (elt) != CONST_INT)\n+     if (!CONST_INT_P (elt))\n        return false;\n \n      val = INTVAL (elt);"}, {"sha": "57d1539ee3d9d882bb135f2519d085167fb8865d", "filename": "gcc/config/arm/thumb2.md", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d435a4be2a1fddc642ddaa4de055178f152ecf1b/gcc%2Fconfig%2Farm%2Fthumb2.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d435a4be2a1fddc642ddaa4de055178f152ecf1b/gcc%2Fconfig%2Farm%2Fthumb2.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fthumb2.md?ref=d435a4be2a1fddc642ddaa4de055178f152ecf1b", "patch": "@@ -494,13 +494,13 @@\n   if (GET_CODE (operands[5]) == LT\n       && (operands[4] == const0_rtx))\n     {\n-      if (which_alternative != 1 && GET_CODE (operands[1]) == REG)\n+      if (which_alternative != 1 && REG_P (operands[1]))\n \t{\n \t  if (operands[2] == const0_rtx)\n \t    return \\\"and\\\\t%0, %1, %3, asr #31\\\";\n \t  return \\\"ands\\\\t%0, %1, %3, asr #32\\;it\\\\tcc\\;movcc\\\\t%0, %2\\\";\n \t}\n-      else if (which_alternative != 0 && GET_CODE (operands[2]) == REG)\n+      else if (which_alternative != 0 && REG_P (operands[2]))\n \t{\n \t  if (operands[1] == const0_rtx)\n \t    return \\\"bic\\\\t%0, %2, %3, asr #31\\\";\n@@ -513,13 +513,13 @@\n   if (GET_CODE (operands[5]) == GE\n       && (operands[4] == const0_rtx))\n     {\n-      if (which_alternative != 1 && GET_CODE (operands[1]) == REG)\n+      if (which_alternative != 1 && REG_P (operands[1]))\n \t{\n \t  if (operands[2] == const0_rtx)\n \t    return \\\"bic\\\\t%0, %1, %3, asr #31\\\";\n \t  return \\\"bics\\\\t%0, %1, %3, asr #32\\;it\\\\tcs\\;movcs\\\\t%0, %2\\\";\n \t}\n-      else if (which_alternative != 0 && GET_CODE (operands[2]) == REG)\n+      else if (which_alternative != 0 && REG_P (operands[2]))\n \t{\n \t  if (operands[1] == const0_rtx)\n \t    return \\\"and\\\\t%0, %2, %3, asr #31\\\";\n@@ -528,7 +528,7 @@\n       /* The only case that falls through to here is when both ops 1 & 2\n \t are constants.  */\n     }\n-  if (GET_CODE (operands[4]) == CONST_INT\n+  if (CONST_INT_P (operands[4])\n       && !const_ok_for_arm (INTVAL (operands[4])))\n     output_asm_insn (\\\"cmn\\\\t%3, #%n4\\\", operands);\n   else\n@@ -680,7 +680,7 @@\n    (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_THUMB2 && reload_completed\n    && ((GET_CODE(operands[3]) != ROTATE && GET_CODE(operands[3]) != ROTATERT)\n-       || REG_P(operands[2]))\"\n+       || REG_P (operands[2]))\"\n   \"* return arm_output_shift(operands, 2);\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"shift\" \"1\")\n@@ -709,7 +709,7 @@\n   \"*\n     HOST_WIDE_INT val;\n \n-    if (GET_CODE (operands[2]) == CONST_INT)\n+    if (CONST_INT_P (operands[2]))\n       val = INTVAL(operands[2]);\n     else\n       val = 0;\n@@ -773,7 +773,7 @@\n   \"*\n     HOST_WIDE_INT val;\n \n-    if (GET_CODE (operands[2]) == CONST_INT)\n+    if (CONST_INT_P (operands[2]))\n       val = INTVAL (operands[2]);\n     else\n       val = 0;\n@@ -797,7 +797,7 @@\n   \"*\n     HOST_WIDE_INT val;\n \n-    if (GET_CODE (operands[1]) == CONST_INT)\n+    if (CONST_INT_P (operands[1]))\n       val = INTVAL (operands[1]);\n     else\n       val = 0;"}, {"sha": "b43e9523a6b35035e632db1e4ab79b50ef5dea70", "filename": "gcc/config/arm/vec-common.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d435a4be2a1fddc642ddaa4de055178f152ecf1b/gcc%2Fconfig%2Farm%2Fvec-common.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d435a4be2a1fddc642ddaa4de055178f152ecf1b/gcc%2Fconfig%2Farm%2Fvec-common.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fvec-common.md?ref=d435a4be2a1fddc642ddaa4de055178f152ecf1b", "patch": "@@ -28,7 +28,7 @@\n {\n   if (can_create_pseudo_p ())\n     {\n-      if (GET_CODE (operands[0]) != REG)\n+      if (!REG_P (operands[0]))\n \toperands[1] = force_reg (<MODE>mode, operands[1]);\n       else if (TARGET_NEON && CONSTANT_P (operands[1]))\n \t{"}]}