{"sha": "b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjgyZjc4MmJmYjVjNDM4M2FjMGJjMWUzNzI3MWFiM2JiZWI5MzA0ZA==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2006-07-28T04:57:34Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2006-07-28T04:57:34Z"}, "message": "PR libstdc++/19664 round 3\n\n2006-07-27  Benjamin Kosnik  <bkoz@wells.artheist.org>\n\n\tPR libstdc++/19664 round 3\t\n\t* include/Makefile.am (tr1_headers): Add hashtable_policy.h.\n\t* include/Makefile.in: Regenerate.\n\t* include/tr1/hashtable: Move policy classes into...\n\t* include/tr1/hashtable_policy.h: ... this. New.\n\t\n\t* src/globals_locale.cc: Move contents....\n\t* src/locale_init.cc: ... to here, put in anonymous namespace.\n\t* src/Makefile.am: Remove globals_locale.cc.\n\t* src/Makefile.in: Regenerate.\n\n\t* src/locale.cc: Convert __gnu_internal to anonymous namespace.\n\t* src/debug.cc: Same.\n\t* src/ext-inst.cc: Same.\n\t* src/mt_allocator.cc: Same.\n\t* src/pool_allocator.cc: Same.\n\t\n\t* include/tr1/random: Convert std::tr1::_Private to anonymous\n\tnamespace.\n\t* include/tr1/random.tcc: Same.\n\n\t* include/tr1/hashtable: Move ::Internal to std::tr1::detail and\n\tenclose bits that can actually be internal in in anonymous\n\tnamespace.\n\t* include/tr1/unordered_set: Adjust explicit qualifications for\n\tnamespace changes.\n\t* include/tr1/unordered_map: Same.\n\n\t* include/tr1/cmath: Convert __gnu_internal to nested detail namespace.\n\n\t* include/bits/cpp_type_traits.h: Move __type_type into anonymous\n\tnamespace.\n\t\n\t* include/ext/rope: Change _Rope_constants to anonymous namespace.\n\t* include/ext/ropeimpl.h: Same.\n\t* src/ext-inst.cc: Same.\n\nFrom-SVN: r115790", "tree": {"sha": "81547eb1eadbf4669dec412581227155f1ad5c83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81547eb1eadbf4669dec412581227155f1ad5c83"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d/comments", "author": null, "committer": null, "parents": [{"sha": "85661c41dd4fe35a4fd54c3679b94fa0ea2e902a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85661c41dd4fe35a4fd54c3679b94fa0ea2e902a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85661c41dd4fe35a4fd54c3679b94fa0ea2e902a"}], "stats": {"total": 2940, "additions": 1441, "deletions": 1499}, "files": [{"sha": "fc42bdb4657d1a92a46b5d0ed3f16f58d44d5bc7", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d", "patch": "@@ -1,3 +1,42 @@\n+2006-07-27  Benjamin Kosnik  <bkoz@wells.artheist.org>\n+\n+\tPR libstdc++/19664 round 3\t\n+\t* include/Makefile.am (tr1_headers): Add hashtable_policy.h.\n+\t* include/Makefile.in: Regenerate.\n+\t* include/tr1/hashtable: Move policy classes into...\n+\t* include/tr1/hashtable_policy.h: ... this. New.\n+\t\n+\t* src/globals_locale.cc: Move contents....\n+\t* src/locale_init.cc: ... to here, put in anonymous namespace.\n+\t* src/Makefile.am: Remove globals_locale.cc.\n+\t* src/Makefile.in: Regenerate.\n+\n+\t* src/locale.cc: Convert __gnu_internal to anonymous namespace.\n+\t* src/debug.cc: Same.\n+\t* src/ext-inst.cc: Same.\n+\t* src/mt_allocator.cc: Same.\n+\t* src/pool_allocator.cc: Same.\n+\t\n+\t* include/tr1/random: Convert std::tr1::_Private to anonymous\n+\tnamespace.\n+\t* include/tr1/random.tcc: Same.\n+\n+\t* include/tr1/hashtable: Move ::Internal to std::tr1::detail and\n+\tenclose bits that can actually be internal in in anonymous\n+\tnamespace.\n+\t* include/tr1/unordered_set: Adjust explicit qualifications for\n+\tnamespace changes.\n+\t* include/tr1/unordered_map: Same.\n+\n+\t* include/tr1/cmath: Convert __gnu_internal to nested detail namespace.\n+\n+\t* include/bits/cpp_type_traits.h: Move __type_type into anonymous\n+\tnamespace.\n+\t\n+\t* include/ext/rope: Change _Rope_constants to anonymous namespace.\n+\t* include/ext/ropeimpl.h: Same.\n+\t* src/ext-inst.cc: Same.\n+\n 2006-07-24  Paolo Carlini  <pcarlini@suse.de>\n \n \t* include/tr1/cinttypes: Simply protect everything with\n@@ -31,6 +70,7 @@\n \n 2006-07-21  Jason Merrill  <jason@redhat.com>\n \n+\tPR libstdc++/19664 round 2\t\n \t* libsupc++/eh_personality.cc: Wrap extern \"C\" function\n \tdefinitions in namespace __cxxabiv1.\n "}, {"sha": "271de28d162d2f0085d0139e6ab40a899009fa99", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d", "patch": "@@ -591,6 +591,7 @@ tr1_headers = \\\n \t${tr1_srcdir}/functional \\\n \t${tr1_srcdir}/functional_iterate.h \\\n \t${tr1_srcdir}/hashtable \\\n+\t${tr1_srcdir}/hashtable_policy.h \\\n \t${tr1_srcdir}/inttypes.h \\\n \t${tr1_srcdir}/limits.h \\\n \t${tr1_srcdir}/math.h \\"}, {"sha": "a53f9252a2cdc916d5f45cb7234967fac93a9d17", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d", "patch": "@@ -811,6 +811,7 @@ tr1_headers = \\\n \t${tr1_srcdir}/functional \\\n \t${tr1_srcdir}/functional_iterate.h \\\n \t${tr1_srcdir}/hashtable \\\n+\t${tr1_srcdir}/hashtable_policy.h \\\n \t${tr1_srcdir}/inttypes.h \\\n \t${tr1_srcdir}/limits.h \\\n \t${tr1_srcdir}/math.h \\"}, {"sha": "f796b0ce3b85dcb7fb9272bb5e8130548f523fc3", "filename": "libstdc++-v3/include/bits/cpp_type_traits.h", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcpp_type_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcpp_type_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcpp_type_traits.h?ref=b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d", "patch": "@@ -70,19 +70,6 @@\n // removed.\n //\n \n-// NB: g++ can not compile these if declared within the class\n-// __is_pod itself.\n-namespace __gnu_internal\n-{\n-  typedef char __one;\n-  typedef char __two[2];\n-\n-  template<typename _Tp>\n-  __one __test_type(int _Tp::*);\n-  template<typename _Tp>\n-  __two& __test_type(...);\n-} // namespace __gnu_internal\n-\n // Forward declaration hack, should really include this from somewhere.\n _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \n@@ -352,16 +339,27 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n     : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >\n     { };\n \n-  //\n-  // For the immediate use, the following is a good approximation\n-  //\n+  // NB: g++ can not compile these if declared within the class\n+  // __is_pod itself.\n+  namespace \n+  {\n+    typedef char __one;\n+    typedef char __two[2];\n+    \n+    template<typename _Tp>\n+    __one __test_type(int _Tp::*);\n+    \n+    template<typename _Tp>\n+    __two& __test_type(...);\n+  }\n+\n+  // For the immediate use, the following is a good approximation.\n   template<typename _Tp>\n     struct __is_pod\n     {\n       enum\n \t{\n-\t  __value = (sizeof(__gnu_internal::__test_type<_Tp>(0))\n-\t\t     != sizeof(__gnu_internal::__one))\n+\t  __value = (sizeof(__test_type<_Tp>(0)) != sizeof(__one))\n \t};\n     };\n "}, {"sha": "059342f22a5cef6ffceba197694392de91000b42", "filename": "libstdc++-v3/include/ext/rope", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d/libstdc%2B%2B-v3%2Finclude%2Fext%2Frope", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d/libstdc%2B%2B-v3%2Finclude%2Fext%2Frope", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Frope?ref=b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d", "patch": "@@ -1,6 +1,7 @@\n // SGI's rope class -*- C++ -*-\n \n-// Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006\n+// Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -66,6 +67,12 @@\n \n #include <ext/memory> // For uninitialized_copy_n\n \n+namespace \n+{\n+  enum { _S_max_rope_depth = 45 };\n+  enum _Tag {_S_leaf, _S_concat, _S_substringfn, _S_function};\n+}\n+\n _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \n   using std::size_t;\n@@ -543,12 +550,6 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n # undef __ROPE_DEFINE_ALLOC\n     };\n \n-  namespace _Rope_constants\n-  {\n-    enum { _S_max_rope_depth = 45 };\n-    enum _Tag {_S_leaf, _S_concat, _S_substringfn, _S_function};\n-  }\n-\n   template<class _CharT, class _Alloc>\n     struct _Rope_RopeRep\n     : public _Rope_rep_base<_CharT, _Alloc>\n@@ -557,7 +558,7 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n # endif\n     {\n     public:\n-      _Rope_constants::_Tag _M_tag:8;\n+      _Tag _M_tag:8;\n       bool _M_is_balanced:8;\n       unsigned char _M_depth;\n       __GC_CONST _CharT* _M_c_string;\n@@ -573,7 +574,7 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \n       using _Rope_rep_base<_CharT, _Alloc>::get_allocator;\n \n-      _Rope_RopeRep(_Rope_constants::_Tag __t, int __d, bool __b, size_t __size,\n+      _Rope_RopeRep(_Tag __t, int __d, bool __b, size_t __size,\n \t\t    allocator_type __a)\n       : _Rope_rep_base<_CharT, _Alloc>(__size, __a),\n #ifndef __GC\n@@ -690,7 +691,7 @@ protected:\n \n       _Rope_RopeLeaf(__GC_CONST _CharT* __d, size_t __size,\n \t\t     allocator_type __a)\n-      : _Rope_RopeRep<_CharT, _Alloc>(_Rope_constants::_S_leaf, 0, true,\n+      : _Rope_RopeRep<_CharT, _Alloc>(_S_leaf, 0, true,\n \t\t\t\t      __size, __a), _M_data(__d)\n       {\n         if (_S_is_basic_char_type((_CharT *)0))\n@@ -732,7 +733,7 @@ protected:\n       _Rope_RopeConcatenation(_Rope_RopeRep<_CharT, _Alloc>* __l,\n \t\t\t      _Rope_RopeRep<_CharT, _Alloc>* __r,\n \t\t\t      allocator_type __a)\n-      : _Rope_RopeRep<_CharT, _Alloc>(_Rope_constants::_S_concat,\n+\t: _Rope_RopeRep<_CharT, _Alloc>(::_S_concat,\n \t\t\t\t      std::max(__l->_M_depth,\n \t\t\t\t\t       __r->_M_depth) + 1,\n \t\t\t\t      false,\n@@ -780,8 +781,7 @@ protected:\n \n       _Rope_RopeFunction(char_producer<_CharT>* __f, size_t __size,\n                         bool __d, allocator_type __a)\n-      : _Rope_RopeRep<_CharT, _Alloc>(_Rope_constants::_S_function,\n-\t\t\t\t      0, true, __size, __a)\n+      : _Rope_RopeRep<_CharT, _Alloc>(::_S_function, 0, true, __size, __a)\n \t, _M_fn(__f)\n #ifndef __GC\n \t, _M_delete_when_done(__d)\n@@ -832,15 +832,15 @@ protected:\n       {\n         switch(_M_base->_M_tag)\n \t  {\n-\t  case _Rope_constants::_S_function:\n-\t  case _Rope_constants::_S_substringfn:\n+\t  case ::_S_function:\n+\t  case ::_S_substringfn:\n \t    {\n \t      char_producer<_CharT>* __fn =\n \t\t((_Rope_RopeFunction<_CharT,_Alloc>*)_M_base)->_M_fn;\n \t      (*__fn)(__start_pos + _M_start, __req_len, __buffer);\n \t    }\n \t    break;\n-\t  case _Rope_constants::_S_leaf:\n+\t  case ::_S_leaf:\n \t    {\n \t      __GC_CONST _CharT* __s =\n \t\t((_Rope_RopeLeaf<_CharT,_Alloc>*)_M_base)->_M_data;\n@@ -864,7 +864,7 @@ protected:\n #ifndef __GC\n \t_M_base->_M_ref_nonnil();\n #endif\n-        this->_M_tag = _Rope_constants::_S_substringfn;\n+        this->_M_tag = ::_S_substringfn;\n       }\n     virtual ~_Rope_RopeSubstring() throw()\n       {\n@@ -1711,7 +1711,7 @@ protected:\n \t\t\t\t_CharT* __buffer);\n \n       static const unsigned long\n-      _S_min_len[_Rope_constants::_S_max_rope_depth + 1];\n+      _S_min_len[::_S_max_rope_depth + 1];\n       \n       static bool\n       _S_is_balanced(_RopeRep* __r)\n@@ -1961,7 +1961,7 @@ protected:\n       {\n \tif (0 == this->_M_tree_ptr)\n \t  return;\n-\tif (_Rope_constants::_S_leaf == this->_M_tree_ptr->_M_tag &&\n+\tif (::_S_leaf == this->_M_tree_ptr->_M_tag &&\n \t    ((_RopeLeaf*)this->_M_tree_ptr)->_M_data ==\n \t    this->_M_tree_ptr->_M_c_string)\n \t  {\n@@ -2013,7 +2013,7 @@ protected:\n       size_type\n       max_size() const\n       {\n-\treturn _S_min_len[int(_Rope_constants::_S_max_rope_depth) - 1] - 1;\n+\treturn _S_min_len[int(::_S_max_rope_depth) - 1] - 1;\n \t//  Guarantees that the result can be sufficirntly\n \t//  balanced.  Longer ropes will probably still work,\n \t//  but it's harder to make guarantees.\n@@ -2089,8 +2089,8 @@ protected:\n \t_Self_destruct_ptr __appendee(_S_substring(__s._M_root,\n \t\t\t\t\t\t   __s._M_current_pos,\n \t\t\t\t\t\t   __e._M_current_pos));\n-\t_RopeRep* __result =\n-\t  _S_concat(this->_M_tree_ptr, (_RopeRep*)__appendee);\n+\t_RopeRep* __result = _S_concat(this->_M_tree_ptr, \n+\t\t\t\t       (_RopeRep*)__appendee);\n \t_S_unref(this->_M_tree_ptr);\n \tthis->_M_tree_ptr = __result;\n \treturn *this;"}, {"sha": "c7827e33515442c52860aacfeb27202233da3f7e", "filename": "libstdc++-v3/include/ext/ropeimpl.h", "status": "modified", "additions": 62, "deletions": 62, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d/libstdc%2B%2B-v3%2Finclude%2Fext%2Fropeimpl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d/libstdc%2B%2B-v3%2Finclude%2Fext%2Fropeimpl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fropeimpl.h?ref=b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d", "patch": "@@ -1,6 +1,7 @@\n // SGI's rope class implementation -*- C++ -*-\n \n-// Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006\n+// Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -77,13 +78,13 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \n       switch(__leaf->_M_tag)\n \t{\n-\tcase _Rope_constants::_S_leaf:\n+\tcase ::_S_leaf:\n \t  __x._M_buf_start = ((_Rope_RopeLeaf<_CharT, _Alloc>*)__leaf)->_M_data;\n \t  __x._M_buf_ptr = __x._M_buf_start + (__pos - __leaf_pos);\n \t  __x._M_buf_end = __x._M_buf_start + __leaf->_M_size;\n \t  break;\n-\tcase _Rope_constants::_S_function:\n-\tcase _Rope_constants::_S_substringfn:\n+\tcase ::_S_function:\n+\tcase ::_S_substringfn:\n \t  {\n \t    size_t __len = _S_iterator_buf_len;\n \t    size_t __buf_start_pos = __leaf_pos;\n@@ -116,7 +117,7 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n     _Rope_iterator_base<_CharT, _Alloc>::\n     _S_setcache(_Rope_iterator_base<_CharT, _Alloc>& __x)\n     {\n-      const _RopeRep* __path[int(_Rope_constants::_S_max_rope_depth) + 1];\n+      const _RopeRep* __path[int(::_S_max_rope_depth) + 1];\n       const _RopeRep* __curr_rope;\n       int __curr_depth = -1;  /* index into path    */\n       size_t __curr_start_pos = 0;\n@@ -146,12 +147,12 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \t  __path[__curr_depth] = __curr_rope;\n \t  switch(__curr_rope->_M_tag)\n \t    {\n-\t    case _Rope_constants::_S_leaf:\n-\t    case _Rope_constants::_S_function:\n-\t    case _Rope_constants::_S_substringfn:\n+\t    case ::_S_leaf:\n+\t    case ::_S_function:\n+\t    case ::_S_substringfn:\n \t      __x._M_leaf_pos = __curr_start_pos;\n \t      goto done;\n-\t    case _Rope_constants::_S_concat:\n+\t    case ::_S_concat:\n \t      {\n \t\t_Rope_RopeConcatenation<_CharT, _Alloc>* __c =\n \t\t  (_Rope_RopeConcatenation<_CharT, _Alloc>*)__curr_rope;\n@@ -233,7 +234,7 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n       __current_node = __c->_M_right;\n       __x._M_path_end[++__current_index] = __current_node;\n       __dirns |= 1;\n-      while (_Rope_constants::_S_concat == __current_node->_M_tag)\n+      while (::_S_concat == __current_node->_M_tag)\n \t{\n \t  ++__current_index;\n \t  if (int(_S_path_cache_len) == __current_index)\n@@ -377,15 +378,15 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n     {\n       switch(_M_tag)\n \t{\n-\tcase _Rope_constants::_S_leaf:\n+\tcase ::_S_leaf:\n \t  {\n \t    _Rope_RopeLeaf<_CharT, _Alloc>* __l\n \t      = (_Rope_RopeLeaf<_CharT, _Alloc>*)this;\n \t    __l->_Rope_RopeLeaf<_CharT, _Alloc>::~_Rope_RopeLeaf();\n \t    _L_deallocate(__l, 1);\n \t    break;\n \t  }\n-\tcase _Rope_constants::_S_concat:\n+\tcase ::_S_concat:\n \t  {\n \t    _Rope_RopeConcatenation<_CharT,_Alloc>* __c\n \t      = (_Rope_RopeConcatenation<_CharT, _Alloc>*)this;\n@@ -394,15 +395,15 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \t    _C_deallocate(__c, 1);\n \t    break;\n \t  }\n-\tcase _Rope_constants::_S_function:\n+\tcase ::_S_function:\n \t  {\n \t    _Rope_RopeFunction<_CharT, _Alloc>* __f\n \t      = (_Rope_RopeFunction<_CharT, _Alloc>*)this;\n \t    __f->_Rope_RopeFunction<_CharT, _Alloc>::~_Rope_RopeFunction();\n \t    _F_deallocate(__f, 1);\n \t    break;\n \t  }\n-\tcase _Rope_constants::_S_substringfn:\n+\tcase ::_S_substringfn:\n \t  {\n \t    _Rope_RopeSubstring<_CharT, _Alloc>* __ss =\n \t      (_Rope_RopeSubstring<_CharT, _Alloc>*)this;\n@@ -502,7 +503,7 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n       \n       if (__depth > 20\n \t  && (__result->_M_size < 1000\n-\t      || __depth > size_t(_Rope_constants::_S_max_rope_depth)))\n+\t      || __depth > size_t(::_S_max_rope_depth)))\n \t{\n \t  _RopeRep* __balanced;\n \n@@ -540,15 +541,14 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n       if (0 == __r)\n \treturn __STL_ROPE_FROM_UNOWNED_CHAR_PTR(__s, __slen,\n \t\t\t\t\t\t__r->get_allocator());\n-      if (_Rope_constants::_S_leaf == __r->_M_tag\n+      if (__r->_M_tag == ::_S_leaf\n \t  && __r->_M_size + __slen <= size_t(_S_copy_max))\n \t{\n \t  __result = _S_leaf_concat_char_iter((_RopeLeaf*)__r, __s, __slen);\n \t  return __result;\n \t}\n-      if (_Rope_constants::_S_concat == __r->_M_tag\n-\t  && _Rope_constants::_S_leaf == ((_RopeConcatenation*)\n-\t\t\t\t\t  __r)->_M_right->_M_tag)\n+      if (::_S_concat == __r->_M_tag\n+\t  && ::_S_leaf == ((_RopeConcatenation*) __r)->_M_right->_M_tag)\n \t{\n \t  _RopeLeaf* __right =\n \t    (_RopeLeaf* )(((_RopeConcatenation* )__r)->_M_right);\n@@ -605,17 +605,17 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \t  return __r;\n \t}\n       if (__orig_size + __slen <= size_t(_S_copy_max)\n-\t  && _Rope_constants::_S_leaf == __r->_M_tag)\n+\t  && ::_S_leaf == __r->_M_tag)\n \t{\n \t  __result = _S_destr_leaf_concat_char_iter((_RopeLeaf*)__r, __s, \n \t\t\t\t\t\t    __slen);\n \t  return __result;\n \t}\n-      if (_Rope_constants::_S_concat == __r->_M_tag)\n+      if (::_S_concat == __r->_M_tag)\n \t{\n \t  _RopeLeaf* __right = (_RopeLeaf*)(((_RopeConcatenation*)\n \t\t\t\t\t     __r)->_M_right);\n-\t  if (_Rope_constants::_S_leaf == __right->_M_tag\n+\t  if (::_S_leaf == __right->_M_tag\n \t      && __right->_M_size + __slen <= size_t(_S_copy_max))\n \t    {\n \t      _RopeRep* __new_right =\n@@ -665,17 +665,17 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \t  __left->_M_ref_nonnil();\n \t  return __left;\n \t}\n-      if (_Rope_constants::_S_leaf == __right->_M_tag)\n+      if (::_S_leaf == __right->_M_tag)\n \t{\n-\t  if (_Rope_constants::_S_leaf == __left->_M_tag)\n+\t  if (::_S_leaf == __left->_M_tag)\n \t    {\n \t      if (__right->_M_size + __left->_M_size <= size_t(_S_copy_max))\n \t\treturn _S_leaf_concat_char_iter((_RopeLeaf*)__left,\n \t\t\t\t\t\t((_RopeLeaf*)__right)->_M_data,\n \t\t\t\t\t\t__right->_M_size);\n \t    }\n-\t  else if (_Rope_constants::_S_concat == __left->_M_tag\n-\t\t   && _Rope_constants::_S_leaf == ((_RopeConcatenation*)\n+\t  else if (::_S_concat == __left->_M_tag\n+\t\t   && ::_S_leaf == ((_RopeConcatenation*)\n \t\t\t\t\t\t   __left)->_M_right->_M_tag)\n \t    {\n \t      _RopeLeaf* __leftright =\n@@ -740,7 +740,7 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \n       switch(__base->_M_tag)\n \t{\n-\tcase _Rope_constants::_S_concat:\n+\tcase ::_S_concat:\n \t    {\n \t      _RopeConcatenation* __c = (_RopeConcatenation*)__base;\n \t      _RopeRep* __left = __c->_M_left;\n@@ -762,7 +762,7 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \t      __result = _S_concat(__left_result, __right_result);\n \t      return __result;\n \t    }\n-\tcase _Rope_constants::_S_leaf:\n+\tcase ::_S_leaf:\n \t  {\n \t    _RopeLeaf* __l = (_RopeLeaf*)__base;\n \t    _RopeLeaf* __result;\n@@ -786,7 +786,7 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n #endif\n \t    return __result;\n \t  }\n-\tcase _Rope_constants::_S_substringfn:\n+\tcase ::_S_substringfn:\n \t  // Avoid introducing multiple layers of substring nodes.\n \t  {\n \t    _RopeSubstring* __old = (_RopeSubstring*)__base;\n@@ -805,7 +805,7 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \t\t\n \t      } // *** else fall through: ***\n \t  }\n-\tcase _Rope_constants::_S_function:\n+\tcase ::_S_function:\n \t  {\n \t    _RopeFunction* __f = (_RopeFunction*)__base;\n \t    _CharT* __section;\n@@ -930,7 +930,7 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \treturn true;\n       switch(__r->_M_tag)\n \t{\n-\tcase _Rope_constants::_S_concat:\n+\tcase ::_S_concat:\n \t  {\n \t    _RopeConcatenation* __conc = (_RopeConcatenation*)__r;\n \t    _RopeRep* __left =  __conc->_M_left;\n@@ -952,13 +952,13 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \t      }\n \t  }\n \t  return true;\n-\tcase _Rope_constants::_S_leaf:\n+\tcase ::_S_leaf:\n \t  {\n \t    _RopeLeaf* __l = (_RopeLeaf*)__r;\n \t    return __c(__l->_M_data + __begin, __end - __begin);\n \t  }\n-\tcase _Rope_constants::_S_function:\n-\tcase _Rope_constants::_S_substringfn:\n+\tcase ::_S_function:\n+\tcase ::_S_substringfn:\n \t    {\n \t      _RopeFunction* __f = (_RopeFunction*)__r;\n \t      size_t __len = __end - __begin;\n@@ -1081,21 +1081,21 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \treturn __buffer;\n       switch(__r->_M_tag)\n \t{\n-\tcase _Rope_constants::_S_concat:\n+\tcase ::_S_concat:\n \t  {\n \t    _RopeConcatenation* __c = (_RopeConcatenation*)__r;\n \t    _RopeRep* __left = __c->_M_left;\n \t    _RopeRep* __right = __c->_M_right;\n \t    _CharT* __rest = _S_flatten(__left, __buffer);\n \t    return _S_flatten(__right, __rest);\n \t  }\n-\tcase _Rope_constants::_S_leaf:\n+\tcase ::_S_leaf:\n \t  {\n \t    _RopeLeaf* __l = (_RopeLeaf*)__r;\n \t    return copy_n(__l->_M_data, __l->_M_size, __buffer).second;\n \t  }\n-\tcase _Rope_constants::_S_function:\n-\tcase _Rope_constants::_S_substringfn:\n+\tcase ::_S_function:\n+\tcase ::_S_substringfn:\n \t  // We don't yet do anything with substring nodes.\n \t  // This needs to be fixed before ropefiles will work well.\n \t  {\n@@ -1121,7 +1121,7 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \t  printf(\"NULL\\n\");\n \t  return;\n \t}\n-      if (_Rope_constants::_S_concat == __r->_M_tag)\n+      if (_S_concat == __r->_M_tag)\n \t{\n \t  _RopeConcatenation* __c = (_RopeConcatenation*)__r;\n \t  _RopeRep* __left = __c->_M_left;\n@@ -1147,13 +1147,13 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \t  \n \t  switch (__r->_M_tag)\n \t    {\n-\t    case _Rope_constants::_S_leaf:\n+\t    case ::_S_leaf:\n \t      __kind = \"Leaf\";\n \t      break;\n-\t    case _Rope_constants::_S_function:\n+\t    case ::_S_function:\n \t      __kind = \"Function\";\n \t      break;\n-\t    case _Rope_constants::_S_substringfn:\n+\t    case ::_S_substringfn:\n \t      __kind = \"Function representing substring\";\n \t      break;\n \t    default:\n@@ -1186,7 +1186,7 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n   template <class _CharT, class _Alloc>\n     const unsigned long\n     rope<_CharT, _Alloc>::\n-    _S_min_len[int(_Rope_constants::_S_max_rope_depth) + 1] = {\n+    _S_min_len[int(::_S_max_rope_depth) + 1] = {\n       /* 0 */1, /* 1 */2, /* 2 */3, /* 3 */5, /* 4 */8, /* 5 */13, /* 6 */21,\n       /* 7 */34, /* 8 */55, /* 9 */89, /* 10 */144, /* 11 */233, /* 12 */377,\n       /* 13 */610, /* 14 */987, /* 15 */1597, /* 16 */2584, /* 17 */4181,\n@@ -1205,7 +1205,7 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n     rope<_CharT, _Alloc>::\n     _S_balance(_RopeRep* __r)\n     {\n-      _RopeRep* __forest[int(_Rope_constants::_S_max_rope_depth) + 1];\n+      _RopeRep* __forest[int(::_S_max_rope_depth) + 1];\n       _RopeRep* __result = 0;\n       int __i;\n       // Invariant:\n@@ -1214,12 +1214,12 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n       // __forest[__i]._M_depth = __i\n       // References from forest are included in refcount.\n       \n-      for (__i = 0; __i <= int(_Rope_constants::_S_max_rope_depth); ++__i)\n+      for (__i = 0; __i <= int(::_S_max_rope_depth); ++__i)\n \t__forest[__i] = 0;\n       try\n \t{\n \t  _S_add_to_forest(__r, __forest);\n-\t  for (__i = 0; __i <= int(_Rope_constants::_S_max_rope_depth); ++__i)\n+\t  for (__i = 0; __i <= int(::_S_max_rope_depth); ++__i)\n \t    if (0 != __forest[__i])\n \t      {\n #ifndef __GC\n@@ -1234,12 +1234,12 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \t}\n       catch(...)\n \t{\n-\t  for(__i = 0; __i <= int(_Rope_constants::_S_max_rope_depth); __i++)\n+\t  for(__i = 0; __i <= int(::_S_max_rope_depth); __i++)\n \t    _S_unref(__forest[__i]);\n \t  __throw_exception_again;\n \t}\n       \n-      if (__result->_M_depth > int(_Rope_constants::_S_max_rope_depth))\n+      if (__result->_M_depth > int(::_S_max_rope_depth))\n \t__throw_length_error(__N(\"rope::_S_balance\"));\n       return(__result);\n     }\n@@ -1307,7 +1307,7 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \t      __forest[__i]->_M_unref_nonnil();\n \t      __forest[__i] = 0;\n \t    }\n-\t  if (__i == int(_Rope_constants::_S_max_rope_depth)\n+\t  if (__i == int(::_S_max_rope_depth)\n \t      || __insertee->_M_size < _S_min_len[__i+1])\n \t    {\n \t      __forest[__i] = __insertee;\n@@ -1330,7 +1330,7 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \t{\n \t  switch(__r->_M_tag)\n \t    {\n-\t    case _Rope_constants::_S_concat:\n+\t    case ::_S_concat:\n \t      {\n \t\t_RopeConcatenation* __c = (_RopeConcatenation*)__r;\n \t\t_RopeRep* __left = __c->_M_left;\n@@ -1345,13 +1345,13 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \t\t  __r = __left;\n \t      }\n \t      break;\n-\t    case _Rope_constants::_S_leaf:\n+\t    case ::_S_leaf:\n \t      {\n \t\t_RopeLeaf* __l = (_RopeLeaf*)__r;\n \t\treturn __l->_M_data[__i];\n \t      }\n-\t    case _Rope_constants::_S_function:\n-\t    case _Rope_constants::_S_substringfn:\n+\t    case ::_S_function:\n+\t    case ::_S_substringfn:\n \t      {\n \t\t_RopeFunction* __f = (_RopeFunction*)__r;\n \t\t_CharT __result;\n@@ -1371,7 +1371,7 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n     rope<_CharT, _Alloc>::\n     _S_fetch_ptr(_RopeRep* __r, size_type __i)\n     {\n-      _RopeRep* __clrstack[_Rope_constants::_S_max_rope_depth];\n+      _RopeRep* __clrstack[::_S_max_rope_depth];\n       size_t __csptr = 0;\n       \n       for(;;)\n@@ -1380,7 +1380,7 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \t    return 0;\n \t  switch(__r->_M_tag)\n \t    {\n-\t    case _Rope_constants::_S_concat:\n+\t    case ::_S_concat:\n \t      {\n \t\t_RopeConcatenation* __c = (_RopeConcatenation*)__r;\n \t\t_RopeRep* __left = __c->_M_left;\n@@ -1397,7 +1397,7 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \t\t  __r = __left;\n \t      }\n \t      break;\n-\t    case _Rope_constants::_S_leaf:\n+\t    case ::_S_leaf:\n \t      {\n \t\t_RopeLeaf* __l = (_RopeLeaf*)__r;\n \t\tif (__l->_M_c_string != __l->_M_data && __l->_M_c_string != 0)\n@@ -1411,8 +1411,8 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \t\t  }\n \t\treturn __l->_M_data + __i;\n \t      }\n-\t    case _Rope_constants::_S_function:\n-\t    case _Rope_constants::_S_substringfn:\n+\t    case ::_S_function:\n+\t    case ::_S_substringfn:\n \t      return 0;\n \t    }\n \t}\n@@ -1437,10 +1437,10 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \treturn -1;\n       __left_len = __left->_M_size;\n       __right_len = __right->_M_size;\n-      if (_Rope_constants::_S_leaf == __left->_M_tag)\n+      if (::_S_leaf == __left->_M_tag)\n \t{\n \t  _RopeLeaf* __l = (_RopeLeaf*) __left;\n-\t  if (_Rope_constants::_S_leaf == __right->_M_tag)\n+\t  if (::_S_leaf == __right->_M_tag)\n \t    {\n \t      _RopeLeaf* __r = (_RopeLeaf*) __right;\n \t      return lexicographical_compare_3way(__l->_M_data,\n@@ -1461,7 +1461,7 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \t{\n \t  const_iterator __lstart(__left, 0);\n \t  const_iterator __lend(__left, __left_len);\n-\t  if (_Rope_constants::_S_leaf == __right->_M_tag)\n+\t  if (::_S_leaf == __right->_M_tag)\n \t    {\n \t      _RopeLeaf* __r = (_RopeLeaf*) __right;\n \t      return lexicographical_compare_3way(__lstart, __lend,\n@@ -1637,7 +1637,7 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \t  return _S_empty_c_str;\n \t}\n       __GC_CONST _CharT* __old_c_string = this->_M_tree_ptr->_M_c_string;\n-      if (_Rope_constants::_S_leaf == this->_M_tree_ptr->_M_tag\n+      if (::_S_leaf == this->_M_tree_ptr->_M_tag\n \t  && 0 != __old_c_string)\n \treturn(__old_c_string);\n       size_t __s = size();"}, {"sha": "22c9f2e44b4564727924baef730ae315b0e05c25", "filename": "libstdc++-v3/include/tr1/cmath", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcmath", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcmath", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcmath?ref=b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d", "patch": "@@ -146,21 +146,6 @@\n #undef truncf\n #undef truncl\n \n-// Workaround for c++/21682.\n-namespace __gnu_internal\n-{\n-  template<typename _Tp, typename _Up>\n-    inline typename\n-    std::__enable_if<typename std::tr1::__promote_2<_Tp, _Up>::__type,\n-\t\t     (std::__is_floating<_Tp>::__value\n-\t\t      || std::__is_floating<_Up>::__value)>::__type\n-    atan2(_Tp __y, _Up __x)\n-    {\n-      typedef typename std::tr1::__promote_2<_Tp, _Up>::__type __type;\n-      return std::atan2(__type(__y), __type(__x));\n-    }\n-}\n-\n #endif\n \n // namespace std::tr1\n@@ -381,10 +366,24 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n     }\n \n   using std::atan;\n-  using std::atan2;\n \n   // Workaround for c++/21682.\n-  using __gnu_internal::atan2;\n+  namespace detail\n+  {\n+    template<typename _Tp, typename _Up>\n+    inline typename\n+    std::__enable_if<typename std::tr1::__promote_2<_Tp, _Up>::__type,\n+\t\t     (std::__is_floating<_Tp>::__value\n+\t\t      || std::__is_floating<_Up>::__value)>::__type\n+\t\t      atan2(_Tp __y, _Up __x)\n+    {\n+      typedef typename std::tr1::__promote_2<_Tp, _Up>::__type __type;\n+      return std::atan2(__type(__y), __type(__x));\n+    }\n+  } // namespace detail\n+\n+  using std::atan2;\n+  using detail::atan2;\n \n   inline float\n   atanh(float __x)"}, {"sha": "9a682db122855bbb64605e3ffdf94dd7f7989538", "filename": "libstdc++-v3/include/tr1/hashtable", "status": "modified", "additions": 48, "deletions": 923, "changes": 971, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable?ref=b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d", "patch": "@@ -38,8 +38,6 @@\n // the differences between those four classes and partly to \n // accommodate policy choices that go beyond what TR1 calls for.\n \n-// ??? Arguably this should be Internal::hashtable, not std::tr1::hashtable.\n-\n // Class template hashtable attempts to encapsulate all reasonable\n // variation among hash tables that use chaining.  It does not handle\n // open addressing.\n@@ -48,8 +46,8 @@\n // M. Austern, \"A Proposal to Add Hash Tables to the Standard\n //    Library (revision 4),\" WG21 Document N1456=03-0039, 2003.\n // D. E. Knuth, The Art of Computer Programming, v. 3, Sorting and Searching.\n-// A. Tavori and V. Dreizin, \"Generic Associative Containers\", 2004.\n-//    ??? Full citation?\n+// A. Tavori and V. Dreizin, \"Policy-Based Data Structures\", 2004.\n+// http://gcc.gnu.org/onlinedocs/libstdc++/ext/pb_ds/index.html\n \n #ifndef _TR1_HASHTABLE\n #define _TR1_HASHTABLE 1\n@@ -62,882 +60,12 @@\n #include <cmath>\n #include <bits/functexcept.h>\n #include <tr1/type_traits>\t// For true_type and false_type\n-\n-//----------------------------------------------------------------------\n-// General utilities\n-\n-namespace Internal\n-{\n-  template<bool Flag, typename IfTrue, typename IfFalse>\n-    struct IF;\n-\n-  template<typename IfTrue, typename IfFalse>\n-    struct IF<true, IfTrue, IfFalse>\n-    { typedef IfTrue type; };\n- \n-  template <typename IfTrue, typename IfFalse>\n-    struct IF<false, IfTrue, IfFalse>\n-    { typedef IfFalse type; };\n-\n-  // Helper function: return distance(first, last) for forward\n-  // iterators, or 0 for input iterators.\n-  template<class Iterator>\n-    inline typename std::iterator_traits<Iterator>::difference_type\n-    distance_fw(Iterator first, Iterator last, std::input_iterator_tag)\n-    { return 0; }\n-\n-  template<class Iterator>\n-    inline typename std::iterator_traits<Iterator>::difference_type\n-    distance_fw(Iterator first, Iterator last, std::forward_iterator_tag)\n-    { return std::distance(first, last); }\n-\n-  template<class Iterator>\n-    inline typename std::iterator_traits<Iterator>::difference_type\n-    distance_fw(Iterator first, Iterator last)\n-    {\n-      typedef typename std::iterator_traits<Iterator>::iterator_category tag;\n-      return distance_fw(first, last, tag());\n-    }\n-  \n-} // namespace Internal\n-\n-\n-//----------------------------------------------------------------------\n-// Auxiliary types used for all instantiations of hashtable: nodes\n-// and iterators.\n-\n-// Nodes, used to wrap elements stored in the hash table.  A policy\n-// template parameter of class template hashtable controls whether\n-// nodes also store a hash code. In some cases (e.g. strings) this may\n-// be a performance win.\n-\n-namespace Internal\n-{\n-  template<typename Value, bool cache_hash_code>\n-    struct hash_node;\n-\n-  template<typename Value>\n-    struct hash_node<Value, true>\n-    {\n-      Value       m_v;\n-      std::size_t hash_code;\n-      hash_node*  m_next;\n-    };\n-\n-  template<typename Value>\n-    struct hash_node<Value, false>\n-    {\n-      Value       m_v;\n-      hash_node*  m_next;\n-    };\n-\n-  // Local iterators, used to iterate within a bucket but not between\n-  // buckets.\n-\n-  template<typename Value, bool cache>\n-    struct node_iterator_base\n-    {\n-      node_iterator_base(hash_node<Value, cache>* p)\n-      : m_cur(p) { }\n-      \n-      void\n-      incr()\n-      { m_cur = m_cur->m_next; }\n-\n-      hash_node<Value, cache>* m_cur;\n-    };\n-\n-  template<typename Value, bool cache>\n-    inline bool\n-    operator==(const node_iterator_base<Value, cache>& x,\n-\t       const node_iterator_base<Value, cache>& y)\n-    { return x.m_cur == y.m_cur; }\n-\n-  template<typename Value, bool cache>\n-    inline bool\n-    operator!=(const node_iterator_base<Value, cache>& x,\n-\t       const node_iterator_base<Value, cache>& y)\n-    { return x.m_cur != y.m_cur; }\n-\n-  template<typename Value, bool constant_iterators, bool cache>\n-    struct node_iterator\n-    : public node_iterator_base<Value, cache>\n-    {\n-      typedef Value                                    value_type;\n-      typedef typename IF<constant_iterators, const Value*, Value*>::type\n-                                                       pointer;\n-      typedef typename IF<constant_iterators, const Value&, Value&>::type\n-                                                       reference;\n-      typedef std::ptrdiff_t                           difference_type;\n-      typedef std::forward_iterator_tag                iterator_category;\n-\n-      node_iterator()\n-      : node_iterator_base<Value, cache>(0) { }\n-\n-      explicit\n-      node_iterator(hash_node<Value, cache>* p)\n-      : node_iterator_base<Value, cache>(p) { }\n-\n-      reference\n-      operator*() const\n-      { return this->m_cur->m_v; }\n-  \n-      pointer\n-      operator->() const\n-      { return &this->m_cur->m_v; }\n-\n-      node_iterator&\n-      operator++()\n-      { \n-\tthis->incr(); \n-\treturn *this; \n-      }\n-  \n-      node_iterator\n-      operator++(int)\n-      { \n-\tnode_iterator tmp(*this);\n-\tthis->incr();\n-\treturn tmp;\n-      }\n-    };\n-\n-  template<typename Value, bool constant_iterators, bool cache>\n-    struct node_const_iterator\n-    : public node_iterator_base<Value, cache>\n-    {\n-      typedef Value                                    value_type;\n-      typedef const Value*                             pointer;\n-      typedef const Value&                             reference;\n-      typedef std::ptrdiff_t                           difference_type;\n-      typedef std::forward_iterator_tag                iterator_category;\n-\n-      node_const_iterator()\n-      : node_iterator_base<Value, cache>(0) { }\n-\n-      explicit\n-      node_const_iterator(hash_node<Value, cache>* p)\n-      : node_iterator_base<Value, cache>(p) { }\n-\n-      node_const_iterator(const node_iterator<Value, constant_iterators,\n-\t\t\t  cache>& x)\n-      : node_iterator_base<Value, cache>(x.m_cur) { }\n-\n-      reference\n-      operator*() const\n-      { return this->m_cur->m_v; }\n-  \n-      pointer\n-      operator->() const\n-      { return &this->m_cur->m_v; }\n-\n-      node_const_iterator&\n-      operator++()\n-      { \n-\tthis->incr(); \n-\treturn *this; \n-      }\n-  \n-      node_const_iterator\n-      operator++(int)\n-      { \n-\tnode_const_iterator tmp(*this);\n-\tthis->incr();\n-\treturn tmp;\n-      }\n-    };\n-\n-  template<typename Value, bool cache>\n-    struct hashtable_iterator_base\n-    {\n-      hashtable_iterator_base(hash_node<Value, cache>* node,\n-\t\t\t      hash_node<Value, cache>** bucket)\n-      : m_cur_node(node), m_cur_bucket(bucket) { }\n-\n-      void\n-      incr()\n-      {\n-\tm_cur_node = m_cur_node->m_next;\n-\tif (!m_cur_node)\n-\t  m_incr_bucket();\n-      }\n-\n-      void\n-      m_incr_bucket();\n-\n-      hash_node<Value, cache>*  m_cur_node;\n-      hash_node<Value, cache>** m_cur_bucket;\n-    };\n-\n-  // Global iterators, used for arbitrary iteration within a hash\n-  // table.  Larger and more expensive than local iterators.\n-  template<typename Value, bool cache>\n-    void\n-    hashtable_iterator_base<Value, cache>::\n-    m_incr_bucket()\n-    {\n-      ++m_cur_bucket;\n-\n-      // This loop requires the bucket array to have a non-null sentinel.\n-      while (!*m_cur_bucket)\n-\t++m_cur_bucket;\n-      m_cur_node = *m_cur_bucket;\n-    }\n-\n-  template<typename Value, bool cache>\n-    inline bool\n-    operator==(const hashtable_iterator_base<Value, cache>& x,\n-\t       const hashtable_iterator_base<Value, cache>& y)\n-    { return x.m_cur_node == y.m_cur_node; }\n-\n-  template<typename Value, bool cache>\n-    inline bool\n-    operator!=(const hashtable_iterator_base<Value, cache>& x,\n-\t       const hashtable_iterator_base<Value, cache>& y)\n-    { return x.m_cur_node != y.m_cur_node; }\n-\n-  template<typename Value, bool constant_iterators, bool cache>\n-    struct hashtable_iterator\n-    : public hashtable_iterator_base<Value, cache>\n-    {\n-      typedef Value                                    value_type;\n-      typedef typename IF<constant_iterators, const Value*, Value*>::type\n-                                                       pointer;\n-      typedef typename IF<constant_iterators, const Value&, Value&>::type\n-                                                       reference;\n-      typedef std::ptrdiff_t                           difference_type;\n-      typedef std::forward_iterator_tag                iterator_category;\n-\n-      hashtable_iterator()\n-      : hashtable_iterator_base<Value, cache>(0, 0) { }\n-\n-      hashtable_iterator(hash_node<Value, cache>* p,\n-\t\t\t hash_node<Value, cache>** b)\n-      : hashtable_iterator_base<Value, cache>(p, b) { }\n-\n-      explicit\n-      hashtable_iterator(hash_node<Value, cache>** b)\n-      : hashtable_iterator_base<Value, cache>(*b, b) { }\n-\n-      reference\n-      operator*() const\n-      { return this->m_cur_node->m_v; }\n-  \n-      pointer\n-      operator->() const\n-      { return &this->m_cur_node->m_v; }\n-\n-      hashtable_iterator&\n-      operator++()\n-      { \n-\tthis->incr();\n-\treturn *this;\n-      }\n-  \n-      hashtable_iterator\n-      operator++(int)\n-      { \n-\thashtable_iterator tmp(*this);\n-\tthis->incr();\n-\treturn tmp;\n-      }\n-    };\n-\n-  template<typename Value, bool constant_iterators, bool cache>\n-    struct hashtable_const_iterator\n-    : public hashtable_iterator_base<Value, cache>\n-    {\n-      typedef Value                                    value_type;\n-      typedef const Value*                             pointer;\n-      typedef const Value&                             reference;\n-      typedef std::ptrdiff_t                           difference_type;\n-      typedef std::forward_iterator_tag                iterator_category;\n-\n-      hashtable_const_iterator()\n-      : hashtable_iterator_base<Value, cache>(0, 0) { }\n-\n-      hashtable_const_iterator(hash_node<Value, cache>* p,\n-\t\t\t       hash_node<Value, cache>** b)\n-      : hashtable_iterator_base<Value, cache>(p, b) { }\n-\n-      explicit\n-      hashtable_const_iterator(hash_node<Value, cache>** b)\n-      : hashtable_iterator_base<Value, cache>(*b, b) { }\n-\n-      hashtable_const_iterator(const hashtable_iterator<Value,\n-\t\t\t       constant_iterators, cache>& x)\n-      : hashtable_iterator_base<Value, cache>(x.m_cur_node, x.m_cur_bucket) { }\n-\n-      reference\n-      operator*() const\n-      { return this->m_cur_node->m_v; }\n-  \n-      pointer\n-      operator->() const\n-      { return &this->m_cur_node->m_v; }\n-\n-      hashtable_const_iterator&\n-      operator++()\n-      { \n-\tthis->incr();\n-\treturn *this;\n-      }\n-  \n-      hashtable_const_iterator\n-      operator++(int)\n-      { \n-\thashtable_const_iterator tmp(*this);\n-\tthis->incr();\n-\treturn tmp;\n-      }\n-    };\n-} // namespace Internal\n-\n-\n-// ----------------------------------------------------------------------\n-// Many of class template hashtable's template parameters are policy\n-// classes.  These are defaults for the policies.\n-\n-namespace Internal\n-{\n-  // The two key extraction policies used by the *set and *map variants.\n-  template<typename T>\n-    struct identity\n-    {\n-      const T&\n-      operator()(const T& t) const\n-      { return t; }\n-    };\n-\n-  template<typename Pair>\n-    struct extract1st\n-    {\n-      const typename Pair::first_type&\n-      operator()(const Pair& p) const\n-      { return p.first; }\n-    };\n-\n-  // Default range hashing function: use division to fold a large number\n-  // into the range [0, N).\n-  struct mod_range_hashing\n-  {\n-    typedef std::size_t first_argument_type;\n-    typedef std::size_t second_argument_type;\n-    typedef std::size_t result_type;\n-\n-    result_type\n-    operator()(first_argument_type r, second_argument_type N) const\n-    { return r % N; }\n-  };\n-\n-  // Default ranged hash function H.  In principle it should be a\n-  // function object composed from objects of type H1 and H2 such that\n-  // h(k, N) = h2(h1(k), N), but that would mean making extra copies of\n-  // h1 and h2.  So instead we'll just use a tag to tell class template\n-  // hashtable to do that composition.\n-  struct default_ranged_hash { };\n-\n-  // Default value for rehash policy.  Bucket size is (usually) the\n-  // smallest prime that keeps the load factor small enough.\n-  struct prime_rehash_policy\n-  {\n-    prime_rehash_policy(float z = 1.0);\n-    \n-    float\n-    max_load_factor() const;\n-\n-    // Return a bucket size no smaller than n.\n-    std::size_t\n-    next_bkt(std::size_t n) const;\n-    \n-    // Return a bucket count appropriate for n elements\n-    std::size_t\n-    bkt_for_elements(std::size_t n) const;\n-    \n-    // n_bkt is current bucket count, n_elt is current element count,\n-    // and n_ins is number of elements to be inserted.  Do we need to\n-    // increase bucket count?  If so, return make_pair(true, n), where n\n-    // is the new bucket count.  If not, return make_pair(false, 0).\n-    std::pair<bool, std::size_t>\n-    need_rehash(std::size_t n_bkt, std::size_t n_elt, std::size_t n_ins) const;\n-    \n-    float               m_max_load_factor;\n-    float               m_growth_factor;\n-    mutable std::size_t m_next_resize;\n-  };\n-\n-  // XXX This is a hack.  prime_rehash_policy's member functions, and\n-  // certainly the list of primes, should be defined in a .cc file.\n-  // We're temporarily putting them in a header because we don't have a\n-  // place to put TR1 .cc files yet.  There's no good reason for any of\n-  // prime_rehash_policy's member functions to be inline, and there's\n-  // certainly no good reason for X<> to exist at all.\n-  \n-  struct lt\n-  {\n-    template<typename X, typename Y>\n-      bool\n-      operator()(X x, Y y)\n-      { return x < y; }\n-  };\n-\n-  template<int ulongsize = sizeof(unsigned long)>\n-    struct X\n-    {\n-      static const int n_primes = ulongsize != 8 ? 256 : 256 + 48;\n-      static const unsigned long primes[256 + 48 + 1];\n-    };\n-\n-  template<int ulongsize>\n-    const int X<ulongsize>::n_primes;\n-\n-  template<int ulongsize>\n-    const unsigned long X<ulongsize>::primes[256 + 48 + 1] =\n-    {\n-      2ul, 3ul, 5ul, 7ul, 11ul, 13ul, 17ul, 19ul, 23ul, 29ul, 31ul,\n-      37ul, 41ul, 43ul, 47ul, 53ul, 59ul, 61ul, 67ul, 71ul, 73ul, 79ul,\n-      83ul, 89ul, 97ul, 103ul, 109ul, 113ul, 127ul, 137ul, 139ul, 149ul,\n-      157ul, 167ul, 179ul, 193ul, 199ul, 211ul, 227ul, 241ul, 257ul,\n-      277ul, 293ul, 313ul, 337ul, 359ul, 383ul, 409ul, 439ul, 467ul,\n-      503ul, 541ul, 577ul, 619ul, 661ul, 709ul, 761ul, 823ul, 887ul,\n-      953ul, 1031ul, 1109ul, 1193ul, 1289ul, 1381ul, 1493ul, 1613ul,\n-      1741ul, 1879ul, 2029ul, 2179ul, 2357ul, 2549ul, 2753ul, 2971ul,\n-      3209ul, 3469ul, 3739ul, 4027ul, 4349ul, 4703ul, 5087ul, 5503ul,\n-      5953ul, 6427ul, 6949ul, 7517ul, 8123ul, 8783ul, 9497ul, 10273ul,\n-      11113ul, 12011ul, 12983ul, 14033ul, 15173ul, 16411ul, 17749ul,\n-      19183ul, 20753ul, 22447ul, 24281ul, 26267ul, 28411ul, 30727ul,\n-      33223ul, 35933ul, 38873ul, 42043ul, 45481ul, 49201ul, 53201ul,\n-      57557ul, 62233ul, 67307ul, 72817ul, 78779ul, 85229ul, 92203ul,\n-      99733ul, 107897ul, 116731ul, 126271ul, 136607ul, 147793ul,\n-      159871ul, 172933ul, 187091ul, 202409ul, 218971ul, 236897ul,\n-      256279ul, 277261ul, 299951ul, 324503ul, 351061ul, 379787ul,\n-      410857ul, 444487ul, 480881ul, 520241ul, 562841ul, 608903ul,\n-      658753ul, 712697ul, 771049ul, 834181ul, 902483ul, 976369ul,\n-      1056323ul, 1142821ul, 1236397ul, 1337629ul, 1447153ul, 1565659ul,\n-      1693859ul, 1832561ul, 1982627ul, 2144977ul, 2320627ul, 2510653ul,\n-      2716249ul, 2938679ul, 3179303ul, 3439651ul, 3721303ul, 4026031ul,\n-      4355707ul, 4712381ul, 5098259ul, 5515729ul, 5967347ul, 6456007ul,\n-      6984629ul, 7556579ul, 8175383ul, 8844859ul, 9569143ul, 10352717ul,\n-      11200489ul, 12117689ul, 13109983ul, 14183539ul, 15345007ul,\n-      16601593ul, 17961079ul, 19431899ul, 21023161ul, 22744717ul,\n-      24607243ul, 26622317ul, 28802401ul, 31160981ul, 33712729ul,\n-      36473443ul, 39460231ul, 42691603ul, 46187573ul, 49969847ul,\n-      54061849ul, 58488943ul, 63278561ul, 68460391ul, 74066549ul,\n-      80131819ul, 86693767ul, 93793069ul, 101473717ul, 109783337ul,\n-      118773397ul, 128499677ul, 139022417ul, 150406843ul, 162723577ul,\n-      176048909ul, 190465427ul, 206062531ul, 222936881ul, 241193053ul,\n-      260944219ul, 282312799ul, 305431229ul, 330442829ul, 357502601ul,\n-      386778277ul, 418451333ul, 452718089ul, 489790921ul, 529899637ul,\n-      573292817ul, 620239453ul, 671030513ul, 725980837ul, 785430967ul,\n-      849749479ul, 919334987ul, 994618837ul, 1076067617ul, 1164186217ul,\n-      1259520799ul, 1362662261ul, 1474249943ul, 1594975441ul,\n-      1725587117ul, 1866894511ul, 2019773507ul, 2185171673ul,\n-      2364114217ul, 2557710269ul, 2767159799ul, 2993761039ul,\n-      3238918481ul, 3504151727ul, 3791104843ul, 4101556399ul,\n-      4294967291ul,\n-      // Sentinel, so we don't have to test the result of lower_bound,\n-      // or, on 64-bit machines, rest of the table.\n-      ulongsize != 8 ? 4294967291ul : (unsigned long)6442450933ull,\n-      (unsigned long)8589934583ull,\n-      (unsigned long)12884901857ull, (unsigned long)17179869143ull,\n-      (unsigned long)25769803693ull, (unsigned long)34359738337ull,\n-      (unsigned long)51539607367ull, (unsigned long)68719476731ull,\n-      (unsigned long)103079215087ull, (unsigned long)137438953447ull,\n-      (unsigned long)206158430123ull, (unsigned long)274877906899ull,\n-      (unsigned long)412316860387ull, (unsigned long)549755813881ull,\n-      (unsigned long)824633720731ull, (unsigned long)1099511627689ull,\n-      (unsigned long)1649267441579ull, (unsigned long)2199023255531ull,\n-      (unsigned long)3298534883309ull, (unsigned long)4398046511093ull,\n-      (unsigned long)6597069766607ull, (unsigned long)8796093022151ull,\n-      (unsigned long)13194139533241ull, (unsigned long)17592186044399ull,\n-      (unsigned long)26388279066581ull, (unsigned long)35184372088777ull,\n-      (unsigned long)52776558133177ull, (unsigned long)70368744177643ull,\n-      (unsigned long)105553116266399ull, (unsigned long)140737488355213ull,\n-      (unsigned long)211106232532861ull, (unsigned long)281474976710597ull,\n-      (unsigned long)562949953421231ull, (unsigned long)1125899906842597ull,\n-      (unsigned long)2251799813685119ull, (unsigned long)4503599627370449ull,\n-      (unsigned long)9007199254740881ull, (unsigned long)18014398509481951ull,\n-      (unsigned long)36028797018963913ull, (unsigned long)72057594037927931ull,\n-      (unsigned long)144115188075855859ull,\n-      (unsigned long)288230376151711717ull,\n-      (unsigned long)576460752303423433ull,\n-      (unsigned long)1152921504606846883ull,\n-      (unsigned long)2305843009213693951ull,\n-      (unsigned long)4611686018427387847ull,\n-      (unsigned long)9223372036854775783ull,\n-      (unsigned long)18446744073709551557ull,\n-      (unsigned long)18446744073709551557ull\n-    };\n-\n-  inline\n-  prime_rehash_policy::\n-  prime_rehash_policy(float z)\n-  : m_max_load_factor(z), m_growth_factor(2.f), m_next_resize(0)\n-  { }\n-\n-  inline float\n-  prime_rehash_policy::\n-  max_load_factor() const\n-  { return m_max_load_factor; }\n-\n-  // Return a prime no smaller than n.\n-  inline std::size_t\n-  prime_rehash_policy::\n-  next_bkt(std::size_t n) const\n-  {\n-    const unsigned long* const last = X<>::primes + X<>::n_primes;\n-    const unsigned long* p = std::lower_bound(X<>::primes, last, n);\n-    m_next_resize = static_cast<std::size_t>(std::ceil(*p * m_max_load_factor));\n-    return *p;\n-  }\n-\n-  // Return the smallest prime p such that alpha p >= n, where alpha\n-  // is the load factor.\n-  inline std::size_t\n-  prime_rehash_policy::\n-  bkt_for_elements(std::size_t n) const\n-  {\n-    const unsigned long* const last = X<>::primes + X<>::n_primes;\n-    const float min_bkts = n / m_max_load_factor;\n-    const unsigned long* p = std::lower_bound(X<>::primes, last,\n-\t\t\t\t\t      min_bkts, lt());\n-    m_next_resize = static_cast<std::size_t>(std::ceil(*p * m_max_load_factor));\n-    return *p;\n-  }\n-\n-  // Finds the smallest prime p such that alpha p > n_elt + n_ins.\n-  // If p > n_bkt, return make_pair(true, p); otherwise return\n-  // make_pair(false, 0).  In principle this isn't very different from \n-  // bkt_for_elements.\n-  \n-  // The only tricky part is that we're caching the element count at\n-  // which we need to rehash, so we don't have to do a floating-point\n-  // multiply for every insertion.\n-  \n-  inline std::pair<bool, std::size_t>\n-  prime_rehash_policy::\n-  need_rehash(std::size_t n_bkt, std::size_t n_elt, std::size_t n_ins) const\n-  {\n-    if (n_elt + n_ins > m_next_resize)\n-      {\n-\tfloat min_bkts = (float(n_ins) + float(n_elt)) / m_max_load_factor;\n-\tif (min_bkts > n_bkt)\n-\t  {\n-\t    min_bkts = std::max(min_bkts, m_growth_factor * n_bkt);\n-\t    const unsigned long* const last = X<>::primes + X<>::n_primes;\n-\t    const unsigned long* p = std::lower_bound(X<>::primes, last,\n-\t\t\t\t\t\t      min_bkts, lt());\n-\t    m_next_resize = \n-\t      static_cast<std::size_t>(std::ceil(*p * m_max_load_factor));\n-\t    return std::make_pair(true, *p);\n-\t  }\n-\telse \n-\t  {\n-\t    m_next_resize = \n-\t      static_cast<std::size_t>(std::ceil(n_bkt * m_max_load_factor));\n-\t    return std::make_pair(false, 0);\n-\t  }\n-      }\n-    else\n-      return std::make_pair(false, 0);\n-  }\n-\n-} // namespace Internal\n-\n-\n-//----------------------------------------------------------------------\n-// Base classes for std::tr1::hashtable.  We define these base classes\n-// because in some cases we want to do different things depending on\n-// the value of a policy class.  In some cases the policy class affects\n-// which member functions and nested typedefs are defined; we handle that\n-// by specializing base class templates.  Several of the base class templates\n-// need to access other members of class template hashtable, so we use\n-// the \"curiously recurring template pattern\" for them.\n-\n-namespace Internal\n-{\n-  // class template map_base.  If the hashtable has a value type of the\n-  // form pair<T1, T2> and a key extraction policy that returns the\n-  // first part of the pair, the hashtable gets a mapped_type typedef.\n-  // If it satisfies those criteria and also has unique keys, then it\n-  // also gets an operator[].\n-  \n-  template<typename K, typename V, typename Ex, bool unique, typename Hashtable>\n-    struct map_base { };\n-\t  \n-  template<typename K, typename Pair, typename Hashtable>\n-    struct map_base<K, Pair, extract1st<Pair>, false, Hashtable>\n-    {\n-      typedef typename Pair::second_type mapped_type;\n-    };\n-\n-  template<typename K, typename Pair, typename Hashtable>\n-    struct map_base<K, Pair, extract1st<Pair>, true, Hashtable>\n-    {\n-      typedef typename Pair::second_type mapped_type;\n-      \n-      mapped_type&\n-      operator[](const K& k);\n-    };\n-\n-  template<typename K, typename Pair, typename Hashtable>\n-    typename map_base<K, Pair, extract1st<Pair>, true, Hashtable>::mapped_type&\n-    map_base<K, Pair, extract1st<Pair>, true, Hashtable>::\n-    operator[](const K& k)\n-    {\n-      Hashtable* h = static_cast<Hashtable*>(this);\n-      typename Hashtable::hash_code_t code = h->m_hash_code(k);\n-      std::size_t n = h->bucket_index(k, code, h->bucket_count());\n-\n-      typename Hashtable::node* p = h->m_find_node(h->m_buckets[n], k, code);\n-      if (!p)\n-\treturn h->m_insert_bucket(std::make_pair(k, mapped_type()),\n-\t\t\t\t  n, code)->second;\n-      return (p->m_v).second;\n-    }\n-\n-  // class template rehash_base.  Give hashtable the max_load_factor\n-  // functions iff the rehash policy is prime_rehash_policy.\n-  template<typename RehashPolicy, typename Hashtable>\n-    struct rehash_base { };\n-\n-  template<typename Hashtable>\n-    struct rehash_base<prime_rehash_policy, Hashtable>\n-    {\n-      float\n-      max_load_factor() const\n-      {\n-\tconst Hashtable* This = static_cast<const Hashtable*>(this);\n-\treturn This->rehash_policy().max_load_factor();\n-      }\n-\n-      void\n-      max_load_factor(float z)\n-      {\n-\tHashtable* This = static_cast<Hashtable*>(this);\n-\tThis->rehash_policy(prime_rehash_policy(z));    \n-      }\n-    };\n-\n-  // Class template hash_code_base.  Encapsulates two policy issues that\n-  // aren't quite orthogonal.\n-  //   (1) the difference between using a ranged hash function and using\n-  //       the combination of a hash function and a range-hashing function.\n-  //       In the former case we don't have such things as hash codes, so\n-  //       we have a dummy type as placeholder.\n-  //   (2) Whether or not we cache hash codes.  Caching hash codes is\n-  //       meaningless if we have a ranged hash function.\n-  // We also put the key extraction and equality comparison function \n-  // objects here, for convenience.\n-  \n-  // Primary template: unused except as a hook for specializations.\n-  \n-  template<typename Key, typename Value,\n-\t   typename ExtractKey, typename Equal,\n-\t   typename H1, typename H2, typename H,\n-\t   bool cache_hash_code>\n-    struct hash_code_base;\n-\n-  // Specialization: ranged hash function, no caching hash codes.  H1\n-  // and H2 are provided but ignored.  We define a dummy hash code type.\n-  template<typename Key, typename Value,\n-\t   typename ExtractKey, typename Equal,\n-\t   typename H1, typename H2, typename H>\n-    struct hash_code_base<Key, Value, ExtractKey, Equal, H1, H2, H, false>\n-    {\n-    protected:\n-      hash_code_base(const ExtractKey& ex, const Equal& eq,\n-\t\t     const H1&, const H2&, const H& h)\n-      : m_extract(ex), m_eq(eq), m_ranged_hash(h) { }\n-\n-      typedef void* hash_code_t;\n-  \n-      hash_code_t\n-      m_hash_code(const Key& k) const\n-      { return 0; }\n-  \n-      std::size_t\n-      bucket_index(const Key& k, hash_code_t, std::size_t N) const\n-      { return m_ranged_hash(k, N); }\n-\n-      std::size_t\n-      bucket_index(const hash_node<Value, false>* p, std::size_t N) const\n-      { return m_ranged_hash(m_extract(p->m_v), N); }\n-  \n-      bool\n-      compare(const Key& k, hash_code_t, hash_node<Value, false>* n) const\n-      { return m_eq(k, m_extract(n->m_v)); }\n-\n-      void\n-      store_code(hash_node<Value, false>*, hash_code_t) const\n-      { }\n-\n-      void\n-      copy_code(hash_node<Value, false>*, const hash_node<Value, false>*) const\n-      { }\n-      \n-      void\n-      m_swap(hash_code_base& x)\n-      {\n-\tstd::swap(m_extract, x.m_extract);\n-\tstd::swap(m_eq, x.m_eq);\n-\tstd::swap(m_ranged_hash, x.m_ranged_hash);\n-      }\n-\n-    protected:\n-      ExtractKey m_extract;\n-      Equal      m_eq;\n-      H          m_ranged_hash;\n-    };\n-\n-\n-  // No specialization for ranged hash function while caching hash codes.\n-  // That combination is meaningless, and trying to do it is an error.\n-  \n-  \n-  // Specialization: ranged hash function, cache hash codes.  This\n-  // combination is meaningless, so we provide only a declaration\n-  // and no definition.\n-  \n-  template<typename Key, typename Value,\n-\t    typename ExtractKey, typename Equal,\n-\t    typename H1, typename H2, typename H>\n-    struct hash_code_base<Key, Value, ExtractKey, Equal, H1, H2, H, true>;\n-\n-\n-  // Specialization: hash function and range-hashing function, no\n-  // caching of hash codes.  H is provided but ignored.  Provides\n-  // typedef and accessor required by TR1.\n-  \n-  template<typename Key, typename Value,\n-\t   typename ExtractKey, typename Equal,\n-\t   typename H1, typename H2>\n-    struct hash_code_base<Key, Value, ExtractKey, Equal, H1, H2,\n-\t\t\t  default_ranged_hash, false>\n-    {\n-      typedef H1 hasher;\n-      \n-      hasher\n-      hash_function() const\n-      { return m_h1; }\n-\n-    protected:\n-      hash_code_base(const ExtractKey& ex, const Equal& eq,\n-\t\t     const H1& h1, const H2& h2, const default_ranged_hash&)\n-      : m_extract(ex), m_eq(eq), m_h1(h1), m_h2(h2) { }\n-\n-      typedef std::size_t hash_code_t;\n-      \n-      hash_code_t\n-      m_hash_code(const Key& k) const\n-      { return m_h1(k); }\n-      \n-      std::size_t\n-      bucket_index(const Key&, hash_code_t c, std::size_t N) const\n-      { return m_h2(c, N); }\n-\n-      std::size_t\n-      bucket_index(const hash_node<Value, false>* p, std::size_t N) const\n-      { return m_h2(m_h1(m_extract(p->m_v)), N); }\n-\n-      bool\n-      compare(const Key& k, hash_code_t, hash_node<Value, false>* n) const\n-      { return m_eq(k, m_extract(n->m_v)); }\n-\n-      void\n-      store_code(hash_node<Value, false>*, hash_code_t) const\n-      { }\n-\n-      void\n-      copy_code(hash_node<Value, false>*, const hash_node<Value, false>*) const\n-      { }\n-\n-      void\n-      m_swap(hash_code_base& x)\n-      {\n-\tstd::swap(m_extract, x.m_extract);\n-\tstd::swap(m_eq, x.m_eq);\n-\tstd::swap(m_h1, x.m_h1);\n-\tstd::swap(m_h2, x.m_h2);\n-      }\n-\n-    protected:\n-      ExtractKey m_extract;\n-      Equal      m_eq;\n-      H1         m_h1;\n-      H2         m_h2;\n-    };\n-\n-  // Specialization: hash function and range-hashing function, \n-  // caching hash codes.  H is provided but ignored.  Provides\n-  // typedef and accessor required by TR1.\n-  template<typename Key, typename Value,\n-\t   typename ExtractKey, typename Equal,\n-\t   typename H1, typename H2>\n-    struct hash_code_base<Key, Value, ExtractKey, Equal, H1, H2,\n-\t\t\t  default_ranged_hash, true>\n-    {\n-      typedef H1 hasher;\n-      \n-      hasher\n-      hash_function() const\n-      { return m_h1; }\n-\n-    protected:\n-      hash_code_base(const ExtractKey& ex, const Equal& eq,\n-\t\t     const H1& h1, const H2& h2, const default_ranged_hash&)\n-      : m_extract(ex), m_eq(eq), m_h1(h1), m_h2(h2) { }\n-\n-      typedef std::size_t hash_code_t;\n-  \n-      hash_code_t\n-      m_hash_code(const Key& k) const\n-      { return m_h1(k); }\n-  \n-      std::size_t\n-      bucket_index(const Key&, hash_code_t c, std::size_t N) const\n-      { return m_h2(c, N); }\n-\n-      std::size_t\n-      bucket_index(const hash_node<Value, true>* p, std::size_t N) const\n-      { return m_h2(p->hash_code, N); }\n-\n-      bool\n-      compare(const Key& k, hash_code_t c, hash_node<Value, true>* n) const\n-      { return c == n->hash_code && m_eq(k, m_extract(n->m_v)); }\n-\n-      void\n-      store_code(hash_node<Value, true>* n, hash_code_t c) const\n-      { n->hash_code = c; }\n-\n-      void\n-      copy_code(hash_node<Value, true>* to,\n-\t\tconst hash_node<Value, true>* from) const\n-      { to->hash_code = from->hash_code; }\n-\n-      void\n-      m_swap(hash_code_base& x)\n-      {\n-\tstd::swap(m_extract, x.m_extract);\n-\tstd::swap(m_eq, x.m_eq);\n-\tstd::swap(m_h1, x.m_h1);\n-\tstd::swap(m_h2, x.m_h2);\n-      }\n-      \n-    protected:\n-      ExtractKey m_extract;\n-      Equal      m_eq;\n-      H1         m_h1;\n-      H2         m_h2;\n-    };\n-\n-} // namespace internal\n+#include <tr1/hashtable_policy.h>\n \n namespace std\n { \n _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \n-  //----------------------------------------------------------------------\n   // Class template hashtable, class definition.\n   \n   // Meaning of class template hashtable's template parameters\n@@ -994,27 +122,26 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n   // true for unordered_set and unordered_map, false for unordered_multiset\n   // and unordered_multimap.\n   \n-  template<typename Key, typename Value, \n-\t   typename Allocator,\n+  template<typename Key, typename Value, typename Allocator,\n \t   typename ExtractKey, typename Equal,\n-\t   typename H1, typename H2,\n-\t   typename H, typename RehashPolicy,\n+\t   typename H1, typename H2, typename H, \n+\t   typename RehashPolicy,\n \t   bool cache_hash_code,\n \t   bool constant_iterators,\n \t   bool unique_keys>\n     class hashtable\n-    : public Internal::rehash_base<RehashPolicy,\n-\t\t\t\t   hashtable<Key, Value, Allocator, ExtractKey,\n-\t\t\t\t\t     Equal, H1, H2, H, RehashPolicy,\n-\t\t\t\t\t     cache_hash_code, constant_iterators,\n-\t\t\t\t\t     unique_keys> >,\n-      public Internal::hash_code_base<Key, Value, ExtractKey, Equal, H1, H2, H,\n-\t\t\t\t      cache_hash_code>,\n-      public Internal::map_base<Key, Value, ExtractKey, unique_keys,\n-\t\t\t\thashtable<Key, Value, Allocator, ExtractKey,\n-\t\t\t\t\t  Equal, H1, H2, H, RehashPolicy,\n-\t\t\t\t\t  cache_hash_code, constant_iterators,\n-\t\t\t\t\t  unique_keys> >\n+    : public detail::rehash_base<RehashPolicy,\n+\t\t\t\t hashtable<Key, Value, Allocator, ExtractKey,\n+\t\t\t\t\t   Equal, H1, H2, H, RehashPolicy,\n+\t\t\t\t\t   cache_hash_code, constant_iterators,\n+\t\t\t\t\t   unique_keys> >,\n+      public detail::hash_code_base<Key, Value, ExtractKey, Equal, H1, H2, H,\n+\t\t\t\t    cache_hash_code>,\n+      public detail::map_base<Key, Value, ExtractKey, unique_keys,\n+\t\t\t      hashtable<Key, Value, Allocator, ExtractKey,\n+\t\t\t\t\tEqual, H1, H2, H, RehashPolicy,\n+\t\t\t\t\tcache_hash_code, constant_iterators,\n+\t\t\t\t\tunique_keys> >\n     {\n     public:\n       typedef Allocator                                   allocator_type;\n@@ -1028,31 +155,30 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       typedef typename Allocator::reference               reference;\n       typedef typename Allocator::const_reference         const_reference;\n       \n-      typedef Internal::node_iterator<value_type, constant_iterators,\n+      typedef detail::node_iterator<value_type, constant_iterators,\n \t\t\t\t      cache_hash_code>\n                                                           local_iterator;\n-      typedef Internal::node_const_iterator<value_type, constant_iterators,\n+      typedef detail::node_const_iterator<value_type, constant_iterators,\n \t\t\t\t\t    cache_hash_code>\n                                                           const_local_iterator;\n \n-      typedef Internal::hashtable_iterator<value_type, constant_iterators,\n+      typedef detail::hashtable_iterator<value_type, constant_iterators,\n \t\t\t\t\t   cache_hash_code>\n                                                           iterator;\n-      typedef Internal::hashtable_const_iterator<value_type, constant_iterators,\n+      typedef detail::hashtable_const_iterator<value_type, constant_iterators,\n \t\t\t\t\t\t cache_hash_code>\n                                                           const_iterator;\n \n       template<typename K, typename Pair, typename Hashtable>\n-        friend struct Internal::map_base;\n+        friend struct detail::map_base;\n \n     private:\n-      typedef Internal::hash_node<Value, cache_hash_code> node;\n+      typedef detail::hash_node<Value, cache_hash_code> node;\n       typedef typename Allocator::template rebind<node>::other\n                                                           node_allocator_t;\n       typedef typename Allocator::template rebind<node*>::other\n                                                           bucket_allocator_t;\n \n-    private:\n       node_allocator_t      m_node_allocator;\n       node**                m_buckets;\n       size_type             m_bucket_count;\n@@ -1074,7 +200,8 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       void\n       m_deallocate_buckets(node**, size_type n);\n \n-    public:\t\t\t    // Constructor, destructor, assignment, swap\n+    public:\t\t\t    \n+      // Constructor, destructor, assignment, swap\n       hashtable(size_type bucket_hint,\n \t\tconst H1&, const H2&, const H&,\n \t\tconst Equal&, const ExtractKey&,\n@@ -1096,7 +223,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \n       void swap(hashtable&);\n \n-    public:\t\t\t\t// Basic container operations\n+      // Basic container operations\n       iterator\n       begin()\n       {\n@@ -1139,14 +266,14 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       max_size() const\n       { return m_node_allocator.max_size(); }\n \n-    public:                             // Observers\n+      // Observers\n       key_equal\n       key_eq() const\n       { return this->m_eq; }\n \n       // hash_function, if present, comes from hash_code_base.\n \n-    public:\t\t\t\t// Bucket operations\n+      // Bucket operations\n       size_type\n       bucket_count() const\n       { return m_bucket_count; }\n@@ -1199,7 +326,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       void \n       rehash_policy(const RehashPolicy&);\n \n-    public:\t\t\t\t// lookup\n+      // Lookup.\n       iterator\n       find(const key_type& k);\n \n@@ -1220,13 +347,13 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       // have partial specialization of member templates; it would be\n       // better to just specialize insert on unique_keys.  There may be a\n       // cleaner workaround.\n-      typedef typename Internal::IF<unique_keys,\n+      typedef typename detail::IF<unique_keys,\n \t\t\t\t    std::pair<iterator, bool>, iterator>::type\n         Insert_Return_Type;\n \n-      typedef typename Internal::IF<unique_keys,\n-\t\t\t\t    Internal::extract1st<Insert_Return_Type>,\n-\t\t\t\t    Internal::identity<Insert_Return_Type>\n+      typedef typename detail::IF<unique_keys,\n+\t\t\t\t    detail::extract1st<Insert_Return_Type>,\n+\t\t\t\t    detail::identity<Insert_Return_Type>\n                                    >::type\n         Insert_Conv_Type;\n \n@@ -1247,7 +374,8 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       void\n       m_erase_node(node*, node**);\n \n-    public:\t\t\t\t// Insert and erase\n+    public:\t\t\t\t\n+      // Insert and erase\n       Insert_Return_Type\n       insert(const value_type& v) \n       { return m_insert(v, std::tr1::integral_constant<bool, unique_keys>()); }\n@@ -1282,7 +410,6 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       void\n       clear();\n \n-    public:\n       // Set number of buckets to be appropriate for container of n element.\n       void rehash(size_type n);\n       \n@@ -1292,9 +419,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n     };\n \n \n-  //----------------------------------------------------------------------\n   // Definitions of class template hashtable's out-of-line member functions.\n-\n   template<typename K, typename V, \n \t   typename A, typename Ex, typename Eq,\n \t   typename H1, typename H2, typename H, typename RP,\n@@ -1389,9 +514,9 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \t      const H1& h1, const H2& h2, const H& h,\n \t      const Eq& eq, const Ex& exk,\n \t      const allocator_type& a)\n-    : Internal::rehash_base<RP, hashtable>(),\n-      Internal::hash_code_base<K, V, Ex, Eq, H1, H2, H, c>(exk, eq, h1, h2, h),\n-      Internal::map_base<K, V, Ex, u, hashtable>(),\n+    : detail::rehash_base<RP, hashtable>(),\n+      detail::hash_code_base<K, V, Ex, Eq, H1, H2, H, c>(exk, eq, h1, h2, h),\n+      detail::map_base<K, V, Ex, u, hashtable>(),\n       m_node_allocator(a),\n       m_bucket_count(0),\n       m_element_count(0),\n@@ -1412,18 +537,18 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \t\tconst H1& h1, const H2& h2, const H& h,\n \t\tconst Eq& eq, const Ex& exk,\n \t\tconst allocator_type& a)\n-      : Internal::rehash_base<RP, hashtable>(),\n-\tInternal::hash_code_base<K, V, Ex, Eq, H1, H2, H, c>(exk, eq,\n+      : detail::rehash_base<RP, hashtable>(),\n+\tdetail::hash_code_base<K, V, Ex, Eq, H1, H2, H, c>(exk, eq,\n \t\t\t\t\t\t\t     h1, h2, h),\n-\tInternal::map_base<K, V, Ex, u, hashtable>(),\n+\tdetail::map_base<K, V, Ex, u, hashtable>(),\n \tm_node_allocator(a),\n \tm_bucket_count(0),\n \tm_element_count(0),\n \tm_rehash_policy()\n       {\n \tm_bucket_count = std::max(m_rehash_policy.next_bkt(bucket_hint),\n \t\t\t\t  m_rehash_policy.\n-\t\t\t\t  bkt_for_elements(Internal::\n+\t\t\t\t  bkt_for_elements(detail::\n \t\t\t\t\t\t   distance_fw(f, l)));\n \tm_buckets = m_allocate_buckets(m_bucket_count);\n \ttry\n@@ -1445,9 +570,9 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \t   bool c, bool ci, bool u>\n     hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n     hashtable(const hashtable& ht)\n-    : Internal::rehash_base<RP, hashtable>(ht),\n-      Internal::hash_code_base<K, V, Ex, Eq, H1, H2, H, c>(ht),\n-      Internal::map_base<K, V, Ex, u, hashtable>(ht),\n+    : detail::rehash_base<RP, hashtable>(ht),\n+      detail::hash_code_base<K, V, Ex, Eq, H1, H2, H, c>(ht),\n+      detail::map_base<K, V, Ex, u, hashtable>(ht),\n       m_node_allocator(ht.get_allocator()),\n       m_bucket_count(ht.m_bucket_count),\n       m_element_count(ht.m_element_count),\n@@ -1512,7 +637,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       // The only base class with member variables is hash_code_base.  We\n       // define hash_code_base::m_swap because different specializations\n       // have different members.\n-      Internal::hash_code_base<K, V, Ex, Eq, H1, H2, H, c>::m_swap(x);\n+      detail::hash_code_base<K, V, Ex, Eq, H1, H2, H, c>::m_swap(x);\n \n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // 431. Swapping containers with unequal allocators.\n@@ -1799,7 +924,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n       insert(InIter first, InIter last)\n       {\n-\tsize_type n_elt = Internal::distance_fw(first, last);\n+\tsize_type n_elt = detail::distance_fw(first, last);\n \tstd::pair<bool, std::size_t> do_rehash\n \t  = m_rehash_policy.need_rehash(m_bucket_count, m_element_count, n_elt);\n \tif (do_rehash.first)"}, {"sha": "57b6e8914f36825b9fa52c6129791de8aae65b16", "filename": "libstdc++-v3/include/tr1/hashtable_policy.h", "status": "added", "additions": 893, "deletions": 0, "changes": 893, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable_policy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable_policy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable_policy.h?ref=b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d", "patch": "@@ -0,0 +1,893 @@\n+// Internal policy header for TR1 unordered_set and unordered_map -*- C++ -*-\n+\n+// Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file \n+ *  This is a TR1 C++ Library header. \n+ */\n+\n+#ifndef _TR1_HASHTABLE_POLICY_H\n+#define _TR1_HASHTABLE_POLICY_H 1\n+\n+namespace std\n+{ \n+_GLIBCXX_BEGIN_NAMESPACE(tr1)\n+namespace detail\n+{\n+namespace \n+{\n+  // General utilities.\n+  template<bool Flag, typename IfTrue, typename IfFalse>\n+    struct IF;\n+\n+  template<typename IfTrue, typename IfFalse>\n+    struct IF<true, IfTrue, IfFalse>\n+    { typedef IfTrue type; };\n+ \n+  template <typename IfTrue, typename IfFalse>\n+    struct IF<false, IfTrue, IfFalse>\n+    { typedef IfFalse type; };\n+\n+  // Helper function: return distance(first, last) for forward\n+  // iterators, or 0 for input iterators.\n+  template<class Iterator>\n+    inline typename std::iterator_traits<Iterator>::difference_type\n+    distance_fw(Iterator first, Iterator last, std::input_iterator_tag)\n+    { return 0; }\n+\n+  template<class Iterator>\n+    inline typename std::iterator_traits<Iterator>::difference_type\n+    distance_fw(Iterator first, Iterator last, std::forward_iterator_tag)\n+    { return std::distance(first, last); }\n+\n+  template<class Iterator>\n+    inline typename std::iterator_traits<Iterator>::difference_type\n+    distance_fw(Iterator first, Iterator last)\n+    {\n+      typedef typename std::iterator_traits<Iterator>::iterator_category tag;\n+      return distance_fw(first, last, tag());\n+    }\n+\n+  // XXX This is a hack.  prime_rehash_policy's member functions, and\n+  // certainly the list of primes, should be defined in a .cc file.\n+  // We're temporarily putting them in a header because we don't have a\n+  // place to put TR1 .cc files yet.  There's no good reason for any of\n+  // prime_rehash_policy's member functions to be inline, and there's\n+  // certainly no good reason for X<> to exist at all.  \n+  struct lt\n+  {\n+    template<typename X, typename Y>\n+      bool\n+      operator()(X x, Y y)\n+      { return x < y; }\n+  };\n+\n+  template<int ulongsize = sizeof(unsigned long)>\n+    struct X\n+    {\n+      static const int n_primes = ulongsize != 8 ? 256 : 256 + 48;\n+      static const unsigned long primes[256 + 48 + 1];\n+    };\n+\n+  template<int ulongsize>\n+    const int X<ulongsize>::n_primes;\n+\n+  template<int ulongsize>\n+    const unsigned long X<ulongsize>::primes[256 + 48 + 1] =\n+    {\n+      2ul, 3ul, 5ul, 7ul, 11ul, 13ul, 17ul, 19ul, 23ul, 29ul, 31ul,\n+      37ul, 41ul, 43ul, 47ul, 53ul, 59ul, 61ul, 67ul, 71ul, 73ul, 79ul,\n+      83ul, 89ul, 97ul, 103ul, 109ul, 113ul, 127ul, 137ul, 139ul, 149ul,\n+      157ul, 167ul, 179ul, 193ul, 199ul, 211ul, 227ul, 241ul, 257ul,\n+      277ul, 293ul, 313ul, 337ul, 359ul, 383ul, 409ul, 439ul, 467ul,\n+      503ul, 541ul, 577ul, 619ul, 661ul, 709ul, 761ul, 823ul, 887ul,\n+      953ul, 1031ul, 1109ul, 1193ul, 1289ul, 1381ul, 1493ul, 1613ul,\n+      1741ul, 1879ul, 2029ul, 2179ul, 2357ul, 2549ul, 2753ul, 2971ul,\n+      3209ul, 3469ul, 3739ul, 4027ul, 4349ul, 4703ul, 5087ul, 5503ul,\n+      5953ul, 6427ul, 6949ul, 7517ul, 8123ul, 8783ul, 9497ul, 10273ul,\n+      11113ul, 12011ul, 12983ul, 14033ul, 15173ul, 16411ul, 17749ul,\n+      19183ul, 20753ul, 22447ul, 24281ul, 26267ul, 28411ul, 30727ul,\n+      33223ul, 35933ul, 38873ul, 42043ul, 45481ul, 49201ul, 53201ul,\n+      57557ul, 62233ul, 67307ul, 72817ul, 78779ul, 85229ul, 92203ul,\n+      99733ul, 107897ul, 116731ul, 126271ul, 136607ul, 147793ul,\n+      159871ul, 172933ul, 187091ul, 202409ul, 218971ul, 236897ul,\n+      256279ul, 277261ul, 299951ul, 324503ul, 351061ul, 379787ul,\n+      410857ul, 444487ul, 480881ul, 520241ul, 562841ul, 608903ul,\n+      658753ul, 712697ul, 771049ul, 834181ul, 902483ul, 976369ul,\n+      1056323ul, 1142821ul, 1236397ul, 1337629ul, 1447153ul, 1565659ul,\n+      1693859ul, 1832561ul, 1982627ul, 2144977ul, 2320627ul, 2510653ul,\n+      2716249ul, 2938679ul, 3179303ul, 3439651ul, 3721303ul, 4026031ul,\n+      4355707ul, 4712381ul, 5098259ul, 5515729ul, 5967347ul, 6456007ul,\n+      6984629ul, 7556579ul, 8175383ul, 8844859ul, 9569143ul, 10352717ul,\n+      11200489ul, 12117689ul, 13109983ul, 14183539ul, 15345007ul,\n+      16601593ul, 17961079ul, 19431899ul, 21023161ul, 22744717ul,\n+      24607243ul, 26622317ul, 28802401ul, 31160981ul, 33712729ul,\n+      36473443ul, 39460231ul, 42691603ul, 46187573ul, 49969847ul,\n+      54061849ul, 58488943ul, 63278561ul, 68460391ul, 74066549ul,\n+      80131819ul, 86693767ul, 93793069ul, 101473717ul, 109783337ul,\n+      118773397ul, 128499677ul, 139022417ul, 150406843ul, 162723577ul,\n+      176048909ul, 190465427ul, 206062531ul, 222936881ul, 241193053ul,\n+      260944219ul, 282312799ul, 305431229ul, 330442829ul, 357502601ul,\n+      386778277ul, 418451333ul, 452718089ul, 489790921ul, 529899637ul,\n+      573292817ul, 620239453ul, 671030513ul, 725980837ul, 785430967ul,\n+      849749479ul, 919334987ul, 994618837ul, 1076067617ul, 1164186217ul,\n+      1259520799ul, 1362662261ul, 1474249943ul, 1594975441ul,\n+      1725587117ul, 1866894511ul, 2019773507ul, 2185171673ul,\n+      2364114217ul, 2557710269ul, 2767159799ul, 2993761039ul,\n+      3238918481ul, 3504151727ul, 3791104843ul, 4101556399ul,\n+      4294967291ul,\n+      // Sentinel, so we don't have to test the result of lower_bound,\n+      // or, on 64-bit machines, rest of the table.\n+      ulongsize != 8 ? 4294967291ul : (unsigned long)6442450933ull,\n+      (unsigned long)8589934583ull,\n+      (unsigned long)12884901857ull, (unsigned long)17179869143ull,\n+      (unsigned long)25769803693ull, (unsigned long)34359738337ull,\n+      (unsigned long)51539607367ull, (unsigned long)68719476731ull,\n+      (unsigned long)103079215087ull, (unsigned long)137438953447ull,\n+      (unsigned long)206158430123ull, (unsigned long)274877906899ull,\n+      (unsigned long)412316860387ull, (unsigned long)549755813881ull,\n+      (unsigned long)824633720731ull, (unsigned long)1099511627689ull,\n+      (unsigned long)1649267441579ull, (unsigned long)2199023255531ull,\n+      (unsigned long)3298534883309ull, (unsigned long)4398046511093ull,\n+      (unsigned long)6597069766607ull, (unsigned long)8796093022151ull,\n+      (unsigned long)13194139533241ull, (unsigned long)17592186044399ull,\n+      (unsigned long)26388279066581ull, (unsigned long)35184372088777ull,\n+      (unsigned long)52776558133177ull, (unsigned long)70368744177643ull,\n+      (unsigned long)105553116266399ull, (unsigned long)140737488355213ull,\n+      (unsigned long)211106232532861ull, (unsigned long)281474976710597ull,\n+      (unsigned long)562949953421231ull, (unsigned long)1125899906842597ull,\n+      (unsigned long)2251799813685119ull, (unsigned long)4503599627370449ull,\n+      (unsigned long)9007199254740881ull, (unsigned long)18014398509481951ull,\n+      (unsigned long)36028797018963913ull, (unsigned long)72057594037927931ull,\n+      (unsigned long)144115188075855859ull,\n+      (unsigned long)288230376151711717ull,\n+      (unsigned long)576460752303423433ull,\n+      (unsigned long)1152921504606846883ull,\n+      (unsigned long)2305843009213693951ull,\n+      (unsigned long)4611686018427387847ull,\n+      (unsigned long)9223372036854775783ull,\n+      (unsigned long)18446744073709551557ull,\n+      (unsigned long)18446744073709551557ull\n+    };\n+} // anonymous namespace\n+\n+  // Auxiliary types used for all instantiations of hashtable: nodes\n+  // and iterators.\n+  \n+  // Nodes, used to wrap elements stored in the hash table.  A policy\n+  // template parameter of class template hashtable controls whether\n+  // nodes also store a hash code. In some cases (e.g. strings) this\n+  // may be a performance win.\n+  template<typename Value, bool cache_hash_code>\n+    struct hash_node;\n+\n+  template<typename Value>\n+    struct hash_node<Value, true>\n+    {\n+      Value       m_v;\n+      std::size_t hash_code;\n+      hash_node*  m_next;\n+    };\n+\n+  template<typename Value>\n+    struct hash_node<Value, false>\n+    {\n+      Value       m_v;\n+      hash_node*  m_next;\n+    };\n+\n+  // Local iterators, used to iterate within a bucket but not between\n+  // buckets.\n+  template<typename Value, bool cache>\n+    struct node_iterator_base\n+    {\n+      node_iterator_base(hash_node<Value, cache>* p)\n+      : m_cur(p) { }\n+      \n+      void\n+      incr()\n+      { m_cur = m_cur->m_next; }\n+\n+      hash_node<Value, cache>* m_cur;\n+    };\n+\n+  template<typename Value, bool cache>\n+    inline bool\n+    operator==(const node_iterator_base<Value, cache>& x,\n+\t       const node_iterator_base<Value, cache>& y)\n+    { return x.m_cur == y.m_cur; }\n+\n+  template<typename Value, bool cache>\n+    inline bool\n+    operator!=(const node_iterator_base<Value, cache>& x,\n+\t       const node_iterator_base<Value, cache>& y)\n+    { return x.m_cur != y.m_cur; }\n+\n+  template<typename Value, bool constant_iterators, bool cache>\n+    struct node_iterator\n+    : public node_iterator_base<Value, cache>\n+    {\n+      typedef Value                                    value_type;\n+      typedef typename IF<constant_iterators, const Value*, Value*>::type\n+                                                       pointer;\n+      typedef typename IF<constant_iterators, const Value&, Value&>::type\n+                                                       reference;\n+      typedef std::ptrdiff_t                           difference_type;\n+      typedef std::forward_iterator_tag                iterator_category;\n+\n+      node_iterator()\n+      : node_iterator_base<Value, cache>(0) { }\n+\n+      explicit\n+      node_iterator(hash_node<Value, cache>* p)\n+      : node_iterator_base<Value, cache>(p) { }\n+\n+      reference\n+      operator*() const\n+      { return this->m_cur->m_v; }\n+  \n+      pointer\n+      operator->() const\n+      { return &this->m_cur->m_v; }\n+\n+      node_iterator&\n+      operator++()\n+      { \n+\tthis->incr(); \n+\treturn *this; \n+      }\n+  \n+      node_iterator\n+      operator++(int)\n+      { \n+\tnode_iterator tmp(*this);\n+\tthis->incr();\n+\treturn tmp;\n+      }\n+    };\n+\n+  template<typename Value, bool constant_iterators, bool cache>\n+    struct node_const_iterator\n+    : public node_iterator_base<Value, cache>\n+    {\n+      typedef Value                                    value_type;\n+      typedef const Value*                             pointer;\n+      typedef const Value&                             reference;\n+      typedef std::ptrdiff_t                           difference_type;\n+      typedef std::forward_iterator_tag                iterator_category;\n+\n+      node_const_iterator()\n+      : node_iterator_base<Value, cache>(0) { }\n+\n+      explicit\n+      node_const_iterator(hash_node<Value, cache>* p)\n+      : node_iterator_base<Value, cache>(p) { }\n+\n+      node_const_iterator(const node_iterator<Value, constant_iterators,\n+\t\t\t  cache>& x)\n+      : node_iterator_base<Value, cache>(x.m_cur) { }\n+\n+      reference\n+      operator*() const\n+      { return this->m_cur->m_v; }\n+  \n+      pointer\n+      operator->() const\n+      { return &this->m_cur->m_v; }\n+\n+      node_const_iterator&\n+      operator++()\n+      { \n+\tthis->incr(); \n+\treturn *this; \n+      }\n+  \n+      node_const_iterator\n+      operator++(int)\n+      { \n+\tnode_const_iterator tmp(*this);\n+\tthis->incr();\n+\treturn tmp;\n+      }\n+    };\n+\n+  template<typename Value, bool cache>\n+    struct hashtable_iterator_base\n+    {\n+      hashtable_iterator_base(hash_node<Value, cache>* node,\n+\t\t\t      hash_node<Value, cache>** bucket)\n+      : m_cur_node(node), m_cur_bucket(bucket) { }\n+\n+      void\n+      incr()\n+      {\n+\tm_cur_node = m_cur_node->m_next;\n+\tif (!m_cur_node)\n+\t  m_incr_bucket();\n+      }\n+\n+      void\n+      m_incr_bucket();\n+\n+      hash_node<Value, cache>*  m_cur_node;\n+      hash_node<Value, cache>** m_cur_bucket;\n+    };\n+\n+  // Global iterators, used for arbitrary iteration within a hash\n+  // table.  Larger and more expensive than local iterators.\n+  template<typename Value, bool cache>\n+    void\n+    hashtable_iterator_base<Value, cache>::\n+    m_incr_bucket()\n+    {\n+      ++m_cur_bucket;\n+\n+      // This loop requires the bucket array to have a non-null sentinel.\n+      while (!*m_cur_bucket)\n+\t++m_cur_bucket;\n+      m_cur_node = *m_cur_bucket;\n+    }\n+\n+  template<typename Value, bool cache>\n+    inline bool\n+    operator==(const hashtable_iterator_base<Value, cache>& x,\n+\t       const hashtable_iterator_base<Value, cache>& y)\n+    { return x.m_cur_node == y.m_cur_node; }\n+\n+  template<typename Value, bool cache>\n+    inline bool\n+    operator!=(const hashtable_iterator_base<Value, cache>& x,\n+\t       const hashtable_iterator_base<Value, cache>& y)\n+    { return x.m_cur_node != y.m_cur_node; }\n+\n+  template<typename Value, bool constant_iterators, bool cache>\n+    struct hashtable_iterator\n+    : public hashtable_iterator_base<Value, cache>\n+    {\n+      typedef Value                                    value_type;\n+      typedef typename IF<constant_iterators, const Value*, Value*>::type\n+                                                       pointer;\n+      typedef typename IF<constant_iterators, const Value&, Value&>::type\n+                                                       reference;\n+      typedef std::ptrdiff_t                           difference_type;\n+      typedef std::forward_iterator_tag                iterator_category;\n+\n+      hashtable_iterator()\n+      : hashtable_iterator_base<Value, cache>(0, 0) { }\n+\n+      hashtable_iterator(hash_node<Value, cache>* p,\n+\t\t\t hash_node<Value, cache>** b)\n+      : hashtable_iterator_base<Value, cache>(p, b) { }\n+\n+      explicit\n+      hashtable_iterator(hash_node<Value, cache>** b)\n+      : hashtable_iterator_base<Value, cache>(*b, b) { }\n+\n+      reference\n+      operator*() const\n+      { return this->m_cur_node->m_v; }\n+  \n+      pointer\n+      operator->() const\n+      { return &this->m_cur_node->m_v; }\n+\n+      hashtable_iterator&\n+      operator++()\n+      { \n+\tthis->incr();\n+\treturn *this;\n+      }\n+  \n+      hashtable_iterator\n+      operator++(int)\n+      { \n+\thashtable_iterator tmp(*this);\n+\tthis->incr();\n+\treturn tmp;\n+      }\n+    };\n+\n+  template<typename Value, bool constant_iterators, bool cache>\n+    struct hashtable_const_iterator\n+    : public hashtable_iterator_base<Value, cache>\n+    {\n+      typedef Value                                    value_type;\n+      typedef const Value*                             pointer;\n+      typedef const Value&                             reference;\n+      typedef std::ptrdiff_t                           difference_type;\n+      typedef std::forward_iterator_tag                iterator_category;\n+\n+      hashtable_const_iterator()\n+      : hashtable_iterator_base<Value, cache>(0, 0) { }\n+\n+      hashtable_const_iterator(hash_node<Value, cache>* p,\n+\t\t\t       hash_node<Value, cache>** b)\n+      : hashtable_iterator_base<Value, cache>(p, b) { }\n+\n+      explicit\n+      hashtable_const_iterator(hash_node<Value, cache>** b)\n+      : hashtable_iterator_base<Value, cache>(*b, b) { }\n+\n+      hashtable_const_iterator(const hashtable_iterator<Value,\n+\t\t\t       constant_iterators, cache>& x)\n+      : hashtable_iterator_base<Value, cache>(x.m_cur_node, x.m_cur_bucket) { }\n+\n+      reference\n+      operator*() const\n+      { return this->m_cur_node->m_v; }\n+  \n+      pointer\n+      operator->() const\n+      { return &this->m_cur_node->m_v; }\n+\n+      hashtable_const_iterator&\n+      operator++()\n+      { \n+\tthis->incr();\n+\treturn *this;\n+      }\n+  \n+      hashtable_const_iterator\n+      operator++(int)\n+      { \n+\thashtable_const_iterator tmp(*this);\n+\tthis->incr();\n+\treturn tmp;\n+      }\n+    };\n+\n+\n+  // Many of class template hashtable's template parameters are policy\n+  // classes.  These are defaults for the policies.\n+\n+  // The two key extraction policies used by the *set and *map variants.\n+  // XXX pb_ds::type_to_type\n+  template<typename T>\n+    struct identity\n+    {\n+      const T&\n+      operator()(const T& t) const\n+      { return t; }\n+    };\n+\n+  // XXX use std::_Select1st?\n+  template<typename Pair>\n+    struct extract1st\n+    {\n+      const typename Pair::first_type&\n+      operator()(const Pair& p) const\n+      { return p.first; }\n+    };\n+\n+  // Default range hashing function: use division to fold a large number\n+  // into the range [0, N).\n+  struct mod_range_hashing\n+  {\n+    typedef std::size_t first_argument_type;\n+    typedef std::size_t second_argument_type;\n+    typedef std::size_t result_type;\n+\n+    result_type\n+    operator()(first_argument_type r, second_argument_type N) const\n+    { return r % N; }\n+  };\n+\n+  // Default ranged hash function H.  In principle it should be a\n+  // function object composed from objects of type H1 and H2 such that\n+  // h(k, N) = h2(h1(k), N), but that would mean making extra copies of\n+  // h1 and h2.  So instead we'll just use a tag to tell class template\n+  // hashtable to do that composition.\n+  struct default_ranged_hash { };\n+\n+  // Default value for rehash policy.  Bucket size is (usually) the\n+  // smallest prime that keeps the load factor small enough.\n+  struct prime_rehash_policy\n+  {\n+    prime_rehash_policy(float z = 1.0);\n+    \n+    float\n+    max_load_factor() const;\n+\n+    // Return a bucket size no smaller than n.\n+    std::size_t\n+    next_bkt(std::size_t n) const;\n+    \n+    // Return a bucket count appropriate for n elements\n+    std::size_t\n+    bkt_for_elements(std::size_t n) const;\n+    \n+    // n_bkt is current bucket count, n_elt is current element count,\n+    // and n_ins is number of elements to be inserted.  Do we need to\n+    // increase bucket count?  If so, return make_pair(true, n), where n\n+    // is the new bucket count.  If not, return make_pair(false, 0).\n+    std::pair<bool, std::size_t>\n+    need_rehash(std::size_t n_bkt, std::size_t n_elt, std::size_t n_ins) const;\n+    \n+    float               m_max_load_factor;\n+    float               m_growth_factor;\n+    mutable std::size_t m_next_resize;\n+  };\n+\n+  inline\n+  prime_rehash_policy::\n+  prime_rehash_policy(float z)\n+  : m_max_load_factor(z), m_growth_factor(2.f), m_next_resize(0)\n+  { }\n+\n+  inline float\n+  prime_rehash_policy::\n+  max_load_factor() const\n+  { return m_max_load_factor; }\n+\n+  // Return a prime no smaller than n.\n+  inline std::size_t\n+  prime_rehash_policy::\n+  next_bkt(std::size_t n) const\n+  {\n+    const unsigned long* const last = X<>::primes + X<>::n_primes;\n+    const unsigned long* p = std::lower_bound(X<>::primes, last, n);\n+    m_next_resize = static_cast<std::size_t>(std::ceil(*p * m_max_load_factor));\n+    return *p;\n+  }\n+\n+  // Return the smallest prime p such that alpha p >= n, where alpha\n+  // is the load factor.\n+  inline std::size_t\n+  prime_rehash_policy::\n+  bkt_for_elements(std::size_t n) const\n+  {\n+    const unsigned long* const last = X<>::primes + X<>::n_primes;\n+    const float min_bkts = n / m_max_load_factor;\n+    const unsigned long* p = std::lower_bound(X<>::primes, last,\n+\t\t\t\t\t      min_bkts, lt());\n+    m_next_resize = static_cast<std::size_t>(std::ceil(*p * m_max_load_factor));\n+    return *p;\n+  }\n+\n+  // Finds the smallest prime p such that alpha p > n_elt + n_ins.\n+  // If p > n_bkt, return make_pair(true, p); otherwise return\n+  // make_pair(false, 0).  In principle this isn't very different from \n+  // bkt_for_elements.\n+  \n+  // The only tricky part is that we're caching the element count at\n+  // which we need to rehash, so we don't have to do a floating-point\n+  // multiply for every insertion.\n+  \n+  inline std::pair<bool, std::size_t>\n+  prime_rehash_policy::\n+  need_rehash(std::size_t n_bkt, std::size_t n_elt, std::size_t n_ins) const\n+  {\n+    if (n_elt + n_ins > m_next_resize)\n+      {\n+\tfloat min_bkts = (float(n_ins) + float(n_elt)) / m_max_load_factor;\n+\tif (min_bkts > n_bkt)\n+\t  {\n+\t    min_bkts = std::max(min_bkts, m_growth_factor * n_bkt);\n+\t    const unsigned long* const last = X<>::primes + X<>::n_primes;\n+\t    const unsigned long* p = std::lower_bound(X<>::primes, last,\n+\t\t\t\t\t\t      min_bkts, lt());\n+\t    m_next_resize = \n+\t      static_cast<std::size_t>(std::ceil(*p * m_max_load_factor));\n+\t    return std::make_pair(true, *p);\n+\t  }\n+\telse \n+\t  {\n+\t    m_next_resize = \n+\t      static_cast<std::size_t>(std::ceil(n_bkt * m_max_load_factor));\n+\t    return std::make_pair(false, 0);\n+\t  }\n+      }\n+    else\n+      return std::make_pair(false, 0);\n+  }\n+\n+  // Base classes for std::tr1::hashtable.  We define these base\n+  // classes because in some cases we want to do different things\n+  // depending on the value of a policy class.  In some cases the\n+  // policy class affects which member functions and nested typedefs\n+  // are defined; we handle that by specializing base class templates.\n+  // Several of the base class templates need to access other members\n+  // of class template hashtable, so we use the \"curiously recurring\n+  // template pattern\" for them.\n+\n+  // class template map_base.  If the hashtable has a value type of the\n+  // form pair<T1, T2> and a key extraction policy that returns the\n+  // first part of the pair, the hashtable gets a mapped_type typedef.\n+  // If it satisfies those criteria and also has unique keys, then it\n+  // also gets an operator[].  \n+  template<typename K, typename V, typename Ex, bool unique, typename Hashtable>\n+    struct map_base { };\n+\t  \n+  template<typename K, typename Pair, typename Hashtable>\n+    struct map_base<K, Pair, extract1st<Pair>, false, Hashtable>\n+    {\n+      typedef typename Pair::second_type mapped_type;\n+    };\n+\n+  template<typename K, typename Pair, typename Hashtable>\n+    struct map_base<K, Pair, extract1st<Pair>, true, Hashtable>\n+    {\n+      typedef typename Pair::second_type mapped_type;\n+      \n+      mapped_type&\n+      operator[](const K& k);\n+    };\n+\n+  template<typename K, typename Pair, typename Hashtable>\n+    typename map_base<K, Pair, extract1st<Pair>, true, Hashtable>::mapped_type&\n+    map_base<K, Pair, extract1st<Pair>, true, Hashtable>::\n+    operator[](const K& k)\n+    {\n+      Hashtable* h = static_cast<Hashtable*>(this);\n+      typename Hashtable::hash_code_t code = h->m_hash_code(k);\n+      std::size_t n = h->bucket_index(k, code, h->bucket_count());\n+\n+      typename Hashtable::node* p = h->m_find_node(h->m_buckets[n], k, code);\n+      if (!p)\n+\treturn h->m_insert_bucket(std::make_pair(k, mapped_type()),\n+\t\t\t\t  n, code)->second;\n+      return (p->m_v).second;\n+    }\n+\n+  // class template rehash_base.  Give hashtable the max_load_factor\n+  // functions iff the rehash policy is prime_rehash_policy.\n+  template<typename RehashPolicy, typename Hashtable>\n+    struct rehash_base { };\n+\n+  template<typename Hashtable>\n+    struct rehash_base<prime_rehash_policy, Hashtable>\n+    {\n+      float\n+      max_load_factor() const\n+      {\n+\tconst Hashtable* This = static_cast<const Hashtable*>(this);\n+\treturn This->rehash_policy().max_load_factor();\n+      }\n+\n+      void\n+      max_load_factor(float z)\n+      {\n+\tHashtable* This = static_cast<Hashtable*>(this);\n+\tThis->rehash_policy(prime_rehash_policy(z));    \n+      }\n+    };\n+\n+  // Class template hash_code_base.  Encapsulates two policy issues that\n+  // aren't quite orthogonal.\n+  //   (1) the difference between using a ranged hash function and using\n+  //       the combination of a hash function and a range-hashing function.\n+  //       In the former case we don't have such things as hash codes, so\n+  //       we have a dummy type as placeholder.\n+  //   (2) Whether or not we cache hash codes.  Caching hash codes is\n+  //       meaningless if we have a ranged hash function.\n+  // We also put the key extraction and equality comparison function \n+  // objects here, for convenience.\n+  \n+  // Primary template: unused except as a hook for specializations.  \n+  template<typename Key, typename Value,\n+\t   typename ExtractKey, typename Equal,\n+\t   typename H1, typename H2, typename H,\n+\t   bool cache_hash_code>\n+    struct hash_code_base;\n+\n+  // Specialization: ranged hash function, no caching hash codes.  H1\n+  // and H2 are provided but ignored.  We define a dummy hash code type.\n+  template<typename Key, typename Value,\n+\t   typename ExtractKey, typename Equal,\n+\t   typename H1, typename H2, typename H>\n+    struct hash_code_base<Key, Value, ExtractKey, Equal, H1, H2, H, false>\n+    {\n+    protected:\n+      hash_code_base(const ExtractKey& ex, const Equal& eq,\n+\t\t     const H1&, const H2&, const H& h)\n+      : m_extract(ex), m_eq(eq), m_ranged_hash(h) { }\n+\n+      typedef void* hash_code_t;\n+  \n+      hash_code_t\n+      m_hash_code(const Key& k) const\n+      { return 0; }\n+  \n+      std::size_t\n+      bucket_index(const Key& k, hash_code_t, std::size_t N) const\n+      { return m_ranged_hash(k, N); }\n+\n+      std::size_t\n+      bucket_index(const hash_node<Value, false>* p, std::size_t N) const\n+      { return m_ranged_hash(m_extract(p->m_v), N); }\n+  \n+      bool\n+      compare(const Key& k, hash_code_t, hash_node<Value, false>* n) const\n+      { return m_eq(k, m_extract(n->m_v)); }\n+\n+      void\n+      store_code(hash_node<Value, false>*, hash_code_t) const\n+      { }\n+\n+      void\n+      copy_code(hash_node<Value, false>*, const hash_node<Value, false>*) const\n+      { }\n+      \n+      void\n+      m_swap(hash_code_base& x)\n+      {\n+\tstd::swap(m_extract, x.m_extract);\n+\tstd::swap(m_eq, x.m_eq);\n+\tstd::swap(m_ranged_hash, x.m_ranged_hash);\n+      }\n+\n+    protected:\n+      ExtractKey m_extract;\n+      Equal      m_eq;\n+      H          m_ranged_hash;\n+    };\n+\n+\n+  // No specialization for ranged hash function while caching hash codes.\n+  // That combination is meaningless, and trying to do it is an error.\n+  \n+  \n+  // Specialization: ranged hash function, cache hash codes.  This\n+  // combination is meaningless, so we provide only a declaration\n+  // and no definition.  \n+  template<typename Key, typename Value,\n+\t    typename ExtractKey, typename Equal,\n+\t    typename H1, typename H2, typename H>\n+    struct hash_code_base<Key, Value, ExtractKey, Equal, H1, H2, H, true>;\n+\n+\n+  // Specialization: hash function and range-hashing function, no\n+  // caching of hash codes.  H is provided but ignored.  Provides\n+  // typedef and accessor required by TR1.  \n+  template<typename Key, typename Value,\n+\t   typename ExtractKey, typename Equal,\n+\t   typename H1, typename H2>\n+    struct hash_code_base<Key, Value, ExtractKey, Equal, H1, H2,\n+\t\t\t  default_ranged_hash, false>\n+    {\n+      typedef H1 hasher;\n+      \n+      hasher\n+      hash_function() const\n+      { return m_h1; }\n+\n+    protected:\n+      hash_code_base(const ExtractKey& ex, const Equal& eq,\n+\t\t     const H1& h1, const H2& h2, const default_ranged_hash&)\n+      : m_extract(ex), m_eq(eq), m_h1(h1), m_h2(h2) { }\n+\n+      typedef std::size_t hash_code_t;\n+      \n+      hash_code_t\n+      m_hash_code(const Key& k) const\n+      { return m_h1(k); }\n+      \n+      std::size_t\n+      bucket_index(const Key&, hash_code_t c, std::size_t N) const\n+      { return m_h2(c, N); }\n+\n+      std::size_t\n+      bucket_index(const hash_node<Value, false>* p, std::size_t N) const\n+      { return m_h2(m_h1(m_extract(p->m_v)), N); }\n+\n+      bool\n+      compare(const Key& k, hash_code_t, hash_node<Value, false>* n) const\n+      { return m_eq(k, m_extract(n->m_v)); }\n+\n+      void\n+      store_code(hash_node<Value, false>*, hash_code_t) const\n+      { }\n+\n+      void\n+      copy_code(hash_node<Value, false>*, const hash_node<Value, false>*) const\n+      { }\n+\n+      void\n+      m_swap(hash_code_base& x)\n+      {\n+\tstd::swap(m_extract, x.m_extract);\n+\tstd::swap(m_eq, x.m_eq);\n+\tstd::swap(m_h1, x.m_h1);\n+\tstd::swap(m_h2, x.m_h2);\n+      }\n+\n+    protected:\n+      ExtractKey m_extract;\n+      Equal      m_eq;\n+      H1         m_h1;\n+      H2         m_h2;\n+    };\n+\n+  // Specialization: hash function and range-hashing function, \n+  // caching hash codes.  H is provided but ignored.  Provides\n+  // typedef and accessor required by TR1.\n+  template<typename Key, typename Value,\n+\t   typename ExtractKey, typename Equal,\n+\t   typename H1, typename H2>\n+    struct hash_code_base<Key, Value, ExtractKey, Equal, H1, H2,\n+\t\t\t  default_ranged_hash, true>\n+    {\n+      typedef H1 hasher;\n+      \n+      hasher\n+      hash_function() const\n+      { return m_h1; }\n+\n+    protected:\n+      hash_code_base(const ExtractKey& ex, const Equal& eq,\n+\t\t     const H1& h1, const H2& h2, const default_ranged_hash&)\n+      : m_extract(ex), m_eq(eq), m_h1(h1), m_h2(h2) { }\n+\n+      typedef std::size_t hash_code_t;\n+  \n+      hash_code_t\n+      m_hash_code(const Key& k) const\n+      { return m_h1(k); }\n+  \n+      std::size_t\n+      bucket_index(const Key&, hash_code_t c, std::size_t N) const\n+      { return m_h2(c, N); }\n+\n+      std::size_t\n+      bucket_index(const hash_node<Value, true>* p, std::size_t N) const\n+      { return m_h2(p->hash_code, N); }\n+\n+      bool\n+      compare(const Key& k, hash_code_t c, hash_node<Value, true>* n) const\n+      { return c == n->hash_code && m_eq(k, m_extract(n->m_v)); }\n+\n+      void\n+      store_code(hash_node<Value, true>* n, hash_code_t c) const\n+      { n->hash_code = c; }\n+\n+      void\n+      copy_code(hash_node<Value, true>* to,\n+\t\tconst hash_node<Value, true>* from) const\n+      { to->hash_code = from->hash_code; }\n+\n+      void\n+      m_swap(hash_code_base& x)\n+      {\n+\tstd::swap(m_extract, x.m_extract);\n+\tstd::swap(m_eq, x.m_eq);\n+\tstd::swap(m_h1, x.m_h1);\n+\tstd::swap(m_h2, x.m_h2);\n+      }\n+      \n+    protected:\n+      ExtractKey m_extract;\n+      Equal      m_eq;\n+      H1         m_h1;\n+      H2         m_h2;\n+    };\n+} // namespace detail\n+_GLIBCXX_END_NAMESPACE\n+} // namespace std::tr1\n+\n+#endif // _TR1_HASHTABLE_POLICY_H\n+"}, {"sha": "92a71af6e69e9bf24c18c76950fdb582d32c9351", "filename": "libstdc++-v3/include/tr1/random", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Frandom", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Frandom", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Frandom?ref=b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d", "patch": "@@ -61,7 +61,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n   /*\n    * Implementation-space details.\n    */\n-  namespace _Private\n+  namespace\n   {\n     // Type selectors -- are these already implemented elsewhere?\n     template<bool, typename _TpTrue, typename _TpFalse>\n@@ -76,6 +76,16 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \ttypedef _TpFalse _Type;\n       };\n \n+    template<typename _UIntType, int __w, bool = \n+\t     __w < std::numeric_limits<_UIntType>::digits>\n+      struct _Shift\n+      { static const _UIntType __value = 0; };\n+\n+    template<typename _UIntType, int __w>\n+      struct _Shift<_UIntType, __w, true>\n+      { static const _UIntType __value = _UIntType(1) << __w; };\n+  } // anonymous namespace\n+\n     /*\n      * An adaptor class for converting the output of any Generator into\n      * the input for a specific Distribution.\n@@ -124,17 +134,6 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       \treturn __return_value;\n       }\n \n-    template<typename _UIntType, int __w, bool = \n-\t     __w < std::numeric_limits<_UIntType>::digits>\n-      struct _Shift\n-      { static const _UIntType __value = 0; };\n-\n-    template<typename _UIntType, int __w>\n-      struct _Shift<_UIntType, __w, true>\n-      { static const _UIntType __value = _UIntType(1) << __w; };\n-\n-  } // namespace std::tr1::_Private\n-\n \n   /**\n    * Produces random numbers on a given disribution function using a un uniform\n@@ -152,7 +151,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \n     public:\n       typedef _Engine                                engine_type;\n-      typedef _Private::_Adaptor<_Engine, _Dist>     engine_value_type;\n+      typedef _Adaptor<_Engine, _Dist>     engine_value_type;\n       typedef _Dist                                  distribution_type;\n       typedef typename _Dist::result_type            result_type;\n \n@@ -364,8 +363,8 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       operator()();\n \n       /**\n-       * Compares two linear congruential random number generator objects of the\n-       * same type for equality.\n+       * Compares two linear congruential random number generator\n+       * objects of the same type for equality.\n        *  \n        * @param __lhs A linear congruential random number generator object.\n        * @param __rhs Another linear congruential random number generator obj.\n@@ -378,8 +377,8 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       { return __lhs._M_x == __rhs._M_x; }\n \n       /**\n-       * Compares two linear congruential random number generator objects of the\n-       * same type for inequality.\n+       * Compares two linear congruential random number generator\n+       * objects of the same type for inequality.\n        *\n        * @param __lhs A linear congruential random number generator object.\n        * @param __rhs Another linear congruential random number generator obj.\n@@ -553,7 +552,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \n       result_type\n       max() const\n-      { return _Private::_Shift<_UIntType, __w>::__value - 1; }\n+      { return _Shift<_UIntType, __w>::__value - 1; }\n \n       result_type\n       operator()();\n@@ -1116,8 +1115,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \n     public:\n       /** The type of the generated random value. */\n-      typedef typename _Private::_Select<\n-\t(sizeof(_Result_type1) > sizeof(_Result_type2)),\n+      typedef typename _Select<(sizeof(_Result_type1) > sizeof(_Result_type2)),\n \t_Result_type1, _Result_type2>::_Type result_type;\n \n       // parameter values"}, {"sha": "5ce415b1829c6cd58ca4a0c7ac1f51788b0b836b", "filename": "libstdc++-v3/include/tr1/random.tcc", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Frandom.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Frandom.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Frandom.tcc?ref=b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d", "patch": "@@ -34,7 +34,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n   /*\n    * Implementation-space details.\n    */\n-  namespace _Private\n+  namespace\n   {\n     // General case for x = (ax + c) mod m -- use Schrage's algorithm to avoid\n     // integer overflow.\n@@ -124,7 +124,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       { typedef unsigned long long _Type; };\n #endif\n \n-  } // namespace _Private\n+  } // anonymous namespace\n \n \n   /**\n@@ -136,11 +136,11 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n     linear_congruential<_UIntType, __a, __c, __m>::\n     seed(unsigned long __x0)\n     {\n-      if ((_Private::__mod<_UIntType, 1, 0, __m>(__c) == 0)\n-\t  && (_Private::__mod<_UIntType, 1, 0, __m>(__x0) == 0))\n-\t_M_x = _Private::__mod<_UIntType, 1, 0, __m>(1);\n+      if ((__mod<_UIntType, 1, 0, __m>(__c) == 0)\n+\t  && (__mod<_UIntType, 1, 0, __m>(__x0) == 0))\n+\t_M_x = __mod<_UIntType, 1, 0, __m>(1);\n       else\n-\t_M_x = _Private::__mod<_UIntType, 1, 0, __m>(__x0);\n+\t_M_x = __mod<_UIntType, 1, 0, __m>(__x0);\n     }\n \n   /**\n@@ -153,11 +153,11 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       seed(_Gen& __g, false_type)\n       {\n \t_UIntType __x0 = __g();\n-\tif ((_Private::__mod<_UIntType, 1, 0, __m>(__c) == 0)\n-\t    && (_Private::__mod<_UIntType, 1, 0, __m>(__x0) == 0))\n-\t  _M_x = _Private::__mod<_UIntType, 1, 0, __m>(1);\n+\tif ((__mod<_UIntType, 1, 0, __m>(__c) == 0)\n+\t    && (__mod<_UIntType, 1, 0, __m>(__x0) == 0))\n+\t  _M_x = __mod<_UIntType, 1, 0, __m>(1);\n \telse\n-\t  _M_x = _Private::__mod<_UIntType, 1, 0, __m>(__x0);\n+\t  _M_x = __mod<_UIntType, 1, 0, __m>(__x0);\n       }\n \n   /**\n@@ -172,7 +172,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n     typename linear_congruential<_UIntType, __a, __c, __m>::result_type\n     linear_congruential<_UIntType, __a, __c, __m>::\n     min() const\n-    { return (_Private::__mod<_UIntType, 1, 0, __m>(__c) == 0) ? 1 : 0; }\n+    { return (__mod<_UIntType, 1, 0, __m>(__c) == 0) ? 1 : 0; }\n \n   /**\n    * Gets the maximum possible value of the generated range.\n@@ -193,7 +193,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n     linear_congruential<_UIntType, __a, __c, __m>::\n     operator()()\n     {\n-      _M_x = _Private::__mod<_UIntType, __a, __c, __m>(_M_x);\n+      _M_x = __mod<_UIntType, __a, __c, __m>(_M_x);\n       return _M_x;\n     }\n \n@@ -240,17 +240,17 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \t\t     __b, __t, __c, __l>::\n     seed(unsigned long __value)\n     {\n-      _M_x[0] = _Private::__mod<_UIntType, 1, 0,\n-\t_Private::_Shift<_UIntType, __w>::__value>(__value);\n+      _M_x[0] = __mod<_UIntType, 1, 0,\n+\t_Shift<_UIntType, __w>::__value>(__value);\n \n       for (int __i = 1; __i < state_size; ++__i)\n \t{\n \t  _UIntType __x = _M_x[__i - 1];\n \t  __x ^= __x >> (__w - 2);\n \t  __x *= 1812433253ul;\n \t  __x += __i;\n-\t  _M_x[__i] = _Private::__mod<_UIntType, 1, 0,\n-\t    _Private::_Shift<_UIntType, __w>::__value>(__x);\t  \n+\t  _M_x[__i] = __mod<_UIntType, 1, 0,\n+\t    _Shift<_UIntType, __w>::__value>(__x);\t  \n \t}\n       _M_p = state_size;\n     }\n@@ -265,8 +265,8 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       seed(_Gen& __gen, false_type)\n       {\n \tfor (int __i = 0; __i < state_size; ++__i)\n-\t  _M_x[__i] = _Private::__mod<_UIntType, 1, 0,\n-\t    _Private::_Shift<_UIntType, __w>::__value>(__gen());\n+\t  _M_x[__i] = __mod<_UIntType, 1, 0,\n+\t    _Shift<_UIntType, __w>::__value>(__gen());\n \t_M_p = state_size;\n       }\n \n@@ -376,7 +376,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \t__lcg(__value);\n \n       for (int __i = 0; __i < long_lag; ++__i)\n-\t_M_x[__i] = _Private::__mod<_IntType, 1, 0, modulus>(__lcg());\n+\t_M_x[__i] = __mod<_IntType, 1, 0, modulus>(__lcg());\n \n       _M_carry = (_M_x[long_lag - 1] == 0) ? 1 : 0;\n       _M_p = 0;\n@@ -390,10 +390,10 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       {\n \tconst int __n = (std::numeric_limits<_IntType>::digits + 31) / 32;\n \n-\ttypedef typename _Private::_Select<(sizeof(unsigned) == 4),\n+\ttypedef typename _Select<(sizeof(unsigned) == 4),\n \t  unsigned, unsigned long>::_Type _UInt32Type;\n \n-\ttypedef typename _Private::_To_Unsigned_Type<_IntType>::_Type\n+\ttypedef typename _To_Unsigned_Type<_IntType>::_Type\n \t  _UIntType;\n \n \tfor (int __i = 0; __i < long_lag; ++__i)\n@@ -402,11 +402,11 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \t    _UIntType __factor = 1;\n \t    for (int __j = 0; __j < __n; ++__j)\n \t      {\n-\t\t__tmp += (_Private::__mod<_UInt32Type, 1, 0, 0>(__gen())\n+\t\t__tmp += (__mod<_UInt32Type, 1, 0, 0>(__gen())\n \t\t\t  * __factor);\n-\t\t__factor *= _Private::_Shift<_UIntType, 32>::__value;\n+\t\t__factor *= _Shift<_UIntType, 32>::__value;\n \t      }\n-\t    _M_x[__i] = _Private::__mod<_UIntType, 1, 0, modulus>(__tmp);\n+\t    _M_x[__i] = __mod<_UIntType, 1, 0, modulus>(__tmp);\n \t  }\n \t_M_carry = (_M_x[long_lag - 1] == 0) ? 1 : 0;\n \t_M_p = 0;\n@@ -622,7 +622,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       const std::streamsize __precision = __os.precision();\n       __os.flags(std::ios_base::scientific | std::ios_base::left);\n       __os.fill(__os.widen(' '));\n-      __os.precision(_Private::_Max_digits10<double>::__value);\n+      __os.precision(_Max_digits10<double>::__value);\n \n       __os << __x.p();\n \n@@ -644,7 +644,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       const std::streamsize __precision = __os.precision();\n       __os.flags(std::ios_base::scientific | std::ios_base::left);\n       __os.fill(__os.widen(' '));\n-      __os.precision(_Private::_Max_digits10<_RealType>::__value);\n+      __os.precision(_Max_digits10<_RealType>::__value);\n \n       __os << __x.p();\n \n@@ -666,7 +666,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       const _CharT __space = __os.widen(' ');\n       __os.flags(std::ios_base::scientific | std::ios_base::left);\n       __os.fill(__space);\n-      __os.precision(_Private::_Max_digits10<_RealType>::__value);\n+      __os.precision(_Max_digits10<_RealType>::__value);\n \n       __os << __x.min() << __space << __x.max();\n \n@@ -701,7 +701,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       const std::streamsize __precision = __os.precision();\n       __os.flags(std::ios_base::scientific | std::ios_base::left);\n       __os.fill(__os.widen(' '));\n-      __os.precision(_Private::_Max_digits10<_RealType>::__value);\n+      __os.precision(_Max_digits10<_RealType>::__value);\n \n       __os << __x.lambda();\n \n@@ -764,7 +764,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       const _CharT __space = __os.widen(' ');\n       __os.flags(std::ios_base::scientific | std::ios_base::left);\n       __os.fill(__space);\n-      __os.precision(_Private::_Max_digits10<_RealType>::__value);\n+      __os.precision(_Max_digits10<_RealType>::__value);\n \n       __os << __x.mean() << __space\n \t   << __x.sigma() << __space\n@@ -872,7 +872,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       const std::streamsize __precision = __os.precision();\n       __os.flags(std::ios_base::scientific | std::ios_base::left);\n       __os.fill(__os.widen(' '));\n-      __os.precision(_Private::_Max_digits10<_RealType>::__value);\n+      __os.precision(_Max_digits10<_RealType>::__value);\n \n       __os << __x.alpha();\n "}, {"sha": "675494157f581360f5cd8e824dd8cae37d859137", "filename": "libstdc++-v3/include/tr1/unordered_map", "status": "modified", "additions": 33, "deletions": 36, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_map?ref=b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d", "patch": "@@ -43,29 +43,26 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \n   // XXX When we get typedef templates these class definitions\n   // will be unnecessary.\n-\n   template<class Key, class T,\n \t   class Hash = hash<Key>,\n \t   class Pred = std::equal_to<Key>,\n \t   class Alloc = std::allocator<std::pair<const Key, T> >,\n \t   bool cache_hash_code = false>\n     class unordered_map\n-    : public hashtable <Key, std::pair<const Key, T>,\n-\t\t\tAlloc,\n-\t\t\tInternal::extract1st<std::pair<const Key, T> >, Pred,\n-\t\t\tHash, Internal::mod_range_hashing,\n-\t\t\tInternal::default_ranged_hash,\n-\t\t\tInternal::prime_rehash_policy,\n-\t\t\tcache_hash_code, false, true>\n+    : public hashtable<Key, std::pair<const Key, T>, Alloc,\n+\t\t       detail::extract1st<std::pair<const Key, T> >, Pred, \n+\t\t       Hash, detail::mod_range_hashing,\n+\t\t       detail::default_ranged_hash,\n+\t\t       detail::prime_rehash_policy,\n+\t\t       cache_hash_code, false, true>\n     {\n-      typedef hashtable <Key, std::pair<const Key, T>,\n-\t\t\t Alloc,\n-\t\t\t Internal::extract1st<std::pair<const Key, T> >, Pred,\n-\t\t\t Hash, Internal::mod_range_hashing,\n-\t\t\t Internal::default_ranged_hash,\n-\t\t\t Internal::prime_rehash_policy,\n-\t\t\t cache_hash_code, false, true>\n-        Base;\n+      typedef hashtable<Key, std::pair<const Key, T>, Alloc,\n+\t\t\tdetail::extract1st<std::pair<const Key, T> >, Pred,\n+\t\t\tHash, detail::mod_range_hashing,\n+\t\t\tdetail::default_ranged_hash,\n+\t\t\tdetail::prime_rehash_policy,\n+\t\t\tcache_hash_code, false, true>\n+      Base;\n \n     public:\n       typedef typename Base::size_type size_type;\n@@ -78,9 +75,9 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \t\t    const hasher& hf = hasher(),\n \t\t    const key_equal& eql = key_equal(),\n \t\t    const allocator_type& a = allocator_type())\n-      : Base(n, hf, Internal::mod_range_hashing(),\n-\t     Internal::default_ranged_hash(),\n-\t     eql, Internal::extract1st<std::pair<const Key, T> >(), a)\n+      : Base(n, hf, detail::mod_range_hashing(),\n+\t     detail::default_ranged_hash(),\n+\t     eql, detail::extract1st<std::pair<const Key, T> >(), a)\n       { }\n \n       template<typename InputIterator>\n@@ -89,9 +86,9 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \t\t      const hasher& hf = hasher(), \n \t\t      const key_equal& eql = key_equal(), \n \t\t      const allocator_type& a = allocator_type())\n-\t: Base (f, l, n, hf, Internal::mod_range_hashing(),\n-\t\tInternal::default_ranged_hash(),\n-\t\teql, Internal::extract1st<std::pair<const Key, T> >(), a)\n+\t: Base (f, l, n, hf, detail::mod_range_hashing(),\n+\t\tdetail::default_ranged_hash(),\n+\t\teql, detail::extract1st<std::pair<const Key, T> >(), a)\n \t{ }\n     };\n   \n@@ -103,18 +100,18 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n     class unordered_multimap\n     : public hashtable <Key, std::pair<const Key, T>,\n \t\t\tAlloc,\n-\t\t\tInternal::extract1st<std::pair<const Key, T> >, Pred,\n-\t\t\tHash, Internal::mod_range_hashing,\n-\t\t\tInternal::default_ranged_hash,\n-\t\t\tInternal::prime_rehash_policy,\n+\t\t\tdetail::extract1st<std::pair<const Key, T> >, Pred,\n+\t\t\tHash, detail::mod_range_hashing,\n+\t\t\tdetail::default_ranged_hash,\n+\t\t\tdetail::prime_rehash_policy,\n \t\t\tcache_hash_code, false, false>\n     {\n       typedef hashtable <Key, std::pair<const Key, T>,\n \t\t\t Alloc,\n-\t\t\t Internal::extract1st<std::pair<const Key, T> >, Pred,\n-\t\t\t Hash, Internal::mod_range_hashing,\n-\t\t\t Internal::default_ranged_hash,\n-\t\t\t Internal::prime_rehash_policy,\n+\t\t\t detail::extract1st<std::pair<const Key, T> >, Pred,\n+\t\t\t Hash, detail::mod_range_hashing,\n+\t\t\t detail::default_ranged_hash,\n+\t\t\t detail::prime_rehash_policy,\n \t\t\t cache_hash_code, false, false>\n         Base;\n \n@@ -129,9 +126,9 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \t\t\t const hasher& hf = hasher(),\n \t\t\t const key_equal& eql = key_equal(),\n \t\t\t const allocator_type& a = allocator_type())\n-      : Base (n, hf, Internal::mod_range_hashing(),\n-\t      Internal::default_ranged_hash(),\n-\t      eql, Internal::extract1st<std::pair<const Key, T> >(), a)\n+      : Base (n, hf, detail::mod_range_hashing(),\n+\t      detail::default_ranged_hash(),\n+\t      eql, detail::extract1st<std::pair<const Key, T> >(), a)\n       { }\n \n \n@@ -141,9 +138,9 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \t\t\t   const hasher& hf = hasher(), \n \t\t\t   const key_equal& eql = key_equal(), \n \t\t\t   const allocator_type& a = allocator_type())\n-\t: Base (f, l, n, hf, Internal::mod_range_hashing(),\n-\t\tInternal::default_ranged_hash(),\n-\t\teql, Internal::extract1st<std::pair<const Key, T> >(), a)\n+\t: Base (f, l, n, hf, detail::mod_range_hashing(),\n+\t\tdetail::default_ranged_hash(),\n+\t\teql, detail::extract1st<std::pair<const Key, T> >(), a)\n         { }\n     };\n "}, {"sha": "f3c722761764784beaa2ffa0b7967b3b20185fec", "filename": "libstdc++-v3/include/tr1/unordered_set", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_set?ref=b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d", "patch": "@@ -43,25 +43,24 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \n   // XXX When we get typedef templates these class definitions\n   // will be unnecessary.\n-\n   template<class Value,\n \t   class Hash = hash<Value>,\n \t   class Pred = std::equal_to<Value>,\n \t   class Alloc = std::allocator<Value>,\n \t   bool cache_hash_code = false>\n     class unordered_set\n     : public hashtable<Value, Value, Alloc,\n-\t\t       Internal::identity<Value>, Pred,\n-\t\t       Hash, Internal::mod_range_hashing,\n-\t\t       Internal::default_ranged_hash,\n-\t\t       Internal::prime_rehash_policy,\n+\t\t       detail::identity<Value>, Pred,\n+\t\t       Hash, detail::mod_range_hashing,\n+\t\t       detail::default_ranged_hash,\n+\t\t       detail::prime_rehash_policy,\n \t\t       cache_hash_code, true, true>\n     {\n       typedef hashtable<Value, Value, Alloc,\n-\t\t\tInternal::identity<Value>, Pred,\n-\t\t\tHash, Internal::mod_range_hashing,\n-\t\t\tInternal::default_ranged_hash,\n-\t\t\tInternal::prime_rehash_policy,\n+\t\t\tdetail::identity<Value>, Pred,\n+\t\t\tHash, detail::mod_range_hashing,\n+\t\t\tdetail::default_ranged_hash,\n+\t\t\tdetail::prime_rehash_policy,\n \t\t\tcache_hash_code, true, true>\n         Base;\n \n@@ -76,9 +75,9 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \t\t    const hasher& hf = hasher(),\n \t\t    const key_equal& eql = key_equal(),\n \t\t    const allocator_type& a = allocator_type())\n-      : Base (n, hf, Internal::mod_range_hashing(),\n-\t      Internal::default_ranged_hash(),\n-\t      eql, Internal::identity<Value>(), a)\n+      : Base(n, hf, detail::mod_range_hashing(),\n+\t     detail::default_ranged_hash(),\n+\t     eql, detail::identity<Value>(), a)\n       { }\n \n       template<typename InputIterator>\n@@ -87,9 +86,9 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \t\t      const hasher& hf = hasher(), \n \t\t      const key_equal& eql = key_equal(), \n \t\t      const allocator_type& a = allocator_type())\n-\t: Base (f, l, n, hf, Internal::mod_range_hashing(),\n-\t\tInternal::default_ranged_hash(),\n-\t\teql, Internal::identity<Value>(), a)\n+\t: Base(f, l, n, hf, detail::mod_range_hashing(),\n+\t       detail::default_ranged_hash(),\n+\t       eql, detail::identity<Value>(), a)\n         { }\n     };\n \n@@ -100,17 +99,17 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \t   bool cache_hash_code = false>\n     class unordered_multiset\n     : public hashtable <Value, Value, Alloc,\n-\t\t\tInternal::identity<Value>, Pred,\n-\t\t\tHash, Internal::mod_range_hashing,\n-\t\t\tInternal::default_ranged_hash,\n-\t\t\tInternal::prime_rehash_policy,\n+\t\t\tdetail::identity<Value>, Pred,\n+\t\t\tHash, detail::mod_range_hashing,\n+\t\t\tdetail::default_ranged_hash,\n+\t\t\tdetail::prime_rehash_policy,\n \t\t\tcache_hash_code, true, false>\n     {\n       typedef hashtable<Value, Value, Alloc,\n-\t\t\tInternal::identity<Value>, Pred,\n-\t\t\tHash, Internal::mod_range_hashing,\n-\t\t\tInternal::default_ranged_hash,\n-\t\t\tInternal::prime_rehash_policy,\n+\t\t\tdetail::identity<Value>, Pred,\n+\t\t\tHash, detail::mod_range_hashing,\n+\t\t\tdetail::default_ranged_hash,\n+\t\t\tdetail::prime_rehash_policy,\n \t\t\tcache_hash_code, true, false>\n         Base;\n \n@@ -125,9 +124,9 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \t\t\t const hasher& hf = hasher(),\n \t\t\t const key_equal& eql = key_equal(),\n \t\t\t const allocator_type& a = allocator_type())\n-      : Base (n, hf, Internal::mod_range_hashing(),\n-\t      Internal::default_ranged_hash(),\n-\t      eql, Internal::identity<Value>(), a)\n+      : Base(n, hf, detail::mod_range_hashing(),\n+\t     detail::default_ranged_hash(),\n+\t     eql, detail::identity<Value>(), a)\n       { }\n \n \n@@ -137,9 +136,9 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \t\t\t   const hasher& hf = hasher(), \n \t\t\t   const key_equal& eql = key_equal(), \n \t\t\t   const allocator_type& a = allocator_type())\n-\t: Base (f, l, n, hf, Internal::mod_range_hashing(),\n-\t\tInternal::default_ranged_hash(), eql,\n-\t\tInternal::identity<Value>(), a)\n+\t: Base(f, l, n, hf, detail::mod_range_hashing(),\n+\t       detail::default_ranged_hash(), eql,\n+\t       detail::identity<Value>(), a)\n         { }\n     };\n "}, {"sha": "47f8ceea2c5564a9230f3608fd7487f463e4748e", "filename": "libstdc++-v3/src/Makefile.am", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am?ref=b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d", "patch": "@@ -138,7 +138,6 @@ sources = \\\n \tdebug.cc \\\n \tdebug_list.cc \\\n \tfunctexcept.cc \\\n-\tglobals_locale.cc \\\n \tglobals_io.cc \\\n \tios.cc \\\n \tios_failure.cc \\"}, {"sha": "34b86e33285871bed5f4213d0655607f504e196e", "filename": "libstdc++-v3/src/Makefile.in", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in?ref=b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d", "patch": "@@ -62,36 +62,36 @@ toolexeclibLTLIBRARIES_INSTALL = $(INSTALL)\n LTLIBRARIES = $(toolexeclib_LTLIBRARIES)\n am__libstdc___la_SOURCES_DIST = bitmap_allocator.cc pool_allocator.cc \\\n \tmt_allocator.cc codecvt.cc compatibility.cc complex_io.cc \\\n-\tctype.cc debug.cc debug_list.cc functexcept.cc \\\n-\tglobals_locale.cc globals_io.cc ios.cc ios_failure.cc \\\n-\tios_init.cc ios_locale.cc limits.cc list.cc locale.cc \\\n-\tlocale_init.cc locale_facets.cc localename.cc stdexcept.cc \\\n-\tstrstream.cc tree.cc allocator-inst.cc concept-inst.cc \\\n-\tfstream-inst.cc ext-inst.cc ios-inst.cc iostream-inst.cc \\\n-\tistream-inst.cc istream.cc locale-inst.cc misc-inst.cc \\\n-\tostream-inst.cc sstream-inst.cc streambuf-inst.cc streambuf.cc \\\n-\tstring-inst.cc valarray-inst.cc wlocale-inst.cc \\\n-\twstring-inst.cc atomicity.cc codecvt_members.cc \\\n-\tcollate_members.cc ctype_members.cc messages_members.cc \\\n-\tmonetary_members.cc numeric_members.cc time_members.cc \\\n-\tbasic_file.cc c++locale.cc compatibility-ldbl.cc\n+\tctype.cc debug.cc debug_list.cc functexcept.cc globals_io.cc \\\n+\tios.cc ios_failure.cc ios_init.cc ios_locale.cc limits.cc \\\n+\tlist.cc locale.cc locale_init.cc locale_facets.cc \\\n+\tlocalename.cc stdexcept.cc strstream.cc tree.cc \\\n+\tallocator-inst.cc concept-inst.cc fstream-inst.cc ext-inst.cc \\\n+\tios-inst.cc iostream-inst.cc istream-inst.cc istream.cc \\\n+\tlocale-inst.cc misc-inst.cc ostream-inst.cc sstream-inst.cc \\\n+\tstreambuf-inst.cc streambuf.cc string-inst.cc valarray-inst.cc \\\n+\twlocale-inst.cc wstring-inst.cc atomicity.cc \\\n+\tcodecvt_members.cc collate_members.cc ctype_members.cc \\\n+\tmessages_members.cc monetary_members.cc numeric_members.cc \\\n+\ttime_members.cc basic_file.cc c++locale.cc \\\n+\tcompatibility-ldbl.cc\n am__objects_1 = atomicity.lo codecvt_members.lo collate_members.lo \\\n \tctype_members.lo messages_members.lo monetary_members.lo \\\n \tnumeric_members.lo time_members.lo\n am__objects_2 = basic_file.lo c++locale.lo\n @GLIBCXX_LDBL_COMPAT_TRUE@am__objects_3 = compatibility-ldbl.lo\n am__objects_4 = bitmap_allocator.lo pool_allocator.lo mt_allocator.lo \\\n \tcodecvt.lo compatibility.lo complex_io.lo ctype.lo debug.lo \\\n-\tdebug_list.lo functexcept.lo globals_locale.lo globals_io.lo \\\n-\tios.lo ios_failure.lo ios_init.lo ios_locale.lo limits.lo \\\n-\tlist.lo locale.lo locale_init.lo locale_facets.lo \\\n-\tlocalename.lo stdexcept.lo strstream.lo tree.lo \\\n-\tallocator-inst.lo concept-inst.lo fstream-inst.lo ext-inst.lo \\\n-\tios-inst.lo iostream-inst.lo istream-inst.lo istream.lo \\\n-\tlocale-inst.lo misc-inst.lo ostream-inst.lo sstream-inst.lo \\\n-\tstreambuf-inst.lo streambuf.lo string-inst.lo valarray-inst.lo \\\n-\twlocale-inst.lo wstring-inst.lo $(am__objects_1) \\\n-\t$(am__objects_2) $(am__objects_3)\n+\tdebug_list.lo functexcept.lo globals_io.lo ios.lo \\\n+\tios_failure.lo ios_init.lo ios_locale.lo limits.lo list.lo \\\n+\tlocale.lo locale_init.lo locale_facets.lo localename.lo \\\n+\tstdexcept.lo strstream.lo tree.lo allocator-inst.lo \\\n+\tconcept-inst.lo fstream-inst.lo ext-inst.lo ios-inst.lo \\\n+\tiostream-inst.lo istream-inst.lo istream.lo locale-inst.lo \\\n+\tmisc-inst.lo ostream-inst.lo sstream-inst.lo streambuf-inst.lo \\\n+\tstreambuf.lo string-inst.lo valarray-inst.lo wlocale-inst.lo \\\n+\twstring-inst.lo $(am__objects_1) $(am__objects_2) \\\n+\t$(am__objects_3)\n am_libstdc___la_OBJECTS = $(am__objects_4)\n libstdc___la_OBJECTS = $(am_libstdc___la_OBJECTS)\n DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)\n@@ -344,7 +344,6 @@ sources = \\\n \tdebug.cc \\\n \tdebug_list.cc \\\n \tfunctexcept.cc \\\n-\tglobals_locale.cc \\\n \tglobals_io.cc \\\n \tios.cc \\\n \tios_failure.cc \\"}, {"sha": "94845563d05f304fe97af54db7aca6e189502500", "filename": "libstdc++-v3/src/debug.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d/libstdc%2B%2B-v3%2Fsrc%2Fdebug.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d/libstdc%2B%2B-v3%2Fsrc%2Fdebug.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fdebug.cc?ref=b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d", "patch": "@@ -39,10 +39,10 @@\n \n using namespace std;\n \n-namespace __gnu_internal _GLIBCXX_VISIBILITY(hidden)\n+namespace\n {\n   static __glibcxx_mutex_define_initialized(iterator_base_mutex);\n-} // namespace __gnu_internal\n+} \n \n namespace __gnu_debug\n {\n@@ -192,7 +192,7 @@ namespace __gnu_debug\n     // Attach to the new sequence (if there is one)\n     if (__seq)\n       {\n-\t__gnu_cxx::lock sentry(__gnu_internal::iterator_base_mutex);\n+\t__gnu_cxx::lock sentry(iterator_base_mutex);\n \t_M_sequence = __seq;\n \t_M_version = _M_sequence->_M_version;\n \t_M_prior = 0;\n@@ -217,7 +217,7 @@ namespace __gnu_debug\n   _Safe_iterator_base::\n   _M_detach()\n   {\n-    __gnu_cxx::lock sentry(__gnu_internal::iterator_base_mutex);\n+    __gnu_cxx::lock sentry(iterator_base_mutex);\n     if (_M_sequence)\n       {\n \t// Remove us from this sequence's list"}, {"sha": "1e356d6dcb88852035408f973f88bfa511f409e0", "filename": "libstdc++-v3/src/ext-inst.cc", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d/libstdc%2B%2B-v3%2Fsrc%2Fext-inst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d/libstdc%2B%2B-v3%2Fsrc%2Fext-inst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fext-inst.cc?ref=b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d", "patch": "@@ -34,15 +34,13 @@\n #include <ext/rope>\n #include <ext/stdio_filebuf.h>\n \n-namespace __gnu_internal _GLIBCXX_VISIBILITY(hidden)\n+namespace\n {\n-  const int min_len = __gnu_cxx::_Rope_constants::_S_max_rope_depth + 1;\n+  const int min_len = _S_max_rope_depth + 1;\n }\n \n _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \n-  using namespace __gnu_internal;\n-\n   template\n     const unsigned long \n     rope<char, std::allocator<char> >::_S_min_len[min_len];"}, {"sha": "56420ef40fc4bb05581867ef285408396d3f627b", "filename": "libstdc++-v3/src/globals_locale.cc", "status": "removed", "additions": 0, "deletions": 210, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85661c41dd4fe35a4fd54c3679b94fa0ea2e902a/libstdc%2B%2B-v3%2Fsrc%2Fglobals_locale.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85661c41dd4fe35a4fd54c3679b94fa0ea2e902a/libstdc%2B%2B-v3%2Fsrc%2Fglobals_locale.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fglobals_locale.cc?ref=85661c41dd4fe35a4fd54c3679b94fa0ea2e902a", "patch": "@@ -1,210 +0,0 @@\n-// Copyright (C) 2001, 2002, 2003, 2004, 2006 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-#include <locale>\n-\n-// On AIX, and perhaps other systems, library initialization order is\n-// not guaranteed.  For example, the static initializers for the main\n-// program might run before the static initializers for this library.\n-// That means that we cannot rely on static initialization in the\n-// library; there is no guarantee that things will get initialized in\n-// time.  This file contains definitions of all global variables that\n-// require initialization as arrays of characters.\n-\n-// NB: asm directives can rename these non-exported, namespace\n-// __gnu_cxx symbols into exported, namespace std symbols with the\n-// appropriate symbol version name.\n-// The rename syntax is \n-//   asm (\".symver currentname,oldname@@GLIBCXX_3.2\")\n-// In macro form:\n-// _GLIBCXX_ASM_SYMVER(currentname, oldname, GLIBCXX_3.2)\n-\n-namespace __gnu_internal _GLIBCXX_VISIBILITY(hidden)\n-{\n-  using namespace std;\n-\n-  typedef char fake_locale_Impl[sizeof(locale::_Impl)]\n-  __attribute__ ((aligned(__alignof__(locale::_Impl))));\n-  fake_locale_Impl c_locale_impl;\n-\n-  typedef char fake_locale[sizeof(locale)]\n-  __attribute__ ((aligned(__alignof__(locale))));\n-  fake_locale c_locale;\n-\n-  typedef char fake_name_vec[sizeof(char*)]\n-  __attribute__ ((aligned(__alignof__(char*))));\n-  fake_name_vec name_vec[6 + _GLIBCXX_NUM_CATEGORIES];\n-\n-  typedef char fake_names[sizeof(char[2])]\n-  __attribute__ ((aligned(__alignof__(char[2]))));\n-  fake_names name_c[6 + _GLIBCXX_NUM_CATEGORIES];\n-\n-  typedef char fake_facet_vec[sizeof(locale::facet*)]\n-  __attribute__ ((aligned(__alignof__(locale::facet*))));\n-  fake_facet_vec facet_vec[_GLIBCXX_NUM_FACETS];\n-\n-  typedef char fake_cache_vec[sizeof(locale::facet*)]\n-  __attribute__ ((aligned(__alignof__(locale::facet*))));\n-  fake_cache_vec cache_vec[_GLIBCXX_NUM_FACETS];\n-\n-  typedef char fake_ctype_c[sizeof(std::ctype<char>)]\n-  __attribute__ ((aligned(__alignof__(std::ctype<char>))));\n-  fake_ctype_c ctype_c;\n-\n-  typedef char fake_collate_c[sizeof(std::collate<char>)]\n-  __attribute__ ((aligned(__alignof__(std::collate<char>))));\n-  fake_collate_c collate_c;\n-\n-  typedef char fake_numpunct_c[sizeof(numpunct<char>)]\n-  __attribute__ ((aligned(__alignof__(numpunct<char>))));\n-  fake_numpunct_c numpunct_c;\n-\n-  typedef char fake_num_get_c[sizeof(num_get<char>)]\n-  __attribute__ ((aligned(__alignof__(num_get<char>))));\n-  fake_num_get_c num_get_c;\n-\n-  typedef char fake_num_put_c[sizeof(num_put<char>)]\n-  __attribute__ ((aligned(__alignof__(num_put<char>))));\n-  fake_num_put_c num_put_c;\n-\n-  typedef char fake_codecvt_c[sizeof(codecvt<char, char, mbstate_t>)]\n-  __attribute__ ((aligned(__alignof__(codecvt<char, char, mbstate_t>))));\n-  fake_codecvt_c codecvt_c;\n-\n-  typedef char fake_moneypunct_c[sizeof(moneypunct<char, true>)]\n-  __attribute__ ((aligned(__alignof__(moneypunct<char, true>))));\n-  fake_moneypunct_c moneypunct_ct;\n-  fake_moneypunct_c moneypunct_cf;\n-\n-  typedef char fake_money_get_c[sizeof(money_get<char>)]\n-  __attribute__ ((aligned(__alignof__(money_get<char>))));\n-  fake_money_get_c money_get_c;\n-  \n-  typedef char fake_money_put_c[sizeof(money_put<char>)]\n-  __attribute__ ((aligned(__alignof__(money_put<char>))));\n-  fake_money_put_c money_put_c;\n-\n-  typedef char fake_timepunct_c[sizeof(__timepunct<char>)]\n-  __attribute__ ((aligned(__alignof__(__timepunct<char>))));\n-  fake_timepunct_c timepunct_c;\n-\n-  typedef char fake_time_get_c[sizeof(time_get<char>)]\n-  __attribute__ ((aligned(__alignof__(time_get<char>))));\n-  fake_time_get_c time_get_c;\n-\n-  typedef char fake_time_put_c[sizeof(time_put<char>)]\n-  __attribute__ ((aligned(__alignof__(time_put<char>))));\n-  fake_time_put_c time_put_c;\n-\n-  typedef char fake_messages_c[sizeof(messages<char>)]\n-  __attribute__ ((aligned(__alignof__(messages<char>))));\n-  fake_messages_c messages_c;\n-\n-#ifdef  _GLIBCXX_USE_WCHAR_T\n-  typedef char fake_wtype_w[sizeof(std::ctype<wchar_t>)]\n-  __attribute__ ((aligned(__alignof__(std::ctype<wchar_t>))));\n-  fake_wtype_w ctype_w;\n-\n-  typedef char fake_wollate_w[sizeof(std::collate<wchar_t>)]\n-  __attribute__ ((aligned(__alignof__(std::collate<wchar_t>))));\n-  fake_wollate_w collate_w;\n-\n-  typedef char fake_numpunct_w[sizeof(numpunct<wchar_t>)]\n-  __attribute__ ((aligned(__alignof__(numpunct<wchar_t>))));\n-  fake_numpunct_w numpunct_w;\n-\n-  typedef char fake_num_get_w[sizeof(num_get<wchar_t>)]\n-  __attribute__ ((aligned(__alignof__(num_get<wchar_t>))));\n-  fake_num_get_w num_get_w;\n-\n-  typedef char fake_num_put_w[sizeof(num_put<wchar_t>)]\n-  __attribute__ ((aligned(__alignof__(num_put<wchar_t>))));\n-  fake_num_put_w num_put_w;\n-\n-  typedef char fake_wodecvt_w[sizeof(codecvt<wchar_t, char, mbstate_t>)]\n-  __attribute__ ((aligned(__alignof__(codecvt<wchar_t, char, mbstate_t>))));\n-  fake_wodecvt_w codecvt_w;\n-\n-  typedef char fake_moneypunct_w[sizeof(moneypunct<wchar_t, true>)]\n-  __attribute__ ((aligned(__alignof__(moneypunct<wchar_t, true>))));\n-  fake_moneypunct_w moneypunct_wt;\n-  fake_moneypunct_w moneypunct_wf;\n-\n-  typedef char fake_money_get_w[sizeof(money_get<wchar_t>)]\n-  __attribute__ ((aligned(__alignof__(money_get<wchar_t>))));\n-  fake_money_get_w money_get_w;\n-  \n-  typedef char fake_money_put_w[sizeof(money_put<wchar_t>)]\n-  __attribute__ ((aligned(__alignof__(money_put<wchar_t>))));\n-  fake_money_put_w money_put_w;\n-\n-  typedef char fake_timepunct_w[sizeof(__timepunct<wchar_t>)]\n-  __attribute__ ((aligned(__alignof__(__timepunct<wchar_t>))));\n-  fake_timepunct_w timepunct_w;\n-\n-  typedef char fake_time_get_w[sizeof(time_get<wchar_t>)]\n-  __attribute__ ((aligned(__alignof__(time_get<wchar_t>))));\n-  fake_time_get_w time_get_w;\n-\n-  typedef char fake_time_put_w[sizeof(time_put<wchar_t>)]\n-  __attribute__ ((aligned(__alignof__(time_put<wchar_t>))));\n-  fake_time_put_w time_put_w;\n-\n-  typedef char fake_messages_w[sizeof(messages<wchar_t>)]\n-  __attribute__ ((aligned(__alignof__(messages<wchar_t>))));\n-  fake_messages_w messages_w;\n-#endif\n-\n-  // Storage for \"C\" locale caches.\n-  typedef char fake_num_cache_c[sizeof(std::__numpunct_cache<char>)]\n-  __attribute__ ((aligned(__alignof__(std::__numpunct_cache<char>))));\n-  fake_num_cache_c numpunct_cache_c;\n-\n-  typedef char fake_money_cache_c[sizeof(std::__moneypunct_cache<char, true>)]\n-  __attribute__ ((aligned(__alignof__(std::__moneypunct_cache<char, true>))));\n-  fake_money_cache_c moneypunct_cache_ct;\n-  fake_money_cache_c moneypunct_cache_cf;\n-\n-  typedef char fake_time_cache_c[sizeof(std::__timepunct_cache<char>)]\n-  __attribute__ ((aligned(__alignof__(std::__timepunct_cache<char>))));\n-  fake_time_cache_c timepunct_cache_c;\n-\n-#ifdef _GLIBCXX_USE_WCHAR_T\n-  typedef char fake_num_cache_w[sizeof(std::__numpunct_cache<wchar_t>)]\n-  __attribute__ ((aligned(__alignof__(std::__numpunct_cache<wchar_t>))));\n-  fake_num_cache_w numpunct_cache_w;\n-\n-  typedef char fake_money_cache_w[sizeof(std::__moneypunct_cache<wchar_t,true>)]\n-  __attribute__ ((aligned(__alignof__(std::__moneypunct_cache<wchar_t,true>))));\n-  fake_money_cache_w moneypunct_cache_wt;\n-  fake_money_cache_w moneypunct_cache_wf;\n-\n-  typedef char fake_time_cache_w[sizeof(std::__timepunct_cache<wchar_t>)]\n-  __attribute__ ((aligned(__alignof__(std::__timepunct_cache<wchar_t>))));\n-  fake_time_cache_w timepunct_cache_w;\n-#endif\n-} // namespace __gnu_internal"}, {"sha": "7bcf51d8e30a3ac201e1d01044b2675e4b445309", "filename": "libstdc++-v3/src/locale.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d/libstdc%2B%2B-v3%2Fsrc%2Flocale.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d/libstdc%2B%2B-v3%2Fsrc%2Flocale.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flocale.cc?ref=b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d", "patch": "@@ -35,9 +35,9 @@\n #include <bits/atomicity.h>\n #include <bits/concurrence.h>\n \n-namespace __gnu_internal _GLIBCXX_VISIBILITY(hidden)\n+namespace\n {\n-  // Mutex object for cache access\n+  // Mutex object for cache access.\n   static __glibcxx_mutex_define_initialized(locale_cache_mutex);\n }\n \n@@ -391,7 +391,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n   locale::_Impl::\n   _M_install_cache(const facet* __cache, size_t __index)\n   {\n-    __gnu_cxx::lock sentry(__gnu_internal::locale_cache_mutex);\n+    __gnu_cxx::lock sentry(locale_cache_mutex);\n     if (_M_caches[__index] != 0)\n       {\n \t// Some other thread got in first."}, {"sha": "3a4b6d15aafe8f9b470955076bc2b31db56ace37", "filename": "libstdc++-v3/src/locale_init.cc", "status": "modified", "additions": 163, "deletions": 54, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d/libstdc%2B%2B-v3%2Fsrc%2Flocale_init.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d/libstdc%2B%2B-v3%2Fsrc%2Flocale_init.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flocale_init.cc?ref=b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d", "patch": "@@ -35,72 +35,181 @@\n #include <bits/atomicity.h>\n #include <bits/concurrence.h>\n \n-namespace __gnu_internal _GLIBCXX_VISIBILITY(hidden)\n+namespace \n {\n-  // Defined in globals.cc.\n-  extern std::locale \t\tc_locale;\n-  extern std::locale::_Impl \tc_locale_impl;\n-\n-  extern std::locale::facet* facet_vec[_GLIBCXX_NUM_FACETS];\n-  extern char* name_vec[6 + _GLIBCXX_NUM_CATEGORIES];\n-  extern char name_c[6 + _GLIBCXX_NUM_CATEGORIES][2];\n-\n-  extern std::ctype<char>\t\t\t ctype_c;\n-  extern std::collate<char> \t\t\t collate_c;\n-  extern std::numpunct<char> \t\t\t numpunct_c;\n-  extern std::num_get<char> \t\t\t num_get_c;\n-  extern std::num_put<char> \t\t\t num_put_c;  \n-  extern std::codecvt<char, char, mbstate_t>\t codecvt_c;\n-  extern std::moneypunct<char, false> \t\t moneypunct_cf;\n-  extern std::moneypunct<char, true> \t\t moneypunct_ct;\n-  extern std::money_get<char> \t\t\t money_get_c;\n-  extern std::money_put<char> \t\t\t money_put_c;\n-  extern std::__timepunct<char> \t\t timepunct_c;\n-  extern std::time_get<char> \t\t\t time_get_c;\n-  extern std::time_put<char> \t\t\t time_put_c;\n-  extern std::messages<char> \t\t\t messages_c;\n+  using namespace std;\n+\n+  typedef char fake_locale_Impl[sizeof(locale::_Impl)]\n+  __attribute__ ((aligned(__alignof__(locale::_Impl))));\n+  fake_locale_Impl c_locale_impl;\n+\n+  typedef char fake_locale[sizeof(locale)]\n+  __attribute__ ((aligned(__alignof__(locale))));\n+  fake_locale c_locale;\n+\n+  typedef char fake_name_vec[sizeof(char*)]\n+  __attribute__ ((aligned(__alignof__(char*))));\n+  fake_name_vec name_vec[6 + _GLIBCXX_NUM_CATEGORIES];\n+\n+  typedef char fake_names[sizeof(char[2])]\n+  __attribute__ ((aligned(__alignof__(char[2]))));\n+  fake_names name_c[6 + _GLIBCXX_NUM_CATEGORIES];\n+\n+  typedef char fake_facet_vec[sizeof(locale::facet*)]\n+  __attribute__ ((aligned(__alignof__(locale::facet*))));\n+  fake_facet_vec facet_vec[_GLIBCXX_NUM_FACETS];\n+\n+  typedef char fake_cache_vec[sizeof(locale::facet*)]\n+  __attribute__ ((aligned(__alignof__(locale::facet*))));\n+  fake_cache_vec cache_vec[_GLIBCXX_NUM_FACETS];\n+\n+  typedef char fake_ctype_c[sizeof(std::ctype<char>)]\n+  __attribute__ ((aligned(__alignof__(std::ctype<char>))));\n+  fake_ctype_c ctype_c;\n+\n+  typedef char fake_collate_c[sizeof(std::collate<char>)]\n+  __attribute__ ((aligned(__alignof__(std::collate<char>))));\n+  fake_collate_c collate_c;\n+\n+  typedef char fake_numpunct_c[sizeof(numpunct<char>)]\n+  __attribute__ ((aligned(__alignof__(numpunct<char>))));\n+  fake_numpunct_c numpunct_c;\n+\n+  typedef char fake_num_get_c[sizeof(num_get<char>)]\n+  __attribute__ ((aligned(__alignof__(num_get<char>))));\n+  fake_num_get_c num_get_c;\n+\n+  typedef char fake_num_put_c[sizeof(num_put<char>)]\n+  __attribute__ ((aligned(__alignof__(num_put<char>))));\n+  fake_num_put_c num_put_c;\n+\n+  typedef char fake_codecvt_c[sizeof(codecvt<char, char, mbstate_t>)]\n+  __attribute__ ((aligned(__alignof__(codecvt<char, char, mbstate_t>))));\n+  fake_codecvt_c codecvt_c;\n+\n+  typedef char fake_moneypunct_c[sizeof(moneypunct<char, true>)]\n+  __attribute__ ((aligned(__alignof__(moneypunct<char, true>))));\n+  fake_moneypunct_c moneypunct_ct;\n+  fake_moneypunct_c moneypunct_cf;\n+\n+  typedef char fake_money_get_c[sizeof(money_get<char>)]\n+  __attribute__ ((aligned(__alignof__(money_get<char>))));\n+  fake_money_get_c money_get_c;\n+  \n+  typedef char fake_money_put_c[sizeof(money_put<char>)]\n+  __attribute__ ((aligned(__alignof__(money_put<char>))));\n+  fake_money_put_c money_put_c;\n+\n+  typedef char fake_timepunct_c[sizeof(__timepunct<char>)]\n+  __attribute__ ((aligned(__alignof__(__timepunct<char>))));\n+  fake_timepunct_c timepunct_c;\n+\n+  typedef char fake_time_get_c[sizeof(time_get<char>)]\n+  __attribute__ ((aligned(__alignof__(time_get<char>))));\n+  fake_time_get_c time_get_c;\n+\n+  typedef char fake_time_put_c[sizeof(time_put<char>)]\n+  __attribute__ ((aligned(__alignof__(time_put<char>))));\n+  fake_time_put_c time_put_c;\n+\n+  typedef char fake_messages_c[sizeof(messages<char>)]\n+  __attribute__ ((aligned(__alignof__(messages<char>))));\n+  fake_messages_c messages_c;\n+\n #ifdef  _GLIBCXX_USE_WCHAR_T\n-  extern std::ctype<wchar_t>\t\t\t ctype_w;\n-  extern std::collate<wchar_t> \t\t\t collate_w;\n-  extern std::numpunct<wchar_t> \t\t numpunct_w;\n-  extern std::num_get<wchar_t> \t\t\t num_get_w;\n-  extern std::num_put<wchar_t> \t\t\t num_put_w;\n-  extern std::codecvt<wchar_t, char, mbstate_t>\t codecvt_w;\n-  extern std::moneypunct<wchar_t, false> \t moneypunct_wf;\n-  extern std::moneypunct<wchar_t, true> \t moneypunct_wt;\n-  extern std::money_get<wchar_t> \t\t money_get_w;\n-  extern std::money_put<wchar_t> \t \t money_put_w;\n-  extern std::__timepunct<wchar_t> \t\t timepunct_w;\n-  extern std::time_get<wchar_t> \t\t time_get_w;\n-  extern std::time_put<wchar_t> \t\t time_put_w;\n-  extern std::messages<wchar_t> \t\t messages_w;\n+  typedef char fake_wtype_w[sizeof(std::ctype<wchar_t>)]\n+  __attribute__ ((aligned(__alignof__(std::ctype<wchar_t>))));\n+  fake_wtype_w ctype_w;\n+\n+  typedef char fake_wollate_w[sizeof(std::collate<wchar_t>)]\n+  __attribute__ ((aligned(__alignof__(std::collate<wchar_t>))));\n+  fake_wollate_w collate_w;\n+\n+  typedef char fake_numpunct_w[sizeof(numpunct<wchar_t>)]\n+  __attribute__ ((aligned(__alignof__(numpunct<wchar_t>))));\n+  fake_numpunct_w numpunct_w;\n+\n+  typedef char fake_num_get_w[sizeof(num_get<wchar_t>)]\n+  __attribute__ ((aligned(__alignof__(num_get<wchar_t>))));\n+  fake_num_get_w num_get_w;\n+\n+  typedef char fake_num_put_w[sizeof(num_put<wchar_t>)]\n+  __attribute__ ((aligned(__alignof__(num_put<wchar_t>))));\n+  fake_num_put_w num_put_w;\n+\n+  typedef char fake_wodecvt_w[sizeof(codecvt<wchar_t, char, mbstate_t>)]\n+  __attribute__ ((aligned(__alignof__(codecvt<wchar_t, char, mbstate_t>))));\n+  fake_wodecvt_w codecvt_w;\n+\n+  typedef char fake_moneypunct_w[sizeof(moneypunct<wchar_t, true>)]\n+  __attribute__ ((aligned(__alignof__(moneypunct<wchar_t, true>))));\n+  fake_moneypunct_w moneypunct_wt;\n+  fake_moneypunct_w moneypunct_wf;\n+\n+  typedef char fake_money_get_w[sizeof(money_get<wchar_t>)]\n+  __attribute__ ((aligned(__alignof__(money_get<wchar_t>))));\n+  fake_money_get_w money_get_w;\n+  \n+  typedef char fake_money_put_w[sizeof(money_put<wchar_t>)]\n+  __attribute__ ((aligned(__alignof__(money_put<wchar_t>))));\n+  fake_money_put_w money_put_w;\n+\n+  typedef char fake_timepunct_w[sizeof(__timepunct<wchar_t>)]\n+  __attribute__ ((aligned(__alignof__(__timepunct<wchar_t>))));\n+  fake_timepunct_w timepunct_w;\n+\n+  typedef char fake_time_get_w[sizeof(time_get<wchar_t>)]\n+  __attribute__ ((aligned(__alignof__(time_get<wchar_t>))));\n+  fake_time_get_w time_get_w;\n+\n+  typedef char fake_time_put_w[sizeof(time_put<wchar_t>)]\n+  __attribute__ ((aligned(__alignof__(time_put<wchar_t>))));\n+  fake_time_put_w time_put_w;\n+\n+  typedef char fake_messages_w[sizeof(messages<wchar_t>)]\n+  __attribute__ ((aligned(__alignof__(messages<wchar_t>))));\n+  fake_messages_w messages_w;\n #endif\n \n-  // And the caches....\n-  extern std::locale::facet* cache_vec[_GLIBCXX_NUM_FACETS];\n-  extern std::__numpunct_cache<char>\t\t numpunct_cache_c;\n-  extern std::__moneypunct_cache<char, false>\t moneypunct_cache_cf;\n-  extern std::__moneypunct_cache<char, true>\t moneypunct_cache_ct;\n-  extern std::__timepunct_cache<char>\t\t timepunct_cache_c;\n-#ifdef  _GLIBCXX_USE_WCHAR_T\n-  extern std::__numpunct_cache<wchar_t>\t\t numpunct_cache_w;\n-  extern std::__moneypunct_cache<wchar_t, false> moneypunct_cache_wf;\n-  extern std::__moneypunct_cache<wchar_t, true>\t moneypunct_cache_wt;\n-  extern std::__timepunct_cache<wchar_t>\t timepunct_cache_w;\n+  // Storage for \"C\" locale caches.\n+  typedef char fake_num_cache_c[sizeof(std::__numpunct_cache<char>)]\n+  __attribute__ ((aligned(__alignof__(std::__numpunct_cache<char>))));\n+  fake_num_cache_c numpunct_cache_c;\n+\n+  typedef char fake_money_cache_c[sizeof(std::__moneypunct_cache<char, true>)]\n+  __attribute__ ((aligned(__alignof__(std::__moneypunct_cache<char, true>))));\n+  fake_money_cache_c moneypunct_cache_ct;\n+  fake_money_cache_c moneypunct_cache_cf;\n+\n+  typedef char fake_time_cache_c[sizeof(std::__timepunct_cache<char>)]\n+  __attribute__ ((aligned(__alignof__(std::__timepunct_cache<char>))));\n+  fake_time_cache_c timepunct_cache_c;\n+\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+  typedef char fake_num_cache_w[sizeof(std::__numpunct_cache<wchar_t>)]\n+  __attribute__ ((aligned(__alignof__(std::__numpunct_cache<wchar_t>))));\n+  fake_num_cache_w numpunct_cache_w;\n+\n+  typedef char fake_money_cache_w[sizeof(std::__moneypunct_cache<wchar_t,true>)]\n+  __attribute__ ((aligned(__alignof__(std::__moneypunct_cache<wchar_t,true>))));\n+  fake_money_cache_w moneypunct_cache_wt;\n+  fake_money_cache_w moneypunct_cache_wf;\n+\n+  typedef char fake_time_cache_w[sizeof(std::__timepunct_cache<wchar_t>)]\n+  __attribute__ ((aligned(__alignof__(std::__timepunct_cache<wchar_t>))));\n+  fake_time_cache_w timepunct_cache_w;\n #endif\n \n   // Mutex object for locale initialization.\n   static __glibcxx_mutex_define_initialized(locale_mutex);\n-} // namespace __gnu_internal\n+} // anonymous namespace\n \n _GLIBCXX_BEGIN_NAMESPACE(std)\n \n-  using namespace __gnu_internal;\n-\n   locale::locale() throw() : _M_impl(0)\n   { \n     _S_initialize();\n-    __gnu_cxx::lock sentry(__gnu_internal::locale_mutex);\n+    __gnu_cxx::lock sentry(locale_mutex);\n     _S_global->_M_add_reference();\n     _M_impl = _S_global;\n   }\n@@ -111,7 +220,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n     _S_initialize();\n     _Impl* __old;\n     {\n-      __gnu_cxx::lock sentry(__gnu_internal::locale_mutex);\n+      __gnu_cxx::lock sentry(locale_mutex);\n       __old = _S_global;\n       __other._M_impl->_M_add_reference();\n       _S_global = __other._M_impl;\n@@ -132,7 +241,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n   locale::classic()\n   {\n     _S_initialize();\n-    return c_locale;\n+    return reinterpret_cast<const locale&>(c_locale);\n   }\n \n   void"}, {"sha": "191f3a528642c45527fb5bc20488e097ce86e9b2", "filename": "libstdc++-v3/src/mt_allocator.cc", "status": "modified", "additions": 36, "deletions": 40, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d/libstdc%2B%2B-v3%2Fsrc%2Fmt_allocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d/libstdc%2B%2B-v3%2Fsrc%2Fmt_allocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fmt_allocator.cc?ref=b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d", "patch": "@@ -35,7 +35,7 @@\n #include <bits/concurrence.h>\n #include <ext/mt_allocator.h>\n \n-namespace __gnu_internal _GLIBCXX_VISIBILITY(hidden)\n+namespace\n {\n #ifdef __GTHREADS\n   struct __freelist\n@@ -64,17 +64,16 @@ namespace __gnu_internal _GLIBCXX_VISIBILITY(hidden)\n   _M_destroy_thread_key(void* __id)\n   {\n     // Return this thread id record to the front of thread_freelist.\n-    __gnu_cxx::lock sentry(__gnu_internal::freelist_mutex);\n+    __gnu_cxx::lock sentry(freelist_mutex);\n     size_t _M_id = reinterpret_cast<size_t>(__id);\n \n-    using namespace __gnu_internal;\n     typedef __gnu_cxx::__pool<true>::_Thread_record _Thread_record;\n     _Thread_record* __tr = &freelist._M_thread_freelist_array[_M_id - 1];\n     __tr->_M_next = freelist._M_thread_freelist;\n     freelist._M_thread_freelist = __tr;\n   }\n #endif\n-}\n+} // anonymous namespace\n \n _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \n@@ -466,10 +465,10 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n     if (__gthread_active_p())\n       {\n \t{\n-\t  __gnu_cxx::lock sentry(__gnu_internal::freelist_mutex);\n+\t  __gnu_cxx::lock sentry(freelist_mutex);\n \n-\t  if (!__gnu_internal::freelist._M_thread_freelist_array\n-\t      || __gnu_internal::freelist._M_max_threads\n+\t  if (!freelist._M_thread_freelist_array\n+\t      || freelist._M_max_threads\n \t\t < _M_options._M_max_threads)\n \t    {\n \t      const size_t __k = sizeof(_Thread_record)\n@@ -492,39 +491,39 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \t      _M_thread_freelist[__i - 1]._M_next = NULL;\n \t      _M_thread_freelist[__i - 1]._M_id = __i;\n \n-\t      if (!__gnu_internal::freelist._M_thread_freelist_array)\n+\t      if (!freelist._M_thread_freelist_array)\n \t\t{\n \t\t  // Initialize per thread key to hold pointer to\n \t\t  // _M_thread_freelist.\n-\t\t  __gthread_key_create(&__gnu_internal::freelist._M_key,\n-\t\t\t\t       __gnu_internal::_M_destroy_thread_key);\n-\t\t  __gnu_internal::freelist._M_thread_freelist\n+\t\t  __gthread_key_create(&freelist._M_key,\n+\t\t\t\t       ::_M_destroy_thread_key);\n+\t\t  freelist._M_thread_freelist\n \t\t    = _M_thread_freelist;\n \t\t}\n \t      else\n \t\t{\n \t\t  _Thread_record* _M_old_freelist\n-\t\t    = __gnu_internal::freelist._M_thread_freelist;\n+\t\t    = freelist._M_thread_freelist;\n \t\t  _Thread_record* _M_old_array\n-\t\t    = __gnu_internal::freelist._M_thread_freelist_array;\n-\t\t  __gnu_internal::freelist._M_thread_freelist\n+\t\t    = freelist._M_thread_freelist_array;\n+\t\t  freelist._M_thread_freelist\n \t\t    = &_M_thread_freelist[_M_old_freelist - _M_old_array];\n \t\t  while (_M_old_freelist)\n \t\t    {\n \t\t      size_t next_id;\n \t\t      if (_M_old_freelist->_M_next)\n \t\t\tnext_id = _M_old_freelist->_M_next - _M_old_array;\n \t\t      else\n-\t\t\tnext_id = __gnu_internal::freelist._M_max_threads;\n+\t\t\tnext_id = freelist._M_max_threads;\n \t\t      _M_thread_freelist[_M_old_freelist->_M_id - 1]._M_next\n \t\t\t= &_M_thread_freelist[next_id];\n \t\t      _M_old_freelist = _M_old_freelist->_M_next;\n \t\t    }\n \t\t  ::operator delete(static_cast<void*>(_M_old_array));\n \t\t}\n-\t      __gnu_internal::freelist._M_thread_freelist_array\n+\t      freelist._M_thread_freelist_array\n \t\t= _M_thread_freelist;\n-\t      __gnu_internal::freelist._M_max_threads\n+\t      freelist._M_max_threads\n \t\t= _M_options._M_max_threads;\n \t    }\n \t}\n@@ -587,21 +586,21 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n     // returns it's id.\n     if (__gthread_active_p())\n       {\n-\tvoid* v = __gthread_getspecific(__gnu_internal::freelist._M_key);\n+\tvoid* v = __gthread_getspecific(freelist._M_key);\n \tsize_t _M_id = (size_t)v;\n \tif (_M_id == 0)\n \t  {\n \t    {\n-\t      __gnu_cxx::lock sentry(__gnu_internal::freelist_mutex);\n-\t      if (__gnu_internal::freelist._M_thread_freelist)\n+\t      __gnu_cxx::lock sentry(freelist_mutex);\n+\t      if (freelist._M_thread_freelist)\n \t\t{\n-\t\t  _M_id = __gnu_internal::freelist._M_thread_freelist->_M_id;\n-\t\t  __gnu_internal::freelist._M_thread_freelist\n-\t\t    = __gnu_internal::freelist._M_thread_freelist->_M_next;\n+\t\t  _M_id = freelist._M_thread_freelist->_M_id;\n+\t\t  freelist._M_thread_freelist\n+\t\t    = freelist._M_thread_freelist->_M_next;\n \t\t}\n \t    }\n \n-\t    __gthread_setspecific(__gnu_internal::freelist._M_key,\n+\t    __gthread_setspecific(freelist._M_key,\n \t\t\t\t  (void*)_M_id);\n \t  }\n \treturn _M_id >= _M_options._M_max_threads ? 0 : _M_id;\n@@ -665,10 +664,10 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n     if (__gthread_active_p())\n       {\n \t{\n-\t  __gnu_cxx::lock sentry(__gnu_internal::freelist_mutex);\n+\t  __gnu_cxx::lock sentry(freelist_mutex);\n \n-\t  if (!__gnu_internal::freelist._M_thread_freelist_array\n-\t      || __gnu_internal::freelist._M_max_threads\n+\t  if (!freelist._M_thread_freelist_array\n+\t      || freelist._M_max_threads\n \t\t < _M_options._M_max_threads)\n \t    {\n \t      const size_t __k = sizeof(_Thread_record)\n@@ -691,40 +690,37 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \t      _M_thread_freelist[__i - 1]._M_next = NULL;\n \t      _M_thread_freelist[__i - 1]._M_id = __i;\n \n-\t      if (!__gnu_internal::freelist._M_thread_freelist_array)\n+\t      if (!freelist._M_thread_freelist_array)\n \t\t{\n \t\t  // Initialize per thread key to hold pointer to\n \t\t  // _M_thread_freelist.\n-\t\t  __gthread_key_create(&__gnu_internal::freelist._M_key,\n-\t\t\t\t       __gnu_internal::_M_destroy_thread_key);\n-\t\t  __gnu_internal::freelist._M_thread_freelist\n-\t\t    = _M_thread_freelist;\n+\t\t  __gthread_key_create(&freelist._M_key, \n+\t\t\t\t       ::_M_destroy_thread_key);\n+\t\t  freelist._M_thread_freelist = _M_thread_freelist;\n \t\t}\n \t      else\n \t\t{\n \t\t  _Thread_record* _M_old_freelist\n-\t\t    = __gnu_internal::freelist._M_thread_freelist;\n+\t\t    = freelist._M_thread_freelist;\n \t\t  _Thread_record* _M_old_array\n-\t\t    = __gnu_internal::freelist._M_thread_freelist_array;\n-\t\t  __gnu_internal::freelist._M_thread_freelist\n+\t\t    = freelist._M_thread_freelist_array;\n+\t\t  freelist._M_thread_freelist\n \t\t    = &_M_thread_freelist[_M_old_freelist - _M_old_array];\n \t\t  while (_M_old_freelist)\n \t\t    {\n \t\t      size_t next_id;\n \t\t      if (_M_old_freelist->_M_next)\n \t\t\tnext_id = _M_old_freelist->_M_next - _M_old_array;\n \t\t      else\n-\t\t\tnext_id = __gnu_internal::freelist._M_max_threads;\n+\t\t\tnext_id = freelist._M_max_threads;\n \t\t      _M_thread_freelist[_M_old_freelist->_M_id - 1]._M_next\n \t\t\t= &_M_thread_freelist[next_id];\n \t\t      _M_old_freelist = _M_old_freelist->_M_next;\n \t\t    }\n \t\t  ::operator delete(static_cast<void*>(_M_old_array));\n \t\t}\n-\t      __gnu_internal::freelist._M_thread_freelist_array\n-\t\t= _M_thread_freelist;\n-\t      __gnu_internal::freelist._M_max_threads\n-\t\t= _M_options._M_max_threads;\n+\t      freelist._M_thread_freelist_array = _M_thread_freelist;\n+\t      freelist._M_max_threads = _M_options._M_max_threads;\n \t    }\n \t}\n "}, {"sha": "30441383cc4a522d165bd5c3109a7a20c1f8ddd5", "filename": "libstdc++-v3/src/pool_allocator.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d/libstdc%2B%2B-v3%2Fsrc%2Fpool_allocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d/libstdc%2B%2B-v3%2Fsrc%2Fpool_allocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fpool_allocator.cc?ref=b82f782bfb5c4383ac0bc1e37271ab3bbeb9304d", "patch": "@@ -35,7 +35,7 @@\n #include <cstdlib>\n #include <ext/pool_allocator.h>\n \n-namespace __gnu_internal _GLIBCXX_VISIBILITY(hidden)\n+namespace\n {\n   static __glibcxx_mutex_define_initialized(palloc_init_mutex);\n }\n@@ -52,7 +52,7 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \n   mutex_type&\n   __pool_alloc_base::_M_get_mutex()\n-  { return __gnu_internal::palloc_init_mutex; }\n+  { return palloc_init_mutex; }\n \n   // Allocate memory in large chunks in order to avoid fragmenting the\n   // heap too much.  Assume that __n is properly aligned.  We hold the"}]}