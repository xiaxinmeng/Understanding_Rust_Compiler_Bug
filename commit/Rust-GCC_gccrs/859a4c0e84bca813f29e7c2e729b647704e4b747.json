{"sha": "859a4c0e84bca813f29e7c2e729b647704e4b747", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODU5YTRjMGU4NGJjYTgxM2YyOWU3YzJlNzI5YjY0NzcwNGU0Yjc0Nw==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel@linux.vnet.ibm.com", "date": "2016-02-19T10:31:05Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2016-02-19T10:31:05Z"}, "message": "S/390: z13 inline stpcpy implementation.\n\nA handwritten loop for stpcpy using the new z13 vector instructions\nappears to be much faster than the millicoded instruction.  However,\nthe implementation is much longer and therefore will only be enabled\nwhen optimization for speed.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/s390/md/movstr-2.c: New test.\n\ngcc/ChangeLog:\n\n\t* config/s390/s390-protos.h: Add s390_expand_vec_movstr prototype.\n\t* config/s390/s390.c (s390_expand_vec_movstr): New function.\n\t* config/s390/s390.md (\"movstr<P:mode>\"): Call\n\ts390_expand_vec_movstr.\n\nFrom-SVN: r233550", "tree": {"sha": "3baa676a3be7520cbbe32785f6125a0482751e00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3baa676a3be7520cbbe32785f6125a0482751e00"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/859a4c0e84bca813f29e7c2e729b647704e4b747", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/859a4c0e84bca813f29e7c2e729b647704e4b747", "html_url": "https://github.com/Rust-GCC/gccrs/commit/859a4c0e84bca813f29e7c2e729b647704e4b747", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/859a4c0e84bca813f29e7c2e729b647704e4b747/comments", "author": null, "committer": null, "parents": [{"sha": "9a36359ec618e0eaff5f622cb61bc1af1c72e5c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a36359ec618e0eaff5f622cb61bc1af1c72e5c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a36359ec618e0eaff5f622cb61bc1af1c72e5c1"}], "stats": {"total": 240, "additions": 238, "deletions": 2}, "files": [{"sha": "d6c0aa9c9e5bd9752596201975523ceaf276831c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/859a4c0e84bca813f29e7c2e729b647704e4b747/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/859a4c0e84bca813f29e7c2e729b647704e4b747/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=859a4c0e84bca813f29e7c2e729b647704e4b747", "patch": "@@ -1,3 +1,10 @@\n+2016-02-19  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n+\n+\t* config/s390/s390-protos.h: Add s390_expand_vec_movstr prototype.\n+\t* config/s390/s390.c (s390_expand_vec_movstr): New function.\n+\t* config/s390/s390.md (\"movstr<P:mode>\"): Call\n+\ts390_expand_vec_movstr.\n+\n 2016-02-19  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n \n \t* config/s390/s390.md: Add missing output modifier for operand 1"}, {"sha": "792eaa7105310f6941067d5091d561f402bd8678", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/859a4c0e84bca813f29e7c2e729b647704e4b747/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/859a4c0e84bca813f29e7c2e729b647704e4b747/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=859a4c0e84bca813f29e7c2e729b647704e4b747", "patch": "@@ -109,6 +109,7 @@ extern bool s390_expand_movmem (rtx, rtx, rtx);\n extern void s390_expand_setmem (rtx, rtx, rtx);\n extern bool s390_expand_cmpmem (rtx, rtx, rtx, rtx);\n extern void s390_expand_vec_strlen (rtx, rtx, rtx);\n+extern void s390_expand_vec_movstr (rtx, rtx, rtx);\n extern bool s390_expand_addcc (enum rtx_code, rtx, rtx, rtx, rtx, rtx);\n extern bool s390_expand_insv (rtx, rtx, rtx, rtx);\n extern void s390_expand_cs_hqi (machine_mode, rtx, rtx, rtx,"}, {"sha": "da05a0495575b942502c758196c7f194be62af52", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/859a4c0e84bca813f29e7c2e729b647704e4b747/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/859a4c0e84bca813f29e7c2e729b647704e4b747/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=859a4c0e84bca813f29e7c2e729b647704e4b747", "patch": "@@ -5622,6 +5622,124 @@ s390_expand_vec_strlen (rtx target, rtx string, rtx alignment)\n     emit_move_insn (target, temp);\n }\n \n+void\n+s390_expand_vec_movstr (rtx result, rtx dst, rtx src)\n+{\n+  int very_unlikely = REG_BR_PROB_BASE / 100 - 1;\n+  rtx temp = gen_reg_rtx (Pmode);\n+  rtx src_addr = XEXP (src, 0);\n+  rtx dst_addr = XEXP (dst, 0);\n+  rtx src_addr_reg = gen_reg_rtx (Pmode);\n+  rtx dst_addr_reg = gen_reg_rtx (Pmode);\n+  rtx offset = gen_reg_rtx (Pmode);\n+  rtx vsrc = gen_reg_rtx (V16QImode);\n+  rtx vpos = gen_reg_rtx (V16QImode);\n+  rtx loadlen = gen_reg_rtx (SImode);\n+  rtx gpos_qi = gen_reg_rtx(QImode);\n+  rtx gpos = gen_reg_rtx (SImode);\n+  rtx done_label = gen_label_rtx ();\n+  rtx loop_label = gen_label_rtx ();\n+  rtx exit_label = gen_label_rtx ();\n+  rtx full_label = gen_label_rtx ();\n+\n+  /* Perform a quick check for string ending on the first up to 16\n+     bytes and exit early if successful.  */\n+\n+  emit_insn (gen_vlbb (vsrc, src, GEN_INT (6)));\n+  emit_insn (gen_lcbb (loadlen, src_addr, GEN_INT (6)));\n+  emit_insn (gen_vfenezv16qi (vpos, vsrc, vsrc));\n+  emit_insn (gen_vec_extractv16qi (gpos_qi, vpos, GEN_INT (7)));\n+  emit_move_insn (gpos, gen_rtx_SUBREG (SImode, gpos_qi, 0));\n+  /* gpos is the byte index if a zero was found and 16 otherwise.\n+     So if it is lower than the loaded bytes we have a hit.  */\n+  emit_cmp_and_jump_insns (gpos, loadlen, GE, NULL_RTX, SImode, 1,\n+\t\t\t   full_label);\n+  emit_insn (gen_vstlv16qi (vsrc, gpos, dst));\n+\n+  force_expand_binop (Pmode, add_optab, dst_addr, gpos, result,\n+\t\t      1, OPTAB_DIRECT);\n+  emit_jump (exit_label);\n+  emit_barrier ();\n+\n+  emit_label (full_label);\n+  LABEL_NUSES (full_label) = 1;\n+\n+  /* Calculate `offset' so that src + offset points to the last byte\n+     before 16 byte alignment.  */\n+\n+  /* temp = src_addr & 0xf */\n+  force_expand_binop (Pmode, and_optab, src_addr, GEN_INT (15), temp,\n+\t\t      1, OPTAB_DIRECT);\n+\n+  /* offset = 0xf - temp */\n+  emit_move_insn (offset, GEN_INT (15));\n+  force_expand_binop (Pmode, sub_optab, offset, temp, offset,\n+\t\t      1, OPTAB_DIRECT);\n+\n+  /* Store `offset' bytes in the dstination string.  The quick check\n+     has loaded at least `offset' bytes into vsrc.  */\n+\n+  emit_insn (gen_vstlv16qi (vsrc, gen_lowpart (SImode, offset), dst));\n+\n+  /* Advance to the next byte to be loaded.  */\n+  force_expand_binop (Pmode, add_optab, offset, const1_rtx, offset,\n+\t\t      1, OPTAB_DIRECT);\n+\n+  /* Make sure the addresses are single regs which can be used as a\n+     base.  */\n+  emit_move_insn (src_addr_reg, src_addr);\n+  emit_move_insn (dst_addr_reg, dst_addr);\n+\n+  /* MAIN LOOP */\n+\n+  emit_label (loop_label);\n+  LABEL_NUSES (loop_label) = 1;\n+\n+  emit_move_insn (vsrc,\n+\t\t  gen_rtx_MEM (V16QImode,\n+\t\t\t       gen_rtx_PLUS (Pmode, src_addr_reg, offset)));\n+\n+  emit_insn (gen_vec_vfenesv16qi (vpos, vsrc, vsrc,\n+\t\t\t\t  GEN_INT (VSTRING_FLAG_ZS | VSTRING_FLAG_CS)));\n+  add_int_reg_note (s390_emit_ccraw_jump (8, EQ, done_label),\n+\t\t    REG_BR_PROB, very_unlikely);\n+\n+  emit_move_insn (gen_rtx_MEM (V16QImode,\n+\t\t\t       gen_rtx_PLUS (Pmode, dst_addr_reg, offset)),\n+\t\t  vsrc);\n+  /* offset += 16 */\n+  force_expand_binop (Pmode, add_optab, offset, GEN_INT (16),\n+\t\t      offset,  1, OPTAB_DIRECT);\n+\n+  emit_jump (loop_label);\n+  emit_barrier ();\n+\n+  /* REGULAR EXIT */\n+\n+  /* We are done.  Add the offset of the zero character to the dst_addr\n+     pointer to get the result.  */\n+\n+  emit_label (done_label);\n+  LABEL_NUSES (done_label) = 1;\n+\n+  force_expand_binop (Pmode, add_optab, dst_addr_reg, offset, dst_addr_reg,\n+\t\t      1, OPTAB_DIRECT);\n+\n+  emit_insn (gen_vec_extractv16qi (gpos_qi, vpos, GEN_INT (7)));\n+  emit_move_insn (gpos, gen_rtx_SUBREG (SImode, gpos_qi, 0));\n+\n+  emit_insn (gen_vstlv16qi (vsrc, gpos, gen_rtx_MEM (BLKmode, dst_addr_reg)));\n+\n+  force_expand_binop (Pmode, add_optab, dst_addr_reg, gpos, result,\n+\t\t      1, OPTAB_DIRECT);\n+\n+  /* EARLY EXIT */\n+\n+  emit_label (exit_label);\n+  LABEL_NUSES (exit_label) = 1;\n+}\n+\n+\n /* Expand conditional increment or decrement using alc/slb instructions.\n    Should generate code setting DST to either SRC or SRC + INCREMENT,\n    depending on the result of the comparison CMP_OP0 CMP_CODE CMP_OP1."}, {"sha": "2c90eae0fab3234a4fcadb38f2c7c124e87385fa", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/859a4c0e84bca813f29e7c2e729b647704e4b747/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/859a4c0e84bca813f29e7c2e729b647704e4b747/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=859a4c0e84bca813f29e7c2e729b647704e4b747", "patch": "@@ -2953,8 +2953,16 @@\n      (clobber (reg:CC CC_REGNUM))])]\n   \"\"\n {\n-  rtx addr1 = gen_reg_rtx (Pmode);\n-  rtx addr2 = gen_reg_rtx (Pmode);\n+  rtx addr1, addr2;\n+\n+  if (TARGET_VX && optimize_function_for_speed_p (cfun))\n+    {\n+      s390_expand_vec_movstr (operands[0], operands[1], operands[2]);\n+      DONE;\n+    }\n+\n+  addr1 = gen_reg_rtx (Pmode);\n+  addr2 = gen_reg_rtx (Pmode);\n \n   emit_move_insn (addr1, force_operand (XEXP (operands[1], 0), NULL_RTX));\n   emit_move_insn (addr2, force_operand (XEXP (operands[2], 0), NULL_RTX));"}, {"sha": "964d09301bb4fe2bf3c4f8193275424d53a58124", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/859a4c0e84bca813f29e7c2e729b647704e4b747/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/859a4c0e84bca813f29e7c2e729b647704e4b747/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=859a4c0e84bca813f29e7c2e729b647704e4b747", "patch": "@@ -1,3 +1,7 @@\n+2016-02-19  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n+\n+\t* gcc.target/s390/md/movstr-2.c: New test.\n+\n 2016-02-19  Marcin Ko\u015bcielnicki  <koriakin@0x04.net>\n \n \t* gcc.target/s390/morestack.c: New test."}, {"sha": "1b977a205c931fa72ffce8d91f8c3d9f74b1f869", "filename": "gcc/testsuite/gcc.target/s390/md/movstr-2.c", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/859a4c0e84bca813f29e7c2e729b647704e4b747/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fmd%2Fmovstr-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/859a4c0e84bca813f29e7c2e729b647704e4b747/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fmd%2Fmovstr-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fmd%2Fmovstr-2.c?ref=859a4c0e84bca813f29e7c2e729b647704e4b747", "patch": "@@ -0,0 +1,98 @@\n+/* The z13 stpcpy implementation plays some alignment tricks for good\n+   performance.  This test tries to make sure it works correctly and\n+   does not access bytes beyond the source and destination\n+   strings.  */\n+\n+/* { dg-do run } */\n+\n+#include <stdio.h>\n+#include <sys/mman.h>\n+\n+#define PAGE_SIZE 4096\n+\n+struct {\n+  char unused[PAGE_SIZE - 32];\n+  char m32[15]; /* page bndry - 32 */\n+  char m17[1];\n+  char m16[1];\n+  char m15[14];\n+  char m1[1];\n+  char next_page[PAGE_SIZE];\n+} s, d __attribute__((aligned(PAGE_SIZE)));\n+\n+char *__attribute__((noinline))\n+my_stpcpy(char *dest, const char *src)\n+{\n+  return __builtin_stpcpy (dest, src);\n+}\n+\n+void __attribute__ ((noinline))\n+check (char *dest, char *src, size_t len)\n+{\n+  char *result;\n+\n+  result = my_stpcpy (dest, src);\n+  if (result != dest + len)\n+    __builtin_abort ();\n+  if (__builtin_memcmp (src, dest, len) != 0)\n+    __builtin_abort ();\n+}\n+\n+int\n+main ()\n+{\n+  char *src[5] = { s.m32, s.m17, s.m16, s.m15, s.m1 };\n+  char *dst[5] = { d.m32, d.m17, d.m16, d.m15, d.m1 };\n+  int len[8] = { 33, 32, 31, 17, 16, 15, 1, 0 };\n+  int i, j, k;\n+  char backup;\n+\n+  for (i = 0; i < sizeof (s); i++)\n+    ((char*)&s)[i] = i % 26 + 97;\n+\n+  for (i = 0; i < 5; i++)\n+    for (j = 0; j < 5; j++)\n+      for (k = 0; k < 8; k++)\n+\t{\n+\t  backup = src[j][len[k]];\n+\t  src[j][len[k]] = 0;\n+\t  __builtin_memset (&d, 0, sizeof (d));\n+\t  check (dst[i], src[j], len[k]);\n+\t  src[j][len[k]] = backup;\n+\t}\n+\n+  /* Make all source strings end before the page boundary.  */\n+  backup = s.m1[0];\n+  s.m1[0] = 0;\n+\n+  if (mprotect (&s.next_page, PAGE_SIZE, PROT_NONE) == -1)\n+    perror (\"mprotect src\");\n+\n+  for (i = 0; i < 5; i++)\n+    for (j = 0; j < 5; j++)\n+      check (dst[i], src[j],\n+\t     PAGE_SIZE - ((unsigned long)src[j] & ((1UL << 12) - 1)) - 1);\n+\n+  if (mprotect (&s.next_page, PAGE_SIZE, PROT_READ | PROT_WRITE) == -1)\n+    perror (\"mprotect src\");\n+\n+  s.m1[0] = backup;\n+\n+  if (mprotect (&d.next_page, PAGE_SIZE, PROT_NONE) == -1)\n+    perror (\"mprotect dst\");\n+\n+  for (i = 0; i < 5; i++)\n+    for (j = 0; j < 5; j++)\n+      {\n+\tint len = PAGE_SIZE - ((unsigned long)dst[i] & ((1UL << 12) - 1)) - 1;\n+\tchar backup = src[j][len];\n+\n+\tsrc[j][len] = 0;\n+\t__builtin_memset (&d, 0,\n+\t\t\t  (unsigned long)&d.next_page - (unsigned long)&d);\n+\tcheck (dst[i], src[j], len);\n+\tsrc[j][len] = backup;\n+      }\n+\n+  return 0;\n+}"}]}