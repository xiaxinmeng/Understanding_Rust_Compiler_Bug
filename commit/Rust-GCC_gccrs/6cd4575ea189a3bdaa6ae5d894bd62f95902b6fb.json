{"sha": "6cd4575ea189a3bdaa6ae5d894bd62f95902b6fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmNkNDU3NWVhMTg5YTNiZGFhNmFlNWQ4OTRiZDYyZjk1OTAyYjZmYg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-03-08T12:24:14Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-03-08T12:24:14Z"}, "message": "Add prototypes for static functions.\n\n(struct cse_basic_block_data): Move to front of file since it constains\nstruct used in a prototype.\n(refers_to_p, find_best_addr): Now static.\n\nFrom-SVN: r3675", "tree": {"sha": "114e5a5d74a51e1ae70c81148b9d9e378342ff7b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/114e5a5d74a51e1ae70c81148b9d9e378342ff7b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6cd4575ea189a3bdaa6ae5d894bd62f95902b6fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cd4575ea189a3bdaa6ae5d894bd62f95902b6fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cd4575ea189a3bdaa6ae5d894bd62f95902b6fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cd4575ea189a3bdaa6ae5d894bd62f95902b6fb/comments", "author": null, "committer": null, "parents": [{"sha": "c19b0882166f2d9ccbfb8fc3c1e669906b70baca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c19b0882166f2d9ccbfb8fc3c1e669906b70baca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c19b0882166f2d9ccbfb8fc3c1e669906b70baca"}], "stats": {"total": 130, "additions": 80, "deletions": 50}, "files": [{"sha": "51f8887f38dba45fc33169bee9ba75250b9be492", "filename": "gcc/cse.c", "status": "modified", "additions": 80, "deletions": 50, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cd4575ea189a3bdaa6ae5d894bd62f95902b6fb/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cd4575ea189a3bdaa6ae5d894bd62f95902b6fb/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=6cd4575ea189a3bdaa6ae5d894bd62f95902b6fb", "patch": "@@ -513,6 +513,34 @@ struct write_data\n   int all : 1;\t\t\t/* Invalidate all memory refs.  */\n };\n \n+/* Define maximum length of a branch path.  */\n+\n+#define PATHLENGTH\t10\n+\n+/* This data describes a block that will be processed by cse_basic_block.  */\n+\n+struct cse_basic_block_data {\n+  /* Lowest CUID value of insns in block.  */\n+  int low_cuid;\n+  /* Highest CUID value of insns in block.  */\n+  int high_cuid;\n+  /* Total number of SETs in block.  */\n+  int nsets;\n+  /* Last insn in the block.  */\n+  rtx last;\n+  /* Size of current branch path, if any.  */\n+  int path_size;\n+  /* Current branch path, indicating which branches will be taken.  */\n+  struct branch_path {\n+    /* The branch insn. */\n+    rtx branch;\n+    /* Whether it should be taken or not.  AROUND is the same as taken\n+       except that it is used when the destination label is not preceded\n+       by a BARRIER.  */\n+    enum taken {TAKEN, NOT_TAKEN, AROUND} status;\n+  } path[PATHLENGTH];\n+};\n+\n /* Nonzero if X has the form (PLUS frame-pointer integer).  We check for\n    virtual regs here because the simplify_*_operation routines are called\n    by integrate.c, which is called before virtual register instantiation.  */\n@@ -550,26 +578,56 @@ struct write_data\n \t   || XEXP (X, 0) == virtual_stack_dynamic_rtx\t\t\\\n \t   || XEXP (X, 0) == virtual_outgoing_args_rtx)))\n \n-static struct table_elt *lookup ();\n-static void free_element ();\n-\n-static int insert_regs ();\n-static void rehash_using_reg ();\n-static void remove_invalid_refs ();\n-static int exp_equiv_p ();\n-int refers_to_p ();\n-int refers_to_mem_p ();\n-static void invalidate_from_clobbers ();\n-static int safe_hash ();\n-static int canon_hash ();\n-static rtx fold_rtx ();\n-static rtx equiv_constant ();\n-static void record_jump_cond ();\n-static void note_mem_written ();\n-static int cse_rtx_addr_varies_p ();\n-static enum rtx_code find_comparison_args ();\n-static void cse_insn ();\n-static void cse_set_around_loop ();\n+static void new_basic_block\tPROTO((void));\n+static void make_new_qty\tPROTO((int));\n+static void make_regs_eqv\tPROTO((int, int));\n+static void delete_reg_equiv\tPROTO((int));\n+static int mention_regs\t\tPROTO((rtx));\n+static int insert_regs\t\tPROTO((rtx, struct table_elt *, int));\n+static void free_element\tPROTO((struct table_elt *));\n+static void remove_from_table\tPROTO((struct table_elt *, int));\n+static struct table_elt *get_element PROTO((void));\n+static struct table_elt *lookup\tPROTO((rtx, int, enum machine_mode)),\n+       *lookup_for_remove PROTO((rtx, int, enum machine_mode));\n+static rtx lookup_as_function\tPROTO((rtx, enum rtx_code));\n+static struct table_elt *insert PROTO((rtx, struct table_elt *, int,\n+\t\t\t\t       enum machine_mode));\n+static void merge_equiv_classes PROTO((struct table_elt *,\n+\t\t\t\t       struct table_elt *));\n+static void invalidate\t\tPROTO((rtx));\n+static void remove_invalid_refs\tPROTO((int));\n+static void rehash_using_reg\tPROTO((rtx));\n+static void invalidate_memory\tPROTO((struct write_data *));\n+static void invalidate_for_call\tPROTO((void));\n+static rtx use_related_value\tPROTO((rtx, struct table_elt *));\n+static int canon_hash\t\tPROTO((rtx, enum machine_mode));\n+static int safe_hash\t\tPROTO((rtx, enum machine_mode));\n+static int exp_equiv_p\t\tPROTO((rtx, rtx, int, int));\n+static int refers_to_p\t\tPROTO((rtx, rtx));\n+int refers_to_mem_p\t\tPROTO((rtx, rtx, HOST_WIDE_INT,\n+\t\t\t\t       HOST_WIDE_INT));\n+static int cse_rtx_addr_varies_p PROTO((rtx));\n+static rtx canon_reg\t\tPROTO((rtx, rtx));\n+static void find_best_addr\tPROTO((rtx, rtx *));\n+static enum rtx_code find_comparison_args PROTO((enum rtx_code, rtx *, rtx *,\n+\t\t\t\t\t\t enum machine_mode *,\n+\t\t\t\t\t\t enum machine_mode *));\n+static rtx fold_rtx\t\tPROTO((rtx, rtx));\n+static rtx equiv_constant\tPROTO((rtx));\n+static void record_jump_equiv\tPROTO((rtx, int));\n+static void record_jump_cond\tPROTO((enum rtx_code, enum machine_mode,\n+\t\t\t\t       rtx, rtx, int));\n+static void cse_insn\t\tPROTO((rtx, int));\n+static void note_mem_written\tPROTO((rtx, struct write_data *));\n+static void invalidate_from_clobbers PROTO((struct write_data *, rtx));\n+static rtx cse_process_notes\tPROTO((rtx, rtx));\n+static void cse_around_loop\tPROTO((rtx));\n+static void invalidate_skipped_set PROTO((rtx, rtx));\n+static void invalidate_skipped_block PROTO((rtx));\n+static void cse_check_loop_start PROTO((rtx, rtx));\n+static void cse_set_around_loop\tPROTO((rtx, rtx, rtx));\n+static rtx cse_basic_block\tPROTO((rtx, rtx, struct branch_path *, int));\n+static void count_reg_usage\tPROTO((rtx, int *, int));\n \f\n /* Return an estimate of the cost of computing rtx X.\n    One use is in cse, to decide which expression to keep in the hash table.\n@@ -2101,7 +2159,7 @@ exp_equiv_p (x, y, validate, equal_values)\n    Here we do not require that X or Y be valid (for registers referred to)\n    for being in the hash table.  */\n \n-int\n+static int\n refers_to_p (x, y)\n      rtx x, y;\n {\n@@ -2425,7 +2483,7 @@ canon_reg (x, insn)\n    than hard registers here because we would also prefer the pseudo registers.\n   */\n \n-void\n+static void\n find_best_addr (insn, loc)\n      rtx insn;\n      rtx *loc;\n@@ -7356,32 +7414,6 @@ cse_set_around_loop (x, insn, loop_start)\n    the current block.  The incoming structure's branch path, if any, is used\n    to construct the output branch path.  */\n \n-/* Define maximum length of a branch path.  */\n-\n-#define PATHLENGTH\t10\n-\n-struct cse_basic_block_data {\n-  /* Lowest CUID value of insns in block.  */\n-  int low_cuid;\n-  /* Highest CUID value of insns in block.  */\n-  int high_cuid;\n-  /* Total number of SETs in block.  */\n-  int nsets;\n-  /* Last insn in the block.  */\n-  rtx last;\n-  /* Size of current branch path, if any.  */\n-  int path_size;\n-  /* Current branch path, indicating which branches will be taken.  */\n-  struct branch_path {\n-    /* The branch insn. */\n-    rtx branch;\n-    /* Whether it should be taken or not.  AROUND is the same as taken\n-       except that it is used when the destination label is not preceded\n-       by a BARRIER.  */\n-    enum taken {TAKEN, NOT_TAKEN, AROUND} status;\n-  } path[PATHLENGTH];\n-};\n-\n void\n cse_end_of_basic_block (insn, data, follow_jumps, after_loop, skip_blocks)\n      rtx insn;\n@@ -7584,8 +7616,6 @@ cse_end_of_basic_block (insn, data, follow_jumps, after_loop, skip_blocks)\n   data->path[path_size].branch = 0;\n }\n \f\n-static rtx cse_basic_block ();\n-\n /* Perform cse on the instructions of a function.\n    F is the first instruction.\n    NREGS is one plus the highest pseudo-reg number used in the instruction."}]}