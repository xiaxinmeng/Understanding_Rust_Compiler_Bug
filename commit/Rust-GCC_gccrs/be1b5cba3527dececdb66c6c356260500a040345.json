{"sha": "be1b5cba3527dececdb66c6c356260500a040345", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmUxYjVjYmEzNTI3ZGVjZWNkYjY2YzZjMzU2MjYwNTAwYTA0MDM0NQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2005-04-23T21:33:15Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2005-04-23T21:33:15Z"}, "message": "tree-ssa-loop-niter.c (tree_simplify_using_condition): Expand simple definitions of ssa names in condition.\n\n\t* tree-ssa-loop-niter.c (tree_simplify_using_condition): Expand simple\n\tdefinitions of ssa names in condition.  Split recusive part to ...\n\t(tree_simplify_using_condition_1): New function.\n\t(expand_simple_operations): New function.\n\n\t* gcc.dg/vect/vect-99.c: New test.\n\nFrom-SVN: r98635", "tree": {"sha": "0ff6a29f85740fedc59f8fc702e20fae58f30e68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ff6a29f85740fedc59f8fc702e20fae58f30e68"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be1b5cba3527dececdb66c6c356260500a040345", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be1b5cba3527dececdb66c6c356260500a040345", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be1b5cba3527dececdb66c6c356260500a040345", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be1b5cba3527dececdb66c6c356260500a040345/comments", "author": null, "committer": null, "parents": [{"sha": "f5f129618b7e7ded46e1f88f61536f7b1b60fcfc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5f129618b7e7ded46e1f88f61536f7b1b60fcfc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5f129618b7e7ded46e1f88f61536f7b1b60fcfc"}], "stats": {"total": 121, "additions": 111, "deletions": 10}, "files": [{"sha": "8d7e15642716853f68786b244aa151537ffaa8d3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be1b5cba3527dececdb66c6c356260500a040345/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be1b5cba3527dececdb66c6c356260500a040345/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=be1b5cba3527dececdb66c6c356260500a040345", "patch": "@@ -1,3 +1,10 @@\n+2005-04-23  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* tree-ssa-loop-niter.c (tree_simplify_using_condition): Expand simple\n+\tdefinitions of ssa names in condition.  Split recusive part to ...\n+\t(tree_simplify_using_condition_1): New function.\n+\t(expand_simple_operations): New function.\n+\n 2005-04-23  Zdenek Dvorak  <dvorakz@suse.cz>\n \n \t* tree-ssa-loop-ivopts.c (struct cost_pair): Add value field."}, {"sha": "819bb052c05ea1bd1ea58622753ba9b619127a73", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be1b5cba3527dececdb66c6c356260500a040345/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be1b5cba3527dececdb66c6c356260500a040345/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=be1b5cba3527dececdb66c6c356260500a040345", "patch": "@@ -1,3 +1,7 @@\n+2005-04-23  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* gcc.dg/vect/vect-99.c: New test.\n+\n 2005-04-22  Diego Novillo  <dnovillo@redhat.com>\n \n \t* gcc.dg/tree-ssa/ltrans-4.c: Fix typo in dg-options."}, {"sha": "288f2ae8daf250fa840ecf516afa6f88d5fe2c0c", "filename": "gcc/testsuite/gcc.dg/vect/vect-99.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be1b5cba3527dececdb66c6c356260500a040345/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-99.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be1b5cba3527dececdb66c6c356260500a040345/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-99.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-99.c?ref=be1b5cba3527dececdb66c6c356260500a040345", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+int ca[100];\n+\n+void foo (int n)\n+{\n+  unsigned int i;\n+\n+  for (i = 0; i < n; i++)\n+    ca[i] = 2;\n+}\n+\n+int main (void)\n+{\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "ab9de0b07f27789883f27e7fa4893ff9b176cc23", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 81, "deletions": 10, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be1b5cba3527dececdb66c6c356260500a040345/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be1b5cba3527dececdb66c6c356260500a040345/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=be1b5cba3527dececdb66c6c356260500a040345", "patch": "@@ -624,14 +624,70 @@ simplify_replace_tree (tree expr, tree old, tree new)\n   return (ret ? fold (ret) : expr);\n }\n \n+/* Expand definitions of ssa names in EXPR as long as they are simple\n+   enough, and return the new expression.  */\n+\n+static tree\n+expand_simple_operations (tree expr)\n+{\n+  unsigned i, n;\n+  tree ret = NULL_TREE, e, ee, stmt;\n+  enum tree_code code = TREE_CODE (expr);\n+\n+  if (is_gimple_min_invariant (expr))\n+    return expr;\n+\n+  if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (code)))\n+    {\n+      n = TREE_CODE_LENGTH (code);\n+      for (i = 0; i < n; i++)\n+\t{\n+\t  e = TREE_OPERAND (expr, i);\n+\t  ee = expand_simple_operations (e);\n+\t  if (e == ee)\n+\t    continue;\n+\n+\t  if (!ret)\n+\t    ret = copy_node (expr);\n+\n+\t  TREE_OPERAND (ret, i) = ee;\n+\t}\n+\n+      return (ret ? fold (ret) : expr);\n+    }\n+\n+  if (TREE_CODE (expr) != SSA_NAME)\n+    return expr;\n+\n+  stmt = SSA_NAME_DEF_STMT (expr);\n+  if (TREE_CODE (stmt) != MODIFY_EXPR)\n+    return expr;\n+\n+  e = TREE_OPERAND (stmt, 1);\n+  if (/* Casts are simple.  */\n+      TREE_CODE (e) != NOP_EXPR\n+      && TREE_CODE (e) != CONVERT_EXPR\n+      /* Copies are simple.  */\n+      && TREE_CODE (e) != SSA_NAME\n+      /* Assignments of invariants are simple.  */\n+      && !is_gimple_min_invariant (e)\n+      /* And increments and decrements by a constant are simple.  */\n+      && !((TREE_CODE (e) == PLUS_EXPR\n+\t    || TREE_CODE (e) == MINUS_EXPR)\n+\t   && is_gimple_min_invariant (TREE_OPERAND (e, 1))))\n+    return expr;\n+\n+  return expand_simple_operations (e);\n+}\n+\n /* Tries to simplify EXPR using the condition COND.  Returns the simplified\n-   expression (or EXPR unchanged, if no simplification was possible).*/\n+   expression (or EXPR unchanged, if no simplification was possible).  */\n \n static tree\n-tree_simplify_using_condition (tree cond, tree expr)\n+tree_simplify_using_condition_1 (tree cond, tree expr)\n {\n   bool changed;\n-  tree e, e0, e1, e2, notcond;\n+  tree e, te, e0, e1, e2, notcond;\n   enum tree_code code = TREE_CODE (expr);\n \n   if (code == INTEGER_CST)\n@@ -643,17 +699,17 @@ tree_simplify_using_condition (tree cond, tree expr)\n     {\n       changed = false;\n \n-      e0 = tree_simplify_using_condition (cond, TREE_OPERAND (expr, 0));\n+      e0 = tree_simplify_using_condition_1 (cond, TREE_OPERAND (expr, 0));\n       if (TREE_OPERAND (expr, 0) != e0)\n \tchanged = true;\n \n-      e1 = tree_simplify_using_condition (cond, TREE_OPERAND (expr, 1));\n+      e1 = tree_simplify_using_condition_1 (cond, TREE_OPERAND (expr, 1));\n       if (TREE_OPERAND (expr, 1) != e1)\n \tchanged = true;\n \n       if (code == COND_EXPR)\n \t{\n-\t  e2 = tree_simplify_using_condition (cond, TREE_OPERAND (expr, 2));\n+\t  e2 = tree_simplify_using_condition_1 (cond, TREE_OPERAND (expr, 2));\n \t  if (TREE_OPERAND (expr, 2) != e2)\n \t    changed = true;\n \t}\n@@ -716,22 +772,37 @@ tree_simplify_using_condition (tree cond, tree expr)\n \treturn boolean_true_node;\n     }\n \n+  te = expand_simple_operations (expr);\n+\n   /* Check whether COND ==> EXPR.  */\n   notcond = invert_truthvalue (cond);\n-  e = fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n-\t\t   notcond, expr);\n+  e = fold_build2 (TRUTH_OR_EXPR, boolean_type_node, notcond, te);\n   if (nonzero_p (e))\n     return e;\n \n   /* Check whether COND ==> not EXPR.  */\n-  e = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n-\t\t   cond, expr);\n+  e = fold_build2 (TRUTH_AND_EXPR, boolean_type_node, cond, te);\n   if (zero_p (e))\n     return e;\n \n   return expr;\n }\n \n+/* Tries to simplify EXPR using the condition COND.  Returns the simplified\n+   expression (or EXPR unchanged, if no simplification was possible).\n+   Wrapper around tree_simplify_using_condition_1 that ensures that chains\n+   of simple operations in definitions of ssa names in COND are expanded,\n+   so that things like casts or incrementing the value of the bound before\n+   the loop do not cause us to fail.  */\n+\n+static tree\n+tree_simplify_using_condition (tree cond, tree expr)\n+{\n+  cond = expand_simple_operations (cond);\n+\n+  return tree_simplify_using_condition_1 (cond, expr);\n+}\n+     \n /* Tries to simplify EXPR using the conditions on entry to LOOP.\n    Record the conditions used for simplification to CONDS_USED.\n    Returns the simplified expression (or EXPR unchanged, if no"}]}