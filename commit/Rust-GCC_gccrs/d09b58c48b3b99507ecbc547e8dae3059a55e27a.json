{"sha": "d09b58c48b3b99507ecbc547e8dae3059a55e27a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDA5YjU4YzQ4YjNiOTk1MDdlY2JjNTQ3ZThkYWUzMDU5YTU1ZTI3YQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2011-01-22T23:45:45Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2011-01-22T23:45:45Z"}, "message": "re PR target/47333 (g++.dg/lto/20091219 FAILs on Solaris 2 with SUN as)\n\n\tPR lto/47333\n\t* g++.dg/lto/pr47333.C: New file.\n\t* lto-cgraph.c (reachable_from_this_partition_p): Fix pasto.\n\nFrom-SVN: r169137", "tree": {"sha": "e5c2da5fcf9ef71724c8fdcdc6ac13da6af83fc5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e5c2da5fcf9ef71724c8fdcdc6ac13da6af83fc5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d09b58c48b3b99507ecbc547e8dae3059a55e27a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d09b58c48b3b99507ecbc547e8dae3059a55e27a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d09b58c48b3b99507ecbc547e8dae3059a55e27a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d09b58c48b3b99507ecbc547e8dae3059a55e27a/comments", "author": null, "committer": null, "parents": [{"sha": "e8ff8c5ab821ec0867687fb46cb8d012c0d5b325", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8ff8c5ab821ec0867687fb46cb8d012c0d5b325", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8ff8c5ab821ec0867687fb46cb8d012c0d5b325"}], "stats": {"total": 958, "additions": 954, "deletions": 4}, "files": [{"sha": "7923ba68d3badfb38dff2ae0c0d1125e8a421f00", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d09b58c48b3b99507ecbc547e8dae3059a55e27a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d09b58c48b3b99507ecbc547e8dae3059a55e27a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d09b58c48b3b99507ecbc547e8dae3059a55e27a", "patch": "@@ -1,3 +1,8 @@\n+2011-01-22  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR lto/47333\n+\t* lto-cgraph.c (reachable_from_this_partition_p): Fix pasto.\n+\n 2011-01-22  Jan Hubicka  <jh@suse.cz>\n \n \tPR tree-optimization/43884"}, {"sha": "18bb83b8ad65100eb48ced51806cc173f2c6f28e", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d09b58c48b3b99507ecbc547e8dae3059a55e27a/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d09b58c48b3b99507ecbc547e8dae3059a55e27a/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=d09b58c48b3b99507ecbc547e8dae3059a55e27a", "patch": "@@ -383,10 +383,6 @@ bool\n reachable_from_this_partition_p (struct cgraph_node *node, cgraph_node_set set)\n {\n   struct cgraph_edge *e;\n-  if (!node->analyzed)\n-    return false;\n-  if (node->global.inlined_to)\n-    return false;\n   for (e = node->callers; e; e = e->next_caller)\n     if (cgraph_node_in_set_p (e->caller, set))\n       return true;"}, {"sha": "1e67126dee7aa9a96b4b4b161b69d5b6f9d613f1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d09b58c48b3b99507ecbc547e8dae3059a55e27a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d09b58c48b3b99507ecbc547e8dae3059a55e27a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d09b58c48b3b99507ecbc547e8dae3059a55e27a", "patch": "@@ -1,3 +1,8 @@\n+2011-01-22  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR lto/47333\n+\t* g++.dg/lto/pr47333.C: New file.\n+\n 2011-01-22  Jan Hubicka  <jh@suse.cz>\n \n \tPR tree-optimization/43884"}, {"sha": "60873ca07c7a2763224a81c32ea89efabaf96a01", "filename": "gcc/testsuite/g++.dg/lto/pr47333.C", "status": "added", "additions": 944, "deletions": 0, "changes": 944, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d09b58c48b3b99507ecbc547e8dae3059a55e27a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr47333.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d09b58c48b3b99507ecbc547e8dae3059a55e27a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr47333.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr47333.C?ref=d09b58c48b3b99507ecbc547e8dae3059a55e27a", "patch": "@@ -0,0 +1,944 @@\n+namespace std\n+{\n+  typedef unsigned int size_t;\n+  typedef int ptrdiff_t;\n+\n+}\n+\n+namespace std __attribute__ ((__visibility__ (\"default\"))) {\n+\n+  template<typename _Alloc>\n+    class allocator;\n+\n+  template<class _CharT>\n+    struct char_traits;\n+\n+  template<typename _CharT, typename _Traits = char_traits<_CharT>,\n+           typename _Alloc = allocator<_CharT> >\n+    class basic_string;\n+\n+  template<> struct char_traits<char>;\n+\n+  typedef basic_string<char> string;\n+\n+  template<> struct char_traits<wchar_t>;\n+\n+  typedef basic_string<wchar_t> wstring;\n+}\n+\n+namespace std __attribute__ ((__visibility__ (\"default\"))) {\n+  void\n+  __throw_bad_alloc(void) __attribute__((__noreturn__));\n+}\n+\n+namespace __gnu_cxx __attribute__ ((__visibility__ (\"default\"))) {\n+  template<typename _Iterator, typename _Container>\n+    class __normal_iterator;\n+}\n+\n+namespace std __attribute__ ((__visibility__ (\"default\"))) {\n+\n+  template<typename _Tp>\n+    inline _Tp*\n+    __addressof(_Tp& __r)\n+    {\n+      return reinterpret_cast<_Tp*>\n+ (&const_cast<char&>(reinterpret_cast<const volatile char&>(__r)));\n+    }\n+}\n+\n+namespace std __attribute__ ((__visibility__ (\"default\"))) {\n+  template<class _T1, class _T2>\n+    struct pair\n+    {\n+      typedef _T1 first_type;\n+      typedef _T2 second_type;\n+\n+      _T1 first;\n+      _T2 second;\n+\n+      pair()\n+      : first(), second() { }\n+\n+      pair(const _T1& __a, const _T2& __b)\n+      : first(__a), second(__b) { }\n+    };\n+}\n+\n+namespace std __attribute__ ((__visibility__ (\"default\"))) {\n+  struct input_iterator_tag { };\n+\n+  struct output_iterator_tag { };\n+\n+  struct forward_iterator_tag : public input_iterator_tag { };\n+\n+  struct bidirectional_iterator_tag : public forward_iterator_tag { };\n+\n+  struct random_access_iterator_tag : public bidirectional_iterator_tag { };\n+  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,\n+           typename _Pointer = _Tp*, typename _Reference = _Tp&>\n+    struct iterator\n+    {\n+      typedef _Category iterator_category;\n+      typedef _Tp value_type;\n+      typedef _Distance difference_type;\n+      typedef _Pointer pointer;\n+      typedef _Reference reference;\n+    };\n+\n+  template<typename _Iterator>\n+    struct iterator_traits\n+    {\n+      typedef typename _Iterator::iterator_category iterator_category;\n+      typedef typename _Iterator::value_type value_type;\n+      typedef typename _Iterator::difference_type difference_type;\n+      typedef typename _Iterator::pointer pointer;\n+      typedef typename _Iterator::reference reference;\n+    };\n+}\n+\n+namespace std __attribute__ ((__visibility__ (\"default\"))) {\n+  template<typename _Iterator>\n+    class reverse_iterator\n+    : public iterator<typename iterator_traits<_Iterator>::iterator_category,\n+        typename iterator_traits<_Iterator>::value_type,\n+        typename iterator_traits<_Iterator>::difference_type,\n+        typename iterator_traits<_Iterator>::pointer,\n+                      typename iterator_traits<_Iterator>::reference>\n+    {\n+    protected:\n+      _Iterator current;\n+      typedef iterator_traits<_Iterator> __traits_type;\n+    };\n+}\n+\n+struct _IO_FILE;\n+\n+typedef struct _IO_FILE FILE;\n+\n+typedef struct _IO_FILE __FILE;\n+\n+typedef __builtin_va_list __gnuc_va_list;\n+\n+typedef unsigned int size_t;\n+typedef unsigned int wint_t;\n+\n+typedef struct\n+{\n+  int __count;\n+  union\n+  {\n+    unsigned int __wch;\n+    char __wchb[4];\n+  } __value;\n+} __mbstate_t;\n+\n+\n+typedef __mbstate_t mbstate_t;\n+\n+namespace std __attribute__ ((__visibility__ (\"default\"))) {\n+  using ::mbstate_t;\n+}\n+\n+namespace std __attribute__ ((__visibility__ (\"default\"))) {\n+  typedef long long streamoff;\n+\n+  typedef ptrdiff_t streamsize;\n+  template<typename _StateT>\n+    class fpos\n+    {\n+    private:\n+      streamoff _M_off;\n+      _StateT _M_state;\n+\n+    public:\n+\n+      fpos()\n+      : _M_off(0), _M_state() { }\n+      fpos(streamoff __off)\n+      : _M_off(__off), _M_state() { }\n+\n+      operator streamoff() const { return _M_off; }\n+\n+    };\n+\n+  typedef fpos<mbstate_t> streampos;\n+\n+  typedef fpos<mbstate_t> wstreampos;\n+}\n+\n+namespace __gnu_cxx __attribute__ ((__visibility__ (\"default\"))) {\n+  template<typename _CharT>\n+    struct _Char_types\n+    {\n+      typedef unsigned long int_type;\n+      typedef std::streampos pos_type;\n+      typedef std::streamoff off_type;\n+      typedef std::mbstate_t state_type;\n+    };\n+  template<typename _CharT>\n+    struct char_traits\n+    {\n+      typedef _CharT char_type;\n+      typedef typename _Char_types<_CharT>::int_type int_type;\n+      typedef typename _Char_types<_CharT>::pos_type pos_type;\n+      typedef typename _Char_types<_CharT>::off_type off_type;\n+      typedef typename _Char_types<_CharT>::state_type state_type;\n+\n+      static const char_type*\n+      find(const char_type* __s, std::size_t __n, const char_type& __a);\n+    };\n+}\n+\n+namespace std __attribute__ ((__visibility__ (\"default\"))) {\n+  template<class _CharT>\n+    struct char_traits : public __gnu_cxx::char_traits<_CharT>\n+    { };\n+\n+  template<>\n+    struct char_traits<char>\n+    {\n+      typedef char char_type;\n+      typedef int int_type;\n+      typedef streampos pos_type;\n+      typedef streamoff off_type;\n+      typedef mbstate_t state_type;\n+\n+      static const char_type*\n+      find(const char_type* __s, size_t __n, const char_type& __a)\n+      { return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n)); }\n+  };\n+}\n+\n+namespace __gnu_cxx __attribute__ ((__visibility__ (\"default\"))) {\n+\n+  using std::size_t;\n+  using std::ptrdiff_t;\n+  template<typename _Tp>\n+    class new_allocator\n+    {\n+    public:\n+      typedef size_t size_type;\n+      typedef ptrdiff_t difference_type;\n+      typedef _Tp* pointer;\n+      typedef const _Tp* const_pointer;\n+      typedef _Tp& reference;\n+      typedef const _Tp& const_reference;\n+      typedef _Tp value_type;\n+\n+      new_allocator() throw() { }\n+\n+      new_allocator(const new_allocator&) throw() { }\n+\n+      template<typename _Tp1>\n+        new_allocator(const new_allocator<_Tp1>&) throw() { }\n+\n+      ~new_allocator() throw() { }\n+\n+      pointer\n+      allocate(size_type __n, const void* = 0)\n+      {\n+ if (__n > this->max_size())\n+   std::__throw_bad_alloc();\n+\n+ return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));\n+      }\n+      void\n+      deallocate(pointer __p, size_type)\n+      { ::operator delete(__p); }\n+\n+      void\n+      destroy(pointer __p) { __p->~_Tp(); }\n+    };\n+}\n+\n+namespace std __attribute__ ((__visibility__ (\"default\"))) {\n+  template<typename _Tp>\n+    class allocator;\n+\n+  template<typename _Tp>\n+    class allocator: public __gnu_cxx::new_allocator<_Tp>\n+    {\n+   public:\n+      typedef size_t size_type;\n+      typedef ptrdiff_t difference_type;\n+      typedef _Tp* pointer;\n+      typedef const _Tp* const_pointer;\n+      typedef _Tp& reference;\n+      typedef const _Tp& const_reference;\n+      typedef _Tp value_type;\n+\n+      template<typename _Tp1>\n+        struct rebind\n+        { typedef allocator<_Tp1> other; };\n+\n+      allocator() throw() { }\n+\n+      allocator(const allocator& __a) throw()\n+      : __gnu_cxx::new_allocator<_Tp>(__a) { }\n+\n+      template<typename _Tp1>\n+        allocator(const allocator<_Tp1>&) throw() { }\n+\n+      ~allocator() throw() { }\n+    };\n+}\n+\n+namespace std __attribute__ ((__visibility__ (\"default\"))) {\n+  template<typename _Arg, typename _Result>\n+    struct unary_function\n+    {\n+      typedef _Arg argument_type;\n+      typedef _Result result_type;\n+    };\n+\n+  template<typename _Arg1, typename _Arg2, typename _Result>\n+    struct binary_function\n+    {\n+      typedef _Arg1 first_argument_type;\n+      typedef _Arg2 second_argument_type;\n+      typedef _Result result_type;\n+    };\n+\n+  template<typename _Tp>\n+    struct less : public binary_function<_Tp, _Tp, bool>\n+    {\n+      bool\n+      operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x < __y; }\n+    };\n+\n+  template<typename _Pair>\n+    struct _Select1st : public unary_function<_Pair,\n+           typename _Pair::first_type>\n+    {\n+      typename _Pair::first_type&\n+      operator()(_Pair& __x) const\n+      { return __x.first; }\n+\n+      const typename _Pair::first_type&\n+      operator()(const _Pair& __x) const\n+      { return __x.first; }\n+    };\n+}\n+\n+extern \"C\" {\n+\n+typedef int __sig_atomic_t;\n+\n+typedef struct\n+  {\n+    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];\n+  } __sigset_t;\n+typedef __sigset_t sigset_t;\n+}\n+typedef unsigned long int pthread_t;\n+\n+typedef struct __pthread_internal_slist\n+{\n+  struct __pthread_internal_slist *__next;\n+} __pthread_slist_t;\n+\n+typedef union\n+{\n+  struct __pthread_mutex_s\n+  {\n+    int __lock;\n+    unsigned int __count;\n+    int __owner;\n+    int __kind;\n+\n+    unsigned int __nusers;\n+    __extension__ union\n+    {\n+      int __spins;\n+      __pthread_slist_t __list;\n+    };\n+\n+  } __data;\n+  char __size[24];\n+  long int __align;\n+} pthread_mutex_t;\n+\n+typedef unsigned int pthread_key_t;\n+\n+typedef int pthread_once_t;\n+\n+extern int pthread_once (pthread_once_t *__once_control,\n+    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));\n+\n+extern int pthread_mutex_lock (pthread_mutex_t *__mutex)\n+     throw () __attribute__ ((__nonnull__ (1)));\n+\n+extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)\n+     throw () __attribute__ ((__nonnull__ (1)));\n+\n+typedef pthread_t __gthread_t;\n+typedef pthread_key_t __gthread_key_t;\n+typedef pthread_once_t __gthread_once_t;\n+typedef pthread_mutex_t __gthread_mutex_t;\n+\n+static __typeof(pthread_once) __gthrw_pthread_once __attribute__ ((__weakref__(\"pthread_once\")));\n+\n+static __typeof(pthread_mutex_lock) __gthrw_pthread_mutex_lock __attribute__ ((__weakref__(\"pthread_mutex_lock\")));\n+\n+static __typeof(pthread_mutex_unlock) __gthrw_pthread_mutex_unlock __attribute__ ((__weakref__(\"pthread_mutex_unlock\")));\n+\n+static volatile int __gthread_active = -1;\n+\n+static void\n+__gthread_trigger (void)\n+{\n+  __gthread_active = 1;\n+}\n+\n+static inline int\n+__gthread_active_p (void)\n+{\n+  static pthread_mutex_t __gthread_active_mutex = { { 0, 0, 0, 0, 0, { 0 } } };\n+  static pthread_once_t __gthread_active_once = 0;\n+\n+  int __gthread_active_latest_value = __gthread_active;\n+\n+  if (__builtin_expect (__gthread_active_latest_value < 0, 0))\n+    {\n+      if (__gthrw_pthread_once)\n+ {\n+   __gthrw_pthread_mutex_lock (&__gthread_active_mutex);\n+   __gthrw_pthread_once (&__gthread_active_once, __gthread_trigger);\n+   __gthrw_pthread_mutex_unlock (&__gthread_active_mutex);\n+ }\n+\n+      if (__gthread_active < 0)\n+ __gthread_active = 0;\n+      __gthread_active_latest_value = __gthread_active;\n+    }\n+\n+  return __gthread_active_latest_value != 0;\n+}\n+\n+typedef int _Atomic_word;\n+\n+namespace __gnu_cxx __attribute__ ((__visibility__ (\"default\"))) {\n+\n+  static inline _Atomic_word\n+  __exchange_and_add(volatile _Atomic_word* __mem, int __val)\n+  { return __sync_fetch_and_add(__mem, __val); }\n+\n+  static inline void\n+  __atomic_add(volatile _Atomic_word* __mem, int __val)\n+  { __sync_fetch_and_add(__mem, __val); }\n+  static inline _Atomic_word\n+  __exchange_and_add_single(_Atomic_word* __mem, int __val)\n+  {\n+    _Atomic_word __result = *__mem;\n+    *__mem += __val;\n+    return __result;\n+  }\n+\n+  static inline void\n+  __atomic_add_single(_Atomic_word* __mem, int __val)\n+  { *__mem += __val; }\n+\n+  static inline _Atomic_word\n+  __attribute__ ((__unused__))\n+  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)\n+  {\n+    if (__gthread_active_p())\n+      return __exchange_and_add(__mem, __val);\n+    else\n+      return __exchange_and_add_single(__mem, __val);\n+  }\n+\n+  static inline void\n+  __attribute__ ((__unused__))\n+  __atomic_add_dispatch(_Atomic_word* __mem, int __val)\n+  {\n+    if (__gthread_active_p())\n+      __atomic_add(__mem, __val);\n+    else\n+      __atomic_add_single(__mem, __val);\n+  }\n+}\n+\n+namespace std __attribute__ ((__visibility__ (\"default\"))) {\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    class basic_string\n+    {\n+      typedef typename _Alloc::template rebind<_CharT>::other _CharT_alloc_type;\n+\n+    public:\n+      typedef _Traits traits_type;\n+      typedef typename _Traits::char_type value_type;\n+      typedef _Alloc allocator_type;\n+      typedef typename _CharT_alloc_type::size_type size_type;\n+      typedef typename _CharT_alloc_type::difference_type difference_type;\n+      typedef typename _CharT_alloc_type::reference reference;\n+      typedef typename _CharT_alloc_type::const_reference const_reference;\n+      typedef typename _CharT_alloc_type::pointer pointer;\n+      typedef typename _CharT_alloc_type::const_pointer const_pointer;\n+      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;\n+      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>\n+                                                            const_iterator;\n+      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n+      typedef std::reverse_iterator<iterator> reverse_iterator;\n+\n+    private:\n+      struct _Rep_base\n+      {\n+ size_type _M_length;\n+ size_type _M_capacity;\n+ _Atomic_word _M_refcount;\n+      };\n+\n+      struct _Rep : _Rep_base\n+      {\n+\n+ typedef typename _Alloc::template rebind<char>::other _Raw_bytes_alloc;\n+ static const size_type _S_max_size;\n+ static const _CharT _S_terminal;\n+\n+        static size_type _S_empty_rep_storage[];\n+\n+        static _Rep&\n+        _S_empty_rep()\n+        {\n+   void* __p = reinterpret_cast<void*>(&_S_empty_rep_storage);\n+   return *reinterpret_cast<_Rep*>(__p);\n+ }\n+\n+ _CharT*\n+ _M_refdata() throw()\n+ { return reinterpret_cast<_CharT*>(this + 1); }\n+\n+ void\n+ _M_dispose(const _Alloc& __a)\n+ {\n+   if (__builtin_expect(this != &_S_empty_rep(), false))\n+     {\n+       ;\n+       if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,\n+        -1) <= 0)\n+  {\n+    ;\n+    _M_destroy(__a);\n+  }\n+     }\n+ }\n+\n+ void\n+ _M_destroy(const _Alloc&) throw();\n+\n+ _CharT*\n+ _M_refcopy() throw()\n+ {\n+   if (__builtin_expect(this != &_S_empty_rep(), false))\n+            __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);\n+   return _M_refdata();\n+ }\n+      };\n+\n+      struct _Alloc_hider : _Alloc\n+      {\n+ _Alloc_hider(_CharT* __dat, const _Alloc& __a)\n+ : _Alloc(__a), _M_p(__dat) { }\n+\n+ _CharT* _M_p;\n+      };\n+\n+    private:\n+\n+      mutable _Alloc_hider _M_dataplus;\n+\n+      _CharT*\n+      _M_data() const\n+      { return _M_dataplus._M_p; }\n+\n+      _Rep*\n+      _M_rep() const\n+      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }\n+\n+      void\n+      _M_leak_hard();\n+\n+    public:\n+\n+      ~basic_string()\n+      { _M_rep()->_M_dispose(this->get_allocator()); }\n+\n+    public:\n+\n+      allocator_type\n+      get_allocator() const\n+      { return _M_dataplus; }\n+  };\n+}\n+\n+namespace std __attribute__ ((__visibility__ (\"default\"))) {\n+  enum _Rb_tree_color { _S_red = false, _S_black = true };\n+\n+  struct _Rb_tree_node_base\n+  {\n+    typedef _Rb_tree_node_base* _Base_ptr;\n+    typedef const _Rb_tree_node_base* _Const_Base_ptr;\n+\n+    _Rb_tree_color _M_color;\n+    _Base_ptr _M_parent;\n+    _Base_ptr _M_left;\n+    _Base_ptr _M_right;\n+\n+    static _Base_ptr\n+    _S_minimum(_Base_ptr __x)\n+    {\n+      while (__x->_M_left != 0) __x = __x->_M_left;\n+      return __x;\n+    }\n+\n+    static _Const_Base_ptr\n+    _S_minimum(_Const_Base_ptr __x)\n+    {\n+      while (__x->_M_left != 0) __x = __x->_M_left;\n+      return __x;\n+    }\n+\n+    static _Base_ptr\n+    _S_maximum(_Base_ptr __x)\n+    {\n+      while (__x->_M_right != 0) __x = __x->_M_right;\n+      return __x;\n+    }\n+\n+    static _Const_Base_ptr\n+    _S_maximum(_Const_Base_ptr __x)\n+    {\n+      while (__x->_M_right != 0) __x = __x->_M_right;\n+      return __x;\n+    }\n+  };\n+\n+  template<typename _Val>\n+    struct _Rb_tree_node : public _Rb_tree_node_base\n+    {\n+      typedef _Rb_tree_node<_Val>* _Link_type;\n+      _Val _M_value_field;\n+    };\n+\n+  __attribute__ ((__pure__)) _Rb_tree_node_base*\n+  _Rb_tree_increment(_Rb_tree_node_base* __x) throw ();\n+\n+  __attribute__ ((__pure__)) const _Rb_tree_node_base*\n+  _Rb_tree_increment(const _Rb_tree_node_base* __x) throw ();\n+\n+  __attribute__ ((__pure__)) _Rb_tree_node_base*\n+  _Rb_tree_decrement(_Rb_tree_node_base* __x) throw ();\n+\n+  __attribute__ ((__pure__)) const _Rb_tree_node_base*\n+  _Rb_tree_decrement(const _Rb_tree_node_base* __x) throw ();\n+\n+  template<typename _Tp>\n+    struct _Rb_tree_iterator\n+    {\n+      typedef _Tp value_type;\n+      typedef _Tp& reference;\n+      typedef _Tp* pointer;\n+\n+      typedef bidirectional_iterator_tag iterator_category;\n+      typedef ptrdiff_t difference_type;\n+\n+      typedef _Rb_tree_iterator<_Tp> _Self;\n+      typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;\n+      typedef _Rb_tree_node<_Tp>* _Link_type;\n+\n+      _Rb_tree_iterator()\n+      : _M_node() { }\n+\n+      explicit\n+      _Rb_tree_iterator(_Link_type __x)\n+      : _M_node(__x) { }\n+\n+      bool\n+      operator==(const _Self& __x) const\n+      { return _M_node == __x._M_node; }\n+\n+      bool\n+      operator!=(const _Self& __x) const\n+      { return _M_node != __x._M_node; }\n+\n+      _Base_ptr _M_node;\n+  };\n+\n+  template<typename _Tp>\n+    struct _Rb_tree_const_iterator\n+    {\n+      typedef _Tp value_type;\n+      typedef const _Tp& reference;\n+      typedef const _Tp* pointer;\n+\n+      typedef _Rb_tree_iterator<_Tp> iterator;\n+\n+      typedef bidirectional_iterator_tag iterator_category;\n+      typedef ptrdiff_t difference_type;\n+\n+      typedef _Rb_tree_const_iterator<_Tp> _Self;\n+      typedef _Rb_tree_node_base::_Const_Base_ptr _Base_ptr;\n+      typedef const _Rb_tree_node<_Tp>* _Link_type;\n+\n+      _Rb_tree_const_iterator()\n+      : _M_node() { }\n+\n+      explicit\n+      _Rb_tree_const_iterator(_Link_type __x)\n+      : _M_node(__x) { }\n+\n+      _Rb_tree_const_iterator(const iterator& __it)\n+      : _M_node(__it._M_node) { }\n+\n+      pointer\n+      operator->() const\n+      { return std::__addressof(static_cast<_Link_type>\n+    (_M_node)->_M_value_field); }\n+\n+      bool\n+      operator==(const _Self& __x) const\n+      { return _M_node == __x._M_node; }\n+\n+      bool\n+      operator!=(const _Self& __x) const\n+      { return _M_node != __x._M_node; }\n+\n+      _Base_ptr _M_node;\n+    };\n+\n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n+           typename _Compare, typename _Alloc = allocator<_Val> >\n+    class _Rb_tree\n+    {\n+      typedef typename _Alloc::template rebind<_Rb_tree_node<_Val> >::other\n+              _Node_allocator;\n+\n+    protected:\n+      typedef _Rb_tree_node_base* _Base_ptr;\n+      typedef const _Rb_tree_node_base* _Const_Base_ptr;\n+\n+    public:\n+      typedef _Key key_type;\n+      typedef _Val value_type;\n+      typedef value_type* pointer;\n+      typedef const value_type* const_pointer;\n+      typedef value_type& reference;\n+      typedef const value_type& const_reference;\n+      typedef _Rb_tree_node<_Val>* _Link_type;\n+      typedef const _Rb_tree_node<_Val>* _Const_Link_type;\n+      typedef size_t size_type;\n+      typedef ptrdiff_t difference_type;\n+      typedef _Alloc allocator_type;\n+\n+      const _Node_allocator&\n+      _M_get_Node_allocator() const\n+      { return *static_cast<const _Node_allocator*>(&this->_M_impl); }\n+\n+      allocator_type\n+      get_allocator() const\n+      { return allocator_type(_M_get_Node_allocator()); }\n+\n+    protected:\n+      void\n+      _M_put_node(_Link_type __p)\n+      { _M_impl._Node_allocator::deallocate(__p, 1); }\n+\n+      void\n+      _M_destroy_node(_Link_type __p)\n+      {\n+ get_allocator().destroy(std::__addressof(__p->_M_value_field));\n+ _M_put_node(__p);\n+      }\n+\n+    protected:\n+      template<typename _Key_compare,\n+        bool _Is_pod_comparator = __is_pod(_Key_compare)>\n+        struct _Rb_tree_impl : public _Node_allocator\n+        {\n+   _Key_compare _M_key_compare;\n+   _Rb_tree_node_base _M_header;\n+   size_type _M_node_count;\n+\n+ private:\n+   void\n+   _M_initialize()\n+   {\n+     this->_M_header._M_color = _S_red;\n+     this->_M_header._M_parent = 0;\n+     this->_M_header._M_left = &this->_M_header;\n+     this->_M_header._M_right = &this->_M_header;\n+   }\n+ };\n+\n+      _Rb_tree_impl<_Compare> _M_impl;\n+\n+    protected:\n+\n+      _Link_type\n+      _M_begin()\n+      { return static_cast<_Link_type>(this->_M_impl._M_header._M_parent); }\n+\n+      _Link_type\n+      _M_end()\n+      { return static_cast<_Link_type>(&this->_M_impl._M_header); }\n+\n+      static _Link_type\n+      _S_left(_Base_ptr __x)\n+      { return static_cast<_Link_type>(__x->_M_left); }\n+\n+      static _Link_type\n+      _S_right(_Base_ptr __x)\n+      { return static_cast<_Link_type>(__x->_M_right); }\n+\n+      static const_reference\n+      _S_value(_Const_Base_ptr __x)\n+      { return static_cast<_Const_Link_type>(__x)->_M_value_field; }\n+\n+      static const _Key&\n+      _S_key(_Const_Base_ptr __x)\n+      { return _KeyOfValue()(_S_value(__x)); }\n+\n+    public:\n+      typedef _Rb_tree_iterator<value_type> iterator;\n+      typedef _Rb_tree_const_iterator<value_type> const_iterator;\n+\n+    private:\n+\n+      void\n+      _M_erase(_Link_type __x);\n+\n+      iterator\n+      _M_lower_bound(_Link_type __x, _Link_type __y,\n+       const _Key& __k);\n+\n+      const_iterator\n+      _M_lower_bound(_Const_Link_type __x, _Const_Link_type __y,\n+       const _Key& __k) const;\n+\n+    public:\n+\n+      ~_Rb_tree()\n+      { _M_erase(_M_begin()); }\n+\n+      iterator\n+      end()\n+      { return iterator(static_cast<_Link_type>(&this->_M_impl._M_header)); }\n+\n+      const_iterator\n+      end() const\n+      {\n+         return const_iterator(static_cast<_Const_Link_type>\n+         (&this->_M_impl._M_header));\n+      }\n+\n+    public:\n+      iterator\n+      find(const key_type& __k);\n+    };\n+\n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n+           typename _Compare, typename _Alloc>\n+    void\n+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+    _M_erase(_Link_type __x)\n+    {\n+\n+      while (__x != 0)\n+ {\n+   _M_erase(_S_right(__x));\n+   _Link_type __y = _S_left(__x);\n+   _M_destroy_node(__x);\n+   __x = __y;\n+ }\n+    }\n+\n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n+           typename _Compare, typename _Alloc>\n+    typename _Rb_tree<_Key, _Val, _KeyOfValue,\n+        _Compare, _Alloc>::iterator\n+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+    _M_lower_bound(_Link_type __x, _Link_type __y,\n+     const _Key& __k)\n+    {\n+      while (__x != 0)\n+ if (!_M_impl._M_key_compare(_S_key(__x), __k))\n+   __y = __x, __x = _S_left(__x);\n+ else\n+   __x = _S_right(__x);\n+      return iterator(__y);\n+    }\n+\n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n+           typename _Compare, typename _Alloc>\n+    typename _Rb_tree<_Key, _Val, _KeyOfValue,\n+        _Compare, _Alloc>::iterator\n+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+    find(const _Key& __k)\n+    {\n+      iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);\n+      return (__j == end()\n+       || _M_impl._M_key_compare(__k,\n+     _S_key(__j._M_node))) ? end() : __j;\n+    }\n+\n+}\n+\n+namespace std {\n+  template <typename _Key, typename _Tp, typename _Compare = std::less<_Key>,\n+            typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >\n+    class map\n+    {\n+    public:\n+      typedef _Key key_type;\n+      typedef _Tp mapped_type;\n+      typedef std::pair<const _Key, _Tp> value_type;\n+      typedef _Compare key_compare;\n+      typedef _Alloc allocator_type;\n+\n+    private:\n+\n+      typedef typename _Alloc::template rebind<value_type>::other\n+        _Pair_alloc_type;\n+\n+      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,\n+         key_compare, _Pair_alloc_type> _Rep_type;\n+\n+      _Rep_type _M_t;\n+\n+    public:\n+\n+      typedef typename _Rep_type::iterator iterator;\n+      typedef typename _Rep_type::const_iterator const_iterator;\n+\n+      map()\n+      : _M_t() { }\n+\n+      const_iterator\n+      end() const\n+      { return _M_t.end(); }\n+\n+      key_compare\n+      key_comp() const\n+      { return _M_t.key_comp(); }\n+\n+      iterator\n+      find(const key_type& __x)\n+      { return _M_t.find(__x); }\n+    };\n+}\n+\n+int main ()\n+{\n+  typedef std::map<int, std::string> Map;\n+  static Map m;\n+\n+  Map::const_iterator it = m.find(0);\n+  if (it != m.end())\n+    std::string s = it->second;\n+\n+  return 0;\n+}\n+"}]}