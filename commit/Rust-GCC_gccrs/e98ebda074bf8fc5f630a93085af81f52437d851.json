{"sha": "e98ebda074bf8fc5f630a93085af81f52437d851", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTk4ZWJkYTA3NGJmOGZjNWY2MzBhOTMwODVhZjgxZjUyNDM3ZDg1MQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-01-31T05:21:44Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-01-31T23:19:31Z"}, "message": "c++: Reduce memory consumption for arrays of non-aggregate type.\n\nThe remaining low-hanging fruit for improvement on memory consumption in the\n14179 testcase was the duplication of the CONSTRUCTOR for the array by\nreshape_init.  This patch changes reshape_init to reuse a single constructor\nfor an array of non-aggregate type such as the one in the testcase.\n\n\tPR c++/14179\n\t* decl.c (reshape_init_array_1): Reuse a single CONSTRUCTOR with\n\tnon-aggregate elements.\n\t(reshape_init_array): Add first_initializer_p parm.\n\t(reshape_init_r): Change first_initializer_p from bool to tree.\n\t(reshape_init): Pass init to it.", "tree": {"sha": "bbe89785ff32257304ced90495373a2c64c1bdca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bbe89785ff32257304ced90495373a2c64c1bdca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e98ebda074bf8fc5f630a93085af81f52437d851", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e98ebda074bf8fc5f630a93085af81f52437d851", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e98ebda074bf8fc5f630a93085af81f52437d851", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e98ebda074bf8fc5f630a93085af81f52437d851/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d2b9548f38c77edc29ab0e24e516f1fb341ecea7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2b9548f38c77edc29ab0e24e516f1fb341ecea7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2b9548f38c77edc29ab0e24e516f1fb341ecea7"}], "stats": {"total": 57, "additions": 41, "deletions": 16}, "files": [{"sha": "cae1c918d304f4a9e34b32680df7b8641fc5ba4a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e98ebda074bf8fc5f630a93085af81f52437d851/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e98ebda074bf8fc5f630a93085af81f52437d851/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e98ebda074bf8fc5f630a93085af81f52437d851", "patch": "@@ -1,5 +1,12 @@\n 2020-01-31  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/14179\n+\t* decl.c (reshape_init_array_1): Reuse a single CONSTRUCTOR with\n+\tnon-aggregate elements.\n+\t(reshape_init_array): Add first_initializer_p parm.\n+\t(reshape_init_r): Change first_initializer_p from bool to tree.\n+\t(reshape_init): Pass init to it.\n+\n \tPR c++/14179\n \t* parser.c (cp_parser_initializer_list): Suppress location wrappers\n \tafter 256 elements."}, {"sha": "ef34f436fdff65bf1337714307677cc05fcd8c95", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 34, "deletions": 16, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e98ebda074bf8fc5f630a93085af81f52437d851/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e98ebda074bf8fc5f630a93085af81f52437d851/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=e98ebda074bf8fc5f630a93085af81f52437d851", "patch": "@@ -5931,7 +5931,7 @@ struct reshape_iter\n   constructor_elt *end;\n };\n \n-static tree reshape_init_r (tree, reshape_iter *, bool, tsubst_flags_t);\n+static tree reshape_init_r (tree, reshape_iter *, tree, tsubst_flags_t);\n \n /* FIELD is a FIELD_DECL or NULL.  In the former case, the value\n    returned is the next FIELD_DECL (possibly FIELD itself) that can be\n@@ -5979,15 +5979,21 @@ is_direct_enum_init (tree type, tree init)\n \n static tree\n reshape_init_array_1 (tree elt_type, tree max_index, reshape_iter *d,\n-\t\t      tsubst_flags_t complain)\n+\t\t      tree first_initializer_p, tsubst_flags_t complain)\n {\n   tree new_init;\n   bool sized_array_p = (max_index && TREE_CONSTANT (max_index));\n   unsigned HOST_WIDE_INT max_index_cst = 0;\n   unsigned HOST_WIDE_INT index;\n \n-  /* The initializer for an array is always a CONSTRUCTOR.  */\n-  new_init = build_constructor (init_list_type_node, NULL);\n+  /* The initializer for an array is always a CONSTRUCTOR.  If this is the\n+     outermost CONSTRUCTOR and the element type is non-aggregate, we don't need\n+     to build a new one.  */\n+  bool reuse = first_initializer_p && !CP_AGGREGATE_TYPE_P (elt_type);\n+  if (reuse)\n+    new_init = first_initializer_p;\n+  else\n+    new_init = build_constructor (init_list_type_node, NULL);\n \n   if (sized_array_p)\n     {\n@@ -6014,12 +6020,20 @@ reshape_init_array_1 (tree elt_type, tree max_index, reshape_iter *d,\n       constructor_elt *old_cur = d->cur;\n \n       check_array_designated_initializer (d->cur, index);\n-      elt_init = reshape_init_r (elt_type, d, /*first_initializer_p=*/false,\n+      elt_init = reshape_init_r (elt_type, d,\n+\t\t\t\t /*first_initializer_p=*/NULL_TREE,\n \t\t\t\t complain);\n       if (elt_init == error_mark_node)\n \treturn error_mark_node;\n-      CONSTRUCTOR_APPEND_ELT (CONSTRUCTOR_ELTS (new_init),\n-\t\t\t      size_int (index), elt_init);\n+      tree idx = size_int (index);\n+      if (reuse)\n+\t{\n+\t  old_cur->index = idx;\n+\t  old_cur->value = elt_init;\n+\t}\n+      else\n+\tCONSTRUCTOR_APPEND_ELT (CONSTRUCTOR_ELTS (new_init),\n+\t\t\t\tidx, elt_init);\n       if (!TREE_CONSTANT (elt_init))\n \tTREE_CONSTANT (new_init) = false;\n \n@@ -6056,7 +6070,8 @@ reshape_init_array_1 (tree elt_type, tree max_index, reshape_iter *d,\n    Parameters are the same of reshape_init_r.  */\n \n static tree\n-reshape_init_array (tree type, reshape_iter *d, tsubst_flags_t complain)\n+reshape_init_array (tree type, reshape_iter *d, tree first_initializer_p,\n+\t\t    tsubst_flags_t complain)\n {\n   tree max_index = NULL_TREE;\n \n@@ -6065,7 +6080,8 @@ reshape_init_array (tree type, reshape_iter *d, tsubst_flags_t complain)\n   if (TYPE_DOMAIN (type))\n     max_index = array_type_nelts (type);\n \n-  return reshape_init_array_1 (TREE_TYPE (type), max_index, d, complain);\n+  return reshape_init_array_1 (TREE_TYPE (type), max_index, d,\n+\t\t\t       first_initializer_p, complain);\n }\n \n /* Subroutine of reshape_init_r, processes the initializers for vectors.\n@@ -6096,7 +6112,8 @@ reshape_init_vector (tree type, reshape_iter *d, tsubst_flags_t complain)\n   if (VECTOR_TYPE_P (type))\n     max_index = size_int (TYPE_VECTOR_SUBPARTS (type) - 1);\n \n-  return reshape_init_array_1 (TREE_TYPE (type), max_index, d, complain);\n+  return reshape_init_array_1 (TREE_TYPE (type), max_index, d,\n+\t\t\t       NULL_TREE, complain);\n }\n \n /* Subroutine of reshape_init_r, processes the initializers for classes\n@@ -6179,7 +6196,8 @@ reshape_init_class (tree type, reshape_iter *d, bool first_initializer_p,\n \tbreak;\n \n       field_init = reshape_init_r (TREE_TYPE (field), d,\n-\t\t\t\t   /*first_initializer_p=*/false, complain);\n+\t\t\t\t   /*first_initializer_p=*/NULL_TREE,\n+\t\t\t\t   complain);\n       if (field_init == error_mark_node)\n \treturn error_mark_node;\n \n@@ -6230,11 +6248,11 @@ has_designator_problem (reshape_iter *d, tsubst_flags_t complain)\n /* Subroutine of reshape_init, which processes a single initializer (part of\n    a CONSTRUCTOR). TYPE is the type of the variable being initialized, D is the\n    iterator within the CONSTRUCTOR which points to the initializer to process.\n-   FIRST_INITIALIZER_P is true if this is the first initializer of the\n-   outermost CONSTRUCTOR node.  */\n+   If this is the first initializer of the outermost CONSTRUCTOR node,\n+   FIRST_INITIALIZER_P is that CONSTRUCTOR; otherwise, it is NULL_TREE.  */\n \n static tree\n-reshape_init_r (tree type, reshape_iter *d, bool first_initializer_p,\n+reshape_init_r (tree type, reshape_iter *d, tree first_initializer_p,\n \t\ttsubst_flags_t complain)\n {\n   tree init = d->cur->value;\n@@ -6431,7 +6449,7 @@ reshape_init_r (tree type, reshape_iter *d, bool first_initializer_p,\n   if (CLASS_TYPE_P (type))\n     return reshape_init_class (type, d, first_initializer_p, complain);\n   else if (TREE_CODE (type) == ARRAY_TYPE)\n-    return reshape_init_array (type, d, complain);\n+    return reshape_init_array (type, d, first_initializer_p, complain);\n   else if (VECTOR_TYPE_P (type))\n     return reshape_init_vector (type, d, complain);\n   else\n@@ -6495,7 +6513,7 @@ reshape_init (tree type, tree init, tsubst_flags_t complain)\n   d.cur = &(*v)[0];\n   d.end = d.cur + v->length ();\n \n-  new_init = reshape_init_r (type, &d, true, complain);\n+  new_init = reshape_init_r (type, &d, init, complain);\n   if (new_init == error_mark_node)\n     return error_mark_node;\n "}]}