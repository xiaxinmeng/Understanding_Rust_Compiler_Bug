{"sha": "194c7c45b14098d8ed488e57d9d37e3b290ee4cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTk0YzdjNDViMTQwOThkOGVkNDg4ZTU3ZDlkMzdlM2IyOTBlZTRjZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-03-25T01:06:35Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-03-25T01:06:35Z"}, "message": "tree.c (lang_safe_for_unsave): Remove.\n\n        * tree.c (lang_safe_for_unsave): Remove.\n        (unsafe_for_reeval): Transmute and rename from safe_for_unsave,\n        allowing for two levels of unsafeness.  Remove lang hook.\n        * tree.h: Update declarations.\n        * calls.c (expand_call): Rename safe_for_reeval to try_tail_call.\n        Create temporary VAR_DECLs to protect very unsafe_for_reeval trees.\n        Always fail sibcalls when there are pending cleanups.\n\nFrom-SVN: r32735", "tree": {"sha": "9ebdd42ff7f81a59b06dea0e7f79c96c34249f4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ebdd42ff7f81a59b06dea0e7f79c96c34249f4b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/194c7c45b14098d8ed488e57d9d37e3b290ee4cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/194c7c45b14098d8ed488e57d9d37e3b290ee4cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/194c7c45b14098d8ed488e57d9d37e3b290ee4cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/194c7c45b14098d8ed488e57d9d37e3b290ee4cd/comments", "author": null, "committer": null, "parents": [{"sha": "1c33f70c9679c08daf29d6911240ff7b9da94ee0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c33f70c9679c08daf29d6911240ff7b9da94ee0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c33f70c9679c08daf29d6911240ff7b9da94ee0"}], "stats": {"total": 173, "additions": 112, "deletions": 61}, "files": [{"sha": "8ca4e958110c0a77804e6c13801ba366f1d454ef", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/194c7c45b14098d8ed488e57d9d37e3b290ee4cd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/194c7c45b14098d8ed488e57d9d37e3b290ee4cd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=194c7c45b14098d8ed488e57d9d37e3b290ee4cd", "patch": "@@ -1,3 +1,13 @@\n+2000-03-24  Richard Henderson  <rth@cygnus.com>\n+\n+\t* tree.c (lang_safe_for_unsave): Remove.\n+\t(unsafe_for_reeval): Transmute and rename from safe_for_unsave,\n+\tallowing for two levels of unsafeness.  Remove lang hook.\n+\t* tree.h: Update declarations.\n+\t* calls.c (expand_call): Rename safe_for_reeval to try_tail_call.\n+\tCreate temporary VAR_DECLs to protect very unsafe_for_reeval trees.\n+\tAlways fail sibcalls when there are pending cleanups.\n+\n 2000-03-24  Geoff Keating  <geoffk@cygnus.com>\n \n \t* flow.c (propagate_block): When we delete an ADDR_VEC,"}, {"sha": "ed4b31be4c3e31588e591ae609f24f2244ee240b", "filename": "gcc/calls.c", "status": "modified", "additions": 61, "deletions": 28, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/194c7c45b14098d8ed488e57d9d37e3b290ee4cd/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/194c7c45b14098d8ed488e57d9d37e3b290ee4cd/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=194c7c45b14098d8ed488e57d9d37e3b290ee4cd", "patch": "@@ -1696,7 +1696,7 @@ expand_call (exp, target, ignore)\n   rtx before_call;\n #endif\n   rtx insn;\n-  int safe_for_reeval;\n+  int try_tail_call;\n   int pass;\n \n   /* Register in which non-BLKmode value will be returned,\n@@ -2027,44 +2027,70 @@ expand_call (exp, target, ignore)\n \n   currently_expanding_call++;\n \n-  /* If we're considering tail recursion optimizations, verify that the\n-     arguments are safe for re-evaluation.  If we can unsave them, wrap\n-     each argument in an UNSAVE_EXPR.  */\n+  /* Tail calls can make things harder to debug, and we're traditionally\n+     pushed these optimizations into -O2.  Don't try if we're already\n+     expanding a call, as that means we're an argument.  Similarly, if\n+     there's pending loops or cleanups we know there's code to follow\n+     the call.  */\n \n-  safe_for_reeval = 0;\n+  try_tail_call = 0;\n   if (optimize >= 2\n       && currently_expanding_call == 1\n       && stmt_loop_nest_empty ()\n       && ! any_pending_cleanups (1))\n     {\n-      /* Verify that each argument is safe for re-evaluation.  */\n+      tree new_actparms = NULL_TREE;\n+\n+      /* Ok, we're going to give the tail call the old college try.\n+\t This means we're going to evaluate the function arguments\n+\t up to three times.  There are two degrees of badness we can\n+\t encounter, those that can be unsaved and those that can't.\n+\t (See unsafe_for_reeval commentary for details.)\n+\n+\t Generate a new argument list.  Pass safe arguments through\n+\t unchanged.  For the easy badness wrap them in UNSAVE_EXPRs.  \n+\t For hard badness, evaluate them now and put their resulting\n+\t rtx in a temporary VAR_DECL.  */\n+\n       for (p = actparms; p; p = TREE_CHAIN (p))\n-\tif (! safe_for_unsave (TREE_VALUE (p)))\n-\t  break;\n+\tswitch (unsafe_for_reeval (TREE_VALUE (p)))\n+\t  {\n+\t  case 0: /* Safe.  */\n+\t    new_actparms = tree_cons (TREE_PURPOSE (p), TREE_VALUE (p),\n+\t\t\t\t      new_actparms);\n+\t    break;\n \n-      if (p == NULL_TREE)\n-        {\n-\t  tree new_actparms = NULL_TREE, q;\n+\t  case 1: /* Mildly unsafe.  */\n+\t    new_actparms = tree_cons (TREE_PURPOSE (p),\n+\t\t\t\t      unsave_expr (TREE_VALUE (p)),\n+\t\t\t\t      new_actparms);\n+\t    break;\n \n-\t  for (p = actparms; p ; p = TREE_CHAIN (p))\n+\t  case 2: /* Wildly unsafe.  */\n \t    {\n-\t      tree np = build_tree_list (TREE_PURPOSE (p),\n-\t\t\t\t\t unsave_expr (TREE_VALUE (p)));\n-\t      if (new_actparms)\n-\t\tTREE_CHAIN (q) = np;\n-\t      else\n-\t\tnew_actparms = np;\n-\t      q = np;\n+\t      tree var = build_decl (VAR_DECL, NULL_TREE,\n+\t\t\t\t     TREE_TYPE (TREE_VALUE (p)));\n+\t      DECL_RTL (var) = expand_expr (TREE_VALUE (p), NULL_RTX,\n+\t\t\t\t\t    VOIDmode, EXPAND_NORMAL);\n+\t      new_actparms = tree_cons (TREE_PURPOSE (p), var, new_actparms);\n \t    }\n+\t    break;\n \n-\t  actparms = new_actparms;\n-\t  safe_for_reeval = 1;\n-\t}\n+\t  default:\n+\t    abort ();\n+\t  }\n+\n+      /* We built the new argument chain backwards.  */\n+      actparms = nreverse (new_actparms);\n+\n+      /* Expanding one of those dangerous arguments could have added\n+\t cleanups, but otherwise give it a whirl.  */\n+      try_tail_call = ! any_pending_cleanups (1);\n     }\n \n   /* Generate a tail recursion sequence when calling ourselves.  */\n \n-  if (safe_for_reeval\n+  if (try_tail_call\n       && TREE_CODE (TREE_OPERAND (exp, 0)) == ADDR_EXPR\n       && TREE_OPERAND (TREE_OPERAND (exp, 0), 0) == current_function_decl)\n     {\n@@ -2149,7 +2175,7 @@ expand_call (exp, target, ignore)\n       if (pass == 0)\n \t{\n \t  /* Various reasons we can not use a sibling call.  */\n-\t  if (! safe_for_reeval\n+\t  if (! try_tail_call \n #ifdef HAVE_sibcall_epilogue\n \t      || ! HAVE_sibcall_epilogue\n #else\n@@ -2163,6 +2189,10 @@ expand_call (exp, target, ignore)\n \t      /* If the register holding the address is a callee saved\n \t\t register, then we lose.  We have no way to prevent that,\n \t\t so we only allow calls to named functions.  */\n+\t      /* ??? This could be done by having the insn constraints\n+\t\t use a register class that is all call-clobbered.  Any\n+\t\t reload insns generated to fix things up would appear\n+\t\t before the sibcall_epilogue.  */\n \t      || fndecl == NULL_TREE\n \t      || ! FUNCTION_OK_FOR_SIBCALL (fndecl))\n \t    continue;\n@@ -2819,10 +2849,13 @@ expand_call (exp, target, ignore)\n \n       /* If there are cleanups to be called, don't use a hard reg as target.\n \t We need to double check this and see if it matters anymore.  */\n-      if (any_pending_cleanups (1)\n-\t  && target && REG_P (target)\n-\t  && REGNO (target) < FIRST_PSEUDO_REGISTER)\n-\ttarget = 0, sibcall_failure = 1;\n+      if (any_pending_cleanups (1))\n+\t{\n+\t  if (target && REG_P (target)\n+\t      && REGNO (target) < FIRST_PSEUDO_REGISTER)\n+\t    target = 0;\n+\t  sibcall_failure = 1;\n+\t}\n \n       if (TYPE_MODE (TREE_TYPE (exp)) == VOIDmode\n \t  || ignore)"}, {"sha": "51c8c3872e3c39f95b3cccd408e559b0dc04241f", "filename": "gcc/tree.c", "status": "modified", "additions": 37, "deletions": 27, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/194c7c45b14098d8ed488e57d9d37e3b290ee4cd/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/194c7c45b14098d8ed488e57d9d37e3b290ee4cd/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=194c7c45b14098d8ed488e57d9d37e3b290ee4cd", "patch": "@@ -290,9 +290,6 @@ static void print_type_hash_statistics PARAMS((void));\n void (*lang_unsave) PARAMS ((tree *));\n void (*lang_unsave_expr_now) PARAMS ((tree));\n \n-/* If non-null, a language specific version of safe_for_unsave. */\n-int (*lang_safe_for_unsave) PARAMS ((tree));\n-\n /* The string used as a placeholder instead of a source file name for\n    built-in tree nodes.  The variable, which is dynamically allocated,\n    should be used; the macro is only used to initialize it.  */\n@@ -2675,26 +2672,42 @@ unsave_expr_now (expr)\n   return expr;\n }\n \n-/* Return nonzero if it is safe to unsave EXPR, else return zero.\n-   It is not safe to unsave EXPR if it contains any embedded RTL_EXPRs.  */\n+/* Return 0 if it is safe to evaluate EXPR multiple times,\n+   return 1 if it is safe if EXPR is unsaved afterward, or\n+   return 2 if it is completely unsafe. \n+\n+   This assumes that CALL_EXPRs and TARGET_EXPRs are never replicated in\n+   an expression tree, so that it safe to unsave them and the surrounding\n+   context will be correct.\n+\n+   SAVE_EXPRs basically *only* appear replicated in an expression tree,\n+   occasionally across the whole of a function.  It is therefore only\n+   safe to unsave a SAVE_EXPR if you know that all occurrences appear\n+   below the UNSAVE_EXPR.\n+\n+   RTL_EXPRs consume their rtl during evaluation.  It is therefore \n+   never possible to unsave them.  */\n \n int\n-safe_for_unsave (expr)\n+unsafe_for_reeval (expr)\n      tree expr;\n {\n   enum tree_code code;\n-  register int i;\n+  register int i, tmp, unsafeness;\n   int first_rtl;\n \n   if (expr == NULL_TREE)\n     return 1;\n \n   code = TREE_CODE (expr);\n   first_rtl = first_rtl_op (code);\n+  unsafeness = 0;\n+\n   switch (code)\n     {\n+    case SAVE_EXPR:\n     case RTL_EXPR:\n-      return 0;\n+      return 2;\n \n     case CALL_EXPR:\n       if (TREE_OPERAND (expr, 1)\n@@ -2703,26 +2716,20 @@ safe_for_unsave (expr)\n \t  tree exp = TREE_OPERAND (expr, 1);\n \t  while (exp)\n \t    {\n-\t      if (! safe_for_unsave (TREE_VALUE (exp)))\n-\t\treturn 0;\n+\t      tmp = unsafe_for_reeval (TREE_VALUE (exp));\n+\t      if (tmp > 1)\n+\t\treturn tmp;\n \t      exp = TREE_CHAIN (exp);\n \t    }\n \t}\n+      return 1;\n+\n+    case TARGET_EXPR:\n+      unsafeness = 1;\n       break;\n \n     default:\n-      if (lang_safe_for_unsave)\n-\tswitch ((*lang_safe_for_unsave) (expr))\n-\t  {\n-\t  case -1:\n-\t    break;\n-\t  case 0:\n-\t    return 0;\n-\t  case 1:\n-\t    return 1;\n-\t  default:\n-\t    abort ();\n-\t  }\n+      /* ??? Add a lang hook if it becomes necessary.  */\n       break;\n     }\n \n@@ -2733,7 +2740,7 @@ safe_for_unsave (expr)\n     case 'x':  /* something random, like an identifier or an ERROR_MARK.  */\n     case 'd':  /* A decl node */\n     case 'b':  /* A block node */\n-      return 1;\n+      return 0;\n \n     case 'e':  /* an expression */\n     case 'r':  /* a reference */\n@@ -2742,12 +2749,15 @@ safe_for_unsave (expr)\n     case '2':  /* a binary arithmetic expression */\n     case '1':  /* a unary arithmetic expression */\n       for (i = first_rtl - 1; i >= 0; i--)\n-\tif (! safe_for_unsave (TREE_OPERAND (expr, i)))\n-\t  return 0;\n-      return 1;\n+\t{\n+\t  tmp = unsafe_for_reeval (TREE_OPERAND (expr, i));\n+\t  if (tmp > unsafeness)\n+\t    unsafeness = tmp;\n+\t}\n+      return unsafeness;\n \n     default:\n-      return 0;\n+      return 2;\n     }\n }\n \f"}, {"sha": "bc5225c30ef2cc654b7ec04b97f04ae241b4e9ea", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/194c7c45b14098d8ed488e57d9d37e3b290ee4cd/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/194c7c45b14098d8ed488e57d9d37e3b290ee4cd/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=194c7c45b14098d8ed488e57d9d37e3b290ee4cd", "patch": "@@ -1963,12 +1963,10 @@ extern tree unsave_expr_now\t\tPARAMS ((tree));\n extern void (*lang_unsave)              PARAMS ((tree *));\n extern void (*lang_unsave_expr_now)     PARAMS ((tree));\n \n-/* If non-null, a language specific version of safe_for_unsave. */\n-extern int (*lang_safe_for_unsave)\tPARAMS ((tree));\n-\n-/* Return nonzero if it is safe to unsave EXPR, else return zero.\n-   It is not safe to unsave EXPR if it contains any embedded RTL_EXPRs.  */\n-extern int safe_for_unsave PARAMS ((tree));\n+/* Return 0 if it is safe to evaluate EXPR multiple times,\n+   return 1 if it is safe if EXPR is unsaved afterward, or\n+   return 2 if it is completely unsafe.  */\n+extern int unsafe_for_reeval PARAMS ((tree));\n \n /* Return 1 if EXP contains a PLACEHOLDER_EXPR; i.e., if it represents a size\n    or offset that depends on a field within a record."}]}