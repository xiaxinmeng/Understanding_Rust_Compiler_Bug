{"sha": "fd4de5ff4abb75e0d9ccae7b920059bcc5f90486", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmQ0ZGU1ZmY0YWJiNzVlMGQ5Y2NhZTdiOTIwMDU5YmNjNWY5MDQ4Ng==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-09-14T11:05:47Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-09-14T11:05:47Z"}, "message": "pt.c (check_specialization_scope): Fix spelling error.\n\n\t* pt.c (check_specialization_scope): Fix spelling error.\n\t(check_explicit_specialization): Remove code to handle explicit\n\tspecializations in class scope; they are now correctly diagnosed\n\tas errors.\n\nFrom-SVN: r22414", "tree": {"sha": "b1a066ab0f44f217e57eb96b5685d50d6a7a65e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b1a066ab0f44f217e57eb96b5685d50d6a7a65e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fd4de5ff4abb75e0d9ccae7b920059bcc5f90486", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd4de5ff4abb75e0d9ccae7b920059bcc5f90486", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd4de5ff4abb75e0d9ccae7b920059bcc5f90486", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd4de5ff4abb75e0d9ccae7b920059bcc5f90486/comments", "author": null, "committer": null, "parents": [{"sha": "028d0b2aaf442fd476e118ed3efbe057093980e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/028d0b2aaf442fd476e118ed3efbe057093980e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/028d0b2aaf442fd476e118ed3efbe057093980e3"}], "stats": {"total": 196, "additions": 96, "deletions": 100}, "files": [{"sha": "08fc2def45652e0a57e159b04d019bce7cd60964", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd4de5ff4abb75e0d9ccae7b920059bcc5f90486/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd4de5ff4abb75e0d9ccae7b920059bcc5f90486/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=fd4de5ff4abb75e0d9ccae7b920059bcc5f90486", "patch": "@@ -1,3 +1,10 @@\n+1998-09-14  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* pt.c (check_specialization_scope): Fix spelling error.\n+\t(check_explicit_specialization): Remove code to handle explicit\n+\tspecializations in class scope; they are now correctly diagnosed\n+\tas errors.\n+\n 1998-09-10  Mark Mitchell  <mark@markmitchell.com>\n \n \t* decl.c (pushdecl): Don't copy types if the"}, {"sha": "de6794fcd73c81e24a5dedd4d53aafe7dc5949c8", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 89, "deletions": 100, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd4de5ff4abb75e0d9ccae7b920059bcc5f90486/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd4de5ff4abb75e0d9ccae7b920059bcc5f90486/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=fd4de5ff4abb75e0d9ccae7b920059bcc5f90486", "patch": "@@ -605,7 +605,7 @@ check_specialization_scope ()\n      explicitly specialize a class member template if its enclosing\n      class templates are not explicitly specialized as well.  */\n   if (current_template_parms) \n-    cp_error (\"enclosing class templates are not explicit specialized\");\n+    cp_error (\"enclosing class templates are not explicitly specialized\");\n }\n \n /* We've just seen template <>. */\n@@ -1031,15 +1031,8 @@ determine_specialization (template_id, decl, targs_out,\n    \n    FLAGS is a bitmask consisting of the following flags: \n \n-   1: We are being called by finish_struct.  (We are unable to\n-      determine what template is specialized by an in-class\n-      declaration until the class definition is complete, so\n-      finish_struct_methods calls this function again later to finish\n-      the job.)\n    2: The function has a definition.\n    4: The function is a friend.\n-   8: The function is known to be a specialization of a member\n-      template. \n \n    The TEMPLATE_COUNT is the number of references to qualifying\n    template classes that appeared in the name of the function.  For\n@@ -1070,126 +1063,122 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n      int template_count;\n      int flags;\n {\n-  int finish_member = flags & 1;\n   int have_def = flags & 2;\n   int is_friend = flags & 4;\n   int specialization = 0;\n   int explicit_instantiation = 0;\n-  int member_specialization = flags & 8;\n+  int member_specialization = 0;\n \n   tree ctype = DECL_CLASS_CONTEXT (decl);\n   tree dname = DECL_NAME (decl);\n \n-  if (!finish_member)\n+  if (processing_specialization) \n     {\n-      if (processing_specialization) \n-\t{\n-\t  /* The last template header was of the form template <>.  */\n+      /* The last template header was of the form template <>.  */\n \t  \n-\t  if (template_header_count > template_count) \n-\t    {\n-\t      /* There were more template headers than qualifying template\n-\t\t classes.  */\n-\t      if (template_header_count - template_count > 1)\n-\t\t/* There shouldn't be that many template parameter\n+      if (template_header_count > template_count) \n+\t{\n+\t  /* There were more template headers than qualifying template\n+\t     classes.  */\n+\t  if (template_header_count - template_count > 1)\n+\t    /* There shouldn't be that many template parameter\n \t\t   lists.  There can be at most one parameter list for\n \t\t   every qualifying class, plus one for the function\n \t\t   itself.  */\n-\t\tcp_error (\"too many template parameter lists in declaration of `%D'\", decl);\n+\t    cp_error (\"too many template parameter lists in declaration of `%D'\", decl);\n \n-\t      SET_DECL_TEMPLATE_SPECIALIZATION (decl);\n-\t      if (ctype)\n-\t\tmember_specialization = 1;\n-\t      else\n-\t\tspecialization = 1;\n-\t    }\n-\t  else if (template_header_count == template_count)\n-\t    {\n-\t      /* The counts are equal.  So, this might be a\n-\t\t specialization, but it is not a specialization of a\n-\t\t member template.  It might be something like\n+\t  SET_DECL_TEMPLATE_SPECIALIZATION (decl);\n+\t  if (ctype)\n+\t    member_specialization = 1;\n+\t  else\n+\t    specialization = 1;\n+\t}\n+      else if (template_header_count == template_count)\n+\t{\n+\t  /* The counts are equal.  So, this might be a\n+\t     specialization, but it is not a specialization of a\n+\t     member template.  It might be something like\n \t\t \n-\t\t template <class T> struct S { \n-\t         void f(int i); \n-\t\t };\n-\t\t template <>\n-\t\t void S<int>::f(int i) {}  */\n-\t      specialization = 1;\n-\t      SET_DECL_TEMPLATE_SPECIALIZATION (decl);\n-\t    }\n-\t  else \n-\t    {\n-\t      /* This cannot be an explicit specialization.  There are not\n-\t\t enough headers for all of the qualifying classes.  For\n-\t\t example, we might have:\n-\t     \n-\t\t template <>\n-\t\t void S<int>::T<char>::f();\n-\n-\t\t But, we're missing another template <>.  */\n-\t      cp_error(\"too few template parameter lists in declaration of `%D'\", decl);\n-\t      return decl;\n-\t    } \n+\t     template <class T> struct S { \n+\t     void f(int i); \n+\t     };\n+\t     template <>\n+\t     void S<int>::f(int i) {}  */\n+\t  specialization = 1;\n+\t  SET_DECL_TEMPLATE_SPECIALIZATION (decl);\n \t}\n-      else if (processing_explicit_instantiation)\n+      else \n \t{\n-\t  if (template_header_count)\n-\t    cp_error (\"template parameter list used in explicit instantiation\");\n+\t  /* This cannot be an explicit specialization.  There are not\n+\t     enough headers for all of the qualifying classes.  For\n+\t     example, we might have:\n+\t     \n+\t     template <>\n+\t     void S<int>::T<char>::f();\n+\n+\t     But, we're missing another template <>.  */\n+\t  cp_error(\"too few template parameter lists in declaration of `%D'\", decl);\n+\t  return decl;\n+\t} \n+    }\n+  else if (processing_explicit_instantiation)\n+    {\n+      if (template_header_count)\n+\tcp_error (\"template parameter list used in explicit instantiation\");\n \t  \n-\t  if (have_def)\n-\t    cp_error (\"definition provided for explicit instantiation\");\n+      if (have_def)\n+\tcp_error (\"definition provided for explicit instantiation\");\n \n-\t  explicit_instantiation = 1;\n-\t}\n-      else if (ctype != NULL_TREE\n-\t       && !TYPE_BEING_DEFINED (ctype)\n-\t       && CLASSTYPE_TEMPLATE_INSTANTIATION (ctype)\n-\t       && !is_friend)\n-\t{\n-\t  /* This case catches outdated code that looks like this:\n+      explicit_instantiation = 1;\n+    }\n+  else if (ctype != NULL_TREE\n+\t   && !TYPE_BEING_DEFINED (ctype)\n+\t   && CLASSTYPE_TEMPLATE_INSTANTIATION (ctype)\n+\t   && !is_friend)\n+    {\n+      /* This case catches outdated code that looks like this:\n \n-\t     template <class T> struct S { void f(); };\n-\t     void S<int>::f() {} // Missing template <>\n+\t template <class T> struct S { void f(); };\n+\t void S<int>::f() {} // Missing template <>\n \n-\t     We disable this check when the type is being defined to\n-\t     avoid complaining about default compiler-generated\n-\t     constructors, destructors, and assignment operators.\n-\t     Since the type is an instantiation, not a specialization,\n-\t     these are the only functions that can be defined before\n-\t     the class is complete.  */\n+\t We disable this check when the type is being defined to\n+\t avoid complaining about default compiler-generated\n+\t constructors, destructors, and assignment operators.\n+\t Since the type is an instantiation, not a specialization,\n+\t these are the only functions that can be defined before\n+\t the class is complete.  */\n \n \t  /* If they said\n \t       template <class T> void S<int>::f() {}\n \t     that's bogus.  */\n-\t  if (template_header_count)\n-\t    {\n-\t      cp_error (\"template parameters specified in specialization\");\n-\t      return decl;\n-\t    }\n-\n-\t  if (pedantic)\n-\t    cp_pedwarn\n-\t      (\"explicit specialization not preceded by `template <>'\");\n-\t  specialization = 1;\n-\t  SET_DECL_TEMPLATE_SPECIALIZATION (decl);\n-\t}\n-      else if (TREE_CODE (declarator) == TEMPLATE_ID_EXPR)\n+      if (template_header_count)\n \t{\n-\t  if (is_friend)\n-\t    /* This could be something like:\n+\t  cp_error (\"template parameters specified in specialization\");\n+\t  return decl;\n+\t}\n \n-\t         template <class T> void f(T);\n-\t\t class S { friend void f<>(int); }  */\n-\t    specialization = 1;\n-\t  else\n-\t    {\n-\t      /* This case handles bogus declarations like template <>\n-\t\t template <class T> void f<int>(); */\n+      if (pedantic)\n+\tcp_pedwarn\n+\t  (\"explicit specialization not preceded by `template <>'\");\n+      specialization = 1;\n+      SET_DECL_TEMPLATE_SPECIALIZATION (decl);\n+    }\n+  else if (TREE_CODE (declarator) == TEMPLATE_ID_EXPR)\n+    {\n+      if (is_friend)\n+\t/* This could be something like:\n \n-\t      cp_error (\"template-id `%D' in declaration of primary template\",\n-\t\t\tdeclarator);\n-\t      return decl;\n-\t    }\n+\t   template <class T> void f(T);\n+\t   class S { friend void f<>(int); }  */\n+\tspecialization = 1;\n+      else\n+\t{\n+\t  /* This case handles bogus declarations like template <>\n+\t     template <class T> void f<int>(); */\n+\n+\t  cp_error (\"template-id `%D' in declaration of primary template\",\n+\t\t    declarator);\n+\t  return decl;\n \t}\n     }\n "}]}