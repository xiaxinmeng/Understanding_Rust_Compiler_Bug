{"sha": "bbc83bc2cb0bcf15c047decf22b190247eb724bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmJjODNiYzJjYjBiY2YxNWMwNDdkZWNmMjJiMTkwMjQ3ZWI3MjRiYw==", "commit": {"author": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-01-03T13:43:25Z"}, "committer": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-01-03T13:43:25Z"}, "message": "Initial revision\n\nFrom-SVN: r156", "tree": {"sha": "6c09b9ffe6ad9af40d6e0eb637992ea09410de06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c09b9ffe6ad9af40d6e0eb637992ea09410de06"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bbc83bc2cb0bcf15c047decf22b190247eb724bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbc83bc2cb0bcf15c047decf22b190247eb724bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbc83bc2cb0bcf15c047decf22b190247eb724bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbc83bc2cb0bcf15c047decf22b190247eb724bc/comments", "author": null, "committer": null, "parents": [{"sha": "ec04a5a3c98fd8c603e9cb3bf63be6b3d0a23389", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec04a5a3c98fd8c603e9cb3bf63be6b3d0a23389", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec04a5a3c98fd8c603e9cb3bf63be6b3d0a23389"}], "stats": {"total": 300, "additions": 300, "deletions": 0}, "files": [{"sha": "ee139a214d279c99be201603a5a39e27c0270c7f", "filename": "gcc/config/m88k/m88k-move.sh", "status": "added", "additions": 300, "deletions": 0, "changes": 300, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbc83bc2cb0bcf15c047decf22b190247eb724bc/gcc%2Fconfig%2Fm88k%2Fm88k-move.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbc83bc2cb0bcf15c047decf22b190247eb724bc/gcc%2Fconfig%2Fm88k%2Fm88k-move.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k-move.sh?ref=bbc83bc2cb0bcf15c047decf22b190247eb724bc", "patch": "@@ -0,0 +1,300 @@\n+#!/bin/sh\n+#\n+#\tIf your shell doesn't support functions (true for some BSD users),\n+#\tyou might try using GNU's bash.\n+#\n+#ident \"@(#) movstr-m88k.sh 17-Oct-90\"\n+#\n+#\tThis file provided by Data General, Feburary 1990.\n+#\n+#\tThis script generates the necessary movstr library functions\n+#\tfor the m88000.  These functions are called from the expansion\n+#\tof movstrsi.  There are eight modules created by this script,\n+#\teach with multiple entry points.  One module, movstrSI64n\n+#\timplements a word aligned loop; the other modules, movstrXINx\n+#\timplement a straight line copy of N bytes in mode XI.\n+#\n+#\tBy analysis of the best memcpy function, it can be determined\n+#\twhat appear to be certain magic numbers.  For example, a\n+#\tmemcpy of 13 bytes, where the pointers are determined at run\n+#\ttime to be word aligned takes 28 cycles.  A call to\n+#\t__movstrQI13x13 also takes 28 cycles.  The break even point\n+#\tfor a HImode copy is 38 bytes.  Just to be on the safe side,\n+#\tthese are bumped to 16 and 48 respectively.\n+#\n+#\tThe smaller, odd-remainder modules are provided to help\n+#\tmitigate the overhead of copying the last bytes.\n+#\n+#\tChanges to these functions should not be taken lightly if you\n+#\twant to be able to link programs built with older movstr\n+#\tparameters.  For this reason, Makefile regards movstr*.s as\n+#\tsource modules and does not have a rule for creating them\n+#\tautomatically.\n+#\n+#.Revision History\n+#\n+#\t26-Oct-90   Tom Wood   Delete movstr.h; moved to out-m88k.c.\n+#\t17-Oct-90   Tom Wood   Files are named *.asm rather than *.s.\n+#\t11-Sep-90   Jeffrey Friedl\n+#\t\t\tOn my BSD 4.3 awk and my GNU-awk, only the\n+#\t\t\tfirst character of an argument to -F is passed\n+#\t\t\tthrough, so I can't get this to work.\n+#\t 5-Sep-90   Ray Essick/Tom Wood  \n+#\t\t\tAdded a -no-tdesc option.\n+#\t27-Aug-90   Vince Guarna/Tom Wood   \n+#\t\t\tVersion 3 assembler syntax (-abi).\n+#\t16-Aug-90   Ron Guilmette\n+#\t\t\tAvoid problems on a Sparc.  The common\n+#\t\t\tdenominator among shells seems to be '...\\'\n+#\t\t\trather than '...\\\\'.\n+#\t15-Aug-90   Ron Guilmette\n+#\t\t\tAvoid awk syntax errors on a Sun by not using\n+#\t\t\tthe `!' operator.\n+#\t22-Feb-90   Tom Wood  \tCreated.\n+#\t20-Jun-90   Tom Wood\tEmit file directives.\n+#\n+#.End]=--------------------------------------------------------------*/\n+\n+usage() {\n+    echo \"usage: $0 [ -abi ] [ -no-tdesc ]\" 1>&2\n+    exit 1\n+}\n+\n+awk_flag=\"-F:\";\n+awk_begin=\"BEGIN { \"\n+do_file() {\n+    echo \"\tfile\t $1\";\n+}\n+\n+while [ $# -gt 0 ] ; do\n+    case $1 in\n+\t-no-tdesc) awk_begin=\"$awk_begin no_tdesc=1;\";;\n+\t-abi) awk_begin=\"$awk_begin abi=1;\"\n+\t      do_file() {\n+\t\techo '\tversion\t \"03.00\"';\n+\t\techo \"\tfile\t $1\";\n+\t      };;\n+\t*) usage;;\n+    esac\n+    shift\n+done\n+\n+rm -f movstr?I*[xn].s movstr?I*[xn].asm\n+\n+#.Implementation_continued[=-----------------------------------------------\n+#\n+#\tThis generates the word aligned loop.  The loop is entered\n+#\tfrom the callable entry points ___movstrSI64nN, where at\n+#\tleast N bytes will be copied.  r2 is the destination pointer\n+#\toffset by 4, r3 is the source pointer offset by 4, r6 is the\n+#\tloop count.  Thus, the total bytes moved is 64 * r6 + N.  The\n+#\tfirst value is is preloaded into r4 or r5 (r4 if N/4 is odd;\n+#\tr5 if N/4 is even).  Upon returning, r2 and r3 have been\n+#\tupdated and may be used for the remainder bytes to move.\n+#\n+#\tThe code for this loop is generated by the awk program\n+#\tfollowing.  Edit *it*, not what it generates!\n+#\n+#.End]=------------------------------------------------------------------*/\n+\n+gen_movstrN() {\n+  awk $awk_flag \"$awk_begin\"'\n+    if (abi) {\n+      ps=\"#\"; us=\"\"; tf=\"a\";\n+    } else {\n+      ps=\"\"; us=\"_\"; tf=\"x\";\n+    }\n+  }\n+  NR == 1 && NF == 4 {\n+    mode = $1; suffix = $2; align = $3; count = $4;\n+    ld = align; st = 0;\n+\n+    printf \"; The following was calculated using awk.\\n\";\n+    printf \"\\ttext\\n\";\n+    printf \"\\talign\\t16\\n\";\n+    printf \"loop%s%d:\\n\", mode, count * align;\n+    printf \"\\taddu\\t%sr3,%sr3,%d\\n\", ps, ps, count * align;\n+    printf \"\\taddu\\t%sr2,%sr2,%d\\n\", ps, ps, count * align;\n+    printf \"\\tsubu\\t%sr6,%sr6,1\\n\", ps, ps;\n+    for (r = count + 1; r >= 1; r--) {\n+      evenp = r % 2;\n+      name = sprintf(\"__%smovstr%s%dn%d\", us, mode, count * align, r * align);\n+      if (r > 1) {\n+        printf \"\\tglobal\\t%s\\n\", name;\n+        printf \"%s:\\n\", name;\n+      }\n+      if (r > 2) {\n+\tprintf \"\\tld%s\\t%sr%d,%sr3,%d\\n\", suffix, ps, 4 + evenp, ps, ld;\n+        printf \"\\tst%s\\t%sr%d,%sr2,%d\\n\", suffix, ps, 5 - evenp, ps, st;\n+      } else if (r == 2) {\n+\tprintf \"\\tld%s\\t%sr%d,%sr3,%d\\n\", suffix, ps, 4 + evenp, ps, ld;\n+\tprintf \"\\tbcnd.n\\t%sgt0,%sr6,loop%s%d\\n\", ps, ps, mode, count * align;\n+        printf \"\\tst%s\\t%sr%d,%sr2,%d\\n\", suffix, ps, 5 - evenp, ps, st;\n+        printf \"\\tjmp.n\\t%sr1\\n\", ps;\n+      } else {\n+        printf \"\\tst%s\\t%sr%d,%sr2,%d\\n\", suffix, ps, 5 - evenp, ps, st;\n+      }\n+      ld += align; st += align;\n+    }\n+    if (!no_tdesc) {\n+      printf \"end%s%d:\\n\", mode, count * align;\n+      printf \"\\tsection\\t.tdesc,\\\"%s\\\"\\n\", tf;\n+      printf \"\\tword\\t0x42\\n\";\n+      printf \"\\tword\\t1\\n\";\n+      printf \"\\tword\\tloop%s%d\\n\", mode, count * align;\n+      printf \"\\tword\\tend%s%d\\n\", mode, count * align;\n+      printf \"\\tword\\t0x0100001f\\n\";\n+      printf \"\\tword\\t0\\n\";\n+      printf \"\\tword\\t1\\n\";\n+      printf \"\\tword\\t0\\n\";\n+      printf \"\\ttext\\n\";\n+    }\n+    printf \"; End of awk generated code.\\n\";\n+    exit;\n+  }'\n+}\n+\n+(do_file '\"movstrSI64n.s\"';\n+ echo 'SI::4:16' | gen_movstrN) > movstrSI64n.asm\n+\n+#.Implementation_continued[=-----------------------------------------------\n+#\n+#\tThis generates the even-remainder, straight-line modules.\n+#\tThe code is entered from the callable entry points\n+#\t___movstrXINxM, where exactly M bytes will be copied in XI\n+#\tmode.  r2 is the destination pointer, r3 is the source\n+#\tpointer, neither being offset.  The first value is preloaded\n+#\tinto r4 or r5 (r4 if M-N/B is even; r5 if M-N/B is odd, where\n+#\tB is the mode size of XI).  Upon returning, r2 and r3 have not\n+#\tbeen changed.\n+#\n+#\tThe code for these cases is generated by the awk program\n+#\tfollowing.  Edit *it*, not what it generates!\n+#\n+#.End]=------------------------------------------------------------------*/\n+\n+gen_movstrX0() {\n+    awk $awk_flag \"$awk_begin\"'\n+      if (abi) {\n+\tps=\"#\"; us=\"\"; tf=\"a\";\n+      } else {\n+\tps=\"\"; us=\"_\"; tf=\"x\";\n+      }\n+    }\n+    NR == 1 && NF == 4 {\n+    mode = $1; suffix = $2; align = $3; bytes = $4;\n+    ld = align; st = 0; count = bytes / align;\n+    printf \"; The following was calculated using awk.\\n\";\n+    printf \"\\ttext\\n\";\n+    printf \"\\talign\\t16\\n\";\n+    for (r = count; r >= 1; r--) {\n+      evenp = r % 2;\n+      name = sprintf(\"__%smovstr%s%dx%d\", us, mode, count * align, r * align);\n+      if (r > 1) {\n+        printf \"\\tglobal\\t%s\\n\", name;\n+        printf \"%s:\\n\", name;\n+      }\n+      if (r == 1)\n+        printf \"\\tjmp.n\\t%sr1\\n\", ps;\n+      else\n+        printf \"\\tld%s\\t%sr%d,%sr3,%d\\n\", suffix, ps, 4 + evenp, ps, ld;\n+      printf \"\\tst%s\\t%sr%d,%sr2,%d\\n\", suffix, ps, 5 - evenp, ps, st;\n+      ld += align; st += align;\n+    }\n+    if (!no_tdesc) {\n+      printf \"end%s%dx:\\n\", mode, count * align;\n+      printf \"\\tsection\\t.tdesc,\\\"%s\\\"\\n\", tf;\n+      printf \"\\tword\\t0x42\\n\";\n+      printf \"\\tword\\t1\\n\";\n+      printf \"\\tword\\t__%smovstr%s%dx%d\\n\", us, mode, count * align, count * align;\n+      printf \"\\tword\\tend%s%dx\\n\", mode, count * align;\n+      printf \"\\tword\\t0x0100001f\\n\";\n+      printf \"\\tword\\t0\\n\";\n+      printf \"\\tword\\t1\\n\";\n+      printf \"\\tword\\t0\\n\";\n+      printf \"\\ttext\\n\";\n+    }\n+    printf \"; End of awk generated code.\\n\"\n+    exit;\n+  }'\n+}\n+\n+(do_file '\"movstrQI16x.s\"';\n+ echo 'QI:.b:1:16' | gen_movstrX0) > movstrQI16x.asm\n+(do_file '\"movstrHI48x.s\"';\n+ echo 'HI:.h:2:48' | gen_movstrX0) > movstrHI48x.asm\n+(do_file '\"movstrSI96x.s\"';\n+ echo 'SI::4:96'   | gen_movstrX0) > movstrSI96x.asm\n+\n+#.Implementation_continued[=-----------------------------------------------\n+#\n+#\tThis generates the odd-remainder, straight-line modules.  The\n+#\tinterface is the same as that for the even-remainder modules.\n+#\n+#.End]=------------------------------------------------------------------*/\n+\n+gen_movstrXr() {\n+    awk $awk_flag \"$awk_begin\"'\n+      if (abi) {\n+\tps=\"#\"; us=\"\"; tf=\"a\";\n+      } else {\n+\tps=\"\"; us=\"_\"; tf=\"x\";\n+      }\n+    }\n+    NR == 1 && NF == 4 {\n+    mode = $1; rem = $2; most = $3; count = $4;\n+    suffix[1] = \".b\"; suffix[2] = \".h\"; suffix[4] = \"\";\n+\n+    prev = align = most;\n+    ld = align; st = 0; total = count - rem - most;\n+    evenp = int(total/align) % 2;\n+    printf \"; The following was calculated using awk.\\n\";\n+    printf \"\\ttext\\n\";\n+    printf \"\\talign\\t16\\n\";\n+    for (bytes = total; bytes >= 0; bytes -= align) {\n+      if (bytes < align) {\n+\tif (bytes >= 2) align = 2;\n+\telse align = 1;\n+      }\n+      name = sprintf(\"__%smovstr%s%dx%d\", us, mode, total + most, bytes + most);\n+      if (bytes > most) {\n+        printf \"\\tglobal\\t%s\\n\", name;\n+        printf \"%s:\\n\", name;\n+      }\n+      if (bytes == 0)\n+\tprintf \"\\tjmp.n\\t%sr1\\n\", ps;\n+      else\n+\tprintf \"\\tld%s\\t%sr%d,%sr3,%d\\n\", suffix[align], ps, 4 + evenp, ps, ld;\n+      printf \"\\tst%s\\t%sr%d,%sr2,%d\\n\", suffix[prev], ps, 5 - evenp, ps, st;\n+      ld += align; st += prev; prev = align;\n+      if (evenp)\n+\tevenp = 0;\n+      else\n+\tevenp = 1;\n+    }\n+    if (!no_tdesc) {\n+      printf \"end%s%dx:\\n\", mode, total + most;\n+      printf \"\\tsection\\t.tdesc,\\\"%s\\\"\\n\", tf;\n+      printf \"\\tword\\t0x42\\n\";\n+      printf \"\\tword\\t1\\n\";\n+      printf \"\\tword\\t__%smovstr%s%dx%d\\n\", us, mode, total + most, total + most;\n+      printf \"\\tword\\tend%s%dx\\n\", mode, total + most;\n+      printf \"\\tword\\t0x0100001f\\n\";\n+      printf \"\\tword\\t0\\n\";\n+      printf \"\\tword\\t1\\n\";\n+      printf \"\\tword\\t0\\n\";\n+      printf \"\\ttext\\n\";\n+    }\n+    printf \"; End of awk generated code.\\n\"\n+    exit;\n+  }'\n+}\n+\n+(do_file '\"movstrSI47x.s\"';\n+ echo 'SI:1:4:48' | gen_movstrXr) > movstrSI47x.asm\n+(do_file '\"movstrSI46x.s\"';\n+ echo 'SI:2:4:48' | gen_movstrXr) > movstrSI46x.asm\n+(do_file '\"movstrSI45x.s\"';\n+ echo 'SI:3:4:48' | gen_movstrXr) > movstrSI45x.asm\n+(do_file '\"movstrHI15x.s\"';\n+ echo 'HI:1:2:16' | gen_movstrXr) > movstrHI15x.asm"}]}