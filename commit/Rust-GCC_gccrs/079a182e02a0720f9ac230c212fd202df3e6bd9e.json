{"sha": "079a182e02a0720f9ac230c212fd202df3e6bd9e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDc5YTE4MmUwMmEwNzIwZjlhYzIzMGMyMTJmZDIwMmRmM2U2YmQ5ZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2007-01-28T19:38:39Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2007-01-28T19:38:39Z"}, "message": "expr.c (emit_block_move_via_movmem, [...]): Add variant handling histograms; add wrapper.\n\n\t* expr.c (emit_block_move_via_movmem, emit_block_move_via_libcall): Add\n\tvariant handling histograms; add wrapper.\n\t(clear_storage_via_libcall): Export.\n\t(emit_block_move_hints): Break out from ...; add histograms.\n\t(emit_block_move): ... this one.\n\t(clear_storage_hints): Break out from ...; add histograms.\n\t(clear_storage): ... this one.\n\t(set_storage_via_memset): Handle histogram.\n\t* expr.h (emit_block_move_via_libcall, emit_block_move_hints): Declare.\n\t(clear_storage_hints, clear_storage_via_libcall): Declare.\n\t(set_storage_via_setmem): Update prototype.\n\t* doc/md.texi (movmem, setmem): Document new arguments.\n\n\t* value-prof.c (dump_histogram_value, tree_find_values_to_profile): Add\n\tnew histograms.\n\t(stringop_block_profile): New global function.\n\t(tree_stringops_values_to_profile): Profile block size and alignment.\n\t* value-prof.h (enum hist_type): add HIST_TYPE_AVERAGE and\n\tHIST_TYPE_IOR.\n\t(struct profile_hooks): Add gen_average_profiler and gen_ior_profiler.\n\t(stringop_block_profile): Declare.\n\t* builtins.c: Include value-prof.h.\n\t(expand_builtin_memcpy, expand_builtin_memset): Pass block profile.\n\t* gcov-ui.h (GCOV_COUNTER_NAMES): Add new counter.\n\t(GCOV_COUNTER_AVERAGE, GCOV_COUNTER_IOR): New constants.\n\t(GCOV_COUNTERS, GCOV_LAST_VALUE_COUNTER): Update.\n\t* profile.c (instrument_values): Add new counters.\n\t* cfgexpand.c (expand_gimple_basic_block): Propagate histograms to\n\tcalls.\n\t* tree-profile.c (tree_average_profiler_fn, tree_ior_profiler_fn): New.\n\t(tree_init_edge_profiler): Build new profilers.\n\t(tree_gen_average_profiler, tree_gen_ior_profiler): New.\n\t(pass_tree_profile): Add dump.\n\t(tree_profile_hooks): Update.\n\t* Makefile.in (LIBGCOV): Add new constants.\n\t* libgcov.c (__gcov_merge_ior, __gcov_average_profiler,\n\t__gcov_ior_profiler): New.\n\t* i386.md (movmem/setmem expanders): Add new optional arguments.\n\nFrom-SVN: r121270", "tree": {"sha": "f0b99d930c723a2db6886a47a653581d98be0f1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f0b99d930c723a2db6886a47a653581d98be0f1a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/079a182e02a0720f9ac230c212fd202df3e6bd9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/079a182e02a0720f9ac230c212fd202df3e6bd9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/079a182e02a0720f9ac230c212fd202df3e6bd9e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/079a182e02a0720f9ac230c212fd202df3e6bd9e/comments", "author": null, "committer": null, "parents": [{"sha": "2472200d9c53250482c75443611251490b23e5f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2472200d9c53250482c75443611251490b23e5f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2472200d9c53250482c75443611251490b23e5f2"}], "stats": {"total": 435, "additions": 390, "deletions": 45}, "files": [{"sha": "1e8f2966e8f4b8a51818f3c1f72f4d7634ac1943", "filename": "gcc/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/079a182e02a0720f9ac230c212fd202df3e6bd9e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/079a182e02a0720f9ac230c212fd202df3e6bd9e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=079a182e02a0720f9ac230c212fd202df3e6bd9e", "patch": "@@ -1,3 +1,44 @@\n+2007-01-28  Jan Hubicka  <jh@suse.cz>\n+\n+\t* expr.c (emit_block_move_via_movmem, emit_block_move_via_libcall): Add\n+\tvariant handling histograms; add wrapper.\n+\t(clear_storage_via_libcall): Export.\n+\t(emit_block_move_hints): Break out from ...; add histograms.\n+\t(emit_block_move): ... this one.\n+\t(clear_storage_hints): Break out from ...; add histograms.\n+\t(clear_storage): ... this one.\n+\t(set_storage_via_memset): Handle histogram.\n+\t* expr.h (emit_block_move_via_libcall, emit_block_move_hints): Declare.\n+\t(clear_storage_hints, clear_storage_via_libcall): Declare.\n+\t(set_storage_via_setmem): Update prototype.\n+\t* doc/md.texi (movmem, setmem): Document new arguments.\n+\n+\t* value-prof.c (dump_histogram_value, tree_find_values_to_profile): Add\n+\tnew histograms.\n+\t(stringop_block_profile): New global function.\n+\t(tree_stringops_values_to_profile): Profile block size and alignment.\n+\t* value-prof.h (enum hist_type): add HIST_TYPE_AVERAGE and\n+\tHIST_TYPE_IOR.\n+\t(struct profile_hooks): Add gen_average_profiler and gen_ior_profiler.\n+\t(stringop_block_profile): Declare.\n+\t* builtins.c: Include value-prof.h.\n+\t(expand_builtin_memcpy, expand_builtin_memset): Pass block profile.\n+\t* gcov-ui.h (GCOV_COUNTER_NAMES): Add new counter.\n+\t(GCOV_COUNTER_AVERAGE, GCOV_COUNTER_IOR): New constants.\n+\t(GCOV_COUNTERS, GCOV_LAST_VALUE_COUNTER): Update.\n+\t* profile.c (instrument_values): Add new counters.\n+\t* cfgexpand.c (expand_gimple_basic_block): Propagate histograms to\n+\tcalls.\n+\t* tree-profile.c (tree_average_profiler_fn, tree_ior_profiler_fn): New.\n+\t(tree_init_edge_profiler): Build new profilers.\n+\t(tree_gen_average_profiler, tree_gen_ior_profiler): New.\n+\t(pass_tree_profile): Add dump.\n+\t(tree_profile_hooks): Update.\n+\t* Makefile.in (LIBGCOV): Add new constants.\n+\t* libgcov.c (__gcov_merge_ior, __gcov_average_profiler,\n+\t__gcov_ior_profiler): New.\n+\t* i386.md (movmem/setmem expanders): Add new optional arguments.\n+\n 2007-01-28  David Edelsohn  <edelsohn@gnu.org>\n \n \t* doc/md.texi (Standard Pattern Names): Document blockage pattern."}, {"sha": "dff21734a59f42e5952f73be799e410f0942fb48", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/079a182e02a0720f9ac230c212fd202df3e6bd9e/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/079a182e02a0720f9ac230c212fd202df3e6bd9e/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=079a182e02a0720f9ac230c212fd202df3e6bd9e", "patch": "@@ -1200,7 +1200,8 @@ LIBGCOV = _gcov _gcov_merge_add _gcov_merge_single _gcov_merge_delta \\\n     _gcov_fork _gcov_execl _gcov_execlp _gcov_execle \\\n     _gcov_execv _gcov_execvp _gcov_execve \\\n     _gcov_interval_profiler _gcov_pow2_profiler _gcov_one_value_profiler \\\n-    _gcov_indirect_call_profiler\n+    _gcov_indirect_call_profiler _gcov_average_profiler _gcov_ior_profiler \\\n+    _gcov_merge_ior\n \n FPBIT_FUNCS = _pack_sf _unpack_sf _addsub_sf _mul_sf _div_sf \\\n     _fpcmp_parts_sf _compare_sf _eq_sf _ne_sf _gt_sf _ge_sf \\"}, {"sha": "7947907d3ecae1f89975e4df3e312f63adb6c015", "filename": "gcc/builtins.c", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/079a182e02a0720f9ac230c212fd202df3e6bd9e/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/079a182e02a0720f9ac230c212fd202df3e6bd9e/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=079a182e02a0720f9ac230c212fd202df3e6bd9e", "patch": "@@ -49,6 +49,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"basic-block.h\"\n #include \"tree-mudflap.h\"\n #include \"tree-flow.h\"\n+#include \"value-prof.h\"\n \n #ifndef PAD_VARARGS_DOWN\n #define PAD_VARARGS_DOWN BYTES_BIG_ENDIAN\n@@ -3099,6 +3100,8 @@ expand_builtin_memcpy (tree exp, rtx target, enum machine_mode mode)\n       rtx dest_mem, src_mem, dest_addr, len_rtx;\n       tree result = fold_builtin_memory_op (arglist, TREE_TYPE (TREE_TYPE (fndecl)),\n \t\t\t\t\t    false, /*endp=*/0);\n+      HOST_WIDE_INT expected_size = -1;\n+      unsigned int expected_align = 0;\n \n       if (result)\n \t{\n@@ -3119,7 +3122,10 @@ expand_builtin_memcpy (tree exp, rtx target, enum machine_mode mode)\n \t operation in-line.  */\n       if (src_align == 0)\n \treturn 0;\n-\n+ \n+      stringop_block_profile (exp, &expected_align, &expected_size);\n+      if (expected_align < dest_align)\n+\texpected_align = dest_align;\n       dest_mem = get_memory_rtx (dest, len);\n       set_mem_align (dest_mem, dest_align);\n       len_rtx = expand_normal (len);\n@@ -3146,9 +3152,10 @@ expand_builtin_memcpy (tree exp, rtx target, enum machine_mode mode)\n       set_mem_align (src_mem, src_align);\n \n       /* Copy word part most expediently.  */\n-      dest_addr = emit_block_move (dest_mem, src_mem, len_rtx,\n-\t\t\t\t   CALL_EXPR_TAILCALL (exp)\n-\t\t\t\t   ? BLOCK_OP_TAILCALL : BLOCK_OP_NORMAL);\n+      dest_addr = emit_block_move_hints (dest_mem, src_mem, len_rtx,\n+\t\t\t\t         CALL_EXPR_TAILCALL (exp)\n+\t\t\t\t         ? BLOCK_OP_TAILCALL : BLOCK_OP_NORMAL,\n+\t\t\t\t\t expected_align, expected_size);\n \n       if (dest_addr == 0)\n \t{\n@@ -3640,6 +3647,8 @@ expand_builtin_memset (tree arglist, rtx target, enum machine_mode mode,\n       char c;\n       unsigned int dest_align;\n       rtx dest_mem, dest_addr, len_rtx;\n+      HOST_WIDE_INT expected_size = -1;\n+      unsigned int expected_align = 0;\n \n       dest_align = get_pointer_alignment (dest, BIGGEST_ALIGNMENT);\n \n@@ -3648,6 +3657,10 @@ expand_builtin_memset (tree arglist, rtx target, enum machine_mode mode,\n       if (dest_align == 0)\n \treturn 0;\n \n+      stringop_block_profile (orig_exp, &expected_align, &expected_size);\n+      if (expected_align < dest_align)\n+\texpected_align = dest_align;\n+\n       /* If the LEN parameter is zero, return DEST.  */\n       if (integer_zerop (len))\n \t{\n@@ -3687,7 +3700,7 @@ expand_builtin_memset (tree arglist, rtx target, enum machine_mode mode,\n \t\t\t       builtin_memset_gen_str, val_rtx, dest_align, 0);\n \t    }\n \t  else if (!set_storage_via_setmem (dest_mem, len_rtx, val_rtx,\n-\t\t\t\t\t    dest_align))\n+\t\t\t\t\t    dest_align, -1, 0))\n \t    goto do_libcall;\n \n \t  dest_mem = force_operand (XEXP (dest_mem, 0), NULL_RTX);\n@@ -3707,7 +3720,8 @@ expand_builtin_memset (tree arglist, rtx target, enum machine_mode mode,\n \t    store_by_pieces (dest_mem, tree_low_cst (len, 1),\n \t\t\t     builtin_memset_read_str, &c, dest_align, 0);\n \t  else if (!set_storage_via_setmem (dest_mem, len_rtx, GEN_INT (c),\n-\t\t\t\t\t    dest_align))\n+\t\t\t\t\t    dest_align, expected_align,\n+\t\t\t\t\t    expected_size))\n \t    goto do_libcall;\n \n \t  dest_mem = force_operand (XEXP (dest_mem, 0), NULL_RTX);\n@@ -3716,9 +3730,10 @@ expand_builtin_memset (tree arglist, rtx target, enum machine_mode mode,\n \t}\n \n       set_mem_align (dest_mem, dest_align);\n-      dest_addr = clear_storage (dest_mem, len_rtx,\n-\t\t\t\t CALL_EXPR_TAILCALL (orig_exp)\n-\t\t\t\t ? BLOCK_OP_TAILCALL : BLOCK_OP_NORMAL);\n+      dest_addr = clear_storage_hints (dest_mem, len_rtx,\n+\t\t\t\t       CALL_EXPR_TAILCALL (orig_exp)\n+\t\t\t\t       ? BLOCK_OP_TAILCALL : BLOCK_OP_NORMAL,\n+\t\t\t\t       expected_align, expected_size);\n \n       if (dest_addr == 0)\n \t{"}, {"sha": "52ac211cbfebb50c3fc2c3f313293f541bed8dfb", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/079a182e02a0720f9ac230c212fd202df3e6bd9e/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/079a182e02a0720f9ac230c212fd202df3e6bd9e/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=079a182e02a0720f9ac230c212fd202df3e6bd9e", "patch": "@@ -1516,9 +1516,12 @@ expand_gimple_basic_block (basic_block bb)\n \t  /* For the benefit of calls.c, converting all this to rtl,\n \t     we need to record the call expression, not just the outer\n \t     modify statement.  */\n-\t  if (call && call != stmt\n-\t      && (region = lookup_stmt_eh_region (stmt)) > 0)\n-\t    add_stmt_to_eh_region (call, region);\n+\t  if (call && call != stmt)\n+\t    {\n+\t      if ((region = lookup_stmt_eh_region (stmt)) > 0)\n+\t        add_stmt_to_eh_region (call, region);\n+\t      gimple_duplicate_stmt_histograms (cfun, call, cfun, stmt);\n+\t    }\n \t  if (call && CALL_EXPR_TAILCALL (call))\n \t    {\n \t      bool can_fallthru;"}, {"sha": "21d1c2b009235f7a473f6589fe92bcde85cf8b28", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/079a182e02a0720f9ac230c212fd202df3e6bd9e/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/079a182e02a0720f9ac230c212fd202df3e6bd9e/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=079a182e02a0720f9ac230c212fd202df3e6bd9e", "patch": "@@ -17591,11 +17591,13 @@\n   [(use (match_operand:BLK 0 \"memory_operand\" \"\"))\n    (use (match_operand:BLK 1 \"memory_operand\" \"\"))\n    (use (match_operand:SI 2 \"nonmemory_operand\" \"\"))\n-   (use (match_operand:SI 3 \"const_int_operand\" \"\"))]\n+   (use (match_operand:SI 3 \"const_int_operand\" \"\"))\n+   (use (match_operand:SI 4 \"const_int_operand\" \"\"))\n+   (use (match_operand:SI 5 \"const_int_operand\" \"\"))]\n   \"\"\n {\n  if (ix86_expand_movmem (operands[0], operands[1], operands[2], operands[3],\n-\t\t\t operands[3], constm1_rtx))\n+\t\t\t operands[4], operands[5]))\n    DONE;\n  else\n    FAIL;\n@@ -17605,11 +17607,13 @@\n   [(use (match_operand:BLK 0 \"memory_operand\" \"\"))\n    (use (match_operand:BLK 1 \"memory_operand\" \"\"))\n    (use (match_operand:DI 2 \"nonmemory_operand\" \"\"))\n-   (use (match_operand:DI 3 \"const_int_operand\" \"\"))]\n+   (use (match_operand:DI 3 \"const_int_operand\" \"\"))\n+   (use (match_operand:SI 4 \"const_int_operand\" \"\"))\n+   (use (match_operand:SI 5 \"const_int_operand\" \"\"))]\n   \"TARGET_64BIT\"\n {\n  if (ix86_expand_movmem (operands[0], operands[1], operands[2], operands[3],\n-\t\t\t operands[3], constm1_rtx))\n+\t\t\t operands[4], operands[5]))\n    DONE;\n  else\n    FAIL;\n@@ -17867,12 +17871,14 @@\n    [(use (match_operand:BLK 0 \"memory_operand\" \"\"))\n     (use (match_operand:SI 1 \"nonmemory_operand\" \"\"))\n     (use (match_operand 2 \"const_int_operand\" \"\"))\n-    (use (match_operand 3 \"const_int_operand\" \"\"))]\n+    (use (match_operand 3 \"const_int_operand\" \"\"))\n+    (use (match_operand:SI 4 \"const_int_operand\" \"\"))\n+    (use (match_operand:SI 5 \"const_int_operand\" \"\"))]\n   \"\"\n {\n  if (ix86_expand_setmem (operands[0], operands[1],\n \t\t\t operands[2], operands[3],\n-\t\t\t operands[3], constm1_rtx))\n+\t\t\t operands[4], operands[5]))\n    DONE;\n  else\n    FAIL;\n@@ -17889,7 +17895,7 @@\n {\n  if (ix86_expand_setmem (operands[0], operands[1],\n \t\t\t operands[2], operands[3],\n-\t\t\t operands[3], constm1_rtx))\n+\t\t\t operands[4], operands[5]))\n    DONE;\n  else\n    FAIL;"}, {"sha": "54ce9f5e315f4d4c40574977023fb1bb73250693", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/079a182e02a0720f9ac230c212fd202df3e6bd9e/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/079a182e02a0720f9ac230c212fd202df3e6bd9e/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=079a182e02a0720f9ac230c212fd202df3e6bd9e", "patch": "@@ -3971,6 +3971,11 @@ destination, in the form of a @code{const_int} rtx.  Thus, if the\n compiler knows that both source and destination are word-aligned,\n it may provide the value 4 for this operand.\n \n+Optional operands 5 and 6 specify expected alignment and size of block\n+respectively.  The expected alignment differs from alignment in operand 4\n+in a way that the blocks are not required to be aligned according to it in\n+all cases. Expected size, when unknown, is set to @code{(const_int -1)}.\n+\n Descriptions of multiple @code{movmem@var{m}} patterns can only be\n beneficial if the patterns for smaller modes have fewer restrictions\n on their first, second and fourth operands.  Note that the mode @var{m}\n@@ -4003,6 +4008,11 @@ of a @code{const_int} rtx.  Thus, if the compiler knows that the\n destination is word-aligned, it may provide the value 4 for this\n operand.\n \n+Optional operands 5 and 6 specify expected alignment and size of block\n+respectively.  The expected alignment differs from alignment in operand 4\n+in a way that the blocks are not required to be aligned according to it in\n+all cases. Expected size, when unknown, is set to @code{(const_int -1)}.\n+\n The use for multiple @code{setmem@var{m}} is as for @code{movmem@var{m}}.\n \n @cindex @code{cmpstrn@var{m}} instruction pattern"}, {"sha": "6e6090904c36af8f53ac2b23dbd54abe3a774d19", "filename": "gcc/expr.c", "status": "modified", "additions": 44, "deletions": 9, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/079a182e02a0720f9ac230c212fd202df3e6bd9e/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/079a182e02a0720f9ac230c212fd202df3e6bd9e/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=079a182e02a0720f9ac230c212fd202df3e6bd9e", "patch": "@@ -126,7 +126,7 @@ static unsigned HOST_WIDE_INT move_by_pieces_ninsns (unsigned HOST_WIDE_INT,\n static void move_by_pieces_1 (rtx (*) (rtx, ...), enum machine_mode,\n \t\t\t      struct move_by_pieces *);\n static bool block_move_libcall_safe_for_call_parm (void);\n-static bool emit_block_move_via_movmem (rtx, rtx, rtx, unsigned);\n+static bool emit_block_move_via_movmem (rtx, rtx, rtx, unsigned, unsigned, HOST_WIDE_INT);\n static tree emit_block_move_libcall_fn (int);\n static void emit_block_move_via_loop (rtx, rtx, rtx, unsigned);\n static rtx clear_by_pieces_1 (void *, HOST_WIDE_INT, enum machine_mode);\n@@ -1147,7 +1147,8 @@ move_by_pieces_1 (rtx (*genfun) (rtx, ...), enum machine_mode mode,\n    0 otherwise.  */\n \n rtx\n-emit_block_move (rtx x, rtx y, rtx size, enum block_op_methods method)\n+emit_block_move_hints (rtx x, rtx y, rtx size, enum block_op_methods method,\n+\t\t       unsigned int expected_align, HOST_WIDE_INT expected_size)\n {\n   bool may_use_call;\n   rtx retval = 0;\n@@ -1202,7 +1203,8 @@ emit_block_move (rtx x, rtx y, rtx size, enum block_op_methods method)\n \n   if (GET_CODE (size) == CONST_INT && MOVE_BY_PIECES_P (INTVAL (size), align))\n     move_by_pieces (x, y, INTVAL (size), align, 0);\n-  else if (emit_block_move_via_movmem (x, y, size, align))\n+  else if (emit_block_move_via_movmem (x, y, size, align,\n+\t\t\t\t       expected_align, expected_size))\n     ;\n   else if (may_use_call)\n     retval = emit_block_move_via_libcall (x, y, size,\n@@ -1216,6 +1218,12 @@ emit_block_move (rtx x, rtx y, rtx size, enum block_op_methods method)\n   return retval;\n }\n \n+rtx\n+emit_block_move (rtx x, rtx y, rtx size, enum block_op_methods method)\n+{\n+  return emit_block_move_hints (x, y, size, method, 0, -1);\n+}\n+\n /* A subroutine of emit_block_move.  Returns true if calling the\n    block move libcall will not clobber any parameters which may have\n    already been placed on the stack.  */\n@@ -1266,12 +1274,16 @@ block_move_libcall_safe_for_call_parm (void)\n    return true if successful.  */\n \n static bool\n-emit_block_move_via_movmem (rtx x, rtx y, rtx size, unsigned int align)\n+emit_block_move_via_movmem (rtx x, rtx y, rtx size, unsigned int align,\n+\t\t\t    unsigned int expected_align, HOST_WIDE_INT expected_size)\n {\n   rtx opalign = GEN_INT (align / BITS_PER_UNIT);\n   int save_volatile_ok = volatile_ok;\n   enum machine_mode mode;\n \n+  if (expected_align < align)\n+    expected_align = align;\n+\n   /* Since this is a move insn, we don't care about volatility.  */\n   volatile_ok = 1;\n \n@@ -1315,7 +1327,12 @@ emit_block_move_via_movmem (rtx x, rtx y, rtx size, unsigned int align)\n \t     that it doesn't fail the expansion because it thinks\n \t     emitting the libcall would be more efficient.  */\n \n-\t  pat = GEN_FCN ((int) code) (x, y, op2, opalign);\n+\t  if (insn_data[(int) code].n_operands == 4)\n+\t    pat = GEN_FCN ((int) code) (x, y, op2, opalign);\n+\t  else\n+\t    pat = GEN_FCN ((int) code) (x, y, op2, opalign,\n+\t\t\t\t\tGEN_INT (expected_align),\n+\t\t\t\t\tGEN_INT (expected_size));\n \t  if (pat)\n \t    {\n \t      emit_insn (pat);\n@@ -2495,7 +2512,8 @@ store_by_pieces_2 (rtx (*genfun) (rtx, ...), enum machine_mode mode,\n    its length in bytes.  */\n \n rtx\n-clear_storage (rtx object, rtx size, enum block_op_methods method)\n+clear_storage_hints (rtx object, rtx size, enum block_op_methods method,\n+\t\t     unsigned int expected_align, HOST_WIDE_INT expected_size)\n {\n   enum machine_mode mode = GET_MODE (object);\n   unsigned int align;\n@@ -2535,7 +2553,8 @@ clear_storage (rtx object, rtx size, enum block_op_methods method)\n   if (GET_CODE (size) == CONST_INT\n       && CLEAR_BY_PIECES_P (INTVAL (size), align))\n     clear_by_pieces (object, INTVAL (size), align);\n-  else if (set_storage_via_setmem (object, size, const0_rtx, align))\n+  else if (set_storage_via_setmem (object, size, const0_rtx, align,\n+\t\t\t\t   expected_align, expected_size))\n     ;\n   else\n     return set_storage_via_libcall (object, size, const0_rtx,\n@@ -2544,6 +2563,13 @@ clear_storage (rtx object, rtx size, enum block_op_methods method)\n   return NULL;\n }\n \n+rtx\n+clear_storage (rtx object, rtx size, enum block_op_methods method)\n+{\n+  return clear_storage_hints (object, size, method, 0, -1);\n+}\n+\n+\n /* A subroutine of clear_storage.  Expand a call to memset.\n    Return the return value of memset, 0 otherwise.  */\n \n@@ -2645,7 +2671,8 @@ clear_storage_libcall_fn (int for_call)\n /* Expand a setmem pattern; return true if successful.  */\n \n bool\n-set_storage_via_setmem (rtx object, rtx size, rtx val, unsigned int align)\n+set_storage_via_setmem (rtx object, rtx size, rtx val, unsigned int align,\n+\t\t\tunsigned int expected_align, HOST_WIDE_INT expected_size)\n {\n   /* Try the most limited insn first, because there's no point\n      including more than one in the machine description unless\n@@ -2654,6 +2681,9 @@ set_storage_via_setmem (rtx object, rtx size, rtx val, unsigned int align)\n   rtx opalign = GEN_INT (align / BITS_PER_UNIT);\n   enum machine_mode mode;\n \n+  if (expected_align < align)\n+    expected_align = align;\n+\n   for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT); mode != VOIDmode;\n        mode = GET_MODE_WIDER_MODE (mode))\n     {\n@@ -2694,7 +2724,12 @@ set_storage_via_setmem (rtx object, rtx size, rtx val, unsigned int align)\n \t\topchar = copy_to_mode_reg (char_mode, opchar);\n \t    }\n \n-\t  pat = GEN_FCN ((int) code) (object, opsize, opchar, opalign);\n+\t  if (insn_data[(int) code].n_operands == 4)\n+\t    pat = GEN_FCN ((int) code) (object, opsize, opchar, opalign);\n+\t  else\n+\t    pat = GEN_FCN ((int) code) (object, opsize, opchar, opalign,\n+\t\t\t\t\tGEN_INT (expected_align),\n+\t\t\t\t\tGEN_INT (expected_size));\n \t  if (pat)\n \t    {\n \t      emit_insn (pat);"}, {"sha": "32a0a51a37384d020562a5527a96ab5b4b77cdd9", "filename": "gcc/expr.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/079a182e02a0720f9ac230c212fd202df3e6bd9e/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/079a182e02a0720f9ac230c212fd202df3e6bd9e/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=079a182e02a0720f9ac230c212fd202df3e6bd9e", "patch": "@@ -378,6 +378,8 @@ extern void init_block_clear_fn (const char *);\n \n extern rtx emit_block_move (rtx, rtx, rtx, enum block_op_methods);\n extern rtx emit_block_move_via_libcall (rtx, rtx, rtx, bool);\n+extern rtx emit_block_move_hints (rtx, rtx, rtx, enum block_op_methods,\n+\t\t\t          unsigned int, HOST_WIDE_INT);\n \n /* Copy all or part of a value X into registers starting at REGNO.\n    The number of registers to be filled is NREGS.  */\n@@ -424,11 +426,14 @@ extern void use_group_regs (rtx *, rtx);\n /* Write zeros through the storage of OBJECT.\n    If OBJECT has BLKmode, SIZE is its length in bytes.  */\n extern rtx clear_storage (rtx, rtx, enum block_op_methods);\n+extern rtx clear_storage_hints (rtx, rtx, enum block_op_methods,\n+\t\t\t        unsigned int, HOST_WIDE_INT);\n /* The same, but always output an library call.  */\n rtx set_storage_via_libcall (rtx, rtx, rtx, bool);\n \n /* Expand a setmem pattern; return true if successful.  */\n-extern bool set_storage_via_setmem (rtx, rtx, rtx, unsigned int);\n+extern bool set_storage_via_setmem (rtx, rtx, rtx, unsigned int, \n+\t\t\t\t    unsigned int, HOST_WIDE_INT);\n \n /* Determine whether the LEN bytes can be moved by using several move\n    instructions.  Return nonzero if a call to move_by_pieces should"}, {"sha": "3ea5d410f335f2927d9ff4732c0fa69487e26da4", "filename": "gcc/gcov-io.h", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/079a182e02a0720f9ac230c212fd202df3e6bd9e/gcc%2Fgcov-io.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/079a182e02a0720f9ac230c212fd202df3e6bd9e/gcc%2Fgcov-io.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.h?ref=079a182e02a0720f9ac230c212fd202df3e6bd9e", "patch": "@@ -329,24 +329,31 @@ typedef HOST_WIDEST_INT gcov_type;\n \t\t\t\t      consecutive values of expression.  */\n \n #define GCOV_COUNTER_V_INDIR\t5  /* The most common indirect address */\n-#define GCOV_LAST_VALUE_COUNTER 5  /* The last of counters used for value\n+#define GCOV_COUNTER_AVERAGE\t6  /* The most common difference between\n+\t\t\t\t      consecutive values of expression.  */\n+#define GCOV_COUNTER_IOR\t7  /* The most common difference between\n+\t\t\t\t      consecutive values of expression.  */\n+#define GCOV_LAST_VALUE_COUNTER 7  /* The last of counters used for value\n \t\t\t\t      profiling.  */\n-#define GCOV_COUNTERS\t\t6\n+#define GCOV_COUNTERS\t\t8\n \n /* Number of counters used for value profiling.  */\n #define GCOV_N_VALUE_COUNTERS \\\n   (GCOV_LAST_VALUE_COUNTER - GCOV_FIRST_VALUE_COUNTER + 1)\n   \n   /* A list of human readable names of the counters */\n-#define GCOV_COUNTER_NAMES\t{\"arcs\", \"interval\", \"pow2\", \"single\", \"delta\", \"indirect_call\"}\n+#define GCOV_COUNTER_NAMES\t{\"arcs\", \"interval\", \"pow2\", \"single\", \\\n+\t\t\t\t \"delta\",\"indirect_call\", \"average\", \"ior\"}\n   \n   /* Names of merge functions for counters.  */\n #define GCOV_MERGE_FUNCTIONS\t{\"__gcov_merge_add\",\t\\\n \t\t\t\t \"__gcov_merge_add\",\t\\\n \t\t\t\t \"__gcov_merge_add\",\t\\\n \t\t\t\t \"__gcov_merge_single\",\t\\\n \t\t\t\t \"__gcov_merge_delta\",  \\\n-\t\t\t\t \"__gcov_merge_single\" }\n+\t\t\t\t \"__gcov_merge_single\", \\\n+\t\t\t\t \"__gcov_merge_add\",\t\\\n+\t\t\t\t \"__gcov_merge_ior\"}\n   \n /* Convert a counter index to a tag.  */\n #define GCOV_TAG_FOR_COUNTER(COUNT)\t\t\t\t\\"}, {"sha": "04fc3b2a0d8bf1ff9b3d2e7f18ed112da6ea5138", "filename": "gcc/libgcov.c", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/079a182e02a0720f9ac230c212fd202df3e6bd9e/gcc%2Flibgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/079a182e02a0720f9ac230c212fd202df3e6bd9e/gcc%2Flibgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcov.c?ref=079a182e02a0720f9ac230c212fd202df3e6bd9e", "patch": "@@ -614,6 +614,18 @@ __gcov_merge_add (gcov_type *counters, unsigned n_counters)\n }\n #endif /* L_gcov_merge_add */\n \n+#ifdef L_gcov_merge_ior\n+/* The profile merging function that just adds the counters.  It is given\n+   an array COUNTERS of N_COUNTERS old counters and it reads the same number\n+   of counters from the gcov file.  */\n+void\n+__gcov_merge_ior (gcov_type *counters, unsigned n_counters)\n+{\n+  for (; n_counters; counters++, n_counters--)\n+    *counters |= gcov_read_counter ();\n+}\n+#endif\n+\n #ifdef L_gcov_merge_single\n /* The profile merging function for choosing the most common value.\n    It is given an array COUNTERS of N_COUNTERS old counters and it\n@@ -770,6 +782,30 @@ __gcov_indirect_call_profiler (gcov_type* counter, gcov_type value,\n }\n #endif\n \n+\n+#ifdef L_gcov_average_profiler\n+/* Increase corresponding COUNTER by VALUE.  FIXME: Perhaps we want\n+   to saturate up.  */\n+\n+void\n+__gcov_average_profiler (gcov_type *counters, gcov_type value)\n+{\n+  counters[0] += value;\n+  counters[1] ++;\n+}\n+#endif\n+\n+#ifdef L_gcov_ior_profiler\n+/* Increase corresponding COUNTER by VALUE.  FIXME: Perhaps we want\n+   to saturate up.  */\n+\n+void\n+__gcov_ior_profiler (gcov_type *counters, gcov_type value)\n+{\n+  *counters |= value;\n+}\n+#endif\n+\n #ifdef L_gcov_fork\n /* A wrapper for the fork function.  Flushes the accumulated profiling data, so\n    that they are not counted twice.  */"}, {"sha": "f833a1a1f3b6e74ce2d032721ecefa0c009455ff", "filename": "gcc/profile.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/079a182e02a0720f9ac230c212fd202df3e6bd9e/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/079a182e02a0720f9ac230c212fd202df3e6bd9e/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=079a182e02a0720f9ac230c212fd202df3e6bd9e", "patch": "@@ -196,6 +196,14 @@ instrument_values (histogram_values values)\n  \t  t = GCOV_COUNTER_V_INDIR;\n  \t  break;\n \n+ \tcase HIST_TYPE_AVERAGE:\n+ \t  t = GCOV_COUNTER_AVERAGE;\n+ \t  break;\n+\n+ \tcase HIST_TYPE_IOR:\n+ \t  t = GCOV_COUNTER_IOR;\n+ \t  break;\n+\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -224,6 +232,14 @@ instrument_values (histogram_values values)\n  \t  (profile_hooks->gen_ic_profiler) (hist, t, 0);\n   \t  break;\n \n+\tcase HIST_TYPE_AVERAGE:\n+\t  (profile_hooks->gen_average_profiler) (hist, t, 0);\n+\t  break;\n+\n+\tcase HIST_TYPE_IOR:\n+\t  (profile_hooks->gen_ior_profiler) (hist, t, 0);\n+\t  break;\n+\n \tdefault:\n \t  gcc_unreachable ();\n \t}"}, {"sha": "4482ad8e3d9a6700635bc5dbd4dd097d957a45f8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/079a182e02a0720f9ac230c212fd202df3e6bd9e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/079a182e02a0720f9ac230c212fd202df3e6bd9e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=079a182e02a0720f9ac230c212fd202df3e6bd9e", "patch": "@@ -1,3 +1,7 @@\n+2007-01-28  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.dg/tree-prof/val-prof-6.c: New test.\n+\n 2007-01-28  Roger Sayle  <roger@eyesopen.com>\n \n \t* gcc.dg/large-size-array-3.c: Correct test case (portability)."}, {"sha": "c439fcffe171d98ed91d10fffac90046527b7ddc", "filename": "gcc/testsuite/gcc.dg/tree-prof/val-prof-6.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/079a182e02a0720f9ac230c212fd202df3e6bd9e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fval-prof-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/079a182e02a0720f9ac230c212fd202df3e6bd9e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fval-prof-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fval-prof-6.c?ref=079a182e02a0720f9ac230c212fd202df3e6bd9e", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+char a[1000];\n+char b[1000];\n+int size=1000;\n+__attribute__ ((noinline))\n+t(int size)\n+{\n+  __builtin_memcpy(a,b,size);\n+}\n+int\n+main()\n+{\n+  int i;\n+  for (i=0; i < size; i++)\n+    t(i);\n+  return 0;\n+}\n+/* { dg-final-use { scan-tree-dump \"Average value sum:499500\" \"optimized\"} } */\n+/* { dg-final-use { scan-tree-dump \"IOR value\" \"optimized\"} } */\n+/* { dg-final-use { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "b5088f07d32a2694f023bb4405d8d4278743ceb8", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 65, "deletions": 8, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/079a182e02a0720f9ac230c212fd202df3e6bd9e/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/079a182e02a0720f9ac230c212fd202df3e6bd9e/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=079a182e02a0720f9ac230c212fd202df3e6bd9e", "patch": "@@ -52,6 +52,8 @@ static GTY(()) tree tree_interval_profiler_fn;\n static GTY(()) tree tree_pow2_profiler_fn;\n static GTY(()) tree tree_one_value_profiler_fn;\n static GTY(()) tree tree_indirect_call_profiler_fn;\n+static GTY(()) tree tree_average_profiler_fn;\n+static GTY(()) tree tree_ior_profiler_fn;\n \f\n \n static GTY(()) tree ic_void_ptr_var;\n@@ -101,6 +103,7 @@ tree_init_edge_profiler (void)\n   tree one_value_profiler_fn_type;\n   tree gcov_type_ptr;\n   tree ic_profiler_fn_type;\n+  tree average_profiler_fn_type;\n \n   if (!gcov_type_node)\n     {\n@@ -145,6 +148,16 @@ tree_init_edge_profiler (void)\n       tree_indirect_call_profiler_fn\n \t      = build_fn_decl (\"__gcov_indirect_call_profiler\",\n \t\t\t\t     ic_profiler_fn_type);\n+      /* void (*) (gcov_type *, gcov_type)  */\n+      average_profiler_fn_type\n+\t      = build_function_type_list (void_type_node,\n+\t\t\t\t\t  gcov_type_ptr, gcov_type_node, NULL_TREE);\n+      tree_average_profiler_fn\n+\t      = build_fn_decl (\"__gcov_average_profiler\",\n+\t\t\t\t     average_profiler_fn_type);\n+      tree_ior_profiler_fn\n+\t      = build_fn_decl (\"__gcov_ior_profiler\",\n+\t\t\t\t     average_profiler_fn_type);\n     }\n }\n \n@@ -354,6 +367,48 @@ tree_gen_const_delta_profiler (histogram_value value ATTRIBUTE_UNUSED,\n   gcc_unreachable ();\n }\n \n+/* Output instructions as GIMPLE trees to increment the average histogram \n+   counter.  VALUE is the expression whose value is profiled.  TAG is the \n+   tag of the section for counters, BASE is offset of the counter position.  */\n+\n+static void\n+tree_gen_average_profiler (histogram_value value, unsigned tag, unsigned base)\n+{\n+  tree stmt = value->hvalue.stmt;\n+  block_stmt_iterator bsi = bsi_for_stmt (stmt);\n+  tree ref = tree_coverage_counter_ref (tag, base), ref_ptr;\n+  tree args, call, val;\n+  \n+  ref_ptr = force_gimple_operand_bsi (&bsi,\n+\t\t\t\t      build_addr (ref, current_function_decl),\n+\t\t\t\t      true, NULL_TREE);\n+  val = prepare_instrumented_value (&bsi, value);\n+  args = tree_cons (NULL_TREE, ref_ptr, tree_cons (NULL_TREE, val, NULL_TREE));\n+  call = build_function_call_expr (tree_average_profiler_fn, args);\n+  bsi_insert_before (&bsi, call, BSI_SAME_STMT);\n+}\n+\n+/* Output instructions as GIMPLE trees to increment the ior histogram \n+   counter.  VALUE is the expression whose value is profiled.  TAG is the \n+   tag of the section for counters, BASE is offset of the counter position.  */\n+\n+static void\n+tree_gen_ior_profiler (histogram_value value, unsigned tag, unsigned base)\n+{\n+  tree stmt = value->hvalue.stmt;\n+  block_stmt_iterator bsi = bsi_for_stmt (stmt);\n+  tree ref = tree_coverage_counter_ref (tag, base), ref_ptr;\n+  tree args, call, val;\n+  \n+  ref_ptr = force_gimple_operand_bsi (&bsi,\n+\t\t\t\t      build_addr (ref, current_function_decl),\n+\t\t\t\t      true, NULL_TREE);\n+  val = prepare_instrumented_value (&bsi, value);\n+  args = tree_cons (NULL_TREE, ref_ptr, tree_cons (NULL_TREE, val, NULL_TREE));\n+  call = build_function_call_expr (tree_ior_profiler_fn, args);\n+  bsi_insert_before (&bsi, call, BSI_SAME_STMT);\n+}\n+\n /* Return 1 if tree-based profiling is in effect, else 0.\n    If it is, set up hooks for tree-based profiling.\n    Gate for pass_tree_profile.  */\n@@ -408,19 +463,21 @@ struct tree_opt_pass pass_tree_profile =\n   PROP_gimple_leh | PROP_cfg,\t\t/* properties_provided */\n   0,\t\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_verify_stmts,\t\t\t/* todo_flags_finish */\n+  TODO_verify_stmts | TODO_dump_func,\t/* todo_flags_finish */\n   0\t\t\t\t\t/* letter */\n };\n \n struct profile_hooks tree_profile_hooks =\n {\n-  tree_init_edge_profiler,      /* init_edge_profiler */\n-  tree_gen_edge_profiler,\t/* gen_edge_profiler */\n-  tree_gen_interval_profiler,   /* gen_interval_profiler */\n-  tree_gen_pow2_profiler,       /* gen_pow2_profiler */\n-  tree_gen_one_value_profiler,  /* gen_one_value_profiler */\n-  tree_gen_const_delta_profiler,/* gen_const_delta_profiler */\n-  tree_gen_ic_profiler,\t\t/* gen_ic_profiler */\n+  tree_init_edge_profiler,       /* init_edge_profiler */\n+  tree_gen_edge_profiler,\t /* gen_edge_profiler */\n+  tree_gen_interval_profiler,    /* gen_interval_profiler */\n+  tree_gen_pow2_profiler,        /* gen_pow2_profiler */\n+  tree_gen_one_value_profiler,   /* gen_one_value_profiler */\n+  tree_gen_const_delta_profiler, /* gen_const_delta_profiler */\n+  tree_gen_ic_profiler,\t\t /* gen_ic_profiler */\n+  tree_gen_average_profiler,     /* gen_average_profiler */\n+  tree_gen_ior_profiler          /* gen_ior_profiler */\n };\n \n #include \"gt-tree-profile.h\""}, {"sha": "4734355d816a74521521030c315d416b77431354", "filename": "gcc/value-prof.c", "status": "modified", "additions": 82, "deletions": 2, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/079a182e02a0720f9ac230c212fd202df3e6bd9e/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/079a182e02a0720f9ac230c212fd202df3e6bd9e/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=079a182e02a0720f9ac230c212fd202df3e6bd9e", "patch": "@@ -248,6 +248,28 @@ dump_histogram_value (FILE *dump_file, histogram_value hist)\n       fprintf (dump_file, \".\\n\");\n       break;\n \n+    case HIST_TYPE_AVERAGE:\n+      fprintf (dump_file, \"Average value \");\n+      if (hist->hvalue.counters)\n+\t{\n+\t   fprintf (dump_file, \"sum:\"HOST_WIDEST_INT_PRINT_DEC\n+\t\t    \" times:\"HOST_WIDEST_INT_PRINT_DEC,\n+\t\t    (HOST_WIDEST_INT) hist->hvalue.counters[0],\n+\t\t    (HOST_WIDEST_INT) hist->hvalue.counters[1]);\n+\t}\n+      fprintf (dump_file, \".\\n\");\n+      break;\n+\n+    case HIST_TYPE_IOR:\n+      fprintf (dump_file, \"IOR value \");\n+      if (hist->hvalue.counters)\n+\t{\n+\t   fprintf (dump_file, \"ior:\"HOST_WIDEST_INT_PRINT_DEC,\n+\t\t    (HOST_WIDEST_INT) hist->hvalue.counters[0]);\n+\t}\n+      fprintf (dump_file, \".\\n\");\n+      break;\n+\n     case HIST_TYPE_CONST_DELTA:\n       fprintf (dump_file, \"Constant delta \");\n       if (hist->hvalue.counters)\n@@ -1404,6 +1426,45 @@ tree_stringops_transform (block_stmt_iterator *bsi)\n   return true;\n }\n \n+void\n+stringop_block_profile (tree stmt, unsigned int *expected_align,\n+\t\t\tHOST_WIDE_INT *expected_size)\n+{\n+  histogram_value histogram;\n+  histogram = gimple_histogram_value_of_type (cfun, stmt, HIST_TYPE_AVERAGE);\n+  if (!histogram)\n+    *expected_size = -1;\n+  else\n+    {\n+      gcov_type size;\n+      size = ((histogram->hvalue.counters[0]\n+\t      + histogram->hvalue.counters[0] / 2)\n+\t       / histogram->hvalue.counters[0]);\n+      /* Even if we can hold bigger value in SIZE, INT_MAX\n+\t is safe \"infinity\" for code generation strategies.  */\n+      if (size > INT_MAX)\n+\tsize = INT_MAX;\n+      *expected_size = size;\n+      gimple_remove_histogram_value (cfun, stmt, histogram);\n+    }\n+  histogram = gimple_histogram_value_of_type (cfun, stmt, HIST_TYPE_IOR);\n+  if (!histogram)\n+    *expected_size = -1;\n+  else\n+    {\n+      gcov_type count;\n+      int alignment;\n+\n+      count = histogram->hvalue.counters[0];\n+      alignment = 1;\n+      while (!(count & alignment)\n+\t     && (alignment * 2 * BITS_PER_UNIT))\n+\talignment <<= 1;\n+      *expected_align = alignment * BITS_PER_UNIT;\n+      gimple_remove_histogram_value (cfun, stmt, histogram);\n+    }\n+}\n+\n struct value_prof_hooks {\n   /* Find list of values for which we want to measure histograms.  */\n   void (*find_values_to_profile) (histogram_values *);\n@@ -1513,6 +1574,7 @@ tree_stringops_values_to_profile (tree stmt, histogram_values *values)\n   tree fndecl;\n   tree arglist;\n   tree blck_size;\n+  tree dest;\n   enum built_in_function fcode;\n \n   if (!call)\n@@ -1526,15 +1588,25 @@ tree_stringops_values_to_profile (tree stmt, histogram_values *values)\n   if (!interesting_stringop_to_profile_p (fndecl, arglist))\n     return;\n \n+  dest = TREE_VALUE (arglist);\n   if (fcode == BUILT_IN_BZERO)\n     blck_size = TREE_VALUE (TREE_CHAIN (arglist));\n   else\n     blck_size = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n \n+  if (TREE_CODE (blck_size) != INTEGER_CST)\n+    {\n+      VEC_safe_push (histogram_value, heap, *values,\n+\t\t     gimple_alloc_histogram_value (cfun, HIST_TYPE_SINGLE_VALUE,\n+\t\t\t\t\t\t   stmt, blck_size));\n+      VEC_safe_push (histogram_value, heap, *values,\n+\t\t     gimple_alloc_histogram_value (cfun, HIST_TYPE_AVERAGE,\n+\t\t\t\t\t\t   stmt, blck_size));\n+    }\n   if (TREE_CODE (blck_size) != INTEGER_CST)\n     VEC_safe_push (histogram_value, heap, *values,\n-\t\t   gimple_alloc_histogram_value (cfun, HIST_TYPE_SINGLE_VALUE,\n-\t\t\t\t\t\t stmt, blck_size));\n+\t\t   gimple_alloc_histogram_value (cfun, HIST_TYPE_IOR,\n+\t\t\t\t\t\t stmt, dest));\n }\n \n /* Find values inside STMT for that we want to measure histograms and adds\n@@ -1588,6 +1660,14 @@ tree_find_values_to_profile (histogram_values *values)\n  \t  hist->n_counters = 3;\n \t  break;\n \n+\tcase HIST_TYPE_AVERAGE:\n+\t  hist->n_counters = 3;\n+\t  break;\n+\n+\tcase HIST_TYPE_IOR:\n+\t  hist->n_counters = 3;\n+\t  break;\n+\n \tdefault:\n \t  gcc_unreachable ();\n \t}"}, {"sha": "4447b14a79c946b30c35544d3118dbaabb8021c0", "filename": "gcc/value-prof.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/079a182e02a0720f9ac230c212fd202df3e6bd9e/gcc%2Fvalue-prof.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/079a182e02a0720f9ac230c212fd202df3e6bd9e/gcc%2Fvalue-prof.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.h?ref=079a182e02a0720f9ac230c212fd202df3e6bd9e", "patch": "@@ -31,8 +31,10 @@ enum hist_type\n \t\t\t   always constant.  */\n   HIST_TYPE_CONST_DELTA, /* Tries to identify the (almost) always constant\n \t\t\t   difference between two evaluations of a value.  */\n-  HIST_TYPE_INDIR_CALL   /* Tries to identify the function that is (almost) \n+  HIST_TYPE_INDIR_CALL,   /* Tries to identify the function that is (almost) \n \t\t\t    called in indirect call */\n+  HIST_TYPE_AVERAGE,\t/* Compute average value (sum of all values).  */\n+  HIST_TYPE_IOR\t\t/* Used to compute expected alignment.  */\n };\n \n #define COUNTER_FOR_HIST_TYPE(TYPE) ((int) (TYPE) + GCOV_FIRST_VALUE_COUNTER)\n@@ -99,6 +101,12 @@ struct profile_hooks {\n \n   /* Insert code to find the most common indirect call */\n   void (*gen_ic_profiler) (histogram_value, unsigned, unsigned);\n+\n+  /* Insert code to find the average value of an expression.  */\n+  void (*gen_average_profiler) (histogram_value, unsigned, unsigned);\n+\n+  /* Insert code to ior value of an expression.  */\n+  void (*gen_ior_profiler) (histogram_value, unsigned, unsigned);\n };\n \n histogram_value gimple_histogram_value (struct function *, tree);\n@@ -111,6 +119,7 @@ void gimple_remove_stmt_histograms (struct function *, tree);\n void gimple_duplicate_stmt_histograms (struct function *, tree, struct function *, tree);\n void verify_histograms (void);\n void free_histograms (void);\n+void stringop_block_profile (tree, unsigned int *, HOST_WIDE_INT *);\n \n /* In profile.c.  */\n extern void init_branch_prob (void);"}]}