{"sha": "7d2f2a6b73fd5022f9f96ffc9e2806c8d7464112", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2QyZjJhNmI3M2ZkNTAyMmY5Zjk2ZmZjOWUyODA2YzhkNzQ2NDExMg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-05-18T18:04:29Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-05-18T18:04:29Z"}, "message": "compiler: ignore struct field tags for type conversion\n    \n    Go 1.8 includes a language change (https://golang.org/doc/go1.8#language):\n    in an explicit conversion from one struct type to another, any field\n    tags are ignored.\n    \n    This CL implements this language change in the gofrontend.  The tests\n    for this are in the gc testsuite, which will be copied into the gccgo\n    repository in due course.\n    \n    Updates golang/go#16085.\n    \n    Reviewed-on: https://go-review.googlesource.com/43614\n\nFrom-SVN: r248248", "tree": {"sha": "2efd8d24b2a654d85532463182d09865a78a7f53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2efd8d24b2a654d85532463182d09865a78a7f53"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d2f2a6b73fd5022f9f96ffc9e2806c8d7464112", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d2f2a6b73fd5022f9f96ffc9e2806c8d7464112", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d2f2a6b73fd5022f9f96ffc9e2806c8d7464112", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d2f2a6b73fd5022f9f96ffc9e2806c8d7464112/comments", "author": null, "committer": null, "parents": [{"sha": "e4171e100d6c3c5263f8e329fd71edb554a67ea5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4171e100d6c3c5263f8e329fd71edb554a67ea5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4171e100d6c3c5263f8e329fd71edb554a67ea5"}], "stats": {"total": 158, "additions": 101, "deletions": 57}, "files": [{"sha": "2a4aa2dbb0389c9d130d7c5ea9f55412e7ffbbec", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d2f2a6b73fd5022f9f96ffc9e2806c8d7464112/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d2f2a6b73fd5022f9f96ffc9e2806c8d7464112/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=7d2f2a6b73fd5022f9f96ffc9e2806c8d7464112", "patch": "@@ -1,4 +1,4 @@\n-ba68a42618d1e8516e38da093d3af731d7fd4f06\n+369e1efe19adfc5393d2235992327f39360e0554\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "053e71d6bfab83e38eced1642b4ca2ffc8644ca9", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 73, "deletions": 50, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d2f2a6b73fd5022f9f96ffc9e2806c8d7464112/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d2f2a6b73fd5022f9f96ffc9e2806c8d7464112/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=7d2f2a6b73fd5022f9f96ffc9e2806c8d7464112", "patch": "@@ -316,6 +316,16 @@ Type::do_traverse(Traverse*)\n bool\n Type::are_identical(const Type* t1, const Type* t2, bool errors_are_identical,\n \t\t    std::string* reason)\n+{\n+  return Type::are_identical_cmp_tags(t1, t2, COMPARE_TAGS,\n+\t\t\t\t      errors_are_identical, reason);\n+}\n+\n+// Like are_identical, but with a CMP_TAGS parameter.\n+\n+bool\n+Type::are_identical_cmp_tags(const Type* t1, const Type* t2, Cmp_tags cmp_tags,\n+\t\t\t     bool errors_are_identical, std::string* reason)\n {\n   if (t1 == NULL || t2 == NULL)\n     {\n@@ -387,31 +397,33 @@ Type::are_identical(const Type* t1, const Type* t2, bool errors_are_identical,\n     case TYPE_FUNCTION:\n       return t1->function_type()->is_identical(t2->function_type(),\n \t\t\t\t\t       false,\n+\t\t\t\t\t       cmp_tags,\n \t\t\t\t\t       errors_are_identical,\n \t\t\t\t\t       reason);\n \n     case TYPE_POINTER:\n-      return Type::are_identical(t1->points_to(), t2->points_to(),\n-\t\t\t\t errors_are_identical, reason);\n+      return Type::are_identical_cmp_tags(t1->points_to(), t2->points_to(),\n+\t\t\t\t\t  cmp_tags, errors_are_identical,\n+\t\t\t\t\t  reason);\n \n     case TYPE_STRUCT:\n-      return t1->struct_type()->is_identical(t2->struct_type(),\n+      return t1->struct_type()->is_identical(t2->struct_type(), cmp_tags,\n \t\t\t\t\t     errors_are_identical);\n \n     case TYPE_ARRAY:\n-      return t1->array_type()->is_identical(t2->array_type(),\n+      return t1->array_type()->is_identical(t2->array_type(), cmp_tags,\n \t\t\t\t\t    errors_are_identical);\n \n     case TYPE_MAP:\n-      return t1->map_type()->is_identical(t2->map_type(),\n+      return t1->map_type()->is_identical(t2->map_type(), cmp_tags,\n \t\t\t\t\t  errors_are_identical);\n \n     case TYPE_CHANNEL:\n-      return t1->channel_type()->is_identical(t2->channel_type(),\n+      return t1->channel_type()->is_identical(t2->channel_type(), cmp_tags,\n \t\t\t\t\t      errors_are_identical);\n \n     case TYPE_INTERFACE:\n-      return t1->interface_type()->is_identical(t2->interface_type(),\n+      return t1->interface_type()->is_identical(t2->interface_type(), cmp_tags,\n \t\t\t\t\t\terrors_are_identical);\n \n     case TYPE_CALL_MULTIPLE_RESULT:\n@@ -735,23 +747,26 @@ Type::are_convertible(const Type* lhs, const Type* rhs, std::string* reason)\n     return true;\n \n   // The types are convertible if they have identical underlying\n-  // types.\n+  // types, ignoring struct field tags.\n   if ((lhs->named_type() != NULL || rhs->named_type() != NULL)\n-      && Type::are_identical(lhs->base(), rhs->base(), true, reason))\n+      && Type::are_identical_cmp_tags(lhs->base(), rhs->base(), IGNORE_TAGS,\n+\t\t\t\t      true, reason))\n     return true;\n \n   // The types are convertible if they are both unnamed pointer types\n-  // and their pointer base types have identical underlying types.\n+  // and their pointer base types have identical underlying types,\n+  // ignoring struct field tags.\n   if (lhs->named_type() == NULL\n       && rhs->named_type() == NULL\n       && lhs->points_to() != NULL\n       && rhs->points_to() != NULL\n       && (lhs->points_to()->named_type() != NULL\n \t  || rhs->points_to()->named_type() != NULL)\n-      && Type::are_identical(lhs->points_to()->base(),\n-\t\t\t     rhs->points_to()->base(),\n-\t\t\t     true,\n-\t\t\t     reason))\n+      && Type::are_identical_cmp_tags(lhs->points_to()->base(),\n+\t\t\t\t      rhs->points_to()->base(),\n+\t\t\t\t      IGNORE_TAGS,\n+\t\t\t\t      true,\n+\t\t\t\t      reason))\n     return true;\n \n   // Integer and floating point types are convertible to each other.\n@@ -4502,7 +4517,7 @@ bool\n Function_type::is_valid_redeclaration(const Function_type* t,\n \t\t\t\t      std::string* reason) const\n {\n-  if (!this->is_identical(t, false, true, reason))\n+  if (!this->is_identical(t, false, COMPARE_TAGS, true, reason))\n     return false;\n \n   // A redeclaration of a function is required to use the same names\n@@ -4580,7 +4595,7 @@ Function_type::is_valid_redeclaration(const Function_type* t,\n \n bool\n Function_type::is_identical(const Function_type* t, bool ignore_receiver,\n-\t\t\t    bool errors_are_identical,\n+\t\t\t    Cmp_tags cmp_tags, bool errors_are_identical,\n \t\t\t    std::string* reason) const\n {\n   if (!ignore_receiver)\n@@ -4595,8 +4610,8 @@ Function_type::is_identical(const Function_type* t, bool ignore_receiver,\n \t}\n       if (r1 != NULL)\n \t{\n-\t  if (!Type::are_identical(r1->type(), r2->type(), errors_are_identical,\n-\t\t\t\t   reason))\n+\t  if (!Type::are_identical_cmp_tags(r1->type(), r2->type(), cmp_tags,\n+\t\t\t\t\t    errors_are_identical, reason))\n \t    {\n \t      if (reason != NULL && !reason->empty())\n \t\t*reason = \"receiver: \" + *reason;\n@@ -4627,8 +4642,8 @@ Function_type::is_identical(const Function_type* t, bool ignore_receiver,\n \t      return false;\n \t    }\n \n-\t  if (!Type::are_identical(p1->type(), p2->type(),\n-\t\t\t\t   errors_are_identical, NULL))\n+\t  if (!Type::are_identical_cmp_tags(p1->type(), p2->type(), cmp_tags,\n+\t\t\t\t\t    errors_are_identical, NULL))\n \t    {\n \t      if (reason != NULL)\n \t\t*reason = _(\"different parameter types\");\n@@ -4672,8 +4687,9 @@ Function_type::is_identical(const Function_type* t, bool ignore_receiver,\n \t      return false;\n \t    }\n \n-\t  if (!Type::are_identical(res1->type(), res2->type(),\n-\t\t\t\t   errors_are_identical, NULL))\n+\t  if (!Type::are_identical_cmp_tags(res1->type(), res2->type(),\n+\t\t\t\t\t    cmp_tags, errors_are_identical,\n+\t\t\t\t\t    NULL))\n \t    {\n \t      if (reason != NULL)\n \t\t*reason = _(\"different result types\");\n@@ -5803,7 +5819,7 @@ Struct_type::do_has_pointer() const\n // Whether this type is identical to T.\n \n bool\n-Struct_type::is_identical(const Struct_type* t,\n+Struct_type::is_identical(const Struct_type* t, Cmp_tags cmp_tags,\n \t\t\t  bool errors_are_identical) const\n {\n   if (this->is_struct_incomparable_ != t->is_struct_incomparable_)\n@@ -5822,20 +5838,23 @@ Struct_type::is_identical(const Struct_type* t,\n       if (pf1->field_name() != pf2->field_name())\n \treturn false;\n       if (pf1->is_anonymous() != pf2->is_anonymous()\n-\t  || !Type::are_identical(pf1->type(), pf2->type(),\n-\t\t\t\t  errors_are_identical, NULL))\n+\t  || !Type::are_identical_cmp_tags(pf1->type(), pf2->type(), cmp_tags,\n+\t\t\t\t\t   errors_are_identical, NULL))\n \treturn false;\n-      if (!pf1->has_tag())\n+      if (cmp_tags == COMPARE_TAGS)\n \t{\n-\t  if (pf2->has_tag())\n-\t    return false;\n-\t}\n-      else\n-\t{\n-\t  if (!pf2->has_tag())\n-\t    return false;\n-\t  if (pf1->tag() != pf2->tag())\n-\t    return false;\n+\t  if (!pf1->has_tag())\n+\t    {\n+\t      if (pf2->has_tag())\n+\t\treturn false;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (!pf2->has_tag())\n+\t\treturn false;\n+\t      if (pf1->tag() != pf2->tag())\n+\t\treturn false;\n+\t    }\n \t}\n     }\n   if (pf2 != fields2->end())\n@@ -7061,10 +7080,11 @@ Array_type::int_length(int64_t* plen)\n // Whether two array types are identical.\n \n bool\n-Array_type::is_identical(const Array_type* t, bool errors_are_identical) const\n+Array_type::is_identical(const Array_type* t, Cmp_tags cmp_tags,\n+\t\t\t bool errors_are_identical) const\n {\n-  if (!Type::are_identical(this->element_type(), t->element_type(),\n-\t\t\t   errors_are_identical, NULL))\n+  if (!Type::are_identical_cmp_tags(this->element_type(), t->element_type(),\n+\t\t\t\t    cmp_tags, errors_are_identical, NULL))\n     return false;\n \n   if (this->is_array_incomparable_ != t->is_array_incomparable_)\n@@ -7986,12 +8006,14 @@ Map_type::do_verify()\n // Whether two map types are identical.\n \n bool\n-Map_type::is_identical(const Map_type* t, bool errors_are_identical) const\n+Map_type::is_identical(const Map_type* t, Cmp_tags cmp_tags,\n+\t\t       bool errors_are_identical) const\n {\n-  return (Type::are_identical(this->key_type(), t->key_type(),\n-\t\t\t      errors_are_identical, NULL)\n-\t  && Type::are_identical(this->val_type(), t->val_type(),\n-\t\t\t\t errors_are_identical, NULL));\n+  return (Type::are_identical_cmp_tags(this->key_type(), t->key_type(),\n+\t\t\t\t       cmp_tags, errors_are_identical, NULL)\n+\t  && Type::are_identical_cmp_tags(this->val_type(), t->val_type(),\n+\t\t\t\t\t  cmp_tags, errors_are_identical,\n+\t\t\t\t\t  NULL));\n }\n \n // Hash code.\n@@ -8510,11 +8532,11 @@ Channel_type::do_hash_for_method(Gogo* gogo) const\n // Whether this type is the same as T.\n \n bool\n-Channel_type::is_identical(const Channel_type* t,\n+Channel_type::is_identical(const Channel_type* t, Cmp_tags cmp_tags,\n \t\t\t   bool errors_are_identical) const\n {\n-  if (!Type::are_identical(this->element_type(), t->element_type(),\n-\t\t\t   errors_are_identical, NULL))\n+  if (!Type::are_identical_cmp_tags(this->element_type(), t->element_type(),\n+\t\t\t\t    cmp_tags, errors_are_identical, NULL))\n     return false;\n   return (this->may_send_ == t->may_send_\n \t  && this->may_receive_ == t->may_receive_);\n@@ -8920,7 +8942,7 @@ Interface_type::is_unexported_method(Gogo* gogo, const std::string& name) const\n // Whether this type is identical with T.\n \n bool\n-Interface_type::is_identical(const Interface_type* t,\n+Interface_type::is_identical(const Interface_type* t, Cmp_tags cmp_tags,\n \t\t\t     bool errors_are_identical) const\n {\n   // If methods have not been finalized, then we are asking whether\n@@ -8951,8 +8973,8 @@ Interface_type::is_identical(const Interface_type* t,\n       if (p1 == this->all_methods_->end())\n \tbreak;\n       if (p1->name() != p2->name()\n-\t  || !Type::are_identical(p1->type(), p2->type(),\n-\t\t\t\t  errors_are_identical, NULL))\n+\t  || !Type::are_identical_cmp_tags(p1->type(), p2->type(), cmp_tags,\n+\t\t\t\t\t   errors_are_identical, NULL))\n \tbreak;\n     }\n \n@@ -9150,7 +9172,8 @@ Interface_type::implements_interface(const Type* t, std::string* reason) const\n       Function_type* m_fn_type = m->type()->function_type();\n       go_assert(p_fn_type != NULL && m_fn_type != NULL);\n       std::string subreason;\n-      if (!p_fn_type->is_identical(m_fn_type, true, true, &subreason))\n+      if (!p_fn_type->is_identical(m_fn_type, true, COMPARE_TAGS, true,\n+\t\t\t\t   &subreason))\n \t{\n \t  if (reason != NULL)\n \t    {"}, {"sha": "bfc0a8ba46a4e42f9ae1b4bd8b2e26e99f9fad8a", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 27, "deletions": 6, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d2f2a6b73fd5022f9f96ffc9e2806c8d7464112/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d2f2a6b73fd5022f9f96ffc9e2806c8d7464112/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=7d2f2a6b73fd5022f9f96ffc9e2806c8d7464112", "patch": "@@ -568,6 +568,22 @@ class Type\n   are_identical(const Type* lhs, const Type* rhs, bool errors_are_identical,\n \t\tstd::string* reason);\n \n+  // An argument to are_identical_cmp_tags, indicating whether or not\n+  // to compare struct field tags.\n+  enum Cmp_tags {\n+    COMPARE_TAGS,\n+    IGNORE_TAGS\n+  };\n+\n+  // Return true if two types are identical.  This is like the\n+  // are_identical function, but also takes a CMP_TAGS argument\n+  // indicating whether to compare struct tags.  Otherwise the\n+  // parameters are as for are_identical.\n+  static bool\n+  are_identical_cmp_tags(const Type* lhs, const Type* rhs,\n+\t\t\t Cmp_tags, bool errors_are_identical,\n+\t\t\t std::string* reason);\n+\n   // Return true if two types are compatible for use in a binary\n   // operation, other than a shift, comparison, or channel send.  This\n   // is an equivalence relation.\n@@ -1899,7 +1915,7 @@ class Function_type : public Type\n   // Whether this type is the same as T.\n   bool\n   is_identical(const Function_type* t, bool ignore_receiver,\n-\t       bool errors_are_identical, std::string*) const;\n+\t       Cmp_tags, bool errors_are_identical, std::string*) const;\n \n   // Record that this is a varargs function.\n   void\n@@ -2293,7 +2309,8 @@ class Struct_type : public Type\n \n   // Whether this type is identical with T.\n   bool\n-  is_identical(const Struct_type* t, bool errors_are_identical) const;\n+  is_identical(const Struct_type* t, Cmp_tags,\n+\t       bool errors_are_identical) const;\n \n   // Return whether NAME is a local field which is not exported.  This\n   // is only used for better error reporting.\n@@ -2495,7 +2512,8 @@ class Array_type : public Type\n \n   // Whether this type is identical with T.\n   bool\n-  is_identical(const Array_type* t, bool errors_are_identical) const;\n+  is_identical(const Array_type* t, Cmp_tags,\n+\t       bool errors_are_identical) const;\n \n   // Return an expression for the pointer to the values in an array.\n   Expression*\n@@ -2656,7 +2674,8 @@ class Map_type : public Type\n \n   // Whether this type is identical with T.\n   bool\n-  is_identical(const Map_type* t, bool errors_are_identical) const;\n+  is_identical(const Map_type* t, Cmp_tags,\n+\t       bool errors_are_identical) const;\n \n   // Import a map type.\n   static Map_type*\n@@ -2773,7 +2792,8 @@ class Channel_type : public Type\n \n   // Whether this type is identical with T.\n   bool\n-  is_identical(const Channel_type* t, bool errors_are_identical) const;\n+  is_identical(const Channel_type* t, Cmp_tags,\n+\t       bool errors_are_identical) const;\n \n   // Import a channel type.\n   static Channel_type*\n@@ -2883,7 +2903,8 @@ class Interface_type : public Type\n   // Whether this type is identical with T.  REASON is as in\n   // implements_interface.\n   bool\n-  is_identical(const Interface_type* t, bool errors_are_identical) const;\n+  is_identical(const Interface_type* t, Cmp_tags,\n+\t       bool errors_are_identical) const;\n \n   // Whether we can assign T to this type.  is_identical is known to\n   // be false."}]}