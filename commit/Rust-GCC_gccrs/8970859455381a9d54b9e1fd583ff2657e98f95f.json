{"sha": "8970859455381a9d54b9e1fd583ff2657e98f95f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODk3MDg1OTQ1NTM4MWE5ZDU0YjllMWZkNTgzZmYyNjU3ZTk4Zjk1Zg==", "commit": {"author": {"name": "Caroline Tice", "email": "ctice@apple.com", "date": "2006-11-14T20:55:56Z"}, "committer": {"name": "Caroline Tice", "email": "ctice@gcc.gnu.org", "date": "2006-11-14T20:55:56Z"}, "message": "Add ability to generate DWARF pubtypes section if DEBUG_PUBTYPES_SECTION is defined.\n\nAdd ability to generate DWARF pubtypes section if DEBUG_PUBTYPES_SECTION\nis defined.  Also add dejagnu testcases for pubtypes.\n\nFrom-SVN: r118826", "tree": {"sha": "a51cc53d9bd3c366c7efa487ba821d3250ded4a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a51cc53d9bd3c366c7efa487ba821d3250ded4a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8970859455381a9d54b9e1fd583ff2657e98f95f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8970859455381a9d54b9e1fd583ff2657e98f95f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8970859455381a9d54b9e1fd583ff2657e98f95f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8970859455381a9d54b9e1fd583ff2657e98f95f/comments", "author": null, "committer": null, "parents": [{"sha": "f0c1ebb73430eb3735b8a196b4795e15b0a64ca8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0c1ebb73430eb3735b8a196b4795e15b0a64ca8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0c1ebb73430eb3735b8a196b4795e15b0a64ca8"}], "stats": {"total": 546, "additions": 496, "deletions": 50}, "files": [{"sha": "8e2c89c7ac440239d0138f511997dd6cf2ef98c8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8970859455381a9d54b9e1fd583ff2657e98f95f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8970859455381a9d54b9e1fd583ff2657e98f95f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8970859455381a9d54b9e1fd583ff2657e98f95f", "patch": "@@ -1,3 +1,34 @@\n+2006-11-14  Caroline Tice  <ctice@apple.com>\n+\t\t\n+\t* dwarf2out.c (debug_pubtypes_section): New static global variable.\n+\t(pubname_entry):  Add DEF_VEC_O and DEF_VEC_ALLOC_O statements for\n+\tthis type.\n+\t(pubname_table):  Redefine as a vector.\n+\t(pubtype_table):  New static global variable, defined as a vector.\n+\t(pubname_table_allocated): Remove static global variable.\n+\t(pubname_table_in_use): Remove static global variable.\n+\t(PUBNAME_TABLE_INCREMENT): Remove constant.\n+\t(size_of_pubnames): Add parameter to deal with either pubnames or \n+\tpubtypes, and change code to deal with table being a vector.\n+\t(add_pubname):  Change to deal with table being a vector.\n+\t(add_pubtype):  New function.\n+\t(output_pubnames): Add parameter to deal with either pubnames or \n+\tpubtypes, and change code to deal with table being a vector.\n+\t(gen_array_type_die):  Add call to add_pubtype.\n+\t(gen_enumeration_type_die): Add call to add_pubtype.\n+\t(gen_struct_or_union_type_die): Add call to add_pubtype.\n+\t(gen_subroutine_type_die): Add call to add_pubtype.\n+\t(gen_typedef_die):  Add call to add_pubtype.\n+\t(dwarf2out_init): Add code to initialize pubname_table and \n+\tpubtype_table vectors; also initialize debug_pubtypes_section.\n+\t(prune_unused_types):  Change to deal with pubnames being a vector.\n+\t(dwarf2out_finish): Change to deal with pubnames being a vector; add \n+\tpubnames table to call to output_pubnames;  Add code to output pubtypes \n+\ttable if DEBUG_PUBTYPES_SECTION is defined.\n+\t* config/darwin.c (darwin_file_start):  Add DEBUG_PUBTYPES_SECTION to \n+\tdebugnames.\n+\t* config/darwin.h (DEBUG_PUBTYPES_SECTION): Define new global variable.\n+\n 2006-11-14  Joseph Myers  <joseph@codesourcery.com>\n \n \t* config/arm/arm.h (FUNCTION_ARG_ADVANCE): Only adjust"}, {"sha": "9332cc14c1861df97fae7fdc5760008bced6cbfb", "filename": "gcc/config/darwin.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8970859455381a9d54b9e1fd583ff2657e98f95f/gcc%2Fconfig%2Fdarwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8970859455381a9d54b9e1fd583ff2657e98f95f/gcc%2Fconfig%2Fdarwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.c?ref=8970859455381a9d54b9e1fd583ff2657e98f95f", "patch": "@@ -1516,6 +1516,7 @@ darwin_file_start (void)\n \t  DEBUG_LINE_SECTION,\n \t  DEBUG_LOC_SECTION,\n \t  DEBUG_PUBNAMES_SECTION,\n+\t  DEBUG_PUBTYPES_SECTION,\n \t  DEBUG_STR_SECTION,\n \t  DEBUG_RANGES_SECTION\n \t};"}, {"sha": "a518a2c7dc9d76445a6a3938e35431ec33850868", "filename": "gcc/config/darwin.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8970859455381a9d54b9e1fd583ff2657e98f95f/gcc%2Fconfig%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8970859455381a9d54b9e1fd583ff2657e98f95f/gcc%2Fconfig%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.h?ref=8970859455381a9d54b9e1fd583ff2657e98f95f", "patch": "@@ -407,6 +407,7 @@ extern GTY(()) int darwin_ms_struct;\n #define DEBUG_LINE_SECTION\t\"__DWARF,__debug_line,regular,debug\"\n #define DEBUG_LOC_SECTION\t\"__DWARF,__debug_loc,regular,debug\"\n #define DEBUG_PUBNAMES_SECTION\t\"__DWARF,__debug_pubnames,regular,debug\"\n+#define DEBUG_PUBTYPES_SECTION\t\"__DWARF,__debug_pubtypes,regular,debug\"\n #define DEBUG_STR_SECTION\t\"__DWARF,__debug_str,regular,debug\"\n #define DEBUG_RANGES_SECTION\t\"__DWARF,__debug_ranges,regular,debug\"\n "}, {"sha": "c61f3d8bd92bcf21e64071c907a647a0c62631c6", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 119, "deletions": 50, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8970859455381a9d54b9e1fd583ff2657e98f95f/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8970859455381a9d54b9e1fd583ff2657e98f95f/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=8970859455381a9d54b9e1fd583ff2657e98f95f", "patch": "@@ -156,6 +156,7 @@ static GTY(()) section *debug_macinfo_section;\n static GTY(()) section *debug_line_section;\n static GTY(()) section *debug_loc_section;\n static GTY(()) section *debug_pubnames_section;\n+static GTY(()) section *debug_pubtypes_section;\n static GTY(()) section *debug_str_section;\n static GTY(()) section *debug_ranges_section;\n static GTY(()) section *debug_frame_section;\n@@ -3759,6 +3760,9 @@ typedef struct pubname_struct GTY(())\n }\n pubname_entry;\n \n+DEF_VEC_O(pubname_entry);\n+DEF_VEC_ALLOC_O(pubname_entry, gc);\n+\n struct dw_ranges_struct GTY(())\n {\n   int block_num;\n@@ -3940,17 +3944,11 @@ static GTY(()) unsigned separate_line_info_table_in_use;\n \n /* A pointer to the base of a table that contains a list of publicly\n    accessible names.  */\n-static GTY ((length (\"pubname_table_allocated\"))) pubname_ref pubname_table;\n-\n-/* Number of elements currently allocated for pubname_table.  */\n-static GTY(()) unsigned pubname_table_allocated;\n-\n-/* Number of elements in pubname_table currently in use.  */\n-static GTY(()) unsigned pubname_table_in_use;\n+static GTY (()) VEC (pubname_entry, gc) *  pubname_table;\n \n-/* Size (in elements) of increments by which we may expand the\n-   pubname_table.  */\n-#define PUBNAME_TABLE_INCREMENT 64\n+/* A pointer to the base of a table that contains a list of publicly\n+   accessible types.  */\n+static GTY (()) VEC (pubname_entry, gc) * pubtype_table;\n \n /* Array of dies for which we should generate .debug_arange info.  */\n static GTY((length (\"arange_table_allocated\"))) dw_die_ref *arange_table;\n@@ -4115,7 +4113,7 @@ static void calc_die_sizes (dw_die_ref);\n static void mark_dies (dw_die_ref);\n static void unmark_dies (dw_die_ref);\n static void unmark_all_dies (dw_die_ref);\n-static unsigned long size_of_pubnames (void);\n+static unsigned long size_of_pubnames (VEC (pubname_entry,gc) *);\n static unsigned long size_of_aranges (void);\n static enum dwarf_form value_format (dw_attr_ref);\n static void output_value_format (dw_attr_ref);\n@@ -4126,7 +4124,8 @@ static void output_compilation_unit_header (void);\n static void output_comp_unit (dw_die_ref, int);\n static const char *dwarf2_name (tree, int);\n static void add_pubname (tree, dw_die_ref);\n-static void output_pubnames (void);\n+static void add_pubtype (tree, dw_die_ref);\n+static void output_pubnames (VEC (pubname_entry,gc) *);\n static void add_arange (tree, dw_die_ref);\n static void output_aranges (void);\n static unsigned int add_ranges (tree);\n@@ -6749,21 +6748,22 @@ unmark_all_dies (dw_die_ref die)\n       unmark_all_dies (AT_ref (a));\n }\n \n-/* Return the size of the .debug_pubnames table  generated for the\n-   compilation unit.  */\n+/* Return the size of the .debug_pubnames or .debug_pubtypes table  \n+   generated for the compilation unit.  */\n \n static unsigned long\n-size_of_pubnames (void)\n+size_of_pubnames (VEC (pubname_entry, gc) * names)\n {\n   unsigned long size;\n   unsigned i;\n+  pubname_ref p;\n \n   size = DWARF_PUBNAMES_HEADER_SIZE;\n-  for (i = 0; i < pubname_table_in_use; i++)\n-    {\n-      pubname_ref p = &pubname_table[i];\n-      size += DWARF_OFFSET_SIZE + strlen (p->name) + 1;\n-    }\n+  for (i = 0; VEC_iterate (pubname_entry, names, i, p); i++)\n+    if (names != pubtype_table\n+\t|| p->die->die_offset != 0\n+\t|| !flag_eliminate_unused_debug_types)\n+      size += strlen (p->name) + DWARF_OFFSET_SIZE + 1;\n \n   size += DWARF_OFFSET_SIZE;\n   return size;\n@@ -7330,59 +7330,95 @@ dwarf2_name (tree decl, int scope)\n static void\n add_pubname (tree decl, dw_die_ref die)\n {\n-  pubname_ref p;\n+  pubname_entry e;\n \n   if (! TREE_PUBLIC (decl))\n     return;\n \n-  if (pubname_table_in_use == pubname_table_allocated)\n+  e.die = die;\n+  e.name = xstrdup (dwarf2_name (decl, 1));\n+  VEC_safe_push (pubname_entry, gc, pubname_table, &e);\n+}\n+\n+/* Add a new entry to .debug_pubtypes if appropriate.  */\n+\n+static void\n+add_pubtype (tree decl, dw_die_ref die)\n+{\n+  pubname_entry e;\n+\n+  e.name = NULL;\n+  if ((TREE_PUBLIC (decl)\n+       || die->die_parent == comp_unit_die)\n+      && (die->die_tag == DW_TAG_typedef || COMPLETE_TYPE_P (decl)))\n     {\n-      pubname_table_allocated += PUBNAME_TABLE_INCREMENT;\n-      pubname_table\n-\t= ggc_realloc (pubname_table,\n-\t\t       (pubname_table_allocated * sizeof (pubname_entry)));\n-      memset (pubname_table + pubname_table_in_use, 0,\n-\t      PUBNAME_TABLE_INCREMENT * sizeof (pubname_entry));\n-    }\n+      e.die = die;\n+      if (TYPE_P (decl))\n+\t{\n+\t  if (TYPE_NAME (decl))\n+\t    {\n+\t      if (TREE_CODE (TYPE_NAME (decl)) == IDENTIFIER_NODE)\n+\t\te.name = xstrdup ((const char *) IDENTIFIER_POINTER \n+\t\t\t\t                              (TYPE_NAME (decl)));\n+\t      else if (TREE_CODE (TYPE_NAME (decl)) == TYPE_DECL\n+\t\t       && DECL_NAME (TYPE_NAME (decl)))\n+\t\te.name = xstrdup ((const char *) IDENTIFIER_POINTER \n+\t\t\t\t                  (DECL_NAME (TYPE_NAME (decl))));\n+             else\n+\t       e.name = xstrdup ((const char *) get_AT_string (die, DW_AT_name));\n+\t    }\n+\t}\n+      else \n+\te.name = xstrdup (dwarf2_name (decl, 1));\n \n-  p = &pubname_table[pubname_table_in_use++];\n-  p->die = die;\n-  p->name = xstrdup (dwarf2_name (decl, 1));\n+      /* If we don't have a name for the type, there's no point in adding\n+\t it to the table.  */\n+      if (e.name && e.name[0] != '\\0')\n+\tVEC_safe_push (pubname_entry, gc, pubtype_table, &e);\n+    }\n }\n \n /* Output the public names table used to speed up access to externally\n-   visible names.  For now, only generate entries for externally\n-   visible procedures.  */\n+   visible names; or the public types table used to find type definitions.  */\n \n static void\n-output_pubnames (void)\n+output_pubnames (VEC (pubname_entry, gc) * names)\n {\n   unsigned i;\n-  unsigned long pubnames_length = size_of_pubnames ();\n+  unsigned long pubnames_length = size_of_pubnames (names);\n+  pubname_ref pub;\n \n   if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4)\n     dw2_asm_output_data (4, 0xffffffff,\n       \"Initial length escape value indicating 64-bit DWARF extension\");\n-  dw2_asm_output_data (DWARF_OFFSET_SIZE, pubnames_length,\n-\t\t       \"Length of Public Names Info\");\n+  if (names == pubname_table)\n+    dw2_asm_output_data (DWARF_OFFSET_SIZE, pubnames_length,\n+\t\t\t \"Length of Public Names Info\");\n+  else\n+    dw2_asm_output_data (DWARF_OFFSET_SIZE, pubnames_length,\n+\t\t\t \"Length of Public Type Names Info\");\n   dw2_asm_output_data (2, DWARF_VERSION, \"DWARF Version\");\n   dw2_asm_output_offset (DWARF_OFFSET_SIZE, debug_info_section_label,\n \t\t\t debug_info_section,\n \t\t\t \"Offset of Compilation Unit Info\");\n   dw2_asm_output_data (DWARF_OFFSET_SIZE, next_die_offset,\n \t\t       \"Compilation Unit Length\");\n \n-  for (i = 0; i < pubname_table_in_use; i++)\n+  for (i = 0; VEC_iterate (pubname_entry, names, i, pub); i++)\n     {\n-      pubname_ref pub = &pubname_table[i];\n-\n-      /* We shouldn't see pubnames for DIEs outside of the main CU.  */\n-      gcc_assert (pub->die->die_mark);\n+      /* We shouldn't see pubnames for DIEs outside of the main CU.  */      \n+      if (names == pubname_table)\n+\tgcc_assert (pub->die->die_mark);\n \n-      dw2_asm_output_data (DWARF_OFFSET_SIZE, pub->die->die_offset,\n-\t\t\t   \"DIE offset\");\n+      if (names != pubtype_table\n+\t  || pub->die->die_offset != 0\n+\t  || !flag_eliminate_unused_debug_types)\n+\t{\n+\t  dw2_asm_output_data (DWARF_OFFSET_SIZE, pub->die->die_offset,\n+\t\t\t       \"DIE offset\");\n \n-      dw2_asm_output_nstring (pub->name, -1, \"external name\");\n+\t  dw2_asm_output_nstring (pub->name, -1, \"external name\");\n+\t}\n     }\n \n   dw2_asm_output_data (DWARF_OFFSET_SIZE, 0, NULL);\n@@ -11250,6 +11286,9 @@ gen_array_type_die (tree type, dw_die_ref context_die)\n #endif\n \n   add_type_attribute (array_die, element_type, 0, 0, context_die);\n+\n+  if (get_AT (array_die, DW_AT_name))\n+    add_pubtype (type, array_die);\n }\n \n #if 0\n@@ -11385,6 +11424,9 @@ gen_enumeration_type_die (tree type, dw_die_ref context_die)\n   else\n     add_AT_flag (type_die, DW_AT_declaration, 1);\n \n+  if (get_AT (type_die, DW_AT_name))\n+    add_pubtype (type, type_die);\n+\n   return type_die;\n }\n \n@@ -12502,6 +12544,9 @@ gen_struct_or_union_type_die (tree type, dw_die_ref context_die)\n \t  && ! decl_function_context (TYPE_STUB_DECL (type)))\n \tVEC_safe_push (tree, gc, incomplete_types, type);\n     }\n+\n+  if (get_AT (type_die, DW_AT_name))\n+    add_pubtype (type, type_die);\n }\n \n /* Generate a DIE for a subroutine _type_.  */\n@@ -12518,6 +12563,9 @@ gen_subroutine_type_die (tree type, dw_die_ref context_die)\n   add_prototyped_attribute (subr_die, type);\n   add_type_attribute (subr_die, return_type, 0, 0, context_die);\n   gen_formal_types_die (type, subr_die);\n+\n+  if (get_AT (subr_die, DW_AT_name))\n+    add_pubtype (type, subr_die);\n }\n \n /* Generate a DIE for a type definition.  */\n@@ -12557,6 +12605,9 @@ gen_typedef_die (tree decl, dw_die_ref context_die)\n \n   if (DECL_ABSTRACT (decl))\n     equate_decl_number_to_die (decl, type_die);\n+\n+  if (get_AT (type_die, DW_AT_name))\n+    add_pubtype (decl, type_die);\n }\n \n /* Generate a type description DIE.  */\n@@ -13848,6 +13899,10 @@ dwarf2out_init (const char *filename ATTRIBUTE_UNUSED)\n   /* Zero-th entry is allocated, but unused.  */\n   line_info_table_in_use = 1;\n \n+  /* Allocate the pubtypes and pubnames vectors.  */\n+  pubname_table = VEC_alloc (pubname_entry, gc, 32);\n+  pubtype_table = VEC_alloc (pubname_entry, gc, 32);\n+\n   /* Generate the initial DIE for the .debug section.  Note that the (string)\n      value given in the DW_AT_name attribute of the DW_TAG_compile_unit DIE\n      will (typically) be a relative pathname and that this pathname should be\n@@ -13874,6 +13929,10 @@ dwarf2out_init (const char *filename ATTRIBUTE_UNUSED)\n \t\t\t\t   SECTION_DEBUG, NULL);\n   debug_pubnames_section = get_section (DEBUG_PUBNAMES_SECTION,\n \t\t\t\t\tSECTION_DEBUG, NULL);\n+#ifdef DEBUG_PUBTYPES_SECTION\n+  debug_pubtypes_section = get_section (DEBUG_PUBTYPES_SECTION,\n+\t\t\t\t\tSECTION_DEBUG, NULL);\n+#endif\n   debug_str_section = get_section (DEBUG_STR_SECTION,\n \t\t\t\t   DEBUG_STR_SECTION_FLAGS, NULL);\n   debug_ranges_section = get_section (DEBUG_RANGES_SECTION,\n@@ -14157,6 +14216,7 @@ prune_unused_types (void)\n {\n   unsigned int i;\n   limbo_die_node *node;\n+  pubname_ref pub;\n \n #if ENABLE_ASSERT_CHECKING\n   /* All the marks should already be clear.  */\n@@ -14172,8 +14232,8 @@ prune_unused_types (void)\n \n   /* Also set the mark on nodes referenced from the\n      pubname_table or arange_table.  */\n-  for (i = 0; i < pubname_table_in_use; i++)\n-    prune_unused_types_mark (pubname_table[i].die, 1);\n+  for (i = 0; VEC_iterate (pubname_entry, pubname_table, i, pub); i++)\n+    prune_unused_types_mark (pub->die, 1);\n   for (i = 0; i < arange_table_in_use; i++)\n     prune_unused_types_mark (arange_table[i], 1);\n \n@@ -14352,12 +14412,21 @@ dwarf2out_finish (const char *filename)\n   output_abbrev_section ();\n \n   /* Output public names table if necessary.  */\n-  if (pubname_table_in_use)\n+  if (!VEC_empty (pubname_entry, pubname_table))\n     {\n       switch_to_section (debug_pubnames_section);\n-      output_pubnames ();\n+      output_pubnames (pubname_table);\n     }\n \n+#ifdef DEBUG_PUBTYPES_SECTION\n+  /* Output public types table if necessary.  */\n+  if (!VEC_empty (pubname_entry, pubtype_table))\n+    {\n+      switch_to_section (debug_pubtypes_section);\n+      output_pubnames (pubtype_table);\n+    }\n+#endif\n+  \n   /* Output the address range information.  We only put functions in the arange\n      table, so don't write it out if we don't have any.  */\n   if (fde_table_in_use)"}, {"sha": "2ad8fb323aba5a3e959375169f287929f0f4bc08", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8970859455381a9d54b9e1fd583ff2657e98f95f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8970859455381a9d54b9e1fd583ff2657e98f95f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8970859455381a9d54b9e1fd583ff2657e98f95f", "patch": "@@ -1,3 +1,11 @@\n+2006-11-14  Caroline Tice  <ctice@apple.com>\n+\n+\t* gcc.dg/pubtypes-1.c: New file/testcase.\n+\t* gcc.dg/pubtypes-2.c: New file/testcase.\n+\t* gcc.dg/pubtypes-3.c: New file/testcase.\n+\t* gcc.dg/pubtypes-4.c: New file/testcase.\n+\t* g++.dg/pubtypes.C: New file/testcase.\n+\n 2006-11-14  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/29106"}, {"sha": "a17ad208ed6b4f847c3be461fedf741ae2ee95f4", "filename": "gcc/testsuite/g++.dg/pubtypes.C", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8970859455381a9d54b9e1fd583ff2657e98f95f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpubtypes.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8970859455381a9d54b9e1fd583ff2657e98f95f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpubtypes.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpubtypes.C?ref=8970859455381a9d54b9e1fd583ff2657e98f95f", "patch": "@@ -0,0 +1,64 @@\n+/* { dg-do compile { target *-*-darwin* } } */\n+/* { dg-options \"-O0 -gdwarf-2 -dA -fno-eliminate-unused-debug-types\" } */\n+/* { dg-final { scan-assembler \"__debug_pubtypes\" } } */\n+/* { dg-final { scan-assembler \"long+\\[ \\t\\]+0x24+\\[ \\t\\]+\\[#;]+\\[ \\t\\]+Length of Public Type Names Info\" } } */\n+/* { dg-final { scan-assembler \"\\\"empty\\\\\\\\0\\\"+\\[ \\t\\]+\\[#;]+\\[ \\t\\]+external name\" } } */\n+/* { dg-final { scan-assembler \"\\\"A\\\\\\\\0\\\"+\\[ \\t\\]+\\[#;]+\\[ \\t\\]+external name\" } } */\n+/* { dg-final { scan-assembler \"\\\"B\\\\\\\\0\\\"+\\[ \\t\\]+\\[#;]+\\[ \\t\\]+external name\" } } */\n+\n+\n+struct A\n+{\n+  virtual ~A ();\n+  int a1;\n+};\n+\n+A::~A()\n+{\n+  a1 = 800;\n+}\n+\n+struct B : public A\n+{\n+  virtual ~B ();\n+  int b1;\n+  int b2;\n+};\n+\n+B::~B()\n+{\n+  a1 = 900;\n+  b1 = 901;\n+  b2 = 902;\n+}\n+\n+// Stop the compiler from optimizing away data.\n+void refer (A *)\n+{\n+  ;\n+}\n+\n+struct empty {};\n+\n+// Stop the compiler from optimizing away data.\n+void refer (empty *)\n+{\n+  ;\n+}\n+\n+int main (void)\n+{\n+  A alpha, *aap, *abp;\n+  B beta, *bbp;\n+  empty e;\n+\n+  alpha.a1 = 100;\n+  beta.a1 = 200; beta.b1 = 201; beta.b2 = 202;\n+\n+  aap = &alpha; refer (aap);\n+  abp = &beta;  refer (abp);\n+  bbp = &beta;  refer (bbp);\n+  refer (&e);\n+\n+  return 0;  // marker return 0\n+} // marker close brace"}, {"sha": "5c6767e8faabfcdb1ce3a3d5c81a7b3d68bd514c", "filename": "gcc/testsuite/gcc.dg/pubtypes-1.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8970859455381a9d54b9e1fd583ff2657e98f95f/gcc%2Ftestsuite%2Fgcc.dg%2Fpubtypes-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8970859455381a9d54b9e1fd583ff2657e98f95f/gcc%2Ftestsuite%2Fgcc.dg%2Fpubtypes-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpubtypes-1.c?ref=8970859455381a9d54b9e1fd583ff2657e98f95f", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-do compile { target *-*-darwin* } } */\n+/* { dg-options \"-O0 -gdwarf-2 -dA -fno-eliminate-unused-debug-types\" } */\n+/* { dg-skip-if \"Unmatchable assembly\" { mmix-*-* } { \"*\" } { \"\" } } */\n+/* { dg-final { scan-assembler \"__debug_pubtypes\" } } */\n+/* { dg-final { scan-assembler \"long+\\[ \\t\\]+0x\\[0-9a-f]+\\[ \\t\\]+\\[#;]+\\[ \\t\\]+Length of Public Type Names Info\" } } */\n+/* { dg-final { scan-assembler \"used_struct\\\\\\\\0\\\"+\\[ \\t\\]+\\[#;]+\\[ \\t\\]+external name\" } } */\n+/* { dg-final { scan-assembler \"unused_struct\\\\\\\\0\\\"+\\[ \\t\\]+\\[#;]+\\[ \\t\\]+external name\" } } */\n+\n+\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+struct used_struct \n+{\n+  int key;\n+  char *name;\n+};\n+\n+struct unused_struct\n+{\n+  int key1;\n+  int f2;\n+  double f3;\n+  char *f4;\n+  struct unused_struct *next;\n+};\n+\n+int\n+main (int argc, char **argv)\n+{\n+  int i;\n+  struct used_struct *my_list;\n+\n+  my_list = (struct used_struct *) malloc (10 * sizeof (struct used_struct));\n+  \n+  for (i = 0; i < 10; i++)\n+    {\n+      my_list[i].key = i;\n+      my_list[i].name = (char *) malloc (11);\n+      sprintf (my_list[i].name, \"Alice_%d\", i);\n+    }\n+\n+  for (i = 0; i < 10; i++)\n+    fprintf (stdout, \"Key: %d, Name: %s\\n\", my_list[i].key, my_list[i].name);\n+  \n+  return 0;\n+}"}, {"sha": "fec46617f9fe7f7b10093988ee0eab67696db548", "filename": "gcc/testsuite/gcc.dg/pubtypes-2.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8970859455381a9d54b9e1fd583ff2657e98f95f/gcc%2Ftestsuite%2Fgcc.dg%2Fpubtypes-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8970859455381a9d54b9e1fd583ff2657e98f95f/gcc%2Ftestsuite%2Fgcc.dg%2Fpubtypes-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpubtypes-2.c?ref=8970859455381a9d54b9e1fd583ff2657e98f95f", "patch": "@@ -0,0 +1,46 @@\n+/* { dg-do compile { target *-*-darwin* } } */\n+/* { dg-options \"-O0 -gdwarf-2 -dA\" } */\n+/* { dg-skip-if \"Unmatchable assembly\" { mmix-*-* } { \"*\" } { \"\" } } */\n+/* { dg-final { scan-assembler \"__debug_pubtypes\" } } */\n+/* { dg-final { scan-assembler \"long+\\[ \\t\\]+0x6a+\\[ \\t\\]+\\[#;]+\\[ \\t\\]+Length of Public Type Names Info\" } } */\n+/* { dg-final { scan-assembler \"used_struct\\\\\\\\0\\\"+\\[ \\t\\]+\\[#;]+\\[ \\t\\]+external name\" } } */\n+/* { dg-final { scan-assembler-not \"unused_struct\\\\\\\\0\\\"+\\[ \\t\\]+\\[#;]+\\[ \\t\\]+external name\" } } */\n+\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+struct used_struct \n+{\n+  int key;\n+  char *name;\n+};\n+\n+struct unused_struct\n+{\n+  int key1;\n+  int f2;\n+  double f3;\n+  char *f4;\n+  struct unused_struct *next;\n+};\n+\n+int\n+main (int argc, char **argv)\n+{\n+  int i;\n+  struct used_struct *my_list;\n+\n+  my_list = (struct used_struct *) malloc (10 * sizeof (struct used_struct));\n+  \n+  for (i = 0; i < 10; i++)\n+    {\n+      my_list[i].key = i;\n+      my_list[i].name = (char *) malloc (11);\n+      sprintf (my_list[i].name, \"Alice_%d\", i);\n+    }\n+\n+  for (i = 0; i < 10; i++)\n+    fprintf (stdout, \"Key: %d, Name: %s\\n\", my_list[i].key, my_list[i].name);\n+  \n+  return 0;\n+}"}, {"sha": "455dadf17941c164e14a3c8cdd487ee2e77285e7", "filename": "gcc/testsuite/gcc.dg/pubtypes-3.c", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8970859455381a9d54b9e1fd583ff2657e98f95f/gcc%2Ftestsuite%2Fgcc.dg%2Fpubtypes-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8970859455381a9d54b9e1fd583ff2657e98f95f/gcc%2Ftestsuite%2Fgcc.dg%2Fpubtypes-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpubtypes-3.c?ref=8970859455381a9d54b9e1fd583ff2657e98f95f", "patch": "@@ -0,0 +1,83 @@\n+/* { dg-do compile { target *-*-darwin* } } */\n+/* { dg-options \"-O0 -gdwarf-2 -dA\" } */\n+/* { dg-skip-if \"Unmatchable assembly\" { mmix-*-* } { \"*\" } { \"\" } } */\n+/* { dg-final { scan-assembler \"__debug_pubtypes\" } } */\n+/* { dg-final { scan-assembler \"long+\\[ \\t\\]+0x6a+\\[ \\t\\]+\\[#;]+\\[ \\t\\]+Length of Public Type Names Info\" } } */\n+/* { dg-final { scan-assembler \"used_struct\\\\\\\\0\\\"+\\[ \\t\\]+\\[#;]+\\[ \\t\\]+external name\" } } */\n+/* { dg-final { scan-assembler-not \"unused_struct\\\\\\\\0\\\"+\\[ \\t\\]+\\[#;]+\\[ \\t\\]+external name\" } } */\n+/* { dg-final { scan-assembler-not \"\\\"list_name_type\\\\\\\\0\\\"+\\[ \\t\\]+\\[#;]+\\[ \\t\\]+external name\" } } */\n+\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+struct used_struct \n+{\n+  int key;\n+  char *name;\n+};\n+\n+struct unused_struct\n+{\n+  int key1;\n+  int f2;\n+  double f3;\n+  char *f4;\n+  struct unused_struct *next;\n+};\n+\n+void \n+foo (struct used_struct *list)\n+{\n+  enum list_name_type {\n+    boy_name,\n+    girl_name,\n+    unknown\n+  };\n+\n+  int b_count = 0;\n+  int g_count = 0;\n+  int i;\n+  enum list_name_type *enum_list;\n+\n+  enum_list = (enum list_name_type *) malloc (10 * sizeof (enum list_name_type));\n+  \n+  for (i = 0; i < 10; i++)\n+    {\n+      if (strncmp (list[i].name, \"Alice\", 5) == 0)\n+\t{\n+\t  enum_list[i] = girl_name;\n+\t  g_count++;\n+\t}\n+      else if (strncmp (list[i].name, \"David\", 5) == 0)\n+\t{\n+\t  enum_list[i] = boy_name;\n+\t  b_count++;\n+\t}\n+      else\n+\tenum_list[i] = unknown;\n+    }\n+\n+}\n+\n+int\n+main (int argc, char **argv)\n+{\n+  int i;\n+  struct used_struct *my_list;\n+\n+  my_list = (struct used_struct *) malloc (10 * sizeof (struct used_struct));\n+  \n+  for (i = 0; i < 10; i++)\n+    {\n+      my_list[i].key = i;\n+      my_list[i].name = (char *) malloc (11);\n+      sprintf (my_list[i].name, \"Alice_%d\", i);\n+    }\n+\n+  foo (my_list);\n+\n+  for (i = 0; i < 10; i++)\n+    fprintf (stdout, \"Key: %d, Name: %s\\n\", my_list[i].key, my_list[i].name);\n+  \n+  return 0;\n+}"}, {"sha": "db222da4a7e54904b9437735f18d294bfa8440c1", "filename": "gcc/testsuite/gcc.dg/pubtypes-4.c", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8970859455381a9d54b9e1fd583ff2657e98f95f/gcc%2Ftestsuite%2Fgcc.dg%2Fpubtypes-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8970859455381a9d54b9e1fd583ff2657e98f95f/gcc%2Ftestsuite%2Fgcc.dg%2Fpubtypes-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpubtypes-4.c?ref=8970859455381a9d54b9e1fd583ff2657e98f95f", "patch": "@@ -0,0 +1,96 @@\n+/* { dg-do compile { target *-*-darwin* } } */\n+/* { dg-options \"-O0 -gdwarf-2 -dA\" } */\n+/* { dg-skip-if \"Unmatchable assembly\" { mmix-*-* } { \"*\" } { \"\" } } */\n+/* { dg-final { scan-assembler \"__debug_pubtypes\" } } */\n+/* { dg-final { scan-assembler \"long+\\[ \\t\\]+0xa1+\\[ \\t\\]+\\[#;]+\\[ \\t\\]+Length of Public Type Names Info\" } } */\n+/* { dg-final { scan-assembler \"used_struct\\\\\\\\0\\\"+\\[ \\t\\]+\\[#;]+\\[ \\t\\]+external name\" } } */\n+/* { dg-final { scan-assembler-not \"unused_struct\\\\\\\\0\\\"+\\[ \\t\\]+\\[#;]+\\[ \\t\\]+external name\" } } */\n+/* { dg-final { scan-assembler \"\\\"list_name_type\\\\\\\\0\\\"+\\[ \\t\\]+\\[#;]+\\[ \\t\\]+external name\" } } */\n+/* { dg-final { scan-assembler \"\\\"enum_list_array\\\\\\\\0\\\"+\\[ \\t\\]+\\[#;]+\\[ \\t\\]+external name\" } } */\n+/* { dg-final { scan-assembler \"\\\"field_union\\\\\\\\0\\\"+\\[ \\t\\]+\\[#;]+\\[ \\t\\]+external name\" } } */\n+\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+struct used_struct \n+{\n+  int key;\n+  char *name;\n+  union field_union\n+  {\n+    char  u_c;\n+    int   u_i;\n+    long  u_l;\n+    double u_d;\n+  } u;\n+};\n+\n+struct unused_struct\n+{\n+  int key1;\n+  int f2;\n+  double f3;\n+  char *f4;\n+  struct unused_struct *next;\n+};\n+\n+enum list_name_type {\n+  boy_name,\n+  girl_name,\n+  unknown\n+};\n+\n+\n+typedef enum list_name_type *enum_list_array;\n+\n+enum_list_array enum_list;\n+\n+void \n+foo (struct used_struct *list)\n+{\n+  int b_count = 0;\n+  int g_count = 0;\n+  int i;\n+\n+  enum_list = (enum_list_array) malloc (10 * sizeof (enum list_name_type));\n+\n+  for (i = 0; i < 10; i++)\n+    {\n+      if (strncmp (list[i].name, \"Alice\", 5) == 0)\n+\t{\n+\t  enum_list[i] = girl_name;\n+\t  g_count++;\n+\t}\n+      else if (strncmp (list[i].name, \"David\", 5) == 0)\n+\t{\n+\t  enum_list[i] = boy_name;\n+\t  b_count++;\n+\t}\n+      else\n+\tenum_list[i] = unknown;\n+    }\n+\n+}\n+\n+int\n+main (int argc, char **argv)\n+{\n+  int i;\n+  struct used_struct *my_list;\n+\n+  my_list = (struct used_struct *) malloc (10 * sizeof (struct used_struct));\n+  \n+  for (i = 0; i < 10; i++)\n+    {\n+      my_list[i].key = i;\n+      my_list[i].name = (char *) malloc (11);\n+      sprintf (my_list[i].name, \"Alice_%d\", i);\n+    }\n+\n+  foo (my_list);\n+\n+  for (i = 0; i < 10; i++)\n+    fprintf (stdout, \"Key: %d, Name: %s\\n\", my_list[i].key, my_list[i].name);\n+  \n+  return 0;\n+}"}]}