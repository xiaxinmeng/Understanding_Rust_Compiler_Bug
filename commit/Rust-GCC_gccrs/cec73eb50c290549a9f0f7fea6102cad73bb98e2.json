{"sha": "cec73eb50c290549a9f0f7fea6102cad73bb98e2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2VjNzNlYjUwYzI5MDU0OWE5ZjBmN2ZlYTYxMDJjYWQ3M2JiOThlMg==", "commit": {"author": {"name": "Stefan Olsson", "email": "stefan@snon.net", "date": "2004-01-20T06:35:21Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2004-01-20T06:35:21Z"}, "message": "mt_allocator.h: If a thread...\n\n\n2004-01-19  Stefan Olsson  <stefan@snon.net>\n\n\t* include/ext/mt_allocator.h: If a thread, when it dies, still has\n\tmemory on it's freelist this memory is not returned to global\n\tlist. Simplification of deallocate so that memory is always\n\treturned to the calling thread id's freelist instead of to\n\tglobal. Fix typos. Add volatile where appropriate.\n\nFrom-SVN: r76200", "tree": {"sha": "51963941d981c78712e09e47ebd1b2c7ba9a1b75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/51963941d981c78712e09e47ebd1b2c7ba9a1b75"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cec73eb50c290549a9f0f7fea6102cad73bb98e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cec73eb50c290549a9f0f7fea6102cad73bb98e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cec73eb50c290549a9f0f7fea6102cad73bb98e2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cec73eb50c290549a9f0f7fea6102cad73bb98e2/comments", "author": null, "committer": null, "parents": [{"sha": "50f59cd71061055cc039bbe44b5c955747719ebb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50f59cd71061055cc039bbe44b5c955747719ebb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50f59cd71061055cc039bbe44b5c955747719ebb"}], "stats": {"total": 111, "additions": 31, "deletions": 80}, "files": [{"sha": "9f0b00222047ab3aff828dfe91b3ae2df939b425", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cec73eb50c290549a9f0f7fea6102cad73bb98e2/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cec73eb50c290549a9f0f7fea6102cad73bb98e2/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=cec73eb50c290549a9f0f7fea6102cad73bb98e2", "patch": "@@ -1,3 +1,11 @@\n+2004-01-19  Stefan Olsson  <stefan@snon.net>\n+\n+\t* include/ext/mt_allocator.h: If a thread, when it dies, still has\n+\tmemory on it's freelist this memory is not returned to global\n+\tlist. Simplification of deallocate so that memory is always\n+\treturned to the calling thread id's freelist instead of to\n+\tglobal. Fix typos. Add volatile where appropriate.\n+\n 2004-01-19  Loren J. Rittle  <ljrittle@acm.org>\n \n \t* testsuite/ext/stdio_filebuf/char/10063-2.cc: Treat unbuffered."}, {"sha": "78fe2b9ec92fab351a6130c8fbcd6c31bc02bdeb", "filename": "libstdc++-v3/include/ext/mt_allocator.h", "status": "modified", "additions": 23, "deletions": 80, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cec73eb50c290549a9f0f7fea6102cad73bb98e2/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cec73eb50c290549a9f0f7fea6102cad73bb98e2/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h?ref=cec73eb50c290549a9f0f7fea6102cad73bb98e2", "patch": "@@ -1,6 +1,6 @@\n // MT-optimized allocator -*- C++ -*-\n \n-// Copyright (C) 2003 Free Software Foundation, Inc.\n+// Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -179,11 +179,10 @@ namespace __gnu_cxx\n         /*\n          * Points to the next block_record for its thread_id.\n          */\n-        block_record* next;\n+        block_record* volatile next;\n \n         /*\n          * The thread id of the thread which has requested this block.\n-         * All blocks are initially \"owned\" by global pool thread id 0.\n          */\n         size_t thread_id;\n       };\n@@ -195,17 +194,17 @@ namespace __gnu_cxx\n          * thread id. Memory to these \"arrays\" is allocated in _S_init()\n          * for _S_max_threads + global pool 0.\n          */\n-        block_record** first;\n-        block_record** last;\n+        block_record** volatile first;\n+        block_record** volatile last;\n \n         /*\n          * An \"array\" of counters used to keep track of the amount of blocks\n          * that are on the freelist/used for each thread id.\n          * Memory to these \"arrays\" is allocated in _S_init()\n          * for _S_max_threads + global pool 0.\n          */\n-        size_t* free;\n-        size_t* used;\n+        size_t* volatile free;\n+        size_t* volatile used;\n \n         /*\n          * Each bin has its own mutex which is used to ensure data integrity\n@@ -221,7 +220,7 @@ namespace __gnu_cxx\n        * An \"array\" of bin_records each of which represents a specific\n        * power of 2 size. Memory to this \"array\" is allocated in _S_init().\n        */\n-      static bin_record* _S_bin;\n+      static bin_record* volatile _S_bin;\n \n     public:\n       pointer\n@@ -478,37 +477,24 @@ namespace __gnu_cxx\n               }\n \n             /*\n-             * Did we allocate this block?\n-             * - Yes, return it to our freelist\n-             * - No, return it to global pool\n+             * Return this block to our list and update\n+             * counters and owner id as needed\n              */\n-            if (thread_id == block->thread_id)\n-              {\n-                if (_S_bin[bin].first[thread_id] == NULL)\n-                  _S_bin[bin].first[thread_id] = block;\n-                else\n-                  _S_bin[bin].last[thread_id]->next = block;\n-\n-                _S_bin[bin].last[thread_id] = block;\n-\n-                _S_bin[bin].free[thread_id]++;\n-                _S_bin[bin].used[thread_id]--;\n-              }\n+            if (_S_bin[bin].first[thread_id] == NULL)\n+              _S_bin[bin].first[thread_id] = block;\n             else\n-              {\n-                __gthread_mutex_lock(_S_bin[bin].mutex);\n+              _S_bin[bin].last[thread_id]->next = block;\n \n-                if (_S_bin[bin].first[0] == NULL)\n-                  _S_bin[bin].first[0] = block;\n-                else\n-                  _S_bin[bin].last[0]->next = block;\n+            _S_bin[bin].last[thread_id] = block;\n \n-                _S_bin[bin].last[0] = block;\n+            _S_bin[bin].free[thread_id]++;\n \n-                _S_bin[bin].free[0]++;\n+            if (thread_id == block->thread_id)\n+              _S_bin[bin].used[thread_id]--;\n+            else\n+              {\n                 _S_bin[bin].used[block->thread_id]--;\n-\n-                __gthread_mutex_unlock(_S_bin[bin].mutex);\n+                block->thread_id = thread_id;\n               }\n           }\n         else\n@@ -639,13 +625,14 @@ namespace __gnu_cxx\n \n           if (!_S_bin[bin].free)\n             __throw_bad_alloc();\n+\n           _S_bin[bin].used = (size_t*) malloc(sizeof(size_t) * __n);\n \n           if (!_S_bin[bin].used)\n             __throw_bad_alloc();\n \n #ifdef __GTHREADS\n-          _S_bin[bin].mutex =(__gthread_mutex_t*)  malloc(sizeof(__gthread_mutex_t));\n+          _S_bin[bin].mutex =(__gthread_mutex_t*) malloc(sizeof(__gthread_mutex_t));\n \n #ifdef __GTHREAD_MUTEX_INIT\n \t  {\n@@ -676,35 +663,6 @@ namespace __gnu_cxx\n     __mt_alloc<_Tp>::\n     _S_thread_key_destr(void* freelist_pos)\n     {\n-      /*\n-       * If the thread - when it dies - still has records on its\n-       * freelist we return them to the global pool here.\n-       */\n-      for (size_t bin = 0; bin < _S_no_of_bins; bin++)\n-        {\n-          block_record* block =\n-            _S_bin[bin].first[((thread_record*)freelist_pos)->id];\n-\n-          if (block != NULL)\n-            {\n-              __gthread_mutex_lock(_S_bin[bin].mutex);\n-              while (block != NULL)\n-                {\n-                  if (_S_bin[bin].first[0] == NULL)\n-                    _S_bin[bin].first[0] = block;\n-                  else\n-                    _S_bin[bin].last[0]->next = block;\n-\n-                  _S_bin[bin].last[0] = block;\n-                  block = block->next;\n-                  _S_bin[bin].free[0]++;\n-                }\n-\n-              _S_bin[bin].last[0]->next = NULL;\n-              __gthread_mutex_unlock(_S_bin[bin].mutex);\n-            }\n-        }\n-\n       /*\n        * Return this thread id record to front of thread_freelist\n        */\n@@ -727,7 +685,7 @@ namespace __gnu_cxx\n        */\n       if (__gthread_active_p())\n         {\n-          thread_record* volatile freelist_pos;\n+          thread_record* freelist_pos;\n \n           if ((freelist_pos =\n               (thread_record*)__gthread_getspecific(_S_thread_key)) == NULL)\n@@ -743,21 +701,6 @@ namespace __gnu_cxx\n               __gthread_mutex_unlock(&_S_thread_freelist_mutex);\n \n               __gthread_setspecific(_S_thread_key, (void*)freelist_pos);\n-\n-              /*\n-               * Since thread_ids may/will be reused (espcially in\n-               * producer/consumer applications) we make sure that the\n-               * list pointers and free counter is reset BUT as the\n-               * \"old\" thread may still be owner of some memory (which\n-               * is referred to by other threads and thus not freed)\n-               * we don't reset the used counter.\n-               */\n-              for (size_t bin = 0; bin < _S_no_of_bins; bin++)\n-                {\n-                  _S_bin[bin].first[freelist_pos->id] = NULL;\n-                  _S_bin[bin].last[freelist_pos->id] = NULL;\n-                  _S_bin[bin].free[freelist_pos->id] = 0;\n-                }\n             }\n \n           return freelist_pos->id;\n@@ -839,7 +782,7 @@ namespace __gnu_cxx\n #endif\n \n   template<typename _Tp> typename __mt_alloc<_Tp>::bin_record*\n-  __mt_alloc<_Tp>::_S_bin = NULL;\n+  volatile __mt_alloc<_Tp>::_S_bin = NULL;\n } // namespace __gnu_cxx\n \n #endif"}]}