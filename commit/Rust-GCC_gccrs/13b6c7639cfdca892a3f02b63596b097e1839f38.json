{"sha": "13b6c7639cfdca892a3f02b63596b097e1839f38", "node_id": "C_kwDOANBUbNoAKDEzYjZjNzYzOWNmZGNhODkyYTNmMDJiNjM1OTZiMDk3ZTE4MzlmMzg", "commit": {"author": {"name": "Andrew Stubbs", "email": "ams@codesourcery.com", "date": "2021-11-11T13:43:04Z"}, "committer": {"name": "Hafiz Abid Qadeer", "email": "abidh@codesourcery.com", "date": "2021-12-08T09:47:16Z"}, "message": "dwarf: Multi-register CFI address support.\n\nAdd support for architectures such as AMD GCN, in which the pointer size is\nlarger than the register size.  This allows the CFI information to include\nmulti-register locations for the stack pointer, frame pointer, and return\naddress.\n\nThis patch was originally posted by Andrew Stubbs in\nhttps://gcc.gnu.org/pipermail/gcc-patches/2020-August/552873.html\n\nIt has now been re-worked according to the review comments. It does not use\nDW_OP_piece or DW_OP_LLVM_piece_end. Instead it uses\nDW_OP_bregx/DW_OP_shl/DW_OP_bregx/DW_OP_plus to build the CFA from multiple\nconsecutive registers. Here is how .debug_frame looks before and after this\npatch:\n\n$ cat factorial.c\nint factorial(int n) {\n  if (n == 0) return 1;\n  return n * factorial (n - 1);\n}\n\n$ amdgcn-amdhsa-gcc -g factorial.c -O0 -c -o fac.o\n$ llvm-dwarfdump -debug-frame fac.o\n\n*** without this patch (edited for brevity)***\n\n00000000 00000014 ffffffff CIE\n\n  DW_CFA_def_cfa: reg48 +0\n  DW_CFA_register: reg16 reg50\n\n00000018 0000002c 00000000 FDE cie=00000000 pc=00000000...000001ac\n  DW_CFA_advance_loc4: 96\n  DW_CFA_offset: reg46 0\n  DW_CFA_offset: reg47 4\n  DW_CFA_offset: reg50 8\n  DW_CFA_offset: reg51 12\n  DW_CFA_offset: reg16 8\n  DW_CFA_advance_loc4: 4\n  DW_CFA_def_cfa_sf: reg46 -16\n\n*** with this patch (edited for brevity)***\n\n00000000 00000024 ffffffff CIE\n\n  DW_CFA_def_cfa_expression: DW_OP_bregx SGPR49+0, DW_OP_const1u 0x20, DW_OP_shl, DW_OP_bregx SGPR48+0, DW_OP_plus\n  DW_CFA_expression: reg16 DW_OP_bregx SGPR51+0, DW_OP_const1u 0x20, DW_OP_shl, DW_OP_bregx SGPR50+0, DW_OP_plus\n\n00000028 0000003c 00000000 FDE cie=00000000 pc=00000000...000001ac\n  DW_CFA_advance_loc4: 96\n  DW_CFA_offset: reg46 0\n  DW_CFA_offset: reg47 4\n  DW_CFA_offset: reg50 8\n  DW_CFA_offset: reg51 12\n  DW_CFA_offset: reg16 8\n  DW_CFA_advance_loc4: 4\n  DW_CFA_def_cfa_expression: DW_OP_bregx SGPR47+0, DW_OP_const1u 0x20, DW_OP_shl, DW_OP_bregx SGPR46+0, DW_OP_plus, DW_OP_lit16, DW_OP_minus\n\ngcc/ChangeLog:\n\n\t* dwarf2cfi.c (dw_stack_pointer_regnum): Change type to struct cfa_reg.\n\t(dw_frame_pointer_regnum): Likewise.\n\t(new_cfi_row): Use set_by_dwreg.\n\t(get_cfa_from_loc_descr): Use set_by_dwreg.  Support register spans.\n\thandle DW_OP_bregx with DW_OP_breg{0-31}.  Support DW_OP_lit*,\n\tDW_OP_const*, DW_OP_minus, DW_OP_shl and DW_OP_plus.\n\t(lookup_cfa_1): Use set_by_dwreg.\n\t(def_cfa_0): Update for cfa_reg and support register spans.\n\t(reg_save): Change sreg parameter to struct cfa_reg.  Support register\n\tspans.\n\t(dwf_cfa_reg): New function.\n\t(dwarf2out_flush_queued_reg_saves): Use dwf_cfa_reg instead of\n\tdwf_regno.\n\t(dwarf2out_frame_debug_def_cfa): Likewise.\n\t(dwarf2out_frame_debug_adjust_cfa): Likewise.\n\t(dwarf2out_frame_debug_cfa_offset): Likewise.  Update reg_save usage.\n\t(dwarf2out_frame_debug_cfa_register): Likewise.\n\t(dwarf2out_frame_debug_expr): Likewise.\n\t(create_pseudo_cfg): Use set_by_dwreg.\n\t(initial_return_save): Use set_by_dwreg and dwf_cfa_reg,\n\t(create_cie_data): Use dwf_cfa_reg.\n\t(execute_dwarf2_frame): Use dwf_cfa_reg.\n\t(dump_cfi_row): Use set_by_dwreg.\n\t* dwarf2out.c (build_span_loc, build_breg_loc): New function.\n\t(build_cfa_loc): Support register spans.\n\t(build_cfa_aligned_loc): Update cfa_reg usage.\n\t(convert_cfa_to_fb_loc_list): Use set_by_dwreg.\n\t* dwarf2out.h (struct cfa_reg): New type.\n\t(struct dw_cfa_location): Use struct cfa_reg.\n\t(build_span_loc): New prototype.\n\nco-authored-By: Hafiz Abid Qadeer <abidh@codesourcery.com>", "tree": {"sha": "f79c345be55f12d9d6282661bc5e5cc39d033086", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f79c345be55f12d9d6282661bc5e5cc39d033086"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/13b6c7639cfdca892a3f02b63596b097e1839f38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13b6c7639cfdca892a3f02b63596b097e1839f38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13b6c7639cfdca892a3f02b63596b097e1839f38", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13b6c7639cfdca892a3f02b63596b097e1839f38/comments", "author": {"login": "ams-cs", "id": 2235130, "node_id": "MDQ6VXNlcjIyMzUxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2235130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ams-cs", "html_url": "https://github.com/ams-cs", "followers_url": "https://api.github.com/users/ams-cs/followers", "following_url": "https://api.github.com/users/ams-cs/following{/other_user}", "gists_url": "https://api.github.com/users/ams-cs/gists{/gist_id}", "starred_url": "https://api.github.com/users/ams-cs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ams-cs/subscriptions", "organizations_url": "https://api.github.com/users/ams-cs/orgs", "repos_url": "https://api.github.com/users/ams-cs/repos", "events_url": "https://api.github.com/users/ams-cs/events{/privacy}", "received_events_url": "https://api.github.com/users/ams-cs/received_events", "type": "User", "site_admin": false}, "committer": {"login": "abidh", "id": 4067533, "node_id": "MDQ6VXNlcjQwNjc1MzM=", "avatar_url": "https://avatars.githubusercontent.com/u/4067533?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abidh", "html_url": "https://github.com/abidh", "followers_url": "https://api.github.com/users/abidh/followers", "following_url": "https://api.github.com/users/abidh/following{/other_user}", "gists_url": "https://api.github.com/users/abidh/gists{/gist_id}", "starred_url": "https://api.github.com/users/abidh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abidh/subscriptions", "organizations_url": "https://api.github.com/users/abidh/orgs", "repos_url": "https://api.github.com/users/abidh/repos", "events_url": "https://api.github.com/users/abidh/events{/privacy}", "received_events_url": "https://api.github.com/users/abidh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "691f05c2197a7b79cb2d7fdbabe3182e22da320a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/691f05c2197a7b79cb2d7fdbabe3182e22da320a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/691f05c2197a7b79cb2d7fdbabe3182e22da320a"}], "stats": {"total": 354, "additions": 284, "deletions": 70}, "files": [{"sha": "9dd1dfe71b766b3bf32ff44ae2b8753d943554ff", "filename": "gcc/dwarf2cfi.c", "status": "modified", "additions": 200, "deletions": 64, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13b6c7639cfdca892a3f02b63596b097e1839f38/gcc%2Fdwarf2cfi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13b6c7639cfdca892a3f02b63596b097e1839f38/gcc%2Fdwarf2cfi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2cfi.c?ref=13b6c7639cfdca892a3f02b63596b097e1839f38", "patch": "@@ -229,8 +229,8 @@ static vec<queued_reg_save> queued_reg_saves;\n static bool any_cfis_emitted;\n \n /* Short-hand for commonly used register numbers.  */\n-static unsigned dw_stack_pointer_regnum;\n-static unsigned dw_frame_pointer_regnum;\n+static struct cfa_reg dw_stack_pointer_regnum;\n+static struct cfa_reg dw_frame_pointer_regnum;\n \f\n /* Hook used by __throw.  */\n \n@@ -430,7 +430,7 @@ new_cfi_row (void)\n {\n   dw_cfi_row *row = ggc_cleared_alloc<dw_cfi_row> ();\n \n-  row->cfa.reg = INVALID_REGNUM;\n+  row->cfa.reg.set_by_dwreg (INVALID_REGNUM);\n \n   return row;\n }\n@@ -538,7 +538,7 @@ get_cfa_from_loc_descr (dw_cfa_location *cfa, struct dw_loc_descr_node *loc)\n   cfa->offset = 0;\n   cfa->base_offset = 0;\n   cfa->indirect = 0;\n-  cfa->reg = -1;\n+  cfa->reg.set_by_dwreg (INVALID_REGNUM);\n \n   for (ptr = loc; ptr != NULL; ptr = ptr->dw_loc_next)\n     {\n@@ -578,10 +578,10 @@ get_cfa_from_loc_descr (dw_cfa_location *cfa, struct dw_loc_descr_node *loc)\n \tcase DW_OP_reg29:\n \tcase DW_OP_reg30:\n \tcase DW_OP_reg31:\n-\t  cfa->reg = op - DW_OP_reg0;\n+\t  cfa->reg.set_by_dwreg (op - DW_OP_reg0);\n \t  break;\n \tcase DW_OP_regx:\n-\t  cfa->reg = ptr->dw_loc_oprnd1.v.val_int;\n+\t  cfa->reg.set_by_dwreg (ptr->dw_loc_oprnd1.v.val_int);\n \t  break;\n \tcase DW_OP_breg0:\n \tcase DW_OP_breg1:\n@@ -615,16 +615,95 @@ get_cfa_from_loc_descr (dw_cfa_location *cfa, struct dw_loc_descr_node *loc)\n \tcase DW_OP_breg29:\n \tcase DW_OP_breg30:\n \tcase DW_OP_breg31:\n-\t  cfa->reg = op - DW_OP_breg0;\n-\t  cfa->base_offset = ptr->dw_loc_oprnd1.v.val_int;\n-\t  break;\n \tcase DW_OP_bregx:\n-\t  cfa->reg = ptr->dw_loc_oprnd1.v.val_int;\n-\t  cfa->base_offset = ptr->dw_loc_oprnd2.v.val_int;\n+\t  if (cfa->reg.reg == INVALID_REGNUM)\n+\t    {\n+\t      unsigned regno\n+\t\t= (op == DW_OP_bregx\n+\t\t   ? ptr->dw_loc_oprnd1.v.val_int : op - DW_OP_breg0);\n+\t      cfa->reg.set_by_dwreg (regno);\n+\t      cfa->base_offset = ptr->dw_loc_oprnd1.v.val_int;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Handle case when span can cover multiple registers.  We\n+\t\t only support the simple case of consecutive registers\n+\t\t all with the same size.  DWARF that we are dealing with\n+\t\t will look something like:\n+\t\t <DW_OP_bregx: (r49) 0; DW_OP_const1u: 32; DW_OP_shl;\n+\t\t  DW_OP_bregx: (r48) 0; DW_OP_plus> */\n+\n+\t      unsigned regno\n+\t\t= (op == DW_OP_bregx\n+\t\t   ? ptr->dw_loc_oprnd1.v.val_int : op - DW_OP_breg0);\n+\t      gcc_assert (regno == cfa->reg.reg - 1);\n+\t      cfa->reg.span++;\n+\t      /* From all the consecutive registers used, we want to set\n+\t\t cfa->reg.reg to lower number register.  */\n+\t      cfa->reg.reg = regno;\n+\t      /* The offset was the shift value.  Use it to get the\n+\t\t span_width and then set it to 0.  */\n+\t      cfa->reg.span_width = cfa->offset.to_constant () / 8;\n+\t      cfa->offset = 0;\n+\t    }\n \t  break;\n \tcase DW_OP_deref:\n \t  cfa->indirect = 1;\n \t  break;\n+\tcase DW_OP_shl:\n+\t  break;\n+\tcase DW_OP_lit0:\n+\tcase DW_OP_lit1:\n+\tcase DW_OP_lit2:\n+\tcase DW_OP_lit3:\n+\tcase DW_OP_lit4:\n+\tcase DW_OP_lit5:\n+\tcase DW_OP_lit6:\n+\tcase DW_OP_lit7:\n+\tcase DW_OP_lit8:\n+\tcase DW_OP_lit9:\n+\tcase DW_OP_lit10:\n+\tcase DW_OP_lit11:\n+\tcase DW_OP_lit12:\n+\tcase DW_OP_lit13:\n+\tcase DW_OP_lit14:\n+\tcase DW_OP_lit15:\n+\tcase DW_OP_lit16:\n+\tcase DW_OP_lit17:\n+\tcase DW_OP_lit18:\n+\tcase DW_OP_lit19:\n+\tcase DW_OP_lit20:\n+\tcase DW_OP_lit21:\n+\tcase DW_OP_lit22:\n+\tcase DW_OP_lit23:\n+\tcase DW_OP_lit24:\n+\tcase DW_OP_lit25:\n+\tcase DW_OP_lit26:\n+\tcase DW_OP_lit27:\n+\tcase DW_OP_lit28:\n+\tcase DW_OP_lit29:\n+\tcase DW_OP_lit30:\n+\tcase DW_OP_lit31:\n+\t  gcc_assert (known_eq (cfa->offset, 0));\n+\t  cfa->offset = op - DW_OP_lit0;\n+\t  break;\n+\tcase DW_OP_const1u:\n+\tcase DW_OP_const1s:\n+\tcase DW_OP_const2u:\n+\tcase DW_OP_const2s:\n+\tcase DW_OP_const4s:\n+\tcase DW_OP_const8s:\n+\tcase DW_OP_constu:\n+\tcase DW_OP_consts:\n+\t  gcc_assert (known_eq (cfa->offset, 0));\n+\t  cfa->offset = ptr->dw_loc_oprnd1.v.val_int;\n+\t  break;\n+\tcase DW_OP_minus:\n+\t  cfa->offset = -cfa->offset;\n+\t  break;\n+\tcase DW_OP_plus:\n+\t  /* The offset is already in place.  */\n+\t  break;\n \tcase DW_OP_plus_uconst:\n \t  cfa->offset = ptr->dw_loc_oprnd1.v.val_unsigned;\n \t  break;\n@@ -648,11 +727,11 @@ lookup_cfa_1 (dw_cfi_ref cfi, dw_cfa_location *loc, dw_cfa_location *remember)\n       loc->offset = cfi->dw_cfi_oprnd1.dw_cfi_offset;\n       break;\n     case DW_CFA_def_cfa_register:\n-      loc->reg = cfi->dw_cfi_oprnd1.dw_cfi_reg_num;\n+      loc->reg.set_by_dwreg (cfi->dw_cfi_oprnd1.dw_cfi_reg_num);\n       break;\n     case DW_CFA_def_cfa:\n     case DW_CFA_def_cfa_sf:\n-      loc->reg = cfi->dw_cfi_oprnd1.dw_cfi_reg_num;\n+      loc->reg.set_by_dwreg (cfi->dw_cfi_oprnd1.dw_cfi_reg_num);\n       loc->offset = cfi->dw_cfi_oprnd2.dw_cfi_offset;\n       break;\n     case DW_CFA_def_cfa_expression:\n@@ -798,6 +877,7 @@ def_cfa_0 (dw_cfa_location *old_cfa, dw_cfa_location *new_cfa)\n \n   HOST_WIDE_INT const_offset;\n   if (new_cfa->reg == old_cfa->reg\n+      && new_cfa->reg.span == 1\n       && !new_cfa->indirect\n       && !old_cfa->indirect\n       && new_cfa->offset.is_constant (&const_offset))\n@@ -814,7 +894,8 @@ def_cfa_0 (dw_cfa_location *old_cfa, dw_cfa_location *new_cfa)\n     }\n   else if (new_cfa->offset.is_constant ()\n \t   && known_eq (new_cfa->offset, old_cfa->offset)\n-\t   && old_cfa->reg != INVALID_REGNUM\n+\t   && old_cfa->reg.reg != INVALID_REGNUM\n+\t   && new_cfa->reg.span == 1\n \t   && !new_cfa->indirect\n \t   && !old_cfa->indirect)\n     {\n@@ -824,10 +905,11 @@ def_cfa_0 (dw_cfa_location *old_cfa, dw_cfa_location *new_cfa)\n \t been set as a register plus offset rather than a general\n \t DW_CFA_def_cfa_expression.  */\n       cfi->dw_cfi_opc = DW_CFA_def_cfa_register;\n-      cfi->dw_cfi_oprnd1.dw_cfi_reg_num = new_cfa->reg;\n+      cfi->dw_cfi_oprnd1.dw_cfi_reg_num = new_cfa->reg.reg;\n     }\n   else if (new_cfa->indirect == 0\n-\t   && new_cfa->offset.is_constant (&const_offset))\n+\t   && new_cfa->offset.is_constant (&const_offset)\n+\t   && new_cfa->reg.span == 1)\n     {\n       /* Construct a \"DW_CFA_def_cfa <register> <offset>\" instruction,\n \t indicating the CFA register has changed to <register> with\n@@ -838,7 +920,7 @@ def_cfa_0 (dw_cfa_location *old_cfa, dw_cfa_location *new_cfa)\n \tcfi->dw_cfi_opc = DW_CFA_def_cfa_sf;\n       else\n \tcfi->dw_cfi_opc = DW_CFA_def_cfa;\n-      cfi->dw_cfi_oprnd1.dw_cfi_reg_num = new_cfa->reg;\n+      cfi->dw_cfi_oprnd1.dw_cfi_reg_num = new_cfa->reg.reg;\n       cfi->dw_cfi_oprnd2.dw_cfi_offset = const_offset;\n     }\n   else\n@@ -885,18 +967,18 @@ def_cfa_1 (dw_cfa_location *new_cfa)\n }\n \n /* Add the CFI for saving a register.  REG is the CFA column number.\n-   If SREG is -1, the register is saved at OFFSET from the CFA;\n+   If SREG is INVALID_REGISTER, the register is saved at OFFSET from the CFA;\n    otherwise it is saved in SREG.  */\n \n static void\n-reg_save (unsigned int reg, unsigned int sreg, poly_int64 offset)\n+reg_save (unsigned int reg, struct cfa_reg sreg, poly_int64 offset)\n {\n   dw_fde_ref fde = cfun ? cfun->fde : NULL;\n   dw_cfi_ref cfi = new_cfi ();\n \n   cfi->dw_cfi_oprnd1.dw_cfi_reg_num = reg;\n \n-  if (sreg == INVALID_REGNUM)\n+  if (sreg.reg == INVALID_REGNUM)\n     {\n       HOST_WIDE_INT const_offset;\n       /* When stack is aligned, store REG using DW_CFA_expression with FP.  */\n@@ -926,18 +1008,24 @@ reg_save (unsigned int reg, unsigned int sreg, poly_int64 offset)\n \t    = build_cfa_loc (&cur_row->cfa, offset);\n \t}\n     }\n-  else if (sreg == reg)\n+  else if (sreg.reg == reg)\n     {\n       /* While we could emit something like DW_CFA_same_value or\n \t DW_CFA_restore, we never expect to see something like that\n \t in a prologue.  This is more likely to be a bug.  A backend\n \t can always bypass this by using REG_CFA_RESTORE directly.  */\n       gcc_unreachable ();\n     }\n+  else if (sreg.span > 1)\n+    {\n+      cfi->dw_cfi_opc = DW_CFA_expression;\n+      cfi->dw_cfi_oprnd1.dw_cfi_reg_num = reg;\n+      cfi->dw_cfi_oprnd2.dw_cfi_loc = build_span_loc (sreg);\n+    }\n   else\n     {\n       cfi->dw_cfi_opc = DW_CFA_register;\n-      cfi->dw_cfi_oprnd2.dw_cfi_reg_num = sreg;\n+      cfi->dw_cfi_oprnd2.dw_cfi_reg_num = sreg.reg;\n     }\n \n   add_cfi (cfi);\n@@ -1018,6 +1106,44 @@ dwf_regno (const_rtx reg)\n   return DWARF_FRAME_REGNUM (REGNO (reg));\n }\n \n+/* Like dwf_regno, but when the value can span multiple registers.  */\n+\n+static struct cfa_reg\n+dwf_cfa_reg (rtx reg)\n+{\n+  struct cfa_reg result;\n+\n+  gcc_assert (REGNO (reg) < FIRST_PSEUDO_REGISTER);\n+\n+  result.reg = dwf_regno (reg);\n+  result.span = 1;\n+  result.span_width = 0;\n+\n+  rtx span = targetm.dwarf_register_span (reg);\n+  if (span)\n+    {\n+      /* We only support the simple case of consecutive registers all with the\n+\t same size.  */\n+      result.span = XVECLEN (span, 0);\n+      result.span_width = GET_MODE_SIZE (GET_MODE (XVECEXP (span, 0, 0)))\n+\t\t\t  .to_constant ();\n+\n+      if (CHECKING_P)\n+\t{\n+\t  /* Ensure that the above assumption is accurate.  */\n+\t  for (unsigned int i = 0; i < result.span; i++)\n+\t    {\n+\t      gcc_assert (GET_MODE_SIZE (GET_MODE (XVECEXP (span, 0, i)))\n+\t\t\t  .to_constant ()  == result.span_width);\n+\t      gcc_assert (REG_P (XVECEXP (span, 0, i)));\n+\t      gcc_assert (dwf_regno (XVECEXP (span, 0, i)) == result.reg + i);\n+\t    }\n+\t}\n+    }\n+\n+  return result;\n+}\n+\n /* Compare X and Y for equivalence.  The inputs may be REGs or PC_RTX.  */\n \n static bool\n@@ -1086,7 +1212,8 @@ dwarf2out_flush_queued_reg_saves (void)\n \n   FOR_EACH_VEC_ELT (queued_reg_saves, i, q)\n     {\n-      unsigned int reg, sreg;\n+      unsigned int reg;\n+      struct cfa_reg sreg;\n \n       record_reg_saved_in_reg (q->saved_reg, q->reg);\n \n@@ -1095,9 +1222,9 @@ dwarf2out_flush_queued_reg_saves (void)\n       else\n         reg = dwf_regno (q->reg);\n       if (q->saved_reg)\n-\tsreg = dwf_regno (q->saved_reg);\n+\tsreg = dwf_cfa_reg (q->saved_reg);\n       else\n-\tsreg = INVALID_REGNUM;\n+\tsreg.set_by_dwreg (INVALID_REGNUM);\n       reg_save (reg, sreg, q->cfa_offset);\n     }\n \n@@ -1169,7 +1296,7 @@ dwarf2out_frame_debug_def_cfa (rtx pat)\n   /* ??? If this fails, we could be calling into the _loc functions to\n      define a full expression.  So far no port does that.  */\n   gcc_assert (REG_P (pat));\n-  cur_cfa->reg = dwf_regno (pat);\n+  cur_cfa->reg = dwf_cfa_reg (pat);\n }\n \n /* A subroutine of dwarf2out_frame_debug, process a REG_ADJUST_CFA note.  */\n@@ -1186,7 +1313,7 @@ dwarf2out_frame_debug_adjust_cfa (rtx pat)\n   switch (GET_CODE (src))\n     {\n     case PLUS:\n-      gcc_assert (dwf_regno (XEXP (src, 0)) == cur_cfa->reg);\n+      gcc_assert (dwf_cfa_reg (XEXP (src, 0)) == cur_cfa->reg);\n       cur_cfa->offset -= rtx_to_poly_int64 (XEXP (src, 1));\n       break;\n \n@@ -1197,7 +1324,7 @@ dwarf2out_frame_debug_adjust_cfa (rtx pat)\n       gcc_unreachable ();\n     }\n \n-  cur_cfa->reg = dwf_regno (dest);\n+  cur_cfa->reg = dwf_cfa_reg (dest);\n   gcc_assert (cur_cfa->indirect == 0);\n }\n \n@@ -1219,11 +1346,11 @@ dwarf2out_frame_debug_cfa_offset (rtx set)\n   switch (GET_CODE (addr))\n     {\n     case REG:\n-      gcc_assert (dwf_regno (addr) == cur_cfa->reg);\n+      gcc_assert (dwf_cfa_reg (addr) == cur_cfa->reg);\n       offset = -cur_cfa->offset;\n       break;\n     case PLUS:\n-      gcc_assert (dwf_regno (XEXP (addr, 0)) == cur_cfa->reg);\n+      gcc_assert (dwf_cfa_reg (XEXP (addr, 0)) == cur_cfa->reg);\n       offset = rtx_to_poly_int64 (XEXP (addr, 1)) - cur_cfa->offset;\n       break;\n     default:\n@@ -1243,8 +1370,10 @@ dwarf2out_frame_debug_cfa_offset (rtx set)\n \n   /* ??? We'd like to use queue_reg_save, but we need to come up with\n      a different flushing heuristic for epilogues.  */\n+  struct cfa_reg invalid;\n+  invalid.set_by_dwreg (INVALID_REGNUM);\n   if (!span)\n-    reg_save (sregno, INVALID_REGNUM, offset);\n+    reg_save (sregno, invalid, offset);\n   else\n     {\n       /* We have a PARALLEL describing where the contents of SRC live.\n@@ -1258,7 +1387,7 @@ dwarf2out_frame_debug_cfa_offset (rtx set)\n \t{\n \t  rtx elem = XVECEXP (span, 0, par_index);\n \t  sregno = dwf_regno (src);\n-\t  reg_save (sregno, INVALID_REGNUM, span_offset);\n+\t  reg_save (sregno, invalid, span_offset);\n \t  span_offset += GET_MODE_SIZE (GET_MODE (elem));\n \t}\n     }\n@@ -1270,7 +1399,8 @@ static void\n dwarf2out_frame_debug_cfa_register (rtx set)\n {\n   rtx src, dest;\n-  unsigned sregno, dregno;\n+  unsigned sregno;\n+  struct cfa_reg dregno;\n \n   src = XEXP (set, 1);\n   dest = XEXP (set, 0);\n@@ -1281,7 +1411,7 @@ dwarf2out_frame_debug_cfa_register (rtx set)\n   else\n     sregno = dwf_regno (src);\n \n-  dregno = dwf_regno (dest);\n+  dregno = dwf_cfa_reg (dest);\n \n   /* ??? We'd like to use queue_reg_save, but we need to come up with\n      a different flushing heuristic for epilogues.  */\n@@ -1667,7 +1797,7 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t{\n \t  /* Setting FP from SP.  */\n \tcase REG:\n-\t  if (cur_cfa->reg == dwf_regno (src))\n+\t  if (cur_cfa->reg == dwf_cfa_reg (src))\n \t    {\n \t      /* Rule 1 */\n \t      /* Update the CFA rule wrt SP or FP.  Make sure src is\n@@ -1677,7 +1807,7 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t\t ARM copies SP to a temporary register, and from there to\n \t\t FP.  So we just rely on the backends to only set\n \t\t RTX_FRAME_RELATED_P on appropriate insns.  */\n-\t      cur_cfa->reg = dwf_regno (dest);\n+\t      cur_cfa->reg = dwf_cfa_reg (dest);\n \t      cur_trace->cfa_temp.reg = cur_cfa->reg;\n \t      cur_trace->cfa_temp.offset = cur_cfa->offset;\n \t    }\n@@ -1698,7 +1828,7 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t\t{\n \t\t  gcc_assert (REGNO (dest) == HARD_FRAME_POINTER_REGNUM\n \t\t\t      && fde->drap_reg != INVALID_REGNUM\n-\t\t\t      && cur_cfa->reg != dwf_regno (src)\n+\t\t\t      && cur_cfa->reg != dwf_cfa_reg (src)\n \t\t\t      && fde->rule18);\n \t\t  fde->rule18 = 0;\n \t\t  /* The save of hard frame pointer has been deferred\n@@ -1722,7 +1852,7 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t      /* Adjusting SP.  */\n \t      if (REG_P (XEXP (src, 1)))\n \t\t{\n-\t\t  gcc_assert (dwf_regno (XEXP (src, 1))\n+\t\t  gcc_assert (dwf_cfa_reg (XEXP (src, 1))\n \t\t\t      == cur_trace->cfa_temp.reg);\n \t\t  offset = cur_trace->cfa_temp.offset;\n \t\t}\n@@ -1756,7 +1886,7 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t      gcc_assert (frame_pointer_needed);\n \n \t      gcc_assert (REG_P (XEXP (src, 0))\n-\t\t\t  && dwf_regno (XEXP (src, 0)) == cur_cfa->reg);\n+\t\t\t  && dwf_cfa_reg (XEXP (src, 0)) == cur_cfa->reg);\n \t      offset = rtx_to_poly_int64 (XEXP (src, 1));\n \t      if (GET_CODE (src) != MINUS)\n \t\toffset = -offset;\n@@ -1769,28 +1899,28 @@ dwarf2out_frame_debug_expr (rtx expr)\n \n \t      /* Rule 4 */\n \t      if (REG_P (XEXP (src, 0))\n-\t\t  && dwf_regno (XEXP (src, 0)) == cur_cfa->reg\n+\t\t  && dwf_cfa_reg (XEXP (src, 0)) == cur_cfa->reg\n \t\t  && poly_int_rtx_p (XEXP (src, 1), &offset))\n \t\t{\n \t\t  /* Setting a temporary CFA register that will be copied\n \t\t     into the FP later on.  */\n \t\t  offset = -offset;\n \t\t  cur_cfa->offset += offset;\n-\t\t  cur_cfa->reg = dwf_regno (dest);\n+\t\t  cur_cfa->reg = dwf_cfa_reg (dest);\n \t\t  /* Or used to save regs to the stack.  */\n \t\t  cur_trace->cfa_temp.reg = cur_cfa->reg;\n \t\t  cur_trace->cfa_temp.offset = cur_cfa->offset;\n \t\t}\n \n \t      /* Rule 5 */\n \t      else if (REG_P (XEXP (src, 0))\n-\t\t       && dwf_regno (XEXP (src, 0)) == cur_trace->cfa_temp.reg\n+\t\t       && dwf_cfa_reg (XEXP (src, 0)) == cur_trace->cfa_temp.reg\n \t\t       && XEXP (src, 1) == stack_pointer_rtx)\n \t\t{\n \t\t  /* Setting a scratch register that we will use instead\n \t\t     of SP for saving registers to the stack.  */\n \t\t  gcc_assert (cur_cfa->reg == dw_stack_pointer_regnum);\n-\t\t  cur_trace->cfa_store.reg = dwf_regno (dest);\n+\t\t  cur_trace->cfa_store.reg = dwf_cfa_reg (dest);\n \t\t  cur_trace->cfa_store.offset\n \t\t    = cur_cfa->offset - cur_trace->cfa_temp.offset;\n \t\t}\n@@ -1799,7 +1929,7 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t      else if (GET_CODE (src) == LO_SUM\n \t\t       && poly_int_rtx_p (XEXP (src, 1),\n \t\t\t\t\t  &cur_trace->cfa_temp.offset))\n-\t\tcur_trace->cfa_temp.reg = dwf_regno (dest);\n+\t\tcur_trace->cfa_temp.reg = dwf_cfa_reg (dest);\n \t      else\n \t\tgcc_unreachable ();\n \t    }\n@@ -1808,17 +1938,17 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t  /* Rule 6 */\n \tcase CONST_INT:\n \tcase CONST_POLY_INT:\n-\t  cur_trace->cfa_temp.reg = dwf_regno (dest);\n+\t  cur_trace->cfa_temp.reg = dwf_cfa_reg (dest);\n \t  cur_trace->cfa_temp.offset = rtx_to_poly_int64 (src);\n \t  break;\n \n \t  /* Rule 7 */\n \tcase IOR:\n \t  gcc_assert (REG_P (XEXP (src, 0))\n-\t\t      && dwf_regno (XEXP (src, 0)) == cur_trace->cfa_temp.reg\n+\t\t      && dwf_cfa_reg (XEXP (src, 0)) == cur_trace->cfa_temp.reg\n \t\t      && CONST_INT_P (XEXP (src, 1)));\n \n-\t  cur_trace->cfa_temp.reg = dwf_regno (dest);\n+\t  cur_trace->cfa_temp.reg = dwf_cfa_reg (dest);\n \t  if (!can_ior_p (cur_trace->cfa_temp.offset, INTVAL (XEXP (src, 1)),\n \t\t\t  &cur_trace->cfa_temp.offset))\n \t    /* The target shouldn't generate this kind of CFI note if we\n@@ -1851,14 +1981,17 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t      dwarf2out_flush_queued_reg_saves ();\n \n               gcc_assert (cur_trace->cfa_store.reg\n-\t\t\t  == dwf_regno (XEXP (src, 0)));\n+\t\t\t  == dwf_cfa_reg (XEXP (src, 0)));\n               fde->stack_realign = 1;\n               fde->stack_realignment = INTVAL (XEXP (src, 1));\n               cur_trace->cfa_store.offset = 0;\n \n \t      if (cur_cfa->reg != dw_stack_pointer_regnum\n \t\t  && cur_cfa->reg != dw_frame_pointer_regnum)\n-\t\tfde->drap_reg = cur_cfa->reg;\n+\t\t{\n+\t\t  gcc_assert (cur_cfa->reg.span == 1);\n+\t\t  fde->drap_reg = cur_cfa->reg.reg;\n+\t\t}\n             }\n           return;\n \n@@ -1935,14 +2068,14 @@ dwarf2out_frame_debug_expr (rtx expr)\n \tcase MINUS:\n \tcase LO_SUM:\n \t  {\n-\t    unsigned int regno;\n+\t    struct cfa_reg regno;\n \n \t    gcc_assert (REG_P (XEXP (XEXP (dest, 0), 0)));\n \t    offset = rtx_to_poly_int64 (XEXP (XEXP (dest, 0), 1));\n \t    if (GET_CODE (XEXP (dest, 0)) == MINUS)\n \t      offset = -offset;\n \n-\t    regno = dwf_regno (XEXP (XEXP (dest, 0), 0));\n+\t    regno = dwf_cfa_reg (XEXP (XEXP (dest, 0), 0));\n \n \t    if (cur_cfa->reg == regno)\n \t      offset -= cur_cfa->offset;\n@@ -1960,7 +2093,7 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t  /* Without an offset.  */\n \tcase REG:\n \t  {\n-\t    unsigned int regno = dwf_regno (XEXP (dest, 0));\n+\t    struct cfa_reg regno = dwf_cfa_reg (XEXP (dest, 0));\n \n \t    if (cur_cfa->reg == regno)\n \t      offset = -cur_cfa->offset;\n@@ -1977,7 +2110,7 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t  /* Rule 14 */\n \tcase POST_INC:\n \t  gcc_assert (cur_trace->cfa_temp.reg\n-\t\t      == dwf_regno (XEXP (XEXP (dest, 0), 0)));\n+\t\t      == dwf_cfa_reg (XEXP (XEXP (dest, 0), 0)));\n \t  offset = -cur_trace->cfa_temp.offset;\n \t  cur_trace->cfa_temp.offset -= GET_MODE_SIZE (GET_MODE (dest));\n \t  break;\n@@ -1995,7 +2128,7 @@ dwarf2out_frame_debug_expr (rtx expr)\n       if (REG_P (src)\n \t  && REGNO (src) != STACK_POINTER_REGNUM\n \t  && REGNO (src) != HARD_FRAME_POINTER_REGNUM\n-\t  && dwf_regno (src) == cur_cfa->reg)\n+\t  && dwf_cfa_reg (src) == cur_cfa->reg)\n \t{\n \t  /* We're storing the current CFA reg into the stack.  */\n \n@@ -2012,7 +2145,7 @@ dwarf2out_frame_debug_expr (rtx expr)\n                   && cur_cfa->indirect == 0\n                   && cur_cfa->reg != dw_frame_pointer_regnum)\n                 {\n-\t\t  gcc_assert (fde->drap_reg == cur_cfa->reg);\n+\t\t  gcc_assert (fde->drap_reg == cur_cfa->reg.reg);\n \n \t\t  cur_cfa->indirect = 1;\n \t\t  cur_cfa->reg = dw_frame_pointer_regnum;\n@@ -2039,7 +2172,7 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t\tx = XEXP (x, 0);\n \t      gcc_assert (REG_P (x));\n \n-\t      cur_cfa->reg = dwf_regno (x);\n+\t      cur_cfa->reg = dwf_cfa_reg (x);\n \t      cur_cfa->base_offset = offset;\n \t      cur_cfa->indirect = 1;\n \t      break;\n@@ -2951,7 +3084,7 @@ create_pseudo_cfg (void)\n   ti.head = get_insns ();\n   ti.beg_row = cie_cfi_row;\n   ti.cfa_store = cie_cfi_row->cfa;\n-  ti.cfa_temp.reg = INVALID_REGNUM;\n+  ti.cfa_temp.reg.set_by_dwreg (INVALID_REGNUM);\n   trace_info.quick_push (ti);\n \n   if (cie_return_save)\n@@ -3014,14 +3147,15 @@ create_pseudo_cfg (void)\n static void\n initial_return_save (rtx rtl)\n {\n-  unsigned int reg = INVALID_REGNUM;\n+  struct cfa_reg reg;\n+  reg.set_by_dwreg (INVALID_REGNUM);\n   poly_int64 offset = 0;\n \n   switch (GET_CODE (rtl))\n     {\n     case REG:\n       /* RA is in a register.  */\n-      reg = dwf_regno (rtl);\n+      reg = dwf_cfa_reg (rtl);\n       break;\n \n     case MEM:\n@@ -3062,9 +3196,9 @@ initial_return_save (rtx rtl)\n       gcc_unreachable ();\n     }\n \n-  if (reg != DWARF_FRAME_RETURN_COLUMN)\n+  if (reg.reg != DWARF_FRAME_RETURN_COLUMN)\n     {\n-      if (reg != INVALID_REGNUM)\n+      if (reg.reg != INVALID_REGNUM)\n         record_reg_saved_in_reg (rtl, pc_rtx);\n       reg_save (DWARF_FRAME_RETURN_COLUMN, reg, offset - cur_row->cfa.offset);\n     }\n@@ -3076,7 +3210,8 @@ create_cie_data (void)\n   dw_cfa_location loc;\n   dw_trace_info cie_trace;\n \n-  dw_stack_pointer_regnum = DWARF_FRAME_REGNUM (STACK_POINTER_REGNUM);\n+  dw_stack_pointer_regnum = dwf_cfa_reg (gen_rtx_REG (Pmode,\n+\t\t\t\t\t\t      STACK_POINTER_REGNUM));\n \n   memset (&cie_trace, 0, sizeof (cie_trace));\n   cur_trace = &cie_trace;\n@@ -3135,7 +3270,8 @@ static unsigned int\n execute_dwarf2_frame (void)\n {\n   /* Different HARD_FRAME_POINTER_REGNUM might coexist in the same file.  */\n-  dw_frame_pointer_regnum = DWARF_FRAME_REGNUM (HARD_FRAME_POINTER_REGNUM);\n+  dw_frame_pointer_regnum\n+    = dwf_cfa_reg (gen_rtx_REG (Pmode, HARD_FRAME_POINTER_REGNUM));\n \n   /* The first time we're called, compute the incoming frame state.  */\n   if (cie_cfi_vec == NULL)\n@@ -3515,7 +3651,7 @@ dump_cfi_row (FILE *f, dw_cfi_row *row)\n     {\n       dw_cfa_location dummy;\n       memset (&dummy, 0, sizeof (dummy));\n-      dummy.reg = INVALID_REGNUM;\n+      dummy.reg.set_by_dwreg (INVALID_REGNUM);\n       cfi = def_cfa_0 (&dummy, &row->cfa);\n     }\n   output_cfi_directive (f, cfi);"}, {"sha": "d6513d389e5e1ac07687b3658de5368e8eeb42d7", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 49, "deletions": 5, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13b6c7639cfdca892a3f02b63596b097e1839f38/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13b6c7639cfdca892a3f02b63596b097e1839f38/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=13b6c7639cfdca892a3f02b63596b097e1839f38", "patch": "@@ -2780,6 +2780,43 @@ output_loc_sequence_raw (dw_loc_descr_ref loc)\n     }\n }\n \n+static void\n+build_breg_loc (struct dw_loc_descr_node **head, unsigned int regno)\n+{\n+  if (regno <= 31)\n+    add_loc_descr (head, new_loc_descr ((enum dwarf_location_atom)\n+\t\t\t\t\t(DW_OP_breg0 + regno),  0, 0));\n+  else\n+    add_loc_descr (head, new_loc_descr (DW_OP_bregx, regno, 0));\n+}\n+\n+/* Build a dwarf location for a cfa_reg spanning multiple\n+   consecutive registers.  */\n+\n+struct dw_loc_descr_node *\n+build_span_loc (struct cfa_reg reg)\n+{\n+  struct dw_loc_descr_node *head = NULL;\n+\n+  gcc_assert (reg.span_width > 0);\n+  gcc_assert (reg.span > 1);\n+\n+  /* Start from the highest number register as it goes in the upper bits.  */\n+  unsigned int regno = reg.reg + reg.span - 1;\n+  build_breg_loc (&head, regno);\n+\n+  /* Deal with the remaining registers in the span.  */\n+  for (int i = reg.span - 2; i >= 0; i--)\n+    {\n+      add_loc_descr (&head, int_loc_descriptor (reg.span_width * 8));\n+      add_loc_descr (&head, new_loc_descr (DW_OP_shl, 0, 0));\n+      regno--;\n+      build_breg_loc (&head, regno);\n+      add_loc_descr (&head, new_loc_descr (DW_OP_plus, 0, 0));\n+    }\n+  return head;\n+}\n+\n /* This function builds a dwarf location descriptor sequence from a\n    dw_cfa_location, adding the given OFFSET to the result of the\n    expression.  */\n@@ -2791,17 +2828,24 @@ build_cfa_loc (dw_cfa_location *cfa, poly_int64 offset)\n \n   offset += cfa->offset;\n \n-  if (cfa->indirect)\n+  if (cfa->reg.span > 1)\n+    {\n+      head = build_span_loc (cfa->reg);\n+\n+      if (maybe_ne (offset, 0))\n+\t  loc_descr_plus_const (&head, offset);\n+    }\n+  else if (cfa->indirect)\n     {\n-      head = new_reg_loc_descr (cfa->reg, cfa->base_offset);\n+      head = new_reg_loc_descr (cfa->reg.reg, cfa->base_offset);\n       head->dw_loc_oprnd1.val_class = dw_val_class_const;\n       head->dw_loc_oprnd1.val_entry = NULL;\n       tmp = new_loc_descr (DW_OP_deref, 0, 0);\n       add_loc_descr (&head, tmp);\n       loc_descr_plus_const (&head, offset);\n     }\n   else\n-    head = new_reg_loc_descr (cfa->reg, offset);\n+    head = new_reg_loc_descr (cfa->reg.reg, offset);\n \n   return head;\n }\n@@ -2819,7 +2863,7 @@ build_cfa_aligned_loc (dw_cfa_location *cfa,\n     = DWARF_FRAME_REGNUM (HARD_FRAME_POINTER_REGNUM);\n \n   /* When CFA is defined as FP+OFFSET, emulate stack alignment.  */\n-  if (cfa->reg == HARD_FRAME_POINTER_REGNUM && cfa->indirect == 0)\n+  if (cfa->reg.reg == HARD_FRAME_POINTER_REGNUM && cfa->indirect == 0)\n     {\n       head = new_reg_loc_descr (dwarf_fp, 0);\n       add_loc_descr (&head, int_loc_descriptor (alignment));\n@@ -20882,7 +20926,7 @@ convert_cfa_to_fb_loc_list (HOST_WIDE_INT offset)\n   list = NULL;\n \n   memset (&next_cfa, 0, sizeof (next_cfa));\n-  next_cfa.reg = INVALID_REGNUM;\n+  next_cfa.reg.set_by_dwreg (INVALID_REGNUM);\n   remember = next_cfa;\n \n   start_label = fde->dw_fde_begin;"}, {"sha": "f00983410afee10d3a7c2c7e831266844001af1d", "filename": "gcc/dwarf2out.h", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13b6c7639cfdca892a3f02b63596b097e1839f38/gcc%2Fdwarf2out.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13b6c7639cfdca892a3f02b63596b097e1839f38/gcc%2Fdwarf2out.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.h?ref=13b6c7639cfdca892a3f02b63596b097e1839f38", "patch": "@@ -119,6 +119,39 @@ struct GTY(()) dw_fde_node {\n };\n \n \n+/* This represents a register, in DWARF_FRAME_REGNUM space, for use in CFA\n+   definitions and expressions.\n+   Most architectures only need a single register number, but some (amdgcn)\n+   have pointers that span multiple registers.  DWARF permits arbitrary\n+   register sets but existing use-cases only require contiguous register\n+   sets, as represented here.  */\n+struct GTY(()) cfa_reg {\n+  unsigned int reg;\n+  unsigned short span;\n+  unsigned short span_width;  /* A.K.A. register mode size.  */\n+\n+  cfa_reg& set_by_dwreg (unsigned int r)\n+    {\n+      reg = r;\n+      span = 1;\n+      span_width = 0;  /* Unknown size (permitted when span == 1).  */\n+      return *this;\n+    }\n+\n+  bool operator== (const cfa_reg &other) const\n+    {\n+      return (reg == other.reg && span == other.span\n+\t      && (span_width == other.span_width\n+\t\t  || (span == 1\n+\t\t      && (span_width == 0 || other.span_width == 0))));\n+    }\n+\n+  bool operator!= (const cfa_reg &other) const\n+    {\n+      return !(*this == other);\n+    }\n+};\n+\n /* This is how we define the location of the CFA. We use to handle it\n    as REG + OFFSET all the time,  but now it can be more complex.\n    It can now be either REG + CFA_OFFSET or *(REG + BASE_OFFSET) + CFA_OFFSET.\n@@ -128,7 +161,7 @@ struct GTY(()) dw_cfa_location {\n   poly_int64_pod offset;\n   poly_int64_pod base_offset;\n   /* REG is in DWARF_FRAME_REGNUM space, *not* normal REGNO space.  */\n-  unsigned int reg;\n+  struct cfa_reg reg;\n   BOOL_BITFIELD indirect : 1;  /* 1 if CFA is accessed via a dereference.  */\n   BOOL_BITFIELD in_use : 1;    /* 1 if a saved cfa is stored here.  */\n };\n@@ -285,6 +318,7 @@ extern struct dw_loc_descr_node *build_cfa_loc\n   (dw_cfa_location *, poly_int64);\n extern struct dw_loc_descr_node *build_cfa_aligned_loc\n   (dw_cfa_location *, poly_int64, HOST_WIDE_INT);\n+extern struct dw_loc_descr_node *build_span_loc (struct cfa_reg);\n extern struct dw_loc_descr_node *mem_loc_descriptor\n   (rtx, machine_mode mode, machine_mode mem_mode,\n    enum var_init_status);"}]}