{"sha": "fb639843e4bb0b43d08de4baca618fe98ee04e91", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmI2Mzk4NDNlNGJiMGI0M2QwOGRlNGJhY2E2MThmZTk4ZWUwNGU5MQ==", "commit": {"author": {"name": "Michael Matz", "email": "matz@suse.de", "date": "2012-05-21T13:24:31Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2012-05-21T13:24:31Z"}, "message": "genattrtab.c (attr_rtx_cost): Move earlier, start with cost being 1.\n\n\t* genattrtab.c (attr_rtx_cost): Move earlier, start with cost being 1.\n\t(simplify_test_exp): Handle one more case of distributive law,\n\tdecrease cost threshold.\n\t(tests_attr_p, get_attr_order): New functions.\n\t(optimize_attrs): Use topological order, inline only cheap values.\n\t(write_attr_set): Reset our_known_true after some time.\n\nFrom-SVN: r187714", "tree": {"sha": "de13a4992d80adf66b288be61c9c4de41c004258", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de13a4992d80adf66b288be61c9c4de41c004258"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fb639843e4bb0b43d08de4baca618fe98ee04e91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb639843e4bb0b43d08de4baca618fe98ee04e91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb639843e4bb0b43d08de4baca618fe98ee04e91", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb639843e4bb0b43d08de4baca618fe98ee04e91/comments", "author": {"login": "susematz", "id": 4117296, "node_id": "MDQ6VXNlcjQxMTcyOTY=", "avatar_url": "https://avatars.githubusercontent.com/u/4117296?v=4", "gravatar_id": "", "url": "https://api.github.com/users/susematz", "html_url": "https://github.com/susematz", "followers_url": "https://api.github.com/users/susematz/followers", "following_url": "https://api.github.com/users/susematz/following{/other_user}", "gists_url": "https://api.github.com/users/susematz/gists{/gist_id}", "starred_url": "https://api.github.com/users/susematz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/susematz/subscriptions", "organizations_url": "https://api.github.com/users/susematz/orgs", "repos_url": "https://api.github.com/users/susematz/repos", "events_url": "https://api.github.com/users/susematz/events{/privacy}", "received_events_url": "https://api.github.com/users/susematz/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "30ee9dbf3d7636fb6b590ea3a1cbf56900b1e9c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30ee9dbf3d7636fb6b590ea3a1cbf56900b1e9c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30ee9dbf3d7636fb6b590ea3a1cbf56900b1e9c0"}], "stats": {"total": 305, "additions": 240, "deletions": 65}, "files": [{"sha": "597064bec291efc8d3e2658b30b3d87a6f62e9ba", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb639843e4bb0b43d08de4baca618fe98ee04e91/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb639843e4bb0b43d08de4baca618fe98ee04e91/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fb639843e4bb0b43d08de4baca618fe98ee04e91", "patch": "@@ -1,3 +1,12 @@\n+2012-05-21  Michael Matz  <matz@suse.de>\n+\n+\t* genattrtab.c (attr_rtx_cost): Move earlier, start with cost being 1.\n+\t(simplify_test_exp): Handle one more case of distributive law,\n+\tdecrease cost threshold.\n+\t(tests_attr_p, get_attr_order): New functions.\n+\t(optimize_attrs): Use topological order, inline only cheap values.\n+\t(write_attr_set): Reset our_known_true after some time.\n+\n 2012-05-21  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/53425"}, {"sha": "2a3ee33f3e6984f303c68be2fb657ddfd24c6fd0", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 231, "deletions": 65, "changes": 296, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb639843e4bb0b43d08de4baca618fe98ee04e91/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb639843e4bb0b43d08de4baca618fe98ee04e91/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=fb639843e4bb0b43d08de4baca618fe98ee04e91", "patch": "@@ -116,6 +116,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"vecprim.h\"\n #include \"fnmatch.h\"\n \n+#define DEBUG 0\n+\n /* Flags for make_internal_attr's `special' parameter.  */\n #define ATTR_NONE\t\t0\n #define ATTR_SPECIAL\t\t(1 << 0)\n@@ -1654,6 +1656,57 @@ write_length_unit_log (FILE *outf)\n   fprintf (outf, \"EXPORTED_CONST int length_unit_log = %u;\\n\", length_unit_log);\n }\n \n+/* Compute approximate cost of the expression.  Used to decide whether\n+   expression is cheap enough for inline.  */\n+static int\n+attr_rtx_cost (rtx x)\n+{\n+  int cost = 1;\n+  enum rtx_code code;\n+  if (!x)\n+    return 0;\n+  code = GET_CODE (x);\n+  switch (code)\n+    {\n+    case MATCH_OPERAND:\n+      if (XSTR (x, 1)[0])\n+\treturn 10;\n+      else\n+\treturn 1;\n+\n+    case EQ_ATTR_ALT:\n+      return 1;\n+\n+    case EQ_ATTR:\n+      /* Alternatives don't result into function call.  */\n+      if (!strcmp_check (XSTR (x, 0), alternative_name))\n+\treturn 1;\n+      else\n+\treturn 5;\n+    default:\n+      {\n+\tint i, j;\n+\tconst char *fmt = GET_RTX_FORMAT (code);\n+\tfor (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+\t  {\n+\t    switch (fmt[i])\n+\t      {\n+\t      case 'V':\n+\t      case 'E':\n+\t\tfor (j = 0; j < XVECLEN (x, i); j++)\n+\t\t  cost += attr_rtx_cost (XVECEXP (x, i, j));\n+\t\tbreak;\n+\t      case 'e':\n+\t\tcost += attr_rtx_cost (XEXP (x, i));\n+\t\tbreak;\n+\t      }\n+\t  }\n+      }\n+      break;\n+    }\n+  return cost;\n+}\n+\n /* Take a COND expression and see if any of the conditions in it can be\n    simplified.  If any are known true or known false for the particular insn\n    code, the COND can be further simplified.\n@@ -2280,57 +2333,6 @@ simplify_or_tree (rtx exp, rtx *pterm, int insn_code, int insn_index)\n   return exp;\n }\n \n-/* Compute approximate cost of the expression.  Used to decide whether\n-   expression is cheap enough for inline.  */\n-static int\n-attr_rtx_cost (rtx x)\n-{\n-  int cost = 0;\n-  enum rtx_code code;\n-  if (!x)\n-    return 0;\n-  code = GET_CODE (x);\n-  switch (code)\n-    {\n-    case MATCH_OPERAND:\n-      if (XSTR (x, 1)[0])\n-\treturn 10;\n-      else\n-\treturn 0;\n-\n-    case EQ_ATTR_ALT:\n-      return 0;\n-\n-    case EQ_ATTR:\n-      /* Alternatives don't result into function call.  */\n-      if (!strcmp_check (XSTR (x, 0), alternative_name))\n-\treturn 0;\n-      else\n-\treturn 5;\n-    default:\n-      {\n-\tint i, j;\n-\tconst char *fmt = GET_RTX_FORMAT (code);\n-\tfor (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-\t  {\n-\t    switch (fmt[i])\n-\t      {\n-\t      case 'V':\n-\t      case 'E':\n-\t\tfor (j = 0; j < XVECLEN (x, i); j++)\n-\t\t  cost += attr_rtx_cost (XVECEXP (x, i, j));\n-\t\tbreak;\n-\t      case 'e':\n-\t\tcost += attr_rtx_cost (XEXP (x, i));\n-\t\tbreak;\n-\t      }\n-\t  }\n-      }\n-      break;\n-    }\n-  return cost;\n-}\n-\n /* Simplify test expression and use temporary obstack in order to avoid\n    memory bloat.  Use ATTR_IND_SIMPLIFIED to avoid unnecessary simplifications\n    and avoid unnecessary copying if possible.  */\n@@ -2663,6 +2665,25 @@ simplify_test_exp (rtx exp, int insn_code, int insn_index)\n \t  return SIMPLIFY_TEST_EXP (newexp, insn_code, insn_index);\n \t}\n \n+      /* Similarly,\n+\t    convert (ior (and (y) (x))\n+\t\t\t (and (z) (x)))\n+\t    to      (and (ior (y) (z))\n+\t\t\t (x))\n+         Note that we want the common term to stay at the end.\n+       */\n+\n+      else if (GET_CODE (left) == AND && GET_CODE (right) == AND\n+\t       && attr_equal_p (XEXP (left, 1), XEXP (right, 1)))\n+\t{\n+\t  newexp = attr_rtx (IOR, XEXP (left, 0), XEXP (right, 0));\n+\n+\t  left = newexp;\n+\t  right = XEXP (right, 1);\n+\t  newexp = attr_rtx (AND, left, right);\n+\t  return SIMPLIFY_TEST_EXP (newexp, insn_code, insn_index);\n+\t}\n+\n       /* See if all or all but one of the insn's alternatives are specified\n \t in this tree.  Optimize if so.  */\n \n@@ -2798,7 +2819,7 @@ simplify_test_exp (rtx exp, int insn_code, int insn_index)\n \t      x = evaluate_eq_attr (exp, attr, av->value,\n \t\t\t\t    insn_code, insn_index);\n \t      x = SIMPLIFY_TEST_EXP (x, insn_code, insn_index);\n-\t      if (attr_rtx_cost(x) < 20)\n+\t      if (attr_rtx_cost(x) < 7)\n \t\treturn x;\n \t    }\n \t}\n@@ -2818,6 +2839,133 @@ simplify_test_exp (rtx exp, int insn_code, int insn_index)\n   return newexp;\n }\n \n+/* Return 1 if any EQ_ATTR subexpression of P refers to ATTR,\n+   otherwise return 0.  */\n+\n+static int\n+tests_attr_p (rtx p, struct attr_desc *attr)\n+{\n+  const char *fmt;\n+  int i, ie, j, je;\n+\n+  if (GET_CODE (p) == EQ_ATTR)\n+    {\n+      if (XSTR (p, 0) != attr->name)\n+\treturn 0;\n+      return 1;\n+    }\n+\n+  fmt = GET_RTX_FORMAT (GET_CODE (p));\n+  ie = GET_RTX_LENGTH (GET_CODE (p));\n+  for (i = 0; i < ie; i++)\n+    {\n+      switch (*fmt++)\n+\t{\n+\tcase 'e':\n+\t  if (tests_attr_p (XEXP (p, i), attr))\n+\t    return 1;\n+\t  break;\n+\n+\tcase 'E':\n+\t  je = XVECLEN (p, i);\n+\t  for (j = 0; j < je; ++j)\n+\t    if (tests_attr_p (XVECEXP (p, i, j), attr))\n+\t      return 1;\n+\t  break;\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n+/* Calculate a topological sorting of all attributes so that\n+   all attributes only depend on attributes in front of it.\n+   Place the result in *RET (which is a pointer to an array of\n+   attr_desc pointers), and return the size of that array.  */\n+\n+static int\n+get_attr_order (struct attr_desc ***ret)\n+{\n+  int i, j;\n+  int num = 0;\n+  struct attr_desc *attr;\n+  struct attr_desc **all, **sorted;\n+  char *handled;\n+  for (i = 0; i < MAX_ATTRS_INDEX; i++)\n+    for (attr = attrs[i]; attr; attr = attr->next)\n+      num++;\n+  all = XNEWVEC (struct attr_desc *, num);\n+  sorted = XNEWVEC (struct attr_desc *, num);\n+  handled = XCNEWVEC (char, num);\n+  num = 0;\n+  for (i = 0; i < MAX_ATTRS_INDEX; i++)\n+    for (attr = attrs[i]; attr; attr = attr->next)\n+      all[num++] = attr;\n+\n+  j = 0;\n+  for (i = 0; i < num; i++)\n+    if (all[i]->is_const)\n+      handled[i] = 1, sorted[j++] = all[i];\n+\n+  /* We have only few attributes hence we can live with the inner\n+     loop being O(n^2), unlike the normal fast variants of topological\n+     sorting.  */\n+  while (j < num)\n+    {\n+      for (i = 0; i < num; i++)\n+\tif (!handled[i])\n+\t  {\n+\t    /* Let's see if I depends on anything interesting.  */\n+\t    int k;\n+\t    for (k = 0; k < num; k++)\n+\t      if (!handled[k])\n+\t\t{\n+\t\t  struct attr_value *av;\n+\t\t  for (av = all[i]->first_value; av; av = av->next)\n+\t\t    if (av->num_insns != 0)\n+\t\t      if (tests_attr_p (av->value, all[k]))\n+\t\t\tbreak;\n+\n+\t\t  if (av)\n+\t\t    /* Something in I depends on K.  */\n+\t\t    break;\n+\t\t}\n+\t    if (k == num)\n+\t      {\n+\t\t/* Nothing in I depended on anything intersting, so\n+\t\t   it's done.  */\n+\t\thandled[i] = 1;\n+\t\tsorted[j++] = all[i];\n+\t      }\n+\t  }\n+    }\n+\n+  if (DEBUG)\n+    for (j = 0; j < num; j++)\n+      {\n+\tstruct attr_desc *attr2;\n+\tstruct attr_value *av;\n+\n+\tattr = sorted[j];\n+\tfprintf (stderr, \"%s depends on: \", attr->name);\n+\tfor (i = 0; i < MAX_ATTRS_INDEX; ++i)\n+\t  for (attr2 = attrs[i]; attr2; attr2 = attr2->next)\n+\t    if (!attr2->is_const)\n+\t      for (av = attr->first_value; av; av = av->next)\n+\t\tif (av->num_insns != 0)\n+\t\t  if (tests_attr_p (av->value, attr2))\n+\t\t    {\n+\t\t      fprintf (stderr, \"%s, \", attr2->name);\n+\t\t      break;\n+\t\t    }\n+\tfprintf (stderr, \"\\n\");\n+      }\n+\n+  free (all);\n+  *ret = sorted;\n+  return num;\n+}\n+\n /* Optimize the attribute lists by seeing if we can determine conditional\n    values from the known values of other attributes.  This will save subroutine\n    calls during the compilation.  */\n@@ -2832,6 +2980,8 @@ optimize_attrs (void)\n   int i;\n   struct attr_value_list *ivbuf;\n   struct attr_value_list *iv;\n+  struct attr_desc **topsort;\n+  int topnum;\n \n   /* For each insn code, make a list of all the insn_ent's for it,\n      for all values for all attributes.  */\n@@ -2847,18 +2997,22 @@ optimize_attrs (void)\n \n   iv = ivbuf = XNEWVEC (struct attr_value_list, num_insn_ents);\n \n-  for (i = 0; i < MAX_ATTRS_INDEX; i++)\n-    for (attr = attrs[i]; attr; attr = attr->next)\n-      for (av = attr->first_value; av; av = av->next)\n-\tfor (ie = av->first_insn; ie; ie = ie->next)\n-\t  {\n-\t    iv->attr = attr;\n-\t    iv->av = av;\n-\t    iv->ie = ie;\n-\t    iv->next = insn_code_values[ie->def->insn_code];\n-\t    insn_code_values[ie->def->insn_code] = iv;\n-\t    iv++;\n-\t  }\n+  /* Create the chain of insn*attr values such that we see dependend\n+     attributes after their dependencies.  As we use a stack via the\n+     next pointers start from the end of the topological order.  */\n+  topnum = get_attr_order (&topsort);\n+  for (i = topnum - 1; i >= 0; i--)\n+    for (av = topsort[i]->first_value; av; av = av->next)\n+      for (ie = av->first_insn; ie; ie = ie->next)\n+\t{\n+\t  iv->attr = topsort[i];\n+\t  iv->av = av;\n+\t  iv->ie = ie;\n+\t  iv->next = insn_code_values[ie->def->insn_code];\n+\t  insn_code_values[ie->def->insn_code] = iv;\n+\t  iv++;\n+\t}\n+  free (topsort);\n \n   /* Sanity check on num_insn_ents.  */\n   gcc_assert (iv == ivbuf + num_insn_ents);\n@@ -2893,7 +3047,15 @@ optimize_attrs (void)\n \t    }\n \n \t  rtl_obstack = old;\n-\t  if (newexp != av->value)\n+\t  /* If we created a new value for this instruction, and it's\n+\t     cheaper than the old value, and overall cheap, use that\n+\t     one as specific value for the current instruction.\n+\t     The last test is to avoid exploding the get_attr_ function\n+\t     sizes for no much gain.  */\n+\t  if (newexp != av->value\n+\t      && attr_rtx_cost (newexp) < attr_rtx_cost (av->value)\n+\t      && attr_rtx_cost (newexp) < 26\n+\t     )\n \t    {\n \t      newexp = attr_copy_rtx (newexp);\n \t      remove_insn_ent (av, ie);\n@@ -3998,6 +4160,10 @@ write_attr_set (FILE *outf, struct attr_desc *attr, int indent, rtx value,\n \t  rtx testexp;\n \t  rtx inner_true;\n \n+\t  /* Reset our_known_true after some time to not accumulate\n+\t     too much cruft (slowing down genattrtab).  */\n+\t  if ((i & 31) == 0)\n+\t    our_known_true = known_true;\n \t  testexp = eliminate_known_true (our_known_true,\n \t\t\t\t\t  XVECEXP (value, 0, i),\n \t\t\t\t\t  insn_code, insn_index);"}]}