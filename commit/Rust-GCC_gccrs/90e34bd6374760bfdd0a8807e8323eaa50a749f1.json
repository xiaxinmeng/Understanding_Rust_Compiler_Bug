{"sha": "90e34bd6374760bfdd0a8807e8323eaa50a749f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTBlMzRiZDYzNzQ3NjBiZmRkMGE4ODA3ZTgzMjNlYWE1MGE3NDlmMQ==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@redhat.com", "date": "2004-12-20T18:18:37Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2004-12-20T18:18:37Z"}, "message": "re PR tree-optimization/19080 (ICE while compiling linux kernel)\n\n\n\tPR tree-optimization/19080\n\n\tMerge from tree-cleanup-branch\n\n\t* tree-flow-inline.h (clear_call_clobbered): New function.\n\t* tree-ssa-alias.c (init_alias_info): Call it.\n\n\ntestsuite/ChangeLog\n\n\tPR tree-optimization/19080\n\t* gcc.c-torture/compile/pr19080.c: New test.\n\nFrom-SVN: r92423", "tree": {"sha": "4f20301c6201fe9b132e07d84f5911f4816afa44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f20301c6201fe9b132e07d84f5911f4816afa44"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90e34bd6374760bfdd0a8807e8323eaa50a749f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90e34bd6374760bfdd0a8807e8323eaa50a749f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90e34bd6374760bfdd0a8807e8323eaa50a749f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90e34bd6374760bfdd0a8807e8323eaa50a749f1/comments", "author": null, "committer": null, "parents": [{"sha": "c20a99d0c57237b78ceb267b6f42d20278b7b7ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c20a99d0c57237b78ceb267b6f42d20278b7b7ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c20a99d0c57237b78ceb267b6f42d20278b7b7ea"}], "stats": {"total": 167, "additions": 152, "deletions": 15}, "files": [{"sha": "08bceddaf7f35735839f950d9a9cd18bd5955b48", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e34bd6374760bfdd0a8807e8323eaa50a749f1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e34bd6374760bfdd0a8807e8323eaa50a749f1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=90e34bd6374760bfdd0a8807e8323eaa50a749f1", "patch": "@@ -1,3 +1,12 @@\n+2004-12-20  Diego Novillo  <dnovillo@redhat.com>\n+\n+\tPR tree-optimization/19080\n+\n+\tMerge from tree-cleanup-branch\n+\n+\t* tree-flow-inline.h (clear_call_clobbered): New function.\n+\t* tree-ssa-alias.c (init_alias_info): Call it.\n+\n 2004-12-20  Richard Henderson  <rth@redhat.com>\n \n \t* config/i386/i386.md (sse2_movsd): Remove ix86_binary_operator_ok"}, {"sha": "5dfec5c4f3c4cc5e6958296299e8e348387661eb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e34bd6374760bfdd0a8807e8323eaa50a749f1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e34bd6374760bfdd0a8807e8323eaa50a749f1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=90e34bd6374760bfdd0a8807e8323eaa50a749f1", "patch": "@@ -1,3 +1,8 @@\n+2004-12-20  Diego Novillo  <dnovillo@redhat.com>\n+\n+\tPR tree-optimization/19080\n+\t* gcc.c-torture/compile/pr19080.c: New test.\n+\n 2004-12-20  Steven Bosscher  <stevenb@suse.de>\n \n \t* gcc.dg/20041219-1.c: New test."}, {"sha": "b5686b80bb5eda049131493063a3b58935f554a1", "filename": "gcc/testsuite/gcc.c-torture/compile/pr19080.c", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e34bd6374760bfdd0a8807e8323eaa50a749f1/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr19080.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e34bd6374760bfdd0a8807e8323eaa50a749f1/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr19080.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr19080.c?ref=90e34bd6374760bfdd0a8807e8323eaa50a749f1", "patch": "@@ -0,0 +1,115 @@\n+typedef union { int ioport; volatile char *maddr; } bus_space_handle_t;\n+struct scb { unsigned short *hscb; };\n+struct ahd_softc\n+{\n+  int tags[2];\n+  bus_space_handle_t bshs[2];\n+  int dst_mode;\n+  int src_mode;\n+  int flags;\n+};\n+void outb(int, int);\n+\n+int foo_inb(struct ahd_softc*);\n+int foo_int_int (int, int);\n+int ahd_inb(struct ahd_softc*);\n+int ahd_scb_active_in_fifo (void);\n+\n+void ahd_flush_qoutfifo (struct ahd_softc *ahd, struct scb *scb)\n+{\n+  int src, dst, *a = &src, *b = &dst; *a = 1, *b = 1;\n+  int bb, p;\n+\n+  if (ahd->src_mode == 1)\n+    { int src, dst, *a = &src, *b = &dst; *a = 1, *b = 1;}\n+  foo_int_int (ahd->src_mode, ahd->dst_mode);\n+  p = 1;\n+  if (ahd->src_mode == 2 && ahd->dst_mode == p)\n+    {\n+      if (ahd->tags[0] == 1) *(ahd->bshs[0].maddr);\n+        outb (1, ahd->bshs[0].ioport );\n+      if (ahd->tags[0] == 1) *(ahd->bshs[0].maddr);\n+        outb (1, ahd->bshs[0].ioport );\n+    }\n+  ahd->src_mode = 1;\n+  ahd->dst_mode = 2;\n+  while ((ahd_inb (ahd) & 0x01) != 0)\n+  {\n+    p = 1;\n+    if (ahd->src_mode == 2 && ahd->dst_mode == p)\n+      {\n+        if (ahd->tags[0] == 1) *(ahd->bshs[0].maddr);\n+          outb (1, ahd->bshs[0].ioport );\n+        if (ahd->tags[0] == 1) *(ahd->bshs[0].maddr);\n+          outb (1, ahd->bshs[0].ioport );\n+      }\n+    ahd->src_mode = 1;\n+    ahd->dst_mode = 2;\n+    if (ahd_scb_active_in_fifo () == 0)\n+      continue;\n+    p = 1;\n+    if (ahd->src_mode == 2 && ahd->dst_mode == p)\n+      {\n+        if (ahd->tags[0] == 1) *(ahd->bshs[0].maddr);\n+          outb (1, ahd->bshs[0].ioport );\n+        if (ahd->tags[0] == 1) *(ahd->bshs[0].maddr);\n+          outb (1, ahd->bshs[0].ioport );\n+      }\n+    ahd->src_mode = 1;\n+    ahd->dst_mode = 2;\n+    if (ahd->tags[0] == 1) *(ahd->bshs[0].maddr);\n+      outb (1, ahd->bshs[0].ioport );\n+    if (ahd->tags[0] == 1) *(ahd->bshs[0].maddr);\n+      outb (1, ahd->bshs[0].ioport );\n+    if ((ahd->flags & 1) != 0)\n+      foo_inb (ahd);\n+    if ((ahd->flags & 1) != 0)\n+      foo_inb (ahd);\n+    if ((ahd->flags & 1) != 0)\n+      foo_inb (ahd);\n+    if (ahd->tags[0] == 1) *(ahd->bshs[0].maddr);\n+      outb (1, ahd->bshs[0].ioport );\n+    if (ahd->tags[0] == 1) *(ahd->bshs[0].maddr);\n+      outb (1, ahd->bshs[0].ioport );\n+    if ((ahd->flags & 1) != 0)\n+      foo_inb (ahd);\n+    if (ahd->tags[0] == 1) *(ahd->bshs[0].maddr);\n+      outb (1, ahd->bshs[0].ioport );\n+    if (ahd->tags[0] == 1) *(ahd->bshs[0].maddr);\n+      outb (1, ahd->bshs[0].ioport );\n+    bb = (*(scb->hscb));\n+    if (ahd->tags[0] == 1) *(ahd->bshs[0].maddr);\n+      outb (1, ahd->bshs[0].ioport );\n+    if (ahd->tags[0] == 1) *(ahd->bshs[0].maddr);\n+      outb (1, ahd->bshs[0].ioport );\n+    bb = (*(scb->hscb));\n+    if (ahd->tags[0] == 1) *(ahd->bshs[0].maddr);\n+      outb (1, ahd->bshs[0].ioport );\n+    if (ahd->tags[0] == 1) *(ahd->bshs[0].maddr);\n+      outb (1, ahd->bshs[0].ioport );\n+  }\n+  if (ahd->tags[0] == 1) *(ahd->bshs[0].maddr);\n+    outb (1, ahd->bshs[0].ioport );\n+  if (ahd->tags[0] == 1) *(ahd->bshs[0].maddr);\n+    outb (1, ahd->bshs[0].ioport );\n+  p = 1;\n+  if (ahd->src_mode == 2 && ahd->dst_mode == p)\n+    {\n+      if (ahd->tags[0] == 1) *(ahd->bshs[0].maddr);\n+        outb (1, ahd->bshs[0].ioport );\n+      if (ahd->tags[0] == 1) *(ahd->bshs[0].maddr);\n+        outb (1, ahd->bshs[0].ioport );\n+    }\n+  ahd->src_mode = 1;\n+  ahd->dst_mode = 2;\n+  if (ahd->src_mode == 2 && ahd->dst_mode == dst)\n+    {\n+      if (ahd->tags[0] == 1) *(ahd->bshs[0].maddr);\n+        outb (1, ahd->bshs[0].ioport );\n+      if (ahd->tags[0] == 1) *(ahd->bshs[0].maddr);\n+        outb (1, ahd->bshs[0].ioport );\n+    }\n+  ahd->src_mode = 1;\n+  ahd->dst_mode = 2;\n+  ahd->flags |= 1;\n+}"}, {"sha": "b6bcb6528d91a439e473cad129e89edd6cd44393", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e34bd6374760bfdd0a8807e8323eaa50a749f1/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e34bd6374760bfdd0a8807e8323eaa50a749f1/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=90e34bd6374760bfdd0a8807e8323eaa50a749f1", "patch": "@@ -625,6 +625,18 @@ mark_call_clobbered (tree var)\n   ssa_ro_call_cache_valid = false;\n }\n \n+/* Clear the call-clobbered attribute from variable VAR.  */\n+static inline void\n+clear_call_clobbered (tree var)\n+{\n+  var_ann_t ann = var_ann (var);\n+  if (ann->mem_tag_kind != NOT_A_TAG)\n+    DECL_EXTERNAL (var) = 0;\n+  bitmap_clear_bit (call_clobbered_vars, ann->uid);\n+  ssa_call_clobbered_cache_valid = false;\n+  ssa_ro_call_cache_valid = false;\n+}\n+\n /* Mark variable VAR as being non-addressable.  */\n static inline void\n mark_non_addressable (tree var)"}, {"sha": "92a203cede7db15013f5bd5b1d610e26745dc581", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e34bd6374760bfdd0a8807e8323eaa50a749f1/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e34bd6374760bfdd0a8807e8323eaa50a749f1/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=90e34bd6374760bfdd0a8807e8323eaa50a749f1", "patch": "@@ -437,7 +437,6 @@ init_alias_info (void)\n   if (aliases_computed_p)\n     {\n       unsigned i;\n-      bitmap_iterator bi;\n       basic_block bb;\n   \n      /* Make sure that every statement has a valid set of operands.\n@@ -453,19 +452,6 @@ init_alias_info (void)\n \t    get_stmt_operands (bsi_stmt (si));\n \t}\n \n-      /* Clear the call-clobbered set.  We are going to re-discover\n-\t  call-clobbered variables.  */\n-      EXECUTE_IF_SET_IN_BITMAP (call_clobbered_vars, 0, i, bi)\n-\t{\n-\t  tree var = referenced_var (i);\n-\n-\t  /* Variables that are intrinsically call-clobbered (globals,\n-\t     local statics, etc) will not be marked by the aliasing\n-\t     code, so we can't remove them from CALL_CLOBBERED_VARS.  */\n-\t  if (!is_call_clobbered (var))\n-\t    bitmap_clear_bit (call_clobbered_vars, var_ann (var)->uid);\n-\t}\n-\n       /* Similarly, clear the set of addressable variables.  In this\n \t case, we can just clear the set because addressability is\n \t only computed here.  */\n@@ -474,9 +460,19 @@ init_alias_info (void)\n       /* Clear flow-insensitive alias information from each symbol.  */\n       for (i = 0; i < num_referenced_vars; i++)\n \t{\n-\t  var_ann_t ann = var_ann (referenced_var (i));\n+\t  tree var = referenced_var (i);\n+\t  var_ann_t ann = var_ann (var);\n+\n \t  ann->is_alias_tag = 0;\n \t  ann->may_aliases = NULL;\n+\n+\t  /* Since we are about to re-discover call-clobbered\n+\t     variables, clear the call-clobbered flag.  Variables that\n+\t     are intrinsically call-clobbered (globals, local statics,\n+\t     etc) will not be marked by the aliasing code, so we can't\n+\t     remove them from CALL_CLOBBERED_VARS.  */\n+\t  if (ann->mem_tag_kind != NOT_A_TAG || !is_global_var (var))\n+\t    clear_call_clobbered (var);\n \t}\n \n       /* Clear flow-sensitive points-to information from each SSA name.  */"}]}