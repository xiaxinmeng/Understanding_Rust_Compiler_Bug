{"sha": "683e93d1975f676d00096b7c93b942dbd0491800", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjgzZTkzZDE5NzVmNjc2ZDAwMDk2YjdjOTNiOTQyZGJkMDQ5MTgwMA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-01-07T10:18:14Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2020-01-07T10:18:14Z"}, "message": "[AArch64] Use type attributes to mark types that use the SVE PCS\n\nThe SVE port needs to maintain a different type identity for\nGNU vectors and \"SVE vectors\", since the types use different ABIs.\nUntil now we've done that using pointer equality between the\nTYPE_MAIN_VARIANT and the built-in SVE type.\n\nHowever, as Richard B noted, that doesn't work well for LTO,\nwhere we stream both GNU and SVE types from a file instead of\ncreating them directly.  We need a mechanism for distinguishing\nthe types using streamed type information.\n\nThis patch does that using a new type attribute.  This attribute\nis only meant to be used for the built-in SVE types and shouldn't\nbe user-visible.  The patch tries to ensure this by including a space\nin the attribute name, like we already do for things like \"fn spec\"\nand \"omp declare simd\".\n\n2020-01-07  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* config/aarch64/aarch64-protos.h (aarch64_sve::svbool_type_p)\n\t(aarch64_sve::nvectors_if_data_type): Replace with...\n\t(aarch64_sve::builtin_type_p): ...this.\n\t* config/aarch64/aarch64-sve-builtins.cc: Include attribs.h.\n\t(find_vector_type): Delete.\n\t(add_sve_type_attribute): New function.\n\t(lookup_sve_type_attribute): Likewise.\n\t(register_builtin_types): Add an \"SVE type\" attribute to each type.\n\t(register_tuple_type): Likewise.\n\t(svbool_type_p, nvectors_if_data_type): Delete.\n\t(mangle_builtin_type): Use lookup_sve_type_attribute.\n\t(builtin_type_p): Likewise.  Add an overload that returns the\n\tnumber of constituent vector and predicate registers.\n\t* config/aarch64/aarch64.c (aarch64_sve_argument_p): Delete.\n\t(aarch64_returns_value_in_sve_regs_p): Use aarch64_sve::builtin_type_p\n\tinstead of aarch64_sve_argument_p.\n\t(aarch64_takes_arguments_in_sve_regs_p): Likewise.\n\t(aarch64_pass_by_reference): Likewise.\n\t(aarch64_function_value_1): Likewise.\n\t(aarch64_return_in_memory): Likewise.\n\t(aarch64_layout_arg): Likewise.\n\ngcc/testsuite/\n\t* g++.target/aarch64/sve/acle/general-c++/mangle_5.C: New test.\n\t* gcc.target/aarch64/sve/pcs/asm_1.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/asm_2.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/asm_3.c: Likewise.\n\nFrom-SVN: r279953", "tree": {"sha": "31e6eb4dea1b3327bdd3fb9874e36778056b3100", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/31e6eb4dea1b3327bdd3fb9874e36778056b3100"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/683e93d1975f676d00096b7c93b942dbd0491800", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/683e93d1975f676d00096b7c93b942dbd0491800", "html_url": "https://github.com/Rust-GCC/gccrs/commit/683e93d1975f676d00096b7c93b942dbd0491800", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/683e93d1975f676d00096b7c93b942dbd0491800/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c4b30920c7427fc57181d91f17e9998502fe1866", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4b30920c7427fc57181d91f17e9998502fe1866", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4b30920c7427fc57181d91f17e9998502fe1866"}], "stats": {"total": 333, "additions": 246, "deletions": 87}, "files": [{"sha": "3aa2061aee2ac5a96321828f0a6b95a546fe0454", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683e93d1975f676d00096b7c93b942dbd0491800/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683e93d1975f676d00096b7c93b942dbd0491800/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=683e93d1975f676d00096b7c93b942dbd0491800", "patch": "@@ -1,3 +1,27 @@\n+2020-01-07  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* config/aarch64/aarch64-protos.h (aarch64_sve::svbool_type_p)\n+\t(aarch64_sve::nvectors_if_data_type): Replace with...\n+\t(aarch64_sve::builtin_type_p): ...this.\n+\t* config/aarch64/aarch64-sve-builtins.cc: Include attribs.h.\n+\t(find_vector_type): Delete.\n+\t(add_sve_type_attribute): New function.\n+\t(lookup_sve_type_attribute): Likewise.\n+\t(register_builtin_types): Add an \"SVE type\" attribute to each type.\n+\t(register_tuple_type): Likewise.\n+\t(svbool_type_p, nvectors_if_data_type): Delete.\n+\t(mangle_builtin_type): Use lookup_sve_type_attribute.\n+\t(builtin_type_p): Likewise.  Add an overload that returns the\n+\tnumber of constituent vector and predicate registers.\n+\t* config/aarch64/aarch64.c (aarch64_sve_argument_p): Delete.\n+\t(aarch64_returns_value_in_sve_regs_p): Use aarch64_sve::builtin_type_p\n+\tinstead of aarch64_sve_argument_p.\n+\t(aarch64_takes_arguments_in_sve_regs_p): Likewise.\n+\t(aarch64_pass_by_reference): Likewise.\n+\t(aarch64_function_value_1): Likewise.\n+\t(aarch64_return_in_memory): Likewise.\n+\t(aarch64_layout_arg): Likewise.\n+\n 2020-01-07  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/93156"}, {"sha": "a4004309fdb848b9fb4227511ea41f37abf603d7", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683e93d1975f676d00096b7c93b942dbd0491800/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683e93d1975f676d00096b7c93b942dbd0491800/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=683e93d1975f676d00096b7c93b942dbd0491800", "patch": "@@ -706,8 +706,7 @@ namespace aarch64_sve {\n   void handle_arm_sve_h ();\n   tree builtin_decl (unsigned, bool);\n   bool builtin_type_p (const_tree);\n-  bool svbool_type_p (const_tree);\n-  unsigned int nvectors_if_data_type (const_tree);\n+  bool builtin_type_p (const_tree, unsigned int *, unsigned int *);\n   const char *mangle_builtin_type (const_tree);\n   tree resolve_overloaded_builtin (location_t, unsigned int,\n \t\t\t\t   vec<tree, va_gc> *);"}, {"sha": "566ebae48667315ccb4bc8408ead21f68ddc6492", "filename": "gcc/config/aarch64/aarch64-sve-builtins.cc", "status": "modified", "additions": 57, "deletions": 56, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683e93d1975f676d00096b7c93b942dbd0491800/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683e93d1975f676d00096b7c93b942dbd0491800/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins.cc?ref=683e93d1975f676d00096b7c93b942dbd0491800", "patch": "@@ -47,6 +47,7 @@\n #include \"gimple-fold.h\"\n #include \"langhooks.h\"\n #include \"stringpool.h\"\n+#include \"attribs.h\"\n #include \"aarch64-sve-builtins.h\"\n #include \"aarch64-sve-builtins-base.h\"\n #include \"aarch64-sve-builtins-shapes.h\"\n@@ -418,18 +419,31 @@ static hash_table<registered_function_hasher> *function_table;\n    when the required extension is disabled.  */\n static bool reported_missing_extension_p;\n \n-/* If TYPE is an ACLE vector type, return the associated vector_type,\n-   otherwise return NUM_VECTOR_TYPES.  */\n-static vector_type_index\n-find_vector_type (const_tree type)\n+/* Record that TYPE is an ABI-defined SVE type that contains NUM_ZR SVE vectors\n+   and NUM_PR SVE predicates.  MANGLED_NAME, if nonnull, is the ABI-defined\n+   mangling of the type.  */\n+static void\n+add_sve_type_attribute (tree type, unsigned int num_zr, unsigned int num_pr,\n+\t\t\tconst char *mangled_name)\n {\n-  /* A linear search should be OK here, since the code isn't hot and\n-     the number of types is only small.  */\n-  type = TYPE_MAIN_VARIANT (type);\n-  for (unsigned int i = 0; i < NUM_VECTOR_TYPES; ++i)\n-    if (type == abi_vector_types[i])\n-      return vector_type_index (i);\n-  return NUM_VECTOR_TYPES;\n+  tree mangled_name_tree\n+    = (mangled_name ? get_identifier (mangled_name) : NULL_TREE);\n+\n+  tree value = tree_cons (NULL_TREE, mangled_name_tree, NULL_TREE);\n+  value = tree_cons (NULL_TREE, size_int (num_pr), value);\n+  value = tree_cons (NULL_TREE, size_int (num_zr), value);\n+  TYPE_ATTRIBUTES (type) = tree_cons (get_identifier (\"SVE type\"), value,\n+\t\t\t\t      TYPE_ATTRIBUTES (type));\n+}\n+\n+/* If TYPE is an ABI-defined SVE type, return its attribute descriptor,\n+   otherwise return null.  */\n+static tree\n+lookup_sve_type_attribute (const_tree type)\n+{\n+  if (type == error_mark_node)\n+    return NULL_TREE;\n+  return lookup_attribute (\"SVE type\", TYPE_ATTRIBUTES (type));\n }\n \n /* If TYPE is a valid SVE element type, return the corresponding type\n@@ -2986,6 +3000,7 @@ register_builtin_types ()\n     {\n       tree eltype = scalar_types[i];\n       tree vectype;\n+      unsigned int num_zr = 0, num_pr = 0;\n       if (eltype == boolean_type_node)\n \t{\n \t  vectype = build_truth_vector_type_for_mode (BYTES_PER_SVE_VECTOR,\n@@ -2995,6 +3010,7 @@ register_builtin_types ()\n \t\t      && TYPE_ALIGN (vectype) == 16\n \t\t      && known_eq (wi::to_poly_offset (TYPE_SIZE (vectype)),\n \t\t\t\t   BYTES_PER_SVE_VECTOR));\n+\t  num_pr = 1;\n \t}\n       else\n \t{\n@@ -3006,12 +3022,15 @@ register_builtin_types ()\n \t\t      && TYPE_ALIGN (vectype) == 128\n \t\t      && known_eq (wi::to_poly_offset (TYPE_SIZE (vectype)),\n \t\t\t\t   BITS_PER_SVE_VECTOR));\n+\t  num_zr = 1;\n \t}\n       vectype = build_distinct_type_copy (vectype);\n       gcc_assert (vectype == TYPE_MAIN_VARIANT (vectype));\n       SET_TYPE_STRUCTURAL_EQUALITY (vectype);\n       TYPE_ARTIFICIAL (vectype) = 1;\n       TYPE_INDIVISIBLE_P (vectype) = 1;\n+      add_sve_type_attribute (vectype, num_zr, num_pr,\n+\t\t\t      vector_types[i].mangled_name);\n       abi_vector_types[i] = vectype;\n       lang_hooks.types.register_builtin_type (vectype,\n \t\t\t\t\t      vector_types[i].abi_name);\n@@ -3076,6 +3095,7 @@ register_tuple_type (unsigned int num_vectors, vector_type_index type)\n \t\t\t   get_identifier (\"__val\"), array_type);\n   DECL_FIELD_CONTEXT (field) = tuple_type;\n   TYPE_FIELDS (tuple_type) = field;\n+  add_sve_type_attribute (tuple_type, num_vectors, 0, NULL);\n   layout_type (tuple_type);\n   gcc_assert (VECTOR_MODE_P (TYPE_MODE (tuple_type))\n \t      && TYPE_MODE_RAW (tuple_type) == TYPE_MODE (tuple_type)\n@@ -3247,64 +3267,45 @@ expand_builtin (unsigned int code, tree exp, rtx target)\n   return function_expander (rfn.instance, rfn.decl, exp, target).expand ();\n }\n \n-/* Return true if TYPE is the ABI-defined __SVBool_t type.  */\n-bool\n-svbool_type_p (const_tree type)\n-{\n-  tree abi_type = abi_vector_types[VECTOR_TYPE_svbool_t];\n-  return type != error_mark_node && TYPE_MAIN_VARIANT (type) == abi_type;\n-}\n-\n /* If TYPE is a built-in type defined by the SVE ABI, return the mangled name,\n    otherwise return NULL.  */\n const char *\n mangle_builtin_type (const_tree type)\n {\n-  if (type == error_mark_node)\n-    return NULL;\n-\n-  vector_type_index vtype = find_vector_type (type);\n-  if (vtype != NUM_VECTOR_TYPES)\n-    return vector_types[vtype].mangled_name;\n-\n+  /* ??? The C++ frontend normally strips qualifiers and attributes before\n+     calling this hook, adding separate mangling for attributes that affect\n+     type identity.  Fortunately the type copy will have the same TYPE_NAME\n+     as the original, so we can get the attributes from there.  */\n+  if (TYPE_NAME (type) && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL)\n+    type = TREE_TYPE (TYPE_NAME (type));\n+  if (tree attr = lookup_sve_type_attribute (type))\n+    if (tree id = TREE_VALUE (chain_index (2, TREE_VALUE (attr))))\n+      return IDENTIFIER_POINTER (id);\n   return NULL;\n }\n \n-/* If TYPE is one of the ABI-defined SVE vector types, or an ACLE-defined\n-   tuple of them, return the number of vectors it contains.  Return 0\n-   otherwise.  */\n-unsigned int\n-nvectors_if_data_type (const_tree type)\n+/* Return true if TYPE is a built-in SVE type defined by the ABI or ACLE.  */\n+bool\n+builtin_type_p (const_tree type)\n {\n-  if (type == error_mark_node)\n-    return 0;\n-\n-  type = TYPE_MAIN_VARIANT (type);\n-  if (VECTOR_TYPE_P (type))\n-    {\n-      vector_type_index type_id = find_vector_type (type);\n-      if (type_id != VECTOR_TYPE_svbool_t && type_id != NUM_VECTOR_TYPES)\n-\treturn 1;\n-    }\n-  else if (TREE_CODE (type) == RECORD_TYPE)\n-    {\n-      for (unsigned int size_i = 1; size_i < MAX_TUPLE_SIZE; ++size_i)\n-\tfor (unsigned int type_i = 0; type_i < NUM_VECTOR_TYPES; ++type_i)\n-\t  {\n-\t    tree tuple_type = acle_vector_types[size_i][type_i];\n-\t    if (tuple_type && type == TYPE_MAIN_VARIANT (tuple_type))\n-\t      return size_i + 1;\n-\t  }\n-    }\n-\n-  return 0;\n+  return lookup_sve_type_attribute (type);\n }\n \n-/* Return true if TYPE is a built-in type defined by the SVE ABI.  */\n+/* Return true if TYPE is a built-in SVE type defined by the ABI or ACLE.\n+   If so, store the number of constituent SVE vectors in *NUM_ZR and the\n+   number of constituent SVE predicates in *NUM_PR.  */\n bool\n-builtin_type_p (const_tree type)\n+builtin_type_p (const_tree type, unsigned int *num_zr, unsigned int *num_pr)\n {\n-  return svbool_type_p (type) || nvectors_if_data_type (type) > 0;\n+  if (tree attr = lookup_sve_type_attribute (type))\n+    {\n+      tree num_zr_node = TREE_VALUE (attr);\n+      tree num_pr_node = TREE_CHAIN (num_zr_node);\n+      *num_zr = tree_to_uhwi (TREE_VALUE (num_zr_node));\n+      *num_pr = tree_to_uhwi (TREE_VALUE (num_pr_node));\n+      return true;\n+    }\n+  return false;\n }\n \n /* Implement TARGET_VERIFY_TYPE_CONTEXT for SVE types.  */"}, {"sha": "66e20becaf22469432a7f9d79ab4f4eb2706e1a6", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 7, "deletions": 29, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683e93d1975f676d00096b7c93b942dbd0491800/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683e93d1975f676d00096b7c93b942dbd0491800/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=683e93d1975f676d00096b7c93b942dbd0491800", "patch": "@@ -1246,6 +1246,7 @@ static const struct attribute_spec aarch64_attribute_table[] =\n        affects_type_identity, handler, exclude } */\n   { \"aarch64_vector_pcs\", 0, 0, false, true,  true,  true,\n \t\t\t  handle_aarch64_vector_pcs_attribute, NULL },\n+  { \"SVE type\",\t\t  3, 3, false, true,  false, true,  NULL, NULL },\n   { NULL,                 0, 0, false, false, false, false, NULL, NULL }\n };\n \n@@ -2042,37 +2043,15 @@ aarch64_hard_regno_mode_ok (unsigned regno, machine_mode mode)\n    true, set *NUM_ZR and *NUM_PR to the number of required Z and P registers\n    respectively.  */\n \n-static bool\n-aarch64_sve_argument_p (const_tree type, unsigned int *num_zr,\n-\t\t\tunsigned int *num_pr)\n-{\n-  if (aarch64_sve::svbool_type_p (type))\n-    {\n-      *num_pr = 1;\n-      *num_zr = 0;\n-      return true;\n-    }\n-\n-  if (unsigned int nvectors = aarch64_sve::nvectors_if_data_type (type))\n-    {\n-      *num_pr = 0;\n-      *num_zr = nvectors;\n-      return true;\n-    }\n-\n-  return false;\n-}\n-\n /* Return true if a function with type FNTYPE returns its value in\n    SVE vector or predicate registers.  */\n \n static bool\n aarch64_returns_value_in_sve_regs_p (const_tree fntype)\n {\n-  unsigned int num_zr, num_pr;\n   tree return_type = TREE_TYPE (fntype);\n   return (return_type != error_mark_node\n-\t  && aarch64_sve_argument_p (return_type, &num_zr, &num_pr));\n+\t  && aarch64_sve::builtin_type_p (return_type));\n }\n \n /* Return true if a function with type FNTYPE takes arguments in\n@@ -2096,8 +2075,7 @@ aarch64_takes_arguments_in_sve_regs_p (const_tree fntype)\n \n       function_arg_info arg (arg_type, /*named=*/true);\n       apply_pass_by_reference_rules (&args_so_far_v, arg);\n-      unsigned int num_zr, num_pr;\n-      if (aarch64_sve_argument_p (arg.type, &num_zr, &num_pr))\n+      if (aarch64_sve::builtin_type_p (arg.type))\n \treturn true;\n \n       targetm.calls.function_arg_advance (args_so_far, arg);\n@@ -4876,7 +4854,7 @@ aarch64_pass_by_reference (cumulative_args_t pcum_v,\n   int nregs;\n \n   unsigned int num_zr, num_pr;\n-  if (arg.type && aarch64_sve_argument_p (arg.type, &num_zr, &num_pr))\n+  if (arg.type && aarch64_sve::builtin_type_p (arg.type, &num_zr, &num_pr))\n     {\n       if (pcum && !pcum->silent_p && !TARGET_SVE)\n \t/* We can't gracefully recover at this point, so make this a\n@@ -4955,7 +4933,7 @@ static rtx\n aarch64_function_value_1 (const_tree type, machine_mode mode)\n {\n   unsigned int num_zr, num_pr;\n-  if (type && aarch64_sve_argument_p (type, &num_zr, &num_pr))\n+  if (type && aarch64_sve::builtin_type_p (type, &num_zr, &num_pr))\n     {\n       /* Don't raise an error here if we're called when SVE is disabled,\n \t since this is really just a query function.  Other code must\n@@ -5098,7 +5076,7 @@ aarch64_return_in_memory (const_tree type, const_tree fndecl ATTRIBUTE_UNUSED)\n     return false;\n \n   unsigned int num_zr, num_pr;\n-  if (type && aarch64_sve_argument_p (type, &num_zr, &num_pr))\n+  if (type && aarch64_sve::builtin_type_p (type, &num_zr, &num_pr))\n     {\n       /* All SVE types we support fit in registers.  For example, it isn't\n \t yet possible to define an aggregate of 9+ SVE vectors or 5+ SVE\n@@ -5226,7 +5204,7 @@ aarch64_layout_arg (cumulative_args_t pcum_v, const function_arg_info &arg,\n   pcum->aapcs_arg_processed = true;\n \n   unsigned int num_zr, num_pr;\n-  if (type && aarch64_sve_argument_p (type, &num_zr, &num_pr))\n+  if (type && aarch64_sve::builtin_type_p (type, &num_zr, &num_pr))\n     {\n       /* The PCS says that it is invalid to pass an SVE value to an\n \t unprototyped function.  There is no ABI-defined location we"}, {"sha": "9e694fa834ed081971b5d9df3761df585737a2e0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683e93d1975f676d00096b7c93b942dbd0491800/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683e93d1975f676d00096b7c93b942dbd0491800/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=683e93d1975f676d00096b7c93b942dbd0491800", "patch": "@@ -1,3 +1,10 @@\n+2020-01-07  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* g++.target/aarch64/sve/acle/general-c++/mangle_5.C: New test.\n+\t* gcc.target/aarch64/sve/pcs/asm_1.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/asm_2.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/asm_3.c: Likewise.\n+\n 2020-01-07  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/93156"}, {"sha": "47c1160d65a35becfd2829c1129d4c2abb0ffc5d", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/mangle_5.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683e93d1975f676d00096b7c93b942dbd0491800/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fmangle_5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683e93d1975f676d00096b7c93b942dbd0491800/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fmangle_5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fmangle_5.C?ref=683e93d1975f676d00096b7c93b942dbd0491800", "patch": "@@ -0,0 +1,8 @@\n+typedef const __SVInt8_t foo;\n+typedef volatile foo bar;\n+\n+foo f (foo x) { return x; }\n+bar g (bar x) { return x; }\n+\n+/* { dg-final { scan-assembler {_Z1f10__SVInt8_t:\\n} } } */\n+/* { dg-final { scan-assembler {_Z1g10__SVInt8_t:\\n} } } */"}, {"sha": "8be2094dc96d4d4e38e0298f7cc31dae64d95901", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/asm_1.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683e93d1975f676d00096b7c93b942dbd0491800/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fasm_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683e93d1975f676d00096b7c93b942dbd0491800/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fasm_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fasm_1.c?ref=683e93d1975f676d00096b7c93b942dbd0491800", "patch": "@@ -0,0 +1,70 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O0 -ffixed-z0 -ffixed-p0\" } */\n+\n+#include <arm_sve.h>\n+\n+#define ASM_FUNCTION(NAME, RET_TYPE, ARG_TYPE, INSN) \\\n+extern RET_TYPE NAME (svbool_t, ARG_TYPE);\t\\\n+  asm(\t\t\t\t\t\t\\\n+\"\t.type\t\" #NAME \", %function\\n\"\t\t\\\n+#NAME \":\\n\"\t\t\t\t\t\\\n+\"\t\" INSN \"\\n\"\t\t\t\t\\\n+\"\tret\\n\"\t\t\t\t\t\\\n+\"\t.size\t\" #NAME \", .-\" #NAME \"\\n\"\t\\\n+)\n+\n+ASM_FUNCTION (u8_callee, uint64_t, svuint8_t,\n+\t      \"uaddv d0, p0, z0.b\\n\\tfmov x0, d0\");\n+ASM_FUNCTION (u16_callee, uint64_t, svuint16_t,\n+\t      \"uaddv d0, p0, z0.h\\n\\tfmov x0, d0\");\n+ASM_FUNCTION (u32_callee, uint64_t, svuint32_t,\n+\t      \"uaddv d0, p0, z0.s\\n\\tfmov x0, d0\");\n+ASM_FUNCTION (u64_callee, uint64_t, svuint64_t,\n+\t      \"uaddv d0, p0, z0.d\\n\\tfmov x0, d0\");\n+\n+ASM_FUNCTION (s8_callee, int64_t, svint8_t,\n+\t      \"saddv d0, p0, z0.b\\n\\tfmov x0, d0\");\n+ASM_FUNCTION (s16_callee, int64_t, svint16_t,\n+\t      \"saddv d0, p0, z0.h\\n\\tfmov x0, d0\");\n+ASM_FUNCTION (s32_callee, int64_t, svint32_t,\n+\t      \"saddv d0, p0, z0.s\\n\\tfmov x0, d0\");\n+ASM_FUNCTION (s64_callee, int64_t, svint64_t,\n+\t      \"uaddv d0, p0, z0.d\\n\\tfmov x0, d0\");\n+\n+ASM_FUNCTION (f16_callee, float16_t, svfloat16_t, \"faddv\\th0, p0, z0.h\");\n+ASM_FUNCTION (f32_callee, float32_t, svfloat32_t, \"faddv\\ts0, p0, z0.s\");\n+ASM_FUNCTION (f64_callee, float64_t, svfloat64_t, \"faddv\\td0, p0, z0.d\");\n+\n+int\n+main (void)\n+{\n+  if (u8_callee (svptrue_pat_b8 (SV_VL7), svdup_u8 (-1)) != 7 * 0xff)\n+    __builtin_abort ();\n+  if (u16_callee (svptrue_pat_b16 (SV_VL6), svdup_u16 (-1)) != 6 * 0xffff)\n+    __builtin_abort ();\n+  if (u32_callee (svptrue_pat_b32 (SV_VL3), svdup_u32 (-1))\n+      != 3 * (uint64_t) (uint32_t) -1)\n+    __builtin_abort ();\n+  if (u64_callee (svptrue_pat_b64 (SV_VL2), svdup_u64 ((uint64_t) 1 << 33))\n+      != (uint64_t) 1 << 34)\n+    __builtin_abort ();\n+\n+  if (s8_callee (svptrue_pat_b8 (SV_VL7), svdup_s8 (-10)) != -70)\n+    __builtin_abort ();\n+  if (s16_callee (svptrue_pat_b16 (SV_VL6), svdup_s16 (-14)) != -84)\n+    __builtin_abort ();\n+  if (s32_callee (svptrue_pat_b32 (SV_VL3), svdup_s32 (-22)) != -66)\n+    __builtin_abort ();\n+  if (s64_callee (svptrue_pat_b64 (SV_VL2), svdup_s64 ((int64_t) 1 << 33))\n+      != (int64_t) 1 << 34)\n+    __builtin_abort ();\n+\n+  if (f16_callee (svptrue_pat_b16 (SV_VL5), svdup_f16 (1.0)) != 5.0)\n+    __builtin_abort ();\n+  if (f32_callee (svptrue_b32 (), svdup_f32 (3.0)) != 3 * svcntw ())\n+    __builtin_abort ();\n+  if (f64_callee (svptrue_b64 (), svdup_f64 (11.0)) != 11 * svcntd ())\n+    __builtin_abort ();\n+\n+  return 0;\n+}"}, {"sha": "935641b9d63646b0bad93e0382cf7183fcc66d24", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/asm_2.c", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683e93d1975f676d00096b7c93b942dbd0491800/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fasm_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683e93d1975f676d00096b7c93b942dbd0491800/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fasm_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fasm_2.c?ref=683e93d1975f676d00096b7c93b942dbd0491800", "patch": "@@ -0,0 +1,4 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2 -flto -ffixed-z0 -ffixed-p0\" } */\n+\n+#include \"asm_1.c\""}, {"sha": "d5a36e52eab1f71c90b00997d45abf8760624dc7", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/asm_3.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683e93d1975f676d00096b7c93b942dbd0491800/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fasm_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683e93d1975f676d00096b7c93b942dbd0491800/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fasm_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fasm_3.c?ref=683e93d1975f676d00096b7c93b942dbd0491800", "patch": "@@ -0,0 +1,68 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O0 -ffixed-z0 -ffixed-p0\" } */\n+\n+#include <arm_sve.h>\n+\n+#define ASM_FUNCTION(NAME, RET_TYPE, ARG_TYPE, INSN) \\\n+extern RET_TYPE NAME (svbool_t, ARG_TYPE);\t\\\n+  asm(\t\t\t\t\t\t\\\n+\"\t.type\t\" #NAME \", %function\\n\"\t\t\\\n+#NAME \":\\n\"\t\t\t\t\t\\\n+\"\t\" INSN \"\\n\"\t\t\t\t\\\n+\"\tret\\n\"\t\t\t\t\t\\\n+\"\t.size\t\" #NAME \", .-\" #NAME \"\\n\"\t\\\n+)\n+\n+ASM_FUNCTION (u8_callee, svuint8_t, svuint8x2_t,\n+\t      \"add z0.b, p0/m, z0.b, z1.b\");\n+ASM_FUNCTION (u16_callee, svuint16_t, svuint16x2_t,\n+\t      \"add z0.h, p0/m, z0.h, z1.h\");\n+ASM_FUNCTION (u32_callee, svuint32_t, svuint32x2_t,\n+\t      \"add z0.s, p0/m, z0.s, z1.s\");\n+ASM_FUNCTION (u64_callee, svuint64_t, svuint64x2_t,\n+\t      \"add z0.d, p0/m, z0.d, z1.d\");\n+\n+ASM_FUNCTION (s8_callee, svint8_t, svint8x2_t,\n+\t      \"add z0.b, p0/m, z0.b, z1.b\");\n+ASM_FUNCTION (s16_callee, svint16_t, svint16x2_t,\n+\t      \"add z0.h, p0/m, z0.h, z1.h\");\n+ASM_FUNCTION (s32_callee, svint32_t, svint32x2_t,\n+\t      \"add z0.s, p0/m, z0.s, z1.s\");\n+ASM_FUNCTION (s64_callee, svint64_t, svint64x2_t,\n+\t      \"add z0.d, p0/m, z0.d, z1.d\");\n+\n+ASM_FUNCTION (f16_callee, svfloat16_t, svfloat16x2_t,\n+\t      \"fadd z0.h, p0/m, z0.h, z1.h\");\n+ASM_FUNCTION (f32_callee, svfloat32_t, svfloat32x2_t,\n+\t      \"fadd z0.s, p0/m, z0.s, z1.s\");\n+ASM_FUNCTION (f64_callee, svfloat64_t, svfloat64x2_t,\n+\t      \"fadd z0.d, p0/m, z0.d, z1.d\");\n+\n+int\n+main (void)\n+{\n+#define CHECK(SUFFIX)\t\t\t\t\t\t\t\\\n+  if (svptest_any (svptrue_b8 (),\t\t\t\t\t\\\n+\t\t   svcmpne (svptrue_b8 (),\t\t\t\t\\\n+\t\t\t    SUFFIX##_callee (svptrue_b8 (),\t\t\\\n+\t\t\t\t\t     svcreate2 (svdup_##SUFFIX (3), \\\n+\t\t\t\t\t\t\tsvdup_##SUFFIX (6))), \\\n+\t\t\t    svdup_##SUFFIX (9))))\t\t\t\\\n+    __builtin_abort ()\n+\n+  CHECK (u8);\n+  CHECK (u16);\n+  CHECK (u32);\n+  CHECK (u64);\n+\n+  CHECK (s8);\n+  CHECK (s16);\n+  CHECK (s32);\n+  CHECK (s64);\n+\n+  CHECK (f16);\n+  CHECK (f32);\n+  CHECK (f64);\n+\n+  return 0;\n+}"}]}