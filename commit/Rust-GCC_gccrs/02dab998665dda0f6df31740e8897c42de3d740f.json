{"sha": "02dab998665dda0f6df31740e8897c42de3d740f", "node_id": "C_kwDOANBUbNoAKDAyZGFiOTk4NjY1ZGRhMGY2ZGYzMTc0MGU4ODk3YzQyZGUzZDc0MGY", "commit": {"author": {"name": "Dimitrij Mijoski", "email": "dmjpp@hotmail.com", "date": "2023-01-10T12:58:59Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2023-01-13T13:34:20Z"}, "message": "libstdc++: Fix Unicode codecvt and add tests [PR86419]\n\nFixes the conversion from UTF-8 to UTF-16 to properly return partial\ninstead ok.\nFixes the conversion from UTF-16 to UTF-8 to properly return partial\ninstead ok.\nFixes the conversion from UTF-8 to UCS-2 to properly return partial\ninstead error.\nFixes the conversion from UTF-8 to UCS-2 to treat 4-byte UTF-8 sequences\nas error just by seeing the leading byte.\nFixes UTF-8 decoding for all codecvts so they detect error at the end of\nthe input range when the last code point is also incomplete.\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/86419\n\t* src/c++11/codecvt.cc (read_utf8_code_point): Correctly detect\n\terrors in incomplete multibyte sequences.\n\t(utf16_in): Remove surrogates parameter. Fix conditions for\n\treturning partial.\n\t(utf16_out): Fix condition for returning partial.\n\t(ucs2_in): Do not pass surrogates argument to utf16_in.\n\t* testsuite/22_locale/codecvt/codecvt_unicode.cc: New test.\n\t* testsuite/22_locale/codecvt/codecvt_unicode.h: New header for\n\ttests.\n\t* testsuite/22_locale/codecvt/codecvt_unicode_wchar_t.cc: New\n\ttest.", "tree": {"sha": "54183d7eb0819f3f09d06817991c223717deac8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/54183d7eb0819f3f09d06817991c223717deac8b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/02dab998665dda0f6df31740e8897c42de3d740f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02dab998665dda0f6df31740e8897c42de3d740f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02dab998665dda0f6df31740e8897c42de3d740f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02dab998665dda0f6df31740e8897c42de3d740f/comments", "author": {"login": "dimztimz", "id": 6236568, "node_id": "MDQ6VXNlcjYyMzY1Njg=", "avatar_url": "https://avatars.githubusercontent.com/u/6236568?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dimztimz", "html_url": "https://github.com/dimztimz", "followers_url": "https://api.github.com/users/dimztimz/followers", "following_url": "https://api.github.com/users/dimztimz/following{/other_user}", "gists_url": "https://api.github.com/users/dimztimz/gists{/gist_id}", "starred_url": "https://api.github.com/users/dimztimz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dimztimz/subscriptions", "organizations_url": "https://api.github.com/users/dimztimz/orgs", "repos_url": "https://api.github.com/users/dimztimz/repos", "events_url": "https://api.github.com/users/dimztimz/events{/privacy}", "received_events_url": "https://api.github.com/users/dimztimz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2fc12a5dafadf15d804e1d2541528296e97a847", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2fc12a5dafadf15d804e1d2541528296e97a847", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2fc12a5dafadf15d804e1d2541528296e97a847"}], "stats": {"total": 1432, "additions": 1414, "deletions": 18}, "files": [{"sha": "03f0bfda97298e25c08d511d04654e342e594d57", "filename": "libstdc++-v3/src/c++11/codecvt.cc", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02dab998665dda0f6df31740e8897c42de3d740f/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fcodecvt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02dab998665dda0f6df31740e8897c42de3d740f/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fcodecvt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fcodecvt.cc?ref=02dab998665dda0f6df31740e8897c42de3d740f", "patch": "@@ -277,13 +277,15 @@ namespace\n     }\n     else if (c1 < 0xF0) // 3-byte sequence\n     {\n-      if (avail < 3)\n+      if (avail < 2)\n \treturn incomplete_mb_character;\n       char32_t c2 = (unsigned char) from[1];\n       if ((c2 & 0xC0) != 0x80)\n \treturn invalid_mb_sequence;\n       if (c1 == 0xE0 && c2 < 0xA0) // overlong\n \treturn invalid_mb_sequence;\n+      if (avail < 3)\n+\treturn incomplete_mb_character;\n       char32_t c3 = (unsigned char) from[2];\n       if ((c3 & 0xC0) != 0x80)\n \treturn invalid_mb_sequence;\n@@ -292,20 +294,24 @@ namespace\n \tfrom += 3;\n       return c;\n     }\n-    else if (c1 < 0xF5) // 4-byte sequence\n+    else if (c1 < 0xF5 && maxcode > 0xFFFF) // 4-byte sequence\n     {\n-      if (avail < 4)\n+      if (avail < 2)\n \treturn incomplete_mb_character;\n       char32_t c2 = (unsigned char) from[1];\n       if ((c2 & 0xC0) != 0x80)\n \treturn invalid_mb_sequence;\n       if (c1 == 0xF0 && c2 < 0x90) // overlong\n \treturn invalid_mb_sequence;\n       if (c1 == 0xF4 && c2 >= 0x90) // > U+10FFFF\n-      return invalid_mb_sequence;\n+\treturn invalid_mb_sequence;\n+      if (avail < 3)\n+\treturn incomplete_mb_character;\n       char32_t c3 = (unsigned char) from[2];\n       if ((c3 & 0xC0) != 0x80)\n \treturn invalid_mb_sequence;\n+      if (avail < 4)\n+\treturn incomplete_mb_character;\n       char32_t c4 = (unsigned char) from[3];\n       if ((c4 & 0xC0) != 0x80)\n \treturn invalid_mb_sequence;\n@@ -527,25 +533,19 @@ namespace\n   // Flag indicating whether to process UTF-16 or UCS2\n   enum class surrogates { allowed, disallowed };\n \n-  // utf8 -> utf16 (or utf8 -> ucs2 if s == surrogates::disallowed)\n-  template<typename C8, typename C16>\n+  // utf8 -> utf16 (or utf8 -> ucs2 if maxcode <= 0xFFFF)\n+  template <typename C8, typename C16>\n   codecvt_base::result\n-  utf16_in(range<const C8>& from, range<C16>& to,\n-\t   unsigned long maxcode = max_code_point, codecvt_mode mode = {},\n-\t   surrogates s = surrogates::allowed)\n+  utf16_in(range<const C8> &from, range<C16> &to,\n+\t   unsigned long maxcode = max_code_point, codecvt_mode mode = {})\n   {\n     read_utf8_bom(from, mode);\n     while (from.size() && to.size())\n       {\n \tauto orig = from;\n \tconst char32_t codepoint = read_utf8_code_point(from, maxcode);\n \tif (codepoint == incomplete_mb_character)\n-\t  {\n-\t    if (s == surrogates::allowed)\n-\t      return codecvt_base::partial;\n-\t    else\n-\t      return codecvt_base::error; // No surrogates in UCS2\n-\t  }\n+\t  return codecvt_base::partial;\n \tif (codepoint > maxcode)\n \t  return codecvt_base::error;\n \tif (!write_utf16_code_point(to, codepoint, mode))\n@@ -554,7 +554,7 @@ namespace\n \t    return codecvt_base::partial;\n \t  }\n       }\n-    return codecvt_base::ok;\n+    return from.size() ? codecvt_base::partial : codecvt_base::ok;\n   }\n \n   // utf16 -> utf8 (or ucs2 -> utf8 if s == surrogates::disallowed)\n@@ -576,7 +576,7 @@ namespace\n \t      return codecvt_base::error; // No surrogates in UCS-2\n \n \t    if (from.size() < 2)\n-\t      return codecvt_base::ok; // stop converting at this point\n+\t      return codecvt_base::partial; // stop converting at this point\n \n \t    const char32_t c2 = from[1];\n \t    if (is_low_surrogate(c2))\n@@ -629,7 +629,7 @@ namespace\n   {\n     // UCS-2 only supports characters in the BMP, i.e. one UTF-16 code unit:\n     maxcode = std::min(max_single_utf16_unit, maxcode);\n-    return utf16_in(from, to, maxcode, mode, surrogates::disallowed);\n+    return utf16_in(from, to, maxcode, mode);\n   }\n \n   // ucs2 -> utf8"}, {"sha": "ae4b6c8968f66f86150a35c199cd46ad48494c01", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/codecvt_unicode.cc", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02dab998665dda0f6df31740e8897c42de3d740f/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fcodecvt_unicode.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02dab998665dda0f6df31740e8897c42de3d740f/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fcodecvt_unicode.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fcodecvt_unicode.cc?ref=02dab998665dda0f6df31740e8897c42de3d740f", "patch": "@@ -0,0 +1,68 @@\n+// Copyright (C) 2020-2023 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run { target c++11 } }\n+\n+#include \"codecvt_unicode.h\"\n+\n+#include <codecvt>\n+\n+using namespace std;\n+\n+void\n+test_utf8_utf32_codecvts ()\n+{\n+  using codecvt_c32 = codecvt<char32_t, char, mbstate_t>;\n+  auto loc_c = locale::classic ();\n+  VERIFY (has_facet<codecvt_c32> (loc_c));\n+  auto &cvt = use_facet<codecvt_c32> (loc_c);\n+  test_utf8_utf32_codecvts (cvt);\n+\n+  auto cvt_ptr = to_unique_ptr (new codecvt_utf8<char32_t> ());\n+  test_utf8_utf32_codecvts (*cvt_ptr);\n+}\n+\n+void\n+test_utf8_utf16_codecvts ()\n+{\n+  using codecvt_c16 = codecvt<char16_t, char, mbstate_t>;\n+  auto loc_c = locale::classic ();\n+  VERIFY (has_facet<codecvt_c16> (loc_c));\n+  auto &cvt = use_facet<codecvt_c16> (loc_c);\n+  test_utf8_utf16_cvts (cvt);\n+\n+  auto cvt_ptr = to_unique_ptr (new codecvt_utf8_utf16<char16_t> ());\n+  test_utf8_utf16_cvts (*cvt_ptr);\n+\n+  auto cvt_ptr2 = to_unique_ptr (new codecvt_utf8_utf16<char32_t> ());\n+  test_utf8_utf16_cvts (*cvt_ptr2);\n+}\n+\n+void\n+test_utf8_ucs2_codecvts ()\n+{\n+  auto cvt_ptr = to_unique_ptr (new codecvt_utf8<char16_t> ());\n+  test_utf8_ucs2_cvts (*cvt_ptr);\n+}\n+\n+int\n+main ()\n+{\n+  test_utf8_utf32_codecvts ();\n+  test_utf8_utf16_codecvts ();\n+  test_utf8_ucs2_codecvts ();\n+}"}, {"sha": "99d1a46840e8a4264edd57e52b9845ef5db40548", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/codecvt_unicode.h", "status": "added", "additions": 1269, "deletions": 0, "changes": 1269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02dab998665dda0f6df31740e8897c42de3d740f/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fcodecvt_unicode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02dab998665dda0f6df31740e8897c42de3d740f/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fcodecvt_unicode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fcodecvt_unicode.h?ref=02dab998665dda0f6df31740e8897c42de3d740f", "patch": "@@ -0,0 +1,1269 @@\n+// Copyright (C) 2020-2023 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <locale>\n+#include <string>\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+template <typename T>\n+std::unique_ptr<T>\n+to_unique_ptr (T *ptr)\n+{\n+  return std::unique_ptr<T> (ptr);\n+}\n+\n+struct test_offsets_ok\n+{\n+  size_t in_size, out_size;\n+};\n+struct test_offsets_partial\n+{\n+  size_t in_size, out_size, expected_in_next, expected_out_next;\n+};\n+\n+template <class CharT> struct test_offsets_error\n+{\n+  size_t in_size, out_size, expected_in_next, expected_out_next;\n+  CharT replace_char;\n+  size_t replace_pos;\n+};\n+\n+template <class T, size_t N>\n+auto constexpr array_size (const T (&)[N]) -> size_t\n+{\n+  return N;\n+}\n+\n+template <class CharT>\n+void\n+utf8_to_utf32_in_ok (const std::codecvt<CharT, char, mbstate_t> &cvt)\n+{\n+  using namespace std;\n+  // UTF-8 string of 1-byte CP, 2-byte CP, 3-byte CP and 4-byte CP\n+  const char in[] = \"b\u0448\\uAAAA\\U0010AAAA\";\n+  const char32_t exp_literal[] = U\"b\u0448\\uAAAA\\U0010AAAA\";\n+  CharT exp[array_size (exp_literal)] = {};\n+  std::copy (begin (exp_literal), end (exp_literal), begin (exp));\n+\n+  static_assert (array_size (in) == 11, \"\");\n+  static_assert (array_size (exp_literal) == 5, \"\");\n+  static_assert (array_size (exp) == 5, \"\");\n+  VERIFY (char_traits<char>::length (in) == 10);\n+  VERIFY (char_traits<char32_t>::length (exp_literal) == 4);\n+  VERIFY (char_traits<CharT>::length (exp) == 4);\n+\n+  test_offsets_ok offsets[] = {{0, 0}, {1, 1}, {3, 2}, {6, 3}, {10, 4}};\n+  for (auto t : offsets)\n+    {\n+      CharT out[array_size (exp) - 1] = {};\n+      VERIFY (t.in_size <= array_size (in));\n+      VERIFY (t.out_size <= array_size (out));\n+      auto state = mbstate_t{};\n+      auto in_next = (const char *) nullptr;\n+      auto out_next = (CharT *) nullptr;\n+      auto res = codecvt_base::result ();\n+\n+      res = cvt.in (state, in, in + t.in_size, in_next, out, out + t.out_size,\n+\t\t    out_next);\n+      VERIFY (res == cvt.ok);\n+      VERIFY (in_next == in + t.in_size);\n+      VERIFY (out_next == out + t.out_size);\n+      VERIFY (char_traits<CharT>::compare (out, exp, t.out_size) == 0);\n+      if (t.out_size < array_size (out))\n+\tVERIFY (out[t.out_size] == 0);\n+    }\n+\n+  for (auto t : offsets)\n+    {\n+      CharT out[array_size (exp)] = {};\n+      VERIFY (t.in_size <= array_size (in));\n+      VERIFY (t.out_size <= array_size (out));\n+      auto state = mbstate_t{};\n+      auto in_next = (const char *) nullptr;\n+      auto out_next = (CharT *) nullptr;\n+      auto res = codecvt_base::result ();\n+\n+      res\n+\t= cvt.in (state, in, in + t.in_size, in_next, out, end (out), out_next);\n+      VERIFY (res == cvt.ok);\n+      VERIFY (in_next == in + t.in_size);\n+      VERIFY (out_next == out + t.out_size);\n+      VERIFY (char_traits<CharT>::compare (out, exp, t.out_size) == 0);\n+      if (t.out_size < array_size (out))\n+\tVERIFY (out[t.out_size] == 0);\n+    }\n+}\n+\n+template <class CharT>\n+void\n+utf8_to_utf32_in_partial (const std::codecvt<CharT, char, mbstate_t> &cvt)\n+{\n+  using namespace std;\n+  // UTF-8 string of 1-byte CP, 2-byte CP, 3-byte CP and 4-byte CP\n+  const char in[] = \"b\u0448\\uAAAA\\U0010AAAA\";\n+  const char32_t exp_literal[] = U\"b\u0448\\uAAAA\\U0010AAAA\";\n+  CharT exp[array_size (exp_literal)] = {};\n+  std::copy (begin (exp_literal), end (exp_literal), begin (exp));\n+\n+  static_assert (array_size (in) == 11, \"\");\n+  static_assert (array_size (exp_literal) == 5, \"\");\n+  static_assert (array_size (exp) == 5, \"\");\n+  VERIFY (char_traits<char>::length (in) == 10);\n+  VERIFY (char_traits<char32_t>::length (exp_literal) == 4);\n+  VERIFY (char_traits<CharT>::length (exp) == 4);\n+\n+  test_offsets_partial offsets[] = {\n+    {1, 0, 0, 0}, // no space for first CP\n+\n+    {3, 1, 1, 1}, // no space for second CP\n+    {2, 2, 1, 1}, // incomplete second CP\n+    {2, 1, 1, 1}, // incomplete second CP, and no space for it\n+\n+    {6, 2, 3, 2}, // no space for third CP\n+    {4, 3, 3, 2}, // incomplete third CP\n+    {5, 3, 3, 2}, // incomplete third CP\n+    {4, 2, 3, 2}, // incomplete third CP, and no space for it\n+    {5, 2, 3, 2}, // incomplete third CP, and no space for it\n+\n+    {10, 3, 6, 3}, // no space for fourth CP\n+    {7, 4, 6, 3},  // incomplete fourth CP\n+    {8, 4, 6, 3},  // incomplete fourth CP\n+    {9, 4, 6, 3},  // incomplete fourth CP\n+    {7, 3, 6, 3},  // incomplete fourth CP, and no space for it\n+    {8, 3, 6, 3},  // incomplete fourth CP, and no space for it\n+    {9, 3, 6, 3},  // incomplete fourth CP, and no space for it\n+  };\n+\n+  for (auto t : offsets)\n+    {\n+      CharT out[array_size (exp) - 1] = {};\n+      VERIFY (t.in_size <= array_size (in));\n+      VERIFY (t.out_size <= array_size (out));\n+      VERIFY (t.expected_in_next <= t.in_size);\n+      VERIFY (t.expected_out_next <= t.out_size);\n+      auto state = mbstate_t{};\n+      auto in_next = (const char *) nullptr;\n+      auto out_next = (CharT *) nullptr;\n+      auto res = codecvt_base::result ();\n+\n+      res = cvt.in (state, in, in + t.in_size, in_next, out, out + t.out_size,\n+\t\t    out_next);\n+      VERIFY (res == cvt.partial);\n+      VERIFY (in_next == in + t.expected_in_next);\n+      VERIFY (out_next == out + t.expected_out_next);\n+      VERIFY (char_traits<CharT>::compare (out, exp, t.expected_out_next) == 0);\n+      if (t.expected_out_next < array_size (out))\n+\tVERIFY (out[t.expected_out_next] == 0);\n+    }\n+}\n+\n+template <class CharT>\n+void\n+utf8_to_utf32_in_error (const std::codecvt<CharT, char, mbstate_t> &cvt)\n+{\n+  using namespace std;\n+  // UTF-8 string of 1-byte CP, 2-byte CP, 3-byte CP and 4-byte CP\n+  const char valid_in[] = \"b\u0448\\uAAAA\\U0010AAAA\";\n+  const char32_t exp_literal[] = U\"b\u0448\\uAAAA\\U0010AAAA\";\n+  CharT exp[array_size (exp_literal)] = {};\n+  std::copy (begin (exp_literal), end (exp_literal), begin (exp));\n+\n+  static_assert (array_size (valid_in) == 11, \"\");\n+  static_assert (array_size (exp_literal) == 5, \"\");\n+  static_assert (array_size (exp) == 5, \"\");\n+  VERIFY (char_traits<char>::length (valid_in) == 10);\n+  VERIFY (char_traits<char32_t>::length (exp_literal) == 4);\n+  VERIFY (char_traits<CharT>::length (exp) == 4);\n+\n+  test_offsets_error<char> offsets[] = {\n+\n+    // replace leading byte with invalid byte\n+    {1, 4, 0, 0, '\\xFF', 0},\n+    {3, 4, 1, 1, '\\xFF', 1},\n+    {6, 4, 3, 2, '\\xFF', 3},\n+    {10, 4, 6, 3, '\\xFF', 6},\n+\n+    // replace first trailing byte with ASCII byte\n+    {3, 4, 1, 1, 'z', 2},\n+    {6, 4, 3, 2, 'z', 4},\n+    {10, 4, 6, 3, 'z', 7},\n+\n+    // replace first trailing byte with invalid byte\n+    {3, 4, 1, 1, '\\xFF', 2},\n+    {6, 4, 3, 2, '\\xFF', 4},\n+    {10, 4, 6, 3, '\\xFF', 7},\n+\n+    // replace second trailing byte with ASCII byte\n+    {6, 4, 3, 2, 'z', 5},\n+    {10, 4, 6, 3, 'z', 8},\n+\n+    // replace second trailing byte with invalid byte\n+    {6, 4, 3, 2, '\\xFF', 5},\n+    {10, 4, 6, 3, '\\xFF', 8},\n+\n+    // replace third trailing byte\n+    {10, 4, 6, 3, 'z', 9},\n+    {10, 4, 6, 3, '\\xFF', 9},\n+\n+    // replace first trailing byte with ASCII byte, also incomplete at end\n+    {5, 4, 3, 2, 'z', 4},\n+    {8, 4, 6, 3, 'z', 7},\n+    {9, 4, 6, 3, 'z', 7},\n+\n+    // replace first trailing byte with invalid byte, also incomplete at end\n+    {5, 4, 3, 2, '\\xFF', 4},\n+    {8, 4, 6, 3, '\\xFF', 7},\n+    {9, 4, 6, 3, '\\xFF', 7},\n+\n+    // replace second trailing byte with ASCII byte, also incomplete at end\n+    {9, 4, 6, 3, 'z', 8},\n+\n+    // replace second trailing byte with invalid byte, also incomplete at end\n+    {9, 4, 6, 3, '\\xFF', 8},\n+  };\n+  for (auto t : offsets)\n+    {\n+      char in[array_size (valid_in)] = {};\n+      CharT out[array_size (exp) - 1] = {};\n+      VERIFY (t.in_size <= array_size (in));\n+      VERIFY (t.out_size <= array_size (out));\n+      VERIFY (t.expected_in_next <= t.in_size);\n+      VERIFY (t.expected_out_next <= t.out_size);\n+      char_traits<char>::copy (in, valid_in, array_size (valid_in));\n+      in[t.replace_pos] = t.replace_char;\n+\n+      auto state = mbstate_t{};\n+      auto in_next = (const char *) nullptr;\n+      auto out_next = (CharT *) nullptr;\n+      auto res = codecvt_base::result ();\n+\n+      res = cvt.in (state, in, in + t.in_size, in_next, out, out + t.out_size,\n+\t\t    out_next);\n+      VERIFY (res == cvt.error);\n+      VERIFY (in_next == in + t.expected_in_next);\n+      VERIFY (out_next == out + t.expected_out_next);\n+      VERIFY (char_traits<CharT>::compare (out, exp, t.expected_out_next) == 0);\n+      if (t.expected_out_next < array_size (out))\n+\tVERIFY (out[t.expected_out_next] == 0);\n+    }\n+}\n+\n+template <class CharT>\n+void\n+utf8_to_utf32_in (const std::codecvt<CharT, char, mbstate_t> &cvt)\n+{\n+  utf8_to_utf32_in_ok (cvt);\n+  utf8_to_utf32_in_partial (cvt);\n+  utf8_to_utf32_in_error (cvt);\n+}\n+\n+template <class CharT>\n+void\n+utf32_to_utf8_out_ok (const std::codecvt<CharT, char, mbstate_t> &cvt)\n+{\n+  using namespace std;\n+  // UTF-8 string of 1-byte CP, 2-byte CP, 3-byte CP and 4-byte CP\n+  const char32_t in_literal[] = U\"b\u0448\\uAAAA\\U0010AAAA\";\n+  const char exp[] = \"b\u0448\\uAAAA\\U0010AAAA\";\n+  CharT in[array_size (in_literal)] = {};\n+  copy (begin (in_literal), end (in_literal), begin (in));\n+\n+  static_assert (array_size (in_literal) == 5, \"\");\n+  static_assert (array_size (in) == 5, \"\");\n+  static_assert (array_size (exp) == 11, \"\");\n+  VERIFY (char_traits<char32_t>::length (in_literal) == 4);\n+  VERIFY (char_traits<CharT>::length (in) == 4);\n+  VERIFY (char_traits<char>::length (exp) == 10);\n+\n+  const test_offsets_ok offsets[] = {{0, 0}, {1, 1}, {2, 3}, {3, 6}, {4, 10}};\n+  for (auto t : offsets)\n+    {\n+      char out[array_size (exp) - 1] = {};\n+      VERIFY (t.in_size <= array_size (in));\n+      VERIFY (t.out_size <= array_size (out));\n+      auto state = mbstate_t{};\n+      auto in_next = (const CharT *) nullptr;\n+      auto out_next = (char *) nullptr;\n+      auto res = codecvt_base::result ();\n+\n+      res = cvt.out (state, in, in + t.in_size, in_next, out, out + t.out_size,\n+\t\t     out_next);\n+      VERIFY (res == cvt.ok);\n+      VERIFY (in_next == in + t.in_size);\n+      VERIFY (out_next == out + t.out_size);\n+      VERIFY (char_traits<char>::compare (out, exp, t.out_size) == 0);\n+      if (t.out_size < array_size (out))\n+\tVERIFY (out[t.out_size] == 0);\n+    }\n+}\n+\n+template <class CharT>\n+void\n+utf32_to_utf8_out_partial (const std::codecvt<CharT, char, mbstate_t> &cvt)\n+{\n+  using namespace std;\n+  // UTF-8 string of 1-byte CP, 2-byte CP, 3-byte CP and 4-byte CP\n+  const char32_t in_literal[] = U\"b\u0448\\uAAAA\\U0010AAAA\";\n+  const char exp[] = \"b\u0448\\uAAAA\\U0010AAAA\";\n+  CharT in[array_size (in_literal)] = {};\n+  copy (begin (in_literal), end (in_literal), begin (in));\n+\n+  static_assert (array_size (in_literal) == 5, \"\");\n+  static_assert (array_size (in) == 5, \"\");\n+  static_assert (array_size (exp) == 11, \"\");\n+  VERIFY (char_traits<char32_t>::length (in_literal) == 4);\n+  VERIFY (char_traits<CharT>::length (in) == 4);\n+  VERIFY (char_traits<char>::length (exp) == 10);\n+\n+  const test_offsets_partial offsets[] = {\n+    {1, 0, 0, 0}, // no space for first CP\n+\n+    {2, 1, 1, 1}, // no space for second CP\n+    {2, 2, 1, 1}, // no space for second CP\n+\n+    {3, 3, 2, 3}, // no space for third CP\n+    {3, 4, 2, 3}, // no space for third CP\n+    {3, 5, 2, 3}, // no space for third CP\n+\n+    {4, 6, 3, 6}, // no space for fourth CP\n+    {4, 7, 3, 6}, // no space for fourth CP\n+    {4, 8, 3, 6}, // no space for fourth CP\n+    {4, 9, 3, 6}, // no space for fourth CP\n+  };\n+  for (auto t : offsets)\n+    {\n+      char out[array_size (exp) - 1] = {};\n+      VERIFY (t.in_size <= array_size (in));\n+      VERIFY (t.out_size <= array_size (out));\n+      VERIFY (t.expected_in_next <= t.in_size);\n+      VERIFY (t.expected_out_next <= t.out_size);\n+      auto state = mbstate_t{};\n+      auto in_next = (const CharT *) nullptr;\n+      auto out_next = (char *) nullptr;\n+      auto res = codecvt_base::result ();\n+\n+      res = cvt.out (state, in, in + t.in_size, in_next, out, out + t.out_size,\n+\t\t     out_next);\n+      VERIFY (res == cvt.partial);\n+      VERIFY (in_next == in + t.expected_in_next);\n+      VERIFY (out_next == out + t.expected_out_next);\n+      VERIFY (char_traits<char>::compare (out, exp, t.expected_out_next) == 0);\n+      if (t.expected_out_next < array_size (out))\n+\tVERIFY (out[t.expected_out_next] == 0);\n+    }\n+}\n+\n+template <class CharT>\n+void\n+utf32_to_utf8_out_error (const std::codecvt<CharT, char, mbstate_t> &cvt)\n+{\n+  using namespace std;\n+  const char32_t valid_in[] = U\"b\u0448\\uAAAA\\U0010AAAA\";\n+  const char exp[] = \"b\u0448\\uAAAA\\U0010AAAA\";\n+\n+  static_assert (array_size (valid_in) == 5, \"\");\n+  static_assert (array_size (exp) == 11, \"\");\n+  VERIFY (char_traits<char32_t>::length (valid_in) == 4);\n+  VERIFY (char_traits<char>::length (exp) == 10);\n+\n+  test_offsets_error<CharT> offsets[] = {{4, 10, 0, 0, 0x00110000, 0},\n+\t\t\t\t\t {4, 10, 1, 1, 0x00110000, 1},\n+\t\t\t\t\t {4, 10, 2, 3, 0x00110000, 2},\n+\t\t\t\t\t {4, 10, 3, 6, 0x00110000, 3}};\n+\n+  for (auto t : offsets)\n+    {\n+      CharT in[array_size (valid_in)] = {};\n+      char out[array_size (exp) - 1] = {};\n+      VERIFY (t.in_size <= array_size (in));\n+      VERIFY (t.out_size <= array_size (out));\n+      VERIFY (t.expected_in_next <= t.in_size);\n+      VERIFY (t.expected_out_next <= t.out_size);\n+      copy (begin (valid_in), end (valid_in), begin (in));\n+      in[t.replace_pos] = t.replace_char;\n+\n+      auto state = mbstate_t{};\n+      auto in_next = (const CharT *) nullptr;\n+      auto out_next = (char *) nullptr;\n+      auto res = codecvt_base::result ();\n+\n+      res = cvt.out (state, in, in + t.in_size, in_next, out, out + t.out_size,\n+\t\t     out_next);\n+      VERIFY (res == cvt.error);\n+      VERIFY (in_next == in + t.expected_in_next);\n+      VERIFY (out_next == out + t.expected_out_next);\n+      VERIFY (char_traits<char>::compare (out, exp, t.expected_out_next) == 0);\n+      if (t.expected_out_next < array_size (out))\n+\tVERIFY (out[t.expected_out_next] == 0);\n+    }\n+}\n+\n+template <class CharT>\n+void\n+utf32_to_utf8_out (const std::codecvt<CharT, char, mbstate_t> &cvt)\n+{\n+  utf32_to_utf8_out_ok (cvt);\n+  utf32_to_utf8_out_partial (cvt);\n+  utf32_to_utf8_out_error (cvt);\n+}\n+\n+template <class CharT>\n+void\n+test_utf8_utf32_codecvts (const std::codecvt<CharT, char, mbstate_t> &cvt)\n+{\n+  utf8_to_utf32_in (cvt);\n+  utf32_to_utf8_out (cvt);\n+}\n+\n+template <class CharT>\n+void\n+utf8_to_utf16_in_ok (const std::codecvt<CharT, char, mbstate_t> &cvt)\n+{\n+  using namespace std;\n+  // UTF-8 string of 1-byte CP, 2-byte CP, 3-byte CP and 4-byte CP\n+  const char in[] = \"b\u0448\\uAAAA\\U0010AAAA\";\n+  const char16_t exp_literal[] = u\"b\u0448\\uAAAA\\U0010AAAA\";\n+  CharT exp[array_size (exp_literal)] = {};\n+  copy (begin (exp_literal), end (exp_literal), begin (exp));\n+\n+  static_assert (array_size (in) == 11, \"\");\n+  static_assert (array_size (exp_literal) == 6, \"\");\n+  static_assert (array_size (exp) == 6, \"\");\n+  VERIFY (char_traits<char>::length (in) == 10);\n+  VERIFY (char_traits<char16_t>::length (exp_literal) == 5);\n+  VERIFY (char_traits<CharT>::length (exp) == 5);\n+\n+  test_offsets_ok offsets[] = {{0, 0}, {1, 1}, {3, 2}, {6, 3}, {10, 5}};\n+  for (auto t : offsets)\n+    {\n+      CharT out[array_size (exp) - 1] = {};\n+      VERIFY (t.in_size <= array_size (in));\n+      VERIFY (t.out_size <= array_size (out));\n+      auto state = mbstate_t{};\n+      auto in_next = (const char *) nullptr;\n+      auto out_next = (CharT *) nullptr;\n+      auto res = codecvt_base::result ();\n+\n+      res = cvt.in (state, in, in + t.in_size, in_next, out, out + t.out_size,\n+\t\t    out_next);\n+      VERIFY (res == cvt.ok);\n+      VERIFY (in_next == in + t.in_size);\n+      VERIFY (out_next == out + t.out_size);\n+      VERIFY (char_traits<CharT>::compare (out, exp, t.out_size) == 0);\n+      if (t.out_size < array_size (out))\n+\tVERIFY (out[t.out_size] == 0);\n+    }\n+\n+  for (auto t : offsets)\n+    {\n+      CharT out[array_size (exp)] = {};\n+      VERIFY (t.in_size <= array_size (in));\n+      VERIFY (t.out_size <= array_size (out));\n+      auto state = mbstate_t{};\n+      auto in_next = (const char *) nullptr;\n+      auto out_next = (CharT *) nullptr;\n+      auto res = codecvt_base::result ();\n+\n+      res\n+\t= cvt.in (state, in, in + t.in_size, in_next, out, end (out), out_next);\n+      VERIFY (res == cvt.ok);\n+      VERIFY (in_next == in + t.in_size);\n+      VERIFY (out_next == out + t.out_size);\n+      VERIFY (char_traits<CharT>::compare (out, exp, t.out_size) == 0);\n+      if (t.out_size < array_size (out))\n+\tVERIFY (out[t.out_size] == 0);\n+    }\n+}\n+\n+template <class CharT>\n+void\n+utf8_to_utf16_in_partial (const std::codecvt<CharT, char, mbstate_t> &cvt)\n+{\n+  using namespace std;\n+  // UTF-8 string of 1-byte CP, 2-byte CP, 3-byte CP and 4-byte CP\n+  const char in[] = \"b\u0448\\uAAAA\\U0010AAAA\";\n+  const char16_t exp_literal[] = u\"b\u0448\\uAAAA\\U0010AAAA\";\n+  CharT exp[array_size (exp_literal)] = {};\n+  copy (begin (exp_literal), end (exp_literal), begin (exp));\n+\n+  static_assert (array_size (in) == 11, \"\");\n+  static_assert (array_size (exp_literal) == 6, \"\");\n+  static_assert (array_size (exp) == 6, \"\");\n+  VERIFY (char_traits<char>::length (in) == 10);\n+  VERIFY (char_traits<char16_t>::length (exp_literal) == 5);\n+  VERIFY (char_traits<CharT>::length (exp) == 5);\n+\n+  test_offsets_partial offsets[] = {\n+    {1, 0, 0, 0}, // no space for first CP\n+\n+    {3, 1, 1, 1}, // no space for second CP\n+    {2, 2, 1, 1}, // incomplete second CP\n+    {2, 1, 1, 1}, // incomplete second CP, and no space for it\n+\n+    {6, 2, 3, 2}, // no space for third CP\n+    {4, 3, 3, 2}, // incomplete third CP\n+    {5, 3, 3, 2}, // incomplete third CP\n+    {4, 2, 3, 2}, // incomplete third CP, and no space for it\n+    {5, 2, 3, 2}, // incomplete third CP, and no space for it\n+\n+    {10, 3, 6, 3}, // no space for fourth CP\n+    {10, 4, 6, 3}, // no space for fourth CP\n+    {7, 5, 6, 3},  // incomplete fourth CP\n+    {8, 5, 6, 3},  // incomplete fourth CP\n+    {9, 5, 6, 3},  // incomplete fourth CP\n+    {7, 3, 6, 3},  // incomplete fourth CP, and no space for it\n+    {8, 3, 6, 3},  // incomplete fourth CP, and no space for it\n+    {9, 3, 6, 3},  // incomplete fourth CP, and no space for it\n+    {7, 4, 6, 3},  // incomplete fourth CP, and no space for it\n+    {8, 4, 6, 3},  // incomplete fourth CP, and no space for it\n+    {9, 4, 6, 3},  // incomplete fourth CP, and no space for it\n+\n+  };\n+\n+  for (auto t : offsets)\n+    {\n+      CharT out[array_size (exp) - 1] = {};\n+      VERIFY (t.in_size <= array_size (in));\n+      VERIFY (t.out_size <= array_size (out));\n+      VERIFY (t.expected_in_next <= t.in_size);\n+      VERIFY (t.expected_out_next <= t.out_size);\n+      auto state = mbstate_t{};\n+      auto in_next = (const char *) nullptr;\n+      auto out_next = (CharT *) nullptr;\n+      auto res = codecvt_base::result ();\n+\n+      res = cvt.in (state, in, in + t.in_size, in_next, out, out + t.out_size,\n+\t\t    out_next);\n+      VERIFY (res == cvt.partial);\n+      VERIFY (in_next == in + t.expected_in_next);\n+      VERIFY (out_next == out + t.expected_out_next);\n+      VERIFY (char_traits<CharT>::compare (out, exp, t.expected_out_next) == 0);\n+      if (t.expected_out_next < array_size (out))\n+\tVERIFY (out[t.expected_out_next] == 0);\n+    }\n+}\n+\n+template <class CharT>\n+void\n+utf8_to_utf16_in_error (const std::codecvt<CharT, char, mbstate_t> &cvt)\n+{\n+  using namespace std;\n+  const char valid_in[] = \"b\u0448\\uAAAA\\U0010AAAA\";\n+  const char16_t exp_literal[] = u\"b\u0448\\uAAAA\\U0010AAAA\";\n+  CharT exp[array_size (exp_literal)] = {};\n+  copy (begin (exp_literal), end (exp_literal), begin (exp));\n+\n+  static_assert (array_size (valid_in) == 11, \"\");\n+  static_assert (array_size (exp_literal) == 6, \"\");\n+  static_assert (array_size (exp) == 6, \"\");\n+  VERIFY (char_traits<char>::length (valid_in) == 10);\n+  VERIFY (char_traits<char16_t>::length (exp_literal) == 5);\n+  VERIFY (char_traits<CharT>::length (exp) == 5);\n+\n+  test_offsets_error<char> offsets[] = {\n+\n+    // replace leading byte with invalid byte\n+    {1, 5, 0, 0, '\\xFF', 0},\n+    {3, 5, 1, 1, '\\xFF', 1},\n+    {6, 5, 3, 2, '\\xFF', 3},\n+    {10, 5, 6, 3, '\\xFF', 6},\n+\n+    // replace first trailing byte with ASCII byte\n+    {3, 5, 1, 1, 'z', 2},\n+    {6, 5, 3, 2, 'z', 4},\n+    {10, 5, 6, 3, 'z', 7},\n+\n+    // replace first trailing byte with invalid byte\n+    {3, 5, 1, 1, '\\xFF', 2},\n+    {6, 5, 3, 2, '\\xFF', 4},\n+    {10, 5, 6, 3, '\\xFF', 7},\n+\n+    // replace second trailing byte with ASCII byte\n+    {6, 5, 3, 2, 'z', 5},\n+    {10, 5, 6, 3, 'z', 8},\n+\n+    // replace second trailing byte with invalid byte\n+    {6, 5, 3, 2, '\\xFF', 5},\n+    {10, 5, 6, 3, '\\xFF', 8},\n+\n+    // replace third trailing byte\n+    {10, 5, 6, 3, 'z', 9},\n+    {10, 5, 6, 3, '\\xFF', 9},\n+\n+    // replace first trailing byte with ASCII byte, also incomplete at end\n+    {5, 5, 3, 2, 'z', 4},\n+    {8, 5, 6, 3, 'z', 7},\n+    {9, 5, 6, 3, 'z', 7},\n+\n+    // replace first trailing byte with invalid byte, also incomplete at end\n+    {5, 5, 3, 2, '\\xFF', 4},\n+    {8, 5, 6, 3, '\\xFF', 7},\n+    {9, 5, 6, 3, '\\xFF', 7},\n+\n+    // replace second trailing byte with ASCII byte, also incomplete at end\n+    {9, 5, 6, 3, 'z', 8},\n+\n+    // replace second trailing byte with invalid byte, also incomplete at end\n+    {9, 5, 6, 3, '\\xFF', 8},\n+  };\n+  for (auto t : offsets)\n+    {\n+      char in[array_size (valid_in)] = {};\n+      CharT out[array_size (exp) - 1] = {};\n+      VERIFY (t.in_size <= array_size (in));\n+      VERIFY (t.out_size <= array_size (out));\n+      VERIFY (t.expected_in_next <= t.in_size);\n+      VERIFY (t.expected_out_next <= t.out_size);\n+      char_traits<char>::copy (in, valid_in, array_size (valid_in));\n+      in[t.replace_pos] = t.replace_char;\n+\n+      auto state = mbstate_t{};\n+      auto in_next = (const char *) nullptr;\n+      auto out_next = (CharT *) nullptr;\n+      auto res = codecvt_base::result ();\n+\n+      res = cvt.in (state, in, in + t.in_size, in_next, out, out + t.out_size,\n+\t\t    out_next);\n+      VERIFY (res == cvt.error);\n+      VERIFY (in_next == in + t.expected_in_next);\n+      VERIFY (out_next == out + t.expected_out_next);\n+      VERIFY (char_traits<CharT>::compare (out, exp, t.expected_out_next) == 0);\n+      if (t.expected_out_next < array_size (out))\n+\tVERIFY (out[t.expected_out_next] == 0);\n+    }\n+}\n+\n+template <class CharT>\n+void\n+utf8_to_utf16_in (const std::codecvt<CharT, char, mbstate_t> &cvt)\n+{\n+  utf8_to_utf16_in_ok (cvt);\n+  utf8_to_utf16_in_partial (cvt);\n+  utf8_to_utf16_in_error (cvt);\n+}\n+\n+template <class CharT>\n+void\n+utf16_to_utf8_out_ok (const std::codecvt<CharT, char, mbstate_t> &cvt)\n+{\n+  using namespace std;\n+  // UTF-8 string of 1-byte CP, 2-byte CP, 3-byte CP and 4-byte CP\n+  const char16_t in_literal[] = u\"b\u0448\\uAAAA\\U0010AAAA\";\n+  const char exp[] = \"b\u0448\\uAAAA\\U0010AAAA\";\n+  CharT in[array_size (in_literal)];\n+  copy (begin (in_literal), end (in_literal), begin (in));\n+\n+  static_assert (array_size (in_literal) == 6, \"\");\n+  static_assert (array_size (exp) == 11, \"\");\n+  static_assert (array_size (in) == 6, \"\");\n+  VERIFY (char_traits<char16_t>::length (in_literal) == 5);\n+  VERIFY (char_traits<char>::length (exp) == 10);\n+  VERIFY (char_traits<CharT>::length (in) == 5);\n+\n+  const test_offsets_ok offsets[] = {{0, 0}, {1, 1}, {2, 3}, {3, 6}, {5, 10}};\n+  for (auto t : offsets)\n+    {\n+      char out[array_size (exp) - 1] = {};\n+      VERIFY (t.in_size <= array_size (in));\n+      VERIFY (t.out_size <= array_size (out));\n+      auto state = mbstate_t{};\n+      auto in_next = (const CharT *) nullptr;\n+      auto out_next = (char *) nullptr;\n+      auto res = codecvt_base::result ();\n+\n+      res = cvt.out (state, in, in + t.in_size, in_next, out, out + t.out_size,\n+\t\t     out_next);\n+      VERIFY (res == cvt.ok);\n+      VERIFY (in_next == in + t.in_size);\n+      VERIFY (out_next == out + t.out_size);\n+      VERIFY (char_traits<char>::compare (out, exp, t.out_size) == 0);\n+      if (t.out_size < array_size (out))\n+\tVERIFY (out[t.out_size] == 0);\n+    }\n+}\n+\n+template <class CharT>\n+void\n+utf16_to_utf8_out_partial (const std::codecvt<CharT, char, mbstate_t> &cvt)\n+{\n+  using namespace std;\n+  // UTF-8 string of 1-byte CP, 2-byte CP, 3-byte CP and 4-byte CP\n+  const char16_t in_literal[] = u\"b\u0448\\uAAAA\\U0010AAAA\";\n+  const char exp[] = \"b\u0448\\uAAAA\\U0010AAAA\";\n+  CharT in[array_size (in_literal)];\n+  copy (begin (in_literal), end (in_literal), begin (in));\n+\n+  static_assert (array_size (in_literal) == 6, \"\");\n+  static_assert (array_size (exp) == 11, \"\");\n+  static_assert (array_size (in) == 6, \"\");\n+  VERIFY (char_traits<char16_t>::length (in_literal) == 5);\n+  VERIFY (char_traits<char>::length (exp) == 10);\n+  VERIFY (char_traits<CharT>::length (in) == 5);\n+\n+  const test_offsets_partial offsets[] = {\n+    {1, 0, 0, 0}, // no space for first CP\n+\n+    {2, 1, 1, 1}, // no space for second CP\n+    {2, 2, 1, 1}, // no space for second CP\n+\n+    {3, 3, 2, 3}, // no space for third CP\n+    {3, 4, 2, 3}, // no space for third CP\n+    {3, 5, 2, 3}, // no space for third CP\n+\n+    {5, 6, 3, 6}, // no space for fourth CP\n+    {5, 7, 3, 6}, // no space for fourth CP\n+    {5, 8, 3, 6}, // no space for fourth CP\n+    {5, 9, 3, 6}, // no space for fourth CP\n+\n+    {4, 10, 3, 6}, // incomplete fourth CP\n+\n+    {4, 6, 3, 6}, // incomplete fourth CP, and no space for it\n+    {4, 7, 3, 6}, // incomplete fourth CP, and no space for it\n+    {4, 8, 3, 6}, // incomplete fourth CP, and no space for it\n+    {4, 9, 3, 6}, // incomplete fourth CP, and no space for it\n+  };\n+  for (auto t : offsets)\n+    {\n+      char out[array_size (exp) - 1] = {};\n+      VERIFY (t.in_size <= array_size (in));\n+      VERIFY (t.out_size <= array_size (out));\n+      VERIFY (t.expected_in_next <= t.in_size);\n+      VERIFY (t.expected_out_next <= t.out_size);\n+      auto state = mbstate_t{};\n+      auto in_next = (const CharT *) nullptr;\n+      auto out_next = (char *) nullptr;\n+      auto res = codecvt_base::result ();\n+\n+      res = cvt.out (state, in, in + t.in_size, in_next, out, out + t.out_size,\n+\t\t     out_next);\n+      VERIFY (res == cvt.partial);\n+      VERIFY (in_next == in + t.expected_in_next);\n+      VERIFY (out_next == out + t.expected_out_next);\n+      VERIFY (char_traits<char>::compare (out, exp, t.expected_out_next) == 0);\n+      if (t.expected_out_next < array_size (out))\n+\tVERIFY (out[t.expected_out_next] == 0);\n+    }\n+}\n+\n+template <class CharT>\n+void\n+utf16_to_utf8_out_error (const std::codecvt<CharT, char, mbstate_t> &cvt)\n+{\n+  using namespace std;\n+  const char16_t valid_in[] = u\"b\u0448\\uAAAA\\U0010AAAA\";\n+  const char exp[] = \"b\u0448\\uAAAA\\U0010AAAA\";\n+\n+  static_assert (array_size (valid_in) == 6, \"\");\n+  static_assert (array_size (exp) == 11, \"\");\n+  VERIFY (char_traits<char16_t>::length (valid_in) == 5);\n+  VERIFY (char_traits<char>::length (exp) == 10);\n+\n+  test_offsets_error<CharT> offsets[] = {\n+    {5, 10, 0, 0, 0xD800, 0},\n+    {5, 10, 0, 0, 0xDBFF, 0},\n+    {5, 10, 0, 0, 0xDC00, 0},\n+    {5, 10, 0, 0, 0xDFFF, 0},\n+\n+    {5, 10, 1, 1, 0xD800, 1},\n+    {5, 10, 1, 1, 0xDBFF, 1},\n+    {5, 10, 1, 1, 0xDC00, 1},\n+    {5, 10, 1, 1, 0xDFFF, 1},\n+\n+    {5, 10, 2, 3, 0xD800, 2},\n+    {5, 10, 2, 3, 0xDBFF, 2},\n+    {5, 10, 2, 3, 0xDC00, 2},\n+    {5, 10, 2, 3, 0xDFFF, 2},\n+\n+    // make the leading surrogate a trailing one\n+    {5, 10, 3, 6, 0xDC00, 3},\n+    {5, 10, 3, 6, 0xDFFF, 3},\n+\n+    // make the trailing surrogate a leading one\n+    {5, 10, 3, 6, 0xD800, 4},\n+    {5, 10, 3, 6, 0xDBFF, 4},\n+\n+    // make the trailing surrogate a BMP char\n+    {5, 10, 3, 6, u'z', 4},\n+  };\n+\n+  for (auto t : offsets)\n+    {\n+      CharT in[array_size (valid_in)] = {};\n+      char out[array_size (exp) - 1] = {};\n+      VERIFY (t.in_size <= array_size (in));\n+      VERIFY (t.out_size <= array_size (out));\n+      VERIFY (t.expected_in_next <= t.in_size);\n+      VERIFY (t.expected_out_next <= t.out_size);\n+      copy (begin (valid_in), end (valid_in), begin (in));\n+      in[t.replace_pos] = t.replace_char;\n+\n+      auto state = mbstate_t{};\n+      auto in_next = (const CharT *) nullptr;\n+      auto out_next = (char *) nullptr;\n+      auto res = codecvt_base::result ();\n+\n+      res = cvt.out (state, in, in + t.in_size, in_next, out, out + t.out_size,\n+\t\t     out_next);\n+      VERIFY (res == cvt.error);\n+      VERIFY (in_next == in + t.expected_in_next);\n+      VERIFY (out_next == out + t.expected_out_next);\n+      VERIFY (char_traits<char>::compare (out, exp, t.expected_out_next) == 0);\n+      if (t.expected_out_next < array_size (out))\n+\tVERIFY (out[t.expected_out_next] == 0);\n+    }\n+}\n+\n+template <class CharT>\n+void\n+utf16_to_utf8_out (const std::codecvt<CharT, char, mbstate_t> &cvt)\n+{\n+  utf16_to_utf8_out_ok (cvt);\n+  utf16_to_utf8_out_partial (cvt);\n+  utf16_to_utf8_out_error (cvt);\n+}\n+\n+template <class CharT>\n+void\n+test_utf8_utf16_cvts (const std::codecvt<CharT, char, mbstate_t> &cvt)\n+{\n+  utf8_to_utf16_in (cvt);\n+  utf16_to_utf8_out (cvt);\n+}\n+\n+template <class CharT>\n+void\n+utf8_to_ucs2_in_ok (const std::codecvt<CharT, char, mbstate_t> &cvt)\n+{\n+  using namespace std;\n+  // UTF-8 string of 1-byte CP, 2-byte CP and 3-byte CP\n+  const char in[] = \"b\u0448\\uAAAA\";\n+  const char16_t exp_literal[] = u\"b\u0448\\uAAAA\";\n+  CharT exp[array_size (exp_literal)] = {};\n+  copy (begin (exp_literal), end (exp_literal), begin (exp));\n+\n+  static_assert (array_size (in) == 7, \"\");\n+  static_assert (array_size (exp_literal) == 4, \"\");\n+  static_assert (array_size (exp) == 4, \"\");\n+  VERIFY (char_traits<char>::length (in) == 6);\n+  VERIFY (char_traits<char16_t>::length (exp_literal) == 3);\n+  VERIFY (char_traits<CharT>::length (exp) == 3);\n+\n+  test_offsets_ok offsets[] = {{0, 0}, {1, 1}, {3, 2}, {6, 3}};\n+  for (auto t : offsets)\n+    {\n+      CharT out[array_size (exp) - 1] = {};\n+      VERIFY (t.in_size <= array_size (in));\n+      VERIFY (t.out_size <= array_size (out));\n+      auto state = mbstate_t{};\n+      auto in_next = (const char *) nullptr;\n+      auto out_next = (CharT *) nullptr;\n+      auto res = codecvt_base::result ();\n+\n+      res = cvt.in (state, in, in + t.in_size, in_next, out, out + t.out_size,\n+\t\t    out_next);\n+      VERIFY (res == cvt.ok);\n+      VERIFY (in_next == in + t.in_size);\n+      VERIFY (out_next == out + t.out_size);\n+      VERIFY (char_traits<CharT>::compare (out, exp, t.out_size) == 0);\n+      if (t.out_size < array_size (out))\n+\tVERIFY (out[t.out_size] == 0);\n+    }\n+\n+  for (auto t : offsets)\n+    {\n+      CharT out[array_size (exp)] = {};\n+      VERIFY (t.in_size <= array_size (in));\n+      VERIFY (t.out_size <= array_size (out));\n+      auto state = mbstate_t{};\n+      auto in_next = (const char *) nullptr;\n+      auto out_next = (CharT *) nullptr;\n+      auto res = codecvt_base::result ();\n+\n+      res\n+\t= cvt.in (state, in, in + t.in_size, in_next, out, end (out), out_next);\n+      VERIFY (res == cvt.ok);\n+      VERIFY (in_next == in + t.in_size);\n+      VERIFY (out_next == out + t.out_size);\n+      VERIFY (char_traits<CharT>::compare (out, exp, t.out_size) == 0);\n+      if (t.out_size < array_size (out))\n+\tVERIFY (out[t.out_size] == 0);\n+    }\n+}\n+\n+template <class CharT>\n+void\n+utf8_to_ucs2_in_partial (const std::codecvt<CharT, char, mbstate_t> &cvt)\n+{\n+  using namespace std;\n+  // UTF-8 string of 1-byte CP, 2-byte CP and 3-byte CP\n+  const char in[] = \"b\u0448\\uAAAA\";\n+  const char16_t exp_literal[] = u\"b\u0448\\uAAAA\";\n+  CharT exp[array_size (exp_literal)] = {};\n+  copy (begin (exp_literal), end (exp_literal), begin (exp));\n+\n+  static_assert (array_size (in) == 7, \"\");\n+  static_assert (array_size (exp_literal) == 4, \"\");\n+  static_assert (array_size (exp) == 4, \"\");\n+  VERIFY (char_traits<char>::length (in) == 6);\n+  VERIFY (char_traits<char16_t>::length (exp_literal) == 3);\n+  VERIFY (char_traits<CharT>::length (exp) == 3);\n+\n+  test_offsets_partial offsets[] = {\n+    {1, 0, 0, 0}, // no space for first CP\n+\n+    {3, 1, 1, 1}, // no space for second CP\n+    {2, 2, 1, 1}, // incomplete second CP\n+    {2, 1, 1, 1}, // incomplete second CP, and no space for it\n+\n+    {6, 2, 3, 2}, // no space for third CP\n+    {4, 3, 3, 2}, // incomplete third CP\n+    {5, 3, 3, 2}, // incomplete third CP\n+    {4, 2, 3, 2}, // incomplete third CP, and no space for it\n+    {5, 2, 3, 2}, // incomplete third CP, and no space for it\n+  };\n+\n+  for (auto t : offsets)\n+    {\n+      CharT out[array_size (exp) - 1] = {};\n+      VERIFY (t.in_size <= array_size (in));\n+      VERIFY (t.out_size <= array_size (out));\n+      VERIFY (t.expected_in_next <= t.in_size);\n+      VERIFY (t.expected_out_next <= t.out_size);\n+      auto state = mbstate_t{};\n+      auto in_next = (const char *) nullptr;\n+      auto out_next = (CharT *) nullptr;\n+      auto res = codecvt_base::result ();\n+\n+      res = cvt.in (state, in, in + t.in_size, in_next, out, out + t.out_size,\n+\t\t    out_next);\n+      VERIFY (res == cvt.partial);\n+      VERIFY (in_next == in + t.expected_in_next);\n+      VERIFY (out_next == out + t.expected_out_next);\n+      VERIFY (char_traits<CharT>::compare (out, exp, t.expected_out_next) == 0);\n+      if (t.expected_out_next < array_size (out))\n+\tVERIFY (out[t.expected_out_next] == 0);\n+    }\n+}\n+\n+template <class CharT>\n+void\n+utf8_to_ucs2_in_error (const std::codecvt<CharT, char, mbstate_t> &cvt)\n+{\n+  using namespace std;\n+  const char valid_in[] = \"b\u0448\\uAAAA\\U0010AAAA\";\n+  const char16_t exp_literal[] = u\"b\u0448\\uAAAA\\U0010AAAA\";\n+  CharT exp[array_size (exp_literal)] = {};\n+  copy (begin (exp_literal), end (exp_literal), begin (exp));\n+\n+  static_assert (array_size (valid_in) == 11, \"\");\n+  static_assert (array_size (exp_literal) == 6, \"\");\n+  static_assert (array_size (exp) == 6, \"\");\n+  VERIFY (char_traits<char>::length (valid_in) == 10);\n+  VERIFY (char_traits<char16_t>::length (exp_literal) == 5);\n+  VERIFY (char_traits<CharT>::length (exp) == 5);\n+\n+  test_offsets_error<char> offsets[] = {\n+\n+    // replace leading byte with invalid byte\n+    {1, 5, 0, 0, '\\xFF', 0},\n+    {3, 5, 1, 1, '\\xFF', 1},\n+    {6, 5, 3, 2, '\\xFF', 3},\n+    {10, 5, 6, 3, '\\xFF', 6},\n+\n+    // replace first trailing byte with ASCII byte\n+    {3, 5, 1, 1, 'z', 2},\n+    {6, 5, 3, 2, 'z', 4},\n+    {10, 5, 6, 3, 'z', 7},\n+\n+    // replace first trailing byte with invalid byte\n+    {3, 5, 1, 1, '\\xFF', 2},\n+    {6, 5, 3, 2, '\\xFF', 4},\n+    {10, 5, 6, 3, '\\xFF', 7},\n+\n+    // replace second trailing byte with ASCII byte\n+    {6, 5, 3, 2, 'z', 5},\n+    {10, 5, 6, 3, 'z', 8},\n+\n+    // replace second trailing byte with invalid byte\n+    {6, 5, 3, 2, '\\xFF', 5},\n+    {10, 5, 6, 3, '\\xFF', 8},\n+\n+    // replace third trailing byte\n+    {10, 5, 6, 3, 'z', 9},\n+    {10, 5, 6, 3, '\\xFF', 9},\n+\n+    // When we see a leading byte of 4-byte CP, we should return error, no\n+    // matter if it is incomplete at the end or has errors in the trailing\n+    // bytes.\n+\n+    // Don't replace anything, show full 4-byte CP\n+    {10, 4, 6, 3, 'b', 0},\n+    {10, 5, 6, 3, 'b', 0},\n+\n+    // Don't replace anything, show incomplete 4-byte CP at the end\n+    {7, 4, 6, 3, 'b', 0}, // incomplete fourth CP\n+    {8, 4, 6, 3, 'b', 0}, // incomplete fourth CP\n+    {9, 4, 6, 3, 'b', 0}, // incomplete fourth CP\n+    {7, 5, 6, 3, 'b', 0}, // incomplete fourth CP\n+    {8, 5, 6, 3, 'b', 0}, // incomplete fourth CP\n+    {9, 5, 6, 3, 'b', 0}, // incomplete fourth CP\n+\n+    // replace first trailing byte with ASCII byte, also incomplete at end\n+    {5, 5, 3, 2, 'z', 4},\n+\n+    // replace first trailing byte with invalid byte, also incomplete at end\n+    {5, 5, 3, 2, '\\xFF', 4},\n+\n+    // replace first trailing byte with ASCII byte, also incomplete at end\n+    {8, 5, 6, 3, 'z', 7},\n+    {9, 5, 6, 3, 'z', 7},\n+\n+    // replace first trailing byte with invalid byte, also incomplete at end\n+    {8, 5, 6, 3, '\\xFF', 7},\n+    {9, 5, 6, 3, '\\xFF', 7},\n+\n+    // replace second trailing byte with ASCII byte, also incomplete at end\n+    {9, 5, 6, 3, 'z', 8},\n+\n+    // replace second trailing byte with invalid byte, also incomplete at end\n+    {9, 5, 6, 3, '\\xFF', 8},\n+  };\n+  for (auto t : offsets)\n+    {\n+      char in[array_size (valid_in)] = {};\n+      CharT out[array_size (exp) - 1] = {};\n+      VERIFY (t.in_size <= array_size (in));\n+      VERIFY (t.out_size <= array_size (out));\n+      VERIFY (t.expected_in_next <= t.in_size);\n+      VERIFY (t.expected_out_next <= t.out_size);\n+      char_traits<char>::copy (in, valid_in, array_size (valid_in));\n+      in[t.replace_pos] = t.replace_char;\n+\n+      auto state = mbstate_t{};\n+      auto in_next = (const char *) nullptr;\n+      auto out_next = (CharT *) nullptr;\n+      auto res = codecvt_base::result ();\n+\n+      res = cvt.in (state, in, in + t.in_size, in_next, out, out + t.out_size,\n+\t\t    out_next);\n+      VERIFY (res == cvt.error);\n+      VERIFY (in_next == in + t.expected_in_next);\n+      VERIFY (out_next == out + t.expected_out_next);\n+      VERIFY (char_traits<CharT>::compare (out, exp, t.expected_out_next) == 0);\n+      if (t.expected_out_next < array_size (out))\n+\tVERIFY (out[t.expected_out_next] == 0);\n+    }\n+}\n+\n+template <class CharT>\n+void\n+utf8_to_ucs2_in (const std::codecvt<CharT, char, mbstate_t> &cvt)\n+{\n+  utf8_to_ucs2_in_ok (cvt);\n+  utf8_to_ucs2_in_partial (cvt);\n+  utf8_to_ucs2_in_error (cvt);\n+}\n+\n+template <class CharT>\n+void\n+ucs2_to_utf8_out_ok (const std::codecvt<CharT, char, mbstate_t> &cvt)\n+{\n+  using namespace std;\n+  // UTF-8 string of 1-byte CP, 2-byte CP and 3-byte CP\n+  const char16_t in_literal[] = u\"b\u0448\\uAAAA\";\n+  const char exp[] = \"b\u0448\\uAAAA\";\n+  CharT in[array_size (in_literal)] = {};\n+  copy (begin (in_literal), end (in_literal), begin (in));\n+\n+  static_assert (array_size (in_literal) == 4, \"\");\n+  static_assert (array_size (exp) == 7, \"\");\n+  static_assert (array_size (in) == 4, \"\");\n+  VERIFY (char_traits<char16_t>::length (in_literal) == 3);\n+  VERIFY (char_traits<char>::length (exp) == 6);\n+  VERIFY (char_traits<CharT>::length (in) == 3);\n+\n+  const test_offsets_ok offsets[] = {{0, 0}, {1, 1}, {2, 3}, {3, 6}};\n+  for (auto t : offsets)\n+    {\n+      char out[array_size (exp) - 1] = {};\n+      VERIFY (t.in_size <= array_size (in));\n+      VERIFY (t.out_size <= array_size (out));\n+      auto state = mbstate_t{};\n+      auto in_next = (const CharT *) nullptr;\n+      auto out_next = (char *) nullptr;\n+      auto res = codecvt_base::result ();\n+\n+      res = cvt.out (state, in, in + t.in_size, in_next, out, out + t.out_size,\n+\t\t     out_next);\n+      VERIFY (res == cvt.ok);\n+      VERIFY (in_next == in + t.in_size);\n+      VERIFY (out_next == out + t.out_size);\n+      VERIFY (char_traits<char>::compare (out, exp, t.out_size) == 0);\n+      if (t.out_size < array_size (out))\n+\tVERIFY (out[t.out_size] == 0);\n+    }\n+}\n+\n+template <class CharT>\n+void\n+ucs2_to_utf8_out_partial (const std::codecvt<CharT, char, mbstate_t> &cvt)\n+{\n+  using namespace std;\n+  // UTF-8 string of 1-byte CP, 2-byte CP and 3-byte CP\n+  const char16_t in_literal[] = u\"b\u0448\\uAAAA\";\n+  const char exp[] = \"b\u0448\\uAAAA\";\n+  CharT in[array_size (in_literal)] = {};\n+  copy (begin (in_literal), end (in_literal), begin (in));\n+\n+  static_assert (array_size (in_literal) == 4, \"\");\n+  static_assert (array_size (exp) == 7, \"\");\n+  static_assert (array_size (in) == 4, \"\");\n+  VERIFY (char_traits<char16_t>::length (in_literal) == 3);\n+  VERIFY (char_traits<char>::length (exp) == 6);\n+  VERIFY (char_traits<CharT>::length (in) == 3);\n+\n+  const test_offsets_partial offsets[] = {\n+    {1, 0, 0, 0}, // no space for first CP\n+\n+    {2, 1, 1, 1}, // no space for second CP\n+    {2, 2, 1, 1}, // no space for second CP\n+\n+    {3, 3, 2, 3}, // no space for third CP\n+    {3, 4, 2, 3}, // no space for third CP\n+    {3, 5, 2, 3}, // no space for third CP\n+  };\n+  for (auto t : offsets)\n+    {\n+      char out[array_size (exp) - 1] = {};\n+      VERIFY (t.in_size <= array_size (in));\n+      VERIFY (t.out_size <= array_size (out));\n+      VERIFY (t.expected_in_next <= t.in_size);\n+      VERIFY (t.expected_out_next <= t.out_size);\n+      auto state = mbstate_t{};\n+      auto in_next = (const CharT *) nullptr;\n+      auto out_next = (char *) nullptr;\n+      auto res = codecvt_base::result ();\n+\n+      res = cvt.out (state, in, in + t.in_size, in_next, out, out + t.out_size,\n+\t\t     out_next);\n+      VERIFY (res == cvt.partial);\n+      VERIFY (in_next == in + t.expected_in_next);\n+      VERIFY (out_next == out + t.expected_out_next);\n+      VERIFY (char_traits<char>::compare (out, exp, t.expected_out_next) == 0);\n+      if (t.expected_out_next < array_size (out))\n+\tVERIFY (out[t.expected_out_next] == 0);\n+    }\n+}\n+\n+template <class CharT>\n+void\n+ucs2_to_utf8_out_error (const std::codecvt<CharT, char, mbstate_t> &cvt)\n+{\n+  using namespace std;\n+  const char16_t valid_in[] = u\"b\u0448\\uAAAA\\U0010AAAA\";\n+  const char exp[] = \"b\u0448\\uAAAA\\U0010AAAA\";\n+\n+  static_assert (array_size (valid_in) == 6, \"\");\n+  static_assert (array_size (exp) == 11, \"\");\n+  VERIFY (char_traits<char16_t>::length (valid_in) == 5);\n+  VERIFY (char_traits<char>::length (exp) == 10);\n+\n+  test_offsets_error<CharT> offsets[] = {\n+    {5, 10, 0, 0, 0xD800, 0},\n+    {5, 10, 0, 0, 0xDBFF, 0},\n+    {5, 10, 0, 0, 0xDC00, 0},\n+    {5, 10, 0, 0, 0xDFFF, 0},\n+\n+    {5, 10, 1, 1, 0xD800, 1},\n+    {5, 10, 1, 1, 0xDBFF, 1},\n+    {5, 10, 1, 1, 0xDC00, 1},\n+    {5, 10, 1, 1, 0xDFFF, 1},\n+\n+    {5, 10, 2, 3, 0xD800, 2},\n+    {5, 10, 2, 3, 0xDBFF, 2},\n+    {5, 10, 2, 3, 0xDC00, 2},\n+    {5, 10, 2, 3, 0xDFFF, 2},\n+\n+    // dont replace anything, just show the surrogate pair\n+    {5, 10, 3, 6, u'b', 0},\n+\n+    // make the leading surrogate a trailing one\n+    {5, 10, 3, 6, 0xDC00, 3},\n+    {5, 10, 3, 6, 0xDFFF, 3},\n+\n+    // make the trailing surrogate a leading one\n+    {5, 10, 3, 6, 0xD800, 4},\n+    {5, 10, 3, 6, 0xDBFF, 4},\n+\n+    // make the trailing surrogate a BMP char\n+    {5, 10, 3, 6, u'z', 4},\n+\n+    {5, 7, 3, 6, u'b', 0}, // no space for fourth CP\n+    {5, 8, 3, 6, u'b', 0}, // no space for fourth CP\n+    {5, 9, 3, 6, u'b', 0}, // no space for fourth CP\n+\n+    {4, 10, 3, 6, u'b', 0}, // incomplete fourth CP\n+    {4, 7, 3, 6, u'b', 0},  // incomplete fourth CP, and no space for it\n+    {4, 8, 3, 6, u'b', 0},  // incomplete fourth CP, and no space for it\n+    {4, 9, 3, 6, u'b', 0},  // incomplete fourth CP, and no space for it\n+\n+  };\n+\n+  for (auto t : offsets)\n+    {\n+      CharT in[array_size (valid_in)] = {};\n+      char out[array_size (exp) - 1] = {};\n+      VERIFY (t.in_size <= array_size (in));\n+      VERIFY (t.out_size <= array_size (out));\n+      VERIFY (t.expected_in_next <= t.in_size);\n+      VERIFY (t.expected_out_next <= t.out_size);\n+      copy (begin (valid_in), end (valid_in), begin (in));\n+      in[t.replace_pos] = t.replace_char;\n+\n+      auto state = mbstate_t{};\n+      auto in_next = (const CharT *) nullptr;\n+      auto out_next = (char *) nullptr;\n+      auto res = codecvt_base::result ();\n+\n+      res = cvt.out (state, in, in + t.in_size, in_next, out, out + t.out_size,\n+\t\t     out_next);\n+      VERIFY (res == cvt.error);\n+      VERIFY (in_next == in + t.expected_in_next);\n+      VERIFY (out_next == out + t.expected_out_next);\n+      VERIFY (char_traits<char>::compare (out, exp, t.expected_out_next) == 0);\n+      if (t.expected_out_next < array_size (out))\n+\tVERIFY (out[t.expected_out_next] == 0);\n+    }\n+}\n+\n+template <class CharT>\n+void\n+ucs2_to_utf8_out (const std::codecvt<CharT, char, mbstate_t> &cvt)\n+{\n+  ucs2_to_utf8_out_ok (cvt);\n+  ucs2_to_utf8_out_partial (cvt);\n+  ucs2_to_utf8_out_error (cvt);\n+}\n+\n+template <class CharT>\n+void\n+test_utf8_ucs2_cvts (const std::codecvt<CharT, char, mbstate_t> &cvt)\n+{\n+  utf8_to_ucs2_in (cvt);\n+  ucs2_to_utf8_out (cvt);\n+}"}, {"sha": "169504939a2a29d0ce8388da983c60a978c7620a", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/codecvt_unicode_wchar_t.cc", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02dab998665dda0f6df31740e8897c42de3d740f/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fcodecvt_unicode_wchar_t.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02dab998665dda0f6df31740e8897c42de3d740f/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fcodecvt_unicode_wchar_t.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fcodecvt_unicode_wchar_t.cc?ref=02dab998665dda0f6df31740e8897c42de3d740f", "patch": "@@ -0,0 +1,59 @@\n+// Copyright (C) 2020-2023 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run { target c++11 } }\n+\n+#include \"codecvt_unicode.h\"\n+\n+#include <codecvt>\n+\n+using namespace std;\n+\n+void\n+test_utf8_utf32_codecvts ()\n+{\n+#if __SIZEOF_WCHAR_T__ == 4\n+  auto cvt_ptr = to_unique_ptr (new codecvt_utf8<wchar_t> ());\n+  test_utf8_utf32_codecvts (*cvt_ptr);\n+#endif\n+}\n+\n+void\n+test_utf8_utf16_codecvts ()\n+{\n+#if __SIZEOF_WCHAR_T__ >= 2\n+  auto cvt_ptr = to_unique_ptr (new codecvt_utf8_utf16<wchar_t> ());\n+  test_utf8_utf16_cvts (*cvt_ptr);\n+#endif\n+}\n+\n+void\n+test_utf8_ucs2_codecvts ()\n+{\n+#if __SIZEOF_WCHAR_T__ == 2\n+  auto cvt_ptr = to_unique_ptr (new codecvt_utf8<wchar_t> ());\n+  test_utf8_ucs2_cvts (*cvt_ptr);\n+#endif\n+}\n+\n+int\n+main ()\n+{\n+  test_utf8_utf32_codecvts ();\n+  test_utf8_utf16_codecvts ();\n+  test_utf8_ucs2_codecvts ();\n+}"}]}