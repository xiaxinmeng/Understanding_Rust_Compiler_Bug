{"sha": "f1f4e530a59db86e577e9e83871626c782e33585", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjFmNGU1MzBhNTlkYjg2ZTU3N2U5ZTgzODcxNjI2Yzc4MmUzMzU4NQ==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2006-12-20T16:25:00Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2006-12-20T16:25:00Z"}, "message": "rtlanal.c (struct subreg_info, [...]): New.\n\n\t* rtlanal.c (struct subreg_info, subreg_get_info, subreg_nregs):\n\tNew.\n\t(subreg_regno_offset, subreg_offset_representable_p): Change to\n\twrappers about subreg_get_info.\n\t(refers_to_regno_p, reg_overlap_mentioned_p): Use subreg_nregs.\n\t* rtl.h (subreg_nregs): Declare.\n\t* doc/tm.texi (HARD_REGNO_NREGS_HAS_PADDING): Update to refer to\n\tsubreg_get_info.\n\t* caller-save.c (mark_set_regs, add_stored_regs): Use\n\tsubreg_nregs.\n\t* df-scan.c (df_ref_record): Use subreg_nregs.\n\t* flow.c (mark_set_1): Use subreg_nregs.\n\t* postreload.c (move2add_note_store): Use subreg_nregs.\n\t* reload.c (decompose, refers_to_regno_for_reload_p,\n\treg_overlap_mentioned_for_reload_p): Use subreg_nregs.\n\t* resource.c (update_live_status, mark_referenced_resources,\n\tmark_set_resources): Use subreg_nregs.\n\nFrom-SVN: r120076", "tree": {"sha": "e5723b345a12a4d1072befdb9b246a6a0ddc5270", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e5723b345a12a4d1072befdb9b246a6a0ddc5270"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f1f4e530a59db86e577e9e83871626c782e33585", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1f4e530a59db86e577e9e83871626c782e33585", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1f4e530a59db86e577e9e83871626c782e33585", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1f4e530a59db86e577e9e83871626c782e33585/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee8c1b05d53213625231c9df895501823b19d44c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee8c1b05d53213625231c9df895501823b19d44c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee8c1b05d53213625231c9df895501823b19d44c"}], "stats": {"total": 323, "additions": 213, "deletions": 110}, "files": [{"sha": "4f145939528fb8cdec241fd67e3b4e6fb54c19f2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1f4e530a59db86e577e9e83871626c782e33585/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1f4e530a59db86e577e9e83871626c782e33585/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f1f4e530a59db86e577e9e83871626c782e33585", "patch": "@@ -1,3 +1,23 @@\n+2006-12-20  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* rtlanal.c (struct subreg_info, subreg_get_info, subreg_nregs):\n+\tNew.\n+\t(subreg_regno_offset, subreg_offset_representable_p): Change to\n+\twrappers about subreg_get_info.\n+\t(refers_to_regno_p, reg_overlap_mentioned_p): Use subreg_nregs.\n+\t* rtl.h (subreg_nregs): Declare.\n+\t* doc/tm.texi (HARD_REGNO_NREGS_HAS_PADDING): Update to refer to\n+\tsubreg_get_info.\n+\t* caller-save.c (mark_set_regs, add_stored_regs): Use\n+\tsubreg_nregs.\n+\t* df-scan.c (df_ref_record): Use subreg_nregs.\n+\t* flow.c (mark_set_1): Use subreg_nregs.\n+\t* postreload.c (move2add_note_store): Use subreg_nregs.\n+\t* reload.c (decompose, refers_to_regno_for_reload_p,\n+\treg_overlap_mentioned_for_reload_p): Use subreg_nregs.\n+\t* resource.c (update_live_status, mark_referenced_resources,\n+\tmark_set_resources): Use subreg_nregs.\n+\n 2006-12-20  Zdenek Dvorak <dvorakz@suse.cz>\n \n \t* loop-unswitch.c (unswitch_loop): Update arguments of"}, {"sha": "86d74ee172653c6393dc69835e1e0f66d499d28d", "filename": "gcc/caller-save.c", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1f4e530a59db86e577e9e83871626c782e33585/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1f4e530a59db86e577e9e83871626c782e33585/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=f1f4e530a59db86e577e9e83871626c782e33585", "patch": "@@ -508,15 +508,17 @@ mark_set_regs (rtx reg, rtx setter ATTRIBUTE_UNUSED, void *data)\n       if (!REG_P (inner) || REGNO (inner) >= FIRST_PSEUDO_REGISTER)\n \treturn;\n       regno = subreg_regno (reg);\n+      endregno = regno + subreg_nregs (reg);\n     }\n   else if (REG_P (reg)\n \t   && REGNO (reg) < FIRST_PSEUDO_REGISTER)\n-    regno = REGNO (reg);\n+    {\n+      regno = REGNO (reg);\n+      endregno = regno + hard_regno_nregs[regno][mode];\n+    }\n   else\n     return;\n \n-  endregno = regno + hard_regno_nregs[regno][mode];\n-\n   for (i = regno; i < endregno; i++)\n     SET_HARD_REG_BIT (*this_insn_sets, i);\n }\n@@ -542,13 +544,17 @@ add_stored_regs (rtx reg, rtx setter, void *data)\n \t\t\t\t    SUBREG_BYTE (reg),\n \t\t\t\t    GET_MODE (reg));\n       reg = SUBREG_REG (reg);\n+      regno = REGNO (reg) + offset;\n+      endregno = regno + subreg_nregs (reg);\n     }\n+  else\n+    {\n+      if (!REG_P (reg) || REGNO (reg) >= FIRST_PSEUDO_REGISTER)\n+\treturn;\n \n-  if (!REG_P (reg) || REGNO (reg) >= FIRST_PSEUDO_REGISTER)\n-    return;\n-\n-  regno = REGNO (reg) + offset;\n-  endregno = regno + hard_regno_nregs[regno][mode];\n+      regno = REGNO (reg) + offset;\n+      endregno = regno + hard_regno_nregs[regno][mode];\n+    }\n \n   for (i = regno; i < endregno; i++)\n     SET_REGNO_REG_SET ((regset) data, i);"}, {"sha": "fea786c01962687ba58d523fff4257d2bd6da46a", "filename": "gcc/df-scan.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1f4e530a59db86e577e9e83871626c782e33585/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1f4e530a59db86e577e9e83871626c782e33585/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=f1f4e530a59db86e577e9e83871626c782e33585", "patch": "@@ -1083,15 +1083,14 @@ df_ref_record (struct dataflow *dflow, rtx reg, rtx *loc,\n       if (!(dflow->flags & DF_HARD_REGS))\n \treturn;\n \n-      /* GET_MODE (reg) is correct here.  We do not want to go into a SUBREG\n-         for the mode, because we only want to add references to regs, which\n-\t are really referenced.  E.g., a (subreg:SI (reg:DI 0) 0) does _not_\n-\t reference the whole reg 0 in DI mode (which would also include\n-\t reg 1, at least, if 0 and 1 are SImode registers).  */\n-      endregno = hard_regno_nregs[regno][GET_MODE (reg)];\n       if (GET_CODE (reg) == SUBREG)\n-        regno += subreg_regno_offset (regno, GET_MODE (SUBREG_REG (reg)),\n-\t\t\t\t      SUBREG_BYTE (reg), GET_MODE (reg));\n+\t{\n+\t  regno += subreg_regno_offset (regno, GET_MODE (SUBREG_REG (reg)),\n+\t\t\t\t\tSUBREG_BYTE (reg), GET_MODE (reg));\n+\t  endregno = subreg_nregs (reg);\n+\t}\n+      else\n+\tendregno = hard_regno_nregs[regno][GET_MODE (reg)];\n       endregno += regno;\n \n       /*  If this is a multiword hardreg, we create some extra datastructures that "}, {"sha": "0896ab8db1733b8807e688a08bcc3dc0ac6233b6", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1f4e530a59db86e577e9e83871626c782e33585/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1f4e530a59db86e577e9e83871626c782e33585/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=f1f4e530a59db86e577e9e83871626c782e33585", "patch": "@@ -1991,7 +1991,7 @@ registers but takes up 128 bits in memory, then this would be\n nonzero.\n \n This macros only needs to be defined if there are cases where\n-@code{subreg_regno_offset} and @code{subreg_offset_representable_p}\n+@code{subreg_get_info}\n would otherwise wrongly determine that a @code{subreg} can be\n represented by an offset to the register number, when in fact such a\n @code{subreg} would contain some of the padding not stored in"}, {"sha": "1da935bda31d9b92cc3be11c83806abc536e2116", "filename": "gcc/flow.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1f4e530a59db86e577e9e83871626c782e33585/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1f4e530a59db86e577e9e83871626c782e33585/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=f1f4e530a59db86e577e9e83871626c782e33585", "patch": "@@ -2791,8 +2791,7 @@ mark_set_1 (struct propagate_block_info *pbi, enum rtx_code code, rtx reg, rtx c\n \t      regno_first += subreg_regno_offset (regno_first, inner_mode,\n \t\t\t\t\t\t  SUBREG_BYTE (reg),\n \t\t\t\t\t\t  outer_mode);\n-\t      regno_last = (regno_first\n-\t\t\t    + hard_regno_nregs[regno_first][outer_mode] - 1);\n+\t      regno_last = regno_first + subreg_nregs (reg) - 1;\n \n \t      /* Since we've just adjusted the register number ranges, make\n \t\t sure REG matches.  Otherwise some_was_live will be clear"}, {"sha": "d1e58ab944d4ef823ef105847e42d7c119e67976", "filename": "gcc/postreload.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1f4e530a59db86e577e9e83871626c782e33585/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1f4e530a59db86e577e9e83871626c782e33585/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=f1f4e530a59db86e577e9e83871626c782e33585", "patch": "@@ -1429,6 +1429,7 @@ static void\n move2add_note_store (rtx dst, rtx set, void *data ATTRIBUTE_UNUSED)\n {\n   unsigned int regno = 0;\n+  unsigned int nregs = 0;\n   unsigned int i;\n   enum machine_mode mode = GET_MODE (dst);\n \n@@ -1438,6 +1439,7 @@ move2add_note_store (rtx dst, rtx set, void *data ATTRIBUTE_UNUSED)\n \t\t\t\t   GET_MODE (SUBREG_REG (dst)),\n \t\t\t\t   SUBREG_BYTE (dst),\n \t\t\t\t   GET_MODE (dst));\n+      nregs = subreg_nregs (dst);\n       dst = SUBREG_REG (dst);\n     }\n \n@@ -1455,9 +1457,11 @@ move2add_note_store (rtx dst, rtx set, void *data ATTRIBUTE_UNUSED)\n     return;\n \n   regno += REGNO (dst);\n+  if (!nregs)\n+    nregs = hard_regno_nregs[regno][mode];\n \n   if (SCALAR_INT_MODE_P (GET_MODE (dst))\n-      && hard_regno_nregs[regno][mode] == 1 && GET_CODE (set) == SET\n+      && nregs == 1 && GET_CODE (set) == SET\n       && GET_CODE (SET_DEST (set)) != ZERO_EXTRACT\n       && GET_CODE (SET_DEST (set)) != STRICT_LOW_PART)\n     {\n@@ -1557,7 +1561,7 @@ move2add_note_store (rtx dst, rtx set, void *data ATTRIBUTE_UNUSED)\n     }\n   else\n     {\n-      unsigned int endregno = regno + hard_regno_nregs[regno][mode];\n+      unsigned int endregno = regno + nregs;\n \n       for (i = regno; i < endregno; i++)\n \t/* Reset the information about this register.  */"}, {"sha": "50af5d5e36621be1cadd6b4a8fba19b1620539df", "filename": "gcc/reload.c", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1f4e530a59db86e577e9e83871626c782e33585/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1f4e530a59db86e577e9e83871626c782e33585/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=f1f4e530a59db86e577e9e83871626c782e33585", "patch": "@@ -2414,7 +2414,7 @@ decompose (rtx x)\n \treturn decompose (SUBREG_REG (x));\n       else\n \t/* A hard reg.  */\n-\tval.end = val.start + hard_regno_nregs[val.start][GET_MODE (x)];\n+\tval.end = val.start + subreg_nregs (x);\n       break;\n \n     case SCRATCH:\n@@ -6381,7 +6381,7 @@ refers_to_regno_for_reload_p (unsigned int regno, unsigned int endregno,\n \t  unsigned int inner_regno = subreg_regno (x);\n \t  unsigned int inner_endregno\n \t    = inner_regno + (inner_regno < FIRST_PSEUDO_REGISTER\n-\t\t\t     ? hard_regno_nregs[inner_regno][GET_MODE (x)] : 1);\n+\t\t\t     ? subreg_nregs (x) : 1);\n \n \t  return endregno > inner_regno && regno < inner_endregno;\n \t}\n@@ -6479,6 +6479,10 @@ reg_overlap_mentioned_for_reload_p (rtx x, rtx in)\n \t\t\t\t      GET_MODE (SUBREG_REG (x)),\n \t\t\t\t      SUBREG_BYTE (x),\n \t\t\t\t      GET_MODE (x));\n+      endregno = regno + (regno < FIRST_PSEUDO_REGISTER\n+\t\t\t  ? subreg_nregs (x) : 1);\n+\n+      return refers_to_regno_for_reload_p (regno, endregno, in, (rtx*) 0);\n     }\n   else if (REG_P (x))\n     {\n@@ -6494,6 +6498,10 @@ reg_overlap_mentioned_for_reload_p (rtx x, rtx in)\n \t  gcc_assert (reg_equiv_constant[regno]);\n \t  return 0;\n \t}\n+\n+      endregno = regno + hard_regno_nregs[regno][GET_MODE (x)];\n+\n+      return refers_to_regno_for_reload_p (regno, endregno, in, (rtx*) 0);\n     }\n   else if (MEM_P (x))\n     return refers_to_mem_for_reload_p (in);\n@@ -6520,10 +6528,7 @@ reg_overlap_mentioned_for_reload_p (rtx x, rtx in)\n \t\t   || reg_overlap_mentioned_for_reload_p (XEXP (x, 1), in));\n     }\n \n-  endregno = regno + (regno < FIRST_PSEUDO_REGISTER\n-\t\t      ? hard_regno_nregs[regno][GET_MODE (x)] : 1);\n-\n-  return refers_to_regno_for_reload_p (regno, endregno, in, (rtx*) 0);\n+  gcc_unreachable ();\n }\n \n /* Return nonzero if anything in X contains a MEM.  Look also for pseudo"}, {"sha": "398db5c9c404bfe7af9c6d81d09a1c51da928bc5", "filename": "gcc/resource.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1f4e530a59db86e577e9e83871626c782e33585/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1f4e530a59db86e577e9e83871626c782e33585/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=f1f4e530a59db86e577e9e83871626c782e33585", "patch": "@@ -99,11 +99,17 @@ update_live_status (rtx dest, rtx x, void *data ATTRIBUTE_UNUSED)\n     return;\n \n   if (GET_CODE (dest) == SUBREG)\n-    first_regno = subreg_regno (dest);\n-  else\n-    first_regno = REGNO (dest);\n+    {\n+      first_regno = subreg_regno (dest);\n+      last_regno = first_regno + subreg_nregs (dest);\n \n-  last_regno = first_regno + hard_regno_nregs[first_regno][GET_MODE (dest)];\n+    }\n+  else\n+    {\n+      first_regno = REGNO (dest);\n+      last_regno\n+\t= first_regno + hard_regno_nregs[first_regno][GET_MODE (dest)];\n+    }\n \n   if (GET_CODE (x) == CLOBBER)\n     for (i = first_regno; i < last_regno; i++)\n@@ -229,8 +235,7 @@ mark_referenced_resources (rtx x, struct resources *res,\n       else\n \t{\n \t  unsigned int regno = subreg_regno (x);\n-\t  unsigned int last_regno\n-\t    = regno + hard_regno_nregs[regno][GET_MODE (x)];\n+\t  unsigned int last_regno = regno + subreg_nregs (x);\n \n \t  gcc_assert (last_regno <= FIRST_PSEUDO_REGISTER);\n \t  for (r = regno; r < last_regno; r++)\n@@ -763,8 +768,7 @@ mark_set_resources (rtx x, struct resources *res, int in_dest,\n \t  else\n \t    {\n \t      unsigned int regno = subreg_regno (x);\n-\t      unsigned int last_regno\n-\t\t= regno + hard_regno_nregs[regno][GET_MODE (x)];\n+\t      unsigned int last_regno = regno + subreg_nregs (x);\n \n \t      gcc_assert (last_regno <= FIRST_PSEUDO_REGISTER);\n \t      for (r = regno; r < last_regno; r++)"}, {"sha": "16de3bbe4b00e4aed435212ae6e7627bbd6c75c1", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1f4e530a59db86e577e9e83871626c782e33585/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1f4e530a59db86e577e9e83871626c782e33585/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=f1f4e530a59db86e577e9e83871626c782e33585", "patch": "@@ -1041,6 +1041,7 @@ extern unsigned int subreg_regno_offset\t(unsigned int, enum machine_mode,\n extern bool subreg_offset_representable_p (unsigned int, enum machine_mode,\n \t\t\t\t\t   unsigned int, enum machine_mode);\n extern unsigned int subreg_regno (rtx);\n+extern unsigned int subreg_nregs (rtx);\n extern unsigned HOST_WIDE_INT nonzero_bits (rtx, enum machine_mode);\n extern unsigned int num_sign_bit_copies (rtx, enum machine_mode);\n extern bool constant_pool_constant_p (rtx);"}, {"sha": "c45a020709f5865c3d54c8cf0ab52256fd66d666", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 140, "deletions": 75, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1f4e530a59db86e577e9e83871626c782e33585/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1f4e530a59db86e577e9e83871626c782e33585/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=f1f4e530a59db86e577e9e83871626c782e33585", "patch": "@@ -38,13 +38,28 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"regs.h\"\n #include \"function.h\"\n \n+/* Information about a subreg of a hard register.  */\n+struct subreg_info\n+{\n+  /* Offset of first hard register involved in the subreg.  */\n+  int offset;\n+  /* Number of hard registers involved in the subreg.  */\n+  int nregs;\n+  /* Whether this subreg can be represented as a hard reg with the new\n+     mode.  */\n+  bool representable_p;\n+};\n+\n /* Forward declarations */\n static void set_of_1 (rtx, rtx, void *);\n static bool covers_regno_p (rtx, unsigned int);\n static bool covers_regno_no_parallel_p (rtx, unsigned int);\n static int rtx_referenced_p_1 (rtx *, void *);\n static int computed_jump_p_1 (rtx);\n static void parms_set (rtx, rtx, void *);\n+static void subreg_get_info (unsigned int, enum machine_mode,\n+\t\t\t     unsigned int, enum machine_mode,\n+\t\t\t     struct subreg_info *);\n \n static unsigned HOST_WIDE_INT cached_nonzero_bits (rtx, enum machine_mode,\n                                                    rtx, enum machine_mode,\n@@ -1176,7 +1191,7 @@ refers_to_regno_p (unsigned int regno, unsigned int endregno, rtx x,\n \t  unsigned int inner_regno = subreg_regno (x);\n \t  unsigned int inner_endregno\n \t    = inner_regno + (inner_regno < FIRST_PSEUDO_REGISTER\n-\t\t\t     ? hard_regno_nregs[inner_regno][GET_MODE (x)] : 1);\n+\t\t\t     ? subreg_nregs (x) : 1);\n \n \t  return endregno > inner_regno && regno < inner_endregno;\n \t}\n@@ -1266,13 +1281,15 @@ reg_overlap_mentioned_p (rtx x, rtx in)\n       regno = REGNO (SUBREG_REG (x));\n       if (regno < FIRST_PSEUDO_REGISTER)\n \tregno = subreg_regno (x);\n+      endregno = regno + (regno < FIRST_PSEUDO_REGISTER\n+\t\t\t  ? subreg_nregs (x) : 1);\n       goto do_reg;\n \n     case REG:\n       regno = REGNO (x);\n-    do_reg:\n       endregno = regno + (regno < FIRST_PSEUDO_REGISTER\n \t\t\t  ? hard_regno_nregs[regno][GET_MODE (x)] : 1);\n+    do_reg:\n       return refers_to_regno_p (regno, endregno, in, (rtx*) 0);\n \n     case MEM:\n@@ -2926,69 +2943,27 @@ subreg_lsb (rtx x)\n \t\t       SUBREG_BYTE (x));\n }\n \n-/* This function returns the regno offset of a subreg expression.\n-   xregno - A regno of an inner hard subreg_reg (or what will become one).\n-   xmode  - The mode of xregno.\n-   offset - The byte offset.\n-   ymode  - The mode of a top level SUBREG (or what may become one).\n-   RETURN - The regno offset which would be used.  */\n-unsigned int\n-subreg_regno_offset (unsigned int xregno, enum machine_mode xmode,\n-\t\t     unsigned int offset, enum machine_mode ymode)\n-{\n-  int nregs_xmode, nregs_ymode;\n-  int mode_multiple, nregs_multiple;\n-  int y_offset;\n-\n-  gcc_assert (xregno < FIRST_PSEUDO_REGISTER);\n-\n-  /* Adjust nregs_xmode to allow for 'holes'.  */\n-  if (HARD_REGNO_NREGS_HAS_PADDING (xregno, xmode))\n-    nregs_xmode = HARD_REGNO_NREGS_WITH_PADDING (xregno, xmode);\n-  else\n-    nregs_xmode = hard_regno_nregs[xregno][xmode];\n-    \n-  nregs_ymode = hard_regno_nregs[xregno][ymode];\n-\n-  /* If this is a big endian paradoxical subreg, which uses more actual\n-     hard registers than the original register, we must return a negative\n-     offset so that we find the proper highpart of the register.  */\n-  if (offset == 0\n-      && nregs_ymode > nregs_xmode\n-      && (GET_MODE_SIZE (ymode) > UNITS_PER_WORD\n-\t  ? WORDS_BIG_ENDIAN : BYTES_BIG_ENDIAN))\n-    return nregs_xmode - nregs_ymode;\n-\n-  if (offset == 0 || nregs_xmode == nregs_ymode)\n-    return 0;\n-\n-  /* Size of ymode must not be greater than the size of xmode.  */\n-  mode_multiple = GET_MODE_SIZE (xmode) / GET_MODE_SIZE (ymode);\n-  gcc_assert (mode_multiple != 0);\n-\n-  y_offset = offset / GET_MODE_SIZE (ymode);\n-  nregs_multiple =  nregs_xmode / nregs_ymode;\n-  return (y_offset / (mode_multiple / nregs_multiple)) * nregs_ymode;\n-}\n-\n-/* This function returns true when the offset is representable via\n-   subreg_offset in the given regno.\n+/* Fill in information about a subreg of a hard register.\n    xregno - A regno of an inner hard subreg_reg (or what will become one).\n    xmode  - The mode of xregno.\n    offset - The byte offset.\n    ymode  - The mode of a top level SUBREG (or what may become one).\n-   RETURN - Whether the offset is representable.  */\n-bool\n-subreg_offset_representable_p (unsigned int xregno, enum machine_mode xmode,\n-\t\t\t       unsigned int offset, enum machine_mode ymode)\n+   info   - Pointer to structure to fill in.  */\n+static void\n+subreg_get_info (unsigned int xregno, enum machine_mode xmode,\n+\t\t unsigned int offset, enum machine_mode ymode,\n+\t\t struct subreg_info *info)\n {\n   int nregs_xmode, nregs_ymode;\n   int mode_multiple, nregs_multiple;\n-  int y_offset;\n+  int offset_adj, y_offset, y_offset_adj;\n   int regsize_xmode, regsize_ymode;\n+  bool rknown;\n \n   gcc_assert (xregno < FIRST_PSEUDO_REGISTER);\n \n+  rknown = false;\n+\n   /* If there are holes in a non-scalar mode in registers, we expect\n      that it is made up of its units concatenated together.  */\n   if (HARD_REGNO_NREGS_HAS_PADDING (xregno, xmode))\n@@ -3021,32 +2996,68 @@ subreg_offset_representable_p (unsigned int xregno, enum machine_mode xmode,\n \t  && (offset / GET_MODE_SIZE (xmode_unit)\n \t      != ((offset + GET_MODE_SIZE (ymode) - 1)\n \t\t  / GET_MODE_SIZE (xmode_unit))))\n-\treturn false;\n+\t{\n+\t  info->representable_p = false;\n+\t  rknown = true;\n+\t}\n     }\n   else\n     nregs_xmode = hard_regno_nregs[xregno][xmode];\n   \n   nregs_ymode = hard_regno_nregs[xregno][ymode];\n \n   /* Paradoxical subregs are otherwise valid.  */\n-  if (offset == 0\n-      && nregs_ymode > nregs_xmode\n-      && (GET_MODE_SIZE (ymode) > UNITS_PER_WORD\n-\t  ? WORDS_BIG_ENDIAN : BYTES_BIG_ENDIAN))\n-    return true;\n+  if (!rknown\n+      && offset == 0\n+      && GET_MODE_SIZE (ymode) > GET_MODE_SIZE (xmode))\n+    {\n+      info->representable_p = true;\n+      /* If this is a big endian paradoxical subreg, which uses more\n+\t actual hard registers than the original register, we must\n+\t return a negative offset so that we find the proper highpart\n+\t of the register.  */\n+      if (GET_MODE_SIZE (ymode) > UNITS_PER_WORD\n+\t  ? WORDS_BIG_ENDIAN : BYTES_BIG_ENDIAN)\n+\tinfo->offset = nregs_xmode - nregs_ymode;\n+      else\n+\tinfo->offset = 0;\n+      info->nregs = nregs_ymode;\n+      return;\n+    }\n \n   /* If registers store different numbers of bits in the different\n      modes, we cannot generally form this subreg.  */\n-  regsize_xmode = GET_MODE_SIZE (xmode) / nregs_xmode;\n-  regsize_ymode = GET_MODE_SIZE (ymode) / nregs_ymode;\n-  if (regsize_xmode > regsize_ymode && nregs_ymode > 1)\n-    return false;\n-  if (regsize_ymode > regsize_xmode && nregs_xmode > 1)\n-    return false;\n+  if (!HARD_REGNO_NREGS_HAS_PADDING (xregno, xmode)\n+      && !HARD_REGNO_NREGS_HAS_PADDING (xregno, ymode))\n+    {\n+      regsize_xmode = GET_MODE_SIZE (xmode) / nregs_xmode;\n+      gcc_assert (regsize_xmode * nregs_xmode == GET_MODE_SIZE (xmode));\n+      regsize_ymode = GET_MODE_SIZE (ymode) / nregs_ymode;\n+      gcc_assert (regsize_ymode * nregs_ymode == GET_MODE_SIZE (ymode));\n+      if (!rknown && regsize_xmode > regsize_ymode && nregs_ymode > 1)\n+\t{\n+\t  info->representable_p = false;\n+\t  info->nregs\n+\t    = (GET_MODE_SIZE (ymode) + regsize_xmode - 1) / regsize_xmode;\n+\t  info->offset = offset / regsize_xmode;\n+\t  return;\n+\t}\n+      if (!rknown && regsize_ymode > regsize_xmode && nregs_xmode > 1)\n+\t{\n+\t  info->representable_p = false;\n+\t  info->nregs\n+\t    = (GET_MODE_SIZE (ymode) + regsize_xmode - 1) / regsize_xmode;\n+\t  info->offset = offset / regsize_xmode;\n+\t  return;\n+\t}\n+    }\n \n   /* Lowpart subregs are otherwise valid.  */\n-  if (offset == subreg_lowpart_offset (ymode, xmode))\n-    return true;\n+  if (!rknown && offset == subreg_lowpart_offset (ymode, xmode))\n+    {\n+      info->representable_p = true;\n+      rknown = true;\n+    }\n \n   /* This should always pass, otherwise we don't know how to verify\n      the constraint.  These conditions may be relaxed but\n@@ -3057,22 +3068,61 @@ subreg_offset_representable_p (unsigned int xregno, enum machine_mode xmode,\n   /* The XMODE value can be seen as a vector of NREGS_XMODE\n      values.  The subreg must represent a lowpart of given field.\n      Compute what field it is.  */\n-  offset -= subreg_lowpart_offset (ymode,\n-\t\t\t\t   mode_for_size (GET_MODE_BITSIZE (xmode)\n-\t\t\t\t\t\t  / nregs_xmode,\n-\t\t\t\t\t\t  MODE_INT, 0));\n+  offset_adj = offset;\n+  offset_adj -= subreg_lowpart_offset (ymode,\n+\t\t\t\t       mode_for_size (GET_MODE_BITSIZE (xmode)\n+\t\t\t\t\t\t      / nregs_xmode,\n+\t\t\t\t\t\t      MODE_INT, 0));\n \n   /* Size of ymode must not be greater than the size of xmode.  */\n   mode_multiple = GET_MODE_SIZE (xmode) / GET_MODE_SIZE (ymode);\n   gcc_assert (mode_multiple != 0);\n \n   y_offset = offset / GET_MODE_SIZE (ymode);\n-  nregs_multiple =  nregs_xmode / nregs_ymode;\n+  y_offset_adj = offset_adj / GET_MODE_SIZE (ymode);\n+  nregs_multiple = nregs_xmode / nregs_ymode;\n \n-  gcc_assert ((offset % GET_MODE_SIZE (ymode)) == 0);\n+  gcc_assert ((offset_adj % GET_MODE_SIZE (ymode)) == 0);\n   gcc_assert ((mode_multiple % nregs_multiple) == 0);\n \n-  return (!(y_offset % (mode_multiple / nregs_multiple)));\n+  if (!rknown)\n+    {\n+      info->representable_p = (!(y_offset_adj % (mode_multiple / nregs_multiple)));\n+      rknown = true;\n+    }\n+  info->offset = (y_offset / (mode_multiple / nregs_multiple)) * nregs_ymode;\n+  info->nregs = nregs_ymode;\n+}\n+\n+/* This function returns the regno offset of a subreg expression.\n+   xregno - A regno of an inner hard subreg_reg (or what will become one).\n+   xmode  - The mode of xregno.\n+   offset - The byte offset.\n+   ymode  - The mode of a top level SUBREG (or what may become one).\n+   RETURN - The regno offset which would be used.  */\n+unsigned int\n+subreg_regno_offset (unsigned int xregno, enum machine_mode xmode,\n+\t\t     unsigned int offset, enum machine_mode ymode)\n+{\n+  struct subreg_info info;\n+  subreg_get_info (xregno, xmode, offset, ymode, &info);\n+  return info.offset;\n+}\n+\n+/* This function returns true when the offset is representable via\n+   subreg_offset in the given regno.\n+   xregno - A regno of an inner hard subreg_reg (or what will become one).\n+   xmode  - The mode of xregno.\n+   offset - The byte offset.\n+   ymode  - The mode of a top level SUBREG (or what may become one).\n+   RETURN - Whether the offset is representable.  */\n+bool\n+subreg_offset_representable_p (unsigned int xregno, enum machine_mode xmode,\n+\t\t\t       unsigned int offset, enum machine_mode ymode)\n+{\n+  struct subreg_info info;\n+  subreg_get_info (xregno, xmode, offset, ymode, &info);\n+  return info.representable_p;\n }\n \n /* Return the final regno that a subreg expression refers to.  */\n@@ -3090,6 +3140,21 @@ subreg_regno (rtx x)\n   return ret;\n \n }\n+\n+/* Return the number of registers that a subreg expression refers\n+   to.  */\n+unsigned int\n+subreg_nregs (rtx x)\n+{\n+  struct subreg_info info;\n+  rtx subreg = SUBREG_REG (x);\n+  int regno = REGNO (subreg);\n+\n+  subreg_get_info (regno, GET_MODE (subreg), SUBREG_BYTE (x), GET_MODE (x),\n+\t\t   &info);\n+  return info.nregs;\n+}\n+\n struct parms_set_data\n {\n   int nregs;"}]}