{"sha": "aead1ca3db61ac3e942e4c57a23d1dfbe3813234", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWVhZDFjYTNkYjYxYWMzZTk0MmU0YzU3YTIzZDFkZmJlMzgxMzIzNA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-09-05T05:54:09Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-09-05T05:54:09Z"}, "message": "reload.c (push_reload): Export.\n\n        * reload.c (push_reload): Export.\n        * reload.h (push_reload): Declare it.\n\n        * config/alpha/alpha.h (LEGITIMIZE_ADDRESS): Move out o' line.\n        (LEGITIMIZE_RELOAD_ADDRESS): Likewise.\n        * config/alpha/alpha.c (alpha_legitimize_address): New.\n        (alpha_legitimize_reload_address): Likewise.\n        * config/alpha/alpha-protos.h: Declare them.\n\nFrom-SVN: r45392", "tree": {"sha": "1fc8fc8a6a49754c767b4d792fee043b740268fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1fc8fc8a6a49754c767b4d792fee043b740268fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aead1ca3db61ac3e942e4c57a23d1dfbe3813234", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aead1ca3db61ac3e942e4c57a23d1dfbe3813234", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aead1ca3db61ac3e942e4c57a23d1dfbe3813234", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aead1ca3db61ac3e942e4c57a23d1dfbe3813234/comments", "author": null, "committer": null, "parents": [{"sha": "ef671f41754b1eef032f3f284b0b1bc8941b7941", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef671f41754b1eef032f3f284b0b1bc8941b7941", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef671f41754b1eef032f3f284b0b1bc8941b7941"}], "stats": {"total": 285, "additions": 167, "deletions": 118}, "files": [{"sha": "611fb9434de5a509d0260b0c8f2bc52c5250b86c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aead1ca3db61ac3e942e4c57a23d1dfbe3813234/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aead1ca3db61ac3e942e4c57a23d1dfbe3813234/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aead1ca3db61ac3e942e4c57a23d1dfbe3813234", "patch": "@@ -1,3 +1,14 @@\n+2001-09-04  Richard Henderson  <rth@redhat.com>\n+\n+\t* reload.c (push_reload): Export.\n+\t* reload.h (push_reload): Declare it.\n+\n+\t* config/alpha/alpha.h (LEGITIMIZE_ADDRESS): Move out o' line.\n+\t(LEGITIMIZE_RELOAD_ADDRESS): Likewise.\n+\t* config/alpha/alpha.c (alpha_legitimize_address): New.\n+\t(alpha_legitimize_reload_address): Likewise.\n+\t* config/alpha/alpha-protos.h: Declare them.\n+\n 2001-09-04  Stan Shebs  <shebs@apple.com>\n \n \t* config/darwin.h (ASM_DECLARE_FUNCTION_NAME): Define."}, {"sha": "6696a18be30b8be69bdecfc628f56bfe7a99921f", "filename": "gcc/config/alpha/alpha-protos.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aead1ca3db61ac3e942e4c57a23d1dfbe3813234/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aead1ca3db61ac3e942e4c57a23d1dfbe3813234/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha-protos.h?ref=aead1ca3db61ac3e942e4c57a23d1dfbe3813234", "patch": "@@ -72,6 +72,11 @@ extern int addition_operation PARAMS ((rtx, enum machine_mode));\n \n extern rtx alpha_tablejump_addr_vec PARAMS ((rtx));\n extern rtx alpha_tablejump_best_label PARAMS ((rtx));\n+\n+extern rtx alpha_legitimize_address PARAMS ((rtx, rtx, enum machine_mode));\n+extern rtx alpha_legitimize_reload_address PARAMS ((rtx, enum machine_mode,\n+\t\t\t\t\t\t    int, int, int));\n+\n extern void get_aligned_mem PARAMS ((rtx, rtx *, rtx *));\n extern rtx get_unaligned_address PARAMS ((rtx, int));\n extern enum reg_class secondary_reload_class PARAMS ((enum reg_class,"}, {"sha": "a7ed11691b168a932bb0bf8c23fbe95bd9a80838", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 124, "deletions": 1, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aead1ca3db61ac3e942e4c57a23d1dfbe3813234/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aead1ca3db61ac3e942e4c57a23d1dfbe3813234/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=aead1ca3db61ac3e942e4c57a23d1dfbe3813234", "patch": "@@ -42,8 +42,8 @@ Boston, MA 02111-1307, USA.  */\n #include \"function.h\"\n #include \"toplev.h\"\n #include \"ggc.h\"\n-#include \"tm_p.h\"\n #include \"integrate.h\"\n+#include \"tm_p.h\"\n #include \"target.h\"\n #include \"target-def.h\"\n \n@@ -1154,6 +1154,129 @@ alpha_tablejump_best_label (insn)\n   return best_label ? best_label : const0_rtx;\n }\n \f\n+/* Try machine-dependent ways of modifying an illegitimate address\n+   to be legitimate.  If we find one, return the new, valid address.  */\n+\n+rtx\n+alpha_legitimize_address (x, oldx, mode)\n+     rtx x;\n+     rtx oldx ATTRIBUTE_UNUSED;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+{\n+  HOST_WIDE_INT addend;\n+\n+  /* If the address is (plus reg const_int) and the CONST_INT is not a\n+     valid offset, compute the high part of the constant and add it to\n+     the register.  Then our address is (plus temp low-part-const).  */\n+  if (GET_CODE (x) == PLUS\n+      && GET_CODE (XEXP (x, 0)) == REG\n+      && GET_CODE (XEXP (x, 1)) == CONST_INT\n+      && ! CONSTANT_ADDRESS_P (XEXP (x, 1)))\n+    {\n+      addend = INTVAL (XEXP (x, 1));\n+      x = XEXP (x, 0);\n+      goto split_addend;\n+    }\n+\n+  /* If the address is (const (plus FOO const_int)), find the low-order\n+     part of the CONST_INT.  Then load FOO plus any high-order part of the\n+     CONST_INT into a register.  Our address is (plus reg low-part-const).\n+     This is done to reduce the number of GOT entries.  */\n+  if (GET_CODE (x) == CONST\n+      && GET_CODE (XEXP (x, 0)) == PLUS\n+      && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT)\n+    {\n+      addend = INTVAL (XEXP (XEXP (x, 0), 1));\n+      x = force_reg (Pmode, XEXP (XEXP (x, 0), 0));\n+      goto split_addend;\n+    }\n+\n+  /* If we have a (plus reg const), emit the load as in (2), then add\n+     the two registers, and finally generate (plus reg low-part-const) as\n+     our address.  */\n+  if (GET_CODE (x) == PLUS\n+      && GET_CODE (XEXP (x, 0)) == REG\n+      && GET_CODE (XEXP (x, 1)) == CONST\n+      && GET_CODE (XEXP (XEXP (x, 1), 0)) == PLUS\n+      && GET_CODE (XEXP (XEXP (XEXP (x, 1), 0), 1)) == CONST_INT)\n+    {\n+      addend = INTVAL (XEXP (XEXP (XEXP (x, 1), 0), 1));\n+      x = expand_simple_binop (Pmode, PLUS, XEXP (x, 0),\n+\t\t\t       XEXP (XEXP (XEXP (x, 1), 0), 0),\n+\t\t\t       NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+      goto split_addend;\n+    }\n+\n+  return NULL;\n+\n+ split_addend:\n+  {\n+    HOST_WIDE_INT lowpart = (addend & 0xffff) - 2 * (addend & 0x8000);\n+    HOST_WIDE_INT highpart = addend - lowpart;\n+    x = expand_simple_binop (Pmode, PLUS, x, GEN_INT (highpart),\n+\t\t\t     NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+    return plus_constant (x, lowpart);\n+  }\n+}\n+\n+/* Try a machine-dependent way of reloading an illegitimate address\n+   operand.  If we find one, push the reload and return the new rtx.  */\n+   \n+rtx\n+alpha_legitimize_reload_address (x, mode, opnum, type, ind_levels)\n+     rtx x;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+     int opnum;\n+     int type;\n+     int ind_levels ATTRIBUTE_UNUSED;\n+{\n+  /* We must recognize output that we have already generated ourselves.  */\n+  if (GET_CODE (x) == PLUS\n+      && GET_CODE (XEXP (x, 0)) == PLUS\n+      && GET_CODE (XEXP (XEXP (x, 0), 0)) == REG\n+      && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n+      && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+    {\n+      push_reload (XEXP (x, 0), NULL_RTX, &XEXP (x, 0), NULL,\n+\t\t   BASE_REG_CLASS, GET_MODE (x), VOIDmode, 0, 0,\n+\t\t   opnum, type);\n+      return x;\n+    }\n+\n+  /* We wish to handle large displacements off a base register by\n+     splitting the addend across an ldah and the mem insn.  This\n+     cuts number of extra insns needed from 3 to 1.  */\n+  if (GET_CODE (x) == PLUS\n+      && GET_CODE (XEXP (x, 0)) == REG\n+      && REGNO (XEXP (x, 0)) < FIRST_PSEUDO_REGISTER\n+      && REGNO_OK_FOR_BASE_P (REGNO (XEXP (x, 0)))\n+      && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+    {\n+      HOST_WIDE_INT val = INTVAL (XEXP (x, 1));\n+      HOST_WIDE_INT low = ((val & 0xffff) ^ 0x8000) - 0x8000;\n+      HOST_WIDE_INT high\n+\t= (((val - low) & 0xffffffff) ^ 0x80000000) - 0x80000000;\n+\n+      /* Check for 32-bit overflow.  */\n+      if (high + low != val)\n+\treturn NULL_RTX;\n+\n+      /* Reload the high part into a base reg; leave the low part\n+\t in the mem directly.  */\n+      x = gen_rtx_PLUS (GET_MODE (x),\n+\t\t\tgen_rtx_PLUS (GET_MODE (x), XEXP (x, 0),\n+\t\t\t\t      GEN_INT (high)),\n+\t\t\tGEN_INT (low));\n+\n+      push_reload (XEXP (x, 0), NULL_RTX, &XEXP (x, 0), NULL,\n+\t\t   BASE_REG_CLASS, GET_MODE (x), VOIDmode, 0, 0,\n+\t\t   opnum, type);\n+      return x;\n+    }\n+\n+  return NULL_RTX;\n+}\n+\f\n /* REF is an alignable memory location.  Place an aligned SImode\n    reference into *PALIGNED_MEM and the number of bits to shift into\n    *PBITNUM.  SCRATCH is a free register for use in reloading out"}, {"sha": "0af83743c294455898fade0f98ccb9b737d8d090", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 20, "deletions": 112, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aead1ca3db61ac3e942e4c57a23d1dfbe3813234/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aead1ca3db61ac3e942e4c57a23d1dfbe3813234/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=aead1ca3db61ac3e942e4c57a23d1dfbe3813234", "patch": "@@ -1460,122 +1460,30 @@ do {\t\t\t\t\t\t\\\n    GO_IF_LEGITIMATE_ADDRESS.\n \n    It is always safe for this macro to do nothing.  It exists to recognize\n-   opportunities to optimize the output. \n-\n-   For the Alpha, there are three cases we handle:\n-\n-   (1) If the address is (plus reg const_int) and the CONST_INT is not a\n-       valid offset, compute the high part of the constant and add it to the\n-       register.  Then our address is (plus temp low-part-const).\n-   (2) If the address is (const (plus FOO const_int)), find the low-order\n-       part of the CONST_INT.  Then load FOO plus any high-order part of the\n-       CONST_INT into a register.  Our address is (plus reg low-part-const).\n-       This is done to reduce the number of GOT entries.\n-   (3) If we have a (plus reg const), emit the load as in (2), then add\n-       the two registers, and finally generate (plus reg low-part-const) as\n-       our address.  */\n-\n-#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\t\t\t\\\n-{ if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == REG\t\\\n-      && GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\\\n-      && ! CONSTANT_ADDRESS_P (XEXP (X, 1)))\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      HOST_WIDE_INT val = INTVAL (XEXP (X, 1));\t\t\t\\\n-      HOST_WIDE_INT lowpart = (val & 0xffff) - 2 * (val & 0x8000); \\\n-      HOST_WIDE_INT highpart = val - lowpart;\t\t\t\\\n-      rtx high = GEN_INT (highpart);\t\t\t\t\\\n-      rtx temp = expand_binop (Pmode, add_optab, XEXP (x, 0),\t\\\n-\t\t\t       high, NULL_RTX, 1, OPTAB_LIB_WIDEN); \\\n-\t\t\t\t\t\t\t\t\\\n-      (X) = plus_constant (temp, lowpart);\t\t\t\\\n-      goto WIN;\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  else if (GET_CODE (X) == CONST\t\t\t\t\\\n-\t   && GET_CODE (XEXP (X, 0)) == PLUS\t\t\t\\\n-\t   && GET_CODE (XEXP (XEXP (X, 0), 1)) == CONST_INT)\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      HOST_WIDE_INT val = INTVAL (XEXP (XEXP (X, 0), 1));\t\\\n-      HOST_WIDE_INT lowpart = (val & 0xffff) - 2 * (val & 0x8000); \\\n-      HOST_WIDE_INT highpart = val - lowpart;\t\t\t\\\n-      rtx high = XEXP (XEXP (X, 0), 0);\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-      if (highpart)\t\t\t\t\t\t\\\n-\thigh = plus_constant (high, highpart);\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-      (X) = plus_constant (force_reg (Pmode, high), lowpart);\t\\\n-      goto WIN;\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  else if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == REG \\\n-\t   && GET_CODE (XEXP (X, 1)) == CONST\t\t\t\\\n-\t   && GET_CODE (XEXP (XEXP (X, 1), 0)) == PLUS\t\t\\\n-\t   && GET_CODE (XEXP (XEXP (XEXP (X, 1), 0), 1)) == CONST_INT) \\\n-    {\t\t\t\t\t\t\t\t\\\n-      HOST_WIDE_INT val = INTVAL (XEXP (XEXP (XEXP (X, 1), 0), 1)); \\\n-      HOST_WIDE_INT lowpart = (val & 0xffff) - 2 * (val & 0x8000); \\\n-      HOST_WIDE_INT highpart = val - lowpart;\t\t\t\\\n-      rtx high = XEXP (XEXP (XEXP (X, 1), 0), 0);\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-      if (highpart)\t\t\t\t\t\t\\\n-\thigh = plus_constant (high, highpart);\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-      high = expand_binop (Pmode, add_optab, XEXP (X, 0),\t\\\n-\t\t\t   force_reg (Pmode, high),\t\t\\\n-\t\t\t   high, 1, OPTAB_LIB_WIDEN);\t\t\\\n-      (X) = plus_constant (high, lowpart);\t\t\t\\\n-      goto WIN;\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-}\n+   opportunities to optimize the output.  */\n+\n+#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\t\t\\\n+do {\t\t\t\t\t\t\t\\\n+  rtx new_x = alpha_legitimize_address (X, OLDX, MODE);\t\\\n+  if (new_x)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      X = new_x;\t\t\t\t\t\\\n+      goto WIN;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+} while (0)\n \n /* Try a machine-dependent way of reloading an illegitimate address\n    operand.  If we find one, push the reload and jump to WIN.  This\n-   macro is used in only one place: `find_reloads_address' in reload.c.\n-\n-   For the Alpha, we wish to handle large displacements off a base\n-   register by splitting the addend across an ldah and the mem insn.\n-   This cuts number of extra insns needed from 3 to 1.  */\n+   macro is used in only one place: `find_reloads_address' in reload.c.  */\n    \n-#define LEGITIMIZE_RELOAD_ADDRESS(X,MODE,OPNUM,TYPE,IND_LEVELS,WIN)\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  /* We must recognize output that we have already generated ourselves.  */ \\\n-  if (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n-      && GET_CODE (XEXP (X, 0)) == PLUS\t\t\t\t\t\\\n-      && GET_CODE (XEXP (XEXP (X, 0), 0)) == REG\t\t\t\\\n-      && GET_CODE (XEXP (XEXP (X, 0), 1)) == CONST_INT\t\t\t\\\n-      && GET_CODE (XEXP (X, 1)) == CONST_INT)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      push_reload (XEXP (X, 0), NULL_RTX, &XEXP (X, 0), NULL,\t\\\n-\t\t   BASE_REG_CLASS, GET_MODE (X), VOIDmode, 0, 0,\t\\\n-\t\t   OPNUM, TYPE);\t\t\t\t\t\\\n-      goto WIN;\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  if (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n-      && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\t\\\n-      && REGNO (XEXP (X, 0)) < FIRST_PSEUDO_REGISTER\t\t\t\\\n-      && REG_MODE_OK_FOR_BASE_P (XEXP (X, 0), MODE)\t\t\t\\\n-      && GET_CODE (XEXP (X, 1)) == CONST_INT)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      HOST_WIDE_INT val = INTVAL (XEXP (X, 1));\t\t\t\t\\\n-      HOST_WIDE_INT low = ((val & 0xffff) ^ 0x8000) - 0x8000;\t\t\\\n-      HOST_WIDE_INT high\t\t\t\t\t\t\\\n-\t= (((val - low) & 0xffffffff) ^ 0x80000000) - 0x80000000;\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      /* Check for 32-bit overflow.  */\t\t\t\t\t\\\n-      if (high + low != val)\t\t\t\t\t\t\\\n-\tbreak;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      /* Reload the high part into a base reg; leave the low part\t\\\n-\t in the mem directly.  */\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      X = gen_rtx_PLUS (GET_MODE (X),\t\t\t\t\t\\\n-\t\t\tgen_rtx_PLUS (GET_MODE (X), XEXP (X, 0),\t\\\n-\t\t\t\t      GEN_INT (high)),\t\t\t\\\n-\t\t\tGEN_INT (low));\t\t\t\t\t\\\n-\t  \t\t\t\t\t\t\t\t\\\n-      push_reload (XEXP (X, 0), NULL_RTX, &XEXP (X, 0), NULL,\t\\\n-\t\t   BASE_REG_CLASS, GET_MODE (X), VOIDmode, 0, 0,\t\\\n-\t\t   OPNUM, TYPE);\t\t\t\t\t\\\n-      goto WIN;\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n+#define LEGITIMIZE_RELOAD_ADDRESS(X,MODE,OPNUM,TYPE,IND_L,WIN)\t\t     \\\n+do {\t\t\t\t\t\t\t\t\t     \\\n+  rtx new_x = alpha_legitimize_reload_address (X, MODE, OPNUM, TYPE, IND_L); \\\n+  if (new_x)\t\t\t\t\t\t\t\t     \\\n+    {\t\t\t\t\t\t\t\t\t     \\\n+      X = new_x;\t\t\t\t\t\t\t     \\\n+      goto WIN;\t\t\t\t\t\t\t\t     \\\n+    }\t\t\t\t\t\t\t\t\t     \\\n } while (0)\n \n /* Go to LABEL if ADDR (a legitimate address expression)"}, {"sha": "b069d18889900c2777ce72b3d696d6295eb732cf", "filename": "gcc/reload.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aead1ca3db61ac3e942e4c57a23d1dfbe3813234/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aead1ca3db61ac3e942e4c57a23d1dfbe3813234/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=aead1ca3db61ac3e942e4c57a23d1dfbe3813234", "patch": "@@ -242,9 +242,6 @@ static int push_secondary_reload PARAMS ((int, rtx, int, int, enum reg_class,\n #endif\n static enum reg_class find_valid_class PARAMS ((enum machine_mode, int));\n static int reload_inner_reg_of_subreg PARAMS ((rtx, enum machine_mode));\n-static int push_reload\t\tPARAMS ((rtx, rtx, rtx *, rtx *, enum reg_class,\n-\t\t\t\t       enum machine_mode, enum machine_mode,\n-\t\t\t\t       int, int, int, enum reload_type));\n static void push_replacement\tPARAMS ((rtx *, int, enum machine_mode));\n static void combine_reloads\tPARAMS ((void));\n static int find_reusable_reload\tPARAMS ((rtx *, rtx, enum reg_class,\n@@ -845,7 +842,7 @@ reload_inner_reg_of_subreg (x, mode)\n    the two reload-numbers are equal, but the caller should be careful to\n    distinguish them.  */\n \n-static int\n+int\n push_reload (in, out, inloc, outloc, class,\n \t     inmode, outmode, strict_low, optional, opnum, type)\n      rtx in, out;"}, {"sha": "edb458b902dbe02ba2d615b765dc3230b80dbc14", "filename": "gcc/reload.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aead1ca3db61ac3e942e4c57a23d1dfbe3813234/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aead1ca3db61ac3e942e4c57a23d1dfbe3813234/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=aead1ca3db61ac3e942e4c57a23d1dfbe3813234", "patch": "@@ -331,7 +331,12 @@ extern int regno_clobbered_p PARAMS ((unsigned int, rtx, enum machine_mode,\n \t\t\t\t      int));\n \n /* Return 1 if X is an operand of an insn that is being earlyclobbered.  */\n-int earlyclobber_operand_p PARAMS ((rtx));\n+extern int earlyclobber_operand_p PARAMS ((rtx));\n+\n+/* Record one reload that needs to be performed.  */\n+extern int push_reload PARAMS ((rtx, rtx, rtx *, rtx *, enum reg_class,\n+\t\t\t\tenum machine_mode, enum machine_mode,\n+\t\t\t\tint, int, int, enum reload_type));\n \n /* Functions in reload1.c:  */\n "}]}