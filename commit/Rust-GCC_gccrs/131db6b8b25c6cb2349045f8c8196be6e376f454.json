{"sha": "131db6b8b25c6cb2349045f8c8196be6e376f454", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTMxZGI2YjhiMjVjNmNiMjM0OTA0NWY4YzgxOTZiZTZlMzc2ZjQ1NA==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-08-22T21:38:03Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-08-22T21:38:03Z"}, "message": "tracer.c (mark_bb_seen): Use SBITMAP_SIZE.\n\n\t* tracer.c (mark_bb_seen): Use SBITMAP_SIZE.\n\n\t* alias.c (MAX_ALIAS_LOOP_PASSES): Update comment with rationale,\n\tor rather a lack thereof.\n\t(init_alias_analysis): Propagate the latest information across\n\tthe CFG in topological order to propagate as far as possible in\n\teach iteration.  Ignore debug insns.\n\nFrom-SVN: r190602", "tree": {"sha": "f0947fee8d1feec00684def297c0a75655c22f86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f0947fee8d1feec00684def297c0a75655c22f86"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/131db6b8b25c6cb2349045f8c8196be6e376f454", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/131db6b8b25c6cb2349045f8c8196be6e376f454", "html_url": "https://github.com/Rust-GCC/gccrs/commit/131db6b8b25c6cb2349045f8c8196be6e376f454", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/131db6b8b25c6cb2349045f8c8196be6e376f454/comments", "author": null, "committer": null, "parents": [{"sha": "c637141af07b7719c1b4c870373944929bcc34b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c637141af07b7719c1b4c870373944929bcc34b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c637141af07b7719c1b4c870373944929bcc34b6"}], "stats": {"total": 152, "additions": 89, "deletions": 63}, "files": [{"sha": "527f822ab501a8865670051ee6edf8bd55d43859", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/131db6b8b25c6cb2349045f8c8196be6e376f454/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/131db6b8b25c6cb2349045f8c8196be6e376f454/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=131db6b8b25c6cb2349045f8c8196be6e376f454", "patch": "@@ -1,3 +1,13 @@\n+2012-08-22  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* tracer.c (mark_bb_seen): Use SBITMAP_SIZE.\n+\n+\t* alias.c (MAX_ALIAS_LOOP_PASSES): Update comment with rationale,\n+\tor rather a lack thereof.\n+\t(init_alias_analysis): Propagate the latest information across\n+\tthe CFG in topological order to propagate as far as possible in\n+\teach iteration.  Ignore debug insns.\n+\n 2012-08-22  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* doc/invoke.texi: Document -mlong-double-64/-mlong-double-80."}, {"sha": "a26c29988b9589c0cb89cdd84e710b830d11a527", "filename": "gcc/alias.c", "status": "modified", "additions": 78, "deletions": 62, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/131db6b8b25c6cb2349045f8c8196be6e376f454/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/131db6b8b25c6cb2349045f8c8196be6e376f454/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=131db6b8b25c6cb2349045f8c8196be6e376f454", "patch": "@@ -168,7 +168,10 @@ static void memory_modified_1 (rtx, const_rtx, void *);\n #define SIZE_FOR_MODE(X) (GET_MODE_SIZE (GET_MODE (X)))\n \n /* Cap the number of passes we make over the insns propagating alias\n-   information through set chains.   10 is a completely arbitrary choice.  */\n+   information through set chains.\n+   ??? 10 is a completely arbitrary choice.  This should be based on the\n+   maximum loop depth in the CFG, but we do not have this information\n+   available (even if current_loops _is_ available).  */\n #define MAX_ALIAS_LOOP_PASSES 10\n \n /* reg_base_value[N] gives an address to which register N is related.\n@@ -2764,6 +2767,8 @@ init_alias_analysis (void)\n   int i;\n   unsigned int ui;\n   rtx insn, val;\n+  int rpo_cnt;\n+  int *rpo;\n \n   timevar_push (TV_ALIAS_ANALYSIS);\n \n@@ -2786,6 +2791,9 @@ init_alias_analysis (void)\n      \"constant\" information from the previous pass to propagate alias\n      information through another level of assignments.\n \n+     The propagation is done on the CFG in reverse post-order, to propagate\n+     things forward as far as possible in each iteration.\n+\n      This could get expensive if the assignment chains are long.  Maybe\n      we should throttle the number of iterations, possibly based on\n      the optimization level or flag_expensive_optimizations.\n@@ -2801,6 +2809,9 @@ init_alias_analysis (void)\n      The state of the arrays for the set chain in question does not matter\n      since the program has undefined behavior.  */\n \n+  rpo = XNEWVEC (int, n_basic_blocks);\n+  rpo_cnt = pre_and_rev_post_order_compute (NULL, rpo, false);\n+\n   pass = 0;\n   do\n     {\n@@ -2833,80 +2844,84 @@ init_alias_analysis (void)\n \t      FIRST_PSEUDO_REGISTER * sizeof (rtx));\n \n       /* Walk the insns adding values to the new_reg_base_value array.  */\n-      for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+      for (i = 0; i < rpo_cnt; i++)\n \t{\n-\t  if (INSN_P (insn))\n+\t  basic_block bb = BASIC_BLOCK (rpo[i]);\n+\t  FOR_BB_INSNS (bb, insn)\n \t    {\n-\t      rtx note, set;\n+\t      if (NONDEBUG_INSN_P (insn))\n+\t\t{\n+\t\t  rtx note, set;\n \n #if defined (HAVE_prologue) || defined (HAVE_epilogue)\n-\t      /* The prologue/epilogue insns are not threaded onto the\n-\t\t insn chain until after reload has completed.  Thus,\n-\t\t there is no sense wasting time checking if INSN is in\n-\t\t the prologue/epilogue until after reload has completed.  */\n-\t      if (reload_completed\n-\t\t  && prologue_epilogue_contains (insn))\n-\t\tcontinue;\n+\t\t  /* The prologue/epilogue insns are not threaded onto the\n+\t\t     insn chain until after reload has completed.  Thus,\n+\t\t     there is no sense wasting time checking if INSN is in\n+\t\t     the prologue/epilogue until after reload has completed.  */\n+\t\t  if (reload_completed\n+\t\t      && prologue_epilogue_contains (insn))\n+\t\t    continue;\n #endif\n \n-\t      /* If this insn has a noalias note, process it,  Otherwise,\n-\t\t scan for sets.  A simple set will have no side effects\n-\t\t which could change the base value of any other register.  */\n+\t\t  /* If this insn has a noalias note, process it,  Otherwise,\n+\t\t     scan for sets.  A simple set will have no side effects\n+\t\t     which could change the base value of any other register.  */\n \n-\t      if (GET_CODE (PATTERN (insn)) == SET\n-\t\t  && REG_NOTES (insn) != 0\n-\t\t  && find_reg_note (insn, REG_NOALIAS, NULL_RTX))\n-\t\trecord_set (SET_DEST (PATTERN (insn)), NULL_RTX, NULL);\n-\t      else\n-\t\tnote_stores (PATTERN (insn), record_set, NULL);\n+\t\t  if (GET_CODE (PATTERN (insn)) == SET\n+\t\t      && REG_NOTES (insn) != 0\n+\t\t      && find_reg_note (insn, REG_NOALIAS, NULL_RTX))\n+\t\t    record_set (SET_DEST (PATTERN (insn)), NULL_RTX, NULL);\n+\t\t  else\n+\t\t    note_stores (PATTERN (insn), record_set, NULL);\n \n-\t      set = single_set (insn);\n+\t\t  set = single_set (insn);\n \n-\t      if (set != 0\n-\t\t  && REG_P (SET_DEST (set))\n-\t\t  && REGNO (SET_DEST (set)) >= FIRST_PSEUDO_REGISTER)\n-\t\t{\n-\t\t  unsigned int regno = REGNO (SET_DEST (set));\n-\t\t  rtx src = SET_SRC (set);\n-\t\t  rtx t;\n-\n-\t\t  note = find_reg_equal_equiv_note (insn);\n-\t\t  if (note && REG_NOTE_KIND (note) == REG_EQUAL\n-\t\t      && DF_REG_DEF_COUNT (regno) != 1)\n-\t\t    note = NULL_RTX;\n-\n-\t\t  if (note != NULL_RTX\n-\t\t      && GET_CODE (XEXP (note, 0)) != EXPR_LIST\n-\t\t      && ! rtx_varies_p (XEXP (note, 0), 1)\n-\t\t      && ! reg_overlap_mentioned_p (SET_DEST (set),\n-\t\t\t\t\t\t    XEXP (note, 0)))\n-\t\t    {\n-\t\t      set_reg_known_value (regno, XEXP (note, 0));\n-\t\t      set_reg_known_equiv_p (regno,\n-\t\t\tREG_NOTE_KIND (note) == REG_EQUIV);\n-\t\t    }\n-\t\t  else if (DF_REG_DEF_COUNT (regno) == 1\n-\t\t\t   && GET_CODE (src) == PLUS\n-\t\t\t   && REG_P (XEXP (src, 0))\n-\t\t\t   && (t = get_reg_known_value (REGNO (XEXP (src, 0))))\n-\t\t\t   && CONST_INT_P (XEXP (src, 1)))\n-\t\t    {\n-\t\t      t = plus_constant (GET_MODE (src), t,\n-\t\t\t\t\t INTVAL (XEXP (src, 1)));\n-\t\t      set_reg_known_value (regno, t);\n-\t\t      set_reg_known_equiv_p (regno, false);\n-\t\t    }\n-\t\t  else if (DF_REG_DEF_COUNT (regno) == 1\n-\t\t\t   && ! rtx_varies_p (src, 1))\n+\t\t  if (set != 0\n+\t\t      && REG_P (SET_DEST (set))\n+\t\t      && REGNO (SET_DEST (set)) >= FIRST_PSEUDO_REGISTER)\n \t\t    {\n-\t\t      set_reg_known_value (regno, src);\n-\t\t      set_reg_known_equiv_p (regno, false);\n+\t\t      unsigned int regno = REGNO (SET_DEST (set));\n+\t\t      rtx src = SET_SRC (set);\n+\t\t      rtx t;\n+\n+\t\t      note = find_reg_equal_equiv_note (insn);\n+\t\t      if (note && REG_NOTE_KIND (note) == REG_EQUAL\n+\t\t\t  && DF_REG_DEF_COUNT (regno) != 1)\n+\t\t\tnote = NULL_RTX;\n+\n+\t\t      if (note != NULL_RTX\n+\t\t\t  && GET_CODE (XEXP (note, 0)) != EXPR_LIST\n+\t\t\t  && ! rtx_varies_p (XEXP (note, 0), 1)\n+\t\t\t  && ! reg_overlap_mentioned_p (SET_DEST (set),\n+\t\t\t\t\t\t\tXEXP (note, 0)))\n+\t\t\t{\n+\t\t\t  set_reg_known_value (regno, XEXP (note, 0));\n+\t\t\t  set_reg_known_equiv_p (regno,\n+\t\t\t\t\t\t REG_NOTE_KIND (note) == REG_EQUIV);\n+\t\t\t}\n+\t\t      else if (DF_REG_DEF_COUNT (regno) == 1\n+\t\t\t       && GET_CODE (src) == PLUS\n+\t\t\t       && REG_P (XEXP (src, 0))\n+\t\t\t       && (t = get_reg_known_value (REGNO (XEXP (src, 0))))\n+\t\t\t       && CONST_INT_P (XEXP (src, 1)))\n+\t\t\t{\n+\t\t\t  t = plus_constant (GET_MODE (src), t,\n+\t\t\t\t\t     INTVAL (XEXP (src, 1)));\n+\t\t\t  set_reg_known_value (regno, t);\n+\t\t\t  set_reg_known_equiv_p (regno, false);\n+\t\t\t}\n+\t\t      else if (DF_REG_DEF_COUNT (regno) == 1\n+\t\t\t       && ! rtx_varies_p (src, 1))\n+\t\t\t{\n+\t\t\t  set_reg_known_value (regno, src);\n+\t\t\t  set_reg_known_equiv_p (regno, false);\n+\t\t\t}\n \t\t    }\n \t\t}\n+\t      else if (NOTE_P (insn)\n+\t\t       && NOTE_KIND (insn) == NOTE_INSN_FUNCTION_BEG)\n+\t\tcopying_arguments = false;\n \t    }\n-\t  else if (NOTE_P (insn)\n-\t\t   && NOTE_KIND (insn) == NOTE_INSN_FUNCTION_BEG)\n-\t    copying_arguments = false;\n \t}\n \n       /* Now propagate values from new_reg_base_value to reg_base_value.  */\n@@ -2925,6 +2940,7 @@ init_alias_analysis (void)\n \t}\n     }\n   while (changed && ++pass < MAX_ALIAS_LOOP_PASSES);\n+  XDELETEVEC (rpo);\n \n   /* Fill in the remaining entries.  */\n   FOR_EACH_VEC_ELT (rtx, reg_known_value, i, val)"}, {"sha": "9b1d724085c6d93c3789e714a0b000bdfbccc1a8", "filename": "gcc/tracer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/131db6b8b25c6cb2349045f8c8196be6e376f454/gcc%2Ftracer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/131db6b8b25c6cb2349045f8c8196be6e376f454/gcc%2Ftracer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftracer.c?ref=131db6b8b25c6cb2349045f8c8196be6e376f454", "patch": "@@ -69,7 +69,7 @@ sbitmap bb_seen;\n static inline void\n mark_bb_seen (basic_block bb)\n {\n-  unsigned int size = SBITMAP_SIZE_BYTES (bb_seen) * 8;\n+  unsigned int size = SBITMAP_SIZE (bb_seen);\n \n   if ((unsigned int)bb->index >= size)\n     bb_seen = sbitmap_resize (bb_seen, size * 2, 0);"}]}