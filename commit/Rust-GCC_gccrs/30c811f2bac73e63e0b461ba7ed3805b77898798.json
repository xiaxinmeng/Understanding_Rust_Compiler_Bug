{"sha": "30c811f2bac73e63e0b461ba7ed3805b77898798", "node_id": "C_kwDOANBUbNoAKDMwYzgxMWYyYmFjNzNlNjNlMGI0NjFiYTdlZDM4MDViNzc4OTg3OTg", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-09-06T12:21:09Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-09-08T18:29:13Z"}, "message": "c++: Fix type completeness checks for type traits [PR106838]\n\nThe check_trait_type function is used for a number of different type\ntraits that have different requirements on their arguments. For example,\n__is_constructible allows arrays of unknown bound even if the array\nelement is an incomplete type, but __is_aggregate does not, it always\nrequires the array element type to be complete. Other traits have\ndifferent requirements again, e.g. __is_empty allows incomplete unions,\nand arrays (of known or unknown bound) of incomplete types.\n\nThis alters the check_trait_type function to take an additional KIND\nparameter which indicates which set of type trait requirements to check.\n\nAs noted in a comment, the requirements for __is_aggregate deviate from\nthe ones for std::is_aggregate in the standard. It's not necessary for\nthe elements of an array to be complete types, because arrays are always\naggregates.\n\nThe type_has_virtual_destructor change is needed to avoid an ICE.\nPreviously it could never be called for incomplete union types as they\nwere (incorrectly) rejected by check_trait_type.\n\nThis change causes some additional diagnostics in some libstdc++ tests,\nwhere the front end was not previously complaining about invalid types\nthat the library assertions diagnosed. We should consider removing the\nlibrary assertions from traits where the front end implements the\ncorrect checks now.\n\n\tPR c++/106838\n\ngcc/cp/ChangeLog:\n\n\t* class.cc (type_has_virtual_destructor): Return false for\n\tunion types.\n\t* semantics.cc (check_trait_type): Add KIND parameter to support\n\tdifferent sets of requirements.\n\t(finish_trait_expr): Pass KIND argument for relevant traits.\n\ngcc/ChangeLog:\n\n\t* doc/extend.texi (Type Traits): Fix requirements. Document\n\t__is_aggregate and __is_final.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/ext/array4.C: Fix invalid use of __is_constructible.\n\t* g++.dg/ext/unary_trait_incomplete.C: Fix tests for traits with\n\tdifferent requirements.\n\nlibstdc++-v3/ChangeLog:\n\n\t* testsuite/20_util/is_complete_or_unbounded/memoization_neg.cc:\n\tPrune additional errors from front-end.\n\t* testsuite/20_util/is_move_constructible/incomplete_neg.cc:\n\tLikewise.\n\t* testsuite/20_util/is_nothrow_swappable/incomplete_neg.cc:\n\tLikewise.\n\t* testsuite/20_util/is_nothrow_swappable_with/incomplete_neg.cc:\n\tLikewise.\n\t* testsuite/20_util/is_swappable_with/incomplete_neg.cc:\n\tLikewise.", "tree": {"sha": "4d3fc323d13afc3c182720d9d9ae1137ef5c1e97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d3fc323d13afc3c182720d9d9ae1137ef5c1e97"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/30c811f2bac73e63e0b461ba7ed3805b77898798", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30c811f2bac73e63e0b461ba7ed3805b77898798", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30c811f2bac73e63e0b461ba7ed3805b77898798", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30c811f2bac73e63e0b461ba7ed3805b77898798/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4977507e329ee3ed410fc7338b9aaada81b68361", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4977507e329ee3ed410fc7338b9aaada81b68361", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4977507e329ee3ed410fc7338b9aaada81b68361"}], "stats": {"total": 215, "additions": 164, "deletions": 51}, "files": [{"sha": "b84f4227e7e9485b5eaade5c10a8988be3e22a6b", "filename": "gcc/cp/class.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c811f2bac73e63e0b461ba7ed3805b77898798/gcc%2Fcp%2Fclass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c811f2bac73e63e0b461ba7ed3805b77898798/gcc%2Fcp%2Fclass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.cc?ref=30c811f2bac73e63e0b461ba7ed3805b77898798", "patch": "@@ -5620,7 +5620,7 @@ type_has_virtual_destructor (tree type)\n {\n   tree dtor;\n \n-  if (!CLASS_TYPE_P (type))\n+  if (!NON_UNION_CLASS_TYPE_P (type))\n     return false;\n \n   gcc_assert (COMPLETE_TYPE_P (type));"}, {"sha": "6bda30e1b7a06ce2f29b02ebecf550ec61239d22", "filename": "gcc/cp/semantics.cc", "status": "modified", "additions": 46, "deletions": 12, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c811f2bac73e63e0b461ba7ed3805b77898798/gcc%2Fcp%2Fsemantics.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c811f2bac73e63e0b461ba7ed3805b77898798/gcc%2Fcp%2Fsemantics.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.cc?ref=30c811f2bac73e63e0b461ba7ed3805b77898798", "patch": "@@ -12028,11 +12028,23 @@ trait_expr_value (cp_trait_kind kind, tree type1, tree type2)\n     }\n }\n \n-/* If TYPE is an array of unknown bound, or (possibly cv-qualified)\n-   void, or a complete type, returns true, otherwise false.  */\n+/* Returns true if TYPE meets the requirements for the specified KIND,\n+   false otherwise.\n+\n+   When KIND == 1, TYPE must be an array of unknown bound,\n+   or (possibly cv-qualified) void, or a complete type.\n+\n+   When KIND == 2, TYPE must be a complete type, or array of complete type,\n+   or (possibly cv-qualified) void.\n+\n+   When KIND == 3:\n+   If TYPE is a non-union class type, it must be complete.\n+\n+   When KIND == 4:\n+   If TYPE is a class type, it must be complete.  */\n \n static bool\n-check_trait_type (tree type)\n+check_trait_type (tree type, int kind = 1)\n {\n   if (type == NULL_TREE)\n     return true;\n@@ -12041,8 +12053,14 @@ check_trait_type (tree type)\n     return (check_trait_type (TREE_VALUE (type))\n \t    && check_trait_type (TREE_CHAIN (type)));\n \n-  if (TREE_CODE (type) == ARRAY_TYPE && !TYPE_DOMAIN (type))\n-    return true;\n+  if (kind == 1 && TREE_CODE (type) == ARRAY_TYPE && !TYPE_DOMAIN (type))\n+    return true; // Array of unknown bound. Don't care about completeness.\n+\n+  if (kind == 3 && !NON_UNION_CLASS_TYPE_P (type))\n+    return true; // Not a non-union class type. Don't care about completeness.\n+\n+  if (kind == 4 && TREE_CODE (type) == ARRAY_TYPE)\n+    return true; // Not a class type. Don't care about completeness.\n \n   if (VOID_TYPE_P (type))\n     return true;\n@@ -12080,23 +12098,39 @@ finish_trait_expr (location_t loc, cp_trait_kind kind, tree type1, tree type2)\n     case CPTK_HAS_TRIVIAL_COPY:\n     case CPTK_HAS_TRIVIAL_DESTRUCTOR:\n     case CPTK_HAS_UNIQUE_OBJ_REPRESENTATIONS:\n-    case CPTK_HAS_VIRTUAL_DESTRUCTOR:\n-    case CPTK_IS_ABSTRACT:\n-    case CPTK_IS_AGGREGATE:\n-    case CPTK_IS_EMPTY:\n-    case CPTK_IS_FINAL:\n+      if (!check_trait_type (type1))\n+\treturn error_mark_node;\n+      break;\n+\n     case CPTK_IS_LITERAL_TYPE:\n     case CPTK_IS_POD:\n-    case CPTK_IS_POLYMORPHIC:\n     case CPTK_IS_STD_LAYOUT:\n     case CPTK_IS_TRIVIAL:\n     case CPTK_IS_TRIVIALLY_COPYABLE:\n-      if (!check_trait_type (type1))\n+      if (!check_trait_type (type1, /* kind = */ 2))\n+\treturn error_mark_node;\n+      break;\n+\n+    case CPTK_IS_EMPTY:\n+    case CPTK_IS_POLYMORPHIC:\n+    case CPTK_IS_ABSTRACT:\n+    case CPTK_HAS_VIRTUAL_DESTRUCTOR:\n+      if (!check_trait_type (type1, /* kind = */ 3))\n+\treturn error_mark_node;\n+      break;\n+\n+    /* N.B. std::is_aggregate is kind=2 but we don't need a complete element\n+       type to know whether an array is an aggregate, so use kind=4 here.  */\n+    case CPTK_IS_AGGREGATE:\n+    case CPTK_IS_FINAL:\n+      if (!check_trait_type (type1, /* kind = */ 4))\n \treturn error_mark_node;\n       break;\n \n     case CPTK_IS_ASSIGNABLE:\n     case CPTK_IS_CONSTRUCTIBLE:\n+      if (!check_trait_type (type1))\n+\treturn error_mark_node;\n       break;\n \n     case CPTK_IS_TRIVIALLY_ASSIGNABLE:"}, {"sha": "be3ea890c47cd980b2f2aca1a7d065415d08eda9", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c811f2bac73e63e0b461ba7ed3805b77898798/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c811f2bac73e63e0b461ba7ed3805b77898798/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=30c811f2bac73e63e0b461ba7ed3805b77898798", "patch": "@@ -25174,14 +25174,17 @@ Requires: @code{type} shall be a complete type, (possibly cv-qualified)\n @item __has_virtual_destructor (type)\n If @code{type} is a class type with a virtual destructor\n ([class.dtor]) then the trait is @code{true}, else it is @code{false}.\n-Requires: @code{type} shall be a complete type, (possibly cv-qualified)\n-@code{void}, or an array of unknown bound.\n+Requires: If @code{type} is a non-union class type, it shall be a complete type.\n \n @item __is_abstract (type)\n If @code{type} is an abstract class ([class.abstract]) then the trait\n is @code{true}, else it is @code{false}.\n-Requires: @code{type} shall be a complete type, (possibly cv-qualified)\n-@code{void}, or an array of unknown bound.\n+Requires: If @code{type} is a non-union class type, it shall be a complete type.\n+\n+@item __is_aggregate (type)\n+If @code{type} is an aggregate type ([dcl.init.aggr]) the trait is\n+@code{true}, else it is @code{false}.\n+Requires: If @code{type} is a class type, it shall be a complete type.\n \n @item __is_base_of (base_type, derived_type)\n If @code{base_type} is a base class of @code{derived_type}\n@@ -25206,13 +25209,17 @@ any, are bit-fields of length 0, and @code{type} has no virtual\n members, and @code{type} has no virtual base classes, and @code{type}\n has no base classes @code{base_type} for which\n @code{__is_empty (base_type)} is @code{false}.\n-Requires: @code{type} shall be a complete type, (possibly cv-qualified)\n-@code{void}, or an array of unknown bound.\n+Requires: If @code{type} is a non-union class type, it shall be a complete type.\n \n @item __is_enum (type)\n If @code{type} is a cv enumeration type ([basic.compound]) the trait is\n @code{true}, else it is @code{false}.\n \n+@item __is_final (type)\n+If @code{type} is a class or union type marked @code{final}, then the trait\n+is @code{true}, else it is @code{false}.\n+Requires: If @code{type} is a class type, it shall be a complete type.\n+\n @item __is_literal_type (type)\n If @code{type} is a literal type ([basic.types]) the trait is\n @code{true}, else it is @code{false}.\n@@ -25228,20 +25235,19 @@ Requires: @code{type} shall be a complete type, (possibly cv-qualified)\n @item __is_polymorphic (type)\n If @code{type} is a polymorphic class ([class.virtual]) then the trait\n is @code{true}, else it is @code{false}.\n-Requires: @code{type} shall be a complete type, (possibly cv-qualified)\n-@code{void}, or an array of unknown bound.\n+Requires: If @code{type} is a non-union class type, it shall be a complete type.\n \n @item __is_standard_layout (type)\n If @code{type} is a standard-layout type ([basic.types]) the trait is\n @code{true}, else it is @code{false}.\n-Requires: @code{type} shall be a complete type, (possibly cv-qualified)\n-@code{void}, or an array of unknown bound.\n+Requires: @code{type} shall be a complete type, an array of complete types,\n+or (possibly cv-qualified) @code{void}.\n \n @item __is_trivial (type)\n If @code{type} is a trivial type ([basic.types]) the trait is\n @code{true}, else it is @code{false}.\n-Requires: @code{type} shall be a complete type, (possibly cv-qualified)\n-@code{void}, or an array of unknown bound.\n+Requires: @code{type} shall be a complete type, an array of complete types,\n+or (possibly cv-qualified) @code{void}.\n \n @item __is_union (type)\n If @code{type} is a cv union type ([basic.compound]) the trait is"}, {"sha": "6adf9a3b0ee220655a77b7941711530303a79e84", "filename": "gcc/testsuite/g++.dg/ext/array4.C", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c811f2bac73e63e0b461ba7ed3805b77898798/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Farray4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c811f2bac73e63e0b461ba7ed3805b77898798/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Farray4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Farray4.C?ref=30c811f2bac73e63e0b461ba7ed3805b77898798", "patch": "@@ -16,7 +16,6 @@ template <typename _Tp>\n constexpr integral_constant<true> __is_complete_or_unbounded(_Tp) {\n   return {};\n }\n-struct Trans_NS_std_formatter;\n template <typename _Tp>\n struct is_default_constructible : integral_constant<false> {\n   static_assert(__is_complete_or_unbounded(_Tp{}), \"\");\n@@ -53,7 +52,7 @@ template <typename> struct basic_string_view { basic_string_view(int, int); };\n template <typename, typename> struct formatter;\n template <typename, typename>\n using has_formatter =\n-    __bool_constant<__is_constructible(Trans_NS_std_formatter)>;\n+    __bool_constant<__is_constructible(void)>;\n struct fallback_formatter;\n template <typename Context> struct custom_value {\n   using parse_context = typename Context::parse_context_type;"}, {"sha": "1dfa449a8d289ba4b9d37c694a9896929de74123", "filename": "gcc/testsuite/g++.dg/ext/unary_trait_incomplete.C", "status": "modified", "additions": 92, "deletions": 24, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c811f2bac73e63e0b461ba7ed3805b77898798/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Funary_trait_incomplete.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c811f2bac73e63e0b461ba7ed3805b77898798/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Funary_trait_incomplete.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Funary_trait_incomplete.C?ref=30c811f2bac73e63e0b461ba7ed3805b77898798", "patch": "@@ -2,6 +2,7 @@\n \n struct I; // { dg-message \"forward declaration\" }\n struct C { };\n+union U; // { dg-message \"forward declaration\" }\n \n bool nas1 = __has_nothrow_assign(I); // { dg-error \"incomplete type\" }\n bool nas2 = __has_nothrow_assign(C[]);\n@@ -39,38 +40,105 @@ bool tcp3 = __has_trivial_copy(I[]);\n bool tcp4 = __has_trivial_copy(void);\n bool tcp5 = __has_trivial_copy(const void);\n \n-bool vde1 = __has_virtual_destructor(I); // { dg-error \"incomplete type\" }\n-bool vde2 = __has_virtual_destructor(C[]);\n-bool vde3 = __has_virtual_destructor(I[]);\n-bool vde4 = __has_virtual_destructor(void);\n-bool vde5 = __has_virtual_destructor(const void);\n-\n bool tde1 = __has_trivial_destructor(I); // { dg-error \"incomplete type\" }\n bool tde2 = __has_trivial_destructor(C[]);\n bool tde3 = __has_trivial_destructor(I[]);\n bool tde4 = __has_trivial_destructor(void);\n bool tde5 = __has_trivial_destructor(const void);\n \n-bool abs1 = __is_abstract(I); // { dg-error \"incomplete type\" }\n-bool abs2 = __is_abstract(C[]);\n-bool abs3 = __is_abstract(I[]);\n-bool abs4 = __is_abstract(void);\n-bool abs5 = __is_abstract(const void);\n+// T shall be a complete type, cv void, or an array of unknown bound.\n \n-bool pod1 = __is_pod(I); // { dg-error \"incomplete type\" }\n-bool pod2 = __is_pod(C[]);\n-bool pod3 = __is_pod(I[]);\n-bool pod4 = __is_pod(void);\n-bool pod5 = __is_pod(const void);\n+bool con1 = __is_constructible(C);\n+bool con2 = __is_constructible(I); // { dg-error \"incomplete type\" }\n+bool con3 = __is_constructible(U); // { dg-error \"incomplete type\" }\n+bool con4 = __is_constructible(C[]);\n+bool con5 = __is_constructible(I[]);\n+bool con6 = __is_constructible(U[]);\n+bool con7 = __is_constructible(C[1]);\n+bool con8 = __is_constructible(I[1]); // { dg-error \"incomplete type\" }\n+bool con9 = __is_constructible(U[1]); // { dg-error \"incomplete type\" }\n+bool con10 = __is_constructible(void);\n+bool con11 = __is_constructible(const void);\n+\n+// If T is a non-union class type, T shall be a complete type.\n+\n+bool vde1 = __has_virtual_destructor(I); // { dg-error \"incomplete type\" }\n+bool vde2 = __has_virtual_destructor(U);\n+bool vde3 = __has_virtual_destructor(C[]);\n+bool vde4 = __has_virtual_destructor(I[]);\n+bool vde5 = __has_virtual_destructor(U[]);\n+bool vde6 = __has_virtual_destructor(C[1]);\n+bool vde7 = __has_virtual_destructor(I[1]);\n+bool vde8 = __has_virtual_destructor(U[1]);\n+bool vde9 = __has_virtual_destructor(void);\n+bool vde10 = __has_virtual_destructor(const void);\n+\n+bool abs1 = __is_abstract(I); // { dg-error \"incomplete type\" }\n+bool abs2 = __is_abstract(U);\n+bool abs3 = __is_abstract(C[]);\n+bool abs4 = __is_abstract(I[]);\n+bool abs5 = __is_abstract(U[]);\n+bool abs6 = __is_abstract(C[1]);\n+bool abs7 = __is_abstract(I[1]);\n+bool abs8 = __is_abstract(U[1]);\n+bool abs9 = __is_abstract(void);\n+bool abs10 = __is_abstract(const void);\n \n bool emp1 = __is_empty(I); // { dg-error \"incomplete type\" }\n-bool emp2 = __is_empty(C[]);\n-bool emp3 = __is_empty(I[]);\n-bool emp4 = __is_empty(void);\n-bool emp5 = __is_empty(const void);\n+bool emp2 = __is_empty(U);\n+bool emp3 = __is_empty(C[]);\n+bool emp4 = __is_empty(I[]);\n+bool emp5 = __is_empty(U[]);\n+bool emp6 = __is_empty(C[1]);\n+bool emp7 = __is_empty(I[1]);\n+bool emp8 = __is_empty(U[1]);\n+bool emp9 = __is_empty(void);\n+bool emp10 = __is_empty(const void);\n \n bool pol1 = __is_polymorphic(I); // { dg-error \"incomplete type\" }\n-bool pol2 = __is_polymorphic(C[]);\n-bool pol3 = __is_polymorphic(I[]);\n-bool pol4 = __is_polymorphic(void);\n-bool pol5 = __is_polymorphic(const void);\n+bool pol2 = __is_polymorphic(U);\n+bool pol3 = __is_polymorphic(C[]);\n+bool pol4 = __is_polymorphic(I[]);\n+bool pol5 = __is_polymorphic(U[]);\n+bool pol6 = __is_polymorphic(C[1]);\n+bool pol7 = __is_polymorphic(I[1]);\n+bool pol8 = __is_polymorphic(U[1]);\n+bool pol9 = __is_polymorphic(void);\n+bool pol10 = __is_polymorphic(const void);\n+\n+// If T is a class type, T shall be a complete type.\n+\n+bool agg1 = __is_aggregate(I); // { dg-error \"incomplete type\" }\n+bool agg2 = __is_aggregate(U); // { dg-error \"incomplete type\" }\n+bool agg3 = __is_aggregate(C[]);\n+bool agg4 = __is_aggregate(I[]);\n+bool agg5 = __is_aggregate(U[]);\n+bool agg6 = __is_aggregate(C[1]);\n+bool agg7 = __is_aggregate(I[1]);\n+bool agg8 = __is_aggregate(U[1]);\n+bool agg9 = __is_aggregate(void);\n+bool agg10 = __is_aggregate(const void);\n+\n+bool fin1 = __is_final(I); // { dg-error \"incomplete type\" }\n+bool fin2 = __is_final(U); // { dg-error \"incomplete type\" }\n+bool fin3 = __is_final(C[]);\n+bool fin4 = __is_final(I[]);\n+bool fin5 = __is_final(U[]);\n+bool fin6 = __is_final(C[1]);\n+bool fin7 = __is_final(I[1]);\n+bool fin8 = __is_final(U[1]);\n+bool fin9 = __is_final(void);\n+bool fin10 = __is_final(const void);\n+\n+// remove_all_extents_t<T> shall be a complete type or cv void.\n+\n+bool pod1 = __is_pod(I); // { dg-error \"incomplete type\" }\n+bool pod2 = __is_pod(U); // { dg-error \"incomplete type\" }\n+bool pod3 = __is_pod(C[]);\n+bool pod4 = __is_pod(I[]); // { dg-error \"incomplete type\" }\n+bool pod5 = __is_pod(U[]); // { dg-error \"incomplete type\" }\n+bool pod6 = __is_pod(C[1]);\n+bool pod7 = __is_pod(I[1]); // { dg-error \"incomplete type\" }\n+bool pod8 = __is_pod(U[1]); // { dg-error \"incomplete type\" }\n+bool pod9 = __is_pod(void);\n+bool pod10 = __is_pod(const void);"}, {"sha": "fc0b70b319c320ef16a5092d260c950814d9a420", "filename": "libstdc++-v3/testsuite/20_util/is_complete_or_unbounded/memoization_neg.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c811f2bac73e63e0b461ba7ed3805b77898798/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_complete_or_unbounded%2Fmemoization_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c811f2bac73e63e0b461ba7ed3805b77898798/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_complete_or_unbounded%2Fmemoization_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_complete_or_unbounded%2Fmemoization_neg.cc?ref=30c811f2bac73e63e0b461ba7ed3805b77898798", "patch": "@@ -1,5 +1,7 @@\n // { dg-do compile { target c++11 } }\n // { dg-prune-output \"must be a complete\" }\n+// { dg-prune-output \"'value' is not a member of 'std::is_move_cons\" }\n+// { dg-prune-output \"invalid use of incomplete type\" }\n \n // Copyright (C) 2019-2022 Free Software Foundation, Inc.\n //"}, {"sha": "7c34b5f12249b21d80f66944fc529c68d9362ae9", "filename": "libstdc++-v3/testsuite/20_util/is_move_constructible/incomplete_neg.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c811f2bac73e63e0b461ba7ed3805b77898798/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_move_constructible%2Fincomplete_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c811f2bac73e63e0b461ba7ed3805b77898798/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_move_constructible%2Fincomplete_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_move_constructible%2Fincomplete_neg.cc?ref=30c811f2bac73e63e0b461ba7ed3805b77898798", "patch": "@@ -18,6 +18,7 @@\n // <http://www.gnu.org/licenses/>.\n \n // { dg-error \"must be a complete class\" \"\" { target *-*-* } 0 }\n+// { dg-prune-output \"invalid use of incomplete type\" }\n \n #include <type_traits>\n "}, {"sha": "d3a34cca7a76d44366b2fd29ab257ad66657a389", "filename": "libstdc++-v3/testsuite/20_util/is_nothrow_swappable/incomplete_neg.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c811f2bac73e63e0b461ba7ed3805b77898798/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_swappable%2Fincomplete_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c811f2bac73e63e0b461ba7ed3805b77898798/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_swappable%2Fincomplete_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_swappable%2Fincomplete_neg.cc?ref=30c811f2bac73e63e0b461ba7ed3805b77898798", "patch": "@@ -18,6 +18,7 @@\n // <http://www.gnu.org/licenses/>.\n \n // { dg-error \"must be a complete class\" \"\" { target *-*-* } 0 }\n+// { dg-prune-output \"invalid use of incomplete type\" }\n \n #include <type_traits>\n "}, {"sha": "6dfa3363d8849d7877b3cb88e5d8261ff8b4614d", "filename": "libstdc++-v3/testsuite/20_util/is_nothrow_swappable_with/incomplete_neg.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c811f2bac73e63e0b461ba7ed3805b77898798/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_swappable_with%2Fincomplete_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c811f2bac73e63e0b461ba7ed3805b77898798/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_swappable_with%2Fincomplete_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_swappable_with%2Fincomplete_neg.cc?ref=30c811f2bac73e63e0b461ba7ed3805b77898798", "patch": "@@ -18,6 +18,7 @@\n // <http://www.gnu.org/licenses/>.\n \n // { dg-error \"must be a complete class\" \"\" { target *-*-* } 0 }\n+// { dg-prune-output \"invalid use of incomplete type\" }\n \n #include <type_traits>\n "}, {"sha": "d5fa42256ea2fc0a8ea242ec9c7d70c7c81cbfc9", "filename": "libstdc++-v3/testsuite/20_util/is_swappable_with/incomplete_neg.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c811f2bac73e63e0b461ba7ed3805b77898798/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_swappable_with%2Fincomplete_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c811f2bac73e63e0b461ba7ed3805b77898798/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_swappable_with%2Fincomplete_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_swappable_with%2Fincomplete_neg.cc?ref=30c811f2bac73e63e0b461ba7ed3805b77898798", "patch": "@@ -18,6 +18,7 @@\n // <http://www.gnu.org/licenses/>.\n \n // { dg-error \"must be a complete class\" \"\" { target *-*-* } 0 }\n+// { dg-prune-output \"invalid use of incomplete type\" }\n \n #include <type_traits>\n "}]}