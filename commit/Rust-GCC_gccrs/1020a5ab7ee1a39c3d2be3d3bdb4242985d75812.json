{"sha": "1020a5ab7ee1a39c3d2be3d3bdb4242985d75812", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTAyMGE1YWI3ZWUxYTM5YzNkMmJlM2QzYmRiNDI0Mjk4NWQ3NTgxMg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-03-28T11:14:40Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-03-28T11:14:40Z"}, "message": "i386.c (general_no_elim_operand): Disallow virtual regs.\n\n        * config/i386/i386.c (general_no_elim_operand): Disallow virtual regs.\n        (ix86_save_reg): If maybe_eh_return, true for EH_RETURN_DATA_REGNOs.\n        True for pic register if current_function_calls_eh_return.\n        (ix86_expand_epilogue): Change \"emit_return\" argument into \"style\".\n        Handle eh_return requirements.\n        * config/i386/i386.h (EH_RETURN_DATA_REGNO): New.\n        (EH_RETURN_STACKADJ_RTX): New.\n        * config/i386/i386.md (exception_receiver): Remove.\n        (eh_return, eh_return_1): New.\n        * config/i386/linux.h (MD_FALLBACK_FRAME_STATE_FOR): New.\n\nFrom-SVN: r40926", "tree": {"sha": "bfbf4f1be1b6e8c2d914a24827a3b06178106afc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bfbf4f1be1b6e8c2d914a24827a3b06178106afc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1020a5ab7ee1a39c3d2be3d3bdb4242985d75812", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1020a5ab7ee1a39c3d2be3d3bdb4242985d75812", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1020a5ab7ee1a39c3d2be3d3bdb4242985d75812", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1020a5ab7ee1a39c3d2be3d3bdb4242985d75812/comments", "author": null, "committer": null, "parents": [{"sha": "4573b4de233cd221a8ecbb8fee3ad533dc68ce93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4573b4de233cd221a8ecbb8fee3ad533dc68ce93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4573b4de233cd221a8ecbb8fee3ad533dc68ce93"}], "stats": {"total": 247, "additions": 199, "deletions": 48}, "files": [{"sha": "c94073eded9cd9e601806026a41a26ac105d92c3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1020a5ab7ee1a39c3d2be3d3bdb4242985d75812/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1020a5ab7ee1a39c3d2be3d3bdb4242985d75812/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1020a5ab7ee1a39c3d2be3d3bdb4242985d75812", "patch": "@@ -1,13 +1,24 @@\n 2001-03-28  Richard Henderson  <rth@redhat.com>\n \n-        * config/alpha/alpha.c (alpha_sa_mask): Add EH_RETURN_DATA_REGNOs.\n-        (alpha_mark_machine_status): No eh_epilogue_sp_ofs ...\n-        (alpha_expand_epilogue): ... use EH_RETURN_STACKADJ_RTX instead.\n-        * config/alpha/alpha.h (machine_function): Remove eh_epilogue_sp_ofs.\n-        (EH_RETURN_DATA_REGNO): New.\n-        (EH_RETURN_STACKADJ_RTX, EH_RETURN_HANDLER_RTX): New.\n-        * config/alpha/alpha.md (eh_epilogue): Remove.\n-        (exception_receiver): Use $26 for ldgp input.\n+\t* config/i386/i386.c (general_no_elim_operand): Disallow virtual regs.\n+\t(ix86_save_reg): If maybe_eh_return, true for EH_RETURN_DATA_REGNOs.\n+\tTrue for pic register if current_function_calls_eh_return.\n+\t(ix86_expand_epilogue): Change \"emit_return\" argument into \"style\".\n+\tHandle eh_return requirements.\n+\t* config/i386/i386.h (EH_RETURN_DATA_REGNO): New.\n+\t(EH_RETURN_STACKADJ_RTX): New.\n+\t* config/i386/i386.md (exception_receiver): Remove.\n+\t(eh_return, eh_return_1): New.\n+\t* config/i386/linux.h (MD_FALLBACK_FRAME_STATE_FOR): New.\n+\n+\t* config/alpha/alpha.c (alpha_sa_mask): Add EH_RETURN_DATA_REGNOs.\n+\t(alpha_mark_machine_status): No eh_epilogue_sp_ofs ...\n+\t(alpha_expand_epilogue): ... use EH_RETURN_STACKADJ_RTX instead.\n+\t* config/alpha/alpha.h (machine_function): Remove eh_epilogue_sp_ofs.\n+\t(EH_RETURN_DATA_REGNO): New.\n+\t(EH_RETURN_STACKADJ_RTX, EH_RETURN_HANDLER_RTX): New.\n+\t* config/alpha/alpha.md (eh_epilogue): Remove.\n+\t(exception_receiver): Use $26 for ldgp input.\n \t* config/alpha/linux.h (MD_FALLBACK_FRAME_STATE_FOR): New.\n \n 2001-03-28  Richard Henderson  <rth@redhat.com>"}, {"sha": "57db899d641e216ea317cdb768ba5aebf74f95ad", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 80, "deletions": 27, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1020a5ab7ee1a39c3d2be3d3bdb4242985d75812/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1020a5ab7ee1a39c3d2be3d3bdb4242985d75812/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=1020a5ab7ee1a39c3d2be3d3bdb4242985d75812", "patch": "@@ -566,7 +566,7 @@ static int ix86_split_to_parts PARAMS ((rtx, rtx *, enum machine_mode));\n static int ix86_safe_length_prefix PARAMS ((rtx));\n static int ix86_nsaved_regs PARAMS((void));\n static void ix86_emit_save_regs PARAMS((void));\n-static void ix86_emit_restore_regs_using_mov PARAMS ((rtx, int));\n+static void ix86_emit_restore_regs_using_mov PARAMS ((rtx, int, bool));\n static void ix86_emit_epilogue_esp_adjustment PARAMS((int));\n static void ix86_set_move_mem_attrs_1 PARAMS ((rtx, rtx, rtx, rtx, rtx));\n static void ix86_sched_reorder_pentium PARAMS((rtx *, rtx *));\n@@ -606,7 +606,7 @@ static int ix86_fp_comparison_arithmetics_cost PARAMS ((enum rtx_code code));\n static int ix86_fp_comparison_fcomi_cost PARAMS ((enum rtx_code code));\n static int ix86_fp_comparison_sahf_cost PARAMS ((enum rtx_code code));\n static int ix86_fp_comparison_cost PARAMS ((enum rtx_code code));\n-static int ix86_save_reg PARAMS ((int));\n+static int ix86_save_reg PARAMS ((int, bool));\n static void ix86_compute_frame_layout PARAMS ((struct ix86_frame *));\n \f\n /* Sometimes certain combinations of command options do not make\n@@ -1475,6 +1475,10 @@ general_no_elim_operand (op, mode)\n       || t == virtual_incoming_args_rtx || t == virtual_stack_vars_rtx\n       || t == virtual_stack_dynamic_rtx)\n     return 0;\n+  if (REG_P (t)\n+      && REGNO (t) >= FIRST_VIRTUAL_REGISTER\n+      && REGNO (t) <= LAST_VIRTUAL_REGISTER)\n+    return 0;\n \n   return general_operand (op, mode);\n }\n@@ -2249,17 +2253,35 @@ gen_push (arg)\n \n /* Return 1 if we need to save REGNO.  */\n static int\n-ix86_save_reg (regno)\n-\tint regno;\n-{\n-  int pic_reg_used = flag_pic && (current_function_uses_pic_offset_table\n-\t\t\t\t  || current_function_uses_const_pool)\n-\t\t     && !TARGET_64BIT;\n-  return ((regs_ever_live[regno] && !call_used_regs[regno]\n-\t   && !fixed_regs[regno]\n-\t   && (regno != HARD_FRAME_POINTER_REGNUM || !frame_pointer_needed))\n-\t  || (regno == PIC_OFFSET_TABLE_REGNUM && pic_reg_used));\n+ix86_save_reg (regno, maybe_eh_return)\n+     int regno;\n+     bool maybe_eh_return;\n+{\n+  if (flag_pic\n+      && ! TARGET_64BIT\n+      && regno == PIC_OFFSET_TABLE_REGNUM\n+      && (current_function_uses_pic_offset_table\n+\t  || current_function_uses_const_pool\n+\t  || current_function_calls_eh_return))\n+    return 1;\n+\n+  if (current_function_calls_eh_return && maybe_eh_return)\n+    {\n+      unsigned i;\n+      for (i = 0; ; i++)\n+\t{\n+\t  unsigned test = EH_RETURN_DATA_REGNO(i);\n+\t  if (test == INVALID_REGNUM)\n+\t    break;\n+\t  if (test == (unsigned) regno)\n+\t    return 1;\n+\t}\n+    }\n \n+  return (regs_ever_live[regno]\n+\t  && !call_used_regs[regno]\n+\t  && !fixed_regs[regno]\n+\t  && (regno != HARD_FRAME_POINTER_REGNUM || !frame_pointer_needed));\n }\n \n /* Return number of registers to be saved on the stack.  */\n@@ -2271,7 +2293,7 @@ ix86_nsaved_regs ()\n   int regno;\n \n   for (regno = FIRST_PSEUDO_REGISTER - 1; regno >= 0; regno--)\n-    if (ix86_save_reg (regno))\n+    if (ix86_save_reg (regno, true))\n       nregs++;\n   return nregs;\n }\n@@ -2423,7 +2445,7 @@ ix86_emit_save_regs ()\n   rtx insn;\n \n   for (regno = FIRST_PSEUDO_REGISTER - 1; regno >= 0; regno--)\n-    if (ix86_save_reg (regno))\n+    if (ix86_save_reg (regno, true))\n       {\n \tinsn = emit_insn (gen_push (gen_rtx_REG (Pmode, regno)));\n \tRTX_FRAME_RELATED_P (insn) = 1;\n@@ -2535,14 +2557,15 @@ ix86_emit_epilogue_esp_adjustment (tsize)\n /* Emit code to restore saved registers using MOV insns.  First register\n    is restored from POINTER + OFFSET.  */\n static void\n-ix86_emit_restore_regs_using_mov (pointer, offset)\n-\trtx pointer;\n-\tint offset;\n+ix86_emit_restore_regs_using_mov (pointer, offset, maybe_eh_return)\n+     rtx pointer;\n+     int offset;\n+     bool maybe_eh_return;\n {\n   int regno;\n \n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-    if (ix86_save_reg (regno))\n+    if (ix86_save_reg (regno, maybe_eh_return))\n       {\n \temit_move_insn (gen_rtx_REG (Pmode, regno),\n \t\t\tadj_offsettable_operand (gen_rtx_MEM (Pmode,\n@@ -2555,8 +2578,8 @@ ix86_emit_restore_regs_using_mov (pointer, offset)\n /* Restore function stack, frame, and registers.  */\n \n void\n-ix86_expand_epilogue (emit_return)\n-     int emit_return;\n+ix86_expand_epilogue (style)\n+     int style;\n {\n   int regno;\n   int sp_valid = !frame_pointer_needed || current_function_sp_is_unchanging;\n@@ -2588,7 +2611,8 @@ ix86_expand_epilogue (emit_return)\n   if ((!sp_valid && frame.nregs <= 1)\n       || (frame_pointer_needed && !frame.nregs && frame.to_allocate)\n       || (frame_pointer_needed && TARGET_USE_LEAVE && !optimize_size\n-\t  && frame.nregs == 1))\n+\t  && frame.nregs == 1)\n+      || style == 2)\n     {\n       /* Restore registers.  We can use ebp or esp to address the memory\n \t locations.  If both are available, default to ebp, since offsets\n@@ -2597,12 +2621,41 @@ ix86_expand_epilogue (emit_return)\n \t mode.  */\n \n       if (!frame_pointer_needed || (sp_valid && !frame.to_allocate))\n-\tix86_emit_restore_regs_using_mov (stack_pointer_rtx, frame.to_allocate);\n+\tix86_emit_restore_regs_using_mov (stack_pointer_rtx,\n+\t\t\t\t\t  frame.to_allocate, style == 2);\n       else\n-\tix86_emit_restore_regs_using_mov (hard_frame_pointer_rtx, offset);\n+\tix86_emit_restore_regs_using_mov (hard_frame_pointer_rtx,\n+\t\t\t\t\t  offset, style == 2);\n \n-      if (!frame_pointer_needed)\n-\tix86_emit_epilogue_esp_adjustment (frame.to_allocate + frame.nregs * UNITS_PER_WORD);\n+      /* eh_return epilogues need %ecx added to the stack pointer.  */\n+      if (style == 2)\n+\t{\n+\t  rtx tmp, sa = EH_RETURN_STACKADJ_RTX;\n+\n+\t  if (frame_pointer_needed)\n+\t    {\n+\t      tmp = gen_rtx_PLUS (Pmode, hard_frame_pointer_rtx, sa);\n+\t      tmp = plus_constant (tmp, UNITS_PER_WORD);\n+\t      emit_insn (gen_rtx_SET (VOIDmode, sa, tmp));\n+\n+\t      tmp = gen_rtx_MEM (Pmode, hard_frame_pointer_rtx);\n+\t      emit_move_insn (hard_frame_pointer_rtx, tmp);\n+\n+\t      emit_insn (gen_pro_epilogue_adjust_stack\n+\t\t\t (stack_pointer_rtx, sa, const0_rtx,\n+\t\t\t  hard_frame_pointer_rtx));\n+\t    }\n+\t  else\n+\t    {\n+\t      tmp = gen_rtx_PLUS (Pmode, stack_pointer_rtx, sa);\n+\t      tmp = plus_constant (tmp, (frame.to_allocate\n+                                         + frame.nregs * UNITS_PER_WORD));\n+\t      emit_insn (gen_rtx_SET (VOIDmode, stack_pointer_rtx, tmp));\n+\t    }\n+\t}\n+      else if (!frame_pointer_needed)\n+\tix86_emit_epilogue_esp_adjustment (frame.to_allocate\n+\t\t\t\t\t   + frame.nregs * UNITS_PER_WORD);\n       /* If not an i386, mov & pop is faster than \"leave\".  */\n       else if (TARGET_USE_LEAVE || optimize_size)\n \temit_insn (TARGET_64BIT ? gen_leave_rex64 () : gen_leave ());\n@@ -2635,7 +2688,7 @@ ix86_expand_epilogue (emit_return)\n \tix86_emit_epilogue_esp_adjustment (frame.to_allocate);\n \n       for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-\tif (ix86_save_reg (regno))\n+\tif (ix86_save_reg (regno, false))\n \t  {\n \t    if (TARGET_64BIT)\n \t      emit_insn (gen_popdi1 (gen_rtx_REG (Pmode, regno)));\n@@ -2652,7 +2705,7 @@ ix86_expand_epilogue (emit_return)\n     }\n \n   /* Sibcall epilogues don't want a return instruction.  */\n-  if (! emit_return)\n+  if (style == 0)\n     return;\n \n   if (current_function_pops_args && current_function_args_size)"}, {"sha": "cd9e54aa607c212930d7d3955bb0171326dbd772", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1020a5ab7ee1a39c3d2be3d3bdb4242985d75812/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1020a5ab7ee1a39c3d2be3d3bdb4242985d75812/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=1020a5ab7ee1a39c3d2be3d3bdb4242985d75812", "patch": "@@ -2779,17 +2779,21 @@ extern int const svr4_dbx_register_map[FIRST_PSEUDO_REGISTER];\n   gen_rtx_MEM (VOIDmode, gen_rtx_REG (VOIDmode, STACK_POINTER_REGNUM))\n  \n /* After the prologue, RA is at -4(AP) in the current frame.  */\n-#define RETURN_ADDR_RTX(COUNT, FRAME)\t\t\t\t\t\\\n-  ((COUNT) == 0\t\t\t\t\t\t\t\t\\\n-   ? gen_rtx_MEM (Pmode, plus_constant (arg_pointer_rtx, TARGET_64BIT ? -8 : -4))\\\n-   : gen_rtx_MEM (Pmode, plus_constant (FRAME, TARGET_64BIT ? 8 : 4)))\n+#define RETURN_ADDR_RTX(COUNT, FRAME)\t\t\t\t\t   \\\n+  ((COUNT) == 0\t\t\t\t\t\t\t\t   \\\n+   ? gen_rtx_MEM (Pmode, plus_constant (arg_pointer_rtx, -UNITS_PER_WORD)) \\\n+   : gen_rtx_MEM (Pmode, plus_constant (FRAME, UNITS_PER_WORD)))\n \n /* PC is dbx register 8; let's use that column for RA. */\n #define DWARF_FRAME_RETURN_COLUMN \t(TARGET_64BIT ? 16 : 8)\n \n /* Before the prologue, the top of the frame is at 4(%esp).  */\n #define INCOMING_FRAME_SP_OFFSET UNITS_PER_WORD\n \n+/* Describe how we implement __builtin_eh_return.  */\n+#define EH_RETURN_DATA_REGNO(N)\t((N) < 2 ? (N) : INVALID_REGNUM)\n+#define EH_RETURN_STACKADJ_RTX\tgen_rtx_REG (Pmode, 2)\n+\n /* This is how to output the definition of a user-level label named NAME,\n    such as the label on a static function or variable NAME.  */\n "}, {"sha": "0d61b8eaf26e1d6decdec37924a8681f2bc1dbeb", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 30, "deletions": 9, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1020a5ab7ee1a39c3d2be3d3bdb4242985d75812/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1020a5ab7ee1a39c3d2be3d3bdb4242985d75812/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=1020a5ab7ee1a39c3d2be3d3bdb4242985d75812", "patch": "@@ -73,6 +73,7 @@\n ;; 10 This is a `sahf' operation.\n ;; 11 This is a `fstcw' operation\n ;; 12 This is behaviour of add when setting carry flag.\n+;; 13 This is a `eh_return' placeholder.\n \n ;; For SSE/MMX support:\n ;; 30 This is `fix', guaranteed to be truncating.\n@@ -13017,6 +13018,35 @@\n   \"\"\n   \"ix86_expand_epilogue (0); DONE;\")\n \n+(define_expand \"eh_return\"\n+  [(use (match_operand 0 \"register_operand\" \"\"))\n+   (use (match_operand 1 \"register_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  rtx tmp, sa = operands[0], ra = operands[1];\n+\n+  /* Tricky bit: we write the address of the handler to which we will\n+     be returning into someone else's stack frame, one word below the\n+     stack address we wish to restore.  */\n+  tmp = gen_rtx_PLUS (Pmode, arg_pointer_rtx, sa);\n+  tmp = plus_constant (tmp, -UNITS_PER_WORD);\n+  tmp = gen_rtx_MEM (Pmode, tmp);\n+  emit_move_insn (tmp, ra);\n+\n+  emit_insn (gen_eh_return_1 (sa));\n+  emit_barrier ();\n+  DONE;\n+}\")\n+\n+(define_insn_and_split \"eh_return_1\"\n+  [(unspec_volatile [(match_operand 0 \"register_operand\" \"c\")] 13)]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(const_int 1)]\n+  \"ix86_expand_epilogue (2); DONE;\")\n+\n (define_insn \"leave\"\n   [(set (reg:SI 7) (reg:SI 6))\n    (set (reg:SI 6) (mem:SI (pre_dec:SI (reg:SI 7))))]\n@@ -15754,15 +15784,6 @@\n   DONE;\n }\")\n \n-(define_expand \"exception_receiver\"\n-  [(const_int 0)]\n-  \"flag_pic\"\n-  \"\n-{\n-  load_pic_register ();\n-  DONE;\n-}\")\n-\n (define_expand \"builtin_setjmp_receiver\"\n   [(label_ref (match_operand 0 \"\" \"\"))]\n   \"flag_pic\""}, {"sha": "138a2469117822bd7c5d741ae5836053db49006d", "filename": "gcc/config/i386/linux.h", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1020a5ab7ee1a39c3d2be3d3bdb4242985d75812/gcc%2Fconfig%2Fi386%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1020a5ab7ee1a39c3d2be3d3bdb4242985d75812/gcc%2Fconfig%2Fi386%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Flinux.h?ref=1020a5ab7ee1a39c3d2be3d3bdb4242985d75812", "patch": "@@ -188,3 +188,65 @@ Boston, MA 02111-1307, USA.  */\n     }\t\t\t\t\t\\\n   while (0)\n #endif\n+\n+/* Do code reading to identify a signal frame, and set the frame\n+   state data appropriately.  See unwind-dw2.c for the structs.  */\n+\n+#ifdef IN_LIBGCC2\n+#include <signal.h>\n+#include <sys/ucontext.h>\n+#endif\n+\n+#define MD_FALLBACK_FRAME_STATE_FOR(CONTEXT, FS, SUCCESS)\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    unsigned char *pc_ = (CONTEXT)->ra;\t\t\t\t\t\\\n+    struct sigcontext *sc_;\t\t\t\t\t\t\\\n+    long new_cfa_;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    /* popl %eax ; movl $__NR_sigreturn,%eax ; int $0x80  */\t\t\\\n+    if (*(unsigned short *)(pc_+0) == 0xb858\t\t\t\t\\\n+\t&& *(unsigned int *)(pc_+2) == 119\t\t\t\t\\\n+\t&& *(unsigned short *)(pc_+6) == 0x80cd)\t\t\t\\\n+      sc_ = (CONTEXT)->cfa + 4;\t\t\t\t\t\t\\\n+    /* movl $__NR_rt_sigreturn,%eax ; int $0x80  */\t\t\t\\\n+    else if (*(unsigned char *)(pc_+0) == 0xb8\t\t\t\t\\\n+\t     && *(unsigned int *)(pc_+1) == 173\t\t\t\t\\\n+\t     && *(unsigned short *)(pc_+5) == 0x80cd)\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tstruct rt_sigframe {\t\t\t\t\t\t\\\n+\t  int sig;\t\t\t\t\t\t\t\\\n+\t  struct siginfo *pinfo;\t\t\t\t\t\\\n+\t  void *puc;\t\t\t\t\t\t\t\\\n+\t  struct siginfo info;\t\t\t\t\t\t\\\n+\t  struct ucontext uc;\t\t\t\t\t\t\\\n+\t} *rt_ = (CONTEXT)->cfa;\t\t\t\t\t\\\n+\tsc_ = (struct sigcontext *) &rt_->uc.uc_mcontext;\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    new_cfa_ = sc_->esp;\t\t\t\t\t\t\\\n+    (FS)->cfa_how = CFA_REG_OFFSET;\t\t\t\t\t\\\n+    (FS)->cfa_reg = 4;\t\t\t\t\t\t\t\\\n+    (FS)->cfa_offset = new_cfa_ - (long) (CONTEXT)->cfa;\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    /* The SVR4 register numbering macros aren't usable in libgcc.  */\t\\\n+    (FS)->regs.reg[0].how = REG_SAVED_OFFSET;\t\t\t\t\\\n+    (FS)->regs.reg[0].loc.offset = (long)&sc_->eax - new_cfa_;\t\t\\\n+    (FS)->regs.reg[3].how = REG_SAVED_OFFSET;\t\t\t\t\\\n+    (FS)->regs.reg[3].loc.offset = (long)&sc_->ebx - new_cfa_;\t\t\\\n+    (FS)->regs.reg[1].how = REG_SAVED_OFFSET;\t\t\t\t\\\n+    (FS)->regs.reg[1].loc.offset = (long)&sc_->ecx - new_cfa_;\t\t\\\n+    (FS)->regs.reg[2].how = REG_SAVED_OFFSET;\t\t\t\t\\\n+    (FS)->regs.reg[2].loc.offset = (long)&sc_->edx - new_cfa_;\t\t\\\n+    (FS)->regs.reg[6].how = REG_SAVED_OFFSET;\t\t\t\t\\\n+    (FS)->regs.reg[6].loc.offset = (long)&sc_->esi - new_cfa_;\t\t\\\n+    (FS)->regs.reg[7].how = REG_SAVED_OFFSET;\t\t\t\t\\\n+    (FS)->regs.reg[7].loc.offset = (long)&sc_->edi - new_cfa_;\t\t\\\n+    (FS)->regs.reg[5].how = REG_SAVED_OFFSET;\t\t\t\t\\\n+    (FS)->regs.reg[5].loc.offset = (long)&sc_->ebp - new_cfa_;\t\t\\\n+    (FS)->regs.reg[8].how = REG_SAVED_OFFSET;\t\t\t\t\\\n+    (FS)->regs.reg[8].loc.offset = (long)&sc_->eip - new_cfa_;\t\t\\\n+    (FS)->retaddr_column = 8;\t\t\t\t\t\t\\\n+    goto SUCCESS;\t\t\t\t\t\t\t\\\n+  } while (0)"}]}