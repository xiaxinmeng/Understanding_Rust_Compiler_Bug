{"sha": "b4075f6b7d43d4c22d12c0d63aa4dfa3c835177d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQwNzVmNmI3ZDQzZDRjMjJkMTJjMGQ2M2FhNGRmYTNjODM1MTc3ZA==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm28@cam.ac.uk", "date": "2001-10-08T07:58:43Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2001-10-08T07:58:43Z"}, "message": "gcc_release: Copy from 3.0 branch.\n\n\t* gcc_release: Copy from 3.0 branch.  Add support for building the\n\tweekly snapshots on gcc.gnu.org.\n\nFrom-SVN: r46073", "tree": {"sha": "3eec1997bf96c7b26d545569680baa32ff6df156", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3eec1997bf96c7b26d545569680baa32ff6df156"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4075f6b7d43d4c22d12c0d63aa4dfa3c835177d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4075f6b7d43d4c22d12c0d63aa4dfa3c835177d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4075f6b7d43d4c22d12c0d63aa4dfa3c835177d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4075f6b7d43d4c22d12c0d63aa4dfa3c835177d/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "83e2393c91dd7ca4efd3c6c298e924283a0bebaa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83e2393c91dd7ca4efd3c6c298e924283a0bebaa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83e2393c91dd7ca4efd3c6c298e924283a0bebaa"}], "stats": {"total": 618, "additions": 618, "deletions": 0}, "files": [{"sha": "3925643782aa899b34129bd43c84c2ab591dadaf", "filename": "maintainer-scripts/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4075f6b7d43d4c22d12c0d63aa4dfa3c835177d/maintainer-scripts%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4075f6b7d43d4c22d12c0d63aa4dfa3c835177d/maintainer-scripts%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/maintainer-scripts%2FChangeLog?ref=b4075f6b7d43d4c22d12c0d63aa4dfa3c835177d", "patch": "@@ -1,3 +1,8 @@\n+2001-10-08  Joseph S. Myers  <jsm28@cam.ac.uk>\n+\n+\t* gcc_release: Copy from 3.0 branch.  Add support for building the\n+\tweekly snapshots on gcc.gnu.org.\n+\n 2001-08-28  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* update_web_docs: Also check out texinfo.tex from"}, {"sha": "59d4711da7f43531c6b6d27e574bfb672bcd15e7", "filename": "maintainer-scripts/gcc_release", "status": "added", "additions": 613, "deletions": 0, "changes": 613, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4075f6b7d43d4c22d12c0d63aa4dfa3c835177d/maintainer-scripts%2Fgcc_release", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4075f6b7d43d4c22d12c0d63aa4dfa3c835177d/maintainer-scripts%2Fgcc_release", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/maintainer-scripts%2Fgcc_release?ref=b4075f6b7d43d4c22d12c0d63aa4dfa3c835177d", "patch": "@@ -0,0 +1,613 @@\n+#! /bin/sh\n+\n+########################################################################\n+#\n+# File:   gcc_release\n+# Author: Jeffrey Law, Bernd Schmidt, Mark Mitchell\n+# Date:   2001-05-25\n+#\n+# Contents:\n+#   Script to create a GCC release.\n+#\n+# Copyright (c) 2001 Free Software Foundation.\n+#\n+# This file is part of GNU CC.\n+#\n+# GNU CC is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2, or (at your option)\n+# any later version.\n+#\n+# GNU CC is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GNU CC; see the file COPYING.  If not, write to\n+# the Free Software Foundation, 59 Temple Place - Suite 330,\n+# Boston, MA 02111-1307, USA.\n+#\n+########################################################################\n+\n+########################################################################\n+# Notes\n+########################################################################\n+\n+# Here is an example usage of this script, to create a GCC 3.0.2\n+# prerelease:\n+#\n+#   gcc_release -r 3.0.2\n+#\n+# This script will automatically use the head of the release branch\n+# to generate the release.\n+\n+########################################################################\n+# Functions\n+########################################################################\n+\n+# Issue the error message given by $1 and exit with a non-zero\n+# exit code.\n+\n+error() {\n+    echo \"gcc_release: error: $1\"\n+    exit 1\n+}\n+\n+# Issue the informational message given by $1.\n+\n+inform() {\n+    echo \"gcc_release: $1\"\n+}\n+\n+# Issue a usage message explaining how to use this script.\n+\n+usage() {\n+cat <<EOF\n+gcc_release     [-d destination]\n+                [-u username]\n+\t\t[-r release]\n+\t\t[-t tag]\n+\t\t[-p previous-tarball]\n+\t\t[-s] [-f] [-l]\n+EOF\n+    exit 1\n+}\n+\n+# Change to the directory given by $1.\n+\n+changedir() {\n+  cd $1 || \\\n+    error \"Could not change directory to $1\"\n+}\n+\n+# Each of the arguments is a directory name, relative to the top\n+# of the source tree.  Return another name for that directory, relative\n+# to the working directory.\n+\n+adjust_dirs() {\n+  for x in $@; do\n+    echo `basename ${SOURCE_DIRECTORY}`/$x\n+  done\n+}\n+\n+# Build the source tree that will be the basis for the release\n+# in ${WORKING_DIRECTORY}/gcc-${RELEASE}.\n+\n+build_sources() {\n+  # If the WORKING_DIRECTORY already exists, do not risk destroying it.\n+  if [ -r ${WORKING_DIRECTORY} ]; then\n+    error \"\\`${WORKING_DIRECTORY}' already exists\"\n+  fi\n+  # Create the WORKING_DIRECTORY.\n+  mkdir \"${WORKING_DIRECTORY}\" \\\n+    || error \"Could not create \\`${WORKING_DIRECTORY}'\"\n+  changedir \"${WORKING_DIRECTORY}\"\n+\n+  # If this is a final release, make sure that the ChangeLogs\n+  # and version strings are updated.\n+  if [ ${FINAL} -ne 0 ]; then\n+    inform \"Updating ChangeLogs and version files\"\n+\n+    ${CVS} co -d \"`basename ${SOURCE_DIRECTORY}`\" \\\n+           -r ${BRANCH} gcc || \\\n+           error \"Could not check out release sources\"\n+    for x in `find ${SOURCE_DIRECTORY} -name ChangeLog`; do\n+      cat - ${x} > ${x}.new <<EOF\n+${LONG_DATE}  Release Manager\n+\n+\t* GCC ${RELEASE} Released.\n+\n+EOF\n+      mv ${x}.new ${x} || \\\n+        error \"Could not update ${x}\"\n+      (changedir `dirname ${x}` && \\\n+        ${CVS} ci -m 'Mark ChangeLog' `basename ${x}`) || \\\n+        error \"Could not commit ${x}\"\n+    done\n+\n+    # Update `gcc/version.c'.  There are other version files\n+    # as well, which should have release status updated.\n+    for x in gcc/version.c; do \n+      y=`basename ${x}`\n+      (changedir `dirname ${SOURCE_DIRECTORY}/${x}` && \\\n+          sed -e 's|= \\\".*\\\"|= \\\"'${RELEASE}'\\\"|g' < ${y} > ${y}.new && \\\n+\t  mv ${y}.new ${y} && \\\n+          ${CVS} ci -m 'Update version' ${y}) || \\\n+\t  error \"Could not update ${x}\"\n+    done\n+    for x in gcc/f/version.c libf2c/libF77/Version.c \\\n+             libf2c/libI77/Version.c libf2c/libU77/Version.c; do\n+      y=`basename ${x}`\n+      (changedir `dirname ${SOURCE_DIRECTORY}/${x}` && \\\n+          sed -e 's/experimental\\|prerelease/release/g' < ${y} > ${y}.new && \\\n+\t  mv ${y}.new ${y} && \\\n+          ${CVS} ci -m 'Update version' ${y}) || \\\n+\t  error \"Could not update ${x}\"\n+    done\n+\n+    # Make sure we tag the sources for a final release.\n+    TAG=\"gcc_`echo ${RELEASE} | tr . _`_release\"\n+\n+    rm -rf ${SOURCE_DIRECTORY}\n+  fi\n+\n+  # Tag the sources.\n+  if [ -n \"${TAG}\" ]; then\n+    inform \"Tagging release sources\"\n+    ${CVS} rtag -r ${BRANCH} -F ${TAG} gcc || \\\n+      error \"Could not tag release sources\"\n+    BRANCH=$TAG\n+  fi\n+\n+  # Export the current sources.\n+  inform \"Retrieving release sources\"\n+  ${CVS} \\\n+       export -d \"`basename ${SOURCE_DIRECTORY}`\" \\\n+       -r ${BRANCH} gcc || \\\n+    error \"Could not retrieve release sources\"\n+\n+  # Run gcc_update on them to set up the timestamps nicely.\n+  changedir \"gcc-${RELEASE}\"\n+  contrib/gcc_update --touch\n+\n+  # Obtain some documentation files from the wwwdocs module.\n+  inform \"Retrieving HTML documentation\"\n+  changedir \"${WORKING_DIRECTORY}\"\n+  for x in bugs gnats faq; do\n+    (${CVS} export -r HEAD wwwdocs/htdocs/${x}.html && \\\n+     cp ${WORKING_DIRECTORY}/wwwdocs/htdocs/${x}.html \\\n+        ${SOURCE_DIRECTORY}) || \\\n+      error \"Could not retrieve ${x}.html\"\n+  done\n+\n+  inform \"Generating plain-text documentation from HTML\"\n+  changedir \"${SOURCE_DIRECTORY}\"\n+  for file in *.html; do\n+    newfile=`echo $file | sed -e 's/.html//' | tr \"[:lower:]\" \"[:upper:]\"`\n+    (${ENV} TERM=vt100 lynx -dump $file \\\n+       | sed -e \"s#file://localhost`/bin/pwd`\\(.*\\)#http://gcc.gnu.org\\1#g\" \\\n+       > $newfile) || \\\n+     error \"Could not regenerate documentation\"\n+  done\n+\n+  # For a prerelease or real release, we need to generate additional\n+  # files not present in CVS.\n+  changedir \"${SOURCE_DIRECTORY}\"\n+  if [ $SNAPSHOT -ne 1 ]; then\n+    # Generate the documentation.\n+    inform \"Building install docs\"\n+    SOURCEDIR=${SOURCE_DIRECTORY}/gcc/doc\n+    DESTDIR=${SOURCE_DIRECTORY}/INSTALL\n+    export SOURCEDIR\n+    export DESTDIR\n+    ${SOURCE_DIRECTORY}/gcc/doc/install.texi2html\n+\n+    # Regenerate the NEWS file.\n+    contrib/gennews > gcc/NEWS || \\\n+      error \"Could not regenerate NEWS files\"\n+\n+    # Now, we must build the compiler in order to create any generated\n+    # files that are supposed to go in the source directory.  This is\n+    # also a good sanity check to make sure that the release builds\n+    # on at least one platform.\n+    inform \"Building compiler\"\n+    OBJECT_DIRECTORY=../objdir\n+    contrib/gcc_build -d ${SOURCE_DIRECTORY} -o ${OBJECT_DIRECTORY} build || \\\n+      error \"Could not rebuild GCC\"\n+\n+    # Regenerate the Fotran NEWS and BUGS files.\n+    (cd ${OBJECT_DIRECTORY}/gcc && make f77.rebuilt) || \\\n+      error \"Could not regenerate Fortran NEWS and BUGS files\"\n+  fi\n+\n+  # Move message catalogs to source directory.\n+  mv ../objdir/gcc/po/*.gmo gcc/po/\n+\n+  # Create a `.brik' file to use for checking the validity of the\n+  # release.\n+  changedir \"${SOURCE_DIRECTORY}\"\n+  BRIK_FILE=`mktemp /tmp/gcc_release.XXXXXXX`\n+  ((find . -type f | sort > $BRIK_FILE) && \\\n+       brik -Gb -f ${BRIK_FILE} > .brik && \\\n+       rm ${BRIK_FILE}) || \\\n+     error \"Could not compute brik checksum\"\n+}\n+\n+# Buid a single tarfile.  The first argument is the name of the name\n+# of the tarfile to build, without any suffixes.  They will be added\n+# automatically.  The rest of the arguments are the files or\n+# directories to include.\n+\n+build_tarfile() {\n+  # Get the name of the destination tar file.\n+  TARFILE=\"$1.tar.gz\"\n+  shift\n+\n+  # Build the tar file itself.\n+  (${TAR} cf - \"$@\" | ${GZIP} > ${TARFILE}) || \\\n+    error \"Could not build tarfile\"\n+  FILE_LIST=\"${FILE_LIST} ${TARFILE}\"\n+}\n+\n+# Build the various tar files for the release.\n+\n+build_tarfiles() {\n+  inform \"Building tarfiles\"\n+\n+  changedir \"${WORKING_DIRECTORY}\"\n+\n+  # The GNU Coding Standards specify that all files should\n+  # world readable.\n+  chmod -R a+r ${SOURCE_DIRECTORY}\n+  # And that all directories have mode 777.\n+  find ${SOURCE_DIRECTORY} -type d -exec chmod 777 {} \\;\n+ \n+  # Build one huge tarfile for the entire distribution.\n+  build_tarfile gcc-${RELEASE} `basename ${SOURCE_DIRECTORY}`\n+\n+  # Now, build one for each of the languages.\n+  build_tarfile gcc-g++-${RELEASE} ${CPLUSPLUS_DIRS}\n+  build_tarfile gcc-g77-${RELEASE} ${FORTRAN_DIRS}\n+  build_tarfile gcc-java-${RELEASE} ${JAVA_DIRS}\n+  build_tarfile gcc-objc-${RELEASE} ${OBJECTIVEC_DIRS}\n+  build_tarfile gcc-testsuite-${RELEASE} ${TESTSUITE_DIRS}\n+   \n+  # The core is everything else.\n+  EXCLUDES=\"\"\n+  for x in ${CPLUSPLUS_DIRS} ${FORTRAN_DIRS} ${JAVA_DIRS} \\\n+           ${OBJECTIVEC_DIRS} ${TESTSUITE_DIRS}; do\n+    EXCLUDES=\"${EXCLUDES} --exclude $x\"\n+  done\n+  build_tarfile gcc-core-${RELEASE} ${EXCLUDES} \\\n+    `basename ${SOURCE_DIRECTORY}`\n+\n+  # Possibly build diffs.\n+  if [ -n \"$OLD_TARS\" ]; then\n+    for old_tar in $OLD_TARS; do\n+      build_diffs $old_tar\n+    done\n+  fi\n+\n+  # Build .bz2 files.\n+  for f in ${FILE_LIST}; do\n+    bzfile=${f%.gz}.bz2\n+    zcat $f | ${BZIP2} > ${bzfile}\n+    FILE_LIST=\"${FILE_LIST} ${bzfile}\"\n+  done\n+}\n+\n+# Build diffs against an old release.\n+build_diffs() {\n+  old_dir=${1%/*}\n+  old_file=${1##*/}\n+  old_vers=${old_file%.tar.gz}\n+  old_vers=${old_vers#gcc-}\n+  inform \"Building diffs against version $old_vers\"\n+  for f in gcc gcc-g++ gcc-g77 gcc-java gcc-objc gcc-testsuite gcc-core; do\n+    old_tar=${old_dir}/${f}-${old_vers}.tar.gz\n+    new_tar=${WORKING_DIRECTORY}/${f}-${RELEASE}.tar.gz\n+    if [ -e $old_tar ] && [ -e $new_tar ]; then\n+      build_diff $old_tar gcc-${old_vers} $new_tar gcc-${RELEASE} \\\n+        ${f}-${old_vers}-${RELEASE}.diff.gz\n+    fi\n+  done\n+}\n+\n+# Build an individual diff.\n+build_diff() {\n+  changedir \"${WORKING_DIRECTORY}\"\n+  tmpdir=gccdiff.$$\n+  mkdir $tmpdir || error \"Could not create directory $tmpdir\"\n+  changedir $tmpdir\n+  tar xfz $1 || error \"Could not unpack $1 for diffs\"\n+  tar xfz $3 || error \"Could not unpack $3 for diffs\"\n+  ${DIFF} $2 $4 | ${GZIP} > ../$5\n+  if [ $? -eq 2 ]; then\n+    error \"Trouble making diffs from $1 to $3\"\n+  fi\n+  changedir ..\n+  rm -rf $tmpdir\n+  FILE_LIST=\"${FILE_LIST} $5\"\n+}\n+\n+# Upload the files to the FTP server.\n+\n+upload_files() {\n+  inform \"Uploading files\"\n+\n+  changedir \"${WORKING_DIRECTORY}\"\n+\n+  if [ $LOCAL -ne 0 ]; then\n+    mkdir -p \"${FTP_PATH}\" \\\n+      || error \"Could not create \\`${FTP_PATH}'\"\n+  fi\n+\n+  # Copy the tar files to the FTP server.\n+  for x in gcc*.gz gcc*.bz2; do\n+    if [ -e ${x} ]; then\n+      # Make sure the file will be readable on the server.\n+      chmod a+r ${x}\n+      # Copy it.\n+      ${SCP} ${x} ${FTP_PATH} || \\\n+        error \"Could not upload ${x}\"\n+    fi\n+  done\n+}\n+\n+########################################################################\n+# Initialization\n+########################################################################\n+\n+# Today's date.\n+DATE=`date \"+%Y%m%d\"`\n+LONG_DATE=`date \"+%Y-%m-%d\"`\n+\n+# The CVS server containing the GCC repository.\n+CVS_SERVER=\"gcc.gnu.org\"\n+# The path to the repository on that server.\n+CVS_REPOSITORY=\"/cvs/gcc\"\n+# The CVS protocol to use.\n+CVS_PROTOCOL=\"ext\"\n+# The username to use when connecting to the server.\n+CVS_USERNAME=\"${USER}\"\n+\n+# The path to the directory where the files are uploaded for FTP.\n+FTP_PATH=\"gccadmin@gcc.gnu.org:~ftp/pub/gcc\"\n+\n+# The major number for the release.  For release `3.0.2' this would be \n+# `3'\n+RELEASE_MAJOR=\"\"\n+# The minor number for the release.  For release `3.0.2' this would be\n+# `0'.\n+RELEASE_MINOR=\"\"\n+# The revision number for the release.  For release `3.0.2' this would\n+# be `2'.\n+RELEASE_REVISION=\"\"\n+# The complete name of the release.\n+RELEASE=\"\"\n+\n+# The name of the branch from which the release should be made.\n+BRANCH=\"\"\n+\n+# The tag to apply to the sources used for the release.\n+TAG=\"\"\n+\n+# The old tarballs from which to generate diffs.\n+OLD_TARS=\"\"\n+\n+# The directory that will be used to construct the release.  The\n+# release itself will be placed in a subdirectory of this diretory.\n+DESTINATION=${HOME}\n+# The subdirectory.\n+WORKING_DIRECTORY=\"\"\n+# The directory that will contain the GCC sources.\n+SOURCE_DIRECTORY=\"\"\n+\n+# The directories that should be part of the various language-specific\n+# tar files.  These are all relative to the top of the source tree.\n+CPLUSPLUS_DIRS=\"gcc/cp libstdc++-v3\"\n+FORTRAN_DIRS=\"gcc/f libf2c\"\n+JAVA_DIRS=\"gcc/java libjava libffi fastjar zlib boehm-gc\"\n+OBJECTIVEC_DIRS=\"gcc/objc libobjc\"\n+TESTSUITE_DIRS=\"gcc/testsuite\"\n+\n+# Non-zero if this is the final release, rather than a prerelease.\n+FINAL=0\n+\n+# Non-zero if we are building a snapshot, and don't build gcc or\n+# include generated files.\n+SNAPSHOT=0\n+\n+# Non-zero if we are running locally on gcc.gnu.org, and use local CVS\n+# and copy directly to the FTP directory.\n+LOCAL=0\n+\n+# Major operation modes.\n+MODE_SOURCES=0\n+MODE_TARFILES=0\n+MODE_UPLOAD=0\n+\n+# Files generated to upload.\n+FILE_LIST=\"\"\n+\n+# Programs we use.\n+\n+BZIP2=\"${BZIP2:-bzip2}\"\n+CVS=\"${CVS:-cvs -f -Q -z9}\"\n+DIFF=\"${DIFF:-diff -Nrc3pad}\"\n+ENV=\"${ENV:-env}\"\n+GZIP=\"${GZIP:-gzip --best}\"\n+SCP=\"${SCP:-scp -p}\"\n+TAR=\"${TAR:-tar}\"\n+\n+########################################################################\n+# Command Line Processing\n+########################################################################\n+\n+# Parse the options.\n+while getopts \"d:fr:u:t:p:sl\" ARG; do\n+    case $ARG in\n+    d)    DESTINATION=\"${OPTARG}\";;\n+    r)    RELEASE=\"${OPTARG}\";;\n+    t)    TAG=\"${OPTARG}\";;\n+    u)    CVS_USERNAME=\"${OPTARG}\";;\n+    f)    FINAL=1;;\n+    s)    SNAPSHOT=1;;\n+    l)    LOCAL=1\n+\t  SCP=cp\n+\t  FTP_PATH=~ftp/pub/gcc\n+\t  PATH=~:$PATH;;\n+    p)    OLD_TARS=\"${OLD_TARS} ${OPTARG}\";;\n+    \\?)   usage;;\n+    esac\n+done\n+shift `expr ${OPTIND} - 1`\n+\n+# Perform consistency checking.\n+if [ -z ${CVS_USERNAME} ]; then\n+  error \"No username specified\"\n+fi\n+\n+if [ ! -d ${DESTINATION} ]; then\n+  error \"\\`${DESTINATION}' is not a directory\"\n+fi\n+\n+if [ $SNAPSHOT -eq 0 ]; then\n+  if [ -z ${RELEASE} ]; then\n+    error \"No release number specified\"\n+  fi\n+\n+  # Compute the major and minor release numbers.\n+  RELEASE_MAJOR=`echo $RELEASE | awk --assign FS=. '{ print $1; }'`\n+  RELEASE_MINOR=`echo $RELEASE | awk --assign FS=. '{ print $2; }'`\n+  RELEASE_REVISION=`echo $RELEASE | awk --assign FS=. '{ print $3; }'`\n+\n+  if [ -z \"${RELEASE_MAJOR}\" ] || [ -z \"${RELEASE_MINOR}\" ]; then\n+    error \"Release number \\`${RELEASE}' is invalid\"\n+  fi\n+\n+  # Compute the full name of the release.\n+  if [ -z \"${RELEASE_REVISION}\" ]; then\n+    RELEASE=\"${RELEASE_MAJOR}.${RELEASE_MINOR}\"\n+  else\n+    RELEASE=\"${RELEASE_MAJOR}.${RELEASE_MINOR}.${RELEASE_REVISION}\"\n+  fi\n+\n+  # Compute the name of the branch, which is based solely on the major\n+  # and minor release numbers.\n+  BRANCH=\"gcc-${RELEASE_MAJOR}_${RELEASE_MINOR}-branch\"\n+\n+  # If this is not a final release, set various parameters acordingly.\n+  if [ ${FINAL} -ne 1 ]; then\n+    RELEASE=\"${RELEASE}-${DATE}\"\n+    FTP_PATH=\"${FTP_PATH}/snapshots\"\n+  else\n+    FTP_PATH=\"${FTP_PATH}/releases/gcc-${RELEASE}\"\n+  fi\n+else\n+  RELEASE=$DATE\n+  # For now snapshots come from the 3.0 branch.\n+  BRANCH=gcc-3_0-branch\n+  FTP_PATH=\"${FTP_PATH}/snapshots/${LONG_DATE}\"\n+  TAG=gcc_ss_${DATE}\n+\n+  # Building locally on gcc.gnu.org, we know what the last snapshot date\n+  # was.\n+  if [ $LOCAL -ne 0 ]; then\n+    LAST_DATE=`cat ~/.snapshot_date`\n+    PREV_LAST_DATE=`cat ~/.prev_snapshot_date`\n+    LAST_LONG_DATE=`date --date=$LAST_DATE +%Y-%m-%d`\n+    LAST_DIR=~ftp/pub/gcc/snapshots/${LAST_LONG_DATE}\n+    OLD_TARS=${LAST_DIR}/gcc-${LAST_DATE}.tar.gz\n+  fi\n+fi\n+\n+# Compute the name of the WORKING_DIRECTORY and the SOURCE_DIRECTORY.\n+WORKING_DIRECTORY=\"${DESTINATION}/gcc-${RELEASE}\"\n+SOURCE_DIRECTORY=\"${WORKING_DIRECTORY}/gcc-${RELEASE}\"\n+\n+# Recompute the names of all the language-specific directories,\n+# relative to the WORKING_DIRECTORY.\n+CPLUSPLUS_DIRS=`adjust_dirs ${CPLUSPLUS_DIRS}`\n+FORTRAN_DIRS=`adjust_dirs ${FORTRAN_DIRS}`\n+JAVA_DIRS=`adjust_dirs ${JAVA_DIRS}`\n+OBJECTIVEC_DIRS=`adjust_dirs ${OBJECTIVEC_DIRS}`\n+TESTSUITE_DIRS=`adjust_dirs ${TESTSUITE_DIRS}`\n+\n+# Set up CVSROOT.\n+if [ $LOCAL -eq 0 ]; then\n+    CVSROOT=\":${CVS_PROTOCOL}:${CVS_USERNAME}@\"\n+    CVSROOT=\"${CVSROOT}${CVS_SERVER}:${CVS_REPOSITORY}\"\n+else\n+    CVSROOT=\"${CVS_REPOSITORY}\"\n+fi\n+export CVSROOT\n+\n+########################################################################\n+# Main Program\n+########################################################################\n+\n+# Handle the major modes.\n+while [ $# -ne 0 ]; do\n+    case $1 in\n+    sources)  MODE_SOURCES=1;;\n+    tarfiles) MODE_TARFILES=1;;\n+    upload)   MODE_UPLOAD=1;;\n+    all)      MODE_SOURCES=1; MODE_TARFILES=1; MODE_UPLOAD=1;;\n+    *)        error \"Unknown mode $1\";;\n+    esac\n+    shift\n+done\n+\n+# Build the source directory.\n+\n+if [ $MODE_SOURCES -ne 0 ]; then\n+  build_sources\n+fi\n+\n+# Build the tar files.\n+\n+if [ $MODE_TARFILES -ne 0 ]; then\n+  build_tarfiles\n+fi\n+\n+# Upload them to the FTP server.\n+\n+if [ $MODE_UPLOAD -ne 0 ]; then\n+  upload_files\n+\n+  # For snapshots, make some further updates.\n+  if [ $SNAPSHOT -ne 0 ] && [ $LOCAL -ne 0 ]; then\n+    # Update links on the FTP server.\n+    TEXT_DATE=`date --date=$DATE +%B\\ %d,\\ %Y`\n+    LAST_TEXT_DATE=`date --date=$LAST_DATE +%B\\ %d,\\ %Y`\n+    cd ~ftp/pub/gcc/snapshots\n+    sed -e \"s%$LAST_DATE%$DATE%g\" -e \"s%$PREV_LAST_DATE%$LAST_DATE%g\" \\\n+      -e \"s%$LAST_LONG_DATE%$LONG_DATE%g\" \\\n+      -e \"s%$LAST_TEXT_DATE%$TEXT_DATE%g\" < README > $$\n+    mv $$ README\n+    sed -e \"s%$LAST_DATE%$DATE%g\" -e \"s%$PREV_LAST_DATE%$LAST_DATE%g\" \\\n+      -e \"s%$LAST_LONG_DATE%$LONG_DATE%g\" \\\n+      -e \"s%$LAST_TEXT_DATE%$TEXT_DATE%g\" < index.html > $$\n+    mv $$ index.html\n+\n+    touch LATEST-IS-$LONG_DATE\n+    rm -f LATEST-IS-$LAST_LONG_DATE\n+\n+    # Update snapshot date file.\n+    changedir ~\n+    mv .snapshot_date .prev_snapshot_date\n+    echo $DATE >.snapshot_date\n+\n+    # Update gcc_latest_snapshot tag.\n+    ${CVS} rtag -d gcc_latest_snapshot gcc\n+    ${CVS} rtag -rgcc_ss_${DATE} gcc_latest_snapshot gcc\n+\n+    # Announce the snapshot.\n+    mail -s \"gcc-ss-$DATE is now available\" gcc@gcc.gnu.org < ~ftp/pub/gcc/snapshots/README\n+\n+    # Remove working directory\n+    rm -rf ${WORKING_DIRECTORY}\n+  fi\n+fi"}]}