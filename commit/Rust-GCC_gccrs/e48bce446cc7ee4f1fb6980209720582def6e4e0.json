{"sha": "e48bce446cc7ee4f1fb6980209720582def6e4e0", "node_id": "C_kwDOANBUbNoAKGU0OGJjZTQ0NmNjN2VlNGYxZmI2OTgwMjA5NzIwNTgyZGVmNmU0ZTA", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-03-17T11:25:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-17T11:25:48Z"}, "message": "Merge #1027 #1032\n\n1027: parser: Allow parsing stmts without closing semicolon r=CohenArthur a=CohenArthur\n\nIn certain cases such as macro matching or macro expansion, it is\r\nimportant to allow the parser to return a valid statement even if no\r\nclosing semicolon is given. This commit adds an optional parameter to\r\nthe concerned functions to allow a lack of semicolon those special cases\r\n\r\nCloses #1011 \r\nCloses #1010 \n\n1032: Add AST kind information r=CohenArthur a=CohenArthur\n\nCloses #1001 \r\n\r\nThis PR adds a base for adding node information to our AST types. It can be used when requiring to differentiate between multiple kinds of nodes, while not necessarily wanting to do a full static cast. This will open up a lot of cleanup issues and good first issues for Project Pineapple\n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>", "tree": {"sha": "1dfb0f6e18f036dfd1596a9ea048ad07cce4f450", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1dfb0f6e18f036dfd1596a9ea048ad07cce4f450"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e48bce446cc7ee4f1fb6980209720582def6e4e0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiMxq8CRBK7hj4Ov3rIwAAXFwIAC2tVWA7T1C4p8JHk0Ms8NHw\nz7EasQmIFxXaQrwruhgmyBg26x6zMzL7FnojW1yiawU0KdRdsUPwA5vZXqGOxeQ/\nj2fdeSaNvLwajtNsJANgWCAc7494LREIbcD1xeWkTGMjLqFc7vlmz8EGJmV1mi12\nkV+RUu1MPifGccooPHV3uKJPfdY1KDYxmRKWRKX849CaGDXxMo4aVIB8KpOoWSWG\nQGdrm6hhxwG9/oWjqMyjNcwWi1gWsFpd2rEzM7Nc1khepzT2pW04B5McHTAbJuQB\nMFof9XiOaOb74gtvVkTbYJVlLUZd37GVhfD7PBpv3Kc+w2eI2twdhD8aEnjg16U=\n=+aif\n-----END PGP SIGNATURE-----\n", "payload": "tree 1dfb0f6e18f036dfd1596a9ea048ad07cce4f450\nparent 3ada3d8365ba3889f91140dfe108d3c74d3e4e38\nparent 313e9890d85b688f538fed52d158b4b4f4aea9dc\nparent 1e873922f0d4fa08448d49c6f5333ffa67fe4704\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1647516348 +0000\ncommitter GitHub <noreply@github.com> 1647516348 +0000\n\nMerge #1027 #1032\n\n1027: parser: Allow parsing stmts without closing semicolon r=CohenArthur a=CohenArthur\n\nIn certain cases such as macro matching or macro expansion, it is\r\nimportant to allow the parser to return a valid statement even if no\r\nclosing semicolon is given. This commit adds an optional parameter to\r\nthe concerned functions to allow a lack of semicolon those special cases\r\n\r\nCloses #1011 \r\nCloses #1010 \n\n1032: Add AST kind information r=CohenArthur a=CohenArthur\n\nCloses #1001 \r\n\r\nThis PR adds a base for adding node information to our AST types. It can be used when requiring to differentiate between multiple kinds of nodes, while not necessarily wanting to do a full static cast. This will open up a lot of cleanup issues and good first issues for Project Pineapple\n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e48bce446cc7ee4f1fb6980209720582def6e4e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e48bce446cc7ee4f1fb6980209720582def6e4e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e48bce446cc7ee4f1fb6980209720582def6e4e0/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ada3d8365ba3889f91140dfe108d3c74d3e4e38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ada3d8365ba3889f91140dfe108d3c74d3e4e38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ada3d8365ba3889f91140dfe108d3c74d3e4e38"}, {"sha": "313e9890d85b688f538fed52d158b4b4f4aea9dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/313e9890d85b688f538fed52d158b4b4f4aea9dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/313e9890d85b688f538fed52d158b4b4f4aea9dc"}, {"sha": "1e873922f0d4fa08448d49c6f5333ffa67fe4704", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e873922f0d4fa08448d49c6f5333ffa67fe4704", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e873922f0d4fa08448d49c6f5333ffa67fe4704"}], "stats": {"total": 229, "additions": 167, "deletions": 62}, "files": [{"sha": "3b965346cf6bc511df417c3898494afa02f581f8", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e48bce446cc7ee4f1fb6980209720582def6e4e0/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e48bce446cc7ee4f1fb6980209720582def6e4e0/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=e48bce446cc7ee4f1fb6980209720582def6e4e0", "patch": "@@ -36,6 +36,28 @@ namespace AST {\n class ASTVisitor;\n using AttrVec = std::vector<Attribute>;\n \n+// The available kinds of AST Nodes\n+enum Kind\n+{\n+  UNKNOWN,\n+  MACRO_RULES_DEFINITION,\n+  MACRO_INVOCATION,\n+};\n+\n+// Abstract base class for all AST elements\n+class Node\n+{\n+public:\n+  /**\n+   * Get the kind of Node this is. This is used to differentiate various AST\n+   * elements with very little overhead when extracting the derived type through\n+   * static casting is not necessary.\n+   */\n+  // FIXME: Mark this as `= 0` in the future to make sure every node implements\n+  // it\n+  virtual Kind get_ast_kind () const { return Kind::UNKNOWN; }\n+};\n+\n // Delimiter types - used in macros and whatever.\n enum DelimType\n {\n@@ -814,7 +836,7 @@ class MetaListNameValueStr;\n \n /* Base statement abstract class. Note that most \"statements\" are not allowed in\n  * top-level module scope - only a subclass of statements called \"items\" are. */\n-class Stmt\n+class Stmt : public Node\n {\n public:\n   // Unique pointer custom clone function\n@@ -880,7 +902,7 @@ class Item : public Stmt\n class ExprWithoutBlock;\n \n // Base expression AST node - abstract\n-class Expr\n+class Expr : public Node\n {\n public:\n   // Unique pointer custom clone function\n@@ -1053,7 +1075,7 @@ class Pattern\n class TraitBound;\n \n // Base class for types as represented in AST - abstract\n-class Type\n+class Type : public Node\n {\n public:\n   // Unique pointer custom clone function"}, {"sha": "1c5d1020b205b32629173b8e823b710dd5edcd23", "filename": "gcc/rust/ast/rust-macro.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e48bce446cc7ee4f1fb6980209720582def6e4e0/gcc%2Frust%2Fast%2Frust-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e48bce446cc7ee4f1fb6980209720582def6e4e0/gcc%2Frust%2Fast%2Frust-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-macro.h?ref=e48bce446cc7ee4f1fb6980209720582def6e4e0", "patch": "@@ -441,6 +441,8 @@ class MacroRulesDefinition : public MacroItem\n     is_builtin_rule = true;\n   }\n \n+  Kind get_ast_kind () const override { return Kind::MACRO_RULES_DEFINITION; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -505,6 +507,8 @@ class MacroInvocation : public TypeNoBounds,\n     return ExprWithoutBlock::get_node_id ();\n   }\n \n+  Kind get_ast_kind () const override { return Kind::MACRO_INVOCATION; }\n+\n   NodeId get_macro_node_id () const { return node_id; }\n \n   MacroInvocData &get_invoc_data () { return invoc_data; }"}, {"sha": "3389f20785035e77ec471794cb59fe7d2531ffd4", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e48bce446cc7ee4f1fb6980209720582def6e4e0/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e48bce446cc7ee4f1fb6980209720582def6e4e0/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=e48bce446cc7ee4f1fb6980209720582def6e4e0", "patch": "@@ -478,7 +478,7 @@ MacroExpander::match_fragment (Parser<MacroInvocLexer> &parser,\n       break;\n \n     case AST::MacroFragSpec::STMT:\n-      parser.parse_stmt ();\n+      parser.parse_stmt (/* allow_no_semi */ true);\n       break;\n \n     case AST::MacroFragSpec::LIFETIME:\n@@ -505,6 +505,9 @@ MacroExpander::match_fragment (Parser<MacroInvocLexer> &parser,\n       return false;\n     }\n \n+  for (const auto &error : parser.get_errors ())\n+    error.emit_error ();\n+\n   // it matches if the parser did not produce errors trying to parse that type\n   // of item\n   return !parser.has_errors ();\n@@ -824,7 +827,7 @@ transcribe_many_stmts (Parser<MacroInvocLexer> &parser, TokenId &delimiter)\n   // transcriber is an expression, but since the macro call is followed by\n   // a semicolon, it's a valid ExprStmt\n   return parse_many (parser, delimiter, [&parser] () {\n-    auto stmt = parser.parse_stmt ();\n+    auto stmt = parser.parse_stmt (/* allow_no_semi */ true);\n     return AST::SingleASTNode (std::move (stmt));\n   });\n }"}, {"sha": "bb2507039d1144f38803b52f7c97be38b19a1d87", "filename": "gcc/rust/hir/rust-ast-lower-expr.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e48bce446cc7ee4f1fb6980209720582def6e4e0/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e48bce446cc7ee4f1fb6980209720582def6e4e0/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h?ref=e48bce446cc7ee4f1fb6980209720582def6e4e0", "patch": "@@ -100,14 +100,6 @@ class ASTLoweringExpr : public ASTLoweringBase\n     return resolver.translated;\n   }\n \n-  void visit (AST::MacroInvocation &expr) override\n-  {\n-    rust_fatal_error (\n-      expr.get_locus (),\n-      \"macro expansion failed: No macro invocation should get lowered to HIR \"\n-      \"as they should disappear during expansion\");\n-  }\n-\n   void visit (AST::TupleIndexExpr &expr) override\n   {\n     HIR::Expr *tuple_expr"}, {"sha": "c9dfd1b65058c230e886d1dc9bc503af1b152479", "filename": "gcc/rust/hir/rust-ast-lower-implitem.h", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e48bce446cc7ee4f1fb6980209720582def6e4e0/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e48bce446cc7ee4f1fb6980209720582def6e4e0/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h?ref=e48bce446cc7ee4f1fb6980209720582def6e4e0", "patch": "@@ -52,14 +52,6 @@ class ASTLowerImplItem : public ASTLoweringBase\n     return resolver.translated;\n   }\n \n-  void visit (AST::MacroInvocation &invoc) override\n-  {\n-    rust_fatal_error (\n-      invoc.get_locus (),\n-      \"macro expansion failed: No macro invocation should get lowered to HIR \"\n-      \"as they should disappear during expansion\");\n-  }\n-\n   void visit (AST::TypeAlias &alias) override\n   {\n     std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n@@ -316,14 +308,6 @@ class ASTLowerTraitItem : public ASTLoweringBase\n     return resolver.translated;\n   }\n \n-  void visit (AST::MacroInvocation &invoc) override\n-  {\n-    rust_fatal_error (\n-      invoc.get_locus (),\n-      \"macro expansion failed: No macro invocation should get lowered to HIR \"\n-      \"as they should disappear during expansion\");\n-  }\n-\n   void visit (AST::TraitItemFunc &func) override\n   {\n     AST::TraitFunctionDecl &ref = func.get_trait_function_decl ();"}, {"sha": "376e6c2aabc15dfced3ce768eaafb104cf27e450", "filename": "gcc/rust/hir/rust-ast-lower-item.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e48bce446cc7ee4f1fb6980209720582def6e4e0/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e48bce446cc7ee4f1fb6980209720582def6e4e0/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h?ref=e48bce446cc7ee4f1fb6980209720582def6e4e0", "patch": "@@ -51,14 +51,6 @@ class ASTLoweringItem : public ASTLoweringBase\n     return resolver.translated;\n   }\n \n-  void visit (AST::MacroInvocation &invoc) override\n-  {\n-    rust_fatal_error (\n-      invoc.get_locus (),\n-      \"macro expansion failed: No macro invocation should get lowered to HIR \"\n-      \"as they should disappear during expansion\");\n-  }\n-\n   void visit (AST::Module &module) override\n   {\n     auto crate_num = mappings->get_current_crate ();"}, {"sha": "ede72bd71bff9edd1c0a5356a98b63a98a94605f", "filename": "gcc/rust/hir/rust-ast-lower-stmt.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e48bce446cc7ee4f1fb6980209720582def6e4e0/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e48bce446cc7ee4f1fb6980209720582def6e4e0/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h?ref=e48bce446cc7ee4f1fb6980209720582def6e4e0", "patch": "@@ -45,14 +45,6 @@ class ASTLoweringStmt : public ASTLoweringBase\n     return resolver.translated;\n   }\n \n-  void visit (AST::MacroInvocation &invoc) override\n-  {\n-    rust_fatal_error (\n-      invoc.get_locus (),\n-      \"macro expansion failed: No macro invocation should get lowered to HIR \"\n-      \"as they should disappear during expansion\");\n-  }\n-\n   void visit (AST::ExprStmtWithBlock &stmt) override\n   {\n     HIR::ExprWithBlock *expr"}, {"sha": "c373ae90a1523e5d74fd1ae54c3e4b46b56c48b2", "filename": "gcc/rust/hir/rust-ast-lower.cc", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e48bce446cc7ee4f1fb6980209720582def6e4e0/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e48bce446cc7ee4f1fb6980209720582def6e4e0/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower.cc?ref=e48bce446cc7ee4f1fb6980209720582def6e4e0", "patch": "@@ -67,6 +67,16 @@ ASTLoweringBlock::visit (AST::BlockExpr &expr)\n \n   for (auto &s : expr.get_statements ())\n     {\n+      if (s->get_ast_kind () == AST::Kind::MACRO_RULES_DEFINITION)\n+\tcontinue;\n+\n+      if (s->get_ast_kind () == AST::Kind::MACRO_INVOCATION)\n+\trust_fatal_error (\n+\t  s->get_locus (),\n+\t  \"macro invocations should not get lowered to HIR - At \"\n+\t  \"this point in \"\n+\t  \"the pipeline, they should all have been expanded\");\n+\n       if (block_did_terminate)\n \trust_warning_at (s->get_locus (), 0, \"unreachable statement\");\n "}, {"sha": "0bbd8fbf31b3cc5854b44fb1d42dcf904cf2f1e7", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 31, "deletions": 13, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e48bce446cc7ee4f1fb6980209720582def6e4e0/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e48bce446cc7ee4f1fb6980209720582def6e4e0/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=e48bce446cc7ee4f1fb6980209720582def6e4e0", "patch": "@@ -6034,9 +6034,10 @@ Parser<ManagedTokenSource>::parse_named_function_param (\n // Parses a statement (will further disambiguate any statement).\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::Stmt>\n-Parser<ManagedTokenSource>::parse_stmt ()\n+Parser<ManagedTokenSource>::parse_stmt (bool allow_no_semi)\n {\n   // quick exit for empty statement\n+  // FIXME: Can we have empty statements without semicolons? Just nothing?\n   const_TokenPtr t = lexer.peek_token ();\n   if (t->get_id () == SEMICOLON)\n     {\n@@ -6058,7 +6059,7 @@ Parser<ManagedTokenSource>::parse_stmt ()\n     {\n     case LET:\n       // let statement\n-      return parse_let_stmt (std::move (outer_attrs));\n+      return parse_let_stmt (std::move (outer_attrs), allow_no_semi);\n     case PUB:\n     case MOD:\n     case EXTERN_TOK:\n@@ -6113,15 +6114,16 @@ Parser<ManagedTokenSource>::parse_stmt ()\n       // TODO: find out how to disable gcc \"implicit fallthrough\" warning\n     default:\n       // fallback: expression statement\n-      return parse_expr_stmt (std::move (outer_attrs));\n+      return parse_expr_stmt (std::move (outer_attrs), allow_no_semi);\n       break;\n     }\n }\n \n // Parses a let statement.\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::LetStmt>\n-Parser<ManagedTokenSource>::parse_let_stmt (AST::AttrVec outer_attrs)\n+Parser<ManagedTokenSource>::parse_let_stmt (AST::AttrVec outer_attrs,\n+\t\t\t\t\t    bool allow_no_semi)\n {\n   Location locus = lexer.peek_token ()->get_locus ();\n   skip_token (LET);\n@@ -6176,12 +6178,12 @@ Parser<ManagedTokenSource>::parse_let_stmt (AST::AttrVec outer_attrs)\n \t}\n     }\n \n-  if (!skip_token (SEMICOLON))\n+  if (!maybe_skip_token (SEMICOLON) && !allow_no_semi)\n     {\n       // skip after somewhere\n       return nullptr;\n-      /* TODO: how wise is it to ditch a mostly-valid let statement just because\n-       * a semicolon is missing? */\n+      /* TODO: how wise is it to ditch a mostly-valid let statement just\n+       * because a semicolon is missing? */\n     }\n \n   return std::unique_ptr<AST::LetStmt> (\n@@ -7016,7 +7018,8 @@ Parser<ManagedTokenSource>::parse_method ()\n  * block statement). */\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::ExprStmt>\n-Parser<ManagedTokenSource>::parse_expr_stmt (AST::AttrVec outer_attrs)\n+Parser<ManagedTokenSource>::parse_expr_stmt (AST::AttrVec outer_attrs,\n+\t\t\t\t\t     bool allow_no_semi)\n {\n   /* potential thoughts - define new virtual method \"has_block()\" on expr. parse\n    * expr and then determine whether semicolon is needed as a result of this\n@@ -7055,7 +7058,8 @@ Parser<ManagedTokenSource>::parse_expr_stmt (AST::AttrVec outer_attrs)\n \t  }\n \telse\n \t  {\n-\t    return parse_expr_stmt_without_block (std::move (outer_attrs));\n+\t    return parse_expr_stmt_without_block (std::move (outer_attrs),\n+\t\t\t\t\t\t  allow_no_semi);\n \t  }\n       }\n       case UNSAFE: {\n@@ -7068,15 +7072,17 @@ Parser<ManagedTokenSource>::parse_expr_stmt (AST::AttrVec outer_attrs)\n \t  }\n \telse\n \t  {\n-\t    return parse_expr_stmt_without_block (std::move (outer_attrs));\n+\t    return parse_expr_stmt_without_block (std::move (outer_attrs),\n+\t\t\t\t\t\t  allow_no_semi);\n \t  }\n       }\n     default:\n       // not a parse expr with block, so must be expr without block\n       /* TODO: if possible, be more selective about possible expr without block\n        * initial tokens in order to prevent more syntactical errors at parse\n        * time. */\n-      return parse_expr_stmt_without_block (std::move (outer_attrs));\n+      return parse_expr_stmt_without_block (std::move (outer_attrs),\n+\t\t\t\t\t    allow_no_semi);\n     }\n }\n \n@@ -7192,7 +7198,7 @@ Parser<ManagedTokenSource>::parse_expr_stmt_with_block (\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::ExprStmtWithoutBlock>\n Parser<ManagedTokenSource>::parse_expr_stmt_without_block (\n-  AST::AttrVec outer_attrs)\n+  AST::AttrVec outer_attrs, bool allow_no_semi)\n {\n   /* TODO: maybe move more logic for expr without block in here for better error\n    * handling */\n@@ -7217,7 +7223,7 @@ Parser<ManagedTokenSource>::parse_expr_stmt_without_block (\n     }\n \n   // skip semicolon at end that is required\n-  if (!skip_token (SEMICOLON))\n+  if (!maybe_skip_token (SEMICOLON) && !allow_no_semi)\n     {\n       // skip somewhere?\n       return nullptr;\n@@ -12219,6 +12225,18 @@ Parser<ManagedTokenSource>::skip_token (TokenId token_id)\n   return expect_token (token_id) != const_TokenPtr ();\n }\n \n+/* Checks if current token has inputted id - skips it and returns true if so,\n+ * returns false otherwise without diagnosing an error */\n+template <typename ManagedTokenSource>\n+bool\n+Parser<ManagedTokenSource>::maybe_skip_token (TokenId token_id)\n+{\n+  if (lexer.peek_token ()->get_id () != token_id)\n+    return false;\n+  else\n+    return skip_token (token_id);\n+}\n+\n /* Checks the current token - if id is same as expected, skips and returns it,\n  * otherwise diagnoses error and returns null. */\n template <typename ManagedTokenSource>"}, {"sha": "5fcb3052156a212c7fc08d43e03c1a81d859c500", "filename": "gcc/rust/parse/rust-parse.h", "status": "modified", "additions": 47, "deletions": 4, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e48bce446cc7ee4f1fb6980209720582def6e4e0/gcc%2Frust%2Fparse%2Frust-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e48bce446cc7ee4f1fb6980209720582def6e4e0/gcc%2Frust%2Fparse%2Frust-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.h?ref=e48bce446cc7ee4f1fb6980209720582def6e4e0", "patch": "@@ -88,8 +88,25 @@ struct ParseRestrictions\n template <typename ManagedTokenSource> class Parser\n {\n public:\n+  /**\n+   * Consume a token, reporting an error if it isn't the next token\n+   *\n+   * @param t ID of the token to consume\n+   *\n+   * @return true if the token was next, false if it wasn't found\n+   */\n   bool skip_token (TokenId t);\n \n+  /**\n+   * Same as `skip_token` but allows for failure without necessarily reporting\n+   * an error\n+   *\n+   * @param t ID of the token to consume\n+   *\n+   * @return true if the token was next, false if it wasn't found\n+   */\n+  bool maybe_skip_token (TokenId t);\n+\n   std::unique_ptr<AST::Expr>\n   parse_expr (AST::AttrVec outer_attrs = AST::AttrVec (),\n \t      ParseRestrictions restrictions = ParseRestrictions ());\n@@ -103,7 +120,20 @@ template <typename ManagedTokenSource> class Parser\n \n   std::unique_ptr<AST::Item> parse_item (bool called_from_statement);\n   std::unique_ptr<AST::Pattern> parse_pattern ();\n-  std::unique_ptr<AST::Stmt> parse_stmt ();\n+\n+  /**\n+   * Parse a statement\n+   *\n+   * Statement : ';'\n+   *    | Item\n+   *    | LetStatement\n+   *    | ExpressionStatement\n+   *    | MacroInvocationSemi\n+   *\n+   * @param allow_no_semi Allow the parser to not parse a semicolon after\n+   * \t\tthe statement without erroring out\n+   */\n+  std::unique_ptr<AST::Stmt> parse_stmt (bool allow_no_semi = false);\n   std::unique_ptr<AST::Type> parse_type ();\n   AST::PathInExpression parse_path_in_expression ();\n   std::vector<std::unique_ptr<AST::LifetimeParam> > parse_lifetime_params ();\n@@ -575,12 +605,25 @@ template <typename ManagedTokenSource> class Parser\n   AST::MaybeNamedParam parse_maybe_named_param (AST::AttrVec outer_attrs);\n \n   // Statement-related\n-  std::unique_ptr<AST::LetStmt> parse_let_stmt (AST::AttrVec outer_attrs);\n-  std::unique_ptr<AST::ExprStmt> parse_expr_stmt (AST::AttrVec outer_attrs);\n+\n+  /**\n+   *Parse a let-statement\n+   * LetStatement :\n+   * \tOuterAttribute*\n+   * \t\t'let' PatternNoTopAlt ( ':' Type )? ('=' Expression )? ';'\n+   *\n+   * @param allow_no_semi Allow parsing a let-statement without expecting a\n+   * \t\tsemicolon to follow it\n+   */\n+  std::unique_ptr<AST::LetStmt> parse_let_stmt (AST::AttrVec outer_attrs,\n+\t\t\t\t\t\tbool allow_no_semi = false);\n+  std::unique_ptr<AST::ExprStmt> parse_expr_stmt (AST::AttrVec outer_attrs,\n+\t\t\t\t\t\t  bool allow_no_semi = false);\n   std::unique_ptr<AST::ExprStmtWithBlock>\n   parse_expr_stmt_with_block (AST::AttrVec outer_attrs);\n   std::unique_ptr<AST::ExprStmtWithoutBlock>\n-  parse_expr_stmt_without_block (AST::AttrVec outer_attrs);\n+  parse_expr_stmt_without_block (AST::AttrVec outer_attrs,\n+\t\t\t\t bool allow_no_semi = false);\n   ExprOrStmt parse_stmt_or_expr_without_block ();\n   ExprOrStmt parse_stmt_or_expr_with_block (AST::AttrVec outer_attrs);\n   ExprOrStmt parse_macro_invocation_maybe_semi (AST::AttrVec outer_attrs);"}, {"sha": "e5e56ed3f0369e2364c6d22e18e111a6f553ff14", "filename": "gcc/testsuite/rust/compile/macro16.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e48bce446cc7ee4f1fb6980209720582def6e4e0/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro16.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e48bce446cc7ee4f1fb6980209720582def6e4e0/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro16.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro16.rs?ref=e48bce446cc7ee4f1fb6980209720582def6e4e0", "patch": "@@ -0,0 +1,11 @@\n+fn main() {\n+    macro_rules! create_type {\n+        ($s:ident) => {\n+            struct $s(i32);\n+        };\n+    }\n+\n+    create_type!(Wrapper);\n+\n+    let _ = Wrapper(15);\n+}"}, {"sha": "c297107d6f3f2b792fc1db8670357efca30fbd5e", "filename": "gcc/testsuite/rust/compile/macro18.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e48bce446cc7ee4f1fb6980209720582def6e4e0/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro18.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e48bce446cc7ee4f1fb6980209720582def6e4e0/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro18.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro18.rs?ref=e48bce446cc7ee4f1fb6980209720582def6e4e0", "patch": "@@ -0,0 +1,14 @@\n+// { dg-additional-options \"-w\" }\n+\n+macro_rules! take_stmt {\n+    ($s:stmt) => {\n+        $s;\n+    };\n+}\n+\n+fn main() -> i32 {\n+    take_stmt!(let complete = 15;);\n+    take_stmt!(let lacking = 14);\n+\n+    0\n+}"}, {"sha": "1bf9a2bfa9d388eaedb4f3b597a9542216dd0b45", "filename": "gcc/testsuite/rust/compile/macro19.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e48bce446cc7ee4f1fb6980209720582def6e4e0/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro19.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e48bce446cc7ee4f1fb6980209720582def6e4e0/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro19.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro19.rs?ref=e48bce446cc7ee4f1fb6980209720582def6e4e0", "patch": "@@ -0,0 +1,19 @@\n+// { dg-additional-options \"-w\" }\n+\n+macro_rules! call_without_semi {\n+    () => {\n+        f()\n+    };\n+    (block) => {{\n+        f()\n+    }};\n+}\n+\n+fn f() {}\n+\n+fn main() -> i32 {\n+    call_without_semi!();\n+    call_without_semi!(block);\n+\n+    0\n+}"}, {"sha": "a06a093dc30b9e7f6255f205c44f69e48dd2e7bb", "filename": "gcc/testsuite/rust/compile/macro9.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e48bce446cc7ee4f1fb6980209720582def6e4e0/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro9.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e48bce446cc7ee4f1fb6980209720582def6e4e0/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro9.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro9.rs?ref=e48bce446cc7ee4f1fb6980209720582def6e4e0", "patch": "@@ -12,6 +12,7 @@ fn main() -> i32 {\n     let b = add!(15);\n     let b = add!(15 14); // { dg-error \"Failed to match any rule within macro\" }\n     let b = add!(15, 14,); // { dg-error \"Failed to match any rule within macro\" }\n+                           // { dg-error \"found unexpected token\" \"\" { target *-*-* } .-1 }\n \n     0\n }"}]}