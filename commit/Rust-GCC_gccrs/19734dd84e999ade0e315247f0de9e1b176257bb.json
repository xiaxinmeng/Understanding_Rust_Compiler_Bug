{"sha": "19734dd84e999ade0e315247f0de9e1b176257bb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTk3MzRkZDg0ZTk5OWFkZTBlMzE1MjQ3ZjBkZTllMWIxNzYyNTdiYg==", "commit": {"author": {"name": "Razya Ladelsky", "email": "razya@gcc.gnu.org", "date": "2005-08-01T07:47:25Z"}, "committer": {"name": "Razya Ladelsky", "email": "razya@gcc.gnu.org", "date": "2005-08-01T07:47:25Z"}, "message": "Interprocedural constant propagation.\n\nFrom-SVN: r102626", "tree": {"sha": "4da9fbc1ee7db5362ec4694645f81df848322798", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4da9fbc1ee7db5362ec4694645f81df848322798"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/19734dd84e999ade0e315247f0de9e1b176257bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19734dd84e999ade0e315247f0de9e1b176257bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19734dd84e999ade0e315247f0de9e1b176257bb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19734dd84e999ade0e315247f0de9e1b176257bb/comments", "author": null, "committer": null, "parents": [{"sha": "57fb53415ece9fc8ce86848b8ff566348d185d94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57fb53415ece9fc8ce86848b8ff566348d185d94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57fb53415ece9fc8ce86848b8ff566348d185d94"}], "stats": {"total": 374, "additions": 355, "deletions": 19}, "files": [{"sha": "38e18031fd394872e1df7233727b970d515123c6", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19734dd84e999ade0e315247f0de9e1b176257bb/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19734dd84e999ade0e315247f0de9e1b176257bb/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=19734dd84e999ade0e315247f0de9e1b176257bb", "patch": "@@ -42,6 +42,7 @@ DEFTIMEVAR (TV_DUMP                  , \"dump files\")\n \n DEFTIMEVAR (TV_CGRAPH                , \"callgraph construction\")\n DEFTIMEVAR (TV_CGRAPHOPT             , \"callgraph optimization\")\n+DEFTIMEVAR (TV_IPA_CONSTANT_PROP     , \"ipa cp\")\n DEFTIMEVAR (TV_IPA_REFERENCE         , \"ipa reference\")\n DEFTIMEVAR (TV_IPA_PURE_CONST        , \"ipa pure const\")\n DEFTIMEVAR (TV_IPA_TYPE_ESCAPE       , \"ipa type escape\")"}, {"sha": "9059b1a9a52c8c2dd83bcd57f116691d2b88a8f9", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 346, "deletions": 19, "changes": 365, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19734dd84e999ade0e315247f0de9e1b176257bb/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19734dd84e999ade0e315247f0de9e1b176257bb/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=19734dd84e999ade0e315247f0de9e1b176257bb", "patch": "@@ -49,7 +49,7 @@ Boston, MA 02110-1301, USA.  */\n #include \"except.h\"\n #include \"debug.h\"\n #include \"pointer-set.h\"\n-#include \"integrate.h\"\n+#include \"ipa-prop.h\"\n \n /* I'm not real happy about this, but we need to handle gimple and\n    non-gimple trees.  */\n@@ -127,12 +127,15 @@ typedef struct inline_data\n   bool cloning_p;\n   /* Similarly for saving function body.  */\n   bool saving_p;\n+  /* Versioning function is slightly different from inlining. */\n+  bool versioning_p;\n   /* Callgraph node of function we are inlining into.  */\n   struct cgraph_node *node;\n   /* Callgraph node of currently inlined function.  */\n   struct cgraph_node *current_node;\n   /* Current BLOCK.  */\n   tree block;\n+  varray_type ipa_info;\n   /* Exception region the inlined call lie in.  */\n   int eh_region;\n   /* Take region number in the function being copied, add this value and\n@@ -157,8 +160,8 @@ static void unsave_expr_1 (tree);\n static tree unsave_r (tree *, int *, void *);\n static void declare_inline_vars (tree, tree);\n static void remap_save_expr (tree *, void *, int *);\n-\n-static inline bool inlining_p (inline_data *id);\n+static bool replace_ref_tree (inline_data *, tree *);\n+static inline bool inlining_p (inline_data *);\n static void add_lexical_block (tree current_block, tree new_block);\n \n /* Insert a tree->tree mapping for ID.  Despite the name suggests\n@@ -198,8 +201,8 @@ remap_decl (tree decl, inline_data *id)\n     {\n       /* Make a copy of the variable or label.  */\n       tree t;\n-      t = copy_decl_for_inlining (decl, fn, id->caller);\n-\n+      t = copy_decl_for_dup (decl, fn, id->caller, id->versioning_p);\n+     \n       /* Remember it, so that if we encounter this local entity again\n \t we can reuse this copy.  Do this early because remap_type may\n \t need this decl for TYPE_STUB_DECL.  */\n@@ -607,7 +610,8 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n \t\t}\n \t    }\n \t}\n-      else if (TREE_CODE (*tp) == INDIRECT_REF)\n+      else if (TREE_CODE (*tp) == INDIRECT_REF\n+\t       && !id->versioning_p)\n \t{\n \t  /* Get rid of *& from inline substitutions that can happen when a\n \t     pointer argument is an ADDR_EXPR.  */\n@@ -639,8 +643,8 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n \n       /* Here is the \"usual case\".  Copy this tree node, and then\n \t tweak some special cases.  */\n-      copy_tree_r (tp, walk_subtrees, NULL);\n-\n+      copy_tree_r (tp, walk_subtrees, id->versioning_p ? data : NULL);\n+       \n       /* If EXPR has block defined, map it to newly constructed block.\n          When inlining we want EXPRs without block appear in the block\n \t of function call.  */\n@@ -749,10 +753,22 @@ copy_bb (inline_data *id, basic_block bb, int frequency_scale, int count_scale)\n \n \t\t  /* We're cloning or inlining this body; duplicate the\n \t\t     associate callgraph nodes.  */\n-\t\t  edge = cgraph_edge (id->current_node, orig_stmt);\n+\t\t  if (!id->versioning_p)\n+\t\t    {\n+\t\t      edge = cgraph_edge (id->current_node, orig_stmt);\n+\t\t      if (edge)\n+\t\t\tcgraph_clone_edge (edge, id->node, stmt,\n+\t\t\t\t\t   REG_BR_PROB_BASE, 1, true);\n+\t\t    }\n+\t\t}\n+\t      if (id->versioning_p)\n+\t\t{\n+\t\t  /* Update the call_expr on the edges from the new version\n+\t\t     to its callees. */\n+\t\t  struct cgraph_edge *edge;\n+\t\t  edge = cgraph_edge (id->node, orig_stmt);\n \t\t  if (edge)\n-\t\t    cgraph_clone_edge (edge, id->node, stmt,\n-\t\t\t\t       REG_BR_PROB_BASE, 1, true);\n+\t\t    edge->call_stmt = stmt;\n \t\t}\n \t    }\n \t  /* If you think we can abort here, you are wrong.\n@@ -921,7 +937,7 @@ copy_cfg_body (inline_data * id, gcov_type count, int frequency,\n      and label_to_block_maps.  Otherwise, we're duplicating a function\n      body for inlining; insert our new blocks and labels into the\n      existing varrays.  */\n-  saving_or_cloning = (id->saving_p || id->cloning_p);\n+  saving_or_cloning = (id->saving_p || id->cloning_p || id->versioning_p);\n   if (saving_or_cloning)\n     {\n       new_cfun =\n@@ -1061,7 +1077,7 @@ setup_one_parameter (inline_data *id, tree p, tree value, tree fn,\n   /* Make an equivalent VAR_DECL.  Note that we must NOT remap the type\n      here since the type of this decl must be visible to the calling\n      function.  */\n-  var = copy_decl_for_inlining (p, fn, id->caller);\n+  var = copy_decl_for_dup (p, fn, id->caller, /*versioning=*/false);\n \n   /* See if the frontend wants to pass this by invisible reference.  If\n      so, our new VAR_DECL will have REFERENCE_TYPE, and we need to\n@@ -1259,7 +1275,7 @@ declare_return_variable (inline_data *id, tree return_slot_addr,\n \n   gcc_assert (TREE_CODE (TYPE_SIZE_UNIT (callee_type)) == INTEGER_CST);\n \n-  var = copy_decl_for_inlining (result, callee, caller);\n+  var = copy_decl_for_dup (result, callee, caller, /*versioning=*/false);\n \n   DECL_SEEN_IN_BIND_EXPR_P (var) = 1;\n   DECL_STRUCT_FUNCTION (caller)->unexpanded_var_list\n@@ -2365,6 +2381,7 @@ tree\n copy_tree_r (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n {\n   enum tree_code code = TREE_CODE (*tp);\n+  inline_data *id = (inline_data *) data;\n \n   /* We make copies of most nodes.  */\n   if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (code))\n@@ -2377,6 +2394,11 @@ copy_tree_r (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n       tree chain = TREE_CHAIN (*tp);\n       tree new;\n \n+      if (id && id->versioning_p && replace_ref_tree (id, tp))\n+\t{\n+\t  *walk_subtrees = 0;\n+\t  return NULL_TREE;\n+\t}\n       /* Copy the node.  */\n       new = copy_node (*tp);\n \n@@ -2479,8 +2501,8 @@ mark_local_for_remap_r (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n \n       /* Copy the decl and remember the copy.  */\n       insert_decl_map (id, decl,\n-\t\t       copy_decl_for_inlining (decl, DECL_CONTEXT (decl),\n-\t\t\t\t\t       DECL_CONTEXT (decl)));\n+\t\t       copy_decl_for_dup (decl, DECL_CONTEXT (decl),\n+\t\t\t\t\t  DECL_CONTEXT (decl),  /*versioning=*/false));\n     }\n \n   return NULL_TREE;\n@@ -2614,9 +2636,314 @@ declare_inline_vars (tree block, tree vars)\n     BLOCK_VARS (block) = chainon (BLOCK_VARS (block), vars);\n }\n \n-/* Returns true if we're inlining.  */\n+\n+/* Copy NODE (which must be a DECL).  The DECL originally was in the FROM_FN,\n+   but now it will be in the TO_FN.  VERSIONING means that this function \n+   is used by the versioning utility (not inlining or cloning).  */\n+\n+tree\n+copy_decl_for_dup (tree decl, tree from_fn, tree to_fn, bool versioning)\n+{\n+  tree copy;\n+\n+  gcc_assert (DECL_P (decl));\n+  /* Copy the declaration.  */\n+  if (!versioning\n+      && (TREE_CODE (decl) == PARM_DECL\n+\t  || TREE_CODE (decl) == RESULT_DECL))\n+    {\n+      tree type = TREE_TYPE (decl);\n+\n+      /* For a parameter or result, we must make an equivalent VAR_DECL,\n+\t not a new PARM_DECL.  */\n+      copy = build_decl (VAR_DECL, DECL_NAME (decl), type);\n+      TREE_ADDRESSABLE (copy) = TREE_ADDRESSABLE (decl);\n+      TREE_READONLY (copy) = TREE_READONLY (decl);\n+      TREE_THIS_VOLATILE (copy) = TREE_THIS_VOLATILE (decl);\n+      DECL_COMPLEX_GIMPLE_REG_P (copy) = DECL_COMPLEX_GIMPLE_REG_P (decl);\n+    }\n+  else\n+    {\n+      copy = copy_node (decl);\n+      /* The COPY is not abstract; it will be generated in TO_FN.  */\n+      DECL_ABSTRACT (copy) = 0;\n+      lang_hooks.dup_lang_specific_decl (copy);\n+\n+      /* TREE_ADDRESSABLE isn't used to indicate that a label's\n+\t address has been taken; it's for internal bookkeeping in\n+\t expand_goto_internal.  */\n+      if (TREE_CODE (copy) == LABEL_DECL)\n+\t{\n+\t  TREE_ADDRESSABLE (copy) = 0;\n+\t  LABEL_DECL_UID (copy) = -1;\n+\t}\n+    }\n+\n+  /* Don't generate debug information for the copy if we wouldn't have\n+     generated it for the copy either.  */\n+  DECL_ARTIFICIAL (copy) = DECL_ARTIFICIAL (decl);\n+  DECL_IGNORED_P (copy) = DECL_IGNORED_P (decl);\n+\n+  /* Set the DECL_ABSTRACT_ORIGIN so the debugging routines know what\n+     declaration inspired this copy.  */ \n+  DECL_ABSTRACT_ORIGIN (copy) = DECL_ORIGIN (decl);\n+\n+  /* The new variable/label has no RTL, yet.  */\n+  if (!TREE_STATIC (copy) && !DECL_EXTERNAL (copy))\n+    SET_DECL_RTL (copy, NULL_RTX);\n+  \n+  /* These args would always appear unused, if not for this.  */\n+  TREE_USED (copy) = 1;\n+\n+  /* Set the context for the new declaration.  */\n+  if (!DECL_CONTEXT (decl))\n+    /* Globals stay global.  */\n+    ;\n+  else if (DECL_CONTEXT (decl) != from_fn)\n+    /* Things that weren't in the scope of the function we're inlining\n+       from aren't in the scope we're inlining to, either.  */\n+    ;\n+  else if (TREE_STATIC (decl))\n+    /* Function-scoped static variables should stay in the original\n+       function.  */\n+    ;\n+  else\n+    /* Ordinary automatic local variables are now in the scope of the\n+       new function.  */\n+    DECL_CONTEXT (copy) = to_fn;\n+\n+  return copy;\n+}\n+\n+/* Return a copy of the function's argument tree.  */\n+static tree\n+copy_arguments_for_versioning (tree orig_parm, inline_data * id)\n+{\n+  tree *arg_copy, *parg;\n+\n+  arg_copy = &orig_parm;\n+  for (parg = arg_copy; *parg; parg = &TREE_CHAIN (*parg))\n+    {\n+      tree new = remap_decl (*parg, id);\n+      lang_hooks.dup_lang_specific_decl (new);\n+      TREE_CHAIN (new) = TREE_CHAIN (*parg);\n+      *parg = new;\n+    }\n+  return orig_parm;\n+}\n+\n+/* Return a copy of the function's static chain.  */\n+static tree\n+copy_static_chain (tree static_chain, inline_data * id)\n+{\n+  tree *chain_copy, *pvar;\n+\n+  chain_copy = &static_chain;\n+  for (pvar = chain_copy; *pvar; pvar = &TREE_CHAIN (*pvar))\n+    {\n+      tree new = remap_decl (*pvar, id);\n+      lang_hooks.dup_lang_specific_decl (new);\n+      TREE_CHAIN (new) = TREE_CHAIN (*pvar);\n+      *pvar = new;\n+    }\n+  return static_chain;\n+}\n+\n+/* Return true if the function is allowed to be versioned.\n+   This is a guard for the versioning functionality.  */\n+bool\n+tree_versionable_function_p (tree fndecl)\n+{\n+  if (fndecl == NULL_TREE)\n+    return false;\n+  /* ??? There are cases where a function is\n+     uninlinable but can be versioned.  */\n+  if (!tree_inlinable_function_p (fndecl))\n+    return false;\n+  \n+  return true;\n+}\n+\n+/* Create a copy of a function's tree.\n+   OLD_DECL and NEW_DECL are FUNCTION_DECL tree nodes\n+   of the original function and the new copied function\n+   respectively.  In case we want to replace a DECL \n+   tree with another tree while duplicating the function's \n+   body, TREE_MAP represents the mapping between these \n+   trees.  */\n+void\n+tree_function_versioning (tree old_decl, tree new_decl, varray_type tree_map)\n+{\n+  struct cgraph_node *old_version_node;\n+  struct cgraph_node *new_version_node;\n+  inline_data id;\n+  tree p, new_fndecl;\n+  unsigned i;\n+  struct ipa_replace_map *replace_info;\n+  basic_block old_entry_block;\n+  tree t_step;\n+\n+  gcc_assert (TREE_CODE (old_decl) == FUNCTION_DECL\n+\t      && TREE_CODE (new_decl) == FUNCTION_DECL);\n+  DECL_POSSIBLY_INLINED (old_decl) = 1;\n+\n+  old_version_node = cgraph_node (old_decl);\n+  new_version_node = cgraph_node (new_decl);\n+\n+  allocate_struct_function (new_decl);\n+  /* Cfun points to the new allocated function struct at this point.  */\n+  cfun->function_end_locus = DECL_SOURCE_LOCATION (new_decl);\n+\n+  DECL_ARTIFICIAL (new_decl) = 1;\n+  DECL_ABSTRACT_ORIGIN (new_decl) = DECL_ORIGIN (old_decl);\n+\n+  /* Generate a new name for the new version. */\n+  DECL_NAME (new_decl) =\n+    create_tmp_var_name (NULL);\n+  /* Create a new SYMBOL_REF rtx for the new name. */\n+  if (DECL_RTL (old_decl) != NULL)\n+    {\n+      SET_DECL_RTL (new_decl, copy_rtx (DECL_RTL (old_decl)));\n+      XEXP (DECL_RTL (new_decl), 0) =\n+\tgen_rtx_SYMBOL_REF (GET_MODE (XEXP (DECL_RTL (old_decl), 0)),\n+\t\t\t    IDENTIFIER_POINTER (DECL_NAME (new_decl)));\n+    }\n+\n+  /* Prepare the data structures for the tree copy.  */\n+  memset (&id, 0, sizeof (id));\n+  \n+  /* The new version. */\n+  id.node = new_version_node;\n+  \n+  /* The old version. */\n+  id.current_node = cgraph_node (old_decl);\n+  \n+  id.versioning_p = true;\n+  id.decl_map = splay_tree_new (splay_tree_compare_pointers, NULL, NULL);\n+  id.caller = new_decl;\n+  id.callee = old_decl;\n+  id.callee_cfun = DECL_STRUCT_FUNCTION (old_decl);\n+  \n+  current_function_decl = new_decl;\n+  \n+  /* Copy the function's static chain.  */\n+  p = DECL_STRUCT_FUNCTION (old_decl)->static_chain_decl;\n+  if (p)\n+    DECL_STRUCT_FUNCTION (new_decl)->static_chain_decl =\n+      copy_static_chain (DECL_STRUCT_FUNCTION (old_decl)->static_chain_decl,\n+\t\t\t &id);\n+  /* Copy the function's arguments.  */\n+  if (DECL_ARGUMENTS (old_decl) != NULL_TREE)\n+    DECL_ARGUMENTS (new_decl) =\n+      copy_arguments_for_versioning (DECL_ARGUMENTS (old_decl), &id);\n+  \n+  /* If there's a tree_map, prepare for substitution.  */\n+  if (tree_map)\n+    for (i = 0; i < VARRAY_ACTIVE_SIZE (tree_map); i++)\n+      {\n+\treplace_info = VARRAY_GENERIC_PTR (tree_map, i);\n+\tif (replace_info->replace_p && !replace_info->ref_p)\n+\t  insert_decl_map (&id, replace_info->old_tree,\n+\t\t\t   replace_info->new_tree);\n+\telse if (replace_info->replace_p && replace_info->ref_p)\n+\t  id.ipa_info = tree_map;\n+      }\n+  \n+  DECL_INITIAL (new_decl) = remap_blocks (DECL_INITIAL (id.callee), &id);\n+  \n+  /* Renumber the lexical scoping (non-code) blocks consecutively.  */\n+  number_blocks (id.caller);\n+  \n+  if (DECL_STRUCT_FUNCTION (old_decl)->unexpanded_var_list != NULL_TREE)\n+    /* Add local vars.  */\n+    for (t_step = DECL_STRUCT_FUNCTION (old_decl)->unexpanded_var_list;\n+\t t_step; t_step = TREE_CHAIN (t_step))\n+      {\n+\ttree var = TREE_VALUE (t_step);\n+\tif (TREE_STATIC (var) && !TREE_ASM_WRITTEN (var))\n+\t  cfun->unexpanded_var_list = tree_cons (NULL_TREE, var,\n+\t\t\t\t\t\t cfun->unexpanded_var_list);\n+\telse\n+\t  cfun->unexpanded_var_list =\n+\t    tree_cons (NULL_TREE, remap_decl (var, &id),\n+\t\t       cfun->unexpanded_var_list);\n+      }\n+  \n+  /* Copy the Function's body.  */\n+  old_entry_block = ENTRY_BLOCK_PTR_FOR_FUNCTION\n+    (DECL_STRUCT_FUNCTION (old_decl));\n+  new_fndecl = copy_body (&id,\n+\t\t\t  old_entry_block->count,\n+\t\t\t  old_entry_block->frequency, NULL, NULL);\n+  \n+  DECL_SAVED_TREE (new_decl) = DECL_SAVED_TREE (new_fndecl);\n+\n+  DECL_STRUCT_FUNCTION (new_decl)->cfg =\n+    DECL_STRUCT_FUNCTION (new_fndecl)->cfg;\n+  DECL_STRUCT_FUNCTION (new_decl)->eh = DECL_STRUCT_FUNCTION (new_fndecl)->eh;\n+  DECL_STRUCT_FUNCTION (new_decl)->ib_boundaries_block =\n+    DECL_STRUCT_FUNCTION (new_fndecl)->ib_boundaries_block;\n+  DECL_STRUCT_FUNCTION (new_decl)->last_label_uid =\n+    DECL_STRUCT_FUNCTION (new_fndecl)->last_label_uid;\n+\n+  if (DECL_RESULT (old_decl) != NULL_TREE)\n+    {\n+      tree *res_decl = &DECL_RESULT (old_decl);\n+      DECL_RESULT (new_decl) = remap_decl (*res_decl, &id);\n+      lang_hooks.dup_lang_specific_decl (DECL_RESULT (new_decl));\n+    }\n+  \n+  current_function_decl = NULL;\n+  /* Renumber the lexical scoping (non-code) blocks consecutively.  */\n+  number_blocks (new_decl);\n+\n+  /* Clean up.  */\n+  splay_tree_delete (id.decl_map);\n+  fold_cond_expr_cond ();\n+  return;\n+}\n+\n+/*  Replace an INDIRECT_REF tree of a given DECL tree with a new \n+    given tree.\n+    ID->ipa_info keeps the old tree and the new tree.  \n+    TP points to the INDIRECT REF tree.  Return true if \n+    the trees were replaced.  */\n+static bool\n+replace_ref_tree (inline_data * id, tree * tp)\n+{\n+  bool replaced = false;\n+  tree new;\n+\n+  if (id->ipa_info && VARRAY_ACTIVE_SIZE (id->ipa_info) > 0)\n+    {\n+      unsigned i;\n+\n+      for (i = 0; i < VARRAY_ACTIVE_SIZE (id->ipa_info); i++)\n+\t{\n+\t  struct ipa_replace_map *replace_info;\n+\t  replace_info = VARRAY_GENERIC_PTR (id->ipa_info, i);\n+\n+\t  if (replace_info->replace_p && replace_info->ref_p)\n+\t    {\n+\t      tree old_tree = replace_info->old_tree;\n+\t      tree new_tree = replace_info->new_tree;\n+\n+\t      if (TREE_CODE (*tp) == INDIRECT_REF\n+\t\t  && TREE_OPERAND (*tp, 0) == old_tree)\n+\t\t{\n+\t\t  new = copy_node (new_tree);\n+\t\t  *tp = new;\n+\t\t  replaced = true;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  return replaced;\n+}\n+\n+/* Return true if we are inlining.  */\n static inline bool\n-inlining_p (inline_data *id)\n+inlining_p (inline_data * id)\n {\n-  return (!id->saving_p && !id->cloning_p);\n+  return (!id->saving_p && !id->cloning_p && !id->versioning_p);\n }"}, {"sha": "65ffed29b8d1eca9af678995c27a3f3e4328fc57", "filename": "gcc/tree-inline.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19734dd84e999ade0e315247f0de9e1b176257bb/gcc%2Ftree-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19734dd84e999ade0e315247f0de9e1b176257bb/gcc%2Ftree-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.h?ref=19734dd84e999ade0e315247f0de9e1b176257bb", "patch": "@@ -22,6 +22,7 @@ Boston, MA 02110-1301, USA.  */\n #ifndef GCC_TREE_INLINE_H\n #define GCC_TREE_INLINE_H\n \n+#include \"varray.h\"\n /* Function prototypes.  */\n \n void optimize_inline_calls (tree);\n@@ -33,6 +34,12 @@ int estimate_move_cost (tree type);\n void push_cfun (struct function *new_cfun);\n void pop_cfun (void);\n int estimate_num_insns (tree expr);\n+bool tree_versionable_function_p (tree);\n+void tree_function_versioning (tree, tree, varray_type);\n+\n+/* Copy a declaration when one function is substituted inline into\n+   another.  It is used also for versioning.  */\n+extern tree copy_decl_for_dup (tree, tree, tree, bool);\n \n /* 0 if we should not perform inlining.\n    1 if we should expand functions calls inline at the tree level."}, {"sha": "36b122c612793f731b9f2d6ffca4833a136d01e6", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19734dd84e999ade0e315247f0de9e1b176257bb/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19734dd84e999ade0e315247f0de9e1b176257bb/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=19734dd84e999ade0e315247f0de9e1b176257bb", "patch": "@@ -284,6 +284,7 @@ extern struct tree_opt_pass pass_rebuild_cgraph_edges;\n extern struct tree_opt_pass pass_eliminate_useless_stores;\n \n /* IPA Passes */\n+extern struct tree_opt_pass pass_ipa_cp;\n extern struct tree_opt_pass pass_ipa_inline;\n extern struct tree_opt_pass pass_early_ipa_inline;\n extern struct tree_opt_pass pass_ipa_reference;"}]}