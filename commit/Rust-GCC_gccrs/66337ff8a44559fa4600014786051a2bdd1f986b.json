{"sha": "66337ff8a44559fa4600014786051a2bdd1f986b", "node_id": "C_kwDOANBUbNoAKDY2MzM3ZmY4YTQ0NTU5ZmE0NjAwMDE0Nzg2MDUxYTJiZGQxZjk4NmI", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2023-02-02T20:07:08Z"}, "committer": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2023-02-02T20:07:08Z"}, "message": "c: Update checks on constexpr floating-point initializers\n\nWG14 has agreed some changes (detailed at the end of N3082) to the\nrules on constexpr initializers for floating types.  Update GCC's\nimplementation to match: binary initializers are now allowed for\ndecimal types, and real initializers for complex types, but signaling\nNaN initializers can't be used for a different type with the same\nmode.\n\nThere are also changes to the constexpr rules for pointer types\n(allowing null pointer address constants that aren't null pointer\nconstants), which I'll deal with separately.\n\nBootstrapped with no regressions for x86_64-pc-linux-gnu.\n\ngcc/c/\n\t* c-typeck.cc: Include \"realmpfr.h\".\n\t(constexpr_init_fits_real_type): Do not allow signaling NaN\n\tconversions to different types with the same mode.  Handle\n\tconversions from binary to decimal types.\n\t(check_constexpr_init): Do not disallow real initializers for\n\tcomplex types.  Do not disallow binary initializers for decimal\n\tfloating types.\n\ngcc/testsuite/\n\t* gcc.dg/c2x-constexpr-1.c: Test constexpr initializers of complex\n\ttypes with real initializers are allowed.\n\t* gcc.dg/c2x-constexpr-3.c: Do not test for constexpr initializers\n\tof complex types with real initializers being disallowed.\n\t* gcc.dg/c2x-constexpr-8.c: Add tests of signaling NaN complex\n\tinitializers.\n\t* gcc.dg/c2x-constexpr-9.c: Add more tests.\n\t* gcc.dg/dfp/c2x-constexpr-dfp-1.c: Add tests of binary floating\n\tinitializers for decimal types.\n\t* gcc.dg/dfp/c2x-constexpr-dfp-2.c: Change tests of binary\n\tinitializers for decimal types.  Add more tests of decimal\n\tinitializers for binary types.", "tree": {"sha": "62e2cf7940c5b27d54abdf792979a2bdd2b5d1d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62e2cf7940c5b27d54abdf792979a2bdd2b5d1d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/66337ff8a44559fa4600014786051a2bdd1f986b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66337ff8a44559fa4600014786051a2bdd1f986b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66337ff8a44559fa4600014786051a2bdd1f986b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66337ff8a44559fa4600014786051a2bdd1f986b/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c43f06c228d169c370e99fa009154344fa305b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c43f06c228d169c370e99fa009154344fa305b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c43f06c228d169c370e99fa009154344fa305b8"}], "stats": {"total": 150, "additions": 98, "deletions": 52}, "files": [{"sha": "9d65130154da41a89d8e1dc2d199473883681b9a", "filename": "gcc/c/c-typeck.cc", "status": "modified", "additions": 68, "deletions": 43, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66337ff8a44559fa4600014786051a2bdd1f986b/gcc%2Fc%2Fc-typeck.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66337ff8a44559fa4600014786051a2bdd1f986b/gcc%2Fc%2Fc-typeck.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.cc?ref=66337ff8a44559fa4600014786051a2bdd1f986b", "patch": "@@ -52,6 +52,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stringpool.h\"\n #include \"attribs.h\"\n #include \"asan.h\"\n+#include \"realmpfr.h\"\n \n /* Possible cases of implicit conversions.  Used to select diagnostic messages\n    and control folding initializers in convert_for_assignment.  */\n@@ -8121,17 +8122,26 @@ print_spelling (char *buffer)\n }\n \n /* Check whether INIT, a floating or integer constant, is\n-   representable in TYPE, a real floating type with the same radix.\n-   Return true if OK, false if not.  */\n+   representable in TYPE, a real floating type with the same radix or\n+   a decimal floating type initialized with a binary floating\n+   constant.  Return true if OK, false if not.  */\n static bool\n constexpr_init_fits_real_type (tree type, tree init)\n {\n   gcc_assert (TREE_CODE (type) == REAL_TYPE);\n   gcc_assert (TREE_CODE (init) == INTEGER_CST || TREE_CODE (init) == REAL_CST);\n   if (TREE_CODE (init) == REAL_CST\n       && TYPE_MODE (TREE_TYPE (init)) == TYPE_MODE (type))\n-    /* Same mode, no conversion required.  */\n-    return true;\n+    {\n+      /* Same mode, no conversion required except for the case of\n+\t signaling NaNs if the types are incompatible (e.g. double and\n+\t long double with the same mode).  */\n+      if (REAL_VALUE_ISSIGNALING_NAN (TREE_REAL_CST (init))\n+\t  && !comptypes (TYPE_MAIN_VARIANT (type),\n+\t\t\t TYPE_MAIN_VARIANT (TREE_TYPE (init))))\n+\treturn false;\n+      return true;\n+    }\n   if (TREE_CODE (init) == INTEGER_CST)\n     {\n       tree converted = build_real_from_int_cst (type, init);\n@@ -8140,6 +8150,33 @@ constexpr_init_fits_real_type (tree type, tree init)\n \t\t\t\t    TYPE_PRECISION (TREE_TYPE (init)));\n       return !fail && wi::eq_p (w, wi::to_wide (init));\n     }\n+  if (REAL_VALUE_ISSIGNALING_NAN (TREE_REAL_CST (init)))\n+    return false;\n+  if ((REAL_VALUE_ISINF (TREE_REAL_CST (init))\n+       && MODE_HAS_INFINITIES (TYPE_MODE (type)))\n+      || (REAL_VALUE_ISNAN (TREE_REAL_CST (init))\n+\t  && MODE_HAS_NANS (TYPE_MODE (type))))\n+    return true;\n+  if (DECIMAL_FLOAT_TYPE_P (type)\n+      && !DECIMAL_FLOAT_TYPE_P (TREE_TYPE (init)))\n+    {\n+      /* This is valid if the real number represented by the\n+\t initializer can be exactly represented in the decimal\n+\t type.  Compare the values using MPFR.  */\n+      REAL_VALUE_TYPE t;\n+      real_convert (&t, TYPE_MODE (type), &TREE_REAL_CST (init));\n+      mpfr_t bin_val, dec_val;\n+      mpfr_init2 (bin_val, REAL_MODE_FORMAT (TYPE_MODE (TREE_TYPE (init)))->p);\n+      mpfr_init2 (dec_val, REAL_MODE_FORMAT (TYPE_MODE (TREE_TYPE (init)))->p);\n+      mpfr_from_real (bin_val, &TREE_REAL_CST (init), MPFR_RNDN);\n+      char string[256];\n+      real_to_decimal (string, &t, sizeof string, 0, 1);\n+      bool res = (mpfr_strtofr (dec_val, string, NULL, 10, MPFR_RNDN) == 0\n+\t\t  && mpfr_equal_p (bin_val, dec_val));\n+      mpfr_clear (bin_val);\n+      mpfr_clear (dec_val);\n+      return res;\n+    }\n   /* exact_real_truncate is not quite right here, since it doesn't\n      allow even an exact conversion to subnormal values.  */\n   REAL_VALUE_TYPE t;\n@@ -8194,58 +8231,46 @@ check_constexpr_init (location_t loc, tree type, tree init,\n   if (TREE_CODE (type) == COMPLEX_TYPE\n       && TREE_CODE (TREE_TYPE (type)) != REAL_TYPE)\n     return;\n-  /* Both the normative text and the relevant footnote are unclear, as\n-     of the C2x CD, about what exactly counts as a change of value in\n-     floating-point cases.  Here, we consider all conversions between\n-     binary and decimal types (even of infinities and NaNs, where\n-     quantum exponents are not involved) as involving a change of\n-     value, and likewise for conversions between real and complex\n-     types (even when the complex constant has imaginary part positive\n-     zero), and conversions of signaling NaN to a different machine\n-     mode.  But we allow exact conversions of integers to binary or\n-     decimal floating types, and exact conversions between different\n-     binary types or different decimal types, where \"exact\" in the\n-     decimal case requires the quantum exponent to be preserved.  */\n+  /* Following N3082, a real type cannot be initialized from a complex\n+     type and a binary type cannot be initialized from a decimal type\n+     (but initializing a decimal type from a binary type is OK).\n+     Signaling NaN initializers are OK only if the types are\n+     compatible (not just the same mode); all quiet NaN and infinity\n+     initializations are considered to preserve the value.  */\n   if (TREE_CODE (TREE_TYPE (init)) == COMPLEX_TYPE\n       && TREE_CODE (type) == REAL_TYPE)\n     {\n       error_at (loc, \"%<constexpr%> initializer for a real type is of \"\n \t\t\"complex type\");\n       return;\n     }\n-  if (TREE_CODE (type) == COMPLEX_TYPE\n-      && TREE_CODE (TREE_TYPE (init)) != COMPLEX_TYPE)\n-    {\n-      error_at (loc, \"%<constexpr%> initializer for a complex type is of \"\n-\t\t\"real type\");\n-      return;\n-    }\n   if (TREE_CODE (type) == REAL_TYPE\n-      && TREE_CODE (TREE_TYPE (init)) == REAL_TYPE)\n+      && TREE_CODE (TREE_TYPE (init)) == REAL_TYPE\n+      && DECIMAL_FLOAT_TYPE_P (TREE_TYPE (init))\n+      && !DECIMAL_FLOAT_TYPE_P (type))\n     {\n-      if (DECIMAL_FLOAT_TYPE_P (type)\n-\t  && !DECIMAL_FLOAT_TYPE_P (TREE_TYPE (init)))\n-\t{\n-\t  error_at (loc, \"%<constexpr%> initializer for a decimal \"\n-\t\t    \"floating-point type is of binary type\");\n-\t  return;\n-\t}\n-      else if (DECIMAL_FLOAT_TYPE_P (TREE_TYPE (init))\n-\t       && !DECIMAL_FLOAT_TYPE_P (type))\n-\t{\n-\t  error_at (loc, \"%<constexpr%> initializer for a binary \"\n-\t\t    \"floating-point type is of decimal type\");\n-\t  return;\n-\t}\n+      error_at (loc, \"%<constexpr%> initializer for a binary \"\n+\t\t\"floating-point type is of decimal type\");\n+      return;\n     }\n   bool fits;\n   if (TREE_CODE (type) == COMPLEX_TYPE)\n     {\n-      gcc_assert (TREE_CODE (init) == COMPLEX_CST);\n-      fits = (constexpr_init_fits_real_type (TREE_TYPE (type),\n-\t\t\t\t\t     TREE_REALPART (init))\n-\t      && constexpr_init_fits_real_type (TREE_TYPE (type),\n-\t\t\t\t\t\tTREE_IMAGPART (init)));\n+      switch (TREE_CODE (init))\n+\t{\n+\tcase INTEGER_CST:\n+\tcase REAL_CST:\n+\t  fits = constexpr_init_fits_real_type (TREE_TYPE (type), init);\n+\t  break;\n+\tcase COMPLEX_CST:\n+\t  fits = (constexpr_init_fits_real_type (TREE_TYPE (type),\n+\t\t\t\t\t\t TREE_REALPART (init))\n+\t\t  && constexpr_init_fits_real_type (TREE_TYPE (type),\n+\t\t\t\t\t\t    TREE_IMAGPART (init)));\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n     }\n   else\n     fits = constexpr_init_fits_real_type (type, init);"}, {"sha": "97b54f17428f267e2c5bcb6e83f5da294a361fd8", "filename": "gcc/testsuite/gcc.dg/c2x-constexpr-1.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66337ff8a44559fa4600014786051a2bdd1f986b/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-constexpr-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66337ff8a44559fa4600014786051a2bdd1f986b/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-constexpr-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-constexpr-1.c?ref=66337ff8a44559fa4600014786051a2bdd1f986b", "patch": "@@ -174,6 +174,8 @@ constexpr int v94 = alignof (int);\n alignas (v94) int v95;\n constexpr int v97[100] = { [v82.x.f] = 7 };\n static int v98[v94];\n+constexpr _Complex double v99 = 1.0;\n+constexpr _Complex float v100 = 12345;\n \n void\n f0 ()\n@@ -247,6 +249,8 @@ f0 ()\n   (constexpr union u58) { 0 };\n   (constexpr union u58) { { } }; /* { dg-warning \"braces around scalar initializer\" } */\n   (constexpr union u58) { { 0 } }; /* { dg-warning \"braces around scalar initializer\" } */\n+  (constexpr _Complex double) { 1.0 };\n+  (constexpr _Complex float) { 12345 };\n   /* It's not entirely clear if constexpr declarations are allowed in this\n      position in a for loop; presume they are, as implicitly auto just as if no\n      storage class specifiers were used.  */"}, {"sha": "4f6b8ed67794a963a34dc19a0c9e4f6d26bf9d2e", "filename": "gcc/testsuite/gcc.dg/c2x-constexpr-3.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66337ff8a44559fa4600014786051a2bdd1f986b/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-constexpr-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66337ff8a44559fa4600014786051a2bdd1f986b/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-constexpr-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-constexpr-3.c?ref=66337ff8a44559fa4600014786051a2bdd1f986b", "patch": "@@ -112,13 +112,9 @@ constexpr int v95 = (unsigned int) -1; /* { dg-error \"'constexpr' initializer no\n constexpr unsigned char v96 = -1; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n constexpr signed char v97 = 1234567LL; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n /* { dg-warning \"overflow in conversion\" \"overflow warning\" { target *-*-* } .-1 } */\n-/* Disallow all real/complex conversions (the C2x CD is unclear about\n-   real-to-complex and about complex-to-real with imaginary part positive 0, if\n-   the real parts can be exactly represented in the relevant types).  */\n constexpr double v98 = __builtin_complex (1.0, 0.0); /* { dg-error \"'constexpr' initializer for a real type is of complex type\" } */\n constexpr double v99 = __builtin_complex (1.0, 1.0); /* { dg-error \"'constexpr' initializer for a real type is of complex type\" } */\n constexpr double v100 = __builtin_complex (1.0, -0.0); /* { dg-error \"'constexpr' initializer for a real type is of complex type\" } */\n-constexpr _Complex double v101 = 1.0; /* { dg-error \"'constexpr' initializer for a complex type is of real type\" } */\n constexpr float v102 = (unsigned long long) -1; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n constexpr double v103 = (unsigned long long) -1; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n constexpr float v104 = __LONG_LONG_MAX__; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n@@ -216,7 +212,6 @@ f0 ()\n   (constexpr double) { __builtin_complex (1.0, 0.0) }; /* { dg-error \"'constexpr' initializer for a real type is of complex type\" } */\n   (constexpr double) { __builtin_complex (1.0, 1.0) }; /* { dg-error \"'constexpr' initializer for a real type is of complex type\" } */\n   (constexpr double) { __builtin_complex (1.0, -0.0) }; /* { dg-error \"'constexpr' initializer for a real type is of complex type\" } */\n-  (constexpr _Complex double) { 1.0 }; /* { dg-error \"'constexpr' initializer for a complex type is of real type\" } */\n   (constexpr float) { (unsigned long long) -1 }; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n   (constexpr double) { (unsigned long long) -1 }; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n   (constexpr float) { __LONG_LONG_MAX__ }; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */"}, {"sha": "11372cf1d5aad3ddbb4cd9c7c4c7ad71978031d9", "filename": "gcc/testsuite/gcc.dg/c2x-constexpr-8.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66337ff8a44559fa4600014786051a2bdd1f986b/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-constexpr-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66337ff8a44559fa4600014786051a2bdd1f986b/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-constexpr-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-constexpr-8.c?ref=66337ff8a44559fa4600014786051a2bdd1f986b", "patch": "@@ -10,6 +10,7 @@ constexpr float fn = __builtin_nan (\"\");\n constexpr double dn = __builtin_nanf (\"\");\n constexpr float fns = __builtin_nansf (\"\");\n constexpr double dns = __builtin_nans (\"\");\n+constexpr _Complex double cdns = __builtin_nans (\"\");\n \n void\n f0 (void)\n@@ -20,4 +21,5 @@ f0 (void)\n   (constexpr double) { __builtin_nanf (\"\") };\n   (constexpr float) { __builtin_nansf (\"\") };\n   (constexpr double) { __builtin_nans (\"\") };\n+  (constexpr _Complex double) { __builtin_nans (\"\") };\n }"}, {"sha": "8a07ed5b3833793383620cba0e4d428f58c0397a", "filename": "gcc/testsuite/gcc.dg/c2x-constexpr-9.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66337ff8a44559fa4600014786051a2bdd1f986b/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-constexpr-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66337ff8a44559fa4600014786051a2bdd1f986b/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-constexpr-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-constexpr-9.c?ref=66337ff8a44559fa4600014786051a2bdd1f986b", "patch": "@@ -4,10 +4,11 @@\n /* { dg-add-options ieee } */\n /* { dg-require-effective-target inff } */\n \n-/* A conversion from signaling NaN to quiet NaN in a different format is not\n-   valid for constexpr.  */\n+/* A conversion from signaling NaN to quiet NaN in a different format or type\n+   is not valid for constexpr.  */\n constexpr float fns = __builtin_nans (\"\"); /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n constexpr double dns = __builtin_nansf (\"\"); /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+constexpr long double ldns = __builtin_nans (\"\"); /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n \n /* Test out-of-range values.  */\n constexpr float fu = __DBL_MIN__; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n@@ -22,6 +23,9 @@ constexpr _Complex float cfui = __builtin_complex (0.0, __DBL_MIN__); /* { dg-er\n constexpr _Complex float cfoi = __builtin_complex (0.0, __DBL_MAX__); /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n constexpr _Complex float cfpi = __builtin_complex (0.0, 0x1.ffffffp0); /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n \n+constexpr _Complex float cfd = __DBL_MAX__; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+constexpr _Complex float cfi = __LONG_LONG_MAX__; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+\n void\n f0 ()\n {\n@@ -36,4 +40,6 @@ f0 ()\n   (constexpr _Complex float) { __builtin_complex (0.0, __DBL_MIN__) }; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n   (constexpr _Complex float) { __builtin_complex (0.0, __DBL_MAX__) }; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n   (constexpr _Complex float) { __builtin_complex (0.0, 0x1.ffffffp0) }; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+  (constexpr _Complex float) { __DBL_MAX__ }; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+  (constexpr _Complex float) { __LONG_LONG_MAX__ }; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n }"}, {"sha": "4ac6629ff5af782bd6125f20250291b378f14abc", "filename": "gcc/testsuite/gcc.dg/dfp/c2x-constexpr-dfp-1.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66337ff8a44559fa4600014786051a2bdd1f986b/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fc2x-constexpr-dfp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66337ff8a44559fa4600014786051a2bdd1f986b/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fc2x-constexpr-dfp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fc2x-constexpr-dfp-1.c?ref=66337ff8a44559fa4600014786051a2bdd1f986b", "patch": "@@ -37,6 +37,11 @@ constexpr _Decimal128 v32 = __builtin_nansd128 (\"\");\n constexpr _Decimal32 v33 = {};\n constexpr _Decimal64 v34 = {};\n constexpr _Decimal128 v35 = {};\n+constexpr _Decimal32 v36 = 0.0;\n+constexpr _Decimal32 v37 = 0.0009765625;\n+constexpr _Decimal64 v38 = 6.103515625e-05;\n+constexpr _Decimal32 v39 = __builtin_inf ();\n+constexpr _Decimal32 v40 = __builtin_nan (\"\");\n \n void\n f0 ()\n@@ -76,4 +81,9 @@ f0 ()\n   (constexpr _Decimal32) {};\n   (constexpr _Decimal64) {};\n   (constexpr _Decimal128) {};\n+  (constexpr _Decimal32) { 0.0 };\n+  (constexpr _Decimal32) { 0.0009765625 };\n+  (constexpr _Decimal64) { 6.103515625e-05 };\n+  (constexpr _Decimal32) { __builtin_inf () };\n+  (constexpr _Decimal32) { __builtin_nan (\"\") };\n }"}, {"sha": "8ce0d088ac3d75b7709e2bf993f5086a04413104", "filename": "gcc/testsuite/gcc.dg/dfp/c2x-constexpr-dfp-2.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66337ff8a44559fa4600014786051a2bdd1f986b/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fc2x-constexpr-dfp-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66337ff8a44559fa4600014786051a2bdd1f986b/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fc2x-constexpr-dfp-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fc2x-constexpr-dfp-2.c?ref=66337ff8a44559fa4600014786051a2bdd1f986b", "patch": "@@ -3,8 +3,10 @@\n /* { dg-options \"-std=c2x -pedantic-errors\" } */\n \n /* Test conversions between binary and decimal.  */\n-constexpr _Decimal32 v1 = 0.0; /* { dg-error \"'constexpr' initializer for a decimal floating-point type is of binary type\" } */\n constexpr double v2 = 0.0DF; /* { dg-error \"'constexpr' initializer for a binary floating-point type is of decimal type\" } */\n+constexpr double v2i = __builtin_infd32 (); /* { dg-error \"'constexpr' initializer for a binary floating-point type is of decimal type\" } */\n+constexpr double v2n = __builtin_nand32 (\"\"); /* { dg-error \"'constexpr' initializer for a binary floating-point type is of decimal type\" } */\n+constexpr _Decimal128 v2d = 0x1p-100f; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n \n /* A conversion from signaling NaN to quiet NaN in a different format is not\n    valid for constexpr.  */\n@@ -30,8 +32,10 @@ constexpr _Decimal32 v15 = 0e200DL; /* { dg-error \"'constexpr' initializer not r\n void\n f0 ()\n {\n-  (constexpr _Decimal32) { 0.0 }; /* { dg-error \"'constexpr' initializer for a decimal floating-point type is of binary type\" } */\n   (constexpr double) { 0.0DF }; /* { dg-error \"'constexpr' initializer for a binary floating-point type is of decimal type\" } */\n+  (constexpr double) { __builtin_infd32 () }; /* { dg-error \"'constexpr' initializer for a binary floating-point type is of decimal type\" } */\n+  (constexpr double) { __builtin_nand32 (\"\") }; /* { dg-error \"'constexpr' initializer for a binary floating-point type is of decimal type\" } */\n+  (constexpr _Decimal128) { 0x1p-100f }; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n   (constexpr _Decimal32) { __builtin_nansd64 (\"\") }; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n   (constexpr _Decimal32) { __builtin_nansd128 (\"\") }; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n   (constexpr _Decimal64) { __builtin_nansd32 (\"\") }; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */"}]}