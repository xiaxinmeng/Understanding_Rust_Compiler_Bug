{"sha": "b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjJkYWQwZTM3MjdjYWRjYTc4ZDRjMmNjNTE1OTZkMWVmMWJmMDk0Ng==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2000-04-21T20:33:34Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2000-04-21T20:33:34Z"}, "message": "libstdc++-v3: New directory.\n\n\n\n2000-04-21  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* libstdc++-v3: New directory.\n\nFrom-SVN: r33317", "tree": {"sha": "e72cc26bb321e8bf90f4e68330674848db54eddf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e72cc26bb321e8bf90f4e68330674848db54eddf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/comments", "author": null, "committer": null, "parents": [{"sha": "051d082b263958a8524d91066f5c481b9e048bfd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/051d082b263958a8524d91066f5c481b9e048bfd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/051d082b263958a8524d91066f5c481b9e048bfd"}], "stats": {"total": 109648, "additions": 109648, "deletions": 0}, "files": [{"sha": "104f41261fd71eaec84f34af0ce512c3eead192a", "filename": "libstdc++-v3/ChangeLog", "status": "added", "additions": 5936, "deletions": 0, "changes": 5936, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "674782b149ce0029d79fd9f21c3ce3418d347d6f", "filename": "libstdc++-v3/Makefile.am", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FMakefile.am?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,147 @@\n+## Makefile for the toplevel directory of the GNU C++ Standard library.\n+##\n+## Copyright (C) 1997,1998, 1999, 2000 Free Software Foundation, Inc.\n+##\n+## This file is part of the libstdc++ version 3 distribution.\n+## Process this file with automake to produce Makefile.in.\n+\n+## This file is part of the GNU ISO C++ Library.  This library is free\n+## software; you can redistribute it and/or modify it under the\n+## terms of the GNU General Public License as published by the\n+## Free Software Foundation; either version 2, or (at your option)\n+## any later version.\n+\n+## This library is distributed in the hope that it will be useful,\n+## but WITHOUT ANY WARRANTY; without even the implied warranty of\n+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+## GNU General Public License for more details.\n+\n+## You should have received a copy of the GNU General Public License along\n+## with this library; see the file COPYING.  If not, write to the Free\n+## Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+## USA.\n+\n+AUTOMAKE_OPTIONS = 1.3 cygnus\n+MAINT_CHARSET = latin1\n+\n+# This helps subvert libstdcxx_interface, as calculated by devo/config.if\n+# Needed so that g++ can find the correct include subdir automatically.\n+INTERFACE = v3\n+gxx_include_dir=$(includedir)/g++\n+\n+SUBDIRS = math libio src\n+\n+check:  $(top_builddir)/mkcheck\n+\t$(top_builddir)/mkcheck 0 $(top_builddir) $(top_srcdir)\n+\n+check-install: $(top_builddir)/mkcheck\n+\t$(top_builddir)/mkcheck 1 $(top_builddir) $(top_srcdir) $(prefix)\n+\n+#all-local:  stamp-rebuild\n+\n+# This has already been sanity-checked by configure to a certain extent\n+#stamp-rebuild:  $(top_builddir)/config.status\n+#\tif test \"$(GCC_OBJDIR)\" != \"no\"; then \\\n+#\t(cd \"$(GCC_OBJDIR)/gcc\" && \\\n+#\t if test -f libgcc2.ready ; then \\\n+#\t   rm -f libgcc2.ready libgcc.a libgcc2.a ; \\\n+#\t   $(MAKE) libgcc2.a TARGET_LIBGCC2_CFLAGS='@NAMESPACES@' ; \\\n+#\t   $(MAKE) libgcc.a ; \\\n+#\t else \\\n+#\t   echo '** There does not appear to be a previously-built' ; \\\n+#\t   echo '** library here.  Please see' ; \\\n+#\t   echo '** <http://sourceware.cygnus.com/libstdc++/install.html>' ; \\\n+#\t   echo '** In particular, the \"Building and Installing' ; \\\n+#\t   echo '** the library (without GCC sources)\" section.' ; \\\n+#\t   exit 1 ; \\\n+#\t fi \\\n+#\t) \\\n+#\tfi\n+#\ttouch stamp-rebuild\n+\n+# Multilib support.\n+MAKEOVERRIDES=\n+\n+# Multilib variables.\n+MULTISRCTOP =\n+MULTIBUILDTOP =\n+MULTIDIRS =\n+MULTISUBDIR =\n+MULTIDO = true\n+MULTICLEAN = true\n+\n+# Multilib Makefile bits.\n+.PHONY: all-multi mostlyclean-multi clean-multi distclean-multi \\\n+\tmaintainer-clean-multi\n+\n+all-am: all-multi\n+install-am: install-multi\n+mostlyclean-am: mostlyclean-multi\n+clean-am: clean-multi\n+distclean-am: distclean-multi\n+maintainer-clean-am: maintainer-clean-multi\n+\n+all-multi:\n+\t$(MULTIDO) $(AM_MAKEFLAGS) DO=all multi-do\n+install-multi:\n+\t$(MULTIDO) $(AM_MAKEFLAGS) DO=install multi-do\n+mostlyclean-multi:\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=mostlyclean multi-clean\n+clean-multi:\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=clean multi-clean\n+distclean-multi:\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=distclean multi-clean\n+maintainer-clean-multi:\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=maintainer-clean multi-clean\n+\n+# Work around what appears to be a GNU make bug handling MAKEFLAGS\n+# values defined in terms of make variables, as is the case for CC and\n+# friends when we are called from the top level Makefile.\n+AM_MAKEFLAGS = \\\n+\t\"AR_FLAGS=$(AR_FLAGS)\" \\\n+\t\"CC_FOR_BUILD=$(CC_FOR_BUILD)\" \\\n+\t\"CC_FOR_TARGET=$(CC_FOR_TARGET)\" \\\n+\t\"CFLAGS=$(CFLAGS)\" \\\n+\t\"CXXFLAGS=$(CXXFLAGS)\" \\\n+\t\"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)\" \\\n+\t\"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)\" \\\n+\t\"INSTALL=$(INSTALL)\" \\\n+\t\"INSTALL_DATA=$(INSTALL_DATA)\" \\\n+\t\"INSTALL_PROGRAM=$(INSTALL_PROGRAM)\" \\\n+\t\"INSTALL_SCRIPT=$(INSTALL_SCRIPT)\" \\\n+\t\"LDFLAGS=$(LDFLAGS)\" \\\n+\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+\t\"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\"MAKE=$(MAKE)\" \\\n+\t\"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)\" \\\n+\t\"PICFLAG=$(PICFLAG)\" \\\n+\t\"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)\" \\\n+\t\"SHELL=$(SHELL)\" \\\n+\t\"EXPECT=$(EXPECT)\" \\\n+\t\"RUNTEST=$(RUNTEST)\" \\\n+\t\"RUNTESTFLAGS=$(RUNTESTFLAGS)\" \\\n+\t\"exec_prefix=$(exec_prefix)\" \\\n+\t\"infodir=$(infodir)\" \\\n+\t\"libdir=$(libdir)\" \\\n+\t\"includedir=$(includedir)\" \\\n+\t\"prefix=$(prefix)\" \\\n+\t\"tooldir=$(tooldir)\" \\\n+\t\"AR=$(AR)\" \\\n+\t\"AS=$(AS)\" \\\n+\t\"CC=$(CC)\" \\\n+\t\"CXX=$(CXX)\" \\\n+\t\"LD=$(LD)\" \\\n+\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+\t\"PICFLAG=$(PICFLAG)\" \\\n+\t\"RANLIB=$(RANLIB)\" \\\n+\t\"NM=$(NM)\" \\\n+\t\"NM_FOR_BUILD=$(NM_FOR_BUILD)\" \\\n+\t\"NM_FOR_TARGET=$(NM_FOR_TARGET)\" \\\n+\t\"DESTDIR=$(DESTDIR)\"\n+\n+\n+\n+\n+\n+\n+"}, {"sha": "d8cdb513a49b82655dbe93c0319a2db23543a9d2", "filename": "libstdc++-v3/Makefile.in", "status": "added", "additions": 509, "deletions": 0, "changes": 509, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FMakefile.in?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,509 @@\n+# Makefile.in generated automatically by automake 1.4 from Makefile.am\n+\n+# Copyright (C) 1994, 1995-8, 1999 Free Software Foundation, Inc.\n+# This Makefile.in is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+# PARTICULAR PURPOSE.\n+\n+\n+SHELL = @SHELL@\n+\n+srcdir = @srcdir@\n+top_srcdir = @top_srcdir@\n+VPATH = @srcdir@\n+prefix = @prefix@\n+exec_prefix = @exec_prefix@\n+\n+bindir = @bindir@\n+sbindir = @sbindir@\n+libexecdir = @libexecdir@\n+datadir = @datadir@\n+sysconfdir = @sysconfdir@\n+sharedstatedir = @sharedstatedir@\n+localstatedir = @localstatedir@\n+libdir = @libdir@\n+infodir = @infodir@\n+mandir = @mandir@\n+includedir = @includedir@\n+oldincludedir = /usr/include\n+\n+DESTDIR =\n+\n+pkgdatadir = $(datadir)/@PACKAGE@\n+pkglibdir = $(libdir)/@PACKAGE@\n+pkgincludedir = $(includedir)/@PACKAGE@\n+\n+top_builddir = .\n+\n+ACLOCAL = @ACLOCAL@\n+AUTOCONF = @AUTOCONF@\n+AUTOMAKE = @AUTOMAKE@\n+AUTOHEADER = @AUTOHEADER@\n+\n+INSTALL = @INSTALL@\n+INSTALL_PROGRAM = @INSTALL_PROGRAM@ $(AM_INSTALL_PROGRAM_FLAGS)\n+INSTALL_DATA = @INSTALL_DATA@\n+INSTALL_SCRIPT = @INSTALL_SCRIPT@\n+transform = @program_transform_name@\n+\n+NORMAL_INSTALL = :\n+PRE_INSTALL = :\n+POST_INSTALL = :\n+NORMAL_UNINSTALL = :\n+PRE_UNINSTALL = :\n+POST_UNINSTALL = :\n+build_alias = @build_alias@\n+build_triplet = @build@\n+host_alias = @host_alias@\n+host_triplet = @host@\n+target_alias = @target_alias@\n+target_triplet = @target@\n+AR = @AR@\n+AS = @AS@\n+BUILD_LIBIO_INCLUDE = @BUILD_LIBIO_INCLUDE@\n+CC = @CC@\n+CPP = @CPP@\n+CSTDIO_CC = @CSTDIO_CC@\n+CSTDIO_H = @CSTDIO_H@\n+CXX = @CXX@\n+CXXCPP = @CXXCPP@\n+DEBUGFLAGS = @DEBUGFLAGS@\n+DLLTOOL = @DLLTOOL@\n+EXEEXT = @EXEEXT@\n+GCC_OBJDIR = @GCC_OBJDIR@\n+GLIBCPP_CFLAGS = @GLIBCPP_CFLAGS@\n+GLIBCPP_CXXFLAGS = @GLIBCPP_CXXFLAGS@\n+LIBMATHOBJS = @LIBMATHOBJS@\n+LIBSTRINGOBJS = @LIBSTRINGOBJS@\n+LIBTOOL = @LIBTOOL@\n+LN_S = @LN_S@\n+MAINT = @MAINT@\n+MAKEINFO = @MAKEINFO@\n+NAMESPACES = @NAMESPACES@\n+OBJDUMP = @OBJDUMP@\n+OPTLEVEL = @OPTLEVEL@\n+PACKAGE = @PACKAGE@\n+RANLIB = @RANLIB@\n+THREADDEPS = @THREADDEPS@\n+THREADINCS = @THREADINCS@\n+THREADLIBS = @THREADLIBS@\n+THREADOBJS = @THREADOBJS@\n+THREADSPEC = @THREADSPEC@\n+USE_LONG_DOUBLE = @USE_LONG_DOUBLE@\n+VERSION = @VERSION@\n+WERRORSUPPRESS = @WERRORSUPPRESS@\n+cpu_include_dir = @cpu_include_dir@\n+ctype_include_dir = @ctype_include_dir@\n+glibcpp_basedir = @glibcpp_basedir@\n+\n+AUTOMAKE_OPTIONS = 1.3 cygnus\n+MAINT_CHARSET = latin1\n+\n+# This helps subvert libstdcxx_interface, as calculated by devo/config.if\n+# Needed so that g++ can find the correct include subdir automatically.\n+INTERFACE = v3\n+gxx_include_dir = $(includedir)/g++\n+\n+SUBDIRS = math libio src\n+\n+#all-local:  stamp-rebuild\n+\n+# This has already been sanity-checked by configure to a certain extent\n+#stamp-rebuild:  $(top_builddir)/config.status\n+#\tif test \"$(GCC_OBJDIR)\" != \"no\"; then \\\n+#\t(cd \"$(GCC_OBJDIR)/gcc\" && \\\n+#\t if test -f libgcc2.ready ; then \\\n+#\t   rm -f libgcc2.ready libgcc.a libgcc2.a ; \\\n+#\t   $(MAKE) libgcc2.a TARGET_LIBGCC2_CFLAGS='@NAMESPACES@' ; \\\n+#\t   $(MAKE) libgcc.a ; \\\n+#\t else \\\n+#\t   echo '** There does not appear to be a previously-built' ; \\\n+#\t   echo '** library here.  Please see' ; \\\n+#\t   echo '** <http://sourceware.cygnus.com/libstdc++/install.html>' ; \\\n+#\t   echo '** In particular, the \"Building and Installing' ; \\\n+#\t   echo '** the library (without GCC sources)\" section.' ; \\\n+#\t   exit 1 ; \\\n+#\t fi \\\n+#\t) \\\n+#\tfi\n+#\ttouch stamp-rebuild\n+\n+# Multilib support.\n+MAKEOVERRIDES = \n+\n+# Multilib variables.\n+MULTISRCTOP = \n+MULTIBUILDTOP = \n+MULTIDIRS = \n+MULTISUBDIR = \n+MULTIDO = true\n+MULTICLEAN = true\n+\n+# Work around what appears to be a GNU make bug handling MAKEFLAGS\n+# values defined in terms of make variables, as is the case for CC and\n+# friends when we are called from the top level Makefile.\n+AM_MAKEFLAGS = \\\n+\t\"AR_FLAGS=$(AR_FLAGS)\" \\\n+\t\"CC_FOR_BUILD=$(CC_FOR_BUILD)\" \\\n+\t\"CC_FOR_TARGET=$(CC_FOR_TARGET)\" \\\n+\t\"CFLAGS=$(CFLAGS)\" \\\n+\t\"CXXFLAGS=$(CXXFLAGS)\" \\\n+\t\"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)\" \\\n+\t\"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)\" \\\n+\t\"INSTALL=$(INSTALL)\" \\\n+\t\"INSTALL_DATA=$(INSTALL_DATA)\" \\\n+\t\"INSTALL_PROGRAM=$(INSTALL_PROGRAM)\" \\\n+\t\"INSTALL_SCRIPT=$(INSTALL_SCRIPT)\" \\\n+\t\"LDFLAGS=$(LDFLAGS)\" \\\n+\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+\t\"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\"MAKE=$(MAKE)\" \\\n+\t\"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)\" \\\n+\t\"PICFLAG=$(PICFLAG)\" \\\n+\t\"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)\" \\\n+\t\"SHELL=$(SHELL)\" \\\n+\t\"EXPECT=$(EXPECT)\" \\\n+\t\"RUNTEST=$(RUNTEST)\" \\\n+\t\"RUNTESTFLAGS=$(RUNTESTFLAGS)\" \\\n+\t\"exec_prefix=$(exec_prefix)\" \\\n+\t\"infodir=$(infodir)\" \\\n+\t\"libdir=$(libdir)\" \\\n+\t\"includedir=$(includedir)\" \\\n+\t\"prefix=$(prefix)\" \\\n+\t\"tooldir=$(tooldir)\" \\\n+\t\"AR=$(AR)\" \\\n+\t\"AS=$(AS)\" \\\n+\t\"CC=$(CC)\" \\\n+\t\"CXX=$(CXX)\" \\\n+\t\"LD=$(LD)\" \\\n+\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+\t\"PICFLAG=$(PICFLAG)\" \\\n+\t\"RANLIB=$(RANLIB)\" \\\n+\t\"NM=$(NM)\" \\\n+\t\"NM_FOR_BUILD=$(NM_FOR_BUILD)\" \\\n+\t\"NM_FOR_TARGET=$(NM_FOR_TARGET)\" \\\n+\t\"DESTDIR=$(DESTDIR)\"\n+\n+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n+mkinstalldirs = $(SHELL) $(top_srcdir)/../mkinstalldirs\n+CONFIG_HEADER = config.h\n+CONFIG_CLEAN_FILES =  mkcheck\n+DIST_COMMON =  README ./stamp-h.in ChangeLog Makefile.am Makefile.in \\\n+acconfig.h acinclude.m4 aclocal.m4 config.h.in configure configure.in \\\n+mkcheck.in\n+\n+\n+DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)\n+\n+TAR = gtar\n+GZIP_ENV = --best\n+all: all-redirect\n+.SUFFIXES:\n+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ Makefile.am $(top_srcdir)/configure.in $(ACLOCAL_M4) \n+\tcd $(top_srcdir) && $(AUTOMAKE) --cygnus Makefile\n+\n+Makefile: $(srcdir)/Makefile.in  $(top_builddir)/config.status\n+\tcd $(top_builddir) \\\n+\t  && CONFIG_FILES=$@ CONFIG_HEADERS= $(SHELL) ./config.status\n+\n+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ configure.in  acinclude.m4\n+\tcd $(srcdir) && $(ACLOCAL)\n+\n+config.status: $(srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)\n+\t$(SHELL) ./config.status --recheck\n+$(srcdir)/configure: @MAINTAINER_MODE_TRUE@$(srcdir)/configure.in $(ACLOCAL_M4) $(CONFIGURE_DEPENDENCIES)\n+\tcd $(srcdir) && $(AUTOCONF)\n+\n+config.h: stamp-h\n+\t@if test ! -f $@; then \\\n+\t\trm -f stamp-h; \\\n+\t\t$(MAKE) stamp-h; \\\n+\telse :; fi\n+stamp-h: $(srcdir)/config.h.in $(top_builddir)/config.status\n+\tcd $(top_builddir) \\\n+\t  && CONFIG_FILES= CONFIG_HEADERS=config.h \\\n+\t     $(SHELL) ./config.status\n+\t@echo timestamp > stamp-h 2> /dev/null\n+$(srcdir)/config.h.in: @MAINTAINER_MODE_TRUE@$(srcdir)/stamp-h.in\n+\t@if test ! -f $@; then \\\n+\t\trm -f $(srcdir)/stamp-h.in; \\\n+\t\t$(MAKE) $(srcdir)/stamp-h.in; \\\n+\telse :; fi\n+$(srcdir)/stamp-h.in: $(top_srcdir)/configure.in $(ACLOCAL_M4) acconfig.h\n+\tcd $(top_srcdir) && $(AUTOHEADER)\n+\t@echo timestamp > $(srcdir)/stamp-h.in 2> /dev/null\n+\n+mostlyclean-hdr:\n+\n+clean-hdr:\n+\n+distclean-hdr:\n+\t-rm -f config.h\n+\n+maintainer-clean-hdr:\n+mkcheck: $(top_builddir)/config.status mkcheck.in\n+\tcd $(top_builddir) && CONFIG_FILES=$@ CONFIG_HEADERS= $(SHELL) ./config.status\n+\n+# This directory's subdirectories are mostly independent; you can cd\n+# into them and run `make' without going through this Makefile.\n+# To change the values of `make' variables: instead of editing Makefiles,\n+# (1) if the variable is set in `config.status', edit `config.status'\n+#     (which will cause the Makefiles to be regenerated when you run `make');\n+# (2) otherwise, pass the desired values on the `make' command line.\n+\n+@SET_MAKE@\n+\n+all-recursive install-data-recursive install-exec-recursive \\\n+installdirs-recursive install-recursive uninstall-recursive install-info-recursive \\\n+check-recursive installcheck-recursive info-recursive dvi-recursive:\n+\t@set fnord $(MAKEFLAGS); amf=$$2; \\\n+\tdot_seen=no; \\\n+\ttarget=`echo $@ | sed s/-recursive//`; \\\n+\tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n+\t  echo \"Making $$target in $$subdir\"; \\\n+\t  if test \"$$subdir\" = \".\"; then \\\n+\t    dot_seen=yes; \\\n+\t    local_target=\"$$target-am\"; \\\n+\t  else \\\n+\t    local_target=\"$$target\"; \\\n+\t  fi; \\\n+\t  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \\\n+\t   || case \"$$amf\" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \\\n+\tdone; \\\n+\tif test \"$$dot_seen\" = \"no\"; then \\\n+\t  $(MAKE) $(AM_MAKEFLAGS) \"$$target-am\" || exit 1; \\\n+\tfi; test -z \"$$fail\"\n+\n+mostlyclean-recursive clean-recursive distclean-recursive \\\n+maintainer-clean-recursive:\n+\t@set fnord $(MAKEFLAGS); amf=$$2; \\\n+\tdot_seen=no; \\\n+\trev=''; list='$(SUBDIRS)'; for subdir in $$list; do \\\n+\t  rev=\"$$subdir $$rev\"; \\\n+\t  test \"$$subdir\" = \".\" && dot_seen=yes; \\\n+\tdone; \\\n+\ttest \"$$dot_seen\" = \"no\" && rev=\". $$rev\"; \\\n+\ttarget=`echo $@ | sed s/-recursive//`; \\\n+\tfor subdir in $$rev; do \\\n+\t  echo \"Making $$target in $$subdir\"; \\\n+\t  if test \"$$subdir\" = \".\"; then \\\n+\t    local_target=\"$$target-am\"; \\\n+\t  else \\\n+\t    local_target=\"$$target\"; \\\n+\t  fi; \\\n+\t  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \\\n+\t   || case \"$$amf\" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \\\n+\tdone && test -z \"$$fail\"\n+tags-recursive:\n+\tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n+\t  test \"$$subdir\" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \\\n+\tdone\n+\n+tags: TAGS\n+\n+ID: $(HEADERS) $(SOURCES) $(LISP)\n+\tlist='$(SOURCES) $(HEADERS)'; \\\n+\tunique=`for i in $$list; do echo $$i; done | \\\n+\t  awk '    { files[$$0] = 1; } \\\n+\t       END { for (i in files) print i; }'`; \\\n+\there=`pwd` && cd $(srcdir) \\\n+\t  && mkid -f$$here/ID $$unique $(LISP)\n+\n+TAGS: tags-recursive $(HEADERS) $(SOURCES) config.h.in $(TAGS_DEPENDENCIES) $(LISP)\n+\ttags=; \\\n+\there=`pwd`; \\\n+\tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n+   if test \"$$subdir\" = .; then :; else \\\n+\t    test -f $$subdir/TAGS && tags=\"$$tags -i $$here/$$subdir/TAGS\"; \\\n+   fi; \\\n+\tdone; \\\n+\tlist='$(SOURCES) $(HEADERS)'; \\\n+\tunique=`for i in $$list; do echo $$i; done | \\\n+\t  awk '    { files[$$0] = 1; } \\\n+\t       END { for (i in files) print i; }'`; \\\n+\ttest -z \"$(ETAGS_ARGS)config.h.in$$unique$(LISP)$$tags\" \\\n+\t  || (cd $(srcdir) && etags $(ETAGS_ARGS) $$tags config.h.in $$unique $(LISP) -o $$here/TAGS)\n+\n+mostlyclean-tags:\n+\n+clean-tags:\n+\n+distclean-tags:\n+\t-rm -f TAGS ID\n+\n+maintainer-clean-tags:\n+\n+distdir = $(PACKAGE)-$(VERSION)\n+top_distdir = $(distdir)\n+\n+# This target untars the dist file and tries a VPATH configuration.  Then\n+# it guarantees that the distribution is self-contained by making another\n+# tarfile.\n+distcheck: dist\n+\t-rm -rf $(distdir)\n+\tGZIP=$(GZIP_ENV) $(TAR) zxf $(distdir).tar.gz\n+\tmkdir $(distdir)/=build\n+\tmkdir $(distdir)/=inst\n+\tdc_install_base=`cd $(distdir)/=inst && pwd`; \\\n+\tcd $(distdir)/=build \\\n+\t  && ../configure --srcdir=.. --prefix=$$dc_install_base \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) dvi \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) check \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) install \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) installcheck \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) dist\n+\t-rm -rf $(distdir)\n+\t@banner=\"$(distdir).tar.gz is ready for distribution\"; \\\n+\tdashes=`echo \"$$banner\" | sed s/./=/g`; \\\n+\techo \"$$dashes\"; \\\n+\techo \"$$banner\"; \\\n+\techo \"$$dashes\"\n+dist: distdir\n+\t-chmod -R a+r $(distdir)\n+\tGZIP=$(GZIP_ENV) $(TAR) chozf $(distdir).tar.gz $(distdir)\n+\t-rm -rf $(distdir)\n+dist-all: distdir\n+\t-chmod -R a+r $(distdir)\n+\tGZIP=$(GZIP_ENV) $(TAR) chozf $(distdir).tar.gz $(distdir)\n+\t-rm -rf $(distdir)\n+distdir: $(DISTFILES)\n+\t-rm -rf $(distdir)\n+\tmkdir $(distdir)\n+\t-chmod 777 $(distdir)\n+\t@for file in $(DISTFILES); do \\\n+\t  if test -f $$file; then d=.; else d=$(srcdir); fi; \\\n+\t  if test -d $$d/$$file; then \\\n+\t    cp -pr $$d/$$file $(distdir)/$$file; \\\n+\t  else \\\n+\t    test -f $(distdir)/$$file \\\n+\t    || ln $$d/$$file $(distdir)/$$file 2> /dev/null \\\n+\t    || cp -p $$d/$$file $(distdir)/$$file || :; \\\n+\t  fi; \\\n+\tdone\n+\tfor subdir in $(SUBDIRS); do \\\n+\t  if test \"$$subdir\" = .; then :; else \\\n+\t    test -d $(distdir)/$$subdir \\\n+\t    || mkdir $(distdir)/$$subdir \\\n+\t    || exit 1; \\\n+\t    chmod 777 $(distdir)/$$subdir; \\\n+\t    (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) top_distdir=../$(distdir) distdir=../$(distdir)/$$subdir distdir) \\\n+\t      || exit 1; \\\n+\t  fi; \\\n+\tdone\n+info-am:\n+info: info-recursive\n+dvi-am:\n+dvi: dvi-recursive\n+check-am:\n+check: check-recursive\n+installcheck-am:\n+installcheck: installcheck-recursive\n+install-info-am: \n+install-info: install-info-recursive\n+all-recursive-am: config.h\n+\t$(MAKE) $(AM_MAKEFLAGS) all-recursive\n+\n+install-exec-am:\n+install-exec: install-exec-recursive\n+\n+install-data-am:\n+install-data: install-data-recursive\n+\n+install-am: all-am\n+\t@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am\n+install: install-recursive\n+uninstall-am:\n+uninstall: uninstall-recursive\n+all-am: Makefile config.h\n+all-redirect: all-recursive-am\n+install-strip:\n+\t$(MAKE) $(AM_MAKEFLAGS) AM_INSTALL_PROGRAM_FLAGS=-s install\n+installdirs: installdirs-recursive\n+installdirs-am:\n+\n+\n+mostlyclean-generic:\n+\n+clean-generic:\n+\n+distclean-generic:\n+\t-rm -f Makefile $(CONFIG_CLEAN_FILES)\n+\t-rm -f config.cache config.log stamp-h stamp-h[0-9]*\n+\n+maintainer-clean-generic:\n+mostlyclean-am:  mostlyclean-hdr mostlyclean-tags mostlyclean-generic\n+\n+mostlyclean: mostlyclean-recursive\n+\n+clean-am:  clean-hdr clean-tags clean-generic mostlyclean-am\n+\n+clean: clean-recursive\n+\n+distclean-am:  distclean-hdr distclean-tags distclean-generic clean-am\n+\t-rm -f libtool\n+\n+distclean: distclean-recursive\n+\t-rm -f config.status\n+\n+maintainer-clean-am:  maintainer-clean-hdr maintainer-clean-tags \\\n+\t\tmaintainer-clean-generic distclean-am\n+\t@echo \"This command is intended for maintainers to use;\"\n+\t@echo \"it deletes files that may require special tools to rebuild.\"\n+\n+maintainer-clean: maintainer-clean-recursive\n+\t-rm -f config.status\n+\n+.PHONY: mostlyclean-hdr distclean-hdr clean-hdr maintainer-clean-hdr \\\n+install-data-recursive uninstall-data-recursive install-exec-recursive \\\n+uninstall-exec-recursive installdirs-recursive uninstalldirs-recursive \\\n+all-recursive check-recursive installcheck-recursive info-recursive \\\n+dvi-recursive mostlyclean-recursive distclean-recursive clean-recursive \\\n+maintainer-clean-recursive tags tags-recursive mostlyclean-tags \\\n+distclean-tags clean-tags maintainer-clean-tags distdir info-am info \\\n+dvi-am dvi check check-am installcheck-am installcheck install-info-am \\\n+install-info all-recursive-am install-exec-am install-exec \\\n+install-data-am install-data install-am install uninstall-am uninstall \\\n+all-redirect all-am all installdirs-am installdirs mostlyclean-generic \\\n+distclean-generic clean-generic maintainer-clean-generic clean \\\n+mostlyclean distclean maintainer-clean\n+\n+\n+check:  $(top_builddir)/mkcheck\n+\t$(top_builddir)/mkcheck 0 $(top_builddir) $(top_srcdir)\n+\n+check-install: $(top_builddir)/mkcheck\n+\t$(top_builddir)/mkcheck 1 $(top_builddir) $(top_srcdir) $(prefix)\n+\n+# Multilib Makefile bits.\n+.PHONY: all-multi mostlyclean-multi clean-multi distclean-multi \\\n+\tmaintainer-clean-multi\n+\n+all-am: all-multi\n+install-am: install-multi\n+mostlyclean-am: mostlyclean-multi\n+clean-am: clean-multi\n+distclean-am: distclean-multi\n+maintainer-clean-am: maintainer-clean-multi\n+\n+all-multi:\n+\t$(MULTIDO) $(AM_MAKEFLAGS) DO=all multi-do\n+install-multi:\n+\t$(MULTIDO) $(AM_MAKEFLAGS) DO=install multi-do\n+mostlyclean-multi:\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=mostlyclean multi-clean\n+clean-multi:\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=clean multi-clean\n+distclean-multi:\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=distclean multi-clean\n+maintainer-clean-multi:\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=maintainer-clean multi-clean\n+\n+# Tell versions [3.59,3.63) of GNU make to not export all variables.\n+# Otherwise a system limit (for SysV at least) may be exceeded.\n+.NOEXPORT:"}, {"sha": "1a941683f498150caf055ea5038b24fb9a747dd9", "filename": "libstdc++-v3/README", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FREADME?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,94 @@\n+file: isolib/README\n+\n+New users may wish to point their web browsers to the file index.html\n+in the 'docs' subdirectory.  It contains brief building instructions\n+and notes on how to configure the library in interesting ways.\n+\n+\n+Instructions for configuring and building this snapshot appear\n+in install.html.\n+\n+This directory contains the files needed to create [a still broken\n+subset of] an ISO Standard C++ Library.\n+\n+It has subdirectories:\n+\n+  bits\n+     Files included by standard headers and by other files in\n+     the bits directory.  Includes a set of files bits/std_xxxx.h\n+     that implement the standard headers <xxxx>.\n+\n+  std\n+     Files meant to be found by #include <name> directives in\n+     standard-conforming user programs.  These headers are not\n+     referred to by other headers, because such dependencies\n+     confuse Make (leading it to delete them, all too often).\n+     Installations may substitute symbolic links in place of\n+     these files.\n+\n+  ext\n+     Headers that define extensions to the standard library.  No\n+     standard header refers to any of them.\n+\n+  backward\n+     Headers provided for backward compatibility, such as <iostream.h>.\n+     They are not used in this library.\n+\n+  src\n+     Files that are used in constructing the library, but are not\n+     installed.\n+\n+  testsuites/17_* to 27_*\n+     Test programs are here, and may be used to begin to exercise the \n+     library.  Support for \"make check\" and \"make check-install\" is\n+     complete, and runs through all the subdirectories here when this\n+     command is issued from the build directory. Please note that\n+     \"make check\" calls the script mkcheck, which requires bash, and which\n+     may need the paths to bash adjusted to work properly, as /bin/bash is\n+     assumed.\n+\n+  shadow\n+     Headers intended to shadow standard C headers provided by an\n+     underlying OS or C library, and other headers depended on directly\n+     by C++ headers (e.g. unistd.h).  These are meant to wrap the names\n+     defined there into the _CSwamp namespace.\n+     [NB: this is still experimental, and is not currently used.]\n+\n+  cshadow\n+     The contents of this directory are constructed by scripts which \n+     examine the underlying C headers to discover other headers they\n+     depend on.  These headers are wrappers for them.\n+     [NB: this is still experimental, and is not currently used.]\n+\n+Other subdirectories contain variant versions of certain files\n+that are meant to be copied or linked by the configure script.\n+Currently these are:\n+\n+  amm1 generic glibc math\n+\n+Files needed only to construct the library, but not installed,\n+are in src/.  Files to be copied as part of an installation are\n+all found in the subdirectories mentioned above.  (A configure\n+script may link files from another directory into one of these.)\n+\n+In a normal installation the bits/ directory is copied\n+under the std/ directory, and arranged to be searched only\n+when an include directive specifies a filename of \"bits/...\"\n+or <bits/...>.  When building the library, we use\n+\n+  -Istd -I. -Iconfig/* -Iconfig/cpu/*\n+\n+to get the same effect.\n+\n+Note that glibc also has a bits/ subdirectory.  We will either\n+need to be careful not to collide with names in its bits/\n+directory; or rename bits to (e.g.) cppbits/.\n+\n+To install libstdc++ you need GNU make.  The makefiles do not work with\n+any other make.\n+\n+In files throughout the system, lines marked with an \"XXX\" indicate\n+a bug or incompletely-implemented feature.  Lines marked \"XXX MT\"\n+indicate a place that may require attention for multi-thread safety.\n+(Warning: places that need an atomic read are not so marked yet.)\n+"}, {"sha": "b7ef8c050169f19358ce64d923351407c6334e3a", "filename": "libstdc++-v3/acconfig.h", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Facconfig.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Facconfig.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Facconfig.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,199 @@\n+// acconfig.h symbols and macros for libstdc++ v3 -*- C++ -*-\n+\n+// If using the namespace std, you need this. Eventually this should\n+// not be an option. In the meantime, and as things like std_ctype.h\n+// need to be hacked out, give people the option. If this is set to 1,\n+// CXXFLAGS should include -fhonor-std. If this is undefined, CXXFLAGS\n+// should include -fno-honor-std.\n+#undef _GLIBCPP_USE_NAMESPACES\n+\n+// Include support for 'long long' and 'unsigned long long'.\n+#undef _GLIBCPP_USE_LONG_LONG\n+\n+// Define if the host has a type mbstate_t defined in\n+// wchar.h, as required by 21.1.3.1. Some systems, namely\n+// hppa-hp-hpux10.20 do not meet this requirement, and must be worked\n+// around.\n+#undef _GLIBCPP_NEED_MBSTATE_T\n+\n+// Define if WCHAR_MIN and WCHAR_MAX are in the <cwchar_t>\n+// header. Presently, this is needed so that solaris won't\n+// instantitate numeric_limits<wchar_t>\n+#undef _GLIBCPP_HAS_WCHAR_MIN_MAX\n+\n+// Define if code specialized for wchar_t should be used.\n+#undef _GLIBCPP_USE_WCHAR_T\n+\n+// Define if the compiler/host combination has __builtin_sinf defined.\n+#undef _GLIBCPP_HAS_BUILTIN_SINF\n+\n+// Define if the compiler/host combination has __builtin_cosf defined.\n+#undef _GLIBCPP_HAS_BUILTIN_COSF\n+\n+// Define if the compiler/host combination has __builtin_fabsf defined.\n+#undef _GLIBCPP_HAS_BUILTIN_FABSF\n+\n+// Define if the compiler/host combination has __builtin_fabsf defined.\n+#undef _GLIBCPP_HAS_BUILTIN_SQRTF\n+\n+// Define if GCC support for __complex__ float is buggy.\n+#undef _GLIBCPP_BUGGY_FLOAT_COMPLEX\n+\n+// Define if GCC support for __complex__ is buggy.\n+#undef _GLIBCPP_BUGGY_COMPLEX\n+\n+// Define if LC_MESSAGES is available in <locale.h>.\n+#undef HAVE_LC_MESSAGES\n+\n+// Define if <float.h> exists.\n+#undef HAVE_FLOAT_H\n+\n+// Define if modf is present in <math.h>\n+#undef HAVE_MODF\n+\n+// @BOTTOM@\n+//\n+// Systems that have certain non-standard functions prefixed with an\n+// underscore, we'll handle those here. Must come after config.h.in.\n+//\n+\n+#if defined (HAVE__ISNAN) && ! defined (HAVE_ISNAN)\n+# define HAVE_ISNAN 1\n+# define isnan _isnan\n+#endif\n+\n+#if defined (HAVE__ISNANF) && ! defined (HAVE_ISNANF)\n+# define HAVE_ISNANF 1\n+# define isnanf _isnanf\n+#endif\n+\n+#if defined (HAVE__ISNANL) && ! defined (HAVE_ISNANL)\n+# define HAVE_ISNANL 1\n+# define isnanl _isnanl\n+#endif\n+\n+#if defined (HAVE__ISINF) && ! defined (HAVE_ISINF)\n+# define HAVE_ISINF 1\n+# define isinf _isinf\n+#endif\n+\n+#if defined (HAVE__ISINFF) && ! defined (HAVE_ISINFF)\n+# define HAVE_ISINFF 1\n+# define isinff _isinff\n+#endif\n+\n+#if defined (HAVE__ISINFL) && ! defined (HAVE_ISINFL)\n+# define HAVE_ISINFL 1\n+# define isinfl _isinfl\n+#endif\n+\n+#if defined (HAVE__COPYSIGN) && ! defined (HAVE_COPYSIGN)\n+# define HAVE_COPYSIGN 1\n+# define copysign _copysign\n+#endif\n+\n+#if defined (HAVE__COPYSIGNL) && ! defined (HAVE_COPYSIGNL)\n+# define HAVE_COPYSIGNL 1\n+# define copysignl _copysignl\n+#endif\n+\n+#if defined (HAVE__COSF) && ! defined (HAVE_COSF)\n+# define HAVE_COSF 1\n+# define cosf _cosf\n+#endif\n+\n+#if defined (HAVE__COSHF) && ! defined (HAVE_COSHF)\n+# define HAVE_COSHF 1\n+# define coshf _coshf\n+#endif\n+\n+#if defined (HAVE__LOGF) && ! defined (HAVE_LOGF)\n+# define HAVE_LOGF 1\n+# define logf _logf\n+#endif\n+\n+#if defined (HAVE__LOG10F) && ! defined (HAVE_LOG10F)\n+# define HAVE_LOG10F 1\n+# define log10f _log10f\n+#endif\n+\n+#if defined (HAVE__POWF) && ! defined (HAVE_POWF)\n+# define HAVE_POWF 1\n+# define powf _powf\n+#endif\n+\n+#if defined (HAVE__SINF) && ! defined (HAVE_SINF)\n+# define HAVE_SINF 1\n+# define sinf _sinf\n+#endif\n+\n+#if defined (HAVE__SINHF) && ! defined (HAVE_SINHF)\n+# define HAVE_SINHF 1\n+# define sinhf _sinhf\n+#endif\n+\n+#if defined (HAVE__SQRTF) && ! defined (HAVE_SQRTF)\n+# define HAVE_SQRTF 1\n+# define sqrtf _sqrtf\n+#endif\n+\n+#if defined (HAVE__TANF) && ! defined (HAVE_TANF)\n+# define HAVE_TANF 1\n+# define tanf _tanf\n+#endif\n+\n+#if defined (HAVE__TANHF) && ! defined (HAVE_TANHF)\n+# define HAVE_TANHF 1\n+# define tanhf _tanhf\n+#endif\n+\n+#if defined (HAVE__STRTOF) && ! defined (HAVE_STRTOF)\n+# define HAVE_STRTOF 1\n+# define strtof _strtof\n+#endif\n+\n+#if defined (HAVE__STRTOLD) && ! defined (HAVE_STRTOLD)\n+# define HAVE_STRTOLD 1\n+# define strtold _strtold\n+#endif\n+\n+#if defined (HAVE__FABSF) && ! defined (HAVE_FABSF)\n+# define HAVE_FABSF 1\n+# define fabsf _fabsf\n+#endif\n+\n+#if defined (HAVE__SINCOS) && ! defined (HAVE_SINCOS)\n+# define HAVE_SINCOS 1\n+# define sincos _sincos\n+#endif\n+\n+#if defined (HAVE__SINCOSF) && ! defined (HAVE_SINCOSF)\n+# define HAVE_SINCOSF 1\n+# define sincosf _sincosf\n+#endif\n+\n+#if defined (HAVE__SINCOSL) && ! defined (HAVE_SINCOSL)\n+# define HAVE_SINCOSL 1\n+# define sincosl _sincosl\n+#endif\n+\n+#if defined (HAVE__FINITE) && ! defined (HAVE_FINITE)\n+# define HAVE_FINITE 1\n+# define finite _finite\n+#endif\n+\n+#if defined (HAVE__QFINITE) && ! defined (HAVE_QFINITE)\n+# define HAVE_QFINITE 1\n+# define qfinite _qfinite\n+#endif\n+\n+#if defined (HAVE__FPCLASS) && ! defined (HAVE_FPCLASS)\n+# define HAVE_FPCLASS 1\n+# define fpclass _fpclass\n+#endif\n+\n+#if defined (HAVE__QFPCLASS) && ! defined (HAVE_QFPCLASS)\n+# define HAVE_QFPCLASS 1\n+# define qfpclass _qfpclass\n+#endif\n+"}, {"sha": "8b9a45473900136b13d47c23c7470fc7586957ce", "filename": "libstdc++-v3/acinclude.m4", "status": "added", "additions": 881, "deletions": 0, "changes": 881, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Facinclude.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Facinclude.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Facinclude.m4?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,881 @@\n+dnl\n+dnl Initialize configure bits.\n+dnl\n+dnl Define OPTLEVEL='-O2' if new inlining code present.\n+dnl\n+dnl GLIBCPP_CONFIGURE\n+AC_DEFUN(GLIBCPP_CONFIGURE, [\n+  dnl Default to --enable-multilib\n+  AC_ARG_ENABLE(multilib,\n+  [  --enable-multilib       build hella library versions (default)],\n+  [case \"${enableval}\" in\n+    yes) multilib=yes ;;\n+    no)  multilib=no ;;\n+    *)   AC_MSG_ERROR(bad value ${enableval} for multilib option) ;;\n+   esac], [multilib=yes])dnl\n+\n+  dnl We may get other options which we dont document:\n+  dnl --with-target-subdir, --with-multisrctop, --with-multisubdir\n+  if test \"[$]{srcdir}\" = \".\"; then\n+    if test \"[$]{with_target_subdir}\" != \".\"; then\n+      glibcpp_basedir=\"[$]{srcdir}/[$]{with_multisrctop}../$1\"\n+    else\n+      glibcpp_basedir=\"[$]{srcdir}/[$]{with_multisrctop}$1\"\n+    fi\n+  else\n+    glibcpp_basedir=\"[$]{srcdir}/$1\"\n+  fi\n+  AC_SUBST(glibcpp_basedir)\n+\n+  AC_CANONICAL_HOST\n+\n+  AM_INIT_AUTOMAKE(libstdc++, 2.90.8)\n+\n+# FIXME: We temporarily define our own version of AC_PROG_CC.  This is\n+# copied from autoconf 2.12, but does not call AC_PROG_CC_WORKS.  We\n+# are probably using a cross compiler, which will not be able to fully\n+# link an executable.  This should really be fixed in autoconf\n+# itself.\n+\n+AC_DEFUN(LIB_AC_PROG_CC,\n+[AC_BEFORE([$0], [AC_PROG_CPP])dnl\n+dnl Fool anybody using AC_PROG_CC.\n+AC_PROVIDE([AC_PROG_CC])\n+AC_CHECK_PROG(CC, gcc, gcc)\n+if test -z \"$CC\"; then\n+  AC_CHECK_PROG(CC, cc, cc, , , /usr/ucb/cc)\n+  test -z \"$CC\" && AC_MSG_ERROR([no acceptable cc found in \\$PATH])\n+fi\n+\n+AC_PROG_CC_GNU\n+\n+if test $ac_cv_prog_gcc = yes; then\n+  GCC=yes\n+dnl Check whether -g works, even if CFLAGS is set, in case the package\n+dnl plays around with CFLAGS (such as to build both debugging and\n+dnl normal versions of a library), tasteless as that idea is.\n+  ac_test_CFLAGS=\"${CFLAGS+set}\"\n+  ac_save_CFLAGS=\"$CFLAGS\"\n+  CFLAGS=\n+  AC_PROG_CC_G\n+  if test \"$ac_test_CFLAGS\" = set; then\n+    CFLAGS=\"$ac_save_CFLAGS\"\n+  elif test $ac_cv_prog_cc_g = yes; then\n+    CFLAGS=\"-g -O2\"\n+  else\n+    CFLAGS=\"-O2\"\n+  fi\n+else\n+  GCC=\n+  test \"${CFLAGS+set}\" = set || CFLAGS=\"-g\"\n+fi\n+])\n+\n+LIB_AC_PROG_CC\n+\n+# Likewise for AC_PROG_CXX.\n+AC_DEFUN(LIB_AC_PROG_CXX,\n+[AC_BEFORE([$0], [AC_PROG_CXXCPP])dnl\n+dnl Fool anybody using AC_PROG_CXX.\n+AC_PROVIDE([AC_PROG_CXX])\n+AC_CHECK_PROGS(CXX, $CCC c++ g++ gcc CC cxx cc++, gcc)\n+test -z \"$CXX\" && AC_MSG_ERROR([no acceptable c++ found in \\$PATH])\n+\n+AC_PROG_CXX_GNU\n+\n+if test $ac_cv_prog_gxx = yes; then\n+  GXX=yes\n+dnl Check whether -g works, even if CXXFLAGS is set, in case the package\n+dnl plays around with CXXFLAGS (such as to build both debugging and\n+dnl normal versions of a library), tasteless as that idea is.\n+  ac_test_CXXFLAGS=\"${CXXFLAGS+set}\"\n+  ac_save_CXXFLAGS=\"$CXXFLAGS\"\n+  CXXFLAGS=\n+  AC_PROG_CXX_G\n+  if test \"$ac_test_CXXFLAGS\" = set; then\n+    CXXFLAGS=\"$ac_save_CXXFLAGS\"\n+  elif test $ac_cv_prog_cxx_g = yes; then\n+    CXXFLAGS=\"-g -O2\"\n+  else\n+    CXXFLAGS=\"-O2\"\n+  fi\n+else\n+  GXX=\n+  test \"${CXXFLAGS+set}\" = set || CXXFLAGS=\"-g\"\n+fi\n+])\n+\n+LIB_AC_PROG_CXX\n+\n+# AC_CHECK_TOOL does AC_REQUIRE (AC_CANONICAL_BUILD).  If we dont\n+# run it explicitly here, it will be run implicitly before\n+# LIBGCJ_CONFIGURE, which doesn't work because that means that it will\n+# be run before AC_CANONICAL_HOST.\n+AC_CANONICAL_BUILD\n+\n+AC_CHECK_TOOL(AS, as)\n+AC_CHECK_TOOL(AR, ar)\n+AC_CHECK_TOOL(RANLIB, ranlib, :)\n+\n+AC_PROG_INSTALL\n+\n+AM_MAINTAINER_MODE\n+\n+# We need AC_EXEEXT to keep automake happy in cygnus mode.  However,\n+# at least currently, we never actually build a program, so we never\n+# need to use $(EXEEXT).  Moreover, the test for EXEEXT normally\n+# fails, because we are probably configuring with a cross compiler\n+# which cant create executables.  So we include AC_EXEEXT to keep\n+# automake happy, but we dont execute it, since we dont care about\n+# the result.\n+if false; then\n+  AC_EXEEXT\n+fi\n+\n+# configure.host sets the following important variables\n+#\tglibcpp_cflags    - host specific C compiler flags\n+#\tglibcpp_cxxflags  - host specific C++ compiler flags\n+\n+glibcpp_cflags=\n+glibcpp_cxxflags=\n+\n+. [$]{glibcpp_basedir}/configure.host\n+\n+case [$]{glibcpp_basedir} in\n+/* | [A-Za-z]:[/\\\\]*) libgcj_flagbasedir=[$]{glibcpp_basedir} ;;\n+*) glibcpp_flagbasedir='[$](top_builddir)/'[$]{glibcpp_basedir} ;;\n+esac\n+\n+GLIBCPP_CFLAGS=\"[$]{glibcpp_cflags}\"\n+GLIBCPP_CXXFLAGS=\"[$]{glibcpp_cxxflags}\"\n+AC_SUBST(GLIBCPP_CFLAGS)\n+AC_SUBST(GLIBCPP_CXXFLAGS)\n+])\n+\n+\n+dnl\n+dnl Check to see if g++ can compile this library. \n+dnl\n+dnl Define OPTLEVEL='-O2' if new inlining code present.\n+dnl\n+dnl GLIBCPP_CHECK_COMPILER_VERSION\n+AC_DEFUN(GLIBCPP_CHECK_COMPILER_VERSION, [\n+  AC_MSG_CHECKING([for g++ that will successfullly compile this code])\n+  AC_EGREP_CPP([ok], [\n+  #if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 95) \n+    ok\n+  #endif\n+  ], gpp_satisfactory=yes, AC_MSG_ERROR(\"please upgrade to gcc-2.95 or above\"))\n+  AC_MSG_RESULT($gpp_satisfactory)\n+\n+  AC_MSG_CHECKING([for g++ that supports new inlining mechanism])\n+  AC_EGREP_CPP([ok], [\n+  #if  __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ > 95)\n+    ok\n+  #endif\n+  ], [OPTLEVEL='-O2'\n+      WERRORSUPPRESS=\n+  ], [OPTLEVEL=\n+      WERRORSUPPRESS=-Wno-error\n+  ])\n+  if test \"$OPTLEVEL\" = \"\"; then\n+    AC_MSG_RESULT(no)\n+  else\n+    AC_MSG_RESULT(yes)\n+  fi\n+  AC_SUBST(OPTLEVEL)\n+  AC_SUBST(WERRORSUPPRESS)\n+])\n+\n+\n+dnl\n+dnl Check to see what builtin math functions are supported\n+dnl\n+dnl Define _GLIBCPP_HAS_BUILTIN_SINF if __builtin_sinf\n+dnl Define _GLIBCPP_HAS_BUILTIN_COSF if __builtin_cosf\n+dnl Define _GLIBCPP_HAS_BUILTIN_FABSF if __builtin_fabsf\n+dnl Define _GLIBCPP_HAS_BUILTIN_SQRTF if __builtin_sqrtf\n+dnl\n+dnl GLIBCPP_CHECK_BUILTIN_MATH_SUPPORT\n+AC_DEFUN(GLIBCPP_CHECK_BUILTIN_MATH_SUPPORT, [\n+  dnl Test for builtin math functions.\n+  AC_MSG_CHECKING([for __builtin_sinf])\n+  AC_TRY_COMPILE([#include <math.h>], \n+  [float foo(void) { __builtin_sinf(0.0); }], \n+  use_builtin_sinf=yes, use_builtin_sinf=no)\n+  AC_MSG_RESULT($use_builtin_sinf)\n+  if test $use_builtin_sinf = \"yes\"; then\n+    AC_DEFINE(_GLIBCPP_HAS_BUILTIN_SINF)\n+  fi\n+\n+  AC_MSG_CHECKING([for __builtin_cosf])\n+  AC_TRY_COMPILE([#include <math.h>], \n+  [float foo(void) { __builtin_cosf(0.0); }], \n+  use_builtin_cosf=yes, use_builtin_cosf=no)\n+  AC_MSG_RESULT($use_builtin_cosf)\n+  if test $use_builtin_cosf = \"yes\"; then\n+    AC_DEFINE(_GLIBCPP_HAS_BUILTIN_COSF)\n+  fi\n+\n+  AC_MSG_CHECKING([for __builtin_fabsf])\n+  AC_TRY_COMPILE([#include <math.h>], \n+  [float foo(void) { __builtin_fabsf(0.0); }], \n+  use_builtin_fabsf=yes, use_builtin_fabsf=no)\n+  AC_MSG_RESULT($use_builtin_fabsf)\n+  if test $use_builtin_fabsf = \"yes\"; then\n+    AC_DEFINE(_GLIBCPP_HAS_BUILTIN_FABSF)\n+  fi\n+\n+  AC_MSG_CHECKING([for __builtin_sqrtf])\n+  AC_TRY_COMPILE([#include <math.h>], \n+  [float foo(void) { __builtin_sqrtf(0.0); }], \n+  use_builtin_sqrtf=yes, use_builtin_sqrtf=no)\n+  AC_MSG_RESULT($use_builtin_sqrtf)\n+  if test $use_builtin_sqrtf = \"yes\"; then\n+    AC_DEFINE(_GLIBCPP_HAS_BUILTIN_SQRTF)\n+  fi\n+])\n+\n+\n+dnl\n+dnl Check to see what architecture we are compiling for. If it's\n+dnl supported, use special hand-crafted routines to provide thread\n+dnl primitives.\n+dnl \n+dnl Depending on what is found, select various configure/cpu/*/atomicity.h \n+dnl If not found, select configure/cpu/generic/atomicity.h\n+dnl\n+dnl GLIBCPP_CHECK_CPU\n+AC_DEFUN(GLIBCPP_CHECK_CPU, [\n+    AC_MSG_CHECKING([for cpu primitives directory])\n+    case \"$target_cpu\" in\n+      alpha*)\n+\tcpu_include_dir=\"config/cpu/alpha\"\n+        ;;\n+      arm*)\n+\tcpu_include_dir=\"config/cpu/arm\"\n+        ;;\n+      i486 | i586 | i686 | i786)\n+\tcpu_include_dir=\"config/cpu/i386\"\n+        ;;\n+      powerpc | rs6000)\n+\tcpu_include_dir=\"config/cpu/powerpc\"\n+        ;;\n+      sparc64 | ultrasparc)\n+\tcpu_include_dir=\"config/cpu/sparc/sparc64\"\n+        ;;\n+      sparc*)\n+\tcpu_include_dir=\"config/cpu/sparc/sparc32\"\n+        ;;\n+      *)\n+\tcpu_include_dir=\"config/cpu/generic\"\n+        ;;\n+    esac\n+    AC_MSG_RESULT($cpu_include_dir)\n+    AC_SUBST(cpu_include_dir)\n+])\n+\n+ \n+dnl\n+dnl Check to see what the underlying c library's interface to ctype looks\n+dnl like. Bits of locale rely on things like isspace, toupper, etc. This\n+dnl stuff makes sure the right bits from the clibrary get called.\n+dnl \n+dnl Depending on what is found, select various configure/*/bits/ctype_base.h \n+dnl Depending on what is found, select various configure/*/ctype.cc\n+dnl\n+dnl GLIBCPP_CHECK_CTYPE\n+AC_DEFUN(GLIBCPP_CHECK_CTYPE, [\n+  AC_CHECK_HEADER(ctype.h, [\n+    \n+    dnl If doesn't match any specified, go with defaults.\n+    ctype_default=yes\n+\n+    dnl Test for <ctype> functionality -- gnu-linux\n+    AC_MSG_CHECKING([for gnu-linux <ctype>])\n+    AC_TRY_COMPILE([#include <ctype.h>],\n+    [int\n+    foo (int a)\n+    { return _ISspace + _ISprint + _IScntrl + _ISupper + _ISlower + _ISalpha \\\n+\t+ _ISdigit + _ISpunct + _ISxdigit + _ISalnum + _ISgraph \\\n+\t+ __ctype_tolower[a] + __ctype_toupper[a] + __ctype_b[a];}], \\\n+    ctype_linux=yes, ctype_linux=no)\n+    AC_MSG_RESULT($ctype_linux)\n+    if test $ctype_linux = \"yes\"; then\n+      ctype_include_dir=\"config/gnu-linux\"\n+      ctype_default=no\n+    fi\n+\n+    dnl Test for <ctype> functionality -- solaris 2.6 and 2.7\n+    if test $ctype_default = \"yes\"; then\n+    AC_MSG_CHECKING([for solaris 2.6 or 2.7 <ctype>])\n+    AC_TRY_COMPILE([#include <ctype.h>],\n+    [int\n+    foo (int a)\n+    { return _ISSPACE + _ISPRINT + _ISCNTRL + _ISUPPER + _ISLOWER + _ISALPHA \\\n+\t+ _ISDIGIT + _ISPUNCT + _ISXDIGIT + _ISALNUM + _ISGRAPH \\\n+\t+ __trans_lower[a] + __trans_upper[a] + __ctype_mask[a];}], \\\n+    ctype_solaris=yes, ctype_solaris=no)\n+    AC_MSG_RESULT($ctype_solaris)\n+\n+    if test $ctype_solaris = \"yes\"; then\n+      AC_MSG_CHECKING([  for version])\n+      AC_LANG_CPLUSPLUS \n+      AC_TRY_COMPILE([#include <ctype.h>],\n+      [typedef long* __to_type; __to_type const& _M_toupper = __trans_upper;],\\\n+      ctype_solaris26=yes, ctype_solaris26=no)\n+      AC_LANG_C\n+      if test $ctype_solaris26 = \"yes\"; then\n+        ctype_include_dir=\"config/solaris/solaris2.6\"\n+        AC_MSG_RESULT(\"solaris2.6\")\n+        ctype_default=no\n+      else\n+        ctype_include_dir=\"config/solaris/solaris2.7\"\n+        AC_MSG_RESULT(\"solaris2.7\")\n+        ctype_default=no\n+      fi\n+    fi\n+    fi  \n+\n+    dnl Test for <ctype> functionality -- solaris 2.5.1\n+    if test $ctype_default = \"yes\"; then\n+    AC_MSG_CHECKING([for solaris 2.5.1 <ctype>])\n+    AC_TRY_COMPILE([#include <ctype.h>],\n+    [int\n+    foo (int a)\n+    { return _U + _L + _N + _S + _P + _C + _X + _B \\\n+\t+ __ctype[a];}], \\\n+    ctype_solaris25=yes, ctype_solaris25=no)\n+    AC_MSG_RESULT($ctype_solaris25)\n+    if test $ctype_solaris25 = \"yes\"; then\n+      ctype_include_dir=\"config/solaris/solaris2.5\"\n+      ctype_default=no\n+    fi\n+    fi\n+\n+    dnl Test for <ctype> functionality -- aix\n+    if test $ctype_default = \"yes\"; then\n+    AC_MSG_CHECKING([for aix <ctype>])\n+    AC_TRY_COMPILE([#include <ctype.h>],\n+    [int\n+    foo (int a)\n+    { return _ISSPACE + _ISPRINT + _ISCNTRL + _ISUPPER + _ISLOWER + _ISALPHA \\\n+\t+ _ISDIGIT + _ISPUNCT + _ISXDIGIT + _ISALNUM + _ISGRAPH \\\n+\t+ _VALC('a') + _IS('c', 0);}], \\\n+    ctype_aix=yes, ctype_aix=no)\n+    AC_MSG_RESULT($ctype_aix)\n+    if test $ctype_aix = \"yes\"; then\n+      ctype_include_dir=\"config/aix\"\n+      ctype_default=no\n+    fi\n+    fi\n+\n+    dnl Test for <ctype> functionality -- newlib\n+    if test $ctype_default = \"yes\"; then\n+    AC_MSG_CHECKING([for newlib <ctype>])\n+    AC_TRY_COMPILE([#include <ctype.h>],\n+    [int\n+    foo (int a)\n+    { return _U + _L + _N + _S + _P + _C + _X + _B \\\n+\t+ _ctype_[a];}], \\\n+    ctype_newlib=yes, ctype_newlib=no)\n+    AC_MSG_RESULT($ctype_newlib)\n+    if test $ctype_newlib = \"yes\"; then\n+      ctype_include_dir=\"config/newlib\"\n+      ctype_default=no\n+    fi\n+    fi\n+\n+    if test $ctype_default = \"yes\"; then\n+      ctype_include_dir=\"config/generic\"\n+      AC_MSG_WARN(\"Using default ctype headers.\")\n+    fi\n+    AC_SUBST(ctype_include_dir)\n+  ])\n+])\n+\n+\n+dnl\n+dnl Check to see what the underlying c library or math library is like.\n+dnl\n+dnl Define HAVE_CARGF etc if \"cargf\" is found.\n+dnl\n+dnl GLIBCPP_CHECK_MATH_SUPPORT\n+AC_DEFUN(GLIBCPP_CHECK_MATH_SUPPORT, [\n+  AC_CHECK_LIB(m, sin, libm=\"-lm\")\n+  save_LIBS=\"$LIBS\"\n+  LIBS=\"$LIBS $libm\"\n+\n+  dnl Check for complex versions of math functions of platform.\n+  AC_CHECK_HEADERS([complex.h])\n+  AC_REPLACE_MATHFUNCS(ccos ccosf ccosh ccoshf cexp cexpf c_log c_logf \\\n+  clog10 clog10f cpow cpowf csin csinf csinh csinhf csqrt csqrtf \\\n+  ctan ctanf ctanh ctanhf \\\n+  carg cargf nan hypot hypotf atan2f expf copysignf)\n+\n+  dnl We compile the long double complex functions only if the function \n+  dnl provides the non-complex functions.\n+  USE_LONG_DOUBLE=no\n+  AC_CHECK_FUNC(sinl,\n+  USE_LONG_DOUBLE=yes\n+  AC_REPLACE_MATHFUNCS(ccoshl ccosl cexpl cpowl csinhl csinl \\\n+  csqrtl ctanhl ctanl cargl hypotl signbitl c_logl clog10l))\n+  AC_SUBST(USE_LONG_DOUBLE)\n+\n+  dnl Check to see if basic C math functions have faster float versions.\n+  AC_CHECK_FUNCS(modf isnan isnanf isnanl isinf isinff isinfl copysign \\\n+  copysignl cosf coshf logf log10f powf sinf sinhf sqrtf tanf tanhf \\\n+  strtof strtold fabsf sincos sincosf sincosl finite finite fqfinite \\\n+  fpclass qfpclass)\n+\n+#Some runtimes have these functions with a preceding underscore. Please\n+# keep this sync'd with the one above. And if you add any new symbol,\n+# please add the corresponding block in the @BOTTOM@ section of\n+# acconfig.h.\n+AC_CHECK_FUNCS(_modf _isnan _isnanf _isnanl _isinf _isinff _isinfl _copysign \\\n+_copysignl _cosf _coshf _logf _log10f _powf _sinf _sinhf _sqrtf _tanf _tanhf \\\n+_strtof _strtold _fabsf _sincos _sincosf _sincosl _finite _finitef _qfinite \\\n+_fpclass _qfpclass)\n+\n+LIBS=\"$save_LIBS\"\n+])\n+\n+\n+dnl\n+dnl Check to see if this target can enable the wchar_t parts of libstdc++.\n+dnl\n+dnl Define _GLIBCPP_USE_WCHAR_T if all the bits are found \n+dnl Define _GLIBCPP_NEED_MBSTATE_T if mbstate_t is not in wchar.h\n+dnl Define _GLIBCPP_HAS_WCHAR_MIN_MAX if WCHAR_MIN, WCHAR_MAX in wchar.h\n+dnl\n+dnl GLIBCPP_CHECK_WCHAR_T_SUPPORT\n+AC_DEFUN(GLIBCPP_CHECK_WCHAR_T_SUPPORT, [\n+  AC_CHECK_HEADER(wchar.h,[\n+  dnl Test wchar.h for mbstate_t, which is needed for char_traits and others.\n+  AC_MSG_CHECKING([for native mbstate_t])\n+  AC_TRY_COMPILE([#include <wchar.h>],\n+  [mbstate_t teststate;], \n+  use_native_mbstatet=yes, use_native_mbstatet=no)\n+  AC_MSG_RESULT($use_native_mbstatet)\n+  if test $use_native_mbstatet = \"no\"; then\n+    AC_DEFINE(_GLIBCPP_NEED_MBSTATE_T)\n+  fi\n+  \n+  dnl Test wchar.h for WCHAR_MIN, WCHAR_MAX, which is needed before\n+  dnl numeric_limits can instantiate type_traits<wchar_t>\n+  AC_MSG_CHECKING([for WCHAR_MIN and WCHAR_MAX])\n+  AC_TRY_COMPILE([#include <wchar.h>],\n+  [int i = WCHAR_MIN; int j = WCHAR_MAX;], \n+  has_wchar_minmax=yes, has_wchar_minmax=no)\n+  AC_MSG_RESULT($has_wchar_minmax)\n+  if test $has_wchar_minmax = \"yes\"; then\n+    AC_DEFINE(_GLIBCPP_HAS_WCHAR_MIN_MAX)\n+  fi\n+  \n+  # Test wchar.h for WEOF, which is what we use to determine whether\n+  # to specialize for wchar_t or not.\n+  AC_MSG_CHECKING([for WEOF])\n+  AC_TRY_COMPILE([\n+    #include <wchar.h>\n+    #include <stddef.h>],\n+  [wint_t i = WEOF;],\n+  has_weof=yes, has_weof=no)\n+  AC_MSG_RESULT($has_weof)\n+\n+  dnl Tests for wide character functions.\n+  AC_REPLACE_STRINGFUNCS(wcslen wmemchr wmemcmp wmemcpy wmemmove wmemset)\n+\n+  AC_MSG_CHECKING([for wide character support])\n+  if test $has_weof = \"yes\" && test $has_wchar_minmax = \"yes\"; then\n+    AC_DEFINE(_GLIBCPP_USE_WCHAR_T)\n+    AC_MSG_RESULT(ok)\n+  else\n+    AC_MSG_RESULT(\"not specializing for wchar_t\")\n+  fi\n+  ],[\n+  AC_MSG_WARN([<wchar.h> not found])\n+  AC_DEFINE(_GLIBCPP_NEED_MBSTATE_T)\n+  ])\n+])\n+\n+\n+dnl\n+dnl Check to see if this version of GNU C++ is afflicted by bugs in\n+dnl __complex__ float support.\n+dnl\n+dnl Define _GLIBCPP_BUGGY_FLOAT_COMPLEX if buggy.\n+dnl\n+dnl GLIBCPP_CHECK_COMPLEX_FLOAT_SUPPORT\n+AC_DEFUN(GLIBCPP_CHECK_COMPLEX_FLOAT_SUPPORT, [\n+  AC_REQUIRE([AC_PROG_CXX])\n+  AC_MSG_CHECKING([for GNU C++ __complex__ float support])\n+  AC_CACHE_VAL(glibcpp_cv_float_complex, [\n+    AC_LANG_SAVE\n+    AC_LANG_CPLUSPLUS\n+    rm -f conftest.h\n+    cat > conftest.h <<EOB\n+      //\n+      // Check for buggy __complex__ that causes ICE in most versions of egcs\n+      // and gcc-2.95.x on certain platforms (eg., x86-win32).\n+      //\n+      // See http://egcs.cygnus.com/ml/gcc-bugs/1999-07/msg00845.html for\n+      // more info on the bug itself.\n+      //\n+      struct\n+      float_complex\n+      {\n+       __complex__ float m_value;\n+       float_complex (float = 0.0f, float = 0.0f);\n+       float_complex (__complex__ float val) : m_value (val) {}\n+       float_complex foo (const float_complex &val)\n+         { return float_complex (~val.m_value); }\n+      };\n+EOB\n+    AC_TRY_COMPILE([#include \"conftest.h\"], ,\n+      glibcpp_cv_float_complex=ok,\n+      glibcpp_cv_float_complex=buggy\n+    )\n+    AC_LANG_RESTORE\n+  ])\n+  AC_MSG_RESULT($glibcpp_cv_float_complex)\n+  if test $glibcpp_cv_float_complex = buggy; then\n+    AC_DEFINE(_GLIBCPP_BUGGY_FLOAT_COMPLEX)\n+  fi\n+])\n+\n+\n+dnl\n+dnl \n+dnl Check to see if this version of GNU C++ is afflicted by bugs in \n+dnl __complex__ support.Check for buggy __complex__ that will cause ICE in\n+dnl gcc-2.95.x when using the library, unless we define the default copy\n+dnl ctor in the specializations of complex<>. \n+dnl \n+dnl Define _GLIBCPP_BUGGY_COMPLEX if buggy.\n+dnl\n+dnl GLIBCPP_CHECK_COMPLEX_SUPPORT\n+AC_DEFUN(GLIBCPP_CHECK_COMPLEX_SUPPORT, [\n+  AC_REQUIRE([AC_PROG_CXX])\n+  AC_MSG_CHECKING([for GNU C++ __complex__ support])\n+  AC_CACHE_VAL(glibcpp_cv_complex, [\n+    AC_LANG_SAVE\n+    AC_LANG_CPLUSPLUS\n+    AC_TRY_COMPILE([struct dcomplex { __complex__ double x; }; \\\n+\t\t    dcomplex f(const dcomplex& x) { return dcomplex(x); }], \\\n+\t\t    [ dcomplex x; f(x); ],\n+      glibcpp_cv_complex=ok,\n+      glibcpp_cv_complex=buggy\n+    )\n+    AC_LANG_RESTORE\n+  ])\n+  AC_MSG_RESULT($glibcpp_cv_complex)\n+  if test $glibcpp_cv_complex = buggy; then\n+    AC_DEFINE(_GLIBCPP_BUGGY_COMPLEX)\n+  fi\n+])\n+\n+\n+dnl\n+dnl Check for certain special build configurations.\n+dnl\n+dnl GLIBCPP_ENABLE_DEBUG\n+dnl --enable-debug sets '-ggdb -O0'.\n+dnl --disable-debug sets '-g' and whatever optimization options the\n+dnl     compiler can handle.\n+dnl  +  Perhaps --enable-maintainer-mode should automatically turn this on?\n+dnl  +  Perhaps -D/-U of NDEBUG, DEBUG, DEBUG_ASSERT, ...?\n+dnl  +  Usage:  GLIBCPP_ENABLE_DEBUG[(DEFAULT)]\n+dnl       Where DEFAULT is either `yes' or `no'.  If ommitted, it\n+dnl       defaults to `no'.\n+AC_DEFUN(GLIBCPP_ENABLE_DEBUG, [dnl\n+define([GLIBCPP_ENABLE_DEBUG_DEFAULT], ifelse($1, yes, yes, no))dnl\n+AC_ARG_ENABLE(debug,\n+changequote(<<, >>)dnl\n+<<  --enable-debug          extra debugging, turn off optimization [default=>>GLIBCPP_ENABLE_DEBUG_DEFAULT],\n+changequote([, ])dnl\n+[case \"$enableval\" in\n+ yes) enable_debug=yes ;;\n+ no)  enable_debug=no ;;\n+ *)   AC_MSG_ERROR([Unknown argument to enable/disable extra debugging]) ;;\n+ esac],\n+enable_debug=GLIBCPP_ENABLE_DEBUG_DEFAULT)dnl\n+dnl Option parsed, now set things appropriately\n+case \"$enable_debug\" in\n+    yes)  DEBUGFLAGS='-ggdb -O0'\n+          ;;\n+    no)   DEBUGFLAGS='-g'\n+          ;;\n+esac\n+AC_SUBST(DEBUGFLAGS)\n+])\n+\n+\n+dnl\n+dnl Check for certain special build configurations.\n+dnl\n+dnl GLIBCPP_ENABLE_NAMESPACES\n+dnl --enable-namespaces sets '-fhonor-std' and defines _GLIBCPP_USE_NAMESPACES\n+dnl --disable-namespaces sets '-fno-honor-std' (the macro should be\n+dnl     undefined by default in whatever.h.in).\n+dnl  +  Eventually, this will go away.\n+dnl  +  Usage:  GLIBCPP_ENABLE_NAMESPACES[(DEFAULT)]\n+dnl       Where DEFAULT is either `yes' or `no'.  If ommitted, it\n+dnl       defaults to `no'.\n+AC_DEFUN(GLIBCPP_ENABLE_NAMESPACES, [dnl\n+define([GLIBCPP_ENABLE_NAMESPACES_DEFAULT], ifelse($1, yes, yes, no))dnl\n+AC_ARG_ENABLE(namespaces,\n+changequote(<<, >>)dnl\n+<<  --enable-namespaces     turns on 'std' [default=>>GLIBCPP_ENABLE_NAMESPACES_DEFAULT],\n+changequote([, ])dnl\n+[case \"$enableval\" in\n+ yes) enable_namespaces=yes ;;\n+ no)  enable_namespaces=no ;;\n+ *)   AC_MSG_ERROR([Unknown argument to enable/disable namespaces]) ;;\n+ esac],\n+enable_namespaces=GLIBCPP_ENABLE_NAMESPACES_DEFAULT)dnl\n+dnl Option parsed, now set things appropriately\n+case \"$enable_namespaces\" in\n+    yes)  NAMESPACES='-fhonor-std'\n+          AC_DEFINE(_GLIBCPP_USE_NAMESPACES)\n+          ;;\n+    no)   NAMESPACES='-fno-honor-std'\n+          ;;\n+esac\n+AC_SUBST(NAMESPACES)\n+])\n+\n+\n+dnl\n+dnl Check for instructions to automatically rebuild libgcc.a.  Requires,\n+dnl of course, the location of the gcc objdir.  Note that if --disable-\n+dnl namespaces is in effect, rebuilding libgcc.a is an expensive no-op.\n+dnl\n+dnl GLIBCPP_ENABLE_RELIBGCC\n+dnl --enable-libgcc-rebuild=/absolute/path/to/gcc/objdir sets GCC_OBJDIR\n+dnl     (presumably in the top-level Makefile) to /absol.../objdir\n+dnl --disable-libgcc-rebuild will not touch libgcc.a at all (maybe print\n+dnl     a warning if this is given along with --enable-namespaces), by\n+dnl     setting GCC_OBJDIR to `no'.\n+dnl  +  Doing this by default is going to be interesting.  What default\n+dnl     \"on\" value can there be?\n+dnl  +  Usage:  GLIBCPP_ENABLE_RELIBGCC[(DEFAULT)]\n+dnl       The default path should be ../.. if bundled with GCC source.\n+dnl       If ommitted, it defaults to `no'.\n+dnl\n+AC_DEFUN(GLIBCPP_ENABLE_RELIBGCC, [dnl\n+define([GLIBCPP_ENABLE_RELIBGCC_DEFAULT], ifelse($1,, no, $1))dnl\n+AC_ARG_ENABLE(libgcc-rebuild,\n+changequote(<<, >>)dnl\n+<<  --enable-libgcc-rebuild=DIR     also rebuild libgcc.a; DIR is\n+                                  the GCC objdir; see install.html>>,\n+changequote([, ])dnl\n+[case \"$enableval\" in\n+ yes) AC_MSG_ERROR([--enable-libgcc-rebuild needs a pathname]) ;;\n+ no)  enable_libgcc_rebuild=no ;;\n+ *)   if test -d \"$enableval\" && test -d \"${enableval}/gcc\" && \\\n+         test -d \"${enableval}/libiberty\"\n+      then\n+         enable_libgcc_rebuild=\"$enableval\"\n+      else\n+         AC_MSG_ERROR([\"$enableval\" does not appear to be the GCC objdir])\n+      fi\n+      ;;\n+ esac],\n+enable_libgcc_rebuild=GLIBCPP_ENABLE_RELIBGCC_DEFAULT)dnl\n+GCC_OBJDIR=\"$enable_libgcc_rebuild\"\n+AC_SUBST(GCC_OBJDIR)\n+])\n+\n+\n+dnl\n+dnl Check for certain special build configurations.\n+dnl\n+dnl GLIBCPP_ENABLE_CSTDIO\n+dnl --enable-cstdio=libio sets config/c_io_libio.h and friends\n+dnl \n+dnl default is libio\n+dnl\n+AC_DEFUN(GLIBCPP_ENABLE_CSTDIO, [\n+  AC_MSG_CHECKING([for cstdio to use])\n+  AC_ARG_ENABLE(cstdio,\n+  [  --enable-cstdio         enable GNU libio for target io package. (default)\n+  --enable-cstdio=LIB     use LIB target-speific io package.], \n+  if test x$enable_cstdio = xno; then\n+    enable_cstdio=libio\n+  fi,\n+     enable_cstdio=libio)\n+\n+  enable_cstdio_flag=$enable_cstdio\n+\n+  dnl Check if a valid thread package\n+  case x${enable_cstdio_flag} in\n+\txlibio | x | xno | xnone | xyes)\n+\t\t# default\n+\t\tCSTDIO_H=c_io_libio.h\n+\t\tCSTDIO_CC=c_io_libio.cc\n+ \t\tAC_MSG_RESULT(libio)\n+\n+\t\t# see if we are on a system with libio native (ie, linux)\n+  \t\tAC_CHECK_HEADER(libio.h,  has_libio=yes, has_libio=no)\n+  \t\tif test $has_libio = \"yes\"; then\n+   \t\t  BUILD_LIBIO_INCLUDE=\n+\t\t  need_libio=no\n+  \t\telse\n+   \t\t  BUILD_LIBIO_INCLUDE='-I../libio'\n+\t\t  need_libio=yes\n+  \t\tfi\n+  \t\tAC_SUBST(BUILD_LIBIO_INCLUDE)\n+\t\t;;\n+        xwince)\n+                CSTDIO_H=c_io_wince.h\n+                CSTDIO_CC=c_io_wince.cc\n+                AC_MSG_RESULT(wince)\n+\n+                need_libio=no\n+                BUILD_LIBIO_INCLUDE=\n+                AC_SUBST(BUILD_LIBIO_INCLUDE)\n+                ;;\n+\t*)\n+\t\techo \"$enable_cstdio is an unknown io package\" 1>&2\n+\t\texit 1\n+\t\t;;\n+  esac\n+  AC_SUBST(CSTDIO_H)\n+  AC_SUBST(CSTDIO_CC)\n+  AM_CONDITIONAL(GLIBCPP_NEED_LIBIO, test \"$need_libio\" = yes)\n+])\n+\n+\n+dnl\n+dnl Check for certain special build configurations.\n+dnl\n+dnl GLIBCPP_ENABLE_THREADS\n+dnl --enable-threads=posix sets config/threads-posix.h et. al.\n+dnl \n+dnl default is no threads\n+dnl\n+AC_DEFUN(GLIBCPP_ENABLE_THREADS, [\n+  dnl Note this comes from the gcc/config.in and libjava/config.in\n+  dnl Efforts should be made to keep this in sync.\n+  AC_MSG_CHECKING([for threads package to use])\n+  AC_ARG_ENABLE(threads,\n+  [  --enable-threads        enable thread usage for target GCC.\n+  --enable-threads=LIB    use LIB thread package for target GCC.],\n+  if test x$enable_threads = xno; then\n+    enable_threads=''\n+  fi,\n+    enable_threads='')\n+\n+  enable_threads_flag=$enable_threads\n+\n+  dnl Check if a valid thread package\n+  case x${enable_threads_flag} in\n+\tx | xno | xnone)\n+\t\t# No threads\n+\t\ttarget_thread_file='single'\n+\t\t;;\n+\txyes)\n+\t\t# default\n+\t\ttarget_thread_file=''\n+\t\t;;\n+\txdecosf1 | xirix | xmach | xos2 | xposix | xpthreads | xsingle | \\\n+\txsolaris | xwin32 | xdce | xvxworks)\n+\t\ttarget_thread_file=$enable_threads_flag\n+\t\t;;\n+\t*)\n+\t\techo \"$enable_threads is an unknown thread package\" 1>&2\n+\t\texit 1\n+\t\t;;\n+  esac\n+\n+  dnl Check for thread package actually supported in libstdc++ \n+  case \"$target_thread_file\" in\n+    no | none | single)\n+      THREADS=none\n+      ;;\n+    posix | pthreads)\n+      THREADS=posix\n+      case \"$host\" in\n+        *-*-linux*)\n+\t;;\n+      esac\n+      ;;\n+    decosf1 | irix | mach | os2 | solaris | win32 | dce | vxworks)\n+      AC_MSG_ERROR(thread package $THREADS not yet supported)\n+      ;;\n+    *)\n+      AC_MSG_ERROR($THREADS is an unknown thread package)\n+      ;;\n+  esac\n+  AC_MSG_RESULT($THREADS)\n+\n+  THREADLIBS=\n+  THREADINCS=\n+  THREADDEPS=\n+  THREADOBJS=\n+  THREADH=\n+  THREADSPEC=\n+  case \"$THREADS\" in\n+    posix)\n+      AC_CHECK_HEADER(pthread.h, [have_pthread_h=yes], [have_pthread_h=])\n+      THREADLIBS=-lpthread\n+      THREADSPEC=-lpthread\n+      dnl Not presently used\n+      dnl THREADOBJS=threads-posix.lo\n+      THREADH=threads-posix.h\n+      ;;\n+    none)\n+      dnl Not presently used\n+      dnl THREADOBJS=threads-no.lo\n+      THREADH=threads-no.h\n+      ;;\n+  esac\n+  AC_SUBST(THREADLIBS)\n+  AC_SUBST(THREADINCS)\n+  AC_SUBST(THREADDEPS)\n+  AC_SUBST(THREADOBJS)\n+  AC_SUBST(THREADSPEC)\n+])\n+\n+\n+dnl\n+dnl Check for certain special build configurations.\n+dnl\n+dnl GLIBCPP_ENABLE_LONG_LONG\n+dnl --enable-long-long defines _GLIBCPP_USE_LONG_LONG\n+dnl --disable-long-long leaves _GLIBCPP_USE_LONG_LONG undefined\n+dnl  +  Usage:  GLIBCPP_ENABLE_LONG_LONG[(DEFAULT)]\n+dnl       Where DEFAULT is either `yes' or `no'.  If ommitted, it\n+dnl       defaults to `no'.\n+dnl\n+dnl GLIBCPP_ENABLE_LONG_LONG\n+AC_DEFUN(GLIBCPP_ENABLE_LONG_LONG, [dnl\n+  define([GLIBCPP_ENABLE_LONG_LONG_DEFAULT], ifelse($1, yes, yes, no))dnl\n+  AC_ARG_ENABLE(long-long,\n+  changequote(<<, >>)dnl\n+  <<--enable-long_long      turns on 'long long' [default=>>GLIBCPP_ENABLE_LONG_LONG_DEFAULT],\n+  changequote([, ])dnl\n+  [case \"$enableval\" in\n+   yes) enable_long_long=yes ;;\n+   no)  enable_long_long=no ;;\n+   *)   AC_MSG_ERROR([Unknown argument to enable/disable long long]) ;;\n+   esac],\n+  enable_long_long=GLIBCPP_ENABLE_LONG_LONG_DEFAULT)dnl\n+  dnl Option parsed, now set things appropriately\n+  case \"$enable_long_long\" in\n+    yes)  AC_DEFINE(_GLIBCPP_USE_LONG_LONG)\n+          ;;\n+  esac\n+])\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+"}, {"sha": "00ff575d40b963c9d2318910c21201b8a4a7194f", "filename": "libstdc++-v3/aclocal.m4", "status": "added", "additions": 1503, "deletions": 0, "changes": 1503, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Faclocal.m4?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,1503 @@\n+dnl aclocal.m4 generated automatically by aclocal 1.4\n+\n+dnl Copyright (C) 1994, 1995-8, 1999 Free Software Foundation, Inc.\n+dnl This file is free software; the Free Software Foundation\n+dnl gives unlimited permission to copy and/or distribute it,\n+dnl with or without modifications, as long as this notice is preserved.\n+\n+dnl This program is distributed in the hope that it will be useful,\n+dnl but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n+dnl even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+dnl PARTICULAR PURPOSE.\n+\n+dnl\n+dnl Initialize configure bits.\n+dnl\n+dnl Define OPTLEVEL='-O2' if new inlining code present.\n+dnl\n+dnl GLIBCPP_CONFIGURE\n+AC_DEFUN(GLIBCPP_CONFIGURE, [\n+  dnl Default to --enable-multilib\n+  AC_ARG_ENABLE(multilib,\n+  [  --enable-multilib       build hella library versions (default)],\n+  [case \"${enableval}\" in\n+    yes) multilib=yes ;;\n+    no)  multilib=no ;;\n+    *)   AC_MSG_ERROR(bad value ${enableval} for multilib option) ;;\n+   esac], [multilib=yes])dnl\n+\n+  dnl We may get other options which we dont document:\n+  dnl --with-target-subdir, --with-multisrctop, --with-multisubdir\n+  if test \"[$]{srcdir}\" = \".\"; then\n+    if test \"[$]{with_target_subdir}\" != \".\"; then\n+      glibcpp_basedir=\"[$]{srcdir}/[$]{with_multisrctop}../$1\"\n+    else\n+      glibcpp_basedir=\"[$]{srcdir}/[$]{with_multisrctop}$1\"\n+    fi\n+  else\n+    glibcpp_basedir=\"[$]{srcdir}/$1\"\n+  fi\n+  AC_SUBST(glibcpp_basedir)\n+\n+  AC_CANONICAL_HOST\n+\n+  AM_INIT_AUTOMAKE(libstdc++, 2.90.8)\n+\n+# FIXME: We temporarily define our own version of AC_PROG_CC.  This is\n+# copied from autoconf 2.12, but does not call AC_PROG_CC_WORKS.  We\n+# are probably using a cross compiler, which will not be able to fully\n+# link an executable.  This should really be fixed in autoconf\n+# itself.\n+\n+AC_DEFUN(LIB_AC_PROG_CC,\n+[AC_BEFORE([$0], [AC_PROG_CPP])dnl\n+dnl Fool anybody using AC_PROG_CC.\n+AC_PROVIDE([AC_PROG_CC])\n+AC_CHECK_PROG(CC, gcc, gcc)\n+if test -z \"$CC\"; then\n+  AC_CHECK_PROG(CC, cc, cc, , , /usr/ucb/cc)\n+  test -z \"$CC\" && AC_MSG_ERROR([no acceptable cc found in \\$PATH])\n+fi\n+\n+AC_PROG_CC_GNU\n+\n+if test $ac_cv_prog_gcc = yes; then\n+  GCC=yes\n+dnl Check whether -g works, even if CFLAGS is set, in case the package\n+dnl plays around with CFLAGS (such as to build both debugging and\n+dnl normal versions of a library), tasteless as that idea is.\n+  ac_test_CFLAGS=\"${CFLAGS+set}\"\n+  ac_save_CFLAGS=\"$CFLAGS\"\n+  CFLAGS=\n+  AC_PROG_CC_G\n+  if test \"$ac_test_CFLAGS\" = set; then\n+    CFLAGS=\"$ac_save_CFLAGS\"\n+  elif test $ac_cv_prog_cc_g = yes; then\n+    CFLAGS=\"-g -O2\"\n+  else\n+    CFLAGS=\"-O2\"\n+  fi\n+else\n+  GCC=\n+  test \"${CFLAGS+set}\" = set || CFLAGS=\"-g\"\n+fi\n+])\n+\n+LIB_AC_PROG_CC\n+\n+# Likewise for AC_PROG_CXX.\n+AC_DEFUN(LIB_AC_PROG_CXX,\n+[AC_BEFORE([$0], [AC_PROG_CXXCPP])dnl\n+dnl Fool anybody using AC_PROG_CXX.\n+AC_PROVIDE([AC_PROG_CXX])\n+AC_CHECK_PROGS(CXX, $CCC c++ g++ gcc CC cxx cc++, gcc)\n+test -z \"$CXX\" && AC_MSG_ERROR([no acceptable c++ found in \\$PATH])\n+\n+AC_PROG_CXX_GNU\n+\n+if test $ac_cv_prog_gxx = yes; then\n+  GXX=yes\n+dnl Check whether -g works, even if CXXFLAGS is set, in case the package\n+dnl plays around with CXXFLAGS (such as to build both debugging and\n+dnl normal versions of a library), tasteless as that idea is.\n+  ac_test_CXXFLAGS=\"${CXXFLAGS+set}\"\n+  ac_save_CXXFLAGS=\"$CXXFLAGS\"\n+  CXXFLAGS=\n+  AC_PROG_CXX_G\n+  if test \"$ac_test_CXXFLAGS\" = set; then\n+    CXXFLAGS=\"$ac_save_CXXFLAGS\"\n+  elif test $ac_cv_prog_cxx_g = yes; then\n+    CXXFLAGS=\"-g -O2\"\n+  else\n+    CXXFLAGS=\"-O2\"\n+  fi\n+else\n+  GXX=\n+  test \"${CXXFLAGS+set}\" = set || CXXFLAGS=\"-g\"\n+fi\n+])\n+\n+LIB_AC_PROG_CXX\n+\n+# AC_CHECK_TOOL does AC_REQUIRE (AC_CANONICAL_BUILD).  If we dont\n+# run it explicitly here, it will be run implicitly before\n+# LIBGCJ_CONFIGURE, which doesn't work because that means that it will\n+# be run before AC_CANONICAL_HOST.\n+AC_CANONICAL_BUILD\n+\n+AC_CHECK_TOOL(AS, as)\n+AC_CHECK_TOOL(AR, ar)\n+AC_CHECK_TOOL(RANLIB, ranlib, :)\n+\n+AC_PROG_INSTALL\n+\n+AM_MAINTAINER_MODE\n+\n+# We need AC_EXEEXT to keep automake happy in cygnus mode.  However,\n+# at least currently, we never actually build a program, so we never\n+# need to use $(EXEEXT).  Moreover, the test for EXEEXT normally\n+# fails, because we are probably configuring with a cross compiler\n+# which cant create executables.  So we include AC_EXEEXT to keep\n+# automake happy, but we dont execute it, since we dont care about\n+# the result.\n+if false; then\n+  AC_EXEEXT\n+fi\n+\n+# configure.host sets the following important variables\n+#\tglibcpp_cflags    - host specific C compiler flags\n+#\tglibcpp_cxxflags  - host specific C++ compiler flags\n+\n+glibcpp_cflags=\n+glibcpp_cxxflags=\n+\n+. [$]{glibcpp_basedir}/configure.host\n+\n+case [$]{glibcpp_basedir} in\n+/* | [A-Za-z]:[/\\\\]*) libgcj_flagbasedir=[$]{glibcpp_basedir} ;;\n+*) glibcpp_flagbasedir='[$](top_builddir)/'[$]{glibcpp_basedir} ;;\n+esac\n+\n+GLIBCPP_CFLAGS=\"[$]{glibcpp_cflags}\"\n+GLIBCPP_CXXFLAGS=\"[$]{glibcpp_cxxflags}\"\n+AC_SUBST(GLIBCPP_CFLAGS)\n+AC_SUBST(GLIBCPP_CXXFLAGS)\n+])\n+\n+\n+dnl\n+dnl Check to see if g++ can compile this library. \n+dnl\n+dnl Define OPTLEVEL='-O2' if new inlining code present.\n+dnl\n+dnl GLIBCPP_CHECK_COMPILER_VERSION\n+AC_DEFUN(GLIBCPP_CHECK_COMPILER_VERSION, [\n+  AC_MSG_CHECKING([for g++ that will successfullly compile this code])\n+  AC_EGREP_CPP([ok], [\n+  #if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 95) \n+    ok\n+  #endif\n+  ], gpp_satisfactory=yes, AC_MSG_ERROR(\"please upgrade to gcc-2.95 or above\"))\n+  AC_MSG_RESULT($gpp_satisfactory)\n+\n+  AC_MSG_CHECKING([for g++ that supports new inlining mechanism])\n+  AC_EGREP_CPP([ok], [\n+  #if  __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ > 95)\n+    ok\n+  #endif\n+  ], [OPTLEVEL='-O2'\n+      WERRORSUPPRESS=\n+  ], [OPTLEVEL=\n+      WERRORSUPPRESS=-Wno-error\n+  ])\n+  if test \"$OPTLEVEL\" = \"\"; then\n+    AC_MSG_RESULT(no)\n+  else\n+    AC_MSG_RESULT(yes)\n+  fi\n+  AC_SUBST(OPTLEVEL)\n+  AC_SUBST(WERRORSUPPRESS)\n+])\n+\n+\n+dnl\n+dnl Check to see what builtin math functions are supported\n+dnl\n+dnl Define _GLIBCPP_HAS_BUILTIN_SINF if __builtin_sinf\n+dnl Define _GLIBCPP_HAS_BUILTIN_COSF if __builtin_cosf\n+dnl Define _GLIBCPP_HAS_BUILTIN_FABSF if __builtin_fabsf\n+dnl Define _GLIBCPP_HAS_BUILTIN_SQRTF if __builtin_sqrtf\n+dnl\n+dnl GLIBCPP_CHECK_BUILTIN_MATH_SUPPORT\n+AC_DEFUN(GLIBCPP_CHECK_BUILTIN_MATH_SUPPORT, [\n+  dnl Test for builtin math functions.\n+  AC_MSG_CHECKING([for __builtin_sinf])\n+  AC_TRY_COMPILE([#include <math.h>], \n+  [float foo(void) { __builtin_sinf(0.0); }], \n+  use_builtin_sinf=yes, use_builtin_sinf=no)\n+  AC_MSG_RESULT($use_builtin_sinf)\n+  if test $use_builtin_sinf = \"yes\"; then\n+    AC_DEFINE(_GLIBCPP_HAS_BUILTIN_SINF)\n+  fi\n+\n+  AC_MSG_CHECKING([for __builtin_cosf])\n+  AC_TRY_COMPILE([#include <math.h>], \n+  [float foo(void) { __builtin_cosf(0.0); }], \n+  use_builtin_cosf=yes, use_builtin_cosf=no)\n+  AC_MSG_RESULT($use_builtin_cosf)\n+  if test $use_builtin_cosf = \"yes\"; then\n+    AC_DEFINE(_GLIBCPP_HAS_BUILTIN_COSF)\n+  fi\n+\n+  AC_MSG_CHECKING([for __builtin_fabsf])\n+  AC_TRY_COMPILE([#include <math.h>], \n+  [float foo(void) { __builtin_fabsf(0.0); }], \n+  use_builtin_fabsf=yes, use_builtin_fabsf=no)\n+  AC_MSG_RESULT($use_builtin_fabsf)\n+  if test $use_builtin_fabsf = \"yes\"; then\n+    AC_DEFINE(_GLIBCPP_HAS_BUILTIN_FABSF)\n+  fi\n+\n+  AC_MSG_CHECKING([for __builtin_sqrtf])\n+  AC_TRY_COMPILE([#include <math.h>], \n+  [float foo(void) { __builtin_sqrtf(0.0); }], \n+  use_builtin_sqrtf=yes, use_builtin_sqrtf=no)\n+  AC_MSG_RESULT($use_builtin_sqrtf)\n+  if test $use_builtin_sqrtf = \"yes\"; then\n+    AC_DEFINE(_GLIBCPP_HAS_BUILTIN_SQRTF)\n+  fi\n+])\n+\n+\n+dnl\n+dnl Check to see what architecture we are compiling for. If it's\n+dnl supported, use special hand-crafted routines to provide thread\n+dnl primitives.\n+dnl \n+dnl Depending on what is found, select various configure/cpu/*/atomicity.h \n+dnl If not found, select configure/cpu/generic/atomicity.h\n+dnl\n+dnl GLIBCPP_CHECK_CPU\n+AC_DEFUN(GLIBCPP_CHECK_CPU, [\n+    AC_MSG_CHECKING([for cpu primitives directory])\n+    case \"$target_cpu\" in\n+      alpha*)\n+\tcpu_include_dir=\"config/cpu/alpha\"\n+        ;;\n+      arm*)\n+\tcpu_include_dir=\"config/cpu/arm\"\n+        ;;\n+      i486 | i586 | i686 | i786)\n+\tcpu_include_dir=\"config/cpu/i386\"\n+        ;;\n+      powerpc | rs6000)\n+\tcpu_include_dir=\"config/cpu/powerpc\"\n+        ;;\n+      sparc64 | ultrasparc)\n+\tcpu_include_dir=\"config/cpu/sparc/sparc64\"\n+        ;;\n+      sparc*)\n+\tcpu_include_dir=\"config/cpu/sparc/sparc32\"\n+        ;;\n+      *)\n+\tcpu_include_dir=\"config/cpu/generic\"\n+        ;;\n+    esac\n+    AC_MSG_RESULT($cpu_include_dir)\n+    AC_SUBST(cpu_include_dir)\n+])\n+\n+ \n+dnl\n+dnl Check to see what the underlying c library's interface to ctype looks\n+dnl like. Bits of locale rely on things like isspace, toupper, etc. This\n+dnl stuff makes sure the right bits from the clibrary get called.\n+dnl \n+dnl Depending on what is found, select various configure/*/bits/ctype_base.h \n+dnl Depending on what is found, select various configure/*/ctype.cc\n+dnl\n+dnl GLIBCPP_CHECK_CTYPE\n+AC_DEFUN(GLIBCPP_CHECK_CTYPE, [\n+  AC_CHECK_HEADER(ctype.h, [\n+    \n+    dnl If doesn't match any specified, go with defaults.\n+    ctype_default=yes\n+\n+    dnl Test for <ctype> functionality -- gnu-linux\n+    AC_MSG_CHECKING([for gnu-linux <ctype>])\n+    AC_TRY_COMPILE([#include <ctype.h>],\n+    [int\n+    foo (int a)\n+    { return _ISspace + _ISprint + _IScntrl + _ISupper + _ISlower + _ISalpha \\\n+\t+ _ISdigit + _ISpunct + _ISxdigit + _ISalnum + _ISgraph \\\n+\t+ __ctype_tolower[a] + __ctype_toupper[a] + __ctype_b[a];}], \\\n+    ctype_linux=yes, ctype_linux=no)\n+    AC_MSG_RESULT($ctype_linux)\n+    if test $ctype_linux = \"yes\"; then\n+      ctype_include_dir=\"config/gnu-linux\"\n+      ctype_default=no\n+    fi\n+\n+    dnl Test for <ctype> functionality -- solaris 2.6 and 2.7\n+    if test $ctype_default = \"yes\"; then\n+    AC_MSG_CHECKING([for solaris 2.6 or 2.7 <ctype>])\n+    AC_TRY_COMPILE([#include <ctype.h>],\n+    [int\n+    foo (int a)\n+    { return _ISSPACE + _ISPRINT + _ISCNTRL + _ISUPPER + _ISLOWER + _ISALPHA \\\n+\t+ _ISDIGIT + _ISPUNCT + _ISXDIGIT + _ISALNUM + _ISGRAPH \\\n+\t+ __trans_lower[a] + __trans_upper[a] + __ctype_mask[a];}], \\\n+    ctype_solaris=yes, ctype_solaris=no)\n+    AC_MSG_RESULT($ctype_solaris)\n+\n+    if test $ctype_solaris = \"yes\"; then\n+      AC_MSG_CHECKING([  for version])\n+      AC_LANG_CPLUSPLUS \n+      AC_TRY_COMPILE([#include <ctype.h>],\n+      [typedef long* __to_type; __to_type const& _M_toupper = __trans_upper;],\\\n+      ctype_solaris26=yes, ctype_solaris26=no)\n+      AC_LANG_C\n+      if test $ctype_solaris26 = \"yes\"; then\n+        ctype_include_dir=\"config/solaris/solaris2.6\"\n+        AC_MSG_RESULT(\"solaris2.6\")\n+        ctype_default=no\n+      else\n+        ctype_include_dir=\"config/solaris/solaris2.7\"\n+        AC_MSG_RESULT(\"solaris2.7\")\n+        ctype_default=no\n+      fi\n+    fi\n+    fi  \n+\n+    dnl Test for <ctype> functionality -- solaris 2.5.1\n+    if test $ctype_default = \"yes\"; then\n+    AC_MSG_CHECKING([for solaris 2.5.1 <ctype>])\n+    AC_TRY_COMPILE([#include <ctype.h>],\n+    [int\n+    foo (int a)\n+    { return _U + _L + _N + _S + _P + _C + _X + _B \\\n+\t+ __ctype[a];}], \\\n+    ctype_solaris25=yes, ctype_solaris25=no)\n+    AC_MSG_RESULT($ctype_solaris25)\n+    if test $ctype_solaris25 = \"yes\"; then\n+      ctype_include_dir=\"config/solaris/solaris2.5\"\n+      ctype_default=no\n+    fi\n+    fi\n+\n+    dnl Test for <ctype> functionality -- aix\n+    if test $ctype_default = \"yes\"; then\n+    AC_MSG_CHECKING([for aix <ctype>])\n+    AC_TRY_COMPILE([#include <ctype.h>],\n+    [int\n+    foo (int a)\n+    { return _ISSPACE + _ISPRINT + _ISCNTRL + _ISUPPER + _ISLOWER + _ISALPHA \\\n+\t+ _ISDIGIT + _ISPUNCT + _ISXDIGIT + _ISALNUM + _ISGRAPH \\\n+\t+ _VALC('a') + _IS('c', 0);}], \\\n+    ctype_aix=yes, ctype_aix=no)\n+    AC_MSG_RESULT($ctype_aix)\n+    if test $ctype_aix = \"yes\"; then\n+      ctype_include_dir=\"config/aix\"\n+      ctype_default=no\n+    fi\n+    fi\n+\n+    dnl Test for <ctype> functionality -- newlib\n+    if test $ctype_default = \"yes\"; then\n+    AC_MSG_CHECKING([for newlib <ctype>])\n+    AC_TRY_COMPILE([#include <ctype.h>],\n+    [int\n+    foo (int a)\n+    { return _U + _L + _N + _S + _P + _C + _X + _B \\\n+\t+ _ctype_[a];}], \\\n+    ctype_newlib=yes, ctype_newlib=no)\n+    AC_MSG_RESULT($ctype_newlib)\n+    if test $ctype_newlib = \"yes\"; then\n+      ctype_include_dir=\"config/newlib\"\n+      ctype_default=no\n+    fi\n+    fi\n+\n+    if test $ctype_default = \"yes\"; then\n+      ctype_include_dir=\"config/generic\"\n+      AC_MSG_WARN(\"Using default ctype headers.\")\n+    fi\n+    AC_SUBST(ctype_include_dir)\n+  ])\n+])\n+\n+\n+dnl\n+dnl Check to see what the underlying c library or math library is like.\n+dnl\n+dnl Define HAVE_CARGF etc if \"cargf\" is found.\n+dnl\n+dnl GLIBCPP_CHECK_MATH_SUPPORT\n+AC_DEFUN(GLIBCPP_CHECK_MATH_SUPPORT, [\n+  AC_CHECK_LIB(m, sin, libm=\"-lm\")\n+  save_LIBS=\"$LIBS\"\n+  LIBS=\"$LIBS $libm\"\n+\n+  dnl Check for complex versions of math functions of platform.\n+  AC_CHECK_HEADERS([complex.h])\n+  AC_REPLACE_MATHFUNCS(ccos ccosf ccosh ccoshf cexp cexpf c_log c_logf \\\n+  clog10 clog10f cpow cpowf csin csinf csinh csinhf csqrt csqrtf \\\n+  ctan ctanf ctanh ctanhf \\\n+  carg cargf nan hypot hypotf atan2f expf copysignf)\n+\n+  dnl We compile the long double complex functions only if the function \n+  dnl provides the non-complex functions.\n+  USE_LONG_DOUBLE=no\n+  AC_CHECK_FUNC(sinl,\n+  USE_LONG_DOUBLE=yes\n+  AC_REPLACE_MATHFUNCS(ccoshl ccosl cexpl cpowl csinhl csinl \\\n+  csqrtl ctanhl ctanl cargl hypotl signbitl c_logl clog10l))\n+  AC_SUBST(USE_LONG_DOUBLE)\n+\n+  dnl Check to see if basic C math functions have faster float versions.\n+  AC_CHECK_FUNCS(modf isnan isnanf isnanl isinf isinff isinfl copysign \\\n+  copysignl cosf coshf logf log10f powf sinf sinhf sqrtf tanf tanhf \\\n+  strtof strtold fabsf sincos sincosf sincosl finite finite fqfinite \\\n+  fpclass qfpclass)\n+\n+#Some runtimes have these functions with a preceding underscore. Please\n+# keep this sync'd with the one above. And if you add any new symbol,\n+# please add the corresponding block in the @BOTTOM@ section of\n+# acconfig.h.\n+AC_CHECK_FUNCS(_modf _isnan _isnanf _isnanl _isinf _isinff _isinfl _copysign \\\n+_copysignl _cosf _coshf _logf _log10f _powf _sinf _sinhf _sqrtf _tanf _tanhf \\\n+_strtof _strtold _fabsf _sincos _sincosf _sincosl _finite _finitef _qfinite \\\n+_fpclass _qfpclass)\n+\n+LIBS=\"$save_LIBS\"\n+])\n+\n+\n+dnl\n+dnl Check to see if this target can enable the wchar_t parts of libstdc++.\n+dnl\n+dnl Define _GLIBCPP_USE_WCHAR_T if all the bits are found \n+dnl Define _GLIBCPP_NEED_MBSTATE_T if mbstate_t is not in wchar.h\n+dnl Define _GLIBCPP_HAS_WCHAR_MIN_MAX if WCHAR_MIN, WCHAR_MAX in wchar.h\n+dnl\n+dnl GLIBCPP_CHECK_WCHAR_T_SUPPORT\n+AC_DEFUN(GLIBCPP_CHECK_WCHAR_T_SUPPORT, [\n+  AC_CHECK_HEADER(wchar.h,[\n+  dnl Test wchar.h for mbstate_t, which is needed for char_traits and others.\n+  AC_MSG_CHECKING([for native mbstate_t])\n+  AC_TRY_COMPILE([#include <wchar.h>],\n+  [mbstate_t teststate;], \n+  use_native_mbstatet=yes, use_native_mbstatet=no)\n+  AC_MSG_RESULT($use_native_mbstatet)\n+  if test $use_native_mbstatet = \"no\"; then\n+    AC_DEFINE(_GLIBCPP_NEED_MBSTATE_T)\n+  fi\n+  \n+  dnl Test wchar.h for WCHAR_MIN, WCHAR_MAX, which is needed before\n+  dnl numeric_limits can instantiate type_traits<wchar_t>\n+  AC_MSG_CHECKING([for WCHAR_MIN and WCHAR_MAX])\n+  AC_TRY_COMPILE([#include <wchar.h>],\n+  [int i = WCHAR_MIN; int j = WCHAR_MAX;], \n+  has_wchar_minmax=yes, has_wchar_minmax=no)\n+  AC_MSG_RESULT($has_wchar_minmax)\n+  if test $has_wchar_minmax = \"yes\"; then\n+    AC_DEFINE(_GLIBCPP_HAS_WCHAR_MIN_MAX)\n+  fi\n+  \n+  # Test wchar.h for WEOF, which is what we use to determine whether\n+  # to specialize for wchar_t or not.\n+  AC_MSG_CHECKING([for WEOF])\n+  AC_TRY_COMPILE([\n+    #include <wchar.h>\n+    #include <stddef.h>],\n+  [wint_t i = WEOF;],\n+  has_weof=yes, has_weof=no)\n+  AC_MSG_RESULT($has_weof)\n+\n+  dnl Tests for wide character functions.\n+  AC_REPLACE_STRINGFUNCS(wcslen wmemchr wmemcmp wmemcpy wmemmove wmemset)\n+\n+  AC_MSG_CHECKING([for wide character support])\n+  if test $has_weof = \"yes\" && test $has_wchar_minmax = \"yes\"; then\n+    AC_DEFINE(_GLIBCPP_USE_WCHAR_T)\n+    AC_MSG_RESULT(ok)\n+  else\n+    AC_MSG_RESULT(\"not specializing for wchar_t\")\n+  fi\n+  ],[\n+  AC_MSG_WARN([<wchar.h> not found])\n+  AC_DEFINE(_GLIBCPP_NEED_MBSTATE_T)\n+  ])\n+])\n+\n+\n+dnl\n+dnl Check to see if this version of GNU C++ is afflicted by bugs in\n+dnl __complex__ float support.\n+dnl\n+dnl Define _GLIBCPP_BUGGY_FLOAT_COMPLEX if buggy.\n+dnl\n+dnl GLIBCPP_CHECK_COMPLEX_FLOAT_SUPPORT\n+AC_DEFUN(GLIBCPP_CHECK_COMPLEX_FLOAT_SUPPORT, [\n+  AC_REQUIRE([AC_PROG_CXX])\n+  AC_MSG_CHECKING([for GNU C++ __complex__ float support])\n+  AC_CACHE_VAL(glibcpp_cv_float_complex, [\n+    AC_LANG_SAVE\n+    AC_LANG_CPLUSPLUS\n+    rm -f conftest.h\n+    cat > conftest.h <<EOB\n+      //\n+      // Check for buggy __complex__ that causes ICE in most versions of egcs\n+      // and gcc-2.95.x on certain platforms (eg., x86-win32).\n+      //\n+      // See http://egcs.cygnus.com/ml/gcc-bugs/1999-07/msg00845.html for\n+      // more info on the bug itself.\n+      //\n+      struct\n+      float_complex\n+      {\n+       __complex__ float m_value;\n+       float_complex (float = 0.0f, float = 0.0f);\n+       float_complex (__complex__ float val) : m_value (val) {}\n+       float_complex foo (const float_complex &val)\n+         { return float_complex (~val.m_value); }\n+      };\n+EOB\n+    AC_TRY_COMPILE([#include \"conftest.h\"], ,\n+      glibcpp_cv_float_complex=ok,\n+      glibcpp_cv_float_complex=buggy\n+    )\n+    AC_LANG_RESTORE\n+  ])\n+  AC_MSG_RESULT($glibcpp_cv_float_complex)\n+  if test $glibcpp_cv_float_complex = buggy; then\n+    AC_DEFINE(_GLIBCPP_BUGGY_FLOAT_COMPLEX)\n+  fi\n+])\n+\n+\n+dnl\n+dnl \n+dnl Check to see if this version of GNU C++ is afflicted by bugs in \n+dnl __complex__ support.Check for buggy __complex__ that will cause ICE in\n+dnl gcc-2.95.x when using the library, unless we define the default copy\n+dnl ctor in the specializations of complex<>. \n+dnl \n+dnl Define _GLIBCPP_BUGGY_COMPLEX if buggy.\n+dnl\n+dnl GLIBCPP_CHECK_COMPLEX_SUPPORT\n+AC_DEFUN(GLIBCPP_CHECK_COMPLEX_SUPPORT, [\n+  AC_REQUIRE([AC_PROG_CXX])\n+  AC_MSG_CHECKING([for GNU C++ __complex__ support])\n+  AC_CACHE_VAL(glibcpp_cv_complex, [\n+    AC_LANG_SAVE\n+    AC_LANG_CPLUSPLUS\n+    AC_TRY_COMPILE([struct dcomplex { __complex__ double x; }; \\\n+\t\t    dcomplex f(const dcomplex& x) { return dcomplex(x); }], \\\n+\t\t    [ dcomplex x; f(x); ],\n+      glibcpp_cv_complex=ok,\n+      glibcpp_cv_complex=buggy\n+    )\n+    AC_LANG_RESTORE\n+  ])\n+  AC_MSG_RESULT($glibcpp_cv_complex)\n+  if test $glibcpp_cv_complex = buggy; then\n+    AC_DEFINE(_GLIBCPP_BUGGY_COMPLEX)\n+  fi\n+])\n+\n+\n+dnl\n+dnl Check for certain special build configurations.\n+dnl\n+dnl GLIBCPP_ENABLE_DEBUG\n+dnl --enable-debug sets '-ggdb -O0'.\n+dnl --disable-debug sets '-g' and whatever optimization options the\n+dnl     compiler can handle.\n+dnl  +  Perhaps --enable-maintainer-mode should automatically turn this on?\n+dnl  +  Perhaps -D/-U of NDEBUG, DEBUG, DEBUG_ASSERT, ...?\n+dnl  +  Usage:  GLIBCPP_ENABLE_DEBUG[(DEFAULT)]\n+dnl       Where DEFAULT is either `yes' or `no'.  If ommitted, it\n+dnl       defaults to `no'.\n+AC_DEFUN(GLIBCPP_ENABLE_DEBUG, [dnl\n+define([GLIBCPP_ENABLE_DEBUG_DEFAULT], ifelse($1, yes, yes, no))dnl\n+AC_ARG_ENABLE(debug,\n+changequote(<<, >>)dnl\n+<<  --enable-debug          extra debugging, turn off optimization [default=>>GLIBCPP_ENABLE_DEBUG_DEFAULT],\n+changequote([, ])dnl\n+[case \"$enableval\" in\n+ yes) enable_debug=yes ;;\n+ no)  enable_debug=no ;;\n+ *)   AC_MSG_ERROR([Unknown argument to enable/disable extra debugging]) ;;\n+ esac],\n+enable_debug=GLIBCPP_ENABLE_DEBUG_DEFAULT)dnl\n+dnl Option parsed, now set things appropriately\n+case \"$enable_debug\" in\n+    yes)  DEBUGFLAGS='-ggdb -O0'\n+          ;;\n+    no)   DEBUGFLAGS='-g'\n+          ;;\n+esac\n+AC_SUBST(DEBUGFLAGS)\n+])\n+\n+\n+dnl\n+dnl Check for certain special build configurations.\n+dnl\n+dnl GLIBCPP_ENABLE_NAMESPACES\n+dnl --enable-namespaces sets '-fhonor-std' and defines _GLIBCPP_USE_NAMESPACES\n+dnl --disable-namespaces sets '-fno-honor-std' (the macro should be\n+dnl     undefined by default in whatever.h.in).\n+dnl  +  Eventually, this will go away.\n+dnl  +  Usage:  GLIBCPP_ENABLE_NAMESPACES[(DEFAULT)]\n+dnl       Where DEFAULT is either `yes' or `no'.  If ommitted, it\n+dnl       defaults to `no'.\n+AC_DEFUN(GLIBCPP_ENABLE_NAMESPACES, [dnl\n+define([GLIBCPP_ENABLE_NAMESPACES_DEFAULT], ifelse($1, yes, yes, no))dnl\n+AC_ARG_ENABLE(namespaces,\n+changequote(<<, >>)dnl\n+<<  --enable-namespaces     turns on 'std' [default=>>GLIBCPP_ENABLE_NAMESPACES_DEFAULT],\n+changequote([, ])dnl\n+[case \"$enableval\" in\n+ yes) enable_namespaces=yes ;;\n+ no)  enable_namespaces=no ;;\n+ *)   AC_MSG_ERROR([Unknown argument to enable/disable namespaces]) ;;\n+ esac],\n+enable_namespaces=GLIBCPP_ENABLE_NAMESPACES_DEFAULT)dnl\n+dnl Option parsed, now set things appropriately\n+case \"$enable_namespaces\" in\n+    yes)  NAMESPACES='-fhonor-std'\n+          AC_DEFINE(_GLIBCPP_USE_NAMESPACES)\n+          ;;\n+    no)   NAMESPACES='-fno-honor-std'\n+          ;;\n+esac\n+AC_SUBST(NAMESPACES)\n+])\n+\n+\n+dnl\n+dnl Check for instructions to automatically rebuild libgcc.a.  Requires,\n+dnl of course, the location of the gcc objdir.  Note that if --disable-\n+dnl namespaces is in effect, rebuilding libgcc.a is an expensive no-op.\n+dnl\n+dnl GLIBCPP_ENABLE_RELIBGCC\n+dnl --enable-libgcc-rebuild=/absolute/path/to/gcc/objdir sets GCC_OBJDIR\n+dnl     (presumably in the top-level Makefile) to /absol.../objdir\n+dnl --disable-libgcc-rebuild will not touch libgcc.a at all (maybe print\n+dnl     a warning if this is given along with --enable-namespaces), by\n+dnl     setting GCC_OBJDIR to `no'.\n+dnl  +  Doing this by default is going to be interesting.  What default\n+dnl     \"on\" value can there be?\n+dnl  +  Usage:  GLIBCPP_ENABLE_RELIBGCC[(DEFAULT)]\n+dnl       The default path should be ../.. if bundled with GCC source.\n+dnl       If ommitted, it defaults to `no'.\n+dnl\n+AC_DEFUN(GLIBCPP_ENABLE_RELIBGCC, [dnl\n+define([GLIBCPP_ENABLE_RELIBGCC_DEFAULT], ifelse($1,, no, $1))dnl\n+AC_ARG_ENABLE(libgcc-rebuild,\n+changequote(<<, >>)dnl\n+<<  --enable-libgcc-rebuild=DIR     also rebuild libgcc.a; DIR is\n+                                  the GCC objdir; see install.html>>,\n+changequote([, ])dnl\n+[case \"$enableval\" in\n+ yes) AC_MSG_ERROR([--enable-libgcc-rebuild needs a pathname]) ;;\n+ no)  enable_libgcc_rebuild=no ;;\n+ *)   if test -d \"$enableval\" && test -d \"${enableval}/gcc\" && \\\n+         test -d \"${enableval}/libiberty\"\n+      then\n+         enable_libgcc_rebuild=\"$enableval\"\n+      else\n+         AC_MSG_ERROR([\"$enableval\" does not appear to be the GCC objdir])\n+      fi\n+      ;;\n+ esac],\n+enable_libgcc_rebuild=GLIBCPP_ENABLE_RELIBGCC_DEFAULT)dnl\n+GCC_OBJDIR=\"$enable_libgcc_rebuild\"\n+AC_SUBST(GCC_OBJDIR)\n+])\n+\n+\n+dnl\n+dnl Check for certain special build configurations.\n+dnl\n+dnl GLIBCPP_ENABLE_CSTDIO\n+dnl --enable-cstdio=libio sets config/c_io_libio.h and friends\n+dnl \n+dnl default is libio\n+dnl\n+AC_DEFUN(GLIBCPP_ENABLE_CSTDIO, [\n+  AC_MSG_CHECKING([for cstdio to use])\n+  AC_ARG_ENABLE(cstdio,\n+  [  --enable-cstdio         enable GNU libio for target io package. (default)\n+  --enable-cstdio=LIB     use LIB target-speific io package.], \n+  if test x$enable_cstdio = xno; then\n+    enable_cstdio=libio\n+  fi,\n+     enable_cstdio=libio)\n+\n+  enable_cstdio_flag=$enable_cstdio\n+\n+  dnl Check if a valid thread package\n+  case x${enable_cstdio_flag} in\n+\txlibio | x | xno | xnone | xyes)\n+\t\t# default\n+\t\tCSTDIO_H=c_io_libio.h\n+\t\tCSTDIO_CC=c_io_libio.cc\n+ \t\tAC_MSG_RESULT(libio)\n+\n+\t\t# see if we are on a system with libio native (ie, linux)\n+  \t\tAC_CHECK_HEADER(libio.h,  has_libio=yes, has_libio=no)\n+  \t\tif test $has_libio = \"yes\"; then\n+   \t\t  BUILD_LIBIO_INCLUDE=\n+\t\t  need_libio=no\n+  \t\telse\n+   \t\t  BUILD_LIBIO_INCLUDE='-I../libio'\n+\t\t  need_libio=yes\n+  \t\tfi\n+  \t\tAC_SUBST(BUILD_LIBIO_INCLUDE)\n+\t\t;;\n+        xwince)\n+                CSTDIO_H=c_io_wince.h\n+                CSTDIO_CC=c_io_wince.cc\n+                AC_MSG_RESULT(wince)\n+\n+                need_libio=no\n+                BUILD_LIBIO_INCLUDE=\n+                AC_SUBST(BUILD_LIBIO_INCLUDE)\n+                ;;\n+\t*)\n+\t\techo \"$enable_cstdio is an unknown io package\" 1>&2\n+\t\texit 1\n+\t\t;;\n+  esac\n+  AC_SUBST(CSTDIO_H)\n+  AC_SUBST(CSTDIO_CC)\n+  AM_CONDITIONAL(GLIBCPP_NEED_LIBIO, test \"$need_libio\" = yes)\n+])\n+\n+\n+dnl\n+dnl Check for certain special build configurations.\n+dnl\n+dnl GLIBCPP_ENABLE_THREADS\n+dnl --enable-threads=posix sets config/threads-posix.h et. al.\n+dnl \n+dnl default is no threads\n+dnl\n+AC_DEFUN(GLIBCPP_ENABLE_THREADS, [\n+  dnl Note this comes from the gcc/config.in and libjava/config.in\n+  dnl Efforts should be made to keep this in sync.\n+  AC_MSG_CHECKING([for threads package to use])\n+  AC_ARG_ENABLE(threads,\n+  [  --enable-threads        enable thread usage for target GCC.\n+  --enable-threads=LIB    use LIB thread package for target GCC.],\n+  if test x$enable_threads = xno; then\n+    enable_threads=''\n+  fi,\n+    enable_threads='')\n+\n+  enable_threads_flag=$enable_threads\n+\n+  dnl Check if a valid thread package\n+  case x${enable_threads_flag} in\n+\tx | xno | xnone)\n+\t\t# No threads\n+\t\ttarget_thread_file='single'\n+\t\t;;\n+\txyes)\n+\t\t# default\n+\t\ttarget_thread_file=''\n+\t\t;;\n+\txdecosf1 | xirix | xmach | xos2 | xposix | xpthreads | xsingle | \\\n+\txsolaris | xwin32 | xdce | xvxworks)\n+\t\ttarget_thread_file=$enable_threads_flag\n+\t\t;;\n+\t*)\n+\t\techo \"$enable_threads is an unknown thread package\" 1>&2\n+\t\texit 1\n+\t\t;;\n+  esac\n+\n+  dnl Check for thread package actually supported in libstdc++ \n+  case \"$target_thread_file\" in\n+    no | none | single)\n+      THREADS=none\n+      ;;\n+    posix | pthreads)\n+      THREADS=posix\n+      case \"$host\" in\n+        *-*-linux*)\n+\t;;\n+      esac\n+      ;;\n+    decosf1 | irix | mach | os2 | solaris | win32 | dce | vxworks)\n+      AC_MSG_ERROR(thread package $THREADS not yet supported)\n+      ;;\n+    *)\n+      AC_MSG_ERROR($THREADS is an unknown thread package)\n+      ;;\n+  esac\n+  AC_MSG_RESULT($THREADS)\n+\n+  THREADLIBS=\n+  THREADINCS=\n+  THREADDEPS=\n+  THREADOBJS=\n+  THREADH=\n+  THREADSPEC=\n+  case \"$THREADS\" in\n+    posix)\n+      AC_CHECK_HEADER(pthread.h, [have_pthread_h=yes], [have_pthread_h=])\n+      THREADLIBS=-lpthread\n+      THREADSPEC=-lpthread\n+      dnl Not presently used\n+      dnl THREADOBJS=threads-posix.lo\n+      THREADH=threads-posix.h\n+      ;;\n+    none)\n+      dnl Not presently used\n+      dnl THREADOBJS=threads-no.lo\n+      THREADH=threads-no.h\n+      ;;\n+  esac\n+  AC_SUBST(THREADLIBS)\n+  AC_SUBST(THREADINCS)\n+  AC_SUBST(THREADDEPS)\n+  AC_SUBST(THREADOBJS)\n+  AC_SUBST(THREADSPEC)\n+])\n+\n+\n+dnl\n+dnl Check for certain special build configurations.\n+dnl\n+dnl GLIBCPP_ENABLE_LONG_LONG\n+dnl --enable-long-long defines _GLIBCPP_USE_LONG_LONG\n+dnl --disable-long-long leaves _GLIBCPP_USE_LONG_LONG undefined\n+dnl  +  Usage:  GLIBCPP_ENABLE_LONG_LONG[(DEFAULT)]\n+dnl       Where DEFAULT is either `yes' or `no'.  If ommitted, it\n+dnl       defaults to `no'.\n+dnl\n+dnl GLIBCPP_ENABLE_LONG_LONG\n+AC_DEFUN(GLIBCPP_ENABLE_LONG_LONG, [dnl\n+  define([GLIBCPP_ENABLE_LONG_LONG_DEFAULT], ifelse($1, yes, yes, no))dnl\n+  AC_ARG_ENABLE(long-long,\n+  changequote(<<, >>)dnl\n+  <<--enable-long_long      turns on 'long long' [default=>>GLIBCPP_ENABLE_LONG_LONG_DEFAULT],\n+  changequote([, ])dnl\n+  [case \"$enableval\" in\n+   yes) enable_long_long=yes ;;\n+   no)  enable_long_long=no ;;\n+   *)   AC_MSG_ERROR([Unknown argument to enable/disable long long]) ;;\n+   esac],\n+  enable_long_long=GLIBCPP_ENABLE_LONG_LONG_DEFAULT)dnl\n+  dnl Option parsed, now set things appropriately\n+  case \"$enable_long_long\" in\n+    yes)  AC_DEFINE(_GLIBCPP_USE_LONG_LONG)\n+          ;;\n+  esac\n+])\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+# Do all the work for Automake.  This macro actually does too much --\n+# some checks are only needed if your package does certain things.\n+# But this isn't really a big deal.\n+\n+# serial 1\n+\n+dnl Usage:\n+dnl AM_INIT_AUTOMAKE(package,version, [no-define])\n+\n+AC_DEFUN(AM_INIT_AUTOMAKE,\n+[AC_REQUIRE([AC_PROG_INSTALL])\n+PACKAGE=[$1]\n+AC_SUBST(PACKAGE)\n+VERSION=[$2]\n+AC_SUBST(VERSION)\n+dnl test to see if srcdir already configured\n+if test \"`cd $srcdir && pwd`\" != \"`pwd`\" && test -f $srcdir/config.status; then\n+  AC_MSG_ERROR([source directory already configured; run \"make distclean\" there first])\n+fi\n+ifelse([$3],,\n+AC_DEFINE_UNQUOTED(PACKAGE, \"$PACKAGE\", [Name of package])\n+AC_DEFINE_UNQUOTED(VERSION, \"$VERSION\", [Version number of package]))\n+AC_REQUIRE([AM_SANITY_CHECK])\n+AC_REQUIRE([AC_ARG_PROGRAM])\n+dnl FIXME This is truly gross.\n+missing_dir=`cd $ac_aux_dir && pwd`\n+AM_MISSING_PROG(ACLOCAL, aclocal, $missing_dir)\n+AM_MISSING_PROG(AUTOCONF, autoconf, $missing_dir)\n+AM_MISSING_PROG(AUTOMAKE, automake, $missing_dir)\n+AM_MISSING_PROG(AUTOHEADER, autoheader, $missing_dir)\n+AM_MISSING_PROG(MAKEINFO, makeinfo, $missing_dir)\n+AC_REQUIRE([AC_PROG_MAKE_SET])])\n+\n+#\n+# Check to make sure that the build environment is sane.\n+#\n+\n+AC_DEFUN(AM_SANITY_CHECK,\n+[AC_MSG_CHECKING([whether build environment is sane])\n+# Just in case\n+sleep 1\n+echo timestamp > conftestfile\n+# Do `set' in a subshell so we don't clobber the current shell's\n+# arguments.  Must try -L first in case configure is actually a\n+# symlink; some systems play weird games with the mod time of symlinks\n+# (eg FreeBSD returns the mod time of the symlink's containing\n+# directory).\n+if (\n+   set X `ls -Lt $srcdir/configure conftestfile 2> /dev/null`\n+   if test \"[$]*\" = \"X\"; then\n+      # -L didn't work.\n+      set X `ls -t $srcdir/configure conftestfile`\n+   fi\n+   if test \"[$]*\" != \"X $srcdir/configure conftestfile\" \\\n+      && test \"[$]*\" != \"X conftestfile $srcdir/configure\"; then\n+\n+      # If neither matched, then we have a broken ls.  This can happen\n+      # if, for instance, CONFIG_SHELL is bash and it inherits a\n+      # broken ls alias from the environment.  This has actually\n+      # happened.  Such a system could not be considered \"sane\".\n+      AC_MSG_ERROR([ls -t appears to fail.  Make sure there is not a broken\n+alias in your environment])\n+   fi\n+\n+   test \"[$]2\" = conftestfile\n+   )\n+then\n+   # Ok.\n+   :\n+else\n+   AC_MSG_ERROR([newly created file is older than distributed files!\n+Check your system clock])\n+fi\n+rm -f conftest*\n+AC_MSG_RESULT(yes)])\n+\n+dnl AM_MISSING_PROG(NAME, PROGRAM, DIRECTORY)\n+dnl The program must properly implement --version.\n+AC_DEFUN(AM_MISSING_PROG,\n+[AC_MSG_CHECKING(for working $2)\n+# Run test in a subshell; some versions of sh will print an error if\n+# an executable is not found, even if stderr is redirected.\n+# Redirect stdin to placate older versions of autoconf.  Sigh.\n+if ($2 --version) < /dev/null > /dev/null 2>&1; then\n+   $1=$2\n+   AC_MSG_RESULT(found)\n+else\n+   $1=\"$3/missing $2\"\n+   AC_MSG_RESULT(missing)\n+fi\n+AC_SUBST($1)])\n+\n+# Add --enable-maintainer-mode option to configure.\n+# From Jim Meyering\n+\n+# serial 1\n+\n+AC_DEFUN(AM_MAINTAINER_MODE,\n+[AC_MSG_CHECKING([whether to enable maintainer-specific portions of Makefiles])\n+  dnl maintainer-mode is disabled by default\n+  AC_ARG_ENABLE(maintainer-mode,\n+[  --enable-maintainer-mode enable make rules and dependencies not useful\n+                          (and sometimes confusing) to the casual installer],\n+      USE_MAINTAINER_MODE=$enableval,\n+      USE_MAINTAINER_MODE=no)\n+  AC_MSG_RESULT($USE_MAINTAINER_MODE)\n+  AM_CONDITIONAL(MAINTAINER_MODE, test $USE_MAINTAINER_MODE = yes)\n+  MAINT=$MAINTAINER_MODE_TRUE\n+  AC_SUBST(MAINT)dnl\n+]\n+)\n+\n+# Define a conditional.\n+\n+AC_DEFUN(AM_CONDITIONAL,\n+[AC_SUBST($1_TRUE)\n+AC_SUBST($1_FALSE)\n+if $2; then\n+  $1_TRUE=\n+  $1_FALSE='#'\n+else\n+  $1_TRUE='#'\n+  $1_FALSE=\n+fi])\n+\n+# Check for functions in math library.\n+# Ulrich Drepper <drepper@cygnus.com>, 1998.\n+#\n+# This file can be copied and used freely without restrictions.  It can\n+# be used in projects which are not available under the GNU Public License\n+# but which still want to provide support for the GNU gettext functionality.\n+# Please note that the actual code is *not* freely available.\n+\n+# serial 1\n+\n+dnl AC_REPLACE_MATHFUNCS(FUNCTION...)\n+AC_DEFUN(AC_REPLACE_MATHFUNCS,\n+[AC_CHECK_FUNCS([$1], , [LIBMATHOBJS=\"$LIBMATHOBJS ${ac_func}.lo\"])\n+AC_SUBST(LIBMATHOBJS)dnl\n+])\n+\n+# Check for string functions.\n+# Ulrich Drepper <drepper@cygnus.com>, 1998.\n+#\n+# This file can be copied and used freely without restrictions.  It can\n+# be used in projects which are not available under the GNU Public License\n+# but which still want to provide support for the GNU gettext functionality.\n+# Please note that the actual code is *not* freely available.\n+\n+# serial 1\n+\n+dnl AC_REPLACE_STRINGFUNCS(FUNCTION...)\n+AC_DEFUN(AC_REPLACE_STRINGFUNCS,\n+[AC_CHECK_FUNCS([$1], , [LIBSTRINGOBJS=\"$LIBSTRINGOBJS ${ac_func}.lo\"])\n+AC_SUBST(LIBSTRINGOBJS)dnl\n+])\n+\n+\n+# serial 40 AC_PROG_LIBTOOL\n+AC_DEFUN(AC_PROG_LIBTOOL,\n+[AC_REQUIRE([AC_LIBTOOL_SETUP])dnl\n+\n+# Save cache, so that ltconfig can load it\n+AC_CACHE_SAVE\n+\n+# Actually configure libtool.  ac_aux_dir is where install-sh is found.\n+CC=\"$CC\" CFLAGS=\"$CFLAGS\" CPPFLAGS=\"$CPPFLAGS\" \\\n+LD=\"$LD\" LDFLAGS=\"$LDFLAGS\" LIBS=\"$LIBS\" \\\n+LN_S=\"$LN_S\" NM=\"$NM\" RANLIB=\"$RANLIB\" \\\n+DLLTOOL=\"$DLLTOOL\" AS=\"$AS\" OBJDUMP=\"$OBJDUMP\" \\\n+${CONFIG_SHELL-/bin/sh} $ac_aux_dir/ltconfig --no-reexec \\\n+$libtool_flags --no-verify $ac_aux_dir/ltmain.sh $lt_target \\\n+|| AC_MSG_ERROR([libtool configure failed])\n+\n+# Reload cache, that may have been modified by ltconfig\n+AC_CACHE_LOAD\n+\n+# This can be used to rebuild libtool when needed\n+LIBTOOL_DEPS=\"$ac_aux_dir/ltconfig $ac_aux_dir/ltmain.sh\"\n+\n+# Always use our own libtool.\n+LIBTOOL='$(SHELL) $(top_builddir)/libtool'\n+AC_SUBST(LIBTOOL)dnl\n+\n+# Redirect the config.log output again, so that the ltconfig log is not\n+# clobbered by the next message.\n+exec 5>>./config.log\n+])\n+\n+AC_DEFUN(AC_LIBTOOL_SETUP,\n+[AC_PREREQ(2.13)dnl\n+AC_REQUIRE([AC_ENABLE_SHARED])dnl\n+AC_REQUIRE([AC_ENABLE_STATIC])dnl\n+AC_REQUIRE([AC_ENABLE_FAST_INSTALL])dnl\n+AC_REQUIRE([AC_CANONICAL_HOST])dnl\n+AC_REQUIRE([AC_CANONICAL_BUILD])dnl\n+AC_REQUIRE([AC_PROG_RANLIB])dnl\n+AC_REQUIRE([AC_PROG_CC])dnl\n+AC_REQUIRE([AC_PROG_LD])dnl\n+AC_REQUIRE([AC_PROG_NM])dnl\n+AC_REQUIRE([AC_PROG_LN_S])dnl\n+dnl\n+\n+case \"$target\" in\n+NONE) lt_target=\"$host\" ;;\n+*) lt_target=\"$target\" ;;\n+esac\n+\n+# Check for any special flags to pass to ltconfig.\n+libtool_flags=\"--cache-file=$cache_file\"\n+test \"$enable_shared\" = no && libtool_flags=\"$libtool_flags --disable-shared\"\n+test \"$enable_static\" = no && libtool_flags=\"$libtool_flags --disable-static\"\n+test \"$enable_fast_install\" = no && libtool_flags=\"$libtool_flags --disable-fast-install\"\n+test \"$ac_cv_prog_gcc\" = yes && libtool_flags=\"$libtool_flags --with-gcc\"\n+test \"$ac_cv_prog_gnu_ld\" = yes && libtool_flags=\"$libtool_flags --with-gnu-ld\"\n+ifdef([AC_PROVIDE_AC_LIBTOOL_DLOPEN],\n+[libtool_flags=\"$libtool_flags --enable-dlopen\"])\n+ifdef([AC_PROVIDE_AC_LIBTOOL_WIN32_DLL],\n+[libtool_flags=\"$libtool_flags --enable-win32-dll\"])\n+AC_ARG_ENABLE(libtool-lock,\n+  [  --disable-libtool-lock  avoid locking (might break parallel builds)])\n+test \"x$enable_libtool_lock\" = xno && libtool_flags=\"$libtool_flags --disable-lock\"\n+test x\"$silent\" = xyes && libtool_flags=\"$libtool_flags --silent\"\n+\n+# Some flags need to be propagated to the compiler or linker for good\n+# libtool support.\n+case \"$lt_target\" in\n+*-*-irix6*)\n+  # Find out which ABI we are using.\n+  echo '[#]line __oline__ \"configure\"' > conftest.$ac_ext\n+  if AC_TRY_EVAL(ac_compile); then\n+    case \"`/usr/bin/file conftest.o`\" in\n+    *32-bit*)\n+      LD=\"${LD-ld} -32\"\n+      ;;\n+    *N32*)\n+      LD=\"${LD-ld} -n32\"\n+      ;;\n+    *64-bit*)\n+      LD=\"${LD-ld} -64\"\n+      ;;\n+    esac\n+  fi\n+  rm -rf conftest*\n+  ;;\n+\n+*-*-sco3.2v5*)\n+  # On SCO OpenServer 5, we need -belf to get full-featured binaries.\n+  SAVE_CFLAGS=\"$CFLAGS\"\n+  CFLAGS=\"$CFLAGS -belf\"\n+  AC_CACHE_CHECK([whether the C compiler needs -belf], lt_cv_cc_needs_belf,\n+    [AC_TRY_LINK([],[],[lt_cv_cc_needs_belf=yes],[lt_cv_cc_needs_belf=no])])\n+  if test x\"$lt_cv_cc_needs_belf\" != x\"yes\"; then\n+    # this is probably gcc 2.8.0, egcs 1.0 or newer; no need for -belf\n+    CFLAGS=\"$SAVE_CFLAGS\"\n+  fi\n+  ;;\n+\n+ifdef([AC_PROVIDE_AC_LIBTOOL_WIN32_DLL],\n+[*-*-cygwin* | *-*-mingw*)\n+  AC_CHECK_TOOL(DLLTOOL, dlltool, false)\n+  AC_CHECK_TOOL(AS, as, false)\n+  AC_CHECK_TOOL(OBJDUMP, objdump, false)\n+  ;;\n+])\n+esac\n+])\n+\n+# AC_LIBTOOL_DLOPEN - enable checks for dlopen support\n+AC_DEFUN(AC_LIBTOOL_DLOPEN, [AC_BEFORE([$0],[AC_LIBTOOL_SETUP])])\n+\n+# AC_LIBTOOL_WIN32_DLL - declare package support for building win32 dll's\n+AC_DEFUN(AC_LIBTOOL_WIN32_DLL, [AC_BEFORE([$0], [AC_LIBTOOL_SETUP])])\n+\n+# AC_ENABLE_SHARED - implement the --enable-shared flag\n+# Usage: AC_ENABLE_SHARED[(DEFAULT)]\n+#   Where DEFAULT is either `yes' or `no'.  If omitted, it defaults to\n+#   `yes'.\n+AC_DEFUN(AC_ENABLE_SHARED, [dnl\n+define([AC_ENABLE_SHARED_DEFAULT], ifelse($1, no, no, yes))dnl\n+AC_ARG_ENABLE(shared,\n+changequote(<<, >>)dnl\n+<<  --enable-shared[=PKGS]  build shared libraries [default=>>AC_ENABLE_SHARED_DEFAULT],\n+changequote([, ])dnl\n+[p=${PACKAGE-default}\n+case \"$enableval\" in\n+yes) enable_shared=yes ;;\n+no) enable_shared=no ;;\n+*)\n+  enable_shared=no\n+  # Look at the argument we got.  We use all the common list separators.\n+  IFS=\"${IFS= \t}\"; ac_save_ifs=\"$IFS\"; IFS=\"${IFS}:,\"\n+  for pkg in $enableval; do\n+    if test \"X$pkg\" = \"X$p\"; then\n+      enable_shared=yes\n+    fi\n+  done\n+  IFS=\"$ac_save_ifs\"\n+  ;;\n+esac],\n+enable_shared=AC_ENABLE_SHARED_DEFAULT)dnl\n+])\n+\n+# AC_DISABLE_SHARED - set the default shared flag to --disable-shared\n+AC_DEFUN(AC_DISABLE_SHARED, [AC_BEFORE([$0],[AC_LIBTOOL_SETUP])dnl\n+AC_ENABLE_SHARED(no)])\n+\n+# AC_ENABLE_STATIC - implement the --enable-static flag\n+# Usage: AC_ENABLE_STATIC[(DEFAULT)]\n+#   Where DEFAULT is either `yes' or `no'.  If omitted, it defaults to\n+#   `yes'.\n+AC_DEFUN(AC_ENABLE_STATIC, [dnl\n+define([AC_ENABLE_STATIC_DEFAULT], ifelse($1, no, no, yes))dnl\n+AC_ARG_ENABLE(static,\n+changequote(<<, >>)dnl\n+<<  --enable-static[=PKGS]  build static libraries [default=>>AC_ENABLE_STATIC_DEFAULT],\n+changequote([, ])dnl\n+[p=${PACKAGE-default}\n+case \"$enableval\" in\n+yes) enable_static=yes ;;\n+no) enable_static=no ;;\n+*)\n+  enable_static=no\n+  # Look at the argument we got.  We use all the common list separators.\n+  IFS=\"${IFS= \t}\"; ac_save_ifs=\"$IFS\"; IFS=\"${IFS}:,\"\n+  for pkg in $enableval; do\n+    if test \"X$pkg\" = \"X$p\"; then\n+      enable_static=yes\n+    fi\n+  done\n+  IFS=\"$ac_save_ifs\"\n+  ;;\n+esac],\n+enable_static=AC_ENABLE_STATIC_DEFAULT)dnl\n+])\n+\n+# AC_DISABLE_STATIC - set the default static flag to --disable-static\n+AC_DEFUN(AC_DISABLE_STATIC, [AC_BEFORE([$0],[AC_LIBTOOL_SETUP])dnl\n+AC_ENABLE_STATIC(no)])\n+\n+\n+# AC_ENABLE_FAST_INSTALL - implement the --enable-fast-install flag\n+# Usage: AC_ENABLE_FAST_INSTALL[(DEFAULT)]\n+#   Where DEFAULT is either `yes' or `no'.  If omitted, it defaults to\n+#   `yes'.\n+AC_DEFUN(AC_ENABLE_FAST_INSTALL, [dnl\n+define([AC_ENABLE_FAST_INSTALL_DEFAULT], ifelse($1, no, no, yes))dnl\n+AC_ARG_ENABLE(fast-install,\n+changequote(<<, >>)dnl\n+<<  --enable-fast-install[=PKGS]  optimize for fast installation [default=>>AC_ENABLE_FAST_INSTALL_DEFAULT],\n+changequote([, ])dnl\n+[p=${PACKAGE-default}\n+case \"$enableval\" in\n+yes) enable_fast_install=yes ;;\n+no) enable_fast_install=no ;;\n+*)\n+  enable_fast_install=no\n+  # Look at the argument we got.  We use all the common list separators.\n+  IFS=\"${IFS= \t}\"; ac_save_ifs=\"$IFS\"; IFS=\"${IFS}:,\"\n+  for pkg in $enableval; do\n+    if test \"X$pkg\" = \"X$p\"; then\n+      enable_fast_install=yes\n+    fi\n+  done\n+  IFS=\"$ac_save_ifs\"\n+  ;;\n+esac],\n+enable_fast_install=AC_ENABLE_FAST_INSTALL_DEFAULT)dnl\n+])\n+\n+# AC_ENABLE_FAST_INSTALL - set the default to --disable-fast-install\n+AC_DEFUN(AC_DISABLE_FAST_INSTALL, [AC_BEFORE([$0],[AC_LIBTOOL_SETUP])dnl\n+AC_ENABLE_FAST_INSTALL(no)])\n+\n+# AC_PROG_LD - find the path to the GNU or non-GNU linker\n+AC_DEFUN(AC_PROG_LD,\n+[AC_ARG_WITH(gnu-ld,\n+[  --with-gnu-ld           assume the C compiler uses GNU ld [default=no]],\n+test \"$withval\" = no || with_gnu_ld=yes, with_gnu_ld=no)\n+AC_REQUIRE([AC_PROG_CC])dnl\n+AC_REQUIRE([AC_CANONICAL_HOST])dnl\n+AC_REQUIRE([AC_CANONICAL_BUILD])dnl\n+ac_prog=ld\n+if test \"$ac_cv_prog_gcc\" = yes; then\n+  # Check if gcc -print-prog-name=ld gives a path.\n+  AC_MSG_CHECKING([for ld used by GCC])\n+  ac_prog=`($CC -print-prog-name=ld) 2>&5`\n+  case \"$ac_prog\" in\n+    # Accept absolute paths.\n+changequote(,)dnl\n+    [\\\\/]* | [A-Za-z]:[\\\\/]*)\n+      re_direlt='/[^/][^/]*/\\.\\./'\n+changequote([,])dnl\n+      # Canonicalize the path of ld\n+      ac_prog=`echo $ac_prog| sed 's%\\\\\\\\%/%g'`\n+      while echo $ac_prog | grep \"$re_direlt\" > /dev/null 2>&1; do\n+\tac_prog=`echo $ac_prog| sed \"s%$re_direlt%/%\"`\n+      done\n+      test -z \"$LD\" && LD=\"$ac_prog\"\n+      ;;\n+  \"\")\n+    # If it fails, then pretend we aren't using GCC.\n+    ac_prog=ld\n+    ;;\n+  *)\n+    # If it is relative, then search for the first ld in PATH.\n+    with_gnu_ld=unknown\n+    ;;\n+  esac\n+elif test \"$with_gnu_ld\" = yes; then\n+  AC_MSG_CHECKING([for GNU ld])\n+else\n+  AC_MSG_CHECKING([for non-GNU ld])\n+fi\n+AC_CACHE_VAL(ac_cv_path_LD,\n+[if test -z \"$LD\"; then\n+  IFS=\"${IFS= \t}\"; ac_save_ifs=\"$IFS\"; IFS=\"${IFS}${PATH_SEPARATOR-:}\"\n+  for ac_dir in $PATH; do\n+    test -z \"$ac_dir\" && ac_dir=.\n+    if test -f \"$ac_dir/$ac_prog\" || test -f \"$ac_dir/$ac_prog$ac_exeext\"; then\n+      ac_cv_path_LD=\"$ac_dir/$ac_prog\"\n+      # Check to see if the program is GNU ld.  I'd rather use --version,\n+      # but apparently some GNU ld's only accept -v.\n+      # Break only if it was the GNU/non-GNU ld that we prefer.\n+      if \"$ac_cv_path_LD\" -v 2>&1 < /dev/null | egrep '(GNU|with BFD)' > /dev/null; then\n+\ttest \"$with_gnu_ld\" != no && break\n+      else\n+\ttest \"$with_gnu_ld\" != yes && break\n+      fi\n+    fi\n+  done\n+  IFS=\"$ac_save_ifs\"\n+else\n+  ac_cv_path_LD=\"$LD\" # Let the user override the test with a path.\n+fi])\n+LD=\"$ac_cv_path_LD\"\n+if test -n \"$LD\"; then\n+  AC_MSG_RESULT($LD)\n+else\n+  AC_MSG_RESULT(no)\n+fi\n+test -z \"$LD\" && AC_MSG_ERROR([no acceptable ld found in \\$PATH])\n+AC_PROG_LD_GNU\n+])\n+\n+AC_DEFUN(AC_PROG_LD_GNU,\n+[AC_CACHE_CHECK([if the linker ($LD) is GNU ld], ac_cv_prog_gnu_ld,\n+[# I'd rather use --version here, but apparently some GNU ld's only accept -v.\n+if $LD -v 2>&1 </dev/null | egrep '(GNU|with BFD)' 1>&5; then\n+  ac_cv_prog_gnu_ld=yes\n+else\n+  ac_cv_prog_gnu_ld=no\n+fi])\n+])\n+\n+# AC_PROG_NM - find the path to a BSD-compatible name lister\n+AC_DEFUN(AC_PROG_NM,\n+[AC_MSG_CHECKING([for BSD-compatible nm])\n+AC_CACHE_VAL(ac_cv_path_NM,\n+[if test -n \"$NM\"; then\n+  # Let the user override the test.\n+  ac_cv_path_NM=\"$NM\"\n+else\n+  IFS=\"${IFS= \t}\"; ac_save_ifs=\"$IFS\"; IFS=\"${IFS}${PATH_SEPARATOR-:}\"\n+  for ac_dir in $PATH /usr/ccs/bin /usr/ucb /bin; do\n+    test -z \"$ac_dir\" && ac_dir=.\n+    if test -f $ac_dir/nm || test -f $ac_dir/nm$ac_exeext ; then\n+      # Check to see if the nm accepts a BSD-compat flag.\n+      # Adding the `sed 1q' prevents false positives on HP-UX, which says:\n+      #   nm: unknown option \"B\" ignored\n+      if ($ac_dir/nm -B /dev/null 2>&1 | sed '1q'; exit 0) | egrep /dev/null >/dev/null; then\n+\tac_cv_path_NM=\"$ac_dir/nm -B\"\n+\tbreak\n+      elif ($ac_dir/nm -p /dev/null 2>&1 | sed '1q'; exit 0) | egrep /dev/null >/dev/null; then\n+\tac_cv_path_NM=\"$ac_dir/nm -p\"\n+\tbreak\n+      else\n+\tac_cv_path_NM=${ac_cv_path_NM=\"$ac_dir/nm\"} # keep the first match, but\n+\tcontinue # so that we can try to find one that supports BSD flags\n+      fi\n+    fi\n+  done\n+  IFS=\"$ac_save_ifs\"\n+  test -z \"$ac_cv_path_NM\" && ac_cv_path_NM=nm\n+fi])\n+NM=\"$ac_cv_path_NM\"\n+AC_MSG_RESULT([$NM])\n+])\n+\n+# AC_CHECK_LIBM - check for math library\n+AC_DEFUN(AC_CHECK_LIBM,\n+[AC_REQUIRE([AC_CANONICAL_HOST])dnl\n+LIBM=\n+case \"$lt_target\" in\n+*-*-beos* | *-*-cygwin*)\n+  # These system don't have libm\n+  ;;\n+*-ncr-sysv4.3*)\n+  AC_CHECK_LIB(mw, _mwvalidcheckl, LIBM=\"-lmw\")\n+  AC_CHECK_LIB(m, main, LIBM=\"$LIBM -lm\")\n+  ;;\n+*)\n+  AC_CHECK_LIB(m, main, LIBM=\"-lm\")\n+  ;;\n+esac\n+])\n+\n+# AC_LIBLTDL_CONVENIENCE[(dir)] - sets LIBLTDL to the link flags for\n+# the libltdl convenience library, adds --enable-ltdl-convenience to\n+# the configure arguments.  Note that LIBLTDL is not AC_SUBSTed, nor\n+# is AC_CONFIG_SUBDIRS called.  If DIR is not provided, it is assumed\n+# to be `${top_builddir}/libltdl'.  Make sure you start DIR with\n+# '${top_builddir}/' (note the single quotes!) if your package is not\n+# flat, and, if you're not using automake, define top_builddir as\n+# appropriate in the Makefiles.\n+AC_DEFUN(AC_LIBLTDL_CONVENIENCE, [AC_BEFORE([$0],[AC_LIBTOOL_SETUP])dnl\n+  case \"$enable_ltdl_convenience\" in\n+  no) AC_MSG_ERROR([this package needs a convenience libltdl]) ;;\n+  \"\") enable_ltdl_convenience=yes\n+      ac_configure_args=\"$ac_configure_args --enable-ltdl-convenience\" ;;\n+  esac\n+  LIBLTDL=ifelse($#,1,$1,['${top_builddir}/libltdl'])/libltdlc.la\n+  INCLTDL=ifelse($#,1,-I$1,['-I${top_builddir}/libltdl'])\n+])\n+\n+# AC_LIBLTDL_INSTALLABLE[(dir)] - sets LIBLTDL to the link flags for\n+# the libltdl installable library, and adds --enable-ltdl-install to\n+# the configure arguments.  Note that LIBLTDL is not AC_SUBSTed, nor\n+# is AC_CONFIG_SUBDIRS called.  If DIR is not provided, it is assumed\n+# to be `${top_builddir}/libltdl'.  Make sure you start DIR with\n+# '${top_builddir}/' (note the single quotes!) if your package is not\n+# flat, and, if you're not using automake, define top_builddir as\n+# appropriate in the Makefiles.\n+# In the future, this macro may have to be called after AC_PROG_LIBTOOL.\n+AC_DEFUN(AC_LIBLTDL_INSTALLABLE, [AC_BEFORE([$0],[AC_LIBTOOL_SETUP])dnl\n+  AC_CHECK_LIB(ltdl, main,\n+  [test x\"$enable_ltdl_install\" != xyes && enable_ltdl_install=no],\n+  [if test x\"$enable_ltdl_install\" = xno; then\n+     AC_MSG_WARN([libltdl not installed, but installation disabled])\n+   else\n+     enable_ltdl_install=yes\n+   fi\n+  ])\n+  if test x\"$enable_ltdl_install\" = x\"yes\"; then\n+    ac_configure_args=\"$ac_configure_args --enable-ltdl-install\"\n+    LIBLTDL=ifelse($#,1,$1,['${top_builddir}/libltdl'])/libltdl.la\n+    INCLTDL=ifelse($#,1,-I$1,['-I${top_builddir}/libltdl'])\n+  else\n+    ac_configure_args=\"$ac_configure_args --enable-ltdl-install=no\"\n+    LIBLTDL=\"-lltdl\"\n+    INCLTDL=\n+  fi\n+])\n+\n+dnl old names\n+AC_DEFUN(AM_PROG_LIBTOOL, [indir([AC_PROG_LIBTOOL])])dnl\n+AC_DEFUN(AM_ENABLE_SHARED, [indir([AC_ENABLE_SHARED], $@)])dnl\n+AC_DEFUN(AM_ENABLE_STATIC, [indir([AC_ENABLE_STATIC], $@)])dnl\n+AC_DEFUN(AM_DISABLE_SHARED, [indir([AC_DISABLE_SHARED], $@)])dnl\n+AC_DEFUN(AM_DISABLE_STATIC, [indir([AC_DISABLE_STATIC], $@)])dnl\n+AC_DEFUN(AM_PROG_LD, [indir([AC_PROG_LD])])dnl\n+AC_DEFUN(AM_PROG_NM, [indir([AC_PROG_NM])])dnl\n+\n+dnl This is just to silence aclocal about the macro not being used\n+ifelse([AC_DISABLE_FAST_INSTALL])dnl\n+\n+# Like AC_CONFIG_HEADER, but automatically create stamp file.\n+\n+AC_DEFUN(AM_CONFIG_HEADER,\n+[AC_PREREQ([2.12])\n+AC_CONFIG_HEADER([$1])\n+dnl When config.status generates a header, we must update the stamp-h file.\n+dnl This file resides in the same directory as the config header\n+dnl that is generated.  We must strip everything past the first \":\",\n+dnl and everything past the last \"/\".\n+AC_OUTPUT_COMMANDS(changequote(<<,>>)dnl\n+ifelse(patsubst(<<$1>>, <<[^ ]>>, <<>>), <<>>,\n+<<test -z \"<<$>>CONFIG_HEADERS\" || echo timestamp > patsubst(<<$1>>, <<^\\([^:]*/\\)?.*>>, <<\\1>>)stamp-h<<>>dnl>>,\n+<<am_indx=1\n+for am_file in <<$1>>; do\n+  case \" <<$>>CONFIG_HEADERS \" in\n+  *\" <<$>>am_file \"*<<)>>\n+    echo timestamp > `echo <<$>>am_file | sed -e 's%:.*%%' -e 's%[^/]*$%%'`stamp-h$am_indx\n+    ;;\n+  esac\n+  am_indx=`expr \"<<$>>am_indx\" + 1`\n+done<<>>dnl>>)\n+changequote([,]))])\n+\n+# Check whether LC_MESSAGES is available in <locale.h>.\n+# Ulrich Drepper <drepper@cygnus.com>, 1995.\n+#\n+# This file file be copied and used freely without restrictions.  It can\n+# be used in projects which are not available under the GNU Public License\n+# but which still want to provide support for the GNU gettext functionality.\n+# Please note that the actual code is *not* freely available.\n+\n+# serial 1\n+\n+AC_DEFUN(AC_LC_MESSAGES,\n+  [if test $ac_cv_header_locale_h = yes; then\n+    AC_CACHE_CHECK([for LC_MESSAGES], ac_cv_val_LC_MESSAGES,\n+      [AC_TRY_LINK([#include <locale.h>], [return LC_MESSAGES],\n+       ac_cv_val_LC_MESSAGES=yes, ac_cv_val_LC_MESSAGES=no)])\n+    if test $ac_cv_val_LC_MESSAGES = yes; then\n+      AC_DEFINE(HAVE_LC_MESSAGES)\n+    fi\n+  fi])\n+"}, {"sha": "b46d3242309fedea7e34b4fd0fc00b19272cc489", "filename": "libstdc++-v3/backward/algo.h", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Falgo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Falgo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Falgo.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,114 @@\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1996,1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef _CPP_BACKWARD_ALGO_H\n+#define _CPP_BACKWARD_ALGO_H 1\n+\n+#include \"algobase.h\"\n+#include \"tempbuf.h\"\n+#include <bits/stl_algo.h>\n+#include <bits/stl_numeric.h>\n+\n+#ifdef __STL_USE_NAMESPACES\n+\n+// Names from <stl_algo.h>\n+using __STD::for_each; \n+using __STD::find; \n+using __STD::find_if; \n+using __STD::adjacent_find; \n+using __STD::count; \n+using __STD::count_if; \n+using __STD::search; \n+using __STD::search_n; \n+using __STD::swap_ranges; \n+using __STD::transform; \n+using __STD::replace; \n+using __STD::replace_if; \n+using __STD::replace_copy; \n+using __STD::replace_copy_if; \n+using __STD::generate; \n+using __STD::generate_n; \n+using __STD::remove; \n+using __STD::remove_if; \n+using __STD::remove_copy; \n+using __STD::remove_copy_if; \n+using __STD::unique; \n+using __STD::unique_copy; \n+using __STD::reverse; \n+using __STD::reverse_copy; \n+using __STD::rotate; \n+using __STD::rotate_copy; \n+using __STD::random_shuffle; \n+using __STD::random_sample; \n+using __STD::random_sample_n; \n+using __STD::partition; \n+using __STD::stable_partition; \n+using __STD::sort; \n+using __STD::stable_sort; \n+using __STD::partial_sort; \n+using __STD::partial_sort_copy; \n+using __STD::nth_element; \n+using __STD::lower_bound; \n+using __STD::upper_bound; \n+using __STD::equal_range; \n+using __STD::binary_search; \n+using __STD::merge; \n+using __STD::inplace_merge; \n+using __STD::includes; \n+using __STD::set_union; \n+using __STD::set_intersection; \n+using __STD::set_difference; \n+using __STD::set_symmetric_difference; \n+using __STD::min_element; \n+using __STD::max_element; \n+using __STD::next_permutation; \n+using __STD::prev_permutation; \n+using __STD::find_first_of; \n+using __STD::find_end; \n+using __STD::is_sorted; \n+using __STD::is_heap; \n+\n+// Names from stl_heap.h\n+using __STD::push_heap;\n+using __STD::pop_heap;\n+using __STD::make_heap;\n+using __STD::sort_heap;\n+\n+// Names from stl_numeric.h\n+using __STD::accumulate; \n+using __STD::inner_product; \n+using __STD::partial_sum; \n+using __STD::adjacent_difference; \n+using __STD::power; \n+using __STD::iota; \n+\n+#endif /* __STL_USE_NAMESPACES */\n+\n+#endif /* _CPP_BACKWARD_ALGO_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "b5c807a882fbb586af238b9320e68e6d989c7752", "filename": "libstdc++-v3/backward/algobase.h", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Falgobase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Falgobase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Falgobase.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,71 @@\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ * Copyright (c) 1996,1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef _CPP_BACKWARD_ALGOBASE_H\n+#define _CPP_BACKWARD_ALGOBASE_H 1\n+\n+#ifndef _CPP_BACKWARD_PAIR_H\n+#include \"pair.h\"\n+#endif\n+#ifndef _CPP_BACKWARD_ITERATOR_H\n+#include \"iterator.h\"\n+#endif\n+#ifndef _CPP_BITS_STL__ALGOBASE_H\n+#include <bits/stl_algobase.h>\n+#endif\n+#ifndef _CPP_BITS_STL_UNINITIALIZED_H\n+#include <bits/stl_uninitialized.h>\n+#endif\n+\n+#ifdef __STL_USE_NAMESPACES\n+\n+// Names from stl_algobase.h\n+using __STD::iter_swap; \n+using __STD::swap; \n+using __STD::min; \n+using __STD::max; \n+using __STD::copy; \n+using __STD::copy_backward; \n+using __STD::copy_n; \n+using __STD::fill; \n+using __STD::fill_n; \n+using __STD::mismatch; \n+using __STD::equal; \n+using __STD::lexicographical_compare; \n+using __STD::lexicographical_compare_3way; \n+\n+// Names from stl_uninitialized.h\n+using __STD::uninitialized_copy;\n+using __STD::uninitialized_copy_n;\n+using __STD::uninitialized_fill;\n+using __STD::uninitialized_fill_n;\n+\n+#endif /* __STL_USE_NAMESPACES */\n+\n+#endif /* _CPP_BACKWARD_ALGOBASE_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "d0e4ba3766c1eb8964f057596d25663a6a946b51", "filename": "libstdc++-v3/backward/alloc.h", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Falloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Falloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Falloc.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,46 @@\n+/*\n+ * Copyright (c) 1996-1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef _CPP_BACKWARD_ALLOC_H\n+#define _CPP_BACKWARD_ALLOC_H 1\n+\n+#ifndef _CPP_BITS_STL_CONFIG_H\n+#include <bits/stl_config.h>\n+#endif\n+#ifndef _CPP_BITS_STL_ALLOC_H\n+#include <bits/stl_alloc.h>\n+#endif\n+\n+#ifdef __STL_USE_NAMESPACES\n+\n+using __STD::__malloc_alloc_template; \n+using __STD::malloc_alloc; \n+using __STD::simple_alloc; \n+using __STD::debug_alloc; \n+using __STD::__default_alloc_template; \n+using __STD::alloc; \n+using __STD::single_client_alloc; \n+#ifdef __STL_STATIC_TEMPLATE_MEMBER_BUG\n+using __STD::__malloc_alloc_oom_handler; \n+#endif /* __STL_STATIC_TEMPLATE_MEMBER_BUG */\n+#ifdef __STL_USE_STD_ALLOCATORS \n+using __STD::allocator;\n+#endif /* __STL_USE_STD_ALLOCATORS */\n+\n+#endif /* __STL_USE_NAMESPACES */\n+\n+#endif /* _CPP_BACKWARD_ALLOC_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "ed9225404858ba8e8d210252f4532a63680c073b", "filename": "libstdc++-v3/backward/bvector.h", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Fbvector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Fbvector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Fbvector.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,51 @@\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1996\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef _CPP_BACKWARD_BVECTOR_H\n+#define _CPP_BACKWARD_BVECTOR_H 1\n+\n+#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n+#include \"vector.h\"\n+#else\n+#include \"algobase.h\"\n+#include \"alloc.h\"\n+#endif \n+\n+#include <bits/stl_bvector.h>\n+\n+#ifdef __STL_USE_NAMESPACES\n+\n+using __STD::bit_vector;\n+\n+#endif /* __STL_USE_NAMESPACES */\n+\n+#endif /* _CPP_BACKWARD_BVECTOR_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:\n+\n+"}, {"sha": "8edee690bc6f98dad2ad0a9d81aac04fd1055cf7", "filename": "libstdc++-v3/backward/defalloc.h", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Fdefalloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Fdefalloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Fdefalloc.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,87 @@\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ */\n+\n+// Inclusion of this file is DEPRECATED.  This is the original HP\n+// default allocator.  It is provided only for backward compatibility.\n+// This file WILL BE REMOVED in a future release.\n+//\n+// DO NOT USE THIS FILE unless you have an old container implementation\n+// that requires an allocator with the HP-style interface.  \n+//\n+// Standard-conforming allocators have a very different interface.  The\n+// standard default allocator is declared in the header <memory>.\n+\n+#ifndef _CPP_BACKWARD_DEFALLOC_H\n+#define _CPP_BACKWARD_DEFALLOC_H 1\n+\n+#include \"new.h\"\n+#include <stddef.h>\n+#include <stdlib.h>\n+#include <limits.h> \n+#include \"iostream.h\" \n+#include \"algobase.h\"\n+\n+\n+template <class _Tp>\n+inline _Tp* allocate(ptrdiff_t __size, _Tp*) {\n+    set_new_handler(0);\n+    _Tp* __tmp = (_Tp*)(::operator new((size_t)(__size * sizeof(_Tp))));\n+    if (__tmp == 0) {\n+\tcerr << \"out of memory\" << endl; \n+\texit(1);\n+    }\n+    return __tmp;\n+}\n+\n+\n+template <class _Tp>\n+inline void deallocate(_Tp* __buffer) {\n+    ::operator delete(__buffer);\n+}\n+\n+template <class _Tp>\n+class allocator {\n+public:\n+    typedef _Tp value_type;\n+    typedef _Tp* pointer;\n+    typedef const _Tp* const_pointer;\n+    typedef _Tp& reference;\n+    typedef const _Tp& const_reference;\n+    typedef size_t size_type;\n+    typedef ptrdiff_t difference_type;\n+    pointer allocate(size_type __n) { \n+\treturn ::allocate((difference_type)__n, (pointer)0);\n+    }\n+    void deallocate(pointer __p) { ::deallocate(__p); }\n+    pointer address(reference __x) { return (pointer)&__x; }\n+    const_pointer const_address(const_reference __x) { \n+\treturn (const_pointer)&__x; \n+    }\n+    size_type init_page_size() { \n+\treturn max(size_type(1), size_type(4096/sizeof(_Tp))); \n+    }\n+    size_type max_size() const { \n+\treturn max(size_type(1), size_type(UINT_MAX/sizeof(_Tp))); \n+    }\n+};\n+\n+class allocator<void> {\n+public:\n+    typedef void* pointer;\n+};\n+\n+\n+\n+#endif /* _CPP_BACKWARD_DEFALLOC_H */"}, {"sha": "fc47056c5ee4a5e6aa1b7c41c6c5f34813654d1d", "filename": "libstdc++-v3/backward/deque.h", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Fdeque.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Fdeque.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Fdeque.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,42 @@\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef _CPP_BACKWARD_DEQUE_H\n+#define _CPP_BACKWARD_DEQUE_H 1\n+\n+#include \"algobase.h\"\n+#include \"alloc.h\"\n+#include <bits/std_deque.h>\n+\n+#ifdef __STL_USE_NAMESPACES\n+using __STD::deque;\n+#endif /* __STL_USE_NAMESPACES */\n+\n+#endif /* _CPP_BACKWARD_DEQUE_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "7988ae99c2b2fce0a408598b2cc7a437744214bb", "filename": "libstdc++-v3/backward/function.h", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Ffunction.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,118 @@\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1996,1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef _CPP_BACKWARD_FUNCTION_H\n+#define _CPP_BACKWARD_FUNCTION_H 1\n+\n+#ifndef _CPP_BITS_STL_CONFIG_H\n+#include <bits/stl_config.h>\n+#endif\n+#ifndef _CPP_BITS_STL_RELOPS\n+#include <bits/stl_relops.h>\n+#endif\n+#include <stddef.h>\n+#ifndef _CPP_BITS_STL_FUNCTION_H\n+#include <bits/stl_function.h>\n+#endif\n+\n+#ifdef __STL_USE_NAMESPACE_FOR_RELOPS\n+\n+// Names from stl_relops.h\n+using __STD_RELOPS::operator!=;\n+using __STD_RELOPS::operator>;\n+using __STD_RELOPS::operator<=;\n+using __STD_RELOPS::operator>=;\n+\n+#endif /* __STL_USE_NAMESPACE_FOR_RELOPS */\n+\n+#ifdef __STL_USE_NAMESPACES\n+\n+// Names from stl_function.h\n+using __STD::unary_function; \n+using __STD::binary_function; \n+using __STD::plus; \n+using __STD::minus; \n+using __STD::multiplies; \n+using __STD::divides; \n+using __STD::identity_element; \n+using __STD::modulus; \n+using __STD::negate; \n+using __STD::equal_to; \n+using __STD::not_equal_to; \n+using __STD::greater; \n+using __STD::less; \n+using __STD::greater_equal; \n+using __STD::less_equal; \n+using __STD::logical_and; \n+using __STD::logical_or; \n+using __STD::logical_not; \n+using __STD::unary_negate; \n+using __STD::binary_negate; \n+using __STD::not1; \n+using __STD::not2; \n+using __STD::binder1st; \n+using __STD::binder2nd; \n+using __STD::bind1st; \n+using __STD::bind2nd; \n+using __STD::unary_compose; \n+using __STD::binary_compose; \n+using __STD::compose1; \n+using __STD::compose2; \n+using __STD::pointer_to_unary_function; \n+using __STD::pointer_to_binary_function; \n+using __STD::ptr_fun; \n+using __STD::identity; \n+using __STD::select1st; \n+using __STD::select2nd; \n+using __STD::project1st; \n+using __STD::project2nd; \n+using __STD::constant_void_fun; \n+using __STD::constant_unary_fun; \n+using __STD::constant_binary_fun; \n+using __STD::constant0; \n+using __STD::constant1; \n+using __STD::constant2; \n+using __STD::subtractive_rng; \n+using __STD::mem_fun_t; \n+using __STD::const_mem_fun_t; \n+using __STD::mem_fun_ref_t; \n+using __STD::const_mem_fun_ref_t; \n+using __STD::mem_fun1_t; \n+using __STD::const_mem_fun1_t; \n+using __STD::mem_fun1_ref_t; \n+using __STD::const_mem_fun1_ref_t; \n+using __STD::mem_fun; \n+using __STD::mem_fun_ref; \n+using __STD::mem_fun1; \n+using __STD::mem_fun1_ref; \n+\n+#endif /* __STL_USE_NAMESPACES */\n+\n+#endif /* _CPP_BACKWARD_FUNCTION_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "ebf0cb8f84be3c9c0dc9a78f98abc4b62bf16955", "filename": "libstdc++-v3/backward/hash_map.h", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Fhash_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Fhash_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Fhash_map.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,49 @@\n+/*\n+ * Copyright (c) 1996\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ */\n+\n+#ifndef _CPP_BACKWARD_HASH_MAP_H\n+#define _CPP_BACKWARD_HASH_MAP_H 1\n+\n+#ifndef _CPP_BITS_STL_HASHTABLE_H\n+#include <bits/stl_hashtable.h>\n+#endif \n+\n+#include \"algobase.h\"\n+#include <bits/stl_hash_map.h>\n+\n+#ifdef __STL_USE_NAMESPACES\n+using __STD::hash;\n+using __STD::hashtable;\n+using __STD::hash_map;\n+using __STD::hash_multimap;\n+#endif /* __STL_USE_NAMESPACES */\n+\n+\n+#endif /* _CPP_BACKWARD_HASH_MAP_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "140ce6048c6d1a64943453ef9bb81f30af641413", "filename": "libstdc++-v3/backward/hash_set.h", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Fhash_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Fhash_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Fhash_set.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright (c) 1996\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ */\n+\n+#ifndef _CPP_BACKWARD_HASH_SET_H\n+#define _CPP_BACKWARD_HASH_SET_H 1\n+\n+#ifndef _CPP_BITS_STL_HASHTABLE_H\n+#include <bits/stl_hashtable.h>\n+#endif \n+\n+#include \"algobase.h\"\n+#include <bits/stl_hash_set.h>\n+\n+#ifdef __STL_USE_NAMESPACES\n+using __STD::hash;\n+using __STD::hashtable;\n+using __STD::hash_set;\n+using __STD::hash_multiset;\n+#endif /* __STL_USE_NAMESPACES */\n+\n+#endif /* _CPP_BACKWARD_HASH_SET_H */"}, {"sha": "bd0f4f47433f3c3d2f72c5b733b0f84f16c9d48e", "filename": "libstdc++-v3/backward/hashtable.h", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Fhashtable.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright (c) 1996,1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ */\n+\n+/* NOTE: This is an internal header file, included by other STL headers.\n+ *   You should not attempt to use it directly.\n+ */\n+\n+#ifndef _CPP_BACKWARD_HASHTABLE_H\n+#define _CPP_BACKWARD_HASHTABLE_H 1\n+\n+#include <bits/stl_hashtable.h>\n+#include \"algo.h\"\n+#include \"alloc.h\"\n+#include \"vector.h\"\n+\n+#ifdef __STL_USE_NAMESPACES\n+using __STD::hash;\n+using __STD::hashtable;\n+#endif /* __STL_USE_NAMESPACES */\n+\n+#endif /* _CPP_BACKWARD_HASHTABLE_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "0256fc62e7ed7b4fa06ef717491f88d68aa78212", "filename": "libstdc++-v3/backward/heap.h", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Fheap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Fheap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Fheap.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,46 @@\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ * Copyright (c) 1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef _CPP_BACKWARD_HEAP_H\n+#define _CPP_BACKWARD_HEAP_H 1\n+\n+#include <bits/stl_config.h>\n+#include <bits/stl_heap.h>\n+\n+#ifdef __STL_USE_NAMESPACES\n+\n+using __STD::push_heap;\n+using __STD::pop_heap;\n+using __STD::make_heap;\n+using __STD::sort_heap;\n+\n+#endif /* __STL_USE_NAMESPACES */\n+\n+\n+#endif /* _CPP_BACKWARD_HEAP_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "617cde418e6b0cd42545d48840deac2f90c448b9", "filename": "libstdc++-v3/backward/iostream.h", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Fiostream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Fiostream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Fiostream.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,55 @@\n+\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _CPP_BACKWARD_IOSTREAM_H\n+#define _CPP_BACKWARD_IOSTREAM_H 1\n+\n+#include <bits/std_iostream.h>\n+\n+#ifdef __STL_USE_NAMESPACES\n+using __STD::iostream;\n+using __STD::ostream;\n+using __STD::istream;\n+using __STD::ios;\n+using __STD::streambuf;\n+\n+using __STD::cout;\n+using __STD::cin;\n+using __STD::cerr;\n+using __STD::clog;\n+using __STD::wcout;\n+using __STD::wcin;\n+using __STD::wcerr;\n+using __STD::wclog;\n+#endif /* __STL_USE_NAMESPACES */\n+\n+#endif /* _CPP_BACKWARD_IOSTREAM_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "40185036b3be9f1d2804c25bb0adef66db00af2b", "filename": "libstdc++-v3/backward/iterator.h", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Fiterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Fiterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Fiterator.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,104 @@\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1996\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef _CPP_BACKWARD_ITERATOR_H\n+#define _CPP_BACKWARD_ITERATOR_H 1\n+\n+#ifndef _CPP_BACKWARD_FUNCTION_H\n+#include \"function.h\"\n+#endif\n+#include <stddef.h>\n+#include \"iostream.h\"\n+#ifndef _CPP_BITS_STL_ITERATOR_H\n+#include <bits/stl_iterator.h>\n+#endif\n+#ifndef _CPP_BITS_TYPE_TRAITS_H\n+#include <bits/type_traits.h>\n+#endif\n+#ifndef _CPP_BITS_STL_CONSTRUCT_H\n+#include <bits/stl_construct.h>\n+#endif\n+#ifndef _CPP_BITS_STL_RAW_STORAGE_ITERATOR_H\n+#include <bits/stl_raw_storage_iter.h>\n+#endif\n+\n+#ifdef __STL_USE_NAMESPACES\n+\n+// Names from stl_iterator.h\n+\n+using __STD::input_iterator_tag;\n+using __STD::output_iterator_tag;\n+using __STD::forward_iterator_tag;\n+using __STD::bidirectional_iterator_tag;\n+using __STD::random_access_iterator_tag;\n+\n+#if 0\n+using __STD::iterator;\n+#endif\n+using __STD::input_iterator;\n+using __STD::output_iterator;\n+using __STD::forward_iterator;\n+using __STD::bidirectional_iterator;\n+using __STD::random_access_iterator;\n+\n+#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n+using __STD::iterator_traits;\n+#endif\n+\n+using __STD::iterator_category;\n+using __STD::distance_type;\n+using __STD::value_type;\n+\n+using __STD::distance; \n+using __STD::advance; \n+\n+using __STD::insert_iterator;\n+using __STD::front_insert_iterator;\n+using __STD::back_insert_iterator;\n+using __STD::inserter;\n+using __STD::front_inserter;\n+using __STD::back_inserter;\n+\n+using __STD::reverse_iterator;\n+using __STD::reverse_bidirectional_iterator;\n+\n+using __STD::istream_iterator;\n+using __STD::ostream_iterator;\n+\n+// Names from stl_construct.h\n+using __STD::construct;\n+using __STD::destroy;\n+\n+// Names from stl_raw_storage_iter.h\n+using __STD::raw_storage_iterator;\n+\n+#endif /* __STL_USE_NAMESPACES */\n+\n+#endif /* _CPP_BACKWARD_ITERATOR_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "9a719ff95941d08332a9832d1d7099ac755d24d2", "filename": "libstdc++-v3/backward/list.h", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Flist.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Flist.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Flist.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,42 @@\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1996,1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef _CPP_BACKWARD_LIST_H\n+#define _CPP_BACKWARD_LIST_H 1\n+\n+#include <bits/stl_algobase.h>\n+#include \"alloc.h\"\n+#include <bits/std_list.h>\n+\n+#ifdef __STL_USE_NAMESPACES\n+using __STD::list;\n+#endif /* __STL_USE_NAMESPACES */\n+\n+#endif /* _CPP_BACKWARD_LIST_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "cf0fe2bc638876955a44180f212e281e98111795", "filename": "libstdc++-v3/backward/map.h", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Fmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Fmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Fmap.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,41 @@\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1996,1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef _CPP_BACKWARD_MAP_H\n+#define _CPP_BACKWARD_MAP_H 1\n+\n+#include \"tree.h\"\n+#include <bits/stl_map.h>\n+\n+#ifdef __STL_USE_NAMESPACES\n+using __STD::map;\n+#endif /* __STL_USE_NAMESPACES */\n+\n+#endif /* _CPP_BACKWARD_MAP_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "157e3331aa90d4562d3f6177fffa5eea480c4e91", "filename": "libstdc++-v3/backward/multimap.h", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Fmultimap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Fmultimap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Fmultimap.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,41 @@\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1996,1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef _CPP_BACKWARD_MULTIMAP_H\n+#define _CPP_BACKWARD_MULTIMAP_H 1\n+\n+#include \"tree.h\"\n+#include <bits/stl_multimap.h>\n+\n+#ifdef __STL_USE_NAMESPACES\n+using __STD::multimap;\n+#endif /* __STL_USE_NAMESPACES */\n+\n+#endif /* _CPP_BACKWARD_MULTIMAP_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "270a5da8ca348f3c6aa91159041e4beb4c0bfae7", "filename": "libstdc++-v3/backward/multiset.h", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Fmultiset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Fmultiset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Fmultiset.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,41 @@\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1996,1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef _CPP_BACKWARD_MULTISET_H\n+#define _CPP_BACKWARD_MULTISET_H 1\n+\n+#include \"tree.h\"\n+#include <bits/stl_multiset.h>\n+\n+#ifdef __STL_USE_NAMESPACES\n+using __STD::multiset;\n+#endif /* __STL_USE_NAMESPACES */\n+\n+#endif /* _CPP_BACKWARD_MULTISET_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "20e57dee8de66c364ff9e63479fabf9b833302d9", "filename": "libstdc++-v3/backward/new.h", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Fnew.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Fnew.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Fnew.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,46 @@\n+\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _CPP_BACKWARD_NEW_H\n+#define _CPP_BACKWARD_NEW_H 1\n+\n+#include <bits/std_new.h>\n+\n+#ifdef __STL_USE_NAMESPACES\n+using __STD::bad_alloc;\n+using __STD::nothrow_t;\n+using __STD::nothrow;\n+using __STD::new_handler;\n+using __STD::set_new_handler;\n+#endif /* __STL_USE_NAMESPACES */\n+\n+#endif /* _CPP_BACKWARD_NEW_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "275a205bb6ea935bcff263070e11815ce3c3bab7", "filename": "libstdc++-v3/backward/pair.h", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Fpair.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Fpair.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Fpair.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,51 @@\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1996,1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef _CPP_BACKWARD_PAIR_H\n+#define _CPP_BACKWARD_PAIR_H 1\n+\n+#ifndef _CPP_BITS_STL_CONFIG_H\n+#include <bits/stl_config.h>\n+#endif\n+#ifndef _CPP_BITS_STL_RELOPS_H\n+#include <bits/stl_relops.h>\n+#endif\n+#ifndef _CPP_BITS_STL_PAIR_H\n+#include <bits/stl_pair.h>\n+#endif\n+\n+#ifdef __STL_USE_NAMESPACES\n+\n+using __STD::pair;\n+using __STD::make_pair;\n+\n+#endif /* __STL_USE_NAMESPACES */\n+\n+#endif /* _CPP_BACKWARD_PAIR_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "7d32f87497ed88f298e09a32cf8c77625cfd0896", "filename": "libstdc++-v3/backward/rope.h", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Frope.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Frope.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Frope.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright (c) 1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef _CPP_BACKWARD_ROPE_H\n+#define _CPP_BACKWARD_ROPE_H 1\n+\n+#include \"hashtable.h\"   \n+#include <bits/stl_rope.h>\n+\n+#ifdef __STL_USE_NAMESPACES\n+\n+using __STD::char_producer; \n+using __STD::sequence_buffer; \n+using __STD::rope; \n+using __STD::crope; \n+using __STD::wrope; \n+\n+#endif /* __STL_USE_NAMESPACES */\n+\n+#endif /* _CPP_BACKWARD_ROPE_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "e05890e046efda61860ff70467ae9ac277f89a82", "filename": "libstdc++-v3/backward/set.h", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Fset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Fset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Fset.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,41 @@\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1996,1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef _CPP_BACKWARD_SET_H\n+#define _CPP_BACKWARD_SET_H 1\n+\n+#include \"tree.h\"\n+#include <bits/stl_set.h>\n+\n+#ifdef __STL_USE_NAMESPACES\n+using __STD::set;\n+#endif /* __STL_USE_NAMESPACES */\n+\n+#endif /* _CPP_BACKWARD_SET_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "8c63282d1ca06fb1306a65da2bcdab76e7d53f5a", "filename": "libstdc++-v3/backward/slist.h", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Fslist.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Fslist.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Fslist.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,28 @@\n+/*\n+ * Copyright (c) 1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ */\n+\n+#ifndef _CPP_BACKWARD_SLIST_H\n+#define _CPP_BACKWARD_SLIST_H 1\n+\n+#include <ext/slist>\n+\n+#ifdef __STL_USE_NAMESPACES\n+using __STD::slist;\n+#endif /* __STL_USE_NAMESPACES */\n+\n+#endif /* _CPP_BACKWARD_SLIST_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "4140f409970ced8132af43be08c24cd9aaef287c", "filename": "libstdc++-v3/backward/stack.h", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Fstack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Fstack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Fstack.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,46 @@\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1996,1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef _CPP_BACKWARD_STACK_H\n+#define _CPP_BACKWARD_STACK_H 1\n+\n+#include \"vector.h\"\n+#include \"deque.h\"\n+#include \"heap.h\"\n+#include <bits/stl_stack.h>\n+#include <bits/stl_queue.h>\n+\n+#ifdef __STL_USE_NAMESPACES\n+using __STD::stack;\n+using __STD::queue;\n+using __STD::priority_queue;\n+#endif /* __STL_USE_NAMESPACES */\n+\n+#endif /* _CPP_BACKWARD_STACK_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "82e5c8e811b17927f3551f29bc53ec159966758d", "filename": "libstdc++-v3/backward/tempbuf.h", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Ftempbuf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Ftempbuf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Ftempbuf.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,62 @@\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1996\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef _CPP_BACKWARD_TEMPBUF_H\n+#define _CPP_BACKWARD_TEMPBUF_H 1\n+\n+#ifndef _CPP_BACKWARD_PAIR_H\n+#include \"pair.h\"\n+#endif\n+#include <iterator.h>\n+#include <limits.h>\n+#include <stddef.h> \n+#include <stdlib.h> \n+#ifndef _CPP_BITS_TYPE_TRAITS_H\n+#include <bits/type_traits.h>  \n+#endif\n+#ifndef _CPP_BITS_STL_CONSTRUCT_H\n+#include <bits/stl_construct.h>\n+#endif\n+#ifndef _CPP_BITS_STL_UNINITIALIZED_H\n+#include <bits/stl_uninitialized.h>\n+#endif\n+#ifndef _CPP_BITS_STL_TEMPBUF_H\n+#include <bits/stl_tempbuf.h>\n+#endif\n+\n+#ifdef __STL_USE_NAMESPACES\n+\n+using __STD::get_temporary_buffer;\n+using __STD::return_temporary_buffer;\n+using __STD::_Temporary_buffer;\n+\n+#endif /* __STL_USE_NAMESPACES */\n+\n+#endif /* _CPP_BACKWARD_TEMPBUF_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "64e89ad36fe880c71645008e08549d0e7c95cbd9", "filename": "libstdc++-v3/backward/tree.h", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Ftree.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,46 @@\n+/*\n+ *\n+ * Copyright (c) 1996,1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ */\n+\n+#ifndef _CPP_BACKWARD_TREE_H\n+#define _CPP_BACKWARD_TREE_H 1\n+\n+#ifndef _CPP_BITS_STL_TREE_H\n+#include <bits/stl_tree.h>\n+#endif\n+#include \"algobase.h\" \n+#include \"alloc.h\"\n+\n+#ifdef __STL_USE_NAMESPACES\n+using __STD::rb_tree;\n+#endif /* __STL_USE_NAMESPACES */\n+\n+#endif /* _CPP_BACKWARD_TREE_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "8a7e8f940401a653ea03ad82747a6c29a2d2808c", "filename": "libstdc++-v3/backward/vector.h", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Fvector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbackward%2Fvector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Fvector.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,42 @@\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1996\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef _CPP_BACKWARD_VECTOR_H\n+#define _CPP_BACKWARD_VECTOR_H 1\n+\n+#include \"algobase.h\"\n+#include \"alloc.h\"  \n+#include <bits/stl_vector.h>\n+\n+#ifdef __STL_USE_NAMESPACES\n+using __STD::vector;\n+#endif /* __STL_USE_NAMESPACES */\n+\n+#endif /* _CPP_BACKWARD_VECTOR_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "71fdb018f3e0952cb6b8d049294914324684e466", "filename": "libstdc++-v3/bits/basic_file.h", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fbasic_file.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fbasic_file.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fbasic_file.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,174 @@\n+// Wrapper of C-language FILE struct -*- C++ -*-\n+\n+// Copyright (C) 1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 27.8  File-based streams\n+//\n+\n+#ifndef _CPP_BASIC_FILE\n+#define _CPP_BASIC_FILE\t\t1\n+\n+#include <bits/c++config.h>\n+#include <bits/std_ios.h>\n+\n+namespace std {\n+  \n+  // Some of these member functions are based on libio/filebuf.cc.\n+  // Also note that the order and number of virtual functions has to precisely\n+  // match the order and number in the _IO_jump_t struct defined in libioP.h.\n+#if _GLIBCPP_BASIC_FILE_INHERITANCE\n+  class __basic_file: public __c_file_type\n+#else\n+  class __basic_file\n+#endif\n+  {\n+#if _GLIBCPP_BASIC_FILE_ENCAPSULATION\n+    int _M_fileno;\n+    __c_file_type* _M_cfile;\n+#endif\n+\n+  public:\n+    __basic_file(__c_lock* __lock = 0);\n+\n+    // Eqivalent to the normal fopen function.\n+    __basic_file* \n+    open(const char* __name, ios_base::openmode __mode, int __prot = 0664);\n+\n+    // Used for opening the standard streams, cin, cout, cerr, clog,\n+    // and their wide-stream equivalents. Instead of calling open, it\n+    // just sets __c_file_type->_fileno and the respective _flags bits, and\n+    // returns.\n+    __basic_file*\n+    sys_open(int __fd, ios_base::openmode __mode);\n+\n+    __basic_file* \n+    close(); \n+\n+    bool \n+    is_open();\n+\n+    // Needed by ios_base::sync_with_stdio.\n+    int get_fileno(void);\n+\n+    // NB: Must match FILE specific jump table starting here--this\n+    // means all virtual functions starting with the dtor must match,\n+    // slot by slot. For glibc-based dystems, this means the _IO_FILE\n+    // as the FILE struct and _IO_jump_t as the jump table.\n+    virtual \n+    ~__basic_file(); // Takes the place of __finish.\n+\n+    virtual int \n+    overflow(int __c = EOF);\n+\n+    virtual int \n+    underflow();\n+\n+    virtual int \n+    uflow();\n+\n+    virtual int \n+    pbackfail(int __c);\n+\n+    // A complex \"write\" function that sets all of __c_file_type's\n+    // ponters and associated data members correctly and manages it's\n+    // relation to the external byte sequence.\n+    virtual streamsize \n+    xsputn(const char* __s, streamsize __n);\n+\n+    // A complex \"read\" function that sets all of __c_file_type's\n+    // ponters and associated data members correctly and manages it's\n+    // relation to the external byte sequence.\n+    virtual streamsize \n+    xsgetn(char* __s, streamsize __n);\n+\n+    // A complex \"seekoff\" function that sets all of __c_file_type's\n+    // ponters and associated data members correctly and manages it's\n+    // relation to the external byte sequence.\n+    virtual __c_streampos \n+    seekoff(streamoff __off, ios_base::seekdir __way,\n+\t    ios_base::openmode __mode = ios_base::in | ios_base::out);\n+\n+    // A complex \"seekpos\" function that sets all of __c_file_type's\n+    // pointers and associated data members correctly and manages it's\n+    // relation to the external byte sequence.\n+    virtual __c_streampos \n+    seekpos(__c_streampos __pos, \n+\t    ios_base::openmode __mode = ios_base::in | ios_base::out);\n+\n+    virtual streambuf* \n+    setbuf(char* __b, int __len);\n+\n+    virtual int \n+    sync();\n+\n+    virtual int \n+    doallocate();\n+\n+    // A simple read function for the external byte sequence, that\n+    // does no mucking around with or setting of the pointers or flags\n+    // in __c_file_type.\n+    virtual streamsize \n+    sys_read(char* __s, streamsize __n);\n+\n+    // A simple write function for the external byte sequence, that\n+    // does no mucking around with or setting of the pointers or flags\n+    // in __c_file_type.\n+    virtual streamsize \n+    sys_write(const char* __s, streamsize __n);\n+\n+    // A simple seek function for the external byte sequence, that\n+    // does no mucking around with or setting of the pointers or flags\n+    // in __c_file_type.\n+    virtual __c_streampos \n+    sys_seek(__c_streampos __off, ios_base::seekdir __way);\n+\n+    virtual int \n+    sys_close();\n+\n+    virtual int \n+    sys_stat(void* __v);\n+\n+    virtual int \n+    showmanyc();\n+\n+    virtual void \n+    imbue(void* __v);\n+    };\n+\n+} // namespace std\n+\n+#endif\t/* _CPP_BASIC_FILE */\n+\n+\n+\n+\n+\n+\n+\n+"}, {"sha": "8168ec0827b8936b605e51ab0d128660e1cbf9b4", "filename": "libstdc++-v3/bits/basic_ios.h", "status": "added", "additions": 216, "deletions": 0, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fbasic_ios.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fbasic_ios.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fbasic_ios.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,216 @@\n+// Iostreams base classes -*- C++ -*-\n+\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _CPP_BITS_BASICIOS_H\n+#define _CPP_BITS_BASICIOS_H 1\n+\n+#include <bits/sbuf_iter.h>\n+\n+namespace std {\n+\n+  // 27.4.5  Template class basic_ios\n+  template<typename _CharT, typename _Traits>\n+    class basic_ios : public ios_base\n+    {\n+    public:\n+\n+      // Types:\n+      typedef _CharT \t\t\t\tchar_type;\n+      typedef typename _Traits::int_type \tint_type;\n+      typedef typename _Traits::pos_type \tpos_type;\n+      typedef typename _Traits::off_type \toff_type;\n+      typedef _Traits \t\t\t\ttraits_type;\n+\n+      // Non-standard Types:\n+      typedef ctype<_CharT>           \t\t__ctype_type;\n+      // From ostream\n+      typedef ostreambuf_iterator<_CharT>\t\t__ostreambuf_iter;\n+      typedef num_put<_CharT, __ostreambuf_iter>        __numput_type;\n+      typedef istreambuf_iterator<_CharT>\t\t__istreambuf_iter;\n+      typedef num_get<_CharT, __istreambuf_iter>        __numget_type;\n+      \n+      // Data members:\n+    private:\n+      basic_ostream<_CharT, _Traits>* \t_M_tie;\n+      char_type \t\t\t_M_fill;\n+      iostate \t\t\t\t_M_exception;\n+\n+    protected:\n+      basic_streambuf<_CharT, _Traits>* _M_streambuf;\n+      iostate \t\t\t\t_M_streambuf_state;\n+\n+      // Cached use_facet<ctype>, which is based on the current locale info.\n+      const __ctype_type*\t\t_M_fctype_ios;      \n+      // From ostream.\n+      const __numput_type* \t\t_M_fnumput;\n+      // From istream.\n+      const __numget_type* \t\t_M_fnumget;\n+\n+    public:\n+\n+      inline const __ctype_type*\t\n+      _M_get_fctype_ios(void)\n+      { return _M_fctype_ios; }\n+\n+      inline const __numget_type* \n+      _M_get_fnumget(void)\n+      { return _M_fnumget; }\n+\n+      inline const __numput_type* \n+      _M_get_fnumput(void)\n+      { return _M_fnumput; }\n+\n+      operator void*() const \n+      { return this->fail() ? 0 : const_cast<basic_ios*>(this); }\n+\n+      inline bool \n+      operator!() const \n+      { return this->fail(); }\n+\n+      inline iostate \n+      rdstate() const \n+      { return _M_streambuf_state; }\n+\n+      inline void \n+      clear(iostate __state = goodbit)\n+      { \n+\tif (this->rdbuf())\n+\t  _M_streambuf_state = __state;\n+\telse\n+\t  _M_streambuf_state = __state | badbit;\n+\tif ((this->rdstate() & this->exceptions()))\n+\t  throw failure(\"basic_ios::clear(iostate) caused exception\");\n+      }\n+\n+      inline void \n+      setstate(iostate __state) \n+      { this->clear(this->rdstate() | __state); }\n+\n+      inline bool \n+      good() const \n+      { return this->rdstate() == 0; }\n+\n+      inline bool \n+      eof() const \n+      { return (this->rdstate() & eofbit) != 0; }\n+\n+      inline bool \n+      fail() const \n+      { return (this->rdstate() & (badbit | failbit)) != 0; }\n+\n+      inline bool \n+      bad() const \n+      { return (this->rdstate() & badbit) != 0; }\n+\n+      inline iostate \n+      exceptions() const \n+      { return _M_exception; }\n+\n+      inline void \n+      exceptions(iostate __except) \n+      { \n+\t_M_exception = __except; \n+\tthis->clear(_M_streambuf_state); \n+      }\n+\n+      // Constructor/destructor:\n+      explicit \n+      basic_ios(basic_streambuf<_CharT, _Traits>* __sb) : ios_base() \n+      { this->init(__sb); }\n+\n+      virtual \n+      ~basic_ios() { }\n+      \n+      // Members:\n+      inline basic_ostream<_CharT, _Traits>*\n+      tie() const      \n+      { return _M_tie; }\n+\n+      inline basic_ostream<_CharT, _Traits>*\n+      tie(basic_ostream<_CharT, _Traits>* __tiestr)\n+      {\n+\tbasic_ostream<_CharT, _Traits>* __old = _M_tie;\n+\t_M_tie = __tiestr;\n+\treturn __old;\n+      }\n+\n+      inline basic_streambuf<_CharT, _Traits>*\n+      rdbuf() const    \n+      { return _M_streambuf; }\n+\n+      basic_streambuf<_CharT, _Traits>* \n+      rdbuf(basic_streambuf<_CharT, _Traits>* __sb);\n+\n+      basic_ios&\n+      copyfmt(const basic_ios& __rhs);\n+\n+      inline char_type \n+      fill() const \n+      { return _M_fill; }\n+\n+      inline char_type \n+      fill(char_type __ch)\n+      {\n+\tchar_type __old = _M_fill;\n+\t_M_fill = __ch;\n+\treturn __old;\n+      }\n+\n+      // Locales:\n+      locale \n+      imbue(const locale& __loc);\n+\n+      char \n+      narrow(char_type __c, char __dfault) const;\n+\n+      char_type \n+      widen(char __c) const;\n+     \n+    protected:\n+      // 27.4.5.1  basic_ios constructors\n+      basic_ios() : ios_base() \n+      { }\n+\n+      void \n+      init(basic_streambuf<_CharT, _Traits>* __sb);\n+    };\n+  \n+} // namespace std\n+\n+#ifdef _GLIBCPP_NO_TEMPLATE_EXPORT\n+# define export\n+//#include <bits/basic_ios.tcc>\n+#endif\n+\n+#endif /* _CPP_BITS_BASICIOS_H */\n+\n+\n+\n+\n+"}, {"sha": "3c24e243ffdda4366f30c6da1a57b513ead2ce0c", "filename": "libstdc++-v3/bits/basic_ios.tcc", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fbasic_ios.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fbasic_ios.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fbasic_ios.tcc?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,142 @@\n+// basic_ios locale and locale-related member functions -*- C++ -*-\n+\n+// Copyright (C) 1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _CPP_BITS_BASICIOS_TCC\n+#define _CPP_BITS_BASICIOS_TCC 1\n+\n+namespace std {\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_streambuf<_CharT, _Traits>* \n+    basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb)\n+    {\n+      basic_streambuf<_CharT, _Traits>* __old = _M_streambuf;\n+      _M_streambuf = __sb;\n+      this->clear();\n+      return __old;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_ios<_CharT, _Traits>&\n+    basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)\n+    {\n+      // Per 27.1.1.1, do not call imbue, yet must trash all caches\n+      // associated with imbue()\n+\n+      // Alloc any new word array first, so if it fails we have \"rollback\".\n+      _Words* __words = (__rhs._M_word_limit <= _S_local_words) ?\n+\t_M_word_array : new _Words[__rhs._M_word_limit];\n+\n+      // XXX This is the only reason _Callback_list was defined\n+      // inline. The suspicion is that this increased compilation\n+      // times dramatically for functions that use this member\n+      // function (inserters_extractors, ios_manip_fmtflags). FIX ME,\n+      // clean this stuff up. Callbacks are broken right now, anyway.\n+\n+      // Bump refs before doing callbacks, for safety.\n+      _Callback_list* __cb = __rhs._M_callbacks;\n+      if (__cb) \n+\t__cb->_M_add_reference();\n+      _M_call_callbacks(erase_event);\n+      if (_M_words != _M_word_array) \n+\tdelete [] _M_words;\n+      _M_dispose_callbacks();\n+\n+      _M_callbacks = __cb;  // NB: Don't want any added during above.\n+      for (int __i = 0; __i < __rhs._M_word_limit; ++__i)\n+\t__words[__i] = __rhs._M_words[__i];\n+      if (_M_words != _M_word_array) \n+\tdelete [] _M_words;\n+      _M_words = __words;\n+      _M_word_limit = __rhs._M_word_limit;\n+\n+      this->flags(__rhs.flags());\n+      this->width(__rhs.width());\n+      this->precision(__rhs.precision());\n+      this->tie(__rhs.tie());\n+      this->fill(__rhs.fill());\n+      // The next is required to be the last assignment.\n+      this->exceptions(__rhs.exceptions());\n+      \n+      _M_call_callbacks(copyfmt_event);\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    char\n+    basic_ios<_CharT, _Traits>::narrow(char_type __c, char __dfault) const\n+    { return _M_fctype_ios->narrow(__c, __dfault); }\n+\n+  template<typename _CharT, typename _Traits>\n+    _CharT\n+    basic_ios<_CharT, _Traits>::widen(char __c) const\n+    { return _M_fctype_ios->widen(__c); }\n+\n+  // Locales:\n+  template<typename _CharT, typename _Traits>\n+    locale\n+    basic_ios<_CharT, _Traits>::imbue(const locale& __loc)\n+    {\n+      locale __old(this->getloc());\n+      ios_base::imbue(__loc);\n+      _M_fctype_ios = &use_facet<__ctype_type>(__loc);\n+      _M_fnumput = &use_facet<__numput_type>(__loc); \n+      _M_fnumget = &use_facet<__numget_type>(__loc); \n+      if (this->rdbuf() != 0)\n+\tthis->rdbuf()->pubimbue(__loc);\n+      return __old;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    void\n+    basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)\n+    {\n+      // NB: This may be called more than once on the same object.\n+      ios_base::_M_init();\n+      locale __loc = this->getloc();\n+      _M_fctype_ios = &use_facet<__ctype_type>(__loc);\n+      // Should be filled in by ostream and istream, respectively.\n+      _M_fnumput = &use_facet<__numput_type>(__loc); \n+      _M_fnumget = &use_facet<__numget_type>(__loc); \n+      _M_tie = 0;\n+      _M_fill = this->widen(' ');\n+      _M_exception = goodbit;\n+      _M_streambuf = __sb;\n+      iostate __state = __sb ? goodbit : badbit;\n+      _M_streambuf_state = __state;\n+    }\n+\n+} // namespace std\n+\n+#endif /* _CPP_BITS_BASICIOS_TCC */\n+\n+\n+\n+\n+"}, {"sha": "f80cc94465a70b6a5c643a08d445136eef1d8fbd", "filename": "libstdc++-v3/bits/basic_string.h", "status": "added", "additions": 1039, "deletions": 0, "changes": 1039, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fbasic_string.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fbasic_string.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fbasic_string.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,1039 @@\n+// Components for manipulating sequences of characters -*- C++ -*-\n+\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 21 Strings library\n+//\n+\n+#ifndef _CPP_BITS_STRING_H\n+#define _CPP_BITS_STRING_H\t1\n+\n+#include <bits/exception_support.h>\n+#include <atomicity.h>\n+\n+namespace std {\n+\n+  // Documentation?  What's that? \n+  // Nathan Myers <ncm@cantrip.org>.\n+  //\n+  // A string looks like this:\n+  //\n+  //                               \t[_Rep]\n+  //                               \t_M_length\n+  //  [basic_string<char_type>]\t\t_M_capacity\n+  //  _M_dataplus                \t_M_state\n+  //  _M_p ---------------->   \t\tunnamed array of char_type\n+  \n+  // Where the _M_p points to the first character in the string, and\n+  // you cast it to a pointer-to-_Rep and subtract 1 to get a\n+  // pointer to the header.\n+  \n+  // This approach has the enormous advantage that a string object\n+  // requires only one allocation.  All the ugliness is confined\n+  // within a single pair of inline functions, which each compile to\n+  // a single \"add\" instruction: _Rep::_M_data(), and\n+  // string::_M_rep(); and the allocation function which gets a\n+  // block of raw bytes and with room enough and constructs a _Rep\n+  // object at the front.\n+  \n+  // The reason you want _M_data pointing to the character array and\n+  // not the _Rep is so that the debugger can see the string\n+  // contents. (Probably we should add a non-inline member to get\n+  // the _Rep for the debugger to use, so users can check the actual\n+  // string length.)\n+  \n+  // Note that the _Rep object is a POD so that you can have a\n+  // static \"empty string\" _Rep object already \"constructed\" before\n+  // static constructors have run.  The reference-count encoding is\n+  // chosen so that a 0 indicates one reference, so you never try to\n+  // destroy the empty-string _Rep object.\n+  \n+  // All but the last paragraph is considered pretty conventional\n+  // for a C++ string implementation.\n+  \n+  // 21.3  Template class basic_string\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    class basic_string\n+    {\n+      // Types:\n+    public:\n+      typedef _Traits \t\t\t\t\t    traits_type;\n+      typedef typename _Traits::char_type \t\t    value_type;\n+      typedef _Alloc \t\t\t\t\t    allocator_type;\n+      typedef typename _Alloc::size_type \t\t    size_type;\n+      typedef typename _Alloc::difference_type \t\t    difference_type;\n+      typedef typename _Alloc::reference \t\t    reference;\n+      typedef typename _Alloc::const_reference \t\t    const_reference;\n+      typedef typename _Alloc::pointer \t\t\t    pointer;\n+      typedef typename _Alloc::const_pointer \t   \t    const_pointer;\n+      typedef __normal_iterator<pointer, basic_string> \t    iterator;\n+      typedef __normal_iterator<const_pointer, basic_string> const_iterator;\n+      typedef reverse_iterator<const_iterator> \tconst_reverse_iterator;\n+      typedef reverse_iterator<iterator> \t\t    reverse_iterator;\n+    \n+      //  Data Members:\n+      // NB: This is an unsigned type, and thus represents the maximum\n+      // size that the allocator can hold.\n+      static const size_type npos = static_cast<size_type>(-1);\n+\n+    private:\n+      // _Rep: string representation\n+      //   Invariants:\n+      //   1. String really contains _M_length + 1 characters; last is set\n+      //      to 0 only on call to c_str().  We avoid instantiating\n+      //      _CharT() where the interface does not require it.\n+      //   2. _M_capacity >= _M_length\n+      //      Allocated memory is always _M_capacity + (1 * sizeof(_CharT)).\n+      //   3. _M_state has three states:\n+      //      -1: leaked, one reference, no ref-copies allowed, non-const.\n+      //       0: one reference, non-const.\n+      //     n>0: n + 1 references, operations require a lock, const.\n+      //   4. All fields==0 is an empty string, given the extra storage\n+      //      beyond-the-end for a null terminator; thus, the shared\n+      //      empty string representation needs no constructor.\n+\n+      struct _Rep\n+      {\n+\t// Types:\n+\ttypedef typename _Alloc::rebind<char>::other _Raw_bytes_alloc;\n+\n+\t// NB: Would be better if atomicity.h defined type(s) itself.\n+\ttypedef uint32_t _State_type; \n+\ttypedef int32_t _Signed_state_type;\n+\n+\t// (Public) Data members: \n+\n+\t// The maximum number of individual char_type elements of an\n+\t// individual string is determined by _S_max_size. This is the\n+\t// value that will be returned by max_size().  (Whereas npos\n+\t// is the maximum number of bytes the allocator can allocate.)\n+\t// If one was to divvy up the theoretical largest size string,\n+\t// with a terminating character and m _CharT elements, it'd\n+\t// look like this: \n+\t// npos = sizeof(_Rep) + (m * sizeof(_CharT)) + sizeof(_CharT)\n+\t// Solving for m:\n+\t// m = ((npos - sizeof(_Rep))/sizeof(CharT)) - 1 \n+\t// In addition, this implementation quarters this ammount.\n+\tstatic size_type \t_S_max_size;\n+\tstatic _CharT \t\t_S_terminal;\n+\n+\tsize_type \t\t_M_length;\n+\tsize_type \t\t_M_capacity;\n+\t_State_type\t\t_M_state;\n+\t\n+        bool\n+\t_M_is_leaked() const\n+        { return static_cast<_Signed_state_type>(_M_state) < 0; }\n+\n+        bool\n+\t_M_is_shared() const\n+        { return static_cast<_Signed_state_type>(_M_state) > 0; }\n+\n+        void\n+\t_M_set_leaked() \n+        { _M_state = _State_type(-1); }\n+\n+        void\n+\t_M_set_sharable() \n+        { _M_state = 0; }\n+\n+\t_CharT* \n+\t_M_refdata() throw()\n+\t{ return reinterpret_cast<_CharT*> (this + 1); }\n+\n+\t_CharT& \n+\toperator[](size_t __s) throw()\n+\t{ return _M_refdata() [__s]; }\n+\n+\t_CharT* \n+\t_M_grab(const _Alloc& __alloc1, const _Alloc& __alloc2)\n+\t{ return (!_M_is_leaked() && __alloc1 == __alloc2) ?\n+\t    _M_refcopy() : _M_clone(__alloc1);  }\n+\n+\t// Create & Destroy\n+\tstatic _Rep* \n+\t_S_create(size_t, const _Alloc&);\n+\n+\tvoid \n+\t_M_dispose(const _Alloc& __a)\n+\t{ \n+\t  if (_Signed_state_type(exchange_and_add(&_M_state, -1)) <= 0)  \n+\t    _M_destroy(__a); \n+\t}  // XXX MT\n+\n+\tvoid \n+\t_M_destroy(const _Alloc&) throw();\n+\n+\t_CharT* \n+\t_M_refcopy() throw()\n+\t{ \n+\t  atomic_add(&_M_state, 1); \n+\t  return _M_refdata(); \n+\t}  // XXX MT\n+\n+\t_CharT* \n+\t_M_clone(const _Alloc&, size_type __res = 0);\n+\n+#if _GLIBCPP_ALLOC_CONTROL\n+\t// These function pointers allow you to modify the allocation\n+\t// policy used by the string classes.  By default they expand by\n+\t// powers of two, but this may be excessive for space-critical\n+\t// applications.\n+\t\n+\t// Returns true if ALLOCATED is too much larger than LENGTH\n+\tstatic bool (*_S_excess_slop) (size_t __length, size_t __allocated);\n+\n+\tinline static bool \n+\t__default_excess(size_t, size_t);\n+#else\n+\tinline static bool \n+\t_S_excess_slop(size_t, size_t);\n+#endif\n+      };\n+\n+      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html\n+      struct _Alloc_hider : _Alloc\n+      {\n+\t_Alloc_hider(_CharT* __dat, const _Alloc& __a)\n+\t: _Alloc(__a), _M_p(__dat) { }\n+\n+\t_CharT* _M_p; // The actual data.\n+      };\n+\n+      mutable _Alloc_hider _M_dataplus;\n+\n+      _CharT* \n+      _M_data() const \n+      { return  _M_dataplus._M_p; }\n+\n+      _CharT* \n+      _M_data(_CharT* __p) \n+      { return (_M_dataplus._M_p = __p); }\n+\n+      _Rep* \n+      _M_rep() const\n+      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }\n+\n+      // For the internal use we have functions similar to `begin'/`end'\n+      // but they do not call _M_leak.\n+      iterator \n+      _M_ibegin() const { return iterator(_M_data()); }\n+\n+      iterator \n+      _M_iend() const { return iterator(_M_data() + this->size()); }\n+\n+      void \n+      _M_leak()    // for use in begin() & non-const op[]\n+      { \n+\tif (!_M_rep()->_M_is_leaked()) \n+\t  _M_leak_hard(); \n+      }\n+\n+      iterator \n+      _M_check(size_type __pos) const\n+      { \n+\t__OUTOFRANGE(__pos > this->size()); \n+\treturn _M_ibegin() + __pos; \n+      }\n+\n+      // NB: _M_fold doesn't check for a bad __pos1 value.\n+      iterator \n+      _M_fold(size_type __pos, size_type __off) const\n+      { \n+\tbool __testoff =  __off < this->size() - __pos;\n+\tsize_type __newoff = __testoff ? __off : this->size() - __pos;\n+\treturn (_M_ibegin() + __pos + __newoff);\n+      }\n+\n+      // _S_copy_chars is a separate template to permit specialization\n+      // to optimize for the common case of pointers as iterators.\n+      template<class _Iterator>\n+        static void\n+        _S_copy_chars(_CharT* __p, _Iterator __j1, _Iterator __j2)\n+        { \n+\t  for (; __j1 != __j2; ++__j1, ++__p) \n+\t    traits_type::assign(*__p, *__j1); //these types are off\n+\t}\n+\n+      static void\n+      _S_copy_chars(_CharT* __p, iterator __j1, iterator __j2)\n+      { _S_copy_chars(__p, __j1.base(), __j2.base()); }\n+\n+      static void\n+      _S_copy_chars(_CharT* __p, const_iterator __j1, const_iterator __j2)\n+      { _S_copy_chars(__p, __j1.base(), __j2.base()); }\n+ \n+      static void\n+      _S_copy_chars(_CharT* __p, _CharT* __j1, _CharT* __j2)\n+      { traits_type::copy(__p, __j1, __j2 - __j1); }\n+\n+      static void\n+      _S_copy_chars(_CharT* __p, const _CharT* __j1, const _CharT* __j2)\n+      { traits_type::copy(__p, __j1, __j2 - __j1); }\n+\n+      void \n+      _M_mutate(size_type __pos, size_type __len1, size_type __len2);\n+\n+      void \n+      _M_leak_hard();\n+\n+      // The following storage is init'd to 0 by the linker, resulting\n+      // (carefully) in an empty string with one reference.\n+      static size_type _S_empty_rep_storage[\n+      (sizeof(_Rep) + sizeof(_CharT) + sizeof(size_type)-1)/sizeof(size_type)];\n+\n+      static _Rep& \n+      _S_empty_rep()\n+      { return *reinterpret_cast<_Rep*> (&_S_empty_rep_storage); }\n+\n+    public:\n+      // Construct/copy/destroy:\n+      // NB: We overload ctors in some cases instead of using default\n+      // arguments, per 17.4.4.4 para. 2 item 2.\n+\n+      inline \n+      basic_string();\n+\n+      explicit \n+      basic_string(const _Alloc& __a);\n+\n+      // NB: per LWG issue 42, semantics different from IS:\n+      basic_string(const basic_string& __str);\n+      basic_string(const basic_string& __str, size_type __pos,\n+\t\t   size_type __n = npos);\n+      basic_string(const basic_string& __str, size_type __pos,\n+\t\t   size_type __n, const _Alloc& __a);\n+\n+      basic_string(const _CharT* __s, size_type __n,\n+\t\t   const _Alloc& __a = _Alloc());\n+      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc());\n+      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc());\n+\n+      template<class _InputIterator>\n+        basic_string(_InputIterator __begin, _InputIterator __end,\n+\t\t     const _Alloc& __a = _Alloc());\n+\n+      ~basic_string() \n+      { _M_rep()->_M_dispose(this->get_allocator()); }\n+\n+      basic_string& \n+      operator=(const basic_string& __str) { return this->assign(__str); }\n+\n+      basic_string& \n+      operator=(const _CharT* __s) { return this->assign(__s); }\n+\n+      basic_string& \n+      operator=(_CharT __c) { return this->assign(1, __c); }\n+\n+      // Iterators:\n+      iterator \n+      begin() \n+      { \n+\t_M_leak(); \n+\treturn iterator(_M_data());\n+      }\n+\n+      const_iterator \n+      begin() const \n+      { return const_iterator(_M_data()); }\n+\n+      iterator \n+      end()\n+      {\n+         _M_leak();\n+\t return iterator(_M_data() + this->size());\n+      }\n+\n+      const_iterator \n+      end() const\n+      { return const_iterator(_M_data() + this->size()); }\n+\n+      reverse_iterator \n+      rbegin() \n+      { return reverse_iterator(this->end()); }\n+\n+      const_reverse_iterator \n+      rbegin() const \n+      { return const_reverse_iterator(this->end()); }\n+\n+      reverse_iterator \n+      rend() \n+      { return reverse_iterator(this->begin()); }\n+\n+      const_reverse_iterator \n+      rend() const \n+      { return const_reverse_iterator(this->begin()); }\n+\n+    public:\n+      // Capacity:\n+      size_type \n+      size() const { return _M_rep()->_M_length; }\n+\n+      size_type \n+      length() const { return _M_rep()->_M_length; }\n+\n+      size_type \n+      max_size() const { return _Rep::_S_max_size; }\n+\n+      void \n+      resize(size_type __n, _CharT __c);\n+\n+      void \n+      resize(size_type __n) { this->resize(__n, _CharT()); }\n+\n+      size_type \n+      capacity() const { return _M_rep()->_M_capacity; }\n+\n+      void \n+      reserve(size_type __res_arg = 0);\n+\n+      void \n+      clear() { _M_mutate(0, this->size(), 0); }\n+\n+      bool \n+      empty() const { return this->size() == 0; }\n+\n+      // Element access:\n+      const_reference \n+      operator[] (size_type __pos) const \n+      { return _M_data()[__pos]; }\n+\n+      reference \n+      operator[](size_type __pos) \n+      { \n+\t_M_leak(); \n+\treturn _M_data()[__pos]; \n+      }\n+\n+      const_reference \n+      at(size_type __n) const\n+      {\n+\t__OUTOFRANGE(__n >= this->size());\n+\treturn _M_data()[__n]; \n+      }\n+\n+      reference \n+      at(size_type __n)\n+      {\n+\t__OUTOFRANGE(__n >= size());\n+\t_M_leak(); \n+\treturn _M_data()[__n]; \n+      }\n+\n+      // Modifiers:\n+      basic_string& \n+      operator+=(const basic_string& __str) { return this->append(__str); }\n+\n+      basic_string& \n+      operator+=(const _CharT* __s) { return this->append(__s); }\n+\n+      basic_string& \n+      operator+=(_CharT __c) { return this->append(size_type(1), __c); }\n+\n+      basic_string& \n+      append(const basic_string& __str);\n+\n+      basic_string& \n+      append(const basic_string& __str, size_type __pos, size_type __n);\n+\n+      basic_string& \n+      append(const _CharT* __s, size_type __n);\n+\n+      basic_string& \n+      append(const _CharT* __s)\n+      { return this->append(__s, traits_type::length(__s)); }\n+\n+      basic_string& \n+      append(size_type __n, _CharT __c);\n+\n+      template<class _InputIterator>\n+        basic_string& \n+        append(_InputIterator __first, _InputIterator __last)\n+        { return this->replace(_M_iend(), _M_iend(), __first, __last); }\n+\n+      void \n+      push_back(_CharT __c)\n+      { this->replace(_M_iend(), _M_iend(), 1, __c); }\n+\n+      basic_string& \n+      assign(const basic_string& __str);\n+\n+      basic_string& \n+      assign(const basic_string& __str, size_type __pos, size_type __n)\n+      { \n+\treturn this->assign(__str._M_check(__pos), __str._M_fold(__pos, __n)); \n+      }\n+\n+      basic_string& \n+      assign(const _CharT* __s, size_type __n)\n+      { return this->assign(__s, __s + __n); }\n+\n+      basic_string& \n+      assign(const _CharT* __s)\n+      { return this->assign(__s, __s + traits_type::length(__s)); }\n+\n+      basic_string& \n+      assign(size_type __n, _CharT __c)\n+      { return this->replace(_M_ibegin(), _M_iend(), __n, __c); }\n+\n+      template<class _InputIterator>\n+        basic_string& \n+        assign(_InputIterator __first, _InputIterator __last)\n+        { return this->replace(_M_ibegin(), _M_iend(), __first, __last); }\n+\n+      void \n+      insert(iterator __p, size_type __n, _CharT __c)\n+      {\tthis->replace(__p, __p, __n, __c);  }\n+\n+      template<class _InputIterator>\n+        void insert(iterator __p, _InputIterator __beg, _InputIterator __end)\n+        { this->replace(__p, __p, __beg, __end); }\n+\n+      basic_string& \n+      insert(size_type __pos1, const basic_string& __str)\n+      { \n+\titerator __p = _M_check(__pos1);\n+\tthis->replace(__p, __p, __str._M_ibegin(), __str._M_iend());\n+        return *this; \n+      }\n+\n+      basic_string& \n+      insert(size_type __pos1, const basic_string& __str,\n+\t     size_type __pos2, size_type __n)\n+      { \n+\titerator __p = _M_check(__pos1);\n+\tthis->replace(__p, __p, __str._M_check(__pos2), \n+\t\t      __str._M_fold(__pos2, __n));\n+        return *this; \n+      }\n+\n+      basic_string& \n+      insert(size_type __pos, const _CharT* __s, size_type __n)\n+      { \n+\titerator __p = _M_check(__pos);\n+\tthis->replace(__p, __p, __s, __s + __n);\n+        return *this; \n+      }\n+\n+      basic_string&  \n+      insert(size_type __pos, const _CharT* __s)\n+      { return this->insert(__pos, __s, traits_type::length(__s)); }\n+\n+      basic_string& \n+      insert(size_type __pos, size_type __n, _CharT __c)\n+      { \n+\tthis->insert(_M_check(__pos), __n, __c); \n+\treturn *this; \n+      }\n+\n+      iterator \n+      insert(iterator __p, _CharT __c = _CharT())\n+      {\n+\tsize_type __pos = __p - _M_ibegin();\n+\tthis->insert(_M_check(__pos), size_type(1), __c);\n+\t_M_rep()->_M_set_leaked(); \n+ \treturn this->_M_ibegin() + __pos; \n+      }\n+\n+      basic_string& \n+      erase(size_type __pos = 0, size_type __n = npos)\n+      { \n+\treturn this->replace(_M_check(__pos), _M_fold(__pos, __n),\n+\t\t\t     _M_data(), _M_data()); \n+      }\n+\n+      iterator \n+      erase(iterator __position)\n+      {\n+\tsize_type __i = __position - _M_ibegin();\n+        this->replace(__position, __position + 1, _M_data(), _M_data());\n+\t_M_rep()->_M_set_leaked(); \n+\treturn _M_ibegin() + __i;\n+      }\n+\n+      iterator \n+      erase(iterator __first, iterator __last)\n+      {\n+        size_type __i = __first - _M_ibegin();\n+\tthis->replace(__first, __last, _M_data(), _M_data());\n+\t_M_rep()->_M_set_leaked();\n+       return _M_ibegin() + __i;\n+      }\n+\n+      basic_string& \n+      replace(size_type __pos, size_type __n, const basic_string& __str)\n+      { \n+\treturn this->replace(_M_check(__pos), _M_fold(__pos, __n),\n+\t\t\t      __str.begin(), __str.end()); \n+      }\n+\n+      basic_string& \n+      replace(size_type __pos1, size_type __n1, const basic_string& __str,\n+\t      size_type __pos2, size_type __n2);\n+\n+      basic_string& \n+      replace(size_type __pos, size_type __n1, const _CharT* __s,\n+\t      size_type __n2)\n+      { \n+\treturn this->replace(_M_check(__pos), _M_fold(__pos, __n1),\n+\t\t\t     __s, __s + __n2); \n+      }\n+\n+      basic_string& \n+      replace(size_type __pos, size_type __n1, const _CharT* __s)\n+      { \n+\treturn this->replace(_M_check(__pos), _M_fold(__pos, __n1),\n+\t\t\t     __s, __s + traits_type::length(__s)); \n+      }\n+\n+      basic_string& \n+      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)\n+      { \n+\treturn this->replace(_M_check(__pos), _M_fold(__pos, __n1), __n2, __c);\n+      }\n+\n+      basic_string& \n+      replace(iterator __i1, iterator __i2, const basic_string& __str)\n+      { return this->replace(__i1, __i2, __str.begin(), __str.end()); }\n+\n+      basic_string& \n+      replace(iterator __i1, iterator __i2,\n+                           const _CharT* __s, size_type __n)\n+      { return this->replace(__i1, __i2, __s, __s + __n); }\n+\n+      basic_string& \n+      replace(iterator __i1, iterator __i2, const _CharT* __s)\n+      { return this->replace(__i1, __i2, __s, \n+\t\t\t     __s + traits_type::length(__s)); }\n+\n+      basic_string& \n+      replace(iterator __i1, iterator __i2, size_type __n, _CharT __c);\n+\n+      template<class _InputIterator>\n+        basic_string& \n+        replace(iterator __i1, iterator __i2,\n+\t\t_InputIterator __j1, _InputIterator __j2)\n+        { return _M_replace(__i1, __i2, __j1, __j2,\n+\t     typename iterator_traits<_InputIterator>::iterator_category()); }\n+\n+    private:\n+      template<class _InputIterator>\n+        basic_string& \n+        _M_replace(iterator __i1, iterator __i2, _InputIterator __j1, \n+\t\t   _InputIterator __j2, input_iterator_tag);\n+\n+      template<class _FwdIterator>\n+        basic_string& \n+        _M_replace(iterator __i1, iterator __i2, _FwdIterator __j1, \n+\t\t   _FwdIterator __j2, forward_iterator_tag);\n+\n+      // _S_construct_aux is used to implement the 21.3.1 para 15 which\n+      // requires special behaviour if _InIter is an integral type\n+      template<class _InIter>\n+        static _CharT*\n+        _S_construct_aux(_InIter __beg, _InIter __end, const _Alloc& __a,\n+\t\t\t __false_type)\n+\t{\n+          typedef typename iterator_traits<_InIter>::iterator_category _Tag;\n+          return _S_construct(__beg, __end, __a, _Tag());\n+\t}\n+ \n+      template<class _InIter>\n+        static _CharT*\n+        _S_construct_aux(_InIter __beg, _InIter __end, const _Alloc& __a,\n+\t\t\t __true_type)\n+\t{\n+\t  return _S_construct(static_cast<size_type>(__beg),\n+\t\t\t      static_cast<value_type>(__end), __a);\n+\t}\n+ \n+      template<class _InIter>\n+        static _CharT*\n+        _S_construct(_InIter __beg, _InIter __end, const _Alloc& __a)\n+\t{\n+\t  typedef typename _Is_integer<_InIter>::_Integral _Integral;\n+\t  return _S_construct_aux(__beg, __end, __a, _Integral());\n+        }\n+\n+      // For Input Iterators, used in istreambuf_iterators, etc.\n+      template<class _InIter>\n+        static _CharT*\n+         _S_construct(_InIter __beg, _InIter __end, const _Alloc& __a,\n+\t\t      input_iterator_tag);\n+      \n+      // For forward_iterators up to random_access_iterators, used for\n+      // string::iterator, _CharT*, etc.\n+      template<class _FwdIter>\n+        static _CharT*\n+        _S_construct(_FwdIter __end, _FwdIter __beg, const _Alloc& __a,\n+\t\t     forward_iterator_tag);\n+\n+      static _CharT* \n+      _S_construct(size_type __req, _CharT __c, const _Alloc& __a);\n+\n+    public:\n+\n+      size_type \n+      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;\n+\n+      void \n+      swap(basic_string<_CharT, _Traits, _Alloc>& __s);\n+\n+      // String operations:\n+      const _CharT* \n+      c_str() const\n+      {\n+\t// MT: This assumes concurrent writes are OK.\n+\tsize_type __n = this->size();\n+\ttraits_type::assign(_M_data()[__n], _Rep::_S_terminal);\n+        return _M_data();\n+      }\n+\n+      const _CharT* \n+      data() const { return _M_data(); }\n+\n+      allocator_type \n+      get_allocator() const { return _M_dataplus; }\n+\n+      size_type \n+      find(const _CharT* __s, size_type __pos, size_type __n) const;\n+\n+      size_type \n+      find(const basic_string& __str, size_type __pos = 0) const\n+      { return this->find(__str.data(), __pos, __str.size()); }\n+\n+      size_type \n+      find(const _CharT* __s, size_type __pos = 0) const\n+      { return this->find(__s, __pos, traits_type::length(__s)); }\n+\n+      size_type \n+      find(_CharT __c, size_type __pos = 0) const;\n+\n+      size_type \n+      rfind(const basic_string& __str, size_type __pos = npos) const\n+      { return this->rfind(__str.data(), __pos, __str.size()); }\n+\n+      size_type \n+      rfind(const _CharT* __s, size_type __pos, size_type __n) const;\n+\n+      size_type \n+      rfind(const _CharT* __s, size_type __pos = npos) const\n+      { return this->rfind(__s, __pos, traits_type::length(__s)); }\n+\n+      size_type \n+      rfind(_CharT __c, size_type __pos = npos) const;\n+\n+      size_type \n+      find_first_of(const basic_string& __str, size_type __pos = 0) const\n+      { return this->find_first_of(__str.data(), __pos, __str.size()); }\n+\n+      size_type \n+      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;\n+\n+      size_type \n+      find_first_of(const _CharT* __s, size_type __pos = 0) const\n+      { return this->find_first_of(__s, __pos, traits_type::length(__s)); }\n+\n+      size_type \n+      find_first_of(_CharT __c, size_type __pos = 0) const\n+      { return this->find(__c, __pos); }\n+\n+      size_type \n+      find_last_of(const basic_string& __str, size_type __pos = npos) const\n+      { return this->find_last_of(__str.data(), __pos, __str.size()); }\n+\n+      size_type \n+      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;\n+\n+      size_type \n+      find_last_of(const _CharT* __s, size_type __pos = npos) const\n+      { return this->find_last_of(__s, __pos, traits_type::length(__s)); }\n+\n+      size_type \n+      find_last_of(_CharT __c, size_type __pos = npos) const\n+      { return this->rfind(__c, __pos); }\n+\n+      size_type \n+      find_first_not_of(const basic_string& __str, size_type __pos = 0) const\n+      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }\n+\n+      size_type \n+      find_first_not_of(const _CharT* __s, size_type __pos, \n+\t\t\tsize_type __n) const;\n+\n+      size_type \n+      find_first_not_of(const _CharT* __s, size_type __pos = 0) const\n+      { return this->find_first_not_of(__s, __pos, traits_type::length(__s)); }\n+\n+      size_type \n+      find_first_not_of(_CharT __c, size_type __pos = 0) const;\n+\n+      size_type \n+      find_last_not_of(const basic_string& __str, size_type __pos = npos) const\n+      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }\n+\n+      size_type \n+      find_last_not_of(const _CharT* __s, size_type __pos, \n+\t\t       size_type __n) const;\n+      size_type \n+      find_last_not_of(const _CharT* __s, size_type __pos = npos) const\n+      { return this->find_last_not_of(__s, __pos, traits_type::length(__s)); }\n+\n+      size_type \n+      find_last_not_of(_CharT __c, size_type __pos = npos) const;\n+\n+      basic_string \n+      substr(size_type __pos = 0, size_type __n = npos) const\n+      { \n+\t__OUTOFRANGE(__pos > this->size());\n+\treturn basic_string(*this, __pos, __n); \n+      }\n+\n+      int \n+      compare(const basic_string& __str) const\n+      {\n+\tsize_type __size = this->size();\n+\tsize_type __osize = __str.size();\n+\tsize_type __len = min(__size, __osize);\n+      \n+\tint __r = traits_type::compare(_M_data(), __str.data(), __len);\n+\tif (!__r)\n+\t  __r =  __size - __osize;\n+\treturn __r;\n+      }\n+\n+      int \n+      compare(size_type __pos, size_type __n, const basic_string& __str) const;\n+\n+      int \n+      compare(size_type __pos1, size_type __n1, const basic_string& __str,\n+\t      size_type __pos2, size_type __n2) const;\n+\n+      int \n+      compare(const _CharT* __s) const;\n+\n+      int \n+      compare(size_type __pos, size_type __n1, const _CharT* __s, \n+\t      size_type __n2 = npos) const;\n+ \n+    private:\n+      static const _CharT* \n+      _S_find (const _CharT* __beg, const _CharT* __end, _CharT __c);\n+  };\n+\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    inline basic_string<_CharT, _Traits, _Alloc>::\n+    basic_string()\n+    : _M_dataplus(_S_empty_rep()._M_refcopy(), _Alloc()) { }\n+\n+  // operator+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    basic_string<_CharT, _Traits, _Alloc>\n+    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n+\t      const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n+    {\n+      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);\n+      __str.append(__rhs);\n+      return __str;\n+    }\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    basic_string<_CharT,_Traits,_Alloc>\n+    operator+(const _CharT* __lhs,\n+\t      const basic_string<_CharT,_Traits,_Alloc>& __rhs);\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    basic_string<_CharT,_Traits,_Alloc>\n+    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    inline basic_string<_CharT, _Traits, _Alloc>\n+    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n+\t     const _CharT* __rhs)\n+    {\n+      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);\n+      __str.append(__rhs);\n+      return __str;\n+    }\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    inline basic_string<_CharT, _Traits, _Alloc>\n+    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)\n+    {\n+      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;\n+      __string_type __str(__lhs);\n+      __str.append(__string_type::size_type(1), __rhs);\n+      return __str;\n+    }\n+\n+  // operator ==\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    inline bool\n+    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n+\t       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n+    { return __lhs.compare(__rhs) == 0; }\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    inline bool\n+    operator==(const _CharT* __lhs,\n+\t       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n+    { return __rhs.compare(__lhs) == 0; }\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    inline bool\n+    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n+\t       const _CharT* __rhs)\n+    { return __lhs.compare(__rhs) == 0; }\n+\n+  // operator !=\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    inline bool\n+    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n+\t       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n+    { return __rhs.compare(__lhs) != 0; }\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    inline bool\n+    operator!=(const _CharT* __lhs,\n+\t       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n+    { return __rhs.compare(__lhs) != 0; }\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    inline bool\n+    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n+\t       const _CharT* __rhs)\n+    { return __lhs.compare(__rhs) != 0; }\n+\n+  // operator <\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    inline bool\n+    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n+\t      const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n+    { return __lhs.compare(__rhs) < 0; }\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    inline bool\n+    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n+\t      const _CharT* __rhs)\n+    { return __lhs.compare(__rhs) < 0; }\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    inline bool\n+    operator<(const _CharT* __lhs,\n+\t      const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n+    { return __rhs.compare(__lhs) > 0; }\n+\n+  // operator >\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    inline bool\n+    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n+\t      const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n+    { return __lhs.compare(__rhs) > 0; }\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    inline bool\n+    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n+\t      const _CharT* __rhs)\n+    { return __lhs.compare(__rhs) > 0; }\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    inline bool\n+    operator>(const _CharT* __lhs,\n+\t      const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n+    { return __rhs.compare(__lhs) < 0; }\n+\n+  // operator <=\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    inline bool\n+    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n+\t       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n+    { return __lhs.compare(__rhs) <= 0; }\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    inline bool\n+    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n+\t       const _CharT* __rhs)\n+    { return __lhs.compare(__rhs) <= 0; }\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    inline bool\n+    operator<=(const _CharT* __lhs,\n+\t       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n+  { return __rhs.compare(__lhs) >= 0; }\n+\n+  // operator >=\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    inline bool\n+    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n+\t       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n+    { return __lhs.compare(__rhs) >= 0; }\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    inline bool\n+    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n+\t       const _CharT* __rhs)\n+    { return __lhs.compare(__rhs) >= 0; }\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    inline bool\n+    operator>=(const _CharT* __lhs,\n+\t     const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n+    { return __rhs.compare(__lhs) <= 0; }\n+\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    inline void\n+    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,\n+\t basic_string<_CharT, _Traits, _Alloc>& __rhs)\n+    { __lhs.swap(__rhs); }\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    basic_istream<_CharT, _Traits>&\n+    operator>>(basic_istream<_CharT, _Traits>& __is,\n+\t       basic_string<_CharT, _Traits, _Alloc>& __str);\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    basic_ostream<_CharT, _Traits>&\n+    operator<<(basic_ostream<_CharT, _Traits>& __os,\n+\t       const basic_string<_CharT, _Traits, _Alloc>& __str);\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    basic_istream<_CharT,_Traits>&\n+    getline(basic_istream<_CharT, _Traits>& __is,\n+\t    basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    inline basic_istream<_CharT,_Traits>&\n+    getline(basic_istream<_CharT, _Traits>& __is,\n+\t    basic_string<_CharT, _Traits, _Alloc>& __str);\n+\n+} // namespace std\n+\n+#endif /* _CPP_BITS_STRING_H */"}, {"sha": "780d3e11cb10ae02bb2391433e19651721640301", "filename": "libstdc++-v3/bits/c++config.h", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fc%2B%2Bconfig.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fc%2B%2Bconfig.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fc%2B%2Bconfig.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,66 @@\n+// Predefined symbols and macros -*- C++ -*-\n+\n+// Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _CPP_CPPCONFIG\n+#define _CPP_CPPCONFIG 1\n+\n+// The current version of the C++ library in compressed ISO date format.\n+#define __GLIBCPP__ 20000324\n+\n+// This flag controls the error handling in string, and perhaps other\n+// bits as time goes on: check out bits/basic_string.h for more\n+// info. It also helps alleviate the circular dependency between\n+// string and exception.\n+# define _GLIBCPP_USE_EXCEPTIONS 1 \n+\n+// This is necessary until Egcs supports separate template\n+// compilation.  \n+#define _GLIBCPP_NO_TEMPLATE_EXPORT 1\n+\n+// This is a hack around not having either pre-compiled headers or\n+// export compilation. If defined, the io, string, and valarray\n+// headers will include all the necessary bits. If not defined, the\n+// implementation optimizes the headers for the most commonly-used\n+// types. For the io library, this means that larger, out-of-line\n+// member functions are only declared, and definitions are not parsed\n+// by the compiler, but instead instantiated into the library binary.\n+//#define _GLIBCPP_FULLY_COMPLIANT_HEADERS 1\n+\n+// To enable older, ARM-style iostreams and other anachronisms use this.\n+//#define _GLIBCPP_DEPRICATED 1\n+\n+// Use corrected code from the committee library group's issues list.\n+# define _GLIBCPP_RESOLVE_LIB_DEFECTS 1\n+\n+\n+\n+\n+\n+\n+"}, {"sha": "3943e6e6cb74b31a2da7c8eb759d49ee0dd37e18", "filename": "libstdc++-v3/bits/char_traits.h", "status": "added", "additions": 327, "deletions": 0, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fchar_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fchar_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fchar_traits.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,327 @@\n+// Character Traits for use by standard string and iostream\n+\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 21  Strings library\n+//\n+\n+#ifndef _CPP_BITS_CHAR_TRAITS_H\n+#define _CPP_BITS_CHAR_TRAITS_H 1\n+\n+#include <bits/std_cwchar.h> \t// For mbstate_t.\n+#include <bits/std_cstring.h> \t// For memmove, memset, memchr\n+#include <bits/fpos.h> \t\t// For streamoff, streamsize\n+\n+namespace std {\n+\n+  // Same as iosfwd\n+#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n+  // Can't have self-recursive types for streampos. \n+  // 21.1.3.1 char_traits sets size_type to streampos\n+  // 27.4.1 \n+  // And here, where streampos is typedefed to fpos<traits::state_type>\n+    typedef fpos<mbstate_t> \tstreampos;\n+#  ifdef _GLIBCPP_USE_WCHAR_T\n+    typedef fpos<mbstate_t> \twstreampos;\n+#  endif\n+#endif\n+\n+  // 21.1.2 Basis for explicit _Traits specialization \n+  // NB: That for any given actual character type this definition is\n+  // probably wrong.\n+\n+  template<class _CharT>\n+    struct char_traits\n+    {\n+      typedef _CharT \t\tchar_type;\n+      // Unsigned as wint_t in unsigned.\n+      typedef unsigned long  \tint_type;\n+      typedef streampos \tpos_type;\n+      typedef streamoff \toff_type;\n+      typedef mbstate_t \tstate_type;\n+      \n+      static void \n+      assign(char_type& __c1, const char_type& __c2)\n+      { __c1 = __c2; }\n+\n+      static bool \n+      eq(const char_type& __c1, const char_type& __c2)\n+      { return __c1 == __c2; }\n+\n+      static bool \n+      lt(const char_type& __c1, const char_type& __c2)\n+      { return __c1 < __c2; }\n+\n+      static int \n+      compare(const char_type* __s1, const char_type* __s2, int_type __n)\n+      { \n+\tfor (int_type __i = 0; __i < __n; ++__i)\n+\t  if (!eq(__s1[__i],__s2[__i]))\n+\t    return lt(__s1[__i],__s2[__i]) ? -1 : 1;\n+\treturn 0; \n+      }\n+\n+      static size_t\n+      length(const char_type* __s)\n+      { \n+\tconst char_type* __p = __s; \n+\twhile (*__p) ++__p; \n+\treturn (__p - __s); \n+      }\n+\n+      static const char_type* \n+      find(const char_type* __s, int __n, const char_type& __a)\n+      { \n+\tfor (const char_type* __p = __s; __p < __s+__n; ++__p)\n+\t  if (*__p == __a) return __p;\n+\treturn 0;\n+      }\n+\n+      static char_type* \n+      move(char_type* __s1, const char_type* __s2, int_type __n)\n+      { return (char_type*) memmove(__s1, __s2, __n * sizeof(char_type)); }\n+\n+      static char_type* \n+      copy(char_type* __s1, const char_type* __s2, int_type __n)\n+      { return (char_type*) memcpy(__s1, __s2, __n * sizeof(char_type)); }\n+\n+      static char_type* \n+      assign(char_type* __s, int_type __n, char_type __a)\n+      { \n+\tfor (char_type* __p = __s; __p - __s < __n; ++__p) \n+\t  assign(*__p, __a);\n+        return __s; \n+      }\n+\n+      static char_type \n+      to_char_type(const int_type& __c)\n+      { return char_type(__c); }\n+\n+      static int_type \n+      to_int_type(const char_type& __c) { return int_type(__c); }\n+\n+      static bool \n+      eq_int_type(const int_type& __c1, const int_type& __c2)\n+      { return __c1 == __c2; }\n+\n+      static state_type \n+      get_state (pos_type __pos) { return __pos.state(); }\n+\n+      static int_type \n+      eof() { return static_cast<int_type>(-1); }\n+\n+      static int_type \n+      eos() { return int_type(); }\n+\n+      static int_type \n+      not_eof(const int_type& __c)\n+      { return eq_int_type(__c, eof()) ? int_type(0) : __c; }\n+    };\n+\n+  // 21.1.4  char_traits specializations\n+  template<>\n+    struct char_traits<char>\n+    {\n+      typedef char \t\tchar_type;\n+      typedef unsigned int \tint_type;\n+      typedef streampos \tpos_type;\n+      typedef streamoff \toff_type;\n+      typedef mbstate_t \tstate_type;\n+\n+      static void \n+      assign(char_type& __c1, const char_type& __c2)\n+      { __c1 = __c2; }\n+\n+      static bool \n+      eq(const char_type& __c1, const char_type& __c2)\n+      { return __c1 == __c2; }\n+\n+      static bool \n+      lt(const char_type& __c1, const char_type& __c2)\n+      { return __c1 < __c2; }\n+\n+      static int \n+      compare(const char_type* __s1, const char_type* __s2, int_type __n)\n+      { return memcmp(__s1, __s2, __n); }\n+\n+      static size_t\n+      length(const char_type* __s)\n+      { return strlen(__s); }\n+\n+      static const char_type* \n+      find(const char_type* __s, int __n, const char_type& __a)\n+      { return static_cast<char*>(memchr(__s, __a, __n)); }\n+\n+      static char_type* \n+      move(char_type* __s1, const char_type* __s2, int_type __n)\n+      { return static_cast<char*>(memmove(__s1, __s2, __n)); }\n+\n+      static char_type* \n+      copy(char_type* __s1, const char_type* __s2, int_type __n)\n+      {  return static_cast<char*>(memcpy(__s1, __s2, __n)); }\n+\n+      static char_type* \n+      assign(char_type* __s, int_type __n, char_type __a)\n+      { return static_cast<char*>(memset(__s, __a, __n)); }\n+\n+      static char_type \n+      to_char_type(const int_type& __c)\n+      { return static_cast<char>(__c); }\n+\n+      //  To keep both the byte 0xff and the eof symbol 0xffffffff\n+      //  from ending up as 0xffffffff.\n+      static int_type \n+      to_int_type(const char_type& __c)\n+      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }\n+\n+      static bool \n+      eq_int_type(const int_type& __c1, const int_type& __c2)\n+      { return __c1 == __c2; }\n+\n+      static state_type \n+      get_state(pos_type __pos) { return __pos.state(); }\n+\n+      static int_type \n+      eof() { return static_cast<int_type>(EOF); }\n+\n+      static int_type \n+      eos() { return '\\0'; }\n+\n+      static int_type \n+      not_eof(const int_type& __c)\n+      { return (__c == eof()) ? 0 : __c; }\n+  };\n+\n+\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  template<>\n+    struct char_traits<wchar_t>\n+    {\n+      typedef wchar_t \t\tchar_type;\n+      typedef wint_t \t\tint_type;\n+      typedef wstreamoff \toff_type;\n+      typedef wstreampos \tpos_type;\n+      typedef mbstate_t \tstate_type;\n+      \n+      static void \n+      assign(char_type& __c1, const char_type& __c2)\n+      { __c1 = __c2; }\n+      static bool \n+      eq(const char_type& __c1, const char_type& __c2)\n+      { return __c1 == __c2; }\n+      static bool \n+      lt(const char_type& __c1, const char_type& __c2)\n+      { return __c1 < __c2; }\n+\n+      static int \n+      compare(const char_type* __s1, const char_type* __s2, int_type __n)\n+      { \n+\tfor (int_type __i = 0; __i < __n; ++__i)\n+\t  if (!eq(__s1[__i], __s2[__i]))\n+\t    return lt(__s1[__i], __s2[__i]) ? -1 : 1;\n+\treturn 0; \n+      }\n+\n+      static size_t\n+      length(const char_type* __s)\n+      { \n+\tconst char_type* __p = __s; \n+\twhile (*__p) \n+\t  ++__p; \n+\treturn (__p - __s); \n+      }\n+\n+      static const char_type* \n+      find (const char_type* __s, int __n, const char_type& __a)\n+      { \n+\tfor (const char_type* __p = __s; __p < __s+__n; ++__p)\n+\t  if (*__p == __a) \n+\t    return __p;\n+\treturn 0;\n+      }\n+\n+      static char_type* \n+      move(char_type* __s1, const char_type* __s2, int_type __n)\n+      { return static_cast<wchar_t*>(memmove(__s1, __s2, \n+\t\t\t\t\t     __n * sizeof(wchar_t))); }\n+\n+      static char_type* \n+      copy(char_type* __s1, const char_type* __s2, int_type __n)\n+      { return static_cast<wchar_t*>(memcpy(__s1, __s2, \n+\t\t\t\t\t    __n * sizeof(wchar_t))); }\n+\n+      static char_type* \n+      assign(char_type* __s, int_type __n, char_type __a)\n+      { \n+\tfor (char_type* __p = __s; __p < __s + __n; ++__p) \n+\t  assign(*__p, __a);\n+        return __s; \n+      }\n+\n+      static char_type \n+      to_char_type(const int_type& __c) { return char_type(__c); }\n+\n+      static int_type \n+      to_int_type(const char_type& __c) { return int_type(__c); }\n+\n+      static bool \n+      eq_int_type(const int_type& __c1, const int_type& __c2)\n+      { return __c1 == __c2; }\n+\n+      static state_type \n+      get_state(pos_type __pos) { return __pos.state(); }\n+\n+      static int_type \n+      eof() { return static_cast<int_type>(WEOF); }\n+\n+      static int_type \n+      eos() { return int_type(); }\n+\n+      static int_type \n+      not_eof(const int_type& __c)\n+      { return eq_int_type(__c, eof()) ? 0 : __c; }\n+  };\n+#endif //_GLIBCPP_USE_WCHAR_T\n+\n+  template<typename _CharT, typename _Traits>\n+    struct _Char_traits_match\n+    {\n+      _CharT _M_c;\n+      _Char_traits_match(_CharT const& __c) : _M_c(__c) { }\n+\n+      bool \n+      operator()(_CharT const& __a) { return _Traits::eq(_M_c,__a); }\n+    };\n+\n+} // namespace std\n+\n+\n+#endif /* _CPP_BITS_CHAR_TRAITS_H */\n+\n+"}, {"sha": "2b62ee8926e29a77fee3d3575d697b4311e47322", "filename": "libstdc++-v3/bits/cpp_type_traits.h", "status": "added", "additions": 301, "deletions": 0, "changes": 301, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fcpp_type_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fcpp_type_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fcpp_type_traits.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,301 @@\n+// The  -*- C++ -*- type traits classes for internal use in libstdc++\n+\n+// Copyright (C) 2000 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// Written by Gabriel Dos Reis <dosreis@cmla.ens-cachan.fr>\n+\n+#ifndef _CPP_BITS_CPP_TYPE_TRAITS_H\n+#define _CPP_BITS_CPP_TYPE_TRAITS_H 1\n+\n+//\n+// This file provides some compile-time information about various types.\n+// These informations were designed, on purpose, to be constant-expressions\n+// and not types as found in <stl/bits/type_traits.h>.  In particular, they\n+// can be used in control structures and the optimizer hopefully will do\n+// the obvious thing.\n+//\n+// Why integral expressions, and not functions nor types?\n+// Firstly, these compile-time information entities are used as\n+// template-arguments so function return values won't work.  We\n+// need compile-time entities.  We're left with types and constant\n+// integral expressions.\n+// Secondly, from the point of view of ease of use type-based compile-time\n+// information is -not- *that* convenient.  On has to write lots of\n+// overloaded functions and to hope that the compiler will select the right\n+// one. As a net effect, the overall structure isn't very clear at first\n+// glance.\n+// Thirdly, partial ordering and overload resolution (of template functions)\n+// is very costly in terms of compiler-resource.  It is a Good Thing to\n+// keep these resource consumption as least as possible.\n+//\n+// -- Gaby (dosreis@cmla.ens-cachan.fr) 2000-03-06.\n+//\n+\n+namespace std {\n+\n+  template<typename _Tp>\n+  struct __is_void\n+  {\n+    enum\n+    {\n+      _M_type = 0\n+    };\n+  };\n+\n+  template<>\n+  struct __is_void<void>\n+  {\n+    enum\n+    {\n+      _M_type = 1\n+    };\n+  };\n+\n+  //\n+  // Integer types\n+  //\n+  template<typename _Tp>\n+    struct __is_integer\n+    {\n+      enum\n+      {\n+\t_M_type = 0\n+      };\n+    };\n+\n+  // Thirteen specializations (yes there are eleven standard integer\n+  // types; 'long long' and 'unsigned long long' are supported as\n+  // extensions)\n+  template<>\n+    struct __is_integer<bool>\n+    {\n+      enum\n+      {\n+\t_M_type = 1\n+      };\n+    };\n+  \n+  template<>\n+    struct __is_integer<char>\n+    {\n+      enum\n+      {\n+\t_M_type = 1\n+      };\n+    };\n+\n+  template<>\n+    struct __is_integer<signed char>\n+    {\n+      enum\n+      {\n+\t_M_type = 1\n+      };\n+    };\n+  \n+  template<>\n+  struct __is_integer<unsigned char>\n+  {\n+    enum\n+    {\n+      _M_type = 1\n+    };\n+  };\n+\n+# ifdef _GLIBCPP_USE_WCHAR_T\n+  template<>\n+  struct __is_integer<wchar_t>\n+  {\n+    enum\n+    {\n+      _M_type = 1\n+    };\n+  };\n+# endif\n+  \n+  template<>\n+  struct __is_integer<short>\n+  {\n+    enum\n+    {\n+      _M_type = 1\n+    };\n+  };\n+\n+  template<>\n+  struct __is_integer<unsigned short>\n+  {\n+    enum\n+    {\n+      _M_type = 1\n+    };\n+  };\n+\n+  template<>\n+  struct __is_integer<int>\n+  {\n+    enum\n+    {\n+      _M_type = 1\n+    };\n+  };\n+\n+  template<>\n+  struct __is_integer<unsigned int>\n+  {\n+    enum\n+    {\n+      _M_type = 1\n+    };\n+  };\n+\n+  template<>\n+  struct __is_integer<long>\n+  {\n+    enum\n+    {\n+      _M_type = 1\n+    };\n+  };\n+\n+  template<>\n+  struct __is_integer<unsigned long>\n+  {\n+    enum\n+    {\n+      _M_type = 1\n+    };\n+  };\n+\n+# ifdef _GLIBCPP_USE_LONG_LONG\n+  template<>\n+  struct __is_integer<long long>\n+  {\n+    enum\n+    {\n+      _M_type = 1\n+    };\n+  };\n+\n+  template<>\n+  struct __is_integer<unsigned long long>\n+  {\n+    enum\n+    {\n+      _M_type = 1\n+    };\n+  };\n+# endif\n+\n+  //\n+  // Floating point types\n+  //\n+  template<typename _Tp>\n+  struct __is_floating\n+  {\n+    enum\n+    {\n+      _M_type = 0\n+    };\n+  };\n+\n+  // three specializations (float, double and 'long double')\n+  template<>\n+  struct __is_floating<float>\n+  {\n+    enum\n+    {\n+      _M_type = 1\n+    };\n+  };\n+\n+  template<>\n+  struct __is_floating<double>\n+  {\n+    enum\n+    {\n+      _M_type = 1\n+    };\n+  };\n+\n+  template<>\n+  struct __is_floating<long double>\n+  {\n+    enum\n+    {\n+      _M_type = 1\n+    };\n+  };\n+\n+  //\n+  // An arithmetic type is an integer type or a floating point type\n+  //\n+  template<typename _Tp>\n+  struct __is_arithmetic\n+  {\n+    enum\n+    {\n+      _M_type = __is_integer<_Tp>::_M_type || __is_floating<_Tp>::_M_type\n+    };\n+  };\n+\n+  //\n+  // A fundamental type is `void' or and arithmetic type\n+  //\n+  template<typename _Tp>\n+  struct __is_fundamental\n+  {\n+    enum\n+    {\n+      _M_type = __is_void<_Tp>::_M_type || __is_arithmetic<_Tp>::_M_type\n+    };\n+  };\n+\n+  //\n+  // For the immediate use, the following is a good approximation\n+  //\n+  template<typename _Tp>\n+  struct __is_pod\n+  {\n+    enum\n+    {\n+      _M_type = __is_fundamental<_Tp>::_M_type\n+    };\n+  };\n+\n+} // namespace std\n+\n+\n+#endif //_CPP_BITS_CPP_TYPE_TRAITS_H\n+\n+\n+\n+\n+\n+\n+"}, {"sha": "e4d033c9ada8900e55545e674721ce8006dce78f", "filename": "libstdc++-v3/bits/exception_support.h", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fexception_support.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fexception_support.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fexception_support.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,79 @@\n+// Methods and support infrastructure for exceptions -*- C++ -*-\n+\n+// Copyright (C) 2000 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 15 Exception handling\n+//\n+\n+// This file declares functions whose only purpose is to throw an\n+// exception. They help break a circularity between <string> and\n+// <stdexcept>. See src/stdexcept.cc, where these functions are\n+// defined.\n+\n+// XXX: These functions serve a similar purpose to those in\n+// stl/bits/stl_range_errors.h . Eventually the two approaches should\n+// be merged. \n+\n+#ifndef _CPP_EXCEPTION_SUPPORT_H\n+#define _CPP_EXCEPTION_SUPPORT_H\t1\n+\n+namespace std {\n+\n+#if _GLIBCPP_USE_EXCEPTIONS\n+  // Internal functions for string implementation.\n+  extern void __out_of_range(const char *__str);\n+  extern void __length_error(const char *__str);\n+  \n+# define __OUTOFRANGE(__cond) \\\n+  do { if (__cond) __out_of_range(#__cond); } while (0)\n+# define __LENGTHERROR(__cond) \\\n+  do { if (__cond) __length_error(#__cond); } while (0)\n+#else\n+# include <bits/std_cassert.h>\n+# define __OUTOFRANGE(__cond) assert(!(__cond))\n+# define __LENGTHERROR(__cond) assert(!(__cond))\n+#endif\n+\n+} // namespace std\n+\n+#endif\t/* _CPP_EXCEPTION_SUPPORT_H */\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+"}, {"sha": "27792b04a847fab0ac25f9860da780f331a9ca7e", "filename": "libstdc++-v3/bits/fpos.h", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Ffpos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Ffpos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Ffpos.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,121 @@\n+// File position object and stream types\n+\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 27 Input/output library\n+//\n+\n+#ifndef _CPP_BITS_FPOS_H\n+#define _CPP_BITS_FPOS_H 1\n+\n+// Need this here as well as in std_ios because fpos is used in\n+// char_traits, and char_traits is used by string, which may or may\n+// not have included the std_ios file.\n+#include <bits/c++io.h>\n+\n+namespace std {\n+\n+  // 27.4.1  Types\n+\n+  // 27.4.3  Template class fpos\n+  template<typename _StateT>\n+    class fpos\n+    {\n+    public:\n+\n+      // Types:\n+      typedef _StateT __state_type;\n+\n+      __state_type\n+      state() const  { return _M_st; }\n+\n+      void \n+      state(__state_type __st)  { _M_st = __st; }\n+\n+      // NB: The standard defines only the implicit copy ctor and the\n+      // previous two members.  The rest is a \"conforming extension\".\n+      fpos(): _M_st(__state_type()), _M_pos(streamoff()) { }\n+\n+      fpos(streamoff __pos, __state_type __st)\n+      : _M_st(__st), _M_pos(__pos) { }\n+\n+      fpos(streamoff __pos)\n+      : _M_st(), _M_pos(__pos) { }\n+\n+      operator streamoff() const { return _M_pos; }\n+\n+      fpos& \n+      operator+=(streamoff __off) { _M_pos += __off; return *this; }\n+\n+      fpos& \n+      operator-=(streamoff __off) { _M_pos -= __off; return *this; }\n+\n+      bool  \n+      operator==(const fpos& __pos2) const { return _M_pos == __pos2._M_pos; }\n+\n+      bool  \n+      operator!=(const fpos& __pos2) const { return _M_pos != __pos2._M_pos; }\n+      \n+      streamoff \n+      _M_position() const { return _M_pos; }\n+\n+      void\n+      _M_position(streamoff __pos)  { _M_pos = __pos; }\n+\n+    private:\n+      __state_type _M_st;\n+      streamoff _M_pos;\n+    };\n+\n+  template<typename _State>\n+    inline fpos<_State> \n+    operator+(const fpos<_State>& __pos, streamoff __off)\n+    { \n+      fpos<_State> t(__pos); \n+      return t += __off; \n+    }\n+\n+  template<typename _State>\n+    inline fpos<_State>\n+    operator-(const fpos<_State>& __pos, streamoff __off)\n+    { \n+      fpos<_State> t(__pos); \n+      return t -= __off; \n+    }\n+\n+  template<typename _State>\n+    inline streamoff \n+    operator-(const fpos<_State>& __pos1, const fpos<_State>& __pos2)\n+    { return __pos1._M_position() - __pos2._M_position(); }\n+\n+}  // namespace std\n+\n+#endif /* _CPP_BITS_FPOS_H */\n+\n+"}, {"sha": "52d71f5e2f891ef50aa026112c411c87001d2381", "filename": "libstdc++-v3/bits/fstream.tcc", "status": "added", "additions": 568, "deletions": 0, "changes": 568, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Ffstream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Ffstream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Ffstream.tcc?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,568 @@\n+// File based streams -*- C++ -*-\n+\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 27.8  File-based streams\n+//\n+\n+#ifndef _CPP_BITS_FSTREAM_TCC\n+#define _CPP_BITS_FSTREAM_TCC 1\n+\n+namespace std\n+{\n+  template<typename _CharT, typename _Traits>\n+    void\n+    basic_filebuf<_CharT, _Traits>::\n+    _M_init_filebuf(void)\n+    {\n+      _M_buf_unified = true; // Tie input to output for basic_filebuf.\n+      _M_buf_size = static_cast<int_type>(BUFSIZ * sizeof(char_type)); \n+      try {\n+\t_M_file = new __file_type(&_M_lock);\n+      }\n+      catch(...) {\n+\tdelete _M_file;\n+\tthrow;\n+      }\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_filebuf<_CharT, _Traits>::\n+    basic_filebuf() \n+    : __streambuf_type(), _M_file(NULL), _M_last_overflowed(false), \n+    _M_state_cur(), _M_state_beg() \n+    { _M_fcvt = &use_facet<__codecvt_type>(this->getloc()); }\n+\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_filebuf<_CharT, _Traits>::\n+    basic_filebuf(int __fd, const char* /*__name*/, ios_base::openmode __mode)\n+    : __streambuf_type(), _M_last_overflowed(false),\n+    _M_state_cur(), _M_state_beg()\n+    {\n+      _M_fcvt = &use_facet<__codecvt_type>(this->getloc());\n+      _M_init_filebuf();\n+      _M_file->sys_open(__fd, __mode);\n+      if (this->is_open() && _M_buf_size)\n+\t{\n+\t  _M_mode = __mode;\n+\t  // XXX So that istream::getc() will only need to get 1 char,\n+\t  // as opposed to BUF_SIZE.\n+\t  if (__fd == 0)\n+\t    _M_buf_size = 1;\n+\n+\t  try {\n+\t    _M_buf = new char_type[_M_buf_size];\n+\t  }\n+\t  catch(...) {\n+\t    delete [] _M_buf;\n+\t    throw;\n+\t  }\n+\n+\t  this->_M_set_indeterminate();\n+\t}\n+   }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_filebuf<_CharT, _Traits>::__filebuf_type* \n+    basic_filebuf<_CharT, _Traits>::\n+    open(const char* __s, ios_base::openmode __mode)\n+    {\n+      __filebuf_type *__retval = NULL;\n+      if (!this->is_open())\n+\t{\n+\t  _M_init_filebuf();\n+\t  _M_file->open(__s, __mode);\n+\t  if (this->is_open() && _M_buf_size)\n+\t    {\n+\t      _M_mode = __mode;\n+\n+\t      try {\n+\t\t_M_buf = new char_type[_M_buf_size];\n+\t      }\n+\t      catch(...) {\n+\t\tdelete [] _M_buf;\n+\t\tthrow;\n+\t      }\n+\t      \n+\t      // For time being, set both (in/out) sets  of pointers.\n+\t      _M_set_indeterminate();\n+\t      if (__mode & ios_base::ate\n+\t\t  && this->seekoff(0, ios_base::end, __mode) < 0)\n+\t\tthis->close();\n+\t      __retval = this;\n+\t    }\n+\t}\n+      return __retval;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_filebuf<_CharT, _Traits>::__filebuf_type* \n+    basic_filebuf<_CharT, _Traits>::\n+    close()\n+    {\n+      __filebuf_type *__retval = NULL;\n+      if (this->is_open())\n+\t{\n+\t  bool __testput = _M_out_cur && _M_out_beg < _M_out_end;\n+\t  if (__testput)\n+\t    _M_really_overflow(traits_type::eof());\n+\t  \n+#if 0\n+\t  // XXX not done\n+\t  if (_M_last_overflowed)\n+\t    {\n+\t      _M_output_unshift();\n+\t      _M_really_overflow(traits_type::eof());\n+\t    }\n+#endif\n+\t  \n+\t  if (_M_file->close())\n+\t    {\n+\t      _M_mode = ios_base::openmode(0);\n+\t      if (_M_buf_size)\n+\t\tdelete [] _M_buf;\n+\t      _M_buf = NULL;\n+\t      this->setg(NULL, NULL, NULL);\n+\t      this->setp(NULL, NULL);\n+\t      __retval = this;\n+\t    }\n+\t}\n+      _M_last_overflowed = false;\t\n+      return __retval;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    streamsize \n+    basic_filebuf<_CharT, _Traits>::\n+    showmanyc()\n+    {\n+      streamsize __retval = -1;\n+      bool __testin = _M_mode & ios_base::in;\n+\n+      if (__testin)\n+\t{\n+\t  bool __testeof = false;\n+\t  if (_M_in_cur >= _M_in_end)\n+\t    __testeof = this->underflow() == traits_type::eof();\n+\t  if (!__testeof)\n+\t    __retval = (_M_in_end - _M_in_cur) / sizeof(char_type);\n+\t}\n+      _M_last_overflowed = false;\t\n+      return __retval;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_filebuf<_CharT, _Traits>::int_type \n+    basic_filebuf<_CharT, _Traits>::\n+    underflow()\n+    {\n+      int_type __retval = traits_type::eof();\n+      bool __testget = _M_in_cur && _M_in_beg < _M_in_cur;\n+      bool __testinit = _M_is_indeterminate();\n+      bool __testout = _M_mode & ios_base::out;\n+      bool __testin = _M_mode & ios_base::in;\n+      \n+      if (__testin)\n+\t{\n+\t  // Sync internal and external buffers.\n+\t  // NB: __testget -> __testput as _M_buf_unified here.\n+\t  if (__testget)\n+\t    {\n+\t      if (__testout)\n+\t\t_M_really_overflow();\n+\t      else \n+\t\t_M_file->seekoff(_M_in_cur - _M_in_beg, ios_base::cur, \n+\t\t\t\t ios_base::in);\n+\t    }\n+\n+\t  if (__testinit || __testget)\n+\t    {\n+\t      // Part one: (Re)fill external buf (_M_file->_IO_*) from\n+\t      // external byte sequence (whatever physical byte sink or\n+\t      // FILE actually is.)\n+\t      char __conv_buf[_M_buf_size];\n+\t      int_type __size = _M_file->xsgetn(__conv_buf, _M_buf_size);\n+\t      \n+\t      // Part two: (Re)fill internal buf contents from external buf.\n+\t      if (0 < __size)\n+\t\t{\n+\t\t  _M_set_determinate(__size);\n+\t\t  \n+\t\t  char* __conv_cur = __conv_buf;\n+\t\t  _M_state_beg = _M_state_cur;\n+\t\t  __res_type __r = _M_fcvt->in(_M_state_cur, \n+\t\t\t\t\t       __conv_buf,\n+\t\t\t\t\t       __conv_buf + __size,\n+\t\t\t\t\t const_cast<const char*&>(__conv_cur), \n+\t\t\t\t\t      _M_in_beg, _M_in_end, _M_in_cur);\n+\t      \n+\t\t  if (__r == codecvt_base::partial)\n+\t\t    {\n+\t\t      // XXX Retry with larger _M_buf size.\n+\t\t    }\n+\t\t  \n+\t\t  // Set pointers to internal and external buffers\n+\t\t  // correctly. . .\n+\t\t  if (__r != codecvt_base::error)\n+\t\t    {\n+\t\t      if (__testout)\n+\t\t\t_M_out_cur = _M_in_cur;\n+\t\t      __retval = traits_type::to_int_type(*_M_in_cur);\n+\t\t    }\n+\n+\t\t  // Part three: Sync the current internal buffer\n+\t\t  // position with the (now overshot) external buffer\n+\t\t  // position.  \n+\t\t  pos_type __p = _M_file->seekoff(0 - __size, ios_base::cur, \n+\t\t\t\t\t\t  ios_base::in);\n+\t\t  if (__p._M_position() == -1)\n+\t\t    {\n+\t\t      // XXX Something is wrong, do error checking.\n+\t\t    }\n+\t\t}\n+\t    }\t      \n+\t}\n+      _M_last_overflowed = false;\t\n+      return __retval;\n+    }\n+  \n+  template<typename _CharT, typename _Traits>\n+    basic_filebuf<_CharT, _Traits>::int_type \n+    basic_filebuf<_CharT, _Traits>::\n+    pbackfail(int_type __i)\n+    {\n+      int_type __retval = traits_type::eof();\n+      char_type __c = traits_type::to_char_type(__i);\n+      bool __testeof = traits_type::eq_int_type(__i, traits_type::eof());\n+      bool __testout = _M_mode & ios_base::out;\n+      bool __testin = _M_mode & ios_base::in;\n+\n+      if (__testin)\n+\t{\n+\t  if (!_M_is_indeterminate())\t  \n+\t    {\n+\t      bool __testpb = _M_in_beg < _M_in_cur;\n+\t      bool __testeq = traits_type::eq(__c, this->gptr()[-1]);\n+\n+\t      // Try to put back __c into input sequence in one of three ways.\n+\t      // Order these tests done in is unspecified by the standard.\n+\t      if (!__testeof && __testpb && __testeq)\n+\t\t{\n+\t\t  --_M_in_cur;\n+\t\t  if (__testout)\n+\t\t    --_M_out_cur;\n+\t\t  __retval = __i;\n+\t\t}\n+\t      else if (!__testeof && __testpb && __testout)\n+\t\t{\n+\t\t  --_M_in_cur;\n+\t\t  if (__testout)\n+\t\t    --_M_out_cur;\n+\t\t  *_M_in_cur = __c;\n+\t\t  __retval = __i;\n+\t\t}\n+\t      else if (__testeof && __testpb)\n+\t\t{\n+\t\t  --_M_in_cur;\n+\t\t  if (__testout)\n+\t\t    --_M_out_cur;\n+\t\t  __retval = traits_type::not_eof(__i);\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      // Need to make a putback position available.\n+\t      this->seekoff(-1, ios_base::cur);\n+\t      this->underflow();\n+\t      if (!__testeof)\n+\t\t{\n+\t\t  *_M_in_cur = __c;\n+\t\t  __retval = __c;\n+\t\t}\n+\t      else\n+\t\t__retval = traits_type::not_eof(__i);\n+\t    }\n+\t}\n+      _M_last_overflowed = false;\t\n+      return __retval;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_filebuf<_CharT, _Traits>::int_type \n+    basic_filebuf<_CharT, _Traits>::\n+    overflow(int_type __c)\n+    {\n+      int_type __retval = traits_type::eof();\n+      bool __testpos = _M_out_cur && _M_out_cur >= _M_buf + _M_buf_size;\n+      bool __testout = _M_mode & ios_base::out;\n+      \n+      if (__testout)\n+\t{\n+\t  if (!__testpos)\n+\t    {\n+\t      *_M_out_cur = traits_type::to_char_type(__c);\n+\t      _M_buf_bump(1);\n+\t      __retval = traits_type::not_eof(__c);\n+\t    }\n+\t  else \n+\t    __retval = this->_M_really_overflow(__c);\n+\t}\n+\n+      _M_last_overflowed = false;    // Set in _M_really_overflow, below.\n+      return __retval;\n+    }\n+  \n+  template<typename _CharT, typename _Traits>\n+    basic_filebuf<_CharT, _Traits>::int_type \n+    basic_filebuf<_CharT, _Traits>::\n+    _M_really_overflow(int_type __c)\n+    {\n+      int_type __retval = traits_type::eof();\n+      bool __testput = _M_out_cur && _M_out_beg < _M_out_end;\n+      bool __testeof = traits_type::eq_int_type(__c, traits_type::eof());\n+      \n+      if (__testput)\n+\t{\n+\t  // Part one: Allocate temporary conversion buffer on\n+\t  // stack. Convert internal buffer plus __c (ie,\n+\t  // \"pending sequence\") to temporary conversion buffer.\n+\t  int __plen = _M_out_end - _M_out_beg;\n+\t  char_type __pbuf[__plen + sizeof(char_type)];\t      \n+\t  traits_type::copy(__pbuf, this->pbase(), __plen);\n+\t  if (!__testeof)\n+\t    {\n+\t      __pbuf[__plen] = traits_type::to_char_type(__c);\n+\t      ++__plen;\n+\t    }\n+\n+\t  char_type* __pend;\n+\t  char __conv_buf[__plen];\n+\t  char* __conv_end;\n+\t  _M_state_beg = _M_state_cur;\n+\n+\t  __res_type __r = _M_fcvt->out(_M_state_cur, \n+\t\t\t\t\t__pbuf, __pbuf + __plen,\n+\t\t\t\t\tconst_cast<const char_type*&>(__pend),\n+\t\t\t\t\t__conv_buf, __conv_buf + __plen,\n+\t\t\t\t\t__conv_end);\n+\t  \n+\t  // Part two: (Re)spill converted \"pending sequence\"\n+\t  // contents (now in temporary conversion buffer) to\n+\t  // external buffer (_M_file->_IO_*) using\n+\t  // _M_file->sys_write(), and do error (minimal) checking.\n+\t  if (__r != codecvt_base::error)\n+\t    {\n+\t      streamsize __r = _M_file->xsputn(__conv_buf, __plen);\n+\t      // NB: Need this so that external byte sequence reflects\n+\t      // internal buffer.\n+\t      _M_file->sync();\n+\t      if (__r == __plen)\n+\t\t{\n+\t\t  _M_set_indeterminate();\n+\t\t  __retval = traits_type::not_eof(__c);\n+\t\t}\n+\t    }\n+\t}\t      \n+      _M_last_overflowed = true;\t\n+      return __retval;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_filebuf<_CharT, _Traits>::pos_type\n+    basic_filebuf<_CharT, _Traits>::\n+    seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode)\n+    {\n+      pos_type __retval =  pos_type(off_type(-1)); \n+      bool __testopen = this->is_open();\n+      bool __testin = __mode & ios_base::in && _M_mode & ios_base::in;\n+      bool __testout = __mode & ios_base::out && _M_mode & ios_base::out;\n+      int __width = _M_fcvt->encoding();\n+      if (__width < 0)\n+\t__width = 0;\n+      bool __testfail = __off != 0  && __width <= 0;\n+      \n+      if (__testopen && !__testfail && (__testin || __testout))\n+\t{\n+\t  if (__way != ios_base::cur || __off != 0)\n+\t    { \n+\t      off_type __computed_off = __width * __off;\n+\t      \n+\t      bool __testget = _M_in_cur && _M_in_beg < _M_in_end;\n+\t      bool __testput = _M_out_cur && _M_out_beg < _M_out_end;\n+\t      // Sync the internal and external streams.\n+\t      // out\n+\t      if (__testput || _M_last_overflowed)\n+\t\t{\n+\t\t  // Part one: update the output sequence.\n+\t\t  this->sync();\n+\t\t  // Part two: output unshift sequence.\n+\t\t  _M_output_unshift();\n+\t\t}\n+\t      //in\n+\t      // NB: underflow() rewinds the external buffer.\n+\t      else if (__testget && __way == ios_base::cur)\n+\t\t__computed_off += _M_in_cur - _M_in_beg;\n+\t  \n+\t      __retval = _M_file->seekoff(__computed_off, __way, __mode);\n+\t      if (__retval._M_position() == -1)\n+\t\t__retval == pos_type(off_type(-1)); \n+\t      _M_set_indeterminate();\n+\t    }\n+\t  // NB: Need to do this in case _M_file in indeterminate\n+\t  // state, ie _M_file->_offset == -1\n+\t  else\n+\t    {\n+\t      __retval = _M_file->seekoff(__off, ios_base::cur, __mode);\n+\t      __retval += max(_M_out_cur, _M_in_cur) - _M_buf;\n+\t    }\n+\t}\n+      _M_last_overflowed = false;\t\n+      return __retval;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_filebuf<_CharT, _Traits>::pos_type\n+    basic_filebuf<_CharT, _Traits>::\n+    seekpos(pos_type __pos, ios_base::openmode __mode)\n+    {\n+      pos_type __retval;\n+      off_type __off = __pos;\n+\n+      __retval = this->seekoff(__off, ios_base::beg, __mode); \n+\n+      _M_last_overflowed = false;\t\n+      return __retval;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    void \n+    basic_filebuf<_CharT, _Traits>::\n+    _M_output_unshift()\n+    {\n+#if 0\n+      // XXX Not complete, or correct.\n+      int __width = _M_fcvt->encoding();\n+      \n+      if (__width < 0)\n+\t{\n+\t  // Part one: call codecvt::unshift\n+\t  int __unsft_len = 0;\n+\t  char_type __unsft_buf[_M_buf_size];\n+\t    char_type* __unsft_cur; // XXX Set to external buf.\n+\t    _M_state_beg = _M_state_cur;\n+\t    __res_type __r = _M_fcvt->unshift(_M_state_cur, \n+\t\t\t\t\t      __unsft_buf,\n+\t\t\t\t\t      __unsft_buf + _M_buf_size,\n+\t\t\t\t\t      __unsft_cur);\n+\t    \n+\t    // Note, for char_type == char, wchar_t unshift\n+\t    // should store no charachers.\n+\t    if (__r == codecvt_base::ok || __r == codecvt_base::noconv)\n+\t      __unsft_len = __unsft_cur - __unsft_buf;\n+\t    \n+\t    // \"Output the resulting sequence.\"\n+\t    if (__unsft_len)\n+\t      {\n+\t\tint __plen = _M_out_cur - _M_out_beg;\n+\t\tint __rlen = __plen  + __unsft_len;\n+\t\tchar_type __rbuf[__rlen];\n+\t\tchar_type* __rend;\n+\t\ttraits_type::copy(__rbuf, this->pbase(), __plen);\n+\t\ttraits_type::copy(__rbuf + __plen, __unsft_buf, \n+\t\t\t\t  __unsft_len);\n+\n+\t\tchar __conv_buf[__rlen];\n+\t\tchar* __conv_end;\n+\t\t\n+\t\t_M_state_beg = _M_state_cur; // XXX Needed?\n+\t\t__r = _M_fcvt->out(_M_state_cur, \n+\t\t\t\t  __rbuf, __rbuf + __rlen,\n+\t\t\t\t  const_cast<const char_type*&>(__rend),\n+\t\t\t\t  __conv_buf, \n+\t\t\t\t  __conv_buf + __rlen,\n+\t\t\t\t  __conv_end);\n+\t\t\n+\t\tif (__r != codecvt_base::error)\n+\t\t  {\n+\t\t    streamsize __r = _M_file->xsputn(__conv_buf, \n+\t\t\t\t\t\t     __rlen);\n+\t\t    if (__r == __rlen)\n+\t\t      {\n+\t\t\t_M_out_cur = _M_out_beg;\n+\t\t\tif (_M_mode & ios_base::in)\n+\t\t\t  _M_in_cur = _M_out_cur;\n+\t\t      }\n+\t\t    else\n+\t\t      {\n+\t\t\t// XXX Throw \"wig out and die exception?\"\n+\t\t      }\n+\t\t  }\n+\t      }\n+\t  }\n+#endif\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    void\n+    basic_filebuf<_CharT, _Traits>::\n+    imbue(const locale& __loc)\n+    {\n+      bool __testbeg = gptr() == eback() && pptr() == pbase();\n+      bool __teststate = _M_fcvt->encoding() == -1;\n+      \n+      _M_locale_set = true;\n+      if (__testbeg && !__teststate && _M_locale_buf != __loc)\n+\t{\n+\t  // XXX Will need to save these older values.\n+\t  _M_locale_buf = __loc;\n+\t  _M_fcvt = &use_facet<__codecvt_type>(_M_locale_buf);\n+\t  // XXX Necessary?\n+\t  _M_fctype_buf = &use_facet<__ctype_type>(_M_locale_buf); \n+\t}\n+      // NB this may require the reconversion of previously\n+      // converted chars. This in turn may cause the reconstruction\n+      // of the original file. YIKES!!\n+      // XXX The part in the above comment is not done.\n+      _M_last_overflowed = false;\t\n+    }\n+  \n+} // namespace std\n+\n+#endif // _CPP_BITS_FSTREAM_TCC\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+"}, {"sha": "4aa3d4a06d6c4994ce0c58ab9432dabc9eed6d3d", "filename": "libstdc++-v3/bits/generic_shadow.h", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fgeneric_shadow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fgeneric_shadow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fgeneric_shadow.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,57 @@\n+// generic C header shadow file -*- C++ -*-\n+\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// This file is included by all the standard C <foo.h> headers\n+// after defining _SHADOW_NAME.\n+\n+#ifdef _IN_C_SWAMP_  /* sub-included by a C header */\n+\n+      // get out of the \"swamp\"\n+    } // close extern \"C\"\n+  }   // close namespace _C_Swamp::\n+\n+# undef _IN_C_SWAMP_\n+# include _SHADOW_NAME\n+\n+  // dive back into the \"swamp\"\n+  namespace _C_Swamp {\n+    extern \"C\" {\n+#     define _IN_C_SWAMP_\n+  \n+#else /* not _IN_C_SWAMP_:  directly included by user program */\n+  \n+# include _SHADOW_NAME\n+  \n+  // expose global C names, including non-standard ones, but shadow\n+  //   some names and types with the std:: C++ version.\n+\n+  using namespace ::_C_Swamp::_C_Shadow;\n+  \n+#endif /* _IN_C_SWAMP_ */\n+    "}, {"sha": "737254c9da7c388d069bfc35bf348d650714d79c", "filename": "libstdc++-v3/bits/gslice.h", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fgslice.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fgslice.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fgslice.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,117 @@\n+// The template and inlines for the -*- C++ -*- gslice class.\n+\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// Written by Gabriel Dos Reis <Gabriel.Dos-Reis@DPTMaths.ENS-Cachan.Fr>\n+\n+#ifndef _CPP_BITS_GSLICE_H\n+#define _CPP_BITS_GSLICE_H\n+\n+namespace std {\n+    \n+    class gslice\n+    {\n+    public:\n+        gslice ();\n+        gslice (size_t, const valarray<size_t>&, const valarray<size_t>&);\n+        // XXX: the IS says the copy-ctor and copy-assignment operators are\n+        //      synthetized by the compiler but they are just unsuitable\n+        //      for a ref-counted semantic\n+        gslice(const gslice&);\n+        ~gslice();\n+\n+        // XXX: See the note above.\n+        gslice& operator= (const gslice&);\n+        \n+        size_t           start () const;\n+        valarray<size_t> size () const;\n+        valarray<size_t> stride () const;\n+        \n+    private:\n+        struct _Indexer {\n+            size_t _M_count;\n+            size_t _M_start;\n+            valarray<size_t> _M_size;\n+            valarray<size_t> _M_stride;\n+            valarray<size_t> _M_index;\n+            _Indexer(size_t, const valarray<size_t>&,\n+                     const valarray<size_t>&);\n+            void _M_increment_use() { ++_M_count; }\n+            size_t _M_decrement_use() { return --_M_count; }\n+        };\n+\n+        _Indexer* _M_index;\n+        \n+        template<typename _Tp> friend class valarray;\n+    };\n+    \n+    inline size_t\n+    gslice::start () const\n+    { return _M_index ? _M_index->_M_start : 0; }\n+    \n+    inline valarray<size_t>\n+    gslice::size () const\n+    { return _M_index ? _M_index->_M_size : valarray<size_t>(); }\n+    \n+    inline valarray<size_t>\n+    gslice::stride () const\n+    { return _M_index ? _M_index->_M_stride : valarray<size_t>(); }\n+    \n+    inline gslice::gslice () : _M_index(0) {}\n+\n+    inline\n+    gslice::gslice(size_t __o, const valarray<size_t>& __l,\n+                   const valarray<size_t>& __s)\n+            : _M_index(new gslice::_Indexer(__o, __l, __s)) {}\n+\n+    inline\n+    gslice::gslice(const gslice& __g) : _M_index(__g._M_index)\n+    { if (_M_index) _M_index->_M_increment_use(); }\n+    \n+    inline\n+    gslice::~gslice()\n+    { if (_M_index && _M_index->_M_decrement_use() == 0) delete _M_index; }\n+\n+    inline gslice&\n+    gslice::operator= (const gslice& __g)\n+    {\n+        if (__g._M_index) __g._M_index->_M_increment_use();\n+        if (_M_index && _M_index->_M_decrement_use() == 0) delete _M_index;\n+        _M_index = __g._M_index;\n+        return *this;\n+    }\n+            \n+    \n+} // std::\n+\n+\n+#endif /* _CPP_BITS_GSLICE_H */\n+\n+// Local Variables:\n+// mode:c++\n+// End:"}, {"sha": "cad3485631a93d5a79811e7f5667886710563d84", "filename": "libstdc++-v3/bits/gslice_array.h", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fgslice_array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fgslice_array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fgslice_array.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,169 @@\n+// The template and inlines for the -*- C++ -*- gslice_array class.\n+\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// Written by Gabriel Dos Reis <Gabriel.Dos-Reis@DPTMaths.ENS-Cachan.Fr>\n+\n+#ifndef _CPP_BITS_GSLICE_ARRAY\n+#define _CPP_BITS_GSLICE_ARRAY 1\n+\n+namespace std {\n+\n+    template<typename _Tp> class gslice_array\n+    {\n+    public:\n+        typedef _Tp value_type;\n+\n+        void operator=  (const valarray<_Tp>&) const;\n+        void operator*= (const valarray<_Tp>&) const;\n+        void operator/= (const valarray<_Tp>&) const;\n+        void operator%= (const valarray<_Tp>&) const;\n+        void operator+= (const valarray<_Tp>&) const;\n+        void operator-= (const valarray<_Tp>&) const;\n+        void operator^= (const valarray<_Tp>&) const;\n+        void operator&= (const valarray<_Tp>&) const;\n+        void operator|= (const valarray<_Tp>&) const;\n+        void operator<<=(const valarray<_Tp>&) const;\n+        void operator>>=(const valarray<_Tp>&) const;\n+        void operator=(const _Tp&);\n+\n+        template<class _Dom>\n+        void operator= (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator*= (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator/= (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator%= (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator+= (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator-= (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator^= (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator&= (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator|= (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator<<= (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator>>= (const _Expr<_Dom,_Tp>&) const;\n+        \n+    private:\n+        _Array<_Tp>    _M_array;\n+        const valarray<size_t>& _M_index;\n+        \n+        friend class valarray<_Tp>;\n+        \n+        gslice_array (_Array<_Tp>, const valarray<size_t>&);\n+\n+        // this constructor needs to be implemented.\n+        gslice_array (const gslice_array&);\n+\n+        // not implemented\n+        gslice_array();\n+        gslice_array& operator= (const gslice_array&);\n+    };\n+\n+    template<typename _Tp>\n+    inline\n+    gslice_array<_Tp>::gslice_array (_Array<_Tp> __a,\n+                                     const valarray<size_t>& __i)\n+            : _M_array (__a), _M_index (__i) {}\n+\n+\n+    template<typename _Tp>\n+    inline\n+    gslice_array<_Tp>::gslice_array (const gslice_array<_Tp>& __a)\n+            : _M_array (__a._M_array), _M_index (__a._M_index) {}\n+\n+    \n+    template<typename _Tp>\n+    inline void\n+    gslice_array<_Tp>::operator= (const _Tp& __t) \n+    { \n+        __valarray_fill (_M_array, _Array<size_t>(_M_index),\n+                         _M_index.size(), __t); \n+    }\n+\n+    template<typename _Tp>\n+    inline void\n+    gslice_array<_Tp>::operator= (const valarray<_Tp>& __v) const\n+    {\n+        __valarray_copy (_Array<_Tp> (__v), __v.size (),\n+                         _M_array, _Array<size_t>(_M_index));\n+    }\n+\n+    template<typename _Tp>\n+    template<class E>\n+    inline void\n+    gslice_array<_Tp>::operator= (const _Expr<E, _Tp>& __e) const\n+    {\n+        __valarray_copy (__e, _M_index.size(), _M_array,\n+                         _Array<size_t>(_M_index));\n+    }\n+\n+#undef _DEFINE_VALARRAY_OPERATOR\n+#define _DEFINE_VALARRAY_OPERATOR(op, name)\t\t\t\t\\\n+template<typename _Tp>\t\t\t\t\t\t\t\\\n+inline void\t\t\t\t\t\t\t\t\\\n+gslice_array<_Tp>::operator##op##= (const valarray<_Tp>& __v) const\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+    _Array_augmented_##name (_M_array, _Array<size_t>(_M_index),\t\\\n+                              _Array<_Tp> (__v), __v.size ());\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+template<typename _Tp> template<class E>        \t\t\t\\\n+inline void \t\t\t\t\t\t\t\t\\\n+gslice_array<_Tp>::operator##op##= (const _Expr<E, _Tp>& __e) const\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+    _Array_augmented_##name (_M_array, _Array<size_t>(_M_index), __e,\t\\\n+                              _M_index.size());\t\t\t\t\\\n+}\n+\n+_DEFINE_VALARRAY_OPERATOR(*, multiplies)\n+_DEFINE_VALARRAY_OPERATOR(/, divides)    \n+_DEFINE_VALARRAY_OPERATOR(%, modulus)\n+_DEFINE_VALARRAY_OPERATOR(+, plus)    \n+_DEFINE_VALARRAY_OPERATOR(-, minus)\n+_DEFINE_VALARRAY_OPERATOR(^, xor)\n+_DEFINE_VALARRAY_OPERATOR(&, and)\n+_DEFINE_VALARRAY_OPERATOR(|, or)\n+_DEFINE_VALARRAY_OPERATOR(<<, shift_left)\n+_DEFINE_VALARRAY_OPERATOR(>>, shift_right)\n+\n+#undef _DEFINE_VALARRAY_OPERATOR\n+\n+} // std::\n+\n+#endif /* _CPP_BITS_GSLICE_ARRAY */\n+\n+// Local Variables:\n+// mode:c++\n+// End:"}, {"sha": "73d382a61c13951bc87e0e4cce8c4efc8fc9e45f", "filename": "libstdc++-v3/bits/indirect_array.h", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Findirect_array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Findirect_array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Findirect_array.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,160 @@\n+// The template and inlines for the -*- C++ -*- indirect_array class.\n+\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// Written by Gabriel Dos Reis <Gabriel.Dos-Reis@DPTMaths.ENS-Cachan.Fr>\n+\n+#ifndef _CPP_BITS_INDIRECT_ARRAY_H\n+#define _CPP_BITS_INDIRECT_ARRAY_H\n+\n+namespace std {\n+\n+    template <class _Tp> class indirect_array\n+    {\n+    public:\n+        typedef _Tp value_type;\n+    \n+        void operator=  (const valarray<_Tp>&) const;\n+        void operator*= (const valarray<_Tp>&) const;\n+        void operator/= (const valarray<_Tp>&) const;\n+        void operator%= (const valarray<_Tp>&) const; \n+        void operator+= (const valarray<_Tp>&) const;\n+        void operator-= (const valarray<_Tp>&) const;  \n+        void operator^= (const valarray<_Tp>&) const;\n+        void operator&= (const valarray<_Tp>&) const;\n+        void operator|= (const valarray<_Tp>&) const;\n+        void operator<<= (const valarray<_Tp>&) const;\n+        void operator>>= (const valarray<_Tp>&) const; \n+        void operator= (const _Tp&);\n+        //    ~indirect_array();\n+\n+        template<class _Dom>\n+        void operator=  (const _Expr<_Dom, _Tp>&) const;\n+        template<class _Dom>\n+        void operator*= (const _Expr<_Dom, _Tp>&) const;\n+        template<class _Dom>\n+        void operator/= (const _Expr<_Dom, _Tp>&) const;\n+        template<class _Dom>\n+        void operator%= (const _Expr<_Dom, _Tp>&) const;\n+        template<class _Dom>\n+        void operator+= (const _Expr<_Dom, _Tp>&) const;\n+        template<class _Dom>\n+        void operator-= (const _Expr<_Dom, _Tp>&) const;\n+        template<class _Dom>\n+        void operator^= (const _Expr<_Dom, _Tp>&) const;\n+        template<class _Dom>\n+        void operator&= (const _Expr<_Dom, _Tp>&) const;\n+        template<class _Dom>\n+        void operator|= (const _Expr<_Dom, _Tp>&) const;\n+        template<class _Dom>\n+        void operator<<= (const _Expr<_Dom, _Tp>&) const;\n+        template<class _Dom>\n+        void operator>>= (const _Expr<_Dom, _Tp>&) const; \n+\n+    private:\n+    indirect_array (const indirect_array&);\n+    indirect_array (_Array<_Tp>, size_t, _Array<size_t>);\n+\n+    friend class valarray<_Tp>;\n+    friend class gslice_array<_Tp>;\n+\n+    const size_t \t _M_sz;\n+    const _Array<size_t> _M_index;\n+    const _Array<_Tp> \t _M_array;\n+\n+        // not implemented\n+        indirect_array ();\n+        indirect_array& operator= (const indirect_array&);\n+    };\n+\n+    template<typename _Tp>\n+    inline indirect_array<_Tp>::indirect_array(const indirect_array<_Tp>& __a)\n+            : _M_sz (__a._M_sz), _M_index (__a._M_index),\n+              _M_array (__a._M_array) {}\n+    \n+    template<typename _Tp>\n+    inline\n+    indirect_array<_Tp>::indirect_array (_Array<_Tp> __a, size_t __s, \n+                                         _Array<size_t> __i)\n+            : _M_sz (__s), _M_index (__i), _M_array (__a) {}\n+    \n+    // template<typename _Tp>\n+    // inline indirect_array<_Tp>::~indirect_array() {}\n+\n+    template<typename _Tp>\n+    inline void\n+    indirect_array<_Tp>::operator= (const _Tp& __t)\n+    { __valarray_fill(_M_array, _M_index, _M_sz, __t); }\n+\n+    template<typename _Tp>\n+    inline void\n+    indirect_array<_Tp>::operator= (const valarray<_Tp>& __v) const\n+    { __valarray_copy (_Array<_Tp> (__v), _M_sz, _M_array, _M_index); }\n+\n+    template<typename _Tp>\n+    template<class _Dom>\n+    inline void\n+    indirect_array<_Tp>::operator= (const _Expr<_Dom,_Tp>& __e) const\n+    { __valarray_copy (__e, _M_sz, _M_array, _M_index); }\n+\n+#undef _DEFINE_VALARRAY_OPERATOR\n+#define _DEFINE_VALARRAY_OPERATOR(op, name)\t\t\t\t\\\n+template<typename _Tp>\t\t\t\t\t\t\t\\\n+inline void\t\t\t\t\t\t\t\t\\\n+indirect_array<_Tp>::operator##op##= (const valarray<_Tp>& __v) const\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  _Array_augmented_##name (_M_array, _M_index, _Array<_Tp> (__v), _M_sz); \\\n+}\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+template<typename _Tp> template<class _Dom>\t\t\t\t\\\n+inline void\t\t\t\t\t\t\t\t\\\n+indirect_array<_Tp>::operator##op##= (const _Expr<_Dom,_Tp>& __e) const \\\n+{\t\t\t\t\t\t\t\t\t\\\n+  _Array_augmented_##name (_M_array, _M_index, __e, _M_sz);\t\t\\\n+}\n+\n+_DEFINE_VALARRAY_OPERATOR(*, multiplies)\n+_DEFINE_VALARRAY_OPERATOR(/, divides)\n+_DEFINE_VALARRAY_OPERATOR(%, modulus)\n+_DEFINE_VALARRAY_OPERATOR(+, plus)\n+_DEFINE_VALARRAY_OPERATOR(-, minus)\n+_DEFINE_VALARRAY_OPERATOR(^, xor)\n+_DEFINE_VALARRAY_OPERATOR(&, and)\n+_DEFINE_VALARRAY_OPERATOR(|, or)\n+_DEFINE_VALARRAY_OPERATOR(<<, shift_left)\n+_DEFINE_VALARRAY_OPERATOR(>>, shift_right)\n+\n+#undef _DEFINE_VALARRAY_OPERATOR\n+\n+} // std::\n+\n+#endif /* _CPP_BITS_INDIRECT_ARRAY_H */\n+\n+// Local Variables:\n+// mode:c++\n+// End:"}, {"sha": "ee257c67c30d1863e9ef9f244ecc578beb4cb0f5", "filename": "libstdc++-v3/bits/ios_base.h", "status": "added", "additions": 576, "deletions": 0, "changes": 576, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fios_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fios_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fios_base.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,576 @@\n+// Iostreams base classes -*- C++ -*-\n+\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 27.8  File-based streams\n+//\n+\n+#ifndef _CPP_BITS_IOSBASE_H\n+#define _CPP_BITS_IOSBASE_H 1\n+\n+namespace std {\n+\n+  // The following definitions of bitmask types are enums, not ints,\n+  // as permitted (but not required) in the standard, in order to provide\n+  // better type safety in iostream calls.  A side effect is that\n+  // expressions involving them are no longer compile-time constants.\n+  enum _Ios_Fmtflags { _S_ios_fmtflags_end = 1<<16 };\n+\n+  inline _Ios_Fmtflags \n+  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)\n+  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }\n+\n+  inline _Ios_Fmtflags \n+  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)\n+  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }\n+\n+  inline _Ios_Fmtflags \n+  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)\n+  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }\n+\n+  inline _Ios_Fmtflags \n+  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)\n+  { return __a = __a | __b; }\n+\n+  inline _Ios_Fmtflags \n+  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)\n+  { return __a = __a & __b; }\n+\n+  inline _Ios_Fmtflags \n+  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)\n+  { return __a = __a ^ __b; }\n+\n+  inline _Ios_Fmtflags \n+  operator~(_Ios_Fmtflags __a)\n+  { return _Ios_Fmtflags(~static_cast<int>(__a)); }\n+\n+\n+  enum _Ios_Openmode { _S_ios_openmode_end = 1<<16 };\n+\n+  inline _Ios_Openmode \n+  operator&(_Ios_Openmode __a, _Ios_Openmode __b)\n+  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }\n+\n+  inline _Ios_Openmode \n+  operator|(_Ios_Openmode __a, _Ios_Openmode __b)\n+  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }\n+\n+  inline _Ios_Openmode \n+  operator^(_Ios_Openmode __a, _Ios_Openmode __b)\n+  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }\n+\n+  inline _Ios_Openmode \n+  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)\n+  { return __a = __a | __b; }\n+\n+  inline _Ios_Openmode \n+  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)\n+  { return __a = __a & __b; }\n+\n+  inline _Ios_Openmode \n+  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)\n+  { return __a = __a ^ __b; }\n+\n+  inline _Ios_Openmode \n+  operator~(_Ios_Openmode __a)\n+  { return _Ios_Openmode(~static_cast<int>(__a)); }\n+\n+\n+  enum _Ios_Iostate { _S_ios_iostate_end = 1<<16 };\n+\n+  inline _Ios_Iostate \n+  operator&(_Ios_Iostate __a, _Ios_Iostate __b)\n+  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }\n+\n+  inline _Ios_Iostate \n+  operator|(_Ios_Iostate __a, _Ios_Iostate __b)\n+  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }\n+\n+  inline _Ios_Iostate \n+  operator^(_Ios_Iostate __a, _Ios_Iostate __b)\n+  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }\n+\n+  inline _Ios_Iostate \n+  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)\n+  { return __a = __a | __b; }\n+\n+  inline _Ios_Iostate \n+  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)\n+  { return __a = __a & __b; }\n+\n+  inline _Ios_Iostate \n+  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)\n+  { return __a = __a ^ __b; }\n+\n+  inline _Ios_Iostate \n+  operator~(_Ios_Iostate __a)\n+  { return _Ios_Iostate(~static_cast<int>(__a)); }\n+\n+  enum _Ios_Seekdir { _S_ios_Seekdir_end = 1<<16 };\n+\n+  // 27.4.2  Class ios_base\n+  class ios_base\n+  {\n+  public:\n+\n+    // 27.4.2.1.1  Class ios_base::failure\n+    class failure : public exception\n+    {\n+    public:\n+#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n+      // Can't do exception(_msg) as defined in 27.4.2.1.1\n+      explicit \n+      failure(const string& __str);\n+\n+      virtual \n+      ~failure() { };\n+\n+      virtual const \n+      char* what() const throw() { return _M_name; }\n+      \n+    private:\n+      enum { _M_bufsize = 256 };\n+      char _M_name[_M_bufsize];\n+#endif\n+    };\n+\n+    // 27.4.2.1.2  Type ios_base::fmtflags\n+    typedef _Ios_Fmtflags fmtflags;\n+    // 27.4.2.1.2  Type fmtflags\n+    static const fmtflags boolalpha =   fmtflags(__ios_flags::_S_boolalpha);\n+    static const fmtflags dec =         fmtflags(__ios_flags::_S_dec);\n+    static const fmtflags fixed =       fmtflags(__ios_flags::_S_fixed);\n+    static const fmtflags hex =         fmtflags(__ios_flags::_S_hex);\n+    static const fmtflags internal =    fmtflags(__ios_flags::_S_internal);\n+    static const fmtflags left =        fmtflags(__ios_flags::_S_left);\n+    static const fmtflags oct =         fmtflags(__ios_flags::_S_oct);\n+    static const fmtflags right =       fmtflags(__ios_flags::_S_right);\n+    static const fmtflags scientific =  fmtflags(__ios_flags::_S_scientific);\n+    static const fmtflags showbase =    fmtflags(__ios_flags::_S_showbase);\n+    static const fmtflags showpoint =   fmtflags(__ios_flags::_S_showpoint);\n+    static const fmtflags showpos =     fmtflags(__ios_flags::_S_showpos);\n+    static const fmtflags skipws =      fmtflags(__ios_flags::_S_skipws);\n+    static const fmtflags unitbuf =     fmtflags(__ios_flags::_S_unitbuf);\n+    static const fmtflags uppercase =   fmtflags(__ios_flags::_S_uppercase);\n+    static const fmtflags adjustfield = fmtflags(__ios_flags::_S_adjustfield);\n+    static const fmtflags basefield =   fmtflags(__ios_flags::_S_basefield);\n+    static const fmtflags floatfield =  fmtflags(__ios_flags::_S_floatfield);\n+\n+    // 27.4.2.1.3  Type ios_base::iostate\n+    typedef _Ios_Iostate iostate;\n+    static const iostate badbit =  \tiostate(__ios_flags::_S_badbit);\n+    static const iostate eofbit =  \tiostate(__ios_flags::_S_eofbit);\n+    static const iostate failbit = \tiostate(__ios_flags::_S_failbit);\n+    static const iostate goodbit = \tiostate(0);\n+\n+    // 27.4.2.1.4  Type openmode\n+    typedef _Ios_Openmode openmode;\n+    static const openmode app =    \topenmode(__ios_flags::_S_app);\n+    static const openmode ate =    \topenmode(__ios_flags::_S_ate);\n+    static const openmode binary = \topenmode(__ios_flags::_S_bin);\n+    static const openmode in =     \topenmode(__ios_flags::_S_in);\n+    static const openmode out =    \topenmode(__ios_flags::_S_out);\n+    static const openmode trunc =  \topenmode(__ios_flags::_S_trunc);\n+\n+    // 27.4.2.1.5  Type seekdir\n+    typedef _Ios_Seekdir seekdir;\n+    static const seekdir beg = \t\tseekdir(0);\n+    static const seekdir cur = \t\tseekdir(SEEK_CUR);\n+    static const seekdir end = \t\tseekdir(SEEK_END);\n+\n+#ifdef _GLIBCPP_DEPRICATED\n+    typedef int io_state;\n+    typedef int open_mode;\n+    typedef int seek_dir;\n+#endif\n+\n+    // Callbacks;\n+    enum event\n+    {\n+      erase_event,\n+      imbue_event,\n+      copyfmt_event\n+    };\n+\n+    typedef void (*event_callback) (event, ios_base&, int);\n+\n+    void \n+    register_callback(event_callback __fn, int __index);\n+\n+  protected:\n+    // Data Members\n+    streamsize \t\t_M_precision;\n+    streamsize \t\t_M_width;\n+    fmtflags \t\t_M_flags;\n+\n+     // 27.4.2.6  Members for callbacks\n+    // 27.4.2.6  ios_base callbacks\n+\n+    struct _Callback_list\n+    {\n+      // Data Members\n+      _Callback_list* \t\t_M_next;\n+      ios_base::event_callback \t_M_fn;\n+      int \t\t\t_M_index;\n+      int \t\t\t_M_refcount;  // 0 means one reference.\n+    \n+      _Callback_list(ios_base::event_callback __fn, int __index, \n+\t\t     _Callback_list* __cb)\n+      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }\n+      \n+      void \n+      _M_add_reference() { ++_M_refcount; } // XXX MT\n+      \n+      int \n+      _M_remove_reference() { return _M_refcount--; }  // 0 => OK to delete\n+    };\n+\n+     _Callback_list*  \t_M_callbacks;\n+\n+    void \n+    _M_call_callbacks(event __ev) throw();\n+\n+    void \n+    _M_dispose_callbacks(void);\n+\n+   // 27.4.2.5  Members for iword/pword storage\n+    struct _Words \n+    { \n+      void* \t_M_pword; \n+      long \t_M_iword; \n+    };\n+\n+    static const int \t_S_local_words = 8;\n+    _Words  \t\t_M_word_array[_S_local_words];  // Guaranteed storage\n+    _Words  \t\t_M_dummy;    // Only for failed iword/pword calls.\n+    _Words* \t\t_M_words;\n+    int     \t\t_M_word_limit;\n+ \n+    _Words& \n+    _M_grow_words(int __index);\n+\n+    // Members for locale and locale caching.\n+    locale \t\t_M_locale_ios;\n+\n+    void \n+    _M_init();\n+\n+  public:\n+    // 27.4.2.1.6  Class ios_base::Init\n+    // Used to initialize standard streams. In theory, g++ could use\n+    // -finit-priority to order this stuff correctly without going\n+    // through these machinations. \n+\n+    class Init \n+    {\n+      friend class ios_base;\n+    public:\n+      Init();\n+      ~Init();\n+    private:\n+      static int \t_M_ios_base_init;\n+      filebuf* \t\t_M_cout;\n+      filebuf* \t\t_M_cin;\n+      filebuf* \t\t_M_cerr;\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+      wfilebuf* \t_M_wcout;\n+      wfilebuf*        \t_M_wcin;\n+      wfilebuf* \t_M_wcerr;\n+#endif\n+    };\n+\n+    // Fmtflags state:\n+    inline fmtflags \n+    flags() const { return _M_flags; }\n+\n+    inline fmtflags \n+    flags(fmtflags __fmtfl)\n+    { \n+      fmtflags __old = _M_flags; \n+      _M_flags = __fmtfl; \n+      return __old; \n+    }\n+\n+    inline fmtflags \n+    setf(fmtflags __fmtfl)\n+    { \n+      fmtflags __old = _M_flags; \n+      _M_flags |= __fmtfl; \n+      return __old; \n+    }\n+\n+    inline fmtflags \n+    setf(fmtflags __fmtfl, fmtflags __mask)\n+    {\n+      fmtflags __old = _M_flags;\n+      _M_flags &= ~__mask;\n+      _M_flags |= (__fmtfl & __mask);\n+      return __old;\n+    }\n+\n+    inline void \n+    unsetf(fmtflags __mask) { _M_flags &= ~__mask; }\n+\n+    inline streamsize \n+    precision() const { return _M_precision; }\n+\n+    inline streamsize \n+    precision(streamsize __prec)\n+    { \n+      streamsize __old = _M_precision; \n+      _M_precision = __prec; \n+      return __old; \n+    }\n+\n+    inline streamsize \n+    width() const { return _M_width; }\n+\n+    inline streamsize \n+    width(streamsize __wide)\n+    { \n+      streamsize __old = _M_width; \n+      _M_width = __wide; \n+      return __old; \n+    }\n+\n+    static bool \n+    sync_with_stdio(bool __sync = true);\n+\n+   // Locales:\n+    locale \n+    imbue(const locale& __loc);\n+\n+    inline locale \n+    getloc() const { return _M_locale_ios; }\n+\n+    // Storage:\n+    static int \n+    xalloc() throw();\n+\n+    inline long& \n+    iword(int __ix)\n+    {\n+      _Words& __word = (__ix < _M_word_limit) \n+\t\t\t? _M_words[__ix] : _M_grow_words(__ix);\n+      return __word._M_iword;\n+    }\n+\n+    inline void*& \n+    pword(int __ix)\n+    {\n+      _Words& __word = (__ix < _M_word_limit) \n+\t\t\t? _M_words[__ix] : _M_grow_words(__ix);\n+      return __word._M_pword;\n+    }\n+\n+    // Destructor\n+    ~ios_base();\n+\n+  protected:\n+    ios_base();\n+\n+#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n+  private:\n+    ios_base(const ios_base&);\n+\n+    ios_base& \n+    operator=(const ios_base&);\n+#endif\n+  };\n+ \n+  // 27.4.5.1 fmtflags manipulators:\n+  inline ios_base& \n+  boolalpha(ios_base& __base)\n+  {\n+    __base.setf(ios_base::boolalpha);\n+    return __base;\n+  }\n+\n+  inline ios_base& \n+  noboolalpha(ios_base& __base)\n+  {\n+    __base.unsetf(ios_base::boolalpha);\n+    return __base;\n+  }\n+\n+  inline ios_base& \n+  showbase(ios_base& __base)\n+  {\n+    __base.setf(ios_base::showbase);\n+    return __base;\n+  }\n+\n+  inline ios_base& \n+  noshowbase(ios_base& __base)\n+  {\n+    __base.unsetf(ios_base::showbase);\n+    return __base;\n+  }\n+\n+  inline ios_base& \n+  showpoint(ios_base& __base)\n+  {\n+    __base.setf(ios_base::showpoint);\n+    return __base;\n+  }\n+\n+  inline ios_base& \n+  noshowpoint(ios_base& __base)\n+  {\n+    __base.unsetf(ios_base::showpoint);\n+    return __base;\n+  }\n+\n+  inline ios_base& \n+  showpos(ios_base& __base)\n+  {\n+    __base.setf(ios_base::showpos);\n+    return __base;\n+  }\n+\n+  inline ios_base& \n+  noshowpos(ios_base& __base)\n+  {\n+    __base.unsetf(ios_base::showpos);\n+    return __base;\n+  }\n+\n+  inline ios_base& \n+  skipws(ios_base& __base)\n+  {\n+    __base.setf(ios_base::skipws);\n+    return __base;\n+  }\n+  \n+  inline ios_base& \n+  noskipws(ios_base& __base)\n+  {\n+    __base.unsetf(ios_base::skipws);\n+    return __base;\n+  }\n+\n+  inline ios_base& \n+  uppercase(ios_base& __base)\n+  {\n+    __base.setf(ios_base::uppercase);\n+    return __base;\n+  }\n+\n+  inline ios_base& \n+  nouppercase(ios_base& __base)\n+  {\n+    __base.unsetf(ios_base::uppercase);\n+    return __base;\n+  }\n+\n+  inline ios_base& \n+  unitbuf(ios_base& __base)\n+  {\n+     __base.setf(ios_base::unitbuf);      \n+     return __base;\n+  }\n+\n+  inline ios_base& \n+  nounitbuf(ios_base& __base)\n+  {\n+     __base.unsetf(ios_base::unitbuf);\n+     return __base;    \n+  }\n+\n+  // 27.4.5.2 adjustfield anipulators:\n+  inline ios_base& \n+  internal(ios_base& __base)\n+  {\n+     __base.setf(ios_base::internal, ios_base::adjustfield);\n+     return __base;    \n+  }\n+\n+  inline ios_base& \n+  left(ios_base& __base)\n+  {\n+    __base.setf(ios_base::left, ios_base::adjustfield);\n+    return __base;\n+  }\n+  \n+  inline ios_base& \n+  right(ios_base& __base)\n+  {\n+    __base.setf(ios_base::right, ios_base::adjustfield);\n+    return __base;\n+  }\n+  \n+  // 27.4.5.3 basefield anipulators:\n+  inline ios_base& \n+  dec(ios_base& __base)\n+  {\n+    __base.setf(ios_base::dec, ios_base::basefield);\n+    return __base;\n+  }\n+  \n+  inline ios_base& \n+  hex(ios_base& __base)\n+  {\n+    __base.setf(ios_base::hex, ios_base::basefield);\n+    return __base;\n+  }\n+\n+  inline ios_base& \n+  oct(ios_base& __base)\n+  {\n+    __base.setf(ios_base::oct, ios_base::basefield);\n+    return __base;\n+  }\n+  \n+  // 27.4.5.4 floatfield anipulators:\n+  inline ios_base& \n+  fixed(ios_base& __base)\n+  {\n+    __base.setf(ios_base::fixed, ios_base::floatfield);\n+    return __base;\n+  }\n+\n+  inline ios_base& \n+  scientific(ios_base& __base)\n+  {\n+    __base.setf(ios_base::scientific, ios_base::floatfield);\n+    return __base;\n+  }\n+\n+} // namespace std\n+\n+#endif /* _CPP_BITS_IOSBASE_H */\n+\n+\n+\n+\n+\n+\n+\n+\n+"}, {"sha": "71cc96147aec41115f4721c9869180252b9432f6", "filename": "libstdc++-v3/bits/istream.tcc", "status": "added", "additions": 1216, "deletions": 0, "changes": 1216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fistream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fistream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fistream.tcc?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,1216 @@\n+// Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 27.6.2  Output streams\n+//\n+\n+#include <bits/std_locale.h>\n+\n+namespace std {\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>::sentry::\n+    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskipws)\n+    {\n+      if (__in.good()) \n+\t{\n+\t  if (__in.tie())\n+\t    __in.tie()->flush();\n+\t  if (!__noskipws && (__in.flags() & ios_base::skipws))\n+\t    {\t  \n+\t      const __int_type __eof = traits_type::eof();\n+\t      __int_type __c = __int_type(0);\n+\t      __streambuf_type* __sb = __in.rdbuf();\n+\t      const __ctype_type* __ctype = __in._M_get_fctype_ios();\n+\t      bool __testsp = true;\n+\t      bool __testeof = false;\n+\t      \n+\t      while (!__testeof && __testsp)\n+\t\t{\n+\t\t  __c = __sb->sbumpc();\n+\t\t  __testeof = __c == __eof;\n+\t\t  __testsp = __ctype->is(ctype_base::space, __c);\n+\t\t}\n+\t      \n+\t      if (!__testeof && !__testsp)\n+\t\t__sb->sputbackc(__c);\n+#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n+//195.  Should basic_istream::sentry's constructor ever set eofbit? \n+\t      else\n+\t\t__in.setstate(ios_base::eofbit);\n+#endif\n+\t    }\n+\t}\n+      _M_ok = __in.good();\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>::\n+    operator>>(__istream_type& (*__pf)(__istream_type&))\n+    {\n+      sentry __cerb(*this, false);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    __pf(*this);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>::\n+    operator>>(__ios_type& (*__pf)(__ios_type&))\n+    {\n+      sentry __cerb(*this, false);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    __pf(*this);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+  \n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>::\n+    operator>>(ios_base& (*__pf)(ios_base&))\n+    {\n+      sentry __cerb(*this, false);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    __pf(*this);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+  \n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>::\n+    operator>>(bool& __n)\n+    {\n+      sentry __cerb(*this, false);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    iostate __err = iostate(ios_base::goodbit);\n+\t    _M_fnumget->get(*this, 0, *this, __err, __n);\n+\t    this->setstate(__err);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>::\n+    operator>>(short& __n)\n+    {\n+      sentry __cerb(*this, false);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    iostate __err = iostate(ios_base::goodbit);\n+\t    _M_fnumget->get(*this, 0, *this, __err, __n);\n+\t    this->setstate(__err);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>::\n+    operator>>(unsigned short& __n)\n+    {\n+      sentry __cerb(*this, false);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    iostate __err = iostate(ios_base::goodbit);\n+\t    _M_fnumget->get(*this, 0, *this, __err, __n);\n+\t    this->setstate(__err);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>::\n+    operator>>(int& __n)\n+    {\n+      sentry __cerb(*this, false);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    iostate __err = iostate(ios_base::goodbit);\n+\t    _M_fnumget->get(*this, 0, *this, __err, __n);\n+\t    this->setstate(__err);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>::\n+    operator>>(unsigned int& __n)\n+    {\n+      sentry __cerb(*this, false);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    iostate __err = iostate(ios_base::goodbit);\n+\t    _M_fnumget->get(*this, 0, *this, __err, __n);\n+\t    this->setstate(__err);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>::\n+    operator>>(long& __n)\n+    {\n+      sentry __cerb(*this, false);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    iostate __err = iostate(ios_base::goodbit);\n+\t    _M_fnumget->get(*this, 0, *this, __err, __n);\n+\t    this->setstate(__err);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>::\n+    operator>>(unsigned long& __n)\n+    {\n+      sentry __cerb(*this, false);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    iostate __err = iostate(ios_base::goodbit);\n+\t    _M_fnumget->get(*this, 0, *this, __err, __n);\n+\t    this->setstate(__err);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+\n+#ifdef _GLIBCPP_USE_LONG_LONG\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>::\n+    operator>>(long long& __n)\n+    {\n+      sentry __cerb(*this, false);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    iostate __err = iostate(ios_base::goodbit);\n+\t    _M_fnumget->get(*this, 0, *this, __err, __n);\n+\t    this->setstate(__err);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>::\n+    operator>>(unsigned long long& __n)\n+    {\n+      sentry __cerb(*this, false);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    iostate __err = iostate(ios_base::goodbit);\n+\t    _M_fnumget->get(*this, 0, *this, __err, __n);\n+\t    this->setstate(__err);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+#endif\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>::\n+    operator>>(float& __n)\n+    {\n+      sentry __cerb(*this, false);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    iostate __err = iostate(ios_base::goodbit);\n+\t    _M_fnumget->get(*this, 0, *this, __err, __n);\n+\t    this->setstate(__err);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>::\n+    operator>>(double& __n)\n+    {\n+      sentry __cerb(*this, false);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    iostate __err = iostate(ios_base::goodbit);\n+\t    _M_fnumget->get(*this, 0, *this, __err, __n);\n+\t    this->setstate(__err);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>::\n+    operator>>(long double& __n)\n+    {\n+      sentry __cerb(*this, false);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    iostate __err = iostate(ios_base::goodbit);\n+\t    _M_fnumget->get(*this, 0, *this, __err, __n);\n+\t    this->setstate(__err);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>::\n+    operator>>(void*& __n)\n+    {\n+      sentry __cerb(*this, false);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    iostate __err = iostate(ios_base::goodbit);\n+\t    _M_fnumget->get(*this, 0, *this, __err, __n);\n+\t    this->setstate(__err);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>::\n+    operator>>(__streambuf_type* __sbout)\n+    {\n+      streamsize __xtrct = 0;\n+      __streambuf_type* __sbin = this->rdbuf();\n+      sentry __cerb(*this, false);\n+      if (__sbout && __cerb)\n+\t__xtrct = _S_copy_streambufs(*this, __sbin, __sbout);\n+      if (!__sbout || !__xtrct)\n+\tthis->setstate(ios_base::failbit);\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>::int_type\n+    basic_istream<_CharT, _Traits>::\n+    get(void)\n+    {\n+      const int_type __eof = traits_type::eof();\n+      int_type __c = __eof;\n+      _M_gcount = 0;\n+      sentry __cerb(*this, true);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    __c = this->rdbuf()->sbumpc();\n+\t    // 27.6.1.1 paragraph 3\n+\t    if (__c != __eof)\n+\t      _M_gcount = 1;\n+\t    else\n+\t      this->setstate(ios_base::eofbit | ios_base::failbit);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.3 paragraph 1\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return __c;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>&\n+    basic_istream<_CharT, _Traits>::\n+    get(char_type& __c)\n+    {\n+      _M_gcount = 0;\n+      sentry __cerb(*this, true);\n+      if (__cerb) \n+\t{\n+\t  const int_type __eof = traits_type::eof();\n+\t  int_type __bufval;\n+ \t  try {\n+\t    __bufval = this->rdbuf()->sbumpc();\n+\t    // 27.6.1.1 paragraph 3\n+\t    if (__bufval != __eof)\n+\t      {\n+\t\t_M_gcount = 1;\n+\t\t__c = traits_type::to_char_type(__bufval);\n+\t      }\n+\t    else\n+\t      this->setstate(ios_base::eofbit | ios_base::failbit);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.3 paragraph 1\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>&\n+    basic_istream<_CharT, _Traits>::\n+    get(char_type* __s, streamsize __n, char_type __delim)\n+    {\n+      _M_gcount = 0;\n+      sentry __cerb(*this, true);\n+      if (__cerb && __n > 1) \n+\t{\n+\t  try {\n+\t    int_type __idelim = traits_type::to_int_type(__delim);\n+\t    __streambuf_type* __sb = this->rdbuf();\n+\t    int_type __c = __sb->sbumpc();\t\n+\t    const int_type __eof = traits_type::eof();\n+\t    bool __testdelim = __c == __idelim;\n+\t    bool __testeof =  __c == __eof;\n+\t    \n+\t    while (_M_gcount < __n - 1 && !__testeof && !__testdelim)\n+\t      {\n+\t\t*__s++ = traits_type::to_char_type(__c);\n+\t\t++_M_gcount;\n+\t\t__c = __sb->sbumpc();\n+\t\t__testeof = __c == __eof;\n+\t\t__testdelim = __c == __idelim;\n+\t      }\n+\t    if (__testdelim || _M_gcount == __n - 1)\n+\t      __sb->sputbackc(__c);\n+\t    if (__testeof)\n+\t      this->setstate(ios_base::eofbit);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.3 paragraph 1\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      *__s = char_type(NULL);\n+      if (!_M_gcount)\n+\tthis->setstate(ios_base::failbit);\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>&\n+    basic_istream<_CharT, _Traits>::\n+    get(__streambuf_type& __sb, char_type __delim)\n+    {\n+      _M_gcount = 0;\n+      sentry __cerb(*this, true);\n+      if (__cerb) \n+\t{\n+\t  __streambuf_type* __this_sb = this->rdbuf();\n+\t  int_type __c;\n+\t  try {\n+\t    int_type __idelim = traits_type::to_int_type(__delim);\n+\t    __c = __this_sb->sbumpc();\n+\t    const int_type __eof = traits_type::eof();\t      \n+\t    bool __testdelim = __c == __idelim;\n+\t    bool __testeof =  __c == __eof;\n+\t    bool __testput = true;\n+\t    streamsize __n = __this_sb->in_avail();\n+\n+\t    while (_M_gcount <= __n \n+\t\t   && !__testeof \n+\t\t   && !__testdelim \n+\t\t   && (__testput = __sb.sputc(traits_type::to_char_type(__c)) \n+\t\t                   != __eof))\n+\t      {\n+\t\t++_M_gcount;\n+\t\t__c = __this_sb->sbumpc();\n+\t\t__testeof = __c == __eof;\n+\t\t__testdelim = __c == __idelim;\n+\t      }\n+\t    if (__testdelim || !__testput)\n+\t      __this_sb->sputbackc(traits_type::to_char_type(__c));\n+\t    if (__testeof)\n+\t      this->setstate(ios_base::eofbit);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // Exception may result from sputc->overflow.\n+\t    __this_sb->sputbackc(traits_type::to_char_type(__c));\n+\t  }\n+\t}\n+      if (!_M_gcount)\n+\tthis->setstate(ios_base::failbit);\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>&\n+    basic_istream<_CharT, _Traits>::\n+    getline(char_type* __s, streamsize __n, char_type __delim)\n+    {\n+      _M_gcount = 0;\n+      sentry __cerb(*this, true);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    int_type __idelim = traits_type::to_int_type(__delim);\n+\t    __streambuf_type* __sb = this->rdbuf();\n+\t    int_type __c = __sb->sbumpc();\n+\t    const int_type __eof = traits_type::eof();\n+\t    bool __testdelim = __c == __idelim;\n+\t    bool __testeof =  __c == __eof;\n+\t    \n+\t    while (_M_gcount < __n - 1 && !__testeof && !__testdelim)\n+\t      {\n+\t\t*__s++ = traits_type::to_char_type(__c);\n+\t\t++_M_gcount;\n+\t\t__c = __sb->sbumpc();\n+\t\t__testeof = __c == __eof;\n+\t\t__testdelim = __c == __idelim;\n+\t      }\n+\t    if (_M_gcount == __n - 1 && !__testeof && !__testdelim)\n+\t      {\n+\t\t__sb->sputbackc(traits_type::to_char_type(__c));\n+\t\tthis->setstate(ios_base::failbit);\n+\t      }\t    \n+\t    if (__testdelim)\n+\t      ++_M_gcount;\n+\t    if (__testeof)\n+\t      this->setstate(ios_base::eofbit);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.3 paragraph 1\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      *__s = char_type(NULL);\n+      if (!_M_gcount || _M_gcount == __n - 1)\n+\tthis->setstate(ios_base::failbit);\n+      return *this;\n+    }\n+  \n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>&\n+    basic_istream<_CharT, _Traits>::\n+    ignore(streamsize __n, int_type __delim)\n+    {\n+      _M_gcount = 0;\n+      sentry __cerb(*this, true);\n+      if (__cerb && __n > 0) \n+\t{\n+\t  try {\n+\t    int_type __idelim = traits_type::to_int_type(__delim);\n+\t    __streambuf_type* __sb = this->rdbuf();\n+\t    int_type __c = __sb->sbumpc();\t\n+\t    const int_type __eof = traits_type::eof();\n+\t    bool __testdelim = __c == __idelim;\n+\t    bool __testeof =  __c == __eof;\n+\t    \t\t\n+\t    __n = min(__n, numeric_limits<streamsize>::max());\n+\t    while (_M_gcount < __n - 1 && !__testeof && !__testdelim)\n+\t      {\n+\t\t++_M_gcount;\n+\t\t__c = __sb->sbumpc();\n+\t\t__testeof = __c == __eof;\n+\t\t__testdelim = __c == __idelim;\n+\t      }\n+\t    if ((_M_gcount == __n - 1 && !__testeof) || __testdelim)\n+\t      ++_M_gcount;\n+\t    if (__testeof)\n+\t      this->setstate(ios_base::eofbit);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.3 paragraph 1\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+  \n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>::int_type\n+    basic_istream<_CharT, _Traits>::\n+    peek(void)\n+    {\n+      int_type __c = traits_type::eof();\n+      _M_gcount = 0;\n+      sentry __cerb(*this, true);\n+      if (__cerb)\n+\t{\n+\t  try {\n+\t    __c = this->rdbuf()->sgetc();\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.3 paragraph 1\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t} \n+      return __c;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>&\n+    basic_istream<_CharT, _Traits>::\n+    read(char_type* __s, streamsize __n)\n+    {\n+      _M_gcount = 0;\n+      sentry __cerb(*this, true);\n+      if (__cerb) \n+\t{\n+\t  if (__n > 0)\n+\t    {\n+\t      try {\n+\t\t__streambuf_type* __sb = this->rdbuf();\n+\t\tint_type __c = __sb->sbumpc();\t\n+\t\tconst int_type __eof = traits_type::eof();\n+\t\tbool __testeof =  __c == __eof;\n+\t\t\n+\t\twhile (_M_gcount < __n - 1 && !__testeof)\n+\t\t  {\n+\t\t    *__s++ = traits_type::to_char_type(__c);\n+\t\t    ++_M_gcount;\n+\t\t    __c = __sb->sbumpc();\n+\t\t    __testeof = __c == __eof;\n+\t\t  }\n+\t\tif (__testeof)\n+\t\t  this->setstate(ios_base::eofbit | ios_base::failbit);\n+\t\telse\n+\t\t  {\n+\t\t    // _M_gcount == __n - 1\n+\t\t    *__s++ = traits_type::to_char_type(__c);\n+\t\t    ++_M_gcount;\n+\t\t  }\t    \n+\t      }\n+\t      catch(exception& __fail){\n+\t\t// 27.6.1.3 paragraph 1\n+\t\t// Turn this on without causing an ios::failure to be thrown.\n+\t\tthis->setstate(ios_base::badbit);\n+\t\tif ((this->exceptions() & ios_base::badbit) != 0)\n+\t\t  throw;\n+\t      }\n+\t    }\n+\t}\n+      else\n+\tthis->setstate(ios_base::failbit);\n+      return *this;\n+    }\n+  \n+  template<typename _CharT, typename _Traits>\n+    streamsize \n+    basic_istream<_CharT, _Traits>::\n+    readsome(char_type* __s, streamsize __n)\n+    {\n+      const int_type __eof = traits_type::eof();\n+      _M_gcount = 0;\n+      sentry __cerb(*this, true);\n+      if (__cerb) \n+\t{\n+\t  if (__n > 0)\n+\t    {\n+\t      try {\n+\t\tstreamsize __num = this->rdbuf()->in_avail();\n+\t\tif (__num != static_cast<streamsize>(__eof))\n+\t\t  {\n+\t\t    __num = min(__num, __n);\n+\t\t    _M_gcount = this->rdbuf()->sgetn(__s, __num);\n+\t\t  }\n+\t\telse\n+\t\t  this->setstate(ios_base::eofbit);\t\t    \n+\t      }\n+\n+\t      catch(exception& __fail){\n+\t\t// 27.6.1.3 paragraph 1\n+\t\t// Turn this on without causing an ios::failure to be thrown.\n+\t\tthis->setstate(ios_base::badbit);\n+\t\tif ((this->exceptions() & ios_base::badbit) != 0)\n+\t\t  throw;\n+\t      }\n+\t    }\n+\t}\n+      else\n+\tthis->setstate(ios_base::failbit);\n+      return _M_gcount;\n+    }\n+      \n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>&\n+    basic_istream<_CharT, _Traits>::\n+    putback(char_type __c)\n+    {\n+      sentry __cerb(*this, true);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    const int_type __eof = traits_type::eof();\n+\t    __streambuf_type* __sb = this->rdbuf();\n+\t    if (!__sb || __sb->sputbackc(__c) == __eof) \n+\t      this->setstate(ios_base::badbit);\t\t    \n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.3 paragraph 1\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      else\n+\tthis->setstate(ios_base::failbit);\n+      return *this;\n+    }\n+  \n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>&\n+    basic_istream<_CharT, _Traits>::\n+    unget(void)\n+    {\n+      const int_type __eof = traits_type::eof();\n+      _M_gcount = 0;\n+      sentry __cerb(*this, true);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    __streambuf_type* __sb = this->rdbuf();\n+\t    if (!__sb || __eof == __sb->sungetc())\n+\t      this->setstate(ios_base::badbit);\t\t    \n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.3 paragraph 1\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      else\n+\tthis->setstate(ios_base::failbit);\n+      return *this;\n+    }\n+  \n+  template<typename _CharT, typename _Traits>\n+    int\n+    basic_istream<_CharT, _Traits>::\n+    sync(void)\n+    {\n+      int __retval = traits_type::eof();\n+      _M_gcount = 0;\n+      sentry __cerb(*this, true);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    __streambuf_type* __sb = this->rdbuf();\n+\t    if (!__sb || __retval == __sb->pubsync())\n+\t      this->setstate(ios_base::badbit);\t\t    \n+\t    else \n+\t      __retval = 0;\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.3 paragraph 1\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return __retval;\n+    }\n+  \n+  template<typename _CharT, typename _Traits>\n+    typename basic_istream<_CharT, _Traits>::pos_type\n+    basic_istream<_CharT, _Traits>::\n+    tellg(void)\n+    {\n+      pos_type __retval = pos_type(-1);\n+      _M_gcount = 0;\n+      sentry __cerb(*this, true);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    __retval = this->rdbuf()->pubseekoff(0, ios_base::cur, \n+\t\t\t\t\t\t ios_base::in);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.3 paragraph 1\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return __retval;\n+    }\n+\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>&\n+    basic_istream<_CharT, _Traits>::\n+    seekg(pos_type __pos)\n+    {\n+      _M_gcount = 0;\n+      sentry __cerb(*this, true);\n+      if (__cerb) \n+\t{\n+\t  try {\n+#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n+// 136.  seekp, seekg setting wrong streams?\n+\t    this->rdbuf()->pubseekpos(__pos, ios_base::in);\n+#endif\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.3 paragraph 1\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>&\n+    basic_istream<_CharT, _Traits>::\n+    seekg(off_type __off, ios_base::seekdir __dir)\n+    {\n+      _M_gcount = 0;\n+      sentry __cerb(*this, true);\n+      if (__cerb) \n+\t{\n+\t  try {\n+#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n+// 136.  seekp, seekg setting wrong streams?\n+\t    this->rdbuf()->pubseekoff(__off, __dir, ios_base::in);\n+#endif\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.3 paragraph 1\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+\n+  // 27.6.1.2.3 Character extraction templates\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>&\n+    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)\n+    {\n+      typedef basic_istream<_CharT, _Traits> \t\t__istream_type;\n+      __istream_type::sentry __cerb(__in, false);\n+      if (__cerb)\n+\t{\n+\t  try {\n+\t    __in.get(__c);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    __in.setstate(ios_base::badbit);\n+\t    if ((__in.exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      else\n+\t__in.setstate(ios_base::failbit);\n+      return __in;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>&\n+    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)\n+    {\n+      typedef basic_istream<_CharT, _Traits> \t\t__istream_type;\n+      typedef typename __istream_type::__streambuf_type __streambuf_type;\n+      typedef typename _Traits::int_type \t\tint_type;\n+      typedef _CharT                     \t\tchar_type;\n+      typedef ctype<_CharT>     \t\t\t__ctype_type;\n+      int_type __extracted = 0;\n+\n+      __istream_type::sentry __cerb(__in, false);\n+      if (__cerb)\n+\t{\n+\t  try {\n+\t    // Figure out how many characters to extract.\n+\t    int_type __num = static_cast<int_type>(__in.width());\n+\t    if (__num <= 0)\n+\t      __num = basic_string<_CharT, _Traits>::npos;\n+\n+\t    __streambuf_type* __sb = __in.rdbuf();\n+\t    const __ctype_type* __ctype = __in._M_get_fctype_ios();\n+\t    int_type __c = __sb->sbumpc();\n+\t    const int_type __eof = _Traits::eof();\n+\t    bool __testsp = __ctype->is(ctype_base::space, __c);\n+\t    bool __testeof =  __c == __eof;\n+\t    \n+\t    while (__extracted < __num - 1 && !__testeof && !__testsp)\n+\t      {\n+\t\t*__s++ = __c;\n+\t\t++__extracted;\n+\t\t__c = __sb->sbumpc();\n+\t\t__testeof = __c == __eof;\n+\t\t__testsp = __ctype->is(ctype_base::space, __c);\n+\t      }\n+\t    \n+\t    if (!__testeof)\n+\t      __sb->sputbackc(__c);\n+\t    else\n+\t      __in.setstate(ios_base::eofbit);\n+\n+#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n+//68.  Extractors for char* should store null at end\n+\t    *__s = char_type();\n+#endif\n+\t    __in.width(0);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    __in.setstate(ios_base::badbit);\n+\t    if ((__in.exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      if (!__extracted)\n+\t__in.setstate(ios_base::failbit);\n+      return __in;\n+    }\n+\n+  // 27.6.1.4 Standard basic_istream manipulators\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT,_Traits>& \n+    ws(basic_istream<_CharT,_Traits>& __in)\n+    {\n+      typedef basic_istream<_CharT, _Traits> \t\t__istream_type;\n+      typedef typename __istream_type::__streambuf_type __streambuf_type;\n+      typedef typename __istream_type::__ctype_type \t__ctype_type;\n+      typedef typename __istream_type::int_type \t__int_type;\n+      typedef typename __istream_type::char_type \t__char_type;\n+\n+      __streambuf_type* __sb = __in.rdbuf();\n+      const __ctype_type* __ctype = __in._M_get_fctype_ios();\n+      const __int_type __eof = _Traits::eof();\t      \n+      __int_type __c;\n+      bool __testeof;\n+      bool __testsp;\n+\n+      do \n+\t{\n+\t  __c = __sb->sbumpc();\n+\t  __testeof = __c == __eof;\n+\t  __testsp = __ctype->is(ctype_base::space, __c);\n+\t}\n+      while (!__testeof && __testsp);\n+\n+      if (!__testeof && !__testsp)\n+\t__sb->sputbackc(__c);\n+      else\n+\t__in.setstate(ios_base::eofbit);\n+\n+      return __in;\n+    }\n+\n+  // 21.3.7.8 basic_string::getline and operators\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    basic_istream<_CharT, _Traits>&\n+    operator>>(basic_istream<_CharT, _Traits>& __in,\n+\t       basic_string<_CharT, _Traits, _Alloc>& __str)\n+    {\n+      typedef basic_istream<_CharT, _Traits> \t\t__istream_type;\n+      typedef typename __istream_type::int_type \t__int_type;\n+      typedef typename __istream_type::__streambuf_type __streambuf_type;\n+      typedef typename __istream_type::__ctype_type \t__ctype_type;\n+      typedef basic_string<_CharT, _Traits, _Alloc> \t__string_type;\n+      typedef typename __string_type::size_type\t\t__size_type;\n+      __int_type __extracted = 0;\n+\n+      __istream_type::sentry __cerb(__in, false);\n+      if (__cerb) \n+\t{\n+\t  __str.erase();\n+\t  streamsize __w = __in.width();\n+\t  __size_type __n;\n+\t  __n = __w > 0 ? static_cast<__size_type>(__w) : __str.max_size();\n+\n+\t  __streambuf_type* __sb = __in.rdbuf();\n+\t  const __ctype_type* __ctype = __in._M_get_fctype_ios();\n+\t  __int_type __c = __sb->sbumpc();\n+\t  const __int_type __eof = _Traits::eof();\n+\t  bool __testsp = __ctype->is(ctype_base::space, __c);\n+\t  bool __testeof =  __c == __eof;\n+\n+\t  while (__extracted <= __n && !__testeof && !__testsp)\n+\t    {\n+\t      __str += _Traits::to_char_type(__c);\n+\t      ++__extracted;\n+\t      __c = __sb->sbumpc();\n+\t      __testeof = __c == __eof;\n+\t      __testsp = __ctype->is(ctype_base::space, __c);\n+\t    }\n+\t  if (!__testeof)\n+\t    __sb->sputbackc(__c);\n+\t  else\n+\t    __in.setstate(ios_base::eofbit);\n+\t  __in.width(0);\n+\t}\n+#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n+// 2000-02-01 Number to be determined\n+      if (!__extracted)\n+\t__in.setstate (ios_base::failbit);\n+#endif\n+      return __in;\n+    }\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    basic_istream<_CharT, _Traits>&\n+    getline(basic_istream<_CharT, _Traits>& __in,\n+\t    basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)\n+    {\n+      typedef basic_istream<_CharT, _Traits> \t\t__istream_type;\n+      typedef typename __istream_type::int_type \t__int_type;\n+      typedef typename __istream_type::__streambuf_type __streambuf_type;\n+      typedef typename __istream_type::__ctype_type \t__ctype_type;\n+      typedef basic_string<_CharT, _Traits, _Alloc> \t__string_type;\n+      typedef typename __string_type::size_type\t\t__size_type;\n+\n+      __size_type __extracted = 0;\n+      bool __testdelim = false;\n+      __istream_type::sentry __cerb(__in, true);\n+      if (__cerb) \n+\t{\n+\t  __str.erase();\n+\t  __size_type __n = __str.max_size();\n+\n+\t  __int_type __idelim = _Traits::to_int_type(__delim);\n+\t  __streambuf_type* __sb = __in.rdbuf();\n+\t  __int_type __c = __sb->sbumpc();\n+\t  const __int_type __eof = _Traits::eof();\n+\t  __testdelim = __c ==  __idelim;\n+\t  bool __testeof =  __c == __eof;\n+\n+\t  while (__extracted <= __n && !__testeof && !__testdelim)\n+\t    {\n+\t      __str += _Traits::to_char_type(__c);\n+\t      ++__extracted;\n+\t      __c = __sb->sbumpc();\n+\t      __testeof = __c == __eof;\n+\t      __testdelim = __c == __idelim;\n+\t    }\n+\t  if (__testeof)\n+\t    __in.setstate(ios_base::eofbit);\n+\t}\n+      if (!__extracted && !__testdelim)\n+\t__in.setstate(ios_base::failbit);\n+      return __in;\n+    }\n+\n+  template<class _CharT, class _Traits, class _Alloc>\n+    inline basic_istream<_CharT,_Traits>&\n+    getline(basic_istream<_CharT, _Traits>& __in, \n+\t    basic_string<_CharT,_Traits,_Alloc>& __str)\n+    { return getline(__in, __str, __in.widen('\\n')); }\n+\n+} // namespace std\n+\n+// Local Variables:\n+// mode:C++\n+// End:\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+"}, {"sha": "4538e210a47856b131e7a210b208f8b7544955df", "filename": "libstdc++-v3/bits/limits_generic.h", "status": "added", "additions": 786, "deletions": 0, "changes": 786, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Flimits_generic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Flimits_generic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Flimits_generic.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,786 @@\n+// The template and inlines for the -*- C++ -*- numeric_limits classes.\n+\n+// Copyright (C) 2000 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// Note: this is not a conforming implementation.\n+// Written by Gabriel Dos Reis <Gabriel.Dos-Reis@cmla.ens-cachan.fr>\n+\n+//\n+// ISO 14882:1998\n+// 18.2.1\n+//\n+\n+#ifndef _CPP_NUMERIC_LIMITS\n+#define _CPP_NUMERIC_LIMITS 1\n+\n+#include <bits/c++config.h>\n+#include <bits/std_cfloat.h>\n+#include <bits/std_climits.h>\n+#if defined( _GLIBCPP_USE_WCHAR_T) && defined(_GLIBCPP_HAS_WCHAR_MIN_MAX)\n+#include <bits/std_cwchar.h>\n+#endif\n+\n+namespace std {\n+\n+    enum float_round_style {\n+        round_indeterminate       = -1,\n+        round_toward_zero         = 0,\n+        round_to_nearest          = 1,\n+        round_toward_infinity     = 2,\n+        round_toward_neg_infinity = 3\n+    };\n+\n+    enum float_denorm_style {\n+        denorm_indeterminate = -1,\n+        denorm_absent        = 0,\n+        denorm_present       = 1\n+    };\n+\n+    template<typename _T> struct numeric_limits {\n+        static const bool is_specialized = false;\n+\n+        static _T min() throw() { return static_cast<_T>(0); }\n+        static _T max() throw() { return static_cast<_T>(0); }\n+\n+        static const int digits = 0;\n+        static const int digits10 = 0;\n+        static const bool is_signed = false;\n+        static const bool is_integer = false;\n+        static const bool is_exact = false;\n+        static const int radix = 0;\n+\n+        static _T epsilon() throw() { return static_cast<_T>(0); }\n+        static _T round_error() throw() { return static_cast<_T>(0); }\n+\n+        static const int min_exponent = 0;\n+        static const int min_exponent10 = 0;\n+        static const int max_exponent = 0;\n+        static const int max_exponent10 = 0;\n+\n+        static const bool has_infinity = false;\n+        static const bool has_quiet_NaN = false;\n+        static const bool has_signaling_NaN = false;\n+        static const float_denorm_style has_denorm = denorm_absent;\n+        static const bool has_denorm_loss = false;\n+\n+        static _T infinity() throw()  { return static_cast<_T>(0); }\n+        static _T quiet_NaN() throw() { return static_cast<_T>(0); }\n+        static _T signaling_NaN() throw() { return static_cast<_T>(0); }\n+        static _T denorm_min() throw() { return static_cast<_T>(0); }\n+\n+        static const bool is_iec559 = false;\n+        static const bool is_bounded = false;\n+        static const bool is_modulo = false;\n+\n+        static const bool traps = false;\n+        static const bool tinyness_before = false;\n+        static const float_round_style round_style = round_toward_zero;\n+    };\n+\n+    template<typename _T> _T __limits_infinity();\n+    template<typename _T> _T __limits_quiet_NaN();\n+    template<typename _T> _T __limits_signaling_NaN();\n+    template<typename _T> _T __limits_denorm_min();\n+\n+    template<> struct numeric_limits<bool> {\n+        static const bool is_specialized = true;\n+\n+        static bool min() throw()\n+        { return false; }\n+        static bool max() throw()\n+        { return true; }\n+\n+        static const int digits = 8;\n+        static const int digits10 = 2;\n+        static const bool is_signed = false;\n+        static const bool is_integer = true;\n+        static const bool is_exact = true;\n+        static const int radix = 2;\n+        static bool epsilon() throw()\n+        { return 0; }\n+        static bool round_error() throw()\n+        { return 0; }\n+\n+        static const int min_exponent = 0;\n+        static const int min_exponent10 = 0;\n+        static const int max_exponent = 0;\n+        static const int max_exponent10 = 0;\n+\n+        static const bool has_infinity = false;\n+        static const bool has_quiet_NaN = false;\n+        static const bool has_signaling_NaN = false;\n+        static const float_denorm_style has_denorm = denorm_absent;\n+        static const bool has_denorm_loss = false;\n+\n+        static bool infinity() throw()\n+        { return static_cast<bool>(0); }\n+        static bool quiet_NaN() throw()\n+        { return static_cast<bool>(0); }\n+        static bool signaling_NaN() throw()\n+        { return static_cast<bool>(0); }\n+        static bool denorm_min() throw()\n+        { return static_cast<bool>(0); }\n+\n+        static const bool is_iec559 = true;\n+        static const bool is_bounded = true;\n+        static const bool is_modulo = true;\n+\n+        static const bool traps = false;\n+        static const bool tinyness_before = false;\n+        static const float_round_style round_style = round_toward_zero;\n+    };\n+\n+    template<> struct numeric_limits<char> {\n+        static const bool is_specialized = true;\n+\n+        static char min() throw()\n+        { return CHAR_MIN; }\n+        static char max() throw()\n+        { return CHAR_MAX; }\n+\n+        static const int digits = 7;\n+        static const int digits10 = 2;\n+        static const bool is_signed = true;\n+        static const bool is_integer = true;\n+        static const bool is_exact = true;\n+        static const int radix = 2;\n+        static char epsilon() throw()\n+        { return 0; }\n+        static char round_error() throw()\n+        { return 0; }\n+\n+        static const int min_exponent = 0;\n+        static const int min_exponent10 = 0;\n+        static const int max_exponent = 0;\n+        static const int max_exponent10 = 0;\n+\n+        static const bool has_infinity = false;\n+        static const bool has_quiet_NaN = false;\n+        static const bool has_signaling_NaN = false;\n+        static const float_denorm_style has_denorm = denorm_absent;\n+        static const bool has_denorm_loss = false;\n+\n+        static char infinity() throw()\n+        { return static_cast<char>(0); }\n+        static char quiet_NaN() throw()\n+        { return static_cast<char>(0); }\n+        static char signaling_NaN() throw()\n+        { return static_cast<char>(0); }\n+        static char denorm_min() throw()\n+        { return static_cast<char>(0); }\n+\n+        static const bool is_iec559 = false;\n+        static const bool is_bounded = true;\n+        static const bool is_modulo = false;\n+\n+        static const bool traps = false;\n+        static const bool tinyness_before = false;\n+        static const float_round_style round_style = round_toward_zero;\n+    };\n+\n+    template<> struct numeric_limits<signed char> {\n+        static const bool is_specialized = true;\n+\n+        static signed char min() throw()\n+        { return SCHAR_MIN; }\n+        static signed char max() throw()\n+        { return SCHAR_MAX; }\n+\n+        static const int digits = 7;\n+        static const int digits10 = 2;\n+        static const bool is_signed = true;\n+        static const bool is_integer = true;\n+        static const bool is_exact = true;\n+        static const int radix = 2;\n+        static signed char epsilon() throw()\n+        { return 0; }\n+        static signed char round_error() throw()\n+        { return 0; }\n+\n+        static const int min_exponent = 0;\n+        static const int min_exponent10 = 0;\n+        static const int max_exponent = 0;\n+        static const int max_exponent10 = 0;\n+\n+        static const bool has_infinity = false;\n+        static const bool has_quiet_NaN = false;\n+        static const bool has_signaling_NaN = false;\n+        static const float_denorm_style has_denorm = denorm_absent;\n+        static const bool has_denorm_loss = false;\n+\n+        static signed char infinity() throw()\n+        { return static_cast<signed char>(0); }\n+        static signed char quiet_NaN() throw()\n+        { return static_cast<signed char>(0); }\n+        static signed char signaling_NaN() throw()\n+        { return static_cast<signed char>(0); }\n+        static signed char denorm_min() throw()\n+        { return static_cast<signed char>(0); }\n+\n+        static const bool is_iec559 = false;\n+        static const bool is_bounded = true;\n+        static const bool is_modulo = false;\n+\n+        static const bool traps = false;\n+        static const bool tinyness_before = false;\n+        static const float_round_style round_style = round_toward_zero;\n+    };\n+\n+    template<> struct numeric_limits<unsigned char> {\n+        static const bool is_specialized = true;\n+\n+        static unsigned char min() throw()\n+        { return 0; }\n+        static unsigned char max() throw()\n+        { return UCHAR_MAX; }\n+\n+        static const int digits = 8;\n+        static const int digits10 = 2;\n+        static const bool is_signed = false;\n+        static const bool is_integer = true;\n+        static const bool is_exact = true;\n+        static const int radix = 2;\n+        static unsigned char epsilon() throw()\n+        { return 0; }\n+        static unsigned char round_error() throw()\n+        { return 0; }\n+\n+        static const int min_exponent = 0;\n+        static const int min_exponent10 = 0;\n+        static const int max_exponent = 0;\n+        static const int max_exponent10 = 0;\n+\n+        static const bool has_infinity = false;\n+        static const bool has_quiet_NaN = false;\n+        static const bool has_signaling_NaN = false;\n+        static const float_denorm_style has_denorm = denorm_absent;\n+        static const bool has_denorm_loss = false;\n+\n+        static unsigned char infinity() throw()\n+        { return static_cast<unsigned char>(0); }\n+        static unsigned char quiet_NaN() throw()\n+        { return static_cast<unsigned char>(0); }\n+        static unsigned char signaling_NaN() throw()\n+        { return static_cast<unsigned char>(0); }\n+        static unsigned char denorm_min() throw()\n+        { return static_cast<unsigned char>(0); }\n+\n+        static const bool is_iec559 = false;\n+        static const bool is_bounded = true;\n+        static const bool is_modulo = true;\n+\n+        static const bool traps = true;\n+        static const bool tinyness_before = false;\n+        static const float_round_style round_style = round_toward_zero;\n+    };\n+\n+#if defined( _GLIBCPP_USE_WCHAR_T) && defined(_GLIBCPP_HAS_WCHAR_MIN_MAX)\n+    template<> struct numeric_limits<wchar_t> {\n+        static const bool is_specialized = true;\n+\n+        static wchar_t min() throw()\n+        { return WCHART_MIN; }\n+        static wchar_t max() throw()\n+        { return WCHART_MAX; }\n+\n+        static const int digits = 31;\n+        static const int digits10 = 9;\n+        static const bool is_signed = true;\n+        static const bool is_integer = true;\n+        static const bool is_exact = true;\n+        static const int radix = 2;\n+        static wchar_t epsilon() throw()\n+        { return 0; }\n+        static wchar_t round_error() throw()\n+        { return 0; }\n+\n+        static const int min_exponent = 0;\n+        static const int min_exponent10 = 0;\n+        static const int max_exponent = 0;\n+        static const int max_exponent10 = 0;\n+\n+        static const bool has_infinity = false;\n+        static const bool has_quiet_NaN = false;\n+        static const bool has_signaling_NaN = false;\n+        static const float_denorm_style has_denorm = denorm_absent;\n+        static const bool has_denorm_loss = false;\n+\n+        static wchar_t infinity() throw()\n+        { return static_cast<wchar_t>(0); }\n+        static wchar_t quiet_NaN() throw()\n+        { return static_cast<wchar_t>(0); }\n+        static wchar_t signaling_NaN() throw()\n+        { return static_cast<wchar_t>(0); }\n+        static wchar_t denorm_min() throw()\n+        { return static_cast<wchar_t>(0); }\n+\n+        static const bool is_iec559 = false;\n+        static const bool is_bounded = true;\n+        static const bool is_modulo = false;\n+\n+        static const bool traps = false;\n+        static const bool tinyness_before = false;\n+        static const float_round_style round_style = round_toward_zero;\n+    };\n+#endif\n+\n+    template<> struct numeric_limits<short> {\n+        static const bool is_specialized = true;\n+\n+        static short min() throw()\n+        { return SHRT_MIN; }\n+        static short max() throw()\n+        { return SHRT_MAX; }\n+\n+        static const int digits = 15;\n+        static const int digits10 = 4;\n+        static const bool is_signed = true;\n+        static const bool is_integer = true;\n+        static const bool is_exact = true;\n+        static const int radix = 2;\n+        static short epsilon() throw()\n+        { return 0; }\n+        static short round_error() throw()\n+        { return 0; }\n+\n+        static const int min_exponent = 0;\n+        static const int min_exponent10 = 0;\n+        static const int max_exponent = 0;\n+        static const int max_exponent10 = 0;\n+\n+        static const bool has_infinity = false;\n+        static const bool has_quiet_NaN = false;\n+        static const bool has_signaling_NaN = false;\n+        static const float_denorm_style has_denorm = denorm_absent;\n+        static const bool has_denorm_loss = false;\n+\n+        static short infinity() throw()\n+        { return static_cast<short>(0); }\n+        static short quiet_NaN() throw()\n+        { return static_cast<short>(0); }\n+        static short signaling_NaN() throw()\n+        { return static_cast<short>(0); }\n+        static short denorm_min() throw()\n+        { return static_cast<short>(0); }\n+\n+        static const bool is_iec559 = false;\n+        static const bool is_bounded = true;\n+        static const bool is_modulo = false;\n+\n+        static const bool traps = false;\n+        static const bool tinyness_before = false;\n+        static const float_round_style round_style = round_toward_zero;\n+    };\n+\n+    template<> struct numeric_limits<unsigned short> {\n+        static const bool is_specialized = true;\n+\n+        static unsigned short min() throw()\n+        { return 0; }\n+        static unsigned short max() throw()\n+        { return USHRT_MAX; }\n+\n+        static const int digits = 16;\n+        static const int digits10 = 4;\n+        static const bool is_signed = false;\n+        static const bool is_integer = true;\n+        static const bool is_exact = true;\n+        static const int radix = 2;\n+        static unsigned short epsilon() throw()\n+        { return 0; }\n+        static unsigned short round_error() throw()\n+        { return 0; }\n+\n+        static const int min_exponent = 0;\n+        static const int min_exponent10 = 0;\n+        static const int max_exponent = 0;\n+        static const int max_exponent10 = 0;\n+\n+        static const bool has_infinity = false;\n+        static const bool has_quiet_NaN = false;\n+        static const bool has_signaling_NaN = false;\n+        static const float_denorm_style has_denorm = denorm_absent;\n+        static const bool has_denorm_loss = false;\n+\n+        static unsigned short infinity() throw()\n+        { return static_cast<unsigned short>(0); }\n+        static unsigned short quiet_NaN() throw()\n+        { return static_cast<unsigned short>(0); }\n+        static unsigned short signaling_NaN() throw()\n+        { return static_cast<unsigned short>(0); }\n+        static unsigned short denorm_min() throw()\n+        { return static_cast<unsigned short>(0); }\n+\n+        static const bool is_iec559 = false;\n+        static const bool is_bounded = true;\n+        static const bool is_modulo = true;\n+\n+        static const bool traps = true;\n+        static const bool tinyness_before = false;\n+        static const float_round_style round_style = round_toward_zero;\n+    };\n+\n+    template<> struct numeric_limits<int> {\n+        static const bool is_specialized = true;\n+\n+        static int min() throw()\n+        { return INT_MIN; }\n+        static int max() throw()\n+        { return INT_MAX; }\n+\n+        static const int digits = 31;\n+        static const int digits10 = 9;\n+        static const bool is_signed = true;\n+        static const bool is_integer = true;\n+        static const bool is_exact = true;\n+        static const int radix = 2;\n+        static int epsilon() throw()\n+        { return 0; }\n+        static int round_error() throw()\n+        { return 0; }\n+\n+        static const int min_exponent = 0;\n+        static const int min_exponent10 = 0;\n+        static const int max_exponent = 0;\n+        static const int max_exponent10 = 0;\n+\n+        static const bool has_infinity = false;\n+        static const bool has_quiet_NaN = false;\n+        static const bool has_signaling_NaN = false;\n+        static const float_denorm_style has_denorm = denorm_absent;\n+        static const bool has_denorm_loss = false;\n+\n+        static int infinity() throw()\n+        { return static_cast<int>(0); }\n+        static int quiet_NaN() throw()\n+        { return static_cast<int>(0); }\n+        static int signaling_NaN() throw()\n+        { return static_cast<int>(0); }\n+        static int denorm_min() throw()\n+        { return static_cast<int>(0); }\n+\n+        static const bool is_iec559 = true;\n+        static const bool is_bounded = true;\n+        static const bool is_modulo = false;\n+\n+        static const bool traps = false;\n+        static const bool tinyness_before = false;\n+        static const float_round_style round_style = round_toward_zero;\n+    };\n+\n+    template<> struct numeric_limits<unsigned int> {\n+        static const bool is_specialized = true;\n+\n+        static unsigned int min() throw()\n+        { return 0; }\n+        static unsigned int max() throw()\n+        { return UINT_MAX; }\n+\n+        static const int digits = 32;\n+        static const int digits10 = 9;\n+        static const bool is_signed = false;\n+        static const bool is_integer = true;\n+        static const bool is_exact = true;\n+        static const int radix = 2;\n+        static unsigned int epsilon() throw()\n+        { return 0; }\n+        static unsigned int round_error() throw()\n+        { return 0; }\n+\n+        static const int min_exponent = 0;\n+        static const int min_exponent10 = 0;\n+        static const int max_exponent = 0;\n+        static const int max_exponent10 = 0;\n+\n+        static const bool has_infinity = false;\n+        static const bool has_quiet_NaN = false;\n+        static const bool has_signaling_NaN = false;\n+        static const float_denorm_style has_denorm = denorm_absent;\n+        static const bool has_denorm_loss = false;\n+\n+        static unsigned int infinity() throw()\n+        { return static_cast<unsigned int>(0); }\n+        static unsigned int quiet_NaN() throw()\n+        { return static_cast<unsigned int>(0); }\n+        static unsigned int signaling_NaN() throw()\n+        { return static_cast<unsigned int>(0); }\n+        static unsigned int denorm_min() throw()\n+        { return static_cast<unsigned int>(0); }\n+\n+        static const bool is_iec559 = true;\n+        static const bool is_bounded = true;\n+        static const bool is_modulo = true;\n+\n+        static const bool traps = true;\n+        static const bool tinyness_before = false;\n+        static const float_round_style round_style = round_toward_zero;\n+    };\n+\n+    template<> struct numeric_limits<long> {\n+        static const bool is_specialized = true;\n+\n+        static long min() throw()\n+        { return LONG_MIN; }\n+        static long max() throw()\n+        { return LONG_MAX; }\n+\n+        static const int digits = 31;\n+        static const int digits10 = 9;\n+        static const bool is_signed = true;\n+        static const bool is_integer = true;\n+        static const bool is_exact = true;\n+        static const int radix = 2;\n+        static long epsilon() throw()\n+        { return 0; }\n+        static long round_error() throw()\n+        { return 0; }\n+\n+        static const int min_exponent = 0;\n+        static const int min_exponent10 = 0;\n+        static const int max_exponent = 0;\n+        static const int max_exponent10 = 0;\n+\n+        static const bool has_infinity = false;\n+        static const bool has_quiet_NaN = false;\n+        static const bool has_signaling_NaN = false;\n+        static const float_denorm_style has_denorm = denorm_absent;\n+        static const bool has_denorm_loss = false;\n+\n+        static long infinity() throw()\n+        { return static_cast<long>(0); }\n+        static long quiet_NaN() throw()\n+        { return static_cast<long>(0); }\n+        static long signaling_NaN() throw()\n+        { return static_cast<long>(0); }\n+        static long denorm_min() throw()\n+        { return static_cast<long>(0); }\n+\n+        static const bool is_iec559 = true;\n+        static const bool is_bounded = true;\n+        static const bool is_modulo = false;\n+\n+        static const bool traps = false;\n+        static const bool tinyness_before = false;\n+        static const float_round_style round_style = round_toward_zero;\n+    };\n+\n+    template<> struct numeric_limits<unsigned long> {\n+        static const bool is_specialized = true;\n+\n+        static unsigned long min() throw()\n+        { return 0; }\n+        static unsigned long max() throw()\n+        { return ULONG_MAX; }\n+\n+        static const int digits = 32;\n+        static const int digits10 = 9;\n+        static const bool is_signed = false;\n+        static const bool is_integer = true;\n+        static const bool is_exact = true;\n+        static const int radix = 2;\n+        static unsigned long epsilon() throw()\n+        { return 0; }\n+        static unsigned long round_error() throw()\n+        { return 0; }\n+\n+        static const int min_exponent = 0;\n+        static const int min_exponent10 = 0;\n+        static const int max_exponent = 0;\n+        static const int max_exponent10 = 0;\n+\n+        static const bool has_infinity = false;\n+        static const bool has_quiet_NaN = false;\n+        static const bool has_signaling_NaN = false;\n+        static const float_denorm_style has_denorm = denorm_absent;\n+        static const bool has_denorm_loss = false;\n+\n+        static unsigned long infinity() throw()\n+        { return static_cast<unsigned long>(0); }\n+        static unsigned long quiet_NaN() throw()\n+        { return static_cast<unsigned long>(0); }\n+        static unsigned long signaling_NaN() throw()\n+        { return static_cast<unsigned long>(0); }\n+        static unsigned long denorm_min() throw()\n+        { return static_cast<unsigned long>(0); }\n+\n+        static const bool is_iec559 = true;\n+        static const bool is_bounded = true;\n+        static const bool is_modulo = true;\n+\n+        static const bool traps = true;\n+        static const bool tinyness_before = false;\n+        static const float_round_style round_style = round_toward_zero;\n+    };\n+\n+    template<> struct numeric_limits<float> {\n+        static const bool is_specialized = true;\n+\n+        static float min() throw()\n+        { return FLT_MIN; }\n+        static float max() throw()\n+        { return FLT_MAX; }\n+\n+        static const int digits = FLT_MANT_DIG;\n+        static const int digits10 = FLT_DIG;\n+        static const bool is_signed = true;\n+        static const bool is_integer = false;\n+        static const bool is_exact = false;\n+        static const int radix = FLT_RADIX;\n+        static float epsilon() throw()\n+        { return FLT_EPSILON; }\n+        static float round_error() throw()\n+        { return FLT_ROUNDS; }\n+\n+        static const int min_exponent = FLT_MIN_EXP;\n+        static const int min_exponent10 = FLT_MIN_10_EXP;\n+        static const int max_exponent = FLT_MAX_EXP;\n+        static const int max_exponent10 = FLT_MAX_10_EXP;\n+\n+        static const bool has_infinity = false;\n+        static const bool has_quiet_NaN = false;\n+        static const bool has_signaling_NaN = false;\n+        static const float_denorm_style has_denorm = denorm_absent;\n+        static const bool has_denorm_loss = false;\n+\n+        static float infinity() throw()\n+        { return static_cast<float>(0); }\n+        static float quiet_NaN() throw()\n+        { return static_cast<float>(0); }\n+        static float signaling_NaN() throw()\n+        { return static_cast<float>(0); }\n+        static float denorm_min() throw()\n+        { return static_cast<float>(0); }\n+\n+        static const bool is_iec559 = false;\n+        static const bool is_bounded = true;\n+        static const bool is_modulo = false;\n+\n+        static const bool traps = false;\n+        static const bool tinyness_before = false;\n+        static const float_round_style round_style = round_toward_zero;\n+    };\n+\n+    template<> struct numeric_limits<double> {\n+        static const bool is_specialized = true;\n+\n+        static double min() throw()\n+        { return DBL_MIN; }\n+        static double max() throw()\n+        { return DBL_MAX; }\n+\n+        static const int digits = DBL_MANT_DIG;\n+        static const int digits10 = DBL_DIG;\n+        static const bool is_signed = true;\n+        static const bool is_integer = false;\n+        static const bool is_exact = false;\n+        static const int radix = 2;\n+        static double epsilon() throw()\n+        { return DBL_EPSILON; }\n+        static double round_error() throw()\n+        { return 1.0; }\n+\n+        static const int min_exponent = DBL_MIN_EXP;\n+        static const int min_exponent10 = DBL_MIN_10_EXP;\n+        static const int max_exponent = DBL_MAX_EXP;\n+        static const int max_exponent10 = DBL_MAX_10_EXP;\n+\n+        static const bool has_infinity = false;\n+        static const bool has_quiet_NaN = false;\n+        static const bool has_signaling_NaN = false;\n+        static const float_denorm_style has_denorm = denorm_absent;\n+        static const bool has_denorm_loss = false;\n+\n+        static double infinity() throw()\n+        { return static_cast<double>(0); }\n+        static double quiet_NaN() throw()\n+        { return static_cast<double>(0); }\n+        static double signaling_NaN() throw()\n+        { return static_cast<double>(0); }\n+        static double denorm_min() throw()\n+        { return static_cast<double>(0); }\n+\n+        static const bool is_iec559 = false;\n+        static const bool is_bounded = true;\n+        static const bool is_modulo = false;\n+\n+        static const bool traps = false;\n+        static const bool tinyness_before = false;\n+        static const float_round_style round_style = round_toward_zero;\n+    };\n+\n+    template<> struct numeric_limits<long double> {\n+        static const bool is_specialized = true;\n+\n+        static double min() throw()\n+        { return LDBL_MIN; }\n+        static double max() throw()\n+        { return LDBL_MAX; }\n+\n+        static const int digits = LDBL_MANT_DIG;\n+        static const int digits10 = LDBL_DIG;\n+        static const bool is_signed = true;\n+        static const bool is_integer = false;\n+        static const bool is_exact = false;\n+        static const int radix = 2;\n+        static double epsilon() throw()\n+        { return LDBL_EPSILON; }\n+        static double round_error() throw()\n+        { return 1.0L; }\n+\n+        static const int min_exponent = LDBL_MIN_EXP;\n+        static const int min_exponent10 = LDBL_MIN_10_EXP;\n+        static const int max_exponent = LDBL_MAX_EXP;\n+        static const int max_exponent10 = LDBL_MAX_10_EXP;\n+\n+        static const bool has_infinity = false;\n+        static const bool has_quiet_NaN = false;\n+        static const bool has_signaling_NaN = false;\n+        static const float_denorm_style has_denorm = denorm_absent;\n+        static const bool has_denorm_loss = false;\n+\n+        static double infinity() throw()\n+        { return static_cast<double>(0); }\n+        static double quiet_NaN() throw()\n+        { return static_cast<double>(0); }\n+        static double signaling_NaN() throw()\n+        { return static_cast<double>(0); }\n+        static double denorm_min() throw()\n+        { return static_cast<double>(0); }\n+\n+        static const bool is_iec559 = false;\n+        static const bool is_bounded = true;\n+        static const bool is_modulo = false;\n+\n+        static const bool traps = false;\n+        static const bool tinyness_before = false;\n+        static const float_round_style round_style = round_toward_zero;\n+    };\n+\n+} // namespace std\n+\n+#endif // _CPP_NUMERIC_LIMITS"}, {"sha": "ec40d0f31ca920f0cdc2b2b815b99498a97b4bca", "filename": "libstdc++-v3/bits/locale_facets.h", "status": "added", "additions": 1935, "deletions": 0, "changes": 1935, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Flocale_facets.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Flocale_facets.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Flocale_facets.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,1935 @@\n+// Locale support -*- C++ -*-\n+\n+// Copyright (C) 1997-2000 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 22.1  Locales\n+//\n+\n+// Warning: this file is not meant for user inclusion.  Use <locale>.\n+\n+#ifndef _CPP_BITS_LOCFACETS_H\n+#define _CPP_BITS_LOCFACETS_H\t1\n+\n+#include <bits/std_ctime.h>\t// For struct tm\n+#include <bits/std_typeinfo.h> \t// For bad_cast, which shouldn't be here.\n+#include <bits/std_ios.h>\t// For ios_base\n+\n+namespace std\n+{\n+\n+  // XXX This function is to be specialized for the \"required\" facets to \n+  // be constructed lazily.   The specializations must be declared after \n+  // the definitions of the facets themselves; but they shouldn't be \n+  // inline.  Corresponding new's in locale::classic() should then be \n+  // eliminated.  Note that ctype<> should not get this treatment; \n+  // see the use_facet<> specializations below.\n+  //\n+  struct _Bad_use_facet : public bad_cast \n+  {\n+    _Bad_use_facet() throw() {}\n+\n+    _Bad_use_facet(_Bad_use_facet const&  __b) throw() \n+    : bad_cast(__b) { }\n+\n+    _Bad_use_facet& \n+    operator=(_Bad_use_facet const& __b) throw() \n+    { \n+      static_cast<bad_cast*>(this)->operator=(__b); \n+      return *this; \n+    }\n+\n+    virtual char const* \n+    what() const throw();\n+\n+    virtual \n+    ~_Bad_use_facet() throw();\n+  };\n+\n+  template<typename _Facet>\n+    const _Facet& \n+    _Use_facet_failure_handler(const locale&)\n+    { throw _Bad_use_facet(); }\n+\n+  // 22.2.1  The ctype category\n+  // Include host-specific ctype enums for ctype_base.\n+  #include <bits/ctype_base.h>\n+\n+  // 22.2.1.1  Template class ctype\n+  // _Ctype_nois is the common base for ctype<char>.  It lacks \"do_is\"\n+  // and related virtuals.  These are filled in by _Ctype, below.\n+  template<typename _CharT>\n+    class _Ctype_nois : public locale::facet, public ctype_base\n+    {\n+      // Types:\n+      typedef _CharT char_type;\n+\n+    public:\n+      char_type \n+      toupper(char_type __c) const\n+      { return this->do_toupper(__c); }\n+\n+      const char_type*\n+      toupper(char_type *__low, const char_type* __high) const\n+      { return this->do_toupper(__low, __high); }\n+\n+      char_type \n+      tolower(char_type __c) const\n+      { return this->do_tolower(__c); }\n+\n+      const char_type*\n+      tolower(char_type* __low, const char_type* __high) const\n+      { return this->do_tolower(__low, __high); }\n+\n+      char_type \n+      widen(char __c) const\n+      { return this->do_widen(__c); }\n+\n+      const char*\n+      widen(const char* __low, const char* __high, char_type* __to) const\n+      { return this->do_widen(__low, __high, __to); }\n+\n+      char \n+      narrow(char_type __c, char __dfault) const\n+      { return this->do_narrow(__c, __dfault); }\n+\n+      const char_type*\n+      narrow(const char_type* __low, const char_type* __high,\n+\t      char __dfault, char *__to) const\n+      { return this->do_narrow(__low, __high, __dfault, __to); }\n+\n+    protected:\n+      explicit \n+      _Ctype_nois(size_t __refs = 0): locale::facet(__refs) { }\n+\n+      virtual \n+      ~_Ctype_nois() { }\n+      \n+      virtual char_type \n+      do_toupper(char_type) const = 0;\n+\n+      virtual const char_type*\n+      do_toupper(char_type* __low, const char_type* __high) const = 0;\n+\n+      virtual char_type \n+      do_tolower(char_type) const = 0;\n+\n+      virtual const char_type*\n+      do_tolower(char_type* __low, const char_type* __high) const = 0;\n+      \n+      virtual char_type \n+      do_widen(char) const = 0;\n+\n+      virtual const char*\n+      do_widen(const char* __low, const char* __high,\n+\t       char_type* __dest) const = 0;\n+\n+      virtual char \n+      do_narrow(char_type, char __dfault) const = 0;\n+\n+      virtual const char_type*\n+      do_narrow(const char_type* __low, const char_type* __high,\n+\t\t char __dfault, char* __dest) const = 0;\n+    };\n+\n+\n+  template<typename _CharT>\n+    class _Ctype : public _Ctype_nois<_CharT>\n+    {\n+    public:\n+\n+      // Types:\n+      typedef _CharT \t\t\t\t\tchar_type;\n+      typedef typename _Ctype_nois<_CharT>::mask \tmask;\n+\n+      bool \n+      is(mask __m, char_type __c) const\n+      { return this->do_is(__m, __c); }\n+\n+      const char_type*\n+      is(const char_type *__lo, const char_type *__hi, mask *__vec) const   \n+      { return this->do_is(__lo, __hi, __vec); }\n+\n+      const char_type*\n+      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const\n+      { return this->do_scan_is(__m, __lo, __hi); }\n+\n+      const char_type*\n+      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const\n+      { return this->do_scan_not(__m, __lo, __hi); }\n+\n+    protected:\n+      explicit \n+      _Ctype(size_t __refs = 0) : _Ctype_nois<_CharT>(__refs) { }\n+\n+      virtual \n+      ~_Ctype() { }\n+\n+      virtual bool \n+      do_is(mask __m, char_type __c) const = 0;\n+\n+      virtual const char_type*\n+      do_is(const char_type* __lo, const char_type* __hi, \n+\t    mask* __vec) const = 0;\n+\n+      virtual const char_type*\n+      do_scan_is(mask __m, const char_type* __lo, \n+\t\t const char_type* __hi) const = 0;\n+\n+      virtual const char_type*\n+      do_scan_not(mask __m, const char_type* __lo, \n+\t\t  const char_type* __hi) const = 0;\n+    };\n+\n+  template<typename _CharT>\n+    class ctype : public _Ctype<_CharT>\n+    {\n+    public:\n+      // Types:\n+      typedef _CharT \t\t\t\t\tchar_type;\n+      typedef typename ctype::mask \t\t\tmask;\n+\n+      explicit \n+      ctype(size_t __refs = 0) : _Ctype<_CharT>(__refs) { }\n+\n+      static locale::id id;\n+\n+   protected:\n+      virtual \n+      ~ctype() { }\n+\n+      virtual bool \n+      do_is(mask, char_type) const\n+      {\n+\t// XXX Need definitions for these abstract mf's.\n+      }\n+\n+      virtual const char_type*\n+      do_is(const char_type*, const char_type*, mask*) const\n+      {\n+\t// XXX Need definitions for these abstract mf's.\n+      }\n+\n+      virtual const char_type*\n+      do_scan_is(mask, const char_type*, const char_type*) const\n+      {\n+\t// XXX Need definitions for these abstract mf's.\n+      }\n+\n+      virtual const char_type*\n+      do_scan_not(mask, const char_type*, const char_type*) const\n+      {\n+\t// XXX Need definitions for these abstract mf's.\n+      }\n+\n+      virtual char_type \n+      do_toupper(char_type) const\n+      {\n+\t// XXX Need definitions for these abstract mf's.\n+      }\n+\n+      virtual const char_type*\n+      do_toupper(char_type*, const char_type*) const\n+      {\n+\t// XXX Need definitions for these abstract mf's.\n+      }\n+\n+      virtual char_type \n+      do_tolower(char_type) const\n+      {\n+\t// XXX Need definitions for these abstract mf's.\n+      }\n+\n+      virtual const char_type*\n+      do_tolower(char_type*, const char_type*) const\n+      {\n+\t// XXX Need definitions for these abstract mf's.\n+      }\n+      \n+      virtual char_type \n+      do_widen(char) const\n+      {\n+\t// XXX Need definitions for these abstract mf's.\n+      }\n+\n+      virtual const char*\n+      do_widen(const char*, const char*, char_type*) const\n+      {\n+\t// XXX Need definitions for these abstract mf's.\n+      }\n+\n+      virtual char \n+      do_narrow(char_type, char) const\n+      {\n+\t// XXX Need definitions for these abstract mf's.\n+      }\n+\n+      virtual const char_type*\n+      do_narrow(const char_type*, const char_type*, char, char*) const\n+      {\n+\t// XXX Need definitions for these abstract mf's.\n+      }\n+    };\n+\n+\n+  // 22.2.1.3  ctype specializations\n+  // NB: Can use _Ctype_nois to actually implement the is\n+  // functionality in the non-virtual (thus inline-able) member\n+  // fuctions.\n+  template<>\n+    class ctype<char> : public _Ctype_nois<char>\n+    {\n+    public:\n+      // Types:\n+      typedef char \t\t\t\t\tchar_type;\n+      typedef ctype::mask \t\t\t\tmask;\n+      typedef size_t\t\t\t\t\t__table_type;\n+\n+    private:\n+      // Data Members:\n+      bool \t\t\t_M_del;\n+      __to_type const& \t\t_M_toupper;\n+      __to_type const& \t\t_M_tolower;\n+      const mask* const& \t_M_ctable;\n+      const mask* \t\t_M_table;\n+      \n+    public:\n+      static locale::id \tid;\n+      static const __table_type table_size = 1 +static_cast<unsigned char>(-1);\n+\n+      explicit \n+      ctype(const mask* __table = 0, bool __del = false, \n+\t    size_t __refs = 0) throw();\n+\n+      inline bool \n+      is(mask __m, char __c) const throw();\n+ \n+      inline const char*\n+      is(const char* __low, const char* __high, mask* __vec) const throw();\n+ \n+      inline const char*\n+      scan_is(mask __m, const char* __low, const char* __high) const throw();\n+\n+      inline const char*\n+      scan_not(mask __m, const char* __low, const char* __high) const throw();\n+     \n+    protected:\n+      virtual \n+      ~ctype();\n+\n+      inline const mask* \n+      table() const throw()\n+      { return _M_table; }\n+\n+      inline const mask* \n+      classic_table() throw()\n+      { return _M_ctable; }\n+\n+      virtual char_type \n+      do_toupper(char_type) const;\n+\n+      virtual const char_type*\n+      do_toupper(char_type* __low, const char_type* __high) const;\n+\n+      virtual char_type \n+      do_tolower(char_type) const;\n+\n+      virtual const char_type*\n+      do_tolower(char_type* __low, const char_type* __high) const;\n+      \n+      virtual char_type \n+      do_widen(char) const;\n+\n+      virtual const char*\n+      do_widen(const char* __low, const char* __high,\n+\t       char_type* __dest) const;\n+\n+      virtual char \n+      do_narrow(char_type, char __dfault) const;\n+\n+      virtual const char_type*\n+      do_narrow(const char_type* __low, const char_type* __high,\n+\t\t char __dfault, char* __dest) const;\n+    };\n+ \n+  template<>\n+    const ctype<char>&\n+    use_facet<const ctype<char> > (const locale& __loc);\n+\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  // ctype<wchar_t> specialization\n+  template<>\n+    class ctype<wchar_t> : public _Ctype<wchar_t>\n+    {\n+    public:\n+     // Types:\n+      typedef wchar_t \t\t\t\t\tchar_type;\n+      typedef ctype::mask \t\t\t\tmask;\n+      typedef size_t\t\t\t\t\t__table_type;\n+\n+    private:\n+      __to_type const& \t\t_M_toupper;\n+      __to_type const& \t\t_M_tolower;\n+      const mask* const& \t_M_ctable;\n+      static const __table_type\t_S_table_size = ctype<char>::table_size;\n+      \n+    public:\n+      static locale::id id;\n+\n+      explicit \n+      ctype(size_t __refs = 0) throw();\n+\n+    protected:\n+      virtual \n+      ~ctype();\n+\n+      virtual bool \n+      do_is(mask __m, char_type __c) const;\n+\n+      virtual const char_type*\n+      do_is(const char_type* __lo, const char_type* __hi, \n+\t    mask* __vec) const;\n+\n+      virtual const char_type*\n+      do_scan_is(mask __m, const char_type* __lo, \n+\t\t const char_type* __hi) const;\n+\n+      virtual const char_type*\n+      do_scan_not(mask __m, const char_type* __lo, \n+\t\t  const char_type* __hi) const;\n+\n+      virtual char_type \n+      do_toupper(char_type) const;\n+\n+      virtual const char_type*\n+      do_toupper(char_type* __low, const char_type* __high) const;\n+\n+      virtual char_type \n+      do_tolower(char_type) const;\n+\n+      virtual const char_type*\n+      do_tolower(char_type* __low, const char_type* __high) const;\n+      \n+      virtual char_type \n+      do_widen(char) const;\n+\n+      virtual const char*\n+      do_widen(const char* __low, const char* __high,\n+\t       char_type* __dest) const;\n+\n+      virtual char \n+      do_narrow(char_type, char __dfault) const;\n+\n+      virtual const char_type*\n+      do_narrow(const char_type* __low, const char_type* __high,\n+\t\t char __dfault, char* __dest) const;\n+\n+    };\n+\n+  template<>\n+    const ctype<wchar_t>&\n+    use_facet< const ctype<wchar_t> > (const locale& __loc);\n+#endif //_GLIBCPP_USE_WCHAR_T\n+\n+  // Include host-specific ctype specializations.\n+  #include <bits/ctype_specializations.h>\n+\n+  // 22.2.1.2  Template class ctype_byname\n+  template<typename _CharT>\n+    class ctype_byname : public ctype<_CharT>\n+    {\n+    public:\n+      typedef _CharT \t\tchar_type;\n+\n+      explicit \n+      ctype_byname(const char*, size_t __refs = 0);\n+\n+    protected:\n+      virtual \n+      ~ctype_byname() { }\n+    };\n+\n+  //  22.2.1.4  Class ctype_byname specializations\n+  template<>\n+    ctype_byname<char>::ctype_byname(const char*, size_t refs);\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  template<>\n+    ctype_byname<wchar_t>::ctype_byname(const char*, size_t refs);\n+#endif\n+\n+\n+  //  22.2.1.5  Template class codecvt\n+  class codecvt_base\n+  {\n+  public:\n+    enum result\n+    {\n+      ok,\n+      partial,\n+      error,\n+      noconv\n+    };\n+  };\n+\n+  template<typename _InternT, typename _ExternT, typename _StateT>\n+    class _Codecvt : public locale::facet, public codecvt_base\n+    {\n+    public:\n+      // Types:\n+      typedef _InternT intern_type;\n+      typedef _ExternT extern_type;\n+      typedef _StateT  state_type;\n+      \n+    protected:\n+      explicit \n+      _Codecvt (size_t __refs = 0) : locale::facet(__refs) { }\n+\n+    public:\n+      result\n+      out(state_type& __state, const intern_type* __from, \n+\t  const intern_type* __from_end, const intern_type* &__from_next,\n+\t  extern_type* __to, extern_type* __to_limit, \n+\t  extern_type*& __to_next) const\n+      { \n+\treturn do_out(__state, __from, __from_end, __from_next, __to, \n+\t\t      __to_limit, __to_next); \n+      }\n+\n+      result\n+      unshift(state_type& __state, extern_type* __to, extern_type* __to_limit,\n+\t      extern_type*& __to_next) const\n+      { return do_unshift(__state, __to,__to_limit,__to_next); }\n+\n+      result\n+      in(state_type& __state, const extern_type* __from, \n+\t const extern_type* __from_end, const extern_type*& __from_next,\n+\t intern_type* __to, intern_type* __to_limit,\n+\t intern_type*& __to_next) const\n+      { \n+\treturn do_in(__state, __from, __from_end, __from_next,\n+\t\t     __to, __to_limit, __to_next); \n+      }\n+\n+      int \n+      encoding() const throw()\n+      { return do_encoding(); }\n+\n+      bool \n+      always_noconv() const throw()\n+      { return do_always_noconv(); }\n+\n+      int\n+      length(const state_type& __state, const extern_type* __from,\n+\t     const extern_type* __end, size_t __max) const\n+      { return do_length(__state, __from, __end, __max); }\n+\n+      int \n+      max_length() const throw()\n+      { return do_max_length(); }\n+\n+    protected:\n+      virtual \n+      ~_Codecvt() { }\n+\n+      virtual result\n+      do_out(state_type& __state,\n+\t     const intern_type* __from, const intern_type* __from_end,\n+\t     const intern_type*& __from_next,\n+\t     extern_type* __to, extern_type* __to_limit,\n+\t     extern_type*& __to_next) const = 0;\n+\n+      virtual result\n+      do_unshift(state_type& __state,\n+\t\t extern_type* __to, extern_type* __to_limit,\n+\t\t extern_type*& __to_next) const = 0;\n+      \n+      virtual result\n+      do_in(state_type& __state,\n+\t    const extern_type* __from, const extern_type* __from_end,\n+\t    const extern_type*& __from_next,\n+\t    intern_type* __to, intern_type* __to_limit,\n+\t    intern_type*& __to_next) const = 0;\n+      \n+      virtual int \n+      do_encoding() const throw() = 0;\n+\n+      virtual bool \n+      do_always_noconv() const throw() = 0;\n+\n+      virtual int \n+      do_length(const state_type&, const extern_type* __from,\n+\t\tconst extern_type* __end, size_t __max) const = 0;\n+\n+      virtual int \n+      do_max_length() const throw() = 0;\n+    };\n+  \n+\n+  template<typename _InternT, typename _ExternT, typename _StateT>\n+    class codecvt : public _Codecvt<_InternT,_ExternT,_StateT>\n+    {\n+    public:      \n+      // Types:\n+      typedef _InternT intern_type;\n+      typedef _ExternT extern_type;\n+      typedef _StateT state_type;\n+\n+      // Data Members:\n+      static locale::id id;\n+\n+      explicit \n+      codecvt(size_t __refs = 0) \n+      : _Codecvt<_InternT,_ExternT,_StateT> (__refs) { }\n+\n+    protected:\n+      virtual \n+      ~codecvt() { }\n+    };\n+\n+  // codecvt<char,char,mbstate_t> specialization\n+  template<>\n+    class codecvt<char, char, mbstate_t> \n+    : public _Codecvt<char, char, mbstate_t>\n+    {\n+    public:      \n+      // Types:\n+      typedef char intern_type;\n+      typedef char extern_type;\n+      typedef mbstate_t state_type;\n+\n+      explicit codecvt (size_t __refs = 0);\n+      static locale::id id;\n+\n+    protected:\n+      virtual ~codecvt();\n+      virtual result\n+      do_out(state_type& __state, const intern_type* __from, \n+\t     const intern_type* __from_end, const intern_type*& __from_next,\n+\t     extern_type* __to, extern_type* __to_limit,\n+\t     extern_type*& __to_next) const;\n+\n+      virtual result\n+      do_unshift(state_type& __state, extern_type* __to, \n+\t\t extern_type* __to_limit, extern_type*& __to_next) const;\n+\n+      virtual result\n+      do_in(state_type& __state, const extern_type* __from, \n+\t    const extern_type* __from_end, const extern_type*& __from_next,\n+\t    intern_type* __to, intern_type* __to_limit, \n+\t    intern_type*& __to_next) const;\n+\n+      virtual int do_encoding() const throw();\n+      virtual bool do_always_noconv() const throw();\n+      virtual int do_length(const state_type&, const extern_type* __from,\n+\t\t\t    const extern_type* __end, size_t __max) const;\n+      virtual int do_max_length() const throw();\n+  };\n+\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  template<>\n+    class codecvt<wchar_t,char,mbstate_t> \n+    : public _Codecvt<wchar_t,char,mbstate_t>\n+    {\n+    public:\n+      // Types:\n+      typedef wchar_t intern_type;\n+      typedef char extern_type;\n+      typedef mbstate_t state_type;\n+\n+      explicit codecvt(size_t __refs = 0);\n+      static locale::id id;\n+\n+    protected:\n+      virtual ~codecvt();\n+      virtual result\n+      do_out(state_type& __state, const intern_type* __from, \n+\t     const intern_type* __from_end, const intern_type*& __from_next,\n+\t     extern_type* __to, extern_type* __to_limit,\n+\t     extern_type*& __to_next) const;\n+\n+      virtual result\n+      do_unshift(state_type& __state,\n+\t\t extern_type* __to, extern_type* __to_limit,\n+\t\t extern_type*& __to_next) const;\n+\n+      virtual result\n+      do_in(state_type& __state,\n+\t     const extern_type* __from, const extern_type* __from_end,\n+\t     const extern_type*& __from_next,\n+\t     intern_type* __to, intern_type* __to_limit,\n+\t     intern_type*& __to_next) const;\n+\n+      virtual int do_encoding() const throw();\n+      virtual bool do_always_noconv() const throw();\n+      virtual int do_length(const state_type&, const extern_type* __from,\n+\t\t\t    const extern_type* __end, size_t __max) const;\n+      virtual int do_max_length() const throw();\n+    };\n+#endif //_GLIBCPP_USE_WCHAR_T\n+\n+\n+  // 22.2.1.6  Template class codecvt_byname\n+  template<typename _InternT, typename _ExternT, typename _StateT>\n+    class codecvt_byname : public codecvt<_InternT,_ExternT,_StateT>\n+    {\n+    public:\n+      explicit \n+      codecvt_byname(const char*, size_t __refs = 0) \n+      : codecvt<_InternT,_ExternT,_StateT> (__refs) { }\n+    protected:\n+      virtual \n+      ~codecvt_byname() { }\n+    };\n+\n+  template<>\n+    class codecvt_byname<char,char,mbstate_t>\n+    : public codecvt<char,char,mbstate_t>\n+    {\n+    public:\n+      explicit \n+      codecvt_byname(const char*, size_t __refs = 0);\n+\n+    protected:\n+      virtual \n+      ~codecvt_byname();\n+    };\n+  \n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  template<>\n+    class codecvt_byname<wchar_t,char,mbstate_t>\n+      : public codecvt<wchar_t,char,mbstate_t>\n+    {\n+    public:\n+      explicit \n+      codecvt_byname(const char*, size_t __refs = 0);\n+\n+    protected:\n+      virtual \n+      ~codecvt_byname();\n+    };\n+#endif\n+\n+  template<typename _CharT, typename _InIter>\n+    class _Numeric_get;  // forward\n+\n+  // _Format_cache holds the information extracted from the numpunct<>\n+  // and moneypunct<> facets in a form optimized for parsing and\n+  // formatting.  It is stored via a void* pointer in the pword()\n+  // array of an iosbase object passed to the _get and _put facets.\n+  // NB: contains no user-serviceable parts.\n+  template<typename _CharT>\n+    class _Format_cache\n+    {\n+    public: \n+      // Types:\n+      typedef _CharT \t\t\tchar_type;\n+      typedef char_traits<_CharT> \ttraits_type;\n+      typedef basic_string<_CharT>\tstring_type;\n+      typedef string_type::size_type\tsize_type;\n+\n+      // Forward decls and Friends:\n+      friend class locale;\n+      template<typename _Char, typename _InIter>\n+        friend class _Numeric_get;\n+      friend class num_get<_CharT>;\n+      friend class num_put<_CharT>;\n+      friend class time_get<_CharT>;\n+      friend class money_get<_CharT>;\n+      friend class time_put<_CharT>;\n+      friend class money_put<_CharT>;\n+\n+      // Data Members:\n+\n+      // ios_base::pword() reserved cell\n+      static int \t\t_S_pword_ix; \n+\n+      // True iff data members are consistent with the current locale,\n+      // ie imbue sets this to false.\n+      bool \t\t\t_M_valid;\n+\n+      // A list of valid numeric literals: for the standard \"C\" locale,\n+      // this would usually be: \"-+xX0123456789abcdef0123456789ABCDEF\"\n+      static const char _S_literals[];\n+\n+      // NB: Code depends on the order of definitions of the names\n+      // these are indices into _S_literals, above.\n+      // This string is formatted for putting, not getting. (output, not input)\n+      enum \n+      {  \n+\t_S_minus, \n+\t_S_plus, \n+\t_S_ecks, \n+\t_S_Ecks, \n+\t_S_digits,\n+\t_S_digits_end = _S_digits + 16,\n+\t_S_udigits = _S_digits_end,  \n+\t_S_udigits_end = _S_udigits + 16,\n+\t_S_ee = _S_digits + 14, // For scientific notation, 'E'\n+\t_S_Ee = _S_udigits + 14 // For scientific notation, 'e'\n+      };\n+\n+      // The sign used to separate decimal values: for standard US\n+      // locales, this would usually be: \".\"\n+      // Abstracted from numpunct::decimal_point().\n+      char_type \t\t_M_decimal_point;\n+\n+      // The sign used to separate groups of digits into smaller\n+      // strings that the eye can parse with less difficulty: for\n+      // standard US locales, this would usually be: \",\"\n+      // Abstracted from numpunct::thousands_sep().\n+      char_type\t\t\t_M_thousands_sep;\n+\n+      // However the US's \"false\" and \"true\" are translated.\n+      // From numpunct::truename() and numpunct::falsename(), respectively.\n+      string_type \t\t_M_truename;\n+      string_type \t\t_M_falsename;\n+\n+      // If we are checking groupings. This should be equivalent to \n+      // numpunct::groupings().size() != 0\n+      bool \t\t\t_M_use_grouping;\n+\n+      // If we are using numpunct's groupings, this is the current\n+      // grouping string in effect (from numpunct::grouping()).\n+      string \t\t\t_M_grouping;\n+\n+      _Format_cache();\n+\n+      ~_Format_cache() throw() { }\n+\n+      // Given a member of the ios heirarchy as an argument, extract\n+      // out all the current formatting information into a\n+      // _Format_cache object and return a pointer to it.\n+      static _Format_cache<_CharT>* \n+      _S_get(ios_base& __ios);\n+\n+      void \n+      _M_populate(ios_base&);\n+\n+      static void \n+      _S_callback(ios_base::event __event, ios_base& __ios, int __ix) throw();\n+    };\n+\n+   template<> _Format_cache<char>::_Format_cache();\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+   template<> _Format_cache<wchar_t>::_Format_cache();\n+#endif\n+\n+  // _Numeric_get is used by num_get, money_get, and time_get to help\n+  // in parsing out numbers.\n+  template<typename _CharT, typename _InIter>\n+    class _Numeric_get\n+    {\n+    public:\n+      // Types:\n+      typedef _CharT     char_type;\n+      typedef _InIter    iter_type;\n+\n+      // Forward decls and Friends:\n+      template<typename _Char, typename _InIterT>\n+      friend class num_get;\n+      template<typename _Char, typename _InIterT>\n+      friend class time_get;\n+      template<typename _Char, typename _InIterT>\n+      friend class money_get;\n+      template<typename _Char, typename _InIterT>\n+      friend class num_put;\n+      template<typename _Char, typename _InIterT>\n+      friend class time_put;\n+      template<typename _Char, typename _InIterT>\n+      friend class money_put;\n+\n+    private:\n+      explicit \n+      _Numeric_get() { }\n+\n+      virtual \n+      ~_Numeric_get() { }\n+\n+      iter_type \n+      _M_get_digits(iter_type __in, iter_type __end) const;\n+    };\n+\n+  template<typename _CharT, typename _InIter>\n+    class num_get : public locale::facet\n+    {\n+    public:\n+      // Types:\n+      typedef _CharT   \t\t\tchar_type;\n+      typedef _InIter  \t\t\titer_type;\n+      typedef char_traits<_CharT> \t__traits_type;\n+\n+      explicit \n+      num_get(size_t __refs = 0) : locale::facet(__refs) { }\n+\n+      iter_type \n+      get(iter_type __in, iter_type __end, ios_base& __io,\n+\t  ios_base::iostate& __err, bool& __v) const\n+      { return do_get(__in, __end, __io, __err, __v); }\n+\n+#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n+      iter_type \n+      get(iter_type __in, iter_type __end, ios_base& __io,\n+\t  ios_base::iostate& __err, short& __v) const\n+      { return do_get(__in, __end, __io, __err, __v); }\n+\n+      iter_type \n+      get(iter_type __in, iter_type __end, ios_base& __io,\n+\t  ios_base::iostate& __err, int& __v)   const\n+      { return do_get(__in, __end, __io, __err, __v); }\n+#endif\n+\n+      iter_type\n+      get(iter_type __in, iter_type __end, ios_base& __io, \n+\t  ios_base::iostate& __err, long& __v) const\n+      { return do_get(__in, __end, __io, __err, __v); }\n+\n+#ifdef _GLIBCPP_USE_LONG_LONG\n+      iter_type \n+      get(iter_type __in, iter_type __end, ios_base& __io,\n+\t  ios_base::iostate& __err, long long& __v) const\n+      { return do_get(__in, __end, __io, __err, __v); }\n+#endif\n+\n+      iter_type \n+      get(iter_type __in, iter_type __end, ios_base& __io,\n+\t  ios_base::iostate& __err, unsigned short& __v) const\n+      { return do_get(__in, __end, __io, __err, __v); }\n+\n+      iter_type \n+      get(iter_type __in, iter_type __end, ios_base& __io,\n+\t  ios_base::iostate& __err, unsigned int& __v)   const\n+      { return do_get(__in, __end, __io, __err, __v); }\n+\n+      iter_type \n+      get(iter_type __in, iter_type __end, ios_base& __io,\n+\t  ios_base::iostate& __err, unsigned long& __v)  const\n+      { return do_get(__in, __end, __io, __err, __v); }\n+\n+#ifdef _GLIBCPP_USE_LONG_LONG\n+      iter_type \n+      get(iter_type __in, iter_type __end, ios_base& __io,\n+\t  ios_base::iostate& __err, unsigned long long& __v)  const\n+      { return do_get(__in, __end, __io, __err, __v); }\n+#endif\n+\n+      iter_type \n+      get(iter_type __in, iter_type __end, ios_base& __io,\n+\t  ios_base::iostate& __err, float& __v) const\n+      { return do_get(__in, __end, __io, __err, __v); }\n+\n+      iter_type \n+      get(iter_type __in, iter_type __end, ios_base& __io,\n+\t  ios_base::iostate& __err, double& __v) const\n+      { return do_get(__in, __end, __io, __err, __v); }\n+\n+      iter_type \n+      get(iter_type __in, iter_type __end, ios_base& __io,\n+\t  ios_base::iostate& __err, long double& __v) const\n+      { return do_get(__in, __end, __io, __err, __v); }\n+\n+      iter_type \n+      get(iter_type __in, iter_type __end, ios_base& __io,\n+\t  ios_base::iostate& __err, void*& __v) const\n+      { return do_get(__in, __end, __io, __err, __v); }      \n+      static locale::id id;\n+\n+    protected:\n+      virtual ~num_get() { }\n+\n+      // This consolidates the extraction, storage and\n+      // error-processing parts of the do_get(...) overloaded member\n+      // functions. NB: this is specialized for char.\n+      void \n+      _M_extract(iter_type __beg, iter_type __end, ios_base& __io, \n+\t\t ios_base::iostate& __err, char* __xtrc, \n+\t\t int& __base, bool __fp = true) const;\n+\n+      virtual iter_type \n+      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;\n+\n+#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n+      virtual iter_type \n+      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, short&) const;\n+      virtual iter_type \n+      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, int&) const;\n+#endif\n+      virtual iter_type \n+      do_get (iter_type, iter_type, ios_base&, ios_base::iostate&, long&) const;\n+#ifdef _GLIBCPP_USE_LONG_LONG \n+      virtual iter_type \n+      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err, \n+\t     long long&) const;\n+#endif\n+      virtual iter_type \n+      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err, \n+\t      unsigned short&) const;\n+      virtual iter_type \n+      do_get(iter_type, iter_type, ios_base&,\n+\t      ios_base::iostate& __err, unsigned int&) const;\n+      virtual iter_type \n+      do_get(iter_type, iter_type, ios_base&,\n+\t      ios_base::iostate& __err, unsigned long&) const;\n+#ifdef _GLIBCPP_USE_LONG_LONG \n+      virtual iter_type \n+      do_get(iter_type, iter_type, ios_base&,\n+\t     ios_base::iostate& __err, unsigned long long&) const;\n+#endif\n+      virtual iter_type \n+      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err, \n+\t     float&) const;\n+\n+      virtual iter_type \n+      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err, \n+\t     double&) const;\n+\n+      virtual iter_type \n+      do_get(iter_type, iter_type, ios_base&, \n+\t     ios_base::iostate& __err, long double&) const;\n+\n+      virtual iter_type \n+      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err, \n+\t     void*&) const;\n+    };\n+\n+  // Declare specialized extraction member function.\n+  template<>\n+    void\n+    num_get<char, istreambuf_iterator<char> >::    \n+    _M_extract(istreambuf_iterator<char> __beg, \n+\t       istreambuf_iterator<char> __end, ios_base& __io, \n+\t       ios_base::iostate& __err, char* __xtrc, \n+\t       int& __base, bool __fp) const;\n+\n+  // _Numeric_put is used by num_put, money_put, and time_put\n+  //   to help in formatting out numbers.\n+  template<typename _CharT, typename _OutIter>\n+    class _Numeric_put\n+    {\n+    public:\n+      typedef _CharT      char_type;\n+      typedef _OutIter    iter_type;\n+    protected:\n+      explicit \n+      _Numeric_put() { }\n+\n+      virtual \n+      ~_Numeric_put() { }\n+    };\n+\n+  template<typename _CharT, typename _OutIter>\n+    class num_put : public locale::facet\n+    {\n+    public:\n+      // Types:\n+      typedef _CharT       char_type;\n+      typedef _OutIter     iter_type;\n+\n+      explicit \n+      num_put(size_t __refs = 0) : locale::facet(__refs) { }\n+\n+      iter_type \n+      put(iter_type __s, ios_base& __f, char_type __fill, bool __v) const\n+      { return do_put(__s, __f, __fill, __v); }\n+\n+      iter_type \n+      put(iter_type __s, ios_base& __f, char_type __fill, long __v) const\n+      { return do_put(__s, __f, __fill, __v); }\n+\n+      iter_type \n+      put(iter_type __s, ios_base& __f, char_type __fill, \n+\t  unsigned long __v) const\n+      { return do_put(__s, __f, __fill, __v); }\n+\n+#ifdef _GLIBCPP_USE_LONG_LONG \n+      iter_type \n+      put(iter_type __s, ios_base& __f, char_type __fill, long long __v) const\n+      { return do_put(__s, __f, __fill, __v); }\n+\n+      iter_type \n+      put(iter_type __s, ios_base& __f, char_type __fill, \n+\t  unsigned long long __v) const\n+      { return do_put(__s, __f, __fill, __v); }\n+#endif\n+\n+      iter_type \n+      put(iter_type __s, ios_base& __f, char_type __fill, double __v) const\n+      { return do_put(__s, __f, __fill, __v); }\n+\n+      iter_type \n+      put(iter_type __s, ios_base& __f, char_type __fill, \n+\t  long double __v) const\n+      { return do_put(__s, __f, __fill, __v); }\n+\n+      iter_type \n+      put(iter_type __s, ios_base& __f, char_type __fill, \n+\t  const void* __v) const\n+      { return do_put(__s, __f, __fill, __v); }\n+\n+      static locale::id id;\n+\n+    protected:\n+      virtual \n+      ~num_put() { };\n+\n+      virtual iter_type \n+      do_put(iter_type, ios_base&, char_type __fill, bool __v) const;\n+\n+      virtual iter_type \n+      do_put(iter_type, ios_base&, char_type __fill, long __v) const;\n+\n+#ifdef _GLIBCPP_USE_LONG_LONG \n+      virtual iter_type \n+      do_put(iter_type, ios_base&, char_type __fill, long long __v) const;\n+#endif\n+\n+      virtual iter_type \n+      do_put(iter_type, ios_base&, char_type __fill, unsigned long) const;\n+\n+#ifdef _GLIBCPP_USE_LONG_LONG\n+      virtual iter_type\n+      do_put(iter_type, ios_base&, char_type __fill, unsigned long long) const;\n+#endif\n+\n+      virtual iter_type \n+      do_put(iter_type, ios_base&, char_type __fill, double __v) const;\n+\n+      virtual iter_type \n+      do_put(iter_type, ios_base&, char_type __fill, long double __v) const;\n+\n+      virtual iter_type \n+      do_put(iter_type, ios_base&, char_type __fill, const void* __v) const;\n+    };\n+\n+  template<typename _CharT>\n+    class _Punct : public locale::facet\n+    {\n+    public:\n+      // Types:\n+      typedef _CharT               char_type;\n+      typedef basic_string<_CharT> string_type;\n+\n+      char_type    \n+      decimal_point() const\n+      { return do_decimal_point(); }\n+\n+      char_type    \n+      thousands_sep() const\n+      { return do_thousands_sep(); }\n+\n+      string       \n+      grouping() const\n+      { return do_grouping(); }\n+    protected:\n+\n+      explicit \n+      _Punct(size_t __refs = 0) : locale::facet(__refs) { }\n+\n+      virtual \n+      ~_Punct() { }\n+\n+      virtual char_type    \n+      do_decimal_point() const\n+      { return _M_decimal_point; }\n+\n+      virtual char_type    \n+      do_thousands_sep() const\n+      { return _M_thousands_sep; }\n+\n+      virtual string       \n+      do_grouping() const\n+      { return _M_grouping; }\n+\n+    private:\n+      char_type _M_decimal_point;\n+      char_type _M_thousands_sep;\n+      string    _M_grouping;\n+      \n+    protected:\n+      // for use at construction time only:\n+      void \n+      _M_init(char_type __d, char_type __t, const string& __g)\n+      {\n+\t_M_decimal_point = __d;\n+\t_M_thousands_sep = __t;\n+\t_M_grouping = __g;\n+      }\n+\n+    };\n+\n+  template<typename _CharT>\n+    class _Numpunct : public _Punct<_CharT>\n+    {\n+    public:\n+      // Types:\n+      typedef _CharT               char_type;\n+      typedef basic_string<_CharT> string_type;\n+\n+      string_type  \n+      truename() const\n+      { return do_truename(); }\n+\n+      string_type  \n+      falsename() const\n+      { return do_falsename(); }\n+\n+    protected:\n+      explicit \n+      _Numpunct(size_t __refs = 0) : _Punct<_CharT> (__refs) { }\n+\n+      virtual \n+      ~_Numpunct() { }\n+\n+      virtual string_type  \n+      do_truename() const\n+      { return _M_truename; }\n+\n+      virtual string_type  \n+      do_falsename() const\n+      { return _M_falsename; }\n+\n+    private:\n+      string_type _M_truename;\n+      string_type _M_falsename;\n+      \n+    protected:\n+      // For use only during construction\n+      void \n+      _M_init_boolnames(const string_type& __t, const string_type& __f)\n+      {\n+\t_M_truename = __t;\n+\t_M_falsename = __f;\n+      }\n+\t\n+    };\n+\n+  template<typename _CharT>\n+    class numpunct : public _Numpunct<_CharT>\n+    {\n+    public:\n+      typedef _CharT               char_type;\n+      typedef basic_string<_CharT> string_type;\n+\n+      static locale::id id;\n+\n+      explicit \n+      numpunct(size_t __refs = 0) : _Numpunct<_CharT>(__refs) { }\n+    protected:\n+\n+      virtual \n+      ~numpunct() { }\n+    };\n+\n+  template<> \n+    numpunct<char>::numpunct(size_t __refs): _Numpunct<char>(__refs)\n+    {\n+      _M_init('.', ',', \"\");\n+      _M_init_boolnames(\"true\", \"false\");\n+    }\n+\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  template<> \n+    numpunct<wchar_t>::numpunct(size_t __refs): _Numpunct<wchar_t>(__refs)\n+    {\n+      _M_init(L'.', L',', \"\");\n+      _M_init_boolnames(L\"true\", L\"false\");\n+    }\n+#endif\n+\n+  template<typename _CharT>\n+    class numpunct_byname : public numpunct<_CharT>\n+    {\n+    public:\n+      typedef _CharT               char_type;\n+      typedef basic_string<_CharT> string_type;\n+\n+      explicit \n+      numpunct_byname(const char*, size_t __refs = 0);\n+      \n+    protected:\n+      virtual \n+      ~numpunct_byname() { }\n+    };\n+\n+  template<>\n+    numpunct_byname<char>::numpunct_byname(const char*, size_t __refs);\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  template<>\n+    numpunct_byname<wchar_t>::numpunct_byname(const char*, size_t __refs);\n+#endif\n+\n+  template<typename _CharT>\n+    class _Collate : public locale::facet\n+    {\n+    public:\n+      // Types:\n+      typedef _CharT               char_type;\n+      typedef basic_string<_CharT> string_type;\n+\n+      int \n+      compare(const _CharT* __lo1, const _CharT* __hi1,\n+\t      const _CharT* __lo2, const _CharT* __hi2) const\n+      { return do_compare(__lo1, __hi1, __lo2, __hi2); }\n+\n+      string_type \n+      transform(const _CharT* __lo, const _CharT* __hi) const\n+      { return do_transform(__lo, __hi); }\n+\n+      long \n+      hash(const _CharT* __lo, const _CharT* __hi) const\n+      { return do_hash(__lo, __hi); }\n+      \n+  protected:\n+      explicit \n+      _Collate(size_t __refs = 0) : locale::facet(__refs) { }\n+\n+      ~_Collate() { } // virtual\n+\n+      virtual int  \n+      do_compare(const _CharT* __lo1, const _CharT* __hi1,\n+\t\t const _CharT* __lo2, const _CharT* __hi2) const = 0;\n+\n+      virtual string_type \n+      do_transform(const _CharT* __lo, const _CharT* __hi) const = 0;\n+\n+      virtual long   \n+      do_hash(const _CharT* __lo, const _CharT* __hi) const = 0;\n+    };\n+\n+  template<typename _CharT>\n+    class collate : public _Collate<_CharT>\n+    {\n+    public:      \n+      // Types:\n+      typedef _CharT               char_type;\n+      typedef basic_string<_CharT> string_type;\n+\n+      explicit \n+      collate(size_t __refs = 0) : _Collate<_CharT> (__refs) { }\n+\n+      static locale::id id;\n+      \n+    protected:\n+      virtual \n+      ~collate() { }\n+    };\n+\n+  template<>\n+    class collate<char> : public _Collate<char>\n+    {\n+    public:      \n+      // Types:\n+      typedef char               char_type;\n+      typedef basic_string<char> string_type;\n+\n+      explicit \n+      collate(size_t __refs = 0);\n+\n+      static locale::id id;\n+      \n+    protected:\n+      virtual \n+      ~collate();\n+\n+      virtual int  \n+      do_compare(const char* __lo1, const char* __hi1,\n+\t\t const char* __lo2, const char* __hi2) const;\n+\n+      virtual string_type \n+      do_transform(const char* __lo, const char* __hi) const;\n+\n+      virtual long   \n+      do_hash(const char* __lo, const char* __hi) const;\n+    };\n+\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  template<>\n+    class collate<wchar_t> : public _Collate<wchar_t>\n+    {\n+    public:\n+      // Types:\n+      typedef wchar_t               char_type;\n+      typedef basic_string<wchar_t> string_type;\n+      \n+      explicit \n+      collate(size_t __refs = 0);\n+\n+      static locale::id id;\n+      \n+    protected:\n+      virtual \n+      ~collate();\n+\n+      virtual int   \n+      do_compare(const wchar_t* __lo1, const wchar_t* __hi1,\n+\t\t const wchar_t* __lo2, const wchar_t* __hi2) const;\n+\n+      virtual string_type \n+      do_transform(const wchar_t* __lo, const wchar_t* __hi) const;\n+\n+      virtual long   \n+      do_hash(const wchar_t* __lo, const wchar_t* __hi) const;\n+    };\n+#endif\n+\n+  template<typename _CharT>\n+    class collate_byname : public collate<_CharT>\n+    {\n+    public:\n+      // Types:\n+      typedef _CharT               char_type;\n+      typedef basic_string<_CharT> string_type;\n+\n+      explicit \n+      collate_byname(const char*, size_t __refs = 0);\n+\n+    protected:\n+      virtual \n+      ~collate_byname() { }\n+    };\n+\n+  template<>\n+    collate_byname<char>::collate_byname(const char*, size_t __refs);\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  template<>\n+    collate_byname<wchar_t>::collate_byname(const char*, size_t __refs);\n+#endif\n+\n+  class time_base\n+  {\n+  public:\n+    enum dateorder { no_order, dmy, mdy, ymd, ydm };\n+  };\n+\n+  template<typename _CharT, typename _InIter>\n+    class time_get : public locale::facet, public time_base\n+    {\n+    public:\n+      // Types:\n+      typedef _CharT     char_type;\n+      typedef _InIter    iter_type;\n+\n+      explicit \n+      time_get(size_t __refs = 0) \n+      : locale::facet (__refs), _M_daynames(0), _M_monthnames(0) { }\n+\n+      dateorder \n+      date_order()  const\n+      { return do_date_order(); }\n+\n+      iter_type \n+      get_time(iter_type __s, iter_type __end, ios_base& __f, \n+\t       ios_base::iostate& __err, tm* __t)  const\n+      { return do_get_time(__s, __end, __f, __err, __t); }\n+\n+      iter_type \n+      get_date(iter_type __s, iter_type __end, ios_base& __f,\n+\t       ios_base::iostate& __err, tm* __t)  const\n+      { return do_get_date(__s, __end, __f, __err, __t); }\n+\n+      iter_type \n+      get_weekday(iter_type __s, iter_type __end, ios_base& __f,\n+\t\t  ios_base::iostate& __err, tm* __t) const\n+      { return do_get_weekday(__s,__end,__f,__err,__t); }\n+\n+      iter_type \n+      get_monthname(iter_type __s, iter_type __end, ios_base& __f, \n+\t\t    ios_base::iostate& __err, tm* __t) const\n+      { return do_get_monthname(__s,__end,__f,__err,__t); }\n+\n+      iter_type \n+      get_year(iter_type __s, iter_type __end, ios_base& __f,\n+\t       ios_base::iostate& __err, tm* __t) const\n+      { return do_get_year(__s,__end,__f,__err,__t); }\n+\n+      static locale::id id;\n+\n+    protected:\n+      virtual \n+      ~time_get() \n+      {      \n+\tdelete [] _M_monthnames; \n+\tdelete [] _M_daynames; \n+      }\n+\n+      virtual dateorder \n+      do_date_order()  const\n+      { return time_base::ymd; }\n+\n+      virtual iter_type \n+      do_get_time(iter_type __s, iter_type /*__end*/, ios_base&,\n+\t\t  ios_base::iostate& /*__err*/, tm* /*__t*/) const\n+      { return __s; }\n+\n+      virtual iter_type \n+      do_get_date(iter_type __s, iter_type /*__end*/, ios_base&,\n+\t\t  ios_base::iostate& /*__err*/, tm* /*__t*/) const\n+      { return __s; }\n+\n+      virtual iter_type \n+      do_get_weekday(iter_type __s, iter_type __end, ios_base&,\n+\t\t     ios_base::iostate& __err, tm* __t) const;\n+\n+      virtual iter_type \n+      do_get_monthname(iter_type __s, iter_type __end, ios_base&, \n+\t\t       ios_base::iostate& __err, tm* __t) const;\n+\n+      virtual iter_type \n+      do_get_year(iter_type __s, iter_type /*__end*/, ios_base&,\n+\t\t   ios_base::iostate& /*__err*/, tm* /*__t*/) const\n+      { return __s; }\n+\n+      mutable basic_string<_CharT>* _M_daynames;\n+      mutable basic_string<_CharT>* _M_monthnames;\n+    };\n+\n+  template<typename _CharT, typename _InIter>\n+    class time_get_byname : public time_get<_CharT, _InIter>\n+    {\n+    public:\n+      typedef _CharT     char_type;\n+      typedef _InIter    iter_type;\n+\n+      explicit \n+      time_get_byname(const char*, size_t __refs = 0) \n+      : time_get<_CharT, _InIter>(__refs) { }\n+    protected:\n+      virtual \n+      ~time_get_byname() { }\n+    };\n+\n+  template<typename _CharT, typename _OutIter>\n+    class time_put : public locale::facet, public time_base\n+    {\n+    public:\n+      typedef _CharT     char_type;\n+      typedef _OutIter   iter_type;\n+\n+      explicit \n+      time_put(size_t __refs = 0) : locale::facet (__refs) { }\n+\n+      // NB: this is a nonvirtual, calls do_put in a loop.\n+      iter_type \n+      put(iter_type __s, ios_base& /*__f*/, char_type /*__fill*/,\n+          const tm* /*__tmb*/, const _CharT* /*__pattern*/,\n+          const _CharT* /*__pat_end*/) const\n+      { return __s; }\n+\n+      iter_type \n+      put(iter_type __s, ios_base& __f, char_type __fill,\n+\t  const tm* __tmb, char __format, char __modifier = 0) const\n+      { return do_put(__s, __f, __fill, __tmb, __format, __modifier); }\n+\n+      static locale::id id;\n+\n+    protected:\n+      virtual \n+      ~time_put() { }\n+\n+      virtual iter_type \n+      do_put(iter_type __s, ios_base&, char_type, const tm* /*__t*/, \n+\t     char /*__format*/, char /*__mod*/) const\n+      { return __s; }\n+    };\n+\n+  template<typename _CharT, typename _OutIter>\n+    class time_put_byname : time_put<_CharT, _OutIter>\n+    {\n+    public:\n+      typedef _CharT     char_type;\n+      typedef _OutIter   iter_type;\n+\n+      explicit \n+      time_put_byname(const char*, size_t __refs = 0) \n+      : time_put<_CharT, _OutIter> (__refs) { }\n+    protected:\n+      virtual \n+      ~time_put_byname() { }\n+    };\n+\n+\n+  template<typename _CharT, typename _InIter>\n+    class money_get : public locale::facet\n+    {\n+    public:\n+      typedef _CharT        char_type;\n+      typedef _InIter       iter_type;\n+      typedef basic_string<_CharT> string_type;\n+\n+      explicit \n+      money_get(size_t __refs = 0) : locale::facet(__refs) { }\n+\n+      iter_type \n+      get(iter_type __s, iter_type __end, bool __intl,\n+\t  ios_base& __f, ios_base::iostate& __err, long double& __units) const\n+      { return do_get(__s, __end, __intl, __f, __err, __units); }\n+\n+      iter_type \n+      get(iter_type __s, iter_type __end, bool __intl, ios_base& __f, \n+\t   ios_base::iostate& __err, string_type& __digits) const\n+      { return do_get(__s, __end, __intl, __f, __err, __digits); }\n+\n+      static locale::id id;\n+\n+    protected:\n+      virtual \n+      ~money_get() { }\n+\n+      virtual iter_type \n+      do_get(iter_type __s, iter_type /*__end*/, bool /*__intl*/,\n+             ios_base& /*__io*/, ios_base::iostate& /*__err*/,\n+             long double& /*__units*/) const\n+      { return __s; }\n+\n+      virtual iter_type \n+      do_get(iter_type __s, iter_type /*__end*/, bool /*__intl*/,\n+             ios_base& /*__io*/, ios_base::iostate& /*__err*/,\n+             string_type& /*__digits*/) const\n+      { return __s; }\n+    };\n+\n+  template<typename _CharT, typename _OutIter>\n+    class money_put : public locale::facet\n+    {\n+    public:\n+      typedef _CharT              char_type;\n+      typedef _OutIter            iter_type;\n+      typedef basic_string<_CharT> string_type;\n+\n+      explicit \n+      money_put(size_t __refs = 0) : locale::facet(__refs) { }\n+\n+      iter_type \n+      put(iter_type __s, bool __intl, ios_base& __f,\n+\t  char_type __fill, long double __units) const\n+      { return do_put(__s, __intl, __f, __fill, __units); }\n+\n+      iter_type \n+      put(iter_type __s, bool __intl, ios_base& __f,\n+\t  char_type __fill, const string_type& __digits) const\n+      { return do_put(__s, __intl, __f, __fill, __digits); }\n+\n+      static locale::id id;\n+\n+    protected:\n+      virtual \n+      ~money_put() { }\n+\n+      virtual iter_type\n+      do_put(iter_type __s, bool, ios_base& /*__io*/, char_type /*__fill*/,\n+\t     long double /*__units*/) const\n+      { return __s; }\n+\n+      virtual iter_type\n+      do_put(iter_type __s, bool, ios_base& /*__io*/, char_type /*__fill*/,\n+\t     const string_type& /*__digits*/) const\n+      { return __s; }\n+    };\n+\n+  struct money_base\n+  {\n+    enum part { none, space, symbol, sign, value };\n+    struct pattern { char field[4]; };\n+\n+    static const pattern __default_pattern;\n+  };\n+\n+  template<typename _CharT>\n+    class _Moneypunct : public _Punct<_CharT>, public money_base\n+    {\n+    public:\n+      typedef _CharT char_type;\n+      typedef basic_string<_CharT> string_type;\n+\n+      string_type  \n+      curr_symbol()   const\n+      { return do_curr_symbol(); }\n+\n+      string_type  \n+      positive_sign() const\n+      { return do_positive_sign(); }\n+\n+      string_type  \n+      negative_sign() const\n+      { return do_negative_sign(); }\n+\n+      int          \n+      frac_digits()   const\n+      { return do_frac_digits(); }\n+\n+      pattern      \n+      pos_format()    const\n+      { return do_pos_format(); }\n+\n+      pattern      \n+      neg_format()    const\n+      { return do_neg_format(); }\n+\n+    protected:\n+      explicit \n+      _Moneypunct(size_t __refs = 0) : _Punct<_CharT> (__refs) { }\n+\n+      virtual \n+      ~_Moneypunct() { }\n+\n+      virtual string_type  \n+      do_curr_symbol()   const\n+      { return basic_string<_CharT>(); }\n+\n+      virtual string_type  \n+      do_positive_sign() const\n+      { return basic_string<_CharT>(); }\n+\n+      virtual string_type  \n+      do_negative_sign() const\n+      { return basic_string<_CharT>(); }\n+\n+      virtual int          \n+      do_frac_digits() const\n+      { return 0; }\n+\n+      virtual pattern      \n+      do_pos_format() const\n+      {\n+\treturn money_base::__default_pattern;\n+      }\n+\n+      virtual pattern      \n+      do_neg_format() const\n+      {\n+\treturn money_base::__default_pattern;\n+      }\n+\n+    };\n+\n+  template<typename _CharT, bool _Intl>\n+    class moneypunct : public _Moneypunct<_CharT>\n+    {\n+    public:\n+      // Types:\n+      typedef _CharT \t\t\tchar_type;\n+      typedef basic_string<_CharT> \tstring_type;\n+\n+      static const bool intl = _Intl;\n+      static locale::id id;\n+\n+      explicit \n+      moneypunct(size_t __refs = 0) : _Moneypunct<_CharT> (__refs) { }\n+    protected:\n+      virtual \n+      ~moneypunct() { }\n+    };\n+\n+  template<typename _CharT, bool _Intl>\n+    class moneypunct_byname : public moneypunct<_CharT,_Intl>\n+    {\n+    public:\n+      typedef _CharT char_type;\n+      typedef basic_string<_CharT> string_type;\n+      static const bool intl = _Intl;\n+\n+      explicit \n+      moneypunct_byname(const char*, size_t __refs = 0);\n+\n+    protected:\n+      virtual \n+      ~moneypunct_byname() { }\n+    };\n+\n+  template<>\n+    moneypunct_byname<char, false>::\n+    moneypunct_byname(const char*, size_t __refs);\n+  template<>\n+    moneypunct_byname<char, true>::\n+    moneypunct_byname(const char*, size_t __refs);\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  template<>\n+    moneypunct_byname<wchar_t,false>::\n+    moneypunct_byname(const char*, size_t __refs);\n+  template<>\n+    moneypunct_byname<wchar_t,true>::\n+    moneypunct_byname (const char*, size_t __refs);\n+#endif\n+\n+  struct messages_base\n+  {\n+    typedef int catalog;\n+  };\n+\n+  template<typename _CharT>\n+    class _Messages : public locale::facet, public messages_base\n+    {\n+    public:\n+      typedef _CharT char_type;\n+      typedef basic_string<_CharT> string_type;\n+\n+      catalog \n+      open(const basic_string<char>& __s, const locale& __loc) const\n+      { return do_open(__s, __loc); }\n+\n+      string_type  \n+      get(catalog __c, int __set, int __msgid, const string_type& __s) const\n+      { return do_get(__c,__set,__msgid,__s); }\n+\n+      void \n+      close(catalog __c) const\n+      { return do_close(__c); }\n+\n+    protected:\n+      explicit \n+      _Messages(size_t __refs = 0) : locale::facet(__refs) { }\n+\n+      virtual \n+      ~_Messages() { }\n+\n+      // NB: Probably these should be pure, and implemented only in\n+      //  specializations of messages<>.  But for now...\n+      virtual catalog \n+      do_open(const basic_string<char>&, const locale&) const\n+      { return 0; }\n+\n+      virtual string_type  \n+      do_get(catalog, int, int /*__msgid*/, const string_type& __dfault) const\n+      { return __dfault; }\n+\n+      virtual void    \n+      do_close (catalog) const { }\n+    };\n+\n+  template<typename _CharT>\n+    class messages : public _Messages<_CharT>\n+    {\n+    public:\n+      typedef _CharT char_type;\n+      typedef basic_string<_CharT> string_type;\n+      static locale::id id;\n+\n+      explicit \n+      messages(size_t __refs = 0) : _Messages<_CharT> (__refs) { }\n+    protected:\n+      virtual \n+      ~messages() { }\n+    };\n+\n+  template<typename _CharT>\n+    class messages_byname : public messages<_CharT>\n+    {\n+    public:\n+      typedef _CharT char_type;\n+      typedef basic_string<_CharT> string_type;\n+\n+      explicit \n+      messages_byname(const char*, size_t __refs = 0);\n+\n+    protected:\n+      virtual \n+      ~messages_byname() { }\n+    };\n+\n+  template<>\n+    messages_byname<char>::messages_byname(const char*, size_t __refs);\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  template<>\n+    messages_byname<wchar_t>::messages_byname(const char*, size_t __refs);\n+#endif\n+\n+  // Subclause convenience interfaces, inlines \n+  // NB: these are inline\n+  // because, when used in a loop, some compilers can hoist the body\n+  // out of the loop; then it's just as fast as the C is*() function.\n+  template<typename _CharT>\n+    inline bool \n+    isspace(_CharT __c, const locale& __loc)\n+    { return use_facet<ctype<_CharT> > (__loc).is(ctype_base::space, __c); }\n+\n+  template<typename _CharT>\n+    inline bool \n+    isprint(_CharT __c, const locale& __loc)\n+    { return use_facet<ctype<_CharT> > (__loc).is(ctype_base::print, __c); }\n+\n+  template<typename _CharT>\n+    inline bool \n+    iscntrl(_CharT __c, const locale& __loc)\n+    { return use_facet<ctype<_CharT> > (__loc).is(ctype_base::cntrl, __c); }\n+\n+  template<typename _CharT>\n+    inline bool \n+    isupper(_CharT __c, const locale& __loc)\n+    { return use_facet<ctype<_CharT> > (__loc).is(ctype_base::upper, __c); }\n+\n+  template<typename _CharT>\n+    inline bool islower(_CharT __c, const locale& __loc)\n+    { return use_facet<ctype<_CharT> > (__loc).is(ctype_base::lower, __c); }\n+\n+  template<typename _CharT>\n+    inline bool \n+    isalpha(_CharT __c, const locale& __loc)\n+    { return use_facet<ctype<_CharT> > (__loc).is(ctype_base::alpha, __c); }\n+\n+  template<typename _CharT>\n+    inline bool \n+    isdigit(_CharT __c, const locale& __loc)\n+    { return use_facet<ctype<_CharT> > (__loc).is(ctype_base::digit, __c); }\n+\n+  template<typename _CharT>\n+    inline bool \n+    ispunct(_CharT __c, const locale& __loc)\n+    { return use_facet<ctype<_CharT> > (__loc).is(ctype_base::punct, __c); }\n+\n+  template<typename _CharT>\n+    inline bool \n+    isxdigit(_CharT __c, const locale& __loc)\n+    { return use_facet<ctype<_CharT> > (__loc).is(ctype_base::xdigit, __c); }\n+\n+  template<typename _CharT>\n+    inline bool \n+    isalnum(_CharT __c, const locale& __loc)\n+    { return use_facet<ctype<_CharT> > (__loc).is(ctype_base::alnum, __c); }\n+\n+  template<typename _CharT>\n+    inline bool \n+    isgraph(_CharT __c, const locale& __loc)\n+    { return use_facet<ctype<_CharT> > (__loc).is(ctype_base::graph, __c); }\n+\n+  template<typename _CharT>\n+    inline _CharT \n+    toupper(_CharT __c, const locale& __loc)\n+    { return use_facet<ctype<_CharT> > (__loc).toupper(__c); }\n+\n+  template<typename _CharT>\n+    inline _CharT \n+    tolower(_CharT __c, const locale& __loc)\n+    { return use_facet<ctype<_CharT> > (__loc).tolower(__c); }\n+\n+} // namespace std\n+\n+#endif\t/* _CPP_BITS_LOCFACETS_H */\n+\n+// Local Variables:\n+// mode:c++\n+// End:\n+"}, {"sha": "3772f0678738b12537c5a28b620c60a56782e4ff", "filename": "libstdc++-v3/bits/locale_facets.tcc", "status": "added", "additions": 1440, "deletions": 0, "changes": 1440, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Flocale_facets.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Flocale_facets.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Flocale_facets.tcc?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,1440 @@\n+// Locale support -*- C++ -*-\n+\n+// Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// Warning: this file is not meant for user inclusion.  Use <locale>.\n+\n+#ifndef _CPP_BITS_LOCFACETS_TCC\n+#define _CPP_BITS_LOCFACETS_TCC 1\n+\n+#include <bits/std_cerrno.h>\n+#include <bits/std_cstdlib.h> \t// For strof, strtold\n+#include <bits/std_limits.h>\t// For numeric_limits\n+#include <bits/std_vector.h>\n+#include <bits/std_memory.h>\t// For auto_ptr\n+#include <bits/sbuf_iter.h>\t// For streambuf_iterators\n+\n+namespace std\n+{\n+  template<typename _Facet>\n+    locale \n+    locale::combine(const locale& __other)\n+    {\n+      locale __copy(*this);\n+      __copy._M_impl->_M_replace_facet(__other._M_impl, &_Facet::id);\n+      __copy._M_impl->_M_has_name = false;\n+      return __copy;\n+    }\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    bool\n+    locale::operator()(const basic_string<_CharT,_Traits,_Alloc>& __s1,\n+\t\t       const basic_string<_CharT,_Traits,_Alloc>& __s2) const\n+    {\n+      // XXX should not need to qualify here.\n+      // typedef collate<_CharT> __collate_type;\n+      typedef std::collate<_CharT> __collate_type;\n+      const __collate_type* __fcoll = &use_facet<__collate_type>(*this);\n+      return (__fcoll->compare(__s1.data(), __s1.data() + __s1.length(),\n+\t\t\t       __s2.data(), __s2.data() + __s2.length()) < 0);\n+    }\n+\n+  template<typename _Facet>\n+    const _Facet&\n+    use_facet(const locale& __loc)\n+    {\n+      const locale::facet* __fp = (const _Facet*)0;    // check derivation\n+      locale::id& __id = _Facet::id;         // check member id\n+      size_t __i = __id._M_index;\n+      const locale::_Impl* __tmp = __loc._M_impl;\n+      if (__id._M_index >= __loc._M_impl->_M_facets->size() \n+\t  || (__fp = (*(__tmp->_M_facets))[__i]) == 0)\n+\treturn _Use_facet_failure_handler<_Facet>(__loc);\n+      return static_cast<const _Facet&>(*__fp);\n+    }\n+\n+  template<typename _Facet>\n+    bool\n+    has_facet(const locale& __loc) throw()\n+    {\n+      typedef locale::_Impl::__vec_facet\t__vec_facet;\n+      locale::id& __id = _Facet::id;         // check member id\n+      size_t __i = __id._M_index;\n+      __vec_facet* __tmpv = __loc._M_impl->_M_facets;\n+      return (__i < __tmpv->size() && (*__tmpv)[__i] != 0);\n+    }\n+\n+  // __match_parallel\n+  // matches input __s against a set of __ntargs strings in __targets,\n+  // placing in __matches a vector of indices into __targets which\n+  // match, and in __remain the number of such matches. If it hits\n+  // end of sequence before it minimizes the set, sets __eof.\n+  // Empty strings are never matched.\n+  template<typename _InIter, typename _CharT>\n+    _InIter \n+    __match_parallel(_InIter __s, _InIter __end, int __ntargs, \n+\t\t     const basic_string<_CharT>* __targets,\n+\t\t     int* __matches, int& __remain, bool& __eof)\n+    {\n+      typedef basic_string<_CharT> __string_type;\n+      __eof = false;\n+      for (int __ti = 0; __ti < __ntargs; ++__ti) \n+\t__matches[__ti] = __ti;\n+      __remain = __ntargs;\n+      size_t __pos = 0;\n+      do \n+\t{\n+\t  {\n+\t    int __ti = 0;\n+\t    for (;__ti < __remain &&\n+\t\t   __pos == __targets[__matches[__ti]].size(); ++__ti)\n+\t      { }\n+\t    if (__ti == __remain) \n+\t      {\n+\t\tif (__pos == 0) __remain = 0;\n+\t\treturn __s;\n+\t      }\n+\t  }\n+\t  if (__s == __end) \n+\t    __eof = true;\n+\t  bool __matched = false;\n+\t  for (int __ti = 0; __ti < __remain; ) \n+\t    {\n+\t      const __string_type& __target = __targets[__matches[__ti]];\n+\t      if (__pos < __target.size()) \n+\t\t{\n+\t\t  if (__eof || __target[__pos] != *__s)\n+\t\t    { \n+\t\t      __matches[__ti] = __matches[--__remain]; \n+\t\t      continue; \n+\t\t    }\n+\t\t  __matched = true;\n+\t\t}\n+\t      ++__ti;\n+\t    }\n+\t  if (__matched) \n+\t    { \n+\t      ++__s; \n+\t      ++__pos; \n+\t    }\n+\t  for (int __ti = 0; __ti < __remain;) \n+\t    {\n+\t      if (__pos > __targets[__matches[__ti]].size())\n+\t\t{ \n+\t\t  __matches[__ti] = __matches[--__remain]; \n+\t\t  continue; \n+\t\t}\n+\t      ++__ti;\n+\t    }\n+\t} \n+      while (__remain);\n+      return __s;\n+    }\n+  \n+  template<typename _CharT>\n+    locale::id ctype<_CharT>::id;\n+\n+  template<typename _InternT, typename _ExternT, typename _StateT>\n+    locale::id codecvt<_InternT,_ExternT,_StateT>::id;\n+\n+  template<typename _CharT>\n+    int _Format_cache<_CharT>::_S_pword_ix;\n+\n+  template<typename _CharT>\n+    const char _Format_cache<_CharT>::\n+    _S_literals[] = \"-+xX0123456789abcdef0123456789ABCDEF\";\n+\n+  template<typename _CharT>\n+    _Format_cache<_CharT>::_Format_cache()\n+    : _M_valid(true), _M_use_grouping(false)\n+    { }\n+\n+  template<>\n+    _Format_cache<char>::_Format_cache()\n+    : _M_valid(true), \n+    _M_decimal_point('.'), _M_thousands_sep(','), \n+    _M_truename(\"true\"), _M_falsename(\"false\"), _M_use_grouping(false)\n+    { }\n+ \n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  template<>\n+    _Format_cache<wchar_t>::_Format_cache()\n+    : _M_valid(true), \n+    _M_decimal_point(L'.'), _M_thousands_sep(L','), \n+    _M_truename(L\"true\"), _M_falsename(L\"false\"), _M_use_grouping(false)\n+    { }\n+#endif\n+\n+  template<typename _CharT>\n+    void\n+    _Format_cache<_CharT>::_M_populate(ios_base& __io)\n+    {\n+      locale __loc = __io.getloc ();\n+      numpunct<_CharT> const& __np = use_facet<numpunct<_CharT> >(__loc);\n+      _M_truename = __np.truename();\n+      _M_falsename = __np.falsename();\n+      _M_thousands_sep = __np.thousands_sep();\n+      _M_decimal_point = __np.decimal_point();\n+      _M_grouping = __np.grouping();\n+      _M_use_grouping = _M_grouping.size() != 0 && _M_grouping.data()[0] != 0;\n+      _M_valid = true;\n+    }\n+\n+  // This function is always called via a pointer installed in\n+  // an ios_base by ios_base::register_callback.\n+  template<typename _CharT>\n+    void\n+    _Format_cache<_CharT>::\n+    _S_callback(ios_base::event __ev, ios_base& __ios, int __ix) throw()\n+    {\n+      void*& __p = __ios.pword(__ix);\n+      switch (__ev)\n+\t{\n+\tcase ios_base::erase_event:\n+\t  delete static_cast<_Format_cache<_CharT>*> (__p); __p = 0;   \n+\t  break;\n+\tcase ios_base::copyfmt_event:\n+\t  // If just stored zero, the callback would get registered again.\n+\t  try { \n+\t    __p = new _Format_cache<_CharT>; \n+\t  } \n+\t  catch(...) { \n+\t  }      \n+\t  break;\n+\tcase ios_base::imbue_event:\n+\t  static_cast<_Format_cache<_CharT>*>(__p)->_M_valid = false; \n+\t  break;\n+\t}\n+    }\n+  \n+  template<typename _CharT>\n+    _Format_cache<_CharT>*\n+    _Format_cache<_CharT>::_S_get(ios_base& __ios)\n+    {\n+      if (!_S_pword_ix) \n+\t_S_pword_ix = ios_base::xalloc();  // XXX MT\n+      void*& __p = __ios.pword(_S_pword_ix);\n+      \n+      // XXX What if pword fails? must check failbit, throw.\n+      if (__p == 0)  // XXX MT?  maybe sentry takes care of it\n+\t{\n+\t  auto_ptr<_Format_cache<_CharT> > __ap(new _Format_cache<_CharT>);\n+\t  __ios.register_callback(&_Format_cache<_CharT>::_S_callback,\n+\t\t\t\t  _S_pword_ix);\n+\t  __p = __ap.release();\n+\t}\n+      _Format_cache<_CharT>* __ncp = static_cast<_Format_cache<_CharT>*>(__p);\n+      if (!__ncp->_M_valid) \n+\t__ncp->_M_populate(__ios);\n+      \n+      return __ncp;\n+    }\n+\n+  template<typename _CharT, typename _InIter>\n+    locale::id num_get<_CharT, _InIter>::id;\n+\n+  // This member function takes an (w)istreambuf_iterator object and\n+  // parses it into a generic char array suitable for parsing with\n+  // strto[l,ll,f,d]. The thought was to encapsulate the conversion\n+  // into this one function, and thus the num_get::do_get member\n+  // functions can just adjust for the type of the overloaded\n+  // argument and process the char array returned from _M_extract.\n+  // Other things were also considered, including a fused\n+  // multiply-add loop that would obviate the need for any call to\n+  // strto... at all: however, it would b e a bit of a pain, because\n+  // you'd have to be able to return either floating or integral\n+  // types, etc etc. The current approach seems to be smack dab in\n+  // the middle between an unoptimized approach using sscanf, and\n+  // some kind of hyper-optimized approach alluded to above.\n+  \n+  // XXX\n+  // Need to do partial specialization to account for differences\n+  // between character sets. For char, this is pretty\n+  // straightforward, but for wchar_t, the conversion to a plain-jane\n+  // char type is a bit more involved.\n+  template<typename _CharT, typename _InIter>\n+    void\n+    num_get<_CharT, _InIter>::    \n+    _M_extract(iter_type /*__beg*/, iter_type /*__end*/, ios_base& /*__io*/, \n+\t       ios_base::iostate& /*__err*/, char* /*__xtrc*/,\n+               int& /*__base*/, bool /*__fp*/) const\n+    {\n+      // XXX Not currently done: need to expand upon char version below.\n+    }\n+\n+  template<>\n+    void\n+    num_get<char, istreambuf_iterator<char> >::    \n+    _M_extract(istreambuf_iterator<char> __beg, \n+\t       istreambuf_iterator<char> __end, ios_base& __io, \n+\t       ios_base::iostate& __err, char* __xtrc, \n+\t       int& __base, bool __fp) const\n+    {\n+      typedef _Format_cache<char> __cache_type;\n+\n+      // Stage 1: determine a conversion specifier.\n+      ios_base::fmtflags __basefield = __io.flags() & ios_base::basefield;\n+      if (__basefield == ios_base::oct)\n+\t__base = 8;\n+      else if (__basefield == ios_base::hex)\n+\t__base = 16;\n+      else\n+\t__base = 10;\n+      \n+      // Stage 2: extract characters.\n+      __cache_type const* __fmt = __cache_type::_S_get(__io);\n+      bool __valid = __beg != __end;\n+      string __grp;\n+      int __sep_pos = 0;\n+      int __pos = 0;\n+      bool __testdec = false;\n+      const char* __lits = __fmt->_S_literals;\n+\n+      while (__valid && __beg != __end)\n+        {\n+          __valid = false;\n+          char __c = *__beg;\n+\t  char* __p = strchr(__fmt->_S_literals, __c);\n+\t  \n+\t  // NB: strchr returns true for __c == 0x0\n+\t  if (__p && __c)\n+\t    {\n+\t      if ((__p >= &__lits[__cache_type::_S_digits + __base]\n+\t\t   && __p < &__lits[__cache_type::_S_digits_end]) ||\n+\t\t  (__p >= &__lits[__cache_type::_S_udigits+__base]\n+\t\t   && __p < &__lits[__cache_type::_S_udigits_end]))\n+\t\t{\n+\t\t  if (!(__fp && (__p == &__lits[__cache_type::_S_ee] \n+\t\t\t\t  || __p == &__lits[__cache_type::_S_Ee]))) \n+\t\t    break;\n+\t\t}\n+\t      __xtrc[__pos] = __c;\n+\t      ++__pos;\n+\t      ++__sep_pos;\n+\t      __valid = true;\n+\t    }\n+          else if (__c == __fmt->_M_thousands_sep \n+\t\t   && __fmt->_M_use_grouping && !__testdec)\n+\t    {\n+\t      // NB: Thousands separator at the beginning of a string\n+\t      // is a no-no, as is two consecutive thousands\n+\t      // separators, as is thousands separator to the right of\n+\t      // a decimal point.\n+\t      if (__sep_pos && !__testdec)\n+\t\t{\n+\t\t  __grp += static_cast<char>(__sep_pos);\n+\t\t  __sep_pos = 0;\n+\t\t  __valid = true;\n+\t\t}\n+\t      else\n+\t\t__err |= ios_base::failbit;\t\t\n+\t    }\n+\t  else if (__c == __fmt->_M_decimal_point \n+\t\t   && __fp && !__testdec)\n+\t    {\n+\t      __xtrc[__pos] = '.';\n+\t      ++__pos;\n+\t      if (__fmt->_M_use_grouping && !__grp.empty())\n+\t\t{\n+\t\t  __grp += static_cast<char>(__sep_pos);\n+\t\t  __sep_pos = 0;\n+\t\t}\n+\t      __testdec = true;\n+\t      __valid = true;\n+\t    }\n+\t  if (__valid) \n+\t    ++__beg;\n+\t}\n+      __xtrc[__pos] = '\\0';\n+      if (__beg == __end)\n+\t__err |= ios_base::eofbit;\n+      \n+      // Digit grouping is checked. If _M_groupings() doesn't\n+      // match, then get very very upset, and set failbit.\n+      if (__fmt->_M_use_grouping && !__grp.empty())\n+\t{\n+\t  // Add the ending grouping if the decimal point hasn't\n+\t  // already delineated the end of the sequence that grouping\n+\t  // cares about.\n+\t  if (!__testdec)\n+\t    __grp += static_cast<char>(__sep_pos);\n+\n+\t  // __grp is parsed L to R\n+\t  // 1,222,444 == __grp of \"/1/3/3\"\n+\t  // __fmt->_M_grouping is parsed R to L\n+\t  // 1,222,444 == __fmt->_M_grouping of \"/3\" == \"/3/3/3\"\n+\t  int __i = 0;\n+\t  int __j = 0;\n+\t  const int __len = __fmt->_M_grouping.size();\n+\t  int __n = __grp.size();\n+\t  bool __test = true;\n+\n+\t  // Parsed number groupings have to match the\n+\t  // numpunct::grouping string exactly, starting at the\n+\t  // right-most point of the parsed sequence of elements ...\n+\t  while (__test && __i < __n - 1)\n+\t    for (__j = 0; __test && __j < __len && __i < __n - 1; ++__j, ++__i)\n+\t      __test &= __fmt->_M_grouping[__j] == __grp[__n - __i - 1];\n+\t  // ... but the last parsed grouping can be <= numpunct\n+\t  // grouping.\n+\t  __j == __len ? __j = 0 : __j;\n+\t  __test &= __fmt->_M_grouping[__j] >= __grp[__n - __i - 1];\n+\n+\t  if (!__test)\n+\t    __err |= ios_base::failbit;\n+\t}\n+    }\n+  \n+  // NB: This is an unresolved library defect #17\n+  // _GLIBCPP_RESOLVE_LIB_DEFECTS\n+  template<typename _CharT, typename _InIter>\n+    _InIter \n+    num_get<_CharT, _InIter>::\n+    do_get(iter_type __beg, iter_type __end, ios_base& __io, \n+\t   ios_base::iostate& __err, bool& __v) const\n+    {\n+      // Parse bool values as long\n+      if (!(__io.flags() & ios_base::boolalpha))\n+\t{\n+\t  // NB: We can't just call do_get(long) here, as it might\n+\t  // refer to a derived class.\n+\n+\t  // Stage 1: extract and determine the conversion specifier.\n+\t  // Assuming leading zeros eliminated, thus the size of 32 for\n+\t  // integral types.\n+\t  char __xtrc[32]= {'\\0'};\n+\t  int __base;\n+\t  _M_extract(__beg, __end, __io, __err, __xtrc, __base, false);\n+\t  \n+\t  // Stage 2: convert and store results.\n+\t  char* __sanity;\n+\t  errno = 0;\n+\t  long __l = strtol(__xtrc, &__sanity, __base);\n+\t  if (!(__err & ios_base::failbit)\n+\t      && __l <= 1\n+\t      && __sanity != __xtrc && *__sanity == '\\0' && errno == 0)\n+\t    __v = __l;\n+\t  else\n+\t    __err |= ios_base::failbit;\n+\t}\n+      \n+      // Parse bool values as alphanumeric\n+      else\n+\t{\n+\t  typedef _Format_cache<char_type> __fcache_type;\n+\t  __fcache_type* __fmt = __fcache_type::_S_get(__io);\n+\t  const char_type* __true = __fmt->_M_truename.c_str();\n+\t  const char_type* __false = __fmt->_M_falsename.c_str();\n+\t  const size_t __truelen =  __traits_type::length(__true) - 1;\n+\t  const size_t __falselen =  __traits_type::length(__false) - 1;\n+\n+\t  for (size_t __pos = 0; __beg != __end; ++__pos)\n+\t    {\n+\t      char_type __c = *__beg++;\n+\t      bool __testf = __c == __false[__pos];\n+\t      bool __testt = __c == __true[__pos];\n+\t      if (!(__testf || __testt))\n+\t\t{\n+\t\t  __err |= ios_base::failbit;\n+\t\t  break;\n+\t\t}\n+\t      else if (__testf && __pos == __falselen)\n+\t\t{\n+\t\t  __v = 0;\n+\t\t  break;\n+\t\t}\n+\t      else if (__testt && __pos == __truelen)\n+\t\t{\n+\t\t  __v = 1;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  if (__beg == __end)\n+\t    __err |= ios_base::eofbit;\n+\t}\n+      \n+      return __beg;\n+    }\n+  \n+#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n+  template<typename _CharT, typename _InIter>\n+    _InIter \n+    num_get<_CharT, _InIter>::\n+    do_get(iter_type __beg, iter_type __end, ios_base& __io, \n+\t   ios_base::iostate& __err, short& __v) const\n+    {\n+      // Stage 1: extract and determine the conversion specifier.\n+      // Assuming leading zeros eliminated, thus the size of 32 for\n+      // integral types.\n+      char __xtrc[32]= {'\\0'};\n+      int __base;\n+      _M_extract(__beg, __end, __io, __err, __xtrc, __base, false);\n+      \n+      // Stage 2: convert and store results.\n+      char* __sanity;\n+      errno = 0;\n+      long __l = strtol(__xtrc, &__sanity, __base);\n+      if (!(__err & ios_base::failbit)\n+\t  && __sanity != __xtrc && *__sanity == '\\0' && errno == 0\n+\t  && __l >= SHRT_MIN && __l <= SHRT_MAX) \n+\t__v = static_cast<short>(__l);\n+      else\n+\t__err |= ios_base::failbit;\n+      \n+      return __beg;\n+    }\n+\n+  template<typename _CharT, typename _InIter>\n+    _InIter \n+    num_get<_CharT, _InIter>::\n+    do_get(iter_type __beg, iter_type __end, ios_base& __io, \n+\t   ios_base::iostate& __err, int& __v) const\n+    {\n+      // Stage 1: extract and determine the conversion specifier.\n+      // Assuming leading zeros eliminated, thus the size of 32 for\n+      // integral types.\n+      char __xtrc[32] = {'\\0'};\n+      int __base;\n+      _M_extract(__beg, __end, __io, __err, __xtrc, __base, false);\n+      \n+      // Stage 2: convert and store results.\n+      char* __sanity;\n+      errno = 0;\n+      long __l = strtol(__xtrc, &__sanity, __base);\n+      if (!(__err & ios_base::failbit)\n+\t  && __sanity != __xtrc && *__sanity == '\\0' && errno == 0\n+\t  && __l >= INT_MIN && __l <= INT_MAX) \n+\t__v = static_cast<int>(__l);\n+      else\n+\t__err |= ios_base::failbit;\n+      \n+      return __beg;\n+    }\n+#endif\n+   \n+  template<typename _CharT, typename _InIter>\n+    _InIter \n+    num_get<_CharT, _InIter>::\n+    do_get(iter_type __beg, iter_type __end, ios_base& __io, \n+\t   ios_base::iostate& __err, long& __v) const\n+    {\n+      // Stage 1: extract and determine the conversion specifier.\n+      // Assuming leading zeros eliminated, thus the size of 32 for\n+      // integral types.\n+      char __xtrc[32]= {'\\0'};\n+      int __base;\n+      _M_extract(__beg, __end, __io, __err, __xtrc, __base, false);\n+      \n+      // Stage 2: convert and store results.\n+      char* __sanity;\n+      errno = 0;\n+      long __l = strtol(__xtrc, &__sanity, __base);\n+      if (!(__err & ios_base::failbit)\n+\t  && __sanity != __xtrc && *__sanity == '\\0' && errno == 0)\n+\t__v = __l;\n+      else\n+\t__err |= ios_base::failbit;\n+      \n+      return __beg;\n+    }\n+   \n+#ifdef _GLIBCPP_USE_LONG_LONG\n+  template<typename _CharT, typename _InIter>\n+    _InIter \n+    num_get<_CharT, _InIter>::\n+    do_get(iter_type __beg, iter_type __end, ios_base& __io, \n+\t   ios_base::iostate& __err, long long& __v) const\n+    {\n+      // Stage 1: extract and determine the conversion specifier.\n+      // Assuming leading zeros eliminated, thus the size of 32 for\n+      // integral types.\n+      char __xtrc[32]= {'\\0'};\n+      int __base;\n+      _M_extract(__beg, __end, __io, __err, __xtrc, __base, false);\n+      \n+      // Stage 2: convert and store results.\n+      char* __sanity;\n+      errno = 0;\n+      long long __ll = strtoll(__xtrc, &__sanity, __base);\n+      if (!(__err & ios_base::failbit)\n+\t  && __sanity != __xtrc && *__sanity == '\\0' && errno == 0)\n+\t__v = __ll;\n+      else\n+\t__err |= ios_base::failbit;\n+      \n+      return __beg;\n+    }\n+#endif\n+\n+  template<typename _CharT, typename _InIter>\n+    _InIter \n+    num_get<_CharT, _InIter>::\n+    do_get(iter_type __beg, iter_type __end, ios_base& __io, \n+\t   ios_base::iostate& __err, unsigned short& __v) const\n+    {\n+      // Stage 1: extract and determine the conversion specifier.\n+      // Assuming leading zeros eliminated, thus the size of 32 for\n+      // integral types.\n+      char __xtrc[32]= {'\\0'};\n+      int __base;\n+      _M_extract(__beg, __end, __io, __err, __xtrc, __base, false);\n+      \n+      // Stage 2: convert and store results.\n+      char* __sanity;\n+      errno = 0;\n+      unsigned long __ul = strtoul(__xtrc, &__sanity, __base);\n+      if (!(__err & ios_base::failbit)\n+\t  && __sanity != __xtrc && *__sanity == '\\0' && errno == 0\n+\t  && __ul <= USHRT_MAX) \n+\t__v = static_cast<unsigned short>(__ul);\n+      else\n+\t__err |= ios_base::failbit;\n+      \n+      return __beg;\n+    }\n+\n+  template<typename _CharT, typename _InIter>\n+    _InIter \n+    num_get<_CharT, _InIter>::\n+    do_get(iter_type __beg, iter_type __end, ios_base& __io, \n+\t   ios_base::iostate& __err, unsigned int& __v) const\n+    {\n+      // Stage 1: extract and determine the conversion specifier.\n+      // Assuming leading zeros eliminated, thus the size of 32 for\n+      // integral types.\n+      char __xtrc[32]= {'\\0'};\n+      int __base;\n+      _M_extract(__beg, __end, __io, __err, __xtrc, __base, false);\n+      \n+      // Stage 2: convert and store results.\n+      char* __sanity;\n+      errno = 0;\n+      unsigned long __ul = strtoul(__xtrc, &__sanity, __base);\n+      if (!(__err & ios_base::failbit)\n+\t  && __sanity != __xtrc && *__sanity == '\\0' && errno == 0\n+\t  && __ul <= UINT_MAX) \n+\t__v = static_cast<unsigned int>(__ul);\n+      else\n+\t__err |= ios_base::failbit;\n+      \n+      return __beg;\n+    }\n+\n+  template<typename _CharT, typename _InIter>\n+    _InIter \n+    num_get<_CharT, _InIter>::\n+    do_get(iter_type __beg, iter_type __end, ios_base& __io, \n+\t   ios_base::iostate& __err, unsigned long& __v) const\n+    {\n+      // Stage 1: extract and determine the conversion specifier.\n+      // Assuming leading zeros eliminated, thus the size of 32 for\n+      // integral types.\n+      char __xtrc[32] = {'\\0'};\n+      int __base;\n+      _M_extract(__beg, __end, __io, __err, __xtrc, __base, false);\n+      \n+      // Stage 2: convert and store results.\n+      char* __sanity;\n+      errno = 0;\n+      unsigned long __ul = strtoul(__xtrc, &__sanity, __base);\n+      if (!(__err & ios_base::failbit)\n+\t  && __sanity != __xtrc && *__sanity == '\\0' && errno == 0)\n+\t__v = __ul;\n+      else\n+\t__err |= ios_base::failbit;\n+      \n+      return __beg;\n+    }\n+\n+#ifdef _GLIBCPP_USE_LONG_LONG\n+  template<typename _CharT, typename _InIter>\n+    _InIter \n+    num_get<_CharT, _InIter>::\n+    do_get(iter_type __beg, iter_type __end, ios_base& __io, \n+\t   ios_base::iostate& __err, unsigned long long& __v) const\n+    {\n+      // Stage 1: extract and determine the conversion specifier.\n+      // Assuming leading zeros eliminated, thus the size of 32 for\n+      // integral types.\n+      char __xtrc[32]= {'\\0'};\n+      int __base;\n+      _M_extract(__beg, __end, __io, __err, __xtrc, __base, false);\n+      \n+      // Stage 2: convert and store results.\n+      char* __sanity;\n+      errno = 0;\n+      unsigned long long __ull = strtoull(__xtrc, &__sanity, __base);\n+      if (!(__err & ios_base::failbit)\n+\t  && __sanity != __xtrc && *__sanity == '\\0' && errno == 0)\n+\t__v = __ull;\n+      else\n+\t__err |= ios_base::failbit;\n+      \n+      return __beg;\n+    }\n+#endif\n+\n+  template<typename _CharT, typename _InIter>\n+    _InIter \n+    num_get<_CharT, _InIter>::\n+    do_get(iter_type __beg, iter_type __end, ios_base& __io, \n+\t   ios_base::iostate& __err, float& __v) const\n+    {\n+      // Stage 1: extract and determine the conversion specifier.\n+      // Assuming leading zeros eliminated, thus the size of 256 for\n+      // floating-point types.\n+      char __xtrc[32]= {'\\0'};\n+      int __base;\n+      _M_extract(__beg, __end, __io, __err, __xtrc, __base, true);\n+      \n+      // Stage 2: convert and store results.\n+      char* __sanity;\n+      errno = 0;\n+#ifdef _GLIBCPP_HAVE_STRTOF\n+      float __f = strtof(__xtrc, &__sanity);\n+#else\n+      float __f = static_cast<float>(strtod(__xtrc, &__sanity));\n+#endif\n+      if (!(__err & ios_base::failbit)\n+\t  && __sanity != __xtrc && *__sanity == '\\0' && errno == 0)\n+\t__v = __f;\n+      else\n+\t__err |= ios_base::failbit;\n+      \n+      return __beg;\n+    }\n+\n+  template<typename _CharT, typename _InIter>\n+    _InIter \n+    num_get<_CharT, _InIter>::\n+    do_get(iter_type __beg, iter_type __end, ios_base& __io, \n+\t   ios_base::iostate& __err, double& __v) const\n+    {\n+      // Stage 1: extract and determine the conversion specifier.\n+      // Assuming leading zeros eliminated, thus the size of 256 for\n+      // floating-point types.\n+      char __xtrc[32]= {'\\0'};\n+      int __base;\n+      _M_extract(__beg, __end, __io, __err, __xtrc, __base, true);\n+      \n+      // Stage 2: convert and store results.\n+      char* __sanity;\n+      errno = 0;\n+      double __d = strtod(__xtrc, &__sanity);\n+      if (!(__err & ios_base::failbit)\n+\t  && __sanity != __xtrc && *__sanity == '\\0' && errno == 0)\n+\t__v = __d;\n+      else\n+\t__err |= ios_base::failbit;\n+      \n+      return __beg;\n+    }\n+\n+#if defined(_GLIBCPP_HAVE_STRTOLD) && !defined(__hpux)\n+  template<typename _CharT, typename _InIter>\n+    _InIter \n+    num_get<_CharT, _InIter>::\n+    do_get(iter_type __beg, iter_type __end, ios_base& __io, \n+\t   ios_base::iostate& __err, long double& __v) const\n+    {\n+      // Stage 1: extract and determine the conversion specifier.\n+      // Assuming leading zeros eliminated, thus the size of 256 for\n+      // floating-point types.\n+      char __xtrc[32]= {'\\0'};\n+      int __base;\n+      _M_extract(__beg, __end, __io, __err, __xtrc, __base, true);\n+      \n+      // Stage 2: convert and store results.\n+      char* __sanity;\n+      errno = 0;\n+      long double __ld = strtold(__xtrc, &__sanity);\n+      if (!(__err & ios_base::failbit)\n+\t  && __sanity != __xtrc && *__sanity == '\\0' && errno == 0)\n+\t__v = __ld;\n+      else\n+\t__err |= ios_base::failbit;\n+      \n+      return __beg;\n+    }\n+#else\n+  template<typename _CharT, typename _InIter>\n+    _InIter \n+    num_get<_CharT, _InIter>::\n+    do_get(iter_type __beg, iter_type __end, ios_base& __io, \n+\t   ios_base::iostate& __err, long double& __v) const\n+    {\n+      // Stage 1: extract\n+      char __xtrc[32]= {'\\0'};\n+      int __base;\n+      _M_extract(__beg, __end, __io, __err, __xtrc, __base, true);\n+\n+      // Stage 2: determine a conversion specifier.\n+      ios_base::fmtflags __basefield = __io.flags() & ios_base::basefield;\n+      const char* __conv;\n+      if (__basefield == ios_base::oct)\n+\t__conv = \"%Lo\";\n+      else if (__basefield == ios_base::hex)\n+\t__conv = \"%LX\";\n+      else if (__basefield == 0)\n+\t__conv = \"%Li\";\n+      else\n+\t__conv = \"%Lg\";\n+\n+      // Stage 3: store results.\n+      long double __ld;\n+      int __p = sscanf(__xtrc, __conv, &__ld);\n+      if (__p \n+\t  && static_cast<__traits_type::int_type>(__p) != __traits_type::eof())\n+\t__v = __ld;\n+      else\n+\t__err |= ios_base::failbit;\n+      \n+      return __beg;\n+    }\n+#endif\n+\n+  template<typename _CharT, typename _InIter>\n+    _InIter \n+    num_get<_CharT, _InIter>::\n+    do_get(iter_type __beg, iter_type __end, ios_base& __io, \n+\t   ios_base::iostate& __err, void*& __v) const\n+    {\n+      // Prepare for hex formatted input\n+      typedef ios_base::fmtflags \tfmtflags;\n+      fmtflags __fmt = __io.flags();\n+      fmtflags __fmtmask = ~(ios_base::showpos | ios_base::basefield \n+\t\t\t     | ios_base::uppercase | ios_base::internal);\n+      __io.flags(__fmt & __fmtmask | (ios_base::hex | ios_base::showbase));\n+\n+      // Stage 1: extract and determine the conversion specifier.\n+      // Assuming leading zeros eliminated, thus the size of 32 for\n+      // integral types.\n+      char __xtrc[32]= {'\\0'};\n+      int __base;\n+      _M_extract(__beg, __end, __io, __err, __xtrc, __base, false);\n+      \n+      // Stage 2: convert and store results.\n+      char* __sanity;\n+      errno = 0;\n+      void* __vp = reinterpret_cast<void*>(strtoul(__xtrc, &__sanity, __base));\n+      if (!(__err & ios_base::failbit)\n+\t  && __sanity != __xtrc && *__sanity == '\\0' && errno == 0)\n+\t__v = __vp;\n+      else\n+\t__err |= ios_base::failbit;\n+      \n+      // Reset from hex formatted input\n+      __io.flags(__fmt);\n+      return __beg;\n+    }\n+\n+  template <typename _CharT, typename _OutIter>\n+    locale::id num_put<_CharT, _OutIter>::id;\n+\n+  // _S_fill is specialized for ostreambuf_iterator, random access iterator.\n+  template <typename _CharT, typename _OutIter>\n+    inline _OutIter\n+    _S_fill(_OutIter __s, _CharT __fill, int __padding);\n+\n+  template <typename _CharT, typename _RaIter>\n+    _RaIter\n+    _S_fill(_RaIter __s, _CharT __fill, int __padding,\n+            random_access_iterator_tag)\n+    {\n+      fill_n(__s, __fill);\n+      return __s + __padding;\n+    }\n+\n+  template <typename _CharT, typename _OutIter, typename _Tag>\n+    _OutIter\n+    _S_fill(_OutIter __s, _CharT __fill, int __padding, _Tag)\n+    {\n+      while (--__padding >= 0) { *__s = __fill; ++__s; }\n+      return __s;\n+    }\n+\n+  template <typename _CharT, typename _OutIter>\n+    inline _OutIter\n+    _S_fill(_OutIter __s, _CharT __fill, int __padding)\n+    {\n+      return _S_fill(__s, __fill, __padding,\n+\t\t     iterator_traits<_OutIter>::iterator_category());\n+    }\n+\n+  template <typename _CharT, typename _OutIter>\n+    _OutIter\n+    _S_pad_numeric(_OutIter __s, ios_base::fmtflags __flags,\n+                   _CharT __fill, int __width, _CharT const* __first,\n+                   _CharT const* __middle, _CharT const* __last)\n+    {\n+      int __padding = __width - (__last - __first);\n+      if (__padding < 0) \n+\t__padding = 0;\n+      ios_base::fmtflags __aflags = __flags & ios_base::adjustfield;\n+      bool __testfield = __padding == 0 || __aflags == ios_base::left \n+\t\t\t || __aflags == ios_base::internal;\n+\n+      // This was needlessly complicated.\n+      if (__first != __middle)\n+\t{\n+\t  if (!__testfield)\n+\t    {\n+\t      _S_fill(__s, __fill, __padding);\n+\t      __padding = 0;\n+\t    }\n+\t  copy(__first, __middle, __s);\n+\t}\n+      _OutIter __s2 = __s;\n+\n+      if (__padding && __aflags != ios_base::left) \n+\t{\n+\t  _S_fill(__s2, __fill, __padding);\n+\t  __padding = 0;\n+\t}\n+      _OutIter __s3 = copy(__middle, __last, __s2);\n+      if (__padding)\n+\t_S_fill(__s3, __fill, __padding);\n+      return __s3;\n+    }\n+\n+  template <typename _CharT, typename _OutIter>\n+    _OutIter \n+    num_put<_CharT, _OutIter>::\n+    do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const\n+    {\n+      const _Format_cache<_CharT>* __fmt = _Format_cache<_CharT>::_S_get(__io);\n+      ios_base::fmtflags __flags = __io.flags();\n+\n+      if ((__flags & ios_base::boolalpha) == 0)\n+\t{\n+\t  unsigned long __uv = __v;\n+\t  return _S_format(__s, __io, __fill, false, __uv);\n+\t}\n+      else\n+\t{\n+\t  const char_type* __first;\n+\t  const char_type* __last;\n+\t  if (__v)\n+\t    {\n+\t      __first = __fmt->_M_truename.data();\n+\t      __last = __first + __fmt->_M_truename.size();\n+\t    }\n+\t  else\n+\t    {\n+\t      __first = __fmt->_M_falsename.data();\n+\t      __last = __first + __fmt->_M_falsename.size();\n+\t    }\n+\t  copy(__first, __last, __s);\n+\t}\n+      return __s;\n+    }\n+\n+  // _S_group_digits inserts \"group separator\" characters into an array \n+  // of characters.  It's recursive, one iteration per group.  It moves\n+  // the characters in the buffer this way: \"xxxx12345\" -> \"12,345xxx\".\n+  // Call this only with __grouping != __grend.\n+  template <typename _CharT>\n+    _CharT*\n+    _S_group_digits(_CharT* __s, _CharT __grsep,  char const* __grouping, \n+\t\t    char const* __grend, _CharT const* __first, \n+\t\t    _CharT const* __last)\n+    {\n+      if (__last - __first > *__grouping) \n+\t{\n+\t  __s = _S_group_digits(__s,  __grsep, \n+              (__grouping + 1 == __grend ? __grouping : __grouping + 1),\n+\t      __grend, __first, __last - *__grouping);\n+\t  __first = __last - *__grouping;\n+\t  *__s++ = __grsep;\n+\t}\n+      do \n+\t{\n+\t  *__s++ = *__first++;\n+\t} \n+      while (__first != __last);\n+      return __s;\n+    }\n+\n+  template <typename _CharT, typename _OutIter, typename _ValueT>\n+    _OutIter\n+    _S_format(_OutIter __s, ios_base& __io, _CharT __fill, bool __neg,\n+\t      _ValueT __v)\n+    {\n+      // Leave room for \"+/-,\" \"0x,\" and commas.\n+      const long _M_room = numeric_limits<_ValueT>::digits10 * 2 + 4;\n+      _CharT __digits[_M_room];\n+      _CharT* __front = __digits + _M_room;\n+      ios_base::fmtflags __flags = __io.flags();\n+      const _Format_cache<_CharT>* __fmt = _Format_cache<_CharT>::_S_get(__io);\n+      char const* __table = __fmt->_S_literals + __fmt->_S_digits;\n+\n+      ios_base::fmtflags __basefield = (__flags & __io.basefield);\n+      _CharT* __sign_end = __front;\n+      if (__basefield == ios_base::hex) \n+\t{\n+\t  if (__flags & ios_base::uppercase) \n+\t    __table += 16;  // use ABCDEF\n+\t  do \n+\t    *--__front = __table[__v & 15];\n+\t  while ((__v >>= 4) != 0);\n+\t  __sign_end = __front;\n+\t  if (__flags & ios_base::showbase) \n+\t    {\n+\t      *--__front = __fmt->_S_literals[__fmt->_S_ecks +\n+                       ((__flags & ios_base::uppercase) ? 1 : 0)];\n+\t      *--__front = __table[0];\n+\t    }\n+\t} \n+      else if (__basefield == ios_base::oct) \n+\t{\n+\t  do \n+\t    *--__front = __table[__v & 7];\n+\t  while ((__v >>= 3) != 0);\n+\t  if (__flags & ios_base::showbase \n+\t      && static_cast<char>(*__front) != __table[0])\n+\t    *--__front = __table[0];\n+\t  __sign_end = __front;\n+\t} \n+      else \n+\t{\n+\t  // NB: This is _lots_ faster than using ldiv.\n+\t  do \n+\t    *--__front = __table[__v % 10];\n+\t  while ((__v /= 10) != 0);\n+\t  __sign_end = __front;\n+\t  // NB: ios_base:hex || ios_base::oct assumed to be unsigned.\n+\t  if (__neg || (__flags & ios_base::showpos))\n+\t    *--__front = __fmt->_S_literals[__fmt->_S_plus - __neg];\n+\t}\n+\n+      // XXX should specialize!\n+      if (!__fmt->_M_use_grouping && !__io.width())\n+\treturn copy(__front, __digits + _M_room, __s);  \n+\n+      if (!__fmt->_M_use_grouping)\n+\treturn _S_pad_numeric(__s, __flags, __fill, __io.width(0),\n+\t\t\t      __front, __sign_end, __digits + _M_room);\n+\n+      _CharT* __p = __digits;\n+      while (__front < __sign_end)\n+\t*__p++ = *__front++;\n+      const char* __gr = __fmt->_M_grouping.data();\n+      __front = _S_group_digits(__p, __fmt->_M_thousands_sep, __gr, \n+        __gr + __fmt->_M_grouping.size(), __sign_end, __digits + _M_room);\n+      return _S_pad_numeric(__s, __flags, __fill, __io.width(0),\n+\t\t\t    __digits, __p, __front);\n+    }\n+\n+  template <typename _CharT, typename _OutIter>\n+    _OutIter \n+    num_put<_CharT, _OutIter>::\n+    do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const\n+    {\n+      unsigned long __uv = __v;\n+      bool __neg = false;\n+      if (__v < 0) \n+\t{ \n+\t  __neg = true; \n+\t  __uv = -__uv; \n+\t}\n+      return _S_format(__s, __io, __fill, __neg, __uv);\n+    }\n+\n+  template <typename _CharT, typename _OutIter>\n+    _OutIter \n+    num_put<_CharT, _OutIter>::\n+    do_put(iter_type __s, ios_base& __io, char_type __fill, \n+\t   unsigned long __v) const\n+    { return _S_format(__s, __io, __fill, false, __v); }\n+\n+#ifdef _GLIBCPP_USE_LONG_LONG \n+  template <typename _CharT, typename _OutIter>\n+    _OutIter \n+    num_put<_CharT, _OutIter>::\n+    do_put(iter_type __s, ios_base& __b, char_type __fill, long long __v) const\n+    {\n+      unsigned long long __uv = __v;\n+      bool __neg = false;\n+      if (__v < 0) \n+\t{ \n+\t  __neg = true; \n+\t  __uv = -__uv; \n+\t}\n+      return _S_format(__s, __b, __fill, __neg, __uv);\n+    }\n+\n+  template <typename _CharT, typename _OutIter>\n+    _OutIter \n+    num_put<_CharT, _OutIter>::\n+    do_put(iter_type __s, ios_base& __io, char_type __fill, \n+\t   unsigned long long __v) const\n+    { return _S_format(__s, __io, __fill, false, __v); }\n+#endif\n+\n+  // The following code uses sprintf() to convert floating point\n+  // values for insertion into a stream. The current implementation\n+  // replicates the code in _S_pad_numeric() (in _S_output_float()) in\n+  // order to prevent having to create a \"wide\" buffer in addition to\n+  // the \"narrow\" buffer passed to sprintf(). An optimization would be\n+  // to replace sprintf() with code that works directly on a wide\n+  // buffer and then use _S_pad_numeric() to do the padding. It would\n+  // be good to replace sprintf() anyway to avoid accidental buffer\n+  // overruns and to gain back the efficiency that C++ provides by\n+  // knowing up front the type of the values to insert. This\n+  // implementation follows the C++ standard fairly directly as\n+  // outlined in 22.2.2.2 [lib.locale.num.put]\n+  bool\n+  _S_build_float_format(ios_base& __io, char* __fptr, char __modifier, \n+\t\t\tstreamsize __prec)\n+  {\n+    bool __incl_prec = false;\n+    ios_base::fmtflags __flags = __io.flags();\n+    *__fptr++ = '%';\n+    // [22.2.2.2.2] Table 60 \n+    if (__flags & ios_base::showpos)  \n+      *__fptr++ = '+';\n+    if (__flags & ios_base::showpoint)\n+      *__fptr++ = '#';\n+    // As per [22.2.2.2.2.11] \n+    if (__flags & ios_base::fixed || __prec > 0) \n+      {\n+\t*__fptr++ = '.';\n+\t*__fptr++ = '*';\n+\t__incl_prec = true;\n+      }\n+    if (__modifier)\n+      *__fptr++ = __modifier;\n+    ios_base::fmtflags __fltfield = __flags & ios_base::floatfield;\n+    // [22.2.2.2.2] Table 58\n+    if (__fltfield == ios_base::fixed)  \n+      *__fptr++ = 'f';\n+    else if (__fltfield == ios_base::scientific)\n+      *__fptr++ = (__flags & ios_base::uppercase) ? 'E' : 'e';\n+    else\n+      *__fptr++ = (__flags & ios_base::uppercase) ? 'G' : 'g';\n+    *__fptr = '\\0';\n+    return __incl_prec;\n+  }\n+\n+  template<typename _CharT,typename _OutIter>\n+    _OutIter\n+    _S_output_float(_OutIter __s, ios_base& __io,_CharT __fill, \n+                    const char* __sptr, size_t __slen)\n+    {\n+      size_t __padding = __io.width() > streamsize(__slen) ?\n+\t\t\t __io.width() -__slen : 0;\n+      locale __loc = __io.getloc();\n+      ctype<_CharT> const& __ct = use_facet<ctype<_CharT> >(__loc);\n+      ios_base::fmtflags __adjfield = __io.flags() & ios_base::adjustfield;\n+      const char* const __eptr = __sptr + __slen;\n+      // [22.2.2.2.2.19] Table 61\n+      if (__adjfield == ios_base::internal)  \n+       {\n+\t // [22.2.2.2.2.14]; widen()\n+         if (__sptr < __eptr && (*__sptr == '+' || *__sptr == '-'))\n+\t   {\n+\t     __s = __ct.widen(*__sptr);\n+\t     ++__s;\n+\t     ++__sptr; \n+\t   }\n+         __s = _S_fill(__s, __fill, __padding);\n+\t __padding = 0;\n+       }\n+      else if (__adjfield != ios_base::left)\n+\t{\n+\t  __s = _S_fill(__s, __fill, __padding);\n+\t  __padding = 0;\n+\t}\n+      // the \"C\" locale decimal character\n+      char __decimal_point = *(localeconv()->decimal_point);  \n+      const _Format_cache<_CharT>* __fmt = _Format_cache<_CharT>::_S_get(__io);\n+      for (; __sptr != __eptr; ++__s, ++__sptr)\n+       {\n+         // [22.2.2.2.2.17]; decimal point conversion \n+         if (*__sptr == __decimal_point) \n+\t   __s = __fmt->_M_decimal_point;\n+\t // [22.2.2.2.2.14]; widen()\n+         else\n+           __s = __ct.widen(*__sptr); \n+       }\n+      // [22.2.2.2.2.19] Table 61\n+      if (__padding)\n+\t_S_fill(__s, __fill, __padding); \n+      __io.width(0);\n+      return __s;\n+    }\n+\n+  template <typename _CharT, typename _OutIter>\n+    _OutIter\n+    num_put<_CharT, _OutIter>::\n+    do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const\n+    {\n+      const streamsize __max_prec = numeric_limits<double>::digits10 + 3;\n+      streamsize __prec = __io.precision();\n+      // Protect against sprintf() buffer overflows.\n+      if (__prec > __max_prec) \n+\t__prec = __max_prec;\n+      // The *2 provides for signs, exp, 'E', and pad.\n+      char __sbuf[__max_prec*2]; \n+      size_t __slen;\n+      // Long enough for the max format spec. \n+      char __fbuf[16];  \n+      if (_S_build_float_format(__io, __fbuf, 0, __prec))\n+\t__slen = sprintf(__sbuf, __fbuf, __prec, __v);\n+      else\n+\t__slen = sprintf(__sbuf, __fbuf, __v);\n+      // [22.2.2.2.2] Stages 2-4.\n+      return _S_output_float(__s, __io, __fill, __sbuf, __slen);\n+    }\n+\n+  template <typename _CharT, typename _OutIter>\n+    _OutIter\n+    num_put<_CharT, _OutIter>::\n+    do_put(iter_type __s, ios_base& __io, char_type __fill,\n+\t   long double __v) const\n+    {\n+      const streamsize __max_prec = numeric_limits<long double>::digits10 + 3;\n+      streamsize __prec = __io.precision();\n+      // Protect against sprintf() buffer overflows.\n+      if (__prec > __max_prec) \n+\t__prec = __max_prec;\n+      // The *2 provides for signs, exp, 'E', and pad.\n+      char __sbuf[__max_prec*2]; \n+      size_t __slen;\n+      // Long enough for the max format spec.\n+      char __fbuf[16];  \n+      // 'L' as per [22.2.2.2.2] Table 59\n+      if ( _S_build_float_format(__io, __fbuf, 'L', __prec)) \n+\t__slen = sprintf(__sbuf, __fbuf, __prec, __v);\n+      else\n+\t__slen = sprintf(__sbuf, __fbuf, __v);\n+      // [22.2.2.2.2] Stages 2-4\n+      return _S_output_float(__s, __io, __fill, __sbuf, __slen);\n+    }\n+\n+  template <typename _CharT, typename _OutIter>\n+    _OutIter \n+    num_put<_CharT, _OutIter>::\n+    do_put(iter_type __s, ios_base& __io, char_type __fill,\n+\t   const void* __v) const\n+    {\n+      typedef ios_base::fmtflags \tfmtflags;\n+      fmtflags __fmt = __io.flags();\n+      fmtflags __fmtmask = ~(ios_base::showpos | ios_base::basefield \n+\t\t\t     | ios_base::uppercase | ios_base::internal);\n+      __io.flags(__fmt & __fmtmask | (ios_base::hex | ios_base::showbase));\n+      try {\n+\t_OutIter __s2 = _S_format(__s, __io, __fill, false, \n+\t\t\t\t  reinterpret_cast<unsigned long>(__v));\n+\t__io.flags(__fmt);\n+\treturn __s2;\n+      } \n+      catch (...) {\n+\t__io.flags(__fmt); \n+\tthrow;\n+      }\n+    }\n+\n+  template<typename _CharT>\n+    locale::id numpunct<_CharT>::id;\n+\n+  template<typename _CharT>\n+    locale::id collate<_CharT>::id;\n+\n+  // Support for time_get:\n+  // Note that these partial specializations could, and maybe should,\n+  // be changed to full specializations (by eliminating the _Dummy\n+  // argument) and moved to a .cc file.\n+  template<typename _CharT, typename _Dummy = int>\n+    struct _Weekdaynames;\n+\n+  template<typename _Dummy>\n+    struct _Weekdaynames<char, _Dummy>\n+    { static const char* const _S_names[14]; };\n+\n+  template<typename _Dummy>\n+    const char* const\n+    _Weekdaynames<char,_Dummy>::_S_names[14] = \n+    { \n+      \"Sun\", \"Sunday\",\n+      \"Mon\", \"Monday\",   \"Tue\", \"Tuesday\", \"Wed\", \"Wednesday\",\n+      \"Thu\", \"Thursday\", \"Fri\", \"Friday\",  \"Sat\", \"Saturday\"\n+    };\n+\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  template<typename _Dummy>\n+    struct _Weekdaynames<wchar_t,_Dummy>\n+    { static const wchar_t* const _S_names[14]; };\n+\n+  template<typename _Dummy>\n+    const wchar_t* const\n+    _Weekdaynames<wchar_t,_Dummy>::_S_names[14] = \n+    { \n+      L\"Sun\", L\"Sunday\",\n+      L\"Mon\", L\"Monday\",   L\"Tue\", L\"Tuesday\", L\"Wed\", L\"Wednesday\",\n+      L\"Thu\", L\"Thursday\", L\"Fri\", L\"Friday\",  L\"Sat\", L\"Saturday\"\n+    };\n+#endif\n+\n+  template<typename _CharT, typename _Dummy = int>\n+    struct _Monthnames;\n+\n+  template<typename _Dummy>\n+    struct _Monthnames<char,_Dummy>\n+    { static const char* const _S_names[24]; };\n+\n+  template<typename _Dummy>\n+    const char* const\n+    _Monthnames<char,_Dummy>::_S_names[24] = \n+    {\n+      \"Jan\", \"January\", \"Feb\", \"February\", \"Mar\", \"March\",\n+      \"Apr\", \"April\",   \"May\", \"May\",      \"Jun\", \"June\",\n+      \"Jul\", \"July\",    \"Aug\", \"August\",   \"Sep\", \"September\",\n+      \"Oct\", \"October\", \"Nov\", \"November\", \"Dec\", \"December\"\n+    };\n+\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  template<typename _Dummy>\n+    struct _Monthnames<wchar_t, _Dummy>\n+    { static const wchar_t* const _S_names[24]; };\n+\n+  template<typename _Dummy>\n+    const wchar_t* const\n+    _Monthnames<wchar_t,_Dummy>::_S_names[24] = \n+    {\n+      L\"Jan\", L\"January\", L\"Feb\", L\"February\", L\"Mar\", L\"March\",\n+      L\"Apr\", L\"April\",   L\"May\", L\"May\",      L\"Jun\", L\"June\",\n+      L\"Jul\", L\"July\",    L\"Aug\", L\"August\",   L\"Sep\", L\"September\",\n+      L\"Oct\", L\"October\", L\"Nov\", L\"November\", L\"Dec\", L\"December\"\n+    };\n+#endif\n+\n+  template<typename _CharT, typename _InIter>\n+    locale::id time_get<_CharT, _InIter>::id;\n+\n+  template<typename _CharT, typename _InIter>\n+    _InIter \n+    time_get<_CharT, _InIter>::\n+    do_get_weekday(iter_type __s, iter_type __end,\n+\t\t   ios_base& __io, ios_base::iostate& __err, tm* __t) const\n+    {\n+      if (!_M_daynames) \n+\t{\n+\t  _M_daynames = new basic_string<_CharT>[14];\n+\t  for (int __i = 0; __i < 14; ++__i)\n+\t    _M_daynames[__i] = _Weekdaynames<_CharT>::_S_names[__i];\n+\t}\n+      bool __at_eof = false;\n+      int __remain = 0;\n+      int __matches[14];\n+      iter_type __out = __match_parallel(__s, __end, 14, _M_daynames, \n+\t\t\t\t\t __matches, __remain, __at_eof);\n+      __err = ios_base::iostate(0);\n+      if (__at_eof) __err |= __io.eofbit;\n+      if (__remain == 1 ||\n+\t  __remain == 2 && (__matches[0]>>1) == (__matches[1]>>1))\n+\t__t->tm_wday = (__matches[0]>>1);\n+      else\n+\t__err |= __io.failbit;\n+      return __out;\n+    }\n+\n+  template<typename _CharT, typename _InIter>\n+    _InIter \n+    time_get<_CharT, _InIter>::\n+    do_get_monthname(iter_type __s, iter_type __end,\n+\t\t     ios_base& __io, ios_base::iostate& __err, tm* __t) const\n+    {\n+      if (!_M_monthnames) \n+\t{\n+\t  _M_monthnames = new basic_string<_CharT>[24];\n+\t  for (int __i = 0; __i < 24; ++__i)\n+\t    _M_monthnames[__i] = _Monthnames<_CharT>::_S_names[__i];\n+\t}\n+      bool __at_eof = false;\n+      int __remain = 0;\n+      int __matches[24];\n+      iter_type __out = __match_parallel( __s, __end, 24, _M_monthnames, \n+\t\t\t\t\t  __matches, __remain, __at_eof);\n+      __err = ios_base::iostate(0);\n+      if (__at_eof) __err |= __io.eofbit;\n+      if (__remain == 1 ||\n+\t  __remain == 2 && (__matches[0]>>1) == (__matches[1]>>1))\n+\t__t->tm_mon = (__matches[0]>>1);\n+      else\n+\t__err |= __io.failbit;\n+      return __out;\n+    }\n+  \n+  template<typename _CharT, typename _OutIter>\n+    locale::id time_put<_CharT, _OutIter>::id;\n+\n+  template<typename _CharT, typename _InIter>\n+    locale::id money_get<_CharT, _InIter>::id;\n+\n+  template<typename _CharT, typename _OutIter>\n+    locale::id money_put<_CharT, _OutIter>::id;\n+\n+  template<typename _CharT, bool _Intl>\n+    locale::id moneypunct<_CharT,_Intl>::id;\n+\n+  template<typename _CharT>\n+    locale::id messages<_CharT>::id;\n+\n+  template<>\n+    const ctype<char>&\n+    use_facet<const ctype<char> > (const locale& __loc)\n+    {\n+      size_t __i = ctype<char>::id._M_index;\n+      const locale::_Impl* __tmp = __loc._M_impl;\n+      return static_cast<const ctype<char>&>(* (*(__tmp->_M_facets))[__i]);\n+    }\n+\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  template<>\n+    const ctype<wchar_t>&\n+    use_facet< const ctype<wchar_t> > (const locale& __loc)\n+    {\n+      size_t __i = ctype<wchar_t>::id._M_index;\n+      const locale::_Impl* __tmp = __loc._M_impl;\n+      return static_cast<const ctype<wchar_t>&>(* (*(__tmp->_M_facets))[__i]);\n+    }\n+#endif\n+\n+} // std::\n+\n+#endif /* _CPP_BITS_LOCFACETS_TCC */\n+\n+// Local Variables:\n+// mode:c++\n+// End:\n+\n+\n+\n+\n+"}, {"sha": "7f12457c8bc252fdb4308c2ff5750a568d2897f9", "filename": "libstdc++-v3/bits/localefwd.h", "status": "added", "additions": 497, "deletions": 0, "changes": 497, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Flocalefwd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Flocalefwd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Flocalefwd.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,497 @@\n+// Locale support -*- C++ -*-\n+\n+// Copyright (C) 1997-2000 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 22.1  Locales\n+//\n+\n+#ifndef _CPP_BITS_LOCCORE_H\n+#define _CPP_BITS_LOCCORE_H\t1\n+\n+#include <bits/c++config.h>\n+#include <bits/std_climits.h>\t// For CHAR_BIT\n+#include <bits/std_string.h> \t// For string\n+#include <bits/std_cctype.h>\t// For isspace, etc.\n+\n+namespace std\n+{\n+\n+  // _Count_ones: compile-time computation of number of 1-bits in a value N\n+  // This takes only 5 (or 6) instantiations, doing recursive descent\n+  // in parallel -- ncm\n+  template<unsigned _Num, int _Shift = (sizeof(unsigned) * CHAR_BIT)/2,\n+           unsigned _Mask = (~0u >> _Shift) >\n+    struct _Count_ones;\n+\n+  template<unsigned _Num, unsigned _Mask>\n+    struct _Count_ones<_Num,0,_Mask> \n+    { static const unsigned _S_count = _Num; };\n+\n+  template<unsigned _Num, int _Shift, unsigned _Mask>\n+    struct _Count_ones \n+    {\n+      static const unsigned _S_halfcount =\n+        _Count_ones<_Num, _Shift/2, (_Mask^((~_Mask)>>(_Shift/2))) >::_S_count;\n+      static const unsigned _S_count\n+      = (_S_halfcount&_Mask) + ((_S_halfcount>>_Shift)&_Mask);\n+    };\n+\n+  // 22.1.1 Locale\n+  template<typename _Tp> class allocator;\n+  template<typename _Tp, typename _Alloc> class vector;\n+  class locale;\n+\n+  template<typename _Facet>\n+    const _Facet&  \n+    use_facet(const locale&);\n+\n+  template<typename _Facet>\n+    bool           \n+    has_facet(const locale&) throw();\n+\n+  // 22.1.3 Convenience interfaces\n+  template<typename _CharT> \n+    inline bool \n+    isspace(_CharT, const locale&);\n+\n+  template<typename _CharT> \n+    inline bool \n+    isprint(_CharT, const locale&);\n+\n+  template<typename _CharT> \n+    inline bool \n+    iscntrl(_CharT, const locale&);\n+\n+  template<typename _CharT> \n+    inline bool \n+    isupper(_CharT, const locale&);\n+\n+  template<typename _CharT> \n+    inline bool \n+    islower(_CharT, const locale&);\n+\n+  template<typename _CharT> \n+    inline bool \n+    isalpha(_CharT, const locale&);\n+\n+  template<typename _CharT> \n+    inline bool \n+    isdigit(_CharT, const locale&);\n+\n+  template<typename _CharT> \n+    inline bool \n+    ispunct(_CharT, const locale&);\n+\n+  template<typename _CharT> \n+    inline bool \n+    isxdigit(_CharT, const locale&);\n+\n+  template<typename _CharT> \n+    inline bool \n+    isalnum(_CharT, const locale&);\n+\n+  template<typename _CharT> \n+    inline bool \n+    isgraph(_CharT, const locale&);\n+\n+  template<typename _CharT> \n+    inline _CharT \n+    toupper(_CharT, const locale&);\n+\n+  template<typename _CharT> \n+    inline _CharT \n+    tolower(_CharT, const locale&);\n+\n+\n+  // 22.2.1 and 22.2.1.3 ctype\n+  class ctype_base;\n+  template<typename _CharT> \n+    class ctype;\n+  template<> class ctype<char>;\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  template<> class ctype<wchar_t>;\n+#endif\n+\n+  template<typename _CharT> \n+    class ctype_byname;\n+  // NB: Specialized for char and wchar_t in locfacets.h.\n+\n+  class codecvt_base;\n+  template<typename _InternT, typename _ExternT, typename _StateT>\n+    class codecvt;\n+  template<> class codecvt<char, char, mbstate_t>;\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  template<> class codecvt<wchar_t, char, mbstate_t>;\n+#endif\n+\n+  template<typename _InternT, typename _ExternT, typename _StateT>\n+    class codecvt_byname;\n+  template<> class codecvt_byname<char, char, mbstate_t>;\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  template<> class codecvt_byname<wchar_t, char, mbstate_t>;\n+#endif\n+\n+  // 22.2.2 and 22.2.3 numeric\n+  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >\n+    class num_get;\n+  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >\n+    class num_put;\n+  template<typename _CharT> class numpunct;\n+  template<typename _CharT> class numpunct_byname;\n+\n+  // 22.2.4 collation\n+  template<typename _CharT> \n+    class collate;\n+  template<> class collate<char>;\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  template<> class collate<wchar_t>;\n+#endif\n+  template<typename _CharT> class \n+    collate_byname;\n+\n+  // 22.2.5 date and time\n+  class time_base;\n+  template<typename _CharT, typename _InIter =  istreambuf_iterator<_CharT> >\n+    class time_get;\n+  template<typename _CharT, typename _InIter =  istreambuf_iterator<_CharT> >\n+    class time_get_byname;\n+  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >\n+    class time_put;\n+  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >\n+    class time_put_byname;\n+\n+  // 22.2.6 money\n+  class money_base;\n+  template<typename _CharT, typename _InIter =  istreambuf_iterator<_CharT> >\n+    class money_get;\n+  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >\n+    class money_put;\n+  template<typename _CharT, bool _Intl = false> \n+    class moneypunct;\n+  template<typename _CharT, bool _Intl = false> \n+    class moneypunct_byname;\n+\n+  // 22.2.7 message retrieval\n+  class messages_base;\n+  template<typename _CharT> \n+    class messages;\n+  template<typename _CharT> \n+    class messages_byname;\n+\n+\n+  // 22.1.1 Class locale\n+  class locale\n+  {\n+    // Forwrd decls and friends:\n+    class _Impl;\n+    friend _Impl;\n+\n+    template<typename _Facet>\n+      friend const _Facet& \n+      use_facet(const locale&);\n+    \n+    template<typename _Facet>\n+      friend bool \n+      has_facet(const locale&) throw();\n+ \n+  public:\n+    // Types:\n+    class facet;\n+    class id;\n+    typedef int category;\n+\n+    // Category values:\n+    // NB much depends on the order in which these appear:\n+    static const category none\t\t= 0;\n+    static const category collate  \t= 0x0100;\n+    static const category ctype \t= 0x0200;\n+    static const category monetary \t= 0x0400;\n+    static const category numeric \t= 0x0800;\n+    static const category time \t\t= 0x1000;\n+    static const category messages \t= 0x2000;\n+    static const category all \t\t= (collate | ctype | monetary |\n+\t\t\t\t \t   numeric | time  | messages);\n+\n+    // Construct/copy/destroy:\n+    inline  \n+    locale() throw();\n+\n+    inline  \n+    locale(const locale& __other) throw();\n+\n+    explicit  \n+    locale(const char* __std_name);\n+\n+    locale(const locale& __other, const char* __std_name, category __cats);\n+\n+    locale(const locale& __other, const locale& __one, category __cats);\n+\n+    template<typename _Facet>\n+      locale(const locale& __other, _Facet* __f);\n+\n+    inline  \n+    ~locale() throw();\n+\n+    const locale&  \n+    operator=(const locale& __other) throw();\n+\n+    template<typename _Facet>\n+      locale  \n+      combine(const locale& __other);\n+\n+    // Locale operations:\n+    string \n+    name() const;\n+\n+    bool \n+    operator==(const locale& __other) const throw ();\n+\n+    inline bool  \n+    operator!=(const locale& __other) const throw ()\n+    { return !(operator==(__other));  }\n+\n+    template<typename _Char, typename _Traits, typename _Alloc>\n+      bool  \n+      operator()(const basic_string<_Char,_Traits,_Alloc>& __s1,\n+\t\t const basic_string<_Char,_Traits,_Alloc>& __s2) const;\n+\n+    // Global locale objects:\n+    static locale \n+    global(const locale&);\n+\n+    static const locale& \n+    classic();\n+\n+  private:\n+    _Impl* _M_impl;  // The (shared) implementation\n+\n+    static _Impl* _S_classic; // The one true C reference locale\n+    static _Impl* _S_global;  // Current global reference locale\n+\n+    explicit \n+    locale(_Impl*) throw();\n+\n+    static inline void  \n+    _S_initialize()\n+    { if (!_S_classic) classic();  }\n+\n+    static int  \n+    _S_normalize_category(int);\n+\n+    static const int \n+    _S_num_categories = _Count_ones<all>::_S_count;\n+  };\n+\n+\n+  // locale implementation object\n+  class locale::_Impl\n+  {\n+    typedef vector<facet*, allocator<facet*> > __vec_facet;\n+    typedef vector<string, allocator<string> > __vec_string;\n+\n+    // Friends:\n+    friend class locale;\n+    friend class facet;\n+\n+    template<typename _Facet>\n+      friend const _Facet&  \n+      use_facet(const locale&);\n+\n+    template<typename _Facet>\n+      friend bool  \n+      has_facet(const locale&) throw();\n+\n+    size_t _M_num_references;\n+    __vec_facet* _M_facets;\n+    __vec_string* _M_category_names;\n+    bool _M_has_name;\n+    bool _M_cached_name_ok;\n+    string _M_cached_name;\n+\n+    inline void \n+    _M_add_reference() throw()\n+    { ++_M_num_references; }  // XXX MT\n+\n+    inline void \n+    _M_remove_reference() throw()\n+    {\n+      if (_M_num_references-- == 0)  // XXX MT\n+\t{\n+\t  try { \n+\t    delete this; \n+\t  } \n+\t  catch(...) { \n+\t  }\n+\t}\n+    }\n+\n+    _Impl(const _Impl&, size_t __refs);\n+    _Impl(const _Impl&, const string&, category, size_t __refs);\n+    _Impl(size_t __facets, size_t __refs);\n+   ~_Impl() throw();\n+\n+    void \n+    _M_replace_categories(const _Impl*, category);\n+\n+    void \n+    _M_replace_category(const _Impl*, const locale::id* const*);\n+\n+    void \n+    _M_replace_facet(const _Impl*, const locale::id*);\n+\n+    void \n+    _M_install_facet(const locale::id*, facet*);\n+\n+    template<typename _Facet>\n+      inline void \n+      _M_init_facet(_Facet* __facet)\n+      { _M_install_facet(&_Facet::id, __facet);  }\n+\n+    void \n+    _M_construct_collate(const char*);\n+\n+    void \n+    _M_construct_ctype(const char*);\n+\n+    void \n+    _M_construct_monetary(const char*);\n+\n+    void \n+    _M_construct_numeric(const char*);\n+\n+    void \n+    _M_construct_time(const char*);\n+\n+    void \n+    _M_construct_messages(const char*);\n+\n+    category \n+    _M_normalize_category_names(const string&, category __cats);\n+\n+    static const locale::id* const _S_id_collate[];\n+    static const locale::id* const _S_id_ctype[];\n+    static const locale::id* const _S_id_monetary[];\n+    static const locale::id* const _S_id_numeric[];\n+    static const locale::id* const _S_id_time[];\n+    static const locale::id* const _S_id_messages[];\n+    static const locale::id* const* const _S_facet_categories[];\n+  };\n+\n+  // class locale inlines, that need declaration of locale::_Imp\n+  locale::locale() throw()\n+  { \n+    _S_initialize(); \n+    (_M_impl = _S_global)->_M_add_reference(); \n+  } // XXX MT\n+\n+  locale::locale(const locale& __other) throw()\n+  { (_M_impl = __other._M_impl)->_M_add_reference(); }\n+\n+  template<typename _Facet>\n+    locale::locale(const locale& __other, _Facet* __f)\n+    {\n+      _M_impl = new _Impl(*__other._M_impl, 0);\n+      _M_impl->_M_install_facet(&_Facet::id, __f);\n+      _M_impl->_M_has_name = false;\n+    }\n+\n+  locale::~locale() throw()\n+  { _M_impl->_M_remove_reference(); }\n+\n+  // 22.1.1.1.2  Class locale::facet\n+  class locale::facet\n+  {\n+    friend class locale;\n+    friend class locale::_Impl;\n+\n+  protected:\n+    explicit \n+    facet(size_t __refs = 0) throw();\n+\n+    virtual \n+    ~facet() {};\n+\n+  private:\n+    size_t _M_num_references;\n+\n+    void \n+    _M_add_reference() throw();\n+\n+    void \n+    _M_remove_reference() throw();\n+\n+    facet(const facet&);  // not defined\n+\n+    void \n+    operator=(const facet&);  // not defined\n+  };\n+\n+\n+  // 22.1.1.1.3 Class locale::id\n+  class locale::id\n+  {\n+    friend class locale;\n+    friend class locale::_Impl;\n+    template<typename _Facet>\n+      friend const _Facet&  \n+      use_facet(const locale&);\n+    template<typename _Facet>\n+      friend bool           \n+      has_facet(const locale&) throw ();\n+  public:\n+    id() {};\n+  private:\n+    // NB: there is no accessor for _M_index because it may be used\n+    // before the constructor is run; the effect of calling a member\n+    // function (even an inline) would be undefined.\n+    mutable size_t _M_index;\n+    static size_t _S_highwater;   // last id number assigned\n+\n+    void \n+    operator=(const id&);  // not defined\n+\n+    id(const id&);  // not defined\n+  };\n+\n+  template<typename _Facet>\n+    const _Facet&\n+    use_facet(const locale& __loc);\n+\n+  template<typename _Facet>\n+    bool\n+    has_facet(const locale& __loc) throw();\n+\n+} // namespace std\n+\n+#endif\t/* _CPP_BITS_LOCCORE_H */\n+\n+// Local Variables:\n+// mode:c++\n+// End:\n+"}, {"sha": "5654a2fc09c2e4bd094d6c9b75f659301987c0a5", "filename": "libstdc++-v3/bits/mask_array.h", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fmask_array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fmask_array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fmask_array.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,160 @@\n+// The template and inlines for the -*- C++ -*- mask_array class.\n+\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// Written by Gabriel Dos Reis <Gabriel.Dos-Reis@DPTMaths.ENS-Cachan.Fr>\n+\n+#ifndef _CPP_BITS_MASK_ARRAY_H\n+#define _CPP_BITS_MASK_ARRAY_H 1\n+\n+namespace std {\n+\n+    template <class _Tp> class mask_array\n+    { \n+    public:\n+        typedef _Tp value_type;\n+    \n+        void operator=  (const valarray<_Tp>&) const;\n+        void operator*= (const valarray<_Tp>&) const;\n+        void operator/= (const valarray<_Tp>&) const;\n+        void operator%= (const valarray<_Tp>&) const;\n+        void operator+= (const valarray<_Tp>&) const; \n+        void operator-= (const valarray<_Tp>&) const;\n+        void operator^= (const valarray<_Tp>&) const;  \n+        void operator&= (const valarray<_Tp>&) const;\n+        void operator|= (const valarray<_Tp>&) const;\n+        void operator<<=(const valarray<_Tp>&) const;  \n+        void operator>>=(const valarray<_Tp>&) const; \n+        void operator= (const _Tp&);\n+    \n+        //        ~mask_array ();\n+        \n+        template<class _Dom>\n+        void operator=  (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator*= (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator/= (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator%= (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator+= (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator-= (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator^= (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator&= (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator|= (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator<<=(const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator>>=(const _Expr<_Dom,_Tp>&) const; \n+\n+    private:\n+        mask_array (_Array<_Tp>, size_t, _Array<bool>);\n+        friend class valarray<_Tp>;\n+        \n+        const size_t       _M_sz;\n+        const _Array<bool> _M_mask;\n+        const _Array<_Tp>   _M_array;\n+        \n+        mask_array (const mask_array&);\n+        \n+        // not implemented\n+        mask_array ();\n+        mask_array& operator= (const mask_array&);\n+    };\n+\n+\n+    template<typename _Tp>\n+    inline mask_array<_Tp>::mask_array (const mask_array<_Tp>& a)\n+            : _M_sz (a._M_sz), _M_mask (a._M_mask), _M_array (a._M_array) {}\n+\n+    template<typename _Tp>\n+    inline \n+    mask_array<_Tp>::mask_array (_Array<_Tp> __a, size_t __s, _Array<bool> __m)\n+            : _M_sz (__s), _M_mask (__m), _M_array (__a) {}\n+    \n+    //    template<typename _Tp>\n+    //    inline mask_array<_Tp>::~mask_array () {}\n+    \n+    template<typename _Tp>\n+    inline void\n+    mask_array<_Tp>::operator= (const _Tp& __t)\n+    { __valarray_fill (_M_array, _M_sz, _M_mask, __t); }\n+    \n+    template<typename _Tp>\n+    inline void\n+    mask_array<_Tp>::operator= (const valarray<_Tp>& __v) const\n+    { __valarray_copy (_Array<_Tp> (__v), __v.size (), _M_array, _M_mask); }\n+\n+    template<typename _Tp>\n+    template<class E>\n+    inline void\n+    mask_array<_Tp>::operator= (const _Expr<E, _Tp>& __e) const\n+    { __valarray_copy (__e, __e.size (), _M_array, _M_mask); }\n+\n+#undef _DEFINE_VALARRAY_OPERATOR\n+#define _DEFINE_VALARRAY_OPERATOR(op, name)\t\t\t\t\\\n+template<typename _Tp>\t\t\t\t\t\t\t\\\n+inline void\t\t\t\t\t\t\t\t\\\n+mask_array<_Tp>::operator##op##= (const valarray<_Tp>& __v) const\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  _Array_augmented_##name (_M_array, _M_mask, \t\t\t\t\\\n+                           _Array<_Tp> (__v), __v.size ());\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+template<typename _Tp> template<class E>\t\t\t\t\\\n+inline void\t\t\t\t\t\t\t\t\\\n+mask_array<_Tp>::operator##op##= (const _Expr<E, _Tp>& __e) const\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  _Array_augmented_##name (_M_array, _M_mask, __e, __e.size ());\t\\\n+}\n+\n+_DEFINE_VALARRAY_OPERATOR(*, multiplies)\n+_DEFINE_VALARRAY_OPERATOR(/, divides)\n+_DEFINE_VALARRAY_OPERATOR(%, modulus)\n+_DEFINE_VALARRAY_OPERATOR(+, plus)\n+_DEFINE_VALARRAY_OPERATOR(-, minus)\n+_DEFINE_VALARRAY_OPERATOR(^, xor)\n+_DEFINE_VALARRAY_OPERATOR(&, and)\n+_DEFINE_VALARRAY_OPERATOR(|, or)\n+_DEFINE_VALARRAY_OPERATOR(<<, shift_left)\n+_DEFINE_VALARRAY_OPERATOR(>>, shift_right)\n+\n+#undef _DEFINE_VALARRAY_OPERATOR    \n+    \n+} // std::\n+\n+#endif /* _CPP_BITS_MASK_ARRAY_H */\n+\n+// Local Variables:\n+// mode:c++\n+// End:"}, {"sha": "2ac775351512c9290454a2ecdeaf9ee92c7d0206", "filename": "libstdc++-v3/bits/ostream.tcc", "status": "added", "additions": 673, "deletions": 0, "changes": 673, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fostream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fostream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fostream.tcc?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,673 @@\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 27.6.2  Output streams\n+//\n+\n+#include <bits/std_locale.h>\n+\n+namespace std {\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_ostream<_CharT, _Traits>::sentry::\n+    sentry(basic_ostream<_CharT,_Traits>& __os)\n+    : _M_ok(__os.good()), _M_os(__os)\n+    {\n+      // XXX MT \n+      if (_M_ok && __os.tie())\n+\t  __os.tie()->flush();  \n+    }\n+  \n+  template<typename _CharT, typename _Traits>\n+    basic_ostream<_CharT, _Traits>& \n+    basic_ostream<_CharT, _Traits>::\n+    operator<<(__ostream_type& (*__pf)(__ostream_type&))\n+    {\n+      sentry __cerb(*this);\n+      if (__cerb)\n+\t{ \n+\t  try {\n+\t      __pf(*this);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.2.5.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t\tthrow;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+  \n+  template<typename _CharT, typename _Traits>\n+    basic_ostream<_CharT, _Traits>& \n+    basic_ostream<_CharT, _Traits>::\n+    operator<<(__ios_type& (*__pf)(__ios_type&))\n+    {\n+      sentry __cerb(*this);\n+      if (__cerb)\n+\t{ \n+\t  try {\n+\t      __pf(*this);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.2.5.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t\tthrow;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_ostream<_CharT, _Traits>& \n+    basic_ostream<_CharT, _Traits>::\n+    operator<<(ios_base& (*__pf)(ios_base&))\n+    {\n+      sentry __cerb(*this);\n+      if (__cerb)\n+\t{ \n+\t  try {\n+\t      __pf(*this);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.2.5.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t\tthrow;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_ostream<_CharT, _Traits>& \n+    basic_ostream<_CharT, _Traits>::operator<<(bool __n)\n+    {\n+      sentry __cerb(*this);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    if (_M_fnumput->put(*this, *this, this->fill(), __n).failed())\n+\t      this->setstate(ios_base::badbit);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_ostream<_CharT, _Traits>& \n+    basic_ostream<_CharT, _Traits>::operator<<(long __n)\n+    {\n+      sentry __cerb(*this);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    bool __f;\n+\t    ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;\n+\t    if (__fmt & ios_base::oct || __fmt & ios_base::hex)\n+\t      __f = _M_fnumput->put(*this, *this, this->fill(), \n+\t\t\t\t    static_cast<unsigned long>(__n)).failed();\n+\t    else\n+\t      __f = _M_fnumput->put(*this, *this, this->fill(), __n).failed();\n+\n+\t    if (__f)  \n+\t      this->setstate(ios_base::badbit);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_ostream<_CharT, _Traits>& \n+    basic_ostream<_CharT, _Traits>::operator<<(unsigned long __n)\n+    {\n+      sentry __cerb(*this);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    if (_M_fnumput->put(*this, *this, this->fill(), __n).failed())\n+\t      this->setstate(ios_base::badbit);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+\n+#ifdef _GLIBCPP_USE_LONG_LONG\n+  template<typename _CharT, typename _Traits>\n+    basic_ostream<_CharT, _Traits>& \n+    basic_ostream<_CharT, _Traits>::operator<<(long long __n)\n+    {\n+      sentry __cerb(*this);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    bool __f;\n+\t    ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;\n+\t    if (__fmt & ios_base::oct || __fmt & ios_base::hex)\n+\t      __f = _M_fnumput->put(*this, *this, this->fill(), \n+\t\t\t\t    static_cast<unsigned long long>(__n)).failed();\n+\t    else\n+\t      __f = _M_fnumput->put(*this, *this, this->fill(), __n).failed();\n+\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_ostream<_CharT, _Traits>& \n+    basic_ostream<_CharT, _Traits>::operator<<(unsigned long long __n)\n+    {\n+      sentry __cerb(*this);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    if (_M_fnumput->put(*this, *this, this->fill(), __n).failed())\n+\t      this->setstate(ios_base::badbit);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+#endif\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_ostream<_CharT, _Traits>& \n+    basic_ostream<_CharT, _Traits>::operator<<(double __n)\n+    {\n+      sentry __cerb(*this);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    if (_M_fnumput->put(*this, *this, this->fill(), __n).failed())\n+\t      this->setstate(ios_base::badbit);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_ostream<_CharT, _Traits>& \n+    basic_ostream<_CharT, _Traits>::operator<<(long double __n)\n+    {\n+      sentry __cerb(*this);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    if (_M_fnumput->put(*this, *this, this->fill(), __n).failed())\n+\t      this->setstate(ios_base::badbit);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_ostream<_CharT, _Traits>& \n+    basic_ostream<_CharT, _Traits>::operator<<(const void* __n)\n+    {\n+      sentry __cerb(*this);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    if (_M_fnumput->put(*this, *this, this->fill(), __n).failed())\n+\t      this->setstate(ios_base::badbit);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_ostream<_CharT, _Traits>& \n+    basic_ostream<_CharT, _Traits>::operator<<(__streambuf_type* __sbin)\n+    {\n+      streamsize __xtrct = 0;\n+      __streambuf_type* __sbout = this->rdbuf();\n+      sentry __cerb(*this);\n+      if (__sbin && __cerb)\n+\t__xtrct = _S_copy_streambufs(*this, __sbin, __sbout);\n+      if (!__sbin || !__xtrct)\n+\tthis->setstate(ios_base::failbit);\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_ostream<_CharT, _Traits>&\n+    basic_ostream<_CharT, _Traits>::put(char_type __c)\n+    { \n+      sentry __cerb(*this);\n+      if (__cerb) \n+\t{\n+\t  int_type __put = rdbuf()->sputc(__c); \n+\t  if (__put != traits_type::to_int_type(__c))\n+\t    this->setstate(ios_base::badbit);\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_ostream<_CharT, _Traits>&\n+    basic_ostream<_CharT, _Traits>::write(const _CharT* __s, streamsize __n)\n+    {\n+      sentry __cerb(*this);\n+      if (__cerb)\n+\t{\n+\t  streamsize __put = this->rdbuf()->sputn(__s, __n);\n+\t  if ( __put != __n)\n+\t    this->setstate(ios_base::badbit);\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_ostream<_CharT, _Traits>&\n+    basic_ostream<_CharT, _Traits>::flush()\n+    {\n+      sentry __cerb(*this);\n+      if (__cerb) \n+\t{\n+\t  if (this->rdbuf() && this->rdbuf()->pubsync() == -1)\n+\t    this->setstate(ios_base::badbit);\n+\t}\n+      return *this;\n+    }\n+  \n+  template<typename _CharT, typename _Traits>\n+    typename basic_ostream<_CharT, _Traits>::pos_type\n+    basic_ostream<_CharT, _Traits>::tellp()\n+    {\n+      pos_type __retval = pos_type(-1);\n+      bool __testok = this->fail() != true;\n+      \n+      if (__testok)\n+\t__retval = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);\n+      return __retval;\n+    }\n+\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_ostream<_CharT, _Traits>&\n+    basic_ostream<_CharT, _Traits>::seekp(pos_type __pos)\n+    {\n+      bool __testok = this->fail() != true;\n+      \n+      if (__testok)\n+#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n+// 136.  seekp, seekg setting wrong streams?\n+\tthis->rdbuf()->pubseekpos(__pos, ios_base::out);\n+#endif\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_ostream<_CharT, _Traits>&\n+    basic_ostream<_CharT, _Traits>::\n+    seekp(off_type __off, ios_base::seekdir __d)\n+    {\n+      bool __testok = this->fail() != true;\n+      \n+      if (__testok)\n+#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n+// 136.  seekp, seekg setting wrong streams?\n+\trdbuf()->pubseekoff(__off, __d, ios_base::out);\n+#endif\n+      return *this;\n+    }\n+\n+  // 27.6.2.5.4 Character inserters\n+\n+  // Construct correctly padded string, as per 22.2.2.2.2\n+  // Similar in theory to _S_pad_numeric, from num_put, but it doesn't\n+  // use _S_fill: perhaps it should.\n+  // Assumes \n+  // __newlen > __oldlen\n+  // __news is allocated for __newlen size\n+  template<typename _CharT, typename _Traits>\n+    static void\n+    _S_pad_char(basic_ios<_CharT, _Traits>& __ios, \n+\t\t_CharT* __news, const _CharT* __olds,\n+\t\tconst streamsize __newlen, const streamsize __oldlen)\n+    {\n+      typedef _CharT\tchar_type;\n+      typedef _Traits\ttraits_type;\n+      typedef typename traits_type::int_type int_type;\n+      \n+      int_type __plen = static_cast<size_t>(__newlen - __oldlen); \n+      char_type __pads[__plen];\n+      traits_type::assign(__pads, __plen, __ios.fill()); \n+\n+      char_type* __beg;\n+      char_type* __end;\n+      size_t __mod = 0;\n+      size_t __beglen; //either __plen or __oldlen\n+      ios_base::fmtflags __fmt = __ios.flags() & ios_base::adjustfield;\n+\n+      if (__fmt == ios_base::left)\n+\t{\n+\t  // Padding last.\n+\t  __beg = const_cast<char_type*>(__olds);\n+\t  __beglen = __oldlen;\n+\t  __end = __pads;\n+\t}\n+      else if (__fmt == ios_base::internal)\n+\t{\n+\t  // Pad after the sign, if there is one.\n+\t  // Pad after 0[xX], if there is one.\n+\t  // Who came up with these rules, anyway? Jeeze.\n+\t  typedef _Format_cache<_CharT> __cache_type;\n+\t  __cache_type const* __fmt = __cache_type::_S_get(__ios);\n+\t  const char_type* __minus = traits_type::find(__olds, __oldlen, \n+\t\t\t\t\t\t       __fmt->_S_minus);\n+\t  const char_type* __plus = traits_type::find(__olds, __oldlen, \n+\t\t\t\t\t\t      __fmt->_S_plus);\n+\t  bool __testsign = __minus || __plus;\n+\t  bool __testhex = __olds[0] == '0' \n+\t    \t\t   && (__olds[1] == 'x' || __olds[1] == 'X');\n+\n+\t  if (__testhex)\n+\t    {\n+\t      __news[0] = __olds[0]; \n+\t      __news[1] = __olds[1];\n+\t      __mod += 2;\n+\t      __beg = const_cast<char_type*>(__olds + __mod);\n+\t      __beglen = __oldlen - __mod;\n+\t      __end = __pads;\n+\t    }\n+\t  else if (__testsign)\n+\t    {\n+\t      __mod += __plen;\n+\t      const char_type* __sign = __minus ? __minus + 1: __plus + 1;\n+\t      __beg = const_cast<char_type*>(__olds);\n+\t      __beglen = __sign - __olds;\n+\t      __end = const_cast<char_type*>(__sign + __plen);\n+\t      traits_type::copy(__news + __beglen, __pads, __plen);\n+\t    }\n+\t  else\n+\t    {\n+\t      // Padding first.\n+\t      __beg = __pads;\n+\t      __beglen = __plen;\n+\t      __end = const_cast<char_type*>(__olds);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  // Padding first.\n+\t  __beg = __pads;\n+\t  __beglen = __plen;\n+\t  __end = const_cast<char_type*>(__olds);\n+\t}\n+\n+      traits_type::copy(__news, __beg, __beglen);\n+      traits_type::copy(__news + __beglen, __end, __newlen - __beglen - __mod);\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_ostream<_CharT, _Traits>&\n+    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)\n+    {\n+      typedef basic_ostream<_CharT, _Traits> __ostream_type;\n+      __ostream_type::sentry __cerb(__out);\n+      if (__cerb)\n+\t{\n+\t  try {\n+\t    streamsize __w = __out.width();\n+\t    _CharT __pads[__w];\n+\t    __pads[0] = __c;\n+\t    streamsize __len = 1;\n+\t    if (__w > __len)\n+\t      {\n+\t\t_S_pad_char(__out, __pads, &__c, __w, __len);\n+\t\t__len = __w;\n+\t      }\n+\t    __out.write(__pads, __len);\n+\t    __out.width(0);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    __out.setstate(ios_base::badbit);\n+\t    if ((__out.exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return __out;\n+    }\n+\n+  // Specialization\n+  template <class _Traits> \n+    basic_ostream<char, _Traits>&\n+    operator<<(basic_ostream<char, _Traits>& __out, char __c)\n+    {\n+      typedef basic_ostream<char, _Traits> __ostream_type;\n+      __ostream_type::sentry __cerb(__out);\n+      if (__cerb)\n+\t{\n+\t  try {\n+\t    streamsize __w = __out.width();\n+\t    char __pads[__w + 1];\n+\t    __pads[0] = __c;\n+\t    streamsize __len = 1;\n+\t    if (__w > __len)\n+\t      {\n+\t\t_S_pad_char(__out, __pads, &__c, __w, __len);\n+\t\t__len = __w;\n+\t      }\n+\t    __out.write(__pads, __len);\n+\t    __out.width(0);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    __out.setstate(ios_base::badbit);\n+\t    if ((__out.exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return __out;\n+     }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_ostream<_CharT, _Traits>&\n+    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)\n+    {\n+      typedef basic_ostream<_CharT, _Traits> __ostream_type;\n+      __ostream_type::sentry __cerb(__out);\n+      if (__cerb)\n+\t{\n+\t  try {\n+\t    streamsize __w = __out.width();\n+\t    _CharT __pads[__w];\n+\t    streamsize __len = static_cast<streamsize>(_Traits::length(__s));\n+\t    if (__w > __len)\n+\t      {\n+\t\t_S_pad_char(__out, __pads, __s, __w, __len);\n+\t\t__s = __pads;\n+\t\t__len = __w;\n+\t      }\n+\t    __out.write(__s, __len);\n+\t    __out.width(0);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    __out.setstate(ios_base::badbit);\n+\t    if ((__out.exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return __out;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_ostream<_CharT, _Traits>&\n+    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* /*__s*/)\n+    {\n+#if 0\n+      typedef basic_ostream<_CharT, _Traits>   \t\t__ostream_type;\n+      typedef typename _Traits::state_type              __state_type;\n+      typedef codecvt<char, _CharT, __state_type>       __codecvt_type;\n+      typedef typename __ostream_type::char_type\t__char_type;\n+\n+      __ostream_type::sentry __cerb(__out);\n+      if (__cerb)\n+\t{\n+\t  const __codecvt_type* __fcvt = &use_facet<__codecvt_type>(__out.getloc());\n+\t  try {\n+\t    streamsize __n = char_traits<char>::length(__s);\n+\t    __char_type __conv[__n];\n+\t    __state_type __state_cur;\n+\t    __char_type __pbuf[__n];\t      \n+\t    __char_type* __pend;\n+\t    char* __send;\n+\t    __fcvt->out(__state_cur, \n+\t\t\t__pbuf, __pbuf + __n,\n+\t\t\tconst_cast<const __char_type*&>(__pend),\n+\t\t\tconst_cast<char*>(__s), \n+\t\t\tconst_cast<char*>(__s + __n),\n+\t\t\t__send);\n+\t    __out.write(__pbuf, __n);\n+\t  }\n+#endif\n+\t  return __out;\n+\t}\n+\n+  // Partial specializationss\n+  template<class _Traits>\n+    basic_ostream<char, _Traits>&\n+    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)\n+    {\n+      typedef basic_ostream<char, _Traits> __ostream_type;\n+      __ostream_type::sentry __cerb(__out);\n+      if (__cerb)\n+\t{\n+\t  try {\n+\t    streamsize __w = __out.width();\n+\t    char __pads[__w];\n+\t    streamsize __len = static_cast<streamsize>(_Traits::length(__s));\n+\t    if (__w > __len)\n+\t      {\n+\t\t_S_pad_char(__out, __pads, __s, __w, __len);\n+\t\t__s = __pads;\n+\t\t__len = __w;\n+\t      }\n+\t    __out.write(__s, __len);\n+\t    __out.width(0);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    __out.setstate(ios_base::badbit);\n+\t    if ((__out.exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return __out;\n+    }\n+\n+  // 21.3.7.8 basic_string::operator<<\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    basic_ostream<_CharT, _Traits>&\n+    operator<<(basic_ostream<_CharT, _Traits>& __out,\n+\t       const basic_string<_CharT, _Traits, _Alloc>& __s)\n+    { return (__out << __s.c_str()); }\n+\n+} // namespace std\n+ \n+// Local Variables:\n+// mode:C++\n+// End:\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+"}, {"sha": "3b63127ced7f3e483fba550d9dee51e66302ab27", "filename": "libstdc++-v3/bits/pthread_allocimpl.h", "status": "added", "additions": 495, "deletions": 0, "changes": 495, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fpthread_allocimpl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fpthread_allocimpl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fpthread_allocimpl.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,495 @@\n+/*\n+ * Copyright (c) 1996\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef _CPP_BITS_PTHREAD_ALLOCIMPL_H\n+#define _CPP_BITS_PTHREAD_ALLOCIMPL_H 1\n+\n+// Pthread-specific node allocator.\n+// This is similar to the default allocator, except that free-list\n+// information is kept separately for each thread, avoiding locking.\n+// This should be reasonably fast even in the presence of threads.\n+// The down side is that storage may not be well-utilized.\n+// It is not an error to allocate memory in thread A and deallocate\n+// it in thread B.  But this effectively transfers ownership of the memory,\n+// so that it can only be reallocated by thread B.  Thus this can effectively\n+// result in a storage leak if it's done on a regular basis.\n+// It can also result in frequent sharing of\n+// cache lines among processors, with potentially serious performance\n+// consequences.\n+\n+#include <bits/std_cerrno.h>\n+#include <bits/stl_config.h>\n+#include <bits/stl_alloc.h>\n+#ifndef __RESTRICT\n+#  define __RESTRICT\n+#endif\n+\n+#ifndef __STL_NO_BAD_ALLOC\n+#  include <bits/std_new.h>\n+#endif\n+\n+__STL_BEGIN_NAMESPACE\n+\n+#define __STL_DATA_ALIGNMENT 8\n+\n+union _Pthread_alloc_obj {\n+    union _Pthread_alloc_obj * __free_list_link;\n+    char __client_data[__STL_DATA_ALIGNMENT];    /* The client sees this.    */\n+};\n+\n+// Pthread allocators don't appear to the client to have meaningful\n+// instances.  We do in fact need to associate some state with each\n+// thread.  That state is represented by\n+// _Pthread_alloc_per_thread_state<_Max_size>.\n+\n+template<size_t _Max_size>\n+struct _Pthread_alloc_per_thread_state {\n+  typedef _Pthread_alloc_obj __obj;\n+  enum { _S_NFREELISTS = _Max_size/__STL_DATA_ALIGNMENT };\n+  _Pthread_alloc_obj* volatile __free_list[_S_NFREELISTS]; \n+  _Pthread_alloc_per_thread_state<_Max_size> * __next; \n+\t// Free list link for list of available per thread structures.\n+  \t// When one of these becomes available for reuse due to thread\n+\t// termination, any objects in its free list remain associated\n+\t// with it.  The whole structure may then be used by a newly\n+\t// created thread.\n+  _Pthread_alloc_per_thread_state() : __next(0)\n+  {\n+    memset((void *)__free_list, 0, (size_t) _S_NFREELISTS * sizeof(__obj *));\n+  }\n+  // Returns an object of size __n, and possibly adds to size n free list.\n+  void *_M_refill(size_t __n);\n+};\n+\n+// Pthread-specific allocator.\n+// The argument specifies the largest object size allocated from per-thread\n+// free lists.  Larger objects are allocated using malloc_alloc.\n+// Max_size must be a power of 2.\n+template <size_t _Max_size = 128>\n+class _Pthread_alloc_template {\n+\n+public: // but only for internal use:\n+\n+  typedef _Pthread_alloc_obj __obj;\n+\n+  // Allocates a chunk for nobjs of size size.  nobjs may be reduced\n+  // if it is inconvenient to allocate the requested number.\n+  static char *_S_chunk_alloc(size_t __size, int &__nobjs);\n+\n+  enum {_S_ALIGN = __STL_DATA_ALIGNMENT};\n+\n+  static size_t _S_round_up(size_t __bytes) {\n+    return (((__bytes) + (int) _S_ALIGN-1) & ~((int) _S_ALIGN - 1));\n+  }\n+  static size_t _S_freelist_index(size_t __bytes) {\n+    return (((__bytes) + (int) _S_ALIGN-1)/(int)_S_ALIGN - 1);\n+  }\n+\n+private:\n+  // Chunk allocation state. And other shared state.\n+  // Protected by _S_chunk_allocator_lock.\n+  static pthread_mutex_t _S_chunk_allocator_lock;\n+  static char *_S_start_free;\n+  static char *_S_end_free;\n+  static size_t _S_heap_size;\n+  static _Pthread_alloc_per_thread_state<_Max_size>* _S_free_per_thread_states;\n+  static pthread_key_t _S_key;\n+  static bool _S_key_initialized;\n+        // Pthread key under which per thread state is stored. \n+        // Allocator instances that are currently unclaimed by any thread.\n+  static void _S_destructor(void *instance);\n+        // Function to be called on thread exit to reclaim per thread\n+        // state.\n+  static _Pthread_alloc_per_thread_state<_Max_size> *_S_new_per_thread_state();\n+        // Return a recycled or new per thread state.\n+  static _Pthread_alloc_per_thread_state<_Max_size> *_S_get_per_thread_state();\n+        // ensure that the current thread has an associated\n+        // per thread state.\n+  class _M_lock;\n+  friend class _M_lock;\n+  class _M_lock {\n+      public:\n+        _M_lock () { pthread_mutex_lock(&_S_chunk_allocator_lock); }\n+        ~_M_lock () { pthread_mutex_unlock(&_S_chunk_allocator_lock); }\n+  };\n+\n+public:\n+\n+  /* n must be > 0      */\n+  static void * allocate(size_t __n)\n+  {\n+    __obj * volatile * __my_free_list;\n+    __obj * __RESTRICT __result;\n+    _Pthread_alloc_per_thread_state<_Max_size>* __a;\n+\n+    if (__n > _Max_size) {\n+        return(malloc_alloc::allocate(__n));\n+    }\n+    if (!_S_key_initialized ||\n+        !(__a = (_Pthread_alloc_per_thread_state<_Max_size>*)\n+                                 pthread_getspecific(_S_key))) {\n+        __a = _S_get_per_thread_state();\n+    }\n+    __my_free_list = __a -> __free_list + _S_freelist_index(__n);\n+    __result = *__my_free_list;\n+    if (__result == 0) {\n+        void *__r = __a -> _M_refill(_S_round_up(__n));\n+        return __r;\n+    }\n+    *__my_free_list = __result -> __free_list_link;\n+    return (__result);\n+  };\n+\n+  /* p may not be 0 */\n+  static void deallocate(void *__p, size_t __n)\n+  {\n+    __obj *__q = (__obj *)__p;\n+    __obj * volatile * __my_free_list;\n+    _Pthread_alloc_per_thread_state<_Max_size>* __a;\n+\n+    if (__n > _Max_size) {\n+        malloc_alloc::deallocate(__p, __n);\n+        return;\n+    }\n+    if (!_S_key_initialized ||\n+        !(__a = (_Pthread_alloc_per_thread_state<_Max_size> *)\n+                pthread_getspecific(_S_key))) {\n+        __a = _S_get_per_thread_state();\n+    }\n+    __my_free_list = __a->__free_list + _S_freelist_index(__n);\n+    __q -> __free_list_link = *__my_free_list;\n+    *__my_free_list = __q;\n+  }\n+\n+  static void * reallocate(void *__p, size_t __old_sz, size_t __new_sz);\n+\n+} ;\n+\n+typedef _Pthread_alloc_template<> pthread_alloc;\n+\n+\n+template <size_t _Max_size>\n+void _Pthread_alloc_template<_Max_size>::_S_destructor(void * __instance)\n+{\n+    _M_lock __lock_instance;\t// Need to acquire lock here.\n+    _Pthread_alloc_per_thread_state<_Max_size>* __s =\n+        (_Pthread_alloc_per_thread_state<_Max_size> *)__instance;\n+    __s -> __next = _S_free_per_thread_states;\n+    _S_free_per_thread_states = __s;\n+}\n+\n+template <size_t _Max_size>\n+_Pthread_alloc_per_thread_state<_Max_size> *\n+_Pthread_alloc_template<_Max_size>::_S_new_per_thread_state()\n+{    \n+    /* lock already held here.\t*/\n+    if (0 != _S_free_per_thread_states) {\n+        _Pthread_alloc_per_thread_state<_Max_size> *__result =\n+\t\t\t\t\t_S_free_per_thread_states;\n+        _S_free_per_thread_states = _S_free_per_thread_states -> __next;\n+        return __result;\n+    } else {\n+        return new _Pthread_alloc_per_thread_state<_Max_size>;\n+    }\n+}\n+\n+template <size_t _Max_size>\n+_Pthread_alloc_per_thread_state<_Max_size> *\n+_Pthread_alloc_template<_Max_size>::_S_get_per_thread_state()\n+{\n+    /*REFERENCED*/\n+    _M_lock __lock_instance;\t// Need to acquire lock here.\n+    int __ret_code;\n+    _Pthread_alloc_per_thread_state<_Max_size> * __result;\n+    if (!_S_key_initialized) {\n+        if (pthread_key_create(&_S_key, _S_destructor)) {\n+\t    __THROW_BAD_ALLOC;  // defined in stl_alloc.h\n+        }\n+        _S_key_initialized = true;\n+    }\n+    __result = _S_new_per_thread_state();\n+    __ret_code = pthread_setspecific(_S_key, __result);\n+    if (__ret_code) {\n+      if (__ret_code == ENOMEM) {\n+\t__THROW_BAD_ALLOC;\n+      } else {\n+\t// EINVAL\n+\tabort();\n+      }\n+    }\n+    return __result;\n+}\n+\n+/* We allocate memory in large chunks in order to avoid fragmenting     */\n+/* the malloc heap too much.                                            */\n+/* We assume that size is properly aligned.                             */\n+template <size_t _Max_size>\n+char *_Pthread_alloc_template<_Max_size>\n+::_S_chunk_alloc(size_t __size, int &__nobjs)\n+{\n+  {\n+    char * __result;\n+    size_t __total_bytes;\n+    size_t __bytes_left;\n+    /*REFERENCED*/\n+    _M_lock __lock_instance;         // Acquire lock for this routine\n+\n+    __total_bytes = __size * __nobjs;\n+    __bytes_left = _S_end_free - _S_start_free;\n+    if (__bytes_left >= __total_bytes) {\n+        __result = _S_start_free;\n+        _S_start_free += __total_bytes;\n+        return(__result);\n+    } else if (__bytes_left >= __size) {\n+        __nobjs = __bytes_left/__size;\n+        __total_bytes = __size * __nobjs;\n+        __result = _S_start_free;\n+        _S_start_free += __total_bytes;\n+        return(__result);\n+    } else {\n+        size_t __bytes_to_get =\n+\t\t2 * __total_bytes + _S_round_up(_S_heap_size >> 4);\n+        // Try to make use of the left-over piece.\n+        if (__bytes_left > 0) {\n+            _Pthread_alloc_per_thread_state<_Max_size>* __a = \n+                (_Pthread_alloc_per_thread_state<_Max_size>*)\n+\t\t\tpthread_getspecific(_S_key);\n+            __obj * volatile * __my_free_list =\n+                        __a->__free_list + _S_freelist_index(__bytes_left);\n+\n+            ((__obj *)_S_start_free) -> __free_list_link = *__my_free_list;\n+            *__my_free_list = (__obj *)_S_start_free;\n+        }\n+#       ifdef _SGI_SOURCE\n+          // Try to get memory that's aligned on something like a\n+          // cache line boundary, so as to avoid parceling out\n+          // parts of the same line to different threads and thus\n+          // possibly different processors.\n+          {\n+            const int __cache_line_size = 128;  // probable upper bound\n+            __bytes_to_get &= ~(__cache_line_size-1);\n+            _S_start_free = (char *)memalign(__cache_line_size, __bytes_to_get); \n+            if (0 == _S_start_free) {\n+              _S_start_free = (char *)malloc_alloc::allocate(__bytes_to_get);\n+            }\n+          }\n+#       else  /* !SGI_SOURCE */\n+          _S_start_free = (char *)malloc_alloc::allocate(__bytes_to_get);\n+#       endif\n+        _S_heap_size += __bytes_to_get;\n+        _S_end_free = _S_start_free + __bytes_to_get;\n+    }\n+  }\n+  // lock is released here\n+  return(_S_chunk_alloc(__size, __nobjs));\n+}\n+\n+\n+/* Returns an object of size n, and optionally adds to size n free list.*/\n+/* We assume that n is properly aligned.                                */\n+/* We hold the allocation lock.                                         */\n+template <size_t _Max_size>\n+void *_Pthread_alloc_per_thread_state<_Max_size>\n+::_M_refill(size_t __n)\n+{\n+    int __nobjs = 128;\n+    char * __chunk =\n+\t_Pthread_alloc_template<_Max_size>::_S_chunk_alloc(__n, __nobjs);\n+    __obj * volatile * __my_free_list;\n+    __obj * __result;\n+    __obj * __current_obj, * __next_obj;\n+    int __i;\n+\n+    if (1 == __nobjs)  {\n+        return(__chunk);\n+    }\n+    __my_free_list = __free_list\n+\t\t + _Pthread_alloc_template<_Max_size>::_S_freelist_index(__n);\n+\n+    /* Build free list in chunk */\n+      __result = (__obj *)__chunk;\n+      *__my_free_list = __next_obj = (__obj *)(__chunk + __n);\n+      for (__i = 1; ; __i++) {\n+        __current_obj = __next_obj;\n+        __next_obj = (__obj *)((char *)__next_obj + __n);\n+        if (__nobjs - 1 == __i) {\n+            __current_obj -> __free_list_link = 0;\n+            break;\n+        } else {\n+            __current_obj -> __free_list_link = __next_obj;\n+        }\n+      }\n+    return(__result);\n+}\n+\n+template <size_t _Max_size>\n+void *_Pthread_alloc_template<_Max_size>\n+::reallocate(void *__p, size_t __old_sz, size_t __new_sz)\n+{\n+    void * __result;\n+    size_t __copy_sz;\n+\n+    if (__old_sz > _Max_size\n+\t&& __new_sz > _Max_size) {\n+        return(realloc(__p, __new_sz));\n+    }\n+    if (_S_round_up(__old_sz) == _S_round_up(__new_sz)) return(__p);\n+    __result = allocate(__new_sz);\n+    __copy_sz = __new_sz > __old_sz? __old_sz : __new_sz;\n+    memcpy(__result, __p, __copy_sz);\n+    deallocate(__p, __old_sz);\n+    return(__result);\n+}\n+\n+template <size_t _Max_size>\n+_Pthread_alloc_per_thread_state<_Max_size> *\n+_Pthread_alloc_template<_Max_size>::_S_free_per_thread_states = 0;\n+\n+template <size_t _Max_size>\n+pthread_key_t _Pthread_alloc_template<_Max_size>::_S_key;\n+\n+template <size_t _Max_size>\n+bool _Pthread_alloc_template<_Max_size>::_S_key_initialized = false;\n+\n+template <size_t _Max_size>\n+pthread_mutex_t _Pthread_alloc_template<_Max_size>::_S_chunk_allocator_lock\n+= PTHREAD_MUTEX_INITIALIZER;\n+\n+template <size_t _Max_size>\n+char *_Pthread_alloc_template<_Max_size>\n+::_S_start_free = 0;\n+\n+template <size_t _Max_size>\n+char *_Pthread_alloc_template<_Max_size>\n+::_S_end_free = 0;\n+\n+template <size_t _Max_size>\n+size_t _Pthread_alloc_template<_Max_size>\n+::_S_heap_size = 0;\n+\n+#ifdef __STL_USE_STD_ALLOCATORS\n+\n+template <class _Tp>\n+class pthread_allocator {\n+  typedef pthread_alloc _S_Alloc;          // The underlying allocator.\n+public:\n+  typedef size_t     size_type;\n+  typedef ptrdiff_t  difference_type;\n+  typedef _Tp*       pointer;\n+  typedef const _Tp* const_pointer;\n+  typedef _Tp&       reference;\n+  typedef const _Tp& const_reference;\n+  typedef _Tp        value_type;\n+\n+  template <class _NewType> struct rebind {\n+    typedef pthread_allocator<_NewType> other;\n+  };\n+\n+  pthread_allocator() __STL_NOTHROW {}\n+  pthread_allocator(const pthread_allocator& a) __STL_NOTHROW {}\n+  template <class _OtherType>\n+\tpthread_allocator(const pthread_allocator<_OtherType>&)\n+\t\t__STL_NOTHROW {}\n+  ~pthread_allocator() __STL_NOTHROW {}\n+\n+  pointer address(reference __x) const { return &__x; }\n+  const_pointer address(const_reference __x) const { return &__x; }\n+\n+  // __n is permitted to be 0.  The C++ standard says nothing about what\n+  // the return value is when __n == 0.\n+  _Tp* allocate(size_type __n, const void* = 0) {\n+    return __n != 0 ? static_cast<_Tp*>(_S_Alloc::allocate(__n * sizeof(_Tp)))\n+                    : 0;\n+  }\n+\n+  // p is not permitted to be a null pointer.\n+  void deallocate(pointer __p, size_type __n)\n+    { _S_Alloc::deallocate(__p, __n * sizeof(_Tp)); }\n+\n+  size_type max_size() const __STL_NOTHROW \n+    { return size_t(-1) / sizeof(_Tp); }\n+\n+  void construct(pointer __p, const _Tp& __val) { new(__p) _Tp(__val); }\n+  void destroy(pointer _p) { _p->~_Tp(); }\n+};\n+\n+template<>\n+class pthread_allocator<void> {\n+public:\n+  typedef size_t      size_type;\n+  typedef ptrdiff_t   difference_type;\n+  typedef void*       pointer;\n+  typedef const void* const_pointer;\n+  typedef void        value_type;\n+\n+  template <class _NewType> struct rebind {\n+    typedef pthread_allocator<_NewType> other;\n+  };\n+};\n+\n+template <size_t _Max_size>\n+inline bool operator==(const _Pthread_alloc_template<_Max_size>&,\n+                       const _Pthread_alloc_template<_Max_size>&)\n+{\n+  return true;\n+}\n+\n+template <class _T1, class _T2>\n+inline bool operator==(const pthread_allocator<_T1>&,\n+                       const pthread_allocator<_T2>& a2) \n+{\n+  return true;\n+}\n+\n+template <class _T1, class _T2>\n+inline bool operator!=(const pthread_allocator<_T1>&,\n+                       const pthread_allocator<_T2>&)\n+{\n+  return false;\n+}\n+\n+template <class _Tp, size_t _Max_size>\n+struct _Alloc_traits<_Tp, _Pthread_alloc_template<_Max_size> >\n+{\n+  static const bool _S_instanceless = true;\n+  typedef simple_alloc<_Tp, _Pthread_alloc_template<_Max_size> > _Alloc_type;\n+  typedef __allocator<_Tp, _Pthread_alloc_template<_Max_size> > \n+          allocator_type;\n+};\n+\n+template <class _Tp, class _Atype, size_t _Max>\n+struct _Alloc_traits<_Tp, __allocator<_Atype, _Pthread_alloc_template<_Max> > >\n+{\n+  static const bool _S_instanceless = true;\n+  typedef simple_alloc<_Tp, _Pthread_alloc_template<_Max> > _Alloc_type;\n+  typedef __allocator<_Tp, _Pthread_alloc_template<_Max> > allocator_type;\n+};\n+\n+template <class _Tp, class _Atype>\n+struct _Alloc_traits<_Tp, pthread_allocator<_Atype> >\n+{\n+  static const bool _S_instanceless = true;\n+  typedef simple_alloc<_Tp, _Pthread_alloc_template<> > _Alloc_type;\n+  typedef pthread_allocator<_Tp> allocator_type;\n+};\n+\n+\n+#endif /* __STL_USE_STD_ALLOCATORS */\n+\n+__STL_END_NAMESPACE\n+\n+#endif /* _CPP_BITS_PTHREAD_ALLOCIMPL_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "a028f230023a3adaff4e57f53e355dcebe78bb71", "filename": "libstdc++-v3/bits/sbuf_iter.h", "status": "added", "additions": 264, "deletions": 0, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fsbuf_iter.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fsbuf_iter.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fsbuf_iter.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,264 @@\n+// Streambuf iterators\n+\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// XXX Should specialize copy, find algorithms for streambuf iterators.\n+\n+#ifndef _CPP_BITS_SBUF_ITER_H\n+#define _CPP_BITS_SBUF_ITER_H 1\n+\n+namespace std\n+{\n+\n+  template<typename _CharT, typename _Traits>\n+    class ostreambuf_iterator\n+#if 0      // XXX this is standard:\n+    : public iterator<output_iterator_tag,_CharT,void,void,void>\n+#else\n+    : public output_iterator\n+#endif\n+    {\n+    public:\n+\n+      // Types:\n+      typedef _CharT                       \t char_type;\n+      typedef _Traits                          traits_type;\n+      typedef basic_streambuf<_CharT, _Traits> streambuf_type;\n+      typedef basic_ostream<_CharT, _Traits>   ostream_type;\n+      \n+      inline \n+      ostreambuf_iterator(ostream_type& __s) throw ()\n+      : _M_sbuf(__s.rdbuf()), _M_failed(false) { }\n+      \n+      ostreambuf_iterator(streambuf_type* __s) throw ()\n+      : _M_sbuf(__s), _M_failed(false) { }\n+\n+      ostreambuf_iterator& \n+      operator=(_CharT __c);\n+\n+      ostreambuf_iterator& \n+      operator*() throw()\n+      { return *this; }\n+\n+      ostreambuf_iterator& \n+      operator++(int) throw()\n+      { return *this; }\n+\n+      ostreambuf_iterator& \n+      operator++() throw()\n+      { return *this; }\n+\n+      bool \n+      failed() const throw()\n+      { return _M_failed; }\n+\n+    private:\n+      streambuf_type* \t_M_sbuf;\n+      bool \t\t_M_failed;\n+\n+#if 0\n+      template<>\n+        friend char const*\n+        copy(char const* __first, char const* __last,\n+             ostreambuf_iterator<char,char_traits<char> > __to);\n+      template<>\n+        friend wchar_t const*\n+        copy(wchar_t const* __first, wchar_t const* __last,\n+             ostreambuf_iterator<wchar_t,char_traits<wchar_t> > __to);\n+#endif\n+    };\n+\n+  template<typename _CharT, typename _Traits>\n+    inline ostreambuf_iterator<_CharT, _Traits>&\n+    ostreambuf_iterator<_CharT, _Traits>::operator=(_CharT __c)\n+    {\n+      if (!_M_failed &&\n+          _Traits::eq_int_type(_M_sbuf->sputc(__c),_Traits::eof()))\n+      _M_failed = true;\n+      return *this;\n+    }\n+\n+\n+#if 0\n+  // Optimized specializations of standard algorithms\n+  // These are specialized only for standard types\n+  // (with no unbound arguments) to avoid creating\n+  // overload problems with user specializations.\n+\n+  template<>\n+    char const*\n+    copy(char const* __first, char const* __last,\n+\t ostreambuf_iterator<char,char_traits<char> > __to)\n+    {\n+      if (!__to._M_failed)\n+\t__to._M_sbuf->sputn(__first, __last-__first);\n+      return __last;\n+    }\n+\n+  template<>\n+    wchar_t const*\n+    copy(wchar_t const* __first, wchar_t const* __last,\n+\t ostreambuf_iterator<whar_t,char_traits<wchar_t> > __to)\n+    {\n+      if (!__to._M_failed)\n+\t__to._M_sbuf->sputn(__first, __last-__first);\n+      return __last;\n+    }\n+#endif\n+\n+  // 24.5.3 Template class istreambuf_iterator\n+  template<class _CharT, class _Traits>\n+    class istreambuf_iterator\n+    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,\n+    \t\t      _CharT*, _CharT&>\n+    {\n+    public:\n+\n+      // Types:\n+      typedef _CharT                         \t\tchar_type;\n+      typedef _Traits                        \t\ttraits_type;\n+      typedef typename _Traits::int_type     \t\tint_type;\n+      typedef basic_streambuf<_CharT, _Traits> \t\tstreambuf_type;\n+      typedef basic_istream<_CharT, _Traits>         \tistream_type;\n+      // Non-standard Types:\n+      typedef istreambuf_iterator<_CharT, _Traits>\t__istreambufiter_type;\n+\n+      istreambuf_iterator() throw() \n+      : _M_istreambuf(NULL), _M_c(-2) { }\n+      \n+      istreambuf_iterator(istream_type& __s) throw()\n+      : _M_istreambuf(__s.rdbuf()), _M_c(-2) { }\n+\n+      istreambuf_iterator(streambuf_type* __s) throw()\n+      : _M_istreambuf(__s), _M_c(-2) { }\n+       \n+      // NB: This should really have an int_type return\n+      // value, so \"end of stream\" postion can be checked without\n+      // hacking.\n+      char_type \n+      operator*() const\n+      { \n+\t// The result of operator*() on an end of stream is undefined.\n+\tchar_type __retval;\n+\tif (_M_istreambuf && _M_c != static_cast<int_type>(-2))\n+\t  __retval = _M_c;\n+\telse if (_M_istreambuf)\n+\t  __retval = traits_type::to_char_type(_M_istreambuf->sgetc()); \n+\telse\n+\t  __retval = static_cast<char_type>(traits_type::eof());\n+\treturn __retval;\n+      }\n+\t\n+      __istreambufiter_type& \n+      operator++()\n+      { \n+\tif (_M_istreambuf)\n+\t  _M_istreambuf->sbumpc();\n+\t_M_c = -2;\n+\treturn *this; \n+      }\n+\n+#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n+      // 14882 says return a proxy object. It should be a const\n+      // proxy object, but since this class is not mandated, it\n+      // should allow this signature:\n+      const __istreambufiter_type\n+      operator++(int)\n+      {\n+\tif (_M_istreambuf)\n+\t  _M_c = _M_istreambuf->sbumpc();\n+\treturn *this; \n+      }\n+#endif\n+\n+      bool \n+      equal(const __istreambufiter_type& __b)\n+      { \n+\tint_type __eof = traits_type::eof();\n+\tbool __thiseof = !_M_istreambuf || _M_istreambuf->sgetc() == __eof;\n+\tbool __beof = !__b._M_istreambuf \n+\t  \t      || __b._M_istreambuf->sgetc() == __eof;\n+\treturn (__thiseof && __beof || (!__thiseof && !__beof));\n+      }\n+\n+#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n+      // 110 istreambuf_iterator::equal not const\n+      // NB: there is also number 111 pending on this function.\n+      bool \n+      equal(const __istreambufiter_type& __b) const\n+      {\n+\tint_type __eof = traits_type::eof();\n+\tbool __thiseof = !_M_istreambuf || _M_istreambuf->sgetc() == __eof;\n+\tbool __beof = !__b._M_istreambuf \n+\t  \t      || __b._M_istreambuf->sgetc() == __eof;\n+\treturn (__thiseof && __beof || (!__thiseof && !__beof));\n+      }\n+#endif\n+\n+    private:\n+      // 24.5.3 istreambuf_iterator \n+      // p 1 \n+      // If the end of stream is reached (streambuf_type::sgetc()\n+      // returns traits_type::eof()), the iterator becomes equal to\n+      // the \"end of stream\" iterator value.\n+      // NB: This implementation assumes the \"end of stream\" value\n+      // is EOF, or -1.\n+      streambuf_type* \t\t_M_istreambuf;  \n+      int_type \t\t\t_M_c;\n+    };\n+\n+  template<typename _CharT, typename _Traits>\n+    inline bool \n+    operator==(const istreambuf_iterator<_CharT, _Traits>& __a,\n+\t       const istreambuf_iterator<_CharT, _Traits>& __b)\n+    { return __a.equal(__b); }\n+\n+  template<typename _CharT, typename _Traits>\n+    inline bool \n+    operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,\n+\t       const istreambuf_iterator<_CharT, _Traits>& __b)\n+    { return !__a.equal(__b); }\n+\n+} // std::\n+\n+#endif /* _CPP_BITS_SBUF_ITER_H */\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+"}, {"sha": "3e4f7a743f6dcd851c60b713d40a083d57bf6694", "filename": "libstdc++-v3/bits/slice.h", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fslice.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fslice.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fslice.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,77 @@\n+// The template and inlines for the -*- C++ -*- slice class.\n+\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// Written by Gabriel Dos Reis <Gabriel.Dos-Reis@DPTMaths.ENS-Cachan.Fr>\n+\n+#ifndef _CPP_BITS_SLICE_H\n+#define _CPP_BITS_SLICE_H\n+\n+namespace std {\n+\n+class slice\n+{\n+public:\n+    slice ();\n+    slice (size_t, size_t, size_t);\n+\n+    size_t start () const;\n+    size_t size () const;\n+    size_t stride () const;\n+\n+private:\n+    size_t _M_off;                      // offset\n+    size_t _M_sz;\t\t\t// size\n+    size_t _M_st;\t\t\t// stride unit\n+};\n+\n+inline slice::slice () {}\n+\n+inline slice::slice (size_t __o, size_t __d, size_t __s)\n+        : _M_off (__o), _M_sz (__d), _M_st (__s) {}\n+\n+inline size_t\n+slice::start () const\n+  { return _M_off; }\n+\n+inline size_t\n+slice::size () const\n+  { return _M_sz; }\n+\n+inline size_t\n+slice::stride () const\n+  { return _M_st; }\n+\n+} // std::\n+\n+\n+#endif /* _CPP_BITS_SLICE_H */\n+\n+// Local Variables:\n+// mode:c++\n+// End:"}, {"sha": "04efd5ff9d9438de810acdb14a31100c8f6bd163", "filename": "libstdc++-v3/bits/slice_array.h", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fslice_array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fslice_array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fslice_array.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,161 @@\n+// The template and inlines for the -*- C++ -*- slice_array class.\n+\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// Written by Gabriel Dos Reis <Gabriel.Dos-Reis@DPTMaths.ENS-Cachan.Fr>\n+\n+#ifndef _CPP_BITS_SLICE_ARRAY_H\n+#define _CPP_BITS_SLICE_ARRAY_H 1\n+\n+namespace std {\n+    \n+    template<typename _Tp>\n+    class slice_array\n+    {\n+    public:\n+        typedef _Tp value_type;\n+        \n+        void operator=   (const valarray<_Tp>&) const;\n+        void operator*=  (const valarray<_Tp>&) const;\n+        void operator/=  (const valarray<_Tp>&) const;\n+        void operator%=  (const valarray<_Tp>&) const;\n+        void operator+=  (const valarray<_Tp>&) const;\n+        void operator-=  (const valarray<_Tp>&) const;\n+        void operator^=  (const valarray<_Tp>&) const;\n+        void operator&=  (const valarray<_Tp>&) const;\n+        void operator|=  (const valarray<_Tp>&) const;\n+        void operator<<= (const valarray<_Tp>&) const;\n+        void operator>>= (const valarray<_Tp>&) const;\n+        void operator= (const _Tp &);\n+        //        ~slice_array ();\n+        \n+        template<class _Dom>\n+        void operator=   (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator*=  (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator/=  (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator%=  (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator+=  (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator-=  (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator^=  (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator&=  (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator|=  (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator<<= (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator>>= (const _Expr<_Dom,_Tp>&) const;\n+        \n+    private:\n+        friend class valarray<_Tp>;\n+        slice_array(_Array<_Tp>, const slice&);\n+        \n+        const size_t     _M_sz;\n+        const size_t     _M_stride;\n+        const _Array<_Tp> _M_array;\n+        \n+        // this constructor is implemented since we need to return a value.\n+        slice_array (const slice_array&);\n+\n+        // not implemented\n+        slice_array ();\n+        slice_array& operator= (const slice_array&);\n+    };\n+\n+    template<typename _Tp>\n+    inline slice_array<_Tp>::slice_array (_Array<_Tp> __a, const slice& __s)\n+            : _M_sz (__s.size ()), _M_stride (__s.stride ()),\n+              _M_array (__a.begin () + __s.start ()) {}\n+\n+    \n+    template<typename _Tp>\n+    inline slice_array<_Tp>::slice_array(const slice_array<_Tp>& a)\n+            : _M_sz(a._M_sz), _M_stride(a._M_stride), _M_array(a._M_array) {}\n+    \n+    //    template<typename _Tp>\n+    //    inline slice_array<_Tp>::~slice_array () {}\n+\n+    template<typename _Tp>\n+    inline void\n+    slice_array<_Tp>::operator= (const _Tp& __t) \n+    { __valarray_fill (_M_array, _M_sz, _M_stride, __t); }\n+    \n+    template<typename _Tp>\n+    inline void\n+    slice_array<_Tp>::operator= (const valarray<_Tp>& __v) const\n+    { __valarray_copy (_Array<_Tp> (__v), _M_array, _M_sz, _M_stride); }\n+    \n+    template<typename _Tp>\n+    template<class _Dom>\n+    inline void\n+    slice_array<_Tp>::operator= (const _Expr<_Dom,_Tp>& __e) const\n+    { __valarray_copy (__e, _M_sz, _M_array, _M_stride); }\n+\n+#undef _DEFINE_VALARRAY_OPERATOR\n+#define _DEFINE_VALARRAY_OPERATOR(op, name)\t\t\t\t\\\n+template<typename _Tp>\t\t\t\t\t\t\t\\\n+inline void\t\t\t\t\t\t\t\t\\\n+slice_array<_Tp>::operator##op##= (const valarray<_Tp>& __v) const\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  _Array_augmented_##name (_M_array, _M_sz, _M_stride, _Array<_Tp> (__v));\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+template<typename _Tp> template<class _Dom>\t\t\t\t\\\n+inline void\t\t\t\t\t\t\t\t\\\n+slice_array<_Tp>::operator##op##= (const _Expr<_Dom,_Tp>& __e) const\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+    _Array_augmented_##name (_M_array, _M_stride, __e, _M_sz);\t\t\\\n+}\n+        \n+\n+_DEFINE_VALARRAY_OPERATOR(*, multiplies)\n+_DEFINE_VALARRAY_OPERATOR(/, divides)\n+_DEFINE_VALARRAY_OPERATOR(%, modulus)\n+_DEFINE_VALARRAY_OPERATOR(+, plus)\n+_DEFINE_VALARRAY_OPERATOR(-, minus)\n+_DEFINE_VALARRAY_OPERATOR(^, xor)\n+_DEFINE_VALARRAY_OPERATOR(&, and)\n+_DEFINE_VALARRAY_OPERATOR(|, or)\n+_DEFINE_VALARRAY_OPERATOR(<<, shift_left)\n+_DEFINE_VALARRAY_OPERATOR(>>, shift_right)\n+\n+#undef _DEFINE_VALARRAY_OPERATOR\n+\n+} // std::\n+\n+#endif /* _CPP_BITS_SLICE_ARRAY_H */\n+\n+// Local Variables:\n+// mode:c++\n+// End:"}, {"sha": "6596c4b6d08a127804a67a37a30bc2491c8f8d06", "filename": "libstdc++-v3/bits/sstream.tcc", "status": "added", "additions": 221, "deletions": 0, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fsstream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fsstream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fsstream.tcc?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,221 @@\n+// String based streams -*- C++ -*-\n+\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 27.7  String-based streams\n+//\n+\n+#ifndef _CPP_BITS_SSTREAM_TCC\n+#define _CPP_BITS_SSTREAM_TCC\t1\n+\n+#include <bits/std_sstream.h>\n+\n+namespace std {\n+\n+  template <class _CharT, class _Traits, class _Alloc>\n+    basic_stringbuf<_CharT, _Traits, _Alloc>::int_type \n+    basic_stringbuf<_CharT, _Traits, _Alloc>::\n+    pbackfail(int_type __c)\n+    {\n+      int_type __retval = traits_type::eof();\n+      bool __testeof = traits_type::eq_int_type(__c, traits_type::eof());\n+      bool __testpos = _M_in_cur && _M_in_beg < _M_in_cur; \n+      \n+      // Try to put back __c into input sequence in one of three ways.\n+      // Order these tests done in is unspecified by the standard.\n+      if (!__testeof && __testpos \n+\t  && traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]))\n+\t{\n+\t  --_M_in_cur;\n+\t  __retval = __c;\n+\t}\n+      else if (!__testeof && __testpos)\n+\t{\n+\t  --_M_in_cur;\n+\t  *_M_in_cur = traits_type::to_char_type(__c);\n+\t  __retval = __c;\n+\t}\n+      else if (__testeof && __testpos)\n+\t{\n+\t  --_M_in_cur;\n+\t  __retval = traits_type::not_eof(__c);\n+\t}\n+      return __retval;\n+    }\n+  \n+  template <class _CharT, class _Traits, class _Alloc>\n+    basic_stringbuf<_CharT, _Traits, _Alloc>::int_type \n+    basic_stringbuf<_CharT, _Traits, _Alloc>::\n+    overflow(int_type __c)\n+    {\n+      int_type __retval = traits_type::eof();\n+      bool __testeof = traits_type::eq_int_type(__c, __retval);\n+      bool __testwrite = _M_out_cur < _M_buf + _M_buf_size;\n+      bool __testout = _M_mode & ios_base::out;\n+\n+      // Try to append __c into output sequence in one of two ways.\n+      // Order these tests done in is unspecified by the standard.\n+      if (__testout)\n+\t{\n+\t  if (!__testeof)\n+\t    {\n+\t      // NB: Start ostringstream buffers at 1024 bytes. This\n+\t      // is an experimental value (pronounced \"arbitrary\" in\n+\t      // some of the hipper english-speaking countries), and\n+\t      // can be changed to suite particular needs.\n+\t      __size_type __len = max(_M_buf_size, static_cast<int_type>(512));\n+\t      __len *= 2;\n+\n+\t      if (__testwrite)\n+\t\t__retval = this->sputc(__c);\n+\t      else if (__len <= _M_string.max_size())\n+\t\t{\n+\t\t  // Force-allocate, re-sync.\n+\t\t  _M_string = this->str();\n+\t\t  _M_string.reserve(__len);\n+\t\t  _M_buf_size = static_cast<int_type>(__len);\n+\t\t  _M_really_sync(_M_in_cur - _M_in_beg, \n+\t\t\t\t _M_out_cur - _M_out_beg);\n+\t\t  *_M_out_cur = traits_type::to_char_type(__c);\n+\t\t  _M_buf_bump(1);\n+\t\t  __retval = __c;\n+\t\t}\n+\t    }\n+\t  else\n+\t    __retval = traits_type::not_eof(__c);\n+\t}\n+      return __retval;\n+    }\n+\n+  template <class _CharT, class _Traits, class _Alloc>\n+    basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type\n+    basic_stringbuf<_CharT, _Traits, _Alloc>::\n+    seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode)\n+    {\n+      pos_type __retval =  pos_type(off_type(-1)); \n+      bool __testin = __mode & ios_base::in && _M_mode & ios_base::in;\n+      bool __testout = __mode & ios_base::out && _M_mode & ios_base::out;\n+      bool __testboth = __testin && __testout && __way != ios_base::cur;\n+      \n+      if (_M_buf_size && ((__testin != __testout) || __testboth))\n+\t{\n+\t  char_type* __beg = _M_buf;\n+\t  char_type* __curi = NULL;\n+\t  char_type* __curo = NULL;\n+\t  char_type* __endi = NULL;\n+\t  char_type* __endo = NULL;\n+\n+\t  if (__testin)\n+\t    {\n+\t      __curi = this->gptr();\n+\t      __endi = this->egptr();\n+\t    }\n+\t  if (__testout)\n+\t    {\n+\t      __curo = this->pptr();\n+\t      __endo = this->epptr();\n+\t    }\n+\n+\t  off_type __newoffi = 0;\n+\t  off_type __newoffo = 0;\n+\t  if (__way == ios_base::cur)\n+\t    {\n+\t      __newoffi = __curi - __beg;\n+\t      __newoffo = __curo - __beg;\n+\t    }\n+\t  else if (__way == ios_base::end)\n+\t    {\n+\t      __newoffi = __endi - __beg;\n+\t      __newoffo = __endo - __beg;\n+\t    }\n+\n+\t  if (__testin\n+\t      && __newoffi + __off >= 0 && __endi - __beg >= __newoffi + __off)\n+\t    {\n+\t      _M_in_cur = __beg + __newoffi + __off;\n+\t      __retval = pos_type(__newoffi);\n+\t    }\n+\t  if (__testout\n+\t      && __newoffo + __off >= 0 && __endo - __beg >= __newoffo + __off)\n+\t    {\n+\t      _M_buf_bump(__newoffo + __off - (_M_out_cur - __beg));\n+\t      __retval = pos_type(__newoffo);\n+\t    }\n+\t}\n+      return __retval;\n+    }\n+\n+  template <class _CharT, class _Traits, class _Alloc>\n+    basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type\n+    basic_stringbuf<_CharT, _Traits, _Alloc>::\n+    seekpos(pos_type __sp, ios_base::openmode __mode)\n+    {\n+      pos_type __retval =  pos_type(off_type(-1)); \n+      off_type __pos = __sp._M_position();\n+      char_type* __beg = NULL;\n+      char_type* __end = NULL;\n+      bool __testin = __mode & ios_base::in && _M_mode & ios_base::in;\n+      bool __testout = __mode & ios_base::out && _M_mode & ios_base::out;\n+      \n+      if (__testin)\n+\t{\n+\t  __beg = this->eback();\n+\t  __end = this->egptr();\n+\t}\n+      if (__testout)\n+\t{\n+\t  __beg = this->pbase();\n+\t  __end = _M_buf + _M_buf_size;\n+\t}\n+ \n+      if (0 <= __pos && __pos <= __end - __beg)\n+\t{\n+\t  // Need to set both of these if applicable\n+\t  if (__testin)\n+\t    _M_in_cur = _M_in_beg + __pos;\n+\t  if (__testout)\n+\t    _M_buf_bump((__pos) - (_M_out_cur - __beg));\n+\t  __retval = pos_type(off_type(__pos));\n+\t}\n+      \n+      return __retval;\n+    }\n+\n+} // namespace std\n+\n+#endif\t/* _CPP_BITS_SSTREAM_TCC */\n+\n+\n+\n+\n+\n+\n+\n+\n+"}, {"sha": "3f0842655066ffc6521da34a1ae93e9a323539dd", "filename": "libstdc++-v3/bits/std_algorithm.h", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_algorithm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_algorithm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_algorithm.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,40 @@\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1996,1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef _CPP_ALGORITHM\n+#define _CPP_ALGORITHM 1\n+\n+#include <bits/stl_algobase.h>\n+#include <bits/stl_construct.h>\n+#include <bits/stl_uninitialized.h>\n+#include <bits/stl_tempbuf.h>\n+#include <bits/stl_algo.h>\n+\n+#endif /* _CPP_ALGORITHM */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "ffd147d433a3136e94bfbbb7c12b03f97224bf90", "filename": "libstdc++-v3/bits/std_bitset.h", "status": "added", "additions": 1216, "deletions": 0, "changes": 1216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_bitset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_bitset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_bitset.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,1216 @@\n+/*\n+ * Copyright (c) 1998\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef _CPP_BITSET\n+#define _CPP_BITSET 1\n+\n+// This implementation of bitset<> has a second template parameter,\n+// _WordT, which defaults to unsigned long.  *YOU SHOULD NOT USE\n+// THIS FEATURE*.  It is experimental, and it may be removed in\n+// future releases.\n+\n+// A bitset of size N, using words of type _WordT, will have\n+// N % (sizeof(_WordT) * CHAR_BIT) unused bits.  (They are the high-\n+// order bits in the highest word.)  It is a class invariant\n+// of class bitset<> that those unused bits are always zero.\n+\n+// Most of the actual code isn't contained in bitset<> itself, but in the\n+// base class _Base_bitset.  The base class works with whole words, not with\n+// individual bits.  This allows us to specialize _Base_bitset for the\n+// important special case where the bitset is only a single word.\n+\n+// The C++ standard does not define the precise semantics of operator[].\n+// In this implementation the const version of operator[] is equivalent\n+// to test(), except that it does no range checking.  The non-const version\n+// returns a reference to a bit, again without doing any range checking.\n+\n+\n+#include <bits/std_cstddef.h>     // for size_t\n+#include <bits/std_string.h>\n+#include <bits/std_stdexcept.h>\n+#include <bits/std_istream.h>\n+#include <bits/std_ostream.h>\n+#include <bits/std_algorithm.h>\n+\n+#define __BITS_PER_WORDT(__wt) (CHAR_BIT*sizeof(__wt))\n+#define __BITSET_WORDS(__n,__wt) \\\n+ ((__n) < 1 ? 1 : ((__n) + __BITS_PER_WORDT(__wt) - 1)/__BITS_PER_WORDT(__wt))\n+\n+__STL_BEGIN_NAMESPACE\n+\n+#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n+#pragma set woff 1209\n+#endif\n+\n+// structure to aid in counting bits\n+template<bool __dummy>\n+struct _Bit_count {\n+  static unsigned char _S_bit_count[256];\n+};\n+\n+// Mapping from 8 bit unsigned integers to the index of the first one\n+// bit:\n+template<bool __dummy>\n+struct _First_one {\n+  static unsigned char _S_first_one[256];\n+};\n+\n+//\n+// Base class: general case.\n+//\n+\n+template<size_t _Nw, class _WordT>\n+struct _Base_bitset {\n+  _WordT _M_w[_Nw];                // 0 is the least significant word.\n+\n+  _Base_bitset( void ) { _M_do_reset(); }\n+\n+  _Base_bitset(unsigned long __val);\n+\n+  static size_t _S_whichword( size_t __pos ) {\n+    return __pos / __BITS_PER_WORDT(_WordT);\n+  }\n+  static size_t _S_whichbyte( size_t __pos ) {\n+    return (__pos % __BITS_PER_WORDT(_WordT)) / CHAR_BIT;\n+  }\n+  static size_t _S_whichbit( size_t __pos ) {\n+    return __pos % __BITS_PER_WORDT(_WordT);\n+  }\n+  static _WordT _S_maskbit( size_t __pos ) {\n+    return (static_cast<_WordT>(1)) << _S_whichbit(__pos);\n+  }\n+\n+  _WordT& _M_getword(size_t __pos)       { return _M_w[_S_whichword(__pos)]; }\n+  _WordT  _M_getword(size_t __pos) const { return _M_w[_S_whichword(__pos)]; }\n+\n+  _WordT& _M_hiword()       { return _M_w[_Nw - 1]; }\n+  _WordT  _M_hiword() const { return _M_w[_Nw - 1]; }\n+\n+  void _M_do_and(const _Base_bitset<_Nw,_WordT>& __x) {\n+    for ( size_t __i = 0; __i < _Nw; __i++ ) {\n+      _M_w[__i] &= __x._M_w[__i];\n+    }\n+  }\n+\n+  void _M_do_or(const _Base_bitset<_Nw,_WordT>& __x) {\n+    for ( size_t __i = 0; __i < _Nw; __i++ ) {\n+      _M_w[__i] |= __x._M_w[__i];\n+    }\n+  }\n+\n+  void _M_do_xor(const _Base_bitset<_Nw,_WordT>& __x) {\n+    for ( size_t __i = 0; __i < _Nw; __i++ ) {\n+      _M_w[__i] ^= __x._M_w[__i];\n+    }\n+  }\n+\n+  void _M_do_left_shift(size_t __shift);\n+\n+  void _M_do_right_shift(size_t __shift);\n+\n+  void _M_do_flip() {\n+    for ( size_t __i = 0; __i < _Nw; __i++ ) {\n+      _M_w[__i] = ~_M_w[__i];\n+    }\n+  }\n+\n+  void _M_do_set() {\n+    for ( size_t __i = 0; __i < _Nw; __i++ ) {\n+      _M_w[__i] = ~static_cast<_WordT>(0);\n+    }\n+  }\n+\n+  void _M_do_reset() {\n+    for ( size_t __i = 0; __i < _Nw; __i++ ) {\n+      _M_w[__i] = 0;\n+    }\n+  }\n+\n+  bool _M_is_equal(const _Base_bitset<_Nw,_WordT>& __x) const {\n+    for (size_t __i = 0; __i < _Nw; ++__i) {\n+      if (_M_w[__i] != __x._M_w[__i])\n+        return false;\n+    }\n+    return true;\n+  }\n+\n+  bool _M_is_any() const {\n+    for ( size_t __i = 0; __i < __BITSET_WORDS(_Nw,_WordT); __i++ ) {\n+      if ( _M_w[__i] != static_cast<_WordT>(0) )\n+        return true;\n+    }\n+    return false;\n+  }\n+\n+  size_t _M_do_count() const {\n+    size_t __result = 0;\n+    const unsigned char* __byte_ptr = (const unsigned char*)_M_w;\n+    const unsigned char* __end_ptr = (const unsigned char*)(_M_w+_Nw);\n+\n+    while ( __byte_ptr < __end_ptr ) {\n+      __result += _Bit_count<true>::_S_bit_count[*__byte_ptr];\n+      __byte_ptr++;\n+    }\n+    return __result;\n+  }\n+\n+  unsigned long _M_do_to_ulong() const;\n+\n+  // find first \"on\" bit\n+  size_t _M_do_find_first(size_t __not_found) const;\n+\n+  // find the next \"on\" bit that follows \"prev\"\n+  size_t _M_do_find_next(size_t __prev, size_t __not_found) const;\n+};\n+\n+//\n+// Definitions of non-inline functions from _Base_bitset.\n+//\n+\n+template<size_t _Nw, class _WordT>\n+_Base_bitset<_Nw, _WordT>::_Base_bitset(unsigned long __val)\n+{\n+  _M_do_reset();\n+  const size_t __n = min(sizeof(unsigned long)*CHAR_BIT,\n+                         __BITS_PER_WORDT(_WordT)*_Nw);\n+  for(size_t __i = 0; __i < __n; ++__i, __val >>= 1)\n+    if ( __val & 0x1 )\n+      _M_getword(__i) |= _S_maskbit(__i);\n+}\n+\n+template<size_t _Nw, class _WordT>\n+void _Base_bitset<_Nw, _WordT>::_M_do_left_shift(size_t __shift)\n+{\n+  if (__shift != 0) {\n+    const size_t __wshift = __shift / __BITS_PER_WORDT(_WordT);\n+    const size_t __offset = __shift % __BITS_PER_WORDT(_WordT);\n+    const size_t __sub_offset = __BITS_PER_WORDT(_WordT) - __offset;\n+    const _WordT __mask = __offset == static_cast<size_t>(0) ?\n+\t\t\t  static_cast<_WordT>(0) :\n+\t\t\t  ~static_cast<_WordT>(0);\n+    size_t __n = _Nw - 1;\n+    for ( ; __n > __wshift; --__n)\n+      _M_w[__n] = (_M_w[__n - __wshift] << __offset) |\n+\t\t((_M_w[__n - __wshift - 1] >> __sub_offset) & __mask);\n+    if (__n == __wshift)\n+      _M_w[__n] = _M_w[0] << __offset;\n+    for (size_t __n1 = 0; __n1 < __n; ++__n1)\n+      _M_w[__n1] = static_cast<_WordT>(0);\n+  }\n+}\n+\n+template<size_t _Nw, class _WordT>\n+void _Base_bitset<_Nw, _WordT>::_M_do_right_shift(size_t __shift)\n+{\n+  if (__shift != 0) {\n+    const size_t __wshift = __shift / __BITS_PER_WORDT(_WordT);\n+    const size_t __offset = __shift % __BITS_PER_WORDT(_WordT);\n+    const size_t __sub_offset = __BITS_PER_WORDT(_WordT) - __offset;\n+    const _WordT __mask = __offset == static_cast<size_t>(0) ?\n+\t\t\t  static_cast<_WordT>(0) :\n+\t\t\t  ~static_cast<_WordT>(0);\n+    const size_t __limit = _Nw - __wshift - 1;\n+    size_t __n = 0;\n+    for ( ; __n < __limit; ++__n)\n+      _M_w[__n] = (_M_w[__n + __wshift] >> __offset) |\n+\t\t  ((_M_w[__n + __wshift + 1] << __sub_offset) & __mask);\n+    _M_w[__limit] = _M_w[_Nw-1] >> __offset;\n+    for (size_t __n1 = __limit + 1; __n1 < _Nw; ++__n1)\n+      _M_w[__n1] = static_cast<_WordT>(0);\n+  }\n+}\n+\n+template<size_t _Nw, class _WordT>\n+unsigned long _Base_bitset<_Nw, _WordT>::_M_do_to_ulong() const\n+{\n+  if (sizeof(_WordT) >= sizeof(unsigned long)) {\n+    for (size_t __i = 1; __i < _Nw; ++__i)\n+      if (_M_w[__i])\n+        __STL_THROW(overflow_error(\"bitset\"));\n+\n+    const _WordT __mask = static_cast<_WordT>(static_cast<unsigned long>(-1));\n+    if (_M_w[0] & ~__mask)\n+      __STL_THROW(overflow_error(\"bitset\"));\n+\n+    return static_cast<unsigned long>(_M_w[0] & __mask);\n+  }\n+  else {                      // sizeof(_WordT) < sizeof(unsigned long).\n+    const size_t __nwords =\n+      (sizeof(unsigned long) + sizeof(_WordT) - 1) / sizeof(_WordT);\n+\n+    size_t __min_nwords = __nwords;\n+    if (_Nw > __nwords) {\n+      for (size_t __i = __nwords; __i < _Nw; ++__i)\n+        if (_M_w[__i])\n+          __STL_THROW(overflow_error(\"bitset\"));\n+    }\n+    else\n+      __min_nwords = _Nw;\n+\n+    // If unsigned long is 8 bytes and _WordT is 6 bytes, then an unsigned\n+    // long consists of all of one word plus 2 bytes from another word.\n+    const size_t __part = sizeof(unsigned long) % sizeof(_WordT);\n+\n+    if (__part != 0 && __nwords <= _Nw &&\n+        (_M_w[__min_nwords - 1] >> ((sizeof(_WordT) - __part) * CHAR_BIT)) != 0)\n+      __STL_THROW(overflow_error(\"bitset\"));\n+\n+    unsigned long __result = 0;\n+    for (size_t __i = 0; __i < __min_nwords; ++__i) {\n+      __result |= static_cast<unsigned long>(\n+         _M_w[__i]) << (__i * sizeof(_WordT) * CHAR_BIT);\n+    }\n+    return __result;\n+  }\n+} // End _M_do_to_ulong\n+\n+template<size_t _Nw, class _WordT>\n+size_t _Base_bitset<_Nw, _WordT>::_M_do_find_first(size_t __not_found) const\n+{\n+  for ( size_t __i = 0; __i < _Nw; __i++ ) {\n+    _WordT __thisword = _M_w[__i];\n+    if ( __thisword != static_cast<_WordT>(0) ) {\n+      // find byte within word\n+      for ( size_t __j = 0; __j < sizeof(_WordT); __j++ ) {\n+        unsigned char __this_byte\n+          = static_cast<unsigned char>(__thisword & (~(unsigned char)0));\n+        if ( __this_byte )\n+          return __i*__BITS_PER_WORDT(_WordT) + __j*CHAR_BIT +\n+            _First_one<true>::_S_first_one[__this_byte];\n+\n+        __thisword >>= CHAR_BIT;\n+      }\n+    }\n+  }\n+  // not found, so return an indication of failure.\n+  return __not_found;\n+}\n+\n+template<size_t _Nw, class _WordT>\n+size_t\n+_Base_bitset<_Nw, _WordT>::_M_do_find_next(size_t __prev,\n+                                           size_t __not_found) const\n+{\n+  // make bound inclusive\n+  ++__prev;\n+\n+  // check out of bounds\n+  if ( __prev >= _Nw * __BITS_PER_WORDT(_WordT) )\n+    return __not_found;\n+\n+    // search first word\n+  size_t __i = _S_whichword(__prev);\n+  _WordT __thisword = _M_w[__i];\n+\n+    // mask off bits below bound\n+  __thisword &= (~static_cast<_WordT>(0)) << _S_whichbit(__prev);\n+\n+  if ( __thisword != static_cast<_WordT>(0) ) {\n+    // find byte within word\n+    // get first byte into place\n+    __thisword >>= _S_whichbyte(__prev) * CHAR_BIT;\n+    for ( size_t __j = _S_whichbyte(__prev); __j < sizeof(_WordT); __j++ ) {\n+      unsigned char __this_byte\n+        = static_cast<unsigned char>(__thisword & (~(unsigned char)0));\n+      if ( __this_byte )\n+        return __i*__BITS_PER_WORDT(_WordT) + __j*CHAR_BIT +\n+          _First_one<true>::_S_first_one[__this_byte];\n+\n+      __thisword >>= CHAR_BIT;\n+    }\n+  }\n+\n+  // check subsequent words\n+  __i++;\n+  for ( ; __i < _Nw; __i++ ) {\n+    _WordT __thisword = _M_w[__i];\n+    if ( __thisword != static_cast<_WordT>(0) ) {\n+      // find byte within word\n+      for ( size_t __j = 0; __j < sizeof(_WordT); __j++ ) {\n+        unsigned char __this_byte\n+          = static_cast<unsigned char>(__thisword & (~(unsigned char)0));\n+        if ( __this_byte )\n+          return __i*__BITS_PER_WORDT(_WordT) + __j*CHAR_BIT +\n+            _First_one<true>::_S_first_one[__this_byte];\n+\n+        __thisword >>= CHAR_BIT;\n+      }\n+    }\n+  }\n+\n+  // not found, so return an indication of failure.\n+  return __not_found;\n+} // end _M_do_find_next\n+\n+\n+// ------------------------------------------------------------\n+\n+//\n+// Base class: specialization for a single word.\n+//\n+\n+#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n+\n+template<class _WordT>\n+struct _Base_bitset<1, _WordT> {\n+  _WordT _M_w;\n+\n+  _Base_bitset( void ) { _M_do_reset(); }\n+\n+  _Base_bitset(unsigned long __val);\n+\n+  static size_t _S_whichword( size_t __pos ) {\n+    return __pos / __BITS_PER_WORDT(_WordT);\n+  }\n+  static size_t _S_whichbyte( size_t __pos ) {\n+    return (__pos % __BITS_PER_WORDT(_WordT)) / CHAR_BIT;\n+  }\n+  static size_t _S_whichbit( size_t __pos ) {\n+    return __pos % __BITS_PER_WORDT(_WordT);\n+  }\n+  static _WordT _S_maskbit( size_t __pos ) {\n+    return (static_cast<_WordT>(1)) << _S_whichbit(__pos);\n+  }\n+\n+  _WordT& _M_getword(size_t)       { return _M_w; }\n+  _WordT  _M_getword(size_t) const { return _M_w; }\n+\n+  _WordT& _M_hiword()       { return _M_w; }\n+  _WordT  _M_hiword() const { return _M_w; }\n+\n+  void _M_do_and(const _Base_bitset<1,_WordT>& __x) { _M_w &= __x._M_w; }\n+  void _M_do_or(const _Base_bitset<1,_WordT>& __x)  { _M_w |= __x._M_w; }\n+  void _M_do_xor(const _Base_bitset<1,_WordT>& __x) { _M_w ^= __x._M_w; }\n+  void _M_do_left_shift(size_t __shift)     { _M_w <<= __shift; }\n+  void _M_do_right_shift(size_t __shift)    { _M_w >>= __shift; }\n+  void _M_do_flip()                       { _M_w = ~_M_w; }\n+  void _M_do_set()                        { _M_w = ~static_cast<_WordT>(0); }\n+  void _M_do_reset()                      { _M_w = 0; }\n+\n+  bool _M_is_equal(const _Base_bitset<1,_WordT>& __x) const {\n+    return _M_w == __x._M_w;\n+  }\n+  bool _M_is_any() const {\n+    return _M_w != 0;\n+  }\n+\n+  size_t _M_do_count() const {\n+    size_t __result = 0;\n+    const unsigned char* __byte_ptr = (const unsigned char*)&_M_w;\n+    const unsigned char* __end_ptr = ((const unsigned char*)&_M_w)+sizeof(_M_w);\n+    while ( __byte_ptr < __end_ptr ) {\n+      __result += _Bit_count<true>::_S_bit_count[*__byte_ptr];\n+      __byte_ptr++;\n+    }\n+    return __result;\n+  }\n+\n+  unsigned long _M_do_to_ulong() const {\n+    if (sizeof(_WordT) <= sizeof(unsigned long))\n+        return static_cast<unsigned long>(_M_w);\n+    else {\n+      const _WordT __mask = static_cast<_WordT>(static_cast<unsigned long>(-1));\n+      if (_M_w & ~__mask)\n+        __STL_THROW(overflow_error(\"bitset\"));\n+      return static_cast<unsigned long>(_M_w);\n+    }\n+  }\n+\n+  size_t _M_do_find_first(size_t __not_found) const;\n+\n+  // find the next \"on\" bit that follows \"prev\"\n+  size_t _M_do_find_next(size_t __prev, size_t __not_found) const;\n+\n+};\n+\n+//\n+// Definitions of non-inline functions from the single-word version of\n+//  _Base_bitset.\n+//\n+\n+template <class _WordT>\n+_Base_bitset<1, _WordT>::_Base_bitset(unsigned long __val)\n+{\n+  _M_do_reset();\n+  const size_t __n = min(sizeof(unsigned long)*CHAR_BIT,\n+                         __BITS_PER_WORDT(_WordT)*_Nw);\n+  for(size_t __i = 0; __i < __n; ++__i, __val >>= 1)\n+    if ( __val & 0x1 )\n+      _M_w |= _S_maskbit(__i);\n+}\n+\n+template <class _WordT>\n+size_t _Base_bitset<1, _WordT>::_M_do_find_first(size_t __not_found) const\n+{\n+  _WordT __thisword = _M_w;\n+\n+  if ( __thisword != static_cast<_WordT>(0) ) {\n+    // find byte within word\n+    for ( size_t __j = 0; __j < sizeof(_WordT); __j++ ) {\n+      unsigned char __this_byte\n+        = static_cast<unsigned char>(__thisword & (~(unsigned char)0));\n+      if ( __this_byte )\n+        return __j*CHAR_BIT + _First_one<true>::_S_first_one[__this_byte];\n+\n+      __thisword >>= CHAR_BIT;\n+    }\n+  }\n+  // not found, so return a value that indicates failure.\n+  return __not_found;\n+}\n+\n+template <class _WordT>\n+size_t\n+_Base_bitset<1, _WordT>::_M_do_find_next(size_t __prev,\n+                                         size_t __not_found ) const\n+{\n+  // make bound inclusive\n+  ++__prev;\n+\n+  // check out of bounds\n+  if ( __prev >= __BITS_PER_WORDT(_WordT) )\n+    return __not_found;\n+\n+    // search first (and only) word\n+  _WordT __thisword = _M_w;\n+\n+  // mask off bits below bound\n+  __thisword &= (~static_cast<_WordT>(0)) << _S_whichbit(__prev);\n+\n+  if ( __thisword != static_cast<_WordT>(0) ) {\n+    // find byte within word\n+    // get first byte into place\n+    __thisword >>= _S_whichbyte(__prev) * CHAR_BIT;\n+    for ( size_t __j = _S_whichbyte(__prev); __j < sizeof(_WordT); __j++ ) {\n+      unsigned char __this_byte\n+        = static_cast<unsigned char>(__thisword & (~(unsigned char)0));\n+      if ( __this_byte )\n+        return __j*CHAR_BIT + _First_one<true>::_S_first_one[__this_byte];\n+\n+      __thisword >>= CHAR_BIT;\n+    }\n+  }\n+\n+  // not found, so return a value that indicates failure.\n+  return __not_found;\n+} // end _M_do_find_next\n+\n+//\n+// One last specialization: _M_do_to_ulong() and the constructor from\n+// unsigned long are very simple if the bitset consists of a single\n+// word of type unsigned long.\n+//\n+\n+__STL_TEMPLATE_NULL\n+inline unsigned long\n+_Base_bitset<1, unsigned long>::_M_do_to_ulong() const { return _M_w; }\n+\n+__STL_TEMPLATE_NULL\n+inline _Base_bitset<1, unsigned long>::_Base_bitset(unsigned long __val) {\n+  _M_w = __val;\n+}\n+\n+#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n+\n+// ------------------------------------------------------------\n+// Helper class to zero out the unused high-order bits in the highest word.\n+\n+#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n+\n+template <class _WordT, size_t _Extrabits> struct _Sanitize {\n+  static void _M_do_sanitize(_WordT& __val)\n+    { __val &= ~((~static_cast<_WordT>(0)) << _Extrabits); }\n+};\n+\n+template <class _WordT> struct _Sanitize<_WordT, 0> {\n+  static void _M_do_sanitize(_WordT) {}\n+};\n+\n+#else /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n+ \n+template <class _WordT, size_t _Extrabits> struct _Sanitize {\n+  static void _M_do_sanitize(_WordT& __val) {\n+    if (_Extrabits != 0)\n+      __val &= ~((~static_cast<_WordT>(0)) << _Extrabits);\n+  }\n+};\n+ \n+#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n+\n+// ------------------------------------------------------------\n+// Class bitset.\n+//   _Nb may be any nonzero number of type size_t.\n+//   Type _WordT may be any unsigned integral type.\n+\n+template<size_t _Nb, class _WordT = unsigned long>\n+class bitset : private _Base_bitset<__BITSET_WORDS(_Nb,_WordT), _WordT>\n+{\n+private:\n+  typedef _Base_bitset<__BITSET_WORDS(_Nb,_WordT), _WordT> _Base;\n+\n+  // Import base's protected interface.  Necessary because of new template\n+  // name resolution rules.\n+\n+#ifdef __STL_HAS_NAMESPACES\n+  using _Base::_S_whichword;\n+  using _Base::_S_whichbyte;\n+  using _Base::_S_whichbit;\n+  using _Base::_S_maskbit;\n+  using _Base::_M_getword;\n+  using _Base::_M_hiword;\n+  using _Base::_M_do_and;\n+  using _Base::_M_do_or;\n+  using _Base::_M_do_xor;\n+  using _Base::_M_do_left_shift;\n+  using _Base::_M_do_right_shift;\n+  using _Base::_M_do_flip;\n+  using _Base::_M_do_set;\n+  using _Base::_M_do_reset;\n+  using _Base::_M_is_equal;\n+  using _Base::_M_is_any;\n+  using _Base::_M_do_count;\n+  using _Base::_M_do_to_ulong;\n+  using _Base::_M_do_find_first;\n+  using _Base::_M_do_find_next;\n+#endif /* __STL_HAS_NAMESPACES */\n+\n+private:\n+  void _M_do_sanitize() {\n+    _Sanitize<_WordT,_Nb%__BITS_PER_WORDT(_WordT) >\n+      ::_M_do_sanitize(_M_hiword());\n+  }\n+\n+public:\n+\n+  // bit reference:\n+  class reference;\n+  friend class reference;\n+  \n+  class reference {\n+    friend class bitset;\n+\n+    _WordT *_M_wp;\n+    size_t _M_bpos;\n+\n+    // left undefined\n+    reference();\n+\n+  public:\n+    reference( bitset& __b, size_t __pos ) {\n+      _M_wp = &__b._M_getword(__pos);\n+      _M_bpos = _S_whichbit(__pos);\n+    }\n+\n+    ~reference() {}\n+\n+    // for b[i] = __x;\n+    reference& operator=(bool __x) {\n+      if ( __x )\n+        *_M_wp |= _S_maskbit(_M_bpos);\n+      else\n+        *_M_wp &= ~_S_maskbit(_M_bpos);\n+\n+      return *this;\n+    }\n+\n+    // for b[i] = b[__j];\n+    reference& operator=(const reference& __j) {\n+      if ( (*(__j._M_wp) & _S_maskbit(__j._M_bpos)) )\n+        *_M_wp |= _S_maskbit(_M_bpos);\n+      else\n+        *_M_wp &= ~_S_maskbit(_M_bpos);\n+\n+      return *this;\n+    }\n+\n+    // flips the bit\n+    bool operator~() const { return (*(_M_wp) & _S_maskbit(_M_bpos)) == 0; }\n+\n+    // for __x = b[i];\n+    operator bool() const { return (*(_M_wp) & _S_maskbit(_M_bpos)) != 0; }\n+\n+    // for b[i].flip();\n+    reference& flip() {\n+      *_M_wp ^= _S_maskbit(_M_bpos);\n+      return *this;\n+    }\n+  };\n+\n+  // 23.3.5.1 constructors:\n+  bitset() {}\n+  bitset(unsigned long __val) :\n+    _Base_bitset<__BITSET_WORDS(_Nb,_WordT), _WordT>(__val) {}\n+\n+#ifdef __STL_MEMBER_TEMPLATES\n+  template<class _CharT, class _Traits, class _Alloc>\n+  explicit bitset(const basic_string<_CharT,_Traits,_Alloc>& __s,\n+                  size_t __pos = 0)\n+    : _Base()\n+  {\n+    if (__pos > __s.size())\n+      __STL_THROW(out_of_range(\"bitset\"));\n+    _M_copy_from_string(__s, __pos, \n+\t\t        basic_string<_CharT,_Traits,_Alloc>::npos);\n+  }\n+\n+  template<class _CharT, class _Traits, class _Alloc>\n+    bitset(const basic_string<_CharT, _Traits, _Alloc>& __s,\n+\t   size_t __pos,\n+\t   size_t __n)\n+    : _Base() \n+    {\n+      if (__pos > __s.size()) \n+\t__STL_THROW(out_of_range(\"bitset\"));\n+      _M_copy_from_string(__s, __pos, __n);\n+    }\n+#else \n+  explicit bitset(const basic_string<char>& __s,\n+\t\t  size_t __pos = 0,\n+\t\t  size_t __n = basic_string<char>::npos) \n+    : _Base() \n+    {\n+      if (__pos > __s.size()) \n+        __STL_THROW(out_of_range(\"bitset\"));\n+      _M_copy_from_string(__s, __pos, __n);\n+    }\n+\n+#endif /* __STL_MEMBER_TEMPLATES */\n+\n+  // 23.3.5.2 bitset operations:\n+  bitset<_Nb,_WordT>& operator&=(const bitset<_Nb,_WordT>& __rhs) {\n+    _M_do_and(__rhs);\n+    return *this;\n+  }\n+\n+  bitset<_Nb,_WordT>& operator|=(const bitset<_Nb,_WordT>& __rhs) {\n+    _M_do_or(__rhs);\n+    return *this;\n+  }\n+\n+  bitset<_Nb,_WordT>& operator^=(const bitset<_Nb,_WordT>& __rhs) {\n+    _M_do_xor(__rhs);\n+    return *this;\n+  }\n+\n+  bitset<_Nb,_WordT>& operator<<=(size_t __pos) {\n+    _M_do_left_shift(__pos);\n+    _M_do_sanitize();\n+    return *this;\n+  }\n+\n+  bitset<_Nb,_WordT>& operator>>=(size_t __pos) {\n+    _M_do_right_shift(__pos);\n+    _M_do_sanitize();\n+    return *this;\n+  }\n+\n+  //\n+  // Extension:\n+  // Versions of single-bit set, reset, flip, test with no range checking.\n+  //\n+\n+  bitset<_Nb,_WordT>& _Unchecked_set(size_t __pos) {\n+    _M_getword(__pos) |= _S_maskbit(__pos);\n+    return *this;\n+  }\n+\n+  bitset<_Nb,_WordT>& _Unchecked_set(size_t __pos, int __val) {\n+    if (__val)\n+      _M_getword(__pos) |= _S_maskbit(__pos);\n+    else\n+      _M_getword(__pos) &= ~_S_maskbit(__pos);\n+\n+    return *this;\n+  }\n+\n+  bitset<_Nb,_WordT>& _Unchecked_reset(size_t __pos) {\n+    _M_getword(__pos) &= ~_S_maskbit(__pos);\n+    return *this;\n+  }\n+\n+  bitset<_Nb,_WordT>& _Unchecked_flip(size_t __pos) {\n+    _M_getword(__pos) ^= _S_maskbit(__pos);\n+    return *this;\n+  }\n+\n+  bool _Unchecked_test(size_t __pos) const {\n+    return (_M_getword(__pos) & _S_maskbit(__pos)) != static_cast<_WordT>(0);\n+  }\n+\n+  // Set, reset, and flip.\n+\n+  bitset<_Nb,_WordT>& set() {\n+    _M_do_set();\n+    _M_do_sanitize();\n+    return *this;\n+  }\n+\n+  bitset<_Nb,_WordT>& set(size_t __pos) {\n+    if (__pos >= _Nb)\n+      __STL_THROW(out_of_range(\"bitset\"));\n+\n+    return _Unchecked_set(__pos);\n+  }\n+\n+  bitset<_Nb,_WordT>& set(size_t __pos, int __val) {\n+    if (__pos >= _Nb)\n+      __STL_THROW(out_of_range(\"bitset\"));\n+\n+    return _Unchecked_set(__pos, __val);\n+  }\n+\n+  bitset<_Nb,_WordT>& reset() {\n+    _M_do_reset();\n+    return *this;\n+  }\n+\n+  bitset<_Nb,_WordT>& reset(size_t __pos) {\n+    if (__pos >= _Nb)\n+      __STL_THROW(out_of_range(\"bitset\"));\n+\n+    return _Unchecked_reset(__pos);\n+  }\n+\n+  bitset<_Nb,_WordT>& flip() {\n+    _M_do_flip();\n+    _M_do_sanitize();\n+    return *this;\n+  }\n+\n+  bitset<_Nb,_WordT>& flip(size_t __pos) {\n+    if (__pos >= _Nb)\n+      __STL_THROW(out_of_range(\"bitset\"));\n+\n+    return _Unchecked_flip(__pos);\n+  }\n+\n+  bitset<_Nb,_WordT> operator~() const {\n+    return bitset<_Nb,_WordT>(*this).flip();\n+  }\n+\n+  // element access:\n+  //for b[i];\n+  reference operator[](size_t __pos) { return reference(*this,__pos); }\n+  bool operator[](size_t __pos) const { return _Unchecked_test(__pos); }\n+\n+  unsigned long to_ulong() const { return _M_do_to_ulong(); }\n+\n+#if  defined(__STL_MEMBER_TEMPLATES) && \\\n+     defined(__STL_EXPLICIT_FUNCTION_TMPL_ARGS)\n+\n+  template <class _CharT, class _Traits, class _Alloc>\n+  basic_string<_CharT, _Traits, _Alloc> to_string() const {\n+    basic_string<_CharT, _Traits, _Alloc> __result;\n+    _M_copy_to_string(__result);\n+    return __result;\n+  }\n+\n+#endif /* member templates and explicit function template args */\n+\n+  // Helper functions for string operations.\n+#ifdef __STL_MEMBER_TEMPLATES\n+\n+  template<class _CharT, class _Traits, class _Alloc>\n+  void _M_copy_from_string(const basic_string<_CharT,_Traits,_Alloc>& __s,\n+                          size_t,\n+                          size_t);\n+\n+  template<class _CharT, class _Traits, class _Alloc>\n+  void _M_copy_to_string(basic_string<_CharT,_Traits,_Alloc>&) const;\n+\n+#else /* __STL_MEMBER_TEMPLATES */\n+\n+  void _M_copy_from_string(const basic_string<char>&, size_t, size_t);\n+  void _M_copy_to_string(basic_string<char>&) const;\n+\n+#endif /* __STL_MEMBER_TEMPLATES */\n+\n+  size_t count() const { return _M_do_count(); }\n+\n+  size_t size() const { return _Nb; }\n+\n+  bool operator==(const bitset<_Nb,_WordT>& __rhs) const {\n+    return _M_is_equal(__rhs);\n+  }\n+  bool operator!=(const bitset<_Nb,_WordT>& __rhs) const {\n+    return !_M_is_equal(__rhs);\n+  }\n+\n+  bool test(size_t __pos) const {\n+    if (__pos > _Nb)\n+      __STL_THROW(out_of_range(\"bitset\"));\n+\n+    return _Unchecked_test(__pos);\n+  }\n+\n+  bool any() const { return _M_is_any(); }\n+  bool none() const { return !_M_is_any(); }\n+\n+  bitset<_Nb,_WordT> operator<<(size_t __pos) const\n+    { return bitset<_Nb,_WordT>(*this) <<= __pos; }\n+  bitset<_Nb,_WordT> operator>>(size_t __pos) const\n+    { return bitset<_Nb,_WordT>(*this) >>= __pos; }\n+\n+  //\n+  // EXTENSIONS: bit-find operations.  These operations are\n+  // experimental, and are subject to change or removal in future\n+  // versions.\n+  //\n+\n+  // find the index of the first \"on\" bit\n+  size_t _Find_first() const\n+    { return _M_do_find_first(_Nb); }\n+\n+  // find the index of the next \"on\" bit after prev\n+  size_t _Find_next( size_t __prev ) const\n+    { return _M_do_find_next(__prev, _Nb); }\n+\n+};\n+\n+//\n+// Definitions of non-inline member functions.\n+//\n+\n+#ifdef __STL_MEMBER_TEMPLATES\n+\n+template <size_t _Nb, class _WordT>\n+template<class _CharT, class _Traits, class _Alloc>\n+void bitset<_Nb, _WordT>\n+  ::_M_copy_from_string(const basic_string<_CharT,_Traits,_Alloc>& __s,\n+                        size_t __pos,\n+                        size_t __n)\n+{\n+  reset();\n+  const size_t __nbits = min(_Nb, min(__n, __s.size() - __pos));\n+  for (size_t __i = 0; __i < __nbits; ++__i) {\n+    switch(__s[__pos + __nbits - __i - 1]) {\n+    case '0':\n+      break;\n+    case '1':\n+      set(__i);\n+      break;\n+    default:\n+      __STL_THROW(invalid_argument(\"bitset\"));\n+    }\n+  }\n+}\n+\n+template <size_t _Nb, class _WordT>\n+template <class _CharT, class _Traits, class _Alloc>\n+void bitset<_Nb, _WordT>\n+  ::_M_copy_to_string(basic_string<_CharT, _Traits, _Alloc>& __s) const\n+{\n+  __s.assign(_Nb, '0');\n+\n+  for (size_t __i = 0; __i < _Nb; ++__i)\n+    if (_Unchecked_test(__i))\n+      __s[_Nb - 1 - __i] = '1';\n+}\n+\n+#else /* __STL_MEMBER_TEMPLATES */\n+ \n+template <size_t _Nb, class _WordT>\n+void bitset<_Nb, _WordT>::_M_copy_from_string(const basic_string<char>& __s,\n+\t\t\t\t\t      size_t __pos, size_t __n)\n+{\n+  reset();\n+  size_t __tmp = _Nb;\n+  const size_t __nbits = min(__tmp, min(__n, __s.size() - __pos));\n+  for (size_t __i = 0; __i < __nbits; ++__i) {\n+    switch(__s[__pos + __nbits - __i - 1]) {\n+    case '0':\n+      break;\n+    case '1':\n+      set(__i);\n+      break;\n+    default:\n+      __STL_THROW(invalid_argument(\"bitset\"));\n+    }\n+  }\n+}\n+\n+template <size_t _Nb, class _WordT>\n+void bitset<_Nb, _WordT>::_M_copy_to_string(basic_string<char>& __s) const\n+{\n+  __s.assign(_Nb, '0');\n+  \n+  for (size_t __i = 0; __i < _Nb; ++__i) \n+    if (_Unchecked_test(__i))\n+      __s[_Nb - 1 - __i] = '1';\n+}\n+\n+#endif /* __STL_MEMBER_TEMPLATES */\n+\n+// ------------------------------------------------------------\n+\n+//\n+// 23.3.5.3 bitset operations:\n+//\n+\n+template <size_t _Nb, class _WordT>\n+inline bitset<_Nb,_WordT> operator&(const bitset<_Nb,_WordT>& __x,\n+                                    const bitset<_Nb,_WordT>& __y) {\n+  bitset<_Nb,_WordT> __result(__x);\n+  __result &= __y;\n+  return __result;\n+}\n+\n+\n+template <size_t _Nb, class _WordT>\n+inline bitset<_Nb,_WordT> operator|(const bitset<_Nb,_WordT>& __x,\n+                                    const bitset<_Nb,_WordT>& __y) {\n+  bitset<_Nb,_WordT> __result(__x);\n+  __result |= __y;\n+  return __result;\n+}\n+\n+template <size_t _Nb, class _WordT>\n+inline bitset<_Nb,_WordT> operator^(const bitset<_Nb,_WordT>& __x,\n+                                    const bitset<_Nb,_WordT>& __y) {\n+  bitset<_Nb,_WordT> __result(__x);\n+  __result ^= __y;\n+  return __result;\n+}\n+\n+#ifdef __STL_USE_NEW_IOSTREAMS\n+\n+template <class _CharT, class _Traits, size_t _Nb, class _WordT>\n+basic_istream<_CharT, _Traits>&\n+operator>>(basic_istream<_CharT, _Traits>& __is, bitset<_Nb,_WordT>& __x)\n+{\n+  basic_string<_CharT, _Traits> __tmp;\n+  __tmp.reserve(_Nb);\n+\n+  // Skip whitespace\n+  typename basic_istream<_CharT, _Traits>::sentry __sentry(__is);\n+  if (__sentry) {\n+    basic_streambuf<_CharT, _Traits>* __buf = __is.rdbuf();\n+    for (size_t __i = 0; __i < _Nb; ++__i) {\n+      static _Traits::int_type __eof = _Traits::eof();\n+\n+      typename _Traits::int_type __c1 = __buf->sbumpc();\n+      if (_Traits::eq_int_type(__c1, __eof)) {\n+        __is.setstate(ios_base::eofbit);\n+        break;\n+      }\n+      else {\n+        char __c2 = _Traits::to_char_type(__c1);\n+        char __c  = __is.narrow(__c2, '*');\n+\n+        if (__c == '0' || __c == '1')\n+          __tmp.push_back(__c);\n+        else if (_Traits::eq_int_type(__buf->sputbackc(__c2), __eof)) {\n+          __is.setstate(ios_base::failbit);\n+          break;\n+        }\n+      }\n+    }\n+\n+    if (__tmp.empty())\n+      __is.setstate(ios_base::failbit);\n+    else\n+      __x._M_copy_from_string(__tmp, static_cast<size_t>(0), _Nb);\n+  }\n+\n+  return __is;\n+}\n+\n+template <class _CharT, class _Traits, size_t _Nb, class _WordT>\n+basic_ostream<_CharT, _Traits>&\n+operator<<(basic_ostream<_CharT, _Traits>& __os,\n+           const bitset<_Nb,_WordT>& __x)\n+{\n+  basic_string<_CharT, _Traits> __tmp;\n+  __x._M_copy_to_string(__tmp);\n+  return __os << __tmp;\n+}\n+\n+#else /* __STL_USE_NEW_IOSTREAMS */\n+\n+template <size_t _Nb, class _WordT>\n+istream&\n+operator>>(istream& __is, bitset<_Nb,_WordT>& __x) {\n+  string __tmp;\n+  __tmp.reserve(_Nb);\n+\n+  if (__is.flags() & ios::skipws) {\n+    char __c;\n+    do \n+      __is.get(__c);\n+    while (__is && isspace(__c));\n+    if (__is)\n+      __is.putback(__c);\n+  }\n+\n+  for (size_t __i = 0; __i < _Nb; ++__i) {\n+    char __c;\n+    __is.get(__c);\n+\n+    if (!__is)\n+      break;\n+    else if (__c != '0' && __c != '1') {\n+      __is.putback(__c);\n+      break;\n+    }\n+    else\n+      __tmp.push_back(__c);\n+  }\n+\n+  if (__tmp.empty()) \n+    __is.clear(__is.rdstate() | ios::failbit);\n+  else\n+    __x._M_copy_from_string(__tmp, static_cast<size_t>(0), _Nb);\n+\n+  return __is;\n+}\n+\n+template <size_t _Nb, class _WordT>\n+ostream& operator<<(ostream& __os, const bitset<_Nb,_WordT>& __x) {\n+  string __tmp;\n+  __x._M_copy_to_string(__tmp);\n+  return __os << __tmp;\n+}\n+\n+#endif /* __STL_USE_NEW_IOSTREAMS */\n+\n+// ------------------------------------------------------------\n+// Lookup tables for find and count operations.\n+\n+template<bool __dummy>\n+unsigned char _Bit_count<__dummy>::_S_bit_count[] = {\n+  0, /*   0 */ 1, /*   1 */ 1, /*   2 */ 2, /*   3 */ 1, /*   4 */\n+  2, /*   5 */ 2, /*   6 */ 3, /*   7 */ 1, /*   8 */ 2, /*   9 */\n+  2, /*  10 */ 3, /*  11 */ 2, /*  12 */ 3, /*  13 */ 3, /*  14 */\n+  4, /*  15 */ 1, /*  16 */ 2, /*  17 */ 2, /*  18 */ 3, /*  19 */\n+  2, /*  20 */ 3, /*  21 */ 3, /*  22 */ 4, /*  23 */ 2, /*  24 */\n+  3, /*  25 */ 3, /*  26 */ 4, /*  27 */ 3, /*  28 */ 4, /*  29 */\n+  4, /*  30 */ 5, /*  31 */ 1, /*  32 */ 2, /*  33 */ 2, /*  34 */\n+  3, /*  35 */ 2, /*  36 */ 3, /*  37 */ 3, /*  38 */ 4, /*  39 */\n+  2, /*  40 */ 3, /*  41 */ 3, /*  42 */ 4, /*  43 */ 3, /*  44 */\n+  4, /*  45 */ 4, /*  46 */ 5, /*  47 */ 2, /*  48 */ 3, /*  49 */\n+  3, /*  50 */ 4, /*  51 */ 3, /*  52 */ 4, /*  53 */ 4, /*  54 */\n+  5, /*  55 */ 3, /*  56 */ 4, /*  57 */ 4, /*  58 */ 5, /*  59 */\n+  4, /*  60 */ 5, /*  61 */ 5, /*  62 */ 6, /*  63 */ 1, /*  64 */\n+  2, /*  65 */ 2, /*  66 */ 3, /*  67 */ 2, /*  68 */ 3, /*  69 */\n+  3, /*  70 */ 4, /*  71 */ 2, /*  72 */ 3, /*  73 */ 3, /*  74 */\n+  4, /*  75 */ 3, /*  76 */ 4, /*  77 */ 4, /*  78 */ 5, /*  79 */\n+  2, /*  80 */ 3, /*  81 */ 3, /*  82 */ 4, /*  83 */ 3, /*  84 */\n+  4, /*  85 */ 4, /*  86 */ 5, /*  87 */ 3, /*  88 */ 4, /*  89 */\n+  4, /*  90 */ 5, /*  91 */ 4, /*  92 */ 5, /*  93 */ 5, /*  94 */\n+  6, /*  95 */ 2, /*  96 */ 3, /*  97 */ 3, /*  98 */ 4, /*  99 */\n+  3, /* 100 */ 4, /* 101 */ 4, /* 102 */ 5, /* 103 */ 3, /* 104 */\n+  4, /* 105 */ 4, /* 106 */ 5, /* 107 */ 4, /* 108 */ 5, /* 109 */\n+  5, /* 110 */ 6, /* 111 */ 3, /* 112 */ 4, /* 113 */ 4, /* 114 */\n+  5, /* 115 */ 4, /* 116 */ 5, /* 117 */ 5, /* 118 */ 6, /* 119 */\n+  4, /* 120 */ 5, /* 121 */ 5, /* 122 */ 6, /* 123 */ 5, /* 124 */\n+  6, /* 125 */ 6, /* 126 */ 7, /* 127 */ 1, /* 128 */ 2, /* 129 */\n+  2, /* 130 */ 3, /* 131 */ 2, /* 132 */ 3, /* 133 */ 3, /* 134 */\n+  4, /* 135 */ 2, /* 136 */ 3, /* 137 */ 3, /* 138 */ 4, /* 139 */\n+  3, /* 140 */ 4, /* 141 */ 4, /* 142 */ 5, /* 143 */ 2, /* 144 */\n+  3, /* 145 */ 3, /* 146 */ 4, /* 147 */ 3, /* 148 */ 4, /* 149 */\n+  4, /* 150 */ 5, /* 151 */ 3, /* 152 */ 4, /* 153 */ 4, /* 154 */\n+  5, /* 155 */ 4, /* 156 */ 5, /* 157 */ 5, /* 158 */ 6, /* 159 */\n+  2, /* 160 */ 3, /* 161 */ 3, /* 162 */ 4, /* 163 */ 3, /* 164 */\n+  4, /* 165 */ 4, /* 166 */ 5, /* 167 */ 3, /* 168 */ 4, /* 169 */\n+  4, /* 170 */ 5, /* 171 */ 4, /* 172 */ 5, /* 173 */ 5, /* 174 */\n+  6, /* 175 */ 3, /* 176 */ 4, /* 177 */ 4, /* 178 */ 5, /* 179 */\n+  4, /* 180 */ 5, /* 181 */ 5, /* 182 */ 6, /* 183 */ 4, /* 184 */\n+  5, /* 185 */ 5, /* 186 */ 6, /* 187 */ 5, /* 188 */ 6, /* 189 */\n+  6, /* 190 */ 7, /* 191 */ 2, /* 192 */ 3, /* 193 */ 3, /* 194 */\n+  4, /* 195 */ 3, /* 196 */ 4, /* 197 */ 4, /* 198 */ 5, /* 199 */\n+  3, /* 200 */ 4, /* 201 */ 4, /* 202 */ 5, /* 203 */ 4, /* 204 */\n+  5, /* 205 */ 5, /* 206 */ 6, /* 207 */ 3, /* 208 */ 4, /* 209 */\n+  4, /* 210 */ 5, /* 211 */ 4, /* 212 */ 5, /* 213 */ 5, /* 214 */\n+  6, /* 215 */ 4, /* 216 */ 5, /* 217 */ 5, /* 218 */ 6, /* 219 */\n+  5, /* 220 */ 6, /* 221 */ 6, /* 222 */ 7, /* 223 */ 3, /* 224 */\n+  4, /* 225 */ 4, /* 226 */ 5, /* 227 */ 4, /* 228 */ 5, /* 229 */\n+  5, /* 230 */ 6, /* 231 */ 4, /* 232 */ 5, /* 233 */ 5, /* 234 */\n+  6, /* 235 */ 5, /* 236 */ 6, /* 237 */ 6, /* 238 */ 7, /* 239 */\n+  4, /* 240 */ 5, /* 241 */ 5, /* 242 */ 6, /* 243 */ 5, /* 244 */\n+  6, /* 245 */ 6, /* 246 */ 7, /* 247 */ 5, /* 248 */ 6, /* 249 */\n+  6, /* 250 */ 7, /* 251 */ 6, /* 252 */ 7, /* 253 */ 7, /* 254 */\n+  8  /* 255 */\n+}; // end _S_bit_count\n+\n+template<bool __dummy>\n+unsigned char _First_one<__dummy>::_S_first_one[] = {\n+  0, /*   0 */ 0, /*   1 */ 1, /*   2 */ 0, /*   3 */ 2, /*   4 */\n+  0, /*   5 */ 1, /*   6 */ 0, /*   7 */ 3, /*   8 */ 0, /*   9 */\n+  1, /*  10 */ 0, /*  11 */ 2, /*  12 */ 0, /*  13 */ 1, /*  14 */\n+  0, /*  15 */ 4, /*  16 */ 0, /*  17 */ 1, /*  18 */ 0, /*  19 */\n+  2, /*  20 */ 0, /*  21 */ 1, /*  22 */ 0, /*  23 */ 3, /*  24 */\n+  0, /*  25 */ 1, /*  26 */ 0, /*  27 */ 2, /*  28 */ 0, /*  29 */\n+  1, /*  30 */ 0, /*  31 */ 5, /*  32 */ 0, /*  33 */ 1, /*  34 */\n+  0, /*  35 */ 2, /*  36 */ 0, /*  37 */ 1, /*  38 */ 0, /*  39 */\n+  3, /*  40 */ 0, /*  41 */ 1, /*  42 */ 0, /*  43 */ 2, /*  44 */\n+  0, /*  45 */ 1, /*  46 */ 0, /*  47 */ 4, /*  48 */ 0, /*  49 */\n+  1, /*  50 */ 0, /*  51 */ 2, /*  52 */ 0, /*  53 */ 1, /*  54 */\n+  0, /*  55 */ 3, /*  56 */ 0, /*  57 */ 1, /*  58 */ 0, /*  59 */\n+  2, /*  60 */ 0, /*  61 */ 1, /*  62 */ 0, /*  63 */ 6, /*  64 */\n+  0, /*  65 */ 1, /*  66 */ 0, /*  67 */ 2, /*  68 */ 0, /*  69 */\n+  1, /*  70 */ 0, /*  71 */ 3, /*  72 */ 0, /*  73 */ 1, /*  74 */\n+  0, /*  75 */ 2, /*  76 */ 0, /*  77 */ 1, /*  78 */ 0, /*  79 */\n+  4, /*  80 */ 0, /*  81 */ 1, /*  82 */ 0, /*  83 */ 2, /*  84 */\n+  0, /*  85 */ 1, /*  86 */ 0, /*  87 */ 3, /*  88 */ 0, /*  89 */\n+  1, /*  90 */ 0, /*  91 */ 2, /*  92 */ 0, /*  93 */ 1, /*  94 */\n+  0, /*  95 */ 5, /*  96 */ 0, /*  97 */ 1, /*  98 */ 0, /*  99 */\n+  2, /* 100 */ 0, /* 101 */ 1, /* 102 */ 0, /* 103 */ 3, /* 104 */\n+  0, /* 105 */ 1, /* 106 */ 0, /* 107 */ 2, /* 108 */ 0, /* 109 */\n+  1, /* 110 */ 0, /* 111 */ 4, /* 112 */ 0, /* 113 */ 1, /* 114 */\n+  0, /* 115 */ 2, /* 116 */ 0, /* 117 */ 1, /* 118 */ 0, /* 119 */\n+  3, /* 120 */ 0, /* 121 */ 1, /* 122 */ 0, /* 123 */ 2, /* 124 */\n+  0, /* 125 */ 1, /* 126 */ 0, /* 127 */ 7, /* 128 */ 0, /* 129 */\n+  1, /* 130 */ 0, /* 131 */ 2, /* 132 */ 0, /* 133 */ 1, /* 134 */\n+  0, /* 135 */ 3, /* 136 */ 0, /* 137 */ 1, /* 138 */ 0, /* 139 */\n+  2, /* 140 */ 0, /* 141 */ 1, /* 142 */ 0, /* 143 */ 4, /* 144 */\n+  0, /* 145 */ 1, /* 146 */ 0, /* 147 */ 2, /* 148 */ 0, /* 149 */\n+  1, /* 150 */ 0, /* 151 */ 3, /* 152 */ 0, /* 153 */ 1, /* 154 */\n+  0, /* 155 */ 2, /* 156 */ 0, /* 157 */ 1, /* 158 */ 0, /* 159 */\n+  5, /* 160 */ 0, /* 161 */ 1, /* 162 */ 0, /* 163 */ 2, /* 164 */\n+  0, /* 165 */ 1, /* 166 */ 0, /* 167 */ 3, /* 168 */ 0, /* 169 */\n+  1, /* 170 */ 0, /* 171 */ 2, /* 172 */ 0, /* 173 */ 1, /* 174 */\n+  0, /* 175 */ 4, /* 176 */ 0, /* 177 */ 1, /* 178 */ 0, /* 179 */\n+  2, /* 180 */ 0, /* 181 */ 1, /* 182 */ 0, /* 183 */ 3, /* 184 */\n+  0, /* 185 */ 1, /* 186 */ 0, /* 187 */ 2, /* 188 */ 0, /* 189 */\n+  1, /* 190 */ 0, /* 191 */ 6, /* 192 */ 0, /* 193 */ 1, /* 194 */\n+  0, /* 195 */ 2, /* 196 */ 0, /* 197 */ 1, /* 198 */ 0, /* 199 */\n+  3, /* 200 */ 0, /* 201 */ 1, /* 202 */ 0, /* 203 */ 2, /* 204 */\n+  0, /* 205 */ 1, /* 206 */ 0, /* 207 */ 4, /* 208 */ 0, /* 209 */\n+  1, /* 210 */ 0, /* 211 */ 2, /* 212 */ 0, /* 213 */ 1, /* 214 */\n+  0, /* 215 */ 3, /* 216 */ 0, /* 217 */ 1, /* 218 */ 0, /* 219 */\n+  2, /* 220 */ 0, /* 221 */ 1, /* 222 */ 0, /* 223 */ 5, /* 224 */\n+  0, /* 225 */ 1, /* 226 */ 0, /* 227 */ 2, /* 228 */ 0, /* 229 */\n+  1, /* 230 */ 0, /* 231 */ 3, /* 232 */ 0, /* 233 */ 1, /* 234 */\n+  0, /* 235 */ 2, /* 236 */ 0, /* 237 */ 1, /* 238 */ 0, /* 239 */\n+  4, /* 240 */ 0, /* 241 */ 1, /* 242 */ 0, /* 243 */ 2, /* 244 */\n+  0, /* 245 */ 1, /* 246 */ 0, /* 247 */ 3, /* 248 */ 0, /* 249 */\n+  1, /* 250 */ 0, /* 251 */ 2, /* 252 */ 0, /* 253 */ 1, /* 254 */\n+  0, /* 255 */\n+}; // end _First_one\n+\n+#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n+#pragma reset woff 1209\n+#endif\n+\n+__STL_END_NAMESPACE\n+\n+\n+#undef __BITS_PER_WORDT\n+#undef __BITSET_WORDS\n+\n+#endif /* _CPP_BITSET */\n+\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "c1aefa6abb3d33065a4c77d129be1b3a3afa3df5", "filename": "libstdc++-v3/bits/std_cassert.h", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_cassert.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_cassert.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_cassert.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,38 @@\n+// -*- C++ -*- forwarding header.\n+\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 19.2  Assertions\n+//\n+\n+// Note: This is not a conforming implementation.\n+\n+// No include guards on this header...\n+\n+# include_next <assert.h>"}, {"sha": "b3ce7d993056ac08b513eb03e01aa98cadc69be0", "filename": "libstdc++-v3/bits/std_cctype.h", "status": "added", "additions": 210, "deletions": 0, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_cctype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_cctype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_cctype.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,210 @@\n+// -*- C++ -*- forwarding header.\n+\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: <ccytpe>\n+//\n+\n+#ifndef _CPP_CCTYPE\n+#define _CPP_CCTYPE 1\n+\n+// This keeps isanum, et al from being propagated as macros.\n+#if __linux__\n+#define __NO_CTYPE 1\n+#endif\n+\n+# include_next <ctype.h>\n+\n+// Sequester the C non-inline implementations in the _C_Swamp::\n+// namespace, and provide C++ inlines for them in the std:: namespace\n+// where they belong.\n+\n+namespace std \n+{\n+  // NB: If not using namespaces, can't have any of these definitions,\n+  // as they will duplicate what's in the global namespace. \n+\n+#ifdef toupper\n+  inline int \n+  _S_toupper_helper(int __c) { return toupper(__c); }\n+# undef toupper\n+  inline int \n+  toupper(int __c) { return _S_toupper_helper(__c); }\n+#elif _GLIBCPP_USE_NAMESPACES \n+  inline int \n+  toupper(int __c) { return ::toupper(__c); }\n+#endif\n+\n+#ifdef tolower\n+  inline int \n+  _S_tolower_helper(int __c) { return tolower(__c); }\n+# undef tolower\n+  inline int \n+  tolower(int __c) { return _S_tolower_helper(__c); }\n+#elif _GLIBCPP_USE_NAMESPACES \n+  inline int \n+  tolower(int __c) { return ::tolower(__c); }\n+#endif\n+\n+#ifdef isspace\n+  inline int \n+  _S_isspace_helper(int __c) { return isspace(__c); }\n+# undef isspace\n+  inline int \n+  isspace(int __c) { return _S_isspace_helper(__c); }\n+#elif _GLIBCPP_USE_NAMESPACES \n+  inline int \n+  isspace(int __c) { return ::isspace(__c); }\n+#endif\n+\n+#ifdef isprint\n+  inline int \n+  _S_isprint_helper(int __c) { return isprint(__c); }\n+# undef isprint\n+  inline int \n+  isprint(int __c) { return _S_isprint_helper(__c); }\n+#elif _GLIBCPP_USE_NAMESPACES \n+  inline int \n+  isprint(int __c) { return ::isprint(__c); }\n+#endif\n+\n+#ifdef iscntrl\n+  inline int \n+  _S_iscntrl_helper(int __c) { return iscntrl(__c); }\n+# undef iscntrl\n+  inline int \n+  iscntrl(int __c) { return _S_iscntrl_helper(__c); }\n+#elif _GLIBCPP_USE_NAMESPACES \n+  inline int \n+  iscntrl(int __c) { return ::iscntrl(__c); }\n+#endif\n+\n+#ifdef isupper\n+  inline int \n+  _S_isupper_helper(int __c) { return isupper(__c); }\n+# undef isupper\n+  inline int \n+  isupper(int __c) { return _S_isupper_helper(__c); }\n+#elif _GLIBCPP_USE_NAMESPACES \n+  inline int \n+  isupper(int __c) { return ::isupper(__c); }\n+#endif\n+\n+#ifdef islower\n+  inline int \n+  _S_islower_helper(int __c) { return islower(__c); }\n+# undef islower\n+  inline int \n+  islower(int __c) { return _S_islower_helper(__c); }\n+#elif _GLIBCPP_USE_NAMESPACES \n+  inline int \n+  islower(int __c) { return ::islower(__c); }\n+#endif\n+\n+#ifdef isalpha\n+  inline int \n+  _S_isalpha_helper(int __c) { return isalpha(__c); }\n+# undef isalpha\n+  inline int \n+  isalpha(int __c) { return _S_isalpha_helper(__c); }\n+#elif _GLIBCPP_USE_NAMESPACES \n+  inline int \n+  isalpha(int __c) { return ::isalpha(__c); }\n+#endif\n+\n+#ifdef isdigit\n+  inline int \n+  _S_isdigit_helper(int __c) { return isdigit(__c); }\n+# undef isdigit\n+  inline int \n+  isdigit(int __c) { return _S_isdigit_helper(__c); }\n+#elif _GLIBCPP_USE_NAMESPACES \n+  inline int \n+  isdigit(int __c) { return ::isdigit(__c); }\n+#endif\n+\n+#ifdef ispunct\n+  inline int \n+  _S_ispunct_helper(int __c) { return ispunct(__c); }\n+# undef ispunct\n+  inline int \n+  ispunct(int __c) { return _S_ispunct_helper(__c); }\n+#elif _GLIBCPP_USE_NAMESPACES \n+  inline int \n+  ispunct(int __c) { return ::ispunct(__c); }\n+#endif\n+\n+#ifdef isxdigit\n+  inline int \n+  _S_isxdigit_helper(int __c) { return isxdigit(__c); }\n+# undef isxdigit\n+  inline int \n+  isxdigit(int __c) { return _S_isxdigit_helper(__c); }\n+#elif _GLIBCPP_USE_NAMESPACES \n+  inline int \n+  isxdigit(int __c) { return ::isxdigit(__c); }\n+#endif\n+\n+#ifdef isalnum\n+  inline int \n+  _S_isalnum_helper(int __c) { return isalnum(__c); }\n+# undef isalnum\n+  inline int \n+  isalnum(int __c) { return _S_isalnum_helper(__c); }\n+#elif _GLIBCPP_USE_NAMESPACES \n+  inline int \n+  isalnum(int __c) { return ::isalnum(__c); }\n+#endif\n+\n+#ifdef isgraph\n+  inline int \n+  _S_isgraph_helper(int __c) { return isgraph(__c); }\n+# undef isgraph\n+  inline int \n+  isgraph(int __c) { return _S_isgraph_helper(__c); }\n+#elif _GLIBCPP_USE_NAMESPACES \n+  inline int \n+  isgraph(int __c) { return ::isgraph(__c); }\n+#endif\n+\n+} // namespace std\n+\n+#endif // _CPP_CCTYPE\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+"}, {"sha": "fda202d1e4fee122dec1f660b9851b7f86ccbf8a", "filename": "libstdc++-v3/bits/std_cerrno.h", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_cerrno.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_cerrno.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_cerrno.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,39 @@\n+// The -*- C++ -*- error number header.\n+\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 19.3  Error numbers\n+//\n+\n+// Note: this is not a conforming implementation.\n+\n+#ifndef _CPP_CERRNO\n+#define _CPP_CERRNO 1\n+# include_next <errno.h>\n+#endif"}, {"sha": "869c452eb3f01bf87986427b5a1b0b0840ab3338", "filename": "libstdc++-v3/bits/std_cfloat.h", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_cfloat.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_cfloat.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_cfloat.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,46 @@\n+// -*- C++ -*- forwarding header.\n+\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 18.2.2  Implementation properties: C library\n+//\n+\n+// Note: this is not a conforming implementation.\n+\n+#ifndef _CPP_CFLOAT\n+#define _CPP_CFLOAT 1\n+# include_next <float.h>\n+\n+#if 0\n+# ifdef __GLIBC__\n+// For GNU libc we must also include this one:\n+#  include <fenv.h>\n+# endif\n+#endif\n+#endif"}, {"sha": "4f8935a7001660c536add7d3433c9512296228f6", "filename": "libstdc++-v3/bits/std_ciso646.h", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_ciso646.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_ciso646.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_ciso646.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,71 @@\n+// ciso646 -*- C++ -*-\n+\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: <ciso646>\n+//\n+\n+#ifndef _CPP_ISO646\n+#define _CPP_ISO646\t1\n+\n+namespace std {\n+\n+  // 2.11 Keywords\n+  // alternative representations\n+  // and, and_eq, bitand, bitor, compl, not, not_eq, or, or_eq, xor, xor_eq\n+\n+#ifndef __cplusplus\n+#define and\t&&\n+#define and_eq\t&=\n+#define bitand\t&\n+#define bitor\t|\n+#define compl\t~\n+#define not\t!\n+#define not_eq\t!=\n+#define or\t||\n+#define or_eq\t|=\n+#define xor\t^\n+#define xor_eq\t^=\n+#endif\n+\n+#if 0\n+  template<typename _T1, typename _T2>\n+    inline bool\n+    operator and(const _T1& __lhs, const _T2& __rhs) \n+    { return (static_cast<bool>(__lhs) && static_cast<bool>(__rhs)); }\n+\n+  template<typename _T1, typename _T2>\n+    inline bool\n+    operator or(const _T1& __lhs, const _T2& __rhs) \n+    { return (static_cast<bool>(__lhs) || static_cast<bool>(__rhs)); }\n+#endif\n+\n+} // namespace std\n+\n+#endif // _CPP_ISO646"}, {"sha": "0638ec22cc8a332b933185a2ef1e4f09371ae27e", "filename": "libstdc++-v3/bits/std_climits.h", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_climits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_climits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_climits.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,39 @@\n+// -*- C++ -*- forwarding header.\n+\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 18.2.2  Implementation properties: C library\n+//\n+\n+// Note: this is not a conforming implementation.\n+\n+#ifndef _CPP_CLIMITS\n+#define _CPP_CLIMITS\t1\n+# include_next <limits.h>\n+#endif"}, {"sha": "acadfd710890b7fc810f7e2b0e3712700ed58c34", "filename": "libstdc++-v3/bits/std_clocale.h", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_clocale.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_clocale.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_clocale.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,40 @@\n+// -*- C++ -*- forwarding header.\n+\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 18.2.2  Implementation properties: C library\n+//\n+\n+// Note: this is not a conforming implementation.\n+\n+#ifndef _CPP_CLOCALE\n+#define _CPP_CLOCALE     1\n+# include_next <locale.h>\n+#endif\n+"}, {"sha": "04b018ff043b02cd91cbb49237ec3efe29a0ce08", "filename": "libstdc++-v3/bits/std_cmath.h", "status": "added", "additions": 247, "deletions": 0, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_cmath.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_cmath.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_cmath.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,247 @@\n+// -*- C++ -*- C math library.\n+\n+// Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 26.5  C library\n+//\n+\n+// Note: this is not a conforming implementation.\n+\n+#ifndef _CPP_CMATH\n+#define _CPP_CMATH 1\n+# include_next <math.h>\n+# include_next <stdlib.h>\n+\n+#include <bits/c++config.h>\n+\n+namespace std {\n+\n+    inline long\n+    abs(long __l) { return ::labs(__l); }\n+\n+    inline ldiv_t\n+    div(long __a, long __b) { return ::ldiv(__a, __b); }\n+\n+    // double\n+    inline double\n+    abs(double __x) { return ::fabs(__x); }\n+\n+    double\n+    pow(double, int);\n+\n+    // float\n+    inline float\n+    ceil(float __x) { return ::ceil(static_cast<double>(__x)); }\n+\n+    inline float\n+    floor(float __x) { return ::floor(static_cast<double>(__x)); }\n+\n+    inline float\n+    fmod(float __x, float __y) \n+    { return ::fmod(static_cast<double>(__x), static_cast<double>(__y)); }\n+\n+    inline float\n+    frexp(float __x, int* __p) \n+    { return ::frexp(static_cast<double>(__x), __p); }\n+\n+    inline float\n+    ldexp(float __x, int __i) \n+    { return ::ldexp(static_cast<double>(__x), __i); }\n+\n+    inline float\n+    pow(float __x, float __y) \n+    { return ::pow(static_cast<double>(__x), static_cast<double>(__y)); }\n+\n+    float\n+    pow(float, int); \n+\n+#if _GLIBCPP_HAVE_ABSF\n+    inline float\n+    abs(float __x) { return ::absf(__x); }\n+#else\n+    inline float\n+    abs(float __x) { return ::fabs(static_cast<double>(__x)); }\n+#endif\n+\n+#if _GLIBCPP_HAVE_ACOSF\n+    inline float\n+    acos(float __x) { return ::acosf(__x); }\n+#else\n+    inline float\n+    acos(float __x) { return ::acos(static_cast<double>(__x)); }\n+#endif\n+\n+#if _GLIBCPP_HAVE_ASINF\n+    inline float\n+    asin(float __x) { return ::asinf(__x); }\n+#else\n+    inline float\n+    asin(float __x) { return ::asin(static_cast<double>(__x)); }\n+#endif\n+\n+#if _GLIBCPP_HAVE_ATANF\n+    inline float\n+    atan(float __x) { return ::atanf(__x); }\n+#else\n+    inline float\n+    atan(float __x) { return ::atan(static_cast<double>(__x)); }\n+#endif\n+\n+#if _GLIBCPP_HAVE_ATAN2F\n+    inline float\n+    atan2(float __x, float __y) { return ::atan2f(__x, __y); }\n+#else\n+    inline float\n+    atan2(float __x, float __y) \n+    { return ::atan2(static_cast<double>(__x), static_cast<double>(__y)); }\n+#endif\n+\n+#if _GLIBCPP_HAVE_TANF\n+    inline float\n+    tan(float __x) { return ::tanf(__x); }\n+#else\n+    inline float\n+    tan(float __x) { return ::tan(static_cast<double>(__x)); }\n+#endif\n+\n+#if _GLIBCPP_HAVE_SINHF\n+    inline float\n+    sinh(float __x) { return ::sinhf(__x); }\n+#else\n+    inline float\n+    sinh(float __x) { return ::sinh(static_cast<double>(__x)); }\n+#endif\n+\n+#if _GLIBCPP_HAVE_TANHF\n+    inline float\n+    tanh(float __x) { return ::tanhf(__x); }\n+#else\n+    inline float\n+    tanh(float __x) { return ::tanh(static_cast<double>(__x)); }\n+#endif\n+\n+#if _GLIBCPP_HAVE_COSHF\n+    inline float\n+    cosh(float __x) { return ::coshf(__x); }\n+#else\n+    inline float\n+    cosh(float __x) { return ::cosh(static_cast<double>(__x)); }\n+#endif\n+ \n+#if _GLIBCPP_HAVE_EXPF\n+    inline float\n+    exp(float __x) { return ::expf(__x); }\n+#else\n+    inline float\n+    exp(float __x) { return ::exp(static_cast<double>(__x)); }\n+#endif\n+\n+#if _GLIBCPP_HAVE_LOGF\n+    inline float\n+    log(float __x) { return ::logf(__x); }\n+#else\n+    inline float\n+    log(float __x) { return ::log(static_cast<double>(__x)); }\n+#endif\n+\n+#if _GLIBCPP_HAVE_LOG10F\n+    inline float\n+    log10(float __x) { return ::log10f(__x); }\n+#else\n+    inline float\n+    log10(float __x) { return ::log10(static_cast<double>(__x)); }\n+#endif\n+\n+#if _GLIBCPP_HAVE_MODFF\n+    inline float\n+    modf(float __x, float* __p) { return ::modff(__x, __p); }\n+#else\n+    inline float\n+    modf(float __x, float* __p) \n+    {\n+      double __tmp;\n+      double __res = ::modf(static_cast<double>(__x), &__tmp);\n+      *__p = static_cast<float> (__tmp);\n+      return __res;\n+    }\n+#endif\n+\n+#if GLIBCPP_HAS_BUILTIN_SINF\n+    inline float\n+    sin(float __x) { return __builtin_sinf(__x); }\n+#elif _GLIBCPP_HAVE_SINF\n+    inline float\n+    sin(float __x) { return ::sinf(__x); }\n+#else\n+    inline float\n+    sin(float __x) { return ::sin(static_cast<double>(__x)); }\n+#endif\n+\n+#if GLIBCPP_HAS_BUILTIN_COSF\n+    inline float\n+    cos(float __x) { return __builtin_cosf(__x); }\n+#elif _GLIBCPP_HAVE_COSF\n+    inline float\n+    cos(float __x) { return ::cosf(__x); }\n+#else\n+    inline float\n+    cos(float __x) { return ::cos(static_cast<double>(__x)); }\n+#endif\n+\n+#if GLIBCPP_HAS_BUILTIN_FABSF\n+    inline float\n+    fabs(float __x) { return __builtin_fabsf(__x); }\n+#elif _GLIBCPP_HAVE_FABSF\n+    inline float\n+    fabs(float __x) { return ::fabsf(__x); }\n+#else\n+    inline float\n+    fabs(float __x) { return ::fabs(static_cast<double>(__x)); }\n+#endif\n+\n+#if GLIBCPP_HAS_BUILTIN_SQRTF\n+    inline float\n+    sqrt(float __x) { return __builtin_sqrtf(__x); }\n+#elif _GLIBCPP_HAVE_SQRTF\n+    inline float\n+    sqrt(float __x) { return ::sqrtf(__x); }\n+#else\n+    inline float\n+    sqrt(float __x) { return ::fabs(static_cast<double>(__x)); }\n+#endif\n+\n+    // XXX long double\n+    long double\n+    pow(long double, int);\n+\n+} // std\n+\n+#endif // _CPP_CMATH\n+\n+"}, {"sha": "5064efad1a1c55f36f63cb90cfa24d8019fdf372", "filename": "libstdc++-v3/bits/std_complex.h", "status": "added", "additions": 966, "deletions": 0, "changes": 966, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_complex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_complex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_complex.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,966 @@\n+// The template and inlines for the -*- C++ -*- complex number classes.\n+\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO 14882/26.2.1\n+// Note: this is not a conforming implementation.\n+// Initially implemented by Ulrich Drepper <drepper@cygnus.com>\n+// Improved by Gabriel Dos Reis <dosreis@cmla.ens-cachan.fr>\n+//\n+\n+#ifndef _CPP_COMPLEX\n+#define _CPP_COMPLEX\t1\n+\n+#include <bits/c++config.h>\n+#include <bits/std_iosfwd.h>\n+\n+\n+namespace std\n+{\n+    // Forward declarations\n+    template<typename _Tp> class complex;\n+    template<> class complex<float>;\n+    template<> class complex<double>;\n+    template<> class complex<long double>;\n+\n+    template<typename _Tp> _Tp abs(const complex<_Tp>&);\n+    template<typename _Tp>  _Tp arg(const complex<_Tp>&);\n+\n+    template<typename _Tp> complex<_Tp> conj(const complex<_Tp>&);\n+    template<typename _Tp> complex<_Tp> polar(const _Tp&, const _Tp&);\n+\n+    // Transcendentals:\n+    template<typename _Tp> complex<_Tp> cos(const complex<_Tp>&);\n+    template<typename _Tp> complex<_Tp> cosh(const complex<_Tp>&);\n+    template<typename _Tp> complex<_Tp> exp(const complex<_Tp>&);\n+    template<typename _Tp> complex<_Tp> log(const complex<_Tp>&);\n+    template<typename _Tp> complex<_Tp> log10(const complex<_Tp>&);\n+    template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&, int);\n+    template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&, const _Tp&);\n+    template<typename _Tp> complex<_Tp> pow (const complex<_Tp>&,\n+                                             const complex<_Tp>&);\n+    template<typename _Tp> complex<_Tp> pow(const _Tp&, const complex<_Tp>&);\n+    template<typename _Tp> complex<_Tp> sin(const complex<_Tp>&);\n+    template<typename _Tp> complex<_Tp> sinh(const complex<_Tp>&);\n+    template<typename _Tp> complex<_Tp> sqrt(const complex<_Tp>&);\n+    template<typename _Tp> complex<_Tp> tan(const complex<_Tp>&);\n+    template<typename _Tp> complex<_Tp> tanh(const complex<_Tp>&);\n+    \n+    \n+    //\n+    // 26.2.2  Primary template class complex\n+    //\n+    template <typename _Tp>\n+    class complex\n+    {\n+    public:\n+        typedef _Tp value_type;\n+\n+        complex (const _Tp& = _Tp(), const _Tp & = _Tp());\n+\n+        // Let's the compiler synthetize the copy constructor   \n+        // complex (const complex<_Tp>&);\n+\n+        template <typename _Up>\n+           complex (const complex<_Up>&);\n+        \n+        _Tp real () const;\n+        _Tp imag () const;\n+\n+        complex<_Tp>& operator= (const _Tp&);\n+        complex<_Tp>& operator+= (const _Tp&);\n+        complex<_Tp>& operator-= (const _Tp&);\n+        complex<_Tp>& operator*= (const _Tp&);\n+        complex<_Tp>& operator/= (const _Tp&);\n+\n+        // Let's the compiler synthetize the\n+        // copy and assignment operator\n+        // complex<_Tp>& operator= (const complex<_Tp>&);\n+\n+        template <typename _Up>\n+           complex<_Tp>& operator= (const complex<_Up>&);\n+        template <typename _Up>\n+           complex<_Tp>& operator+= (const complex<_Up>&);\n+        template <typename _Up>\n+           complex<_Tp>& operator-= (const complex<_Up>&);\n+        template <typename _Up>\n+           complex<_Tp>& operator*= (const complex<_Up>&);\n+        template <typename _Up>\n+           complex<_Tp>& operator/= (const complex<_Up>&);\n+\n+    private:\n+        _Tp _M_real, _M_imag;\n+    };\n+\n+    template<typename _Tp>\n+    inline _Tp\n+    complex<_Tp>::real() const { return _M_real; }\n+\n+    template<typename _Tp>\n+    inline _Tp\n+    complex<_Tp>::imag() const { return _M_imag; }\n+\n+    \n+    //\n+    // 26.2.3  complex specializations\n+    //\n+\n+    //\n+    // complex<float> specialization\n+    //\n+    template<> class complex<float>\n+    {\n+    public:\n+        typedef float value_type;\n+\n+        complex(float = 0.0f, float = 0.0f);\n+#ifdef _GLIBCPP_BUGGY_COMPLEX\n+\tcomplex(const complex& __z) : _M_value(__z._M_value) {}\n+#endif\n+        explicit complex(const complex<double>&);\n+        explicit complex(const complex<long double>&);\n+\n+        float real() const;\n+        float imag() const;\n+\n+        complex<float>& operator= (float);\n+        complex<float>& operator+= (float);\n+        complex<float>& operator-= (float);\n+        complex<float>& operator*= (float);\n+        complex<float>& operator/= (float);\n+        \n+        // Let's the compiler synthetize the copy and assignment\n+        // operator.  It always does a pretty good job.\n+        // complex& operator= (const complex&);\n+\n+        template <typename _Tp>\n+           complex<float>&operator= (const complex<_Tp>&);\n+        template <typename _Tp>\n+           complex<float>& operator+= (const complex<_Tp>&);\n+        template <class _Tp>\n+           complex<float>& operator-= (const complex<_Tp>&);\n+        template <class _Tp>\n+           complex<float>& operator*= (const complex<_Tp>&);\n+        template <class _Tp>\n+           complex<float>&operator/= (const complex<_Tp>&);\n+\n+    private:\n+        typedef __complex__ float _ComplexT;\n+        _ComplexT _M_value;\n+\n+        complex(_ComplexT __z) : _M_value(__z) {}\n+        \n+        friend class complex<double>;\n+        friend class complex<long double>;\n+\n+        friend float abs<>(const complex<float>&);\n+        friend float arg<>(const complex<float>&);\n+\n+        friend complex<float> conj<>(const complex<float>&);\n+\n+        friend complex<float> cos<>(const complex<float>&);\n+        friend complex<float> cosh<>(const complex<float>&);\n+        friend complex<float> exp<>(const complex<float>&);\n+        friend complex<float> log<>(const complex<float>&);\n+        friend complex<float> log10<>(const complex<float>&);\n+        friend complex<float> pow<>(const complex<float>&, int);\n+        friend complex<float> pow<>(const complex<float>&, const float&);\n+        friend complex<float> pow<>(const complex<float>&,\n+                                    const complex<float>&);\n+        friend complex<float> pow<>(const float&, const complex<float>&);\n+        friend complex<float> sin<>(const complex<float>&);\n+        friend complex<float> sinh<>(const complex<float>&);\n+        friend complex<float> sqrt<>(const complex<float>&);\n+        friend complex<float> tan<>(const complex<float>&);\n+        friend complex<float> tanh<>(const complex<float>&);\n+  };\n+\n+    inline float\n+    complex<float>::real() const\n+    { return __real__ _M_value; }\n+\n+    inline float\n+    complex<float>::imag() const\n+    { return __imag__ _M_value; }\n+\n+\n+    //\n+    // complex<double> specialization\n+    //\n+    template<> class complex<double>\n+    {\n+    public:\n+        typedef double value_type;\n+\n+        complex(double  =0.0, double =0.0);\n+#ifdef _GLIBCPP_BUGGY_COMPLEX\n+\tcomplex(const complex& __z) : _M_value(__z._M_value) {}\n+#endif\n+        complex(const complex<float>&);\n+        explicit complex(const complex<long double>&);\n+        \n+        double real () const;\n+        double imag () const;\n+        \n+        complex<double>& operator= (double);\n+        complex<double>& operator+= (double);\n+        complex<double>& operator-= (double);\n+        complex<double>& operator*= (double);\n+        complex<double>& operator/= (double);\n+\n+        // The compiler will synthetize this, efficiently.\n+        // complex& operator= (const complex&);\n+\n+        template <typename _Tp>\n+           complex<double>& operator= (const complex<_Tp>&);\n+        template <typename _Tp>\n+           complex<double>& operator+= (const complex<_Tp>&);\n+        template <typename _Tp>\n+           complex<double>& operator-= (const complex<_Tp>&);\n+        template <typename _Tp>\n+           complex<double>& operator*= (const complex<_Tp>&);\n+        template <typename _Tp>\n+        complex<double>& operator/= (const complex<_Tp>&);\n+\n+    private:\n+        typedef __complex__ double _ComplexT;\n+        _ComplexT _M_value;\n+\n+        complex(_ComplexT __z) : _M_value(__z) {}\n+        \n+        friend class complex<float>;\n+        friend class complex<long double>;\n+\n+        friend double abs<>(const complex<double>&);\n+        friend double arg<>(const complex<double>&);\n+\n+        friend complex<double> conj<>(const complex<double>&);\n+\n+        friend complex<double> cos<>(const complex<double>&);\n+        friend complex<double> cosh<>(const complex<double>&);\n+        friend complex<double> exp<>(const complex<double>&);\n+        friend complex<double> log<>(const complex<double>&);\n+        friend complex<double> log10<>(const complex<double>&);\n+        friend complex<double> pow<>(const complex<double>&, int);\n+        friend complex<double> pow<>(const complex<double>&, const double&);\n+        friend complex<double> pow<>(const complex<double>&,\n+                                    const complex<double>&);\n+        friend complex<double> pow<>(const double&, const complex<double>&);\n+        friend complex<double> sin<>(const complex<double>&);\n+        friend complex<double> sinh<>(const complex<double>&);\n+        friend complex<double> sqrt<>(const complex<double>&);\n+        friend complex<double> tan<>(const complex<double>&);\n+        friend complex<double> tanh<>(const complex<double>&);\n+    };\n+\n+    inline double\n+    complex<double>::real() const\n+    { return __real__ _M_value; }\n+\n+    inline double\n+    complex<double>::imag() const\n+    { return __imag__ _M_value; }\n+\n+\n+    //\n+    // complex<long double> specialization\n+    //\n+    template<> class complex<long double>\n+    {\n+    public:\n+        typedef long double value_type;\n+\n+        complex(long double = 0.0L, long double = 0.0L);\n+#ifdef _GLIBCPP_BUGGY_COMPLEX\n+\tcomplex(const complex& __z) : _M_value(__z._M_value) {}\n+#endif\n+        complex(const complex<float>&);\n+        complex(const complex<double>&);\n+\n+        long double real() const;\n+        long double imag() const;\n+\n+        complex<long double>& operator= (long double);\n+        complex<long double>& operator+= (long double);\n+        complex<long double>& operator-= (long double);\n+        complex<long double>& operator*= (long double);\n+        complex<long double>& operator/= (long double);\n+\n+        // The compiler knows how to do this efficiently\n+        // complex& operator= (const complex&);\n+\n+        template<typename _Tp>\n+           complex<long double>& operator= (const complex<_Tp>&);\n+        template<typename _Tp>\n+           complex<long double>& operator+= (const complex<_Tp>&);\n+        template<typename _Tp>\n+           complex<long double>& operator-= (const complex<_Tp>&);\n+        template<typename _Tp>\n+           complex<long double>& operator*= (const complex<_Tp>&);\n+        template<typename _Tp>\n+        complex<long double>& operator/= (const complex<_Tp>&);\n+\n+    private:\n+        typedef __complex__ long double _ComplexT;\n+        _ComplexT _M_value;\n+\n+        complex(_ComplexT __z) : _M_value(__z) {}\n+\n+        friend class complex<float>;\n+        friend class complex<double>;\n+\n+        friend long double abs<>(const complex<long double>&);\n+        friend long double arg<>(const complex<long double>&);\n+\n+        friend complex<long double> conj<>(const complex<long double>&);\n+\n+        friend complex<long double> cos<>(const complex<long double>&);\n+        friend complex<long double> cosh<>(const complex<long double>&);\n+        friend complex<long double> exp<>(const complex<long double>&);\n+        friend complex<long double> log<>(const complex<long double>&);\n+        friend complex<long double> log10<>(const complex<long double>&);\n+        friend complex<long double> pow<>(const complex<long double>&, int);\n+        friend complex<long double> pow<>(const complex<long double>&,\n+                                          const long double&);\n+        friend complex<long double> pow<>(const complex<long double>&,\n+                                    const complex<long double>&);\n+        friend complex<long double> pow<>(const long double&,\n+                                          const complex<long double>&);\n+        friend complex<long double> sin<>(const complex<long double>&);\n+        friend complex<long double> sinh<>(const complex<long double>&);\n+        friend complex<long double> sqrt<>(const complex<long double>&);\n+        friend complex<long double> tan<>(const complex<long double>&);\n+        friend complex<long double> tanh<>(const complex<long double>&);\n+    };\n+\n+    inline\n+    complex<long double>::complex(long double __r, long double __i)\n+    {\n+        __real__ _M_value = __r;\n+        __imag__ _M_value = __i;\n+    }\n+\n+    inline\n+    complex<long double>::complex(const complex<float>& __z)\n+            : _M_value(_ComplexT(__z._M_value)) {}\n+\n+    inline\n+    complex<long double>::complex(const complex<double>& __z)\n+            : _M_value(_ComplexT(__z._M_value)) {}\n+\n+    inline long double\n+    complex<long double>::real() const\n+    { return __real__ _M_value; }\n+\n+    inline long double\n+    complex<long double>::imag() const\n+    { return __imag__ _M_value; }\n+\n+    inline complex<long double>&\n+    complex<long double>::operator= (long double __r)\n+    {\n+        __real__ _M_value = __r;\n+        __imag__ _M_value = 0.0L;\n+        return *this;\n+    }\n+\n+    inline complex<long double>&\n+    complex<long double>::operator+= (long double __r)\n+    {\n+        __real__ _M_value += __r;\n+        return *this;\n+    }\n+\n+    inline complex<long double>&\n+    complex<long double>::operator-= (long double __r)\n+    {\n+        __real__ _M_value -= __r;\n+        return *this;\n+    }\n+\n+    inline complex<long double>&\n+    complex<long double>::operator*= (long double __r)\n+    {\n+        __real__ _M_value *= __r;\n+        return *this;\n+    }\n+\n+    inline complex<long double>&\n+    complex<long double>::operator/= (long double __r)\n+    {\n+        __real__ _M_value /= __r;\n+        return *this;\n+    }\n+\n+    template<typename _Tp>\n+    inline complex<long double>&\n+    complex<long double>::operator= (const complex<_Tp>& __z)\n+    {\n+        __real__ _M_value = __z.real();\n+        __imag__ _M_value = __z.imag();\n+        return *this;\n+    }\n+\n+    template<typename _Tp>\n+    inline complex<long double>&\n+    complex<long double>::operator+= (const complex<_Tp>& __z)\n+    {\n+        __real__ _M_value += __z.real();\n+        __imag__ _M_value += __z.imag();\n+        return *this;\n+    }\n+\n+    template<typename _Tp>\n+    inline complex<long double>&\n+    complex<long double>::operator-= (const complex<_Tp>& __z)\n+    {\n+        __real__ _M_value -= __z.real();\n+        __imag__ _M_value -= __z.imag();\n+        return *this;\n+    }\n+    \n+    template<typename _Tp>\n+    inline complex<long double>&\n+    complex<long double>::operator*= (const complex<_Tp>& __z)\n+    {\n+        _ComplexT __t;\n+        __real__ __t = __z.real();\n+        __imag__ __t = __z.imag();\n+        _M_value *= __t;\n+        return *this;\n+    }\n+\n+    template<typename _Tp>\n+    inline complex<long double>&\n+    complex<long double>::operator/= (const complex<_Tp>& __z)\n+    {\n+        _ComplexT __t;\n+        __real__ __t = __z.real();\n+        __imag__ __t = __z.imag();\n+        _M_value /= __t;\n+        return *this;\n+    }\n+\n+    //\n+    // complex<float> continued.\n+    //\n+    inline\n+    complex<float>::complex(float r, float i)\n+    {\n+        __real__ _M_value = r;\n+        __imag__ _M_value = i;\n+    }\n+\n+    inline\n+    complex<float>::complex(const complex<double>& __z)\n+            : _M_value(_ComplexT(__z._M_value)) {}\n+\n+    inline\n+    complex<float>::complex(const complex<long double>& __z)\n+            : _M_value(_ComplexT(__z._M_value)) {}\n+\n+    inline complex<float>&\n+    complex<float>::operator= (float __f)\n+    {\n+        __real__ _M_value = __f;\n+        __imag__ _M_value = 0.0f;\n+        return *this;\n+    }\n+\n+    inline complex<float>&\n+    complex<float>::operator+= (float __f)\n+    {\n+        __real__ _M_value += __f;\n+        return *this;\n+    }\n+\n+    inline complex<float>&\n+    complex<float>::operator-= (float __f)\n+    {\n+        __real__ _M_value -= __f;\n+        return *this;\n+    }\n+\n+    inline complex<float>&\n+    complex<float>::operator*= (float __f)\n+    {\n+        _M_value *= __f;\n+        return *this;\n+    }\n+\n+    inline complex<float>&\n+    complex<float>::operator/= (float __f)\n+    {\n+        _M_value /= __f;\n+        return *this;\n+    }\n+\n+    template<typename _Tp>\n+    inline complex<float>&\n+    complex<float>::operator= (const complex<_Tp>& __z)\n+    {\n+        __real__ _M_value = __z.real();\n+        __imag__ _M_value = __z.imag();\n+        return *this;\n+    }\n+\n+    template<typename _Tp>\n+    inline complex<float>&\n+    complex<float>::operator+= (const complex<_Tp>& __z)\n+    {\n+        __real__ _M_value += __z.real();\n+        __imag__ _M_value += __z.imag();\n+        return *this;\n+    }\n+    \n+    template<typename _Tp>\n+    inline complex<float>&\n+    complex<float>::operator-= (const complex<_Tp>& __z)\n+    {\n+        __real__ _M_value -= __z.real();\n+        __imag__ _M_value -= __z.real();\n+        return *this;\n+    }\n+\n+    template<typename _Tp>\n+    inline complex<float>&\n+    complex<float>::operator*= (const complex<_Tp>& __z)\n+    {\n+        _ComplexT __t;\n+        __real__ __t = __z.real();\n+        __imag__ __t = __z.imag();\n+        _M_value *= __t;\n+        return *this;\n+    }\n+\n+    template<typename _Tp>\n+    inline complex<float>&\n+    complex<float>::operator/= (const complex<_Tp>& __z)\n+    {\n+        _ComplexT __t;\n+        __real__ __t = __z.real();\n+        __imag__ __t = __z.imag();\n+        _M_value /= __t;\n+        return *this;\n+    }\n+\n+\n+    //\n+    // complex<double> continued.\n+    //\n+    inline\n+    complex<double>::complex(double __r, double __i)\n+    {\n+        __real__ _M_value = __r;\n+        __imag__ _M_value = __i;\n+    }\n+\n+    inline\n+    complex<double>::complex(const complex<float>& __z)\n+            : _M_value(_ComplexT(__z._M_value)) {}\n+\n+    inline\n+    complex<double>::complex(const complex<long double>& __z)\n+    {\n+        __real__ _M_value = __z.real();\n+        __imag__ _M_value = __z.imag();\n+    }\n+\n+    inline complex<double>&\n+    complex<double>::operator= (double __d)\n+    {\n+        __real__ _M_value = __d;\n+        __imag__ _M_value = 0.0;\n+        return *this;\n+    }\n+\n+    inline complex<double>&\n+    complex<double>::operator+= (double __d)\n+    {\n+        __real__ _M_value += __d;\n+        return *this;\n+    }\n+\n+    inline complex<double>&\n+    complex<double>::operator-= (double __d)\n+    {\n+        __real__ _M_value -= __d;\n+        return *this;\n+    }\n+\n+    inline complex<double>&\n+    complex<double>::operator*= (double __d)\n+    {\n+        _M_value *= __d;\n+        return *this;\n+    }\n+\n+    inline complex<double>&\n+    complex<double>::operator/= (double __d)\n+    {\n+        _M_value /= __d;\n+        return *this;\n+    }\n+\n+    template<typename _Tp>\n+    inline complex<double>&\n+    complex<double>::operator= (const complex<_Tp>& __z)\n+    {\n+        __real__ _M_value = __z.real();\n+        __imag__ _M_value = __z.imag();\n+        return *this;\n+    }\n+    \n+    template<typename _Tp>\n+    inline complex<double>&\n+    complex<double>::operator+= (const complex<_Tp>& __z)\n+    {\n+        __real__ _M_value += __z.real();\n+        __imag__ _M_value += __z.imag();\n+        return *this;\n+    }\n+\n+    template<typename _Tp>\n+    inline complex<double>&\n+    complex<double>::operator-= (const complex<_Tp>& __z)\n+    {\n+        __real__ _M_value -= __z.real();\n+        __imag__ _M_value -= __z.imag();\n+        return *this;\n+    }\n+\n+    template<typename _Tp>\n+    inline complex<double>&\n+    complex<double>::operator*= (const complex<_Tp>& __z)\n+    {\n+        _ComplexT __t;\n+        __real__ __t = __z.real();\n+        __imag__ __t = __z.imag();\n+        _M_value *= __t;\n+        return *this;\n+    }\n+\n+    template<typename _Tp>\n+    inline complex<double>&\n+    complex<double>::operator/= (const complex<_Tp>& __z)\n+    {\n+        _ComplexT __t;\n+        __real__ __t = __z.real();\n+        __imag__ __t = __z.imag();\n+        _M_value /= __t;\n+        return *this;\n+    }\n+\n+    //\n+    // Primary template class complex continued.\n+    //\n+    // 26.2.4\n+    template<typename _Tp>\n+    inline \n+    complex<_Tp>::complex(const _Tp& __r, const _Tp& __i)\n+            : _M_real(__r), _M_imag(__i) {}\n+\n+    template<typename _Tp>\n+       template<typename _Up>\n+    inline \n+    complex<_Tp>::complex(const complex<_Up>& __z)\n+            : _M_real(__z.real()), _M_imag(__z.imag()) {}\n+\n+    // 26.2.7/6\n+    template<typename _Tp>\n+    inline complex<_Tp>\n+    conj(const complex<_Tp>& __z)\n+    { return complex<_Tp>(__z.real(), -__z.imag()); }\n+\n+    // 26.2.7/4\n+    template<typename _Tp>\n+    inline _Tp\n+    norm(const complex<_Tp>& __z)\n+    {\n+        // XXX: Grammar school computation\n+        return __z.real() * __z.real() + __z.imag() * __z.imag();\n+    }\n+        \n+    template<typename _Tp>\n+    complex<_Tp>&\n+    complex<_Tp>::operator= (const _Tp& __t)\n+    {\n+        _M_real = __t;\n+        _M_imag = _Tp();\n+        return *this;\n+    }\n+\n+    // 26.2.5/1\n+    template<typename _Tp>\n+    inline complex<_Tp>&\n+    complex<_Tp>::operator+= (const _Tp& __t)\n+    {\n+        _M_real += __t;\n+        return *this;\n+    }\n+\n+    // 26.2.5/3\n+    template<typename _Tp>\n+    inline complex<_Tp>&\n+    complex<_Tp>::operator-= (const _Tp& __t)\n+    {\n+        _M_real -= __t;\n+        return *this;\n+    }\n+\n+    // 26.2.5/5\n+    template<typename _Tp>\n+    complex<_Tp>&\n+    complex<_Tp>::operator*= (const _Tp& __t)\n+    {\n+        _M_real *= __t;\n+        _M_imag *= __t;\n+        return *this;\n+    }\n+\n+    // 26.2.5/7\n+    template<typename _Tp>\n+    complex<_Tp>&\n+    complex<_Tp>::operator/= (const _Tp& __t)\n+    {\n+        _M_real /= __t;\n+        _M_imag /= __t;\n+        return *this;\n+    }\n+\n+    template<typename _Tp>\n+       template<typename _Up>\n+    complex<_Tp>&\n+    complex<_Tp>::operator= (const complex<_Up>& __z)\n+    {\n+        _M_real = __z.real();\n+        _M_imag = __z.imag();\n+        return *this;\n+    }\n+\n+    // 26.2.5/9\n+    template<typename _Tp>\n+       template<typename _Up>\n+    complex<_Tp>&\n+    complex<_Tp>::operator+= (const complex<_Up>& __z)\n+    {\n+        _M_real += __z.real();\n+        _M_imag += __z.imag();\n+        return *this;\n+    }\n+\n+    // 26.2.5/11\n+    template<typename _Tp>\n+       template<typename _Up>\n+    complex<_Tp>&\n+    complex<_Tp>::operator-= (const complex<_Up>& __z)\n+    {\n+        _M_real -= __z.real();\n+        _M_imag -= __z.imag();\n+        return *this;\n+    }\n+\n+    // 26.2.5/13\n+    // XXX: this is a grammar school implementation.\n+    template<typename _Tp>\n+       template<typename _Up>\n+    complex<_Tp>&\n+    complex<_Tp>::operator*= (const complex<_Up>& __z)\n+    {\n+        _Tp __r = _M_real * __z.real() - _M_imag * __z.imag();\n+        _M_imag = _M_real * __z.imag() + _M_imag * __z.real();\n+        _M_real = __r;\n+        return *this;\n+    }\n+\n+    // 26.2.5/15\n+    // XXX: this is a grammar school implementation.\n+    template<typename _Tp>\n+       template<typename _Up>\n+    complex<_Tp>&\n+    complex<_Tp>::operator/= (const complex<_Up>& __z)\n+    {\n+        _Tp __r =  _M_real * __z.real() + _M_imag * __z.imag();\n+        _Tp __n = norm(__z);\n+        _M_imag = (_M_real * __z.imag() - _M_imag * __z.real()) / __n;\n+        _M_real = __r / __n;\n+        return *this;\n+    }\n+    \n+\n+    // Operators:\n+    template<typename _Tp>\n+    inline complex<_Tp>\n+    operator+(const complex<_Tp>& __x, const complex<_Tp>& __y)\n+    { return complex<_Tp> (__x) += __y; }\n+\n+    template<typename _Tp>\n+    inline complex<_Tp>\n+    operator+(const complex<_Tp>& __x, const _Tp& __y)\n+    { return complex<_Tp> (__x) += __y; }\n+\n+    template<typename _Tp>\n+    inline complex<_Tp>\n+    operator+(const _Tp& __x, const complex<_Tp>& __y)\n+    { return complex<_Tp> (__y) += __x; }\n+\n+    template<typename _Tp>\n+    inline complex<_Tp>\n+    operator-(const complex<_Tp>& __x, const complex<_Tp>& __y)\n+    { return complex<_Tp> (__x) -= __y; }\n+    \n+    template<typename _Tp>\n+    inline complex<_Tp>\n+    operator-(const complex<_Tp>& __x, const _Tp& __y)\n+    { return complex<_Tp> (__x) -= __y; }\n+\n+    template<typename _Tp>\n+    inline complex<_Tp>\n+    operator-(const _Tp& __x, const complex<_Tp>& __y)\n+    { return complex<_Tp> (__x) -= __y; }\n+\n+    template<typename _Tp>\n+    inline complex<_Tp>\n+    operator*(const complex<_Tp>& __x, const complex<_Tp>& __y)\n+    { return complex<_Tp> (__x) *= __y; }\n+\n+    template<typename _Tp>\n+    inline complex<_Tp>\n+    operator*(const complex<_Tp>& __x, const _Tp& __y)\n+    { return complex<_Tp> (__x) *= __y; }\n+\n+    template<typename _Tp>\n+    inline complex<_Tp>\n+    operator*(const _Tp& __x, const complex<_Tp>& __y)\n+    { return complex<_Tp> (__y) *= __x; }\n+\n+    template<typename _Tp>\n+    inline complex<_Tp>\n+    operator/(const complex<_Tp>& __x, const complex<_Tp>& __y)\n+    { return complex<_Tp> (__x) /= __y; }\n+    \n+    template<typename _Tp>\n+    inline complex<_Tp>\n+    operator/(const complex<_Tp>& __x, const _Tp& __y)\n+    { return complex<_Tp> (__x) /= __y; }\n+\n+    template<typename _Tp>\n+    inline complex<_Tp>\n+    operator/(const _Tp& __x, const complex<_Tp>& __y)\n+    { return complex<_Tp> (__x) /= __y; }\n+\n+    template<typename _Tp>\n+    inline complex<_Tp>\n+    operator+(const complex<_Tp>& __x)\n+    { return __x; }\n+\n+    template<typename _Tp>\n+    inline complex<_Tp>\n+    operator-(const complex<_Tp>& __x)\n+    {  return complex<_Tp>(-__x.real(), -__x.imag()); }\n+\n+    template<typename _Tp>\n+    inline bool\n+    operator==(const complex<_Tp>& __x, const complex<_Tp>& __y)\n+    { return __x.real() == __y.real() && __x.imag == __y.imag(); }\n+\n+    template<typename _Tp>\n+    inline bool\n+    operator==(const complex<_Tp>& __x, const _Tp& __y)\n+    { return __x.real() == __y && __x.imag() == 0; }\n+\n+    template<typename _Tp>\n+    inline bool\n+    operator==(const _Tp& __x, const complex<_Tp>& __y)\n+    { return __x == __y.real() && 0 == __y.imag(); }\n+\n+    template<typename _Tp>\n+    inline bool\n+    operator!=(const complex<_Tp>& __x, const complex<_Tp>& __y)\n+    { return __x.real() != __y.real() || __x.imag() != __y.imag(); }\n+\n+    template<typename _Tp>\n+    inline bool\n+    operator!=(const complex<_Tp>& __x, const _Tp& __y)\n+    {  return __x.real() != __y || __x.imag() != 0; }\n+\n+    template<typename _Tp>\n+    inline bool\n+    operator!=(const _Tp& __x, const complex<_Tp>& __y)\n+    { return __x != __y.real() || 0 != __y.imag(); }\n+\n+    template<typename _Tp, typename _CharT, class _Traits>\n+    basic_istream<_CharT, _Traits>&\n+    operator>>(basic_istream<_CharT, _Traits>&, complex<_Tp>&);\n+\n+    template<typename _Tp, typename _CharT, class _Traits>\n+    basic_ostream<_CharT, _Traits>&\n+    operator<<(basic_ostream<_CharT, _Traits>&, const complex<_Tp>&);\n+\n+\n+    // Values:\n+    template <typename _Tp>\n+    inline _Tp\n+    real (const complex<_Tp>& __z)\n+    { return __z.real(); }\n+    \n+    template <typename _Tp>\n+    inline _Tp\n+    imag (const complex<_Tp>& __z)\n+    { return __z.imag(); }\n+    \n+\n+    // We use here a few more specializations.\n+    template<>\n+    inline complex<float>\n+    conj(const complex<float> &__x)\n+#ifdef _GLIBCPP_BUGGY_FLOAT_COMPLEX\n+    {\n+      complex<float> __tmpf(~__x._M_value);\n+      return __tmpf;\n+    }\n+#else\n+    { return complex<float>(~__x._M_value); }\n+#endif\n+\n+    template<>\n+    inline complex<double>\n+    conj(const complex<double> &__x)\n+    {  return complex<double> (~__x._M_value); }\n+\n+    template<>\n+    inline complex<long double>\n+    conj(const complex<long double> &__x)\n+    {\n+        return complex<long double> (~__x._M_value);\n+    }\n+\n+} // namespace std\n+\n+#endif\t/* _CPP_COMPLEX */"}, {"sha": "e94488b85b82339b0da73faade1c57895885d146", "filename": "libstdc++-v3/bits/std_csetjmp.h", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_csetjmp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_csetjmp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_csetjmp.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,39 @@\n+// -*- C++ -*- forwarding header.\n+\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 20.4.6  C library\n+//\n+\n+// Note: this is not a conforming implementation.\n+\n+#ifndef _CPP_CSETJMP\n+#define _CPP_CSETJMP 1\n+# include_next <setjmp.h>\n+#endif"}, {"sha": "b300f5b0547b5a170a2f00f7409ae8bcce958d19", "filename": "libstdc++-v3/bits/std_csignal.h", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_csignal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_csignal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_csignal.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,39 @@\n+// -*- C++ -*- forwarding header.\n+\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 20.4.6  C library\n+//\n+\n+// Note: this is not a conforming implementation.\n+\n+#ifndef _CPP_CSIGNAL\n+#define _CPP_CSIGNAL 1\n+# include_next <signal.h>\n+#endif"}, {"sha": "5b0ca7d6e63845c01884dd0c6c716061f3fb15bd", "filename": "libstdc++-v3/bits/std_cstdarg.h", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_cstdarg.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_cstdarg.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_cstdarg.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,39 @@\n+// -*- C++ -*- forwarding header.\n+\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 20.4.6  C library\n+//\n+\n+// Note: this is not a conforming implementation.\n+\n+#ifndef _CPP_CSTDARG\n+#define _CPP_CSTDARG 1\n+# include_next <stdarg.h>\n+#endif"}, {"sha": "66a1b5d4a05a07d9de0e23652aa9231e3a874a48", "filename": "libstdc++-v3/bits/std_cstddef.h", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_cstddef.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_cstddef.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_cstddef.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946", "patch": "@@ -0,0 +1,39 @@\n+// -*- C++ -*- forwarding header.\n+\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 18.1  Types\n+//\n+\n+// Note: this is not a conforming implementation.\n+\n+#ifndef _CPP_CSTDDEF\n+#define _CPP_CSTDDEF 1\n+# include_next <stddef.h>\n+#endif"}, {"sha": "aec526d1b623ed6c443d9f5e967052d413b2da99", "filename": "libstdc++-v3/bits/std_cstdio.h", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_cstdio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_cstdio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_cstdio.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "adbefa2ad77366dbd5bee83724d259d34d5eed36", "filename": "libstdc++-v3/bits/std_cstdlib.h", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_cstdlib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_cstdlib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_cstdlib.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "c076b6a12d01cae9c280a51fafba8f1b38e2642e", "filename": "libstdc++-v3/bits/std_cstring.h", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_cstring.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_cstring.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_cstring.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "08c07b6d5f633730a1cebe4fecf5a58480e134c0", "filename": "libstdc++-v3/bits/std_ctime.h", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_ctime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_ctime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_ctime.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "8c606dc80de7391711a591f0cb9e5d0ee3c1a6f4", "filename": "libstdc++-v3/bits/std_cwchar.h", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_cwchar.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_cwchar.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_cwchar.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "97db4b85423be2e1e2cf4ddc640bb23bac3579bc", "filename": "libstdc++-v3/bits/std_cwctype.h", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_cwctype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_cwctype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_cwctype.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "574ab313755455e8685dec8f90abff02bcd1ea99", "filename": "libstdc++-v3/bits/std_deque.h", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_deque.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_deque.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_deque.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "66cf46d95cc56ecf33edc452a1b81f9e0d23e575", "filename": "libstdc++-v3/bits/std_exception.h", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_exception.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_exception.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_exception.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "0ebbc76027278728a44b99429855c94ce3700646", "filename": "libstdc++-v3/bits/std_fstream.h", "status": "added", "additions": 386, "deletions": 0, "changes": 386, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_fstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_fstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_fstream.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "0336c2aedab14e9732aa1f151b6a9f9e169127f8", "filename": "libstdc++-v3/bits/std_functional.h", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_functional.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_functional.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_functional.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "6fa49386b6729eb97635018317cdd2acffb46957", "filename": "libstdc++-v3/bits/std_iomanip.h", "status": "added", "additions": 219, "deletions": 0, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_iomanip.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_iomanip.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_iomanip.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "7c54547c2ab3b0639cf0eabf2c22d3e4364c6473", "filename": "libstdc++-v3/bits/std_ios.h", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_ios.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_ios.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_ios.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "3a8eb056ddc6e26375f1ed1463fe588e49212c68", "filename": "libstdc++-v3/bits/std_iosfwd.h", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_iosfwd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_iosfwd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_iosfwd.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "b08d038046d3e525cee3cb51839ac8fdfdebce06", "filename": "libstdc++-v3/bits/std_iostream.h", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_iostream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_iostream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_iostream.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "baddea47f8a2cf7ee4138407dfcd2f9e08d3310b", "filename": "libstdc++-v3/bits/std_istream.h", "status": "added", "additions": 307, "deletions": 0, "changes": 307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_istream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_istream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_istream.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "643cff99cb8fa320b99226290fdff1efe5c926d2", "filename": "libstdc++-v3/bits/std_iterator.h", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_iterator.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "eaf1258cca6873407507a78e2fe0fc8430db6ec4", "filename": "libstdc++-v3/bits/std_list.h", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_list.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "85100444fb96f5fff195df61623f64c64840482e", "filename": "libstdc++-v3/bits/std_locale.h", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_locale.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_locale.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_locale.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "9390ab8689dcedd431ed4f5d1c37c004681c9497", "filename": "libstdc++-v3/bits/std_map.h", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_map.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "005c7d3728cf33d48198480868efff1539f583c8", "filename": "libstdc++-v3/bits/std_memory.h", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_memory.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_memory.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_memory.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "1ac2dd05325c4c8cd86e09ccedfd6211a6a50e40", "filename": "libstdc++-v3/bits/std_new.h", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_new.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_new.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_new.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "8b7c6fd96669b6e6d92257e5a2b892365f600ccb", "filename": "libstdc++-v3/bits/std_numeric.h", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_numeric.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_numeric.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_numeric.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "eff25b90625bc7984b09986abf0a7e33ed62e77b", "filename": "libstdc++-v3/bits/std_ostream.h", "status": "added", "additions": 288, "deletions": 0, "changes": 288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_ostream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_ostream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_ostream.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "198b2c03508a2e19e46e94aac82f7a6b834b8107", "filename": "libstdc++-v3/bits/std_queue.h", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_queue.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_queue.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_queue.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "7a5f5c5b4ecedeeaef2a1ee7281523de1a72e83b", "filename": "libstdc++-v3/bits/std_set.h", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_set.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "68a36c22b44a5e3b01bdd52cb9ed752f5e4fd803", "filename": "libstdc++-v3/bits/std_sstream.h", "status": "added", "additions": 367, "deletions": 0, "changes": 367, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_sstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_sstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_sstream.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "53e7e21f0ecb1fc16afafc2a0e2aef2a6c8e57f7", "filename": "libstdc++-v3/bits/std_stack.h", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_stack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_stack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_stack.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "691b9b5825e9ade7311b0c972ba8c7046611cd25", "filename": "libstdc++-v3/bits/std_stdexcept.h", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_stdexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_stdexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_stdexcept.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "6aa9204c51048af247637729f4ec50a48a622868", "filename": "libstdc++-v3/bits/std_streambuf.h", "status": "added", "additions": 460, "deletions": 0, "changes": 460, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_streambuf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_streambuf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_streambuf.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "6008eca2862b6a71bcca26a7d2d7b62798211b29", "filename": "libstdc++-v3/bits/std_string.h", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_string.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_string.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_string.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "2f784b36fcee5ee11e466e6ba838a069fa1855db", "filename": "libstdc++-v3/bits/std_strstream.h", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_strstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_strstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_strstream.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "1bce795882ccbbed93cfec6b4edf477f1c92303f", "filename": "libstdc++-v3/bits/std_typeinfo.h", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_typeinfo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_typeinfo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_typeinfo.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "e10dae35b6a87a5bde7fe9180187f8e2104fbd5a", "filename": "libstdc++-v3/bits/std_utility.h", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_utility.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_utility.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_utility.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "3a5f0c7ba1aed02cf909b20f4604fa801929dc50", "filename": "libstdc++-v3/bits/std_valarray.h", "status": "added", "additions": 748, "deletions": 0, "changes": 748, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_valarray.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_valarray.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_valarray.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "08ac4bd69de37ed2adc4ed9a66ff0ce2c750f527", "filename": "libstdc++-v3/bits/std_vector.h", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstd_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_vector.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "60d40f662509113b7bf6b1852ac5afa1a51cabcf", "filename": "libstdc++-v3/bits/stl_algo.h", "status": "added", "additions": 2900, "deletions": 0, "changes": 2900, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_algo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_algo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_algo.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "b1bbd57b9b295da2ee2dba27c116244e3bdd5676", "filename": "libstdc++-v3/bits/stl_algobase.h", "status": "added", "additions": 652, "deletions": 0, "changes": 652, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_algobase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_algobase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_algobase.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "d28938b9cefc8b1737d0f2978fb94c09df116c29", "filename": "libstdc++-v3/bits/stl_alloc.h", "status": "added", "additions": 905, "deletions": 0, "changes": 905, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_alloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_alloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_alloc.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "6e2200dfbd8ea44ddffbb6c37a59f4dfb69054d0", "filename": "libstdc++-v3/bits/stl_config.h", "status": "added", "additions": 490, "deletions": 0, "changes": 490, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_config.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_config.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_config.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "b77bf15dd53c57b6d43f4ce78ec6e07dd48a6d09", "filename": "libstdc++-v3/bits/stl_construct.h", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_construct.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_construct.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_construct.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "4b0d20b8781149ed93e2f3cccd1deb250254f0a4", "filename": "libstdc++-v3/bits/stl_deque.h", "status": "added", "additions": 1768, "deletions": 0, "changes": 1768, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_deque.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_deque.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_deque.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "e7e53407c9583a24c04d8e0841a02cf249444937", "filename": "libstdc++-v3/bits/stl_function.h", "status": "added", "additions": 732, "deletions": 0, "changes": 732, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_function.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_function.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_function.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "8af130c7006b8b627bbd0185e47c98a4b9e398d5", "filename": "libstdc++-v3/bits/stl_heap.h", "status": "added", "additions": 281, "deletions": 0, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_heap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_heap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_heap.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "16b657e81b72c6202120f17bbc8d09991a423da8", "filename": "libstdc++-v3/bits/stl_iterator.h", "status": "added", "additions": 1093, "deletions": 0, "changes": 1093, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_iterator.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "d26888e6072373a6acc4486b240c28c93da9febc", "filename": "libstdc++-v3/bits/stl_iterator_base.h", "status": "added", "additions": 358, "deletions": 0, "changes": 358, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_iterator_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_iterator_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_iterator_base.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "b5b88ed81bd59ae535f28bf74470adde39f60499", "filename": "libstdc++-v3/bits/stl_list.h", "status": "added", "additions": 867, "deletions": 0, "changes": 867, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_list.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "1a3b63014dc914f6f188ab19ba686d5268469cb9", "filename": "libstdc++-v3/bits/stl_map.h", "status": "added", "additions": 273, "deletions": 0, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_map.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "c8a861bcb170cd7fd00bbe97ca09d8aceb975cf5", "filename": "libstdc++-v3/bits/stl_multimap.h", "status": "added", "additions": 275, "deletions": 0, "changes": 275, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_multimap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_multimap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_multimap.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "eda4dabe2a7aac7e9da7a45e6ded8c2ff433922f", "filename": "libstdc++-v3/bits/stl_multiset.h", "status": "added", "additions": 266, "deletions": 0, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_multiset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_multiset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_multiset.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "7070e2d625e5c6a3045fd9f7c0585b5b4e4d957e", "filename": "libstdc++-v3/bits/stl_numeric.h", "status": "added", "additions": 239, "deletions": 0, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_numeric.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_numeric.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_numeric.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "a6155a698e1c7d3a35b7e8f9f6a0de497c8883d0", "filename": "libstdc++-v3/bits/stl_pair.h", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_pair.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_pair.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_pair.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "c1488b1ef6a277f307e94994fc9d8725a7c0108e", "filename": "libstdc++-v3/bits/stl_pthread_alloc.h", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_pthread_alloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_pthread_alloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_pthread_alloc.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "610ba3edbc5abc150caa65c50361d5a6e15e7963", "filename": "libstdc++-v3/bits/stl_queue.h", "status": "added", "additions": 221, "deletions": 0, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_queue.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_queue.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_queue.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "c5ddfe63cbb8f5d9ea4bcaa3c5a855c900757180", "filename": "libstdc++-v3/bits/stl_range_errors.h", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_range_errors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_range_errors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_range_errors.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "007acd032edb8f4812ac918a43e2613d8c934abb", "filename": "libstdc++-v3/bits/stl_raw_storage_iter.h", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_raw_storage_iter.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_raw_storage_iter.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_raw_storage_iter.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "f0cabdfd54446f68d8fcab327e657bb762e6a9b1", "filename": "libstdc++-v3/bits/stl_relops.h", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_relops.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_relops.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_relops.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "b5d364362cba988df9d39deec55bd1ac3ce6562c", "filename": "libstdc++-v3/bits/stl_set.h", "status": "added", "additions": 259, "deletions": 0, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_set.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "bb9d851f4cfc1b7280e5f78b802dbf917125370e", "filename": "libstdc++-v3/bits/stl_stack.h", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_stack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_stack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_stack.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "5097e618aa9d76413c612006125780af06416ecc", "filename": "libstdc++-v3/bits/stl_string_fwd.h", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_string_fwd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_string_fwd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_string_fwd.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "cdc0dd27df0e57c8b60f973de9feaf24ebf064ff", "filename": "libstdc++-v3/bits/stl_tempbuf.h", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_tempbuf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_tempbuf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_tempbuf.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "8b6d08e2489e59db74d75dc480503e0e3f0207f0", "filename": "libstdc++-v3/bits/stl_threads.h", "status": "added", "additions": 369, "deletions": 0, "changes": 369, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_threads.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_threads.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_threads.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "dd1fa407bc816ea4ab72a8c59252df4142c1d7c9", "filename": "libstdc++-v3/bits/stl_tree.h", "status": "added", "additions": 1368, "deletions": 0, "changes": 1368, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_tree.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "087424ad4c3414bd570fbd9ec354847ecfb9e15f", "filename": "libstdc++-v3/bits/stl_uninitialized.h", "status": "added", "additions": 281, "deletions": 0, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_uninitialized.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_uninitialized.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_uninitialized.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "3d2994cc7d3bc9df0716e2c826b0e0aa015f63ca", "filename": "libstdc++-v3/bits/stl_vector.h", "status": "added", "additions": 873, "deletions": 0, "changes": 873, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstl_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_vector.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "f956ab267200d18f688edbbd6a01493e51ec59c8", "filename": "libstdc++-v3/bits/streambuf.tcc", "status": "added", "additions": 259, "deletions": 0, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstreambuf.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstreambuf.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstreambuf.tcc?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "7ad2b5d0e8fdfc54a808b62ba5771cf88d3d8b75", "filename": "libstdc++-v3/bits/string.tcc", "status": "added", "additions": 858, "deletions": 0, "changes": 858, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstring.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fstring.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstring.tcc?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "dbcaa2a619fee2e2b7d6cd236cdece36ee9045c1", "filename": "libstdc++-v3/bits/type_traits.h", "status": "added", "additions": 387, "deletions": 0, "changes": 387, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Ftype_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Ftype_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Ftype_traits.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "fc610ee0defc2be489793ae068cc416f75e5860f", "filename": "libstdc++-v3/bits/valarray_array.h", "status": "added", "additions": 535, "deletions": 0, "changes": 535, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fvalarray_array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fvalarray_array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fvalarray_array.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "ab77f4aca1eb7074179062fc75835cca2a39dca0", "filename": "libstdc++-v3/bits/valarray_array.tcc", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fvalarray_array.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fvalarray_array.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fvalarray_array.tcc?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "1207bd96e2df0cdfcb5b772f2721ec2afa445829", "filename": "libstdc++-v3/bits/valarray_meta.h", "status": "added", "additions": 1057, "deletions": 0, "changes": 1057, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fvalarray_meta.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fbits%2Fvalarray_meta.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fvalarray_meta.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "b657fdf306f7c96c1b86a9199e9a59595e61ffbe", "filename": "libstdc++-v3/config.h.in", "status": "added", "additions": 569, "deletions": 0, "changes": 569, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig.h.in?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "bae6bb4a4583bfce94e965a9489f8e235b131023", "filename": "libstdc++-v3/config/aix/bits/ctype_base.h", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Faix%2Fbits%2Fctype_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Faix%2Fbits%2Fctype_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Faix%2Fbits%2Fctype_base.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "2083a174a4bab91b8a94f7e615f2468644a4d7e3", "filename": "libstdc++-v3/config/aix/bits/ctype_specializations.h", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Faix%2Fbits%2Fctype_specializations.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Faix%2Fbits%2Fctype_specializations.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Faix%2Fbits%2Fctype_specializations.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "2c600f0e0db85b16e51cf3af0916b0827b7f7a0a", "filename": "libstdc++-v3/config/aix/ctype.cc", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Faix%2Fctype.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Faix%2Fctype.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Faix%2Fctype.cc?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "9ea87a293c0723828fb64e5b4aaabb646a9539b9", "filename": "libstdc++-v3/config/c_io_libio.cc", "status": "added", "additions": 268, "deletions": 0, "changes": 268, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fc_io_libio.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fc_io_libio.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fc_io_libio.cc?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "d282519f6a310efe9fdb8268bf468dc0616983c3", "filename": "libstdc++-v3/config/c_io_libio.h", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fc_io_libio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fc_io_libio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fc_io_libio.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "b9b92d05dcb3570fa528869da80a7a8f8804d38f", "filename": "libstdc++-v3/config/cpu/alpha/atomicity.h", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Falpha%2Fatomicity.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Falpha%2Fatomicity.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Falpha%2Fatomicity.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "7d886a3036d3a0f31c83720034c9858e7512dfe0", "filename": "libstdc++-v3/config/cpu/arm/atomicity.h", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Farm%2Fatomicity.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Farm%2Fatomicity.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Farm%2Fatomicity.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "5831f9597922c996e10527e8cc220fc5c4a6e85e", "filename": "libstdc++-v3/config/cpu/generic/atomicity.h", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fgeneric%2Fatomicity.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fgeneric%2Fatomicity.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fgeneric%2Fatomicity.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "dfa9182465ae4dbaa67e50236dcbb7fbf50a7118", "filename": "libstdc++-v3/config/cpu/i386/atomicity.h", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fi386%2Fatomicity.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fi386%2Fatomicity.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fi386%2Fatomicity.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "59bd61cd7299de23362a9de8d802a181f6ed6ec6", "filename": "libstdc++-v3/config/cpu/powerpc/atomicity.h", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fpowerpc%2Fatomicity.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fpowerpc%2Fatomicity.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fpowerpc%2Fatomicity.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "1ead56e8d9bb89933a7248828a429f3cb0a163f1", "filename": "libstdc++-v3/config/cpu/sparc/sparc32/atomicity.h", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fsparc%2Fsparc32%2Fatomicity.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fsparc%2Fsparc32%2Fatomicity.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fsparc%2Fsparc32%2Fatomicity.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "945247a602524065b117ee9478ac612e9a5dc273", "filename": "libstdc++-v3/config/cpu/sparc/sparc64/atomicity.h", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fsparc%2Fsparc64%2Fatomicity.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fsparc%2Fsparc64%2Fatomicity.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fsparc%2Fsparc64%2Fatomicity.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "8b5e0a07252e391e0987f96f4d541bb6ea699699", "filename": "libstdc++-v3/config/generic/bits/ctype_base.h", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fgeneric%2Fbits%2Fctype_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fgeneric%2Fbits%2Fctype_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fgeneric%2Fbits%2Fctype_base.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "76d4cbcbb798ce5bbae20116286c2a8e54e12927", "filename": "libstdc++-v3/config/generic/bits/ctype_specializations.h", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fgeneric%2Fbits%2Fctype_specializations.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fgeneric%2Fbits%2Fctype_specializations.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fgeneric%2Fbits%2Fctype_specializations.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "ad7ec434bc3120d40613ae6896c869c2c6818975", "filename": "libstdc++-v3/config/generic/ctype.cc", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fgeneric%2Fctype.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fgeneric%2Fctype.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fgeneric%2Fctype.cc?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "8d4a65bd040f52e7ceb914baf6db4b51e6da43bb", "filename": "libstdc++-v3/config/gnu-linux/bits/ctype_base.h", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fgnu-linux%2Fbits%2Fctype_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fgnu-linux%2Fbits%2Fctype_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fgnu-linux%2Fbits%2Fctype_base.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "76d4cbcbb798ce5bbae20116286c2a8e54e12927", "filename": "libstdc++-v3/config/gnu-linux/bits/ctype_specializations.h", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fgnu-linux%2Fbits%2Fctype_specializations.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fgnu-linux%2Fbits%2Fctype_specializations.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fgnu-linux%2Fbits%2Fctype_specializations.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "f6abe08cc1032e738f76527b93c6a672b0900567", "filename": "libstdc++-v3/config/gnu-linux/ctype.cc", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fgnu-linux%2Fctype.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fgnu-linux%2Fctype.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fgnu-linux%2Fctype.cc?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "32394eb7a4a9f8b26da4644c14d143a19a46fe4a", "filename": "libstdc++-v3/config/irix/bits/ctype_base.h", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Firix%2Fbits%2Fctype_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Firix%2Fbits%2Fctype_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Firix%2Fbits%2Fctype_base.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "88a93b4c7bafd9b66ddef0281fb3b5d21ce05b33", "filename": "libstdc++-v3/config/irix/bits/ctype_specializations.h", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Firix%2Fbits%2Fctype_specializations.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Firix%2Fbits%2Fctype_specializations.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Firix%2Fbits%2Fctype_specializations.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "553e776e1dd5d5f8b26ffbbadb720050bde38c48", "filename": "libstdc++-v3/config/irix/ctype.cc", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Firix%2Fctype.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Firix%2Fctype.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Firix%2Fctype.cc?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "447073e2a046ddaa496f33f1cfea7668d84b9114", "filename": "libstdc++-v3/config/newlib/bits/ctype_base.h", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fnewlib%2Fbits%2Fctype_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fnewlib%2Fbits%2Fctype_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fnewlib%2Fbits%2Fctype_base.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "ff8bb67c1edeeaee85e86995c7f3941a104fa737", "filename": "libstdc++-v3/config/newlib/bits/ctype_specializations.h", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fnewlib%2Fbits%2Fctype_specializations.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fnewlib%2Fbits%2Fctype_specializations.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fnewlib%2Fbits%2Fctype_specializations.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "db401bdc5c252d26d677e8c51aa61951b3c4ca83", "filename": "libstdc++-v3/config/newlib/ctype.cc", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fnewlib%2Fctype.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fnewlib%2Fctype.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fnewlib%2Fctype.cc?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "1f4e1d65d3d54196c3b5ba0a59c4f20c94bb7f4e", "filename": "libstdc++-v3/config/solaris/solaris2.5/bits/ctype_base.h", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fsolaris%2Fsolaris2.5%2Fbits%2Fctype_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fsolaris%2Fsolaris2.5%2Fbits%2Fctype_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fsolaris%2Fsolaris2.5%2Fbits%2Fctype_base.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "88a93b4c7bafd9b66ddef0281fb3b5d21ce05b33", "filename": "libstdc++-v3/config/solaris/solaris2.5/bits/ctype_specializations.h", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fsolaris%2Fsolaris2.5%2Fbits%2Fctype_specializations.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fsolaris%2Fsolaris2.5%2Fbits%2Fctype_specializations.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fsolaris%2Fsolaris2.5%2Fbits%2Fctype_specializations.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "7e01ad6ecf7ecb50d1b48c4b0c396a41d89aa917", "filename": "libstdc++-v3/config/solaris/solaris2.5/ctype.cc", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fsolaris%2Fsolaris2.5%2Fctype.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fsolaris%2Fsolaris2.5%2Fctype.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fsolaris%2Fsolaris2.5%2Fctype.cc?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "4e2618f89e733efb73cd3dc4b4395ad375c5b99e", "filename": "libstdc++-v3/config/solaris/solaris2.6/bits/ctype_base.h", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fsolaris%2Fsolaris2.6%2Fbits%2Fctype_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fsolaris%2Fsolaris2.6%2Fbits%2Fctype_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fsolaris%2Fsolaris2.6%2Fbits%2Fctype_base.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "819fc19caed2583e86b6867762999924f0aebb1b", "filename": "libstdc++-v3/config/solaris/solaris2.6/bits/ctype_specializations.h", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fsolaris%2Fsolaris2.6%2Fbits%2Fctype_specializations.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fsolaris%2Fsolaris2.6%2Fbits%2Fctype_specializations.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fsolaris%2Fsolaris2.6%2Fbits%2Fctype_specializations.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "97a9a561f215de74a8292547f50ff95ab8419e6d", "filename": "libstdc++-v3/config/solaris/solaris2.6/ctype.cc", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fsolaris%2Fsolaris2.6%2Fctype.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fsolaris%2Fsolaris2.6%2Fctype.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fsolaris%2Fsolaris2.6%2Fctype.cc?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "782a09b2fedfc0fa9e4ef2139e157545c7880467", "filename": "libstdc++-v3/config/solaris/solaris2.7/bits/ctype_base.h", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fsolaris%2Fsolaris2.7%2Fbits%2Fctype_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fsolaris%2Fsolaris2.7%2Fbits%2Fctype_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fsolaris%2Fsolaris2.7%2Fbits%2Fctype_base.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "819fc19caed2583e86b6867762999924f0aebb1b", "filename": "libstdc++-v3/config/solaris/solaris2.7/bits/ctype_specializations.h", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fsolaris%2Fsolaris2.7%2Fbits%2Fctype_specializations.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fsolaris%2Fsolaris2.7%2Fbits%2Fctype_specializations.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fsolaris%2Fsolaris2.7%2Fbits%2Fctype_specializations.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "d8f837098854a156a463079ecd91568a2e4cab3f", "filename": "libstdc++-v3/config/solaris/solaris2.7/ctype.cc", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fsolaris%2Fsolaris2.7%2Fctype.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fsolaris%2Fsolaris2.7%2Fctype.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fsolaris%2Fsolaris2.7%2Fctype.cc?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "c2de0f1ef4c817f2231beecdb56bb6502f0d143b", "filename": "libstdc++-v3/config/threads-no.h", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fthreads-no.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fthreads-no.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fthreads-no.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "46d53f4ecc2885778e9480a6037c8a3a3536875b", "filename": "libstdc++-v3/config/threads-posix.h", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fthreads-posix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfig%2Fthreads-posix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fthreads-posix.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "7adb657d3f9ca85d1b4bc6babec2cefad6e6c8ae", "filename": "libstdc++-v3/configure", "status": "added", "additions": 4470, "deletions": 0, "changes": 4470, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "6c896c65348b26a8a626d4089902ac6e16ba0709", "filename": "libstdc++-v3/configure.host", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfigure.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfigure.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure.host?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "cd26c7dbd4a686477609d9027100e95ee2f07faa", "filename": "libstdc++-v3/configure.in", "status": "added", "additions": 197, "deletions": 0, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure.in?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "5b0473ba64e26f6c3b09e424b10c8c92c756cb53", "filename": "libstdc++-v3/docs/17_intro/BADNAMES", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F17_intro%2FBADNAMES", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F17_intro%2FBADNAMES", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2F17_intro%2FBADNAMES?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "150503593fe8c5febd5c3655f89880686dfd70ec", "filename": "libstdc++-v3/docs/17_intro/BUGS", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F17_intro%2FBUGS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F17_intro%2FBUGS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2F17_intro%2FBUGS?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "91c4b0998da80196eceaf69e675019a8b3f983ab", "filename": "libstdc++-v3/docs/17_intro/C++STYLE", "status": "added", "additions": 310, "deletions": 0, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F17_intro%2FC%2B%2BSTYLE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F17_intro%2FC%2B%2BSTYLE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2F17_intro%2FC%2B%2BSTYLE?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "bef9635e8507400c517c897782dc8808fa8c004f", "filename": "libstdc++-v3/docs/17_intro/CHECKLIST", "status": "added", "additions": 6014, "deletions": 0, "changes": 6014, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F17_intro%2FCHECKLIST", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F17_intro%2FCHECKLIST", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2F17_intro%2FCHECKLIST?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "60549be514af76c5db0c17ce6bbe01b2f81e2d9e", "filename": "libstdc++-v3/docs/17_intro/COPYING", "status": "added", "additions": 340, "deletions": 0, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F17_intro%2FCOPYING", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F17_intro%2FCOPYING", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2F17_intro%2FCOPYING?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "6979bc40f80d36e56883aa73ff5dd121f4b51679", "filename": "libstdc++-v3/docs/17_intro/DESIGN", "status": "added", "additions": 859, "deletions": 0, "changes": 859, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F17_intro%2FDESIGN", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F17_intro%2FDESIGN", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2F17_intro%2FDESIGN?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "c6fa6d38b54f6c48fc45666d7c76f10a4d41f52c", "filename": "libstdc++-v3/docs/17_intro/HEADER_POLICY", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F17_intro%2FHEADER_POLICY", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F17_intro%2FHEADER_POLICY", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2F17_intro%2FHEADER_POLICY?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "52223911295e440f3aa84cece7908b4675e95328", "filename": "libstdc++-v3/docs/17_intro/PROBLEMS", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F17_intro%2FPROBLEMS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F17_intro%2FPROBLEMS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2F17_intro%2FPROBLEMS?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "37040f72a3447be4009fc7e763e9657f60a34eea", "filename": "libstdc++-v3/docs/17_intro/RELEASE-NOTES", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F17_intro%2FRELEASE-NOTES", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F17_intro%2FRELEASE-NOTES", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2F17_intro%2FRELEASE-NOTES?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "4da846277d6b1d9663f6556e2f082feb1b571acf", "filename": "libstdc++-v3/docs/17_intro/TODO", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F17_intro%2FTODO", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F17_intro%2FTODO", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2F17_intro%2FTODO?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "916bb0562b84f79eed4b59d28659861b1930db87", "filename": "libstdc++-v3/docs/17_intro/contribute.html", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F17_intro%2Fcontribute.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F17_intro%2Fcontribute.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2F17_intro%2Fcontribute.html?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "d55c2868347be406d29f04bdc4725d8aa4f5ee2c", "filename": "libstdc++-v3/docs/17_intro/howto.html", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F17_intro%2Fhowto.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F17_intro%2Fhowto.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2F17_intro%2Fhowto.html?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "025b86e1d7393d92f0af1e3853ec2de6481ca0f1", "filename": "libstdc++-v3/docs/17_intro/libstdc++-assign.txt", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F17_intro%2Flibstdc%2B%2B-assign.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F17_intro%2Flibstdc%2B%2B-assign.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2F17_intro%2Flibstdc%2B%2B-assign.txt?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "828a81128341489519704a4faa2e53318edd9e1d", "filename": "libstdc++-v3/docs/17_intro/organization", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F17_intro%2Forganization", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F17_intro%2Forganization", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2F17_intro%2Forganization?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "e31d5412e432ffe68b06b2626d437e9fc5ea4f84", "filename": "libstdc++-v3/docs/18_support/howto.html", "status": "added", "additions": 217, "deletions": 0, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F18_support%2Fhowto.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F18_support%2Fhowto.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2F18_support%2Fhowto.html?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "949a70a5fb1f929a011be66e56caa6548a139569", "filename": "libstdc++-v3/docs/19_diagnostics/howto.html", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F19_diagnostics%2Fhowto.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F19_diagnostics%2Fhowto.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2F19_diagnostics%2Fhowto.html?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "21ea55b9cd5c0fae31d04deda1e4f68ca18fda6e", "filename": "libstdc++-v3/docs/20_util/howto.html", "status": "added", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F20_util%2Fhowto.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F20_util%2Fhowto.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2F20_util%2Fhowto.html?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "d823f30504e6775f39051e8a88759255f142cb26", "filename": "libstdc++-v3/docs/21_strings/gotw29a.txt", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F21_strings%2Fgotw29a.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F21_strings%2Fgotw29a.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2F21_strings%2Fgotw29a.txt?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "0014268db874ae932c1ec62991b78c230b4372c0", "filename": "libstdc++-v3/docs/21_strings/howto.html", "status": "added", "additions": 292, "deletions": 0, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F21_strings%2Fhowto.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F21_strings%2Fhowto.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2F21_strings%2Fhowto.html?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "81d87a6efaf758a8ebe2ec9ff0d7e4b0a6d960f2", "filename": "libstdc++-v3/docs/21_strings/stringtok_h.txt", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F21_strings%2Fstringtok_h.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F21_strings%2Fstringtok_h.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2F21_strings%2Fstringtok_h.txt?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "2f3d7e073684aef9fc676fb7eedd165253d43826", "filename": "libstdc++-v3/docs/21_strings/stringtok_std_h.txt", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F21_strings%2Fstringtok_std_h.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F21_strings%2Fstringtok_std_h.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2F21_strings%2Fstringtok_std_h.txt?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "70d4add93f410cdbd19f022ad5e3680ec10d313a", "filename": "libstdc++-v3/docs/22_locale/howto.html", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F22_locale%2Fhowto.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F22_locale%2Fhowto.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2F22_locale%2Fhowto.html?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "f39731b845cde7f5e0c619e3e56ad90092411693", "filename": "libstdc++-v3/docs/23_containers/howto.html", "status": "added", "additions": 246, "deletions": 0, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F23_containers%2Fhowto.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F23_containers%2Fhowto.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2F23_containers%2Fhowto.html?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "3e0805bf8c83c3ea6c45c1d3bc51d16ff23956fb", "filename": "libstdc++-v3/docs/23_containers/wrappers_h.txt", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F23_containers%2Fwrappers_h.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F23_containers%2Fwrappers_h.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2F23_containers%2Fwrappers_h.txt?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "036042f13c9931b9f494cc205dfa3d96933bf666", "filename": "libstdc++-v3/docs/24_iterators/howto.html", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F24_iterators%2Fhowto.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F24_iterators%2Fhowto.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2F24_iterators%2Fhowto.html?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "9c6d6c42da13e6ccfc78b54f4097ae6e2e1adeb8", "filename": "libstdc++-v3/docs/25_algorithms/howto.html", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F25_algorithms%2Fhowto.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F25_algorithms%2Fhowto.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2F25_algorithms%2Fhowto.html?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "ef7b6bb1cb29c2c690c50b1a096783aa73358d23", "filename": "libstdc++-v3/docs/26_numerics/howto.html", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F26_numerics%2Fhowto.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F26_numerics%2Fhowto.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2F26_numerics%2Fhowto.html?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "1de9a35969ee1814cc5efc12e92a4a086f1a0281", "filename": "libstdc++-v3/docs/27_io/howto.html", "status": "added", "additions": 346, "deletions": 0, "changes": 346, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F27_io%2Fhowto.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F27_io%2Fhowto.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2F27_io%2Fhowto.html?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "ab8891300174d42c333167a5e29aa61af1b6619e", "filename": "libstdc++-v3/docs/27_io/iostreams_hierarchy.pdf", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F27_io%2Fiostreams_hierarchy.pdf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2F27_io%2Fiostreams_hierarchy.pdf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2F27_io%2Fiostreams_hierarchy.pdf?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "e511f8f86686f528845ff67094194ef63ee59538", "filename": "libstdc++-v3/docs/configopts.html", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2Fconfigopts.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2Fconfigopts.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fconfigopts.html?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "540d934f1215153ad6a77a1d2d2502a054ed6c9c", "filename": "libstdc++-v3/docs/documentation.html", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2Fdocumentation.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2Fdocumentation.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fdocumentation.html?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "c6a834dd353eee6afe2968f3714011172b7164d6", "filename": "libstdc++-v3/docs/download.html", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2Fdownload.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2Fdownload.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fdownload.html?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "12c7b3d0546e42228d2d0df18a1528f2a1d9485b", "filename": "libstdc++-v3/docs/faq/index.html", "status": "added", "additions": 672, "deletions": 0, "changes": 672, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2Ffaq%2Findex.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2Ffaq%2Findex.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Ffaq%2Findex.html?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "27c2472b897ee66378d151bab3668c016373db03", "filename": "libstdc++-v3/docs/faq/index.txt", "status": "added", "additions": 611, "deletions": 0, "changes": 611, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2Ffaq%2Findex.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2Ffaq%2Findex.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Ffaq%2Findex.txt?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "f3740d614e9392067a7b083c7592f52ebdab2318", "filename": "libstdc++-v3/docs/footer.html", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2Ffooter.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2Ffooter.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Ffooter.html?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "3f167cc0cea5ea84a59ef9ec4e92f71c85a7c7af", "filename": "libstdc++-v3/docs/gccrebuild.html", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2Fgccrebuild.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2Fgccrebuild.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fgccrebuild.html?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "467a1fd7d73204c5277b5785c70f1589aa92a7fd", "filename": "libstdc++-v3/docs/header.html", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2Fheader.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2Fheader.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fheader.html?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "86e2f6d957734d69cbfff9e5eb26601ad8df317e", "filename": "libstdc++-v3/docs/index.html", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2Findex.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2Findex.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Findex.html?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "99c9c532c02ac2c1264365cd599e6f04f7b637ae", "filename": "libstdc++-v3/docs/install.html", "status": "added", "additions": 378, "deletions": 0, "changes": 378, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2Finstall.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2Finstall.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Finstall.html?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "ee88c366cd47bcbcd11efd0f7f4c6049aac99db5", "filename": "libstdc++-v3/docs/lib3styles.css", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2Flib3styles.css", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2Flib3styles.css", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Flib3styles.css?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "bf5774a81f64fa8eb7709c8e7c8467c9883e0f46", "filename": "libstdc++-v3/docs/links.html", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2Flinks.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2Flinks.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Flinks.html?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "2753484a4c0b708194d582f4832c60cf9384f563", "filename": "libstdc++-v3/docs/mail.html", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2Fmail.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2Fmail.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fmail.html?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "bb097f8004a04a6e2ee55345fb80ec3323f63346", "filename": "libstdc++-v3/docs/status.html", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2Fstatus.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2Fstatus.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fstatus.html?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "791272c97ab499d9cdf71eb820228d34a4b2dad4", "filename": "libstdc++-v3/docs/thanks.html", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2Fthanks.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fdocs%2Fthanks.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fthanks.html?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "2ece99c7160547eb7b079ab5d57cc5191e3da362", "filename": "libstdc++-v3/ext/bvector", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fext%2Fbvector", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fext%2Fbvector", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fext%2Fbvector?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "0f046e186f78bec926491fb47504a75948d0460b", "filename": "libstdc++-v3/ext/hash_map", "status": "added", "additions": 518, "deletions": 0, "changes": 518, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fext%2Fhash_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fext%2Fhash_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fext%2Fhash_map?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "fb54c603d6cd55beb6d16b3401b72dfe1855688e", "filename": "libstdc++-v3/ext/hash_set", "status": "added", "additions": 502, "deletions": 0, "changes": 502, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fext%2Fhash_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fext%2Fhash_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fext%2Fhash_set?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "3779defea2be4c49ed9d265be1577c5c2d16d789", "filename": "libstdc++-v3/ext/rope", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fext%2Frope", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fext%2Frope", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fext%2Frope?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "19b8107e7c8c821eae6ec0932c8354a01dda7e04", "filename": "libstdc++-v3/ext/ropeimpl.h", "status": "added", "additions": 1586, "deletions": 0, "changes": 1586, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fext%2Fropeimpl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fext%2Fropeimpl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fext%2Fropeimpl.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "81ca92dc21590d934adb189ac6a9379befd52ade", "filename": "libstdc++-v3/ext/slist", "status": "added", "additions": 1023, "deletions": 0, "changes": 1023, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fext%2Fslist", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fext%2Fslist", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fext%2Fslist?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "b1c15355107954db69c23619792daba5bbc38d82", "filename": "libstdc++-v3/ext/stl_bvector.h", "status": "added", "additions": 892, "deletions": 0, "changes": 892, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fext%2Fstl_bvector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fext%2Fstl_bvector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fext%2Fstl_bvector.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "3144e6a07f181912a307d7eb18d13cd86fd795dc", "filename": "libstdc++-v3/ext/stl_hash_fun.h", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fext%2Fstl_hash_fun.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fext%2Fstl_hash_fun.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fext%2Fstl_hash_fun.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "9bd69cd853a4b0b0b214d85b485314ef8cf133e1", "filename": "libstdc++-v3/ext/stl_hashtable.h", "status": "added", "additions": 1054, "deletions": 0, "changes": 1054, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fext%2Fstl_hashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fext%2Fstl_hashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fext%2Fstl_hashtable.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "bcf42394d6db89a90afd03fb8c3d94a73cc20738", "filename": "libstdc++-v3/ext/stl_rope.h", "status": "added", "additions": 2710, "deletions": 0, "changes": 2710, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fext%2Fstl_rope.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fext%2Fstl_rope.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fext%2Fstl_rope.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "f6faf976e34fe58d324d1d83cb86962a814722c8", "filename": "libstdc++-v3/ext/tree", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fext%2Ftree", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fext%2Ftree", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fext%2Ftree?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "e9a14c917ea955b5ca16e2d8d9cbb53e4c38c76b", "filename": "libstdc++-v3/inclosure", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Finclosure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Finclosure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclosure?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "65391f54ba72f1d88b8050d4a64e750dea0d783a", "filename": "libstdc++-v3/libio/ChangeLog", "status": "added", "additions": 2669, "deletions": 0, "changes": 2669, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Flibio%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Flibio%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2FChangeLog?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "07534f2b06e4927320b3139661ea7d9099156ba3", "filename": "libstdc++-v3/libio/Makefile.am", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Flibio%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Flibio%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2FMakefile.am?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "80cbf5fed730239fdcbe1ba93cfae78f335aa24e", "filename": "libstdc++-v3/libio/Makefile.in", "status": "added", "additions": 349, "deletions": 0, "changes": 349, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Flibio%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Flibio%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2FMakefile.in?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "691fa838b26ab9cb7553f29a8e3965bf7782bb45", "filename": "libstdc++-v3/libio/cleanup.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Flibio%2Fcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Flibio%2Fcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2Fcleanup.c?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "a27455c4a5cb3e20558c3a80f7692b4dc6500e75", "filename": "libstdc++-v3/libio/filedoalloc.c", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Flibio%2Ffiledoalloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Flibio%2Ffiledoalloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2Ffiledoalloc.c?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "54e13d3f18feaab37a847ebe80ef3cfe03b80cc2", "filename": "libstdc++-v3/libio/fileops.c", "status": "added", "additions": 811, "deletions": 0, "changes": 811, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Flibio%2Ffileops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Flibio%2Ffileops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2Ffileops.c?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "6c07b46b36bf97a6b5a60ca46aba768bd496a485", "filename": "libstdc++-v3/libio/gen-params", "status": "added", "additions": 751, "deletions": 0, "changes": 751, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Flibio%2Fgen-params", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Flibio%2Fgen-params", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2Fgen-params?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "b899e150afabf483e32ebd24b8dc4d033e62fcde", "filename": "libstdc++-v3/libio/genops.c", "status": "added", "additions": 946, "deletions": 0, "changes": 946, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Flibio%2Fgenops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Flibio%2Fgenops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2Fgenops.c?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "083b198b4485da1c294bc765ca5f33bd59861a7d", "filename": "libstdc++-v3/libio/iolibio.h", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Flibio%2Fiolibio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Flibio%2Fiolibio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2Fiolibio.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "1bc57b2fcc741233fa9691ecc20bd1d1e765c8db", "filename": "libstdc++-v3/libio/libio.h", "status": "added", "additions": 365, "deletions": 0, "changes": 365, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Flibio%2Flibio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Flibio%2Flibio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2Flibio.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "be70f526bbe600580b5f96e0360a86d5426e05be", "filename": "libstdc++-v3/libio/libioP.h", "status": "added", "additions": 648, "deletions": 0, "changes": 648, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Flibio%2FlibioP.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Flibio%2FlibioP.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2FlibioP.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "8453e33c34cd8a18d89eed06ad2f25f97cb30b5d", "filename": "libstdc++-v3/libio/stdfiles.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Flibio%2Fstdfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Flibio%2Fstdfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2Fstdfiles.c?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "df4f242d3ccb8a7ced612190aadfe19c7e777c77", "filename": "libstdc++-v3/m4/lc_messages.m4", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fm4%2Flc_messages.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fm4%2Flc_messages.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fm4%2Flc_messages.m4?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "bb1d23c05562f8e2e68f431bcef9516df9ffacf0", "filename": "libstdc++-v3/m4/mathfcts.m4", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fm4%2Fmathfcts.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fm4%2Fmathfcts.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fm4%2Fmathfcts.m4?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "70652f84c52455eccbef899fd3250716ca4255e4", "filename": "libstdc++-v3/m4/stringfcts.m4", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fm4%2Fstringfcts.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fm4%2Fstringfcts.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fm4%2Fstringfcts.m4?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "4e192c50981e023a2581721535ed38e9ecd946d5", "filename": "libstdc++-v3/math/Makefile.am", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2FMakefile.am?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "79f40e23eda13e8f6bc2c90e2f37c7fc073deb36", "filename": "libstdc++-v3/math/Makefile.in", "status": "added", "additions": 348, "deletions": 0, "changes": 348, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2FMakefile.in?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "1c59dae7a9aa6300f936b48599c741bdda6e925f", "filename": "libstdc++-v3/math/atan2f.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fatan2f.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fatan2f.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2Fatan2f.c?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "c3b8c558858275bfaaea33a3532926d42d39dc05", "filename": "libstdc++-v3/math/c_log.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fc_log.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fc_log.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2Fc_log.c?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "aff2111391cdd8fecec14728133a0553093b60d4", "filename": "libstdc++-v3/math/c_logf.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fc_logf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fc_logf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2Fc_logf.c?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "e1d60cdaa1b284a62921b3c362a15c271a33e394", "filename": "libstdc++-v3/math/c_logl.c", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fc_logl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fc_logl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2Fc_logl.c?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "f2f41e2bd1bad1172c49e9ddc85a91f5713e265e", "filename": "libstdc++-v3/math/cabs.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fcabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fcabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2Fcabs.c?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "53358cfc568dbc6327ddcf018f6a36dafa13e61d", "filename": "libstdc++-v3/math/cabsf.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fcabsf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fcabsf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2Fcabsf.c?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "4b36a3afcbb1be2d19d705129eb16dcadb98f890", "filename": "libstdc++-v3/math/cabsl.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fcabsl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fcabsl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2Fcabsl.c?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "81da1c63fd283226a08e198238560d5287a17c1a", "filename": "libstdc++-v3/math/carg.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fcarg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fcarg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2Fcarg.c?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "90a2f417cccbc0513f0cb00de59f70e7186446d2", "filename": "libstdc++-v3/math/cargf.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fcargf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fcargf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2Fcargf.c?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "f99ad330d88c93154e81e359688021970ecedde6", "filename": "libstdc++-v3/math/cargl.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fcargl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fcargl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2Fcargl.c?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "208c6e6abc37cbef6dd22efaa0e273260caff217", "filename": "libstdc++-v3/math/ccos.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fccos.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fccos.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2Fccos.c?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "0cbf4a040fea9b99a4ae8c7c681debe6be8f98ae", "filename": "libstdc++-v3/math/ccosf.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fccosf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fccosf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2Fccosf.c?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "79fe94e45cb02b7bc9b2b4cb1d711bd5fe9946d9", "filename": "libstdc++-v3/math/ccosh.c", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fccosh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fccosh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2Fccosh.c?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "51c5890e2a7ba15aee629124d72525b69b2768fb", "filename": "libstdc++-v3/math/ccoshf.c", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fccoshf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fccoshf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2Fccoshf.c?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "7bb2dacf3b881b645e87ee398ef78f1fbc90c861", "filename": "libstdc++-v3/math/ccoshl.c", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fccoshl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fccoshl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2Fccoshl.c?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "6531476488c4d9740545b907d9fae6ce1cd4bf12", "filename": "libstdc++-v3/math/ccosl.c", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fccosl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fccosl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2Fccosl.c?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "210220bc58c709660a2436905df49d5afbe7b473", "filename": "libstdc++-v3/math/cexp.c", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fcexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fcexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2Fcexp.c?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "0888cb70fa4f3e16273d6f53a495819e56101961", "filename": "libstdc++-v3/math/cexpf.c", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fcexpf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fcexpf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2Fcexpf.c?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "83cb4db5e584acaaed1201251a9fb4898396be11", "filename": "libstdc++-v3/math/cexpl.c", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fcexpl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fcexpl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2Fcexpl.c?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "e158a9900e38dc5cb9822423816c4bcbb39b227a", "filename": "libstdc++-v3/math/clog10.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fclog10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fclog10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2Fclog10.c?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "b241cec994a26b97b2023ad64a52b6a23010e9de", "filename": "libstdc++-v3/math/clog10f.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fclog10f.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fclog10f.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2Fclog10f.c?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "e183862ffcc5a48421a1b900754b31d03d6f337f", "filename": "libstdc++-v3/math/clog10l.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fclog10l.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fclog10l.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2Fclog10l.c?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "afc7ef68f654f206c85c78f6f9a1341a89c9b6ff", "filename": "libstdc++-v3/math/complex-stub.h", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fcomplex-stub.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fcomplex-stub.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2Fcomplex-stub.h?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "968c1472b60a3a5414e7a78293140066ec718e2f", "filename": "libstdc++-v3/math/copysignf.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fcopysignf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fcopysignf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2Fcopysignf.c?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "5d816a1d0d64f15f548cc836070c06136977b27a", "filename": "libstdc++-v3/math/cpow.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fcpow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fcpow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2Fcpow.c?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "d4aa5904f86faa85084d31006d13731a0f14cee7", "filename": "libstdc++-v3/math/cpowf.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fcpowf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fcpowf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2Fcpowf.c?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "65856d48ec4b105ef5aa84888f375444900feead", "filename": "libstdc++-v3/math/cpowl.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fcpowl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fcpowl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2Fcpowl.c?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "bde60196e1b182857882add9bb3a3d45d4b279c8", "filename": "libstdc++-v3/math/csin.c", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fcsin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fcsin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2Fcsin.c?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "8c66865380a4a8ee026e42b6a2b1a15ab69fdb26", "filename": "libstdc++-v3/math/csinf.c", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fcsinf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fcsinf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2Fcsinf.c?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "9da924b1c66ba0a95e1c0400f2de92d64cc4daa7", "filename": "libstdc++-v3/math/csinh.c", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fcsinh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fcsinh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2Fcsinh.c?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "3aaf49aa208393e0b03e3d7b250ce34b5ab8fa88", "filename": "libstdc++-v3/math/csinhf.c", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fcsinhf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fcsinhf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2Fcsinhf.c?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "efd45a24323dfe47d110c7a0abdc42a5ec1faacc", "filename": "libstdc++-v3/math/csinhl.c", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fcsinhl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fcsinhl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2Fcsinhl.c?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "423b459d667aae76f1e820a04a85b0e563848fe4", "filename": "libstdc++-v3/math/csinl.c", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fcsinl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fcsinl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2Fcsinl.c?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "53551653ae0db36b99932db9e7758d6b7dd5b528", "filename": "libstdc++-v3/math/csqrt.c", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fcsqrt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fcsqrt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2Fcsqrt.c?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "a239588a646de841f8f5087e5946d544943b3350", "filename": "libstdc++-v3/math/csqrtf.c", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fcsqrtf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fcsqrtf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2Fcsqrtf.c?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "d871a69afb01643f2fd878c1f025c27201f1ac4a", "filename": "libstdc++-v3/math/csqrtl.c", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fcsqrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fcsqrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2Fcsqrtl.c?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "2a35c1822c3c4bea403fa45305cd10668955ed08", "filename": "libstdc++-v3/math/ctan.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fctan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fctan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2Fctan.c?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "ebd8cfa3eb0b37e85abb5443ecc4e38db3477fb3", "filename": "libstdc++-v3/math/ctanf.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fctanf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fctanf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2Fctanf.c?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "5db5cd65a8a8e7e58b7f2fc3441a3bf6224002a8", "filename": "libstdc++-v3/math/ctanh.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fctanh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fctanh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2Fctanh.c?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "b5f1ccea94ab9a129706c0f2c43d41f9105eb616", "filename": "libstdc++-v3/math/ctanhf.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fctanhf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fctanhf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2Fctanhf.c?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "3fdf1fcb6c818d15bbd5f3225ca961bd89213732", "filename": "libstdc++-v3/math/ctanhl.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fctanhl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fctanhl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2Fctanhl.c?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "0af4cecf6e238d646801203fa77162e6279c010f", "filename": "libstdc++-v3/math/ctanl.c", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fctanl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fctanl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2Fctanl.c?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}, {"sha": "a597502f8a019840e97a18c88bc8257bfc5e244f", "filename": "libstdc++-v3/math/expf.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fexpf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dad0e3727cadca78d4c2cc51596d1ef1bf0946/libstdc%2B%2B-v3%2Fmath%2Fexpf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2Fexpf.c?ref=b2dad0e3727cadca78d4c2cc51596d1ef1bf0946"}]}