{"sha": "a6a12bb9de5452dcd08dfe62432ebf4ab8c3e04f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTZhMTJiYjlkZTU0NTJkY2QwOGRmZTYyNDMyZWJmNGFiOGMzZTA0Zg==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2006-03-29T22:40:17Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2006-03-29T22:40:17Z"}, "message": "stor-layout.c (mode_for_size_tree): Remove restiction on type sizes by correctly testing whether the size fits a...\n\n\n\t* stor-layout.c (mode_for_size_tree): Remove restiction on type\n\tsizes by correctly testing whether the size fits a host integer.\n\t(initialize_sizetypes): Use set_min_and_max_values_for_integral_type\n\tto correctly set TYPE_MIN_VALUE and TYPE_MAX_VALUE to the full\n\tSImode range for the default sizetype and bitsizetype.\n\nFrom-SVN: r112513", "tree": {"sha": "ca10d5eb72bc1f5de3fd9b33542544396b8a4e5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca10d5eb72bc1f5de3fd9b33542544396b8a4e5b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6a12bb9de5452dcd08dfe62432ebf4ab8c3e04f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6a12bb9de5452dcd08dfe62432ebf4ab8c3e04f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6a12bb9de5452dcd08dfe62432ebf4ab8c3e04f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6a12bb9de5452dcd08dfe62432ebf4ab8c3e04f/comments", "author": null, "committer": null, "parents": [{"sha": "68441323e2cc02348391d8108fbe22c34aab56f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68441323e2cc02348391d8108fbe22c34aab56f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68441323e2cc02348391d8108fbe22c34aab56f4"}], "stats": {"total": 36, "additions": 22, "deletions": 14}, "files": [{"sha": "3448d7b6670922e9c9d4e7c268733e72efa81dd0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6a12bb9de5452dcd08dfe62432ebf4ab8c3e04f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6a12bb9de5452dcd08dfe62432ebf4ab8c3e04f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a6a12bb9de5452dcd08dfe62432ebf4ab8c3e04f", "patch": "@@ -1,3 +1,11 @@\n+2006-03-29  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* stor-layout.c (mode_for_size_tree): Remove restiction on type\n+\tsizes by correctly testing whether the size fits a host integer.\n+\t(initialize_sizetypes): Use set_min_and_max_values_for_integral_type\n+\tto correctly set TYPE_MIN_VALUE and TYPE_MAX_VALUE to the full\n+\tSImode range for the default sizetype and bitsizetype.\n+\n 2006-03-29  Roger Sayle  <roger@eyesopen.com>\n \n \t* convert.c (convert_to_pointer): Preserve the TREE_OVERFLOW"}, {"sha": "723e06892015f5c4a41ae96eac60518a185ab76e", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6a12bb9de5452dcd08dfe62432ebf4ab8c3e04f/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6a12bb9de5452dcd08dfe62432ebf4ab8c3e04f/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=a6a12bb9de5452dcd08dfe62432ebf4ab8c3e04f", "patch": "@@ -190,15 +190,16 @@ mode_for_size (unsigned int size, enum mode_class class, int limit)\n enum machine_mode\n mode_for_size_tree (tree size, enum mode_class class, int limit)\n {\n-  if (TREE_CODE (size) != INTEGER_CST\n-      || TREE_OVERFLOW (size)\n-      /* What we really want to say here is that the size can fit in a\n-\t host integer, but we know there's no way we'd find a mode for\n-\t this many bits, so there's no point in doing the precise test.  */\n-      || compare_tree_int (size, 1000) > 0)\n+  unsigned HOST_WIDE_INT uhwi;\n+  unsigned int ui;\n+\n+  if (!host_integerp (size, 1))\n     return BLKmode;\n-  else\n-    return mode_for_size (tree_low_cst (size, 1), class, limit);\n+  uhwi = tree_low_cst (size, 1);\n+  ui = uhwi;\n+  if (uhwi != ui)\n+    return BLKmode;\n+  return mode_for_size (ui, class, limit);\n }\n \n /* Similar, but never return BLKmode; return the narrowest mode that\n@@ -1938,20 +1939,19 @@ void\n initialize_sizetypes (bool signed_p)\n {\n   tree t = make_node (INTEGER_TYPE);\n+  int precision = GET_MODE_BITSIZE (SImode);\n \n   TYPE_MODE (t) = SImode;\n   TYPE_ALIGN (t) = GET_MODE_ALIGNMENT (SImode);\n   TYPE_USER_ALIGN (t) = 0;\n   TYPE_IS_SIZETYPE (t) = 1;\n   TYPE_UNSIGNED (t) = !signed_p;\n-  TYPE_SIZE (t) = build_int_cst (t, GET_MODE_BITSIZE (SImode));\n+  TYPE_SIZE (t) = build_int_cst (t, precision);\n   TYPE_SIZE_UNIT (t) = build_int_cst (t, GET_MODE_SIZE (SImode));\n-  TYPE_PRECISION (t) = GET_MODE_BITSIZE (SImode);\n-  TYPE_MIN_VALUE (t) = build_int_cst (t, 0);\n+  TYPE_PRECISION (t) = precision;\n \n-  /* 1000 avoids problems with possible overflow and is certainly\n-     larger than any size value we'd want to be storing.  */\n-  TYPE_MAX_VALUE (t) = build_int_cst (t, 1000);\n+  /* Set TYPE_MIN_VALUE and TYPE_MAX_VALUE.  */\n+  set_min_and_max_values_for_integral_type (t, precision, !signed_p);\n \n   sizetype = t;\n   bitsizetype = build_distinct_type_copy (t);"}]}