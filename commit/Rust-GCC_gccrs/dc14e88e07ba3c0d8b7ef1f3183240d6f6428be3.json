{"sha": "dc14e88e07ba3c0d8b7ef1f3183240d6f6428be3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGMxNGU4OGUwN2JhM2MwZDhiN2VmMWYzMTgzMjQwZDZmNjQyOGJlMw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-08-02T00:54:15Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-08-02T00:54:15Z"}, "message": "re PR other/61895 (libbacktrace crashes with bus error with empty file argv[0])\n\n\tPR other/61895\n\nruntime: Ignore small argv[0] file for backtrace.\n\nReportedly in some cases Docker starts processes with argv[0]\npointing to an empty file.  That would cause libgo to pass\nthat empty file to libbacktrace, which would then fail to do\nany backtraces.  Everything should work fine if libbacktrace\nfalls back to /proc/self/exe.\n\nThis patch to libgo works around the problem by ignoring\nargv[0] if it is a small file, or if stat fails.  This is not\na perfect fix but it's an unusual problem.\n\nFrom-SVN: r213513", "tree": {"sha": "d37998f4cbceacc74d2de058a6ad5c59557e4f02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d37998f4cbceacc74d2de058a6ad5c59557e4f02"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc14e88e07ba3c0d8b7ef1f3183240d6f6428be3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc14e88e07ba3c0d8b7ef1f3183240d6f6428be3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc14e88e07ba3c0d8b7ef1f3183240d6f6428be3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc14e88e07ba3c0d8b7ef1f3183240d6f6428be3/comments", "author": null, "committer": null, "parents": [{"sha": "3bc63227d5eb38a70adee7375e5d3596e9c7ec01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bc63227d5eb38a70adee7375e5d3596e9c7ec01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3bc63227d5eb38a70adee7375e5d3596e9c7ec01"}], "stats": {"total": 12, "additions": 12, "deletions": 0}, "files": [{"sha": "7fcdf2021d399f7c4abeaa1d2bd43b906ed32ac3", "filename": "libgo/runtime/go-caller.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc14e88e07ba3c0d8b7ef1f3183240d6f6428be3/libgo%2Fruntime%2Fgo-caller.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc14e88e07ba3c0d8b7ef1f3183240d6f6428be3/libgo%2Fruntime%2Fgo-caller.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-caller.c?ref=dc14e88e07ba3c0d8b7ef1f3183240d6f6428be3", "patch": "@@ -7,6 +7,9 @@\n /* Implement runtime.Caller.  */\n \n #include <stdint.h>\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+#include <unistd.h>\n \n #include \"backtrace.h\"\n \n@@ -99,6 +102,7 @@ __go_get_backtrace_state ()\n   if (back_state == NULL)\n     {\n       const char *filename;\n+      struct stat s;\n \n       filename = (const char *) runtime_progname ();\n \n@@ -108,6 +112,14 @@ __go_get_backtrace_state ()\n       if (__builtin_strchr (filename, '/') == NULL)\n \tfilename = NULL;\n \n+      /* If the file is small, then it's not the real executable.\n+\t This is specifically to deal with Docker, which uses a bogus\n+\t argv[0] (http://gcc.gnu.org/PR61895).  It would be nice to\n+\t have a better check for whether this file is the real\n+\t executable.  */\n+      if (stat (filename, &s) < 0 || s.st_size < 1024)\n+\tfilename = NULL;\n+\n       back_state = backtrace_create_state (filename, 1, error_callback, NULL);\n     }\n   runtime_unlock (&back_state_lock);"}]}