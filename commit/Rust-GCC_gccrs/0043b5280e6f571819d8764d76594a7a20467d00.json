{"sha": "0043b5280e6f571819d8764d76594a7a20467d00", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDA0M2I1MjgwZTZmNTcxODE5ZDg3NjRkNzY1OTRhN2EyMDQ2N2QwMA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-10-05T07:36:09Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-10-05T07:36:09Z"}, "message": "re PR tree-optimization/91734 (gcc skip an if statement  with \"-O1 -ffast-math\")\n\n\tPR tree-optimization/91734\n\t* generic-match-head.c: Include fold-const-call.h.\n\t* match.pd (sqrt(x) cmp c): Check the boundary value and\n\tin case inexact computation of c*c affects comparison of the boundary,\n\tturn LT_EXPR into LE_EXPR, GE_EXPR into GT_EXPR, LE_EXPR into LT_EXPR\n\tor GT_EXPR into GE_EXPR.  Punt for sqrt comparisons against NaN and\n\tfor -frounding-math.  For c2, try the next smaller or larger floating\n\tpoint constant depending on comparison code and if it has the same\n\tsqrt as c2, use it instead of c2.\n\n\t* gcc.dg/pr91734.c: New test.\n\nFrom-SVN: r276621", "tree": {"sha": "67f05915a1d5bd9c404586fb97a5e8fbc421c015", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67f05915a1d5bd9c404586fb97a5e8fbc421c015"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0043b5280e6f571819d8764d76594a7a20467d00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0043b5280e6f571819d8764d76594a7a20467d00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0043b5280e6f571819d8764d76594a7a20467d00", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0043b5280e6f571819d8764d76594a7a20467d00/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "30648d02155fd2cf5e15c9741f08ed08554fa3d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30648d02155fd2cf5e15c9741f08ed08554fa3d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30648d02155fd2cf5e15c9741f08ed08554fa3d6"}], "stats": {"total": 260, "additions": 213, "deletions": 47}, "files": [{"sha": "171d554483983b37f88ccbf84540e48e55224549", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0043b5280e6f571819d8764d76594a7a20467d00/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0043b5280e6f571819d8764d76594a7a20467d00/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0043b5280e6f571819d8764d76594a7a20467d00", "patch": "@@ -1,3 +1,15 @@\n+2019-10-05  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/91734\n+\t* generic-match-head.c: Include fold-const-call.h.\n+\t* match.pd (sqrt(x) cmp c): Check the boundary value and\n+\tin case inexact computation of c*c affects comparison of the boundary,\n+\tturn LT_EXPR into LE_EXPR, GE_EXPR into GT_EXPR, LE_EXPR into LT_EXPR\n+\tor GT_EXPR into GE_EXPR.  Punt for sqrt comparisons against NaN and\n+\tfor -frounding-math.  For c2, try the next smaller or larger floating\n+\tpoint constant depending on comparison code and if it has the same\n+\tsqrt as c2, use it instead of c2.\n+\n 2019-10-04  Martin Sebor  <msebor@redhat.com>\n \n \tPR middle-end/91977"}, {"sha": "fdc603977fc5b03a843944f75ce262f5d2256308", "filename": "gcc/generic-match-head.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0043b5280e6f571819d8764d76594a7a20467d00/gcc%2Fgeneric-match-head.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0043b5280e6f571819d8764d76594a7a20467d00/gcc%2Fgeneric-match-head.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgeneric-match-head.c?ref=0043b5280e6f571819d8764d76594a7a20467d00", "patch": "@@ -29,6 +29,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cgraph.h\"\n #include \"vec-perm-indices.h\"\n #include \"fold-const.h\"\n+#include \"fold-const-call.h\"\n #include \"stor-layout.h\"\n #include \"tree-dfa.h\"\n #include \"builtins.h\""}, {"sha": "e3ac06c8ef5b893bd344734095b11047a43f98b8", "filename": "gcc/match.pd", "status": "modified", "additions": 98, "deletions": 47, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0043b5280e6f571819d8764d76594a7a20467d00/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0043b5280e6f571819d8764d76594a7a20467d00/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=0043b5280e6f571819d8764d76594a7a20467d00", "patch": "@@ -3726,8 +3726,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n      (cmp { tem; } @1)))))\n \n  /* Fold comparisons against built-in math functions.  */\n- (if (flag_unsafe_math_optimizations\n-      && ! flag_errno_math)\n+ (if (flag_unsafe_math_optimizations && ! flag_errno_math)\n   (for sq (SQRT)\n    (simplify\n     (cmp (sq @0) REAL_CST@1)\n@@ -3762,56 +3761,108 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n \t  if x is negative or NaN.  Due to -funsafe-math-optimizations,\n \t  the results for other x follow from natural arithmetic.  */\n        (cmp @0 @1)))\n-     (if (cmp == GT_EXPR || cmp == GE_EXPR)\n+     (if ((cmp == LT_EXPR\n+\t   || cmp == LE_EXPR\n+\t   || cmp == GT_EXPR\n+\t   || cmp == GE_EXPR)\n+\t  && !REAL_VALUE_ISNAN (TREE_REAL_CST (@1))\n+\t  /* Give up for -frounding-math.  */\n+\t  && !HONOR_SIGN_DEPENDENT_ROUNDING (TREE_TYPE (@0)))\n       (with\n        {\n-         REAL_VALUE_TYPE c2;\n+\t REAL_VALUE_TYPE c2;\n+\t enum tree_code ncmp = cmp;\n+\t const real_format *fmt\n+\t   = REAL_MODE_FORMAT (TYPE_MODE (TREE_TYPE (@0)));\n \t real_arithmetic (&c2, MULT_EXPR,\n \t\t\t  &TREE_REAL_CST (@1), &TREE_REAL_CST (@1));\n-\t real_convert (&c2, TYPE_MODE (TREE_TYPE (@0)), &c2);\n-       }\n-       (if (REAL_VALUE_ISINF (c2))\n-\t/* sqrt(x) > y is x == +Inf, when y is very large.  */\n-\t(if (HONOR_INFINITIES (@0))\n-\t (eq @0 { build_real (TREE_TYPE (@0), c2); })\n-\t { constant_boolean_node (false, type); })\n-\t/* sqrt(x) > c is the same as x > c*c.  */\n-\t(cmp @0 { build_real (TREE_TYPE (@0), c2); }))))\n-     (if (cmp == LT_EXPR || cmp == LE_EXPR)\n-      (with\n-       {\n-       \t REAL_VALUE_TYPE c2;\n-\t real_arithmetic (&c2, MULT_EXPR,\n-\t\t\t  &TREE_REAL_CST (@1), &TREE_REAL_CST (@1));\n-\t real_convert (&c2, TYPE_MODE (TREE_TYPE (@0)), &c2);\n+\t real_convert (&c2, fmt, &c2);\n+\t /* See PR91734: if c2 is inexact and sqrt(c2) < c (or sqrt(c2) >= c),\n+\t    then change LT_EXPR into LE_EXPR or GE_EXPR into GT_EXPR.  */\n+\t if (!REAL_VALUE_ISINF (c2))\n+\t   {\n+\t     tree c3 = fold_const_call (CFN_SQRT, TREE_TYPE (@0),\n+\t\t\t\t\tbuild_real (TREE_TYPE (@0), c2));\n+\t     if (c3 == NULL_TREE || TREE_CODE (c3) != REAL_CST)\n+\t       ncmp = ERROR_MARK;\n+\t     else if ((cmp == LT_EXPR || cmp == GE_EXPR)\n+\t\t      && real_less (&TREE_REAL_CST (c3), &TREE_REAL_CST (@1)))\n+\t       ncmp = cmp == LT_EXPR ? LE_EXPR : GT_EXPR;\n+\t     else if ((cmp == LE_EXPR || cmp == GT_EXPR)\n+\t\t      && real_less (&TREE_REAL_CST (@1), &TREE_REAL_CST (c3)))\n+\t       ncmp = cmp == LE_EXPR ? LT_EXPR : GE_EXPR;\n+\t     else\n+\t       {\n+\t\t /* With rounding to even, sqrt of up to 3 different values\n+\t\t    gives the same normal result, so in some cases c2 needs\n+\t\t    to be adjusted.  */\n+\t\t REAL_VALUE_TYPE c2alt, tow;\n+\t\t if (cmp == LT_EXPR || cmp == GE_EXPR)\n+\t\t   tow = dconst0;\n+\t\t else\n+\t\t   real_inf (&tow);\n+\t\t real_nextafter (&c2alt, fmt, &c2, &tow);\n+\t\t real_convert (&c2alt, fmt, &c2alt);\n+\t\t if (REAL_VALUE_ISINF (c2alt))\n+\t\t   ncmp = ERROR_MARK;\n+\t\t else\n+\t\t   {\n+\t\t     c3 = fold_const_call (CFN_SQRT, TREE_TYPE (@0),\n+\t\t\t\t\t   build_real (TREE_TYPE (@0), c2alt));\n+\t\t     if (c3 == NULL_TREE || TREE_CODE (c3) != REAL_CST)\n+\t\t       ncmp = ERROR_MARK;\n+\t\t     else if (real_equal (&TREE_REAL_CST (c3),\n+\t\t\t\t\t  &TREE_REAL_CST (@1)))\n+\t\t       c2 = c2alt;\n+\t\t   }\n+\t       }\n+\t   }\n        }\n-       (if (REAL_VALUE_ISINF (c2))\n-        (switch\n-\t /* sqrt(x) < y is always true, when y is a very large\n-\t    value and we don't care about NaNs or Infinities.  */\n-\t (if (! HONOR_NANS (@0) && ! HONOR_INFINITIES (@0))\n-\t  { constant_boolean_node (true, type); })\n-\t /* sqrt(x) < y is x != +Inf when y is very large and we\n-\t    don't care about NaNs.  */\n-\t (if (! HONOR_NANS (@0))\n-\t  (ne @0 { build_real (TREE_TYPE (@0), c2); }))\n-\t /* sqrt(x) < y is x >= 0 when y is very large and we\n-\t    don't care about Infinities.  */\n-\t (if (! HONOR_INFINITIES (@0))\n-\t  (ge @0 { build_real (TREE_TYPE (@0), dconst0); }))\n-\t /* sqrt(x) < y is x >= 0 && x != +Inf, when y is large.  */\n-\t (if (GENERIC)\n-\t  (truth_andif\n-\t   (ge @0 { build_real (TREE_TYPE (@0), dconst0); })\n-\t   (ne @0 { build_real (TREE_TYPE (@0), c2); }))))\n-\t/* sqrt(x) < c is the same as x < c*c, if we ignore NaNs.  */\n-\t(if (! HONOR_NANS (@0))\n-\t (cmp @0 { build_real (TREE_TYPE (@0), c2); })\n-\t /* sqrt(x) < c is the same as x >= 0 && x < c*c.  */\n-\t (if (GENERIC)\n-\t  (truth_andif\n-\t   (ge @0 { build_real (TREE_TYPE (@0), dconst0); })\n-\t   (cmp @0 { build_real (TREE_TYPE (@0), c2); })))))))))\n+       (if (cmp == GT_EXPR || cmp == GE_EXPR)\n+\t(if (REAL_VALUE_ISINF (c2))\n+\t /* sqrt(x) > y is x == +Inf, when y is very large.  */\n+\t (if (HONOR_INFINITIES (@0))\n+\t  (eq @0 { build_real (TREE_TYPE (@0), c2); })\n+\t  { constant_boolean_node (false, type); })\n+\t /* sqrt(x) > c is the same as x > c*c.  */\n+\t (if (ncmp != ERROR_MARK)\n+\t  (if (ncmp == GE_EXPR)\n+\t   (ge @0 { build_real (TREE_TYPE (@0), c2); })\n+\t   (gt @0 { build_real (TREE_TYPE (@0), c2); }))))\n+\t/* else if (cmp == LT_EXPR || cmp == LE_EXPR)  */\n+\t(if (REAL_VALUE_ISINF (c2))\n+\t (switch\n+\t  /* sqrt(x) < y is always true, when y is a very large\n+\t     value and we don't care about NaNs or Infinities.  */\n+\t  (if (! HONOR_NANS (@0) && ! HONOR_INFINITIES (@0))\n+\t   { constant_boolean_node (true, type); })\n+\t  /* sqrt(x) < y is x != +Inf when y is very large and we\n+\t     don't care about NaNs.  */\n+\t  (if (! HONOR_NANS (@0))\n+\t   (ne @0 { build_real (TREE_TYPE (@0), c2); }))\n+\t  /* sqrt(x) < y is x >= 0 when y is very large and we\n+\t     don't care about Infinities.  */\n+\t  (if (! HONOR_INFINITIES (@0))\n+\t   (ge @0 { build_real (TREE_TYPE (@0), dconst0); }))\n+\t  /* sqrt(x) < y is x >= 0 && x != +Inf, when y is large.  */\n+\t  (if (GENERIC)\n+\t   (truth_andif\n+\t    (ge @0 { build_real (TREE_TYPE (@0), dconst0); })\n+\t    (ne @0 { build_real (TREE_TYPE (@0), c2); }))))\n+\t /* sqrt(x) < c is the same as x < c*c, if we ignore NaNs.  */\n+\t (if (ncmp != ERROR_MARK && ! HONOR_NANS (@0))\n+\t  (if (ncmp == LT_EXPR)\n+\t   (lt @0 { build_real (TREE_TYPE (@0), c2); })\n+\t   (le @0 { build_real (TREE_TYPE (@0), c2); }))\n+\t  /* sqrt(x) < c is the same as x >= 0 && x < c*c.  */\n+\t  (if (ncmp != ERROR_MARK && GENERIC)\n+\t   (if (ncmp == LT_EXPR)\n+\t    (truth_andif\n+\t     (ge @0 { build_real (TREE_TYPE (@0), dconst0); })\n+\t     (lt @0 { build_real (TREE_TYPE (@0), c2); }))\n+\t    (truth_andif\n+\t     (ge @0 { build_real (TREE_TYPE (@0), dconst0); })\n+\t     (le @0 { build_real (TREE_TYPE (@0), c2); })))))))))))\n    /* Transform sqrt(x) cmp sqrt(y) -> x cmp y.  */\n    (simplify\n     (cmp (sq @0) (sq @1))"}, {"sha": "10ba0d9ed7d7fdd215abc48a526e0bba425080a6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0043b5280e6f571819d8764d76594a7a20467d00/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0043b5280e6f571819d8764d76594a7a20467d00/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0043b5280e6f571819d8764d76594a7a20467d00", "patch": "@@ -1,3 +1,8 @@\n+2019-10-05  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/91734\n+\t* gcc.dg/pr91734.c: New test.\n+\n 2019-10-04  Joseph Myers  <joseph@codesourcery.com>\n \n \tPR c/82752"}, {"sha": "1cc3e40ccbc023e097e493c1100e4d61969f12c7", "filename": "gcc/testsuite/gcc.dg/pr91734.c", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0043b5280e6f571819d8764d76594a7a20467d00/gcc%2Ftestsuite%2Fgcc.dg%2Fpr91734.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0043b5280e6f571819d8764d76594a7a20467d00/gcc%2Ftestsuite%2Fgcc.dg%2Fpr91734.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr91734.c?ref=0043b5280e6f571819d8764d76594a7a20467d00", "patch": "@@ -0,0 +1,97 @@\n+/* PR tree-optimization/91734 */\n+/* { dg-do run } */\n+/* { dg-add-options ieee } */\n+/* { dg-additional-options \"-O2 -std=gnu99\" } */\n+\n+__attribute__((noipa, optimize (\"Ofast\"))) int\n+f1 (float x)\n+{\n+  return __builtin_sqrtf (x) < __FLT_MIN__;\n+}\n+\n+__attribute__((noipa, optimize (\"Ofast\"))) int\n+f2 (float x)\n+{\n+  return __builtin_sqrtf (x) < 0x1.2dd3d0p-65f;\n+}\n+\n+__attribute__((noipa, optimize (\"Ofast\"))) int\n+f3 (float x)\n+{\n+  return __builtin_sqrtf (x) >= 0x1.2dd3d0p-65f;\n+}\n+\n+__attribute__((noipa, optimize (\"Ofast\"))) int\n+f4 (float x)\n+{\n+  return __builtin_sqrtf (x) >= 0x1.5642e6p+54f;\n+}\n+\n+__attribute__((noipa, optimize (\"Ofast\"))) int\n+f5 (float x)\n+{\n+  return __builtin_sqrtf (x) > 0x1.5642e6p+54f;\n+}\n+\n+__attribute__((noipa, optimize (\"Ofast\"))) int\n+f6 (float x)\n+{\n+  return __builtin_sqrtf (x) < 0x1.4da1cp-19f;\n+}\n+\n+__attribute__((noipa, optimize (\"Ofast\"))) int\n+f7 (float x)\n+{\n+  return __builtin_sqrtf (x) <= 0x1.4da1cp-19f;\n+}\n+\n+__attribute__((noipa, optimize (\"Ofast\"))) int\n+f8 (float x)\n+{\n+  return __builtin_sqrtf (x) < 0x1.50cb62p-65f;\n+}\n+\n+__attribute__((noipa, optimize (\"Ofast\"))) int\n+f9 (float x)\n+{\n+  return __builtin_sqrtf (x) <= 0x1.4fc00cp-73f;\n+}\n+\n+__attribute__((noipa, optimize (\"Ofast\"))) int\n+f10 (float x)\n+{\n+  return __builtin_sqrtf (x) < 0x1.001002p+0f;\n+}\n+\n+int\n+main ()\n+{\n+  if (__FLT_RADIX__ != 2\n+      || __FLT_MANT_DIG__ != 24\n+      || __FLT_MIN_EXP__ != -125\n+      || __FLT_MAX_EXP__ != 128\n+      || __FLT_HAS_DENORM__ != 1\n+      || __FLT_HAS_INFINITY__ != 1)\n+    return 0;\n+  if (!f1 (0.0f) || f1 (0x1.0p-149f))\n+    __builtin_abort ();\n+  if (!f2 (0x1.63dbc0p-130f))\n+    __builtin_abort ();\n+  if (f3 (0x1.63dbc0p-130f))\n+    __builtin_abort ();\n+  if (!f4 (0x1.c996d0p+108f) || !f4 (0x1.c996cep+108f) || f4 (0x1.c996ccp+108f))\n+    __builtin_abort ();\n+  if (f5 (0x1.c996d0p+108f) || f5 (0x1.c996d2p+108f) || !f5 (0x1.c996d4p+108f))\n+    __builtin_abort ();\n+  if (!f6 (0x1.b2ce3p-38f) || f6 (0x1.b2ce32p-38f) || f6 (0x1.b2ce34p-38f))\n+    __builtin_abort ();\n+  if (!f7 (0x1.b2ce3p-38f) || !f7 (0x1.b2ce34p-38f) || !f7 (0x1.b2ce36p-38f) || f7 (0x1.b2ce38p-38f))\n+    __builtin_abort ();\n+  if (!f8 (0x1.bb166p-130f) || !f8 (0x1.bb168p-130f) || f8 (0x1.bb16ap-130f) || f8 (0x1.bb16cp-130f))\n+    __builtin_abort ();\n+  if (!f9 (0x1.8p-146f) || !f9 (0x1.ap-146f) || f9 (0x1.cp-146f) || f9 (0x1.ep-146f))\n+    __builtin_abort ();\n+  if (f10 (0x1.002004p+0f))\n+    __builtin_abort ();\n+  return 0;\n+}"}]}