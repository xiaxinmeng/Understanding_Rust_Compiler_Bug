{"sha": "0988b758459e0f4a90322fd127b90dfedc8cfafd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDk4OGI3NTg0NTllMGY0YTkwMzIyZmQxMjdiOTBkZmVkYzhjZmFmZA==", "commit": {"author": {"name": "Bernardo Innocenti", "email": "bernie@develer.com", "date": "2003-09-19T16:39:44Z"}, "committer": {"name": "Bernardo Innocenti", "email": "bernie@gcc.gnu.org", "date": "2003-09-19T16:39:44Z"}, "message": "m68k.h (TARGET_CPU_CPP_PREDEFINES): Add predefines for -m68030, -m68020-60 and -m68020-40.\n\n\t* config/m68k/m68k.h (TARGET_CPU_CPP_PREDEFINES): Add predefines\n\tfor -m68030, -m68020-60 and -m68020-40.\n\t* config/m68k/m68k.h (TARGET_68030): New target flag.\n\t* config/m68k/m68k.h (MASK_RTD, TARGET_RTD, MASK_REGPARM,\n\tTARGET_REGPARM): Remove.\n\t* config/m68k/m68k.h: Regroup and renumber target flags.\n\t* config/m68k/m68k.h (TARGET_SWITCHES): Fix some tabulations.\n\t* config/m68k/m68k.h (RETURN_POPS_ARGS): Always evaluate to 0.\n\t* config/m68k/m68k.h (FUNCTION_ARG): Likewise.\n\t* config/m68k/m68k.h (FUNCTION_ARG_PARTIAL_NREGS): Likewise.\n\t* config/m68k/m68k-none.h: Use MASK_xxx values in M68K_CPU_xxx macros.\n\nFrom-SVN: r71577", "tree": {"sha": "d6a39f7720f88a1b0bf25abd6e225d60e748cf99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d6a39f7720f88a1b0bf25abd6e225d60e748cf99"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0988b758459e0f4a90322fd127b90dfedc8cfafd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0988b758459e0f4a90322fd127b90dfedc8cfafd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0988b758459e0f4a90322fd127b90dfedc8cfafd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0988b758459e0f4a90322fd127b90dfedc8cfafd/comments", "author": {"login": "codewiz", "id": 1184492, "node_id": "MDQ6VXNlcjExODQ0OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/1184492?v=4", "gravatar_id": "", "url": "https://api.github.com/users/codewiz", "html_url": "https://github.com/codewiz", "followers_url": "https://api.github.com/users/codewiz/followers", "following_url": "https://api.github.com/users/codewiz/following{/other_user}", "gists_url": "https://api.github.com/users/codewiz/gists{/gist_id}", "starred_url": "https://api.github.com/users/codewiz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/codewiz/subscriptions", "organizations_url": "https://api.github.com/users/codewiz/orgs", "repos_url": "https://api.github.com/users/codewiz/repos", "events_url": "https://api.github.com/users/codewiz/events{/privacy}", "received_events_url": "https://api.github.com/users/codewiz/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ed71e586b9b0ae1aa76e6a46626ced279b5cfd96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed71e586b9b0ae1aa76e6a46626ced279b5cfd96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed71e586b9b0ae1aa76e6a46626ced279b5cfd96"}], "stats": {"total": 283, "additions": 140, "deletions": 143}, "files": [{"sha": "98fec669ae3c88c86a0d72190d98aa6a6ed46eef", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0988b758459e0f4a90322fd127b90dfedc8cfafd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0988b758459e0f4a90322fd127b90dfedc8cfafd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0988b758459e0f4a90322fd127b90dfedc8cfafd", "patch": "@@ -1,3 +1,17 @@\n+2003-09-19  Bernardo Innocenti  <bernie@develer.com>\n+\n+\t* config/m68k/m68k.h (TARGET_CPU_CPP_PREDEFINES): Add predefines\n+\tfor -m68030, -m68020-60 and -m68020-40.\n+\t* config/m68k/m68k.h (TARGET_68030): New target flag.\n+\t* config/m68k/m68k.h (MASK_RTD, TARGET_RTD, MASK_REGPARM,\n+\tTARGET_REGPARM): Remove.\n+\t* config/m68k/m68k.h: Regroup and renumber target flags.\n+\t* config/m68k/m68k.h (TARGET_SWITCHES): Fix some tabulations.\n+\t* config/m68k/m68k.h (RETURN_POPS_ARGS): Always evaluate to 0.\n+\t* config/m68k/m68k.h (FUNCTION_ARG): Likewise.\n+\t* config/m68k/m68k.h (FUNCTION_ARG_PARTIAL_NREGS): Likewise.\n+\t* config/m68k/m68k-none.h: Use MASK_xxx values in M68K_CPU_xxx macros.\n+\n 2003-09-19  Ralf Corsepius <corsepiu@faw.uni-ulm.de>\n \n \t* config/m68k/t-rtems (m68k-*-rtems*): New."}, {"sha": "040122f01d2e4e0fd41450d478691574cdfcbeba", "filename": "gcc/config/m68k/m68k-none.h", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0988b758459e0f4a90322fd127b90dfedc8cfafd/gcc%2Fconfig%2Fm68k%2Fm68k-none.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0988b758459e0f4a90322fd127b90dfedc8cfafd/gcc%2Fconfig%2Fm68k%2Fm68k-none.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k-none.h?ref=0988b758459e0f4a90322fd127b90dfedc8cfafd", "patch": "@@ -24,17 +24,15 @@ Boston, MA 02111-1307, USA.  */\n #endif\n \n /* These are values set by the configure script in TARGET_CPU_DEFAULT.\n-   They are ((desired value for TARGET_DEFAULT) << 4) + sequential integer.\n-   See m68k.h for the values (it should really define MASK_FOO so we can\n-   use them).  */\n-#define M68K_CPU_m68k\t((7 << 4) + 0)\n-#define M68K_CPU_m68000 ((0 << 4) + 1)\n-#define M68K_CPU_m68010 ((0 << 4) + 1) /* make same as m68000 */\n-#define M68K_CPU_m68020 ((7 << 4) + 2)\n-#define M68K_CPU_m68030 ((7 << 4) + 3)\n-#define M68K_CPU_m68040 ((01007 << 4) + 4)\n-#define M68K_CPU_m68302 ((0 << 4) + 5)\n-#define M68K_CPU_m68332 ((1 << 4) + 6)\n+   They are (sequential integer + (desired value for TARGET_DEFAULT) << 4).  */\n+#define M68K_CPU_m68k\t(0 + ((MASK_68020|MASK_68881|MASK_BITFIELD)<<4))\n+#define M68K_CPU_m68000 (1 + (0 << 4))\n+#define M68K_CPU_m68010 (1 + (0 << 4)) /* make same as m68000 */\n+#define M68K_CPU_m68020 (2 + ((MASK_68020|MASK_68881|MASK_BITFIELD) << 4))\n+#define M68K_CPU_m68030 (3 + ((MASK_68030|MASK_68020|MASK_68881|MASK_BITFIELD) << 4))\n+#define M68K_CPU_m68040 (4 + ((MASK_68040_ONLY|MASK_68020|MASK_68881|MASK_BITFIELD) << 4))\n+#define M68K_CPU_m68302 (5 + (0 << 4))\n+#define M68K_CPU_m68332 (6 + (MASK_68020 << 4))\n \n /* This is tested for below, so if target wants to override this, it\n    just set this first in cover file.  */"}, {"sha": "8160f8c5952b2f904717205e6847dca40234e4d2", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 117, "deletions": 132, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0988b758459e0f4a90322fd127b90dfedc8cfafd/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0988b758459e0f4a90322fd127b90dfedc8cfafd/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=0988b758459e0f4a90322fd127b90dfedc8cfafd", "patch": "@@ -28,48 +28,66 @@ Boston, MA 02111-1307, USA.  */\n #define TARGET_CPU_CPP_BUILTINS()\t\t\\\n   do\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\\\n-\tbuiltin_define (\"__m68k__\");\t\t\\\n-\tbuiltin_define_std (\"mc68000\");\t\t\\\n-\tif (TARGET_68060)\t\t\t\\\n+      builtin_define (\"__m68k__\");\t\t\\\n+      builtin_define_std (\"mc68000\");\t\t\\\n+      if (TARGET_68040_ONLY)\t\t\t\\\n+\t{\t\t\t\t\t\\\n+\t  if (TARGET_68060)\t\t\t\\\n+\t    builtin_define_std (\"mc68060\");\t\\\n+\t  else\t\t\t\t\t\\\n+\t    builtin_define_std (\"mc68040\");\t\\\n+\t}\t\t\t\t\t\\\n+      else if (TARGET_68060) /* -m68020-60 */\t\\\n+\t{\t\t\t\t\t\\\n \t  builtin_define_std (\"mc68060\");\t\\\n-\telse if (TARGET_68040)\t\t\t\\\n \t  builtin_define_std (\"mc68040\");\t\\\n-\telse if (TARGET_68020)\t\t\t\\\n-\t    builtin_define_std (\"mc68020\");\t\\\n-\tif (TARGET_68881)\t\t\t\\\n-\t  builtin_define (\"__HAVE_68881__\");\t\\\n-\tif (TARGET_CPU32)\t\t\t\\\n-\t  {\t\t\t\t\t\\\n-\t    builtin_define_std (\"mc68332\");\t\\\n-\t    builtin_define_std (\"mcpu32\");\t\\\n-\t  }\t\t\t\t\t\\\n-\tif (TARGET_COLDFIRE)\t\t\t\\\n-\t  builtin_define (\"__mcoldfire__\");\t\\\n-\tif (TARGET_5200)\t\t\t\\\n+\t  builtin_define_std (\"mc68030\");\t\\\n+\t  builtin_define_std (\"mc68020\");\t\\\n+\t}\t\t\t\t\t\\\n+      else if (TARGET_68040) /* -m68020-40 */\t\\\n+\t{\t\t\t\t\t\\\n+\t  builtin_define_std (\"mc68040\");\t\\\n+\t  builtin_define_std (\"mc68030\");\t\\\n+ \t  builtin_define_std (\"mc68020\");\t\\\n+\t}\t\t\t\t\t\\\n+      else if (TARGET_68030)\t\t\t\\\n+\tbuiltin_define_std (\"mc68030\");\t\t\\\n+      else if (TARGET_68020)\t\t\t\\\n+\tbuiltin_define_std (\"mc68020\");\t\t\\\n+      if (TARGET_68881)\t\t\t\t\\\n+\tbuiltin_define (\"__HAVE_68881__\");\t\\\n+      if (TARGET_CPU32)\t\t\t\t\\\n+\t{\t\t\t\t\t\\\n+\t  builtin_define_std (\"mc68332\");\t\\\n+\t  builtin_define_std (\"mcpu32\");\t\\\n+\t}\t\t\t\t\t\\\n+      if (TARGET_COLDFIRE)\t\t\t\\\n+\tbuiltin_define (\"__mcoldfire__\");\t\\\n+      if (TARGET_5200)\t\t\t\t\\\n+\tbuiltin_define (\"__mcf5200__\");\t\t\\\n+      if (TARGET_528x)\t\t\t\t\\\n+\t{\t\t\t\t\t\\\n+\t  builtin_define (\"__mcf528x__\");\t\\\n \t  builtin_define (\"__mcf5200__\");\t\\\n-\tif (TARGET_528x)\t\t\t\\\n-\t  {\t\t\t\t\t\\\n-\t    builtin_define (\"__mcf528x__\");\t\\\n-\t    builtin_define (\"__mcf5200__\");\t\\\n-\t  }\t\t\t\t\t\\\n-\tif (TARGET_CFV3)\t\t\t\\\n-\t  {\t\t\t\t\t\\\n-\t    builtin_define (\"__mcf5300__\");\t\\\n-\t    builtin_define (\"__mcf5307__\");\t\\\n-\t  }\t\t\t\t\t\\\n-\tif (TARGET_CFV4)\t\t\t\\\n-\t  {\t\t\t\t\t\\\n-\t    builtin_define (\"__mcf5400__\");\t\\\n-\t    builtin_define (\"__mcf5407__\");\t\\\n-\t  }\t\t\t\t\t\\\n-\tif (TARGET_CF_HWDIV)\t\t\t\\\n-\t  builtin_define (\"__mcfhwdiv__\");\t\\\n-\tif (flag_pic)\t\t\t\t\\\n-\t  builtin_define (\"__pic__\");\t\t\\\n-\tif (flag_pic > 1)\t\t\t\\\n-\t  builtin_define (\"__PIC__\");\t\t\\\n-\tbuiltin_assert (\"cpu=m68k\");\t\t\\\n-\tbuiltin_assert (\"machine=m68k\");\t\\\n+\t}\t\t\t\t\t\\\n+      if (TARGET_CFV3)\t\t\t\t\\\n+\t{\t\t\t\t\t\\\n+\t  builtin_define (\"__mcf5300__\");\t\\\n+\t  builtin_define (\"__mcf5307__\");\t\\\n+\t}\t\t\t\t\t\\\n+      if (TARGET_CFV4)\t\t\t\t\\\n+\t{\t\t\t\t\t\\\n+\t  builtin_define (\"__mcf5400__\");\t\\\n+\t  builtin_define (\"__mcf5407__\");\t\\\n+\t}\t\t\t\t\t\\\n+      if (TARGET_CF_HWDIV)\t\t\t\\\n+\tbuiltin_define (\"__mcfhwdiv__\");\t\\\n+      if (flag_pic)\t\t\t\t\\\n+\tbuiltin_define (\"__pic__\");\t\t\\\n+      if (flag_pic > 1)\t\t\t\t\\\n+\tbuiltin_define (\"__PIC__\");\t\t\\\n+      builtin_assert (\"cpu=m68k\");\t\t\\\n+      builtin_assert (\"machine=m68k\");\t\t\\\n     }\t\t\t\t\t\t\\\n   while (0)\n \n@@ -98,45 +116,25 @@ extern int target_flags;\n /* Macros used in the machine description to test the flags.  */\n \n /* Compile for a 68020 (not a 68000 or 68010).  */\n-#define MASK_68020\t1\n+#define MASK_68020\t(1<<0)\n #define TARGET_68020 (target_flags & MASK_68020)\n \n-/* Compile 68881 insns for floating point (not library calls).  */\n-#define MASK_68881\t2\n-#define TARGET_68881 (target_flags & MASK_68881)\n-\n-/* Compile using 68020 bit-field insns.  */\n-#define MASK_BITFIELD\t4\n-#define TARGET_BITFIELD (target_flags & MASK_BITFIELD)\n-\n-/* Compile using rtd insn calling sequence.\n-   This will not work unless you use prototypes at least\n-   for all functions that can take varying numbers of args.  */\n-#define MASK_RTD\t8\n-#define TARGET_RTD (target_flags & MASK_RTD)\n-\n-/* Compile passing first two args in regs 0 and 1.\n-   This exists only to test compiler features that will\n-   be needed for RISC chips.  It is not usable\n-   and is not intended to be usable on this cpu.  */\n-#define MASK_REGPARM\t16\n-#define TARGET_REGPARM (target_flags & MASK_REGPARM)\n-\n-/* Compile with 16-bit `int'.  */\n-#define MASK_SHORT\t32\n-#define TARGET_SHORT (target_flags & MASK_SHORT)\n+/* Compile for a 68030.  This does not really make a difference in GCC,\n+   it just enables the __mc68030__ predefine.  */\n+#define MASK_68030\t(1<<1)\n+#define TARGET_68030 (target_flags & MASK_68030)\n \n /* Optimize for 68040, but still allow execution on 68020\n    (-m68020-40 or -m68040).\n    The 68040 will execute all 68030 and 68881/2 instructions, but some\n    of them must be emulated in software by the OS.  When TARGET_68040 is\n    turned on, these instructions won't be used.  This code will still\n    run on a 68030 and 68881/2.  */\n-#define MASK_68040\t256\n+#define MASK_68040\t(1<<2)\t\n #define TARGET_68040 (target_flags & MASK_68040)\n \n /* Use the 68040-only fp instructions (-m68040 or -m68060).  */\n-#define MASK_68040_ONLY\t512\n+#define MASK_68040_ONLY\t(1<<3)\n #define TARGET_68040_ONLY (target_flags & MASK_68040_ONLY)\n \n /* Optimize for 68060, but still allow execution on 68020\n@@ -145,24 +143,48 @@ extern int target_flags;\n    of them must be emulated in software by the OS.  When TARGET_68060 is\n    turned on, these instructions won't be used.  This code will still\n    run on a 68030 and 68881/2.  */\n-#define MASK_68060\t1024\n+#define MASK_68060\t(1<<4)\n #define TARGET_68060 (target_flags & MASK_68060)\n \n /* Compile for mcf5200 */\n-#define MASK_5200\t2048\n+#define MASK_5200\t(1<<5)\n #define TARGET_5200 (target_flags & MASK_5200)\n \n+/* Build for ColdFire v3 */\n+#define MASK_CFV3\t(1<<6)\n+#define TARGET_CFV3\t(target_flags & MASK_CFV3)\n+\n+/* Build for ColdFire v4 */\n+#define MASK_CFV4\t(1<<7)\n+#define TARGET_CFV4\t(target_flags & MASK_CFV4)\n+\n+/* Compile for ColdFire 528x */\n+#define MASK_528x\t(1<<8)\n+#define TARGET_528x\t(target_flags & MASK_528x)\n+\n+/* Divide support for ColdFire */\n+#define MASK_CF_HWDIV\t(1<<9)\n+#define TARGET_CF_HWDIV\t(target_flags & MASK_CF_HWDIV)\n+\n+/* Compile 68881 insns for floating point (not library calls).  */\n+#define MASK_68881\t(1<<10)\n+#define TARGET_68881\t(target_flags & MASK_68881)\n+\n+/* Compile using 68020 bit-field insns.  */\n+#define MASK_BITFIELD\t(1<<11)\n+#define TARGET_BITFIELD (target_flags & MASK_BITFIELD)\n+\n+/* Compile with 16-bit `int'.  */\n+#define MASK_SHORT\t(1<<12)\n+#define TARGET_SHORT\t(target_flags & MASK_SHORT)\n+\n /* Align ints to a word boundary.  This breaks compatibility with the \n    published ABI's for structures containing ints, but produces faster\n    code on cpus with 32 bit busses (020, 030, 040, 060, CPU32+, coldfire).\n    It's required for coldfire cpus without a misalignment module.  */\n-#define MASK_ALIGN_INT\t4096\n+#define MASK_ALIGN_INT\t(1<<13)\n #define TARGET_ALIGN_INT (target_flags & MASK_ALIGN_INT)\n \n-/* Compile for a CPU32 */\n-\t/* A 68020 without bitfields is a good heuristic for a CPU32 */\n-#define TARGET_CPU32\t(TARGET_68020 && !TARGET_BITFIELD)\n-\n /* Use PC-relative addressing modes (without using a global offset table).\n    The m68000 supports 16-bit PC-relative addressing.\n    The m68020 supports 32-bit PC-relative addressing\n@@ -172,31 +194,19 @@ extern int target_flags;\n    treated as all containing an implicit PC-relative component, and hence\n    cannot be used directly as addresses for memory writes.  See the comments\n    in m68k.c for more information.  */\n-#define MASK_PCREL\t8192\n+#define MASK_PCREL\t(1<<14)\n #define TARGET_PCREL\t(target_flags & MASK_PCREL)\n \n /* Relax strict alignment.  */\n-#define MASK_NO_STRICT_ALIGNMENT 16384\n+#define MASK_NO_STRICT_ALIGNMENT (1<<15)\n #define TARGET_STRICT_ALIGNMENT  (~target_flags & MASK_NO_STRICT_ALIGNMENT)\n \n-/* Build for ColdFire v3 */\n-#define MASK_CFV3\t0x8000\n-#define TARGET_CFV3\t(target_flags & MASK_CFV3)\n-\n-/* Build for ColdFire v4 */\n-#define MASK_CFV4\t0x10000\n-#define TARGET_CFV4\t(target_flags & MASK_CFV4)\n-\n-/* Divide support for ColdFire */\n-#define MASK_CF_HWDIV\t0x40000\n-#define TARGET_CF_HWDIV\t(target_flags & MASK_CF_HWDIV)\n-\n-/* Compile for mcf528x */\n-#define MASK_528x\t0x80000\n-#define TARGET_528x (target_flags & MASK_528x)\n \n+/* Compile for a CPU32.  A 68020 without bitfields is a good\n+   heuristic for a CPU32.  */\n+#define TARGET_CPU32\t(TARGET_68020 && !TARGET_BITFIELD)\n \n-/* Is the target a coldfire */\n+/* Is the target a ColdFire?  */\n #define MASK_COLDFIRE\t(MASK_5200|MASK_528x|MASK_CFV3|MASK_CFV4)\n #define TARGET_COLDFIRE\t(target_flags & MASK_COLDFIRE)\n \n@@ -226,27 +236,23 @@ extern int target_flags;\n       N_(\"Use the bit-field instructions\") },\t\t\t\t\\\n     { \"nobitfield\", - MASK_BITFIELD,\t\t\t\t\t\\\n       N_(\"Do not use the bit-field instructions\") },\t\t\t\\\n-    { \"rtd\", MASK_RTD,\t\t\t\t\t\t\t\\\n-      N_(\"Use different calling convention using 'rtd'\") },\t\t\\\n-    { \"nortd\", - MASK_RTD,\t\t\t\t\t\t\\\n-      N_(\"Use normal calling convention\") },\t\t\t\t\\\n     { \"short\", MASK_SHORT,\t\t\t\t\t\t\\\n       N_(\"Consider type `int' to be 16 bits wide\") },\t\t\t\\\n     { \"noshort\", - MASK_SHORT,\t\t\t\t\t\t\\\n       N_(\"Consider type `int' to be 32 bits wide\") },\t\t\t\\\n     { \"68881\", MASK_68881, \"\" },\t\t\t\t\t\\\n     { \"soft-float\", - (MASK_68040_ONLY|MASK_68881),\t\t\t\\\n       N_(\"Generate code with library calls for floating point\") },\t\\\n-    { \"68020-40\", -(MASK_ALL_CF_BITS|MASK_68060|MASK_68040_ONLY),\t\t\\\n+    { \"68020-40\", -(MASK_ALL_CF_BITS|MASK_68060|MASK_68040_ONLY),\t\\\n       N_(\"Generate code for a 68040, without any new instructions\") },\t\\\n     { \"68020-40\", (MASK_BITFIELD|MASK_68881|MASK_68020|MASK_68040), \"\"},\\\n-    { \"68020-60\", -(MASK_ALL_CF_BITS|MASK_68040_ONLY),\t\t\t\t\\\n+    { \"68020-60\", -(MASK_ALL_CF_BITS|MASK_68040_ONLY),\t\t\t\\\n       N_(\"Generate code for a 68060, without any new instructions\") },\t\\\n     { \"68020-60\", (MASK_BITFIELD|MASK_68881|MASK_68020|MASK_68040\t\\\n \t\t   |MASK_68060), \"\" },\t\t\t\t\t\\\n     { \"68030\", - (MASK_ALL_CF_BITS|MASK_68060|MASK_68040|MASK_68040_ONLY),\t\\\n       N_(\"Generate code for a 68030\") },\t\t\t\t\\\n-    { \"68030\", (MASK_68020|MASK_BITFIELD), \"\" },\t\t\t\\\n+    { \"68030\", (MASK_68020|MASK_68030|MASK_BITFIELD), \"\" },\t\t\\\n     { \"68040\", - (MASK_ALL_CF_BITS|MASK_68060),\t\t\t\t\\\n       N_(\"Generate code for a 68040\") },\t\t\t\t\\\n     { \"68040\", (MASK_68020|MASK_68881|MASK_BITFIELD\t\t\t\\\n@@ -261,20 +267,20 @@ extern int target_flags;\n     { \"5200\", (MASK_5200), \"\" },\t\t\t\t\t\\\n     { \"5206e\", - (MASK_ALL_CF_BITS|MASK_68060|MASK_68040|MASK_68040_ONLY|MASK_68020\t\\\n \t\t|MASK_BITFIELD|MASK_68881),\t\t\t\t\\\n-      N_(\"Generate code for a 5206e\") },\t\t\t\t\t\\\n-    { \"5206e\", (MASK_5200|MASK_CF_HWDIV), \"\" },\t\t\t\t\t\\\n+      N_(\"Generate code for a 5206e\") },\t\t\t\t\\\n+    { \"5206e\", (MASK_5200|MASK_CF_HWDIV), \"\" },\t\t\t\t\\\n     { \"528x\", - (MASK_ALL_CF_BITS|MASK_68060|MASK_68040|MASK_68040_ONLY|MASK_68020\t\\\n \t\t|MASK_BITFIELD|MASK_68881),\t\t\t\t\\\n       N_(\"Generate code for a 528x\") },\t\t\t\t\t\\\n-    { \"528x\", (MASK_528x|MASK_CF_HWDIV), \"\" },\t\t\t\t\t\\\n+    { \"528x\", (MASK_528x|MASK_CF_HWDIV), \"\" },\t\t\t\t\\\n     { \"5307\", - (MASK_ALL_CF_BITS|MASK_68060|MASK_68040|MASK_68040_ONLY|MASK_68020\t\\\n \t\t|MASK_BITFIELD|MASK_68881),\t\t\t\t\\\n       N_(\"Generate code for a 5307\") },\t\t\t\t\t\\\n-    { \"5307\", (MASK_CFV3|MASK_CF_HWDIV), \"\" },\t\t\t\t\t\\\n+    { \"5307\", (MASK_CFV3|MASK_CF_HWDIV), \"\" },\t\t\t\t\\\n     { \"5407\", - (MASK_ALL_CF_BITS|MASK_68060|MASK_68040|MASK_68040_ONLY|MASK_68020\t\\\n \t\t|MASK_BITFIELD|MASK_68881),\t\t\t\t\\\n       N_(\"Generate code for a 5407\") },\t\t\t\t\t\\\n-    { \"5407\", (MASK_CFV4|MASK_CF_HWDIV), \"\" },\t\t\t\t\t\\\n+    { \"5407\", (MASK_CFV4|MASK_CF_HWDIV), \"\" },\t\t\t\t\\\n     { \"68851\", 0,\t\t\t\t\t\t\t\\\n       N_(\"Generate code for a 68851\") },\t\t\t\t\\\n     { \"no-68851\", 0,\t\t\t\t\t\t\t\\\n@@ -302,7 +308,7 @@ extern int target_flags;\n       N_(\"Use unaligned memory references\") },\t\t\t\t\\\n     SUBTARGET_SWITCHES\t\t\t\t\t\t\t\\\n     { \"\", TARGET_DEFAULT, \"\" }}\n-/* TARGET_DEFAULT is defined in sun*.h and isi.h, etc.  */\n+/* TARGET_DEFAULT is defined in m68k-none.h, netbsd.h, etc.  */\n \n /* This macro is similar to `TARGET_SWITCHES' but defines names of\n    command options that have values.  Its definition is an\n@@ -784,21 +790,9 @@ enum reg_class {\n    or for a library call it is an identifier node for the subroutine name.\n    SIZE is the number of bytes of arguments passed on the stack.\n \n-   On the 68000, the RTS insn cannot pop anything.\n-   On the 68010, the RTD insn may be used to pop them if the number\n-     of args is fixed, but if the number is variable then the caller\n-     must pop them all.  RTD can't be used for library calls now\n-     because the library is compiled with the Unix compiler.\n-   Use of RTD is a selectable option, since it is incompatible with\n-   standard Unix calling sequences.  If the option is not selected,\n-   the caller must always pop the args.  */\n-\n-#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE)   \\\n-  ((TARGET_RTD && (!(FUNDECL) || TREE_CODE (FUNDECL) != IDENTIFIER_NODE)\t\\\n-    && (TYPE_ARG_TYPES (FUNTYPE) == 0\t\t\t\t\\\n-\t|| (TREE_VALUE (tree_last (TYPE_ARG_TYPES (FUNTYPE)))\t\\\n-\t    == void_type_node)))\t\t\t\t\\\n-   ? (SIZE) : 0)\n+   On the m68k, the caller must always pop the args. */\n+\n+#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) 0\n \n /* Define how to find the value returned by a function.\n    VALTYPE is the data type of the value (as a tree).\n@@ -877,26 +871,17 @@ enum reg_class {\n    CUM is a variable of type CUMULATIVE_ARGS which gives info about\n     the preceding args and about the function being called.\n    NAMED is nonzero if this argument is a named parameter\n-    (otherwise it is an extra parameter matching an ellipsis).  */\n+    (otherwise it is an extra parameter matching an ellipsis).\n \n-/* On the 68000 all args are pushed, except if -mregparm is specified\n-   then the first two words of arguments are passed in d0, d1.\n-   *NOTE* -mregparm does not work.\n-   It exists only to test register calling conventions.  */\n+   On the m68k all args are always pushed.  */\n \n-#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n-((TARGET_REGPARM && (CUM) < 8) ? gen_rtx_REG ((MODE), (CUM) / 4) : 0)\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) 0\n \n /* For an arg passed partly in registers and partly in memory,\n    this is the number of registers used.\n    For args passed entirely in registers or entirely in memory, zero.  */\n \n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n-((TARGET_REGPARM && (CUM) < 8\t\t\t\t\t\\\n-  && 8 < ((CUM) + ((MODE) == BLKmode\t\t\t\t\\\n-\t\t      ? int_size_in_bytes (TYPE)\t\t\\\n-\t\t      : GET_MODE_SIZE (MODE))))  \t\t\\\n- ? 2 - (CUM) / 4 : 0)\n+#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) 0\n \n /* Output assembler code to FILE to increment profiler label # LABELNO\n    for profiling a function entry.  */"}]}