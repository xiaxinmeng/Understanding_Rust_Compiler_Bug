{"sha": "c6c7698dfd268ad41c9ca00a8c49333d09c51e20", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzZjNzY5OGRmZDI2OGFkNDFjOWNhMDBhOGM0OTMzM2QwOWM1MWUyMA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2006-08-21T20:54:57Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2006-08-21T20:54:57Z"}, "message": "re PR c++/27115 (ICE in cp_expr_size or miscompilation with statement expressions and constructors (and ?: ))\n\n        PR c++/27115\n        * gimplify.c (voidify_wrapper_expr): Handle STATEMENT_LIST as a\n        wrapper.  Loop to handle nested wrappers.\n        (gimplify_bind_expr): Remove temp parameter.\n        (gimplify_modify_expr_rhs): Handle CLEANUP_POINT_EXPR, BIND_EXPR\n        and STATEMENT_LIST on the rhs.\n        (gimplify_statement_list): Voidify the STATEMENT_LIST.\n        (gimplify_expr): Pass pre_p to gimplify_statement_list.\n        (gimplify_target_expr): Remove special BIND_EXPR handling.\n        * cp/semantics.c (finish_stmt_expr_expr): Don't try to voidify here,\n        just leave the expression as it is.\n        (finish_stmt_expr): If the statement-expression has class type,\n        wrap it in a TARGET_EXPR.\n        * cp/cp-gimplify.c (cp_gimplify_init_expr): Don't bother with\n        CLEANUP_POINT_EXPR.\n        * cp/except.c (build_throw): Give the CLEANUP_POINT_EXPR void type.\n\nFrom-SVN: r116311", "tree": {"sha": "38fad6e6bb826a12c58767da330650091c1f7cd9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/38fad6e6bb826a12c58767da330650091c1f7cd9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c6c7698dfd268ad41c9ca00a8c49333d09c51e20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6c7698dfd268ad41c9ca00a8c49333d09c51e20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6c7698dfd268ad41c9ca00a8c49333d09c51e20", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6c7698dfd268ad41c9ca00a8c49333d09c51e20/comments", "author": null, "committer": null, "parents": [{"sha": "63b263936ed5ce953ec313d858cb20a1dcb7ebfa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63b263936ed5ce953ec313d858cb20a1dcb7ebfa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63b263936ed5ce953ec313d858cb20a1dcb7ebfa"}], "stats": {"total": 425, "additions": 277, "deletions": 148}, "files": [{"sha": "685b4b6daf9aebd3f697667baf40292aa71b3c06", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c7698dfd268ad41c9ca00a8c49333d09c51e20/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c7698dfd268ad41c9ca00a8c49333d09c51e20/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c6c7698dfd268ad41c9ca00a8c49333d09c51e20", "patch": "@@ -1,3 +1,15 @@\n+2006-08-21  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/27115\n+\t* gimplify.c (voidify_wrapper_expr): Handle STATEMENT_LIST as a\n+\twrapper.  Loop to handle nested wrappers.\n+\t(gimplify_bind_expr): Remove temp parameter.\n+\t(gimplify_modify_expr_rhs): Handle CLEANUP_POINT_EXPR, BIND_EXPR\n+\tand STATEMENT_LIST on the rhs.\n+\t(gimplify_statement_list): Voidify the STATEMENT_LIST.\n+\t(gimplify_expr): Pass pre_p to gimplify_statement_list.\n+\t(gimplify_target_expr): Remove special BIND_EXPR handling.\n+\n 2006-08-21  J\"orn Rennecke  <joern.rennecke@st.com>\n \n \t* config/sh/lib1funcs-Os-4-200.asm: Guard entire file with"}, {"sha": "fa7d6bc0e65b6aa6cf5e9aee4e924687ef990423", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 29, "deletions": 18, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c7698dfd268ad41c9ca00a8c49333d09c51e20/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c7698dfd268ad41c9ca00a8c49333d09c51e20/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c6c7698dfd268ad41c9ca00a8c49333d09c51e20", "patch": "@@ -1,16 +1,27 @@\n+2006-08-21  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/27115\n+\t* semantics.c (finish_stmt_expr_expr): Don't try to voidify here,\n+\tjust leave the expression as it is.\n+\t(finish_stmt_expr): If the statement-expression has class type,\n+\twrap it in a TARGET_EXPR.\n+\t* cp-gimplify.c (cp_gimplify_init_expr): Don't bother with\n+\tCLEANUP_POINT_EXPR.\n+\t* except.c (build_throw): Give the CLEANUP_POINT_EXPR void type.\n+\n 2006-08-21  Lee Millward  <lee.millward@codesourcery.com>\n \n \tPR c++/26269\n-        * decl.c (duplicate_decls): Return early if either\n-        newdecl or olddecl is error_mark_node.\n+\t* decl.c (duplicate_decls): Return early if either\n+\tnewdecl or olddecl is error_mark_node.\n \n \t PR c++/28505\n-        * decl.c (grokdeclarator): Return early after\n-        issuing diagnostic about an incomplete type.\n+\t* decl.c (grokdeclarator): Return early after\n+\tissuing diagnostic about an incomplete type.\n \n \tPR c++/28741\n-        * tree.c (decl_anon_ns_mem_p): Robustify.\n-        * decl2.c (determine_visibility): Likewise.\n+\t* tree.c (decl_anon_ns_mem_p): Robustify.\n+\t* decl2.c (determine_visibility): Likewise.\n \t\n 2006-08-20  Mark Mitchell  <mark@codesourcery.com>\n \n@@ -189,18 +200,18 @@\n \n 2006-07-28  Lee Millward  <lee.millward@codesourcery.com>\n \n-        PR c++/27668\n-        PR c++/27962\n-        * pt.c (process_template_parm) Store invalid template\n-        parameters as error_mark_node in the paramater list.\n-        (push_inline_template_parms_recursive): Handle invalid\n-        template parameters.\n-        (comp_template_parms): Likewise.\n-        (check_default_tmpl_arg): Likewise.\n-        (coerce_template_template_parms): Likewise.\n-        (mangle_class_name_for_template): Likewise.\n-        (tsubst_template_parms): Likewise.\n-        * error.c (dump_template_argument_list): Likewise.\n+\tPR c++/27668\n+\tPR c++/27962\n+\t* pt.c (process_template_parm) Store invalid template\n+\tparameters as error_mark_node in the paramater list.\n+\t(push_inline_template_parms_recursive): Handle invalid\n+\ttemplate parameters.\n+\t(comp_template_parms): Likewise.\n+\t(check_default_tmpl_arg): Likewise.\n+\t(coerce_template_template_parms): Likewise.\n+\t(mangle_class_name_for_template): Likewise.\n+\t(tsubst_template_parms): Likewise.\n+\t* error.c (dump_template_argument_list): Likewise.\n \t\n 2006-07-28  Kazu Hirata  <kazu@codesourcery.com>\n "}, {"sha": "bdb2edf2f41687863194706d9da73b88ecfbcdad", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c7698dfd268ad41c9ca00a8c49333d09c51e20/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c7698dfd268ad41c9ca00a8c49333d09c51e20/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=c6c7698dfd268ad41c9ca00a8c49333d09c51e20", "patch": "@@ -391,18 +391,15 @@ cp_gimplify_init_expr (tree *expr_p, tree *pre_p, tree *post_p)\n   tree to = TREE_OPERAND (*expr_p, 0);\n   tree sub;\n \n-  /* If we are initializing something from a TARGET_EXPR, strip the\n-     TARGET_EXPR and initialize it directly.  */\n   /* What about code that pulls out the temp and uses it elsewhere?  I\n      think that such code never uses the TARGET_EXPR as an initializer.  If\n      I'm wrong, we'll abort because the temp won't have any RTL.  In that\n      case, I guess we'll need to replace references somehow.  */\n   if (TREE_CODE (from) == TARGET_EXPR)\n     from = TARGET_EXPR_INITIAL (from);\n-  if (TREE_CODE (from) == CLEANUP_POINT_EXPR)\n-    from = TREE_OPERAND (from, 0);\n \n-  /* Look through any COMPOUND_EXPRs.  */\n+  /* Look through any COMPOUND_EXPRs, since build_compound_expr pushes them\n+     inside the TARGET_EXPR.  */\n   sub = expr_last (from);\n \n   /* If we are initializing from an AGGR_INIT_EXPR, drop the INIT_EXPR and"}, {"sha": "71b433f1560357d096d57cdc5642fcd68ddfecc6", "filename": "gcc/cp/except.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c7698dfd268ad41c9ca00a8c49333d09c51e20/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c7698dfd268ad41c9ca00a8c49333d09c51e20/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=c6c7698dfd268ad41c9ca00a8c49333d09c51e20", "patch": "@@ -744,7 +744,7 @@ build_throw (tree exp)\n       /* Wrap the initialization in a CLEANUP_POINT_EXPR so that cleanups\n \t for temporaries within the initialization are run before the one\n \t for the exception object, preserving LIFO order.  */\n-      exp = build1 (CLEANUP_POINT_EXPR, TREE_TYPE (exp), exp);\n+      exp = build1 (CLEANUP_POINT_EXPR, void_type_node, exp);\n \n       if (elided)\n \texp = build2 (TRY_CATCH_EXPR, void_type_node, exp,"}, {"sha": "56dbe6fddad601d11fc9b60cd49e2d89567cb08e", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 37, "deletions": 59, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c7698dfd268ad41c9ca00a8c49333d09c51e20/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c7698dfd268ad41c9ca00a8c49333d09c51e20/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=c6c7698dfd268ad41c9ca00a8c49333d09c51e20", "patch": "@@ -1612,70 +1612,46 @@ finish_stmt_expr_expr (tree expr, tree stmt_expr)\n      of the last statement is the value of the entire expression.  */\n   if (expr)\n     {\n-      tree type;\n-      type = TREE_TYPE (expr);\n-      if (!dependent_type_p (type) && !VOID_TYPE_P (type))\n+      tree type = TREE_TYPE (expr);\n+\n+      if (processing_template_decl)\n+\t{\n+\t  expr = build_stmt (EXPR_STMT, expr);\n+\t  expr = add_stmt (expr);\n+\t  /* Mark the last statement so that we can recognize it as such at\n+\t     template-instantiation time.  */\n+\t  EXPR_STMT_STMT_EXPR_RESULT (expr) = 1;\n+\t}\n+      else if (VOID_TYPE_P (type))\n \t{\n-\t  expr = decay_conversion (expr);\n+\t  /* Just treat this like an ordinary statement.  */\n+\t  expr = finish_expr_stmt (expr);\n+\t}\n+      else\n+\t{\n+\t  /* It actually has a value we need to deal with.  First, force it\n+\t     to be an rvalue so that we won't need to build up a copy\n+\t     constructor call later when we try to assign it to something.  */\n+\t  expr = force_rvalue (expr);\n \t  if (error_operand_p (expr))\n \t    return error_mark_node;\n+\n+\t  /* Update for array-to-pointer decay.  */\n \t  type = TREE_TYPE (expr);\n+\n+\t  /* Wrap it in a CLEANUP_POINT_EXPR and add it to the list like a\n+\t     normal statement, but don't convert to void or actually add\n+\t     the EXPR_STMT.  */\n+\t  if (TREE_CODE (expr) != CLEANUP_POINT_EXPR)\n+\t    expr = maybe_cleanup_point_expr (expr);\n+\t  add_stmt (expr);\n \t}\n+\n       /* The type of the statement-expression is the type of the last\n \t expression.  */\n       TREE_TYPE (stmt_expr) = type;\n-      /* We must take particular care if TYPE is a class type.  In\n-\t particular if EXPR creates a temporary of class type, then it\n-\t must be destroyed at the semicolon terminating the last\n-\t statement -- but we must make a copy before that happens.\n-\n-\t This problem is solved by using a TARGET_EXPR to initialize a\n-\t new temporary variable.  The TARGET_EXPR itself is placed\n-\t outside the statement-expression.  However, the last\n-\t statement in the statement-expression is transformed from\n-\t EXPR to (approximately) T = EXPR, where T is the new\n-\t temporary variable.  Thus, the lifetime of the new temporary\n-\t extends to the full-expression surrounding the\n-\t statement-expression.  */\n-      if (!processing_template_decl && !VOID_TYPE_P (type))\n-\t{\n-\t  tree target_expr;\n-\t  if (CLASS_TYPE_P (type)\n-\t      && !TYPE_HAS_TRIVIAL_INIT_REF (type))\n-\t    {\n-\t      target_expr = build_target_expr_with_type (expr, type);\n-\t      expr = TARGET_EXPR_INITIAL (target_expr);\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Normally, build_target_expr will not create a\n-\t\t TARGET_EXPR for scalars.  However, we need the\n-\t\t temporary here, in order to solve the scoping\n-\t\t problem described above.  */\n-\t      target_expr = force_target_expr (type, expr);\n-\t      expr = TARGET_EXPR_INITIAL (target_expr);\n-\t      expr = build2 (INIT_EXPR,\n-\t\t\t     type,\n-\t\t\t     TARGET_EXPR_SLOT (target_expr),\n-\t\t\t     expr);\n-\t    }\n-\t  TARGET_EXPR_INITIAL (target_expr) = NULL_TREE;\n-\t  /* Save away the TARGET_EXPR in the TREE_TYPE field of the\n-\t     STATEMENT_EXPR.  We will retrieve it in\n-\t     finish_stmt_expr.  */\n-\t  TREE_TYPE (stmt_expr) = target_expr;\n-\t}\n     }\n \n-  /* Having modified EXPR to reflect the extra initialization, we now\n-     treat it just like an ordinary statement.  */\n-  expr = finish_expr_stmt (expr);\n-\n-  /* Mark the last statement so that we can recognize it as such at\n-     template-instantiation time.  */\n-  if (expr && processing_template_decl)\n-    EXPR_STMT_STMT_EXPR_RESULT (expr) = 1;\n-\n   return stmt_expr;\n }\n \n@@ -1696,19 +1672,21 @@ finish_stmt_expr (tree stmt_expr, bool has_no_scope)\n \n   type = TREE_TYPE (stmt_expr);\n   result = pop_stmt_list (stmt_expr);\n+  TREE_TYPE (result) = type;\n \n   if (processing_template_decl)\n     {\n       result = build_min (STMT_EXPR, type, result);\n       TREE_SIDE_EFFECTS (result) = 1;\n       STMT_EXPR_NO_SCOPE (result) = has_no_scope;\n     }\n-  else if (!TYPE_P (type))\n+  else if (CLASS_TYPE_P (type))\n     {\n-      gcc_assert (TREE_CODE (type) == TARGET_EXPR);\n-      TARGET_EXPR_INITIAL (type) = result;\n-      TREE_TYPE (result) = void_type_node;\n-      result = type;\n+      /* Wrap the statement-expression in a TARGET_EXPR so that the\n+\t temporary object created by the final expression is destroyed at\n+\t the end of the full-expression containing the\n+\t statement-expression.  */\n+      result = force_target_expr (type, result);\n     }\n \n   return result;"}, {"sha": "fd9e1e561572da7146f68837a1845cecd5b321cc", "filename": "gcc/gimplify.c", "status": "modified", "additions": 81, "deletions": 65, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c7698dfd268ad41c9ca00a8c49333d09c51e20/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c7698dfd268ad41c9ca00a8c49333d09c51e20/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=c6c7698dfd268ad41c9ca00a8c49333d09c51e20", "patch": "@@ -957,71 +957,71 @@ voidify_wrapper_expr (tree wrapper, tree temp)\n {\n   if (!VOID_TYPE_P (TREE_TYPE (wrapper)))\n     {\n-      tree *p, sub = wrapper;\n+      tree type = TREE_TYPE (wrapper);\n+      tree *p;\n \n-    restart:\n-      /* Set p to point to the body of the wrapper.  */\n-      switch (TREE_CODE (sub))\n-\t{\n-\tcase BIND_EXPR:\n-\t  /* For a BIND_EXPR, the body is operand 1.  */\n-\t  p = &BIND_EXPR_BODY (sub);\n-\t  break;\n-\n-\tdefault:\n-\t  p = &TREE_OPERAND (sub, 0);\n-\t  break;\n-\t}\n-\n-      /* Advance to the last statement.  Set all container types to void.  */\n-      if (TREE_CODE (*p) == STATEMENT_LIST)\n-\t{\n-\t  tree_stmt_iterator i = tsi_last (*p);\n-\t  p = tsi_end_p (i) ? NULL : tsi_stmt_ptr (i);\n-\t}\n-      else\n+      /* Set p to point to the body of the wrapper.  Loop until we find\n+\t something that isn't a wrapper.  */\n+      for (p = &wrapper; p && *p; )\n \t{\n-\t  for (; TREE_CODE (*p) == COMPOUND_EXPR; p = &TREE_OPERAND (*p, 1))\n+\t  switch (TREE_CODE (*p))\n \t    {\n+\t    case BIND_EXPR:\n \t      TREE_SIDE_EFFECTS (*p) = 1;\n \t      TREE_TYPE (*p) = void_type_node;\n+\t      /* For a BIND_EXPR, the body is operand 1.  */\n+\t      p = &BIND_EXPR_BODY (*p);\n+\t      break;\n+\n+\t    case CLEANUP_POINT_EXPR:\n+\t    case TRY_FINALLY_EXPR:\n+\t    case TRY_CATCH_EXPR:\n+\t      TREE_SIDE_EFFECTS (*p) = 1;\n+\t      TREE_TYPE (*p) = void_type_node;\n+\t      p = &TREE_OPERAND (*p, 0);\n+\t      break;\n+\n+\t    case STATEMENT_LIST:\n+\t      {\n+\t\ttree_stmt_iterator i = tsi_last (*p);\n+\t\tTREE_SIDE_EFFECTS (*p) = 1;\n+\t\tTREE_TYPE (*p) = void_type_node;\n+\t\tp = tsi_end_p (i) ? NULL : tsi_stmt_ptr (i);\n+\t      }\n+\t      break;\n+\n+\t    case COMPOUND_EXPR:\n+\t      /* Advance to the last statement.  Set all container types to void.  */\n+\t      for (; TREE_CODE (*p) == COMPOUND_EXPR; p = &TREE_OPERAND (*p, 1))\n+\t\t{\n+\t\t  TREE_SIDE_EFFECTS (*p) = 1;\n+\t\t  TREE_TYPE (*p) = void_type_node;\n+\t\t}\n+\t      break;\n+\n+\t    default:\n+\t      goto out;\n \t    }\n \t}\n \n+    out:\n       if (p == NULL || IS_EMPTY_STMT (*p))\n-\t;\n-      /* Look through exception handling.  */\n-      else if (TREE_CODE (*p) == TRY_FINALLY_EXPR\n-\t       || TREE_CODE (*p) == TRY_CATCH_EXPR)\n+\ttemp = NULL_TREE;\n+      else if (temp)\n \t{\n-\t  sub = *p;\n-\t  goto restart;\n-\t}\n-      /* The C++ frontend already did this for us.  */\n-      else if (TREE_CODE (*p) == INIT_EXPR\n-\t       || TREE_CODE (*p) == TARGET_EXPR)\n-\ttemp = TREE_OPERAND (*p, 0);\n-      /* If we're returning a dereference, move the dereference\n-\t outside the wrapper.  */\n-      else if (TREE_CODE (*p) == INDIRECT_REF)\n-\t{\n-\t  tree ptr = TREE_OPERAND (*p, 0);\n-\t  temp = create_tmp_var (TREE_TYPE (ptr), \"retval\");\n-\t  *p = build2 (MODIFY_EXPR, TREE_TYPE (ptr), temp, ptr);\n-\t  temp = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (temp)), temp);\n-\t  /* If this is a BIND_EXPR for a const inline function, it might not\n-\t     have TREE_SIDE_EFFECTS set.  That is no longer accurate.  */\n-\t  TREE_SIDE_EFFECTS (wrapper) = 1;\n+\t  /* The wrapper is on the RHS of an assignment that we're pushing\n+\t     down.  */\n+\t  gcc_assert (TREE_CODE (temp) == INIT_EXPR\n+\t\t      || TREE_CODE (temp) == MODIFY_EXPR);\n+\t  TREE_OPERAND (temp, 1) = *p;\n+\t  *p = temp;\n \t}\n       else\n \t{\n-\t  if (!temp)\n-\t    temp = create_tmp_var (TREE_TYPE (wrapper), \"retval\");\n-\t  *p = build2 (MODIFY_EXPR, TREE_TYPE (temp), temp, *p);\n-\t  TREE_SIDE_EFFECTS (wrapper) = 1;\n+\t  temp = create_tmp_var (type, \"retval\");\n+\t  *p = build2 (INIT_EXPR, type, temp, *p);\n \t}\n \n-      TREE_TYPE (wrapper) = void_type_node;\n       return temp;\n     }\n \n@@ -1050,13 +1050,13 @@ build_stack_save_restore (tree *save, tree *restore)\n /* Gimplify a BIND_EXPR.  Just voidify and recurse.  */\n \n static enum gimplify_status\n-gimplify_bind_expr (tree *expr_p, tree temp, tree *pre_p)\n+gimplify_bind_expr (tree *expr_p, tree *pre_p)\n {\n   tree bind_expr = *expr_p;\n   bool old_save_stack = gimplify_ctxp->save_stack;\n   tree t;\n \n-  temp = voidify_wrapper_expr (bind_expr, temp);\n+  tree temp = voidify_wrapper_expr (bind_expr, NULL);\n \n   /* Mark variables seen in this bind expr.  */\n   for (t = BIND_EXPR_VARS (bind_expr); t ; t = TREE_CHAIN (t))\n@@ -3408,6 +3408,20 @@ gimplify_modify_expr_rhs (tree *expr_p, tree *from_p, tree *to_p, tree *pre_p,\n \tret = GS_UNHANDLED;\n \tbreak;\n \n+\t/* If we're initializing from a container, push the initialization\n+\t   inside it.  */\n+      case CLEANUP_POINT_EXPR:\n+      case BIND_EXPR:\n+      case STATEMENT_LIST:\n+\t{\n+\t  tree wrap = *from_p;\n+\t  tree t = voidify_wrapper_expr (wrap, *expr_p);\n+\t  gcc_assert (t == *expr_p);\n+\n+\t  *expr_p = wrap;\n+\t  return GS_OK;\n+\t}\n+\t\n       default:\n \tret = GS_UNHANDLED;\n \tbreak;\n@@ -3681,8 +3695,10 @@ gimplify_compound_expr (tree *expr_p, tree *pre_p, bool want_value)\n    enlightened front-end, or by shortcut_cond_expr.  */\n \n static enum gimplify_status\n-gimplify_statement_list (tree *expr_p)\n+gimplify_statement_list (tree *expr_p, tree *pre_p)\n {\n+  tree temp = voidify_wrapper_expr (*expr_p, NULL);\n+\n   tree_stmt_iterator i = tsi_start (*expr_p);\n \n   while (!tsi_end_p (i))\n@@ -3703,6 +3719,13 @@ gimplify_statement_list (tree *expr_p)\n \ttsi_next (&i);\n     }\n \n+  if (temp)\n+    {\n+      append_to_statement_list (*expr_p, pre_p);\n+      *expr_p = temp;\n+      return GS_OK;\n+    }\n+\n   return GS_ALL_DONE;\n }\n \n@@ -4184,16 +4207,9 @@ gimplify_target_expr (tree *expr_p, tree *pre_p, tree *post_p)\n \tret = gimplify_expr (&init, pre_p, post_p, is_gimple_stmt, fb_none);\n       else\n \t{\n-          /* Special handling for BIND_EXPR can result in fewer temps.  */\n-\t  ret = GS_OK;\n-          if (TREE_CODE (init) == BIND_EXPR)\n-\t    gimplify_bind_expr (&init, temp, pre_p);\n-\t  if (init != temp)\n-\t    {\n-\t      init = build2 (INIT_EXPR, void_type_node, temp, init);\n-\t      ret = gimplify_expr (&init, pre_p, post_p, is_gimple_stmt,\n-\t\t\t\t   fb_none);\n-\t    }\n+\t  init = build2 (INIT_EXPR, void_type_node, temp, init);\n+\t  ret = gimplify_expr (&init, pre_p, post_p, is_gimple_stmt,\n+\t\t\t       fb_none);\n \t}\n       if (ret == GS_ERROR)\n \treturn GS_ERROR;\n@@ -5507,7 +5523,7 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \t  break;\n \n \tcase BIND_EXPR:\n-\t  ret = gimplify_bind_expr (expr_p, NULL, pre_p);\n+\t  ret = gimplify_bind_expr (expr_p, pre_p);\n \t  break;\n \n \tcase LOOP_EXPR:\n@@ -5654,7 +5670,7 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \t  break;\n \n \tcase STATEMENT_LIST:\n-\t  ret = gimplify_statement_list (expr_p);\n+\t  ret = gimplify_statement_list (expr_p, pre_p);\n \t  break;\n \n \tcase WITH_SIZE_EXPR:"}, {"sha": "0d31ee435471d436c52fad23498408bacf604556", "filename": "gcc/testsuite/g++.dg/abi/forced-sticky.C", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c7698dfd268ad41c9ca00a8c49333d09c51e20/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fforced-sticky.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c7698dfd268ad41c9ca00a8c49333d09c51e20/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fforced-sticky.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fforced-sticky.C?ref=c6c7698dfd268ad41c9ca00a8c49333d09c51e20", "patch": "@@ -0,0 +1,62 @@\n+// Test for \"sticky cancel\": if a catch (...) block discards the\n+// cancellation exception, a new one is raised at the next cancellation\n+// point.\n+\n+// This test only applies to glibc targets.\n+// { dg-do run { target *-*-linux* } }\n+// { dg-options \"-pthread\" }\n+\n+#include <pthread.h>\n+#include <cxxabi.h>\n+extern \"C\" int printf (const char *, ...);\n+\n+void* thread_main(void*)\n+{\n+  try\n+    {\n+      // Spin until we get cancelled.\n+      while (1)\n+\tpthread_testcancel();\n+    }\n+  catch (...)\n+    {\n+      // Catch and discard the forced unwind.\n+      printf (\"caught ...\\n\");\n+    }\n+\n+  try\n+    {\n+      // Start unwinding again.\n+      pthread_testcancel();\n+    }\n+  catch (...)\n+    {\n+      // Catch and discard again.  This time the thread exits before the\n+      // next cancellation point, so we're done.\n+      printf (\"caught ... again\\n\");\n+      return 0;\n+    }\n+\n+  return (void*)4;\n+}\n+\n+int main()\n+{\n+  pthread_t thread;\n+  int r;\n+  void *p;\n+\n+  r = pthread_create (&thread, NULL, thread_main, NULL);\n+  if (r)\n+    return 1;\n+\n+  r = pthread_cancel (thread);\n+  if (r)\n+    return 2;\n+\n+  r = pthread_join (thread, &p);\n+  if (r)\n+    return 3;\n+\n+  return (int)p;\n+}"}, {"sha": "7a9c35964f7ce9a74245f1ce1f4f0125055b4a79", "filename": "gcc/testsuite/g++.dg/abi/forced.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c7698dfd268ad41c9ca00a8c49333d09c51e20/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fforced.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c7698dfd268ad41c9ca00a8c49333d09c51e20/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fforced.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fforced.C?ref=c6c7698dfd268ad41c9ca00a8c49333d09c51e20", "patch": "@@ -0,0 +1,25 @@\n+// This test only applies to glibc (NPTL) targets.\n+// { dg-do run { target *-*-linux* } }\n+// { dg-options \"-pthread\" }\n+\n+#include <pthread.h>\n+#include <cxxabi.h>\n+extern \"C\" int printf (const char *, ...);\n+\n+int main()\n+{\n+  try\n+    {\n+      pthread_exit (0);\n+    }\n+  catch (abi::__forced_unwind &)\n+    {\n+      printf (\"caught forced unwind\\n\");\n+      throw;\n+    }\n+  catch (...)\n+    {\n+      printf (\"caught ...\\n\");\n+      return 1;\n+    }\n+}"}, {"sha": "8e5d0ddcba25983516f0f54fd128ed49c2fa5fa7", "filename": "gcc/testsuite/g++.dg/ext/stmtexpr8.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c7698dfd268ad41c9ca00a8c49333d09c51e20/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fstmtexpr8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c7698dfd268ad41c9ca00a8c49333d09c51e20/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fstmtexpr8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fstmtexpr8.C?ref=c6c7698dfd268ad41c9ca00a8c49333d09c51e20", "patch": "@@ -0,0 +1,28 @@\n+// PR c++/27115\n+\n+// { dg-do run }\n+// { dg-options \"\" }\n+\n+struct A\n+{\n+  int i;\n+  A (int j) : i(j) {}\n+  A (const A &j) : i(j.i) {}\n+  A& operator= (const A &j) { i = j.i; return *this; }\n+};\n+\n+A foo(int j)\n+{\n+  return ({ j ? A(1) : A(0); });\n+}\n+\n+int main()\n+{\n+  return foo(1).i-1;\n+}\n+\n+void foo2()\n+{\n+  A b = ({ A a(1); a; });\n+}\n+"}]}