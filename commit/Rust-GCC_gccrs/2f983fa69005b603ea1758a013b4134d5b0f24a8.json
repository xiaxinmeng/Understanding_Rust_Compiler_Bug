{"sha": "2f983fa69005b603ea1758a013b4134d5b0f24a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmY5ODNmYTY5MDA1YjYwM2VhMTc1OGEwMTNiNDEzNGQ1YjBmMjRhOA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-09-02T14:17:24Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-09-02T14:32:11Z"}, "message": "libstdc++: Fix three-way comparison for std::array [PR 96851]\n\nThe spaceship operator for std::array uses memcmp when the\n__is_byte<value_type> trait is true, but memcmp isn't usable in\nconstexpr contexts. Also, memcmp should only be used for unsigned byte\ntypes, because it gives the wrong answer for signed chars with negative\nvalues.\n\nWe can simply check std::is_constant_evaluated() so that we don't use\nmemcmp during constant evaluation.\n\nTo fix the problem of using memcmp for inappropriate types, this patch\nadds new __is_memcmp_ordered and __is_memcmp_ordered_with traits. These\nsay whether using memcmp will give the right answer for ordering\noperations such as lexicographical_compare and three-way comparisons.\nThe new traits can be used in several places, and can also be used to\nimplement my suggestion in PR 93059 comment 37 to use memcmp for\nunsigned integers larger than one byte on big endian targets.\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/96851\n\t* include/bits/cpp_type_traits.h (__is_memcmp_ordered):\n\tNew trait that says if memcmp can be used for ordering.\n\t(__is_memcmp_ordered_with): Likewise, for two types.\n\t* include/bits/deque.tcc (__lex_cmp_dit): Use new traits\n\tinstead of __is_byte and __numeric_traits.\n\t(__lexicographical_compare_aux1): Likewise.\n\t* include/bits/ranges_algo.h (__lexicographical_compare_fn):\n\tLikewise.\n\t* include/bits/stl_algobase.h (__lexicographical_compare_aux1)\n\t(__is_byte_iter): Likewise.\n\t* include/std/array (operator<=>): Likewise. Only use memcmp\n\twhen std::is_constant_evaluated() is false.\n\t* testsuite/23_containers/array/comparison_operators/96851.cc:\n\tNew test.\n\t* testsuite/23_containers/array/tuple_interface/get_neg.cc:\n\tAdjust dg-error line numbers.", "tree": {"sha": "ba2f3d849521981cf9ba1b48fa806c32a9cef5f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba2f3d849521981cf9ba1b48fa806c32a9cef5f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f983fa69005b603ea1758a013b4134d5b0f24a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f983fa69005b603ea1758a013b4134d5b0f24a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f983fa69005b603ea1758a013b4134d5b0f24a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f983fa69005b603ea1758a013b4134d5b0f24a8/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d45a6c7099a346153e970476688be5bd6a016cef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d45a6c7099a346153e970476688be5bd6a016cef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d45a6c7099a346153e970476688be5bd6a016cef"}], "stats": {"total": 227, "additions": 200, "deletions": 27}, "files": [{"sha": "b48d1adc63c9532e6ceb1a149869445f69aa0f39", "filename": "libstdc++-v3/include/bits/cpp_type_traits.h", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f983fa69005b603ea1758a013b4134d5b0f24a8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcpp_type_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f983fa69005b603ea1758a013b4134d5b0f24a8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcpp_type_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcpp_type_traits.h?ref=2f983fa69005b603ea1758a013b4134d5b0f24a8", "patch": "@@ -482,6 +482,66 @@ __INT_N(__GLIBCXX_TYPE_INT_N_3)\n     : __is_nonvolatile_trivially_copyable<_Tp>\n     { };\n \n+  // Whether memcmp can be used to determine ordering for a type\n+  // e.g. in std::lexicographical_compare or three-way comparisons.\n+  // True for unsigned integer-like types where comparing each byte in turn\n+  // as an unsigned char yields the right result. This is true for all\n+  // unsigned integers on big endian targets, but only unsigned narrow\n+  // character types (and std::byte) on little endian targets.\n+  template<typename _Tp, bool _TreatAsBytes =\n+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n+\t__is_integer<_Tp>::__value\n+#else\n+\t__is_byte<_Tp>::__value\n+#endif\n+    >\n+    struct __is_memcmp_ordered\n+    {\n+      static const bool __value = _Tp(-1) > _Tp(1); // is unsigned\n+    };\n+\n+  template<typename _Tp>\n+    struct __is_memcmp_ordered<_Tp, false>\n+    {\n+      static const bool __value = false;\n+    };\n+\n+  // Whether two types can be compared using memcmp.\n+  template<typename _Tp, typename _Up, bool = sizeof(_Tp) == sizeof(_Up)>\n+    struct __is_memcmp_ordered_with\n+    {\n+      static const bool __value = __is_memcmp_ordered<_Tp>::__value\n+\t&& __is_memcmp_ordered<_Up>::__value;\n+    };\n+\n+  template<typename _Tp, typename _Up>\n+    struct __is_memcmp_ordered_with<_Tp, _Up, false>\n+    {\n+      static const bool __value = false;\n+    };\n+\n+#if __cplusplus >= 201703L\n+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n+  // std::byte is not an integer, but it can be compared using memcmp.\n+  template<>\n+    struct __is_memcmp_ordered<std::byte, false>\n+    { static constexpr bool __value = true; };\n+#endif\n+\n+  // std::byte can only be compared to itself, not to other types.\n+  template<>\n+    struct __is_memcmp_ordered_with<std::byte, std::byte, true>\n+    { static constexpr bool __value = true; };\n+\n+  template<typename _Tp, bool _SameSize>\n+    struct __is_memcmp_ordered_with<_Tp, std::byte, _SameSize>\n+    { static constexpr bool __value = false; };\n+\n+  template<typename _Up, bool _SameSize>\n+    struct __is_memcmp_ordered_with<std::byte, _Up, _SameSize>\n+    { static constexpr bool __value = false; };\n+#endif\n+\n   //\n   // Move iterator type\n   //"}, {"sha": "651ae70a84b9ad1337a4f48403a56461f4c48c9c", "filename": "libstdc++-v3/include/bits/deque.tcc", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f983fa69005b603ea1758a013b4134d5b0f24a8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdeque.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f983fa69005b603ea1758a013b4134d5b0f24a8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdeque.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdeque.tcc?ref=2f983fa69005b603ea1758a013b4134d5b0f24a8", "patch": "@@ -1269,9 +1269,7 @@ _GLIBCXX_END_NAMESPACE_CONTAINER\n \tconst _Tp2* __first2, const _Tp2* __last2)\n     {\n       const bool __simple =\n-\t(__is_byte<_Tp1>::__value && __is_byte<_Tp2>::__value\n-\t && !__gnu_cxx::__numeric_traits<_Tp1>::__is_signed\n-\t && !__gnu_cxx::__numeric_traits<_Tp2>::__is_signed\n+\t(__is_memcmp_ordered_with<_Tp1, _Tp2>::__value\n \t && __is_pointer<_Ptr>::__value\n #if __cplusplus > 201703L && __cpp_lib_concepts\n \t // For C++20 iterator_traits<volatile T*>::value_type is non-volatile\n@@ -1327,9 +1325,7 @@ _GLIBCXX_END_NAMESPACE_CONTAINER\n \t\t_GLIBCXX_STD_C::_Deque_iterator<_Tp2, _Ref2, _Ptr2> __last2)\n     {\n       const bool __simple =\n-\t(__is_byte<_Tp1>::__value && __is_byte<_Tp2>::__value\n-\t && !__gnu_cxx::__numeric_traits<_Tp1>::__is_signed\n-\t && !__gnu_cxx::__numeric_traits<_Tp2>::__is_signed\n+\t(__is_memcmp_ordered_with<_Tp1, _Tp2>::__value\n \t && __is_pointer<_Ptr1>::__value\n \t && __is_pointer<_Ptr2>::__value\n #if __cplusplus > 201703L && __cpp_lib_concepts"}, {"sha": "a5539650edcfd82eb7cb067614c55dd3e38fc959", "filename": "libstdc++-v3/include/bits/ranges_algo.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f983fa69005b603ea1758a013b4134d5b0f24a8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f983fa69005b603ea1758a013b4134d5b0f24a8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algo.h?ref=2f983fa69005b603ea1758a013b4134d5b0f24a8", "patch": "@@ -3475,10 +3475,7 @@ namespace ranges\n \t\t// This condition is consistent with the one in\n \t\t// __lexicographical_compare_aux in <bits/stl_algobase.h>.\n \t\tconstexpr bool __use_memcmp\n-\t\t  = (__is_byte<_ValueType1>::__value\n-\t\t     && __is_byte<_ValueType2>::__value\n-\t\t     && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed\n-\t\t     && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed\n+\t\t  = (__is_memcmp_ordered_with<_ValueType1, _ValueType2>::__value\n \t\t     && __ptr_to_nonvolatile<_Iter1>\n \t\t     && __ptr_to_nonvolatile<_Iter2>\n \t\t     && (is_same_v<_Comp, ranges::less>"}, {"sha": "3e9ec32340ed7633a8dc293d3f1cbfb05840aa3d", "filename": "libstdc++-v3/include/bits/stl_algobase.h", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f983fa69005b603ea1758a013b4134d5b0f24a8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f983fa69005b603ea1758a013b4134d5b0f24a8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h?ref=2f983fa69005b603ea1758a013b4134d5b0f24a8", "patch": "@@ -1368,9 +1368,7 @@ _GLIBCXX_END_NAMESPACE_CONTAINER\n       typedef typename iterator_traits<_II1>::value_type _ValueType1;\n       typedef typename iterator_traits<_II2>::value_type _ValueType2;\n       const bool __simple =\n-\t(__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value\n-\t && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed\n-\t && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed\n+\t(__is_memcmp_ordered_with<_ValueType1, _ValueType2>::__value\n \t && __is_pointer<_II1>::__value\n \t && __is_pointer<_II2>::__value\n #if __cplusplus > 201703L && __cpp_lib_concepts\n@@ -1785,8 +1783,7 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO\n   // or std::byte, suitable for comparison by memcmp.\n   template<typename _Iter>\n     concept __is_byte_iter = contiguous_iterator<_Iter>\n-      && __is_byte<iter_value_t<_Iter>>::__value != 0\n-      && !__gnu_cxx::__numeric_traits<iter_value_t<_Iter>>::__is_signed;\n+      && __is_memcmp_ordered<iter_value_t<_Iter>>::__value;\n \n   // Return a struct with two members, initialized to the smaller of x and y\n   // (or x if they compare equal) and the result of the comparison x <=> y."}, {"sha": "3bb6f48c4321c25dd1600fc34cf09ba6c6e6e393", "filename": "libstdc++-v3/include/std/array", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f983fa69005b603ea1758a013b4134d5b0f24a8/libstdc%2B%2B-v3%2Finclude%2Fstd%2Farray", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f983fa69005b603ea1758a013b4134d5b0f24a8/libstdc%2B%2B-v3%2Finclude%2Fstd%2Farray", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Farray?ref=2f983fa69005b603ea1758a013b4134d5b0f24a8", "patch": "@@ -258,16 +258,20 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     constexpr __detail::__synth3way_t<_Tp>\n     operator<=>(const array<_Tp, _Nm>& __a, const array<_Tp, _Nm>& __b)\n     {\n-      if constexpr (_Nm && __is_byte<_Tp>::__value)\n-\treturn __builtin_memcmp(__a.data(), __b.data(), _Nm) <=> 0;\n-      else\n+#ifdef __cpp_lib_is_constant_evaluated\n+      if constexpr (_Nm && __is_memcmp_ordered<_Tp>::__value)\n+\tif (!std::is_constant_evaluated())\n+\t  {\n+\t    constexpr size_t __n = _Nm * sizeof(_Tp);\n+\t    return __builtin_memcmp(__a.data(), __b.data(), __n) <=> 0;\n+\t  }\n+#endif\n+\n+      for (size_t __i = 0; __i < _Nm; ++__i)\n \t{\n-\t  for (size_t __i = 0; __i < _Nm; ++__i)\n-\t    {\n-\t      auto __c = __detail::__synth3way(__a[__i], __b[__i]);\n-\t      if (__c != 0)\n-\t\treturn __c;\n-\t    }\n+\t  auto __c = __detail::__synth3way(__a[__i], __b[__i]);\n+\t  if (__c != 0)\n+\t    return __c;\n \t}\n       return strong_ordering::equal;\n     }"}, {"sha": "b2a464b8f68f84bc3b782f30b689cb5d041b103c", "filename": "libstdc++-v3/testsuite/23_containers/array/comparison_operators/96851.cc", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f983fa69005b603ea1758a013b4134d5b0f24a8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Farray%2Fcomparison_operators%2F96851.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f983fa69005b603ea1758a013b4134d5b0f24a8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Farray%2Fcomparison_operators%2F96851.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Farray%2Fcomparison_operators%2F96851.cc?ref=2f983fa69005b603ea1758a013b4134d5b0f24a8", "patch": "@@ -0,0 +1,119 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <array>\n+#include <testsuite_hooks.h>\n+\n+template<typename T>\n+constexpr auto\n+cmp_array(T t)\n+{\n+  std::array<T, 2> a{ T{1}, t };\n+  std::array<T, 2> b{ T{1}, T{2} };\n+  return a <=> b;\n+}\n+\n+void\n+test01()\n+{\n+  static_assert( cmp_array((unsigned char)1) < 0 );\n+  static_assert( cmp_array((unsigned char)2) == 0 );\n+  static_assert( cmp_array((unsigned char)3) > 0 );\n+\n+  static_assert( cmp_array((signed char)-1) < 0 );\n+  static_assert( cmp_array((signed char)2) == 0 );\n+  static_assert( cmp_array((signed char)3) > 0 );\n+\n+  static_assert( cmp_array(std::byte{1}) < 0 );\n+  static_assert( cmp_array(std::byte{2}) == 0 );\n+  static_assert( cmp_array(std::byte{3}) > 0 );\n+\n+  static_assert( cmp_array((unsigned int)1) < 0 );\n+  static_assert( cmp_array((unsigned int)2) == 0 );\n+  static_assert( cmp_array((unsigned int)333) > 0 );\n+  static_assert( cmp_array((unsigned int)4444) > 0 );\n+  static_assert( cmp_array((unsigned int)55555) > 0 );\n+  static_assert( cmp_array((unsigned int)0x66666666) > 0 );\n+\n+  static_assert( cmp_array((signed int)-1) < 0 );\n+  static_assert( cmp_array((signed int)2) == 0 );\n+  static_assert( cmp_array((signed int)333) > 0 );\n+  static_assert( cmp_array((signed int)-4444) < 0 );\n+  static_assert( cmp_array((signed int)55555) > 0 );\n+  static_assert( cmp_array((signed int)-0x66666666) < 0 );\n+}\n+\n+void\n+test02()\n+{\n+  unsigned char uc = 1;\n+  VERIFY( cmp_array(uc) < 0 );\n+  uc = 2;\n+  VERIFY( cmp_array(uc) == 0 );\n+  uc = 3;\n+  VERIFY( cmp_array(uc) > 0 );\n+\n+  signed char sc = -1;\n+  VERIFY( cmp_array(sc) < 0 );\n+  sc = 2;\n+  VERIFY( cmp_array(sc) == 0 );\n+  sc = 3;\n+  VERIFY( cmp_array(sc) > 0 );\n+\n+  std::byte b{1};\n+  VERIFY( cmp_array(b) < 0 );\n+  b = std::byte{2};\n+  VERIFY( cmp_array(b) == 0 );\n+  b = std::byte{3};\n+  VERIFY( cmp_array(b) > 0 );\n+\n+  unsigned int ui = 1;\n+  VERIFY( cmp_array(ui) < 0 );\n+  ui = 2;\n+  VERIFY( cmp_array(ui) == 0 );\n+  ui = 333;\n+  VERIFY( cmp_array(ui) > 0 );\n+  ui = 4444;\n+  VERIFY( cmp_array(ui) > 0 );\n+  ui = 555555;\n+  VERIFY( cmp_array(ui) > 0 );\n+  ui = 0x66666666;\n+  VERIFY( cmp_array(ui) > 0 );\n+\n+  signed int si = -1;\n+  VERIFY( cmp_array(si) < 0 );\n+  si = 2;\n+  VERIFY( cmp_array(si) == 0 );\n+  si = 333;\n+  VERIFY( cmp_array(si) > 0 );\n+  si = -4444;\n+  VERIFY( cmp_array(si) < 0 );\n+  si = 555555;\n+  VERIFY( cmp_array(si) > 0 );\n+  si = -0x66666666;\n+  VERIFY( cmp_array(si) < 0 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "a2640318617d90aba12d8a258916e4e189a2e0a9", "filename": "libstdc++-v3/testsuite/23_containers/array/tuple_interface/get_neg.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f983fa69005b603ea1758a013b4134d5b0f24a8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Farray%2Ftuple_interface%2Fget_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f983fa69005b603ea1758a013b4134d5b0f24a8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Farray%2Ftuple_interface%2Fget_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Farray%2Ftuple_interface%2Fget_neg.cc?ref=2f983fa69005b603ea1758a013b4134d5b0f24a8", "patch": "@@ -27,6 +27,6 @@ int n1 = std::get<1>(a);\n int n2 = std::get<1>(std::move(a));\n int n3 = std::get<1>(ca);\n \n-// { dg-error \"static assertion failed\" \"\" { target *-*-* } 336 }\n-// { dg-error \"static assertion failed\" \"\" { target *-*-* } 345 }\n-// { dg-error \"static assertion failed\" \"\" { target *-*-* } 353 }\n+// { dg-error \"static assertion failed\" \"\" { target *-*-* } 340 }\n+// { dg-error \"static assertion failed\" \"\" { target *-*-* } 349 }\n+// { dg-error \"static assertion failed\" \"\" { target *-*-* } 357 }"}]}