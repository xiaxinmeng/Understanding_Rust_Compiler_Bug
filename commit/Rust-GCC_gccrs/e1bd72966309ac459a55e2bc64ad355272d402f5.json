{"sha": "e1bd72966309ac459a55e2bc64ad355272d402f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTFiZDcyOTY2MzA5YWM0NTlhNTVlMmJjNjRhZDM1NTI3MmQ0MDJmNQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2018-07-31T14:22:05Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-07-31T14:22:05Z"}, "message": "[12/46] Make vect_finish_stmt_generation return a stmt_vec_info\n\nThis patch makes vect_finish_replace_stmt and vect_finish_stmt_generation\nreturn the stmt_vec_info for the vectorised statement, so that the caller\ndoesn't need a separate vinfo_for_stmt to get at it.\n\nThis involved changing the structure of the statement-generating loops\nso that they use narrow scopes for the vectorised gimple statements\nand use the existing (wider) scopes for the associated stmt_vec_infos.\nThis helps with gimple stmt->stmt_vec_info changes further down the line.\n\nThe way we do this generation is another area ripe for clean-up,\nbut that's too much of a rabbit-hole for this series.\n\n2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-vectorizer.h (vect_finish_replace_stmt): Return a stmt_vec_info\n\t(vect_finish_stmt_generation): Likewise.\n\t* tree-vect-stmts.c (vect_finish_stmt_generation_1): Likewise.\n\t(vect_finish_replace_stmt, vect_finish_stmt_generation): Likewise.\n\t(vect_build_gather_load_calls): Use the return value of the above\n\tfunctions instead of a separate call to vinfo_for_stmt.  Use narrow\n\tscopes for the input gimple stmt and wider scopes for the associated\n\tstmt_vec_info.  Use vec_info::lookup_def when setting these\n\tstmt_vec_infos from an SSA_NAME definition.\n\t(vectorizable_bswap, vectorizable_call, vectorizable_simd_clone_call)\n\t(vect_create_vectorized_demotion_stmts, vectorizable_conversion)\n\t(vectorizable_assignment, vectorizable_shift, vectorizable_operation)\n\t(vectorizable_store, vectorizable_load, vectorizable_condition)\n\t(vectorizable_comparison): Likewise.\n\t* tree-vect-loop.c (vectorize_fold_left_reduction): Likewise.\n\t(vectorizable_reduction): Likewise.\n\nFrom-SVN: r263127", "tree": {"sha": "61ce73a63a79b56f77a39ccb07e013a49b8732aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/61ce73a63a79b56f77a39ccb07e013a49b8732aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e1bd72966309ac459a55e2bc64ad355272d402f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1bd72966309ac459a55e2bc64ad355272d402f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1bd72966309ac459a55e2bc64ad355272d402f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1bd72966309ac459a55e2bc64ad355272d402f5/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fef96d8e2a370e826acdf914d51c88aa2657340a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fef96d8e2a370e826acdf914d51c88aa2657340a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fef96d8e2a370e826acdf914d51c88aa2657340a"}], "stats": {"total": 550, "additions": 310, "deletions": 240}, "files": [{"sha": "16a9bb360f5d93457b488d581ed259da2289a69d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1bd72966309ac459a55e2bc64ad355272d402f5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1bd72966309ac459a55e2bc64ad355272d402f5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e1bd72966309ac459a55e2bc64ad355272d402f5", "patch": "@@ -1,3 +1,22 @@\n+2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vectorizer.h (vect_finish_replace_stmt): Return a stmt_vec_info\n+\t(vect_finish_stmt_generation): Likewise.\n+\t* tree-vect-stmts.c (vect_finish_stmt_generation_1): Likewise.\n+\t(vect_finish_replace_stmt, vect_finish_stmt_generation): Likewise.\n+\t(vect_build_gather_load_calls): Use the return value of the above\n+\tfunctions instead of a separate call to vinfo_for_stmt.  Use narrow\n+\tscopes for the input gimple stmt and wider scopes for the associated\n+\tstmt_vec_info.  Use vec_info::lookup_def when setting these\n+\tstmt_vec_infos from an SSA_NAME definition.\n+\t(vectorizable_bswap, vectorizable_call, vectorizable_simd_clone_call)\n+\t(vect_create_vectorized_demotion_stmts, vectorizable_conversion)\n+\t(vectorizable_assignment, vectorizable_shift, vectorizable_operation)\n+\t(vectorizable_store, vectorizable_load, vectorizable_condition)\n+\t(vectorizable_comparison): Likewise.\n+\t* tree-vect-loop.c (vectorize_fold_left_reduction): Likewise.\n+\t(vectorizable_reduction): Likewise.\n+\n 2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-vectorizer.h (vect_is_simple_use): Add an optional"}, {"sha": "ff4a8cfa58ab9479d89069943bf5cf890a72bc2e", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1bd72966309ac459a55e2bc64ad355272d402f5/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1bd72966309ac459a55e2bc64ad355272d402f5/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=e1bd72966309ac459a55e2bc64ad355272d402f5", "patch": "@@ -5861,7 +5861,7 @@ vectorize_fold_left_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   tree vectype_out = STMT_VINFO_VECTYPE (stmt_info);\n-  gimple *new_stmt = NULL;\n+  stmt_vec_info new_stmt_info = NULL;\n \n   int ncopies;\n   if (slp_node)\n@@ -5917,6 +5917,7 @@ vectorize_fold_left_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n   tree def0;\n   FOR_EACH_VEC_ELT (vec_oprnds0, i, def0)\n     {\n+      gimple *new_stmt;\n       tree mask = NULL_TREE;\n       if (LOOP_VINFO_FULLY_MASKED_P (loop_vinfo))\n \tmask = vect_get_loop_mask (gsi, masks, vec_num, vectype_in, i);\n@@ -5965,17 +5966,18 @@ vectorize_fold_left_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n       if (i == vec_num - 1)\n \t{\n \t  gimple_set_lhs (new_stmt, scalar_dest);\n-\t  vect_finish_replace_stmt (scalar_dest_def, new_stmt);\n+\t  new_stmt_info = vect_finish_replace_stmt (scalar_dest_def, new_stmt);\n \t}\n       else\n-\tvect_finish_stmt_generation (scalar_dest_def, new_stmt, gsi);\n+\tnew_stmt_info = vect_finish_stmt_generation (scalar_dest_def,\n+\t\t\t\t\t\t     new_stmt, gsi);\n \n       if (slp_node)\n-\tSLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt);\n+\tSLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt_info);\n     }\n \n   if (!slp_node)\n-    STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n+    STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt_info;\n \n   return true;\n }\n@@ -6102,7 +6104,7 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n   int epilog_copies;\n   stmt_vec_info prev_stmt_info, prev_phi_info;\n   bool single_defuse_cycle = false;\n-  gimple *new_stmt = NULL;\n+  stmt_vec_info new_stmt_info = NULL;\n   int j;\n   tree ops[3];\n   enum vect_def_type dts[3];\n@@ -7130,19 +7132,19 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \t      gcc_assert (reduc_index != -1 || ! single_defuse_cycle);\n \n \t      if (single_defuse_cycle && reduc_index == 0)\n-\t\tvec_oprnds0[0] = gimple_get_lhs (new_stmt);\n+\t\tvec_oprnds0[0] = gimple_get_lhs (new_stmt_info->stmt);\n \t      else\n \t\tvec_oprnds0[0]\n \t\t  = vect_get_vec_def_for_stmt_copy (dts[0], vec_oprnds0[0]);\n \t      if (single_defuse_cycle && reduc_index == 1)\n-\t\tvec_oprnds1[0] = gimple_get_lhs (new_stmt);\n+\t\tvec_oprnds1[0] = gimple_get_lhs (new_stmt_info->stmt);\n \t      else\n \t\tvec_oprnds1[0]\n \t\t  = vect_get_vec_def_for_stmt_copy (dts[1], vec_oprnds1[0]);\n \t      if (op_type == ternary_op)\n \t\t{\n \t\t  if (single_defuse_cycle && reduc_index == 2)\n-\t\t    vec_oprnds2[0] = gimple_get_lhs (new_stmt);\n+\t\t    vec_oprnds2[0] = gimple_get_lhs (new_stmt_info->stmt);\n \t\t  else\n \t\t    vec_oprnds2[0] \n \t\t      = vect_get_vec_def_for_stmt_copy (dts[2], vec_oprnds2[0]);\n@@ -7169,23 +7171,24 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \t      new_temp = make_ssa_name (vec_dest, call);\n \t      gimple_call_set_lhs (call, new_temp);\n \t      gimple_call_set_nothrow (call, true);\n-\t      new_stmt = call;\n+\t      new_stmt_info = vect_finish_stmt_generation (stmt, call, gsi);\n \t    }\n \t  else\n \t    {\n \t      if (op_type == ternary_op)\n \t\tvop[2] = vec_oprnds2[i];\n \n-\t      new_stmt = gimple_build_assign (vec_dest, code,\n-\t\t\t\t\t      vop[0], vop[1], vop[2]);\n+\t      gassign *new_stmt = gimple_build_assign (vec_dest, code,\n+\t\t\t\t\t\t       vop[0], vop[1], vop[2]);\n \t      new_temp = make_ssa_name (vec_dest, new_stmt);\n \t      gimple_assign_set_lhs (new_stmt, new_temp);\n+\t      new_stmt_info\n+\t\t= vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t    }\n-\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \n           if (slp_node)\n             {\n-              SLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt);\n+\t      SLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt_info);\n               vect_defs.quick_push (new_temp);\n             }\n           else\n@@ -7196,11 +7199,11 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n         continue;\n \n       if (j == 0)\n-\tSTMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n+\tSTMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt_info;\n       else\n-\tSTMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n+\tSTMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt_info;\n \n-      prev_stmt_info = vinfo_for_stmt (new_stmt);\n+      prev_stmt_info = new_stmt_info;\n     }\n \n   /* Finalize the reduction-phi (set its arguments) and create the"}, {"sha": "f228301f4ffa719687b9e16d618cd742c6d16c6d", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 268, "deletions": 220, "changes": 488, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1bd72966309ac459a55e2bc64ad355272d402f5/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1bd72966309ac459a55e2bc64ad355272d402f5/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=e1bd72966309ac459a55e2bc64ad355272d402f5", "patch": "@@ -1729,15 +1729,15 @@ vect_get_vec_defs (tree op0, tree op1, gimple *stmt,\n \n /* Helper function called by vect_finish_replace_stmt and\n    vect_finish_stmt_generation.  Set the location of the new\n-   statement and create a stmt_vec_info for it.  */\n+   statement and create and return a stmt_vec_info for it.  */\n \n-static void\n+static stmt_vec_info\n vect_finish_stmt_generation_1 (gimple *stmt, gimple *vec_stmt)\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   vec_info *vinfo = stmt_info->vinfo;\n \n-  vinfo->add_stmt (vec_stmt);\n+  stmt_vec_info vec_stmt_info = vinfo->add_stmt (vec_stmt);\n \n   if (dump_enabled_p ())\n     {\n@@ -1753,27 +1753,29 @@ vect_finish_stmt_generation_1 (gimple *stmt, gimple *vec_stmt)\n   int lp_nr = lookup_stmt_eh_lp (stmt);\n   if (lp_nr != 0 && stmt_could_throw_p (vec_stmt))\n     add_stmt_to_eh_lp (vec_stmt, lp_nr);\n+\n+  return vec_stmt_info;\n }\n \n /* Replace the scalar statement STMT with a new vector statement VEC_STMT,\n-   which sets the same scalar result as STMT did.  */\n+   which sets the same scalar result as STMT did.  Create and return a\n+   stmt_vec_info for VEC_STMT.  */\n \n-void\n+stmt_vec_info\n vect_finish_replace_stmt (gimple *stmt, gimple *vec_stmt)\n {\n   gcc_assert (gimple_get_lhs (stmt) == gimple_get_lhs (vec_stmt));\n \n   gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n   gsi_replace (&gsi, vec_stmt, false);\n \n-  vect_finish_stmt_generation_1 (stmt, vec_stmt);\n+  return vect_finish_stmt_generation_1 (stmt, vec_stmt);\n }\n \n-/* Function vect_finish_stmt_generation.\n+/* Add VEC_STMT to the vectorized implementation of STMT and insert it\n+   before *GSI.  Create and return a stmt_vec_info for VEC_STMT.  */\n \n-   Insert a new stmt.  */\n-\n-void\n+stmt_vec_info\n vect_finish_stmt_generation (gimple *stmt, gimple *vec_stmt,\n \t\t\t     gimple_stmt_iterator *gsi)\n {\n@@ -1806,7 +1808,7 @@ vect_finish_stmt_generation (gimple *stmt, gimple *vec_stmt,\n \t}\n     }\n   gsi_insert_before (gsi, vec_stmt, GSI_SAME_STMT);\n-  vect_finish_stmt_generation_1 (stmt, vec_stmt);\n+  return vect_finish_stmt_generation_1 (stmt, vec_stmt);\n }\n \n /* We want to vectorize a call to combined function CFN with function\n@@ -2774,7 +2776,6 @@ vect_build_gather_load_calls (gimple *stmt, gimple_stmt_iterator *gsi,\n   for (int j = 0; j < ncopies; ++j)\n     {\n       tree op, var;\n-      gimple *new_stmt;\n       if (modifier == WIDEN && (j & 1))\n \top = permute_vec_elements (vec_oprnd0, vec_oprnd0,\n \t\t\t\t   perm_mask, stmt, gsi);\n@@ -2791,7 +2792,7 @@ vect_build_gather_load_calls (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t\t\tTYPE_VECTOR_SUBPARTS (idxtype)));\n \t  var = vect_get_new_ssa_name (idxtype, vect_simple_var);\n \t  op = build1 (VIEW_CONVERT_EXPR, idxtype, op);\n-\t  new_stmt = gimple_build_assign (var, VIEW_CONVERT_EXPR, op);\n+\t  gassign *new_stmt = gimple_build_assign (var, VIEW_CONVERT_EXPR, op);\n \t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t  op = var;\n \t}\n@@ -2816,37 +2817,38 @@ vect_build_gather_load_calls (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t\t       TYPE_VECTOR_SUBPARTS (masktype)));\n \t\t  var = vect_get_new_ssa_name (masktype, vect_simple_var);\n \t\t  mask_op = build1 (VIEW_CONVERT_EXPR, masktype, mask_op);\n-\t\t  new_stmt = gimple_build_assign (var, VIEW_CONVERT_EXPR,\n-\t\t\t\t\t\t  mask_op);\n+\t\t  gassign *new_stmt\n+\t\t    = gimple_build_assign (var, VIEW_CONVERT_EXPR, mask_op);\n \t\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t\t  mask_op = var;\n \t\t}\n \t    }\n \t  src_op = mask_op;\n \t}\n \n-      new_stmt = gimple_build_call (gs_info->decl, 5, src_op, ptr, op,\n-\t\t\t\t    mask_op, scale);\n+      gcall *new_call = gimple_build_call (gs_info->decl, 5, src_op, ptr, op,\n+\t\t\t\t\t   mask_op, scale);\n \n+      stmt_vec_info new_stmt_info;\n       if (!useless_type_conversion_p (vectype, rettype))\n \t{\n \t  gcc_assert (known_eq (TYPE_VECTOR_SUBPARTS (vectype),\n \t\t\t\tTYPE_VECTOR_SUBPARTS (rettype)));\n \t  op = vect_get_new_ssa_name (rettype, vect_simple_var);\n-\t  gimple_call_set_lhs (new_stmt, op);\n-\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t  gimple_call_set_lhs (new_call, op);\n+\t  vect_finish_stmt_generation (stmt, new_call, gsi);\n \t  var = make_ssa_name (vec_dest);\n \t  op = build1 (VIEW_CONVERT_EXPR, vectype, op);\n-\t  new_stmt = gimple_build_assign (var, VIEW_CONVERT_EXPR, op);\n+\t  gassign *new_stmt = gimple_build_assign (var, VIEW_CONVERT_EXPR, op);\n+\t  new_stmt_info = vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t}\n       else\n \t{\n-\t  var = make_ssa_name (vec_dest, new_stmt);\n-\t  gimple_call_set_lhs (new_stmt, var);\n+\t  var = make_ssa_name (vec_dest, new_call);\n+\t  gimple_call_set_lhs (new_call, var);\n+\t  new_stmt_info = vect_finish_stmt_generation (stmt, new_call, gsi);\n \t}\n \n-      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n-\n       if (modifier == NARROW)\n \t{\n \t  if ((j & 1) == 0)\n@@ -2855,14 +2857,14 @@ vect_build_gather_load_calls (gimple *stmt, gimple_stmt_iterator *gsi,\n \t      continue;\n \t    }\n \t  var = permute_vec_elements (prev_res, var, perm_mask, stmt, gsi);\n-\t  new_stmt = SSA_NAME_DEF_STMT (var);\n+\t  new_stmt_info = loop_vinfo->lookup_def (var);\n \t}\n \n       if (prev_stmt_info == NULL_STMT_VEC_INFO)\n-\tSTMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n+\tSTMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt_info;\n       else\n-\tSTMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n-      prev_stmt_info = vinfo_for_stmt (new_stmt);\n+\tSTMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt_info;\n+      prev_stmt_info = new_stmt_info;\n     }\n }\n \n@@ -3023,7 +3025,7 @@ vectorizable_bswap (gimple *stmt, gimple_stmt_iterator *gsi,\n \n   /* Transform.  */\n   vec<tree> vec_oprnds = vNULL;\n-  gimple *new_stmt = NULL;\n+  stmt_vec_info new_stmt_info = NULL;\n   stmt_vec_info prev_stmt_info = NULL;\n   for (unsigned j = 0; j < ncopies; j++)\n     {\n@@ -3038,6 +3040,7 @@ vectorizable_bswap (gimple *stmt, gimple_stmt_iterator *gsi,\n       tree vop;\n       FOR_EACH_VEC_ELT (vec_oprnds, i, vop)\n        {\n+\t gimple *new_stmt;\n \t tree tem = make_ssa_name (char_vectype);\n \t new_stmt = gimple_build_assign (tem, build1 (VIEW_CONVERT_EXPR,\n \t\t\t\t\t\t      char_vectype, vop));\n@@ -3049,20 +3052,20 @@ vectorizable_bswap (gimple *stmt, gimple_stmt_iterator *gsi,\n \t tem = make_ssa_name (vectype);\n \t new_stmt = gimple_build_assign (tem, build1 (VIEW_CONVERT_EXPR,\n \t\t\t\t\t\t      vectype, tem2));\n-\t vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t new_stmt_info = vect_finish_stmt_generation (stmt, new_stmt, gsi);\n          if (slp_node)\n-           SLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt);\n+\t   SLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt_info);\n        }\n \n       if (slp_node)\n         continue;\n \n       if (j == 0)\n-        STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n+\tSTMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt_info;\n       else\n-        STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n+\tSTMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt_info;\n \n-      prev_stmt_info = vinfo_for_stmt (new_stmt);\n+      prev_stmt_info = new_stmt_info;\n     }\n \n   vec_oprnds.release ();\n@@ -3123,7 +3126,6 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n     = { vect_unknown_def_type, vect_unknown_def_type, vect_unknown_def_type,\n \tvect_unknown_def_type };\n   int ndts = ARRAY_SIZE (dt);\n-  gimple *new_stmt = NULL;\n   int ncopies, j;\n   auto_vec<tree, 8> vargs;\n   auto_vec<tree, 8> orig_vargs;\n@@ -3361,6 +3363,7 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \n   bool masked_loop_p = loop_vinfo && LOOP_VINFO_FULLY_MASKED_P (loop_vinfo);\n \n+  stmt_vec_info new_stmt_info = NULL;\n   prev_stmt_info = NULL;\n   if (modifier == NONE || ifn != IFN_LAST)\n     {\n@@ -3399,16 +3402,19 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t\t= gimple_build_call_internal_vec (ifn, vargs);\n \t\t      gimple_call_set_lhs (call, half_res);\n \t\t      gimple_call_set_nothrow (call, true);\n-\t\t      new_stmt = call;\n-\t\t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t\t      new_stmt_info\n+\t\t\t= vect_finish_stmt_generation (stmt, call, gsi);\n \t\t      if ((i & 1) == 0)\n \t\t\t{\n \t\t\t  prev_res = half_res;\n \t\t\t  continue;\n \t\t\t}\n \t\t      new_temp = make_ssa_name (vec_dest);\n-\t\t      new_stmt = gimple_build_assign (new_temp, convert_code,\n-\t\t\t\t\t\t      prev_res, half_res);\n+\t\t      gimple *new_stmt\n+\t\t\t= gimple_build_assign (new_temp, convert_code,\n+\t\t\t\t\t       prev_res, half_res);\n+\t\t      new_stmt_info\n+\t\t\t= vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t\t    }\n \t\t  else\n \t\t    {\n@@ -3431,10 +3437,10 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t      new_temp = make_ssa_name (vec_dest, call);\n \t\t      gimple_call_set_lhs (call, new_temp);\n \t\t      gimple_call_set_nothrow (call, true);\n-\t\t      new_stmt = call;\n+\t\t      new_stmt_info\n+\t\t\t= vect_finish_stmt_generation (stmt, call, gsi);\n \t\t    }\n-\t\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n-\t\t  SLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt);\n+\t\t  SLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt_info);\n \t\t}\n \n \t      for (i = 0; i < nargs; i++)\n@@ -3475,7 +3481,9 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t      gimple *init_stmt = gimple_build_assign (new_var, cst);\n \t      vect_init_vector_1 (stmt, init_stmt, NULL);\n \t      new_temp = make_ssa_name (vec_dest);\n-\t      new_stmt = gimple_build_assign (new_temp, new_var);\n+\t      gimple *new_stmt = gimple_build_assign (new_temp, new_var);\n+\t      new_stmt_info\n+\t\t= vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t    }\n \t  else if (modifier == NARROW)\n \t    {\n@@ -3486,16 +3494,17 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t      gcall *call = gimple_build_call_internal_vec (ifn, vargs);\n \t      gimple_call_set_lhs (call, half_res);\n \t      gimple_call_set_nothrow (call, true);\n-\t      new_stmt = call;\n-\t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t      new_stmt_info = vect_finish_stmt_generation (stmt, call, gsi);\n \t      if ((j & 1) == 0)\n \t\t{\n \t\t  prev_res = half_res;\n \t\t  continue;\n \t\t}\n \t      new_temp = make_ssa_name (vec_dest);\n-\t      new_stmt = gimple_build_assign (new_temp, convert_code,\n-\t\t\t\t\t      prev_res, half_res);\n+\t      gassign *new_stmt = gimple_build_assign (new_temp, convert_code,\n+\t\t\t\t\t\t       prev_res, half_res);\n+\t      new_stmt_info\n+\t\t= vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t    }\n \t  else\n \t    {\n@@ -3504,19 +3513,18 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\tcall = gimple_build_call_internal_vec (ifn, vargs);\n \t      else\n \t\tcall = gimple_build_call_vec (fndecl, vargs);\n-\t      new_temp = make_ssa_name (vec_dest, new_stmt);\n+\t      new_temp = make_ssa_name (vec_dest, call);\n \t      gimple_call_set_lhs (call, new_temp);\n \t      gimple_call_set_nothrow (call, true);\n-\t      new_stmt = call;\n+\t      new_stmt_info = vect_finish_stmt_generation (stmt, call, gsi);\n \t    }\n-\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \n \t  if (j == (modifier == NARROW ? 1 : 0))\n-\t    STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n+\t    STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt_info;\n \t  else\n-\t    STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n+\t    STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt_info;\n \n-\t  prev_stmt_info = vinfo_for_stmt (new_stmt);\n+\t  prev_stmt_info = new_stmt_info;\n \t}\n     }\n   else if (modifier == NARROW)\n@@ -3560,9 +3568,9 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t  new_temp = make_ssa_name (vec_dest, call);\n \t\t  gimple_call_set_lhs (call, new_temp);\n \t\t  gimple_call_set_nothrow (call, true);\n-\t\t  new_stmt = call;\n-\t\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n-\t\t  SLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt);\n+\t\t  new_stmt_info\n+\t\t    = vect_finish_stmt_generation (stmt, call, gsi);\n+\t\t  SLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt_info);\n \t\t}\n \n \t      for (i = 0; i < nargs; i++)\n@@ -3585,7 +3593,8 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t}\n \t      else\n \t\t{\n-\t\t  vec_oprnd1 = gimple_call_arg (new_stmt, 2*i + 1);\n+\t\t  vec_oprnd1 = gimple_call_arg (new_stmt_info->stmt,\n+\t\t\t\t\t\t2 * i + 1);\n \t\t  vec_oprnd0\n \t\t    = vect_get_vec_def_for_stmt_copy (dt[i], vec_oprnd1);\n \t\t  vec_oprnd1\n@@ -3596,17 +3605,17 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t      vargs.quick_push (vec_oprnd1);\n \t    }\n \n-\t  new_stmt = gimple_build_call_vec (fndecl, vargs);\n+\t  gcall *new_stmt = gimple_build_call_vec (fndecl, vargs);\n \t  new_temp = make_ssa_name (vec_dest, new_stmt);\n \t  gimple_call_set_lhs (new_stmt, new_temp);\n-\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t  new_stmt_info = vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \n \t  if (j == 0)\n-\t    STMT_VINFO_VEC_STMT (stmt_info) = new_stmt;\n+\t    STMT_VINFO_VEC_STMT (stmt_info) = new_stmt_info;\n \t  else\n-\t    STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n+\t    STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt_info;\n \n-\t  prev_stmt_info = vinfo_for_stmt (new_stmt);\n+\t  prev_stmt_info = new_stmt_info;\n \t}\n \n       *vec_stmt = STMT_VINFO_VEC_STMT (stmt_info);\n@@ -3629,7 +3638,8 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n     stmt_info = vinfo_for_stmt (STMT_VINFO_RELATED_STMT (stmt_info));\n   lhs = gimple_get_lhs (stmt_info->stmt);\n \n-  new_stmt = gimple_build_assign (lhs, build_zero_cst (TREE_TYPE (lhs)));\n+  gassign *new_stmt\n+    = gimple_build_assign (lhs, build_zero_cst (TREE_TYPE (lhs)));\n   set_vinfo_for_stmt (new_stmt, stmt_info);\n   set_vinfo_for_stmt (stmt_info->stmt, NULL);\n   STMT_VINFO_STMT (stmt_info) = new_stmt;\n@@ -3752,7 +3762,6 @@ vectorizable_simd_clone_call (gimple *stmt, gimple_stmt_iterator *gsi,\n   vec_info *vinfo = stmt_info->vinfo;\n   struct loop *loop = loop_vinfo ? LOOP_VINFO_LOOP (loop_vinfo) : NULL;\n   tree fndecl, new_temp;\n-  gimple *new_stmt = NULL;\n   int ncopies, j;\n   auto_vec<simd_call_arg_info> arginfo;\n   vec<tree> vargs = vNULL;\n@@ -4106,7 +4115,7 @@ vectorizable_simd_clone_call (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t\t= build3 (BIT_FIELD_REF, atype, vec_oprnd0,\n \t\t\t\t  bitsize_int (prec),\n \t\t\t\t  bitsize_int ((m & (k - 1)) * prec));\n-\t\t      new_stmt\n+\t\t      gassign *new_stmt\n \t\t\t= gimple_build_assign (make_ssa_name (atype),\n \t\t\t\t\t       vec_oprnd0);\n \t\t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n@@ -4142,7 +4151,7 @@ vectorizable_simd_clone_call (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t      else\n \t\t\t{\n \t\t\t  vec_oprnd0 = build_constructor (atype, ctor_elts);\n-\t\t\t  new_stmt\n+\t\t\t  gassign *new_stmt\n \t\t\t    = gimple_build_assign (make_ssa_name (atype),\n \t\t\t\t\t\t   vec_oprnd0);\n \t\t\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n@@ -4189,7 +4198,7 @@ vectorizable_simd_clone_call (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t\t       ncopies * nunits);\n \t\t  tree tcst = wide_int_to_tree (type, cst);\n \t\t  tree phi_arg = copy_ssa_name (op);\n-\t\t  new_stmt\n+\t\t  gassign *new_stmt\n \t\t    = gimple_build_assign (phi_arg, code, phi_res, tcst);\n \t\t  gimple_stmt_iterator si = gsi_after_labels (loop->header);\n \t\t  gsi_insert_after (&si, new_stmt, GSI_NEW_STMT);\n@@ -4211,8 +4220,9 @@ vectorizable_simd_clone_call (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t\t       j * nunits);\n \t\t  tree tcst = wide_int_to_tree (type, cst);\n \t\t  new_temp = make_ssa_name (TREE_TYPE (op));\n-\t\t  new_stmt = gimple_build_assign (new_temp, code,\n-\t\t\t\t\t\t  arginfo[i].op, tcst);\n+\t\t  gassign *new_stmt\n+\t\t    = gimple_build_assign (new_temp, code,\n+\t\t\t\t\t   arginfo[i].op, tcst);\n \t\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t\t  vargs.safe_push (new_temp);\n \t\t}\n@@ -4228,20 +4238,21 @@ vectorizable_simd_clone_call (gimple *stmt, gimple_stmt_iterator *gsi,\n \t    }\n \t}\n \n-      new_stmt = gimple_build_call_vec (fndecl, vargs);\n+      gcall *new_call = gimple_build_call_vec (fndecl, vargs);\n       if (vec_dest)\n \t{\n \t  gcc_assert (ratype || simd_clone_subparts (rtype) == nunits);\n \t  if (ratype)\n \t    new_temp = create_tmp_var (ratype);\n \t  else if (simd_clone_subparts (vectype)\n \t\t   == simd_clone_subparts (rtype))\n-\t    new_temp = make_ssa_name (vec_dest, new_stmt);\n+\t    new_temp = make_ssa_name (vec_dest, new_call);\n \t  else\n-\t    new_temp = make_ssa_name (rtype, new_stmt);\n-\t  gimple_call_set_lhs (new_stmt, new_temp);\n+\t    new_temp = make_ssa_name (rtype, new_call);\n+\t  gimple_call_set_lhs (new_call, new_temp);\n \t}\n-      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+      stmt_vec_info new_stmt_info\n+\t= vect_finish_stmt_generation (stmt, new_call, gsi);\n \n       if (vec_dest)\n \t{\n@@ -4264,15 +4275,18 @@ vectorizable_simd_clone_call (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t  else\n \t\t    t = build3 (BIT_FIELD_REF, vectype, new_temp,\n \t\t\t\tbitsize_int (prec), bitsize_int (l * prec));\n-\t\t  new_stmt\n+\t\t  gimple *new_stmt\n \t\t    = gimple_build_assign (make_ssa_name (vectype), t);\n-\t\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t\t  new_stmt_info\n+\t\t    = vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\n \t\t  if (j == 0 && l == 0)\n-\t\t    STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n+\t\t    STMT_VINFO_VEC_STMT (stmt_info)\n+\t\t      = *vec_stmt = new_stmt_info;\n \t\t  else\n-\t\t    STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n+\t\t    STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt_info;\n \n-\t\t  prev_stmt_info = vinfo_for_stmt (new_stmt);\n+\t\t  prev_stmt_info = new_stmt_info;\n \t\t}\n \n \t      if (ratype)\n@@ -4293,9 +4307,10 @@ vectorizable_simd_clone_call (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t    {\n \t\t      tree tem = build4 (ARRAY_REF, rtype, new_temp,\n \t\t\t\t\t size_int (m), NULL_TREE, NULL_TREE);\n-\t\t      new_stmt\n+\t\t      gimple *new_stmt\n \t\t\t= gimple_build_assign (make_ssa_name (rtype), tem);\n-\t\t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t\t      new_stmt_info\n+\t\t\t= vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t\t      CONSTRUCTOR_APPEND_ELT (ret_ctor_elts, NULL_TREE,\n \t\t\t\t\t      gimple_assign_lhs (new_stmt));\n \t\t    }\n@@ -4306,36 +4321,38 @@ vectorizable_simd_clone_call (gimple *stmt, gimple_stmt_iterator *gsi,\n \t      if ((j & (k - 1)) != k - 1)\n \t\tcontinue;\n \t      vec_oprnd0 = build_constructor (vectype, ret_ctor_elts);\n-\t      new_stmt\n+\t      gimple *new_stmt\n \t\t= gimple_build_assign (make_ssa_name (vec_dest), vec_oprnd0);\n-\t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t      new_stmt_info\n+\t\t= vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \n \t      if ((unsigned) j == k - 1)\n-\t\tSTMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n+\t\tSTMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt_info;\n \t      else\n-\t\tSTMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n+\t\tSTMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt_info;\n \n-\t      prev_stmt_info = vinfo_for_stmt (new_stmt);\n+\t      prev_stmt_info = new_stmt_info;\n \t      continue;\n \t    }\n \t  else if (ratype)\n \t    {\n \t      tree t = build_fold_addr_expr (new_temp);\n \t      t = build2 (MEM_REF, vectype, t,\n \t\t\t  build_int_cst (TREE_TYPE (t), 0));\n-\t      new_stmt\n+\t      gimple *new_stmt\n \t\t= gimple_build_assign (make_ssa_name (vec_dest), t);\n-\t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t      new_stmt_info\n+\t\t= vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t      vect_clobber_variable (stmt, gsi, new_temp);\n \t    }\n \t}\n \n       if (j == 0)\n-\tSTMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n+\tSTMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt_info;\n       else\n-\tSTMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n+\tSTMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt_info;\n \n-      prev_stmt_info = vinfo_for_stmt (new_stmt);\n+      prev_stmt_info = new_stmt_info;\n     }\n \n   vargs.release ();\n@@ -4348,6 +4365,7 @@ vectorizable_simd_clone_call (gimple *stmt, gimple_stmt_iterator *gsi,\n   if (slp_node)\n     return true;\n \n+  gimple *new_stmt;\n   if (scalar_dest)\n     {\n       type = TREE_TYPE (scalar_dest);\n@@ -4465,7 +4483,6 @@ vect_create_vectorized_demotion_stmts (vec<tree> *vec_oprnds,\n {\n   unsigned int i;\n   tree vop0, vop1, new_tmp, vec_dest;\n-  gimple *new_stmt;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n \n   vec_dest = vec_dsts.pop ();\n@@ -4475,10 +4492,11 @@ vect_create_vectorized_demotion_stmts (vec<tree> *vec_oprnds,\n       /* Create demotion operation.  */\n       vop0 = (*vec_oprnds)[i];\n       vop1 = (*vec_oprnds)[i + 1];\n-      new_stmt = gimple_build_assign (vec_dest, code, vop0, vop1);\n+      gassign *new_stmt = gimple_build_assign (vec_dest, code, vop0, vop1);\n       new_tmp = make_ssa_name (vec_dest, new_stmt);\n       gimple_assign_set_lhs (new_stmt, new_tmp);\n-      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+      stmt_vec_info new_stmt_info\n+\t= vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \n       if (multi_step_cvt)\n \t/* Store the resulting vector for next recursive call.  */\n@@ -4489,15 +4507,15 @@ vect_create_vectorized_demotion_stmts (vec<tree> *vec_oprnds,\n \t     vectors in SLP_NODE or in vector info of the scalar statement\n \t     (or in STMT_VINFO_RELATED_STMT chain).  */\n \t  if (slp_node)\n-\t    SLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt);\n+\t    SLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt_info);\n \t  else\n \t    {\n \t      if (!*prev_stmt_info)\n-\t\tSTMT_VINFO_VEC_STMT (stmt_info) = new_stmt;\n+\t\tSTMT_VINFO_VEC_STMT (stmt_info) = new_stmt_info;\n \t      else\n-\t\tSTMT_VINFO_RELATED_STMT (*prev_stmt_info) = new_stmt;\n+\t\tSTMT_VINFO_RELATED_STMT (*prev_stmt_info) = new_stmt_info;\n \n-\t      *prev_stmt_info = vinfo_for_stmt (new_stmt);\n+\t      *prev_stmt_info = new_stmt_info;\n \t    }\n \t}\n     }\n@@ -4595,7 +4613,6 @@ vectorizable_conversion (gimple *stmt, gimple_stmt_iterator *gsi,\n   tree new_temp;\n   enum vect_def_type dt[2] = {vect_unknown_def_type, vect_unknown_def_type};\n   int ndts = 2;\n-  gimple *new_stmt = NULL;\n   stmt_vec_info prev_stmt_info;\n   poly_uint64 nunits_in;\n   poly_uint64 nunits_out;\n@@ -4965,31 +4982,37 @@ vectorizable_conversion (gimple *stmt, gimple_stmt_iterator *gsi,\n \n \t  FOR_EACH_VEC_ELT (vec_oprnds0, i, vop0)\n \t    {\n+\t      stmt_vec_info new_stmt_info;\n \t      /* Arguments are ready, create the new vector stmt.  */\n \t      if (code1 == CALL_EXPR)\n \t\t{\n-\t\t  new_stmt = gimple_build_call (decl1, 1, vop0);\n+\t\t  gcall *new_stmt = gimple_build_call (decl1, 1, vop0);\n \t\t  new_temp = make_ssa_name (vec_dest, new_stmt);\n \t\t  gimple_call_set_lhs (new_stmt, new_temp);\n+\t\t  new_stmt_info\n+\t\t    = vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t\t}\n \t      else\n \t\t{\n \t\t  gcc_assert (TREE_CODE_LENGTH (code1) == unary_op);\n-\t\t  new_stmt = gimple_build_assign (vec_dest, code1, vop0);\n+\t\t  gassign *new_stmt\n+\t\t    = gimple_build_assign (vec_dest, code1, vop0);\n \t\t  new_temp = make_ssa_name (vec_dest, new_stmt);\n \t\t  gimple_assign_set_lhs (new_stmt, new_temp);\n+\t\t  new_stmt_info\n+\t\t    = vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t\t}\n \n-\t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t      if (slp_node)\n-\t\tSLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt);\n+\t\tSLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt_info);\n \t      else\n \t\t{\n \t\t  if (!prev_stmt_info)\n-\t\t    STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n+\t\t    STMT_VINFO_VEC_STMT (stmt_info)\n+\t\t      = *vec_stmt = new_stmt_info;\n \t\t  else\n-\t\t    STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n-\t\t  prev_stmt_info = vinfo_for_stmt (new_stmt);\n+\t\t    STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt_info;\n+\t\t  prev_stmt_info = new_stmt_info;\n \t\t}\n \t    }\n \t}\n@@ -5075,36 +5098,39 @@ vectorizable_conversion (gimple *stmt, gimple_stmt_iterator *gsi,\n \n \t  FOR_EACH_VEC_ELT (vec_oprnds0, i, vop0)\n \t    {\n+\t      stmt_vec_info new_stmt_info;\n \t      if (cvt_type)\n \t\t{\n \t\t  if (codecvt1 == CALL_EXPR)\n \t\t    {\n-\t\t      new_stmt = gimple_build_call (decl1, 1, vop0);\n+\t\t      gcall *new_stmt = gimple_build_call (decl1, 1, vop0);\n \t\t      new_temp = make_ssa_name (vec_dest, new_stmt);\n \t\t      gimple_call_set_lhs (new_stmt, new_temp);\n+\t\t      new_stmt_info\n+\t\t\t= vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t\t    }\n \t\t  else\n \t\t    {\n \t\t      gcc_assert (TREE_CODE_LENGTH (codecvt1) == unary_op);\n \t\t      new_temp = make_ssa_name (vec_dest);\n-\t\t      new_stmt = gimple_build_assign (new_temp, codecvt1,\n-\t\t\t\t\t\t      vop0);\n+\t\t      gassign *new_stmt\n+\t\t\t= gimple_build_assign (new_temp, codecvt1, vop0);\n+\t\t      new_stmt_info\n+\t\t\t= vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t\t    }\n-\n-\t\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t\t}\n \t      else\n-\t\tnew_stmt = SSA_NAME_DEF_STMT (vop0);\n+\t\tnew_stmt_info = vinfo->lookup_def (vop0);\n \n \t      if (slp_node)\n-\t\tSLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt);\n+\t\tSLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt_info);\n \t      else\n \t\t{\n \t\t  if (!prev_stmt_info)\n-\t\t    STMT_VINFO_VEC_STMT (stmt_info) = new_stmt;\n+\t\t    STMT_VINFO_VEC_STMT (stmt_info) = new_stmt_info;\n \t\t  else\n-\t\t    STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n-\t\t  prev_stmt_info = vinfo_for_stmt (new_stmt);\n+\t\t    STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt_info;\n+\t\t  prev_stmt_info = new_stmt_info;\n \t\t}\n \t    }\n \t}\n@@ -5136,19 +5162,20 @@ vectorizable_conversion (gimple *stmt, gimple_stmt_iterator *gsi,\n \t      {\n \t\tif (codecvt1 == CALL_EXPR)\n \t\t  {\n-\t\t    new_stmt = gimple_build_call (decl1, 1, vop0);\n+\t\t    gcall *new_stmt = gimple_build_call (decl1, 1, vop0);\n \t\t    new_temp = make_ssa_name (vec_dest, new_stmt);\n \t\t    gimple_call_set_lhs (new_stmt, new_temp);\n+\t\t    vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t\t  }\n \t\telse\n \t\t  {\n \t\t    gcc_assert (TREE_CODE_LENGTH (codecvt1) == unary_op);\n \t\t    new_temp = make_ssa_name (vec_dest);\n-\t\t    new_stmt = gimple_build_assign (new_temp, codecvt1,\n-\t\t\t\t\t\t    vop0);\n+\t\t    gassign *new_stmt\n+\t\t      = gimple_build_assign (new_temp, codecvt1, vop0);\n+\t\t    vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t\t  }\n \n-\t\tvect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t\tvec_oprnds0[i] = new_temp;\n \t      }\n \n@@ -5196,7 +5223,6 @@ vectorizable_assignment (gimple *stmt, gimple_stmt_iterator *gsi,\n   tree vop;\n   bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n   vec_info *vinfo = stmt_info->vinfo;\n-  gimple *new_stmt = NULL;\n   stmt_vec_info prev_stmt_info = NULL;\n   enum tree_code code;\n   tree vectype_in;\n@@ -5306,28 +5332,29 @@ vectorizable_assignment (gimple *stmt, gimple_stmt_iterator *gsi,\n         vect_get_vec_defs_for_stmt_copy (dt, &vec_oprnds, NULL);\n \n       /* Arguments are ready. create the new vector stmt.  */\n+      stmt_vec_info new_stmt_info = NULL;\n       FOR_EACH_VEC_ELT (vec_oprnds, i, vop)\n        {\n \t if (CONVERT_EXPR_CODE_P (code)\n \t     || code == VIEW_CONVERT_EXPR)\n \t   vop = build1 (VIEW_CONVERT_EXPR, vectype, vop);\n-         new_stmt = gimple_build_assign (vec_dest, vop);\n+\t gassign *new_stmt = gimple_build_assign (vec_dest, vop);\n          new_temp = make_ssa_name (vec_dest, new_stmt);\n          gimple_assign_set_lhs (new_stmt, new_temp);\n-         vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t new_stmt_info = vect_finish_stmt_generation (stmt, new_stmt, gsi);\n          if (slp_node)\n-           SLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt);\n+\t   SLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt_info);\n        }\n \n       if (slp_node)\n         continue;\n \n       if (j == 0)\n-        STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n+\tSTMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt_info;\n       else\n-        STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n+\tSTMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt_info;\n \n-      prev_stmt_info = vinfo_for_stmt (new_stmt);\n+      prev_stmt_info = new_stmt_info;\n     }\n \n   vec_oprnds.release ();\n@@ -5398,7 +5425,6 @@ vectorizable_shift (gimple *stmt, gimple_stmt_iterator *gsi,\n   machine_mode optab_op2_mode;\n   enum vect_def_type dt[2] = {vect_unknown_def_type, vect_unknown_def_type};\n   int ndts = 2;\n-  gimple *new_stmt = NULL;\n   stmt_vec_info prev_stmt_info;\n   poly_uint64 nunits_in;\n   poly_uint64 nunits_out;\n@@ -5706,25 +5732,26 @@ vectorizable_shift (gimple *stmt, gimple_stmt_iterator *gsi,\n         vect_get_vec_defs_for_stmt_copy (dt, &vec_oprnds0, &vec_oprnds1);\n \n       /* Arguments are ready.  Create the new vector stmt.  */\n+      stmt_vec_info new_stmt_info = NULL;\n       FOR_EACH_VEC_ELT (vec_oprnds0, i, vop0)\n         {\n           vop1 = vec_oprnds1[i];\n-\t  new_stmt = gimple_build_assign (vec_dest, code, vop0, vop1);\n+\t  gassign *new_stmt = gimple_build_assign (vec_dest, code, vop0, vop1);\n           new_temp = make_ssa_name (vec_dest, new_stmt);\n           gimple_assign_set_lhs (new_stmt, new_temp);\n-          vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t  new_stmt_info = vect_finish_stmt_generation (stmt, new_stmt, gsi);\n           if (slp_node)\n-            SLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt);\n+\t    SLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt_info);\n         }\n \n       if (slp_node)\n         continue;\n \n       if (j == 0)\n-        STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n+\tSTMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt_info;\n       else\n-        STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n-      prev_stmt_info = vinfo_for_stmt (new_stmt);\n+\tSTMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt_info;\n+      prev_stmt_info = new_stmt_info;\n     }\n \n   vec_oprnds0.release ();\n@@ -5762,7 +5789,6 @@ vectorizable_operation (gimple *stmt, gimple_stmt_iterator *gsi,\n   enum vect_def_type dt[3]\n     = {vect_unknown_def_type, vect_unknown_def_type, vect_unknown_def_type};\n   int ndts = 3;\n-  gimple *new_stmt = NULL;\n   stmt_vec_info prev_stmt_info;\n   poly_uint64 nunits_in;\n   poly_uint64 nunits_out;\n@@ -6090,37 +6116,41 @@ vectorizable_operation (gimple *stmt, gimple_stmt_iterator *gsi,\n \t}\n \n       /* Arguments are ready.  Create the new vector stmt.  */\n+      stmt_vec_info new_stmt_info = NULL;\n       FOR_EACH_VEC_ELT (vec_oprnds0, i, vop0)\n         {\n \t  vop1 = ((op_type == binary_op || op_type == ternary_op)\n \t\t  ? vec_oprnds1[i] : NULL_TREE);\n \t  vop2 = ((op_type == ternary_op)\n \t\t  ? vec_oprnds2[i] : NULL_TREE);\n-\t  new_stmt = gimple_build_assign (vec_dest, code, vop0, vop1, vop2);\n+\t  gassign *new_stmt = gimple_build_assign (vec_dest, code,\n+\t\t\t\t\t\t   vop0, vop1, vop2);\n \t  new_temp = make_ssa_name (vec_dest, new_stmt);\n \t  gimple_assign_set_lhs (new_stmt, new_temp);\n-\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t  new_stmt_info = vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t  if (vec_cvt_dest)\n \t    {\n \t      new_temp = build1 (VIEW_CONVERT_EXPR, vectype_out, new_temp);\n-\t      new_stmt = gimple_build_assign (vec_cvt_dest, VIEW_CONVERT_EXPR,\n-\t\t\t\t\t      new_temp);\n+\t      gassign *new_stmt\n+\t\t= gimple_build_assign (vec_cvt_dest, VIEW_CONVERT_EXPR,\n+\t\t\t\t       new_temp);\n \t      new_temp = make_ssa_name (vec_cvt_dest, new_stmt);\n \t      gimple_assign_set_lhs (new_stmt, new_temp);\n-\t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t      new_stmt_info\n+\t\t= vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t    }\n           if (slp_node)\n-\t    SLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt);\n+\t    SLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt_info);\n         }\n \n       if (slp_node)\n         continue;\n \n       if (j == 0)\n-\tSTMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n+\tSTMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt_info;\n       else\n-\tSTMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n-      prev_stmt_info = vinfo_for_stmt (new_stmt);\n+\tSTMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt_info;\n+      prev_stmt_info = new_stmt_info;\n     }\n \n   vec_oprnds0.release ();\n@@ -6230,7 +6260,6 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n   vec_info *vinfo = stmt_info->vinfo;\n   tree aggr_type;\n   gather_scatter_info gs_info;\n-  gimple *new_stmt;\n   poly_uint64 vf;\n   vec_load_store_type vls_type;\n   tree ref_type;\n@@ -6520,7 +6549,8 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t\t\t    TYPE_VECTOR_SUBPARTS (srctype)));\n \t      var = vect_get_new_ssa_name (srctype, vect_simple_var);\n \t      src = build1 (VIEW_CONVERT_EXPR, srctype, src);\n-\t      new_stmt = gimple_build_assign (var, VIEW_CONVERT_EXPR, src);\n+\t      gassign *new_stmt\n+\t\t= gimple_build_assign (var, VIEW_CONVERT_EXPR, src);\n \t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t      src = var;\n \t    }\n@@ -6531,21 +6561,22 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t\t\t    TYPE_VECTOR_SUBPARTS (idxtype)));\n \t      var = vect_get_new_ssa_name (idxtype, vect_simple_var);\n \t      op = build1 (VIEW_CONVERT_EXPR, idxtype, op);\n-\t      new_stmt = gimple_build_assign (var, VIEW_CONVERT_EXPR, op);\n+\t      gassign *new_stmt\n+\t\t= gimple_build_assign (var, VIEW_CONVERT_EXPR, op);\n \t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t      op = var;\n \t    }\n \n-\t  new_stmt\n+\t  gcall *new_stmt\n \t    = gimple_build_call (gs_info.decl, 5, ptr, mask, op, src, scale);\n-\n-\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t  stmt_vec_info new_stmt_info\n+\t    = vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \n \t  if (prev_stmt_info == NULL_STMT_VEC_INFO)\n-\t    STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n+\t    STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt_info;\n \t  else\n-\t    STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n-\t  prev_stmt_info = vinfo_for_stmt (new_stmt);\n+\t    STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt_info;\n+\t  prev_stmt_info = new_stmt_info;\n \t}\n       return true;\n     }\n@@ -6806,7 +6837,8 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \n \t\t  /* And store it to *running_off.  */\n \t\t  assign = gimple_build_assign (newref, elem);\n-\t\t  vect_finish_stmt_generation (stmt, assign, gsi);\n+\t\t  stmt_vec_info assign_info\n+\t\t    = vect_finish_stmt_generation (stmt, assign, gsi);\n \n \t\t  group_el += lnel;\n \t\t  if (! slp\n@@ -6825,10 +6857,10 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t    {\n \t\t      if (j == 0 && i == 0)\n \t\t\tSTMT_VINFO_VEC_STMT (stmt_info)\n-\t\t\t    = *vec_stmt = assign;\n+\t\t\t    = *vec_stmt = assign_info;\n \t\t      else\n-\t\t\tSTMT_VINFO_RELATED_STMT (prev_stmt_info) = assign;\n-\t\t      prev_stmt_info = vinfo_for_stmt (assign);\n+\t\t\tSTMT_VINFO_RELATED_STMT (prev_stmt_info) = assign_info;\n+\t\t      prev_stmt_info = assign_info;\n \t\t    }\n \t\t}\n \t    }\n@@ -6931,7 +6963,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n   tree vec_mask = NULL_TREE;\n   for (j = 0; j < ncopies; j++)\n     {\n-\n+      stmt_vec_info new_stmt_info;\n       if (j == 0)\n \t{\n           if (slp)\n@@ -7081,15 +7113,14 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t      gimple_call_set_lhs (call, data_ref);\n \t    }\n \t  gimple_call_set_nothrow (call, true);\n-\t  new_stmt = call;\n-\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t  new_stmt_info = vect_finish_stmt_generation (stmt, call, gsi);\n \n \t  /* Record that VEC_ARRAY is now dead.  */\n \t  vect_clobber_variable (stmt, gsi, vec_array);\n \t}\n       else\n \t{\n-\t  new_stmt = NULL;\n+\t  new_stmt_info = NULL;\n \t  if (grouped_store)\n \t    {\n \t      if (j == 0)\n@@ -7126,8 +7157,8 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t      (IFN_SCATTER_STORE, 4, dataref_ptr, vec_offset,\n \t\t       scale, vec_oprnd);\n \t\t  gimple_call_set_nothrow (call, true);\n-\t\t  new_stmt = call;\n-\t\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t\t  new_stmt_info\n+\t\t    = vect_finish_stmt_generation (stmt, call, gsi);\n \t\t  break;\n \t\t}\n \n@@ -7186,7 +7217,8 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t\t\t\t\t  dataref_ptr, ptr,\n \t\t\t\t\t\t  final_mask, vec_oprnd);\n \t\t  gimple_call_set_nothrow (call, true);\n-\t\t  new_stmt = call;\n+\t\t  new_stmt_info\n+\t\t    = vect_finish_stmt_generation (stmt, call, gsi);\n \t\t}\n \t      else\n \t\t{\n@@ -7206,9 +7238,11 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t      = build_aligned_type (TREE_TYPE (data_ref),\n \t\t\t\t\t    TYPE_ALIGN (elem_type));\n \t\t  vect_copy_ref_info (data_ref, DR_REF (first_dr));\n-\t\t  new_stmt = gimple_build_assign (data_ref, vec_oprnd);\n+\t\t  gassign *new_stmt\n+\t\t    = gimple_build_assign (data_ref, vec_oprnd);\n+\t\t  new_stmt_info\n+\t\t    = vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t\t}\n-\t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \n \t      if (slp)\n \t\tcontinue;\n@@ -7221,10 +7255,10 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n       if (!slp)\n \t{\n \t  if (j == 0)\n-\t    STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n+\t    STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt_info;\n \t  else\n-\t    STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n-\t  prev_stmt_info = vinfo_for_stmt (new_stmt);\n+\t    STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt_info;\n+\t  prev_stmt_info = new_stmt_info;\n \t}\n     }\n \n@@ -7370,7 +7404,6 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n   tree elem_type;\n   tree new_temp;\n   machine_mode mode;\n-  gimple *new_stmt = NULL;\n   tree dummy;\n   enum dr_alignment_support alignment_support_scheme;\n   tree dataref_ptr = NULL_TREE;\n@@ -7812,14 +7845,17 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t{\n \t  if (nloads > 1)\n \t    vec_alloc (v, nloads);\n+\t  stmt_vec_info new_stmt_info = NULL;\n \t  for (i = 0; i < nloads; i++)\n \t    {\n \t      tree this_off = build_int_cst (TREE_TYPE (alias_off),\n \t\t\t\t\t     group_el * elsz + cst_offset);\n \t      tree data_ref = build2 (MEM_REF, ltype, running_off, this_off);\n \t      vect_copy_ref_info (data_ref, DR_REF (first_dr));\n-\t      new_stmt = gimple_build_assign (make_ssa_name (ltype), data_ref);\n-\t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t      gassign *new_stmt\n+\t\t= gimple_build_assign (make_ssa_name (ltype), data_ref);\n+\t      new_stmt_info\n+\t\t= vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t      if (nloads > 1)\n \t\tCONSTRUCTOR_APPEND_ELT (v, NULL_TREE,\n \t\t\t\t\tgimple_assign_lhs (new_stmt));\n@@ -7841,31 +7877,33 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t    {\n \t      tree vec_inv = build_constructor (lvectype, v);\n \t      new_temp = vect_init_vector (stmt, vec_inv, lvectype, gsi);\n-\t      new_stmt = SSA_NAME_DEF_STMT (new_temp);\n+\t      new_stmt_info = vinfo->lookup_def (new_temp);\n \t      if (lvectype != vectype)\n \t\t{\n-\t\t  new_stmt = gimple_build_assign (make_ssa_name (vectype),\n-\t\t\t\t\t\t  VIEW_CONVERT_EXPR,\n-\t\t\t\t\t\t  build1 (VIEW_CONVERT_EXPR,\n-\t\t\t\t\t\t\t  vectype, new_temp));\n-\t\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t\t  gassign *new_stmt\n+\t\t    = gimple_build_assign (make_ssa_name (vectype),\n+\t\t\t\t\t   VIEW_CONVERT_EXPR,\n+\t\t\t\t\t   build1 (VIEW_CONVERT_EXPR,\n+\t\t\t\t\t\t   vectype, new_temp));\n+\t\t  new_stmt_info\n+\t\t    = vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t\t}\n \t    }\n \n \t  if (slp)\n \t    {\n \t      if (slp_perm)\n-\t\tdr_chain.quick_push (gimple_assign_lhs (new_stmt));\n+\t\tdr_chain.quick_push (gimple_assign_lhs (new_stmt_info->stmt));\n \t      else\n-\t\tSLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt);\n+\t\tSLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt_info);\n \t    }\n \t  else\n \t    {\n \t      if (j == 0)\n-\t\tSTMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n+\t\tSTMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt_info;\n \t      else\n-\t\tSTMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n-\t      prev_stmt_info = vinfo_for_stmt (new_stmt);\n+\t\tSTMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt_info;\n+\t      prev_stmt_info = new_stmt_info;\n \t    }\n \t}\n       if (slp_perm)\n@@ -8122,6 +8160,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n   poly_uint64 group_elt = 0;\n   for (j = 0; j < ncopies; j++)\n     {\n+      stmt_vec_info new_stmt_info = NULL;\n       /* 1. Create the vector or array pointer update chain.  */\n       if (j == 0)\n \t{\n@@ -8228,8 +8267,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t    }\n \t  gimple_call_set_lhs (call, vec_array);\n \t  gimple_call_set_nothrow (call, true);\n-\t  new_stmt = call;\n-\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t  new_stmt_info = vect_finish_stmt_generation (stmt, call, gsi);\n \n \t  /* Extract each vector into an SSA_NAME.  */\n \t  for (i = 0; i < vec_num; i++)\n@@ -8264,6 +8302,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t\t\t\t       stmt, bump);\n \n \t      /* 2. Create the vector-load in the loop.  */\n+\t      gimple *new_stmt = NULL;\n \t      switch (alignment_support_scheme)\n \t\t{\n \t\tcase dr_aligned:\n@@ -8421,7 +8460,8 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t}\n \t      new_temp = make_ssa_name (vec_dest, new_stmt);\n \t      gimple_set_lhs (new_stmt, new_temp);\n-\t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t      new_stmt_info\n+\t\t= vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \n \t      /* 3. Handle explicit realignment if necessary/supported.\n \t\t Create in loop:\n@@ -8437,7 +8477,8 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t\t\t\t\t  msq, lsq, realignment_token);\n \t\t  new_temp = make_ssa_name (vec_dest, new_stmt);\n \t\t  gimple_assign_set_lhs (new_stmt, new_temp);\n-\t\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t\t  new_stmt_info\n+\t\t    = vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \n \t\t  if (alignment_support_scheme == dr_explicit_realign_optimized)\n \t\t    {\n@@ -8477,15 +8518,15 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t\t\t\t        (gimple_assign_rhs1 (stmt))));\n \t\t      new_temp = vect_init_vector (stmt, tem, vectype, NULL);\n \t\t      new_stmt = SSA_NAME_DEF_STMT (new_temp);\n-\t\t      vinfo->add_stmt (new_stmt);\n+\t\t      new_stmt_info = vinfo->add_stmt (new_stmt);\n \t\t    }\n \t\t  else\n \t\t    {\n \t\t      gimple_stmt_iterator gsi2 = *gsi;\n \t\t      gsi_next (&gsi2);\n \t\t      new_temp = vect_init_vector (stmt, scalar_dest,\n \t\t\t\t\t\t   vectype, &gsi2);\n-\t\t      new_stmt = SSA_NAME_DEF_STMT (new_temp);\n+\t\t      new_stmt_info = vinfo->lookup_def (new_temp);\n \t\t    }\n \t\t}\n \n@@ -8494,7 +8535,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t  tree perm_mask = perm_mask_for_reverse (vectype);\n \t\t  new_temp = permute_vec_elements (new_temp, new_temp,\n \t\t\t\t\t\t   perm_mask, stmt, gsi);\n-\t\t  new_stmt = SSA_NAME_DEF_STMT (new_temp);\n+\t\t  new_stmt_info = vinfo->lookup_def (new_temp);\n \t\t}\n \n \t      /* Collect vector loads and later create their permutation in\n@@ -8504,7 +8545,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \n \t      /* Store vector loads in the corresponding SLP_NODE.  */\n \t      if (slp && !slp_perm)\n-\t\tSLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt);\n+\t\tSLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt_info);\n \n \t      /* With SLP permutation we load the gaps as well, without\n \t         we need to skip the gaps after we manage to fully load\n@@ -8561,10 +8602,10 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n           else\n \t    {\n \t      if (j == 0)\n-\t        STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n+\t        STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt_info;\n \t      else\n-\t        STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n-\t      prev_stmt_info = vinfo_for_stmt (new_stmt);\n+\t        STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt_info;\n+\t      prev_stmt_info = new_stmt_info;\n \t    }\n         }\n       dr_chain.release ();\n@@ -8869,7 +8910,7 @@ vectorizable_condition (gimple *stmt, gimple_stmt_iterator *gsi,\n   /* Handle cond expr.  */\n   for (j = 0; j < ncopies; j++)\n     {\n-      gimple *new_stmt = NULL;\n+      stmt_vec_info new_stmt_info = NULL;\n       if (j == 0)\n \t{\n           if (slp_node)\n@@ -8974,6 +9015,7 @@ vectorizable_condition (gimple *stmt, gimple_stmt_iterator *gsi,\n \t      else\n \t\t{\n \t\t  new_temp = make_ssa_name (vec_cmp_type);\n+\t\t  gassign *new_stmt;\n \t\t  if (bitop1 == BIT_NOT_EXPR)\n \t\t    new_stmt = gimple_build_assign (new_temp, bitop1,\n \t\t\t\t\t\t    vec_cond_rhs);\n@@ -9005,50 +9047,52 @@ vectorizable_condition (gimple *stmt, gimple_stmt_iterator *gsi,\n \t      if (!is_gimple_val (vec_compare))\n \t\t{\n \t\t  tree vec_compare_name = make_ssa_name (vec_cmp_type);\n-\t\t  new_stmt = gimple_build_assign (vec_compare_name,\n-\t\t\t\t\t\t  vec_compare);\n+\t\t  gassign *new_stmt = gimple_build_assign (vec_compare_name,\n+\t\t\t\t\t\t\t   vec_compare);\n \t\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t\t  vec_compare = vec_compare_name;\n \t\t}\n \t      gcc_assert (reduc_index == 2);\n-\t      new_stmt = gimple_build_call_internal\n+\t      gcall *new_stmt = gimple_build_call_internal\n \t\t(IFN_FOLD_EXTRACT_LAST, 3, else_clause, vec_compare,\n \t\t vec_then_clause);\n \t      gimple_call_set_lhs (new_stmt, scalar_dest);\n \t      SSA_NAME_DEF_STMT (scalar_dest) = new_stmt;\n \t      if (stmt == gsi_stmt (*gsi))\n-\t\tvect_finish_replace_stmt (stmt, new_stmt);\n+\t\tnew_stmt_info = vect_finish_replace_stmt (stmt, new_stmt);\n \t      else\n \t\t{\n \t\t  /* In this case we're moving the definition to later in the\n \t\t     block.  That doesn't matter because the only uses of the\n \t\t     lhs are in phi statements.  */\n \t\t  gimple_stmt_iterator old_gsi = gsi_for_stmt (stmt);\n \t\t  gsi_remove (&old_gsi, true);\n-\t\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t\t  new_stmt_info\n+\t\t    = vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t\t}\n \t    }\n \t  else\n \t    {\n \t      new_temp = make_ssa_name (vec_dest);\n-\t      new_stmt = gimple_build_assign (new_temp, VEC_COND_EXPR,\n-\t\t\t\t\t      vec_compare, vec_then_clause,\n-\t\t\t\t\t      vec_else_clause);\n-\t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t      gassign *new_stmt\n+\t\t= gimple_build_assign (new_temp, VEC_COND_EXPR, vec_compare,\n+\t\t\t\t       vec_then_clause, vec_else_clause);\n+\t      new_stmt_info\n+\t\t= vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t    }\n           if (slp_node)\n-            SLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt);\n+\t    SLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt_info);\n         }\n \n         if (slp_node)\n           continue;\n \n-        if (j == 0)\n-          STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n-        else\n-          STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n+\tif (j == 0)\n+\t  STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt_info;\n+\telse\n+\t  STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt_info;\n \n-        prev_stmt_info = vinfo_for_stmt (new_stmt);\n+\tprev_stmt_info = new_stmt_info;\n     }\n \n   vec_oprnds0.release ();\n@@ -9244,7 +9288,7 @@ vectorizable_comparison (gimple *stmt, gimple_stmt_iterator *gsi,\n   /* Handle cmp expr.  */\n   for (j = 0; j < ncopies; j++)\n     {\n-      gassign *new_stmt = NULL;\n+      stmt_vec_info new_stmt_info = NULL;\n       if (j == 0)\n \t{\n \t  if (slp_node)\n@@ -9286,18 +9330,21 @@ vectorizable_comparison (gimple *stmt, gimple_stmt_iterator *gsi,\n \t  new_temp = make_ssa_name (mask);\n \t  if (bitop1 == NOP_EXPR)\n \t    {\n-\t      new_stmt = gimple_build_assign (new_temp, code,\n-\t\t\t\t\t      vec_rhs1, vec_rhs2);\n-\t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t      gassign *new_stmt = gimple_build_assign (new_temp, code,\n+\t\t\t\t\t\t       vec_rhs1, vec_rhs2);\n+\t      new_stmt_info\n+\t\t= vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t    }\n \t  else\n \t    {\n+\t      gassign *new_stmt;\n \t      if (bitop1 == BIT_NOT_EXPR)\n \t\tnew_stmt = gimple_build_assign (new_temp, bitop1, vec_rhs2);\n \t      else\n \t\tnew_stmt = gimple_build_assign (new_temp, bitop1, vec_rhs1,\n \t\t\t\t\t\tvec_rhs2);\n-\t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t      new_stmt_info\n+\t\t= vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t      if (bitop2 != NOP_EXPR)\n \t\t{\n \t\t  tree res = make_ssa_name (mask);\n@@ -9306,22 +9353,23 @@ vectorizable_comparison (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t  else\n \t\t    new_stmt = gimple_build_assign (res, bitop2, vec_rhs1,\n \t\t\t\t\t\t    new_temp);\n-\t\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t\t  new_stmt_info\n+\t\t    = vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t\t}\n \t    }\n \t  if (slp_node)\n-\t    SLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt);\n+\t    SLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt_info);\n \t}\n \n       if (slp_node)\n \tcontinue;\n \n       if (j == 0)\n-\tSTMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n+\tSTMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt_info;\n       else\n-\tSTMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n+\tSTMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt_info;\n \n-      prev_stmt_info = vinfo_for_stmt (new_stmt);\n+      prev_stmt_info = new_stmt_info;\n     }\n \n   vec_oprnds0.release ();"}, {"sha": "4109cd9d73a5398fbd7e97be56628c236016feb9", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1bd72966309ac459a55e2bc64ad355272d402f5/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1bd72966309ac459a55e2bc64ad355272d402f5/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=e1bd72966309ac459a55e2bc64ad355272d402f5", "patch": "@@ -1548,9 +1548,9 @@ extern void free_stmt_vec_info (gimple *stmt);\n extern unsigned record_stmt_cost (stmt_vector_for_cost *, int,\n \t\t\t\t  enum vect_cost_for_stmt, stmt_vec_info,\n \t\t\t\t  int, enum vect_cost_model_location);\n-extern void vect_finish_replace_stmt (gimple *, gimple *);\n-extern void vect_finish_stmt_generation (gimple *, gimple *,\n-                                         gimple_stmt_iterator *);\n+extern stmt_vec_info vect_finish_replace_stmt (gimple *, gimple *);\n+extern stmt_vec_info vect_finish_stmt_generation (gimple *, gimple *,\n+\t\t\t\t\t\t  gimple_stmt_iterator *);\n extern bool vect_mark_stmts_to_be_vectorized (loop_vec_info);\n extern tree vect_get_store_rhs (gimple *);\n extern tree vect_get_vec_def_for_operand_1 (gimple *, enum vect_def_type);"}]}