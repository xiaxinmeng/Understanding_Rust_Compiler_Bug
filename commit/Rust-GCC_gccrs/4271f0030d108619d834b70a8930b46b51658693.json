{"sha": "4271f0030d108619d834b70a8930b46b51658693", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDI3MWYwMDMwZDEwODYxOWQ4MzRiNzBhODkzMGI0NmI1MTY1ODY5Mw==", "commit": {"author": {"name": "Michael Hayes", "email": "m.hayes@elec.canterbury.ac.nz", "date": "1998-11-25T19:59:39Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "1998-11-25T19:59:39Z"}, "message": "c4x.c: (c4x_override_options): For compatibility with old target options clear...\n\n\t* config/c4x/c4x.c: (c4x_override_options): For compatibility\n\twith old target options clear flag_branch_on_count_reg if\n\t-mno-rptb specified and set flag_argument_alias is -mno-aliases\n\tspecified.\n\t(c4x_output_cbranch): Handle a sequence of insns rather than a\n \tsingle insn.\n\t(c4x_rptb_insert): Do not emit a RPTB insn if the RC register\n\thas not been allocated as the loop counter.\n\t(c4x_address_conflict): Do not allow two volatile memory references.\n\t(valid_parallel_operands_4, valid_parallel_operands_5,\n \tvalid_parallel_operands_6): Reject pattern if the register destination\n\tof the first set is used as part of an address in the second set.\n\nFrom-SVN: r23879", "tree": {"sha": "a4ef8a956d69da307dc14b0d450d2ef3a6b34427", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a4ef8a956d69da307dc14b0d450d2ef3a6b34427"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4271f0030d108619d834b70a8930b46b51658693", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4271f0030d108619d834b70a8930b46b51658693", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4271f0030d108619d834b70a8930b46b51658693", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4271f0030d108619d834b70a8930b46b51658693/comments", "author": null, "committer": null, "parents": [{"sha": "0fe69abaa1b8062525cc6a061d266fef560bf995", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fe69abaa1b8062525cc6a061d266fef560bf995", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fe69abaa1b8062525cc6a061d266fef560bf995"}], "stats": {"total": 148, "additions": 93, "deletions": 55}, "files": [{"sha": "f53c400a5cd4a948d3241dab9115a5c314c54bc6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4271f0030d108619d834b70a8930b46b51658693/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4271f0030d108619d834b70a8930b46b51658693/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4271f0030d108619d834b70a8930b46b51658693", "patch": "@@ -16,9 +16,12 @@ Thu Nov 26 15:16:05 1998  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n \tspecified.\n \t(c4x_output_cbranch): Handle a sequence of insns rather than a\n  \tsingle insn.\n-\t(c4x_rptb_insert): Don not emit a RPTB insn if the RC register\n+\t(c4x_rptb_insert): Do not emit a RPTB insn if the RC register\n \thas not been allocated as the loop counter.\n-\t(c4x_address_conflict): \n+\t(c4x_address_conflict): Do not allow two volatile memory references.\n+\t(valid_parallel_operands_4, valid_parallel_operands_5,\n+ \tvalid_parallel_operands_6): Reject pattern if the register destination\n+\tof the first set is used as part of an address in the second set.\n \t\n \n Thu Nov 26 14:56:32 1998  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>"}, {"sha": "b7b02c49f1bd3b373218f8c6dae3b2bc3fbdd4b3", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 88, "deletions": 53, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4271f0030d108619d834b70a8930b46b51658693/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4271f0030d108619d834b70a8930b46b51658693/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=4271f0030d108619d834b70a8930b46b51658693", "patch": "@@ -159,9 +159,6 @@ tree interrupt_tree = NULL_TREE;\n void\n c4x_override_options ()\n {\n-  /* Convert foo / 8.0 into foo * 0.125, etc.  */\n-  flag_fast_math = 1;\n-\n   if (c4x_rpts_cycles_string)\n     c4x_rpts_cycles = atoi (c4x_rpts_cycles_string);\n   else\n@@ -204,16 +201,29 @@ c4x_override_options ()\n   else\n     target_flags &= ~C3X_FLAG;\n \n+  /* Convert foo / 8.0 into foo * 0.125, etc.  */\n+  flag_fast_math = 1;\n+\n+  /* We should phase out the following at some stage.\n+     This provides compatibility with the old -mno-rptb option.  */\n+  if (!TARGET_RPTB && flag_branch_on_count_reg)\n+    flag_branch_on_count_reg = 0;\n+\n+  /* We should phase out the following at some stage.\n+     This provides compatibility with the old -mno-aliases option.  */\n+  if (!TARGET_ALIASES && !flag_argument_noalias)\n+    flag_argument_noalias = 1;\n }\n \n+/* This is called before c4x_override_options.  */\n void\n c4x_optimization_options (level, size)\n      int level;\n      int size ATTRIBUTE_UNUSED;\n {\n   /* When optimizing, enable use of RPTB instruction.  */\n   if (level >= 1)\n-      flag_branch_on_count_reg = 1;\n+    flag_branch_on_count_reg = 1;\n }\n \n /* Write an ASCII string.  */\n@@ -1419,30 +1429,26 @@ c4x_gen_compare_reg (code, x, y)\n }\n \n char *\n-c4x_output_cbranch (reversed, insn)\n-     int reversed;\n-     rtx insn;\n+c4x_output_cbranch (form, seq)\n+     char *form;\n+     rtx seq;\n {\n   int delayed = 0;\n   int annultrue = 0;\n   int annulfalse = 0;\n   rtx delay;\n   char *cp;\n-  static char str[20];\n+  static char str[100];\n   \n   if (final_sequence)\n     {\n       delay = XVECEXP (final_sequence, 0, 1);\n-      delayed = !INSN_ANNULLED_BRANCH_P (insn);\n-      annultrue = INSN_ANNULLED_BRANCH_P (insn) && !INSN_FROM_TARGET_P (delay);\n-      annulfalse = INSN_ANNULLED_BRANCH_P (insn) && INSN_FROM_TARGET_P (delay);\n+      delayed = !INSN_ANNULLED_BRANCH_P (seq);\n+      annultrue = INSN_ANNULLED_BRANCH_P (seq) && !INSN_FROM_TARGET_P (delay);\n+      annulfalse = INSN_ANNULLED_BRANCH_P (seq) && INSN_FROM_TARGET_P (delay);\n     }\n-  cp = str;\n-  *cp++ = 'b';\n-  *cp++ = '%';\n-  if (reversed)\n-    *cp++ = 'I';\n-  *cp++ = '0';\n+  strcpy (str, form);\n+  cp = &str [strlen (str)];\n   if (delayed)\n     {\n       *cp++ = '%';\n@@ -1466,7 +1472,6 @@ c4x_output_cbranch (reversed, insn)\n   return str;\n }\n \n-\n void\n c4x_print_operand (file, op, letter)\n      FILE *file;\t\t/* file to write to */\n@@ -2040,10 +2045,19 @@ c4x_rptb_insert (insn)\n {\n   rtx end_label;\n   rtx start_label;\n-  \n+  rtx count_reg;\n+\n+  /* If the count register has not been allocated to RC, say if\n+     there is a movstr pattern in the loop, then do not insert a\n+     RPTB instruction.  Instead we emit a decrement and branch\n+     at the end of the loop.  */\n+  count_reg = XEXP (XEXP (SET_SRC (XVECEXP (PATTERN (insn), 0, 0)), 0), 0);\n+  if (REGNO (count_reg) != RC_REGNO)\n+    return;\n+\n   /* Extract the start label from the jump pattern (rptb_end).  */\n   start_label = XEXP (XEXP (SET_SRC (XVECEXP (PATTERN (insn), 0, 0)), 1), 0);\n-\n+  \n   /* We'll have to update the basic blocks.  */\n   end_label = gen_label_rtx ();\n   emit_label_after (end_label, insn);\n@@ -3123,6 +3137,9 @@ c4x_address_conflict (op0, op1, store0, store1)\n   int disp0;\n   int disp1;\n   \n+  if (MEM_VOLATILE_P (op0) && MEM_VOLATILE_P (op1))\n+    return 1;\n+\n   c4x_S_address_parse (op0, &base0, &incdec0, &index0, &disp0);\n   c4x_S_address_parse (op1, &base1, &incdec1, &index1, &disp1);\n \n@@ -3137,12 +3154,7 @@ c4x_address_conflict (op0, op1, store0, store1)\n \t have an aliased address if both locations are not marked\n \t volatile, it is probably safer to flag a potential conflict\n \t if either location is volatile.  */\n-      if (!TARGET_ALIASES)\n-\t{\n-\t  if (MEM_VOLATILE_P (op0) && MEM_VOLATILE_P (op1))\n-\t    return 1;\n-\t}\n-      else\n+      if (!flag_argument_alias)\n \t{\n \t  if (MEM_VOLATILE_P (op0) || MEM_VOLATILE_P (op1))\n \t    return 1;\n@@ -3222,6 +3234,14 @@ valid_parallel_operands_4 (operands, mode)\n      par_ind_operand() operands.  Thus of the 4 operands, only 2\n      should be REGs and the other 2 should be MEMs.  */\n \n+  /* This test prevents the multipack pass from using this pattern if\n+     op0 is used as an index or base register in op3, since this combination\n+     will require reloading.  */\n+  if (GET_CODE (op0) == REG\n+      && GET_CODE (op3) == MEM\n+      && reg_mentioned_p (op0, XEXP (op3, 0)))\n+    return 0;\n+\n   /* LDI||LDI  */\n   if (GET_CODE (op0) == REG && GET_CODE (op2) == REG)\n     return (REGNO (op0) != REGNO (op2))\n@@ -3246,6 +3266,7 @@ valid_parallel_operands_4 (operands, mode)\n   return 0;\n }\n \n+\n /* We only use this to check operands 1 and 2 since these may be\n    commutative.  It will need extending for the C32 opcodes.  */\n int\n@@ -3254,23 +3275,36 @@ valid_parallel_operands_5 (operands, mode)\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   int regs = 0;\n-  rtx op0 = operands[1];\n-  rtx op1 = operands[2];\n+  rtx op0 = operands[0];\n+  rtx op1 = operands[1];\n+  rtx op2 = operands[2];\n+  rtx op3 = operands[3];\n \n   if (GET_CODE (op0) == SUBREG)\n     op0 = SUBREG_REG (op0);\n-  if (GET_CODE (op1) == SUBREG)\n-    op1 = SUBREG_REG (op1);\n+  if (GET_CODE (op2) == SUBREG)\n+    op2 = SUBREG_REG (op2);\n \n   /* The patterns should only allow ext_low_reg_operand() or\n      par_ind_operand() operands. */\n \n   if (GET_CODE (op0) == REG)\n     regs++;\n-  if (GET_CODE (op1) == REG)\n+  if (GET_CODE (op2) == REG)\n     regs++;\n \n-  return regs == 1;\n+  if (regs != 1)\n+    return 0;\n+\n+  /* This test prevents the multipack pass from using this pattern if\n+     op0 is used as an index or base register in op3, since this combination\n+     will require reloading.  */\n+  if (GET_CODE (op0) == REG\n+      && GET_CODE (op3) == MEM\n+      && reg_mentioned_p (op0, XEXP (op3, 0)))\n+    return 0;\n+\n+  return 1;\n }\n \n \n@@ -3280,47 +3314,48 @@ valid_parallel_operands_6 (operands, mode)\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   int regs = 0;\n-  rtx op0 = operands[1];\n-  rtx op1 = operands[2];\n-  rtx op2 = operands[4];\n-  rtx op3 = operands[5];\n+  rtx op0 = operands[0];\n+  rtx op1 = operands[1];\n+  rtx op2 = operands[2];\n+  rtx op4 = operands[4];\n+  rtx op5 = operands[5];\n \n-  if (GET_CODE (op0) == SUBREG)\n-    op0 = SUBREG_REG (op0);\n   if (GET_CODE (op1) == SUBREG)\n     op1 = SUBREG_REG (op1);\n   if (GET_CODE (op2) == SUBREG)\n     op2 = SUBREG_REG (op2);\n-  if (GET_CODE (op3) == SUBREG)\n-    op3 = SUBREG_REG (op3);\n+  if (GET_CODE (op4) == SUBREG)\n+    op4 = SUBREG_REG (op4);\n+  if (GET_CODE (op5) == SUBREG)\n+    op5 = SUBREG_REG (op5);\n \n   /* The patterns should only allow ext_low_reg_operand() or\n      par_ind_operand() operands.  Thus of the 4 input operands, only 2\n      should be REGs and the other 2 should be MEMs.  */\n \n-  if (GET_CODE (op0) == REG)\n-    regs++;\n   if (GET_CODE (op1) == REG)\n     regs++;\n   if (GET_CODE (op2) == REG)\n     regs++;\n-  if (GET_CODE (op3) == REG)\n+  if (GET_CODE (op4) == REG)\n+    regs++;\n+  if (GET_CODE (op5) == REG)\n     regs++;\n \n   /* The new C30/C40 silicon dies allow 3 regs of the 4 input operands. \n      Perhaps we should count the MEMs as well?  */\n-  return regs == 2;\n-}\n+  if (regs != 2)\n+    return 0;\n \n+  /* This test prevents the multipack pass from using this pattern if\n+     op0 is used as an index or base register in op4 or op5, since\n+     this combination will require reloading.  */\n+  if (GET_CODE (op0) == REG\n+      && ((GET_CODE (op4) == MEM && reg_mentioned_p (op0, XEXP (op4, 0)))\n+\t  || (GET_CODE (op5) == MEM && reg_mentioned_p (op0, XEXP (op5, 0)))))\n+    return 0;\n \n-int\n-legitimize_parallel_operands_6 (operands, mode)\n-     rtx *operands;\n-     enum machine_mode mode;\n-{\n-  /* It's gonna be hard to legitimize operands for a parallel\n-     instruction... TODO...  */\n-  return valid_parallel_operands_6 (operands, mode);\n+  return 1;\n }\n \n "}]}