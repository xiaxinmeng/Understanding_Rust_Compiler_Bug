{"sha": "b62acd607636a2294e6b141e3906d43377a7341b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjYyYWNkNjA3NjM2YTIyOTRlNmIxNDFlMzkwNmQ0MzM3N2E3MzQxYg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-07-27T05:57:26Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-07-27T05:57:26Z"}, "message": "(set_init_index): Add pedantic warning.\n\n(set_init_label): Likewise.\n\n(digest_init): Add `static' to definition.\n\n(start_init): Fill in p->next.\n\nHandle gaps in record initializers.\n(constructor_bit_index): New variable.\n(constructor_stack): New field bit_index.\n(really_start_incremental_init, push_init_level): Save and init it.\n(pop_init_level): Restore it.\n(output_init_element): Update constructor_bit_index.\nUse it to output gaps.\n(pop_init_level): Speed up by using constructor_bit_index.\n\n(process_init_element): Accept STRING_CST for subarray.\n\nFrom-SVN: r4997", "tree": {"sha": "0448343ac73712ac12205bdd20fd0f42365e7fa2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0448343ac73712ac12205bdd20fd0f42365e7fa2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b62acd607636a2294e6b141e3906d43377a7341b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b62acd607636a2294e6b141e3906d43377a7341b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b62acd607636a2294e6b141e3906d43377a7341b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b62acd607636a2294e6b141e3906d43377a7341b/comments", "author": null, "committer": null, "parents": [{"sha": "a785e67e7bd8d20a3200eddb1d6d53996ab17e4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a785e67e7bd8d20a3200eddb1d6d53996ab17e4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a785e67e7bd8d20a3200eddb1d6d53996ab17e4f"}], "stats": {"total": 148, "additions": 121, "deletions": 27}, "files": [{"sha": "fe459d9747c505862a5fa7955cc98e351f9594a9", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 121, "deletions": 27, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b62acd607636a2294e6b141e3906d43377a7341b/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b62acd607636a2294e6b141e3906d43377a7341b/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=b62acd607636a2294e6b141e3906d43377a7341b", "patch": "@@ -4831,7 +4831,7 @@ static tree free_tree_list = NULL_TREE;\n    If OFWHAT is null, the component name is stored on the spelling stack.\n    (That is true for all nested calls to digest_init.)  */\n \n-tree\n+static tree\n digest_init (type, init, tail, require_constant, constructor_constant)\n      tree type, init, *tail;\n      int require_constant, constructor_constant;\n@@ -5081,6 +5081,11 @@ static tree constructor_unfilled_fields;\n    This is a special INTEGER_CST node that we modify in place.  */\n static tree constructor_unfilled_index;\n \n+/* In a RECORD_TYPE, the byte index of the next consecutive field.\n+   This is so we can generate gaps between fields, when appropriate.\n+   This is a special INTEGER_CST node that we modify in place.  */\n+static tree constructor_bit_index;\n+\n /* If we are saving up the elements rather than allocating them,\n    this is the list of elements so far (in reverse order,\n    most recent first).  */\n@@ -5131,6 +5136,10 @@ static int constructor_top_level;\n /* When we finish reading a constructor expression\n    (constructor_decl is 0), the CONSTRUCTOR goes here.  */\n static tree constructor_result;\n+\f\n+/* This stack has a level for each implicit or explicit level of\n+   structuring in the initializer, including the outermost one.  It\n+   saves the values of most of the variables above.  */\n \n struct constructor_stack\n {\n@@ -5142,6 +5151,7 @@ struct constructor_stack\n   tree max_index;\n   tree unfilled_index;\n   tree unfilled_fields;\n+  tree bit_index;\n   tree elements;\n   int offset;\n   tree pending_elts;\n@@ -5205,7 +5215,7 @@ start_init (decl, asmspec_tree, top_level)\n   p->spelling_size = spelling_size;\n   p->deferred = constructor_subconstants_deferred;\n   p->top_level = constructor_top_level;\n-  p->next = 0;\n+  p->next = initializer_stack;\n   initializer_stack = p;\n \n   constructor_decl = decl;\n@@ -5302,6 +5312,7 @@ really_start_incremental_init (type)\n   p->max_index = constructor_max_index;\n   p->unfilled_index = constructor_unfilled_index;\n   p->unfilled_fields = constructor_unfilled_fields;\n+  p->bit_index = constructor_bit_index;\n   p->elements = 0;\n   p->constant = constructor_constant;\n   p->simple = constructor_simple;\n@@ -5326,6 +5337,7 @@ really_start_incremental_init (type)\n     {\n       constructor_fields = TYPE_FIELDS (constructor_type);\n       constructor_unfilled_fields = constructor_fields;\n+      constructor_bit_index = copy_node (integer_zero_node);\n     }\n   else if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n     {\n@@ -5381,6 +5393,7 @@ push_init_level (implicit)\n   p->max_index = constructor_max_index;\n   p->unfilled_index = constructor_unfilled_index;\n   p->unfilled_fields = constructor_unfilled_fields;\n+  p->bit_index = constructor_bit_index;\n   p->elements = constructor_elements;\n   p->constant = constructor_constant;\n   p->simple = constructor_simple;\n@@ -5419,6 +5432,7 @@ push_init_level (implicit)\n     {\n       constructor_fields = TYPE_FIELDS (constructor_type);\n       constructor_unfilled_fields = constructor_fields;\n+      constructor_bit_index = copy_node (integer_zero_node);\n     }\n   else if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n     {\n@@ -5488,6 +5502,15 @@ pop_init_level (implicit)\n   /* Now output all pending elements.  */\n   output_pending_init_elements (1);\n \n+#if 0 /* c-parse.in warns about {}.  */\n+  /* In ANSI, each brace level must have at least one element.  */\n+  if (! implicit && pedantic\n+      && (TREE_CODE (constructor_type) == ARRAY_TYPE\n+\t  ? integer_zerop (constructor_unfilled_index)\n+\t  : constructor_unfilled_fields == TYPE_FIELDS (constructor_type)))\n+    pedwarn_init (\"empty braces in initializer%s\", \" for `%s'\", NULL);\n+#endif\n+\n   /* Pad out the end of the structure.  */\n   \n   if (! constructor_incremental)\n@@ -5515,17 +5538,9 @@ pop_init_level (implicit)\n       if (TREE_CODE (constructor_type) == RECORD_TYPE\n \t  || TREE_CODE (constructor_type) == UNION_TYPE)\n \t{\n-\t  tree tail;\n-\t  /* Find the last field written out.  */\n-\t  for (tail = TYPE_FIELDS (constructor_type); tail;\n-\t       tail = TREE_CHAIN (tail))\n-\t    if (TREE_CHAIN (tail) == constructor_unfilled_fields)\n-\t      break;\n \t  /* Find the offset of the end of that field.  */\n \t  filled = size_binop (CEIL_DIV_EXPR,\n-\t\t\t       size_binop (PLUS_EXPR,\n-\t\t\t\t\t   DECL_FIELD_BITPOS (tail),\n-\t\t\t\t\t   DECL_SIZE (tail)),\n+\t\t\t       constructor_bit_index,\n \t\t\t       size_int (BITS_PER_UNIT));\n \t}\n       else if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n@@ -5581,6 +5596,7 @@ pop_init_level (implicit)\n   constructor_max_index = p->max_index;\n   constructor_unfilled_index = p->unfilled_index;\n   constructor_unfilled_fields = p->unfilled_fields;\n+  constructor_bit_index = p->bit_index;\n   constructor_elements = p->elements;\n   constructor_constant = p->constant;\n   constructor_simple = p->simple;\n@@ -5622,7 +5638,11 @@ set_init_index (first, last)\n       if (last != 0 && tree_int_cst_lt (last, first))\n \terror_init (\"empty index range in initializer%s\", \" for `%s'\", NULL);\n       else\n-\tconstructor_range_end = last;\n+\t{\n+\t  if (pedantic)\n+\t    pedwarn (\"ANSI C forbids specifying element to initialize\");\n+\t  constructor_range_end = last;\n+\t}\n     }\n }\n \n@@ -5651,7 +5671,11 @@ set_init_label (fieldname)\n     error (\"field `%s' already initialized\",\n \t   IDENTIFIER_POINTER (fieldname));\n   else\n-    constructor_fields = tail;\n+    {\n+      constructor_fields = tail;\n+      if (pedantic)\n+\tpedwarn (\"ANSI C forbids specifying structure member to initialize\");\n+    }\n }\n \f\n /* \"Output\" the next constructor element.\n@@ -5759,7 +5783,37 @@ output_init_element (value, type, field, pending)\n \t\t\t\t\trequire_constant_elements),\n \t\t\t   constructor_elements);\n \t  else\n-\t    output_constant (value, int_size_in_bytes (type));\n+\t    {\n+\t      /* Structure elements may require alignment.\n+\t\t Do this, if necessary.  */\n+\t      if (TREE_CODE (constructor_type) == RECORD_TYPE)\n+\t\t{\n+\t\t  /* Advance to offset of this element.  */\n+\t\t  if (! tree_int_cst_equal (constructor_bit_index,\n+\t\t\t\t\t    DECL_FIELD_BITPOS (constructor_fields)))\n+\t\t    {\n+\t\t      int next = (TREE_INT_CST_LOW (DECL_FIELD_BITPOS (field))\n+\t\t\t\t  / BITS_PER_UNIT);\n+\t\t      int here = (TREE_INT_CST_LOW (constructor_bit_index)\n+\t\t\t\t  / BITS_PER_UNIT);\n+\n+\t\t      assemble_zeros (next - here);\n+\t\t    }\n+\t\t}\n+\t      output_constant (value, int_size_in_bytes (type));\n+\n+\t      /* For a record, keep track of end position of last field.  */\n+\t      if (TREE_CODE (constructor_type) == RECORD_TYPE)\n+\t\t{\n+\t\t  tree temp = size_binop (PLUS_EXPR,\n+\t\t\t\t\t  DECL_FIELD_BITPOS (constructor_fields),\n+\t\t\t\t\t  DECL_SIZE (constructor_fields));\n+\t\t  TREE_INT_CST_LOW (constructor_bit_index)\n+\t\t    = TREE_INT_CST_LOW (temp);\n+\t\t  TREE_INT_CST_HIGH (constructor_bit_index)\n+\t\t    = TREE_INT_CST_HIGH (temp);\n+\t\t}\n+\t    }\n \t}\n \n       /* Advance the variable that indicates sequential elements output.  */\n@@ -5924,6 +5978,9 @@ void\n process_init_element (value)\n      tree value;\n {\n+  tree orig_value = value;\n+  int string_flag = value != 0 && TREE_CODE (value) == STRING_CST;\n+\n   if (value != 0)\n     value = default_conversion (value);\n \n@@ -5968,9 +6025,18 @@ process_init_element (value)\n \t  fieldtype = TYPE_MAIN_VARIANT (TREE_TYPE (constructor_fields));\n \t  fieldcode = TREE_CODE (fieldtype);\n \n-\t  if (value != 0 && TYPE_MAIN_VARIANT (TREE_TYPE (value)) != fieldtype\n-\t      && (fieldcode == RECORD_TYPE || fieldcode == ARRAY_TYPE\n-\t\t  || fieldcode == UNION_TYPE))\n+\t  /* Accept a string constant to initialize a subarray.  */\n+\t  if (value != 0\n+\t      && fieldcode == ARRAY_TYPE\n+\t      && TREE_CODE (TREE_TYPE (fieldtype)) == INTEGER_TYPE\n+\t      && string_flag)\n+\t    value = orig_value;\n+\t  /* Otherwise, if we have come to a subaggregate,\n+\t     and we don't have an element of its type, push into it.  */\n+\t  else if (value != 0\n+\t\t   && TYPE_MAIN_VARIANT (TREE_TYPE (value)) != fieldtype\n+\t\t   && (fieldcode == RECORD_TYPE || fieldcode == ARRAY_TYPE\n+\t\t       || fieldcode == UNION_TYPE))\n \t    {\n \t      push_init_level (1);\n \t      continue;\n@@ -5983,10 +6049,20 @@ process_init_element (value)\n \t      RESTORE_SPELLING_DEPTH (constructor_depth);\n \t    }\n \t  else\n-\t    /* If we are doing the bookkeeping for an element that was\n-\t       directly output as a constructor,\n-\t       we must update constructor_unfilled_fields.  */\n-\t    constructor_unfilled_fields = TREE_CHAIN (constructor_fields);\n+\t    /* Do the bookkeeping for an element that was\n+\t       directly output as a constructor.  */\n+\t    {\n+\t      /* For a record, keep track of end position of last field.  */\n+\t      tree temp = size_binop (PLUS_EXPR,\n+\t\t\t\t      DECL_FIELD_BITPOS (constructor_fields),\n+\t\t\t\t      DECL_SIZE (constructor_fields));\n+\t      TREE_INT_CST_LOW (constructor_bit_index)\n+\t\t= TREE_INT_CST_LOW (temp);\n+\t      TREE_INT_CST_HIGH (constructor_bit_index)\n+\t\t= TREE_INT_CST_HIGH (temp);\n+\n+\t      constructor_unfilled_fields = TREE_CHAIN (constructor_fields);\n+\t    }\n \n \t  constructor_fields = TREE_CHAIN (constructor_fields);\n \t  break;\n@@ -6006,9 +6082,18 @@ process_init_element (value)\n \t  fieldtype = TYPE_MAIN_VARIANT (TREE_TYPE (constructor_fields));\n \t  fieldcode = TREE_CODE (fieldtype);\n \n-\t  if (value != 0 && TYPE_MAIN_VARIANT (TREE_TYPE (value)) != fieldtype\n-\t      && (fieldcode == RECORD_TYPE || fieldcode == ARRAY_TYPE\n-\t\t  || fieldcode == UNION_TYPE))\n+\t  /* Accept a string constant to initialize a subarray.  */\n+\t  if (value != 0\n+\t      && fieldcode == ARRAY_TYPE\n+\t      && TREE_CODE (TREE_TYPE (fieldtype)) == INTEGER_TYPE\n+\t      && string_flag)\n+\t    value = orig_value;\n+\t  /* Otherwise, if we have come to a subaggregate,\n+\t     and we don't have an element of its type, push into it.  */\n+\t  else if (value != 0\n+\t\t   && TYPE_MAIN_VARIANT (TREE_TYPE (value)) != fieldtype\n+\t\t   && (fieldcode == RECORD_TYPE || fieldcode == ARRAY_TYPE\n+\t\t       || fieldcode == UNION_TYPE))\n \t    {\n \t      push_init_level (1);\n \t      continue;\n@@ -6034,9 +6119,18 @@ process_init_element (value)\n \t  tree elttype = TYPE_MAIN_VARIANT (TREE_TYPE (constructor_type));\n \t  enum tree_code eltcode = TREE_CODE (elttype);\n \n-\t  if (value != 0 && TYPE_MAIN_VARIANT (TREE_TYPE (value)) != elttype\n-\t      && (eltcode == RECORD_TYPE || eltcode == ARRAY_TYPE\n-\t\t  || eltcode == UNION_TYPE))\n+\t  /* Accept a string constant to initialize a subarray.  */\n+\t  if (value != 0\n+\t      && eltcode == ARRAY_TYPE\n+\t      && TREE_CODE (TREE_TYPE (elttype)) == INTEGER_TYPE\n+\t      && string_flag)\n+\t    value = orig_value;\n+\t  /* Otherwise, if we have come to a subaggregate,\n+\t     and we don't have an element of its type, push into it.  */\n+\t  else if (value != 0\n+\t\t   && TYPE_MAIN_VARIANT (TREE_TYPE (value)) != elttype\n+\t\t   && (eltcode == RECORD_TYPE || eltcode == ARRAY_TYPE\n+\t\t       || eltcode == UNION_TYPE))\n \t    {\n \t      push_init_level (1);\n \t      continue;"}]}