{"sha": "c4574d23cb07340918793a5a98ae7bb2988b3791", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzQ1NzRkMjNjYjA3MzQwOTE4NzkzYTVhOThhZTdiYjI5ODhiMzc5MQ==", "commit": {"author": {"name": "Andrew Pinski", "email": "apinski@marvell.com", "date": "2021-06-01T06:48:05Z"}, "committer": {"name": "Andrew Pinski", "email": "apinski@marvell.com", "date": "2021-06-08T22:08:25Z"}, "message": "Improve match_simplify_replacement in phi-opt\n\nThis improves match_simplify_replace in phi-opt to handle the\ncase where there is one cheap (non-call) preparation statement in the\nmiddle basic block similar to xor_replacement and others.\nThis allows to remove xor_replacement which it does too.\n\nOK?  Bootstrapped and tested on x86_64-linux-gnu with no regressions.\n\nThanks,\nAndrew Pinski\n\nChanges since v1:\nv3 - Just minor changes to using gimple_assign_lhs\ninstead of gimple_lhs and fixing a comment.\nv2 - change the check on the preparation statement to\nallow only assignments and no calls and only assignments\nthat feed into the phi.\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/25290\n\t* tree-ssa-phiopt.c (xor_replacement): Delete.\n\t(tree_ssa_phiopt_worker): Delete use of xor_replacement.\n\t(match_simplify_replacement): Allow one cheap preparation\n\tstatement that can be moved to before the if.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/tree-ssa/pr96928-1.c: Fix testcase for now that ~\n\thappens on the outside of the bit_xor.", "tree": {"sha": "f68278ceb99dd9423dc9d0b279dedca082a22fe1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f68278ceb99dd9423dc9d0b279dedca082a22fe1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c4574d23cb07340918793a5a98ae7bb2988b3791", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4574d23cb07340918793a5a98ae7bb2988b3791", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4574d23cb07340918793a5a98ae7bb2988b3791", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4574d23cb07340918793a5a98ae7bb2988b3791/comments", "author": {"login": "apinski-cavium", "id": 6335315, "node_id": "MDQ6VXNlcjYzMzUzMTU=", "avatar_url": "https://avatars.githubusercontent.com/u/6335315?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apinski-cavium", "html_url": "https://github.com/apinski-cavium", "followers_url": "https://api.github.com/users/apinski-cavium/followers", "following_url": "https://api.github.com/users/apinski-cavium/following{/other_user}", "gists_url": "https://api.github.com/users/apinski-cavium/gists{/gist_id}", "starred_url": "https://api.github.com/users/apinski-cavium/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apinski-cavium/subscriptions", "organizations_url": "https://api.github.com/users/apinski-cavium/orgs", "repos_url": "https://api.github.com/users/apinski-cavium/repos", "events_url": "https://api.github.com/users/apinski-cavium/events{/privacy}", "received_events_url": "https://api.github.com/users/apinski-cavium/received_events", "type": "User", "site_admin": false}, "committer": {"login": "apinski-cavium", "id": 6335315, "node_id": "MDQ6VXNlcjYzMzUzMTU=", "avatar_url": "https://avatars.githubusercontent.com/u/6335315?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apinski-cavium", "html_url": "https://github.com/apinski-cavium", "followers_url": "https://api.github.com/users/apinski-cavium/followers", "following_url": "https://api.github.com/users/apinski-cavium/following{/other_user}", "gists_url": "https://api.github.com/users/apinski-cavium/gists{/gist_id}", "starred_url": "https://api.github.com/users/apinski-cavium/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apinski-cavium/subscriptions", "organizations_url": "https://api.github.com/users/apinski-cavium/orgs", "repos_url": "https://api.github.com/users/apinski-cavium/repos", "events_url": "https://api.github.com/users/apinski-cavium/events{/privacy}", "received_events_url": "https://api.github.com/users/apinski-cavium/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "61fc01806f376a780978a6dea165ec3dadef085b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61fc01806f376a780978a6dea165ec3dadef085b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61fc01806f376a780978a6dea165ec3dadef085b"}], "stats": {"total": 168, "additions": 54, "deletions": 114}, "files": [{"sha": "2e86620da11d11a7b42c7f3592be29f32d67402b", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr96928-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4574d23cb07340918793a5a98ae7bb2988b3791/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr96928-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4574d23cb07340918793a5a98ae7bb2988b3791/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr96928-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr96928-1.c?ref=c4574d23cb07340918793a5a98ae7bb2988b3791", "patch": "@@ -1,9 +1,9 @@\n /* PR tree-optimization/96928 */\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-phiopt2\" } */\n+/* { dg-options \"-O2 -fdump-tree-phiopt2 -fdump-tree-optimized\" } */\n /* { dg-final { scan-tree-dump-times \" = a_\\[0-9]*\\\\\\(D\\\\\\) >> \" 5 \"phiopt2\" } } */\n /* { dg-final { scan-tree-dump-times \" = ~c_\\[0-9]*\\\\\\(D\\\\\\);\" 1 \"phiopt2\" } } */\n-/* { dg-final { scan-tree-dump-times \" = ~\" 1 \"phiopt2\" } } */\n+/* { dg-final { scan-tree-dump-times \" = ~\" 1 \"optimized\" } } */\n /* { dg-final { scan-tree-dump-times \" = \\[abc_0-9\\\\\\(\\\\\\)D]* \\\\\\^ \" 5 \"phiopt2\" } } */\n /* { dg-final { scan-tree-dump-not \"a < 0\" \"phiopt2\" } } */\n "}, {"sha": "76f4e7ec843330d301f014b67667e71d829d29aa", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 52, "deletions": 112, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4574d23cb07340918793a5a98ae7bb2988b3791/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4574d23cb07340918793a5a98ae7bb2988b3791/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=c4574d23cb07340918793a5a98ae7bb2988b3791", "patch": "@@ -28,6 +28,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfghooks.h\"\n #include \"tree-pass.h\"\n #include \"ssa.h\"\n+#include \"tree-ssa.h\"\n #include \"optabs-tree.h\"\n #include \"insn-config.h\"\n #include \"gimple-pretty-print.h\"\n@@ -63,8 +64,6 @@ static bool minmax_replacement (basic_block, basic_block,\n \t\t\t\tedge, edge, gphi *, tree, tree);\n static bool abs_replacement (basic_block, basic_block,\n \t\t\t     edge, edge, gphi *, tree, tree);\n-static bool xor_replacement (basic_block, basic_block,\n-\t\t\t     edge, edge, gphi *, tree, tree);\n static bool spaceship_replacement (basic_block, basic_block,\n \t\t\t\t   edge, edge, gphi *, tree, tree);\n static bool cond_removal_in_popcount_clz_ctz_pattern (basic_block, basic_block,\n@@ -352,9 +351,6 @@ tree_ssa_phiopt_worker (bool do_store_elim, bool do_hoist_loads, bool early_p)\n \t    cfgchanged = true;\n \t  else if (abs_replacement (bb, bb1, e1, e2, phi, arg0, arg1))\n \t    cfgchanged = true;\n-\t  else if (!early_p\n-\t\t   && xor_replacement (bb, bb1, e1, e2, phi, arg0, arg1))\n-\t    cfgchanged = true;\n \t  else if (!early_p\n \t\t   && cond_removal_in_popcount_clz_ctz_pattern (bb, bb1, e1,\n \t\t\t\t\t\t\t\te2, phi, arg0,\n@@ -801,14 +797,51 @@ match_simplify_replacement (basic_block cond_bb, basic_block middle_bb,\n   edge true_edge, false_edge;\n   gimple_seq seq = NULL;\n   tree result;\n-\n-  if (!empty_block_p (middle_bb))\n-    return false;\n+  gimple *stmt_to_move = NULL;\n \n   /* Special case A ? B : B as this will always simplify to B. */\n   if (operand_equal_for_phi_arg_p (arg0, arg1))\n     return false;\n \n+  /* If the basic block only has a cheap preparation statement,\n+     allow it and move it once the transformation is done. */\n+  if (!empty_block_p (middle_bb))\n+    {\n+      stmt_to_move = last_and_only_stmt (middle_bb);\n+      if (!stmt_to_move)\n+\treturn false;\n+\n+      if (gimple_vuse (stmt_to_move))\n+\treturn false;\n+\n+      if (gimple_could_trap_p (stmt_to_move)\n+\t  || gimple_has_side_effects (stmt_to_move))\n+\treturn false;\n+\n+      if (gimple_uses_undefined_value_p (stmt_to_move))\n+\treturn false;\n+\n+      /* Allow assignments and not no calls.\n+\t As const calls don't match any of the above, yet they could\n+\t still have some side-effects - they could contain\n+\t gimple_could_trap_p statements, like floating point\n+\t exceptions or integer division by zero.  See PR70586.\n+\t FIXME: perhaps gimple_has_side_effects or gimple_could_trap_p\n+\t should handle this.  */\n+      if (!is_gimple_assign (stmt_to_move))\n+\treturn false;\n+\n+      tree lhs = gimple_assign_lhs  (stmt_to_move);\n+      gimple *use_stmt;\n+      use_operand_p use_p;\n+\n+      /* Allow only a statement which feeds into the phi.  */\n+      if (!lhs || TREE_CODE (lhs) != SSA_NAME\n+\t  || !single_imm_use (lhs, &use_p, &use_stmt)\n+\t  || use_stmt != phi)\n+\treturn false;\n+    }\n+\n     /* At this point we know we have a GIMPLE_COND with two successors.\n      One successor is BB, the other successor is an empty block which\n      falls through into BB.\n@@ -844,7 +877,17 @@ match_simplify_replacement (basic_block cond_bb, basic_block middle_bb,\n     return false;\n \n   gsi = gsi_last_bb (cond_bb);\n-\n+  if (stmt_to_move)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"statement un-sinked:\\n\");\n+\t  print_gimple_stmt (dump_file, stmt_to_move, 0,\n+\t\t\t   TDF_VOPS|TDF_MEMSYMS);\n+\t}\n+      gimple_stmt_iterator gsi1 = gsi_for_stmt (stmt_to_move);\n+      gsi_move_before (&gsi1, &gsi);\n+    }\n   if (seq)\n     gsi_insert_seq_before (&gsi, seq, GSI_SAME_STMT);\n \n@@ -2592,109 +2635,6 @@ abs_replacement (basic_block cond_bb, basic_block middle_bb,\n   return true;\n }\n \n-/* Optimize x < 0 ? ~y : y into (x >> (prec-1)) ^ y.  */\n-\n-static bool\n-xor_replacement (basic_block cond_bb, basic_block middle_bb,\n-\t\t edge e0 ATTRIBUTE_UNUSED, edge e1,\n-\t\t gphi *phi, tree arg0, tree arg1)\n-{\n-  if (!INTEGRAL_TYPE_P (TREE_TYPE (arg1)))\n-    return false;\n-\n-  /* OTHER_BLOCK must have only one executable statement which must have the\n-     form arg0 = ~arg1 or arg1 = ~arg0.  */\n-\n-  gimple *assign = last_and_only_stmt (middle_bb);\n-  /* If we did not find the proper one's complement assignment, then we cannot\n-     optimize.  */\n-  if (assign == NULL)\n-    return false;\n-\n-  /* If we got here, then we have found the only executable statement\n-     in OTHER_BLOCK.  If it is anything other than arg = ~arg1 or\n-     arg1 = ~arg0, then we cannot optimize.  */\n-  if (!is_gimple_assign (assign))\n-    return false;\n-\n-  if (gimple_assign_rhs_code (assign) != BIT_NOT_EXPR)\n-    return false;\n-\n-  tree lhs = gimple_assign_lhs (assign);\n-  tree rhs = gimple_assign_rhs1 (assign);\n-\n-  /* The assignment has to be arg0 = -arg1 or arg1 = -arg0.  */\n-  if (!(lhs == arg0 && rhs == arg1) && !(lhs == arg1 && rhs == arg0))\n-    return false;\n-\n-  gimple *cond = last_stmt (cond_bb);\n-  tree result = PHI_RESULT (phi);\n-\n-  /* Only relationals comparing arg[01] against zero are interesting.  */\n-  enum tree_code cond_code = gimple_cond_code (cond);\n-  if (cond_code != LT_EXPR && cond_code != GE_EXPR)\n-    return false;\n-\n-  /* Make sure the conditional is x OP 0.  */\n-  tree clhs = gimple_cond_lhs (cond);\n-  if (TREE_CODE (clhs) != SSA_NAME\n-      || !INTEGRAL_TYPE_P (TREE_TYPE (clhs))\n-      || TYPE_UNSIGNED (TREE_TYPE (clhs))\n-      || TYPE_PRECISION (TREE_TYPE (clhs)) != TYPE_PRECISION (TREE_TYPE (arg1))\n-      || !integer_zerop (gimple_cond_rhs (cond)))\n-    return false;\n-\n-  /* We need to know which is the true edge and which is the false\n-     edge so that we know if have xor or inverted xor.  */\n-  edge true_edge, false_edge;\n-  extract_true_false_edges_from_block (cond_bb, &true_edge, &false_edge);\n-\n-  /* For GE_EXPR, if the true edge goes to OTHER_BLOCK, then we\n-     will need to invert the result.  Similarly for LT_EXPR if\n-     the false edge goes to OTHER_BLOCK.  */\n-  edge e;\n-  if (cond_code == GE_EXPR)\n-    e = true_edge;\n-  else\n-    e = false_edge;\n-\n-  bool invert = e->dest == middle_bb;\n-\n-  result = duplicate_ssa_name (result, NULL);\n-\n-  gimple_stmt_iterator gsi = gsi_last_bb (cond_bb);\n-\n-  int prec = TYPE_PRECISION (TREE_TYPE (clhs));\n-  gimple *new_stmt\n-    = gimple_build_assign (make_ssa_name (TREE_TYPE (clhs)), RSHIFT_EXPR, clhs,\n-\t\t\t   build_int_cst (integer_type_node, prec - 1));\n-  gsi_insert_before (&gsi, new_stmt, GSI_SAME_STMT);\n-\n-  if (!useless_type_conversion_p (TREE_TYPE (result), TREE_TYPE (clhs)))\n-    {\n-      new_stmt = gimple_build_assign (make_ssa_name (TREE_TYPE (result)),\n-\t\t\t\t      NOP_EXPR, gimple_assign_lhs (new_stmt));\n-      gsi_insert_before (&gsi, new_stmt, GSI_SAME_STMT);\n-    }\n-  lhs = gimple_assign_lhs (new_stmt);\n-\n-  if (invert)\n-    {\n-      new_stmt = gimple_build_assign (make_ssa_name (TREE_TYPE (result)),\n-\t\t\t\t      BIT_NOT_EXPR, rhs);\n-      gsi_insert_before (&gsi, new_stmt, GSI_SAME_STMT);\n-      rhs = gimple_assign_lhs (new_stmt);\n-    }\n-\n-  new_stmt = gimple_build_assign (result, BIT_XOR_EXPR, lhs, rhs);\n-  gsi_insert_before (&gsi, new_stmt, GSI_NEW_STMT);\n-\n-  replace_phi_edge_with_variable (cond_bb, e1, phi, result);\n-\n-  /* Note that we optimized this PHI.  */\n-  return true;\n-}\n-\n /* Auxiliary functions to determine the set of memory accesses which\n    can't trap because they are preceded by accesses to the same memory\n    portion.  We do that for MEM_REFs, so we only need to track"}]}