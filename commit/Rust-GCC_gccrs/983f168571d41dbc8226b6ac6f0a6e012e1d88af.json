{"sha": "983f168571d41dbc8226b6ac6f0a6e012e1d88af", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTgzZjE2ODU3MWQ0MWRiYzgyMjZiNmFjNmYwYTZlMDEyZTFkODhhZg==", "commit": {"author": {"name": "Stan Cox", "email": "coxs@gnu.org", "date": "1996-06-11T19:28:11Z"}, "committer": {"name": "Stan Cox", "email": "coxs@gnu.org", "date": "1996-06-11T19:28:11Z"}, "message": "(TARGET_SCHEDULE_PROLOGUE): New to allow prologue to  be emitted as asm or rtl.\n\nFrom-SVN: r12275", "tree": {"sha": "234fe8f529088984e254609fd56f217cd971fd88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/234fe8f529088984e254609fd56f217cd971fd88"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/983f168571d41dbc8226b6ac6f0a6e012e1d88af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/983f168571d41dbc8226b6ac6f0a6e012e1d88af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/983f168571d41dbc8226b6ac6f0a6e012e1d88af", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/983f168571d41dbc8226b6ac6f0a6e012e1d88af/comments", "author": null, "committer": null, "parents": [{"sha": "68ea97b42a700cd439a25ce9cf6352780fb3202a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68ea97b42a700cd439a25ce9cf6352780fb3202a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68ea97b42a700cd439a25ce9cf6352780fb3202a"}], "stats": {"total": 82, "additions": 68, "deletions": 14}, "files": [{"sha": "0d529a5fe58e7bfc663f4ee62b33ed9ed280bb54", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 68, "deletions": 14, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/983f168571d41dbc8226b6ac6f0a6e012e1d88af/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/983f168571d41dbc8226b6ac6f0a6e012e1d88af/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=983f168571d41dbc8226b6ac6f0a6e012e1d88af", "patch": "@@ -294,6 +294,10 @@ override_options ()\n \n   if (TARGET_OMIT_LEAF_FRAME_POINTER)\t/* keep nonleaf frame pointers */\n     flag_omit_frame_pointer = 1;\n+\n+  /* pic references don't explicitly mention pic_offset_table_rtx */\n+  if (flag_pic)\n+    target_flags &= ~MASK_SCHEDULE_PROLOGUE;\n }\n \f\n /* A C statement (sans semicolon) to choose the order in which to\n@@ -1709,6 +1713,67 @@ function_prologue (file, size)\n      FILE *file;\n      int size;\n {\n+  register int regno;\n+  int limit;\n+  rtx xops[4];\n+  int pic_reg_used = flag_pic && (current_function_uses_pic_offset_table\n+\t\t\t\t  || current_function_uses_const_pool);\n+  long tsize = get_frame_size ();\n+\n+  /* pic references don't explicitly mention pic_offset_table_rtx */\n+  if (TARGET_SCHEDULE_PROLOGUE)\n+    return;\n+  \n+  xops[0] = stack_pointer_rtx;\n+  xops[1] = frame_pointer_rtx;\n+  xops[2] = GEN_INT (tsize);\n+  if (frame_pointer_needed)\n+    {\n+      output_asm_insn (\"push%L1 %1\", xops); \n+      output_asm_insn (AS2 (mov%L0,%0,%1), xops); \n+    }\n+\n+  if (tsize)\n+    output_asm_insn (AS2 (sub%L0,%2,%0), xops);\n+\n+  /* Note If use enter it is NOT reversed args.\n+     This one is not reversed from intel!!\n+     I think enter is slower.  Also sdb doesn't like it.\n+     But if you want it the code is:\n+     {\n+     xops[3] = const0_rtx;\n+     output_asm_insn (\"enter %2,%3\", xops);\n+     }\n+     */\n+  limit = (frame_pointer_needed ? FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM);\n+  for (regno = limit - 1; regno >= 0; regno--)\n+    if ((regs_ever_live[regno] && ! call_used_regs[regno])\n+\t|| (regno == PIC_OFFSET_TABLE_REGNUM && pic_reg_used))\n+      {\n+\txops[0] = gen_rtx (REG, SImode, regno);\n+\toutput_asm_insn (\"push%L0 %0\", xops);\n+      }\n+\n+  if (pic_reg_used && TARGET_DEEP_BRANCH_PREDICTION)\n+    {\n+      xops[0] = pic_offset_table_rtx;\n+      if (pic_label_rtx == 0)\n+\tpic_label_rtx = (rtx) gen_label_rtx ();\n+      xops[1] = pic_label_rtx;\n+\n+      output_asm_insn (AS1 (call,%P1), xops);\n+      output_asm_insn (\"addl $_GLOBAL_OFFSET_TABLE_,%0\", xops);\n+    }\n+  else if (pic_reg_used)\n+    {\n+    xops[0] = pic_offset_table_rtx;\n+    xops[1] = (rtx) gen_label_rtx ();\n+ \n+      output_asm_insn (AS1 (call,%P1), xops);\n+      ASM_OUTPUT_INTERNAL_LABEL (file, \"L\", CODE_LABEL_NUMBER (xops[1]));\n+      output_asm_insn (AS1 (pop%L0,%0), xops);\n+      output_asm_insn (\"addl $_GLOBAL_OFFSET_TABLE_+[.-%P1],%0\", xops);\n+  } \n }\n \n /* This function generates the assembly code for function entry.\n@@ -1725,6 +1790,9 @@ ix86_expand_prologue ()\n \t\t\t\t  || current_function_uses_const_pool);\n   long tsize = get_frame_size ();\n \n+  if (!TARGET_SCHEDULE_PROLOGUE)\n+    return;\n+  \n   xops[0] = stack_pointer_rtx;\n   xops[1] = frame_pointer_rtx;\n   xops[2] = GEN_INT (tsize);\n@@ -1735,8 +1803,6 @@ ix86_expand_prologue ()\n \t\t\t\t   gen_rtx (PRE_DEC, SImode, stack_pointer_rtx)),\n \t\t\t  frame_pointer_rtx));\n       emit_move_insn (xops[1], xops[0]);\n-/*      output_asm_insn (\"push%L1 %1\", xops); */\n-/*      output_asm_insn (AS2 (mov%L0,%0,%1), xops); */\n     }\n \n   if (tsize)\n@@ -1746,8 +1812,6 @@ ix86_expand_prologue ()\n \t\t\t\t   xops[0],\n \t\t\t\t   xops[2])));\n \n-/*    output_asm_insn (AS2 (sub%L0,%2,%0), xops);*/\n-\n   /* Note If use enter it is NOT reversed args.\n      This one is not reversed from intel!!\n      I think enter is slower.  Also sdb doesn't like it.\n@@ -1767,7 +1831,6 @@ ix86_expand_prologue ()\n \t\t\t    gen_rtx (MEM, SImode,\n \t\t\t\t     gen_rtx (PRE_DEC, SImode, stack_pointer_rtx)),\n \t\t\t  xops[0]));\n-/*\toutput_asm_insn (\"push%L0 %0\", xops);*/\n       }\n \n   if (pic_reg_used && TARGET_DEEP_BRANCH_PREDICTION)\n@@ -1778,29 +1841,20 @@ ix86_expand_prologue ()\n       xops[1] = pic_label_rtx;\n \n       emit_insn (gen_prologue_get_pc (xops[0], gen_rtx (CONST_INT, Pmode, CODE_LABEL_NUMBER(xops[1]))));\n-/*      output_asm_insn (AS1 (call,%P1), xops);*/\n       emit_insn (gen_prologue_set_got (xops[0], \n \t\t gen_rtx (SYMBOL_REF, Pmode, \"$_GLOBAL_OFFSET_TABLE_\"), \n \t\t gen_rtx (CONST_INT, Pmode, CODE_LABEL_NUMBER(xops[1]))));\n-      SCHED_GROUP_P (get_last_insn()) = 1;\n-/*      output_asm_insn (\"addl $_GLOBAL_OFFSET_TABLE_,%0\", xops);*/\n     }\n   else if (pic_reg_used)\n     {\n     xops[0] = pic_offset_table_rtx;\n     xops[1] = (rtx) gen_label_rtx ();\n  \n       emit_insn (gen_prologue_get_pc (xops[0], gen_rtx (CONST_INT, Pmode, CODE_LABEL_NUMBER(xops[1]))));\n-      SCHED_GROUP_P (get_last_insn()) = 1;\n-/*      output_asm_insn (AS1 (call,%P1), xops);*/\n-/*      ASM_OUTPUT_INTERNAL_LABEL (file, \"L\", CODE_LABEL_NUMBER (xops[1]));*/\n       emit_insn (gen_pop (xops[0]));\n-/*      output_asm_insn (AS1 (pop%L0,%0), xops);*/\n       emit_insn (gen_prologue_set_got (xops[0], \n \t\t gen_rtx (SYMBOL_REF, Pmode, \"$_GLOBAL_OFFSET_TABLE_\"), \n \t\t gen_rtx (CONST_INT, Pmode, CODE_LABEL_NUMBER (xops[1]))));\n-    SCHED_GROUP_P (get_last_insn()) = 1;\n-/*      output_asm_insn (\"addl $_GLOBAL_OFFSET_TABLE_+[.-%P1],%0\", xops);*/\n   } \n }\n "}]}