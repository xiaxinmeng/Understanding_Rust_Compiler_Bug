{"sha": "b266b96856da702dbe957396adc6f242daed233b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjI2NmI5Njg1NmRhNzAyZGJlOTU3Mzk2YWRjNmYyNDJkYWVkMjMzYg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-06-10T10:39:31Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-06-10T10:39:31Z"}, "message": "tree-vect-slp.c (vect_attempt_slp_rearrange_stmts): Split out from ...\n\n2015-06-10  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-slp.c (vect_attempt_slp_rearrange_stmts): Split\n\tout from ...\n\t(vect_supported_load_permutation_p): ... here.  Handle\n\tsupportable permutations in reductions.\n\t* tree-vect-stmts.c (vectorizable_load): Handle SLP permutations\n\tfor vectorizing strided group loads.\n\nFrom-SVN: r224324", "tree": {"sha": "ce0f05e25c08e6f3afd2ed0a00dc9443a954ff57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ce0f05e25c08e6f3afd2ed0a00dc9443a954ff57"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b266b96856da702dbe957396adc6f242daed233b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b266b96856da702dbe957396adc6f242daed233b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b266b96856da702dbe957396adc6f242daed233b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b266b96856da702dbe957396adc6f242daed233b/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8ffd51d230e0ab7a1c1caaf1486303796862f771", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ffd51d230e0ab7a1c1caaf1486303796862f771", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ffd51d230e0ab7a1c1caaf1486303796862f771"}], "stats": {"total": 141, "additions": 86, "deletions": 55}, "files": [{"sha": "c3854fa5c6e6b75e2bd5db8696c5b7e5613123ec", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b266b96856da702dbe957396adc6f242daed233b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b266b96856da702dbe957396adc6f242daed233b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b266b96856da702dbe957396adc6f242daed233b", "patch": "@@ -1,3 +1,12 @@\n+2015-06-10  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vect-slp.c (vect_attempt_slp_rearrange_stmts): Split\n+\tout from ...\n+\t(vect_supported_load_permutation_p): ... here.  Handle\n+\tsupportable permutations in reductions.\n+\t* tree-vect-stmts.c (vectorizable_load): Handle SLP permutations\n+\tfor vectorizing strided group loads.\n+\n 2015-06-10  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/66470"}, {"sha": "880b245c92713bb69e4d7fe748cb57912335df78", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 65, "deletions": 50, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b266b96856da702dbe957396adc6f242daed233b/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b266b96856da702dbe957396adc6f242daed233b/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=b266b96856da702dbe957396adc6f242daed233b", "patch": "@@ -1299,6 +1299,67 @@ vect_slp_rearrange_stmts (slp_tree node, unsigned int group_size,\n }\n \n \n+/* Attempt to reorder stmts in a reduction chain so that we don't\n+   require any load permutation.  Return true if that was possible,\n+   otherwise return false.  */\n+\n+static bool\n+vect_attempt_slp_rearrange_stmts (slp_instance slp_instn)\n+{\n+  unsigned int group_size = SLP_INSTANCE_GROUP_SIZE (slp_instn);\n+  unsigned int i, j;\n+  sbitmap load_index;\n+  unsigned int lidx;\n+  slp_tree node, load;\n+\n+  /* Compare all the permutation sequences to the first one.  We know\n+     that at least one load is permuted.  */\n+  node = SLP_INSTANCE_LOADS (slp_instn)[0];\n+  if (!node->load_permutation.exists ())\n+    return false;\n+  for (i = 1; SLP_INSTANCE_LOADS (slp_instn).iterate (i, &load); ++i)\n+    {\n+      if (!load->load_permutation.exists ())\n+\treturn false;\n+      FOR_EACH_VEC_ELT (load->load_permutation, j, lidx)\n+\tif (lidx != node->load_permutation[j])\n+\t  return false;\n+    }\n+\n+  /* Check that the loads in the first sequence are different and there\n+     are no gaps between them.  */\n+  load_index = sbitmap_alloc (group_size);\n+  bitmap_clear (load_index);\n+  FOR_EACH_VEC_ELT (node->load_permutation, i, lidx)\n+    {\n+      if (bitmap_bit_p (load_index, lidx))\n+\t{\n+\t  sbitmap_free (load_index);\n+\t  return false;\n+\t}\n+      bitmap_set_bit (load_index, lidx);\n+    }\n+  for (i = 0; i < group_size; i++)\n+    if (!bitmap_bit_p (load_index, i))\n+      {\n+\tsbitmap_free (load_index);\n+\treturn false;\n+      }\n+  sbitmap_free (load_index);\n+\n+  /* This permutation is valid for reduction.  Since the order of the\n+     statements in the nodes is not important unless they are memory\n+     accesses, we can rearrange the statements in all the nodes\n+     according to the order of the loads.  */\n+  vect_slp_rearrange_stmts (SLP_INSTANCE_TREE (slp_instn), group_size,\n+\t\t\t    node->load_permutation);\n+\n+  /* We are done, no actual permutations need to be generated.  */\n+  FOR_EACH_VEC_ELT (SLP_INSTANCE_LOADS (slp_instn), i, node)\n+    SLP_TREE_LOAD_PERMUTATION (node).release ();\n+  return true;\n+}\n+\n /* Check if the required load permutations in the SLP instance\n    SLP_INSTN are supported.  */\n \n@@ -1307,7 +1368,6 @@ vect_supported_load_permutation_p (slp_instance slp_instn)\n {\n   unsigned int group_size = SLP_INSTANCE_GROUP_SIZE (slp_instn);\n   unsigned int i, j, k, next;\n-  sbitmap load_index;\n   slp_tree node;\n   gimple stmt, load, next_load, first_load;\n   struct data_reference *dr;\n@@ -1342,59 +1402,14 @@ vect_supported_load_permutation_p (slp_instance slp_instn)\n   stmt = SLP_TREE_SCALAR_STMTS (node)[0];\n \n   /* Reduction (there are no data-refs in the root).\n-     In reduction chain the order of the loads is important.  */\n+     In reduction chain the order of the loads is not important.  */\n   if (!STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt))\n       && !GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)))\n     {\n-      slp_tree load;\n-      unsigned int lidx;\n+      if (vect_attempt_slp_rearrange_stmts (slp_instn))\n+\treturn true;\n \n-      /* Compare all the permutation sequences to the first one.  We know\n-         that at least one load is permuted.  */\n-      node = SLP_INSTANCE_LOADS (slp_instn)[0];\n-      if (!node->load_permutation.exists ())\n-\treturn false;\n-      for (i = 1; SLP_INSTANCE_LOADS (slp_instn).iterate (i, &load); ++i)\n-\t{\n-\t  if (!load->load_permutation.exists ())\n-\t    return false;\n-\t  FOR_EACH_VEC_ELT (load->load_permutation, j, lidx)\n-\t    if (lidx != node->load_permutation[j])\n-\t      return false;\n-\t}\n-\n-      /* Check that the loads in the first sequence are different and there\n-\t are no gaps between them.  */\n-      load_index = sbitmap_alloc (group_size);\n-      bitmap_clear (load_index);\n-      FOR_EACH_VEC_ELT (node->load_permutation, i, lidx)\n-\t{\n-\t  if (bitmap_bit_p (load_index, lidx))\n-\t    {\n-\t      sbitmap_free (load_index);\n-\t      return false;\n-\t    }\n-\t  bitmap_set_bit (load_index, lidx);\n-\t}\n-      for (i = 0; i < group_size; i++)\n-\tif (!bitmap_bit_p (load_index, i))\n-\t  {\n-\t    sbitmap_free (load_index);\n-\t    return false;\n-\t  }\n-      sbitmap_free (load_index);\n-\n-      /* This permutation is valid for reduction.  Since the order of the\n-\t statements in the nodes is not important unless they are memory\n-\t accesses, we can rearrange the statements in all the nodes\n-\t according to the order of the loads.  */\n-      vect_slp_rearrange_stmts (SLP_INSTANCE_TREE (slp_instn), group_size,\n-\t\t\t\tnode->load_permutation);\n-\n-      /* We are done, no actual permutations need to be generated.  */\n-      FOR_EACH_VEC_ELT (SLP_INSTANCE_LOADS (slp_instn), i, node)\n-\tSLP_TREE_LOAD_PERMUTATION (node).release ();\n-      return true;\n+      /* Fallthru to general load permutation handling.  */\n     }\n \n   /* In basic block vectorization we allow any subchain of an interleaving"}, {"sha": "2f77e8448ee62441c7c39d73ddd8ab9fffdd6196", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b266b96856da702dbe957396adc6f242daed233b/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b266b96856da702dbe957396adc6f242daed233b/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=b266b96856da702dbe957396adc6f242daed233b", "patch": "@@ -5995,9 +5995,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n       if ((grouped_load\n \t   && (slp || PURE_SLP_STMT (stmt_info)))\n \t  && (group_size > nunits\n-\t      || nunits % group_size != 0\n-\t      /* We don't support load permutations.  */\n-\t      || slp_perm))\n+\t      || nunits % group_size != 0))\n \t{\n \t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t   \"unhandled strided group load\\n\");\n@@ -6294,6 +6292,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n       alias_off = build_int_cst (reference_alias_ptr_type (DR_REF (dr)), 0);\n       int nloads = nunits;\n       tree ltype = TREE_TYPE (vectype);\n+      auto_vec<tree> dr_chain;\n       if (slp)\n \t{\n \t  nloads = nunits / group_size;\n@@ -6303,7 +6302,8 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t    ltype = vectype;\n \t  ltype = build_aligned_type (ltype, TYPE_ALIGN (TREE_TYPE (vectype)));\n \t  ncopies = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n-\t  gcc_assert (!slp_perm);\n+\t  if (slp_perm)\n+\t    dr_chain.create (ncopies);\n \t}\n       for (j = 0; j < ncopies; j++)\n \t{\n@@ -6350,13 +6350,20 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t    }\n \n \t  if (slp)\n-\t    SLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt);\n+\t    {\n+\t      SLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt);\n+\t      if (slp_perm)\n+\t\tdr_chain.quick_push (gimple_assign_lhs (new_stmt));\n+\t    }\n \t  if (j == 0)\n \t    STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n \t  else\n \t    STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n \t  prev_stmt_info = vinfo_for_stmt (new_stmt);\n \t}\n+      if (slp_perm)\n+\tvect_transform_slp_perm_load (slp_node, dr_chain, gsi, vf,\n+\t\t\t\t      slp_node_instance, false);\n       return true;\n     }\n "}]}