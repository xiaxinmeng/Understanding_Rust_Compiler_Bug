{"sha": "aa7bda5f27458fd958226050a221713dc6a39d26", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWE3YmRhNWYyNzQ1OGZkOTU4MjI2MDUwYTIyMTcxM2RjNmEzOWQyNg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-05-23T19:37:03Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-05-23T19:37:03Z"}, "message": "name-lookup.c (find_namespace_binding): New.\n\n\t* name-lookup.c (find_namespace_binding): New.\n\t(pushdecl_maybe_friend_1): Use CP_DECL_CONTEXT.\n\t(set_identifier_type_value_with_scope): Use\n\tfind_namespace_binding.\n\t(find_binding, cp_binding_level_find_binding_for_name)\n\tbinding_for_name, namespace_binding_1): Delete.\n\t(push_overloaded_decl_1): Use CP_DECL_CONTEXT.\n\t(get_namespace_binding, set_namespace_binding)\n\tfinish_namespace_using_decl, unqualified_namespace_lookup_1,\n\tqualified_lookup_using_namespace, lookup_type_scope_1,\n\tlookup_name_innermost_nonclass_level_1): Use\n\tfind_namespace_binding.\n((--This line, and those below, will be ignored--\n\nM    cp/name-lookup.c\nM    cp/ChangeLog\n\nFrom-SVN: r248382", "tree": {"sha": "5179a0bfc0b8a828f200bbbc2b4f660bdf0fa534", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5179a0bfc0b8a828f200bbbc2b4f660bdf0fa534"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa7bda5f27458fd958226050a221713dc6a39d26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa7bda5f27458fd958226050a221713dc6a39d26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa7bda5f27458fd958226050a221713dc6a39d26", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa7bda5f27458fd958226050a221713dc6a39d26/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6131102ce3f1ac19a9c6637827b1f4dff9eea97b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6131102ce3f1ac19a9c6637827b1f4dff9eea97b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6131102ce3f1ac19a9c6637827b1f4dff9eea97b"}], "stats": {"total": 153, "additions": 58, "deletions": 95}, "files": [{"sha": "7d8ea1632e42acc231dbeccd68eabb5d66d4e8e0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa7bda5f27458fd958226050a221713dc6a39d26/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa7bda5f27458fd958226050a221713dc6a39d26/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=aa7bda5f27458fd958226050a221713dc6a39d26", "patch": "@@ -1,5 +1,16 @@\n 2017-05-23  Nathan Sidwell  <nathan@acm.org>\n \n+\t* name-lookup.c (find_namespace_binding): New.\n+\t(pushdecl_maybe_friend_1): Use CP_DECL_CONTEXT.\n+\t(set_identifier_type_value_with_scope): Use find_namespace_binding.\n+\t(find_binding, cp_binding_level_find_binding_for_name,\n+\tbinding_for_name, namespace_binding_1): Delete.\n+\t(push_overloaded_decl_1): Use CP_DECL_CONTEXT.\n+\t(get_namespace_binding, set_namespace_binding,\n+\tfinish_namespace_using_decl, unqualified_namespace_lookup_1,\n+\tqualified_lookup_using_namespace, lookup_type_scope_1,\n+\tlookup_name_innermost_nonclass_level_1): Use find_namespace_binding.\n+\n \tPR c++/80866\n \t* parser.c (cp_parser_template_id): Keep the lookup when stashing\n \tthe template_id."}, {"sha": "12024216bc81dd62cd9c66beb76a80a35a44c115", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 47, "deletions": 95, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa7bda5f27458fd958226050a221713dc6a39d26/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa7bda5f27458fd958226050a221713dc6a39d26/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=aa7bda5f27458fd958226050a221713dc6a39d26", "patch": "@@ -48,7 +48,6 @@ struct scope_binding {\n };\n #define EMPTY_SCOPE_BINDING { NULL_TREE, NULL_TREE }\n \n-static cxx_binding *binding_for_name (cp_binding_level *, tree);\n static tree push_overloaded_decl (tree, int, bool);\n static bool lookup_using_namespace (tree, struct scope_binding *, tree,\n \t\t\t\t    tree, int);\n@@ -62,6 +61,32 @@ static void consider_binding_level (tree name,\n static tree push_using_directive (tree);\n static void diagnose_name_conflict (tree, tree);\n \n+/* Find the binding for NAME in namespace NS.  If CREATE_P is true,\n+   make an empty binding if there wasn't one.  */\n+\n+static cxx_binding *\n+find_namespace_binding (tree ns, tree name, bool create_p = false)\n+{\n+  cp_binding_level *level = NAMESPACE_LEVEL (ns);\n+  cxx_binding *binding = IDENTIFIER_NAMESPACE_BINDINGS (name);\n+\n+  for (;binding; binding = binding->previous)\n+    if (binding->scope == level)\n+      return binding;\n+\n+  if (create_p)\n+    {\n+      binding = cxx_binding_make (NULL, NULL);\n+      binding->previous = IDENTIFIER_NAMESPACE_BINDINGS (name);\n+      binding->scope = level;\n+      binding->is_local = false;\n+      binding->value_is_inherited = false;\n+      IDENTIFIER_NAMESPACE_BINDINGS (name) = binding;\n+    }\n+\n+  return binding;\n+}\n+\n /* Add DECL to the list of things declared in B.  */\n \n static void\n@@ -1698,7 +1723,7 @@ pushdecl_maybe_friend_1 (tree x, bool is_friend)\n       /* In case this decl was explicitly namespace-qualified, look it\n \t up in its namespace context.  */\n       if (DECL_NAMESPACE_SCOPE_P (x) && namespace_bindings_p ())\n-\tt = get_namespace_binding (DECL_CONTEXT (x), name);\n+\tt = get_namespace_binding (CP_DECL_CONTEXT (x), name);\n       else\n \tt = lookup_name_innermost_nonclass_level (name);\n \n@@ -2702,9 +2727,9 @@ set_identifier_type_value_with_scope (tree id, tree decl, cp_binding_level *b)\n     }\n   else\n     {\n-      cxx_binding *binding =\n-\tbinding_for_name (NAMESPACE_LEVEL (current_namespace), id);\n-      gcc_assert (decl);\n+      cxx_binding *binding\n+\t= find_namespace_binding (current_namespace, id, true);\n+\n       if (binding->value)\n \tsupplement_binding (binding, decl);\n       else\n@@ -2811,55 +2836,6 @@ make_lambda_name (void)\n   return get_identifier (buf);\n }\n \n-/* Return (from the stack of) the BINDING, if any, established at SCOPE.  */\n-\n-static inline cxx_binding *\n-find_binding (cp_binding_level *scope, cxx_binding *binding)\n-{\n-  for (; binding != NULL; binding = binding->previous)\n-    if (binding->scope == scope)\n-      return binding;\n-\n-  return (cxx_binding *)0;\n-}\n-\n-/* Return the binding for NAME in SCOPE, if any.  Otherwise, return NULL.  */\n-\n-static inline cxx_binding *\n-cp_binding_level_find_binding_for_name (cp_binding_level *scope, tree name)\n-{\n-  cxx_binding *b = IDENTIFIER_NAMESPACE_BINDINGS (name);\n-  if (b)\n-    {\n-      /* Fold-in case where NAME is used only once.  */\n-      if (scope == b->scope && b->previous == NULL)\n-\treturn b;\n-      return find_binding (scope, b);\n-    }\n-  return NULL;\n-}\n-\n-/* Always returns a binding for name in scope.  If no binding is\n-   found, make a new one.  */\n-\n-static cxx_binding *\n-binding_for_name (cp_binding_level *scope, tree name)\n-{\n-  cxx_binding *result;\n-\n-  result = cp_binding_level_find_binding_for_name (scope, name);\n-  if (result)\n-    return result;\n-  /* Not found, make a new one.  */\n-  result = cxx_binding_make (NULL, NULL);\n-  result->previous = IDENTIFIER_NAMESPACE_BINDINGS (name);\n-  result->scope = scope;\n-  result->is_local = false;\n-  result->value_is_inherited = false;\n-  IDENTIFIER_NAMESPACE_BINDINGS (name) = result;\n-  return result;\n-}\n-\n /* Insert another USING_DECL into the current binding level, returning\n    this declaration. If this is a redeclaration, do nothing, and\n    return NULL_TREE if this not in namespace scope (in namespace\n@@ -2978,7 +2954,7 @@ push_overloaded_decl_1 (tree decl, int flags, bool is_friend)\n   int doing_global = (namespace_bindings_p () || !(flags & PUSH_LOCAL));\n \n   if (doing_global)\n-    old = get_namespace_binding (DECL_CONTEXT (decl), name);\n+    old = get_namespace_binding (CP_DECL_CONTEXT (decl), name);\n   else\n     old = lookup_name_innermost_nonclass_level (name);\n \n@@ -3965,25 +3941,6 @@ do_class_using_decl (tree scope, tree name)\n }\n \n \f\n-/* Return the binding value for name in scope.  */\n-\n-\n-static tree\n-namespace_binding_1 (tree scope, tree name)\n-{\n-  cxx_binding *binding;\n-\n-  if (SCOPE_FILE_SCOPE_P (scope))\n-    scope = global_namespace;\n-  else\n-    /* Unnecessary for the global namespace because it can't be an alias. */\n-    scope = ORIGINAL_NAMESPACE (scope);\n-\n-  binding = cp_binding_level_find_binding_for_name (NAMESPACE_LEVEL (scope), name);\n-\n-  return binding ? binding->value : NULL_TREE;\n-}\n-\n /* Return the binding for NAME in NS.  If NS is NULL, look in\n    global_namespace.  */\n \n@@ -3993,28 +3950,26 @@ get_namespace_binding (tree ns, tree name)\n   bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n   if (!ns)\n     ns = global_namespace;\n-  tree ret = namespace_binding_1 (ns, name);\n+  cxx_binding *binding = find_namespace_binding (ns, name);\n   timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n-  return ret;\n+  return binding ? binding->value : NULL_TREE;\n }\n \n static void\n set_namespace_binding (tree scope, tree name, tree val)\n {\n-  cxx_binding *b;\n-\n   if (scope == NULL_TREE)\n     scope = global_namespace;\n-  b = binding_for_name (NAMESPACE_LEVEL (scope), name);\n-  if (!b->value\n+  cxx_binding *binding = find_namespace_binding (scope, name, true);\n+  if (!binding->value\n       /* For templates and using we create a single element OVERLOAD.\n \t Look for the chain to know whether this is really augmenting\n \t an existing overload.  */\n       || (TREE_CODE (val) == OVERLOAD && OVL_CHAIN (val))\n       || val == error_mark_node)\n-    b->value = val;\n+    binding->value = val;\n   else\n-    supplement_binding (b, val);\n+    supplement_binding (binding, val);\n }\n \n /* Set value binding og NAME in the global namespace to VAL.  Does not\n@@ -4366,7 +4321,7 @@ finish_namespace_using_decl (tree decl, tree scope, tree name)\n     return;\n \n   cxx_binding *binding\n-    = binding_for_name (NAMESPACE_LEVEL (current_namespace), name);\n+    = find_namespace_binding (current_namespace, name, true);\n \n   tree value = binding->value;\n   tree type = binding->type;\n@@ -4917,8 +4872,7 @@ unqualified_namespace_lookup_1 (tree name, int flags)\n   for (; !val; scope = CP_DECL_CONTEXT (scope))\n     {\n       struct scope_binding binding = EMPTY_SCOPE_BINDING;\n-      cxx_binding *b =\n-\t cp_binding_level_find_binding_for_name (NAMESPACE_LEVEL (scope), name);\n+      cxx_binding *b = find_namespace_binding (scope, name);\n \n       if (b)\n \tambiguous_decl (&binding, b, flags);\n@@ -5021,8 +4975,7 @@ lookup_using_namespace (tree name, struct scope_binding *val,\n     if (TREE_VALUE (iter) == scope)\n       {\n \ttree used = ORIGINAL_NAMESPACE (TREE_PURPOSE (iter));\n-\tcxx_binding *val1 =\n-\t  cp_binding_level_find_binding_for_name (NAMESPACE_LEVEL (used), name);\n+\tcxx_binding *val1 = find_namespace_binding (used, name);\n \t/* Resolve ambiguities.  */\n \tif (val1)\n \t  ambiguous_decl (val, val1, flags);\n@@ -5092,8 +5045,7 @@ qualified_lookup_using_namespace (tree name, tree scope,\n \t    continue;\n \t  vec_safe_push (seen_inline, scope);\n \n-\t  binding =\n-\t    cp_binding_level_find_binding_for_name (NAMESPACE_LEVEL (scope), name);\n+\t  binding = find_namespace_binding (scope, name);\n \t  if (binding)\n \t    {\n \t      ambiguous_decl (result, binding, flags);\n@@ -5610,8 +5562,7 @@ lookup_type_scope_1 (tree name, tag_scope scope)\n   /* Look in namespace scope.  */\n   if (!val)\n     {\n-      iter = cp_binding_level_find_binding_for_name\n-\t       (NAMESPACE_LEVEL (current_decl_namespace ()), name);\n+      iter = find_namespace_binding (current_decl_namespace (), name);\n \n       if (iter)\n \t{\n@@ -5668,13 +5619,14 @@ static tree\n lookup_name_innermost_nonclass_level_1 (tree name)\n {\n   cp_binding_level *b = innermost_nonclass_level ();\n+  cxx_binding *binding = NULL;\n \n   if (b->kind == sk_namespace)\n-    return namespace_binding_1 (current_namespace, name);\n-  else if (cxx_binding *binding = find_local_binding (b, name))\n-    return binding->value;\n+    binding = find_namespace_binding (current_namespace, name);\n   else\n-    return NULL_TREE;\n+    binding = find_local_binding (b, name);\n+\n+  return binding ? binding->value : NULL_TREE;\n }\n \n /* Wrapper for lookup_name_innermost_nonclass_level_1.  */"}]}