{"sha": "8403445abac6b5d1b03903c3f23fd9a28c550438", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQwMzQ0NWFiYWM2YjVkMWIwMzkwM2MzZjIzZmQ5YTI4YzU1MDQzOA==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@bigpond.net.au", "date": "2003-02-23T22:19:39Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2003-02-23T22:19:39Z"}, "message": "calls.c (store_one_arg): Revert 1999-02-16 change.\n\n\t* calls.c (store_one_arg): Revert 1999-02-16 change.  Revert\n\t2000-12-17 change.  Pass EXPAND_STACK_PARM to expand_expr.\n\t* expr.h (enum expand_modifier): Define EXPAND_STACK_PARM.\n\t(enum block_op_methods): Reorder for better store_expr optimization.\n\t* expr.c (store_expr): Test bit 1 of \"want_value\" for call param\n\tstores, test bit 0 for original want_value meaning.  Pass\n\tBLOCK_OP_CALL_PARM to emit_block_move when bit 1 set.  Adjust\n\trecursive calls, and calls to expand_param.\n\t(expand_expr): Handle EXPAND_STACK_PARM modifier.  When cse\n\texpected, set target to 0 rather than to subtarget.  Formatting.\n\nFrom-SVN: r63337", "tree": {"sha": "3072cb4fe732b3df37e851d737c014b16029b598", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3072cb4fe732b3df37e851d737c014b16029b598"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8403445abac6b5d1b03903c3f23fd9a28c550438", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8403445abac6b5d1b03903c3f23fd9a28c550438", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8403445abac6b5d1b03903c3f23fd9a28c550438", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8403445abac6b5d1b03903c3f23fd9a28c550438/comments", "author": null, "committer": null, "parents": [{"sha": "ef9063812820167f826b3f7fce2827826599d80c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef9063812820167f826b3f7fce2827826599d80c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef9063812820167f826b3f7fce2827826599d80c"}], "stats": {"total": 272, "additions": 171, "deletions": 101}, "files": [{"sha": "0e92c85ee9ba98c2dbb1ed056aba9d99092eee08", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8403445abac6b5d1b03903c3f23fd9a28c550438/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8403445abac6b5d1b03903c3f23fd9a28c550438/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8403445abac6b5d1b03903c3f23fd9a28c550438", "patch": "@@ -1,3 +1,16 @@\n+2003-02-24  Alan Modra  <amodra@bigpond.net.au>\n+\n+\t* calls.c (store_one_arg): Revert 1999-02-16 change.  Revert\n+\t2000-12-17 change.  Pass EXPAND_STACK_PARM to expand_expr.\n+\t* expr.h (enum expand_modifier): Define EXPAND_STACK_PARM.\n+\t(enum block_op_methods): Reorder for better store_expr optimization.\n+\t* expr.c (store_expr): Test bit 1 of \"want_value\" for call param\n+\tstores, test bit 0 for original want_value meaning.  Pass\n+\tBLOCK_OP_CALL_PARM to emit_block_move when bit 1 set.  Adjust\n+\trecursive calls, and calls to expand_param.\n+\t(expand_expr): Handle EXPAND_STACK_PARM modifier.  When cse\n+\texpected, set target to 0 rather than to subtarget.  Formatting.\n+\n 2003-02-23  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* gcse.c (cprop_jump): Use the REG_EQUAL note if available."}, {"sha": "abd88fe6c72b37a46c2e80b4945df3dbe383b4b5", "filename": "gcc/calls.c", "status": "modified", "additions": 7, "deletions": 39, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8403445abac6b5d1b03903c3f23fd9a28c550438/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8403445abac6b5d1b03903c3f23fd9a28c550438/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=8403445abac6b5d1b03903c3f23fd9a28c550438", "patch": "@@ -4341,13 +4341,6 @@ store_one_arg (arg, argblock, flags, variable_size, reg_parm_stack_space)\n \t\t}\n \t    }\n \t}\n-      /* Now that we have saved any slots that will be overwritten by this\n-\t store, mark all slots this store will use.  We must do this before\n-\t we actually expand the argument since the expansion itself may\n-\t trigger library calls which might need to use the same stack slot.  */\n-      if (argblock && ! variable_size && arg->stack)\n-\tfor (i = lower_bound; i < upper_bound; i++)\n-\t  stack_usage_map[i] = 1;\n     }\n \n   /* If this isn't going to be placed on both the stack and in registers,\n@@ -4400,7 +4393,7 @@ store_one_arg (arg, argblock, flags, variable_size, reg_parm_stack_space)\n \t\t\t\t(partial\n \t\t\t\t || TYPE_MODE (TREE_TYPE (pval)) != arg->mode)\n \t\t\t\t? NULL_RTX : arg->stack,\n-\t\t\t\tVOIDmode, 0);\n+\t\t\t\tVOIDmode, EXPAND_STACK_PARM);\n \n       /* If we are promoting object (or for any other reason) the mode\n \t doesn't agree, convert the mode.  */\n@@ -4543,37 +4536,6 @@ store_one_arg (arg, argblock, flags, variable_size, reg_parm_stack_space)\n \t    }\n \t}\n \n-      /* Special handling is required if part of the parameter lies in the\n-\t register parameter area.  The argument may be copied into the stack\n-\t slot using memcpy(), but the original contents of the register\n-\t parameter area will be restored after the memcpy() call.\n-\n-\t To ensure that the part that lies in the register parameter area\n-\t is copied correctly, we emit a separate push for that part.  This\n-\t push should be small enough to avoid a call to memcpy().  */\n-#ifndef STACK_PARMS_IN_REG_PARM_AREA\n-      if (arg->reg && arg->pass_on_stack)\n-#else\n-      if (1)\n-#endif\n-\t{\n-\t  if (arg->offset.constant < reg_parm_stack_space && arg->offset.var)\n-\t    error (\"variable offset is passed partially in stack and in reg\");\n-\t  else if (arg->offset.constant < reg_parm_stack_space && arg->size.var)\n-\t    error (\"variable size is passed partially in stack and in reg\");\n-\t  else if (arg->offset.constant < reg_parm_stack_space \n-\t      && ((arg->offset.constant + arg->size.constant) \n-\t\t   > reg_parm_stack_space))\n-          {\n-\t    rtx size_rtx1 = GEN_INT (reg_parm_stack_space - arg->offset.constant);\n-\t    emit_push_insn (arg->value, arg->mode, TREE_TYPE (pval), size_rtx1,\n-\t\t            parm_align, partial, reg, excess, argblock,\n-\t\t\t    ARGS_SIZE_RTX (arg->offset), reg_parm_stack_space,\n-\t\t            ARGS_SIZE_RTX (arg->alignment_pad));\n-\t  }\n-\t}\n-\t\n-\n       emit_push_insn (arg->value, arg->mode, TREE_TYPE (pval), size_rtx,\n \t\t      parm_align, partial, reg, excess, argblock,\n \t\t      ARGS_SIZE_RTX (arg->offset), reg_parm_stack_space,\n@@ -4591,6 +4553,12 @@ store_one_arg (arg, argblock, flags, variable_size, reg_parm_stack_space)\n \targ->value = arg->stack_slot;\n     }\n \n+  /* Mark all slots this store used.  */\n+  if (ACCUMULATE_OUTGOING_ARGS && !(flags & ECF_SIBCALL)\n+      && argblock && ! variable_size && arg->stack)\n+    for (i = lower_bound; i < upper_bound; i++)\n+      stack_usage_map[i] = 1;\n+\n   /* Once we have pushed something, pops can't safely\n      be deferred during the rest of the arguments.  */\n   NO_DEFER_POP;"}, {"sha": "d8f4c7967eaf2a255d43379a585fbe4bb140f5bc", "filename": "gcc/expr.c", "status": "modified", "additions": 143, "deletions": 57, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8403445abac6b5d1b03903c3f23fd9a28c550438/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8403445abac6b5d1b03903c3f23fd9a28c550438/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=8403445abac6b5d1b03903c3f23fd9a28c550438", "patch": "@@ -4256,7 +4256,7 @@ expand_assignment (to, from, want_value, suggest_reg)\n    and storing the value into TARGET.\n    TARGET may contain a QUEUED rtx.\n \n-   If WANT_VALUE is nonzero, return a copy of the value\n+   If WANT_VALUE & 1 is nonzero, return a copy of the value\n    not in TARGET, so that we can be sure to use the proper\n    value in a containing expression even if TARGET has something\n    else stored in it.  If possible, we copy the value through a pseudo\n@@ -4271,9 +4271,12 @@ expand_assignment (to, from, want_value, suggest_reg)\n    with no sequence point.  Will other languages need this to\n    be more thorough?\n \n-   If WANT_VALUE is 0, we return NULL, to make sure\n+   If WANT_VALUE & 1 is 0, we return NULL, to make sure\n    to catch quickly any cases where the caller uses the value\n-   and fails to set WANT_VALUE.  */\n+   and fails to set WANT_VALUE.\n+\n+   If WANT_VALUE & 2 is set, this is a store into a call param on the\n+   stack, and block moves may need to be treated specially.  */\n \n rtx\n store_expr (exp, target, want_value)\n@@ -4289,7 +4292,8 @@ store_expr (exp, target, want_value)\n     {\n       /* Perform first part of compound expression, then assign from second\n \t part.  */\n-      expand_expr (TREE_OPERAND (exp, 0), const0_rtx, VOIDmode, 0);\n+      expand_expr (TREE_OPERAND (exp, 0), const0_rtx, VOIDmode,\n+\t\t   want_value & 2 ? EXPAND_STACK_PARM : EXPAND_NORMAL);\n       emit_queue ();\n       return store_expr (TREE_OPERAND (exp, 1), target, want_value);\n     }\n@@ -4309,20 +4313,20 @@ store_expr (exp, target, want_value)\n       NO_DEFER_POP;\n       jumpifnot (TREE_OPERAND (exp, 0), lab1);\n       start_cleanup_deferral ();\n-      store_expr (TREE_OPERAND (exp, 1), target, 0);\n+      store_expr (TREE_OPERAND (exp, 1), target, want_value & 2);\n       end_cleanup_deferral ();\n       emit_queue ();\n       emit_jump_insn (gen_jump (lab2));\n       emit_barrier ();\n       emit_label (lab1);\n       start_cleanup_deferral ();\n-      store_expr (TREE_OPERAND (exp, 2), target, 0);\n+      store_expr (TREE_OPERAND (exp, 2), target, want_value & 2);\n       end_cleanup_deferral ();\n       emit_queue ();\n       emit_label (lab2);\n       OK_DEFER_POP;\n \n-      return want_value ? target : NULL_RTX;\n+      return want_value & 1 ? target : NULL_RTX;\n     }\n   else if (queued_subexp_p (target))\n     /* If target contains a postincrement, let's not risk\n@@ -4332,18 +4336,24 @@ store_expr (exp, target, want_value)\n \t{\n \t  /* Expand EXP into a new pseudo.  */\n \t  temp = gen_reg_rtx (GET_MODE (target));\n-\t  temp = expand_expr (exp, temp, GET_MODE (target), 0);\n+\t  temp = expand_expr (exp, temp, GET_MODE (target),\n+\t\t\t      (want_value & 2\n+\t\t\t       ? EXPAND_STACK_PARM : EXPAND_NORMAL));\n \t}\n       else\n-\ttemp = expand_expr (exp, NULL_RTX, GET_MODE (target), 0);\n+\ttemp = expand_expr (exp, NULL_RTX, GET_MODE (target),\n+\t\t\t    (want_value & 2\n+\t\t\t     ? EXPAND_STACK_PARM : EXPAND_NORMAL));\n \n       /* If target is volatile, ANSI requires accessing the value\n \t *from* the target, if it is accessed.  So make that happen.\n \t In no case return the target itself.  */\n-      if (! MEM_VOLATILE_P (target) && want_value)\n+      if (! MEM_VOLATILE_P (target) && (want_value & 1) != 0)\n \tdont_return_target = 1;\n     }\n-  else if (want_value && GET_CODE (target) == MEM && ! MEM_VOLATILE_P (target)\n+  else if ((want_value & 1) != 0\n+\t   && GET_CODE (target) == MEM\n+\t   && ! MEM_VOLATILE_P (target)\n \t   && GET_MODE (target) != BLKmode)\n     /* If target is in memory and caller wants value in a register instead,\n        arrange that.  Pass TARGET as target for expand_expr so that,\n@@ -4352,7 +4362,8 @@ store_expr (exp, target, want_value)\n        Don't do this if TARGET is volatile because we are supposed\n        to write it and then read it.  */\n     {\n-      temp = expand_expr (exp, target, GET_MODE (target), 0);\n+      temp = expand_expr (exp, target, GET_MODE (target),\n+\t\t\t  want_value & 2 ? EXPAND_STACK_PARM : EXPAND_NORMAL);\n       if (GET_MODE (temp) != BLKmode && GET_MODE (temp) != VOIDmode)\n \t{\n \t  /* If TEMP is already in the desired TARGET, only copy it from\n@@ -4379,7 +4390,8 @@ store_expr (exp, target, want_value)\n \t the extend.  But don't do this if the type of EXP is a subtype\n \t of something else since then the conversion might involve\n \t more than just converting modes.  */\n-      if (! want_value && INTEGRAL_TYPE_P (TREE_TYPE (exp))\n+      if ((want_value & 1) == 0\n+\t  && INTEGRAL_TYPE_P (TREE_TYPE (exp))\n \t  && TREE_TYPE (TREE_TYPE (exp)) == 0)\n \t{\n \t  if (TREE_UNSIGNED (TREE_TYPE (exp))\n@@ -4396,14 +4408,15 @@ store_expr (exp, target, want_value)\n \t  inner_target = SUBREG_REG (target);\n \t}\n \n-      temp = expand_expr (exp, inner_target, VOIDmode, 0);\n+      temp = expand_expr (exp, inner_target, VOIDmode,\n+\t\t\t  want_value & 2 ? EXPAND_STACK_PARM : EXPAND_NORMAL);\n \n       /* If TEMP is a MEM and we want a result value, make the access\n \t now so it gets done only once.  Strictly speaking, this is \n \t only necessary if the MEM is volatile, or if the address \n \t overlaps TARGET.  But not performing the load twice also\n \t reduces the amount of rtl we generate and then have to CSE.  */\n-      if (GET_CODE (temp) == MEM && want_value)\n+      if (GET_CODE (temp) == MEM && (want_value & 1) != 0)\n \ttemp = copy_to_reg (temp);\n \n       /* If TEMP is a VOIDmode constant, use convert_modes to make\n@@ -4424,7 +4437,7 @@ store_expr (exp, target, want_value)\n \t target.  Otherwise, the caller might get confused by a result whose\n \t mode is larger than expected.  */\n \n-      if (want_value && GET_MODE (temp) != GET_MODE (target))\n+      if ((want_value & 1) != 0 && GET_MODE (temp) != GET_MODE (target))\n \t{\n \t  if (GET_MODE (temp) != VOIDmode)\n \t    {\n@@ -4439,11 +4452,12 @@ store_expr (exp, target, want_value)\n \t\t\t\t  temp, SUBREG_PROMOTED_UNSIGNED_P (target));\n \t}\n \n-      return want_value ? temp : NULL_RTX;\n+      return want_value & 1 ? temp : NULL_RTX;\n     }\n   else\n     {\n-      temp = expand_expr (exp, target, GET_MODE (target), 0);\n+      temp = expand_expr (exp, target, GET_MODE (target),\n+\t\t\t  want_value & 2 ? EXPAND_STACK_PARM : EXPAND_NORMAL);\n       /* Return TARGET if it's a specified hardware register.\n \t If TARGET is a volatile mem ref, either return TARGET\n \t or return a reg copied *from* TARGET; ANSI requires this.\n@@ -4455,7 +4469,7 @@ store_expr (exp, target, want_value)\n \t    && REGNO (target) < FIRST_PSEUDO_REGISTER)\n \t  && !(GET_CODE (target) == MEM && MEM_VOLATILE_P (target))\n \t  && ! rtx_equal_p (temp, target)\n-\t  && (CONSTANT_P (temp) || want_value))\n+\t  && (CONSTANT_P (temp) || (want_value & 1) != 0))\n \tdont_return_target = 1;\n     }\n \n@@ -4526,21 +4540,27 @@ store_expr (exp, target, want_value)\n \n \t  if (GET_CODE (size) == CONST_INT\n \t      && INTVAL (size) < TREE_STRING_LENGTH (exp))\n-\t    emit_block_move (target, temp, size, BLOCK_OP_NORMAL);\n+\t    emit_block_move (target, temp, size,\n+\t\t\t     (want_value & 2\n+\t\t\t      ? BLOCK_OP_CALL_PARM : BLOCK_OP_NORMAL));\n \t  else\n \t    {\n \t      /* Compute the size of the data to copy from the string.  */\n \t      tree copy_size\n \t\t= size_binop (MIN_EXPR,\n \t\t\t      make_tree (sizetype, size),\n \t\t\t      size_int (TREE_STRING_LENGTH (exp)));\n-\t      rtx copy_size_rtx = expand_expr (copy_size, NULL_RTX,\n-\t\t\t\t\t       VOIDmode, 0);\n+\t      rtx copy_size_rtx\n+\t\t= expand_expr (copy_size, NULL_RTX, VOIDmode,\n+\t\t\t       (want_value & 2\n+\t\t\t\t? EXPAND_STACK_PARM : EXPAND_NORMAL));\n \t      rtx label = 0;\n \n \t      /* Copy that much.  */\n \t      copy_size_rtx = convert_to_mode (ptr_mode, copy_size_rtx, 0);\n-\t      emit_block_move (target, temp, copy_size_rtx, BLOCK_OP_NORMAL);\n+\t      emit_block_move (target, temp, copy_size_rtx,\n+\t\t\t       (want_value & 2\n+\t\t\t\t? BLOCK_OP_CALL_PARM : BLOCK_OP_NORMAL));\n \n \t      /* Figure out how much is left in TARGET that we have to clear.\n \t\t Do all calculations in ptr_mode.  */\n@@ -4581,13 +4601,15 @@ store_expr (exp, target, want_value)\n       else if (GET_CODE (target) == PARALLEL)\n \temit_group_load (target, temp, int_size_in_bytes (TREE_TYPE (exp)));\n       else if (GET_MODE (temp) == BLKmode)\n-\temit_block_move (target, temp, expr_size (exp), BLOCK_OP_NORMAL);\n+\temit_block_move (target, temp, expr_size (exp),\n+\t\t\t (want_value & 2\n+\t\t\t  ? BLOCK_OP_CALL_PARM : BLOCK_OP_NORMAL));\n       else\n \temit_move_insn (target, temp);\n     }\n \n   /* If we don't want a value, return NULL_RTX.  */\n-  if (! want_value)\n+  if ((want_value & 1) == 0)\n     return NULL_RTX;\n \n   /* If we are supposed to return TEMP, do so as long as it isn't a MEM.\n@@ -4596,7 +4618,8 @@ store_expr (exp, target, want_value)\n     return temp;\n \n   /* Return TARGET itself if it is a hard register.  */\n-  else if (want_value && GET_MODE (target) != BLKmode\n+  else if ((want_value & 1) != 0\n+\t   && GET_MODE (target) != BLKmode\n \t   && ! (GET_CODE (target) == REG\n \t\t && REGNO (target) < FIRST_PSEUDO_REGISTER))\n     return copy_to_reg (target);\n@@ -6410,7 +6433,14 @@ find_placeholder (exp, plist)\n \n    EXPAND_CONST_ADDRESS says that it is okay to return a MEM\n    with a constant address even if that address is not normally legitimate.\n-   EXPAND_INITIALIZER and EXPAND_SUM also have this effect.  */\n+   EXPAND_INITIALIZER and EXPAND_SUM also have this effect.\n+\n+   EXPAND_STACK_PARM is used when expanding to a TARGET on the stack for\n+   a call parameter.  Such targets require special care as we haven't yet\n+   marked TARGET so that it's safe from being trashed by libcalls.  We\n+   don't want to use TARGET for anything but the final result;\n+   Intermediate values must go elsewhere.   Additionally, calls to\n+   emit_block_move will be flagged with BLOCK_OP_CALL_PARM.  */\n \n rtx\n expand_expr (exp, target, tmode, modifier)\n@@ -6555,7 +6585,7 @@ expand_expr (exp, target, tmode, modifier)\n       && (GET_CODE (target) != REG || REGNO (target) < FIRST_PSEUDO_REGISTER)\n       && ! (code == CONSTRUCTOR && GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n       && ! (code == CALL_EXPR && aggregate_value_p (exp)))\n-    target = subtarget;\n+    target = 0;\n \n   switch (code)\n     {\n@@ -6741,7 +6771,7 @@ expand_expr (exp, target, tmode, modifier)\n       return temp;\n \n     case CONST_DECL:\n-      return expand_expr (DECL_INITIAL (exp), target, VOIDmode, 0);\n+      return expand_expr (DECL_INITIAL (exp), target, VOIDmode, modifier);\n \n     case REAL_CST:\n       /* If optimized, generate immediate CONST_DOUBLE\n@@ -6857,7 +6887,8 @@ expand_expr (exp, target, tmode, modifier)\n \t  if (temp == const0_rtx)\n \t    expand_expr (TREE_OPERAND (exp, 0), const0_rtx, VOIDmode, 0);\n \t  else\n-\t    store_expr (TREE_OPERAND (exp, 0), temp, 0);\n+\t    store_expr (TREE_OPERAND (exp, 0), temp,\n+\t\t\tmodifier == EXPAND_STACK_PARM ? 2 : 0);\n \n \t  TREE_USED (exp) = 1;\n \t}\n@@ -7042,7 +7073,8 @@ expand_expr (exp, target, tmode, modifier)\n \t  /* Handle calls that pass values in multiple non-contiguous\n \t     locations.  The Irix 6 ABI has examples of this.  */\n \t  if (target == 0 || ! safe_from_p (target, exp, 1)\n-\t      || GET_CODE (target) == PARALLEL)\n+\t      || GET_CODE (target) == PARALLEL\n+\t      || modifier == EXPAND_STACK_PARM)\n \t    target\n \t      = assign_temp (build_qualified_type (type,\n \t\t\t\t\t\t   (TYPE_QUALS (type)\n@@ -7216,6 +7248,9 @@ expand_expr (exp, target, tmode, modifier)\n \t\t\t&& (GET_MODE_BITSIZE (DECL_MODE (TREE_PURPOSE (elt)))\n \t\t\t    <= HOST_BITS_PER_WIDE_INT))))\n \t      {\n+\t\tif (DECL_BIT_FIELD (TREE_PURPOSE (elt))\n+\t\t    && modifier == EXPAND_STACK_PARM)\n+\t\t  target = 0;\n \t\top0 = expand_expr (TREE_VALUE (elt), target, tmode, modifier);\n \t\tif (DECL_BIT_FIELD (TREE_PURPOSE (elt)))\n \t\t  {\n@@ -7270,10 +7305,12 @@ expand_expr (exp, target, tmode, modifier)\n \t\t\t (TREE_CODE (TREE_TYPE (tem)) == UNION_TYPE\n \t\t\t  && (TREE_CODE (TYPE_SIZE (TREE_TYPE (tem)))\n \t\t\t      != INTEGER_CST)\n+\t\t\t  && modifier != EXPAND_STACK_PARM\n \t\t\t  ? target : NULL_RTX),\n \t\t\t VOIDmode,\n \t\t\t (modifier == EXPAND_INITIALIZER\n-\t\t\t  || modifier == EXPAND_CONST_ADDRESS)\n+\t\t\t  || modifier == EXPAND_CONST_ADDRESS\n+\t\t\t  || modifier == EXPAND_STACK_PARM)\n \t\t\t ? modifier : EXPAND_NORMAL);\n \n \t/* If this is a constant, put it into a register if it is a\n@@ -7290,7 +7327,8 @@ expand_expr (exp, target, tmode, modifier)\n \n \tif (offset != 0)\n \t  {\n-\t    rtx offset_rtx = expand_expr (offset, NULL_RTX, VOIDmode, EXPAND_SUM);\n+\t    rtx offset_rtx = expand_expr (offset, NULL_RTX, VOIDmode,\n+\t\t\t\t\t  EXPAND_SUM);\n \n \t    /* If this object is in a register, put it into memory.\n \t       This case can't occur in C, but can in Ada if we have\n@@ -7426,7 +7464,8 @@ expand_expr (exp, target, tmode, modifier)\n \t\temit_block_move (target, op0,\n \t\t\t\t GEN_INT ((bitsize + BITS_PER_UNIT - 1)\n \t\t\t\t\t  / BITS_PER_UNIT),\n-\t\t\t\t BLOCK_OP_NORMAL);\n+\t\t\t\t (modifier == EXPAND_STACK_PARM\n+\t\t\t\t  ? BLOCK_OP_CALL_PARM : BLOCK_OP_NORMAL));\n \n \t\treturn target;\n \t      }\n@@ -7436,8 +7475,10 @@ expand_expr (exp, target, tmode, modifier)\n \t    if (GET_CODE (op0) == MEM && GET_CODE (XEXP (op0, 0)) == REG)\n \t      mark_reg_pointer (XEXP (op0, 0), MEM_ALIGN (op0));\n \n-\t    op0 = extract_bit_field (op0, bitsize, bitpos,\n-\t\t\t\t     unsignedp, target, ext_mode, ext_mode,\n+\t    op0 = extract_bit_field (op0, bitsize, bitpos, unsignedp,\n+\t\t\t\t     (modifier == EXPAND_STACK_PARM\n+\t\t\t\t      ? NULL_RTX : target),\n+\t\t\t\t     ext_mode, ext_mode,\n \t\t\t\t     int_size_in_bytes (TREE_TYPE (tem)));\n \n \t    /* If the result is a record type and BITSIZE is narrower than\n@@ -7681,8 +7722,8 @@ expand_expr (exp, target, tmode, modifier)\n \t{\n \t  if (DECL_BUILT_IN_CLASS (TREE_OPERAND (TREE_OPERAND (exp, 0), 0))\n \t      == BUILT_IN_FRONTEND)\n-\t    return (*lang_hooks.expand_expr)\n-\t      (exp, original_target, tmode, modifier);\n+\t    return (*lang_hooks.expand_expr) (exp, original_target,\n+\t\t\t\t\t      tmode, modifier);\n \t  else\n \t    return expand_builtin (exp, target, subtarget, tmode, ignore);\n \t}\n@@ -7718,7 +7759,8 @@ expand_expr (exp, target, tmode, modifier)\n \t  if (GET_CODE (target) == MEM)\n \t    /* Store data into beginning of memory target.  */\n \t    store_expr (TREE_OPERAND (exp, 0),\n-\t\t\tadjust_address (target, TYPE_MODE (valtype), 0), 0);\n+\t\t\tadjust_address (target, TYPE_MODE (valtype), 0),\n+\t\t\tmodifier == EXPAND_STACK_PARM ? 2 : 0);\n \n \t  else if (GET_CODE (target) == REG)\n \t    /* Store this field into a union of the proper type.  */\n@@ -7843,7 +7885,8 @@ expand_expr (exp, target, tmode, modifier)\n \t      if (GET_MODE (op0) == BLKmode)\n \t\temit_block_move (new_with_op0_mode, op0,\n \t\t\t\t GEN_INT (GET_MODE_SIZE (TYPE_MODE (type))),\n-\t\t\t\t BLOCK_OP_NORMAL);\n+\t\t\t\t (modifier == EXPAND_STACK_PARM\n+\t\t\t\t  ? BLOCK_OP_CALL_PARM : BLOCK_OP_NORMAL));\n \t      else\n \t\temit_move_insn (new_with_op0_mode, op0);\n \n@@ -7895,6 +7938,8 @@ expand_expr (exp, target, tmode, modifier)\n       if (modifier == EXPAND_SUM || modifier == EXPAND_INITIALIZER\n \t  || (mode == ptr_mode && (unsignedp || ! flag_trapv)))\n \t{\n+\t  if (modifier == EXPAND_STACK_PARM)\n+\t    target = 0;\n \t  if (TREE_CODE (TREE_OPERAND (exp, 0)) == INTEGER_CST\n \t      && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n \t      && TREE_CONSTANT (TREE_OPERAND (exp, 1)))\n@@ -8117,6 +8162,9 @@ expand_expr (exp, target, tmode, modifier)\n       if (! safe_from_p (subtarget, TREE_OPERAND (exp, 1), 1))\n \tsubtarget = 0;\n \n+      if (modifier == EXPAND_STACK_PARM)\n+\ttarget = 0;\n+\n       /* Check for multiplying things that have been extended\n \t from a narrower type.  If this machine supports multiplying\n \t in that narrower type with a result in the desired type,\n@@ -8200,6 +8248,8 @@ expand_expr (exp, target, tmode, modifier)\n     case EXACT_DIV_EXPR:\n       if (! safe_from_p (subtarget, TREE_OPERAND (exp, 1), 1))\n \tsubtarget = 0;\n+      if (modifier == EXPAND_STACK_PARM)\n+\ttarget = 0;\n       /* Possible optimization: compute the dividend with EXPAND_SUM\n \t then if the divisor is constant can optimize the case\n \t where some terms of the dividend have coeffs divisible by it.  */\n@@ -8228,6 +8278,8 @@ expand_expr (exp, target, tmode, modifier)\n     case ROUND_MOD_EXPR:\n       if (! safe_from_p (subtarget, TREE_OPERAND (exp, 1), 1))\n \tsubtarget = 0;\n+      if (modifier == EXPAND_STACK_PARM)\n+\ttarget = 0;\n       op0 = expand_expr (TREE_OPERAND (exp, 0), subtarget, VOIDmode, 0);\n       op1 = expand_expr (TREE_OPERAND (exp, 1), NULL_RTX, VOIDmode, 0);\n       return expand_divmod (1, code, mode, op0, op1, target, unsignedp);\n@@ -8239,14 +8291,14 @@ expand_expr (exp, target, tmode, modifier)\n \n     case FIX_TRUNC_EXPR:\n       op0 = expand_expr (TREE_OPERAND (exp, 0), NULL_RTX, VOIDmode, 0);\n-      if (target == 0)\n+      if (target == 0 || modifier == EXPAND_STACK_PARM)\n \ttarget = gen_reg_rtx (mode);\n       expand_fix (target, op0, unsignedp);\n       return target;\n \n     case FLOAT_EXPR:\n       op0 = expand_expr (TREE_OPERAND (exp, 0), NULL_RTX, VOIDmode, 0);\n-      if (target == 0)\n+      if (target == 0 || modifier == EXPAND_STACK_PARM)\n \ttarget = gen_reg_rtx (mode);\n       /* expand_float can't figure out what to do if FROM has VOIDmode.\n \t So give it the correct mode.  With -O, cse will optimize this.  */\n@@ -8259,6 +8311,8 @@ expand_expr (exp, target, tmode, modifier)\n \n     case NEGATE_EXPR:\n       op0 = expand_expr (TREE_OPERAND (exp, 0), subtarget, VOIDmode, 0);\n+      if (modifier == EXPAND_STACK_PARM)\n+\ttarget = 0;\n       temp = expand_unop (mode,\n \t\t\t  ! unsignedp && flag_trapv\n \t\t\t  && (GET_MODE_CLASS(mode) == MODE_INT)\n@@ -8269,6 +8323,8 @@ expand_expr (exp, target, tmode, modifier)\n \n     case ABS_EXPR:\n       op0 = expand_expr (TREE_OPERAND (exp, 0), subtarget, VOIDmode, 0);\n+      if (modifier == EXPAND_STACK_PARM)\n+\ttarget = 0;\n \n       /* Handle complex values specially.  */\n       if (GET_MODE_CLASS (mode) == MODE_COMPLEX_INT\n@@ -8286,7 +8342,9 @@ expand_expr (exp, target, tmode, modifier)\n     case MAX_EXPR:\n     case MIN_EXPR:\n       target = original_target;\n-      if (target == 0 || ! safe_from_p (target, TREE_OPERAND (exp, 1), 1)\n+      if (target == 0\n+\t  || modifier == EXPAND_STACK_PARM\n+\t  || ! safe_from_p (target, TREE_OPERAND (exp, 1), 1)\n \t  || (GET_CODE (target) == MEM && MEM_VOLATILE_P (target))\n \t  || GET_MODE (target) != mode\n \t  || (GET_CODE (target) == REG\n@@ -8343,13 +8401,17 @@ expand_expr (exp, target, tmode, modifier)\n \n     case BIT_NOT_EXPR:\n       op0 = expand_expr (TREE_OPERAND (exp, 0), subtarget, VOIDmode, 0);\n+      if (modifier == EXPAND_STACK_PARM)\n+\ttarget = 0;\n       temp = expand_unop (mode, one_cmpl_optab, op0, target, 1);\n       if (temp == 0)\n \tabort ();\n       return temp;\n \n     case FFS_EXPR:\n       op0 = expand_expr (TREE_OPERAND (exp, 0), subtarget, VOIDmode, 0);\n+      if (modifier == EXPAND_STACK_PARM)\n+\ttarget = 0;\n       temp = expand_unop (mode, ffs_optab, op0, target, 1);\n       if (temp == 0)\n \tabort ();\n@@ -8417,6 +8479,8 @@ expand_expr (exp, target, tmode, modifier)\n     case RROTATE_EXPR:\n       if (! safe_from_p (subtarget, TREE_OPERAND (exp, 1), 1))\n \tsubtarget = 0;\n+      if (modifier == EXPAND_STACK_PARM)\n+\ttarget = 0;\n       op0 = expand_expr (TREE_OPERAND (exp, 0), subtarget, VOIDmode, 0);\n       return expand_shift (code, mode, op0, TREE_OPERAND (exp, 1), target,\n \t\t\t   unsignedp);\n@@ -8436,7 +8500,9 @@ expand_expr (exp, target, tmode, modifier)\n     case UNGT_EXPR:\n     case UNGE_EXPR:\n     case UNEQ_EXPR:\n-      temp = do_store_flag (exp, target, tmode != VOIDmode ? tmode : mode, 0);\n+      temp = do_store_flag (exp,\n+\t\t\t    modifier != EXPAND_STACK_PARM ? target : NULL_RTX,\n+\t\t\t    tmode != VOIDmode ? tmode : mode, 0);\n       if (temp != 0)\n \treturn temp;\n \n@@ -8485,7 +8551,9 @@ expand_expr (exp, target, tmode, modifier)\n     case TRUTH_ANDIF_EXPR:\n     case TRUTH_ORIF_EXPR:\n       if (! ignore\n-\t  && (target == 0 || ! safe_from_p (target, exp, 1)\n+\t  && (target == 0\n+\t      || modifier == EXPAND_STACK_PARM\n+\t      || ! safe_from_p (target, exp, 1)\n \t      /* Make sure we don't have a hard reg (such as function's return\n \t\t value) live across basic blocks, if not optimizing.  */\n \t      || (!optimize && GET_CODE (target) == REG\n@@ -8505,6 +8573,8 @@ expand_expr (exp, target, tmode, modifier)\n       return ignore ? const0_rtx : target;\n \n     case TRUTH_NOT_EXPR:\n+      if (modifier == EXPAND_STACK_PARM)\n+\ttarget = 0;\n       op0 = expand_expr (TREE_OPERAND (exp, 0), target, VOIDmode, 0);\n       /* The parser is careful to generate TRUTH_NOT_EXPR\n \t only with operands that are always zero or one.  */\n@@ -8519,7 +8589,7 @@ expand_expr (exp, target, tmode, modifier)\n       emit_queue ();\n       return expand_expr (TREE_OPERAND (exp, 1),\n \t\t\t  (ignore ? const0_rtx : target),\n-\t\t\t  VOIDmode, 0);\n+\t\t\t  VOIDmode, modifier);\n \n     case COND_EXPR:\n       /* If we would have a \"singleton\" (see below) were it not for a\n@@ -8572,6 +8642,8 @@ expand_expr (exp, target, tmode, modifier)\n \t\treturn const0_rtx;\n \t      }\n \n+\t    if (modifier == EXPAND_STACK_PARM)\n+\t      target = 0;\n \t    op0 = expand_expr (TREE_OPERAND (exp, 0), target, mode, modifier);\n \t    if (GET_MODE (op0) == mode)\n \t      return op0;\n@@ -8612,6 +8684,8 @@ expand_expr (exp, target, tmode, modifier)\n \n \tif (ignore)\n \t  temp = 0;\n+\telse if (modifier == EXPAND_STACK_PARM)\n+\t  temp = assign_temp (type, 0, 0, 1);\n \telse if (original_target\n \t\t && (safe_from_p (original_target, TREE_OPERAND (exp, 0), 1)\n \t\t     || (singleton && GET_CODE (original_target) == REG\n@@ -8699,7 +8773,8 @@ expand_expr (exp, target, tmode, modifier)\n \t\t    || (GET_CODE (temp) == REG\n \t\t\t&& REGNO (temp) < FIRST_PSEUDO_REGISTER))\n \t\t  temp = gen_reg_rtx (mode);\n-\t\tstore_expr (singleton, temp, 0);\n+\t\tstore_expr (singleton, temp,\n+\t\t\t    modifier == EXPAND_STACK_PARM ? 2 : 0);\n \t      }\n \t    else\n \t      expand_expr (singleton,\n@@ -8718,11 +8793,11 @@ expand_expr (exp, target, tmode, modifier)\n \t      store_expr (build (TREE_CODE (binary_op), type,\n \t\t\t\t make_tree (type, temp),\n \t\t\t\t TREE_OPERAND (binary_op, 1)),\n-\t\t\t  temp, 0);\n+\t\t\t  temp, modifier == EXPAND_STACK_PARM ? 2 : 0);\n \t    else\n \t      store_expr (build1 (TREE_CODE (unary_op), type,\n \t\t\t\t  make_tree (type, temp)),\n-\t\t\t  temp, 0);\n+\t\t\t  temp, modifier == EXPAND_STACK_PARM ? 2 : 0);\n \t    op1 = op0;\n \t  }\n \t/* Check for A op 0 ? A : FOO and A op 0 ? FOO : A where OP is any\n@@ -8741,11 +8816,13 @@ expand_expr (exp, target, tmode, modifier)\n \t    if (GET_CODE (temp) == REG\n \t\t&& REGNO (temp) < FIRST_PSEUDO_REGISTER)\n \t      temp = gen_reg_rtx (mode);\n-\t    store_expr (TREE_OPERAND (exp, 1), temp, 0);\n+\t    store_expr (TREE_OPERAND (exp, 1), temp,\n+\t\t\tmodifier == EXPAND_STACK_PARM ? 2 : 0);\n \t    jumpif (TREE_OPERAND (exp, 0), op0);\n \n \t    start_cleanup_deferral ();\n-\t    store_expr (TREE_OPERAND (exp, 2), temp, 0);\n+\t    store_expr (TREE_OPERAND (exp, 2), temp,\n+\t\t\tmodifier == EXPAND_STACK_PARM ? 2 : 0);\n \t    op1 = op0;\n \t  }\n \telse if (temp\n@@ -8760,11 +8837,13 @@ expand_expr (exp, target, tmode, modifier)\n \t    if (GET_CODE (temp) == REG\n \t\t&& REGNO (temp) < FIRST_PSEUDO_REGISTER)\n \t      temp = gen_reg_rtx (mode);\n-\t    store_expr (TREE_OPERAND (exp, 2), temp, 0);\n+\t    store_expr (TREE_OPERAND (exp, 2), temp,\n+\t\t\tmodifier == EXPAND_STACK_PARM ? 2 : 0);\n \t    jumpifnot (TREE_OPERAND (exp, 0), op0);\n \n \t    start_cleanup_deferral ();\n-\t    store_expr (TREE_OPERAND (exp, 1), temp, 0);\n+\t    store_expr (TREE_OPERAND (exp, 1), temp,\n+\t\t\tmodifier == EXPAND_STACK_PARM ? 2 : 0);\n \t    op1 = op0;\n \t  }\n \telse\n@@ -8778,7 +8857,8 @@ expand_expr (exp, target, tmode, modifier)\n \t       example A ? throw : E  */\n \t    if (temp != 0\n \t\t&& TREE_TYPE (TREE_OPERAND (exp, 1)) != void_type_node)\n-\t      store_expr (TREE_OPERAND (exp, 1), temp, 0);\n+\t      store_expr (TREE_OPERAND (exp, 1), temp,\n+\t\t\t  modifier == EXPAND_STACK_PARM ? 2 : 0);\n \t    else\n \t      expand_expr (TREE_OPERAND (exp, 1),\n \t\t\t   ignore ? const0_rtx : NULL_RTX, VOIDmode, 0);\n@@ -8790,7 +8870,8 @@ expand_expr (exp, target, tmode, modifier)\n \t    start_cleanup_deferral ();\n \t    if (temp != 0\n \t\t&& TREE_TYPE (TREE_OPERAND (exp, 2)) != void_type_node)\n-\t      store_expr (TREE_OPERAND (exp, 2), temp, 0);\n+\t      store_expr (TREE_OPERAND (exp, 2), temp,\n+\t\t\t  modifier == EXPAND_STACK_PARM ? 2 : 0);\n \t    else\n \t      expand_expr (TREE_OPERAND (exp, 2),\n \t\t\t   ignore ? const0_rtx : NULL_RTX, VOIDmode, 0);\n@@ -8895,7 +8976,7 @@ expand_expr (exp, target, tmode, modifier)\n \t/* Mark it as expanded.  */\n \tTREE_OPERAND (exp, 1) = NULL_TREE;\n \n-\tstore_expr (exp1, target, 0);\n+\tstore_expr (exp1, target, modifier == EXPAND_STACK_PARM ? 2 : 0);\n \n \texpand_decl_cleanup_eh (NULL_TREE, cleanups, CLEANUP_EH_ONLY (exp));\n \n@@ -8980,6 +9061,8 @@ expand_expr (exp, target, tmode, modifier)\n       return expand_increment (exp, ! ignore, ignore);\n \n     case ADDR_EXPR:\n+      if (modifier == EXPAND_STACK_PARM)\n+\ttarget = 0;\n       /* Are we taking the address of a nested function?  */\n       if (TREE_CODE (TREE_OPERAND (exp, 0)) == FUNCTION_DECL\n \t  && decl_function_context (TREE_OPERAND (exp, 0)) != 0\n@@ -9101,7 +9184,8 @@ expand_expr (exp, target, tmode, modifier)\n \t\tabort ();\n \n \t      emit_block_move (new, op0, expr_size (TREE_OPERAND (exp, 0)),\n-\t\t\t       BLOCK_OP_NORMAL);\n+\t\t\t       (modifier == EXPAND_STACK_PARM\n+\t\t\t\t? BLOCK_OP_CALL_PARM : BLOCK_OP_NORMAL));\n \t      op0 = new;\n \t    }\n \n@@ -9317,6 +9401,8 @@ expand_expr (exp, target, tmode, modifier)\n   op0 = expand_expr (TREE_OPERAND (exp, 0), subtarget, VOIDmode, 0);\n   op1 = expand_expr (TREE_OPERAND (exp, 1), NULL_RTX, VOIDmode, 0);\n  binop2:\n+  if (modifier == EXPAND_STACK_PARM)\n+    target = 0;\n   temp = expand_binop (mode, this_optab, op0, op1, target,\n \t\t       unsignedp, OPTAB_LIB_WIDEN);\n   if (temp == 0)"}, {"sha": "2f243266cf277a7b5c4085c2eb92092ba79246e4", "filename": "gcc/expr.h", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8403445abac6b5d1b03903c3f23fd9a28c550438/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8403445abac6b5d1b03903c3f23fd9a28c550438/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=8403445abac6b5d1b03903c3f23fd9a28c550438", "patch": "@@ -1,6 +1,6 @@\n /* Definitions for code generation pass of GNU compiler.\n    Copyright (C) 1987, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -44,13 +44,16 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define QUEUED_NEXT(P) XEXP (P, 4)\n \n /* This is the 4th arg to `expand_expr'.\n+   EXPAND_STACK_PARM means we are possibly expanding a call param onto\n+   the stack.  Choosing a value of 2 isn't special;  It just allows\n+   some code optimization in store_expr.\n    EXPAND_SUM means it is ok to return a PLUS rtx or MULT rtx.\n    EXPAND_INITIALIZER is similar but also record any labels on forced_labels.\n    EXPAND_CONST_ADDRESS means it is ok to return a MEM whose address\n     is a constant that is not a legitimate address.\n    EXPAND_WRITE means we are only going to write to the resulting rtx.  */\n-enum expand_modifier {EXPAND_NORMAL, EXPAND_SUM, EXPAND_CONST_ADDRESS,\n-\t\t\tEXPAND_INITIALIZER, EXPAND_WRITE};\n+enum expand_modifier {EXPAND_NORMAL = 0, EXPAND_STACK_PARM = 2, EXPAND_SUM,\n+\t\t      EXPAND_CONST_ADDRESS, EXPAND_INITIALIZER, EXPAND_WRITE};\n \n /* Prevent the compiler from deferring stack pops.  See\n    inhibit_defer_pop for more information.  */\n@@ -378,8 +381,8 @@ extern rtx convert_modes PARAMS ((enum machine_mode, enum machine_mode,\n enum block_op_methods\n {\n   BLOCK_OP_NORMAL,\n-  BLOCK_OP_CALL_PARM,\n-  BLOCK_OP_NO_LIBCALL\n+  BLOCK_OP_NO_LIBCALL,\n+  BLOCK_OP_CALL_PARM\n };\n \n extern rtx emit_block_move PARAMS ((rtx, rtx, rtx, enum block_op_methods));"}]}