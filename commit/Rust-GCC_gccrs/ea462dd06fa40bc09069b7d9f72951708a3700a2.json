{"sha": "ea462dd06fa40bc09069b7d9f72951708a3700a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWE0NjJkZDA2ZmE0MGJjMDkwNjliN2Q5ZjcyOTUxNzA4YTM3MDBhMg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard@codesourcery.com", "date": "2006-03-16T20:24:42Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2006-03-16T20:24:42Z"}, "message": "predicates.md (splittable_const_int_operand): New, split from move_operand.\n\n\t* config/mips/predicates.md (splittable_const_int_operand): New,\n\tsplit from move_operand.\n\t(splittable_symbolic_operand): New.\n\t(move_operand): Add commentary.  Use splittable_const_int_operand.\n\tInline mips_atomic_symbolic_constant_p.\n\t* config/mips/mips.md: Add combine splitters for handling moves\n\tof splittable_const_int_operands and splittable_symbolic_operands.\n\t* config/mips/mips-protos.h (mips_atomic_symbolic_constant_p): Delete.\n\t(mips_split_symbol): Declare.\n\t(mips_move_integer): Declare.\n\t* config/mips/mips.c (mips_split_p): Make global.\n\t(TARGET_MIN_ANCHOR_OFFSET): Override default.\n\t(TARGET_MAX_ANCHOR_OFFSET): Likewise.\n\t(TARGET_USE_BLOCKS_FOR_CONSTANT_P): Likewise.\n\t(TARGET_USE_ANCHORS_FOR_SYMBOL_P): Likewise.\n\t(mips_offset_within_object_p): Handle block symbols.\n\t(mips_atomic_symbolic_constant_p): Delete.\n\t(mips_cannot_force_const_mem): Return false for constants that\n\tmips_legitimize_move can handle.\n\t(mips_use_blocks_for_constant_p): New function.\n\t(mips_split_symbol): Make global.\n\t(mips_move_integer): Likewise.  Add a temporary register argument.\n\t(mips_legitimize_const_move): Use splittable_const_int_operand and\n\tsplittable_symbolic_operand.\n\t(mips_use_anchors_for_symbol_p): New function.\n\t* config/mips/mips.h: Protect externs with !USED_FOR_TARGET.\n\t(mips_split_p): Declare.\n\nFrom-SVN: r112150", "tree": {"sha": "0d9e288be90577a8c05e18e72391446f59072ca7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0d9e288be90577a8c05e18e72391446f59072ca7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea462dd06fa40bc09069b7d9f72951708a3700a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea462dd06fa40bc09069b7d9f72951708a3700a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea462dd06fa40bc09069b7d9f72951708a3700a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea462dd06fa40bc09069b7d9f72951708a3700a2/comments", "author": null, "committer": null, "parents": [{"sha": "5d2a73d520f9b0dbad52954eed380c45e72044f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d2a73d520f9b0dbad52954eed380c45e72044f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d2a73d520f9b0dbad52954eed380c45e72044f0"}], "stats": {"total": 268, "additions": 216, "deletions": 52}, "files": [{"sha": "6175a872d2faf76caeb2208a6b365b0789e6e592", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea462dd06fa40bc09069b7d9f72951708a3700a2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea462dd06fa40bc09069b7d9f72951708a3700a2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ea462dd06fa40bc09069b7d9f72951708a3700a2", "patch": "@@ -1,3 +1,33 @@\n+2006-03-16  Richard Sandiford  <richard@codesourcery.com>\n+\n+\t* config/mips/predicates.md (splittable_const_int_operand): New,\n+\tsplit from move_operand.\n+\t(splittable_symbolic_operand): New.\n+\t(move_operand): Add commentary.  Use splittable_const_int_operand.\n+\tInline mips_atomic_symbolic_constant_p.\n+\t* config/mips/mips.md: Add combine splitters for handling moves\n+\tof splittable_const_int_operands and splittable_symbolic_operands.\n+\t* config/mips/mips-protos.h (mips_atomic_symbolic_constant_p): Delete.\n+\t(mips_split_symbol): Declare.\n+\t(mips_move_integer): Declare.\n+\t* config/mips/mips.c (mips_split_p): Make global.\n+\t(TARGET_MIN_ANCHOR_OFFSET): Override default.\n+\t(TARGET_MAX_ANCHOR_OFFSET): Likewise.\n+\t(TARGET_USE_BLOCKS_FOR_CONSTANT_P): Likewise.\n+\t(TARGET_USE_ANCHORS_FOR_SYMBOL_P): Likewise.\n+\t(mips_offset_within_object_p): Handle block symbols.\n+\t(mips_atomic_symbolic_constant_p): Delete.\n+\t(mips_cannot_force_const_mem): Return false for constants that\n+\tmips_legitimize_move can handle.\n+\t(mips_use_blocks_for_constant_p): New function.\n+\t(mips_split_symbol): Make global.\n+\t(mips_move_integer): Likewise.  Add a temporary register argument.\n+\t(mips_legitimize_const_move): Use splittable_const_int_operand and\n+\tsplittable_symbolic_operand.\n+\t(mips_use_anchors_for_symbol_p): New function.\n+\t* config/mips/mips.h: Protect externs with !USED_FOR_TARGET.\n+\t(mips_split_p): Declare.  \n+\n 2006-03-16  Richard Sandiford  <richard@codesourcery.com>\n \n \t* config.gcc (mips64*-*-linux*): Keep existing tm_defines."}, {"sha": "b737375af6180bffeebc79306cf2fbc81b81fe44", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea462dd06fa40bc09069b7d9f72951708a3700a2/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea462dd06fa40bc09069b7d9f72951708a3700a2/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=ea462dd06fa40bc09069b7d9f72951708a3700a2", "patch": "@@ -106,7 +106,6 @@ enum mips_symbol_type {\n #define NUM_SYMBOL_TYPES (SYMBOL_64_LOW + 1)\n \n extern bool mips_symbolic_constant_p (rtx, enum mips_symbol_type *);\n-extern bool mips_atomic_symbolic_constant_p (rtx);\n extern int mips_regno_mode_ok_for_base_p (int, enum machine_mode, int);\n extern bool mips_stack_address_p (rtx, enum machine_mode);\n extern int mips_address_insns (rtx, enum machine_mode);\n@@ -116,8 +115,10 @@ extern int mips_idiv_insns (void);\n extern int fp_register_operand (rtx, enum machine_mode);\n extern int lo_operand (rtx, enum machine_mode);\n extern bool mips_legitimate_address_p (enum machine_mode, rtx, int);\n+extern rtx mips_split_symbol (rtx, rtx);\n extern rtx mips_unspec_address (rtx, enum mips_symbol_type);\n extern bool mips_legitimize_address (rtx *, enum machine_mode);\n+extern void mips_move_integer (rtx, rtx, unsigned HOST_WIDE_INT);\n extern bool mips_legitimize_move (enum machine_mode, rtx, rtx);\n \n extern int m16_uimm3_b (rtx, enum machine_mode);"}, {"sha": "f907c01b0b3ef70b1849af6693c9b75e51b2fb78", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 90, "deletions": 37, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea462dd06fa40bc09069b7d9f72951708a3700a2/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea462dd06fa40bc09069b7d9f72951708a3700a2/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=ea462dd06fa40bc09069b7d9f72951708a3700a2", "patch": "@@ -274,18 +274,17 @@ static bool mips_symbolic_address_p (enum mips_symbol_type, enum machine_mode);\n static bool mips_classify_address (struct mips_address_info *, rtx,\n \t\t\t\t   enum machine_mode, int);\n static bool mips_cannot_force_const_mem (rtx);\n+static bool mips_use_blocks_for_constant_p (enum machine_mode, rtx);\n static int mips_symbol_insns (enum mips_symbol_type);\n static bool mips16_unextended_reference_p (enum machine_mode mode, rtx, rtx);\n static rtx mips_force_temporary (rtx, rtx);\n-static rtx mips_split_symbol (rtx, rtx);\n static rtx mips_unspec_offset_high (rtx, rtx, rtx, enum mips_symbol_type);\n static rtx mips_add_offset (rtx, rtx, HOST_WIDE_INT);\n static unsigned int mips_build_shift (struct mips_integer_op *, HOST_WIDE_INT);\n static unsigned int mips_build_lower (struct mips_integer_op *,\n \t\t\t\t      unsigned HOST_WIDE_INT);\n static unsigned int mips_build_integer (struct mips_integer_op *,\n \t\t\t\t\tunsigned HOST_WIDE_INT);\n-static void mips_move_integer (rtx, unsigned HOST_WIDE_INT);\n static void mips_legitimize_const_move (enum machine_mode, rtx, rtx);\n static int m16_check_op (rtx, int, int, int);\n static bool mips_rtx_costs (rtx, int, int, int *);\n@@ -333,6 +332,7 @@ static section *mips_select_rtx_section (enum machine_mode, rtx,\n \t\t\t\t\t unsigned HOST_WIDE_INT);\n static section *mips_function_rodata_section (tree);\n static bool mips_in_small_data_p (tree);\n+static bool mips_use_anchors_for_symbol_p (rtx);\n static int mips_fpr_return_fields (tree, tree *);\n static bool mips_return_in_msb (tree);\n static rtx mips_return_fpr_pair (enum machine_mode mode,\n@@ -628,7 +628,7 @@ static GTY (()) int mips_output_filename_first_time = 1;\n \n /* mips_split_p[X] is true if symbols of type X can be split by\n    mips_split_symbol().  */\n-static bool mips_split_p[NUM_SYMBOL_TYPES];\n+bool mips_split_p[NUM_SYMBOL_TYPES];\n \n /* mips_lo_relocs[X] is the relocation to use when a symbol of type X\n    appears in a LO_SUM.  It can be null if such LO_SUMs aren't valid or\n@@ -1162,6 +1162,15 @@ static struct mips_rtx_cost_data const mips_rtx_cost_data[PROCESSOR_MAX] =\n #undef TARGET_EXTRA_LIVE_ON_ENTRY\n #define TARGET_EXTRA_LIVE_ON_ENTRY mips_extra_live_on_entry\n \n+#undef TARGET_MIN_ANCHOR_OFFSET\n+#define TARGET_MIN_ANCHOR_OFFSET -32768\n+#undef TARGET_MAX_ANCHOR_OFFSET\n+#define TARGET_MAX_ANCHOR_OFFSET 32767\n+#undef TARGET_USE_BLOCKS_FOR_CONSTANT_P\n+#define TARGET_USE_BLOCKS_FOR_CONSTANT_P mips_use_blocks_for_constant_p\n+#undef TARGET_USE_ANCHORS_FOR_SYMBOL_P\n+#define TARGET_USE_ANCHORS_FOR_SYMBOL_P mips_use_anchors_for_symbol_p\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Classify symbol X, which must be a SYMBOL_REF or a LABEL_REF.  */\n@@ -1256,7 +1265,7 @@ mips_split_const (rtx x, rtx *base, HOST_WIDE_INT *offset)\n \n \n /* Return true if SYMBOL is a SYMBOL_REF and OFFSET + SYMBOL points\n-   to the same object as SYMBOL.  */\n+   to the same object as SYMBOL, or to the same object_block.  */\n \n static bool\n mips_offset_within_object_p (rtx symbol, HOST_WIDE_INT offset)\n@@ -1274,6 +1283,13 @@ mips_offset_within_object_p (rtx symbol, HOST_WIDE_INT offset)\n       && offset < int_size_in_bytes (TREE_TYPE (SYMBOL_REF_DECL (symbol))))\n     return true;\n \n+  if (SYMBOL_REF_HAS_BLOCK_INFO_P (symbol)\n+      && SYMBOL_REF_BLOCK (symbol)\n+      && SYMBOL_REF_BLOCK_OFFSET (symbol) >= 0\n+      && ((unsigned HOST_WIDE_INT) offset + SYMBOL_REF_BLOCK_OFFSET (symbol)\n+\t  < (unsigned HOST_WIDE_INT) SYMBOL_REF_BLOCK (symbol)->size))\n+    return true;\n+\n   return false;\n }\n \n@@ -1357,17 +1373,6 @@ mips_symbolic_constant_p (rtx x, enum mips_symbol_type *symbol_type)\n }\n \n \n-/* Return true if X is a symbolic constant whose value is not split\n-   into separate relocations.  */\n-\n-bool\n-mips_atomic_symbolic_constant_p (rtx x)\n-{\n-  enum mips_symbol_type type;\n-  return mips_symbolic_constant_p (x, &type) && !mips_split_p[type];\n-}\n-\n-\n /* This function is used to implement REG_MODE_OK_FOR_BASE_P.  */\n \n int\n@@ -1542,10 +1547,42 @@ mips_tls_symbol_ref_1 (rtx *x, void *data ATTRIBUTE_UNUSED)\n static bool\n mips_cannot_force_const_mem (rtx x)\n {\n-  if (! TARGET_HAVE_TLS)\n-    return false;\n+  rtx base;\n+  HOST_WIDE_INT offset;\n+\n+  if (!TARGET_MIPS16)\n+    {\n+      /* As an optimization, reject constants that mips_legitimize_move\n+\t can expand inline.\n \n-  return for_each_rtx (&x, &mips_tls_symbol_ref_1, 0);\n+\t Suppose we have a multi-instruction sequence that loads constant C\n+\t into register R.  If R does not get allocated a hard register, and\n+\t R is used in an operand that allows both registers and memory\n+\t references, reload will consider forcing C into memory and using\n+\t one of the instruction's memory alternatives.  Returning false\n+\t here will force it to use an input reload instead.  */\n+      if (GET_CODE (x) == CONST_INT)\n+\treturn true;\n+\n+      mips_split_const (x, &base, &offset);\n+      if (symbolic_operand (base, VOIDmode) && SMALL_OPERAND (offset))\n+\treturn true;\n+    }\n+\n+  if (TARGET_HAVE_TLS && for_each_rtx (&x, &mips_tls_symbol_ref_1, 0))\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Implement TARGET_USE_BLOCKS_FOR_CONSTANT_P.  MIPS16 uses per-function\n+   constant pools, but normal-mode code doesn't need to.  */\n+\n+static bool\n+mips_use_blocks_for_constant_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t\trtx x ATTRIBUTE_UNUSED)\n+{\n+  return !TARGET_MIPS16;\n }\n \f\n /* Return the number of instructions needed to load a symbol of the\n@@ -1845,7 +1882,7 @@ mips_force_temporary (rtx dest, rtx value)\n /* Return a LO_SUM expression for ADDR.  TEMP is as for mips_force_temporary\n    and is used to load the high part into a register.  */\n \n-static rtx\n+rtx\n mips_split_symbol (rtx temp, rtx addr)\n {\n   rtx high;\n@@ -2175,10 +2212,10 @@ mips_build_integer (struct mips_integer_op *codes,\n }\n \n \n-/* Move VALUE into register DEST.  */\n+/* Load VALUE into DEST, using TEMP as a temporary register if need be.  */\n \n-static void\n-mips_move_integer (rtx dest, unsigned HOST_WIDE_INT value)\n+void\n+mips_move_integer (rtx dest, rtx temp, unsigned HOST_WIDE_INT value)\n {\n   struct mips_integer_op codes[MIPS_MAX_INTEGER_OPS];\n   enum machine_mode mode;\n@@ -2194,7 +2231,10 @@ mips_move_integer (rtx dest, unsigned HOST_WIDE_INT value)\n   for (i = 1; i < cost; i++)\n     {\n       if (no_new_pseudos)\n-\temit_move_insn (dest, x), x = dest;\n+\t{\n+\t  emit_insn (gen_rtx_SET (VOIDmode, temp, x));\n+\t  x = temp;\n+\t}\n       else\n \tx = force_reg (mode, x);\n       x = gen_rtx_fmt_ee (codes[i].code, mode, x, GEN_INT (codes[i].value));\n@@ -2213,30 +2253,24 @@ mips_legitimize_const_move (enum machine_mode mode, rtx dest, rtx src)\n {\n   rtx base;\n   HOST_WIDE_INT offset;\n-  enum mips_symbol_type symbol_type;\n \n-  /* Split moves of big integers into smaller pieces.  In mips16 code,\n-     it's better to force the constant into memory instead.  */\n-  if (GET_CODE (src) == CONST_INT && !TARGET_MIPS16)\n+  /* Split moves of big integers into smaller pieces.  */\n+  if (splittable_const_int_operand (src, mode))\n     {\n-      mips_move_integer (dest, INTVAL (src));\n+      mips_move_integer (dest, dest, INTVAL (src));\n       return;\n     }\n \n-  if (mips_tls_operand_p (src))\n+  /* Split moves of symbolic constants into high/low pairs.  */\n+  if (splittable_symbolic_operand (src, mode))\n     {\n-      emit_move_insn (dest, mips_legitimize_tls_address (src));\n+      emit_insn (gen_rtx_SET (VOIDmode, dest, mips_split_symbol (dest, src)));\n       return;\n     }\n \n-  /* See if the symbol can be split.  For mips16, this is often worse than\n-     forcing it in the constant pool since it needs the single-register form\n-     of addiu or daddiu.  */\n-  if (!TARGET_MIPS16\n-      && mips_symbolic_constant_p (src, &symbol_type)\n-      && mips_split_p[symbol_type])\n+  if (mips_tls_operand_p (src))\n     {\n-      emit_move_insn (dest, mips_split_symbol (dest, src));\n+      emit_move_insn (dest, mips_legitimize_tls_address (src));\n       return;\n     }\n \n@@ -7205,6 +7239,25 @@ mips_in_small_data_p (tree decl)\n   size = int_size_in_bytes (TREE_TYPE (decl));\n   return (size > 0 && size <= mips_section_threshold);\n }\n+\n+/* Implement TARGET_USE_ANCHORS_FOR_SYMBOL_P.  We don't want to use\n+   anchors for small data: the GP register acts as an anchor in that\n+   case.  We also don't want to use them for PC-relative accesses,\n+   where the PC acts as an anchor.  */\n+\n+static bool\n+mips_use_anchors_for_symbol_p (rtx symbol)\n+{\n+  switch (mips_classify_symbol (symbol))\n+    {\n+    case SYMBOL_CONSTANT_POOL:\n+    case SYMBOL_SMALL_DATA:\n+      return false;\n+\n+    default:\n+      return true;\n+    }\n+}\n \f\n /* See whether VALTYPE is a record whose fields should be returned in\n    floating-point registers.  If so, return the number of fields and"}, {"sha": "51d383c59cf536da052fbd1632417810dc99b18b", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea462dd06fa40bc09069b7d9f72951708a3700a2/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea462dd06fa40bc09069b7d9f72951708a3700a2/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=ea462dd06fa40bc09069b7d9f72951708a3700a2", "patch": "@@ -106,6 +106,7 @@ struct mips_cpu_info {\n   int isa;\n };\n \n+#ifndef USED_FOR_TARGET\n extern char mips_print_operand_punct[256]; /* print_operand punctuation chars */\n extern const char *current_function_file; /* filename current function is in */\n extern int num_source_filenames;\t/* current .file # */\n@@ -117,6 +118,7 @@ extern int set_noat;\t\t\t/* # of nested .set noat's  */\n extern int set_volatile;\t\t/* # of nested .set volatile's  */\n extern int mips_branch_likely;\t\t/* emit 'l' after br (branch likely) */\n extern int mips_dbx_regno[];\t\t/* Map register # to debug register # */\n+extern bool mips_split_p[];\n extern GTY(()) rtx cmp_operands[2];\n extern enum processor_type mips_arch;   /* which cpu to codegen for */\n extern enum processor_type mips_tune;   /* which cpu to schedule for */\n@@ -127,6 +129,7 @@ extern const struct mips_cpu_info mips_cpu_info_table[];\n extern const struct mips_cpu_info *mips_arch_info;\n extern const struct mips_cpu_info *mips_tune_info;\n extern const struct mips_rtx_cost_data *mips_cost;\n+#endif\n \n /* Macros to silence warnings about numbers being signed in traditional\n    C and unsigned in ISO C when compiled on 32-bit hosts.  */"}, {"sha": "ce2cce650acb277e649392114ec1f9f4726a3343", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea462dd06fa40bc09069b7d9f72951708a3700a2/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea462dd06fa40bc09069b7d9f72951708a3700a2/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=ea462dd06fa40bc09069b7d9f72951708a3700a2", "patch": "@@ -3194,6 +3194,28 @@\n    (set_attr \"mode\" \"<MODE>\")\n    (set_attr \"length\" \"8\")])\n \n+;; Allow combine to split complex const_int load sequences, using operand 2\n+;; to store the intermediate results.  See move_operand for details.\n+(define_split\n+  [(set (match_operand:GPR 0 \"register_operand\")\n+\t(match_operand:GPR 1 \"splittable_const_int_operand\"))\n+   (clobber (match_operand:GPR 2 \"register_operand\"))]\n+  \"\"\n+  [(const_int 0)]\n+{\n+  mips_move_integer (operands[0], operands[2], INTVAL (operands[1]));\n+  DONE;\n+})\n+\n+;; Likewise, for symbolic operands.\n+(define_split\n+  [(set (match_operand:P 0 \"register_operand\")\n+\t(match_operand:P 1 \"splittable_symbolic_operand\"))\n+   (clobber (match_operand:P 2 \"register_operand\"))]\n+  \"\"\n+  [(set (match_dup 0) (match_dup 1))]\n+  { operands[1] = mips_split_symbol (operands[2], operands[1]); })\n+\n ;; 64-bit integer moves\n \n ;; Unlike most other insns, the move insns can't be split with"}, {"sha": "23e85d82be8d09343b051dea62915e78d2a2238b", "filename": "gcc/config/mips/predicates.md", "status": "modified", "additions": 69, "deletions": 14, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea462dd06fa40bc09069b7d9f72951708a3700a2/gcc%2Fconfig%2Fmips%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea462dd06fa40bc09069b7d9f72951708a3700a2/gcc%2Fconfig%2Fmips%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fpredicates.md?ref=ea462dd06fa40bc09069b7d9f72951708a3700a2", "patch": "@@ -125,30 +125,85 @@\n   (ior (match_operand 0 \"const_call_insn_operand\")\n        (match_operand 0 \"register_operand\")))\n \n+;; A legitimate CONST_INT operand that takes more than one instruction\n+;; to load.\n+(define_predicate \"splittable_const_int_operand\"\n+  (match_code \"const_int\")\n+{\n+  /* When generating mips16 code, LEGITIMATE_CONSTANT_P rejects\n+     CONST_INTs that can't be loaded using simple insns.  */\n+  if (TARGET_MIPS16)\n+    return false;\n+\n+  /* Don't handle multi-word moves this way; we don't want to introduce\n+     the individual word-mode moves until after reload.  */\n+  if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n+    return false;\n+\n+  /* Otherwise check whether the constant can be loaded in a single\n+     instruction.  */\n+  return !LUI_INT (op) && !SMALL_INT (op) && !SMALL_INT_UNSIGNED (op);\n+})\n+\n+;; A legitimate symbolic operand that takes more than one instruction\n+;; to load.\n+(define_predicate \"splittable_symbolic_operand\"\n+  (match_code \"const,symbol_ref,label_ref\")\n+{\n+  enum mips_symbol_type symbol_type;\n+  return (mips_symbolic_constant_p (op, &symbol_type)\n+\t  && mips_split_p[symbol_type]);\n+})\n+\n (define_predicate \"move_operand\"\n   (match_operand 0 \"general_operand\")\n {\n+  enum mips_symbol_type symbol_type;\n+\n+  /* The thinking here is as follows:\n+\n+     (1) The move expanders should split complex load sequences into\n+\t individual instructions.  Those individual instructions can\n+\t then be optimized by all rtl passes.\n+\n+     (2) The target of pre-reload load sequences should not be used\n+\t to store temporary results.  If the target register is only\n+\t assigned one value, reload can rematerialize that value\n+\t on demand, rather than spill it to the stack.\n+\n+     (3) If we allowed pre-reload passes like combine and cse to recreate\n+\t complex load sequences, we would want to be able to split the\n+\t sequences before reload as well, so that the pre-reload scheduler\n+\t can see the individual instructions.  This falls foul of (2);\n+\t the splitter would be forced to reuse the target register for\n+\t intermediate results.\n+\n+     (4) We want to define complex load splitters for combine.  These\n+\t splitters can request a temporary scratch register, which avoids\n+\t the problem in (2).  They allow things like:\n+\n+\t      (set (reg T1) (high SYM))\n+\t      (set (reg T2) (low (reg T1) SYM))\n+\t      (set (reg X) (plus (reg T2) (const_int OFFSET)))\n+\n+\t to be combined into:\n+\n+\t      (set (reg T3) (high SYM+OFFSET))\n+\t      (set (reg X) (lo_sum (reg T3) SYM+OFFSET))\n+\n+\t if T2 is only used this once.  */\n   switch (GET_CODE (op))\n     {\n     case CONST_INT:\n-      /* When generating mips16 code, LEGITIMATE_CONSTANT_P rejects\n-\t CONST_INTs that can't be loaded using simple insns.  */\n-      if (TARGET_MIPS16)\n-\treturn true;\n-\n-      /* When generating 32-bit code, allow DImode move_operands to\n-\t match arbitrary constants.  We split them after reload.  */\n-      if (!TARGET_64BIT && mode == DImode)\n-\treturn true;\n-\n-      /* Otherwise check whether the constant can be loaded in a single\n-\t instruction.  */\n-      return LUI_INT (op) || SMALL_INT (op) || SMALL_INT_UNSIGNED (op);\n+      return !splittable_const_int_operand (op, mode);\n \n     case CONST:\n     case SYMBOL_REF:\n     case LABEL_REF:\n-      return CONST_GP_P (op) || mips_atomic_symbolic_constant_p (op);\n+      if (CONST_GP_P (op))\n+\treturn true;\n+      return (mips_symbolic_constant_p (op, &symbol_type)\n+\t      && !mips_split_p[symbol_type]);\n \n     default:\n       return true;"}]}