{"sha": "5f730c650184d4c8bfad513a9e0e593f87a5bf0c", "node_id": "C_kwDOANBUbNoAKDVmNzMwYzY1MDE4NGQ0YzhiZmFkNTEzYTllMGU1OTNmODdhNWJmMGM", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-09-20T22:07:14Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-09-22T18:48:29Z"}, "message": "Convert CFN_BUILT_FFS and CFN_POPCOUNT to range-ops.\n\n\t* gimple-range-fold.cc (range_of_builtin_int_call): Remove case\n\tfor CFN_FFS and CFN_POPCOUNT.\n\t* gimple-range-op.cc (class cfn_pocount): New.\n\t(gimple_range_op_handler::maybe_builtin_call): Set arguments.", "tree": {"sha": "584d7035e64af4763a5715dac8deb5ca476124d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/584d7035e64af4763a5715dac8deb5ca476124d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f730c650184d4c8bfad513a9e0e593f87a5bf0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f730c650184d4c8bfad513a9e0e593f87a5bf0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f730c650184d4c8bfad513a9e0e593f87a5bf0c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f730c650184d4c8bfad513a9e0e593f87a5bf0c/comments", "author": null, "committer": null, "parents": [{"sha": "2f5da730f159de238500c82b0c6ef6c9ab91b1c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f5da730f159de238500c82b0c6ef6c9ab91b1c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f5da730f159de238500c82b0c6ef6c9ab91b1c2"}], "stats": {"total": 56, "additions": 34, "deletions": 22}, "files": [{"sha": "ca531037e13c24609c6530d67104fcabefa55b7d", "filename": "gcc/gimple-range-fold.cc", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f730c650184d4c8bfad513a9e0e593f87a5bf0c/gcc%2Fgimple-range-fold.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f730c650184d4c8bfad513a9e0e593f87a5bf0c/gcc%2Fgimple-range-fold.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-fold.cc?ref=5f730c650184d4c8bfad513a9e0e593f87a5bf0c", "patch": "@@ -922,28 +922,6 @@ fold_using_range::range_of_builtin_int_call (irange &r, gcall *call,\n \n   switch (func)\n     {\n-    CASE_CFN_FFS:\n-    CASE_CFN_POPCOUNT:\n-      // __builtin_ffs* and __builtin_popcount* return [0, prec].\n-      arg = gimple_call_arg (call, 0);\n-      prec = TYPE_PRECISION (TREE_TYPE (arg));\n-      mini = 0;\n-      maxi = prec;\n-      src.get_operand (r, arg);\n-      // If arg is non-zero, then ffs or popcount are non-zero.\n-      if (!range_includes_zero_p (&r))\n-\tmini = 1;\n-      // If some high bits are known to be zero, decrease the maximum.\n-      if (!r.undefined_p ())\n-\t{\n-\t  if (TYPE_SIGN (r.type ()) == SIGNED)\n-\t    range_cast (r, unsigned_type_for (r.type ()));\n-\t  wide_int max = r.upper_bound ();\n-\t  maxi = wi::floor_log2 (max) + 1;\n-\t}\n-      r.set (build_int_cst (type, mini), build_int_cst (type, maxi));\n-      return true;\n-\n     CASE_CFN_PARITY:\n       r.set (build_zero_cst (type), build_one_cst (type));\n       return true;"}, {"sha": "84837f8ee4395436318628432332c1ecec13193f", "filename": "gcc/gimple-range-op.cc", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f730c650184d4c8bfad513a9e0e593f87a5bf0c/gcc%2Fgimple-range-op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f730c650184d4c8bfad513a9e0e593f87a5bf0c/gcc%2Fgimple-range-op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-op.cc?ref=5f730c650184d4c8bfad513a9e0e593f87a5bf0c", "patch": "@@ -387,6 +387,33 @@ cfn_toupper_tolower::fold_range (irange &r, tree type, const irange &lh,\n   return true;\n }\n \n+// Implement range operator for CFN_BUILT_IN_FFS and CFN_BUILT_IN_POPCOUNT.\n+class cfn_popcount : public range_operator\n+{\n+public:\n+  using range_operator::fold_range;\n+  virtual bool fold_range (irange &r, tree type, const irange &lh,\n+\t\t\t   const irange &, relation_kind) const\n+  {\n+    if (lh.undefined_p ())\n+      return false;\n+    // __builtin_ffs* and __builtin_popcount* return [0, prec].\n+    int prec = TYPE_PRECISION (lh.type ());\n+    // If arg is non-zero, then ffs or popcount are non-zero.\n+    int mini = range_includes_zero_p (&lh) ? 0 : 1;\n+    int maxi = prec;\n+\n+    // If some high bits are known to be zero, decrease the maximum.\n+    int_range_max tmp = lh;\n+    if (TYPE_SIGN (tmp.type ()) == SIGNED)\n+      range_cast (tmp, unsigned_type_for (tmp.type ()));\n+    wide_int max = tmp.upper_bound ();\n+    maxi = wi::floor_log2 (max) + 1;\n+    r.set (build_int_cst (type, mini), build_int_cst (type, maxi));\n+    return true;\n+  }\n+} op_cfn_popcount;\n+\n // Set up a gimple_range_op_handler for any built in function which can be\n // supported via range-ops.\n \n@@ -435,6 +462,13 @@ gimple_range_op_handler::maybe_builtin_call ()\n \t}\n       break;\n \n+    CASE_CFN_FFS:\n+    CASE_CFN_POPCOUNT:\n+      m_op1 = gimple_call_arg (call, 0);\n+      m_int = &op_cfn_popcount;\n+      m_valid = true;\n+      break;\n+\n     default:\n       break;\n     }"}]}