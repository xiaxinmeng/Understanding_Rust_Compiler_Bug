{"sha": "e64f9262e6e27a79ea5f3ce8dcee0ce4ce4af268", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTY0ZjkyNjJlNmUyN2E3OWVhNWYzY2U4ZGNlZTBjZTRjZTRhZjI2OA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-02-03T00:53:23Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-02-03T00:53:23Z"}, "message": "(objc_condition_{,de}allocate): New functions.\n\n(objc_condition_{wait,broadcast,signal}): New functions.\n(__objc_runtime_mutex): Eliminate leading underscore\nfrom name of objc mutex and thread structures.\n\nFrom-SVN: r13596", "tree": {"sha": "c7b4e620428aa556cc08597a5f5684a5437a4842", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c7b4e620428aa556cc08597a5f5684a5437a4842"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e64f9262e6e27a79ea5f3ce8dcee0ce4ce4af268", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e64f9262e6e27a79ea5f3ce8dcee0ce4ce4af268", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e64f9262e6e27a79ea5f3ce8dcee0ce4ce4af268", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e64f9262e6e27a79ea5f3ce8dcee0ce4ce4af268/comments", "author": null, "committer": null, "parents": [{"sha": "f4d01e796255c94ed79cc5c2fb032c4486d020b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4d01e796255c94ed79cc5c2fb032c4486d020b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4d01e796255c94ed79cc5c2fb032c4486d020b4"}], "stats": {"total": 142, "additions": 123, "deletions": 19}, "files": [{"sha": "f1084bc79138e62f1e3c02c0f8f20bfc70a0cabb", "filename": "gcc/objc/thr-solaris.c", "status": "modified", "additions": 123, "deletions": 19, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e64f9262e6e27a79ea5f3ce8dcee0ce4ce4af268/gcc%2Fobjc%2Fthr-solaris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e64f9262e6e27a79ea5f3ce8dcee0ce4ce4af268/gcc%2Fobjc%2Fthr-solaris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fthr-solaris.c?ref=e64f9262e6e27a79ea5f3ce8dcee0ce4ce4af268", "patch": "@@ -1,7 +1,8 @@\n /* GNU Objective C Runtime Thread Interface\n-   Copyright (C) 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n    Contributed by Galen C. Hunt (gchunt@cs.rochester.edu)\n-\n+   Conditions added by Mircea Oancea (mircea@first.elcom.pub.ro)\n+      \n This file is part of GNU CC.\n \n GNU CC is free software; you can redistribute it and/or modify it under the\n@@ -37,13 +38,18 @@ Boston, MA 02111-1307, USA.  */\n  *  provided by the system.  We augment it with depth and current owner id\n  *  fields to implement and re-entrant lock.\n  */\n-struct _objc_mutex \n+struct objc_mutex \n {\n-    volatile _objc_thread_t     owner;          /* Id of thread that owns.  */\n+    volatile objc_thread_t     owner;          /* Id of thread that owns.  */\n     volatile int                depth;          /* # of acquires.           */\n     mutex_t                     lock;           /* System mutex.            */\n };\n \n+struct objc_condition\n+{\n+    cond_t                     condition;      /* solaris condition        */\n+};\n+\n /*****************************************************************************\n  *  Static variables.\n  */\n@@ -74,10 +80,10 @@ __objc_fini_thread_system(void)\n  *  Create a new thread of execution and return its id.  Return -1 if fails.\n  *  The new thread starts in \"func\" with the given argument.\n  */\n-_objc_thread_t\n+objc_thread_t\n objc_thread_create(void (*func)(void *arg), void *arg)\n {\n-  _objc_thread_t        thread_id = NULL;       /* Detached thread id.      */\n+  objc_thread_t        thread_id = NULL;       /* Detached thread id.      */\n   thread_t              new_thread_id = 0;      /* Solaris thread id type.  */\n   int                   errn;\n \n@@ -86,7 +92,7 @@ objc_thread_create(void (*func)(void *arg), void *arg)\n   if (thr_create(NULL, 0, (void *)func, arg,\n                  THR_DETACHED | THR_NEW_LWP,\n                  &new_thread_id) == 0) {    \t/* Created new thread?      */\n-    thread_id = (_objc_thread_t)new_thread_id;  /* Yes, remember its id.    */\n+    thread_id = (objc_thread_t)new_thread_id;  /* Yes, remember its id.    */\n     __objc_runtime_threads_alive++;\n   }\n   \n@@ -171,10 +177,10 @@ objc_thread_exit(void)\n  *  Returns an integer value which uniquely describes a thread.  Must not be\n  *  NULL which is reserved as a marker for \"no thread\".\n  */\n-_objc_thread_t\n+objc_thread_t\n objc_thread_id(void)\n {\n-    return (_objc_thread_t)thr_self();\n+    return (objc_thread_t)thr_self();\n }\n \n /********\n@@ -207,13 +213,13 @@ objc_thread_get_data(void)\n  *  Allocate a mutex.  Return the mutex pointer if successful or NULL if\n  *  the allocation fails for any reason.\n  */\n-_objc_mutex_t\n+objc_mutex_t\n objc_mutex_allocate(void)\n {\n-    struct _objc_mutex *mutex;\n+    struct objc_mutex *mutex;\n     int         err = 0;\n     \n-    if (!(mutex = (_objc_mutex_t) objc_malloc(sizeof(struct _objc_mutex))))\n+    if (!(mutex = (objc_mutex_t)objc_malloc(sizeof(struct objc_mutex))))\n         return NULL;                            /* Abort if malloc failed.  */\n     \n     err = mutex_init(&mutex->lock, USYNC_THREAD, 0);\n@@ -235,7 +241,7 @@ objc_mutex_allocate(void)\n  *  Returns the number of locks on the thread.  (1 for deallocate).\n  */\n int\n-objc_mutex_deallocate(_objc_mutex_t mutex)\n+objc_mutex_deallocate(objc_mutex_t mutex)\n {\n     int         depth;                          /* # of locks on mutex.     */\n \n@@ -256,9 +262,9 @@ objc_mutex_deallocate(_objc_mutex_t mutex)\n  *  Returns the lock count on the mutex held by this thread.\n  */\n int\n-objc_mutex_lock(_objc_mutex_t mutex)\n+objc_mutex_lock(objc_mutex_t mutex)\n {\n-    _objc_thread_t      thread_id;              /* Cache our thread id.     */\n+    objc_thread_t      thread_id;              /* Cache our thread id.     */\n \n     if (!mutex)                                 /* Is argument bad?         */\n         return -1;                              /* Yes, abort.              */\n@@ -279,9 +285,9 @@ objc_mutex_lock(_objc_mutex_t mutex)\n  *  thread has a lock on the mutex returns -1.\n  */\n int\n-objc_mutex_trylock(_objc_mutex_t mutex)\n+objc_mutex_trylock(objc_mutex_t mutex)\n {\n-    _objc_thread_t      thread_id;              /* Cache our thread id.     */\n+    objc_thread_t      thread_id;              /* Cache our thread id.     */\n \n     if (!mutex)                                 /* Is argument bad?         */\n         return -1;                              /* Yes, abort.              */\n@@ -304,9 +310,9 @@ objc_mutex_trylock(_objc_mutex_t mutex)\n  *  Will also return -1 if the mutex free fails.\n  */\n int\n-objc_mutex_unlock(_objc_mutex_t mutex)\n+objc_mutex_unlock(objc_mutex_t mutex)\n {\n-    _objc_thread_t      thread_id;              /* Cache our thread id.     */\n+    objc_thread_t      thread_id;              /* Cache our thread id.     */\n     \n     if (!mutex)                                 /* Is argument bad?         */\n         return -1;                              /* Yes, abort.              */\n@@ -324,4 +330,102 @@ objc_mutex_unlock(_objc_mutex_t mutex)\n     return 0;                                   /* No, return success.      */\n }\n \n+/********\n+ *  Allocate a condition.  Return the condition pointer if successful or NULL\n+ * if the allocation failed for any reason.\n+ */\n+objc_condition_t\n+objc_condition_allocate(void)\n+{\n+    objc_condition_t condition;\n+\n+    if (!(condition = (objc_condition_t)objc_malloc(\n+                        sizeof(struct objc_condition))))\n+        return NULL;                            /* Abort if malloc failed.  */\n+\n+    cond_init(&(condition->condition), USYNC_THREAD, NULL);\n+\n+    return condition;                           /* Return new condition     */\n+}\n+\n+/********\n+ *  Deallocate a condition. Note that this includes an implicit\n+ *  condition_broadcast to insure that waiting threads have the opportunity\n+ *  to wake.  It is legal to dealloc a condition only if no other\n+ *  thread is/will be using it. Here we do NOT check for other threads\n+ *  waiting but just wake them up.\n+ */\n+int\n+objc_condition_deallocate(objc_condition_t condition)\n+{\n+    cond_broadcast(&(condition->condition));    /* Wakeup waiting threads   */\n+    cond_destroy(&(condition->condition));      /* Kill condition           */\n+    objc_free(condition);                       /* Release struct memory    */\n+    return 0;\n+}\n+\n+/********\n+ *  Wait on the condition unlocking the mutex until objc_condition_signal()\n+ *  or objc_condition_broadcast() are called for the same condition. The\n+ *  given mutex *must* have the depth set to 1 so that it can be unlocked\n+ *  here, so that someone else can lock it and signal/broadcast the condition.\n+ *  The mutex is used to lock access to the shared data that make up the\n+ *  \"condition\" predicate.\n+ */\n+int\n+objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n+{\n+    objc_thread_t    thread_id;                /* Cache our thread id.     */\n+\n+    if (!mutex || !condition)                   /* Is argument bad?         */\n+        return -1;                              /* Yes, abort.              */\n+\n+    thread_id = objc_thread_id();               /* Get this thread's id.    */\n+    if (mutex->owner != thread_id)              /* Does some else own lock? */\n+        return -1;                              /* Yes, abort.              */\n+    if (mutex->depth > 1)                       /* Locked more than once ?  */\n+        return -1;                              /* YES, return error        */\n+                                                /* mutex will be unlocked   */\n+    mutex->depth = 0;                           /* Yes, reset depth to 0.   */\n+    mutex->owner = (objc_thread_t) -1;         /* Set owner to \"no thread\".*/\n+\n+    cond_wait(&(condition->condition),\n+        &(mutex->lock));                        /* unlock, wait ..., lock   */\n+\n+    mutex->owner = thread_id;                   /* Mark thread as owner.    */\n+    mutex->depth = 1;                           /* Must be here !           */\n+\n+    return 0;                                   /* Return success.          */\n+}\n+\n+/********\n+ *  Wake up all threads waiting on this condition. It is recommended that\n+ *  the called would lock the same mutex as the threads in objc_condition_wait\n+ *  before changing the \"condition predicate\" and make this call and unlock it\n+ *  right away after this call.\n+ */\n+int\n+objc_condition_broadcast(objc_condition_t condition)\n+{\n+    if (!condition)\n+        return -1;\n+    cond_broadcast(&(condition->condition));\n+    return 0;\n+}\n+\n+/********\n+ *  Wake up one thread waiting on this condition. It is recommended that\n+ *  the called would lock the same mutex as the threads in objc_condition_wait\n+ *  before changing the \"condition predicate\" and make this call and unlock it\n+ *  right away after this call.\n+ */\n+int\n+objc_condition_signal(objc_condition_t condition)\n+{\n+    if (!condition)\n+        return -1;\n+    cond_signal(&(condition->condition));\n+    return 0;\n+}\n+\n /* End of File */"}]}