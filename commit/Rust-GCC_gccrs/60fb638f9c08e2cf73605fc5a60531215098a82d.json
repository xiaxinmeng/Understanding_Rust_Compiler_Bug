{"sha": "60fb638f9c08e2cf73605fc5a60531215098a82d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjBmYjYzOGY5YzA4ZTJjZjczNjA1ZmM1YTYwNTMxMjE1MDk4YTgyZA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2017-01-04T04:32:48Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2017-01-04T04:32:48Z"}, "message": "re PR target/78900 (ICE in gcc.target/powerpc/signbit-3.c)\n\n[gcc]\n2016-12-30  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/78900\n\t* config/rs6000/rs6000.c (rs6000_split_signbit): Change some\n\tassertions.  Add support for doing the signbit if the IEEE 128-bit\n\tfloating point value is in a GPR.\n\t* config/rs6000/rs6000.md (Fsignbit): Delete.\n\t(signbit<mode>2_dm): Delete using <Fsignbit> and just use \"wa\".\n\tUpdate the length attribute if the value is in a GPR.\n\t(signbit<mode>2_dm_<su>ext): Add combiner pattern to eliminate\n\tthe sign or zero extension instruction, since the value is always\n\t0/1.\n\t(signbit<mode>2_dm2): Delete using <Fsignbit>.\n\n2017-01-03  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/78953\n\t* config/rs6000/vsx.md (vsx_extract_<mode>_store_p9): If we are\n\textracting SImode to a GPR register so that we can generate a\n\tstore, limit the vector to be in a traditional Altivec register\n\tfor the vextuwrx instruction.\n\n[gcc/testsuite]\n2017-01-03  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/78953\n\t* gcc.target/powerpc/pr78953.c: New test.\n\nFrom-SVN: r244044", "tree": {"sha": "b58e5f12cc14d7b64cda24d04cebfcef8d6d4907", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b58e5f12cc14d7b64cda24d04cebfcef8d6d4907"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/60fb638f9c08e2cf73605fc5a60531215098a82d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60fb638f9c08e2cf73605fc5a60531215098a82d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60fb638f9c08e2cf73605fc5a60531215098a82d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60fb638f9c08e2cf73605fc5a60531215098a82d/comments", "author": null, "committer": null, "parents": [{"sha": "c671a0d674de28574cad46b83ea7e141b7297cbd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c671a0d674de28574cad46b83ea7e141b7297cbd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c671a0d674de28574cad46b83ea7e141b7297cbd"}], "stats": {"total": 95, "additions": 77, "deletions": 18}, "files": [{"sha": "3114e02af6734b35ac409c0332b0ad396b08dbb4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60fb638f9c08e2cf73605fc5a60531215098a82d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60fb638f9c08e2cf73605fc5a60531215098a82d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=60fb638f9c08e2cf73605fc5a60531215098a82d", "patch": "@@ -1,3 +1,23 @@\n+2016-12-30  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/78900\n+\t* config/rs6000/rs6000.c (rs6000_split_signbit): Change some\n+\tassertions.  Add support for doing the signbit if the IEEE 128-bit\n+\tfloating point value is in a GPR.\n+\t* config/rs6000/rs6000.md (Fsignbit): Delete.\n+\t(signbit<mode>2_dm): Delete using <Fsignbit> and just use \"wa\".\n+\tUpdate the length attribute if the value is in a GPR.\n+\t(signbit<mode>2_dm_<su>ext): Add combiner pattern to eliminate\n+\tthe sign or zero extension instruction, since the value is always\n+\t0/1.\n+\t(signbit<mode>2_dm2): Delete using <Fsignbit>.\n+\n+\tPR target/78953\n+\t* config/rs6000/vsx.md (vsx_extract_<mode>_store_p9): If we are\n+\textracting SImode to a GPR register so that we can generate a\n+\tstore, limit the vector to be in a traditional Altivec register\n+\tfor the vextuwrx instruction.\n+\n 2017-01-03  Ian Lance Taylor  <iant@google.com>\n \n \t* godump.c (go_format_type): Treat ENUMERAL_TYPE like"}, {"sha": "a287a2363b38d8ae3341f7ac7c37e0c906f83732", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60fb638f9c08e2cf73605fc5a60531215098a82d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60fb638f9c08e2cf73605fc5a60531215098a82d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=60fb638f9c08e2cf73605fc5a60531215098a82d", "patch": "@@ -25170,9 +25170,7 @@ rs6000_split_signbit (rtx dest, rtx src)\n   rtx dest_di = (d_mode == DImode) ? dest : gen_lowpart (DImode, dest);\n   rtx shift_reg = dest_di;\n \n-  gcc_assert (REG_P (dest));\n-  gcc_assert (REG_P (src) || MEM_P (src));\n-  gcc_assert (s_mode == KFmode || s_mode == TFmode);\n+  gcc_assert (FLOAT128_IEEE_P (s_mode) && TARGET_POWERPC64);\n \n   if (MEM_P (src))\n     {\n@@ -25184,17 +25182,20 @@ rs6000_split_signbit (rtx dest, rtx src)\n \n   else\n     {\n-      unsigned int r = REGNO (src);\n+      unsigned int r = reg_or_subregno (src);\n \n-      /* If this is a VSX register, generate the special mfvsrd instruction\n-\t to get it in a GPR.  Until we support SF and DF modes, that will\n-\t always be true.  */\n-      gcc_assert (VSX_REGNO_P (r));\n+      if (INT_REGNO_P (r))\n+\tshift_reg = gen_rtx_REG (DImode, r + (BYTES_BIG_ENDIAN == 0));\n \n-      if (s_mode == KFmode)\n-\temit_insn (gen_signbitkf2_dm2 (dest_di, src));\n       else\n-\temit_insn (gen_signbittf2_dm2 (dest_di, src));\n+\t{\n+\t  /* Generate the special mfvsrd instruction to get it in a GPR.  */\n+\t  gcc_assert (VSX_REGNO_P (r));\n+\t  if (s_mode == KFmode)\n+\t    emit_insn (gen_signbitkf2_dm2 (dest_di, src));\n+\t  else\n+\t    emit_insn (gen_signbittf2_dm2 (dest_di, src));\n+\t}\n     }\n \n   emit_insn (gen_lshrdi3 (dest_di, shift_reg, GEN_INT (63)));"}, {"sha": "7e103b019f0dda22e913bd34c4192c63da610a76", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60fb638f9c08e2cf73605fc5a60531215098a82d/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60fb638f9c08e2cf73605fc5a60531215098a82d/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=60fb638f9c08e2cf73605fc5a60531215098a82d", "patch": "@@ -518,9 +518,6 @@\n (define_mode_iterator SIGNBIT [(KF \"FLOAT128_VECTOR_P (KFmode)\")\n \t\t\t       (TF \"FLOAT128_VECTOR_P (TFmode)\")])\n \n-(define_mode_attr Fsignbit\t[(KF \"wa\")\n-\t\t\t\t (TF \"wa\")])\n-\n ; Iterator for ISA 3.0 supported floating point types\n (define_mode_iterator FP_ISA3 [SF\n \t\t\t       DF\n@@ -4744,7 +4741,7 @@\n (define_insn_and_split \"signbit<mode>2_dm\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r,r\")\n \t(unspec:SI\n-\t [(match_operand:SIGNBIT 1 \"input_operand\" \"<Fsignbit>,m,r\")]\n+\t [(match_operand:SIGNBIT 1 \"input_operand\" \"wa,m,r\")]\n \t UNSPEC_SIGNBIT))]\n   \"TARGET_POWERPC64 && TARGET_DIRECT_MOVE\"\n   \"#\"\n@@ -4754,15 +4751,32 @@\n   rs6000_split_signbit (operands[0], operands[1]);\n   DONE;\n }\n- [(set_attr \"length\" \"8,8,12\")\n+ [(set_attr \"length\" \"8,8,4\")\n+  (set_attr \"type\" \"mftgpr,load,integer\")])\n+\n+(define_insn_and_split \"*signbit<mode>2_dm_<su>ext\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r,r\")\n+\t(any_extend:DI\n+\t (unspec:SI\n+\t  [(match_operand:SIGNBIT 1 \"input_operand\" \"wa,m,r\")]\n+\t  UNSPEC_SIGNBIT)))]\n+  \"TARGET_POWERPC64 && TARGET_DIRECT_MOVE\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+{\n+  rs6000_split_signbit (operands[0], operands[1]);\n+  DONE;\n+}\n+ [(set_attr \"length\" \"8,8,4\")\n   (set_attr \"type\" \"mftgpr,load,integer\")])\n \n ;; MODES_TIEABLE_P doesn't allow DImode to be tied with the various floating\n ;; point types, which makes normal SUBREG's problematical. Instead use a\n ;; special pattern to avoid using a normal movdi.\n (define_insn \"signbit<mode>2_dm2\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n-\t(unspec:DI [(match_operand:SIGNBIT 1 \"gpc_reg_operand\" \"<Fsignbit>\")\n+\t(unspec:DI [(match_operand:SIGNBIT 1 \"gpc_reg_operand\" \"wa\")\n \t\t    (const_int 0)]\n \t\t   UNSPEC_SIGNBIT))]\n   \"TARGET_POWERPC64 && TARGET_DIRECT_MOVE\""}, {"sha": "6264e6c72069831c2f0fa6dde08047830049d50a", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60fb638f9c08e2cf73605fc5a60531215098a82d/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60fb638f9c08e2cf73605fc5a60531215098a82d/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=60fb638f9c08e2cf73605fc5a60531215098a82d", "patch": "@@ -2628,7 +2628,7 @@\n (define_insn_and_split \"*vsx_extract_<mode>_store_p9\"\n   [(set (match_operand:<VS_scalar> 0 \"memory_operand\" \"=Z,m\")\n \t(vec_select:<VS_scalar>\n-\t (match_operand:VSX_EXTRACT_I 1 \"gpc_reg_operand\" \"<VSX_EX>,<VSX_EX>\")\n+\t (match_operand:VSX_EXTRACT_I 1 \"gpc_reg_operand\" \"<VSX_EX>,v\")\n \t (parallel [(match_operand:QI 2 \"const_int_operand\" \"n,n\")])))\n    (clobber (match_scratch:<VS_scalar> 3 \"=<VSX_EX>,&r\"))\n    (clobber (match_scratch:SI 4 \"=X,&r\"))]"}, {"sha": "cd2a065ec14cf55164c00157ef41ea50c1e8d147", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60fb638f9c08e2cf73605fc5a60531215098a82d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60fb638f9c08e2cf73605fc5a60531215098a82d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=60fb638f9c08e2cf73605fc5a60531215098a82d", "patch": "@@ -1,3 +1,8 @@\n+2017-01-03  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/78953\n+\t* gcc.target/powerpc/pr78953.c: New test.\n+\n 2017-01-03  Ian Lance Taylor  <iant@google.com>\n \n \t* gcc.misc-tests/godump-1.c: Update for accurate representation of"}, {"sha": "34a3083918da124c5a3e38d385172046b10252f5", "filename": "gcc/testsuite/gcc.target/powerpc/pr78953.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60fb638f9c08e2cf73605fc5a60531215098a82d/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr78953.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60fb638f9c08e2cf73605fc5a60531215098a82d/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr78953.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr78953.c?ref=60fb638f9c08e2cf73605fc5a60531215098a82d", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile { target { powerpc64*-*-* && lp64 } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9 -O2 -mupper-regs-di\" } */\n+\n+#include <altivec.h>\n+\n+/* PR 78953: mem = vec_extract (V4SI, <n>) failed if the vector was in a\n+   traditional FPR register.  */\n+\n+void\n+foo (vector int *vp, int *ip)\n+{\n+  vector int v = *vp;\n+  __asm__ (\" # fpr %x0\" : \"+d\" (v));\n+  ip[4] = vec_extract (v, 0);\n+}\n+\n+/* { dg-final { scan-assembler \"xxextractuw\\|vextuw\\[lr\\]x\" } } */"}]}