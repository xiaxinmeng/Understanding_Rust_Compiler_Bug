{"sha": "954b452ada953bcbc8d2f9ee802dfd74df079f8d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTU0YjQ1MmFkYTk1M2JjYmM4ZDJmOWVlODAyZGZkNzRkZjA3OWY4ZA==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2017-01-24T00:55:19Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2017-01-24T00:55:19Z"}, "message": "PR middle-end/78703 - -fprintf-return-value floating point handling incorrect...\n\nPR middle-end/78703 - -fprintf-return-value floating point handling incorrect in locales with a mulltibyte decimal point\n\t* gimple-ssa-sprintf.c (pass_sprintf_length::gate): Adjust formatting.\n\t(fmtresult::operator+=): Outlined.\n\t(struct fmtresult): Add ctors.\n\t(struct conversion_spec): Rename...\n\t(struct directive): ...to this.  Add and remove data members.\n\t(directive::set_width, directive::set_precision): New functions.\n\t(format_percent): Use fmtresult ctor.\n\t(get_width_and_precision): Remove.\n\t(format_integer): Make naming changes.  Avoid computing width and\n\tprecision.\n\t(format_floating): Same.  Adjust indentation.\n\t(format_character, format_none): New functions.\n\t(format_string): Moved character handling to format_character.\n\t(format_directive): Remove arguments, change return type.\n\t(parse_directive): New function.\n\t(pass_sprintf_length::compute_format_length): Move directive\n\tparsing to parse_directive.\n\nFrom-SVN: r244845", "tree": {"sha": "b0a68a7d37f5154d1428b9d0d44d3e8a329759d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0a68a7d37f5154d1428b9d0d44d3e8a329759d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/954b452ada953bcbc8d2f9ee802dfd74df079f8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/954b452ada953bcbc8d2f9ee802dfd74df079f8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/954b452ada953bcbc8d2f9ee802dfd74df079f8d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/954b452ada953bcbc8d2f9ee802dfd74df079f8d/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "86b2a5583b9494d2e80803fd6e325e123516d9f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86b2a5583b9494d2e80803fd6e325e123516d9f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86b2a5583b9494d2e80803fd6e325e123516d9f0"}], "stats": {"total": 1464, "additions": 804, "deletions": 660}, "files": [{"sha": "c7988667891ec5f2e686d95874f982a0e56a0c47", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/954b452ada953bcbc8d2f9ee802dfd74df079f8d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/954b452ada953bcbc8d2f9ee802dfd74df079f8d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=954b452ada953bcbc8d2f9ee802dfd74df079f8d", "patch": "@@ -1,3 +1,24 @@\n+2017-01-23  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/78703\n+\t* gimple-ssa-sprintf.c (pass_sprintf_length::gate): Adjust formatting.\n+\t(fmtresult::operator+=): Outlined.\n+\t(struct fmtresult): Add ctors.\n+\t(struct conversion_spec): Rename...\n+\t(struct directive): ...to this.  Add and remove data members.\n+\t(directive::set_width, directive::set_precision): New functions.\n+\t(format_percent): Use fmtresult ctor.\n+\t(get_width_and_precision): Remove.\n+\t(format_integer): Make naming changes.  Avoid computing width and\n+\tprecision.\n+\t(format_floating): Same.  Adjust indentation.\n+\t(format_character, format_none): New functions.\n+\t(format_string): Moved character handling to format_character.\n+\t(format_directive): Remove arguments, change return type.\n+\t(parse_directive): New function.\n+\t(pass_sprintf_length::compute_format_length): Move directive\n+\tparsing to parse_directive.\n+\n 2017-01-23  Jakub Jelinek  <jakub@redhat.com>\n \n \t* tree.h (assign_assembler_name_if_neeeded): Rename to ..."}, {"sha": "7fbd4a036994bb1c5c83c98bbbe037913a6b5cc5", "filename": "gcc/gimple-ssa-sprintf.c", "status": "modified", "additions": 783, "deletions": 660, "changes": 1443, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/954b452ada953bcbc8d2f9ee802dfd74df079f8d/gcc%2Fgimple-ssa-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/954b452ada953bcbc8d2f9ee802dfd74df079f8d/gcc%2Fgimple-ssa-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-sprintf.c?ref=954b452ada953bcbc8d2f9ee802dfd74df079f8d", "patch": "@@ -82,7 +82,7 @@ along with GCC; see the file COPYING3.  If not see\n /* The likely worst case value of MB_LEN_MAX for the target, large enough\n    for UTF-8.  Ideally, this would be obtained by a target hook if it were\n    to be used for optimization but it's good enough as is for warnings.  */\n-#define target_mb_len_max   6\n+#define target_mb_len_max()   6\n \n /* The maximum number of bytes a single non-string directive can result\n    in.  This is the result of printf(\"%.*Lf\", INT_MAX, -LDBL_MAX) for\n@@ -141,7 +141,9 @@ pass_sprintf_length::gate (function *)\n      not optimizing and the pass is being invoked early, or when\n      optimizing and the pass is being invoked during optimization\n      (i.e., \"late\").  */\n-  return ((warn_format_overflow > 0 || flag_printf_return_value)\n+  return ((warn_format_overflow > 0\n+\t   || warn_format_trunc > 0\n+\t   || flag_printf_return_value)\n \t  && (optimize > 0) == fold_return_value);\n }\n \n@@ -215,20 +217,26 @@ struct format_result\n   }\n \n   /* Increment the number of output characters by N.  */\n-  format_result& operator+= (unsigned HOST_WIDE_INT n)\n-  {\n-    gcc_assert (n < HOST_WIDE_INT_MAX);\n-\n-    if (number_chars < HOST_WIDE_INT_MAX)\n-      number_chars += n;\n-    if (number_chars_min < HOST_WIDE_INT_MAX)\n-      number_chars_min += n;\n-    if (number_chars_max < HOST_WIDE_INT_MAX)\n-      number_chars_max += n;\n-    return *this;\n-  }\n+  format_result& operator+= (unsigned HOST_WIDE_INT);\n };\n \n+format_result&\n+format_result::operator+= (unsigned HOST_WIDE_INT n)\n+{\n+  gcc_assert (n < HOST_WIDE_INT_MAX);\n+\n+  if (number_chars < HOST_WIDE_INT_MAX)\n+    number_chars += n;\n+\n+  if (number_chars_min < HOST_WIDE_INT_MAX)\n+    number_chars_min += n;\n+\n+  if (number_chars_max < HOST_WIDE_INT_MAX)\n+    number_chars_max += n;\n+\n+  return *this;\n+}\n+\n /* Return the value of INT_MIN for the target.  */\n \n static inline HOST_WIDE_INT\n@@ -438,10 +446,30 @@ struct result_range\n \n struct fmtresult\n {\n-  fmtresult ()\n-  : argmin (), argmax (), knownrange (), bounded (), constant (), nullp ()\n+  /* Construct a FMTRESULT object with all counters initialized\n+     to MIN.  KNOWNRANGE is set when MIN is valid.  */\n+  fmtresult (unsigned HOST_WIDE_INT min = HOST_WIDE_INT_MAX)\n+  : argmin (), argmax (),\n+    knownrange (min < HOST_WIDE_INT_MAX),\n+    bounded (),\n+    constant (),\n+    nullp ()\n   {\n-    range.min = range.max = HOST_WIDE_INT_MAX;\n+    range.min = min;\n+    range.max = min;\n+  }\n+\n+  /* Construct a FMTRESULT object with all counters initialized\n+     to MIN.  KNOWNRANGE is set when MIN is valid.  */\n+  fmtresult (unsigned HOST_WIDE_INT min, unsigned HOST_WIDE_INT max)\n+  : argmin (), argmax (),\n+    knownrange (min < HOST_WIDE_INT_MAX && max < HOST_WIDE_INT_MAX),\n+    bounded (),\n+    constant (),\n+    nullp ()\n+  {\n+    range.min = min;\n+    range.max = min;\n   }\n \n   /* The range a directive's argument is in.  */\n@@ -474,40 +502,36 @@ struct fmtresult\n \n /* Description of a conversion specification.  */\n \n-struct conversion_spec\n+struct directive\n {\n+  /* The 1-based directive number (for debugging).  */\n+  unsigned dirno;\n+\n+  /* The first character of the directive and its length.  */\n+  const char *beg;\n+  size_t len;\n+\n   /* A bitmap of flags, one for each character.  */\n   unsigned flags[256 / sizeof (int)];\n-  /* Numeric width as in \"%8x\".  */\n-  int width;\n-  /* Numeric precision as in \"%.32s\".  */\n-  int precision;\n \n-  /* Width specified via the '*' character.  Need not be INTEGER_CST.\n-     For vararg functions set to void_node.  */\n-  tree star_width;\n-  /* Precision specified via the asterisk.  Need not be INTEGER_CST.\n-     For vararg functions set to void_node.  */\n-  tree star_precision;\n+  /* The specified width, or -1 if not specified.  */\n+  HOST_WIDE_INT width;\n+  /* The specified precision, or -1 if not specified.  */\n+  HOST_WIDE_INT prec;\n \n   /* Length modifier.  */\n   format_lengths modifier;\n \n   /* Format specifier character.  */\n   char specifier;\n \n-  /* Numeric width was given.  */\n-  unsigned have_width: 1;\n-  /* Numeric precision was given.  */\n-  unsigned have_precision: 1;\n-  /* Non-zero when certain flags should be interpreted even for a directive\n-     that normally doesn't accept them (used when \"%p\" with flags such as\n-     space or plus is interepreted as a \"%x\".  */\n-  unsigned force_flags: 1;\n+  /* The argument of the directive or null when the directive doesn't\n+     take one or when none is available (such as for vararg functions).  */\n+  tree arg;\n \n   /* Format conversion function that given a conversion specification\n      and an argument returns the formatting result.  */\n-  fmtresult (*fmtfunc) (const conversion_spec &, tree);\n+  fmtresult (*fmtfunc) (const directive &, tree);\n \n   /* Return True when a the format flag CHR has been used.  */\n   bool get_flag (char chr) const\n@@ -532,6 +556,56 @@ struct conversion_spec\n     flags[c / (CHAR_BIT * sizeof *flags)]\n       &= ~(1U << (c % (CHAR_BIT * sizeof *flags)));\n   }\n+\n+  /* Set the width to VAL.  */\n+  void set_width (HOST_WIDE_INT val)\n+  {\n+    width = val;\n+  }\n+\n+  /* Set the width to ARG.  */\n+  void set_width (tree arg)\n+  {\n+    if (tree_fits_shwi_p (arg))\n+      {\n+\twidth = tree_to_shwi (arg);\n+\tif (width < 0)\n+\t  {\n+\t    if (width == HOST_WIDE_INT_MIN)\n+\t      {\n+\t\t/* Avoid undefined behavior due to negating a minimum.\n+\t\t   This case will be diagnosed since it will result in\n+\t\t   more than INT_MAX bytes on output, either by the\n+\t\t   directive itself (when INT_MAX < HOST_WIDE_INT_MAX)\n+\t\t   or by the format function itself.  */\n+\t\twidth = HOST_WIDE_INT_MAX;\n+\t      }\n+\t    else\n+\t      width = -width;\n+\t  }\n+      }\n+    else\n+      width = HOST_WIDE_INT_MIN;\n+  }\n+\n+  /* Set the precision to val.  */\n+  void set_precision (HOST_WIDE_INT val)\n+  {\n+    prec = val;\n+  }\n+\n+  /* Set the precision to ARG.  */\n+  void set_precision (tree arg)\n+  {\n+    if (tree_fits_shwi_p (arg))\n+      {\n+\tprec = tree_to_shwi (arg);\n+\tif (prec < 0)\n+\t  prec = -1;\n+      }\n+    else\n+      prec = HOST_WIDE_INT_MIN;\n+  }\n };\n \n /* Return the logarithm of X in BASE.  */\n@@ -738,14 +812,22 @@ struct pass_sprintf_length::call_info\n   }\n };\n \n+/* Return the result of formatting a no-op directive (such as '%n').  */\n+\n+static fmtresult\n+format_none (const directive &, tree)\n+{\n+  fmtresult res (0);\n+  res.bounded = res.constant = true;\n+  return res;\n+}\n+\n /* Return the result of formatting the '%%' directive.  */\n \n static fmtresult\n-format_percent (const conversion_spec &, tree)\n+format_percent (const directive &, tree)\n {\n-  fmtresult res;\n-  res.argmin = res.argmax = NULL_TREE;\n-  res.range.min = res.range.max = 1;\n+  fmtresult res (1);\n   res.bounded = res.constant = true;\n   return res;\n }\n@@ -791,59 +873,6 @@ build_intmax_type_nodes (tree *pintmax, tree *puintmax)\n     }\n }\n \n-/* Set *PWIDTH and *PPREC according to the width and precision specified\n-   in SPEC.  Each is set to HOST_WIDE_INT_MIN when the corresponding\n-   field is specified but unknown, to zero for width and -1 for precision,\n-   respectively when it's not specified, or to a non-negative value\n-   corresponding to the known value.  */\n-\n-static void\n-get_width_and_precision (const conversion_spec &spec,\n-\t\t\t HOST_WIDE_INT *pwidth, HOST_WIDE_INT *pprec)\n-{\n-  HOST_WIDE_INT width = spec.have_width ? spec.width : 0;\n-  HOST_WIDE_INT prec = spec.have_precision ? spec.precision : -1;\n-\n-  if (spec.star_width)\n-    {\n-      if (TREE_CODE (spec.star_width) == INTEGER_CST)\n-\t{\n-\t  width = tree_to_shwi (spec.star_width);\n-\t  if (width < 0)\n-\t    {\n-\t      if (width == HOST_WIDE_INT_MIN)\n-\t\t{\n-\t\t  /* Avoid undefined behavior due to negating a minimum.\n-\t\t     This case will be diagnosed since it will result in\n-\t\t     more than INT_MAX bytes on output, either by the\n-\t\t     directive itself (when INT_MAX < HOST_WIDE_INT_MAX)\n-\t\t     or by the format function itself.  */\n-\t\t  width = HOST_WIDE_INT_MAX;\n-\t\t}\n-\t      else\n-\t\twidth = -width;\n-\t    }\n-\t}\n-      else\n-\twidth = HOST_WIDE_INT_MIN;\n-    }\n-\n-  if (spec.star_precision)\n-    {\n-      if (TREE_CODE (spec.star_precision) == INTEGER_CST)\n-\t{\n-\t  prec = tree_to_shwi (spec.star_precision);\n-\t  if (prec < 0)\n-\t    prec = -1;\n-\t}\n-      else\n-\tprec = HOST_WIDE_INT_MIN;\n-    }\n-\n-  *pwidth = width;\n-  *pprec = prec;\n-}\n-\n /* With the range [*ARGMIN, *ARGMAX] of an integer directive's actual\n    argument, due to the conversion from either *ARGMIN or *ARGMAX to\n    the type of the directive's formal argument it's possible for both\n@@ -908,32 +937,31 @@ adjust_range_for_overflow (tree dirtype, tree *argmin, tree *argmax)\n }\n \n /* Return a range representing the minimum and maximum number of bytes\n-   that the conversion specification SPEC will write on output for the\n+   that the conversion specification DIR will write on output for the\n    integer argument ARG when non-null.  ARG may be null (for vararg\n    functions).  */\n \n static fmtresult\n-format_integer (const conversion_spec &spec, tree arg)\n+format_integer (const directive &dir, tree arg)\n {\n   tree intmax_type_node;\n   tree uintmax_type_node;\n \n   /* Set WIDTH and PRECISION based on the specification.  */\n-  HOST_WIDE_INT width;\n-  HOST_WIDE_INT prec;\n-  get_width_and_precision (spec, &width, &prec);\n+  HOST_WIDE_INT width = dir.width;\n+  HOST_WIDE_INT prec = dir.prec;\n \n-  bool sign = spec.specifier == 'd' || spec.specifier == 'i';\n+  bool sign = dir.specifier == 'd' || dir.specifier == 'i';\n \n   /* The type of the \"formal\" argument expected by the directive.  */\n   tree dirtype = NULL_TREE;\n \n   /* Determine the expected type of the argument from the length\n      modifier.  */\n-  switch (spec.modifier)\n+  switch (dir.modifier)\n     {\n     case FMT_LEN_none:\n-      if (spec.specifier == 'p')\n+      if (dir.specifier == 'p')\n \tdirtype = ptr_type_node;\n       else\n \tdirtype = sign ? integer_type_node : unsigned_type_node;\n@@ -1000,12 +1028,12 @@ format_integer (const conversion_spec &spec, tree arg)\n       /* True when a signed conversion is preceded by a sign or space.  */\n       bool maybesign = false;\n \n-      switch (spec.specifier)\n+      switch (dir.specifier)\n \t{\n \tcase 'd':\n \tcase 'i':\n \t  /* Space and '+' are  only meaningful for signed conversions.  */\n-\t  maybesign = spec.get_flag (' ') | spec.get_flag ('+');\n+\t  maybesign = dir.get_flag (' ') | dir.get_flag ('+');\n \t  base = 10;\n \t  break;\n \tcase 'u':\n@@ -1033,7 +1061,7 @@ format_integer (const conversion_spec &spec, tree arg)\n \t     when it results in just one byte (with width having the normal\n \t     effect).  This must extend to the case of a specified precision\n \t     with an unknown value because it can be zero.  */\n-\t  len = ((base == 8 && spec.get_flag ('#')) || maybesign);\n+\t  len = ((base == 8 && dir.get_flag ('#')) || maybesign);\n \t}\n       else\n \t{\n@@ -1042,7 +1070,7 @@ format_integer (const conversion_spec &spec, tree arg)\n \n \t  /* True when a conversion is preceded by a prefix indicating the base\n \t     of the argument (octal or hexadecimal).  */\n-\t  bool maybebase = spec.get_flag ('#');\n+\t  bool maybebase = dir.get_flag ('#');\n \t  len = tree_digits (arg, base, prec, maybesign, maybebase);\n \t  if (len < 1)\n \t    len = HOST_WIDE_INT_MAX;\n@@ -1137,7 +1165,7 @@ format_integer (const conversion_spec &spec, tree arg)\n \t      if (code == INTEGER_CST)\n \t\t{\n \t\t  arg = gimple_assign_rhs1 (def);\n-\t\t  return format_integer (spec, arg);\n+\t\t  return format_integer (dir, arg);\n \t\t}\n \n \t      if (code == NOP_EXPR)\n@@ -1215,8 +1243,8 @@ format_integer (const conversion_spec &spec, tree arg)\n       /* For unsigned conversions/directives, use the minimum (i.e., 0\n \t or 1) and maximum to compute the shortest and longest output,\n \t respectively.  */\n-      res.range.min = format_integer (spec, argmin).range.min;\n-      res.range.max = format_integer (spec, argmax).range.max;\n+      res.range.min = format_integer (dir, argmin).range.min;\n+      res.range.max = format_integer (dir, argmax).range.max;\n     }\n   else\n     {\n@@ -1225,8 +1253,8 @@ format_integer (const conversion_spec &spec, tree arg)\n \t to compute the longest output.  This is important when precision\n \t is specified but unknown because otherwise both output lengths\n \t would reflect the largest possible precision (i.e., INT_MAX).  */\n-      res.range.min = format_integer (spec, argmax).range.min;\n-      res.range.max = format_integer (spec, argmin).range.max;\n+      res.range.min = format_integer (dir, argmax).range.min;\n+      res.range.max = format_integer (dir, argmin).range.max;\n     }\n \n   /* The result is bounded either when the argument is determined to be\n@@ -1336,11 +1364,7 @@ format_floating_max (tree type, char spec, HOST_WIDE_INT prec)\n   const real_format *rfmt = REAL_MODE_FORMAT (mode);\n   REAL_VALUE_TYPE rv;\n \n-  {\n-    char buf[256];\n-    get_max_float (rfmt, buf, sizeof buf);\n-    real_from_string (&rv, buf);\n-  }\n+  real_maxval (&rv, 0, mode);\n \n   /* Convert the GCC real value representation with the precision\n      of the real type to the mpfr_t format with the GCC default\n@@ -1354,17 +1378,16 @@ format_floating_max (tree type, char spec, HOST_WIDE_INT prec)\n }\n \n /* Return a range representing the minimum and maximum number of bytes\n-   that the conversion specification SPEC will output for any argument\n-   given the WIDTH and PRECISION (extracted from SPEC).  This function\n+   that the conversion specification DIR will output for any argument\n+   given the WIDTH and PRECISION (extracted from DIR).  This function\n    is used when the directive argument or its value isn't known.  */\n \n static fmtresult\n-format_floating (const conversion_spec &spec, HOST_WIDE_INT width,\n-\t\t HOST_WIDE_INT prec)\n+format_floating (const directive &dir)\n {\n   tree type;\n \n-  switch (spec.modifier)\n+  switch (dir.modifier)\n     {\n     case FMT_LEN_l:\n     case FMT_LEN_none:\n@@ -1391,10 +1414,10 @@ format_floating (const conversion_spec &spec, HOST_WIDE_INT width,\n \n   /* The minimum output as determined by flags.  It's always at least 1.  */\n   int flagmin = (1 /* for the first digit */\n-\t\t + (spec.get_flag ('+') | spec.get_flag (' '))\n-\t\t + (prec == 0 && spec.get_flag ('#')));\n+\t\t + (dir.get_flag ('+') | dir.get_flag (' '))\n+\t\t + (dir.prec == 0 && dir.get_flag ('#')));\n \n-  if (width == INT_MIN || prec == INT_MIN)\n+  if (dir.width == HOST_WIDE_INT_MIN || dir.prec == HOST_WIDE_INT_MIN)\n     {\n       /* When either width or precision is specified but unknown\n \t the upper bound is the maximum.  Otherwise it will be\n@@ -1404,16 +1427,16 @@ format_floating (const conversion_spec &spec, HOST_WIDE_INT width,\n   else\n     res.range.max = HOST_WIDE_INT_M1U;\n \n-  switch (spec.specifier)\n+  switch (dir.specifier)\n     {\n     case 'A':\n     case 'a':\n       {\n-\tres.range.min = flagmin + 5 + (prec > 0 ? prec + 1 : 0);\n+\tres.range.min = flagmin + 5 + (dir.prec > 0 ? dir.prec + 1 : 0);\n \tif (res.range.max == HOST_WIDE_INT_M1U)\n \t  {\n \t    /* Compute the upper bound for -TYPE_MAX.  */\n-\t    res.range.max = format_floating_max (type, 'a', prec);\n+\t    res.range.max = format_floating_max (type, 'a', dir.prec);\n \t  }\n \n \tbreak;\n@@ -1425,16 +1448,16 @@ format_floating (const conversion_spec &spec, HOST_WIDE_INT width,\n \t/* The minimum output is \"[-+]1.234567e+00\" regardless\n \t   of the value of the actual argument.  */\n \tres.range.min = (flagmin\n-\t\t\t + (prec == INT_MIN\n-\t\t\t    ? 0 : prec < 0 ? 7 : prec ? prec + 1 : 0)\n+\t\t\t + (dir.prec == HOST_WIDE_INT_MIN\n+\t\t\t    ? 0 : dir.prec < 0 ? 7 : dir.prec ? dir.prec + 1 : 0)\n \t\t\t + 2 /* e+ */ + 2);\n \n \tif (res.range.max == HOST_WIDE_INT_M1U)\n \t  {\n \t    /* MPFR uses a precision of 16 by default for some reason.\n \t       Set it to the C default of 6.  */\n \t    res.range.max = format_floating_max (type, 'e',\n-\t\t\t\t\t\t -1 == prec ? 6 : prec);\n+\t\t\t\t\t\t -1 == dir.prec ? 6 : dir.prec);\n \t  }\n \tbreak;\n       }\n@@ -1448,14 +1471,14 @@ format_floating (const conversion_spec &spec, HOST_WIDE_INT width,\n \t   when precision is greater than zero, then the lower bound\n \t   is 2 plus precision (plus flags).  */\n \tres.range.min = (flagmin\n-\t\t\t + (prec != INT_MIN)   /* for decimal point */\n-\t\t\t + (prec == INT_MIN\n-\t\t\t    ? 0 : prec < 0 ? 6 : prec ? prec : -1));\n+\t\t\t + (dir.prec != HOST_WIDE_INT_MIN)   /* decimal point */\n+\t\t\t + (dir.prec == HOST_WIDE_INT_MIN\n+\t\t\t    ? 0 : dir.prec < 0 ? 6 : dir.prec ? dir.prec : -1));\n \n \tif (res.range.max == HOST_WIDE_INT_M1U)\n \t  {\n \t    /* Compute the upper bound for -TYPE_MAX.  */\n-\t    res.range.max = format_floating_max (type, 'f', prec);\n+\t    res.range.max = format_floating_max (type, 'f', dir.prec);\n \t  }\n \tbreak;\n       }\n@@ -1472,7 +1495,7 @@ format_floating (const conversion_spec &spec, HOST_WIDE_INT width,\n \t  {\n \t    /* Compute the upper bound for -TYPE_MAX which should be\n \t       the lesser of %e and %f.  */\n-\t    res.range.max = format_floating_max (type, 'g', prec);\n+\t    res.range.max = format_floating_max (type, 'g', dir.prec);\n \t  }\n \tbreak;\n       }\n@@ -1481,148 +1504,118 @@ format_floating (const conversion_spec &spec, HOST_WIDE_INT width,\n       return fmtresult ();\n     }\n \n-  if (width > 0)\n+  if (dir.width > 0)\n     {\n       /* If width has been specified use it to adjust the range.  */\n-      if (res.range.min < (unsigned)width)\n-\tres.range.min = width;\n-      if (res.range.max < (unsigned)width)\n-\tres.range.max = width;\n+      if (res.range.min < (unsigned)dir.width)\n+\tres.range.min = dir.width;\n+      if (res.range.max < (unsigned)dir.width)\n+\tres.range.max = dir.width;\n     }\n \n   return res;\n }\n \n /* Return a range representing the minimum and maximum number of bytes\n-   that the conversion specification SPEC will write on output for the\n+   that the conversion specification DIR will write on output for the\n    floating argument ARG.  */\n \n static fmtresult\n-format_floating (const conversion_spec &spec, tree arg)\n+format_floating (const directive &dir, tree arg)\n {\n-  /* Set WIDTH to -1 when it's not specified, to HOST_WIDE_INT_MIN when\n-     it is specified by the asterisk to an unknown value, and otherwise\n-     to a non-negative value corresponding to the specified width.  */\n-  HOST_WIDE_INT width = -1;\n-  HOST_WIDE_INT prec = -1;\n+  if (!arg || TREE_CODE (arg) != REAL_CST)\n+    return format_floating (dir);\n \n-  /* The minimum and maximum number of bytes produced by the directive.  */\n-  fmtresult res;\n-  res.constant = arg && TREE_CODE (arg) == REAL_CST;\n+  HOST_WIDE_INT prec = dir.prec;\n \n-  if (spec.have_width)\n-    width = spec.width;\n-  else if (spec.star_width)\n-    {\n-      if (TREE_CODE (spec.star_width) == INTEGER_CST)\n-\t{\n-\t  width = tree_to_shwi (spec.star_width);\n-\t  if (width < 0)\n-\t    width = -width;\n-\t}\n-      else\n-\twidth = INT_MIN;\n-    }\n-\n-  if (spec.have_precision)\n-    prec = spec.precision;\n-  else if (spec.star_precision)\n-    {\n-      if (TREE_CODE (spec.star_precision) == INTEGER_CST)\n-\t{\n-\t  prec = tree_to_shwi (spec.star_precision);\n-\t  if (prec < 0)\n-\t    prec = -1;\n-\t}\n-      else\n-\tprec = INT_MIN;\n-    }\n-  else if (res.constant && TOUPPER (spec.specifier) != 'A')\n+  if (prec < 0 && TOUPPER (dir.specifier) != 'A')\n     {\n       /* Specify the precision explicitly since mpfr_sprintf defaults\n \t to zero.  */\n       prec = 6;\n     }\n \n-  if (res.constant)\n-    {\n-      /* Get the real type format desription for the target.  */\n-      const REAL_VALUE_TYPE *rvp = TREE_REAL_CST_PTR (arg);\n-      const real_format *rfmt = REAL_MODE_FORMAT (TYPE_MODE (TREE_TYPE (arg)));\n+  /* The minimum and maximum number of bytes produced by the directive.  */\n+  fmtresult res;\n+  res.constant = true;\n+\n+  /* Get the real type format desription for the target.  */\n+  const REAL_VALUE_TYPE *rvp = TREE_REAL_CST_PTR (arg);\n+  const real_format *rfmt = REAL_MODE_FORMAT (TYPE_MODE (TREE_TYPE (arg)));\n \n-      /* Convert the GCC real value representation with the precision\n-\t of the real type to the mpfr_t format with the GCC default\n-\t round-to-nearest mode.  */\n-      mpfr_t mpfrval;\n-      mpfr_init2 (mpfrval, rfmt->p);\n-      mpfr_from_real (mpfrval, rvp, GMP_RNDN);\n+  char fmtstr [40];\n+  char *pfmt = fmtstr;\n \n-      char fmtstr [40];\n-      char *pfmt = fmtstr;\n+  /* Append flags.  */\n+  for (const char *pf = \"-+ #0\"; *pf; ++pf)\n+    if (dir.get_flag (*pf))\n+      *pfmt++ = *pf;\n \n-      /* Append flags.  */\n-      for (const char *pf = \"-+ #0\"; *pf; ++pf)\n-\tif (spec.get_flag (*pf))\n-\t  *pfmt++ = *pf;\n+  *pfmt = '\\0';\n \n-      *pfmt = '\\0';\n+  {\n+    /* Set up an array to easily iterate over.  */\n+    unsigned HOST_WIDE_INT* const minmax[] = {\n+      &res.range.min, &res.range.max\n+    };\n \n+    for (int i = 0; i != sizeof minmax / sizeof *minmax; ++i)\n       {\n-\t/* Set up an array to easily iterate over below.  */\n-\tunsigned HOST_WIDE_INT* const minmax[] = {\n-\t  &res.range.min, &res.range.max\n-\t};\n-\t\n-\tfor (int i = 0; i != sizeof minmax / sizeof *minmax; ++i)\n-\t  {\n-\t    /* Use the MPFR rounding specifier to round down in the first\n-\t       iteration and then up.  In most but not all cases this will\n-\t       result in the same number of bytes.  */\n-\t    char rndspec = \"DU\"[i];\n-\n-\t    /* Format it and store the result in the corresponding member\n-\t       of the result struct.  */\n-\t    unsigned HOST_WIDE_INT len\n-\t      = get_mpfr_format_length (mpfrval, fmtstr, prec,\n-\t\t\t\t\tspec.specifier, rndspec);\n-\t    if (0 < width && len < (unsigned)width)\n-\t      len = width;\n-\n-\t    *minmax[i] = len;\n-\t}\n+\t/* Convert the GCC real value representation with the precision\n+\t   of the real type to the mpfr_t format rounding down in the\n+\t   first iteration that computes the minimm and up in the second\n+\t   that computes the maximum.  This order is arbibtrary because\n+\t   rounding in either direction can result in longer output.  */\n+\tmpfr_t mpfrval;\n+\tmpfr_init2 (mpfrval, rfmt->p);\n+\tmpfr_from_real (mpfrval, rvp, i ? MPFR_RNDU : MPFR_RNDD);\n+\n+\t/* Use the MPFR rounding specifier to round down in the first\n+\t   iteration and then up.  In most but not all cases this will\n+\t   result in the same number of bytes.  */\n+\tchar rndspec = \"DU\"[i];\n+\n+\t/* Format it and store the result in the corresponding member\n+\t   of the result struct.  */\n+\tunsigned HOST_WIDE_INT len\n+\t  = get_mpfr_format_length (mpfrval, fmtstr, prec,\n+\t\t\t\t    dir.specifier, rndspec);\n+\n+\tif (0 < dir.width && len < (unsigned)dir.width)\n+\t  len = dir.width;\n+\n+\t*minmax[i] = len;\n       }\n+  }\n \n-      /* Make sure the minimum is less than the maximum (MPFR rounding\n-\t in the call to mpfr_snprintf can result in the reverse.  */\n-      if (res.range.max < res.range.min)\n-\t{\n-\t  unsigned HOST_WIDE_INT tmp = res.range.min;\n-\t  res.range.min = res.range.max;\n-\t  res.range.max = tmp;\n-\t}\n-\n-      /* The range of output is known even if the result isn't bounded.  */\n-      if (width == HOST_WIDE_INT_MIN)\n-\t{\n-\t  res.knownrange = false;\n-\t  res.range.max = HOST_WIDE_INT_MAX;\n-\t}\n-      else\n-\tres.knownrange = true;\n-\n-      /* The output of all directives except \"%a\" is fully specified\n-\t and so the result is bounded unless it exceeds INT_MAX.\n-\t For \"%a\" the output is fully specified only when precision\n-\t is explicitly specified.  */\n-      res.bounded = (res.knownrange\n-\t\t     && (TOUPPER (spec.specifier) != 'A'\n-\t\t\t || (0 <= prec && (unsigned) prec < target_int_max ()))\n-\t\t     && res.range.min < target_int_max ());\n+  /* Make sure the minimum is less than the maximum (MPFR rounding\n+     in the call to mpfr_snprintf can result in the reverse.  */\n+  if (res.range.max < res.range.min)\n+    {\n+      unsigned HOST_WIDE_INT tmp = res.range.min;\n+      res.range.min = res.range.max;\n+      res.range.max = tmp;\n+    }\n \n-      return res;\n+  /* The range of output is known even if the result isn't bounded.  */\n+  if (dir.width == HOST_WIDE_INT_MIN)\n+    {\n+      res.knownrange = false;\n+      res.range.max = HOST_WIDE_INT_MAX;\n     }\n+  else\n+    res.knownrange = true;\n+\n+  /* The output of all directives except \"%a\" is fully specified\n+     and so the result is bounded unless it exceeds INT_MAX.\n+     For \"%a\" the output is fully specified only when precision\n+     is explicitly specified.  */\n+  res.bounded = (res.knownrange\n+\t\t && (TOUPPER (dir.specifier) != 'A'\n+\t\t     || (0 <= dir.prec && (unsigned) dir.prec < target_int_max ()))\n+\t\t && res.range.min < target_int_max ());\n \n-  return format_floating (spec, width, prec);\n+  return res;\n }\n \n /* Return a FMTRESULT struct set to the lengths of the shortest and longest\n@@ -1681,191 +1674,211 @@ get_string_length (tree str)\n }\n \n /* Return the minimum and maximum number of characters formatted\n-   by the '%c' and '%s' format directives and ther wide character\n-   forms for the argument ARG.  ARG can be null (for functions\n-   such as vsprinf).  */\n+   by the '%c' format directives and its wide character form for\n+   the argument ARG.  ARG can be null (for functions such as\n+   vsprinf).  */\n \n static fmtresult\n-format_string (const conversion_spec &spec, tree arg)\n+format_character (const directive &dir, tree arg)\n {\n-  /* Set WIDTH and PRECISION based on the specification.  */\n-  HOST_WIDE_INT width;\n-  HOST_WIDE_INT prec;\n-  get_width_and_precision (spec, &width, &prec);\n-\n   fmtresult res;\n \n   /* The maximum number of bytes for an unknown wide character argument\n      to a \"%lc\" directive adjusted for precision but not field width.\n      6 is the longest UTF-8 sequence for a single wide character.  */\n   const unsigned HOST_WIDE_INT max_bytes_for_unknown_wc\n-    = (0 <= prec ? prec : warn_format_overflow > 1 ? 6 : 1);\n+    = (0 <= dir.prec ? dir.prec : warn_format_overflow > 1 ? 6 : 1);\n+\n+    if (dir.modifier == FMT_LEN_l)\n+    {\n+      /* Positive if the argument is a wide NUL character?  */\n+      int nul = (arg && TREE_CODE (arg) == INTEGER_CST\n+\t\t ? integer_zerop (arg) : -1);\n+\n+      /* A '%lc' directive is the same as '%ls' for a two element\n+\t wide string character with the second element of NUL, so\n+\t when the character is unknown the minimum number of bytes\n+\t is the smaller of either 0 (at level 1) or 1 (at level 2)\n+\t and WIDTH, and the maximum is MB_CUR_MAX in the selected\n+\t locale, which is unfortunately, unknown.  */\n+      res.range.min = warn_format_overflow == 1 ? !nul : nul < 1;\n+      res.range.max = max_bytes_for_unknown_wc;\n+      /* The range above is good enough to issue warnings but not\n+\t for value range propagation, so clear BOUNDED.  */\n+      res.bounded = false;\n+    }\n+  else\n+    {\n+      /* A plain '%c' directive.  Its ouput is exactly 1.  */\n+      res.range.min = res.range.max = 1;\n+      res.bounded = true;\n+      res.knownrange = true;\n+      res.constant = arg && TREE_CODE (arg) == INTEGER_CST;\n+    }\n+\n+  /* Adjust the lengths for field width.  */\n+  if (0 < dir.width)\n+    {\n+      if (res.range.min < (unsigned HOST_WIDE_INT)dir.width)\n+\tres.range.min = dir.width;\n+\n+      if (res.range.max < (unsigned HOST_WIDE_INT)dir.width)\n+\tres.range.max = dir.width;\n+\n+      /* Adjust BOUNDED if width happens to make them equal.  */\n+      if (res.range.min == res.range.max && res.range.min < target_int_max ())\n+\tres.bounded = true;\n+    }\n+\n+  /* When precision is specified the range of characters on output\n+     is known to be bounded by it.  */\n+  if (-1 < dir.width && -1 < dir.prec)\n+    res.knownrange = true;\n+\n+  return res;\n+}\n+\n+/* Return the minimum and maximum number of characters formatted\n+   by the '%c' and '%s' format directives and ther wide character\n+   forms for the argument ARG.  ARG can be null (for functions\n+   such as vsprinf).  */\n+\n+static fmtresult\n+format_string (const directive &dir, tree arg)\n+{\n+  fmtresult res;\n \n   /* The maximum number of bytes for an unknown string argument to either\n      a \"%s\" or \"%ls\" directive adjusted for precision but not field width.  */\n   const unsigned HOST_WIDE_INT max_bytes_for_unknown_str\n-    = (0 <= prec ? prec : warn_format_overflow > 1);\n+    = (0 <= dir.prec ? dir.prec : warn_format_overflow > 1);\n \n   /* The result is bounded unless overriddden for a non-constant string\n      of an unknown length.  */\n   bool bounded = true;\n \n-  if (spec.specifier == 'c')\n-    {\n-      if (spec.modifier == FMT_LEN_l)\n-\t{\n-\t  /* Positive if the argument is a wide NUL character?  */\n-\t  int nul = (arg && TREE_CODE (arg) == INTEGER_CST\n-\t\t     ? integer_zerop (arg) : -1);\n-\n-\t  /* A '%lc' directive is the same as '%ls' for a two element\n-\t     wide string character with the second element of NUL, so\n-\t     when the character is unknown the minimum number of bytes\n-\t     is the smaller of either 0 (at level 1) or 1 (at level 2)\n-\t     and WIDTH, and the maximum is MB_CUR_MAX in the selected\n-\t     locale, which is unfortunately, unknown.  */\n-\t  res.range.min = warn_format_overflow == 1 ? !nul : nul < 1;\n-\t  res.range.max = max_bytes_for_unknown_wc;\n-\t  /* The range above is good enough to issue warnings but not\n-\t     for value range propagation, so clear BOUNDED.  */\n-\t  res.bounded = false;\n-\t}\n-      else\n-\t{\n-\t  /* A plain '%c' directive.  Its ouput is exactly 1.  */\n-\t  res.range.min = res.range.max = 1;\n-\t  res.bounded = true;\n-\t  res.knownrange = true;\n-\t  res.constant = arg && TREE_CODE (arg) == INTEGER_CST;\n-\t}\n-    }\n-  else   /* spec.specifier == 's' */\n+  /* Compute the range the argument's length can be in.  */\n+  fmtresult slen = get_string_length (arg);\n+  if (slen.constant)\n     {\n-      /* Compute the range the argument's length can be in.  */\n-      fmtresult slen = get_string_length (arg);\n-      if (slen.constant)\n-\t{\n-\t  gcc_checking_assert (slen.range.min == slen.range.max);\n-\n-\t  /* A '%s' directive with a string argument with constant length.  */\n-\t  res.range = slen.range;\n+      gcc_checking_assert (slen.range.min == slen.range.max);\n \n-\t  /* The output of \"%s\" and \"%ls\" directives with a constant\n-\t     string is in a known range unless width of an unknown value\n-\t     is specified.  For \"%s\" it is the length of the string.  For\n-\t     \"%ls\" it is in the range [length, length * MB_LEN_MAX].\n-\t     (The final range can be further constrained by width and\n-\t     precision but it's always known.)  */\n-\t  res.knownrange = -1 < width;\n+      /* A '%s' directive with a string argument with constant length.  */\n+      res.range = slen.range;\n \n-\t  if (spec.modifier == FMT_LEN_l)\n-\t    {\n-\t      bounded = false;\n+      /* The output of \"%s\" and \"%ls\" directives with a constant\n+\t string is in a known range unless width of an unknown value\n+\t is specified.  For \"%s\" it is the length of the string.  For\n+\t \"%ls\" it is in the range [length, length * MB_LEN_MAX].\n+\t (The final range can be further constrained by width and\n+\t precision but it's always known.)  */\n+      res.knownrange = HOST_WIDE_INT_MIN != dir.width;\n \n-\t      if (warn_format_overflow > 1)\n-\t\t{\n-\t\t  /* Leave the minimum number of bytes the wide string\n-\t\t     converts to equal to its length and set the maximum\n-\t\t     to the worst case length which is the string length\n-\t\t     multiplied by MB_LEN_MAX.  */\n-\n-\t\t  /* It's possible to be smarter about computing the maximum\n-\t\t     by scanning the wide string for any 8-bit characters and\n-\t\t     if it contains none, using its length for the maximum.\n-\t\t     Even though this would be simple to do it's unlikely to\n-\t\t     be worth it when dealing with wide characters.  */\n-\t\t  res.range.max *= target_mb_len_max;\n-\t\t}\n+      if (dir.modifier == FMT_LEN_l)\n+\t{\n+\t  bounded = false;\n \n-\t      /* For a wide character string, use precision as the maximum\n-\t\t even if precision is greater than the string length since\n-\t\t the number of bytes the string converts to may be greater\n-\t\t (due to MB_CUR_MAX).  */\n-\t      if (0 <= prec)\n-\t\tres.range.max = prec;\n-\t    }\n-\t  else if (0 <= width)\n+\t  if (warn_format_overflow > 1)\n \t    {\n-\t      /* The output of a \"%s\" directive with a constant argument\n-\t\t and constant or no width is bounded.  It is constant if\n-\t\t precision is either not specified or it is specified and\n-\t\t its value is known.  */\n-\t      res.bounded = true;\n-\t      res.constant = prec != HOST_WIDE_INT_MIN;\n-\t    }\n-\t  else if (width == HOST_WIDE_INT_MIN)\n-\t    {\n-\t      /* Specified but unknown width makes the output unbounded.  */\n-\t      res.range.max = HOST_WIDE_INT_MAX;\n+\t      /* Leave the minimum number of bytes the wide string\n+\t\t converts to equal to its length and set the maximum\n+\t\t to the worst case length which is the string length\n+\t\t multiplied by MB_LEN_MAX.  */\n+\n+\t      /* It's possible to be smarter about computing the maximum\n+\t\t by scanning the wide string for any 8-bit characters and\n+\t\t if it contains none, using its length for the maximum.\n+\t\t Even though this would be simple to do it's unlikely to\n+\t\t be worth it when dealing with wide characters.  */\n+\t      res.range.max *= target_mb_len_max();\n \t    }\n \n-\t  if (0 <= prec && (unsigned HOST_WIDE_INT)prec < res.range.min)\n-\t    {\n-\t      res.range.min = prec;\n-\t      res.range.max = prec;\n-\t    }\n-\t  else if (prec == HOST_WIDE_INT_MIN)\n-\t    {\n-\t      /* When precision is specified but not known the lower\n-\t\t bound is assumed to be as low as zero.  */\n-\t      res.range.min = 0;\n-\t    }\n+\t  /* For a wide character string, use precision as the maximum\n+\t     even if precision is greater than the string length since\n+\t     the number of bytes the string converts to may be greater\n+\t     (due to MB_CUR_MAX).  */\n+\t  if (0 <= dir.prec)\n+\t    res.range.max = dir.prec;\n \t}\n-      else if (arg && integer_zerop (arg))\n+      else if (-1 <= dir.width)\n \t{\n-\t  /* Handle null pointer argument.  */\n-\n-\t  fmtresult res;\n-\t  res.range.min = 0;\n-\t  res.range.max = HOST_WIDE_INT_MAX;\n-\t  res.nullp = true;\n-\t  return res;\n+\t  /* The output of a \"%s\" directive with a constant argument\n+\t     and constant or no width is bounded.  It is constant if\n+\t     precision is either not specified or it is specified and\n+\t     its value is known.  */\n+\t  res.bounded = true;\n+\t  res.constant = dir.prec != HOST_WIDE_INT_MIN;\n \t}\n-      else\n+      else if (dir.width == HOST_WIDE_INT_MIN)\n \t{\n-\t  /* For a '%s' and '%ls' directive with a non-constant string,\n-\t     the minimum number of characters is the greater of WIDTH\n-\t     and either 0 in mode 1 or the smaller of PRECISION and 1\n-\t     in mode 2, and the maximum is PRECISION or -1 to disable\n-\t     tracking.  */\n+\t  /* Specified but unknown width makes the output unbounded.  */\n+\t  res.range.max = HOST_WIDE_INT_MAX;\n+\t}\n \n-\t  if (0 <= prec)\n-\t    {\n-\t      if (slen.range.min >= target_int_max ())\n-\t\tslen.range.min = 0;\n-\t      else if ((unsigned HOST_WIDE_INT)prec < slen.range.min)\n-\t\tslen.range.min = prec;\n-\n-\t      if ((unsigned HOST_WIDE_INT)prec < slen.range.max\n-\t\t  || slen.range.max >= target_int_max ())\n-\t\tslen.range.max = prec;\n-\t    }\n-\t  else if (slen.range.min >= target_int_max ())\n-\t    {\n-\t      slen.range.min = max_bytes_for_unknown_str;\n-\t      slen.range.max = max_bytes_for_unknown_str;\n-\t      bounded = false;\n-\t    }\n+      if (0 <= dir.prec && (unsigned HOST_WIDE_INT)dir.prec < res.range.min)\n+\t{\n+\t  res.range.min = dir.prec;\n+\t  res.range.max = dir.prec;\n+\t}\n+      else if (dir.prec == HOST_WIDE_INT_MIN)\n+\t{\n+\t  /* When precision is specified but not known the lower\n+\t     bound is assumed to be as low as zero.  */\n+\t  res.range.min = 0;\n+\t}\n+    }\n+  else if (arg && integer_zerop (arg))\n+    {\n+      /* Handle null pointer argument.  */\n \n-\t  res.range = slen.range;\n+      fmtresult res (0);\n+      res.nullp = true;\n+      return res;\n+    }\n+  else\n+    {\n+      /* For a '%s' and '%ls' directive with a non-constant string,\n+\t the minimum number of characters is the greater of WIDTH\n+\t and either 0 in mode 1 or the smaller of PRECISION and 1\n+\t in mode 2, and the maximum is PRECISION or -1 to disable\n+\t tracking.  */\n \n-\t  /* The output is considered bounded when a precision has been\n-\t     specified to limit the number of bytes or when the number\n-\t     of bytes is known or contrained to some range.  */\n-\t  res.bounded = 0 <= prec || slen.bounded;\n-\t  res.knownrange = slen.knownrange;\n-\t  res.constant = false;\n+      if (0 <= dir.prec)\n+\t{\n+\t  if (slen.range.min >= target_int_max ())\n+\t    slen.range.min = 0;\n+\t  else if ((unsigned HOST_WIDE_INT)dir.prec < slen.range.min)\n+\t    slen.range.min = dir.prec;\n+\n+\t  if ((unsigned HOST_WIDE_INT)dir.prec < slen.range.max\n+\t      || slen.range.max >= target_int_max ())\n+\t    slen.range.max = dir.prec;\n+\t}\n+      else if (slen.range.min >= target_int_max ())\n+\t{\n+\t  slen.range.min = max_bytes_for_unknown_str;\n+\t  slen.range.max = max_bytes_for_unknown_str;\n+\t  bounded = false;\n \t}\n+\n+      res.range = slen.range;\n+\n+      /* The output is considered bounded when a precision has been\n+\t specified to limit the number of bytes or when the number\n+\t of bytes is known or contrained to some range.  */\n+      res.bounded = 0 <= dir.prec || slen.bounded;\n+      res.knownrange = slen.knownrange;\n+      res.constant = false;\n     }\n \n   /* Adjust the lengths for field width.  */\n-  if (0 < width)\n+  if (0 < dir.width)\n     {\n-      if (res.range.min < (unsigned HOST_WIDE_INT)width)\n-\tres.range.min = width;\n+      if (res.range.min < (unsigned HOST_WIDE_INT)dir.width)\n+\tres.range.min = dir.width;\n \n-      if (res.range.max < (unsigned HOST_WIDE_INT)width)\n-\tres.range.max = width;\n+      if (res.range.max < (unsigned HOST_WIDE_INT)dir.width)\n+\tres.range.max = dir.width;\n \n       /* Adjust BOUNDED if width happens to make them equal.  */\n       if (res.range.min == res.range.max && res.range.min < target_int_max ()\n@@ -1875,22 +1888,25 @@ format_string (const conversion_spec &spec, tree arg)\n \n   /* When precision is specified the range of characters on output\n      is known to be bounded by it.  */\n-  if (-1 < width && -1 < prec)\n+  if (HOST_WIDE_INT_MIN != dir.width && HOST_WIDE_INT_MIN != dir.prec)\n     res.knownrange = true;\n \n   return res;\n }\n \n /* Compute the length of the output resulting from the conversion\n-   specification SPEC with the argument ARG in a call described by INFO\n+   specification DIR with the argument ARG in a call described by INFO\n    and update the overall result of the call in *RES.  The format directive\n-   corresponding to SPEC starts at CVTBEG and is CVTLEN characters long.  */\n+   corresponding to DIR starts at CVTBEG and is CVTLEN characters long.  */\n \n-static void\n+static bool\n format_directive (const pass_sprintf_length::call_info &info,\n-\t\t  format_result *res, const char *cvtbeg, size_t cvtlen,\n-\t\t  const conversion_spec &spec, tree arg)\n+\t\t  format_result *res, const directive &dir)\n {\n+  const char *cvtbeg = dir.beg;\n+  size_t cvtlen = dir.len;\n+  tree arg = dir.arg;\n+\n   /* Offset of the beginning of the directive from the beginning\n      of the format string.  */\n   size_t offset = cvtbeg - info.fmtstr;\n@@ -1914,11 +1930,11 @@ format_directive (const pass_sprintf_length::call_info &info,\n \n   /* Bail when there is no function to compute the output length,\n      or when minimum length checking has been disabled.   */\n-  if (!spec.fmtfunc || res->number_chars_min >= HOST_WIDE_INT_MAX)\n-    return;\n+  if (!dir.fmtfunc || res->number_chars_min >= HOST_WIDE_INT_MAX)\n+    return false;\n \n   /* Compute the (approximate) length of the formatted output.  */\n-  fmtresult fmtres = spec.fmtfunc (spec, arg);\n+  fmtresult fmtres = dir.fmtfunc (dir, arg);\n \n   /* The overall result is bounded and constant only if the output\n      of every directive is bounded and constant, respectively.  */\n@@ -1962,7 +1978,7 @@ format_directive (const pass_sprintf_length::call_info &info,\n \t     except in an error) but keep tracking the minimum and maximum\n \t     number of characters.  */\n \t  res->number_chars = HOST_WIDE_INT_M1U;\n-\t  return;\n+\t  return true;\n \t}\n     }\n \n@@ -1976,7 +1992,7 @@ format_directive (const pass_sprintf_length::call_info &info,\n       res->warned = true;\n       res->number_chars = HOST_WIDE_INT_M1U;\n       res->number_chars_min = res->number_chars_max = res->number_chars;\n-      return;\n+      return false;\n     }\n \n   bool warned = res->warned;\n@@ -2037,13 +2053,13 @@ format_directive (const pass_sprintf_length::call_info &info,\n \t\t}\n \t    }\n \t  else if (navail < fmtres.range.max\n-\t\t   && (spec.specifier != 's'\n+\t\t   && (dir.specifier != 's'\n \t\t       || fmtres.range.max < HOST_WIDE_INT_MAX)\n \t\t   && ((info.bounded\n \t\t\t&& (!info.retval_used ()\n \t\t\t    || warn_format_trunc > 1))\n \t\t       || (!info.bounded\n-\t\t\t   && (spec.specifier == 's'\n+\t\t\t   && (dir.specifier == 's'\n \t\t\t       || warn_format_overflow > 1))))\n \t    {\n \t      /* The maximum directive output is longer than there is\n@@ -2198,6 +2214,7 @@ format_directive (const pass_sprintf_length::call_info &info,\n     }\n \n   res->warned |= warned;\n+  return true;\n }\n \n /* Account for the number of bytes between BEG and END (or between\n@@ -2401,318 +2418,424 @@ add_bytes (const pass_sprintf_length::call_info &info,\n \n #pragma GCC diagnostic pop\n \n-/* Compute the length of the output resulting from the call to a formatted\n-   output function described by INFO and store the result of the call in\n-   *RES.  Issue warnings for detected past the end writes.  Return true\n-   if the complete format string has been processed and *RES can be relied\n-   on, false otherwise (e.g., when a unknown or unhandled directive was seen\n-   that caused the processing to be terminated early).  */\n+/* Parse a format directive in function call described by INFO starting\n+   at STR and populate DIR structure.  Bump up *ARGNO by the number of\n+   arguments extracted for the directive.  Return the length of\n+   the directive.  */\n \n-bool\n-pass_sprintf_length::compute_format_length (call_info &info,\n-\t\t\t\t\t    format_result *res)\n+static size_t\n+parse_directive (pass_sprintf_length::call_info &info,\n+\t\t directive &dir, format_result *res,\n+\t\t const char *str, unsigned *argno)\n {\n-  /* The variadic argument counter.  */\n-  unsigned argno = info.argidx;\n+  const char *pcnt = strchr (str, '%');\n+  dir.beg = str;\n \n-  /* Reset exact, minimum, and maximum character counters.  */\n-  res->number_chars = res->number_chars_min = res->number_chars_max = 0;\n+  if (size_t len = pcnt ? pcnt - str : *str ? strlen (str) : 1)\n+    {\n+      /* This directive is either a plain string or the terminating nul\n+\t (which isn't really a directive but it simplifies things to\n+\t handle it as if it were).  */\n+      dir.len = len;\n+      dir.fmtfunc = NULL;\n \n-  /* No directive has been seen yet so the length of output is bounded\n-     by the known range [0, 0] and constant (with no conversion producing\n-     more than 4K bytes) until determined otherwise.  */\n-  res->bounded = true;\n-  res->knownrange = true;\n-  res->constant = true;\n-  res->under4k = true;\n-  res->floating = false;\n-  res->warned = false;\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"  Directive %u at offset %zu: \\\"%.*s\\\", \"\n+\t\t   \"length = %zu\\n\",\n+\t\t   dir.dirno, (size_t)(dir.beg - info.fmtstr),\n+\t\t   (int)dir.len, dir.beg, dir.len);\n+\t}\n+\n+      return len - !*str;\n+    }\n+\n+  const char *pf = pcnt + 1;\n+\n+    /* POSIX numbered argument index or zero when none.  */\n+  unsigned dollar = 0;\n+\n+  /* With and precision.  -1 when not specified, HOST_WIDE_INT_MIN\n+     when given by a va_list argument, and a non-negative value\n+     when specified in the format string itself.  */\n+  HOST_WIDE_INT width = -1;\n+  HOST_WIDE_INT precision = -1;\n \n-  const char *pf = info.fmtstr;\n+  /* Width specified via the asterisk.  Need not be INTEGER_CST.\n+     For vararg functions set to void_node.  */\n+  tree star_width = NULL_TREE;\n+\n+  /* Width specified via the asterisk.  Need not be INTEGER_CST.\n+     For vararg functions set to void_node.  */\n+  tree star_precision = NULL_TREE;\n+\n+  if (ISDIGIT (*pf))\n+    {\n+      /* This could be either a POSIX positional argument, the '0'\n+\t flag, or a width, depending on what follows.  Store it as\n+\t width and sort it out later after the next character has\n+\t been seen.  */\n+      char *end;\n+      width = strtol (pf, &end, 10);\n+      pf = end;\n+    }\n+  else if ('*' == *pf)\n+    {\n+      /* Similarly to the block above, this could be either a POSIX\n+\t positional argument or a width, depending on what follows.  */\n+      if (*argno < gimple_call_num_args (info.callstmt))\n+\tstar_width = gimple_call_arg (info.callstmt, (*argno)++);\n+      else\n+\tstar_width = void_node;\n+      ++pf;\n+    }\n \n-  for ( ; ; )\n+  if (*pf == '$')\n     {\n-      /* The beginning of the next format directive.  */\n-      const char *dir = strchr (pf, '%');\n+      /* Handle the POSIX dollar sign which references the 1-based\n+\t positional argument number.  */\n+      if (width != -1)\n+\tdollar = width + info.argidx;\n+      else if (star_width\n+\t       && TREE_CODE (star_width) == INTEGER_CST)\n+\tdollar = width + tree_to_shwi (star_width);\n \n-      /* Add the number of bytes between the end of the last directive\n-\t and either the next if one exists, or the end of the format\n-\t string.  */\n-      add_bytes (info, pf, dir, res);\n+      /* Bail when the numbered argument is out of range (it will\n+\t have already been diagnosed by -Wformat).  */\n+      if (dollar == 0\n+\t  || dollar == info.argidx\n+\t  || dollar > gimple_call_num_args (info.callstmt))\n+\treturn false;\n \n-      if (!dir)\n-\tbreak;\n+      --dollar;\n \n-      pf = dir + 1;\n+      star_width = NULL_TREE;\n+      width = -1;\n+      ++pf;\n+    }\n \n-      if (0 && *pf == 0)\n+  if (dollar || !star_width)\n+    {\n+      if (width != -1)\n \t{\n-\t  /* Incomplete directive.  */\n-\t  return false;\n+\t  if (width == 0)\n+\t    {\n+\t      /* The '0' that has been interpreted as a width above is\n+\t\t actually a flag.  Reset HAVE_WIDTH, set the '0' flag,\n+\t\t and continue processing other flags.  */\n+\t      width = -1;\n+\t      dir.set_flag ('0');\n+\t    }\n+\t  else if (!dollar)\n+\t    {\n+\t      /* (Non-zero) width has been seen.  The next character\n+\t\t is either a period or a digit.  */\n+\t      goto start_precision;\n+\t    }\n \t}\n+      /* When either '$' has been seen, or width has not been seen,\n+\t the next field is the optional flags followed by an optional\n+\t width.  */\n+      for ( ; ; ) {\n+\tswitch (*pf)\n+\t  {\n+\t  case ' ':\n+\t  case '0':\n+\t  case '+':\n+\t  case '-':\n+\t  case '#':\n+\t    dir.set_flag (*pf++);\n+\t    break;\n+\n+\t  default:\n+\t    goto start_width;\n+\t  }\n+      }\n \n-      conversion_spec spec = conversion_spec ();\n-\n-      /* POSIX numbered argument index or zero when none.  */\n-      unsigned dollar = 0;\n-\n+    start_width:\n       if (ISDIGIT (*pf))\n \t{\n-\t  /* This could be either a POSIX positional argument, the '0'\n-\t     flag, or a width, depending on what follows.  Store it as\n-\t     width and sort it out later after the next character has\n-\t     been seen.  */\n \t  char *end;\n-\t  spec.width = strtol (pf, &end, 10);\n-\t  spec.have_width = true;\n+\t  width = strtol (pf, &end, 10);\n \t  pf = end;\n \t}\n       else if ('*' == *pf)\n \t{\n-\t  /* Similarly to the block above, this could be either a POSIX\n-\t     positional argument or a width, depending on what follows.  */\n-\t  if (argno < gimple_call_num_args (info.callstmt))\n-\t    spec.star_width = gimple_call_arg (info.callstmt, argno++);\n+\t  if (*argno < gimple_call_num_args (info.callstmt))\n+\t    star_width = gimple_call_arg (info.callstmt, (*argno)++);\n \t  else\n-\t    spec.star_width = void_node;\n+\t    {\n+\t      /* This is (likely) a va_list.  It could also be an invalid\n+\t\t call with insufficient arguments.  */\n+\t      star_width = void_node;\n+\t    }\n \t  ++pf;\n \t}\n-\n-      if (*pf == '$')\n+      else if ('\\'' == *pf)\n \t{\n-\t  /* Handle the POSIX dollar sign which references the 1-based\n-\t     positional argument number.  */\n-\t  if (spec.have_width)\n-\t    dollar = spec.width + info.argidx;\n-\t  else if (spec.star_width\n-\t\t   && TREE_CODE (spec.star_width) == INTEGER_CST)\n-\t    dollar = spec.width + tree_to_shwi (spec.star_width);\n-\n-\t  /* Bail when the numbered argument is out of range (it will\n-\t     have already been diagnosed by -Wformat).  */\n-\t  if (dollar == 0\n-\t      || dollar == info.argidx\n-\t      || dollar > gimple_call_num_args (info.callstmt))\n-\t    return false;\n+\t  /* The POSIX apostrophe indicating a numeric grouping\n+\t     in the current locale.  Even though it's possible to\n+\t     estimate the upper bound on the size of the output\n+\t     based on the number of digits it probably isn't worth\n+\t     continuing.  */\n+\t  return 0;\n+\t}\n+    }\n \n-\t  --dollar;\n+ start_precision:\n+  if ('.' == *pf)\n+    {\n+      ++pf;\n \n-\t  spec.star_width = NULL_TREE;\n-\t  spec.have_width = false;\n-\t  ++pf;\n+      if (ISDIGIT (*pf))\n+\t{\n+\t  char *end;\n+\t  precision = strtol (pf, &end, 10);\n+\t  pf = end;\n \t}\n-\n-      if (dollar || !spec.star_width)\n+      else if ('*' == *pf)\n \t{\n-\t  if (spec.have_width)\n-\t    {\n-\t      if (spec.width == 0)\n-\t\t{\n-\t\t  /* The '0' that has been interpreted as a width above is\n-\t\t     actually a flag.  Reset HAVE_WIDTH, set the '0' flag,\n-\t\t     and continue processing other flags.  */\n-\t\t  spec.have_width = false;\n-\t\t  spec.set_flag ('0');\n-\t\t}\n-\t      else if (!dollar)\n-\t\t{\n-\t\t  /* (Non-zero) width has been seen.  The next character\n-\t\t     is either a period or a digit.  */\n-\t\t  goto start_precision;\n-\t\t}\n-\t    }\n-\t  /* When either '$' has been seen, or width has not been seen,\n-\t     the next field is the optional flags followed by an optional\n-\t     width.  */\n-\t  for ( ; ; ) {\n-\t    switch (*pf)\n-\t      {\n-\t      case ' ':\n-\t      case '0':\n-\t      case '+':\n-\t      case '-':\n-\t      case '#':\n-\t\tspec.set_flag (*pf++);\n-\t\tbreak;\n-\n-\t      default:\n-\t\tgoto start_width;\n-\t      }\n-\t  }\n-\n-\tstart_width:\n-\t  if (ISDIGIT (*pf))\n-\t    {\n-\t      char *end;\n-\t      spec.width = strtol (pf, &end, 10);\n-\t      spec.have_width = true;\n-\t      pf = end;\n-\t    }\n-\t  else if ('*' == *pf)\n-\t    {\n-\t      if (argno < gimple_call_num_args (info.callstmt))\n-\t\tspec.star_width = gimple_call_arg (info.callstmt, argno++);\n-\t      else\n-\t\tspec.star_width = void_node;\n-\t      ++pf;\n-\t    }\n-\t  else if ('\\'' == *pf)\n+\t  if (*argno < gimple_call_num_args (info.callstmt))\n+\t    star_precision = gimple_call_arg (info.callstmt, (*argno)++);\n+\t  else\n \t    {\n-\t      /* The POSIX apostrophe indicating a numeric grouping\n-\t\t in the current locale.  Even though it's possible to\n-\t\t estimate the upper bound on the size of the output\n-\t\t based on the number of digits it probably isn't worth\n-\t\t continuing.  */\n-\t      return false;\n+\t      /* This is (likely) a va_list.  It could also be an invalid\n+\t\t call with insufficient arguments.  */\n+\t      star_precision = void_node;\n \t    }\n+\t  ++pf;\n \t}\n+      else\n+\t{\n+\t  /* The decimal precision or the asterisk are optional.\n+\t     When neither is dirified it's taken to be zero.  */\n+\t  precision = 0;\n+\t}\n+    }\n \n-    start_precision:\n-      if ('.' == *pf)\n+  switch (*pf)\n+    {\n+    case 'h':\n+      if (pf[1] == 'h')\n \t{\n \t  ++pf;\n-\n-\t  if (ISDIGIT (*pf))\n-\t    {\n-\t      char *end;\n-\t      spec.precision = strtol (pf, &end, 10);\n-\t      spec.have_precision = true;\n-\t      pf = end;\n-\t    }\n-\t  else if ('*' == *pf)\n-\t    {\n-\t      if (argno < gimple_call_num_args (info.callstmt))\n-\t\tspec.star_precision = gimple_call_arg (info.callstmt, argno++);\n-\t      else\n-\t\tspec.star_precision = void_node;\n-\t      ++pf;\n-\t    }\n-\t  else\n-\t    {\n-\t      /* The decimal precision or the asterisk are optional.\n-\t\t When neither is specified it's taken to be zero.  */\n-\t      spec.precision = 0;\n-\t      spec.have_precision = true;\n-\t    }\n+\t  dir.modifier = FMT_LEN_hh;\n \t}\n+      else\n+\tdir.modifier = FMT_LEN_h;\n+      ++pf;\n+      break;\n+\n+    case 'j':\n+      dir.modifier = FMT_LEN_j;\n+      ++pf;\n+      break;\n+\n+    case 'L':\n+      dir.modifier = FMT_LEN_L;\n+      ++pf;\n+      break;\n \n-      switch (*pf)\n+    case 'l':\n+      if (pf[1] == 'l')\n \t{\n-\tcase 'h':\n-\t  if (pf[1] == 'h')\n-\t    {\n-\t      ++pf;\n-\t      spec.modifier = FMT_LEN_hh;\n-\t    }\n-\t  else\n-\t    spec.modifier = FMT_LEN_h;\n \t  ++pf;\n-\t  break;\n+\t  dir.modifier = FMT_LEN_ll;\n+\t}\n+      else\n+\tdir.modifier = FMT_LEN_l;\n+      ++pf;\n+      break;\n \n-\tcase 'j':\n-\t  spec.modifier = FMT_LEN_j;\n-\t  ++pf;\n-\t  break;\n+    case 't':\n+      dir.modifier = FMT_LEN_t;\n+      ++pf;\n+      break;\n \n-\tcase 'L':\n-\t  spec.modifier = FMT_LEN_L;\n-\t  ++pf;\n-\t  break;\n+    case 'z':\n+      dir.modifier = FMT_LEN_z;\n+      ++pf;\n+      break;\n+    }\n \n-\tcase 'l':\n-\t  if (pf[1] == 'l')\n-\t    {\n-\t      ++pf;\n-\t      spec.modifier = FMT_LEN_ll;\n-\t    }\n-\t  else\n-\t    spec.modifier = FMT_LEN_l;\n-\t  ++pf;\n-\t  break;\n+  switch (*pf)\n+    {\n+      /* Handle a sole '%' character the same as \"%%\" but since it's\n+\t undefined prevent the result from being folded.  */\n+    case '\\0':\n+      --pf;\n+      res->bounded = false;\n+      /* FALLTHRU */\n+    case '%':\n+      dir.fmtfunc = format_percent;\n+      break;\n \n-\tcase 't':\n-\t  spec.modifier = FMT_LEN_t;\n-\t  ++pf;\n-\t  break;\n+    case 'a':\n+    case 'A':\n+    case 'e':\n+    case 'E':\n+    case 'f':\n+    case 'F':\n+    case 'g':\n+    case 'G':\n+      res->floating = true;\n+      dir.fmtfunc = format_floating;\n+      break;\n \n-\tcase 'z':\n-\t  spec.modifier = FMT_LEN_z;\n-\t  ++pf;\n-\t  break;\n+    case 'd':\n+    case 'i':\n+    case 'o':\n+    case 'u':\n+    case 'x':\n+    case 'X':\n+      dir.fmtfunc = format_integer;\n+      break;\n+\n+    case 'p':\n+      /* The %p output is implementation-defined.  It's possible\n+\t to determine this format but due to extensions (edirially\n+\t those of the Linux kernel -- see bug 78512) the first %p\n+\t in the format string disables any further processing.  */\n+      return false;\n+\n+    case 'n':\n+      /* %n has side-effects even when nothing is actually printed to\n+\t any buffer.  */\n+      info.nowrite = false;\n+      dir.fmtfunc = format_none;\n+      break;\n+\n+    case 'c':\n+      dir.fmtfunc = format_character;\n+      break;\n+\n+    case 'S':\n+    case 's':\n+      dir.fmtfunc = format_string;\n+      break;\n+\n+    default:\n+      /* Unknown conversion specification.  */\n+      return 0;\n+    }\n+\n+  dir.specifier = *pf++;\n+\n+  if (star_width)\n+    {\n+      if (TREE_CODE (TREE_TYPE (star_width)) == INTEGER_TYPE)\n+\tdir.set_width (star_width);\n+      else\n+\t{\n+\t  /* Width specified by a va_list takes on the range [0, -INT_MIN]\n+\t     (width is the absolute value of that specified).  */\n+\t  dir.width = HOST_WIDE_INT_MIN;\n \t}\n+    }\n+  else\n+    dir.set_width (width);\n \n-      switch (*pf)\n+  if (star_precision)\n+    {\n+      if (TREE_CODE (TREE_TYPE (star_precision)) == INTEGER_TYPE)\n+\tdir.set_precision (star_precision);\n+      else\n \t{\n-\t  /* Handle a sole '%' character the same as \"%%\" but since it's\n-\t     undefined prevent the result from being folded.  */\n-\tcase '\\0':\n-\t  --pf;\n-\t  res->bounded = false;\n-\t  /* FALLTHRU */\n-\tcase '%':\n-\t  spec.fmtfunc = format_percent;\n-\t  break;\n+\t  /* Precision specified by a va_list takes on the range [-1, INT_MAX]\n+\t     (unlike width, negative precision is ignored).  */\n+\t  dir.prec = HOST_WIDE_INT_MIN;\n+\t}\n+    }\n+  else\n+    dir.set_precision (precision);\n \n-\tcase 'a':\n-\tcase 'A':\n-\tcase 'e':\n-\tcase 'E':\n-\tcase 'f':\n-\tcase 'F':\n-\tcase 'g':\n-\tcase 'G':\n-\t  res->floating = true;\n-\t  spec.fmtfunc = format_floating;\n-\t  break;\n+  /* Extract the argument if the directive takes one and if it's\n+     available (e.g., the function doesn't take a va_list).  Treat\n+     missing arguments the same as va_list, even though they will\n+     have likely already been diagnosed by -Wformat.  */\n+  if (dir.specifier != '%'\n+      && *argno < gimple_call_num_args (info.callstmt))\n+    dir.arg = gimple_call_arg (info.callstmt, dollar ? dollar : (*argno)++);\n \n-\tcase 'd':\n-\tcase 'i':\n-\tcase 'o':\n-\tcase 'u':\n-\tcase 'x':\n-\tcase 'X':\n-\t  spec.fmtfunc = format_integer;\n-\t  break;\n+  /* Return the length of the format directive.  */\n+  dir.len = pf - pcnt;\n \n-\tcase 'p':\n-\t  /* The %p output is implementation-defined.  It's possible\n-\t     to determine this format but due to extensions (especially\n-\t     those of the Linux kernel -- see bug 78512) the first %p\n-\t     in the format string disables any further processing.  */\n-\t  return false;\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"  Directive %u at offset %zu: \\\"%.*s\\\"\",\n+\t       dir.dirno, (size_t)(dir.beg - info.fmtstr),\n+\t       (int)dir.len, dir.beg);\n+      if (star_width)\n+\tfprintf (dump_file, \", width = %lli\", (long long)dir.width);\n \n-\tcase 'n':\n-\t  /* %n has side-effects even when nothing is actually printed to\n-\t     any buffer.  */\n-\t  info.nowrite = false;\n-\t  break;\n+      if (star_precision)\n+\tfprintf (dump_file, \", precision = %lli\", (long long)dir.prec);\n \n-\tcase 'c':\n-\tcase 'S':\n-\tcase 's':\n-\t  spec.fmtfunc = format_string;\n-\t  break;\n+      fputc ('\\n', dump_file);\n+    }\n \n-\tdefault:\n-\t  /* Unknown conversion specification.  */\n-\t  return false;\n-\t}\n+  return dir.len;\n+}\n \n-      spec.specifier = *pf++;\n+/* Compute the length of the output resulting from the call to a formatted\n+   output function described by INFO and store the result of the call in\n+   *RES.  Issue warnings for detected past the end writes.  Return true\n+   if the complete format string has been processed and *RES can be relied\n+   on, false otherwise (e.g., when a unknown or unhandled directive was seen\n+   that caused the processing to be terminated early).  */\n \n-      /* Compute the length of the format directive.  */\n-      size_t dirlen = pf - dir;\n+bool\n+pass_sprintf_length::compute_format_length (call_info &info,\n+\t\t\t\t\t    format_result *res)\n+{\n+  /* Reset exact, minimum, and maximum character counters.  */\n+  res->number_chars = res->number_chars_min = res->number_chars_max = 0;\n+\n+  /* No directive has been seen yet so the length of output is bounded\n+     by the known range [0, 0] and constant (with no conversion producing\n+     more than 4K bytes) until determined otherwise.  */\n+  res->bounded = true;\n+  res->knownrange = true;\n+  res->constant = true;\n+  res->under4k = true;\n+  res->floating = false;\n+  res->warned = false;\n+\n+  /* 1-based directive counter.  */\n+  unsigned dirno = 1;\n+\n+  /* The variadic argument counter.  */\n+  unsigned argno = info.argidx;\n+\n+  for (const char *pf = info.fmtstr; ; ++dirno)\n+    {\n+      directive dir = directive ();\n+      dir.dirno = dirno;\n+\n+      size_t n = parse_directive (info, dir, res, pf, &argno);\n+\n+      if (dir.fmtfunc)\n+\t{\n+\t  /* Return failure if the format function fails.  */\n+\t  if (!format_directive (info, res, dir))\n+\t    return false;\n+\t}\n+      else\n+\t{\n+\t  /* Add the number of bytes between the end of the last directive\n+\t     and either the next if one exists, or the end of the format\n+\t     string.  */\n+\t  add_bytes (info, pf, n ? pf + n : NULL, res);\n+\t}\n \n-      /* Extract the argument if the directive takes one and if it's\n-\t available (e.g., the function doesn't take a va_list).  Treat\n-\t missing arguments the same as va_list, even though they will\n-\t have likely already been diagnosed by -Wformat.  */\n-      tree arg = NULL_TREE;\n-      if (spec.specifier != '%'\n-\t  && argno < gimple_call_num_args (info.callstmt))\n-\targ = gimple_call_arg (info.callstmt, dollar ? dollar : argno++);\n+      /* Return success the directive is zero bytes long and it's\n+\t the last think in the format string (i.e., it's the terminating\n+\t nul, which isn't really a directive but handling it as one makes\n+\t things simpler).  */\n+      if (!n)\n+\treturn *pf == '\\0';\n \n-      ::format_directive (info, res, dir, dirlen, spec, arg);\n+      pf += n;\n     }\n \n   /* Complete format string was processed (with or without warnings).  */"}]}