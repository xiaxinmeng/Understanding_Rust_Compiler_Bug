{"sha": "29ba9f52eee2ab585349ba71850bf9e0e5c86d3c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjliYTlmNTJlZWUyYWI1ODUzNDliYTcxODUwYmY5ZTBlNWM4NmQzYw==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2012-07-30T15:15:00Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-07-30T15:15:00Z"}, "message": "par_sco.adb, [...]: Minor reformatting.\n\n2012-07-30  Robert Dewar  <dewar@adacore.com>\n\n\t* par_sco.adb, a-cihama.adb, a-coinve.adb, exp_ch7.adb, a-ciorse.adb,\n\texp_ch9.adb, sem_dim.adb, par-ch13.adb, sem_ch9.adb, a-cidlli.adb,\n\ta-cimutr.adb, freeze.adb, a-ciormu.adb, sem_res.adb, sem_attr.adb,\n\ta-cihase.adb, exp_ch4.adb, sem_ch4.adb, a-ciorma.adb,\n\ts-tasinf-linux.ads, sem_ch13.adb, a-coinho.adb: Minor reformatting.\n\tAdd comments.\n\nFrom-SVN: r189977", "tree": {"sha": "10b4ccca210f1b877b9404f282c4e6fd1996100a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/10b4ccca210f1b877b9404f282c4e6fd1996100a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/29ba9f52eee2ab585349ba71850bf9e0e5c86d3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29ba9f52eee2ab585349ba71850bf9e0e5c86d3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29ba9f52eee2ab585349ba71850bf9e0e5c86d3c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29ba9f52eee2ab585349ba71850bf9e0e5c86d3c/comments", "author": null, "committer": null, "parents": [{"sha": "b5059fa0897458f65c8c2a30f3d16c8dbc1e0e03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5059fa0897458f65c8c2a30f3d16c8dbc1e0e03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5059fa0897458f65c8c2a30f3d16c8dbc1e0e03"}], "stats": {"total": 306, "additions": 201, "deletions": 105}, "files": [{"sha": "19dbf07fa6bc0d27df4436a41282b032db6c5edb", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ba9f52eee2ab585349ba71850bf9e0e5c86d3c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ba9f52eee2ab585349ba71850bf9e0e5c86d3c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=29ba9f52eee2ab585349ba71850bf9e0e5c86d3c", "patch": "@@ -1,3 +1,12 @@\n+2012-07-30  Robert Dewar  <dewar@adacore.com>\n+\n+\t* par_sco.adb, a-cihama.adb, a-coinve.adb, exp_ch7.adb, a-ciorse.adb,\n+\texp_ch9.adb, sem_dim.adb, par-ch13.adb, sem_ch9.adb, a-cidlli.adb,\n+\ta-cimutr.adb, freeze.adb, a-ciormu.adb, sem_res.adb, sem_attr.adb,\n+\ta-cihase.adb, exp_ch4.adb, sem_ch4.adb, a-ciorma.adb,\n+\ts-tasinf-linux.ads, sem_ch13.adb, a-coinho.adb: Minor reformatting.\n+\tAdd comments.\n+\n 2012-07-30  Vincent Pucci  <pucci@adacore.com>\n \n \t* sem_ch9.adb (Allows_Lock_Free_Implementation): Restrict implicit"}, {"sha": "fafe6719170e016ed55895276e62a20d6611eca9", "filename": "gcc/ada/a-cidlli.adb", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ba9f52eee2ab585349ba71850bf9e0e5c86d3c/gcc%2Fada%2Fa-cidlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ba9f52eee2ab585349ba71850bf9e0e5c86d3c/gcc%2Fada%2Fa-cidlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cidlli.adb?ref=29ba9f52eee2ab585349ba71850bf9e0e5c86d3c", "patch": "@@ -888,16 +888,19 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       end if;\n \n       declare\n-         pragma Unsuppress (Accessibility_Check);\n          --  The element allocator may need an accessibility check in the case\n          --  the actual type is class-wide or has access discriminants (see\n          --  RM 4.8(10.1) and AI12-0035). We don't unsuppress the check on the\n          --  allocator in the loop below, because the one in this block would\n          --  have failed already.\n \n+         pragma Unsuppress (Accessibility_Check);\n+\n          Element : Element_Access := new Element_Type'(New_Item);\n+\n       begin\n          New_Node := new Node_Type'(Element, null, null);\n+\n       exception\n          when others =>\n             Free (Element);\n@@ -1468,12 +1471,14 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       pragma Assert (Vet (Position), \"bad cursor in Replace_Element\");\n \n       declare\n-         pragma Unsuppress (Accessibility_Check);\n          --  The element allocator may need an accessibility check in the case\n          --  the actual type is class-wide or has access discriminants (see\n          --  RM 4.8(10.1) and AI12-0035).\n \n+         pragma Unsuppress (Accessibility_Check);\n+\n          X : Element_Access := Position.Node.Element;\n+\n       begin\n          Position.Node.Element := new Element_Type'(New_Item);\n          Free (X);"}, {"sha": "2ea73b9f960685370e53d70ed10f3df6b3626f91", "filename": "gcc/ada/a-cihama.adb", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ba9f52eee2ab585349ba71850bf9e0e5c86d3c/gcc%2Fada%2Fa-cihama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ba9f52eee2ab585349ba71850bf9e0e5c86d3c/gcc%2Fada%2Fa-cihama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cihama.adb?ref=29ba9f52eee2ab585349ba71850bf9e0e5c86d3c", "patch": "@@ -695,12 +695,15 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n          Position.Node.Key := new Key_Type'(Key);\n \n          declare\n-            pragma Unsuppress (Accessibility_Check);\n             --  The element allocator may need an accessibility check in the\n             --  case the actual type is class-wide or has access discriminants\n             --  (see RM 4.8(10.1) and AI12-0035).\n+\n+            pragma Unsuppress (Accessibility_Check);\n+\n          begin\n             Position.Node.Element := new Element_Type'(New_Item);\n+\n          exception\n             when others =>\n                Free_Key (K);\n@@ -736,14 +739,16 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n          K  : Key_Access := new Key_Type'(Key);\n          E  : Element_Access;\n \n-         pragma Unsuppress (Accessibility_Check);\n          --  The element allocator may need an accessibility check in the case\n          --  the actual type is class-wide or has access discriminants (see\n          --  RM 4.8(10.1) and AI12-0035).\n \n+         pragma Unsuppress (Accessibility_Check);\n+\n       begin\n          E := new Element_Type'(New_Item);\n          return new Node_Type'(K, E, Next);\n+\n       exception\n          when others =>\n             Free_Key (K);\n@@ -1177,12 +1182,15 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       Node.Key := new Key_Type'(Key);\n \n       declare\n-         pragma Unsuppress (Accessibility_Check);\n          --  The element allocator may need an accessibility check in the case\n          --  the actual type is class-wide or has access discriminants (see\n          --  RM 4.8(10.1) and AI12-0035).\n+\n+         pragma Unsuppress (Accessibility_Check);\n+\n       begin\n          Node.Element := new Element_Type'(New_Item);\n+\n       exception\n          when others =>\n             Free_Key (K);\n@@ -1230,10 +1238,12 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       declare\n          X : Element_Access := Position.Node.Element;\n \n-         pragma Unsuppress (Accessibility_Check);\n          --  The element allocator may need an accessibility check in the case\n          --  the actual type is class-wide or has access discriminants (see\n          --  RM 4.8(10.1) and AI12-0035).\n+\n+         pragma Unsuppress (Accessibility_Check);\n+\n       begin\n          Position.Node.Element := new Element_Type'(New_Item);\n          Free_Element (X);"}, {"sha": "9d96b6c645286ae8c4a10c598771d5db8949aaac", "filename": "gcc/ada/a-cihase.adb", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ba9f52eee2ab585349ba71850bf9e0e5c86d3c/gcc%2Fada%2Fa-cihase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ba9f52eee2ab585349ba71850bf9e0e5c86d3c/gcc%2Fada%2Fa-cihase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cihase.adb?ref=29ba9f52eee2ab585349ba71850bf9e0e5c86d3c", "patch": "@@ -186,10 +186,12 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n    procedure Assign (Node : Node_Access; Item : Element_Type) is\n       X : Element_Access := Node.Element;\n \n-      pragma Unsuppress (Accessibility_Check);\n       --  The element allocator may need an accessibility check in the case the\n       --  actual type is class-wide or has access discriminants (RM 4.8(10.1)\n       --  and AI12-0035).\n+\n+      pragma Unsuppress (Accessibility_Check);\n+\n    begin\n       Node.Element := new Element_Type'(Item);\n       Free_Element (X);\n@@ -199,10 +201,10 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n    begin\n       if Target'Address = Source'Address then\n          return;\n+      else\n+         Target.Clear;\n+         Target.Union (Source);\n       end if;\n-\n-      Target.Clear;\n-      Target.Union (Source);\n    end Assign;\n \n    --------------\n@@ -813,10 +815,12 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n          X := Position.Node.Element;\n \n          declare\n-            pragma Unsuppress (Accessibility_Check);\n             --  The element allocator may need an accessibility check in the\n             --  case the actual type is class-wide or has access discriminants\n             --  (see RM 4.8(10.1) and AI12-0035).\n+\n+            pragma Unsuppress (Accessibility_Check);\n+\n          begin\n             Position.Node.Element := new Element_Type'(New_Item);\n          end;\n@@ -875,14 +879,18 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       --------------\n \n       function New_Node (Next : Node_Access) return Node_Access is\n-         pragma Unsuppress (Accessibility_Check);\n+\n          --  The element allocator may need an accessibility check in the case\n          --  the actual type is class-wide or has access discriminants (see\n          --  RM 4.8(10.1) and AI12-0035).\n \n+         pragma Unsuppress (Accessibility_Check);\n+\n          Element : Element_Access := new Element_Type'(New_Item);\n+\n       begin\n          return new Node_Type'(Element, Next);\n+\n       exception\n          when others =>\n             Free_Element (Element);\n@@ -898,9 +906,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n \n       Local_Insert (HT, New_Item, Node, Inserted);\n \n-      if Inserted\n-        and then HT.Length > HT_Ops.Capacity (HT)\n-      then\n+      if Inserted and then HT.Length > HT_Ops.Capacity (HT) then\n          HT_Ops.Reserve_Capacity (HT, HT.Length);\n       end if;\n    end Insert;\n@@ -1335,10 +1341,12 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       X := Node.Element;\n \n       declare\n-         pragma Unsuppress (Accessibility_Check);\n          --  The element allocator may need an accessibility check in the case\n          --  the actual type is class-wide or has access discriminants (see\n          --  RM 4.8(10.1) and AI12-0035).\n+\n+         pragma Unsuppress (Accessibility_Check);\n+\n       begin\n          Node.Element := new Element_Type'(New_Item);\n       end;"}, {"sha": "e249c6a68d69f8b662941c1cbb65005bb2653683", "filename": "gcc/ada/a-cimutr.adb", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ba9f52eee2ab585349ba71850bf9e0e5c86d3c/gcc%2Fada%2Fa-cimutr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ba9f52eee2ab585349ba71850bf9e0e5c86d3c/gcc%2Fada%2Fa-cimutr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cimutr.adb?ref=29ba9f52eee2ab585349ba71850bf9e0e5c86d3c", "patch": "@@ -292,12 +292,14 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       end if;\n \n       declare\n-         pragma Unsuppress (Accessibility_Check);\n          --  The element allocator may need an accessibility check in the case\n          --  the actual type is class-wide or has access discriminants (see\n          --  RM 4.8(10.1) and AI12-0035). We don't unsuppress the check on the\n          --  allocator in the loop below, because the one in this block would\n          --  have failed already.\n+\n+         pragma Unsuppress (Accessibility_Check);\n+\n       begin\n          Element := new Element_Type'(New_Item);\n       end;\n@@ -1251,12 +1253,14 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       Position.Container := Parent.Container;\n \n       declare\n-         pragma Unsuppress (Accessibility_Check);\n          --  The element allocator may need an accessibility check in the case\n          --  the actual type is class-wide or has access discriminants (see\n          --  RM 4.8(10.1) and AI12-0035). We don't unsuppress the check on the\n          --  allocator in the loop below, because the one in this block would\n          --  have failed already.\n+\n+         pragma Unsuppress (Accessibility_Check);\n+\n       begin\n          Element := new Element_Type'(New_Item);\n       end;\n@@ -1826,12 +1830,14 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       end if;\n \n       declare\n-         pragma Unsuppress (Accessibility_Check);\n          --  The element allocator may need an accessibility check in the case\n          --  the actual type is class-wide or has access discriminants (see\n          --  RM 4.8(10.1) and AI12-0035). We don't unsuppress the check on the\n          --  allocator in the loop below, because the one in this block would\n          --  have failed already.\n+\n+         pragma Unsuppress (Accessibility_Check);\n+\n       begin\n          Element := new Element_Type'(New_Item);\n       end;\n@@ -2194,10 +2200,12 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       end if;\n \n       declare\n-         pragma Unsuppress (Accessibility_Check);\n          --  The element allocator may need an accessibility check in the case\n          --  the actual type is class-wide or has access discriminants (see\n          --  RM 4.8(10.1) and AI12-0035).\n+\n+         pragma Unsuppress (Accessibility_Check);\n+\n       begin\n          E := new Element_Type'(New_Item);\n       end;"}, {"sha": "472c912d27b5602c9d35a6e96dff09fc6c7460e8", "filename": "gcc/ada/a-ciorma.adb", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ba9f52eee2ab585349ba71850bf9e0e5c86d3c/gcc%2Fada%2Fa-ciorma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ba9f52eee2ab585349ba71850bf9e0e5c86d3c/gcc%2Fada%2Fa-ciorma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciorma.adb?ref=29ba9f52eee2ab585349ba71850bf9e0e5c86d3c", "patch": "@@ -813,12 +813,15 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n          Position.Node.Key := new Key_Type'(Key);\n \n          declare\n-            pragma Unsuppress (Accessibility_Check);\n             --  The element allocator may need an accessibility check in the\n             --  case the actual type is class-wide or has access discriminants\n             --  (see RM 4.8(10.1) and AI12-0035).\n+\n+            pragma Unsuppress (Accessibility_Check);\n+\n          begin\n             Position.Node.Element := new Element_Type'(New_Item);\n+\n          exception\n             when others =>\n                Free_Key (K);\n@@ -857,10 +860,12 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n       function New_Node return Node_Access is\n          Node : Node_Access := new Node_Type;\n \n-         pragma Unsuppress (Accessibility_Check);\n          --  The element allocator may need an accessibility check in the case\n          --  the actual type is class-wide or has access discriminants (see\n          --  RM 4.8(10.1) and AI12-0035).\n+\n+         pragma Unsuppress (Accessibility_Check);\n+\n       begin\n          Node.Key := new Key_Type'(Key);\n          Node.Element := new Element_Type'(New_Item);\n@@ -869,9 +874,10 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n       exception\n          when others =>\n \n-            --  On exception, deallocate key and elem\n+            --  On exception, deallocate key and elem. Note that free\n+            --  deallocates both the key and the elem.\n \n-            Free (Node);  --  Note that Free deallocates key and elem too\n+            Free (Node);\n             raise;\n       end New_Node;\n \n@@ -1502,12 +1508,15 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n       Node.Key := new Key_Type'(Key);\n \n       declare\n-         pragma Unsuppress (Accessibility_Check);\n          --  The element allocator may need an accessibility check in the case\n          --  the actual type is class-wide or has access discriminants (see\n          --  RM 4.8(10.1) and AI12-0035).\n+\n+         pragma Unsuppress (Accessibility_Check);\n+\n       begin\n          Node.Element := new Element_Type'(New_Item);\n+\n       exception\n          when others =>\n             Free_Key (K);\n@@ -1556,10 +1565,12 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n       declare\n          X : Element_Access := Position.Node.Element;\n \n-         pragma Unsuppress (Accessibility_Check);\n          --  The element allocator may need an accessibility check in the case\n          --  the actual type is class-wide or has access discriminants (see\n          --  RM 4.8(10.1) and AI12-0035).\n+\n+         pragma Unsuppress (Accessibility_Check);\n+\n       begin\n          Position.Node.Element := new Element_Type'(New_Item);\n          Free_Element (X);"}, {"sha": "7bd1aa1e5577d260ad0479ce763e49eb0652c505", "filename": "gcc/ada/a-ciormu.adb", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ba9f52eee2ab585349ba71850bf9e0e5c86d3c/gcc%2Fada%2Fa-ciormu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ba9f52eee2ab585349ba71850bf9e0e5c86d3c/gcc%2Fada%2Fa-ciormu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciormu.adb?ref=29ba9f52eee2ab585349ba71850bf9e0e5c86d3c", "patch": "@@ -1167,11 +1167,12 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n       --------------\n \n       function New_Node return Node_Access is\n-         pragma Unsuppress (Accessibility_Check);\n          --  The element allocator may need an accessibility check in the case\n          --  the actual type is class-wide or has access discriminants (see\n          --  RM 4.8(10.1) and AI12-0035).\n \n+         pragma Unsuppress (Accessibility_Check);\n+\n          Element : Element_Access := new Element_Type'(New_Item);\n \n       begin\n@@ -1180,6 +1181,7 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n                                Right   => null,\n                                Color   => Red_Black_Trees.Red,\n                                Element => Element);\n+\n       exception\n          when others =>\n             Free_Element (Element);\n@@ -1774,10 +1776,12 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n          declare\n             X : Element_Access := Node.Element;\n \n-            pragma Unsuppress (Accessibility_Check);\n             --  The element allocator may need an accessibility check in the\n             --  case the actual type is class-wide or has access discriminants\n             --  (see RM 4.8(10.1) and AI12-0035).\n+\n+            pragma Unsuppress (Accessibility_Check);\n+\n          begin\n             Node.Element := new Element_Type'(Item);\n             Free_Element (X);\n@@ -1803,10 +1807,13 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n          --------------\n \n          function New_Node return Node_Access is\n-            pragma Unsuppress (Accessibility_Check);\n+\n             --  The element allocator may need an accessibility check in the\n             --  case the actual type is class-wide or has access discriminants\n             --  (see RM 4.8(10.1) and AI12-0035).\n+\n+            pragma Unsuppress (Accessibility_Check);\n+\n          begin\n             Node.Element := new Element_Type'(Item);  -- OK if fails\n             Node.Color := Red_Black_Trees.Red;"}, {"sha": "885c6b6568b761e5cf6722d801603e017dcad292", "filename": "gcc/ada/a-ciorse.adb", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ba9f52eee2ab585349ba71850bf9e0e5c86d3c/gcc%2Fada%2Fa-ciorse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ba9f52eee2ab585349ba71850bf9e0e5c86d3c/gcc%2Fada%2Fa-ciorse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciorse.adb?ref=29ba9f52eee2ab585349ba71850bf9e0e5c86d3c", "patch": "@@ -1174,10 +1174,12 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n          end if;\n \n          declare\n-            pragma Unsuppress (Accessibility_Check);\n             --  The element allocator may need an accessibility check in the\n             --  case the actual type is class-wide or has access discriminants\n             --  (see RM 4.8(10.1) and AI12-0035).\n+\n+            pragma Unsuppress (Accessibility_Check);\n+\n          begin\n             X := Position.Node.Element;\n             Position.Node.Element := new Element_Type'(New_Item);\n@@ -1245,11 +1247,12 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       --------------\n \n       function New_Node return Node_Access is\n-         pragma Unsuppress (Accessibility_Check);\n          --  The element allocator may need an accessibility check in the case\n          --  the actual type is class-wide or has access discriminants (see\n          --  RM 4.8(10.1) and AI12-0035).\n \n+         pragma Unsuppress (Accessibility_Check);\n+\n          Element : Element_Access := new Element_Type'(New_Item);\n \n       begin\n@@ -1258,6 +1261,7 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n                                Right   => null,\n                                Color   => Red_Black_Trees.Red,\n                                Element => Element);\n+\n       exception\n          when others =>\n             Free_Element (Element);\n@@ -1831,10 +1835,12 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       end if;\n \n       declare\n-         pragma Unsuppress (Accessibility_Check);\n          --  The element allocator may need an accessibility check in the case\n          --  the actual type is class-wide or has access discriminants (see\n          --  RM 4.8(10.1) and AI12-0035).\n+\n+         pragma Unsuppress (Accessibility_Check);\n+\n       begin\n          X := Node.Element;\n          Node.Element := new Element_Type'(New_Item);\n@@ -1873,10 +1879,13 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       --------------\n \n       function New_Node return Node_Access is\n-         pragma Unsuppress (Accessibility_Check);\n+\n          --  The element allocator may need an accessibility check in the case\n          --  the actual type is class-wide or has access discriminants (see\n          --  RM 4.8(10.1) and AI12-0035).\n+\n+         pragma Unsuppress (Accessibility_Check);\n+\n       begin\n          Node.Element := new Element_Type'(Item);  -- OK if fails\n          Node.Color := Red;\n@@ -1895,9 +1904,7 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       --  Start of processing for Replace_Element\n \n    begin\n-      if Item < Node.Element.all\n-        or else Node.Element.all < Item\n-      then\n+      if Item < Node.Element.all or else Node.Element.all < Item then\n          null;\n \n       else\n@@ -1907,10 +1914,12 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n          end if;\n \n          declare\n-            pragma Unsuppress (Accessibility_Check);\n             --  The element allocator may need an accessibility check in the\n             --  case the actual type is class-wide or has access discriminants\n             --  (see RM 4.8(10.1) and AI12-0035).\n+\n+            pragma Unsuppress (Accessibility_Check);\n+\n          begin\n             Node.Element := new Element_Type'(Item);\n             Free_Element (X);\n@@ -1932,10 +1941,12 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n             end if;\n \n             declare\n-               pragma Unsuppress (Accessibility_Check);\n                --  The element allocator may need an accessibility check in the\n                --  case actual type is class-wide or has access discriminants\n                --  (see RM 4.8(10.1) and AI12-0035).\n+\n+               pragma Unsuppress (Accessibility_Check);\n+\n             begin\n                Node.Element := new Element_Type'(Item);\n                Free_Element (X);"}, {"sha": "0d0d40064e9d4071c5ecf0e2aaf5600510ac13d8", "filename": "gcc/ada/a-coinho.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ba9f52eee2ab585349ba71850bf9e0e5c86d3c/gcc%2Fada%2Fa-coinho.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ba9f52eee2ab585349ba71850bf9e0e5c86d3c/gcc%2Fada%2Fa-coinho.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coinho.adb?ref=29ba9f52eee2ab585349ba71850bf9e0e5c86d3c", "patch": "@@ -223,10 +223,12 @@ package body Ada.Containers.Indefinite_Holders is\n       declare\n          X : Element_Access := Container.Element;\n \n-         pragma Unsuppress (Accessibility_Check);\n          --  Element allocator may need an accessibility check in case actual\n          --  type is class-wide or has access discriminants (RM 4.8(10.1) and\n          --  AI12-0035).\n+\n+         pragma Unsuppress (Accessibility_Check);\n+\n       begin\n          Container.Element := new Element_Type'(New_Item);\n          Free (X);\n@@ -238,10 +240,12 @@ package body Ada.Containers.Indefinite_Holders is\n    ---------------\n \n    function To_Holder (New_Item : Element_Type) return Holder is\n-      pragma Unsuppress (Accessibility_Check);\n       --  The element allocator may need an accessibility check in the case the\n       --  actual type is class-wide or has access discriminants (RM 4.8(10.1)\n       --  and AI12-0035).\n+\n+      pragma Unsuppress (Accessibility_Check);\n+\n    begin\n       return (AF.Controlled with new Element_Type'(New_Item), 0);\n    end To_Holder;"}, {"sha": "e615ad17efd2f37f8eabd1ea84aa5e7ec37ef5c5", "filename": "gcc/ada/a-coinve.adb", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ba9f52eee2ab585349ba71850bf9e0e5c86d3c/gcc%2Fada%2Fa-coinve.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ba9f52eee2ab585349ba71850bf9e0e5c86d3c/gcc%2Fada%2Fa-coinve.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coinve.adb?ref=29ba9f52eee2ab585349ba71850bf9e0e5c86d3c", "patch": "@@ -1699,10 +1699,12 @@ package body Ada.Containers.Indefinite_Vectors is\n             --  storage available, or because element initialization fails).\n \n             declare\n-               pragma Unsuppress (Accessibility_Check);\n                --  The element allocator may need an accessibility check in the\n                --  case actual type is class-wide or has access discriminants\n                --  (see RM 4.8(10.1) and AI12-0035).\n+\n+               pragma Unsuppress (Accessibility_Check);\n+\n             begin\n                Container.Elements.EA (Idx) := new Element_Type'(New_Item);\n             end;\n@@ -1752,10 +1754,12 @@ package body Ada.Containers.Indefinite_Vectors is\n                   --  initialization fails).\n \n                   declare\n-                     pragma Unsuppress (Accessibility_Check);\n                      --  The element allocator may need an accessibility check\n                      --  in case the actual type is class-wide or has access\n                      --  discriminants (see RM 4.8(10.1) and AI12-0035).\n+\n+                     pragma Unsuppress (Accessibility_Check);\n+\n                   begin\n                      E (Idx) := new Element_Type'(New_Item);\n                   end;\n@@ -1794,11 +1798,14 @@ package body Ada.Containers.Indefinite_Vectors is\n                --  K always has a value if the exception handler triggers.\n \n                K := Before;\n+\n                declare\n-                  pragma Unsuppress (Accessibility_Check);\n                   --  The element allocator may need an accessibility check in\n                   --  the case the actual type is class-wide or has access\n                   --  discriminants (see RM 4.8(10.1) and AI12-0035).\n+\n+                  pragma Unsuppress (Accessibility_Check);\n+\n                begin\n                   while K < Index loop\n                      E (K) := new Element_Type'(New_Item);\n@@ -1905,10 +1912,12 @@ package body Ada.Containers.Indefinite_Vectors is\n                --  initialization fails).\n \n                declare\n-                  pragma Unsuppress (Accessibility_Check);\n                   --  The element allocator may need an accessibility check in\n                   --  the case the actual type is class-wide or has access\n                   --  discriminants (see RM 4.8(10.1) and AI12-0035).\n+\n+                  pragma Unsuppress (Accessibility_Check);\n+\n                begin\n                   Dst.EA (Idx) := new Element_Type'(New_Item);\n                end;\n@@ -1952,10 +1961,12 @@ package body Ada.Containers.Indefinite_Vectors is\n                --  let it propagate.\n \n                declare\n-                  pragma Unsuppress (Accessibility_Check);\n                   --  The element allocator may need an accessibility check in\n                   --  the case the actual type is class-wide or has access\n                   --  discriminants (see RM 4.8(10.1) and AI12-0035).\n+\n+                  pragma Unsuppress (Accessibility_Check);\n+\n                begin\n                   Dst.EA (Idx) := new Element_Type'(New_Item);\n                end;\n@@ -3208,10 +3219,12 @@ package body Ada.Containers.Indefinite_Vectors is\n       declare\n          X : Element_Access := Container.Elements.EA (Index);\n \n-         pragma Unsuppress (Accessibility_Check);\n          --  The element allocator may need an accessibility check in the case\n          --  where the actual type is class-wide or has access discriminants\n          --  (see RM 4.8(10.1) and AI12-0035).\n+\n+         pragma Unsuppress (Accessibility_Check);\n+\n       begin\n          Container.Elements.EA (Index) := new Element_Type'(New_Item);\n          Free (X);\n@@ -3244,10 +3257,12 @@ package body Ada.Containers.Indefinite_Vectors is\n       declare\n          X : Element_Access := Container.Elements.EA (Position.Index);\n \n-         pragma Unsuppress (Accessibility_Check);\n          --  The element allocator may need an accessibility check in the case\n          --  where the actual type is class-wide or has access discriminants\n          --  (see RM 4.8(10.1) and AI12-0035).\n+\n+         pragma Unsuppress (Accessibility_Check);\n+\n       begin\n          Container.Elements.EA (Position.Index) := new Element_Type'(New_Item);\n          Free (X);\n@@ -3993,10 +4008,12 @@ package body Ada.Containers.Indefinite_Vectors is\n       Last := Index_Type'First;\n \n       declare\n-         pragma Unsuppress (Accessibility_Check);\n          --  The element allocator may need an accessibility check in the case\n          --  where the actual type is class-wide or has access discriminants\n          --  (see RM 4.8(10.1) and AI12-0035).\n+\n+         pragma Unsuppress (Accessibility_Check);\n+\n       begin\n          loop\n             Elements.EA (Last) := new Element_Type'(New_Item);"}, {"sha": "9ac910cede0f0083131d765addb8e3cd9f6a3581", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ba9f52eee2ab585349ba71850bf9e0e5c86d3c/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ba9f52eee2ab585349ba71850bf9e0e5c86d3c/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=29ba9f52eee2ab585349ba71850bf9e0e5c86d3c", "patch": "@@ -705,8 +705,7 @@ package body Exp_Ch4 is\n                or else\n                  (Is_Class_Wide_Type (Etype (Exp))\n                    and then Scope (PtrT) /= Current_Scope))\n-           and then\n-             (Tagged_Type_Expansion or else VM_Target /= No_VM)\n+           and then (Tagged_Type_Expansion or else VM_Target /= No_VM)\n          then\n             --  If the allocator was built in place, Ref is already a reference\n             --  to the access object initialized to the result of the allocator"}, {"sha": "2839bf39e569abf769c1169a6496754ab9334338", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ba9f52eee2ab585349ba71850bf9e0e5c86d3c/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ba9f52eee2ab585349ba71850bf9e0e5c86d3c/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=29ba9f52eee2ab585349ba71850bf9e0e5c86d3c", "patch": "@@ -4568,6 +4568,9 @@ package body Exp_Ch7 is\n                --  finalization blocks, and we put everything into a wrapper\n                --  block to clearly expose the construct to the back-end.\n \n+               --  This requirement for \"clearly expose\" must be properly\n+               --  documented in sinfo/einfo ???\n+\n                if Present (Prev_Fin) then\n                   Insert_Before_And_Analyze (Prev_Fin, Fin_Block);\n                else"}, {"sha": "53ff97e343fc8574822b8d28d2c5e36ca403674f", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ba9f52eee2ab585349ba71850bf9e0e5c86d3c/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ba9f52eee2ab585349ba71850bf9e0e5c86d3c/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=29ba9f52eee2ab585349ba71850bf9e0e5c86d3c", "patch": "@@ -5485,6 +5485,7 @@ package body Exp_Ch9 is\n \n    procedure Ensure_Statement_Present (Loc : Source_Ptr; Alt : Node_Id) is\n       Stmt : Node_Id;\n+\n    begin\n       if Opt.Suppress_Control_Flow_Optimizations\n         and then Is_Empty_List (Statements (Alt))\n@@ -5494,6 +5495,9 @@ package body Exp_Ch9 is\n          --  Mark NULL statement as coming from source so that it is not\n          --  eliminated by GIGI.\n \n+         --  Another covert channel! If this is a requirement, it must be\n+         --  documented in sinfo/einfo ???\n+\n          Set_Comes_From_Source (Stmt, True);\n \n          Set_Statements (Alt, New_List (Stmt));"}, {"sha": "f2f7ac918c803feaacafa903de0fd752b83a6de5", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ba9f52eee2ab585349ba71850bf9e0e5c86d3c/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ba9f52eee2ab585349ba71850bf9e0e5c86d3c/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=29ba9f52eee2ab585349ba71850bf9e0e5c86d3c", "patch": "@@ -3029,7 +3029,7 @@ package body Freeze is\n \n                --  Pre/post conditions are implemented through a subprogram in\n                --  the corresponding body, and therefore are not checked on an\n-               --  imported subprogram, for which the body is not available.\n+               --  imported subprogram for which the body is not available.\n \n                --  Could consider generating a wrapper to take care of this???\n "}, {"sha": "030f929a7b700d6cf79885ceaeca71b4091a8d0d", "filename": "gcc/ada/par-ch13.adb", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ba9f52eee2ab585349ba71850bf9e0e5c86d3c/gcc%2Fada%2Fpar-ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ba9f52eee2ab585349ba71850bf9e0e5c86d3c/gcc%2Fada%2Fpar-ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch13.adb?ref=29ba9f52eee2ab585349ba71850bf9e0e5c86d3c", "patch": "@@ -645,7 +645,6 @@ package body Ch13 is\n       Ptr     : Source_Ptr;\n \n    begin\n-\n       --  Aspect Specification is present\n \n       Ptr := Token_Ptr;\n@@ -834,11 +833,10 @@ package body Ch13 is\n       --  Otherwise we have an illegal range attribute. Note that P_Name\n       --  ensures that Token = Tok_Range is the only possibility left here.\n \n-      else -- Token = Tok_Range\n+      else\n          Error_Msg_SC (\"RANGE attribute illegal here!\");\n          raise Error_Resync;\n       end if;\n-\n    end P_Code_Statement;\n \n end Ch13;"}, {"sha": "73b00c24ee9bf2eb00245becb80e208aa1d209d2", "filename": "gcc/ada/par_sco.adb", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ba9f52eee2ab585349ba71850bf9e0e5c86d3c/gcc%2Fada%2Fpar_sco.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ba9f52eee2ab585349ba71850bf9e0e5c86d3c/gcc%2Fada%2Fpar_sco.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar_sco.adb?ref=29ba9f52eee2ab585349ba71850bf9e0e5c86d3c", "patch": "@@ -492,13 +492,16 @@ package body Par_SCO is\n \n                --  For entry guard, the token sloc is from the N_Entry_Body.\n                --  For PRAGMA, we must get the location from the pragma node.\n-               --  Argument N is the pragma argument, and we have to go up two\n-               --  levels (through the pragma argument association) to get to\n-               --  the pragma node itself. For the guard on a select\n-               --  alternative, we do not have access to the token location\n-               --  for the WHEN, so we use the first sloc of the condition\n-               --  itself (note: we use First_Sloc, not Sloc, because this is\n-               --  what is referenced by dominance markers).\n+               --  Argument N is the pragma argument, and we have to go up\n+               --  two levels (through the pragma argument association) to\n+               --  get to the pragma node itself. For the guard on a select\n+               --  alternative, we do not have access to the token location for\n+               --  the WHEN, so we use the first sloc of the condition itself\n+               --  (note: we use First_Sloc, not Sloc, because this is what is\n+               --  referenced by dominance markers).\n+\n+               --  Doesn't this requirement of using First_Sloc need to be\n+               --  documented in the spec ???\n \n                if Nkind_In (Parent (N), N_Accept_Alternative,\n                                         N_Delay_Alternative,"}, {"sha": "740c6bb3646047fac932f5882c77d8c0040fbf3d", "filename": "gcc/ada/s-tasinf-linux.ads", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ba9f52eee2ab585349ba71850bf9e0e5c86d3c/gcc%2Fada%2Fs-tasinf-linux.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ba9f52eee2ab585349ba71850bf9e0e5c86d3c/gcc%2Fada%2Fs-tasinf-linux.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tasinf-linux.ads?ref=29ba9f52eee2ab585349ba71850bf9e0e5c86d3c", "patch": "@@ -48,10 +48,10 @@ package System.Task_Info is\n    pragma Elaborate_Body;\n    --  To ensure that a body is allowed\n \n-   --  Linux provides a way to define the ideal processor to use for a given\n-   --  thread. The ideal processor is not necessarily the one that will be used\n-   --  by the OS but the OS will always try to schedule this thread to the\n-   --  specified processor if it is available.\n+   --  The Linux kernel provides a way to define the ideal processor to use for\n+   --  a given thread. The ideal processor is not necessarily the one that will\n+   --  be used by the OS but the OS will always try to schedule this thread to\n+   --  the specified processor if it is available.\n \n    --  The Task_Info pragma:\n "}, {"sha": "782cd984fde8ccd2b69064fdbccf18e81e7f9c4a", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ba9f52eee2ab585349ba71850bf9e0e5c86d3c/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ba9f52eee2ab585349ba71850bf9e0e5c86d3c/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=29ba9f52eee2ab585349ba71850bf9e0e5c86d3c", "patch": "@@ -4029,10 +4029,10 @@ package body Sem_Attr is\n          --  within the subprogram itself. If the prefix includes a function\n          --  call it may involve finalization actions that should only be\n          --  inserted when the attribute has been rewritten as a declarations.\n-         --  As a result, if the prefix is not a simple name we create a\n-         --  declaration for it now,  and insert it at the start of the\n-         --  enclosing subprogram. This is properly an expansion activity but\n-         --  it has to be performed now to prevent out-of-order issues.\n+         --  As a result, if the prefix is not a simple name we create\n+         --  a declaration for it now, and insert it at the start of the\n+         --  enclosing subprogram. This is properly an expansion activity\n+         --  but it has to be performed now to prevent out-of-order issues.\n \n          if not Is_Entity_Name (P) then\n             P_Type := Base_Type (P_Type);\n@@ -4474,9 +4474,9 @@ package body Sem_Attr is\n          Check_Decimal_Fixed_Point_Type;\n          Set_Etype (N, P_Base_Type);\n \n-         --  Because the context is universal_real (3.5.10(12)) it is a legal\n-         --  context for a universal fixed expression. This is the only\n-         --  attribute whose functional description involves U_R.\n+         --  Because the context is universal_real (3.5.10(12)) it is a\n+         --  legal context for a universal fixed expression. This is the\n+         --  only attribute whose functional description involves U_R.\n \n          if Etype (E1) = Universal_Fixed then\n             declare\n@@ -4771,8 +4771,8 @@ package body Sem_Attr is\n \n                Validate_Remote_Access_To_Class_Wide_Type (N);\n \n-            --  The prefix is allowed to be an implicit dereference\n-            --  of an access value designating a task.\n+            --  The prefix is allowed to be an implicit dereference of an\n+            --  access value designating a task.\n \n             else\n                Check_Task_Prefix;"}, {"sha": "82ef7298ffa7d3e4d2989b4a2a1abdb43942654f", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ba9f52eee2ab585349ba71850bf9e0e5c86d3c/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ba9f52eee2ab585349ba71850bf9e0e5c86d3c/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=29ba9f52eee2ab585349ba71850bf9e0e5c86d3c", "patch": "@@ -1866,8 +1866,8 @@ package body Sem_Ch13 is\n           Chars => Name_Address,\n           Expression => Expression (N)));\n \n-      --  We preserve Comes_From_Source, since logically the clause still\n-      --  comes from the source program even though it is changed in form.\n+      --  We preserve Comes_From_Source, since logically the clause still comes\n+      --  from the source program even though it is changed in form.\n \n       Set_Comes_From_Source (N, CS);\n \n@@ -2685,8 +2685,8 @@ package body Sem_Ch13 is\n \n                   --  Legality checks on the address clause for initialized\n                   --  objects is deferred until the freeze point, because\n-                  --  a subsequent pragma might indicate that the object is\n-                  --  imported and thus not initialized.\n+                  --  a subsequent pragma might indicate that the object\n+                  --  is imported and thus not initialized.\n \n                   Set_Has_Delayed_Freeze (U_Ent);\n \n@@ -3120,8 +3120,8 @@ package body Sem_Ch13 is\n \n          when Attribute_Implicit_Dereference =>\n \n-            --  Legality checks already performed at the point of\n-            --  the type declaration, aspect is not delayed.\n+            --  Legality checks already performed at the point of the type\n+            --  declaration, aspect is not delayed.\n \n             null;\n "}, {"sha": "04305784f6e25bd25379b80891ab46e5dedade64", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ba9f52eee2ab585349ba71850bf9e0e5c86d3c/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ba9f52eee2ab585349ba71850bf9e0e5c86d3c/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=29ba9f52eee2ab585349ba71850bf9e0e5c86d3c", "patch": "@@ -4231,8 +4231,9 @@ package body Sem_Ch4 is\n \n                begin\n                   Set_Parent (Par, Parent (Parent (N)));\n+\n                   if Try_Object_Operation\n-                    (Sinfo.Name (Par), CW_Test_Only => True)\n+                       (Sinfo.Name (Par), CW_Test_Only => True)\n                   then\n                      return;\n                   end if;\n@@ -6531,7 +6532,6 @@ package body Sem_Ch4 is\n \n       declare\n          Arg : Node_Id;\n-\n       begin\n          Arg := First (Exprs);\n          while Present (Arg) loop\n@@ -6542,9 +6542,10 @@ package body Sem_Ch4 is\n \n       if not Is_Overloaded (Func_Name) then\n          Func := Entity (Func_Name);\n-         Indexing := Make_Function_Call (Loc,\n-           Name => New_Occurrence_Of (Func, Loc),\n-           Parameter_Associations => Assoc);\n+         Indexing :=\n+           Make_Function_Call (Loc,\n+             Name                   => New_Occurrence_Of (Func, Loc),\n+             Parameter_Associations => Assoc);\n          Rewrite (N, Indexing);\n          Analyze (N);\n \n@@ -6609,8 +6610,8 @@ package body Sem_Ch4 is\n       end if;\n \n       if Etype (N) = Any_Type then\n-         Error_Msg_NE (\"container cannot be indexed with&\",\n-           N, Etype (First (Exprs)));\n+         Error_Msg_NE\n+           (\"container cannot be indexed with&\", N, Etype (First (Exprs)));\n          Rewrite (N, New_Occurrence_Of (Any_Id, Loc));\n       else\n          Analyze (N);"}, {"sha": "877ac4d0f3873a5ccd6c8b17f7f1a193a18b08c2", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ba9f52eee2ab585349ba71850bf9e0e5c86d3c/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ba9f52eee2ab585349ba71850bf9e0e5c86d3c/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=29ba9f52eee2ab585349ba71850bf9e0e5c86d3c", "patch": "@@ -68,7 +68,7 @@ package body Sem_Ch9 is\n    -----------------------\n \n    function Allows_Lock_Free_Implementation\n-     (N        : Node_Id;\n+     (N               : Node_Id;\n       Lock_Free_Given : Boolean := False) return Boolean;\n    --  This routine returns True iff N satisfies the following list of lock-\n    --  free restrictions for protected type declaration and protected body:\n@@ -130,9 +130,8 @@ package body Sem_Ch9 is\n       --  when Lock_Free_Given is True.\n \n    begin\n-      pragma Assert (Nkind_In (N,\n-                               N_Protected_Type_Declaration,\n-                               N_Protected_Body));\n+      pragma Assert (Nkind_In (N, N_Protected_Type_Declaration,\n+                                  N_Protected_Body));\n \n       --  The lock-free implementation is currently enabled through a debug\n       --  flag. When Lock_Free_Given is True, an aspect Lock_Free forces the\n@@ -418,8 +417,8 @@ package body Sem_Ch9 is\n                                  and then Is_Access_Type (Etype (Prefix (N))))\n                      then\n                         if Lock_Free_Given then\n-                           Error_Msg_N (\"dereference of access value \" &\n-                                        \"not allowed\", N);\n+                           Error_Msg_N\n+                             (\"dereference of access value not allowed\", N);\n                            return Skip;\n                         end if;\n \n@@ -431,8 +430,8 @@ package body Sem_Ch9 is\n                        and then not Is_Static_Expression (N)\n                      then\n                         if Lock_Free_Given then\n-                           Error_Msg_N (\"non-static function call not allowed\",\n-                                        N);\n+                           Error_Msg_N\n+                             (\"non-static function call not allowed\", N);\n                            return Skip;\n                         end if;\n \n@@ -463,10 +462,12 @@ package body Sem_Ch9 is\n                            --  outside the protected subprogram scope.\n \n                            if Ekind (Id) in Assignable_Kind\n-                             and then not Scope_Within_Or_Same (Scope (Id),\n-                                            Sub_Id)\n-                             and then not Scope_Within_Or_Same (Scope (Id),\n-                                            Protected_Body_Subprogram (Sub_Id))\n+                             and then not\n+                               Scope_Within_Or_Same (Scope (Id), Sub_Id)\n+                             and then not\n+                               Scope_Within_Or_Same\n+                                 (Scope (Id),\n+                                  Protected_Body_Subprogram (Sub_Id))\n                            then\n                               if Lock_Free_Given then\n                                  Error_Msg_NE\n@@ -647,7 +648,6 @@ package body Sem_Ch9 is\n                  and then (not Lock_Free_Given\n                             or else Errors_Count = Serious_Errors_Detected)\n                then\n-\n                   --  Establish a relation between the subprogram body and the\n                   --  unique protected component it references.\n "}, {"sha": "0f518375a1e642437b0e3d46cf0a38dd9a8b8d98", "filename": "gcc/ada/sem_dim.adb", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ba9f52eee2ab585349ba71850bf9e0e5c86d3c/gcc%2Fada%2Fsem_dim.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ba9f52eee2ab585349ba71850bf9e0e5c86d3c/gcc%2Fada%2Fsem_dim.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_dim.adb?ref=29ba9f52eee2ab585349ba71850bf9e0e5c86d3c", "patch": "@@ -1712,9 +1712,7 @@ package body Sem_Dim is\n             --  entity when the object is a constant whose type is a\n             --  dimensioned type.\n \n-            if Constant_Present (N)\n-              and then not Exists (Dim_Of_Etyp)\n-            then\n+            if Constant_Present (N) and then not Exists (Dim_Of_Etyp) then\n                Set_Dimensions (Id, Dim_Of_Expr);\n \n             --  Otherwise, issue an error message"}, {"sha": "257e4d5566bce2ecaf26c9cf192d45d18e69eb1b", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ba9f52eee2ab585349ba71850bf9e0e5c86d3c/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ba9f52eee2ab585349ba71850bf9e0e5c86d3c/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=29ba9f52eee2ab585349ba71850bf9e0e5c86d3c", "patch": "@@ -7129,9 +7129,9 @@ package body Sem_Res is\n             return;\n          end if;\n \n-      else\n-         --  If not overloaded, resolve P with its own type\n+      --  If not overloaded, resolve P with its own type\n \n+      else\n          Resolve (P);\n       end if;\n "}]}