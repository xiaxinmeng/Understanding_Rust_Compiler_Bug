{"sha": "e7206fbc5c2615615180bf23d52727994d6b4a63", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTcyMDZmYmM1YzI2MTU2MTUxODBiZjIzZDUyNzI3OTk0ZDZiNGE2Mw==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2002-05-29T19:55:34Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2002-05-29T19:55:34Z"}, "message": "Revert this patch:\n\n-       * haifa-sched.c (schedule_block): Do not count USE and CLOBBER\n-       insns against the issue rate.\n-\n-       * sched-deps.c (sched_create_groups_for_libcalls): New function.\n-       (sched_analyze): Use it.\n\nFrom-SVN: r54015", "tree": {"sha": "3ca16b30a6b68951a3d1916e374823b5b7964d26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ca16b30a6b68951a3d1916e374823b5b7964d26"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e7206fbc5c2615615180bf23d52727994d6b4a63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7206fbc5c2615615180bf23d52727994d6b4a63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7206fbc5c2615615180bf23d52727994d6b4a63", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7206fbc5c2615615180bf23d52727994d6b4a63/comments", "author": null, "committer": null, "parents": [{"sha": "8dc901ded38b2ad59f56ca82d9d8043d4fa92d18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dc901ded38b2ad59f56ca82d9d8043d4fa92d18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8dc901ded38b2ad59f56ca82d9d8043d4fa92d18"}], "stats": {"total": 72, "additions": 1, "deletions": 71}, "files": [{"sha": "11e769a729d164438719766a8c2d9ecb0ba09ca6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7206fbc5c2615615180bf23d52727994d6b4a63/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7206fbc5c2615615180bf23d52727994d6b4a63/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e7206fbc5c2615615180bf23d52727994d6b4a63", "patch": "@@ -63,17 +63,6 @@\n \t(SUBTARGET_EXTRA_SPECS): Define.\n \t(CPP_SPEC): Remove.\n \n-2002-05-29  Dale Johannesen  <dalej@apple.com>\n-            Michael Matz  <matz@kde.org>\n-            David Edelsohn  <edesohn@gnu.org>\n-            Jeff Law <law@redhat.com>\n-\n-\t* haifa-sched.c (schedule_block): Do not count USE and CLOBBER\n-\tinsns against the issue rate.\n-\n-\t* sched-deps.c (sched_create_groups_for_libcalls): New function.\n-\t(sched_analyze): Use it.\n-\n 2002-05-29  Chris Lattner  <sabre@nondot.org>\n \n         * ssa.c (rename_insn_1): Rename uses of undefined registers to"}, {"sha": "63a31352a5b7e8f319368df8f3277a3e2b1aca88", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7206fbc5c2615615180bf23d52727994d6b4a63/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7206fbc5c2615615180bf23d52727994d6b4a63/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=e7206fbc5c2615615180bf23d52727994d6b4a63", "patch": "@@ -2179,10 +2179,7 @@ schedule_block (b, rgn_n_insns)\n \t    can_issue_more =\n \t      (*targetm.sched.variable_issue) (sched_dump, sched_verbose,\n \t\t\t\t\t       insn, can_issue_more);\n-\t  /* A naked CLOBBER or USE generates no instruction, so do\n-\t     not count them against the issue rate.  */\n-\t  else if (GET_CODE (PATTERN (insn)) != USE\n-\t\t   && GET_CODE (PATTERN (insn)) != CLOBBER)\n+\t  else\n \t    can_issue_more--;\n \n \t  schedule_insn (insn, &ready, clock_var);"}, {"sha": "0afb21bcf6b618eaff5bebf413687af91f654eb3", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7206fbc5c2615615180bf23d52727994d6b4a63/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7206fbc5c2615615180bf23d52727994d6b4a63/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=e7206fbc5c2615615180bf23d52727994d6b4a63", "patch": "@@ -88,7 +88,6 @@ static void flush_pending_lists PARAMS ((struct deps *, rtx, int, int));\n static void sched_analyze_1 PARAMS ((struct deps *, rtx, rtx));\n static void sched_analyze_2 PARAMS ((struct deps *, rtx, rtx));\n static void sched_analyze_insn PARAMS ((struct deps *, rtx, rtx, rtx));\n-static void sched_create_groups_for_libcalls PARAMS ((rtx, rtx));\n static rtx group_leader PARAMS ((rtx));\n \n static rtx get_condition PARAMS ((rtx));\n@@ -1211,57 +1210,6 @@ sched_analyze_insn (deps, x, insn, loop_notes)\n     }\n }\n \n-/* Find any libcall sequences between HEAD and TAIL inclusive; set\n-   SCHED_GROUP_P appropriately for such sequences.  */\n-\n-static void\n-sched_create_groups_for_libcalls (head, tail)\n-     rtx head, tail;\n-{\n-  rtx insn;\n-  int tail_seen_p = 0;\n-\n-  for (insn = head;; insn = NEXT_INSN (insn))\n-    {\n-      rtx link, end_seq, set, r0, note;\n-      if (INSN_P (insn) && GET_CODE (PATTERN (insn)) == CLOBBER\n-\t  && (r0 = XEXP (PATTERN (insn), 0), GET_CODE (r0) == REG)\n-\t  && (link = find_reg_note (insn, REG_LIBCALL, NULL_RTX)) != 0\n-\t  && (end_seq = XEXP (link, 0)) != 0\n-\t  && INSN_P (end_seq)\n-\t  && (set = single_set (end_seq)) != 0\n-\t  && SET_DEST (set) == r0 && SET_SRC (set) == r0\n-\t  && (note = find_reg_note (end_seq, REG_EQUAL, NULL_RTX)) != 0)\n-\t{\n-\t  /* We found a libcall block between insn and end_seq.\n-\t     The inner insns should be scheduled in a block.  */\n-\t  rtx inner;\n-\t  /* Paranoia.  */\n-\t  if (insn == tail)\n-\t    tail_seen_p = 1;\n-\t  /* We don't want to set this flag on the initial clobber, because\n-\t     the semantic of SCHED_GROUP_P is to make insn be scheduled\n-\t     together with the previous insn.  */\n-\t  for (inner = NEXT_INSN (insn); inner; inner = NEXT_INSN (inner))\n-\t    {\n-\t      if (INSN_P (inner))\n-\t\tset_sched_group_p (inner);\n-\t      /* Paranoia.  */\n-\t      if (inner == tail)\n-\t\ttail_seen_p = 1;\n-\t      if (inner == end_seq)\n-\t\tbreak;\n-\t    }\n-\t  /* We should be able to skip the whole lib-call block.\n-\t     Remember that one NEXT_INSN is done in the loop-iteration.  */\n-\t  insn = end_seq;\n-\t}\n-      if (insn == tail || tail_seen_p)\n-\tbreak;\n-    }\n-  return;\n-}\n-\n /* Analyze every insn between HEAD and TAIL inclusive, creating LOG_LINKS\n    for every dependency.  */\n \n@@ -1409,10 +1357,6 @@ sched_analyze (deps, head, tail)\n \t{\n \t  if (current_sched_info->use_cselib)\n \t    cselib_finish ();\n-\n-\t  if (! reload_completed)\n-\t    sched_create_groups_for_libcalls (head, tail);\n-\n \t  return;\n \t}\n     }"}]}