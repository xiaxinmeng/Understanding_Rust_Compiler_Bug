{"sha": "da51a4782bacca6fc41eac7695ce687deb797b8e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGE1MWE0NzgyYmFjY2E2ZmM0MWVhYzc2OTVjZTY4N2RlYjc5N2I4ZQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-01-16T14:42:30Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-01-16T14:42:30Z"}, "message": "General code cleanup in the style of 1995-04-01 change.\n\nAdd prototypes for static functions.\nAdd parentheses suggested by `gcc -Wparentheses'.\nUse `long' uniformly, instead of long, int, HOST_WIDE_INT mess.\n(struct constant): Use `signedp' flag (with sign bit) instead of\n`unsignedp' flag; it's a little more convenient.\n\n(HAVE_STDLIB_H, STDC_HEADERS, LONG_MASK, __attribute__, PROTO,\nVA_START, PRINTF_ALIST, PRINTF_DCL, PRINTF_PROTO, PRINTF_PROTO_1,\nvfprintf, SIGNED, UNSIGNED): New symbols.\n<stdlib.h>: Include if HAVE_STDLIB_H.\n<string.h>: New include.\n(HOST_BITS_PER_WIDE_INT, HOST_WIDE_INT): Remove.\n(yylex, yyerror, expression_value, parse_number,\ninitialize_random_junk): Now static.\n\n(overflow_sum_sign): Renamed from possible_sum_sign, with an\nextra arg SIGNEDP.\n(parse_number): Inline strcmp when checking for \"0x\".\n(yylex): Keep track of mask needed when decoding wide characters.\n(parse_escape): New arg RESULT_MASK; use it instead of\nassuming char width.\n(yylex, parse_escape, parse_c_expression): Store all host\nintegers as long, not int or HOST_WIDE_INT.\n(left_shift): No need to do signed left shifts separately.\n\nThese changes are for the test program (if TEST_EXP_READER):\n(pedantic, traditional): Allocate storage.\n(main): Set pedantic, traditional, yydebug depending on args.\n(is_hor_space, warning, lookup): Change types and implementation\nto match rest of program.\n(pedwarn, check_assertion, xmalloc): New functions.\n\nFrom-SVN: r11024", "tree": {"sha": "ef243b8febc1419214f2b1725ea77c6e4d65e136", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef243b8febc1419214f2b1725ea77c6e4d65e136"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/da51a4782bacca6fc41eac7695ce687deb797b8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da51a4782bacca6fc41eac7695ce687deb797b8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da51a4782bacca6fc41eac7695ce687deb797b8e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da51a4782bacca6fc41eac7695ce687deb797b8e/comments", "author": null, "committer": null, "parents": [{"sha": "2994a9acb75088ac8d18f70d10963a47c728130a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2994a9acb75088ac8d18f70d10963a47c728130a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2994a9acb75088ac8d18f70d10963a47c728130a"}], "stats": {"total": 411, "additions": 271, "deletions": 140}, "files": [{"sha": "90678b89d9d78dccf9194023aec65645def18530", "filename": "gcc/cexp.y", "status": "modified", "additions": 271, "deletions": 140, "changes": 411, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da51a4782bacca6fc41eac7695ce687deb797b8e/gcc%2Fcexp.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da51a4782bacca6fc41eac7695ce687deb797b8e/gcc%2Fcexp.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcexp.y?ref=da51a4782bacca6fc41eac7695ce687deb797b8e", "patch": "@@ -1,5 +1,5 @@\n /* Parse C expressions for CCCP.\n-   Copyright (C) 1987, 1992, 1994, 1995 Free Software Foundation.\n+   Copyright (C) 1987, 1992, 1994, 1995, 1996 Free Software Foundation.\n \n This program is free software; you can redistribute it and/or modify it\n under the terms of the GNU General Public License as published by the\n@@ -29,8 +29,30 @@ Boston, MA 02111-1307, USA.\n #include <setjmp.h>\n /* #define YYDEBUG 1 */\n \n+/* The following symbols should be autoconfigured:\n+\tHAVE_STDLIB_H\n+\tSTDC_HEADERS\n+   In the mean time, we'll get by with approximations based\n+   on existing GCC configuration symbols.  */\n+\n+#ifdef POSIX\n+# ifndef HAVE_STDLIB_H\n+# define HAVE_STDLIB_H 1\n+# endif\n+# ifndef STDC_HEADERS\n+# define STDC_HEADERS 1\n+# endif\n+#endif /* defined (POSIX) */\n+\n+#if STDC_HEADERS\n+# include <string.h>\n+#endif\n+\n+#if HAVE_STDLIB_H || defined (MULTIBYTE_CHARS)\n+# include <stdlib.h>\n+#endif\n+\n #ifdef MULTIBYTE_CHARS\n-#include <stdlib.h>\n #include <locale.h>\n #endif\n \n@@ -60,27 +82,53 @@ struct arglist {\n #endif\n #endif\n \n-/* Find the largest host integer type and set its size and type.  */\n+#define LONG_MASK(bits) ((bits) < HOST_BITS_PER_LONG ? ~(~0L << (bits)) : ~0L)\n \n-#ifndef HOST_BITS_PER_WIDE_INT\n+#ifndef NULL_PTR\n+#define NULL_PTR ((GENERIC_PTR)0)\n+#endif\n \n-#if HOST_BITS_PER_LONG > HOST_BITS_PER_INT\n-#define HOST_BITS_PER_WIDE_INT HOST_BITS_PER_LONG\n-#define HOST_WIDE_INT long\n-#else\n-#define HOST_BITS_PER_WIDE_INT HOST_BITS_PER_INT\n-#define HOST_WIDE_INT int\n+#if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 6)\n+# define __attribute__(x)\n #endif\n \n+#ifndef PROTO\n+# if defined (USE_PROTOTYPES) ? USE_PROTOTYPES : defined (__STDC__)\n+#  define PROTO(ARGS) ARGS\n+# else\n+#  define PROTO(ARGS) ()\n+# endif\n #endif\n \n-#ifndef NULL_PTR\n-#define NULL_PTR ((GENERIC_PTR)0)\n+#if defined (__STDC__) && defined (HAVE_VPRINTF)\n+# include <stdarg.h>\n+# define VA_START(va_list, var) va_start (va_list, var)\n+# define PRINTF_ALIST(msg) char *msg, ...\n+# define PRINTF_DCL(msg)\n+# define PRINTF_PROTO(ARGS, m, n) PROTO (ARGS) __attribute__ ((format (printf, m, n)))\n+#else\n+# include <varargs.h>\n+# define VA_START(va_list, var) va_start (va_list)\n+# define PRINTF_ALIST(msg) msg, va_alist\n+# define PRINTF_DCL(msg) char *msg; va_dcl\n+# define PRINTF_PROTO(ARGS, m, n) () __attribute__ ((format (printf, m, n)))\n+# define vfprintf(file, msg, args) \\\n+    { \\\n+      char *a0 = va_arg(args, char *); \\\n+      char *a1 = va_arg(args, char *); \\\n+      char *a2 = va_arg(args, char *); \\\n+      char *a3 = va_arg(args, char *); \\\n+      fprintf (file, msg, a0, a1, a2, a3); \\\n+    }\n #endif\n \n-int yylex ();\n-void yyerror ();\n-HOST_WIDE_INT expression_value;\n+#define PRINTF_PROTO_1(ARGS) PRINTF_PROTO(ARGS, 1, 2)\n+\n+long parse_c_expression PROTO((char *));\n+\n+static int yylex PROTO((void));\n+static void yyerror PROTO((char *)) __attribute__ ((noreturn));\n+static long expression_value;\n \n static jmp_buf parse_return_error;\n \n@@ -94,8 +142,6 @@ static int skip_evaluation;\n /* some external tables of character types */\n extern unsigned char is_idstart[], is_idchar[], is_hor_space[];\n \n-extern char *xmalloc ();\n-\n /* Flag for -pedantic.  */\n extern int pedantic;\n \n@@ -134,17 +180,38 @@ extern int traditional;\n #define MAX_WCHAR_TYPE_SIZE WCHAR_TYPE_SIZE\n #endif\n \n-/* Yield nonzero if adding two numbers with A's and B's signs can yield a\n-   number with SUM's sign, where A, B, and SUM are all C integers.  */\n-#define possible_sum_sign(a, b, sum) ((((a) ^ (b)) | ~ ((a) ^ (sum))) < 0)\n-\n-static void integer_overflow ();\n-static long left_shift ();\n-static long right_shift ();\n+/* Suppose A1 + B1 = SUM1, using 2's complement arithmetic ignoring overflow.\n+   Suppose A, B and SUM have the same respective signs as A1, B1, and SUM1.\n+   Suppose SIGNEDP is negative if the result is signed, zero if unsigned.\n+   Then this yields nonzero if overflow occurred during the addition.\n+   Overflow occurs if A and B have the same sign, but A and SUM differ in sign,\n+   and SIGNEDP is negative.\n+   Use `^' to test whether signs differ, and `< 0' to isolate the sign.  */\n+#define overflow_sum_sign(a, b, sum, signedp) \\\n+\t((~((a) ^ (b)) & ((a) ^ (sum)) & (signedp)) < 0)\n+\n+struct constant;\n+\n+GENERIC_PTR xmalloc PROTO((size_t));\n+long parse_escape PROTO((char **, long));\n+int check_assertion PROTO((U_CHAR *, int, int, struct arglist *));\n+struct hashnode *lookup PROTO((U_CHAR *, int, int));\n+void error PRINTF_PROTO_1((char *, ...));\n+void pedwarn PRINTF_PROTO_1((char *, ...));\n+void warning PRINTF_PROTO_1((char *, ...));\n+\n+static int parse_number PROTO((int));\n+static long left_shift PROTO((struct constant *, unsigned long));\n+static long right_shift PROTO((struct constant *, unsigned long));\n+static void integer_overflow PROTO((void));\n+\n+/* `signedp' values */\n+#define SIGNED (~0)\n+#define UNSIGNED 0\n %}\n \n %union {\n-  struct constant {long value; int unsignedp;} integer;\n+  struct constant {long value; int signedp;} integer;\n   struct name {U_CHAR *address; int length;} name;\n   struct arglist *keywords;\n }\n@@ -188,165 +255,163 @@ exp1\t:\texp\n /* Expressions, not including the comma operator.  */\n exp\t:\t'-' exp    %prec UNARY\n \t\t\t{ $$.value = - $2.value;\n-\t\t\t  if (($$.value & $2.value) < 0 && ! $2.unsignedp)\n-\t\t\t    integer_overflow ();\n-\t\t\t  $$.unsignedp = $2.unsignedp; }\n+\t\t\t  $$.signedp = $2.signedp;\n+\t\t\t  if (($$.value & $2.value & $$.signedp) < 0)\n+\t\t\t    integer_overflow (); }\n \t|\t'!' exp    %prec UNARY\n \t\t\t{ $$.value = ! $2.value;\n-\t\t\t  $$.unsignedp = 0; }\n+\t\t\t  $$.signedp = SIGNED; }\n \t|\t'+' exp    %prec UNARY\n \t\t\t{ $$ = $2; }\n \t|\t'~' exp    %prec UNARY\n \t\t\t{ $$.value = ~ $2.value;\n-\t\t\t  $$.unsignedp = $2.unsignedp; }\n+\t\t\t  $$.signedp = $2.signedp; }\n \t|\t'#' NAME\n   \t\t\t{ $$.value = check_assertion ($2.address, $2.length,\n \t\t\t\t\t\t      0, NULL_PTR);\n-\t\t\t  $$.unsignedp = 0; }\n+\t\t\t  $$.signedp = SIGNED; }\n \t|\t'#' NAME\n \t\t\t{ keyword_parsing = 1; }\n \t\t'(' keywords ')'\n   \t\t\t{ $$.value = check_assertion ($2.address, $2.length,\n \t\t\t\t\t\t      1, $5);\n \t\t\t  keyword_parsing = 0;\n-\t\t\t  $$.unsignedp = 0; }\n+\t\t\t  $$.signedp = SIGNED; }\n \t|\t'(' exp1 ')'\n \t\t\t{ $$ = $2; }\n \t;\n \n /* Binary operators in order of decreasing precedence.  */\n exp\t:\texp '*' exp\n-\t\t\t{ $$.unsignedp = $1.unsignedp || $3.unsignedp;\n-\t\t\t  if ($$.unsignedp)\n-\t\t\t    $$.value = (unsigned long) $1.value * $3.value;\n-\t\t\t  else\n+\t\t\t{ $$.signedp = $1.signedp & $3.signedp;\n+\t\t\t  if ($$.signedp)\n \t\t\t    {\n \t\t\t      $$.value = $1.value * $3.value;\n \t\t\t      if ($1.value\n \t\t\t\t  && ($$.value / $1.value != $3.value\n \t\t\t\t      || ($$.value & $1.value & $3.value) < 0))\n \t\t\t\tinteger_overflow ();\n-\t\t\t    } }\n+\t\t\t    }\n+\t\t\t  else\n+\t\t\t    $$.value = (unsigned long) $1.value * $3.value; }\n \t|\texp '/' exp\n \t\t\t{ if ($3.value == 0)\n \t\t\t    {\n \t\t\t      if (!skip_evaluation)\n \t\t\t\terror (\"division by zero in #if\");\n \t\t\t      $3.value = 1;\n \t\t\t    }\n-\t\t\t  $$.unsignedp = $1.unsignedp || $3.unsignedp;\n-\t\t\t  if ($$.unsignedp)\n-\t\t\t    $$.value = (unsigned long) $1.value / $3.value;\n-\t\t\t  else\n+\t\t\t  $$.signedp = $1.signedp & $3.signedp;\n+\t\t\t  if ($$.signedp)\n \t\t\t    {\n \t\t\t      $$.value = $1.value / $3.value;\n \t\t\t      if (($$.value & $1.value & $3.value) < 0)\n \t\t\t\tinteger_overflow ();\n-\t\t\t    } }\n+\t\t\t    }\n+\t\t\t  else\n+\t\t\t    $$.value = (unsigned long) $1.value / $3.value; }\n \t|\texp '%' exp\n \t\t\t{ if ($3.value == 0)\n \t\t\t    {\n \t\t\t      if (!skip_evaluation)\n \t\t\t\terror (\"division by zero in #if\");\n \t\t\t      $3.value = 1;\n \t\t\t    }\n-\t\t\t  $$.unsignedp = $1.unsignedp || $3.unsignedp;\n-\t\t\t  if ($$.unsignedp)\n-\t\t\t    $$.value = (unsigned long) $1.value % $3.value;\n+\t\t\t  $$.signedp = $1.signedp & $3.signedp;\n+\t\t\t  if ($$.signedp)\n+\t\t\t    $$.value = $1.value % $3.value;\n \t\t\t  else\n-\t\t\t    $$.value = $1.value % $3.value; }\n+\t\t\t    $$.value = (unsigned long) $1.value % $3.value; }\n \t|\texp '+' exp\n \t\t\t{ $$.value = $1.value + $3.value;\n-\t\t\t  $$.unsignedp = $1.unsignedp || $3.unsignedp;\n-\t\t\t  if (! $$.unsignedp\n-\t\t\t      && ! possible_sum_sign ($1.value, $3.value,\n-\t\t\t\t\t\t      $$.value))\n+\t\t\t  $$.signedp = $1.signedp & $3.signedp;\n+\t\t\t  if (overflow_sum_sign ($1.value, $3.value,\n+\t\t\t\t\t\t $$.value, $$.signedp))\n \t\t\t    integer_overflow (); }\n \t|\texp '-' exp\n \t\t\t{ $$.value = $1.value - $3.value;\n-\t\t\t  $$.unsignedp = $1.unsignedp || $3.unsignedp;\n-\t\t\t  if (! $$.unsignedp\n-\t\t\t      && ! possible_sum_sign ($$.value, $3.value,\n-\t\t\t\t\t\t      $1.value))\n+\t\t\t  $$.signedp = $1.signedp & $3.signedp;\n+\t\t\t  if (overflow_sum_sign ($$.value, $3.value,\n+\t\t\t\t\t\t $1.value, $$.signedp))\n \t\t\t    integer_overflow (); }\n \t|\texp LSH exp\n-\t\t\t{ $$.unsignedp = $1.unsignedp;\n-\t\t\t  if ($3.value < 0 && ! $3.unsignedp)\n+\t\t\t{ $$.signedp = $1.signedp;\n+\t\t\t  if (($3.value & $3.signedp) < 0)\n \t\t\t    $$.value = right_shift (&$1, -$3.value);\n \t\t\t  else\n \t\t\t    $$.value = left_shift (&$1, $3.value); }\n \t|\texp RSH exp\n-\t\t\t{ $$.unsignedp = $1.unsignedp;\n-\t\t\t  if ($3.value < 0 && ! $3.unsignedp)\n+\t\t\t{ $$.signedp = $1.signedp;\n+\t\t\t  if (($3.value & $3.signedp) < 0)\n \t\t\t    $$.value = left_shift (&$1, -$3.value);\n \t\t\t  else\n \t\t\t    $$.value = right_shift (&$1, $3.value); }\n \t|\texp EQUAL exp\n \t\t\t{ $$.value = ($1.value == $3.value);\n-\t\t\t  $$.unsignedp = 0; }\n+\t\t\t  $$.signedp = SIGNED; }\n \t|\texp NOTEQUAL exp\n \t\t\t{ $$.value = ($1.value != $3.value);\n-\t\t\t  $$.unsignedp = 0; }\n+\t\t\t  $$.signedp = SIGNED; }\n \t|\texp LEQ exp\n-\t\t\t{ $$.unsignedp = 0;\n-\t\t\t  if ($1.unsignedp || $3.unsignedp)\n-\t\t\t    $$.value = (unsigned long) $1.value <= $3.value;\n+\t\t\t{ $$.signedp = SIGNED;\n+\t\t\t  if ($1.signedp & $3.signedp)\n+\t\t\t    $$.value = $1.value <= $3.value;\n \t\t\t  else\n-\t\t\t    $$.value = $1.value <= $3.value; }\n+\t\t\t    $$.value = (unsigned long) $1.value <= $3.value; }\n \t|\texp GEQ exp\n-\t\t\t{ $$.unsignedp = 0;\n-\t\t\t  if ($1.unsignedp || $3.unsignedp)\n-\t\t\t    $$.value = (unsigned long) $1.value >= $3.value;\n+\t\t\t{ $$.signedp = SIGNED;\n+\t\t\t  if ($1.signedp & $3.signedp)\n+\t\t\t    $$.value = $1.value >= $3.value;\n \t\t\t  else\n-\t\t\t    $$.value = $1.value >= $3.value; }\n+\t\t\t    $$.value = (unsigned long) $1.value >= $3.value; }\n \t|\texp '<' exp\n-\t\t\t{ $$.unsignedp = 0;\n-\t\t\t  if ($1.unsignedp || $3.unsignedp)\n-\t\t\t    $$.value = (unsigned long) $1.value < $3.value;\n+\t\t\t{ $$.signedp = SIGNED;\n+\t\t\t  if ($1.signedp & $3.signedp)\n+\t\t\t    $$.value = $1.value < $3.value;\n \t\t\t  else\n-\t\t\t    $$.value = $1.value < $3.value; }\n+\t\t\t    $$.value = (unsigned long) $1.value < $3.value; }\n \t|\texp '>' exp\n-\t\t\t{ $$.unsignedp = 0;\n-\t\t\t  if ($1.unsignedp || $3.unsignedp)\n-\t\t\t    $$.value = (unsigned long) $1.value > $3.value;\n+\t\t\t{ $$.signedp = SIGNED;\n+\t\t\t  if ($1.signedp & $3.signedp)\n+\t\t\t    $$.value = $1.value > $3.value;\n \t\t\t  else\n-\t\t\t    $$.value = $1.value > $3.value; }\n+\t\t\t    $$.value = (unsigned long) $1.value > $3.value; }\n \t|\texp '&' exp\n \t\t\t{ $$.value = $1.value & $3.value;\n-\t\t\t  $$.unsignedp = $1.unsignedp || $3.unsignedp; }\n+\t\t\t  $$.signedp = $1.signedp & $3.signedp; }\n \t|\texp '^' exp\n \t\t\t{ $$.value = $1.value ^ $3.value;\n-\t\t\t  $$.unsignedp = $1.unsignedp || $3.unsignedp; }\n+\t\t\t  $$.signedp = $1.signedp & $3.signedp; }\n \t|\texp '|' exp\n \t\t\t{ $$.value = $1.value | $3.value;\n-\t\t\t  $$.unsignedp = $1.unsignedp || $3.unsignedp; }\n+\t\t\t  $$.signedp = $1.signedp & $3.signedp; }\n \t|\texp AND\n \t\t\t{ skip_evaluation += !$1.value; }\n \t\texp\n \t\t\t{ skip_evaluation -= !$1.value;\n \t\t\t  $$.value = ($1.value && $4.value);\n-\t\t\t  $$.unsignedp = 0; }\n+\t\t\t  $$.signedp = SIGNED; }\n \t|\texp OR\n \t\t\t{ skip_evaluation += !!$1.value; }\n \t\texp\n \t\t\t{ skip_evaluation -= !!$1.value;\n \t\t\t  $$.value = ($1.value || $4.value);\n-\t\t\t  $$.unsignedp = 0; }\n+\t\t\t  $$.signedp = SIGNED; }\n \t|\texp '?'\n \t\t\t{ skip_evaluation += !$1.value; }\n \t        exp ':'\n \t\t\t{ skip_evaluation += !!$1.value - !$1.value; }\n \t\texp\n \t\t\t{ skip_evaluation -= !!$1.value;\n \t\t\t  $$.value = $1.value ? $4.value : $7.value;\n-\t\t\t  $$.unsignedp = $4.unsignedp || $7.unsignedp; }\n+\t\t\t  $$.signedp = $4.signedp & $7.signedp; }\n \t|\tINT\n \t\t\t{ $$ = yylval.integer; }\n \t|\tCHAR\n \t\t\t{ $$ = yylval.integer; }\n \t|\tNAME\n \t\t\t{ $$.value = 0;\n-\t\t\t  $$.unsignedp = 0; }\n+\t\t\t  $$.signedp = SIGNED; }\n \t;\n \n keywords :\n@@ -383,7 +448,7 @@ static char *lexptr;\n \n /* maybe needs to actually deal with floating point numbers */\n \n-int\n+static int\n parse_number (olen)\n      int olen;\n {\n@@ -396,15 +461,16 @@ parse_number (olen)\n   register int digit, largest_digit = 0;\n   int spec_long = 0;\n \n-  yylval.integer.unsignedp = 0;\n+  yylval.integer.signedp = SIGNED;\n \n-  if (len >= 3 && (!strncmp (p, \"0x\", 2) || !strncmp (p, \"0X\", 2))) {\n-    p += 2;\n-    base = 16;\n-    len -= 2;\n-  }\n-  else if (*p == '0')\n+  if (*p == '0') {\n     base = 8;\n+    if (len >= 3 && (p[1] == 'x' || p[1] == 'X')) {\n+      p += 2;\n+      base = 16;\n+      len -= 2;\n+    }\n+  }\n \n   ULONG_MAX_over_base = (unsigned long) -1 / base;\n \n@@ -428,9 +494,9 @@ parse_number (olen)\n \t  }\n \telse if (c == 'u' || c == 'U')\n \t  {\n-\t    if (yylval.integer.unsignedp)\n+\t    if (! yylval.integer.signedp)\n \t      yyerror (\"two `u's in integer constant\");\n-\t    yylval.integer.unsignedp = 1;\n+\t    yylval.integer.signedp = UNSIGNED;\n \t  }\n \telse {\n \t  if (c == '.' || c == 'e' || c == 'E')\n@@ -453,7 +519,7 @@ parse_number (olen)\n     if (largest_digit < digit)\n       largest_digit = digit;\n     nd = n * base + digit;\n-    overflow |= ULONG_MAX_over_base < n | nd < n;\n+    overflow |= (ULONG_MAX_over_base < n) | (nd < n);\n     n = nd;\n   }\n \n@@ -464,11 +530,11 @@ parse_number (olen)\n     warning (\"integer constant out of range\");\n \n   /* If too big to be signed, consider it unsigned.  */\n-  if ((long) n < 0 && ! yylval.integer.unsignedp)\n+  if (((long) n & yylval.integer.signedp) < 0)\n     {\n       if (base == 10)\n \twarning (\"integer constant is so large that it is unsigned\");\n-      yylval.integer.unsignedp = 1;\n+      yylval.integer.signedp = UNSIGNED;\n     }\n \n   lexptr = p;\n@@ -497,14 +563,15 @@ static struct token tokentab2[] = {\n \n /* Read one token, getting characters through lexptr.  */\n \n-int\n+static int\n yylex ()\n {\n   register int c;\n   register int namelen;\n   register unsigned char *tokstart;\n   register struct token *toktab;\n   int wide_flag;\n+  long mask;\n \n  retry:\n \n@@ -540,26 +607,29 @@ yylex ()\n       {\n \tlexptr++;\n \twide_flag = 1;\n+\tmask = LONG_MASK (MAX_WCHAR_TYPE_SIZE);\n \tgoto char_constant;\n       }\n     if (lexptr[1] == '\"')\n       {\n \tlexptr++;\n \twide_flag = 1;\n+\tmask = LONG_MASK (MAX_WCHAR_TYPE_SIZE);\n \tgoto string_constant;\n       }\n     break;\n \n   case '\\'':\n     wide_flag = 0;\n+    mask = LONG_MASK (MAX_CHAR_TYPE_SIZE);\n   char_constant:\n     lexptr++;\n     if (keyword_parsing) {\n       char *start_ptr = lexptr - 1;\n       while (1) {\n \tc = *lexptr++;\n \tif (c == '\\\\')\n-\t  c = parse_escape (&lexptr);\n+\t  c = parse_escape (&lexptr, mask);\n \telse if (c == '\\'')\n \t  break;\n       }\n@@ -572,7 +642,7 @@ yylex ()\n        handles multicharacter constants and wide characters.\n        It is mostly copied from c-lex.c.  */\n     {\n-      register int result = 0;\n+      register long result = 0;\n       register num_chars = 0;\n       unsigned width = MAX_CHAR_TYPE_SIZE;\n       int max_chars;\n@@ -601,19 +671,16 @@ yylex ()\n \n \t  if (c == '\\\\')\n \t    {\n-\t      c = parse_escape (&lexptr);\n-\t      if (width < HOST_BITS_PER_INT\n-\t\t  && (unsigned) c >= (1 << width))\n-\t\tpedwarn (\"escape sequence out of range for character\");\n+\t      c = parse_escape (&lexptr, mask);\n \t    }\n \n \t  num_chars++;\n \n \t  /* Merge character into result; ignore excess chars.  */\n-\t  if (num_chars < max_chars + 1)\n+\t  if (num_chars <= max_chars)\n \t    {\n-\t      if (width < HOST_BITS_PER_INT)\n-\t\tresult = (result << width) | (c & ((1 << width) - 1));\n+\t      if (width < HOST_BITS_PER_LONG)\n+\t\tresult = (result << width) | c;\n \t      else\n \t\tresult = c;\n \t      token_buffer[num_chars - 1] = c;\n@@ -642,10 +709,10 @@ yylex ()\n \t  if (lookup (\"__CHAR_UNSIGNED__\", sizeof (\"__CHAR_UNSIGNED__\")-1, -1)\n \t      || ((result >> (num_bits - 1)) & 1) == 0)\n \t    yylval.integer.value\n-\t      = result & ((unsigned long) ~0 >> (HOST_BITS_PER_LONG - num_bits));\n+\t      = result & (~ (unsigned long) 0 >> (HOST_BITS_PER_LONG - num_bits));\n \t  else\n \t    yylval.integer.value\n-\t      = result | ~((unsigned long) ~0 >> (HOST_BITS_PER_LONG - num_bits));\n+\t      = result | ~(~ (unsigned long) 0 >> (HOST_BITS_PER_LONG - num_bits));\n \t}\n       else\n \t{\n@@ -670,7 +737,7 @@ yylex ()\n     }\n \n     /* This is always a signed type.  */\n-    yylval.integer.unsignedp = 0;\n+    yylval.integer.signedp = SIGNED;\n     \n     return CHAR;\n \n@@ -707,14 +774,15 @@ yylex ()\n     return c;\n \n   case '\"':\n+    mask = LONG_MASK (MAX_CHAR_TYPE_SIZE);\n   string_constant:\n     if (keyword_parsing) {\n       char *start_ptr = lexptr;\n       lexptr++;\n       while (1) {\n \tc = *lexptr++;\n \tif (c == '\\\\')\n-\t  c = parse_escape (&lexptr);\n+\t  c = parse_escape (&lexptr, mask);\n \telse if (c == '\"')\n \t  break;\n       }\n@@ -772,6 +840,9 @@ yylex ()\n    is updated past the characters we use.  The value of the\n    escape sequence is returned.\n \n+   RESULT_MASK is used to mask out the result;\n+   an error is reported if bits are lost thereby.\n+\n    A negative value means the sequence \\ newline was seen,\n    which is supposed to be equivalent to nothing at all.\n \n@@ -781,9 +852,10 @@ yylex ()\n    If \\ is followed by 000, we return 0 and leave the string pointer\n    after the zeros.  A value of 0 does not mean end of string.  */\n \n-int\n-parse_escape (string_ptr)\n+long\n+parse_escape (string_ptr, result_mask)\n      char **string_ptr;\n+     long result_mask;\n {\n   register int c = *(*string_ptr)++;\n   switch (c)\n@@ -822,7 +894,7 @@ parse_escape (string_ptr)\n     case '6':\n     case '7':\n       {\n-\tregister int i = c - '0';\n+\tregister long i = c - '0';\n \tregister int count = 0;\n \twhile (++count < 3)\n \t  {\n@@ -835,16 +907,17 @@ parse_escape (string_ptr)\n \t\tbreak;\n \t      }\n \t  }\n-\tif ((i & ~((1 << MAX_CHAR_TYPE_SIZE) - 1)) != 0)\n+\tif (i != (i & result_mask))\n \t  {\n-\t    i &= (1 << MAX_CHAR_TYPE_SIZE) - 1;\n-\t    warning (\"octal character constant does not fit in a byte\");\n+\t    i &= result_mask;\n+\t    pedwarn (\"octal escape sequence out of range\");\n \t  }\n \treturn i;\n       }\n     case 'x':\n       {\n-\tregister unsigned i = 0, overflow = 0, digits_found = 0, digit;\n+\tregister unsigned long i = 0, overflow = 0;\n+\tregister int digits_found = 0, digit;\n \tfor (;;)\n \t  {\n \t    c = *(*string_ptr)++;\n@@ -865,10 +938,10 @@ parse_escape (string_ptr)\n \t  }\n \tif (!digits_found)\n \t  yyerror (\"\\\\x used with no following hex digits\");\n-\tif (overflow | (i & ~((1 << BITS_PER_UNIT) - 1)))\n+\tif (overflow | (i != (i & result_mask)))\n \t  {\n-\t    i &= (1 << BITS_PER_UNIT) - 1;\n-\t    warning (\"hex character constant does not fit in a byte\");\n+\t    i &= result_mask;\n+\t    pedwarn (\"hex escape sequence out of range\");\n \t  }\n \treturn i;\n       }\n@@ -877,11 +950,11 @@ parse_escape (string_ptr)\n     }\n }\n \n-void\n+static void\n yyerror (s)\n      char *s;\n {\n-  error (s);\n+  error (\"%s\", s);\n   skip_evaluation = 0;\n   longjmp (parse_return_error, 1);\n }\n@@ -903,10 +976,8 @@ left_shift (a, b)\n       interpretation ruling is needed.  */\n   if (b >= HOST_BITS_PER_LONG)\n     return 0;\n-  else if (a->unsignedp)\n-    return (unsigned long) a->value << b;\n   else\n-    return a->value << b;\n+    return (unsigned long) a->value << b;\n }\n \n static long\n@@ -915,11 +986,11 @@ right_shift (a, b)\n      unsigned long b;\n {\n   if (b >= HOST_BITS_PER_LONG)\n-    return a->unsignedp ? 0 : a->value >> (HOST_BITS_PER_LONG - 1);\n-  else if (a->unsignedp)\n-    return (unsigned long) a->value >> b;\n-  else\n+    return a->signedp ? a->value >> (HOST_BITS_PER_LONG - 1) : 0;\n+  else if (a->signedp)\n     return a->value >> b;\n+  else\n+    return (unsigned long) a->value >> b;\n }\n \f\n /* This page contains the entry point to this file.  */\n@@ -931,7 +1002,7 @@ right_shift (a, b)\n /* We do not support C comments.  They should be removed before\n    this function is called.  */\n \n-HOST_WIDE_INT\n+long\n parse_c_expression (string)\n      char *string;\n {\n@@ -958,18 +1029,31 @@ parse_c_expression (string)\n }\n \f\n #ifdef TEST_EXP_READER\n+\n+#if YYDEBUG\n extern int yydebug;\n+#endif\n+\n+int pedantic;\n+int traditional;\n+\n+int main PROTO((int, char **));\n+static void initialize_random_junk PROTO((void));\n \n /* Main program for testing purposes.  */\n int\n-main ()\n+main (argc, argv)\n+     int argc;\n+     char **argv;\n {\n   int n, c;\n   char buf[1024];\n \n-/*\n-  yydebug = 1;\n-*/\n+  pedantic = 1 < argc;\n+  traditional = 2 < argc;\n+#if YYDEBUG\n+  yydebug = 3 < argc;\n+#endif\n   initialize_random_junk ();\n \n   for (;;) {\n@@ -991,11 +1075,12 @@ unsigned char is_idchar[256];\n unsigned char is_idstart[256];\n /* table to tell if c is horizontal space.  isspace () thinks that\n    newline is space; this is not a good idea for this program. */\n-char is_hor_space[256];\n+unsigned char is_hor_space[256];\n \n /*\n  * initialize random junk in the hash table and maybe other places\n  */\n+static void\n initialize_random_junk ()\n {\n   register int i;\n@@ -1026,22 +1111,68 @@ initialize_random_junk ()\n   ++is_hor_space['\\t'];\n }\n \n-error (msg)\n+void\n+error (PRINTF_ALIST (msg))\n+     PRINTF_DCL (msg)\n {\n-  printf (\"error: %s\\n\", msg);\n+  va_list args;\n+\n+  VA_START (args, msg);\n+  fprintf (stderr, \"error: \");\n+  vfprintf (stderr, msg, args);\n+  fprintf (stderr, \"\\n\");\n+  va_end (args);\n }\n \n-warning (msg)\n+void\n+pedwarn (PRINTF_ALIST (msg))\n+     PRINTF_DCL (msg)\n+{\n+  va_list args;\n+\n+  VA_START (args, msg);\n+  fprintf (stderr, \"pedwarn: \");\n+  vfprintf (stderr, msg, args);\n+  fprintf (stderr, \"\\n\");\n+  va_end (args);\n+}\n+\n+void\n+warning (PRINTF_ALIST (msg))\n+     PRINTF_DCL (msg)\n {\n-  printf (\"warning: %s\\n\", msg);\n+  va_list args;\n+\n+  VA_START (args, msg);\n+  fprintf (stderr, \"warning: \");\n+  vfprintf (stderr, msg, args);\n+  fprintf (stderr, \"\\n\");\n+  va_end (args);\n+}\n+\n+int\n+check_assertion (name, sym_length, tokens_specified, tokens)\n+     U_CHAR *name;\n+     int sym_length;\n+     int tokens_specified;\n+     struct arglist *tokens;\n+{\n+  return 0;\n }\n \n struct hashnode *\n lookup (name, len, hash)\n-     char *name;\n+     U_CHAR *name;\n      int len;\n      int hash;\n {\n   return (DEFAULT_SIGNED_CHAR) ? 0 : ((struct hashnode *) -1);\n }\n+\n+GENERIC_PTR\n+xmalloc (size)\n+     size_t size;\n+{\n+  return (GENERIC_PTR) malloc (size);\n+}\n #endif"}]}