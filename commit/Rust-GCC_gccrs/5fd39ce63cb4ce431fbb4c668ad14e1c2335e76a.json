{"sha": "5fd39ce63cb4ce431fbb4c668ad14e1c2335e76a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWZkMzljZTYzY2I0Y2U0MzFmYmI0YzY2OGFkMTRlMWMyMzM1ZTc2YQ==", "commit": {"author": {"name": "Lawrence Crowl", "email": "crowl@google.com", "date": "2012-11-01T22:39:26Z"}, "committer": {"name": "Lawrence Crowl", "email": "crowl@gcc.gnu.org", "date": "2012-11-01T22:39:26Z"}, "message": "This patch removes the unused ebitmap, and then removes some sbitmap functions only used by ebitmap.\n\nThis patch removes the unused ebitmap, and then removes some sbitmap functions\nonly used by ebitmap.  The functions removed are:\n\nSET_BIT_WITH_POPCOUNT\nRESET_BIT_WITH_POPCOUNT\nbitmap_copy_n\nbitmap_range_empty_p\nsbitmap_popcount\n\nIn addition, two functions have been made private to the implementation file:\n\nSBITMAP_SIZE_BYTES\nsbitmap_verify_popcount\n\nTested on x86-64.\n\n\nIndex: gcc/ChangeLog\n\n2012-11-01  Lawrence Crowl  <crowl@google.com>\n\n\t* ebitmap.h: Remove unused.\n\t* ebitmap.c: Remove unused.\n\t* Makefile.in: Remove ebitmap.h and ebitmap.c.\n\t* sbitmap.h (SBITMAP_SIZE_BYTES): Move to source file.\n\t(SET_BIT_WITH_POPCOUNT): Remove unused.\n\t(RESET_BIT_WITH_POPCOUNT): Remove unused.\n\t(bitmap_copy_n): Remove unused.\n\t(bitmap_range_empty_p): Remove unused.\n\t(sbitmap_popcount): Remove unused.\n\t(sbitmap_verify_popcount): Make private to source file.\n\t* sbitmap.c (SBITMAP_SIZE_BYTES): Move here from header.\n\t(bitmap_copy_n): Remove unused.\n\t(bitmap_range_empty_p): Remove unused.\n\t(sbitmap_popcount): Remove unused.\n\t(sbitmap_verify_popcount): Make private to source file.\n\n2012-11-01  Lawrence Crowl  <crowl@google.com>\n\nFrom-SVN: r193072", "tree": {"sha": "721953d1607e06b4dcb3e4e0e522f8d20d151d17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/721953d1607e06b4dcb3e4e0e522f8d20d151d17"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5fd39ce63cb4ce431fbb4c668ad14e1c2335e76a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fd39ce63cb4ce431fbb4c668ad14e1c2335e76a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fd39ce63cb4ce431fbb4c668ad14e1c2335e76a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fd39ce63cb4ce431fbb4c668ad14e1c2335e76a/comments", "author": null, "committer": null, "parents": [{"sha": "c291b2adc6f25d897928c79f431d987eb74e4bc5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c291b2adc6f25d897928c79f431d987eb74e4bc5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c291b2adc6f25d897928c79f431d987eb74e4bc5"}], "stats": {"total": 1380, "additions": 34, "deletions": 1346}, "files": [{"sha": "2865ceeabfb062fab2b0707ede537c4307f3dace", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd39ce63cb4ce431fbb4c668ad14e1c2335e76a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd39ce63cb4ce431fbb4c668ad14e1c2335e76a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5fd39ce63cb4ce431fbb4c668ad14e1c2335e76a", "patch": "@@ -1,4 +1,22 @@\n-2012-10-31  Lawrence Crowl  <crowl@google.com>\n+2012-11-01  Lawrence Crowl  <crowl@google.com>\n+\n+\t* ebitmap.h: Remove unused.\n+\t* ebitmap.c: Remove unused.\n+\t* Makefile.in: Remove ebitmap.h and ebitmap.c.\n+\t* sbitmap.h (SBITMAP_SIZE_BYTES): Move to source file.\n+\t(SET_BIT_WITH_POPCOUNT): Remove unused.\n+\t(RESET_BIT_WITH_POPCOUNT): Remove unused.\n+\t(bitmap_copy_n): Remove unused.\n+\t(bitmap_range_empty_p): Remove unused.\n+\t(sbitmap_popcount): Remove unused.\n+\t(sbitmap_verify_popcount): Make private to source file.\n+\t* sbitmap.c (SBITMAP_SIZE_BYTES): Move here from header.\n+\t(bitmap_copy_n): Remove unused.\n+\t(bitmap_range_empty_p): Remove unused.\n+\t(sbitmap_popcount): Remove unused.\n+\t(sbitmap_verify_popcount): Make private to source file.\n+\n+2012-11-01  Lawrence Crowl  <crowl@google.com>\n \n \t* sbitmap.h (sbitmap_iter_init): Rename bmp_iter_set_init and add\n \tunused parameter to match bitmap iterator.  Update callers."}, {"sha": "9aea03ddc469799cfc7d6a527470d86f3447f1a5", "filename": "gcc/Makefile.in", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd39ce63cb4ce431fbb4c668ad14e1c2335e76a/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd39ce63cb4ce431fbb4c668ad14e1c2335e76a/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=5fd39ce63cb4ce431fbb4c668ad14e1c2335e76a", "patch": "@@ -942,7 +942,6 @@ REAL_H = real.h $(MACHMODE_H)\n IRA_INT_H = ira.h ira-int.h $(CFGLOOP_H) alloc-pool.h\n LRA_INT_H = lra.h $(BITMAP_H) $(RECOG_H) $(INSN_ATTR_H) insn-codes.h lra-int.h\n DBGCNT_H = dbgcnt.h dbgcnt.def\n-EBITMAP_H = ebitmap.h sbitmap.h\n LTO_STREAMER_H = lto-streamer.h $(LINKER_PLUGIN_API_H) $(TARGET_H) \\\n \t\t$(CGRAPH_H) $(VEC_H) vecprim.h $(TREE_H) $(GIMPLE_H) \\\n \t\t$(GCOV_IO_H) $(DIAGNOSTIC_H) alloc-pool.h\n@@ -1200,7 +1199,6 @@ OBJS = \\\n \tdwarf2asm.o \\\n \tdwarf2cfi.o \\\n \tdwarf2out.o \\\n-\tebitmap.o \\\n \temit-rtl.o \\\n \tet-forest.o \\\n \texcept.o \\\n@@ -1833,7 +1831,6 @@ graph.o: graph.c $(SYSTEM_H) coretypes.h $(TM_H) toplev.h $(DIAGNOSTIC_CORE_H) $\n     $(CONFIG_H) $(EMIT_RTL_H)\n \n sbitmap.o: sbitmap.c sbitmap.h $(CONFIG_H) $(SYSTEM_H) coretypes.h\n-ebitmap.o: ebitmap.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(EBITMAP_H)\n sparseset.o: sparseset.c $(SYSTEM_H) sparseset.h $(CONFIG_H)\n \n AR_LIBS = @COLLECT2_LIBS@"}, {"sha": "334953204e3a901117b136d21464054da7e1ec49", "filename": "gcc/ebitmap.c", "status": "removed", "additions": 0, "deletions": 1019, "changes": 1019, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c291b2adc6f25d897928c79f431d987eb74e4bc5/gcc%2Febitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c291b2adc6f25d897928c79f431d987eb74e4bc5/gcc%2Febitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Febitmap.c?ref=c291b2adc6f25d897928c79f431d987eb74e4bc5", "patch": "@@ -1,1019 +0,0 @@\n-/* Sparse array-based bitmaps.\n-   Copyright (C) 2007-2012  Free Software Foundation, Inc.\n-   Contributed by Daniel Berlin <dberlin@dberlin.org>\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"ebitmap.h\"\n-\n-/* The ebitmap data structure is a sparse bitmap structure that works\n-   by having two pieces:\n-   1. An array of all nonzero words in the structures, organized as\n-   an array of HOST_WIDE_INT's.\n-   2. A non-sparse bitmap saying which bitmap words are present in the\n-   array.\n-\n-   As a consequence of this representation, testing whether a bit\n-   exists in the bitmap is faster than linked-list bitmaps.  For bits\n-   in words that are all zero, the time to test is O(1).  For bits in\n-   words that exist, it requires O(n/sizeof(word)) time to perform the\n-   test (ignoring the one element cache).  It also has much better\n-   locality than linked-list bitmaps.\n-\n-   To test whether a bit exists, we do the following:\n-   1. Test whether the word the bit would appear in exists in the\n-   bitmap (O(1) check of the mask).  If not, fail.\n-\n-   2. Population count the mask up to the word containing the bit, to\n-   find the place in the array the word would be (popcount is cached,\n-   but this is just as slow as the linked-list bitmap)\n-   3. Test the word to see if the bit exists.\n-\n-   Just like linked-list bitmaps, we cache the last element that has\n-   been tested in order to speed up common access patterns.\n-\n-   Most of the other speedups are simply due to better locality of the\n-   single contiguous array.\n-\n-   As would be expected in a structure like this, insertion into an\n-   empty word in the middle requires moving bits to make room for the\n-   new word.   As most operations that perform sets perform them in\n-   order, this is rarely a problem.  We also take advantage of the\n-   same element cache to make repeated sets to the same word O(1).\n-\n-   Operations on the entire bitmap are also more efficient than linked\n-   list bitmaps, as they are all operating on contiguous memory, and\n-   can be easily vectorized.  They are all O(number of words) +\n-   O(number of bits that may end up in the destination), as the\n-   appropriate operation is first performed on the word mask, and then\n-   only those elements that may generate results are touched.\n-\n-   Memory wise, the ebitmap starts out using less memory than the\n-   linked-list bitmap, but its size in memory is technically bounded\n-   by ((index of the highest bit set) / (size of a word) + (index of\n-   the highest bit set) / ((size of a word) * (size of a word))) This\n-   is because the mask is non-sparse.  The mask could be transformed\n-   into a sparse bitmap at the cost of making bit testing\n-   *theoretically* slower (real world numbers have not been computed\n-   yet as to whether it matters or not).  */\n-\n-/* #define EBITMAP_DEBUGGING  */\n-\n-/* Find the last set bit in ebitmap MAP.  */\n-\n-int\n-bitmap_last_set_bit (ebitmap map)\n-{\n-  unsigned int i = 0;\n-  ebitmap_iterator ebi;\n-  bool foundbit = false;\n-\n-  /* This is not the fastest way to do this, we could simply look for\n-     the popcount, and start there, but this function is not used\n-     anywhere speed critical.  */\n-  EXECUTE_IF_SET_IN_EBITMAP (map, 0, i, ebi)\n-    {\n-      foundbit = true;\n-    }\n-\n-\n-  if (foundbit)\n-    return i;\n-  return -1;\n-}\n-\n-/* Grow or shrink the internal word array for MAP to NEWSIZE\n-   elements.  */\n-\n-static inline void\n-ebitmap_array_grow (ebitmap map, unsigned int newsize)\n-{\n-  if (newsize <= map->n_elts)\n-    {\n-      map->n_elts = newsize;\n-      return;\n-    }\n-\n-  newsize += newsize / 4;\n-\n-  map->n_elts = newsize;\n-  map->elts = XRESIZEVEC (EBITMAP_ELT_TYPE, map->elts, newsize);\n-}\n-\n-/* Grow the internal word array for MAP so it is at least SIZE\n-   elements.  Will not shrink the array if it is already big\n-   enough.  */\n-\n-static inline void\n-ebitmap_array_maybe_grow (ebitmap map, unsigned int size)\n-{\n-  if (size >= map->n_elts)\n-    ebitmap_array_grow (map, size + 1);\n-}\n-\n-/* Retrieve the IDX'th element from the word array for MAP.  */\n-\n-static inline EBITMAP_ELT_TYPE\n-ebitmap_array_get (ebitmap map, unsigned int idx)\n-{\n-  gcc_assert (idx < map->n_elts);\n-  return map->elts[idx];\n-}\n-\n-/* Retrieve a pointer to the IDX'th element from the word array for\n-   MAP.  If the element index is greater than the size of the array,\n-   the array will be grown to the correct size.  */\n-\n-static inline EBITMAP_ELT_TYPE *\n-ebitmap_array_grow_get (ebitmap map, unsigned int idx)\n-{\n-  if (idx >= map->n_elts)\n-    ebitmap_array_grow (map, idx + 1);\n-  return &map->elts[idx];\n-}\n-\n-/* Initialize the internal word array for MAP, so that it is SIZE\n-   elements.  */\n-\n-static inline void\n-ebitmap_array_init (ebitmap map, unsigned int size)\n-{\n-  if (size > 0)\n-    {\n-      map->elts = XNEWVEC (EBITMAP_ELT_TYPE, size);\n-      map->n_elts = size;\n-    }\n-  else\n-    {\n-      map->n_elts = 0;\n-      map->elts = NULL;\n-    }\n-}\n-\n-/* Free the internal word array for MAP.  */\n-\n-static inline void\n-ebitmap_array_clear (ebitmap map)\n-{\n-  if (map->elts)\n-    {\n-      free (map->elts);\n-      map->elts = NULL;\n-    }\n-  map->n_elts = 0;\n-}\n-\n-/* Clear ebitmap MAP.  */\n-\n-void\n-bitmap_clear (ebitmap map)\n-{\n-  ebitmap_array_clear (map);\n-  bitmap_clear (map->wordmask);\n-  map->wordmask = sbitmap_resize (map->wordmask, 1, 0);\n-  map->numwords = 0;\n-  map->cache = NULL;\n-  map->cacheindex = 0;\n-}\n-\n-/* Allocate an ebitmap with enough room for SIZE bits to start out.  */\n-\n-ebitmap\n-ebitmap_alloc (unsigned int size)\n-{\n-  ebitmap ret = XNEW (struct ebitmap_def);\n-  if (size == 0)\n-    size = EBITMAP_ELT_BITS;\n-  ebitmap_array_init (ret, (size + EBITMAP_ELT_BITS - 1) / EBITMAP_ELT_BITS);\n-  ret->wordmask = sbitmap_alloc_with_popcount (size);\n-  bitmap_clear (ret->wordmask);\n-  ret->numwords = 0;\n-  ret->cache = NULL;\n-  ret->cacheindex = 0;\n-\n-  return ret;\n-}\n-\n-/* Clear BIT from ebitmap MAP.  */\n-\n-void\n-bitmap_clear_bit (ebitmap map, unsigned int bit)\n-{\n-  unsigned int wordindex = bit / EBITMAP_ELT_BITS;\n-  unsigned int eltwordindex = 0;\n-  unsigned int bitindex, shift;\n-  bool have_eltwordindex = false;\n-  EBITMAP_ELT_TYPE *elt_ptr;\n-\n-  /* If the bit can't exist in our bitmap, just return.  */\n-  if (map->numwords == 0)\n-    return;\n-\n-  if (wordindex >= map->wordmask->n_bits\n-      || !bitmap_bit_p (map->wordmask, wordindex))\n-    return;\n-\n-  if (map->cache != NULL && map->cacheindex == wordindex)\n-    elt_ptr = map->cache;\n-  else\n-    {\n-      eltwordindex = sbitmap_popcount (map->wordmask, wordindex);\n-      elt_ptr = &map->elts[eltwordindex];\n-      have_eltwordindex = true;\n-    }\n-\n-  bitindex = bit % EBITMAP_ELT_BITS;\n-  shift = bitindex;\n-\n-  *(elt_ptr) &= ~(((EBITMAP_ELT_TYPE)1) << shift);\n-\n-  /* Clear out the empty words.  */\n-  if (*(elt_ptr) == 0)\n-    {\n-      if (!have_eltwordindex)\n-\teltwordindex = sbitmap_popcount (map->wordmask, wordindex);\n-\n-      if (map->cache != NULL)\n-        {\n-          if (map->cacheindex == wordindex)\n-            map->cache = NULL;\n-          else if (map->cacheindex > wordindex)\n-            map->cache = map->cache - 1;\n-        }\n-\n-      bitmap_clear_bit_with_popcount (map->wordmask, wordindex);\n-\n-      memmove(&map->elts[eltwordindex], &map->elts[eltwordindex + 1],\n-\t      sizeof (EBITMAP_ELT_TYPE) * (map->numwords - eltwordindex));\n-      map->numwords--;\n-    }\n-}\n-\n-/* Set BIT in ebitmap MAP.  */\n-\n-void\n-bitmap_set_bit (ebitmap map, unsigned int bit)\n-{\n-  unsigned int wordindex = bit / EBITMAP_ELT_BITS;\n-  unsigned int eltwordindex;\n-  unsigned int bitindex =   bit % EBITMAP_ELT_BITS;\n-\n-  /* If we have this element cached, just set the bit in it.  */\n-  if (map->cache && map->cacheindex == wordindex)\n-    {\n-      (*map->cache) |= (EBITMAP_ELT_TYPE)1 << bitindex;\n-      return;\n-    }\n-\n-  /* Resize the wordmask if necessary.  */\n-  if (wordindex >= map->wordmask->n_bits)\n-    map->wordmask = sbitmap_resize (map->wordmask, wordindex + 1, 0);\n-\n-  /* Allocate a new word in the array and move whatever is in it's\n-     place, if necessary. */\n-  if (!bitmap_bit_p (map->wordmask, wordindex))\n-    {\n-      unsigned long count;\n-      unsigned int i;\n-\n-      bitmap_set_bit_with_popcount (map->wordmask, wordindex);\n-      count = sbitmap_popcount (map->wordmask, wordindex);\n-      gcc_assert (count <= map->numwords);\n-\n-      for (i = map->numwords; i > count; i--)\n-\t{\n-\t  EBITMAP_ELT_TYPE *newelt;\n-\t  newelt = ebitmap_array_grow_get (map, i);\n-\t  *newelt = ebitmap_array_get (map, i - 1);\n-\t}\n-      map->numwords++;\n-      eltwordindex = count;\n-      ebitmap_array_maybe_grow (map, eltwordindex);\n-      map->elts[eltwordindex] = 0;\n-    }\n-  else\n-    {\n-      eltwordindex = sbitmap_popcount (map->wordmask, wordindex);\n-    }\n-\n-  /* Set the actual bit.  */\n-  bitindex = bit % EBITMAP_ELT_BITS;\n-\n-  map->elts[eltwordindex] |= (EBITMAP_ELT_TYPE)1 << bitindex;\n-  map->cache = &map->elts[eltwordindex];\n-  map->cacheindex = wordindex;\n-}\n-\n-\n-/* Return true if MAP contains BIT.  */\n-\n-bool\n-bitmap_bit_p (ebitmap map, unsigned int bit)\n-{\n-  unsigned int wordindex = bit / EBITMAP_ELT_BITS;\n-  unsigned int bitindex= bit % EBITMAP_ELT_BITS;\n-\n-  /* Trivial empty ebitmap case.  */\n-  if (map->numwords == 0)\n-    return false;\n-\n-  if (map->cache && map->cacheindex == wordindex)\n-    return ((*map->cache) >> bitindex) & 1;\n-\n-  /* If the wordindex is greater than the size of the wordmask, *or*\n-     it's not set in the wordmask, this bit can't exist in our\n-     ebitmap.  */\n-  if (wordindex >= map->wordmask->n_bits\n-      || !bitmap_bit_p (map->wordmask, wordindex))\n-    return false;\n-\n-  /* Find the bit and test it.  */\n-  map->cacheindex = wordindex;\n-  wordindex = sbitmap_popcount (map->wordmask, wordindex);\n-  map->cache = &map->elts[wordindex];\n-\n-  return (map->elts[wordindex] >> bitindex) & 1;\n-}\n-\n-/* Copy ebitmap SRC to DST.  */\n-\n-void\n-bitmap_copy (ebitmap dst, ebitmap src)\n-{\n-  /* Blow away any existing wordmask, and copy the new one.  */\n-  sbitmap_free (dst->wordmask);\n-  dst->wordmask = sbitmap_alloc_with_popcount (src->wordmask->n_bits);\n-  bitmap_copy (dst->wordmask, src->wordmask);\n-\n-  /* Make sure our destination array is big enough, and then copy the\n-     actual words.  */\n-  ebitmap_array_grow (dst, src->numwords);\n-  memcpy (dst->elts, src->elts,\n-\t  src->numwords * sizeof (EBITMAP_ELT_TYPE));\n-  dst->numwords = src->numwords;\n-  dst->cache = NULL;\n-}\n-\n-/* Dump ebitmap BMAP to FILE.  */\n-\n-void\n-dump_bitmap (FILE *file, ebitmap bmap)\n-{\n-  unsigned int pos;\n-  unsigned int i;\n-  int res;\n-  unsigned int size;\n-\n-  res = bitmap_last_set_bit (bmap->wordmask);\n-  if (res == -1)\n-    size = 0;\n-  else\n-    size = (res + 1) * EBITMAP_ELT_BITS;\n-\n-  fprintf (file, \"n_words = %d, set = {\", bmap->numwords);\n-\n-  for (pos = 30, i = 0; i < size; i++)\n-    if (bitmap_bit_p (bmap, i))\n-      {\n-\tif (pos > 70)\n-\t  {\n-\t    fprintf (file, \"\\n  \");\n-\t    pos = 0;\n-\t  }\n-\n-\tpos += fprintf (file, \"%d \", i);\n-      }\n-\n-  fprintf (file, \"}\\n\");\n-}\n-\n-/* Dump ebitmap BMAP to stderr.  */\n-\n-DEBUG_FUNCTION void\n-debug_bitmap (ebitmap bmap)\n-{\n-  dump_bitmap (stderr, bmap);\n-}\n-\n-/* Perform the operation DST &= SRC.  */\n-\n-void\n-bitmap_and_into (ebitmap dst, ebitmap src)\n-{\n-  sbitmap_iterator sbi;\n-  unsigned int i;\n-  unsigned int neweltindex = 0;\n-  unsigned int dsteltindex = 0;\n-  unsigned int srceltindex = 0;\n-\n-  gcc_assert (dst != src);\n-\n-  dst->cache = NULL;\n-\n-  /* Short circuit the empty bitmap cases.  */\n-  if (src->numwords == 0 || dst->numwords == 0)\n-    {\n-      bitmap_clear (dst);\n-      return;\n-    }\n-\n-  /* AND the masks, then walk the words that may actually appear in\n-     the result, AND'ing them.  */\n-  bitmap_and (dst->wordmask, dst->wordmask, src->wordmask);\n-\n-  EXECUTE_IF_SET_IN_BITMAP (dst->wordmask, 0, i, sbi)\n-    {\n-      EBITMAP_ELT_TYPE tmpword = ebitmap_array_get (src, srceltindex++);\n-      tmpword &= ebitmap_array_get (dst, dsteltindex++);\n-      if (tmpword != 0)\n-\t{\n-\t  EBITMAP_ELT_TYPE *dstplace;\n-\t  dstplace = ebitmap_array_grow_get (dst, neweltindex++);\n-\t  *dstplace = tmpword;\n-\t}\n-      else\n-\tbitmap_clear_bit_with_popcount (dst->wordmask, i);\n-    }\n-#ifdef EBITMAP_DEBUGGING\n-  {\n-    unsigned int i;\n-\n-    for (i = 0; i <  dst->numwords; i++)\n-      gcc_assert (dst->elts[i] != 0);\n-\n-    sbitmap_verify_popcount (dst->wordmask);\n-    gcc_assert (sbitmap_popcount (dst->wordmask,\n-\t\t\t\t  dst->wordmask->n_bits) == dst->numwords);\n-  }\n-#endif\n-  dst->numwords = neweltindex;\n-}\n-\n-/* Perform the operation DST = SRC1 & SRC2.  */\n-\n-void\n-bitmap_and (ebitmap dst, ebitmap src1, ebitmap src2)\n-{\n-  sbitmap_iterator sbi;\n-  unsigned int i;\n-  unsigned int neweltindex = 0;\n-  unsigned int src1eltindex = 0;\n-  unsigned int src2eltindex = 0;\n-\n-  dst->cache = NULL;\n-  if (src1->numwords == 0 || src2->numwords == 0)\n-    {\n-      bitmap_clear (dst);\n-      return;\n-    }\n-\n-  dst->wordmask\n-    = sbitmap_resize (dst->wordmask,\n-\t\t      MIN (src1->wordmask->n_bits, src2->wordmask->n_bits),\n-\t\t      0);\n-  bitmap_and (dst->wordmask, src1->wordmask, src2->wordmask);\n-\n-  EXECUTE_IF_SET_IN_BITMAP (dst->wordmask, 0, i, sbi)\n-    {\n-      bool src1hasword, src2hasword;\n-\n-      src1hasword = bitmap_bit_p (src1->wordmask, i);\n-      src2hasword = bitmap_bit_p (src2->wordmask, i);\n-\n-      if (src1hasword && src2hasword)\n-\t{\n-\t  EBITMAP_ELT_TYPE tmpword = ebitmap_array_get (src1, src1eltindex++);\n-\t  tmpword &= ebitmap_array_get (src2, src2eltindex++);\n-\t  if (tmpword != 0)\n-\t    {\n-\t      EBITMAP_ELT_TYPE *dstplace;\n-\t      dstplace = ebitmap_array_grow_get (dst, neweltindex++);\n-\t      *dstplace = tmpword;\n-\t    }\n-\t  else\n-\t    bitmap_clear_bit_with_popcount (dst->wordmask, i);\n-\t}\n-      else if (src1hasword)\n-\tsrc1eltindex++;\n-      else\n-\tsrc2eltindex++;\n-    }\n-#ifdef EBITMAP_DEBUGGING\n-  {\n-    ebitmap_iterator ebi;\n-    unsigned int i;\n-\n-    for (i = 0; i <  dst->numwords; i++)\n-      gcc_assert (dst->elts[i] != 0);\n-\n-    EXECUTE_IF_SET_IN_EBITMAP (src1, 0, i, ebi)\n-      if (bitmap_bit_p (src2, i))\n-\tgcc_assert (bitmap_bit_p (dst, i));\n-\n-    for (i = 0; i <  dst->numwords; i++)\n-      gcc_assert (dst->elts[i] != 0);\n-\n-    sbitmap_verify_popcount (dst->wordmask);\n-    gcc_assert (sbitmap_popcount (dst->wordmask,\n-\t\t\t\t  dst->wordmask->n_bits) == dst->numwords);\n-  }\n-#endif\n-  dst->numwords = neweltindex;\n-}\n-\n-/* Perform the operation DST |= SRC.  Return true if any bits in DST\n-   changed.  */\n-\n-bool\n-bitmap_ior_into (ebitmap dst, ebitmap src)\n-{\n-  unsigned int dstsize = dst->wordmask->n_bits;\n-  unsigned int srcsize = src->wordmask->n_bits;\n-  sbitmap_iterator sbi;\n-  unsigned int i;\n-  sbitmap tempmask;\n-  unsigned int neweltindex = 0;\n-  unsigned int dsteltindex = 0;\n-  unsigned int srceltindex = 0;\n-  bool changed = false;\n-  EBITMAP_ELT_TYPE *newarray;\n-  unsigned int newarraysize;\n-#ifdef EBITMAP_DEBUGGING\n-  ebitmap dstcopy = ebitmap_alloc (1);\n-  bitmap_copy (dstcopy, dst);\n-#endif\n-\n-  dst->cache = NULL;\n-  if (dst == src)\n-    return false;\n-\n-  if (dst->numwords == 0 && src->numwords != 0)\n-    {\n-      bitmap_copy (dst, src);\n-      return true;\n-    }\n-  else if (src->numwords == 0)\n-    return false;\n-\n-  /* We can do without the temp mask if it's faster, but it would mean\n-     touching more words in the actual dense vector.  */\n-  tempmask = sbitmap_alloc (MAX (srcsize, dstsize));\n-  bitmap_clear (tempmask);\n-  if (srcsize == dstsize)\n-    {\n-      bitmap_ior (tempmask, dst->wordmask, src->wordmask);\n-    }\n-  else\n-    {\n-      dst->wordmask = sbitmap_resize (dst->wordmask, MAX (srcsize, dstsize),\n-\t\t\t\t      0);\n-      if (srcsize >= dstsize)\n-\t{\n-\t  bitmap_copy_n (tempmask, dst->wordmask, dst->wordmask->size);\n-\t  bitmap_ior (tempmask, tempmask, src->wordmask);\n-\t}\n-      else\n-\t{\n-\t  bitmap_copy_n (tempmask, src->wordmask, src->wordmask->size);\n-\t  bitmap_ior (tempmask, tempmask, dst->wordmask);\n-\t}\n-    }\n-  newarraysize = src->numwords + dst->numwords;\n-  newarray = XNEWVEC (EBITMAP_ELT_TYPE, newarraysize);\n-\n-  EXECUTE_IF_SET_IN_BITMAP (tempmask, 0, i, sbi)\n-    {\n-      bool dsthasword, srchasword;\n-\n-      dsthasword = (i < dst->wordmask->n_bits\n-\t\t    && bitmap_bit_p (dst->wordmask, i));\n-      srchasword = (i < src->wordmask->n_bits\n-\t\t    && bitmap_bit_p (src->wordmask, i));\n-\n-      if (dsthasword && srchasword)\n-\t{\n-\t  EBITMAP_ELT_TYPE tmpword = ebitmap_array_get (src, srceltindex++);\n-\t  tmpword |= ebitmap_array_get (dst, dsteltindex);\n-\t  if (!changed)\n-\t    changed |= tmpword != ebitmap_array_get (dst, dsteltindex);\n-\t  dsteltindex++;\n-\t  newarray[neweltindex++] = tmpword;\n-\t}\n-      else if (dsthasword)\n-\t{\n-\t  newarray [neweltindex++] = ebitmap_array_get (dst, dsteltindex++);\n-\t}\n-      else\n-\t{\n-\t  newarray [neweltindex++] = ebitmap_array_get (src, srceltindex++);\n-\t  gcc_assert (i < dst->wordmask->n_bits);\n-\t  bitmap_set_bit_with_popcount (dst->wordmask, i);\n-\t  changed |= true;\n-\t}\n-    }\n-\n-  sbitmap_free (tempmask);\n-  if (changed)\n-    {\n-      dst->numwords = neweltindex;\n-      free (dst->elts);\n-      dst->elts = newarray;\n-      dst->n_elts = newarraysize;\n-    }\n-  else\n-    free (newarray);\n-\n-#ifdef EBITMAP_DEBUGGING\n-  {\n-    ebitmap_iterator ebi;\n-    unsigned int i;\n-\n-    for (i = 0; i <  dst->numwords; i++)\n-      gcc_assert (dst->elts[i] != 0);\n-\n-    EXECUTE_IF_SET_IN_EBITMAP (src, 0, i, ebi)\n-      gcc_assert (bitmap_bit_p (dst, i));\n-    EXECUTE_IF_SET_IN_EBITMAP (dstcopy, 0, i, ebi)\n-      gcc_assert (bitmap_bit_p (dst, i));\n-\n-    sbitmap_verify_popcount (dst->wordmask);\n-    gcc_assert (changed == !bitmap_equal_p (dst, dstcopy));\n-    gcc_assert (sbitmap_popcount (dst->wordmask,\n-\t\t\t\t  dst->wordmask->n_bits) == dst->numwords);\n-  }\n-#endif\n-  return changed;\n-}\n-\n-/* Perform the operation DST = SRC1 | SRC2.  Return true if any bit\n-   in DST has changed.  */\n-\n-bool\n-bitmap_ior (ebitmap dst, ebitmap src1, ebitmap src2)\n-{\n-  unsigned int src1size = src1->wordmask->n_bits;\n-  unsigned int src2size = src2->wordmask->n_bits;\n-  sbitmap_iterator sbi;\n-  unsigned int i;\n-  sbitmap tempmask;\n-  unsigned int neweltindex = 0;\n-  unsigned int src1eltindex = 0;\n-  unsigned int src2eltindex = 0;\n-  bool changed = false;\n-  EBITMAP_ELT_TYPE *newarray;\n-  unsigned int newarraysize;\n-#ifdef EBITMAP_DEBUGGING\n-  ebitmap dstcopy = ebitmap_alloc (1);\n-  bitmap_copy (dstcopy, dst);\n-#endif\n-\n-  dst->cache = NULL;\n-  tempmask = sbitmap_alloc_with_popcount (MAX (src1size, src2size));\n-  bitmap_clear (tempmask);\n-  if (src1size == src2size)\n-    {\n-      bitmap_ior (tempmask, src1->wordmask, src2->wordmask);\n-    }\n-  else\n-    {\n-      if (src1size >= src2size)\n-\t{\n-\t  bitmap_copy_n (tempmask, src2->wordmask, src2->wordmask->size);\n-\t  bitmap_ior (tempmask, tempmask, src1->wordmask);\n-\t}\n-      else\n-\t{\n-\t  bitmap_copy_n (tempmask, src1->wordmask, src1->wordmask->size);\n-\t  bitmap_ior (tempmask, tempmask, src2->wordmask);\n-\t}\n-    }\n-  newarraysize = src1->numwords + src2->numwords;\n-  newarray = XNEWVEC (EBITMAP_ELT_TYPE, newarraysize);\n-\n-  EXECUTE_IF_SET_IN_BITMAP (tempmask, 0, i, sbi)\n-    {\n-      bool src1hasword, src2hasword;\n-      EBITMAP_ELT_TYPE tmpword;\n-      src1hasword = (i < src1->wordmask->n_bits\n-\t\t    && bitmap_bit_p (src1->wordmask, i));\n-      src2hasword = (i < src2->wordmask->n_bits\n-\t\t    && bitmap_bit_p (src2->wordmask, i));\n-\n-      if (src1hasword && src2hasword)\n-\t{\n-\t  tmpword = (ebitmap_array_get (src1, src1eltindex++)\n-\t\t     | ebitmap_array_get (src2, src2eltindex++));\n-\t  newarray[neweltindex++] = tmpword;\n-\t}\n-      else if (src1hasword)\n-\t{\n-\t  tmpword = ebitmap_array_get (src1, src1eltindex++);\n-\t  newarray [neweltindex++] = tmpword;\n-\t}\n-      else\n-\t{\n-\t  tmpword = ebitmap_array_get (src2, src2eltindex++);\n-\t  newarray [neweltindex++] = tmpword;\n-\t}\n-\n-      if (i >= dst->wordmask->n_bits || !bitmap_bit_p (dst->wordmask, i))\n-\t{\n-\t  changed = true;\n-\t}\n-      else if (!changed)\n-\t{\n-\t  unsigned int count = sbitmap_popcount (dst->wordmask, i);\n-\t  changed |= ebitmap_array_get (dst, count) != tmpword;\n-\t}\n-    }\n-\n-  if (changed)\n-    {\n-      sbitmap_free (dst->wordmask);\n-      dst->wordmask = tempmask;\n-      dst->numwords = neweltindex;\n-      free (dst->elts);\n-      dst->elts = newarray;\n-      dst->n_elts = newarraysize;\n-    }\n-  else\n-    {\n-      sbitmap_free (tempmask);\n-      free (newarray);\n-    }\n-\n-#ifdef EBITMAP_DEBUGGING\n-  {\n-    ebitmap_iterator ebi;\n-    unsigned int i;\n-\n-    for (i = 0; i <  dst->numwords; i++)\n-      gcc_assert (dst->elts[i] != 0);\n-\n-    EXECUTE_IF_SET_IN_EBITMAP (src1, 0, i, ebi)\n-      gcc_assert (bitmap_bit_p (dst, i));\n-\n-    EXECUTE_IF_SET_IN_EBITMAP (src2, 0, i, ebi)\n-      gcc_assert (bitmap_bit_p (dst, i));\n-  }\n-  sbitmap_verify_popcount (dst->wordmask);\n-  gcc_assert (changed == !bitmap_equal_p (dst, dstcopy));\n-  gcc_assert (sbitmap_popcount (dst->wordmask,\n-\t\t\t\tdst->wordmask->n_bits) == dst->numwords);\n-#endif\n-\n-  return changed;\n-}\n-\n-/* Perform the operation DST &= ~SRC.  Return true if any bit in DST\n-   has changed.  */\n-\n-bool\n-bitmap_and_compl_into (ebitmap dst, ebitmap src)\n-{\n-  bool changed = false;\n-  unsigned int i;\n-  unsigned int neweltindex = 0;\n-  unsigned int dsteltindex = 0;\n-  sbitmap_iterator sbi;\n-#ifdef EBITMAP_DEBUGGING\n-  ebitmap dstcopy = ebitmap_alloc (1);\n-  bitmap_copy (dstcopy, dst);\n-#endif\n-\n-  gcc_assert (dst != src);\n-  dst->cache = NULL;\n-  if (src->numwords == 0)\n-    return false;\n-\n-  EXECUTE_IF_SET_IN_BITMAP (dst->wordmask, 0, i, sbi)\n-    {\n-      bool srchasword;\n-\n-      srchasword = (i < src->wordmask->n_bits\n-\t\t    && bitmap_bit_p (src->wordmask, i));\n-\n-      if (srchasword)\n-\t{\n-\t  unsigned int srccount = sbitmap_popcount (src->wordmask, i);\n-\t  EBITMAP_ELT_TYPE tmpword = ebitmap_array_get (dst, dsteltindex);\n-\t  tmpword &= ~(ebitmap_array_get (src, srccount));\n-\t  if (!changed)\n-\t    changed |= ebitmap_array_get (dst, dsteltindex) != tmpword;\n-\t  dsteltindex++;\n-\t  if (tmpword != 0)\n-\t    {\n-\t      EBITMAP_ELT_TYPE *dstplace;\n-\t      dstplace = ebitmap_array_grow_get (dst, neweltindex++);\n-\t      *dstplace = tmpword;\n-\t    }\n-\t  else\n-\t    bitmap_clear_bit_with_popcount (dst->wordmask, i);\n-\t}\n-      else\n-\t{\n-\t  dsteltindex++;\n-\t  neweltindex++;\n-\t}\n-    }\n-#ifdef EBITMAP_DEBUGGING\n-  {\n-    unsigned int i;\n-    ebitmap_iterator ebi;\n-\n-    EXECUTE_IF_SET_IN_EBITMAP (dstcopy, 0, i, ebi)\n-      {\n-\tif (!bitmap_bit_p (src, i))\n-\t  gcc_assert (bitmap_bit_p (dst, i));\n-      }\n-\n-    for (i = 0; i <  dst->numwords; i++)\n-      gcc_assert (dst->elts[i] != 0);\n-\n-    gcc_assert (sbitmap_popcount (dst->wordmask,\n-\t\t\t\t  dst->wordmask->n_bits) == neweltindex);\n-    sbitmap_verify_popcount (dst->wordmask);\n-    gcc_assert (changed == !bitmap_equal_p (dst, dstcopy));\n-    gcc_assert (sbitmap_popcount (dst->wordmask,\n-\t\t\t\t  dst->wordmask->n_bits) == dst->numwords);\n-  }\n-#endif\n-  dst->numwords = neweltindex;\n-  /* sbitmap_popcount (dst->wordmask, -1); */\n-\n-  return changed;\n-}\n-\n-/* Perform the operation DST = SRC1 & ~SRC2.  Return true if any bit\n-   in DST has changed.  */\n-\n-bool\n-bitmap_and_compl (ebitmap dst, ebitmap src1, ebitmap src2)\n-{\n-  unsigned int src1size = src1->wordmask->n_bits;\n-  sbitmap_iterator sbi;\n-  unsigned int i;\n-  sbitmap tempmask;\n-  unsigned int neweltindex = 0;\n-  unsigned int src1eltindex = 0;\n-  bool changed = false;\n-  EBITMAP_ELT_TYPE *newarray;\n-  unsigned int newarraysize;\n-\n-  /* XXX: Optimize like the into version.  */\n-  dst->cache = NULL;\n-  tempmask = sbitmap_alloc_with_popcount (src1size);\n-  bitmap_clear (tempmask);\n-  bitmap_copy (tempmask, src1->wordmask);\n-\n-  newarraysize = src1->numwords;\n-  newarray = XNEWVEC (EBITMAP_ELT_TYPE, newarraysize);\n-\n-  EXECUTE_IF_SET_IN_BITMAP (src1->wordmask, 0, i, sbi)\n-    {\n-      bool src2hasword;\n-      EBITMAP_ELT_TYPE tmpword;\n-\n-      src2hasword = (i < src2->wordmask->n_bits\n-\t\t     && bitmap_bit_p (src2->wordmask, i));\n-\n-      if (src2hasword)\n-\t{\n-\t  unsigned int src2count = sbitmap_popcount (src2->wordmask, i);\n-\t  tmpword = ebitmap_array_get (src1, src1eltindex++)\n-\t            & ~(ebitmap_array_get (src2, src2count));\n-\t  if (tmpword)\n-\t    {\n-\t      newarray[neweltindex++] = tmpword;\n-\t    }\n-\t  else\n-\t    bitmap_clear_bit_with_popcount (tempmask, i);\n-\n-\t}\n-      else\n-\t{\n-\t  tmpword = ebitmap_array_get (src1, src1eltindex++);\n-\t  gcc_assert (tmpword != 0);\n-\t  newarray[neweltindex++] = tmpword;\n-\t}\n-\n-      if (i >= dst->wordmask->n_bits || !bitmap_bit_p (dst->wordmask, i))\n-\t{\n-\t  changed = true;\n-\t}\n-      else if (!changed)\n-\t{\n-\t  unsigned int count = sbitmap_popcount (dst->wordmask, i);\n-\t  changed |= ebitmap_array_get (dst, count) != tmpword;\n-\t}\n-    }\n-  if (changed)\n-    {\n-      sbitmap_free (dst->wordmask);\n-      dst->wordmask = tempmask;\n-      dst->numwords = neweltindex;\n-      free (dst->elts);\n-      dst->elts = newarray;\n-      dst->n_elts = newarraysize;\n-    }\n-  else\n-    {\n-      free (tempmask);\n-      free (newarray);\n-    }\n-#ifdef EBITMAP_DEBUGGING\n-  {\n-    unsigned int i;\n-    ebitmap_iterator ebi;\n-\n-    EXECUTE_IF_SET_IN_EBITMAP (src1, 0, i, ebi)\n-      {\n-\tif (!bitmap_bit_p (src2, i))\n-\t  gcc_assert (bitmap_bit_p (dst, i));\n-      }\n-  for (i = 0; i <  dst->numwords; i++)\n-    gcc_assert (dst->elts[i] != 0);\n-\n-  sbitmap_verify_popcount (dst->wordmask);\n-  gcc_assert (sbitmap_popcount (dst->wordmask,\n-\t\t\t\tdst->wordmask->n_bits) == dst->numwords);\n-  }\n-#endif\n-  return changed;\n-}\n-\n-/* Perform the operation DST = A | (B & ~C).  */\n-\n-bool\n-bitmap_ior_and_compl (ebitmap dst, ebitmap a, ebitmap b, ebitmap c)\n-{\n-  bool changed;\n-  ebitmap temp = ebitmap_alloc (1);\n-#ifdef EBITMAP_DEBUGGING\n-  ebitmap dstcopy = ebitmap_alloc (1);\n-  bitmap_copy (dstcopy, dst);\n-#endif\n-\n-  dst->cache = NULL;\n-  bitmap_and_compl (temp, b, c);\n-  changed = bitmap_ior (dst, a, temp);\n-#ifdef EBITMAP_DEBUGGING\n-  {\n-    ebitmap_iterator ebi;\n-    unsigned int i;\n-\n-    EXECUTE_IF_SET_IN_EBITMAP (a, 0, i, ebi)\n-      gcc_assert (bitmap_bit_p (dst, i));\n-\n-    EXECUTE_IF_SET_IN_EBITMAP (b, 0, i, ebi)\n-      if (!bitmap_bit_p (c, i))\n-\tgcc_assert (bitmap_bit_p (dst, i));\n-    gcc_assert (changed == !bitmap_equal_p (dst, dstcopy));\n-  }\n-#endif\n-  ebitmap_free (temp);\n-\n-  return changed;\n-}\n-\n-/* Return true if ebitmap DST is equal to ebitmap SRC.  */\n-\n-bool\n-bitmap_equal_p (ebitmap dst, ebitmap src)\n-{\n-  unsigned int which = MIN (dst->wordmask->size, src->wordmask->size);\n-\n-  if (dst->numwords != src->numwords)\n-    return false;\n-\n-  /* bitmap_equal_p compares up to the size of the first argument, so\n-     if the two sbitmaps are not equally sized, we need to pass the\n-     smaller one as the first argument, or it will crash.  */\n-  if (which == dst->wordmask->size\n-      && !bitmap_equal_p (dst->wordmask, src->wordmask))\n-    return false;\n-  else if (which == src->wordmask->size\n-\t   && !bitmap_equal_p (src->wordmask, dst->wordmask))\n-    return false;\n-\n-  return memcmp (dst->elts, src->elts,\n-\t\t dst->numwords * sizeof (EBITMAP_ELT_TYPE)) == 0;\n-  return true;\n-}"}, {"sha": "fef3154baf42064f7c4e358fc9fe78c91b2adf21", "filename": "gcc/ebitmap.h", "status": "removed", "additions": 0, "deletions": 175, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c291b2adc6f25d897928c79f431d987eb74e4bc5/gcc%2Febitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c291b2adc6f25d897928c79f431d987eb74e4bc5/gcc%2Febitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Febitmap.h?ref=c291b2adc6f25d897928c79f431d987eb74e4bc5", "patch": "@@ -1,175 +0,0 @@\n-/* Sparse array based bitmaps.\n-   Copyright (C) 2007, 2008, 2009 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#ifndef GCC_EBITMAP_H\n-#define GCC_EBITMAP_H\n-\n-#include \"sbitmap.h\"\n-\n-#define EBITMAP_ELT_BITS ((unsigned) HOST_BITS_PER_WIDEST_FAST_INT)\n-#define EBITMAP_ELT_TYPE unsigned HOST_WIDEST_FAST_INT\n-\n-typedef struct ebitmap_def\n-{\n-  unsigned int n_elts;\t\t/* number of elements in the array.  */\n-  sbitmap wordmask;\t\t/* wordmask saying which words are\n-\t\t\t\t   nonzero.  */\n-  unsigned int numwords;\t/* number of nonzero words.  */\n-  unsigned int cacheindex;\t/* which word cache is.  */\n-  EBITMAP_ELT_TYPE *elts;\t/* nonzero element array.  */\n-  EBITMAP_ELT_TYPE *cache;\t/* last tested element, or NULL.  */\n-} *ebitmap;\n-\n-\n-inline bool bitmap_empty_p (ebitmap map)\n-{\n-  return map->numwords == 0;\n-}\n-\n-#define ebitmap_free(MAP)  (free((MAP)->elts), \\\n-\t\t\t    sbitmap_free ((MAP)->wordmask),\t\\\n-\t\t\t    free((MAP)))\n-\n-extern void bitmap_set_bit (ebitmap, unsigned int);\n-extern void bitmap_clear_bit (ebitmap, unsigned int);\n-extern bool bitmap_bit_p (ebitmap, unsigned int);\n-extern void dump_bitmap (FILE *, ebitmap);\n-extern void dump_bitmap_file (FILE *, ebitmap);\n-extern void dump_bitmap_vector (FILE *, const char *, const char *, ebitmap *,\n-\t\t\t\tint);\n-extern ebitmap ebitmap_alloc (unsigned int);\n-extern ebitmap *ebitmap_vector_alloc (unsigned int, unsigned int);\n-extern void bitmap_copy (ebitmap, ebitmap);\n-extern void bitmap_and (ebitmap, ebitmap, ebitmap);\n-extern void bitmap_and_into (ebitmap, ebitmap);\n-extern bool bitmap_and_compl (ebitmap, ebitmap, ebitmap);\n-extern bool bitmap_and_compl_into (ebitmap, ebitmap);\n-extern bool bitmap_ior_into (ebitmap, ebitmap);\n-extern bool bitmap_ior (ebitmap, ebitmap, ebitmap);\n-extern bool bitmap_ior_and_compl (ebitmap, ebitmap, ebitmap, ebitmap);\n-extern bool bitmap_ior_and_compl_into (ebitmap, ebitmap, ebitmap);\n-extern bool bitmap_equal_p (ebitmap, ebitmap);\n-extern void bitmap_clear (ebitmap);\n-extern int bitmap_last_set_bit (ebitmap);\n-extern void debug_bitmap (ebitmap);\n-extern unsigned long bitmap_popcount(ebitmap, unsigned long);\n-\n-/* The iterator for ebitmap.  */\n-typedef struct {\n-  /* The pointer to the first word of the bitmap.  */\n-  EBITMAP_ELT_TYPE *ptr;\n-\n-  /* Element number inside ptr that we are at.  */\n-  unsigned int eltnum;\n-\n-  /* The size of the bitmap.  */\n-  unsigned int size;\n-\n-  /* Current bit index.  */\n-  unsigned int bit_num;\n-\n-  /* The words currently visited.  */\n-  EBITMAP_ELT_TYPE word;\n-\n-  /* The word mask iterator.  */\n-  sbitmap_iterator maskiter;\n-} ebitmap_iterator;\n-\n-static inline void\n-ebitmap_iter_init (ebitmap_iterator *i, ebitmap bmp, unsigned int min)\n-{\n-  unsigned unused;\n-  bmp_iter_set_init (&i->maskiter, bmp->wordmask,\n-\t\t     min / EBITMAP_ELT_BITS, &unused);\n-  i->size = bmp->numwords;\n-  if (i->size == 0)\n-    {\n-      i->ptr = NULL;\n-      i->eltnum = 0;\n-      i->bit_num = 0;\n-      i->word = 0;\n-      return;\n-    }\n-  i->ptr = bmp->elts;\n-  i->bit_num = min;\n-  i->eltnum = 0;\n-\n-  if ((min / EBITMAP_ELT_BITS) >= bmp->wordmask->n_bits)\n-    {\n-      i->word = 0;\n-    }\n-  else\n-    {\n-      if (bitmap_bit_p (bmp->wordmask, min / EBITMAP_ELT_BITS) == 0)\n-\ti->word = 0;\n-      else\n-\t{\n-\t  unsigned int wordindex = min / EBITMAP_ELT_BITS;\n-\t  unsigned int count = sbitmap_popcount (bmp->wordmask, wordindex);\n-\t  i->word = i->ptr[count] >> (i->bit_num % (unsigned int)EBITMAP_ELT_BITS);\n-\t  i->eltnum = count + 1;\n-\t}\n-    }\n-}\n-\n-static inline bool\n-ebitmap_iter_cond (ebitmap_iterator *i, unsigned int *n)\n-{\n-  unsigned int ourn = 0;\n-  unsigned unused;\n-\n-  if (i->size == 0)\n-    return false;\n-\n-  if (i->word == 0)\n-    {\n-      bmp_iter_next (&i->maskiter, &unused);\n-      if (!bmp_iter_set (&i->maskiter, &ourn))\n-\treturn false;\n-      i->bit_num = ourn * EBITMAP_ELT_BITS;\n-      i->word = i->ptr[i->eltnum++];\n-    }\n-\n-  /* Skip bits that are zero.  */\n-\n-  for (; (i->word & 1) == 0; i->word >>= 1)\n-    i->bit_num++;\n-\n-  *n = i->bit_num;\n-  return true;\n-}\n-\n-static inline void\n-ebitmap_iter_next (ebitmap_iterator *i)\n-{\n-  i->word >>= 1;\n-  i->bit_num++;\n-}\n-\n-/* Loop over all elements of EBITMAP, starting with MIN.  In each\n-   iteration, N is set to the index of the bit being visited.  ITER is\n-   an instance of ebitmap_iterator used to iterate the bitmap.  */\n-\n-#define EXECUTE_IF_SET_IN_EBITMAP(EBITMAP, MIN, N, ITER)\t\\\n-  for (ebitmap_iter_init (&(ITER), (EBITMAP), (MIN));\t\t\\\n-       ebitmap_iter_cond (&(ITER), &(N));\t\t\t\\\n-       ebitmap_iter_next (&(ITER)))\n-\n-\n-#endif /* ! GCC_EBITMAP_H */"}, {"sha": "b50c82e5e91b1c11d865b912d5d11f08fdc5a4b5", "filename": "gcc/sbitmap.c", "status": "modified", "additions": 14, "deletions": 114, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd39ce63cb4ce431fbb4c668ad14e1c2335e76a/gcc%2Fsbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd39ce63cb4ce431fbb4c668ad14e1c2335e76a/gcc%2Fsbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.c?ref=5fd39ce63cb4ce431fbb4c668ad14e1c2335e76a", "patch": "@@ -44,6 +44,13 @@ static unsigned long sbitmap_elt_popcount (SBITMAP_ELT_TYPE);\n typedef SBITMAP_ELT_TYPE *sbitmap_ptr;\n typedef const SBITMAP_ELT_TYPE *const_sbitmap_ptr;\n \n+/* Return the size in bytes of a bitmap MAP.  */\n+\n+static inline unsigned int sbitmap_size_bytes (const_sbitmap map)\n+{\n+   return map->size * sizeof (SBITMAP_ELT_TYPE);\n+}\n+\n /* This macro controls debugging that is as expensive as the\n    operations it verifies.  */\n \n@@ -53,7 +60,7 @@ typedef const SBITMAP_ELT_TYPE *const_sbitmap_ptr;\n /* Verify the population count of sbitmap A matches the cached value,\n    if there is a cached value. */\n \n-void\n+static void\n sbitmap_verify_popcount (const_sbitmap a)\n {\n   unsigned ix;\n@@ -111,7 +118,7 @@ sbitmap_resize (sbitmap bmap, unsigned int n_elms, int def)\n \n   size = SBITMAP_SET_SIZE (n_elms);\n   bytes = size * sizeof (SBITMAP_ELT_TYPE);\n-  if (bytes > SBITMAP_SIZE_BYTES (bmap))\n+  if (bytes > sbitmap_size_bytes (bmap))\n     {\n       amt = (sizeof (struct simple_bitmap_def)\n \t    + bytes - sizeof (SBITMAP_ELT_TYPE));\n@@ -125,7 +132,7 @@ sbitmap_resize (sbitmap bmap, unsigned int n_elms, int def)\n       if (def)\n \t{\n \t  memset (bmap->elms + bmap->size, -1,\n-\t\t  bytes - SBITMAP_SIZE_BYTES (bmap));\n+\t\t  bytes - sbitmap_size_bytes (bmap));\n \n \t  /* Set the new bits if the original last element.  */\n \t  last_bit = bmap->n_bits % SBITMAP_ELT_BITS;\n@@ -142,7 +149,7 @@ sbitmap_resize (sbitmap bmap, unsigned int n_elms, int def)\n       else\n \t{\n \t  memset (bmap->elms + bmap->size, 0,\n-\t\t  bytes - SBITMAP_SIZE_BYTES (bmap));\n+\t\t  bytes - sbitmap_size_bytes (bmap));\n \t  if (bmap->popcount)\n \t    memset (bmap->popcount + bmap->size, 0,\n \t\t    (size * sizeof (unsigned char))\n@@ -181,7 +188,7 @@ sbitmap_realloc (sbitmap src, unsigned int n_elms)\n   amt = (sizeof (struct simple_bitmap_def)\n \t + bytes - sizeof (SBITMAP_ELT_TYPE));\n \n-  if (SBITMAP_SIZE_BYTES (src)  >= bytes)\n+  if (sbitmap_size_bytes (src)  >= bytes)\n     {\n       src->n_bits = n_elms;\n       return src;\n@@ -245,16 +252,6 @@ bitmap_copy (sbitmap dst, const_sbitmap src)\n     memcpy (dst->popcount, src->popcount, sizeof (unsigned char) * dst->size);\n }\n \n-/* Copy the first N elements of sbitmap SRC to DST.  */\n-\n-void\n-bitmap_copy_n (sbitmap dst, const_sbitmap src, unsigned int n)\n-{\n-  memcpy (dst->elms, src->elms, sizeof (SBITMAP_ELT_TYPE) * n);\n-  if (dst->popcount)\n-    memcpy (dst->popcount, src->popcount, sizeof (unsigned char) * n);\n-}\n-\n /* Determine if a == b.  */\n int\n bitmap_equal_p (const_sbitmap a, const_sbitmap b)\n@@ -275,63 +272,13 @@ bitmap_empty_p (const_sbitmap bmap)\n   return true;\n }\n \n-/* Return false if any of the N bits are set in MAP starting at\n-   START.  */\n-\n-bool\n-bitmap_range_empty_p (const_sbitmap bmap, unsigned int start, unsigned int n)\n-{\n-  unsigned int i = start / SBITMAP_ELT_BITS;\n-  SBITMAP_ELT_TYPE elm;\n-  unsigned int shift = start % SBITMAP_ELT_BITS;\n-\n-  gcc_assert (bmap->n_bits >= start + n);\n-\n-  elm = bmap->elms[i];\n-  elm = elm >> shift;\n-\n-  if (shift + n <= SBITMAP_ELT_BITS)\n-    {\n-      /* The bits are totally contained in a single element.  */\n-      if (shift + n < SBITMAP_ELT_BITS)\n-        elm &= ((1 << n) - 1);\n-      return (elm == 0);\n-    }\n-\n-  if (elm)\n-    return false;\n-\n-  n -= SBITMAP_ELT_BITS - shift;\n-  i++;\n-\n-  /* Deal with full elts.  */\n-  while (n >= SBITMAP_ELT_BITS)\n-    {\n-      if (bmap->elms[i])\n-\treturn false;\n-      i++;\n-      n -= SBITMAP_ELT_BITS;\n-    }\n-\n-  /* The leftover bits.  */\n-  if (n)\n-    {\n-      elm = bmap->elms[i];\n-      elm &= ((1 << n) - 1);\n-      return (elm == 0);\n-    }\n-\n-  return true;\n-}\n-\n-\n \n /* Zero all elements in a bitmap.  */\n \n void\n bitmap_clear (sbitmap bmap)\n {\n-  memset (bmap->elms, 0, SBITMAP_SIZE_BYTES (bmap));\n+  memset (bmap->elms, 0, sbitmap_size_bytes (bmap));\n   if (bmap->popcount)\n     memset (bmap->popcount, 0, bmap->size * sizeof (unsigned char));\n }\n@@ -343,7 +290,7 @@ bitmap_ones (sbitmap bmap)\n {\n   unsigned int last_bit;\n \n-  memset (bmap->elms, -1, SBITMAP_SIZE_BYTES (bmap));\n+  memset (bmap->elms, -1, sbitmap_size_bytes (bmap));\n   if (bmap->popcount)\n     memset (bmap->popcount, -1, bmap->size * sizeof (unsigned char));\n \n@@ -790,50 +737,3 @@ sbitmap_elt_popcount (SBITMAP_ELT_TYPE a)\n   return ret;\n }\n #endif\n-\n-/* Count the number of bits in SBITMAP a, up to bit MAXBIT.  */\n-\n-unsigned long\n-sbitmap_popcount (const_sbitmap a, unsigned long maxbit)\n-{\n-  unsigned long count = 0;\n-  unsigned ix;\n-  unsigned int lastword;\n-\n-  if (maxbit == 0)\n-    return 0;\n-\n-  if (maxbit >= a->n_bits)\n-    maxbit = a->n_bits;\n-\n-  /* Count the bits in the full word.  */\n-  lastword = MIN (a->size, SBITMAP_SET_SIZE (maxbit + 1) - 1);\n-  for (ix = 0; ix < lastword; ix++)\n-    {\n-      if (a->popcount)\n-\t{\n-\t  count += a->popcount[ix];\n-#ifdef BITMAP_DEBUGGING\n-\t  gcc_assert (a->popcount[ix] == do_popcount (a->elms[ix]));\n-#endif\n-\t}\n-      else\n-\tcount += do_popcount (a->elms[ix]);\n-    }\n-\n-  /* Count the remaining bits.  */\n-  if (lastword < a->size)\n-    {\n-      unsigned int bitindex;\n-      SBITMAP_ELT_TYPE theword = a->elms[lastword];\n-\n-      bitindex = maxbit % SBITMAP_ELT_BITS;\n-      if (bitindex != 0)\n-\t{\n-\t  theword &= (SBITMAP_ELT_TYPE)-1 >> (SBITMAP_ELT_BITS - bitindex);\n-\t  count += do_popcount (theword);\n-\t}\n-    }\n-  return count;\n-}\n-"}, {"sha": "dce22d0faba1a995a0ae1edb2d67a35913eb6e0f", "filename": "gcc/sbitmap.h", "status": "modified", "additions": 1, "deletions": 34, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd39ce63cb4ce431fbb4c668ad14e1c2335e76a/gcc%2Fsbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd39ce63cb4ce431fbb4c668ad14e1c2335e76a/gcc%2Fsbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.h?ref=5fd39ce63cb4ce431fbb4c668ad14e1c2335e76a", "patch": "@@ -42,11 +42,10 @@ along with GCC; see the file COPYING3.  If not see\n    the size of the set universe:\n \n      * clear\t\t\t: bitmap_clear\n-     * cardinality\t\t: sbitmap_popcount\n      * choose_one\t\t: bitmap_first_set_bit /\n \t\t\t\t  bitmap_last_set_bit\n      * forall\t\t\t: EXECUTE_IF_SET_IN_BITMAP\n-     * set_copy\t\t\t: bitmap_copy / bitmap_copy_n\n+     * set_copy\t\t\t: bitmap_copy\n      * set_intersection\t\t: bitmap_and\n      * set_union\t\t: bitmap_ior\n      * set_difference\t\t: bitmap_and_compl\n@@ -93,7 +92,6 @@ struct simple_bitmap_def\n \n /* Return the set size needed for N elements.  */\n #define SBITMAP_SET_SIZE(N) (((N) + SBITMAP_ELT_BITS - 1) / SBITMAP_ELT_BITS)\n-#define SBITMAP_SIZE_BYTES(BITMAP) ((BITMAP)->size * sizeof (SBITMAP_ELT_TYPE))\n \n /* Return the number of bits in BITMAP.  */\n #define SBITMAP_SIZE(BITMAP) ((BITMAP)->n_bits)\n@@ -117,20 +115,6 @@ bitmap_set_bit (sbitmap map, int bitno)\n     |= (SBITMAP_ELT_TYPE) 1 << (bitno) % SBITMAP_ELT_BITS;\n }\n \n-/* Like bitmap_set_bit, but updates population count.  */\n-\n-static inline void\n-bitmap_set_bit_with_popcount (sbitmap map, int bitno)\n-{\n-  bool oldbit;\n-  gcc_checking_assert (map->popcount);\n-  oldbit = bitmap_bit_p (map, bitno);\n-  if (!oldbit)\n-    map->popcount[bitno / SBITMAP_ELT_BITS]++;\n-  map->elms[bitno / SBITMAP_ELT_BITS]\n-    |= (SBITMAP_ELT_TYPE) 1 << (bitno) % SBITMAP_ELT_BITS;\n-}\n-\n /* Reset bit number BITNO in the sbitmap MAP.  */\n \n static inline void\n@@ -141,20 +125,6 @@ bitmap_clear_bit (sbitmap map, int bitno)\n     &= ~((SBITMAP_ELT_TYPE) 1 << (bitno) % SBITMAP_ELT_BITS);\n }\n \n-/* Like bitmap_clear_bit, but updates population count.  */\n-\n-static inline void\n-bitmap_clear_bit_with_popcount (sbitmap map, int bitno)\n-{\n-  bool oldbit;\n-  gcc_checking_assert (map->popcount);\n-  oldbit = bitmap_bit_p (map, bitno);\n-  if (oldbit)\n-    map->popcount[bitno / SBITMAP_ELT_BITS]--;\n-  map->elms[bitno / SBITMAP_ELT_BITS]\n-    &= ~((SBITMAP_ELT_TYPE) 1 << (bitno) % SBITMAP_ELT_BITS);\n-}\n-\n /* The iterator for sbitmap.  */\n typedef struct {\n   /* The pointer to the first word of the bitmap.  */\n@@ -261,10 +231,8 @@ extern sbitmap sbitmap_alloc_with_popcount (unsigned int);\n extern sbitmap *sbitmap_vector_alloc (unsigned int, unsigned int);\n extern sbitmap sbitmap_resize (sbitmap, unsigned int, int);\n extern void bitmap_copy (sbitmap, const_sbitmap);\n-extern void bitmap_copy_n (sbitmap, const_sbitmap, unsigned int);\n extern int bitmap_equal_p (const_sbitmap, const_sbitmap);\n extern bool bitmap_empty_p (const_sbitmap);\n-extern bool bitmap_range_empty_p (const_sbitmap, unsigned int, unsigned int);\n extern void bitmap_clear (sbitmap);\n extern void bitmap_ones (sbitmap);\n extern void bitmap_vector_clear (sbitmap *, unsigned int);\n@@ -290,5 +258,4 @@ extern int bitmap_last_set_bit (const_sbitmap);\n extern void debug_bitmap (const_sbitmap);\n extern sbitmap sbitmap_realloc (sbitmap, unsigned int);\n extern unsigned long sbitmap_popcount (const_sbitmap, unsigned long);\n-extern void sbitmap_verify_popcount (const_sbitmap);\n #endif /* ! GCC_SBITMAP_H */"}]}