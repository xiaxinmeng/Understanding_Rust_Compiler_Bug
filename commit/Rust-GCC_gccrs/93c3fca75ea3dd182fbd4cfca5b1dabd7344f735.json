{"sha": "93c3fca75ea3dd182fbd4cfca5b1dabd7344f735", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTNjM2ZjYTc1ZWEzZGQxODJmYmQ0Y2ZjYTViMWRhYmQ3MzQ0ZjczNQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-06-19T10:59:04Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-06-19T10:59:04Z"}, "message": "[multiple changes]\n\n2009-06-19  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* einfo.ads (Handling of Type'Size Values): Fix Object_Size values.\n\n2009-06-19  Robert Dewar  <dewar@adacore.com>\n\n\t* a-nudira.adb (Need_64): Handle negative ranges and also dynamic\n\tranges\n\n\t* checks.adb (Determine_Range): Move the test for generic types later.\n\n\t* sem_eval.adb (Compile_Time_Compare): Improve circuitry to catch more\n\tcases.\n\t(Eval_Relational_Op): Fold more cases including string compares\n\n\t* sem_util.ads, sem_util.adb (References_Generic_Formal_Type): New\n\tfunction.\n\nFrom-SVN: r148697", "tree": {"sha": "007f417d2cffc875792dc7dd354090911831687c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/007f417d2cffc875792dc7dd354090911831687c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93c3fca75ea3dd182fbd4cfca5b1dabd7344f735", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93c3fca75ea3dd182fbd4cfca5b1dabd7344f735", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93c3fca75ea3dd182fbd4cfca5b1dabd7344f735", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93c3fca75ea3dd182fbd4cfca5b1dabd7344f735/comments", "author": null, "committer": null, "parents": [{"sha": "e29e24831601dbcc701626073daca9054ac1edad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e29e24831601dbcc701626073daca9054ac1edad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e29e24831601dbcc701626073daca9054ac1edad"}], "stats": {"total": 469, "additions": 339, "deletions": 130}, "files": [{"sha": "8781413a3055137d02dd9b757e455f1f555920d3", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c3fca75ea3dd182fbd4cfca5b1dabd7344f735/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c3fca75ea3dd182fbd4cfca5b1dabd7344f735/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=93c3fca75ea3dd182fbd4cfca5b1dabd7344f735", "patch": "@@ -1,3 +1,21 @@\n+2009-06-19  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* einfo.ads (Handling of Type'Size Values): Fix Object_Size values.\n+\n+2009-06-19  Robert Dewar  <dewar@adacore.com>\n+\n+\t* a-nudira.adb (Need_64): Handle negative ranges and also dynamic\n+\tranges\n+\n+\t* checks.adb (Determine_Range): Move the test for generic types later.\n+\n+\t* sem_eval.adb (Compile_Time_Compare): Improve circuitry to catch more\n+\tcases.\n+\t(Eval_Relational_Op): Fold more cases including string compares\n+\n+\t* sem_util.ads, sem_util.adb (References_Generic_Formal_Type): New\n+\tfunction.\n+\n 2009-06-19  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_type.ads, sem_ch12.adb: Minor reformatting"}, {"sha": "3a8819b6aaa7b78d651a8ec6577ba7e3ca2f68f3", "filename": "gcc/ada/a-nudira.adb", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c3fca75ea3dd182fbd4cfca5b1dabd7344f735/gcc%2Fada%2Fa-nudira.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c3fca75ea3dd182fbd4cfca5b1dabd7344f735/gcc%2Fada%2Fa-nudira.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-nudira.adb?ref=93c3fca75ea3dd182fbd4cfca5b1dabd7344f735", "patch": "@@ -51,11 +51,24 @@ package body Ada.Numerics.Discrete_Random is\n \n    type Pointer is access all State;\n \n-   Need_64 : constant Boolean := Rst'Pos (Rst'Last) > Int'Last;\n+   Need_64 : constant Boolean := Rst'Pos (Rst'Last) > 2**31 - 1\n+                                   or else\n+                                 Rst'Pos (Rst'First) < 2**31;\n    --  Set if we need more than 32 bits in the result. In practice we will\n    --  only use the meaningful 48 bits of any 64 bit number generated, since\n    --  if more than 48 bits are required, we split the computation into two\n    --  separate parts, since the algorithm does not behave above 48 bits.\n+   --\n+   --  Note: the right hand side used to be Int'Last, but that won't work\n+   --  since it means that if Rst is a dynamic subtype, the comparison is\n+   --  evaluated at run time in type Int, which is too small. In practice\n+   --  the use of dynamic bounds is rare, and this constant will always\n+   --  be evaluated at compile time in an instance.\n+   --\n+   --  This still is not quite right for dynamic subtypes of 64-bit modular\n+   --  types where the upper bound can exceed the upper bound of universal\n+   --  integer. Not clear how to do this with a nice static expression ???\n+   --  Might have to introduce a special Type'First_In_32_Bits attribute!\n \n    -----------------------\n    -- Local Subprograms --"}, {"sha": "4cfcb8e913569c39f84e4e46a08b845633e767b2", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c3fca75ea3dd182fbd4cfca5b1dabd7344f735/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c3fca75ea3dd182fbd4cfca5b1dabd7344f735/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=93c3fca75ea3dd182fbd4cfca5b1dabd7344f735", "patch": "@@ -3065,7 +3065,7 @@ package body Checks is\n       function OK_Operands return Boolean;\n       --  Used for binary operators. Determines the ranges of the left and\n       --  right operands, and if they are both OK, returns True, and puts\n-      --  the results in Lo_Right, Hi_Right, Lo_Left, Hi_Left\n+      --  the results in Lo_Right, Hi_Right, Lo_Left, Hi_Left.\n \n       -----------------\n       -- OK_Operands --\n@@ -3108,10 +3108,6 @@ package body Checks is\n         --  ignore if error posted on the reference node.\n \n         or else Error_Posted (N) or else Error_Posted (Typ)\n-\n-        --  Ignore generic type, since range is indeed bogus\n-\n-        or else Is_Generic_Type (Typ)\n       then\n          OK := False;\n          return;\n@@ -3148,6 +3144,15 @@ package body Checks is\n       --  overflow situation, which is a separate check, we are talking here\n       --  only about the expression value).\n \n+      --  First a check, never try to find the bounds of a generic type, since\n+      --  these bounds are always junk values, and it is only valid to look at\n+      --  the bounds in an instance.\n+\n+      if Is_Generic_Type (Typ) then\n+         OK := False;\n+         return;\n+      end if;\n+\n       --  First step, change to use base type unless we know the value is valid\n \n       if (Is_Entity_Name (N) and then Is_Known_Valid (Entity (N)))"}, {"sha": "50c1c7b1bbc19a46a89c35187bf0f52ee61f34fa", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c3fca75ea3dd182fbd4cfca5b1dabd7344f735/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c3fca75ea3dd182fbd4cfca5b1dabd7344f735/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=93c3fca75ea3dd182fbd4cfca5b1dabd7344f735", "patch": "@@ -214,13 +214,13 @@ package Einfo is\n --     type x1 is range 0..5;                      8               3\n \n --     type x2 is range 0..5;\n---     for x2'size use 12;                        12              12\n+--     for x2'size use 12;                        16              12\n \n---     subtype x3 is x2 range 0 .. 3;             12               2\n+--     subtype x3 is x2 range 0 .. 3;             16               2\n \n --     subtype x4 is x2'base range 0 .. 10;        8               4\n \n---     subtype x5 is x2 range 0 .. dynamic;       12              (7)\n+--     subtype x5 is x2 range 0 .. dynamic;       16              (7)\n \n --     subtype x6 is x2'base range 0 .. dynamic;   8              (7)\n \n@@ -2081,9 +2081,9 @@ package Einfo is\n --       (generic function, generic subprogram), False for all other entities.\n \n --    Is_Generic_Type (Flag13)\n---       Present in all types and subtypes. Set for types which are generic\n---       formal types. Such types have an Ekind that corresponds to their\n---       classification, so the Ekind cannot be used to identify generic types.\n+--       Present in all entities. Set for types which are generic formal types.\n+--       Such types have an Ekind that corresponds to their classification, so\n+--       the Ekind cannot be used to identify generic types.\n \n --    Is_Generic_Unit (synthesized)\n --       Applies to all entities. Yields True for a generic unit (generic\n@@ -4503,6 +4503,7 @@ package Einfo is\n    --    Is_First_Subtype                    (Flag70)\n    --    Is_Formal_Subprogram                (Flag111)\n    --    Is_Generic_Instance                 (Flag130)\n+   --    Is_Generic_Type                     (Flag13)\n    --    Is_Hidden                           (Flag57)\n    --    Is_Hidden_Open_Scope                (Flag171)\n    --    Is_Immediately_Visible              (Flag7)\n@@ -4609,7 +4610,6 @@ package Einfo is\n    --    Is_Eliminated                       (Flag124)\n    --    Is_Frozen                           (Flag4)\n    --    Is_Generic_Actual_Type              (Flag94)\n-   --    Is_Generic_Type                     (Flag13)\n    --    Is_Protected_Interface              (Flag198)\n    --    Is_RACW_Stub_Type                   (Flag244)\n    --    Is_Synchronized_Interface           (Flag199)"}, {"sha": "19abf4b3672a5b159092f14f37e9741d60036c3a", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 241, "deletions": 117, "changes": 358, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c3fca75ea3dd182fbd4cfca5b1dabd7344f735/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c3fca75ea3dd182fbd4cfca5b1dabd7344f735/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=93c3fca75ea3dd182fbd4cfca5b1dabd7344f735", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -194,6 +194,12 @@ package body Sem_Eval is\n    --  call to Check_Non_Static_Context on the operand. If Fold is False on\n    --  return, then all processing is complete, and the caller should\n    --  return, since there is nothing else to do.\n+   --\n+   --  If Stat is set True on return, then Is_Static_Expression is also set\n+   --  true in node N. There are some cases where this is over-enthusiastic,\n+   --  e.g. in the two operand case below, for string comaprison, the result\n+   --  is not static even though the two operands are static. In such cases,\n+   --  the caller must reset the Is_Static_Expression flag in N.\n \n    procedure Test_Expression_Is_Foldable\n      (N    : Node_Id;\n@@ -393,8 +399,8 @@ package body Sem_Eval is\n       Assume_Valid : Boolean;\n       Rec          : Boolean := False) return Compare_Result\n    is\n-      Ltyp : Entity_Id := Etype (L);\n-      Rtyp : Entity_Id := Etype (R);\n+      Ltyp : Entity_Id := Underlying_Type (Etype (L));\n+      Rtyp : Entity_Id := Underlying_Type (Etype (R));\n       --  These get reset to the base type for the case of entities where\n       --  Is_Known_Valid is not set. This takes care of handling possible\n       --  invalid representations using the value of the base type, in\n@@ -683,23 +689,46 @@ package body Sem_Eval is\n       if L = R then\n          return EQ;\n \n-      --  If expressions have no types, then do not attempt to determine\n-      --  if they are the same, since something funny is going on. One\n-      --  case in which this happens is during generic template analysis,\n-      --  when bounds are not fully analyzed.\n+      --  If expressions have no types, then do not attempt to determine if\n+      --  they are the same, since something funny is going on. One case in\n+      --  which this happens is during generic template analysis, when bounds\n+      --  are not fully analyzed.\n \n       elsif No (Ltyp) or else No (Rtyp) then\n          return Unknown;\n \n-      --  We only attempt compile time analysis for scalar values, and\n-      --  not for packed arrays represented as modular types, where the\n-      --  semantics of comparison is quite different.\n+      --  We do not attempt comparisons for packed arrays arrays represented as\n+      --  modular types, where the semantics of comparison is quite different.\n \n-      elsif not Is_Scalar_Type (Ltyp)\n-        or else Is_Packed_Array_Type (Ltyp)\n+      elsif Is_Packed_Array_Type (Ltyp)\n+        and then Is_Modular_Integer_Type (Ltyp)\n       then\n          return Unknown;\n \n+      --  For access types, the only time we know the result at compile time\n+      --  (apart from identical operands, which we handled already, is if we\n+      --  know one operand is null and the other is not, or both operands are\n+      --  known null.\n+\n+      elsif Is_Access_Type (Ltyp) then\n+         if Known_Null (L) then\n+            if Known_Null (R) then\n+               return EQ;\n+            elsif Known_Non_Null (R) then\n+               return NE;\n+            else\n+               return Unknown;\n+            end if;\n+\n+         elsif Known_Non_Null (L)\n+           and then Known_Null (R)\n+         then\n+            return NE;\n+\n+         else\n+            return Unknown;\n+         end if;\n+\n       --  Case where comparison involves two compile time known values\n \n       elsif Compile_Time_Known_Value (L)\n@@ -728,8 +757,42 @@ package body Sem_Eval is\n                end if;\n             end;\n \n-         --  For the integer case we know exactly (note that this includes the\n-         --  fixed-point case, where we know the run time integer values now)\n+         --  For string types, we have two string literals and we proceed to\n+         --  compare them using the Ada style dictionary string comparison.\n+\n+         elsif not Is_Scalar_Type (Ltyp) then\n+            declare\n+               Lstring : constant String_Id := Strval (Expr_Value_S (L));\n+               Rstring : constant String_Id := Strval (Expr_Value_S (R));\n+               Llen    : constant Nat       := String_Length (Lstring);\n+               Rlen    : constant Nat       := String_Length (Rstring);\n+\n+            begin\n+               for J in 1 .. Nat'Min (Llen, Rlen) loop\n+                  declare\n+                     LC : constant Char_Code := Get_String_Char (Lstring, J);\n+                     RC : constant Char_Code := Get_String_Char (Rstring, J);\n+                  begin\n+                     if LC < RC then\n+                        return LT;\n+                     elsif LC > RC then\n+                        return GT;\n+                     end if;\n+                  end;\n+               end loop;\n+\n+               if Llen < Rlen then\n+                  return LT;\n+               elsif Llen > Rlen then\n+                  return GT;\n+               else\n+                  return EQ;\n+               end if;\n+            end;\n+\n+         --  For remaining scalar cases we know exactly (note that this does\n+         --  include the fixed-point case, where we know the run time integer\n+         --  values now)\n \n          else\n             declare\n@@ -754,12 +817,36 @@ package body Sem_Eval is\n       --  Cases where at least one operand is not known at compile time\n \n       else\n-         --  Remaining checks apply only for non-generic discrete types\n+         --  Remaining checks apply only for discrete types\n \n          if not Is_Discrete_Type (Ltyp)\n            or else not Is_Discrete_Type (Rtyp)\n-           or else Is_Generic_Type (Ltyp)\n-           or else Is_Generic_Type (Rtyp)\n+         then\n+            return Unknown;\n+         end if;\n+\n+         --  Defend against generic types, or actually any expressions that\n+         --  contain a reference to a generic type from within a generic\n+         --  template. We don't want to do any range analysis of such\n+         --  expressions for two reasons. First, the bounds of a generic type\n+         --  itself are junk and cannot be used for any kind of analysis.\n+         --  Second, we may have a case where the range at run time is indeed\n+         --  known, but we don't want to do compile time analysis in the\n+         --  template based on that range since in an instance the value may be\n+         --  static, and able to be elaborated without reference to the bounds\n+         --  of types involved. As an example, consider:\n+\n+         --     (F'Pos (F'Last) + 1) > Integer'Last\n+\n+         --  The expression on the left side of > is Universal_Integer and thus\n+         --  acquires the type Integer for evaluation at run time, and at run\n+         --  time it is true that this condition is always False, but within\n+         --  an instance F may be a type with a static range greater than the\n+         --  range of Integer, and the expression statically evaluates to True.\n+\n+         if References_Generic_Formal_Type (L)\n+              or else\n+            References_Generic_Formal_Type (R)\n          then\n             return Unknown;\n          end if;\n@@ -770,11 +857,11 @@ package body Sem_Eval is\n \n          if not Assume_Valid and then not Assume_No_Invalid_Values then\n             if Is_Entity_Name (L) and then not Is_Known_Valid (Entity (L)) then\n-               Ltyp := Base_Type (Ltyp);\n+               Ltyp := Underlying_Type (Base_Type (Ltyp));\n             end if;\n \n             if Is_Entity_Name (R) and then not Is_Known_Valid (Entity (R)) then\n-               Rtyp := Base_Type (Rtyp);\n+               Rtyp := Underlying_Type (Base_Type (Rtyp));\n             end if;\n          end if;\n \n@@ -821,54 +908,59 @@ package body Sem_Eval is\n          --  attempt this optimization with generic types, since the type\n          --  bounds may not be meaningful in this case.\n \n-         --  We are in danger of an  infinite recursion here. It does not seem\n+         --  We are in danger of an infinite recursion here. It does not seem\n          --  useful to go more than one level deep, so the parameter Rec is\n          --  used to protect ourselves against this infinite recursion.\n \n          if not Rec then\n \n             --  See if we can get a decisive check against one operand and\n             --  a bound of the other operand (four possible tests here).\n+            --  Note that we avoid testing junk bounds of a generic type.\n+\n+            if not Is_Generic_Type (Rtyp) then\n+               case Compile_Time_Compare (L, Type_Low_Bound (Rtyp),\n+                                          Discard'Access,\n+                                          Assume_Valid, Rec => True)\n+               is\n+                  when LT => return LT;\n+                  when LE => return LE;\n+                  when EQ => return LE;\n+                  when others => null;\n+               end case;\n \n-            case Compile_Time_Compare (L, Type_Low_Bound (Rtyp),\n-                                       Discard'Access,\n-                                       Assume_Valid, Rec => True)\n-            is\n-               when LT => return LT;\n-               when LE => return LE;\n-               when EQ => return LE;\n-               when others => null;\n-            end case;\n-\n-            case Compile_Time_Compare (L, Type_High_Bound (Rtyp),\n-                                       Discard'Access,\n-                                       Assume_Valid, Rec => True)\n-            is\n-               when GT => return GT;\n-               when GE => return GE;\n-               when EQ => return GE;\n-               when others => null;\n-            end case;\n+               case Compile_Time_Compare (L, Type_High_Bound (Rtyp),\n+                                          Discard'Access,\n+                                          Assume_Valid, Rec => True)\n+               is\n+                  when GT => return GT;\n+                  when GE => return GE;\n+                  when EQ => return GE;\n+                  when others => null;\n+               end case;\n+            end if;\n \n-            case Compile_Time_Compare (Type_Low_Bound (Ltyp), R,\n-                                       Discard'Access,\n-                                       Assume_Valid, Rec => True)\n-            is\n-               when GT => return GT;\n-               when GE => return GE;\n-               when EQ => return GE;\n-               when others => null;\n-            end case;\n+            if not Is_Generic_Type (Ltyp) then\n+               case Compile_Time_Compare (Type_Low_Bound (Ltyp), R,\n+                                          Discard'Access,\n+                                          Assume_Valid, Rec => True)\n+               is\n+                  when GT => return GT;\n+                  when GE => return GE;\n+                  when EQ => return GE;\n+                  when others => null;\n+               end case;\n \n-            case Compile_Time_Compare (Type_High_Bound (Ltyp), R,\n-                                       Discard'Access,\n-                                       Assume_Valid, Rec => True)\n-            is\n-               when LT => return LT;\n-               when LE => return LE;\n-               when EQ => return LE;\n-               when others => null;\n-            end case;\n+               case Compile_Time_Compare (Type_High_Bound (Ltyp), R,\n+                                          Discard'Access,\n+                                          Assume_Valid, Rec => True)\n+               is\n+                  when LT => return LT;\n+                  when LE => return LE;\n+                  when EQ => return LE;\n+                  when others => null;\n+               end case;\n+            end if;\n          end if;\n \n          --  Next attempt is to decompose the expressions to extract\n@@ -1053,6 +1145,15 @@ package body Sem_Eval is\n       Indx := First_Index (T);\n       while Present (Indx) loop\n          Typ := Underlying_Type (Etype (Indx));\n+\n+         --  Never look at junk bounds of a generic type\n+\n+         if Is_Generic_Type (Typ) then\n+            return False;\n+         end if;\n+\n+         --  Otherwise check bounds for compile time known\n+\n          if not Compile_Time_Known_Value (Type_Low_Bound (Typ)) then\n             return False;\n          elsif not Compile_Time_Known_Value (Type_High_Bound (Typ)) then\n@@ -2395,7 +2496,8 @@ package body Sem_Eval is\n    ------------------------\n \n    --  Relational operations are static functions, so the result is static\n-   --  if both operands are static (RM 4.9(7), 4.9(20)).\n+   --  if both operands are static (RM 4.9(7), 4.9(20)), except that for\n+   --  strings, the result is never static, even if the operands are.\n \n    procedure Eval_Relational_Op (N : Node_Id) is\n       Left   : constant Node_Id   := Left_Opnd (N);\n@@ -2597,94 +2699,116 @@ package body Sem_Eval is\n          end Length_Mismatch;\n       end if;\n \n-      --  Another special case: comparisons of access types, where one or both\n-      --  operands are known to be null, so the result can be determined.\n-\n-      if Is_Access_Type (Typ) then\n-         if Known_Null (Left) then\n-            if Known_Null (Right) then\n-               Fold_Uint (N, Test (Nkind (N) = N_Op_Eq), False);\n-               Warn_On_Known_Condition (N);\n-               return;\n-\n-            elsif Known_Non_Null (Right) then\n-               Fold_Uint (N, Test (Nkind (N) = N_Op_Ne), False);\n-               Warn_On_Known_Condition (N);\n-               return;\n-            end if;\n+      --  Test for expression being foldable\n \n-         elsif Known_Non_Null (Left) then\n-            if Known_Null (Right) then\n-               Fold_Uint (N, Test (Nkind (N) = N_Op_Ne), False);\n-               Warn_On_Known_Condition (N);\n-               return;\n-            end if;\n-         end if;\n-      end if;\n+      Test_Expression_Is_Foldable (N, Left, Right, Stat, Fold);\n \n-      --  Can only fold if type is scalar (don't fold string ops)\n+      --  Only comparisons of scalars can give static results. In particular,\n+      --  comparisons of strings never yield a static result, even if both\n+      --  operands are static strings.\n \n       if not Is_Scalar_Type (Typ) then\n-         Check_Non_Static_Context (Left);\n-         Check_Non_Static_Context (Right);\n-         return;\n-      end if;\n-\n-      --  If not foldable we are done\n-\n-      Test_Expression_Is_Foldable (N, Left, Right, Stat, Fold);\n-\n-      if not Fold then\n-         return;\n+         Stat := False;\n+         Set_Is_Static_Expression (N, False);\n       end if;\n \n-      --  Integer and Enumeration (discrete) type cases\n+      --  For static real type expressions, we cannot use Compile_Time_Compare\n+      --  since it worries about run-time results which are not exact.\n \n-      if Is_Discrete_Type (Typ) then\n+      if Stat and then Is_Real_Type (Typ) then\n          declare\n-            Left_Int  : constant Uint := Expr_Value (Left);\n-            Right_Int : constant Uint := Expr_Value (Right);\n+            Left_Real  : constant Ureal := Expr_Value_R (Left);\n+            Right_Real : constant Ureal := Expr_Value_R (Right);\n \n          begin\n             case Nkind (N) is\n-               when N_Op_Eq => Result := Left_Int =  Right_Int;\n-               when N_Op_Ne => Result := Left_Int /= Right_Int;\n-               when N_Op_Lt => Result := Left_Int <  Right_Int;\n-               when N_Op_Le => Result := Left_Int <= Right_Int;\n-               when N_Op_Gt => Result := Left_Int >  Right_Int;\n-               when N_Op_Ge => Result := Left_Int >= Right_Int;\n+               when N_Op_Eq => Result := (Left_Real =  Right_Real);\n+               when N_Op_Ne => Result := (Left_Real /= Right_Real);\n+               when N_Op_Lt => Result := (Left_Real <  Right_Real);\n+               when N_Op_Le => Result := (Left_Real <= Right_Real);\n+               when N_Op_Gt => Result := (Left_Real >  Right_Real);\n+               when N_Op_Ge => Result := (Left_Real >= Right_Real);\n \n                when others =>\n                   raise Program_Error;\n             end case;\n \n-            Fold_Uint (N, Test (Result), Stat);\n+            Fold_Uint (N, Test (Result), True);\n          end;\n \n-      --  Real type case\n+      --  For all other cases, we use Compile_Time_Compare to do the compare\n \n       else\n-         pragma Assert (Is_Real_Type (Typ));\n-\n          declare\n-            Left_Real  : constant Ureal := Expr_Value_R (Left);\n-            Right_Real : constant Ureal := Expr_Value_R (Right);\n+            CR : constant Compare_Result :=\n+                   Compile_Time_Compare (Left, Right, Assume_Valid => False);\n \n          begin\n+            if CR = Unknown then\n+               return;\n+            end if;\n+\n             case Nkind (N) is\n-               when N_Op_Eq => Result := (Left_Real =  Right_Real);\n-               when N_Op_Ne => Result := (Left_Real /= Right_Real);\n-               when N_Op_Lt => Result := (Left_Real <  Right_Real);\n-               when N_Op_Le => Result := (Left_Real <= Right_Real);\n-               when N_Op_Gt => Result := (Left_Real >  Right_Real);\n-               when N_Op_Ge => Result := (Left_Real >= Right_Real);\n+               when N_Op_Eq =>\n+                  if CR = EQ then\n+                     Result := True;\n+                  elsif CR = NE or else CR = GT or else CR = LT then\n+                     Result := False;\n+                  else\n+                     return;\n+                  end if;\n+\n+               when N_Op_Ne =>\n+                  if CR = NE or else CR = GT or else CR = LT then\n+                     Result := True;\n+                  elsif CR = EQ then\n+                     Result := False;\n+                  else\n+                     return;\n+                  end if;\n+\n+               when N_Op_Lt =>\n+                  if CR = LT then\n+                     Result := True;\n+                  elsif CR = EQ or else CR = GT or else CR = GE then\n+                     Result := False;\n+                  else\n+                     return;\n+                  end if;\n+\n+               when N_Op_Le =>\n+                  if CR = LT or else CR = EQ or else CR = LE then\n+                     Result := True;\n+                  elsif CR = GT then\n+                     Result := False;\n+                  else\n+                     return;\n+                  end if;\n+\n+               when N_Op_Gt =>\n+                  if CR = GT then\n+                     Result := True;\n+                  elsif CR = EQ or else CR = LT or else CR = LE then\n+                     Result := False;\n+                  else\n+                     return;\n+                  end if;\n+\n+               when N_Op_Ge =>\n+                  if CR = GT or else CR = EQ or else CR = GE then\n+                     Result := True;\n+                  elsif CR = LT then\n+                     Result := False;\n+                  else\n+                     return;\n+                  end if;\n \n                when others =>\n                   raise Program_Error;\n             end case;\n-\n-            Fold_Uint (N, Test (Result), Stat);\n          end;\n+\n+         Fold_Uint (N, Test (Result), Stat);\n       end if;\n \n       Warn_On_Known_Condition (N);"}, {"sha": "05aadcbd9952feac81c0203ca2e37e0041165d80", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c3fca75ea3dd182fbd4cfca5b1dabd7344f735/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c3fca75ea3dd182fbd4cfca5b1dabd7344f735/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=93c3fca75ea3dd182fbd4cfca5b1dabd7344f735", "patch": "@@ -9482,6 +9482,51 @@ package body Sem_Util is\n       return Token_Node;\n    end Real_Convert;\n \n+   ------------------------------------\n+   -- References_Generic_Formal_Type --\n+   ------------------------------------\n+\n+   function References_Generic_Formal_Type (N : Node_Id) return Boolean is\n+\n+      function Process (N : Node_Id) return Traverse_Result;\n+      --  Process one node in search for generic formal type\n+\n+      -------------\n+      -- Process --\n+      -------------\n+\n+      function Process (N : Node_Id) return Traverse_Result is\n+      begin\n+         if Nkind (N) in N_Has_Entity then\n+            declare\n+               E : constant Entity_Id := Entity (N);\n+            begin\n+               if Present (E) then\n+                  if Is_Generic_Type (E) then\n+                     return Abandon;\n+                  elsif Present (Etype (E))\n+                    and then Is_Generic_Type (Etype (E))\n+                  then\n+                     return Abandon;\n+                  end if;\n+               end if;\n+            end;\n+         end if;\n+\n+         return Atree.OK;\n+      end Process;\n+\n+      function Traverse is new Traverse_Func (Process);\n+      --  Traverse tree to look for generic type\n+\n+   begin\n+      if Inside_A_Generic then\n+         return Traverse (N) = Abandon;\n+      else\n+         return False;\n+      end if;\n+   end References_Generic_Formal_Type;\n+\n    --------------------\n    -- Remove_Homonym --\n    --------------------"}, {"sha": "b4adabf26a99c81a50a1a7277f2a3e8d1ae6d1b6", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c3fca75ea3dd182fbd4cfca5b1dabd7344f735/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c3fca75ea3dd182fbd4cfca5b1dabd7344f735/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=93c3fca75ea3dd182fbd4cfca5b1dabd7344f735", "patch": "@@ -1026,6 +1026,10 @@ package Sem_Util is\n    --  S is a possibly signed syntactically valid real literal. The result\n    --  returned is an N_Real_Literal node representing the literal value.\n \n+   function References_Generic_Formal_Type (N : Node_Id) return Boolean;\n+   --  Returns True if the expression Expr contains any references to a\n+   --  generic type. This can only happen within a generic template.\n+\n    procedure Remove_Homonym (E : Entity_Id);\n    --  Removes E from the homonym chain\n "}]}