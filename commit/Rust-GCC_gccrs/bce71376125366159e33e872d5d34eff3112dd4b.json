{"sha": "bce71376125366159e33e872d5d34eff3112dd4b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmNlNzEzNzYxMjUzNjYxNTllMzNlODcyZDVkMzRlZmYzMTEyZGQ0Yg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2005-10-12T20:41:28Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2005-10-12T20:41:28Z"}, "message": "[multiple changes]\n\n2005-10-12  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/24092\n\t* trans-types.c (gfc_get_derived_type): Insert code to obtain backend\n\tdeclaration for derived types, building if necessary.  Return the\n\tderived type if the fields have been built by this process.  Otherwise,\n\tcontinue as before but using the already obtained backend_decls for the\n\tderived type components.  Change the gcc_assert to act on the field.\n\n2005-10-10  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/24092\n\t* gfortran.dg/derived_pointer_recursion.f90: New test.\n\nFrom-SVN: r105331", "tree": {"sha": "3af3f5392e010df02ed042dbc2ee1cef65f159d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3af3f5392e010df02ed042dbc2ee1cef65f159d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bce71376125366159e33e872d5d34eff3112dd4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bce71376125366159e33e872d5d34eff3112dd4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bce71376125366159e33e872d5d34eff3112dd4b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bce71376125366159e33e872d5d34eff3112dd4b/comments", "author": null, "committer": null, "parents": [{"sha": "8adac33500f774ff06f2900186eb09b42cb5e9c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8adac33500f774ff06f2900186eb09b42cb5e9c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8adac33500f774ff06f2900186eb09b42cb5e9c5"}], "stats": {"total": 78, "additions": 62, "deletions": 16}, "files": [{"sha": "86aeeae89ec2630ed28a7bd4884cbb6e03404784", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bce71376125366159e33e872d5d34eff3112dd4b/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bce71376125366159e33e872d5d34eff3112dd4b/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=bce71376125366159e33e872d5d34eff3112dd4b", "patch": "@@ -1,3 +1,12 @@\n+2005-10-12  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/24092\n+\t* trans-types.c (gfc_get_derived_type): Insert code to obtain backend\n+\tdeclaration for derived types, building if necessary.  Return the\n+\tderived type if the fields have been built by this process.  Otherwise,\n+\tcontinue as before but using the already obtained backend_decls for the\n+\tderived type components.  Change the gcc_assert to act on the field.\n+\n 2005-10-12  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/18082"}, {"sha": "81a90f1d373f7d1baca08aec0ced4e21a019f34d", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bce71376125366159e33e872d5d34eff3112dd4b/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bce71376125366159e33e872d5d34eff3112dd4b/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=bce71376125366159e33e872d5d34eff3112dd4b", "patch": "@@ -1415,21 +1415,30 @@ gfc_get_derived_type (gfc_symbol * derived)\n       derived->backend_decl = typenode;\n     }\n \n+  /* Go through the derived type components, building them as\n+     necessary. The reason for doing this now is that it is\n+     possible to recurse back to this derived type through a\n+     pointer component (PR24092). If this happens, the fields\n+     will be built and so we can return the type.  */\n+  for (c = derived->components; c; c = c->next)\n+    {\n+      if (c->ts.type != BT_DERIVED)\n+\tcontinue;\n+\n+      if (!c->pointer || c->ts.derived->backend_decl == NULL)\n+\tc->ts.derived->backend_decl = gfc_get_derived_type (c->ts.derived);\n+    }\n+\n+  if (TYPE_FIELDS (derived->backend_decl))\n+    return derived->backend_decl;\n+\n   /* Build the type member list. Install the newly created RECORD_TYPE\n      node as DECL_CONTEXT of each FIELD_DECL.  */\n   fieldlist = NULL_TREE;\n   for (c = derived->components; c; c = c->next)\n     {\n-      if (c->ts.type == BT_DERIVED && c->pointer)\n-        {\n-          if (c->ts.derived->backend_decl)\n-\t    /* We already saw this derived type so use the exiting type.\n-\t       It doesn't matter if it is incomplete.  */\n-\t    field_type = c->ts.derived->backend_decl;\n-          else\n-\t    /* Recurse into the type.  */\n-\t    field_type = gfc_get_derived_type (c->ts.derived);\n-        }\n+      if (c->ts.type == BT_DERIVED)\n+        field_type = c->ts.derived->backend_decl;\n       else\n \t{\n \t  if (c->ts.type == BT_CHARACTER)\n@@ -1464,8 +1473,9 @@ gfc_get_derived_type (gfc_symbol * derived)\n \n       DECL_PACKED (field) |= TYPE_PACKED (typenode);\n \n-      gcc_assert (!c->backend_decl);\n-      c->backend_decl = field;\n+      gcc_assert (field);\n+      if (!c->backend_decl)\n+\tc->backend_decl = field;\n     }\n \n   /* Now we have the final fieldlist.  Record it, then lay out the"}, {"sha": "99d2dbd33099717330947e70ddc9cdeb0ea44f66", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bce71376125366159e33e872d5d34eff3112dd4b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bce71376125366159e33e872d5d34eff3112dd4b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bce71376125366159e33e872d5d34eff3112dd4b", "patch": "@@ -1,19 +1,24 @@\n+2005-10-10  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/24092\n+\t* gfortran.dg/derived_pointer_recursion.f90: New test.\n+\n 2005-10-12  Adrian Straetling <straetling@de.ibm.com>\n \n \t* gcc.c-torture/execute/20051012-1.c: New test.\n \n 2005-10-12  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/18082\n-\tgfortran.dg/automatic_char_len_1.f90: New test.\n+\t* gfortran.dg/automatic_char_len_1.f90: New test.\n \n 2005-10-12  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/20847\n-\tgfortran.dg/save_common.f90: New test.\n+\t* gfortran.dg/save_common.f90: New test.\n \n \tPR fortran/20856\n-\tgfortran.dg/save_result.f90: New test.\n+\t* gfortran.dg/save_result.f90: New test.\n \n 2005-10-12  Nathan Sidwell  <nathan@codesourcery.com>\n \n@@ -50,7 +55,7 @@\n 2005-10-12  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/24207\n-\tgfortran.dg/private_type_3.f90: New test.\n+\t* gfortran.dg/private_type_3.f90: New test.\n \n 2005-10-11  Steven G. Kargl  <kargls@comcast.net>\n "}, {"sha": "5ae532530d2af315015e43f72c7e39f79c9bdb6f", "filename": "gcc/testsuite/gfortran.dg/derived_pointer_recursion.f90", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bce71376125366159e33e872d5d34eff3112dd4b/gcc%2Ftestsuite%2Fgfortran.dg%2Fderived_pointer_recursion.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bce71376125366159e33e872d5d34eff3112dd4b/gcc%2Ftestsuite%2Fgfortran.dg%2Fderived_pointer_recursion.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fderived_pointer_recursion.f90?ref=bce71376125366159e33e872d5d34eff3112dd4b", "patch": "@@ -0,0 +1,22 @@\n+! { dg-do compile }\n+! { dg-options \"-O0\" }\n+!  Tests patch for PR24092 - This would ICE because of the loop in the\n+!  derived type definitions.\n+!\n+   module llo\n+      type :: it\n+         character*10  :: k\n+         integer :: c(2)\n+      end type it\n+      type :: bt\n+         type (nt), pointer :: p\n+      end type bt\n+      type :: nt\n+         type (it) :: i\n+         type (bt) :: b\n+      end type nt\n+      type (bt), pointer :: ptr\n+   end module llo\n+!  copyright 1996 Loren P. Meissner -- May be distributed if this line is included.\n+!  Linked List operations with Pointer to Pointer\n+"}]}