{"sha": "0c2b81459e5e8aa3d34f5deb4cc150a1ee8ee779", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGMyYjgxNDU5ZTVlOGFhM2QzNGY1ZGViNGNjMTUwYTFlZThlZTc3OQ==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@cygnus.com", "date": "2000-07-07T06:36:14Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "2000-07-07T06:36:14Z"}, "message": "[multiple changes]\n\n2000-07-06  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n        * parse.h (BUILD_PTR_FROM_NAME): Surround with a do/while\n        construct.\n        * parse.y (find_as_inner_class): Fixed typo.\n        (do_resolve_class): Explore enclosing contexts when searching for\n        innerclasses. Removed curly brackets around BUILD_PTR_FROM_NAME.\n        (check_inner_class_access): Check `decl' which can be null in case\n        of previous errors.\n\n2000-07-05  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n        * java-tree.h (java_debug_context): Declared `extern.'\n        (safe_layout_class): Likewise.\n        * parse.y (resolve_field_access): Field must be `static' in order\n        to be replaced by its initial value. Added comments.\n        (find_applicable_accessible_methods_list): Fixed typo.\n        (find_most_specific_methods_list): Methods found in innerclasses\n        take over methods founds in the enclosing contexts.\n        (java_complete_tree): Loosen restrictions on the type of DECLs\n        that can be replaced by their initialization values.\n        (valid_ref_assignconv_cast_p): Removed call to `enclosing_context_p.'\n\n(http://gcc.gnu.org/ml/gcc-patches/2000-07/msg00184.html)\n\nFrom-SVN: r34895", "tree": {"sha": "9c3743be4380c260fc213732a10aaa7f6976cf6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c3743be4380c260fc213732a10aaa7f6976cf6f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c2b81459e5e8aa3d34f5deb4cc150a1ee8ee779", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c2b81459e5e8aa3d34f5deb4cc150a1ee8ee779", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c2b81459e5e8aa3d34f5deb4cc150a1ee8ee779", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c2b81459e5e8aa3d34f5deb4cc150a1ee8ee779/comments", "author": null, "committer": null, "parents": [{"sha": "98a52c2ccf0f7c28c910a2bc17d0e97ff9f28bdb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98a52c2ccf0f7c28c910a2bc17d0e97ff9f28bdb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98a52c2ccf0f7c28c910a2bc17d0e97ff9f28bdb"}], "stats": {"total": 142, "additions": 102, "deletions": 40}, "files": [{"sha": "03fb4f3b69f2bb33514e9508d37440a7d8aee464", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c2b81459e5e8aa3d34f5deb4cc150a1ee8ee779/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c2b81459e5e8aa3d34f5deb4cc150a1ee8ee779/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=0c2b81459e5e8aa3d34f5deb4cc150a1ee8ee779", "patch": "@@ -1,3 +1,26 @@\n+2000-07-06  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* parse.h (BUILD_PTR_FROM_NAME): Surround with a do/while\n+\tconstruct.\n+\t* parse.y (find_as_inner_class): Fixed typo.\n+\t(do_resolve_class): Explore enclosing contexts when searching for\n+\tinnerclasses. Removed curly brackets around BUILD_PTR_FROM_NAME.\n+\t(check_inner_class_access): Check `decl' which can be null in case\n+\tof previous errors.\n+\n+2000-07-05  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* java-tree.h (java_debug_context): Declared `extern.'\n+\t(safe_layout_class): Likewise.\n+\t* parse.y (resolve_field_access): Field must be `static' in order\n+\tto be replaced by its initial value. Added comments.\n+\t(find_applicable_accessible_methods_list): Fixed typo.\n+\t(find_most_specific_methods_list): Methods found in innerclasses\n+\ttake over methods founds in the enclosing contexts.\n+\t(java_complete_tree): Loosen restrictions on the type of DECLs\n+\tthat can be replaced by their initialization values.\n+\t(valid_ref_assignconv_cast_p): Removed call to `enclosing_context_p.'\n+\n 2000-07-05  Tom Tromey  <tromey@cygnus.com>\n \n \t* Make-lang.in (PARSE_DIR): New macro."}, {"sha": "5d132beaa20189b376c1f12188a06ca5bd330e76", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c2b81459e5e8aa3d34f5deb4cc150a1ee8ee779/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c2b81459e5e8aa3d34f5deb4cc150a1ee8ee779/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=0c2b81459e5e8aa3d34f5deb4cc150a1ee8ee779", "patch": "@@ -779,8 +779,8 @@ extern const char* open_class PARAMS ((const char *, struct JCF *,\n \t\t\t\t       int, const char *));\n # endif /* JCF_USE_STDIO */\n #endif\n-void java_debug_context PARAMS ((void));\n-void safe_layout_class PARAMS ((tree));\n+extern void java_debug_context PARAMS ((void));\n+extern void safe_layout_class PARAMS ((tree));\n \n extern tree get_boehm_type_descriptor PARAMS ((tree));\n extern unsigned long java_hash_hash_tree_node PARAMS ((hash_table_key));"}, {"sha": "14c4375d2a5d708e13722e1a34aec6d5a3265aba", "filename": "gcc/java/parse.c", "status": "modified", "additions": 38, "deletions": 18, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c2b81459e5e8aa3d34f5deb4cc150a1ee8ee779/gcc%2Fjava%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c2b81459e5e8aa3d34f5deb4cc150a1ee8ee779/gcc%2Fjava%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.c?ref=0c2b81459e5e8aa3d34f5deb4cc150a1ee8ee779", "patch": "@@ -6169,8 +6169,8 @@ find_as_inner_class (enclosing, name, cl)\n     {\n       tree acc = NULL_TREE, decl = NULL_TREE, ptr;\n \n-      for(qual = EXPR_WFL_QUALIFICATION (cl); qual && !decl; \n-\t  qual = TREE_CHAIN (qual))\n+      for (qual = EXPR_WFL_QUALIFICATION (cl); qual && !decl; \n+\t   qual = TREE_CHAIN (qual))\n \t{\n \t  acc = merge_qualified_name (acc, \n \t\t\t\t      EXPR_WFL_NODE (TREE_PURPOSE (qual)));\n@@ -8136,6 +8136,15 @@ do_resolve_class (enclosing, class_type, decl, cl)\n       if ((new_class_decl = find_as_inner_class (enclosing, class_type, cl)))\n         return new_class_decl;\n \n+      /* Explore enclosing contexts. */\n+      while (INNER_CLASS_DECL_P (enclosing))\n+\t{\n+\t  enclosing = DECL_CONTEXT (enclosing);\n+\t  if ((new_class_decl = find_as_inner_class (enclosing, \n+\t\t\t\t\t\t     class_type, cl)))\n+\t    return new_class_decl;\n+\t}\n+\n       /* Now go to the upper classes, bail out if necessary. */\n       enclosing = CLASSTYPE_SUPER (TREE_TYPE (enclosing));\n       if (!enclosing || enclosing == object_type_node)\n@@ -8148,9 +8157,7 @@ do_resolve_class (enclosing, class_type, decl, cl)\n \t}\n \n       if (TREE_CODE (enclosing) == IDENTIFIER_NODE)\n-\t{\n-\t  BUILD_PTR_FROM_NAME (name, enclosing);\n-\t}\n+\tBUILD_PTR_FROM_NAME (name, enclosing);\n       else\n \tname = enclosing;\n       enclosing = do_resolve_class (NULL, name, NULL, NULL);\n@@ -9475,6 +9482,8 @@ static void\n check_inner_class_access (decl, enclosing_type, cl)\n      tree decl, enclosing_type, cl;\n {\n+  if (!decl)\n+    return;\n   /* We don't issue an error message when CL is null. CL can be null\n      as a result of processing a JDEP crafted by\n      source_start_java_method for the purpose of patching its parm\n@@ -11438,10 +11447,13 @@ resolve_field_access (qual_wfl, field_decl, field_type)\n       if (!type_found)\n \ttype_found = DECL_CONTEXT (decl);\n       is_static = JDECL_P (decl) && FIELD_STATIC (decl);\n-      if (FIELD_FINAL (decl) \n+      if (FIELD_FINAL (decl) && FIELD_STATIC (decl)\n \t  && JPRIMITIVE_TYPE_P (TREE_TYPE (decl))\n \t  && DECL_INITIAL (decl))\n \t{\n+\t  /* When called on a FIELD_DECL of the right (primitive)\n+\t     type, java_complete_tree will try to substitue the decl\n+\t     for it's initial value. */\n \t  field_ref = java_complete_tree (decl);\n \t  static_final_found = 1;\n \t}\n@@ -12812,7 +12824,7 @@ find_applicable_accessible_methods_list (lc, class, name, arglist)\n     \n   search_not_done++;\n   hash_lookup (searched_classes, \n-              (const hash_table_key) class, TRUE, NULL);\n+\t       (const hash_table_key) class, TRUE, NULL);\n \n   if (!CLASS_LOADED_P (class) && !CLASS_FROM_SOURCE_P (class))\n     {\n@@ -12966,19 +12978,27 @@ find_most_specific_methods_list (list)\n \n       for (method = list; method; method = TREE_CHAIN (method))\n \t{\n+\t  tree method_v, current_v;\n \t  /* Don't test a method against itself */\n \t  if (method == current)\n \t    continue;\n \n-\t  /* Compare arguments and location where method where declared */\n-\t  if (argument_types_convertible (TREE_VALUE (method), \n-\t\t\t\t\t  TREE_VALUE (current))\n-\t      && valid_method_invocation_conversion_p \n-\t           (DECL_CONTEXT (TREE_VALUE (method)), \n-\t\t    DECL_CONTEXT (TREE_VALUE (current))))\n+\t  method_v = TREE_VALUE (method);\n+\t  current_v = TREE_VALUE (current);\n+\n+\t  /* Compare arguments and location where methods where declared */\n+\t  if (argument_types_convertible (method_v, current_v))\n \t    {\n-\t      int v = ++DECL_SPECIFIC_COUNT (TREE_VALUE (current));\n-\t      max = (v > max ? v : max);\n+\t      if (valid_method_invocation_conversion_p \n+\t\t  (DECL_CONTEXT (method_v), DECL_CONTEXT (current_v))\n+\t\t  || (INNER_CLASS_TYPE_P (DECL_CONTEXT (current_v))\n+\t\t      && enclosing_context_p (DECL_CONTEXT (method_v),\n+\t\t\t\t\t      DECL_CONTEXT (current_v))))\n+\t\t{\n+\t\t  int v = (DECL_SPECIFIC_COUNT (current_v) += \n+\t\t    (INNER_CLASS_TYPE_P (DECL_CONTEXT (current_v)) ? 2 : 1));\n+\t\t  max = (v > max ? v : max);\n+\t\t}\n \t    }\n \t}\n     }\n@@ -13315,8 +13335,8 @@ java_complete_tree (node)\n      tree node;\n {\n   node = java_complete_lhs (node);\n-  if (TREE_CODE (node) == VAR_DECL && FIELD_STATIC (node)\n-      && FIELD_FINAL (node) && DECL_INITIAL (node) != NULL_TREE\n+  if (JDECL_P (node) && FIELD_STATIC (node) && FIELD_FINAL (node) \n+      && DECL_INITIAL (node) != NULL_TREE\n       && !flag_emit_xref)\n     {\n       tree value = DECL_INITIAL (node);\n@@ -13782,6 +13802,7 @@ java_complete_lhs (node)\n     case NEW_CLASS_EXPR:\n     case CALL_EXPR:\n       /* Complete function's argument(s) first */\n+\n       if (complete_function_arguments (node))\n \treturn error_mark_node;\n       else\n@@ -14766,7 +14787,6 @@ valid_ref_assignconv_cast_p (source, dest, cast)\n       if (TYPE_CLASS_P (dest))\n \treturn  (source == dest \n \t\t || inherits_from_p (source, dest)\n-\t\t || enclosing_context_p (source, dest)\n \t\t || (cast && inherits_from_p (dest, source)));\n       if (TYPE_INTERFACE_P (dest))\n \t{"}, {"sha": "687dc951c92a72bf96f0be247ea0cd9aa4cd0344", "filename": "gcc/java/parse.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c2b81459e5e8aa3d34f5deb4cc150a1ee8ee779/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c2b81459e5e8aa3d34f5deb4cc150a1ee8ee779/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=0c2b81459e5e8aa3d34f5deb4cc150a1ee8ee779", "patch": "@@ -156,10 +156,10 @@ extern tree stabilize_reference PARAMS ((tree));\n \n /* Quickly build a temporary pointer on hypothetical type NAME. */\n #define BUILD_PTR_FROM_NAME(ptr, name)\t\t\\\n-  {\t\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\\\n     ptr = build (POINTER_TYPE, NULL_TREE);\t\\\n     TYPE_NAME (ptr) = name;\t\t\t\\\n-  }\n+  } while (0)\n \n #define INCOMPLETE_TYPE_P(NODE)\t\t\t\t\\\n   ((TREE_CODE (NODE) == POINTER_TYPE)\t\t\t\\"}, {"sha": "312afd319c01172cf0d7f67e0ca8a985a15227ec", "filename": "gcc/java/parse.y", "status": "modified", "additions": 37, "deletions": 18, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c2b81459e5e8aa3d34f5deb4cc150a1ee8ee779/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c2b81459e5e8aa3d34f5deb4cc150a1ee8ee779/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=0c2b81459e5e8aa3d34f5deb4cc150a1ee8ee779", "patch": "@@ -3471,8 +3471,8 @@ find_as_inner_class (enclosing, name, cl)\n     {\n       tree acc = NULL_TREE, decl = NULL_TREE, ptr;\n \n-      for(qual = EXPR_WFL_QUALIFICATION (cl); qual && !decl; \n-\t  qual = TREE_CHAIN (qual))\n+      for (qual = EXPR_WFL_QUALIFICATION (cl); qual && !decl; \n+\t   qual = TREE_CHAIN (qual))\n \t{\n \t  acc = merge_qualified_name (acc, \n \t\t\t\t      EXPR_WFL_NODE (TREE_PURPOSE (qual)));\n@@ -5438,6 +5438,15 @@ do_resolve_class (enclosing, class_type, decl, cl)\n       if ((new_class_decl = find_as_inner_class (enclosing, class_type, cl)))\n         return new_class_decl;\n \n+      /* Explore enclosing contexts. */\n+      while (INNER_CLASS_DECL_P (enclosing))\n+\t{\n+\t  enclosing = DECL_CONTEXT (enclosing);\n+\t  if ((new_class_decl = find_as_inner_class (enclosing, \n+\t\t\t\t\t\t     class_type, cl)))\n+\t    return new_class_decl;\n+\t}\n+\n       /* Now go to the upper classes, bail out if necessary. */\n       enclosing = CLASSTYPE_SUPER (TREE_TYPE (enclosing));\n       if (!enclosing || enclosing == object_type_node)\n@@ -5450,9 +5459,7 @@ do_resolve_class (enclosing, class_type, decl, cl)\n \t}\n \n       if (TREE_CODE (enclosing) == IDENTIFIER_NODE)\n-\t{\n-\t  BUILD_PTR_FROM_NAME (name, enclosing);\n-\t}\n+\tBUILD_PTR_FROM_NAME (name, enclosing);\n       else\n \tname = enclosing;\n       enclosing = do_resolve_class (NULL, name, NULL, NULL);\n@@ -6777,6 +6784,8 @@ static void\n check_inner_class_access (decl, enclosing_type, cl)\n      tree decl, enclosing_type, cl;\n {\n+  if (!decl)\n+    return;\n   /* We don't issue an error message when CL is null. CL can be null\n      as a result of processing a JDEP crafted by\n      source_start_java_method for the purpose of patching its parm\n@@ -8740,10 +8749,13 @@ resolve_field_access (qual_wfl, field_decl, field_type)\n       if (!type_found)\n \ttype_found = DECL_CONTEXT (decl);\n       is_static = JDECL_P (decl) && FIELD_STATIC (decl);\n-      if (FIELD_FINAL (decl) \n+      if (FIELD_FINAL (decl) && FIELD_STATIC (decl)\n \t  && JPRIMITIVE_TYPE_P (TREE_TYPE (decl))\n \t  && DECL_INITIAL (decl))\n \t{\n+\t  /* When called on a FIELD_DECL of the right (primitive)\n+\t     type, java_complete_tree will try to substitue the decl\n+\t     for it's initial value. */\n \t  field_ref = java_complete_tree (decl);\n \t  static_final_found = 1;\n \t}\n@@ -10114,7 +10126,7 @@ find_applicable_accessible_methods_list (lc, class, name, arglist)\n     \n   search_not_done++;\n   hash_lookup (searched_classes, \n-              (const hash_table_key) class, TRUE, NULL);\n+\t       (const hash_table_key) class, TRUE, NULL);\n \n   if (!CLASS_LOADED_P (class) && !CLASS_FROM_SOURCE_P (class))\n     {\n@@ -10268,19 +10280,27 @@ find_most_specific_methods_list (list)\n \n       for (method = list; method; method = TREE_CHAIN (method))\n \t{\n+\t  tree method_v, current_v;\n \t  /* Don't test a method against itself */\n \t  if (method == current)\n \t    continue;\n \n-\t  /* Compare arguments and location where method where declared */\n-\t  if (argument_types_convertible (TREE_VALUE (method), \n-\t\t\t\t\t  TREE_VALUE (current))\n-\t      && valid_method_invocation_conversion_p \n-\t           (DECL_CONTEXT (TREE_VALUE (method)), \n-\t\t    DECL_CONTEXT (TREE_VALUE (current))))\n+\t  method_v = TREE_VALUE (method);\n+\t  current_v = TREE_VALUE (current);\n+\n+\t  /* Compare arguments and location where methods where declared */\n+\t  if (argument_types_convertible (method_v, current_v))\n \t    {\n-\t      int v = ++DECL_SPECIFIC_COUNT (TREE_VALUE (current));\n-\t      max = (v > max ? v : max);\n+\t      if (valid_method_invocation_conversion_p \n+\t\t  (DECL_CONTEXT (method_v), DECL_CONTEXT (current_v))\n+\t\t  || (INNER_CLASS_TYPE_P (DECL_CONTEXT (current_v))\n+\t\t      && enclosing_context_p (DECL_CONTEXT (method_v),\n+\t\t\t\t\t      DECL_CONTEXT (current_v))))\n+\t\t{\n+\t\t  int v = (DECL_SPECIFIC_COUNT (current_v) += \n+\t\t    (INNER_CLASS_TYPE_P (DECL_CONTEXT (current_v)) ? 2 : 1));\n+\t\t  max = (v > max ? v : max);\n+\t\t}\n \t    }\n \t}\n     }\n@@ -10617,8 +10637,8 @@ java_complete_tree (node)\n      tree node;\n {\n   node = java_complete_lhs (node);\n-  if (TREE_CODE (node) == VAR_DECL && FIELD_STATIC (node)\n-      && FIELD_FINAL (node) && DECL_INITIAL (node) != NULL_TREE\n+  if (JDECL_P (node) && FIELD_STATIC (node) && FIELD_FINAL (node) \n+      && DECL_INITIAL (node) != NULL_TREE\n       && !flag_emit_xref)\n     {\n       tree value = DECL_INITIAL (node);\n@@ -12068,7 +12088,6 @@ valid_ref_assignconv_cast_p (source, dest, cast)\n       if (TYPE_CLASS_P (dest))\n \treturn  (source == dest \n \t\t || inherits_from_p (source, dest)\n-\t\t || enclosing_context_p (source, dest)\n \t\t || (cast && inherits_from_p (dest, source)));\n       if (TYPE_INTERFACE_P (dest))\n \t{"}]}