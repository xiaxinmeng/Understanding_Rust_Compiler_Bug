{"sha": "d10e419bebe07f5506836ea65ab7638321305305", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDEwZTQxOWJlYmUwN2Y1NTA2ODM2ZWE2NWFiNzYzODMyMTMwNTMwNQ==", "commit": {"author": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2012-11-13T18:35:32Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2012-11-13T18:35:32Z"}, "message": "Workaround PR middle-end/55142\n\ngcc/\n\n2012-11-13  Eric Botcazou  <ebotcazou@adacore.com>\n\t    H.J. Lu  <hongjiu.lu@intel.com>\n\n\tPR middle-end/55142\n\t* config/i386/i386.c (legitimize_pic_address): Properly handle\n\tREG + CONST.\n\t(ix86_print_operand_address): Set code to 'k' when forcing\n\taddr32 prefix.  For x32, zero-extend negative displacement if\n\tit < -16*1024*1024.\n\ngcc/testsuite/\n\n2012-11-13  H.J. Lu  <hongjiu.lu@intel.com>\n\n\tPR middle-end/55142\n\t* gcc.target/i386/pr55142-1.c: New file.\n\t* gcc.target/i386/pr55142-2.c: Likewise.\n\nFrom-SVN: r193483", "tree": {"sha": "e85c5539e0ff5c7572a0fa5cadd12da746ddc2fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e85c5539e0ff5c7572a0fa5cadd12da746ddc2fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d10e419bebe07f5506836ea65ab7638321305305", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d10e419bebe07f5506836ea65ab7638321305305", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d10e419bebe07f5506836ea65ab7638321305305", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d10e419bebe07f5506836ea65ab7638321305305/comments", "author": null, "committer": null, "parents": [{"sha": "141a9e06ad6d6f7d57f33435bd12c4df20cec0db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/141a9e06ad6d6f7d57f33435bd12c4df20cec0db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/141a9e06ad6d6f7d57f33435bd12c4df20cec0db"}], "stats": {"total": 138, "additions": 129, "deletions": 9}, "files": [{"sha": "c39b9f2aa27899a069e63039f3de63a07fdadd08", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10e419bebe07f5506836ea65ab7638321305305/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10e419bebe07f5506836ea65ab7638321305305/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d10e419bebe07f5506836ea65ab7638321305305", "patch": "@@ -1,3 +1,13 @@\n+2012-11-13  Eric Botcazou  <ebotcazou@adacore.com>\n+\t    H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR middle-end/55142\n+\t* config/i386/i386.c (legitimize_pic_address): Properly handle\n+\tREG + CONST.\n+\t(ix86_print_operand_address): Set code to 'k' when forcing\n+\taddr32 prefix.  For x32, zero-extend negative displacement if\n+\tit < -16*1024*1024.\n+\n 2012-11-13  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/41993"}, {"sha": "3af1cf8a6784b0f2aab096ddac543689afcce2bb", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 44, "deletions": 9, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10e419bebe07f5506836ea65ab7638321305305/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10e419bebe07f5506836ea65ab7638321305305/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=d10e419bebe07f5506836ea65ab7638321305305", "patch": "@@ -12203,7 +12203,6 @@ legitimize_pic_address (rtx orig, rtx reg)\n {\n   rtx addr = orig;\n   rtx new_rtx = orig;\n-  rtx base;\n \n #if TARGET_MACHO\n   if (TARGET_MACHO && !TARGET_64BIT)\n@@ -12408,20 +12407,33 @@ legitimize_pic_address (rtx orig, rtx reg)\n \t    }\n \t  else\n \t    {\n-\t      base = legitimize_pic_address (XEXP (addr, 0), reg);\n-\t      new_rtx  = legitimize_pic_address (XEXP (addr, 1),\n-\t\t\t\t\t\t base == reg ? NULL_RTX : reg);\n+\t      rtx base = legitimize_pic_address (op0, reg);\n+\t      enum machine_mode mode = GET_MODE (base);\n+\t      new_rtx\n+\t        = legitimize_pic_address (op1, base == reg ? NULL_RTX : reg);\n \n \t      if (CONST_INT_P (new_rtx))\n-\t\tnew_rtx = plus_constant (Pmode, base, INTVAL (new_rtx));\n+\t\t{\n+\t\t  if (INTVAL (new_rtx) < -16*1024*1024\n+\t\t      || INTVAL (new_rtx) >= 16*1024*1024)\n+\t\t    {\n+\t\t      if (!x86_64_immediate_operand (new_rtx, mode))\n+\t\t\tnew_rtx = force_reg (mode, new_rtx);\n+\t\t      new_rtx\n+\t\t        = gen_rtx_PLUS (mode, force_reg (mode, base), new_rtx);\n+\t\t    }\n+\t\t  else\n+\t\t    new_rtx = plus_constant (mode, base, INTVAL (new_rtx));\n+\t\t}\n \t      else\n \t\t{\n-\t\t  if (GET_CODE (new_rtx) == PLUS && CONSTANT_P (XEXP (new_rtx, 1)))\n+\t\t  if (GET_CODE (new_rtx) == PLUS\n+\t\t      && CONSTANT_P (XEXP (new_rtx, 1)))\n \t\t    {\n-\t\t      base = gen_rtx_PLUS (Pmode, base, XEXP (new_rtx, 0));\n+\t\t      base = gen_rtx_PLUS (mode, base, XEXP (new_rtx, 0));\n \t\t      new_rtx = XEXP (new_rtx, 1);\n \t\t    }\n-\t\t  new_rtx = gen_rtx_PLUS (Pmode, base, new_rtx);\n+\t\t  new_rtx = gen_rtx_PLUS (mode, base, new_rtx);\n \t\t}\n \t    }\n \t}\n@@ -14510,7 +14522,30 @@ ix86_print_operand_address (FILE *file, rtx addr)\n \t    }\n #endif\n \t  gcc_assert (!code);\n-\t  code = 'l';\n+\t  code = 'k';\n+\t}\n+      else if (code == 0\n+\t       && TARGET_X32\n+\t       && disp\n+\t       && CONST_INT_P (disp)\n+\t       && INTVAL (disp) < -16*1024*1024)\n+\t{\n+\t  /* X32 runs in 64-bit mode, where displacement, DISP, in\n+\t     address DISP(%r64), is encoded as 32-bit immediate sign-\n+\t     extended from 32-bit to 64-bit.  For -0x40000300(%r64),\n+\t     address is %r64 + 0xffffffffbffffd00.  When %r64 <\n+\t     0x40000300, like 0x37ffe064, address is 0xfffffffff7ffdd64,\n+\t     which is invalid for x32.  The correct address is %r64\n+\t     - 0x40000300 == 0xf7ffdd64.  To properly encode\n+\t     -0x40000300(%r64) for x32, we zero-extend negative\n+\t     displacement by forcing addr32 prefix which truncates\n+\t     0xfffffffff7ffdd64 to 0xf7ffdd64.  In theory, we should\n+\t     zero-extend all negative displacements, including -1(%rsp).\n+\t     However, for small negative displacements, sign-extension\n+\t     won't cause overflow.  We only zero-extend negative\n+\t     displacements if they < -16*1024*1024, which is also used\n+\t     to check legitimate address displacements for PIC.  */\n+\t  code = 'k';\n \t}\n \n       if (ASSEMBLER_DIALECT == ASM_ATT)"}, {"sha": "b8923e7c9bf69ddf44708b4d25465d9fb49be7af", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10e419bebe07f5506836ea65ab7638321305305/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10e419bebe07f5506836ea65ab7638321305305/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d10e419bebe07f5506836ea65ab7638321305305", "patch": "@@ -1,3 +1,9 @@\n+2012-11-13  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR middle-end/55142\n+\t* gcc.target/i386/pr55142-1.c: New file.\n+\t* gcc.target/i386/pr55142-2.c: Likewise.\n+\n 2012-11-13  Dodji Seketeli  <dodji@redhat.com>\n \n \tPR c++/54466"}, {"sha": "e6b5f126cccac8e32b2ae29cfa19b2f99b15fa9d", "filename": "gcc/testsuite/gcc.target/i386/pr55142-1.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10e419bebe07f5506836ea65ab7638321305305/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr55142-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10e419bebe07f5506836ea65ab7638321305305/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr55142-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr55142-1.c?ref=d10e419bebe07f5506836ea65ab7638321305305", "patch": "@@ -0,0 +1,35 @@\n+/* { dg-do compile { target { ! { ia32 } } } } */\n+/* { dg-require-effective-target maybe_x32 } */\n+/* { dg-require-effective-target fpic } */\n+/* { dg-options \"-O2 -mx32 -maddress-mode=long -fpic\" } */\n+\n+typedef int int32_t;\n+typedef unsigned int uint32_t;\n+typedef int32_t Elf32_Sword;\n+typedef struct\n+{\n+  Elf32_Sword d_tag;\n+} Elf32_Dyn;\n+struct link_map\n+{\n+  Elf32_Dyn *l_ld;\n+  Elf32_Dyn *l_info[34];\n+};\n+extern struct link_map _dl_rtld_map __attribute__ ((visibility (\"hidden\")));\n+static void elf_get_dynamic_info (struct link_map *l)\n+{\n+  Elf32_Dyn *dyn = l->l_ld;\n+  Elf32_Dyn **info;\n+  info = l->l_info;\n+  while (dyn->d_tag != 0)\n+    {\n+      if ((uint32_t) (0x6ffffeff - dyn->d_tag) < 11)\n+\tinfo[0x6ffffeff - dyn->d_tag + 12] = dyn;\n+      ++dyn;\n+    }\n+}\n+void\n+foo (void)\n+{\n+  elf_get_dynamic_info (&_dl_rtld_map);\n+}"}, {"sha": "34f4687193a4ae58976b2f33b9f10cdab4c882ec", "filename": "gcc/testsuite/gcc.target/i386/pr55142-2.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10e419bebe07f5506836ea65ab7638321305305/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr55142-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10e419bebe07f5506836ea65ab7638321305305/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr55142-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr55142-2.c?ref=d10e419bebe07f5506836ea65ab7638321305305", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do compile { target { ! { ia32 } } } } */\n+/* { dg-require-effective-target maybe_x32 } */\n+/* { dg-require-effective-target fpic } */\n+/* { dg-options \"-O3 -mx32 -maddress-mode=long -fpic\" } */\n+/* { dg-final { scan-assembler-not \"movl\\[\\\\t \\]*%.*,\\[\\\\t \\]*-1073742592\\\\(%r(.x|.i|.p|\\[1-9\\]*)\\\\)\" } } */\n+\n+typedef int int32_t;\n+typedef unsigned int uint32_t;\n+typedef uint32_t Elf32_Word;\n+typedef int32_t Elf32_Sword;\n+typedef uint32_t Elf32_Addr;\n+typedef struct {\n+  Elf32_Sword d_tag;\n+  union {\n+    Elf32_Word d_val;\n+    Elf32_Addr d_ptr;\n+  } d_un;\n+} Elf32_Dyn;\n+struct link_map {\n+  Elf32_Dyn *l_ld;\n+  Elf32_Dyn *l_info[34 + 16 + 3 + 12 + 11];\n+};\n+void\n+elf_get_dynamic_info (struct link_map *l)\n+{\n+  Elf32_Dyn *dyn = l->l_ld;\n+  Elf32_Dyn **info = l->l_info;\n+  typedef Elf32_Word d_tag_utype;\n+  while (dyn->d_tag != 0) {\n+    if ((d_tag_utype) (0x6ffffeff - dyn->d_tag) < 11)\n+      info[(0x6ffffeff - dyn->d_tag) + 34 + 16 + 3 + 12] = dyn;\n+    ++dyn;\n+  }\n+}"}]}