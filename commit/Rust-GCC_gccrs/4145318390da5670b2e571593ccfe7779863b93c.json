{"sha": "4145318390da5670b2e571593ccfe7779863b93c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDE0NTMxODM5MGRhNTY3MGIyZTU3MTU5M2NjZmU3Nzc5ODYzYjkzYw==", "commit": {"author": {"name": "Claudiu Zissulescu", "email": "claziss@synopsys.com", "date": "2017-05-09T14:19:22Z"}, "committer": {"name": "Claudiu Zissulescu", "email": "claziss@gcc.gnu.org", "date": "2017-05-09T14:19:22Z"}, "message": "[ARC] Automatic context save/restore for regular interrupts.\n\nThe AUX_IRQ_CTRL register controls the behavior of automated register\nsave and restore or prologue and epilogue sequences during a non-fast\ninterrupt entry and exit, and context save and restore instructions.\n\nA user passes to the compiler the configuration of the AUX_IRQ_CTRL\nregister via mirq-ctrl-saved option.  This option, specifies\ngneral-purposes registers that the processor saves/restores on\ninterrupt entry and exit, and it is only valid for ARC EM and ARC HS\ncores.\n\ngcc/\n2017-05-09  Claudiu Zissulescu  <claziss@synopsys.com>\n\n\t* config/arc/arc.c (irq_ctrl_saved): New variable.\n\t(ARC_AUTOBLINK_IRQ_P): Define.\n\t(ARC_AUTOFP_IRQ_P): Likewise.\n\t(ARC_AUTO_IRQ_P): Likewise.\n\t(irq_range): New function.\n\t(arc_must_save_register): Likewise.\n\t(arc_must_save_return_addr): Likewise.\n\t(arc_dwarf_emit_irq_save_regs): Likewise.\n\t(arc_override_options): Handle deferred options.\n\t(MUST_SAVE_REGISTER): Deleted, replaced by arc_must_save_register.\n\t(MUST_SAVE_RETURN_ADDR): Deleted, replaced by\n\tarc_must_save_return_addr.\n\t(arc_compute_frame_size): Handle automated save and restore of\n\tregisters.\n\t(arc_expand_prologue): Likewise.\n\t(arc_expand_epilogue): Likewise.\n\t* config/arc/arc.md (stack_irq_dwarf): New unspec instruction.\n\t* config/arc/arc.opt (mirq-ctrl-saved): New option.\n\t* doc/invoke.texi (mirq-ctrl-saved): Document option.\n\ntestsuite/\n2017-05-09  Claudiu Zissulescu  <claziss@synopsys.com>\n\n\t* gcc.target/arc/interrupt-5.c: Newfile.\n\t* gcc.target/arc/interrupt-6.c: Likewise.\n\t* gcc.target/arc/interrupt-7.c: Likewise.\n\t* gcc.target/arc/interrupt-8.c: Likewise.\n\t* gcc.target/arc/interrupt-9.c: Likewise.\n\nFrom-SVN: r247795", "tree": {"sha": "e1214c456606fb611b8e63d9e124aee1b065bc08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e1214c456606fb611b8e63d9e124aee1b065bc08"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4145318390da5670b2e571593ccfe7779863b93c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4145318390da5670b2e571593ccfe7779863b93c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4145318390da5670b2e571593ccfe7779863b93c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4145318390da5670b2e571593ccfe7779863b93c/comments", "author": {"login": "claziss", "id": 2761368, "node_id": "MDQ6VXNlcjI3NjEzNjg=", "avatar_url": "https://avatars.githubusercontent.com/u/2761368?v=4", "gravatar_id": "", "url": "https://api.github.com/users/claziss", "html_url": "https://github.com/claziss", "followers_url": "https://api.github.com/users/claziss/followers", "following_url": "https://api.github.com/users/claziss/following{/other_user}", "gists_url": "https://api.github.com/users/claziss/gists{/gist_id}", "starred_url": "https://api.github.com/users/claziss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/claziss/subscriptions", "organizations_url": "https://api.github.com/users/claziss/orgs", "repos_url": "https://api.github.com/users/claziss/repos", "events_url": "https://api.github.com/users/claziss/events{/privacy}", "received_events_url": "https://api.github.com/users/claziss/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "019bd543a9a7c24396eab29a97e4c30c7931bf4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/019bd543a9a7c24396eab29a97e4c30c7931bf4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/019bd543a9a7c24396eab29a97e4c30c7931bf4d"}], "stats": {"total": 483, "additions": 451, "deletions": 32}, "files": [{"sha": "530ade2d031fcdbc9e4ee244bd937f32bfbf3d51", "filename": "ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4145318390da5670b2e571593ccfe7779863b93c/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4145318390da5670b2e571593ccfe7779863b93c/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=4145318390da5670b2e571593ccfe7779863b93c", "patch": "@@ -1,3 +1,25 @@\n+2017-05-09  Claudiu Zissulescu  <claziss@synopsys.com>\n+\n+\t* config/arc/arc.c (irq_ctrl_saved): New variable.\n+\t(ARC_AUTOBLINK_IRQ_P): Define.\n+\t(ARC_AUTOFP_IRQ_P): Likewise.\n+\t(ARC_AUTO_IRQ_P): Likewise.\n+\t(irq_range): New function.\n+\t(arc_must_save_register): Likewise.\n+\t(arc_must_save_return_addr): Likewise.\n+\t(arc_dwarf_emit_irq_save_regs): Likewise.\n+\t(arc_override_options): Handle deferred options.\n+\t(MUST_SAVE_REGISTER): Deleted, replaced by arc_must_save_register.\n+\t(MUST_SAVE_RETURN_ADDR): Deleted, replaced by\n+\tarc_must_save_return_addr.\n+\t(arc_compute_frame_size): Handle automated save and restore of\n+\tregisters.\n+\t(arc_expand_prologue): Likewise.\n+\t(arc_expand_epilogue): Likewise.\n+\t* config/arc/arc.md (stack_irq_dwarf): New unspec instruction.\n+\t* config/arc/arc.opt (mirq-ctrl-saved): New option.\n+\t* doc/invoke.texi (mirq-ctrl-saved): Document option.\n+\n 2017-04-19  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \tTobias Burnus  <tobias.burnus@physik.fu-berlin.de>\n "}, {"sha": "c754d827c81017bff0ceca5d9c095d725ff93b68", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 298, "deletions": 31, "changes": 329, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4145318390da5670b2e571593ccfe7779863b93c/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4145318390da5670b2e571593ccfe7779863b93c/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=4145318390da5670b2e571593ccfe7779863b93c", "patch": "@@ -63,6 +63,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"builtins.h\"\n #include \"rtl-iter.h\"\n #include \"alias.h\"\n+#include \"opts.h\"\n \n /* Which cpu we're compiling for (ARC600, ARC601, ARC700).  */\n static char arc_cpu_name[10] = \"\";\n@@ -111,6 +112,29 @@ struct GTY (()) arc_ccfsm\n   int target_label;\n };\n \n+/* Status of the IRQ_CTRL_AUX register.  */\n+typedef struct irq_ctrl_saved_t\n+{\n+  /* Last register number used by IRQ_CTRL_SAVED aux_reg.  */\n+  short irq_save_last_reg;\n+  /* True if BLINK is automatically saved.  */\n+  bool  irq_save_blink;\n+  /* True if LPCOUNT is automatically saved.  */\n+  bool  irq_save_lpcount;\n+} irq_ctrl_saved_t;\n+static irq_ctrl_saved_t irq_ctrl_saved;\n+\n+#define ARC_AUTOBLINK_IRQ_P(FNTYPE)\t\t\t\t\\\n+  (ARC_INTERRUPT_P (FNTYPE) && irq_ctrl_saved.irq_save_blink)\n+\n+#define ARC_AUTOFP_IRQ_P(FNTYPE)\t\t\t\t\t\\\n+  (ARC_INTERRUPT_P (FNTYPE) && (irq_ctrl_saved.irq_save_last_reg > 26))\n+\n+#define ARC_AUTO_IRQ_P(FNTYPE)\t\t\t\t\\\n+  (ARC_INTERRUPT_P (FNTYPE)\t\t\t\t\\\n+   && (irq_ctrl_saved.irq_save_blink\t\t\t\\\n+       || (irq_ctrl_saved.irq_save_last_reg >= 0)))\n+\n #define arc_ccfsm_current cfun->machine->ccfsm_current\n \n #define ARC_CCFSM_BRANCH_DELETED_P(STATE) \\\n@@ -806,11 +830,110 @@ arc_init (void)\n     }\n }\n \n+/* Parse -mirq-ctrl-saved=RegisterRange, blink, lp_copunt.  The\n+   register range is specified as two registers separated by a dash.\n+   It always starts with r0, and its upper limit is fp register.\n+   blink and lp_count registers are optional.  */\n+\n+static void\n+irq_range (const char *cstr)\n+{\n+  int i, first, last, blink, lpcount, xreg;\n+  char *str, *dash, *comma;\n+\n+  i = strlen (cstr);\n+  str = (char *) alloca (i + 1);\n+  memcpy (str, cstr, i + 1);\n+  blink = -1;\n+  lpcount = -1;\n+\n+  dash = strchr (str, '-');\n+  if (!dash)\n+    {\n+      warning (0, \"value of -mirq-ctrl-saved must have form R0-REGx\");\n+      return;\n+    }\n+  *dash = '\\0';\n+\n+  comma = strchr (dash + 1, ',');\n+  if (comma)\n+    *comma = '\\0';\n+\n+  first = decode_reg_name (str);\n+  if (first != 0)\n+    {\n+      warning (0, \"first register must be R0\");\n+      return;\n+    }\n+\n+  /* At this moment we do not have the register names initialized\n+     accordingly.  */\n+  if (!strcmp (dash + 1, \"ilink\"))\n+    last = 29;\n+  else\n+    last = decode_reg_name (dash + 1);\n+\n+  if (last < 0)\n+    {\n+      warning (0, \"unknown register name: %s\", dash + 1);\n+      return;\n+    }\n+\n+  if (!(last & 0x01))\n+    {\n+      warning (0, \"last register name %s must be an odd register\", dash + 1);\n+      return;\n+    }\n+\n+  *dash = '-';\n+\n+  if (first > last)\n+    {\n+      warning (0, \"%s-%s is an empty range\", str, dash + 1);\n+      return;\n+    }\n+\n+  while (comma)\n+    {\n+      *comma = ',';\n+      str = comma + 1;\n+\n+      comma = strchr (str, ',');\n+      if (comma)\n+\t*comma = '\\0';\n+\n+      xreg = decode_reg_name (str);\n+      switch (xreg)\n+\t{\n+\tcase 31:\n+\t  blink = 31;\n+\t  break;\n+\n+\tcase 60:\n+\t  lpcount = 60;\n+\t  break;\n+\n+\tdefault:\n+\t  warning (0, \"unknown register name: %s\", str);\n+\t  return;\n+\t}\n+    }\n+\n+  irq_ctrl_saved.irq_save_last_reg = last;\n+  irq_ctrl_saved.irq_save_blink    = (blink == 31) || (last == 31);\n+  irq_ctrl_saved.irq_save_lpcount  = (lpcount == 60);\n+}\n+\n /* Check ARC options, generate derived target attributes.  */\n \n static void\n arc_override_options (void)\n {\n+  unsigned int i;\n+  cl_deferred_option *opt;\n+  vec<cl_deferred_option> *vopt\n+    = (vec<cl_deferred_option> *) arc_deferred_options;\n+\n   if (arc_cpu == PROCESSOR_NONE)\n     arc_cpu = TARGET_CPU_DEFAULT;\n \n@@ -839,6 +962,28 @@ arc_override_options (void)\n       gcc_unreachable ();\n     }\n \n+  irq_ctrl_saved.irq_save_last_reg = -1;\n+  irq_ctrl_saved.irq_save_blink    = false;\n+  irq_ctrl_saved.irq_save_lpcount  = false;\n+\n+  /* Handle the deferred options.  */\n+  if (vopt)\n+    FOR_EACH_VEC_ELT (*vopt, i, opt)\n+      {\n+\tswitch (opt->opt_index)\n+\t  {\n+\t  case OPT_mirq_ctrl_saved_:\n+\t    if (TARGET_V2)\n+\t      irq_range (opt->arg);\n+\t    else\n+\t      warning (0, \"option -mirq-ctrl-saved valid only for ARC v2 processors\");\n+\t    break;\n+\n+\t  default:\n+\t    gcc_unreachable();\n+\t  }\n+      }\n+\n   /* Set cpu flags accordingly to architecture/selected cpu.  The cpu\n      specific flags are set in arc-common.c.  The architecture forces\n      the default hardware configurations in, regardless what command\n@@ -2235,14 +2380,52 @@ arc_compute_function_type (struct function *fun)\n    FIXME: This will not be needed if we used some arbitrary register\n    instead of r26.\n */\n-#define MUST_SAVE_REGISTER(regno, interrupt_p) \\\n-(((regno) != RETURN_ADDR_REGNUM && (regno) != FRAME_POINTER_REGNUM \\\n-  && (df_regs_ever_live_p (regno) && (!call_used_regs[regno] || interrupt_p))) \\\n- || (flag_pic && crtl->uses_pic_offset_table \\\n-     && regno == PIC_OFFSET_TABLE_REGNUM) )\n \n-#define MUST_SAVE_RETURN_ADDR \\\n-  (cfun->machine->frame_info.save_return_addr)\n+static bool\n+arc_must_save_register (int regno, struct function *func)\n+{\n+  enum arc_function_type fn_type = arc_compute_function_type (func);\n+  bool irq_auto_save_p = ((irq_ctrl_saved.irq_save_last_reg >= regno)\n+\t\t\t  && ARC_INTERRUPT_P (fn_type));\n+\n+  if ((regno) != RETURN_ADDR_REGNUM\n+      && (regno) != FRAME_POINTER_REGNUM\n+      && df_regs_ever_live_p (regno)\n+      && (!call_used_regs[regno]\n+\t  || ARC_INTERRUPT_P (fn_type))\n+      /* Do not emit code for auto saved regs.  */\n+      && !irq_auto_save_p)\n+    return true;\n+\n+  if (flag_pic && crtl->uses_pic_offset_table\n+      && regno == PIC_OFFSET_TABLE_REGNUM)\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Return true if the return address must be saved in the current function,\n+   otherwise return false.  */\n+\n+static bool\n+arc_must_save_return_addr (struct function *func)\n+{\n+  if (func->machine->frame_info.save_return_addr)\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Helper function to wrap FRAME_POINTER_NEEDED.  We do this as\n+   FRAME_POINTER_NEEDED will not be true until the IRA (Integrated\n+   Register Allocator) pass, while we want to get the frame size\n+   correct earlier than the IRA pass.  */\n+static bool\n+arc_frame_pointer_needed (void)\n+{\n+  return (frame_pointer_needed);\n+}\n+\n \n /* Return non-zero if there are registers to be saved or loaded using\n    millicode thunks.  We can only use consecutive sequences starting\n@@ -2286,8 +2469,6 @@ arc_compute_frame_size (int size)\t/* size = # of var. bytes allocated.  */\n   unsigned int total_size, var_size, args_size, pretend_size, extra_size;\n   unsigned int reg_size, reg_offset;\n   unsigned int gmask;\n-  enum arc_function_type fn_type;\n-  int interrupt_p;\n   struct arc_frame_info *frame_info = &cfun->machine->frame_info;\n \n   size = ARC_STACK_ALIGN (size);\n@@ -2306,15 +2487,13 @@ arc_compute_frame_size (int size)\t/* size = # of var. bytes allocated.  */\n \n   reg_size = 0;\n   gmask = 0;\n-  fn_type = arc_compute_function_type (cfun);\n-  interrupt_p = ARC_INTERRUPT_P (fn_type);\n \n   for (regno = 0; regno <= 31; regno++)\n     {\n-      if (MUST_SAVE_REGISTER (regno, interrupt_p))\n+      if (arc_must_save_register (regno, cfun))\n \t{\n \t  reg_size += UNITS_PER_WORD;\n-\t  gmask |= 1 << regno;\n+\t  gmask |= 1L << regno;\n \t}\n     }\n \n@@ -2330,9 +2509,9 @@ arc_compute_frame_size (int size)\t/* size = # of var. bytes allocated.  */\n     }\n \n   extra_size = 0;\n-  if (MUST_SAVE_RETURN_ADDR)\n+  if (arc_must_save_return_addr (cfun))\n     extra_size = 4;\n-  if (frame_pointer_needed)\n+  if (arc_frame_pointer_needed ())\n     extra_size += 4;\n \n   /* 5) Space for variable arguments passed in registers */\n@@ -2357,7 +2536,7 @@ arc_compute_frame_size (int size)\t/* size = # of var. bytes allocated.  */\n      Frame: pretend_size <blink> reg_size <fp> var_size args_size <--sp\n   */\n   reg_offset = (total_size - (pretend_size + reg_size + extra_size)\n-\t\t+ (frame_pointer_needed ? 4 : 0));\n+\t\t+ (arc_frame_pointer_needed () ? 4 : 0));\n \n   /* Save computed information.  */\n   frame_info->total_size   = total_size;\n@@ -2548,6 +2727,77 @@ arc_save_restore (rtx base_reg,\n int arc_return_address_regs[4]\n   = {0, RETURN_ADDR_REGNUM, ILINK1_REGNUM, ILINK2_REGNUM};\n \n+\n+/* Build dwarf information when the context is saved via AUX_IRQ_CTRL\n+   mechanism.  */\n+\n+static void\n+arc_dwarf_emit_irq_save_regs (void)\n+{\n+  rtx tmp, par, insn, reg;\n+  int i, offset, j;\n+\n+  par = gen_rtx_SEQUENCE (VOIDmode,\n+\t\t\t  rtvec_alloc (irq_ctrl_saved.irq_save_last_reg + 1\n+\t\t\t\t       + irq_ctrl_saved.irq_save_blink\n+\t\t\t\t       + irq_ctrl_saved.irq_save_lpcount\n+\t\t\t\t       + 1));\n+\n+  /* Build the stack adjustment note for unwind info.  */\n+  j = 0;\n+  offset = UNITS_PER_WORD * (irq_ctrl_saved.irq_save_last_reg + 1\n+\t\t\t     + irq_ctrl_saved.irq_save_blink\n+\t\t\t     + irq_ctrl_saved.irq_save_lpcount);\n+  tmp = plus_constant (Pmode, stack_pointer_rtx, -1 * offset);\n+  tmp = gen_rtx_SET (stack_pointer_rtx, tmp);\n+  RTX_FRAME_RELATED_P (tmp) = 1;\n+  XVECEXP (par, 0, j++) = tmp;\n+\n+  offset -= UNITS_PER_WORD;\n+\n+  /* 1st goes LP_COUNT.  */\n+  if (irq_ctrl_saved.irq_save_lpcount)\n+    {\n+      reg = gen_rtx_REG (SImode, 60);\n+      tmp = plus_constant (Pmode, stack_pointer_rtx, offset);\n+      tmp = gen_frame_mem (SImode, tmp);\n+      tmp = gen_rtx_SET (tmp, reg);\n+      RTX_FRAME_RELATED_P (tmp) = 1;\n+      XVECEXP (par, 0, j++) = tmp;\n+      offset -= UNITS_PER_WORD;\n+    }\n+\n+  /* 2nd goes BLINK.  */\n+  if (irq_ctrl_saved.irq_save_blink)\n+    {\n+      reg = gen_rtx_REG (SImode, 31);\n+      tmp = plus_constant (Pmode, stack_pointer_rtx, offset);\n+      tmp = gen_frame_mem (SImode, tmp);\n+      tmp = gen_rtx_SET (tmp, reg);\n+      RTX_FRAME_RELATED_P (tmp) = 1;\n+      XVECEXP (par, 0, j++) = tmp;\n+      offset -= UNITS_PER_WORD;\n+    }\n+\n+  /* Build the parallel of the remaining registers recorded as saved\n+     for unwind.  */\n+  for (i = irq_ctrl_saved.irq_save_last_reg; i >= 0; i--)\n+    {\n+      reg = gen_rtx_REG (SImode, i);\n+      tmp = plus_constant (Pmode, stack_pointer_rtx, offset);\n+      tmp = gen_frame_mem (SImode, tmp);\n+      tmp = gen_rtx_SET (tmp, reg);\n+      RTX_FRAME_RELATED_P (tmp) = 1;\n+      XVECEXP (par, 0, j++) = tmp;\n+      offset -= UNITS_PER_WORD;\n+    }\n+\n+  /* Dummy insn used to anchor the dwarf info.  */\n+  insn = emit_insn (gen_stack_irq_dwarf());\n+  add_reg_note (insn, REG_FRAME_RELATED_EXPR, par);\n+  RTX_FRAME_RELATED_P (insn) = 1;\n+}\n+\n /* Set up the stack and frame pointer (if desired) for the function.  */\n \n void\n@@ -2561,6 +2811,7 @@ arc_expand_prologue (void)\n      Change the stack layout so that we rather store a high register with the\n      PRE_MODIFY, thus enabling more short insn generation.)  */\n   int first_offset = 0;\n+  enum arc_function_type fn_type = arc_compute_function_type (cfun);\n \n   size = ARC_STACK_ALIGN (size);\n \n@@ -2588,16 +2839,25 @@ arc_expand_prologue (void)\n       frame_size_to_allocate -= cfun->machine->frame_info.pretend_size;\n     }\n \n+  /* IRQ using automatic save mechanism will save the register before\n+     anything we do.  */\n+  if (ARC_AUTO_IRQ_P (fn_type))\n+    {\n+      arc_dwarf_emit_irq_save_regs ();\n+    }\n+\n   /* The home-grown ABI says link register is saved first.  */\n-  if (MUST_SAVE_RETURN_ADDR)\n+  if (arc_must_save_return_addr (cfun)\n+      && !ARC_AUTOBLINK_IRQ_P (fn_type))\n     {\n       rtx ra = gen_rtx_REG (SImode, RETURN_ADDR_REGNUM);\n-      rtx mem = gen_frame_mem (Pmode, gen_rtx_PRE_DEC (Pmode, stack_pointer_rtx));\n+      rtx mem = gen_frame_mem (Pmode,\n+\t\t\t       gen_rtx_PRE_DEC (Pmode,\n+\t\t\t\t\t\tstack_pointer_rtx));\n \n       frame_move_inc (mem, ra, stack_pointer_rtx, 0);\n       frame_size_to_allocate -= UNITS_PER_WORD;\n-\n-    } /* MUST_SAVE_RETURN_ADDR */\n+    }\n \n   /* Save any needed call-saved regs (and call-used if this is an\n      interrupt handler) for ARCompact ISA.  */\n@@ -2609,9 +2869,10 @@ arc_expand_prologue (void)\n       frame_size_to_allocate -= cfun->machine->frame_info.reg_size;\n     }\n \n-\n-  /* Save frame pointer if needed.  */\n-  if (frame_pointer_needed)\n+  /* Save frame pointer if needed.  First save the FP on stack, if not\n+     autosaved.  */\n+  if (arc_frame_pointer_needed ()\n+      && !ARC_AUTOFP_IRQ_P (fn_type))\n     {\n       rtx addr = gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n \t\t\t       GEN_INT (-UNITS_PER_WORD + first_offset));\n@@ -2621,6 +2882,11 @@ arc_expand_prologue (void)\n       frame_move_inc (mem, frame_pointer_rtx, stack_pointer_rtx, 0);\n       frame_size_to_allocate -= UNITS_PER_WORD;\n       first_offset = 0;\n+    }\n+\n+  /* Emit mov fp,sp.  */\n+  if (arc_frame_pointer_needed ())\n+    {\n       frame_move (frame_pointer_rtx, stack_pointer_rtx);\n     }\n \n@@ -2675,13 +2941,13 @@ arc_expand_epilogue (int sibcall_p)\n      sp, but don't restore sp if we don't have to.  */\n \n   if (!can_trust_sp_p)\n-    gcc_assert (frame_pointer_needed);\n+    gcc_assert (arc_frame_pointer_needed ());\n \n   /* Restore stack pointer to the beginning of saved register area for\n      ARCompact ISA.  */\n   if (frame_size)\n     {\n-      if (frame_pointer_needed)\n+      if (arc_frame_pointer_needed ())\n \tframe_move (stack_pointer_rtx, frame_pointer_rtx);\n       else\n \tfirst_offset = frame_size;\n@@ -2692,7 +2958,8 @@ arc_expand_epilogue (int sibcall_p)\n \n \n   /* Restore any saved registers.  */\n-  if (frame_pointer_needed)\n+  if (arc_frame_pointer_needed ()\n+      && !ARC_AUTOFP_IRQ_P (fn_type))\n     {\n       rtx addr = gen_rtx_POST_INC (Pmode, stack_pointer_rtx);\n \n@@ -2730,14 +2997,15 @@ arc_expand_epilogue (int sibcall_p)\n \t    : satisfies_constraint_C2a (GEN_INT (first_offset))))\n        /* Also do this if we have both gprs and return\n \t  address to restore, and they both would need a LIMM.  */\n-       || (MUST_SAVE_RETURN_ADDR\n-\t   && !SMALL_INT ((cfun->machine->frame_info.reg_size + first_offset) >> 2)\n-\t   && cfun->machine->frame_info.gmask))\n+      || (arc_must_save_return_addr (cfun)\n+\t  && !SMALL_INT ((cfun->machine->frame_info.reg_size + first_offset) >> 2)\n+\t  && cfun->machine->frame_info.gmask))\n     {\n       frame_stack_add (first_offset);\n       first_offset = 0;\n     }\n-  if (MUST_SAVE_RETURN_ADDR)\n+  if (arc_must_save_return_addr (cfun)\n+      && !ARC_AUTOBLINK_IRQ_P (fn_type))\n     {\n       rtx ra = gen_rtx_REG (Pmode, RETURN_ADDR_REGNUM);\n       int ra_offs = cfun->machine->frame_info.reg_size + first_offset;\n@@ -2802,7 +3070,6 @@ arc_expand_epilogue (int sibcall_p)\n \t\t\t   & ~(FRAME_POINTER_MASK | RETURN_ADDR_MASK), 1, &first_offset);\n     }\n \n-\n   /* The rest of this function does the following:\n      ARCompact    : handle epilogue_delay, restore sp (phase-2), return\n   */"}, {"sha": "2221fb564d8083a01472d96249dc9746b4db0173", "filename": "gcc/config/arc/arc.md", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4145318390da5670b2e571593ccfe7779863b93c/gcc%2Fconfig%2Farc%2Farc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4145318390da5670b2e571593ccfe7779863b93c/gcc%2Fconfig%2Farc%2Farc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.md?ref=4145318390da5670b2e571593ccfe7779863b93c", "patch": "@@ -6241,6 +6241,14 @@\n   [(set (zero_extract:SI (match_dup 3) (match_dup 1) (match_dup 2))\n \t(zero_extract:SI (match_dup 0) (match_dup 1) (match_dup 2)))])\n \n+;; Dummy pattern used as a place holder for automatically saved\n+;; registers.\n+(define_insn \"stack_irq_dwarf\"\n+  [(unspec_volatile [(const_int 1)] VUNSPEC_ARC_STACK_IRQ)]\n+  \"\"\n+  \"\"\n+  [(set_attr \"length\" \"0\")])\n+\n ;; include the arc-FPX instructions\n (include \"fpx.md\")\n "}, {"sha": "483470de7cfa02c60535e5391e8cfbca8d22d119", "filename": "gcc/config/arc/arc.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4145318390da5670b2e571593ccfe7779863b93c/gcc%2Fconfig%2Farc%2Farc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4145318390da5670b2e571593ccfe7779863b93c/gcc%2Fconfig%2Farc%2Farc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.opt?ref=4145318390da5670b2e571593ccfe7779863b93c", "patch": "@@ -486,3 +486,7 @@ Enable use of NPS400 xld/xst extension.\n munaligned-access\n Target Report Var(unaligned_access) Init(UNALIGNED_ACCESS_DEFAULT)\n Enable unaligned word and halfword accesses to packed data.\n+\n+mirq-ctrl-saved=\n+Target RejectNegative Joined Var(arc_deferred_options) Defer\n+Specifies the registers that the processor saves on an interrupt entry and exit."}, {"sha": "6f82e24653f04535e11a729ded556bcb4ce54853", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4145318390da5670b2e571593ccfe7779863b93c/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4145318390da5670b2e571593ccfe7779863b93c/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=4145318390da5670b2e571593ccfe7779863b93c", "patch": "@@ -606,7 +606,7 @@ Objective-C and Objective-C++ Dialects}.\n -mnorm  -mspfp  -mspfp-compact  -mspfp-fast  -msimd  -msoft-float  -mswap @gol\n -mcrc  -mdsp-packa  -mdvbf  -mlock  -mmac-d16  -mmac-24  -mrtsc  -mswape @gol\n -mtelephony  -mxy  -misize  -mannotate-align  -marclinux  -marclinux_prof @gol\n--mlong-calls  -mmedium-calls  -msdata @gol\n+-mlong-calls  -mmedium-calls  -msdata -mirq-ctrl-saved @gol\n -mvolatile-cache  -mtp-regno=@var{regno} @gol\n -malign-call  -mauto-modify-reg  -mbbit-peephole  -mno-brcc @gol\n -mcase-vector-pcrel  -mcompact-casesi  -mno-cond-exec  -mearly-cbranchsi @gol\n@@ -14547,6 +14547,15 @@ hardware extensions.  Not available for ARC EM@.\n \n @end table\n \n+@item -mirq-ctrl-saved=@var{register-range}, @var{blink}, @var{lp_count}\n+@opindex mirq-ctrl-saved\n+Specifies general-purposes registers that the processor automatically\n+saves/restores on interrupt entry and exit.  @var{register-range} is\n+specified as two registers separated by a dash.  The register range\n+always starts with @code{r0}, the upper limit is @code{fp} register.\n+@var{blink} and @var{lp_count} are optional.  This option is only\n+valid for ARC EM and ARC HS cores.\n+\n @end table\n \n The following options are passed through to the assembler, and also"}, {"sha": "0cbe360f697e96b156e1718964ac6d14d6a38ae6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4145318390da5670b2e571593ccfe7779863b93c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4145318390da5670b2e571593ccfe7779863b93c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4145318390da5670b2e571593ccfe7779863b93c", "patch": "@@ -1,3 +1,11 @@\n+2017-05-09  Claudiu Zissulescu  <claziss@synopsys.com>\n+\n+\t* gcc.target/arc/interrupt-5.c: Newfile.\n+\t* gcc.target/arc/interrupt-6.c: Likewise.\n+\t* gcc.target/arc/interrupt-7.c: Likewise.\n+\t* gcc.target/arc/interrupt-8.c: Likewise.\n+\t* gcc.target/arc/interrupt-9.c: Likewise.\n+\n 2017-05-09  Richard Biener  <rguenther@suse.de>\n \n \t* gcc.dg/vect/vect-44.c: Add --param vect-max-peeling-for-alignment=0"}, {"sha": "ee01d760d90bec8b87456707251f4abf63bb1044", "filename": "gcc/testsuite/gcc.target/arc/interrupt-5.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4145318390da5670b2e571593ccfe7779863b93c/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Finterrupt-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4145318390da5670b2e571593ccfe7779863b93c/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Finterrupt-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Finterrupt-5.c?ref=4145318390da5670b2e571593ccfe7779863b93c", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-skip-if \"Not available for ARCv1\" { arc700 ||  arc6xx } } */\n+/* { dg-options \"-O2 -mirq-ctrl-saved=r0-r3,blink\" } */\n+\n+/* Check if the registers R0-R3,blink are automatically saved. */\n+\n+extern int bar (void *);\n+\n+void  __attribute__ ((interrupt(\"ilink\")))\n+foo(void)\n+{\n+  bar (0);\n+  __asm__ volatile ( \"\" : : : \"r0\",\"r1\",\"r2\",\"r3\");\n+}\n+/* { dg-final { scan-assembler-not \"st.*r0,\\\\\\[sp\" } } */\n+/* { dg-final { scan-assembler-not \"st.*r1,\\\\\\[sp\" } } */\n+/* { dg-final { scan-assembler-not \"st.*r2,\\\\\\[sp\" } } */\n+/* { dg-final { scan-assembler-not \"st.*r3,\\\\\\[sp\" } } */\n+/* { dg-final { scan-assembler-not \"push_s blink\" } } */"}, {"sha": "509ff3021248e8207e55b42c0170fd3e53aea66a", "filename": "gcc/testsuite/gcc.target/arc/interrupt-6.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4145318390da5670b2e571593ccfe7779863b93c/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Finterrupt-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4145318390da5670b2e571593ccfe7779863b93c/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Finterrupt-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Finterrupt-6.c?ref=4145318390da5670b2e571593ccfe7779863b93c", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-skip-if \"Not available for ARCv1\" { arc700 || arc6xx } } */\n+/* { dg-options \"-O2 -mirq-ctrl-saved=r0-ilink\" } */\n+\n+#include <alloca.h>\n+\n+/* Check if ilink is recognized. Check how FP and BLINK are saved.\n+   BLINK is saved last on the stack because the IRQ autosave will do\n+   first r0-ilink.  To avoid this ABI exception, one needs to autosave\n+   always blink when using the IRQ autosave feature.  */\n+\n+extern int bar (void *);\n+\n+void  __attribute__ ((interrupt(\"ilink\")))\n+foo(void)\n+{\n+  int *p = alloca (10);\n+  bar (p);\n+}\n+/* { dg-final { scan-assembler-not \".*fp,\\\\\\[sp\" } } */\n+/* { dg-final { scan-assembler \"ld.*blink,\\\\\\[sp\\\\\\]\" } } */\n+/* { dg-final { scan-assembler \"push_s.*blink\" } } */"}, {"sha": "547dfd380bb80a2d867170f1a1670fa96542cc69", "filename": "gcc/testsuite/gcc.target/arc/interrupt-7.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4145318390da5670b2e571593ccfe7779863b93c/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Finterrupt-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4145318390da5670b2e571593ccfe7779863b93c/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Finterrupt-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Finterrupt-7.c?ref=4145318390da5670b2e571593ccfe7779863b93c", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-skip-if \"Not available for ARCv1\" { arc700 ||  arc6xx } } */\n+/* { dg-options \"-O2 -mirq-ctrl-saved=r0-r17,blink\" } */\n+\n+/* Check if the registers R0-R17,blink are automatically saved. */\n+\n+void  __attribute__ ((interrupt(\"ilink\")))\n+foo(void)\n+{\n+  __asm__ volatile ( \"\" : : : \"r13\",\"r14\",\"r15\",\"r16\");\n+}\n+/* { dg-final { scan-assembler-not \"st.*r13,\\\\\\[sp\" } } */\n+/* { dg-final { scan-assembler-not \"st.*r14,\\\\\\[sp\" } } */\n+/* { dg-final { scan-assembler-not \"st.*r15,\\\\\\[sp\" } } */\n+/* { dg-final { scan-assembler-not \"st.*r16,\\\\\\[sp\" } } */\n+/* { dg-final { scan-assembler-not \"push_s blink\" } } */"}, {"sha": "60fd87b43951d36304f1c89cb730d3d13fa6643d", "filename": "gcc/testsuite/gcc.target/arc/interrupt-8.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4145318390da5670b2e571593ccfe7779863b93c/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Finterrupt-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4145318390da5670b2e571593ccfe7779863b93c/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Finterrupt-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Finterrupt-8.c?ref=4145318390da5670b2e571593ccfe7779863b93c", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-skip-if \"Not available for ARCv1\" { arc700 || arc6xx } } */\n+/* { dg-options \"-O2 -mirq-ctrl-saved=r0-r17\" } */\n+\n+/* Check if the registers R0-R17 are automatically saved.  GP is saved\n+   by the compiler.  */\n+\n+int a;\n+\n+void  __attribute__ ((interrupt(\"ilink\")))\n+foo(void)\n+{\n+  __asm__ volatile ( \"\" : : : \"r0\",\"r1\",\"r2\",\"r3\");\n+  __asm__ volatile ( \"\" : : : \"r13\",\"r14\",\"r15\",\"r16\");\n+  a++;\n+}\n+/* { dg-final { scan-assembler-not \"st.*r13,\\\\\\[sp\" } } */\n+/* { dg-final { scan-assembler-not \"st.*r14,\\\\\\[sp\" } } */\n+/* { dg-final { scan-assembler-not \"st.*r15,\\\\\\[sp\" } } */\n+/* { dg-final { scan-assembler-not \"st.*r16,\\\\\\[sp\" } } */\n+/* { dg-final { scan-assembler \"st.*gp,\\\\\\[sp,-4\\\\\\]\" } } */\n+/* { dg-final { scan-assembler \"ld.*gp,\\\\\\[sp\\\\\\]\" } } */\n+/* { dg-final { scan-assembler-not \"st.*r0,\\\\\\[sp\" } } */\n+/* { dg-final { scan-assembler-not \"st.*r1,\\\\\\[sp\" } } */\n+/* { dg-final { scan-assembler-not \"st.*r2,\\\\\\[sp\" } } */\n+/* { dg-final { scan-assembler-not \"st.*r3,\\\\\\[sp\" } } */\n+/* { dg-final { scan-assembler \"rtie\" } } */"}, {"sha": "4547fef8410f141dff93046db60248ac13e1174f", "filename": "gcc/testsuite/gcc.target/arc/interrupt-9.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4145318390da5670b2e571593ccfe7779863b93c/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Finterrupt-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4145318390da5670b2e571593ccfe7779863b93c/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Finterrupt-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Finterrupt-9.c?ref=4145318390da5670b2e571593ccfe7779863b93c", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target archs }*/\n+/* { dg-options \"-O0 -mirq-ctrl-saved=r0-fp\" } */\n+\n+/* Check if we get the move operation between fp and sp.  */\n+\n+void __attribute__ ((interrupt(\"ilink\")))\n+handler1 (void)\n+{\n+  asm (\"\"\n+       :\n+       :\n+       : \"r0\", \"r1\", \"r2\", \"r3\", \"r4\",\n+         \"r5\", \"r6\", \"r7\", \"r8\", \"r9\");\n+}\n+/* { dg-final { scan-assembler \"mov.*fp,sp\" } } */\n+/* { dg-final { scan-assembler-not \".*fp,\\\\\\[sp\" } } */"}]}