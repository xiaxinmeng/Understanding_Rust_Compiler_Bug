{"sha": "81ede53ad7a6db16eee9e9d8896949e928c04d5c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODFlZGU1M2FkN2E2ZGIxNmVlZTllOWQ4ODk2OTQ5ZTkyOGMwNGQ1Yw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2012-11-22T14:42:00Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2012-11-22T14:42:00Z"}, "message": "re PR c++/55137 (Unexpected static structure initialization)\n\n\tPR c++/55137\n\t* semantics.c (verify_constant): Track overflow separately.\n\t(reduced_constant_expression_p): Don't check it here.\n\t(cxx_eval_constant_expression): Check it on CSTs.\n\t(cxx_eval_outermost_constant_expr): Treat overflows as non-constant\n\tat this point, but still return the folded version.\n\t(potential_constant_expression_1): Don't check overflow.\n\nFrom-SVN: r193727", "tree": {"sha": "9c24e24f889471d133a7807f725c04c202a351bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c24e24f889471d133a7807f725c04c202a351bc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/81ede53ad7a6db16eee9e9d8896949e928c04d5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81ede53ad7a6db16eee9e9d8896949e928c04d5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81ede53ad7a6db16eee9e9d8896949e928c04d5c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81ede53ad7a6db16eee9e9d8896949e928c04d5c/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0c0cba54e8c87f02ee4ff2bea9b746f09ef1c8ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c0cba54e8c87f02ee4ff2bea9b746f09ef1c8ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c0cba54e8c87f02ee4ff2bea9b746f09ef1c8ba"}], "stats": {"total": 237, "additions": 122, "deletions": 115}, "files": [{"sha": "c991780dfd871afbfc4c86eac77b80728d739708", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81ede53ad7a6db16eee9e9d8896949e928c04d5c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81ede53ad7a6db16eee9e9d8896949e928c04d5c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=81ede53ad7a6db16eee9e9d8896949e928c04d5c", "patch": "@@ -1,5 +1,13 @@\n 2012-11-22  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/55137\n+\t* semantics.c (verify_constant): Track overflow separately.\n+\t(reduced_constant_expression_p): Don't check it here.\n+\t(cxx_eval_constant_expression): Check it on CSTs.\n+\t(cxx_eval_outermost_constant_expr): Treat overflows as non-constant\n+\tat this point, but still return the folded version.\n+\t(potential_constant_expression_1): Don't check overflow.\n+\n \t* call.c (extend_ref_init_temps_1): Recompute TREE_CONSTANT for\n \tthe ADDR_EXPR.\n "}, {"sha": "eaf706968e4b2ff005207c4c92b90aa2356ba593", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 105, "deletions": 115, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81ede53ad7a6db16eee9e9d8896949e928c04d5c/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81ede53ad7a6db16eee9e9d8896949e928c04d5c/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=81ede53ad7a6db16eee9e9d8896949e928c04d5c", "patch": "@@ -6293,10 +6293,7 @@ typedef struct GTY(()) constexpr_call {\n static GTY ((param_is (constexpr_call))) htab_t constexpr_call_table;\n \n static tree cxx_eval_constant_expression (const constexpr_call *, tree,\n-\t\t\t\t\t  bool, bool, bool *);\n-static tree cxx_eval_vec_perm_expr (const constexpr_call *, tree, bool, bool,\n-\t\t\t\t    bool *);\n-\n+\t\t\t\t\t  bool, bool, bool *, bool *);\n \n /* Compute a hash value for a constexpr call representation.  */\n \n@@ -6422,7 +6419,7 @@ lookup_parameter_binding (const constexpr_call *call, tree t)\n static tree\n cxx_eval_builtin_function_call (const constexpr_call *call, tree t,\n \t\t\t\tbool allow_non_constant, bool addr,\n-\t\t\t\tbool *non_constant_p)\n+\t\t\t\tbool *non_constant_p, bool *overflow_p)\n {\n   const int nargs = call_expr_nargs (t);\n   tree *args = (tree *) alloca (nargs * sizeof (tree));\n@@ -6432,7 +6429,7 @@ cxx_eval_builtin_function_call (const constexpr_call *call, tree t,\n     {\n       args[i] = cxx_eval_constant_expression (call, CALL_EXPR_ARG (t, i),\n \t\t\t\t\t      allow_non_constant, addr,\n-\t\t\t\t\t      non_constant_p);\n+\t\t\t\t\t      non_constant_p, overflow_p);\n       if (allow_non_constant && *non_constant_p)\n \treturn t;\n     }\n@@ -6468,7 +6465,7 @@ static void\n cxx_bind_parameters_in_call (const constexpr_call *old_call, tree t,\n                              constexpr_call *new_call,\n \t\t\t     bool allow_non_constant,\n-\t\t\t     bool *non_constant_p)\n+\t\t\t     bool *non_constant_p, bool *overflow_p)\n {\n   const int nargs = call_expr_nargs (t);\n   tree fun = new_call->fundef->decl;\n@@ -6486,7 +6483,7 @@ cxx_bind_parameters_in_call (const constexpr_call *old_call, tree t,\n       x = get_nth_callarg (t, i);\n       arg = cxx_eval_constant_expression (old_call, x, allow_non_constant,\n \t\t\t\t\t  TREE_CODE (type) == REFERENCE_TYPE,\n-\t\t\t\t\t  non_constant_p);\n+\t\t\t\t\t  non_constant_p, overflow_p);\n       /* Don't VERIFY_CONSTANT here.  */\n       if (*non_constant_p && allow_non_constant)\n \treturn;\n@@ -6551,7 +6548,7 @@ cx_error_context (void)\n static tree\n cxx_eval_call_expression (const constexpr_call *old_call, tree t,\n \t\t\t  bool allow_non_constant, bool addr,\n-\t\t\t  bool *non_constant_p)\n+\t\t\t  bool *non_constant_p, bool *overflow_p)\n {\n   location_t loc = EXPR_LOC_OR_HERE (t);\n   tree fun = get_function_named_in_call (t);\n@@ -6565,7 +6562,7 @@ cxx_eval_call_expression (const constexpr_call *old_call, tree t,\n     {\n       /* Might be a constexpr function pointer.  */\n       fun = cxx_eval_constant_expression (old_call, fun, allow_non_constant,\n-\t\t\t\t\t  /*addr*/false, non_constant_p);\n+\t\t\t\t\t  /*addr*/false, non_constant_p, overflow_p);\n       if (TREE_CODE (fun) == ADDR_EXPR)\n \tfun = TREE_OPERAND (fun, 0);\n     }\n@@ -6581,7 +6578,7 @@ cxx_eval_call_expression (const constexpr_call *old_call, tree t,\n     fun = DECL_CLONED_FUNCTION (fun);\n   if (is_builtin_fn (fun))\n     return cxx_eval_builtin_function_call (old_call, t, allow_non_constant,\n-\t\t\t\t\t   addr, non_constant_p);\n+\t\t\t\t\t   addr, non_constant_p, overflow_p);\n   if (!DECL_DECLARED_CONSTEXPR_P (fun))\n     {\n       if (!allow_non_constant)\n@@ -6598,7 +6595,7 @@ cxx_eval_call_expression (const constexpr_call *old_call, tree t,\n     {\n       tree arg = convert_from_reference (get_nth_callarg (t, 1));\n       return cxx_eval_constant_expression (old_call, arg, allow_non_constant,\n-\t\t\t\t\t   addr, non_constant_p);\n+\t\t\t\t\t   addr, non_constant_p, overflow_p);\n     }\n \n   /* If in direct recursive call, optimize definition search.  */\n@@ -6625,7 +6622,7 @@ cxx_eval_call_expression (const constexpr_call *old_call, tree t,\n         }\n     }\n   cxx_bind_parameters_in_call (old_call, t, &new_call,\n-\t\t\t       allow_non_constant, non_constant_p);\n+\t\t\t       allow_non_constant, non_constant_p, overflow_p);\n   if (*non_constant_p)\n     return t;\n \n@@ -6673,7 +6670,7 @@ cxx_eval_call_expression (const constexpr_call *old_call, tree t,\n \tresult = (cxx_eval_constant_expression\n \t\t  (&new_call, new_call.fundef->body,\n \t\t   allow_non_constant, addr,\n-\t\t   non_constant_p));\n+\t\t   non_constant_p, overflow_p));\n       if (result == error_mark_node)\n \t*non_constant_p = true;\n       if (*non_constant_p)\n@@ -6704,9 +6701,6 @@ cxx_eval_call_expression (const constexpr_call *old_call, tree t,\n bool\n reduced_constant_expression_p (tree t)\n {\n-  if (TREE_OVERFLOW_P (t))\n-    /* Integer overflow makes this not a constant expression.  */\n-    return false;\n   /* FIXME are we calling this too much?  */\n   return initializer_constant_valid_p (t, TREE_TYPE (t)) != NULL_TREE;\n }\n@@ -6721,32 +6715,32 @@ reduced_constant_expression_p (tree t)\n    variable that might be dereferenced later.  */\n \n static bool\n-verify_constant (tree t, bool allow_non_constant, bool *non_constant_p)\n+verify_constant (tree t, bool allow_non_constant, bool *non_constant_p,\n+\t\t bool *overflow_p)\n {\n   if (!*non_constant_p && !reduced_constant_expression_p (t))\n+    {\n+      if (!allow_non_constant)\n+\terror (\"%q+E is not a constant expression\", t);\n+      *non_constant_p = true;\n+    }\n+  if (TREE_OVERFLOW_P (t))\n     {\n       if (!allow_non_constant)\n \t{\n-\t  /* If T was already folded to a _CST with TREE_OVERFLOW set,\n-\t     printing the folded constant isn't helpful.  */\n-\t  if (TREE_OVERFLOW_P (t))\n-\t    {\n-\t      permerror (input_location, \"overflow in constant expression\");\n-\t      /* If we're being permissive (and are in an enforcing\n-\t\t context), consider this constant.  */\n-\t      if (flag_permissive)\n-\t\treturn false;\n-\t    }\n-\t  else\n-\t    error (\"%q+E is not a constant expression\", t);\n+\t  permerror (input_location, \"overflow in constant expression\");\n+\t  /* If we're being permissive (and are in an enforcing\n+\t     context), ignore the overflow.  */\n+\t  if (flag_permissive)\n+\t    return *non_constant_p;\n \t}\n-      *non_constant_p = true;\n+      *overflow_p = true;\n     }\n   return *non_constant_p;\n }\n #define VERIFY_CONSTANT(X)\t\t\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n-  if (verify_constant ((X), allow_non_constant, non_constant_p))\t\\\n+  if (verify_constant ((X), allow_non_constant, non_constant_p, overflow_p)) \\\n     return t;\t\t\t\t\t\t\t\t\\\n  } while (0)\n \n@@ -6758,12 +6752,12 @@ do {\t\t\t\t\t\t\t\t\t\\\n static tree\n cxx_eval_unary_expression (const constexpr_call *call, tree t,\n \t\t\t   bool allow_non_constant, bool addr,\n-\t\t\t   bool *non_constant_p)\n+\t\t\t   bool *non_constant_p, bool *overflow_p)\n {\n   tree r;\n   tree orig_arg = TREE_OPERAND (t, 0);\n   tree arg = cxx_eval_constant_expression (call, orig_arg, allow_non_constant,\n-\t\t\t\t\t   addr, non_constant_p);\n+\t\t\t\t\t   addr, non_constant_p, overflow_p);\n   VERIFY_CONSTANT (arg);\n   if (arg == orig_arg)\n     return t;\n@@ -6778,19 +6772,19 @@ cxx_eval_unary_expression (const constexpr_call *call, tree t,\n static tree\n cxx_eval_binary_expression (const constexpr_call *call, tree t,\n \t\t\t    bool allow_non_constant, bool addr,\n-\t\t\t    bool *non_constant_p)\n+\t\t\t    bool *non_constant_p, bool *overflow_p)\n {\n   tree r;\n   tree orig_lhs = TREE_OPERAND (t, 0);\n   tree orig_rhs = TREE_OPERAND (t, 1);\n   tree lhs, rhs;\n   lhs = cxx_eval_constant_expression (call, orig_lhs,\n \t\t\t\t      allow_non_constant, addr,\n-\t\t\t\t      non_constant_p);\n+\t\t\t\t      non_constant_p, overflow_p);\n   VERIFY_CONSTANT (lhs);\n   rhs = cxx_eval_constant_expression (call, orig_rhs,\n \t\t\t\t      allow_non_constant, addr,\n-\t\t\t\t      non_constant_p);\n+\t\t\t\t      non_constant_p, overflow_p);\n   VERIFY_CONSTANT (rhs);\n   if (lhs == orig_lhs && rhs == orig_rhs)\n     return t;\n@@ -6806,20 +6800,20 @@ cxx_eval_binary_expression (const constexpr_call *call, tree t,\n static tree\n cxx_eval_conditional_expression (const constexpr_call *call, tree t,\n \t\t\t\t bool allow_non_constant, bool addr,\n-\t\t\t\t bool *non_constant_p)\n+\t\t\t\t bool *non_constant_p, bool *overflow_p)\n {\n   tree val = cxx_eval_constant_expression (call, TREE_OPERAND (t, 0),\n \t\t\t\t\t   allow_non_constant, addr,\n-\t\t\t\t\t   non_constant_p);\n+\t\t\t\t\t   non_constant_p, overflow_p);\n   VERIFY_CONSTANT (val);\n   /* Don't VERIFY_CONSTANT the other operands.  */\n   if (integer_zerop (val))\n     return cxx_eval_constant_expression (call, TREE_OPERAND (t, 2),\n \t\t\t\t\t allow_non_constant, addr,\n-\t\t\t\t\t non_constant_p);\n+\t\t\t\t\t non_constant_p, overflow_p);\n   return cxx_eval_constant_expression (call, TREE_OPERAND (t, 1),\n \t\t\t\t       allow_non_constant, addr,\n-\t\t\t\t       non_constant_p);\n+\t\t\t\t       non_constant_p, overflow_p);\n }\n \n /* Subroutine of cxx_eval_constant_expression.\n@@ -6828,12 +6822,12 @@ cxx_eval_conditional_expression (const constexpr_call *call, tree t,\n static tree\n cxx_eval_array_reference (const constexpr_call *call, tree t,\n \t\t\t  bool allow_non_constant, bool addr,\n-\t\t\t  bool *non_constant_p)\n+\t\t\t  bool *non_constant_p, bool *overflow_p)\n {\n   tree oldary = TREE_OPERAND (t, 0);\n   tree ary = cxx_eval_constant_expression (call, oldary,\n \t\t\t\t\t   allow_non_constant, addr,\n-\t\t\t\t\t   non_constant_p);\n+\t\t\t\t\t   non_constant_p, overflow_p);\n   tree index, oldidx;\n   HOST_WIDE_INT i;\n   tree elem_type;\n@@ -6843,7 +6837,7 @@ cxx_eval_array_reference (const constexpr_call *call, tree t,\n   oldidx = TREE_OPERAND (t, 1);\n   index = cxx_eval_constant_expression (call, oldidx,\n \t\t\t\t\tallow_non_constant, false,\n-\t\t\t\t\tnon_constant_p);\n+\t\t\t\t\tnon_constant_p, overflow_p);\n   VERIFY_CONSTANT (index);\n   if (addr && ary == oldary && index == oldidx)\n     return t;\n@@ -6874,7 +6868,7 @@ cxx_eval_array_reference (const constexpr_call *call, tree t,\n \t  tree val = build_value_init (elem_type, tf_warning_or_error);\n \t  return cxx_eval_constant_expression (call, val,\n \t\t\t\t\t       allow_non_constant, addr,\n-\t\t\t\t\t       non_constant_p);\n+\t\t\t\t\t       non_constant_p, overflow_p);\n \t}\n \n       if (!allow_non_constant)\n@@ -6904,7 +6898,7 @@ cxx_eval_array_reference (const constexpr_call *call, tree t,\n static tree\n cxx_eval_component_reference (const constexpr_call *call, tree t,\n \t\t\t      bool allow_non_constant, bool addr,\n-\t\t\t      bool *non_constant_p)\n+\t\t\t      bool *non_constant_p, bool *overflow_p)\n {\n   unsigned HOST_WIDE_INT i;\n   tree field;\n@@ -6913,7 +6907,7 @@ cxx_eval_component_reference (const constexpr_call *call, tree t,\n   tree orig_whole = TREE_OPERAND (t, 0);\n   tree whole = cxx_eval_constant_expression (call, orig_whole,\n \t\t\t\t\t     allow_non_constant, addr,\n-\t\t\t\t\t     non_constant_p);\n+\t\t\t\t\t     non_constant_p, overflow_p);\n   if (whole == orig_whole)\n     return t;\n   if (addr)\n@@ -6955,7 +6949,7 @@ cxx_eval_component_reference (const constexpr_call *call, tree t,\n   value = build_value_init (TREE_TYPE (t), tf_warning_or_error);\n   return cxx_eval_constant_expression (call, value,\n \t\t\t\t       allow_non_constant, addr,\n-\t\t\t\t       non_constant_p);\n+\t\t\t\t       non_constant_p, overflow_p);\n }\n \n /* Subroutine of cxx_eval_constant_expression.\n@@ -6965,15 +6959,15 @@ cxx_eval_component_reference (const constexpr_call *call, tree t,\n static tree\n cxx_eval_bit_field_ref (const constexpr_call *call, tree t,\n \t\t\tbool allow_non_constant, bool addr,\n-\t\t\tbool *non_constant_p)\n+\t\t\tbool *non_constant_p, bool *overflow_p)\n {\n   tree orig_whole = TREE_OPERAND (t, 0);\n   tree retval, fldval, utype, mask;\n   bool fld_seen = false;\n   HOST_WIDE_INT istart, isize;\n   tree whole = cxx_eval_constant_expression (call, orig_whole,\n \t\t\t\t\t     allow_non_constant, addr,\n-\t\t\t\t\t     non_constant_p);\n+\t\t\t\t\t     non_constant_p, overflow_p);\n   tree start, field, value;\n   unsigned HOST_WIDE_INT i;\n \n@@ -7045,18 +7039,18 @@ static tree\n cxx_eval_logical_expression (const constexpr_call *call, tree t,\n                              tree bailout_value, tree continue_value,\n \t\t\t     bool allow_non_constant, bool addr,\n-\t\t\t     bool *non_constant_p)\n+\t\t\t     bool *non_constant_p, bool *overflow_p)\n {\n   tree r;\n   tree lhs = cxx_eval_constant_expression (call, TREE_OPERAND (t, 0),\n \t\t\t\t\t   allow_non_constant, addr,\n-\t\t\t\t\t   non_constant_p);\n+\t\t\t\t\t   non_constant_p, overflow_p);\n   VERIFY_CONSTANT (lhs);\n   if (tree_int_cst_equal (lhs, bailout_value))\n     return lhs;\n   gcc_assert (tree_int_cst_equal (lhs, continue_value));\n   r = cxx_eval_constant_expression (call, TREE_OPERAND (t, 1),\n-\t\t\t\t    allow_non_constant, addr, non_constant_p);\n+\t\t\t\t    allow_non_constant, addr, non_constant_p, overflow_p);\n   VERIFY_CONSTANT (r);\n   return r;\n }\n@@ -7098,7 +7092,7 @@ base_field_constructor_elt (vec<constructor_elt, va_gc> *v, tree ref)\n static tree\n cxx_eval_bare_aggregate (const constexpr_call *call, tree t,\n \t\t\t bool allow_non_constant, bool addr,\n-\t\t\t bool *non_constant_p)\n+\t\t\t bool *non_constant_p, bool *overflow_p)\n {\n   vec<constructor_elt, va_gc> *v = CONSTRUCTOR_ELTS (t);\n   vec<constructor_elt, va_gc> *n;\n@@ -7111,7 +7105,7 @@ cxx_eval_bare_aggregate (const constexpr_call *call, tree t,\n     {\n       tree elt = cxx_eval_constant_expression (call, ce->value,\n \t\t\t\t\t       allow_non_constant, addr,\n-\t\t\t\t\t       non_constant_p);\n+\t\t\t\t\t       non_constant_p, overflow_p);\n       /* Don't VERIFY_CONSTANT here.  */\n       if (allow_non_constant && *non_constant_p)\n \tgoto fail;\n@@ -7160,7 +7154,7 @@ cxx_eval_bare_aggregate (const constexpr_call *call, tree t,\n static tree\n cxx_eval_vec_init_1 (const constexpr_call *call, tree atype, tree init,\n \t\t     bool value_init, bool allow_non_constant, bool addr,\n-\t\t     bool *non_constant_p)\n+\t\t     bool *non_constant_p, bool *overflow_p)\n {\n   tree elttype = TREE_TYPE (atype);\n   int max = tree_low_cst (array_type_nelts (atype), 0);\n@@ -7180,7 +7174,7 @@ cxx_eval_vec_init_1 (const constexpr_call *call, tree atype, tree init,\n     {\n       init = build_value_init (elttype, tf_warning_or_error);\n       init = cxx_eval_constant_expression\n-\t    (call, init, allow_non_constant, addr, non_constant_p);\n+\t    (call, init, allow_non_constant, addr, non_constant_p, overflow_p);\n       pre_init = true;\n     }\n   else if (!init)\n@@ -7191,7 +7185,7 @@ cxx_eval_vec_init_1 (const constexpr_call *call, tree atype, tree init,\n \t\t\t\t\ttf_warning_or_error);\n       release_tree_vector (argvec);\n       init = cxx_eval_constant_expression (call, init, allow_non_constant,\n-\t\t\t\t\t   addr, non_constant_p);\n+\t\t\t\t\t   addr, non_constant_p, overflow_p);\n       pre_init = true;\n     }\n \n@@ -7212,7 +7206,7 @@ cxx_eval_vec_init_1 (const constexpr_call *call, tree atype, tree init,\n \t\t\t\t\t  tf_warning_or_error);\n \t  eltinit = cxx_eval_vec_init_1 (call, elttype, eltinit, value_init,\n \t\t\t\t\t allow_non_constant, addr,\n-\t\t\t\t\t non_constant_p);\n+\t\t\t\t\t non_constant_p, overflow_p);\n \t}\n       else if (pre_init)\n \t{\n@@ -7240,7 +7234,7 @@ cxx_eval_vec_init_1 (const constexpr_call *call, tree atype, tree init,\n \t\t      elttype, LOOKUP_NORMAL, tf_warning_or_error));\n \t  release_tree_vector (argvec);\n \t  eltinit = cxx_eval_constant_expression\n-\t    (call, eltinit, allow_non_constant, addr, non_constant_p);\n+\t    (call, eltinit, allow_non_constant, addr, non_constant_p, overflow_p);\n \t}\n       if (*non_constant_p && !allow_non_constant)\n \tgoto fail;\n@@ -7262,13 +7256,13 @@ cxx_eval_vec_init_1 (const constexpr_call *call, tree atype, tree init,\n static tree\n cxx_eval_vec_init (const constexpr_call *call, tree t,\n \t\t   bool allow_non_constant, bool addr,\n-\t\t   bool *non_constant_p)\n+\t\t   bool *non_constant_p, bool *overflow_p)\n {\n   tree atype = TREE_TYPE (t);\n   tree init = VEC_INIT_EXPR_INIT (t);\n   tree r = cxx_eval_vec_init_1 (call, atype, init,\n \t\t\t\tVEC_INIT_EXPR_VALUE_INIT (t),\n-\t\t\t\tallow_non_constant, addr, non_constant_p);\n+\t\t\t\tallow_non_constant, addr, non_constant_p, overflow_p);\n   if (*non_constant_p)\n     return t;\n   else\n@@ -7458,11 +7452,11 @@ cxx_fold_indirect_ref (location_t loc, tree type, tree op0, bool *empty_base)\n static tree\n cxx_eval_indirect_ref (const constexpr_call *call, tree t,\n \t\t       bool allow_non_constant, bool addr,\n-\t\t       bool *non_constant_p)\n+\t\t       bool *non_constant_p, bool *overflow_p)\n {\n   tree orig_op0 = TREE_OPERAND (t, 0);\n   tree op0 = cxx_eval_constant_expression (call, orig_op0, allow_non_constant,\n-\t\t\t\t\t   /*addr*/false, non_constant_p);\n+\t\t\t\t\t   /*addr*/false, non_constant_p, overflow_p);\n   bool empty_base = false;\n   tree r;\n \n@@ -7475,7 +7469,7 @@ cxx_eval_indirect_ref (const constexpr_call *call, tree t,\n \n   if (r)\n     r = cxx_eval_constant_expression (call, r, allow_non_constant,\n-\t\t\t\t      addr, non_constant_p);\n+\t\t\t\t      addr, non_constant_p, overflow_p);\n   else\n     {\n       tree sub = op0;\n@@ -7568,7 +7562,7 @@ non_const_var_error (tree r)\n static tree\n cxx_eval_vec_perm_expr (const constexpr_call *call, tree t, \n \t\t\tbool allow_non_constant, bool addr,\n-\t\t\tbool * non_constant_p)\n+\t\t\tbool *non_constant_p, bool *overflow_p)\n {\n   int i;\n   tree args[3];\n@@ -7579,7 +7573,7 @@ cxx_eval_vec_perm_expr (const constexpr_call *call, tree t,\n     {\n       args[i] = cxx_eval_constant_expression (call, TREE_OPERAND (t, i),\n \t\t\t\t\t      allow_non_constant, addr,\n-\t\t\t\t\t      non_constant_p);\n+\t\t\t\t\t      non_constant_p, overflow_p);\n       if (*non_constant_p)\n       \tgoto fail;\n     }\n@@ -7604,7 +7598,7 @@ cxx_eval_vec_perm_expr (const constexpr_call *call, tree t,\n static tree\n cxx_eval_constant_expression (const constexpr_call *call, tree t,\n \t\t\t      bool allow_non_constant, bool addr,\n-\t\t\t      bool *non_constant_p)\n+\t\t\t      bool *non_constant_p, bool *overflow_p)\n {\n   tree r = t;\n \n@@ -7617,6 +7611,8 @@ cxx_eval_constant_expression (const constexpr_call *call, tree t,\n     {\n       if (TREE_CODE (t) == PTRMEM_CST)\n \tt = cplus_expand_constant (t);\n+      else if (TREE_OVERFLOW (t) && (!flag_permissive || allow_non_constant))\n+\t*overflow_p = true;\n       return t;\n     }\n   if (TREE_CODE (t) != NOP_EXPR\n@@ -7673,7 +7669,7 @@ cxx_eval_constant_expression (const constexpr_call *call, tree t,\n     case CALL_EXPR:\n     case AGGR_INIT_EXPR:\n       r = cxx_eval_call_expression (call, t, allow_non_constant, addr,\n-\t\t\t\t    non_constant_p);\n+\t\t\t\t    non_constant_p, overflow_p);\n       break;\n \n     case TARGET_EXPR:\n@@ -7694,7 +7690,7 @@ cxx_eval_constant_expression (const constexpr_call *call, tree t,\n \t initialization of a temporary.  */\n       r = cxx_eval_constant_expression (call, TREE_OPERAND (t, 1),\n \t\t\t\t\tallow_non_constant, false,\n-\t\t\t\t\tnon_constant_p);\n+\t\t\t\t\tnon_constant_p, overflow_p);\n       if (!*non_constant_p)\n \t/* Adjust the type of the result to the type of the temporary.  */\n \tr = adjust_temp_type (TREE_TYPE (t), r);\n@@ -7703,7 +7699,7 @@ cxx_eval_constant_expression (const constexpr_call *call, tree t,\n     case SCOPE_REF:\n       r = cxx_eval_constant_expression (call, TREE_OPERAND (t, 1),\n \t\t\t\t\tallow_non_constant, addr,\n-\t\t\t\t\tnon_constant_p);\n+\t\t\t\t\tnon_constant_p, overflow_p);\n       break;\n \n     case RETURN_EXPR:\n@@ -7714,15 +7710,15 @@ cxx_eval_constant_expression (const constexpr_call *call, tree t,\n     case SAVE_EXPR:\n       r = cxx_eval_constant_expression (call, TREE_OPERAND (t, 0),\n \t\t\t\t\tallow_non_constant, addr,\n-\t\t\t\t\tnon_constant_p);\n+\t\t\t\t\tnon_constant_p, overflow_p);\n       break;\n \n       /* These differ from cxx_eval_unary_expression in that this doesn't\n \t check for a constant operand or result; an address can be\n \t constant without its operand being, and vice versa.  */\n     case INDIRECT_REF:\n       r = cxx_eval_indirect_ref (call, t, allow_non_constant, addr,\n-\t\t\t\t non_constant_p);\n+\t\t\t\t non_constant_p, overflow_p);\n       break;\n \n     case ADDR_EXPR:\n@@ -7731,7 +7727,7 @@ cxx_eval_constant_expression (const constexpr_call *call, tree t,\n \ttree op = cxx_eval_constant_expression (call, oldop,\n \t\t\t\t\t\tallow_non_constant,\n \t\t\t\t\t\t/*addr*/true,\n-\t\t\t\t\t\tnon_constant_p);\n+\t\t\t\t\t\tnon_constant_p, overflow_p);\n \t/* Don't VERIFY_CONSTANT here.  */\n \tif (*non_constant_p)\n \t  return t;\n@@ -7753,7 +7749,7 @@ cxx_eval_constant_expression (const constexpr_call *call, tree t,\n     case TRUTH_NOT_EXPR:\n     case FIXED_CONVERT_EXPR:\n       r = cxx_eval_unary_expression (call, t, allow_non_constant, addr,\n-\t\t\t\t     non_constant_p);\n+\t\t\t\t     non_constant_p, overflow_p);\n       break;\n \n     case SIZEOF_EXPR:\n@@ -7782,15 +7778,15 @@ cxx_eval_constant_expression (const constexpr_call *call, tree t,\n \tif ((TREE_CODE (op0) == TARGET_EXPR && op1 == TARGET_EXPR_SLOT (op0))\n \t    || TREE_CODE (op1) == EMPTY_CLASS_EXPR)\n \t  r = cxx_eval_constant_expression (call, op0, allow_non_constant,\n-\t\t\t\t\t    addr, non_constant_p);\n+\t\t\t\t\t    addr, non_constant_p, overflow_p);\n \telse\n \t  {\n \t    /* Check that the LHS is constant and then discard it.  */\n \t    cxx_eval_constant_expression (call, op0, allow_non_constant,\n-\t\t\t\t\t  false, non_constant_p);\n+\t\t\t\t\t  false, non_constant_p, overflow_p);\n \t    op1 = TREE_OPERAND (t, 1);\n \t    r = cxx_eval_constant_expression (call, op1, allow_non_constant,\n-\t\t\t\t\t      addr, non_constant_p);\n+\t\t\t\t\t      addr, non_constant_p, overflow_p);\n \t  }\n       }\n       break;\n@@ -7834,7 +7830,7 @@ cxx_eval_constant_expression (const constexpr_call *call, tree t,\n     case RANGE_EXPR:\n     case COMPLEX_EXPR:\n       r = cxx_eval_binary_expression (call, t, allow_non_constant, addr,\n-\t\t\t\t      non_constant_p);\n+\t\t\t\t      non_constant_p, overflow_p);\n       break;\n \n       /* fold can introduce non-IF versions of these; still treat them as\n@@ -7844,41 +7840,41 @@ cxx_eval_constant_expression (const constexpr_call *call, tree t,\n       r = cxx_eval_logical_expression (call, t, boolean_false_node,\n \t\t\t\t       boolean_true_node,\n \t\t\t\t       allow_non_constant, addr,\n-\t\t\t\t       non_constant_p);\n+\t\t\t\t       non_constant_p, overflow_p);\n       break;\n \n     case TRUTH_OR_EXPR:\n     case TRUTH_ORIF_EXPR:\n       r = cxx_eval_logical_expression (call, t, boolean_true_node,\n \t\t\t\t       boolean_false_node,\n \t\t\t\t       allow_non_constant, addr,\n-\t\t\t\t       non_constant_p);\n+\t\t\t\t       non_constant_p, overflow_p);\n       break;\n \n     case ARRAY_REF:\n       r = cxx_eval_array_reference (call, t, allow_non_constant, addr,\n-\t\t\t\t    non_constant_p);\n+\t\t\t\t    non_constant_p, overflow_p);\n       break;\n \n     case COMPONENT_REF:\n       r = cxx_eval_component_reference (call, t, allow_non_constant, addr,\n-\t\t\t\t\tnon_constant_p);\n+\t\t\t\t\tnon_constant_p, overflow_p);\n       break;\n \n     case BIT_FIELD_REF:\n       r = cxx_eval_bit_field_ref (call, t, allow_non_constant, addr,\n-\t\t\t\t  non_constant_p);\n+\t\t\t\t  non_constant_p, overflow_p);\n       break;\n \n     case COND_EXPR:\n     case VEC_COND_EXPR:\n       r = cxx_eval_conditional_expression (call, t, allow_non_constant, addr,\n-\t\t\t\t\t   non_constant_p);\n+\t\t\t\t\t   non_constant_p, overflow_p);\n       break;\n \n     case CONSTRUCTOR:\n       r = cxx_eval_bare_aggregate (call, t, allow_non_constant, addr,\n-\t\t\t\t   non_constant_p);\n+\t\t\t\t   non_constant_p, overflow_p);\n       break;\n \n     case VEC_INIT_EXPR:\n@@ -7888,12 +7884,12 @@ cxx_eval_constant_expression (const constexpr_call *call, tree t,\n \t or xvalue of the same type, meaning direct-initialization from the\n \t corresponding member.  */\n       r = cxx_eval_vec_init (call, t, allow_non_constant, addr,\n-\t\t\t     non_constant_p);\n+\t\t\t     non_constant_p, overflow_p);\n       break;\n \n     case VEC_PERM_EXPR:\n       r = cxx_eval_vec_perm_expr (call, t, allow_non_constant, addr,\n-\t\t\t\t  non_constant_p);\n+\t\t\t\t  non_constant_p, overflow_p);\n       break;\n \n     case CONVERT_EXPR:\n@@ -7903,7 +7899,7 @@ cxx_eval_constant_expression (const constexpr_call *call, tree t,\n \ttree oldop = TREE_OPERAND (t, 0);\n \ttree op = cxx_eval_constant_expression (call, oldop,\n \t\t\t\t\t\tallow_non_constant, addr,\n-\t\t\t\t\t\tnon_constant_p);\n+\t\t\t\t\t\tnon_constant_p, overflow_p);\n \tif (*non_constant_p)\n \t  return t;\n \tif (op == oldop)\n@@ -7972,10 +7968,11 @@ static tree\n cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant)\n {\n   bool non_constant_p = false;\n+  bool overflow_p = false;\n   tree r = cxx_eval_constant_expression (NULL, t, allow_non_constant,\n-\t\t\t\t\t false, &non_constant_p);\n+\t\t\t\t\t false, &non_constant_p, &overflow_p);\n \n-  verify_constant (r, allow_non_constant, &non_constant_p);\n+  verify_constant (r, allow_non_constant, &non_constant_p, &overflow_p);\n \n   if (TREE_CODE (t) != CONSTRUCTOR\n       && cp_has_mutable_p (TREE_TYPE (t)))\n@@ -8003,21 +8000,26 @@ cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant)\n       non_constant_p = true;\n     }\n \n+  if (!non_constant_p && overflow_p)\n+    non_constant_p = true;\n+\n   if (non_constant_p && !allow_non_constant)\n     return error_mark_node;\n-  else if (non_constant_p && TREE_CONSTANT (t))\n+  else if (non_constant_p && TREE_CONSTANT (r))\n     {\n       /* This isn't actually constant, so unset TREE_CONSTANT.  */\n-      if (EXPR_P (t) || TREE_CODE (t) == CONSTRUCTOR)\n-\tr = copy_node (t);\n+      if (EXPR_P (r))\n+\tr = copy_node (r);\n+      else if (TREE_CODE (r) == CONSTRUCTOR)\n+\tr = build1 (VIEW_CONVERT_EXPR, TREE_TYPE (r), r);\n       else\n-\tr = build_nop (TREE_TYPE (t), t);\n+\tr = build_nop (TREE_TYPE (r), r);\n       TREE_CONSTANT (r) = false;\n-      return r;\n     }\n   else if (non_constant_p || r == t)\n     return t;\n-  else if (TREE_CODE (r) == CONSTRUCTOR && CLASS_TYPE_P (TREE_TYPE (r)))\n+\n+  if (TREE_CODE (r) == CONSTRUCTOR && CLASS_TYPE_P (TREE_TYPE (r)))\n     {\n       if (TREE_CODE (t) == TARGET_EXPR\n \t  && TARGET_EXPR_INITIAL (t) == r)\n@@ -8040,8 +8042,10 @@ bool\n is_sub_constant_expr (tree t)\n {\n   bool non_constant_p = false;\n-  cxx_eval_constant_expression (NULL, t, true, false, &non_constant_p);\n-  return !non_constant_p;\n+  bool overflow_p = false;\n+  cxx_eval_constant_expression (NULL, t, true, false, &non_constant_p,\n+\t\t\t\t&overflow_p);\n+  return !non_constant_p && !overflow_p;\n }\n \n /* If T represents a constant expression returns its reduced value.\n@@ -8098,8 +8102,7 @@ maybe_constant_init (tree t)\n   if (TREE_CODE (t) == TARGET_EXPR)\n     {\n       tree init = TARGET_EXPR_INITIAL (t);\n-      if (TREE_CODE (init) == CONSTRUCTOR\n-\t  && TREE_CONSTANT (init))\n+      if (TREE_CODE (init) == CONSTRUCTOR)\n \tt = init;\n     }\n   return t;\n@@ -8166,20 +8169,7 @@ potential_constant_expression_1 (tree t, bool want_rval, tsubst_flags_t flags)\n       return false;\n     }\n   if (CONSTANT_CLASS_P (t))\n-    {\n-      if (TREE_OVERFLOW (t))\n-\t{\n-\t  if (flags & tf_error)\n-\t    {\n-\t      permerror (EXPR_LOC_OR_HERE (t),\n-\t\t\t \"overflow in constant expression\");\n-\t      if (flag_permissive)\n-\t\treturn true;\n-\t    }\n-\t  return false;\n-\t}\n-      return true;\n-    }\n+    return true;\n \n   switch (TREE_CODE (t))\n     {"}, {"sha": "9f89c3119b3d5a9c0092119858c8acc76bd69451", "filename": "gcc/testsuite/g++.dg/init/static-init3.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81ede53ad7a6db16eee9e9d8896949e928c04d5c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fstatic-init3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81ede53ad7a6db16eee9e9d8896949e928c04d5c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fstatic-init3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fstatic-init3.C?ref=81ede53ad7a6db16eee9e9d8896949e928c04d5c", "patch": "@@ -0,0 +1,9 @@\n+// PR c++/55137\n+// s should have constant initialization.\n+// { dg-final { scan-assembler-not \"GLOBAL\" } }\n+\n+struct S {\n+  int b;\n+};\n+\n+struct S s = { -1 + (int)(sizeof(int) - 1) };"}]}