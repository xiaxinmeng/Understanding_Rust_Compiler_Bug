{"sha": "bd9c7e238831a76bd4bcd76c043ad92da192246b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQ5YzdlMjM4ODMxYTc2YmQ0YmNkNzZjMDQzYWQ5MmRhMTkyMjQ2Yg==", "commit": {"author": {"name": "Richard Earnshaw", "email": "erich@gnu.org", "date": "1996-05-04T16:13:28Z"}, "committer": {"name": "Richard Earnshaw", "email": "erich@gnu.org", "date": "1996-05-04T16:13:28Z"}, "message": "(arm_select): Declare and initialize.\n\n(all_procs): Add arm7100.\n(arm_override_options): Parse arm_select structure to determine selected\narchitecture and tuning parameters.\n(output_option, output_options): New functions.\n(arm_canonicalize_comparison): New function.\n(arm_gen_movstrqi): Don't add a writeback of the index registers for the\nlast instructions.\n(arm_select_cc_mode): Detect case where mode is carry out of unsigned\narithmetic.\n(output_lcomm_directive): Use bss_section (), and use alignment rather than\nrounding.\n(get_arm_condition_code): Handle CC_Cmode.\n(final_prescan_insn): Avoid boundary case where we would occasionally\ninline MAX_INSNS_SKIPPED+1 insns.  Allow call_insns to be inlined in APCS_32\nmode if they are the last insn in the block.\n\nFrom-SVN: r11921", "tree": {"sha": "84ed75a13991903ed271294c91e5516ad7c713da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/84ed75a13991903ed271294c91e5516ad7c713da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd9c7e238831a76bd4bcd76c043ad92da192246b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd9c7e238831a76bd4bcd76c043ad92da192246b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd9c7e238831a76bd4bcd76c043ad92da192246b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd9c7e238831a76bd4bcd76c043ad92da192246b/comments", "author": null, "committer": null, "parents": [{"sha": "a0b632ecd1662b6980f73a062a8fd9c3da713f6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0b632ecd1662b6980f73a062a8fd9c3da713f6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0b632ecd1662b6980f73a062a8fd9c3da713f6e"}], "stats": {"total": 331, "additions": 267, "deletions": 64}, "files": [{"sha": "5f59a0c9116ea8c75fa48b34af8490d2fbe9b509", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 267, "deletions": 64, "changes": 331, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd9c7e238831a76bd4bcd76c043ad92da192246b/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd9c7e238831a76bd4bcd76c043ad92da192246b/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=bd9c7e238831a76bd4bcd76c043ad92da192246b", "patch": "@@ -130,6 +130,14 @@ static enum arm_cond_code get_arm_condition_code ();\n \f\n /* Initialization code */\n \n+struct arm_cpu_select arm_select[3] =\n+{\n+  /* switch\tname,\t\ttune\tarch */\n+  { (char *)0,\t\"--with-cpu=\",\t1,\t1 },\n+  { (char *)0,\t\"-mcpu=\",\t1,\t1 },\n+  { (char *)0,\t\"-mtune=\",\t1,\t0 },\n+};\n+\n #define FL_CO_PROC    0x01            /* Has external co-processor bus */\n #define FL_FAST_MULT  0x02            /* Fast multiply */\n #define FL_MODE26     0x04            /* 26-bit mode support */\n@@ -167,6 +175,7 @@ static struct processors all_procs[] =\n   {\"arm700i\",\tPROCESSOR_ARM7, FL_CO_PROC | FL_MODE32 | FL_MODE26},\n   {\"arm710\",\tPROCESSOR_ARM7, FL_MODE32 | FL_MODE26},\n   {\"arm710c\",\tPROCESSOR_ARM7, FL_MODE32 | FL_MODE26},\n+  {\"arm7100\",\tPROCESSOR_ARM7, FL_MODE32 | FL_MODE26},\n   {\"arm7500\",\tPROCESSOR_ARM7, FL_MODE32 | FL_MODE26},\n   {\"arm7tdmi\",\tPROCESSOR_ARM7, (FL_CO_PROC | FL_FAST_MULT | FL_MODE32\n \t\t\t\t | FL_ARCH4 | FL_THUMB)},\n@@ -179,6 +188,35 @@ void\n arm_override_options ()\n {\n   int arm_thumb_aware = 0;\n+  int flags = 0;\n+  int i;\n+  struct arm_cpu_select *ptr;\n+\n+  arm_cpu = PROCESSOR_DEFAULT;\n+  arm_select[0].string = TARGET_CPU_DEFAULT;\n+\n+  for (i = 0; i < sizeof (arm_select) / sizeof (arm_select[0]); i++)\n+    {\n+      ptr = &arm_select[i];\n+      if (ptr->string != (char *)0 && ptr->string[0] != '\\0')\n+        {\n+\t  struct processors *sel;\n+\n+          for (sel = all_procs; sel->name != NULL; sel++)\n+            if (! strcmp (ptr->string, sel->name))\n+              {\n+                if (ptr->set_tune_p)\n+                  arm_cpu = sel->type;\n+\n+                if (ptr->set_arch_p)\n+\t\t  flags = sel->flags;\n+                break;\n+              }\n+\n+          if (sel->name == NULL)\n+            error (\"bad value (%s) for %s switch\", ptr->string, ptr->name);\n+        }\n+    }\n \n   if (write_symbols != NO_DEBUG && flag_omit_frame_pointer)\n     warning (\"-g with -fomit-frame-pointer may not give sensible debugging\");\n@@ -188,22 +226,18 @@ arm_override_options ()\n \n   if (TARGET_6)\n     {\n-      warning (\"Option '-m6' deprecated.  Use: '-mapcs-32' or -mcpu-<proc>\");\n+      warning (\"Option '-m6' deprecated.  Use: '-mapcs-32' or -mcpu=<proc>\");\n       target_flags |= ARM_FLAG_APCS_32;\n       arm_cpu = PROCESSOR_ARM6;\n     }\n \n   if (TARGET_3)\n     {\n-      warning (\"Option '-m3' deprecated.  Use: '-mapcs-26' or -mcpu-<proc>\");\n+      warning (\"Option '-m3' deprecated.  Use: '-mapcs-26' or -mcpu=<proc>\");\n       target_flags &= ~ARM_FLAG_APCS_32;\n       arm_cpu = PROCESSOR_ARM2;\n     }\n \n-  if ((TARGET_3 || TARGET_6) && target_cpu_name != NULL)\n-    fatal (\"Incompatible mix of old and new options.  -m%d and -mcpu-%s\",\n-\t   TARGET_3 ? 3 : 6, target_cpu_name);\n-\n   if (TARGET_APCS_REENT && flag_pic)\n     fatal (\"-fpic and -mapcs-reent are incompatible\");\n \n@@ -222,43 +256,18 @@ arm_override_options ()\n       target_flags |= ARM_FLAG_APCS_FRAME;\n     }\n \n-  arm_cpu = TARGET_6 ? PROCESSOR_ARM6: PROCESSOR_ARM2;\n   arm_fpu = FP_HARD;\n \n-  if (target_cpu_name != NULL)\n-    {\n-      char *c = target_cpu_name;\n-      struct processors *proc;\n-\n-      /* Match against the supported types.  */\n-      for (proc = all_procs; proc->name != NULL; proc++)\n-\t{\n-\t  if (strcmp (proc->name, c) == 0)\n-\t    break;\n-\t}\n-\n-      if (proc->name)\n-\t{\n-\t  arm_cpu = proc->type;\n-\n-\t  /* Default value for floating point code... if no co-processor\n-\t     bus, then schedule for emulated floating point.  Otherwise,\n-\t     assume the user has an FPA, unless overridden with -mfpe-...  */\n-\t  if (proc->flags & FL_CO_PROC == 0)\n-\t    arm_fpu = FP_SOFT3;\n-\t  else\n-\t    arm_fpu = FP_HARD;\n-\t  arm_fast_multiply = (proc->flags & FL_FAST_MULT) != 0;\n-\t  arm_arch4 = (proc->flags & FL_ARCH4) != 0;\n-\t  arm_thumb_aware = (proc->flags & FL_THUMB) != 0;\n-\t  /* Processors with a load delay slot can load constants faster,\n-\t     from the pool than it takes to construct them, so reduce the\n-\t     complexity of the constant that we will try to generate\n-\t     inline.  */\n-\t}\n-      else\n-\tfatal (\"Unrecognized cpu type: %s\", target_cpu_name);\n-    }\n+  /* Default value for floating point code... if no co-processor\n+     bus, then schedule for emulated floating point.  Otherwise,\n+     assume the user has an FPA, unless overridden with -mfpe-...  */\n+  if (flags & FL_CO_PROC == 0)\n+    arm_fpu = FP_SOFT3;\n+  else\n+    arm_fpu = FP_HARD;\n+  arm_fast_multiply = (flags & FL_FAST_MULT) != 0;\n+  arm_arch4 = (flags & FL_ARCH4) != 0;\n+  arm_thumb_aware = (flags & FL_THUMB) != 0;\n \n   if (target_fpe_name)\n     {\n@@ -288,6 +297,97 @@ arm_override_options ()\n   arm_prog_mode = TARGET_APCS_32 ? PROG_MODE_PROG32 : PROG_MODE_PROG26;\n }\n \n+#define MAX_LINE 79\n+\n+struct asm_option\n+{\n+  char *string;\n+  int *variable;\n+  int on_value;\n+};\n+\n+static int\n+output_option (file, type, name, pos)\n+     FILE *file;\n+     char *type;\n+     char *name;\n+     int pos;\n+{\n+  int type_len = strlen (type);\n+  int name_len = strlen (name);\n+\n+  if (1 + type_len + name_len + pos > MAX_LINE)\n+    {\n+      fprintf (file, \"\\n%s %s%s\", ASM_COMMENT_START, type, name);\n+      return 3 + type_len + name_len;\n+    }\n+  fprintf (file, \" %s%s\", type, name);\n+  return pos + 1 + type_len + name_len;\n+}\n+\n+static struct { char *name; int value; } m_options[] = TARGET_SWITCHES;\n+extern char *version_string, *language_string;\n+\n+void\n+output_options (file, f_options, f_len, W_options, W_len)\n+     FILE *file;\n+     struct asm_option *f_options;\n+     int f_len;\n+     struct asm_option *W_options;\n+     int W_len;\n+{\n+  int j;\n+  int flags = target_flags;\n+  int pos = 32767;\n+\n+  fprintf (file, \"%s %s %s\", ASM_COMMENT_START, language_string,\n+\t   version_string);\n+\n+  if (optimize)\n+    {\n+      char opt_string[20];\n+      sprintf (opt_string, \"%d\", optimize);\n+      pos = output_option (file, \"-O\", opt_string, pos);\n+    }\n+\n+  if (profile_flag)\n+    pos = output_option (file, \"-p\", \"\", pos);\n+\n+  if (inhibit_warnings)\n+    pos = output_option (file, \"-w\", \"\", pos);\n+\n+  for (j = 0; j < f_len; j++)\n+    {\n+      if (*f_options[j].variable == f_options[j].on_value)\n+\tpos = output_option (file, \"-f\", f_options[j].string, pos);\n+    }\n+\n+  for (j = 0; j < W_len; j++)\n+    {\n+      if (*W_options[j].variable == W_options[j].on_value)\n+\tpos = output_option (file, \"-W\", W_options[j].string, pos);\n+    }\n+\n+  for (j = 0; j < sizeof m_options / sizeof m_options[0]; j++)\n+    {\n+      if (m_options[j].name[0] != '\\0'\n+\t  && m_options[j].value > 0\n+\t  && ((m_options[j].value & flags) == m_options[j].value))\n+\t{\n+\t  pos = output_option (file, \"-m\", m_options[j].name, pos);\n+\t  flags &= ~ m_options[j].value;\n+\t}\n+    }\n+\n+  for (j = 0; j < sizeof (arm_select) / sizeof(arm_select[0]); j++)\n+    if (arm_select[j].string != (char *)0)\n+      pos = output_option (file, arm_select[j].name, arm_select[j].string,\n+\t\t\t   pos);\n+\n+  fputs (\"\\n\\n\", file);\n+}\n+\n+\n \f\n /* Return 1 if it is possible to return using a single instruction */\n \n@@ -960,6 +1060,70 @@ arm_gen_constant (code, mode, val, target, source, subtargets, generate)\n   return insns;\n }\n \n+/* Canonicalize a comparison so that we are more likely to recognize it.\n+   This can be done for a few constant compares, where we can make the\n+   immediate value easier to load.  */\n+enum rtx_code\n+arm_canonicalize_comparison (code, op1)\n+     enum rtx_code code;\n+     rtx *op1;\n+{\n+  HOST_WIDE_INT i = INTVAL (*op1);\n+\n+  switch (code)\n+    {\n+    case EQ:\n+    case NE:\n+      return code;\n+\n+    case GT:\n+    case LE:\n+      if (i != (1 << (HOST_BITS_PER_WIDE_INT - 1) - 1)\n+\t  && (const_ok_for_arm (i+1) || const_ok_for_arm (- (i+1))))\n+\t{\n+\t  *op1 = GEN_INT (i+1);\n+\t  return code == GT ? GE : LT;\n+\t}\n+      break;\n+\n+    case GE:\n+    case LT:\n+      if (i != (1 << (HOST_BITS_PER_WIDE_INT - 1))\n+\t  && (const_ok_for_arm (i-1) || const_ok_for_arm (- (i-1))))\n+\t{\n+\t  *op1 = GEN_INT (i-1);\n+\t  return code == GE ? GT : LE;\n+\t}\n+      break;\n+\n+    case GTU:\n+    case LEU:\n+      if (i != ~0\n+\t  && (const_ok_for_arm (i+1) || const_ok_for_arm (- (i+1))))\n+\t{\n+\t  *op1 = GEN_INT (i + 1);\n+\t  return code == GTU ? GEU : LTU;\n+\t}\n+      break;\n+\n+    case GEU:\n+    case LTU:\n+      if (i != 0\n+\t  && (const_ok_for_arm (i - 1) || const_ok_for_arm (- (i - 1))))\n+\t{\n+\t  *op1 = GEN_INT (i - 1);\n+\t  return code == GEU ? GTU : LEU;\n+\t}\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+\n+  return code;\n+}\n+\t\n+\n /* Handle aggregates that are not laid out in a BLKmode element.\n    This is a sub-element of RETURN_IN_MEMORY.  */\n int\n@@ -2491,20 +2655,27 @@ arm_gen_movstrqi (operands)\n \n   for (i = 0; in_words_to_go >= 2; i+=4)\n     {\n-      emit_insn (arm_gen_load_multiple (0, (in_words_to_go > 4 \n-\t\t\t\t\t    ? 4 : in_words_to_go),\n-                                        src, TRUE, TRUE));\n+      if (in_words_to_go > 4)\n+\temit_insn (arm_gen_load_multiple (0, 4, src, TRUE, TRUE));\n+      else\n+\temit_insn (arm_gen_load_multiple (0, in_words_to_go, src, TRUE, \n+\t\t\t\t\t  FALSE));\n+\n       if (out_words_to_go)\n \t{\n-\t  if (out_words_to_go != 1)\n-\t    emit_insn (arm_gen_store_multiple (0, (out_words_to_go > 4\n-\t\t\t\t\t\t   ? 4 : out_words_to_go),\n-\t\t\t\t\t       dst, TRUE, TRUE));\n+\t  if (out_words_to_go > 4)\n+\t    emit_insn (arm_gen_store_multiple (0, 4, dst, TRUE, TRUE));\n+\t  else if (out_words_to_go != 1)\n+\t    emit_insn (arm_gen_store_multiple (0, out_words_to_go,\n+\t\t\t\t\t       dst, TRUE, \n+\t\t\t\t\t       (last_bytes == 0\n+\t\t\t\t\t\t? FALSE : TRUE)));\n \t  else\n \t    {\n \t      emit_move_insn (gen_rtx (MEM, SImode, dst),\n \t\t\t      gen_rtx (REG, SImode, 0));\n-\t      emit_insn (gen_addsi3 (dst, dst, GEN_INT (4)));\n+\t      if (last_bytes != 0)\n+\t\temit_insn (gen_addsi3 (dst, dst, GEN_INT (4)));\n \t    }\n \t}\n \n@@ -2533,7 +2704,6 @@ arm_gen_movstrqi (operands)\n \tabort ();\n \n       part_bytes_reg = copy_to_mode_reg (SImode, gen_rtx (MEM, SImode, src));\n-      emit_insn (gen_addsi3 (src, src, GEN_INT (4)));\n     }\n \n   if (BYTES_BIG_ENDIAN && last_bytes)\n@@ -2571,10 +2741,11 @@ arm_gen_movstrqi (operands)\n \n \t  emit_move_insn (gen_rtx (MEM, QImode, dst),\n \t\t\t  gen_rtx (SUBREG, QImode, part_bytes_reg, 0));\n-\t  emit_insn (gen_addsi3 (dst, dst, const1_rtx));\n \t  if (--last_bytes)\n \t    {\n \t      rtx tmp = gen_reg_rtx (SImode);\n+\n+\t      emit_insn (gen_addsi3 (dst, dst, const1_rtx));\n \t      emit_insn (gen_lshrsi3 (tmp, part_bytes_reg, GEN_INT (8)));\n \t      part_bytes_reg = tmp;\n \t    }\n@@ -2787,6 +2958,11 @@ arm_select_cc_mode (op, x, y)\n   if (GET_MODE (x) == QImode && (op == EQ || op == NE))\n     return CC_Zmode;\n \n+  if (GET_MODE (x) == SImode && (op == LTU || op == GEU)\n+      && GET_CODE (x) == PLUS\n+      && (rtx_equal_p (XEXP (x, 0), y) || rtx_equal_p (XEXP (x, 1), y)))\n+    return CC_Cmode;\n+\n   return CCmode;\n }\n \n@@ -4845,18 +5021,15 @@ arm_asm_output_label (stream, name)\n    define STATIC COMMON space but merely STATIC BSS space.  */\n \n void\n-output_lcomm_directive (stream, name, size, rounded)\n+output_lcomm_directive (stream, name, size, align)\n      FILE *stream;\n      char *name;\n-     int size, rounded;\n+     int size, align;\n {\n-  fprintf (stream, \"\\n\\t.bss\\t%s .lcomm\\n\", ASM_COMMENT_START);\n-  assemble_name (stream, name);\n-  fprintf (stream, \":\\t.space\\t%d\\n\", rounded);\n-  if (in_text_section ())\n-    fputs (\"\\n\\t.text\\n\", stream);\n-  else\n-    fputs (\"\\n\\t.data\\n\", stream);\n+  bss_section ();\n+  ASM_OUTPUT_ALIGN (stream, floor_log2 (align / BITS_PER_UNIT));\n+  ARM_OUTPUT_LABEL (stream, name);\n+  fprintf (stream, \"\\t.space\\t%d\\n\", size);\n }\n \f\n /* A finite state machine takes care of noticing whether or not instructions\n@@ -4972,6 +5145,14 @@ get_arm_condition_code (comparison)\n \tdefault: abort ();\n \t}\n \n+    case CC_Cmode:\n+      switch (comp_code)\n+      {\n+      case LTU: return ARM_CS;\n+      case GEU: return ARM_CC;\n+      default: abort ();\n+      }\n+      \n     case CCmode:\n       switch (comp_code)\n \t{\n@@ -5096,7 +5277,8 @@ final_prescan_insn (insn, opvec, noperands)\n       || (GET_CODE (body) == SET && GET_CODE (SET_DEST (body)) == PC\n \t  && GET_CODE (SET_SRC (body)) == IF_THEN_ELSE))\n     {\n-      int insns_skipped = 0, fail = FALSE, succeed = FALSE;\n+      int insns_skipped;\n+      int fail = FALSE, succeed = FALSE;\n       /* Flag which part of the IF_THEN_ELSE is the LABEL_REF.  */\n       int then_not_else = TRUE;\n       rtx this_insn = start_insn, label = 0;\n@@ -5137,8 +5319,7 @@ final_prescan_insn (insn, opvec, noperands)\n \t insns are okay, and the label or unconditional branch to the same\n \t label is not too far away, succeed.  */\n       for (insns_skipped = 0;\n-\t   !fail && !succeed && insns_skipped < MAX_INSNS_SKIPPED;\n-\t   insns_skipped++)\n+\t   !fail && !succeed && insns_skipped++ < MAX_INSNS_SKIPPED;)\n \t{\n \t  rtx scanbody;\n \n@@ -5193,7 +5374,29 @@ final_prescan_insn (insn, opvec, noperands)\n \t      /* If using 32-bit addresses the cc is not preserved over\n \t\t calls */\n \t      if (TARGET_APCS_32)\n-\t\tfail = TRUE;\n+\t\t{\n+\t\t  /* Succeed if the following insn is the target label,\n+\t\t     or if the following two insns are a barrier and\n+\t\t     the target label.  */\n+\t\t  this_insn = next_nonnote_insn (this_insn);\n+\t\t  if (this_insn && GET_CODE (this_insn) == BARRIER)\n+\t\t    this_insn = next_nonnote_insn (this_insn);\n+\n+\t\t  if (this_insn && this_insn == label\n+\t\t      && insns_skipped < MAX_INSNS_SKIPPED)\n+\t\t    {\n+\t\t      if (jump_clobbers)\n+\t\t\t{\n+\t\t\t  arm_ccfsm_state = 2;\n+\t\t\t  this_insn = next_nonnote_insn (this_insn);\n+\t\t\t}\n+\t\t      else\n+\t\t\tarm_ccfsm_state = 1;\n+\t\t      succeed = TRUE;\n+\t\t    }\n+\t\t  else\n+\t\t    fail = TRUE;\n+\t\t}\n \t      break;\n \n \t    case JUMP_INSN:"}]}