{"sha": "540d5f4f0215e1cdd2d4a2c89c65e46033298be0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQwZDVmNGYwMjE1ZTFjZGQyZDRhMmM4OWM2NWU0NjAzMzI5OGJlMA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-10-14T13:37:51Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-10-16T08:24:17Z"}, "message": "Refactor vect_get_and_check_slp_defs some more\n\nThis refactors vect_get_and_check_slp_defs so that the ops and def_stmts\narrays are filled for all stmts and operands even when we signal failure.\nThis allows later changes for BB vectorization SLP discovery heuristics.\n\n2020-10-16  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-slp.c (vect_get_and_check_slp_defs): First analyze\n\tall operands and fill in the def_stmts and ops entries.\n\t(vect_def_types_match): New helper.", "tree": {"sha": "4781156774435353b9af4b42b79ff3dfd16d0ed2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4781156774435353b9af4b42b79ff3dfd16d0ed2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/540d5f4f0215e1cdd2d4a2c89c65e46033298be0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/540d5f4f0215e1cdd2d4a2c89c65e46033298be0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/540d5f4f0215e1cdd2d4a2c89c65e46033298be0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/540d5f4f0215e1cdd2d4a2c89c65e46033298be0/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a86623902767122c71c7229150a8b8a79cbb3673", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a86623902767122c71c7229150a8b8a79cbb3673", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a86623902767122c71c7229150a8b8a79cbb3673"}], "stats": {"total": 141, "additions": 82, "deletions": 59}, "files": [{"sha": "cfb79e2651f20e067e3ed1a1d404e381aabbd5a0", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 82, "deletions": 59, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/540d5f4f0215e1cdd2d4a2c89c65e46033298be0/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/540d5f4f0215e1cdd2d4a2c89c65e46033298be0/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=540d5f4f0215e1cdd2d4a2c89c65e46033298be0", "patch": "@@ -356,6 +356,16 @@ can_duplicate_and_interleave_p (vec_info *vinfo, unsigned int count,\n     }\n }\n \n+/* Return true if DTA and DTB match.  */\n+\n+static bool\n+vect_def_types_match (enum vect_def_type dta, enum vect_def_type dtb)\n+{\n+  return (dta == dtb\n+\t  || ((dta == vect_external_def || dta == vect_constant_def)\n+\t      && (dtb == vect_external_def || dtb == vect_constant_def)));\n+}\n+\n /* Get the defs for the rhs of STMT (collect them in OPRNDS_INFO), check that\n    they are of a valid type and that they match the defs of the first stmt of\n    the SLP group (stored in OPRNDS_INFO).  This function tries to match stmts\n@@ -421,9 +431,9 @@ vect_get_and_check_slp_defs (vec_info *vinfo, unsigned char swap,\n \n   bool swapped = (swap != 0);\n   gcc_assert (!swapped || first_op_cond);\n+  enum vect_def_type *dts = XALLOCAVEC (enum vect_def_type, number_of_oprnds);\n   for (i = 0; i < number_of_oprnds; i++)\n     {\n-again:\n       if (first_op_cond)\n \t{\n \t  /* Map indicating how operands of cond_expr should be swapped.  */\n@@ -444,7 +454,7 @@ vect_get_and_check_slp_defs (vec_info *vinfo, unsigned char swap,\n       oprnd_info = (*oprnds_info)[i];\n \n       stmt_vec_info def_stmt_info;\n-      if (!vect_is_simple_use (oprnd, vinfo, &dt, &def_stmt_info))\n+      if (!vect_is_simple_use (oprnd, vinfo, &dts[i], &def_stmt_info))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -457,9 +467,13 @@ vect_get_and_check_slp_defs (vec_info *vinfo, unsigned char swap,\n       if (def_stmt_info && is_pattern_stmt_p (def_stmt_info))\n \toprnd_info->any_pattern = true;\n \n-      tree type = TREE_TYPE (oprnd);\n+      oprnd_info->def_stmts.quick_push (def_stmt_info);\n+      oprnd_info->ops.quick_push (oprnd);\n+\n       if (first)\n \t{\n+\t  tree type = TREE_TYPE (oprnd);\n+\t  dt = dts[i];\n \t  if ((dt == vect_constant_def\n \t       || dt == vect_external_def)\n \t      && !GET_MODE_SIZE (vinfo->vector_mode).is_constant ()\n@@ -480,14 +494,48 @@ vect_get_and_check_slp_defs (vec_info *vinfo, unsigned char swap,\n \t      && REDUC_GROUP_FIRST_ELEMENT (stmt_info)\n \t      && (int)i == STMT_VINFO_REDUC_IDX (stmt_info)\n \t      && def_stmt_info)\n-\t    dt = vect_reduction_def;\n+\t    dts[i] = dt = vect_reduction_def;\n+\n+\t  /* Check the types of the definition.  */\n+\t  switch (dt)\n+\t    {\n+\t    case vect_external_def:\n+\t    case vect_constant_def:\n+\t    case vect_internal_def:\n+\t    case vect_reduction_def:\n+\t    case vect_induction_def:\n+\t      break;\n+\n+\t    default:\n+\t      /* FORNOW: Not supported.  */\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t \"Build SLP failed: illegal type of def %T\\n\",\n+\t\t\t\t oprnd);\n+\t      return -1;\n+\t    }\n+\n \t  oprnd_info->first_dt = dt;\n \t  oprnd_info->first_op_type = type;\n \t}\n-      else\n-\t{\n+    }\n+  if (first)\n+    return 0;\n+\n+  /* Now match the operand definition types to that of the first stmt.  */\n+  for (i = 0; i < number_of_oprnds;)\n+    {\n+      oprnd_info = (*oprnds_info)[i];\n+      dt = dts[i];\n+      stmt_vec_info def_stmt_info = oprnd_info->def_stmts[stmt_num];\n+      oprnd = oprnd_info->ops[stmt_num];\n+      tree type = TREE_TYPE (oprnd);\n+\n \t  if (!types_compatible_p (oprnd_info->first_op_type, type))\n \t    {\n+\t      gcc_assert ((i != commutative_op\n+\t\t\t   && (commutative_op == -1U\n+\t\t\t       || i != commutative_op + 1)));\n \t      if (dump_enabled_p ())\n \t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t\t \"Build SLP failed: different operand types\\n\");\n@@ -499,18 +547,14 @@ vect_get_and_check_slp_defs (vec_info *vinfo, unsigned char swap,\n \t     types for reduction chains: the first stmt must be a\n \t     vect_reduction_def (a phi node), and the rest\n \t     end in the reduction chain.  */\n-\t  if ((oprnd_info->first_dt != dt\n+\t  if ((!vect_def_types_match (oprnd_info->first_dt, dt)\n \t       && !(oprnd_info->first_dt == vect_reduction_def\n \t\t    && !STMT_VINFO_DATA_REF (stmt_info)\n \t\t    && REDUC_GROUP_FIRST_ELEMENT (stmt_info)\n \t\t    && def_stmt_info\n \t\t    && !STMT_VINFO_DATA_REF (def_stmt_info)\n \t\t    && (REDUC_GROUP_FIRST_ELEMENT (def_stmt_info)\n-\t\t\t== REDUC_GROUP_FIRST_ELEMENT (stmt_info)))\n-\t       && !((oprnd_info->first_dt == vect_external_def\n-\t\t     || oprnd_info->first_dt == vect_constant_def)\n-\t\t    && (dt == vect_external_def\n-\t\t\t|| dt == vect_constant_def)))\n+\t\t\t== REDUC_GROUP_FIRST_ELEMENT (stmt_info))))\n \t      || (!STMT_VINFO_DATA_REF (stmt_info)\n \t\t  && REDUC_GROUP_FIRST_ELEMENT (stmt_info)\n \t\t  && ((!def_stmt_info\n@@ -519,69 +563,48 @@ vect_get_and_check_slp_defs (vec_info *vinfo, unsigned char swap,\n \t\t\t   != REDUC_GROUP_FIRST_ELEMENT (stmt_info)))\n \t\t      != (oprnd_info->first_dt != vect_reduction_def))))\n \t    {\n-\t      /* Try swapping operands if we got a mismatch.  */\n+\t      /* Try swapping operands if we got a mismatch.  For BB\n+\t\t vectorization only in case that will improve things.  */\n \t      if (i == commutative_op && !swapped)\n \t\t{\n \t\t  if (dump_enabled_p ())\n \t\t    dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t\t     \"trying swapped operands\\n\");\n+\t\t  std::swap (dts[i], dts[i+1]);\n+\t\t  std::swap ((*oprnds_info)[i]->def_stmts[stmt_num],\n+\t\t\t     (*oprnds_info)[i+1]->def_stmts[stmt_num]);\n+\t\t  std::swap ((*oprnds_info)[i]->ops[stmt_num],\n+\t\t\t     (*oprnds_info)[i+1]->ops[stmt_num]);\n \t\t  swapped = true;\n-\t\t  goto again;\n+\t\t  continue;\n \t\t}\n \n \t      if (dump_enabled_p ())\n \t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t\t \"Build SLP failed: different types\\n\");\n-\n \t      return 1;\n \t    }\n-\t}\n \n-      /* Check the types of the definitions.  */\n-      switch (dt)\n+      /* Make sure to demote the overall operand to external.  */\n+      if (dt == vect_external_def)\n+\toprnd_info->first_dt = vect_external_def;\n+      /* For a SLP reduction chain we want to duplicate the reduction to\n+\t each of the chain members.  That gets us a sane SLP graph (still\n+\t the stmts are not 100% correct wrt the initial values).  */\n+      else if ((dt == vect_internal_def\n+\t\t|| dt == vect_reduction_def)\n+\t       && oprnd_info->first_dt == vect_reduction_def\n+\t       && !STMT_VINFO_DATA_REF (stmt_info)\n+\t       && REDUC_GROUP_FIRST_ELEMENT (stmt_info)\n+\t       && !STMT_VINFO_DATA_REF (def_stmt_info)\n+\t       && (REDUC_GROUP_FIRST_ELEMENT (def_stmt_info)\n+\t\t   == REDUC_GROUP_FIRST_ELEMENT (stmt_info)))\n \t{\n-\tcase vect_external_def:\n-\t  /* Make sure to demote the overall operand to external.  */\n-\t  oprnd_info->first_dt = vect_external_def;\n-\t  /* Fallthru.  */\n-\tcase vect_constant_def:\n-\t  oprnd_info->def_stmts.quick_push (NULL);\n-\t  oprnd_info->ops.quick_push (oprnd);\n-\t  break;\n-\n-\tcase vect_internal_def:\n-\tcase vect_reduction_def:\n-\t  if (oprnd_info->first_dt == vect_reduction_def\n-\t      && !STMT_VINFO_DATA_REF (stmt_info)\n-\t      && REDUC_GROUP_FIRST_ELEMENT (stmt_info)\n-\t      && !STMT_VINFO_DATA_REF (def_stmt_info)\n-\t      && (REDUC_GROUP_FIRST_ELEMENT (def_stmt_info)\n-\t\t  == REDUC_GROUP_FIRST_ELEMENT (stmt_info)))\n-\t    {\n-\t      /* For a SLP reduction chain we want to duplicate the\n-\t         reduction to each of the chain members.  That gets\n-\t\t us a sane SLP graph (still the stmts are not 100%\n-\t\t correct wrt the initial values).  */\n-\t      gcc_assert (!first);\n-\t      oprnd_info->def_stmts.quick_push (oprnd_info->def_stmts[0]);\n-\t      oprnd_info->ops.quick_push (oprnd_info->ops[0]);\n-\t      break;\n-\t    }\n-\t  /* Fallthru.  */\n-\tcase vect_induction_def:\n-\t  oprnd_info->def_stmts.quick_push (def_stmt_info);\n-\t  oprnd_info->ops.quick_push (oprnd);\n-\t  break;\n-\n-\tdefault:\n-\t  /* FORNOW: Not supported.  */\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"Build SLP failed: illegal type of def %T\\n\",\n-\t\t\t     oprnd);\n-\n-\t  return -1;\n+\t  oprnd_info->def_stmts[stmt_num] = oprnd_info->def_stmts[0];\n+\t  oprnd_info->ops[stmt_num] = oprnd_info->ops[0];\n \t}\n+\n+      ++i;\n     }\n \n   /* Swap operands.  */"}]}