{"sha": "1444f2ed7cfaf30f6e50da21f9a74e164f1fad84", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTQ0NGYyZWQ3Y2ZhZjMwZjZlNTBkYTIxZjlhNzRlMTY0ZjFmYWQ4NA==", "commit": {"author": {"name": "Neil Booth", "email": "neil@cat.daikokuya.demon.co.uk", "date": "2001-08-01T06:19:39Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-08-01T06:19:39Z"}, "message": "cpphash.h (struct cpp_reader): New members line, pseudo_newlines.\n\n\t* cpphash.h (struct cpp_reader): New members line, pseudo_newlines.\n\t* cpplex.c (handle_newline): Update prototype.  Maintain logical\n\tline number.\n\t(skip_escaped_newlines, skip_block_comment, parse_string):\n\tUpdate accordingly.\n\t(_cpp_lex_token): Update, and store token position within the token.\n\t* cpplib.h (struct cpp_token): Add line and column entries.\n\t* cppmacro.c (replace_args): Position stringified tokens correctly.\n\nFrom-SVN: r44533", "tree": {"sha": "31a44a63f5280d362281e3aedf7c120f4aed024a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/31a44a63f5280d362281e3aedf7c120f4aed024a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1444f2ed7cfaf30f6e50da21f9a74e164f1fad84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1444f2ed7cfaf30f6e50da21f9a74e164f1fad84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1444f2ed7cfaf30f6e50da21f9a74e164f1fad84", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1444f2ed7cfaf30f6e50da21f9a74e164f1fad84/comments", "author": null, "committer": null, "parents": [{"sha": "7f8a212577aa9bc71a1828635b426c3f2157c3b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f8a212577aa9bc71a1828635b426c3f2157c3b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f8a212577aa9bc71a1828635b426c3f2157c3b6"}], "stats": {"total": 51, "additions": 43, "deletions": 8}, "files": [{"sha": "857a75db7d570791b2aafae523161c6aa034dfc9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1444f2ed7cfaf30f6e50da21f9a74e164f1fad84/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1444f2ed7cfaf30f6e50da21f9a74e164f1fad84/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1444f2ed7cfaf30f6e50da21f9a74e164f1fad84", "patch": "@@ -1,3 +1,14 @@\n+2001-08-01  Neil Booth  <neil@cat.daikokuya.demon.co.uk>\n+\n+\t* cpphash.h (struct cpp_reader): New members line, pseudo_newlines.\n+\t* cpplex.c (handle_newline): Update prototype.  Maintain logical\n+\tline number.\n+\t(skip_escaped_newlines, skip_block_comment, parse_string):\n+\tUpdate accordingly.\n+\t(_cpp_lex_token): Update, and store token position within the token.\n+\t* cpplib.h (struct cpp_token): Add line and column entries.\n+\t* cppmacro.c (replace_args): Position stringified tokens correctly.\n+\n 2001-08-01  Andreas Jaeger  <aj@suse.de>\n \n \t* basic-block.h: Add prototype for last_loop_beg_note."}, {"sha": "12b64a80afa8d102be8e5262e538f1bd8bc8f4d6", "filename": "gcc/cpphash.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1444f2ed7cfaf30f6e50da21f9a74e164f1fad84/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1444f2ed7cfaf30f6e50da21f9a74e164f1fad84/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=1444f2ed7cfaf30f6e50da21f9a74e164f1fad84", "patch": "@@ -246,6 +246,12 @@ struct cpp_reader\n   /* Lexer state.  */\n   struct lexer_state state;\n \n+  /* Source line tracking.  Subtract pseudo_newlines from the actual\n+     line number to get the line number of preprocessed output.  Used\n+     for escaped newlines and macro args that cross multiple lines.  */\n+  unsigned int line;\n+  unsigned int pseudo_newlines;\n+\n   /* The position of the last lexed token and last lexed directive.  */\n   cpp_lexer_pos lexer_pos;\n   cpp_lexer_pos directive_pos;"}, {"sha": "5970442c073a8b320a6083ebbab0e8411f907a0d", "filename": "gcc/cpplex.c", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1444f2ed7cfaf30f6e50da21f9a74e164f1fad84/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1444f2ed7cfaf30f6e50da21f9a74e164f1fad84/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=1444f2ed7cfaf30f6e50da21f9a74e164f1fad84", "patch": "@@ -80,7 +80,7 @@ const struct token_spelling token_spellings [N_TTYPES] = {TTYPE_TABLE };\n #define TOKEN_SPELL(token) (token_spellings[(token)->type].category)\n #define TOKEN_NAME(token) (token_spellings[(token)->type].name)\n \n-static cppchar_t handle_newline PARAMS ((cpp_buffer *, cppchar_t));\n+static cppchar_t handle_newline PARAMS ((cpp_reader *, cppchar_t));\n static cppchar_t skip_escaped_newlines PARAMS ((cpp_buffer *, cppchar_t));\n static cppchar_t get_effective_char PARAMS ((cpp_buffer *));\n \n@@ -124,12 +124,17 @@ cpp_ideq (token, string)\n /* Call when meeting a newline.  Returns the character after the newline\n    (or carriage-return newline combination), or EOF.  */\n static cppchar_t\n-handle_newline (buffer, newline_char)\n-     cpp_buffer *buffer;\n+handle_newline (pfile, newline_char)\n+     cpp_reader *pfile;\n      cppchar_t newline_char;\n {\n+  cpp_buffer *buffer;\n   cppchar_t next = EOF;\n \n+  pfile->line++;\n+  pfile->pseudo_newlines++;\n+\n+  buffer = pfile->buffer;\n   buffer->col_adjust = 0;\n   buffer->lineno++;\n   buffer->line_base = buffer->cur;\n@@ -264,7 +269,7 @@ skip_escaped_newlines (buffer, next)\n \t    cpp_warning (buffer->pfile,\n \t\t\t \"backslash and newline separated by space\");\n \n-\t  next = handle_newline (buffer, next1);\n+\t  next = handle_newline (buffer->pfile, next1);\n \t  if (next == EOF)\n \t    cpp_pedwarn (buffer->pfile, \"backslash-newline at end of file\");\n \t}\n@@ -348,7 +353,7 @@ skip_block_comment (pfile)\n \t}\n       else if (is_vspace (c))\n \t{\n-\t  prevc = c, c = handle_newline (buffer, c);\n+\t  prevc = c, c = handle_newline (pfile, c);\n \t  goto next_char;\n \t}\n       else if (c == '\\t')\n@@ -706,7 +711,7 @@ parse_string (pfile, token, terminator)\n \t  if (pfile->mlstring_pos.line == 0)\n \t    pfile->mlstring_pos = pfile->lexer_pos;\n \t      \n-\t  c = handle_newline (buffer, c);\n+\t  c = handle_newline (pfile, c);\n \t  *dest++ = '\\n';\n \t  goto have_char;\n \t}\n@@ -866,6 +871,7 @@ _cpp_lex_token (pfile, result)\n   buffer->saved_flags = 0;\n  next_char:\n   pfile->lexer_pos.line = buffer->lineno;\n+  result->line = pfile->line;\n  next_char2:\n   pfile->lexer_pos.col = CPP_BUF_COLUMN (buffer, buffer->cur);\n \n@@ -875,6 +881,7 @@ _cpp_lex_token (pfile, result)\n       c = *buffer->cur++;\n       pfile->lexer_pos.col++;\n     }\n+  result->col = pfile->lexer_pos.col;\n \n  do_switch:\n   buffer->read_ahead = EOF;\n@@ -901,7 +908,9 @@ _cpp_lex_token (pfile, result)\n     case '\\n': case '\\r':\n       if (!pfile->state.in_directive)\n \t{\n-\t  handle_newline (buffer, c);\n+\t  handle_newline (pfile, c);\n+\t  if (!pfile->state.parsing_args)\n+\t    pfile->pseudo_newlines = 0;\n \t  bol = 1;\n \t  pfile->lexer_pos.output_line = buffer->lineno;\n \t  /* This is a new line, so clear any white space flag."}, {"sha": "fb7fac276db6c68df1e5ddf0b0079f9598f509df", "filename": "gcc/cpplib.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1444f2ed7cfaf30f6e50da21f9a74e164f1fad84/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1444f2ed7cfaf30f6e50da21f9a74e164f1fad84/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=1444f2ed7cfaf30f6e50da21f9a74e164f1fad84", "patch": "@@ -172,6 +172,8 @@ struct cpp_string\n    occupy 12 bytes on 32-bit hosts and 16 bytes on 64-bit hosts.  */\n struct cpp_token\n {\n+  unsigned int line;\t\t/* Logical line of first char of token.  */\n+  unsigned short col;\t\t/* Column of first char of token.  */\n   ENUM_BITFIELD(cpp_ttype) type : CHAR_BIT;  /* token type */\n   unsigned char flags;\t\t/* flags - see above */\n "}, {"sha": "f8b3a2b0f90cbb46cad84376d0f1d55457decb34", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1444f2ed7cfaf30f6e50da21f9a74e164f1fad84/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1444f2ed7cfaf30f6e50da21f9a74e164f1fad84/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=1444f2ed7cfaf30f6e50da21f9a74e164f1fad84", "patch": "@@ -761,7 +761,12 @@ replace_args (pfile, macro, args, list)\n \n \targ = &args[src->val.arg_no - 1];\n \tif (src->flags & STRINGIFY_ARG)\n-\t  from = arg->stringified, count = 1;\n+\t  {\n+\t    from = arg->stringified, count = 1;\n+\t    /* Ugh.  Maintain position of original argument.  */\n+\t    arg->stringified->line = src->line;\n+\t    arg->stringified->col = src->col;\n+\t  }\n \telse if (src->flags & PASTE_LEFT)\n \t  count = arg->count, from = arg->first;\n \telse if (src > macro->expansion && (src[-1].flags & PASTE_LEFT))\n@@ -923,6 +928,7 @@ cpp_get_token (pfile, token)\n \t  /* PASTE_LEFT tokens can only appear in macro expansions.  */\n \t  if (token->flags & PASTE_LEFT)\n \t    {\n+\t      /* Maintains position of original token.  */\n \t      paste_all_tokens (pfile, token);\n \t      pfile->buffer->saved_flags = AVOID_LPASTE;\n \t    }\n@@ -957,6 +963,7 @@ cpp_get_token (pfile, token)\n \n \t  if (node->flags & NODE_BUILTIN)\n \t    {\n+\t      /* Maintains position of original token.  */\n \t      builtin_macro (pfile, token);\n \t      pfile->buffer->saved_flags = AVOID_LPASTE;\n \t      break;"}]}