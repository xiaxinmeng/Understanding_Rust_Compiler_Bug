{"sha": "b39555b4d7c9b2b95facaf17e61cbd324b3e3f01", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjM5NTU1YjRkN2M5YjJiOTVmYWNhZjE3ZTYxY2JkMzI0YjNlM2YwMQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-02-16T22:13:45Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-02-16T22:13:45Z"}, "message": "(find_reloads_address): Use strict_memory_address_p\nto check for valid indirect address.\n\nFrom-SVN: r3478", "tree": {"sha": "5d5f5fa01292a3009fab675b0bf40491063d209b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d5f5fa01292a3009fab675b0bf40491063d209b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b39555b4d7c9b2b95facaf17e61cbd324b3e3f01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b39555b4d7c9b2b95facaf17e61cbd324b3e3f01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b39555b4d7c9b2b95facaf17e61cbd324b3e3f01", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b39555b4d7c9b2b95facaf17e61cbd324b3e3f01/comments", "author": null, "committer": null, "parents": [{"sha": "c14f2655196e2279377f0f29664a423187ab1491", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c14f2655196e2279377f0f29664a423187ab1491", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c14f2655196e2279377f0f29664a423187ab1491"}], "stats": {"total": 25, "additions": 6, "deletions": 19}, "files": [{"sha": "e0c3d59dc72a6d80e313b947432de0ec852b7065", "filename": "gcc/reload.c", "status": "modified", "additions": 6, "deletions": 19, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b39555b4d7c9b2b95facaf17e61cbd324b3e3f01/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b39555b4d7c9b2b95facaf17e61cbd324b3e3f01/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=b39555b4d7c9b2b95facaf17e61cbd324b3e3f01", "patch": "@@ -3590,25 +3590,12 @@ find_reloads_address (mode, memrefloc, ad, loc, operand, ind_levels)\n \t  return 1;\n \t}\n \n-      else if (reg_equiv_mem[regno] != 0)\n-\t{\n-\t  tem = XEXP (reg_equiv_mem[regno], 0);\n-\n-\t  /* If we can't indirect any more, a pseudo must be reloaded.\n-\t     If the pseudo's address in its MEM is a SYMBOL_REF, it\n-\t     must be reloaded unless indirect_symref_ok.  Otherwise, it\n-\t     can be reloaded if the address is REG or REG + CONST_INT.  */\n-\n-\t  if (ind_levels > 0\n-\t      && ! (GET_CODE (tem) == SYMBOL_REF && ! indirect_symref_ok)\n-\t      && ((GET_CODE (tem) == REG\n-\t\t   && REGNO (tem) < FIRST_PSEUDO_REGISTER)\n-\t\t  || (GET_CODE (tem) == PLUS\n-\t\t      && GET_CODE (XEXP (tem, 0)) == REG\n-\t\t      && REGNO (XEXP (tem, 0)) < FIRST_PSEUDO_REGISTER\n-\t\t      && GET_CODE (XEXP (tem, 1)) == CONST_INT)))\n-\t    return 0;\n-\t}\n+      /* We can avoid a reload if the register's equivalent memory expression\n+\t is valid as an indirect memory address. */\n+\n+      else if (reg_equiv_mem[regno] != 0 && ind_levels > 0\n+\t       && strict_memory_address_p (mode, reg_equiv_mem[regno]))\n+\treturn 0;\n \n       /* The only remaining case where we can avoid a reload is if this is a\n \t hard register that is valid as a base register and which is not the"}]}