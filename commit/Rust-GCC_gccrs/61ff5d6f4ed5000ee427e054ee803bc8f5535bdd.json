{"sha": "61ff5d6f4ed5000ee427e054ee803bc8f5535bdd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjFmZjVkNmY0ZWQ1MDAwZWU0MjdlMDU0ZWU4MDNiYzhmNTUzNWJkZA==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2018-08-27T12:17:19Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2018-08-27T12:17:19Z"}, "message": "Add new gswitch related functions into tree-cfg.c.\n\n2018-08-27  Martin Liska  <mliska@suse.cz>\n\n\t* cfgexpand.c (expand_asm_stmt): Use label_to_block and pass\n        cfun argument explicitly.\n\t* gimple-pretty-print.c (dump_gimple_switch): Likewise.\n\t* hsa-gen.c (gen_hsa_insns_for_switch_stmt): Use new\n        function gimple_switch_default_bb.\n\t(convert_switch_statements):\n\t(expand_builtins):\n\t* ipa-fnsummary.c (set_switch_stmt_execution_predicate):\n\t* stmt.c (label_to_block_fn): Use label_to_block and pass\n        cfun argument explicitly and use gimple_switch_label_bb.\n\t(expand_case): Likewise.\n\t* tree-cfg.c (lower_phi_internal_fn): Use label_to_block and pass\n        cfun argument explicitly. Likewise.\n\t(make_edges_bb): Likewise.\n\t(make_cond_expr_edges): Likewise.\n\t(get_cases_for_edge): Likewise.\n\t(make_gimple_switch_edges): Likewise.\n\t(label_to_block_fn): Likewise.\n\t(label_to_block): Likewise.\n\t(make_goto_expr_edges): Likewise.\n\t(make_gimple_asm_edges): Likewise.\n\t(main_block_label): Likewise.\n\t(group_case_labels_stmt): Likewise.\n\t(find_taken_edge_computed_goto): Likewise.\n\t(find_taken_edge_switch_expr): Likewise.\n\t(gimple_verify_flow_info): Likewise.\n\t(gimple_redirect_edge_and_branch): Likewise.\n\t(gimple_switch_label_bb): New function.\n\t(gimple_switch_default_bb): Likewise.\n\t(gimple_switch_edge): Likewise.\n\t(gimple_switch_default_edge): Likewise.\n\t* tree-cfg.h (label_to_block_fn): Remove and replace ...\n\t(label_to_block): ... with this.\n\t(gimple_switch_label_bb): New.\n\t(gimple_switch_default_bb): Likewise.\n\t(gimple_switch_edge): Likewise.\n\t(gimple_switch_default_edge): Likewise.\n\t* tree-cfgcleanup.c (convert_single_case_switch): Use\n        new gimple functions and pass new argument to label_to_block.\n\t(cleanup_control_flow_bb):\n\t* tree-eh.c (make_eh_dispatch_edges): Use label_to_block and pass\n        cfun argument explicitly.\n\t(make_eh_edges): Likewise.\n\t(redirect_eh_dispatch_edge): Likewise.\n\t(lower_resx): Likewise.\n\t(lower_eh_dispatch): Likewise.\n\t(maybe_remove_unreachable_handlers): Likewise.\n\t(unsplit_eh): Likewise.\n\t(cleanup_empty_eh): Likewise.\n\t(verify_eh_edges): Likewise.\n\t(verify_eh_dispatch_edge): Likewise.\n\t* tree-ssa-dom.c (record_edge_info): Likewise.\n\t* tree-ssa-forwprop.c (simplify_gimple_switch_label_vec): Likewise.\n\t* tree-ssa-threadedge.c (thread_around_empty_blocks): Likewise.\n\t(thread_through_normal_block): Likewise.\n\t* tree-ssa-uncprop.c (associate_equivalences_with_edges): Likewise.\n\t* tree-ssa-uninit.c (convert_control_dep_chain_into_preds):\n\t* tree-switch-conversion.c (switch_conversion::collect): Use new\n        gimple functions.\n\t(switch_conversion::check_final_bb): Likewise.\n\t(switch_conversion::gather_default_values): Pass new argument\n        to label_to_block.\n\t(switch_conversion::build_constructors): Likewise.\n\t(switch_decision_tree::compute_cases_per_edge): Use new\n        gimple_switch_edge function.\n\t(switch_decision_tree::analyze_switch_statement): Pass new argument\n        to label_to_block.\n\t(switch_decision_tree::try_switch_expansion): Use\n        gimple_switch_default_edge.\n\t* tree-vrp.c (find_switch_asserts): Pass new argument\n        to label_to_block.\n\t* vr-values.c (vr_values::vrp_visit_switch_stmt): Likewise.\n\t(vr_values::simplify_switch_using_ranges): Likewise.\n\nFrom-SVN: r263876", "tree": {"sha": "258d294d1bd789f941b4e62269851da44fa8a99c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/258d294d1bd789f941b4e62269851da44fa8a99c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61ff5d6f4ed5000ee427e054ee803bc8f5535bdd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61ff5d6f4ed5000ee427e054ee803bc8f5535bdd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61ff5d6f4ed5000ee427e054ee803bc8f5535bdd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61ff5d6f4ed5000ee427e054ee803bc8f5535bdd/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "78ea9abc2018243af7f7ada6135144ac90c6ad27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78ea9abc2018243af7f7ada6135144ac90c6ad27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78ea9abc2018243af7f7ada6135144ac90c6ad27"}], "stats": {"total": 294, "additions": 192, "deletions": 102}, "files": [{"sha": "40a8735a44610b7bfffc3a51f5402aaad02a3559", "filename": "gcc/ChangeLog", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ff5d6f4ed5000ee427e054ee803bc8f5535bdd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ff5d6f4ed5000ee427e054ee803bc8f5535bdd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=61ff5d6f4ed5000ee427e054ee803bc8f5535bdd", "patch": "@@ -1,3 +1,79 @@\n+2018-08-27  Martin Liska  <mliska@suse.cz>\n+\n+\t* cfgexpand.c (expand_asm_stmt): Use label_to_block and pass\n+        cfun argument explicitly.\n+\t* gimple-pretty-print.c (dump_gimple_switch): Likewise.\n+\t* hsa-gen.c (gen_hsa_insns_for_switch_stmt): Use new\n+        function gimple_switch_default_bb.\n+\t(convert_switch_statements):\n+\t(expand_builtins):\n+\t* ipa-fnsummary.c (set_switch_stmt_execution_predicate):\n+\t* stmt.c (label_to_block_fn): Use label_to_block and pass\n+        cfun argument explicitly and use gimple_switch_label_bb.\n+\t(expand_case): Likewise.\n+\t* tree-cfg.c (lower_phi_internal_fn): Use label_to_block and pass\n+        cfun argument explicitly. Likewise.\n+\t(make_edges_bb): Likewise.\n+\t(make_cond_expr_edges): Likewise.\n+\t(get_cases_for_edge): Likewise.\n+\t(make_gimple_switch_edges): Likewise.\n+\t(label_to_block_fn): Likewise.\n+\t(label_to_block): Likewise.\n+\t(make_goto_expr_edges): Likewise.\n+\t(make_gimple_asm_edges): Likewise.\n+\t(main_block_label): Likewise.\n+\t(group_case_labels_stmt): Likewise.\n+\t(find_taken_edge_computed_goto): Likewise.\n+\t(find_taken_edge_switch_expr): Likewise.\n+\t(gimple_verify_flow_info): Likewise.\n+\t(gimple_redirect_edge_and_branch): Likewise.\n+\t(gimple_switch_label_bb): New function.\n+\t(gimple_switch_default_bb): Likewise.\n+\t(gimple_switch_edge): Likewise.\n+\t(gimple_switch_default_edge): Likewise.\n+\t* tree-cfg.h (label_to_block_fn): Remove and replace ...\n+\t(label_to_block): ... with this.\n+\t(gimple_switch_label_bb): New.\n+\t(gimple_switch_default_bb): Likewise.\n+\t(gimple_switch_edge): Likewise.\n+\t(gimple_switch_default_edge): Likewise.\n+\t* tree-cfgcleanup.c (convert_single_case_switch): Use\n+        new gimple functions and pass new argument to label_to_block.\n+\t(cleanup_control_flow_bb):\n+\t* tree-eh.c (make_eh_dispatch_edges): Use label_to_block and pass\n+        cfun argument explicitly.\n+\t(make_eh_edges): Likewise.\n+\t(redirect_eh_dispatch_edge): Likewise.\n+\t(lower_resx): Likewise.\n+\t(lower_eh_dispatch): Likewise.\n+\t(maybe_remove_unreachable_handlers): Likewise.\n+\t(unsplit_eh): Likewise.\n+\t(cleanup_empty_eh): Likewise.\n+\t(verify_eh_edges): Likewise.\n+\t(verify_eh_dispatch_edge): Likewise.\n+\t* tree-ssa-dom.c (record_edge_info): Likewise.\n+\t* tree-ssa-forwprop.c (simplify_gimple_switch_label_vec): Likewise.\n+\t* tree-ssa-threadedge.c (thread_around_empty_blocks): Likewise.\n+\t(thread_through_normal_block): Likewise.\n+\t* tree-ssa-uncprop.c (associate_equivalences_with_edges): Likewise.\n+\t* tree-ssa-uninit.c (convert_control_dep_chain_into_preds):\n+\t* tree-switch-conversion.c (switch_conversion::collect): Use new\n+        gimple functions.\n+\t(switch_conversion::check_final_bb): Likewise.\n+\t(switch_conversion::gather_default_values): Pass new argument\n+        to label_to_block.\n+\t(switch_conversion::build_constructors): Likewise.\n+\t(switch_decision_tree::compute_cases_per_edge): Use new\n+        gimple_switch_edge function.\n+\t(switch_decision_tree::analyze_switch_statement): Pass new argument\n+        to label_to_block.\n+\t(switch_decision_tree::try_switch_expansion): Use\n+        gimple_switch_default_edge.\n+\t* tree-vrp.c (find_switch_asserts): Pass new argument\n+        to label_to_block.\n+\t* vr-values.c (vr_values::vrp_visit_switch_stmt): Likewise.\n+\t(vr_values::simplify_switch_using_ranges): Likewise.\n+\n 2018-08-27  Richard Biener  <rguenther@suse.de>\n \n \t* cfganal.h (rev_post_order_and_mark_dfs_back_seme): Declare."}, {"sha": "647764b0e94ec3476a38f7d07d2845eb8820798e", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ff5d6f4ed5000ee427e054ee803bc8f5535bdd/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ff5d6f4ed5000ee427e054ee803bc8f5535bdd/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=61ff5d6f4ed5000ee427e054ee803bc8f5535bdd", "patch": "@@ -3239,7 +3239,7 @@ expand_asm_stmt (gasm *stmt)\n \t     may insert further instructions into the same basic block after\n \t     asm goto and if we don't do this, insertion of instructions on\n \t     the fallthru edge might misbehave.  See PR58670.  */\n-\t  if (fallthru_bb && label_to_block_fn (cfun, label) == fallthru_bb)\n+\t  if (fallthru_bb && label_to_block (cfun, label) == fallthru_bb)\n \t    {\n \t      if (fallthru_label == NULL_RTX)\n \t        fallthru_label = gen_label_rtx ();"}, {"sha": "dd63a28761b85cf38d38108d559db86531edb823", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ff5d6f4ed5000ee427e054ee803bc8f5535bdd/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ff5d6f4ed5000ee427e054ee803bc8f5535bdd/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=61ff5d6f4ed5000ee427e054ee803bc8f5535bdd", "patch": "@@ -992,7 +992,7 @@ dump_gimple_switch (pretty_printer *buffer, gswitch *gs, int spc,\n \n       if (cfun && cfun->cfg)\n \t{\n-\t  basic_block dest = label_to_block (label);\n+\t  basic_block dest = label_to_block (cfun, label);\n \t  if (dest)\n \t    {\n \t      edge label_edge = find_edge (gimple_bb (gs), dest);"}, {"sha": "416de933a22b57777c0340f26493c147fb42669b", "filename": "gcc/hsa-gen.c", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ff5d6f4ed5000ee427e054ee803bc8f5535bdd/gcc%2Fhsa-gen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ff5d6f4ed5000ee427e054ee803bc8f5535bdd/gcc%2Fhsa-gen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa-gen.c?ref=61ff5d6f4ed5000ee427e054ee803bc8f5535bdd", "patch": "@@ -3475,7 +3475,6 @@ gen_hsa_insns_for_switch_stmt (gswitch *s, hsa_bb *hbb)\n   e->flags &= ~EDGE_FALLTHRU;\n   e->flags |= EDGE_TRUE_VALUE;\n \n-  function *func = DECL_STRUCT_FUNCTION (current_function_decl);\n   tree index_tree = gimple_switch_index (s);\n   tree lowest = get_switch_low (s);\n   tree highest = get_switch_high (s);\n@@ -3499,9 +3498,7 @@ gen_hsa_insns_for_switch_stmt (gswitch *s, hsa_bb *hbb)\n \n   hbb->append_insn (new hsa_insn_cbr (cmp_reg));\n \n-  tree default_label = gimple_switch_default_label (s);\n-  basic_block default_label_bb = label_to_block_fn (func,\n-\t\t\t\t\t\t    CASE_LABEL (default_label));\n+  basic_block default_label_bb = gimple_switch_default_bb (cfun, s);\n \n   if (!gimple_seq_empty_p (phi_nodes (default_label_bb)))\n     {\n@@ -3536,7 +3533,7 @@ gen_hsa_insns_for_switch_stmt (gswitch *s, hsa_bb *hbb)\n   for (unsigned i = 1; i < labels; i++)\n     {\n       tree label = gimple_switch_label (s, i);\n-      basic_block bb = label_to_block_fn (func, CASE_LABEL (label));\n+      basic_block bb = label_to_block (cfun, CASE_LABEL (label));\n \n       unsigned HOST_WIDE_INT sub_low\n \t= tree_to_uhwi (int_const_binop (MINUS_EXPR, CASE_LOW (label), lowest));\n@@ -6290,12 +6287,11 @@ LD:    hard_work_3 ();\n static bool\n convert_switch_statements (void)\n {\n-  function *func = DECL_STRUCT_FUNCTION (current_function_decl);\n   basic_block bb;\n \n   bool modified_cfg = false;\n \n-  FOR_EACH_BB_FN (bb, func)\n+  FOR_EACH_BB_FN (bb, cfun)\n   {\n     gimple_stmt_iterator gsi = gsi_last_bb (bb);\n     if (gsi_end_p (gsi))\n@@ -6318,7 +6314,7 @@ convert_switch_statements (void)\n \ttree index_type = TREE_TYPE (index);\n \ttree default_label = gimple_switch_default_label (s);\n \tbasic_block default_label_bb\n-\t  = label_to_block_fn (func, CASE_LABEL (default_label));\n+\t  = label_to_block (cfun, CASE_LABEL (default_label));\n \tbasic_block cur_bb = bb;\n \n \tauto_vec <edge> new_edges;\n@@ -6330,8 +6326,7 @@ convert_switch_statements (void)\n \t   should be fixed after we add new collection of edges.  */\n \tfor (unsigned i = 0; i < labels; i++)\n \t  {\n-\t    tree label = gimple_switch_label (s, i);\n-\t    basic_block label_bb = label_to_block_fn (func, CASE_LABEL (label));\n+\t    basic_block label_bb = gimple_switch_label_bb (cfun, s, i);\n \t    edge e = find_edge (bb, label_bb);\n \t    edge_counts.safe_push (e->count ());\n \t    edge_probabilities.safe_push (e->probability);\n@@ -6413,8 +6408,7 @@ convert_switch_statements (void)\n \n \t    gsi_insert_before (&cond_gsi, c, GSI_SAME_STMT);\n \n-\t    basic_block label_bb\n-\t      = label_to_block_fn (func, CASE_LABEL (label));\n+\t    basic_block label_bb = label_to_block (cfun, CASE_LABEL (label));\n \t    edge new_edge = make_edge (cur_bb, label_bb, EDGE_TRUE_VALUE);\n \t    profile_probability prob_sum = sum_slice <profile_probability>\n \t\t (edge_probabilities, i, labels, profile_probability::never ())\n@@ -6481,10 +6475,9 @@ convert_switch_statements (void)\n static void\n expand_builtins ()\n {\n-  function *func = DECL_STRUCT_FUNCTION (current_function_decl);\n   basic_block bb;\n \n-  FOR_EACH_BB_FN (bb, func)\n+  FOR_EACH_BB_FN (bb, cfun)\n   {\n     for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);\n \t gsi_next (&gsi))"}, {"sha": "d8311d25ab2b95aed43246b2ff44dfb2aad53da5", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ff5d6f4ed5000ee427e054ee803bc8f5535bdd/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ff5d6f4ed5000ee427e054ee803bc8f5535bdd/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=61ff5d6f4ed5000ee427e054ee803bc8f5535bdd", "patch": "@@ -1291,7 +1291,7 @@ set_switch_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n       tree min, max;\n       predicate p;\n \n-      e = find_edge (bb, label_to_block (CASE_LABEL (cl)));\n+      e = gimple_switch_edge (cfun, last, case_idx);\n       min = CASE_LOW (cl);\n       max = CASE_HIGH (cl);\n "}, {"sha": "07355984de1aeaf2b5549d676f1a4792e3df53d2", "filename": "gcc/stmt.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ff5d6f4ed5000ee427e054ee803bc8f5535bdd/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ff5d6f4ed5000ee427e054ee803bc8f5535bdd/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=61ff5d6f4ed5000ee427e054ee803bc8f5535bdd", "patch": "@@ -81,8 +81,6 @@ struct simple_case_node\n   /* Label to jump to when node matches.  */\n   tree m_code_label;\n };\n-\n-extern basic_block label_to_block_fn (struct function *, tree);\n \f\n static bool check_unique_operand_names (tree, tree, tree);\n static char *resolve_operand_name_1 (char *, tree, tree, tree);\n@@ -907,7 +905,7 @@ expand_case (gswitch *stmt)\n   /* Find the default case target label.  */\n   tree default_lab = CASE_LABEL (gimple_switch_default_label (stmt));\n   default_label = jump_target_rtx (default_lab);\n-  basic_block default_bb = label_to_block_fn (cfun, default_lab);\n+  basic_block default_bb = label_to_block (cfun, default_lab);\n   edge default_edge = find_edge (bb, default_bb);\n \n   /* Get upper and lower bounds of case values.  */"}, {"sha": "b021fb0f97ba6acec3bcc2244feb1e93e396f2ef", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 58, "deletions": 25, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ff5d6f4ed5000ee427e054ee803bc8f5535bdd/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ff5d6f4ed5000ee427e054ee803bc8f5535bdd/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=61ff5d6f4ed5000ee427e054ee803bc8f5535bdd", "patch": "@@ -389,7 +389,7 @@ lower_phi_internal_fn ()\n \t    {\n \t      tree arg = gimple_call_arg (stmt, i);\n \t      if (TREE_CODE (arg) == LABEL_DECL)\n-\t\tpred = label_to_block (arg);\n+\t\tpred = label_to_block (cfun, arg);\n \t      else\n \t\t{\n \t\t  edge e = find_edge (pred, bb);\n@@ -972,15 +972,15 @@ make_edges_bb (basic_block bb, struct omp_region **pcur_region, int *pomp_index)\n \ttree label2 = gimple_transaction_label_uninst (txn);\n \n \tif (label1)\n-\t  make_edge (bb, label_to_block (label1), EDGE_FALLTHRU);\n+\t  make_edge (bb, label_to_block (cfun, label1), EDGE_FALLTHRU);\n \tif (label2)\n-\t  make_edge (bb, label_to_block (label2),\n+\t  make_edge (bb, label_to_block (cfun, label2),\n \t\t     EDGE_TM_UNINSTRUMENTED | (label1 ? 0 : EDGE_FALLTHRU));\n \n \ttree label3 = gimple_transaction_label_over (txn);\n \tif (gimple_transaction_subcode (txn)\n \t    & (GTMA_HAVE_ABORT | GTMA_IS_OUTER))\n-\t  make_edge (bb, label_to_block (label3), EDGE_TM_ABORT);\n+\t  make_edge (bb, label_to_block (cfun, label3), EDGE_TM_ABORT);\n \n \tfallthru = false;\n       }\n@@ -1265,8 +1265,8 @@ make_cond_expr_edges (basic_block bb)\n   /* Entry basic blocks for each component.  */\n   then_label = gimple_cond_true_label (entry);\n   else_label = gimple_cond_false_label (entry);\n-  then_bb = label_to_block (then_label);\n-  else_bb = label_to_block (else_label);\n+  then_bb = label_to_block (cfun, then_label);\n+  else_bb = label_to_block (cfun, else_label);\n   then_stmt = first_stmt (then_bb);\n   else_stmt = first_stmt (else_bb);\n \n@@ -1373,7 +1373,7 @@ get_cases_for_edge (edge e, gswitch *t)\n     {\n       tree elt = gimple_switch_label (t, i);\n       tree lab = CASE_LABEL (elt);\n-      basic_block label_bb = label_to_block (lab);\n+      basic_block label_bb = label_to_block (cfun, lab);\n       edge this_edge = find_edge (e->src, label_bb);\n \n       /* Add it to the chain of CASE_LABEL_EXPRs referencing E, or create\n@@ -1397,8 +1397,7 @@ make_gimple_switch_edges (gswitch *entry, basic_block bb)\n \n   for (i = 0; i < n; ++i)\n     {\n-      tree lab = CASE_LABEL (gimple_switch_label (entry, i));\n-      basic_block label_bb = label_to_block (lab);\n+      basic_block label_bb = gimple_switch_label_bb (cfun, entry, i);\n       make_edge (bb, label_bb, 0);\n     }\n }\n@@ -1407,7 +1406,7 @@ make_gimple_switch_edges (gswitch *entry, basic_block bb)\n /* Return the basic block holding label DEST.  */\n \n basic_block\n-label_to_block_fn (struct function *ifun, tree dest)\n+label_to_block (struct function *ifun, tree dest)\n {\n   int uid = LABEL_DECL_UID (dest);\n \n@@ -1442,7 +1441,7 @@ make_goto_expr_edges (basic_block bb)\n   if (simple_goto_p (goto_t))\n     {\n       tree dest = gimple_goto_dest (goto_t);\n-      basic_block label_bb = label_to_block (dest);\n+      basic_block label_bb = label_to_block (cfun, dest);\n       edge e = make_edge (bb, label_bb, EDGE_FALLTHRU);\n       e->goto_locus = gimple_location (goto_t);\n       gsi_remove (&last, true);\n@@ -1464,7 +1463,7 @@ make_gimple_asm_edges (basic_block bb)\n   for (i = 0; i < n; ++i)\n     {\n       tree label = TREE_VALUE (gimple_asm_label_op (stmt, i));\n-      basic_block label_bb = label_to_block (label);\n+      basic_block label_bb = label_to_block (cfun, label);\n       make_edge (bb, label_bb, 0);\n     }\n }\n@@ -1496,7 +1495,7 @@ static struct label_record\n static tree\n main_block_label (tree label)\n {\n-  basic_block bb = label_to_block (label);\n+  basic_block bb = label_to_block (cfun, label);\n   tree main_label = label_for_bb[bb->index].label;\n \n   /* label_to_block possibly inserted undefined label into the chain.  */\n@@ -1773,7 +1772,7 @@ group_case_labels_stmt (gswitch *stmt)\n   int i, next_index, new_size;\n   basic_block default_bb = NULL;\n \n-  default_bb = label_to_block (CASE_LABEL (gimple_switch_default_label (stmt)));\n+  default_bb = gimple_switch_default_bb (cfun, stmt);\n \n   /* Look for possible opportunities to merge cases.  */\n   new_size = i = 1;\n@@ -1785,7 +1784,7 @@ group_case_labels_stmt (gswitch *stmt)\n       base_case = gimple_switch_label (stmt, i);\n \n       gcc_assert (base_case);\n-      base_bb = label_to_block (CASE_LABEL (base_case));\n+      base_bb = label_to_block (cfun, CASE_LABEL (base_case));\n \n       /* Discard cases that have the same destination as the default case or\n \t whose destiniation blocks have already been removed as unreachable.  */\n@@ -1806,7 +1805,7 @@ group_case_labels_stmt (gswitch *stmt)\n       while (next_index < old_size)\n \t{\n \t  tree merge_case = gimple_switch_label (stmt, next_index);\n-\t  basic_block merge_bb = label_to_block (CASE_LABEL (merge_case));\n+\t  basic_block merge_bb = label_to_block (cfun, CASE_LABEL (merge_case));\n \t  wide_int bhp1 = wi::to_wide (base_high) + 1;\n \n \t  /* Merge the cases if they jump to the same place,\n@@ -2387,7 +2386,7 @@ find_taken_edge_computed_goto (basic_block bb, tree val)\n   basic_block dest;\n   edge e = NULL;\n \n-  dest = label_to_block (val);\n+  dest = label_to_block (cfun, val);\n   if (dest)\n     e = find_edge (bb, dest);\n \n@@ -2455,7 +2454,7 @@ find_taken_edge_switch_expr (const gswitch *switch_stmt, tree val)\n       else\n \ttaken_case = find_case_label_for_value (switch_stmt, val);\n     }\n-  dest_bb = label_to_block (CASE_LABEL (taken_case));\n+  dest_bb = label_to_block (cfun, CASE_LABEL (taken_case));\n \n   e = find_edge (gimple_bb (switch_stmt), dest_bb);\n   gcc_assert (e);\n@@ -5498,7 +5497,7 @@ gimple_verify_flow_info (void)\n \t      err = 1;\n \t    }\n \n-\t  if (label_to_block (label) != bb)\n+\t  if (label_to_block (cfun, label) != bb)\n \t    {\n \t      error (\"label \");\n \t      print_generic_expr (stderr, label);\n@@ -5655,8 +5654,7 @@ gimple_verify_flow_info (void)\n \t    /* Mark all the destination basic blocks.  */\n \t    for (i = 0; i < n; ++i)\n \t      {\n-\t\ttree lab = CASE_LABEL (gimple_switch_label (switch_stmt, i));\n-\t\tbasic_block label_bb = label_to_block (lab);\n+\t\tbasic_block label_bb = gimple_switch_label_bb (cfun, switch_stmt, i);\n \t\tgcc_assert (!label_bb->aux || label_bb->aux == (void *)1);\n \t\tlabel_bb->aux = (void *)1;\n \t      }\n@@ -5711,8 +5709,8 @@ gimple_verify_flow_info (void)\n \t    /* Check that we have all of them.  */\n \t    for (i = 0; i < n; ++i)\n \t      {\n-\t\ttree lab = CASE_LABEL (gimple_switch_label (switch_stmt, i));\n-\t\tbasic_block label_bb = label_to_block (lab);\n+\t\tbasic_block label_bb = gimple_switch_label_bb (cfun,\n+\t\t\t\t\t\t\t       switch_stmt, i);\n \n \t\tif (label_bb->aux != (void *)2)\n \t\t  {\n@@ -5936,7 +5934,7 @@ gimple_redirect_edge_and_branch (edge e, basic_block dest)\n \t    for (i = 0; i < n; i++)\n \t      {\n \t\ttree elt = gimple_switch_label (switch_stmt, i);\n-\t\tif (label_to_block (CASE_LABEL (elt)) == e->dest)\n+\t\tif (label_to_block (cfun, CASE_LABEL (elt)) == e->dest)\n \t\t  CASE_LABEL (elt) = label;\n \t      }\n \t  }\n@@ -5952,7 +5950,7 @@ gimple_redirect_edge_and_branch (edge e, basic_block dest)\n \tfor (i = 0; i < n; ++i)\n \t  {\n \t    tree cons = gimple_asm_label_op (asm_stmt, i);\n-\t    if (label_to_block (TREE_VALUE (cons)) == e->dest)\n+\t    if (label_to_block (cfun, TREE_VALUE (cons)) == e->dest)\n \t      {\n \t\tif (!label)\n \t\t  label = gimple_block_label (dest);\n@@ -9143,6 +9141,41 @@ generate_range_test (basic_block bb, tree index, tree low, tree high,\n   gsi_insert_seq_before (&gsi, seq, GSI_SAME_STMT);\n }\n \n+/* Return the basic block that belongs to label numbered INDEX\n+   of a switch statement.  */\n+\n+basic_block\n+gimple_switch_label_bb (function *ifun, gswitch *gs, unsigned index)\n+{\n+  return label_to_block (ifun, CASE_LABEL (gimple_switch_label (gs, index)));\n+}\n+\n+/* Return the default basic block of a switch statement.  */\n+\n+basic_block\n+gimple_switch_default_bb (function *ifun, gswitch *gs)\n+{\n+  return gimple_switch_label_bb (ifun, gs, 0);\n+}\n+\n+/* Return the edge that belongs to label numbered INDEX\n+   of a switch statement.  */\n+\n+edge\n+gimple_switch_edge (function *ifun, gswitch *gs, unsigned index)\n+{\n+  return find_edge (gimple_bb (gs), gimple_switch_label_bb (ifun, gs, index));\n+}\n+\n+/* Return the default edge of a switch statement.  */\n+\n+edge\n+gimple_switch_default_edge (function *ifun, gswitch *gs)\n+{\n+  return gimple_switch_edge (ifun, gs, 0);\n+}\n+\n+\n /* Emit return warnings.  */\n \n namespace {"}, {"sha": "349a954316858394df44ce35e98db5c8cb39e9d4", "filename": "gcc/tree-cfg.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ff5d6f4ed5000ee427e054ee803bc8f5535bdd/gcc%2Ftree-cfg.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ff5d6f4ed5000ee427e054ee803bc8f5535bdd/gcc%2Ftree-cfg.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.h?ref=61ff5d6f4ed5000ee427e054ee803bc8f5535bdd", "patch": "@@ -33,8 +33,7 @@ extern void init_empty_tree_cfg_for_function (struct function *);\n extern void init_empty_tree_cfg (void);\n extern void start_recording_case_labels (void);\n extern void end_recording_case_labels (void);\n-extern basic_block label_to_block_fn (struct function *, tree);\n-#define label_to_block(t) (label_to_block_fn (cfun, t))\n+extern basic_block label_to_block (struct function *, tree);\n extern void cleanup_dead_labels (void);\n extern bool group_case_labels_stmt (gswitch *);\n extern bool group_case_labels (void);\n@@ -112,6 +111,10 @@ extern bool extract_true_false_controlled_edges (basic_block, basic_block,\n \t\t\t\t\t\t edge *, edge *);\n extern void generate_range_test (basic_block bb, tree index, tree low,\n \t\t\t\t tree high, tree *lhs, tree *rhs);\n+extern basic_block gimple_switch_label_bb (function *, gswitch *, unsigned);\n+extern basic_block gimple_switch_default_bb (function *, gswitch *);\n+extern edge gimple_switch_edge (function *, gswitch *, unsigned);\n+extern edge gimple_switch_default_edge (function *, gswitch *);\n \n /* Return true if the LHS of a call should be removed.  */\n "}, {"sha": "7fd0430d6cfad00f05e1c351dc03c8460608b529", "filename": "gcc/tree-cfgcleanup.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ff5d6f4ed5000ee427e054ee803bc8f5535bdd/gcc%2Ftree-cfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ff5d6f4ed5000ee427e054ee803bc8f5535bdd/gcc%2Ftree-cfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.c?ref=61ff5d6f4ed5000ee427e054ee803bc8f5535bdd", "patch": "@@ -84,13 +84,12 @@ convert_single_case_switch (gswitch *swtch, gimple_stmt_iterator &gsi)\n     return false;\n \n   tree index = gimple_switch_index (swtch);\n-  tree default_label = CASE_LABEL (gimple_switch_default_label (swtch));\n   tree label = gimple_switch_label (swtch, 1);\n   tree low = CASE_LOW (label);\n   tree high = CASE_HIGH (label);\n \n-  basic_block default_bb = label_to_block_fn (cfun, default_label);\n-  basic_block case_bb = label_to_block_fn (cfun, CASE_LABEL (label));\n+  basic_block default_bb = gimple_switch_default_bb (cfun, swtch);\n+  basic_block case_bb = label_to_block (cfun, CASE_LABEL (label));\n \n   basic_block bb = gimple_bb (swtch);\n   gcond *cond;\n@@ -266,7 +265,7 @@ cleanup_control_flow_bb (basic_block bb)\n       label = TREE_OPERAND (gimple_goto_dest (stmt), 0);\n       if (DECL_CONTEXT (label) != cfun->decl)\n \treturn retval;\n-      target_block = label_to_block (label);\n+      target_block = label_to_block (cfun, label);\n       for (ei = ei_start (bb->succs); (e = ei_safe_edge (ei)); )\n \t{\n \t  if (e->dest != target_block)"}, {"sha": "20e2db9e29a5e455034baabb4cf9806e731b3115", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ff5d6f4ed5000ee427e054ee803bc8f5535bdd/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ff5d6f4ed5000ee427e054ee803bc8f5535bdd/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=61ff5d6f4ed5000ee427e054ee803bc8f5535bdd", "patch": "@@ -2231,7 +2231,7 @@ make_eh_dispatch_edges (geh_dispatch *stmt)\n     case ERT_TRY:\n       for (c = r->u.eh_try.first_catch; c ; c = c->next_catch)\n \t{\n-\t  dst = label_to_block (c->label);\n+\t  dst = label_to_block (cfun, c->label);\n \t  make_edge (src, dst, 0);\n \n \t  /* A catch-all handler doesn't have a fallthru.  */\n@@ -2241,7 +2241,7 @@ make_eh_dispatch_edges (geh_dispatch *stmt)\n       break;\n \n     case ERT_ALLOWED_EXCEPTIONS:\n-      dst = label_to_block (r->u.allowed.label);\n+      dst = label_to_block (cfun, r->u.allowed.label);\n       make_edge (src, dst, 0);\n       break;\n \n@@ -2270,7 +2270,7 @@ make_eh_edges (gimple *stmt)\n   gcc_assert (lp != NULL);\n \n   src = gimple_bb (stmt);\n-  dst = label_to_block (lp->post_landing_pad);\n+  dst = label_to_block (cfun, lp->post_landing_pad);\n   make_edge (src, dst, EDGE_EH);\n }\n \n@@ -2389,7 +2389,7 @@ redirect_eh_dispatch_edge (geh_dispatch *stmt, edge e, basic_block new_bb)\n     case ERT_TRY:\n       for (c = r->u.eh_try.first_catch; c ; c = c->next_catch)\n \t{\n-\t  old_bb = label_to_block (c->label);\n+\t  old_bb = label_to_block (cfun, c->label);\n \t  if (old_bb == e->dest)\n \t    {\n \t      c->label = new_lab;\n@@ -2399,7 +2399,7 @@ redirect_eh_dispatch_edge (geh_dispatch *stmt, edge e, basic_block new_bb)\n       break;\n \n     case ERT_ALLOWED_EXCEPTIONS:\n-      old_bb = label_to_block (r->u.allowed.label);\n+      old_bb = label_to_block (cfun, r->u.allowed.label);\n       gcc_assert (old_bb == e->dest);\n       r->u.allowed.label = new_lab;\n       any_changed = true;\n@@ -3329,7 +3329,7 @@ lower_resx (basic_block bb, gresx *stmt,\n \t  else\n \t    {\n \t      lab = *slot;\n-\t      new_bb = label_to_block (lab);\n+\t      new_bb = label_to_block (cfun, lab);\n \t    }\n \n \t  gcc_assert (EDGE_COUNT (bb->succs) == 0);\n@@ -3733,7 +3733,7 @@ lower_eh_dispatch (basic_block src, geh_dispatch *stmt)\n \t    while (tp_node);\n \t    if (! have_label)\n \t      {\n-\t        remove_edge (find_edge (src, label_to_block (lab)));\n+\t\tremove_edge (find_edge (src, label_to_block (cfun, lab)));\n \t        redirected = true;\n \t      }\n \t  }\n@@ -4046,7 +4046,7 @@ maybe_remove_unreachable_handlers (void)\n   FOR_EACH_VEC_SAFE_ELT (cfun->eh->lp_array, i, lp)\n     if (lp && lp->post_landing_pad)\n       {\n-\tif (label_to_block (lp->post_landing_pad) == NULL)\n+\tif (label_to_block (cfun, lp->post_landing_pad) == NULL)\n \t  {\n \t    remove_unreachable_handlers ();\n \t    return;\n@@ -4110,7 +4110,7 @@ remove_unreachable_handlers_no_lp (void)\n static bool\n unsplit_eh (eh_landing_pad lp)\n {\n-  basic_block bb = label_to_block (lp->post_landing_pad);\n+  basic_block bb = label_to_block (cfun, lp->post_landing_pad);\n   gimple_stmt_iterator gsi;\n   edge e_in, e_out;\n \n@@ -4475,7 +4475,7 @@ infinite_empty_loop_p (edge e_first)\n static bool\n cleanup_empty_eh (eh_landing_pad lp)\n {\n-  basic_block bb = label_to_block (lp->post_landing_pad);\n+  basic_block bb = label_to_block (cfun, lp->post_landing_pad);\n   gimple_stmt_iterator gsi;\n   gimple *resx;\n   eh_region new_region;\n@@ -4795,7 +4795,7 @@ verify_eh_edges (gimple *stmt)\n       return true;\n     }\n \n-  if (eh_edge->dest != label_to_block (lp->post_landing_pad))\n+  if (eh_edge->dest != label_to_block (cfun, lp->post_landing_pad))\n     {\n       error (\"Incorrect EH edge %i->%i\", bb->index, eh_edge->dest->index);\n       return true;\n@@ -4827,7 +4827,7 @@ verify_eh_dispatch_edge (geh_dispatch *stmt)\n     case ERT_TRY:\n       for (c = r->u.eh_try.first_catch; c ; c = c->next_catch)\n \t{\n-\t  dst = label_to_block (c->label);\n+\t  dst = label_to_block (cfun, c->label);\n \t  e = find_edge (src, dst);\n \t  if (e == NULL)\n \t    {\n@@ -4846,7 +4846,7 @@ verify_eh_dispatch_edge (geh_dispatch *stmt)\n       break;\n \n     case ERT_ALLOWED_EXCEPTIONS:\n-      dst = label_to_block (r->u.allowed.label);\n+      dst = label_to_block (cfun, r->u.allowed.label);\n       e = find_edge (src, dst);\n       if (e == NULL)\n \t{"}, {"sha": "7430fd7e706c2d38fb449c9d261dd9b02854f0da", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ff5d6f4ed5000ee427e054ee803bc8f5535bdd/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ff5d6f4ed5000ee427e054ee803bc8f5535bdd/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=61ff5d6f4ed5000ee427e054ee803bc8f5535bdd", "patch": "@@ -436,7 +436,8 @@ record_edge_info (basic_block bb)\n \t      for (i = 0; i < n_labels; i++)\n \t\t{\n \t\t  tree label = gimple_switch_label (switch_stmt, i);\n-\t\t  basic_block target_bb = label_to_block (CASE_LABEL (label));\n+\t\t  basic_block target_bb\n+\t\t    = label_to_block (cfun, CASE_LABEL (label));\n \t\t  if (CASE_HIGH (label)\n \t\t      || !CASE_LOW (label)\n \t\t      || info[target_bb->index])"}, {"sha": "4ed61c37a5fa5c8705928cb864936f97d9ce136b", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ff5d6f4ed5000ee427e054ee803bc8f5535bdd/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ff5d6f4ed5000ee427e054ee803bc8f5535bdd/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=61ff5d6f4ed5000ee427e054ee803bc8f5535bdd", "patch": "@@ -1071,7 +1071,7 @@ simplify_gimple_switch_label_vec (gswitch *stmt, tree index_type)\n       for (i = 0; i < gimple_switch_num_labels (stmt); i++)\n \t{\n \t  tree elt = gimple_switch_label (stmt, i);\n-\t  basic_block target = label_to_block (CASE_LABEL (elt));\n+\t  basic_block target = label_to_block (cfun, CASE_LABEL (elt));\n \t  bitmap_set_bit (target_blocks, target->index);\n \t}\n       for (ei = ei_start (gimple_bb (stmt)->succs); (e = ei_safe_edge (ei)); )"}, {"sha": "a2304493495db2c8f893bfc7cffb9e9191437623", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ff5d6f4ed5000ee427e054ee803bc8f5535bdd/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ff5d6f4ed5000ee427e054ee803bc8f5535bdd/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=61ff5d6f4ed5000ee427e054ee803bc8f5535bdd", "patch": "@@ -977,7 +977,7 @@ thread_around_empty_blocks (edge taken_edge,\n \t  || TREE_CODE (cond) == CASE_LABEL_EXPR))\n     {\n       if (TREE_CODE (cond) == CASE_LABEL_EXPR)\n-\ttaken_edge = find_edge (bb, label_to_block (CASE_LABEL (cond)));\n+\ttaken_edge = find_edge (bb, label_to_block (cfun, CASE_LABEL (cond)));\n       else\n \ttaken_edge = find_taken_edge (bb, cond);\n \n@@ -1109,7 +1109,7 @@ thread_through_normal_block (edge e,\n \t  edge taken_edge;\n \t  if (TREE_CODE (cond) == CASE_LABEL_EXPR)\n \t    taken_edge = find_edge (e->dest,\n-\t\t\t\t    label_to_block (CASE_LABEL (cond)));\n+\t\t\t\t    label_to_block (cfun, CASE_LABEL (cond)));\n \t  else\n \t    taken_edge = find_taken_edge (e->dest, cond);\n "}, {"sha": "98cc79e86070726332f5d1e568fcb450bb0fbf5f", "filename": "gcc/tree-ssa-uncprop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ff5d6f4ed5000ee427e054ee803bc8f5535bdd/gcc%2Ftree-ssa-uncprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ff5d6f4ed5000ee427e054ee803bc8f5535bdd/gcc%2Ftree-ssa-uncprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uncprop.c?ref=61ff5d6f4ed5000ee427e054ee803bc8f5535bdd", "patch": "@@ -184,7 +184,7 @@ associate_equivalences_with_edges (void)\n \t      for (i = 0; i < n_labels; i++)\n \t\t{\n \t\t  tree label = gimple_switch_label (switch_stmt, i);\n-\t\t  basic_block bb = label_to_block (CASE_LABEL (label));\n+\t\t  basic_block bb = label_to_block (cfun, CASE_LABEL (label));\n \n \t\t  if (CASE_HIGH (label)\n \t\t      || !CASE_LOW (label)"}, {"sha": "f3e42ddbd7f2460fd204986987cb26997c4b141b", "filename": "gcc/tree-ssa-uninit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ff5d6f4ed5000ee427e054ee803bc8f5535bdd/gcc%2Ftree-ssa-uninit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ff5d6f4ed5000ee427e054ee803bc8f5535bdd/gcc%2Ftree-ssa-uninit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uninit.c?ref=61ff5d6f4ed5000ee427e054ee803bc8f5535bdd", "patch": "@@ -725,7 +725,7 @@ convert_control_dep_chain_into_preds (vec<edge> *dep_chains,\n \t      for (idx = 0; idx < gimple_switch_num_labels (gs); ++idx)\n \t\t{\n \t\t  tree tl = gimple_switch_label (gs, idx);\n-\t\t  if (e->dest == label_to_block (CASE_LABEL (tl)))\n+\t\t  if (e->dest == label_to_block (cfun, CASE_LABEL (tl)))\n \t\t    {\n \t\t      if (!l)\n \t\t\tl = tl;"}, {"sha": "ef08bdc990dcb773eeb1bfc6d7a5a6f87cc2cdcd", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 15, "deletions": 29, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ff5d6f4ed5000ee427e054ee803bc8f5535bdd/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ff5d6f4ed5000ee427e054ee803bc8f5535bdd/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=61ff5d6f4ed5000ee427e054ee803bc8f5535bdd", "patch": "@@ -78,7 +78,6 @@ switch_conversion::collect (gswitch *swtch)\n   unsigned int i;\n   edge e, e_default, e_first;\n   edge_iterator ei;\n-  basic_block first;\n \n   m_switch = swtch;\n \n@@ -87,9 +86,8 @@ switch_conversion::collect (gswitch *swtch)\n      Collect the bits we can deduce from the CFG.  */\n   m_index_expr = gimple_switch_index (swtch);\n   m_switch_bb = gimple_bb (swtch);\n-  m_default_bb\n-    = label_to_block (CASE_LABEL (gimple_switch_default_label (swtch)));\n-  e_default = find_edge (m_switch_bb, m_default_bb);\n+  e_default = gimple_switch_default_edge (cfun, swtch);\n+  m_default_bb = e_default->dest;\n   m_default_prob = e_default->probability;\n   m_default_count = e_default->count ();\n   FOR_EACH_EDGE (e, ei, m_switch_bb->succs)\n@@ -120,15 +118,9 @@ switch_conversion::collect (gswitch *swtch)\n     }\n \n   if (m_contiguous_range)\n-    {\n-      first = label_to_block (CASE_LABEL (gimple_switch_label (swtch, 1)));\n-      e_first = find_edge (m_switch_bb, first);\n-    }\n+    e_first = gimple_switch_edge (cfun, swtch, 1);\n   else\n-    {\n-      first = m_default_bb;\n-      e_first = e_default;\n-    }\n+    e_first = e_default;\n \n   /* See if there is one common successor block for all branch\n      targets.  If it exists, record it in FINAL_BB.\n@@ -306,8 +298,7 @@ switch_conversion::check_final_bb ()\n \t\t  unsigned int branch_num = gimple_switch_num_labels (m_switch);\n \t\t  for (unsigned int i = 1; i < branch_num; i++)\n \t\t    {\n-\t\t      tree lab = CASE_LABEL (gimple_switch_label (m_switch, i));\n-\t\t      if (label_to_block (lab) == bb)\n+\t\t      if (gimple_switch_label_bb (cfun, m_switch, i) == bb)\n \t\t\t{\n \t\t\t  m_reason = reason;\n \t\t\t  return false;\n@@ -351,7 +342,7 @@ void\n switch_conversion::gather_default_values (tree default_case)\n {\n   gphi_iterator gsi;\n-  basic_block bb = label_to_block (CASE_LABEL (default_case));\n+  basic_block bb = label_to_block (cfun, CASE_LABEL (default_case));\n   edge e;\n   int i = 0;\n \n@@ -388,7 +379,7 @@ switch_conversion::build_constructors ()\n   for (i = 1; i < branch_num; i++)\n     {\n       tree cs = gimple_switch_label (m_switch, i);\n-      basic_block bb = label_to_block (CASE_LABEL (cs));\n+      basic_block bb = label_to_block (cfun, CASE_LABEL (cs));\n       edge e;\n       tree high;\n       gphi_iterator gsi;\n@@ -1577,15 +1568,11 @@ bit_test_cluster::hoist_edge_and_branch_if_true (gimple_stmt_iterator *gsip,\n void\n switch_decision_tree::compute_cases_per_edge ()\n {\n-  basic_block bb = gimple_bb (m_switch);\n   reset_out_edges_aux ();\n   int ncases = gimple_switch_num_labels (m_switch);\n   for (int i = ncases - 1; i >= 1; --i)\n     {\n-      tree elt = gimple_switch_label (m_switch, i);\n-      tree lab = CASE_LABEL (elt);\n-      basic_block case_bb = label_to_block_fn (cfun, lab);\n-      edge case_edge = find_edge (bb, case_bb);\n+      edge case_edge = gimple_switch_edge (cfun, m_switch, i);\n       case_edge->aux = (void *) ((intptr_t) (case_edge->aux) + 1);\n     }\n }\n@@ -1601,8 +1588,7 @@ switch_decision_tree::analyze_switch_statement ()\n   auto_vec<cluster *> clusters;\n   clusters.create (l - 1);\n \n-  tree default_label = CASE_LABEL (gimple_switch_default_label (m_switch));\n-  basic_block default_bb = label_to_block_fn (cfun, default_label);\n+  basic_block default_bb = gimple_switch_default_bb (cfun, m_switch);\n   m_case_bbs.reserve (l);\n   m_case_bbs.quick_push (default_bb);\n \n@@ -1612,15 +1598,16 @@ switch_decision_tree::analyze_switch_statement ()\n     {\n       tree elt = gimple_switch_label (m_switch, i);\n       tree lab = CASE_LABEL (elt);\n-      basic_block case_bb = label_to_block_fn (cfun, lab);\n+      basic_block case_bb = label_to_block (cfun, lab);\n       edge case_edge = find_edge (bb, case_bb);\n       tree low = CASE_LOW (elt);\n       tree high = CASE_HIGH (elt);\n \n       profile_probability p\n \t= case_edge->probability.apply_scale (1, (intptr_t) (case_edge->aux));\n-      clusters.quick_push (new simple_cluster (low, high, elt, case_bb, p));\n-      m_case_bbs.quick_push (case_bb);\n+      clusters.quick_push (new simple_cluster (low, high, elt, case_edge->dest,\n+\t\t\t\t\t       p));\n+      m_case_bbs.quick_push (case_edge->dest);\n     }\n \n   reset_out_edges_aux ();\n@@ -1694,9 +1681,8 @@ switch_decision_tree::try_switch_expansion (vec<cluster *> &clusters)\n     return false;\n \n   /* Find the default case target label.  */\n-  tree default_label_expr = CASE_LABEL (gimple_switch_default_label (m_switch));\n-  m_default_bb = label_to_block_fn (cfun, default_label_expr);\n-  edge default_edge = find_edge (bb, m_default_bb);\n+  edge default_edge = gimple_switch_default_edge (cfun, m_switch);\n+  m_default_bb = default_edge->dest;\n \n   /* Do the insertion of a case label into m_case_list.  The labels are\n      fed to us in descending order from the sorted vector of case labels used"}, {"sha": "e8eb92925060f1464e0d0544409a3e1f436c7917", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ff5d6f4ed5000ee427e054ee803bc8f5535bdd/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ff5d6f4ed5000ee427e054ee803bc8f5535bdd/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=61ff5d6f4ed5000ee427e054ee803bc8f5535bdd", "patch": "@@ -3474,7 +3474,7 @@ find_switch_asserts (basic_block bb, gswitch *last)\n   for (idx = 0; idx < n; ++idx)\n     {\n       ci[idx].expr = gimple_switch_label (last, idx);\n-      ci[idx].bb = label_to_block (CASE_LABEL (ci[idx].expr));\n+      ci[idx].bb = label_to_block (cfun, CASE_LABEL (ci[idx].expr));\n     }\n   edge default_edge = find_edge (bb, ci[0].bb);\n   qsort (ci, n, sizeof (struct case_info), compare_case_labels);"}, {"sha": "11df1023b6efa3618c670122a396f0cb67f0d94b", "filename": "gcc/vr-values.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ff5d6f4ed5000ee427e054ee803bc8f5535bdd/gcc%2Fvr-values.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ff5d6f4ed5000ee427e054ee803bc8f5535bdd/gcc%2Fvr-values.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.c?ref=61ff5d6f4ed5000ee427e054ee803bc8f5535bdd", "patch": "@@ -2707,7 +2707,7 @@ vr_values::vrp_visit_switch_stmt (gswitch *stmt, edge *taken_edge_p)\n     }\n \n   *taken_edge_p = find_edge (gimple_bb (stmt),\n-\t\t\t     label_to_block (CASE_LABEL (val)));\n+\t\t\t     label_to_block (cfun, CASE_LABEL (val)));\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -3760,7 +3760,8 @@ vr_values::simplify_switch_using_ranges (gswitch *stmt)\n   for (i = 0; i < n2; ++i)\n     {\n       e = find_edge (gimple_bb (stmt),\n-\t\t     label_to_block (CASE_LABEL (TREE_VEC_ELT (vec2, i))));\n+\t\t     label_to_block (cfun,\n+\t\t\t\t     CASE_LABEL (TREE_VEC_ELT (vec2, i))));\n       e->aux = (void *)-1;\n     }\n "}]}