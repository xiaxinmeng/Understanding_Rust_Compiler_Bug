{"sha": "a4f6608ca2562a0bd05493406beee11e1dfe89fd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTRmNjYwOGNhMjU2MmEwYmQwNTQ5MzQwNmJlZWUxMWUxZGZlODlmZA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-10-14T09:49:27Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-10-14T09:49:27Z"}, "message": "Some comments and whitespace cleaned up.  RCS headers removed.\n\nInclude gstddef.h and objc-proto.h.\nDon't include objcP.h or objc-protoP.h.\nAvoid use of u_int, etc. so no need for sys/types.h.\nAdjust for change in node_table field data type.\n\nFix calls to DEBUG_PRINTF; no longer wants stream as arg.\n\nFrom-SVN: r2456", "tree": {"sha": "f4aa3f525f26a3a4211eef3f74ab41c5b90c7ccc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f4aa3f525f26a3a4211eef3f74ab41c5b90c7ccc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a4f6608ca2562a0bd05493406beee11e1dfe89fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4f6608ca2562a0bd05493406beee11e1dfe89fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4f6608ca2562a0bd05493406beee11e1dfe89fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4f6608ca2562a0bd05493406beee11e1dfe89fd/comments", "author": null, "committer": null, "parents": [{"sha": "437b93370de374bc1c6b7b85a104385b9860a3d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/437b93370de374bc1c6b7b85a104385b9860a3d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/437b93370de374bc1c6b7b85a104385b9860a3d1"}], "stats": {"total": 193, "additions": 63, "deletions": 130}, "files": [{"sha": "427548aac475d457893e1973fe71ba8dec68120d", "filename": "gcc/objc/hash.c", "status": "modified", "additions": 63, "deletions": 130, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4f6608ca2562a0bd05493406beee11e1dfe89fd/gcc%2Fobjc%2Fhash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4f6608ca2562a0bd05493406beee11e1dfe89fd/gcc%2Fobjc%2Fhash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fhash.c?ref=a4f6608ca2562a0bd05493406beee11e1dfe89fd", "patch": "@@ -1,4 +1,5 @@\n-/* Copyright (C) 1989, 1992 Free Software Foundation, Inc.\n+/* Hash tables for Objective C method dispatch.\n+   Copyright (C) 1992 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -22,111 +23,46 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n    This exception does not however invalidate any other reasons why\n    the executable file might be covered by the GNU General Public License.  */\n \n-/* \n-  $Header: /home/fsf/rms/c-runtime/dispatch/RCS/hash.c,v 0.15 1992/09/02 02:04:32 rms Exp rms $\n-  $Author: rms $\n-  $Date: 1992/09/02 02:04:32 $\n-  $Log: hash.c,v $\n- * Revision 0.15  1992/09/02  02:04:32  rms\n- * Changed some decls.\n- *\n- * Revision 0.14  1992/08/31  21:09:15  dglattin\n- * minor documentation changes.\n- *\n- * Revision 0.13  1992/08/18  04:46:58  dglattin\n- * Saving a working version before release.\n- *\n- * Revision 0.12  1992/04/13  11:43:08  dennisg\n- * Check in after array version of run-time works.\n- * Expect more changes as hash version and other changes are made.\n- *\n- * Revision 0.11  1992/01/03  02:55:03  dennisg\n- * modified to handle new initialization scheme.\n- * fixed code structure.\n- *\n- * Revision 0.10  1991/12/10  12:05:28  dennisg\n- * Cleaned up file format for a distribution.\n- *\n- * Revision 0.9  1991/12/03  02:01:23  dennisg\n- * fixed assert macro.\n- * added memory allocation adjustment macro for hash size allocation.\n- *\n- * Revision 0.8  1991/11/24  01:20:02  dennisg\n- * changed shorts back to ints.\n- * the efficiency gained didn't out weight the grossness of the code.\n- *\n- * Revision 0.7  1991/11/23  22:18:29  dennisg\n- * deleted hashIndex and moved it to hash-inline.h\n- * converted hash_value_for_key to a inline and moved it to hash-inline.h.\n- *\n- * Revision 0.6  1991/11/21  22:27:06  dennisg\n- * changed hash value calculation.\n- * func name changed from hashValue to hashIndex.  the\n- * func really calculated a index anyway.\n- * changed hash func impl.  essentially it was calculating a hash value\n- * from a hash value.  this is a implementation thing.\n- *\n- * Revision 0.5  1991/11/20  23:29:20  dennisg\n- * converted hashIndex to a inline.\n- *\n- * Revision 0.4  1991/11/19  12:34:41  dennisg\n- * bug in hash_delete.  It was using void* to obtain nodes to\n- * pass to hash_remove.  The value passed to hash_removed is a\n- * entry from the node structure rather than the node itself.  Using\n- * void* removed compiler checking.\n- * Modified to implement cache expansion.\n- *\n- * Revision 0.3  1991/11/07  23:23:40  dennisg\n- * implemented hash table expansion as suggested by rms.\n- *\n- * Revision 0.2  1991/11/07  22:30:54  dennisg\n- * added copyleft\n- *\n- * Revision 0.1  1991/10/24  00:45:39  dennisg\n- * Initial check in.  Preliminary development stage.\n- *\n-*/\n- \n-\n #include \"config.h\"\n+#include \"gstddef.h\"\n+#include \"assert.h\"\n+\n #include \"hash.h\"\n #include \"objc.h\"\n-#include \"objcP.h\"\n-#include \"objc-protoP.h\"\n-\n-#include \"assert.h\"\n+#include \"objc-proto.h\"\n \n \n /* These two macros determine when a hash table is full and\n    by how much it should be expanded respectively.\n-                                                  \n+\n    These equations are percentages.  */\n #define FULLNESS(cache) \\\n    ((((cache)->size * 75) / 100) <= (cache)->used)\n #define EXPANSION(cache) \\\n   ((cache)->size * 2)\n \n-cache_ptr \n-hash_new (u_int size, hash_func_type hash_func, compare_func_type compare_func)\n+cache_ptr\n+hash_new (unsigned int size, hash_func_type hash_func,\n+\t  compare_func_type compare_func)\n {\n   cache_ptr cache;\n \n \n   /* Pass me a value greater than 0 and a power of 2.  */\n   assert (size);\n   assert (!(size & (size - 1)));\n-  \n+\n   /* Allocate the cache structure.  calloc insures\n      its initialization for default values.  */\n   cache = (cache_ptr) calloc (1, sizeof (struct cache));\n   assert (cache);\n-  \n-  /* Allocate the array of buckets for the cache.  \n+\n+  /* Allocate the array of buckets for the cache.\n      calloc initializes all of the pointers to NULL.  */\n   cache->node_table\n     = (node_ptr *) calloc (size, sizeof (node_ptr));\n   assert (cache->node_table);\n-  \n+\n   cache->size  = size;\n \n   /* This should work for all processor architectures? */\n@@ -135,15 +71,15 @@ hash_new (u_int size, hash_func_type hash_func, compare_func_type compare_func)\n   /* Store the hashing function so that codes can be computed.  */\n   cache->hash_func = hash_func;\n \n-  /* Store the function that compares hash keys to \n+  /* Store the function that compares hash keys to\n      determine if they are equal.  */\n   cache->compare_func = compare_func;\n \n   return cache;\n }\n \n \n-void \n+void\n hash_delete (cache_ptr cache)\n {\n   node_ptr node;\n@@ -159,92 +95,92 @@ hash_delete (cache_ptr cache)\n }\n \n \n-void \n-hash_add (cache_ptr *cachep, void *key, void *value)\n+void\n+hash_add (cache_ptr *cachep, const void *key, void *value)\n {\n-  u_int indx = (*(*cachep)->hash_func)(*cachep, key);\n+  size_t indx = (*(*cachep)->hash_func)(*cachep, key);\n   node_ptr node = (node_ptr) calloc (1, sizeof (struct cache_node));\n \n \n   assert (node);\n-  \n+\n   /* Initialize the new node.  */\n   node->key    = key;\n   node->value  = value;\n-  node->next  = (*(*cachep)->node_table)[indx];\n-  \n+  node->next  = (*cachep)->node_table[indx];\n+\n   /* Debugging.\n      Check the list for another key.  */\n #ifdef DEBUG\n-  { node_ptr node1 = (*(*cachep)->node_table)[indx];\n-    \n+  { node_ptr node1 = (*cachep)->node_table[indx];\n+\n     while (node1) {\n-    \n+\n       assert (node1->key != key);\n       node1 = node1->next;\n     }\n   }\n #endif\n \n   /* Install the node as the first element on the list.  */\n-  (*(*cachep)->node_table)[indx] = node;\n+  (*cachep)->node_table[indx] = node;\n \n   /* Bump the number of entries in the cache.  */\n   ++(*cachep)->used;\n-  \n+\n   /* Check the hash table's fullness.   We're going\n      to expand if it is above the fullness level.  */\n   if (FULLNESS (*cachep)) {\n-    \n+\n     /* The hash table has reached its fullness level.  Time to\n-       expand it. \n-       \n+       expand it.\n+\n        I'm using a slow method here but is built on other\n-       primitive functions thereby increasing its \n+       primitive functions thereby increasing its\n        correctness.  */\n     node_ptr node1 = NULL;\n-    cache_ptr new = hash_new (EXPANSION (*cachep), \n-\t\t\t      (*cachep)->hash_func, \n+    cache_ptr new = hash_new (EXPANSION (*cachep),\n+\t\t\t      (*cachep)->hash_func,\n \t\t\t      (*cachep)->compare_func);\n \n-    DEBUG_PRINTF (stderr, \"Expanding cache %#x from %d to %d\\n\",\n+    DEBUG_PRINTF (\"Expanding cache %#x from %d to %d\\n\",\n \t\t  *cachep, (*cachep)->size, new->size);\n-      \n+\n     /* Copy the nodes from the first hash table to the new one.  */\n     while (node1 = hash_next (*cachep, node1))\n       hash_add (&new, node1->key, node1->value);\n \n     /* Trash the old cache.  */\n     hash_delete (*cachep);\n-    \n+\n     /* Return a pointer to the new hash table.  */\n     *cachep = new;\n   }\n }\n \n \n-void \n-hash_remove (cache_ptr cache, void *key)\n+void\n+hash_remove (cache_ptr cache, const void *key)\n {\n-  u_int indx = (*cache->hash_func)(cache, key);\n-  node_ptr node = (*cache->node_table)[indx];\n-  \n-  \n+  size_t indx = (*cache->hash_func)(cache, key);\n+  node_ptr node = cache->node_table[indx];\n+\n+\n   /* We assume there is an entry in the table.  Error if it is not.  */\n   assert (node);\n-  \n+\n   /* Special case.  First element is the key/value pair to be removed.  */\n   if ((*cache->compare_func)(node->key, key)) {\n-    (*cache->node_table)[indx] = node->next;\n+    cache->node_table[indx] = node->next;\n     free (node);\n   } else {\n \n     /* Otherwise, find the hash entry.  */\n     node_ptr prev = node;\n-    BOOL        removed = NO;\n-    \n+    BOOL removed = NO;\n+\n     do {\n-    \n+\n       if ((*cache->compare_func)(node->key, key)) {\n         prev->next = node->next, removed = YES;\n         free (node);\n@@ -253,60 +189,57 @@ hash_remove (cache_ptr cache, void *key)\n     } while (!removed && node);\n     assert (removed);\n   }\n-  \n+\n   /* Decrement the number of entries in the hash table.  */\n   --cache->used;\n }\n \n \n-node_ptr \n+node_ptr\n hash_next (cache_ptr cache, node_ptr node)\n {\n-  /* If the scan is being started then reset the last node \n+  /* If the scan is being started then reset the last node\n      visitied pointer and bucket index.  */\n   if (!node)\n     cache->last_bucket  = 0;\n-  \n-  /* If there is a node visited last then check for another \n+\n+  /* If there is a node visited last then check for another\n      entry in the same bucket;  Otherwise step to the next bucket.  */\n   if (node) {\n     if (node->next)\n-      /* There is a node which follows the last node \n+      /* There is a node which follows the last node\n \t returned.  Step to that node and retun it.  */\n       return node->next;\n     else\n       ++cache->last_bucket;\n   }\n \n-  /* If the list isn't exhausted then search the buckets for \n+  /* If the list isn't exhausted then search the buckets for\n      other nodes.  */\n   if (cache->last_bucket < cache->size) {\n     /*  Scan the remainder of the buckets looking for an entry\n \tat the head of the list.  Return the first item found.  */\n     while (cache->last_bucket < cache->size)\n-      if ((*cache->node_table)[cache->last_bucket])\n-        return (*cache->node_table)[cache->last_bucket];\n+      if (cache->node_table[cache->last_bucket])\n+        return cache->node_table[cache->last_bucket];\n       else\n         ++cache->last_bucket;\n-  \n+\n     /* No further nodes were found in the hash table.  */\n     return NULL;\n   } else\n     return NULL;\n }\n \n \n-/* \n- * Given key, return its value.  Return NULL if the\n- * key/value pair isn't in the hash. \n- */\n+/* Given KEY, return corresponding value for it in CACHE.\n+   Return NULL if the KEY is not recorded.  */\n+\n void *\n-hash_value_for_key (cache_ptr cache, void *key)\n+hash_value_for_key (cache_ptr cache, const void *key)\n {\n-  node_ptr node\n-    =  (*cache->node_table)[(*cache->hash_func)(cache, key)];\n+  node_ptr node = cache->node_table[(*cache->hash_func)(cache, key)];\n   void *retval = NULL;\n-  \n \n   if (node)\n     do {\n@@ -315,6 +248,6 @@ hash_value_for_key (cache_ptr cache, void *key)\n       else\n         node = node->next;\n     } while (!retval && node);\n-  \n+\n   return retval;\n }"}]}