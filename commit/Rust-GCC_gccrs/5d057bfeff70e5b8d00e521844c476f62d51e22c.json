{"sha": "5d057bfeff70e5b8d00e521844c476f62d51e22c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQwNTdiZmVmZjcwZTViOGQwMGU1MjE4NDRjNDc2ZjYyZDUxZTIyYw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-01-13T09:15:13Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-01-13T09:15:13Z"}, "message": "i386: Add define_insn_and_split patterns for btrl [PR96938]\n\nIn the following testcase we only optimize f2 and f7 to btrl, although we\nshould optimize that way all of the functions.  The problem is the type\ndemotion/narrowing (which is performed solely during the generic folding and\nnot later), without it we see the AND performed in SImode and match it as\nbtrl, but with it while the shifts are still performed in SImode, the\nAND is already done in QImode or HImode low part of the shift.\n\n2021-01-13  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR target/96938\n\t* config/i386/i386.md (*btr<mode>_1, *btr<mode>_2): New\n\tdefine_insn_and_split patterns.\n\t(splitter after *btr<mode>_2): New splitter.\n\n\t* gcc.target/i386/pr96938.c: New test.", "tree": {"sha": "4a2b273b233f5d809538bba3e983fe9a226ced9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a2b273b233f5d809538bba3e983fe9a226ced9c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d057bfeff70e5b8d00e521844c476f62d51e22c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d057bfeff70e5b8d00e521844c476f62d51e22c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d057bfeff70e5b8d00e521844c476f62d51e22c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d057bfeff70e5b8d00e521844c476f62d51e22c/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b70fa678b1a5ecf3ee87e2be87c3dc9dd08cc92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b70fa678b1a5ecf3ee87e2be87c3dc9dd08cc92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b70fa678b1a5ecf3ee87e2be87c3dc9dd08cc92"}], "stats": {"total": 131, "additions": 131, "deletions": 0}, "files": [{"sha": "b60784a2908e0e801fd2ffcc7e3c614df8ec1f8b", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d057bfeff70e5b8d00e521844c476f62d51e22c/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d057bfeff70e5b8d00e521844c476f62d51e22c/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=5d057bfeff70e5b8d00e521844c476f62d51e22c", "patch": "@@ -12419,6 +12419,71 @@\n \t     (match_dup 3)))\n       (clobber (reg:CC FLAGS_REG))])])\n \n+(define_insn_and_split \"*btr<mode>_1\"\n+  [(set (match_operand:SWI12 0 \"register_operand\")\n+\t(and:SWI12\n+\t  (subreg:SWI12\n+\t    (rotate:SI (const_int -2)\n+\t\t       (match_operand:QI 2 \"register_operand\")) 0)\n+\t  (match_operand:SWI12 1 \"nonimmediate_operand\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_USE_BT && ix86_pre_reload_split ()\"\n+  \"#\"\n+  \"&& 1\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (and:SI (rotate:SI (const_int -2) (match_dup 2))\n+\t\t   (match_dup 1)))\n+      (clobber (reg:CC FLAGS_REG))])]\n+{\n+  operands[0] = lowpart_subreg (SImode, operands[0], <MODE>mode);\n+  if (MEM_P (operands[1]))\n+    operands[1] = force_reg (<MODE>mode, operands[1]);\n+  operands[1] = lowpart_subreg (SImode, operands[1], <MODE>mode);\n+})\n+\n+(define_insn_and_split \"*btr<mode>_2\"\n+  [(set (zero_extract:HI\n+\t  (match_operand:SWI12 0 \"nonimmediate_operand\")\n+\t  (const_int 1)\n+\t  (zero_extend:SI (match_operand:QI 1 \"register_operand\")))\n+\t(const_int 0))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_USE_BT && ix86_pre_reload_split ()\"\n+  \"#\"\n+  \"&& MEM_P (operands[0])\"\n+  [(set (match_dup 2) (match_dup 0))\n+   (parallel\n+     [(set (match_dup 3)\n+\t   (and:SI (rotate:SI (const_int -2) (match_dup 1))\n+\t\t   (match_dup 4)))\n+      (clobber (reg:CC FLAGS_REG))])\n+   (set (match_dup 0) (match_dup 5))]\n+{\n+  operands[2] = gen_reg_rtx (<MODE>mode);\n+  operands[5] = gen_reg_rtx (<MODE>mode);\n+  operands[3] = lowpart_subreg (SImode, operands[5], <MODE>mode);\n+  operands[4] = lowpart_subreg (SImode, operands[2], <MODE>mode);\n+})\n+\n+(define_split\n+  [(set (zero_extract:HI\n+\t  (match_operand:SWI12 0 \"register_operand\")\n+\t  (const_int 1)\n+\t  (zero_extend:SI (match_operand:QI 1 \"register_operand\")))\n+\t(const_int 0))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_USE_BT && ix86_pre_reload_split ()\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (and:SI (rotate:SI (const_int -2) (match_dup 1))\n+\t\t   (match_dup 2)))\n+      (clobber (reg:CC FLAGS_REG))])]\n+{\n+  operands[2] = lowpart_subreg (SImode, operands[0], <MODE>mode);\n+  operands[0] = lowpart_subreg (SImode, operands[0], <MODE>mode);\n+})\n+\n ;; These instructions are never faster than the corresponding\n ;; and/ior/xor operations when using immediate operand, so with\n ;; 32-bit there's no point.  But in 64-bit, we can't hold the"}, {"sha": "832cdd4737ac4e34f167e4cb9f7d1d3b5747c7ed", "filename": "gcc/testsuite/gcc.target/i386/pr96938.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d057bfeff70e5b8d00e521844c476f62d51e22c/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr96938.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d057bfeff70e5b8d00e521844c476f62d51e22c/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr96938.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr96938.c?ref=5d057bfeff70e5b8d00e521844c476f62d51e22c", "patch": "@@ -0,0 +1,66 @@\n+/* PR target/96938 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -masm=att\" } */\n+/* { dg-final { scan-assembler-times \"\\tbtrl\\t\" 10 } } */\n+\n+void\n+f1 (unsigned char *f, int o, unsigned char v)\n+{\n+  *f = (*f & ~(1 << o)) | (v << o);\n+}\n+\n+void\n+f2 (unsigned char *f, int o, unsigned char v)\n+{\n+  int t = *f & ~(1 << o);\n+  *f = t | (v << o);\n+}\n+\n+void\n+f3 (unsigned char *f, int o, unsigned char v)\n+{\n+  *f &= ~(1 << o);\n+}\n+\n+void\n+f4 (unsigned char *f, int o, unsigned char v)\n+{\n+  *f = (*f & ~(1 << (o & 31))) | v;\n+}\n+\n+void\n+f5 (unsigned char *f, int o, unsigned char v)\n+{\n+  *f = (*f & ~(1 << (o & 31))) | (v << (o & 31));\n+}\n+\n+void\n+f6 (unsigned short *f, int o, unsigned short v)\n+{\n+  *f = (*f & ~(1 << o)) | (v << o);\n+}\n+\n+void\n+f7 (unsigned short *f, int o, unsigned short v)\n+{\n+  int t = *f & ~(1 << o);\n+  *f = t | (v << o);\n+}\n+\n+void\n+f8 (unsigned short *f, int o, unsigned short v)\n+{\n+  *f &= ~(1 << o);\n+}\n+\n+void\n+f9 (unsigned short *f, int o, unsigned short v)\n+{\n+  *f = (*f & ~(1 << (o & 31))) | v;\n+}\n+\n+void\n+f10 (unsigned short *f, int o, unsigned short v)\n+{\n+  *f = (*f & ~(1 << (o & 31))) | (v << (o & 31));\n+}"}]}