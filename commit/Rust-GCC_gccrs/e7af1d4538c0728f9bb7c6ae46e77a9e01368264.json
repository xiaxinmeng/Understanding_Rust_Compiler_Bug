{"sha": "e7af1d4538c0728f9bb7c6ae46e77a9e01368264", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTdhZjFkNDUzOGMwNzI4ZjliYjdjNmFlNDZlNzdhOWUwMTM2ODI2NA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-10-28T02:30:03Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-10-28T02:30:03Z"}, "message": "dwarf2out.c (reg_number): Abort if pseudo.\n\n\t* dwarf2out.c (reg_number): Abort if pseudo.\n\t(reg_loc_descriptor): Return 0 if pseudo.\n\t(is_based_loc): Return 0 if pseudo.\n\t(mem_loc_descriptor): Return 0 for pseudo and handle 0 return from\n\trecursive calls.\n\t(concat_loc_descriptor): Return 0 if either part's descriptor is 0.\n\t(loc_descriptor): Return 0 if can't find location and handle 0\n\treturn from recursive calls.\n\t(loc_descriptor_from_tree): Likewise.\n\tFix handling of indirect.\n\tAlso return 0 for PLACEHOLDER_EXPR.\n\tClean up COMPONENT_REF cases.\n\t(add_AT_location_descriptor): Simplify, but handle 0 return from\n\tloc_descriptor.\n\t(add_const_value_attribute): Avoid shift count warning.\n\t(add_bound_info): Remove test for PLACEHOLDER_EXPR here.\n\tSet comp_unit_die as context if not in function.\n\nFrom-SVN: r46573", "tree": {"sha": "84b13627d1c6001f7953f404983fd8eaccd21c4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/84b13627d1c6001f7953f404983fd8eaccd21c4d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e7af1d4538c0728f9bb7c6ae46e77a9e01368264", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7af1d4538c0728f9bb7c6ae46e77a9e01368264", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7af1d4538c0728f9bb7c6ae46e77a9e01368264", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7af1d4538c0728f9bb7c6ae46e77a9e01368264/comments", "author": null, "committer": null, "parents": [{"sha": "6b7d57c7e7f79fbbe3798f783b799c0f386d7286", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b7d57c7e7f79fbbe3798f783b799c0f386d7286", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b7d57c7e7f79fbbe3798f783b799c0f386d7286"}], "stats": {"total": 280, "additions": 165, "deletions": 115}, "files": [{"sha": "17056d5363c00a77427eab90c8ab545722eb38a9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7af1d4538c0728f9bb7c6ae46e77a9e01368264/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7af1d4538c0728f9bb7c6ae46e77a9e01368264/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e7af1d4538c0728f9bb7c6ae46e77a9e01368264", "patch": "@@ -1,5 +1,23 @@\n Sat Oct 27 17:32:04 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n+\t* dwarf2out.c (reg_number): Abort if pseudo.\n+\t(reg_loc_descriptor): Return 0 if pseudo.\n+\t(is_based_loc): Return 0 if pseudo.\n+\t(mem_loc_descriptor): Return 0 for pseudo and handle 0 return from\n+\trecursive calls.\n+\t(concat_loc_descriptor): Return 0 if either part's descriptor is 0.\n+\t(loc_descriptor): Return 0 if can't find location and handle 0\n+\treturn from recursive calls.\n+\t(loc_descriptor_from_tree): Likewise.\n+\tFix handling of indirect.\n+\tAlso return 0 for PLACEHOLDER_EXPR.\n+\tClean up COMPONENT_REF cases.\n+\t(add_AT_location_descriptor): Simplify, but handle 0 return from\n+\tloc_descriptor.\n+\t(add_const_value_attribute): Avoid shift count warning.\n+\t(add_bound_info): Remove test for PLACEHOLDER_EXPR here.\n+\tSet comp_unit_die as context if not in function.\n+\n \t* config/mips/mips-protos.h: Break up long lines.\n \tRemove needless #ifdef/#endif blocks.\n \tDon't declare functions declared in file made by genpreds or recog.h."}, {"sha": "052f52b79c53382d85a972912ce8d3e772022d16", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 147, "deletions": 115, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7af1d4538c0728f9bb7c6ae46e77a9e01368264/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7af1d4538c0728f9bb7c6ae46e77a9e01368264/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=e7af1d4538c0728f9bb7c6ae46e77a9e01368264", "patch": "@@ -7438,24 +7438,25 @@ reg_number (rtl)\n   unsigned regno = REGNO (rtl);\n \n   if (regno >= FIRST_PSEUDO_REGISTER)\n-    {\n-      warning (\"internal regno botch: regno = %d\\n\", regno);\n-      regno = 0;\n-    }\n+    abort ();\n \n-  regno = DBX_REGISTER_NUMBER (regno);\n-  return regno;\n+  return DBX_REGISTER_NUMBER (regno);\n }\n \n-/* Return a location descriptor that designates a machine register.  */\n+/* Return a location descriptor that designates a machine register or\n+   zero if there is no such.  */\n \n static dw_loc_descr_ref\n reg_loc_descriptor (rtl)\n      rtx rtl;\n {\n   dw_loc_descr_ref loc_result = NULL;\n-  unsigned reg = reg_number (rtl);\n+  unsigned reg;\n \n+  if (REGNO (rtl) >= FIRST_PSEUDO_REGISTER)\n+    return 0;\n+\n+  reg = reg_number (rtl);\n   if (reg <= 31)\n     loc_result = new_loc_descr (DW_OP_reg0 + reg, 0, 0);\n   else\n@@ -7537,6 +7538,7 @@ is_based_loc (rtl)\n {\n     return (GET_CODE (rtl) == PLUS\n \t    && ((GET_CODE (XEXP (rtl, 0)) == REG\n+\t\t && REGNO (XEXP (rtl, 0)) < FIRST_PSEUDO_REGISTER\n \t\t && GET_CODE (XEXP (rtl, 1)) == CONST_INT)));\n }\n \n@@ -7551,14 +7553,17 @@ is_based_loc (rtl)\n    it into Dwarf postfix code as it goes.\n \n    MODE is the mode of the memory reference, needed to handle some\n-   autoincrement addressing modes.  */\n+   autoincrement addressing modes.\n+\n+   Return 0 if we can't represent the location.  */\n \n static dw_loc_descr_ref\n mem_loc_descriptor (rtl, mode)\n      rtx rtl;\n      enum machine_mode mode;\n {\n   dw_loc_descr_ref mem_loc_result = NULL;\n+\n   /* Note that for a dynamically sized array, the location we will generate a\n      description of here will be the lowest numbered location which is\n      actually within the array.  That's *not* necessarily the same as the\n@@ -7602,12 +7607,14 @@ mem_loc_descriptor (rtl, mode)\n          the object in question was allocated to a register (rather than in\n          memory) so DWARF consumers need to be aware of the subtle\n          distinction between OP_REG and OP_BASEREG.  */\n-      mem_loc_result = based_loc_descr (reg_number (rtl), 0);\n+      if (REGNO (rtl) < FIRST_PSEUDO_REGISTER)\n+\tmem_loc_result = based_loc_descr (reg_number (rtl), 0);\n       break;\n \n     case MEM:\n       mem_loc_result = mem_loc_descriptor (XEXP (rtl, 0), GET_MODE (rtl));\n-      add_loc_descr (&mem_loc_result, new_loc_descr (DW_OP_deref, 0, 0));\n+      if (mem_loc_result != 0)\n+\tadd_loc_descr (&mem_loc_result, new_loc_descr (DW_OP_deref, 0, 0));\n       break;\n \n     case LABEL_REF:\n@@ -7656,14 +7663,14 @@ mem_loc_descriptor (rtl, mode)\n       else\n \t{\n \t  mem_loc_result = mem_loc_descriptor (XEXP (rtl, 0), mode);\n+\t  if (mem_loc_result == 0)\n+\t    break;\n \n \t  if (GET_CODE (XEXP (rtl, 1)) == CONST_INT\n \t      && INTVAL (XEXP (rtl, 1)) >= 0)\n-\t    {\n-\t      add_loc_descr (&mem_loc_result,\n-\t\t\t     new_loc_descr (DW_OP_plus_uconst,\n-\t\t\t\t\t    INTVAL (XEXP (rtl, 1)), 0));\n-\t    }\n+\t    add_loc_descr (&mem_loc_result,\n+\t\t\t   new_loc_descr (DW_OP_plus_uconst,\n+\t\t\t\t\t  INTVAL (XEXP (rtl, 1)), 0));\n \t  else\n \t    {\n \t      add_loc_descr (&mem_loc_result,\n@@ -7675,14 +7682,20 @@ mem_loc_descriptor (rtl, mode)\n       break;\n \n     case MULT:\n-      /* If a pseudo-reg is optimized away, it is possible for it to\n-\t be replaced with a MEM containing a multiply.  */\n-      add_loc_descr (&mem_loc_result,\n-\t\t     mem_loc_descriptor (XEXP (rtl, 0), mode));\n-      add_loc_descr (&mem_loc_result,\n-\t\t     mem_loc_descriptor (XEXP (rtl, 1), mode));\n-      add_loc_descr (&mem_loc_result, new_loc_descr (DW_OP_mul, 0, 0));\n-      break;\n+      {\n+\t/* If a pseudo-reg is optimized away, it is possible for it to\n+\t   be replaced with a MEM containing a multiply.  */\n+\tdw_loc_descr_ref op0 = mem_loc_descriptor (XEXP (rtl, 0), mode);\n+\tdw_loc_descr_ref op1 = mem_loc_descriptor (XEXP (rtl, 1), mode);\n+\n+\tif (op0 == 0 || op1 == 0)\n+\t  break;\n+\n+\tmem_loc_result = op0;\n+\tadd_loc_descr (&mem_loc_result, op1);\n+\tadd_loc_descr (&mem_loc_result, new_loc_descr (DW_OP_mul, 0, 0));\n+\tbreak;\n+      }\n \n     case CONST_INT:\n       mem_loc_result = int_loc_descriptor (INTVAL (rtl));\n@@ -7703,18 +7716,21 @@ concat_loc_descriptor (x0, x1)\n      rtx x0, x1;\n {\n   dw_loc_descr_ref cc_loc_result = NULL;\n+  dw_loc_descr_ref x0_ref = loc_descriptor (x0);\n+  dw_loc_descr_ref x1_ref = loc_descriptor (x1);\n \n-  if (!is_pseudo_reg (x0)\n-      && (GET_CODE (x0) != MEM || !is_pseudo_reg (XEXP (x0, 0))))\n-    add_loc_descr (&cc_loc_result, loc_descriptor (x0));\n+  if (x0_ref == 0 || x1_ref == 0)\n+    return 0;\n+\n+  cc_loc_result = x0_ref;\n   add_loc_descr (&cc_loc_result,\n-\t         new_loc_descr (DW_OP_piece, GET_MODE_SIZE (GET_MODE (x0)), 0));\n+\t\t new_loc_descr (DW_OP_piece,\n+\t\t\t\tGET_MODE_SIZE (GET_MODE (x0)), 0));\n \n-  if (!is_pseudo_reg (x1)\n-      && (GET_CODE (x1) != MEM || !is_pseudo_reg (XEXP (x1, 0))))\n-    add_loc_descr (&cc_loc_result, loc_descriptor (x1));\n+  add_loc_descr (&cc_loc_result, x1_ref);\n   add_loc_descr (&cc_loc_result,\n-\t\t new_loc_descr (DW_OP_piece, GET_MODE_SIZE (GET_MODE (x1)), 0));\n+\t\t new_loc_descr (DW_OP_piece,\n+\t\t\t\tGET_MODE_SIZE (GET_MODE (x1)), 0));\n \n   return cc_loc_result;\n }\n@@ -7723,13 +7739,16 @@ concat_loc_descriptor (x0, x1)\n    which is either allocated in a register or in a memory location.  For a\n    register, we just generate an OP_REG and the register number.  For a\n    memory location we provide a Dwarf postfix expression describing how to\n-   generate the (dynamic) address of the object onto the address stack.  */\n+   generate the (dynamic) address of the object onto the address stack.\n+\n+   If we don't know how to describe it, return 0.  */\n \n static dw_loc_descr_ref\n loc_descriptor (rtl)\n      rtx rtl;\n {\n   dw_loc_descr_ref loc_result = NULL;\n+\n   switch (GET_CODE (rtl))\n     {\n     case SUBREG:\n@@ -7762,15 +7781,17 @@ loc_descriptor (rtl)\n }\n \n /* Similar, but generate the descriptor from trees instead of rtl.\n-   This comes up particularly with variable length arrays.  */\n+   This comes up particularly with variable length arrays.  If ADDRESSP\n+   is nonzero, we are looking for an address.  Otherwise, we return a\n+   value.  If we can't find a value, return 0.  */\n \n static dw_loc_descr_ref\n loc_descriptor_from_tree (loc, addressp)\n      tree loc;\n      int addressp;\n {\n-  dw_loc_descr_ref ret = NULL;\n-  int indirect_size = 0;\n+  dw_loc_descr_ref ret, ret1;\n+  int indirect_p = 0;\n   int unsignedp = TREE_UNSIGNED (TREE_TYPE (loc));\n   enum dwarf_location_atom op;\n \n@@ -7781,35 +7802,36 @@ loc_descriptor_from_tree (loc, addressp)\n   switch (TREE_CODE (loc))\n     {\n     case ERROR_MARK:\n-      break;\n+      return 0;\n \n     case WITH_RECORD_EXPR:\n+    case PLACEHOLDER_EXPR:\n       /* This case involves extracting fields from an object to determine the\n \t position of other fields.  We don't try to encode this here.  The\n \t only user of this is Ada, which encodes the needed information using\n \t the names of types.  */\n-      return ret;\n+      return 0;\n \n     case VAR_DECL:\n     case PARM_DECL:\n       {\n \trtx rtl = rtl_for_decl_location (loc);\n-\tenum machine_mode mode = DECL_MODE (loc);\n+\tenum machine_mode mode = GET_MODE (rtl);\n \n \tif (rtl == NULL_RTX)\n-\t  break;\n+\t  return 0;\n \telse if (CONSTANT_P (rtl))\n \t  {\n \t    ret = new_loc_descr (DW_OP_addr, 0, 0);\n \t    ret->dw_loc_oprnd1.val_class = dw_val_class_addr;\n \t    ret->dw_loc_oprnd1.v.val_addr = rtl;\n-\t    indirect_size = GET_MODE_SIZE (mode);\n+\t    indirect_p = 1;\n \t  }\n \telse\n \t  {\n \t    if (GET_CODE (rtl) == MEM)\n \t      {\n-\t\tindirect_size = GET_MODE_SIZE (mode);\n+\t\tindirect_p = 1;\n \t\trtl = XEXP (rtl, 0);\n \t      }\n \t    ret = mem_loc_descriptor (rtl, mode);\n@@ -7819,7 +7841,7 @@ loc_descriptor_from_tree (loc, addressp)\n \n     case INDIRECT_REF:\n       ret = loc_descriptor_from_tree (TREE_OPERAND (loc, 0), 0);\n-      indirect_size = GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (loc)));\n+      indirect_p = 1;\n       break;\n \n     case NOP_EXPR:\n@@ -7841,7 +7863,15 @@ loc_descriptor_from_tree (loc, addressp)\n \n \tobj = get_inner_reference (loc, &bitsize, &bitpos, &offset, &mode,\n \t\t\t\t   &unsignedp, &volatilep, &alignment);\n+\n+\tif (obj == loc)\n+\t  return 0;\n+\n \tret = loc_descriptor_from_tree (obj, 1);\n+\tif (ret == 0\n+\t    || bitpos % BITS_PER_UNIT != 0\n+\t    || bitsize % BITS_PER_UNIT != 0)\n+\t  return 0;\n \n \tif (offset != NULL_TREE)\n \t  {\n@@ -7850,24 +7880,8 @@ loc_descriptor_from_tree (loc, addressp)\n \t    add_loc_descr (&ret, new_loc_descr (DW_OP_plus, 0, 0));\n \t  }\n \n-\tif (addressp)\n-\t  {\n-\t    /* We cannot address anything not on a unit boundary.  */\n-\t    if (bitpos % BITS_PER_UNIT != 0)\n-\t      abort ();\n-\t  }\n-\telse\n-\t  {\n-\t    if (bitpos % BITS_PER_UNIT != 0\n-\t\t|| bitsize % BITS_PER_UNIT != 0)\n-\t      {\n-\t\t/* ??? We could handle this by loading and shifting etc.\n-\t\t   Wait until someone needs it before expending the effort.  */\n-\t\tabort ();\n-\t      }\n-\n-\t    indirect_size = bitsize / BITS_PER_UNIT;\n-\t  }\n+\tif (!addressp)\n+\t  indirect_p = 1;\n \n \tbytepos = bitpos / BITS_PER_UNIT;\n \tif (bytepos > 0)\n@@ -7883,94 +7897,127 @@ loc_descriptor_from_tree (loc, addressp)\n     case INTEGER_CST:\n       if (host_integerp (loc, 0))\n \tret = int_loc_descriptor (tree_low_cst (loc, 0));\n+      else\n+\treturn 0;\n       break;\n \n     case BIT_AND_EXPR:\n       op = DW_OP_and;\n       goto do_binop;\n+\n     case BIT_XOR_EXPR:\n       op = DW_OP_xor;\n       goto do_binop;\n+\n     case BIT_IOR_EXPR:\n       op = DW_OP_or;\n       goto do_binop;\n+\n     case TRUNC_DIV_EXPR:\n       op = DW_OP_div;\n       goto do_binop;\n+\n     case MINUS_EXPR:\n       op = DW_OP_minus;\n       goto do_binop;\n+\n     case TRUNC_MOD_EXPR:\n       op = DW_OP_mod;\n       goto do_binop;\n+\n     case MULT_EXPR:\n       op = DW_OP_mul;\n       goto do_binop;\n+\n     case LSHIFT_EXPR:\n       op = DW_OP_shl;\n       goto do_binop;\n+\n     case RSHIFT_EXPR:\n       op = (unsignedp ? DW_OP_shr : DW_OP_shra);\n       goto do_binop;\n+\n     case PLUS_EXPR:\n       if (TREE_CODE (TREE_OPERAND (loc, 1)) == INTEGER_CST\n \t  && host_integerp (TREE_OPERAND (loc, 1), 0))\n \t{\n \t  ret = loc_descriptor_from_tree (TREE_OPERAND (loc, 0), 0);\n+\t  if (ret == 0)\n+\t    return 0;\n+\n \t  add_loc_descr (&ret,\n \t\t\t new_loc_descr (DW_OP_plus_uconst,\n \t\t\t\t\ttree_low_cst (TREE_OPERAND (loc, 1),\n \t\t\t\t\t\t      0),\n \t\t\t\t\t0));\n \t  break;\n \t}\n+\n       op = DW_OP_plus;\n       goto do_binop;\n     case LE_EXPR:\n       if (TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (loc, 0))))\n-\tbreak;\n+\treturn 0;\n+\n       op = DW_OP_le;\n       goto do_binop;\n+\n     case GE_EXPR:\n       if (TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (loc, 0))))\n-\tbreak;\n+\treturn 0;\n+\n       op = DW_OP_ge;\n       goto do_binop;\n+\n     case LT_EXPR:\n       if (TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (loc, 0))))\n-\tbreak;\n+\treturn 0;\n+\n       op = DW_OP_lt;\n       goto do_binop;\n+\n     case GT_EXPR:\n       if (TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (loc, 0))))\n-\tbreak;\n+\treturn 0;\n+\n       op = DW_OP_gt;\n       goto do_binop;\n+\n     case EQ_EXPR:\n       op = DW_OP_eq;\n       goto do_binop;\n+\n     case NE_EXPR:\n       op = DW_OP_ne;\n       goto do_binop;\n \n     do_binop:\n       ret = loc_descriptor_from_tree (TREE_OPERAND (loc, 0), 0);\n-      add_loc_descr (&ret, loc_descriptor_from_tree (TREE_OPERAND (loc, 1), 0));\n+      ret1 = loc_descriptor_from_tree (TREE_OPERAND (loc, 1), 0);\n+      if (ret == 0 || ret1 == 0)\n+\treturn 0;\n+\n+      add_loc_descr (&ret, ret1);\n       add_loc_descr (&ret, new_loc_descr (op, 0, 0));\n       break;\n \n     case BIT_NOT_EXPR:\n       op = DW_OP_not;\n       goto do_unop;\n+\n     case ABS_EXPR:\n       op = DW_OP_abs;\n       goto do_unop;\n+\n     case NEGATE_EXPR:\n       op = DW_OP_neg;\n       goto do_unop;\n \n     do_unop:\n       ret = loc_descriptor_from_tree (TREE_OPERAND (loc, 0), 0);\n+      if (ret == 0)\n+\treturn 0;\n+\n       add_loc_descr (&ret, new_loc_descr (op, 0, 0));\n       break;\n \n@@ -7983,21 +8030,26 @@ loc_descriptor_from_tree (loc, addressp)\n \n     case COND_EXPR:\n       {\n+\tdw_loc_descr_ref lhs\n+\t  = loc_descriptor_from_tree (TREE_OPERAND (loc, 1), 0);\n+\tdw_loc_descr_ref rhs\n+\t  = loc_descriptor_from_tree (TREE_OPERAND (loc, 2), 0);\n \tdw_loc_descr_ref bra_node, jump_node, tmp;\n \n \tret = loc_descriptor_from_tree (TREE_OPERAND (loc, 0), 0);\n+\tif (ret == 0 || lhs == 0 || rhs == 0)\n+\t  return 0;\n+\n \tbra_node = new_loc_descr (DW_OP_bra, 0, 0);\n \tadd_loc_descr (&ret, bra_node);\n \n-\ttmp = loc_descriptor_from_tree (TREE_OPERAND (loc, 2), 0);\n-\tadd_loc_descr (&ret, tmp);\n+\tadd_loc_descr (&ret, rhs);\n \tjump_node = new_loc_descr (DW_OP_skip, 0, 0);\n \tadd_loc_descr (&ret, jump_node);\n \n-\ttmp = loc_descriptor_from_tree (TREE_OPERAND (loc, 1), 0);\n-\tadd_loc_descr (&ret, tmp);\n+\tadd_loc_descr (&ret, lhs);\n \tbra_node->dw_loc_oprnd1.val_class = dw_val_class_loc;\n-\tbra_node->dw_loc_oprnd1.v.val_loc = tmp;\n+\tbra_node->dw_loc_oprnd1.v.val_loc = lhs;\n \n \t/* ??? Need a node to point the skip at.  Use a nop.  */\n \ttmp = new_loc_descr (DW_OP_nop, 0, 0);\n@@ -8011,20 +8063,23 @@ loc_descriptor_from_tree (loc, addressp)\n       abort ();\n     }\n \n-  /* If we can't fill the request for an address, die.  */\n-  if (addressp && indirect_size == 0)\n-    abort ();\n+  /* Show if we can't fill the request for an address.  */\n+  if (addressp && indirect_p == 0)\n+    return 0;\n \n   /* If we've got an address and don't want one, dereference.  */\n-  if (!addressp && indirect_size > 0)\n+  if (!addressp && indirect_p > 0)\n     {\n-      if (indirect_size > DWARF2_ADDR_SIZE)\n-\tabort ();\n-      if (indirect_size == DWARF2_ADDR_SIZE)\n+      HOST_WIDE_INT size = int_size_in_bytes (TREE_TYPE (loc));\n+\n+      if (size > DWARF2_ADDR_SIZE || size == -1)\n+\treturn 0;\n+      if (size == DWARF2_ADDR_SIZE)\n \top = DW_OP_deref;\n       else\n \top = DW_OP_deref_size;\n-      add_loc_descr (&ret, new_loc_descr (op, indirect_size, 0));\n+\n+      add_loc_descr (&ret, new_loc_descr (op, size, 0));\n     }\n \n   return ret;\n@@ -8240,31 +8295,10 @@ add_AT_location_description (die, attr_kind, rtl)\n      enum dwarf_attribute attr_kind;\n      rtx rtl;\n {\n-  /* Handle a special case.  If we are about to output a location descriptor\n-     for a variable or parameter which has been optimized out of existence,\n-     don't do that.  A variable which has been optimized out\n-     of existence will have a DECL_RTL value which denotes a pseudo-reg.\n-     Currently, in some rare cases, variables can have DECL_RTL values which\n-     look like (MEM (REG pseudo-reg#)).  These cases are due to bugs\n-     elsewhere in the compiler.  We treat such cases as if the variable(s) in\n-     question had been optimized out of existence.  */\n-\n-  if (is_pseudo_reg (rtl)\n-      || (GET_CODE (rtl) == MEM\n-\t  && is_pseudo_reg (XEXP (rtl, 0)))\n-      /* This can happen for a PARM_DECL with a DECL_INCOMING_RTL which\n-\t references the internal argument pointer (a pseudo) in a function\n-\t where all references to the internal argument pointer were\n-\t eliminated via the optimizers.  */\n-      || (GET_CODE (rtl) == MEM\n-\t  && GET_CODE (XEXP (rtl, 0)) == PLUS\n-\t  && is_pseudo_reg (XEXP (XEXP (rtl, 0), 0)))\n-      || (GET_CODE (rtl) == CONCAT\n-\t  && is_pseudo_reg (XEXP (rtl, 0))\n-\t  && is_pseudo_reg (XEXP (rtl, 1))))\n-    return;\n+  dw_loc_descr_ref descr = loc_descriptor (rtl);\n \n-  add_AT_loc (die, attr_kind, loc_descriptor (rtl));\n+  if (descr != 0)\n+    add_AT_loc (die, attr_kind, descr);\n }\n \n /* Attach the specialized form of location attribute used for data\n@@ -8343,11 +8377,12 @@ add_const_value_attribute (die, rtl)\n \t  add_AT_int (die, DW_AT_const_value, (long) val);\n \telse if ((unsigned long) val == (unsigned HOST_WIDE_INT) val)\n \t  add_AT_unsigned (die, DW_AT_const_value, (unsigned long) val);\n-\telse if (2*HOST_BITS_PER_LONG == HOST_BITS_PER_WIDE_INT)\n-\t  add_AT_long_long (die, DW_AT_const_value,\n-\t\t\t    val >> HOST_BITS_PER_LONG, val);\n-\telse\n-\t  abort ();\n+#if HOST_BITS_PER_LONG * 2 == HOST_BITS_PER_WIDE_INT\n+\tadd_AT_long_long (die, DW_AT_const_value,\n+\t\t\t  val >> HOST_BITS_PER_LONG, val);\n+#else\n+\tabort ();\n+#endif\n       }\n       break;\n \n@@ -8710,12 +8745,6 @@ add_bound_info (subrange_die, bound_attr, bound)\n      enum dwarf_attribute bound_attr;\n      tree bound;\n {\n-  /* If this is an Ada unconstrained array type, then don't emit any debug\n-     info because the array bounds are unknown.  They are parameterized when\n-     the type is instantiated.  */\n-  if (contains_placeholder_p (bound))\n-    return;\n-\n   switch (TREE_CODE (bound))\n     {\n     case ERROR_MARK:\n@@ -8816,7 +8845,10 @@ add_bound_info (subrange_die, bound_attr, bound)\n \tif (loc == NULL)\n \t  break;\n \n-\tctx = lookup_decl_die (current_function_decl);\n+\tif (current_function_decl == 0)\n+\t  ctx = comp_unit_die;\n+\telse\n+\t  ctx = lookup_decl_die (current_function_decl);\n \n \tdecl_die = new_die (DW_TAG_variable, ctx);\n \tadd_AT_flag (decl_die, DW_AT_artificial, 1);"}]}