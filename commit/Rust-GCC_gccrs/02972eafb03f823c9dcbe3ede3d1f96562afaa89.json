{"sha": "02972eafb03f823c9dcbe3ede3d1f96562afaa89", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDI5NzJlYWZiMDNmODIzYzlkY2JlM2VkZTNkMWY5NjU2MmFmYWE4OQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2011-06-01T19:49:53Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2011-06-01T19:49:53Z"}, "message": "re PR target/45074 (GCC Segmentation fault - negating global register variables)\n\ngcc/\n\tPR target/45074\n\t* optabs.h (valid_multiword_target_p): Declare.\n\t* expmed.c (extract_bit_field_1): Check valid_multiword_target_p when\n\tdoing multi-word operations.\n\t* optabs.c (expand_binop): Likewise.\n\t(expand_doubleword_bswap): Likewise.\n\t(expand_absneg_bit): Likewise.\n\t(expand_unop): Likewise.\n\t(expand_copysign_bit): Likewise.\n\t(multiword_target_p): New function.\n\ngcc/testsuite/\n\tPR target/45074\n\t* gcc.target/mips/pr45074.c: New test.\n\nFrom-SVN: r174541", "tree": {"sha": "512555575631369514775396520cedb9467f1074", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/512555575631369514775396520cedb9467f1074"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/02972eafb03f823c9dcbe3ede3d1f96562afaa89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02972eafb03f823c9dcbe3ede3d1f96562afaa89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02972eafb03f823c9dcbe3ede3d1f96562afaa89", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02972eafb03f823c9dcbe3ede3d1f96562afaa89/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4d41c2d1ce6f01c53eb8941461b3047e8a6368f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d41c2d1ce6f01c53eb8941461b3047e8a6368f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d41c2d1ce6f01c53eb8941461b3047e8a6368f6"}], "stats": {"total": 78, "additions": 69, "deletions": 9}, "files": [{"sha": "85b68a744b0843c72346ba73dc26d410870cff5e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02972eafb03f823c9dcbe3ede3d1f96562afaa89/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02972eafb03f823c9dcbe3ede3d1f96562afaa89/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=02972eafb03f823c9dcbe3ede3d1f96562afaa89", "patch": "@@ -1,3 +1,16 @@\n+2011-06-01  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\tPR target/45074\n+\t* optabs.h (valid_multiword_target_p): Declare.\n+\t* expmed.c (extract_bit_field_1): Check valid_multiword_target_p when\n+\tdoing multi-word operations.\n+\t* optabs.c (expand_binop): Likewise.\n+\t(expand_doubleword_bswap): Likewise.\n+\t(expand_absneg_bit): Likewise.\n+\t(expand_unop): Likewise.\n+\t(expand_copysign_bit): Likewise.\n+\t(multiword_target_p): New function.\n+\n 2011-06-01  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \tPR rtl-optimization/48830"}, {"sha": "314fac79c284c679c43765ee1f00f33654a5381a", "filename": "gcc/expmed.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02972eafb03f823c9dcbe3ede3d1f96562afaa89/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02972eafb03f823c9dcbe3ede3d1f96562afaa89/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=02972eafb03f823c9dcbe3ede3d1f96562afaa89", "patch": "@@ -1341,7 +1341,7 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n       unsigned int nwords = (bitsize + (BITS_PER_WORD - 1)) / BITS_PER_WORD;\n       unsigned int i;\n \n-      if (target == 0 || !REG_P (target))\n+      if (target == 0 || !REG_P (target) || !valid_multiword_target_p (target))\n \ttarget = gen_reg_rtx (mode);\n \n       /* Indicate for flow that the entire target reg is being set.  */"}, {"sha": "224fb11b59b1210170b86a6fc5cb34c0df59c712", "filename": "gcc/optabs.c", "status": "modified", "additions": 40, "deletions": 8, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02972eafb03f823c9dcbe3ede3d1f96562afaa89/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02972eafb03f823c9dcbe3ede3d1f96562afaa89/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=02972eafb03f823c9dcbe3ede3d1f96562afaa89", "patch": "@@ -1537,7 +1537,10 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \n       /* If TARGET is the same as one of the operands, the REG_EQUAL note\n \t won't be accurate, so use a new target.  */\n-      if (target == 0 || target == op0 || target == op1)\n+      if (target == 0\n+\t  || target == op0\n+\t  || target == op1\n+\t  || !valid_multiword_target_p (target))\n \ttarget = gen_reg_rtx (mode);\n \n       start_sequence ();\n@@ -1605,7 +1608,10 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \n \t  /* If TARGET is the same as one of the operands, the REG_EQUAL note\n \t     won't be accurate, so use a new target.  */\n-\t  if (target == 0 || target == op0 || target == op1)\n+\t  if (target == 0\n+\t      || target == op0\n+\t      || target == op1\n+\t      || !valid_multiword_target_p (target))\n \t    target = gen_reg_rtx (mode);\n \n \t  start_sequence ();\n@@ -1659,7 +1665,11 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \t opportunities, and second because if target and op0 happen to be MEMs\n \t designating the same location, we would risk clobbering it too early\n \t in the code sequence we generate below.  */\n-      if (target == 0 || target == op0 || target == op1 || ! REG_P (target))\n+      if (target == 0\n+\t  || target == op0\n+\t  || target == op1\n+\t  || !REG_P (target)\n+\t  || !valid_multiword_target_p (target))\n \ttarget = gen_reg_rtx (mode);\n \n       start_sequence ();\n@@ -1779,7 +1789,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \n       xtarget = gen_reg_rtx (mode);\n \n-      if (target == 0 || !REG_P (target))\n+      if (target == 0 || !REG_P (target) || !valid_multiword_target_p (target))\n \ttarget = xtarget;\n \n       /* Indicate for flow that the entire target reg is being set.  */\n@@ -2481,7 +2491,7 @@ expand_doubleword_bswap (enum machine_mode mode, rtx op, rtx target)\n   t0 = expand_unop (word_mode, bswap_optab,\n \t\t    operand_subword_force (op, 1, mode), NULL_RTX, true);\n \n-  if (target == 0)\n+  if (target == 0 || !valid_multiword_target_p (target))\n     target = gen_reg_rtx (mode);\n   if (REG_P (target))\n     emit_clobber (target);\n@@ -2724,7 +2734,9 @@ expand_absneg_bit (enum rtx_code code, enum machine_mode mode,\n   if (code == ABS)\n     mask = double_int_not (mask);\n \n-  if (target == 0 || target == op0)\n+  if (target == 0\n+      || target == op0\n+      || (nwords > 1 && !valid_multiword_target_p (target)))\n     target = gen_reg_rtx (mode);\n \n   if (nwords > 1)\n@@ -2915,7 +2927,7 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n       int i;\n       rtx insns;\n \n-      if (target == 0 || target == op0)\n+      if (target == 0 || target == op0 || !valid_multiword_target_p (target))\n \ttarget = gen_reg_rtx (mode);\n \n       start_sequence ();\n@@ -3386,7 +3398,10 @@ expand_copysign_bit (enum machine_mode mode, rtx op0, rtx op1, rtx target,\n \n   mask = double_int_setbit (double_int_zero, bitpos);\n \n-  if (target == 0 || target == op0 || target == op1)\n+  if (target == 0\n+      || target == op0\n+      || target == op1\n+      || (nwords > 1 && !valid_multiword_target_p (target)))\n     target = gen_reg_rtx (mode);\n \n   if (nwords > 1)\n@@ -7034,6 +7049,23 @@ insn_operand_matches (enum insn_code icode, unsigned int opno, rtx operand)\n \t      (operand, insn_data[(int) icode].operand[opno].mode)));\n }\n \f\n+/* TARGET is a target of a multiword operation that we are going to\n+   implement as a series of word-mode operations.  Return true if\n+   TARGET is suitable for this purpose.  */\n+\n+bool\n+valid_multiword_target_p (rtx target)\n+{\n+  enum machine_mode mode;\n+  int i;\n+\n+  mode = GET_MODE (target);\n+  for (i = 0; i < GET_MODE_SIZE (mode); i += UNITS_PER_WORD)\n+    if (!validate_subreg (word_mode, mode, target, i))\n+      return false;\n+  return true;\n+}\n+\n /* Like maybe_legitimize_operand, but do not change the code of the\n    current rtx value.  */\n "}, {"sha": "62bc14e484034f33983753c0ce1b7490e554f104", "filename": "gcc/optabs.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02972eafb03f823c9dcbe3ede3d1f96562afaa89/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02972eafb03f823c9dcbe3ede3d1f96562afaa89/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=02972eafb03f823c9dcbe3ede3d1f96562afaa89", "patch": "@@ -1059,6 +1059,8 @@ create_integer_operand (struct expand_operand *op, HOST_WIDE_INT intval)\n   create_expand_operand (op, EXPAND_INTEGER, GEN_INT (intval), VOIDmode, false);\n }\n \n+extern bool valid_multiword_target_p (rtx);\n+\n extern bool maybe_legitimize_operands (enum insn_code icode,\n \t\t\t\t       unsigned int opno, unsigned int nops,\n \t\t\t\t       struct expand_operand *ops);"}, {"sha": "7e90e17f08400526d0f903fa74e9badc5c2f0dc8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02972eafb03f823c9dcbe3ede3d1f96562afaa89/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02972eafb03f823c9dcbe3ede3d1f96562afaa89/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=02972eafb03f823c9dcbe3ede3d1f96562afaa89", "patch": "@@ -1,3 +1,8 @@\n+2011-06-01  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\tPR target/45074\n+\t* gcc.target/mips/pr45074.c: New test.\n+\n 2011-06-01  Eric Botcazou  <ebotcazou@adacore.com>\n \t    Hans-Peter Nilsson  <hp@axis.com>\n "}, {"sha": "ba578c838c15742ed1a8d883f561f997aaa5ec5b", "filename": "gcc/testsuite/gcc.target/mips/pr45074.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02972eafb03f823c9dcbe3ede3d1f96562afaa89/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fpr45074.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02972eafb03f823c9dcbe3ede3d1f96562afaa89/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fpr45074.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fpr45074.c?ref=02972eafb03f823c9dcbe3ede3d1f96562afaa89", "patch": "@@ -0,0 +1,8 @@\n+/* { dg-options \"-mhard-float -mgp32 -O\" } */\n+register double g __asm__(\"$f20\");\n+\n+NOMIPS16 void\n+test (double a)\n+{\n+  g = -a;\n+}"}]}