{"sha": "956a5206b05d26a2b9bc52813eeeb1686279caa1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTU2YTUyMDZiMDVkMjZhMmI5YmM1MjgxM2VlZWIxNjg2Mjc5Y2FhMQ==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1995-11-30T20:31:06Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1995-11-30T20:31:06Z"}, "message": "(insn-attr.h): Include.\n\n(pragma_nosave_low_regs): New global variable.\n(calc_live_regs): If SH3 and pragma_nosave_low_regs, then don't\nsave registers r0 through r7 for interrupt functions.\n(function_epilogue): Clear pragma_nosave_low_regs.\n(handle_pragma): Set pragma_nosave_low_regs if see pragma for it.\n\nFrom-SVN: r10649", "tree": {"sha": "0381a6eb514d956a2d8275e75c4b435f1d701a8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0381a6eb514d956a2d8275e75c4b435f1d701a8d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/956a5206b05d26a2b9bc52813eeeb1686279caa1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/956a5206b05d26a2b9bc52813eeeb1686279caa1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/956a5206b05d26a2b9bc52813eeeb1686279caa1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/956a5206b05d26a2b9bc52813eeeb1686279caa1/comments", "author": null, "committer": null, "parents": [{"sha": "b6c9286a86e351a50cd49fc0cd8934d99875e14d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6c9286a86e351a50cd49fc0cd8934d99875e14d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6c9286a86e351a50cd49fc0cd8934d99875e14d"}], "stats": {"total": 22, "additions": 19, "deletions": 3}, "files": [{"sha": "f6ff44c94e866cd8f1641d9a2d8d211ed782679d", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/956a5206b05d26a2b9bc52813eeeb1686279caa1/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/956a5206b05d26a2b9bc52813eeeb1686279caa1/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=956a5206b05d26a2b9bc52813eeeb1686279caa1", "patch": "@@ -33,6 +33,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n #include \"output.h\"\n+#include \"insn-attr.h\"\n \n #define MSW (TARGET_LITTLE_ENDIAN ? 1 : 0)\n #define LSW (TARGET_LITTLE_ENDIAN ? 0 : 1)\n@@ -46,6 +47,13 @@ int pragma_interrupt;\n    the compiler doesn't emit code to preserve all registers.  */\n static int pragma_trapa;\n \n+/* This is set by #pragma nosave_low_regs.  This is useful on the SH3,\n+   which has a separate set of low regs for User and Supervisor modes.\n+   This should only be used for the lowest level of interrupts.  Higher levels\n+   of interrupts must save the registers in case they themselves are\n+   interrupted.  */\n+int pragma_nosave_low_regs;\n+\n /* This is used for communication between SETUP_INCOMING_VARARGS and\n    sh_expand_prologue.  */\n int current_function_anonymous_args;\n@@ -1509,11 +1517,14 @@ calc_live_regs (count_ptr)\n     {\n       if (pragma_interrupt && ! pragma_trapa)\n \t{\n-\t  /* Need to save all the regs ever live.  */\n+\t  /* Normally, we must save all the regs ever live.\n+\t     If pragma_nosave_low_regs, then don't save any of the\n+\t     registers which are banked on the SH3.  */\n \t  if ((regs_ever_live[reg]\n \t       || (call_used_regs[reg] && regs_ever_live[PR_REG]))\n \t      && reg != STACK_POINTER_REGNUM && reg != ARG_POINTER_REGNUM\n-\t      && reg != T_REG && reg != GBR_REG)\n+\t      && reg != T_REG && reg != GBR_REG\n+\t      && ! (sh_cpu == CPU_SH3 && pragma_nosave_low_regs && reg < 8))\n \t    {\n \t      live_regs_mask |= 1 << reg;\n \t      count++;\n@@ -1613,7 +1624,7 @@ function_epilogue (stream, size)\n      FILE *stream;\n      int size;\n {\n-  pragma_interrupt = pragma_trapa = 0;\n+  pragma_interrupt = pragma_trapa = pragma_nosave_low_regs = 0;\n }\n \n /* Define the offset between two registers, one to be eliminated, and\n@@ -1675,6 +1686,11 @@ handle_pragma (file)\n \t  pragma_interrupt = pragma_trapa = 1;\n \t  return ' ';\n \t}\n+      if (psize == 15 && strncmp (pbuf, \"nosave_low_regs\", 15) == 0)\n+\t{\n+\t  pragma_nosave_low_regs = 1;\n+\t  return ' ';\n+\t}\n       c = getc (file);\n     }\n   return c;"}]}