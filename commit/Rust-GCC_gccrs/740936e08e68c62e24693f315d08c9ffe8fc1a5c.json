{"sha": "740936e08e68c62e24693f315d08c9ffe8fc1a5c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQwOTM2ZTA4ZTY4YzYyZTI0NjkzZjMxNWQwOGM5ZmZlOGZjMWE1Yw==", "commit": {"author": {"name": "Johannes Singler", "email": "singler@ira.uka.de", "date": "2007-10-25T17:07:56Z"}, "committer": {"name": "Johannes Singler", "email": "singler@gcc.gnu.org", "date": "2007-10-25T17:07:56Z"}, "message": "multiway_merge.h: Removed Timing<inactive_tag>\n\n2007-10-25  Johannes Singler  <singler@ira.uka.de>\n\n      * include/parallel/multiway_merge.h: Removed Timing<inactive_tag>\n      * include/parallel/random_shuffle.h: Same\n      * include/parallel/set_operations.h: Same\n      * include/parallel/tree.h: Same\n      * include/parallel/multiway_mergesort.h: Same\n      * include/parallel/timing.h: Removed completely\n\nFrom-SVN: r129629", "tree": {"sha": "72bfb00d3daea603a29f58c55c510abe1b9e3ae5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/72bfb00d3daea603a29f58c55c510abe1b9e3ae5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/740936e08e68c62e24693f315d08c9ffe8fc1a5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/740936e08e68c62e24693f315d08c9ffe8fc1a5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/740936e08e68c62e24693f315d08c9ffe8fc1a5c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/740936e08e68c62e24693f315d08c9ffe8fc1a5c/comments", "author": null, "committer": null, "parents": [{"sha": "8d358a4aae876bfa44501f8d2830564fbe6f1cdd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d358a4aae876bfa44501f8d2830564fbe6f1cdd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d358a4aae876bfa44501f8d2830564fbe6f1cdd"}], "stats": {"total": 364, "additions": 9, "deletions": 355}, "files": [{"sha": "a588ed935cd3111da873c6045a4efc8261a7d09f", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/740936e08e68c62e24693f315d08c9ffe8fc1a5c/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/740936e08e68c62e24693f315d08c9ffe8fc1a5c/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=740936e08e68c62e24693f315d08c9ffe8fc1a5c", "patch": "@@ -1,3 +1,12 @@\n+2007-10-25  Johannes Singler  <singler@ira.uka.de>\n+\n+      * include/parallel/multiway_merge.h: Removed Timing<inactive_tag>\n+      * include/parallel/random_shuffle.h: Same\n+      * include/parallel/set_operations.h: Same\n+      * include/parallel/tree.h: Same\n+      * include/parallel/multiway_mergesort.h: Same\n+      * include/parallel/timing.h: Removed completely\n+\n 2007-10-25  Paolo Carlini  <pcarlini@suse.de>\n \n \t* include/bits/stl_algo.h (__lg<>(_Size)): Slightly tweak."}, {"sha": "c7d317a519a8594890835886efac02857157236b", "filename": "libstdc++-v3/include/parallel/multiway_merge.h", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/740936e08e68c62e24693f315d08c9ffe8fc1a5c/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_merge.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/740936e08e68c62e24693f315d08c9ffe8fc1a5c/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_merge.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_merge.h?ref=740936e08e68c62e24693f315d08c9ffe8fc1a5c", "patch": "@@ -52,7 +52,6 @@\n #include <parallel/parallel.h>\n #include <parallel/merge.h>\n #include <parallel/losertree.h>\n-#include <parallel/timing.h>\n #if _GLIBCXX_ASSERTIONS\n #include <parallel/checkers.h>\n #endif\n@@ -1354,11 +1353,6 @@ namespace __gnu_parallel\n \n     thread_index_t num_threads = static_cast<thread_index_t>(std::min(static_cast<difference_type>(get_max_threads()), total_length));\n \n-    Timing<sequential_tag>* t = new Timing<sequential_tag>[num_threads];\n-\n-    for (int pr = 0; pr < num_threads; pr++)\n-      t[pr].tic();\n-\n     bool tight = (total_length == length);\n \n     // Thread t will have to merge pieces[iam][0..k - 1]\n@@ -1456,15 +1450,10 @@ namespace __gnu_parallel\n \tdelete[] offsets;\n       }\n \n-    for (int pr = 0; pr < num_threads; pr++)\n-      t[pr].tic();\n-\n #\tpragma omp parallel num_threads(num_threads)\n     {\n       thread_index_t iam = omp_get_thread_num();\n \n-      t[iam].tic();\n-\n       difference_type target_position = 0;\n \n       for (int c = 0; c < k; c++)\n@@ -1498,14 +1487,8 @@ namespace __gnu_parallel\n \t\t\t(pieces[iam][0].second - pieces[iam][0].first) + (pieces[iam][1].second - pieces[iam][1].first),\n \t\t\tcomp);\n \t}\n-\n-      t[iam].tic();\n-\n     }\n \n-    for (int pr = 0; pr < num_threads; pr++)\n-      t[pr].tic();\n-\n #if _GLIBCXX_ASSERTIONS\n     _GLIBCXX_PARALLEL_ASSERT(is_sorted(target, target + length, comp));\n #endif\n@@ -1516,12 +1499,6 @@ namespace __gnu_parallel\n \n     delete[] pieces;\n \n-    for (int pr = 0; pr < num_threads; pr++)\n-      t[pr].tic();\n-    for (int pr = 0; pr < num_threads; pr++)\n-      t[pr].print();\n-    delete[] t;\n-\n     return target + length;\n   }\n "}, {"sha": "89285e163898b13aeb845a5adfdb567330354bdd", "filename": "libstdc++-v3/include/parallel/multiway_mergesort.h", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/740936e08e68c62e24693f315d08c9ffe8fc1a5c/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_mergesort.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/740936e08e68c62e24693f315d08c9ffe8fc1a5c/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_mergesort.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_mergesort.h?ref=740936e08e68c62e24693f315d08c9ffe8fc1a5c", "patch": "@@ -44,7 +44,6 @@\n #include <bits/stl_algo.h>\n #include <parallel/parallel.h>\n #include <parallel/multiway_merge.h>\n-#include <parallel/timing.h>\n \n namespace __gnu_parallel\n {\n@@ -160,9 +159,6 @@ namespace __gnu_parallel\n     typedef typename traits_type::value_type value_type;\n     typedef typename traits_type::difference_type difference_type;\n \n-    Timing<sequential_tag> t;\n-    t.tic();\n-\n     PMWMSSortingData<RandomAccessIterator>* sd = d->sd;\n     thread_index_t iam = d->iam;\n \n@@ -196,7 +192,6 @@ namespace __gnu_parallel\n \n     // Invariant: locally sorted subsequence in sd->sorting_places[iam],\n     // sd->sorting_places[iam] + length_local.\n-    t.tic(\"local sort\");\n \n     if (Settings::sort_splitting == Settings::SAMPLING)\n       {\n@@ -205,8 +200,6 @@ namespace __gnu_parallel\n \n #pragma omp barrier\n \n-\tt.tic(\"sample/wait\");\n-\n #pragma omp single\n \t__gnu_sequential::sort(sd->samples, \n \t\t\t       sd->samples + (num_samples * d->num_threads), \n@@ -241,8 +234,6 @@ namespace __gnu_parallel\n       {\n #pragma omp barrier\n \n-\tt.tic(\"wait\");\n-\n \tstd::vector<std::pair<SortingPlacesIterator, SortingPlacesIterator> > seqs(d->num_threads);\n \tfor (int s = 0; s < d->num_threads; s++)\n \t  seqs[s] = std::make_pair(sd->sorting_places[s], sd->sorting_places[s] + sd->starts[s + 1] - sd->starts[s]);\n@@ -276,8 +267,6 @@ namespace __gnu_parallel\n \t  }\n       }\n \n-    t.tic(\"split\");\n-\n     // Offset from target begin, length after merging.\n     difference_type offset = 0, length_am = 0;\n     for (int s = 0; s < d->num_threads; s++)\n@@ -308,8 +297,6 @@ namespace __gnu_parallel\n \n     multiway_merge(seqs.begin(), seqs.end(), sd->merging_places[iam], comp, length_am, d->stable, false, sequential_tag());\n \n-    t.tic(\"merge\");\n-\n #if _GLIBCXX_ASSERTIONS\n     _GLIBCXX_PARALLEL_ASSERT(is_sorted(sd->merging_places[iam], sd->merging_places[iam] + length_am, comp));\n #endif\n@@ -323,10 +310,6 @@ namespace __gnu_parallel\n #endif\n \n     delete[] sd->temporaries[iam];\n-\n-    t.tic(\"copy back\");\n-\n-    t.print();\n   }\n \n   /** @brief PMWMS main call."}, {"sha": "933ab3e8a8ee09be3bd2ec748fcc562bbc1e33dd", "filename": "libstdc++-v3/include/parallel/random_shuffle.h", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/740936e08e68c62e24693f315d08c9ffe8fc1a5c/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_shuffle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/740936e08e68c62e24693f315d08c9ffe8fc1a5c/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_shuffle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_shuffle.h?ref=740936e08e68c62e24693f315d08c9ffe8fc1a5c", "patch": "@@ -42,7 +42,6 @@\n #include <bits/stl_numeric.h>\n #include <parallel/parallel.h>\n #include <parallel/random_number.h>\n-#include <parallel/timing.h>\n \n namespace __gnu_parallel\n {\n@@ -136,9 +135,6 @@ namespace __gnu_parallel\n     typedef typename traits_type::value_type value_type;\n     typedef typename traits_type::difference_type difference_type;\n \n-    Timing<sequential_tag> t;\n-    t.tic();\n-\n     DRSSorterPU<RandomAccessIterator, RandomNumberGenerator>* d = &pus[omp_get_thread_num()];\n     DRandomShufflingGlobalData<RandomAccessIterator>* sd = d->sd;\n     thread_index_t iam = d->iam;\n@@ -170,12 +166,8 @@ namespace __gnu_parallel\n     for (bin_index b = 0; b < sd->num_bins + 1; b++)\n       sd->dist[b][iam + 1] = dist[b];\n \n-    t.tic();\n-\n #pragma omp barrier\n \n-    t.tic();\n-\n #pragma omp single\n     {\n       // Sum up bins, sd->dist[s + 1][d->num_threads] now contains the\n@@ -188,8 +180,6 @@ namespace __gnu_parallel\n \n #pragma omp barrier\n \n-    t.tic();\n-\n     sequence_index_t offset = 0, global_offset = 0;\n     for (bin_index s = 0; s < d->bins_begin; s++)\n       global_offset += sd->dist[s + 1][d->num_threads];\n@@ -205,12 +195,8 @@ namespace __gnu_parallel\n \n     sd->temporaries[iam] = static_cast<value_type*>(::operator new(sizeof(value_type) * offset));\n \n-    t.tic();\n-\n #pragma omp barrier\n \n-    t.tic();\n-\n     // Draw local copies to avoid false sharing.\n     for (bin_index b = 0; b < sd->num_bins + 1; b++)\n       dist[b] = sd->dist[b][iam];\n@@ -237,12 +223,8 @@ namespace __gnu_parallel\n     delete[] bin_proc;\n     delete[] temporaries;\n \n-    t.tic();\n-\n #pragma omp barrier\n \n-    t.tic();\n-\n     // Shuffle bins internally.\n     for (bin_index b = d->bins_begin; b < d->bins_end; b++)\n       {\n@@ -253,10 +235,6 @@ namespace __gnu_parallel\n       }\n \n     delete[] sd->temporaries[iam];\n-\n-    t.tic();\n-\n-    t.print();\n   }\n \n   /** @brief Round up to the next greater power of 2.\n@@ -453,9 +431,6 @@ namespace __gnu_parallel\n \tfor (int b = 0; b < num_bins + 1; b++)\n \t  dist0[b] = 0;\n \n-\tTiming<sequential_tag> t;\n-\tt.tic();\n-\n \trandom_number bitrng(rng(0xFFFFFFFF));\n \n \tfor (difference_type i = 0; i < n; i++)\n@@ -467,16 +442,12 @@ namespace __gnu_parallel\n \t    dist0[oracle + 1]++;\n \t  }\n \n-\tt.tic();\n-\n \t// Sum up bins.\n \t__gnu_sequential::partial_sum(dist0, dist0 + num_bins + 1, dist0);\n \n \tfor (int b = 0; b < num_bins + 1; b++)\n \t  dist1[b] = dist0[b];\n \n-\tt.tic();\n-\n \t// Distribute according to oracles.\n \tfor (difference_type i = 0; i < n; i++)\n \t  target[(dist0[oracles[i]])++] = *(begin + i);\n@@ -485,9 +456,7 @@ namespace __gnu_parallel\n \t  {\n \t    sequential_random_shuffle(target + dist1[b], target + dist1[b + 1],\n \t\t\t\t      rng);\n-\t    t.tic();\n \t  }\n-\tt.print();\n \n \tdelete[] dist0;\n \tdelete[] dist1;"}, {"sha": "2a16691459a914ac047df164347071209759a040", "filename": "libstdc++-v3/include/parallel/set_operations.h", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/740936e08e68c62e24693f315d08c9ffe8fc1a5c/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fset_operations.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/740936e08e68c62e24693f315d08c9ffe8fc1a5c/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fset_operations.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fset_operations.h?ref=740936e08e68c62e24693f315d08c9ffe8fc1a5c", "patch": "@@ -381,10 +381,6 @@ namespace __gnu_parallel\n \n #pragma omp parallel num_threads(num_threads)\n     {\n-      Timing<sequential_tag> t;\n-\n-      t.tic();\n-\n       // Result from multiseq_partition.\n       InputIterator offset[2];\n       const int iam = omp_get_thread_num();\n@@ -407,13 +403,9 @@ namespace __gnu_parallel\n \n       iterator_pair block_end = block_begins[ iam + 1 ] = iterator_pair(offset[ 0 ], offset[ 1 ]);\n \n-      t.tic();\n-\n       // Make sure all threads have their block_begin result written out.\n #pragma omp barrier\n \n-      t.tic();\n-\n       iterator_pair block_begin = block_begins[ iam ];\n \n       // Begin working for the first block, while the others except\n@@ -429,12 +421,9 @@ namespace __gnu_parallel\n \t\t\t\t   block_begin.second, block_end.second);\n \t}\n \n-      t.tic();\n-\n       // Make sure everyone wrote their lengths.\n #pragma omp barrier\n \n-      t.tic();\n       OutputIterator r = result;\n \n       if (iam == 0)\n@@ -458,9 +447,6 @@ namespace __gnu_parallel\n \t  op.invoke(block_begin.first, block_end.first,\n \t\t    block_begin.second, block_end.second, r);\n \t}\n-\n-      t.tic();\n-      t.print();\n     }\n     return return_value;\n   }"}, {"sha": "f1f75225c156eab16c581fe5a35e61bcf9cb4d12", "filename": "libstdc++-v3/include/parallel/timing.h", "status": "removed", "additions": 0, "deletions": 217, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d358a4aae876bfa44501f8d2830564fbe6f1cdd/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftiming.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d358a4aae876bfa44501f8d2830564fbe6f1cdd/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftiming.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftiming.h?ref=8d358a4aae876bfa44501f8d2830564fbe6f1cdd", "patch": "@@ -1,217 +0,0 @@\n-// -*- C++ -*-\n-\n-// Copyright (C) 2007 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the terms\n-// of the GNU General Public License as published by the Free Software\n-// Foundation; either version 2, or (at your option) any later\n-// version.\n-\n-// This library is distributed in the hope that it will be useful, but\n-// WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-// General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with this library; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-// MA 02111-1307, USA.\n-\n-// As a special exception, you may use this file as part of a free\n-// software library without restriction.  Specifically, if other files\n-// instantiate templates or use macros or inline functions from this\n-// file, or you compile this file and link it with other files to\n-// produce an executable, this file does not by itself cause the\n-// resulting executable to be covered by the GNU General Public\n-// License.  This exception does not however invalidate any other\n-// reasons why the executable file might be covered by the GNU General\n-// Public License.\n-\n-/** @file parallel/timing.h\n- *  @brief Provides a simple tool to do performance debugging, also in\n- *  parallel code.\n- *  This file is a GNU parallel extension to the Standard C++ Library.\n- */\n-\n-// Written by Johannes Singler.\n-\n-#ifndef _GLIBCXX_PARALLEL_TIMING_H\n-#define _GLIBCXX_PARALLEL_TIMING_H 1\n-\n-#include <omp.h>\n-#include <cstdio>\n-#include <cstring>\n-#include <parallel/tags.h>\n-\n-namespace __gnu_parallel\n-{\n-  // XXX integrate with existing performance testing infrastructure.\n-  /** @brief Type of of point in time, used for the Timing classes. */\n-  typedef double point_in_time;\n-\n-  template<typename tag, typename must_be_int = int>\n-  class Timing;\n-\n-  /** @brief A class that provides simple run time measurements, also\n-      for parallel code.\n-   *  @param tag If parallel_tag, then the measurements are actually done.\n-   *  Otherwise, no code at all is emitted by the compiler. */\n-  template<typename must_be_int>\n-  class Timing<parallel_tag, must_be_int>\n-  {\n-  private:\n-    static const int max_points_in_time = 100;\n-    point_in_time points_in_time[max_points_in_time];\n-    point_in_time active, last_start;\n-    int pos;\n-    char* str;\n-    const char* tags[max_points_in_time];\n-\n-  public:\n-    Timing()\n-    {\n-      str = NULL;\n-      pos = 0;\n-      active = 0.0;\n-      last_start = -1.0;\n-    }\n-\n-    ~Timing()\n-    {\n-      delete[] str;\n-    }\n-\n-    /** @brief Take a running time measurement.\n-     *  @param tag Optional description that will be output again with\n-     *  the timings.\n-     *  It should describe the operation before the tic(). To time a\n-     *  series of @c n operations, there should be @c n+1 calls to\n-     *  tic(), and one call to print(). */\n-    inline void\n-    tic(const char* tag = NULL)\n-    {\n-      points_in_time[pos] = omp_get_wtime();\n-      tags[pos] = tag;\n-      pos++;\n-    }\n-\n-    /** @brief Start the running time measurement.\n-     *\n-     *  Should be paired with stop(). */\n-    inline void\n-    start()\n-    {\n-      _GLIBCXX_PARALLEL_ASSERT(last_start == -1.0);\n-      last_start = omp_get_wtime();\n-    }\n-\n-    /** @brief Stop the running time measurement.\n-     *\n-     *  Should be paired with start(). */\n-    inline void\n-    stop()\n-    {\n-      _GLIBCXX_PARALLEL_ASSERT(last_start != -1.0);\n-      active += (omp_get_wtime() - last_start);\n-      last_start = -1.0;\n-    }\n-\n-    /** @brief Reset running time accumulation. */\n-    inline void\n-    reset()\n-    {\n-      active = 0.0;\n-      last_start = -1.0;\n-    }\n-\n-    /** @brief Accumulate the time between all pairs of start() and\n-\tstop() so far */\n-    inline point_in_time\n-    active_time()\n-    { return active; }\n-\n-    /** @brief Total time between first and last tic() */\n-    inline point_in_time\n-    total_time()\n-    { return (points_in_time[pos - 1] - points_in_time[0]) * 1000.0; }\n-\n-  private:\n-    /** @brief Construct string to print out, presenting the timings. */\n-    const char*\n-    c_str()\n-    {\n-      // Avoid stream library here, to avoid cyclic dependencies in\n-      // header files.\n-      char tmp[1000];\n-\n-      if (!str)\n-\tstr = new char[pos * 200];\n-      else\n-\tstr[0] = '\\0';\n-\n-      sprintf(str, \"t %2d      T[ms]\", omp_get_thread_num());\n-      strcat(str, \"\\n\");\n-\n-      for (int i = 0; i < pos; )\n-\t{\n-\t  point_in_time last = points_in_time[i];\n-\t  i++;\n-\t  if (i == pos)\n-\t    break;\n-\t  if (tags[i] == NULL)\n-\t    sprintf(tmp, \"%2d:     \", i - 1);\n-\t  else\n-\t    sprintf(tmp, \"%20s:     \", tags[i]);\n-\t  strcat(str, tmp);\n-\n-\t  sprintf(tmp, \"%7.2f     \", (points_in_time[i] - last) * 1000.0);\n-\t  strcat(str, tmp);\n-\t  strcat(str, \"\\n\");\n-\t}\n-\n-      return str;\n-    }\n-\n-  public:\n-    /** @brief Print the running times between the tic()s. */\n-    void\n-    print()\n-    {\n-      printf(\"print\\n\");\n-#pragma omp barrier\n-#pragma omp master\n-      printf(\"\\n\\n\");\n-#pragma omp critical\n-      printf(\"%s\\n\", c_str());\n-    }\n-  };\n-\n-  /** @brief A class that provides simple run time measurements, also\n-      for parallel code.\n-   *  @param tag If parallel_tag, then the measurements are actually done,\n-   *  otherwise, no code at all is emitted by the compiler.\n-   */\n-  template<typename must_be_int>\n-  class Timing<sequential_tag, must_be_int>\n-  {\n-  private:\n-    static const char* empty_string;\n-\n-  public:\n-    inline void tic(const char* /*tag*/ = NULL) { }\n-    inline void start() { }\n-    inline void stop() { }\n-    inline void reset() { }\n-    inline point_in_time active_time() { return -1.0; }\n-    inline point_in_time total_time() { return -1.0; }\n-    inline const char* c_str() { return empty_string; }\n-    inline void print() { }\n-  };\n-\n-  template<typename must_be_int>\n-  const char* Timing<sequential_tag, must_be_int>::empty_string = \"\";\n-\n-}\n-\n-#endif"}, {"sha": "eae33c0cba25a5007d8fac4e0df60d2f1f2b5787", "filename": "libstdc++-v3/include/parallel/tree.h", "status": "modified", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/740936e08e68c62e24693f315d08c9ffe8fc1a5c/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/740936e08e68c62e24693f315d08c9ffe8fc1a5c/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftree.h?ref=740936e08e68c62e24693f315d08c9ffe8fc1a5c", "patch": "@@ -57,13 +57,6 @@\n \n #include <parallel/list_partition.h>\n \n-//#define _GLIBCXX_TIMING\n-#ifdef _GLIBCXX_TIMING\n-#define _timing_tag parallel_tag\n-#else\n-#define _timing_tag sequential_tag\n-#endif\n-\n namespace std\n {\n   // XXX Declaration should go to stl_tree.h.\n@@ -1217,19 +1210,13 @@ namespace __gnu_parallel\n     void\n     _M_bulk_insertion_construction(const _InputIterator __first, const _InputIterator __last, const bool is_construction, StrictlyLessOrLessEqual strictly_less_or_less_equal)\n     {\n-      Timing<_timing_tag> t;\n-\n-      t.tic();\n-\n       thread_index_t num_threads = get_max_threads();\n       size_type n;\n       size_type beg_partition[num_threads+1];\n       _InputIterator access[num_threads+1];\n       beg_partition[0] = 0;\n       bool is_sorted= is_sorted_distance_accessors(__first, __last, access, beg_partition,n, num_threads, std::__iterator_category(__first));\n \n-      t.tic(\"is_sorted\");\n-\n       if (not is_sorted)\n \t{\n \t  _M_not_sorted_bulk_insertion_construction(access, beg_partition, n, num_threads, is_construction, strictly_less_or_less_equal);\n@@ -1260,10 +1247,6 @@ namespace __gnu_parallel\n \t    _M_sorted_bulk_insertion(access, beg_partition, n, num_threads, \n \t\t\t\t     strictly_less_or_less_equal);\n \t}\n-\n-      t.tic(\"main work\");\n-\n-      t.print();\n     }\n \n     /** @brief Bulk construction and insertion helper method on an\n@@ -1349,31 +1332,19 @@ namespace __gnu_parallel\n     _M_not_sorted_bulk_insertion_construction(size_type* beg_partition, ElementsToSort* v, Comparator comp, const size_type n, thread_index_t num_threads, const bool is_construction, StrictlyLessOrLessEqual strictly_less_or_less_equal)\n     {\n       // The accessors have been calculated for the non sorted.\n-      Timing<_timing_tag> t;\n-\n-      t.tic();\n-\n       num_threads = static_cast<thread_index_t>(std::min<size_type>(num_threads, n));\n \n       std::stable_sort(v, v+n, comp);\n \n-      t.tic(\"sort\");\n-\n       IteratorSortedElements sorted_access[num_threads+1];\n       range_accessors(IteratorSortedElements(v), IteratorSortedElements(v+n), sorted_access, beg_partition, n, num_threads, std::__iterator_category(v));\n \n-      t.tic(\"range_accessors\");\n-\n       // Partial template specialization not available.\n       if (is_construction)\n \t_M_sorted_bulk_construction(sorted_access, beg_partition, n, num_threads, strictly_less_or_less_equal);\n       else\n \t_M_sorted_bulk_insertion(sorted_access, beg_partition, n, num_threads, strictly_less_or_less_equal);\n       delete v;\n-\n-      t.tic(\"actual construction or insertion\");\n-\n-      t.print();\n     }\n \n     /** @brief Construct a tree sequentially using the parallel routine\n@@ -1753,17 +1724,11 @@ namespace __gnu_parallel\n     void\n     _M_sorted_bulk_construction(_Iterator* access, size_type* beg_partition, const size_type n, thread_index_t num_threads, StrictlyLessOrLessEqual strictly_less_or_less_equal)\n     {\n-      Timing<_timing_tag> t;\n-\n       // Dealing with repetitions (EFFICIENCY ISSUE).\n       size_type rank_shift[num_threads+1];\n \n-      t.tic();\n-\n       _Rb_tree_node_ptr* r = _M_sorted_bulk_allocation_and_initialization(access, beg_partition, rank_shift, n, num_threads, strictly_less_or_less_equal);\n \n-      t.tic(\"bulk allocation and initialization\");\n-\n       // Link the tree appropriately.\n       // Dealing with repetitions (EFFICIENCY ISSUE).\n       ranker_gaps rank(beg_partition, rank_shift, num_threads);\n@@ -1818,11 +1783,7 @@ namespace __gnu_parallel\n       base_type::_M_impl._M_header._M_parent = nodes_init.get_root();\n       nodes_init.get_root()->_M_parent= &base_type::_M_impl._M_header;\n \n-      t.tic(\"linking nodes\");\n       ::operator delete(r);\n-\n-      t.tic(\"delete array of pointers\");\n-      t.print();\n     }\n \n \n@@ -1850,10 +1811,6 @@ namespace __gnu_parallel\n     _M_sorted_bulk_insertion(_Iterator* access, size_type* beg_partition, size_type k, thread_index_t num_threads, StrictlyLessOrLessEqual strictly_less_or_less_equal)\n     {\n       _GLIBCXX_PARALLEL_ASSERT((size_type)num_threads <= k);\n-      Timing<_timing_tag> t;\n-\n-      t.tic();\n-\n       // num_thr-1 problems in the upper part of the tree\n       // num_thr problems to further parallelize\n       std::vector<size_type> existing(num_threads,0);\n@@ -1873,7 +1830,6 @@ namespace __gnu_parallel\n \t  // 1. Construct the nodes with their corresponding data\n #if _GLIBCXX_TREE_INITIAL_SPLITTING\n \t  r = _M_sorted_bulk_allocation_and_initialization(access, beg_partition, rank_shift, k, num_threads, strictly_less_or_less_equal);\n-\t  t.tic(\"bulk allocation and initialization\");\n #else\n \t  r = _M_sorted_no_gapped_bulk_allocation_and_initialization(access, beg_partition, k, num_threads, strictly_less_or_less_equal);\n #endif\n@@ -1896,8 +1852,6 @@ namespace __gnu_parallel\n       repetitions (EFFICIENCY ISSUE) *****/\n       size_type last = beg_partition[num_threads] - (rank_shift[num_threads] - rank_shift[num_threads - 1]);\n \n-      t.tic(\"last element to be inserted\");\n-\n       //2. Split the tree according to access in num_threads parts\n       //Initialize upper concat_problems\n       //Allocate them dynamically because they are afterwards so erased\n@@ -1960,8 +1914,6 @@ namespace __gnu_parallel\n       size_type last = k;\n #endif\n \n-      t.tic(\"sorted_no_gapped...\");\n-\n       // 3. Split the range according to tree and create\n       // 3. insertion/concatenation problems to be solved in parallel\n #if _GLIBCXX_TREE_DYNAMIC_BALANCING\n@@ -2018,8 +1970,6 @@ namespace __gnu_parallel\n \t  } while (change);\n       }\n \n-      t.tic(\"merging\");\n-\n       // Update root and sizes.\n       base_type::_M_root() = root_problem->t;\n       root_problem->t->_M_parent = &(base_type::_M_impl._M_header);\n@@ -2069,9 +2019,6 @@ namespace __gnu_parallel\n \n       // Delete array of pointers\n       ::operator delete(r);\n-\n-      t.tic();\n-      t.print();\n     }\n \n "}]}