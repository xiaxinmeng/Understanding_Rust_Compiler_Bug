{"sha": "8af3f53d325fe4a6b1f3da64dc02d10978b9a116", "node_id": "C_kwDOANBUbNoAKDhhZjNmNTNkMzI1ZmU0YTZiMWYzZGE2NGRjMDJkMTA5NzhiOWExMTY", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-11-30T09:52:30Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-11-30T09:52:30Z"}, "message": "vect: Support masked gather loads with SLP\n\nThis patch extends the previous SLP gather load support so\nthat it can handle masked loads too.\n\ngcc/\n\t* tree-vect-slp.c (arg1_arg4_map): New variable.\n\t(vect_get_operand_map): Handle IFN_MASK_GATHER_LOAD.\n\t(vect_build_slp_tree_1): Likewise.\n\t(vect_build_slp_tree_2): Likewise.\n\t* tree-vect-stmts.c (vectorizable_load): Expect the mask to be\n\tthe last SLP child node rather than the first.\n\ngcc/testsuite/\n\t* gcc.dg/vect/vect-gather-3.c: New test.\n\t* gcc.dg/vect/vect-gather-4.c: Likewise.\n\t* gcc.target/aarch64/sve/mask_gather_load_8.c: Likewise.", "tree": {"sha": "216e2715a85af701255c8a76cda849bb6a351d2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/216e2715a85af701255c8a76cda849bb6a351d2e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8af3f53d325fe4a6b1f3da64dc02d10978b9a116", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8af3f53d325fe4a6b1f3da64dc02d10978b9a116", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8af3f53d325fe4a6b1f3da64dc02d10978b9a116", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8af3f53d325fe4a6b1f3da64dc02d10978b9a116/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "32ede1083fad4b68873bec3e5a775e2092d6566e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32ede1083fad4b68873bec3e5a775e2092d6566e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32ede1083fad4b68873bec3e5a775e2092d6566e"}], "stats": {"total": 213, "additions": 203, "deletions": 10}, "files": [{"sha": "738bd3f3106948754e38ffa93fec5097560511d3", "filename": "gcc/testsuite/gcc.dg/vect/vect-gather-3.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af3f53d325fe4a6b1f3da64dc02d10978b9a116/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-gather-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af3f53d325fe4a6b1f3da64dc02d10978b9a116/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-gather-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-gather-3.c?ref=8af3f53d325fe4a6b1f3da64dc02d10978b9a116", "patch": "@@ -0,0 +1,64 @@\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+\n+void __attribute__((noipa))\n+f (int *restrict y, int *restrict x, int *restrict indices)\n+{\n+  for (int i = 0; i < N; ++i)\n+    {\n+      y[i * 2] = (indices[i * 2] < N * 2\n+\t\t  ? x[indices[i * 2]] + 1\n+\t\t  : 1);\n+      y[i * 2 + 1] = (indices[i * 2 + 1] < N * 2\n+\t\t      ? x[indices[i * 2 + 1]] + 2\n+\t\t      : 2);\n+    }\n+}\n+\n+int y[N * 2];\n+int x[N * 2] = {\n+  72704, 52152, 51301, 96681,\n+  57937, 60490, 34504, 60944,\n+  42225, 28333, 88336, 74300,\n+  29250, 20484, 38852, 91536,\n+  86917, 63941, 31590, 21998,\n+  22419, 26974, 28668, 13968,\n+  3451, 20247, 44089, 85521,\n+  22871, 87362, 50555, 85939\n+};\n+int indices[N * 2] = {\n+  15, 0x10000, 0xcafe0, 19,\n+  7, 22, 19, 1,\n+  0x20000, 0x70000, 15, 30,\n+  5, 12, 11, 11,\n+  10, 25, 5, 20,\n+  22, 24, 32, 28,\n+  30, 19, 6, 0xabcdef,\n+  7, 12, 8, 21\n+};\n+int expected[N * 2] = {\n+  91537, 2, 1, 22000,\n+  60945, 28670, 21999, 52154,\n+  1, 2, 91537, 50557,\n+  60491, 29252, 74301, 74302,\n+  88337, 20249, 60491, 22421,\n+  28669, 3453, 1, 22873,\n+  50556, 22000, 34505, 2,\n+  60945, 29252, 42226, 26976\n+};\n+\n+int\n+main (void)\n+{\n+  check_vect ();\n+\n+  f (y, x, indices);\n+  for (int i = 0; i < 32; ++i)\n+    if (y[i] != expected[i])\n+      __builtin_abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump \"Loop contains only SLP stmts\" vect { target { vect_gather_load_ifn && vect_masked_load } } } } */"}, {"sha": "ee2e4e4999a8b8b826081eb166f206ecd88abda5", "filename": "gcc/testsuite/gcc.dg/vect/vect-gather-4.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af3f53d325fe4a6b1f3da64dc02d10978b9a116/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-gather-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af3f53d325fe4a6b1f3da64dc02d10978b9a116/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-gather-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-gather-4.c?ref=8af3f53d325fe4a6b1f3da64dc02d10978b9a116", "patch": "@@ -0,0 +1,48 @@\n+/* { dg-do compile } */\n+\n+#define N 16\n+\n+void\n+f1 (int *restrict y, int *restrict x1, int *restrict x2,\n+    int *restrict indices)\n+{\n+  for (int i = 0; i < N; ++i)\n+    {\n+      y[i * 2] = (indices[i * 2] < N * 2\n+\t\t  ? x1[indices[i * 2]] + 1\n+\t\t  : 1);\n+      y[i * 2 + 1] = (indices[i * 2 + 1] < N * 2\n+\t\t      ? x2[indices[i * 2 + 1]] + 2\n+\t\t      : 2);\n+    }\n+}\n+\n+void\n+f2 (int *restrict y, int *restrict x, int *restrict indices)\n+{\n+  for (int i = 0; i < N; ++i)\n+    {\n+      y[i * 2] = (indices[i * 2] < N * 2\n+\t\t  ? x[indices[i * 2]] + 1\n+\t\t  : 1);\n+      y[i * 2 + 1] = (indices[i * 2 + 1] < N * 2\n+\t\t      ? x[indices[i * 2 + 1] * 2] + 2\n+\t\t      : 2);\n+    }\n+}\n+\n+void\n+f3 (int *restrict y, int *restrict x, int *restrict indices)\n+{\n+  for (int i = 0; i < N; ++i)\n+    {\n+      y[i * 2] = (indices[i * 2] < N * 2\n+\t\t  ? x[indices[i * 2]] + 1\n+\t\t  : 1);\n+      y[i * 2 + 1] = (indices[i * 2 + 1] < N * 2\n+\t\t      ? x[(unsigned int) indices[i * 2 + 1]] + 2\n+\t\t      : 2);\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"Loop contains only SLP stmts\" vect { target vect_gather_load_ifn } } } */"}, {"sha": "95767f30a809051c8897a8b03d9efc1a80e68b9b", "filename": "gcc/testsuite/gcc.target/aarch64/sve/mask_gather_load_8.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af3f53d325fe4a6b1f3da64dc02d10978b9a116/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_gather_load_8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af3f53d325fe4a6b1f3da64dc02d10978b9a116/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_gather_load_8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_gather_load_8.c?ref=8af3f53d325fe4a6b1f3da64dc02d10978b9a116", "patch": "@@ -0,0 +1,65 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fno-vect-cost-model\" } */\n+\n+#include <stdint.h>\n+\n+void\n+f1 (int32_t *restrict y, int32_t *restrict x, int32_t *restrict index)\n+{\n+  for (int i = 0; i < 100; ++i)\n+    {\n+      y[i * 2] = (index[i * 2] < 128\n+\t\t  ? x[index[i * 2]] + 1\n+\t\t  : 1);\n+      y[i * 2 + 1] = (index[i * 2 + 1] < 128\n+\t\t      ? x[index[i * 2 + 1]] + 2\n+\t\t      : 2);\n+    }\n+}\n+\n+void\n+f2 (int32_t *restrict y, int32_t *restrict x, uint32_t *restrict index)\n+{\n+  for (int i = 0; i < 100; ++i)\n+    {\n+      y[i * 2] = (index[i * 2] < 128\n+\t\t  ? x[index[i * 2]] + 1\n+\t\t  : 1);\n+      y[i * 2 + 1] = (index[i * 2 + 1] < 128\n+\t\t      ? x[index[i * 2 + 1]] + 2\n+\t\t      : 2);\n+    }\n+}\n+\n+void\n+f3 (int32_t *restrict y, int32_t *restrict x, uint64_t *restrict index)\n+{\n+  for (int i = 0; i < 100; ++i)\n+    {\n+      y[i * 2] = (index[i * 2] < 128\n+\t\t  ? x[index[i * 2]] + 1\n+\t\t  : 1);\n+      y[i * 2 + 1] = (index[i * 2 + 1] < 128\n+\t\t      ? x[index[i * 2 + 1]] + 2\n+\t\t      : 2);\n+    }\n+}\n+\n+void\n+f4 (int64_t *restrict y, int64_t *restrict x, uint64_t *restrict index)\n+{\n+  for (int i = 0; i < 100; ++i)\n+    {\n+      y[i * 2] = (index[i * 2] < 128\n+\t\t  ? x[index[i * 2]] + 1\n+\t\t  : 1);\n+      y[i * 2 + 1] = (index[i * 2 + 1] < 128\n+\t\t      ? x[index[i * 2 + 1]] + 2\n+\t\t      : 2);\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tld1w\\tz[0-9]+\\.s, p[0-7]/z, \\[x[0-9]+, z[0-9]+\\.s, sxtw #?2\\]} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tld1w\\tz[0-9]+\\.s, p[0-7]/z, \\[x[0-9]+, z[0-9]+\\.s, uxtw #?2\\]} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tld1w\\tz[0-9]+\\.d, p[0-7]/z, \\[x[0-9]+, z[0-9]+\\.d, lsl #?2\\]} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tld1d\\tz[0-9]+\\.d, p[0-7]/z, \\[x[0-9]+, z[0-9]+\\.d, lsl #?3\\]} 1 } } */"}, {"sha": "7bff5118bd00c5ed660c35b02bf70b1bb4b31834", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af3f53d325fe4a6b1f3da64dc02d10978b9a116/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af3f53d325fe4a6b1f3da64dc02d10978b9a116/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=8af3f53d325fe4a6b1f3da64dc02d10978b9a116", "patch": "@@ -461,6 +461,7 @@ static const int cond_expr_maps[3][5] = {\n };\n static const int arg1_map[] = { 1, 1 };\n static const int arg2_map[] = { 1, 2 };\n+static const int arg1_arg4_map[] = { 2, 1, 4 };\n \n /* For most SLP statements, there is a one-to-one mapping between\n    gimple arguments and child nodes.  If that is not true for STMT,\n@@ -494,6 +495,9 @@ vect_get_operand_map (const gimple *stmt, unsigned char swap = 0)\n \t  case IFN_GATHER_LOAD:\n \t    return arg1_map;\n \n+\t  case IFN_MASK_GATHER_LOAD:\n+\t    return arg1_arg4_map;\n+\n \t  default:\n \t    break;\n \t  }\n@@ -1000,7 +1004,9 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n \t  else\n \t    rhs_code = CALL_EXPR;\n \n-\t  if (cfn == CFN_MASK_LOAD || cfn == CFN_GATHER_LOAD)\n+\t  if (cfn == CFN_MASK_LOAD\n+\t      || cfn == CFN_GATHER_LOAD\n+\t      || cfn == CFN_MASK_GATHER_LOAD)\n \t    load_p = true;\n \t  else if ((internal_fn_p (cfn)\n \t\t    && !vectorizable_internal_fn_p (as_internal_fn (cfn)))\n@@ -1229,7 +1235,9 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n         } /* Grouped access.  */\n       else\n \t{\n-\t  if (load_p && rhs_code != CFN_GATHER_LOAD)\n+\t  if (load_p\n+\t      && rhs_code != CFN_GATHER_LOAD\n+\t      && rhs_code != CFN_MASK_GATHER_LOAD)\n \t    {\n \t      /* Not grouped load.  */\n \t      if (dump_enabled_p ())\n@@ -1711,7 +1719,8 @@ vect_build_slp_tree_2 (vec_info *vinfo, slp_tree node,\n     {\n       if (gcall *stmt = dyn_cast <gcall *> (stmt_info->stmt))\n \tgcc_assert (gimple_call_internal_p (stmt, IFN_MASK_LOAD)\n-\t\t    || gimple_call_internal_p (stmt, IFN_GATHER_LOAD));\n+\t\t    || gimple_call_internal_p (stmt, IFN_GATHER_LOAD)\n+\t\t    || gimple_call_internal_p (stmt, IFN_MASK_GATHER_LOAD));\n       else\n \t{\n \t  *max_nunits = this_max_nunits;"}, {"sha": "8642acbc0b47012c831d3ebba1629b671018a6d0", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af3f53d325fe4a6b1f3da64dc02d10978b9a116/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af3f53d325fe4a6b1f3da64dc02d10978b9a116/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=8af3f53d325fe4a6b1f3da64dc02d10978b9a116", "patch": "@@ -8595,6 +8595,7 @@ vectorizable_load (vec_info *vinfo,\n     return false;\n \n   tree mask = NULL_TREE, mask_vectype = NULL_TREE;\n+  int mask_index = -1;\n   if (gassign *assign = dyn_cast <gassign *> (stmt_info->stmt))\n     {\n       scalar_dest = gimple_assign_lhs (assign);\n@@ -8626,12 +8627,12 @@ vectorizable_load (vec_info *vinfo,\n       if (!scalar_dest)\n \treturn false;\n \n-      int mask_index = internal_fn_mask_index (ifn);\n+      mask_index = internal_fn_mask_index (ifn);\n+      /* ??? For SLP the mask operand is always last.  */\n+      if (mask_index >= 0 && slp_node)\n+\tmask_index = SLP_TREE_CHILDREN (slp_node).length () - 1;\n       if (mask_index >= 0\n-\t  && !vect_check_scalar_mask (vinfo, stmt_info, slp_node,\n-\t\t\t\t      /* ??? For SLP we only have operands for\n-\t\t\t\t\t the mask operand.  */\n-\t\t\t\t      slp_node ? 0 : mask_index,\n+\t  && !vect_check_scalar_mask (vinfo, stmt_info, slp_node, mask_index,\n \t\t\t\t      &mask, NULL, &mask_dt, &mask_vectype))\n \treturn false;\n     }\n@@ -9393,8 +9394,14 @@ vectorizable_load (vec_info *vinfo,\n   vec<tree> vec_offsets = vNULL;\n   auto_vec<tree> vec_masks;\n   if (mask)\n-    vect_get_vec_defs (vinfo, stmt_info, slp_node, ncopies,\n-\t\t       mask, &vec_masks, mask_vectype, NULL_TREE);\n+    {\n+      if (slp_node)\n+\tvect_get_slp_defs (SLP_TREE_CHILDREN (slp_node)[mask_index],\n+\t\t\t   &vec_masks);\n+      else\n+\tvect_get_vec_defs_for_operand (vinfo, stmt_info, ncopies, mask,\n+\t\t\t\t       &vec_masks, mask_vectype);\n+    }\n   tree vec_mask = NULL_TREE;\n   poly_uint64 group_elt = 0;\n   for (j = 0; j < ncopies; j++)"}]}